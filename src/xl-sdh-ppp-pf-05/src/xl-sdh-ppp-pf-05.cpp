#define NEW_WSP_1102
//#define HPPPT1_V14_RECV                     /* 26.08.12 KB HOB-PPP-T1 V1.4 receive */
#define HPPPT1_V21                          /* 18.01.13 KB HOB-PPP-T1 V2.1 */
//#define DEBUG_101207_01
//#define DEBUG_101207_02
//#define DEBUG_101208_01
//#define CHECK_OUTPUT_01
//#define CHECK_OUTPUT_01
//#define TRY_101205
//#define TRACEHL1
//#define TRACEHL_DNS
//#define TRACEHL_090905
/*+-------------------------------------------------------------------+*/
/*|                                                                   |*/
/*| PROGRAM NAME: xl-sdh-ppp-pf-05                                    |*/
/*| -------------                                                     |*/
/*|  DLL / Library for HOB WebSecureProxy                             |*/
/*|    Server-Data-Hook                                               |*/
/*|  PPP Packet-Filter 05, client and server may use any INETA range  |*/
/*|  KB 23.10.10                                                      |*/
/*|                                                                   |*/
/*| COPYRIGHT:                                                        |*/
/*| ----------                                                        |*/
/*|  Copyright (C) HOB Germany 2010                                   |*/
/*|  Copyright (C) HOB Germany 2011                                   |*/
/*|  Copyright (C) HOB Germany 2012                                   |*/
/*|  Copyright (C) HOB Germany 2013                                   |*/
/*|                                                                   |*/
/*| REQUIRED PROGRAMS:                                                |*/
/*| ------------------                                                |*/
/*|  MS Visual Studio 2005 (VC8)                                      |*/
/*|  Unix / Linux GCC                                                 |*/
/*|                                                                   |*/
/*| FUNCTION:                                                         |*/
/*| ---------                                                         |*/
/*|                                                                   |*/
/*+-------------------------------------------------------------------+*/

/* #define TRACEHL1 */

/**
   bug detected 20.08.11 KB:
   at p_out_dns_20:  -- output stored DNS one entry --
   always one INETA is translated in the DNS response
   generated by this SDH.
   This is wrong in the following situations:
   1. when <DNS-ineta> is configured with multiple <ineta>,
      only the last INETA is translated.
   2. when <exclude-DNS-name> is configured, there is no INETA,
      so the packet is corrupted.
   For solutions and improvements see xl-sdh-ppp-pf-07.cpp
   21.08.11  KB
   ---
   possible bug detected 22.08.11 KB:
   when ALG-SIP is not configured, the program jumps to p_check_dns_00:
   there, the port is not checked correctly, as done at p_check_recv_80:
   23.08.11  KB
   --- old ---
   when data from client:
     first crosswise NAT
     second normal NAT
   when data from server:
     first normal NAT
     second crosswise NAT
*/

#ifdef TRACEHL_DNS
#ifndef TRACEHL_TIME
#define TRACEHL_TIME
#endif
#endif

#ifndef HL_LONGLONG
#ifndef HL_UNIX
#define HL_LONGLONG LONGLONG
#else
#define HL_LONGLONG long long int
#endif
#endif

#ifndef HL_UNIX
#define HL_WCSLEN( p ) wcslen( (WCHAR *) p )
#define HL_WCSCMP( p1, p2 ) wcscmp( (WCHAR *) p1, (WCHAR *) p2 )
#define HL_FN_WCSCMP( p1, p2 ) _wcsicmp( (WCHAR *) p1, (WCHAR *) p2 )
#define HL_NAME_WCSCMP( p1, p2 ) _wcsicmp( (WCHAR *) p1, (WCHAR *) p2 )
#else
#define HL_WCSLEN( p ) m_len_u16z( (HL_WCHAR *) p )
#define HL_WCSCMP( p1, p2 ) m_cmp_u16z_u16z( (HL_WCHAR *) p1, (HL_WCHAR *) p2 )
#define HL_FN_WCSCMP( p1, p2 ) m_cmp_u16z_u16z( (HL_WCHAR *) p1, (HL_WCHAR *) p2 )
#define HL_NAME_WCSCMP( p1, p2 ) m_cmpi_u16z_u16z( (HL_WCHAR *) p1, (HL_WCHAR *) p2 )
#endif

/*+-------------------------------------------------------------------+*/
/*| System and library header files.                                  |*/
/*+-------------------------------------------------------------------+*/

#include <stdlib.h>
#include <stddef.h>
#include <stdio.h>
#include <string.h>
#include <time.h>
#ifndef HL_UNIX
#include <conio.h>
#include <winsock2.h>
#include <ws2tcpip.h>
#include <windows.h>
#ifdef TRACEHL_TIME
#include <sys/timeb.h>
#endif
#else
#include <netinet/in.h>
#ifdef TRACEHL_TIME
#include <sys/time.h>
#endif
#include "hob-hunix01.h"
#endif
//#include "hob-xsclib01.h"
#include <hob-xslunic1.h>
#include <hob-tab-ascii-ansi-1.h>
#include <hob-tab-mime-base64.h>
#include <hob-netw-01.h>
#ifndef HL_UNIX
#include <hob-avl03.h>
#else
#include "hob-avl03.h"
#endif
#ifdef HL_FREEBSD
#include <sys/socket.h>
#endif

/*+-------------------------------------------------------------------+*/
/*| System and library header files for XERCES.                       |*/
/*+-------------------------------------------------------------------+*/

#include <xercesc/dom/DOMAttr.hpp>

#define DOMNode XERCES_CPP_NAMESPACE::DOMNode

/*+-------------------------------------------------------------------+*/
/*| header files for Server-Data-Hook.                                |*/
/*+-------------------------------------------------------------------+*/

#define DEF_HL_INCL_DOM
#include "hob-xsclib01.h"

#ifndef UNSIG_MED
#define UNSIG_MED unsigned int
#endif
#ifndef HL_WCHAR
#define HL_WCHAR unsigned short int
#endif

#ifdef OLD01
#ifndef HL_UNIX
#define D_CHARSET_IP ied_chs_ansi_819       /* ANSI 819                */
#else
#define D_CHARSET_IP ied_chs_ascii_850      /* ASCII 850               */
#endif
#endif

#define HL_MAX_LEN_PACKET      (16 * 1024)

#define LEN_INETA_PR_IPV4      15           /* length Internet Address print IPV4 */

#define MAX_DNS_INETA          32           /* maximum number of INETA in DNS response */
#ifdef B130118
#define MAX_DNS_QUEUED         8            /* maximum number of DNS responses queued */
#endif

#define DEF_INETA_TABLE_ORG    64           /* number of entries original table */
#define DEF_INETA_TABLE_EXT    32           /* number of entries extension */

#define MAX_LEN_NHASN          4            /* maximum length NHASN length */
#define D_POS_IPH_PROT         9            /* position protocol in IP header */
#define D_POS_IPH_DCHS         10           /* position checksum in IP header */
#define D_LEN_HEADER_IPV4      20           /* length of IPV4 header minimum */
#define D_LEN_HEADER_IPV6      40           /* length of IPV6 header   */
#define D_LEN_UDP_HEADER       8            /* length of UDP header    */
#define D_LEN_DNS_ID           sizeof(unsigned short int)  /* length of DNS Id */
#define D_EXT_SIP              64           /* SIP packet to be extended */
#define D_LEN_RESP_START       128          /* size maximum of RESPONSE-START */
//#define D_LEN_IP_H_P1          20           /* length of IP header part one */

#define CHAR_CR                0X0D         /* carriage-return         */
#define CHAR_LF                0X0A         /* line-feed               */
#define CHAR_TELNET_ESC        0XFF         /* telnet escape           */

struct dsd_sdh_call_1 {                     /* structure call in SDH   */
   BOOL (* amc_aux) ( void *, int, void *, int );  // Helper routine pointer
   void *     vpc_userfld;                  /* User Field Subroutine   */
};

struct dsd_clib1_conf {                     /* configuration data      */
   UNSIG_MED  umc_conf_ineta_1_lower;       /* configured INETAs 1 lower value */
   UNSIG_MED  umc_conf_ineta_1_upper;       /* configured INETAs 1 upper value */
   UNSIG_MED  umc_conf_ineta_1_mask;        /* configured INETAs 1 network mask */
   UNSIG_MED  umc_conf_ineta_2_lower;       /* configured INETAs 2 lower value */
   UNSIG_MED  umc_conf_ineta_2_upper;       /* configured INETAs 2 upper value */
   UNSIG_MED  umc_conf_ineta_2_mask;        /* configured INETAs 2 network mask */
#ifdef XYZ1
// 25.10.10 KB - remove imc_nat_e1
   int        imc_nat_e1;                   /* number of entries NAT   */
#endif
   int        imc_len_dns_resp;             /* length of DNS responses */
#ifdef XYZ1
// 25.10.10 KB - remove boc_cross_nat
   BOOL       boc_cross_nat;                /* use crosswise NAT       */
#endif
   BOOL       boc_alg_sip;                  /* use ALG for SIP VoIP protocol */
   BOOL       boc_disp_inetas;              /* display natted INETAs   */
#ifdef XYZ1
// 25.10.10 KB - remove umc_cnat_*
   UNSIG_MED  umc_cnat_ineta_real;          /* real INETA              */
   UNSIG_MED  umc_cnat_ineta_translated;    /* translated INETA        */
   UNSIG_MED  umc_cnat_mask_and_1;          /* mask for AND            */
   UNSIG_MED  umc_cnat_mask_and_2;          /* mask for AND            */
#endif
};

struct dsd_dns_resp_1 {                     /* structure DNS response  */
   int        imc_len_stor;                 /* storage reserved        */
   int        imc_len_entry;                /* length of entry         */
   int        imc_len_dns_n;                /* length DNS name         */
};

#ifdef B130118
struct dsd_query_dns_resp_1 {               /* structure query DNS response */
   UNSIG_MED  umc_ineta_source;             /* INETA source            */
   char       chrs_port_dest[2];            /* destination port        */
   char       chrs_id[2];                   /* transaction ID          */
   struct dsd_dns_resp_1 *adsc_dnsr1;       /* structure DNS response  */
};
#endif

struct dsd_ineta_ctl_1 {                    /* control INETA           */
   struct dsd_htree1_avl_entry dsc_sort_ineta;  /* entry for sorting INETAs */
   int        imc_ineta;                    /* INETA original          */
};

struct dsd_clib1_contr_1 {                  /* structure session control */
   BOOL       boc_client_header;            /* client header has been received */
   UNSIG_MED  umc_ineta_lower;              /* natted INETAs lower entry */
   UNSIG_MED  umc_ineta_upper;              /* natted INETAs upper entry */
   UNSIG_MED  umc_ineta_mask;               /* natted INETAs network mask */
   UNSIG_MED  umc_ineta_client;             /* INETA client in tunnel  */
   UNSIG_MED  umc_ineta_cl_int;             /* INETA client intern in intranet */
   UNSIG_MED  umc_ineta_max_used;           /* natted INETAs maximum used INETA */
   int        imc_alloc;                    /* number of INETAs allocated */
#ifdef B130118
   int        imc_no_qdnsr1;                /* number of responses queued */
#endif
   struct dsd_cc1_ext *adsc_cc1_ext;        /* structure session control extension */
   struct dsd_htree1_avl_cntl dsc_htree1_avl_cntl_ineta;
#ifdef B130118
   struct dsd_query_dns_resp_1 dsrc_qdnsr1[ MAX_DNS_QUEUED ];  /* structure query DNS response */
#endif
   struct dsd_ineta_ctl_1 dsrc_ic1[ DEF_INETA_TABLE_ORG ];  /* control INETA */
#ifdef DEBUG_101208_01
   char       chrc_display[ 64 * 1024 ];    /* display area            */
#endif
};

struct dsd_cc1_ext {                        /* structure session control extension */
   struct dsd_cc1_ext *adsc_next;           /* for chaining            */
   struct dsd_ineta_ctl_1 dsrc_ic1[ DEF_INETA_TABLE_EXT ];  /* control INETA */
};

static const char * achrs_node_main[] = {
   "NAT-control",
   "display-natted-inetas",
   "ALG-SIP",
   "exclude-DNS-name",
   "DNS-ineta",
};

#ifdef XYZ1
// 25.10.10 KB - remove achrs_node_nat
static const char * achrs_node_nat[] = {
   "real-ineta",
   "translated-ineta",
   "prefix"
};
#endif

static const char * achrs_node_nat_contr[] = {
   "ineta-use-1",
   "ineta-use-2"
};

static const char * achrs_node_dnsi1[] = {
   "DNS-name",
   "ineta"
};

#ifdef XYZ1
static const char * achrs_node_cnat[] = {
   "real-network-ineta",
   "translated-network-ineta",
   "prefix"
};
#endif

static const unsigned char ucrs_recv_contr_01[] = {
   'S', 'T', 'A', 'R', 'T'
};

static const unsigned char ucrs_recv_contr_02[] = {
   'R', 'E', 'C', 'O', 'N', 'N', 'E', 'C',
   'T'
};

static const unsigned char ucrs_recv_locineta[] = {
   'L', 'O', 'C', 'A', 'L', '-', 'I', 'N',
   'E', 'T', 'A', '='
};

#ifndef B130607
#ifndef HPPPT1_V21                          /* 18.01.13 KB HOB-PPP-T1 V2.1 */
static const unsigned char ucrs_send_stop[] = {
   0X05,                                    /* length NHASN            */
   '0',                                     /* control command         */
   'S', 'T', 'O', 'P'
};
#endif
#ifdef HPPPT1_V21                           /* 18.01.13 KB HOB-PPP-T1 V2.1 */
static const unsigned char ucrs_send_stop[] = {
   '0',                                     /* control command         */
   0X04,                                    /* length NHASN            */
   'S', 'T', 'O', 'P'
};
#endif
#endif

static const unsigned char ucrs_ctrl_ipcp[] = {
   0X80, 0X21
};

/* 1 = digit                                                           */
/* 2 = dot                                                             */
/* 3 = separator                                                       */
/* 4 = character                                                       */
/* 5 = invalid                                                         */
static const unsigned char ucrs_tab_char_sip[ 256 ] = {
   5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 3, 5, 5,  /* 0X00 till 0X0F  */
   5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,  /* 0X10 till 0X1F  */
   3, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 3, 5, 2, 5,  /* 0X20 till 0X2F  */
   1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 3, 5, 3, 3, 5,  /* 0X30 till 0X3F  */
   3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,  /* 0X40 till 0X4F  */
   4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5,  /* 0X50 till 0X5F  */
   5, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,  /* 0X60 till 0X6F  */
   4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5,  /* 0X70 till 0X7F  */
   5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,  /* 0X80 till 0X8F  */
   5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,  /* 0X90 till 0X9F  */
   5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,  /* 0XA0 till 0XAF  */
   5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,  /* 0XB0 till 0XBF  */
   5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,  /* 0XC0 till 0XCF  */
   5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,  /* 0XD0 till 0XDF  */
   5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,  /* 0XE0 till 0XEF  */
   5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5   /* 0XF0 till 0XFF  */
};

/* invalid - not found - part 1                                        */
static const unsigned char chrs_dns_r_i_1[] = {
   (unsigned char) 0X85, (unsigned char) 0X83,  /* Response etc.       */
   (unsigned char) 0X00, (unsigned char) 0X01,  /* QDCOUNT             */
   (unsigned char) 0X00, (unsigned char) 0X00,  /* ANCOUNT             */
   (unsigned char) 0X00, (unsigned char) 0X00,  /* NSCOUNT             */
   (unsigned char) 0X00, (unsigned char) 0X00,  /* ARCOUNT             */
};

/* all types of response - part 2                                      */
static const unsigned char chrs_dns_r_a_2[] = {
   (unsigned char) 0X00, (unsigned char) 0X01,  /* Type A 0001         */
   (unsigned char) 0X00, (unsigned char) 0X01,  /* Class IN 0001       */
};

/* successful - found - part 1                                         */
static const unsigned char chrs_dns_r_s_1[] = {
   (unsigned char) 0X85, (unsigned char) 0X80,  /* Response etc.       */
   (unsigned char) 0X00, (unsigned char) 0X01,  /* QDCOUNT             */
   (unsigned char) 0X00, (unsigned char) 0X01,  /* ANCOUNT             */
   (unsigned char) 0X00, (unsigned char) 0X00,  /* NSCOUNT             */
   (unsigned char) 0X00, (unsigned char) 0X00,  /* ARCOUNT             */
};

/* successful - found - part 3 - with INETA                            */
static const unsigned char chrs_dns_r_s_3[] = {
   (unsigned char) 0XC0, (unsigned char) 0X0C,  /* DNS name compressed */
   (unsigned char) 0X00, (unsigned char) 0X01,  /* Type A 0001         */
   (unsigned char) 0X00, (unsigned char) 0X01,  /* Class IN 0001       */
   (unsigned char) 0X00, (unsigned char) 0X01,  /* Type to live        */
   (unsigned char) 0X51, (unsigned char) 0X80,  /* 1 Day               */
   (unsigned char) 0X00, (unsigned char) 0X04,  /* Data length         */
};

/* DNS query part one                                                  */
static const unsigned char chrs_dns_query_1[] = {
   (unsigned char) 0X01, (unsigned char) 0X00,  /* Flags standard query */
   (unsigned char) 0X00, (unsigned char) 0X01,  /* QDCOUNT             */
   (unsigned char) 0X00, (unsigned char) 0X00,  /* ANCOUNT             */
   (unsigned char) 0X00, (unsigned char) 0X00,  /* NSCOUNT             */
   (unsigned char) 0X00, (unsigned char) 0X00,  /* ARCOUNT             */
};

/* DNS query part two                                                  */
static const unsigned char chrs_dns_query_2[] = {
   (unsigned char) 0X00, (unsigned char) 0X01,  /* Type A 0001         */
   (unsigned char) 0X00, (unsigned char) 0X01,  /* Class IN 0001       */
};

static const unsigned char chrs_port_dns[] = {
   (unsigned char) 0,
   (unsigned char) 53
};

static const unsigned char chrs_port_sip[] = {  /* port 5060           */
   (unsigned char) 0X13,
   (unsigned char) 0XC4
};

static const unsigned char ucrs_sip_cont_len[] = {  /* SIP Content-Length */
   CHAR_CR, CHAR_LF,
   'C', 'o', 'n', 't', 'e', 'n', 't', '-',
   'L', 'e', 'n', 'g', 't', 'h', ':'
};

/**
   see http://www.duxcw.com/faq/network/privip.htm
*/
static const unsigned char ucrrs_private_inetas[8][4] = {  /* private INETAs */
   {
     10, 0, 0, 0
   },
   {
     10, 255, 255, 255
   },
   {
     169, 254, 0, 0
   },
   {
     169, 254, 255, 255
   },
   {
     172, 16, 0, 0
   },
   {
     172, 31, 255, 255
   },
   {
     192, 168, 0, 0
   },
   {
     192, 168, 255, 255
   }
};

static int m_get_dns_name( char *, int, HL_WCHAR * );
#ifdef XYZ1
static BOOL m_check_dns_n_double( char *, int, struct dsd_clib1_conf * );
#endif
static int m_get_ineta_w( UNSIG_MED *, HL_WCHAR * );
static int m_get_ineta_a( UNSIG_MED *, char *, char * );
static BOOL m_check_private_ineta( char * );
static int m_natted_ineta( struct dsd_hl_clib_1 *, char * );
static int m_original_ineta( struct dsd_hl_clib_1 *, char * );
static int m_cmp_ineta( void *, struct dsd_htree1_avl_entry *, struct dsd_htree1_avl_entry * );
static int m_sdh_printf( struct dsd_sdh_call_1 *, const char *, ... );
static int m_get_date_time( char *achp_buff );
static void m_sdh_console_out( struct dsd_sdh_call_1 *, char *achp_buff, int implength );
static void m_dump_gather( struct dsd_sdh_call_1 *, struct dsd_gather_i_1 *, int );
#ifdef CHECK_OUTPUT_01
static void m_check_output_01( struct dsd_hl_clib_1 * );
#endif
#ifdef TRACEHL_TIME
static HL_LONGLONG m_get_epoch_ms( void );
#endif

static const char chrstrans[]
     = { '0', '1', '2', '3', '4', '5', '6', '7',
         '8', '9', 'A', 'B', 'C', 'D', 'E', 'F' };

#ifdef DEBUG_101207_01
static BOOL   bos_debug_01 = FALSE;
#endif

/** subroutine to process the configuration data                       */
extern "C" HL_DLL_PUBLIC BOOL m_hlclib_conf( struct dsd_hl_clib_dom_conf *adsp_hlcldomf ) {
   BOOL       bol1;                         /* working variable        */
   BOOL       bol_disp_nat_i_conf;          /* display-natted-INETAs configured */
   BOOL       bol_alg_sip_conf;             /* use ALG for SIP VoIP protocol configured */
   int        iml1, iml2, iml3;             /* working variables       */
   int        iml_cmp;                      /* compare values          */
   int        iml_val;                      /* value in array          */
   int        iml_no_ineta;                 /* count INETA             */
   int        iml_len_dns_n;                /* length DNS name         */
   int        iml_ineta_use;                /* entry ineta-use-n       */
   int        iml_flag_nat_control;         /* flag NAT-control defined */
// int        iml_cnat_prefix;              /* cnat prefix             */
   UNSIG_MED  uml_ineta_w1;                 /* working-variable INETA  */
   UNSIG_MED  uml_ineta_w2;                 /* working-variable INETA  */
   UNSIG_MED  uml_ineta_w3;                 /* working-variable INETA  */
   UNSIG_MED  *auml_w1;                     /* working-variable        */
   char       *achl_stor_new;               /* new storage             */
   char       *achl_stor_old;               /* old storage             */
   char       *achl_w1;                     /* working-variable        */
   DOMNode    *adsl_node_1;                 /* node for navigation     */
   DOMNode    *adsl_node_2;                 /* node for navigation     */
   DOMNode    *adsl_node_3;                 /* node for navigation     */
   HL_WCHAR   *awcl1;                       /* working variable        */
   HL_WCHAR   *awcl_name;                   /* name of Node            */
   HL_WCHAR   *awcl_value;                  /* value of Node           */
   HL_WCHAR   *awcl_dns_name;               /* save DNS name           */
#ifdef XYZ1
   struct dsd_nat_entry_1 *adsl_nat_entry_1_w1;  /* structure NAT entry */
#endif
   struct dsd_ineta_single_ret dsl_ineta_sret_work_1;
   struct dsd_dns_resp_1 *adsl_dnsr1_new;   /* new DNS response        */
   struct dsd_sdh_call_1 dsl_sdh_call_1;    /* SDH call structure      */
#ifdef XYZ1
   struct dsd_nat_entry_1 dsl_nat_entry_1;  /* structure NAT entry     */
#endif
   struct dsd_clib1_conf dsl_clco;          /* configuration data      */
   unsigned char chrl_ineta_w1[4];          /* INETA                   */
   char       chrl_dns_name[256];           /* for DNS name            */
   UNSIG_MED  umrl_ineta[ MAX_DNS_INETA ];  /* for INETAs              */

#ifdef TRACEHL1
   printf( "xl-sdh-ppp-pf-05-l%05d-T m_hlclib_conf() called adsp_hlcldomf=%p\n",
           __LINE__, adsp_hlcldomf );
#endif
   dsl_sdh_call_1.amc_aux = adsp_hlcldomf->amc_aux;  /* auxiliary subroutine */
   dsl_sdh_call_1.vpc_userfld = adsp_hlcldomf->vpc_userfld;  /* User Field Subroutine */
#ifndef HPPPT1_V21                          /* 18.01.13 KB HOB-PPP-T1 V2.1 */
   m_sdh_printf( &dsl_sdh_call_1, "xl-sdh-ppp-pf-05-l%05d-I V1.2 " __DATE__ " m_hlclib_conf() called",
                 __LINE__ );
#else
   m_sdh_printf( &dsl_sdh_call_1, "xl-sdh-ppp-pf-05-l%05d-I V2.1 " __DATE__ " m_hlclib_conf() called",
                 __LINE__ );
#endif
#ifdef TRACEHL_090905
   m_sdh_printf( &dsl_sdh_call_1, "xl-sdh-ppp-pf-05-l%05d-T sizeof(struct dsd_hl_clib_1)=%d offsetof( ..., boc_callrevdir )=%d TRUE=%d.",
                 __LINE__, sizeof(struct dsd_hl_clib_1), offsetof( struct dsd_hl_clib_1, boc_callrevdir ), TRUE );
#endif
#ifdef NOT_YET_080308_01
   bol1 = adsp_hlcldomf->amc_aux( adsp_hlcldomf->vpc_userfld,
                                  DEF_AUX_MEMGET,
                                  adsp_hlcldomf->aac_conf,
                                  sizeof(struct dsd_clib1_4_1) );
   if (bol1 == FALSE) {
     return FALSE;
   }
   memset( *adsp_hlcldomf->aac_conf, 0, sizeof(struct dsd_clib1_4_1) );
   ((struct dsd_clib1_4_1 *) *adsp_hlcldomf->aac_conf)->imc_flags_1
     = adsp_hlcldomf->imc_flags_1;
#endif

   if (adsp_hlcldomf->adsc_node_conf == NULL) {
     m_sdh_printf( &dsl_sdh_call_1, "xl-sdh-ppp-pf-05-l%05d-W m_hlclib_conf() no Node configured",
                   __LINE__ );
     return FALSE;
   }

   /* getFirstChild()                                                  */
   adsl_node_1 = (DOMNode *) adsp_hlcldomf->amc_call_dom( adsp_hlcldomf->adsc_node_conf,
                                                          ied_hlcldom_get_first_child );
   if (adsl_node_1 == NULL) {               /* no Node returned        */
     m_sdh_printf( &dsl_sdh_call_1, "xl-sdh-ppp-pf-05-l%05d-W m_hlclib_conf() no getFirstChild()",
                   __LINE__ );
     return FALSE;
   }

   memset( &dsl_clco, 0, sizeof(struct dsd_clib1_conf) );  /* configuration data */
   iml_flag_nat_control = 0;                /* flag NAT-control defined */
   achl_stor_new = NULL;                    /* new storage             */
   bol_disp_nat_i_conf = FALSE;             /* display-natted-INETAs configured */
   bol_alg_sip_conf = FALSE;                /* use ALG for SIP VoIP protocol configured */

   pdomc20:                                 /* process DOM node        */
   if (((int) (long long) adsp_hlcldomf->amc_call_dom( adsl_node_1, ied_hlcldom_get_node_type ))
         != DOMNode::ELEMENT_NODE) {
     goto pdomc80;                          /* get next sibling        */
   }
   awcl1 = (HL_WCHAR *) adsp_hlcldomf->amc_call_dom( adsl_node_1, ied_hlcldom_get_node_name );
#ifdef TRACEHL1
   printf( "xl-sdh-ppp-pf-05-l%05d-T m_hlclib_conf() found node %S\n", __LINE__, awcl1 );
#endif
   iml_val = sizeof(achrs_node_main) / sizeof(achrs_node_main[0]);
   do {
     bol1 = m_cmp_u16z_u8z( &iml_cmp, awcl1, (char *) achrs_node_main[ iml_val - 1 ] );
     if ((bol1) && (iml_cmp == 0)) break;   /* strings are equal       */
     iml_val--;
   } while (iml_val > 0);
   if (iml_val == 0) {                      /* keyword not found       */
     m_sdh_printf( &dsl_sdh_call_1, "xl-sdh-ppp-pf-05-l%05d-W Error first element name \"%(ux)s\" undefined - ignored",
                   __LINE__, awcl1 );
     goto pdomc80;                          /* DOM node processed - next */
   }
   adsl_node_2 = (DOMNode *) adsp_hlcldomf->amc_call_dom( adsl_node_1,
                                                          ied_hlcldom_get_first_child );  /* getFirstChild() */
   if (adsl_node_2 == NULL) {               /* no child found          */
     m_sdh_printf( &dsl_sdh_call_1, "xl-sdh-ppp-pf-05-l%05d-W Error \"%(ux)s\" has no child - ignored",
                   __LINE__, awcl1 );
     goto pdomc80;                          /* DOM node processed - next */
   }
   switch (iml_val) {                       /* check keyword           */
     case 2:
       goto p_disp_nat_i_00;                /* display-natted-inetas   */
     case 3:
       goto p_alg_sip_00;                   /* ALG-SIP                 */
     case 4:
       goto p_excl_dns_00;                  /* exclude DNS name        */
     case 5:
       goto p_dns_ineta_00;                 /* retrieve DNS-ineta      */
   }
   /* is NAT-control                                                   */
   if (iml_flag_nat_control) {              /* flag NAT-control defined */
     m_sdh_printf( &dsl_sdh_call_1, "xl-sdh-ppp-pf-05-l%05d-W Error \"%(ux)s\" defined double - new values ignored",
                   __LINE__, awcl1 );
     goto pdomc80;                          /* DOM node processed - next */
   }

   pdomc40:                                 /* process DOM node stage 2 */
   if (((int) (long long) adsp_hlcldomf->amc_call_dom( adsl_node_2, ied_hlcldom_get_node_type ))
         != DOMNode::ELEMENT_NODE) {
     goto pdomc56;                          /* get next sibling stage 2 */
   }
   awcl_name = (HL_WCHAR *) adsp_hlcldomf->amc_call_dom( adsl_node_2, ied_hlcldom_get_node_name );
#ifdef TRACEHL1
   printf( "xl-sdh-ppp-pf-05-l%05d-T m_hlclib_conf() found node %S\n", __LINE__, awcl_name );
#endif
   iml_ineta_use = sizeof(achrs_node_nat_contr) / sizeof(achrs_node_nat_contr[0]) - 1;
   do {
     bol1 = m_cmp_u16z_u8z( &iml_cmp, awcl_name, (char *) achrs_node_nat_contr[ iml_ineta_use ] );
     if ((bol1) && (iml_cmp == 0)) break;   /* strings are equal       */
     iml_ineta_use--;                       /* decrement index         */
   } while (iml_ineta_use >= 0);
   if (iml_ineta_use < 0) {                 /* parameter not found     */
     m_sdh_printf( &dsl_sdh_call_1, "xl-sdh-ppp-pf-05-l%05d-W Error element \"NAT-control\" child \"%(ux)s\" not defined - ignored",
                   __LINE__, awcl_name );
     goto pdomc56;                          /* get next sibling stage 2 */
   }
   adsl_node_3 = (DOMNode *) adsp_hlcldomf->amc_call_dom( adsl_node_2,
                                                          ied_hlcldom_get_first_child );  /* getFirstChild() */
   if (adsl_node_3 == NULL) {               /* no child found          */
     m_sdh_printf( &dsl_sdh_call_1, "xl-sdh-ppp-pf-05-l%05d-W Error element \"NAT-control\" \"%(ux)s\" has no child - ignored",
                   __LINE__, awcl_name );
     goto pdomc56;                          /* get next sibling stage 2 */
   }
   do {                                     /* search value            */
     if (((int) (long long) adsp_hlcldomf->amc_call_dom( adsl_node_3, ied_hlcldom_get_node_type ))
           == DOMNode::TEXT_NODE) break;
     adsl_node_3 = (DOMNode *) adsp_hlcldomf->amc_call_dom( adsl_node_3,
                                                            ied_hlcldom_get_next_sibling );
   } while (adsl_node_3);
   if (adsl_node_3 == NULL) {
     m_sdh_printf( &dsl_sdh_call_1, "xl-sdh-ppp-pf-05-l%05d-W Error element \"NAT-control\" \"%(ux)s\" no value found - ignored",
                   __LINE__, awcl_name );
     goto pdomc56;                          /* get next sibling stage 2 */
   }
   awcl_value = (HL_WCHAR *) adsp_hlcldomf->amc_call_dom( adsl_node_3, ied_hlcldom_get_node_value );  /* getNodeValue() */
   if (iml_flag_nat_control & (1 << iml_ineta_use)) {  /* flag NAT-control defined */
     m_sdh_printf( &dsl_sdh_call_1, "xl-sdh-ppp-pf-05-l%05d-W Error \"NAT-control\" element \"%s\" value \"%(ux)s\" already defined before - ignored",
                   __LINE__, achrs_node_nat_contr[ iml_ineta_use ], awcl_value );
     goto pdomc56;                          /* get next sibling stage 2 */
   }

   /* INETA with prefix                                                */
   iml1 = HL_WCSLEN( awcl_value );         /* length of parameter     */
   while ((iml1 > 0) && (*(awcl_value + iml1 - 1) != '/')) iml1--;
   if (iml1 == 0) {
     m_sdh_printf( &dsl_sdh_call_1, "xl-sdh-ppp-pf-05-l%05d-W Error \"NAT-control\" element \"%s\" value \"%(ux)s\" could not find \"/\" for prefix - ignored",
                   __LINE__, achrs_node_nat_contr[ iml_ineta_use ], awcl_value );
     goto pdomc56;                          /* get next sibling stage 2 */
   }
   if ((iml1 - 1) > LEN_INETA_PR_IPV4) {    /* INETA too long          */
     m_sdh_printf( &dsl_sdh_call_1, "xl-sdh-ppp-pf-05-l%05d-W Error \"NAT-control\" element \"%s\" value \"%(ux)s\" INETA length %d too long - ignored",
                   __LINE__, achrs_node_nat_contr[ iml_ineta_use ], awcl_value, iml1 - 1 );
     goto pdomc56;                          /* get next sibling stage 2 */
   }
   awcl1 = awcl_value + iml1;               /* here starts prefix      */
   iml2 = 0;                                /* clear result            */
   while (TRUE) {                           /* loop over digits        */
     if (*awcl1 == 0) break;                /* end of digits           */
     if ((*awcl1 < '0') || (*awcl1 > '9')) {
       m_sdh_printf( &dsl_sdh_call_1, "xl-sdh-ppp-pf-05-l%05d-W Error \"NAT-control\" element \"%s\" value \"%(ux)s\" invalid digit \"%(ux)c\" in prefix found - ignored",
                     __LINE__, achrs_node_nat_contr[ iml_ineta_use ], awcl_value, *awcl1 );
       goto pdomc56;                        /* get next sibling stage 2 */
     }
     iml2 *= 10;                            /* shift old digits        */
     iml2 += *awcl1++ - '0';                /* add new digit           */
   }
   if ((iml2 <= 0) || (iml2 > 128)) {
     m_sdh_printf( &dsl_sdh_call_1, "xl-sdh-ppp-pf-05-l%05d-W Error \"NAT-control\" element \"%s\" \"%(ux)s\" prefix %d out of range - ignored",
                   __LINE__, achrs_node_nat_contr[ iml_ineta_use ], awcl_value, iml2 );
     goto pdomc56;                          /* get next sibling stage 2 */
   }
   iml1--;                                  /* subtract separator      */
   if (iml1 <= 0) {                         /* too short for INETA     */
     m_sdh_printf( &dsl_sdh_call_1, "xl-sdh-ppp-pf-05-l%05d-W Error \"NAT-control\" element \"%s\" value \"%(ux)s\" INETA length %d too short - ignored",
                   __LINE__, achrs_node_nat_contr[ iml_ineta_use ], awcl_value, iml1 );
     goto pdomc56;                          /* get next sibling stage 2 */
   }
   bol1 = m_get_single_ineta( &iml3, &dsl_ineta_sret_work_1,
                              awcl_value, iml1, ied_chs_utf_16 );
   if (bol1 == FALSE) {                     /* error occured           */
     m_sdh_printf( &dsl_sdh_call_1, "xl-sdh-ppp-pf-05-l%05d-W Error \"NAT-control\" element \"%s\" value \"%(ux)s\" INETA invalid, error %d - ignored",
                   __LINE__, achrs_node_nat_contr[ iml_ineta_use ], awcl_value, iml3 );
     goto pdomc56;                          /* get next sibling stage 2 */
   }
   if (dsl_ineta_sret_work_1.usc_family != AF_INET) {  /* family IPV4 / IPV6 */
     m_sdh_printf( &dsl_sdh_call_1, "xl-sdh-ppp-pf-05-l%05d-W Error \"NAT-control\" element \"%s\" value \"%(ux)s\" INETA not IPV4 - ignored",
                   __LINE__, achrs_node_nat_contr[ iml_ineta_use ], awcl_value );
     goto pdomc56;                          /* get next sibling stage 2 */
   }
   if (iml2 > (dsl_ineta_sret_work_1.usc_length * 8)) {
     m_sdh_printf( &dsl_sdh_call_1, "xl-sdh-ppp-pf-05-l%05d-W Error \"NAT-control\" element \"%s\" value \"%(ux)s\" prefix %d out of range - ignored",
                   __LINE__, achrs_node_nat_contr[ iml_ineta_use ], awcl_value, iml2 );
     goto pdomc56;                          /* get next sibling stage 2 */
   }
   memcpy( &uml_ineta_w1, dsl_ineta_sret_work_1.chrc_ineta, sizeof(UNSIG_MED) );
   uml_ineta_w3 = (UNSIG_MED) 0XFFFFFFFF;   /* network mask            */
   iml1 = sizeof(UNSIG_MED);
   iml3 = sizeof(UNSIG_MED) * 8 - iml2;
   do {                                     /* loop over bytes on INETA */
     iml1--;                                /* decrement index         */
     if (iml3 >= 8) {
       *((unsigned char *) &uml_ineta_w1 + iml1) = 0;
       *((unsigned char *) &uml_ineta_w3 + iml1) = 0;
       iml3 -= 8;
       if (iml3 == 0) break;
     } else {
       *((unsigned char *) &uml_ineta_w1 + iml1) &= (unsigned char) (-1 << iml3);
       *((unsigned char *) &uml_ineta_w3 + iml1) &= (unsigned char) (-1 << iml3);
       break;
     }
   } while (iml1 > 0);
   if (memcmp( &uml_ineta_w1, dsl_ineta_sret_work_1.chrc_ineta, sizeof(UNSIG_MED) )) {
     m_sdh_printf( &dsl_sdh_call_1, "xl-sdh-ppp-pf-05-l%05d-W Error \"NAT-control\" element \"%s\" value \"%(ux)s\" INETA last bits not zero - ignored",
                   __LINE__, achrs_node_nat_contr[ iml_ineta_use ], awcl_value );
     goto pdomc56;                          /* get next sibling stage 2 */
   }
   uml_ineta_w2 = uml_ineta_w1;
   m_ineta_op_add( (char *) &uml_ineta_w2, sizeof(UNSIG_MED), (1 << (sizeof(UNSIG_MED) * 8 - iml2)) - 1 );
   if (iml_ineta_use == 0) {                /* entry ineta-use-n       */
     dsl_clco.umc_conf_ineta_1_lower = uml_ineta_w1;  /* configured INETAs 1 lower value */
     dsl_clco.umc_conf_ineta_1_upper = uml_ineta_w2;  /* configured INETAs 1 upper value */
     dsl_clco.umc_conf_ineta_1_mask = uml_ineta_w3;  /* configured INETAs 1 network mask */
   } else {
     dsl_clco.umc_conf_ineta_2_lower = uml_ineta_w1;  /* configured INETAs 2 lower value */
     dsl_clco.umc_conf_ineta_2_upper = uml_ineta_w2;  /* configured INETAs 2 upper value */
     dsl_clco.umc_conf_ineta_2_mask = uml_ineta_w3;  /* configured INETAs 2 network mask */
   }
   iml_flag_nat_control |= 1 << iml_ineta_use;  /* flag NAT-control defined */

   pdomc56:                                 /* get next sibling stage 2 */
   adsl_node_2 = (DOMNode *) adsp_hlcldomf->amc_call_dom( adsl_node_2,
                                                          ied_hlcldom_get_next_sibling );
   if (adsl_node_2) goto pdomc40;           /* process DOM node stage 2 */
#ifdef TRACEHL1
   m_sdh_console_out( &dsl_sdh_call_1, (char *) &dsl_clco, sizeof(struct dsd_clib1_conf) );
#endif
   if (iml_flag_nat_control != 3) {         /* flag NAT-control defined */
     m_sdh_printf( &dsl_sdh_call_1, "xl-sdh-ppp-pf-05-l%05d-W Error \"NAT-control\" not all values ineta-use-1 and ineta-use-2 defined - NAT-control ignored",
                   __LINE__ );
     iml_flag_nat_control = 0;              /* flag NAT-control defined */
   }
   goto pdomc80;                            /* DOM node processed - next */

   p_disp_nat_i_00:                         /* display-natted-inetas   */
   if (bol_disp_nat_i_conf) {               /* display-natted-INETAs configured */
     m_sdh_printf( &dsl_sdh_call_1, "xl-sdh-ppp-pf-05-l%05d-W Error element \"display-natted-inetas\" defined double - ignored",
                   __LINE__ );
     goto pdomc80;                          /* DOM node processed - next */
   }
   do {                                     /* search value            */
     if (((int) (long long) adsp_hlcldomf->amc_call_dom( adsl_node_2, ied_hlcldom_get_node_type ))
           == DOMNode::TEXT_NODE) break;
     adsl_node_2 = (DOMNode *) adsp_hlcldomf->amc_call_dom( adsl_node_2,
                                                            ied_hlcldom_get_next_sibling );
   } while (adsl_node_2);
   if (adsl_node_2 == NULL) {
     m_sdh_printf( &dsl_sdh_call_1, "xl-sdh-ppp-pf-05-l%05d-W Error element \"display-natted-inetas\" no value found - ignored",
                   __LINE__ );
     goto pdomc80;                          /* DOM node processed - next */
   }
   awcl_value = (HL_WCHAR *) adsp_hlcldomf->amc_call_dom( adsl_node_2, ied_hlcldom_get_node_value );  /* getNodeValue() */
   while (TRUE) {                           /* pseudo-loop             */
     bol1 = m_cmp_u16z_u8z( &iml_cmp, awcl_value, "YES" );
     if ((bol1) && (iml_cmp == 0)) {        /* strings are equal       */
       dsl_clco.boc_disp_inetas = TRUE;     /* display natted INETAs   */
       break;
     }
     bol1 = m_cmp_u16z_u8z( &iml_cmp, awcl_value, "NO" );
     if ((bol1) && (iml_cmp == 0)) break;   /* strings are equal       */
     m_sdh_printf( &dsl_sdh_call_1, "xl-sdh-ppp-pf-05-l%05d-W Error element \"display-natted-inetas\" value neither YES nor NO - \"%(ux)s\" - ignored",
                   __LINE__, awcl_value );
     goto pdomc80;                          /* DOM node processed - next */
   } while (FALSE);
   bol_disp_nat_i_conf = TRUE;              /* display-natted-INETAs configured */
   goto pdomc80;                            /* DOM node processed - next */

   p_alg_sip_00:                            /* ALG-SIP                 */
   if (bol_alg_sip_conf) {                  /* use ALG for SIP VoIP protocol configured */
     m_sdh_printf( &dsl_sdh_call_1, "xl-sdh-ppp-pf-05-l%05d-W Error element \"ALG-SIP\" defined double - ignored",
                   __LINE__ );
     goto pdomc80;                          /* DOM node processed - next */
   }
   do {                                     /* search value            */
     if (((int) (long long) adsp_hlcldomf->amc_call_dom( adsl_node_2, ied_hlcldom_get_node_type ))
           == DOMNode::TEXT_NODE) break;
     adsl_node_2 = (DOMNode *) adsp_hlcldomf->amc_call_dom( adsl_node_2,
                                                            ied_hlcldom_get_next_sibling );
   } while (adsl_node_2);
   if (adsl_node_2 == NULL) {
     m_sdh_printf( &dsl_sdh_call_1, "xl-sdh-ppp-pf-05-l%05d-W Error element \"ALG-SIP\" no value found - ignored",
                   __LINE__ );
     goto pdomc80;                          /* DOM node processed - next */
   }
   awcl_value = (HL_WCHAR *) adsp_hlcldomf->amc_call_dom( adsl_node_2, ied_hlcldom_get_node_value );  /* getNodeValue() */
   while (TRUE) {                           /* pseudo-loop             */
     bol1 = m_cmp_u16z_u8z( &iml_cmp, awcl_value, "YES" );
     if ((bol1) && (iml_cmp == 0)) {        /* strings are equal       */
       dsl_clco.boc_alg_sip = TRUE;         /* use ALG for SIP VoIP protocol */
       break;
     }
     bol1 = m_cmp_u16z_u8z( &iml_cmp, awcl_value, "NO" );
     if ((bol1) && (iml_cmp == 0)) break;   /* strings are equal       */
     m_sdh_printf( &dsl_sdh_call_1, "xl-sdh-ppp-pf-05-l%05d-W Error element \"ALG-SIP\" value neither YES nor NO - \"%(ux)s\" - ignored",
                   __LINE__, awcl_value );
     goto pdomc80;                          /* DOM node processed - next */
   } while (FALSE);
   bol_alg_sip_conf = TRUE;                 /* use ALG for SIP VoIP protocol configured */
   goto pdomc80;                            /* DOM node processed - next */

   p_excl_dns_00:                           /* exclude DNS name        */
   do {                                     /* search value            */
     if (((int) (long long) adsp_hlcldomf->amc_call_dom( adsl_node_2, ied_hlcldom_get_node_type ))
           == DOMNode::TEXT_NODE) break;
     adsl_node_2 = (DOMNode *) adsp_hlcldomf->amc_call_dom( adsl_node_2,
                                                            ied_hlcldom_get_next_sibling );
   } while (adsl_node_2);
   if (adsl_node_2 == NULL) {
     m_sdh_printf( &dsl_sdh_call_1, "xl-sdh-ppp-pf-05-l%05d-W Error element \"exclude-DNS-name\" no value found - ignored",
                   __LINE__ );
     goto pdomc80;                          /* DOM node processed - next */
   }
   awcl_value = (HL_WCHAR *) adsp_hlcldomf->amc_call_dom( adsl_node_2, ied_hlcldom_get_node_value );  /* getNodeValue() */
   iml_len_dns_n = m_get_dns_name( chrl_dns_name, sizeof(chrl_dns_name), (HL_WCHAR *) awcl_value );
   if (iml_len_dns_n < 0) {                 /* DNS name is not valid   */
     m_sdh_printf( &dsl_sdh_call_1, "xl-sdh-ppp-pf-05-l%05d-W Error element \"exclude-DNS-name\" value \"%(ux)s\" invalid - ignored",
                   __LINE__, awcl_value );
     goto pdomc80;                          /* DOM node processed - next */
   }
   awcl_dns_name = awcl_value;              /* save DNS name           */
#ifdef XYZ1
   bol1 = m_check_dns_n_double( chrl_dns_name, iml_len_dns_n, (struct dsd_clib1_conf *) achl_stor_new );
   if (bol1 == FALSE) {                     /* DNS name already defined */
     m_sdh_printf( &dsl_sdh_call_1, "xl-sdh-ppp-pf-05-l%05d-W Error element \"exclude-DNS-name\" value \"%(ux)s\" DNS-name already configured before - ignored",
                   __LINE__, awcl_dns_name );
     goto pdomc80;                          /* DOM node processed - next */
   }
#endif
   iml1 = dsl_clco.imc_len_dns_resp;        /* save old length         */
   iml2 = sizeof(chrs_dns_r_i_1) + iml_len_dns_n + sizeof(chrs_dns_r_a_2);
   dsl_clco.imc_len_dns_resp
     += sizeof(struct dsd_dns_resp_1)
          + (iml2 + sizeof(void *) - 1)
            & (0 - sizeof(void *));
   achl_stor_old = achl_stor_new;           /* save storage            */
   bol1 = adsp_hlcldomf->amc_aux( adsp_hlcldomf->vpc_userfld,
                                  DEF_AUX_MEMGET,
                                  &achl_stor_new,
                                  sizeof(struct dsd_clib1_conf)
                                    + dsl_clco.imc_len_dns_resp );
   if (bol1 == FALSE) {                     /* error occured           */
     return FALSE;
   }
   if (achl_stor_old) {                     /* copy old values         */
     memcpy( achl_stor_new + sizeof(struct dsd_clib1_conf),
             achl_stor_old + sizeof(struct dsd_clib1_conf),
             iml1 );
     bol1 = adsp_hlcldomf->amc_aux( adsp_hlcldomf->vpc_userfld,
                                    DEF_AUX_MEMFREE,
                                    &achl_stor_old,
                                    sizeof(struct dsd_clib1_conf)
                                      + iml1 );
   }
   /* new DNS response                                                 */
   adsl_dnsr1_new
     = (struct dsd_dns_resp_1 *) (achl_stor_new + sizeof(struct dsd_clib1_conf)
                                    + iml1 );
   adsl_dnsr1_new->imc_len_stor = dsl_clco.imc_len_dns_resp - iml1;  /* storage reserved */
   adsl_dnsr1_new->imc_len_entry = iml2;    /* length of entry         */
   adsl_dnsr1_new->imc_len_dns_n = iml_len_dns_n;  /* length DNS name  */
   achl_w1 = (char *) (adsl_dnsr1_new + 1);
   memcpy( achl_w1, chrs_dns_r_i_1, sizeof(chrs_dns_r_i_1) );
   achl_w1 += sizeof(chrs_dns_r_i_1);
   memcpy( achl_w1, chrl_dns_name, iml_len_dns_n );
   achl_w1 += iml_len_dns_n;
   memcpy( achl_w1, chrs_dns_r_a_2, sizeof(chrs_dns_r_a_2) );
   memcpy( achl_stor_new, &dsl_clco, sizeof(struct dsd_clib1_conf) );
   goto pdomc80;                            /* DOM node processed - next */

   p_dns_ineta_00:                          /* retrieve DNS-ineta      */
   iml_no_ineta = 0;                        /* no INETA till now       */
   iml_len_dns_n = 0;                       /* clear length DNS name   */

   p_dns_ineta_20:                          /* process DOM node stage 2 */
   if (((int) (long long) adsp_hlcldomf->amc_call_dom( adsl_node_2, ied_hlcldom_get_node_type ))
         != DOMNode::ELEMENT_NODE) {
     goto p_dns_ineta_60;                   /* get next sibling stage 2 */
   }
   awcl_name = (HL_WCHAR *) adsp_hlcldomf->amc_call_dom( adsl_node_2, ied_hlcldom_get_node_name );
#ifdef TRACEHL1
   printf( "xl-sdh-ppp-pf-05-l%05d-T m_hlclib_conf() found node %S\n", __LINE__, awcl_name );
#endif
   iml_val = sizeof(achrs_node_dnsi1) / sizeof(achrs_node_dnsi1[0]);
   do {
     bol1 = m_cmp_u16z_u8z( &iml_cmp, awcl_name, (char *) achrs_node_dnsi1[ iml_val - 1 ] );
     if ((bol1) && (iml_cmp == 0)) break;   /* strings are equal       */
     iml_val--;                             /* decrement index         */
   } while (iml_val > 0);
   if (iml_val == 0) {                      /* parameter not found     */
     m_sdh_printf( &dsl_sdh_call_1, "xl-sdh-ppp-pf-05-l%05d-W Error element \"DNS-ineta\" child \"%(ux)s\" not defined - ignored",
                   __LINE__, awcl_name );
     goto p_dns_ineta_60;                   /* get next sibling stage 2 */
   }
   adsl_node_3 = (DOMNode *) adsp_hlcldomf->amc_call_dom( adsl_node_2,
                                                          ied_hlcldom_get_first_child );  /* getFirstChild() */
   if (adsl_node_3 == NULL) {               /* no child found          */
     m_sdh_printf( &dsl_sdh_call_1, "xl-sdh-ppp-pf-05-l%05d-W Error element \"DNS-ineta\" \"%(ux)s\" has no child - ignored",
                   __LINE__, awcl_name );
     goto p_dns_ineta_60;                   /* get next sibling stage 2 */
   }
   do {                                     /* search value            */
     if (((int) (long long) adsp_hlcldomf->amc_call_dom( adsl_node_3, ied_hlcldom_get_node_type ))
           == DOMNode::TEXT_NODE) break;
     adsl_node_3 = (DOMNode *) adsp_hlcldomf->amc_call_dom( adsl_node_3,
                                                            ied_hlcldom_get_next_sibling );
   } while (adsl_node_3);
   if (adsl_node_3 == NULL) {
     m_sdh_printf( &dsl_sdh_call_1, "xl-sdh-ppp-pf-05-l%05d-W Error element \"DNS-ineta\" \"%(ux)s\" no value found - ignored",
                   __LINE__, awcl_name );
     goto p_dns_ineta_60;                   /* get next sibling stage 2 */
   }
   awcl_value = (HL_WCHAR *) adsp_hlcldomf->amc_call_dom( adsl_node_3, ied_hlcldom_get_node_value );  /* getNodeValue() */
   if (iml_val != 1) goto p_dns_ineta_40;   /* retrieve INETA          */
   /* retrieve DNS-name                                                */
   if (iml_len_dns_n > 0) {                 /* check length DNS name   */
     m_sdh_printf( &dsl_sdh_call_1, "xl-sdh-ppp-pf-05-l%05d-W Error element \"DNS-ineta\" \"DNS-name\" defined double - \"%(ux)s\" ignored",
                   __LINE__, awcl_value );
     goto p_dns_ineta_60;                   /* get next sibling stage 2 */
   }
   iml_len_dns_n = m_get_dns_name( chrl_dns_name, sizeof(chrl_dns_name), (HL_WCHAR *) awcl_value );
   if (iml_len_dns_n < 0) {                 /* DNS name is not valid   */
     m_sdh_printf( &dsl_sdh_call_1, "xl-sdh-ppp-pf-05-l%05d-W Error element \"DNS-ineta\" \"DNS-name\" value \"%(ux)s\" invalid - ignored",
                   __LINE__, awcl_value );
   }
   awcl_dns_name = awcl_value;              /* save DNS name           */
   goto p_dns_ineta_60;                     /* get next sibling stage 2 */

   p_dns_ineta_40:                          /* retrieve INETA          */
   if (iml_no_ineta >= MAX_DNS_INETA) {     /* INETA array filled      */
     m_sdh_printf( &dsl_sdh_call_1, "xl-sdh-ppp-pf-05-l%05d-W Error element \"DNS-ineta\" \"ineta\" value \"%(ux)s\" ignored - too many entries",
                   __LINE__, awcl_value );
     goto p_dns_ineta_60;                   /* get next sibling stage 2 */
   }
   iml1 = m_get_ineta_w( &umrl_ineta[ iml_no_ineta ], (HL_WCHAR *) awcl_value );
   if (iml1 < 0) {
     m_sdh_printf( &dsl_sdh_call_1, "xl-sdh-ppp-pf-05-l%05d-W Error element \"DNS-ineta\" \"ineta\" value \"%(ux)s\" invalid - ignored",
                   __LINE__, awcl_value );
     goto p_dns_ineta_60;                   /* get next sibling stage 2 */
   }
   iml1 = 0;                                /* clear index             */
   while (iml1 < iml_no_ineta) {            /* loop over all entries before */
     if (umrl_ineta[ iml1 ] == umrl_ineta[ iml_no_ineta ]) {
       m_sdh_printf( &dsl_sdh_call_1, "xl-sdh-ppp-pf-05-l%05d-W Error element \"DNS-ineta\" \"ineta\" value \"%(ux)s\" defined double - ignored",
                     __LINE__, awcl_value );
       goto p_dns_ineta_60;                 /* get next sibling stage 2 */
     }
     iml1++;                                /* increment index         */
   }
   iml_no_ineta++;                          /* count INETA             */

   p_dns_ineta_60:                          /* get next sibling stage 2 */
   adsl_node_2 = (DOMNode *) adsp_hlcldomf->amc_call_dom( adsl_node_2,
                                                          ied_hlcldom_get_next_sibling );
   if (adsl_node_2) goto p_dns_ineta_20;    /* process DOM node stage 2 */
   if (iml_no_ineta <= 0) {                 /* no INETA defined        */
     m_sdh_printf( &dsl_sdh_call_1, "xl-sdh-ppp-pf-05-l%05d-W Error element \"DNS-ineta\" no \"ineta\" defined - ignored",
                   __LINE__ );
     goto pdomc80;                          /* DOM node processed - next */
   }
   if (iml_len_dns_n <= 0) {                /* DNS name is not defined */
     m_sdh_printf( &dsl_sdh_call_1, "xl-sdh-ppp-pf-05-l%05d-W Error element \"DNS-ineta\" no \"DNS-name\" defined - ignored",
                   __LINE__ );
     goto pdomc80;                          /* DOM node processed - next */
   }
#ifdef XYZ1
   bol1 = m_check_dns_n_double( chrl_dns_name, iml_len_dns_n, (struct dsd_clib1_conf *) achl_stor_new );
   if (bol1 == FALSE) {                     /* DNS name already defined */
     m_sdh_printf( &dsl_sdh_call_1, "xl-sdh-ppp-pf-05-l%05d-W Error element \"DNS-ineta\" \"DNS-name\" value \"%(ux)s\" DNS-name already configured before - ignored",
                   __LINE__, awcl_dns_name );
     goto pdomc80;                          /* DOM node processed - next */
   }
#endif
   iml1 = dsl_clco.imc_len_dns_resp;        /* save old length         */
   iml2 = sizeof(chrs_dns_r_s_1) + iml_len_dns_n + sizeof(chrs_dns_r_a_2)
            + iml_no_ineta * (sizeof(chrs_dns_r_s_3) + sizeof(UNSIG_MED));
   dsl_clco.imc_len_dns_resp
     += sizeof(struct dsd_dns_resp_1)
          + (iml2 + sizeof(void *) - 1)
            & (0 - sizeof(void *));
   achl_stor_old = achl_stor_new;           /* save storage            */
   bol1 = adsp_hlcldomf->amc_aux( adsp_hlcldomf->vpc_userfld,
                                  DEF_AUX_MEMGET,
                                  &achl_stor_new,
                                  sizeof(struct dsd_clib1_conf)
                                    + dsl_clco.imc_len_dns_resp );
   if (bol1 == FALSE) {                     /* error occured           */
     return FALSE;
   }
   if (achl_stor_old) {                     /* copy old values         */
     memcpy( achl_stor_new + sizeof(struct dsd_clib1_conf),
             achl_stor_old + sizeof(struct dsd_clib1_conf),
             iml1 );
     bol1 = adsp_hlcldomf->amc_aux( adsp_hlcldomf->vpc_userfld,
                                    DEF_AUX_MEMFREE,
                                    &achl_stor_old,
                                    sizeof(struct dsd_clib1_conf)
                                      + iml1 );
   }
   /* new DNS response                                                 */
   adsl_dnsr1_new
     = (struct dsd_dns_resp_1 *) (achl_stor_new + sizeof(struct dsd_clib1_conf)
                                    + iml1 );
   adsl_dnsr1_new->imc_len_stor = dsl_clco.imc_len_dns_resp - iml1;  /* storage reserved */
   adsl_dnsr1_new->imc_len_entry = iml2;    /* length of entry         */
   adsl_dnsr1_new->imc_len_dns_n = iml_len_dns_n;  /* length DNS name  */
   achl_w1 = (char *) (adsl_dnsr1_new + 1);
   memcpy( achl_w1, chrs_dns_r_s_1, sizeof(chrs_dns_r_s_1) );
   *((unsigned char *) achl_w1 + 4 + 0) = (unsigned char) (iml_no_ineta >> 8);
   *((unsigned char *) achl_w1 + 4 + 1) = (unsigned char) iml_no_ineta;
   achl_w1 += sizeof(chrs_dns_r_s_1);
   memcpy( achl_w1, chrl_dns_name, iml_len_dns_n );
   achl_w1 += iml_len_dns_n;
   memcpy( achl_w1, chrs_dns_r_a_2, sizeof(chrs_dns_r_a_2) );
   achl_w1 += sizeof(chrs_dns_r_a_2);
   iml1 = 0;                                /* clear index             */
   do {                                     /* loop to copy all INETA  */
     memcpy( achl_w1, chrs_dns_r_s_3, sizeof(chrs_dns_r_s_3) );
     achl_w1 += sizeof(chrs_dns_r_s_3);
     memcpy( achl_w1, &umrl_ineta[ iml1 ], sizeof(UNSIG_MED) );
     achl_w1 += sizeof(UNSIG_MED);
     iml1++;                                /* increment index         */
   } while (iml1 < iml_no_ineta);
   memcpy( achl_stor_new, &dsl_clco, sizeof(struct dsd_clib1_conf) );
// goto pdomc80;                            /* DOM node processed - next */

   pdomc80:                                 /* DOM node processed - next */
   adsl_node_1 = (DOMNode *) adsp_hlcldomf->amc_call_dom( adsl_node_1,
                                                          ied_hlcldom_get_next_sibling );
   if (adsl_node_1) goto pdomc20;           /* process DOM node        */
   if (iml_flag_nat_control == 0) {         /* flag NAT-control defined */
     m_sdh_printf( &dsl_sdh_call_1, "xl-sdh-ppp-pf-05-l%05d-W Error no valid NAT-control found - Server-Data-Hook not usable",
                   __LINE__, awcl1 );
     if (achl_stor_new) {                   /* free storage            */
       bol1 = adsp_hlcldomf->amc_aux( adsp_hlcldomf->vpc_userfld,
                                      DEF_AUX_MEMFREE,
                                      &achl_stor_new,
                                      sizeof(struct dsd_clib1_conf)
                                      + dsl_clco.imc_len_dns_resp );
     }
     return FALSE;
   }
   if (achl_stor_new == NULL) {             /* no DNS-entries found    */
     bol1 = adsp_hlcldomf->amc_aux( adsp_hlcldomf->vpc_userfld,
                                    DEF_AUX_MEMGET,
                                    &achl_stor_new,
                                    sizeof(struct dsd_clib1_conf) );
     if (bol1 == FALSE) {                   /* error occured           */
       return FALSE;
     }
   }
   memcpy( achl_stor_new, &dsl_clco, sizeof(struct dsd_clib1_conf) );
   *adsp_hlcldomf->aac_conf = achl_stor_new;  /* save configuration data */
#ifdef TRACEHL1
   m_sdh_console_out( &dsl_sdh_call_1,
                      achl_stor_new,
                      sizeof(struct dsd_clib1_conf)
                        + dsl_clco.imc_len_dns_resp );
#endif
   return TRUE;
} /* end m_hlclib_conf()                                               */

/* retrieve DNS name                                                   */
static int m_get_dns_name( char *achp_out, int imp_len_out, HL_WCHAR *awcp_value ) {
   char       *achl_wp, *achl_end;          /* write pointer, end      */
   char       *achl_first;                  /* first element with length */

   achl_wp = achp_out;                      /* get output              */
   achl_end = achp_out + imp_len_out;       /* end of output           */

   p_out_00:                                /* output next part        */
   achl_first = achl_wp;                    /* save start element      */
   achl_wp++;                               /* start here              */
   if (achl_wp >= achl_end) return -1;      /* output too long         */

   p_out_20:                                /* output characters       */
   if (*awcp_value >= 0X80) return -1;      /* invalid character       */
   if (   (*awcp_value != 0)                /* not end of string       */
       && (*awcp_value != '.')) {           /* is not separator        */
     if (achl_wp >= achl_end) return -1;    /* output too long         */
     *achl_wp++ = (unsigned char) *awcp_value++;  /* copy value        */
     goto p_out_20;                         /* output characters       */
   }
   *achl_first = (unsigned char) (achl_wp - (achl_first + 1));
   if (*achl_first == 0) return -1;         /* only . / separator      */
   if (*awcp_value != 0) {                  /* not end of string       */
     awcp_value++;                          /* next input character    */
     goto p_out_00;                         /* output next part        */
   }
   if (achl_wp >= achl_end) return -1;      /* output too long         */
   *achl_wp++ = 0;                          /* set length zero as end  */
   return achl_wp - achp_out;               /* all done                */
} /* end m_get_dns_name()                                              */

#ifdef XYZ1
static BOOL m_check_dns_n_double( char *achp_dns_n, int imp_len_dns_n, struct dsd_clib1_conf *adsp_clco ) {
   char       *achl_w1;                     /* working-variable        */
   char       *achl_end;                    /* end of configuration    */

   if (adsp_clco == NULL) return TRUE;      /* first configured value  */
   if (adsp_clco->imc_len_dns_resp == 0) return TRUE;  /* no values before */
   achl_w1 = (char *) (adsp_clco + 1) + adsp_clco->imc_nat_e1 * sizeof(dsd_nat_entry_1);
   achl_end = achl_w1 + adsp_clco->imc_len_dns_resp;  /* add length of DNS responses */
   do {                                     /* loop over all DNS responses */
#define ADSL_DNSR1_W1 ((struct dsd_dns_resp_1 *) achl_w1)
     if (   (imp_len_dns_n == ADSL_DNSR1_W1->imc_len_dns_n)
         && (!memcmp( achp_dns_n, (char *) (ADSL_DNSR1_W1 + 1) + sizeof(chrs_dns_r_i_1), imp_len_dns_n ))) {
       return FALSE;                        /* DNS name already defined */
     }
     achl_w1 += ADSL_DNSR1_W1->imc_len_stor;  /* add storage reserved  */
#undef ADSL_DNSR1_W1
   } while (achl_w1 < achl_end);
   return TRUE;                             /* all valid               */
} /* end m_check_dns_n_double()                                        */
#endif

/** subroutine to process the copy library function                    */
extern "C" HL_DLL_PUBLIC void m_hlclib01( struct dsd_hl_clib_1 *adsp_hl_clib_1 ) {
   int        iml1, iml2, iml3, iml4;       /* working variables       */
   BOOL       bol1;                         /* working variable        */
   BOOL       bol_output;                   /* output has been done    */
   int        iml_len_nhasn;                /* length bytes NHASN      */
   int        iml_len_packet;               /* length bytes packet     */
#ifdef B101204
   int        iml_pos_packet;               /* position in packet      */
#endif
   int        iml_len_ip_header;            /* length of IP header     */
#ifdef XYZ1
// 31.10.10 KB - remove next field
   int        iml_xchg_pos_packet;          /* exchange in IP header   */
#endif
   int        iml_udp_pos_port;             /* port in UDP header      */
   int        iml_type;                     /* type of RR              */
   int        iml_class;                    /* class of RR             */
   int        iml_chs;                      /* calculate checksum      */
#ifdef XYZ1
// 31.10.10 KB - remove next two fields
   int        iml_cmp_disp_ineta;           /* displacement INETA to compare */
   int        iml_repl_disp_ineta;          /* displacement INETA to replace */
#endif
   int        iml_len_dns_n;                /* length DNS name         */
   UNSIG_MED  uml_ineta_w1;                 /* working-variable        */
   UNSIG_MED  uml_ineta_dns;                /* INETA for DNS           */
#ifdef TRACEHL1
   char       chl1;                         /* working variable        */
#endif
#ifdef XYZ1
   char       chl_protocol;                 /* protocol from IP header */
#endif
#ifdef HPPPT1_V21                           /* 18.01.13 KB HOB-PPP-T1 V2.1 */
   char       chl_type;                     /* type received           */
#endif
   char       *achl1, *achl2, *achl3, *achl4, *achl5;  /* working variables */
   char       *achl_end;                    /* end of string to examine */
   char       *achl_work_1;                 /* position work area, up  */
   char       *achl_work_2;                 /* position work area, dow */
   char       *achl_out_ippa;               /* output area IP packet   */
   char       *achl_out_end;                /* output area end         */
   char       *achl_inp;                    /* input data              */
   char       *achl_packet;                 /* start of packet         */
   char       *achl_sip_packet;             /* start of SIP packet     */
// 31.10.10 KB - remove next two fields
   UNSIG_MED  *auml_cnet_so;                /* cnet INETA source       */
   UNSIG_MED  *auml_cnet_de;                /* cnet INETA destination  */
   struct dsd_clib1_contr_1 *adsl_contr_1;  /* for addressing          */
   struct dsd_gather_i_1 *adsl_gai1_inp_start;  /* start input data    */
   struct dsd_gather_i_1 *adsl_gai1_inp_packet;  /* input packet data  */
   struct dsd_gather_i_1 *adsl_gai1_inp_w1;  /* input data             */
   struct dsd_gather_i_1 *adsl_gai1_inp_w2;  /* input data             */
   struct dsd_gather_i_1 *adsl_gai1_out_1;  /* output data             */
#ifdef B130119
   struct dsd_gather_i_1 *adsl_gai1_out_2;  /* output data             */
#endif
   struct dsd_gather_i_1 *adsl_gai1_out_t1;  /* output data            */
   struct dsd_gather_i_1 *adsl_gai1_out_t2;  /* output data            */
#ifndef B130119
   struct dsd_gather_i_1 **aadsl_gai1_out_normal;  /* output data normal direction */
   struct dsd_gather_i_1 **aadsl_gai1_out_client;  /* output data direction to client */
#endif
   struct dsd_cc1_ext *adsl_cc1_ext_w1;     /* structure session control extension */
   struct dsd_cc1_ext *adsl_cc1_ext_w2;     /* structure session control extension */
// struct dsd_nat_entry_1 *adsl_nat_entry_1_w1;  /* structure NAT entry */
// struct dsd_nat_entry_1 *adsl_nat_entry_1_header;  /* structure NAT entry */
#ifdef B130118
   struct dsd_query_dns_resp_1 *adsl_qdnsr1_w1;  /* structure query DNS response */
#endif
   struct dsd_dns_resp_1 *adsl_dnsr1;       /* structure DNS response  */
#ifdef DEBUG_101208_01
   int        iml_d1, iml_d2;               /* working variables       */
   char       *achl_display;                /* pointer display         */
#define D_LEN_LINE_M1 128
#endif
   struct dsd_sdh_call_1 dsl_sdh_call_1;    /* SDH call structure      */
   char       chrl_dns_name[ 256 ];         /* for DNS name            */
#ifdef B110701
   char       chrl_work1[ 1024 ];           /* work area               */
#else
   char       chrl_work1[ 2048 ];           /* work area               */
#endif
   char       chrl_work2[ 4 ];              /* work area               */
#ifndef B130212
   char       chrl_work3[ 2 ];              /* work area               */
#endif

   dsl_sdh_call_1.amc_aux = adsp_hl_clib_1->amc_aux;  /* auxiliary subroutine */
   dsl_sdh_call_1.vpc_userfld = adsp_hl_clib_1->vpc_userfld;  /* User Field Subroutine */
   adsl_contr_1 = (struct dsd_clib1_contr_1 *) adsp_hl_clib_1->ac_ext;
#ifdef DEBUG_101208_01
   achl_display = adsl_contr_1->chrc_display;  /* pointer display      */
#endif
#ifdef TRACEHL1
   {
     char *achh_text = "invalid function";
     switch (adsp_hl_clib_1->inc_func) {
       case DEF_IFUNC_START:
         achh_text = "DEF_IFUNC_START";
         break;
       case DEF_IFUNC_CLOSE:
         achh_text = "DEF_IFUNC_CLOSE";
         break;
       case DEF_IFUNC_FROMSERVER:
         achh_text = "DEF_IFUNC_FROMSERVER";
         break;
       case DEF_IFUNC_TOSERVER:
         achh_text = "DEF_IFUNC_TOSERVER";
         break;
       case DEF_IFUNC_REFLECT:
         achh_text = "DEF_IFUNC_REFLECT";
         break;
     }
     iml1 = iml2 = 0;                       /* length input data       */
     adsl_gai1_inp_w1 = adsp_hl_clib_1->adsc_gather_i_1_in;
     bol1 = FALSE;
     chl1 = 0;
     while (adsl_gai1_inp_w1) {
       iml2++;
       iml1 += adsl_gai1_inp_w1->achc_ginp_end - adsl_gai1_inp_w1->achc_ginp_cur;
       if (   (adsl_gai1_inp_w1->achc_ginp_end > adsl_gai1_inp_w1->achc_ginp_cur)
           && (bol1 == FALSE)) {
         chl1 = *adsl_gai1_inp_w1->achc_ginp_cur;
         bol1 = TRUE;
       }
       adsl_gai1_inp_w1 = adsl_gai1_inp_w1->adsc_next;  /* get next in chain */
     }
     printf( "xl-sdh-ppp-pf-05 m_hlclib01() called inc_func=%d %s input=%p len=%d pieces=%d cont=0X%02X\n",
             adsp_hl_clib_1->inc_func, achh_text,
             adsp_hl_clib_1->adsc_gather_i_1_in, iml1, iml2, (unsigned char) chl1 );
     fflush( stdout );
#ifdef OLD01
     if (adsl_contr_1) {                    /* memory allocated        */
       adsl_contr_1->imc_count_call++;      /* count all calls         */
       if (adsl_contr_1->imc_count_call > 40) {  /* already too many   */
#ifndef HL_UNIX
         Sleep( 500 );
#else
         sleep( 1 );
#endif
       }
     }
#endif
   }
   iml_len_nhasn = 0;                       /* length bytes NHASN      */
#endif
   switch (adsp_hl_clib_1->inc_func) {
     case DEF_IFUNC_START:
       bol1 = adsp_hl_clib_1->amc_aux( adsp_hl_clib_1->vpc_userfld,
                                       DEF_AUX_MEMGET,
                                       &adsp_hl_clib_1->ac_ext,
                                       sizeof(struct dsd_clib1_contr_1) );
       if (bol1 == FALSE) {
         adsp_hl_clib_1->inc_return = DEF_IRET_ERRAU;
         return;
       }
//     memset( adsp_hl_clib_1->ac_ext, 0, sizeof(struct dsd_clib1_contr_1) );
       ((struct dsd_clib1_contr_1 *) adsp_hl_clib_1->ac_ext)->boc_client_header = FALSE;  /* no client header has been received */
#ifndef B110317
       ((struct dsd_clib1_contr_1 *) adsp_hl_clib_1->ac_ext)->umc_ineta_cl_int = 0;  /* INETA client intern in intranet */
#endif
       ((struct dsd_clib1_contr_1 *) adsp_hl_clib_1->ac_ext)->umc_ineta_lower = 0;  /* natted INETAs lower entry */
       ((struct dsd_clib1_contr_1 *) adsp_hl_clib_1->ac_ext)->umc_ineta_upper = 0;  /* natted INETAs upper entry */
       ((struct dsd_clib1_contr_1 *) adsp_hl_clib_1->ac_ext)->umc_ineta_mask = 0;  /* natted INETAs network mask */
       ((struct dsd_clib1_contr_1 *) adsp_hl_clib_1->ac_ext)->umc_ineta_max_used = 0;  /* natted INETAs maximum used INETA */
       ((struct dsd_clib1_contr_1 *) adsp_hl_clib_1->ac_ext)->imc_alloc = 0;  /* number of INETAs allocated */
#ifdef B130118
       ((struct dsd_clib1_contr_1 *) adsp_hl_clib_1->ac_ext)->imc_no_qdnsr1 = 0;  /* number of responses queued */
#endif
       ((struct dsd_clib1_contr_1 *) adsp_hl_clib_1->ac_ext)->adsc_cc1_ext = NULL;  /* structure session control extension */
       bol1 = m_htree1_avl_init( NULL, &((struct dsd_clib1_contr_1 *) adsp_hl_clib_1->ac_ext)->dsc_htree1_avl_cntl_ineta,
                                 &m_cmp_ineta );
       if (bol1 == FALSE) {                 /* error occured           */
         m_sdh_printf( &dsl_sdh_call_1, "xl-sdh-ppp-pf-05-l%05d-W m_htree1_avl_init() failed",
                       __LINE__ );
       }
       return;
     case DEF_IFUNC_CLOSE:
       adsl_cc1_ext_w1 = adsl_contr_1->adsc_cc1_ext;  /* structure session control extension */
       while (adsl_cc1_ext_w1) {            /* loop over all extensions */
         adsl_cc1_ext_w2 = adsl_cc1_ext_w1->adsc_next;  /* save next in chain */
         bol1 = adsp_hl_clib_1->amc_aux( adsp_hl_clib_1->vpc_userfld,
                                         DEF_AUX_MEMFREE,
                                         &adsl_cc1_ext_w1,
                                         sizeof(struct dsd_clib1_contr_1) );
         if (bol1 == FALSE) {               /* error occured           */
           adsp_hl_clib_1->inc_return = DEF_IRET_ERRAU;
           return;
         }
         adsl_cc1_ext_w1 = adsl_cc1_ext_w2;  /* get saved next in chain */
       }
       bol1 = adsp_hl_clib_1->amc_aux( adsp_hl_clib_1->vpc_userfld,
                                       DEF_AUX_MEMFREE,
                                       &adsp_hl_clib_1->ac_ext,
                                       sizeof(struct dsd_clib1_contr_1) );
       if (bol1 == FALSE) {                 /* error occured           */
         adsp_hl_clib_1->inc_return = DEF_IRET_ERRAU;
       }
       return;
     case DEF_IFUNC_REFLECT:
#ifdef TRACEHL_DNS
       m_sdh_printf( &dsl_sdh_call_1, "xl-sdh-ppp-pf-05-l%05d-T time=%lld called DEF_IFUNC_REFLECT",
                   __LINE__, m_get_epoch_ms() );
#endif
       return;
   }
#ifdef B130118
#ifdef TRACEHL_DNS
   if (adsl_contr_1->imc_no_qdnsr1) {
     m_sdh_printf( &dsl_sdh_call_1, "xl-sdh-ppp-pf-05-l%05d-T time=%lld called inc_func=%d imc_no_qdnsr1=%d adsc_gather_i_1_in=0X%p.",
                   __LINE__, m_get_epoch_ms(),
                   adsp_hl_clib_1->inc_func, adsl_contr_1->imc_no_qdnsr1,
                   adsp_hl_clib_1->adsc_gather_i_1_in );
   }
#endif
   if (adsp_hl_clib_1->adsc_gather_i_1_in == NULL) {
     if (   (adsp_hl_clib_1->inc_func == DEF_IFUNC_TOSERVER)
         || (adsl_contr_1->imc_no_qdnsr1 == 0)) {
       return;
     }
   }
#else
   if (adsp_hl_clib_1->adsc_gather_i_1_in == NULL) return;
#endif
#ifdef DEBUG_101208_01
   adsl_gai1_inp_w1 = adsp_hl_clib_1->adsc_gather_i_1_in;  /* start input data */
   while (adsl_gai1_inp_w1) {               /* loop over all gather input */
     iml_d2 = adsl_gai1_inp_w1->achc_ginp_end - adsl_gai1_inp_w1->achc_ginp_cur;
     iml_d1 = sprintf( achl_display, "l%05d input-gather=%p cur=%p end=%p len=%d/0X%p.",
                       __LINE__, adsl_gai1_inp_w1,
                       adsl_gai1_inp_w1->achc_ginp_cur, adsl_gai1_inp_w1->achc_ginp_end,
                       iml_d2, iml_d2 );
     achl_display += iml_d1;
     iml_d2 = D_LEN_LINE_M1 - iml_d1;
     if (iml_d2 > 0) {
       memset( achl_display, ' ', iml_d2 );
       achl_display += iml_d2;
     }
     adsl_gai1_inp_w1 = adsl_gai1_inp_w1->adsc_next;  /* get next in chain */
   }
#endif
#define ADSL_CLCO ((struct dsd_clib1_conf *) adsp_hl_clib_1->ac_conf)
   achl_work_1 = adsp_hl_clib_1->achc_work_area;  /* addr work-area    */
   achl_work_2 = achl_work_1 + adsp_hl_clib_1->inc_len_work_area;  /* length work-area */
#ifdef B130119
   adsl_gai1_out_2 = NULL;                  /* output data             */
#endif
#ifndef B130119
   if (adsp_hl_clib_1->inc_func != DEF_IFUNC_TOSERVER) {  /* send to client */
     aadsl_gai1_out_normal = &adsp_hl_clib_1->adsc_gai1_out_to_client;  /* output data to client */
   } else {                                 /* send to server          */
     aadsl_gai1_out_normal = &adsp_hl_clib_1->adsc_gai1_out_to_server;  /* output data to server */
     aadsl_gai1_out_client = &adsp_hl_clib_1->adsc_gai1_out_to_client;  /* output data direction to client */
   }
#endif
   bol_output = FALSE;                      /* clear output has been done */
#ifdef B130118
   if (   (adsp_hl_clib_1->inc_func == DEF_IFUNC_TOSERVER)
       || (adsl_contr_1->imc_no_qdnsr1 == 0)) {
     goto p_out_dns_80;                     /* end of output stored DNS */
   }
   adsl_qdnsr1_w1 = adsl_contr_1->dsrc_qdnsr1;

   p_out_dns_20:                            /* output stored DNS one entry */
   adsl_dnsr1 = adsl_qdnsr1_w1->adsc_dnsr1;  /* structure DNS response */
   /* use sizeof(void *) instead of sizeof(UNSIG_MED) because of alignement 64-bit systems */
   achl_work_2 -= 3 * sizeof(struct dsd_gather_i_1) + sizeof(void *);
   achl1 = achl_work_1 + MAX_LEN_NHASN;     /* start of packet         */
   achl_work_1 += MAX_LEN_NHASN + 1 + 20 + D_LEN_UDP_HEADER + 2;
// to-do 28.03.09 crosswise NAT INETA in DNS response
   if (achl_work_1 > achl_work_2) {         /* no space for output     */
     if (bol_output == FALSE) goto p_out_80;  /* overflow              */
     iml1 = (char *) (adsl_contr_1->dsrc_qdnsr1 + adsl_contr_1->imc_no_qdnsr1)
              - (char *) adsl_dnsr1;
     memmove( adsl_contr_1->dsrc_qdnsr1,
              adsl_dnsr1,
              iml1 );
     adsl_contr_1->imc_no_qdnsr1
       = iml1 / sizeof(struct dsd_query_dns_resp_1);
     adsp_hl_clib_1->boc_callagain = TRUE;  /* call again this direction */
#ifdef CHECK_OUTPUT_01
     m_check_output_01( adsp_hl_clib_1 );
#endif
     return;                                /* to be called again      */
   }
#define ADSL_GAI1_G1 (((struct dsd_gather_i_1 *) achl_work_2) + 1)
#define ADSL_GAI1_G2 (ADSL_GAI1_G1 + 1)
#define AUML_INETA_G ((UNSIG_MED *) (ADSL_GAI1_G2 + 1))
   ADSL_GAI1_G1->adsc_next = ADSL_GAI1_G2;  /* add INETA in gather     */
   ADSL_GAI1_G1->achc_ginp_cur = (char *) (adsl_dnsr1 + 1);
   ADSL_GAI1_G1->achc_ginp_end = (char *) (adsl_dnsr1 + 1) + adsl_dnsr1->imc_len_entry - sizeof(UNSIG_MED);
// ADSL_GAI1_G2->adsc_next = adsl_gai1_out_2;  /* get chain before      */
   ADSL_GAI1_G2->adsc_next = NULL;          /* set end of chain        */
   ADSL_GAI1_G2->achc_ginp_cur = (char *) AUML_INETA_G;
   ADSL_GAI1_G2->achc_ginp_end = (char *) (AUML_INETA_G + 1);
   *AUML_INETA_G = m_natted_ineta( adsp_hl_clib_1,
                                   (char *) (adsl_dnsr1 + 1) + adsl_dnsr1->imc_len_entry - sizeof(UNSIG_MED) );
   bol_output = TRUE;                       /* output has been done    */
   adsl_gai1_out_1 = (struct dsd_gather_i_1 *) achl_work_2;
   adsl_gai1_out_1->adsc_next = ADSL_GAI1_G1;
#ifdef B130119
   if (adsl_gai1_out_2 == NULL) {
#ifndef NEW_WSP_1102
     adsp_hl_clib_1->adsc_gather_i_1_out = adsl_gai1_out_1;
#else
     if (adsp_hl_clib_1->inc_func != DEF_IFUNC_TOSERVER) {  /* send to client */
       adsp_hl_clib_1->adsc_gai1_out_to_client = adsl_gai1_out_1;  /* output data to client */
     } else {                               /* send to server          */
       adsp_hl_clib_1->adsc_gai1_out_to_server = adsl_gai1_out_1;  /* output data to server */
     }
#endif
   } else {
     adsl_gai1_out_2->adsc_next = adsl_gai1_out_1;
   }
   adsl_gai1_out_2 = ADSL_GAI1_G2;          /* this is last output     */
#endif
#ifndef B130119
   *aadsl_gai1_out_normal = adsl_gai1_out_1;  /* output data normal direction */
   aadsl_gai1_out_normal = &ADSL_GAI1_G2->adsc_next;  /* this is last output */
#endif
// bol_output = TRUE;                       /* output has been done    */
   achl2 = achl1;
   *achl2++ = '4';                          /* PPP IPV4 data           */
   *achl2++ = (unsigned char) 0X45;         /* IPV4 and length         */
   *achl2++ = 0;                            /* Type of Service         */
   iml1 = 20 + D_LEN_UDP_HEADER + 2 + adsl_dnsr1->imc_len_entry;
   *achl2++ = (unsigned char) (iml1 >> 8);  /* first part Total Length */
   *achl2++ = (unsigned char) iml1;         /* second part Total Length */
   *achl2++ = (unsigned char) 0X01;         /* first part Identification */
   *achl2++ = (unsigned char) 0X6A;         /* second part Identification */
   *achl2++ = 0;                            /* Flags + first part Fragment Offset */
   *achl2++ = 0;                            /* second part Fragment Offset */
   *achl2++ = (unsigned char) 0X80;         /* Time to live            */
   *achl2++ = (unsigned char) IPPROTO_UDP;  /* Protocol UDP            */
   *achl2++ = 0;                            /* first part Header checksum */
   *achl2++ = 0;                            /* second part Header checksum */
#ifdef XYZ1
   memcpy( achl2, &adsl_qdnsr1_w1->umc_ineta_dest, sizeof(UNSIG_MED) );
#endif
   memcpy( achl2, &adsl_qdnsr1_w1->umc_ineta_source, sizeof(UNSIG_MED) );
   achl2 += sizeof(UNSIG_MED);
   memcpy( achl2, &adsl_contr_1->umc_ineta_client, sizeof(UNSIG_MED) );
   achl2 += sizeof(UNSIG_MED);
#ifdef TRACEHL_DNS
   m_sdh_printf( &dsl_sdh_call_1, "xl-sdh-ppp-pf-05-l%05d-T time=%lld send DNS response part one",
                 __LINE__, m_get_epoch_ms() );
   m_sdh_console_out( &dsl_sdh_call_1, achl1, achl2 - achl1 );
#endif
   /* calculate header checksum                                        */
   achl3 = achl1 + 1;                       /* here is start IP header */
   iml_chs = 0;                             /* calculate checksum      */
   do {                                     /* loop over IP header     */
     /* calculate checksum                                           */
     iml_chs += (*((unsigned char *) achl3 + 0) << 8)
                  | *((unsigned char *) achl3 + 1);
     achl3 += 2;                            /* next position in header */
   } while (achl3 < achl2);
   while ((iml_chs >> 16) != 0) {           /* continue carry          */
     iml_chs = (iml_chs & 0X0000FFFF) + (iml_chs >> 16);
   }
   iml_chs = ~iml_chs;                      /* negate result           */
   *((unsigned char *) achl1 + 1 + D_POS_IPH_DCHS + 0) = (unsigned char) (iml_chs >> 8);
   *((unsigned char *) achl1 + 1 + D_POS_IPH_DCHS + 1) = (unsigned char) iml_chs;
   /* build UDP header                                                 */
   memcpy( achl2, chrs_port_dns, sizeof(chrs_port_dns) );
   achl2 += sizeof(chrs_port_dns);
   memcpy( achl2, adsl_qdnsr1_w1->chrs_port_dest, sizeof(adsl_qdnsr1_w1->chrs_port_dest) );
   achl2 += sizeof(adsl_qdnsr1_w1->chrs_port_dest);
   iml1 = D_LEN_UDP_HEADER + 2 + adsl_dnsr1->imc_len_entry;
   *achl2++ = (unsigned char) (iml1 >> 8);  /* first part Length UDP packet */
   *achl2++ = (unsigned char) iml1;         /* second part Length UDP packet */
   *achl2++ = 0;                            /* first part checksum     */
   *achl2++ = 0;                            /* second part checksum    */
   memcpy( achl2, adsl_qdnsr1_w1->chrs_id, sizeof(adsl_qdnsr1_w1->chrs_id) );
   achl2 += sizeof(adsl_qdnsr1_w1->chrs_id);
   /* calculate UDP checksum                                           */
   iml_chs = 0;                             /* calculate checksum      */
   do {                                     /* loop over data          */
     /* calculate checksum                                             */
     iml_chs += (*((unsigned char *) achl3 + 0) << 8)
                  | *((unsigned char *) achl3 + 1);
     achl3 += 2;                            /* next position in data   */
   } while (achl3 < achl2);
   /* checksum over constant part                                      */
   achl3 = (char *) (adsl_dnsr1 + 1);
   achl2 = achl3 + adsl_dnsr1->imc_len_entry - sizeof(UNSIG_MED) - 1;
   do {                                     /* loop over data          */
     /* calculate checksum                                             */
     iml_chs += (*((unsigned char *) achl3 + 0) << 8)
                  | *((unsigned char *) achl3 + 1);
     achl3 += 2;                            /* next position in data   */
   } while (achl3 < achl2);
   if (adsl_dnsr1->imc_len_entry & 1) {     /* one byte remaining      */
     iml_chs += *((unsigned char *) achl3 + 0) << 8;
     iml_chs += *((unsigned char *) AUML_INETA_G + 0);
     iml_chs += *((unsigned char *) AUML_INETA_G + 1) << 8;
     iml_chs += *((unsigned char *) AUML_INETA_G + 2);
     iml_chs += *((unsigned char *) AUML_INETA_G + 3) << 8;
   } else {
     iml_chs += (*((unsigned char *) AUML_INETA_G + 0) << 8)
                  | *((unsigned char *) AUML_INETA_G + 1);
     iml_chs += (*((unsigned char *) AUML_INETA_G + 2) << 8)
                  | *((unsigned char *) AUML_INETA_G + 3);
   }
   /* fields in the IP header                                          */
   achl2 = achl1 + 1 + 12;                  /* start source address    */
   achl3 = achl2 + 4 + 4;                   /* after destination address */
   do {                                     /* loop over data          */
     /* calculate checksum                                             */
     iml_chs += (*((unsigned char *) achl2 + 0) << 8)
                  | *((unsigned char *) achl2 + 1);
     achl2 += 2;                            /* next position in data   */
   } while (achl2 < achl3);
   iml_chs += ((unsigned char) IPPROTO_UDP) + D_LEN_UDP_HEADER + 2 + adsl_dnsr1->imc_len_entry;
   while ((iml_chs >> 16) != 0) {           /* continue carry          */
     iml_chs = (iml_chs & 0X0000FFFF) + (iml_chs >> 16);
   }
   iml_chs = ~iml_chs;                      /* negate result           */
   *((unsigned char *) achl1 + 1 + 20 + 6 + 0) = (unsigned char) (iml_chs >> 8);
   *((unsigned char *) achl1 + 1 + 20 + 6 + 1) = (unsigned char) iml_chs;
#undef ADSL_GAI1_G1
#undef ADSL_GAI1_G2
#undef AUML_INETA_G
   /* packet has been prepared                                         */
   iml1 = (achl_work_1 - achl1) + adsl_dnsr1->imc_len_entry;  /* length of packet */
   iml2 = 0;                                /* clear more bit          */
   do {
     *(--achl1) = (unsigned char) ((iml1 & 0X7F) | iml2);
     iml1 >>= 7;                            /* remove bits             */
     iml2 = 0X80;                           /* set more bit            */
   } while (iml1 > 0);
   adsl_gai1_out_1->achc_ginp_cur = achl1;
   adsl_gai1_out_1->achc_ginp_end = achl_work_1;
#ifdef TRACEHL1
   iml1 = (achl_work_1 - achl1) + adsl_dnsr1->imc_len_entry;  /* length of packet */
   m_sdh_printf( &dsl_sdh_call_1, "xl-sdh-ppp-pf-05-l%05d-T DNS response packet len=%d.",
                 __LINE__, iml1 );
   m_dump_gather( &dsl_sdh_call_1, adsl_gai1_out_1, iml1 );
#endif
#ifdef TRACEHL_DNS
   iml1 = (achl_work_1 - achl1) + adsl_dnsr1->imc_len_entry;  /* length of packet */
   m_sdh_printf( &dsl_sdh_call_1, "xl-sdh-ppp-pf-05-l%05d-T time=%lld DNS response packet len=%d.",
                 __LINE__, m_get_epoch_ms(), iml1 );
   m_dump_gather( &dsl_sdh_call_1, adsl_gai1_out_1, iml1 );
#endif
   adsl_qdnsr1_w1++;                        /* next entry output       */
   if (adsl_qdnsr1_w1
         < (adsl_contr_1->dsrc_qdnsr1 + adsl_contr_1->imc_no_qdnsr1)) {
     goto p_out_dns_20;                     /* output stored DNS one entry */
   }
   adsl_contr_1->imc_no_qdnsr1 = 0;         /* no more entry           */
   if (adsp_hl_clib_1->adsc_gather_i_1_in == NULL) return;
#ifndef CHECK_OUTPUT_01
   if (adsp_hl_clib_1->adsc_gather_i_1_in == NULL) return;
#else
   if (adsp_hl_clib_1->adsc_gather_i_1_in == NULL) {
     m_check_output_01( adsp_hl_clib_1 );
     return;
   }
#endif

   p_out_dns_80:                            /* end of output stored DNS */
#endif
   adsl_gai1_inp_start = adsl_gai1_inp_w1 = adsp_hl_clib_1->adsc_gather_i_1_in;  /* start input data */
   achl_inp = adsl_gai1_inp_w1->achc_ginp_cur;  /* start input data    */
   if (adsp_hl_clib_1->inc_func == DEF_IFUNC_FROMSERVER) {
#ifdef XYZ1
     iml_cmp_disp_ineta = offsetof( struct dsd_nat_entry_1, umc_ineta_real );  /* displacement INETA to compare */
     iml_repl_disp_ineta = offsetof( struct dsd_nat_entry_1, umc_ineta_translated );  /* displacement INETA to replace */
     iml_xchg_pos_packet = 12;              /* exchange in IP header   */
#endif
     iml_udp_pos_port = 0;                  /* port in UDP header      */
#ifdef XYZ1
     auml_cnet_so = &ADSL_CLCO->umc_cnat_ineta_real;  /* cnet INETA source */
     auml_cnet_de = &ADSL_CLCO->umc_cnat_ineta_translated;  /* cnet INETA destination */
#endif
     goto p_check_recv_00;                  /* check received packet   */
   }
   if (adsp_hl_clib_1->inc_func == DEF_IFUNC_TOSERVER) {
#ifdef XYZ1
     iml_cmp_disp_ineta = offsetof( struct dsd_nat_entry_1, umc_ineta_translated );  /* displacement INETA to compare */
     iml_repl_disp_ineta = offsetof( struct dsd_nat_entry_1, umc_ineta_real );  /* displacement INETA to replace */
     iml_xchg_pos_packet = 16;              /* exchange in IP header   */
#endif
     iml_udp_pos_port = 2;                  /* port in UDP header      */
#ifdef XYZ1
     auml_cnet_so = &ADSL_CLCO->umc_cnat_ineta_translated;  /* cnet INETA source */
     auml_cnet_de = &ADSL_CLCO->umc_cnat_ineta_real;  /* cnet INETA destination */
#endif
     if (adsl_contr_1->boc_client_header) {  /* client header has been received */
       goto p_check_recv_00;                /* check received packet   */
     }
   } else {                                 /* is other function       */
#ifdef CHECK_OUTPUT_01
     m_check_output_01( adsp_hl_clib_1 );
#endif
     return;                                /* nothing to do           */
   }
   bol1 = FALSE;                            /* reset state             */

   p_header_00:                             /* search in header        */
   while (achl_inp >= adsl_gai1_inp_w1->achc_ginp_end) {  /* end of gather */
     adsl_gai1_inp_w1 = adsl_gai1_inp_w1->adsc_next;  /* get next gather in chain */
#ifndef CHECK_OUTPUT_01
     if (adsl_gai1_inp_w1 == NULL) return;  /* end of input data       */
#else
     if (adsl_gai1_inp_w1 == NULL) {        /* end of input data       */
       m_check_output_01( adsp_hl_clib_1 );
       return;
     }
#endif
     achl_inp = adsl_gai1_inp_w1->achc_ginp_cur;  /* start in gather   */
   }
   if (*achl_inp == CHAR_CR) {              /* carriage-return found   */
     bol1 = TRUE;                           /* set state               */
   } else if (*achl_inp == CHAR_LF) {       /* line-feed found         */
     if (bol1) {                            /* found carriage-return before */
       achl_inp++;                          /* after this character    */
       adsl_contr_1->boc_client_header = TRUE;  /* client header has been received */
       goto p_out_00;                       /* output of these data    */
     }
   } else {                                 /* normal character received */
     bol1 = FALSE;                          /* set state               */
   }
   achl_inp++;                              /* after this character    */
   goto p_header_00;                        /* search in header        */

   p_check_recv_00:                         /* check received packet   */
#ifdef HPPPT1_V21                           /* 18.01.13 KB HOB-PPP-T1 V2.1 */
   adsl_gai1_inp_w1 = adsl_gai1_inp_start;  /* start input data        */
   while (achl_inp >= adsl_gai1_inp_w1->achc_ginp_end) {  /* end of gather */
     adsl_gai1_inp_w1 = adsl_gai1_inp_w1->adsc_next;  /* get next gather in chain */
     if (adsl_gai1_inp_w1 == NULL) {        /* end of input data       */
#ifdef CHECK_OUTPUT_01
       m_check_output_01( adsp_hl_clib_1 );
#endif
       return;                              /* to be called again      */
     }
     achl_inp = adsl_gai1_inp_w1->achc_ginp_cur;  /* start in gather   */
   }
   chl_type = *achl_inp++;                  /* type received           */
   switch (chl_type & 0XF0) {               /* first character         */
     case 0X30:                             /* control or PPP          */
       iml_len_nhasn = 0;                   /* clear length bytes NHASN */
       iml_len_packet = 0;                  /* clear length bytes packet */
       goto p_check_recv_20;                /* decode length NHASN     */
     case 0X40:                             /* IPV4                    */
       achl_out_ippa = (char *) (((long long int) (achl_work_1 + sizeof(UNSIG_MED) - 1)) & (0 - sizeof(UNSIG_MED)));
       if ((achl_out_ippa + 5 * 4 + sizeof(struct dsd_gather_i_1)) > achl_work_2) {  /* no space for output */
       adsp_hl_clib_1->boc_callagain = TRUE;  /* call again this direction */
#ifdef CHECK_OUTPUT_01
         m_check_output_01( adsp_hl_clib_1 );
#endif
         return;                            /* to be called again      */
       }
       iml_len_ip_header = (chl_type & 0X0F) << 2;  /* length of IP header */
       if (iml_len_ip_header < (5 * 4)) {   /* IP header too short     */
         goto p_inv_data_00;                /* input data invalid      */
       }
       *achl_out_ippa = chl_type;           /* copy first byte         */
       achl1 = achl_out_ippa + 1;           /* copy here               */
       achl2 = achl_out_ippa + 4;           /* end of copy             */
       break;
     case 0X60:                             /* IPV6                    */
       achl_out_ippa = (char *) (((long long int) (achl_work_1 + sizeof(UNSIG_MED) - 1)) & (0 - sizeof(UNSIG_MED)));
       if ((achl_out_ippa + D_LEN_HEADER_IPV6 + sizeof(struct dsd_gather_i_1)) > achl_work_2) {  /* no space for output */
       adsp_hl_clib_1->boc_callagain = TRUE;  /* call again this direction */
#ifdef CHECK_OUTPUT_01
         m_check_output_01( adsp_hl_clib_1 );
#endif
         return;                            /* to be called again      */
       }
       *achl_out_ippa = chl_type;           /* copy first byte         */
       achl1 = achl_out_ippa + 1;           /* copy here               */
       achl2 = achl_out_ippa + 6;           /* end of copy             */
       break;
     default:                               /* other value             */
       m_sdh_printf( &dsl_sdh_call_1, "xl-sdh-ppp-pf-05-l%05d-E packet invalid control character 0X%02X.",
                     __LINE__, (unsigned char) chl_type );
       adsp_hl_clib_1->inc_return = DEF_IRET_END;  /* return code      */
       return;
   }
   do {                                     /* loop copy characters    */
     iml1 = adsl_gai1_inp_w1->achc_ginp_end - achl_inp;  /* length of data */
     if (iml1 == 0) {                       /* no more data            */
       adsl_gai1_inp_w1 = adsl_gai1_inp_w1->adsc_next;  /* get next gather in chain */
       if (adsl_gai1_inp_w1 == NULL) {      /* end of input data       */
#ifdef CHECK_OUTPUT_01
         m_check_output_01( adsp_hl_clib_1 );
#endif
         return;                            /* to be called again      */
       }
       achl_inp = adsl_gai1_inp_w1->achc_ginp_cur;  /* start in gather */
     } else {                               /* found data              */
       iml2 = achl2 - achl1;                /* data to copy            */
       if (iml2 > iml1) iml2 = iml1;
       memcpy( achl1, achl_inp, iml2 );
       achl1 += iml2;
       achl_inp += iml2;
     }
   } while (achl1 < achl2);
   if ((chl_type & 0XF0) == 0X60) {         /* first character IPV6    */
     iml_len_packet = ((*((unsigned char *) achl_out_ippa + 4) << 8)
                         | *((unsigned char *) achl_out_ippa + 5))
                      + D_LEN_HEADER_IPV6;
//   iml_len_ip_header = D_LEN_HEADER_IPV6;  /* length of IPV6 header  */
     goto p_out_00;                         /* output unchanged        */
   }
   iml_len_packet = (*((unsigned char *) achl_out_ippa + 2) << 8)
                      | *((unsigned char *) achl_out_ippa + 3);
   if (iml_len_packet > HL_MAX_LEN_PACKET) {  /* packet too long       */
     m_sdh_printf( &dsl_sdh_call_1, "xl-sdh-ppp-pf-08-l%05d-W packet length %d too high - ignored",
                   __LINE__, iml_len_packet );
     goto p_out_00;                         /* output unchanged        */
   }
   if (iml_len_packet < (1 + iml_len_ip_header)) {  /* packet too short */
     goto p_inv_data_00;                    /* input data invalid      */
   }
   achl_packet = achl_inp;                  /* start of packet         */
   adsl_gai1_inp_packet = adsl_gai1_inp_w1;  /* input packet data      */

   /* first check if complete packet is in input data                  */
   iml1 = iml_len_packet - (achl2 - achl_out_ippa);  /* get length remaining packet */

   p_check_recv_04:                         /* read over packet        */
   while (achl_inp >= adsl_gai1_inp_w1->achc_ginp_end) {  /* end of gather */
     adsl_gai1_inp_w1 = adsl_gai1_inp_w1->adsc_next;  /* get next gather in chain */
     if (adsl_gai1_inp_w1 == NULL) {        /* end of input data       */
#ifdef CHECK_OUTPUT_01
       m_check_output_01( adsp_hl_clib_1 );
#endif
       return;                              /* to be called again      */
     }
     achl_inp = adsl_gai1_inp_w1->achc_ginp_cur;  /* start in gather   */
   }
   iml2 = adsl_gai1_inp_w1->achc_ginp_end - achl_inp;  /* length this part */
   if (iml2 > iml1) iml2 = iml1;            /* only as long as requested */
   achl_inp += iml2;                        /* add length this part    */
   iml1 -= iml2;                            /* subtract length this part */
   if (iml1) goto p_check_recv_04;          /* read over packet        */

   achl_sip_packet = NULL;                  /* clear start of SIP packet */

   /* copy the first part of the packet to the output area             */
   achl_out_end = achl_out_ippa + iml_len_ip_header;
   adsl_gai1_out_t1 = (struct dsd_gather_i_1 *) achl_work_2 - 1;  /* output data */
   if (achl_out_end > ((char *) adsl_gai1_out_t1)) {  /* no space for output */
     adsp_hl_clib_1->boc_callagain = TRUE;  /* call again this direction */
#ifdef CHECK_OUTPUT_01
     m_check_output_01( adsp_hl_clib_1 );
#endif
     return;                                /* to be called again      */
   }
   adsl_gai1_out_t1->achc_ginp_cur = achl_out_ippa;  /* start of gather */
   adsl_gai1_out_t1->achc_ginp_end = achl_out_end;  /* end of gather   */
   iml1 = achl_out_end - achl2;             /* end part one            */

   p_check_recv_08:                         /* copy IPV4 packet part one */
   while (achl_packet >= adsl_gai1_inp_packet->achc_ginp_end) {  /* end of gather */
     adsl_gai1_inp_packet = adsl_gai1_inp_packet->adsc_next;  /* get next gather in chain */
     if (adsl_gai1_inp_packet == NULL) goto p_illogic_00;  /* program illogic */
     achl_packet = adsl_gai1_inp_packet->achc_ginp_cur;  /* start in gather */
   }
   iml2 = adsl_gai1_inp_packet->achc_ginp_end - achl_packet;
   if (iml2 > iml1) iml2 = iml1;
   memcpy( achl_out_end - iml1, achl_packet, iml2 );
   achl_packet += iml2;
   iml1 -= iml2;
   if (iml1) goto p_check_recv_08;          /* copy IPV4 packet part one */
#ifdef DEBUG_101207_02
   if (bol_output) {                        /* output has been done    */
     m_sdh_printf( &dsl_sdh_call_1, "xl-sdh-ppp-pf-05-l%05d-T second packet for output iml_len_packet=%d/0X%p.",
                   __LINE__, iml_len_packet, iml_len_packet );
   }
#endif
#define CHL_PROTOCOL *(achl_out_ippa + D_POS_IPH_PROT)  /* protocol from IP header */
#ifdef TRACEHL1
   m_sdh_printf( &dsl_sdh_call_1, "xl-sdh-ppp-pf-05-l%05d-T packet protocol=0X%02X.",
                 __LINE__, (unsigned char) CHL_PROTOCOL );
#endif
   /* check TCP or UDP header                                          */
#ifndef TRY_101205
   if (CHL_PROTOCOL == IPPROTO_TCP) {       /* protocol TCP from IP header */
     iml1 = 20;                             /* length TCP header without options */
   } else if (CHL_PROTOCOL == IPPROTO_UDP) {  /* protocol UDP from IP header */
     iml1 = D_LEN_UDP_HEADER;               /* length UDP header       */
   } else goto p_check_recv_80;             /* all headers are in output area */
#else
   if (CHL_PROTOCOL == IPPROTO_TCP) {       /* protocol TCP from IP header */
     iml1 = 20;                             /* length TCP header without options */
   } else if ((CHL_PROTOCOL & 0X0F) == (IPPROTO_UDP & 0X0F)) {  /* protocol UDP from IP header */
     iml1 = D_LEN_UDP_HEADER;               /* length UDP header       */
   } else goto p_check_recv_80;             /* all headers are in output area */
#endif
   if (iml_len_packet < (iml_len_ip_header + iml1)) {  /* packet too short */
     goto p_inv_data_00;                    /* input data invalid      */
   }
   achl_out_end += iml1;                    /* new end of headers      */
   if (achl_out_end > ((char *) adsl_gai1_out_t1)) {  /* no space for output */
     adsp_hl_clib_1->boc_callagain = TRUE;  /* call again this direction */
#ifdef CHECK_OUTPUT_01
     m_check_output_01( adsp_hl_clib_1 );
#endif
     return;                                /* to be called again      */
   }
   adsl_gai1_out_t1->achc_ginp_end = achl_out_end;  /* end of gather   */

   p_check_recv_12:                         /* copy IPV4 packet part two */
   while (achl_packet >= adsl_gai1_inp_packet->achc_ginp_end) {  /* end of gather */
     adsl_gai1_inp_packet = adsl_gai1_inp_packet->adsc_next;  /* get next gather in chain */
     if (adsl_gai1_inp_packet == NULL) goto p_illogic_00;  /* program illogic */
     achl_packet = adsl_gai1_inp_packet->achc_ginp_cur;  /* start in gather */
   }
   iml2 = adsl_gai1_inp_packet->achc_ginp_end - achl_packet;
   if (iml2 > iml1) iml2 = iml1;
   memcpy( achl_out_end - iml1, achl_packet, iml2 );
   achl_packet += iml2;
   iml1 -= iml2;
   if (iml1) goto p_check_recv_12;          /* copy IPV4 packet part two */
   goto p_check_recv_80;                    /* check first part packet */
#endif
#ifndef HPPPT1_V21                          /* 18.01.13 KB HOB-PPP-T1 V2.1 */
   iml_len_nhasn = 0;                       /* clear length bytes NHASN */
   iml_len_packet = 0;                      /* clear length bytes packet */
   adsl_gai1_inp_w1 = adsl_gai1_inp_start;  /* start input data        */
#ifdef DEBUG_101208_01
   iml_d1 = sprintf( achl_display, "l%05d adsl_gai1_inp_w1=%p achl_inp=%p achl_work_1=%p achl_work_2=%p.",
                     __LINE__, adsl_gai1_inp_w1, achl_inp, achl_work_1, achl_work_2 );
   achl_display += iml_d1;
   iml_d2 = D_LEN_LINE_M1 - iml_d1;
   if (iml_d2 > 0) {
     memset( achl_display, ' ', iml_d2 );
     achl_display += iml_d2;
   }
#endif
#endif

   p_check_recv_20:                         /* decode length NHASN     */
   while (achl_inp >= adsl_gai1_inp_w1->achc_ginp_end) {  /* end of gather */
     adsl_gai1_inp_w1 = adsl_gai1_inp_w1->adsc_next;  /* get next gather in chain */
     if (adsl_gai1_inp_w1 == NULL) {        /* end of input data       */
#ifdef B130118
       if (   (adsp_hl_clib_1->inc_func == DEF_IFUNC_TOSERVER)
           && (adsl_contr_1->imc_no_qdnsr1)) {  /* number of responses queued */
         adsp_hl_clib_1->boc_callrevdir = TRUE;  /* call on reverse direction */
       }
#endif
#ifdef CHECK_OUTPUT_01
       m_check_output_01( adsp_hl_clib_1 );
#endif
       return;                              /* to be called again      */
     }
     achl_inp = adsl_gai1_inp_w1->achc_ginp_cur;  /* start in gather   */
   }
   iml_len_packet <<= 7;                    /* shift old value         */
   iml_len_packet |= *achl_inp++ & 0X7F;    /* apply new bits          */
   iml_len_nhasn++;                         /* increment length bytes NHASN */
   if ((unsigned char) *(achl_inp - 1) & 0X80) {  /* more bit set      */
     if (iml_len_nhasn > MAX_LEN_NHASN) goto p_inv_data_00;  /* input data invalid */
     goto p_check_recv_20;                  /* decode length NHASN     */
   }
#ifndef HPPPT1_V21                          /* 18.01.13 KB HOB-PPP-T1 V2.1 */
   if (iml_len_packet <= 1) goto p_inv_data_00;  /* input data invalid */
#endif
#ifdef HPPPT1_V21                           /* 18.01.13 KB HOB-PPP-T1 V2.1 */
   if (iml_len_packet <= 0) goto p_inv_data_00;  /* input data invalid */
#endif
   achl_packet = achl_inp;                  /* start of packet         */
   adsl_gai1_inp_packet = adsl_gai1_inp_w1;  /* input packet data      */
   iml1 = iml_len_packet;                   /* get length packet       */

   p_check_recv_40:                         /* read over packet        */
   while (achl_inp >= adsl_gai1_inp_w1->achc_ginp_end) {  /* end of gather */
     adsl_gai1_inp_w1 = adsl_gai1_inp_w1->adsc_next;  /* get next gather in chain */
     if (adsl_gai1_inp_w1 == NULL) {        /* end of input data       */
#ifdef B130118
       if (   (adsp_hl_clib_1->inc_func == DEF_IFUNC_TOSERVER)
           && (adsl_contr_1->imc_no_qdnsr1)) {  /* number of responses queued */
         adsp_hl_clib_1->boc_callrevdir = TRUE;  /* call on reverse direction */
       }
#endif
#ifdef CHECK_OUTPUT_01
       m_check_output_01( adsp_hl_clib_1 );
#endif
       return;                              /* to be called again      */
     }
     achl_inp = adsl_gai1_inp_w1->achc_ginp_cur;  /* start in gather   */
   }
   iml2 = adsl_gai1_inp_w1->achc_ginp_end - achl_inp;  /* length this part */
   if (iml2 > iml1) iml2 = iml1;            /* only as long as requested */
   achl_inp += iml2;                        /* add length this part    */
   iml1 -= iml2;                            /* subtract length this part */
   if (iml1) goto p_check_recv_40;          /* read over packet        */

#ifndef HPPPT1_V21                          /* 18.01.13 KB HOB-PPP-T1 V2.1 */
   /* check if PPP data, IP, IPV4                                      */
   iml1 = 0;                                /* reset state             */

   p_check_recv_60:                         /* check first part packet */
   while (achl_packet >= adsl_gai1_inp_packet->achc_ginp_end) {  /* end of gather */
     adsl_gai1_inp_packet = adsl_gai1_inp_packet->adsc_next;  /* get next gather in chain */
     if (adsl_gai1_inp_packet == NULL) goto p_illogic_00;  /* program illogic */
     achl_packet = adsl_gai1_inp_packet->achc_ginp_cur;  /* start in gather */
   }
   if (achl_packet == achl_inp) goto p_out_00;  /* content too short   */
   switch (iml1) {                          /* depend on state         */
     case 0:
#ifdef HPPPT1_V14_RECV                      /* 26.08.12 KB HOB-PPP-T1 V1.4 receive */
       if ((*achl_packet & 0XF0) == 0X40) {  /* IPV4 data found         */
         iml1 = 3;                          /* next end of loop        */
         break;
       }
       if ((*achl_packet & 0XF0) == 0X60) {  /* IPV6 data found         */
         goto p_out_00;                     /* output unchanged        */
       }
#endif
       if (*achl_packet == '4') {           /* PPP IPV4 data found     */
         iml1 = 1;                          /* next is packet case 2   */
         break;
       }
       if (*achl_packet == '1') break;      /* PPP data found          */
       if (*achl_packet == '0') {
         goto p_contr_00;                   /* control packet found    */
       }
       goto p_out_00;                       /* output unchanged        */
     case 1:
       iml1 = 2;                            /* next is end of compare  */
       if (((unsigned char) *achl_packet) == ucrs_ctrl_ipcp[0]) {
         goto p_ipcp_00;                    /* process IPCP            */
       }
       goto p_out_00;                       /* output unchanged        */
     case 2:                                /* check IPV4 header       */
       if ((*achl_packet & 0XF0) != 0X40) goto p_out_00;  /* not IPV4  */
       break;
   }
   achl_packet++;                           /* increment input         */
   iml1++;                                  /* increment state         */
   if (iml1 < 3) goto p_check_recv_60;      /* check first part packet */
#ifdef TRACEHL1
   m_sdh_printf( &dsl_sdh_call_1, "xl-sdh-ppp-pf-05-l%05d-T packet iml_len_nhasn=%d iml_len_packet=%d.",
                 __LINE__, iml_len_nhasn, iml_len_packet );
   m_dump_gather( &dsl_sdh_call_1, adsl_gai1_inp_start, iml_len_nhasn + iml_len_packet );
#endif
   iml_len_ip_header = (*(achl_packet - 1) & 0X0F) << 2;  /* length of IP header */
   if (iml_len_ip_header < (5 * 4)) {       /* IP header too short     */
     goto p_inv_data_00;                    /* input data invalid      */
   }
   if (iml_len_packet < (1 + iml_len_ip_header)) {  /* packet too short */
     goto p_inv_data_00;                    /* input data invalid      */
   }
   achl_sip_packet = NULL;                  /* clear start of SIP packet */

   /* copy the first part of the packet to the output area             */
   achl_out_ippa = (char *) (((long long int) (achl_work_1 + MAX_LEN_NHASN + 1 + sizeof(UNSIG_MED) - 1)) & (0 - sizeof(UNSIG_MED)));
   achl_out_end = achl_out_ippa + iml_len_ip_header;
   adsl_gai1_out_t1 = (struct dsd_gather_i_1 *) achl_work_2 - 1;  /* output data */
   if (achl_out_end > ((char *) adsl_gai1_out_t1)) {  /* no space for output */
     adsp_hl_clib_1->boc_callagain = TRUE;  /* call again this direction */
#ifdef CHECK_OUTPUT_01
     m_check_output_01( adsp_hl_clib_1 );
#endif
     return;                                /* to be called again      */
   }
   adsl_gai1_out_t1->achc_ginp_end = achl_out_end;  /* end of gather   */
   *achl_out_ippa = *(achl_packet - 1);     /* copy first byte IP header */
   iml1 = iml_len_ip_header - (2 - 1);      /* end part one            */

   p_check_recv_64:                         /* copy IPV4 packet part one */
   while (achl_packet >= adsl_gai1_inp_packet->achc_ginp_end) {  /* end of gather */
     adsl_gai1_inp_packet = adsl_gai1_inp_packet->adsc_next;  /* get next gather in chain */
     if (adsl_gai1_inp_packet == NULL) goto p_illogic_00;  /* program illogic */
     achl_packet = adsl_gai1_inp_packet->achc_ginp_cur;  /* start in gather */
   }
   iml2 = adsl_gai1_inp_packet->achc_ginp_end - achl_packet;
   if (iml2 > iml1) iml2 = iml1;
   memcpy( achl_out_end - iml1, achl_packet, iml2 );
   achl_packet += iml2;
   iml1 -= iml2;
   if (iml1) goto p_check_recv_64;          /* copy IPV4 packet part one */
#ifdef DEBUG_101207_02
   if (bol_output) {                        /* output has been done    */
     m_sdh_printf( &dsl_sdh_call_1, "xl-sdh-ppp-pf-05-l%05d-T second packet for output iml_len_packet=%d/0X%p.",
                   __LINE__, iml_len_packet, iml_len_packet );
   }
#endif
#define CHL_PROTOCOL *(achl_out_ippa + D_POS_IPH_PROT)  /* protocol from IP header */
#ifdef TRACEHL1
   m_sdh_printf( &dsl_sdh_call_1, "xl-sdh-ppp-pf-05-l%05d-T packet protocol=0X%02X.",
                 __LINE__, (unsigned char) CHL_PROTOCOL );
#endif
   /* check TCP or UDP header                                          */
#ifndef TRY_101205
   if (CHL_PROTOCOL == IPPROTO_TCP) {       /* protocol TCP from IP header */
     iml1 = 20;                             /* length TCP header without options */
   } else if (CHL_PROTOCOL == IPPROTO_UDP) {  /* protocol UDP from IP header */
     iml1 = D_LEN_UDP_HEADER;               /* length UDP header       */
   } else goto p_check_recv_80;             /* all headers are in output area */
#else
   if (CHL_PROTOCOL == IPPROTO_TCP) {       /* protocol TCP from IP header */
     iml1 = 20;                             /* length TCP header without options */
   } else if ((CHL_PROTOCOL & 0X0F) == (IPPROTO_UDP & 0X0F)) {  /* protocol UDP from IP header */
     iml1 = D_LEN_UDP_HEADER;               /* length UDP header       */
   } else goto p_check_recv_80;             /* all headers are in output area */
#endif
   if (iml_len_packet < (1 + iml_len_ip_header + iml1)) {  /* packet too short */
     goto p_inv_data_00;                    /* input data invalid      */
   }
   achl_out_end += iml1;                    /* new end of headers      */
   if (achl_out_end > ((char *) adsl_gai1_out_t1)) {  /* no space for output */
     adsp_hl_clib_1->boc_callagain = TRUE;  /* call again this direction */
#ifdef CHECK_OUTPUT_01
     m_check_output_01( adsp_hl_clib_1 );
#endif
     return;                                /* to be called again      */
   }
   adsl_gai1_out_t1->achc_ginp_end = achl_out_end;  /* end of gather   */

   p_check_recv_68:                         /* copy IPV4 packet part two */
   while (achl_packet >= adsl_gai1_inp_packet->achc_ginp_end) {  /* end of gather */
     adsl_gai1_inp_packet = adsl_gai1_inp_packet->adsc_next;  /* get next gather in chain */
     if (adsl_gai1_inp_packet == NULL) goto p_illogic_00;  /* program illogic */
     achl_packet = adsl_gai1_inp_packet->achc_ginp_cur;  /* start in gather */
   }
   iml2 = adsl_gai1_inp_packet->achc_ginp_end - achl_packet;
   if (iml2 > iml1) iml2 = iml1;
   memcpy( achl_out_end - iml1, achl_packet, iml2 );
   achl_packet += iml2;
   iml1 -= iml2;
   if (iml1) goto p_check_recv_68;          /* copy IPV4 packet part two */
#endif
#ifdef HPPPT1_V21                           /* 18.01.13 KB HOB-PPP-T1 V2.1 */
   while (achl_packet >= adsl_gai1_inp_packet->achc_ginp_end) {  /* end of gather */
     adsl_gai1_inp_packet = adsl_gai1_inp_packet->adsc_next;  /* get next gather in chain */
     if (adsl_gai1_inp_packet == NULL) goto p_illogic_00;  /* program illogic */
     achl_packet = adsl_gai1_inp_packet->achc_ginp_cur;  /* start in gather */
   }
// if (achl_packet == achl_inp) goto p_out_00;  /* content too short   */
   if (chl_type == '0') {
     goto p_contr_00;                       /* control packet found    */
   }
   if (chl_type != '1') {                   /* not PPP data            */
     goto p_out_00;                         /* output unchanged        */
   }
   if (((unsigned char) *achl_packet) == ucrs_ctrl_ipcp[0]) {
     goto p_ipcp_00;                        /* process IPCP            */
   }
   goto p_out_00;                           /* output unchanged        */

#define CHL_PROTOCOL *(achl_out_ippa + D_POS_IPH_PROT)  /* protocol from IP header */
#endif

   p_check_recv_80:                         /* all headers are in output area */
   memcpy( &uml_ineta_dns, achl_out_ippa + 16, sizeof(UNSIG_MED) );  /* INETA for DNS */
   /* apply NAT                                                        */
   if (adsp_hl_clib_1->inc_func == DEF_IFUNC_TOSERVER) {
     *((UNSIG_MED *) (achl_out_ippa + 12)) = adsl_contr_1->umc_ineta_cl_int;  /* INETA client intern in intranet */
     *((UNSIG_MED *) (achl_out_ippa + 16))
       = m_original_ineta( adsp_hl_clib_1, achl_out_ippa + 16 );
   } else {
     *((UNSIG_MED *) (achl_out_ippa + 12))
       = m_natted_ineta( adsp_hl_clib_1, achl_out_ippa + 12 );
     *((UNSIG_MED *) (achl_out_ippa + 16)) = adsl_contr_1->umc_ineta_client;  /* INETA client in tunnel */
   }
#ifdef B101204
// iml_pos_packet = 1 + D_LEN_IP_H_P1;      /* first part has been copied */
#endif

// p_check_sip_00:                          /* has to check SIP        */
#ifndef TRY_101205
   if (CHL_PROTOCOL != IPPROTO_UDP) {       /* protocol from IP header */
     goto p_rem_packet_00;                  /* remaining part of packet in gather */
   }
#else
   if ((CHL_PROTOCOL & 0X0F) != (IPPROTO_UDP & 0X0F)) {  /* protocol from IP header */
     goto p_rem_packet_00;                  /* remaining part of packet in gather */
   }
#endif
   if (ADSL_CLCO->boc_alg_sip == FALSE) {   /* do not use ALG for SIP VoIP protocol */
     goto p_check_dns_00;                   /* has to check DNS        */
   }
// 28.08.12 KB - alignment
#ifdef B120828
   if (*((unsigned short int *) chrs_port_dns)
         == *((unsigned short int *) (achl_out_ippa + iml_len_ip_header + iml_udp_pos_port))) {
     if (ADSL_CLCO->imc_len_dns_resp) {     /* length of DNS responses */
       goto p_check_dns_20;                 /* this is UDP DNS packet  */
     }
     goto p_rem_packet_00;                  /* remaining part of packet in gather */
   }
#endif
   if (!memcmp( chrs_port_dns,
                achl_out_ippa + iml_len_ip_header + iml_udp_pos_port,
                sizeof(unsigned short int) )) {
#ifdef B130607
     if (ADSL_CLCO->imc_len_dns_resp) {     /* length of DNS responses */
       goto p_check_dns_20;                 /* this is UDP DNS packet  */
     }
     goto p_rem_packet_00;                  /* remaining part of packet in gather */
#else
     goto p_check_dns_20;                   /* this is UDP DNS packet  */
#endif
   }
   if (*((unsigned short int *) chrs_port_sip)
         == *((unsigned short int *) (achl_out_ippa + iml_len_ip_header + 0))) {
     goto p_check_sip_20;                   /* this is UDP SIP packet  */
   }
   if (*((unsigned short int *) chrs_port_sip)
         != *((unsigned short int *) (achl_out_ippa + iml_len_ip_header + 2))) {
     goto p_rem_packet_00;                  /* remaining part of packet in gather */
   }

   p_check_sip_20:                          /* this is UDP SIP packet  */
#ifdef DEBUG_101207_01
   bos_debug_01 = FALSE;
   if (adsp_hl_clib_1->inc_func == DEF_IFUNC_FROMSERVER) {
     iml3 = adsl_gai1_inp_packet->achc_ginp_end - achl_packet;
     if (   (iml3 > 20)
         && (!memcmp( achl_packet, "INVITE ", 7))) {
       m_sdh_printf( &dsl_sdh_call_1, "xl-sdh-ppp-pf-05-l%05d-T FROMSERVER INVITE",
                     __LINE__ );
       bos_debug_01 = TRUE;
     }
   }
#endif
#ifndef HPPPT1_V21                          /* 18.01.13 KB HOB-PPP-T1 V2.1 */
   iml3 = iml_len_nhasn + 1 + (achl_out_end - achl_out_ippa);  /* overread this part */
#else
   iml3 = achl_out_end - achl_out_ippa;     /* overread this part      */
#endif

   p_check_sip_40:                          /* overread first part of packet */
#ifdef B110709
   while (adsl_gai1_inp_start->achc_ginp_cur >= adsl_gai1_inp_w1->achc_ginp_end) {  /* end of gather */
     adsl_gai1_inp_start = adsl_gai1_inp_start->adsc_next;  /* get next gather in chain */
     if (adsl_gai1_inp_start == NULL) goto p_illogic_00;  /* program illogic */
   }
   iml2 = adsl_gai1_inp_w1->achc_ginp_end - adsl_gai1_inp_start->achc_ginp_cur;
#else
   while (adsl_gai1_inp_start->achc_ginp_cur >= adsl_gai1_inp_start->achc_ginp_end) {  /* end of gather */
     adsl_gai1_inp_start = adsl_gai1_inp_start->adsc_next;  /* get next gather in chain */
     if (adsl_gai1_inp_start == NULL) goto p_illogic_00;  /* program illogic */
   }
   iml2 = adsl_gai1_inp_start->achc_ginp_end - adsl_gai1_inp_start->achc_ginp_cur;
#endif
   if (iml2 > iml3) iml2 = iml3;
   adsl_gai1_inp_start->achc_ginp_cur += iml2;
   iml3 -= iml2;
   if (iml3) goto p_check_sip_40;           /* overread first part of packet */

   while (adsl_gai1_inp_start->achc_ginp_cur >= adsl_gai1_inp_start->achc_ginp_end) {  /* end of gather */
     adsl_gai1_inp_start = adsl_gai1_inp_start->adsc_next;  /* get next gather in chain */
     if (adsl_gai1_inp_start == NULL) goto p_illogic_00;  /* program illogic */
   }
#ifndef HPPPT1_V21                          /* 18.01.13 KB HOB-PPP-T1 V2.1 */
   iml1 = iml_len_packet - 1 - (achl_out_end - achl_out_ippa);  /* length to copy */
#else
   iml1 = iml_len_packet - (achl_out_end - achl_out_ippa);  /* length to copy */
#endif
#ifdef B110709
   iml2 = adsl_gai1_inp_w1->achc_ginp_end - adsl_gai1_inp_start->achc_ginp_cur;
#else
   iml2 = adsl_gai1_inp_start->achc_ginp_end - adsl_gai1_inp_start->achc_ginp_cur;
#endif
   if (iml1 <= iml2) {                      /* SIP packet in one single chunk */
     achl_sip_packet = adsl_gai1_inp_start->achc_ginp_cur;  /* here starts SIP packet */
     adsl_gai1_inp_start->achc_ginp_cur += iml1;  /* data are processed */
     goto p_copy_00;                        /* copy the packet         */
   }

   /* we copy the SIP packet to the work area                          */
   if (iml1 > sizeof(chrl_work1)) {
     goto p_data_to_long;                   /* input data too long     */
   }

   achl1 = chrl_work1;                      /* copy packet here        */

   p_check_sip_60:                          /* copy part of the packet */
   while (adsl_gai1_inp_start->achc_ginp_cur >= adsl_gai1_inp_start->achc_ginp_end) {  /* end of gather */
     adsl_gai1_inp_start = adsl_gai1_inp_start->adsc_next;  /* get next gather in chain */
     if (adsl_gai1_inp_start == NULL) goto p_illogic_00;  /* program illogic */
   }
   iml2 = adsl_gai1_inp_start->achc_ginp_end - adsl_gai1_inp_start->achc_ginp_cur;
   if (iml2 > iml1) iml2 = iml1;
   memcpy( achl1, adsl_gai1_inp_start->achc_ginp_cur, iml2 );
   achl1 += iml2;
   adsl_gai1_inp_start->achc_ginp_cur += iml2;
   iml1 -= iml2;
   if (iml1) goto p_check_sip_60;           /* copy part of the packet */
   achl_sip_packet = chrl_work1;            /* here starts SIP packet  */
   goto p_copy_00;                          /* copy the packet         */

   p_check_dns_00:                          /* has to check DNS        */
   if (   (adsp_hl_clib_1->inc_func == DEF_IFUNC_TOSERVER)
       && (ADSL_CLCO->imc_len_dns_resp == 0)) {  /* length of DNS responses */
     goto p_rem_packet_00;                  /* remaining part of packet in gather */
   }
#ifdef B110822
   /* displacement zero in UDP header is source port                   */
   if (*((unsigned short int *) chrs_port_dns)
         != *((unsigned short int *) (achl_out_ippa + iml_len_ip_header + 0))) {
     goto p_rem_packet_00;                  /* remaining part of packet in gather */
   }
#endif
// 28.08.12 KB - alignment
   if (memcmp( chrs_port_dns,
               achl_out_ippa + iml_len_ip_header + iml_udp_pos_port,
               sizeof(unsigned short int) )) {
     goto p_rem_packet_00;                  /* remaining part of packet in gather */
   }

   p_check_dns_20:                          /* this is UDP DNS packet  */
#ifdef TRACEHL1
   m_sdh_printf( &dsl_sdh_call_1, "xl-sdh-ppp-pf-05-l%05d-T packet iml_len_nhasn=%d iml_len_packet=%d UDP DNS query found 1.",
                 __LINE__, iml_len_nhasn, iml_len_packet );
#endif
#ifdef TRACEHL_DNS
   m_sdh_printf( &dsl_sdh_call_1, "xl-sdh-ppp-pf-05-l%05d-T time=%lld packet iml_len_nhasn=%d iml_len_packet=%d UDP DNS query found 1.",
                 __LINE__, m_get_epoch_ms(), iml_len_nhasn, iml_len_packet );
   m_dump_gather( &dsl_sdh_call_1, adsl_gai1_inp_start, iml_len_nhasn + iml_len_packet );
#endif
   if (adsp_hl_clib_1->inc_func == DEF_IFUNC_FROMSERVER) {
     goto p_copy_00;                        /* copy the packet         */
   }
   /* check if DNS name as requested                                   */
#ifdef B101204
   if (iml_len_packet < (2 + iml_len_ip_header + D_LEN_UDP_HEADER
                           + 2 + sizeof(chrs_dns_query_1) + 2 + sizeof(chrs_dns_query_2))) {  /* packet too short */
     goto p_rem_packet_00;                  /* remaining part of packet in gather */
   }
#endif
#ifndef HPPPT1_V21                          /* 18.01.13 KB HOB-PPP-T1 V2.1 */
   if (iml_len_packet < (1 + iml_len_ip_header + D_LEN_UDP_HEADER
                           + 2 + sizeof(chrs_dns_query_1) + 2 + sizeof(chrs_dns_query_2))) {  /* packet too short */
     goto p_rem_packet_00;                  /* remaining part of packet in gather */
   }
#else
   if (iml_len_packet < (iml_len_ip_header + D_LEN_UDP_HEADER
                           + 2 + sizeof(chrs_dns_query_1) + 2 + sizeof(chrs_dns_query_2))) {  /* packet too short */
     goto p_rem_packet_00;                  /* remaining part of packet in gather */
   }
#endif
   iml1 = 2;                                /* we need two bytes       */

   p_name_dns_20:                           /* overread part before start of UDP packet after ID */
   while (achl_packet >= adsl_gai1_inp_packet->achc_ginp_end) {  /* end of gather */
     adsl_gai1_inp_packet = adsl_gai1_inp_packet->adsc_next;  /* get next gather in chain */
     if (adsl_gai1_inp_packet == NULL) goto p_illogic_00;  /* program illogic */
     achl_packet = adsl_gai1_inp_packet->achc_ginp_cur;  /* start in gather */
   }
   iml2 = adsl_gai1_inp_packet->achc_ginp_end - achl_packet;
   if (iml2 > iml1) iml2 = iml1;
   memcpy( chrl_work2 + 2 - iml1, achl_packet, iml2 );
   achl_packet += iml2;
   iml1 -= iml2;
   if (iml1) goto p_name_dns_20;            /* overread part before start of UDP packet after ID */
   /* copy part 1                                                      */
   iml1 = sizeof(chrs_dns_query_1);         /* copy part 1             */
   achl1 = chrl_work1;                      /* output area             */

   p_name_dns_40:                           /* copy DNS control fields */
   while (achl_packet >= adsl_gai1_inp_packet->achc_ginp_end) {  /* end of gather */
     adsl_gai1_inp_packet = adsl_gai1_inp_packet->adsc_next;  /* get next gather in chain */
     if (adsl_gai1_inp_packet == NULL) goto p_illogic_00;  /* program illogic */
     achl_packet = adsl_gai1_inp_packet->achc_ginp_cur;  /* start in gather */
   }
   iml2 = adsl_gai1_inp_packet->achc_ginp_end - achl_packet;
   if (iml2 > iml1) iml2 = iml1;
   memcpy( achl1, achl_packet, iml2 );
   achl_packet += iml2;
   achl1 += iml2;
   iml1 -= iml2;
   if (iml1) goto p_name_dns_40;            /* copy DNS control fields */
   if (memcmp( chrl_work1, chrs_dns_query_1, sizeof(chrs_dns_query_1) )) {
     goto p_rem_packet_00;                  /* remaining part of packet in gather */
   }
   /* get the DNS name                                                 */
   achl1 = achl2 = chrl_dns_name;           /* output DNS name         */

   p_name_dns_60:                           /* copy DNS name           */
   while (achl_packet >= adsl_gai1_inp_packet->achc_ginp_end) {  /* end of gather */
     adsl_gai1_inp_packet = adsl_gai1_inp_packet->adsc_next;  /* get next gather in chain */
     if (adsl_gai1_inp_packet == NULL) goto p_illogic_00;  /* program illogic */
     achl_packet = adsl_gai1_inp_packet->achc_ginp_cur;  /* start in gather */
   }
   if (achl1 >= (chrl_dns_name + sizeof(chrl_dns_name))) {
     m_sdh_printf( &dsl_sdh_call_1, "xl-sdh-ppp-pf-05-l%05d-W p_name_dns_60 DNS name too long", __LINE__ );
     goto p_rem_packet_00;                  /* remaining part of packet in gather */
   }
   *achl1 = *achl_packet++;                 /* get next byte           */
   if (achl1 < achl2) {                     /* not yet at end this part */
     achl1++;                               /* next output             */
     goto p_name_dns_60;                    /* copy DNS name           */
   }
   achl2 += 1 + (unsigned char) *achl1++;
   if (achl1 < achl2) {                     /* not yet at end this part */
     goto p_name_dns_60;                    /* copy DNS name           */
   }
   /* end of DNS name                                                  */
   iml_len_dns_n = achl1 - chrl_dns_name;   /* length DNS name         */
#ifdef B101204
   iml1 = iml_len_ip_header + 2 + sizeof(chrs_dns_query_1);  /* position in packet */
   if ((iml_len_packet - 2 - iml1) != sizeof(chrs_dns_query_2)) {
     goto p_rem_packet_00;                  /* remaining part of packet in gather */
   }
#endif
#ifdef XYZ1
   iml1 = iml_len_packet - 1 - iml_len_ip_header
            - D_LEN_UDP_HEADER
            - 2 - sizeof(chrs_dns_query_1)
            - iml_len_dns_n
            - sizeof(chrs_dns_query_2);
   m_sdh_printf( &dsl_sdh_call_1, "xl-sdh-ppp-pf-05-l%05d-T p_name_dns_60 iml1=%d.", __LINE__, iml1 );
#endif
#ifdef XYZ1
// 04.12.10 KB UUUU
   if (iml_len_packet > 0) {
     goto p_rem_packet_00;                  /* remaining part of packet in gather */
   }
#endif
#ifndef HPPPT1_V21                          /* 18.01.13 KB HOB-PPP-T1 V2.1 */
   if (iml_len_packet - 1 - iml_len_ip_header
        - D_LEN_UDP_HEADER
        - 2 - sizeof(chrs_dns_query_1)
        - iml_len_dns_n
        - sizeof(chrs_dns_query_2)) {
     goto p_rem_packet_00;                  /* remaining part of packet in gather */
   }
#else
   if (iml_len_packet - iml_len_ip_header
        - D_LEN_UDP_HEADER
        - 2 - sizeof(chrs_dns_query_1)
        - iml_len_dns_n
        - sizeof(chrs_dns_query_2)) {
     goto p_rem_packet_00;                  /* remaining part of packet in gather */
   }
#endif
   /* copy part 2 of DNS query                                         */
   iml1 = sizeof(chrs_dns_query_2);         /* copy part 2             */
   achl1 = chrl_work1;                      /* output area             */
#ifdef B101204
   iml_pos_packet += iml1;                  /* position in packet      */
#endif

   p_name_dns_80:                           /* copy DNS query last part */
   while (achl_packet >= adsl_gai1_inp_packet->achc_ginp_end) {  /* end of gather */
     adsl_gai1_inp_packet = adsl_gai1_inp_packet->adsc_next;  /* get next gather in chain */
     if (adsl_gai1_inp_packet == NULL) goto p_illogic_00;  /* program illogic */
     achl_packet = adsl_gai1_inp_packet->achc_ginp_cur;  /* start in gather */
   }
   iml2 = adsl_gai1_inp_packet->achc_ginp_end - achl_packet;
   if (iml2 > iml1) iml2 = iml1;
   memcpy( achl1, achl_packet, iml2 );
   achl_packet += iml2;
   achl1 += iml2;
   iml1 -= iml2;
   if (iml1) goto p_name_dns_80;            /* copy DNS query last part */
   if (memcmp( chrl_work1, chrs_dns_query_2, sizeof(chrs_dns_query_2) )) {
     goto p_rem_packet_00;                  /* remaining part of packet in gather */
   }
#ifndef B130607
   if (ADSL_CLCO->imc_len_dns_resp == 0) {  /* length of DNS responses */
     goto p_copy_00;                        /* check what to do with packet */
   }
#endif
#ifdef TRACEHL1
   m_sdh_printf( &dsl_sdh_call_1, "xl-sdh-ppp-pf-05-l%05d-T packet DNS query found iml_len_nhasn=%d iml_len_packet=%d iml_len_dns_n=%d.",
                 __LINE__, iml_len_nhasn, iml_len_packet, iml_len_dns_n );
#endif
#ifdef B130216
   achl1 = (char *) ADSL_CLCO + sizeof(struct dsd_clib1_conf);
   achl2 = achl1 + ADSL_CLCO->imc_len_dns_resp;  /* add length of DNS responses */
   do {                                     /* loop over all DNS responses */
#define ADSL_DNSR1_W1 ((struct dsd_dns_resp_1 *) achl1)
     if (   (iml_len_dns_n == ADSL_DNSR1_W1->imc_len_dns_n)
         && (!memcmp( chrl_dns_name, (char *) (ADSL_DNSR1_W1 + 1) + sizeof(chrs_dns_r_i_1), iml_len_dns_n ))) {
       goto p_found_dns_name;               /* DNS name found          */
     }
     achl1 += ADSL_DNSR1_W1->imc_len_stor;  /* add storage reserved    */
#undef ADSL_DNSR1_W1
   } while (achl1 < achl2);
   goto p_copy_00;                          /* check what to do with packet */
#endif
   adsl_dnsr1 = (struct dsd_dns_resp_1 *) ((char *) ADSL_CLCO + sizeof(struct dsd_clib1_conf));
   achl1 = (char *) adsl_dnsr1 + ADSL_CLCO->imc_len_dns_resp;  /* add length of DNS responses */
   do {                                     /* loop over all DNS responses */
     if (   (iml_len_dns_n == adsl_dnsr1->imc_len_dns_n)
         && (!memcmp( chrl_dns_name, (char *) (adsl_dnsr1 + 1) + sizeof(chrs_dns_r_i_1), iml_len_dns_n ))) {
       goto p_found_dns_name;               /* DNS name found          */
     }
     *((char **) &adsl_dnsr1) += adsl_dnsr1->imc_len_stor;  /* add storage reserved */
   } while (((char *) adsl_dnsr1) < achl1);
   goto p_copy_00;                          /* check what to do with packet */

   p_found_dns_name:                        /* DNS name found          */
#ifdef B130118
#ifdef TRACEHL_DNS
   m_sdh_printf( &dsl_sdh_call_1, "xl-sdh-ppp-pf-05-l%05d-T time=%lld p_found_dns_name: adsl_contr_1->imc_no_qdnsr1 = %d.",
                 __LINE__, m_get_epoch_ms(), adsl_contr_1->imc_no_qdnsr1 );
#endif
   if (adsl_contr_1->imc_no_qdnsr1 >= MAX_DNS_QUEUED) {
     adsp_hl_clib_1->boc_callrevdir = TRUE;  /* call on reverse direction */
#ifdef CHECK_OUTPUT_01
     m_check_output_01( adsp_hl_clib_1 );
#endif
     return;                                /* to be called again      */
   }
   adsl_qdnsr1_w1 = adsl_contr_1->dsrc_qdnsr1 + adsl_contr_1->imc_no_qdnsr1;
   adsl_qdnsr1_w1->adsc_dnsr1 = (struct dsd_dns_resp_1 *) achl1;  /* structure DNS response */
#endif

   /* ignore till end of the packet                                    */
#ifdef B101205
   iml1 = iml_len_packet - 1 - (iml_len_ip_header + D_LEN_UDP_HEADER + 2);
#endif
#ifndef HPPPT1_V21                          /* 18.01.13 KB HOB-PPP-T1 V2.1 */
   iml1 = iml_len_nhasn + iml_len_packet;   /* ignore full packet      */
#else
   iml1 = iml_len_packet;                   /* ignore full packet      */
#endif

   p_found_dn_40:                           /* ignore remaining part of packet */
   while (adsl_gai1_inp_start->achc_ginp_cur >= adsl_gai1_inp_start->achc_ginp_end) {  /* end of gather */
     adsl_gai1_inp_start = adsl_gai1_inp_start->adsc_next;  /* get next gather in chain */
     if (adsl_gai1_inp_start == NULL) goto p_illogic_00;  /* program illogic */
   }
   iml2 = adsl_gai1_inp_start->achc_ginp_end - adsl_gai1_inp_start->achc_ginp_cur;
   if (iml2 > iml1) iml2 = iml1;
#ifdef B130216
   achl1 += iml2;
#endif
   adsl_gai1_inp_start->achc_ginp_cur += iml2;
   iml1 -= iml2;
   if (iml1) goto p_found_dn_40;            /* ignore remaining part of packet */
#ifndef B130216
   achl_inp = adsl_gai1_inp_start->achc_ginp_cur;  /* start in gather  */
#endif

#ifdef B130118
   /* fill structure to send in reverse direction                      */
   adsl_qdnsr1_w1->umc_ineta_source = uml_ineta_dns;  /* INETA source  */
#ifdef XYZ1
   memcpy( &adsl_qdnsr1_w1->umc_ineta_dest,  /* INETA destination      */
           achl_out_ippa + 16,
           sizeof(UNSIG_MED) );
#endif
   memcpy( adsl_qdnsr1_w1->chrs_port_dest,  /* destination port        */
           achl_out_ippa + iml_len_ip_header + 0,
           sizeof(adsl_qdnsr1_w1->chrs_port_dest) );
   memcpy( adsl_qdnsr1_w1->chrs_id,         /* transaction ID          */
           chrl_work2,
           sizeof(adsl_qdnsr1_w1->chrs_id) );
   adsl_contr_1->imc_no_qdnsr1++;
#ifdef TRACEHL1
   m_sdh_printf( &dsl_sdh_call_1, "xl-sdh-ppp-pf-05-l%05d-T packet DNS query put to queue",
                 __LINE__ );
#endif
#ifdef TRACEHL_DNS
   m_sdh_printf( &dsl_sdh_call_1, "xl-sdh-ppp-pf-05-l%05d-T time=%lld packet DNS query put to queue",
                 __LINE__, m_get_epoch_ms() );
   m_sdh_console_out( &dsl_sdh_call_1, (char *) adsl_qdnsr1_w1, sizeof(struct dsd_query_dns_resp_1) );
#endif
#endif
#ifndef B130212
   memcpy( chrl_work3, achl_out_ippa + iml_len_ip_header + 0, sizeof(unsigned short int) );  /* save UDP source port */

   /* (sizeof(chrs_dns_r_s_3) + sizeof(UNSIG_MED)) are a multiple of sizeof(void *)
      so no problem with alignment                                     */
#ifdef XYZ1
   iml1 = iml2 = 0;                         /* no additional length    */
   if (adsl_dnsr1->iec_coe != ied_coe_socks_se) {  /* not Socks server */
     iml1 = adsl_dnsr1->imc_no_ineta;     /* get number of INETAs    */
   } else {                                 /* Socks5 server           */
     iml1 = 1;                              /* one INETA               */
   }
#endif
#ifdef XYZ1
   iml1 = adsl_dnsr1->imc_no_ineta;       /* get number of INETAs    */
   iml2 = 0;                                /* no additional length    */
   if (iml1 > 0) {                          /* with additional INETAs  */
     iml2 = sizeof(struct dsd_gather_i_1) + iml1 * (sizeof(chrs_dns_r_s_3) + sizeof(UNSIG_MED));
   }
   achl_work_2 -= 2 * sizeof(struct dsd_gather_i_1) + iml2;
#endif
#ifdef B130216
   achl_work_2 -= 2 * sizeof(struct dsd_gather_i_1);
#else
   achl_work_2 -= 3 * sizeof(struct dsd_gather_i_1) + sizeof(void *);
#endif
#ifndef HPPPT1_V21                          /* 18.01.13 KB HOB-PPP-T1 V2.1 */
   achl1 = achl_work_1 + MAX_LEN_NHASN;     /* start of packet         */
   achl_work_1 += MAX_LEN_NHASN + 1 + D_LEN_HEADER_IPV4 + D_LEN_UDP_HEADER + D_LEN_DNS_ID;
#endif
#ifdef HPPPT1_V21                           /* 18.01.13 KB HOB-PPP-T1 V2.1 */
   achl1 = achl_work_1;                     /* start of packet         */
   achl_work_1 += D_LEN_HEADER_IPV4 + D_LEN_UDP_HEADER + D_LEN_DNS_ID;
#endif
   if (achl_work_1 > achl_work_2) {         /* no space for output     */
     if (bol_output == FALSE) goto p_out_80;  /* overflow              */
     adsp_hl_clib_1->boc_callagain = TRUE;  /* call again this direction */
#ifdef CHECK_OUTPUT_01
     m_check_output_01( adsp_hl_clib_1 );
#endif
     return;                                /* to be called again      */
   }
#ifdef B130216
#define ADSL_GAI1_GS ((struct dsd_gather_i_1 *) achl_work_2)
#define ADSL_GAI1_G1 (((struct dsd_gather_i_1 *) achl_work_2) + 1)
#define AUML_INETA_G ((UNSIG_MED *) (ADSL_GAI1_G2 + 1))
   ADSL_GAI1_GS->adsc_next = ADSL_GAI1_G1;
   ADSL_GAI1_G1->achc_ginp_cur = (char *) (adsl_dnsr1 + 1);
   ADSL_GAI1_G1->achc_ginp_end = (char *) (adsl_dnsr1 + 1) + adsl_dnsr1->imc_len_entry;
   adsl_gai1_out_t1 = ADSL_GAI1_G1;         /* this is last gather     */
#ifdef XYZ1
   if (iml1 > 0) {                          /* with additional INETAs  */
     adsl_gai1_out_t1->adsc_next = adsl_gai1_out_t1 + 1;  /* append at end of last gather */
     adsl_gai1_out_t1++;                    /* additinal gather        */
     adsl_gai1_out_t1->achc_ginp_cur = achl2 = (char *) (adsl_gai1_out_t1 + 1);
     adsl_gai1_out_t1->achc_ginp_end
       = achl2 + iml1 * (sizeof(chrs_dns_r_s_3) + sizeof(UNSIG_MED));
     if (adsl_dnsr1->iec_coe != ied_coe_socks_se) {  /* not Socks server */
       iml2 = iml1;                         /* get number of INETAs    */
       achl3 = (char *) adsl_dnsr1 + adsl_dnsr1->imc_len_stor - iml1 * sizeof(UNSIG_MED);
       do {                                 /* loop over all INETAs    */
         memcpy( achl2, chrs_dns_r_s_3, sizeof(chrs_dns_r_s_3) );
         *((UNSIG_MED *) (achl2 + sizeof(chrs_dns_r_s_3)))
           = m_natted_ineta( adsp_hl_clib_1, achl3, NULL, ADSL_CLCO->boc_disp_inetas );
         achl2 += sizeof(chrs_dns_r_s_3) + sizeof(UNSIG_MED);
         achl3 += sizeof(UNSIG_MED);
         iml2--;                            /* decrement index         */
       } while (iml2 > 0);
     } else {
// to-do 21.08.11 KB INETA of Socks5 server
       memcpy( achl2, chrs_dns_r_s_3, sizeof(chrs_dns_r_s_3) );
       *((UNSIG_MED *) (achl2 + sizeof(chrs_dns_r_s_3))) = adsl_contr_1->umc_ineta_upper;
       m_ineta_op_add( achl2 + sizeof(chrs_dns_r_s_3),
                       sizeof(UNSIG_MED),
                       1 + adsl_dnsr1->imc_index_so_ineta_nat );  /* index of reserved INETAs for Socks servers */
     }
   }
#endif
   adsl_gai1_out_t1->adsc_next = NULL;      /* end of this sequence    */
#endif
#ifndef B130216
#define ADSL_GAI1_GS ((struct dsd_gather_i_1 *) achl_work_2)
#define ADSL_GAI1_G1 (((struct dsd_gather_i_1 *) achl_work_2) + 1)
#define ADSL_GAI1_G2 (ADSL_GAI1_G1 + 1)
#define AUML_INETA_G ((UNSIG_MED *) (ADSL_GAI1_G2 + 1))
   ADSL_GAI1_GS->adsc_next = ADSL_GAI1_G1;
   ADSL_GAI1_G1->adsc_next = ADSL_GAI1_G2;  /* add INETA in gather     */
   ADSL_GAI1_G1->achc_ginp_cur = (char *) (adsl_dnsr1 + 1);
   ADSL_GAI1_G1->achc_ginp_end = (char *) (adsl_dnsr1 + 1) + adsl_dnsr1->imc_len_entry - sizeof(UNSIG_MED);
// ADSL_GAI1_G2->adsc_next = adsl_gai1_out_2;  /* get chain before      */
   ADSL_GAI1_G2->adsc_next = NULL;          /* set end of chain        */
   ADSL_GAI1_G2->achc_ginp_cur = (char *) AUML_INETA_G;
   ADSL_GAI1_G2->achc_ginp_end = (char *) (AUML_INETA_G + 1);
   *AUML_INETA_G = m_natted_ineta( adsp_hl_clib_1,
                                   (char *) (adsl_dnsr1 + 1) + adsl_dnsr1->imc_len_entry - sizeof(UNSIG_MED) );
   adsl_gai1_out_t1 = ADSL_GAI1_G2;         /* this is last gather     */
#endif
   achl2 = achl1;
#ifndef HPPPT1_V21                          /* 18.01.13 KB HOB-PPP-T1 V2.1 */
   *achl2++ = '4';                          /* PPP IPV4 data           */
#endif
   *achl2++ = (unsigned char) 0X45;         /* IPV4 and length         */
   *achl2++ = 0;                            /* Type of Service         */
#ifdef XYZ1
   iml2 = D_LEN_HEADER_IPV4 + D_LEN_UDP_HEADER + D_LEN_DNS_ID + adsl_dnsr1->imc_len_entry
            + iml1 * (sizeof(chrs_dns_r_s_3) + sizeof(UNSIG_MED));
#endif
   iml2 = D_LEN_HEADER_IPV4 + D_LEN_UDP_HEADER + D_LEN_DNS_ID + adsl_dnsr1->imc_len_entry;
   *achl2++ = (unsigned char) (iml2 >> 8);  /* first part Total Length */
   *achl2++ = (unsigned char) iml2;         /* second part Total Length */
   *achl2++ = (unsigned char) 0X01;         /* first part Identification */
   *achl2++ = (unsigned char) 0X6A;         /* second part Identification */
   *achl2++ = 0;                            /* Flags + first part Fragment Offset */
   *achl2++ = 0;                            /* second part Fragment Offset */
   *achl2++ = (unsigned char) 0X80;         /* Time to live            */
   *achl2++ = (unsigned char) IPPROTO_UDP;  /* Protocol UDP            */
   *achl2++ = 0;                            /* first part Header checksum */
   *achl2++ = 0;                            /* second part Header checksum */
   memcpy( achl2, &uml_ineta_dns, sizeof(UNSIG_MED) );
   achl2 += sizeof(UNSIG_MED);
   memcpy( achl2, &adsl_contr_1->umc_ineta_client, sizeof(UNSIG_MED) );
   achl2 += sizeof(UNSIG_MED);
#ifdef TRACEHL_DNS
   m_sdh_printf( &dsl_sdh_call_1, "xl-sdh-ppp-pf-05-l%05d-T time=%lld send DNS response part one",
                 __LINE__, m_get_epoch_ms() );
   m_sdh_console_out( &dsl_sdh_call_1, achl1, achl2 - achl1 );
#endif
   /* calculate header checksum                                        */
#ifndef HPPPT1_V21                          /* 18.01.13 KB HOB-PPP-T1 V2.1 */
   achl3 = achl1 + 1;                       /* here is start IP header */
#else
   achl3 = achl1;                           /* here is start IP header */
#endif
   iml_chs = 0;                             /* calculate checksum      */
   do {                                     /* loop over IP header     */
     /* calculate checksum                                             */
     iml_chs += (*((unsigned char *) achl3 + 0) << 8)
                  | *((unsigned char *) achl3 + 1);
     achl3 += 2;                            /* next position in header */
   } while (achl3 < achl2);
   while ((iml_chs >> 16) != 0) {           /* continue carry          */
     iml_chs = (iml_chs & 0X0000FFFF) + (iml_chs >> 16);
   }
   iml_chs = ~iml_chs;                      /* negate result           */
#ifndef HPPPT1_V21                          /* 18.01.13 KB HOB-PPP-T1 V2.1 */
   *((unsigned char *) achl1 + 1 + D_POS_IPH_DCHS + 0) = (unsigned char) (iml_chs >> 8);
   *((unsigned char *) achl1 + 1 + D_POS_IPH_DCHS + 1) = (unsigned char) iml_chs;
#else
   *((unsigned char *) achl1 + D_POS_IPH_DCHS + 0) = (unsigned char) (iml_chs >> 8);
   *((unsigned char *) achl1 + D_POS_IPH_DCHS + 1) = (unsigned char) iml_chs;
#endif
   /* build UDP header                                                 */
   memcpy( achl2, chrs_port_dns, sizeof(chrs_port_dns) );
   achl2 += sizeof(chrs_port_dns);
#ifdef B11116
   memcpy( achl2, achl_out_ippa + iml_len_ip_header + 0, sizeof(unsigned short int) );
#else
   memcpy( achl2, chrl_work3, sizeof(unsigned short int) );  /* set UDP destination port */
#endif
   achl2 += sizeof(unsigned short int);
   iml2 = D_LEN_UDP_HEADER + D_LEN_DNS_ID + adsl_dnsr1->imc_len_entry
            + iml1 * (sizeof(chrs_dns_r_s_3) + sizeof(UNSIG_MED));
   *achl2++ = (unsigned char) (iml2 >> 8);  /* first part Length UDP packet */
   *achl2++ = (unsigned char) iml2;         /* second part Length UDP packet */
   *achl2++ = 0;                            /* first part checksum     */
   *achl2++ = 0;                            /* second part checksum    */
   memcpy( achl2, chrl_work2, D_LEN_DNS_ID );
   achl2 += D_LEN_DNS_ID;
   /* calculate UDP checksum                                           */
   iml_chs = 0;                             /* calculate checksum      */
   do {                                     /* loop over data          */
     /* calculate checksum                                             */
     iml_chs += (*((unsigned char *) achl3 + 0) << 8)
                  | *((unsigned char *) achl3 + 1);
     achl3 += 2;                            /* next position in data   */
   } while (achl3 < achl2);
#ifdef B130216
   /* checksum over constant part                                      */
   achl3 = (char *) (adsl_dnsr1 + 1);
   achl2 = achl3 + adsl_dnsr1->imc_len_entry - 1;
   do {                                     /* loop over data          */
     /* calculate checksum                                             */
     iml_chs += (*((unsigned char *) achl3 + 0) << 8)
                  | *((unsigned char *) achl3 + 1);
     achl3 += 2;                            /* next position in data   */
   } while (achl3 < achl2);
   if (adsl_dnsr1->imc_len_entry & 1) {   /* one byte remaining      */
     iml_chs += *((unsigned char *) achl3 + 0) << 8;
     if (iml1 > 0) {                        /* additional area with INETAs */
       achl2 = adsl_gai1_out_t1->achc_ginp_cur;
       achl3 = adsl_gai1_out_t1->achc_ginp_end;
       do {
         iml_chs += *((unsigned char *) achl2 + 0);
         iml_chs += *((unsigned char *) achl2 + 1) << 8;
         achl2 += 2;
       } while (achl2 < achl3);
     }
   } else {
     if (iml1 > 0) {                        /* additional area with INETAs */
       achl2 = adsl_gai1_out_t1->achc_ginp_cur;
       achl3 = adsl_gai1_out_t1->achc_ginp_end;
       do {
         iml_chs += *((unsigned char *) achl2 + 0) << 8;
         iml_chs += *((unsigned char *) achl2 + 1);
         achl2 += 2;
       } while (achl2 < achl3);
     }
   }
#endif
#ifndef B130216
   /* checksum over constant part                                      */
   achl3 = (char *) (adsl_dnsr1 + 1);
   achl2 = achl3 + adsl_dnsr1->imc_len_entry - sizeof(UNSIG_MED) - 1;
   do {                                     /* loop over data          */
     /* calculate checksum                                             */
     iml_chs += (*((unsigned char *) achl3 + 0) << 8)
                  | *((unsigned char *) achl3 + 1);
     achl3 += 2;                            /* next position in data   */
   } while (achl3 < achl2);
   if (adsl_dnsr1->imc_len_entry & 1) {     /* one byte remaining      */
     iml_chs += *((unsigned char *) achl3 + 0) << 8;
     iml_chs += *((unsigned char *) AUML_INETA_G + 0);
     iml_chs += *((unsigned char *) AUML_INETA_G + 1) << 8;
     iml_chs += *((unsigned char *) AUML_INETA_G + 2);
     iml_chs += *((unsigned char *) AUML_INETA_G + 3) << 8;
   } else {
     iml_chs += (*((unsigned char *) AUML_INETA_G + 0) << 8)
                  | *((unsigned char *) AUML_INETA_G + 1);
     iml_chs += (*((unsigned char *) AUML_INETA_G + 2) << 8)
                  | *((unsigned char *) AUML_INETA_G + 3);
   }
#endif
   /* fields in the IP header                                          */
#ifndef HPPPT1_V21                          /* 18.01.13 KB HOB-PPP-T1 V2.1 */
   achl2 = achl1 + 1 + 12;                  /* start source address    */
#else
   achl2 = achl1 + 12;                      /* start source address    */
#endif
   achl3 = achl2 + 4 + 4;                   /* after destination address */
   do {                                     /* loop over data          */
     /* calculate checksum                                             */
     iml_chs += (*((unsigned char *) achl2 + 0) << 8)
                  | *((unsigned char *) achl2 + 1);
     achl2 += 2;                            /* next position in data   */
   } while (achl2 < achl3);
   iml_chs += ((unsigned char) IPPROTO_UDP) + D_LEN_UDP_HEADER + D_LEN_DNS_ID + adsl_dnsr1->imc_len_entry
                + iml1 * (sizeof(chrs_dns_r_s_3) + sizeof(UNSIG_MED));
   while ((iml_chs >> 16) != 0) {           /* continue carry          */
     iml_chs = (iml_chs & 0X0000FFFF) + (iml_chs >> 16);
   }
   iml_chs = ~iml_chs;                      /* negate result           */
#ifndef HPPPT1_V21                          /* 18.01.13 KB HOB-PPP-T1 V2.1 */
   *((unsigned char *) achl1 + 1 + D_LEN_HEADER_IPV4 + 6 + 0) = (unsigned char) (iml_chs >> 8);
   *((unsigned char *) achl1 + 1 + D_LEN_HEADER_IPV4 + 6 + 1) = (unsigned char) iml_chs;
#else
   *((unsigned char *) achl1 + D_LEN_HEADER_IPV4 + 6 + 0) = (unsigned char) (iml_chs >> 8);
   *((unsigned char *) achl1 + D_LEN_HEADER_IPV4 + 6 + 1) = (unsigned char) iml_chs;
#endif
   /* packet has been prepared                                         */
#ifndef HPPPT1_V21                          /* 18.01.13 KB HOB-PPP-T1 V2.1 */
   iml1 = (achl_work_1 - achl1) + adsl_dnsr1->imc_len_entry  /* length of packet */
            + iml1 * (sizeof(chrs_dns_r_s_3) + sizeof(UNSIG_MED));
   iml2 = 0;                                /* clear more bit          */
   do {
     *(--achl1) = (unsigned char) ((iml1 & 0X7F) | iml2);
     iml1 >>= 7;                            /* remove bits             */
     iml2 = 0X80;                           /* set more bit            */
   } while (iml1 > 0);
#endif
   ADSL_GAI1_GS->achc_ginp_cur = achl1;
   ADSL_GAI1_GS->achc_ginp_end = achl_work_1;
#ifdef TRACEHL1
   iml1 = (achl_work_1 - achl1) + adsl_dnsr1->imc_len_entry;  /* length of packet */
   m_sdh_printf( &dsl_sdh_call_1, "xl-sdh-ppp-pf-05-l%05d-T DNS response packet len=%d.",
                 __LINE__, iml1 );
   m_dump_gather( &dsl_sdh_call_1, ADSL_GAI1_GS, iml1 );
#endif
#ifdef TRACEHL_DNS
   iml1 = (achl_work_1 - achl1) + adsl_dnsr1->imc_len_entry;  /* length of packet */
   m_sdh_printf( &dsl_sdh_call_1, "xl-sdh-ppp-pf-05-l%05d-T time=%lld DNS response packet len=%d.",
                 __LINE__, m_get_epoch_ms(), iml1 );
   m_dump_gather( &dsl_sdh_call_1, ADSL_GAI1_GS, iml1 );
#endif
   bol_output = TRUE;                       /* output has been done    */
   *aadsl_gai1_out_client = ADSL_GAI1_GS;
   aadsl_gai1_out_client = &adsl_gai1_out_t1->adsc_next;
   goto p_check_recv_00;                    /* check received packet   */

#undef ADSL_GAI1_GS
#undef ADSL_GAI1_G1
#ifndef B130216
#undef ADSL_GAI1_G2
#undef AUML_INETA_G
#endif
#endif
   goto p_check_recv_00;                    /* check received packet   */

   p_rem_packet_00:                         /* remaining part of packet in gather */
   adsl_gai1_out_t2 = adsl_gai1_out_t1;     /* this is output gather   */
   adsl_gai1_inp_w1 = adsl_gai1_inp_start;  /* here is first gather    */
   achl_packet = adsl_gai1_inp_w1->achc_ginp_cur;  /* here is current input */
#ifndef HPPPT1_V21                          /* 18.01.13 KB HOB-PPP-T1 V2.1 */
   iml1 = iml_len_nhasn + 1 + (achl_out_end - achl_out_ippa);  /* overread this part */
#endif
#ifdef HPPPT1_V21                           /* 18.01.13 KB HOB-PPP-T1 V2.1 */
   iml1 = achl_out_end - achl_out_ippa;     /* overread this part */
#endif

   p_rem_packet_20:                         /* overread first part of packet */
   while (achl_packet >= adsl_gai1_inp_w1->achc_ginp_end) {  /* end of gather */
     adsl_gai1_inp_w1 = adsl_gai1_inp_w1->adsc_next;  /* get next gather in chain */
     if (adsl_gai1_inp_w1 == NULL) goto p_illogic_00;  /* program illogic */
     achl_packet = adsl_gai1_inp_w1->achc_ginp_cur;  /* here is current input */
   }
   iml2 = adsl_gai1_inp_w1->achc_ginp_end - achl_packet;
   if (iml2 > iml1) iml2 = iml1;
   achl_packet += iml2;
   iml1 -= iml2;
   if (iml1) goto p_rem_packet_20;          /* overread first part of packet */

   /* the remaining parts of the record are put into gather structures for output */
#ifndef HPPPT1_V21                          /* 18.01.13 KB HOB-PPP-T1 V2.1 */
   iml1 = iml_len_packet - (1 + achl_out_end - achl_out_ippa);  /* length remaining part */
#endif
#ifdef HPPPT1_V21                           /* 18.01.13 KB HOB-PPP-T1 V2.1 */
   iml1 = iml_len_packet - (achl_out_end - achl_out_ippa);  /* length remaining part */
#endif
   if (iml1 <= 0) goto p_rem_packet_60;     /* all output has been done */

   p_rem_packet_40:                         /* put following parts of packet in gather output */
   adsl_gai1_out_t2--;                      /* gather before           */
   if (achl_out_end > ((char *) adsl_gai1_out_t2)) {  /* no space for output */
     if (bol_output == FALSE) goto p_out_80;  /* overflow              */
     adsp_hl_clib_1->boc_callagain = TRUE;  /* call again this direction */
#ifdef CHECK_OUTPUT_01
     m_check_output_01( adsp_hl_clib_1 );
#endif
     return;                                /* to be called again      */
   }
   (adsl_gai1_out_t2 + 1)->adsc_next = adsl_gai1_out_t2;  /* append gather output */
   while (achl_packet >= adsl_gai1_inp_w1->achc_ginp_end) {  /* end of gather */
     adsl_gai1_inp_w1 = adsl_gai1_inp_w1->adsc_next;  /* get next gather in chain */
     if (adsl_gai1_inp_w1 == NULL) goto p_illogic_00;  /* program illogic */
     achl_packet = adsl_gai1_inp_w1->achc_ginp_cur;  /* here is current input */
   }
   iml2 = adsl_gai1_inp_w1->achc_ginp_end - achl_packet;
   if (iml2 > iml1) iml2 = iml1;
   adsl_gai1_out_t2->achc_ginp_cur = achl_packet;  /* start of output this part */
   achl_packet += iml2;
   adsl_gai1_out_t2->achc_ginp_end = achl_packet;  /* end of output this part */
#ifdef DEBUG_101208_01
   iml_d2 = adsl_gai1_out_t2->achc_ginp_end - adsl_gai1_out_t2->achc_ginp_cur;
   iml_d1 = sprintf( achl_display, "l%05d gather=%p cur=%p end=%p len=%d/0X%p.",
                     __LINE__,
                     adsl_gai1_out_t2,
                     adsl_gai1_out_t2->achc_ginp_cur, adsl_gai1_out_t2->achc_ginp_end,
                     iml_d2, iml_d2 );
   achl_display += iml_d1;
   iml_d2 = D_LEN_LINE_M1 - iml_d1;
   if (iml_d2 > 0) {
     memset( achl_display, ' ', iml_d2 );
     achl_display += iml_d2;
   }
#endif
   iml1 -= iml2;
#ifdef B101208
   if (iml1) goto p_rem_packet_20;          /* overread first part of packet */
#else
   if (iml1) goto p_rem_packet_40;          /* put following parts of packet in gather output */
#endif

   p_rem_packet_60:                         /* all output has been done */
#ifndef HPPPT1_V21                          /* 18.01.13 KB HOB-PPP-T1 V2.1 */
   /* prepare HOB-PPP-T1 header                                        */
   achl1 = achl_out_ippa;                   /* here is IP packet       */
   *(--achl1) = '4';                        /* type IPV4               */
   iml1 = iml_len_packet;                   /* length of packet        */
   iml2 = 0;                                /* clear more bit          */
   do {
     *(--achl1) = (unsigned char) ((iml1 & 0X7F) | iml2);
     iml1 >>= 7;                            /* remove bits set         */
     iml2 = 0X80;                           /* set more bit            */
   } while (iml1 > 0);
   /* use gather structure prepared before                             */
   adsl_gai1_out_t1->achc_ginp_cur = achl1;
#endif
#ifdef DEBUG_101208_01
   iml_d1 = sprintf( achl_display, "l%05d gather=%p cur=%p end=%p.",
                     __LINE__, adsl_gai1_out_t1, adsl_gai1_out_t1->achc_ginp_cur, adsl_gai1_out_t1->achc_ginp_end );
   achl_display += iml_d1;
   iml_d2 = D_LEN_LINE_M1 - iml_d1;
   if (iml_d2 > 0) {
     memset( achl_display, ' ', iml_d2 );
     achl_display += iml_d2;
   }
#endif
   adsl_gai1_out_t2->adsc_next = NULL;      /* end of this part        */
   achl_work_1 = achl_out_end;              /* workarea used till here */
   achl_work_2 = (char *) adsl_gai1_out_t2;  /* new upper limit        */
   bol_output = TRUE;                       /* output has been done    */
#ifdef B130119
   if (adsl_gai1_out_2 == NULL) {
#ifndef NEW_WSP_1102
     adsp_hl_clib_1->adsc_gather_i_1_out = adsl_gai1_out_t1;
#else
     if (adsp_hl_clib_1->inc_func != DEF_IFUNC_TOSERVER) {  /* send to client */
       adsp_hl_clib_1->adsc_gai1_out_to_client = adsl_gai1_out_t1;  /* output data to client */
     } else {                               /* send to server          */
       adsp_hl_clib_1->adsc_gai1_out_to_server = adsl_gai1_out_t1;  /* output data to server */
     }
#endif
   } else {
     adsl_gai1_out_2->adsc_next = adsl_gai1_out_t1;
   }
   adsl_gai1_out_2 = adsl_gai1_out_t2;
#endif
#ifndef B130119
   *aadsl_gai1_out_normal = adsl_gai1_out_t1;  /* output data normal direction */
   aadsl_gai1_out_normal = &adsl_gai1_out_t2->adsc_next;  /* this is last output */
#endif
   /* remove the input data                                            */
#ifndef HPPPT1_V21                          /* 18.01.13 KB HOB-PPP-T1 V2.1 */
   iml1 = iml_len_nhasn + iml_len_packet;   /* length of data to be removed */
#endif
#ifdef HPPPT1_V21                           /* 18.01.13 KB HOB-PPP-T1 V2.1 */
   iml1 = iml_len_packet;                   /* length of data to be removed */
#endif
   do {                                     /* loop to remove the data */
     while (adsl_gai1_inp_start->achc_ginp_cur >= adsl_gai1_inp_start->achc_ginp_end) {  /* end of gather */
       adsl_gai1_inp_start = adsl_gai1_inp_start->adsc_next;  /* get next gather in chain */
       if (adsl_gai1_inp_start == NULL) goto p_illogic_00;  /* program illogic */
     }
     iml2 = adsl_gai1_inp_start->achc_ginp_end - adsl_gai1_inp_start->achc_ginp_cur;
     if (iml2 > iml1) iml2 = iml1;
     adsl_gai1_inp_start->achc_ginp_cur += iml2;
     iml1 -= iml2;
   } while (iml1 > 0);
   achl_inp = adsl_gai1_inp_start->achc_ginp_cur;  /* start input data */
   /* calculate checksum of IP-header                                  */
   /* clear old checksum                                               */
   *((unsigned char *) achl_out_ippa + D_POS_IPH_DCHS + 0) = 0;
   *((unsigned char *) achl_out_ippa + D_POS_IPH_DCHS + 1) = 0;
   achl1 = achl_out_ippa;                   /* start of IP header      */
   achl2 = achl1 + iml_len_ip_header;       /* end of IP header        */
   iml_chs = 0;                             /* calculate checksum      */
   do {                                     /* loop over IP header     */
     /* calculate checksum                                             */
     iml_chs += (*((unsigned char *) achl1 + 0) << 8)
                  | *((unsigned char *) achl1 + 1);
     achl1 += 2;                            /* next position in header */
   } while (achl1 < achl2);
   while ((iml_chs >> 16) != 0) {           /* continue carry          */
     iml_chs = (iml_chs & 0X0000FFFF) + (iml_chs >> 16);
   }
   iml_chs = ~iml_chs;                      /* negate result           */
   *((unsigned char *) achl_out_ippa + D_POS_IPH_DCHS + 0) = (unsigned char) (iml_chs >> 8);
   *((unsigned char *) achl_out_ippa + D_POS_IPH_DCHS + 1) = (unsigned char) iml_chs;
#ifdef XYZ1
   if ((*achl_out_ippa & 0XF0) == 0X40) {   /* IPV4                    */
     /* calculate checksum of IP-header                                */
     /* clear old checksum                                             */
     *((unsigned char *) achl_out_ippa + D_POS_IPH_DCHS + 0) = 0;
     *((unsigned char *) achl_out_ippa + D_POS_IPH_DCHS + 1) = 0;
     achl1 = achl_out_ippa;                 /* start of IP header      */
     achl2 = achl1 + iml_len_ip_header;     /* end of IP header        */
     iml_chs = 0;                           /* calculate checksum      */
     do {                                   /* loop over IP header     */
       /* calculate checksum                                             */
       iml_chs += (*((unsigned char *) achl1 + 0) << 8)
                    | *((unsigned char *) achl1 + 1);
       achl1 += 2;                          /* next position in header */
     } while (achl1 < achl2);
     while ((iml_chs >> 16) != 0) {         /* continue carry          */
       iml_chs = (iml_chs & 0X0000FFFF) + (iml_chs >> 16);
     }
     iml_chs = ~iml_chs;                    /* negate result           */
     *((unsigned char *) achl_out_ippa + D_POS_IPH_DCHS + 0) = (unsigned char) (iml_chs >> 8);
     *((unsigned char *) achl_out_ippa + D_POS_IPH_DCHS + 1) = (unsigned char) iml_chs;
   }
#endif
   /* check TCP or UDP header                                          */
#ifndef TRY_101205
   if (CHL_PROTOCOL == IPPROTO_TCP) {       /* protocol TCP from IP header */
     achl3 = achl_out_ippa + iml_len_ip_header + 16;
   } else if (CHL_PROTOCOL == IPPROTO_UDP) {  /* protocol UDP from IP header */
     achl3 = achl_out_ippa + iml_len_ip_header + 6;
   } else goto p_check_recv_00;             /* no new checksum needed  */
#else
   if (CHL_PROTOCOL == IPPROTO_TCP) {       /* protocol TCP from IP header */
     achl3 = achl_out_ippa + iml_len_ip_header + 16;
   } else if ((CHL_PROTOCOL & 0X0F) == (IPPROTO_UDP & 0X0F)) {  /* protocol UDP from IP header */
     achl3 = achl_out_ippa + iml_len_ip_header + 6;
   } else goto p_check_recv_00;             /* no new checksum needed  */
#endif
   /* clear old checksum                                               */
   *(achl3 + 0) = 0;
   *(achl3 + 1) = 0;
   iml_chs = 0;                             /* calculate checksum      */
   achl1 = achl_out_ippa + iml_len_ip_header;  /* start of TCP / UDP header */
   achl2 = achl_out_end;                    /* end of header           */
   do {                                     /* loop over header        */
     /* calculate checksum                                             */
     iml_chs += (*((unsigned char *) achl1 + 0) << 8)
                  | *((unsigned char *) achl1 + 1);
     achl1 += 2;                            /* next position in header */
   } while (achl1 < achl2);
   iml1 = 8;                                /* do shift bits           */
   adsl_gai1_inp_w1 = adsl_gai1_out_t1 - 1;  /* here is first part output */
   while (adsl_gai1_inp_w1 >= adsl_gai1_out_t2) {  /* loop over all gather output */
     achl1 = adsl_gai1_inp_w1->achc_ginp_cur;
     while (achl1 < adsl_gai1_inp_w1->achc_ginp_end) {
       iml_chs += *((unsigned char *) achl1) << iml1;
       iml1 ^= 8;
       achl1++;                             /* next character          */
     }
     adsl_gai1_inp_w1--;                    /* next gather before      */
   }
   /* fields in the IP header                                          */
   achl1 = achl_out_ippa + 12;              /* start source address    */
   achl2 = achl1 + 4 + 4;                   /* after destination address */
#ifdef XYZ1
   if ((*achl_out_ippa & 0XF0) == 0X60) {   /* IPV6                    */
     achl1 = achl_out_ippa + 8;             /* start source address    */
     achl2 = achl1 + 16 + 16;               /* after destination address */
   }
#endif
   do {                                     /* loop over data          */
     /* calculate checksum                                             */
     iml_chs += (*((unsigned char *) achl1 + 0) << 8)
                  | *((unsigned char *) achl1 + 1);
     achl1 += 2;                            /* next position in data   */
   } while (achl1 < achl2);
#ifndef HPPPT1_V21                          /* 18.01.13 KB HOB-PPP-T1 V2.1 */
   iml_chs += ((unsigned char) CHL_PROTOCOL) + iml_len_packet - (1 + iml_len_ip_header);
#endif
#ifdef HPPPT1_V21                           /* 18.01.13 KB HOB-PPP-T1 V2.1 */
   iml_chs += ((unsigned char) CHL_PROTOCOL) + iml_len_packet - iml_len_ip_header;
#endif
   while ((iml_chs >> 16) != 0) {           /* continue carry          */
     iml_chs = (iml_chs & 0X0000FFFF) + (iml_chs >> 16);
   }
   iml_chs = ~iml_chs;                      /* negate result           */
   *(achl3 + 0) = (unsigned char) (iml_chs >> 8);
   *(achl3 + 1) = (unsigned char) iml_chs;
   goto p_check_recv_00;                    /* all done                */

   p_copy_00:                               /* copy the packet         */
   /* the remaining parts of the record are put into the output area   */
#ifndef HPPPT1_V21                          /* 18.01.13 KB HOB-PPP-T1 V2.1 */
   iml1 = iml_len_packet - 1 - (achl_out_end - achl_out_ippa);  /* length to copy */
#else
   iml1 = iml_len_packet - (achl_out_end - achl_out_ippa);  /* length to copy */
#endif
   achl_work_1 = achl_out_end + iml1;       /* here is space for the packet */
   achl_work_2 = (char *) adsl_gai1_out_t1;
   iml2 = 0;                                /* nothing extra           */
   if (achl_sip_packet) {                   /* is SIP packet           */
     iml2 = D_EXT_SIP;                      /* something extra         */
   }
   if (achl_work_2 < (achl_work_1 + iml2)) {  /* work-area too small   */
     if (bol_output == FALSE) goto p_out_80;  /* overflow              */
     adsp_hl_clib_1->boc_callagain = TRUE;  /* call again this direction */
#ifdef CHECK_OUTPUT_01
     m_check_output_01( adsp_hl_clib_1 );
#endif
     return;                                /* to be called again      */
   }
   bol_output = TRUE;                       /* output has been done    */
   adsl_gai1_out_t1->adsc_next = NULL;
   adsl_gai1_out_t1->achc_ginp_end = achl_work_1;
#ifdef DEBUG_101208_01
   iml_d1 = sprintf( achl_display, "l%05d gather=%p cur=%p end=%p.",
                     __LINE__, adsl_gai1_out_t1, adsl_gai1_out_t1->achc_ginp_cur, adsl_gai1_out_t1->achc_ginp_end );
   achl_display += iml_d1;
   iml_d2 = D_LEN_LINE_M1 - iml_d1;
   if (iml_d2 > 0) {
     memset( achl_display, ' ', iml_d2 );
     achl_display += iml_d2;
   }
#endif
#ifdef B130119
   if (adsl_gai1_out_2 == NULL) {
#ifndef NEW_WSP_1102
     adsp_hl_clib_1->adsc_gather_i_1_out = adsl_gai1_out_t1;
#else
     if (adsp_hl_clib_1->inc_func != DEF_IFUNC_TOSERVER) {  /* send to client */
       adsp_hl_clib_1->adsc_gai1_out_to_client = adsl_gai1_out_t1;  /* output data to client */
     } else {                               /* send to server          */
       adsp_hl_clib_1->adsc_gai1_out_to_server = adsl_gai1_out_t1;  /* output data to server */
     }
#endif
   } else {
     adsl_gai1_out_2->adsc_next = adsl_gai1_out_t1;
   }
   adsl_gai1_out_2 = adsl_gai1_out_t1;
#endif
#ifndef B130119
   *aadsl_gai1_out_normal = adsl_gai1_out_t1;  /* output data normal direction */
   aadsl_gai1_out_normal = &adsl_gai1_out_t1->adsc_next;  /* this is last output */
#endif

   if (achl_sip_packet) goto p_copy_84;     /* is SIP packet           */

#ifndef HPPPT1_V21                          /* 18.01.13 KB HOB-PPP-T1 V2.1 */
   iml3 = iml_len_nhasn + 1 + (achl_out_end - achl_out_ippa);  /* overread this part */
#endif
#ifdef HPPPT1_V21                           /* 18.01.13 KB HOB-PPP-T1 V2.1 */
   iml3 = achl_out_end - achl_out_ippa;     /* overread this part      */
#endif

   p_copy_20:                               /* overread first part of packet */
#ifdef B110709
   while (adsl_gai1_inp_start->achc_ginp_cur >= adsl_gai1_inp_w1->achc_ginp_end) {  /* end of gather */
     adsl_gai1_inp_start = adsl_gai1_inp_start->adsc_next;  /* get next gather in chain */
     if (adsl_gai1_inp_start == NULL) goto p_illogic_00;  /* program illogic */
     achl_packet = adsl_gai1_inp_w1->achc_ginp_cur;  /* here is current input */
   }
   iml2 = adsl_gai1_inp_w1->achc_ginp_end - adsl_gai1_inp_start->achc_ginp_cur;
#else
   while (adsl_gai1_inp_start->achc_ginp_cur >= adsl_gai1_inp_start->achc_ginp_end) {  /* end of gather */
     adsl_gai1_inp_start = adsl_gai1_inp_start->adsc_next;  /* get next gather in chain */
     if (adsl_gai1_inp_start == NULL) goto p_illogic_00;  /* program illogic */
     achl_packet = adsl_gai1_inp_w1->achc_ginp_cur;  /* here is current input */
   }
   iml2 = adsl_gai1_inp_start->achc_ginp_end - adsl_gai1_inp_start->achc_ginp_cur;
#endif
   if (iml2 > iml3) iml2 = iml3;
   adsl_gai1_inp_start->achc_ginp_cur += iml2;
   iml3 -= iml2;
   if (iml3) goto p_copy_20;                /* overread first part of packet */

   p_copy_40:                               /* copy part of the packet */
   while (adsl_gai1_inp_start->achc_ginp_cur >= adsl_gai1_inp_start->achc_ginp_end) {  /* end of gather */
     adsl_gai1_inp_start = adsl_gai1_inp_start->adsc_next;  /* get next gather in chain */
     if (adsl_gai1_inp_start == NULL) goto p_illogic_00;  /* program illogic */
   }
   iml2 = adsl_gai1_inp_start->achc_ginp_end - adsl_gai1_inp_start->achc_ginp_cur;
   if (iml2 > iml1) iml2 = iml1;
   memcpy( achl_out_end, adsl_gai1_inp_start->achc_ginp_cur, iml2 );
   achl_out_end += iml2;
   adsl_gai1_inp_start->achc_ginp_cur += iml2;
   iml1 -= iml2;
   if (iml1) goto p_copy_40;                /* copy part of the packet */

   /* calculate checksum of IP-header                                  */
   /* clear old checksum                                               */
   *((unsigned char *) achl_out_ippa + D_POS_IPH_DCHS + 0) = 0;
   *((unsigned char *) achl_out_ippa + D_POS_IPH_DCHS + 1) = 0;
   achl1 = achl_out_ippa;                   /* start of IP header      */
   achl2 = achl1 + iml_len_ip_header;       /* end of IP header        */
   iml_chs = 0;                             /* calculate checksum      */
   do {                                     /* loop over IP header     */
     /* calculate checksum                                             */
     iml_chs += (*((unsigned char *) achl1 + 0) << 8)
                  | *((unsigned char *) achl1 + 1);
     achl1 += 2;                            /* next position in header */
   } while (achl1 < achl2);
   while ((iml_chs >> 16) != 0) {           /* continue carry          */
     iml_chs = (iml_chs & 0X0000FFFF) + (iml_chs >> 16);
   }
   iml_chs = ~iml_chs;                      /* negate result           */
   *((unsigned char *) achl_out_ippa + D_POS_IPH_DCHS + 0) = (unsigned char) (iml_chs >> 8);
   *((unsigned char *) achl_out_ippa + D_POS_IPH_DCHS + 1) = (unsigned char) iml_chs;
   if (adsp_hl_clib_1->inc_func == DEF_IFUNC_TOSERVER) {
     goto p_copy_80;                        /* end of packet change    */
   }
#ifndef TRY_101205
   if (CHL_PROTOCOL != IPPROTO_UDP) {       /* protocol from IP header */
     goto p_copy_80;                        /* end of packet change    */
   }
#else
   if ((CHL_PROTOCOL & 0X0F) != (IPPROTO_UDP & 0X0F)) {       /* protocol from IP header */
     goto p_copy_80;                        /* end of packet change    */
   }
#endif
   if (memcmp( achl_out_ippa + iml_len_ip_header + 0, chrs_port_dns, 2 )) {
     goto p_copy_80;                        /* end of packet change    */
   }
#ifdef TRACEHL1
   m_sdh_printf( &dsl_sdh_call_1, "xl-sdh-ppp-pf-05-l%05d-T packet iml_len_nhasn=%d iml_len_packet=%d UDP DNS query found 2.",
                 __LINE__, iml_len_nhasn, iml_len_packet );
#endif
   /* check if response                                                */
   if ((*(achl_out_ippa + iml_len_ip_header + D_LEN_UDP_HEADER + 2) & 0X80) == 0) {
     goto p_copy_80;                        /* end of packet change    */
   }
   /* check RCODE                                                      */
   if ((*(achl_out_ippa + iml_len_ip_header + D_LEN_UDP_HEADER + 2 + 1) & 0X0F) != 0) {
     goto p_copy_80;                        /* end of packet change    */
   }
   /* get QDCOUNT                                                      */
   iml1 = (*((unsigned char *) achl_out_ippa + iml_len_ip_header + D_LEN_UDP_HEADER + 4 + 0) << 8)
            | *((unsigned char *) achl_out_ippa + iml_len_ip_header + D_LEN_UDP_HEADER + 4 + 1);
   /* get ANCOUNT                                                      */
   iml2 = (*((unsigned char *) achl_out_ippa + iml_len_ip_header + D_LEN_UDP_HEADER + 6 + 0) << 8)
            | *((unsigned char *) achl_out_ippa + iml_len_ip_header + D_LEN_UDP_HEADER + 6 + 1);
#ifdef TRACEHL1
   m_sdh_printf( &dsl_sdh_call_1, "xl-sdh-ppp-pf-05-l%05d-T packet UDP DNS query found 3 iml1=%d iml2=%d.",
                 __LINE__, iml1, iml2 );
#endif
   achl1 = achl_out_ippa + iml_len_ip_header + D_LEN_UDP_HEADER + 12;  /* here starts question section */
   while (iml1 > 0) {                       /* loop over all questions */
     while (TRUE) {                         /* loop over elements of name */
       if (achl1 > achl_work_1) goto p_copy_80;  /* after end of record */
       iml3 = *((unsigned char *) achl1);
       if (iml3 >= 64) {                    /* compression used        */
         achl1 += 2;                        /* after compression index */
         break;                             /* all done                */
       }
       achl1 += 1 + iml3;
       if (iml3 == 0) break;
     }
     achl1 += 4;                            /* ignore QTYPE and QCLASS */
     iml1--;                                /* this question has been processed */
   }
#ifdef TRACEHL1
   m_sdh_printf( &dsl_sdh_call_1, "xl-sdh-ppp-pf-05-l%05d-T DNS query iml2=%d achl_packet=%p achl1=%p.",
                 __LINE__, iml2, achl_packet, achl1 );
#endif
   while (iml2 > 0) {                       /* loop over all resource records */
     while (TRUE) {                         /* loop over elements of name */
       if (achl1 > achl_work_1) goto p_copy_80;  /* after end of record */
       iml3 = *((unsigned char *) achl1);
       if (iml3 >= 64) {                    /* compression used        */
         achl1 += 2;                        /* after compression index */
         break;                             /* all done                */
       }
       achl1 += 1 + iml3;
       if (iml3 == 0) break;
     }
     iml_type = (*((unsigned char *) achl1 + 0 + 0) << 8)
                  | *((unsigned char *) achl1 + 0 + 1);
     iml_class = (*((unsigned char *) achl1 + 2 + 0) << 8)
                  | *((unsigned char *) achl1 + 2 + 1);
     iml3 = (*((unsigned char *) achl1 + 8 + 0) << 8)
              | *((unsigned char *) achl1 + 8 + 1);
     achl2 = achl1 + 10;
     achl1 += 10 + iml3;                    /* after this RR           */
     if (achl1 > achl_work_1) goto p_copy_80;  /* after end of record  */
#ifdef TRACEHL1
     m_sdh_printf( &dsl_sdh_call_1, "xl-sdh-ppp-pf-05-l%05d-T DNS query iml2=%d achl_packet=%p achl1=%p iml_type=%d iml_class=%d iml3=%d.",
                   __LINE__, iml2, achl_packet, achl1, iml_type,iml_class, iml3 );
#endif
     if (    (iml_type == 1)                /* A 1 a host address      */
          && (iml_class == 1)               /* IN 1 the Internet       */
          && (iml3 == 4)) {                 /* length INETA IPV4       */
       /* attention alignment                                          */
//     memcpy( &uml_ineta_w1, achl2, sizeof(UNSIG_MED) );
//     uml_ineta_w1 = m_natted_ineta( adsp_hl_clib_1, (char *) &uml_ineta_w1 );
       uml_ineta_w1 = m_natted_ineta( adsp_hl_clib_1, achl2 );
       memcpy( achl2, &uml_ineta_w1, sizeof(UNSIG_MED) );
     }
     iml2--;                                /* this resource record has been processed */
   }

   p_copy_80:                               /* end of packet change    */
#ifdef HPPPT1_V21                           /* 18.01.13 KB HOB-PPP-T1 V2.1 */
   achl_inp = adsl_gai1_inp_start->achc_ginp_cur;  /* start input data */
#endif
   if (achl_sip_packet == NULL) {           /* not SIP packet          */
     goto p_copy_92;                        /* prepare HOB-PPP-T1 header */
   }

   p_copy_84:                               /* is SIP packet           */
   /* apply ALG SIP                                                    */
   achl1 = achl_sip_packet;                 /* start input to copy     */
#ifndef HPPPT1_V21                          /* 18.01.13 KB HOB-PPP-T1 V2.1 */
   achl2 = achl_sip_packet + iml_len_packet - 1 - (achl_out_end - achl_out_ippa);  /* end input to copy */
#else
   achl2 = achl_sip_packet + iml_len_packet - (achl_out_end - achl_out_ippa);  /* end input to copy */
#endif
   achl3 = achl_out_end;                    /* start output of copy    */
   achl4 = achl_sip_packet;                 /* copied so far           */
   iml2 = 0;                                /* state CR LF             */
   achl5 = NULL;                            /* CR LF CR LF not found   */

   p_alg_sip_20:                            /* search invalid characters */
#ifdef B101022
   while ((achl1 < achl2) && (ucrs_tab_char_sip[ (unsigned char) *achl1 ] != 3)) achl1++;
#endif
   while (achl1 < achl2) {
     switch ((unsigned char) *achl1) {
       case CHAR_CR:
         if ((iml2 & 1) == 0) {
           iml2++;                          /* next state              */
           break;
         }
         iml2 = 1;                          /* CR found                */
         break;
       case CHAR_LF:
         if ((iml2 & 1) == 0) {             /* not CR before           */
           iml2 = 0;                        /* state CR LF             */
           break;
         }
         iml2++;                            /* next state              */
         if (iml2 < 4) break;               /* not CR LF CR LF         */
         achl5 = achl1 - 3;                 /* CR LF CR LF found       */
         achl5 += achl3 - achl4;            /* pointer to output area  */
#ifdef DEBUG_101207_01
         if (bos_debug_01) {
           m_sdh_printf( &dsl_sdh_call_1, "xl-sdh-ppp-pf-05-l%05d-T CR LF CR LF achl5=%p.",
                         __LINE__, achl5 );
         }
#endif
         break;
       default:
         iml2 = 0;                          /* state CR LF             */
         break;
     }
     if (ucrs_tab_char_sip[ (unsigned char) *achl1 ] == 3) break;
     achl1++;                               /* next character          */
   }
   if (achl1 >= achl2) goto p_alg_sip_60;   /* copy last part          */
   achl1++;                                 /* after separator         */
   if (ucrs_tab_char_sip[ (unsigned char) *achl1 ] != 1) goto p_alg_sip_20;  /* search invalid characters */
   iml1 = achl1 - achl4;                    /* get length input        */
   if ((achl3 + iml1) > achl_work_2) goto p_illogic_00;  /* program illogic */
   memcpy( achl3, achl4, iml1 );            /* copy content            */
   achl3 += iml1;                           /* this is end packet      */
   achl4 = achl1;                           /* save start string       */
   while ((achl1 < achl2) && (ucrs_tab_char_sip[ (unsigned char) *achl1 ] <= 2)) achl1++;
   if ((achl1 < achl2) && (ucrs_tab_char_sip[ (unsigned char) *achl1 ] != 3)) {
     goto p_alg_sip_20;                     /* search invalid characters */
   }
   iml1 = m_get_ineta_a( &uml_ineta_w1, achl4, achl1 );
   if (iml1) goto p_alg_sip_20;             /* was not valid INETA     */
   if (adsp_hl_clib_1->inc_func == DEF_IFUNC_TOSERVER) {
     uml_ineta_w1 = m_original_ineta( adsp_hl_clib_1, (char *) &uml_ineta_w1 );
   } else {
     uml_ineta_w1 = m_natted_ineta( adsp_hl_clib_1, (char *) &uml_ineta_w1 );
   }
#ifdef B110701
   if ((achl3 + 15) > achl_work_2) goto p_illogic_00;  /* program illogic */
#else
   if ((achl3 + 15 + 1) > achl_work_2) goto p_illogic_00;  /* program illogic */
#endif
   achl3 += sprintf( achl3, "%d.%d.%d.%d",
              *((unsigned char *) &uml_ineta_w1 + 0),
              *((unsigned char *) &uml_ineta_w1 + 1),
              *((unsigned char *) &uml_ineta_w1 + 2),
              *((unsigned char *) &uml_ineta_w1 + 3) );
   achl4 = achl1;                           /* input processed so far  */
   goto p_alg_sip_20;                       /* continue searching      */

   p_alg_sip_60:                            /* copy last part          */
   iml1 = achl1 - achl4;                    /* get length input        */
   if (iml1 > 0) {                          /* something to copy       */
     if ((achl3 + iml1) > achl_work_2) goto p_illogic_00;  /* program illogic */
     memcpy( achl3, achl4, iml1 );          /* copy content            */
     achl3 += iml1;                         /* this is end packet      */
   }
   /* set length of packet                                             */
   while (   (achl5)
          && ((achl5 + 4) != achl3)) {
#ifdef DEBUG_101207_01
     if (bos_debug_01) {
       m_sdh_printf( &dsl_sdh_call_1, "xl-sdh-ppp-pf-05-l%05d-T set length of packet achl3=%p achl5=%p.",
                     __LINE__, achl3, achl5 );
     }
#endif
     achl1 = achl5;                         /* end of CR LF CR LF      */
     while ((achl1 > achl_out_end) && (*(achl1 - 1) != 0X20)) achl1--;
     if (achl1 <= achl_out_end) {
       m_sdh_printf( &dsl_sdh_call_1, "xl-sdh-ppp-pf-05-l%05d-W SIP NAT packet-length error 01",
                     __LINE__ );
       break;
     }
     if ((achl1 - 1 - sizeof(ucrs_sip_cont_len)) <= achl_out_end) {
       m_sdh_printf( &dsl_sdh_call_1, "xl-sdh-ppp-pf-05-l%05d-W SIP NAT packet-length error 02",
                     __LINE__ );
       break;
     }
     if (memcmp( (achl1 - 1 - sizeof(ucrs_sip_cont_len)),
                 ucrs_sip_cont_len,
                 sizeof(ucrs_sip_cont_len) )) {
       m_sdh_printf( &dsl_sdh_call_1, "xl-sdh-ppp-pf-05-l%05d-W SIP NAT packet-length error 03",
                     __LINE__ );
       break;
     }
     /* compute length of length in ASCII                              */
#ifdef B101207
     iml2 = iml3 = achl3 - achl5;           /* length of last part     */
#else
     iml2 = iml3 = achl3 - (achl5 + 4);     /* length of last part     */
#endif
#ifdef DEBUG_101207_01
     if (bos_debug_01) {
       m_sdh_printf( &dsl_sdh_call_1, "xl-sdh-ppp-pf-05-l%05d-T new length iml2=%d/%p packet-end=achl3=%p.",
                     __LINE__, iml2, iml2, achl3 );
     }
#endif
     iml4 = 0;
     do {
       iml4++;                              /* count the digit         */
       iml2 /= 10;                          /* divide number           */
     } while (iml2 > 0);
     iml2 = iml4 - (achl5 - achl1);         /* compute difference in number of digits */
     if (iml2) {                            /* different number of ASCII digits */
       memmove( (achl5 + 4) + iml2,
                achl5 + 4,
                achl3 - (achl5 - 4) );
       achl3 += iml2;                       /* new end of packet       */
       achl5 += iml2;                       /* new end of ASCII number */
     }
     do {
       *(--achl5) = (iml3 % 10) + '0';      /* output one digit        */
       iml3 /= 10;                          /* divide number           */
     } while (iml3 > 0);
     break;
   }
#ifndef HPPPT1_V21                          /* 18.01.13 KB HOB-PPP-T1 V2.1 */
   iml_len_packet = iml1 = achl3 - achl_out_ippa + 1;  /* length of packet */
   /* set length in the IP header                                      */
   iml2 = iml_len_packet - 1;
   achl1 = achl_out_ippa + 2;               /* here is length          */
   *(achl1 + 0) = (unsigned char) (iml2 >> 8);  /* first byte length big endian */
   *(achl1 + 1) = (unsigned char) iml2;     /* second byte length big endian */
#endif
#ifdef HPPPT1_V21                           /* 18.01.13 KB HOB-PPP-T1 V2.1 */
   iml_len_packet = iml1 = achl3 - achl_out_ippa;  /* length of packet */
   /* set length in the IP header                                      */
   achl1 = achl_out_ippa + 2;               /* here is length          */
   *(achl1 + 0) = (unsigned char) (iml_len_packet >> 8);  /* first byte length big endian */
   *(achl1 + 1) = (unsigned char) iml_len_packet;  /* second byte length big endian */
#endif
   /* calculate checksum of IP-header                                  */
   /* clear old checksum                                               */
   *((unsigned char *) achl_out_ippa + D_POS_IPH_DCHS + 0) = 0;
   *((unsigned char *) achl_out_ippa + D_POS_IPH_DCHS + 1) = 0;
   achl1 = achl_out_ippa;                   /* start of IP header      */
   achl2 = achl1 + iml_len_ip_header;       /* end of IP header        */
   iml_chs = 0;                             /* calculate checksum      */
   do {                                     /* loop over IP header     */
     /* calculate checksum                                           */
     iml_chs += (*((unsigned char *) achl1 + 0) << 8)
                  | *((unsigned char *) achl1 + 1);
     achl1 += 2;                            /* next position in header */
   } while (achl1 < achl2);
   while ((iml_chs >> 16) != 0) {           /* continue carry          */
     iml_chs = (iml_chs & 0X0000FFFF) + (iml_chs >> 16);
   }
   iml_chs = ~iml_chs;                      /* negate result           */
   *((unsigned char *) achl_out_ippa + D_POS_IPH_DCHS + 0) = (unsigned char) (iml_chs >> 8);
   *((unsigned char *) achl_out_ippa + D_POS_IPH_DCHS + 1) = (unsigned char) iml_chs;
   /* set length in the UDP header                                     */
#ifndef HPPPT1_V21                          /* 18.01.13 KB HOB-PPP-T1 V2.1 */
   iml2 = iml_len_packet - (1 + iml_len_ip_header);
#endif
#ifdef HPPPT1_V21                           /* 18.01.13 KB HOB-PPP-T1 V2.1 */
   iml2 = iml_len_packet - iml_len_ip_header;
#endif
   achl1 = achl_out_ippa + iml_len_ip_header + 4;  /* here is length   */
   *(achl1 + 0) = (unsigned char) (iml2 >> 8);  /* first byte length big endian */
   *(achl1 + 1) = (unsigned char) iml2;     /* second byte length big endian */
   adsl_gai1_out_t1->achc_ginp_end = achl_work_1 = achl3;

   p_copy_92:                               /* prepare HOB-PPP-T1 header */
#ifndef HPPPT1_V21                          /* 18.01.13 KB HOB-PPP-T1 V2.1 */
   achl1 = achl_out_ippa;                   /* start of IP packet      */
   *(--achl1) = '4';                        /* type IPV4               */
   iml1 = iml_len_packet;                   /* length of packet        */
   /* output length NHASN                                              */
   iml2 = 0;                                /* clear more bit          */
   do {
     *(--achl1) = (unsigned char) ((iml1 & 0X7F) | iml2);
     iml1 >>= 7;                            /* remove bits set         */
     iml2 = 0X80;                           /* set more bit            */
   } while (iml1 > 0);
   /* use gather structure prepared before                             */
   adsl_gai1_out_t1->achc_ginp_cur = achl1;
#endif
#ifdef HPPPT1_V21                           /* 18.01.13 KB HOB-PPP-T1 V2.1 */
   /* use gather structure prepared before                             */
   adsl_gai1_out_t1->achc_ginp_cur = achl_out_ippa;
#endif

#ifndef TRY_101205
   if (CHL_PROTOCOL == IPPROTO_TCP) {       /* protocol TCP from IP header */
     achl3 = achl_out_ippa + iml_len_ip_header + 16;
   } else if (CHL_PROTOCOL == IPPROTO_UDP) {  /* protocol UDP from IP header */
     achl3 = achl_out_ippa + iml_len_ip_header + 6;
   } else goto p_check_recv_00;             /* no new checksum needed  */
#else
   if (CHL_PROTOCOL == IPPROTO_TCP) {       /* protocol TCP from IP header */
     achl3 = achl_out_ippa + iml_len_ip_header + 16;
   } else if ((CHL_PROTOCOL & 0X0F) == (IPPROTO_UDP & 0X0F)) {  /* protocol UDP from IP header */
     achl3 = achl_out_ippa + iml_len_ip_header + 6;
   } else goto p_check_recv_00;             /* no new checksum needed  */
#endif
   achl1 = achl_out_ippa + iml_len_ip_header;  /* start of header and data */
// achl2 = achl_out_ippa + ((iml_len_packet - 1) & (-2));  /* end of data, even */
#ifdef B101204
   achl2 = achl_out_ippa + iml_len_packet - 1;  /* end of data, even or odd */
#endif
#ifndef HPPPT1_V21                          /* 18.01.13 KB HOB-PPP-T1 V2.1 */
   achl2 = achl_out_ippa + iml_len_packet - 2;  /* end of data, even or odd */
#else
   achl2 = achl_out_ippa + iml_len_packet - 1;  /* end of data, even or odd */
#endif
   if ((achl3 + 2) > achl2) goto p_check_recv_00;  /* packet is too short */
   /* clear old checksum                                               */
   *((unsigned char *) achl3 + 0) = 0;
   *((unsigned char *) achl3 + 1) = 0;
   iml_chs = 0;                             /* calculate checksum      */
   do {                                     /* loop over data          */
     /* calculate checksum                                             */
     iml_chs += (*((unsigned char *) achl1 + 0) << 8)
                  | *((unsigned char *) achl1 + 1);
     achl1 += 2;                            /* next position in data   */
   } while (achl1 < achl2);
   if (achl1 < achl_work_1) {               /* one byte remaining      */
     iml_chs += *((unsigned char *) achl1 + 0) << 8;
   }
   /* fields in the IP header                                          */
   achl1 = achl_out_ippa + 12;              /* start source address    */
   achl2 = achl1 + 4 + 4;                   /* after destination address */
   do {                                     /* loop over data          */
     /* calculate checksum                                             */
     iml_chs += (*((unsigned char *) achl1 + 0) << 8)
                  | *((unsigned char *) achl1 + 1);
     achl1 += 2;                            /* next position in data   */
   } while (achl1 < achl2);
#ifndef HPPPT1_V21                          /* 18.01.13 KB HOB-PPP-T1 V2.1 */
   iml_chs += ((unsigned char) CHL_PROTOCOL) + iml_len_packet - (1 + iml_len_ip_header);
#endif
#ifdef HPPPT1_V21                           /* 18.01.13 KB HOB-PPP-T1 V2.1 */
   iml_chs += ((unsigned char) CHL_PROTOCOL) + iml_len_packet - iml_len_ip_header;
#endif
   while ((iml_chs >> 16) != 0) {           /* continue carry          */
     iml_chs = (iml_chs & 0X0000FFFF) + (iml_chs >> 16);
   }
   iml_chs = ~iml_chs;                      /* negate result           */
   *((unsigned char *) achl3 + 0) = (unsigned char) (iml_chs >> 8);
   *((unsigned char *) achl3 + 1) = (unsigned char) iml_chs;
   goto p_check_recv_00;                    /* check received packet   */

   p_ipcp_00:                               /* process IPCP            */
   achl_packet++;                           /* increment input         */
   while (achl_packet >= adsl_gai1_inp_packet->achc_ginp_end) {  /* end of gather */
     adsl_gai1_inp_packet = adsl_gai1_inp_packet->adsc_next;  /* get next gather in chain */
     if (adsl_gai1_inp_packet == NULL) goto p_illogic_00;  /* program illogic */
     achl_packet = adsl_gai1_inp_packet->achc_ginp_cur;  /* start in gather */
   }
   if (((unsigned char) *achl_packet) != ucrs_ctrl_ipcp[1]) {
     goto p_out_00;                         /* output unchanged        */
   }
   /* copy the complete packet to the work-area                        */
   achl1 = achl_work_1;                     /* output here             */
#ifndef HPPPT1_V21                          /* 18.01.13 KB HOB-PPP-T1 V2.1 */
   achl_packet = achl_work_1 + iml_len_nhasn;  /* here comes packet    */
   iml1 = iml_len_nhasn + iml_len_packet;   /* length to copy          */
#endif
#ifdef HPPPT1_V21                           /* 18.01.13 KB HOB-PPP-T1 V2.1 */
   achl_packet = achl_work_1 + 1 + iml_len_nhasn;  /* here comes packet */
   iml1 = 1 + iml_len_nhasn + iml_len_packet;  /* length to copy       */
#endif
   achl_work_1 += iml1;                     /* here is space for the packet */
   achl_work_2 -= sizeof(struct dsd_gather_i_1);
   if (achl_work_2 < achl_work_1) {         /* work-area too small     */
     if (bol_output == FALSE) goto p_out_80;  /* overflow              */
     adsp_hl_clib_1->boc_callagain = TRUE;  /* call again this direction */
#ifdef CHECK_OUTPUT_01
     m_check_output_01( adsp_hl_clib_1 );
#endif
     return;                                /* to be called again      */
   }
   bol_output = TRUE;                       /* output has been done    */
   adsl_gai1_out_1 = (struct dsd_gather_i_1 *) achl_work_2;
   adsl_gai1_out_1->adsc_next = NULL;
   adsl_gai1_out_1->achc_ginp_cur = achl1;
   adsl_gai1_out_1->achc_ginp_end = achl_work_1;
#ifdef DEBUG_101208_01
   iml_d1 = sprintf( achl_display, "l%05d gather=%p cur=%p end=%p.",
                     __LINE__, adsl_gai1_out_1, adsl_gai1_out_1->achc_ginp_cur, adsl_gai1_out_1->achc_ginp_end );
   achl_display += iml_d1;
   iml_d2 = D_LEN_LINE_M1 - iml_d1;
   if (iml_d2 > 0) {
     memset( achl_display, ' ', iml_d2 );
     achl_display += iml_d2;
   }
#endif
#ifdef B130119
   if (adsl_gai1_out_2 == NULL) {
#ifndef NEW_WSP_1102
     adsp_hl_clib_1->adsc_gather_i_1_out = adsl_gai1_out_1;
#else
     if (adsp_hl_clib_1->inc_func != DEF_IFUNC_TOSERVER) {  /* send to client */
       adsp_hl_clib_1->adsc_gai1_out_to_client = adsl_gai1_out_1;  /* output data to client */
     } else {                               /* send to server          */
       adsp_hl_clib_1->adsc_gai1_out_to_server = adsl_gai1_out_1;  /* output data to server */
     }
#endif
   } else {
     adsl_gai1_out_2->adsc_next = adsl_gai1_out_1;
   }
   adsl_gai1_out_2 = adsl_gai1_out_1;
#endif
#ifndef B130119
   *aadsl_gai1_out_normal = adsl_gai1_out_1;  /* output data normal direction */
   aadsl_gai1_out_normal = &adsl_gai1_out_1->adsc_next;  /* this is last output */
#endif

   p_ipcp_20:                               /* copy part of the packet */
   while (adsl_gai1_inp_start->achc_ginp_cur >= adsl_gai1_inp_start->achc_ginp_end) {  /* end of gather */
     adsl_gai1_inp_start = adsl_gai1_inp_start->adsc_next;  /* get next gather in chain */
     if (adsl_gai1_inp_start == NULL) goto p_illogic_00;  /* program illogic */
   }
   iml2 = adsl_gai1_inp_start->achc_ginp_end - adsl_gai1_inp_start->achc_ginp_cur;
   if (iml2 > iml1) iml2 = iml1;
   memcpy( achl1, adsl_gai1_inp_start->achc_ginp_cur, iml2 );
   achl1 += iml2;
   adsl_gai1_inp_start->achc_ginp_cur += iml2;
   iml1 -= iml2;
   if (iml1) goto p_ipcp_20;                /* copy part of the packet */
   if (iml_len_packet < (2 + 4)) {
     m_sdh_printf( &dsl_sdh_call_1, "xl-sdh-ppp-pf-05-l%05d-W PPP IPCP packet too short",
                   __LINE__ );
     goto p_check_recv_00;                  /* check received packet   */
   }
#ifndef HPPPT1_V21                          /* 18.01.13 KB HOB-PPP-T1 V2.1 */
   iml1 = (*((unsigned char *) achl_packet + 1 + 2 + 2 + 0) << 8)
            | *((unsigned char *) achl_packet + 1 + 2 + 2 + 1);
   achl1 = achl_packet + 1 + 2 + iml1;
#endif
#ifdef HPPPT1_V21                           /* 18.01.13 KB HOB-PPP-T1 V2.1 */
   iml1 = (*((unsigned char *) achl_packet + 2 + 2 + 0) << 8)
            | *((unsigned char *) achl_packet + 2 + 2 + 1);
   achl1 = achl_packet + 2 + iml1;
#endif
   if (achl1 > (achl_packet + iml_len_packet)) {
     m_sdh_printf( &dsl_sdh_call_1, "xl-sdh-ppp-pf-05-l%05d-W PPP IPCP packet length invalid",
                   __LINE__ );
     goto p_check_recv_00;                  /* check received packet   */
   }
#ifndef HPPPT1_V21                          /* 18.01.13 KB HOB-PPP-T1 V2.1 */
   if (   (*(achl_packet + 1 + 2 + 0) < 1)
       || (*(achl_packet + 1 + 2 + 0) > 4)) {
     m_sdh_printf( &dsl_sdh_call_1, "xl-sdh-ppp-pf-05-l%05d-W PPP IPCP packet code 0X%02X invalid",
                   __LINE__, (unsigned char) *(achl_packet + 2 + 0) );
     goto p_check_recv_00;                  /* check received packet   */
   }
   iml2 = 0;
   if (*(achl_packet + 1 + 2 + 0) != 1) iml2 = 1;
   if (adsp_hl_clib_1->inc_func == DEF_IFUNC_TOSERVER) {
     iml2 ^= 1;                             /* invert function         */
   }
   achl2 = achl_packet + 1 + 2 + 4;         /* start scanning          */
#endif
#ifdef HPPPT1_V21                           /* 18.01.13 KB HOB-PPP-T1 V2.1 */
   if (   (*(achl_packet + 2 + 0) < 1)
       || (*(achl_packet + 2 + 0) > 4)) {
     m_sdh_printf( &dsl_sdh_call_1, "xl-sdh-ppp-pf-05-l%05d-W PPP IPCP packet code 0X%02X invalid",
                   __LINE__, (unsigned char) *(achl_packet + 2 + 0) );
     goto p_check_recv_00;                  /* check received packet   */
   }
   iml2 = 0;
   if (*(achl_packet + 2 + 0) != 1) iml2 = 1;
   if (adsp_hl_clib_1->inc_func == DEF_IFUNC_TOSERVER) {
     iml2 ^= 1;                             /* invert function         */
   }
   achl2 = achl_packet + 2 + 4;             /* start scanning          */
#endif

   p_ipcp_40:                               /* scan option IPCP        */
   if (achl2 == achl1) goto p_check_recv_00;  /* check received packet */
   if ((achl2 + 2) > achl1) {
     m_sdh_printf( &dsl_sdh_call_1, "xl-sdh-ppp-pf-05-l%05d-W PPP IPCP packet no space for option",
                   __LINE__ );
     goto p_check_recv_00;                  /* check received packet   */
   }
   iml1 = (unsigned char) *(achl2 + 1);     /* get length option       */
   if (iml1 < 2) {                          /* length option too short */
     m_sdh_printf( &dsl_sdh_call_1, "xl-sdh-ppp-pf-05-l%05d-W PPP IPCP packet length option %d too short",
                   __LINE__, iml1 );
     goto p_check_recv_00;                  /* check received packet   */
   }
   achl3 = achl2;                           /* save this position      */
   achl2 += iml1;                           /* after this option       */
   if (achl2 > achl1) {
     m_sdh_printf( &dsl_sdh_call_1, "xl-sdh-ppp-pf-05-l%05d-W PPP IPCP packet option too long",
                   __LINE__ );
     goto p_check_recv_00;                  /* check received packet   */
   }
   iml3 = iml2;                             /* is client INETA         */
   while (TRUE) {                           /* pseudo-loop             */
     if (*achl3 == 3) break;
     if (   (((unsigned char) *achl3) >= 0X81)
         && (((unsigned char) *achl3) <= 0X84)) {
       iml3 ^= 1;                           /* is not client INETA     */
       break;
     }
     goto p_ipcp_40;                        /* this option IPCP unchanged */
   }
   if (iml1 != (2 + sizeof(UNSIG_MED))) {
     m_sdh_printf( &dsl_sdh_call_1, "xl-sdh-ppp-pf-05-l%05d-W PPP IPCP packet length option %d for INETA invalid",
                   __LINE__, iml1 );
     goto p_check_recv_00;                  /* check received packet   */
   }
   memcpy( &uml_ineta_w1, achl3 + 2, sizeof(UNSIG_MED) );
   if (uml_ineta_w1 == 0) goto p_ipcp_40;   /* this option IPCP unchanged */
   if (iml3) {                              /* INETA client in tunnel  */
     if (adsp_hl_clib_1->inc_func == DEF_IFUNC_TOSERVER) {
       memcpy( achl3 + 2, &adsl_contr_1->umc_ineta_cl_int, sizeof(UNSIG_MED) );
     } else {
       adsl_contr_1->umc_ineta_cl_int = uml_ineta_w1;  /* INETA client intern in intranet */
       memcpy( achl3 + 2, &adsl_contr_1->umc_ineta_client, sizeof(UNSIG_MED) );
     }
   } else {
     if (adsp_hl_clib_1->inc_func == DEF_IFUNC_TOSERVER) {
       uml_ineta_w1 = m_original_ineta( adsp_hl_clib_1, achl3 + 2 );
     } else {
       uml_ineta_w1 = m_natted_ineta( adsp_hl_clib_1, achl3 + 2 );
     }
     memcpy( achl3 + 2, &uml_ineta_w1, sizeof(UNSIG_MED) );
   }
#ifdef TRACEHL1
   m_sdh_printf( &dsl_sdh_call_1, "xl-sdh-ppp-pf-05-l%05d-T PPP IPCP packet INETA replaced",
                 __LINE__ );
#endif
   goto p_ipcp_40;                          /* scan option IPCP        */

   p_contr_00:                              /* control packet found    */
#ifndef HPPPT1_V21                          /* 18.01.13 KB HOB-PPP-T1 V2.1 */
   achl_packet++;                           /* after control character '0' */
#endif
   achl1 = achl_packet;                     /* here starts control packet */
#ifndef HPPPT1_V21                          /* 18.01.13 KB HOB-PPP-T1 V2.1 */
   iml_len_packet--;                        /* remaining length        */
#endif
   achl2 = achl_packet + iml_len_packet;    /* end of control packet   */
   if (achl2 <= adsl_gai1_inp_packet->achc_ginp_end) {  /* end of gather */
     achl_packet = achl2;                   /* set end of packet       */
     goto p_contr_20;                       /* packet is in one chunk  */
   }
   achl1 = achl2 = chrl_work1;              /* copy to work area       */
   if (iml_len_packet > sizeof(chrl_work1)) iml_len_packet = sizeof(chrl_work1);
   iml1 = iml_len_packet;                   /* length to copy          */

   p_contr_04:                              /* copy one part of the packet */
   while (achl_packet >= adsl_gai1_inp_packet->achc_ginp_end) {  /* end of gather */
     adsl_gai1_inp_packet = adsl_gai1_inp_packet->adsc_next;  /* get next gather in chain */
     if (adsl_gai1_inp_packet == NULL) goto p_illogic_00;  /* program illogic */
     achl_packet = adsl_gai1_inp_packet->achc_ginp_cur;  /* start in gather */
   }
   iml2 = adsl_gai1_inp_packet->achc_ginp_end - achl_packet;  /* length this chunk */
   if (iml2 > iml1) iml2 = iml1;            /* so much to copy         */
   memcpy( achl2, achl_packet, iml2 );
   achl2 += iml2;
   achl_packet += iml2;
   iml1 -= iml2;
   if (iml1) goto p_contr_04;               /* more to copy            */

   p_contr_20:                              /* packet is in one chunk  */
   if (adsp_hl_clib_1->inc_func != DEF_IFUNC_TOSERVER) goto p_se_contr_00;  /* received control from server */
   achl3 = achl1 + sizeof(ucrs_recv_contr_01);
   if (!memcmp( achl1, ucrs_recv_contr_01, sizeof(ucrs_recv_contr_01) )) {
     adsl_contr_1->umc_ineta_lower          /* natted INETAs lower entry */
       = ADSL_CLCO->umc_conf_ineta_1_lower;  /* configured INETAs 1 lower value */
     adsl_contr_1->umc_ineta_upper          /* natted INETAs upper entry */
       = ADSL_CLCO->umc_conf_ineta_1_upper;  /* configured INETAs 1 upper value */
     adsl_contr_1->umc_ineta_mask           /* natted INETAs network mask */
       = ADSL_CLCO->umc_conf_ineta_1_mask;  /* configured INETAs 1 network mask */
     goto p_contr_24;                       /* command is valid        */
   }
   if (memcmp( achl1, ucrs_recv_contr_02, sizeof(ucrs_recv_contr_02) )) {
     goto p_out_00;                         /* other command found     */
   }
#ifdef NOT_YET_101031
   achl3 = achl1 + sizeof(ucrs_recv_contr_02);
#else
   m_sdh_printf( &dsl_sdh_call_1, "xl-sdh-ppp-pf-05-l%05d-E RECONNECT not supported by this Server-Data-Hook - end session",
                 __LINE__ );
   goto p_end_tunnel_00;                    /* end the tunnel          */
#endif

   p_contr_24:                              /* command is valid        */
   if (achl3 >= achl2) goto p_out_00;       /* end of command found    */
   if (*achl3 != ' ') goto p_out_00;        /* not separated by blank  */

   p_contr_28:                              /* search next keyword     */
   while ((achl3 < achl2) && (*achl3 == ' ')) achl3++;  /* overread spaces */
   if (achl3 >= achl2) goto p_out_00;       /* end of command found    */
#ifdef B110317
   achl4 = (char *) memchr( achl3, ' ', achl2 - achl4 );
#else
   achl4 = (char *) memchr( achl3, ' ', achl2 - achl3 );
#endif
   if (achl4 == NULL) achl4 = achl2;        /* end of control packet   */
   if (memcmp( achl3, ucrs_recv_locineta, sizeof(ucrs_recv_locineta) )) {
     achl3 = achl4;                         /* after this keyword      */
     goto p_contr_28;                       /* search next keyword     */
   }
   achl3 += sizeof(ucrs_recv_locineta);
   iml1 = m_get_ineta_a( &uml_ineta_w1, achl3, achl4 );
   if (iml1) {
     m_sdh_printf( &dsl_sdh_call_1, "xl-sdh-ppp-pf-05-l%05d-W LOCAL-INETA=\"%.*s\" invalid",
                   __LINE__, achl4 - achl3, achl3 );
     goto p_out_00;                         /* end of command          */
   }
   if (   (memcmp( &uml_ineta_w1, &ADSL_CLCO->umc_conf_ineta_1_lower, sizeof(UNSIG_MED) ) >= 0)  /* configured INETAs 1 lower value */
       && (memcmp( &uml_ineta_w1, &ADSL_CLCO->umc_conf_ineta_1_upper, sizeof(UNSIG_MED) ) <= 0)) {  /* configured INETAs 1 upper value */
     adsl_contr_1->umc_ineta_lower          /* natted INETAs lower entry */
       = ADSL_CLCO->umc_conf_ineta_2_lower;  /* configured INETAs 2 lower value */
     adsl_contr_1->umc_ineta_upper          /* natted INETAs upper entry */
       = ADSL_CLCO->umc_conf_ineta_2_upper;  /* configured INETAs 2 upper value */
     adsl_contr_1->umc_ineta_mask           /* natted INETAs network mask */
       = ADSL_CLCO->umc_conf_ineta_2_mask;  /* configured INETAs 2 network mask */
   }
   adsl_contr_1->umc_ineta_client = adsl_contr_1->umc_ineta_lower;  /* INETA client in tunnel */
   m_ineta_op_inc( (char *) &adsl_contr_1->umc_ineta_client, sizeof(UNSIG_MED) );  /* increment */
   goto p_out_00;                           /* output data unchanged   */

   p_se_contr_00:                           /* received control from server */
   if (   (iml_len_packet <= 15)
       || (memcmp( achl1, "RESPONSE-START ", 15 ))) {
     goto p_out_00;                         /* copy command unchanged  */
   }
   achl2 = achl1 + 15;                      /* scan from here          */
   achl_end = achl1 + iml_len_packet;       /* end of packet           */
   achl5 = NULL;                            /* tunnel-id not found     */
   while (TRUE) {                           /* loop over keywords      */
     while ((achl2 < achl_end) && (*achl2 == ' ')) achl2++;
     if (achl2 >= achl_end) break;
     achl3 = (char *) memchr( achl2, ' ', achl_end - achl2 );
     if (achl3 == NULL) achl3 = achl_end;   /* no space found          */
     achl4 = (char *) memchr( achl2, '=', achl3 - achl2 );
     if (achl4 == NULL) {                   /* no equals found         */
       m_sdh_printf( &dsl_sdh_call_1, "xl-sdh-ppp-pf-05-l%05d-W received keyword without \'=\' in RESPONSE-START packet \"%.*s\".",
                     __LINE__, iml_len_packet, achl1 );
       achl2 = achl3;                       /* set end of keyword      */
       continue;                            /* ignore this keyword     */
     }
     iml3 = achl4 - achl2;                  /* get length of string    */
     if (iml3 <= 0) {
       m_sdh_printf( &dsl_sdh_call_1, "xl-sdh-ppp-pf-05-l%05d-W received keyword length zero before \'=\' in RESPONSE-START packet \"%.*s\".",
                     __LINE__, iml_len_packet, achl1 );
       achl2 = achl3;                       /* set end of keyword      */
       continue;                            /* ignore this keyword     */
     }
     if (   (iml3 != 9)
         || (memcmp( achl2, "TUNNEL-ID", 9 ))) {
       achl2 = achl3;                       /* set end of keyword      */
       continue;                            /* ignore this keyword     */
     }
     achl4++;                               /* after equals            */
     iml4 = achl3 - achl4;                  /* length of value         */
     if (iml4 <= 0) {                       /* value too short         */
       m_sdh_printf( &dsl_sdh_call_1, "xl-sdh-ppp-pf-05-l%05d-W received value too short with keyword \"%.*s\" in RESPONSE-START packet \"%.*s\".",
                     __LINE__, iml3, achl2, iml_len_packet, achl1 );
       achl2 = achl3;                       /* set end of keyword      */
       continue;                            /* ignore this keyword     */
     }
     if (achl5) {                           /* tunnel-id already set   */
       m_sdh_printf( &dsl_sdh_call_1, "xl-sdh-ppp-pf-05-l%05d-W received TUNNEL-ID= twice in RESPONSE-START packet \"%.*s\".",
                     __LINE__, iml_len_packet, achl1 );
       achl2 = achl3;                       /* set end of keyword      */
       continue;                            /* ignore this keyword     */
     }
     iml2 = iml4;                           /* set length tunnel-id    */
     achl5 = achl4;                         /* save address tunnel-id  */
     achl2 = achl3;                         /* set end of keyword      */
   }
   if (achl5 == NULL) {                     /* tunnel-id not found     */
     m_sdh_printf( &dsl_sdh_call_1, "xl-sdh-ppp-pf-05-l%05d-W did not received TUNNEL-ID= in RESPONSE-START packet \"%.*s\".",
                   __LINE__, iml_len_packet, achl1 );
     goto p_out_00;                         /* copy command unchanged  */
   }
   achl_work_2 -= sizeof(struct dsd_gather_i_1);
   if ((achl_work_1 + D_LEN_RESP_START + iml2) > achl_work_2) {  /* no space for output */
     if (bol_output == FALSE) goto p_out_80;  /* overflow              */
     adsp_hl_clib_1->boc_callagain = TRUE;  /* call again this direction */
#ifdef CHECK_OUTPUT_01
     m_check_output_01( adsp_hl_clib_1 );
#endif
     return;                                /* to be called again      */
   }
#define ADSL_GAI1_G ((struct dsd_gather_i_1 *) achl_work_2)
   ADSL_GAI1_G->adsc_next = NULL;           /* set last in chain       */
   bol_output = TRUE;                       /* output has been done    */
#ifdef B130119
   if (adsl_gai1_out_2 == NULL) {
#ifndef NEW_WSP_1102
     adsp_hl_clib_1->adsc_gather_i_1_out = ADSL_GAI1_G;
#else
     if (adsp_hl_clib_1->inc_func != DEF_IFUNC_TOSERVER) {  /* send to client */
       adsp_hl_clib_1->adsc_gai1_out_to_client = ADSL_GAI1_G;  /* output data to client */
     } else {                               /* send to server          */
       adsp_hl_clib_1->adsc_gai1_out_to_server = ADSL_GAI1_G;  /* output data to server */
     }
#endif
   } else {
     adsl_gai1_out_2->adsc_next = ADSL_GAI1_G;
   }
   adsl_gai1_out_2 = ADSL_GAI1_G;           /* this is last output     */
#endif
#ifndef B130119
   *aadsl_gai1_out_normal = ADSL_GAI1_G;    /* output data normal direction */
   aadsl_gai1_out_normal = &ADSL_GAI1_G->adsc_next;  /* this is last output */
#endif
#ifndef HPPPT1_V21                          /* 18.01.13 KB HOB-PPP-T1 V2.1 */
   achl_work_1 += 2;                        /* leave space for length  */
   iml1 = sprintf( achl_work_1, "0RESPONSE-START TUNNEL-ID=%.*s \
SERVER-NETWORK-INETA=%d.%d.%d.%d \
SERVER-NETWORK-MASK=%d.%d.%d.%d",
                   iml2, achl5,
                   *((unsigned char *) &adsl_contr_1->umc_ineta_lower + 0 ),
                   *((unsigned char *) &adsl_contr_1->umc_ineta_lower + 1 ),
                   *((unsigned char *) &adsl_contr_1->umc_ineta_lower + 2 ),
                   *((unsigned char *) &adsl_contr_1->umc_ineta_lower + 3 ),
                   *((unsigned char *) &adsl_contr_1->umc_ineta_mask + 0 ),
                   *((unsigned char *) &adsl_contr_1->umc_ineta_mask + 1 ),
                   *((unsigned char *) &adsl_contr_1->umc_ineta_mask + 2 ),
                   *((unsigned char *) &adsl_contr_1->umc_ineta_mask + 3 ) );
   achl1 = achl_work_1;                     /* get position output     */
   achl_work_1 += iml1;                     /* after output            */
   if (iml1 < 0X80) {
     *(--achl1) = (unsigned char) iml1;
   } else {
     *(--achl1) = (unsigned char) (iml1 & 0X7F);
     *(--achl1) = (unsigned char) ((iml1 >> 7) | 0X80);
   }
#endif
#ifdef HPPPT1_V21                           /* 18.01.13 KB HOB-PPP-T1 V2.1 */
   achl_work_1 += 1 + 2;                    /* leave space for tag and length */
   iml1 = sprintf( achl_work_1, "RESPONSE-START TUNNEL-ID=%.*s \
SERVER-NETWORK-INETA=%d.%d.%d.%d \
SERVER-NETWORK-MASK=%d.%d.%d.%d",
                   iml2, achl5,
                   *((unsigned char *) &adsl_contr_1->umc_ineta_lower + 0 ),
                   *((unsigned char *) &adsl_contr_1->umc_ineta_lower + 1 ),
                   *((unsigned char *) &adsl_contr_1->umc_ineta_lower + 2 ),
                   *((unsigned char *) &adsl_contr_1->umc_ineta_lower + 3 ),
                   *((unsigned char *) &adsl_contr_1->umc_ineta_mask + 0 ),
                   *((unsigned char *) &adsl_contr_1->umc_ineta_mask + 1 ),
                   *((unsigned char *) &adsl_contr_1->umc_ineta_mask + 2 ),
                   *((unsigned char *) &adsl_contr_1->umc_ineta_mask + 3 ) );
   achl1 = achl_work_1;                     /* get position output     */
   achl_work_1 += iml1;                     /* after output            */
   if (iml1 < 0X80) {
     *(--achl1) = (unsigned char) iml1;
   } else {
     *(--achl1) = (unsigned char) (iml1 & 0X7F);
     *(--achl1) = (unsigned char) ((iml1 >> 7) | 0X80);
   }
   *(--achl1) = (unsigned char) '0';        /* tag                     */
#endif
   ADSL_GAI1_G->achc_ginp_cur = achl1;
   ADSL_GAI1_G->achc_ginp_end = achl_work_1;
#undef ADSL_GAI1_G
   /* remove the received packet                                       */
   while (adsl_gai1_inp_start != adsl_gai1_inp_packet) {
     adsl_gai1_inp_start->achc_ginp_cur = adsl_gai1_inp_start->achc_ginp_end;
     adsl_gai1_inp_start = adsl_gai1_inp_start->adsc_next;
     if (adsl_gai1_inp_start == NULL) goto p_illogic_00;  /* program illogic */
   }
   adsl_gai1_inp_start->achc_ginp_cur = achl_packet;  /* processed so far */
   goto p_check_recv_00;                    /* check received packet   */

   p_out_00:                                /* output data unchanged   */
   /* check if enough space in output area                             */
   iml1 = sizeof(struct dsd_gather_i_1);
   adsl_gai1_inp_w2 = adsl_gai1_inp_start;  /* start from first gather */
   while (adsl_gai1_inp_w2 != adsl_gai1_inp_w1) {
     adsl_gai1_inp_w2 = adsl_gai1_inp_w2->adsc_next;
     if (adsl_gai1_inp_w2 == NULL) goto p_illogic_00;  /* program illogic */
     iml1 += sizeof(struct dsd_gather_i_1);
   }
   if ((achl_work_2 - iml1) < achl_work_1) {  /* not enough space      */
     if (bol_output == FALSE) goto p_out_80;  /* overflow              */
     adsp_hl_clib_1->boc_callagain = TRUE;  /* call again this direction */
#ifdef CHECK_OUTPUT_01
     m_check_output_01( adsp_hl_clib_1 );
#endif
     return;                                /* to be called again      */
   }
   bol_output = TRUE;                       /* output has been done    */

   p_out_20:                                /* output data unchanged   */
   achl_work_2 -= sizeof(struct dsd_gather_i_1);
   if (achl_work_2 < achl_work_1) goto p_out_80;  /* overflow          */
   adsl_gai1_out_1 = (struct dsd_gather_i_1 *) achl_work_2;
   adsl_gai1_out_1->adsc_next = NULL;
   adsl_gai1_out_1->achc_ginp_cur = adsl_gai1_inp_start->achc_ginp_cur;
   adsl_gai1_out_1->achc_ginp_end = adsl_gai1_inp_start->achc_ginp_end;
#ifdef DEBUG_101208_01
   iml_d1 = sprintf( achl_display, "l%05d gather=%p cur=%p end=%p.",
                     __LINE__, adsl_gai1_out_1, adsl_gai1_out_1->achc_ginp_cur, adsl_gai1_out_1->achc_ginp_end );
   achl_display += iml_d1;
   iml_d2 = D_LEN_LINE_M1 - iml_d1;
   if (iml_d2 > 0) {
     memset( achl_display, ' ', iml_d2 );
     achl_display += iml_d2;
   }
#endif
#ifdef B130119
   if (adsl_gai1_out_2 == NULL) {
#ifndef NEW_WSP_1102
     adsp_hl_clib_1->adsc_gather_i_1_out = adsl_gai1_out_1;
#else
     if (adsp_hl_clib_1->inc_func != DEF_IFUNC_TOSERVER) {  /* send to client */
       adsp_hl_clib_1->adsc_gai1_out_to_client = adsl_gai1_out_1;  /* output data to client */
     } else {                               /* send to server          */
       adsp_hl_clib_1->adsc_gai1_out_to_server = adsl_gai1_out_1;  /* output data to server */
     }
#endif
   } else {
     adsl_gai1_out_2->adsc_next = adsl_gai1_out_1;
   }
   adsl_gai1_out_2 = adsl_gai1_out_1;
#endif
#ifndef B130119
   *aadsl_gai1_out_normal = adsl_gai1_out_1;  /* output data normal direction */
   aadsl_gai1_out_normal = &adsl_gai1_out_1->adsc_next;  /* this is last output */
#endif
   if (adsl_gai1_inp_start != adsl_gai1_inp_w1) {
     adsl_gai1_inp_start->achc_ginp_cur = adsl_gai1_inp_start->achc_ginp_end;
     adsl_gai1_inp_start = adsl_gai1_inp_start->adsc_next;
     if (adsl_gai1_inp_start) goto p_out_20;  /* output next part      */
     goto p_illogic_00;                     /* program illogic         */
   }
   adsl_gai1_inp_start->achc_ginp_cur = achl_inp;  /* processed so far */
   adsl_gai1_out_1->achc_ginp_end = achl_inp;  /* output only till here */
   goto p_check_recv_00;                    /* check received packet   */

   p_end_tunnel_00:                         /* end the tunnel          */
#ifndef B130607
   adsp_hl_clib_1->adsc_gai1_out_to_server = NULL;  /* output data to server */
#define ADSL_GAI1_G ((struct dsd_gather_i_1 *) adsp_hl_clib_1->achc_work_area)
   ADSL_GAI1_G->achc_ginp_cur = (char *) ucrs_send_stop;
   ADSL_GAI1_G->achc_ginp_end = (char *) ucrs_send_stop + sizeof(ucrs_send_stop);
   ADSL_GAI1_G->adsc_next = NULL;
   adsp_hl_clib_1->adsc_gai1_out_to_client = ADSL_GAI1_G;  /* output data direction to client */
#undef ADSL_GAI1_G
#endif
   adsp_hl_clib_1->inc_return = DEF_IRET_END;  /* return code          */
   return;

   p_out_80:                                /* overflow in work-area   */
   m_sdh_printf( &dsl_sdh_call_1, "xl-sdh-ppp-pf-05-l%05d-E p_out_80 overflow work-area", __LINE__ );
   adsp_hl_clib_1->inc_return = DEF_IRET_END;  /* return code          */
   return;

   p_inv_data_00:                           /* input data invalid      */
   m_sdh_printf( &dsl_sdh_call_1, "xl-sdh-ppp-pf-05-l%05d-E p_inv_data_00 input data invalid", __LINE__ );
   adsp_hl_clib_1->inc_return = DEF_IRET_END;  /* return code          */
   return;

   p_data_to_long:                          /* input data too long     */
   m_sdh_printf( &dsl_sdh_call_1, "xl-sdh-ppp-pf-05-l%05d-E p_inv_data_00 input data too long", __LINE__ );
   adsp_hl_clib_1->inc_return = DEF_IRET_END;  /* return code          */
   return;

   p_illogic_00:                            /* program illogic         */
   m_sdh_printf( &dsl_sdh_call_1, "xl-sdh-ppp-pf-05-l%05d-E p_illogic_00 program illogic", __LINE__ );
   adsp_hl_clib_1->inc_return = DEF_IRET_END;  /* return code          */
   return;
#undef ADSL_CLCO
#undef CHL_PROTOCOL
} /* end m_hlclib01()                                                  */

static int m_get_ineta_w( UNSIG_MED *amp_ineta, HL_WCHAR *awcp_value ) {
   BOOL       bol1;                         /* working variable        */
   int        iml1, iml2;                   /* working variables       */
   HL_WCHAR   *awcl1;                       /* working variable        */
   unsigned char chrl_ineta_w1[4];          /* INETA                   */

   iml1 = 0;                                /* first digit             */
   awcl1 = awcp_value;                      /* get value               */

   p_ineta_20:                              /* retrieve number of INETA */
   iml2 = 0;                                /* clear number            */
   bol1 = FALSE;                            /* no digit yet            */
   while ((*awcl1 >= '0') && (*awcl1 <= '9')) {
     iml2 *= 10;                            /* shift old value         */
     iml2 += *awcl1 - '0';
     if (iml2 >= 256) return -1;
     awcl1++;                               /* next digit              */
     bol1 = TRUE;                           /* digit found             */
   }
   if (bol1 == FALSE) return -1;            /* no digit found          */
   chrl_ineta_w1[ iml1++ ] = (unsigned char) iml2;
   if (iml1 == 4) {                         /* all parts set           */
     if (*awcl1 != 0) return -1;            /* too many parts          */
     /* INETA decoded                                                  */
     *amp_ineta = *((UNSIG_MED *) chrl_ineta_w1);
     return 0;                              /* all valid               */
   }
   if (*awcl1 == '.') {                     /* separator found         */
     awcl1++;                               /* next character          */
     goto p_ineta_20;                       /* retrieve number of INETA */
   }
   return -1;
} /* end m_get_ineta_w()                                               */

/* retrieve INETA of string                                            */
static int m_get_ineta_a( UNSIG_MED *amp_ineta, char *achp_value, char *achp_end ) {
   BOOL       bol1;                         /* working variable        */
   int        iml1, iml2;                   /* working variables       */
   char       *achl1;                       /* working variable        */
   unsigned char chrl_ineta_w1[4];          /* INETA                   */

   iml1 = 0;                                /* first digit             */
   achl1 = achp_value;                      /* get value               */

   p_ineta_20:                              /* retrieve number of INETA */
   iml2 = 0;                                /* clear number            */
   bol1 = FALSE;                            /* no digit yet            */
   while ((achl1 < achp_end) && (*achl1 >= '0') && (*achl1 <= '9')) {
     iml2 *= 10;                            /* shift old value         */
     iml2 += *achl1 - '0';
     if (iml2 >= 256) return -1;
     achl1++;                               /* next digit              */
     bol1 = TRUE;                           /* digit found             */
   }
   if (bol1 == FALSE) return -1;            /* no digit found          */
   chrl_ineta_w1[ iml1++ ] = (unsigned char) iml2;
   if (iml1 == 4) {                         /* all parts set           */
     if (achl1 != achp_end) return -1;      /* too many parts          */
     /* INETA decoded                                                  */
     *amp_ineta = *((UNSIG_MED *) chrl_ineta_w1);
     return 0;                              /* all valid               */
   }
   if (*achl1 == '.') {                     /* separator found         */
     achl1++;                               /* next character          */
     goto p_ineta_20;                       /* retrieve number of INETA */
   }
   return -1;
} /* end m_get_ineta_a()                                               */

/* check if an INETA is in the range of private INETAs                 */
static BOOL m_check_private_ineta( char *achp_ineta ) {
   int        iml1;                         /* working variable        */
   int        iml_cmp;                      /* for compare             */
   unsigned char *aucl_w1;                  /* working variable        */

   aucl_w1 = (unsigned char *) &ucrrs_private_inetas[0][0];

   p_check_upper:                           /* check upper INETA       */
   iml1 = 0;                                /* clear index             */
   do {
     iml_cmp = *(aucl_w1 + 4 + iml1) - *((unsigned char *) achp_ineta + iml1);
     if (iml_cmp > 0) break;                /* INETA to compare is higher */
     if (iml_cmp < 0) {                     /* INETA to compare is lower */
       goto p_end_range;                    /* not in this range       */
     }
     iml1++;                                /* next digit              */
   } while (iml1 < sizeof(int));
   iml1 = 0;                                /* clear index             */
   do {
     iml_cmp = *(aucl_w1 + iml1) - *((unsigned char *) achp_ineta + iml1);
     if (iml_cmp < 0) break;                /* INETA to compare is lower */
     if (iml_cmp > 0) {                     /* INETA to compare is higher */
       goto p_end_range;                    /* not in this range       */
     }
     if (*((unsigned char *) achp_ineta + iml1) < *(aucl_w1 + iml1)) {
       goto p_end_range;                    /* not in this range       */
     }
     iml1++;                                /* next digit              */
   } while (iml1 < sizeof(int));
   return TRUE;                             /* is private INETA        */

   p_end_range:                             /* not in this range       */
   aucl_w1 += 2 * sizeof(int);              /* next range              */
   if (aucl_w1 < ((unsigned char *) ucrrs_private_inetas + sizeof(ucrrs_private_inetas))) {
     goto p_check_upper;                    /* check upper INETA       */
   }
   return FALSE;                            /* is public INETA         */
} /* end m_check_private_ineta()                                       */

static int m_natted_ineta( struct dsd_hl_clib_1 *adsp_hl_clib_1, char *achp_ineta ) {
   BOOL       bol1;                         /* working variable        */
   int        iml1, iml2;                   /* working variables       */
   int        iml_ineta;                    /* INETA for computation   */
   struct dsd_clib1_contr_1 *adsl_contr_1;  /* for addressing          */
   struct dsd_cc1_ext *adsl_cc1_ext_w1;     /* structure session control extension */
   struct dsd_cc1_ext *adsl_cc1_ext_w2;     /* structure session control extension */
   struct dsd_ineta_ctl_1 *adsl_ic1_w1;     /* control INETA           */
   struct dsd_sdh_call_1 dsl_sdh_call_1;    /* SDH call structure      */
   struct dsd_ineta_ctl_1 dsl_ic1_l;        /* control INETA           */
   struct dsd_htree1_avl_work dsl_htree1_work;  /* work-area for AVL-Tree */

// dsl_ic1_l.imc_ineta = *((int *) achp_ineta);
   memcpy( &dsl_ic1_l.imc_ineta, achp_ineta, sizeof(UNSIG_MED) );
   bol1 = m_check_private_ineta( achp_ineta );
   if (bol1 == FALSE) {                     /* is public INETA         */
     return dsl_ic1_l.imc_ineta;            /* return the original INETA */
   }
   adsl_contr_1 = (struct dsd_clib1_contr_1 *) adsp_hl_clib_1->ac_ext;
   if (dsl_ic1_l.imc_ineta == adsl_contr_1->umc_ineta_cl_int) {  /* INETA client intern in intranet */
     return adsl_contr_1->umc_ineta_client;  /* INETA client in tunnel */
   }
   iml_ineta = adsl_contr_1->umc_ineta_lower;
   bol1 = m_htree1_avl_search( NULL, &adsl_contr_1->dsc_htree1_avl_cntl_ineta,
                               &dsl_htree1_work, &dsl_ic1_l.dsc_sort_ineta );
   if (bol1 == FALSE) {                     /* error occured           */
     dsl_sdh_call_1.amc_aux = adsp_hl_clib_1->amc_aux;  /* auxiliary subroutine */
     dsl_sdh_call_1.vpc_userfld = adsp_hl_clib_1->vpc_userfld;  /* User Field Subroutine */
     m_sdh_printf( &dsl_sdh_call_1, "xl-sdh-ppp-pf-05-l%05d-W m_htree1_avl_search() failed",
                   __LINE__ );
   }
   if (dsl_htree1_work.adsc_found) {        /* entry found             */
     if (   (((char *) dsl_htree1_work.adsc_found) >= ((char *) adsl_contr_1->dsrc_ic1))  /* lower address */
         && (((char *) dsl_htree1_work.adsc_found) < ((char *) adsl_contr_1->dsrc_ic1 + sizeof(adsl_contr_1->dsrc_ic1)))) {  /* upper address */
       iml1 = (((char *) dsl_htree1_work.adsc_found) - ((char *) adsl_contr_1->dsrc_ic1))
                / sizeof(struct dsd_ineta_ctl_1);
       goto p_ret_ineta;                    /* return INETA, iml1 contains index */
     }
     iml1 = DEF_INETA_TABLE_ORG;            /* number of entries original table */
     adsl_cc1_ext_w1 = adsl_contr_1->adsc_cc1_ext;  /* structure session control extension */
     while (adsl_cc1_ext_w1) {              /* loop over all extensions */
       if (   (((char *) dsl_htree1_work.adsc_found) >= ((char *) adsl_cc1_ext_w1->dsrc_ic1))  /* lower address */
           && (((char *) dsl_htree1_work.adsc_found) < ((char *) adsl_cc1_ext_w1->dsrc_ic1 + sizeof(adsl_cc1_ext_w1->dsrc_ic1)))) {  /* upper address */
         iml1 += (((char *) dsl_htree1_work.adsc_found) - ((char *) adsl_cc1_ext_w1->dsrc_ic1))
                  / sizeof(struct dsd_ineta_ctl_1);
         goto p_ret_ineta;                  /* return INETA, iml1 contains index */
       }
       iml1 += DEF_INETA_TABLE_EXT;         /* number of entries extension */
       adsl_cc1_ext_w1 = adsl_cc1_ext_w1->adsc_next;  /* get next in chain */
     }
   }
   /* create new entry                                                 */
   iml1 = adsl_contr_1->imc_alloc;          /* number of INETAs allocated */
   adsl_contr_1->imc_alloc++;               /* number of INETAs allocated */
   if (iml1 < DEF_INETA_TABLE_ORG) {        /* number of entries original table */
     adsl_ic1_w1 = &adsl_contr_1->dsrc_ic1[ iml1 ];  /* control INETA  */
   } else {                                 /* use extension           */
     iml2 = iml1 - DEF_INETA_TABLE_ORG;     /* number of entries original table */
     adsl_cc1_ext_w1 = adsl_contr_1->adsc_cc1_ext;  /* structure session control extension */
     adsl_cc1_ext_w2 = NULL;                /* clear last element      */
     while (iml2 >= DEF_INETA_TABLE_EXT) {  /* number of entries extension */
       iml2 -= DEF_INETA_TABLE_EXT;         /* number of entries extension */
       adsl_cc1_ext_w2 = adsl_cc1_ext_w1;   /* save last element       */
       adsl_cc1_ext_w1 = adsl_cc1_ext_w1->adsc_next;  /* get next in chain */
     }
     if (adsl_cc1_ext_w1 == NULL) {         /* need to allocate new extension */
       bol1 = adsp_hl_clib_1->amc_aux( adsp_hl_clib_1->vpc_userfld,
                                       DEF_AUX_MEMGET,
                                       &adsl_cc1_ext_w1,
                                       sizeof(struct dsd_cc1_ext) );
       if (bol1 == FALSE) {
         dsl_sdh_call_1.amc_aux = adsp_hl_clib_1->amc_aux;  /* auxiliary subroutine */
         dsl_sdh_call_1.vpc_userfld = adsp_hl_clib_1->vpc_userfld;  /* User Field Subroutine */
         m_sdh_printf( &dsl_sdh_call_1, "xl-sdh-ppp-pf-05-l%05d-W aux( DEF_AUX_MEMGET ) failed",
                       __LINE__ );
       }
       adsl_cc1_ext_w1->adsc_next = NULL;   /* clear chain field       */
       if (adsl_cc1_ext_w2 == NULL) {       /* first extension         */
         adsl_contr_1->adsc_cc1_ext = adsl_cc1_ext_w1;  /* structure session control extension */
       } else {                             /* next extension          */
         adsl_cc1_ext_w2->adsc_next = adsl_cc1_ext_w1;  /* append new extension */
       }
     }
     adsl_ic1_w1 = &adsl_cc1_ext_w1->dsrc_ic1[ iml2 ];  /* control INETA */
   }
   adsl_ic1_w1->imc_ineta = *((int *) achp_ineta);
   bol1 = m_htree1_avl_insert( NULL, &adsl_contr_1->dsc_htree1_avl_cntl_ineta,
                               &dsl_htree1_work, &adsl_ic1_w1->dsc_sort_ineta );
   if (bol1 == FALSE) {                     /* error occured           */
     dsl_sdh_call_1.amc_aux = adsp_hl_clib_1->amc_aux;  /* auxiliary subroutine */
     dsl_sdh_call_1.vpc_userfld = adsp_hl_clib_1->vpc_userfld;  /* User Field Subroutine */
     m_sdh_printf( &dsl_sdh_call_1, "xl-sdh-ppp-pf-05-l%05d-W m_htree1_avl_insert() failed",
                   __LINE__ );
   }
   m_ineta_op_add( (char *) &iml_ineta, sizeof(int), 2 + iml1 );
   adsl_contr_1->umc_ineta_max_used = iml_ineta;  /* set upper INETA   */
   if (memcmp( &adsl_contr_1->umc_ineta_max_used,
               &adsl_contr_1->umc_ineta_upper,
               sizeof(UNSIG_MED) )
         <= 0) {
     return iml_ineta;
   }
   dsl_sdh_call_1.amc_aux = adsp_hl_clib_1->amc_aux;  /* auxiliary subroutine */
   dsl_sdh_call_1.vpc_userfld = adsp_hl_clib_1->vpc_userfld;  /* User Field Subroutine */
   m_sdh_printf( &dsl_sdh_call_1, "xl-sdh-ppp-pf-05-l%05d-W use non-configured NAT INETA %d.%d.%d.%d.",
                 __LINE__,
                 *((unsigned char *) &iml_ineta + 0),
                 *((unsigned char *) &iml_ineta + 1),
                 *((unsigned char *) &iml_ineta + 2),
                 *((unsigned char *) &iml_ineta + 3) );
   return iml_ineta;

   p_ret_ineta:                             /* return INETA, iml1 contains index */
   m_ineta_op_add( (char *) &iml_ineta, sizeof(int), 2 + iml1 );
   return iml_ineta;
} /* end m_natted_ineta()                                              */

static int m_original_ineta( struct dsd_hl_clib_1 *adsp_hl_clib_1, char *achp_ineta ) {
   BOOL       bol1;                         /* working variable        */
   int        iml1, iml2;                   /* working variables       */
   int        iml_cmp;                      /* for compare             */
// int        iml_ineta;                    /* INETA passed            */
   struct dsd_clib1_contr_1 *adsl_contr_1;  /* for addressing          */
   struct dsd_cc1_ext *adsl_cc1_ext_w1;     /* structure session control extension */
   struct dsd_sdh_call_1 dsl_sdh_call_1;    /* SDH call structure      */

   adsl_contr_1 = (struct dsd_clib1_contr_1 *) adsp_hl_clib_1->ac_ext;
// iml_ineta = *((int *) achp_ineta);
   iml1 = 0;                                /* clear index             */
   do {                                     /* loop over digits of INETA */
     iml_cmp = *((unsigned char *) &adsl_contr_1->umc_ineta_lower + iml1)
                - *((unsigned char *) achp_ineta + iml1);
     if (iml_cmp < 0) break;                /* all done                */
     if (iml_cmp > 0) goto p_ret_original;  /* return original INETA   */
     iml1++;                                /* increment index         */
   } while (iml1 < sizeof(UNSIG_MED));
   iml1 = 0;                                /* clear index             */
   do {                                     /* loop over digits of INETA */
     iml_cmp = *((unsigned char *) &adsl_contr_1->umc_ineta_upper + iml1)
                - *((unsigned char *) achp_ineta + iml1);
     if (iml_cmp > 0) break;                /* all done                */
     if (iml_cmp < 0) goto p_ret_original;  /* return original INETA   */
     iml1++;                                /* increment index         */
   } while (iml1 < sizeof(UNSIG_MED));
   iml1 = m_ineta_op_diff( achp_ineta, (char *) &adsl_contr_1->umc_ineta_lower, sizeof(int) );
   if (iml1 < 0) {                          /* error occured           */
     dsl_sdh_call_1.amc_aux = adsp_hl_clib_1->amc_aux;  /* auxiliary subroutine */
     dsl_sdh_call_1.vpc_userfld = adsp_hl_clib_1->vpc_userfld;  /* User Field Subroutine */
     m_sdh_printf( &dsl_sdh_call_1, "xl-sdh-ppp-pf-05-l%05d-W original INETA could not be translated 01",
                   __LINE__ );
     goto p_ret_original;                   /* return original INETA   */
   }
   iml1 -= 2;                               /* subtract offset first entry */
   if (iml1 < 0) {                          /* is control INETA        */
     return adsl_contr_1->umc_ineta_cl_int;  /* INETA client intern in intranet */
   }
   if (iml1 < DEF_INETA_TABLE_ORG) {        /* number of entries original table */
     return adsl_contr_1->dsrc_ic1[ iml1 ].imc_ineta;  /* from control INETA */
   }
   iml1 -= DEF_INETA_TABLE_ORG;             /* number of entries original table */
   if (adsl_contr_1->adsc_cc1_ext == NULL) {  /* structure session control extension */
     dsl_sdh_call_1.amc_aux = adsp_hl_clib_1->amc_aux;  /* auxiliary subroutine */
     dsl_sdh_call_1.vpc_userfld = adsp_hl_clib_1->vpc_userfld;  /* User Field Subroutine */
     m_sdh_printf( &dsl_sdh_call_1, "xl-sdh-ppp-pf-05-l%05d-W original INETA could not be translated 02",
                   __LINE__ );
     goto p_ret_original;                   /* return original INETA   */
   }
   adsl_cc1_ext_w1 = adsl_contr_1->adsc_cc1_ext;  /* structure session control extension */
   while (iml1 >= DEF_INETA_TABLE_EXT) {    /* number of entries extension */
     iml1 -= DEF_INETA_TABLE_EXT;           /* number of entries extension */
     adsl_cc1_ext_w1 = adsl_cc1_ext_w1->adsc_next;  /* get next in chain */
     if (adsl_cc1_ext_w1 == NULL) {
       dsl_sdh_call_1.amc_aux = adsp_hl_clib_1->amc_aux;  /* auxiliary subroutine */
       dsl_sdh_call_1.vpc_userfld = adsp_hl_clib_1->vpc_userfld;  /* User Field Subroutine */
       m_sdh_printf( &dsl_sdh_call_1, "xl-sdh-ppp-pf-05-l%05d-W original INETA could not be translated 03",
                     __LINE__ );
       goto p_ret_original;                 /* return original INETA   */
     }
   }
   return adsl_cc1_ext_w1->dsrc_ic1[ iml1 ].imc_ineta;  /* from control INETA */

   p_ret_original:                          /* return original INETA   */
// return iml_ineta;
   return *((int *) achp_ineta);
} /* end m_original_ineta()                                            */

/* compare entries in AVL tree of INETAs IPV4                          */
static int m_cmp_ineta( void *ap_option,
                        struct dsd_htree1_avl_entry *adsp_entry_1,
                        struct dsd_htree1_avl_entry *adsp_entry_2 ) {
   int        iml1;                         /* working variable        */
   int        iml_cmp;                      /* for compare             */

#define ADSL_INETA_P1 ((struct dsd_ineta_ctl_1 *) ((char *) adsp_entry_1 - offsetof( struct dsd_ineta_ctl_1, dsc_sort_ineta )))
#define ADSL_INETA_P2 ((struct dsd_ineta_ctl_1 *) ((char *) adsp_entry_2 - offsetof( struct dsd_ineta_ctl_1, dsc_sort_ineta )))
   iml1 = 0;                                /* clear index             */
   do {                                     /* loop over digits of INETA */
     iml_cmp = *((unsigned char *) &ADSL_INETA_P2->imc_ineta + iml1)
                - *((unsigned char *) &ADSL_INETA_P1->imc_ineta + iml1);
     if (iml_cmp != 0) return iml_cmp;
     iml1++;                                /* increment index         */
   } while (iml1 < sizeof(int));
   return 0;                                /* entries are equal       */
#undef ADSL_INETA_P1
#undef ADSL_INETA_P2
} /* end m_cmp_ineta()                                                 */

/* subroutine for output to console                                    */
static int m_sdh_printf( struct dsd_sdh_call_1 *adsp_sdh_call_1, const char *achptext, ... ) {
   BOOL       bol1;                         /* working variable        */
   int        iml1;                         /* working variable        */
   va_list    dsl_argptr;
   char       chrl_out1[512];

   va_start( dsl_argptr, achptext );
   iml1 = m_hlvsnprintf( chrl_out1, sizeof(chrl_out1), ied_chs_utf_8, achptext, dsl_argptr );
   va_end( dsl_argptr );
   bol1 = (*adsp_sdh_call_1->amc_aux)( adsp_sdh_call_1->vpc_userfld,
                                       DEF_AUX_CONSOLE_OUT,  /* output to console */
                                       chrl_out1, iml1 );
   return iml1;
} /* end m_sdh_printf()                                                */

/* subroutine to display date and time                                 */
static int m_get_date_time( char *achp_buff ) {
   time_t     dsl_time;

   time( &dsl_time );
   return strftime( achp_buff, 18, "%d.%m.%y %H:%M:%S", localtime( &dsl_time ) );
} /* end m_get_date_time()                                             */

/* subroutine to dump storage-content to console                       */
static void m_sdh_console_out( struct dsd_sdh_call_1 *adsp_sdh_call_1,
                               char *achp_buff, int implength ) {
   int        iml1, iml2, iml3, iml4, iml5, iml6;  /* working variable */
   char       byl1;                         /* working-variable        */
   char       chrlwork1[ 76 ];              /* buffer to print         */

   iml1 = 0;
   while (iml1 < implength) {
     iml2 = iml1 + 16;
     if (iml2 > implength) iml2 = implength;
     for ( iml3 = 4; iml3 < 75; iml3++ ) {
       chrlwork1[iml3] = ' ';
     }
     chrlwork1[58] = '*';
     chrlwork1[75] = '*';
     iml3 = 4;
     do {
       iml3--;
       chrlwork1[ iml3 ] = chrstrans[ (iml1 >> ((4 - 1 - iml3) << 2)) & 0X0F ];
     } while (iml3 > 0);
     iml4 = 6;                              /* start hexa digits here  */
     iml5 = 59;                             /* start ASCII here        */
     iml6 = 4;                              /* times normal            */
     do {
       byl1 = achp_buff[ iml1++ ];
       chrlwork1[ iml4++ ] = chrstrans[ (byl1 >> 4) & 0X0F ];
       chrlwork1[ iml4++ ] = chrstrans[ byl1 & 0X0F ];
       iml4++;
       if (byl1 > 0X20) {
         chrlwork1[ iml5 ] = byl1;
       }
       iml5++;
       iml6--;
       if (iml6 == 0) {
         iml4++;
         iml6 = 4;
       }
     } while (iml1 < iml2);
//   printf( "%.*s\n", sizeof(chrlwork1), chrlwork1 );
     m_sdh_printf( adsp_sdh_call_1, "%.*s", sizeof(chrlwork1), chrlwork1 );
   }
} /* end m_sdh_console_out()                                           */

/* dump output data from gather structures                             */
static void m_dump_gather( struct dsd_sdh_call_1 *adsp_sdh_call_1,
  struct dsd_gather_i_1 *adsp_gather_i_1_in,  /* input data            */
  int imp_len_trace_input ) {               /* length trace-input      */
   int        iml1, iml2, iml3, iml4, iml5, iml6;  /* working variable */
   char       byl1;                         /* working-variable        */
   struct dsd_gather_i_1 *adsl_gai1_w1;     /* working-variable        */
   char       *achl_cur;                    /* position in gather      */
   char       chrlwork1[ 76 ];              /* buffer to print         */

   adsl_gai1_w1 = adsp_gather_i_1_in;
   if (adsl_gai1_w1 == NULL) return;
   achl_cur = adsl_gai1_w1->achc_ginp_cur;
   iml1 = 0;
   while (iml1 < imp_len_trace_input) {
     iml2 = iml1 + 16;
     if (iml2 > imp_len_trace_input) iml2 = imp_len_trace_input;
     for ( iml3 = 4; iml3 < 75; iml3++ ) {
       chrlwork1[iml3] = ' ';
     }
     chrlwork1[58] = '*';
     chrlwork1[75] = '*';
     iml3 = 4;
     do {
       iml3--;
       chrlwork1[ iml3 ] = chrstrans[ (iml1 >> ((4 - 1 - iml3) << 2)) & 0X0F ];
     } while (iml3 > 0);
     iml4 = 6;                              /* start hexa digits here  */
     iml5 = 59;                             /* start ASCII here        */
     iml6 = 4;                              /* times normal            */
     do {
       while (achl_cur >= adsl_gai1_w1->achc_ginp_end) {
         adsl_gai1_w1 = adsl_gai1_w1->adsc_next;
         if (adsl_gai1_w1 == NULL) return;
         achl_cur = adsl_gai1_w1->achc_ginp_cur;
       }
       byl1 = *achl_cur++;
       iml1++;
       chrlwork1[ iml4++ ] = chrstrans[ (byl1 >> 4) & 0X0F ];
       chrlwork1[ iml4++ ] = chrstrans[ byl1 & 0X0F ];
       iml4++;
       if (byl1 > 0X20) {
         chrlwork1[ iml5 ] = byl1;
       }
       iml5++;
       iml6--;
       if (iml6 == 0) {
         iml4++;
         iml6 = 4;
       }
     } while (iml1 < iml2);
     m_sdh_printf( adsp_sdh_call_1, "%.*s", sizeof(chrlwork1), chrlwork1 );
   }
} /* end m_dump_gather()                                               */

/* pseudo-entry, cannot be used in Server-Data-Hook                    */
extern "C" int m_hl1_printf( char *aptext, ... ) {
   return 0;
} /* end m_hl1_printf()                                                */

#ifdef CHECK_OUTPUT_01
#ifndef HPPPT1_V21                          /* 18.01.13 KB HOB-PPP-T1 V2.1 */
static void m_check_output_01( struct dsd_hl_clib_1 *adsp_hl_clib_1 ) {
   int        iml1, iml2;                   /* working variables       */
   int        iml_len_nhasn;                /* length bytes NHASN      */
   int        iml_len_packet;               /* length bytes packet     */
   char       *achl_w1;                     /* working variable        */
   char       *achl_w2;                     /* working variable        */
   struct dsd_clib1_contr_1 *adsl_contr_1;  /* for addressing          */
   struct dsd_gather_i_1 *adsl_gai1_w1;     /* working variable gather */
   struct dsd_gather_i_1 *adsl_gai1_w2;     /* working variable gather */
   struct dsd_sdh_call_1 dsl_sdh_call_1;    /* SDH call structure      */
   char       chrc_display[ 16 * 1024 ];    /* display area            */
#define D_LEN_LINE_M2 128

#ifndef NEW_WSP_1102
   if (adsp_hl_clib_1->adsc_gather_i_1_out == NULL) return;
#else
   adsl_gai1_w1 = adsp_hl_clib_1->adsc_gai1_out_to_client;  /* output data to client */
   if (adsl_gai1_w1 == NULL) {
     adsl_gai1_w1 = adsp_hl_clib_1->adsc_gai1_out_to_server;  /* output data to server */
   }
   if (adsl_gai1_w1 == NULL) return;
   adsl_gai1_w2 = adsl_gai1_w1;             /* save for later          */
#endif
   dsl_sdh_call_1.amc_aux = adsp_hl_clib_1->amc_aux;  /* auxiliary subroutine */
   dsl_sdh_call_1.vpc_userfld = adsp_hl_clib_1->vpc_userfld;  /* User Field Subroutine */
   adsl_contr_1 = (struct dsd_clib1_contr_1 *) adsp_hl_clib_1->ac_ext;
#ifndef NEW_WSP_1102
   adsl_gai1_w1 = adsp_hl_clib_1->adsc_gather_i_1_out;
#endif
   achl_w1 = adsl_gai1_w1->achc_ginp_cur;
   iml1 = adsl_gai1_w1->achc_ginp_end - achl_w1;
   if (   (iml1 >= 18)
       && (!memcmp( achl_w1, "HOB PPP TUNNEL V01", 18 ))) {
     achl_w1 += 20;
     if (achl_w1 >= adsl_gai1_w1->achc_ginp_end) {
       adsl_gai1_w1 = adsl_gai1_w1->adsc_next;  /* get next in chain     */
#ifndef NEW_WSP_1102
       if (adsl_gai1_w1 == NULL) return;
#else
       if (adsl_gai1_w1 == NULL) {          /* end of input data       */
         if (adsl_gai1_w2 == adsp_hl_clib_1->adsc_gai1_out_to_client) {  /* output data to client */
           adsl_gai1_w1 = adsp_hl_clib_1->adsc_gai1_out_to_server;  /* output data to server */
         }
         if (adsl_gai1_w1 == NULL) return;
         adsl_gai1_w2 = adsl_gai1_w1;       /* save for later          */
       }
#endif
       achl_w1 = adsl_gai1_w1->achc_ginp_cur;
     }
   }

   p_check_recv_00:                         /* check next packet       */
   iml_len_nhasn = 0;                       /* clear length bytes NHASN */
   iml_len_packet = 0;                      /* clear length bytes packet */

   p_check_recv_20:                         /* decode length NHASN     */
   while (achl_w1 >= adsl_gai1_w1->achc_ginp_end) {  /* end of gather  */
     adsl_gai1_w1 = adsl_gai1_w1->adsc_next;  /* get next gather in chain */
#ifndef NEW_WSP_1102
     if (adsl_gai1_w1 == NULL) {            /* end of input data       */
       if (iml_len_nhasn == 0) return;      /* to be called again      */
       m_sdh_printf( &dsl_sdh_call_1, "xl-sdh-ppp-pf-05-l%05d-E end output data and iml_len_nhasn != 0.",
                     __LINE__ );
       goto p_display_00;                   /* display the chain       */
     }
#else
     if (adsl_gai1_w1 == NULL) {            /* end of input data       */
       if (iml_len_nhasn != 0) {            /* not to be called again  */
         m_sdh_printf( &dsl_sdh_call_1, "xl-sdh-ppp-pf-05-l%05d-E end output data and iml_len_nhasn != 0.",
                       __LINE__ );
         goto p_display_00;                   /* display the chain       */
       }
       if (adsl_gai1_w2 == adsp_hl_clib_1->adsc_gai1_out_to_client) {  /* output data to client */
         adsl_gai1_w1 = adsp_hl_clib_1->adsc_gai1_out_to_server;  /* output data to server */
       }
       if (adsl_gai1_w1 == NULL) return;
       adsl_gai1_w2 = adsl_gai1_w1;         /* save for later          */
     }
#endif
     achl_w1 = adsl_gai1_w1->achc_ginp_cur;  /* start in gather        */
   }
   iml_len_packet <<= 7;                    /* shift old value         */
   iml_len_packet |= *achl_w1++ & 0X7F;     /* apply new bits          */
   iml_len_nhasn++;                         /* increment length bytes NHASN */
   if ((unsigned char) *(achl_w1 - 1) & 0X80) {  /* more bit set       */
     if (iml_len_nhasn > MAX_LEN_NHASN) {   /* input data invalid      */
       m_sdh_printf( &dsl_sdh_call_1, "xl-sdh-ppp-pf-05-l%05d-E end output data and iml_len_nhasn > MAX_LEN_NHASN.",
                     __LINE__ );
       goto p_display_00;                   /* display the chain       */
     }
     goto p_check_recv_20;                  /* decode length NHASN     */
   }
   if (iml_len_packet <= 1) {               /* input data invalid      */
     m_sdh_printf( &dsl_sdh_call_1, "xl-sdh-ppp-pf-05-l%05d-E length NHASN iml_len_packet=%d invalid",
                   __LINE__, iml_len_packet );
     goto p_display_00;                     /* display the chain       */
   }
   while (achl_w1 >= adsl_gai1_w1->achc_ginp_end) {  /* end of gather */
     adsl_gai1_w1 = adsl_gai1_w1->adsc_next;  /* get next gather in chain */
     if (adsl_gai1_w1 == NULL) {            /* end of input data       */
       m_sdh_printf( &dsl_sdh_call_1, "xl-sdh-ppp-pf-05-l%05d-E end output data after length NHASN",
                     __LINE__ );
       goto p_display_00;                   /* display the chain       */
     }
     achl_w1 = adsl_gai1_w1->achc_ginp_cur;  /* start in gather        */
   }
#ifdef HPPPT1_V14_RECV                      /* 26.08.12 KB HOB-PPP-T1 V1.4 receive */
   if ((*achl_w1 & 0XD0) == 0X40) {         /* 0X4x - IPV4 or 0X6x - IPV6 */
     iml1 = iml_len_packet;                 /* get length packet       */
     goto p_check_recv_40;                  /* read over packet        */
   }
#endif
   if (   (*achl_w1 != '0')
       && (*achl_w1 != '1')
       && (*achl_w1 != '4')
       && (*achl_w1 != '6')) {
     m_sdh_printf( &dsl_sdh_call_1, "xl-sdh-ppp-pf-05-l%05d-E control character 0X%02X invalid",
                   __LINE__, (unsigned char) *achl_w1 );
     goto p_display_00;                     /* display the chain       */
   }
   iml1 = iml_len_packet;                   /* get length packet       */

   p_check_recv_40:                         /* read over packet        */
   while (achl_w1 >= adsl_gai1_w1->achc_ginp_end) {  /* end of gather */
     adsl_gai1_w1 = adsl_gai1_w1->adsc_next;  /* get next gather in chain */
     if (adsl_gai1_w1 == NULL) {            /* end of input data       */
       m_sdh_printf( &dsl_sdh_call_1, "xl-sdh-ppp-pf-05-l%05d-E end output data and %d/0X%X data in record missing",
                     __LINE__, iml1, iml1 );
       goto p_display_00;                   /* display the chain       */
     }
     achl_w1 = adsl_gai1_w1->achc_ginp_cur;  /* start in gather        */
   }
   iml2 = adsl_gai1_w1->achc_ginp_end - achl_w1;  /* length this part  */
   if (iml2 > iml1) iml2 = iml1;            /* only as long as requested */
   achl_w1 += iml2;                         /* add length this part    */
   iml1 -= iml2;                            /* subtract length this part */
   if (iml1) goto p_check_recv_40;          /* read over packet        */
   goto p_check_recv_00;                    /* check next packet       */

   p_display_00:                            /* display the chain       */
   achl_w2 = chrc_display;
#ifndef NEW_WSP_1102
   adsl_gai1_w2 = adsp_hl_clib_1->adsc_gather_i_1_out;
#endif
   while (adsl_gai1_w2) {
     iml2 = adsl_gai1_w2->achc_ginp_end - adsl_gai1_w2->achc_ginp_cur;
     iml1 = sprintf( achl_w2, "this=%p achc_ginp_cur=%p achc_ginp_end=%p len=%d/0X%p 0X%02X 0X%02X.",
                     adsl_gai1_w2, adsl_gai1_w2->achc_ginp_cur, adsl_gai1_w2->achc_ginp_end,
                     iml2, iml2,
                     *((unsigned char *) adsl_gai1_w2->achc_ginp_cur + 0),
                     *((unsigned char *) adsl_gai1_w2->achc_ginp_cur + 1) );
     achl_w2 += iml1;
     iml2 = D_LEN_LINE_M2 - iml1;
     if (iml2 > 0) {
       memset( achl_w2, ' ', iml2 );
       achl_w2 += iml2;
     }
     adsl_gai1_w2 = adsl_gai1_w2->adsc_next;
   }
   m_sdh_printf( &dsl_sdh_call_1, "xl-sdh-ppp-pf-05-l%05d-E output of chain done start=%p end=%p.",
                 __LINE__, chrc_display, achl_w2 );
   return;
} /* end m_check_output_01()                                           */
#endif
#ifdef HPPPT1_V21                           /* 18.01.13 KB HOB-PPP-T1 V2.1 */
static void m_check_output_01( struct dsd_hl_clib_1 *adsp_hl_clib_1 ) {
   int        iml1, iml2;                   /* working variables       */
   int        iml_len_nhasn;                /* length bytes NHASN      */
   int        iml_len_packet;               /* length bytes packet     */
   char       chl_type;                     /* type received           */
   char       *achl_w1;                     /* working variable        */
   char       *achl_w2;                     /* working variable        */
   char       *achl_w3;                     /* working variable        */
   struct dsd_clib1_contr_1 *adsl_contr_1;  /* for addressing          */
   struct dsd_gather_i_1 *adsl_gai1_w1;     /* working variable gather */
   struct dsd_gather_i_1 *adsl_gai1_w2;     /* working variable gather */
   struct dsd_sdh_call_1 dsl_sdh_call_1;    /* SDH call structure      */
   char       chrl_work1[ 5 ];              /* work area               */
   char       chrc_display[ 16 * 1024 ];    /* display area            */
#define D_LEN_LINE_M2 128

#ifndef NEW_WSP_1102
   if (adsp_hl_clib_1->adsc_gather_i_1_out == NULL) return;
#else
   adsl_gai1_w1 = adsp_hl_clib_1->adsc_gai1_out_to_client;  /* output data to client */
   if (adsl_gai1_w1 == NULL) {
     adsl_gai1_w1 = adsp_hl_clib_1->adsc_gai1_out_to_server;  /* output data to server */
   }
   if (adsl_gai1_w1 == NULL) return;
   adsl_gai1_w2 = adsl_gai1_w1;             /* save for later          */
#endif
   dsl_sdh_call_1.amc_aux = adsp_hl_clib_1->amc_aux;  /* auxiliary subroutine */
   dsl_sdh_call_1.vpc_userfld = adsp_hl_clib_1->vpc_userfld;  /* User Field Subroutine */
   adsl_contr_1 = (struct dsd_clib1_contr_1 *) adsp_hl_clib_1->ac_ext;
#ifndef NEW_WSP_1102
   adsl_gai1_w1 = adsp_hl_clib_1->adsc_gather_i_1_out;
#endif
   achl_w1 = adsl_gai1_w1->achc_ginp_cur;
   iml1 = adsl_gai1_w1->achc_ginp_end - achl_w1;
   if (   (iml1 >= 18)
       && (!memcmp( achl_w1, "HOB PPP TUNNEL V01", 18 ))) {
     achl_w1 += 20;
     if (achl_w1 >= adsl_gai1_w1->achc_ginp_end) {
       adsl_gai1_w1 = adsl_gai1_w1->adsc_next;  /* get next in chain   */
#ifndef NEW_WSP_1102
       if (adsl_gai1_w1 == NULL) return;
#else
       if (adsl_gai1_w1 == NULL) {          /* end of input data       */
         if (adsl_gai1_w2 == adsp_hl_clib_1->adsc_gai1_out_to_client) {  /* output data to client */
           adsl_gai1_w1 = adsp_hl_clib_1->adsc_gai1_out_to_server;  /* output data to server */
         }
         if (adsl_gai1_w1 == NULL) return;
         adsl_gai1_w2 = adsl_gai1_w1;       /* save for later          */
       }
#endif
       achl_w1 = adsl_gai1_w1->achc_ginp_cur;
     }
   }

   p_check_recv_00:                         /* check next packet       */
   while (achl_w1 >= adsl_gai1_w1->achc_ginp_end) {  /* end of gather  */
     adsl_gai1_w1 = adsl_gai1_w1->adsc_next;  /* get next gather in chain */
#ifndef NEW_WSP_1102
     if (adsl_gai1_w1 == NULL) return;      /* end of input data       */
#else
     if (adsl_gai1_w1 == NULL) {            /* end of input data       */
       if (adsl_gai1_w2 == adsp_hl_clib_1->adsc_gai1_out_to_client) {  /* output data to client */
         adsl_gai1_w1 = adsp_hl_clib_1->adsc_gai1_out_to_server;  /* output data to server */
       }
       if (adsl_gai1_w1 == NULL) return;
       adsl_gai1_w2 = adsl_gai1_w1;         /* save for later          */
     }
#endif
     achl_w1 = adsl_gai1_w1->achc_ginp_cur;  /* start in gather        */
   }
   chl_type = *achl_w1++;
   if ((chl_type & 0XF0) == 0X30) {
     iml_len_nhasn = 0;                     /* clear length bytes NHASN */
     iml_len_packet = 0;                    /* clear length bytes packet */
     goto p_check_recv_20;                  /* decode length NHASN     */
   }
   achl_w2 = chrl_work1;
   if ((chl_type & 0XF0) == 0X40) {         /* IPV4                    */
     if ((chl_type & 0X0F) < 5) {
       m_sdh_printf( &dsl_sdh_call_1, "xl-sdh-ppp-pf-05-l%05d-E control character 0X%02X IP header IPV4 too short",
                     __LINE__, (unsigned char) chl_type );
       goto p_display_00;                   /* display the chain       */
     }
     achl_w3 = chrl_work1 + 3;
   } else if ((chl_type & 0XF0) == 0X60) {  /* IPV6                    */
     achl_w3 = chrl_work1 + 5;
   } else {
     m_sdh_printf( &dsl_sdh_call_1, "xl-sdh-ppp-pf-05-l%05d-E control character 0X%02X invalid",
                   __LINE__, (unsigned char) chl_type );
     goto p_display_00;                     /* display the chain       */
   }

   p_check_recv_08:                         /* get fields for length   */
   while (achl_w1 >= adsl_gai1_w1->achc_ginp_end) {  /* end of gather  */
     adsl_gai1_w1 = adsl_gai1_w1->adsc_next;  /* get next gather in chain */
     if (adsl_gai1_w1 == NULL) {            /* end of input data       */
       m_sdh_printf( &dsl_sdh_call_1, "xl-sdh-ppp-pf-05-l%05d-E end output data NHASN length %d/0X%X and nothing follows",
                     __LINE__, iml_len_nhasn, iml_len_nhasn );
       goto p_display_00;                   /* display the chain       */
     }
     achl_w1 = adsl_gai1_w1->achc_ginp_cur;  /* start in gather        */
   }
   iml1 = achl_w3 - achl_w2;
   iml2 = adsl_gai1_w1->achc_ginp_end - achl_w1;
   if (iml1 > iml2) iml1 = iml2;
   memcpy( achl_w2, achl_w1, iml1 );
   achl_w2 += iml1;
   achl_w1 += iml1;
   if (achl_w2 < achl_w3) {
     goto p_check_recv_08;                  /* get fields for length   */
   }
   if ((chl_type & 0XF0) == 0X40) {         /* IPV4                    */
     iml_len_packet = (*((unsigned char *) &chrl_work1 + 1) << 8)
                        | *((unsigned char *) &chrl_work1 + 2);
     iml1 = iml_len_packet - 4;             /* get length remaining packet */
     iml2 = (chl_type & 0X0F) << 2;
   } else {                                 /* IPV6                    */
     iml_len_packet = ((*((unsigned char *) &chrl_work1 + 3) << 8)
                         | *((unsigned char *) &chrl_work1 + 4))
                      + D_LEN_HEADER_IPV6;
     iml1 = iml_len_packet - 6;             /* get length remaining packet */
     iml2 = D_LEN_HEADER_IPV6;
   }
   if (iml_len_packet <= iml2) {
     m_sdh_printf( &dsl_sdh_call_1, "xl-sdh-ppp-pf-05-l%05d-E packet IPV4 / IPV6 too short %d/0X%X.",
                   __LINE__, iml_len_packet, iml_len_packet );
     goto p_display_00;                     /* display the chain       */
   }
   goto p_check_recv_40;                    /* read over packet        */

   p_check_recv_20:                         /* decode length NHASN     */
   while (achl_w1 >= adsl_gai1_w1->achc_ginp_end) {  /* end of gather  */
     adsl_gai1_w1 = adsl_gai1_w1->adsc_next;  /* get next gather in chain */
     if (adsl_gai1_w1 == NULL) {            /* end of input data       */
       m_sdh_printf( &dsl_sdh_call_1, "xl-sdh-ppp-pf-05-l%05d-E end output data NHASN length %d/0X%X and nothing follows",
                     __LINE__, iml_len_nhasn, iml_len_nhasn );
       goto p_display_00;                   /* display the chain       */
     }
     achl_w1 = adsl_gai1_w1->achc_ginp_cur;  /* start in gather        */
   }
   iml_len_packet <<= 7;                    /* shift old value         */
   iml_len_packet |= *achl_w1++ & 0X7F;     /* apply new bits          */
   iml_len_nhasn++;                         /* increment length bytes NHASN */
   if ((unsigned char) *(achl_w1 - 1) & 0X80) {  /* more bit set       */
     if (iml_len_nhasn > MAX_LEN_NHASN) {   /* input data invalid      */
       m_sdh_printf( &dsl_sdh_call_1, "xl-sdh-ppp-pf-05-l%05d-E end output data and iml_len_nhasn > MAX_LEN_NHASN.",
                     __LINE__ );
       goto p_display_00;                   /* display the chain       */
     }
     goto p_check_recv_20;                  /* decode length NHASN     */
   }
   if (iml_len_packet <= 0) {               /* input data invalid      */
     m_sdh_printf( &dsl_sdh_call_1, "xl-sdh-ppp-pf-05-l%05d-E length NHASN iml_len_packet=%d invalid",
                   __LINE__, iml_len_packet );
     goto p_display_00;                     /* display the chain       */
   }
   while (achl_w1 >= adsl_gai1_w1->achc_ginp_end) {  /* end of gather */
     adsl_gai1_w1 = adsl_gai1_w1->adsc_next;  /* get next gather in chain */
     if (adsl_gai1_w1 == NULL) {            /* end of input data       */
       m_sdh_printf( &dsl_sdh_call_1, "xl-sdh-ppp-pf-05-l%05d-E end output data after length NHASN",
                     __LINE__ );
       goto p_display_00;                   /* display the chain       */
     }
     achl_w1 = adsl_gai1_w1->achc_ginp_cur;  /* start in gather        */
   }
   if (   (chl_type != '0')
       && (chl_type != '1')) {
     m_sdh_printf( &dsl_sdh_call_1, "xl-sdh-ppp-pf-05-l%05d-E control character 0X%02X invalid",
                   __LINE__, (unsigned char) chl_type );
     goto p_display_00;                     /* display the chain       */
   }
   iml1 = iml_len_packet;                   /* get length packet       */

   p_check_recv_40:                         /* read over packet        */
   while (achl_w1 >= adsl_gai1_w1->achc_ginp_end) {  /* end of gather */
     adsl_gai1_w1 = adsl_gai1_w1->adsc_next;  /* get next gather in chain */
     if (adsl_gai1_w1 == NULL) {            /* end of input data       */
       m_sdh_printf( &dsl_sdh_call_1, "xl-sdh-ppp-pf-05-l%05d-E end output data and %d/0X%X data in record missing",
                     __LINE__, iml1, iml1 );
       goto p_display_00;                   /* display the chain       */
     }
     achl_w1 = adsl_gai1_w1->achc_ginp_cur;  /* start in gather        */
   }
   iml2 = adsl_gai1_w1->achc_ginp_end - achl_w1;  /* length this part  */
   if (iml2 > iml1) iml2 = iml1;            /* only as long as requested */
   achl_w1 += iml2;                         /* add length this part    */
   iml1 -= iml2;                            /* subtract length this part */
   if (iml1) goto p_check_recv_40;          /* read over packet        */
   goto p_check_recv_00;                    /* check next packet       */

   p_display_00:                            /* display the chain       */
   achl_w2 = chrc_display;
#ifndef NEW_WSP_1102
   adsl_gai1_w2 = adsp_hl_clib_1->adsc_gather_i_1_out;
#endif
   while (adsl_gai1_w2) {
     iml2 = adsl_gai1_w2->achc_ginp_end - adsl_gai1_w2->achc_ginp_cur;
     iml1 = sprintf( achl_w2, "this=%p achc_ginp_cur=%p achc_ginp_end=%p len=%d/0X%p 0X%02X 0X%02X.",
                     adsl_gai1_w2, adsl_gai1_w2->achc_ginp_cur, adsl_gai1_w2->achc_ginp_end,
                     iml2, iml2,
                     *((unsigned char *) adsl_gai1_w2->achc_ginp_cur + 0),
                     *((unsigned char *) adsl_gai1_w2->achc_ginp_cur + 1) );
     achl_w2 += iml1;
     iml2 = D_LEN_LINE_M2 - iml1;
     if (iml2 > 0) {
       memset( achl_w2, ' ', iml2 );
       achl_w2 += iml2;
     }
     adsl_gai1_w2 = adsl_gai1_w2->adsc_next;
   }
   m_sdh_printf( &dsl_sdh_call_1, "xl-sdh-ppp-pf-05-l%05d-E output of chain done start=%p end=%p.",
                 __LINE__, chrc_display, achl_w2 );
   return;
} /* end m_check_output_01()                                           */
#endif
#endif
#ifdef TRACEHL_TIME
/* return the Epoch value in milliseconds                              */
static HL_LONGLONG m_get_epoch_ms( void ) {
#ifndef HL_UNIX
   struct __timeb64 timebuffer;

   _ftime64( &timebuffer );

   return ( timebuffer.time * 1000 + timebuffer.millitm );
#else
   struct timeval dsl_timeval;

   gettimeofday( &dsl_timeval, NULL );
   return (dsl_timeval.tv_sec * 1000 + dsl_timeval.tv_usec / 1000);
#endif
} /* end m_get_epoch_ms()                                              */
#endif
