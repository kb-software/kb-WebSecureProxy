// This file was generated by the script combine_sources.rb
/** @date Wed Sep 27 12:11:26 2017  (creation) */
/**
 ******************************************************************************
 * PROJECT:  HOB Encryption library
 *
 * This file provides the complete 'unicrypt'-library in one file only.
 * It replaces the old xs-encry-1.c file. 
 *
 * The following preprocessor defines are used to configure the general build:
 *
 * XH_INTERFACE             Builds the source for use in the WSP. As simple rule: 
 *                          If you use the SSL interface of the WSP, specified 
 *                          in hob-ssl-01.h, use this define!
 *
 * USE_ASSEMBLER_SOURCES    Compiles the source for use with the X86/X64 AES assembler 
 *                          sources. The used assembler sources and build instructions
 *                          are listed below.
 *
 * HOB_WIN64_ASM            When USE_ASSEMBLER_SOURCES is set, this can be set to 0 to
 *                          still use the C implementations of Software AES and SHA1 
 *                          (sources aesasm.asm and shaasm.asm). This is a workaround 
 *                          for 'ADDR32' relocation linker errors, if LARGEADDRESSAWARE:NO 
 *                          is not an option.
 *
 * ALT_SEEDING_SOURCE       to be set, if Linux Domain Socket are used for seeding
 *
 *
 *
 * Additionally, the following common HOB defines may still needed:
 * HL_LINUX_ARM     reduced CPU power (use settings of ARM CPU for RNG Seeding)
 * HL_BIG_ENDIAN    for big endian OSs, automatically set on HP-UX and AIX
 *
 * The following assembler sources are always required. Use MASM for Windows and NASM v2.09+ for Unix:
 *
 * Windows 32 bit: is-random-cas-02-32-win.asm, islock03-32-win.asm
 * Windows 64 bit: is-random-cas-02-64-win.asm, islock03-64-win.asm
 * Unix 32 bit: is-random-cas-02-32-nasm.s, islock03-32-nasm.s
 * Unix 64 bit: is-random-cas-02-64-nasm.s, islock03-64-nasm.s
 *
 * x86/x64 Assembler sources for Windows (use the respective MS assembler):
 *
 * Windows 32 bit: cpuaes86.asm
 * Windows 64 bit: cpuaes64.asm, aesasm.asm, shaasm.asm, fasttabs.inc, sbox.inc
 *
 * x86/x64 Assembler sources for Unix systems (Using Intel syntax, so use NASM v2.09, which is
 * available on all platforms):
 *
 * X86 (32 bit): cpuaes86.s
 * X64 (64 bit): cpuaes64.s
 *
 * The following options work for NASM on respective systems:
 *
 * Linux 32 bit: -f elf32 -F dwarf -g
 * Linux 64 bit: -f elf64 -F dwarf -g
 * Mac OS 32 bit: -f macho32
 * Mac OS 64 bit: -f macho64
 *
 * ARMv8 aarch64 Assembler source for Unix:
 * 
 * armaes64.S
 *
 * Use a native GNU compiler with option -mcpu=cortex-a53+crypto or similar.
 * The particular platform may vary, but the +crypto substring is important.
 * The reference GCC version is 4.9.2.
 *
 *
 * The HL_ENCR_* defines can be used to selectively compile only specific 
 * algorithms. If none of these is defined, all are compiled.
 *
 * Defines for crypto functions:
 * NO_RSA_BLINDING           Deactivate RSA blinding (requires defines _DEBUG or DEBUG)
 * HL_ENCR_AES               AES is compiled                                                
 * HL_ENCR_MD                MD2, MD4 and MD5 are compiled                                  
 * HL_ENCR_SHA               SHA1 and SHA2 are compiled                                     
 * HL_ENCR_DES               DES is compiled                                                
 * HL_ENCR_RC                RC2 and RC4 are compiled     
 * HL_ENCR_RMD               RIPEMD160 is compiled 
 * HL_ENCR_RSA               RSA is compiled  
 * HL_ENCR_HMAC              HMAC is compiled 
 * HL_ENCR_DSA               DSA is compiled 
 * HL_ENCR_RAND              RAND is compiled
 * HL_ENCR_LNUM              LNUM is compiled
 * HL_ENCR_PBKDF2            PBKDF2 is compiled
 *
 * Copyright (C) HOB Germany 2005 - 2014
 *
 * @version 1.01
 * @author  Gerhard Oed, Lutz Schmid, Stephan Schulze
 *
*/
#ifdef __APPLE__
#pragma clang optimize off
#endif
#if (!defined _WIN32_WINNT) & (_MSC_VER < 1700)
// required later for TryEnterCriticalSection
#define _WIN32_WINNT 0x0400
#endif
#if (!defined HL_ENCR_AES) && (!defined HL_ENCR_MD) && (!defined HL_ENCR_SHA) && (!defined HL_ENCR_DES) && (!defined HL_ENCR_RC) && (!defined HL_ENCR_RMD) && (!defined HL_ENCR_RSA) && (!defined HL_ENCR_HMAC) && (!defined HL_ENCR_DSA) && (!defined HL_ENCR_RAND) && (!defined HL_ENCR_LNUM) && (!defined HL_ENCR_PBKDF2) && (!defined HL_ENCR_HMEM) && (!defined HL_ENCR_VERSION)
#define HL_ENCR_AES
#define HL_ENCR_MD
#define HL_ENCR_SHA
#define HL_ENCR_DES
#define HL_ENCR_RC
#define HL_ENCR_RMD
#define HL_ENCR_RSA
#define HL_ENCR_HMAC
#define HL_ENCR_DSA
#define HL_ENCR_RAND
#define HL_ENCR_LNUM
#define HL_ENCR_PBKDF2
#define HL_ENCR_HMEM
#define HL_ENCR_VERSION
#endif

#ifdef HL_ENCR_AES
/** @defgroup aes AES
* This module implements the AES encryption algorithm (Rijndael).
*
* It is the current C implemetation. Only CBC/ECB Mode is implemented. <br>
* -- improved C-version for WIN32 --
*
* For secure operation, the key bytes must be generated by the @ref rand "HOB PRNG".
*
* Only 128, 192 and 256 Bit keys are supported, blocksize 128 Bits (nb = 4). 
* Further: nr(Number of rounds) = nk + 6.
*
<table>
     <tr><td>Keylen</td><td>nk</td><td>nr</td><td>Subkey Array Size (nr+1) * nb * 4 Bytes</td></tr>
     <tr><td>128</td><td>4</td><td>10</td><td>((10+1) * 4) * 4 = 44 * 4 = 176</td></tr>
     <tr><td>192</td><td>6</td><td>12</td><td>((12+1) * 4) * 4 = 52 * 4 = 108</td></tr>
     <tr><td>256</td><td>8</td><td>14</td><td>((14+1) * 4) * 4 = 60 * 4 = 240</td></tr>
</table>
* Generally, the encryption/decryption routines use a block count of 16 byte 
* blocks, not a byte length to show the length of data blocks.
*
* The tables and associated processing routines are BYTE REVERSED
* compared to the original RIJNDAEL fast mode reference code.
* This reduces Byte to DWord/DWord to Byte conversion overhead on
* Little Endian machines [INTEL].
*
* On Windows, CPU AES may be used, if available.
*
* Additionally, there are assembler implementations for x86 and x64 
* architectures. They are available in the files aesasm.asm, cpuaes64.asm and
* cpuaes86.asm. They do not provide new functions, they just replace the
* generic C functions equivalently.
*
* The module has no dependencies on other modules.
* @{
* @file
* This file contains the current C implementation of AES.
* @}
*/
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#if (defined _WIN32) & (_MSC_VER < 1700)
#ifndef _STDINT
#define _STDINT
// MSVC lower than 17.00 does not have stdint.h, assure, all needed types are defined

typedef unsigned __int16 uint16_t;

typedef unsigned __int32 uint32_t;

typedef unsigned __int64 uint64_t;

#endif // !_STDINT
#else
#include <stdint.h>
#include <ctype.h>
#endif
#include <stddef.h>
#ifdef _WIN32
#define WIN32_LEAN_AND_MEAN
#include <Windows.h>
#undef WIN32_LEAN_AND_MEAN
#else// Define system-specific HL_* defines here
#ifndef HL_UNIX
#define HL_UNIX

#if (defined __gnu_linux__) || (defined __linux__)
#define HL_LINUX
#endif

#if (defined __APPLE__) && (defined __MACH__)
#define HL_LINUX
#define HL_MACOS
#endif

#ifdef _AIX
#define HL_AIX
#define HL_BIG_ENDIAN
#endif

#ifdef __FreeBSD__
#define HL_FREEBSD
#endif

#if (defined _hpux) || (defined hpux) || (defined __hpux)
#define HL_HPUX
#define HL_BIG_ENDIAN
#endif

#if (defined sun) || (defined __sun)
#define HL_SOLARIS
#endif

#if (defined __arm__) || (defined __aarch64__)
#define HL_LINUX_ARM
#endif

#ifdef __ANDROID__
#define HL_ANDROID
#endif

#endif
#include <hob-unix01.h>
#endif
#ifdef __APPLE__
/* We get target conditionals to keep apart Mac OS, iOS and iOS simulator.
   The conditionals are TARGET_IPHONE_SIMULATOR, TARGET_OS_IPHONE and TARGET_OS_MAC.
   TARGET_IPHONE_SIMULATOR has the highest priority, TARGET_OS_MAC the lowest.
   Always test, if the conditional is 1, as they will be defined as 0, if we 
   are not compiling for the target.
   */
#include <TargetConditionals.h>
#endif

#include "hob-encry-1.h"
#include "hob-encry-intern-1.h"
#include "hob-encry-err-1.h"

//--------------------------------------------------------------
// AES S-Box used for Encryption
//--------------------------------------------------------------
static unsigned char SBox[256] = {
  0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 	// 00-07
  0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76, 	// 08-0F
  0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 	// 10-17
  0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,	// 18-1F
  0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 	// 20-27
  0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15, 	// 28-2F
  0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A,  	// 30-37
  0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75, 	// 38-3F
  0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 	// 40-47
  0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84, 	// 48-4F
  0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 	// 50-57
  0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF, 	// 58-5F
  0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 	// 60-67
  0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8, 	// 68-6F
  0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 	// 70-77
  0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2, 	// 78-7F
  0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 	// 80-87
  0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73, 	// 88-8F
  0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 	// 90-97
  0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB, 	// 98-9F
  0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 	// A0-A7
  0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79, 	// A8-AF
  0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 	// B0-B7
  0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08, 	// B8-BF
  0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 	// C0-C7
  0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A, 	// C8-CF
  0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 	// D0-D7
  0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E, 	// D8-DF
  0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 	// E0-E7
  0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF, 	// E8-EF
  0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 	// F0-F7
  0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16, 	// F8-FF
};
//--------------------------------------------------------------
// AES S-Box used for Decryption
//--------------------------------------------------------------
static unsigned char InvSBox[256] = {
  0x52, 0x09, 0x6A, 0xD5, 0x30, 0x36, 0xA5, 0x38,	// 00-07
  0xBF, 0x40, 0xA3, 0x9E, 0x81, 0xF3, 0xD7, 0xFB, 	// 08-0F
  0x7C, 0xE3, 0x39, 0x82, 0x9B, 0x2F, 0xFF, 0x87, 	// 10-17
  0x34, 0x8E, 0x43, 0x44, 0xC4, 0xDE, 0xE9, 0xCB, 	// 18-1F
  0x54, 0x7B, 0x94, 0x32, 0xA6, 0xC2, 0x23, 0x3D, 	// 20-27
  0xEE, 0x4C, 0x95, 0x0B, 0x42, 0xFA, 0xC3, 0x4E, 	// 28-2F
  0x08, 0x2E, 0xA1, 0x66, 0x28, 0xD9, 0x24, 0xB2, 	// 30-37
  0x76, 0x5B, 0xA2, 0x49, 0x6D, 0x8B, 0xD1, 0x25, 	// 38-3F
  0x72, 0xF8, 0xF6, 0x64, 0x86, 0x68, 0x98, 0x16, 	// 40-47
  0xD4, 0xA4, 0x5C, 0xCC, 0x5D, 0x65, 0xB6, 0x92, 	// 48-4F
  0x6C, 0x70, 0x48, 0x50, 0xFD, 0xED, 0xB9, 0xDA, 	// 50-57
  0x5E, 0x15, 0x46, 0x57, 0xA7, 0x8D, 0x9D, 0x84, 	// 58-5F
  0x90, 0xD8, 0xAB, 0x00, 0x8C, 0xBC, 0xD3, 0x0A, 	// 60-67
  0xF7, 0xE4, 0x58, 0x05, 0xB8, 0xB3, 0x45, 0x06, 	// 68-6F
  0xD0, 0x2C, 0x1E, 0x8F, 0xCA, 0x3F, 0x0F, 0x02, 	// 70-77
  0xC1, 0xAF, 0xBD, 0x03, 0x01, 0x13, 0x8A, 0x6B, 	// 78-7F
  0x3A, 0x91, 0x11, 0x41, 0x4F, 0x67, 0xDC, 0xEA, 	// 80-87
  0x97, 0xF2, 0xCF, 0xCE, 0xF0, 0xB4, 0xE6, 0x73, 	// 88-8F
  0x96, 0xAC, 0x74, 0x22, 0xE7, 0xAD, 0x35, 0x85, 	// 90-97
  0xE2, 0xF9, 0x37, 0xE8, 0x1C, 0x75, 0xDF, 0x6E, 	// 98-9F
  0x47, 0xF1, 0x1A, 0x71, 0x1D, 0x29, 0xC5, 0x89, 	// A0-A7
  0x6F, 0xB7, 0x62, 0x0E, 0xAA, 0x18, 0xBE, 0x1B, 	// A8-AF
  0xFC, 0x56, 0x3E, 0x4B, 0xC6, 0xD2, 0x79, 0x20, 	// B0-B7
  0x9A, 0xDB, 0xC0, 0xFE, 0x78, 0xCD, 0x5A, 0xF4, 	// B8-BF
  0x1F, 0xDD, 0xA8, 0x33, 0x88, 0x07, 0xC7, 0x31, 	// C0-C7
  0xB1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xEC, 0x5F, 	// C8-CF
  0x60, 0x51, 0x7F, 0xA9, 0x19, 0xB5, 0x4A, 0x0D, 	// D0-D7
  0x2D, 0xE5, 0x7A, 0x9F, 0x93, 0xC9, 0x9C, 0xEF, 	// D8-DF
  0xA0, 0xE0, 0x3B, 0x4D, 0xAE, 0x2A, 0xF5, 0xB0, 	// E0-E7
  0xC8, 0xEB, 0xBB, 0x3C, 0x83, 0x53, 0x99, 0x61, 	// E8-EF
  0x17, 0x2B, 0x04, 0x7E, 0xBA, 0x77, 0xD6, 0x26, 	// F0-F7
  0xE1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0C, 0x7D, 	// F8-FF
};
//------------------------------------------------------
// Encryption Table T0
//------------------------------------------------------
unsigned int TabEncT0[256] = {
  0xA56363C6, 0x847C7CF8, 0x997777EE, 0x8D7B7BF6, 	// 00-03
  0x0DF2F2FF, 0xBD6B6BD6, 0xB16F6FDE, 0x54C5C591, 	// 04-07
  0x50303060, 0x03010102, 0xA96767CE, 0x7D2B2B56, 	// 08-0B
  0x19FEFEE7, 0x62D7D7B5, 0xE6ABAB4D, 0x9A7676EC, 	// 0C-0F

  0x45CACA8F, 0x9D82821F, 0x40C9C989, 0x877D7DFA, 	// 10-13
  0x15FAFAEF, 0xEB5959B2, 0xC947478E, 0x0BF0F0FB, 	// 14-17
  0xECADAD41, 0x67D4D4B3, 0xFDA2A25F, 0xEAAFAF45, 	// 18-1B
  0xBF9C9C23, 0xF7A4A453, 0x967272E4, 0x5BC0C09B, 	// 1C-1F

  0xC2B7B775, 0x1CFDFDE1, 0xAE93933D, 0x6A26264C, 	// 20-23
  0x5A36366C, 0x413F3F7E, 0x02F7F7F5, 0x4FCCCC83, 	// 24-27
  0x5C343468, 0xF4A5A551, 0x34E5E5D1, 0x08F1F1F9, 	// 28-2B
  0x937171E2, 0x73D8D8AB, 0x53313162, 0x3F15152A, 	// 2C-2F

  0x0C040408, 0x52C7C795, 0x65232346, 0x5EC3C39D, 	// 30-33
  0x28181830, 0xA1969637, 0x0F05050A, 0xB59A9A2F, 	// 34-37
  0x0907070E, 0x36121224, 0x9B80801B, 0x3DE2E2DF, 	// 38-3B
  0x26EBEBCD, 0x6927274E, 0xCDB2B27F, 0x9F7575EA, 	// 3C-3F

  0x1B090912, 0x9E83831D, 0x742C2C58, 0x2E1A1A34, 	// 40-43
  0x2D1B1B36, 0xB26E6EDC, 0xEE5A5AB4, 0xFBA0A05B, 	// 44-47
  0xF65252A4, 0x4D3B3B76, 0x61D6D6B7, 0xCEB3B37D, 	// 48-4B
  0x7B292952, 0x3EE3E3DD, 0x712F2F5E, 0x97848413, 	// 4C-4F

  0xF55353A6, 0x68D1D1B9, 0x00000000, 0x2CEDEDC1, 	// 50-53
  0x60202040, 0x1FFCFCE3, 0xC8B1B179, 0xED5B5BB6, 	// 54-57
  0xBE6A6AD4, 0x46CBCB8D, 0xD9BEBE67, 0x4B393972, 	// 58-5B
  0xDE4A4A94, 0xD44C4C98, 0xE85858B0, 0x4ACFCF85, 	// 5C-5F

  0x6BD0D0BB, 0x2AEFEFC5, 0xE5AAAA4F, 0x16FBFBED, 	// 60-63
  0xC5434386, 0xD74D4D9A, 0x55333366, 0x94858511, 	// 64-67
  0xCF45458A, 0x10F9F9E9, 0x06020204, 0x817F7FFE, 	// 68-6B
  0xF05050A0, 0x443C3C78, 0xBA9F9F25, 0xE3A8A84B, 	// 6C-6F

  0xF35151A2, 0xFEA3A35D, 0xC0404080, 0x8A8F8F05, 	// 70-73
  0xAD92923F, 0xBC9D9D21, 0x48383870, 0x04F5F5F1, 	// 74-77
  0xDFBCBC63, 0xC1B6B677, 0x75DADAAF, 0x63212142, 	// 78-7B
  0x30101020, 0x1AFFFFE5, 0x0EF3F3FD, 0x6DD2D2BF, 	// 7C-7F

  0x4CCDCD81, 0x140C0C18, 0x35131326, 0x2FECECC3, 	// 80-83
  0xE15F5FBE, 0xA2979735, 0xCC444488, 0x3917172E, 	// 84-87
  0x57C4C493, 0xF2A7A755, 0x827E7EFC, 0x473D3D7A, 	// 88-8B
  0xAC6464C8, 0xE75D5DBA, 0x2B191932, 0x957373E6, 	// 8C-8F

  0xA06060C0, 0x98818119, 0xD14F4F9E, 0x7FDCDCA3, 	// 90-93
  0x66222244, 0x7E2A2A54, 0xAB90903B, 0x8388880B, 	// 94-97
  0xCA46468C, 0x29EEEEC7, 0xD3B8B86B, 0x3C141428, 	// 98-9B
  0x79DEDEA7, 0xE25E5EBC, 0x1D0B0B16, 0x76DBDBAD, 	// 9C-9F

  0x3BE0E0DB, 0x56323264, 0x4E3A3A74, 0x1E0A0A14, 	// A0-A3
  0xDB494992, 0x0A06060C, 0x6C242448, 0xE45C5CB8, 	// A4-A7
  0x5DC2C29F, 0x6ED3D3BD, 0xEFACAC43, 0xA66262C4, 	// A8-AB
  0xA8919139, 0xA4959531, 0x37E4E4D3, 0x8B7979F2, 	// AC-AF

  0x32E7E7D5, 0x43C8C88B, 0x5937376E, 0xB76D6DDA, 	// B0-B3
  0x8C8D8D01, 0x64D5D5B1, 0xD24E4E9C, 0xE0A9A949, 	// B4-B7
  0xB46C6CD8, 0xFA5656AC, 0x07F4F4F3, 0x25EAEACF, 	// B8-BB
  0xAF6565CA, 0x8E7A7AF4, 0xE9AEAE47, 0x18080810, 	// BC-BF

  0xD5BABA6F, 0x887878F0, 0x6F25254A, 0x722E2E5C, 	// C0-C3
  0x241C1C38, 0xF1A6A657, 0xC7B4B473, 0x51C6C697, 	// C4-C7
  0x23E8E8CB, 0x7CDDDDA1, 0x9C7474E8, 0x211F1F3E, 	// C8-CB
  0xDD4B4B96, 0xDCBDBD61, 0x868B8B0D, 0x858A8A0F, 	// CC-CF

  0x907070E0, 0x423E3E7C, 0xC4B5B571, 0xAA6666CC, 	// D0-D3
  0xD8484890, 0x05030306, 0x01F6F6F7, 0x120E0E1C, 	// D4-D7
  0xA36161C2, 0x5F35356A, 0xF95757AE, 0xD0B9B969, 	// D8-DB
  0x91868617, 0x58C1C199, 0x271D1D3A, 0xB99E9E27, 	// DC-DF

  0x38E1E1D9, 0x13F8F8EB, 0xB398982B, 0x33111122, 	// E0-E3
  0xBB6969D2, 0x70D9D9A9, 0x898E8E07, 0xA7949433, 	// E4-E7
  0xB69B9B2D, 0x221E1E3C, 0x92878715, 0x20E9E9C9, 	// E8-EB
  0x49CECE87, 0xFF5555AA, 0x78282850, 0x7ADFDFA5, 	// EC-EF

  0x8F8C8C03, 0xF8A1A159, 0x80898909, 0x170D0D1A, 	// F0-F3
  0xDABFBF65, 0x31E6E6D7, 0xC6424284, 0xB86868D0, 	// F4-F7
  0xC3414182, 0xB0999929, 0x772D2D5A, 0x110F0F1E, 	// F8-FB
  0xCBB0B07B, 0xFC5454A8, 0xD6BBBB6D, 0x3A16162C, 	// FC-FF
};
//------------------------------------------------------
// Encryption Table T1
//------------------------------------------------------
unsigned int TabEncT1[256] = {
  0x6363C6A5, 0x7C7CF884, 0x7777EE99, 0x7B7BF68D, 	// 00-03
  0xF2F2FF0D, 0x6B6BD6BD, 0x6F6FDEB1, 0xC5C59154, 	// 04-07
  0x30306050, 0x01010203, 0x6767CEA9, 0x2B2B567D, 	// 08-0B
  0xFEFEE719, 0xD7D7B562, 0xABAB4DE6, 0x7676EC9A, 	// 0C-0F

  0xCACA8F45, 0x82821F9D, 0xC9C98940, 0x7D7DFA87, 	// 10-13
  0xFAFAEF15, 0x5959B2EB, 0x47478EC9, 0xF0F0FB0B, 	// 14-17
  0xADAD41EC, 0xD4D4B367, 0xA2A25FFD, 0xAFAF45EA, 	// 18-1B
  0x9C9C23BF, 0xA4A453F7, 0x7272E496, 0xC0C09B5B, 	// 1C-1F

  0xB7B775C2, 0xFDFDE11C, 0x93933DAE, 0x26264C6A, 	// 20-23
  0x36366C5A, 0x3F3F7E41, 0xF7F7F502, 0xCCCC834F, 	// 24-27
  0x3434685C, 0xA5A551F4, 0xE5E5D134, 0xF1F1F908, 	// 28-2B
  0x7171E293, 0xD8D8AB73, 0x31316253, 0x15152A3F, 	// 2C-2F

  0x0404080C, 0xC7C79552, 0x23234665, 0xC3C39D5E, 	// 30-33
  0x18183028, 0x969637A1, 0x05050A0F, 0x9A9A2FB5, 	// 34-37
  0x07070E09, 0x12122436, 0x80801B9B, 0xE2E2DF3D, 	// 38-3B
  0xEBEBCD26, 0x27274E69, 0xB2B27FCD, 0x7575EA9F, 	// 3C-3F

  0x0909121B, 0x83831D9E, 0x2C2C5874, 0x1A1A342E, 	// 40-43
  0x1B1B362D, 0x6E6EDCB2, 0x5A5AB4EE, 0xA0A05BFB, 	// 44-47
  0x5252A4F6, 0x3B3B764D, 0xD6D6B761, 0xB3B37DCE, 	// 48-4B
  0x2929527B, 0xE3E3DD3E, 0x2F2F5E71, 0x84841397, 	// 4C-4F

  0x5353A6F5, 0xD1D1B968, 0x00000000, 0xEDEDC12C, 	// 50-53
  0x20204060, 0xFCFCE31F, 0xB1B179C8, 0x5B5BB6ED, 	// 54-57
  0x6A6AD4BE, 0xCBCB8D46, 0xBEBE67D9, 0x3939724B, 	// 58-5B
  0x4A4A94DE, 0x4C4C98D4, 0x5858B0E8, 0xCFCF854A, 	// 5C-5F

  0xD0D0BB6B, 0xEFEFC52A, 0xAAAA4FE5, 0xFBFBED16, 	// 60-63
  0x434386C5, 0x4D4D9AD7, 0x33336655, 0x85851194, 	// 64-67
  0x45458ACF, 0xF9F9E910, 0x02020406, 0x7F7FFE81, 	// 68-6B
  0x5050A0F0, 0x3C3C7844, 0x9F9F25BA, 0xA8A84BE3, 	// 6C-6F

  0x5151A2F3, 0xA3A35DFE, 0x404080C0, 0x8F8F058A, 	// 70-73
  0x92923FAD, 0x9D9D21BC, 0x38387048, 0xF5F5F104, 	// 74-77
  0xBCBC63DF, 0xB6B677C1, 0xDADAAF75, 0x21214263, 	// 78-7B
  0x10102030, 0xFFFFE51A, 0xF3F3FD0E, 0xD2D2BF6D, 	// 7C-7F

  0xCDCD814C, 0x0C0C1814, 0x13132635, 0xECECC32F, 	// 80-83
  0x5F5FBEE1, 0x979735A2, 0x444488CC, 0x17172E39, 	// 84-87
  0xC4C49357, 0xA7A755F2, 0x7E7EFC82, 0x3D3D7A47, 	// 88-8B
  0x6464C8AC, 0x5D5DBAE7, 0x1919322B, 0x7373E695, 	// 8C-8F

  0x6060C0A0, 0x81811998, 0x4F4F9ED1, 0xDCDCA37F, 	// 90-93
  0x22224466, 0x2A2A547E, 0x90903BAB, 0x88880B83, 	// 94-97
  0x46468CCA, 0xEEEEC729, 0xB8B86BD3, 0x1414283C, 	// 98-9B
  0xDEDEA779, 0x5E5EBCE2, 0x0B0B161D, 0xDBDBAD76, 	// 9C-9F

  0xE0E0DB3B, 0x32326456, 0x3A3A744E, 0x0A0A141E, 	// A0-A3
  0x494992DB, 0x06060C0A, 0x2424486C, 0x5C5CB8E4, 	// A4-A7
  0xC2C29F5D, 0xD3D3BD6E, 0xACAC43EF, 0x6262C4A6, 	// A8-AB
  0x919139A8, 0x959531A4, 0xE4E4D337, 0x7979F28B, 	// AC-AF

  0xE7E7D532, 0xC8C88B43, 0x37376E59, 0x6D6DDAB7, 	// B0-B3
  0x8D8D018C, 0xD5D5B164, 0x4E4E9CD2, 0xA9A949E0, 	// B4-B7
  0x6C6CD8B4, 0x5656ACFA, 0xF4F4F307, 0xEAEACF25, 	// B8-BB
  0x6565CAAF, 0x7A7AF48E, 0xAEAE47E9, 0x08081018, 	// BC-BF

  0xBABA6FD5, 0x7878F088, 0x25254A6F, 0x2E2E5C72, 	// C0-C3
  0x1C1C3824, 0xA6A657F1, 0xB4B473C7, 0xC6C69751, 	// C4-C7
  0xE8E8CB23, 0xDDDDA17C, 0x7474E89C, 0x1F1F3E21, 	// C8-CB
  0x4B4B96DD, 0xBDBD61DC, 0x8B8B0D86, 0x8A8A0F85, 	// CC-CF

  0x7070E090, 0x3E3E7C42, 0xB5B571C4, 0x6666CCAA, 	// D0-D3
  0x484890D8, 0x03030605, 0xF6F6F701, 0x0E0E1C12, 	// D4-D7
  0x6161C2A3, 0x35356A5F, 0x5757AEF9, 0xB9B969D0, 	// D8-DB
  0x86861791, 0xC1C19958, 0x1D1D3A27, 0x9E9E27B9, 	// DC-DF

  0xE1E1D938, 0xF8F8EB13, 0x98982BB3, 0x11112233, 	// E0-E3
  0x6969D2BB, 0xD9D9A970, 0x8E8E0789, 0x949433A7, 	// E4-E7
  0x9B9B2DB6, 0x1E1E3C22, 0x87871592, 0xE9E9C920, 	// E8-EB
  0xCECE8749, 0x5555AAFF, 0x28285078, 0xDFDFA57A, 	// EC-EF

  0x8C8C038F, 0xA1A159F8, 0x89890980, 0x0D0D1A17, 	// F0-F3
  0xBFBF65DA, 0xE6E6D731, 0x424284C6, 0x6868D0B8, 	// F4-F7
  0x414182C3, 0x999929B0, 0x2D2D5A77, 0x0F0F1E11, 	// F8-FB
  0xB0B07BCB, 0x5454A8FC, 0xBBBB6DD6, 0x16162C3A, 	// FC-FF
};
//------------------------------------------------------
// Encryption Table T2
//------------------------------------------------------
unsigned int TabEncT2[256] = {
  0x63C6A563, 0x7CF8847C, 0x77EE9977, 0x7BF68D7B, 	// 00-03
  0xF2FF0DF2, 0x6BD6BD6B, 0x6FDEB16F, 0xC59154C5, 	// 04-07
  0x30605030, 0x01020301, 0x67CEA967, 0x2B567D2B, 	// 08-0B
  0xFEE719FE, 0xD7B562D7, 0xAB4DE6AB, 0x76EC9A76, 	// 0C-0F

  0xCA8F45CA, 0x821F9D82, 0xC98940C9, 0x7DFA877D, 	// 10-13
  0xFAEF15FA, 0x59B2EB59, 0x478EC947, 0xF0FB0BF0, 	// 14-17
  0xAD41ECAD, 0xD4B367D4, 0xA25FFDA2, 0xAF45EAAF, 	// 18-1B
  0x9C23BF9C, 0xA453F7A4, 0x72E49672, 0xC09B5BC0, 	// 1C-1F

  0xB775C2B7, 0xFDE11CFD, 0x933DAE93, 0x264C6A26, 	// 20-23
  0x366C5A36, 0x3F7E413F, 0xF7F502F7, 0xCC834FCC, 	// 24-27
  0x34685C34, 0xA551F4A5, 0xE5D134E5, 0xF1F908F1, 	// 28-2B
  0x71E29371, 0xD8AB73D8, 0x31625331, 0x152A3F15, 	// 2C-2F

  0x04080C04, 0xC79552C7, 0x23466523, 0xC39D5EC3, 	// 30-33
  0x18302818, 0x9637A196, 0x050A0F05, 0x9A2FB59A, 	// 34-37
  0x070E0907, 0x12243612, 0x801B9B80, 0xE2DF3DE2, 	// 38-3B
  0xEBCD26EB, 0x274E6927, 0xB27FCDB2, 0x75EA9F75, 	// 3C-3F

  0x09121B09, 0x831D9E83, 0x2C58742C, 0x1A342E1A, 	// 40-43
  0x1B362D1B, 0x6EDCB26E, 0x5AB4EE5A, 0xA05BFBA0, 	// 44-47
  0x52A4F652, 0x3B764D3B, 0xD6B761D6, 0xB37DCEB3, 	// 48-4B
  0x29527B29, 0xE3DD3EE3, 0x2F5E712F, 0x84139784, 	// 4C-4F

  0x53A6F553, 0xD1B968D1, 0x00000000, 0xEDC12CED, 	// 50-53
  0x20406020, 0xFCE31FFC, 0xB179C8B1, 0x5BB6ED5B, 	// 54-57
  0x6AD4BE6A, 0xCB8D46CB, 0xBE67D9BE, 0x39724B39, 	// 58-5B
  0x4A94DE4A, 0x4C98D44C, 0x58B0E858, 0xCF854ACF, 	// 5C-5F

  0xD0BB6BD0, 0xEFC52AEF, 0xAA4FE5AA, 0xFBED16FB, 	// 60-63
  0x4386C543, 0x4D9AD74D, 0x33665533, 0x85119485, 	// 64-67
  0x458ACF45, 0xF9E910F9, 0x02040602, 0x7FFE817F, 	// 68-6B
  0x50A0F050, 0x3C78443C, 0x9F25BA9F, 0xA84BE3A8, 	// 6C-6F

  0x51A2F351, 0xA35DFEA3, 0x4080C040, 0x8F058A8F, 	// 70-73
  0x923FAD92, 0x9D21BC9D, 0x38704838, 0xF5F104F5, 	// 74-77
  0xBC63DFBC, 0xB677C1B6, 0xDAAF75DA, 0x21426321, 	// 78-7B
  0x10203010, 0xFFE51AFF, 0xF3FD0EF3, 0xD2BF6DD2, 	// 7C-7F

  0xCD814CCD, 0x0C18140C, 0x13263513, 0xECC32FEC, 	// 80-83
  0x5FBEE15F, 0x9735A297, 0x4488CC44, 0x172E3917, 	// 84-87
  0xC49357C4, 0xA755F2A7, 0x7EFC827E, 0x3D7A473D, 	// 88-8B
  0x64C8AC64, 0x5DBAE75D, 0x19322B19, 0x73E69573, 	// 8C-8F

  0x60C0A060, 0x81199881, 0x4F9ED14F, 0xDCA37FDC, 	// 90-93
  0x22446622, 0x2A547E2A, 0x903BAB90, 0x880B8388, 	// 94-97
  0x468CCA46, 0xEEC729EE, 0xB86BD3B8, 0x14283C14, 	// 98-9B
  0xDEA779DE, 0x5EBCE25E, 0x0B161D0B, 0xDBAD76DB, 	// 9C-9F

  0xE0DB3BE0, 0x32645632, 0x3A744E3A, 0x0A141E0A, 	// A0-A3
  0x4992DB49, 0x060C0A06, 0x24486C24, 0x5CB8E45C, 	// A4-A7
  0xC29F5DC2, 0xD3BD6ED3, 0xAC43EFAC, 0x62C4A662, 	// A8-AB
  0x9139A891, 0x9531A495, 0xE4D337E4, 0x79F28B79, 	// AC-AF

  0xE7D532E7, 0xC88B43C8, 0x376E5937, 0x6DDAB76D, 	// B0-B3
  0x8D018C8D, 0xD5B164D5, 0x4E9CD24E, 0xA949E0A9, 	// B4-B7
  0x6CD8B46C, 0x56ACFA56, 0xF4F307F4, 0xEACF25EA, 	// B8-BB
  0x65CAAF65, 0x7AF48E7A, 0xAE47E9AE, 0x08101808, 	// BC-BF

  0xBA6FD5BA, 0x78F08878, 0x254A6F25, 0x2E5C722E, 	// C0-C3
  0x1C38241C, 0xA657F1A6, 0xB473C7B4, 0xC69751C6, 	// C4-C7
  0xE8CB23E8, 0xDDA17CDD, 0x74E89C74, 0x1F3E211F, 	// C8-CB
  0x4B96DD4B, 0xBD61DCBD, 0x8B0D868B, 0x8A0F858A, 	// CC-CF

  0x70E09070, 0x3E7C423E, 0xB571C4B5, 0x66CCAA66, 	// D0-D3
  0x4890D848, 0x03060503, 0xF6F701F6, 0x0E1C120E, 	// D4-D7
  0x61C2A361, 0x356A5F35, 0x57AEF957, 0xB969D0B9, 	// D8-DB
  0x86179186, 0xC19958C1, 0x1D3A271D, 0x9E27B99E, 	// DC-DF

  0xE1D938E1, 0xF8EB13F8, 0x982BB398, 0x11223311, 	// E0-E3
  0x69D2BB69, 0xD9A970D9, 0x8E07898E, 0x9433A794, 	// E4-E7
  0x9B2DB69B, 0x1E3C221E, 0x87159287, 0xE9C920E9, 	// E8-EB
  0xCE8749CE, 0x55AAFF55, 0x28507828, 0xDFA57ADF, 	// EC-EF

  0x8C038F8C, 0xA159F8A1, 0x89098089, 0x0D1A170D, 	// F0-F3
  0xBF65DABF, 0xE6D731E6, 0x4284C642, 0x68D0B868, 	// F4-F7
  0x4182C341, 0x9929B099, 0x2D5A772D, 0x0F1E110F, 	// F8-FB
  0xB07BCBB0, 0x54A8FC54, 0xBB6DD6BB, 0x162C3A16, 	// FC-FF
};
//------------------------------------------------------
// Encryption Table T3
//------------------------------------------------------
unsigned int TabEncT3[256] = {
  0xC6A56363, 0xF8847C7C, 0xEE997777, 0xF68D7B7B, 	// 00-03
  0xFF0DF2F2, 0xD6BD6B6B, 0xDEB16F6F, 0x9154C5C5, 	// 04-07
  0x60503030, 0x02030101, 0xCEA96767, 0x567D2B2B, 	// 08-0B
  0xE719FEFE, 0xB562D7D7, 0x4DE6ABAB, 0xEC9A7676, 	// 0C-0F

  0x8F45CACA, 0x1F9D8282, 0x8940C9C9, 0xFA877D7D, 	// 10-13
  0xEF15FAFA, 0xB2EB5959, 0x8EC94747, 0xFB0BF0F0, 	// 14-17
  0x41ECADAD, 0xB367D4D4, 0x5FFDA2A2, 0x45EAAFAF, 	// 18-1B
  0x23BF9C9C, 0x53F7A4A4, 0xE4967272, 0x9B5BC0C0, 	// 1C-1F

  0x75C2B7B7, 0xE11CFDFD, 0x3DAE9393, 0x4C6A2626, 	// 20-23
  0x6C5A3636, 0x7E413F3F, 0xF502F7F7, 0x834FCCCC, 	// 24-27
  0x685C3434, 0x51F4A5A5, 0xD134E5E5, 0xF908F1F1, 	// 28-2B
  0xE2937171, 0xAB73D8D8, 0x62533131, 0x2A3F1515, 	// 2C-2F

  0x080C0404, 0x9552C7C7, 0x46652323, 0x9D5EC3C3, 	// 30-33
  0x30281818, 0x37A19696, 0x0A0F0505, 0x2FB59A9A, 	// 34-37
  0x0E090707, 0x24361212, 0x1B9B8080, 0xDF3DE2E2, 	// 38-3B
  0xCD26EBEB, 0x4E692727, 0x7FCDB2B2, 0xEA9F7575, 	// 3C-3F

  0x121B0909, 0x1D9E8383, 0x58742C2C, 0x342E1A1A, 	// 40-43
  0x362D1B1B, 0xDCB26E6E, 0xB4EE5A5A, 0x5BFBA0A0, 	// 44-47
  0xA4F65252, 0x764D3B3B, 0xB761D6D6, 0x7DCEB3B3, 	// 48-4B
  0x527B2929, 0xDD3EE3E3, 0x5E712F2F, 0x13978484, 	// 4C-4F

  0xA6F55353, 0xB968D1D1, 0x00000000, 0xC12CEDED, 	// 50-53
  0x40602020, 0xE31FFCFC, 0x79C8B1B1, 0xB6ED5B5B, 	// 54-57
  0xD4BE6A6A, 0x8D46CBCB, 0x67D9BEBE, 0x724B3939, 	// 58-5B
  0x94DE4A4A, 0x98D44C4C, 0xB0E85858, 0x854ACFCF, 	// 5C-5F

  0xBB6BD0D0, 0xC52AEFEF, 0x4FE5AAAA, 0xED16FBFB, 	// 60-63
  0x86C54343, 0x9AD74D4D, 0x66553333, 0x11948585, 	// 64-67
  0x8ACF4545, 0xE910F9F9, 0x04060202, 0xFE817F7F, 	// 68-6B
  0xA0F05050, 0x78443C3C, 0x25BA9F9F, 0x4BE3A8A8, 	// 6C-6F

  0xA2F35151, 0x5DFEA3A3, 0x80C04040, 0x058A8F8F, 	// 70-73
  0x3FAD9292, 0x21BC9D9D, 0x70483838, 0xF104F5F5, 	// 74-77
  0x63DFBCBC, 0x77C1B6B6, 0xAF75DADA, 0x42632121, 	// 78-7B
  0x20301010, 0xE51AFFFF, 0xFD0EF3F3, 0xBF6DD2D2, 	// 7C-7F

  0x814CCDCD, 0x18140C0C, 0x26351313, 0xC32FECEC, 	// 80-83
  0xBEE15F5F, 0x35A29797, 0x88CC4444, 0x2E391717, 	// 84-87
  0x9357C4C4, 0x55F2A7A7, 0xFC827E7E, 0x7A473D3D, 	// 88-8B
  0xC8AC6464, 0xBAE75D5D, 0x322B1919, 0xE6957373, 	// 8C-8F

  0xC0A06060, 0x19988181, 0x9ED14F4F, 0xA37FDCDC, 	// 90-93
  0x44662222, 0x547E2A2A, 0x3BAB9090, 0x0B838888, 	// 94-97
  0x8CCA4646, 0xC729EEEE, 0x6BD3B8B8, 0x283C1414, 	// 98-9B
  0xA779DEDE, 0xBCE25E5E, 0x161D0B0B, 0xAD76DBDB, 	// 9C-9F

  0xDB3BE0E0, 0x64563232, 0x744E3A3A, 0x141E0A0A, 	// A0-A3
  0x92DB4949, 0x0C0A0606, 0x486C2424, 0xB8E45C5C, 	// A4-A7
  0x9F5DC2C2, 0xBD6ED3D3, 0x43EFACAC, 0xC4A66262, 	// A8-AB
  0x39A89191, 0x31A49595, 0xD337E4E4, 0xF28B7979, 	// AC-AF

  0xD532E7E7, 0x8B43C8C8, 0x6E593737, 0xDAB76D6D, 	// B0-B3
  0x018C8D8D, 0xB164D5D5, 0x9CD24E4E, 0x49E0A9A9, 	// B4-B7
  0xD8B46C6C, 0xACFA5656, 0xF307F4F4, 0xCF25EAEA, 	// B8-BB
  0xCAAF6565, 0xF48E7A7A, 0x47E9AEAE, 0x10180808, 	// BC-BF

  0x6FD5BABA, 0xF0887878, 0x4A6F2525, 0x5C722E2E, 	// C0-C3
  0x38241C1C, 0x57F1A6A6, 0x73C7B4B4, 0x9751C6C6, 	// C4-C7
  0xCB23E8E8, 0xA17CDDDD, 0xE89C7474, 0x3E211F1F, 	// C8-CB
  0x96DD4B4B, 0x61DCBDBD, 0x0D868B8B, 0x0F858A8A, 	// CC-CF

  0xE0907070, 0x7C423E3E, 0x71C4B5B5, 0xCCAA6666, 	// D0-D3
  0x90D84848, 0x06050303, 0xF701F6F6, 0x1C120E0E, 	// D4-D7
  0xC2A36161, 0x6A5F3535, 0xAEF95757, 0x69D0B9B9, 	// D8-DB
  0x17918686, 0x9958C1C1, 0x3A271D1D, 0x27B99E9E, 	// DC-DF

  0xD938E1E1, 0xEB13F8F8, 0x2BB39898, 0x22331111, 	// E0-E3
  0xD2BB6969, 0xA970D9D9, 0x07898E8E, 0x33A79494, 	// E4-E7
  0x2DB69B9B, 0x3C221E1E, 0x15928787, 0xC920E9E9, 	// E8-EB
  0x8749CECE, 0xAAFF5555, 0x50782828, 0xA57ADFDF, 	// EC-EF

  0x038F8C8C, 0x59F8A1A1, 0x09808989, 0x1A170D0D, 	// F0-F3
  0x65DABFBF, 0xD731E6E6, 0x84C64242, 0xD0B86868, 	// F4-F7
  0x82C34141, 0x29B09999, 0x5A772D2D, 0x1E110F0F, 	// F8-FB
  0x7BCBB0B0, 0xA8FC5454, 0x6DD6BBBB, 0x2C3A1616, 	// FC-FF
};
//------------------------------------------------------
// Decryption Table T0
//------------------------------------------------------
unsigned int TabDecT0[256] = {
  0x50A7F451, 0x5365417E, 0xC3A4171A, 0x965E273A, 	// 00-03
  0xCB6BAB3B, 0xF1459D1F, 0xAB58FAAC, 0x9303E34B, 	// 04-07
  0x55FA3020, 0xF66D76AD, 0x9176CC88, 0x254C02F5, 	// 08-0B
  0xFCD7E54F, 0xD7CB2AC5, 0x80443526, 0x8FA362B5, 	// 0C-0F

  0x495AB1DE, 0x671BBA25, 0x980EEA45, 0xE1C0FE5D, 	// 10-13
  0x02752FC3, 0x12F04C81, 0xA397468D, 0xC6F9D36B, 	// 14-17
  0xE75F8F03, 0x959C9215, 0xEB7A6DBF, 0xDA595295, 	// 18-1B
  0x2D83BED4, 0xD3217458, 0x2969E049, 0x44C8C98E, 	// 1C-1F

  0x6A89C275, 0x78798EF4, 0x6B3E5899, 0xDD71B927, 	// 20-23
  0xB64FE1BE, 0x17AD88F0, 0x66AC20C9, 0xB43ACE7D, 	// 24-27
  0x184ADF63, 0x82311AE5, 0x60335197, 0x457F5362, 	// 28-2B
  0xE07764B1, 0x84AE6BBB, 0x1CA081FE, 0x942B08F9, 	// 2C-2F

  0x58684870, 0x19FD458F, 0x876CDE94, 0xB7F87B52, 	// 30-33
  0x23D373AB, 0xE2024B72, 0x578F1FE3, 0x2AAB5566, 	// 34-37
  0x0728EBB2, 0x03C2B52F, 0x9A7BC586, 0xA50837D3, 	// 38-3B
  0xF2872830, 0xB2A5BF23, 0xBA6A0302, 0x5C8216ED, 	// 3C-3F

  0x2B1CCF8A, 0x92B479A7, 0xF0F207F3, 0xA1E2694E, 	// 40-43
  0xCDF4DA65, 0xD5BE0506, 0x1F6234D1, 0x8AFEA6C4, 	// 44-47
  0x9D532E34, 0xA055F3A2, 0x32E18A05, 0x75EBF6A4, 	// 48-4B
  0x39EC830B, 0xAAEF6040, 0x069F715E, 0x51106EBD, 	// 4C-4F

  0xF98A213E, 0x3D06DD96, 0xAE053EDD, 0x46BDE64D, 	// 50-53
  0xB58D5491, 0x055DC471, 0x6FD40604, 0xFF155060, 	// 54-57
  0x24FB9819, 0x97E9BDD6, 0xCC434089, 0x779ED967, 	// 58-5B
  0xBD42E8B0, 0x888B8907, 0x385B19E7, 0xDBEEC879, 	// 5C-5F

  0x470A7CA1, 0xE90F427C, 0xC91E84F8, 0x00000000, 	// 60-63
  0x83868009, 0x48ED2B32, 0xAC70111E, 0x4E725A6C, 	// 64-67
  0xFBFF0EFD, 0x5638850F, 0x1ED5AE3D, 0x27392D36, 	// 68-6B
  0x64D90F0A, 0x21A65C68, 0xD1545B9B, 0x3A2E3624, 	// 6C-6F

  0xB1670A0C, 0x0FE75793, 0xD296EEB4, 0x9E919B1B, 	// 70-73
  0x4FC5C080, 0xA220DC61, 0x694B775A, 0x161A121C, 	// 74-77
  0x0ABA93E2, 0xE52AA0C0, 0x43E0223C, 0x1D171B12, 	// 78-7B
  0x0B0D090E, 0xADC78BF2, 0xB9A8B62D, 0xC8A91E14, 	// 7C-7F

  0x8519F157, 0x4C0775AF, 0xBBDD99EE, 0xFD607FA3, 	// 80-83
  0x9F2601F7, 0xBCF5725C, 0xC53B6644, 0x347EFB5B, 	// 84-87
  0x7629438B, 0xDCC623CB, 0x68FCEDB6, 0x63F1E4B8, 	// 88-8B
  0xCADC31D7, 0x10856342, 0x40229713, 0x2011C684, 	// 8C-8F

  0x7D244A85, 0xF83DBBD2, 0x1132F9AE, 0x6DA129C7, 	// 90-93
  0x4B2F9E1D, 0xF330B2DC, 0xEC52860D, 0xD0E3C177, 	// 94-97
  0x6C16B32B, 0x99B970A9, 0xFA489411, 0x2264E947, 	// 98-9B
  0xC48CFCA8, 0x1A3FF0A0, 0xD82C7D56, 0xEF903322, 	// 9C-9F

  0xC74E4987, 0xC1D138D9, 0xFEA2CA8C, 0x360BD498, 	// A0-A3
  0xCF81F5A6, 0x28DE7AA5, 0x268EB7DA, 0xA4BFAD3F, 	// A4-A7
  0xE49D3A2C, 0x0D927850, 0x9BCC5F6A, 0x62467E54, 	// A8-AB
  0xC2138DF6, 0xE8B8D890, 0x5EF7392E, 0xF5AFC382, 	// AC-AF

  0xBE805D9F, 0x7C93D069, 0xA92DD56F, 0xB31225CF, 	// B0-B3
  0x3B99ACC8, 0xA77D1810, 0x6E639CE8, 0x7BBB3BDB, 	// B4-B7
  0x097826CD, 0xF418596E, 0x01B79AEC, 0xA89A4F83, 	// B8-BB
  0x656E95E6, 0x7EE6FFAA, 0x08CFBC21, 0xE6E815EF, 	// BC-BF

  0xD99BE7BA, 0xCE366F4A, 0xD4099FEA, 0xD67CB029, 	// C0-C3
  0xAFB2A431, 0x31233F2A, 0x3094A5C6, 0xC066A235, 	// C4-C7
  0x37BC4E74, 0xA6CA82FC, 0xB0D090E0, 0x15D8A733, 	// C8-CB
  0x4A9804F1, 0xF7DAEC41, 0x0E50CD7F, 0x2FF69117, 	// CC-CF

  0x8DD64D76, 0x4DB0EF43, 0x544DAACC, 0xDF0496E4, 	// D0-D3
  0xE3B5D19E, 0x1B886A4C, 0xB81F2CC1, 0x7F516546, 	// D4-D7
  0x04EA5E9D, 0x5D358C01, 0x737487FA, 0x2E410BFB, 	// D8-DB
  0x5A1D67B3, 0x52D2DB92, 0x335610E9, 0x1347D66D, 	// DC-DF

  0x8C61D79A, 0x7A0CA137, 0x8E14F859, 0x893C13EB, 	// E0-E3
  0xEE27A9CE, 0x35C961B7, 0xEDE51CE1, 0x3CB1477A, 	// E4-E7
  0x59DFD29C, 0x3F73F255, 0x79CE1418, 0xBF37C773, 	// E8-EB
  0xEACDF753, 0x5BAAFD5F, 0x146F3DDF, 0x86DB4478, 	// EC-EF

  0x81F3AFCA, 0x3EC468B9, 0x2C342438, 0x5F40A3C2, 	// F0-F3
  0x72C31D16, 0x0C25E2BC, 0x8B493C28, 0x41950DFF, 	// F4-F7
  0x7101A839, 0xDEB30C08, 0x9CE4B4D8, 0x90C15664, 	// F8-FB
  0x6184CB7B, 0x70B632D5, 0x745C6C48, 0x4257B8D0, 	// FC-FF
};
//------------------------------------------------------
// Decryption Table T1
//------------------------------------------------------
unsigned int TabDecT1[256] = {
  0xA7F45150, 0x65417E53, 0xA4171AC3, 0x5E273A96, 	// 00-03
  0x6BAB3BCB, 0x459D1FF1, 0x58FAACAB, 0x03E34B93, 	// 04-07
  0xFA302055, 0x6D76ADF6, 0x76CC8891, 0x4C02F525, 	// 08-0B
  0xD7E54FFC, 0xCB2AC5D7, 0x44352680, 0xA362B58F, 	// 0C-0F

  0x5AB1DE49, 0x1BBA2567, 0x0EEA4598, 0xC0FE5DE1, 	// 10-13
  0x752FC302, 0xF04C8112, 0x97468DA3, 0xF9D36BC6, 	// 14-17
  0x5F8F03E7, 0x9C921595, 0x7A6DBFEB, 0x595295DA, 	// 18-1B
  0x83BED42D, 0x217458D3, 0x69E04929, 0xC8C98E44, 	// 1C-1F

  0x89C2756A, 0x798EF478, 0x3E58996B, 0x71B927DD, 	// 20-23
  0x4FE1BEB6, 0xAD88F017, 0xAC20C966, 0x3ACE7DB4, 	// 24-27
  0x4ADF6318, 0x311AE582, 0x33519760, 0x7F536245, 	// 28-2B
  0x7764B1E0, 0xAE6BBB84, 0xA081FE1C, 0x2B08F994, 	// 2C-2F

  0x68487058, 0xFD458F19, 0x6CDE9487, 0xF87B52B7, 	// 30-33
  0xD373AB23, 0x024B72E2, 0x8F1FE357, 0xAB55662A, 	// 34-37
  0x28EBB207, 0xC2B52F03, 0x7BC5869A, 0x0837D3A5, 	// 38-3B
  0x872830F2, 0xA5BF23B2, 0x6A0302BA, 0x8216ED5C, 	// 3C-3F

  0x1CCF8A2B, 0xB479A792, 0xF207F3F0, 0xE2694EA1, 	// 40-43
  0xF4DA65CD, 0xBE0506D5, 0x6234D11F, 0xFEA6C48A, 	// 44-47
  0x532E349D, 0x55F3A2A0, 0xE18A0532, 0xEBF6A475, 	// 48-4B
  0xEC830B39, 0xEF6040AA, 0x9F715E06, 0x106EBD51, 	// 4C-4F

  0x8A213EF9, 0x06DD963D, 0x053EDDAE, 0xBDE64D46, 	// 50-53
  0x8D5491B5, 0x5DC47105, 0xD406046F, 0x155060FF, 	// 54-57
  0xFB981924, 0xE9BDD697, 0x434089CC, 0x9ED96777, 	// 58-5B
  0x42E8B0BD, 0x8B890788, 0x5B19E738, 0xEEC879DB, 	// 5C-5F

  0x0A7CA147, 0x0F427CE9, 0x1E84F8C9, 0x00000000, 	// 60-63
  0x86800983, 0xED2B3248, 0x70111EAC, 0x725A6C4E, 	// 64-67
  0xFF0EFDFB, 0x38850F56, 0xD5AE3D1E, 0x392D3627, 	// 68-6B
  0xD90F0A64, 0xA65C6821, 0x545B9BD1, 0x2E36243A, 	// 6C-6F

  0x670A0CB1, 0xE757930F, 0x96EEB4D2, 0x919B1B9E, 	// 70-73
  0xC5C0804F, 0x20DC61A2, 0x4B775A69, 0x1A121C16, 	// 74-77
  0xBA93E20A, 0x2AA0C0E5, 0xE0223C43, 0x171B121D, 	// 78-7B
  0x0D090E0B, 0xC78BF2AD, 0xA8B62DB9, 0xA91E14C8, 	// 7C-7F

  0x19F15785, 0x0775AF4C, 0xDD99EEBB, 0x607FA3FD, 	// 80-83
  0x2601F79F, 0xF5725CBC, 0x3B6644C5, 0x7EFB5B34, 	// 84-87
  0x29438B76, 0xC623CBDC, 0xFCEDB668, 0xF1E4B863, 	// 88-8B
  0xDC31D7CA, 0x85634210, 0x22971340, 0x11C68420, 	// 8C-8F

  0x244A857D, 0x3DBBD2F8, 0x32F9AE11, 0xA129C76D, 	// 90-93
  0x2F9E1D4B, 0x30B2DCF3, 0x52860DEC, 0xE3C177D0, 	// 94-97
  0x16B32B6C, 0xB970A999, 0x489411FA, 0x64E94722, 	// 98-9B
  0x8CFCA8C4, 0x3FF0A01A, 0x2C7D56D8, 0x903322EF, 	// 9C-9F

  0x4E4987C7, 0xD138D9C1, 0xA2CA8CFE, 0x0BD49836, 	// A0-A3
  0x81F5A6CF, 0xDE7AA528, 0x8EB7DA26, 0xBFAD3FA4, 	// A4-A7
  0x9D3A2CE4, 0x9278500D, 0xCC5F6A9B, 0x467E5462, 	// A8-AB
  0x138DF6C2, 0xB8D890E8, 0xF7392E5E, 0xAFC382F5, 	// AC-AF

  0x805D9FBE, 0x93D0697C, 0x2DD56FA9, 0x1225CFB3, 	// B0-B3
  0x99ACC83B, 0x7D1810A7, 0x639CE86E, 0xBB3BDB7B, 	// B4-B7
  0x7826CD09, 0x18596EF4, 0xB79AEC01, 0x9A4F83A8, 	// B8-BB
  0x6E95E665, 0xE6FFAA7E, 0xCFBC2108, 0xE815EFE6, 	// BC-BF

  0x9BE7BAD9, 0x366F4ACE, 0x099FEAD4, 0x7CB029D6, 	// C0-C3
  0xB2A431AF, 0x233F2A31, 0x94A5C630, 0x66A235C0, 	// C4-C7
  0xBC4E7437, 0xCA82FCA6, 0xD090E0B0, 0xD8A73315, 	// C8-CB
  0x9804F14A, 0xDAEC41F7, 0x50CD7F0E, 0xF691172F, 	// CC-CF

  0xD64D768D, 0xB0EF434D, 0x4DAACC54, 0x0496E4DF, 	// D0-D3
  0xB5D19EE3, 0x886A4C1B, 0x1F2CC1B8, 0x5165467F, 	// D4-D7
  0xEA5E9D04, 0x358C015D, 0x7487FA73, 0x410BFB2E, 	// D8-DB
  0x1D67B35A, 0xD2DB9252, 0x5610E933, 0x47D66D13, 	// DC-DF

  0x61D79A8C, 0x0CA1377A, 0x14F8598E, 0x3C13EB89, 	// E0-E3
  0x27A9CEEE, 0xC961B735, 0xE51CE1ED, 0xB1477A3C, 	// E4-E7
  0xDFD29C59, 0x73F2553F, 0xCE141879, 0x37C773BF, 	// E8-EB
  0xCDF753EA, 0xAAFD5F5B, 0x6F3DDF14, 0xDB447886, 	// EC-EF

  0xF3AFCA81, 0xC468B93E, 0x3424382C, 0x40A3C25F, 	// F0-F3
  0xC31D1672, 0x25E2BC0C, 0x493C288B, 0x950DFF41, 	// F4-F7
  0x01A83971, 0xB30C08DE, 0xE4B4D89C, 0xC1566490, 	// F8-FB
  0x84CB7B61, 0xB632D570, 0x5C6C4874, 0x57B8D042, 	// FC-FF
};
//------------------------------------------------------
// Decryption Table T2
//------------------------------------------------------
unsigned int TabDecT2[256] = {
  0xF45150A7, 0x417E5365, 0x171AC3A4, 0x273A965E, 	// 00-03
  0xAB3BCB6B, 0x9D1FF145, 0xFAACAB58, 0xE34B9303, 	// 04-07
  0x302055FA, 0x76ADF66D, 0xCC889176, 0x02F5254C, 	// 08-0B
  0xE54FFCD7, 0x2AC5D7CB, 0x35268044, 0x62B58FA3, 	// 0C-0F

  0xB1DE495A, 0xBA25671B, 0xEA45980E, 0xFE5DE1C0, 	// 10-13
  0x2FC30275, 0x4C8112F0, 0x468DA397, 0xD36BC6F9, 	// 14-17
  0x8F03E75F, 0x9215959C, 0x6DBFEB7A, 0x5295DA59, 	// 18-1B
  0xBED42D83, 0x7458D321, 0xE0492969, 0xC98E44C8, 	// 1C-1F

  0xC2756A89, 0x8EF47879, 0x58996B3E, 0xB927DD71, 	// 20-23
  0xE1BEB64F, 0x88F017AD, 0x20C966AC, 0xCE7DB43A, 	// 24-27
  0xDF63184A, 0x1AE58231, 0x51976033, 0x5362457F, 	// 28-2B
  0x64B1E077, 0x6BBB84AE, 0x81FE1CA0, 0x08F9942B, 	// 2C-2F

  0x48705868, 0x458F19FD, 0xDE94876C, 0x7B52B7F8, 	// 30-33
  0x73AB23D3, 0x4B72E202, 0x1FE3578F, 0x55662AAB, 	// 34-37
  0xEBB20728, 0xB52F03C2, 0xC5869A7B, 0x37D3A508, 	// 38-3B
  0x2830F287, 0xBF23B2A5, 0x0302BA6A, 0x16ED5C82, 	// 3C-3F

  0xCF8A2B1C, 0x79A792B4, 0x07F3F0F2, 0x694EA1E2, 	// 40-43
  0xDA65CDF4, 0x0506D5BE, 0x34D11F62, 0xA6C48AFE, 	// 44-47
  0x2E349D53, 0xF3A2A055, 0x8A0532E1, 0xF6A475EB, 	// 48-4B
  0x830B39EC, 0x6040AAEF, 0x715E069F, 0x6EBD5110, 	// 4C-4F

  0x213EF98A, 0xDD963D06, 0x3EDDAE05, 0xE64D46BD, 	// 50-53
  0x5491B58D, 0xC471055D, 0x06046FD4, 0x5060FF15, 	// 54-57
  0x981924FB, 0xBDD697E9, 0x4089CC43, 0xD967779E, 	// 58-5B
  0xE8B0BD42, 0x8907888B, 0x19E7385B, 0xC879DBEE, 	// 5C-5F

  0x7CA1470A, 0x427CE90F, 0x84F8C91E, 0x00000000, 	// 60-63
  0x80098386, 0x2B3248ED, 0x111EAC70, 0x5A6C4E72, 	// 64-67
  0x0EFDFBFF, 0x850F5638, 0xAE3D1ED5, 0x2D362739, 	// 68-6B
  0x0F0A64D9, 0x5C6821A6, 0x5B9BD154, 0x36243A2E, 	// 6C-6F

  0x0A0CB167, 0x57930FE7, 0xEEB4D296, 0x9B1B9E91, 	// 70-73
  0xC0804FC5, 0xDC61A220, 0x775A694B, 0x121C161A, 	// 74-77
  0x93E20ABA, 0xA0C0E52A, 0x223C43E0, 0x1B121D17, 	// 78-7B
  0x090E0B0D, 0x8BF2ADC7, 0xB62DB9A8, 0x1E14C8A9, 	// 7C-7F

  0xF1578519, 0x75AF4C07, 0x99EEBBDD, 0x7FA3FD60, 	// 80-83
  0x01F79F26, 0x725CBCF5, 0x6644C53B, 0xFB5B347E, 	// 84-87
  0x438B7629, 0x23CBDCC6, 0xEDB668FC, 0xE4B863F1, 	// 88-8B
  0x31D7CADC, 0x63421085, 0x97134022, 0xC6842011, 	// 8C-8F

  0x4A857D24, 0xBBD2F83D, 0xF9AE1132, 0x29C76DA1, 	// 90-93
  0x9E1D4B2F, 0xB2DCF330, 0x860DEC52, 0xC177D0E3, 	// 94-97
  0xB32B6C16, 0x70A999B9, 0x9411FA48, 0xE9472264, 	// 98-9B
  0xFCA8C48C, 0xF0A01A3F, 0x7D56D82C, 0x3322EF90, 	// 9C-9F

  0x4987C74E, 0x38D9C1D1, 0xCA8CFEA2, 0xD498360B, 	// A0-A3
  0xF5A6CF81, 0x7AA528DE, 0xB7DA268E, 0xAD3FA4BF, 	// A4-A7
  0x3A2CE49D, 0x78500D92, 0x5F6A9BCC, 0x7E546246, 	// A8-AB
  0x8DF6C213, 0xD890E8B8, 0x392E5EF7, 0xC382F5AF, 	// AC-AF

  0x5D9FBE80, 0xD0697C93, 0xD56FA92D, 0x25CFB312, 	// B0-B3
  0xACC83B99, 0x1810A77D, 0x9CE86E63, 0x3BDB7BBB, 	// B4-B7
  0x26CD0978, 0x596EF418, 0x9AEC01B7, 0x4F83A89A, 	// B8-BB
  0x95E6656E, 0xFFAA7EE6, 0xBC2108CF, 0x15EFE6E8, 	// BC-BF

  0xE7BAD99B, 0x6F4ACE36, 0x9FEAD409, 0xB029D67C, 	// C0-C3
  0xA431AFB2, 0x3F2A3123, 0xA5C63094, 0xA235C066, 	// C4-C7
  0x4E7437BC, 0x82FCA6CA, 0x90E0B0D0, 0xA73315D8, 	// C8-CB
  0x04F14A98, 0xEC41F7DA, 0xCD7F0E50, 0x91172FF6, 	// CC-CF

  0x4D768DD6, 0xEF434DB0, 0xAACC544D, 0x96E4DF04, 	// D0-D3
  0xD19EE3B5, 0x6A4C1B88, 0x2CC1B81F, 0x65467F51, 	// D4-D7
  0x5E9D04EA, 0x8C015D35, 0x87FA7374, 0x0BFB2E41, 	// D8-DB
  0x67B35A1D, 0xDB9252D2, 0x10E93356, 0xD66D1347, 	// DC-DF

  0xD79A8C61, 0xA1377A0C, 0xF8598E14, 0x13EB893C, 	// E0-E3
  0xA9CEEE27, 0x61B735C9, 0x1CE1EDE5, 0x477A3CB1, 	// E4-E7
  0xD29C59DF, 0xF2553F73, 0x141879CE, 0xC773BF37, 	// E8-EB
  0xF753EACD, 0xFD5F5BAA, 0x3DDF146F, 0x447886DB, 	// EC-EF

  0xAFCA81F3, 0x68B93EC4, 0x24382C34, 0xA3C25F40, 	// F0-F3
  0x1D1672C3, 0xE2BC0C25, 0x3C288B49, 0x0DFF4195, 	// F4-F7
  0xA8397101, 0x0C08DEB3, 0xB4D89CE4, 0x566490C1, 	// F8-FB
  0xCB7B6184, 0x32D570B6, 0x6C48745C, 0xB8D04257, 	// FC-FF
};
//------------------------------------------------------
// Decryption Table T3
//------------------------------------------------------
unsigned int TabDecT3[256] = {
  0x5150A7F4, 0x7E536541, 0x1AC3A417, 0x3A965E27, 	// 00-03
  0x3BCB6BAB, 0x1FF1459D, 0xACAB58FA, 0x4B9303E3, 	// 04-07
  0x2055FA30, 0xADF66D76, 0x889176CC, 0xF5254C02, 	// 08-0B
  0x4FFCD7E5, 0xC5D7CB2A, 0x26804435, 0xB58FA362, 	// 0C-0F

  0xDE495AB1, 0x25671BBA, 0x45980EEA, 0x5DE1C0FE, 	// 10-13
  0xC302752F, 0x8112F04C, 0x8DA39746, 0x6BC6F9D3, 	// 14-17
  0x03E75F8F, 0x15959C92, 0xBFEB7A6D, 0x95DA5952, 	// 18-1B
  0xD42D83BE, 0x58D32174, 0x492969E0, 0x8E44C8C9, 	// 1C-1F

  0x756A89C2, 0xF478798E, 0x996B3E58, 0x27DD71B9, 	// 20-23
  0xBEB64FE1, 0xF017AD88, 0xC966AC20, 0x7DB43ACE, 	// 24-27
  0x63184ADF, 0xE582311A, 0x97603351, 0x62457F53, 	// 28-2B
  0xB1E07764, 0xBB84AE6B, 0xFE1CA081, 0xF9942B08, 	// 2C-2F

  0x70586848, 0x8F19FD45, 0x94876CDE, 0x52B7F87B, 	// 30-33
  0xAB23D373, 0x72E2024B, 0xE3578F1F, 0x662AAB55, 	// 34-37
  0xB20728EB, 0x2F03C2B5, 0x869A7BC5, 0xD3A50837, 	// 38-3B
  0x30F28728, 0x23B2A5BF, 0x02BA6A03, 0xED5C8216, 	// 3C-3F

  0x8A2B1CCF, 0xA792B479, 0xF3F0F207, 0x4EA1E269, 	// 40-43
  0x65CDF4DA, 0x06D5BE05, 0xD11F6234, 0xC48AFEA6, 	// 44-47
  0x349D532E, 0xA2A055F3, 0x0532E18A, 0xA475EBF6, 	// 48-4B
  0x0B39EC83, 0x40AAEF60, 0x5E069F71, 0xBD51106E, 	// 4C-4F

  0x3EF98A21, 0x963D06DD, 0xDDAE053E, 0x4D46BDE6, 	// 50-53
  0x91B58D54, 0x71055DC4, 0x046FD406, 0x60FF1550, 	// 54-57
  0x1924FB98, 0xD697E9BD, 0x89CC4340, 0x67779ED9, 	// 58-5B
  0xB0BD42E8, 0x07888B89, 0xE7385B19, 0x79DBEEC8, 	// 5C-5F

  0xA1470A7C, 0x7CE90F42, 0xF8C91E84, 0x00000000, 	// 60-63
  0x09838680, 0x3248ED2B, 0x1EAC7011, 0x6C4E725A, 	// 64-67
  0xFDFBFF0E, 0x0F563885, 0x3D1ED5AE, 0x3627392D, 	// 68-6B
  0x0A64D90F, 0x6821A65C, 0x9BD1545B, 0x243A2E36, 	// 6C-6F

  0x0CB1670A, 0x930FE757, 0xB4D296EE, 0x1B9E919B, 	// 70-73
  0x804FC5C0, 0x61A220DC, 0x5A694B77, 0x1C161A12, 	// 74-77
  0xE20ABA93, 0xC0E52AA0, 0x3C43E022, 0x121D171B, 	// 78-7B
  0x0E0B0D09, 0xF2ADC78B, 0x2DB9A8B6, 0x14C8A91E, 	// 7C-7F

  0x578519F1, 0xAF4C0775, 0xEEBBDD99, 0xA3FD607F, 	// 80-83
  0xF79F2601, 0x5CBCF572, 0x44C53B66, 0x5B347EFB, 	// 84-87
  0x8B762943, 0xCBDCC623, 0xB668FCED, 0xB863F1E4, 	// 88-8B
  0xD7CADC31, 0x42108563, 0x13402297, 0x842011C6, 	// 8C-8F

  0x857D244A, 0xD2F83DBB, 0xAE1132F9, 0xC76DA129, 	// 90-93
  0x1D4B2F9E, 0xDCF330B2, 0x0DEC5286, 0x77D0E3C1, 	// 94-97
  0x2B6C16B3, 0xA999B970, 0x11FA4894, 0x472264E9, 	// 98-9B
  0xA8C48CFC, 0xA01A3FF0, 0x56D82C7D, 0x22EF9033, 	// 9C-9F

  0x87C74E49, 0xD9C1D138, 0x8CFEA2CA, 0x98360BD4, 	// A0-A3
  0xA6CF81F5, 0xA528DE7A, 0xDA268EB7, 0x3FA4BFAD, 	// A4-A7
  0x2CE49D3A, 0x500D9278, 0x6A9BCC5F, 0x5462467E, 	// A8-AB
  0xF6C2138D, 0x90E8B8D8, 0x2E5EF739, 0x82F5AFC3, 	// AC-AF

  0x9FBE805D, 0x697C93D0, 0x6FA92DD5, 0xCFB31225, 	// B0-B3
  0xC83B99AC, 0x10A77D18, 0xE86E639C, 0xDB7BBB3B, 	// B4-B7
  0xCD097826, 0x6EF41859, 0xEC01B79A, 0x83A89A4F, 	// B8-BB
  0xE6656E95, 0xAA7EE6FF, 0x2108CFBC, 0xEFE6E815, 	// BC-BF

  0xBAD99BE7, 0x4ACE366F, 0xEAD4099F, 0x29D67CB0, 	// C0-C3
  0x31AFB2A4, 0x2A31233F, 0xC63094A5, 0x35C066A2, 	// C4-C7
  0x7437BC4E, 0xFCA6CA82, 0xE0B0D090, 0x3315D8A7, 	// C8-CB
  0xF14A9804, 0x41F7DAEC, 0x7F0E50CD, 0x172FF691, 	// CC-CF

  0x768DD64D, 0x434DB0EF, 0xCC544DAA, 0xE4DF0496, 	// D0-D3
  0x9EE3B5D1, 0x4C1B886A, 0xC1B81F2C, 0x467F5165, 	// D4-D7
  0x9D04EA5E, 0x015D358C, 0xFA737487, 0xFB2E410B, 	// D8-DB
  0xB35A1D67, 0x9252D2DB, 0xE9335610, 0x6D1347D6, 	// DC-DF

  0x9A8C61D7, 0x377A0CA1, 0x598E14F8, 0xEB893C13, 	// E0-E3
  0xCEEE27A9, 0xB735C961, 0xE1EDE51C, 0x7A3CB147, 	// E4-E7
  0x9C59DFD2, 0x553F73F2, 0x1879CE14, 0x73BF37C7, 	// E8-EB
  0x53EACDF7, 0x5F5BAAFD, 0xDF146F3D, 0x7886DB44, 	// EC-EF

  0xCA81F3AF, 0xB93EC468, 0x382C3424, 0xC25F40A3, 	// F0-F3
  0x1672C31D, 0xBC0C25E2, 0x288B493C, 0xFF41950D, 	// F4-F7
  0x397101A8, 0x08DEB30C, 0xD89CE4B4, 0x6490C156, 	// F8-FB
  0x7B6184CB, 0xD570B632, 0x48745C6C, 0xD04257B8, 	// FC-FF
};

// constats for AES GCM
static unsigned const long long MAX_PLAINTEXT_LENGTH = 68719476704LL; //2^39-256
static unsigned const long long MAX_CIPHERTEXT_LENGTH = 68719476704LL; //2^39-256
const int AES128_KEY_SIZE = 16;
const int AES192_KEY_SIZE = 24;
const int AES256_KEY_SIZE = 32;
static const int AES128_ROUNDS = 10;
static const int AES192_ROUNDS = 12;
static const int AES256_ROUNDS = 14;
static const size_t ALLOWED_TAG_SIZE[] = {16,15,14,13,12,8,4};
static const size_t ALLOWED_KEY_SIZE[] = {AES128_KEY_SIZE,AES192_KEY_SIZE,AES256_KEY_SIZE};
static const int BYTE_BITSIZE = 8;
static const int IV_STANDARD_BYTESIZE = 12;
static const unsigned char LSB_SET = 0x1;
static const long long LSB_SET_U64 = 0x0000000000000001;
static const long long MSB_SET_U64 = 0x8000000000000000LL;
static const long long GF128_MODULO_U64 = 0xE100000000000000LL;
static const int BIT_SEVEN = 7;

#define IS_SET_BIT(byte,num) ( (byte) & (1<<(num)) )
#define IS_NOTSET_BIT(byte,num) !(IS_SET_BIT(byte,num))
#define SET_BIT(byte,num) ( (byte) |=  (1<<(num)) )
#define UNSET_BIT(byte,num) ( (byte) &=  (~(1<<(num))) )

inline void m_aes_block_xor(const unsigned char* abyp_first_block,
                            const unsigned char* abyp_second_block,
                            unsigned char* abyp_dest_block)
{
   ((uint64_t*)abyp_dest_block)[0] = ((const uint64_t*)abyp_first_block)[0] ^
                                     ((const uint64_t*)abyp_second_block)[0];
   ((uint64_t*)abyp_dest_block)[1] = ((const uint64_t*)abyp_first_block)[1] ^
                                     ((const uint64_t*)abyp_second_block)[1];
}

/** @addtogroup aes
*@{
*/

//***********************************************************
//
// Processing Routines with special 32 Bit Table support (9 kB),
// all tested
//
// VERY IMPORTANT NOTE:
// --------------------
// The Tables and associated processing routines are BYTE REVERSED
// compared to the original RIJNDAEL fast mode reference code.
// This reduces Byte to DWord/DWord to Byte conversion overhead on
// Little Endian machines [INTEL]
// For Big Endian machines [SUN etc.] all the tables and processing
// routines should be changed.... (to be done ?)
//
//***********************************************************

extern "C" int m_gen_aes_encrypt_keys(const unsigned char * AesKey, 
                                      size_t AesKeyLen,
                                      ds_aes_key * pEncKeyStruc)
{
  unsigned int * EncKeyTab = (unsigned int *) pEncKeyStruc->byr_key;

  size_t Index = AesKeyLen-1;
  unsigned char Remainder;
  size_t MaxRoundIndex = AesKeyLen*4 + 28 - 1;  // ((nk+6) + 1) * nb (-1)

  unsigned int Rcon = 0x01;
  unsigned int s;
  //---------------------------------------------------------
  // Copy the key data to the array
  //---------------------------------------------------------
  char2longn(AesKey,EncKeyTab[0],0);
  char2longn(AesKey,EncKeyTab[1],4);
  char2longn(AesKey,EncKeyTab[2],8);
  char2longn(AesKey,EncKeyTab[3],12);

  if(AesKeyLen == 4)
  {
//    Offset += 16;
  }
  else if(AesKeyLen == 6)
  {
    char2longn(AesKey,EncKeyTab[4],16);
    char2longn(AesKey,EncKeyTab[5],20);
//    Offset += 24;
  }
  else if(AesKeyLen == 8)
  {
    char2longn(AesKey,EncKeyTab[4],16);
    char2longn(AesKey,EncKeyTab[5],20);
    char2longn(AesKey,EncKeyTab[6],24);
    char2longn(AesKey,EncKeyTab[7],28);
//    Offset += 32;
  }
  else // wrong key length, should not happen
  {
    return(-1);
  }
  //--------------------------------------------------------
  // Expand the key for the number of rounds required
  //--------------------------------------------------------
  do
  {
    s = EncKeyTab[Index++];			// get last key, advance
    Remainder = (unsigned char) (Index % AesKeyLen); // get modulus remainder
    if(Remainder == 0)				// at a specific index
    {
      s = ((((int) SBox[s         & 0xFF] & 0xFF) << 24) |
           (((int) SBox[(s >> 24) & 0xFF] & 0xFF) << 16) |
           (((int) SBox[(s >> 16) & 0xFF] & 0xFF) << 8) |
           (((int) SBox[(s >>  8) & 0xFF] & 0xFF))) ^ Rcon;
      Rcon <<= 1;				// times 2
      if((Rcon & 0x100) != 0)			// was 1 00
        Rcon = 0x1B;				// reduce modulo 1 1B
    }
    else if((AesKeyLen == 8) && (Remainder == 4))
    {
      s = ((int)  SBox[s         & 0xFF] & 0xFF) |
          (((int) SBox[(s >>  8) & 0xFF] & 0xFF) <<  8) |
          (((int) SBox[(s >> 16) & 0xFF] & 0xFF) << 16) |
          (((int) SBox[(s >> 24) & 0xFF] & 0xFF) << 24);
    }
    EncKeyTab[Index] = EncKeyTab[Index - AesKeyLen] ^ s;
  }while(Index < MaxRoundIndex);
  return(0);
}

extern "C" int m_gen_aes_decrypt_keys(const unsigned char * AesKey, 
                                      size_t AesKeyLen,
                                      ds_aes_key * pDecKeyStruc)
{
  unsigned int * DecKeyTab = (unsigned int *) pDecKeyStruc->byr_key;
  int Retcode;
  size_t SrcIndex;
  size_t DstIndex;
  size_t Rounds = AesKeyLen + 6 - 2;	// not for first/last
  unsigned int s0,s1,s2,s3;
  //---------------------------------------------------------------
  // 1. Expand the key same as for encryption mode
  //---------------------------------------------------------------
  Retcode = m_gen_aes_encrypt_keys(AesKey, AesKeyLen, pDecKeyStruc);
  if(Retcode != 0)
    return(Retcode);
  //---------------------------------------------------------------
  // 2. Change order of keys in Blocks of 4
  //---------------------------------------------------------------
  SrcIndex = 0;
  DstIndex = (AesKeyLen + 6) * 4;		// last quadruple
  do
  {
    s0 = DecKeyTab[DstIndex+0];
    s1 = DecKeyTab[DstIndex+1];
    s2 = DecKeyTab[DstIndex+2];
    s3 = DecKeyTab[DstIndex+3];

    DecKeyTab[DstIndex+0] = DecKeyTab[SrcIndex+0];
    DecKeyTab[DstIndex+1] = DecKeyTab[SrcIndex+1];
    DecKeyTab[DstIndex+2] = DecKeyTab[SrcIndex+2];
    DecKeyTab[DstIndex+3] = DecKeyTab[SrcIndex+3];

    DecKeyTab[SrcIndex+0] = s0;
    DecKeyTab[SrcIndex+1] = s1;
    DecKeyTab[SrcIndex+2] = s2;
    DecKeyTab[SrcIndex+3] = s3;

    SrcIndex += 4;
    DstIndex -= 4;
  }while(SrcIndex < DstIndex);
  //---------------------------------------------------------------
  // 2. Inverse Mix Columns for Element Indices 1 ... KeyLen-2
  //---------------------------------------------------------------
  Rounds = AesKeyLen + 6 - 1;	// not for first/last
  SrcIndex = 4;
  do
  {
    //-------------------------------------------------------------
    // fetch 4 contiguous keys, process through tables
    // NOTE: watch for the Indirect Index processing via S-Box !!!
    //-------------------------------------------------------------
    s0 = DecKeyTab[SrcIndex+0];
    s1 = DecKeyTab[SrcIndex+1];
    s2 = DecKeyTab[SrcIndex+2];
    s3 = DecKeyTab[SrcIndex+3];

    DecKeyTab[SrcIndex+0] =
      TabDecT0[SBox[ s0        & 0xFF] & 0xFF] ^
      TabDecT1[SBox[(s0 >>  8) & 0xFF] & 0xFF] ^
      TabDecT2[SBox[(s0 >> 16) & 0xFF] & 0xFF] ^
      TabDecT3[SBox[(s0 >> 24) & 0xFF] & 0xFF];

    DecKeyTab[SrcIndex+1] =
      TabDecT0[SBox[s1         & 0xFF] & 0xFF] ^
      TabDecT1[SBox[(s1 >>  8) & 0xFF] & 0xFF] ^
      TabDecT2[SBox[(s1 >> 16) & 0xFF] & 0xFF] ^
      TabDecT3[SBox[(s1 >> 24) & 0xFF] & 0xFF];

    DecKeyTab[SrcIndex+2] =
      TabDecT0[SBox[s2         & 0xFF] & 0xFF] ^
      TabDecT1[SBox[(s2 >>  8) & 0xFF] & 0xFF] ^
      TabDecT2[SBox[(s2 >> 16) & 0xFF] & 0xFF] ^
      TabDecT3[SBox[(s2 >> 24) & 0xFF] & 0xFF];

    DecKeyTab[SrcIndex+3] =
      TabDecT0[SBox[s3         & 0xFF] & 0xFF] ^
      TabDecT1[SBox[(s3 >>  8) & 0xFF] & 0xFF] ^
      TabDecT2[SBox[(s3 >> 16) & 0xFF] & 0xFF] ^
      TabDecT3[SBox[(s3 >> 24) & 0xFF] & 0xFF];

    SrcIndex += 4;
    Rounds--;
  }while(Rounds != 0);
  return(0);
}

#if HOB_WIN64_ASM != 1

extern "C" void AES_Fast_cbc_encrypt(const unsigned char * input,
		               unsigned char * output,
                               const ds_aes_key * pEncKeyStruc,
                               size_t BlkCnt,
                               unsigned char * IVector,
		               int Rounds)
{
  const unsigned int * EncKeyTab = (const unsigned int *) pEncKeyStruc->byr_key;

  unsigned int s0,s1,s2,s3;
  unsigned int t0,t1,t2,t3;
  unsigned int Xor[4];
  unsigned int s[4];
  //-----------------------------------------------------------
  // load IV Vector
  //-----------------------------------------------------------
  char2longn(IVector,Xor[0],0);		// get bytes 0-3
  char2longn(IVector,Xor[1],4);		// get bytes 4-7
  char2longn(IVector,Xor[2],8);		// get bytes 8-11
  char2longn(IVector,Xor[3],12);	// get bytes 12-15
  //-----------------------------------------------------------
  // Encrypt Blocks, full unrolled loops
  //-----------------------------------------------------------
  for(;BlkCnt > 0;BlkCnt--)
  {
    char2longn(input,s[0],0);		// get bytes 0-3
    char2longn(input,s[1],4);		// get bytes 4-7
    char2longn(input,s[2],8);		// get bytes 8-11
    char2longn(input,s[3],12);		// get bytes 12-15

    s0 = s[0] ^ Xor[0] ^ EncKeyTab[0];
    s1 = s[1] ^ Xor[1] ^ EncKeyTab[1];
    s2 = s[2] ^ Xor[2] ^ EncKeyTab[2];
    s3 = s[3] ^ Xor[3] ^ EncKeyTab[3];
    //-------------------------------------------------
    // Perform Table processing for all 10/12/14 rounds
    //-------------------------------------------------
    AES_ENC_ROUND(t0,t1,t2,t3,s0,s1,s2,s3,EncKeyTab,0);	// Round 1
//  SR_STATES(s0,s1,s2,s3,t0,t1,t2,t3,1);

    AES_ENC_ROUND(s0,s1,s2,s3,t0,t1,t2,t3,EncKeyTab,1);	// Round 2
//  SR_STATES(t0,t1,t2,t3,s0,s1,s2,s3,2);

    AES_ENC_ROUND(t0,t1,t2,t3,s0,s1,s2,s3,EncKeyTab,2);	// Round 3
//  SR_STATES(s0,s1,s2,s3,t0,t1,t2,t3,3);

    AES_ENC_ROUND(s0,s1,s2,s3,t0,t1,t2,t3,EncKeyTab,3);	// Round 4
//  SR_STATES(t0,t1,t2,t3,s0,s1,s2,s3,4);

    AES_ENC_ROUND(t0,t1,t2,t3,s0,s1,s2,s3,EncKeyTab,4);	// Round 5
//  SR_STATES(s0,s1,s2,s3,t0,t1,t2,t3,5);

    AES_ENC_ROUND(s0,s1,s2,s3,t0,t1,t2,t3,EncKeyTab,5);	// Round 6
//  SR_STATES(t0,t1,t2,t3,s0,s1,s2,s3,6);

    AES_ENC_ROUND(t0,t1,t2,t3,s0,s1,s2,s3,EncKeyTab,6);	// Round 7
//  SR_STATES(s0,s1,s2,s3,t0,t1,t2,t3,7);

    AES_ENC_ROUND(s0,s1,s2,s3,t0,t1,t2,t3,EncKeyTab,7);	// Round 8
//  SR_STATES(t0,t1,t2,t3,s0,s1,s2,s3,8);

    AES_ENC_ROUND(t0,t1,t2,t3,s0,s1,s2,s3,EncKeyTab,8);	// Round 9
//  SR_STATES(s0,s1,s2,s3,t0,t1,t2,t3,9);

    if(Rounds == 14)					// AES-256
    {
      AES_ENC_ROUND(s0,s1,s2,s3,t0,t1,t2,t3,EncKeyTab,9);  // Round 10
//    SR_STATES(t0,t1,t2,t3,s0,s1,s2,s3,10);

      AES_ENC_ROUND(t0,t1,t2,t3,s0,s1,s2,s3,EncKeyTab,10); // Round 11
//    SR_STATES(s0,s1,s2,s3,t0,t1,t2,t3,11);

      AES_ENC_ROUND(s0,s1,s2,s3,t0,t1,t2,t3,EncKeyTab,11); // Round 12
//    SR_STATES(t0,t1,t2,t3,s0,s1,s2,s3,12);

      AES_ENC_ROUND(t0,t1,t2,t3,s0,s1,s2,s3,EncKeyTab,12); // Round 13
//    SR_STATES(s0,s1,s2,s3,t0,t1,t2,t3,13);

      AES_ENC_LAST_ROUND(Xor[0],Xor[1],Xor[2],Xor[3],t0,t1,t2,t3,EncKeyTab,13);//Round 14
//    SR_STATES(t0,t1,t2,t3,xor[0],xor[1],xor[2],xor[3],14);

    }
    else if(Rounds == 12)				// AES-192
    {
      AES_ENC_ROUND(s0,s1,s2,s3,t0,t1,t2,t3,EncKeyTab,9); // Round 10
//    SR_STATES(t0,t1,t2,t3,s0,s1,s2,s3,10);

      AES_ENC_ROUND(t0,t1,t2,t3,s0,s1,s2,s3,EncKeyTab,10);// Round 11
//    SR_STATES(s0,s1,s2,s3,t0,t1,t2,t3,11);

      AES_ENC_LAST_ROUND(Xor[0],Xor[1],Xor[2],Xor[3],t0,t1,t2,t3,EncKeyTab,11);//Round 12
//    SR_STATES(t0,t1,t2,t3,Xor[0],Xor[1],Xor[2],Xor[3],12);
    }
    else
    {
      AES_ENC_LAST_ROUND(Xor[0],Xor[1],Xor[2],Xor[3],t0,t1,t2,t3,EncKeyTab,9);// Round 10
//    SR_STATES(t0,t1,t2,t3,Xor[0],Xor[1],Xor[2],Xor[3],10);
    }

    long2charn(Xor[0],output,0);
    long2charn(Xor[1],output,4);
    long2charn(Xor[2],output,8);
    long2charn(Xor[3],output,12);

    input  += 16;
    output += 16;
  }
  //-----------------------------------------------------------
  // Store Back new IV
  //-----------------------------------------------------------
  long2charn(Xor[0],IVector,0);
  long2charn(Xor[1],IVector,4);
  long2charn(Xor[2],IVector,8);
  long2charn(Xor[3],IVector,12);
}

extern "C" void AES_Fast_cbc_decrypt(const unsigned char * input,
		               unsigned char * output,
                               const ds_aes_key * pDecKeyStruc,
                               size_t BlkCnt,
                               unsigned char * IVector,
		               int Rounds)
{
  const unsigned int * DecKeyTab = (const unsigned int *) pDecKeyStruc->byr_key;

  unsigned int s0,s1,s2,s3;
  unsigned int t0,t1,t2,t3;
  unsigned int Xor[4];
  unsigned int s[4];
  //-----------------------------------------------------------
  // load IV Vector, prepare input/output pointers
  //-----------------------------------------------------------
  char2longn(IVector,Xor[0],0);			// get bytes 0-3
  char2longn(IVector,Xor[1],4);			// get bytes 4-7
  char2longn(IVector,Xor[2],8);			// get bytes 8-11
  char2longn(IVector,Xor[3],12);		// get bytes 12-15
  //-----------------------------------------------------------
  // Decrypt Blocks
  //-----------------------------------------------------------
  for(;BlkCnt > 0;BlkCnt--)
  {
    char2longn(input,s[0],0);
    char2longn(input,s[1],4);
    char2longn(input,s[2],8);
    char2longn(input,s[3],12);

    s0 = s[0] ^ DecKeyTab[0];
    s1 = s[1] ^ DecKeyTab[1];
    s2 = s[2] ^ DecKeyTab[2];
    s3 = s[3] ^ DecKeyTab[3];

    //-------------------------------------------------
    // Perform Table processing for all 10 rounds
    //-------------------------------------------------
    AES_DEC_ROUND(t0,t1,t2,t3,s0,s1,s2,s3,DecKeyTab,0);	// Round 1
    AES_DEC_ROUND(s0,s1,s2,s3,t0,t1,t2,t3,DecKeyTab,1);	// Round 2
    AES_DEC_ROUND(t0,t1,t2,t3,s0,s1,s2,s3,DecKeyTab,2);	// Round 3
    AES_DEC_ROUND(s0,s1,s2,s3,t0,t1,t2,t3,DecKeyTab,3);	// Round 4
    AES_DEC_ROUND(t0,t1,t2,t3,s0,s1,s2,s3,DecKeyTab,4);	// Round 5
    AES_DEC_ROUND(s0,s1,s2,s3,t0,t1,t2,t3,DecKeyTab,5);	// Round 6
    AES_DEC_ROUND(t0,t1,t2,t3,s0,s1,s2,s3,DecKeyTab,6);	// Round 7
    AES_DEC_ROUND(s0,s1,s2,s3,t0,t1,t2,t3,DecKeyTab,7);	// Round 8
    AES_DEC_ROUND(t0,t1,t2,t3,s0,s1,s2,s3,DecKeyTab,8);	// Round 9
    if(Rounds == 14)					// AES-256
    {
      AES_DEC_ROUND(s0,s1,s2,s3,t0,t1,t2,t3,DecKeyTab,9);  // Round 10
      AES_DEC_ROUND(t0,t1,t2,t3,s0,s1,s2,s3,DecKeyTab,10); // Round 11
      AES_DEC_ROUND(s0,s1,s2,s3,t0,t1,t2,t3,DecKeyTab,11); // Round 12
      AES_DEC_ROUND(t0,t1,t2,t3,s0,s1,s2,s3,DecKeyTab,12); // Round 13
      AES_DEC_LAST_ROUND(s0,s1,s2,s3,t0,t1,t2,t3,DecKeyTab,13);//Round 14
    }
    else if(Rounds == 12)				// AES-192
    {
      AES_DEC_ROUND(s0,s1,s2,s3,t0,t1,t2,t3,DecKeyTab,9); // Round 10
      AES_DEC_ROUND(t0,t1,t2,t3,s0,s1,s2,s3,DecKeyTab,10);// Round 11
      AES_DEC_LAST_ROUND(s0,s1,s2,s3,t0,t1,t2,t3,DecKeyTab,11);//Round 12
    }
    else						// AES-128
    {
      AES_DEC_LAST_ROUND(s0,s1,s2,s3,t0,t1,t2,t3,DecKeyTab,9);// Round 10
    }

    Xor[0] ^= s0;			// Xor with IV
    Xor[1] ^= s1;
    Xor[2] ^= s2;
    Xor[3] ^= s3;

    long2charn(Xor[0],output,0);
    long2charn(Xor[1],output,4);
    long2charn(Xor[2],output,8);
    long2charn(Xor[3],output,12);
    memcpy(Xor,s,16);

    input  += 16;
    output += 16;
  }
  //-----------------------------------------------------------
  // Store Back new IV
  //-----------------------------------------------------------
  long2charn(Xor[0],IVector,0);
  long2charn(Xor[1],IVector,4);
  long2charn(Xor[2],IVector,8);
  long2charn(Xor[3],IVector,12);
}
#endif// HOB_WIN64_ASM != 1

extern "C" void AES_Fast_ecb_encrypt(const unsigned char * input,
                                     unsigned char * output,
                                     const ds_aes_key * pEncKeyStruc,
                                     size_t BlkCnt, 
                                     int Rounds)
{
  const unsigned int * EncKeyTab = (const unsigned int *) pEncKeyStruc->byr_key;

  unsigned int s0,s1,s2,s3;
  unsigned int t0,t1,t2,t3;
  unsigned int s[4];
  //-----------------------------------------------------------
  // Encrypt Blocks, full unrolled loops
  //-----------------------------------------------------------
  for(;BlkCnt > 0;BlkCnt--)
  {
    char2longn(input,s[0],0);		// get bytes 0-3
    char2longn(input,s[1],4);		// get bytes 4-7
    char2longn(input,s[2],8);		// get bytes 8-11
    char2longn(input,s[3],12);		// get bytes 12-15

    s0 = s[0] ^ EncKeyTab[0];
    s1 = s[1] ^ EncKeyTab[1];
    s2 = s[2] ^ EncKeyTab[2];
    s3 = s[3] ^ EncKeyTab[3];
    //-------------------------------------------------
    // Perform Table processing for all 10/12/14 rounds
    //-------------------------------------------------
    AES_ENC_ROUND(t0,t1,t2,t3,s0,s1,s2,s3,EncKeyTab,0);	// Round 1
    AES_ENC_ROUND(s0,s1,s2,s3,t0,t1,t2,t3,EncKeyTab,1);	// Round 2
    AES_ENC_ROUND(t0,t1,t2,t3,s0,s1,s2,s3,EncKeyTab,2);	// Round 3
    AES_ENC_ROUND(s0,s1,s2,s3,t0,t1,t2,t3,EncKeyTab,3);	// Round 4
    AES_ENC_ROUND(t0,t1,t2,t3,s0,s1,s2,s3,EncKeyTab,4);	// Round 5
    AES_ENC_ROUND(s0,s1,s2,s3,t0,t1,t2,t3,EncKeyTab,5);	// Round 6
    AES_ENC_ROUND(t0,t1,t2,t3,s0,s1,s2,s3,EncKeyTab,6);	// Round 7
    AES_ENC_ROUND(s0,s1,s2,s3,t0,t1,t2,t3,EncKeyTab,7);	// Round 8
    AES_ENC_ROUND(t0,t1,t2,t3,s0,s1,s2,s3,EncKeyTab,8);	// Round 9

    if(Rounds == 14)					// AES-256
    {
      AES_ENC_ROUND(s0,s1,s2,s3,t0,t1,t2,t3,EncKeyTab,9);  // Round 10
      AES_ENC_ROUND(t0,t1,t2,t3,s0,s1,s2,s3,EncKeyTab,10); // Round 11
      AES_ENC_ROUND(s0,s1,s2,s3,t0,t1,t2,t3,EncKeyTab,11); // Round 12
      AES_ENC_ROUND(t0,t1,t2,t3,s0,s1,s2,s3,EncKeyTab,12); // Round 13
      AES_ENC_LAST_ROUND(s0,s1,s2,s3,t0,t1,t2,t3,EncKeyTab,13);//Round 14
    }
    else if(Rounds == 12)				// AES-192
    {
      AES_ENC_ROUND(s0,s1,s2,s3,t0,t1,t2,t3,EncKeyTab,9); // Round 10
      AES_ENC_ROUND(t0,t1,t2,t3,s0,s1,s2,s3,EncKeyTab,10);// Round 11
      AES_ENC_LAST_ROUND(s0,s1,s2,s3,t0,t1,t2,t3,EncKeyTab,11);//Round 12
    }
    else
    {
      AES_ENC_LAST_ROUND(s0,s1,s2,s3,t0,t1,t2,t3,EncKeyTab,9);// Round 10
    }

    long2charn(s0,output,0);
    long2charn(s1,output,4);
    long2charn(s2,output,8);
    long2charn(s3,output,12);

    input  += 16;
    output += 16;
  }
}

extern "C" void AES_Fast_ecb_decrypt(const unsigned char * input,
                                     unsigned char * output,
                                     const ds_aes_key * pDecKeyStruc,
                                     size_t BlkCnt,
                                     int Rounds)
{
  const unsigned int * DecKeyTab = (const unsigned int *) pDecKeyStruc->byr_key;

  unsigned int s0,s1,s2,s3;
  unsigned int t0,t1,t2,t3;
  unsigned int s[4];
  //-----------------------------------------------------------
  // Decrypt Blocks
  //-----------------------------------------------------------
  for(;BlkCnt > 0;BlkCnt--)
  {
    char2longn(input,s[0],0);
    char2longn(input,s[1],4);
    char2longn(input,s[2],8);
    char2longn(input,s[3],12);

    s0 = s[0] ^ DecKeyTab[0];
    s1 = s[1] ^ DecKeyTab[1];
    s2 = s[2] ^ DecKeyTab[2];
    s3 = s[3] ^ DecKeyTab[3];

    //-------------------------------------------------
    // Perform Table processing for all 10 rounds
    //-------------------------------------------------
    AES_DEC_ROUND(t0,t1,t2,t3,s0,s1,s2,s3,DecKeyTab,0);	// Round 1
    AES_DEC_ROUND(s0,s1,s2,s3,t0,t1,t2,t3,DecKeyTab,1);	// Round 2
    AES_DEC_ROUND(t0,t1,t2,t3,s0,s1,s2,s3,DecKeyTab,2);	// Round 3
    AES_DEC_ROUND(s0,s1,s2,s3,t0,t1,t2,t3,DecKeyTab,3);	// Round 4
    AES_DEC_ROUND(t0,t1,t2,t3,s0,s1,s2,s3,DecKeyTab,4);	// Round 5
    AES_DEC_ROUND(s0,s1,s2,s3,t0,t1,t2,t3,DecKeyTab,5);	// Round 6
    AES_DEC_ROUND(t0,t1,t2,t3,s0,s1,s2,s3,DecKeyTab,6);	// Round 7
    AES_DEC_ROUND(s0,s1,s2,s3,t0,t1,t2,t3,DecKeyTab,7);	// Round 8
    AES_DEC_ROUND(t0,t1,t2,t3,s0,s1,s2,s3,DecKeyTab,8);	// Round 9
    if(Rounds == 14)					// AES-256
    {
      AES_DEC_ROUND(s0,s1,s2,s3,t0,t1,t2,t3,DecKeyTab,9);  // Round 10
      AES_DEC_ROUND(t0,t1,t2,t3,s0,s1,s2,s3,DecKeyTab,10); // Round 11
      AES_DEC_ROUND(s0,s1,s2,s3,t0,t1,t2,t3,DecKeyTab,11); // Round 12
      AES_DEC_ROUND(t0,t1,t2,t3,s0,s1,s2,s3,DecKeyTab,12); // Round 13
      AES_DEC_LAST_ROUND(s0,s1,s2,s3,t0,t1,t2,t3,DecKeyTab,13);//Round 14
    }
    else if(Rounds == 12)				// AES-192
    {
      AES_DEC_ROUND(s0,s1,s2,s3,t0,t1,t2,t3,DecKeyTab,9); // Round 10
      AES_DEC_ROUND(t0,t1,t2,t3,s0,s1,s2,s3,DecKeyTab,10);// Round 11
      AES_DEC_LAST_ROUND(s0,s1,s2,s3,t0,t1,t2,t3,DecKeyTab,11);//Round 12
    }
    else						// AES-128
    {
      AES_DEC_LAST_ROUND(s0,s1,s2,s3,t0,t1,t2,t3,DecKeyTab,9);// Round 10
    }
    long2charn(s0,output,0);
    long2charn(s1,output,4);
    long2charn(s2,output,8);
    long2charn(s3,output,12);

    input  += 16;
    output += 16;
  }
}

//================================================================
//
// CPU-AES Wrapper functions
//
//================================================================
#if defined USE_ASSEMBLER_SOURCES

inline void m_set_cpu_aes_flags(ds_aes_key * adsp_keytab)
{
    if((adsp_keytab->im_flags & CHECK_CPU_AES_FLAG) != 0){
        adsp_keytab->im_flags = CHECK_CPU_AES_FLAG | m_check_cpu_support_aes();
    }
}

extern "C" void m_aes_set_encrypt_key(const unsigned char * abyp_userkey,
			   size_t szp_dwords,
			   ds_aes_key * adsp_keytab)
{
  m_set_cpu_aes_flags(adsp_keytab);

  if((adsp_keytab->im_flags & USE_CPU_AES_FLAG) != 0) {
    adsp_keytab->im_flags |= 1;
    m_aes_cpu_set_encrypt_key(abyp_userkey,szp_dwords, adsp_keytab);
  } else {
    adsp_keytab->im_flags &= ~1;
#if HOB_WIN64_ASM != 1
    m_gen_aes_encrypt_keys(abyp_userkey,szp_dwords,adsp_keytab);
#else
    GenAESEncryptKeys(abyp_userkey,0,szp_dwords,(unsigned int *) adsp_keytab);
#endif
  }
}
#endif

#if defined USE_ASSEMBLER_SOURCES

extern "C" void m_aes_set_decrypt_key(const unsigned char * abyp_userkey,
			   size_t szp_dwords,
			   ds_aes_key * adsp_keytab)
{
  m_set_cpu_aes_flags(adsp_keytab);

  if((adsp_keytab->im_flags & USE_CPU_AES_FLAG) != 0){
    adsp_keytab->im_flags |= 1;
    m_aes_cpu_set_decrypt_key(abyp_userkey,szp_dwords,adsp_keytab);
  } else {
    adsp_keytab->im_flags &= ~1;
#if HOB_WIN64_ASM != 1
    m_gen_aes_decrypt_keys(abyp_userkey,szp_dwords,adsp_keytab);
#else
    GenAESDecryptKeys(abyp_userkey,0,szp_dwords,(unsigned int *) adsp_keytab);
#endif
  }
}
#endif

#if defined USE_ASSEMBLER_SOURCES
extern "C" void m_aes_cbc_encrypt(const unsigned char * abyp_input,
		       unsigned char * abyp_output,
		       const ds_aes_key * adsp_key,
		       size_t szp_block_count,
		       unsigned char * abyp_iv,
		       int imp_rounds)
{

  if((adsp_key->im_flags & USE_CPU_AES_FLAG) == 0)	// no CPU support
  {
    AES_Fast_cbc_encrypt(abyp_input,abyp_output,
                         adsp_key,szp_block_count,
		         abyp_iv,imp_rounds);
  }
  else						// has CPU support
  {
    m_aes_cbc_cpu_encrypt(abyp_input,abyp_output,
		          (unsigned char *) adsp_key,
		          static_cast<unsigned int>(szp_block_count),
			  abyp_iv,
		          imp_rounds);
  }
}
#endif

#if defined USE_ASSEMBLER_SOURCES
extern "C" void m_aes_cbc_decrypt(const unsigned char * abyp_input,
		       unsigned char * abyp_output,
		       const ds_aes_key * adsp_key,
		       size_t szp_block_count,
		       unsigned char * abyp_iv,
		       int imp_rounds)
{
  if((adsp_key->im_flags & USE_CPU_AES_FLAG) == 0)		// no CPU support
  {
    AES_Fast_cbc_decrypt(abyp_input,abyp_output,adsp_key,
                         szp_block_count,abyp_iv,imp_rounds);
  }
  else						// has CPU support
  {
    m_aes_cbc_cpu_decrypt(abyp_input,abyp_output,
		          (unsigned char *) adsp_key,
		          static_cast<unsigned int>(szp_block_count),abyp_iv,
		          imp_rounds);
  }
}
#endif

#if defined USE_ASSEMBLER_SOURCES
extern "C" void m_aes_ecb_encrypt(const unsigned char * abyp_input,
		       unsigned char * abyp_output,
		       const ds_aes_key * adsp_key,
		       size_t szp_block_count,
		       int imp_rounds)
{
  if((adsp_key->im_flags & USE_CPU_AES_FLAG) == 0)		// no CPU support
  {
    AES_Fast_ecb_encrypt(abyp_input,abyp_output,
                         adsp_key,szp_block_count,
		         imp_rounds);
  }
  else						// has CPU support
  {
    m_aes_ecb_cpu_encrypt(abyp_input,abyp_output,
		          (unsigned char *) adsp_key,
		          static_cast<unsigned int>(szp_block_count),
		          imp_rounds);
  }
}
#endif

#if defined USE_ASSEMBLER_SOURCES
extern "C" void m_aes_ecb_decrypt(const unsigned char * abyp_input,
		       unsigned char * abyp_output,
		       const ds_aes_key * adsp_key,
		       size_t szp_block_count,
		       int imp_rounds)
{
  if((adsp_key->im_flags & USE_CPU_AES_FLAG) == 0)		// no CPU support
  {
    AES_Fast_ecb_decrypt(abyp_input,abyp_output,
                         adsp_key,szp_block_count,
		         imp_rounds);
  }
  else						// has CPU support
  {
    m_aes_ecb_cpu_decrypt(abyp_input,abyp_output,
		          (unsigned char *) adsp_key,
		          static_cast<unsigned int>(szp_block_count),
		          imp_rounds);
  }
}
#endif

extern "C" void m_aes_cfb8_encrypt(const unsigned char * abyp_input,
                                   unsigned char * abyp_output,
                                   const ds_aes_key * adsp_key,
                                   size_t szp_byte_count,
                                   const unsigned char * abyp_iv,
                                   int imp_rounds)
{
   unsigned char aucl_temp_cipher_block[AES_BLOCK_SIZE]; //Output from actual AES calls
   unsigned char aucl_temp_in_block[AES_BLOCK_SIZE];     //Input for actual AES calls
   unsigned int uml_bytes_written = 0;                   //Number of bytes encrypted so far
   // Start with IV
   memcpy(aucl_temp_in_block,abyp_iv,AES_BLOCK_SIZE);
   for(;uml_bytes_written < szp_byte_count; uml_bytes_written++){ //Encrypt byte by byte
      m_aes_ecb_encrypt(aucl_temp_in_block, aucl_temp_cipher_block, adsp_key, 1, imp_rounds);
      abyp_output[uml_bytes_written] = aucl_temp_cipher_block[0]^abyp_input[uml_bytes_written];
      // Shift the input and fill with encrypted (meaning OUT) byte
      memmove(aucl_temp_in_block,aucl_temp_in_block+1, AES_BLOCK_SIZE-1);
      aucl_temp_in_block[AES_BLOCK_SIZE-1] = abyp_output[uml_bytes_written];
   }
}

extern "C" void m_aes_cfb8_decrypt(const unsigned char * abyp_input,
                                   unsigned char * abyp_output,
                                   const ds_aes_key * adsp_key,
                                   size_t szp_byte_count,
                                   unsigned char * abyp_iv,
                                   int imp_rounds)
{
   unsigned char aucl_temp_cipher_block[AES_BLOCK_SIZE]; //Output from actual AES calls
   unsigned char aucl_temp_in_block[AES_BLOCK_SIZE];     //Input for actual AES calls
   unsigned int uml_bytes_written = 0;                   //Number of bytes encrypted so far
   // Start with IV
   memcpy(aucl_temp_in_block,abyp_iv,AES_BLOCK_SIZE);

   //Decrypt byte by byte
   for(;uml_bytes_written < szp_byte_count; uml_bytes_written++){
      // The encrypted byte is needed for next decryption, but might be overwritten, when input is output
      unsigned char ucl_next_byte = abyp_input[uml_bytes_written];
      m_aes_ecb_encrypt(aucl_temp_in_block, aucl_temp_cipher_block, adsp_key, 1, imp_rounds);
      abyp_output[uml_bytes_written] = aucl_temp_cipher_block[0]^abyp_input[uml_bytes_written];
      // Shift the input and fill with encrypted (meaning IN) byte
      memmove(aucl_temp_in_block,aucl_temp_in_block+1, AES_BLOCK_SIZE-1);
      aucl_temp_in_block[AES_BLOCK_SIZE-1] = ucl_next_byte;
   }
}

extern "C" void m_aes_raw_encrypt(const unsigned char * aucp_input,
                                  unsigned char * aucp_output,
                                  const ds_aes_key * adsp_enc_key,
                                  int inp_rounds)
{
   AES_Fast_ecb_encrypt(aucp_input, aucp_output, adsp_enc_key, 1, inp_rounds);
}

extern "C" void m_aes_raw_decrypt(const unsigned char * aucp_input,
                                  unsigned char * aucp_output,
                                  const ds_aes_key * adsp_dec_key,
                                  int inp_rounds)
{
   AES_Fast_ecb_decrypt(aucp_input, aucp_output, adsp_dec_key, 1, inp_rounds);
}

extern "C" void m_aes_cfb128_encrypt(const unsigned char * abyp_input,
                                     unsigned char * abyp_output,
                                     const ds_aes_key * adsp_key,
                                     size_t szp_block_count,
                                     unsigned char * abyp_iv,
                                     int imp_rounds)
{
   unsigned char aucl_temp_cipher_block[AES_BLOCK_SIZE]; //Output from actual AES calls
   unsigned int uml_blocks_written = 0;                   //Number of bytes encrypted so far
   // Start with IV
   for(;uml_blocks_written < szp_block_count; uml_blocks_written++){ //Decrypt byte by byte
      m_aes_raw_encrypt(abyp_iv, aucl_temp_cipher_block, adsp_key, imp_rounds);
      // XOR DWORD-wise
      ((int*)abyp_output)[0] = ((const int*)abyp_input)[0] ^ ((int*)aucl_temp_cipher_block)[0];
      ((int*)abyp_output)[1] = ((const int*)abyp_input)[1] ^ ((int*)aucl_temp_cipher_block)[1];
      ((int*)abyp_output)[2] = ((const int*)abyp_input)[2] ^ ((int*)aucl_temp_cipher_block)[2];
      ((int*)abyp_output)[3] = ((const int*)abyp_input)[3] ^ ((int*)aucl_temp_cipher_block)[3];
      // update pointers
      abyp_iv = abyp_output;
      abyp_input += AES_BLOCK_SIZE;
      abyp_output += AES_BLOCK_SIZE;
   }
}

extern "C" void m_aes_cfb128_decrypt(const unsigned char * abyp_input,
                                     unsigned char * abyp_output,
                                     const ds_aes_key * adsp_key,
                                     size_t szp_block_count,
                                     unsigned char * abyp_iv,
                                     int imp_rounds)
{
   unsigned char aucl_temp_cipher_block[AES_BLOCK_SIZE]; //Output from actual AES calls
   unsigned char aucl_temp_in_block[AES_BLOCK_SIZE];     //Input for actual AES calls
   unsigned int uml_blocks_written = 0;                   //Number of bytes encrypted so far
   // Start with IV
   memcpy(aucl_temp_in_block,abyp_iv,AES_BLOCK_SIZE);
   for(;uml_blocks_written < szp_block_count; uml_blocks_written++){ //Decrypt byte by byte
      m_aes_ecb_encrypt(aucl_temp_in_block, aucl_temp_cipher_block, adsp_key, 1, imp_rounds);

      // Fetch next block, THEN XOR
      memcpy(aucl_temp_in_block, abyp_input, AES_BLOCK_SIZE);
      ((int*)abyp_output)[0] = ((const int*)abyp_input)[0] ^ ((int*)aucl_temp_cipher_block)[0];
      ((int*)abyp_output)[1] = ((const int*)abyp_input)[1] ^ ((int*)aucl_temp_cipher_block)[1];
      ((int*)abyp_output)[2] = ((const int*)abyp_input)[2] ^ ((int*)aucl_temp_cipher_block)[2];
      ((int*)abyp_output)[3] = ((const int*)abyp_input)[3] ^ ((int*)aucl_temp_cipher_block)[3];

      // increment pointers
      abyp_input += AES_BLOCK_SIZE;
      abyp_output += AES_BLOCK_SIZE;
   }
}

//========================================================
//
// AES CPU functions
//
//========================================================
#if defined USE_ASSEMBLER_SOURCES

#if (defined _WIN32)
#include <intrin.h>

#define AES_NI_FLAG 0x2000000
#define PCLMULDQ_FLAG 0x02
#define SSSE3_FLAG 0x100
// For Microsoft Compiler only! UNIX uses assembler
extern "C" int m_check_cpu_support_aes()
{
    //TODO:
    // Add PCLMULDQ, when implemented
  int imlr_info[4];
  __cpuid(imlr_info,1);
  if(imlr_info[2] & AES_NI_FLAG) {
      if((imlr_info[2] & PCLMULDQ_FLAG) && (imlr_info[2] & SSSE3_FLAG)) {
          return USE_CPU_AES_GCM_FLAG | USE_CPU_AES_FLAG; 
      }
      return USE_CPU_AES_FLAG;
  }
  return 0;
}
#endif

#if (defined __APPLE__) && (defined __aarch64__) && (TARGET_OS_IPHONE==1)
//All Apple A7+ chips (i.e. all Apple ARM AArch64 chips) have AES capability
//Older, non-v8 is excluded via __aarch64__ check
//Non-Iphone MacOS on other ARMv8 is excluded via Apple's TARGET checks

extern "C" int m_check_cpu_support_aes()
{
  return 5;
}
#endif

#if (!defined _WIN32) && (defined HL_LINUX_ARM)
// On ARM/AArch64 architectures, CPU feature inquiries require EL1

#define DEF_AES_CPU_CAPABILITY_NONE             0
#define DEF_AES_CPU_CAPABILITY_AES_ONLY         1
#define DEF_AES_CPU_CAPABILITY_AES_PMUL         5

#define DEF_CPUINFO_FILE_LINE_BUFFER_LENGTH     1024

static int m_set_aes_cpu_capability();

static int ims_aes_cpu_capability = m_set_aes_cpu_capability();

extern "C" int m_check_cpu_support_aes()
{
    return ims_aes_cpu_capability;
}

static int m_set_aes_cpu_capability(){
    //no cpuinfo API available in *nix
    //open "/proc/cpuinfo" file and search it for "aes" string
    //format of that file is not standardized between platforms, thus simple strstr search
    FILE* adsl_procinfo;
    adsl_procinfo = fopen("/proc/cpuinfo","r");
    if (adsl_procinfo == NULL){
        return DEF_AES_CPU_CAPABILITY_NONE;
    }
    char achl_line_buffer[DEF_CPUINFO_FILE_LINE_BUFFER_LENGTH];
    while ((!ferror(adsl_procinfo)) && (!feof(adsl_procinfo)))
    {
        // read linewise, continue; on error
        if (fgets(achl_line_buffer,DEF_CPUINFO_FILE_LINE_BUFFER_LENGTH,adsl_procinfo) == NULL){
            continue;
        }
        //search for string (case insensitive)
#ifdef _GNU_SOURCE
        char* achl_pos_aes = strcasestr(achl_line_buffer,"aes");
#else
        char* achl_pos_aes = strstr(achl_line_buffer,"aes");
        if (achl_pos_aes==NULL){
            achl_pos_aes = strstr(achl_line_buffer,"AES");
        }
        if (achl_pos_aes==NULL){
            achl_pos_aes = strstr(achl_line_buffer,"Aes");
        }
#endif
        if (achl_pos_aes==NULL){
            //go to next line if not found
            continue;
        }
        if ((achl_pos_aes - achl_line_buffer) > 0){
            //If found, check if the preceding character is whitespace, ':', or start of line. If no, it is likely part of a larger word. Avoid false positives.
            if ((!isspace(achl_pos_aes[-1])) && (achl_pos_aes[-1] != ':')){
                continue;
            }
        }
        //AES capability is confirmed, check for 'pmul'
#ifdef _GNU_SOURCE
        char* achl_pos_pmul = strcasestr(achl_line_buffer,"pmul");
#else
        char* achl_pos_pmul = strstr(achl_line_buffer,"pmul");
        if (achl_pos_pmul==NULL){
            achl_pos_pmul = strstr(achl_line_buffer,"PMUL");
        }
        if (achl_pos_pmul==NULL){
            achl_pos_pmul = strstr(achl_line_buffer,"Pmul");
        }
#endif
        fclose(adsl_procinfo);
        if (achl_pos_pmul==NULL){
            return DEF_AES_CPU_CAPABILITY_AES_ONLY;
        } else {
            return DEF_AES_CPU_CAPABILITY_AES_PMUL;
        }
    }
    fclose(adsl_procinfo);
    return DEF_AES_CPU_CAPABILITY_NONE;
}
#endif

//==============================================================

extern "C" void m_aes_cpu_set_encrypt_key(const unsigned char * abyp_userkey,
                                          const size_t szp_dwords,
                                          ds_aes_key * adsp_key)
{
  if(szp_dwords == 4)
    m_aes_128_cpu_key_expansion(abyp_userkey,(unsigned char *) adsp_key);
  else if(szp_dwords == 6)
    m_aes_192_cpu_key_expansion(abyp_userkey,(unsigned char *) adsp_key);
  else
    m_aes_256_cpu_key_expansion(abyp_userkey,(unsigned char *) adsp_key);
}

extern "C" void m_aes_cpu_set_decrypt_key(const unsigned char * abyp_userkey,
                                          const size_t szp_dwords,
                                          ds_aes_key * adsp_key)
{
  size_t szl_nr;
  ds_aes_key dsl_temp_key;

  m_aes_cpu_set_encrypt_key(abyp_userkey,szp_dwords,&dsl_temp_key);

  szl_nr = szp_dwords + 6;	// number of rounds
  m_aes_cpu_revert_key((unsigned char *) &dsl_temp_key,
	                   (unsigned char *) adsp_key,szl_nr);
}

#endif //defined USE_ASSEMBLER_SOURCES

extern "C" void m_aes_cbc_cts_encrypt(const unsigned char * abyp_input,
                                      unsigned char * abyp_output,
                                      const ds_aes_key * adsp_key,
                                      size_t szp_input_len,
                                      unsigned char * abyp_iv,
                                      int imp_rounds)
{
   if( AES_BLOCK_SIZE >= szp_input_len ){
      if( AES_BLOCK_SIZE == szp_input_len ){
         m_aes_raw_encrypt(abyp_input, abyp_output, adsp_key, imp_rounds);
      }
      return;
   }

   size_t szl_cbc_blocks= (szp_input_len-1)/AES_BLOCK_SIZE;    // Number of blocks for CBC processing
   size_t szl_last_block_len= ((szp_input_len-1)%              // Bytes in the last block
      AES_BLOCK_SIZE)+1;
   size_t szl_last_block_offset=szp_input_len-                 // Offset of the last block in bytes
      szl_last_block_len;
   unsigned char byrl_last_block[AES_BLOCK_SIZE];                    // Temporary storage for last block to avoid overwriting on in-place encryption

   memset(byrl_last_block, 0, AES_BLOCK_SIZE);
   memcpy(byrl_last_block, (abyp_input+szl_last_block_offset), szl_last_block_len);

   // We do normal CBC for all but the last block
   m_aes_cbc_encrypt(abyp_input, abyp_output, adsp_key, szl_cbc_blocks, abyp_iv,
      imp_rounds);

   // Now we do the CTS processing of last two blocks
   abyp_output +=(szl_last_block_offset-AES_BLOCK_SIZE);
   memcpy(abyp_output+AES_BLOCK_SIZE,abyp_output, szl_last_block_len);

   m_aes_block_xor(abyp_output, byrl_last_block, byrl_last_block);

   m_aes_raw_encrypt(byrl_last_block, abyp_output, adsp_key, imp_rounds);
   m_sec_zero_mem(byrl_last_block, AES_BLOCK_SIZE);
}

extern "C" void m_aes_cbc_cts_decrypt(const unsigned char * abyp_input,
                                  unsigned char * abyp_output,
                                  const ds_aes_key * adsp_key,
                                  size_t szp_input_len,
                                  unsigned char * abyp_iv,
                                  int imp_rounds)
{
   if( AES_BLOCK_SIZE >= szp_input_len ){
      if( AES_BLOCK_SIZE == szp_input_len ){
         m_aes_raw_decrypt(abyp_input, abyp_output, adsp_key, imp_rounds);
      }
      return;
   }

   size_t szl_cbc_blocks= (szp_input_len-(AES_BLOCK_SIZE+1))                // Number of blocks for CBC processing
      /AES_BLOCK_SIZE; 
   size_t szl_second_last_offset = szl_cbc_blocks*AES_BLOCK_SIZE;           // Offset of the second to last block
   unsigned char byrl_second_last[AES_BLOCK_SIZE];                          // Second last ciphertext block

   unsigned char byrl_last_block[AES_BLOCK_SIZE];                           // Last ciphertext block, 0-padded as needed
   size_t szl_last_block_offset = szl_second_last_offset+                   // Offset of the last block
      AES_BLOCK_SIZE;
   size_t szl_last_block_len= ((szp_input_len-1)%                           // Bytes in the last block
      AES_BLOCK_SIZE)+1;
   
   // We decrypt the second to last cipher block into the last output block and
   // complete the last ciphertext block. Local buffers are used for proper in-place processing.
   memset(byrl_last_block, 0, AES_BLOCK_SIZE);
   memcpy(byrl_last_block, abyp_input+szl_last_block_offset, szl_last_block_len);

   m_aes_raw_decrypt(abyp_input+szl_second_last_offset, byrl_second_last, 
      adsp_key, imp_rounds);

   m_aes_block_xor(byrl_last_block, byrl_second_last, byrl_second_last);
   memcpy(abyp_output+szl_last_block_offset, byrl_second_last, szl_last_block_len);
   
   memcpy(byrl_last_block+szl_last_block_len, byrl_second_last+szl_last_block_len, 
      AES_BLOCK_SIZE-szl_last_block_len);

   // Here we process the completed block and possible other blocks
   m_aes_raw_decrypt(byrl_last_block, abyp_output+szl_second_last_offset, 
      adsp_key, imp_rounds);
   if( 0 != szl_cbc_blocks ){
      m_aes_block_xor(abyp_input+szl_second_last_offset-AES_BLOCK_SIZE, 
         abyp_output+szl_second_last_offset, abyp_output+szl_second_last_offset);
      m_aes_cbc_decrypt(abyp_input, abyp_output, adsp_key, szl_cbc_blocks,
         abyp_iv, imp_rounds);
   } else {
      m_aes_block_xor(abyp_iv, byrl_last_block, byrl_last_block);
   }


   m_sec_zero_mem(byrl_second_last, AES_BLOCK_SIZE);
   m_sec_zero_mem(byrl_last_block, AES_BLOCK_SIZE);
}

#ifdef USE_ASSEMBLER_SOURCES
/**
Performs a block-wise AES CTR using AES NI.

The IV input is overwritten with an extra counter block, that can be XORed into 
the last incomplete block. This greatly simplifies the assembler code.

Length is counted in block, NOT in bytes!

@param[in]      abyp_input      Pointer to the input buffer.
@param[out]     abyp_output     Pointer to the output buffer.
@param[in]      adsp_key        Pointer to the key structure.
@param[in]      szp_block_count Number of 16 byte AES blocks.
@param[inout]   abyp_iv         IN: Pointer to the IV.
                                OUT: Filled with the last counter block.
@param[in]      inp_rounds      Number of AES rounds.
*/
extern "C" void m_aes_ctr_cpu(const unsigned char * abyp_input,
                              unsigned char * abyp_output,
                              const ds_aes_key * adsp_key,
                              size_t szp_block_count,
                              unsigned char * abyp_iv,
                              int inp_rounds);

/**
This static function delegates the AES CTR to the CPU implementation.

It prevents optimization errors on MSVC 11.
*/
static void m_do_cpu_aes_ctr(const unsigned char * abyp_input,
                             size_t szp_input_len,
                             unsigned char * abyp_output,
                             const ds_aes_key * adsp_key,
                             const unsigned char * abyp_iv,
                             int inp_rounds)
{
    // We store the IV, as it is overwritten by m_aes_ctr_cpu
    unsigned char byrl_temp_iv[AES_BLOCK_SIZE];
    memcpy(byrl_temp_iv, abyp_iv, AES_BLOCK_SIZE);
    m_aes_ctr_cpu(abyp_input, 
                  abyp_output,
                  adsp_key, 
                  szp_input_len/AES_BLOCK_SIZE, 
                  byrl_temp_iv, 
                  inp_rounds);
    size_t szl_single_bytes = szp_input_len%16;
    if(szl_single_bytes != 0){
        size_t szl_offset = (szp_input_len - szl_single_bytes);
        while(szl_single_bytes > 0){
            szl_single_bytes--;
            abyp_output[szl_single_bytes+szl_offset] = abyp_input[szl_single_bytes+szl_offset] 
                                                       ^ byrl_temp_iv[szl_single_bytes];
        }
        m_sec_zero_mem(byrl_temp_iv, AES_BLOCK_SIZE);
    }
    return;
}
#endif

extern "C" void m_aes_ctr(const unsigned char * input,
                          size_t input_length,
                          unsigned char * output,
                          const ds_aes_key * pEncKeyStruc,
                          const unsigned char * IVector,
                          int Rounds)
{
#ifdef USE_ASSEMBLER_SOURCES
    if( (pEncKeyStruc->im_flags & USE_CPU_AES_FLAG) != 0){
        m_do_cpu_aes_ctr(input,
                         input_length,
                         output,
                         pEncKeyStruc,
                         IVector,
                         Rounds);
        return;
    }
#endif

  const unsigned int * EncKeyTab = (const unsigned int *) pEncKeyStruc->byr_key; //special settings

  unsigned int Sn[4]; //array holding the aes state
  unsigned int t0,t1,t2,t3; //for round calculations
  unsigned int s[4]; //holds intermediate values for output
  unsigned int CB[4]; //contains the counter block

  unsigned char last[16]; //holds the last partial block
  int i; //counter

  //-----------------------------------------------------------
  // Calculate number of Blocks
  //-----------------------------------------------------------
  size_t BlkCnt = input_length/AES_BLOCK_SIZE; //get number of complete 128bit blocks 
  int reminder = input_length%AES_BLOCK_SIZE; //BYTEs of the partial block

  //-----------------------------------------------------------
  // load IV Vector ; Initial Counter Block ICB
  //-----------------------------------------------------------
#if defined _WIN32 && ! defined _M_IA64 && !defined WINCE // AG added && !defined WINCE
  CB[0] = * (unsigned int *) (IVector+0);
  CB[1] = * (unsigned int *) (IVector+4);
  CB[2] = * (unsigned int *) (IVector+8);
  CB[3] = * (unsigned int *) (IVector+12);

#else // other OSs, JAVA
  char2longn(IVector,CB[0],0);		// get bytes 0-3
  char2longn(IVector,CB[1],4);		// get bytes 4-7
  char2longn(IVector,CB[2],8);		// get bytes 8-11
  char2longn(IVector,CB[3],12);	    // get bytes 12-15
#endif

  // Read the counter as big endian number
  unsigned int unl_cnt;
  BIGchar2longn(IVector,unl_cnt,12);
  //-----------------------------------------------------------
  // Encrypt Blocks, full unrolled loops
  //-----------------------------------------------------------
  for(;BlkCnt > 0;BlkCnt--)
  {

	Sn[0] = CB[0]  ^ EncKeyTab[0];
    Sn[1] = CB[1]  ^ EncKeyTab[1];
    Sn[2] = CB[2]  ^ EncKeyTab[2];
    Sn[3] = CB[3]  ^ EncKeyTab[3];

    //-------------------------------------------------
    // Perform Table processing for all 10/12/14 rounds
    //-------------------------------------------------
    AES_ENC_ROUND(t0,t1,t2,t3,Sn[0],Sn[1],Sn[2],Sn[3],EncKeyTab,0);	// Round 1
    AES_ENC_ROUND(Sn[0],Sn[1],Sn[2],Sn[3],t0,t1,t2,t3,EncKeyTab,1);	// Round 2
    AES_ENC_ROUND(t0,t1,t2,t3,Sn[0],Sn[1],Sn[2],Sn[3],EncKeyTab,2);	// Round 3
    AES_ENC_ROUND(Sn[0],Sn[1],Sn[2],Sn[3],t0,t1,t2,t3,EncKeyTab,3);	// Round 4
    AES_ENC_ROUND(t0,t1,t2,t3,Sn[0],Sn[1],Sn[2],Sn[3],EncKeyTab,4);	// Round 5
    AES_ENC_ROUND(Sn[0],Sn[1],Sn[2],Sn[3],t0,t1,t2,t3,EncKeyTab,5);	// Round 6
    AES_ENC_ROUND(t0,t1,t2,t3,Sn[0],Sn[1],Sn[2],Sn[3],EncKeyTab,6);	// Round 7
    AES_ENC_ROUND(Sn[0],Sn[1],Sn[2],Sn[3],t0,t1,t2,t3,EncKeyTab,7);	// Round 8
    AES_ENC_ROUND(t0,t1,t2,t3,Sn[0],Sn[1],Sn[2],Sn[3],EncKeyTab,8);	// Round 9

    if(Rounds == 14)					// AES-256
    {
      AES_ENC_ROUND(Sn[0],Sn[1],Sn[2],Sn[3],t0,t1,t2,t3,EncKeyTab,9);  // Round 10
      AES_ENC_ROUND(t0,t1,t2,t3,Sn[0],Sn[1],Sn[2],Sn[3],EncKeyTab,10); // Round 11
      AES_ENC_ROUND(Sn[0],Sn[1],Sn[2],Sn[3],t0,t1,t2,t3,EncKeyTab,11); // Round 12
      AES_ENC_ROUND(t0,t1,t2,t3,Sn[0],Sn[1],Sn[2],Sn[3],EncKeyTab,12); // Round 13
      AES_ENC_LAST_ROUND(Sn[0],Sn[1],Sn[2],Sn[3],t0,t1,t2,t3,EncKeyTab,13);//Round 14
    }
    else if(Rounds == 12)				// AES-192
    {
      AES_ENC_ROUND(Sn[0],Sn[1],Sn[2],Sn[3],t0,t1,t2,t3,EncKeyTab,9); // Round 10
      AES_ENC_ROUND(t0,t1,t2,t3,Sn[0],Sn[1],Sn[2],Sn[3],EncKeyTab,10);// Round 11
      AES_ENC_LAST_ROUND(Sn[0],Sn[1],Sn[2],Sn[3],t0,t1,t2,t3,EncKeyTab,11);//Round 12
    }
    else
    {
      AES_ENC_LAST_ROUND(Sn[0],Sn[1],Sn[2],Sn[3],t0,t1,t2,t3,EncKeyTab,9);// Round 10
    }

    //reverse input endianness if needed 	
#if defined _WIN32 && !defined _M_IA64 && !defined WINCE // AG added && !defined WINCE
    s[0] = * (unsigned int *) (input+0);
    s[1] = * (unsigned int *) (input+4);
    s[2] = * (unsigned int *) (input+8);
    s[3] = * (unsigned int *) (input+12);
#else // other OSs, JAVA
    char2longn(input,s[0],0);		// get bytes 0-3
    char2longn(input,s[1],4);		// get bytes 4-7
    char2longn(input,s[2],8);		// get bytes 8-11
    char2longn(input,s[3],12);		// get bytes 12-15
#endif
    //Xoring output block with plaintext
	((uint64_t*)(Sn))[0] ^= ((uint64_t*)(s))[0];
	((uint64_t*)(Sn))[1] ^= ((uint64_t*)(s))[1];

    //reversing endianness for output
#if defined _WIN32 && !defined _M_IA64 && !defined WINCE // AG added && !defined WINCE
    *(unsigned int *) (output+0)  = Sn[0];
    *(unsigned int *) (output+4)  = Sn[1];
    *(unsigned int *) (output+8)  = Sn[2];
    *(unsigned int *) (output+12) = Sn[3];
	//increase function for LE 32 bit

#else // other OSs, JAVA
    long2charn(Sn[0],output,0);
    long2charn(Sn[1],output,4);
    long2charn(Sn[2],output,8);
    long2charn(Sn[3],output,12);

#endif

	//increase function 32bit
	unl_cnt++;

    // Here, we have to distinguish between BE and LE machines
    // Using BIGlong2charn on BE machines would result in errors
#ifndef HL_BIG_ENDIAN
    BIGlong2charn(unl_cnt,((unsigned char*)(&CB[3])),0);
#else
    long2charn(unl_cnt,((unsigned char*)(&CB[3])),0);
#endif

	//for loop
    input  += 16;
    output += 16;
  }
 
/*******************************************************************************************/
//  FULL BLOCKS DONE!
/*******************************************************************************************/

 //-----------------------------------------------------------
 // Last Block is partial?
 //----------------------------------------------------------- 
  if(reminder!=0){		
	//do remaining opertaions with the uncompleted block left

	Sn[0] = CB[0]  ^ EncKeyTab[0];
    Sn[1] = CB[1]  ^ EncKeyTab[1];
    Sn[2] = CB[2]  ^ EncKeyTab[2];
    Sn[3] = CB[3]  ^ EncKeyTab[3];

    //-------------------------------------------------
    // Perform Table processing for all 10/12/14 rounds
    //-------------------------------------------------
    AES_ENC_ROUND(t0,t1,t2,t3,Sn[0],Sn[1],Sn[2],Sn[3],EncKeyTab,0);	// Round 1
    AES_ENC_ROUND(Sn[0],Sn[1],Sn[2],Sn[3],t0,t1,t2,t3,EncKeyTab,1);	// Round 2
    AES_ENC_ROUND(t0,t1,t2,t3,Sn[0],Sn[1],Sn[2],Sn[3],EncKeyTab,2);	// Round 3
    AES_ENC_ROUND(Sn[0],Sn[1],Sn[2],Sn[3],t0,t1,t2,t3,EncKeyTab,3);	// Round 4
    AES_ENC_ROUND(t0,t1,t2,t3,Sn[0],Sn[1],Sn[2],Sn[3],EncKeyTab,4);	// Round 5
    AES_ENC_ROUND(Sn[0],Sn[1],Sn[2],Sn[3],t0,t1,t2,t3,EncKeyTab,5);	// Round 6
    AES_ENC_ROUND(t0,t1,t2,t3,Sn[0],Sn[1],Sn[2],Sn[3],EncKeyTab,6);	// Round 7
    AES_ENC_ROUND(Sn[0],Sn[1],Sn[2],Sn[3],t0,t1,t2,t3,EncKeyTab,7);	// Round 8
    AES_ENC_ROUND(t0,t1,t2,t3,Sn[0],Sn[1],Sn[2],Sn[3],EncKeyTab,8);	// Round 9

    if(Rounds == 14)					// AES-256
    {
      AES_ENC_ROUND(Sn[0],Sn[1],Sn[2],Sn[3],t0,t1,t2,t3,EncKeyTab,9);  // Round 10
      AES_ENC_ROUND(t0,t1,t2,t3,Sn[0],Sn[1],Sn[2],Sn[3],EncKeyTab,10); // Round 11
      AES_ENC_ROUND(Sn[0],Sn[1],Sn[2],Sn[3],t0,t1,t2,t3,EncKeyTab,11); // Round 12
      AES_ENC_ROUND(t0,t1,t2,t3,Sn[0],Sn[1],Sn[2],Sn[3],EncKeyTab,12); // Round 13
      AES_ENC_LAST_ROUND(Sn[0],Sn[1],Sn[2],Sn[3],t0,t1,t2,t3,EncKeyTab,13);//Round 14
    }
    else if(Rounds == 12)				// AES-192
    {
      AES_ENC_ROUND(Sn[0],Sn[1],Sn[2],Sn[3],t0,t1,t2,t3,EncKeyTab,9); // Round 10
      AES_ENC_ROUND(t0,t1,t2,t3,Sn[0],Sn[1],Sn[2],Sn[3],EncKeyTab,10);// Round 11
      AES_ENC_LAST_ROUND(Sn[0],Sn[1],Sn[2],Sn[3],t0,t1,t2,t3,EncKeyTab,11);//Round 12
    }
    else
    {
      AES_ENC_LAST_ROUND(Sn[0],Sn[1],Sn[2],Sn[3],t0,t1,t2,t3,EncKeyTab,9);// Round 10
    }

//reverse input endianness if needed 
#if defined _WIN32 && !defined _M_IA64 && !defined WINCE // AG added && !defined WINCE
		*(unsigned int *) (last+0)  = Sn[0];
		*(unsigned int *) (last+4)  = Sn[1];
		*(unsigned int *) (last+8)  = Sn[2];
		*(unsigned int *) (last+12) = Sn[3];
#else // other OSs, JAVA
		long2charn(Sn[0],last,0);
		long2charn(Sn[1],last,4);
		long2charn(Sn[2],last,8);
		long2charn(Sn[3],last,12);
#endif

	for (i=0;i<reminder;i++)
	{
		*output = *input^last[i];
		output++;input++;
	}

  }

}

#define AES_GCM_GHASH_INNER_ROUND(BIT) do{ \
    /* xi = 1? */ \
    if ( IS_SET_BIT(abyr_h[im_byte_cntr],BIT) ){\
        /* Zi+1 = Zi xor Vi */ \
        ul_z_low ^= ul_v_low; \
        ul_z_high ^= ul_v_high; \
    } \
    /* This mask R, using bit V_127. Makes it 0, if the bit is not set. */ \
    uint64_t ull_r_masked = GF128_MODULO_U64 & (((uint64_t)0)-(ul_v_high & 0x01)); \
    /*Vi+1 = (Vi>>1) xor R */ \
    ul_v_high >>= 1; \
    ul_v_high |= ul_v_low << 63; \
    ul_v_low >>= 1; \
    ul_v_low ^= ull_r_masked;\
}while(FALSE)

static inline void m_ghash(const unsigned char* abyr_h,
                           const unsigned char* abyr_x,
                           unsigned char* abyr_y)
{

    int im_byte_cntr; 
    int im_bit_cntr; 

    unsigned long long aulr_x[2]; /*data to hash in 64u[2]*/
    unsigned long long aulr_y[2]; /*output/state in u64[2]*/

    unsigned long long ul_z_high,ul_z_low; 
    unsigned long long ul_v_high,ul_v_low; 

    //copy input 
    BIGchar2longlongn(abyr_x,aulr_x[0],0);
    BIGchar2longlongn(abyr_x,aulr_x[1],8);
    BIGchar2longlongn(abyr_y,aulr_y[0],0);
    BIGchar2longlongn(abyr_y,aulr_y[1],8);

    //update state
    aulr_y[0] ^= aulr_x[0];
    aulr_y[1] ^= aulr_x[1];

    //Z0 = 0^128
    ul_z_low = 0;
    ul_z_high = 0; 
    //V0 = Y 
    ul_v_low = aulr_y[0];
    ul_v_high = aulr_y[1]; 

    //x0,x1.. to x128
    for (im_byte_cntr = 0; im_byte_cntr < AES_BLOCK_SIZE; im_byte_cntr++) {
            AES_GCM_GHASH_INNER_ROUND(7);
            AES_GCM_GHASH_INNER_ROUND(6);
            AES_GCM_GHASH_INNER_ROUND(5);
            AES_GCM_GHASH_INNER_ROUND(4);
            AES_GCM_GHASH_INNER_ROUND(3);
            AES_GCM_GHASH_INNER_ROUND(2);
            AES_GCM_GHASH_INNER_ROUND(1);
            AES_GCM_GHASH_INNER_ROUND(0);
    }

    //output
    aulr_y[0] = ul_z_low;
    aulr_y[1] = ul_z_high;
    BIGlonglong2charn(aulr_y[0],abyr_y,0);
    BIGlonglong2charn(aulr_y[1],abyr_y,AES_BLOCK_SIZE/2);

}/*END OF function m_ghash(...)*/

extern "C" int m_aes_gcm_auth_enc(unsigned char* abyr_iv,
                                  size_t sz_iv_len,
                                  unsigned char* abyr_auth_data,
                                  size_t sz_auth_data_len,
                                  const ds_aes_key* c_enc_key,
                                  unsigned int um_key_len,
                                  unsigned char* abyr_plaintext,
                                  size_t sz_plaintext_len,
                                  unsigned char* abyr_ciphertext,
                                  size_t sz_dest_buff_len,
                                  unsigned char* abyr_mac_tag,
                                  unsigned int um_mac_tag_len)
{
    //-----------------------------------------------------------
    // VARIABLES INITIALITATION
    //-----------------------------------------------------------
    ALIGN16 dsd_aes_gcm_state dsl_state;
    //-----------------------------------------------------------
    // PARAMETER VALIDATION
    //-----------------------------------------------------------
    if (sz_plaintext_len > sz_dest_buff_len)
        return GCM_DST_BUFFER_TOO_SMALL;
    if(((abyr_plaintext == NULL) && (sz_plaintext_len != 0))
        || (c_enc_key == NULL)
        || ((abyr_iv == NULL)) && (sz_iv_len != 0))
        return GCM_NULL_PTR;
	if (sz_plaintext_len > MAX_PLAINTEXT_LENGTH)
        return GCM_PARAM_ERR;
    //sz_auth_data_len is always guaranted to be under 2^64 due to size_t max capacity
    //sz_iv_len is always guaranted to be under 2^64 due to size_t max capacity
    //both evaluations have been ovbiated to improve performance
	if (sz_iv_len < 1)
        return GCM_PARAM_ERR;
    if ( 
         ((um_mac_tag_len != ALLOWED_TAG_SIZE[0])
          && (um_mac_tag_len != ALLOWED_TAG_SIZE[1]) 
          && (um_mac_tag_len != ALLOWED_TAG_SIZE[2]) 
          && (um_mac_tag_len != ALLOWED_TAG_SIZE[3]) 
          && (um_mac_tag_len != ALLOWED_TAG_SIZE[4]) 
          && (um_mac_tag_len != ALLOWED_TAG_SIZE[5]) 
          && (um_mac_tag_len != ALLOWED_TAG_SIZE[6]) 
         )
      )
        return GCM_PARAM_ERR;
    if ( 
         ((um_key_len != ALLOWED_KEY_SIZE[0])
          && (um_key_len != ALLOWED_KEY_SIZE[1]) 
          && (um_key_len != ALLOWED_KEY_SIZE[2]) 
         )
      )
		return GCM_PARAM_ERR;
    if (sz_iv_len == 0)
        return GCM_PARAM_ERR;    
    //-----------------------------------------------------------
    // SINGLE STEP ENCRYPTION
    //-----------------------------------------------------------
    m_init_aes_gcm_1(&dsl_state, (char*)abyr_auth_data, (int)sz_auth_data_len,
        (char*)abyr_iv, (int)sz_iv_len, c_enc_key, (int)um_key_len);
    m_enc_update_aes_gcm_1(&dsl_state, (char*)abyr_ciphertext, (char*)abyr_plaintext, (int)sz_plaintext_len);
    m_enc_final_aes_gcm_1(&dsl_state, (char*)abyr_mac_tag, (int)um_mac_tag_len);
    return GCM_OK;
}/*function aes_gcm_aek(...)*/

extern "C" int m_aes_gcm_auth_dec(unsigned char* abyr_iv,
                                  size_t sz_iv_len,
                                  unsigned char* abyr_auth_data,
                                  size_t sz_auth_data_len,
                                  const ds_aes_key* c_enc_key,
                                  unsigned int um_key_len,
                                  unsigned char* abyr_ciphertext,
                                  size_t sz_ciphertext_len,
                                  unsigned char* abyr_plaintext,
                                  size_t sz_dest_buff_len,
                                  unsigned char* abyr_mac_tag,
                                  unsigned int um_mac_tag_len)
{
    //-----------------------------------------------------------
    // VARIABLES INITIALITATION
    //-----------------------------------------------------------
    ALIGN16 dsd_aes_gcm_state dsl_state;
    BOOL iel_auth_success;
    //-----------------------------------------------------------
    // PARAMETER VALIDATION
    //-----------------------------------------------------------
    if (sz_ciphertext_len > sz_dest_buff_len)
        return GCM_DST_BUFFER_TOO_SMALL;
    if (((abyr_ciphertext == NULL) && (sz_ciphertext_len != 0))
        || (c_enc_key == NULL)
        || ((abyr_iv == NULL) && (sz_iv_len != 0)))
        return GCM_NULL_PTR;  
    if (sz_ciphertext_len > MAX_CIPHERTEXT_LENGTH)
        return GCM_PARAM_ERR;
    //sz_auth_data_len is always guaranted to be under 2^64 due to size_t max capacity
    //sz_iv_len is always guaranted to be under 2^64 due to size_t max capacity
    //both evaluations have been ovbiated to improve performance
	if (sz_iv_len < 1)
        return GCM_PARAM_ERR;
    if ( 
         ((um_mac_tag_len != ALLOWED_TAG_SIZE[0])
          && (um_mac_tag_len != ALLOWED_TAG_SIZE[1]) 
          && (um_mac_tag_len != ALLOWED_TAG_SIZE[2]) 
          && (um_mac_tag_len != ALLOWED_TAG_SIZE[3]) 
          && (um_mac_tag_len != ALLOWED_TAG_SIZE[4]) 
          && (um_mac_tag_len != ALLOWED_TAG_SIZE[5]) 
          && (um_mac_tag_len != ALLOWED_TAG_SIZE[6]) 
         )
      )
        return GCM_PARAM_ERR;
    if ( 
         ((um_key_len != ALLOWED_KEY_SIZE[0])
          && (um_key_len != ALLOWED_KEY_SIZE[1]) 
          && (um_key_len != ALLOWED_KEY_SIZE[2]) 
         )
      )
		return GCM_PARAM_ERR;
    if (sz_iv_len == 0)
        return GCM_PARAM_ERR;
    //-----------------------------------------------------------
    // SINGLE STEP DECREPTION
    //-----------------------------------------------------------
    m_init_aes_gcm_1(&dsl_state, (char*)abyr_auth_data, (int)sz_auth_data_len,
        (char*)abyr_iv, (int)sz_iv_len, c_enc_key, (int)um_key_len);
    m_dec_update_aes_gcm_1(&dsl_state, (char*)abyr_plaintext, (char*)abyr_ciphertext, (int)sz_ciphertext_len);
    iel_auth_success = m_dec_final_aes_gcm_1(&dsl_state, (char*)abyr_mac_tag, (int)um_mac_tag_len);
    //-----------------------------------------------------------
    // AUTHENTICATION
    //-----------------------------------------------------------
    if (iel_auth_success == FALSE)
    {
        // Scrub result if failed  
        m_sec_zero_mem(abyr_plaintext,sz_ciphertext_len);
        return GCM_AUTH_FAIL;
    }
    return GCM_OK;
}/*END OF function m_aes_gcm_auth_dec(...)*/

/**
*  Get a mac for the given authenticated data in AES GCM mode.
*
*  @param [in] abyr_iv  Initialitation vector
*  @param [in] sz_iv_len  IV length in bytes
*  @param [in] abyr_auth_data  authenticated data 
*  @param [in] sz_auth_data_len  authenticated data in bytes
*  @param [in] c_enc_key  keyset to use
*  @param [in] um_key_len  length of the key in bytes
*  @param [in,out] abyr_mac_tag  output authentication tag
*  @param [in] um_mac_tag_len  tag length in bytes
*
*  @return output  error code or "ok" code and tag if success
*
*	will yield error code if something goes wrong and 0 otherwise.
*	If everything is correct an authentication tag for the input will be handed back
*	
*		return values:
*				GCM_OK	0 - everything ok
*				GCM_NULL_PTR -1 - some input is missing/empty
*				GCM_PARAM_ERR -3 - parameters given do not match the requirements
*
*/
extern "C" int m_aes_gcm_mac(unsigned char* abyr_iv,
                             size_t sz_iv_len,
                             unsigned char* abyr_auth_data,
                             size_t sz_auth_data_len,
                             const ds_aes_key* c_enc_key,
                             unsigned int um_key_len,
                             unsigned char* abyr_mac_tag,
                             unsigned int um_mac_tag_len)
{
    if((c_enc_key == NULL) || (abyr_iv == NULL))
        return GCM_NULL_PTR;
    return m_aes_gcm_auth_enc(abyr_iv,sz_iv_len,abyr_auth_data,sz_auth_data_len,c_enc_key,um_key_len,NULL,0,NULL,0,abyr_mac_tag,um_mac_tag_len);
}/*END OF function m_aes_gcm_mac (...)*/

/**
*  Calculate mac in AES GCM mode for the given authenticated data and compare it
*  with a given mac.
*
*  @param [in] abyr_iv  Initialitation vector
*  @param [in] sz_iv_len  IV length in bytes
*  @param [in] abyr_auth_data  authenticated data 
*  @param [in] sz_auth_data_len  authenticated data in bytes
*  @param [in] c_enc_key keyset to use
*  @param [in] um_key_len  length of the key in bytes
*  @param [in] abyr_mac_tag  output authentication tag
*  @param [in] um_mac_tag_len  tag length in bytes
*
*  @return output  error code or "ok" code if success
*
*		return values:
*				GCM_OK	0 - tags match
*				GCM_NULL_PTR -1 - some input is missing/empty
*				GCM_PARAM_ERR -3 - parameters given do not match the requirements
*				GCM_AUTH_FAIL -5 - tag mismatch
*
*/
extern "C" int m_aes_gcm_mac_verify(unsigned char* abyr_iv,
                                    size_t sz_iv_len,
                                    unsigned char* abyr_auth_data,
                                    size_t sz_auth_data_len,
                                    const ds_aes_key* c_enc_key,
                                    unsigned int um_key_len,
                                    unsigned char* abyr_mac_tag,
                                    unsigned int um_mac_tag_len)
{
    if ((c_enc_key == NULL) || (abyr_iv == NULL))
        return GCM_NULL_PTR;
    return m_aes_gcm_auth_dec(abyr_iv,sz_iv_len,abyr_auth_data,sz_auth_data_len,c_enc_key,um_key_len,NULL,0,NULL,0,abyr_mac_tag,um_mac_tag_len);
}/*END OF function m_aes_gcm_mac_verify(...)*/



// Exactly the same as m_ghash_stream, but assembly coded
#if defined (USE_ASSEMBLER_SOURCES) 
    extern "C" void m_cpu_ghash_stream(unsigned char* achp_hash_state,
                                const unsigned char* achp_hash_key,
                                const unsigned char* achp_data,
                                int inp_data_len);
#endif

/**
Auxiliary GHASH function for byte-stream

This function updates the current hash state by input data
If the last block of input is incomplete (i.e. if inp_data_len % 16 > 0), zeros are appended

@param[in,out]	achp_hash_state		Current GHASH state
@param[in]		achp_hash_key		GHASH key
@param[in]		achp_data			Input data
@param[in]		inp_data_len		Data length
*/
static inline void m_ghash_stream(unsigned char* achp_hash_state,
								const unsigned char* achp_hash_key,
								const unsigned char* achp_data,
								int inp_data_len)
{
    int inl_len_blocks = inp_data_len / AES_BLOCK_SIZE;
    int inl_len_remain = inp_data_len % AES_BLOCK_SIZE;
	unsigned char byrl_aux[AES_BLOCK_SIZE]; /*auxiliary 16byte array*/
	// Complete blocks
	while(inl_len_blocks > 0)
	{
		m_ghash((unsigned char*) achp_hash_key, (unsigned char*) achp_data, (unsigned char*) achp_hash_state);
		achp_data += AES_BLOCK_SIZE;
		inl_len_blocks --;
	}
	// Partial block, extended with zeros
	if (inl_len_remain != 0)
	{
		memcpy(byrl_aux, achp_data, inl_len_remain);
		memset(byrl_aux + inl_len_remain, 0, AES_BLOCK_SIZE - inl_len_remain);
		m_ghash((unsigned char*) achp_hash_key, (unsigned char*) byrl_aux, (unsigned char*) achp_hash_state);
	}
} /*END m_ghash_stream*/


extern "C" void m_init_aes_gcm_1(struct dsd_aes_gcm_state* adsp_state,
                                 const char* achp_additional_data,
                                 int inp_data_len,
                                 const char* achp_iv,
                                 int inp_iv_len,
                                 const struct ds_aes_key_t* adsp_key,
                                 int inp_key_len)
{
    //-----------------------------------------------------------
    // NO PARAMETER VALIDATION
    //-----------------------------------------------------------
    //-----------------------------------------------------------
    // STATE INITIALITATION
    //-----------------------------------------------------------
	memset(adsp_state,0,sizeof(struct dsd_aes_gcm_state)); 
    adsp_state->ulc_add_data_len = inp_data_len;
    adsp_state->dsc_key = *adsp_key;
    if (inp_key_len == AES128_KEY_SIZE)
        adsp_state->unc_rounds = AES128_ROUNDS;
    else if (inp_key_len == AES192_KEY_SIZE)
        adsp_state->unc_rounds = AES192_ROUNDS;
    else if (inp_key_len == AES256_KEY_SIZE)
        adsp_state->unc_rounds = AES256_ROUNDS;
    else 
        return;
#define HASHKEY ((unsigned char*)adsp_state->chrc_ghash_key)
    //-----------------------------------------------------------
    // VARIABLES INITIALITATION
    //-----------------------------------------------------------

	unsigned char byrl_aux[AES_BLOCK_SIZE]; /*auxiliary 16byte array*/
    memset(byrl_aux,0,AES_BLOCK_SIZE); 

    //-----------------------------------------------------------
    // GHASH KEY INITIALITATION
    //-----------------------------------------------------------
    m_aes_ecb_encrypt(HASHKEY,
        HASHKEY,
        &(adsp_state->dsc_key),
        1,
        adsp_state->unc_rounds);

    //-----------------------------------------------------------
    // COUNTER INITIALIZATION
    //-----------------------------------------------------------
	if (inp_iv_len == IV_STANDARD_BYTESIZE) 
	{
		// J = ( IV || 0^(31) || 1 )
		memcpy(adsp_state->chrc_counter_block, achp_iv, inp_iv_len); 
		adsp_state->chrc_counter_block[16 - 1] |= 0x01; 
	}
	else
    { 
	    // J = GHASH( IV || 0^(s+64) || [length(IV)]64bits )
        //[length(IV)]64bits = represent length of IV in 64bit little endian format
#if defined (USE_ASSEMBLER_SOURCES)  
        if(adsp_key->im_flags & USE_CPU_AES_GCM_FLAG){
			m_cpu_ghash_stream((unsigned char*)adsp_state->chrc_counter_block,
				HASHKEY,
				(unsigned char*)achp_iv,
				inp_iv_len);
        } else
#endif
        {
			m_ghash_stream((unsigned char*)adsp_state->chrc_counter_block,
				HASHKEY,
				(unsigned char*)achp_iv,
				inp_iv_len);
		}
        long long inl_iv_bit_len = inp_iv_len*BYTE_BITSIZE;
        memset(byrl_aux,0,AES_BLOCK_SIZE);
        BIGlonglong2charn(inl_iv_bit_len, byrl_aux, AES_BLOCK_SIZE/2);
#if defined (USE_ASSEMBLER_SOURCES)  
        if(adsp_key->im_flags & USE_CPU_AES_GCM_FLAG){
		    m_cpu_ghash_stream((unsigned char*)adsp_state->chrc_counter_block,
			    HASHKEY,
			    byrl_aux,
			    AES_BLOCK_SIZE);
        } else
#endif
        {
			m_ghash_stream((unsigned char*)adsp_state->chrc_counter_block,
				HASHKEY,
				byrl_aux,
				AES_BLOCK_SIZE);
        }
    }

    //-----------------------------------------------------------
    // AUTHDATA INITIALIZATION
    //-----------------------------------------------------------
    //GHASH(A || 0^v...
#if defined (USE_ASSEMBLER_SOURCES)  
    if(adsp_key->im_flags & USE_CPU_AES_GCM_FLAG){
	    m_cpu_ghash_stream((unsigned char*)adsp_state->chrc_ghash_state,
		    HASHKEY,
		    (unsigned char*)achp_additional_data,
		    inp_data_len);
    } else
#endif
    {
		m_ghash_stream((unsigned char*)adsp_state->chrc_ghash_state,
			HASHKEY,
			(unsigned char*)achp_additional_data,
			inp_data_len);
    }

	//-----------------------------------------------------------
    // 0TH BLOCK INITIALITATION
    //-----------------------------------------------------------
    m_aes_ecb_encrypt((unsigned char*)adsp_state->chrc_counter_block,
        (unsigned char*)adsp_state->chrc_ctr_0_block,
        &(adsp_state->dsc_key),
        1,
        adsp_state->unc_rounds);

    //-----------------------------------------------------------
    // COUNTER INCREMENT
    //-----------------------------------------------------------
    unsigned int unl_counter;
	BIGchar2longn(((unsigned char*)adsp_state->chrc_counter_block),unl_counter,12);
	unl_counter++;
	BIGlong2charn(unl_counter,((unsigned char*)adsp_state->chrc_counter_block),12);
    adsp_state->unc_counter = unl_counter;

#undef HASHKEY
}

extern "C" void m_enc_update_aes_gcm_1(struct dsd_aes_gcm_state* adsp_state,
                                       char* achp_ciphertext,
                                       const char* achp_plaintext,
                                       int inp_data_len)
{
    //-----------------------------------------------------------
    // USE UP STORED PARTIAL BLOCK
    //-----------------------------------------------------------
    int inl_partial_size = adsp_state->unc_partial_bytes;
    if (inl_partial_size != 0){
        int inl_partial_limit = /*min*/((AES_BLOCK_SIZE-inl_partial_size < inp_data_len) ? (AES_BLOCK_SIZE-inl_partial_size) : inp_data_len);
        for (int inl1 = 0; inl1 < inl_partial_limit; inl1++){
            adsp_state->chrc_partial_block[inl_partial_size+inl1] ^= achp_plaintext[inl1];
            achp_ciphertext[inl1] = adsp_state->chrc_partial_block[inl_partial_size+inl1];
        }
        achp_ciphertext +=inl_partial_limit;
        achp_plaintext  +=inl_partial_limit;
        inp_data_len    -=inl_partial_limit;
        adsp_state->ulc_message_len +=inl_partial_limit;
        adsp_state->unc_partial_bytes += inl_partial_limit;

        if (adsp_state->unc_partial_bytes == AES_BLOCK_SIZE){
#if defined (USE_ASSEMBLER_SOURCES)  
            if(adsp_state->dsc_key.im_flags & USE_CPU_AES_GCM_FLAG){
			    m_cpu_ghash_stream((unsigned char*) adsp_state->chrc_ghash_state,
				    (unsigned char*) adsp_state->chrc_ghash_key,
				    (unsigned char*) adsp_state->chrc_partial_block,
				    AES_BLOCK_SIZE);
            } else
#endif
            {
			    m_ghash_stream((unsigned char*) adsp_state->chrc_ghash_state,
				    (unsigned char*) adsp_state->chrc_ghash_key,
				    (unsigned char*) adsp_state->chrc_partial_block,
				    AES_BLOCK_SIZE);
            }
            adsp_state->unc_partial_bytes = 0;
        }
    }

    //-----------------------------------------------------------
    // COMPLETE BLOCKS
    //-----------------------------------------------------------
    int inl_len_blocks = inp_data_len / AES_BLOCK_SIZE;
    int inl_len_remain = inp_data_len % AES_BLOCK_SIZE;
    if (inl_len_blocks > 0){
        m_aes_ctr((unsigned char*)achp_plaintext,
            inl_len_blocks*AES_BLOCK_SIZE, 
            (unsigned char*)achp_ciphertext,
            &adsp_state->dsc_key,
            (unsigned char*)adsp_state->chrc_counter_block,
            adsp_state->unc_rounds);

        adsp_state->unc_counter+=inl_len_blocks;
	    BIGlong2charn((adsp_state->unc_counter),((unsigned char*)adsp_state->chrc_counter_block),12);

#if defined (USE_ASSEMBLER_SOURCES)  
        if(adsp_state->dsc_key.im_flags & USE_CPU_AES_GCM_FLAG){
		    m_cpu_ghash_stream((unsigned char*) adsp_state->chrc_ghash_state,
			    (unsigned char*) adsp_state->chrc_ghash_key,
			    (unsigned char*) achp_ciphertext,
			    inl_len_blocks*AES_BLOCK_SIZE);
        } else
#endif
        {
		    m_ghash_stream((unsigned char*) adsp_state->chrc_ghash_state,
			    (unsigned char*) adsp_state->chrc_ghash_key,
			    (unsigned char*) achp_ciphertext,
			    inl_len_blocks*AES_BLOCK_SIZE);
        }
		achp_ciphertext += inl_len_blocks*AES_BLOCK_SIZE;
    }

    //-----------------------------------------------------------
    // STORE REMAINDER TO PARTIAL
    //-----------------------------------------------------------
    if (inl_len_remain > 0){
        achp_plaintext += inl_len_blocks*AES_BLOCK_SIZE;

        m_aes_ecb_encrypt((unsigned char*)adsp_state->chrc_counter_block,
            (unsigned char*)adsp_state->chrc_partial_block,
            &adsp_state->dsc_key, 1, adsp_state->unc_rounds);

        for (int inl1 = 0; inl1 < inl_len_remain; inl1++){
            adsp_state->chrc_partial_block[inl1] ^= achp_plaintext[inl1];
            achp_ciphertext[inl1] = adsp_state->chrc_partial_block[inl1];
        }
        adsp_state->unc_partial_bytes = inl_len_remain;
        adsp_state->unc_counter++;
	    BIGlong2charn((adsp_state->unc_counter),((unsigned char*)adsp_state->chrc_counter_block),12);
    }
    adsp_state->ulc_message_len+=inp_data_len;
}

extern "C" void m_dec_update_aes_gcm_1(struct dsd_aes_gcm_state* adsp_state,
                                       char* achp_plaintext,
                                       const char* achp_ciphertext,
                                       int inp_data_len)
{
    //-----------------------------------------------------------
    // USE UP STORED PARTIAL BLOCK
    //-----------------------------------------------------------
    int inl_partial_size = adsp_state->unc_partial_bytes;
    if (inl_partial_size != 0){
        int inl_partial_limit = /*min*/((AES_BLOCK_SIZE-inl_partial_size < inp_data_len) ? (AES_BLOCK_SIZE-inl_partial_size) : inp_data_len);
        for (int inl1 = 0; inl1 < inl_partial_limit; inl1++){
			achp_plaintext[inl1] = adsp_state->chrc_partial_block[inl_partial_size+inl1]^achp_ciphertext[inl1];
			adsp_state->chrc_partial_block[inl_partial_size+inl1] = achp_ciphertext[inl1];
        }
        achp_ciphertext +=inl_partial_limit;
        achp_plaintext  +=inl_partial_limit;
        inp_data_len    -=inl_partial_limit;
        adsp_state->ulc_message_len +=inl_partial_limit;
        adsp_state->unc_partial_bytes +=inl_partial_limit;
        if (adsp_state->unc_partial_bytes == AES_BLOCK_SIZE){
#if defined (USE_ASSEMBLER_SOURCES)  
            if(adsp_state->dsc_key.im_flags & USE_CPU_AES_GCM_FLAG){
			    m_cpu_ghash_stream((unsigned char*) adsp_state->chrc_ghash_state,
				    (unsigned char*) adsp_state->chrc_ghash_key,
				    (unsigned char*) adsp_state->chrc_partial_block,
				    AES_BLOCK_SIZE);
            } else
#endif
            {
			    m_ghash_stream((unsigned char*) adsp_state->chrc_ghash_state,
				    (unsigned char*) adsp_state->chrc_ghash_key,
				    (unsigned char*) adsp_state->chrc_partial_block,
				    AES_BLOCK_SIZE);
            }
			adsp_state->unc_partial_bytes = 0;
        }
    }

    //-----------------------------------------------------------
    // COMPLETE BLOCKS
    //-----------------------------------------------------------
    int inl_len_blocks = inp_data_len / AES_BLOCK_SIZE;
    int inl_len_remain = inp_data_len % AES_BLOCK_SIZE;
    if (inl_len_blocks > 0){
        m_aes_ctr((unsigned char*)achp_ciphertext,
            inl_len_blocks*AES_BLOCK_SIZE, 
            (unsigned char*)achp_plaintext,
            &adsp_state->dsc_key,
            (unsigned char*)adsp_state->chrc_counter_block,
            adsp_state->unc_rounds);

        adsp_state->unc_counter+=inl_len_blocks;
	    BIGlong2charn((adsp_state->unc_counter),((unsigned char*)adsp_state->chrc_counter_block),12);

#if defined (USE_ASSEMBLER_SOURCES)  
        if(adsp_state->dsc_key.im_flags & USE_CPU_AES_GCM_FLAG){
		    m_cpu_ghash_stream((unsigned char*) adsp_state->chrc_ghash_state,
			    (unsigned char*) adsp_state->chrc_ghash_key,
			    (unsigned char*) achp_ciphertext,
			    inl_len_blocks*AES_BLOCK_SIZE);
        } else
#endif
        {
		    m_ghash_stream((unsigned char*) adsp_state->chrc_ghash_state,
			    (unsigned char*) adsp_state->chrc_ghash_key,
			    (unsigned char*) achp_ciphertext,
			    inl_len_blocks*AES_BLOCK_SIZE);
        }
		achp_ciphertext += inl_len_blocks*AES_BLOCK_SIZE;
    }

    //-----------------------------------------------------------
    // STORE REMAINDER TO PARTIAL
    //-----------------------------------------------------------
    if (inl_len_remain > 0){
        achp_plaintext += inl_len_blocks*AES_BLOCK_SIZE;
        m_aes_ecb_encrypt((unsigned char*)adsp_state->chrc_counter_block,
            (unsigned char*)adsp_state->chrc_partial_block,
            &adsp_state->dsc_key, 1, adsp_state->unc_rounds);
        for (int inl1 = 0; inl1 < inl_len_remain; inl1++){
			achp_plaintext[inl1] = adsp_state->chrc_partial_block[inl1]^achp_ciphertext[inl1];
			adsp_state->chrc_partial_block[inl1] = achp_ciphertext[inl1];
        }
        adsp_state->unc_partial_bytes = inl_len_remain;
        adsp_state->unc_counter++;
	    BIGlong2charn((adsp_state->unc_counter),((unsigned char*)adsp_state->chrc_counter_block),12);
    }

    adsp_state->ulc_message_len+=inp_data_len;
}

extern "C" void m_enc_final_aes_gcm_1(struct dsd_aes_gcm_state* adsp_state,
                                      char* achp_tag,
                                      int inp_tag_len)
{
    //-----------------------------------------------------------
    // USE UP STORED PARTIAL BLOCK
    //-----------------------------------------------------------
    if (adsp_state->unc_partial_bytes != 0){
        memset(&adsp_state->chrc_partial_block[adsp_state->unc_partial_bytes],0,AES_BLOCK_SIZE-adsp_state->unc_partial_bytes);
#if defined (USE_ASSEMBLER_SOURCES)  
        if(adsp_state->dsc_key.im_flags & USE_CPU_AES_GCM_FLAG){
		    m_cpu_ghash_stream((unsigned char*) adsp_state->chrc_ghash_state,
			    (unsigned char*) adsp_state->chrc_ghash_key,
			    (unsigned char*) adsp_state->chrc_partial_block,
			    AES_BLOCK_SIZE);
        } else
#endif
        {
		    m_ghash_stream((unsigned char*) adsp_state->chrc_ghash_state,
			    (unsigned char*) adsp_state->chrc_ghash_key,
			    (unsigned char*) adsp_state->chrc_partial_block,
			    AES_BLOCK_SIZE);
        }
    }

    //-----------------------------------------------------------
    // DATA LENGTHS
    //-----------------------------------------------------------
	unsigned char byrl_aux[AES_BLOCK_SIZE];
    unsigned long long ull_ad_bit_len = adsp_state->ulc_add_data_len *BYTE_BITSIZE;
    unsigned long long ull_msg_bit_len = adsp_state->ulc_message_len *BYTE_BITSIZE;
    BIGlonglong2charn(ull_ad_bit_len,byrl_aux,0);
    BIGlonglong2charn(ull_msg_bit_len, byrl_aux,AES_BLOCK_SIZE/2);
#if defined (USE_ASSEMBLER_SOURCES)  
    if(adsp_state->dsc_key.im_flags & USE_CPU_AES_GCM_FLAG){
	    m_cpu_ghash_stream((unsigned char*) adsp_state->chrc_ghash_state,
		    (unsigned char*) adsp_state->chrc_ghash_key,
		    byrl_aux,
		    AES_BLOCK_SIZE);
    } else
#endif
    {
	    m_ghash_stream((unsigned char*) adsp_state->chrc_ghash_state,
		    (unsigned char*) adsp_state->chrc_ghash_key,
		    byrl_aux,
		    AES_BLOCK_SIZE);
    }

    //-----------------------------------------------------------
    // XOR WITH 0TH BLOCK
    //-----------------------------------------------------------
    for (int inl1 = 0; inl1 < inp_tag_len; inl1++){
        achp_tag[inl1] = adsp_state->chrc_ghash_state[inl1] ^ adsp_state->chrc_ctr_0_block[inl1];
    }
    //-----------------------------------------------------------
    // SCRUB STATE
    //-----------------------------------------------------------
    m_sec_zero_mem(adsp_state,sizeof(struct dsd_aes_gcm_state)); 
}

extern "C" BOOL m_dec_final_aes_gcm_1(struct dsd_aes_gcm_state* adsp_state,
                                      const char* achp_tag,
                                      int inp_tag_len)
{
    //-----------------------------------------------------------
    // USE UP STORED PARTIAL BLOCK
    //-----------------------------------------------------------
    if (adsp_state->unc_partial_bytes != 0){
		memset(&adsp_state->chrc_partial_block[adsp_state->unc_partial_bytes],0,AES_BLOCK_SIZE-adsp_state->unc_partial_bytes);
#if defined (USE_ASSEMBLER_SOURCES)  
        if(adsp_state->dsc_key.im_flags & USE_CPU_AES_GCM_FLAG){
		    m_cpu_ghash_stream((unsigned char*) adsp_state->chrc_ghash_state,
			    (unsigned char*) adsp_state->chrc_ghash_key,
			    (unsigned char*) adsp_state->chrc_partial_block,
			    AES_BLOCK_SIZE);
        } else
#endif
        {
		    m_ghash_stream((unsigned char*) adsp_state->chrc_ghash_state,
			    (unsigned char*) adsp_state->chrc_ghash_key,
			    (unsigned char*) adsp_state->chrc_partial_block,
			    AES_BLOCK_SIZE);
        }
    }

    //-----------------------------------------------------------
    // DATA LENGTHS
    //-----------------------------------------------------------
	unsigned char byrl_aux[AES_BLOCK_SIZE];
    unsigned long long ull_ad_bit_len = adsp_state->ulc_add_data_len *BYTE_BITSIZE;
    unsigned long long ull_msg_bit_len = adsp_state->ulc_message_len *BYTE_BITSIZE;
    BIGlonglong2charn(ull_ad_bit_len,byrl_aux,0);
    BIGlonglong2charn(ull_msg_bit_len, byrl_aux,AES_BLOCK_SIZE/2);

#if defined (USE_ASSEMBLER_SOURCES)  
    if(adsp_state->dsc_key.im_flags & USE_CPU_AES_GCM_FLAG){
	    m_cpu_ghash_stream((unsigned char*) adsp_state->chrc_ghash_state,
		    (unsigned char*) adsp_state->chrc_ghash_key,
		    byrl_aux,
		    AES_BLOCK_SIZE);
    } else
#endif
    {
	    m_ghash_stream((unsigned char*) adsp_state->chrc_ghash_state,
		    (unsigned char*) adsp_state->chrc_ghash_key,
		    byrl_aux,
		    AES_BLOCK_SIZE);
    }

    //-----------------------------------------------------------
    // XOR WITH 0TH BLOCK
    //-----------------------------------------------------------
    BOOL bol_auth;
    for (int inl1 = 0; inl1 < inp_tag_len; inl1++)
    {
        adsp_state->chrc_ghash_state[inl1] ^= adsp_state->chrc_ctr_0_block[inl1];
    }

    if (const_time_memcmp(achp_tag,adsp_state->chrc_ghash_state,inp_tag_len) == 0) 
    {
        bol_auth = TRUE;
    } else {
        bol_auth = FALSE;
    }
    //-----------------------------------------------------------
    // SCRUB STATE
    //-----------------------------------------------------------
    m_sec_zero_mem(adsp_state,sizeof(struct dsd_aes_gcm_state)); 
    return bol_auth;
}


#if defined __arm__ && !defined __aarch64__ && defined USE_ASSEMBLER_SOURCES
//Dummy functions for 32-bit ARM architectures where the build process can't provide precise control of USE_ASSEMBLER_SOURCES
//While the lack of USE_CPU_AES_FLAG should prevent these functions from ever being called, we provide redirection to C implementations where possible

extern "C" void m_aes_cbc_cpu_encrypt(const unsigned char * abyp_in,
                                  unsigned char * abyp_out,
                                  unsigned char * abyp_key,
                                  size_t szp_block_count,
                                  unsigned char * abyp_ivec,
                                  int imp_number_of_rounds)
{
    AES_Fast_cbc_encrypt(abyp_in,abyp_out,(ds_aes_key*)abyp_key,szp_block_count,abyp_ivec,imp_number_of_rounds);
}

extern "C" void m_aes_cbc_cpu_decrypt(const unsigned char * abyp_in,
                                  unsigned char * abyp_out,
                                  unsigned char * abyp_key,
                                  size_t szp_block_count,
                                  unsigned char * abyp_ivec,
                                  int imp_number_of_rounds)
{
    AES_Fast_cbc_decrypt(abyp_in,abyp_out,(ds_aes_key*)abyp_key,szp_block_count,abyp_ivec,imp_number_of_rounds);
}


extern "C" void m_aes_ecb_cpu_encrypt(const unsigned char * abyp_in,
                                  unsigned char * abyp_out,
                                  unsigned char * abyp_key,
                                  size_t szp_block_count,
                                  int imp_number_of_rounds)
{
    AES_Fast_ecb_encrypt(abyp_in,abyp_out,(ds_aes_key*)abyp_key,szp_block_count,imp_number_of_rounds);
}

extern "C" void m_aes_ecb_cpu_decrypt(const unsigned char * abyp_in,
                                  unsigned char * abyp_out,
                                  unsigned char * abyp_key,
                                  size_t szp_block_count,
                                  int imp_number_of_rounds)
{
    AES_Fast_ecb_encrypt(abyp_in,abyp_out,(ds_aes_key*)abyp_key,szp_block_count,imp_number_of_rounds);
}

extern "C" void m_aes_128_cpu_key_expansion(const unsigned char * abyp_userkey,
                                        unsigned char * abyp_key)
{
    m_gen_aes_encrypt_keys(abyp_userkey,4,(ds_aes_key*)abyp_key);
}

extern "C" void m_aes_192_cpu_key_expansion(const unsigned char * abyp_userkey,
                                        unsigned char * abyp_key)
{
    m_gen_aes_encrypt_keys(abyp_userkey,6,(ds_aes_key*)abyp_key);
}

extern "C" void m_aes_256_cpu_key_expansion(const unsigned char * abyp_userkey,
                                        unsigned char * abyp_key)
{
    m_gen_aes_encrypt_keys(abyp_userkey,8,(ds_aes_key*)abyp_key);
}

extern "C" void m_aes_cpu_revert_key(unsigned char * adsp_key,
                                 unsigned char * adsp_rev_key,
                                 size_t szp_rounds)
{
    // No same-functionality C function exists
    __builtin_trap();
}

extern "C" void m_aes_ctr_cpu(const unsigned char * abyp_input,
                              unsigned char * abyp_output,
                              const ds_aes_key * adsp_key,
                              size_t szp_block_count,
                              unsigned char * abyp_iv,
                              int inp_rounds)
{
    //Calling m_aes_ctr risks infinite recursion
    __builtin_trap();
}

extern "C" void m_cpu_ghash_stream(unsigned char* achp_hash_state,
                                const unsigned char* achp_hash_key,
                                const unsigned char* achp_data,
                                int inp_data_len)
{
    m_ghash_stream(achp_hash_state,achp_hash_key,achp_data,inp_data_len);
}

extern "C" int m_check_cpu_support_aes()
{
  return 0;
}

#endif

/**
*@}
*/

#endif //HL_ENCR_AES
// end of file ../aes/hobaes.cpp


#ifdef HL_ENCR_MD
/** @defgroup md2 MD 2 
* This module mplements the MD2 hash algorithm, described in RFC 1319.
*
* Used for backward compatibility reasons (older certificates).
*
* The state array will NOT be cleared in the final step.
*
* No other modules are used.
* @{
* @file
* This file implements the MD2 message digest (hash) algorithm.
* See RFC 1319 for description of algorithm.
* @date 14.10.1998
* @}
*/
#if (defined _WIN32) & (_MSC_VER < 1700)
#ifndef _STDINT
#define _STDINT
// MSVC lower than 17.00 does not have stdint.h, assure, all needed types are defined

typedef unsigned __int16 uint16_t;

typedef unsigned __int32 uint32_t;

typedef unsigned __int64 uint64_t;

#endif // !_STDINT
#else
#include <stdint.h>
#endif
#include <stddef.h>
#ifdef _WIN32
#define WIN32_LEAN_AND_MEAN
#include <Windows.h>
#undef WIN32_LEAN_AND_MEAN
#else// Define system-specific HL_* defines here
#ifndef HL_UNIX
#define HL_UNIX

#if (defined __gnu_linux__) || (defined __linux__)
#define HL_LINUX
#endif

#if (defined __APPLE__) && (defined __MACH__)
#define HL_LINUX
#define HL_MACOS
#endif

#ifdef _AIX
#define HL_AIX
#define HL_BIG_ENDIAN
#endif

#ifdef __FreeBSD__
#define HL_FREEBSD
#endif

#if (defined _hpux) || (defined hpux) || (defined __hpux)
#define HL_HPUX
#define HL_BIG_ENDIAN
#endif

#if (defined sun) || (defined __sun)
#define HL_SOLARIS
#endif

#if (defined __arm__) || (defined __aarch64__)
#define HL_LINUX_ARM
#endif

#ifdef __ANDROID__
#define HL_ANDROID
#endif

#endif
#include <hob-unix01.h>
#endif
#ifdef __APPLE__
/* We get target conditionals to keep apart Mac OS, iOS and iOS simulator.
   The conditionals are TARGET_IPHONE_SIMULATOR, TARGET_OS_IPHONE and TARGET_OS_MAC.
   TARGET_IPHONE_SIMULATOR has the highest priority, TARGET_OS_MAC the lowest.
   Always test, if the conditional is 1, as they will be defined as 0, if we 
   are not compiling for the target.
   */
#include <TargetConditionals.h>
#endif

#include <string.h>
#include <stdlib.h>
#include "hob-encry-1.h"
#include "hob-encry-intern-1.h"
/* State: 16 Bit: checked o.k.					
*        32 Bit: not yet checked				
*/

/*--------------------------------------------------------------*/
/* MD2 S-Table							*/
/*--------------------------------------------------------------*/
//BYTEARRAYI
static unsigned char S[256] = {

  (unsigned char) 0x29, (unsigned char) 0x2E, (unsigned char) 0x43, (unsigned char) 0xC9,
  (unsigned char) 0xA2, (unsigned char) 0xD8, (unsigned char) 0x7C, (unsigned char) 0x01,
  (unsigned char) 0x3D, (unsigned char) 0x36, (unsigned char) 0x54, (unsigned char) 0xA1,
  (unsigned char) 0xEC, (unsigned char) 0xF0, (unsigned char) 0x06, (unsigned char) 0x13,
  (unsigned char) 0x62, (unsigned char) 0xA7, (unsigned char) 0x05, (unsigned char) 0xF3,
  (unsigned char) 0xC0, (unsigned char) 0xC7, (unsigned char) 0x73, (unsigned char) 0x8C,
  (unsigned char) 0x98, (unsigned char) 0x93, (unsigned char) 0x2B, (unsigned char) 0xD9,
  (unsigned char) 0xBC, (unsigned char) 0x4C, (unsigned char) 0x82, (unsigned char) 0xCA,
  (unsigned char) 0x1E, (unsigned char) 0x9B, (unsigned char) 0x57, (unsigned char) 0x3C,
  (unsigned char) 0xFD, (unsigned char) 0xD4, (unsigned char) 0xE0, (unsigned char) 0x16,
  (unsigned char) 0x67, (unsigned char) 0x42, (unsigned char) 0x6F, (unsigned char) 0x18,
  (unsigned char) 0x8A, (unsigned char) 0x17, (unsigned char) 0xE5, (unsigned char) 0x12,
  (unsigned char) 0xBE, (unsigned char) 0x4E, (unsigned char) 0xC4, (unsigned char) 0xD6,
  (unsigned char) 0xDA, (unsigned char) 0x9E, (unsigned char) 0xDE, (unsigned char) 0x49,
  (unsigned char) 0xA0, (unsigned char) 0xFB, (unsigned char) 0xF5, (unsigned char) 0x8E,
  (unsigned char) 0xBB, (unsigned char) 0x2F, (unsigned char) 0xEE, (unsigned char) 0x7A,
  (unsigned char) 0xA9, (unsigned char) 0x68, (unsigned char) 0x79, (unsigned char) 0x91,
  (unsigned char) 0x15, (unsigned char) 0xB2, (unsigned char) 0x07, (unsigned char) 0x3F,
  (unsigned char) 0x94, (unsigned char) 0xC2, (unsigned char) 0x10, (unsigned char) 0x89,
  (unsigned char) 0x0B, (unsigned char) 0x22, (unsigned char) 0x5F, (unsigned char) 0x21,
  (unsigned char) 0x80, (unsigned char) 0x7F, (unsigned char) 0x5D, (unsigned char) 0x9A,
  (unsigned char) 0x5A, (unsigned char) 0x90, (unsigned char) 0x32, (unsigned char) 0x27,
  (unsigned char) 0x35, (unsigned char) 0x3E, (unsigned char) 0xCC, (unsigned char) 0xE7,
  (unsigned char) 0xBF, (unsigned char) 0xF7, (unsigned char) 0x97, (unsigned char) 0x03,
  (unsigned char) 0xFF, (unsigned char) 0x19, (unsigned char) 0x30, (unsigned char) 0xB3,
  (unsigned char) 0x48, (unsigned char) 0xA5, (unsigned char) 0xB5, (unsigned char) 0xD1,
  (unsigned char) 0xD7, (unsigned char) 0x5E, (unsigned char) 0x92, (unsigned char) 0x2A,
  (unsigned char) 0xAC, (unsigned char) 0x56, (unsigned char) 0xAA, (unsigned char) 0xC6,
  (unsigned char) 0x4F, (unsigned char) 0xB8, (unsigned char) 0x38, (unsigned char) 0xD2,
  (unsigned char) 0x96, (unsigned char) 0xA4, (unsigned char) 0x7D, (unsigned char) 0xB6,
  (unsigned char) 0x76, (unsigned char) 0xFC, (unsigned char) 0x6B, (unsigned char) 0xE2,
  (unsigned char) 0x9C, (unsigned char) 0x74, (unsigned char) 0x04, (unsigned char) 0xF1,
  (unsigned char) 0x45, (unsigned char) 0x9D, (unsigned char) 0x70, (unsigned char) 0x59,
  (unsigned char) 0x64, (unsigned char) 0x71, (unsigned char) 0x87, (unsigned char) 0x20,
  (unsigned char) 0x86, (unsigned char) 0x5B, (unsigned char) 0xCF, (unsigned char) 0x65,
  (unsigned char) 0xE6, (unsigned char) 0x2D, (unsigned char) 0xA8, (unsigned char) 0x02,
  (unsigned char) 0x1B, (unsigned char) 0x60, (unsigned char) 0x25, (unsigned char) 0xAD,
  (unsigned char) 0xAE, (unsigned char) 0xB0, (unsigned char) 0xB9, (unsigned char) 0xF6,
  (unsigned char) 0x1C, (unsigned char) 0x46, (unsigned char) 0x61, (unsigned char) 0x69,
  (unsigned char) 0x34, (unsigned char) 0x40, (unsigned char) 0x7E, (unsigned char) 0x0F,
  (unsigned char) 0x55, (unsigned char) 0x47, (unsigned char) 0xA3, (unsigned char) 0x23,
  (unsigned char) 0xDD, (unsigned char) 0x51, (unsigned char) 0xAF, (unsigned char) 0x3A,
  (unsigned char) 0xC3, (unsigned char) 0x5C, (unsigned char) 0xF9, (unsigned char) 0xCE,
  (unsigned char) 0xBA, (unsigned char) 0xC5, (unsigned char) 0xEA, (unsigned char) 0x26,
  (unsigned char) 0x2C, (unsigned char) 0x53, (unsigned char) 0x0D, (unsigned char) 0x6E,
  (unsigned char) 0x85, (unsigned char) 0x28, (unsigned char) 0x84, (unsigned char) 0x09,
  (unsigned char) 0xD3, (unsigned char) 0xDF, (unsigned char) 0xCD, (unsigned char) 0xF4,
  (unsigned char) 0x41, (unsigned char) 0x81, (unsigned char) 0x4D, (unsigned char) 0x52,
  (unsigned char) 0x6A, (unsigned char) 0xDC, (unsigned char) 0x37, (unsigned char) 0xC8,
  (unsigned char) 0x6C, (unsigned char) 0xC1, (unsigned char) 0xAB, (unsigned char) 0xFA,
  (unsigned char) 0x24, (unsigned char) 0xE1, (unsigned char) 0x7B, (unsigned char) 0x08,
  (unsigned char) 0x0C, (unsigned char) 0xBD, (unsigned char) 0xB1, (unsigned char) 0x4A,
  (unsigned char) 0x78, (unsigned char) 0x88, (unsigned char) 0x95, (unsigned char) 0x8B,
  (unsigned char) 0xE3, (unsigned char) 0x63, (unsigned char) 0xE8, (unsigned char) 0x6D,
  (unsigned char) 0xE9, (unsigned char) 0xCB, (unsigned char) 0xD5, (unsigned char) 0xFE,
  (unsigned char) 0x3B, (unsigned char) 0x00, (unsigned char) 0x1D, (unsigned char) 0x39,
  (unsigned char) 0xF2, (unsigned char) 0xEF, (unsigned char) 0xB7, (unsigned char) 0x0E,
  (unsigned char) 0x66, (unsigned char) 0x58, (unsigned char) 0xD0, (unsigned char) 0xE4,
  (unsigned char) 0xA6, (unsigned char) 0x77, (unsigned char) 0x72, (unsigned char) 0xF8,
  (unsigned char) 0xEB, (unsigned char) 0x75, (unsigned char) 0x4B, (unsigned char) 0x0A,
  (unsigned char) 0x31, (unsigned char) 0x44, (unsigned char) 0x50, (unsigned char) 0xB4,
  (unsigned char) 0x8F, (unsigned char) 0xED, (unsigned char) 0x1F, (unsigned char) 0x1A,
  (unsigned char) 0xDB, (unsigned char) 0x99, (unsigned char) 0x8D, (unsigned char) 0x33,
  (unsigned char) 0x9F, (unsigned char) 0x11, (unsigned char) 0x83, (unsigned char) 0x14,
};

/* Implemented from RFC1319(??!!): MD2 Message-Digest Algorithm	*/

/** @addtogroup md2
* @{
*/
/**
* Processes one complete, saved	
* MD2 datablock and generates new checksum and X values	
* for the MD2 state array (MD2BlockService).
*					
* @param MD2_Array	Pointer to MD2	state structure							
*/
static void MD2BlockService(int* MD2_Array)
{
  char c,l;
  int	i,j,k;

  /*--------------------------------------------------------------------*/
  /* 1. Do checksum Array, load Digest Array X[16+i], X[32+i]		*/
  /*--------------------------------------------------------------------*/
  i = 0;				// Blockbuffer start index
  j = MD2_X;				// X-Array Index Start
  k = MD2_ChkSum;			// Checksum Index Start
  l = (char) MD2_Array[MD2_ChkSum+MD2_CBLOCK-1]; // get continuation for chks.
  do
  {
    c = (char) MD2_Array[i];		// get Databyte
    MD2_Array[j+16] = (int) c & 0xFF;	// save digest

// NOTE: INTEL Compiler mixes up index j in the following statement!!
//    MD2_Array[j+32] = (BIT32)		// dto.
//      (c ^ (BIT8) MD2_Array[j++]) & 0xFF;

// Next 2 unrolled statements work correct with Intel Compiler...
    MD2_Array[j+32] = (int)		// dto.
      (c ^ (char) MD2_Array[j]) & 0xFF;
    j++;

    MD2_Array[k] ^=
     (int) S[(c ^ l) & 0xFF] & 0xFF;// get new checksum byte
//       (BIT32) STRING_CHAR(S,(c ^ l) & 0xFF) & 0xFF;// get new checksum byte
    l = (char) MD2_Array[k++];		// save for processing
    i++;
  } while(i != MD2_CBLOCK);
  /*--------------------------------------------------------------------*/
  /* 2. Calculate new digest values X[i], do 18 rounds			*/
  /*--------------------------------------------------------------------*/
  l = 0;
  i = 0;
  do
  {
    j = MD2_X_ARRAY_LEN;			// total length of X-Array
    k = MD2_X;					// StartIndex X-Array
    do
    {
      MD2_Array[k] ^= (int)
        S[(l & 0xFF)] & 0xFF;		// shuffle X-Array       
//        STRING_CHAR(S,(l & 0xFF)) & 0xFF;	// shuffle X-Array       
      l = (char) MD2_Array[k++];		// save
      j--;
    }while(j != 0);
    l = (char)(l +(char) (i & 0xFF));			// modify value (!!)
    i++;
  } while(i != MD2_ROUNDS);
}

extern "C" void MD2_Init(int* MD2_Array)
{
  int i,j;

  MD2_Array[MD2_DatCnt] = 0;			// no data in block buffer

  j = MD2_X;					// StartIndex  X-Array buffer
  for (i=MD2_X_ARRAY_LEN;i>0;i--)		// Initialize X-Array with 0
    MD2_Array[j++] = 0;
  j = MD2_ChkSum;				// StartIndex Checksum buffer
  for (i=MD2_CBLOCK;i>0;i--)			// Initialize CheckSum with 0
    MD2_Array[j++] = 0;
}

extern "C" void MD2_Update(int MD2_Array[],
                           const char data[],
                           int offset, 
                           size_t len)
{
  int i;
  int nFill,nIndex,nCopy; 
  int nCharIndex;

  if (len == 0) return;				// nothing to do
  /*--------------------------------------------------------------------*/
  /* set buffer indices/DataCount (note: buffer starts at index 0)	*/
  /*--------------------------------------------------------------------*/
  nIndex = (int) MD2_Array[MD2_DatCnt];
  nCharIndex = offset;
  /*------------------------------------------------------------*/
  /* process input data using block buffer			*/
  /*------------------------------------------------------------*/
  do
  {
    /*----------------------------------------------------------*/
    /* copy data to blockbuffer until filled or data exhausted	*/
    /*----------------------------------------------------------*/
    nFill = MD2_CBLOCK - (int) MD2_Array[MD2_DatCnt];//number of bytes required
    nCopy = nFill;				// preset bytes to copy
    if(((uint32_t) nFill) > len)  nCopy = (int) len; // reduce copy count
    for(i=nCopy;i>0;i--)
    {
      MD2_Array[nIndex++] =
        (int) data[nCharIndex++] & 0xFF;	// copy bytes to buffer
    }
    if(nCopy < nFill)				// not enough data, exit
    {
      MD2_Array[MD2_DatCnt] += nCopy;		// save byte count, no sign
						// change should occur !!
      return;					// exit, no complete buffer...
    }
    nIndex = 0;					// back to Block Buffer start
    MD2_Array[MD2_DatCnt] = 0;			// preset Block Buf. processed
    /*----------------------------------------------------------*/
    /* process blockbuffer to generate new portion of digest	*/
    /*----------------------------------------------------------*/
    MD2BlockService(MD2_Array);			// generate digest portion
    len -= nFill;				// reduce remaining data count
  } while (len != 0);				// continue until data end
}

extern "C" void MD2_Final(int* MD2_Array,
				  char* Digest, int Offset)
{
  int i,j,nPadding;

  int nIndex = (int) MD2_Array[MD2_DatCnt];

  /*----------------------------------------------------*/
  /* calculate padding length (is definitely <> 0),	*/
  /* append padding (value of 'missing' bytes),		*/
  /* process block					*/
  /*----------------------------------------------------*/
  nPadding = MD2_CBLOCK-nIndex;			// get padding count/value
  j = nIndex;
  for(i=nPadding;i>0;i--)			// pad buffer with Constant
    MD2_Array[j++] = (int) nPadding;  
  MD2BlockService(MD2_Array);			// generate digest portion
  /*------------------------------------------------------*/
  /* copy Checksum to Blockbuffer, process that last block*/
  /*------------------------------------------------------*/
  j = 0;					// StartIndex of Blockbuffer
  for(i=MD2_CBLOCK;i>0;i--)			// copy checksum to Blockbuffer
  {
    MD2_Array[j] = MD2_Array[MD2_ChkSum+j];
    j++;
  }
  MD2BlockService(MD2_Array);			// generate digest portion
  /*----------------------------------------------------*/
  /* store message digest into user supplied buffer	*/
  /*----------------------------------------------------*/
  j = 0;					// StartIndex for Copy
  for(i=MD2_DIGEST_LEN;i>0;i--)  		// copy the final digest
  {
    Digest[j+Offset] = (char) MD2_Array[MD2_X + j];
    j++;
  }
}

/** @}*/


#endif //HL_ENCR_MD
// end of file ../MD2/m2.cpp


#ifdef HL_ENCR_MD
/** @defgroup md4 MD 4
* This module mplements the MD4 hash algorithm, described in RFC 1321.
*
* Used for backward compatibility reasons (older certificates).
*
* The state array will NOT be cleared in the final step.
*
* No other modules are used.
* @{
* @file
* This file implements the MD4 message digest (hash) algorithm.
* See 'Applied Cryptography' / RFC 1321 for description of algorithm.
* @}
*/
#if (defined _WIN32) & (_MSC_VER < 1700)
#ifndef _STDINT
#define _STDINT
// MSVC lower than 17.00 does not have stdint.h, assure, all needed types are defined

typedef unsigned __int16 uint16_t;

typedef unsigned __int32 uint32_t;

typedef unsigned __int64 uint64_t;

#endif // !_STDINT
#else
#include <stdint.h>
#endif
#include <stddef.h>
#ifdef _WIN32
#define WIN32_LEAN_AND_MEAN
#include <Windows.h>
#undef WIN32_LEAN_AND_MEAN
#else// Define system-specific HL_* defines here
#ifndef HL_UNIX
#define HL_UNIX

#if (defined __gnu_linux__) || (defined __linux__)
#define HL_LINUX
#endif

#if (defined __APPLE__) && (defined __MACH__)
#define HL_LINUX
#define HL_MACOS
#endif

#ifdef _AIX
#define HL_AIX
#define HL_BIG_ENDIAN
#endif

#ifdef __FreeBSD__
#define HL_FREEBSD
#endif

#if (defined _hpux) || (defined hpux) || (defined __hpux)
#define HL_HPUX
#define HL_BIG_ENDIAN
#endif

#if (defined sun) || (defined __sun)
#define HL_SOLARIS
#endif

#if (defined __arm__) || (defined __aarch64__)
#define HL_LINUX_ARM
#endif

#ifdef __ANDROID__
#define HL_ANDROID
#endif

#endif
#include <hob-unix01.h>
#endif
#ifdef __APPLE__
/* We get target conditionals to keep apart Mac OS, iOS and iOS simulator.
   The conditionals are TARGET_IPHONE_SIMULATOR, TARGET_OS_IPHONE and TARGET_OS_MAC.
   TARGET_IPHONE_SIMULATOR has the highest priority, TARGET_OS_MAC the lowest.
   Always test, if the conditional is 1, as they will be defined as 0, if we 
   are not compiling for the target.
   */
#include <TargetConditionals.h>
#endif

#include "hob-encry-1.h"

#include <string.h>
#include <stdlib.h>
#include "hob-encry-intern-1.h"

/* Note: All Long values are treated as being stored in 	*/
/* ----- BIG ENDIAN Format according to RFC1321			*/

/**
* Subroutine MD4BlockService, processes one complete, saved
* MD4 Datablock and generates new values for A,B,C and D (MD4BlockService).
*/
static void MD4BlockService(int MD4_Array[])
{
  int A,B,C,D;

  //------------------------------------------------------
  // Get saved 'Register values'
  //------------------------------------------------------
  A = MD4_Array[MD4_A];
  B = MD4_Array[MD4_B];
  C = MD4_Array[MD4_C];
  D = MD4_Array[MD4_D];
  //-----------------------------------------
  // Process round 1
  //-----------------------------------------
  R1_MD4(A,B,C,D,MD4_Array[MD4_data + 0], 3, 0);
  R1_MD4(D,A,B,C,MD4_Array[MD4_data + 1], 7, 0);
  R1_MD4(C,D,A,B,MD4_Array[MD4_data + 2],11, 0);
  R1_MD4(B,C,D,A,MD4_Array[MD4_data + 3],19, 0);

  R1_MD4(A,B,C,D,MD4_Array[MD4_data + 4], 3, 0);
  R1_MD4(D,A,B,C,MD4_Array[MD4_data + 5], 7, 0);
  R1_MD4(C,D,A,B,MD4_Array[MD4_data + 6],11, 0);
  R1_MD4(B,C,D,A,MD4_Array[MD4_data + 7],19, 0);

  R1_MD4(A,B,C,D,MD4_Array[MD4_data + 8], 3, 0);
  R1_MD4(D,A,B,C,MD4_Array[MD4_data + 9], 7, 0);
  R1_MD4(C,D,A,B,MD4_Array[MD4_data +10],11, 0);
  R1_MD4(B,C,D,A,MD4_Array[MD4_data +11],19, 0);

  R1_MD4(A,B,C,D,MD4_Array[MD4_data +12], 3, 0);
  R1_MD4(D,A,B,C,MD4_Array[MD4_data +13], 7, 0);
  R1_MD4(C,D,A,B,MD4_Array[MD4_data +14],11, 0);
  R1_MD4(B,C,D,A,MD4_Array[MD4_data +15],19, 0);
  //-----------------------------------------
  // Process round 2
  //-----------------------------------------
  R2_MD4(A,B,C,D,MD4_Array[MD4_data + 0], 3, 0x5A827999);
  R2_MD4(D,A,B,C,MD4_Array[MD4_data + 4], 5, 0x5A827999);
  R2_MD4(C,D,A,B,MD4_Array[MD4_data + 8], 9, 0x5A827999);
  R2_MD4(B,C,D,A,MD4_Array[MD4_data +12],13, 0x5A827999);

  R2_MD4(A,B,C,D,MD4_Array[MD4_data + 1], 3, 0x5A827999);
  R2_MD4(D,A,B,C,MD4_Array[MD4_data + 5], 5, 0x5A827999);
  R2_MD4(C,D,A,B,MD4_Array[MD4_data + 9], 9, 0x5A827999);
  R2_MD4(B,C,D,A,MD4_Array[MD4_data +13],13, 0x5A827999);

  R2_MD4(A,B,C,D,MD4_Array[MD4_data + 2], 3, 0x5A827999);
  R2_MD4(D,A,B,C,MD4_Array[MD4_data + 6], 5, 0x5A827999);
  R2_MD4(C,D,A,B,MD4_Array[MD4_data +10], 9, 0x5A827999);
  R2_MD4(B,C,D,A,MD4_Array[MD4_data +14],13, 0x5A827999);

  R2_MD4(A,B,C,D,MD4_Array[MD4_data + 3], 3, 0x5A827999);
  R2_MD4(D,A,B,C,MD4_Array[MD4_data + 7], 5, 0x5A827999);
  R2_MD4(C,D,A,B,MD4_Array[MD4_data +11], 9, 0x5A827999);
  R2_MD4(B,C,D,A,MD4_Array[MD4_data +15],13, 0x5A827999);
  //-----------------------------------------
  // Process round 3
  //-----------------------------------------
  R3_MD4(A,B,C,D,MD4_Array[MD4_data + 0], 3, 0x6ED9EBA1);
  R3_MD4(D,A,B,C,MD4_Array[MD4_data + 8], 9, 0x6ED9EBA1);
  R3_MD4(C,D,A,B,MD4_Array[MD4_data + 4],11, 0x6ED9EBA1);
  R3_MD4(B,C,D,A,MD4_Array[MD4_data +12],15, 0x6ED9EBA1);

  R3_MD4(A,B,C,D,MD4_Array[MD4_data + 2], 3, 0x6ED9EBA1);
  R3_MD4(D,A,B,C,MD4_Array[MD4_data +10], 9, 0x6ED9EBA1);
  R3_MD4(C,D,A,B,MD4_Array[MD4_data + 6],11, 0x6ED9EBA1);
  R3_MD4(B,C,D,A,MD4_Array[MD4_data +14],15, 0x6ED9EBA1);

  R3_MD4(A,B,C,D,MD4_Array[MD4_data + 1], 3, 0x6ED9EBA1);
  R3_MD4(D,A,B,C,MD4_Array[MD4_data + 9], 9, 0x6ED9EBA1);
  R3_MD4(C,D,A,B,MD4_Array[MD4_data + 5],11, 0x6ED9EBA1);
  R3_MD4(B,C,D,A,MD4_Array[MD4_data +13],15, 0x6ED9EBA1);

  R3_MD4(A,B,C,D,MD4_Array[MD4_data + 3], 3, 0x6ED9EBA1);
  R3_MD4(D,A,B,C,MD4_Array[MD4_data +11], 9, 0x6ED9EBA1);
  R3_MD4(C,D,A,B,MD4_Array[MD4_data + 7],11, 0x6ED9EBA1);
  R3_MD4(B,C,D,A,MD4_Array[MD4_data +15],15, 0x6ED9EBA1);

  //-------------------------------------------------
  // Calculate effective new digest 'register' values
  //-------------------------------------------------
  MD4_Array[MD4_A] += A;
  MD4_Array[MD4_B] += B;
  MD4_Array[MD4_C] += C;
  MD4_Array[MD4_D] += D;
}

extern "C" void MD4_Init(int MD4_Array[])
{
  MD4_Array[MD4_A] = INIT_A_MD4;			// initialize 'Register' values
  MD4_Array[MD4_B] = INIT_B_MD4;
  MD4_Array[MD4_C] = INIT_C_MD4;
  MD4_Array[MD4_D] = INIT_D_MD4;
  MD4_Array[MD4_LenL] = 0;			// Total byte length low = 0
  MD4_Array[MD4_LenH] = 0;			// dto. high = 0
  MD4_Array[MD4_DatCnt] = 0;			// no data in block buffer
  MD4_Array[MD4_DatInd] = 0;			// index
}

extern "C" void MD4_Update(int MD4_Array[], 
                           const char data[],
                           int offset, 
                           size_t len)
{
  int i,j;
  int nIndex,nlCnt,ncCnt,nCharIndex; 
  int l,l1,nFill,nCopy;

  if (len == 0)
    return;					// nothing to do
  //------------------------------------------------------------
  // Add up byte length to get new total byte length
  //------------------------------------------------------------
  l1 = static_cast<int>(len << 3);				    // get the BIT-Count
  ADD_64(MD4_Array[MD4_LenH],MD4_Array[MD4_LenL],l1); // sum up
  //------------------------------------------------------------
  // get bufferpointers and indices
  //------------------------------------------------------------
  nCharIndex = offset;
  //------------------------------------------------------------
  // process input data using block buffer
  //------------------------------------------------------------
  do
  {
    //----------------------------------------------------------
    // Fill Block buffer if possible
    //----------------------------------------------------------
    nIndex = (int) MD4_Array[MD4_DatInd];	// get current Field index
    //----------------------------------------------------------
    // copy data to blockbuffer until filled or data exhausted
    //----------------------------------------------------------
    j = (int) MD4_Array[MD4_DatCnt] & (int) 0x03;// get fill boundary
    if(j != 0)					// not on a long boundary
    {
      //--------------------------------------------------------
      // must fill up last long value from new data
      //--------------------------------------------------------
      i = (4-j) & 0x03;				// get fill byte count
      if(((uint32_t) i) > len)			// check for data end
        i = (int) len;
      MD4_Array[MD4_DatCnt] += i;		// new Byte count
      len -= i;					// reduce data count
      char2longcx(data,l1,i,nCharIndex)		// convert bytes to long
      MD4_Array[nIndex+MD4_data] |= (l1 <<(j*8));// save new long
      if((MD4_Array[MD4_DatCnt] & 0x03) == 0)	// check if long filled
      {
        nIndex++;				// increment index
        MD4_Array[MD4_DatInd]++;		// dto.
      }   
      if(len == 0)
      {
        //------------------------------------------------------
        // Data exhausted, check if last byte has been filled
        //------------------------------------------------------
        if(nIndex < MD4_LBLOCK)			// data exhausted, not filled
          return;
        MD4_Array[MD4_DatInd] = 0;	        // buffer filled !
        MD4_Array[MD4_DatCnt] = 0;
        //-------------------------------------------------------
        // process blockbuffer to generate new portion of digest
        //-------------------------------------------------------
        MD4BlockService(MD4_Array);		// generate digest portion
        return;
      }
    }
    //----------------------------------------------------------
    // caclulate remaining elements to fill
    //----------------------------------------------------------
    nFill = MD4_CBLOCK - MD4_Array[MD4_DatCnt];	// number of bytes required
    nCopy = nFill;				// preset bytes to copy
    if(((uint32_t) nFill) > len)
      nCopy = static_cast<int>(len);				// reduce copy count
    nlCnt = (int) nCopy/4;			// get long elements count
    ncCnt = (int) nCopy & (int) 0x03;		// get remaining bytes 
    for(i=nlCnt;i>0;i--)			// long elements copy loop
    {
      char2long(data,l,nCharIndex);		// get long
      MD4_Array[nIndex+MD4_data] = l;		// byte order dep. copy
      nIndex++;
    }
    if(ncCnt != 0)
    {
      char2longcx(data,l1,ncCnt,nCharIndex)	// byte order dependent copy
      MD4_Array[nIndex+MD4_data] = l1;
    }
    if(nCopy < nFill)				// not enough data, exit
    {
      MD4_Array[MD4_DatInd] = (int) nIndex &	// save index
                              (int) 0xFFFF;
      MD4_Array[MD4_DatCnt] += nCopy;		// save byte count
      return;
    }
    nIndex = 0;					// Buffer is now filled ...
    MD4_Array[MD4_DatInd] = 0;
    MD4_Array[MD4_DatCnt] = 0;
    //----------------------------------------------------------
    // process blockbuffer to generate new portion of digest
    //----------------------------------------------------------
    MD4BlockService(MD4_Array);			// generate digest portion
    len -= nFill;				// reduce remaining data count
  } while (len != 0);
}

extern "C" void MD4_Final(int MD4_Array[], char Digest[], int Offset)
{
  int i,nPadding;
  int nIndex=MD4_Array[MD4_DatInd];
  //----------------------------------------------------
  // pad with 1st Element
  //----------------------------------------------------
  i = (int) MD4_Array[MD4_DatCnt] & (int) 0x03;	// get start byte pos.
  if(i != 0)
    MD4_Array[nIndex+MD4_data] |=	// append 1st pad. value
      ((int) 0x80 << (i*8));
  else MD4_Array[nIndex+MD4_data] = 0x80;	// dto.
  nIndex++;
  //----------------------------------------------------
  // calculate remaining padding length
  //----------------------------------------------------
  nPadding = (int) (MD4_LAST_BLOCK - MD4_Array[MD4_DatCnt]);// req. padding len
  if(nPadding <= 0)					// last block too large
  {
    nPadding =(int) (MD4_CBLOCK - MD4_Array[MD4_DatCnt]);// true size to pad
    nPadding -= (4-i);				// reduce padding length
    for(i=nPadding/4;i != 0;i--)		// clear rest
    {
      MD4_Array[nIndex+MD4_data] = 0;
      nIndex++;
    }
    MD4BlockService(MD4_Array);			// generate digest portion
    nIndex = 0;					// set buffer bottom
    nPadding = MD4_LAST_BLOCK;			// set remaining padding count
  }
  else						// enough space in last
    nPadding -= (4-i);				// reduce padding length
  //----------------------------------------------------
  // pad rest with zeroes, process block
  //----------------------------------------------------
  for(i=nPadding/4;i != 0;i--)			// clear rest of buffer
  {
    MD4_Array[nIndex+MD4_data] = 0;
    nIndex++;
  }
  MD4_Array[nIndex+MD4_data] = MD4_Array[MD4_LenL];	// append length low
  nIndex++;
  MD4_Array[nIndex+MD4_data] = MD4_Array[MD4_LenH];	// append length high
  MD4BlockService(MD4_Array);			// generate digest
  //----------------------------------------------------
  // store message digest
  //----------------------------------------------------
//  i = 0;					// Start Index
  long2charn(MD4_Array[MD4_A],Digest,Offset)	// get 1st part
  long2charn(MD4_Array[MD4_B],Digest,Offset+4)	// get 2nd part
  long2charn(MD4_Array[MD4_C],Digest,Offset+8)	// get 3rd part
  long2charn(MD4_Array[MD4_D],Digest,Offset+12)// get 4th part
}


#endif //HL_ENCR_MD
// end of file ../MD4/m4.cpp


#ifdef HL_ENCR_MD
//#include <basetype.h>
/** @defgroup md5 MD 5
* This module implements the MD5 hash algorithm used for certificate signatures
* and SSL hashes.
*
* See RFC 1321 for description of algorithm.
* 
* The state array will NOT be cleared in the final step.
*
* No other modules are used.
* @{
* @file
* This file implements the MD5 message digest (hash) algorithm.
* @date  04.06.1998									
* @}
*/
#if (defined _WIN32) & (_MSC_VER < 1700)
#ifndef _STDINT
#define _STDINT
// MSVC lower than 17.00 does not have stdint.h, assure, all needed types are defined

typedef unsigned __int16 uint16_t;

typedef unsigned __int32 uint32_t;

typedef unsigned __int64 uint64_t;

#endif // !_STDINT
#else
#include <stdint.h>
#endif
#include <stddef.h>
#ifdef _WIN32
#define WIN32_LEAN_AND_MEAN
#include <Windows.h>
#undef WIN32_LEAN_AND_MEAN
#else// Define system-specific HL_* defines here
#ifndef HL_UNIX
#define HL_UNIX

#if (defined __gnu_linux__) || (defined __linux__)
#define HL_LINUX
#endif

#if (defined __APPLE__) && (defined __MACH__)
#define HL_LINUX
#define HL_MACOS
#endif

#ifdef _AIX
#define HL_AIX
#define HL_BIG_ENDIAN
#endif

#ifdef __FreeBSD__
#define HL_FREEBSD
#endif

#if (defined _hpux) || (defined hpux) || (defined __hpux)
#define HL_HPUX
#define HL_BIG_ENDIAN
#endif

#if (defined sun) || (defined __sun)
#define HL_SOLARIS
#endif

#if (defined __arm__) || (defined __aarch64__)
#define HL_LINUX_ARM
#endif

#ifdef __ANDROID__
#define HL_ANDROID
#endif

#endif
#include <hob-unix01.h>
#endif
#ifdef __APPLE__
/* We get target conditionals to keep apart Mac OS, iOS and iOS simulator.
   The conditionals are TARGET_IPHONE_SIMULATOR, TARGET_OS_IPHONE and TARGET_OS_MAC.
   TARGET_IPHONE_SIMULATOR has the highest priority, TARGET_OS_MAC the lowest.
   Always test, if the conditional is 1, as they will be defined as 0, if we 
   are not compiling for the target.
   */
#include <TargetConditionals.h>
#endif

#include "hob-encry-1.h"

#include <string.h>
#include <stdlib.h>
#include "hob-encry-intern-1.h"

/* Implemented from RFC1321: MD5 Message-Digest Algorithm	*/
/* Note: All Long values are treated as beeing stored in 	*/
/* ----- BIG ENDIAN Format according to RFC1321			*/
/* State: 16 Bit: checked o.k.					
*        32 Bit: not yet checked				
*/

/** @addtogroup md5
* @{
*/
/**
* Processes one complete, saved MD5 datablock and update the state array (MD5BlockService).
*								
* @param MD5_Array MD5 state array
*/
static void MD5BlockService(int* MD5_Array)
{
  int A,B,C,D;

  /*--------------------------------------------------------------------*/
  /* Get saved 'Register values'					*/
  /*--------------------------------------------------------------------*/
  A = MD5_Array[MD5_A];
  B = MD5_Array[MD5_B];
  C = MD5_Array[MD5_C];
  D = MD5_Array[MD5_D];
  /*--------------------------------------------------------------------*/
  /* Process round 1							*/
  /*--------------------------------------------------------------------*/
  /*--------------------------------------------------------------------*/
  /* Process round 1							*/
  /*--------------------------------------------------------------------*/
  R1_MD5(A,B,C,D,MD5_Array[MD5_data + 0], 7,(int) 0xd76aa478);
  R1_MD5(D,A,B,C,MD5_Array[MD5_data + 1],12,(int) 0xe8c7b756);
  R1_MD5(C,D,A,B,MD5_Array[MD5_data + 2],17,(int) 0x242070db);
  R1_MD5(B,C,D,A,MD5_Array[MD5_data + 3],22,(int) 0xc1bdceee);
  R1_MD5(A,B,C,D,MD5_Array[MD5_data + 4], 7,(int) 0xf57c0faf);
  R1_MD5(D,A,B,C,MD5_Array[MD5_data + 5],12,(int) 0x4787c62a);
  R1_MD5(C,D,A,B,MD5_Array[MD5_data + 6],17,(int) 0xa8304613);
  R1_MD5(B,C,D,A,MD5_Array[MD5_data + 7],22,(int) 0xfd469501);
  R1_MD5(A,B,C,D,MD5_Array[MD5_data + 8], 7,(int) 0x698098d8);
  R1_MD5(D,A,B,C,MD5_Array[MD5_data + 9],12,(int) 0x8b44f7af);
  R1_MD5(C,D,A,B,MD5_Array[MD5_data +10],17,(int) 0xffff5bb1);
  R1_MD5(B,C,D,A,MD5_Array[MD5_data +11],22,(int) 0x895cd7be);
  R1_MD5(A,B,C,D,MD5_Array[MD5_data +12], 7,(int) 0x6b901122);
  R1_MD5(D,A,B,C,MD5_Array[MD5_data +13],12,(int) 0xfd987193);
  R1_MD5(C,D,A,B,MD5_Array[MD5_data +14],17,(int) 0xa679438e);
  R1_MD5(B,C,D,A,MD5_Array[MD5_data +15],22,(int) 0x49b40821);
  /*--------------------------------------------------------------------*/
  /* Process round 2							*/
  /*--------------------------------------------------------------------*/
  R2_MD5(A,B,C,D,MD5_Array[MD5_data + 1], 5,(int) 0xf61e2562);
  R2_MD5(D,A,B,C,MD5_Array[MD5_data + 6], 9,(int) 0xc040b340);
  R2_MD5(C,D,A,B,MD5_Array[MD5_data +11],14,(int) 0x265e5a51);
  R2_MD5(B,C,D,A,MD5_Array[MD5_data + 0],20,(int) 0xe9b6c7aa);
  R2_MD5(A,B,C,D,MD5_Array[MD5_data + 5], 5,(int) 0xd62f105d);
  R2_MD5(D,A,B,C,MD5_Array[MD5_data +10], 9,(int) 0x02441453);
  R2_MD5(C,D,A,B,MD5_Array[MD5_data +15],14,(int) 0xd8a1e681);
  R2_MD5(B,C,D,A,MD5_Array[MD5_data + 4],20,(int) 0xe7d3fbc8);
  R2_MD5(A,B,C,D,MD5_Array[MD5_data + 9], 5,(int) 0x21e1cde6);
  R2_MD5(D,A,B,C,MD5_Array[MD5_data +14], 9,(int) 0xc33707d6);
  R2_MD5(C,D,A,B,MD5_Array[MD5_data + 3],14,(int) 0xf4d50d87);
  R2_MD5(B,C,D,A,MD5_Array[MD5_data + 8],20,(int) 0x455a14ed);
  R2_MD5(A,B,C,D,MD5_Array[MD5_data +13], 5,(int) 0xa9e3e905);
  R2_MD5(D,A,B,C,MD5_Array[MD5_data + 2], 9,(int) 0xfcefa3f8);
  R2_MD5(C,D,A,B,MD5_Array[MD5_data + 7],14,(int) 0x676f02d9);
  R2_MD5(B,C,D,A,MD5_Array[MD5_data +12],20,(int) 0x8d2a4c8a);
  /*--------------------------------------------------------------------*/
  /* Process round 3							*/
  /*--------------------------------------------------------------------*/
  R3_MD5(A,B,C,D,MD5_Array[MD5_data + 5], 4,(int) 0xfffa3942);
  R3_MD5(D,A,B,C,MD5_Array[MD5_data + 8],11,(int) 0x8771f681);
  R3_MD5(C,D,A,B,MD5_Array[MD5_data +11],16,(int) 0x6d9d6122);
  R3_MD5(B,C,D,A,MD5_Array[MD5_data +14],23,(int) 0xfde5380c);
  R3_MD5(A,B,C,D,MD5_Array[MD5_data + 1], 4,(int) 0xa4beea44);
  R3_MD5(D,A,B,C,MD5_Array[MD5_data + 4],11,(int) 0x4bdecfa9);
  R3_MD5(C,D,A,B,MD5_Array[MD5_data + 7],16,(int) 0xf6bb4b60);
  R3_MD5(B,C,D,A,MD5_Array[MD5_data +10],23,(int) 0xbebfbc70);
  R3_MD5(A,B,C,D,MD5_Array[MD5_data +13], 4,(int) 0x289b7ec6);
  R3_MD5(D,A,B,C,MD5_Array[MD5_data + 0],11,(int) 0xeaa127fa);
  R3_MD5(C,D,A,B,MD5_Array[MD5_data + 3],16,(int) 0xd4ef3085);
  R3_MD5(B,C,D,A,MD5_Array[MD5_data + 6],23,(int) 0x04881d05);
  R3_MD5(A,B,C,D,MD5_Array[MD5_data + 9], 4,(int) 0xd9d4d039);
  R3_MD5(D,A,B,C,MD5_Array[MD5_data +12],11,(int) 0xe6db99e5);
  R3_MD5(C,D,A,B,MD5_Array[MD5_data +15],16,(int) 0x1fa27cf8);
  R3_MD5(B,C,D,A,MD5_Array[MD5_data + 2],23,(int) 0xc4ac5665);
  /*--------------------------------------------------------------------*/
  /* Process round 4							*/
  /*--------------------------------------------------------------------*/
  R4_MD5(A,B,C,D,MD5_Array[MD5_data + 0], 6,(int) 0xf4292244);
  R4_MD5(D,A,B,C,MD5_Array[MD5_data + 7],10,(int) 0x432aff97);
  R4_MD5(C,D,A,B,MD5_Array[MD5_data +14],15,(int) 0xab9423a7);
  R4_MD5(B,C,D,A,MD5_Array[MD5_data + 5],21,(int) 0xfc93a039);
  R4_MD5(A,B,C,D,MD5_Array[MD5_data +12], 6,(int) 0x655b59c3);
  R4_MD5(D,A,B,C,MD5_Array[MD5_data + 3],10,(int) 0x8f0ccc92);
  R4_MD5(C,D,A,B,MD5_Array[MD5_data +10],15,(int) 0xffeff47d);
  R4_MD5(B,C,D,A,MD5_Array[MD5_data + 1],21,(int) 0x85845dd1);
  R4_MD5(A,B,C,D,MD5_Array[MD5_data + 8], 6,(int) 0x6fa87e4f);
  R4_MD5(D,A,B,C,MD5_Array[MD5_data +15],10,(int) 0xfe2ce6e0);
  R4_MD5(C,D,A,B,MD5_Array[MD5_data + 6],15,(int) 0xa3014314);
  R4_MD5(B,C,D,A,MD5_Array[MD5_data +13],21,(int) 0x4e0811a1);
  R4_MD5(A,B,C,D,MD5_Array[MD5_data + 4], 6,(int) 0xf7537e82);
  R4_MD5(D,A,B,C,MD5_Array[MD5_data +11],10,(int) 0xbd3af235);
  R4_MD5(C,D,A,B,MD5_Array[MD5_data + 2],15,(int) 0x2ad7d2bb);
  R4_MD5(B,C,D,A,MD5_Array[MD5_data + 9],21,(int) 0xeb86d391);
  /*--------------------------------------------------------------------*/
  /* Calculate effective new digest 'register' values			*/
  /*--------------------------------------------------------------------*/
  MD5_Array[MD5_A] += A;
  MD5_Array[MD5_B] += B;
  MD5_Array[MD5_C] += C;
  MD5_Array[MD5_D] += D;
}

extern "C" void MD5_Init(int* MD5_Array)
{
  MD5_Array[MD5_A] = INIT_A_MD5;			// initialize 'Register' values
  MD5_Array[MD5_B] = INIT_B_MD5;
  MD5_Array[MD5_C] = INIT_C_MD5;
  MD5_Array[MD5_D] = INIT_D_MD5;
  MD5_Array[MD5_LenL] = 0;			// Total byte length low = 0
  MD5_Array[MD5_LenH] = 0;			// dto. high = 0
  MD5_Array[MD5_DatCnt] = 0;			// no data in block buffer
  MD5_Array[MD5_DatInd] = 0;			// index
}

extern "C" void MD5_Update(int MD5_Array[],
                           const char data[],
                           int offset,
                           size_t len)
{
  int i,j;
  int nIndex,nlCnt,ncCnt,nCharIndex; 
//  BIT32 l,l1,l2,nFill,nCopy;
  int l,l1,nFill,nCopy;

  if (len == 0) return;				// nothing to do
  /*------------------------------------------------------------*/
  /* Add up byte length to get new total byte length		*/
  /*------------------------------------------------------------*/

  l1 = static_cast<int>(len << 3);				    // get the BIT-Count
  ADD_64(MD5_Array[MD5_LenH],MD5_Array[MD5_LenL],l1); // sum up
  /*------------------------------------------------------------*/
  /* get bufferpointers and indices				*/
  /*------------------------------------------------------------*/
  nCharIndex = offset;
  /*------------------------------------------------------------*/
  /* process input data using block buffer			*/
  /*------------------------------------------------------------*/
  do
  {
    /*----------------------------------------------------------*/
    /* Fill Block buffer if possible				*/
    /*----------------------------------------------------------*/
    nIndex = (int) MD5_Array[MD5_DatInd];	// get current Field index
    /*----------------------------------------------------------*/
    /* copy data to blockbuffer until filled or data exhausted	*/
    /*----------------------------------------------------------*/
    j = (int) MD5_Array[MD5_DatCnt] & (int) 0x03;// get fill boundary
    if(j != 0)					// not on a long boundary
    {
      /*--------------------------------------------------------*/
      /* must fill up last long value from new data		*/
      /*--------------------------------------------------------*/
      i = (4-j) & 0x03;				// get fill byte count
      if(((uint32_t) i) > len) i = (int) len;	// check for data end
      MD5_Array[MD5_DatCnt] += i;		// new Byte count
      len -= i;					// reduce data count
      char2longcx(data,l1,i,nCharIndex)		// convert bytes to long
      MD5_Array[nIndex+MD5_data] |= (l1 <<(j*8));// save new long
      if((MD5_Array[MD5_DatCnt] & 0x03) == 0)	// check if long filled
      {
        nIndex++;				// increment index
        MD5_Array[MD5_DatInd]++;		// dto.
      }   
      if(len == 0)
      {
        /*------------------------------------------------------*/
        /* Data exhausted, check if last byte has been filled	*/
        /*------------------------------------------------------*/
        if(nIndex < MD5_LBLOCK) return;		// data exhausted, not filled
        MD5_Array[MD5_DatInd] = 0;	        // buffer filled !
        MD5_Array[MD5_DatCnt] = 0;
        /*-------------------------------------------------------*/
        /* process blockbuffer to generate new portion of digest */
        /*-------------------------------------------------------*/
        MD5BlockService(MD5_Array);		// generate digest portion
        return;
      }
    }
    /*----------------------------------------------------------*/
    /* caclulate remaining elements to fill			*/
    /*----------------------------------------------------------*/
    nFill = MD5_CBLOCK - MD5_Array[MD5_DatCnt];	// number of bytes required
    nCopy = nFill;				// preset bytes to copy
    if(((uint32_t) nFill) > len) nCopy = static_cast<int>(len);	// reduce copy count
    nlCnt = (int) nCopy/4;			// get long elements count
    ncCnt = (int) nCopy & (int) 0x03;		// get remaining bytes 
    for(i=nlCnt;i>0;i--)			// long elements copy loop
    {
      char2long(data,l,nCharIndex);		// get long
      MD5_Array[nIndex+MD5_data] = l;		// byte order dep. copy
      nIndex++;
    }
    if(ncCnt != 0)
    {
      char2longcx(data,l1,ncCnt,nCharIndex)	// byte order dependent copy
      MD5_Array[nIndex+MD5_data] = l1;
    }
    if(nCopy < nFill)				// not enough data, exit
    {
      MD5_Array[MD5_DatInd] = (int) nIndex &	// save index
                              (int) 0xFFFF;
      MD5_Array[MD5_DatCnt] += nCopy;		// save byte count
      return;
    }
    nIndex = 0;					// Buffer is now filled ...
    MD5_Array[MD5_DatInd] = 0;
    MD5_Array[MD5_DatCnt] = 0;
    /*----------------------------------------------------------*/
    /* process blockbuffer to generate new portion of digest	*/
    /*----------------------------------------------------------*/
    MD5BlockService(MD5_Array);			// generate digest portion
    len -= nFill;				// reduce remaining data count
  } while (len != 0);
}

extern "C" void MD5_Final(int* MD5_Array,
				  char* Digest, int Offset)
{
  int i,nPadding;
  int nIndex=MD5_Array[MD5_DatInd];
//  REGISTER BIT32 l;

  /*----------------------------------------------------*/
  /* pad with 1st Element				*/
  /*----------------------------------------------------*/
  i = (int) MD5_Array[MD5_DatCnt] & (int) 0x03;	// get start byte pos.
  if(i != 0) MD5_Array[nIndex+MD5_data] |=	// append 1st pad. value
    ((int) 0x80 << (i*8));
  else MD5_Array[nIndex+MD5_data] = 0x80;	// dto.
  nIndex++;
  /*----------------------------------------------------*/
  /* calculate remaining padding length			*/
  /*----------------------------------------------------*/
  nPadding = (int) (MD5_LAST_BLOCK - MD5_Array[MD5_DatCnt]);// req. padding len
// Next Line was definitely  w r o n g ! (if data(mod64) = 56 -> padding=0!)
//  if(nPadding < 0)					// last block too large
  if(nPadding <= 0)					// last block too large
  {
    nPadding =(int) (MD5_CBLOCK - MD5_Array[MD5_DatCnt]);// true size to pad
    nPadding -= (4-i);				// reduce padding length
    for(i=nPadding/4;i != 0;i--)		// clear rest
    {
      MD5_Array[nIndex+MD5_data] = 0;
      nIndex++;
    }
    MD5BlockService(MD5_Array);			// generate digest portion
    nIndex = 0;					// set buffer bottom
    nPadding = MD5_LAST_BLOCK;			// set remaining padding count
  }
  else						// enough space in last
    nPadding -= (4-i);				// reduce padding length
  /*----------------------------------------------------*/
  /* pad rest with zeroes, process block		*/
  /*----------------------------------------------------*/
  for(i=nPadding/4;i != 0;i--)			// clear rest of buffer
  {
    MD5_Array[nIndex+MD5_data] = 0;
    nIndex++;
  }
  MD5_Array[nIndex+MD5_data] = MD5_Array[MD5_LenL];	// append length low
  nIndex++;
  MD5_Array[nIndex+MD5_data] = MD5_Array[MD5_LenH];	// append length high
  MD5BlockService(MD5_Array);			// generate digest
  /*----------------------------------------------------*/
  /* store message digest				*/
  /*----------------------------------------------------*/
//  i = 0;					// Start Index
  long2charn(MD5_Array[MD5_A],Digest,Offset)	// get 1st part
  long2charn(MD5_Array[MD5_B],Digest,Offset+4)	// get 2nd part
  long2charn(MD5_Array[MD5_C],Digest,Offset+8)	// get 3rd part
  long2charn(MD5_Array[MD5_D],Digest,Offset+12)// get 4th part
}

/** @}*/

#endif //HL_ENCR_MD
// end of file ../MD5/m5.cpp


#ifdef HL_ENCR_SHA
/** @defgroup sha1 SHA1
* @brief SHA-1 cryptographic hash implementation
*
* This module implements the SHA-1 message digest (hash) algorithm as described
* in FIPS PUB 180-1.
*
* The call to the final function will clear the state array.
*
* No other modules are used.
* @{
* @file
* This file implements the SHA 1 hash algorithm.
* @date 14.10.1998
* @}
*/

#include <string.h>
#if (defined _WIN32) & (_MSC_VER < 1700)
#ifndef _STDINT
#define _STDINT
// MSVC lower than 17.00 does not have stdint.h, assure, all needed types are defined

typedef unsigned __int16 uint16_t;

typedef unsigned __int32 uint32_t;

typedef unsigned __int64 uint64_t;

#endif // !_STDINT
#else
#include <stdint.h>
#endif
#include <stddef.h>
#ifdef _WIN32
#define WIN32_LEAN_AND_MEAN
#include <Windows.h>
#undef WIN32_LEAN_AND_MEAN
#else// Define system-specific HL_* defines here
#ifndef HL_UNIX
#define HL_UNIX

#if (defined __gnu_linux__) || (defined __linux__)
#define HL_LINUX
#endif

#if (defined __APPLE__) && (defined __MACH__)
#define HL_LINUX
#define HL_MACOS
#endif

#ifdef _AIX
#define HL_AIX
#define HL_BIG_ENDIAN
#endif

#ifdef __FreeBSD__
#define HL_FREEBSD
#endif

#if (defined _hpux) || (defined hpux) || (defined __hpux)
#define HL_HPUX
#define HL_BIG_ENDIAN
#endif

#if (defined sun) || (defined __sun)
#define HL_SOLARIS
#endif

#if (defined __arm__) || (defined __aarch64__)
#define HL_LINUX_ARM
#endif

#ifdef __ANDROID__
#define HL_ANDROID
#endif

#endif
#include <hob-unix01.h>
#endif
#ifdef __APPLE__
/* We get target conditionals to keep apart Mac OS, iOS and iOS simulator.
   The conditionals are TARGET_IPHONE_SIMULATOR, TARGET_OS_IPHONE and TARGET_OS_MAC.
   TARGET_IPHONE_SIMULATOR has the highest priority, TARGET_OS_MAC the lowest.
   Always test if the conditional is 1, as they will be defined as 0 if we 
   are not compiling for the target.
   */
#include <TargetConditionals.h>
#endif

#include "hob-encry-1.h"
#include <stdlib.h>
#include "hob-encry-intern-1.h"

// on Windows 64 bit, SHA is also available in assembler
#if HOB_WIN64_ASM != 1
//sha1_block
static void sha1_block(uint32_t SHA_Array[])
{
   uint32_t iT;
   uint32_t iA = SHA_Array[SHA_h0];
   uint32_t iB = SHA_Array[SHA_h1];
   uint32_t iC = SHA_Array[SHA_h2];
   uint32_t iD = SHA_Array[SHA_h3];
   uint32_t iE = SHA_Array[SHA_h4];

   BODY_00_15( 0,iA,iB,iC,iD,iE,iT);
   BODY_00_15( 1,iT,iA,iB,iC,iD,iE);
   BODY_00_15( 2,iE,iT,iA,iB,iC,iD);
   BODY_00_15( 3,iD,iE,iT,iA,iB,iC);
   BODY_00_15( 4,iC,iD,iE,iT,iA,iB);
   BODY_00_15( 5,iB,iC,iD,iE,iT,iA);
   BODY_00_15( 6,iA,iB,iC,iD,iE,iT);
   BODY_00_15( 7,iT,iA,iB,iC,iD,iE);
   BODY_00_15( 8,iE,iT,iA,iB,iC,iD);
   BODY_00_15( 9,iD,iE,iT,iA,iB,iC);
   BODY_00_15(10,iC,iD,iE,iT,iA,iB);
   BODY_00_15(11,iB,iC,iD,iE,iT,iA);
   BODY_00_15(12,iA,iB,iC,iD,iE,iT);
   BODY_00_15(13,iT,iA,iB,iC,iD,iE);
   BODY_00_15(14,iE,iT,iA,iB,iC,iD);
   BODY_00_15(15,iD,iE,iT,iA,iB,iC);
   BODY_16_19(16,iC,iD,iE,iT,iA,iB);
   BODY_16_19(17,iB,iC,iD,iE,iT,iA);
   BODY_16_19(18,iA,iB,iC,iD,iE,iT);
   BODY_16_19(19,iT,iA,iB,iC,iD,iE);

   BODY_20_39(20,iE,iT,iA,iB,iC,iD);
   BODY_20_39(21,iD,iE,iT,iA,iB,iC);
   BODY_20_39(22,iC,iD,iE,iT,iA,iB);
   BODY_20_39(23,iB,iC,iD,iE,iT,iA);
   BODY_20_39(24,iA,iB,iC,iD,iE,iT);
   BODY_20_39(25,iT,iA,iB,iC,iD,iE);
   BODY_20_39(26,iE,iT,iA,iB,iC,iD);
   BODY_20_39(27,iD,iE,iT,iA,iB,iC);
   BODY_20_39(28,iC,iD,iE,iT,iA,iB);
   BODY_20_39(29,iB,iC,iD,iE,iT,iA);
   BODY_20_39(30,iA,iB,iC,iD,iE,iT);
   BODY_20_39(31,iT,iA,iB,iC,iD,iE);
   BODY_20_39(32,iE,iT,iA,iB,iC,iD);
   BODY_20_39(33,iD,iE,iT,iA,iB,iC);
   BODY_20_39(34,iC,iD,iE,iT,iA,iB);
   BODY_20_39(35,iB,iC,iD,iE,iT,iA);
   BODY_20_39(36,iA,iB,iC,iD,iE,iT);
   BODY_20_39(37,iT,iA,iB,iC,iD,iE);
   BODY_20_39(38,iE,iT,iA,iB,iC,iD);
   BODY_20_39(39,iD,iE,iT,iA,iB,iC);

   BODY_40_59(40,iC,iD,iE,iT,iA,iB);
   BODY_40_59(41,iB,iC,iD,iE,iT,iA);
   BODY_40_59(42,iA,iB,iC,iD,iE,iT);
   BODY_40_59(43,iT,iA,iB,iC,iD,iE);
   BODY_40_59(44,iE,iT,iA,iB,iC,iD);
   BODY_40_59(45,iD,iE,iT,iA,iB,iC);
   BODY_40_59(46,iC,iD,iE,iT,iA,iB);
   BODY_40_59(47,iB,iC,iD,iE,iT,iA);
   BODY_40_59(48,iA,iB,iC,iD,iE,iT);
   BODY_40_59(49,iT,iA,iB,iC,iD,iE);
   BODY_40_59(50,iE,iT,iA,iB,iC,iD);
   BODY_40_59(51,iD,iE,iT,iA,iB,iC);
   BODY_40_59(52,iC,iD,iE,iT,iA,iB);
   BODY_40_59(53,iB,iC,iD,iE,iT,iA);
   BODY_40_59(54,iA,iB,iC,iD,iE,iT);
   BODY_40_59(55,iT,iA,iB,iC,iD,iE);
   BODY_40_59(56,iE,iT,iA,iB,iC,iD);
   BODY_40_59(57,iD,iE,iT,iA,iB,iC);
   BODY_40_59(58,iC,iD,iE,iT,iA,iB);
   BODY_40_59(59,iB,iC,iD,iE,iT,iA);

   BODY_60_79(60,iA,iB,iC,iD,iE,iT);
   BODY_60_79(61,iT,iA,iB,iC,iD,iE);
   BODY_60_79(62,iE,iT,iA,iB,iC,iD);
   BODY_60_79(63,iD,iE,iT,iA,iB,iC);
   BODY_60_79(64,iC,iD,iE,iT,iA,iB);
   BODY_60_79(65,iB,iC,iD,iE,iT,iA);
   BODY_60_79(66,iA,iB,iC,iD,iE,iT);
   BODY_60_79(67,iT,iA,iB,iC,iD,iE);
   BODY_60_79(68,iE,iT,iA,iB,iC,iD);
   BODY_60_79(69,iD,iE,iT,iA,iB,iC);
   BODY_60_79(70,iC,iD,iE,iT,iA,iB);
   BODY_60_79(71,iB,iC,iD,iE,iT,iA);
   BODY_60_79(72,iA,iB,iC,iD,iE,iT);
   BODY_60_79(73,iT,iA,iB,iC,iD,iE);
   BODY_60_79(74,iE,iT,iA,iB,iC,iD);
   BODY_60_79(75,iD,iE,iT,iA,iB,iC);
   BODY_60_79(76,iC,iD,iE,iT,iA,iB);
   BODY_60_79(77,iB,iC,iD,iE,iT,iA);
   BODY_60_79(78,iA,iB,iC,iD,iE,iT);
   BODY_60_79(79,iT,iA,iB,iC,iD,iE);

   SHA_Array[SHA_h0] += iE;
   SHA_Array[SHA_h1] += iT;
   SHA_Array[SHA_h2] += iA;
   SHA_Array[SHA_h3] += iB;
   SHA_Array[SHA_h4] += iC;
}

/** @addtogroup sha1
*@{
*/

extern "C" void SHA1_Init(int* SHA_Array)
{

#if defined _WIN32 && defined _DEBUG
   // The next added to keep INSURE happy
   memset(SHA_Array,0,SHA_ARRAY_SIZE*4);
#endif

   SHA_Array[SHA_h0]  = INIT_DATA_h0;
   SHA_Array[SHA_h1]  = INIT_DATA_h1;
   SHA_Array[SHA_h2]  = INIT_DATA_h2;
   SHA_Array[SHA_h3]  = INIT_DATA_h3;
   SHA_Array[SHA_h4]  = INIT_DATA_h4;
   SHA_Array[SHA_Nl]  = 0;
   SHA_Array[SHA_Nh]  = 0;
   SHA_Array[SHA_num] = 0;
}

extern "C" void SHA1_Update(int SHA_Array[], 
                            const char data[],
                            int Offset,
                            size_t len)
{  
   int i,j,ew,ec,sw,sc;
   uint32_t l;

   if(len == 0)				// check zero length
      return;
   //----------------------------------------------------------------
   // calulate new total B I T - length
   //----------------------------------------------------------------
   l = (uint32_t) SHA_Array[SHA_Nl];	// Save for Carry check
   SHA_Array[SHA_Nl] =			// add new length bit count
      (uint32_t) SHA_Array[SHA_Nl] + (uint32_t) (len << 3);

   if(l > (uint32_t) SHA_Array[SHA_Nl])	// had a Carry out
      SHA_Array[SHA_Nh]++;

   i = Offset;					// Data-Array StartIndex
   if(SHA_Array[SHA_num] != 0)			// check for saved data in array
   {
      //=================================================================
      // stored data in array, fill up until SHA-Block complete (16 longs)
      // or data exhausted
      //=================================================================
      //    sw = (int) ((((BIT16) SHA_Array[SHA_num] & (0x7F)) >> 2)); // full longs
      sw = (int) (SHA_Array[SHA_num] >> 2);	 // full 4Byte longs
      sc = (int) (SHA_Array[SHA_num] & 0x03);	 // remaining bytes

      // NOTE: overflow will occur above 4 GByte - 64 Byte !! (> (2**31-1) - 64)

      if((SHA_Array[SHA_num] + len) >= SHA_CBLOCK)
      {
         //---------------------------------------------------------------
         // enough data to complete array, do copy data to array,
         // generate Digest
         //---------------------------------------------------------------
         l = SHA_Array[sw + SHA_data];	// get address of next or incomplete
         BIGchar2longc(data,l,sc,i);	// get required bytes
         SHA_Array[sw + SHA_data] = l;	// save to array
         sw++;				// to next location
         for (; sw < SHA_LBLOCK; sw++)	// continue copying full longs
         {
            BIGchar2long(data,l,i);
            SHA_Array[sw + SHA_data] = l;
         }
         len -= (SHA_CBLOCK - SHA_Array[SHA_num]);	// reduce length

         sha1_block((uint32_t*) SHA_Array);	// get digest
         SHA_Array[SHA_num] = 0;			// no data in array
      }  
      else
      {
         //---------------------------------------------------------------
         // not enough data to complete array, do copy data to array only
         // and exit
         //---------------------------------------------------------------
         SHA_Array[SHA_num] += static_cast<int>(len);   // remaining bytes, always < 64
         if ((sc + (int) len) < 4)		// cannot fill a full long
         {
            l = SHA_Array[sw + SHA_data];	// get saved bytes (if any)
            switch(sc)
            {
            case 0:					// no bytes saved
               l = ((int) data[i++] & 0xFF) << 24;	// save byte
               len--;
               if(len == 0)
                  break;
            case 1:					// 1 byte saved
               l |= (((int) data[i++] & 0xFF) << 16);	// insert next
               len--;
               if(len == 0)
                  break;
            case 2:					// 2 byte saved
               l |= (((int) data[i++] & 0xFF) << 8);	// insert next
               len--;
               if(len == 0)
                  break;
            case 3:					// 3 byte saved
               l |= ((int) data[i++] & 0xFF);		// insert next
               break;
            }
            SHA_Array[sw + SHA_data] = l;	// save incomplete long
         }
         else
         {
            ew = (int) SHA_Array[SHA_num];	// get ending byte count
            ec = ew & 0x03;			// incomplete ending byte count
            ew >>= 2;			// full longs for copy

            l = SHA_Array[sw + SHA_data];	// get saved bytes (if any)
            BIGchar2longc(data,l,sc,i);	// insert bytes or copy full long
            SHA_Array[sw + SHA_data] = l;	// save full long
            sw++;				// to next long

            for(; sw < ew; sw++)		// copy full longs
            {
               BIGchar2long(data,l,i);
               SHA_Array[sw + SHA_data] = l;
            }
            if(ec != 0)			// remaining bytes to copy into a long
            {
               BIGchar2long3n(data,l,ec,i);
               SHA_Array[sw + SHA_data] = l;
            }
         }
         return;				// exit, wait for more data
      }
   } // end of stored data preprocessing
   //=================================================================
   // no stored data in array, start storing data until filled up
   //=================================================================
   while (len >= SHA_CBLOCK)		// only for full blocks
   {
      j = SHA_data;			// index to Stored data
      for(sw=(SHA_BLOCK/4);sw != 0; sw--)	// full long copy loop
      {

         BIGchar2longn(data,l,i);    SHA_Array[j]   = l;
         BIGchar2longn(data,l,(i+4));  SHA_Array[j+1] = l;
         BIGchar2longn(data,l,(i+8));  SHA_Array[j+2] = l;
         BIGchar2longn(data,l,(i+12)); SHA_Array[j+3] = l;
         i += 16;
         j += 4;

      }
      sha1_block((uint32_t*) SHA_Array);		// process Digest
      len -= SHA_CBLOCK;				// subtract blocklength
   }
   //
   // calculate remaining longs and rest bytes/long
   //
   ec = (int) len;				// is always < SHA_BLOCK !!
   //  SHA_Array[SHA_num] = (BIT32) ec & 0xFF;	// save remaining data bytes
   SHA_Array[SHA_num] = (int) ec;		// save remaining data bytes
   ew = ec >> 2;					// calculate full long count
   ec &= 0x03;					// get last remaining bytes

   sw = 0;					// index data field start
   for (; sw < ew; sw++)				// copy full longs if any
   {
      BIGchar2long(data,l,i);
      SHA_Array[sw + SHA_data] = l;
   }
   // next line was missing in original !!
   if(ec != 0)					// copy remaining bytes if any
   {
      BIGchar2long3n(data,l,ec,i);
      SHA_Array[sw + SHA_data] = l;
   } 

}

extern "C" void SHA1_Final(int* SHA_Array,
                           char* Digest, int Offset)
{
   int i,j;
   uint32_t l;

   static unsigned char end[4] = {(unsigned char)0x80,(unsigned char)0x00,(unsigned char)0x00,(unsigned char)0x00};	// padding bytes array

   /* Array data should definitly have room for at least one more byte. */

   //---------------------------------------------------------------
   // Get stored long and remaining byte counts, append padding bits
   //---------------------------------------------------------------
   j = (int) SHA_Array[SHA_num];		// get stored long count
   i = j >> 2;				// get remaining byte count

   l = SHA_Array[i+SHA_data];		// get last stored long
   BIGchar2longcn(end,l,(j & 0x03));	// insert 1..4 padding bytes
   SHA_Array[i+SHA_data] = l;		// save full long
   i++;					// to next long (not yet loaded)
   //---------------------------------------------------------------
   // check if this block has room for length data (8 bytes)
   // if not fill with zeroes and generate Digest
   //---------------------------------------------------------------
   if (SHA_Array[SHA_num] >= SHA_LAST_BLOCK)	// not enough room
   {

      for (; i<SHA_LBLOCK; i++) SHA_Array[i+SHA_data] = 0; // zero data

      sha1_block((uint32_t*) SHA_Array);		// generate digest
      i = 0;					// set index back
   }
   //---------------------------------------------------------------
   // fill block with zeroes until position for length reached,
   // insert bitlength, generate final Digest
   //---------------------------------------------------------------

   for (; i<(SHA_LBLOCK-2); i++)	SHA_Array[i+SHA_data]=0; // clear

   SHA_Array[SHA_data+(SHA_LBLOCK-2)] = SHA_Array[SHA_Nh]; // set length high
   SHA_Array[SHA_data+(SHA_LBLOCK-1)] = SHA_Array[SHA_Nl]; // dto. low
   sha1_block((uint32_t*) SHA_Array);		// generate final digest
   //---------------------------------------------------------------
   // copy final digest to user buffer, clear SHA Array (safety)
   //---------------------------------------------------------------
   l = SHA_Array[SHA_h0]; BIGlong2charn(l,Digest,Offset+0);
   l = SHA_Array[SHA_h1]; BIGlong2charn(l,Digest,Offset+4);
   l = SHA_Array[SHA_h2]; BIGlong2charn(l,Digest,Offset+8);
   l = SHA_Array[SHA_h3]; BIGlong2charn(l,Digest,Offset+12);
   l = SHA_Array[SHA_h4]; BIGlong2charn(l,Digest,Offset+16);

   memset(SHA_Array,0,sizeof(uint32_t) * SHA_ARRAY_SIZE);
}
/** @} */

#endif // !(defined USE_ASSEMBLER_SOURCES && defined _WIN64)

#endif //HL_ENCR_SHA
// end of file ../SHA1/s1.cpp


#ifdef HL_ENCR_SHA
/** @defgroup sha2 SHA2
* @brief SHA-2 cryptographic hash family implementation
*
* This module implements the SHA-2 message digest family, described in
* FIPS PUB 180-2. All four hash lengths are implemented.
*
* SHA-224 and SHA-256 use a state array of 32 bit integers, SHA-384 and SHA 512
* one of 64 bit integers.
*
* The call to the final function will clear the state array in any case.
*
* No other modules are used.
* @{
* @file
* This file implements the SHA 2 hash family.
* @date 14.10.1998
* @}
*/
#include <string.h>
#if (defined _WIN32) & (_MSC_VER < 1700)
#ifndef _STDINT
#define _STDINT
// MSVC lower than 17.00 does not have stdint.h, assure, all needed types are defined

typedef unsigned __int16 uint16_t;

typedef unsigned __int32 uint32_t;

typedef unsigned __int64 uint64_t;

#endif // !_STDINT
#else
#include <stdint.h>
#endif
#include <stddef.h>
#ifdef _WIN32
#define WIN32_LEAN_AND_MEAN
#include <Windows.h>
#undef WIN32_LEAN_AND_MEAN
#else// Define system-specific HL_* defines here
#ifndef HL_UNIX
#define HL_UNIX

#if (defined __gnu_linux__) || (defined __linux__)
#define HL_LINUX
#endif

#if (defined __APPLE__) && (defined __MACH__)
#define HL_LINUX
#define HL_MACOS
#endif

#ifdef _AIX
#define HL_AIX
#define HL_BIG_ENDIAN
#endif

#ifdef __FreeBSD__
#define HL_FREEBSD
#endif

#if (defined _hpux) || (defined hpux) || (defined __hpux)
#define HL_HPUX
#define HL_BIG_ENDIAN
#endif

#if (defined sun) || (defined __sun)
#define HL_SOLARIS
#endif

#if (defined __arm__) || (defined __aarch64__)
#define HL_LINUX_ARM
#endif

#ifdef __ANDROID__
#define HL_ANDROID
#endif

#endif
#include <hob-unix01.h>
#endif
#ifdef __APPLE__
/* We get target conditionals to keep apart Mac OS, iOS and iOS simulator.
   The conditionals are TARGET_IPHONE_SIMULATOR, TARGET_OS_IPHONE and TARGET_OS_MAC.
   TARGET_IPHONE_SIMULATOR has the highest priority, TARGET_OS_MAC the lowest.
   Always test if the conditional is 1, as they will be defined as 0 if we 
   are not compiling for the target.
   */
#include <TargetConditionals.h>
#endif

#include "hob-encry-1.h"
#include "hob-encry-intern-1.h"

//===============================================================
// Constant arrays for SHA256 and SHA384/512 for Block operations
//===============================================================
//BIT32ARRAYI
static int Sha256Const[64] = {
  K0_SHA256,  K1_SHA256,  K2_SHA256,  K3_SHA256,
  K4_SHA256,  K5_SHA256,  K6_SHA256,  K7_SHA256,
  K8_SHA256,  K9_SHA256,  K10_SHA256, K11_SHA256,
  K12_SHA256, K13_SHA256, K14_SHA256, K15_SHA256,
  K16_SHA256, K17_SHA256, K18_SHA256, K19_SHA256,
  K20_SHA256, K21_SHA256, K22_SHA256, K23_SHA256,
  K24_SHA256, K25_SHA256, K26_SHA256, K27_SHA256,
  K28_SHA256, K29_SHA256, K30_SHA256, K31_SHA256,
  K32_SHA256, K33_SHA256, K34_SHA256, K35_SHA256,
  K36_SHA256, K37_SHA256, K38_SHA256, K39_SHA256,
  K40_SHA256, K41_SHA256, K42_SHA256, K43_SHA256,
  K44_SHA256, K45_SHA256, K46_SHA256, K47_SHA256,
  K48_SHA256, K49_SHA256, K50_SHA256, K51_SHA256,
  K52_SHA256, K53_SHA256, K54_SHA256, K55_SHA256,
  K56_SHA256, K57_SHA256, K58_SHA256, K59_SHA256,
  K60_SHA256, K61_SHA256, K62_SHA256, K63_SHA256,
};

//BIT64ARRAYI
static long long Sha512Const[80] = {
  K0_SHA512,  K1_SHA512,  K2_SHA512,  K3_SHA512,
  K4_SHA512,  K5_SHA512,  K6_SHA512,  K7_SHA512,
  K8_SHA512,  K9_SHA512,  K10_SHA512, K11_SHA512,
  K12_SHA512, K13_SHA512, K14_SHA512, K15_SHA512,
  K16_SHA512, K17_SHA512, K18_SHA512, K19_SHA512,
  K20_SHA512, K21_SHA512, K22_SHA512, K23_SHA512,
  K24_SHA512, K25_SHA512, K26_SHA512, K27_SHA512,
  K28_SHA512, K29_SHA512, K30_SHA512, K31_SHA512,
  K32_SHA512, K33_SHA512, K34_SHA512, K35_SHA512,
  K36_SHA512, K37_SHA512, K38_SHA512, K39_SHA512,
  K40_SHA512, K41_SHA512, K42_SHA512, K43_SHA512,
  K44_SHA512, K45_SHA512, K46_SHA512, K47_SHA512,
  K48_SHA512, K49_SHA512, K50_SHA512, K51_SHA512,
  K52_SHA512, K53_SHA512, K54_SHA512, K55_SHA512,
  K56_SHA512, K57_SHA512, K58_SHA512, K59_SHA512,
  K60_SHA512, K61_SHA512, K62_SHA512, K63_SHA512,
  K64_SHA512, K65_SHA512, K66_SHA512, K67_SHA512,
  K68_SHA512, K69_SHA512, K70_SHA512, K71_SHA512,
  K72_SHA512, K73_SHA512, K74_SHA512, K75_SHA512,
  K76_SHA512, K77_SHA512, K78_SHA512, K79_SHA512,
};

/** @addtogroup sha2
* @{
*/
/**
* Subroutine Sha256Block performs SHA-256 block operation
* on a filled SHA block, updates H0..H7 (Sha256Block).
* NOTE: Can be unfolded if needed (much code!)
*
* @param ShaArray SHA State structure
*/
static void Sha256Block(int* ShaArray)
{
  int a = ShaArray[16+0];		// H0
  int b = ShaArray[16+1];		// H1
  int c = ShaArray[16+2];		// H2
  int d = ShaArray[16+3];		// H3
  int e = ShaArray[16+4];		// H4
  int f = ShaArray[16+5];		// H5
  int g = ShaArray[16+6];		// H6
  int h = ShaArray[16+7];		// H7

  int i;
  int T1,T2,W1,W2;

  //----------------------------------------------------------
  // Generate the SHA-256 Hash for the given Block for 0<=t<64
  //----------------------------------------------------------
  for(i=0;i<16;i++)			// 0<= t <16
  {
    T1 = h + S1_256(e) + Ch_SHA(e,f,g) + Sha256Const[i] + ShaArray[i];
    T2 = S0_256(a) + Maj_SHA(a,b,c);
    h=g;g=f;f=e;e=d+T1;d=c;c=b;b=a;a=T1+T2;
//  printf("a=%08X,b=%08X,c=%08X,d=%08X\n",a,b,c,d);
//  printf("e=%08X,f=%08X,g=%08X,h=%08X\n\n",e,f,g,h);
  }

  for(i=0;i<16;i++)			// 16<= t <32
  {
    W1 = ShaArray[(i+14) & 0x0F];
    W2 = ShaArray[(i+1) & 0x0F];
    ShaArray[i] = s1_256(W1) + ShaArray[(i+9) & 0x0F] +
                  s0_256(W2) + ShaArray[i];
    T1 = h + S1_256(e) + Ch_SHA(e,f,g) + Sha256Const[i+16] + ShaArray[i];
    T2 = S0_256(a) + Maj_SHA(a,b,c);
    h=g;g=f;f=e;e=d+T1;d=c;c=b;b=a;a=T1+T2;
  }

  for(i=0;i<16;i++)			// 32<= t <48
  {
    W1 = ShaArray[(i+14) & 0x0F];
    W2 = ShaArray[(i+1) & 0x0F];
    ShaArray[i] = s1_256(W1) + ShaArray[(i+9) & 0x0F] +
                  s0_256(W2) + ShaArray[i];
    T1 = h + S1_256(e) + Ch_SHA(e,f,g) + Sha256Const[i+32] + ShaArray[i];
    T2 = S0_256(a) + Maj_SHA(a,b,c);
    h=g;g=f;f=e;e=d+T1;d=c;c=b;b=a;a=T1+T2;
  }

  for(i=0;i<16;i++)			// 48<= t <64
  {
    W1 = ShaArray[(i+14) & 0x0F];
    W2 = ShaArray[(i+1) & 0x0F];
    ShaArray[i] = s1_256(W1) + ShaArray[(i+9) & 0x0F] +
                  s0_256(W2) + ShaArray[i];
    T1 = h + S1_256(e) + Ch_SHA(e,f,g) + Sha256Const[i+48] + ShaArray[i];
    T2 = S0_256(a) + Maj_SHA(a,b,c);
    h=g;g=f;f=e;e=d+T1;d=c;c=b;b=a;a=T1+T2;
  }

  ShaArray[16+0] += a;		// H0
  ShaArray[16+1] += b;		// H1
  ShaArray[16+2] += c;		// H2
  ShaArray[16+3] += d;		// H3
  ShaArray[16+4] += e;		// H4
  ShaArray[16+5] += f;		// H5
  ShaArray[16+6] += g;		// H6
  ShaArray[16+7] += h;		// H7
}
/**
* Subroutine Sha512Block performs SHA-384/512 block operation
* on a filled SHA block, updates H0..H7 (Sha512Block).
* NOTE: Can be unfolded if needed (much code!)
*
* @param ShaArray SHA State structure
*/
static void Sha512Block(long long* ShaArray)
{
  long long a = ShaArray[16+0];		// H0
  long long b = ShaArray[16+1];		// H1
  long long c = ShaArray[16+2];		// H2
  long long d = ShaArray[16+3];		// H3
  long long e = ShaArray[16+4];		// H4
  long long f = ShaArray[16+5];		// H5
  long long g = ShaArray[16+6];		// H6
  long long h = ShaArray[16+7];		// H7

  int i;
  long long T1,T2,W1,W2;

  // Generate the SHA-384/512 Hash for the given Block
  for(i=0;i<16;i++)			// 0<= t <16
  {
    T1 = h + S1_512(e) + Ch_SHA(e,f,g) + Sha512Const[i] + ShaArray[i];
    T2 = S0_512(a) + Maj_SHA(a,b,c);
    h=g;g=f;f=e;e=d+T1;d=c;c=b;b=a;a=T1+T2;

  }

  for(i=0;i<16;i++)			// 16<= t <32
  {
    W1 = ShaArray[(i+14) & 0x0F];
    W2 = ShaArray[(i+1) & 0x0F];
    ShaArray[i] = s1_512(W1) + ShaArray[(i+9) & 0x0F] +
                  s0_512(W2) + ShaArray[i];
    T1 = h + S1_512(e) + Ch_SHA(e,f,g) + Sha512Const[i+16] + ShaArray[i];
    T2 = S0_512(a) + Maj_SHA(a,b,c);
    h=g;g=f;f=e;e=d+T1;d=c;c=b;b=a;a=T1+T2;
  }

  for(i=0;i<16;i++)			// 32<= t <48
  {
    W1 = ShaArray[(i+14) & 0x0F];
    W2 = ShaArray[(i+1) & 0x0F];
    ShaArray[i] = s1_512(W1) + ShaArray[(i+9) & 0x0F] +
                  s0_512(W2) + ShaArray[i];
    T1 = h + S1_512(e) + Ch_SHA(e,f,g) + Sha512Const[i+32] + ShaArray[i];
    T2 = S0_512(a) + Maj_SHA(a,b,c);
    h=g;g=f;f=e;e=d+T1;d=c;c=b;b=a;a=T1+T2;
  }

  for(i=0;i<16;i++)			// 48<= t <64
  {
    W1 = ShaArray[(i+14) & 0x0F];
    W2 = ShaArray[(i+1) & 0x0F];
    ShaArray[i] = s1_512(W1) + ShaArray[(i+9) & 0x0F] +
                  s0_512(W2) + ShaArray[i];
    T1 = h + S1_512(e) + Ch_SHA(e,f,g) + Sha512Const[i+48] + ShaArray[i];
    T2 = S0_512(a) + Maj_SHA(a,b,c);
    h=g;g=f;f=e;e=d+T1;d=c;c=b;b=a;a=T1+T2;
  }

  for(i=0;i<16;i++)			// 64<= t <79
  {
    W1 = ShaArray[(i+14) & 0x0F];
    W2 = ShaArray[(i+1) & 0x0F];
    ShaArray[i] = s1_512(W1) + ShaArray[(i+9) & 0x0F] +
                  s0_512(W2) + ShaArray[i];
    T1 = h + S1_512(e) + Ch_SHA(e,f,g) + Sha512Const[i+64] + ShaArray[i];
    T2 = S0_512(a) + Maj_SHA(a,b,c);
    h=g;g=f;f=e;e=d+T1;d=c;c=b;b=a;a=T1+T2;
  }

  ShaArray[16+0] += a;		// H0
  ShaArray[16+1] += b;		// H1
  ShaArray[16+2] += c;		// H2
  ShaArray[16+3] += d;		// H3
  ShaArray[16+4] += e;		// H4
  ShaArray[16+5] += f;		// H5
  ShaArray[16+6] += g;		// H6
  ShaArray[16+7] += h;		// H7
}

extern "C" void SHA224_Init(int* ShaArray)
{
  ShaArray[16+0] = H0_SHA224;
  ShaArray[16+1] = H1_SHA224;
  ShaArray[16+2] = H2_SHA224;
  ShaArray[16+3] = H3_SHA224;
  ShaArray[16+4] = H4_SHA224;
  ShaArray[16+5] = H5_SHA224;
  ShaArray[16+6] = H6_SHA224;
  ShaArray[16+7] = H7_SHA224;

  ShaArray[16+8+0] = 0;		// clear total length high word
  ShaArray[16+8+1] = 0;		// clear total length low word
  ShaArray[16+8+2] = 0;		// clear saved byte counter
}

extern "C" void SHA256_Init(int* ShaArray)
{
  ShaArray[16+0] = H0_SHA256;
  ShaArray[16+1] = H1_SHA256;
  ShaArray[16+2] = H2_SHA256;
  ShaArray[16+3] = H3_SHA256;
  ShaArray[16+4] = H4_SHA256;
  ShaArray[16+5] = H5_SHA256;
  ShaArray[16+6] = H6_SHA256;
  ShaArray[16+7] = H7_SHA256;

  ShaArray[16+8+0] = 0;		// clear total length high word
  ShaArray[16+8+1] = 0;		// clear total length low word
  ShaArray[16+8+2] = 0;		// clear saved byte counter
}

extern "C" void SHA384_Init(long long* ShaArray)
{
  ShaArray[16+0] = H0_SHA384;
  ShaArray[16+1] = H1_SHA384;
  ShaArray[16+2] = H2_SHA384;
  ShaArray[16+3] = H3_SHA384;
  ShaArray[16+4] = H4_SHA384;
  ShaArray[16+5] = H5_SHA384;
  ShaArray[16+6] = H6_SHA384;
  ShaArray[16+7] = H7_SHA384;

  ShaArray[16+8+0] = 0;		// clear total length high long word
  ShaArray[16+8+1] = 0;		// clear total length low long word
  ShaArray[16+8+2] = 0;		// clear saved byte counter
}

extern "C" void SHA512_Init(long long* ShaArray)
{
  ShaArray[16+0] = H0_SHA512;
  ShaArray[16+1] = H1_SHA512;
  ShaArray[16+2] = H2_SHA512;
  ShaArray[16+3] = H3_SHA512;
  ShaArray[16+4] = H4_SHA512;
  ShaArray[16+5] = H5_SHA512;
  ShaArray[16+6] = H6_SHA512;
  ShaArray[16+7] = H7_SHA512;

  ShaArray[16+8+0] = 0;		// clear total length high long word
  ShaArray[16+8+1] = 0;		// clear total length low long word
  ShaArray[16+8+2] = 0;		// clear saved byte count
}

extern "C" void SHA256_Update(int* SHA_Array, 
                              const char* data,
                              int Offset, 
                              size_t len)
{  
  int i,j,ew,ec,sw,sc;
  uint32_t l;

  if(len == 0)				// check zero length
    return;
  //----------------------------------------------------------------
  // calulate new total B I T - length
  //----------------------------------------------------------------
  l = (uint32_t) SHA_Array[25];		// Save for Carry check
  SHA_Array[25] =			// add new length bit count
    (uint32_t) SHA_Array[25] + (uint32_t) (len << 3);

  if(l > (uint32_t) SHA_Array[25])	// had a Carry out
    SHA_Array[24]++;

  i = Offset;				// Data-Array StartIndex
  if(SHA_Array[26] != 0)		// check for saved data in array
  {
    //=================================================================
    // stored data in array, fill up until SHA-Block complete (16 DWORDS)
    // or data exhausted
    //=================================================================
    sw = (int) (SHA_Array[26] >> 2);	 // number of full 4Byte DWORDS
    sc = (int) (SHA_Array[26] & 0x03);	 // remaining bytes

    // NOTE: overflow will occur above 4 GByte - 64 Byte !! (> (2**31-1) - 64)
 
    if((SHA_Array[26] + len) >= 64)
    {
      //---------------------------------------------------------------
      // enough data to complete array, do copy data to array,
      // generate Digest
      //---------------------------------------------------------------
      l = SHA_Array[sw];		// get address of next or incomplete
      BIGchar2longc(data,l,sc,i);	// get required bytes
      SHA_Array[sw] = l;		// save to array
      sw++;				// to next location
      for (; sw < 16; sw++)		// continue copying full longs
      {
        BIGchar2long(data,l,i);
        SHA_Array[sw] = l;
      }
      len -= (64 - SHA_Array[26]);	// reduce length

      Sha256Block(SHA_Array);		// get digest
      SHA_Array[26] = 0;		// no data in array
    }  
    else
    {
      //---------------------------------------------------------------
      // not enough data to complete array, do copy data to array only
      // and exit
      //---------------------------------------------------------------
      SHA_Array[26] += static_cast<int>(len);		// remaining bytes, always < 64
      if ((sc + (int) len) < 4)		// cannot fill a full DWORD
      {
        l = SHA_Array[sw];		// get saved bytes (if any)
        switch(sc)
        {
          case 0:					// no bytes saved
            l = ((int) data[i++] & 0x0FF) << 24;	// save byte
            len--;
            if(len == 0)
              break;
          case 1:					// 1 byte saved
            l |= (((int) data[i++] & 0x0FF) << 16);	// insert next
            len--;
            if(len == 0)
              break;
          case 2:					// 2 byte saved
            l |= (((int) data[i++] & 0x0FF) << 8);	// insert next
            len--;
            if(len == 0)
              break;
          case 3:					// 3 byte saved
            l |= ((int) data[i++] & 0x0FF);		// insert next
            break;
        }
        SHA_Array[sw] = l;		// save incomplete DWORD
      }
      else
      {
        ew = (int) SHA_Array[26];	// get ending byte count
        ec = ew & 0x03;			// incomplete ending byte count
        ew >>= 2;			// full DWORDS for copy

        l = SHA_Array[sw];		// get saved bytes (if any)
        BIGchar2longc(data,l,sc,i);	// insert bytes or copy full long
  	SHA_Array[sw] = l;		// save full long
        sw++;				// to next long

	for(; sw < ew; sw++)		// copy full longs
        {
          BIGchar2long(data,l,i);
          SHA_Array[sw] = l;
        }
        if(ec != 0)			// remaining bytes to copy into a long
        {
          BIGchar2long3n(data,l,ec,i);
          SHA_Array[sw] = l;
        }
      }
      return;				// exit, wait for more data
    }
  } // end of stored data preprocessing
  //=================================================================
  // no stored data in array, start storing data until filled up
  //=================================================================
  while (len >= 64)			// only for full blocks
  {
    j = 0;				// index to Stored data
    for(sw=4;sw != 0; sw--)		// full DWORD copy loop
    {
      BIGchar2longn(data,l,i);    SHA_Array[j]   = l;
      BIGchar2longn(data,l,(i+4));  SHA_Array[j+1] = l;
      BIGchar2longn(data,l,(i+8));  SHA_Array[j+2] = l;
      BIGchar2longn(data,l,(i+12)); SHA_Array[j+3] = l;
      i += 16;
      j += 4;

    }
    Sha256Block(SHA_Array);		// process Digest
    len -= 64;				// subtract blocklength
  }
  //
  // calculate remaining longs and rest bytes/long
  //
  ec = (int) len;			// is always < SHA_BLOCK !!

  SHA_Array[26] = (int) ec;		// save remaining data byte count
  ew = ec >> 2;				// calculate full long count
  ec &= 0x03;				// get last remaining bytes

  sw = 0;				// index data field start
  for (; sw < ew; sw++)			// copy full longs if any
  {
    BIGchar2long(data,l,i);
    SHA_Array[sw] = l;
  }

  if(ec != 0)				// copy remaining bytes if any
  {
    BIGchar2long3n(data,l,ec,i);
    SHA_Array[sw] = l;
  } 
}

extern "C" void SHA384_512_Update(long long* SHA_Array, 
                                  const char* data,
                                  int Offset, 
                                  size_t len)
{  
  int i,j,ew,ec,sw,sc;
  uint64_t l;

  if(len == 0)				// check zero length
    return;
  //----------------------------------------------------------------
  // calulate new total B I T - length
  // NOTE: only LOW count is calculated, limits size to 2**61 Bytes !!
  //----------------------------------------------------------------
//  l = (UBIT64) SHA_Array[25];		// Save for Carry check
  SHA_Array[25] =			// add new length bit count
    (uint64_t) SHA_Array[25] + (uint64_t) (len << 3);

//  if(l > (UBIT64) SHA_Array[25])	// had a Carry out
//    SHA_Array[24]++;

  i = Offset;				// Data-Array StartIndex
  if(SHA_Array[26] != 0)		// check for saved data in array
  {
    //=================================================================
    // stored data in array, fill up until SHA-Block complete (16 QWORDS)
    // or data exhausted
    //=================================================================
    sw = (int) (SHA_Array[26] >> 3);	 // number of full 8Byte QWORDS
    sc = (int) (SHA_Array[26] & 0x07);	 // remaining bytes

    if((SHA_Array[26] + len) >= 128)
    {
      //---------------------------------------------------------------
      // enough data to complete array, do copy data to array,
      // generate Digest
      //---------------------------------------------------------------
      l = SHA_Array[sw];		// get address of next or incomplete
      BIGchar2longlongc(data,l,sc,i);	// get required bytes
      SHA_Array[sw] = l;		// save to array
      sw++;				// to next location
      for (; sw < 16; sw++)		// continue copying full longlongs
      {
        BIGchar2longlong(data,l,i);
        SHA_Array[sw] = l;
      }
      len -= (128 - (int) SHA_Array[26]); // reduce length

      Sha512Block(SHA_Array);		// get digest
      SHA_Array[26] = 0;		// no data in array
    }  
    else
    {
      //---------------------------------------------------------------
      // not enough data to complete array, do copy data to array only
      // and exit
      //---------------------------------------------------------------
      SHA_Array[26] += len;		// remaining bytes, always < 64
      if ((sc + (int) len) < 8)		// cannot fill a full QWORD
      {
        l = SHA_Array[sw];		// get saved bytes (if any)
        switch(sc)
        {
          case 0:					// no bytes saved
            l = ((long long) data[i++] & 0x0FF) << 56;	// save byte
            len--;
            if(len == 0)
              break;
          case 1:					// 1 byte saved
            l |= (((long long) data[i++] & 0x0FF) << 48);	// insert next
            len--;
            if(len == 0)
              break;
          case 2:					// 2 byte saved
            l |= (((long long) data[i++] & 0x0FF) << 40);	// insert next
            len--;
            if(len == 0)
              break;
          case 3:					// 3 byte saved
            l |= (((long long) data[i++] & 0x0FF) << 32);	// insert next
            len--;
            if(len == 0)
              break;
          case 4:					// 4 byte saved
            l |= (((long long) data[i++] & 0x0FF) << 24);	// insert next
            len--;
            if(len == 0)
              break;
          case 5:					// 5 byte saved
            l |= (((long long) data[i++] & 0x0FF) << 16);	// insert next
            len--;
            if(len == 0)
              break;
          case 6:					// 6 byte saved
            l |= (((long long) data[i++] & 0x0FF) << 8);	// insert next
            len--;
            if(len == 0)
              break;
          case 7:					// 7 byte saved
            l |= ((long long) data[i++] & 0x0FF);		// insert next
            break;
        }
        SHA_Array[sw] = l;		// save incomplete DWORD
      }
      else
      {
        ew = (int) SHA_Array[26];	// get ending byte count
        ec = ew & 0x07;			// incomplete ending byte count
        ew >>= 3;			// full QWORDS for copy

        l = SHA_Array[sw];		// get saved bytes (if any)
        BIGchar2longlongc(data,l,sc,i);	// insert bytes or copy full longlong
  	SHA_Array[sw] = l;		// save full long
        sw++;				// to next long

	for(; sw < ew; sw++)		// copy full longs
        {
          BIGchar2longlong(data,l,i);
          SHA_Array[sw] = l;
        }
        if(ec != 0)			// remaining bytes to copy into longlong
        {
          BIGchar2longlong7n(data,l,ec,i);
          SHA_Array[sw] = l;
        }
      }
      return;				// exit, wait for more data
    }
  } // end of stored data preprocessing
  //=================================================================
  // no stored data in array, start storing data until filled up
  //=================================================================
  while (len >= 128)			// only for full blocks
  {
    j = 0;				// index to Stored data
    for(sw=4;sw != 0; sw--)		// full DWORD copy loop
    {
      BIGchar2longlongn(data,l,i);      SHA_Array[j]   = l;
      BIGchar2longlongn(data,l,(i+8));  SHA_Array[j+1] = l;
      BIGchar2longlongn(data,l,(i+16)); SHA_Array[j+2] = l;
      BIGchar2longlongn(data,l,(i+24)); SHA_Array[j+3] = l;
      i += 32;
      j += 4;

    }
    Sha512Block(SHA_Array);		// process Digest
    len -= 128;				// subtract blocklength
  }

  //
  // calculate remaining longs and rest bytes/long
  //
  ec = (int) len;			// is always < SHA_BLOCK !!

  SHA_Array[26] = (int) ec;		// save remaining data byte count
  ew = ec >> 3;				// calculate full longlong count
  ec &= 0x07;				// get last remaining bytes

  sw = 0;				// index data field start
  for (; sw < ew; sw++)			// copy full longs if any
  {
    BIGchar2longlong(data,l,i);
    SHA_Array[sw] = l;
  }

  if(ec != 0)				// copy remaining bytes if any
  {
    BIGchar2longlong7n(data,l,ec,i);
    SHA_Array[sw] = l;
  } 
}

//=======================================
// Padding bytes array for SHA256/384/512
//=======================================
  static unsigned char end8[8] = {(unsigned char)0x80,(unsigned char)0x00,(unsigned char)0x00,(unsigned char)0x00,
			 (unsigned char)0x00,(unsigned char)0x00,(unsigned char)0x00,(unsigned char)0x00};

extern "C" void SHA224_Final(int* SHA_Array,
				   char* Digest, int Offset)
{
  int i,j;
  uint32_t l;

  //---------------------------------------------------------------
  // Get stored long and remaining byte counts, append padding bits
  //---------------------------------------------------------------
  j = (int) SHA_Array[26];		// get stored byte count
  i = j >> 2;				// get remaining byte count

  l = SHA_Array[i];			// get last stored DWORD
  BIGchar2longcn(end8,l,(j & 0x03));	// insert 1..4 padding bytes
  SHA_Array[i] = l;			// save full long
  i++;					// to next long (not yet loaded)
  //---------------------------------------------------------------
  // check if this block has room for length data (8 bytes)
  // if not fill with zeroes and generate Digest
  //---------------------------------------------------------------
  if (SHA_Array[26] >= 56)		// not enough room
  {
    for (; i<16; i++) SHA_Array[i] = 0;	// zero data
    Sha256Block(SHA_Array);		// generate digest
    i = 0;				// set index back
  }
  //---------------------------------------------------------------
  // fill block with zeroes until position for length reached,
  // insert bitlength, generate final Digest
  //---------------------------------------------------------------
  for (; i<14; i++)	SHA_Array[i]=0;	// clear

  SHA_Array[14] = SHA_Array[24];	// set length high
  SHA_Array[15] = SHA_Array[25];	// dto. low
  Sha256Block(SHA_Array);		// generate final digest
  //---------------------------------------------------------------
  // copy final digest to user buffer, clear SHA Array (safety)
  //---------------------------------------------------------------
  l = SHA_Array[16]; BIGlong2charn(l,Digest,Offset+0);
  l = SHA_Array[17]; BIGlong2charn(l,Digest,Offset+4);
  l = SHA_Array[18]; BIGlong2charn(l,Digest,Offset+8);
  l = SHA_Array[19]; BIGlong2charn(l,Digest,Offset+12);
  l = SHA_Array[20]; BIGlong2charn(l,Digest,Offset+16);
  l = SHA_Array[21]; BIGlong2charn(l,Digest,Offset+20);
  l = SHA_Array[22]; BIGlong2charn(l,Digest,Offset+24);

  memset(SHA_Array,0,sizeof(int) * 27);
}

extern "C" void SHA256_Final(int* SHA_Array,
				   char* Digest, int Offset)
{
  int i,j;
  uint32_t l;

  //---------------------------------------------------------------
  // Get stored long and remaining byte counts, append padding bits
  //---------------------------------------------------------------
  j = (int) SHA_Array[26];		// get stored byte count
  i = j >> 2;				// get remaining byte count

  l = SHA_Array[i];			// get last stored DWORD
  BIGchar2longcn(end8,l,(j & 0x03));	// insert 1..4 padding bytes
  SHA_Array[i] = l;			// save full long
  i++;					// to next long (not yet loaded)
  //---------------------------------------------------------------
  // check if this block has room for length data (8 bytes)
  // if not fill with zeroes and generate Digest
  //---------------------------------------------------------------
  if (SHA_Array[26] >= 56)		// not enough room
  {
    for (; i<16; i++) SHA_Array[i] = 0;	// zero data
    Sha256Block(SHA_Array);		// generate digest
    i = 0;				// set index back
  }
  //---------------------------------------------------------------
  // fill block with zeroes until position for length reached,
  // insert bitlength, generate final Digest
  //---------------------------------------------------------------
  for (; i<14; i++)	SHA_Array[i]=0;	// clear

  SHA_Array[14] = SHA_Array[24];	// set length high
  SHA_Array[15] = SHA_Array[25];	// dto. low
  Sha256Block(SHA_Array);		// generate final digest
  //---------------------------------------------------------------
  // copy final digest to user buffer, clear SHA Array (safety)
  //---------------------------------------------------------------
  l = SHA_Array[16]; BIGlong2charn(l,Digest,Offset+0);
  l = SHA_Array[17]; BIGlong2charn(l,Digest,Offset+4);
  l = SHA_Array[18]; BIGlong2charn(l,Digest,Offset+8);
  l = SHA_Array[19]; BIGlong2charn(l,Digest,Offset+12);
  l = SHA_Array[20]; BIGlong2charn(l,Digest,Offset+16);
  l = SHA_Array[21]; BIGlong2charn(l,Digest,Offset+20);
  l = SHA_Array[22]; BIGlong2charn(l,Digest,Offset+24);
  l = SHA_Array[23]; BIGlong2charn(l,Digest,Offset+28);

  memset(SHA_Array,0,sizeof(int) * 27);
}

extern "C" void SHA384_Final(long long* SHA_Array,
				   char* Digest, int Offset)
{
  int i,j;
  long long l;

  //---------------------------------------------------------------
  // Get stored long and remaining byte counts, append padding bits
  //---------------------------------------------------------------
  j = (int) SHA_Array[26];		// get stored byte count
  i = j >> 3;				// get remaining byte count

  l = SHA_Array[i];			// get last stored QWORD
  BIGchar2longlongcn(end8,l,(j & 0x07));// insert 1..7 padding bytes
  SHA_Array[i] = l;			// save full longlong
  i++;					// to next longlong (not yet loaded)
  //---------------------------------------------------------------
  // check if this block has room for length data (16 bytes)
  // if not fill with zeroes and generate Digest
  //---------------------------------------------------------------
  if (SHA_Array[26] >= 112)		// not enough room
  {
    for (; i<16; i++) SHA_Array[i] = 0;	// zero data
    Sha512Block(SHA_Array);		// generate digest
    i = 0;				// set index back
  }
  //---------------------------------------------------------------
  // fill block with zeroes until position for length reached,
  // insert bitlength, generate final Digest
  //---------------------------------------------------------------
  for (; i<14; i++)	SHA_Array[i]=0;	// clear

  SHA_Array[14] = SHA_Array[24];	// set length high
  SHA_Array[15] = SHA_Array[25];	// dto. low

  Sha512Block(SHA_Array);		// generate final digest
  //---------------------------------------------------------------
  // copy final digest to user buffer, clear SHA Array (safety)
  //---------------------------------------------------------------
  l = SHA_Array[16]; BIGlonglong2charn(l,Digest,Offset+0);
  l = SHA_Array[17]; BIGlonglong2charn(l,Digest,Offset+8);
  l = SHA_Array[18]; BIGlonglong2charn(l,Digest,Offset+16);
  l = SHA_Array[19]; BIGlonglong2charn(l,Digest,Offset+24);
  l = SHA_Array[20]; BIGlonglong2charn(l,Digest,Offset+32);
  l = SHA_Array[21]; BIGlonglong2charn(l,Digest,Offset+40);
//  l = SHA_Array[22]; BIGlonglong2charn(l,Digest,Offset+48);
//  l = SHA_Array[23]; BIGlonglong2charn(l,Digest,Offset+56);

  memset(SHA_Array,0,sizeof(long long) * 27);
}

extern "C" void SHA512_Final(long long* SHA_Array,
				   char* Digest, int Offset)
{
  int i,j;
  long long l;

  //---------------------------------------------------------------
  // Get stored long and remaining byte counts, append padding bits
  //---------------------------------------------------------------
  j = (int) SHA_Array[26];		// get stored byte count
  i = j >> 3;				// get remaining byte count

  l = SHA_Array[i];			// get last stored QWORD
  BIGchar2longlongcn(end8,l,(j & 0x07));// insert 1..7 padding bytes
  SHA_Array[i] = l;			// save full longlong
  i++;					// to next longlong (not yet loaded)
  //---------------------------------------------------------------
  // check if this block has room for length data (16 bytes)
  // if not fill with zeroes and generate Digest
  //---------------------------------------------------------------
  if (SHA_Array[26] >= 112)		// not enough room
  {
    for (; i<16; i++) SHA_Array[i] = 0;	// zero data
    Sha512Block(SHA_Array);		// generate digest
    i = 0;				// set index back
  }
  //---------------------------------------------------------------
  // fill block with zeroes until position for length reached,
  // insert bitlength, generate final Digest
  //---------------------------------------------------------------
  for (; i<14; i++)	SHA_Array[i]=0;	// clear

  SHA_Array[14] = SHA_Array[24];	// set length high
  SHA_Array[15] = SHA_Array[25];	// dto. low
  Sha512Block(SHA_Array);		// generate final digest
  //---------------------------------------------------------------
  // copy final digest to user buffer, clear SHA Array (safety)
  //---------------------------------------------------------------
  l = SHA_Array[16]; BIGlonglong2charn(l,Digest,Offset+0);
  l = SHA_Array[17]; BIGlonglong2charn(l,Digest,Offset+8);
  l = SHA_Array[18]; BIGlonglong2charn(l,Digest,Offset+16);
  l = SHA_Array[19]; BIGlonglong2charn(l,Digest,Offset+24);
  l = SHA_Array[20]; BIGlonglong2charn(l,Digest,Offset+32);
  l = SHA_Array[21]; BIGlonglong2charn(l,Digest,Offset+40);
  l = SHA_Array[22]; BIGlonglong2charn(l,Digest,Offset+48);
  l = SHA_Array[23]; BIGlonglong2charn(l,Digest,Offset+56);

  memset(SHA_Array,0,sizeof(long long) * 27);
}
/** @} */


#endif //HL_ENCR_SHA
// end of file ../SHA1/s2.cpp


#ifdef HL_ENCR_SHA
/** @defgroup sha3 SHA3
* @brief SHA-3 cryptographic hash family implementation
*
* This module implements the SHA-3 message digest family, described in
* FIPS PUB 202.
*
* The call to the final function will clear the state array in any case.
*
* No other modules are used.
* @{
* @file
* This file implements the SHA32 hash family.
* @date 31.03.2016
* @}
*/

#include <string.h>
#if (defined _WIN32) & (_MSC_VER < 1700)
#ifndef _STDINT
#define _STDINT
// MSVC lower than 17.00 does not have stdint.h, assure, all needed types are defined

typedef unsigned __int16 uint16_t;

typedef unsigned __int32 uint32_t;

typedef unsigned __int64 uint64_t;


#endif // !_STDINT
#else
#include <stdint.h>
#endif
#include <stddef.h>
#ifdef _WIN32
#define WIN32_LEAN_AND_MEAN
#include <Windows.h>
#undef WIN32_LEAN_AND_MEAN
#else// Define system-specific HL_* defines here
#ifndef HL_UNIX
#define HL_UNIX

#if (defined __gnu_linux__) || (defined __linux__)
#define HL_LINUX
#endif

#if (defined __APPLE__) && (defined __MACH__)
#define HL_LINUX
#define HL_MACOS
#endif

#ifdef _AIX
#define HL_AIX
#define HL_BIG_ENDIAN
#endif

#ifdef __FreeBSD__
#define HL_FREEBSD
#endif

#if (defined _hpux) || (defined hpux) || (defined __hpux)
#define HL_HPUX
#define HL_BIG_ENDIAN
#endif

#if (defined sun) || (defined __sun)
#define HL_SOLARIS
#endif

#if (defined __arm__) || (defined __aarch64__)
#define HL_LINUX_ARM
#endif

#ifdef __ANDROID__
#define HL_ANDROID
#endif

#endif
#include <hob-unix01.h>
#endif
#ifdef __APPLE__
/* We get target conditionals to keep apart Mac OS, iOS and iOS simulator.
   The conditionals are TARGET_IPHONE_SIMULATOR, TARGET_OS_IPHONE and TARGET_OS_MAC.
   TARGET_IPHONE_SIMULATOR has the highest priority, TARGET_OS_MAC the lowest.
   Always test if the conditional is 1, as they will be defined as 0 if we 
   are not compiling for the target.
   */
#include <TargetConditionals.h>
#endif

#include "hob-encry-1.h"
#include <stdlib.h>
#include "hob-encry-intern-1.h"

/** List of Keccack round constants. */
static const uint64_t auls_sha3_round_constants[24] = {
    0x0000000000000001ULL, 0x0000000000008082ULL, 0x800000000000808AULL, 0x8000000080008000ULL,
    0x000000000000808BULL, 0x0000000080000001ULL, 0x8000000080008081ULL, 0x8000000000008009ULL,
    0x000000000000008AULL, 0x0000000000000088ULL, 0x0000000080008009ULL, 0x000000008000000AULL,
    0x000000008000808BULL, 0x800000000000008BULL, 0x8000000000008089ULL, 0x8000000000008003ULL,
    0x8000000000008002ULL, 0x8000000000000080ULL, 0x000000000000800AULL, 0x800000008000000AULL,
    0x8000000080008081ULL, 0x8000000000008080ULL, 0x0000000080000001ULL, 0x8000000080008008ULL
};

static inline uint64_t m_rotl64(uint64_t ulp_input, 
                                   int inp_rot_cnt)
{
#ifdef _MSC_VER
    return _rotl64(ulp_input, inp_rot_cnt);
#elif (defined __GNUC__) && (defined __aarch64__)
    uint64_t ull_result;
    inp_rot_cnt = 64-(inp_rot_cnt&0x3F);
    __asm__("ror %0, %1, %2\n" : "=r"(ull_result) : "r" (ulp_input), "r"((long) inp_rot_cnt));
    //no reliably available GCC intrinsic
    return ull_result;
#else
    //Multiple mentions of the 64 literal provoke a compiler error in Xcode 7.3.1 at -Os level for iPhone 6 target. Replacing %64 with &0x3F helped (see above).
    return ((ulp_input << inp_rot_cnt%64)|(ulp_input >> (64-(inp_rot_cnt%64))));
#endif
}


static inline uint64_t m_endianswap(uint64_t ulp_x)
{
#if defined(__GNUC__)  && (__GNUC_VERSION__ >= 40300) && !defined(HL_LINUX_ARM)
    return __builtin_bswap64(ulp_x); //unknown before 4.3.0
#elif defined(__GNUC__) && (__GNUC_VERSION__ >= 40500)
    return __builtin_bswap64(ulp_x); // low-quality builtin for ARM before 4.5.0
#elif defined(__clang__) 
    return __builtin_bswap64(ulp_x);
#elif defined _MSC_VER
    return _byteswap_uint64(ulp_x);
#else
    ulp_x = ((ulp_x <<  8) & 0xFF00FF00FF00FF00ULL ) | ((ulp_x >>  8) & 0x00FF00FF00FF00FFULL );
    ulp_x = ((ulp_x << 16) & 0xFFFF0000FFFF0000ULL ) | ((ulp_x >> 16) & 0x0000FFFF0000FFFFULL );
    return (ulp_x << 32) | (ulp_x >> 32);
#endif
} 


static void m_sha3_single_round(unsigned int unp_round_nr, 
                    uint64_t * aulp_src_state, 
                    uint64_t * aulp_dest_state, 
                    uint64_t * aulp_parity)
{
    uint64_t aull_theta;
    uint64_t aull_temp_array_b[5];
    //Theta
    aull_theta=aulp_parity[4]^m_rotl64(aulp_parity[1],1);
    aulp_src_state[0] ^= aull_theta;
    aulp_src_state[5] ^= aull_theta;
    aulp_src_state[10] ^= aull_theta;
    aulp_src_state[15] ^= aull_theta;
    aulp_src_state[20] ^= aull_theta;

    aull_theta=aulp_parity[0]^m_rotl64(aulp_parity[2],1);
    aulp_src_state[1] ^= aull_theta;
    aulp_src_state[6] ^= aull_theta;
    aulp_src_state[11] ^= aull_theta;
    aulp_src_state[16] ^= aull_theta;
    aulp_src_state[21] ^= aull_theta;

    aull_theta=aulp_parity[1]^m_rotl64(aulp_parity[3],1);
    aulp_src_state[2] ^= aull_theta;
    aulp_src_state[7] ^= aull_theta;
    aulp_src_state[12] ^= aull_theta;
    aulp_src_state[17] ^= aull_theta;
    aulp_src_state[22] ^= aull_theta;

    aull_theta=aulp_parity[2]^m_rotl64(aulp_parity[4],1);
    aulp_src_state[3] ^= aull_theta;
    aulp_src_state[8] ^= aull_theta;
    aulp_src_state[13] ^= aull_theta;
    aulp_src_state[18] ^= aull_theta;
    aulp_src_state[23] ^= aull_theta;

    aull_theta=aulp_parity[3]^m_rotl64(aulp_parity[0],1);
    aulp_src_state[4] ^= aull_theta;
    aulp_src_state[9] ^= aull_theta;
    aulp_src_state[14] ^= aull_theta;
    aulp_src_state[19] ^= aull_theta;
    aulp_src_state[24] ^= aull_theta;

    memset(aulp_parity, 0, 5*sizeof(uint64_t));

    // plane 0
    // Rho and Pi
    aull_temp_array_b[0] = aulp_src_state[0];
    aull_temp_array_b[1] = m_rotl64(aulp_src_state[6],44);
    aull_temp_array_b[2] = m_rotl64(aulp_src_state[12],43);
    aull_temp_array_b[3] = m_rotl64(aulp_src_state[18],21);
    aull_temp_array_b[4] = m_rotl64(aulp_src_state[24],14);

    // Chi, and precalc parity for next round
    aulp_dest_state[0] = aull_temp_array_b[0]^
        ((~aull_temp_array_b[1])&aull_temp_array_b[2]);
    // Iota: add round const to word [0][0]
    aulp_dest_state[0] ^= auls_sha3_round_constants[unp_round_nr];
    aulp_parity[0] ^= aulp_dest_state[0];
    aulp_dest_state[1] = aull_temp_array_b[1]^
        ((~aull_temp_array_b[2])&aull_temp_array_b[3]);
    aulp_parity[1] ^= aulp_dest_state[1];
    aulp_dest_state[2] = aull_temp_array_b[2]^
        ((~aull_temp_array_b[3])&aull_temp_array_b[4]);
    aulp_parity[2] ^= aulp_dest_state[2];
    aulp_dest_state[3] = aull_temp_array_b[3]^
        ((~aull_temp_array_b[4])&aull_temp_array_b[0]);
    aulp_parity[3] ^= aulp_dest_state[3];
    aulp_dest_state[4] = aull_temp_array_b[4]^
        ((~aull_temp_array_b[0])&aull_temp_array_b[1]);
    aulp_parity[4] ^= aulp_dest_state[4];

    // plane 1
    // Rho and Pi
    aull_temp_array_b[0] = m_rotl64(aulp_src_state[3],28);
    aull_temp_array_b[1] = m_rotl64(aulp_src_state[9],20);
    aull_temp_array_b[2] = m_rotl64(aulp_src_state[10],3);
    aull_temp_array_b[3] = m_rotl64(aulp_src_state[16],45);
    aull_temp_array_b[4] = m_rotl64(aulp_src_state[22],61);

    // Chi, and precalc parity for next round
    aulp_dest_state[5] = aull_temp_array_b[0]^
        ((~aull_temp_array_b[1])&aull_temp_array_b[2]);
    aulp_parity[0] ^= aulp_dest_state[5];
    aulp_dest_state[6] = aull_temp_array_b[1]^
        ((~aull_temp_array_b[2])&aull_temp_array_b[3]);
    aulp_parity[1] ^= aulp_dest_state[6];
    aulp_dest_state[7] = aull_temp_array_b[2]^
        ((~aull_temp_array_b[3])&aull_temp_array_b[4]);
    aulp_parity[2] ^= aulp_dest_state[7];
    aulp_dest_state[8] = aull_temp_array_b[3]^
        ((~aull_temp_array_b[4])&aull_temp_array_b[0]);
    aulp_parity[3] ^= aulp_dest_state[8];
    aulp_dest_state[9] = aull_temp_array_b[4]^
        ((~aull_temp_array_b[0])&aull_temp_array_b[1]);
    aulp_parity[4] ^= aulp_dest_state[9];

    // plane 2
    // Rho and Pi
    aull_temp_array_b[0] = m_rotl64(aulp_src_state[1],1);
    aull_temp_array_b[1] = m_rotl64(aulp_src_state[7],6);
    aull_temp_array_b[2] = m_rotl64(aulp_src_state[13],25);
    aull_temp_array_b[3] = m_rotl64(aulp_src_state[19],8);
    aull_temp_array_b[4] = m_rotl64(aulp_src_state[20],18);

    // Chi, and precalc parity for next round
    aulp_dest_state[10] = aull_temp_array_b[0]^
        ((~aull_temp_array_b[1])&aull_temp_array_b[2]);
    aulp_parity[0] ^= aulp_dest_state[10];
    aulp_dest_state[11] = aull_temp_array_b[1]^
        ((~aull_temp_array_b[2])&aull_temp_array_b[3]);
    aulp_parity[1] ^= aulp_dest_state[11];
    aulp_dest_state[12] = aull_temp_array_b[2]^
        ((~aull_temp_array_b[3])&aull_temp_array_b[4]);
    aulp_parity[2] ^= aulp_dest_state[12];
    aulp_dest_state[13] = aull_temp_array_b[3]^
        ((~aull_temp_array_b[4])&aull_temp_array_b[0]);
    aulp_parity[3] ^= aulp_dest_state[13];
    aulp_dest_state[14] = aull_temp_array_b[4]^
        ((~aull_temp_array_b[0])&aull_temp_array_b[1]);
    aulp_parity[4] ^= aulp_dest_state[14];

    // plane 3
    // Rho and Pi
    aull_temp_array_b[0] = m_rotl64(aulp_src_state[4],27);
    aull_temp_array_b[1] = m_rotl64(aulp_src_state[5],36);
    aull_temp_array_b[2] = m_rotl64(aulp_src_state[11],10);
    aull_temp_array_b[3] = m_rotl64(aulp_src_state[17],15);
    aull_temp_array_b[4] = m_rotl64(aulp_src_state[23],56);

    // Chi, and precalc parity for next round
    aulp_dest_state[15] = aull_temp_array_b[0]^
        ((~aull_temp_array_b[1])&aull_temp_array_b[2]);
    aulp_parity[0] ^= aulp_dest_state[15];
    aulp_dest_state[16] = aull_temp_array_b[1]^
        ((~aull_temp_array_b[2])&aull_temp_array_b[3]);
    aulp_parity[1] ^= aulp_dest_state[16];
    aulp_dest_state[17] = aull_temp_array_b[2]^
        ((~aull_temp_array_b[3])&aull_temp_array_b[4]);
    aulp_parity[2] ^= aulp_dest_state[17];
    aulp_dest_state[18] = aull_temp_array_b[3]^
        ((~aull_temp_array_b[4])&aull_temp_array_b[0]);
    aulp_parity[3] ^= aulp_dest_state[18];
    aulp_dest_state[19] = aull_temp_array_b[4]^
        ((~aull_temp_array_b[0])&aull_temp_array_b[1]);
    aulp_parity[4] ^= aulp_dest_state[19];

    // plane 4
    // Rho and Pi
    aull_temp_array_b[0] = m_rotl64(aulp_src_state[2],62);
    aull_temp_array_b[1] = m_rotl64(aulp_src_state[8],55);
    aull_temp_array_b[2] = m_rotl64(aulp_src_state[14],39);
    aull_temp_array_b[3] = m_rotl64(aulp_src_state[15],41);
    aull_temp_array_b[4] = m_rotl64(aulp_src_state[21],2);

    // Chi, and precalc parity for next round
    aulp_dest_state[20] = aull_temp_array_b[0]^
        ((~aull_temp_array_b[1])&aull_temp_array_b[2]);
    aulp_parity[0] ^= aulp_dest_state[20];
    aulp_dest_state[21] = aull_temp_array_b[1]^
        ((~aull_temp_array_b[2])&aull_temp_array_b[3]);
    aulp_parity[1] ^= aulp_dest_state[21];
    aulp_dest_state[22] = aull_temp_array_b[2]^
        ((~aull_temp_array_b[3])&aull_temp_array_b[4]);
    aulp_parity[2] ^= aulp_dest_state[22];
    aulp_dest_state[23] = aull_temp_array_b[3]^
        ((~aull_temp_array_b[4])&aull_temp_array_b[0]);
    aulp_parity[3] ^= aulp_dest_state[23];
    aulp_dest_state[24] = aull_temp_array_b[4]^
        ((~aull_temp_array_b[0])&aull_temp_array_b[1]);
    aulp_parity[4] ^= aulp_dest_state[24];

} // end of void m_sha3_single_round(unsigned int, uint64_t *, uint64_t *, uint64_t *)


static void m_sha3_permute_state(struct dsd_sha3_state_array* adsp_sha_state){
    uint64_t aull_parities[5];      // Array for state parrities
#ifndef HL_BIG_ENDIAN
    uint64_t* aull_temp_state_1 = adsp_sha_state->aulc_array;
    uint64_t aull_temp_state_2[25];  // Temporary state array
#else
    uint64_t aull_temp_state_1[25];  // Temporary state array
    uint64_t aull_temp_state_2[25];  // Temporary state array
    // Fill temp state array
    for(unsigned int unl1 = 0; unl1 <25; unl1++){
        aull_temp_state_1[unl1] = m_endianswap(adsp_sha_state->aulc_array[unl1]);
    }
#endif
    // precalculate state parities
    aull_parities[0] = aull_temp_state_1[0]^aull_temp_state_1[5]^
        aull_temp_state_1[10]^aull_temp_state_1[15]^aull_temp_state_1[20];
    aull_parities[1] = aull_temp_state_1[1]^aull_temp_state_1[6]^
        aull_temp_state_1[11]^aull_temp_state_1[16]^aull_temp_state_1[21];
    aull_parities[2] = aull_temp_state_1[2]^aull_temp_state_1[7]^
        aull_temp_state_1[12]^aull_temp_state_1[17]^aull_temp_state_1[22];
    aull_parities[3] = aull_temp_state_1[3]^aull_temp_state_1[8]^
        aull_temp_state_1[13]^aull_temp_state_1[18]^aull_temp_state_1[23];
    aull_parities[4] = aull_temp_state_1[4]^aull_temp_state_1[9]^
        aull_temp_state_1[14]^aull_temp_state_1[19]^aull_temp_state_1[24];

    // Do 12*2 permutation rounds
    for(unsigned int unl_round_count = 0; unl_round_count < 24; unl_round_count+=2){
        m_sha3_single_round(unl_round_count, aull_temp_state_1, 
        aull_temp_state_2, aull_parities);
        m_sha3_single_round(unl_round_count+1, aull_temp_state_2, 
        aull_temp_state_1, aull_parities);
    }
    // write back state array
#ifdef HL_BIG_ENDIAN
    for(unsigned int unl1 = 0; unl1 <25; unl1++){
        adsp_sha_state->aulc_array[unl1] = m_endianswap(aull_temp_state_1[unl1]);
    }
#endif
}//end of void m_sha3_permute_state(struct dsd_sha3_state_array*)

static void m_sha3_init(struct dsd_sha3_state_array* adsp_sha_state, int inp_hashsize)
{
    memset(adsp_sha_state->achc_array,0,200);
    adsp_sha_state->imc_current_pos = 0;
    adsp_sha_state->imc_hash_size = inp_hashsize/8;
    adsp_sha_state->imc_rate_size = 200 - (adsp_sha_state->imc_hash_size*2);
    //rate size in bytes
    //SHA3-224(28): 144
    //SHA3-256(32): 136
    //SHA3-384(48): 104
    //SHA3-512(64): 72
    return;
} // end of void m_sha3_init(struct dsd_sha3_state_array*, int)

extern "C" void m_sha3_224_init(struct dsd_sha3_state_array* state){
    m_sha3_init(state, 224);
}
extern "C" void m_sha3_256_init(struct dsd_sha3_state_array* state){
    m_sha3_init(state, 256);
}
extern "C" void m_sha3_384_init(struct dsd_sha3_state_array* state){
    m_sha3_init(state, 384);
}
extern "C" void m_sha3_512_init(struct dsd_sha3_state_array* state){
    m_sha3_init(state, 512);
}

extern "C" void m_sha3_update(struct dsd_sha3_state_array* adsp_sha_state,
                              const char* achp_data,
                              int imp_offset, 
                              size_t szp_len)
{
    const char* achl_data_cur = achp_data + imp_offset;
    const char* achl_data_end = achp_data + imp_offset + szp_len;
    char* achl_state_cur = &adsp_sha_state->achc_array[adsp_sha_state->imc_current_pos];
    while(achl_data_cur < achl_data_end){
        // copy input bytewise onto rate, until either end of rate or end of input is reached
        while ((adsp_sha_state->imc_current_pos < adsp_sha_state->imc_rate_size) && (achl_data_cur < achl_data_end)){
            *achl_state_cur++ ^= *achl_data_cur++;
            adsp_sha_state->imc_current_pos++;
        }
        // if end of rate has been reached, perform state permutations and reset cur pointer to start
        if(adsp_sha_state->imc_current_pos == adsp_sha_state->imc_rate_size){
            m_sha3_permute_state(adsp_sha_state);
            adsp_sha_state->imc_current_pos = 0;
            achl_state_cur = adsp_sha_state->achc_array;
        }
    }
    return;

} // end of void m_sha3_update(struct dsd_sha3_state_array*, const char*, int, size_t)

extern "C" void m_sha3_final(struct dsd_sha3_state_array* adsp_sha_state,
                              char* achp_digest,
                              int imp_offset)
{
    //apply padding
    adsp_sha_state->achc_array[adsp_sha_state->imc_current_pos] ^= 0x06;
    adsp_sha_state->achc_array[adsp_sha_state->imc_rate_size-1] ^= 0x80;
    //perform last state permutation step
    m_sha3_permute_state(adsp_sha_state);
    //squeeze digest
    memcpy(achp_digest+imp_offset,adsp_sha_state->achc_array,adsp_sha_state->imc_hash_size);
    return;

} // end of void m_sha3_final(struct dsd_sha3_state_array*, char*, int)



#endif //HL_ENCR_SHA
// end of file ../SHA1/s3.cpp


#ifdef HL_ENCR_DES
/**   @defgroup des DES
*  This module implements the basic DES cipher algorithm and
*  some derived cipher modes e.g. DES-CBC, 3DES-EDE_CBC.
* 
*  See US Standards FIPS PUB 46 (-1, -2) [DES] and FIPS PUB 81
*  [Modes of Operation] for further description.
* 
*  See also DESSWAP.TXT, KEYSHIFT.TXT, SROUND.TXT and DESSBOX.TXT
*  for specific implementation.
*
*  This is the current C implementation.
*
*  This module has no dependencies on other modules.
*/
#if (defined _WIN32) & (_MSC_VER < 1700)
#ifndef _STDINT
#define _STDINT
// MSVC lower than 17.00 does not have stdint.h, assure, all needed types are defined

typedef unsigned __int16 uint16_t;

typedef unsigned __int32 uint32_t;

typedef unsigned __int64 uint64_t;

#endif // !_STDINT
#else
#include <stdint.h>
#endif
#include <stddef.h>
#ifdef _WIN32
#define WIN32_LEAN_AND_MEAN
#include <Windows.h>
#undef WIN32_LEAN_AND_MEAN
#else// Define system-specific HL_* defines here
#ifndef HL_UNIX
#define HL_UNIX

#if (defined __gnu_linux__) || (defined __linux__)
#define HL_LINUX
#endif

#if (defined __APPLE__) && (defined __MACH__)
#define HL_LINUX
#define HL_MACOS
#endif

#ifdef _AIX
#define HL_AIX
#define HL_BIG_ENDIAN
#endif

#ifdef __FreeBSD__
#define HL_FREEBSD
#endif

#if (defined _hpux) || (defined hpux) || (defined __hpux)
#define HL_HPUX
#define HL_BIG_ENDIAN
#endif

#if (defined sun) || (defined __sun)
#define HL_SOLARIS
#endif

#if (defined __arm__) || (defined __aarch64__)
#define HL_LINUX_ARM
#endif

#ifdef __ANDROID__
#define HL_ANDROID
#endif

#endif
#include <hob-unix01.h>
#endif
#ifdef __APPLE__
/* We get target conditionals to keep apart Mac OS, iOS and iOS simulator.
   The conditionals are TARGET_IPHONE_SIMULATOR, TARGET_OS_IPHONE and TARGET_OS_MAC.
   TARGET_IPHONE_SIMULATOR has the highest priority, TARGET_OS_MAC the lowest.
   Always test, if the conditional is 1, as they will be defined as 0, if we 
   are not compiling for the target.
   */
#include <TargetConditionals.h>
#endif

#include <string.h>
#include <stdlib.h>
#include "hob-encry-1.h"
#include "hob-encry-intern-1.h"
/** @addtogroup des
*  @{
*  @file
* This file contains the current C implementation for the DES module.
*  @}
*/

//----------------------------------------------------
// constant values
//----------------------------------------------------
static const unsigned int DES_KPBox[8][64]=
{
// CP-Box 1 :
{
0x00000000,0x00000010,0x20000000,0x20000010,
0x00010000,0x00010010,0x20010000,0x20010010,
0x00000800,0x00000810,0x20000800,0x20000810,
0x00010800,0x00010810,0x20010800,0x20010810,
0x00000020,0x00000030,0x20000020,0x20000030,
0x00010020,0x00010030,0x20010020,0x20010030,
0x00000820,0x00000830,0x20000820,0x20000830,
0x00010820,0x00010830,0x20010820,0x20010830,
0x00080000,0x00080010,0x20080000,0x20080010,
0x00090000,0x00090010,0x20090000,0x20090010,
0x00080800,0x00080810,0x20080800,0x20080810,
0x00090800,0x00090810,0x20090800,0x20090810,
0x00080020,0x00080030,0x20080020,0x20080030,
0x00090020,0x00090030,0x20090020,0x20090030,
0x00080820,0x00080830,0x20080820,0x20080830,
0x00090820,0x00090830,0x20090820,0x20090830,
},

// CP-Box 2 :
{
0x00000000,0x02000000,0x00002000,0x02002000,
0x00200000,0x02200000,0x00202000,0x02202000,
0x00000004,0x02000004,0x00002004,0x02002004,
0x00200004,0x02200004,0x00202004,0x02202004,
0x00000400,0x02000400,0x00002400,0x02002400,
0x00200400,0x02200400,0x00202400,0x02202400,
0x00000404,0x02000404,0x00002404,0x02002404,
0x00200404,0x02200404,0x00202404,0x02202404,
0x10000000,0x12000000,0x10002000,0x12002000,
0x10200000,0x12200000,0x10202000,0x12202000,
0x10000004,0x12000004,0x10002004,0x12002004,
0x10200004,0x12200004,0x10202004,0x12202004,
0x10000400,0x12000400,0x10002400,0x12002400,
0x10200400,0x12200400,0x10202400,0x12202400,
0x10000404,0x12000404,0x10002404,0x12002404,
0x10200404,0x12200404,0x10202404,0x12202404,
},

// CP-Box 3 :
{
0x00000000,0x00000001,0x00040000,0x00040001,
0x01000000,0x01000001,0x01040000,0x01040001,
0x00000002,0x00000003,0x00040002,0x00040003,
0x01000002,0x01000003,0x01040002,0x01040003,
0x00000200,0x00000201,0x00040200,0x00040201,
0x01000200,0x01000201,0x01040200,0x01040201,
0x00000202,0x00000203,0x00040202,0x00040203,
0x01000202,0x01000203,0x01040202,0x01040203,
0x08000000,0x08000001,0x08040000,0x08040001,
0x09000000,0x09000001,0x09040000,0x09040001,
0x08000002,0x08000003,0x08040002,0x08040003,
0x09000002,0x09000003,0x09040002,0x09040003,
0x08000200,0x08000201,0x08040200,0x08040201,
0x09000200,0x09000201,0x09040200,0x09040201,
0x08000202,0x08000203,0x08040202,0x08040203,
0x09000202,0x09000203,0x09040202,0x09040203,
},

// CP-Box 4 :
{
0x00000000,0x00100000,0x00000100,0x00100100,
0x00000008,0x00100008,0x00000108,0x00100108,
0x00001000,0x00101000,0x00001100,0x00101100,
0x00001008,0x00101008,0x00001108,0x00101108,
0x04000000,0x04100000,0x04000100,0x04100100,
0x04000008,0x04100008,0x04000108,0x04100108,
0x04001000,0x04101000,0x04001100,0x04101100,
0x04001008,0x04101008,0x04001108,0x04101108,
0x00020000,0x00120000,0x00020100,0x00120100,
0x00020008,0x00120008,0x00020108,0x00120108,
0x00021000,0x00121000,0x00021100,0x00121100,
0x00021008,0x00121008,0x00021108,0x00121108,
0x04020000,0x04120000,0x04020100,0x04120100,
0x04020008,0x04120008,0x04020108,0x04120108,
0x04021000,0x04121000,0x04021100,0x04121100,
0x04021008,0x04121008,0x04021108,0x04121108,
},

// DP-Box 1 :
{
0x00000000,0x10000000,0x00010000,0x10010000,
0x00000004,0x10000004,0x00010004,0x10010004,
0x20000000,0x30000000,0x20010000,0x30010000,
0x20000004,0x30000004,0x20010004,0x30010004,
0x00100000,0x10100000,0x00110000,0x10110000,
0x00100004,0x10100004,0x00110004,0x10110004,
0x20100000,0x30100000,0x20110000,0x30110000,
0x20100004,0x30100004,0x20110004,0x30110004,
0x00001000,0x10001000,0x00011000,0x10011000,
0x00001004,0x10001004,0x00011004,0x10011004,
0x20001000,0x30001000,0x20011000,0x30011000,
0x20001004,0x30001004,0x20011004,0x30011004,
0x00101000,0x10101000,0x00111000,0x10111000,
0x00101004,0x10101004,0x00111004,0x10111004,
0x20101000,0x30101000,0x20111000,0x30111000,
0x20101004,0x30101004,0x20111004,0x30111004,
},

// DP-Box 2 :
{
0x00000000,0x08000000,0x00000008,0x08000008,
0x00000400,0x08000400,0x00000408,0x08000408,
0x00020000,0x08020000,0x00020008,0x08020008,
0x00020400,0x08020400,0x00020408,0x08020408,
0x00000001,0x08000001,0x00000009,0x08000009,
0x00000401,0x08000401,0x00000409,0x08000409,
0x00020001,0x08020001,0x00020009,0x08020009,
0x00020401,0x08020401,0x00020409,0x08020409,
0x02000000,0x0a000000,0x02000008,0x0a000008,
0x02000400,0x0a000400,0x02000408,0x0a000408,
0x02020000,0x0a020000,0x02020008,0x0a020008,
0x02020400,0x0a020400,0x02020408,0x0a020408,
0x02000001,0x0a000001,0x02000009,0x0a000009,
0x02000401,0x0a000401,0x02000409,0x0a000409,
0x02020001,0x0a020001,0x02020009,0x0a020009,
0x02020401,0x0a020401,0x02020409,0x0a020409,
},

// DP-Box 3 :
{
0x00000000,0x00000100,0x00080000,0x00080100,
0x01000000,0x01000100,0x01080000,0x01080100,
0x00000010,0x00000110,0x00080010,0x00080110,
0x01000010,0x01000110,0x01080010,0x01080110,
0x00200000,0x00200100,0x00280000,0x00280100,
0x01200000,0x01200100,0x01280000,0x01280100,
0x00200010,0x00200110,0x00280010,0x00280110,
0x01200010,0x01200110,0x01280010,0x01280110,
0x00000200,0x00000300,0x00080200,0x00080300,
0x01000200,0x01000300,0x01080200,0x01080300,
0x00000210,0x00000310,0x00080210,0x00080310,
0x01000210,0x01000310,0x01080210,0x01080310,
0x00200200,0x00200300,0x00280200,0x00280300,
0x01200200,0x01200300,0x01280200,0x01280300,
0x00200210,0x00200310,0x00280210,0x00280310,
0x01200210,0x01200310,0x01280210,0x01280310,
},

// DP-Box 4 :
{
0x00000000,0x04000000,0x00040000,0x04040000,
0x00000002,0x04000002,0x00040002,0x04040002,
0x00002000,0x04002000,0x00042000,0x04042000,
0x00002002,0x04002002,0x00042002,0x04042002,
0x00000020,0x04000020,0x00040020,0x04040020,
0x00000022,0x04000022,0x00040022,0x04040022,
0x00002020,0x04002020,0x00042020,0x04042020,
0x00002022,0x04002022,0x00042022,0x04042022,
0x00000800,0x04000800,0x00040800,0x04040800,
0x00000802,0x04000802,0x00040802,0x04040802,
0x00002800,0x04002800,0x00042800,0x04042800,
0x00002802,0x04002802,0x00042802,0x04042802,
0x00000820,0x04000820,0x00040820,0x04040820,
0x00000822,0x04000822,0x00040822,0x04040822,
0x00002820,0x04002820,0x00042820,0x04042820,
0x00002822,0x04002822,0x00042822,0x04042822,
},
};

static const unsigned int DesSPBox[8*64]=
{

// SP-Box 1 :
0x00820200, 0x00020000, 0x80800000, 0x80820200, 
0x00800000, 0x80020200, 0x80020000, 0x80800000, 
0x80020200, 0x00820200, 0x00820000, 0x80000200, 
0x80800200, 0x00800000, 0x00000000, 0x80020000, 
0x00020000, 0x80000000, 0x00800200, 0x00020200, 
0x80820200, 0x00820000, 0x80000200, 0x00800200, 
0x80000000, 0x00000200, 0x00020200, 0x80820000, 
0x00000200, 0x80800200, 0x80820000, 0x00000000, 
0x00000000, 0x80820200, 0x00800200, 0x80020000, 
0x00820200, 0x00020000, 0x80000200, 0x00800200, 
0x80820000, 0x00000200, 0x00020200, 0x80800000, 
0x80020200, 0x80000000, 0x80800000, 0x00820000, 
0x80820200, 0x00020200, 0x00820000, 0x80800200, 
0x00800000, 0x80000200, 0x80020000, 0x00000000, 
0x00020000, 0x00800000, 0x80800200, 0x00820200, 
0x80000000, 0x80820000, 0x00000200, 0x80020200, 

// SP-Box 2 :
0x10042004, 0x00000000, 0x00042000, 0x10040000, 
0x10000004, 0x00002004, 0x10002000, 0x00042000, 
0x00002000, 0x10040004, 0x00000004, 0x10002000, 
0x00040004, 0x10042000, 0x10040000, 0x00000004, 
0x00040000, 0x10002004, 0x10040004, 0x00002000, 
0x00042004, 0x10000000, 0x00000000, 0x00040004, 
0x10002004, 0x00042004, 0x10042000, 0x10000004, 
0x10000000, 0x00040000, 0x00002004, 0x10042004, 
0x00040004, 0x10042000, 0x10002000, 0x00042004, 
0x10042004, 0x00040004, 0x10000004, 0x00000000, 
0x10000000, 0x00002004, 0x00040000, 0x10040004, 
0x00002000, 0x10000000, 0x00042004, 0x10002004, 
0x10042000, 0x00002000, 0x00000000, 0x10000004, 
0x00000004, 0x10042004, 0x00042000, 0x10040000, 
0x10040004, 0x00040000, 0x00002004, 0x10002000, 
0x10002004, 0x00000004, 0x10040000, 0x00042000, 

// SP-Box 3 :
0x41000000, 0x01010040, 0x00000040, 0x41000040, 
0x40010000, 0x01000000, 0x41000040, 0x00010040, 
0x01000040, 0x00010000, 0x01010000, 0x40000000, 
0x41010040, 0x40000040, 0x40000000, 0x41010000, 
0x00000000, 0x40010000, 0x01010040, 0x00000040, 
0x40000040, 0x41010040, 0x00010000, 0x41000000, 
0x41010000, 0x01000040, 0x40010040, 0x01010000, 
0x00010040, 0x00000000, 0x01000000, 0x40010040, 
0x01010040, 0x00000040, 0x40000000, 0x00010000, 
0x40000040, 0x40010000, 0x01010000, 0x41000040, 
0x00000000, 0x01010040, 0x00010040, 0x41010000, 
0x40010000, 0x01000000, 0x41010040, 0x40000000, 
0x40010040, 0x41000000, 0x01000000, 0x41010040, 
0x00010000, 0x01000040, 0x41000040, 0x00010040, 
0x01000040, 0x00000000, 0x41010000, 0x40000040, 
0x41000000, 0x40010040, 0x00000040, 0x01010000, 

// SP-Box 4 :
0x00100402, 0x04000400, 0x00000002, 0x04100402, 
0x00000000, 0x04100000, 0x04000402, 0x00100002, 
0x04100400, 0x04000002, 0x04000000, 0x00000402, 
0x04000002, 0x00100402, 0x00100000, 0x04000000, 
0x04100002, 0x00100400, 0x00000400, 0x00000002, 
0x00100400, 0x04000402, 0x04100000, 0x00000400, 
0x00000402, 0x00000000, 0x00100002, 0x04100400, 
0x04000400, 0x04100002, 0x04100402, 0x00100000, 
0x04100002, 0x00000402, 0x00100000, 0x04000002, 
0x00100400, 0x04000400, 0x00000002, 0x04100000, 
0x04000402, 0x00000000, 0x00000400, 0x00100002, 
0x00000000, 0x04100002, 0x04100400, 0x00000400, 
0x04000000, 0x04100402, 0x00100402, 0x00100000, 
0x04100402, 0x00000002, 0x04000400, 0x00100402, 
0x00100002, 0x00100400, 0x04100000, 0x04000402, 
0x00000402, 0x04000000, 0x04000002, 0x04100400, 

// SP-Box 5 :
0x02000000, 0x00004000, 0x00000100, 0x02004108, 
0x02004008, 0x02000100, 0x00004108, 0x02004000, 
0x00004000, 0x00000008, 0x02000008, 0x00004100, 
0x02000108, 0x02004008, 0x02004100, 0x00000000, 
0x00004100, 0x02000000, 0x00004008, 0x00000108, 
0x02000100, 0x00004108, 0x00000000, 0x02000008, 
0x00000008, 0x02000108, 0x02004108, 0x00004008, 
0x02004000, 0x00000100, 0x00000108, 0x02004100, 
0x02004100, 0x02000108, 0x00004008, 0x02004000, 
0x00004000, 0x00000008, 0x02000008, 0x02000100, 
0x02000000, 0x00004100, 0x02004108, 0x00000000, 
0x00004108, 0x02000000, 0x00000100, 0x00004008, 
0x02000108, 0x00000100, 0x00000000, 0x02004108, 
0x02004008, 0x02004100, 0x00000108, 0x00004000, 
0x00004100, 0x02004008, 0x02000100, 0x00000108, 
0x00000008, 0x00004108, 0x02004000, 0x02000008, 

// SP-Box 6 :
0x20000010, 0x00080010, 0x00000000, 0x20080800, 
0x00080010, 0x00000800, 0x20000810, 0x00080000, 
0x00000810, 0x20080810, 0x00080800, 0x20000000, 
0x20000800, 0x20000010, 0x20080000, 0x00080810, 
0x00080000, 0x20000810, 0x20080010, 0x00000000, 
0x00000800, 0x00000010, 0x20080800, 0x20080010, 
0x20080810, 0x20080000, 0x20000000, 0x00000810, 
0x00000010, 0x00080800, 0x00080810, 0x20000800, 
0x00000810, 0x20000000, 0x20000800, 0x00080810, 
0x20080800, 0x00080010, 0x00000000, 0x20000800, 
0x20000000, 0x00000800, 0x20080010, 0x00080000, 
0x00080010, 0x20080810, 0x00080800, 0x00000010, 
0x20080810, 0x00080800, 0x00080000, 0x20000810, 
0x20000010, 0x20080000, 0x00080810, 0x00000000, 
0x00000800, 0x20000010, 0x20000810, 0x20080800, 
0x20080000, 0x00000810, 0x00000010, 0x20080010, 

// SP-Box 7 :
0x00001000, 0x00000080, 0x00400080, 0x00400001, 
0x00401081, 0x00001001, 0x00001080, 0x00000000, 
0x00400000, 0x00400081, 0x00000081, 0x00401000, 
0x00000001, 0x00401080, 0x00401000, 0x00000081, 
0x00400081, 0x00001000, 0x00001001, 0x00401081, 
0x00000000, 0x00400080, 0x00400001, 0x00001080, 
0x00401001, 0x00001081, 0x00401080, 0x00000001, 
0x00001081, 0x00401001, 0x00000080, 0x00400000, 
0x00001081, 0x00401000, 0x00401001, 0x00000081, 
0x00001000, 0x00000080, 0x00400000, 0x00401001, 
0x00400081, 0x00001081, 0x00001080, 0x00000000, 
0x00000080, 0x00400001, 0x00000001, 0x00400080, 
0x00000000, 0x00400081, 0x00400080, 0x00001080, 
0x00000081, 0x00001000, 0x00401081, 0x00400000, 
0x00401080, 0x00000001, 0x00001001, 0x00401081, 
0x00400001, 0x00401080, 0x00401000, 0x00001001, 

// SP-Box 8 :
0x08200020, 0x08208000, 0x00008020, 0x00000000, 
0x08008000, 0x00200020, 0x08200000, 0x08208020, 
0x00000020, 0x08000000, 0x00208000, 0x00008020, 
0x00208020, 0x08008020, 0x08000020, 0x08200000, 
0x00008000, 0x00208020, 0x00200020, 0x08008000, 
0x08208020, 0x08000020, 0x00000000, 0x00208000, 
0x08000000, 0x00200000, 0x08008020, 0x08200020, 
0x00200000, 0x00008000, 0x08208000, 0x00000020, 
0x00200000, 0x00008000, 0x08000020, 0x08208020, 
0x00008020, 0x08000000, 0x00000000, 0x00208000, 
0x08200020, 0x08008020, 0x08008000, 0x00200020, 
0x08208000, 0x00000020, 0x00200020, 0x08008000, 
0x08208020, 0x00200000, 0x08200000, 0x08000020, 
0x00208000, 0x00008020, 0x08008020, 0x08200000, 
0x00000020, 0x08208000, 0x00208020, 0x00000000, 
0x08000000, 0x08200020, 0x00008000, 0x00208020, 
};

/** @addtogroup des
*  @{
*/

extern "C" void DES_encrypt_decrypt(unsigned int * data,
                                    const unsigned int * SubKeyTab,
                                    int mode)
{
  int i;
  unsigned int l,r,u,v;

  r=data[0];					// get DATA low
  l=data[1];					// get DATA high
  //------------------------------------------------------------
  // Do initial permutation and prepare for E-Box Access
  //------------------------------------------------------------
  IP(r,l);					// do Initial Permutation
  r=LROT1(r);					// prepare for S-Box access
  l=LROT1(l);					// dto.
  //------------------------------------------------------------
  // Do Encryption
  //------------------------------------------------------------
  if(mode == DES_ENCRYPT)			// encryption mode selected
  {
    i=0;
    do
    {
      DES_ROUND(l,r,i,SubKeyTab);		// use subkey 1/5/ 9/13, C'',D''
      DES_ROUND(r,l,i+2,SubKeyTab);		// use subkey 2/6/10/14, C'',D''
      i += 4;
    } while(i<32);
  }
  //------------------------------------------------------------
  // Do Decryption
  //------------------------------------------------------------
  else
  {
    i=30;
    do
    {
      DES_ROUND(l,r,i,SubKeyTab);		// use subkey 16/12/8/4, C'',D''
      DES_ROUND(r,l,i-2,SubKeyTab);		// use subkey 15/11/7/3, C'',D''
      i -= 4;
    } while(i>0);

  }
  //------------------------------------------------------------
  // rearrange bits before final permutation, do final permutation
  //------------------------------------------------------------
  l = RROT1(l);				// convert back to original bit order
  r = RROT1(r);				// dto.

  FP(r,l);				// Do Final Permutation
  //------------------------------------------------------------
  //Store new data words, clear used temporary variables (safety)
  //------------------------------------------------------------
  data[0]=l;				// save new low
  data[1]=r;				// save new high
  l=r=u=v=0;				// clear temporary vars.
}

extern "C" void DES_encrypt3(unsigned int * data,
                             const unsigned int * SubKeyTab1,
                             const unsigned int * SubKeyTab2,
                             const unsigned int * SubKeyTab3)
{
  int i;
  unsigned int  l,r,u,v;

  r=data[0];					// get DATA low
  l=data[1];					// get DATA high
  //------------------------------------------------------------
  // Do initial permutation and prepare for E-Box Access
  //------------------------------------------------------------
  IP(r,l);					// do Initial Permutation
  r=LROT1(r);					// prepare for S-Box access
  l=LROT1(l);					// dto.
  //------------------------------------------------------------
  // Do 1st Encryption
  //------------------------------------------------------------
  i=0;
  do
  {
    DES_ROUND(l,r,i,SubKeyTab1);	// use subkey 1/5/ 9/13, C'',D''
    DES_ROUND(r,l,i+2,SubKeyTab1);	// use subkey 2/6/10/14, C'',D''
    i += 4;
  }while(i<32);
  //------------------------------------------------------------
  // Do 2nd Encryption (is a DECRYPTION!!)
  //------------------------------------------------------------
  i=30;
  do
  {
    DES_ROUND(r,l,i,SubKeyTab2);	// use subkey 16/12/8/4, C'',D''
    DES_ROUND(l,r,i-2,SubKeyTab2);	// use subkey 15/11/7/3, C'',D''
    i -= 4;
  } while(i>0);
  //------------------------------------------------------------
  // Do 3rd Encryption
  //------------------------------------------------------------
  i=0;
  do
  {
    DES_ROUND(l,r,i,SubKeyTab3);	// use subkey 1/5/ 9/13, C'',D''
    DES_ROUND(r,l,i+2,SubKeyTab3);	// use subkey 2/6/10/14, C'',D''
    i += 4;
  }while(i<32);
  //------------------------------------------------------------
  // rearrange bits before final permutation, do final permutation
  //------------------------------------------------------------
  l = RROT1(l);				// convert back to original bit order
  r = RROT1(r);				// dto.

  FP(r,l);				// Do Final Permutation
  //------------------------------------------------------------
  //Store new data words, clear used temporary variables (safety)
  //------------------------------------------------------------
  data[0]=l;				// save new low
  data[1]=r;				// save new high
  l=r=u=v=0;				// clear temporary vars.
}

extern "C" void DES_decrypt3(unsigned int * data,
                             const unsigned int * SubKeyTab1,
                             const unsigned int * SubKeyTab2,
                             const unsigned int * SubKeyTab3)
{
  int i;
  unsigned int l,r,u,v;
  r=data[0];					// get DATA low
  l=data[1];					// get DATA high
  //------------------------------------------------------------
  // Do initial permutation and prepare for E-Box Access
  //------------------------------------------------------------
  IP(r,l);					// do Initial Permutation
  r=LROT1(r);					// prepare for S-Box access
  l=LROT1(l);					// dto.
  //------------------------------------------------------------
  // Do 1st Decryption
  //------------------------------------------------------------
  i=30;
  do
  {
    DES_ROUND(l,r,i,SubKeyTab3);		// use subkey 16/12/8/4, C'',D''
    DES_ROUND(r,l,i-2,SubKeyTab3);		// use subkey 15/11/7/3, C'',D''
    i -= 4;
  }while(i>0);
  //------------------------------------------------------------
  // Do 2nd Decryption (is an Encryption)
  //------------------------------------------------------------
  i=0;
  do
  {
    DES_ROUND(r,l,i,SubKeyTab2);	// use subkey 1/5/ 9/13, C'',D''
    DES_ROUND(l,r,i+2,SubKeyTab2);	// use subkey 2/6/10/14, C'',D''
    i += 4;
  }while(i<32);
  //------------------------------------------------------------
  // Do 3rd Decryption
  //------------------------------------------------------------
  i=30;
  do
  {
    DES_ROUND(l,r,i,SubKeyTab1);		// use subkey 16/12/8/4, C'',D''
    DES_ROUND(r,l,i-2,SubKeyTab1);		// use subkey 15/11/7/3, C'',D''
    i -= 4;
  }while(i>0);
  //------------------------------------------------------------
  // rearrange bits before final permutation, do final permutation
  //------------------------------------------------------------
  l = RROT1(l);				// convert back to original bit order
  r = RROT1(r);				// dto.

  FP(r,l);				// Do Final Permutation
  //------------------------------------------------------------
  //Store new data words, clear used temporary variables (safety)
  //------------------------------------------------------------
  data[0]=l;				// save new low
  data[1]=r;				// save new high
  l=r=u=v=0;				// clear temporary vars.
}
/**
* Splits a given DES into 'registers' C and D doing initial
* key permutation (PC1)
*
*  @param DesKey 64 Bit (8*8 Byte) DES Key
*               in FIPS46 bit order
*  @param CDRegs C/D-registers (bit-reversed!!)
*               Element 0: C-register
*               Element 1: D-register
*/
static void SplitDESKey(const unsigned char * DesKey, int * CDRegs)
{
  unsigned int c,d;
  //
  // 1. Pre-Load DES Key Registers C,D
  //
    char2longn(DesKey,c,0);
    char2longn(DesKey,d,4);
  //
  // 2. Perform Initial Permutation on C,D Registers (PC-1)
  //    this leaves C and D loaded with the appropriate
  //	starting Subkeys in Bitreversed order !!
  //
    PC1(d,c)				// do Key Permutation
  //
  // 3. Store DES Key Registers C,D
  //
  CDRegs[0] = c;
  CDRegs[1] = d;
}

extern "C" void GenDESSubKeys(const unsigned char * DesKey, 
                              unsigned int * SubKeyTab)
{
  unsigned int c,d,s,t;
  unsigned int CDRegs[2];
  int i,j;
  
  //
  // Get DES C,D Registers
  //
    SplitDESKey(DesKey,(int *) CDRegs);
    c = CDRegs[0];
    d = CDRegs[1];
  //
  // 3. Generate Subkeys for direct Exoring to the data before
  //    entering the S-Box Permutation
  //
    i = j = 0;
    do
    {
      //
      // 3.1 rotate C,D registers 1 or 2 bit right (note the mentioned
      // reversed bit order in C and D !!)
      //
      if((i != 0) && (i != 1) && (i != 8) && (i != 15))
      {
        c=RROT2MOD28BIT(c);			// 2 Bits to the right
        d=RROT2MOD28BIT(d);			// dto.
      }
      else
      {
        c=RROT1MOD28BIT(c);			// 1 Bit to the right
        d=RROT1MOD28BIT(d);				// dto.
      }
      //
      // 3.2 Perform Key Compression Permutation PC-2 and
      // reorder output bits / bytes to be suited for XOR
      //
      s= DES_KPBox[0][  c     & 0x3F                ]| // Bit 1,2,3,4,5,6
         DES_KPBox[1][((c>> 7)& 0x3C)|((c>> 6)&0x03)]| // Bit 7,8,10,11,12,13
	 DES_KPBox[2][((c>>14)& 0x30)|((c>>13)&0x0F)]|// Bit14,15,16,17,19,20
         DES_KPBox[3][((c>>22)& 0x38)|((c>>21)&0x06)| // Bit21,23,24,26,27,28
                       ((c>>20)& 0x01)];

      t= DES_KPBox[4][  d     &0x3F                 ]|// Bit29,30,31,32,33,34
         DES_KPBox[5][((d>> 8)& 0x3C)|((d>> 7)&0x03)]|// Bit36,37,39,40,41,42
         DES_KPBox[6][((d>>15)& 0x3F)               ]|// Bit44,45,46,47,48,49
         DES_KPBox[7][((d>>22)& 0x30)|((d>>21)&0x0F)];// Bit50,51,53,54,55,56

         SubKeyTab[j] = 				// generate,save C''
            ((t<<16) | (s & 0xFFFF)) & 0xFFFFFFFF;
       
         t = ((t & 0xFFFF0000)|((s>>16) & 0xFFFF)) &	// generate D''
               0xFFFFFFFF;
      SubKeyTab[j+1] = LROT4(t);			// do pre-rotate, save

       j +=2;
       i ++;
    } while(i < 16);
}

extern "C" void DES_cbc_encrypt_decrypt(const unsigned char * input,
                                        unsigned char * output,
                                        const unsigned int * DES_SubkeyTab,
                                        size_t BlkCnt,
                                        unsigned char * IVector,
                                        int mode)
{
    if(BlkCnt == 0){
        return;
    }
  unsigned int tin0,tin1;
  unsigned int tout0,tout1,xor0,xor1;

  unsigned int tin[2];
  size_t l=BlkCnt;
  int i,j;

       
  if(mode == DES_ENCRYPT)
  {
    char2longn(IVector,tout0,0);	// get low portion of IV
    char2longn(IVector,tout1,4);	// dto. high

    i = 0;
    j = 0;
    do
    {
      char2long(input,tin0,i);		// get low  4 data bytes
      char2long(input,tin1,i);		// get high 4 data bytes
      tin[0]=tin0^tout0;
      tin[1]=tin1^tout1;

      DES_encrypt_decrypt(tin,DES_SubkeyTab,DES_ENCRYPT);
      tout0=tin[0];
      long2char(tout0,output,j);
      tout1=tin[1];
      long2char(tout1,output,j);
      l --;
    } while(l != 0);
    long2charn(tout0,IVector,0);
    long2charn(tout1,IVector,4);
  }
  else					// Decrypt
  {
    char2longn(IVector,xor0,0);
    char2longn(IVector,xor1,4);
    i=0;
    j=0;
    do
    {
      char2long(input,tin0,i);
      tin[0]=tin0;
      char2long(input,tin1,i);
      tin[1]=tin1;

      DES_encrypt_decrypt(tin,DES_SubkeyTab,DES_DECRYPT);
      tout0=tin[0]^xor0;
      tout1=tin[1]^xor1;
      long2char(tout0,output,j);
      long2char(tout1,output,j);
      xor0=tin0;
      xor1=tin1;
      l --;
    } while(l != 0);
    long2charn(xor0,IVector,0);
    long2charn(xor1,IVector,4);
  }
  tin0=tin1=tout0=tout1=xor0=xor1=0;
  tin[0]=tin[1]=0;
}

extern "C" void DES3_ede_cbc_encrypt_decrypt(const unsigned char * input,
                                             unsigned char * output,
                                             const unsigned int * DES_SubkeyTab1,
                                             const unsigned int * DES_SubkeyTab2,
                                             const unsigned int * DES_SubkeyTab3,
                                             size_t BlkCnt,
                                             unsigned char * IVector,
                                             int mode)
{
    unsigned int tin0, tin1, tout0, tout1;
    unsigned int xor0, xor1;
    unsigned int tin[2];
    int i = 0;
    int j = 0;

    if (BlkCnt == 0) {
        return;
    }

    if (mode == DES_ENCRYPT)
    {
        char2longn(IVector,tout0,0);	// get low portion of IV
        char2longn(IVector,tout1,4);	// dto. high

        while(BlkCnt > 0)
        {
            char2long(input,tin0,i);		// get low  4 data bytes
            char2long(input,tin1,i);		// get high 4 data bytes
            tin[0]=tin0^tout0;
            tin[1]=tin1^tout1;

            DES_encrypt3(tin,DES_SubkeyTab1,DES_SubkeyTab2,DES_SubkeyTab3);
            tout0=tin[0];
            long2char(tout0,output,j);
            tout1=tin[1];
            long2char(tout1,output,j);
            BlkCnt --;
        }
        long2charn(tout0,IVector,0);
        long2charn(tout1,IVector,4);
    }
    else					// Decrypt
    {
        char2longn(IVector,xor0,0);
        char2longn(IVector,xor1,4);

        while(BlkCnt > 0)
        {
            char2long(input,tin0,i);
            tin[0]=tin0;
            char2long(input,tin1,i);
            tin[1]=tin1;

            DES_decrypt3(tin,DES_SubkeyTab1,DES_SubkeyTab2,DES_SubkeyTab3);
            tout0=tin[0]^xor0;
            long2char(tout0,output,j);
            tout1=tin[1]^xor1;
            long2char(tout1,output,j);
            xor0=tin0;
            xor1=tin1;
            BlkCnt --;
        }
        long2charn(xor0,IVector,0);
        long2charn(xor1,IVector,4);
    }
    tin0=tin1=tout0=tout1=xor0=xor1=0;
    tin[0]=tin[1]=0;
}

extern "C" void DES_ecb_encrypt_decrypt(const unsigned char * input,
                                        unsigned char * output,
                                        const unsigned int * DES_SubkeyTab,
                                        size_t BlkCnt, int mode)
{
  int i,j;
  unsigned int tin[2];

       
  i=0;
  j=0;
  while(BlkCnt > 0)
  {
    char2long(input,tin[0],i);		// get low  4 data bytes
    char2long(input,tin[1],i);		// get high 4 data bytes

    DES_encrypt_decrypt(tin,DES_SubkeyTab, mode);

    long2char(tin[0],output,j);
    long2char(tin[1],output,j);
    BlkCnt--;
  }
  tin[0]=tin[1]=0;
}
/** @} */

#endif //HL_ENCR_DES
// end of file ../DES/hobdes.cpp


#ifdef HL_ENCR_RC
/** @defgroup rc2 RC2
* This module implements the RC2 block cipher algorithm.
*
* RC2 as implemented from a posting from Newsgroups: sci.crypt
* Sender: pgut01@cs.auckland.ac.nz (Peter Gutmann)
* Subject: Specification for Ron Rivests Cipher No.2
* Message-ID: <4fk39f$f70@net.auckland.ac.nz>
* Date: 11 Feb 1996 06:45:03 GMT
*
* Source documentation has been adaptad to Javadoc.
*
* See RRC2.DOC for description of algorithm.
* NOTE: The key-reduction is missing in the description but is
*  implemented within all known SSL servers !
* @{
* @file
* This file is the actual implementation of RC2.
* @}
*/
#include <string.h>
#if (defined _WIN32) & (_MSC_VER < 1700)
#ifndef _STDINT
#define _STDINT
// MSVC lower than 17.00 does not have stdint.h, assure, all needed types are defined

typedef unsigned __int16 uint16_t;

typedef unsigned __int32 uint32_t;

typedef unsigned __int64 uint64_t;

#endif // !_STDINT
#else
#include <stdint.h>
#endif
#include <stddef.h>
#ifdef _WIN32
#define WIN32_LEAN_AND_MEAN
#include <Windows.h>
#undef WIN32_LEAN_AND_MEAN
#else// Define system-specific HL_* defines here
#ifndef HL_UNIX
#define HL_UNIX

#if (defined __gnu_linux__) || (defined __linux__)
#define HL_LINUX
#endif

#if (defined __APPLE__) && (defined __MACH__)
#define HL_LINUX
#define HL_MACOS
#endif

#ifdef _AIX
#define HL_AIX
#define HL_BIG_ENDIAN
#endif

#ifdef __FreeBSD__
#define HL_FREEBSD
#endif

#if (defined _hpux) || (defined hpux) || (defined __hpux)
#define HL_HPUX
#define HL_BIG_ENDIAN
#endif

#if (defined sun) || (defined __sun)
#define HL_SOLARIS
#endif

#if (defined __arm__) || (defined __aarch64__)
#define HL_LINUX_ARM
#endif

#ifdef __ANDROID__
#define HL_ANDROID
#endif

#endif
#include <hob-unix01.h>
#endif
#ifdef __APPLE__
/* We get target conditionals to keep apart Mac OS, iOS and iOS simulator.
   The conditionals are TARGET_IPHONE_SIMULATOR, TARGET_OS_IPHONE and TARGET_OS_MAC.
   TARGET_IPHONE_SIMULATOR has the highest priority, TARGET_OS_MAC the lowest.
   Always test, if the conditional is 1, as they will be defined as 0, if we 
   are not compiling for the target.
   */
#include <TargetConditionals.h>
#endif

#include "hob-encry-1.h"
#include "hob-encry-intern-1.h"

static unsigned char RC2_SBox[256] = {

(unsigned char) 0xD9, (unsigned char) 0x78, (unsigned char) 0xF9, (unsigned char) 0xC4, 
(unsigned char) 0x19, (unsigned char) 0xDD, (unsigned char) 0xB5, (unsigned char) 0xED, 
(unsigned char) 0x28, (unsigned char) 0xE9, (unsigned char) 0xFD, (unsigned char) 0x79, 
(unsigned char) 0x4A, (unsigned char) 0xA0, (unsigned char) 0xD8, (unsigned char) 0x9D, 
(unsigned char) 0xC6, (unsigned char) 0x7E, (unsigned char) 0x37, (unsigned char) 0x83, 
(unsigned char) 0x2B, (unsigned char) 0x76, (unsigned char) 0x53, (unsigned char) 0x8E, 
(unsigned char) 0x62, (unsigned char) 0x4C, (unsigned char) 0x64, (unsigned char) 0x88, 
(unsigned char) 0x44, (unsigned char) 0x8B, (unsigned char) 0xFB, (unsigned char) 0xA2, 
(unsigned char) 0x17, (unsigned char) 0x9A, (unsigned char) 0x59, (unsigned char) 0xF5, 
(unsigned char) 0x87, (unsigned char) 0xB3, (unsigned char) 0x4F, (unsigned char) 0x13, 
(unsigned char) 0x61, (unsigned char) 0x45, (unsigned char) 0x6D, (unsigned char) 0x8D, 
(unsigned char) 0x09, (unsigned char) 0x81, (unsigned char) 0x7D, (unsigned char) 0x32, 
(unsigned char) 0xBD, (unsigned char) 0x8F, (unsigned char) 0x40, (unsigned char) 0xEB, 
(unsigned char) 0x86, (unsigned char) 0xB7, (unsigned char) 0x7B, (unsigned char) 0x0B, 
(unsigned char) 0xF0, (unsigned char) 0x95, (unsigned char) 0x21, (unsigned char) 0x22, 
(unsigned char) 0x5C, (unsigned char) 0x6B, (unsigned char) 0x4E, (unsigned char) 0x82, 
(unsigned char) 0x54, (unsigned char) 0xD6, (unsigned char) 0x65, (unsigned char) 0x93, 
(unsigned char) 0xCE, (unsigned char) 0x60, (unsigned char) 0xB2, (unsigned char) 0x1C, 
(unsigned char) 0x73, (unsigned char) 0x56, (unsigned char) 0xC0, (unsigned char) 0x14, 
(unsigned char) 0xA7, (unsigned char) 0x8C, (unsigned char) 0xF1, (unsigned char) 0xDC, 
(unsigned char) 0x12, (unsigned char) 0x75, (unsigned char) 0xCA, (unsigned char) 0x1F, 
(unsigned char) 0x3B, (unsigned char) 0xBE, (unsigned char) 0xE4, (unsigned char) 0xD1, 
(unsigned char) 0x42, (unsigned char) 0x3D, (unsigned char) 0xD4, (unsigned char) 0x30, 
(unsigned char) 0xA3, (unsigned char) 0x3C, (unsigned char) 0xB6, (unsigned char) 0x26, 
(unsigned char) 0x6F, (unsigned char) 0xBF, (unsigned char) 0x0E, (unsigned char) 0xDA, 
(unsigned char) 0x46, (unsigned char) 0x69, (unsigned char) 0x07, (unsigned char) 0x57, 
(unsigned char) 0x27, (unsigned char) 0xF2, (unsigned char) 0x1D, (unsigned char) 0x9B, 
(unsigned char) 0xBC, (unsigned char) 0x94, (unsigned char) 0x43, (unsigned char) 0x03, 
(unsigned char) 0xF8, (unsigned char) 0x11, (unsigned char) 0xC7, (unsigned char) 0xF6, 
(unsigned char) 0x90, (unsigned char) 0xEF, (unsigned char) 0x3E, (unsigned char) 0xE7, 
(unsigned char) 0x06, (unsigned char) 0xC3, (unsigned char) 0xD5, (unsigned char) 0x2F, 
(unsigned char) 0xC8, (unsigned char) 0x66, (unsigned char) 0x1E, (unsigned char) 0xD7, 
(unsigned char) 0x08, (unsigned char) 0xE8, (unsigned char) 0xEA, (unsigned char) 0xDE, 
(unsigned char) 0x80, (unsigned char) 0x52, (unsigned char) 0xEE, (unsigned char) 0xF7, 
(unsigned char) 0x84, (unsigned char) 0xAA, (unsigned char) 0x72, (unsigned char) 0xAC, 
(unsigned char) 0x35, (unsigned char) 0x4D, (unsigned char) 0x6A, (unsigned char) 0x2A, 
(unsigned char) 0x96, (unsigned char) 0x1A, (unsigned char) 0xD2, (unsigned char) 0x71, 
(unsigned char) 0x5A, (unsigned char) 0x15, (unsigned char) 0x49, (unsigned char) 0x74, 
(unsigned char) 0x4B, (unsigned char) 0x9F, (unsigned char) 0xD0, (unsigned char) 0x5E, 
(unsigned char) 0x04, (unsigned char) 0x18, (unsigned char) 0xA4, (unsigned char) 0xEC, 
(unsigned char) 0xC2, (unsigned char) 0xE0, (unsigned char) 0x41, (unsigned char) 0x6E, 
(unsigned char) 0x0F, (unsigned char) 0x51, (unsigned char) 0xCB, (unsigned char) 0xCC, 
(unsigned char) 0x24, (unsigned char) 0x91, (unsigned char) 0xAF, (unsigned char) 0x50, 
(unsigned char) 0xA1, (unsigned char) 0xF4, (unsigned char) 0x70, (unsigned char) 0x39, 
(unsigned char) 0x99, (unsigned char) 0x7C, (unsigned char) 0x3A, (unsigned char) 0x85, 
(unsigned char) 0x23, (unsigned char) 0xB8, (unsigned char) 0xB4, (unsigned char) 0x7A, 
(unsigned char) 0xFC, (unsigned char) 0x02, (unsigned char) 0x36, (unsigned char) 0x5B, 
(unsigned char) 0x25, (unsigned char) 0x55, (unsigned char) 0x97, (unsigned char) 0x31, 
(unsigned char) 0x2D, (unsigned char) 0x5D, (unsigned char) 0xFA, (unsigned char) 0x98, 
(unsigned char) 0xE3, (unsigned char) 0x8A, (unsigned char) 0x92, (unsigned char) 0xAE, 
(unsigned char) 0x05, (unsigned char) 0xDF, (unsigned char) 0x29, (unsigned char) 0x10, 
(unsigned char) 0x67, (unsigned char) 0x6C, (unsigned char) 0xBA, (unsigned char) 0xC9, 
(unsigned char) 0xD3, (unsigned char) 0x00, (unsigned char) 0xE6, (unsigned char) 0xCF, 
(unsigned char) 0xE1, (unsigned char) 0x9E, (unsigned char) 0xA8, (unsigned char) 0x2C, 
(unsigned char) 0x63, (unsigned char) 0x16, (unsigned char) 0x01, (unsigned char) 0x3F, 
(unsigned char) 0x58, (unsigned char) 0xE2, (unsigned char) 0x89, (unsigned char) 0xA9, 
(unsigned char) 0x0D, (unsigned char) 0x38, (unsigned char) 0x34, (unsigned char) 0x1B, 
(unsigned char) 0xAB, (unsigned char) 0x33, (unsigned char) 0xFF, (unsigned char) 0xB0, 
(unsigned char) 0xBB, (unsigned char) 0x48, (unsigned char) 0x0C, (unsigned char) 0x5F, 
(unsigned char) 0xB9, (unsigned char) 0xB1, (unsigned char) 0xCD, (unsigned char) 0x2E, 
(unsigned char) 0xC5, (unsigned char) 0xF3, (unsigned char) 0xDB, (unsigned char) 0x47, 
(unsigned char) 0xE5, (unsigned char) 0xA5, (unsigned char) 0x9C, (unsigned char) 0x77, 
(unsigned char) 0x0A, (unsigned char) 0xA6, (unsigned char) 0x20, (unsigned char) 0x68, 
(unsigned char) 0xFE, (unsigned char) 0x7F, (unsigned char) 0xC1, (unsigned char) 0xAD, 

};

/** @addtogroup rc2
* @{
*/
// Original comment from ssleay:

/* It has come to my attention that there are 2 versions of the RC2
 * key schedule.  One which is normal, and another which has a hook to
 * use a reduced key length.
 * BSAFE uses the 'retarded' version.  What I previously shipped is
 * the same as specifying 1024 for the 'bits' parameter.  Bsafe uses
 * a version where the bits parameter is the same as len*8 */

// now only 0 and <> 0 are supporrted G.O.

extern "C" void RC2_SetKey(short Key[],
                           const char data[], 
                           size_t len,
                           int bits)
{
  
  char TmpKey[128];			// temporary array, bytewide
  char c,d;

  int i,j;

  //--------------------------------------------------------
  // Step 0. Limit requested bytes and bits
  //--------------------------------------------------------
  if(len > 128)				// limit size of Key input data
    len=128;
  if ((bits <= 0) || (bits > 1024))	// limit bits to Max.
    bits=1024;
  //--------------------------------------------------------
  // Step 1. Copy Key material to Temporary Buffer
  //--------------------------------------------------------
  if(len == 0)
  {
    TmpKey[0] = 0;				// initialize 1st Element
    c = 0;					// Clear Sum variable
  }
  else
  {
    memcpy(TmpKey+0,data+0,len);
    c = TmpKey[len-1];		// get last byte from initdata
  }
  //--------------------------------------------------------
  // Step 2. Key expansion up to 128 Bytes
  // 2.0. IndexS = 0, IndexE = Len-1 or 0 if Len == 0
  // 2.1. Sum = SBox[(Key[IndexE] + Key[IndexS])]
  // 2.2. IndexS++, IndexE++
  // 2.2. Key[IndexE] = Sum
  // 2.3. while IndexE < 128 goto 2.1.
  // 2.4. Key[0] = SBox[Key[0]]
  //--------------------------------------------------------
  i = static_cast<int>(len);
  j = 0;
  while(i < RC2_MAX_KEY_BYTES)
  {
    c = RC2_SBox[((int) (TmpKey[j++] + c)) & 0xFF];
    TmpKey[i++] = c;
  }
  TmpKey[0] = RC2_SBox[(int) TmpKey[0] & 0xFF]; // zus. eingefuegt !!
						 // ist weiter unten

  //--------------------------------------------------------
  // hier stimmt was nicht, wenn bits = 1024 ist !!!!
  // dann j = 128, i = 0 !!!! -> while Schleife dreht hohl !!
  // ==> Fehler: Schleife war nicht abweisend, ist nun abweisend
  //--------------------------------------------------------
  /* hmm.... key reduction to 'bits' bits */

  if(bits != 0)
  {

    j = (bits+7)/8;			// number of used bytes of key
    i = RC2_MAX_KEY_BYTES-j;		// index to topmost used byte

    c = (unsigned char) ((int) 0xFF >> (-bits & 0x07));	// Bit reduction Mask
    d = TmpKey[i] = RC2_SBox[(TmpKey[i] & c) & 0xFF]; // remove unused bits

    while(i != 0)
    {
      i--;
      d = TmpKey[i] = RC2_SBox[(TmpKey[(i+j) & 0xFF] ^ d) & 0xFF];
    }
  }
  //--------------------------------------------------------
  // Byte to word conversion, machine independent
  //--------------------------------------------------------
  i = j = 0;
  do
  {
    Key[i] = (short) (((short) TmpKey[j] & (short) 0xFF) |
                        (((short) TmpKey[j+1] & (short) 0xFF) << 8));
    j += 2;
    i ++;
  } while(i < RC2_MAX_KEY_WORDS);
}

/**
* Encrypts/decrypts a single 8 byte data block using RC2 (RC2_encrypt).
*
*  @param d 8 byte data block to process
*  @param key RC2 keydata array
*  @param mode RC2_ENCRYPT -> do encryption
*               RC2_DECRYPT -> do decryption
*/
extern "C" void RC2_encrypt(int* d,const short* key,int mode)
{
  int i,n,k;
  short x0,x1,x2,x3,t;
  int l;

  //----------------------------------------------------------
  // split 8 Input bytes to 4 words a 16 bits
  //----------------------------------------------------------
  l  = d[0];					// get low 4 bytes
  x0 = (short) (l & 0xFFFF);			// Byte 0,1
  x1 = (short) ((l>>16) & 0xFFFF);		// Byte 2,3

  l  = d[1];					// get high 4 bytes
  x2 = (short) (l & 0xFFFF);			// Byte 4,5
  x3 = (short) ((l>>16) & 0xFFFF);		// Byte 6,7
  //----------------------------------------------------------
  // do encrypt/decrypt
  //----------------------------------------------------------
  n=3;
  i=5;						// 5 Subrounds first
  if (mode == RC2_ENCRYPT)
  {
    //-------------------------------------------------------
    // RC2 Encryption
    //-------------------------------------------------------
    k = 0;					// index to key table start
    for (;;)
    {
      //-----------------------------------------------------
      // RC2 Sub-Round (for all 4 words)
      //-----------------------------------------------------
      t  = (short) ((x0 + (x1 & ~x3) + (x2 & x3) + key[k++]) & 0xFFFF);
      x0 = (short) ((t<<1) | ((t>>15) & (char) 0x01));

      t  = (short) ((x1 + (x2 & ~x0) + (x3 & x0) + key[k++]) & 0xFFFF);
      x1 = (short) ((t<<2) | ((t>>14) & (char) 0x03));

      t  = (short) ((x2 + (x3 & ~x1) + (x0 & x1) + key[k++]) & 0xFFFF);
      x2 = (short) ((t<<3) | ((t>>13) & (char) 0x07));

      t  = (short) ((x3 + (x0 & ~x2) + (x1 & x2) + key[k++]) & 0xFFFF);
      x3 = (short) ((t<<5) | ((t>>11) & (char) 0x1F));

      i--;
      if(i == 0)
      {
        n--;
        if(n == 0) break;		// all round processed
        i = 5;				// prepare for last 5 Rounds
	if(n == 2) i++;			// middle 6 Rounds correction
        //-----------------------------------------------------
        // additional permutation after Round 5 and 11
        //-----------------------------------------------------
        x0 = (short) (x0 + key[x3 & 0x3F]);
        x1 = (short) (x1 + key[x0 & 0x3F]);
        x2 = (short) (x2 + key[x1 & 0x3F]);
        x3 = (short) (x3 + key[x2 & 0x3F]);
      }
    }
  }
  else  // Decrypt
  {
    //-------------------------------------------------------
    // RC2 Decryption
    //-------------------------------------------------------
    k = 63;				// index to key table start
    for (;;)
    {
      //-----------------------------------------------------
      // RC2 Sub-Round (for all 4 words)
      //-----------------------------------------------------
      t  = (short) (((x3<<11) | ((x3>>5) & 0x07FF)) & 0xFFFF);
      x3 = (short) ((t-(x0& ~x2)-(x1&x2)- key[k--]) & 0xFFFF);

      t  = (short) (((x2<<13) | ((x2>>3) & 0x1FFF)) & 0xFFFF);
      x2 = (short) ((t-(x3& ~x1)-(x0&x1)- key[k--]) & 0xFFFF);

      t  = (short) (((x1<<14) | ((x1>>2) & 0x3FFF)) & 0xFFFF);
      x1 = (short) ((t-(x2& ~x0)-(x3&x0)- key[k--]) & 0xFFFF);

      t  = (short) (((x0<<15) | ((x0>>1) & 0x7FFF)) & 0xFFFF);
      x0 = (short) ((t-(x1& ~x3)-(x2&x3)- key[k--]) & 0xFFFF);

      i--;
      if(i == 0)
      {
        n--;
        if(n == 0) break;		// all round processed
        i = 5;				// prepare for last 5 Rounds
	if(n == 2) i++;			// middle 6 Rounds correction
        //-----------------------------------------------------
        // additional permutation after Round 5 and 11
        //-----------------------------------------------------
        x3 = (short) ((x3-key[x2 & 0x3F]) & 0xFFFF);
        x2 = (short) ((x2-key[x1 & 0x3F]) & 0xFFFF);
        x1 = (short) ((x1-key[x0 & 0x3F]) & 0xFFFF);
        x0 = (short) ((x0-key[x3 & 0x3F]) & 0xFFFF);
      }
    }
  }
  //-----------------------------------------------------------
  // store 8 output bytes
  //-----------------------------------------------------------
  d[0] = (int) ((((int) x0) & 0xFFFF) |
                  ((((int) x1) & 0xFFFF) << 16));

  d[1] = (int) ((((int) x2) & 0xFFFF) |
                  ((((int) x3) & 0xFFFF) << 16));

}

extern "C" void RC2_cbc_encdecrypt(const char in[], 
                                   int InpOffset,
                                   char out[], 
                                   int OutpOffset,
                                   size_t length, 
                                   const short key[],
                                   char iv[], 
                                   int mode)
{
  int i,j;
  int tin0,tin1;
  int tout0,tout1,xor0,xor1;
  long long l=static_cast<long long>(length);
  int tin[2];

  if(mode == RC2_ENCRYPT)
  {
    i = 0;
    char2long(iv,tout0,i);
    char2longn(iv,tout1,i);

    i = InpOffset;
    j = OutpOffset;
    for (l-=8; l>=0; l-=8)
    {
      char2long(in,tin0,i);
      char2long(in,tin1,i);
      tin0 ^= tout0;
      tin1 ^= tout1;
      tin[0] = tin0;
      tin[1] = tin1;
      RC2_encrypt(tin,key,RC2_ENCRYPT);
      tout0 = tin[0];
      long2char(tout0,out,j);
      tout1 = tin[1];
      long2char(tout1,out,j);
    }
    i = 0;
    long2char(tout0,iv,i);
    long2charn(tout1,iv,i);
  }
  else // Decrypt
  {
    i = 0;
    char2long(iv,xor0,i);
    char2longn(iv,xor1,i);

    i = InpOffset;
    j = OutpOffset;
    for (l-=8; l>=0; l-=8)
    {
      char2long(in,tin0,i);
      tin[0]=tin0;
      char2long(in,tin1,i);
      tin[1]=tin1;
      RC2_encrypt(tin,key,RC2_DECRYPT);
      tout0 = tin[0] ^ xor0;
      tout1 = tin[1] ^ xor1;
      long2char(tout0,out,j);
      long2char(tout1,out,j);
      xor0 = tin0;
      xor1 = tin1;
    }
    i = 0;
    long2char(xor0,iv,i);
    long2charn(xor1,iv,i);
  }
  tin0 = tin1 = tout0 = tout1 = xor0 = xor1 = 0;
  tin[0] = tin[1] = 0;
}

/** @} */

#endif //HL_ENCR_RC
// end of file ../RC2/r2.cpp


#ifdef HL_ENCR_RC
/** @defgroup rc4 RC 4
* This module implements an RC4 compatible stream cipher algorithm.
*
* It is in the form in which the ARCFOUR was published in 1994 (see Applied 
* Cryptography, Second Edition: protocols, algorithms and source
* code in C, Bruce Schneier, John Wiley & Sons, Inc., 1996
* and <a href="http://en.wikipedia.org/wiki/RC4">Wikipedia</a>).
*
* The RC4 compatible stream cipher algorithm is used for SSL/TLS symmetric 
* encryption.
* @{
* @file
* This file implements the RC4 stream cipher algorithm.
*
* RC4 as implemented from a posting from Newsgroups: sci.crypt
* From: sterndark@netcom.com (David Sterndark)
* Subject: RC4 Algorithm revealed.
* Message-ID: <sternCvKL4B.Hyy@netcom.com>
* Date: Wed, 14 Sep 1994 06:35:31 GMT
*
* See RRC4.DOC for description of algorithm.
* @}
*/
#include <string.h>
#if (defined _WIN32) & (_MSC_VER < 1700)
#ifndef _STDINT
#define _STDINT
// MSVC lower than 17.00 does not have stdint.h, assure, all needed types are defined

typedef unsigned __int16 uint16_t;

typedef unsigned __int32 uint32_t;

typedef unsigned __int64 uint64_t;

#endif // !_STDINT
#else
#include <stdint.h>
#endif
#include <stddef.h>
#ifdef _WIN32
#define WIN32_LEAN_AND_MEAN
#include <Windows.h>
#undef WIN32_LEAN_AND_MEAN
#else// Define system-specific HL_* defines here
#ifndef HL_UNIX
#define HL_UNIX

#if (defined __gnu_linux__) || (defined __linux__)
#define HL_LINUX
#endif

#if (defined __APPLE__) && (defined __MACH__)
#define HL_LINUX
#define HL_MACOS
#endif

#ifdef _AIX
#define HL_AIX
#define HL_BIG_ENDIAN
#endif

#ifdef __FreeBSD__
#define HL_FREEBSD
#endif

#if (defined _hpux) || (defined hpux) || (defined __hpux)
#define HL_HPUX
#define HL_BIG_ENDIAN
#endif

#if (defined sun) || (defined __sun)
#define HL_SOLARIS
#endif

#if (defined __arm__) || (defined __aarch64__)
#define HL_LINUX_ARM
#endif

#ifdef __ANDROID__
#define HL_ANDROID
#endif

#endif
#include <hob-unix01.h>
#endif
#ifdef __APPLE__
/* We get target conditionals to keep apart Mac OS, iOS and iOS simulator.
   The conditionals are TARGET_IPHONE_SIMULATOR, TARGET_OS_IPHONE and TARGET_OS_MAC.
   TARGET_IPHONE_SIMULATOR has the highest priority, TARGET_OS_MAC the lowest.
   Always test, if the conditional is 1, as they will be defined as 0, if we 
   are not compiling for the target.
   */
#include <TargetConditionals.h>
#endif

#include "hob-encry-1.h"
#include "hob-encry-intern-1.h"

/** @addtogroup rc4
* @{
*/

extern "C" void RC4_SetKey(char state[],
                           const char data[],
                           int Offset, 
                           size_t len)
{
  char tmp;
  int   id1=Offset;
  int	index=static_cast<int>(len)+Offset;
  int	id2=0;
  int i;

  //---------------------------------------------------
  // preload RC4 State Array, set x = 0, y = 0        
  //---------------------------------------------------
  for (i=0; i<256; i++)	state[i+RC4_data] = (char) (i & 0xFF);	// preset
  state[RC4_x] = 0;     
  state[RC4_y] = 0;     

  //---------------------------------------------------
  // Correlate with key data
  //---------------------------------------------------
  for (i=0; i < 256; i+=4)
  {
    SK_LOOP(i+0);
    SK_LOOP(i+1);
    SK_LOOP(i+2);
    SK_LOOP(i+3);
  }
}

extern "C" void RC4(const char indata[], 
                    int InpOffset,
                    size_t len,
                    char outdata[],
                    int OutpOffset,
                    char key[])
{
  int x,y,tx;
  size_t i = len;
  int j = InpOffset;
  int k = OutpOffset;

  if(i == 0) return;			// nothing to do
        
  x=((int) key[RC4_x]) & 0xFF;     
  y=((int) key[RC4_y]) & 0xFF;     

  for (;;)
  {               
    RC4_ENC_LOOP(indata[j++],outdata[k++]); i--; if(i == 0) break;
    RC4_ENC_LOOP(indata[j++],outdata[k++]); i--; if(i == 0) break;
    RC4_ENC_LOOP(indata[j++],outdata[k++]); i--; if(i == 0) break;
    RC4_ENC_LOOP(indata[j++],outdata[k++]); i--; if(i == 0) break;
    RC4_ENC_LOOP(indata[j++],outdata[k++]); i--; if(i == 0) break;
    RC4_ENC_LOOP(indata[j++],outdata[k++]); i--; if(i == 0) break;
    RC4_ENC_LOOP(indata[j++],outdata[k++]); i--; if(i == 0) break;
    RC4_ENC_LOOP(indata[j++],outdata[k++]); i--; if(i == 0) break;
  }               
  key[RC4_x] = (char) (x & 0xFF);     
  key[RC4_y] = (char) (y & 0xFF);
}

extern "C" void m_rc4_singlepass(const char* byrp_indata,
                                 int imp_inpoffset,
                                 size_t szp_inplen,
                                 const char* byrp_key,
                                 int imp_keyoffset,
                                 size_t szp_keylen,
                                 char* byrp_outdata,
                                 int imp_outpoffset)
{
  int i;
  char byrl_state[258];

  RC4_SetKey(byrl_state,byrp_key,imp_keyoffset,szp_keylen);
  RC4(byrp_indata,imp_inpoffset,szp_inplen,byrp_outdata,imp_outpoffset,
      byrl_state);
  for(i=0;i<258;i++)
    byrl_state[i] = 0;
}

/** @} */

#endif //HL_ENCR_RC
// end of file ../RC4/r4.cpp


#ifdef HL_ENCR_RMD
/** @defgroup ripemd RIPEMD 160
* This module implements the RIPEMD-160 hash algorithm used for certificate
* signatures.
*
* It is used by some european CAs.
*
* The state array will be cleared in the final step.
*
* No other modules are used.
* @{
* @file
* RIPEMD 160 Digest Functions
* adapted from OPENSSL, for further description see the
* original files
* @}
*/
#if (defined _WIN32) & (_MSC_VER < 1700)
#ifndef _STDINT
#define _STDINT
// MSVC lower than 17.00 does not have stdint.h, assure, all needed types are defined

typedef unsigned __int16 uint16_t;

typedef unsigned __int32 uint32_t;

typedef unsigned __int64 uint64_t;

#endif // !_STDINT
#else
#include <stdint.h>
#endif
#include <stddef.h>
#ifdef _WIN32
#define WIN32_LEAN_AND_MEAN
#include <Windows.h>
#undef WIN32_LEAN_AND_MEAN
#else// Define system-specific HL_* defines here
#ifndef HL_UNIX
#define HL_UNIX

#if (defined __gnu_linux__) || (defined __linux__)
#define HL_LINUX
#endif

#if (defined __APPLE__) && (defined __MACH__)
#define HL_LINUX
#define HL_MACOS
#endif

#ifdef _AIX
#define HL_AIX
#define HL_BIG_ENDIAN
#endif

#ifdef __FreeBSD__
#define HL_FREEBSD
#endif

#if (defined _hpux) || (defined hpux) || (defined __hpux)
#define HL_HPUX
#define HL_BIG_ENDIAN
#endif

#if (defined sun) || (defined __sun)
#define HL_SOLARIS
#endif

#if (defined __arm__) || (defined __aarch64__)
#define HL_LINUX_ARM
#endif

#ifdef __ANDROID__
#define HL_ANDROID
#endif

#endif
#include <hob-unix01.h>
#endif
#ifdef __APPLE__
/* We get target conditionals to keep apart Mac OS, iOS and iOS simulator.
   The conditionals are TARGET_IPHONE_SIMULATOR, TARGET_OS_IPHONE and TARGET_OS_MAC.
   TARGET_IPHONE_SIMULATOR has the highest priority, TARGET_OS_MAC the lowest.
   Always test, if the conditional is 1, as they will be defined as 0, if we 
   are not compiling for the target.
   */
#include <TargetConditionals.h>
#endif

#include "hob-encry-1.h"
#include <string.h>
#include <stdlib.h>
#include "hob-encry-intern-1.h"

/** @addtogroup ripemd
* @{
*/
/**
* Processes a full block of data from the RPMD-array and updates it (Ripemd160_Block).
*
*  @param RPMD_Array Pointer to RIPEMD state array
*/
static void Ripemd160_Block(int* RPMD_Array)
{
  int A,B,C,D,E;
  int a,b,c,d,e;

  A = RPMD_Array[RPMD_A];
  B = RPMD_Array[RPMD_B];
  C = RPMD_Array[RPMD_C];
  D = RPMD_Array[RPMD_D];
  E = RPMD_Array[RPMD_E];

  RIP1(A,B,C,D,E,ZL_00,SL_00);
  RIP1(E,A,B,C,D,ZL_01,SL_01);
  RIP1(D,E,A,B,C,ZL_02,SL_02);
  RIP1(C,D,E,A,B,ZL_03,SL_03);
  RIP1(B,C,D,E,A,ZL_04,SL_04);
  RIP1(A,B,C,D,E,ZL_05,SL_05);
  RIP1(E,A,B,C,D,ZL_06,SL_06);
  RIP1(D,E,A,B,C,ZL_07,SL_07);
  RIP1(C,D,E,A,B,ZL_08,SL_08);
  RIP1(B,C,D,E,A,ZL_09,SL_09);
  RIP1(A,B,C,D,E,ZL_10,SL_10);
  RIP1(E,A,B,C,D,ZL_11,SL_11);
  RIP1(D,E,A,B,C,ZL_12,SL_12);
  RIP1(C,D,E,A,B,ZL_13,SL_13);
  RIP1(B,C,D,E,A,ZL_14,SL_14);
  RIP1(A,B,C,D,E,ZL_15,SL_15);

  RIP2(E,A,B,C,D,ZL_16,SL_16,YL_1);
  RIP2(D,E,A,B,C,ZL_17,SL_17,YL_1);
  RIP2(C,D,E,A,B,ZL_18,SL_18,YL_1);
  RIP2(B,C,D,E,A,ZL_19,SL_19,YL_1);
  RIP2(A,B,C,D,E,ZL_20,SL_20,YL_1);
  RIP2(E,A,B,C,D,ZL_21,SL_21,YL_1);
  RIP2(D,E,A,B,C,ZL_22,SL_22,YL_1);
  RIP2(C,D,E,A,B,ZL_23,SL_23,YL_1);
  RIP2(B,C,D,E,A,ZL_24,SL_24,YL_1);
  RIP2(A,B,C,D,E,ZL_25,SL_25,YL_1);
  RIP2(E,A,B,C,D,ZL_26,SL_26,YL_1);
  RIP2(D,E,A,B,C,ZL_27,SL_27,YL_1);
  RIP2(C,D,E,A,B,ZL_28,SL_28,YL_1);
  RIP2(B,C,D,E,A,ZL_29,SL_29,YL_1);
  RIP2(A,B,C,D,E,ZL_30,SL_30,YL_1);
  RIP2(E,A,B,C,D,ZL_31,SL_31,YL_1);

  RIP3(D,E,A,B,C,ZL_32,SL_32,YL_2);
  RIP3(C,D,E,A,B,ZL_33,SL_33,YL_2);
  RIP3(B,C,D,E,A,ZL_34,SL_34,YL_2);
  RIP3(A,B,C,D,E,ZL_35,SL_35,YL_2);
  RIP3(E,A,B,C,D,ZL_36,SL_36,YL_2);
  RIP3(D,E,A,B,C,ZL_37,SL_37,YL_2);
  RIP3(C,D,E,A,B,ZL_38,SL_38,YL_2);
  RIP3(B,C,D,E,A,ZL_39,SL_39,YL_2);
  RIP3(A,B,C,D,E,ZL_40,SL_40,YL_2);
  RIP3(E,A,B,C,D,ZL_41,SL_41,YL_2);
  RIP3(D,E,A,B,C,ZL_42,SL_42,YL_2);
  RIP3(C,D,E,A,B,ZL_43,SL_43,YL_2);
  RIP3(B,C,D,E,A,ZL_44,SL_44,YL_2);
  RIP3(A,B,C,D,E,ZL_45,SL_45,YL_2);
  RIP3(E,A,B,C,D,ZL_46,SL_46,YL_2);
  RIP3(D,E,A,B,C,ZL_47,SL_47,YL_2);

  RIP4(C,D,E,A,B,ZL_48,SL_48,YL_3);
  RIP4(B,C,D,E,A,ZL_49,SL_49,YL_3);
  RIP4(A,B,C,D,E,ZL_50,SL_50,YL_3);
  RIP4(E,A,B,C,D,ZL_51,SL_51,YL_3);
  RIP4(D,E,A,B,C,ZL_52,SL_52,YL_3);
  RIP4(C,D,E,A,B,ZL_53,SL_53,YL_3);
  RIP4(B,C,D,E,A,ZL_54,SL_54,YL_3);
  RIP4(A,B,C,D,E,ZL_55,SL_55,YL_3);
  RIP4(E,A,B,C,D,ZL_56,SL_56,YL_3);
  RIP4(D,E,A,B,C,ZL_57,SL_57,YL_3);
  RIP4(C,D,E,A,B,ZL_58,SL_58,YL_3);
  RIP4(B,C,D,E,A,ZL_59,SL_59,YL_3);
  RIP4(A,B,C,D,E,ZL_60,SL_60,YL_3);
  RIP4(E,A,B,C,D,ZL_61,SL_61,YL_3);
  RIP4(D,E,A,B,C,ZL_62,SL_62,YL_3);
  RIP4(C,D,E,A,B,ZL_63,SL_63,YL_3);

  RIP5(B,C,D,E,A,ZL_64,SL_64,YL_4);
  RIP5(A,B,C,D,E,ZL_65,SL_65,YL_4);
  RIP5(E,A,B,C,D,ZL_66,SL_66,YL_4);
  RIP5(D,E,A,B,C,ZL_67,SL_67,YL_4);
  RIP5(C,D,E,A,B,ZL_68,SL_68,YL_4);
  RIP5(B,C,D,E,A,ZL_69,SL_69,YL_4);
  RIP5(A,B,C,D,E,ZL_70,SL_70,YL_4);
  RIP5(E,A,B,C,D,ZL_71,SL_71,YL_4);
  RIP5(D,E,A,B,C,ZL_72,SL_72,YL_4);
  RIP5(C,D,E,A,B,ZL_73,SL_73,YL_4);
  RIP5(B,C,D,E,A,ZL_74,SL_74,YL_4);
  RIP5(A,B,C,D,E,ZL_75,SL_75,YL_4);
  RIP5(E,A,B,C,D,ZL_76,SL_76,YL_4);
  RIP5(D,E,A,B,C,ZL_77,SL_77,YL_4);
  RIP5(C,D,E,A,B,ZL_78,SL_78,YL_4);
  RIP5(B,C,D,E,A,ZL_79,SL_79,YL_4);

  a = A;
  b = B;
  c = C;
  d = D;
  e = E;

  // Do other half 

  A = RPMD_Array[RPMD_A];
  B = RPMD_Array[RPMD_B];
  C = RPMD_Array[RPMD_C];
  D = RPMD_Array[RPMD_D];
  E = RPMD_Array[RPMD_E];

  RIP5(A,B,C,D,E,ZR_00,SR_00,YR_0);
  RIP5(E,A,B,C,D,ZR_01,SR_01,YR_0);
  RIP5(D,E,A,B,C,ZR_02,SR_02,YR_0);
  RIP5(C,D,E,A,B,ZR_03,SR_03,YR_0);
  RIP5(B,C,D,E,A,ZR_04,SR_04,YR_0);
  RIP5(A,B,C,D,E,ZR_05,SR_05,YR_0);
  RIP5(E,A,B,C,D,ZR_06,SR_06,YR_0);
  RIP5(D,E,A,B,C,ZR_07,SR_07,YR_0);
  RIP5(C,D,E,A,B,ZR_08,SR_08,YR_0);
  RIP5(B,C,D,E,A,ZR_09,SR_09,YR_0);
  RIP5(A,B,C,D,E,ZR_10,SR_10,YR_0);
  RIP5(E,A,B,C,D,ZR_11,SR_11,YR_0);
  RIP5(D,E,A,B,C,ZR_12,SR_12,YR_0);
  RIP5(C,D,E,A,B,ZR_13,SR_13,YR_0);
  RIP5(B,C,D,E,A,ZR_14,SR_14,YR_0);
  RIP5(A,B,C,D,E,ZR_15,SR_15,YR_0);

  RIP4(E,A,B,C,D,ZR_16,SR_16,YR_1);
  RIP4(D,E,A,B,C,ZR_17,SR_17,YR_1);
  RIP4(C,D,E,A,B,ZR_18,SR_18,YR_1);
  RIP4(B,C,D,E,A,ZR_19,SR_19,YR_1);
  RIP4(A,B,C,D,E,ZR_20,SR_20,YR_1);
  RIP4(E,A,B,C,D,ZR_21,SR_21,YR_1);
  RIP4(D,E,A,B,C,ZR_22,SR_22,YR_1);
  RIP4(C,D,E,A,B,ZR_23,SR_23,YR_1);
  RIP4(B,C,D,E,A,ZR_24,SR_24,YR_1);
  RIP4(A,B,C,D,E,ZR_25,SR_25,YR_1);
  RIP4(E,A,B,C,D,ZR_26,SR_26,YR_1);
  RIP4(D,E,A,B,C,ZR_27,SR_27,YR_1);
  RIP4(C,D,E,A,B,ZR_28,SR_28,YR_1);
  RIP4(B,C,D,E,A,ZR_29,SR_29,YR_1);
  RIP4(A,B,C,D,E,ZR_30,SR_30,YR_1);
  RIP4(E,A,B,C,D,ZR_31,SR_31,YR_1);

  RIP3(D,E,A,B,C,ZR_32,SR_32,YR_2);
  RIP3(C,D,E,A,B,ZR_33,SR_33,YR_2);
  RIP3(B,C,D,E,A,ZR_34,SR_34,YR_2);
  RIP3(A,B,C,D,E,ZR_35,SR_35,YR_2);
  RIP3(E,A,B,C,D,ZR_36,SR_36,YR_2);
  RIP3(D,E,A,B,C,ZR_37,SR_37,YR_2);
  RIP3(C,D,E,A,B,ZR_38,SR_38,YR_2);
  RIP3(B,C,D,E,A,ZR_39,SR_39,YR_2);
  RIP3(A,B,C,D,E,ZR_40,SR_40,YR_2);
  RIP3(E,A,B,C,D,ZR_41,SR_41,YR_2);
  RIP3(D,E,A,B,C,ZR_42,SR_42,YR_2);
  RIP3(C,D,E,A,B,ZR_43,SR_43,YR_2);
  RIP3(B,C,D,E,A,ZR_44,SR_44,YR_2);
  RIP3(A,B,C,D,E,ZR_45,SR_45,YR_2);
  RIP3(E,A,B,C,D,ZR_46,SR_46,YR_2);
  RIP3(D,E,A,B,C,ZR_47,SR_47,YR_2);

  RIP2(C,D,E,A,B,ZR_48,SR_48,YR_3);
  RIP2(B,C,D,E,A,ZR_49,SR_49,YR_3);
  RIP2(A,B,C,D,E,ZR_50,SR_50,YR_3);
  RIP2(E,A,B,C,D,ZR_51,SR_51,YR_3);
  RIP2(D,E,A,B,C,ZR_52,SR_52,YR_3);
  RIP2(C,D,E,A,B,ZR_53,SR_53,YR_3);
  RIP2(B,C,D,E,A,ZR_54,SR_54,YR_3);
  RIP2(A,B,C,D,E,ZR_55,SR_55,YR_3);
  RIP2(E,A,B,C,D,ZR_56,SR_56,YR_3);
  RIP2(D,E,A,B,C,ZR_57,SR_57,YR_3);
  RIP2(C,D,E,A,B,ZR_58,SR_58,YR_3);
  RIP2(B,C,D,E,A,ZR_59,SR_59,YR_3);
  RIP2(A,B,C,D,E,ZR_60,SR_60,YR_3);
  RIP2(E,A,B,C,D,ZR_61,SR_61,YR_3);
  RIP2(D,E,A,B,C,ZR_62,SR_62,YR_3);
  RIP2(C,D,E,A,B,ZR_63,SR_63,YR_3);

  RIP1(B,C,D,E,A,ZR_64,SR_64);
  RIP1(A,B,C,D,E,ZR_65,SR_65);
  RIP1(E,A,B,C,D,ZR_66,SR_66);
  RIP1(D,E,A,B,C,ZR_67,SR_67);
  RIP1(C,D,E,A,B,ZR_68,SR_68);
  RIP1(B,C,D,E,A,ZR_69,SR_69);
  RIP1(A,B,C,D,E,ZR_70,SR_70);
  RIP1(E,A,B,C,D,ZR_71,SR_71);
  RIP1(D,E,A,B,C,ZR_72,SR_72);
  RIP1(C,D,E,A,B,ZR_73,SR_73);
  RIP1(B,C,D,E,A,ZR_74,SR_74);
  RIP1(A,B,C,D,E,ZR_75,SR_75);
  RIP1(E,A,B,C,D,ZR_76,SR_76);
  RIP1(D,E,A,B,C,ZR_77,SR_77);
  RIP1(C,D,E,A,B,ZR_78,SR_78);
  RIP1(B,C,D,E,A,ZR_79,SR_79);

  D = RPMD_Array[RPMD_B] + c + D;
  RPMD_Array[RPMD_B] = RPMD_Array[RPMD_C] + d + E;
  RPMD_Array[RPMD_C] = RPMD_Array[RPMD_D] + e + A;
  RPMD_Array[RPMD_D] = RPMD_Array[RPMD_E] + a + B;
  RPMD_Array[RPMD_E] = RPMD_Array[RPMD_A] + b + C;
  RPMD_Array[RPMD_A] = D;
}

extern "C" void RMD160_Init(int* RPMD_Array)
{
  RPMD_Array[RPMD_A]   = RPMD160_A;
  RPMD_Array[RPMD_B]   = RPMD160_B;
  RPMD_Array[RPMD_C]   = RPMD160_C;
  RPMD_Array[RPMD_D]   = RPMD160_D;
  RPMD_Array[RPMD_E]   = RPMD160_E;
  RPMD_Array[RPMD_Nl]  = 0;
  RPMD_Array[RPMD_Nh]  = 0;
  RPMD_Array[RPMD_num] = 0;
}

extern "C" void RMD160_Update(int RPMD_Array[],
                              const char data[],
                              int Offset,
                              size_t len)
{  
  int i,j,ew,ec,sw,sc;
  int l;

  if (len == 0) return;				// check zero length

  //----------------------------------------------------------------
  // calulate new total B I T - length
  //----------------------------------------------------------------
  l = static_cast<int>(len << 3);					// get Bitcount
  ADD_64(RPMD_Array[RPMD_Nh],RPMD_Array[RPMD_Nl],l);// sum up

  i = Offset;					// Data-Array StartIndex
  if(RPMD_Array[RPMD_num] != 0)			// check for saved data in array

  {
    //=================================================================
    // stored data in array, fill up until RIPEMD-Block complete (16 longs)
    // or data exhausted
    //=================================================================
    sw = (int) ((((short) RPMD_Array[RPMD_num] & (0x7F)) >> 2)); // full longs
    sc = (int)   (RPMD_Array[RPMD_num] & 0x03);	       // and rem. bytes

    // NOTE: overflow will occur above 4 GByte - 64 Byte !! (> (2**31-1) - 64)

 
    if((RPMD_Array[RPMD_num] + len) >= RPMD_CBLOCK)
    {
      //---------------------------------------------------------------
      // enough data to complete array, do copy data to array,
      // generate Digest
      //---------------------------------------------------------------
      l = RPMD_Array[sw + RPMD_data];	// get address of next or incomplete
      char2longcx(data,l,sc,i);		// get required bytes
      RPMD_Array[sw + RPMD_data] = l;	// save to array
      sw++;				// to next location
      for (; sw < RPMD_LBLOCK; sw++)	// continue copying full longs
      {
        char2long(data,l,i);
        RPMD_Array[sw + RPMD_data] = l;
      }
      len -= (RPMD_CBLOCK - RPMD_Array[RPMD_num]);	// reduce length

      Ripemd160_Block(RPMD_Array);			// get digest
      RPMD_Array[RPMD_num] = 0;				// no data in array
      /* drop through and do the rest */
    }  

    else
    {
      //---------------------------------------------------------------
      // not enough data to complete array, do copy data to array only
      // and exit
      //---------------------------------------------------------------
      RPMD_Array[RPMD_num] += static_cast<int>(len);	// remaining bytes, always < 64
      if ((sc+ (int) len) < 4)		// cannot fill a full long
      {
        l = RPMD_Array[sw + RPMD_data];	// get saved bytes (if any)
        switch(sc)
        {
          case 0:					// no bytes saved
            l = ((int) data[i++] & 0xFF) << 24;	// save byte
            len--;
            if(len == 0) break;
          case 1:					// 1 byte saved
            l |= (((int) data[i++] & 0xFF) << 16);	// insert next
            len--;
            if(len == 0) break;
          case 2:					// 2 byte saved
            l |= (((int) data[i++] & 0xFF) << 8);	// insert next
            len--;
            if(len == 0) break;
          case 3:					// 3 byte saved
            l |= ((int) data[i++] & 0xFF);		// insert next
            break;
        }
        RPMD_Array[sw + RPMD_data] = l;	// save incomplete long
      }
      else
      {
        ew = (int) (RPMD_Array[RPMD_num] & 0xFF); // get ending byte count
        ec = ew & 0x03;				// incomplete ending byte count
        ew >>= 2;				// full longs for copy
        l = RPMD_Array[sw + RPMD_data];	// get saved bytes (if any)
        char2longcx(data,l,sc,i);	// insert bytes or copy full long
  	RPMD_Array[sw + RPMD_data] = l;	// save full long
        sw++;				// to next long

	for(; sw < ew; sw++)		// copy full longs
        {
          char2long(data,l,i);
          RPMD_Array[sw + RPMD_data] = l;
        }
        if(ec != 0)			// remaining bytes to copy into a long
        {
          char2long3n(data,l,ec,i);
          RPMD_Array[sw + RPMD_data] = l;
        }
      }
      return;				// exit, wait for more data
    }
  } // end of stored data preprocessing
  //=================================================================
  // no stored data in array, start storing data until filled up
  //=================================================================
  while (len >= RPMD_CBLOCK)		// only for full blocks
  {
    j = RPMD_data;			// index to Stored data
    for(sw=(RPMD_BLOCK/4);sw != 0; sw--)	// full long copy loop
    {
      char2long(data,l,i); RPMD_Array[j++] = l;
      char2long(data,l,i); RPMD_Array[j++] = l;
      char2long(data,l,i); RPMD_Array[j++] = l;
      char2long(data,l,i); RPMD_Array[j++] = l;
    }
    Ripemd160_Block(RPMD_Array);			// process Digest
    len -= RPMD_CBLOCK;				// subtract blocklength
  }
  //
  // calculate remaining longs and rest bytes/long
  //
  ec = (int) len;				// is always < SHA_BLOCK !!
  RPMD_Array[RPMD_num] = (int) ec & 0xFF;	// save remaining data bytes
  ew = ec >> 2;					// calculate full long count
  ec &= 0x03;					// get last remaining bytes

  sw = 0;					// index data field start
  for (; sw < ew; sw++)				// copy full longs if any
  {
    char2long(data,l,i);
    RPMD_Array[sw + RPMD_data] = l;
  }
  // next line was missing in original !!
  if(ec != 0)					// copy remaining bytes if any
  {
    char2long3n(data,l,ec,i);
    RPMD_Array[sw + RPMD_data] = l;
  } 

}

extern "C" void RMD160_Final(int* RPMD_Array,
				     char* Digest, int Offset)
{
  int i,j;
  int l;

  static unsigned char end[4] = {(unsigned char)0x80,(unsigned char)0x00,(unsigned char)0x00,(unsigned char)0x00};	// padding bytes array

  /* Array data should definitly have room for at least one more byte. */

  //---------------------------------------------------------------
  // Get stored long and remaining byte counts, append padding bits
  //---------------------------------------------------------------
  j = (int) RPMD_Array[RPMD_num];	// get stored BYTE count
  i = j >> 2;				// get full BIT32 count

  l = RPMD_Array[i+RPMD_data];		// get last stored long
  char2longcn(end,l,(j & 0x03));	// insert 1..4 padding bytes
  RPMD_Array[i+RPMD_data] = l;		// save full long
  i++;					// to next long (not yet loaded)
  //---------------------------------------------------------------
  // check if this block has room for length data (8 bytes)
  // if not fill with zeroes and generate Digest
  //---------------------------------------------------------------
  if (RPMD_Array[RPMD_num] >= RPMD_LAST_BLOCK)	// not enough room
  {
    for (; i<RPMD_LBLOCK; i++) RPMD_Array[i+RPMD_data] = 0; // zero data
    Ripemd160_Block(RPMD_Array);			// generate digest
    i = 0;					// set index back
  }
  //---------------------------------------------------------------
  // fill block with zeroes until position for length reached,
  // insert bitlength, generate final Digest
  //---------------------------------------------------------------
  for (; i<(RPMD_LBLOCK-2); i++) RPMD_Array[i+RPMD_data]=0; // clear

  RPMD_Array[RPMD_data+(RPMD_LBLOCK-1)] = RPMD_Array[RPMD_Nh]; // set length high
  RPMD_Array[RPMD_data+(RPMD_LBLOCK-2)] = RPMD_Array[RPMD_Nl]; // dto. low
  Ripemd160_Block(RPMD_Array);			// generate final digest
  //---------------------------------------------------------------
  // copy final digest to user buffer, clear RIPEMD Array (safety)
  //---------------------------------------------------------------
  l = RPMD_Array[RPMD_A]; long2charn(l,Digest,Offset+0);
  l = RPMD_Array[RPMD_B]; long2charn(l,Digest,Offset+4);
  l = RPMD_Array[RPMD_C]; long2charn(l,Digest,Offset+8);
  l = RPMD_Array[RPMD_D]; long2charn(l,Digest,Offset+12);
  l = RPMD_Array[RPMD_E]; long2charn(l,Digest,Offset+16);

  i = 0;					// index to array start
  do{RPMD_Array[i] = 0;i++;}while(i < RPMD_ARRAY_SIZE); // clear
}

/** @}*/

#endif //HL_ENCR_RMD
// end of file ../ripemd/rp.cpp


#ifdef HL_ENCR_RSA
/** @defgroup rsa RSA
* @brief RSA public key algorithm implementation
*
* This module implements RSA public encryption/decryption with RSAES-PKCS1-v1_5
* encryption scheme and RSA signature generation / checking with 
* RSASSA-PKCS1-v1_5 signature scheme. Additionally to the current standard, the
* hash algorithms RIPEMD 160 and SHA 224 are supported. Just for verification,
* old Blocktype 0 can be allowed. Encoding and padding is done according to
* PKCS1-v1_5 and verified during decryption.
*
* The module also includes RSA Key Generation routines.
*
* For all encryption and decryption functions, temporary copies of plaintext
* data are cleared before returning. Private key operations uses RSA Blinding
* to counter timing attacks, signatures are always verified after generation.
*
* The following modules are used:
* <ul>
*  <li> @ref rand "PRNG" for key generation and padding generation
*  <li> @ref lnum32 "Large number module" for large integer calculations
*  <li> @ref md2 "MD2" for MD2 hash functions
*  <li> @ref md5 "MD5" for MD5 hash functions
*  <li> @ref ripemd "RIPEMD 160" for RIPEMD 160 hash functions
*  <li> @ref sha1 "SHA1" for SHA1 hash functions
*  <li> @ref sha2 "SHA2" for SHA2 hash functions family
* </ul>
* @{
* @file
* This file implements RSA public/private encryption/decryption
* algorithm.
*
* See RSA PKCS-1 for description of algorithm.
*@}
*/
#include <stdlib.h>
#include <string.h>
#if (defined _WIN32) & (_MSC_VER < 1700)
#ifndef _STDINT
#define _STDINT
// MSVC lower than 17.00 does not have stdint.h, assure, all needed types are defined

typedef unsigned __int16 uint16_t;

typedef unsigned __int32 uint32_t;

typedef unsigned __int64 uint64_t;

#endif // !_STDINT
#else
#include <stdint.h>
#endif
#include <stddef.h>
#ifdef _WIN32
#define WIN32_LEAN_AND_MEAN
#include <Windows.h>
#undef WIN32_LEAN_AND_MEAN
#else// Define system-specific HL_* defines here
#ifndef HL_UNIX
#define HL_UNIX

#if (defined __gnu_linux__) || (defined __linux__)
#define HL_LINUX
#endif

#if (defined __APPLE__) && (defined __MACH__)
#define HL_LINUX
#define HL_MACOS
#endif

#ifdef _AIX
#define HL_AIX
#define HL_BIG_ENDIAN
#endif

#ifdef __FreeBSD__
#define HL_FREEBSD
#endif

#if (defined _hpux) || (defined hpux) || (defined __hpux)
#define HL_HPUX
#define HL_BIG_ENDIAN
#endif

#if (defined sun) || (defined __sun)
#define HL_SOLARIS
#endif

#if (defined __arm__) || (defined __aarch64__)
#define HL_LINUX_ARM
#endif

#ifdef __ANDROID__
#define HL_ANDROID
#endif

#endif
#include <hob-unix01.h>
#endif
#ifdef __APPLE__
/* We get target conditionals to keep apart Mac OS, iOS and iOS simulator.
   The conditionals are TARGET_IPHONE_SIMULATOR, TARGET_OS_IPHONE and TARGET_OS_MAC.
   TARGET_IPHONE_SIMULATOR has the highest priority, TARGET_OS_MAC the lowest.
   Always test, if the conditional is 1, as they will be defined as 0, if we 
   are not compiling for the target.
   */
#include <TargetConditionals.h>
#endif

#include "hob-encry-1.h"
#include "hob-encry-intern-1.h"

/** @addtogroup rsa
* @{
*/
/**
* Clears RSA data structure pointers (RSAClrPtrs). 
* The content of the pointers will not
* be modified!
*
*  @param rsa Pointer to structure
*/
static  void RSAClrPtrs(RSA_STRUC* rsa)
{
  //----------------------------------------------------------
  // invalidate pointers
  //----------------------------------------------------------
  rsa->Modul   = NULL;
  rsa->PubExp  = NULL;
  rsa->PrivExp = NULL;
  rsa->Prime_p = NULL;
  rsa->Prime_q = NULL;
  rsa->Dmodpm1 = NULL;
  rsa->Dmodqm1 = NULL;
  rsa->Invqmp  = NULL;
}

extern "C"  void RSA_Free(HMEM_CTX_DEF RSA_STRUC* rsa)
{
  if (rsa == NULL) return;
  //----------------------------------------------------------
  // clear stored values and free (if appropriate)
  //----------------------------------------------------------
  ClearFreeWLnum(HMEM_CTX_REF1 rsa->Modul);
  ClearFreeWLnum(HMEM_CTX_REF1 rsa->PubExp);
  ClearFreeWLnum(HMEM_CTX_REF1 rsa->PrivExp);
  ClearFreeWLnum(HMEM_CTX_REF1 rsa->Prime_p);
  ClearFreeWLnum(HMEM_CTX_REF1 rsa->Prime_q);
  ClearFreeWLnum(HMEM_CTX_REF1 rsa->Dmodpm1);
  ClearFreeWLnum(HMEM_CTX_REF1 rsa->Dmodqm1);
  ClearFreeWLnum(HMEM_CTX_REF1 rsa->Invqmp);
  //----------------------------------------------------------
  // invalidate pointers
  //----------------------------------------------------------
  RSAClrPtrs(rsa);
  FREE_CARRAY(HMEM_CTX_REF,rsa);
}

extern "C"  RSA_STRUC* RSA_New(HMEM_CTX_DEF
				   int nElementcnt,
				   int eElementcnt,
				   int dElementcnt,
				   int pElementcnt,
				   int qElementcnt)
{
//  int ok = 0;

  RSA_STRUC* rsa;

  //-------------------------------------------------
  // allocate new structure, clear pointers
  //-------------------------------------------------
  rsa = (RSA_STRUC *)
	  ((void *) BIT8_ARRAY_CALLOC(HMEM_CTX_REF,1,sizeof(RSA_STRUC)));
  if(rsa == NULL) return(NULL);
  //-------------------------------------------------
  // Allocate required number structures
  //-------------------------------------------------
  if(((rsa->Modul   = AllocNewWLnum(HMEM_CTX_REF1 nElementcnt)) == NULL) ||
     ((rsa->PubExp  = AllocNewWLnum(HMEM_CTX_REF1 eElementcnt)) == NULL) ||
     ((rsa->PrivExp = AllocNewWLnum(HMEM_CTX_REF1 dElementcnt)) == NULL) ||
     ((rsa->Prime_p = AllocNewWLnum(HMEM_CTX_REF1 pElementcnt)) == NULL) ||
     ((rsa->Prime_q = AllocNewWLnum(HMEM_CTX_REF1 qElementcnt)) == NULL) ||
     ((rsa->Dmodpm1 = AllocNewWLnum(HMEM_CTX_REF1 pElementcnt)) == NULL) ||
     ((rsa->Dmodqm1 = AllocNewWLnum(HMEM_CTX_REF1 qElementcnt)) == NULL) ||
     ((rsa->Invqmp  = AllocNewWLnum(HMEM_CTX_REF1 qElementcnt)) == NULL))
  {
    RSA_Free(HMEM_CTX_REF1 rsa);
    return(NULL);
  }
  return(rsa);
}

extern "C"  int RSA_Size(RSA_STRUC* rsa)
{
  if((rsa == NULL) || (rsa->Modul) == NULL)
    return(0);
  return(GetByteCntWLnum(rsa->Modul));
}

extern "C"  int RSA_BitSize(RSA_STRUC* rsa)
{
  int UsedSize;
  int * lpEl;

  if((rsa == NULL) || (rsa->Modul) == NULL) return(0);
  UsedSize = rsa->Modul->UsedSize;	// get used elements
  if(UsedSize == 0) return(0);			// none
  lpEl = rsa->Modul->lpEl;		// get pointer
  return(HardGetBitCntWLnumElem(lpEl[UsedSize-1]) +
	 ((UsedSize-1) * WELEMENT_SIZE * 8));
}
/**
* Checks if all parameters are present for chinese remainder calculation
* of the EXPMOD function (ChkExtRsaParamsPresent).
*
*  @param rsa Pointer to structure
*  @return == 0 - not all present
* <br>            != 0 all present
*/
static  int ChkExtRsaParamsPresent(RSA_STRUC* rsa)
{
  if ((rsa->Prime_p != NULL) &&			// prime p present
      (rsa->Prime_p->UsedSize != 0) &&	// not empty
      (rsa->Prime_q != NULL) &&			// prime q present
      (rsa->Prime_q->UsedSize != 0) &&	// not empty
      (rsa->Dmodpm1 != NULL) &&			// d mod(p-1) present
      (rsa->Dmodpm1->UsedSize != 0) &&	// not empty     
      (rsa->Dmodqm1 != NULL) &&			// d mod(q-1) present
      (rsa->Dmodqm1->UsedSize != 0) &&	// not empty
      (rsa->Invqmp  != NULL) &&			// q**-1 mod(p) present
      (rsa->Invqmp->UsedSize != 0))		// not empty
    return(1);
  return(0);
}
/**
* Performs modulo exponentation for private key processing using the
* chinese remainder theorem (RSA_ExpMod). Full base, modulus and exponent
* blinding is applied to (a**(d mod(p-1)) mod p and (b**(d mod(q-1)) mod q.
*
*  @param res Large number to take the result
*  @param u Large number holding the base
*  @param rsa RSA structure with the other required parameters
*  @return RSA_OP_OK on success, error code otherwise
*/
static  int RSA_ExpMod(HMEM_CTX_DEF
			WLARGENUM* res, WLARGENUM* u, RSA_STRUC* rsa)
{
  int i;

  int retcode  = RSA_FAST_EXPMOD_FAILURE;	// preset failure
  WLARGENUM* r1 = NULL;
  WLARGENUM* m1 = NULL;
  //------------------------------------------------------
  // to ease error handling we use a dummy FOR loop that will
  // terminate when an error is encountered. So all cleanup stuff
  // can be done at a central place
  //------------------------------------------------------
  //---------------------------------------------------------
  // allocate temporary large numbers
  //---------------------------------------------------------
  i  = rsa->Prime_p->UsedSize;	// get p size
  r1 = AllocNewWLnum(HMEM_CTX_REF1 i);	// get struc, preallocate
  m1 = AllocNewWLnum(HMEM_CTX_REF1 i);	// dto.
  if((m1 != NULL) && (r1 != NULL) &&		// Allocate fail detect
    //---------------------------------------------------------
    // calculate (a**(d mod(p-1)) mod p, (b**(d mod(q-1)) mod q
    //---------------------------------------------------------
					// r1 = u mod q
    (ModWLnum(HMEM_CTX_REF1 r1,u,rsa->Prime_q,NULL) == LNUM_OP_OK) &&
					// b = r1**(d mod(q-1)) mod q
    (m_exp_mod_blind(HMEM_CTX_REF1 m1,r1,rsa->Dmodqm1,rsa->Prime_q,NULL,(WLNUM_USE_BASE_BLINDING|WLNUM_USE_MOD_BLINDING|WLNUM_USE_EXP_BLINDING),NULL) == LNUM_OP_OK) &&

    (ModWLnum(HMEM_CTX_REF1 r1,u,rsa->Prime_p,NULL) == LNUM_OP_OK) &&

						// a = r1**(d mod(p-1)) mod p
    (m_exp_mod_blind(HMEM_CTX_REF1 res,r1,rsa->Dmodpm1,rsa->Prime_p,NULL,(WLNUM_USE_BASE_BLINDING|WLNUM_USE_MOD_BLINDING| WLNUM_USE_EXP_BLINDING),NULL) == LNUM_OP_OK) &&
						// a = a + p
    (AddWLnum(HMEM_CTX_REF1 r1,res,rsa->Prime_p) == LNUM_OP_OK) &&

						// a - b
    (SubWLnum(HMEM_CTX_REF1 res,r1,m1) == LNUM_OP_OK) &&
						// (a - b) * qinv
    (MulWLnum(HMEM_CTX_REF1 r1,res,rsa->Invqmp) == LNUM_OP_OK) &&

						// ((a-b) * qinv) mod p
    (ModWLnum(HMEM_CTX_REF1 res,r1,rsa->Prime_p,NULL) == LNUM_OP_OK) &&
						// (((a-b)*qinv)modp)*q
    (MulWLnum(HMEM_CTX_REF1 r1,res,rsa->Prime_q) == LNUM_OP_OK) &&
						// x=(((a-b)*qinv)modp)*q+b 
    (AddWLnum(HMEM_CTX_REF1 res,r1,m1) == LNUM_OP_OK))
      retcode=RSA_OP_OK;			// set o.k.

  FreeWLnum(HMEM_CTX_REF1 m1);
  FreeWLnum(HMEM_CTX_REF1 r1);
  return(retcode);
}	

extern "C"  int  RSA_PublicEncrypt(HMEM_CTX_DEF
					  char* MsgBuf, int MsgOff,
					  int  MsgLen,
					  char* DstBuf, int DstOff,
					  int*  pDstLen,
					  RSA_STRUC* rsa,
					  int ZeroFill)
{
  int i,j,k,num;
  int retcode = RSA_OP_OK;
  int tmpind = 0;

  char* Tmpbuf;

  WLARGENUM* f = NULL;
  WLARGENUM* ret = NULL;
  //------------------------------------------------------
  // check for correct message length (<= Modulus length -11)
  // and destination buffer size
  //------------------------------------------------------
  num = RSA_Size(rsa);			// get modulus length (must be >= 12)
  if (MsgLen > (num-11))		// check for correct blocklen
    return(RSA_PUBENC_DATA_TOO_LARGE);
  if(((ZeroFill == 0) && (pDstLen[0] <= num)) || // include leading zero
     ((ZeroFill != 0) && (pDstLen[0] < num)))	// no leading zero...
    return(RSA_PUBENC_KEY_SIZE_TOO_LARGE);
  //------------------------------------------------------
  // get temporary buffer/allocate
  //------------------------------------------------------
  if((Tmpbuf = BIT8_ARRAY_ALLOC(HMEM_CTX_REF,num)) == NULL)
    return(RSA_PUBENC_ALLOC_ERR);
  //------------------------------------------------------
  // to ease error handling we use a dummy FOR loop that will
  // terminate when an error is encountered. So all cleanup stuff
  // can be done at a central place
  //------------------------------------------------------
  for(;;)	
  {
    //==========================================================
    // 1. RSAES-PCKS1-v1_5 encoding of message
    //==========================================================
    Tmpbuf[tmpind++] = 0;			// Starting delimiter
    Tmpbuf[tmpind++] = 2;			// Blocktype(BT): public key

    j = num - MsgLen - 3;			// length of padding string

//    RAND_BYTES(RANDinst,Tmpbuf,tmpind,j);	// fill buffer with random
    retcode = SecDrbgRandBytes(HMEM_CTX_REF1 Tmpbuf,tmpind,j);
    if(retcode != 0)
    {
      retcode=RSA_PUBENC_RANDOM_GET_FAILURE;	// set reason
      break;
    }
    //-------------------------------------------------------------
    // assure there is no 0x00 character in the generated random data
    //-------------------------------------------------------------
    for (i=0; i<j; i++)
    {
      if(Tmpbuf[tmpind] == 0)			// found a zero, must replace
      {
        k = 1000;				// loop limit
        retcode = 0;
        do
        {
//        RAND_BYTES(RANDinst,Tmpbuf,tmpind,1);		// get other random byte
          retcode = SecDrbgRandBytes(HMEM_CTX_REF1 Tmpbuf,tmpind,1);
          if(retcode != 0)
            break;

          k--;					// reduce limiting counter

        }while((Tmpbuf[tmpind] == 0) && (k != 0));// until <> zero or limit
        if(retcode != 0)
        {
          retcode=RSA_PUBENC_RANDOM_GET_FAILURE;	// set reason
          break;
        }

        if(Tmpbuf[tmpind] == 0)			// timed out
        {
          retcode=RSA_PUBENC_RANDOM_GET_FAILURE;	// set reason
          break;
        }
      } // zero detected
      tmpind++;					// to next location
    } // for
    if(retcode != RSA_OP_OK)			// Error occured...
      break;
    //----------------------------------------------------------
    // append the data delimiter and the data octets
    //----------------------------------------------------------
    Tmpbuf[tmpind++] = 0;			// set data delimiter
    j = MsgOff;					// start of message data
    for(i=0;i<MsgLen;i++)
    {
      Tmpbuf[tmpind++] = MsgBuf[j++];		// append data byte
    }
    //==========================================================
    // 2. convert encryption block to integer (large number)
    //==========================================================
    f   = AllocNewWLnum(HMEM_CTX_REF1 (num + WELEMENT_SIZE-1)/WELEMENT_SIZE);// get a large number
    ret = AllocNewWLnum(HMEM_CTX_REF1 (num + WELEMENT_SIZE-1)/WELEMENT_SIZE);// dto.
    if((f == NULL) || (ret == NULL))		// no structure(s)
    {
      retcode = RSA_PUBENC_LNUM_ALLOC_ERR;	// set error reason
      break;
    }
    if(WLnum_bin2wlnum(HMEM_CTX_REF1 f,Tmpbuf,0,num) != LNUM_OP_OK) //to large number
    {
      retcode = RSA_PUBENC_BYTES_TO_LNUM_ERR;
      break;
    }
    //============================================================
    // 3. do RSA encryption
    //============================================================
    if(ExpModWLnum(HMEM_CTX_REF1 ret,f,rsa->PubExp,rsa->Modul,NULL,NULL) != LNUM_OP_OK)
    {
      retcode = RSA_PUBENC_EXPMOD_ERR;
      break;
    }  
    //============================================================
    // 4. convert encrypted integer (large number) back to byte string,
    //    insert leading Zeroes if necessary
    //============================================================
    if(ZeroFill != 0)
    {

      if(WLnum_wlnum2binFill(DstBuf,DstOff,pDstLen,ret,num) != LNUM_OP_OK) // convert to bytes
      {
        retcode = RSA_PUBENC_LNUM_TO_BYTES_ERR;
        break;
      }  
// for Testing only !!!!

//

    }
    else
    {
      if(WLnum_wlnum2bin(DstBuf,DstOff,pDstLen,ret,0) != LNUM_OP_OK) // convert to bytes
      {
        retcode = RSA_PUBENC_LNUM_TO_BYTES_ERR;
        break;
      }  
    }
    break;
  } // outmost for loop
  //------------------------------------------------------------------
  // clear sensitive data, free used buffers
  //------------------------------------------------------------------
  do{num--;Tmpbuf[num] = 0;}while(num != 0);	// clear sensitve data

  FREE_CARRAY(HMEM_CTX_REF,Tmpbuf);
  ClearFreeWLnum(HMEM_CTX_REF1 f);// clear/free large number
  FreeWLnum(HMEM_CTX_REF1 ret);			// result number, just free
  return(retcode);				// return
}

extern "C"  int RSA_PrivateEncryptEx(HMEM_CTX_DEF
					    char* InpBuf, int InpLen,
                   char* DstBuf, int DstOffset,
					    int* pDstLen,
					    RSA_STRUC* rsa,
					    int ZeroFlag)
{
  int i,num;
  int retcode = RSA_OP_OK;
  int tmpind = 0;

  char* Tmpbuf;
//  INTARRAY(lpi,1);

  WLARGENUM* f = NULL;
  WLARGENUM* ret = NULL;
  //------------------------------------------------------
  // check for correct message length (<= Modulus length -11)
  //------------------------------------------------------
					// get modulus length (must be >= 12)
  num = RSA_Size(rsa);
  if (InpLen > (num-11))		// check for correct blocklen
    return(RSA_PRIVENC_SRCDATA_TOO_LARGE);
  //------------------------------------------------------
  // check for correct destination buffer length
  //------------------------------------------------------
  if(pDstLen[0] < (num+1))		// buffer too small
    return(RSA_PRIVENC_DSTBUF_TOO_SMALL);
  //------------------------------------------------------
  // get temporary buffer/allocate
  //------------------------------------------------------
  if((Tmpbuf = BIT8_ARRAY_ALLOC(HMEM_CTX_REF,num)) == NULL)
    return(RSA_PRIVENC_ALLOC_ERR);
  //------------------------------------------------------
  // to ease error handling we use a dummy FOR loop that will
  // terminate when an error is encountered. So all cleanup stuff
  // can be done at a central place
  //------------------------------------------------------
  //==========================================================
  // 1. RSASSA-PKCS1-v1_5 encoding
  //==========================================================
  Tmpbuf[tmpind++] = 0;				// Starting delimiter
  Tmpbuf[tmpind++] = 1;				// Blocktype(BT): private key

  i = num - InpLen - 3;				// length of padding string
  for(;i != 0;i--)
    Tmpbuf[tmpind++] = (char) ((unsigned char) 0xFF);	// pad with 0xFF bytes
  //----------------------------------------------------------
  // append the data delimiter and the data octets
  //----------------------------------------------------------
  Tmpbuf[tmpind++] = 0;			// set data delimiter
  memcpy(Tmpbuf+tmpind,InpBuf+0,InpLen);
  //==========================================================
  // 2. convert encryption block to integer (large number)
  //==========================================================
  f   = AllocNewWLnum(HMEM_CTX_REF1 num);// get a large number
  ret = AllocNewWLnum(HMEM_CTX_REF1 num);// dto.
  if((f == NULL) || (ret == NULL))		// no structure(s)
    retcode = RSA_PRIVENC_LNUM_ALLOC_ERR;	// set error reason
  else
  {						 // convert to large number
    if(WLnum_bin2wlnum(HMEM_CTX_REF1 f,Tmpbuf,1,num-1) != LNUM_OP_OK)
      retcode = RSA_PRIVENC_BYTES_TO_LNUM_ERR;
  }
  //============================================================
  // 3. do RSA encryption; check if easier way possible
  //============================================================
  if(retcode == RSA_OP_OK)
  {
    if(ChkExtRsaParamsPresent(rsa) != 0)
    {
      if(RSA_ExpMod(HMEM_CTX_REF1 ret,f,rsa) != RSA_OP_OK)
        retcode = RSA_PRIVENC_FAST_EXPMOD_ERR;
    } // fast expmod
    else
    { // normal blinded exponentiation
      if(m_exp_mod_blind(HMEM_CTX_REF1 ret,f,rsa->PrivExp,rsa->Modul,NULL,(WLNUM_USE_BASE_BLINDING|WLNUM_USE_MOD_BLINDING| WLNUM_USE_EXP_BLINDING),NULL) != LNUM_OP_OK)
        retcode = RSA_PRIVENC_EXPMOD_ERR;
    }  
  }
  //============================================================
  // 4. convert encrypted integer (large number) back to byte string
  //============================================================
  if(retcode == RSA_OP_OK)
  {
    if(ZeroFlag >= 0)				// old mode
    {
      if(WLnum_wlnum2bin(DstBuf,DstOffset,pDstLen,ret,ZeroFlag) != LNUM_OP_OK)
        retcode = RSA_PRIVENC_LNUM_TO_BYTES_ERR;
    }
    else					// new mode, fill up
    {
      if(WLnum_wlnum2binFill(DstBuf,DstOffset,pDstLen,ret,num) != LNUM_OP_OK)
        retcode = RSA_PRIVENC_LNUM_TO_BYTES_ERR;
    }
  } // outmost for loop
  //------------------------------------------------------------------
  // clear sensitive data, free used buffers
  //------------------------------------------------------------------
  do{num--;Tmpbuf[num] = 0;}while(num != 0);	// clear sensitve data
  FREE_CARRAY(HMEM_CTX_REF,Tmpbuf);
  ClearFreeWLnum(HMEM_CTX_REF1 f);// clear/free large number
  FreeWLnum(HMEM_CTX_REF1 ret);			// result number, just free
  return(retcode);				// return
}

extern "C"  int RSA_PrivateEncrypt(HMEM_CTX_DEF
					  char* InpBuf, int InpLen,
                                          char* DstBuf, int DstOffset,
					  int* pDstLen,
					  RSA_STRUC* rsa,
					  int ZeroFlag)
{
  int NewZeroFlag = 0;

  if(ZeroFlag != 0)
    NewZeroFlag = 1;
  return(RSA_PrivateEncryptEx(HMEM_CTX_REF1
			      InpBuf, InpLen, DstBuf, DstOffset,
			      pDstLen, rsa, NewZeroFlag));
}

extern "C"  int RSA_PublicDecryptEx(HMEM_CTX_DEF
				  int Buflen, char* InpBuf,
				  int InputOffset,
                                  char* OutpBuf, int* pMsgLen,
                                  RSA_STRUC* rsa, int Flags)
{
  int i,j,num;
  int retcode = RSA_OP_OK;
  int tmpind = 0;

  char padvalue;

  char* Tmpbuf;
  int lpi[1];

  WLARGENUM* f = NULL;
  WLARGENUM* ret = NULL;
  //------------------------------------------------------
  // get temporary buffer/allocate
  //------------------------------------------------------
  num = RSA_Size(rsa);		// get modulus length (must be >= 12)
  if((Tmpbuf = BIT8_ARRAY_ALLOC(HMEM_CTX_REF,num)) == NULL)
    return(RSA_PUBDEC_ALLOC_ERR);
  //------------------------------------------------------
  // to ease error handling we use a dummy FOR loop that will
  // terminate when an error is encountered. So all cleanup stuff
  // can be done at a central place
  //------------------------------------------------------
  for(;;)	
  {
    //============================================================
    // 1. convert cipher text to integer (large number), check < n
    //============================================================
    f   = AllocNewWLnum(HMEM_CTX_REF1 num); // get a large number
    ret = AllocNewWLnum(HMEM_CTX_REF1 num); // dto.
    if((f == NULL) || (ret == NULL))		// no structure(s)
    {
      retcode = RSA_PUBDEC_LNUM_ALLOC_ERR;	// set error reason
      break;
    }
						// convert to large number
    if(WLnum_bin2wlnum(HMEM_CTX_REF1 f,InpBuf,InputOffset,Buflen) != LNUM_OP_OK)
    {
      retcode = RSA_PUBDEC_BYTES_TO_LNUM_ERR;
      break;
    }
    i = UcompWLnum(f,rsa->Modul); // check < n
    if(i != WLNUM_1ST_LT_2ND)
    {
      retcode = RSA_PUBDEC_SRCDATA_TOO_LARGE;
      break;
    }
    //============================================================
    // 2. do RSA decryption
    //============================================================
    if(ExpModWLnum(HMEM_CTX_REF1 ret,f,rsa->PubExp,rsa->Modul,NULL,NULL) != LNUM_OP_OK)
    {
      retcode = RSA_PUBDEC_EXPMOD_ERR;
      break;
    }  
    //============================================================
    // 3. convert decrypted integer (large number) back to byte string
    // NOTE: the leading zero will not appear in the output string
    //============================================================
    lpi[0] = num;				// size of buffer
    if(WLnum_wlnum2bin(Tmpbuf,0,lpi,ret,0) != LNUM_OP_OK) // convert to bytes
    {
      retcode = RSA_PUBDEC_LNUM_TO_BYTES_ERR;
      break;
    }  
    //============================================================
    // 4. check decrypted message block for PKCS1-v1_5 compliance, 
    //    Blocktypes 00 and 01 possible
    //    NOTE: SSL only allows Blocktype 0x01, but Certificates
    //    ----- might use Blocktype 0x00 !!
    //============================================================
    padvalue = 0;			// padding for type 0
    if((Tmpbuf[tmpind] != 0x00) &&	// not Blocktype (BT) 00
       (Tmpbuf[tmpind] != 0x01))	// not Blocktype (BT) 01
    {
      retcode = RSA_PUBDEC_BLOCKTYPE_NOT_00_01;
      break;
    }
    if((Tmpbuf[tmpind] == 0x00) && ((Flags & 0x01) != 0))
    {
      retcode = RSA_PUBDEC_BLOCKTYPE_NOT_01;	// TLS 1.1 requirement
      break;
    }

    if(Tmpbuf[tmpind++] == 0x01)	// must use alternate padding
      padvalue = (char) ((unsigned char) 0xFF);
    //------------------------------------------------------------
    // go over padding data
    //------------------------------------------------------------
    j=num-2;				// minus BT and leading 00 bef. data
    i = 0;
    do
    {
      if (Tmpbuf[tmpind] != padvalue)	// not a padding byte (00/FF)
        break;				// further checking required
      tmpind++;				// to next byte
      i++;				// to next
    }while(i < j);
    //------------------------------------------------------------
    // check if enough padding data and data delimiter are present
    //------------------------------------------------------------
    if(padvalue == (char) 0xFFu)		// type 1 processing
    {
      if (i == j)			// no data delimiter found
      {
        retcode = RSA_PUBDEC_NO_DATA_BLOCK_DELIM;
        break;
      }
      if(Tmpbuf[tmpind++] != 0)		// not a data delimiter (00)
      {
	retcode = RSA_PUBDEC_BAD_FF_HEADER;
	break;
      }
      i++;				// skip data delimiter
    }
    if (i < 9)				// too few padding bytes(inc. data del)
    {
      retcode = RSA_PUBDEC_BAD_PAD_BYTE_COUNT;
      break;
    }
    //============================================================
    // 5. copy data (if any) to output buffer
    //============================================================
    j = j - i;				// get remaining data length
    if(pMsgLen[0] < j)				// buffer too small
    {
      retcode = RSA_PUBDEC_DSTBUF_TOO_SMALL;
      break;
    }
    pMsgLen[0] = j;			// report output data count
    if(j > 0)
      memcpy(OutpBuf+0,Tmpbuf+tmpind,j);

    break;				// exit FOR loop
  } // outmost for loop
  //---------------------------------------------------
  // clear sensitive data
  //---------------------------------------------------
  do{num--;Tmpbuf[num]=0;}while(num != 0);

  FREE_CARRAY(HMEM_CTX_REF,Tmpbuf);				// free buffer
  FreeWLnum(HMEM_CTX_REF1 f);  // representation of cipher block, just free
  ClearFreeWLnum(HMEM_CTX_REF1 ret); //representation of plain text, clear

  return(retcode);
}

extern "C"  int RSA_PublicDecrypt(HMEM_CTX_DEF
				  int Buflen, char* InpBuf,
				  int InputOffset,
              char* OutpBuf, int* pMsgLen,
              RSA_STRUC* rsa)
{
  return(RSA_PublicDecryptEx(HMEM_CTX_REF1
			     Buflen, InpBuf, InputOffset,
                             OutpBuf, pMsgLen, rsa, 0));
}

extern "C"  int RSA_PrivateDecrypt(HMEM_CTX_DEF
				   char* InpBuf, int InpOff,
				   int Inplen,
                                   char* OutpBuf, int* pMsgLen,
                                   RSA_STRUC* rsa)
{
  int i,j,num;
  int retcode = RSA_OP_OK;
  int tmpind = 0;

  char* Tmpbuf;
  int lpi[1];

  WLARGENUM* f    = NULL;
  WLARGENUM* ret  = NULL;
  //------------------------------------------------------
  // get temporary buffer/allocate
  //------------------------------------------------------
  num = RSA_Size(rsa);			// get modulus length (must be >= 12)
  if((Tmpbuf = BIT8_ARRAY_ALLOC(HMEM_CTX_REF,num)) == NULL)// alloc buffer of modulus size
    return(RSA_PRIVDEC_ALLOC_ERR);
  //------------------------------------------------------
  // to ease error handling we use a dummy FOR loop that will
  // terminate when an error is encountered. So all cleanup stuff
  // can be done at a central place
  //------------------------------------------------------
  for(;;)	
  {
    //===============================================================
    // 1. convert cipher text to integer (large number), check if < n
    //===============================================================
    f    = AllocNewWLnum(HMEM_CTX_REF1 num); // get a large number
    ret  = AllocNewWLnum(HMEM_CTX_REF1 num); // dto.
    if((f == NULL) || (ret == NULL))			// no structure(s)
    {
      retcode = RSA_PRIVDEC_LNUM_ALLOC_ERR;	// set error reason
      break;
    }
						// convert to large number
    if(WLnum_bin2wlnum(HMEM_CTX_REF1 f,InpBuf,InpOff,Inplen) != LNUM_OP_OK)
    {
      retcode = RSA_PRIVDEC_BYTES_TO_LNUM_ERR;
      break;
    }
    i = UcompWLnum(f,rsa->Modul);	// check < n
    if(i != WLNUM_1ST_LT_2ND)
    {

      retcode = RSA_PRIVDEC_SRCDATA_TOO_LARGE;
      break;
    }
    retcode = LNUM_OP_OK;
    //============================================================
    // 2. do RSA decryption, check if easier way possible
    //============================================================
    if(ChkExtRsaParamsPresent(rsa) != 0)
    {
      if(RSA_ExpMod(HMEM_CTX_REF1 ret,f,rsa) != RSA_OP_OK)
      {
        retcode = RSA_PRIVDEC_FAST_EXPMOD_ERR;
        break;
      }  
    } // fast expmod
    else
    { // normal blinded decryption
      if(m_exp_mod_blind(HMEM_CTX_REF1 ret,f,rsa->PrivExp,rsa->Modul,NULL,(WLNUM_USE_BASE_BLINDING|WLNUM_USE_MOD_BLINDING| WLNUM_USE_EXP_BLINDING),NULL) != LNUM_OP_OK)
//      if(EXP_MOD_RECIP_LNUM(LNUMinst,ret,f,RSA_PrivExp(rsa),RSA_Modul(rsa)) !=
//	 LNUM_OP_OK)
      {
        retcode = RSA_PRIVDEC_EXPMOD_ERR;
        break;
      }  
    }  
    //============================================================
    // 3. convert decrypted integer (large number) back to byte string
    // NOTE: the leading zero will not appear in the output string
    //============================================================
    lpi[0] = num;				// size of buffer
						// convert to bytes
    if(WLnum_wlnum2bin(Tmpbuf,0,lpi,ret,0) != LNUM_OP_OK)
    {
      retcode = RSA_PRIVDEC_LNUM_TO_BYTES_ERR;
      break;
    }  
    //============================================================
    // 4. check decrypted message block for PKCS-v1_5 compliance, only Blocktype 02 valid
    //============================================================
    if(Tmpbuf[tmpind++] != 0x02)	// not Blocktype (BT) 02
    {
      retcode = RSA_PRIVDEC_BLOCKTYPE_NOT_02;
      break;
    }
    //------------------------------------------------------------
    // skip padding data
    //------------------------------------------------------------
    j=num-2;				// minus BT and leading 00 bef. data
    i = 0;
    do
    {
      if (Tmpbuf[tmpind++] == 00) break;// start of data found
      i++;				// to next
    }while(i < j);
    //------------------------------------------------------------
    // check if enough padding data/data delimiter present
    //------------------------------------------------------------
    if (i == j)				// no data delimiter found
    {
        retcode = RSA_PRIVDEC_NO_DATA_BLOCK_DELIM;
        break;
    }
    if (i < 8)				// too few padding bytes(excl. data del)
    {
      retcode = RSA_PRIVDEC_BAD_PAD_BYTE_COUNT;
      break;
    }
    i++;				// skip data delimiter
    //============================================================
    // 5. copy data (if any) to output buffer
    //============================================================
    j = j - i;				// get remaining data length
    if(pMsgLen[0] < j)				// buffer too small
    {
      retcode = RSA_PRIVDEC_DSTBUF_TOO_SMALL;
      break;
    }
    pMsgLen[0] = j;			// report output data count
    if(i > 0)
      memcpy(OutpBuf+0,Tmpbuf+tmpind,j);

    break;				// exit FOR loop
  } // outmost for loop
  //---------------------------------------------------
  // clear sensitive data
  //---------------------------------------------------
  do{num--;Tmpbuf[num]=0;}while(num != 0);

  FREE_CARRAY(HMEM_CTX_REF,Tmpbuf);			// free buffer
  FreeWLnum(HMEM_CTX_REF1 f);
  ClearFreeWLnum(HMEM_CTX_REF1 ret);

  return(retcode);
}
/** @} */
//----------------------------------------------------------------------
//BYTEARRAYI
unsigned char RSA_Def_MD_Sign_Hdr[RSA_DEF_MD_SIGN_HDR_LEN] =
  {(unsigned char) 0x30, (unsigned char) 0x20,			// Outer Sequence
     (unsigned char) 0x30, (unsigned char) 0x0C,			// Algoritm ID Sequence
       (unsigned char) 0x06, (unsigned char) 0x08, (unsigned char) 0x2A,	// Algoritm ObjID (RSA-PKCS1),
       (unsigned char) 0x86, (unsigned char) 0x48, (unsigned char) 0x86,
       (unsigned char) 0xF7,
          (unsigned char) 0x0D, (unsigned char) 0x02, (unsigned char) 0xFF,// MD2/MD5 digest Algorithm
       (unsigned char) 0x05, (unsigned char) 0x00,		// Algorithm-Params: NULL
    (unsigned char) 0x04, (unsigned char) 0x10			// OctetString: Digest(MD2/MD5)
};

//BIT8ARRAYI
unsigned char RSA_Def_SHA_Sign_Hdr[RSA_DEF_SHA_SIGN_HDR_LEN] =
  {(unsigned char) 0x30, (unsigned char) 0x21,			// Outer Sequence
     (unsigned char) 0x30, (unsigned char) 0x09,			// Algoritm ID Sequence
       (unsigned char) 0x06, (unsigned char) 0x05, (unsigned char) 0x2B,	// Algoritm ObjID (OIW),
       (unsigned char) 0x0E, (unsigned char) 0x03, (unsigned char) 0x02,
         (unsigned char) 0x1A,				// SHA1 digest Algorithm
       (unsigned char) 0x05, (unsigned char) 0x00,		// Algorithm-Params: NULL
     (unsigned char) 0x04, (unsigned char) 0x14			// OctetString: Digest(SHA1)
};

//BIT8ARRAYI
unsigned char RSA_Def_RIPEMD_Sign_Hdr[RSA_DEF_RIPEMD_SIGN_HDR_LEN] =
  {(unsigned char) 0x30, (unsigned char) 0x21,			// Outer Sequence
     (unsigned char) 0x30, (unsigned char) 0x09,			// Algoritm ID Sequence
       (unsigned char) 0x06, (unsigned char) 0x05, (unsigned char) 0x2B,	// Algoritm ObjID (TELESEC),
       (unsigned char) 0x24, (unsigned char) 0x03, (unsigned char) 0x02,
         (unsigned char) 0x01,				// RIPEMD Algorithm
       (unsigned char) 0x05, (unsigned char) 0x00,		// Algorithm-Params: NULL
     (unsigned char) 0x04, (unsigned char) 0x14			// Oct. Digest(RIPEMD160)
};

//BIT8ARRAYI
unsigned char RSA_Def_SHA2_Sign_Hdr[RSA_DEF_SHA2_SIGN_HDR_LEN] =
  {(unsigned char) 0x30, (unsigned char) 0xFF,			// Outer Sequence
     (unsigned char) 0x30, (unsigned char) 0x0D,			// Algorithm ID Sequence
       (unsigned char) 0x06, (unsigned char) 0x09, (unsigned char) 0x60,	// Algorithm ID (NIST),
       (unsigned char) 0x86, (unsigned char) 0x48, (unsigned char) 0x01,
       (unsigned char) 0x65, (unsigned char) 0x03, (unsigned char) 0x04,
       (unsigned char) 0x02, (unsigned char) 0xFF,		// SHA-2 Algors
     (unsigned char) 0x05, (unsigned char) 0x00,			// Algorithm-Params: NULL
   (unsigned char) 0x04, (unsigned char) 0xFF			// Oct. Digest (SHA-2)
};
/** @addtogroup rsa
* @{
*/
extern "C"  int RSA_signEx(HMEM_CTX_DEF
	  int DigestType,
	  char* MessageBuf,   int MsgBufOffset,     int MessageLen,
	  char* SignatureBuf, int SignatBufOffset,  int* pSignatureLen,
	  RSA_STRUC* rsa, int mode, int Flags)
{

  int i;
  int RetCode;
  int ModulusLen;
  int EncodedDigestLen;

  char* TmpBuf = NULL;
  char* TmpSignatBuf=NULL;

  int DigestState[MAX_DIGEST_STATE_LEN];
  long long DigestStateL[MAX_DIGEST_STATE_LEN];
  int DecodedDigestLen[1];
  
  //-----------------------------------------------------------
  // Get the RSA-Modulus length, check if modulus
  // and public or private exponent are present and have size <> 0,
  // check for correct signature buffer size
  //-----------------------------------------------------------
  if(rsa->Modul == NULL) return(RSA_SIG_PARAMS_MISSING);// no modulus ptr
  ModulusLen = RSA_Size(rsa);				// get modulus size
  if(ModulusLen == 0) return(RSA_SIG_PARAMS_MISSING);	// invalid size

  if(mode == 0)						// generate option
  {
    if((rsa->PrivExp == NULL) ||			// no pointer
       (rsa->PrivExp->UsedSize == 0))  	// no private exp.
      return(RSA_SIG_PARAMS_MISSING);
    if(pSignatureLen[0] < ModulusLen) return(RSA_SIG_DSTBUF_TOO_SMALL);
  }
  else							// verify option
  {  
    if((rsa->PubExp == NULL) ||			// no pointer
       (rsa->PubExp->UsedSize == 0))   	// no public exp.
      return(RSA_SIG_PARAMS_MISSING);
    i = pSignatureLen[0];				// get total length
    if(SignatureBuf[SignatBufOffset] == 0)		// leading zero case !
      i--;
    if(i > ModulusLen) return(RSA_SIG_INVALID_SIGNATURE_LEN);
  }
  //-----------------------------------------------------------
  // Allocate temporary buffer for signature generation:
  // length =   ASN1 headers   (max. 19 Bytes for SHA2)
  //          + Digest Buffer  (max. 64 Bytes for SHA512)
  //-----------------------------------------------------------
  if((TmpBuf = BIT8_ARRAY_ALLOC(HMEM_CTX_REF, RSA_MAX_SIGN_HDR_LEN +
			  RSA_MAX_DIGEST_LEN)) == NULL)
    return(RSA_SIG_TMP_ALLOC_ERR);
  //-----------------------------------------------------------
  // If Verify Mode requested, allocate Decrypted Signature
  // buffer of modulus length
  //-----------------------------------------------------------
  if(mode != 0)					// verify mode
  {
    if((TmpSignatBuf = BIT8_ARRAY_ALLOC(HMEM_CTX_REF,ModulusLen)) == NULL)
    {
      FREE_CARRAY(HMEM_CTX_REF,TmpBuf);		// free other buffer
      return(RSA_SIG_TMP_ALLOC_ERR);
    }
  }
  //-----------------------------------------------------------
  // set specific data according to the requested Message Digest,
  // generate the message digest with ASN.1 header
  //-----------------------------------------------------------
  switch(DigestType)
  {
    //---------------------------------------------------------
    // MD2 Digest requested, generate
    //---------------------------------------------------------
    case MD2_WITH_RSA_ALGOR:
      //-------------------------------------------------------
      // preload the Digest Header data, set MD2 Algorithm ID
      //-------------------------------------------------------
      memcpy(TmpBuf+0,RSA_Def_MD_Sign_Hdr+0,RSA_DEF_MD_SIGN_HDR_LEN);

      TmpBuf[RSA_DEF_MD_HDR_ALG_ID_IND] =	// insert Algor-ID (PKCS1)
         MD2_WITH_RSA_ALGOR_ID_BYTE;

      EncodedDigestLen = RSA_DEF_MD_SIGN_HDR_LEN+ // set Encoded total length
			 MD5_DIGEST_LEN;
      //-------------------------------------------------------
      // generate MD2 Message Digest
      //-------------------------------------------------------
      MD2_Init(DigestState);			// initialize State Array
							// generate Digest
      MD2_Update(DigestState,MessageBuf,MsgBufOffset,MessageLen);
							// store the digest
      MD2_Final(DigestState,TmpBuf,RSA_DEF_MD_SIGN_HDR_LEN);
      break;
    //---------------------------------------------------------
    // MD5 Digest requested, generate
    //---------------------------------------------------------
    case MD5_WITH_RSA_ALGOR:
      //-------------------------------------------------------
      // preload the Digest Header data, set MD5 Algorithm ID
      //-------------------------------------------------------
      memcpy(TmpBuf+0,RSA_Def_MD_Sign_Hdr+0,RSA_DEF_MD_SIGN_HDR_LEN);

      TmpBuf[RSA_DEF_MD_HDR_ALG_ID_IND] =	// insert Algor-ID (PKCS1)
         MD5_WITH_RSA_ALGOR_ID_BYTE;

      EncodedDigestLen = RSA_DEF_MD_SIGN_HDR_LEN+ // set Encoded total length
			 MD5_DIGEST_LEN;
      //-------------------------------------------------------
      // generate MD5 Message Digest
      //-------------------------------------------------------
      MD5_Init(DigestState);			// initialize State Array
							// generate Digest
      MD5_Update(DigestState,MessageBuf,MsgBufOffset,MessageLen);
							// store the digest
      MD5_Final(DigestState,TmpBuf,RSA_DEF_MD_SIGN_HDR_LEN);
      break;
    //---------------------------------------------------------
    // SHA1 Digest requested, generate
    //---------------------------------------------------------
    case SHA1_WITH_RSA_ALGOR:
      //-------------------------------------------------------
      // preload the Digest Header data, set compare data length
      //-------------------------------------------------------
      memcpy(TmpBuf+0,RSA_Def_SHA_Sign_Hdr+0,RSA_DEF_SHA_SIGN_HDR_LEN);

      EncodedDigestLen = RSA_DEF_SHA_SIGN_HDR_LEN+ // get Encoded total length
			 SHA1_DIGEST_LEN;
      //-------------------------------------------------------
      // generate SHA1 Message Digest
      //-------------------------------------------------------
      SHA1_Init(DigestState);			// initialize State Array
							// generate Digest
      SHA1_Update(DigestState,MessageBuf,MsgBufOffset,MessageLen);
							// store the digest
      SHA1_Final(DigestState,TmpBuf,RSA_DEF_SHA_SIGN_HDR_LEN);
      break;
    //---------------------------------------------------------
    // RIPEMD160 Digest requested, generate
    //---------------------------------------------------------
    case RIPEMD160_WITH_RSA_ALGOR:
      //-------------------------------------------------------
      // preload the Digest Header data, set compare data length
      //-------------------------------------------------------
      memcpy(TmpBuf+0,RSA_Def_RIPEMD_Sign_Hdr+0,RSA_DEF_RIPEMD_SIGN_HDR_LEN);

      EncodedDigestLen = RSA_DEF_RIPEMD_SIGN_HDR_LEN+ // get Encoded total length
			 RMD160_DIGEST_LEN;
      //-------------------------------------------------------
      // generate RIPEMD160 Message Digest
      //-------------------------------------------------------
      RMD160_Init(DigestState);		// initialize State Array
							// generate Digest
      RMD160_Update(DigestState,MessageBuf,MsgBufOffset,MessageLen);
							// store the digest
      RMD160_Final(DigestState,TmpBuf,RSA_DEF_RIPEMD_SIGN_HDR_LEN);
      break;
    //---------------------------------------------------------
    // SHA-256 Digest requested, generate
    //---------------------------------------------------------
    case SHA256_WITH_RSA_ALGOR:
      //--------------------------------------------------------------------
      // preload the Digest Header data, set SHA-256 Algorithm ID and length
      //--------------------------------------------------------------------
      memcpy(TmpBuf+0,RSA_Def_SHA2_Sign_Hdr+0,RSA_DEF_SHA2_SIGN_HDR_LEN);

      TmpBuf[RSA_DEF_SHA2_HDR_ALG_ID_IND] =	// insert Algor-ID (NIST)
         SHA256_WITH_RSA_ALGOR_ID_BYTE;
      TmpBuf[RSA_DEF_SHA2_HDR_HASHLEN_IND] =	// insert hash length
         SHA256_DIGEST_LEN;
      TmpBuf[RSA_DEF_SHA2_HDR_TOTLEN_IND] =	// insert total length
        RSA_DEF_SHA2_SIGN_HDR_LEN-2 + SHA256_DIGEST_LEN;

      EncodedDigestLen = RSA_DEF_SHA2_SIGN_HDR_LEN+ // set Encoded total length
			 SHA256_DIGEST_LEN;
      //-------------------------------------------------------
      // generate SHA-256 Message Digest
      //-------------------------------------------------------
      SHA256_Init(DigestState);		// initialize State Array
							// generate Digest
      SHA256_Update(DigestState,MessageBuf,MsgBufOffset,MessageLen);
							// store the digest
      SHA256_Final(DigestState,TmpBuf,RSA_DEF_SHA2_SIGN_HDR_LEN);
      break;
    //---------------------------------------------------------
    // SHA-384 Digest requested, generate
    //---------------------------------------------------------
    case SHA384_WITH_RSA_ALGOR:
      //--------------------------------------------------------------------
      // preload the Digest Header data, set SHA-384 Algorithm ID and length
      //--------------------------------------------------------------------
      memcpy(TmpBuf+0,RSA_Def_SHA2_Sign_Hdr+0,RSA_DEF_SHA2_SIGN_HDR_LEN);

      TmpBuf[RSA_DEF_SHA2_HDR_ALG_ID_IND] =	// insert Algor-ID (NIST)
         SHA384_WITH_RSA_ALGOR_ID_BYTE;
      TmpBuf[RSA_DEF_SHA2_HDR_HASHLEN_IND] =	// insert hash length
         SHA384_DIGEST_LEN;
      TmpBuf[RSA_DEF_SHA2_HDR_TOTLEN_IND] =	// insert total length
        RSA_DEF_SHA2_SIGN_HDR_LEN-2 + SHA384_DIGEST_LEN;

      EncodedDigestLen = RSA_DEF_SHA2_SIGN_HDR_LEN+ // set Encoded total length
			 SHA384_DIGEST_LEN;
      //-------------------------------------------------------
      // generate SHA-384 Message Digest
      //-------------------------------------------------------
      SHA384_Init(DigestStateL);		// initialize State Array
							// generate Digest
      SHA384_512_Update(DigestStateL,MessageBuf,MsgBufOffset,MessageLen);
							// store the digest
      SHA384_Final(DigestStateL,TmpBuf,RSA_DEF_SHA2_SIGN_HDR_LEN);
      break;
    //---------------------------------------------------------
    // SHA-512 Digest requested, generate
    //---------------------------------------------------------
    case SHA512_WITH_RSA_ALGOR:
      //--------------------------------------------------------------------
      // preload the Digest Header data, set SHA-512 Algorithm ID and length
      //--------------------------------------------------------------------
      memcpy(TmpBuf+0,RSA_Def_SHA2_Sign_Hdr+0,RSA_DEF_SHA2_SIGN_HDR_LEN);

      TmpBuf[RSA_DEF_SHA2_HDR_ALG_ID_IND] =	// insert Algor-ID (NIST)
         SHA512_WITH_RSA_ALGOR_ID_BYTE;
      TmpBuf[RSA_DEF_SHA2_HDR_HASHLEN_IND] =	// insert hash length
         SHA512_DIGEST_LEN;
      TmpBuf[RSA_DEF_SHA2_HDR_TOTLEN_IND] =	// insert total length
        RSA_DEF_SHA2_SIGN_HDR_LEN-2 + SHA512_DIGEST_LEN;

      EncodedDigestLen = RSA_DEF_SHA2_SIGN_HDR_LEN+ // set Encoded total length
			 SHA512_DIGEST_LEN;
      //-------------------------------------------------------
      // generate SHA-512 Message Digest
      //-------------------------------------------------------
      SHA512_Init(DigestStateL);		// initialize State Array
							// generate Digest
      SHA384_512_Update(DigestStateL,MessageBuf,MsgBufOffset,MessageLen);
							// store the digest
      SHA512_Final(DigestStateL,TmpBuf,RSA_DEF_SHA2_SIGN_HDR_LEN);
      break;
    //---------------------------------------------------------
    // SHA-224 Digest requested, generate
    //---------------------------------------------------------
    case SHA224_WITH_RSA_ALGOR:
      //--------------------------------------------------------------------
      // preload the Digest Header data, set SHA-224 Algorithm ID and length
      //--------------------------------------------------------------------
      memcpy(TmpBuf+0,RSA_Def_SHA2_Sign_Hdr+0,RSA_DEF_SHA2_SIGN_HDR_LEN);

      TmpBuf[RSA_DEF_SHA2_HDR_ALG_ID_IND] =	// insert Algor-ID (NIST)
         SHA224_WITH_RSA_ALGOR_ID_BYTE;
      TmpBuf[RSA_DEF_SHA2_HDR_HASHLEN_IND] =	// insert hash length
         SHA224_DIGEST_LEN;
      TmpBuf[RSA_DEF_SHA2_HDR_TOTLEN_IND] =	// insert total length
        RSA_DEF_SHA2_SIGN_HDR_LEN-2 + SHA224_DIGEST_LEN;

      EncodedDigestLen = RSA_DEF_SHA2_SIGN_HDR_LEN+ // set Encoded total length
			 SHA224_DIGEST_LEN;
      //-------------------------------------------------------
      // generate SHA-224 Message Digest
      //-------------------------------------------------------
      SHA224_Init(DigestState);		// initialize State Array
							// generate Digest
      SHA256_Update(DigestState,MessageBuf,MsgBufOffset,MessageLen);
							// store the digest
      SHA224_Final(DigestState,TmpBuf,RSA_DEF_SHA2_SIGN_HDR_LEN);
      break;

    //---------------------------------------------------------
    // unknown digest type
    //---------------------------------------------------------
    default:
      FREE_CARRAY(HMEM_CTX_REF,TmpBuf);
      FREE_CARRAY(HMEM_CTX_REF,TmpSignatBuf);
      return(RSA_SIG_UNKNOWN_ALGOR_TYPE);		// should not happen
  } // switch    
  //===========================================================
  // Distribute according to generate/verify mode
  //===========================================================
  if(mode == 0)					// generate
  {
    int ainl_tmp_len[1];
    //---------------------------------------------------------
    // RSA-encrypt the Encoded Message Digest and store it to user
    //---------------------------------------------------------
    RetCode = RSA_PrivateEncryptEx(HMEM_CTX_REF1
				 TmpBuf,EncodedDigestLen,
			         SignatureBuf,SignatBufOffset,
				 pSignatureLen,rsa,Flags);
    ainl_tmp_len[0] = pSignatureLen[0];
#ifdef __HIGH_SECURITY__
    for(i=0;i < EncodedDigestLen;i++) TmpBuf[i] = 0;	// clear encoded digest
#endif

    FREE_CARRAY(HMEM_CTX_REF,TmpBuf);			// free the buffer
    //-----------------------------------------------------------
    // Check the return-Code
    //-----------------------------------------------------------
    if(RetCode != RSA_OP_OK)
    {

      return(RSA_SIG_PRIV_ENCRYPT_ERR);
    }
    //-----------------------------------------------------------
    // Verify signature
    //-----------------------------------------------------------
    RetCode = RSA_signEx(HMEM_CTX_REF1 DigestType,
	  MessageBuf, MsgBufOffset, MessageLen,
	  SignatureBuf, SignatBufOffset,  ainl_tmp_len,
	  rsa, 1,1);
    if(RetCode != RSA_OP_OK)
    {
       return(RSA_SIG_VERIFY_FAILURE);
    }
    return(RetCode);
  }
  //-------------------------------------------------------------
  // Signature verify mode requested...
  //-------------------------------------------------------------
  else						// verify mode
  {
    //---------------------------------------------------------
    // RSA-decrypt the Encoded Message Digest and store it temporary
    //---------------------------------------------------------
    DecodedDigestLen[0] = ModulusLen;		// set DstBuf-Size

    RetCode = RSA_PublicDecryptEx(HMEM_CTX_REF1
				  pSignatureLen[0],SignatureBuf,
				  SignatBufOffset,
				  TmpSignatBuf,
				  DecodedDigestLen,
				  rsa,Flags);
    if(RetCode != RSA_OP_OK)				// decryption error
    {

      RetCode = RSA_SIG_PUBLIC_DECRYPT_ERR;	// set correct ret-code
    }     
    else
    {
      //---------------------------------------------------------
      // Compare the decrypted, encoded message signature to the
      // self generated encoded signature (Note: due to restricted
      // BER encoding [i.e. DER encoding] values must match 1:1,
      // but a leading ZERO byte is also accepted !)
      //---------------------------------------------------------
      RetCode =	RSA_SIG_VERIFY_FAILURE;			// assume compare error
      if(DecodedDigestLen[0] == EncodedDigestLen)	// same length
      {
        for(i=0;i<(int)DecodedDigestLen[0];i++)		// do compare
        {
          if(TmpSignatBuf[i] != TmpBuf[i]) break;	// compare error
        }
        if(i >= (int) DecodedDigestLen[0])		// o.k.
          RetCode = RSA_OP_OK;				// Verify o.k
      }
    }
#ifdef __HIGH_SECURITY__
    for(i=0;i < EncodedDigestLen;i++) TmpBuf[i] = 0;	// clear encoded digest
    for(i=0;i < ModulusLen;i++) TmpSignatBuf[i] = 0;	// dto.
#endif

    FREE_CARRAY(HMEM_CTX_REF,TmpBuf);			// free the buffer
    FREE_CARRAY(HMEM_CTX_REF,TmpSignatBuf);			// dto.

    return(RetCode);
  } // else Verify case
}

extern "C"  int RSA_sign(HMEM_CTX_DEF
	  int DigestType,
	  char* MessageBuf,   int MsgBufOffset,     int MessageLen,
	  char* SignatureBuf, int SignatBufOffset,  int* pSignatureLen,
	  RSA_STRUC* rsa, int mode)
{
  return(RSA_signEx(HMEM_CTX_REF1
                    DigestType, MessageBuf, MsgBufOffset, MessageLen,
	            SignatureBuf, SignatBufOffset, pSignatureLen,
		    rsa, mode, 0));
}

/** @} */


#endif //HL_ENCR_RSA
// end of file ../RSA/r6.cpp


#ifdef HL_ENCR_RSA
/** @addtogroup rsa
*@{
*@file
* This file implements RSA Key Generation in a manner, that the result
* is compliant to FIPS PUB 186-3 Appendix B 3.1. To assure this, the generation
* routine (or in several cases the used prime generation function) make the 
* following guarantees about the generated RSA parameters (nlen = size of 
* modulus):
* <ul>
* <li> q is larger than p.
* <li> p and q have a length of (nlen/2). Round up/down in case of odd nlen.
* <li> p and q are probable prime with error probability of at most 2^-100.
* <li> The two top bits are set for p and q, thus p,q >= (1.5)(2^(nlen/2-1)) > (sqrt(2))(2^(nlen/2-1))
* <li> |p-q| > 2^(nlen/2-100), meaning the topmost 100 bits are not identical.
* <li> (2^(nlen/2))<d< LCM((p-1)(q-1))
* <li> d= e^-1 mod(LCM((p-1)(q-1)))
* <li> e < 2^32(e is type int) < 2^256(FIPS limit)
*</ul>
*
* Note, that the last guarantee would only be invalidated, if the type int 
* would be larger, than 256 bit, which seems unlikely in the foreseeable future.
*
* Remaining requirements must be assured by the caller.
*@}
*/
#include <string.h>
#if (defined _WIN32) & (_MSC_VER < 1700)
#ifndef _STDINT
#define _STDINT
// MSVC lower than 17.00 does not have stdint.h, assure, all needed types are defined

typedef unsigned __int16 uint16_t;

typedef unsigned __int32 uint32_t;

typedef unsigned __int64 uint64_t;

#endif // !_STDINT
#else
#include <stdint.h>
#endif
#include <stddef.h>
#ifdef _WIN32
#define WIN32_LEAN_AND_MEAN
#include <Windows.h>
#undef WIN32_LEAN_AND_MEAN
#else// Define system-specific HL_* defines here
#ifndef HL_UNIX
#define HL_UNIX

#if (defined __gnu_linux__) || (defined __linux__)
#define HL_LINUX
#endif

#if (defined __APPLE__) && (defined __MACH__)
#define HL_LINUX
#define HL_MACOS
#endif

#ifdef _AIX
#define HL_AIX
#define HL_BIG_ENDIAN
#endif

#ifdef __FreeBSD__
#define HL_FREEBSD
#endif

#if (defined _hpux) || (defined hpux) || (defined __hpux)
#define HL_HPUX
#define HL_BIG_ENDIAN
#endif

#if (defined sun) || (defined __sun)
#define HL_SOLARIS
#endif

#if (defined __arm__) || (defined __aarch64__)
#define HL_LINUX_ARM
#endif

#ifdef __ANDROID__
#define HL_ANDROID
#endif

#endif
#include <hob-unix01.h>
#endif
#ifdef __APPLE__
/* We get target conditionals to keep apart Mac OS, iOS and iOS simulator.
   The conditionals are TARGET_IPHONE_SIMULATOR, TARGET_OS_IPHONE and TARGET_OS_MAC.
   TARGET_IPHONE_SIMULATOR has the highest priority, TARGET_OS_MAC the lowest.
   Always test, if the conditional is 1, as they will be defined as 0, if we 
   are not compiling for the target.
   */
#include <TargetConditionals.h>
#endif

#include "hob-encry-1.h"
#include "hob-encry-intern-1.h"

#define	RSA_STRONG_PRIMES   1
#define	RSA_WEAK_PRIMES     0

/** @addtogroup rsa
*@{
*/
extern "C"  RSA_STRUC* m_rsa_genkey_impl(HMEM_CTX_DEF int bits, int e_value,
                                         int inp_strength, void (*callback)(int))
{
  int retcode = LNUM_OP_OK;

  WLARGENUM* r0  = NULL;
  WLARGENUM* r1  = NULL;
  WLARGENUM* r2  = NULL;
  WLARGENUM* tmp;

//  int n=0;

  int elementcnt;
  int pelementcnt;
  int qelementcnt;

  int pbits,qbits;
  int shiftcnt,dbitcnt;

  RSA_STRUC* rsa = NULL;

  for(;;)					// error loop
  {
    //-------------------------------------------------------------
    // Allocate number structures
    //-------------------------------------------------------------
    elementcnt = (((bits+1)/2) + WELEMENT_BITS - 1)/WELEMENT_BITS + 1;
    r0 = AllocNewWLnum(HMEM_CTX_REF1 elementcnt);
    r1 = AllocNewWLnum(HMEM_CTX_REF1 elementcnt);
    r2 = AllocNewWLnum(HMEM_CTX_REF1 elementcnt);
    if((r0 == NULL) || (r1 == NULL) || (r2 == NULL))
    {
      retcode = LNUM_OP_ALLOC_ERR;
      break;
    }
    //-------------------------------------------------------------
    // get bits for p and q and element counts
    //-------------------------------------------------------------
    pbits = (bits + 1)/2;			// p bitcount
    qbits = bits - pbits;			// q bitcount
    pelementcnt = (((pbits+1)/2) + WELEMENT_BITS - 1)/WELEMENT_BITS + 1;
    qelementcnt = (((qbits+1)/2) + WELEMENT_BITS - 1)/WELEMENT_BITS + 1;
    shiftcnt = pbits - 100;			// upper 100 bits test shift
    if(shiftcnt < 0)
      shiftcnt = 0;
    dbitcnt = (bits + 1) / 2;			// d size test bitcount
    //-------------------------------------------------------------
    // allocate RSA-Structure and number structures
    //-------------------------------------------------------------
    rsa = RSA_New(HMEM_CTX_REF1 elementcnt,4,elementcnt,pelementcnt,qelementcnt);			// size of prime q
    if (rsa == NULL)
    {
      retcode = LNUM_OP_ALLOC_ERR;		// allocation error
      break;
    }
    //---------------------------------------------------------
    // store value e into the RSA-Structure
    //---------------------------------------------------------
    rsa->PubExp->lpEl[0] = e_value;
    rsa->PubExp->UsedSize = 1;		// set size
    //---------------------------------------------------------
    // generate p and q, retry loop
    //---------------------------------------------------------
    for(;;)
    {
      //----------------------------------------------------------
      // generate Prime p
      //----------------------------------------------------------
      for (;;)
      {
        retcode = GenPrimeWLnum(HMEM_CTX_REF1 rsa->Prime_p,pbits,0,0,inp_strength,NULL,callback);
        if(retcode != LNUM_OP_OK)
        {
//        printf("Failed to generate Prime number, RC=%d\n",retcode);
          break;
        }
        //-----------------------------------------------------------
        // check GCD(p-1,e) = 1 (as GCD((p-1)*(q-1),e) = 1 must hold)
        //-----------------------------------------------------------
							// copy number
        if((retcode = CopyWLnum(HMEM_CTX_REF1 r2,rsa->Prime_p)) != LNUM_OP_OK)
          break;
							// r2 = p - 1
        if((retcode = SubElementWLnum(r2,(int)1)) != LNUM_OP_OK)
          break;

							// r1 = ggT(e,p-1)
        if((retcode = GcdWLnum(HMEM_CTX_REF1 r1,r2,rsa->PubExp)) != LNUM_OP_OK)
          break;

        if(IsOneWLnum(r1) != 0)		// no common divisor
          break;
        //--------------------------------------------------------
        // prime p is not usable, get other one
        //--------------------------------------------------------
        if (callback != NULL)
          callback(3);					// not usable prime
      }
      if(retcode != LNUM_OP_OK)				// error occured...
        break;
      if(callback != NULL)
        callback(4);					// found first prime
      //----------------------------------------------------------
      // generate Prime q
      //----------------------------------------------------------
      for (;;)
      {
        retcode = GenPrimeWLnum(HMEM_CTX_REF1 rsa->Prime_q,qbits,0,0,RSA_WEAK_PRIMES,NULL,callback);
        if(retcode != LNUM_OP_OK)
          break;
        //-----------------------------------------------------------
        // check GCD(q-1,e) = 1 (as GCD((p-1)*(q-1),e) = 1 must hold)
        //-----------------------------------------------------------
							// copy number
        if((retcode = CopyWLnum(HMEM_CTX_REF1 r2,rsa->Prime_q)) != LNUM_OP_OK)
          break;

							// r2 = q - 1
        if((retcode = SubElementWLnum(r2,(unsigned char)1)) != LNUM_OP_OK)
          break;
							// r1 = ggT(e,q-1)
        if((retcode = GcdWLnum(HMEM_CTX_REF1 r1,r2,rsa->PubExp)) != LNUM_OP_OK)
          break;
        //--------------------------------------------------------
        // GCD(q-1,e) = 1, check if same prime as p
        //--------------------------------------------------------
        if(IsOneWLnum(r1) != 0)		// no common divisor
        {
          if(UcompWLnum(rsa->Prime_p,rsa->Prime_q) !=
             WLNUM_1ST_EQ_2ND) break;			// o.k.
        }
        //--------------------------------------------------------
        // prime q is not usable, get other one
        //--------------------------------------------------------
        if(callback != NULL)
          callback(3);					// not usable prime
      }
      if(retcode != LNUM_OP_OK) break;			// error occured...
      if(callback != NULL)
        callback(5);					// found 2nd prime
      //----------------------------------------------------------
      // if p < q we must exchange p and q
      //----------------------------------------------------------
      if(UcompWLnum(rsa->Prime_p,rsa->Prime_q) ==
         WLNUM_1ST_LT_2ND)					// p < q
      {
        tmp = rsa->Prime_p;				// exchange p,q
        rsa->Prime_p = rsa->Prime_q;
        rsa->Prime_q = tmp;
      }
      //----------------------------------------------------------
      // check if p and q differ in the upper 100 bits
      //----------------------------------------------------------
      if((retcode = SubWLnum(HMEM_CTX_REF1 r0,rsa->Prime_p,rsa->Prime_q)) != LNUM_OP_OK)
        break;
      if((retcode = RshiftWLnum(HMEM_CTX_REF1 r1,r0,shiftcnt)) != LNUM_OP_OK)
        break;

      if(IsZeroWLnum(r1) != 0)		// same upper 100 bits!
      {
        if(callback != NULL)
          callback(6);					// not usable prime
        continue;				// get another p,q pair!!
      }
      //----------------------------------------------------------
      // calculate n = p * q  and
      // d = e **(-1) mod ((p-1)*(q-1)), d mod (p-1), d mod (q-1)
      //----------------------------------------------------------
      if((retcode = MulWLnum(HMEM_CTX_REF1 rsa->Modul,rsa->Prime_p,rsa->Prime_q)) != LNUM_OP_OK)
        break;

      // calculate d
							// copy number
      if((retcode = CopyWLnum(HMEM_CTX_REF1 r1,rsa->Prime_p)) != LNUM_OP_OK)
        break;
							// r1 = p - 1
      if((retcode = SubElementWLnum(r1,(unsigned char)1)) != LNUM_OP_OK)
        break;

							// copy number
      if((retcode = CopyWLnum(HMEM_CTX_REF1 r2,rsa->Prime_q)) != LNUM_OP_OK)
        break;

							// r2 = q - 1
      if((retcode = SubElementWLnum(r2,(unsigned char)1)) != LNUM_OP_OK)
        break;

							// r0 = (p-1)*(q-1)
      if((retcode = MulWLnum(HMEM_CTX_REF1 r0,r1,r2)) != LNUM_OP_OK)
        break;

							// d
      if((retcode = InvModWLnum(HMEM_CTX_REF1 rsa->PrivExp,rsa->PubExp,r0,NULL)) != LNUM_OP_OK)
        break;
      //--------------------------------------------------------------------
      // Assert (2^nlen/2) < d < LCM(p-1,q-1)  and  1 = de mod(LCM(p-1,q-1))
      //--------------------------------------------------------------------
      if(GetBitCntWLnum(rsa->PrivExp) < dbitcnt)
      {
        if(callback != NULL)
          callback(6);					// not usable prime
        continue;				// get another p,q pair!!
      }
      // r0 = LCM((p-1),(q-1))
      if((retcode = m_lcm_wlnum(HMEM_CTX_REF1 r1,r2,r0)) != LNUM_OP_OK)
         break;
      
      if(UcompWLnum(rsa->PrivExp,r0) != WLNUM_1ST_LT_2ND)
      {
         if(callback != NULL)
          callback(6);					// not usable prime
        continue;				// get another p,q pair!!
      }
      // assert 1 = de mod(LCM(p-1,q-1))
      if((retcode = MulModWLnum(HMEM_CTX_REF1 r1,rsa->PubExp,rsa->PrivExp,r0,NULL)) != LNUM_OP_OK)
        break;

      if(IsOneWLnum(r1) == 0)
      {
         if(callback != NULL)
          callback(6);					// not usable prime
        continue;				// get another p,q pair!!
      }
      break; // retry FOR p,q search
    }
    if(retcode != LNUM_OP_OK)
      break;
    // Reset r1 to (p-1)
    if((retcode = CopyWLnum(HMEM_CTX_REF1 r1,rsa->Prime_p)) != LNUM_OP_OK)
        break;
    if((retcode = SubElementWLnum(r1,(unsigned char)1)) != LNUM_OP_OK)
        break;
    // calculate d mod (p-1)
    if((retcode = DivWLnum(HMEM_CTX_REF1 NULL,rsa->Dmodpm1,rsa->PrivExp,r1,NULL)) != LNUM_OP_OK)
      break;

    // calculate d mod (q-1)
    if((retcode = DivWLnum(HMEM_CTX_REF1 NULL,rsa->Dmodqm1,rsa->PrivExp,r2,NULL)) != LNUM_OP_OK)
      break;

    // calculate inverse of q mod p
    retcode = InvModWLnum(HMEM_CTX_REF1 rsa->Invqmp,rsa->Prime_q,rsa->Prime_p,NULL);
//    if(retcode != LNUM_OP_OK) break;		// not required, break follows
    break;
  } // error FOR loop

  if(retcode != LNUM_OP_OK)
  {

    RSA_Free(HMEM_CTX_REF1 rsa);
    rsa = NULL;
  }
  //----------------------------------------------------------
  // Output the prime numbers and parameters (for Test Purposes only)
  //----------------------------------------------------------

  FreeWLnum(HMEM_CTX_REF1 r0);
  FreeWLnum(HMEM_CTX_REF1 r1);
  FreeWLnum(HMEM_CTX_REF1 r2);
  return(rsa);
} // end of RSA_STRUC* RSA_GenKey_impl(...)

extern "C"  RSA_STRUC* RSA_GenKey(HMEM_CTX_DEF int bits, int e_value,
              		  	      void (*callback)(int))
{
  return(m_rsa_genkey_impl(HMEM_CTX_REF1 bits, e_value,
                           RSA_WEAK_PRIMES, callback));
} // end of RSA_GenKey(...)
/** @} */


#endif //HL_ENCR_RSA
// end of file ../RSA/r7.cpp


#ifdef HL_ENCR_HMAC
/** @defgroup hmac HMAC
* This module implements the HMAC keyed hashing for message authentication as
* described in RFC 2104.
*
* Currently, HMAC supports the following underlying hash functions, also
* using their respective modules:
*<ul>
*  <li> @ref md5 "MD5"
*  <li> @ref sha1 "SHA1"
*  <li> @ref ripemd "RIPEMD 160"
*  <li> @ref sha2 "SHA2"
*</ul>
*
* Additionally to normal generation over a single buffer, a function for
* generating a HMAC over a list of gather structures is provided.
*
* @{
* @file
* This is the C source for the HMAC module.
* @}
*/
#include <string.h>
#if (defined _WIN32) & (_MSC_VER < 1700)
#ifndef _STDINT
#define _STDINT
// MSVC lower than 17.00 does not have stdint.h, assure, all needed types are defined

typedef unsigned __int16 uint16_t;

typedef unsigned __int32 uint32_t;

typedef unsigned __int64 uint64_t;

#endif // !_STDINT
#else
#include <stdint.h>
#endif
#include <stddef.h>
#ifdef _WIN32
#define WIN32_LEAN_AND_MEAN
#include <Windows.h>
#undef WIN32_LEAN_AND_MEAN
#else// Define system-specific HL_* defines here
#ifndef HL_UNIX
#define HL_UNIX

#if (defined __gnu_linux__) || (defined __linux__)
#define HL_LINUX
#endif

#if (defined __APPLE__) && (defined __MACH__)
#define HL_LINUX
#define HL_MACOS
#endif

#ifdef _AIX
#define HL_AIX
#define HL_BIG_ENDIAN
#endif

#ifdef __FreeBSD__
#define HL_FREEBSD
#endif

#if (defined _hpux) || (defined hpux) || (defined __hpux)
#define HL_HPUX
#define HL_BIG_ENDIAN
#endif

#if (defined sun) || (defined __sun)
#define HL_SOLARIS
#endif

#if (defined __arm__) || (defined __aarch64__)
#define HL_LINUX_ARM
#endif

#ifdef __ANDROID__
#define HL_ANDROID
#endif

#endif
#include <hob-unix01.h>
#endif
#ifdef __APPLE__
/* We get target conditionals to keep apart Mac OS, iOS and iOS simulator.
   The conditionals are TARGET_IPHONE_SIMULATOR, TARGET_OS_IPHONE and TARGET_OS_MAC.
   TARGET_IPHONE_SIMULATOR has the highest priority, TARGET_OS_MAC the lowest.
   Always test, if the conditional is 1, as they will be defined as 0, if we 
   are not compiling for the target.
   */
#include <TargetConditionals.h>
#endif

#include "hob-encry-1.h"
#include "hob-encry-intern-1.h"
#include "hob-encry-err-1.h"

/** @addtogroup hmac
*@{
*/
/**
* Xors array content with given value (XorBit8Array).
*
*  @param pBuf Array Base
*  @param BufOff Start of Data
*  @param BufLen Size of Data
*  @param Value Value for XOR (Low Byte)
*/
static void XorBit8Array(char pBuf[], int BufOff, size_t BufLen,
				      int Value)
{
  if((pBuf != NULL) && (BufLen > 0))
  {
    while(BufLen != 0)
    {
      pBuf[BufOff++] ^= (unsigned char) Value;
      BufLen--;
    }
  }
}

/**
Wrapper function for SHA384_Init, allowing the use of an int array as state.

@param ainp_state State array to be initialized.
*/
static void m_sha384_init(int* ainp_state){
   SHA384_Init((long long*)ainp_state);
}

/**
Wrapper function for SHA512_Init, allowing the use of an int array as state.

@param ainp_state State array to be initialized.
*/
static void m_sha512_init(int* ainp_state){
   SHA512_Init((long long*)ainp_state);
}

/**
Wrapper function for SHA384_512_Update, allowing the use of an int array as state.

@param ainp_state    State array to be used.
@param achp_data     Data buffer to be added.
@param inp_offset    Offset of the data in the data buffer.
@param inp_data_len  Length of data to be added.
*/
static void m_sha384_512_update(int* ainp_state, 
                                const char* achp_data, 
                                int inp_offset, 
                                size_t inp_data_len)
{
   SHA384_512_Update((long long*)ainp_state, achp_data, inp_offset, inp_data_len);
}

/**
Wrapper function for SHA384_Final, allowing the use of an int array as state.

@param ainp_state State array to be used.
@param achp_dest  Destination array to write the hash to.
@param inp_offset Offset to start writing.
*/
static void m_sha384_final(int* ainp_state, 
                                char* achp_dest, 
                                int inp_offset)
{
   SHA384_Final((long long*)ainp_state, achp_dest, inp_offset);
}

/**
Wrapper function for SHA512_Final, allowing the use of an int array as state.

@param ainp_state State array to be used.
@param achp_dest  Destination array to write the hash to.
@param inp_offset Offset to start writing.
*/
static void m_sha512_final(int* ainp_state, 
                                char* achp_dest, 
                                int inp_offset)
{
   SHA512_Final((long long*)ainp_state, achp_dest, inp_offset);
}

extern "C" int GenHMAC(const char pKeyData[], 
                       int KeyDataOff, 
                       size_t KeyDataLen,
                       const char pHashData[], 
                       int HashDataOff,
                       size_t HashDataLen,
                       int HashType,
                       char pDstBuf[],
                       int DstOff, 
                       int pDstLen[])
{
  size_t HashLen, KeyLen;
  size_t szl_real_block_len = HMAC_BLOCK_LEN;

  char KeyBuffer[HMAC_BLOCK_LEN*2];
  char DigestBuffer[HMAC_MAX_DIGEST_LEN];
  int HashArray[HMAC_MAX_HASH_ARRAY_SIZE*2];
  
  void (*am_hash_init) (int* ainp_state);
  void (*am_hash_update) (int* ainp_state, const char* achp_data, int inp_offset, size_t szp_data_len);
  void (*am_hash_final) (int* ainp_state, char* achp_dest, int inp_offset);

  //-------------------------------------------------------
  // Check parameters
  //-------------------------------------------------------
  if((pKeyData == NULL) || (pHashData == NULL) ||
     (pDstBuf == NULL) || (pDstLen == NULL))
    return(HMAC_NULL_PTR);

  if(pDstLen[0] < 0)
    return(HMAC_PARAM_ERR);
  
  size_t DstBufLen = (size_t)(pDstLen[0]);
  // Set Hash and block length and hash function pointers according to hash type
  switch(HashType){
      case HMAC_MD5_ID:
        HashLen = MD5_DIGEST_LEN;
        am_hash_init = MD5_Init;
        am_hash_update = MD5_Update;
        am_hash_final = MD5_Final;
        break;
      case HMAC_SHA1_ID:
        HashLen = SHA_DIGEST_LEN;
        am_hash_init = SHA1_Init;
        am_hash_update = SHA1_Update;
        am_hash_final = SHA1_Final;
        break;
      case HMAC_RMD160_ID:
        HashLen = RMD160_DIGEST_LEN;
        am_hash_init = RMD160_Init;
        am_hash_update = RMD160_Update;
        am_hash_final = RMD160_Final;
        break;
      case HMAC_SHA256_ID:
        HashLen = SHA256_DIGEST_LEN;
        am_hash_init = SHA256_Init;
        am_hash_update = SHA256_Update;
        am_hash_final = SHA256_Final;
        break;
      case HMAC_SHA384_ID:
        HashLen = SHA384_DIGEST_LEN;
        am_hash_init = m_sha384_init;
        am_hash_update = m_sha384_512_update;
        am_hash_final = m_sha384_final;
        szl_real_block_len *=2;
        break;
      case HMAC_SHA512_ID:
        HashLen = SHA512_DIGEST_LEN;
        am_hash_init = m_sha512_init;
        am_hash_update = m_sha384_512_update;
        am_hash_final = m_sha512_final;
        szl_real_block_len *=2;
        break;
      default:
        return(HMAC_PARAM_ERR);
  }

  if(DstBufLen < HashLen)
    return(HMAC_DST_BUFFER_TOO_SMALL);

  //-------------------------------------------------------
  // Generate the Key buffer from Key
  //-------------------------------------------------------
  if(KeyDataLen > szl_real_block_len)
  {
    //-----------------------------------------------------
    // Must shrink the Key down
    //-----------------------------------------------------
    am_hash_init(HashArray);
    am_hash_update(HashArray,pKeyData,KeyDataOff,KeyDataLen);
    am_hash_final(HashArray,KeyBuffer,0);
    KeyLen = HashLen;
  }
  else
  {
    memcpy(KeyBuffer,pKeyData+KeyDataOff,KeyDataLen);
    KeyLen = KeyDataLen;
  }
  //--------------------------------------------------------
  // Pad the Key with 0x00 till Blocksize is reached
  //--------------------------------------------------------
  memset(KeyBuffer+KeyLen,0,szl_real_block_len - KeyLen);

  //--------------------------------------------------------
  // XOR the Key buffer with IPAD (0x36)
  //--------------------------------------------------------
  XorBit8Array(KeyBuffer, 0, szl_real_block_len, HMAC_IPAD);

  //--------------------------------------------------------
  // Build hash from concatenation of Xored Key and Data
  //--------------------------------------------------------
  am_hash_init(HashArray);
  am_hash_update(HashArray,KeyBuffer,0,szl_real_block_len);
  am_hash_update(HashArray,pHashData,HashDataOff,HashDataLen);
  am_hash_final(HashArray,DigestBuffer,0);
  
  //--------------------------------------------------------
  // XOR the Key buffer with OPAD (0x5C)
  //--------------------------------------------------------
  XorBit8Array(KeyBuffer, 0, szl_real_block_len, HMAC_IPAD ^ HMAC_OPAD);
  
  //-----------------------------------------------------------
  // Build hash from concatenation of padded key and Inner Hash
  //-----------------------------------------------------------
  am_hash_init(HashArray);
  am_hash_update(HashArray,KeyBuffer,0,szl_real_block_len);
  am_hash_update(HashArray,DigestBuffer,0,HashLen);
  am_hash_final(HashArray,pDstBuf,DstOff);
  
  memset(KeyBuffer,0,szl_real_block_len);
  memset(DigestBuffer,0,HMAC_MAX_DIGEST_LEN);
  memset(HashArray,0,HMAC_MAX_HASH_ARRAY_SIZE*8);

  pDstLen[0] = static_cast<int>(HashLen);
  return(HMAC_OP_OK);
}

extern "C" int GenHMACGath(const char pKeyData[], 
                           int KeyDataOff, 
                           size_t KeyDataLen, 
                           const struct dsd_gather_i_1* ads_gath,
                           int HashType, 
                           char pDstBuf[],
                           int DstOff,
                           int pDstLen[])
{
  size_t HashLen, KeyLen;
  const struct dsd_gather_i_1* ads_curr = ads_gath;
  size_t szl_real_block_len = HMAC_BLOCK_LEN;

  char KeyBuffer[HMAC_BLOCK_LEN*2];
  char DigestBuffer[HMAC_MAX_DIGEST_LEN];
  int HashArray[HMAC_MAX_HASH_ARRAY_SIZE*2];

  void (*am_hash_init) (int* ainp_state);
  void (*am_hash_update) (int* ainp_state, const char* achp_data, int inp_offset, size_t szp_data_len);
  void (*am_hash_final) (int* ainp_state, char* achp_dest, int inp_offset);

  //-------------------------------------------------------
  // Check parameters
  //-------------------------------------------------------
  if((pKeyData == NULL) || (ads_gath== NULL) ||
     (pDstBuf == NULL) || (pDstLen == NULL))
    return(HMAC_NULL_PTR);

  if(pDstLen[0] < 0)
    return(HMAC_PARAM_ERR);
  
  size_t DstBufLen = (size_t)(pDstLen[0]);
  // Ensure proper input was given
  while(ads_curr)
  {
      if (ads_curr->achc_ginp_end < ads_curr->achc_ginp_cur)
          return(HMAC_PARAM_ERR);
      ads_curr = ads_curr->adsc_next;
  }
  ads_curr = ads_gath;

  // Set Hash and block length and hash function pointers according to hash type
  switch(HashType){
      case HMAC_MD5_ID:
        HashLen = MD5_DIGEST_LEN;
        am_hash_init = MD5_Init;
        am_hash_update = MD5_Update;
        am_hash_final = MD5_Final;
        break;
      case HMAC_SHA1_ID:
        HashLen = SHA_DIGEST_LEN;
        am_hash_init = SHA1_Init;
        am_hash_update = SHA1_Update;
        am_hash_final = SHA1_Final;
        break;
      case HMAC_RMD160_ID:
        HashLen = RMD160_DIGEST_LEN;
        am_hash_init = RMD160_Init;
        am_hash_update = RMD160_Update;
        am_hash_final = RMD160_Final;
        break;
      case HMAC_SHA256_ID:
        HashLen = SHA256_DIGEST_LEN;
        am_hash_init = SHA256_Init;
        am_hash_update = SHA256_Update;
        am_hash_final = SHA256_Final;
        break;
      case HMAC_SHA384_ID:
        HashLen = SHA384_DIGEST_LEN;
        am_hash_init = m_sha384_init;
        am_hash_update = m_sha384_512_update;
        am_hash_final = m_sha384_final;
        szl_real_block_len *=2;
        break;
      case HMAC_SHA512_ID:
        HashLen = SHA512_DIGEST_LEN;
        am_hash_init = m_sha512_init;
        am_hash_update = m_sha384_512_update;
        am_hash_final = m_sha512_final;
        szl_real_block_len *=2;
        break;
      default:
        return(HMAC_PARAM_ERR);
  }

  if(DstBufLen < HashLen)
    return(HMAC_DST_BUFFER_TOO_SMALL);

  //-------------------------------------------------------
  // Generate the Key buffer from Key
  //-------------------------------------------------------
  if(KeyDataLen > szl_real_block_len)
  {
    //-----------------------------------------------------
    // Must shrink the Key down
    //-----------------------------------------------------
    am_hash_init(HashArray);
    am_hash_update(HashArray,pKeyData,KeyDataOff, KeyDataLen);
    am_hash_final(HashArray,KeyBuffer,0);
    KeyLen = HashLen;
  }
  else
  {
    memcpy(KeyBuffer,pKeyData+KeyDataOff,KeyDataLen);
    KeyLen = KeyDataLen;
  }
  //--------------------------------------------------------
  // Pad the Key with 0x00 till Blocksize is reached
  //--------------------------------------------------------
  memset(KeyBuffer+KeyLen,0,szl_real_block_len - KeyLen);
  //--------------------------------------------------------
  // XOR the Key buffer with IPAD (0x36)
  //--------------------------------------------------------
  XorBit8Array(KeyBuffer, 0, szl_real_block_len, HMAC_IPAD);

  //--------------------------------------------------------
  // Build hash from concatenation of Xored Key and Data
  //--------------------------------------------------------
  am_hash_init(HashArray);
  am_hash_update(HashArray,KeyBuffer,0,szl_real_block_len);

  while (ads_curr)
  {
     am_hash_update(HashArray,ads_curr->achc_ginp_cur,0,
        (int)(ads_curr->achc_ginp_end - ads_curr->achc_ginp_cur));
     ads_curr = ads_curr->adsc_next;
  }

  am_hash_final(HashArray,DigestBuffer,0);

  //--------------------------------------------------------
  // XOR the Key buffer with OPAD (0x5C)
  //--------------------------------------------------------
  XorBit8Array(KeyBuffer, 0, szl_real_block_len, HMAC_IPAD ^ HMAC_OPAD);
  
  //-----------------------------------------------------------
  // Build hash from concatenation of padded key and Inner Hash
  //-----------------------------------------------------------
  am_hash_init(HashArray);
  am_hash_update(HashArray,KeyBuffer,0,szl_real_block_len);
  am_hash_update(HashArray,DigestBuffer,0,HashLen);
  am_hash_final(HashArray,pDstBuf,DstOff);

  memset(KeyBuffer,0,szl_real_block_len);
  memset(DigestBuffer,0,HMAC_MAX_DIGEST_LEN);
  memset(HashArray,0,HMAC_MAX_HASH_ARRAY_SIZE*8);

  pDstLen[0] = static_cast<int>(HashLen);
  return(HMAC_OP_OK);
}

/** @} */

#endif //HL_ENCR_HMAC
// end of file ../hmac/Hmac.cpp


#ifdef HL_ENCR_DSA

/** @defgroup dsa_dh DSA/DH
*  This module implements the DSA signature algorithm, the
*  DH X9.42 Key exchange algorithm and
*  (combined) DSA/DH parameter generation routines.
* 
*  See US Standards FIPS PUB 186(-1) for description of DSA algorithm
*  and DSA parameter generation.
*  See RSA PKCS-3 for description of DH algorithm.
*  See draft-ietf-smime-X942-076.txt for DH parameter generation.
* 
*  Can be compiled both for C (16 Bit / 32 Bit) and JAVA.
*
*  It depends on the following modules:
* <ul>
* <li> @ref lnum32 "Large number routines"
* <li> @ref rand "Pseudo random generator routines"
* <li> @ref sha1 "SHA-1" hash routines
* </ul> 
*  DSA Original version from Steven Schoch <schoch@sheba.arc.nasa.gov>
*
*  Several functions allow an optional callback routine, that will be called
*  periodically (about 1 sec interval). This can be used for status / progress
*  bar update if desired.
*  @{
*  @file
* This file contains the implementation for all DSA and DH functions.
*  @}
*/
#include <stdlib.h>
#include <string.h>
#if (defined _WIN32) & (_MSC_VER < 1700)
#ifndef _STDINT
#define _STDINT
// MSVC lower than 17.00 does not have stdint.h, assure, all needed types are defined

typedef unsigned __int16 uint16_t;

typedef unsigned __int32 uint32_t;

typedef unsigned __int64 uint64_t;

#endif // !_STDINT
#else
#include <stdint.h>
#endif
#include <stddef.h>
#ifdef _WIN32
#define WIN32_LEAN_AND_MEAN
#include <Windows.h>
#undef WIN32_LEAN_AND_MEAN
#else// Define system-specific HL_* defines here
#ifndef HL_UNIX
#define HL_UNIX

#if (defined __gnu_linux__) || (defined __linux__)
#define HL_LINUX
#endif

#if (defined __APPLE__) && (defined __MACH__)
#define HL_LINUX
#define HL_MACOS
#endif

#ifdef _AIX
#define HL_AIX
#define HL_BIG_ENDIAN
#endif

#ifdef __FreeBSD__
#define HL_FREEBSD
#endif

#if (defined _hpux) || (defined hpux) || (defined __hpux)
#define HL_HPUX
#define HL_BIG_ENDIAN
#endif

#if (defined sun) || (defined __sun)
#define HL_SOLARIS
#endif

#if (defined __arm__) || (defined __aarch64__)
#define HL_LINUX_ARM
#endif

#ifdef __ANDROID__
#define HL_ANDROID
#endif

#endif
#include <hob-unix01.h>
#endif
#ifdef __APPLE__
/* We get target conditionals to keep apart Mac OS, iOS and iOS simulator.
   The conditionals are TARGET_IPHONE_SIMULATOR, TARGET_OS_IPHONE and TARGET_OS_MAC.
   TARGET_IPHONE_SIMULATOR has the highest priority, TARGET_OS_MAC the lowest.
   Always test, if the conditional is 1, as they will be defined as 0, if we 
   are not compiling for the target.
   */
#include <TargetConditionals.h>
#endif

#include "hob-encry-1.h"
#include "hob-encry-intern-1.h"

/** @addtogroup dsa_dh
* @{
*/

//-----------------------------------------------------------------------------
// Named DH groups
//-----------------------------------------------------------------------------

/**
This structure contains the encoded DH group parameters.

Encoding is always big endian.
*/
struct dsd_diffie_hellman_group {
    const unsigned char* abyc_modulus_p;
    size_t szc_modulus_p_len;
    const unsigned char* abyc_generator_g;
    size_t szc_generator_g_len;
    const unsigned char* abyc_group_size_q;
    size_t szc_group_size_q_len;
};

static unsigned char byrs_tls_ffdhe2048_prime_p[] = {
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xAD, 0xF8, 0x54, 0x58, 0xA2, 0xBB, 0x4A, 0x9A,
    0xAF, 0xDC, 0x56, 0x20, 0x27, 0x3D, 0x3C, 0xF1, 0xD8, 0xB9, 0xC5, 0x83, 0xCE, 0x2D, 0x36, 0x95, 
    0xA9, 0xE1, 0x36, 0x41, 0x14, 0x64, 0x33, 0xFB, 0xCC, 0x93, 0x9D, 0xCE, 0x24, 0x9B, 0x3E, 0xF9,
    0x7D, 0x2F, 0xE3, 0x63, 0x63, 0x0C, 0x75, 0xD8, 0xF6, 0x81, 0xB2, 0x02, 0xAE, 0xC4, 0x61, 0x7A,
    0xD3, 0xDF, 0x1E, 0xD5, 0xD5, 0xFD, 0x65, 0x61, 0x24, 0x33, 0xF5, 0x1F, 0x5F, 0x06, 0x6E, 0xD0, 
    0x85, 0x63, 0x65, 0x55, 0x3D, 0xED, 0x1A, 0xF3, 0xB5, 0x57, 0x13, 0x5E, 0x7F, 0x57, 0xC9, 0x35, 
    0x98, 0x4F, 0x0C, 0x70, 0xE0, 0xE6, 0x8B, 0x77, 0xE2, 0xA6, 0x89, 0xDA, 0xF3, 0xEF, 0xE8, 0x72, 
    0x1D, 0xF1, 0x58, 0xA1, 0x36, 0xAD, 0xE7, 0x35, 0x30, 0xAC, 0xCA, 0x4F, 0x48, 0x3A, 0x79, 0x7A, 
    0xBC, 0x0A, 0xB1, 0x82, 0xB3, 0x24, 0xFB, 0x61, 0xD1, 0x08, 0xA9, 0x4B, 0xB2, 0xC8, 0xE3, 0xFB,
    0xB9, 0x6A, 0xDA, 0xB7, 0x60, 0xD7, 0xF4, 0x68, 0x1D, 0x4F, 0x42, 0xA3, 0xDE, 0x39, 0x4D, 0xF4, 
    0xAE, 0x56, 0xED, 0xE7, 0x63, 0x72, 0xBB, 0x19, 0x0B, 0x07, 0xA7, 0xC8, 0xEE, 0x0A, 0x6D, 0x70, 
    0x9E, 0x02, 0xFC, 0xE1, 0xCD, 0xF7, 0xE2, 0xEC, 0xC0, 0x34, 0x04, 0xCD, 0x28, 0x34, 0x2F, 0x61, 
    0x91, 0x72, 0xFE, 0x9C, 0xE9, 0x85, 0x83, 0xFF, 0x8E, 0x4F, 0x12, 0x32, 0xEE, 0xF2, 0x81, 0x83, 
    0xC3, 0xFE, 0x3B, 0x1B, 0x4C, 0x6F, 0xAD, 0x73, 0x3B, 0xB5, 0xFC, 0xBC, 0x2E, 0xC2, 0x20, 0x05,
    0xC5, 0x8E, 0xF1, 0x83, 0x7D, 0x16, 0x83, 0xB2, 0xC6, 0xF3, 0x4A, 0x26, 0xC1, 0xB2, 0xEF, 0xFA, 
    0x88, 0x6B, 0x42, 0x38, 0x61, 0x28, 0x5C, 0x97, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF
};

static unsigned char byrs_tls_ffdhe2048_generator_g[] = {0x02};

static unsigned char byrs_tls_ffdhe2048_group_size_q[] = {
    0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xD6, 0xFC, 0x2A, 0x2C, 0x51, 0x5D, 0xA5, 0x4D,
    0x57, 0xEE, 0x2B, 0x10, 0x13, 0x9E, 0x9E, 0x78, 0xEC, 0x5C, 0xE2, 0xC1, 0xE7, 0x16, 0x9B, 0x4A, 
    0xD4, 0xF0, 0x9B, 0x20, 0x8A, 0x32, 0x19, 0xFD, 0xE6, 0x49, 0xCE, 0xE7, 0x12, 0x4D, 0x9F, 0x7C, 
    0xBE, 0x97, 0xF1, 0xB1, 0xB1, 0x86, 0x3A, 0xEC, 0x7B, 0x40, 0xD9, 0x01, 0x57, 0x62, 0x30, 0xBD,
    0x69, 0xEF, 0x8F, 0x6A, 0xEA, 0xFE, 0xB2, 0xB0, 0x92, 0x19, 0xFA, 0x8F, 0xAF, 0x83, 0x37, 0x68, 
    0x42, 0xB1, 0xB2, 0xAA, 0x9E, 0xF6, 0x8D, 0x79, 0xDA, 0xAB, 0x89, 0xAF, 0x3F, 0xAB, 0xE4, 0x9A,
    0xCC, 0x27, 0x86, 0x38, 0x70, 0x73, 0x45, 0xBB, 0xF1, 0x53, 0x44, 0xED, 0x79, 0xF7, 0xF4, 0x39,
    0x0E, 0xF8, 0xAC, 0x50, 0x9B, 0x56, 0xF3, 0x9A, 0x98, 0x56, 0x65, 0x27, 0xA4, 0x1D, 0x3C, 0xBD, 
    0x5E, 0x05, 0x58, 0xC1, 0x59, 0x92, 0x7D, 0xB0, 0xE8, 0x84, 0x54, 0xA5, 0xD9, 0x64, 0x71, 0xFD, 
    0xDC, 0xB5, 0x6D, 0x5B, 0xB0, 0x6B, 0xFA, 0x34, 0x0E, 0xA7, 0xA1, 0x51, 0xEF, 0x1C, 0xA6, 0xFA,
    0x57, 0x2B, 0x76, 0xF3, 0xB1, 0xB9, 0x5D, 0x8C, 0x85, 0x83, 0xD3, 0xE4, 0x77, 0x05, 0x36, 0xB8, 
    0x4F, 0x01, 0x7E, 0x70, 0xE6, 0xFB, 0xF1, 0x76, 0x60, 0x1A, 0x02, 0x66, 0x94, 0x1A, 0x17, 0xB0,
    0xC8, 0xB9, 0x7F, 0x4E, 0x74, 0xC2, 0xC1, 0xFF, 0xC7, 0x27, 0x89, 0x19, 0x77, 0x79, 0x40, 0xC1,
    0xE1, 0xFF, 0x1D, 0x8D, 0xA6, 0x37, 0xD6, 0xB9, 0x9D, 0xDA, 0xFE, 0x5E, 0x17, 0x61, 0x10, 0x02,
    0xE2, 0xC7, 0x78, 0xC1, 0xBE, 0x8B, 0x41, 0xD9, 0x63, 0x79, 0xA5, 0x13, 0x60, 0xD9, 0x77, 0xFD, 
    0x44, 0x35, 0xA1, 0x1C, 0x30, 0x94, 0x2E, 0x4B, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF
};

static dsd_diffie_hellman_group dss_tls_ffdhe2048 = {
    byrs_tls_ffdhe2048_prime_p,
    sizeof(byrs_tls_ffdhe2048_prime_p),
    byrs_tls_ffdhe2048_generator_g,
    sizeof(byrs_tls_ffdhe2048_generator_g),
    byrs_tls_ffdhe2048_group_size_q,
    sizeof(byrs_tls_ffdhe2048_group_size_q)
};

static dsd_diffie_hellman_group dsrs_named_groups[] = {
    dss_tls_ffdhe2048,                                  //<! ied_dh_group_tls_ffdhe2048
};

/**
* Gets bitsize of a large number (WLnum_BitSize).
*
*  @param pNum Number to query
*  @return size in bits, 0, if no bits set / NULL pointer
*/
static  int WLnum_BitSize(WLARGENUM* pNum)
{
  int UsedSize;
  int * lpEl;

  if(pNum == NULL)				// Null pointer
    return(0);

  UsedSize = pNum->UsedSize;
  if(UsedSize == 0)				// value is 0
    return(0);

  lpEl = pNum->lpEl;			// get pointer
  return(HardGetBitCntWLnumElem(lpEl[UsedSize-1]) +
	 ((UsedSize-1) * WELEMENT_SIZE * 8));
}

/**
* Calculates required number of bytes for ASN.1 DER encoded length field for a
* given data length ( < 32k) (GetAsn1_DER_LenfieldSize).
*
*  @param DataLen Length value to be encoded
*  @return  Number of length field bytes, 0 on error (length too large)
*/
static  int GetAsn1_DER_LenfieldSize(int DataLen)
{
  int i = (DataLen >> 8) & 0xFF;	// get MSB

  if(i > 0x80) return(0);		// too big
  if(DataLen < 0x80) return(1);		// 1 Byte needed
  if(i == 0) return(2);			// 2 bytes needed
  return(3);				// 3 bytes needed
}
/**
* Generates ASN.1 encoded length field from a given length value 
* (must be < 32K) (SetAsn1_DER_Lenfield).
*
* Note: buffer size and length value are not checked!
*
*  @param dstbuf Array base
*  @param dstOffset Offset to start writing
*  @param dstLen Length to be encoded
*/
static  void SetAsn1_DER_Lenfield(char* dstbuf,
					      int dstOffset, int dstLen)
{
  int Index = dstOffset;

  if(dstLen < 0x80)
  {
    dstbuf[Index] = (char) dstLen;
    return;
  }
  if(dstLen < 0x100)
  {
    dstbuf[Index++] = (char) ((unsigned char) 0x81);
    dstbuf[Index] = (unsigned char) dstLen;
    return;
  }
  dstbuf[Index++] = (char) ((unsigned char) 0x82);
  dstbuf[Index++] = (unsigned char) (dstLen >> 8);
  dstbuf[Index] = (unsigned char) dstLen;
}
/**
* Decodes length of ASN.1 DER encoded length (no indefinite length, minimal
*  byte values) length < 32 k) (GetAsn1_DER_DataLen).
*
*  @param inpBuf array base
*  @param inpOffset Start of data
*  @param inpLen Length of data in array
*  @param pDatLen Decoded length value
*  @return number of length field bytes (1/2), 0 on error (length too large).
*/
static  int GetAsn1_DER_DataLen(char* inpBuf, int inpOffset,
					    int inpLen, int* pDatLen)
{
  int Index=inpOffset;
  int i;

  if(inpLen ==  0) return(0);			// error !!
  i = (int) inpBuf[Index++] & 0xFF;		// get number of bytes
  if((i & 0x80) == 0)				// 1 byte only
  {
    pDatLen[0] = i;
    return(1);
  }
  inpLen--;
  i &= 0x7F;					// get byte count
  if((i == 0) || (i > 2) || (i > inpLen))	// error occured
    return(0);
  pDatLen[0] = (int) inpBuf[Index++] & 0xFF;
  i--;
  if(i == 0) return(2);				// 1 additional byte !
  if((pDatLen[0] & 0x80) != 0)			// overflow !!
    return(0);

  pDatLen[0] <<= 8;				// shift up 1 byte
  pDatLen[0] |=  ((int) inpBuf[Index] & 0xFF);	// insert 2nd byte
  return(3);  
}

extern "C" int m_copy_dh(HMEM_CTX_DEF
                         const DH_STRUC* adsp_input,
                         DH_STRUC** aadsp_output)
{
    if((adsp_input == NULL) || (aadsp_output == NULL)){
        return DSA_DH_NULL_PTR;
    }
    
    // We generate a new instance with same sizes
    *aadsp_output = NULL;
    DH_STRUC* adsl_copy = DH_New(HMEM_CTX_REF1 
                                 adsp_input->p->UsedSize,
                                 adsp_input->q->UsedSize,
                                 adsp_input->g->UsedSize,
                                 adsp_input->PubKey->UsedSize,
                                 adsp_input->PrivKey->UsedSize);

    if(adsl_copy == NULL){
        return DSA_DH_ALLOC_ERR;
    }

    // We copy all content
    int inl_error = CopyWLnum(HMEM_CTX_REF1 adsl_copy->p, adsp_input->p);
    if(inl_error != LNUM_OP_OK){
        goto error;
    }
    
    inl_error = CopyWLnum(HMEM_CTX_REF1 adsl_copy->q, adsp_input->q);
    if(inl_error != LNUM_OP_OK){
        goto error;
    }

    inl_error = CopyWLnum(HMEM_CTX_REF1 adsl_copy->g, adsp_input->g);
    if(inl_error != LNUM_OP_OK){
        goto error;
    }

    inl_error = CopyWLnum(HMEM_CTX_REF1 adsl_copy->j, adsp_input->j);
    if(inl_error != LNUM_OP_OK){
        goto error;
    }

    inl_error = CopyWLnum(HMEM_CTX_REF1 adsl_copy->PubKey, adsp_input->PubKey);
    if(inl_error != LNUM_OP_OK){
        goto error;
    }

    inl_error = CopyWLnum(HMEM_CTX_REF1 adsl_copy->PrivKey, adsp_input->PrivKey);
    if(inl_error != LNUM_OP_OK){
        goto error;
    }

    inl_error = CopyWLnum(HMEM_CTX_REF1 adsl_copy->Seed, adsp_input->Seed);
    if(inl_error != LNUM_OP_OK){
        goto error;
    }

    adsl_copy->PrivLen = adsp_input->PrivLen;
    adsl_copy->PgenCount = adsp_input->PgenCount;

    *aadsp_output = adsl_copy;
    return 0;
error:
    DH_Free(HMEM_CTX_REF1 adsl_copy);
    return inl_error;
}

extern "C" BOOL m_dh_group_is_safe(DH_STRUC* adsp_group, 
                                   int inp_min_bit_len)
{
    BOOL bol_group_is_safe = TRUE;

    // We check for minimum size
    bol_group_is_safe &= (GetBitCntWLnum(adsp_group->p) >= inp_min_bit_len);

    // We validate 2 <= g <= (p-1)
    bol_group_is_safe &= ! IsZeroWLnum(adsp_group->g);
    bol_group_is_safe &= ! IsOneWLnum(adsp_group->g);

    bol_group_is_safe &= (WLNUM_1ST_GT_2ND == UcompWLnum(adsp_group->p, 
                                                         adsp_group->g));

    return bol_group_is_safe;
}

extern "C"  void DSA_Free(HMEM_CTX_DEF DSA_STRUC* r)
{
  if(r == NULL) return;
  ClearFreeWLnum(HMEM_CTX_REF1 r->p);
  ClearFreeWLnum(HMEM_CTX_REF1 r->q);
  ClearFreeWLnum(HMEM_CTX_REF1 r->g);
  ClearFreeWLnum(HMEM_CTX_REF1 r->y);
  ClearFreeWLnum(HMEM_CTX_REF1 r->x);
  FREE_CARRAY(HMEM_CTX_REF,r);
}

extern "C"  DSA_STRUC* DSA_New(HMEM_CTX_DEF
				  int pElementcnt,
			          int qElementcnt,
			          int gElementcnt,
			          int yElementcnt,
				  int xElementcnt)
{
  DSA_STRUC* ret;

  ret = (DSA_STRUC *)
          ((void *) BIT8_ARRAY_ALLOC(HMEM_CTX_REF,sizeof(DSA_STRUC)));

  if(ret == NULL) return(NULL);

  ret->p = AllocNewWLnum(HMEM_CTX_REF1 pElementcnt);
  ret->q = AllocNewWLnum(HMEM_CTX_REF1 qElementcnt);
  ret->g = AllocNewWLnum(HMEM_CTX_REF1 gElementcnt);
  ret->y = AllocNewWLnum(HMEM_CTX_REF1 yElementcnt);
  ret->x = AllocNewWLnum(HMEM_CTX_REF1 xElementcnt);

  if((ret->x == NULL) || (ret->y == NULL) ||
     (ret->p == NULL) || (ret->q == NULL) ||
     (ret->g == NULL))

  {
    DSA_Free(HMEM_CTX_REF1 ret);
    return(NULL);
  }
  return(ret);
}

extern "C"  int DSA_BitSize(DSA_STRUC* dsa)
{
  if((dsa == NULL) || (dsa->p) == NULL) return(0);
  return(WLnum_BitSize(dsa->p));
}

extern "C"  int DSA_SignatMaxLen(DSA_STRUC* dsa)
{
  int i,len,qsize;

  if((dsa == NULL) || (dsa->q == NULL))  return(0);	// no structure/q-value
//qsize = WLNUM_UsedSize(DSA_q(dsa)) * WELEMENT_SIZE;	// get byte-count of q
  qsize = GetByteCntWLnum(dsa->q);	// get byte-count of q
  if(qsize == 0) return(0);				// invalid value !
  qsize++;						// incl. leading zero
  //-------------------------------------------------------
  // get required ASN.1 length field for Integers r,s
  //-------------------------------------------------------
  i=GetAsn1_DER_LenfieldSize(qsize);
  if(i == 0) return(0);					// invalid
  len = (qsize + i + 1) * 2;				// length incl.INTEGER
  //-------------------------------------------------------
  // get required ASN.1 length field for sequence
  //-------------------------------------------------------
  i=GetAsn1_DER_LenfieldSize(len);
  if(i == 0) return(0);					// invalid
  return(len + i + 1);
}

extern "C"  void DH_Free(HMEM_CTX_DEF DH_STRUC* r)
{
  if(r == NULL) return;
//  FREE_WLNUM(HMEM_CTX_REF,DH_Prime_p(r));
//  FREE_WLNUM(HMEM_CTX_REF,DH_Prime_q(r));
//  FREE_WLNUM(HMEM_CTX_REF,DH_Base(r));
//  FREE_WLNUM(HMEM_CTX_REF,DH_Factor(r));
//  FREE_WLNUM(HMEM_CTX_REF,DH_PubKey(r));

  ClearFreeWLnum(HMEM_CTX_REF1 r->p);
  ClearFreeWLnum(HMEM_CTX_REF1 r->q);
  ClearFreeWLnum(HMEM_CTX_REF1 r->g);
  ClearFreeWLnum(HMEM_CTX_REF1 r->j);
  ClearFreeWLnum(HMEM_CTX_REF1 r->PubKey);

  ClearFreeWLnum(HMEM_CTX_REF1 r->PrivKey);
  FreeWLnum(HMEM_CTX_REF1 r->Seed);
  FREE_CARRAY(HMEM_CTX_REF,r);
}

extern "C"  DH_STRUC* DH_New(HMEM_CTX_DEF
				int pElementcnt,
				int qElementcnt,
				int gElementcnt,
				int yElementcnt,
				int xElementcnt)
{
  int i;
  DH_STRUC* ret;

  ret = (DH_STRUC *)
          ((void *) BIT8_ARRAY_ALLOC(HMEM_CTX_REF,sizeof(DH_STRUC)));
  if (ret == NULL) return(NULL);

  i = pElementcnt - qElementcnt;
  if(i < 0) i = -i;
  ret->p = AllocNewWLnum(HMEM_CTX_REF1 pElementcnt);
  ret->q = AllocNewWLnum(HMEM_CTX_REF1 qElementcnt);
  ret->g    = AllocNewWLnum(HMEM_CTX_REF1 gElementcnt);
  ret->j  = AllocNewWLnum(HMEM_CTX_REF1 i);
  ret->PubKey  = AllocNewWLnum(HMEM_CTX_REF1 yElementcnt);
  ret->PrivKey = AllocNewWLnum(HMEM_CTX_REF1 xElementcnt);
  ret->Seed	  = AllocNewWLnum(HMEM_CTX_REF1 qElementcnt);
  ret->PrivLen = 0;
  ret->PgenCount = 0;

  if((ret->p == NULL) || (ret->q == NULL) ||
     (ret->g == NULL)    || (ret->j == NULL)  ||
     (ret->PubKey == NULL)   || (ret->PrivKey == NULL) ||
     (ret->Seed == NULL))
  {
    DH_Free(HMEM_CTX_REF1 ret);
    return(NULL);
  }
  return(ret);
}	

extern "C"  int DH_Size(DH_STRUC* dh)
{
  if((dh == NULL) || (dh->p == NULL)) return(0);
  return(GetByteCntWLnum(dh->p));
}

extern "C"  int DH_BitSize(DH_STRUC* dh)
{
  if((dh == NULL) || (dh->p) == NULL) return(0);
  return(WLnum_BitSize(dh->p));
}

extern "C"  int DH_ParamCompare(DH_STRUC* Dh1, DH_STRUC* Dh2)
{

  if((Dh1 == NULL) || (Dh2 == NULL))	// one or both absent
    return(1);
  //----------------------------------------------------------
  // Check if all 3 parameters are loaded and have length <> 0
  //----------------------------------------------------------
  if((Dh1->p == NULL) || (Dh2->p == NULL))
    return(1);

  if((Dh1->p->UsedSize == 0) ||
     (Dh2->p->UsedSize == 0))
    return(1);

  if((Dh1->g == NULL) || (Dh2->g == NULL))
    return(1);

  if((Dh1->g->UsedSize == 0) ||
     (Dh2->g->UsedSize == 0))
    return(1);
  //----------------------------------------------------------
  // All Parameters present, compare
  //----------------------------------------------------------
  if(UcompWLnum(Dh1->p,Dh2->p) !=
     WLNUM_1ST_EQ_2ND)
    return(1);

  if(UcompWLnum(Dh1->g,Dh2->g) !=
     WLNUM_1ST_EQ_2ND)
    return(1);

  return(0);
}

extern "C"  int DSA_Sign(HMEM_CTX_DEF
			char* msgBuf, int msgOffset, int msgLen,
			char* sigBuf, int sigOffset, int* psigLen,
			DSA_STRUC* dsa, WLARGENUM* kTest,int Mode)
{

  int i,j,l,SeqLen,NumLen,rLen,sLen;

  int ret=DSA_OP_OK;
  int reason=LNUM_OP_OK;

  int DgstOffset = 0;

  char* pDgst;

  char dgst[SHA_DIGEST_LEN];
  int sha[SHA_ARRAY_SIZE];
  int tmpLen[1];

  WLARGENUM* m = NULL;
  WLARGENUM* k = NULL;
  WLARGENUM* kinv = NULL;
  WLARGENUM* r = NULL;
  WLARGENUM* s = NULL;

  for(;;)				// outer processing loop
  {
    if(Mode == 0)			// must hash
    {
      pDgst = dgst;			// use local buffer later
      //---------------------------------------------------
      // generate SHA1 Hash
      //---------------------------------------------------
      SHA1_Init(sha);				// initialize
      SHA1_Update(sha,msgBuf,msgOffset,msgLen);// generate
      SHA1_Final(sha,dgst,0);			// store
    }
    else				// no hashing required
    {
      pDgst      = msgBuf;
      DgstOffset = msgOffset;
    }
    //---------------------------------------------------
    // allocate required large numbers
    //---------------------------------------------------
    if(dsa->q->UsedSize > dsa->p->UsedSize)
      NumLen = dsa->q->UsedSize;
    else
      NumLen = dsa->p->UsedSize;

    m = AllocNewWLnum(HMEM_CTX_REF1 NumLen);
    r = AllocNewWLnum(HMEM_CTX_REF1 NumLen);
    s = AllocNewWLnum(HMEM_CTX_REF1 NumLen);
    k = AllocNewWLnum(HMEM_CTX_REF1 NumLen);
    kinv = AllocNewWLnum(HMEM_CTX_REF1 NumLen);
    if(m == NULL || r == NULL || s == NULL || k == NULL || kinv == NULL)
    {
      reason = LNUM_OP_ALLOC_ERR;
      break;
    }
    //-----------------------------------------------------
    // convert digest from binary to large number for calc,
    // get 160 Bit Random, compute s and r params
    //-----------------------------------------------------
							// to large number
    if((reason = WLnum_bin2wlnum(HMEM_CTX_REF1 m,pDgst,DgstOffset,SHA_DIGEST_LEN)) != LNUM_OP_OK)
      break;

    if(kTest != NULL)
      reason = CopyWLnum(HMEM_CTX_REF1 k,kTest);			// use given value
    else
      reason = WLnumRand(HMEM_CTX_REF1 k,160,1,0);			// get 160 Bit random

    if(reason != LNUM_OP_OK)
      break;

    // Compute r = (g^k mod p) mod q

							// s = g^k mod p
    if((reason = ExpModWLnum(HMEM_CTX_REF1 s,dsa->g,k,dsa->p,NULL,NULL)) != LNUM_OP_OK)
      break;

							// r = s mod q
    if((reason = DivWLnum(HMEM_CTX_REF1 NULL,r,s,dsa->q,NULL)) != LNUM_OP_OK)
      break;

    // Compute  s = inv(k) (m + xr) mod q

							// s = x * r
    if((reason = MulWLnum(HMEM_CTX_REF1 s,dsa->x,r)) != LNUM_OP_OK)
      break;
							// s = x * r + m
    if((reason = AddWLnum(HMEM_CTX_REF1 s,s,m)) != LNUM_OP_OK)
      break;
							 // kinv = k^-1 mod q
    if((reason = InvModWLnum(HMEM_CTX_REF1 kinv,k,dsa->q,NULL)) != LNUM_OP_OK)
      break;
							// s = (s * kinv) mod q
    if((reason = MulModWLnum(HMEM_CTX_REF1 s,s,kinv,dsa->q,NULL)) != LNUM_OP_OK)
      break;
    //------------------------------------------------------
    // assure that nor s neither t are 0 (is invalid!)
    //------------------------------------------------------
    if((IsZeroWLnum(r) != 0) ||
       (IsZeroWLnum(s) != 0))
    {
      reason = DSA_SIGN_R_S_ZERO;
      break;
    }

    //------------------------------------------------------
    // get length for r and s byte strings
    // NOTE: Obey leading zero for ASN.1 integer coding
    //------------------------------------------------------
    rLen = GetByteCntWLnum(r);	// get length in byte
    i = r->UsedSize;			// get element count
    j = HardGetByteCntWLnumElem(r->lpEl[i-1]);		// number of bytes in highest

    if((r->lpEl[i-1] & ((int) 0x80 << ((j-1)*8))) != 0) //MSB bit set
      rLen++;

    sLen = GetByteCntWLnum(s);	// get length in byte
    i = s->UsedSize;			// get element count
    j = HardGetByteCntWLnumElem(s->lpEl[i-1]);		// number of bytes in highest

    if((s->lpEl[i-1] & ((int) 0x80 << ((j-1)*8))) != 0) //MSB bit set
      sLen++;

    i = GetAsn1_DER_LenfieldSize(rLen);			// get length bytes
    if(i == 0)
    {
      ret = DSA_SIGN_R_DATA_TOO_LARGE;
      break;
    }
    j = GetAsn1_DER_LenfieldSize(sLen);			// get length bytes
    if(j == 0)
    {
      ret = DSA_SIGN_S_DATA_TOO_LARGE;
      break;
    }
    l = rLen + sLen + i + j + 2;			// length of r,s
    NumLen = GetAsn1_DER_LenfieldSize(l);		// seq. length
    if(NumLen == 0)
    {
      ret = DSA_SIGN_DATA_TOO_LARGE;
      break;
    }
    SeqLen = NumLen + l;				// total size
    if((SeqLen+1) > psigLen[0])
    {
      ret = DSA_SIGN_DATA_TOO_LARGE;
      break;
    }
    psigLen[0] = SeqLen + 1;
    //------------------------------------------------------
    // generate ASN.1 sequence
    //------------------------------------------------------
    sigBuf[sigOffset++] = (char) 0x30;			// set sequence
    SetAsn1_DER_Lenfield(sigBuf,sigOffset,l);		// set length field
    sigOffset += NumLen;
    //------------------------------------------------------
    // generate ASN.1 integer r
    //------------------------------------------------------
    sigBuf[sigOffset++] = 0x02;				// set integer
    SetAsn1_DER_Lenfield(sigBuf,sigOffset,rLen);	// set length field
    sigOffset += i;
    tmpLen[0] = rLen;
							//to string
    if((reason = WLnum_wlnum2bin(sigBuf,sigOffset,tmpLen,r,1)) != LNUM_OP_OK)
      break;

    sigOffset += rLen;
    //------------------------------------------------------
    // generate ASN.1 integer s
    //------------------------------------------------------
    sigBuf[sigOffset++] = 0x02;				// set integer
    SetAsn1_DER_Lenfield(sigBuf,sigOffset,sLen);	// set length field
    sigOffset += j;
    tmpLen[0] = sLen;
							//to string
    reason = WLnum_wlnum2bin(sigBuf,sigOffset,tmpLen,s,1);
    break;
  } // for

  FreeWLnum(HMEM_CTX_REF1 m);
  FreeWLnum(HMEM_CTX_REF1 r);
  FreeWLnum(HMEM_CTX_REF1 s);
  FreeWLnum(HMEM_CTX_REF1 k);
  FreeWLnum(HMEM_CTX_REF1 kinv);
  if(reason != LNUM_OP_OK)
    return(DSA_SIGN_LNUM_ERR);
  return(ret);
}

extern "C"  int DSA_Verify(HMEM_CTX_DEF
			char* msgBuf, int msgOffset, int msgLen,
			char* sigBuf, int sigOffset, int sigLen,
		        DSA_STRUC* dsa, int Mode)
{
  int i,NumLen,SeqLen;
  int ret = DSA_OP_OK;
  int reason = LNUM_OP_OK;

  int DgstOffset=0;
  char* pDgst;

  int DataLen[1];

  char dgst[SHA_DIGEST_LEN];
  int sha[SHA_ARRAY_SIZE];

  WLARGENUM* r  = NULL;
  WLARGENUM* t1 = NULL;
  WLARGENUM* t2 = NULL;
  WLARGENUM* u1 = NULL;
  WLARGENUM* u2 = NULL;

  if(sigLen < 8) return(DSA_VERIFY_SIGNAT_TOO_SMALL);
  //-----------------------------------------------
  // FOR-Loop for easier error handling
  //-----------------------------------------------
  for(;;)
  {
    if(Mode == 0)				// must hash first
    {
      pDgst = dgst;
      //---------------------------------------------------
      // generate SHA1 Hash
      //---------------------------------------------------
      SHA1_Init(sha);					// initialize
      SHA1_Update(sha,msgBuf,msgOffset,msgLen);	// generate
      SHA1_Final(sha,dgst,0);				// store
    }
    else					// use as direct input
    {
      pDgst      = msgBuf;
      DgstOffset = msgOffset;
    }
    //---------------------------------------------
    // Allocate temporary large numbers
    //---------------------------------------------
    if(dsa->q->UsedSize > dsa->p->UsedSize)
      NumLen = dsa->q->UsedSize;
    else
      NumLen = dsa->p->UsedSize;

    r  = AllocNewWLnum(HMEM_CTX_REF1 NumLen);
    u1 = AllocNewWLnum(HMEM_CTX_REF1 NumLen);
    u2 = AllocNewWLnum(HMEM_CTX_REF1 NumLen);
    t1 = AllocNewWLnum(HMEM_CTX_REF1 NumLen);
    t2 = AllocNewWLnum(HMEM_CTX_REF1 NumLen);
    if((r==NULL) || (u1==NULL) || (u2==NULL) || (t1==NULL) || (t2 == NULL))
    {
      ret = DSA_VERIFY_ALLOC_ERR;
      break;
    }
    //---------------------------------------------
    // Decode the ASN.1 sequence from the signature buffer:
    // 1. Get/Check length of Sequence
    //---------------------------------------------
    if(sigBuf[sigOffset++] != 0x30)		// must be a sequence
      return(DSA_VERIFY_INVALID_SIGNAT_DATA);
    sigLen--;					// reduce length

    i = GetAsn1_DER_DataLen(sigBuf,sigOffset,sigLen,DataLen);
    if(i == 0)
    {
      reason = DSA_VERIFY_INVALID_SIGNAT_DATA;
      break;
    }
    SeqLen = DataLen[0];
    sigOffset += i;				// skip bytes
    sigLen -= i;				// reduce length
    if(sigLen < SeqLen) return(DSA_VERIFY_SIGNAT_TOO_SMALL);
    SeqLen -= 2;				// reduce INT prefixes
    //---------------------------------------------
    // 2. Get/Check length of number r
    //---------------------------------------------
    if(sigBuf[sigOffset++] != 0x02)		// must be an integer
      return(DSA_VERIFY_INVALID_SIGNAT_DATA);
    sigLen--;
    i = GetAsn1_DER_DataLen(sigBuf,sigOffset,sigLen,DataLen);
    if(i == 0)
    {
      reason = DSA_VERIFY_INVALID_SIGNAT_DATA;
      break;
    }
    sigOffset += i;				// skip bytes
    sigLen -= i;				// reduce count
    SeqLen -= i;				// dto.
    NumLen = DataLen[0];			// get length
    if(NumLen >= SeqLen) return(DSA_VERIFY_SIGNAT_TOO_SMALL);
    //---------------------------------------------
    // 3. load number r into LNUM structure
    //---------------------------------------------

    if((reason = WLnum_bin2wlnum(HMEM_CTX_REF1 r,sigBuf,sigOffset,NumLen)) != LNUM_OP_OK)
      break;
    SeqLen -= NumLen;
    sigOffset += NumLen;
    sigLen -= NumLen;
    if(sigLen < 2)
      return(DSA_VERIFY_SIGNAT_TOO_SMALL);
    //---------------------------------------------
    // 4. Get/Check length of number s
    //---------------------------------------------
    if(sigBuf[sigOffset++] != 0x02)		// must be an integer
      return(DSA_VERIFY_INVALID_SIGNAT_DATA);
    sigLen--;					// reduce count
    i = GetAsn1_DER_DataLen(sigBuf,sigOffset,sigLen,DataLen);
    if(i == 0)
    {
      reason = DSA_VERIFY_INVALID_SIGNAT_DATA;
      break;
    }
    sigOffset += i;				// skip bytes
    SeqLen -= i;				// dto.
    NumLen = DataLen[0];
    if(NumLen != SeqLen)
      return(DSA_VERIFY_INVALID_SIGNAT_DATA);
    //---------------------------------------------
    // 5. load number s into LNUM structure
    //---------------------------------------------
						// convert s to long number
    if((reason = WLnum_bin2wlnum(HMEM_CTX_REF1 u1,sigBuf,sigOffset,NumLen)) != LNUM_OP_OK)
      break;
    //-----------------------------------------------------------
    // Calculate w = (S^-1) mod q
    //-----------------------------------------------------------
						// w = u2 = (s^-1) mod q
    if((reason = InvModWLnum(HMEM_CTX_REF1 u2,u1,dsa->q,NULL)) != LNUM_OP_OK)
      break;
						 // convert M to long number
    if((reason = WLnum_bin2wlnum(HMEM_CTX_REF1 u1,pDgst,DgstOffset,SHA_DIGEST_LEN)) != LNUM_OP_OK)
      break;
    //-----------------------------------------------------------
    // Calculate u1 = (M' * w) mod q
    //-----------------------------------------------------------
						// u1 = (M'* w) mod q
    if((reason = MulModWLnum(HMEM_CTX_REF1 u1,u1,u2,dsa->q,NULL)) != LNUM_OP_OK)
      break;
    //-----------------------------------------------------------
    // Calculate u2 = (r' * w) mod q
    //-----------------------------------------------------------
						 // u2 = (r'* w) mod q
    if((reason = MulModWLnum(HMEM_CTX_REF1 u2,r,u2,dsa->q,NULL)) != LNUM_OP_OK)
      break;
    //-----------------------------------------------------------
    // Calculate v = (((g^u1) * (y^u2)) mod p) mod q =
    //                (((g^u1) mod p) * ((y^u2) mod p) mod p) mod q
    //-----------------------------------------------------------
							// t1 = (g^u1) mod p
    if((reason = ExpModWLnum(HMEM_CTX_REF1 t1,dsa->g,u1,dsa->p,NULL,NULL)) != LNUM_OP_OK)
      break;
							// t2 = (y^u2) mod p
    if((reason = ExpModWLnum(HMEM_CTX_REF1 t2,dsa->y,u2,dsa->p,NULL,NULL)) != LNUM_OP_OK)
      break;

							//u2 = (t1 * t2) mod p
    if((reason = MulModWLnum(HMEM_CTX_REF1 u2,t1,t2,dsa->p,NULL)) != LNUM_OP_OK)
      break;

							 // u1 = u2 mod q
    if((reason = DivWLnum(HMEM_CTX_REF1 NULL,u1,u2,dsa->q,NULL)) != LNUM_OP_OK)
      break;
    //-----------------------------------------------------------
    // V is now in u1.  If the signature is correct, it will be
    // equal to R.
    //-----------------------------------------------------------
    i = UcompWLnum(u1,r);			// compare
    if(i != WLNUM_1ST_EQ_2ND)
      ret = DSA_VERIFY_INVALID_SIGNAT;
    break;
  } // Error FOR loop
  FreeWLnum(HMEM_CTX_REF1 r);
  FreeWLnum(HMEM_CTX_REF1 t1);
  FreeWLnum(HMEM_CTX_REF1 t2);
  FreeWLnum(HMEM_CTX_REF1 u1);
  FreeWLnum(HMEM_CTX_REF1 u2);
  if(reason != LNUM_OP_OK)
    return(DSA_VERIFY_LNUM_ERR);
  return(ret);
}
//===========================================================
//
// Routines for DSA/DH Parameter generation
// 
//===========================================================

/**
* Adds a byte value to a number in BIG ENDIAN order in a byte buffer and does
* modulo reduction to 2^n (i.e. discard all bits that would be larger 2^n) 
* according to the given bitmask for the topmost element (AddByteToBufMod2n).
*
*  @param Buf Buffer containing number (BIG ENDIAN)
*  @param Offset Start of Data
*  @param Len Number of Bytes in buffer 
*  @param AddVal Value to Add
*  @param BitMask Mask for topmost (MSB) bits [Modulo]
*
*/
static  void AddByteToBufMod2n(char* Buf, int Offset, int Len,
				      unsigned char AddVal, char BitMask)
{
  int Index = Offset+Len-1;		// Start of LSB byte
  int Sum = AddVal & 0xFF;

  if(Len == 0) return;			// nothing to do

  do
  {
    Sum += ((int) Buf[Index] & 0xFF);	// Add up
    Buf[Index--] = (unsigned char) Sum;
    Sum = (Sum >> 8) & 0xFF;
    Len--;
  }while(Len != 0);
  Buf[Index+1] &= BitMask;		// do modulo reduction
}

extern "C"  int GenDsaDhParams(HMEM_CTX_DEF
				 int L, int m, int ncheck,
				 int Type,
				 WLARGENUM* p, WLARGENUM* q, WLARGENUM* g,
				 WLARGENUM* j,
				 WLARGENUM* Seed, int* pCounter,
				 void callback(int))
{
  int Retcode = LNUM_OP_OK;

  char* pSeed	     = NULL;
  char* pSeedCalc1 = NULL;
  char* pSeedCalc2 = NULL;

  char* pNumberU   = NULL;
  char* pNumberW   = NULL;

  char Sha1Dgst1[SHA_DIGEST_LEN];
  char Sha1Dgst2[SHA_DIGEST_LEN];

  int sha[SHA_ARRAY_SIZE];

  unsigned char	bMask;
  unsigned char  dMask;

  int	i,k,l;
  int   b,n,t,d;
  int	bCnt,dCnt;
  int	VLen,SLen;
  int	Index;
  int	PgenCnt = 0;
  int	StopFlag = 0;

  int TmpInt[1];

  WLARGENUM* lp2q  = NULL;
  WLARGENUM* lpX   = NULL;
  WLARGENUM* lpTmp = NULL;

  short* primarray=NULL;				// prime number array

  //----------------------------------------------
  // Check Parameters 
  //----------------------------------------------
  if((p == NULL) || (q == NULL) || (g == NULL))
    return(LNUM_OP_NULL_PTR);

  if(m < MIN_DH_DSA_Q_BITS)
    return(DSA_DH_GEN_INV_BITSIZE);

  if(Type == 0)					// DSA
  {
    if((m != MIN_DH_DSA_Q_BITS) || (L < 512) || (L > 2048) ||
       (((L - 512) & 0x1F) != 0))
    return(DSA_DH_GEN_INV_BITSIZE);
  }
  else
  {
    if(L <= m+1)
      return(DSA_DH_GEN_INV_BITSIZE);
  }
  //----------------------------------------------
  // Calculate constants
  //----------------------------------------------
  n = (L-1) / MIN_DH_DSA_Q_BITS;		// full digests V count
  b = (L-1) - n*MIN_DH_DSA_Q_BITS;		// remaining bits
  bCnt = (b + 7) / 8;				// number of bytes
  VLen = n * SHA_DIGEST_LEN + bCnt;		// total bytes
  b &= 0x07;					// remaining bits
  bMask = (unsigned char) 0xFF;					// do not mask bits
  if(b != 0) bMask =(unsigned char) ~(bMask << b);	// generate bitmask

  t = m / MIN_DH_DSA_Q_BITS;			// full digests S count
  d = m - t * MIN_DH_DSA_Q_BITS;		// remaining bits
  dCnt = (d + 7) / 8;				// number of bytes
  SLen = t * SHA_DIGEST_LEN + dCnt;		// total Bytes
  d &= 0x07;					// remaining bits
  dMask = (unsigned char) 0xFF;					// do not mask bits
  if(d != 0) dMask = (unsigned char) ~(dMask << d);	// generate bitmask
  //----------------------------------------------
  // Allocate required buffers and prime array
  //----------------------------------------------
  pSeed      = BIT8_ARRAY_ALLOC(HMEM_CTX_REF,SLen); // m bit long Seed
  pSeedCalc1 = BIT8_ARRAY_ALLOC(HMEM_CTX_REF,SLen); // same for S generation
  pSeedCalc2 = BIT8_ARRAY_ALLOC(HMEM_CTX_REF,SLen); // dto.
  pNumberW   = BIT8_ARRAY_ALLOC(HMEM_CTX_REF,VLen+1); // L bit long number
  pNumberU   = BIT8_ARRAY_ALLOC(HMEM_CTX_REF,SLen); // m bit long number
  primarray  = BIT16_ARRAY_ALLOC(HMEM_CTX_REF,SMALL_PRIME_CNT); // number array
  if((pSeed == NULL) || (pSeedCalc1 == NULL) ||
     (pSeedCalc2 == NULL) || (pNumberU == NULL) ||
     (pNumberW == NULL) || (primarray == NULL))
  {
    FREE_ARRAY(HMEM_CTX_REF,pSeed);
    FREE_ARRAY(HMEM_CTX_REF,pSeedCalc1);
    FREE_ARRAY(HMEM_CTX_REF,pSeedCalc2);
    FREE_ARRAY(HMEM_CTX_REF,pNumberU);
    FREE_ARRAY(HMEM_CTX_REF,pNumberW);
    FREE_ARRAY(HMEM_CTX_REF,primarray);
    return(LNUM_OP_ALLOC_ERR);
  }
  //----------------------------------------------
  // Get required large numbers.....
  //----------------------------------------------
  lp2q  = AllocNewWLnum(HMEM_CTX_REF1 (SLen + WELEMENT_SIZE - 1)/WELEMENT_SIZE);	// 2 times m size
  lpX   = AllocNewWLnum(HMEM_CTX_REF1 (VLen + WELEMENT_SIZE - 1) / WELEMENT_SIZE); // size L  
  lpTmp = AllocNewWLnum(HMEM_CTX_REF1 (VLen + WELEMENT_SIZE - 1) / WELEMENT_SIZE);
  if((lpX == NULL) || (lp2q == NULL) || (lpTmp == NULL))
  {
    FreeWLnum(HMEM_CTX_REF1 lp2q);
    FreeWLnum(HMEM_CTX_REF1 lpX);
    FreeWLnum(HMEM_CTX_REF1 lpTmp);
    FREE_ARRAY(HMEM_CTX_REF,pSeed);
    FREE_ARRAY(HMEM_CTX_REF,pSeedCalc1);
    FREE_ARRAY(HMEM_CTX_REF,pSeedCalc2);
    FREE_ARRAY(HMEM_CTX_REF,primarray);
    FREE_ARRAY(HMEM_CTX_REF,pNumberW);
    FREE_ARRAY(HMEM_CTX_REF,pNumberU);
    return(LNUM_OP_ALLOC_ERR);
  }
  //----------------------------------------------
  // Generate small prime Array
  //----------------------------------------------
  DoEratosthenesWSieve(HMEM_CTX_REF1 primarray,SMALL_PRIME_CNT);

  //----------------------------------------------
  // Generate prime q,p and group params g
  //----------------------------------------------
  for(;;)				// Error FOR
  {
    if(callback != NULL)
    {
      callback(0);
    }
    //----------------------------------------------
    // A. Generate prime q
    //----------------------------------------------
    for(;;)				// q Generate FOR
    {
      //----------------------------------------------------------
      // 1. Get the Seed of length m bit, prepare calculation
      //----------------------------------------------------------
//      RAND_BYTES(RANDinst,pSeed,0,SLen);		// get seed
      Retcode = SecDrbgRandBytes(HMEM_CTX_REF1 pSeed,0,SLen);
      if(Retcode != 0)
        break;

      pSeed[0] &= dMask;				// ignore masked bits
      if(d == 0)
        pSeed[0] |= 0x80;				// set top bit
      else
      {
        pSeed[0] = (char)
          (pSeed[0] | (0x01 << (d-1)));			// dto.
      }
      memcpy(pSeedCalc1+0,pSeed+0,SLen); // copy for calculation
      memcpy(pSeedCalc2+0,pSeed+0,SLen); // copy for calculation
      AddByteToBufMod2n(pSeedCalc2,0,SLen,	// add t
	  	        (unsigned char) t,dMask);
      //----------------------------------------------------------
      // 2. Format Number U resp. p from S(0) ... S(t-1)
      //----------------------------------------------------------
      Index = SLen;					// past last byte
      i = 0;
      for(;;)
      {
        //--------------------------------------------------
        // Get Hashes for current i, XOR them together
        //--------------------------------------------------
        SHA1_Init(sha);
        SHA1_Update(sha,pSeedCalc1,0,SLen);	// generate hash 1
        SHA1_Final(sha,Sha1Dgst1,0);    

        SHA1_Init(sha);
        SHA1_Update(sha,pSeedCalc2,0,SLen);	// generate hash 2
        SHA1_Final(sha,Sha1Dgst2,0);    
        k = SHA_DIGEST_LEN;				// Counter and Index
        do
        {
          k--;						// pre-decrement
          Sha1Dgst1[k] ^= Sha1Dgst2[k];			// XOR
        }while(k != 0);
        //--------------------------------------------------
        // put the full / partial  hashes to number U
        //--------------------------------------------------
        if(i < t)					// full hash to copy
        {
          Index -= SHA_DIGEST_LEN;
          memcpy(pNumberU+Index,Sha1Dgst1+0,SHA_DIGEST_LEN);
          AddByteToBufMod2n(pSeedCalc1,0,SLen,(unsigned char) 1,dMask);	// add 1
          AddByteToBufMod2n(pSeedCalc2,0,SLen,(unsigned char) 1,dMask);	// add 1
        }
        else						// not a full hash
        {
          Index -= dCnt;
          if(dCnt != 0)					// bytes to copy
          {
            memcpy(pNumberU+Index,Sha1Dgst1+SHA_DIGEST_LEN-1-dCnt,dCnt);
            pNumberU[Index] &= dMask;			// ignore bits
          }
          pNumberU[SLen-1] |= 0x01;			// make odd
          if(d == 0)					// full bytes
            pNumberU[Index] |= 0x80;			// set top most
          else
          {
            pNumberU[Index] = (char)
              (pNumberU[Index] | (0x01 << (d-1)));	// set bit m
          }
          break;
        }
        i++;
      } // U-Generate for
      //----------------------------------------------------------
      // 3. Convert number to internal format, weed out small primes
      //----------------------------------------------------------
      if((Retcode = WLnum_bin2wlnum(HMEM_CTX_REF1 q,pNumberU,0,SLen)) != LNUM_OP_OK)
        break;

      i = 0;
      do
      {
        if(ModWordWLnum(q,primarray[i]) == 0)// get p mod (prime)
          break;				// not prime 
        i++;
      }while(i < SMALL_PRIME_CNT);
      if(i == SMALL_PRIME_CNT)			// all test passed
      {

        if(callback != NULL)
        {
          callback(1);
        }

        Retcode = WLnumMillerRabin(HMEM_CTX_REF1 q,ncheck,TmpInt,NULL,callback);
        if(Retcode != LNUM_OP_OK)
          break;
        if(TmpInt[0] == 0)			// found a prime q !!
          break;
        if(callback != NULL)
        {
          callback(2);
        }
      }
//      PRINT("d");
    } // q generate FOR
    if(Retcode != LNUM_OP_OK) break;		// error occured
//    PRINT("\nFound q\n");
    if(callback != NULL)
    {
      callback(4);
    }
    //----------------------------------------------
    // B. Generate prime p from seed and q
    //----------------------------------------------
    PgenCnt = 0;
    memcpy(pSeedCalc1+0,pSeed+0,SLen); // copy for calculation
    AddByteToBufMod2n(pSeedCalc1,0,SLen,(unsigned char) 2,dMask);// add offset 2

							// 2*q
    if((Retcode = Lshift1WLnum(HMEM_CTX_REF1 lp2q,q)) != LNUM_OP_OK)
      break;

    if(callback != NULL)
    {
      callback(0);
    }

    do
    {
      memcpy(pSeedCalc2+0,pSeedCalc1+0,SLen); // copy for calculation
      Index = VLen+1;					// past LSB of Number
      i = 0;
      //----------------------------------------------------
      // generate number W resp. X from V(0),...,V(n)
      //----------------------------------------------------
      for(;;)	// V-Number generate for
      {
        //--------------------------------------------------
        // Get Hash for current i
        //--------------------------------------------------
        SHA1_Init(sha);
        SHA1_Update(sha,pSeedCalc2,0,SLen);	// generate hash
        SHA1_Final(sha,Sha1Dgst1,0);    
        //--------------------------------------------------
        // put the full / partial  hash to number V
        //--------------------------------------------------
        if(i < n)   					// full hash to set
        {
          Index -= SHA_DIGEST_LEN;			// to Start
          memcpy(pNumberW+Index,Sha1Dgst1+0,SHA_DIGEST_LEN);
          AddByteToBufMod2n(pSeedCalc2,0,SLen,(unsigned char) 1,bMask);// increment
        }
        else
        {
          Index -= bCnt;
          if(bCnt != 0)
          {
            memcpy(pNumberW+Index,Sha1Dgst1+SHA_DIGEST_LEN-bCnt,bCnt);
            pNumberW[Index] &= bMask;			// ignore bits
          }
          pNumberW[0] = 0;				// clear top
          if(b == 0)					// one more byte !
            pNumberW[0] = 0x01;				// set top bit
          else
          {
            pNumberW[1] = (char)
              (pNumberW[1] | (0x01 << b));		// topmost 
          }
          break;
        }
        i++;
      } // W-Generate for
      //----------------------------------------------------
      // convert X to internal, calculate p
      //----------------------------------------------------
      if((Retcode = WLnum_bin2wlnum(HMEM_CTX_REF1 lpX,pNumberW,0,VLen+1)) != LNUM_OP_OK)
        break;
							// X mod 2*q
      if((Retcode = ModWLnum(HMEM_CTX_REF1 lpTmp,lpX,lp2q,NULL)) != LNUM_OP_OK)
        break;
							// X + 1
      if((Retcode = AddElementWLnum(HMEM_CTX_REF1 lpX,(int) 1)) != LNUM_OP_OK)
        break;
							// p = X - c + 1;
      if((Retcode = SubWLnum(HMEM_CTX_REF1 p,lpX,lpTmp)) != LNUM_OP_OK)
        break;
      //----------------------------------------------------
      // check if p has size L, if so check prime
      //----------------------------------------------------
      i = p->UsedSize;			// get count
      k = HardGetBitCntWLnumElem(p->lpEl[i-1]); // get topmost
      l = 0;					// signaling flag
      if(((i-1)*WELEMENT_BITS + k) >= L)	// has correct size
      {
        i = 0;
        do
        {
          if(ModWordWLnum(p,primarray[i]) == 0) // get p mod (prime) 
            break;				// not a prime
          i++;     
        }while(i < SMALL_PRIME_CNT);
        if(i == SMALL_PRIME_CNT)		// all test passed
        {
	  l = 1;
          //----------------------------------------------------------
          // do Miller-Rabin
          //----------------------------------------------------------
          if(callback != NULL)
          {
            callback(1);
          }

          Retcode = WLnumMillerRabin(HMEM_CTX_REF1 p,ncheck,TmpInt,NULL,callback);
          if(Retcode != LNUM_OP_OK) break;
          if(TmpInt[0] == 0)
          {
            StopFlag = 1;				// found prime p !!
  	    break;
          }
        }  
      }
      //----------------------------------------------------
      // size too small, not prime, to next counter / offset
      //----------------------------------------------------
      if((callback != NULL) && (l != 0))
      {
        callback(2);
      }
      PgenCnt ++;
      AddByteToBufMod2n(pSeedCalc1,0,SLen,(unsigned char) (n+1),// increment by n+1
			bMask);
    }while(PgenCnt < 4096);
    if(Retcode != LNUM_OP_OK) break;		// error occured
    if(StopFlag == 0) continue;			// no Error, not yet found
    if(callback != NULL)
    {
      callback(5);
    }
    //----------------------------------------------
    // C. Generate group parameter g from p,q and j
    //----------------------------------------------
								// get p
    if((Retcode = CopyWLnum(HMEM_CTX_REF1 lpX,p)) != LNUM_OP_OK)
      break;
								// p-1
    if((Retcode = SubElementWLnum(lpX,(int) 1)) != LNUM_OP_OK)
      break;
								// j = (p-1)/q
    if((Retcode = QuotWLnum(HMEM_CTX_REF1 lpTmp,lpX,q,NULL)) != LNUM_OP_OK)
      break;
    //-------------------------------------------------
    // Get Mask for Random Size generation
    //-------------------------------------------------
    b = 0x8000;					// preload mask
    i = 16;					// shift-Counter
    do
    {
      if((L & b) != 0) break;			// found top bit
      b = (b >> 1) | 0x8000;			// shift down 1 bit
      i--;
    }while(i != 0);
    b = ~(b << 1);				// generate AND mask

    for(;;)
    {
      //-------------------------------------------------
      // Generate random number h of length 2 .. L-1 bits
      //-------------------------------------------------
//      RAND_BYTES(RANDinst,pSeedCalc1,0,2);	// get 2 bytes random
      if((Retcode = SecDrbgRandBytes(HMEM_CTX_REF1 pSeedCalc1,0,2)) != 0)
        break;

      BIGchar2wordn(pSeedCalc1,i,0);		// to number
      i &= b;					// isolate relevant bits
      if(i <= 1) i = 2;				// at least 2 bits
      if(i >= L) i = L-1;			// at most L-1 bits
						// get random
      if((Retcode = WLnumRand(HMEM_CTX_REF1 lp2q,i,1,0)) != LNUM_OP_OK)
        break;      
      //-------------------------------------------
      // Calculate g = (h ** j) mod p
      //-------------------------------------------
						//(h ** j) mod p
      if((Retcode = ExpModWLnum(HMEM_CTX_REF1 lpX,lp2q,lpTmp,p,NULL,NULL)) != LNUM_OP_OK)
        break;      

      if(IsOneWLnum(lpX) == FALSE)	// found g
      {
        Retcode = CopyWLnum(HMEM_CTX_REF1 g,lpX);
	break;
      }
      if(callback != NULL)
      {
        callback(6);
      }
    } // g generate for
    break;
  } // Error / Generate for

  if(Retcode == LNUM_OP_OK)
  {
    if(pCounter != NULL)
      pCounter[0] = PgenCnt;			// set Counter

    if(Seed != NULL)
    {
      Retcode = WLnum_bin2wlnum(HMEM_CTX_REF1 Seed,pSeed,0,SLen);
    }

    if((j != NULL) && (Retcode == LNUM_OP_OK))
    {
      Retcode = CopyWLnum(HMEM_CTX_REF1 j,lpTmp);
    }
  }

  FreeWLnum(HMEM_CTX_REF1 lp2q);
  FreeWLnum(HMEM_CTX_REF1 lpX);
  FreeWLnum(HMEM_CTX_REF1 lpTmp);
  FREE_ARRAY(HMEM_CTX_REF,pSeed);
  FREE_ARRAY(HMEM_CTX_REF,pSeedCalc1);
  FREE_ARRAY(HMEM_CTX_REF,pSeedCalc2);
  FREE_ARRAY(HMEM_CTX_REF,primarray);
  FREE_ARRAY(HMEM_CTX_REF,pNumberW);
  FREE_ARRAY(HMEM_CTX_REF,pNumberU);
  return(Retcode);
}

/**
* Transforms a given large number x using modulo and addition
* operation into a given interval ]Low,High[ (TransformLnumToInterval).
* This is used for DSA/DH private value generation.
* NOTE: No parameters checked. Is MUST be assured that High - Low >= 2 !
*
*  @param x Large number to modify
*  @param LowVal Interval lower limit
*  @param HighVal Interval higher limit
*  @return 0 on sucess, error code otherwise
*/
static  int TransformLnumToInterval(HMEM_CTX_DEF
	WLARGENUM* x, WLARGENUM* LowVal, WLARGENUM* HighVal)
{
  int Retcode;

  WLARGENUM* Result = NULL;
  WLARGENUM* Remainder = NULL;

  //---------------------------------------------------------
  // Allocate helper large numbers
  //---------------------------------------------------------
  Result = AllocNewWLnum(HMEM_CTX_REF1 HighVal->AllocSize);
  Remainder = AllocNewWLnum(HMEM_CTX_REF1 HighVal->AllocSize);

  if((Result == NULL) || (Remainder == NULL))
  {
    FreeWLnum(HMEM_CTX_REF1 Result);
    FreeWLnum(HMEM_CTX_REF1 Remainder);
    return(LNUM_OP_ALLOC_ERR);
  }

  for(;;)
  {
    //---------------------------------------------------------
    // Calculate k = interval size - 1  for Modulo reduction
    //---------------------------------------------------------
    if((Retcode = SubWLnum(HMEM_CTX_REF1 Result,HighVal,LowVal)) != LNUM_OP_OK)
      break;

    if((Retcode = SubElementWLnum(Result,(int) 1)) != LNUM_OP_OK)
      break;
    //---------------------------------------------------------
    // Limit x to interval [0,k-1]: y = x mod k
    //---------------------------------------------------------
    if((Retcode = ModWLnum(HMEM_CTX_REF1 Remainder,x,Result,NULL)) != LNUM_OP_OK)
      break;
    //---------------------------------------------------------------
    // Add low limit to y:  z = y + Low to bring in range
    // NOTE: we direct store z to the x input number (no longer used)
    //---------------------------------------------------------------
    Retcode = AddWLnum(HMEM_CTX_REF1 x,Remainder,LowVal);
    break;
  }
  FreeWLnum(HMEM_CTX_REF1 Result);
  FreeWLnum(HMEM_CTX_REF1 Remainder);
  return(Retcode);  
}

extern "C"  int GenDsaDhKey(HMEM_CTX_DEF
			      int PrivKeyLen, int KeyType, int Mode,
			      WLARGENUM* p, WLARGENUM* q, WLARGENUM* g,
			      WLARGENUM* y, WLARGENUM* x,
			      void callback(int))
{
  int i;
  int Retcode;
  int TopFlag = 0;
  int BitCnt;
  int NumLen;
  int LowCmp,HighCmp;
//  int RetryCount = 4096;
  int RetryCount = 20;				// no more should be needed...
  WLARGENUM* pLowLimit  = NULL;
  WLARGENUM* pHighLimit = NULL;
  char TmpBuf[1];

  //-----------------------------------------------------------------
  // Check parameters
  //-----------------------------------------------------------------
  if((p == NULL) || (g == NULL) || (y == NULL) || (x == NULL) ||
    (p->UsedSize == 0) || (g->UsedSize == 0))
    return(LNUM_OP_NULL_PTR);

  Retcode = LNUM_OP_OK;
  for(;;)				// Error FOR
  {
    //-----------------------------------------------
    // set up bitsizes and comparison values needed
    //-----------------------------------------------
    if(KeyType == 0)					// DSA key to generate
    {
      //------------------------------------------------------------
      // Private key x for DSA is required, assure that q is present
      // and has correct length, set low and high compare limit
      //------------------------------------------------------------
      if(q == NULL)
        return(LNUM_OP_NULL_PTR);
      BitCnt = WLnum_BitSize(q);
      if(BitCnt != MIN_DH_DSA_Q_BITS)		// size is fixed !!
        return(DSA_DH_KEY_SIZE_ERR);

      NumLen = BitCnt / WELEMENT_BITS;
      pLowLimit  = AllocNewWLnum(HMEM_CTX_REF1 1);// need 1 element only
      pHighLimit = AllocNewWLnum(HMEM_CTX_REF1 NumLen);			// elements needed
      if((pLowLimit == NULL) || (pHighLimit == NULL))
      {
        Retcode = LNUM_OP_ALLOC_ERR;
        break;
      }

      TmpBuf[0] = (unsigned char) 0x00;			// > 0, lower limit
      if((Retcode = WLnum_bin2wlnum(HMEM_CTX_REF1 pLowLimit,TmpBuf,0,1)) != LNUM_OP_OK)
        break;
      if((Retcode = CopyWLnum(HMEM_CTX_REF1 pHighLimit,q)) != 0)
        break;
    }
    else
    {
      //----------------------------------------------------
      // DH Key to generate, check which mode to use
      //----------------------------------------------------
      if(Mode == 0)					// classic mode
      {
//      PRINT("DH Generate Key Classic Mode\n");
        BitCnt = WLnum_BitSize(p);			// maximum size
        //--------------------------------------------------
        // Preprocess key length in case of SSH access
        //--------------------------------------------------
        if(PrivKeyLen != 0)				// given size limit
        {
          if(PrivKeyLen > BitCnt)
            return(DSA_DH_KEY_SIZE_ERR);

          BitCnt = PrivKeyLen;
          if((q != NULL) && (q->AllocSize == 0))	// from SSH !!
            PrivKeyLen = 0;				// use 'default'
        }

        if(PrivKeyLen != 0)				// given size, classic
        {
	  TopFlag = 1;					// assure bit size
          //------------------------------------------------
          // Allocate large numbers for comparison,
          // 2**(l-1) < x < 2**l
          //------------------------------------------------
          NumLen = BitCnt / WELEMENT_BITS;		// size needed
          pLowLimit = AllocNewWLnum(HMEM_CTX_REF1 NumLen);		// elements needed
          pHighLimit = AllocNewWLnum(HMEM_CTX_REF1 NumLen);		// elements needed
          if((pLowLimit == NULL) || (pHighLimit == NULL))
          {
            Retcode = LNUM_OP_ALLOC_ERR;
            break;
          }
          //------------------------------------------------
          // generate lower limit 2**(l-1) (l = bitsize)
          //------------------------------------------------
          TmpBuf[0] = (unsigned char) 0x01;			// set LSB bit
          if((Retcode = WLnum_bin2wlnum(HMEM_CTX_REF1 pLowLimit,TmpBuf,0,1)) != LNUM_OP_OK)
            break;

          if((Retcode = LshiftWLnum(HMEM_CTX_REF1 pLowLimit,pLowLimit,BitCnt)) != LNUM_OP_OK)
            break;
          //------------------------------------------------
          // generate upper limit 2**l (l = bitsize)
          //------------------------------------------------
          if((Retcode = CopyWLnum(HMEM_CTX_REF1 pHighLimit,pLowLimit)) != LNUM_OP_OK)
            break;
          if((Retcode = Lshift1WLnum(HMEM_CTX_REF1 pHighLimit,pHighLimit)) != LNUM_OP_OK)
            break;
        }
        else					// no private key length
        {
          //------------------------------------------------
          // Allocate large numbers for comparison,
          // 1 < x < p-1	(Original: 0 < x < p-1)
          //------------------------------------------------
          NumLen = BitCnt / WELEMENT_BITS;		// size needed
          pLowLimit  = AllocNewWLnum(HMEM_CTX_REF1 1);	// only 1 element needed
          pHighLimit = AllocNewWLnum(HMEM_CTX_REF1 NumLen);		// elements needed
          if((pHighLimit == NULL) || (pLowLimit == NULL))
          {
            Retcode = LNUM_OP_ALLOC_ERR;
            break;
          }
          //------------------------------------------------
          // generate lower limit 1 and upper limit p-1
          //------------------------------------------------
          TmpBuf[0] = (unsigned char) 0x01;			// set Low limit
          if((Retcode = WLnum_bin2wlnum(HMEM_CTX_REF1 pLowLimit,TmpBuf,0,1)) != LNUM_OP_OK)
            break;

          if((Retcode = CopyWLnum(HMEM_CTX_REF1 pHighLimit,p)) != LNUM_OP_OK)
            break;

          if((Retcode = SubElementWLnum(pHighLimit,(int) 1)) != LNUM_OP_OK)
            break;
        }
      }
      else
      {
        //----------------------------------------------------------
        // Extended DH mode to use, check if q is present, get size
        //----------------------------------------------------------
        if(q == NULL)
          return(LNUM_OP_NULL_PTR);
        BitCnt = WLnum_BitSize(q);
        if(BitCnt <= 0)
          return(DSA_DH_KEY_SIZE_ERR);
        //------------------------------------------------
        // Allocate large numbers for comparison,
        // 1 < x < q-1	(Original: 0 < x < q-1)
        //------------------------------------------------
        NumLen = BitCnt / WELEMENT_BITS;		// size needed
        pLowLimit  = AllocNewWLnum(HMEM_CTX_REF1 1);// only 1 element needed
        pHighLimit = AllocNewWLnum(HMEM_CTX_REF1 NumLen);		// elements needed
        if((pHighLimit == NULL) || (pLowLimit == NULL))
        {
          Retcode = LNUM_OP_ALLOC_ERR;
          break;
        }
        //------------------------------------------------
        // generate lower limit 1 and upper limit q-1
        //------------------------------------------------
        TmpBuf[0] = (unsigned char) 0x01;			// set Low limit
        if((Retcode = WLnum_bin2wlnum(HMEM_CTX_REF1 pLowLimit,TmpBuf,0,1)) != LNUM_OP_OK)
          break;

        if((Retcode = CopyWLnum(HMEM_CTX_REF1 pHighLimit,q)) != LNUM_OP_OK)
          break;

        if((Retcode = SubElementWLnum(pHighLimit,(int) 1)) != LNUM_OP_OK)
          break;
      } // classic / enhanced DH
    } // DSA/DH
    break;
  } // Error FOR

  if(Retcode != LNUM_OP_OK)
  {
    FreeWLnum(HMEM_CTX_REF1 pHighLimit);
    FreeWLnum(HMEM_CTX_REF1 pLowLimit);
    return(Retcode);
  }

  //-----------------------------------------------------------------
  // All precalculations done, get the private value x
  //-----------------------------------------------------------------
//  PRINT("Start generating x value now...\n");

  if(callback != NULL)
  {
    callback(0);
  }

  do
  {

    i = WLnumRand(HMEM_CTX_REF1 x,BitCnt,TopFlag,0); // get random
    if(i != LNUM_OP_OK)
    {
      FreeWLnum(HMEM_CTX_REF1 pLowLimit);
      FreeWLnum(HMEM_CTX_REF1 pHighLimit);
//      PRINT("PRNG Err\n");
      return(DSA_DH_KEY_PRIV_GEN_ERR);
    }
    //------------------------------------------------------
    // Check if LowLimit < x < HighLimit
    //------------------------------------------------------
    LowCmp  = UcompWLnum(x,pLowLimit);
    HighCmp = UcompWLnum(x,pHighLimit); 
    if((LowCmp == WLNUM_1ST_GT_2ND) &&			// x above low limit
       (HighCmp == WLNUM_1ST_LT_2ND))			// x below high limit
      break;
    //------------------------------------------------------
    // x is outside interval ]LowLimit,HighLimit[ put inside
    //------------------------------------------------------
    if((Retcode = TransformLnumToInterval(HMEM_CTX_REF1
			x,pLowLimit,pHighLimit)) != LNUM_OP_OK)
    {
      FreeWLnum(HMEM_CTX_REF1 pLowLimit);
      FreeWLnum(HMEM_CTX_REF1 pHighLimit);
//      PRINT("PRNG Err\n");
      return(DSA_DH_KEY_PRIV_GEN_ERR);
    }
    LowCmp  = UcompWLnum(x,pLowLimit);
    HighCmp = UcompWLnum(x,pHighLimit); 
    if((LowCmp == WLNUM_1ST_GT_2ND) &&			// x above low limit
       (HighCmp == WLNUM_1ST_LT_2ND))			// x below high limit
      break;

//    PRINT(";");
    RetryCount--;
    if(callback != NULL)
    {
      callback(2);
    }
  }while(RetryCount != 0);

  FreeWLnum(HMEM_CTX_REF1 pLowLimit);
  FreeWLnum(HMEM_CTX_REF1 pHighLimit);

  if(RetryCount == 0)    
  {
//    PRINT("Too many retries\n");
    return(DSA_DH_KEY_PRIV_GEN_ERR);
  }
  //-----------------------------------------------------------------
  // Calculate public value: pub_key y = (g ** priv_key x) mod prime p
  //-----------------------------------------------------------------
  i = ExpModWLnum(HMEM_CTX_REF1 y,g,x,p,NULL,callback);

  if(i != LNUM_OP_OK)
    return(DSA_DH_KEY_PUBL_GEN_ERR);

  if(callback != NULL)
  {
    callback(3);
  }
  return(DSA_DH_OP_OK);
}

extern "C"  int CheckDsaDhPubValue(HMEM_CTX_DEF
		WLARGENUM* p, WLARGENUM* q, WLARGENUM* y)
{
  int Retcode;

  int i;
  int pLen,yLen;
  WLARGENUM* lpTmp = NULL;

  int CmpResult;
  //-----------------------------------------------------
  // Check for NULL pointers or invalid length of p,y
  //-----------------------------------------------------
  if((p == NULL) || (q == NULL) || (y == NULL))
    return(LNUM_OP_NULL_PTR);
  pLen = p->UsedSize;
  yLen = y->UsedSize;
  if((pLen == 0) || (yLen == 0))
    return(LNUM_OP_INVALID_PRIME);
  //-----------------------------------------------------
  // 1. Check if y is in the interval [2,...p-1]
  //-----------------------------------------------------
  if((yLen == 1) && ((y->lpEl[0] == 1) || (y->lpEl[0] == 0)))
    return(DSA_DH_CHK_INVALID_PUBVAL);		// invalid size

  i = UcompWLnum(y,p);		// compare
  if((i == WLNUM_1ST_GT_2ND) || (i == WLNUM_1ST_EQ_2ND))
    return(DSA_DH_CHK_INVALID_PUBVAL);		// invalid size
  //-----------------------------------------------------
  // 2. Check if (y ** q) mod p === 1
  //-----------------------------------------------------
  if((lpTmp = AllocNewWLnum(HMEM_CTX_REF1 pLen)) == NULL)
    return(LNUM_OP_ALLOC_ERR);

  if((Retcode = ExpModWLnum(HMEM_CTX_REF1 lpTmp,y,q,p,NULL,NULL)) != LNUM_OP_OK)
  {
    FreeWLnum(HMEM_CTX_REF1 lpTmp);
    return(Retcode);
  }
  CmpResult = IsOneWLnum(lpTmp);	// check result === 1
  FreeWLnum(HMEM_CTX_REF1 lpTmp);

//  if(CmpResult != TRUE)
  if(CmpResult == 0)
    return(DSA_DH_CHK_INVALID_PUBVAL);
  return(DSA_DH_OP_OK);
} 

extern "C"  int DSA_GenKey(HMEM_CTX_DEF DSA_STRUC* dsa)
{
  //-------------------------------------------------------
  // Generate public/private values
  //-------------------------------------------------------
// Following was wrong, for DSA 2**159 < X < 2**160 !!
//  return(GenDsaDhKey(0,DSA_p(dsa),DSA_g(dsa),DSA_y(dsa),DSA_x(dsa),NULL));
  return(GenDsaDhKey(HMEM_CTX_REF1
		MIN_DH_DSA_Q_BITS,0,0,
		dsa->p,dsa->q,dsa->g,dsa->y,dsa->x,
		NULL));
}

extern "C"  int DSA_GenParams(HMEM_CTX_DEF
				     int pBits, DSA_STRUC** pdsa,
				     void CallBack(int))
{
  int Retcode;
  int pLen,qLen;

  DSA_STRUC* dsa;
  //-------------------------------------------------------
  // Check parameters
  //-------------------------------------------------------
  if(pdsa == NULL) return(DSA_GEN_NULL_PTR_ERR);
  if(pBits < (MIN_DH_DSA_Q_BITS+2)) return(DSA_GEN_INV_BITSIZE_ERR);
  pdsa[0] = NULL;
  //-------------------------------------------------------
  // 1. Allocate DSA Structure
  //-------------------------------------------------------
  pLen = ((((pBits + 7)/8) + 1) + (WELEMENT_SIZE-1))/WELEMENT_SIZE;
  qLen = (((MIN_DH_DSA_Q_BITS+7)/8+1) + (WELEMENT_SIZE-1))/WELEMENT_SIZE;

  dsa = DSA_New(HMEM_CTX_REF1 pLen,qLen,pLen,pLen,pLen);
  if(dsa == NULL) return(DSA_GEN_ALLOC_ERR);

  //-------------------------------------------------------
  // 2. Generate parameters p,q,g
  //-------------------------------------------------------
  Retcode = GenDsaDhParams(HMEM_CTX_REF1 pBits,MIN_DH_DSA_Q_BITS,PRIME_CHECK_CNT,DSA_GEN_TYPE,dsa->p,dsa->q,dsa->g,NULL,NULL,NULL,CallBack);
  if(Retcode == DSA_DH_OP_OK)
  {
    //-------------------------------------------------------
    // 3. Generate public/private key y,x
    //-------------------------------------------------------
    Retcode = DSA_GenKey(HMEM_CTX_REF1 dsa);
  }
  if(Retcode != DSA_DH_OP_OK)
    DSA_Free(HMEM_CTX_REF1 dsa);
  else
    pdsa[0] = dsa;
  return(Retcode);
}

extern "C"  int DH_GenParams(HMEM_CTX_DEF
				    int pBits, int qBits, DH_STRUC** pdh,
				    void CallBack(int))
{
  int Retcode;
  int pLen;
  int qLen;

  int pTmpInt[1];

  DH_STRUC* dh;
  //-------------------------------------------------------
  // Check parameters
  //-------------------------------------------------------
  if(pdh == NULL) return(DH_GEN_NULL_PTR_ERR);
  if((qBits < MIN_DH_DSA_Q_BITS) ||(pBits < qBits))
    return(DH_GEN_INV_BITSIZE);
  pdh[0] = NULL;
  //-------------------------------------------------------
  // 1. Allocate DH Structure
  //-------------------------------------------------------
  pLen = ((((pBits + 7)/8) + 1) + WELEMENT_SIZE - 1)/WELEMENT_SIZE;
  qLen = ((((qBits + 7)/8) + 1) + WELEMENT_SIZE - 1)/WELEMENT_SIZE;

  dh = DH_New(HMEM_CTX_REF1 pLen,qLen,pLen,pLen,pLen);
  if(dh == NULL) return(DH_GEN_ALLOC_ERR);
  //-------------------------------------------------------
  // 2. Generate parameters p,q,g,j,Seed and PgenCount
  //-------------------------------------------------------
  Retcode = GenDsaDhParams(HMEM_CTX_REF1 pBits,qBits,PRIME_CHECK_CNT,DH_GEN_TYPE,dh->p,dh->q,dh->g,dh->j,dh->Seed,pTmpInt,CallBack);
  if(Retcode != DSA_DH_OP_OK)
    DH_Free(HMEM_CTX_REF1 dh);
  else
  {
    dh->PgenCount = pTmpInt[0];
    pdh[0] = dh;
  }
  return(Retcode);
}

extern "C"  int DH_GenKey(HMEM_CTX_DEF
				 DH_STRUC* dh, void callback(int))
{
  int DhMode = 0;
  int PrivLen;
  //-------------------------------------------------------
  // assure that we get the correct length for private key
  //-------------------------------------------------------
  PrivLen = dh->PrivLen;		// get preset value
  if(PrivLen > 0)			// one is selected, classic mode
  {
    DhMode = 0;
//    PRINT("Set DH Classic Mode");
  }
  else					// none selected, assume enhanced mode
  {
    PrivLen = 0;			// we use the defaults
    DhMode  = 1;
//    PRINT("Assume DH Enhanced Mode");
    if((dh->q == NULL) || (dh->q->UsedSize <= 0))
    {
      DhMode = 0;			// back to classic mode
//      PRINT("Back to DH Classic Mode");
    }
  }
  //-------------------------------------------------------
  // Generate public/private values
  //-------------------------------------------------------
  return(GenDsaDhKey(HMEM_CTX_REF1
		     PrivLen,1,DhMode,dh->p,dh->q,
		     dh->g,dh->PubKey,dh->PrivKey,callback));
}

extern "C"  int DH_GenSecret(HMEM_CTX_DEF
		char** ppDstBuf, int* pDstLen, DH_STRUC* dh)
{
  int i;
  int pLen;
  int Retcode = DH_OP_OK;

  char* pBuf = NULL;

  WLARGENUM* lptmplnum = NULL;
  //----------------------------------------------------------
  // check if prime p, Base g, private value x and public value
  // y are present and valid
  //----------------------------------------------------------
  if((dh == NULL) || (dh->p == NULL) ||
     (dh->PrivKey == NULL) || (dh->PubKey == NULL) ||
     (ppDstBuf == NULL) || (pDstLen == NULL) ||
     ((pLen = dh->p->UsedSize) == 0) ||
     (dh->g->UsedSize == 0) ||
     (dh->PubKey->UsedSize == 0) ||
     (dh->PrivKey->UsedSize == 0))
    return(DH_COMPUTE_KEY_INV_DATA);
  ppDstBuf[0] = NULL;
  pDstLen[0] = 0;
  //--------------------------------------------------------------
  // Allocate large numbers for calculation and destination buffer
  //--------------------------------------------------------------
  lptmplnum = AllocNewWLnum(HMEM_CTX_REF1 pLen);	// get pointer
  pLen = GetByteCntWLnum(dh->p);
  pBuf = BIT8_ARRAY_ALLOC(HMEM_CTX_REF,pLen+1);		// get buffer
  if((lptmplnum == NULL) || (pBuf == NULL))
  {
    FreeWLnum(HMEM_CTX_REF1 lptmplnum);
    FREE_ARRAY(HMEM_CTX_REF,pBuf);
    return(DH_COMPUTE_KEY_ALLOC_ERR);
  }
  ppDstBuf[0] = pBuf;
  pDstLen[0] = pLen+1;
  //----------------------------------------------------------
  // Calculate secret Z
  //----------------------------------------------------------

  i = ExpModWLnum(HMEM_CTX_REF1 lptmplnum,dh->PubKey,dh->PrivKey,dh->p,NULL,NULL);
  if(i != LNUM_OP_OK)
  {
//      PRINT("\nExpMod");PRINT_INT(i);PRINT("\n");	// TEST TEST TEST
    Retcode = DH_COMPUTE_KEY_EXPMOD_ERR;
  }
  else
  {
							// convert back	
    if((i = WLnum_wlnum2bin(pBuf,0,pDstLen,lptmplnum,0)) != LNUM_OP_OK)
    {
      Retcode = DH_COMPUTE_KEY_LNUM_TO_BIN_ERR;
//      PRINT("\nLNUM_Conv");PRINT_INT(i);PRINT("\n");	// TEST TEST TEST
    }
  }

  FreeWLnum(HMEM_CTX_REF1 lptmplnum);
  if(Retcode != DH_OP_OK)
  {
    ppDstBuf[0] = NULL;
    pDstLen[0] = 0;
    FREE_ARRAY(HMEM_CTX_REF,pBuf);
  }    
  return(Retcode);  
}

extern "C" DH_STRUC* m_dh_gen_named_group(HMEM_CTX_DEF
                                          ie_dh_named_groups iep_group_name)
{
    // We look up the requested group and generate the structure of required size
    dsd_diffie_hellman_group& dsl_requested_group = dsrs_named_groups[iep_group_name];
    
    int inl_p_element_count = (int)((dsl_requested_group.szc_modulus_p_len+3)/4);
    int inl_g_element_count = (int)((dsl_requested_group.szc_generator_g_len+3)/4);
    int inl_q_element_count = (int)((dsl_requested_group.szc_group_size_q_len+3)/4);
    DH_STRUC* adsl_new_group = DH_New(HMEM_CTX_REF1 
                                      inl_p_element_count,
                                      inl_q_element_count,
                                      inl_g_element_count,
                                      inl_p_element_count,
                                      inl_p_element_count);

    if(adsl_new_group == NULL){
        return adsl_new_group;
    }

    // Now we just have to read the numbers
    int inl_error = WLnum_bin2wlnum(HMEM_CTX_REF1 
                                    adsl_new_group->p,
                                    (char*) dsl_requested_group.abyc_modulus_p,
                                    0,
                                    static_cast<int>(dsl_requested_group.szc_modulus_p_len));
    if(inl_error != LNUM_OP_OK){
        DH_Free(HMEM_CTX_REF1 adsl_new_group);
        return NULL;
    }

    inl_error = WLnum_bin2wlnum(HMEM_CTX_REF1 
                                adsl_new_group->q,
                                (char*) dsl_requested_group.abyc_group_size_q,
                                0,
                                static_cast<int>(dsl_requested_group.szc_group_size_q_len));
    if(inl_error != LNUM_OP_OK){
        DH_Free(HMEM_CTX_REF1 adsl_new_group);
        return NULL;
    }
    
    inl_error = WLnum_bin2wlnum(HMEM_CTX_REF1 
                                adsl_new_group->g,
                                (char*) dsl_requested_group.abyc_generator_g,
                                0,
                                static_cast<int>(dsl_requested_group.szc_generator_g_len));
    if(inl_error != LNUM_OP_OK){
        DH_Free(HMEM_CTX_REF1 adsl_new_group);
        return NULL;
    }

    return adsl_new_group;
}

/** @} */
// old version !!!


#endif //HL_ENCR_DSA
// end of file ../DSA/d3.cpp


#ifdef HL_ENCR_DSA
//**************************************************************
//
// DSA Raw Signing / Verification Module
//
//**************************************************************
#include <stdlib.h>
#include <string.h>
#if (defined _WIN32) & (_MSC_VER < 1700)
#ifndef _STDINT
#define _STDINT
// MSVC lower than 17.00 does not have stdint.h, assure, all needed types are defined

typedef unsigned __int16 uint16_t;

typedef unsigned __int32 uint32_t;

typedef unsigned __int64 uint64_t;

#endif // !_STDINT
#else
#include <stdint.h>
#endif
#include <stddef.h>
#ifdef _WIN32
#define WIN32_LEAN_AND_MEAN
#include <Windows.h>
#undef WIN32_LEAN_AND_MEAN
#else// Define system-specific HL_* defines here
#ifndef HL_UNIX
#define HL_UNIX

#if (defined __gnu_linux__) || (defined __linux__)
#define HL_LINUX
#endif

#if (defined __APPLE__) && (defined __MACH__)
#define HL_LINUX
#define HL_MACOS
#endif

#ifdef _AIX
#define HL_AIX
#define HL_BIG_ENDIAN
#endif

#ifdef __FreeBSD__
#define HL_FREEBSD
#endif

#if (defined _hpux) || (defined hpux) || (defined __hpux)
#define HL_HPUX
#define HL_BIG_ENDIAN
#endif

#if (defined sun) || (defined __sun)
#define HL_SOLARIS
#endif

#if (defined __arm__) || (defined __aarch64__)
#define HL_LINUX_ARM
#endif

#ifdef __ANDROID__
#define HL_ANDROID
#endif

#endif
#include <hob-unix01.h>
#endif
#ifdef __APPLE__
/* We get target conditionals to keep apart Mac OS, iOS and iOS simulator.
   The conditionals are TARGET_IPHONE_SIMULATOR, TARGET_OS_IPHONE and TARGET_OS_MAC.
   TARGET_IPHONE_SIMULATOR has the highest priority, TARGET_OS_MAC the lowest.
   Always test, if the conditional is 1, as they will be defined as 0, if we 
   are not compiling for the target.
   */
#include <TargetConditionals.h>
#endif

#include "hob-encry-1.h"
#include "hob-encry-intern-1.h"

#define	DSARAW_NULL_PTR			-1
#define	DSARAW_INVALID_PARAMETER	-2
#define	DSARAW_BUFFER_TOO_SMALL		-3	// redefine ?

extern "C"  int DSA_SignRaw(HMEM_CTX_DEF
		char* pDgstBuf, int DgstOffset,
		int DgstLen, char* pSigBuf, int SigOffset, int* pSigLen,
		DSA_STRUC* dsa, WLARGENUM* kTest)
{

  int NumLen,rLen,sLen;

  int ret=DSA_OP_OK;
  int reason=LNUM_OP_OK;

  int pTmpLen[1];

  WLARGENUM* m = NULL;
  WLARGENUM* k = NULL;
  WLARGENUM* kinv = NULL;
  WLARGENUM* r = NULL;
  WLARGENUM* s = NULL;
  //------------------------------------------------------------
  // Check Parameters ahead
  //------------------------------------------------------------
  if((pDgstBuf == NULL) || (pSigBuf == NULL) || (dsa == NULL) ||
     (pSigLen == NULL))
    return(DSA_DH_NULL_PTR);

  if(pSigLen[0] < (2*SHA_DIGEST_LEN))
    return(DSA_SIGN_BUFFER_TOO_SMALL);

  if(DgstLen != SHA_DIGEST_LEN)
    return(DSA_SIGN_INVALID_HASH_LEN);
  //------------------------------------------------------------
  // Clear signing buffer
  //------------------------------------------------------------
//  pSigLen[0] = 0;
  memset(pSigBuf+SigOffset,0,(2*SHA_DIGEST_LEN));

  for(;;)				// outer processing loop
  {
    //---------------------------------------------------
    // allocate required large numbers
    //---------------------------------------------------
    if(dsa->q->UsedSize > dsa->p->UsedSize)
      NumLen = dsa->q->UsedSize;
    else
      NumLen = dsa->p->UsedSize;

    m = AllocNewWLnum(HMEM_CTX_REF1 NumLen);
    r = AllocNewWLnum(HMEM_CTX_REF1 NumLen);
    s = AllocNewWLnum(HMEM_CTX_REF1 NumLen);
    k = AllocNewWLnum(HMEM_CTX_REF1 NumLen);
    kinv = AllocNewWLnum(HMEM_CTX_REF1 NumLen);
    if(m == NULL || r == NULL || s == NULL || k == NULL || kinv == NULL)
    {
      reason = LNUM_OP_ALLOC_ERR;
      break;
    }
    //-----------------------------------------------------
    // convert digest from binary to large number for calc,
    // get 160 Bit Random, compute s and r params
    //-----------------------------------------------------
						// to large number
    if((reason = WLnum_bin2wlnum(HMEM_CTX_REF1 m,pDgstBuf,DgstOffset,SHA_DIGEST_LEN)) != LNUM_OP_OK)
      break;

    if(kTest != NULL)
      reason = CopyWLnum(HMEM_CTX_REF1 k,kTest); // use given value
    else
      reason = WLnumRand(HMEM_CTX_REF1 k,160,1,0);// get 160 Bit random
    if(reason != LNUM_OP_OK)
      break;

    // Compute r = (g^k mod p) mod q

							// s = g^k mod p
    if((reason = ExpModWLnum(HMEM_CTX_REF1 s,dsa->g,k,dsa->p,NULL,NULL)) != LNUM_OP_OK)
      break;
							// r = s mod q
    if((reason = DivWLnum(HMEM_CTX_REF1 NULL,r,s,dsa->q,NULL)) != LNUM_OP_OK)
      break;

    // Compute  s = inv(k) (m + xr) mod q
							// s = x * r
    if((reason = MulWLnum(HMEM_CTX_REF1 s,dsa->x,r)) != LNUM_OP_OK)
      break;
							// s = x * r + m
    if((reason = AddWLnum(HMEM_CTX_REF1 s,s,m)) != LNUM_OP_OK)
      break;
							// kinv = k^-1 mod q
    if((reason = InvModWLnum(HMEM_CTX_REF1 kinv,k,dsa->q,NULL)) != LNUM_OP_OK)
      break;
							// s = (s * kinv) mod q
    if((reason = MulModWLnum(HMEM_CTX_REF1 s,s,kinv,dsa->q,NULL)) != LNUM_OP_OK)
      break;
    //------------------------------------------------------
    // get length for r store large number
    //------------------------------------------------------
//  rLen = WLNUM_UsedSize(r);				// get length
    rLen = GetByteCntWLnum(r);		// new !!
    pTmpLen[0] = rLen; 

    if((reason = WLnum_wlnum2bin(pSigBuf,SigOffset+SHA_DIGEST_LEN-rLen,pTmpLen,r,0)) != LNUM_OP_OK)
      break;

    SigOffset += SHA_DIGEST_LEN;

//  sLen = WLNUM_UsedSize(s);				// get length
    sLen = GetByteCntWLnum(s);		// new !!
    pTmpLen[0] = sLen; 

    reason = WLnum_wlnum2bin(pSigBuf,SigOffset+SHA_DIGEST_LEN-sLen,pTmpLen,s,0);
    break;
  } // for
  FreeWLnum(HMEM_CTX_REF1 m);
  FreeWLnum(HMEM_CTX_REF1 r);
  FreeWLnum(HMEM_CTX_REF1 s);
  FreeWLnum(HMEM_CTX_REF1 k);
  FreeWLnum(HMEM_CTX_REF1 kinv);
  if(reason != LNUM_OP_OK)
    return(DSA_SIGN_LNUM_ERR);
  return(ret);
}

extern "C"  int DSA_VerifyRaw(HMEM_CTX_DEF
		char* pDgstBuf, int DgstOffset,
		int DgstLen, char* pSigBuf, int SigOffset, int SigLen,
		DSA_STRUC* dsa)
{
  int i,NumLen;
  int ret = DSA_OP_OK;
  int reason = LNUM_OP_OK;

  WLARGENUM* r  = NULL;
  WLARGENUM* t1 = NULL;
  WLARGENUM* t2 = NULL;
  WLARGENUM* u1 = NULL;
  WLARGENUM* u2 = NULL;
  //------------------------------------------------------------
  // Check Parameters ahead
  //------------------------------------------------------------
  if((pDgstBuf == NULL) || (pSigBuf == NULL) || (dsa == NULL))
    return(DSA_DH_NULL_PTR);

  if(SigLen < (2 * SHA_DIGEST_LEN))
    return(DSA_VERIFY_SIGNAT_TOO_SMALL);

  if(DgstLen != SHA_DIGEST_LEN)
    return(DSA_VERIFY_INVALID_HASH_LEN);
  //-----------------------------------------------
  // FOR-Loop for easier error handling
  //-----------------------------------------------
  for(;;)
  {
    //---------------------------------------------
    // Allocate temporary large numbers
    //---------------------------------------------
    if(dsa->q->UsedSize > dsa->p->UsedSize)
      NumLen = dsa->q->UsedSize;
    else
      NumLen = dsa->p->UsedSize;

    r  = AllocNewWLnum(HMEM_CTX_REF1 NumLen);
    u1 = AllocNewWLnum(HMEM_CTX_REF1 NumLen);
    u2 = AllocNewWLnum(HMEM_CTX_REF1 NumLen);
    t1 = AllocNewWLnum(HMEM_CTX_REF1 NumLen);
    t2 = AllocNewWLnum(HMEM_CTX_REF1 NumLen);
    if((r==NULL) || (u1==NULL) || (u2==NULL) || (t1==NULL) || (t2 == NULL))
    {
      ret = DSA_VERIFY_ALLOC_ERR;
      break;
    }
    //---------------------------------------------
    // 1. load number r into LNUM structure
    //---------------------------------------------
    if((reason = WLnum_bin2wlnum(HMEM_CTX_REF1 r,pSigBuf,SigOffset,SHA_DIGEST_LEN)) != LNUM_OP_OK)
      break;

    SigOffset += SHA_DIGEST_LEN;
    //---------------------------------------------
    // 2. load number s into LNUM structure
    //---------------------------------------------
    if((reason = WLnum_bin2wlnum(HMEM_CTX_REF1 u1,pSigBuf,SigOffset,SHA_DIGEST_LEN)) != LNUM_OP_OK)
      break;
    //-----------------------------------------------------------
    // Calculate w = (S^-1) mod q
    //-----------------------------------------------------------
							//w = u2 = (s^-1) mod q
    if((reason = InvModWLnum(HMEM_CTX_REF1 u2,u1,dsa->q,NULL)) != LNUM_OP_OK)
      break;
						 // convert M to long number
    if((reason = WLnum_bin2wlnum(HMEM_CTX_REF1 u1,pDgstBuf,DgstOffset,SHA_DIGEST_LEN)) != LNUM_OP_OK)
      break;
    //-----------------------------------------------------------
    // Calculate u1 = (M' * w) mod q
    //-----------------------------------------------------------
							//u1 = (M'* w) mod q
    if((reason = MulModWLnum(HMEM_CTX_REF1 u1,u1,u2,dsa->q,NULL)) != LNUM_OP_OK)
      break;
    //-----------------------------------------------------------
    // Calculate u2 = (r' * w) mod q
    //-----------------------------------------------------------
							// u2 = (r'* w) mod q
    if((reason = MulModWLnum(HMEM_CTX_REF1 u2,r,u2,dsa->q,NULL)) != LNUM_OP_OK)
      break;
    //-----------------------------------------------------------
    // Calculate v = (((g^u1) * (y^u2)) mod p) mod q =
    //                (((g^u1) mod p) * ((y^u2) mod p) mod p) mod q
    //-----------------------------------------------------------
							// t1 = (g^u1) mod p
    if((reason = ExpModWLnum(HMEM_CTX_REF1 t1,dsa->g,u1,dsa->p,NULL,NULL)) != LNUM_OP_OK)
      break;
							// t2 = (y^u2) mod p
    if((reason = ExpModWLnum(HMEM_CTX_REF1 t2,dsa->y,u2,dsa->p,NULL,NULL)) != LNUM_OP_OK)
      break;
							// u2 = (t1 * t2) mod p
    if((reason = MulModWLnum(HMEM_CTX_REF1 u2,t1,t2,dsa->p,NULL)) != LNUM_OP_OK)
      break;
							// u1 = u2 mod q
    if((reason = DivWLnum(HMEM_CTX_REF1 NULL,u1,u2,dsa->q,NULL)) != LNUM_OP_OK)
      break;
    //-----------------------------------------------------------
    // V is now in u1.  If the signature is correct, it will be
    // equal to R.
    //-----------------------------------------------------------
    i = UcompWLnum(u1,r);			// compare
    if(i != WLNUM_1ST_EQ_2ND)
      ret = DSA_VERIFY_INVALID_SIGNAT;
    break;
  } // Error FOR loop
  FreeWLnum(HMEM_CTX_REF1 r);
  FreeWLnum(HMEM_CTX_REF1 t1);
  FreeWLnum(HMEM_CTX_REF1 t2);
  FreeWLnum(HMEM_CTX_REF1 u1);
  FreeWLnum(HMEM_CTX_REF1 u2);
  if(reason != LNUM_OP_OK)
    return(DSA_VERIFY_LNUM_ERR);
  return(ret);
}


#endif //HL_ENCR_DSA
// end of file ../DSA/d4.cpp


#ifdef HL_ENCR_RAND
//
//******************************************************************************
//
// Random Number Generation
// ========================
//
// HOBLink Secure, HOB GmbH & Co KG, Cadolzburg
//
// Implementation of the random number generator 
// for HOBLink Secure and HOBLink SSH.
//
//
// Development history:
// Version  Programmer     Date        Description of Amendment/Addition
// ---------------------------------------------------------------------
//
// 000442   Schmid, Lutz   17.06.2015  Function m_execute_command modified to kill the 
//                                     child process in case that a timeout occurred.
// 000441   Schmid, Lutz   28.04.2015  Functions SysGetEntropy for Windows, HashEvtDir, 
//                                     GetNetHashes, HashPerfInfo, HashSysTimes and 
//                                     m_getdrivegeometry modified to remove character 
//                                     set dependencies.
// 000440   Schmid, Lutz   20.04.2015  Including hob-xsclib01.h was implemented with the 
//                                     wrong precompiler dependency logic (copy-paste-error).
// 000439   Schmid, Lutz   15.04.2015  In function m_add_qualified_seed_impl the code for 
//                                     retrieving seed data from a seeder daemon is now 
//                                     implemented. The seed data are returned from a call 
//                                     to the aux-function in a XH_INTERFACE environment. 
//                                     Header file "hob-xsclib01.h" is added for the aux-call.
//                                     Used buffer size in function m_print_dir increased, 
//                                     because valgrind reported that one byte behind the 
//                                     buffer is accessed.
// 000438   Schmid, Lutz   02.02.2015  Function m_add_qualified_seed renamed to 
//                                     m_add_qualified_seed_impl and a new function 
//                                     m_add_qualified_seed added which is a synchronization 
//                                     wrapper function for m_add_qualified_seed_impl.
// 000437   Schmid, Lutz   16.01.2015  Function m_add_qualified_seed added and functions 
//                                     SecDrbgInit_impl, SecDrbgRandBytes_impl and 
//                                     m_secdrbg_randbytes_impl changed. Now the function 
//                                     SysGetEntropy is only called from m_add_qualified_seed 
//                                     and the changed functions only call 
//                                     m_add_qualified_seed. The function 
//                                     m_add_qualified_seed can also be called to force a 
//                                     qualified reseeding of the random generator 
//                                     independently from the reseed counter. 
// 000436   Schmid, Lutz   15.01.2015  Console output and spacing corrected.
// 000435   Schulze, S.    02.12.2014  Added code to define _WIN32_WINNT macro. This 
//                                     makes sure, that TryEnterCriticalSection function 
//                                     is available on Windows systems.
// 000434   Schulze, S.    01.12.2014  Changed synchronization to directly use 
//                                     dsd_hcla_critsect_1_ex and its scoped lock classes, 
//                                     instead of the wrapper functions from 
//                                     crit_sect_ext_c.cpp
// 000433   Schulze, S.    27.11.2014  Changed file type to cpp (C++ source). Following 
//                                     changes were done in the process of separating C
//                                     and Java code:
//                                       - All ifdef sections for Java, debug code and 
//                                         unused code were removed.
//                                       - Headers were restructured, now there are three 
//                                         headers for encryption code: hob_encry_intern_1.h, 
//                                         hob-encry-1.h, hob_encry_err_1.h.
//                                       - Preprocessor macros used to allow compiling for 
//                                         Java were expanded as possible (e.g. BIT32 or 
//                                         SHA256_INIT).
// 000432   Schulze, S.    06.10.2014  Reverted partial rollback from last change.
// 000431   Schulze, S.    01.10.2014  Patial version rollback: removed all critical sections 
//                                     to make a stable release.
// 000430   Schmid, Lutz   29.09.2014  Debug output now deactivated in function 
//                                     'm_execute_command'. Function 'waitpid' 
//                                     is called in a loop.
// 000429   Schmid, Lutz   29.09.2014  Call to function 'waitpid' modified and 
//                                     DEBUG output activated in 'm_execute_command'.
// 000428   Schmid, Lutz   29.09.2014  Compatibility define "PSAPI_VERSION=1" added
//                                     for builds in Visual Studio 2005. Visual Studio 2012 
//                                     uses a newer version of the pasapi library.
// 000427   Schmid, Lutz   24.09.2014  Functions CTR_DRBG_Update128 and BlockCipherDf_AES128 
//                                     changed to force the AES algorithm calls not to use 
//                                     the CPU AES support, as it is not available fom the 
//                                     configuration whether to use the CPU support.
// 000426   Schulze, S.    02.09.2014  Refactored all public functions (SecDrbgInit, 
//                                     SecDrbgRandBytes, m_ssl_seed_rng, m_secdrbg_randbytes,
//                                     SecDrbgRandBytes_Test and CTR_DRBG_AddSeed256). The 
//                                     normal code is now in a private function named (
//                                     old_name)_impl, while the public functions just make a 
//                                     call to the implementation functions, protected by a 
//                                     critical section. This makes the module completely 
//                                     thread safe.
// 000425   Schmid, Lutz   01.09.2014  Function m_execute_command changed to avoid 
//                                     a buffer read beyond the buffer size.
// 000424   Schmid, Lutz   05.08.2014  Copy-paste bug corrected in SysGetEntropy 
//                                     for Linux/UNIX systems.
// 000423   Schulze, S.    07.07.2014  Fixed include of hob-unix01.h after moving 
//                                     it to the module include folder.
// 000422   Schmid, Lutz   19.05.2014  Several modifications for the Android OS 
//                                     implemented. Function m_print_dir changed 
//                                     to remove an oversized read when setting 
//                                     the buffer size to SSIZE_MAX.
// 000421   Schmid, Lutz   06.05.2014  AES flag initialized in function 
//                                     CTR_DRBG_Generate128.
// 000420   Schulze, S.    01.04.2014  Another pragma added for the linker (Psapi.lib)
// 000419   Schmid, Lutz   01.04.2014  Pragma commands added for the linker  
// 000418   Schmid, Lutz   17.03.2014  Function HashSysTimes updated to prevent 
//                                     a possible FreeLibrary leak.
// 000417   Schmid, Lutz   17.02.2014  Functions m_hashdevrandom and SysGetEntropy
//                                     for Linux/UNIX changed to solve a problem 
//                                     when running the rn2 module on an ARM processor 
//                                     system on the HOB privacy cube micro PC.
// 000416   Schmid, Lutz   14.01.2014  Function m_user_entropy_test_estma changed 
//                                     to test the availability of the input array 
//                                     before testing a possible length mismatch.
// 000415   Schmid, Lutz   23.10.2013  The file "../htrace/hob-unix01.h" is now 
//                                     included for non-XH environments on UNIX 
//                                     platforms to define the BOOL macro.
//                                     A call to 'PrintAux' in function SysGetEntropy 
//                                     was not guarded by a precompiler ifdef embracing.
// 000414   Schmid, Lutz   13.08.2013  Function m_ssl_seed_rng updated to use the 
//                                     precompiler defined versions of BOOL.
// 000413   Schmid, Lutz   18.06.2013  The import of java.util.Locale was missing 
//                                     for the modification of the UpperCase method 
//                                     done in version 000411 on 17.06.2013.
// 000412   Schmid, Lutz   18.06.2013  Function m_ssl_seed_rng implemented 
//                                     according to a request by 
//                                     Mr. K. Brandstaetter.
// 000411   Schmid, Lutz   17.06.2013  Method m_hashdevrandom (Java version) 
//                                     updated to remove a potential null pointer 
//                                     error when clsoing the stream. Method 
//                                     GetOsTypeVersion updated when examining 
//                                     the Java property value "os.name" to use 
//                                     the English locale for executing the 
//                                     UpperCase method.
// 000410   Schmid, Lutz   17.04.2013  Method m_entropyassessment(6 parameters) 
//                                     changed. Now the correct value from the 
//                                     RNG test function is return in case that 
//                                     an error is detected.
// 000409   Schmid, Lutz   11.04.2013  Method m_user_entropy_test_estma updated 
//                                     to the latest version of the mathematical 
//                                     modelling of the entropy source "user 
//                                     interaction". Keyboard entropy has maximum 
//                                     3.25 bit per event, Mouse entropy has 
//                                     maximum 2.0 bit per event. Function 
//                                     m_calc_pi_wallis now returns the average 
//                                     Pi value of all loops.
// 000408   Schmid, Lutz   22.01.2013  Some comments are expanded to provide more 
//                                     information on assuring entropy quality.
//                                     Entropy estimator for the server side on 
//                                     Linux OSs is improved and performs 
//                                     additional tests for the OS-API time.
// 000407   Schmid, Lutz   17.01.2013  Some comments are expanded. The entropy 
//                                     estimation for Windows and Linux is 
//                                     improved in the method SysGetEntropy for 
//                                     Linux and Windows. The method 
//                                     m_calc_pi_wallis is changed to compensate 
//                                     CPUs that have lesser performance as 
//                                     originally expected.
// 000406   Schmid, Lutz   11.12.2012  Method m_test_entropy_data changed to 
//                                     return the entropy estimation value.
//                                     Method m_user_entropy_test_estma changed 
//                                     and the latest research results imple-
//                                     mented how to estimate the entropy value.
//                                     Some code added to prepare the processing 
//                                     of the entropy gathering in a separate 
//                                     thread when running with the WSP.
// 000405   Schmid, Lutz   06.12.2012  Method m_checkeventtimearr removed 
//                                     and replaced by method 
//                                     m_user_entropy_test_estimation.
//                                     Method m_user_entropy_test_estma added 
//                                     newly that performs the entropy 
//                                     estimation for the user-related entropy 
//                                     gathering. Methods m_entropyassessment, 
//                                     m_test_entropy_data and 
//                                     m_test_user_entropy_data updated to use 
//                                     the new methods mentioned above.
// 000404   Schmid, Lutz   28.11.2012  Method m_checkeventtimearr for the 
//                                     Java version updated to the latest 
//                                     result that resulted from mathematical 
//                                     research on test data.
// 000403   Schmid, Lutz   12.10.2012  New tests added to the method 
//                                     m_calc_pi_wallis. JavaDoc for method
//                                     m_entropyassessment improved and 
//                                     IM_MIN_GOOD_EVENTVALUES changed to 
//                                     16 according to a BSI request.
// 000402   Schmid, Lutz   27.09.2012  New methods m_test_entropy_data and 
//                                     CTR_DRBG_AddSeed256 with offset and 
//                                     length added for use in HOBLink JWT.
// 000401   Schmid, Lutz   19.09.2012  More Doxygen/JavaDoc comments added.
// 000400   Schmid, Lutz   06.07.2012  More refactoring work done to implement 
//                                     the changes that are discussed in the 
//          RNG document for the CC certification after the mathematical 
//          modelling of the entropy sources is finished.
//
// ......   Oed, Gerhard / Schmid, Lutz  continuous changes
//
// 000000   Oed, Gerhard   29.10.2009  Module started as rn2 after a 
//                                     refactoring of r0 and r1.
//
//******************************************************************************
//
/** @defgroup rand PRNG
*
* Random Number Generation
*
* HOBLink Secure, HOB GmbH & Co KG, Cadolzburg
*
* This module contains the implementation of the random number generator 
* for HOBLink Secure and HOBLink SSH for all platforms and OSs and for C 
* and Java languages.
* The generator implements the NIST AES based random generator functions 
* according to the "DRBG Mechanisms Based on Block Ciphers" as specified 
* in NIST Special Publication 800-90A. This RNG implementation includes 
* entropy gathering and allows addition of externally provided entropy 
* data with internal testing and without further testing of the passed 
* entropy data. <br>
* Entropy gathering varies for the different operating systems and the 
* scenario in which the software is used. One important part of the 
* entropy in a server environment is gained from the unpredictability of 
* details of processes executed by the CPU and controlled by the OS and 
* the time duration that is needed to execute a certain part of source 
* code. For this reason it is not the author's intention to provide 
* source code (concerning entropy related functions) that is implemented 
* in an optimized way, in fact the opposite is realized meaning that 
* cumbersome code is written on purpose hoping that the compiler does 
* not add too much optimization. For the client side use it is possible 
* to add entropy from user interaction that is collected as time events 
* from keyboard input or mouse movement in an application GUI.
*
*
* C compile options: <br>
* "__DEBUG__"       - outputs additional texts with a lot of different results <br>
* "__DEBUG_INFO__"  - shows hashed data length and random counters <br>
* "__DEBUG_WIN__"
*
*
*@{
*@file
*
* This file contains the implementation of the random number generator for 
* HOBLink Secure and HOBLink SSH for all platforms and OSs and for C and Java languages.
*
* Linux/UNIX compile samples
* --------------------------
*
* Linux, Intel/AMD EM64T, 64 bit:
* g++ -g -m64 -W -Wall -DHL_UNIX -DHL_LINUX [-D__DEBUG__] -I../source/include -o ../source/RAND/rn2.o -c ../source/RAND/rn2.c
*
* Linux, Intel x86, 32 bit:
* g++ -g -m32 -W -Wall -DHL_UNIX -DHL_LINUX [-D__DEBUG__] -I../source/include -o ../source/RAND/rn2.o -c ../source/RAND/rn2.c
*
* AIX, PowerPC, 64 bit:
* gcc -g -DHL_UNIX -DHL_AIX -W -Wall -D_REENTRANT [-D__DEBUG__] -I../source/include -o ../source/RAND/rn2.o -c ../source/RAND/rn2.c
*
* FreeBSD, Intel x86, 32 bit:
* gcc -g -DHL_UNIX -DHL_FREEBSD -W -Wall -D_REENTRANT [-D__DEBUG__] -I../source/include -o ../source/RAND/rn2.o -c ../source/RAND/rn2.c
*
* HP/UX, Intel Itanium, 64 bit:
* cc -g +DD64 +z -DHL_UNIX -DHL_HPUX -D_REENTRANT [-D__DEBUG__] -I../source/include -o ../source/RAND/rn2.o -c ../source/RAND/rn2.c
*
* HP/UX, PA-Risc, 64 bit
* cc -g +DA2.0W  +z -DHL_UNIX -DHL_HPUX -D_REENTRANT [-D__DEBUG__] -I../source/include -o ../source/RAND/rn2.o -c ../source/RAND/rn2.c
*
* Solaris, Intel/AMD EM64T or SPARC, 64 bit:
* cc -g -m64 -DHL_UNIX -DHL_SOLARIS -erroff=E_WHITE_SPACE_IN_DIRECTIVE -D_REENTRANT -D_RWSTD_MULTI_THREAD [-D__DEBUG__] -I../source/include -o ../source/RAND/rn2.o -c ../source/RAND/rn2.c
*
* MAC OS, Intel, 64 bit:
* gcc -g -m64 -W -Wall -DHL_UNIX -DHL_LINUX -DHL_MACOS [-D__DEBUG__] -I../source/include -o ../source/RAND/rn2.o -c ../source/RAND/rn2.c
*
* MAC OS, Intel, 32 bit:
* gcc -g -m32 -W -Wall -DHL_UNIX -DHL_LINUX -DHL_MACOS [-D__DEBUG__] -I../source/include -o ../source/RAND/rn2.o -c ../source/RAND/rn2.c
*@}
*/

#if defined _WIN32
// In Visual Studio 2012 a new psapi library version is used. The following define forces version 1 to be used.
#define PSAPI_VERSION 1

#if (!defined _WIN32_WINNT) & (_MSC_VER < 1700)
// required later for TryEnterCriticalSection
#define _WIN32_WINNT 0x0400
#endif
#include <windows.h>
#include <wincrypt.h>
#include <iprtrmib.h>
#include <iphlpapi.h>
#include <tlhelp32.h>
#include <psapi.h>
#include <winioctl.h>
#include <TCHAR.H>
#include <intrin.h>
#endif // _WIN32

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#if (defined _WIN32) & (_MSC_VER < 1700)
#ifndef _STDINT
#define _STDINT
// MSVC lower than 17.00 does not have stdint.h, assure, all needed types are defined

typedef unsigned __int16 uint16_t;

typedef unsigned __int32 uint32_t;

typedef unsigned __int64 uint64_t;

#endif // !_STDINT
#else
#include <stdint.h>
#endif
#include <stddef.h>
#ifdef _WIN32
#define WIN32_LEAN_AND_MEAN
#include <Windows.h>
#undef WIN32_LEAN_AND_MEAN
#else// Define system-specific HL_* defines here
#ifndef HL_UNIX
#define HL_UNIX

#if (defined __gnu_linux__) || (defined __linux__)
#define HL_LINUX
#endif

#if (defined __APPLE__) && (defined __MACH__)
#define HL_LINUX
#define HL_MACOS
#endif

#ifdef _AIX
#define HL_AIX
#define HL_BIG_ENDIAN
#endif

#ifdef __FreeBSD__
#define HL_FREEBSD
#endif

#if (defined _hpux) || (defined hpux) || (defined __hpux)
#define HL_HPUX
#define HL_BIG_ENDIAN
#endif

#if (defined sun) || (defined __sun)
#define HL_SOLARIS
#endif

#if (defined __arm__) || (defined __aarch64__)
#define HL_LINUX_ARM
#endif

#ifdef __ANDROID__
#define HL_ANDROID
#endif

#endif
#include <hob-unix01.h>
#endif
#ifdef __APPLE__
/* We get target conditionals to keep apart Mac OS, iOS and iOS simulator.
   The conditionals are TARGET_IPHONE_SIMULATOR, TARGET_OS_IPHONE and TARGET_OS_MAC.
   TARGET_IPHONE_SIMULATOR has the highest priority, TARGET_OS_MAC the lowest.
   Always test, if the conditional is 1, as they will be defined as 0, if we 
   are not compiling for the target.
   */
#include <TargetConditionals.h>
#endif

#include <string.h>
#include <stdlib.h>
#if defined XH_INTERFACE
#if !(defined __HOB_XSCLIB01__) && !(defined DEF_AUX_CO_UNICODE)
#define __HOB_XSCLIB01__

#include <hob-xsclib01.h>
#endif // !__HOB_XSCLIB01__
#endif // defined ALT_SEEDING_SOURCE && defined XH_INTERFACE
#include "hob-encry-1.h"
#include "hob-encry-intern-1.h"
#include "hob-encry-err-1.h"
#include <hob-xslhcla1.hpp>

#if !defined _WIN32
#include <unistd.h>
#include <errno.h>
#include <time.h>
#include <sys/wait.h>
#include <sys/time.h>
#include <stdarg.h>
#include <fcntl.h>
#include <sys/times.h>
#include <sys/types.h>

#include <dirent.h>
#include <fcntl.h>
#include <libgen.h>
#include <limits.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <signal.h>
#include <sys/resource.h>
#include <sys/stat.h>
#ifndef HL_ANDROID
 #include <sys/statvfs.h>
#else
 #include <sys/vfs.h>
#endif  // HL_ANDROID
#if !defined HL_AIX
 #include <sys/syscall.h>
#endif  // HL_AIX
#if !defined HL_MACOS
#if !defined HL_FREEBSD
 #include <sys/sysinfo.h>
#endif  // not HL_FREEBSD
#else
 #include <mach/mach_time.h>
#endif  // HL_MACOS
#if defined HL_HPUX
 #include <pthread.h>
#endif  // HL_HPUX

#if defined HL_SOLARIS || defined HL_AIX
#if defined NAME_MAX
 #undef NAME_MAX
#endif  // NAME_MAX
 #define NAME_MAX _XOPEN_NAME_MAX
#endif  // defined HL_SOLARIS || defined HL_AIX

#if defined HL_HPUX
#if defined NAME_MAX
 #undef NAME_MAX
#endif  // NAME_MAX
 #define NAME_MAX  255
#endif  // HL_HPUX

#if defined HL_HPUX || defined HL_AIX
#if !defined HL_BIG_ENDIAN
 #define HL_BIG_ENDIAN     // the HP-UX systems and AIX systems force big endian to be used
#endif  // !defined HL_BIG_ENDIAN
#endif  // defined HL_HPUX || defined HL_AIX

#define Sleep(x) usleep((x) * 1000)

#define INT_PATH_FILENAME_LIMIT  8192
#define PROC_PATH  "/proc/"
#define VAR_PATH  "/var/"

#endif // not WINDOWS (_WIN32)

#if defined HL_UNIX && !defined XH_INTERFACE
#include <hob-unix01.h>
#endif // HL_UNIX && !XH_INTERFACE

#define HL_RANDOM_CAS_SIZE 1024

#if defined _WIN32
// pragma comments for the compiler
#pragma warning(disable:4996 4351)
// pragma comments for the linker
#pragma comment(lib, "crypt32.lib")
#pragma comment(lib, "Iphlpapi.lib")
#pragma comment(lib, "Psapi.lib")
#endif
static int m_get_high_resolutime(long long* ailp_perf_retval);
extern "C" int m_hl1_printf( const char *, ... );
typedef int (*am_get_entropy)(HMEM_CTX_DEF
                         char* abyp_pdigest,
                         int* ainp_byteshashed);

int SysGetEntropy(HMEM_CTX_DEF
                  char* abyp_pdigest,
                  int* ainp_byteshashed);

/** @addtogroup rand
* @{
*/
static unsigned long long m_get_tsc_impl(void)
{
    // For x86 and x64, use RDTSC with CPUID as serialization barrier. RDSTCP seems to be inaccessible for some machines/VM configurations
#ifdef WIN32
    int inrl_temp[4];
    __cpuid(inrl_temp, 0);
    return __rdtsc();
#else
#ifdef __i386
    unsigned long long int x;
    __asm__ volatile (".byte 0x0f, 0x31" : "=A" (x));
    return x;
#elif defined __amd64 || defined __x86_64__
   unsigned hi, lo;
    __asm__ __volatile__ ("rdtsc" : "=a"(lo), "=d"(hi));
    return ( (unsigned long long)lo)|( ((unsigned long long)hi)<<32 );
#else
    // For non-X86 systems, just return 0
    return 0;
#endif
#endif
}

static bool m_tsc_usable(void)
{
    unsigned long long ull_start = m_get_tsc_impl();
    Sleep(1000);
    unsigned long long ull_end = m_get_tsc_impl();

    // only use TSC, if it at least gives a 1 ns resolution. This would mean 1 GHz or more
    return (ull_end - ull_start) > 1000000000;
}

static unsigned long long m_get_tsc(void)
{
    static bool bos_use_tsc = m_tsc_usable();

    if(bos_use_tsc){
        return m_get_tsc_impl();
    } else {
        return 0;
    }
}

typedef struct crngstruc_st {
	char St[16];		// Statearray, the variable 'V'
	char Ky[16];		// Keyarray, the variable 'Key'
	int Rs;				// Reseed counter
	int Ck;				// Check counter
	int Fl;				// Bit 1: 1-fatal error occured
					// Bit 0: 1-initialized
    am_get_entropy amc_get_entropy;

    crngstruc_st() :
        St(),
        Ky(),
        Rs(0),
        Ck(0),
        Fl(0),
        amc_get_entropy(SysGetEntropy){}
}CRNG_STRUC;

//
//-----------------------------------------------------
// Global variables / Flags for secure random generator
//-----------------------------------------------------
/**
 * This is the main RNG structure variable that contains all the 
 * relevant state variables used within the random generator.
 */
static CRNG_STRUC SecRandStruc;

static dsd_hcla_critsect_1 m_get_lock()
{
    dsd_hcla_critsect_1 dss_critsect;
    dss_critsect.m_create();
    return dss_critsect;
}

/**
This reference to a critical section object is used to synchronize the global 
DRNG instance.
*/
static dsd_hcla_critsect_1 dss_critsect = m_get_lock();

/**
 * This variable is used to identify whether the random generator is 
 * initialized or not. The variable contains a 1 for initialized or 
 * a 0 for not initialized.
 */
volatile int SecRandInitFlag = 0;

#if defined XH_INTERFACE
/**
 * This is the global memory access pointer that is available when the 
 * XH-Interface version of this code is running for a program that provides 
 * the according memory management support.
 */
static ds__hmem* m_get_mem_context(void){
     static ds__hmem* adsl_memory = AllocFillMemCtxStruc(1);
     return adsl_memory;
}

extern void PrintAux(HMEM_CTX_DEF const char * ach_format,...);

#endif   // XH_INTERFACE

static void m_entropy_out(float flp_entropy)
{
#ifdef HL_ENTROPY_TEST
    printf("Entropy estimate is %f bit.\n", flp_entropy);
#endif
}

//
//---------------------------------------------------------------
// Minimum amount of needed bytes to be hashed, Windows/Unix only
//---------------------------------------------------------------
#if defined _WIN32
      #define HASH_LIMIT  5000  // Windows
      #define MIN_PI_ROUNDS  2000000
#if defined RANDBUFSIZE
      #undef RANDBUFSIZE
#endif // RANDBUFSIZE
#else // UNIX (=> !defined _WIN32)
#if defined HL_LINUX
#if !defined HL_LINUX_ARM
      #define HASH_LIMIT  15000  // Linux
      #define MIN_PI_ROUNDS  2000000
#else
      #define HASH_LIMIT  35
      #define MIN_PI_ROUNDS  10000
#endif // HL_LINUX_ARM
#else
#if (TARGET_OS_IPHONE == 1)
//iOS needs same limits as Linux ARM
      #define HASH_LIMIT  35
      #define MIN_PI_ROUNDS  10000
#else
      #define HASH_LIMIT  12000  // all other UNIX systems
      #define MIN_PI_ROUNDS  1000000
#endif
#endif // HL_LINUX
      #define RANDBUFSIZE (24)
#endif // defined _WIN32
//
#define CONF_COEF_LIMIT  50

/**
 * The DfKeyData array contains the key array for the 
 * derivation function.
 * <br><br>
 * Note: The key size is adapted for AES128 Cipher.
 */
static  char DfKeyData[16] = {
	(unsigned char) 0x00, (unsigned char) 0x01, (unsigned char) 0x02, (unsigned char) 0x03,
	(unsigned char) 0x04, (unsigned char) 0x05, (unsigned char) 0x06, (unsigned char) 0x07,
	(unsigned char) 0x08, (unsigned char) 0x09, (unsigned char) 0x0A, (unsigned char) 0x0B,
	(unsigned char) 0x0C, (unsigned char) 0x0D, (unsigned char) 0x0E, (unsigned char) 0x0F,
};
/**
 * The CrngTestSeedData array contains the seed data 
 * for the known answer test (KAT).
 */
static  char CrngTestSeedData[32] = {
	(unsigned char) 0x61, (unsigned char) 0x62, (unsigned char) 0x63, (unsigned char) 0x64,
	(unsigned char) 0x62, (unsigned char) 0x63, (unsigned char) 0x64, (unsigned char) 0x65,
	(unsigned char) 0x63, (unsigned char) 0x64, (unsigned char) 0x65, (unsigned char) 0x66,
	(unsigned char) 0x64, (unsigned char) 0x65, (unsigned char) 0x66, (unsigned char) 0x67,
	(unsigned char) 0x65, (unsigned char) 0x66, (unsigned char) 0x67, (unsigned char) 0x68,
	(unsigned char) 0x66, (unsigned char) 0x67, (unsigned char) 0x68, (unsigned char) 0x69,
	(unsigned char) 0x67, (unsigned char) 0x68, (unsigned char) 0x69, (unsigned char) 0x6A,
	(unsigned char) 0x68, (unsigned char) 0x69, (unsigned char) 0x6A, (unsigned char) 0x6B,
};
/**
 * The CrngCheckData array contains the test result data 
 * from the known answer test (KAT).
 * <br><br>
 * Note: The 'additional update' is already included.
 */
static  unsigned char CrngCheckData[32] = {
	(unsigned char) 0x1A, (unsigned char) 0x44, (unsigned char) 0x25, (unsigned char) 0x6F,
	(unsigned char) 0xD8, (unsigned char) 0xB8, (unsigned char) 0x4F, (unsigned char) 0xF4,
	(unsigned char) 0x25, (unsigned char) 0x29, (unsigned char) 0x55, (unsigned char) 0x14,
	(unsigned char) 0x75, (unsigned char) 0x6F, (unsigned char) 0x41, (unsigned char) 0x32,
	(unsigned char) 0xBE, (unsigned char) 0xAC, (unsigned char) 0x56, (unsigned char) 0x8C,
	(unsigned char) 0x59, (unsigned char) 0xA2, (unsigned char) 0x6F, (unsigned char) 0xDE,
	(unsigned char) 0xD8, (unsigned char) 0xC4, (unsigned char) 0xFE, (unsigned char) 0xD9,
	(unsigned char) 0xAF, (unsigned char) 0x50, (unsigned char) 0x60, (unsigned char) 0xEF,
};
//

//-----------------------------------------------------
// Structure definitions for Linux
//-----------------------------------------------------
#if !defined WIN32
#if !defined WIN64

/**
 * Structure needed for splitting up a 64-bit value into two 32-bit values.
 */
typedef union {
    unsigned long long ull_value;
    struct {
#if !defined HL_BIG_ENDIAN
        unsigned int um_low : 32;  // little endian is used
        unsigned int um_high : 32;  // so-called "Little Indian"
#else
        unsigned int um_high : 32;  // big endian is used
        unsigned int um_low : 32;  // so-called "Big Enzian"
#endif
    } ds_split;
} split_long_t;
//
/**
 * Structure storing system-information.
 */
typedef struct {
    unsigned int um_phys_total;
    unsigned int um_phys_avail;
    unsigned int um_pagesize;
    unsigned int um_process_count; 
    unsigned int um_num_cpus;
    unsigned int um_num_cpus_avail;
    unsigned int um_total_ram;
    unsigned int um_free_ram;
    unsigned int um_shared_ram;
    unsigned int um_buffer_ram;
    unsigned int um_total_swap;
    unsigned int um_free_swap;
    unsigned int um_total_high;
    unsigned int um_free_high;
} system_info_t;
//
/**
 * Structure storing IO-information of a process.
 */
typedef struct {
    unsigned int um_read;
    unsigned int um_write;
    unsigned int um_sysread;
    unsigned int um_syswrite;
    unsigned int um_read_transfer;
    unsigned int um_write_transfer;
    unsigned int um_write_cancel_transfer;
} proc_io_t;
//
/**
 * Structure storing memory information of a process.
 */
typedef struct {
    unsigned int um_size;
    unsigned int um_resident;
    unsigned int um_share;
    unsigned int um_text;
    unsigned int um_lib;
    unsigned int um_data;
    unsigned int um_dt;
} proc_mem_t;
//

#if !defined _WIN32
//-----------------------------------------------------
// Function prototype declarations
//-----------------------------------------------------
static int m_execute_command(const char *, const char *, int, unsigned int *, unsigned int, int*, int *);
#endif // !defined _WIN32

//-----------------------------------------------------
// Command array definitions for UNIX/Linux
//-----------------------------------------------------
//
       static char chrl_delim_1[] = { 0x20, 0x09, 0 };
#if defined HL_LINUX
       static char chrl_delim_2[] = { 0x20, 0x09, 0x0A, 0 };
#endif  // HL_LINUX
//
       static char * ach_commands_df = (char *)"df";
//
#if defined HL_LINUX && !defined HL_MACOS
       // Linux
       static char * achr_commands_ps[2] = {
           (char *)"ps -aefl",  // display information about the active processes
           (char *)"ps ax -o pid --no-headers"  // get PIDs of currently running processes
       };
       static char * achr_commands_mcp[5] = {
           (char *)"ipcs -a",  // use all print options for the ipcs information
           (char *)"ipcs -p",  // write process number information
           (char *)"ipcs -t",  // write time information
           (char *)"vmstat -d",  // report disk statistics (2.5.70 or above required) 
           (char *)"vmstat -m"   // display slabinfo 
       };
#ifndef HL_LINUX_ARM
       static char * achr_commands_net[7] = {
           (char *)"netstat -a",     // show both listening and non-listening sockets
           (char *)"netstat -a -e",  // show both listening and non-listening sockets, extended version
           (char *)"netstat -a -n",  // show both listening and non-listening sockets, numeric version
           (char *)"netstat -i -e",  // display a table of all network interfaces, extended version
           (char *)"netstat -g -n",  // display multicast group membership information for IPv4 and IPv6, numeric version
           (char *)"netstat -p -e",  // show the PID and name of the program to which each socket belongs, extended version
           (char *)"netstat -s"      // display summary statistics for each protocol
       };
#else
       // netstat -a and netstat -a -e can cause several minutes delay on some Android devices (found on Galaxy S6), so they are removed in ARM builds.
       static char * achr_commands_net[5] = {
           (char *)"netstat -a -n",  // show both listening and non-listening sockets, numeric version
           (char *)"netstat -i -e",  // display a table of all network interfaces, extended version
           (char *)"netstat -g -n",  // display multicast group membership information for IPv4 and IPv6, numeric version
           (char *)"netstat -p -e",  // show the PID and name of the program to which each socket belongs, extended version
           (char *)"netstat -s"      // display summary statistics for each protocol
       };
#endif 
//
#else // !HL_LINUX
#if defined HL_SOLARIS
       // Solaris
       static char * achr_commands_ps[2] = {
           (char *)"ps -acefjl",  // display information about the active processes
           (char *)"ps -o pid -o addr -o vsz -o pmem -o pcpu -o rss -o stime -o etime -o wchan"  // get further information
       };
       static char * achr_commands_mcp[8] = {
           (char *)"/usr/sbin/prtconf -P",  // display the system configuration information: memory, system peripherals and pseudo devices
           (char *)"/usr/sbin/swap -l",     // display the status of all the system swap areas used by the memory manager
           (char *)"/usr/sbin/swap -s",     // display information about total swap space usage and availability
           (char *)"/usr/bin/vmstat",       // report virtual memory statistics regarding kernel thread, virtual memory, disk, trap, and CPU activity
           (char *)"/usr/bin/vmstat -i",    // report the number of interrupts per device
           (char *)"/usr/bin/vmstat -q",    // report virtual memory statistics without state changes
           (char *)"/usr/bin/vmstat -s",    // display the total number of various system events since boot
           (char *)"/usr/bin/prstat -a -L 0 1"   // report once active process statistics about processes and users and for each light-weight process (LWP)
       };
       static char * achr_commands_net[8] = {
           (char *)"netstat -a",     // show the state of all sockets
           (char *)"netstat -a -n",  // show network addresses as numbers
           (char *)"netstat -g -v",  // show multicast group memberships and source-specific membership information for all interfaces
           (char *)"netstat -i -a",  // show the state of the interfaces and the logical interfaces that are used for IP traffic
           (char *)"netstat -m -v",  // show the STREAMS memory statistics, verbose mode
           (char *)"netstat -p -v",  // show the net to media tables
           (char *)"netstat -r -a",  // show the routing tables, include all routes
           (char *)"netstat -s -a"   // show  per-interface statistics, in addition to statistics global to the system
       };
//
#else // !HL_SOLARIS
#if defined HL_HPUX
       // HP UX
       static char * achr_commands_ps[2] = {
           (char *)"ps -aefl",  // display information about the active processes
           (char *)"ps -elPx"  // display more information about the active processes
       };
       static char * achr_commands_mcp[7] = {
           (char *)"getconf CS_MACHINE_IDENT",  // get the machine ident ID number
           (char *)"getconf MACHINE_MODEL",  // get the machine model identification
           (char *)"ipcs -amqs",         // report status of interprocess communication facilities, display largest-allowable-size
                                         // information for shared memory segments, for message queues and for semaphores
           (char *)"vmstat -d",          // report virtual memory statistics and disk transfer information as a separate section
           (char *)"vmstat -f",          // report on the number of forks and the number of pages of virtual memory involved since boot-up
           (char *)"vmstat -s",          // print the total number of several kinds of paging-related events from the 
                                         // kernel sum structure that have occurred since boot-up or since vmstat was 
                                         // last executed with the -z option
           (char *)"vmstat -S"           // report virtual memory statistics and the number of processes swapped in and out (si and so)
                                         // instead of page reclaims and address translation faults (re and at)
       };
       static char * achr_commands_net[10] = {
           (char *)"netstat -a",        // show the state of all sockets
           (char *)"netstat -a -n",     // show network addresses as numbers
           (char *)"netstat -f inet",   // show statistics or address control block for the specified address-family AF_INET
           (char *)"netstat -f inet6",  // show statistics or address control block for the specified address-family AF_INET6
           (char *)"netstat -f unix",   // show statistics or address control block for the specified address-family AF_UNIX
           (char *)"netstat -g",        // show multicast information for network interfaces
           (char *)"netstat -i",        // show the state of network interfaces
           (char *)"netstat -M -s",     // show the multicast routing statistics
           (char *)"netstat -s",        // show statistics for all protocols ("netstat -p xxx" not needed)
           (char *)"netstat -r -v"      // show the routing tables and the network masks in the route entries
       };
//
#else // !HL_HPUX
#if defined HL_AIX
       // IBM AIX
       static char * achr_commands_ps[2] = {
           (char *)"ps -Afkml",  // display information about the active processes
                                 // -A = display information about all processes
                                 // -f = generates a full listing
                                 // -k = list kernel processes
                                 // -l = generate a long listing
                                 // -m = lists kernel threads as well as processes
           (char *)"ps -AfNPX"  // display other information about the active processes
                                // -A = display information about all processes
                                // -f = generates a full listing
                                // -N = report those statistics that can be obtained by 
                                //      not traversing through the threads chain for the process
                                // -P = display the Project name and subproject identifier for the project
                                // -X = print all available characters of each user/group name
                                //      instead of truncating to the first 8 characters
       };
       static char * achr_commands_mcp[10] = {
           (char *)"prtconf -ckLmsv",    // display the system model, machine serial, processor type, number of processors, 
                                         // processor clock speed, cpu type, total memory size, network information, 
                                         // filesystem information, paging space information, and devices information
           (char *)"ipcs -bcoptX",       // report information about active interprocess communication facilities;
                                         // this includes information about currently active message queues, shared 
                                         // memory segments, semaphores, remote queues, and local queue headers
           (char *)"lsattr -E -l sys0",  // display effective values of the logical device 'sys0'
           (char *)"lscfg -v -p -s",     // display vital product data (VPD), platform-specific device information and device description
           (char *)"vmstat -I",          // report statistics about kernel threads, virtual memory, disks, 
                                         // traps and CPU activity, display I/O oriented view
           (char *)"vmstat -i",          // displays the number of interrupts taken by each device since system startup
           (char *)"vmstat -f",          // report the number of forks since system startup
           (char *)"vmstat -s -v",       // display the contents of the sum structure, which contains an 
                                         // absolute count of paging events since system initialization, 
                                         // report various statistics maintained by the Virtual Memory Manager
           (char *)"vmstat -l -w",       // report system configuration
           (char *)"vmstat -t -p ALL"    // display virtual memory and cpu statistics of all devices with a time stamp
       };
       static char * achr_commands_net[10] = {
           (char *)"netstat -a -A",   // show the state of all sockets and the address of any 
                                      // protocol control blocks associated with the sockets
           (char *)"netstat -a -n",   // show the state of all sockets and network addresses as numbers
           (char *)"netstat -c",      // show the statistics of the Network Buffer Cache
           (char *)"netstat -D",      // show  the number of packets received, transmitted, 
                                      // and dropped in the communications subsystem
           (char *)"netstat -f inet",   // show statistics or address control block limited to the address-family AF_INET
           (char *)"netstat -f inet6",  // show statistics or address control block limited to the address-family AF_INET6
           (char *)"netstat -f unix",   // show statistics or address control block limited to the address-family AF_UNIX
           (char *)"netstat -i",        // show the state of all configured interfaces
           (char *)"netstat -m -M",     // show statistics recorded by the memory management routines 
                                        // and network memory's mbuf cluster pool statistics
           (char *)"netstat -s"         // show statistics for each protocol
       };
//
#else // !HL_AIX
#if defined HL_FREEBSD || defined HL_MACOS
       // Free BSD or MAC OS-X
       static char * achr_commands_ps[2] = {
           (char *)"ps -aefl",  // display information about the active processes
                                // -a = display information about other users' processes as well as your own
                                // -e = display the environment as well
                                // -f = show commandline and environment information about swapped out processes
                                // -l = display information associated with the following keywords: 
                                //      uid, pid, ppid, cpu, pri, nice, vsz, rss, mwchan, state, tt, time, and command
           (char *)"ps -v -x -e"  // displays information about all of your processes that have controlling terminals. 
                                  // -v = display information associated with the following keywords: 
                                  //      pid, state, time, sl, re, pagein, vsz, rss, lim, tsiz, %cpu, %mem, and command
                                  // -x = when displaying processes matched by other options, 
                                  //      include processes which do not have a controlling terminal
                                  // -e = display the environment as well
       };
#if defined HL_FREEBSD
       // Free BSD
       static char * achr_commands_mcp[8] = {
           (char *)"ipcs -bcpt",      // show the maximum amount of information possible when displaying
                                      // active semaphores, message queues, and shared memory segments
           (char *)"ipcs -o",         // show outstanding usage for active message queues, and shared memory segments
           (char *)"ipcs -T",         // display system information about shared memory, messages queues and semaphores
           (char *)"vmstat -a",       // report virtual memory statistics
           (char *)"vmstat -a -i",    // report virtual memory statistics and include statistics about interrupts
           (char *)"vmstat -f",       // report on the number fork(2), vfork(2) and rfork(2) system calls since 
                                      // system startup, and the number of pages of virtual memory involved in each
           (char *)"vmstat -s",       // display the contents of the sum structure, giving the total number of several 
                                      // kinds of paging related events which have occurred since system startup
           (char *)"vmstat -P"        // report per-cpu system/user/idle cpu statistics
       };
       static char * achr_commands_net[7] = {
           (char *)"netstat -a",      // display a list of active sockets (protocol control blocks) for each network protocol
           (char *)"netstat -L",      // display a list of active sockets and show the size of the various listen queues
           (char *)"netstat -iabt",   // show the state of all network interfaces, show the number of bytes in and out and 
                                      // show the contents of watchdog timers
           (char *)"netstat -m",      // show statistics recorded by the memory management routines (mbuf(9))
           (char *)"netstat -r",      // display the contents of all routing tables
           (char *)"netstat -rs",     // display routing statistics
           (char *)"netstat -s"       // display system-wide statistics for each network protocol
       };
//
#else // !HL_FREEBSD / HL_MACOS
       // MAC OS-X
       static char * achr_commands_mcp[4] = {
           (char *)"ipcs -a",      // show the maximum amount of information possible when displaying
                                   // active semaphores, message queues, and shared memory segments
           (char *)"ipcs -M",      // display system information about shared memory
           (char *)"ipcs -Q",      // display system information about messages queues
           (char *)"ipcs -S"       // display system information about semaphores
       };
       static char * achr_commands_net[6] = {
           (char *)"netstat -alA",    // show the state of all sockets, print full IPv6 address, 
                                      // show the address of any protocol control blocks associated with sockets
           (char *)"netstat -g -n",   // show information related to multicast (group address) routing, 
                                      // show network addresses as numbers
           (char *)"netstat -i -a",   // show the state of interfaces which have been auto-configured (interfaces statically 
                                      // configured into a system, but not located at boot time are not shown) 
                                      // multicast addresses currently in use are shown for each Ethernet interface 
                                      // and for each IP interface address
           (char *)"netstat -m",      // show statistics recorded by the memory management routines
           (char *)"netstat -rs",     // show routing statistics
           (char *)"netstat -s"       // show per-protocol statistics
       };
//
#endif // HL_FREEBSD / HL_MACOS
#else // !HL_FREEBSD & !HL_MACOS
       // default
       static char * achr_commands_ps[2] = {
           (char *)"ps -aefl",  // display information about the active processes
           (char *)"ps"         // get ps default
       };
       static char * achr_commands_mcp[1] = {
           (char *)"vmstat",          // displays the number of interrupts taken by each device since system startup
       };
       static char * achr_commands_net[8] = {
           (char *)"netstat -a",     // get state of all sockets
           (char *)"netstat -i",     // get Interface Table
           (char *)"netstat -w",     // get IP Net Table
           (char *)"netstat -w -s",  // get IP Statistics
           (char *)"netstat -u",     // get UDP Table
           (char *)"netstat -u -s",  // get UDP Statistics
           (char *)"netstat -t",     // get TCP Table
           (char *)"netstat -t -s"   // get TCP Statistics
       };
//
#endif  // HL_FREEBSD | HL_MACOS
#endif  // HL_AIX
#endif  // HL_HPUX
#endif  // HL_SOLARIS
#endif  // HL_LINUX
//
//
#if defined HL_LINUX
       // Linux
       static char * achrl_delimit_ps[2] = {
           (char *)chrl_delim_1,
           (char *)chrl_delim_2
       };
//
#else // !HL_LINUX
       // default
       static char * achrl_delimit_ps[2] = {
           (char *)chrl_delim_1,
           (char *)chrl_delim_1
       };
#endif  // HL_LINUX
//
#endif // !defined WIN64
#endif // !defined WIN32

//
//-----------------------------------------------------
// Source code for all languages and platform types
//-----------------------------------------------------


static void ms_add_cas_random(int* ainp_sha_array,
                              int& inp_bytes_hashed,
                              int& inp_total_percentage,
                              float& flp_entropy_est)
{
// At the moment, Random CAS is x86 and x64 only
#if defined(_WIN32) || defined (__x86_64__) || defined (__i386__)
    // Set up for a run of 200 ms, all cores, lowest priority, 3 allocs (results from KB tests), relative time and a buffer of size HL_RANDOM_CAS_SIZE
    char chrl_cas_bytes[HL_RANDOM_CAS_SIZE];
    dsd_random_cas_02 dsl_cas_struct = {
        200,
        0,
        0,
        3,
        TRUE,
        HL_RANDOM_CAS_SIZE,
        HL_RANDOM_CAS_SIZE,
        chrl_cas_bytes
    };

    int inl_ret = m_call_random_cas_02(&dsl_cas_struct);

    if(inl_ret < 0){
        m_hl1_printf("[xs-encry-1.cpp] %u  function m_call_random_cas_02 returned error code %i \n", __LINE__, inl_ret);
        return;
    }

    SHA256_Update(ainp_sha_array, chrl_cas_bytes, 0, inl_ret);

    /** @todo add the entropy, when estimates are ready. */
#endif
}

// Aux function for random CAS
extern "C" BOOL m_aux( void * vpp_userfld, int imp_func, void * ap_addr, int imp_length ) {
#define X_AUADDR  *((void **) ap_addr)
   if (imp_func == DEF_AUX_MEMGET) {
     X_AUADDR = malloc( imp_length );
     if (X_AUADDR) return TRUE;
     return FALSE;
   }
   if (imp_func == DEF_AUX_MEMFREE) {
     free( X_AUADDR );
     return TRUE;
   }
   return FALSE;
}

/**
* SecClearByteArray - Clear a byte array with zeros.
*
* 
*  @param abyp_parray  Array to clear
*  @param iml_size  Size of array
*/
static  void SecClearByteArray(char* abyp_parray, int iml_size)
{
   memset(abyp_parray, 0x55, iml_size);
   memset(abyp_parray, 0, iml_size);
}  // end of PRIVATE STATIC void SecClearByteArray(...)
//
//
/**
* ArraySet - Fill an array with a given constant value. 
* <br><br>
* The array is filled with a given value starting from an offset 
* position and filling the given size number of bytes. Only the 
* low byte value (bit 0 - bit 7) is used as relevant value from 
* the passed integer value.
*
* 
*  @param abyp_parray  array to fill
*  @param imp_offset  start of data
*  @param imp_len  size of data
*  @param imp_value  value to use for fill
*/
static  void ArraySet(char* abyp_parray, int imp_offset, 
                             int imp_len, int imp_value)
{
  memset((abyp_parray + imp_offset), imp_value, imp_len);
} // end of PRIVATE STATIC void ArraySet(...)
//
//
/**
* SecGetSystemTimeUTC - Get system time in 
* UTC format (seconds rel 00:00 01.01.1970).
*
*
*  @return  BIT32 time
*/
extern "C"  int SecGetSystemTimeUTC()
{
   return((int) time(NULL));  // C-Library Version
}
//
//
/**
* IncVStateArray - Increment the variable 'V' modulo 2**128 (outlen).
*
* 
*  @param pArray  State variable in BIG endian order
*/
static  void IncVStateArray(char* pArray)
{
  int Sum,SrcOff;

  Sum = 1;  // preset summand
  SrcOff = 15;  // start for Summing is LSB
  do
  {
    Sum = Sum + ((int) pArray[SrcOff] & 0x0FF);
    pArray[SrcOff--] = (char) Sum;
    Sum = (Sum >> 8) & 0x0FF;
  }
  while(SrcOff >= 0);
} // end of PRIVATE STATIC void IncVStateArray(...)
//
//
/**
* CTR_DRBG_Update128 - This is the CTR-DRBG Update function.
* <br><br>
* The CTR-DRBG Update function is used to perform the updating of 
* the generator, it is specialized for the AES128 crypto function.
* Updates V and Key using AES ECB encrypt mode.
*
* 
*  @param pStruc  Generator structure
*  @param pInData  Data to XOR or NULL if none
*/
static  void CTR_DRBG_Update128(CRNG_STRUC * pStruc, char* pInData)
{
  int i;
  char TmpIV[16];

  ds_aes_key EncryptTab;
  //---------------------------------------------------------
  // Generate the subkey array required for encryption
  //---------------------------------------------------------
  EncryptTab.im_flags = 0;  // CPU AES off; check, whether CPU AES support can be set from configuration
  m_aes_set_encrypt_key((unsigned char *) pStruc->Ky,4,
                        &EncryptTab);

  //---------------------------------------------------------
  // Generate new Key data (16 bytes) first
  //---------------------------------------------------------
  IncVStateArray(pStruc->St);  // V = V+1 mod 2**128
  memset(TmpIV,0,16);  // clear chaining value (XOR)

  m_aes_cbc_encrypt((unsigned char *) pStruc->St,
                    (unsigned char *) pStruc->Ky,
		    &EncryptTab,1,
		    (unsigned char *) TmpIV,AES_NR_MIN);
  //---------------------------------------------------------
  // Generate new State data (16 bytes) next
  //---------------------------------------------------------
  IncVStateArray(pStruc->St);	// V = V+1 mod 2**128
  ArraySet(TmpIV,0,16,0);			// clear chaining value
  m_aes_cbc_encrypt((unsigned char *) pStruc->St,
                    (unsigned char *) pStruc->St,
		    &EncryptTab,1,
		    (unsigned char *) TmpIV,AES_NR_MIN);
  //---------------------------------------------------------
  // XOR in given data if any
  //---------------------------------------------------------
  if(pInData != NULL)
  {
    for(i=0;i<16;i++)
    {
      pStruc->Ky[i] = (char)
        (pStruc->Ky[i] ^ pInData[i]);
      pStruc->St[i] = (char)
        (pStruc->St[i] ^ pInData[i+16]);
    }
  }
} // end of PRIVATE STATIC void CTR_DRBG_Update128(...)
//
//
/**
* BlockCipherDf_AES128 - This is the CTR-DRBG Derivation function.
* <br><br>
* Derivation function for the seed data in block cipher mode
* specialized for AES128 usage (seedlen=32 byte, blocklen=16 byte,
* keylen=16 byte).
*
* 
*  @param pInpData  Raw input data, 32 Bytes
*  @param pOutData  Output data, 32 Bytes
*/
static  void BlockCipherDf_AES128(char* pInpData,char* pOutData)
{
  char KeyArray[16];
  char XArray[16];
  char TmpIV[16];
  char IvSArray[64];
  char TmpArray[64];
  ds_aes_key EncryptTab;
  //--------------------------------------------------------
  // Note: We use combined Array for IV and S from spec.
  // ----- First 16 bytes are the IV, remaining bytes are S
  //--------------------------------------------------------
  memset(IvSArray,0,16);			// Zero the IV
  memset(IvSArray+57,0,7);			// Set additional padding zero
  //--------------------------------------------------------
  // Format the S-String from length, input and padding
  //--------------------------------------------------------
  BIGlong2charn(32,IvSArray,16);		// store the input byte length
  BIGlong2charn(32,IvSArray,20);		// store the output byte length
  memcpy(IvSArray+24,pInpData+0,32);	// append input data
  IvSArray[32+16+8] = (unsigned char) 0x80;		// store the padding byte

//  PRINT("IVS Array:\n");
//  PrintHexData(IvSArray,0,64);

  //---------------------------------------------------------
  // Generate the temporary key, for i=0 at first
  //---------------------------------------------------------
  memset(KeyArray,0,16);			// clear key (chaining) value

  EncryptTab.im_flags = 0;  // CPU AES off; check, whether CPU AES support can be set from configuration
  m_aes_set_encrypt_key((unsigned char *) DfKeyData,4,&EncryptTab); // generate key

  m_aes_cbc_encrypt((unsigned char *) IvSArray,
		    (unsigned char *) TmpArray,
		    &EncryptTab,4,
		    (unsigned char *) KeyArray,AES_NR_MIN);
  //---------------------------------------------------------
  // Generate the X value, for i=1 next
  //---------------------------------------------------------
  BIGlong2charn(1,IvSArray,0);			// set i=1 for IV

  memset(XArray,0,16);			// clear X (chaining) value

  m_aes_cbc_encrypt((unsigned char *) IvSArray,
		    (unsigned char *) TmpArray,
                    &EncryptTab,4,
		    (unsigned char *) XArray,AES_NR_MIN);
  //----------------------------------------------------------------
  // Expand X value for needed output size bytes using temporary key
  //----------------------------------------------------------------
  m_aes_set_encrypt_key((unsigned char *) KeyArray,4, &EncryptTab);

  memset(TmpIV,0,16);				// clear CBC input IV

  m_aes_cbc_encrypt((unsigned char *) XArray,
		    (unsigned char *) XArray,
		    &EncryptTab,1,
		    (unsigned char *) TmpIV,AES_NR_MIN);

  memcpy(pOutData+0,XArray+0,16);

  ArraySet(TmpIV,0,16,0);			// clear CBC input IV

  m_aes_cbc_encrypt((unsigned char *) XArray,
		    (unsigned char *) XArray,
		    &EncryptTab,1,
		    (unsigned char *) TmpIV,AES_NR_MIN);

  memcpy(pOutData+16,XArray+0,16);
} // end of PRIVATE STATIC void BlockCipherDf_AES128(...)
//
//
/**
* CTR_DRBG_Instantiate128 - This is the CTR-DRBG Instantiate function.
* <br><br>
* The CTR-DRBG Instantiate function is used to start the RNG, 
* it is specialized for the AES128 crypto function.  <br>
* NOTE: No personalization data/NONCE are used
*
* 
*  @param pStruc  Generator structure
*  @param pEntropy  Entropy data to use
*/
static  void CTR_DRBG_Instantiate128(CRNG_STRUC * pStruc,
						char* pEntropy)
{
  char SeedMaterial[32];

  //----------------------------------------------------------------
  // Initialize the structure set V = 0, Key = 0, Reseedcount = 1
  //----------------------------------------------------------------
  ArraySet(pStruc->St,0,16,0);		// set V  =0
  ArraySet(pStruc->Ky,0,16,0);		// set Key=0
  pStruc->Rs = 1;
  pStruc->Ck =  1;
  //-----------------------------------------
  // Generate seeding material from raw input
  //-----------------------------------------
  BlockCipherDf_AES128(pEntropy,SeedMaterial);
  //----------------------------------------------------------
  // Set initial key and state variables 
  //----------------------------------------------------------
  CTR_DRBG_Update128(pStruc,SeedMaterial);
  SecClearByteArray(SeedMaterial,32);
  CTR_DRBG_Update128(pStruc,NULL);
  //-----------------------------------------
  // Set Flags = 1
  //-----------------------------------------
  pStruc->Fl = 0x01;
} // end of PRIVATE STATIC void CTR_DRBG_Instantiate128(...)
//
//
/**
* CTR_DRBG_Reseed128 - This is the CTR-DRBG Reseed function.
* <br><br>
* The CTR-DRBG Reseed function is used to perform the reseeding of  
* the generator, it is specialized for AES128 crypto function.  <br>
* NOTE: No personalization data/NONCE are used
* <br><br>
* It is expected that the entropy data to be used are passed to 
* this function in a byte array of length 32 from the output of 
* a SHA-256 hash function.
*
* 
*  @param pStruc  Generator structure
*  @param pEntropy  Entropy data to use
*/
static  void CTR_DRBG_Reseed128(CRNG_STRUC * pStruc, char* pEntropy)
{
  char SeedMaterial[32];

  //-----------------------------------------
  // Generate seeding material from raw input
  //-----------------------------------------
  BlockCipherDf_AES128(pEntropy, SeedMaterial);

  //----------------------------------------------------------
  // Update key and state variables 
  //----------------------------------------------------------
  CTR_DRBG_Update128(pStruc, SeedMaterial);
  SecClearByteArray(SeedMaterial, 32);
  CTR_DRBG_Update128(pStruc, NULL);
  pStruc->Rs = 1;
  pStruc->Fl |= 0x01;
} // end of PRIVATE STATIC void CTR_DRBG_Reseed128(...)
//
//
/**
* CTR_DRBG_Generate128 - This is the CTR-DRBG Generate function.
* <br><br>
* The CTR-DRBG Generate function is used to provide generated random 
* output from the generator, it is specialized for the AES128 
* crypto function. The size of data to return is given in bytes.  <br>
* NOTE: No personalization data/NONCE are used.
*
*  @param pStruc  Generator structure
*  @param pOutData  Output buffer
*  @param OutOff  start of destination data
*  @param OutLen  number of bytes requested
*  @param NoReseed  if <> 0, no reseed checking done
*  @return int state 
*  <br>         0 - o.k.
*  <br>         1 - not initialized
*  <br>         2 - reseed needed
*  <br>         < 0 - parameter error
*/
static  int CTR_DRBG_Generate128(CRNG_STRUC * pStruc, char* pOutData,
					    int OutOff, int OutLen, int NoReseed)
{
   int CopyLen;
   char TmpIV[16];
   char OutBlock[16];
   ds_aes_key EncryptTab;
   //-------------------------------------------
   // Check parameters first
   //-------------------------------------------
   if ((pStruc == NULL) || (pOutData == NULL))
      return(-1);  // NULL pointer

   if ((OutLen < 0) || (OutLen > CRNG_REQ_MAX_BYTES))
      return(-2);  // parameter error

   if ((pStruc->Fl & 0x01) == 0)  // not initialized
      return(1);

   //-------------------------------------------
   // Check if reseed is needed
   //-------------------------------------------
   if (NoReseed == 0)
   {
     if (pStruc->Rs == 0)  // already 2**32 requests were issued
        return(2);
   }
   //-------------------------------------------
   // Generate the output data using V and Key K
   //-------------------------------------------
   EncryptTab.im_flags = 0;  // CPU AES off; check, whether CPU AES support can be set from configuration
   m_aes_set_encrypt_key((unsigned char *)pStruc->Ky, 4,
                         &EncryptTab);

   while(OutLen != 0)
   {
     CopyLen = OutLen;
     if (CopyLen > AES_BLOCK_SIZE)
        CopyLen = AES_BLOCK_SIZE;

     IncVStateArray(pStruc->St);  // V = V+1 mod 2**128

     ArraySet(TmpIV,0,16,0);  // clear CBC input IV (XOR)

     m_aes_cbc_encrypt((unsigned char *)pStruc->St,
                       (unsigned char *)OutBlock, &EncryptTab, 1,
                       (unsigned char *) TmpIV,AES_NR_MIN);

//     PRINT("CopyLen: ");PRINT_INT(CopyLen);
//     PRINT(" DstOff: ");PRINT_INT_NL(OutOff);

     memcpy(pOutData+OutOff,OutBlock+0,CopyLen);

     OutLen -= CopyLen;
     OutOff += AES_BLOCK_SIZE;
   }
   //-----------------------------------------------
   // Update the state/key arrays next
   //-----------------------------------------------
   CTR_DRBG_Update128(pStruc,NULL);
   if (NoReseed == 0)
      pStruc->Rs++;

   return(0);
} // end of PRIVATE STATIC int CTR_DRBG_Generate128(...)
//
//
/**
* CTR_DRBG_Test - This is the CTR-DRBG Test method.
* <br><br>
* Test operation of the AES128 DBRG generator:  <br>
* 1. Instantiate the generator using test seed data.  <br>
* 2. Generate 32 byte of random data, compare against
*    known result.
*
*
*  @return int state - 0 o.k., else error occurred
*/
static  int CTR_DRBG_Test()
{
  int Retcode,i;
  unsigned char ResultData[32];
  CRNG_STRUC * pTestStruc;
  CRNG_STRUC TestStruc;
  pTestStruc = &TestStruc;

  //------------------------------------------------------
  // initialize generator, 'seed' it, get 'Random' data 
  //------------------------------------------------------
  CTR_DRBG_Instantiate128(pTestStruc, CrngTestSeedData);
  Retcode = CTR_DRBG_Generate128(pTestStruc,(char*) ResultData,0,32,0);
  if(Retcode != 0)
  {
//    printf("Retcode was: %d\n",Retcode);
    return(-9995);
  }
//  PrintHexData(ResultData,0,16);
  //---------------------------------------------
  // Compare result with KAT result data
  //---------------------------------------------
  for(i=0;i<32;i++)
  {
    if(ResultData[i] != CrngCheckData[i])
      return(-9996);
  }
  // Test clear array function
  SecClearByteArray((char*) ResultData, 32);
  for(i=0;i<32;i++)
  {
    if(ResultData[i] != 0)
      return(-9997);
  }
  // return ok
  return(0);
} // end of PRIVATE STATIC int CTR_DRBG_Test()
//
//
/**
* m_drbg_change_crng_flags - Set or clear flags in the 
* crng structure of the generator.
*
* 
*  @param adsp_pstruc Generator structure
*  @param inp_set_flags_val Bits to be set in the flags
*  @param inp_clear_flags_val Bits to be cleared in flags
*/
static  void m_drbg_change_crng_flags(CRNG_STRUC * adsp_pstruc,
                           int inp_set_flags_val, int inp_clear_flags_val)
{
   if (inp_set_flags_val != 0)
      adsp_pstruc->Fl |= inp_set_flags_val;
   if (inp_clear_flags_val != 0)
      adsp_pstruc->Fl &= (~inp_clear_flags_val);
}  // end of PRIVATE STATIC void m_drbg_change_crng_flags(...)
//
//
/**
* DRBGGetRandBytes - Output random bytes from the CRT_DRBG
* <br><br>
* Get requested number of random bytes from the CRT_DRBG
* with AES128. If requested number of bytes is larger than 8192
* bytes, multiple requests are done with as many full blocks as
* needed.
*
* 
*  @param pStruc Generator structure
*  @param pOutData Output buffer
*  @param OutOff Start for destination data
*  @param OutLen Number of bytes requested
*  @param NoReseed if <> 0, no reseed checking done
*  @return int state
*  <br>           == 0 o.k.
*  <br>           == 1 - not initialized
*  <br>           == 2 - reseed needed
*  <br>           < 0 parameter error
*/
static  int DRBGGetRandBytes(CRNG_STRUC * pStruc, char* pOutData,
				        int OutOff, int OutLen, int NoReseed)
{
  int BlockCnt,InBlkCnt,Retcode;
  //
  BlockCnt = OutLen/CRNG_REQ_MAX_BYTES;
  InBlkCnt = OutLen - (BlockCnt * CRNG_REQ_MAX_BYTES);
  //-----------------------------------------------------
  // Generate full blocks if required
  //-----------------------------------------------------
  while(BlockCnt != 0)
  {
    if((Retcode = CTR_DRBG_Generate128(pStruc,pOutData,OutOff,
				       CRNG_REQ_MAX_BYTES,NoReseed)) != 0)
      return(Retcode);
    //
    BlockCnt--;
    OutOff += CRNG_REQ_MAX_BYTES;
    pStruc->Ck++;
    if(pStruc->Ck > CRNG_CHECK_INTERVAL)
    {
      pStruc->Ck = 1;
      Retcode = CTR_DRBG_Test();
      if(Retcode != 0)
      {
        m_drbg_change_crng_flags(pStruc, 0, 0x01);	// set to not initialized
        return(Retcode);
      }
    }
  }
  //-----------------------------------------------------
  // Generate remaining bytes if required
  //-----------------------------------------------------
  if(InBlkCnt != 0)
  {
    if((Retcode = CTR_DRBG_Generate128(pStruc,pOutData,OutOff,
				       InBlkCnt,NoReseed)) != 0)
      return(Retcode);
    //
    pStruc->Ck++;
    if(pStruc->Ck > CRNG_CHECK_INTERVAL)
    {
      pStruc->Ck = 1;
      Retcode = CTR_DRBG_Test();
      if(Retcode != 0)
      {
        m_drbg_change_crng_flags(pStruc, 0, 0x01);	// set to not initialized
        return(Retcode);
      }
    }
  }
  return(0);
} // end of PRIVATE STATIC int DRBGGetRandBytes(...)
//
//
//
//
#if defined _WIN32
/**
* m_getdrivegeometry - Perform an access to harddisk information.
* <br><br>
* This method is used perform a simple access to harddisk information 
* that is necessary to spread variances of different loops in the 
* Wallis product calculation.  <br>
* The code is taken from 'msdn.microsoft.com' and 'code.google.com'.
*
*  @param dsp_pdg Geometry structure
*  @return state 
*  <br>            = 1 - function successfully processed
*  <br>            = 0 - error condition
*/
static int m_getdrivegeometry(DISK_GEOMETRY *dsp_pdg)
{
  HANDLE inl_hdevice;  // handle to the drive to be examined 
  BOOL bol_result;     // results flag
  DWORD dwl_junk;      // discard results

  inl_hdevice = CreateFileA("\\\\.\\PhysicalDrive0",  // drive to open
                            0,                // no access to the drive
                            FILE_SHARE_READ | // share mode
                            FILE_SHARE_WRITE, 
                            NULL,             // default security attributes
                            OPEN_EXISTING,    // disposition
                            0,                // file attributes
                            NULL);            // do not copy file attributes
  if (inl_hdevice == INVALID_HANDLE_VALUE) // cannot open the drive
  {
    return (0);
  }

  bol_result = DeviceIoControl(inl_hdevice,  // device to be queried
                               IOCTL_DISK_GET_DRIVE_GEOMETRY,  // operation to perform
                               NULL, 0,  // no input buffer
                               dsp_pdg, sizeof(*dsp_pdg),  // output buffer
                               &dwl_junk,  // # bytes returned
                               (LPOVERLAPPED) NULL);  // synchronous I/O
  CloseHandle(inl_hdevice);
  if (bol_result == FALSE)
     return (0);
  else
     return (1);
} // end of static int m_getdrivegeometry(...)
#endif // defined _WIN32

//
/**
* m_calc_pi_wallis - Calculate PI with a simple approximation 
* (Wallis product).
* <br><br>
* This method is used to create 2 to 4 values that can be used as entropy 
* sources. The central loop performs a calculation of the number PI by an 
* iterated multiplication and division of double float values, the so-called 
* Wallis' product. The entropy value is gained by the number of loop cycles 
* that are processed within a certain time interval measured by a timer with 
* only a low resolution. The time interval is limited to 137 milliseconds. 
* If the time resolution is higher than milliseconds it is scaled down (to 
* milliseconds). The number of rounds of the calculation of PI that are 
* performed up to the time limit is stored. This process is executed twice 
* as minimum, but is increased up to 4, if the number of loops in the first 
* or the second execution of the inner loop is not sufficient. If the number 
* of rounds in the first execution of the inner loop is less than 2200000 
* rounds, the number of loops is incremented by one. If it is even below 
* 1100000 it is once again incremented by one. If the number of rounds in 
* the second execution of the inner loop is less than 2200000 rounds, the 
* of loops is also incremented by one. However, the maximum number of number 
* executions of the inner loop is limited to 4. The results are returned in 
* the elements of the passed pointer that represents an array of a minimum 
* length of 4 items. After all inner loops are processed the result values 
* are tested for identity, and, if identical values are found one of these 
* is set to zero. It is assumed that the calculation efforts, and thus the 
* results of the 2 described values, are directly correlated to the current 
* system's CPU/FPU load.
* <br><br>
*
* Windows time format:  <br>
*         GetSystemTimeAsFileTime function  <br>
*         The FILETIME structure is a 64-bit value representing the number 
*         of 100-nanosecond intervals since January 1, 1601.
* <br><br>
* Linux/Unix time format:  <br>
*         gettimeofday function  <br>
*         The functions gettimeofday() gives the number of seconds and 
*         microseconds since the Epoch, 1970-01-01 00:00:00 +0000 (UTC).
*         The timeval structure has an element time_t for seconds and an 
*         element suseconds_t for microseconds.
* <br><br>
* Java time format:  <br>
*         System.currentTimeMillis method  <br>
*         Method public static long currentTimeMillis() returns the current 
*         time in milliseconds which is the difference, measured in milli
*         seconds, between the current time and midnight, January 1, 1970 UTC.
* <br><br>         
*
* Windows function parameters:  <br>
*               LARGE_INTEGER*   ailp_wallis_rounds  <br>
* The pointer must point to an array that has a minimum length of 4 elements. 
* Elements can be zero. <br>
* <br>
* Linux/Unix function parameters:  <br>
*               split_long_t *   adsl_wallis_rounds  <br>
* The pointer must point to an array that has a minimum length of 4 elements. 
* Elements can be zero. <br>
* <br>
* Java method parameters:  <br>
*               long[] ilrp_wallis_rounds (return values in [x])  <br>
* This array must have a minimum length of 4 and is used to return 4 values in 
* its array elements. Elements can be zero.
* <br><br>
* All versions:
*  @return state 
*  <br>            > 0 - value of PI calculation * 1000000 (PI/2 * 2000000)
*  <br>            = 0 - unknown state
*  <br>            < 0 - error condition
*/
//
#if defined _WIN32
   //
static long m_calc_pi_wallis(LARGE_INTEGER* ailp_wallis_rounds)
{
   int inl1;
   int  inl_loops;
   int  inl_val;
   LONGLONG  ill1, ill2;
   LONGLONG  ilrl_storerounds[4];  // values of rounds performed in a certain milliseconds time
   ULARGE_INTEGER  dsul_time_1;
   ULARGE_INTEGER  dsul_time_2;
   ULARGE_INTEGER  dsul_deltatime;
   double  fdl_calc;
   double  fdl_numerator;
   double  fdl_denominat;
   double  fdl_pi_avg;
   DISK_GEOMETRY dsl_pdg;  // disk drive geometry structure
   FILETIME  dsl_ft_startcutimi;
   FILETIME  dsl_ft_currenttime;
   //
   // check input parameter
   if (ailp_wallis_rounds == NULL)
      return(-1L);
   // test GetSystemTimeAsFileTime function
   GetSystemTimeAsFileTime(&dsl_ft_currenttime);
   if ((dsl_ft_currenttime.dwHighDateTime == 0L) && (dsl_ft_currenttime.dwLowDateTime == 0L))
      return(-2L);
   //
   ilrl_storerounds[2] = 0L;
   ilrl_storerounds[3] = 0L;
   fdl_calc = 0.0;
   fdl_pi_avg = 0.0;
   inl_loops = 2;
   // perform 2 - 4 loops depending on the system performance
   for (inl1 = 0; inl1 < inl_loops; inl1++)
   {
     // force a small interrupt to break a correlation between the loops and at the beginning
     Sleep(3);  // wait for 3 msec
     // get start time for current loop
     GetSystemTimeAsFileTime(&dsl_ft_startcutimi);
     //
     // initialize variables
     dsul_time_1.u.HighPart = dsl_ft_currenttime.dwHighDateTime;
     dsul_time_1.u.LowPart = dsl_ft_currenttime.dwLowDateTime;
     ilrl_storerounds[inl1] = dsul_time_1.QuadPart;
     dsul_time_2.u.HighPart = dsl_ft_startcutimi.dwHighDateTime;
     dsul_time_2.u.LowPart = dsl_ft_startcutimi.dwLowDateTime;
     fdl_calc = 1.0;
     //
     inl_val = m_getdrivegeometry(&dsl_pdg);
     //
     // perform loop with milliseconds timer
     for (ill1 = 0; ill1 < 0x100000000000L; ill1++)  // absolute limit as emergency break
     {
       ill2 = (ill1 + 2) & (~0x01);
       fdl_numerator = (double)ill2;
       ill2 = (ill1 + 1) + (ill1 & 0x01);
       fdl_denominat = (double)ill2;
       fdl_calc = (fdl_calc * (fdl_numerator / fdl_denominat));  // calculation on double float values
       //
       // get current time and do additional delta time calculation steps
       GetSystemTimeAsFileTime(&dsl_ft_currenttime);
       dsul_time_1.u.HighPart = dsl_ft_currenttime.dwHighDateTime;
       dsul_time_1.u.LowPart = dsl_ft_currenttime.dwLowDateTime;
       dsul_deltatime.QuadPart = (dsul_time_1.QuadPart - dsul_time_2.QuadPart);
       //
       // check the resulting time and break after 137 msec
       if (dsul_deltatime.QuadPart > 0L)
       { // time differences may cause a sign problem on multi-core CPUs
         if ((dsul_deltatime.QuadPart / 10000L) > 137L)  // scaling: 100nsec / 10000 = 1msec
         { // store the number of loop cycles that correlate with CPU load
           ilrl_storerounds[inl1] = ill1;
           break;  // break to store the values that correlate with CPU load
         }
       }
     }
     if (((inl1 == 0) || (inl1 == 1)) && (inl_loops < 4))
     { // increment the number of loops, if the number of rounds is not large enough
       if (ill1 < 2200000L)
          inl_loops++;
       if ((inl1 == 0) && (ill1 < 1100000L))
          inl_loops++;
     }
     fdl_pi_avg += fdl_calc;
   } // end of for (inl1 = 0; inl1 < inl_loops; inl1++)
   //
   //
   // test the generated number of rounds for identity
   // if an identical value is found clear the lower indexed one for result examination
   if (ilrl_storerounds[3] > 0L)
   {
     if (ilrl_storerounds[0] == ilrl_storerounds[3])
        ilrl_storerounds[0] = 0L;
     if (ilrl_storerounds[1] == ilrl_storerounds[3])
        ilrl_storerounds[1] = 0L;
     if (ilrl_storerounds[2] == ilrl_storerounds[3])
        ilrl_storerounds[2] = 0L;
   }
   if (ilrl_storerounds[2] > 0L)
   {
     if (ilrl_storerounds[0] == ilrl_storerounds[2])
        ilrl_storerounds[0] = 0L;
     if (ilrl_storerounds[1] == ilrl_storerounds[2])
        ilrl_storerounds[1] = 0L;
   }
   if (ilrl_storerounds[1] > 0L)
   {
     if (ilrl_storerounds[0] == ilrl_storerounds[1])
        ilrl_storerounds[0] = 0L;
   }
   //
   // set output values to return pointer elements
   (ailp_wallis_rounds[0]).QuadPart = ilrl_storerounds[0];
   (ailp_wallis_rounds[1]).QuadPart = ilrl_storerounds[1];
   (ailp_wallis_rounds[2]).QuadPart = ilrl_storerounds[2];
   (ailp_wallis_rounds[3]).QuadPart = ilrl_storerounds[3];
   //
   for (inl1 = 0; inl1 < 4; inl1++)
      ilrl_storerounds[inl1] = 0L;
   // return the average pi value of all loops
   fdl_calc = (fdl_pi_avg / ((double)inl_loops));
   return((long)(fdl_calc * 2000000.0));  // this is the punch line of the method
}  // end of static int m_calc_pi_wallis(...)
//
#else  // !defined WIN32 || !defined WIN64 ==> UNIX/Linux
//
static long m_calc_pi_wallis(split_long_t * adsp_wallis_rounds)
{
   int inl1;
   int  inl_loops;
   int  inl_val;
   long long  ill1, ill2;
   long long  ill3, ill4;
   long long  ill_deltatime;
   long long  ilrl_storerounds[4];  // values of rounds performed in a certain milliseconds time
   double  fdl_calc;
   double  fdl_numerator;
   double  fdl_denominat;
   double  fdl_pi_avg;
   struct timeval  dsl_tv_startcutimi;
   struct timeval  dsl_tv_currenttime;
   //
   // check input parameter
   if (adsp_wallis_rounds == NULL)
      return(-1L);
   // test gettimeofday function
   if (gettimeofday(&dsl_tv_currenttime, NULL) != 0)
      return(-2L);
   //
   ilrl_storerounds[2] = 0LL;
   ilrl_storerounds[3] = 0LL;
   fdl_calc = 0.0;
   fdl_pi_avg = 0.0;
   inl_loops = 2;
   // perform 2 - 4 loops depending on the system performance
   for (inl1 = 0; inl1 < inl_loops; inl1++)
   {
     // force a small interrupt to break a correlation between the loops
     Sleep(3);  // wait for 3 msec
     // get start time for current loop
     gettimeofday(&dsl_tv_startcutimi, NULL);
     //
     // initialize variables
     ill4 = ((((long long)(dsl_tv_currenttime.tv_sec)) * 1000000LL) +
              ((long long)(dsl_tv_currenttime.tv_usec)));
     ilrl_storerounds[inl1] = ill4;
     ill4 = ((((long long)(dsl_tv_startcutimi.tv_sec)) * 1000000LL) +
              ((long long)(dsl_tv_startcutimi.tv_usec)));
     fdl_calc = 1.0;
     //
#if !(TARGET_IPHONE_SIMULATOR == 1)
     inl_val = m_execute_command(ach_commands_df, achrl_delimit_ps[0], 0, 
                                 NULL, 0, NULL, NULL);
#endif
     //
     // perform loop with milliseconds timer
     for (ill1 = 0LL; ill1 < 0x100000000000LL; ill1++)  // absolute limit as emergency break
     {
       // perform one step of the Wallis product calculation
       ill2 = ((ill1 + 2L) & (~0x01));
       fdl_numerator = (double)ill2;
       ill2 = ((ill1 + 1L) + (ill1 & 0x01));
       fdl_denominat = (double)ill2;
       fdl_calc = (fdl_calc * (fdl_numerator / fdl_denominat));  // calculation on double float values
       //
       // get current time and do additional delta time calculation steps
       gettimeofday(&dsl_tv_currenttime, NULL);
       ill3 = ((((long long)(dsl_tv_currenttime.tv_sec)) * 1000000LL) +
                ((long long)(dsl_tv_currenttime.tv_usec)));
       ill_deltatime = (ill3 - ill4);
       //
       // check the resulting time and break after 137 msec
       if (ill_deltatime > 0L)
       { // time differences may cause a sign problem on multi-core CPUs
         if ((ill_deltatime / 1000LL) > 137LL)  // scaling: 1usec / 1000 = 1msec
         {
           ilrl_storerounds[inl1] = ill1;
           break;  // break to store the values that correlate with CPU load
         }
       }
     }
     if (((inl1 == 0) || (inl1 == 1)) && (inl_loops < 4))
     { // increment the number of loops, if the number of rounds is not large enough
       if (ill1 < 2200000LL)
          inl_loops++;
       if ((inl1 == 0) && (ill1 < 1100000LL))
          inl_loops++;
     }
     fdl_pi_avg += fdl_calc;
   } // end of for (inl1 = 0; inl1 < inl_loops; inl1++)
   //
   //
   // test the generated number of rounds for identity
   if (ilrl_storerounds[3] > 0LL)
   {
     if (ilrl_storerounds[0] == ilrl_storerounds[3])
        ilrl_storerounds[0] = 0LL;
     if (ilrl_storerounds[1] == ilrl_storerounds[3])
        ilrl_storerounds[1] = 0LL;
     if (ilrl_storerounds[2] == ilrl_storerounds[3])
        ilrl_storerounds[2] = 0LL;
   }
   if (ilrl_storerounds[2] > 0LL)
   {
     if (ilrl_storerounds[0] == ilrl_storerounds[2])
        ilrl_storerounds[0] = 0LL;
     if (ilrl_storerounds[1] == ilrl_storerounds[2])
        ilrl_storerounds[1] = 0LL;
   }
   if (ilrl_storerounds[1] > 0LL)
   {
     if (ilrl_storerounds[0] == ilrl_storerounds[1])
        ilrl_storerounds[0] = 0LL;
   }
   // set output values to return pointer elements
   (&(adsp_wallis_rounds[0]))->ull_value = ilrl_storerounds[0];
   (&(adsp_wallis_rounds[1]))->ull_value = ilrl_storerounds[1];
   (&(adsp_wallis_rounds[2]))->ull_value = ilrl_storerounds[2];
   (&(adsp_wallis_rounds[3]))->ull_value = ilrl_storerounds[3];
   //
   for (inl1 = 0; inl1 < 4; inl1++)
      ilrl_storerounds[inl1] = 0LL;
   // return the average pi value of all loops
   fdl_calc = (fdl_pi_avg / ((double)inl_loops));
   return((long)(fdl_calc * 2000000.0));  // this is the punch line of the method
}  // end of static int m_calc_pi_wallis(...)
//
#endif  // WIN/UNIX
//
//=============================================================
// Windows only: entropy gathering functions
//=============================================================
//
#if defined _WIN32
/**
* HashSysTimes - 
* Hash system times with "GetSystemTimes", 
* if function is available on the current system.
* -- Windows Version --
*
* 
*  @param pShaArray  SHA256 array to use
*  @return int state
*  <br>            > 0 o.k. number of bytes hashed
*  <br>            == 0 function not available
*  <br>            < 0 error condition
*/
static  int HashSysTimes(int* pShaArray)
{
   HMODULE  inl_hmod_lib;
   FARPROC  dsl_hdl_adr;
   FILETIME  dsl_idletime;
   FILETIME  dsl_kerneltime;
   FILETIME  dsl_usertime;

   //-----------------------------------------------------------
   // Get Address of function "GetSystemTimes" from kernel32.dll
   //-----------------------------------------------------------
   if ((inl_hmod_lib = LoadLibraryA("kernel32.dll")) == NULL)
   {
     ;
     return(-1);
   }
   if ((dsl_hdl_adr = GetProcAddress(inl_hmod_lib, "GetSystemTimes")) == NULL)
   {
     FreeLibrary(inl_hmod_lib);
     ;
     return(0);
   }
   //-----------------------------------------------------------
   // Call "GetSystemTimes" and hash the three return values
   //-----------------------------------------------------------
   ((void (_stdcall *)(FILETIME *,FILETIME *, FILETIME *)) *dsl_hdl_adr)
          (&dsl_idletime, &dsl_kerneltime, &dsl_usertime);
   SHA256_Update(pShaArray,(char*)(&dsl_idletime),0,sizeof(FILETIME));
   SHA256_Update(pShaArray,(char*)(&dsl_kerneltime),0,sizeof(FILETIME));
   SHA256_Update(pShaArray,(char*)(&dsl_usertime),0,sizeof(FILETIME));
   FreeLibrary(inl_hmod_lib);

   return(sizeof(FILETIME) * 3);
} // end of PRIVATE STATIC int HashSysTimes(...)
//
//
/**
* HashPerfInfo - 
* Hash performance information with "GetPerformanceInfo",
* if function is available on the current system.
* -- Windows Version --
*
* 
*  @param pShaArray  SHA256 array to use
*  @return int state
*  <br>            > 0 o.k. number of bytes hashed
*  <br>            == 0 function not available
*  <br>            < 0 error condition
*/
static  int HashPerfInfo(int* pShaArray)
{
   HMODULE  inl_hmod_lib;
   FARPROC  dsl_hdl_adr;
   PERFORMANCE_INFORMATION   dsl_performinform;

   //------------------------------------------------------------
   // Get Address of function "GetPerformanceInfo" from Psapi.dll
   //------------------------------------------------------------
   if ((inl_hmod_lib = LoadLibraryA("Psapi.dll")) == NULL)
   {
     ;
     return(-1);
   }
   if ((dsl_hdl_adr = GetProcAddress(inl_hmod_lib, "GetPerformanceInfo")) == NULL)
   {
     ;
     return(0);
   }
   //----------------------------------------------------
   // Call "GetPerformanceInfo" and hash the return value
   //----------------------------------------------------
   ((void (_stdcall *) (PERFORMANCE_INFORMATION *, int)) *dsl_hdl_adr)
	      	(&dsl_performinform, sizeof(PERFORMANCE_INFORMATION));
   SHA256_Update(pShaArray,(char*)(&dsl_performinform),0,sizeof(PERFORMANCE_INFORMATION));
   FreeLibrary(inl_hmod_lib);

   return(sizeof(PERFORMANCE_INFORMATION));
} // end of PRIVATE STATIC int HashPerfInfo(...)
//
//
/**
* HashProcessInfo - 
* Hash process information for a given process entry.
* -- Windows Version --
*
* 
*  @param dsp_proc_entry32
*  @param pShaArray  SHA256 array to use
*  @return int state
*  <br>           > 0 o.k. number of bytes hashed
*  <br>           == 0 function not available
*  <br>           < 0 error condition
*/
static  int HashProcessInfo(PROCESSENTRY32 dsp_proc_entry32, int* pShaArray)
{
   int inl1 = 0;
   int inl_bytes_hashed = 0;
   DWORD uml_priorityclass;
   DWORD uml_funresult;
   HANDLE dsl_hdl_th32process;
   IO_COUNTERS dsl_io_counters;
   FILETIME dsl_ftcreationtime;
   FILETIME dsl_ftexittime;
   FILETIME dsl_ftkerneltime;
   FILETIME dsl_ftusertime;
   PROCESS_MEMORY_COUNTERS dsl_procmemocountrs;
   //
   // Open the process of the process ID that the passed ProcessEntry contains
   uml_priorityclass = 0;
   dsl_hdl_th32process = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dsp_proc_entry32.th32ProcessID);
   if (dsl_hdl_th32process == NULL)
   {
     uml_funresult = GetLastError();
     SHA256_Update(pShaArray,(char*)(&uml_funresult),0,sizeof(DWORD));
     inl_bytes_hashed += sizeof(DWORD);
     return(-1);
   }
   //
   // Get the priority class value of the opened process
   uml_priorityclass = GetPriorityClass(dsl_hdl_th32process);
   if (uml_priorityclass == 0)
   {
     uml_funresult = GetLastError();
     SHA256_Update(pShaArray,(char*)(&uml_funresult),0,sizeof(DWORD));
     inl_bytes_hashed += sizeof(DWORD);
   }
   else
   {
     SHA256_Update(pShaArray,(char*)(&uml_priorityclass),0,sizeof(DWORD));
     inl1++;
     inl_bytes_hashed += sizeof(DWORD);
   }
   //
   // Get the IO counter values of the opened process with ReadOperationCount, WriteOperationCount, 
   // OtherOperationCount, ReadTransferCount, WriteTransferCount and OtherTransferCount
   if (GetProcessIoCounters(dsl_hdl_th32process, &dsl_io_counters) == FALSE)
   {
     uml_funresult = GetLastError();
     SHA256_Update(pShaArray,(char*)(&uml_funresult),0,sizeof(DWORD));
     inl_bytes_hashed += sizeof(DWORD);
   }
   else
   {
     SHA256_Update(pShaArray,(char*)(&dsl_io_counters),0,sizeof(IO_COUNTERS));
     inl1++;
     inl_bytes_hashed += sizeof(IO_COUNTERS);
   }
   //
   // Get the process time values of the opened process with creation, exit, kernel and user time
   if (GetProcessTimes(dsl_hdl_th32process, &dsl_ftcreationtime, &dsl_ftexittime,
                       &dsl_ftkerneltime, &dsl_ftusertime) == FALSE)
   {
     uml_funresult = GetLastError();
     SHA256_Update(pShaArray,(char*)(&uml_funresult),0,sizeof(DWORD));
     inl_bytes_hashed += sizeof(DWORD);
   }
   else
   {
     SHA256_Update(pShaArray,(char*)(&dsl_ftcreationtime),0,sizeof(FILETIME));
     SHA256_Update(pShaArray,(char*)(&dsl_ftexittime),0,sizeof(FILETIME));
     SHA256_Update(pShaArray,(char*)(&dsl_ftkerneltime),0,sizeof(FILETIME));
     SHA256_Update(pShaArray,(char*)(&dsl_ftusertime),0,sizeof(FILETIME));
     inl1++;
     inl_bytes_hashed += (sizeof(FILETIME) * 4);
   }
   //
   // Get the process memory info values of the opened process
   if (GetProcessMemoryInfo(dsl_hdl_th32process, &dsl_procmemocountrs, sizeof(PROCESS_MEMORY_COUNTERS)) == FALSE)
   {
     uml_funresult = GetLastError();
     SHA256_Update(pShaArray,(char*)(&uml_funresult),0,sizeof(DWORD));
     inl_bytes_hashed += sizeof(DWORD);
   }
   else
   {
     SHA256_Update(pShaArray,(char*)(&dsl_procmemocountrs),0,sizeof(PROCESS_MEMORY_COUNTERS));
     inl1++;
     inl_bytes_hashed += sizeof(PROCESS_MEMORY_COUNTERS);
   }
   // Close the process handle
   CloseHandle (dsl_hdl_th32process);
   // Check return value
   if (inl1 > 0)
      return(inl_bytes_hashed);
   else
      return(inl1);
} // end of PRIVATE STATIC int HashProcessInfo(...)
//
//
/**
* CollectSnapshots - 
* Collect information related to all processes running on the 
* system that can be accessed. This is the Priority class, the 
* process IO counters, the process times and the process memory 
* information. Furthermore module and thread information is 
* collected which is related to each found process.
* <br>
* -- Windows Version --
*
* 
*  @param pShaArray  SHA256 array to use
*  @return int state
*  <br>            > 0 o.k. number of bytes hashed
*  <br>            == 0 function not available
*  <br>            < 0 error condition
*/
static  int CollectSnapshots(int* pShaArray)
{
   int inl1;
   int inl_retcode;
   int inl_bytes_hashed;
   BOOL bol_funcret1;
   DWORD uml_process_count;
   DWORD uml_modules_count;
   DWORD uml_threads_count;
   DWORD uml_funresult;
   HANDLE dsl_hdl_snapprocess;
   HANDLE dsl_hdl_snapmodule;
   HANDLE dsl_hdl_snapthread;
   FILETIME dsl_procwatchtime;
   FILETIME dsl_processtime;
   ULARGE_INTEGER dsl_time1;
   ULARGE_INTEGER dsl_time2;
   PROCESSENTRY32 dsl_procentry32;
   MODULEENTRY32 dsl_modulentry32;
   THREADENTRY32 dsl_threadentry32;
   //
   // initialize variables
   inl1 = 0;
   inl_bytes_hashed = 0;
   uml_process_count = 0;
   uml_modules_count = 0;
   uml_threads_count = 0;
   //
   // get information related to all processes in the system and the current thread
   dsl_hdl_snapprocess = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
   if (dsl_hdl_snapprocess == INVALID_HANDLE_VALUE)
   {
     uml_funresult = GetLastError();
     SHA256_Update(pShaArray,(char*)(&uml_funresult),0,sizeof(DWORD));
     inl_bytes_hashed += sizeof(DWORD);
     return(-1);
   }
   else
   {
     // set the size of the structure before using it and initialize timeout processing
     dsl_procentry32.dwSize = sizeof(PROCESSENTRY32);
     dsl_procwatchtime.dwHighDateTime = 0;
     dsl_procwatchtime.dwLowDateTime = 0;
     SHA256_Update(pShaArray,(char*)(&dsl_hdl_snapprocess),0,sizeof(HANDLE));
     inl_bytes_hashed += sizeof(HANDLE);
     //
     // retrieve information about the first process
     if (Process32First(dsl_hdl_snapprocess, &dsl_procentry32) == FALSE)
     {
       uml_funresult = GetLastError();
       SHA256_Update(pShaArray,(char*)(&uml_funresult),0,sizeof(DWORD));
       inl_bytes_hashed += sizeof(DWORD);
       CloseHandle(dsl_hdl_snapprocess);
       return(0);
     }
     //
     // loop the snapshot of processes, and get information about each process in turn
     do
     {
       uml_process_count++;  // loop count
//       printf("NextProcess\n");
       //
       // function hashes all the process info and returns the number of hashed bytes
       inl_retcode = HashProcessInfo(dsl_procentry32, pShaArray);
       if (inl_retcode > 0)
       {
         inl1++;
         inl_bytes_hashed += inl_retcode;
       }
       else
       { // if the HashProcessInfo fails in consequence of missing access rights, it consumes a lot of time
         if (inl_retcode < 0)
         {
           if ((dsl_procwatchtime.dwLowDateTime == 0) && (dsl_procwatchtime.dwHighDateTime == 0))
              GetSystemTimeAsFileTime(&dsl_procwatchtime);
           else
           {
             GetSystemTimeAsFileTime(&dsl_processtime);
             dsl_time1.u.HighPart = dsl_processtime.dwHighDateTime;
             dsl_time1.u.LowPart = dsl_processtime.dwLowDateTime;
             dsl_time2.u.HighPart = dsl_procwatchtime.dwHighDateTime;
             dsl_time2.u.LowPart = dsl_procwatchtime.dwLowDateTime;
             // if error situations take more than 2 seconds, stop the process hashing
             if ((dsl_time1.QuadPart - dsl_time2.QuadPart) > 20000000L)  // 2 sec.
             {
               // add time information to console output
               break;
             }
           }
         }
       }
       //
       //-------------------------------------------------
       // Make a snapshot of modules used by given process
       //-------------------------------------------------
       for ( ; ; )  // not a loop
       {
         // list the modules associated with this process
         dsl_hdl_snapmodule = CreateToolhelp32Snapshot(TH32CS_SNAPMODULE, dsl_procentry32.th32ProcessID);
         if (dsl_hdl_snapmodule == INVALID_HANDLE_VALUE )
         {
           uml_funresult = GetLastError();
           SHA256_Update(pShaArray,(char*)(&uml_funresult),0,sizeof(DWORD));
           inl_bytes_hashed += sizeof(DWORD);
           break;
         }
         // set the size of the structure before using it
         dsl_modulentry32.dwSize = sizeof(MODULEENTRY32);
         // retrieve information about the first module
         if (Module32First(dsl_hdl_snapmodule, &dsl_modulentry32) == FALSE)
         {
           uml_funresult = GetLastError();
           SHA256_Update(pShaArray,(char*)(&uml_funresult),0,sizeof(DWORD));
           inl_bytes_hashed += sizeof(DWORD);
           CloseHandle(dsl_hdl_snapmodule);
           break;
         }
         //-------------------------------------------------
         // Hash module information of all modules
         //-------------------------------------------------
//         printf("Have first module!\n");
         do
         {
           uml_modules_count++;
           SHA256_Update(pShaArray,(char*)(&dsl_modulentry32),0,sizeof(MODULEENTRY32));
           inl1++;
           inl_bytes_hashed += sizeof(MODULEENTRY32);
//           printf("NextModule\n");
         }
         while(Module32Next(dsl_hdl_snapmodule, &dsl_modulentry32) != 0);

         CloseHandle(dsl_hdl_snapmodule);
         break;
       }
       //
       //-------------------------------------------------
       // Make a snapshot of threads used by given process
       //-------------------------------------------------
       for ( ; ; )
       {
         // take a snapshot of all running threads  
         dsl_hdl_snapthread = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, 0);
         if (dsl_hdl_snapthread == INVALID_HANDLE_VALUE)
         {
           uml_funresult = GetLastError();
           SHA256_Update(pShaArray,(char*)(&uml_funresult),0,sizeof(DWORD));
           inl_bytes_hashed += sizeof(DWORD);
           break;
         }
         // set the size of the structure before using it.
         dsl_threadentry32.dwSize = sizeof(THREADENTRY32); 
         // retrieve information about the first thread
         if (Thread32First(dsl_hdl_snapthread, &dsl_threadentry32) == FALSE)
         {
           uml_funresult = GetLastError();
           SHA256_Update(pShaArray,(char*)(&uml_funresult),0,sizeof(DWORD));
           inl_bytes_hashed += sizeof(DWORD);
           CloseHandle(dsl_hdl_snapthread);
           break;
         }
         //---------------------------------------
         // Hash thread information of all threads
         //---------------------------------------
         do
         {
           uml_threads_count++;
           SHA256_Update(pShaArray,(char*)(&dsl_threadentry32),0,sizeof(THREADENTRY32));
           inl1++;
           inl_bytes_hashed += sizeof(THREADENTRY32);
//           printf("NextThread\n");
         }
         while(Thread32Next(dsl_hdl_snapthread,&dsl_threadentry32) != 0);

         CloseHandle(dsl_hdl_snapthread);
         break;
       }

       bol_funcret1 = Process32Next(dsl_hdl_snapprocess, &dsl_procentry32);
       if (bol_funcret1 == FALSE)
       {
         uml_funresult = GetLastError();
         if (uml_funresult != ERROR_NO_MORE_FILES)
         {
           SHA256_Update(pShaArray,(char*)(&uml_funresult),0,sizeof(DWORD));
           inl_bytes_hashed += sizeof(DWORD);
         }
       }
     } while (bol_funcret1 != FALSE);
     //
     // close the process handle
     CloseHandle(dsl_hdl_snapprocess);
     dsl_hdl_snapprocess = NULL;
     //
     // check, if the HashProcessInfo function was stopped by a timeout
     if ((dsl_procwatchtime.dwLowDateTime != 0) || (dsl_procwatchtime.dwHighDateTime != 0))
     {
       SHA256_Update(pShaArray,(char*)(&dsl_procwatchtime),0,sizeof(FILETIME));
       inl_bytes_hashed += sizeof(FILETIME);
       SHA256_Update(pShaArray,(char*)(&dsl_processtime),0,sizeof(FILETIME));
       inl_bytes_hashed += sizeof(FILETIME);
     }
     //
//     printf("Processes: %d\n",uml_process_count);
//     printf("Modules:   %d\n",uml_modules_count);
//     printf("Threads:   %d\n",uml_threads_count);
   } // if (dsl_hdl_snapprocess == INVALID_HANDLE_VALUE)
   //
   if (inl1 > 0)
   {
     uml_funresult = (uml_process_count + uml_modules_count + uml_threads_count);
     SHA256_Update(pShaArray,(char*)(&uml_funresult),0,sizeof(DWORD));
     inl_bytes_hashed += sizeof(DWORD);
     // return number of hashed bytes
     return(inl_bytes_hashed);
   }
   else
      return(inl1);
} // end of PRIVATE STATIC int CollectSnapshots(...)
//
//
/**
* GetNetHashes - 
* Hash network tables and statistics. Get network information 
* that results from functions in "iphlpapi.dll": GetIfTable, 
* GetIpNetTable, GetIpStatistics, GetUdpTable, GetUdpStatistics, 
* GetTcpTable and GetTcpStatistics.
* <br>
* -- Windows Version --
*
* 
*  @param pShaArray  SHA256 array to use
*  @return int state 
*  <br>            > 0 o.k. number of bytes hashed
*  <br>            == 0 function not available
*  <br>            < 0 error condition
*/
static  int GetNetHashes(HMEM_CTX_DEF int* pShaArray)
{
   int inl1;
   int inl_table_len;
   int inl_bytes_hashed;
   DWORD uml_testval;
   DWORD uml_alloclen;
   DWORD uml_funresult;
   char* abyl_pbuff = NULL;
   HMODULE dsl_hmdl_loli_ippa;
   DWORD (WINAPI * dsl_fprocfunc)(void *);
   //
   // initialize variables
   inl1 = 0;
   inl_bytes_hashed = 0;
   abyl_pbuff = NULL;
   //
   //--------------------------
   // Load the iphlpapi library
   //--------------------------
   dsl_hmdl_loli_ippa = LoadLibraryA("iphlpapi.dll");  // load the library that contains the necessary functions
   if (dsl_hmdl_loli_ippa == NULL)
   {
     uml_funresult = GetLastError();
     SHA256_Update(pShaArray,(char*)(&uml_funresult),0,sizeof(DWORD));
     inl1 = (int)uml_funresult;
     if (inl1 > 0)
        inl1 = 0;
   }
   else
   {
   	 //
     //----------------------------
     // Hash the Interface(s) table
     //----------------------------
     dsl_fprocfunc = (DWORD (WINAPI *)(void *))GetProcAddress(dsl_hmdl_loli_ippa, "GetIfTable");
     if (dsl_fprocfunc == NULL)
     {
       uml_funresult = GetLastError();
       SHA256_Update(pShaArray,(char*)(&uml_funresult),0,sizeof(DWORD));
     }
     else
     {
       // get network statistics: Interface table -- The GetIfTable function retrieves the MIB-II interface table.
       inl_table_len = 0;
       uml_testval = (((int (WINAPI *) (void*, PULONG, int))dsl_fprocfunc)(NULL, (PULONG)(&inl_table_len), 0));  // get required size
       if ((uml_testval != NO_ERROR) && (uml_testval != ERROR_INSUFFICIENT_BUFFER))
       {
         uml_funresult = GetLastError();
         SHA256_Update(pShaArray,(char*)(&uml_funresult),0,sizeof(DWORD));
       }
       else
       {
         uml_alloclen = (((DWORD)inl_table_len + (2 * sizeof(DWORD))) & (~(sizeof(DWORD) - 1)));
         if ((abyl_pbuff = BIT8_ARRAY_ALLOC(HMEM_CTX_REF, (uml_alloclen * sizeof(unsigned char)))) != NULL)
         {
           memset(((void *)abyl_pbuff), 0, uml_alloclen);
           uml_testval = (((int (WINAPI *) (void*, PULONG, int))dsl_fprocfunc)(((void *)abyl_pbuff), (PULONG)(&inl_table_len), 0));
           if (uml_testval != NO_ERROR)
           {
             uml_funresult = GetLastError();
             SHA256_Update(pShaArray,(char*)(&uml_funresult),0,sizeof(DWORD));
           }
           else
           {
             ;
             SHA256_Update(pShaArray,abyl_pbuff,0,inl_table_len);
             inl_bytes_hashed += inl_table_len;
             inl1++;
           }
           FREE_ARRAY(HMEM_CTX_REF, abyl_pbuff);
           abyl_pbuff = NULL;
         }
       }
     }
     //
     //--------------------------
     // Hash the IP network table
     //--------------------------
     dsl_fprocfunc = (DWORD (WINAPI *)(void *))GetProcAddress(dsl_hmdl_loli_ippa, "GetIpNetTable");
     if (dsl_fprocfunc == NULL)
     {
       uml_funresult = GetLastError();
       SHA256_Update(pShaArray,(char*)(&uml_funresult),0,sizeof(DWORD));
     }
     else
     {
       // get network statistics: IP network table -- The GetIpNetTable function retrieves the IPv4 to physical address mapping table.
       inl_table_len = 0;
       uml_testval = (((int (WINAPI *) (void*, PULONG, int))dsl_fprocfunc)(NULL, (PULONG)(&inl_table_len), 0));  // get required size
       if ((uml_testval != NO_ERROR) && (uml_testval != ERROR_INSUFFICIENT_BUFFER))
       {
         uml_funresult = GetLastError();
         SHA256_Update(pShaArray,(char*)(&uml_funresult),0,sizeof(DWORD));
       }
       else
       {
         uml_alloclen = (((DWORD)inl_table_len + (2 * sizeof(DWORD))) & (~(sizeof(DWORD) - 1)));
         if ((abyl_pbuff = BIT8_ARRAY_ALLOC(HMEM_CTX_REF, (uml_alloclen * sizeof(unsigned char)))) != NULL)
         {
           memset(((void *)abyl_pbuff), 0, uml_alloclen);
           uml_testval = (((int (WINAPI *) (void*, PULONG, int))dsl_fprocfunc)(((void *)abyl_pbuff), (PULONG)(&inl_table_len), 0));
           if (uml_testval != NO_ERROR)
           {
             uml_funresult = GetLastError();
             SHA256_Update(pShaArray,(char*)(&uml_funresult),0,sizeof(DWORD));
           }
           else
           {
             ;
             SHA256_Update(pShaArray,abyl_pbuff,0,inl_table_len);
             inl_bytes_hashed += inl_table_len;
             inl1++;
           }
           FREE_ARRAY(HMEM_CTX_REF, abyl_pbuff);
           abyl_pbuff = NULL;
         }
       }
     }
     //
     //-------------------------------
     // Hash the IP network statistics
     //-------------------------------
     dsl_fprocfunc = (DWORD (WINAPI *)(void *))GetProcAddress(dsl_hmdl_loli_ippa, "GetIpStatistics");
     if (dsl_fprocfunc == NULL)
     {
       uml_funresult = GetLastError();
       SHA256_Update(pShaArray,(char*)(&uml_funresult),0,sizeof(DWORD));
     }
     else
     {
       // get network statistics: IP statistics -- The GetIpStatistics function retrieves the IP statistics for the current computer.
       inl_table_len = sizeof(MIB_IPSTATS);
       uml_alloclen = (((DWORD)inl_table_len + (2 * sizeof(DWORD))) & (~(sizeof(DWORD) - 1)));
       if ((abyl_pbuff = BIT8_ARRAY_ALLOC(HMEM_CTX_REF, (uml_alloclen * sizeof(unsigned char)))) != NULL)
       {
         memset(((void *)abyl_pbuff), 0, uml_alloclen);
         uml_testval = dsl_fprocfunc((void *)abyl_pbuff);
         if (uml_testval != NO_ERROR)
         {
           uml_funresult = GetLastError();
           SHA256_Update(pShaArray,(char*)(&uml_funresult),0,sizeof(DWORD));
         }
         else
         {
           ;
           SHA256_Update(pShaArray,abyl_pbuff,0,inl_table_len);
           inl_bytes_hashed += inl_table_len;
           inl1++;
         }
         FREE_ARRAY(HMEM_CTX_REF, abyl_pbuff);
         abyl_pbuff = NULL;
       }
     }
     //
     //---------------------------
     // Hash the UDP network table
     //---------------------------
     dsl_fprocfunc = (DWORD (WINAPI *)(void *))GetProcAddress(dsl_hmdl_loli_ippa, "GetUdpTable");
     if (dsl_fprocfunc == NULL)
     {
       uml_funresult = GetLastError();
       SHA256_Update(pShaArray,(char*)(&uml_funresult),0,sizeof(DWORD));
     }
     else
     {
       // get network statistics: UDP network table -- The GetUdpTable function retrieves the IPv4 User Datagram Protocol (UDP) listener table.
       inl_table_len = 0;
       uml_testval = (((int (WINAPI *) (void*, PULONG, int))dsl_fprocfunc)(NULL, (PULONG)(&inl_table_len), 0));  // get required size
       if ((uml_testval != NO_ERROR) && (uml_testval != ERROR_INSUFFICIENT_BUFFER))
       {
         uml_funresult = GetLastError();
         SHA256_Update(pShaArray,(char*)(&uml_funresult),0,sizeof(DWORD));
       }
       else
       {
         uml_alloclen = (((DWORD)inl_table_len + (2 * sizeof(DWORD))) & (~(sizeof(DWORD) - 1)));
         if ((abyl_pbuff = BIT8_ARRAY_ALLOC(HMEM_CTX_REF, (uml_alloclen * sizeof(unsigned char)))) != NULL)
         {
           memset(((void *)abyl_pbuff), 0, uml_alloclen);
           uml_testval = (((int (WINAPI *) (void*, PULONG, int))dsl_fprocfunc)(((void *)abyl_pbuff), (PULONG)(&inl_table_len), 0));
           if (uml_testval != NO_ERROR)
           {
             uml_funresult = GetLastError();
             SHA256_Update(pShaArray,(char*)(&uml_funresult),0,sizeof(DWORD));
           }
           else
           {
             ;
             SHA256_Update(pShaArray,abyl_pbuff,0,inl_table_len);
             inl_bytes_hashed += inl_table_len;
             inl1++;
           }
           FREE_ARRAY(HMEM_CTX_REF, abyl_pbuff);
           abyl_pbuff = NULL;
         }
       }
     }
     //
     //--------------------------------
     // Hash the UDP network statistics
     //--------------------------------
     dsl_fprocfunc = (DWORD (WINAPI *)(void *))GetProcAddress(dsl_hmdl_loli_ippa, "GetUdpStatistics");
     if (dsl_fprocfunc == NULL)
     {
       uml_funresult = GetLastError();
       SHA256_Update(pShaArray,(char*)(&uml_funresult),0,sizeof(DWORD));
     }
     else
     {
       // get network statistics: UDP statistics -- The GetUdpStatistics function retrieves the User Datagram Protocol (UDP) statistics for the local computer.
       inl_table_len = sizeof(MIB_UDPSTATS);
       uml_alloclen = (((DWORD)inl_table_len + (2 * sizeof(DWORD))) & (~(sizeof(DWORD) - 1)));
       if ((abyl_pbuff = BIT8_ARRAY_ALLOC(HMEM_CTX_REF, (uml_alloclen * sizeof(unsigned char)))) != NULL)
       {
         memset(((void *)abyl_pbuff), 0, uml_alloclen);
         uml_testval = dsl_fprocfunc((void *)abyl_pbuff);
         if (uml_testval != NO_ERROR)
         {
           uml_funresult = GetLastError();
           SHA256_Update(pShaArray,(char*)(&uml_funresult),0,sizeof(DWORD));
         }
         else
         {
           ;
           SHA256_Update(pShaArray,abyl_pbuff,0,inl_table_len);
           inl_bytes_hashed += inl_table_len;
           inl1++;
         }
         FREE_ARRAY(HMEM_CTX_REF, abyl_pbuff);
         abyl_pbuff = NULL;
       }
     }
     //
     //---------------------------
     // Hash the TCP network table
     //---------------------------
     dsl_fprocfunc = (DWORD (WINAPI *)(void *))GetProcAddress(dsl_hmdl_loli_ippa, "GetTcpTable");
     if (dsl_fprocfunc == NULL)
     {
       uml_funresult = GetLastError();
       SHA256_Update(pShaArray,(char*)(&uml_funresult),0,sizeof(DWORD));
     }
     else
     {
       // get network statistics: TCP network table -- The GetTcpTable function retrieves the IPv4 TCP connection table.
       inl_table_len = 0;
       uml_testval = (((int (WINAPI *) (void*, PULONG, int))dsl_fprocfunc)(NULL, (PULONG)(&inl_table_len), 0));  // get required size
       if ((uml_testval != NO_ERROR) && (uml_testval != ERROR_INSUFFICIENT_BUFFER))
       {
         uml_funresult = GetLastError();
         SHA256_Update(pShaArray,(char*)(&uml_funresult),0,sizeof(DWORD));
       }
       else
       {
         uml_alloclen = (((DWORD)inl_table_len + (2 * sizeof(DWORD))) & (~(sizeof(DWORD) - 1)));
         if ((abyl_pbuff = BIT8_ARRAY_ALLOC(HMEM_CTX_REF, (uml_alloclen * sizeof(unsigned char)))) != NULL)
         {
           memset(((void *)abyl_pbuff), 0, uml_alloclen);
           uml_testval = (((int (WINAPI *) (void*, PULONG, int))dsl_fprocfunc)(((void *)abyl_pbuff), (PULONG)(&inl_table_len), 0));
           if (uml_testval != NO_ERROR)
           {
             uml_funresult = GetLastError();
             SHA256_Update(pShaArray,(char*)(&uml_funresult),0,sizeof(DWORD));
           }
           else
           {
             ;
             SHA256_Update(pShaArray,abyl_pbuff,0,inl_table_len);
             inl_bytes_hashed += inl_table_len;
             inl1++;
           }
           FREE_ARRAY(HMEM_CTX_REF, abyl_pbuff);
           abyl_pbuff = NULL;
         }
       }
     }
     //
     //--------------------------------
     // Hash the TCP network statistics
     //--------------------------------
     dsl_fprocfunc = (DWORD (WINAPI *)(void *))GetProcAddress(dsl_hmdl_loli_ippa, "GetTcpStatistics");
     if (dsl_fprocfunc == NULL)
     {
       uml_funresult = GetLastError();
       SHA256_Update(pShaArray,(char*)(&uml_funresult),0,sizeof(DWORD));
     }
     else
     {
       // get network statistics: TCP statistics -- The GetUdpStatistics function retrieves the User Datagram Protocol (UDP) statistics for the local computer.
       inl_table_len = sizeof(MIB_TCPSTATS);
       uml_alloclen = (((DWORD)inl_table_len + (2 * sizeof(DWORD))) & (~(sizeof(DWORD) - 1)));
       if ((abyl_pbuff = BIT8_ARRAY_ALLOC(HMEM_CTX_REF, (uml_alloclen * sizeof(unsigned char)))) != NULL)
       {
         memset(((void *)abyl_pbuff), 0, uml_alloclen);
         uml_testval = dsl_fprocfunc((void *)abyl_pbuff);
         if (uml_testval != NO_ERROR)
         {
           uml_funresult = GetLastError();
           SHA256_Update(pShaArray,(char*)(&uml_funresult),0,sizeof(DWORD));
         }
         else
         {
           ;
           SHA256_Update(pShaArray,abyl_pbuff,0,inl_table_len);
           inl_bytes_hashed += inl_table_len;
           inl1++;
         }
         FREE_ARRAY(HMEM_CTX_REF, abyl_pbuff);
         abyl_pbuff = NULL;
       }
     }
     //
     //--------------------------
     // Free the iphlpapi library
     //--------------------------
     if (FreeLibrary(dsl_hmdl_loli_ippa) == 0)
     {
       uml_funresult = GetLastError();
       SHA256_Update(pShaArray,(char*)(&uml_funresult),0,sizeof(DWORD));
     }
     dsl_hmdl_loli_ippa = NULL;
   } // end of else (dsl_hmdl_loli_ippa == NULL)
   //
   if (inl1 > 4)
      return(inl_bytes_hashed);
   else
   {
     if (inl1 > 0)
        return(0);
     else
        return(inl1);
   }
} // end of PRIVATE STATIC int GetNetHashes(...)
//
//
/**
* HashEvtDir - 
* Hash files in the eventlog directory/directories. 
* Registry path is "\HKLM\SYSTEM\CurrentControlSet\Services\Eventlog".
* <br>
* -- Windows Version --
*
* Read from registry: HKEY_LOCAL_MACHINE\SYSTEM\...\Eventlog\...;
* enumerate all keys (nodes) in "HKLMACHINE\SYSTEM\CurrentControlSet
* \Services\Eventlog" and get the values "File"; check all directory
* paths for equality; then examine all files which exist in the found
* directory(directories) and collect time and file size information.
*
* 
*  @param pShaArray  SHA256 array to use
*  @param ainp_byteshashed  Number of bytes hashed
*                           (in this function)
*  @return int state 
*  <br>            > 0 o.k., number of examined files
*  <br>            = 0 no files found
*  <br>            < 0 error occurred
*/
int HashEvtDir(HMEM_CTX_DEF int* pShaArray, int * ainp_byteshashed)
{
   int inl1, inl2;
   int inl_entries;
   int inl_byteshashed;
   int inl_path_index;
   DWORD uml_idx;
   DWORD uml_alloclen;
   DWORD uml_regresult;
   DWORD uml_valuesize;
   DWORD uml_valuetype;
   DWORD uml_namebuflen;
   DWORD uml_subkeyscount;
   DWORD uml_maxsubkeylen;
   DWORD uml_maxclasslen;
   DWORD uml_securitydescriptor;
   HKEY dsl_hkey;
   HKEY dsl_subhkey;
   HANDLE dsl_hdl_file;
   FILETIME dsl_ftlastwritetime;
   WIN32_FIND_DATAA dsl_findfiledata;
   char chrl_drive_buf[_MAX_DRIVE + 1];
   char chrl_dir_buf[_MAX_DIR + 1];
   char * achl_regdata;
   char * achl_pathbuff;
   char * achl_subkeyname;
   char ** aachl_ppatharray;
   //
   // initialize variables
   inl_entries = 0;
   inl_byteshashed = 0;
   dsl_hkey = NULL;
   dsl_subhkey = NULL;
   achl_subkeyname = NULL;
   achl_pathbuff = NULL;
   aachl_ppatharray = NULL;
   //-----------------------------------------------------------------------
   // Open main key for subkeys enumeration, get numer of keys,
   // longest size of key, allocate required subkey name buffer
   //-----------------------------------------------------------------------
   uml_regresult = RegOpenKeyExA(HKEY_LOCAL_MACHINE,
                   "SYSTEM\\CurrentControlSet\\Services\\Eventlog",
                   0, KEY_READ, &dsl_hkey);  // open the registry key
   if (uml_regresult != ERROR_SUCCESS)
   {
     SHA256_Update(pShaArray,(char*)(&uml_regresult),0,sizeof(DWORD));
     return(-1);
   }
   //
   //
   uml_regresult = RegQueryInfoKey(dsl_hkey, NULL, NULL, NULL, &uml_subkeyscount,
                                   &uml_maxsubkeylen, &uml_maxclasslen, NULL, NULL, NULL,
                                   &uml_securitydescriptor, &dsl_ftlastwritetime);

   if ((uml_regresult != ERROR_SUCCESS) || (uml_subkeyscount == 0))
   {
     if (uml_regresult != ERROR_SUCCESS)
     { // unspecific registry query error
       SHA256_Update(pShaArray,(char*)(&uml_regresult),0,sizeof(DWORD));
     }
     else
     {
       SHA256_Update(pShaArray,(char*)(&dsl_ftlastwritetime),0,sizeof(FILETIME));
     }
     SHA256_Update(pShaArray,(char*)(&dsl_hkey),0,sizeof(HKEY));
     RegCloseKey(dsl_hkey);
     dsl_hkey = NULL;
     return(-2);
   }
   //
   //
   // Hash last access times
   SHA256_Update(pShaArray,(char*)(&dsl_ftlastwritetime),0,sizeof(FILETIME));
   inl_byteshashed += sizeof(FILETIME);
   //
   //----------------------------------------
   // Allocate buffers
   //----------------------------------------
   aachl_ppatharray = (char**) BIT8_ARRAY_ALLOC(HMEM_CTX_REF, uml_subkeyscount * sizeof (char *));  // alloc path
   memset(aachl_ppatharray, 0, uml_subkeyscount * sizeof (char *));  // set NULLs
   uml_alloclen = ((uml_maxsubkeylen + 4) & (~0x01));
   achl_subkeyname = (char*) BIT8_ARRAY_ALLOC(HMEM_CTX_REF, (uml_alloclen * sizeof(char)));
   //-------------------------------------------------------------
   // Enumerate Subkeys for Main key one by one, extract the paths
   //-------------------------------------------------------------
   uml_idx = 0;
   inl_path_index = 0;
   while (uml_idx < uml_subkeyscount)
   {
     if (dsl_subhkey != NULL)
        RegCloseKey(dsl_subhkey);
     dsl_subhkey = NULL;
     achl_regdata = NULL;
     //-----------------------------------------
     // Get next subkey name, open it
     //-----------------------------------------
     memset(achl_subkeyname, 0, uml_alloclen * sizeof (char));  // set NULLs
     uml_namebuflen = (uml_maxsubkeylen + 1);

     uml_regresult = RegEnumKeyExA(dsl_hkey, uml_idx, achl_subkeyname, &uml_namebuflen,
                                  NULL, NULL, &uml_maxclasslen, &dsl_ftlastwritetime);
     if (uml_regresult != ERROR_SUCCESS)
     {
       SHA256_Update(pShaArray,(char*)(&uml_regresult),0,sizeof(DWORD));
       if (uml_regresult == ERROR_NO_MORE_ITEMS)
       {
         break;
       }
       continue;
     }
     achl_subkeyname[uml_namebuflen] = '\0';  // terminate (NUL might be missing)
     //
     uml_idx++;
     // Hash last access times
     SHA256_Update(pShaArray,(char*)(&dsl_ftlastwritetime),0,sizeof(FILETIME));
     inl_byteshashed += sizeof(FILETIME);
     // open the registry key of the subkey
     uml_regresult = RegOpenKeyExA(dsl_hkey, achl_subkeyname, 0, KEY_READ, &dsl_subhkey);
     if (uml_regresult != ERROR_SUCCESS)
     {
       SHA256_Update(pShaArray,(char*)(&uml_regresult),0,sizeof(DWORD));
       continue;
     }
     //------------------------------------------------
     // Got a new subkey handle, query 'File' Value
     //------------------------------------------------
     uml_valuesize = 0;
     uml_regresult = RegQueryValueExA(dsl_subhkey, "File", NULL, &uml_valuetype, NULL, &uml_valuesize);
     if ((uml_regresult != ERROR_SUCCESS) || ((uml_valuetype != REG_SZ) && (uml_valuetype != REG_EXPAND_SZ)))
     {
       SHA256_Update(pShaArray,(char*)(&uml_regresult),0,sizeof(DWORD));
       SHA256_Update(pShaArray,(char*)(&dsl_subhkey),0,sizeof(HKEY));
       continue;
     }
     //--------------------------------------------------------
     // 'File' value is present, allocate buffer and read value
     //--------------------------------------------------------
     // find the type, size and content of the entry "File"
     achl_regdata = BIT8_ARRAY_ALLOC(HMEM_CTX_REF, ((uml_valuesize + 2) * sizeof(char)));
     if (achl_regdata == NULL)
     {
       SHA256_Update(pShaArray,(char*)(&dsl_subhkey),0,sizeof(HKEY));
       continue;
     }
     uml_regresult = RegQueryValueExA(dsl_subhkey, "File", NULL, &uml_valuetype, ((LPBYTE)achl_regdata), &uml_valuesize);
     if (uml_regresult != ERROR_SUCCESS)
     {
       SHA256_Update(pShaArray,(char*)(&uml_regresult),0,sizeof(DWORD));
       SHA256_Update(pShaArray,(char*)(&dsl_subhkey),0,sizeof(HKEY));
       FREE_ARRAY(HMEM_CTX_REF, achl_regdata);
       continue;
     }
     RegCloseKey(dsl_subhkey);  // no longer needed
     dsl_subhkey = NULL;
     //--------------------------------------------------
     // Expand path if required, strip filename/extension
     //--------------------------------------------------
     if (uml_valuetype == REG_EXPAND_SZ)
     {
       // create the correct string in 'achl_pathbuff' to continue working with that
       achl_pathbuff = BIT8_ARRAY_ALLOC(HMEM_CTX_REF, (MAX_PATH + uml_valuesize + 2));
       uml_regresult = ExpandEnvironmentStringsA(achl_regdata, achl_pathbuff, (MAX_PATH + uml_valuesize));
       FREE_ARRAY(HMEM_CTX_REF, achl_regdata);
       achl_regdata = NULL;
       if ((uml_regresult == 0) || (uml_regresult > (MAX_PATH + uml_valuesize)))
       {
         FREE_ARRAY(HMEM_CTX_REF, achl_pathbuff);
         continue;
       }
       achl_pathbuff[uml_regresult] = '\0';  // terminate (NUL might be missing)
       aachl_ppatharray[inl_path_index] = achl_pathbuff;
     }
     else
     {
       aachl_ppatharray[inl_path_index] = achl_regdata;
     }
     //-------------------------------------------------------
     // Remove File/Extension from path
     //-------------------------------------------------------
     _splitpath(aachl_ppatharray[inl_path_index], chrl_drive_buf, chrl_dir_buf, NULL, NULL);
     _makepath(aachl_ppatharray[inl_path_index], chrl_drive_buf, chrl_dir_buf, "*", "*");
     inl_path_index++;
   } // end of while (uml_idx < uml_subkeyscount)
   //---------------------------------------------
   // Close registry keys
   //---------------------------------------------
   if (dsl_subhkey != NULL)
   {
     RegCloseKey(dsl_subhkey);
     dsl_subhkey = NULL;
   }
   RegCloseKey(dsl_hkey);
   dsl_hkey = NULL;
   if (achl_subkeyname != NULL)
   {
     FREE_ARRAY(HMEM_CTX_REF, achl_subkeyname);
     achl_subkeyname = NULL;
   }
   //----------------------------------------------
   // Remove duplicate paths from Array
   //----------------------------------------------
   for (inl2 = (inl_path_index - 1); inl2 > 0; inl2--)
   {
     for (inl1 = (inl2 - 1); inl1 >= 0; inl1--)
     {
       if ((aachl_ppatharray[inl1] != NULL) && (aachl_ppatharray[inl2] != NULL))
       {
         if (stricmp(aachl_ppatharray[inl2], aachl_ppatharray[inl1]) == 0)  // same path
         {
           FREE_ARRAY(HMEM_CTX_REF, aachl_ppatharray[inl2]);
           aachl_ppatharray[inl2] = NULL;
         }
       }
     }
   }
   //-------------------------------------------------------
   // Enumerate files in directories, hash structures
   //-------------------------------------------------------
   for (inl1 = 0; inl1 < inl_path_index; inl1++)
   {
     if (aachl_ppatharray[inl1] == NULL)
        continue;
     for (inl2 = 0; ; )
     {
       dsl_hdl_file = FindFirstFileA(aachl_ppatharray[inl1], &dsl_findfiledata);
       if (dsl_hdl_file == INVALID_HANDLE_VALUE)
       {
         uml_regresult = GetLastError();
         SHA256_Update(pShaArray,(char*)(&uml_regresult),0,sizeof(DWORD));
         break;
       }
       SHA256_Update(pShaArray,(char*)(&dsl_findfiledata),0,sizeof(dsl_findfiledata));
       inl_byteshashed += sizeof(dsl_findfiledata);
       inl2++;
       //-----------------------------------------
       // Enumerate more files if any
       //-----------------------------------------
       for (;;)
       {
         uml_regresult = FindNextFileA(dsl_hdl_file, &dsl_findfiledata);
         if (uml_regresult != 0)
         {
           SHA256_Update(pShaArray,(char*)(&dsl_findfiledata),0,sizeof(dsl_findfiledata));
           inl_byteshashed += sizeof(dsl_findfiledata);
           inl2++;
           continue;
         }
         uml_regresult = GetLastError();
         if (uml_regresult == ERROR_NO_MORE_FILES)
         {
         }
         else
         {
           SHA256_Update(pShaArray,(char*)(&uml_regresult),0,sizeof(DWORD));
         }
         break;
       }
       if (inl2 > 0)
          inl_entries++;
       FindClose(dsl_hdl_file);
       break;
     }
     FREE_ARRAY(HMEM_CTX_REF, aachl_ppatharray[inl1]);
     aachl_ppatharray[inl1] = NULL;
   } // end of for (inl1 = 0; inl1 < inl_path_index; inl1++)
   //
   FREE_ARRAY(HMEM_CTX_REF, aachl_ppatharray);
   aachl_ppatharray = NULL;
   *ainp_byteshashed = inl_byteshashed;
   return(inl_entries);
}  // end of int HashEvtDir(...)
//
//
/**
* SysGetEntropy - 
* Collect entropy for DRBG seed on Windows systems. 
* This is the core function that collects entropy from the various 
* system API calls. After all entropy gathering functions are 
* processed the results from the entropy sources are tested. 
* <br>
* -- Windows Version --
*
* 
*  @param abyp_pdigest  Output buffer, 32 bytes
*  @param ainp_byteshashed  Number of bytes hashed
*  @return int state 
*  <br>            > 0 reference value for the collected data
*  <br>            <= 0 error condition
*/
int SysGetEntropy(HMEM_CTX_DEF char* abyp_pdigest,
                               int* ainp_byteshashed)
{
#define PERFCOUNTBUFLEN  8
   //
   int inl_retcode;
   int inl_byteshashed;
   int inl_idx;
   int inl_len;
   int inl_totalpercentage;
   long ill_pi_val;
   long ill_longval;
   DWORD uml_val;
   DWORD uml_funresult;
   long long ill_val64;
   float fll_entropest;
   double fdl_val1;
   double fdl_val2;
   SYSTEMTIME dsl_systemtime;
   LARGE_INTEGER dsl_quryperfcnt;
   LARGE_INTEGER dsl_quryperfrqn;
   ULARGE_INTEGER ull_freebytesavail;
   ULARGE_INTEGER ull_totalnmbofbyt;
   ULARGE_INTEGER ull_totalnmboffree;
   LARGE_INTEGER dsrl_wallis_rounds[4];
   LPTCH achl_penv_name;
   char byrl_tmp_buff[18];
   int ShaArray[SHA256_ARRAY_SIZE];
   long long ulrl_perfcountbuf[PERFCOUNTBUFLEN];
   unsigned long long ulrl_tsc_buf[PERFCOUNTBUFLEN];
   MEMORYSTATUS dsl_memorystatus;
   MEMORYSTATUSEX dsl_memorystatusex;
   POINT dsl_point;
   HCRYPTPROV dsl_hcryptprov;
   //
   //-------------------------------------------------------
   // Initialize variables and the SHA-256 hash array
   //-------------------------------------------------------
   inl_byteshashed = 0;
   inl_totalpercentage = 0;
   fll_entropest = 0.0F;
   SHA256_Init(ShaArray);
   memset(((void *)(&(ulrl_perfcountbuf[0]))), 0, (sizeof(long long) * PERFCOUNTBUFLEN));
   ;
   //-------------------------------------------------
   // 1. Collect all the performance counter values 
   //    at the start of the entropy gathering and 
   //    after the end of the processing of each 
   //    specific group of items
   //-------------------------------------------------
   // 1a. Add the performance counter value before 
   //     the start of processing item 2.
   //-------------------------------------------------
   if (QueryPerformanceCounter(&dsl_quryperfcnt) != 0)
   {
     ulrl_perfcountbuf[0] = dsl_quryperfcnt.QuadPart;
     ulrl_tsc_buf[0] = m_get_tsc();
     Sleep(2);  // wait for 2 msec
   }
   //----------------------------------------------------------
   // 2. Get standard function values for Local Time, the 
   //    frequency of the high-resolution performance counter, 
   //    the Thread ID, the Process ID, the current Tick Count, 
   //    and the performance info values
   //----------------------------------------------------------
   GetLocalTime(&dsl_systemtime);  // Time / Date
   SHA256_Update(ShaArray,(char*)(&dsl_systemtime),0,sizeof(SYSTEMTIME));
   inl_byteshashed += sizeof(SYSTEMTIME);
   inl_totalpercentage += 4;
   // Performance Frequency
   if (QueryPerformanceFrequency(&dsl_quryperfrqn) != FALSE)
   {
     SHA256_Update(ShaArray,(char*)(&dsl_quryperfrqn),0,sizeof(LARGE_INTEGER));
     inl_byteshashed += sizeof(LARGE_INTEGER);
   }
   // get Process ID, Thread ID, Tick Count
   uml_funresult = GetCurrentProcessId();  // Process ID
   SHA256_Update(ShaArray,(char*)(&uml_funresult),0,sizeof(DWORD));
   uml_funresult = GetCurrentThreadId();  // Thread ID
   SHA256_Update(ShaArray,(char*)(&uml_funresult),0,sizeof(DWORD));
   uml_funresult = GetTickCount();  // current System Tick Count
   SHA256_Update(ShaArray,(char*)(&uml_funresult),0,sizeof(DWORD));
   inl_byteshashed += (3 * sizeof(DWORD));
   inl_totalpercentage += 10;
   //
   inl_retcode = HashPerfInfo(ShaArray);  // performance info
   if (inl_retcode > 0)
   {
     inl_byteshashed += inl_retcode;
     inl_totalpercentage += 4;
     ;
   }
   //---------------------------------------------------------------
   // 1b. Add the performance counter value after processing item 2.
   //---------------------------------------------------------------
   if (QueryPerformanceCounter(&dsl_quryperfcnt) != 0)
   {
     ulrl_perfcountbuf[1] = dsl_quryperfcnt.QuadPart;
     ulrl_tsc_buf[1] = m_get_tsc();
     Sleep(2);  // wait for 2 msec
   }
   // -----------------------------------------------------------------
   // 3. Get information related to all processes running on the system 
   //    which can be accessed; this is the IO information, the timer 
   //    information and the memory information; furthermore module and 
   //    thread information related to each found process is collected.
   // -----------------------------------------------------------------
   inl_retcode = CollectSnapshots(ShaArray);
   if (inl_retcode > 0)
   {
     inl_byteshashed += inl_retcode;
     inl_totalpercentage += 4;
     ;
   }
   //---------------------------------------------------------------
   // 1c. Add the performance counter value after processing item 3.
   //---------------------------------------------------------------
   if (QueryPerformanceCounter(&dsl_quryperfcnt) != 0)
   {
     ulrl_perfcountbuf[2] = dsl_quryperfcnt.QuadPart;
     ulrl_tsc_buf[2] = m_get_tsc();
     Sleep(2);  // wait for 2 msec
   }
   // ---------------------------------------------------------------
   // 4. Get System Times (corresponds with CPU load, i.e. idle time,
   //    kernel time and user time), do calculation program (Wallis) 
   //    and measure System Times again.
   // ---------------------------------------------------------------
   inl_retcode = HashSysTimes(ShaArray);
   if (inl_retcode > 0)
   {
     inl_byteshashed += inl_retcode;
     inl_totalpercentage += 3;
     ;
   }
   // Wallis product (calculate the number pi with a very lousy routine)
   ill_pi_val = m_calc_pi_wallis(&(dsrl_wallis_rounds[0]));
   // test whether any of the values falls below a certain limit which is a hint for incorrect processing
   for (inl_idx = 0; inl_idx < 4; inl_idx++)
   {
     if ((dsrl_wallis_rounds[inl_idx].QuadPart > 0L) &&
         (dsrl_wallis_rounds[inl_idx].QuadPart < (MIN_PI_ROUNDS / 100)))
     {
       ill_pi_val = 0L;
       break;
     }
   }
   // test the results and determine an estimated entropy value
   if (ill_pi_val > 0L)
   {
     fdl_val2 = 0.0;
     dsl_quryperfcnt.QuadPart = (dsrl_wallis_rounds[0].QuadPart + dsrl_wallis_rounds[1].QuadPart + 
                                 dsrl_wallis_rounds[2].QuadPart + dsrl_wallis_rounds[3].QuadPart);
     if (dsl_quryperfcnt.u.HighPart > 0)
        fdl_val1 = 13.0;
     else
     {
       uml_val = dsl_quryperfcnt.u.LowPart;
       if (uml_val > MIN_PI_ROUNDS)
          fdl_val1 = 13.0;
       else if (uml_val > MIN_PI_ROUNDS * 3 / 4)
          fdl_val1 = 9.75;
       else if (uml_val > MIN_PI_ROUNDS / 2)
          fdl_val1 = 6.5;
       else if (uml_val > MIN_PI_ROUNDS / 4)
          fdl_val1 = 3.25;
       else
          fdl_val1 = 0.0;
     }
     if (dsrl_wallis_rounds[3].QuadPart > 0L)
        uml_val = 4;
     else if (dsrl_wallis_rounds[2].QuadPart > 0L)
        uml_val = 3;
     else if (dsrl_wallis_rounds[1].QuadPart > 0L)
        uml_val = 2;
     else
        uml_val = 1;

     for (inl_idx = 0; inl_idx < 4; inl_idx++)
     {
       if (dsrl_wallis_rounds[inl_idx].QuadPart > (MIN_PI_ROUNDS / (uml_val * 2)))
          fdl_val2 += (double)(fdl_val1 / uml_val);
     }
     //
     // add the return values of Wallis rounds to the hash pool
     if (dsrl_wallis_rounds[0].QuadPart > 0L)
     {
       SHA256_Update(ShaArray,(char*)(&(dsrl_wallis_rounds[0].QuadPart)),0,sizeof(LARGE_INTEGER));
       inl_byteshashed += sizeof(LARGE_INTEGER);
     }
     if (dsrl_wallis_rounds[1].QuadPart > 0L)
     {
       SHA256_Update(ShaArray,(char*)(&(dsrl_wallis_rounds[1].QuadPart)),0,sizeof(LARGE_INTEGER));
       inl_byteshashed += sizeof(LARGE_INTEGER);
     }
     if (dsrl_wallis_rounds[2].QuadPart > 0L)
     {
       SHA256_Update(ShaArray,(char*)(&(dsrl_wallis_rounds[2].QuadPart)),0,sizeof(LARGE_INTEGER));
       inl_byteshashed += sizeof(LARGE_INTEGER);
     }
     if (dsrl_wallis_rounds[3].QuadPart > 0L)
     {
       SHA256_Update(ShaArray,(char*)(&(dsrl_wallis_rounds[3].QuadPart)),0,sizeof(LARGE_INTEGER));
       inl_byteshashed += sizeof(LARGE_INTEGER);
     }
     if ((ill_pi_val >= 3133000L) && (ill_pi_val <= 3150000)){
        // Only add The entropy, if the Wallis Product was successfull and sufficient
         fll_entropest += (float)fdl_val2;
        inl_totalpercentage += (int)fdl_val2;
     }
   } // end of if (ill_pi_val > 0L)
   // clear the returned data
   SecClearByteArray((char*)dsrl_wallis_rounds, (4 * sizeof(LARGE_INTEGER)));
   // get system times again
   inl_retcode = HashSysTimes(ShaArray);
   if (inl_retcode > 0)
   {
     inl_byteshashed += inl_retcode;
     inl_totalpercentage += 3;
     ;
   }
   //---------------------------------------------------------------
   // 1d. Add the performance counter value after processing item 4.
   //---------------------------------------------------------------
   if (QueryPerformanceCounter(&dsl_quryperfcnt) != 0)
   {
     ulrl_perfcountbuf[3] = dsl_quryperfcnt.QuadPart;
     ulrl_tsc_buf[3] = m_get_tsc();
     Sleep(2);  // wait for 2 msec
   }
   // -------------------------------------------------------------------------
   // 5. Get DiskFreeSpace and GlobalMemoryStatus, get caret, message and 
   //    cursor positions, get message time, get environment strings.
   // -------------------------------------------------------------------------
   // The GetDiskFreeSpaceEx function retrieves information about the amount of space that is available
   // on a disk volume, which is the total amount of space, the total amount of free space, and the 
   // total amount of free space available to the user that is associated with the calling thread.
   if (GetDiskFreeSpaceEx(NULL, &ull_freebytesavail, &ull_totalnmbofbyt, &ull_totalnmboffree) != FALSE)
   {
     SHA256_Update(ShaArray,(char*)(&ull_freebytesavail),0,sizeof(LARGE_INTEGER));
     SHA256_Update(ShaArray,(char*)(&ull_totalnmbofbyt),0,sizeof(LARGE_INTEGER));
     SHA256_Update(ShaArray,(char*)(&ull_totalnmboffree),0,sizeof(LARGE_INTEGER));
     inl_byteshashed += (3 * sizeof(LARGE_INTEGER));
     inl_totalpercentage += 4;
     ;
   }
   // Retrieve information about the system's current usage of both physical and virtual memory
   dsl_memorystatusex.dwLength = sizeof (MEMORYSTATUSEX);
   if (GlobalMemoryStatusEx(&dsl_memorystatusex) == FALSE)
   {
     uml_funresult = GetLastError();
     SHA256_Update(ShaArray,(char*)(&uml_funresult),0,sizeof(DWORD));
     inl_byteshashed += sizeof(DWORD);
     GlobalMemoryStatus(&dsl_memorystatus);
     SHA256_Update(ShaArray,(char*)(&dsl_memorystatus),0,sizeof(MEMORYSTATUS));
     inl_byteshashed += sizeof(MEMORYSTATUS);
     inl_totalpercentage += 2;
   }
   else
   {
     SHA256_Update(ShaArray,(char*)(&dsl_memorystatusex),0,sizeof(MEMORYSTATUSEX));
     inl_byteshashed += sizeof(MEMORYSTATUSEX);
     inl_totalpercentage += 4;
     ;
   }
   // Get caret position, message position and cursor position;
   // this doesn't give any benefit on server systems (without a user), but the 
   // system calls are helpful for taking processor time used for the function calls.
   if (GetCaretPos(&dsl_point) != 0)  // the caret's position in client coordinates
   {
     SHA256_Update(ShaArray,(char*)(&dsl_point),0,sizeof(POINT));
     inl_byteshashed += sizeof(POINT);
     inl_totalpercentage += 2;
     ;
   }
   //
   uml_funresult = GetMessagePos();  // the cursor position for the last message
   SHA256_Update(ShaArray,(char*)(&uml_funresult),0,sizeof(DWORD));
   inl_byteshashed += sizeof(DWORD);
   inl_totalpercentage += 2;
   //
   if (GetCursorPos(&dsl_point) != 0)  // the cursor's position in screen coordinates
   {
     SHA256_Update(ShaArray,(char*)(&dsl_point),0,sizeof(POINT));
     inl_byteshashed += sizeof(POINT);
     inl_totalpercentage += 2;
     ;
   }
   // The GetMessageTime function retrieves the message time for the last message 
   // retrieved by the GetMessage function. The time is a long integer that specifies 
   // the elapsed time, in milliseconds, from the time the system was started to the 
   // time the message was created (that is, placed in the thread's message queue). 
   ill_longval = GetMessageTime();
   SHA256_Update(ShaArray,(char*)(&ill_longval),0,sizeof(long));
   inl_byteshashed += sizeof(long);
   inl_totalpercentage += 2;
   // Hash environment settings (strings)
   achl_penv_name = GetEnvironmentStrings();
   if (achl_penv_name != NULL)
   {
     inl_idx = 0;
     for ( ; ; )
     {
       inl_len = (int)_tcslen(achl_penv_name + inl_idx);
       if (inl_len <= 0)
          break;
       SHA256_Update(ShaArray, (const char *)achl_penv_name, inl_idx, (inl_len * sizeof(*achl_penv_name)));
       inl_byteshashed += (inl_len * sizeof(*achl_penv_name));
       inl_idx += (inl_len + 1);
     }
     FreeEnvironmentStrings(achl_penv_name);
     inl_totalpercentage += 4;
     ;
   }
   //---------------------------------------------------------------
   // 1e. Add the performance counter value after processing item 5.
   //---------------------------------------------------------------
   if (QueryPerformanceCounter(&dsl_quryperfcnt) != 0)
   {
     ulrl_perfcountbuf[4] = dsl_quryperfcnt.QuadPart;
     Sleep(2);  // wait for 2 msec
   }
   //-----------------------------------------------------
   // 6. Get Event and Logging file information
   //-----------------------------------------------------
   inl_retcode = HashEvtDir(HMEM_CTX_REF1 ShaArray, &inl_len);
   if (inl_retcode > 0)
   {
     inl_byteshashed += inl_len;
     inl_totalpercentage += 8;
   }
   //---------------------------------------------------------------
   // 1f. Add the performance counter value after processing item 6.
   //---------------------------------------------------------------
   if (QueryPerformanceCounter(&dsl_quryperfcnt) != 0)
   {
     ulrl_perfcountbuf[5] = dsl_quryperfcnt.QuadPart;
     ulrl_tsc_buf[5] = m_get_tsc();
     Sleep(2);  // wait for 2 msec
   }
   //-------------------------------------------------------
   // 7. Get random from CRYPTO-API, fetch 2 times 16 bytes
   //-------------------------------------------------------
   // get bytes from the Crypto API
   dsl_hcryptprov = NULL;
   // acquire a CSP context, use the default key container name and the user default provider 
   if (CryptAcquireContext(&dsl_hcryptprov, NULL, NULL, PROV_RSA_FULL, CRYPT_VERIFYCONTEXT) == FALSE)
   {
     // an error occurred in acquiring the context. This could mean that the key container 
     // requested does not exist. In this case, the function can be called again to attempt 
     // to create a new key container. Error codes are defined in Winerror.h.
     uml_funresult = GetLastError();
     SHA256_Update(ShaArray,(char*)(&uml_funresult),0,sizeof(DWORD));
     inl_byteshashed += sizeof(DWORD);
     if (uml_funresult == NTE_BAD_KEYSET)
     {
       if (CryptAcquireContextA(&dsl_hcryptprov, "MyKeyContainer", NULL, PROV_RSA_FULL, CRYPT_NEWKEYSET) == FALSE)
       {
         uml_funresult = GetLastError();
         SHA256_Update(ShaArray,(char*)(&uml_funresult),0,sizeof(DWORD));
         inl_byteshashed += sizeof(DWORD);
         if (uml_funresult == NTE_EXISTS)
         {
           if (CryptAcquireContextA(&dsl_hcryptprov, "MyKeyContainer", NULL, PROV_RSA_FULL, 0) == FALSE)
           {
             uml_funresult = GetLastError();
             SHA256_Update(ShaArray,(char*)(&uml_funresult),0,sizeof(DWORD));
             inl_byteshashed += sizeof(DWORD);
             dsl_hcryptprov = NULL;
           }
         }
         else
            dsl_hcryptprov = NULL;
       }
     }
     else
        dsl_hcryptprov = NULL;
   }
   // fetch random bytes
   if (dsl_hcryptprov != NULL)
   {
     for (inl_idx = 0, uml_val = 16; inl_idx < 2; inl_idx++)
     {
       memset(((void *)(&(byrl_tmp_buff[0]))), 0, ((uml_val + 2) * sizeof(unsigned char)));
       if (CryptGenRandom(dsl_hcryptprov, uml_val, ((unsigned char *)byrl_tmp_buff)) == FALSE)
       {
         uml_funresult = GetLastError();
         SHA256_Update(ShaArray,(char*)(&uml_funresult),0,sizeof(DWORD));
         inl_byteshashed += sizeof(DWORD);
       }
       else
       {
         SHA256_Update(ShaArray,byrl_tmp_buff,0,uml_val);
         inl_byteshashed += (int)uml_val;
         inl_totalpercentage += 8;
         fll_entropest += 10.0F;  // it is assumed that the CryptoAPI returns 20 bit entropy in total
         ;
       }
     }
     // when the CSP handle is no longer needed, it must be released
     if (CryptReleaseContext(dsl_hcryptprov, 0) == FALSE)
     {
       uml_funresult = GetLastError();
       SHA256_Update(ShaArray,(char*)(&uml_funresult),0,sizeof(DWORD));
       inl_byteshashed += sizeof(DWORD);
     }
     else
     {
       dsl_hcryptprov = NULL;
     }
   } // end of if (dsl_hcryptprov != NULL)
   //---------------------------------------------------------------
   // 1g. Add the performance counter value after processing item 7.
   //---------------------------------------------------------------
   if (QueryPerformanceCounter(&dsl_quryperfcnt) != 0)
   {
     ulrl_perfcountbuf[6] = dsl_quryperfcnt.QuadPart;
     ulrl_tsc_buf[6] = m_get_tsc();
     Sleep(2);  // wait for 2 msec
   }
   //-------------------------------------------------------
   // 8. Hash network tables and statistics
   //-------------------------------------------------------
   // get network information which results from functions in "iphlpapi.dll"
   inl_retcode = GetNetHashes(HMEM_CTX_REF1 ShaArray);
   if (inl_retcode > 0)
   {
     inl_byteshashed += inl_retcode;
     inl_totalpercentage += 10;
     ;
   }
   //---------------------------------------------------------------
   // 1h. Add the performance counter value after processing item 8.
   //---------------------------------------------------------------
   if (QueryPerformanceCounter(&dsl_quryperfcnt) != 0)
   {
     ulrl_perfcountbuf[7] = dsl_quryperfcnt.QuadPart;
     ulrl_tsc_buf[7] = m_get_tsc();
   }
   ;
   //----------------------------------------------------------------
   // Hash the performance counter values and test the collected data
   //----------------------------------------------------------------
   SHA256_Update(ShaArray,(char*)(&(ulrl_perfcountbuf[0])),0,(sizeof(long long) * PERFCOUNTBUFLEN));
   SHA256_Update(ShaArray,(char*)(&(ulrl_tsc_buf[0])),0,(sizeof(long long) * PERFCOUNTBUFLEN));
   inl_byteshashed += (sizeof(long long) * PERFCOUNTBUFLEN);

   // check the performance counter values
   for (inl_idx = 0, uml_val = 0; inl_idx < (PERFCOUNTBUFLEN - 1); inl_idx++)
   {
     ill_val64 = (ulrl_perfcountbuf[inl_idx + 1] - ulrl_perfcountbuf[inl_idx]);
     if (ill_val64 > 1234L)
     {
       uml_val++;
       inl_totalpercentage += 3;
       fll_entropest += 3.2F;  // it is assumed that every OS-API-time adds 3.2 bit entropy
     }
   }
   if (((unsigned long long)ulrl_perfcountbuf[0]) > 0xFFFFL)
   {
     uml_val++;
     fll_entropest += 3.2F;  // it is assumed that every OS-API-time adds 3.2 bit entropy
   }

   //----------------------------------------------------------------
   // Add entropy from random CAS
   //----------------------------------------------------------------
   ms_add_cas_random(ShaArray, inl_byteshashed, inl_totalpercentage, fll_entropest);

   m_entropy_out(fll_entropest);
   // test the qualified entropy sources
   inl_retcode = inl_totalpercentage;
   if (fll_entropest < 32.0F){  // Windows OS is not CC evaluated !
      inl_retcode = DRBG_SEC_HASH_WEAK;
   }

   m_sec_zero_mem(ulrl_perfcountbuf, (PERFCOUNTBUFLEN*sizeof(long long)));
   m_sec_zero_mem(ulrl_tsc_buf, (PERFCOUNTBUFLEN*sizeof(long long)));
   //----------------------------------------------------------
   // Create the final hash value and return all necessary data
   //----------------------------------------------------------
   SHA256_Final(ShaArray,abyp_pdigest,0);
   ainp_byteshashed[0] = inl_byteshashed;
   return(inl_retcode);
}  // end of int SysGetEntropy(...)
//
//
#else // WIN32 || WIN64  =  NON-Windows, UNIX systems

//===========================================
// UNIX/Linux only: entropy gathering functions
//===========================================

/**
* m_get_high_resolutime - 
* Get the high resolution timer on Linux and UNIX systems. <br>
* -- Linux and UNIX Version --
*
* <br>
* maybe the following precompiler statement must be implemented: 
* #if defined __timespec_defined
*
* Used structures: <br>
*   struct timespec
*   {
*     __time_t tv_sec;   * Seconds
*     long int tv_nsec;  * Nanoseconds
*   }; <br>
*   struct timeval
*   {
*     time_t      tv_sec;  * seconds
*     suseconds_t tv_usec;  * microseconds
*   };
*
* 
*  @param ailp_perf_retval
*               pointer to a 64 bit return value
*  @return int state 
*  <br>            >= 0 time value ok
*  <br>            < 0 error condition
*/
static int m_get_high_resolutime(long long* ailp_perf_retval)
{
   unsigned int     uml_testval1;
   unsigned int     uml_testval2;
   int              iml_func_out;
   long long            ill_hgh_res_time;
#if !defined HL_MACOS
   struct timespec  dsl_timespec_qperf;
#else
   mach_timebase_info_data_t  dsl_info;
   uint64_t  ull_time;
   uint64_t  ull_nano;
#endif // HL_MACOS
#if !defined HL_LINUX || defined HL_MACOS
   struct timeval   dsl_timeval_qperf;
#endif // !HL_LINUX || HL_MACOS
   //
#if !defined HL_MACOS
   // get the high precision clock 'clock_gettime' with nano seconds resolution;
   // clock type = CLOCK_REALTIME, other values = CLOCK_MONOTONIC, CLOCK_PROCESS_CPUTIME_ID or CLOCK_THREAD_CPUTIME_ID
   if (clock_gettime(CLOCK_REALTIME, &dsl_timespec_qperf) == 0)
   {
     uml_testval1 = dsl_timespec_qperf.tv_sec;
     uml_testval2 = dsl_timespec_qperf.tv_nsec;
     iml_func_out = 0;  // everything is ok
   }
   else
   {
     uml_testval1 = errno;
     uml_testval2 = (unsigned int)time(NULL);  // Time / Date
     iml_func_out = -2;  // error - 'clock_gettime' could not be processed
   }
#else // HL_MACOS
   // get the high precision time 'mach_timebase_info'/'mach_absolute_time' with nano seconds resolution;
   if (mach_timebase_info(&dsl_info) != KERN_SUCCESS)
   {
     uml_testval1 = (unsigned int)mach_timebase_info(&dsl_info);
     uml_testval2 = (unsigned int)time(NULL);  // Time / Date
     iml_func_out = -2;  // error - 'clock_gettime' could not be processed
   }
   else
   {
     if ((dsl_info.numer == 0) || (dsl_info.denom == 0))
     {
       uml_testval1 = errno;
       uml_testval2 = (unsigned int)time(NULL);  // Time / Date
       iml_func_out = -2;  // error - 'clock_gettime' could be processed
     }
     else
     {
       ull_time = mach_absolute_time();
       ull_nano = ((ull_time * dsl_info.numer) / dsl_info.denom);
       ull_time = (ull_nano / 1000000000L);
       uml_testval1 = ((unsigned int)(ull_time & 0xFFFFFFFFL));
       uml_testval2 = ((unsigned int)((ull_nano - (ull_time * 1000000000L)) & 0xFFFFFFFFL));
       iml_func_out = 0;  // everything is ok
     }
   }
#endif // HL_MACOS
   //
#if !defined HL_LINUX || defined HL_MACOS
   if (iml_func_out < 0)
   {
     // use alternative function that is common on nearly all systems
     if (gettimeofday(&dsl_timeval_qperf, NULL) == 0)
     {
       uml_testval1 = dsl_timeval_qperf.tv_sec;
       uml_testval2 = (dsl_timeval_qperf.tv_usec * 1000);
       iml_func_out = 1;  // alternative function 'gettimeofday' is used
     }
     else
     {
       uml_testval1 = errno;
       uml_testval2 = (unsigned int)time(NULL);  // Time / Date
       iml_func_out = -3;  // error - neither 'clock_gettime' nor 'gettimeofday' could be processed
     }
   }
#endif // !HL_LINUX || HL_MACOS
   //
   if (ailp_perf_retval != NULL)
   {
   	 ill_hgh_res_time = ((((long long)uml_testval1) & 0xFFFFFFFFL) * 1000000000L);
   	 ill_hgh_res_time += (((long long)uml_testval2) & 0xFFFFFFFFL);
   	 *ailp_perf_retval = ill_hgh_res_time;
   }
   else
      iml_func_out = -1;  // function was processed, but no return parameter available
   //
   return(iml_func_out);
}  // end of static int m_get_high_resolutime(...)
//
//
/**
* m_get_perform_info - 
* Get multiple system values on Linux and UNIX systems. <br>
* -- Linux and UNIX Version --
*
* 
*  @param aumlp_perf_retval
*               pointer to a system_info_t return structure
*  @return int state
*  <br>            > 0 time value ok
*  <br>            <= 0 error condition
*/
static int m_get_perform_info(system_info_t * ads_info)
{
   int iml_retval;
#if defined HL_LINUX && !defined HL_MACOS
   unsigned int uml_funresult = 0;
   struct sysinfo dsl_sysinfo;
#endif  // HL_LINUX
   //
   // check passed parameter
   if (ads_info == NULL)
      return(-1);  // no info-struct provided
   // preset variables
   iml_retval = 0;
   memset(ads_info, 0, sizeof(system_info_t));
   //
#if defined HL_LINUX && !defined HL_MACOS
   // sysinfo returns information on overall system statistics
   if (sysinfo(&dsl_sysinfo) == -1)
   {
     memset(&dsl_sysinfo, 0, sizeof dsl_sysinfo);
     uml_funresult = errno;
   }
   else
      iml_retval++;
   //
   ads_info->um_process_count = dsl_sysinfo.procs;  // number of current processes
   ads_info->um_total_ram = dsl_sysinfo.totalram;  // total usable main memory size
   ads_info->um_free_ram = dsl_sysinfo.freeram;  // available memory size
   ads_info->um_shared_ram = dsl_sysinfo.sharedram;  // amount of shared memory
   ads_info->um_buffer_ram = dsl_sysinfo.bufferram;  // memory used by buffers
   ads_info->um_total_swap = dsl_sysinfo.totalswap;  // total swap space size
   ads_info->um_free_swap = dsl_sysinfo.freeswap;  // swap space still available
   ads_info->um_total_high = dsl_sysinfo.totalhigh;  // total high memory size
   ads_info->um_free_high = dsl_sysinfo.freehigh;  // available high memory size
#endif  // HL_LINUX && !HL_MACOS
   //
#if !defined HL_LINUX
   ads_info->um_process_count = sysconf(_SC_CHILD_MAX);  // specifies the number of simultaneous processes per real user ID
   ads_info->um_total_ram = sysconf(_SC_ARG_MAX);  // specifies the maximum byte length of the arguments for one of the exec functions, including environment data
   ads_info->um_shared_ram = sysconf(_SC_NGROUPS_MAX);  // specifies the maximum number of simultaneous supplementary group IDs per process
   ads_info->um_total_swap = sysconf(_SC_OPEN_MAX);  // specifies the maximum number of files that one process can have open at any one time
   ads_info->um_buffer_ram = sysconf(_SC_LINE_MAX);  // specifies the maximum byte length of a command's input line (either standard input or another file) when a command is described as processing text files
   ads_info->um_free_ram = sysconf(_SC_AIO_LISTIO_MAX);  // maximum number of Input and Output operations that can be specified in a list Input and Output call
   ads_info->um_free_swap = sysconf(_SC_TTY_NAME_MAX);  // maximum length of a terminal device name
   ads_info->um_total_high = sysconf(_SC_SIGQUEUE_MAX);  // maximum number of signals a process may send and have pending at any time
   ads_info->um_free_high = sysconf(_SC_THREAD_THREADS_MAX);  // maximum number of threads within a process
   iml_retval++;
#endif  // !HL_LINUX
   //
#if defined HL_MACOS
   ads_info->um_process_count = sysconf(_SC_CHILD_MAX);  // specifies the number of simultaneous processes per real user ID
   ads_info->um_total_ram = sysconf(_SC_ARG_MAX);  // specifies the maximum byte length of the arguments for one of the exec functions, including environment data
   ads_info->um_shared_ram = sysconf(_SC_NGROUPS_MAX);  // specifies the maximum number of simultaneous supplementary group IDs per process
   ads_info->um_total_swap = sysconf(_SC_OPEN_MAX);  // specifies the maximum number of files that one process can have open at any one time
   ads_info->um_buffer_ram = sysconf(_SC_LINE_MAX);  // specifies the maximum byte length of a command's input line (either standard input or another file) when a command is described as processing text files
   iml_retval++;
#endif  // HL_MACOS
   //
#if !defined HL_MACOS
#if !defined HL_HPUX
   ads_info->um_phys_total = sysconf(_SC_PHYS_PAGES);  // total number of pages of physical memory in system
#if !defined HL_FREEBSD
   ads_info->um_phys_avail = sysconf(_SC_AVPHYS_PAGES);  // number of physical memory pages not currently in use by system
#else
   ads_info->um_phys_avail = sysconf(_SC_EXPR_NEST_MAX);  // maximum number of expressions that can be nested within parenthesis by the expr(1) utility
#endif  // HL_FREEBSD
   //
   ads_info->um_pagesize = sysconf(_SC_PAGESIZE);  // size in bytes of a page
   ads_info->um_num_cpus = sysconf(_SC_NPROCESSORS_CONF);  // number of processors configured
   ads_info->um_num_cpus_avail = sysconf(_SC_NPROCESSORS_ONLN);  // number of processors online
   iml_retval++;
#else
   ads_info->um_phys_total = sysconf(_SC_EXPR_NEST_MAX);  //  maximum parenthesis nesting level for expr expressions
   ads_info->um_phys_avail = sysconf(_SC_LOGIN_NAME_MAX);  // maximum size of the login name
   ads_info->um_pagesize = sysconf(_SC_MQ_OPEN_MAX);  // maximum number of perprocess open message queue descriptors
   ads_info->um_num_cpus = sysconf(_SC_THREAD_KEYS_MAX);  // number of pthread data keys per process
   iml_retval++;
#endif  // !HL_HPUX
#else
   ads_info->um_phys_total = sysconf(_SC_STREAM_MAX);  // minimum maximum number of streams that a process may have open at any one time
   ads_info->um_phys_avail = sysconf(_SC_EXPR_NEST_MAX);  // maximum number of expressions that can be nested within parenthesis by the expr(1) utility
   ads_info->um_num_cpus = sysconf(_SC_NPROCESSORS_CONF);  // number of processors configured
   ads_info->um_num_cpus_avail = sysconf(_SC_NPROCESSORS_ONLN);  // number of processors online
   ads_info->um_total_high = sysconf(_SC_CLK_TCK);  //  frequency of the statistics clock in ticks per second
   iml_retval++;
#endif  // !HL_MACOS
   //
   return(iml_retval);
}  // end of m_get_perform_info(...)
//
//
/**
* m_execute_command - 
* Execute an external command, collect its output data. <br>
* -- Linux and UNIX Version --
*
* 
*  @param achp_exec_cmd  command to be processed
*                        including all parameters
*  @param achp_delimit  string delimiter for separation
*  @param imp_exp_exitcode  expected exit code
*  @param aump_pids  return array for ProcIDs or NULL
*  @param ump_array_len  length of return array
*  @param pShaArray  SHA256 array to use
*  @param aim_hashedbycount  hashed bytes count pointer
*  @return int state 
*  <br>            >= 0 o.k., number of bytes collected
*  <br>            < 0 error condition
*/
static int m_execute_command(const char * achp_exec_cmd, const char * achp_delimit,
                             int imp_exp_exitcode,
                             unsigned int * aump_pids, unsigned int ump_array_len,
                             int* pShaArray, int * aim_hashedbycount)
{
 #define UNIX_WAIT_DELAY    2
 #define CHAR_OUTPUT_ARRAY_LENGTH    1024
   //
   int iml_retcode;
   int imrl_pipearr[2];
   int iml_devnull_id;
   int iml_len;
   int iml_argc;
   int iml_idx;
   int iml_numbytes;
   int iml_bytescount;
   unsigned int uml_idx;
   unsigned int uml_funresult;
   pid_t dsl_child_procid;
   char * achl_tmp;
   char * achl_cmd;
   char * achl_ep;
   char ** aachl_argv;
   fd_set dsl_readfd_set;
   struct timeval dsl_tv_wait;
   unsigned char ucrl_buf[CHAR_OUTPUT_ARRAY_LENGTH + 4];
//
#if defined XH_INTERFACE
   ds__hmem * vp__ctx = m_get_mem_context();
#endif
   //
   // test passed parameters
   // ----------------------
   if ((achp_exec_cmd == NULL) || (achp_delimit == NULL))
      return(-1);
   if ((aump_pids == NULL) && (ump_array_len > 0))
      return(-2);

   // initialize variables
   errno = 0;
   iml_retcode = 0;
   uml_funresult = 0;
   iml_devnull_id = -1;
   //
   // prepare Stdin/Stdout/StdErr for use with child
   // -----------------------------------------------

   // open "/dev/null" for use as Stdin for child
   if ((iml_devnull_id = open("/dev/null",O_RDWR)) == -1)
   {
     ;
     return(DRBG_EXEC_NULLDEV_OPEN_FAIL);
   }

   // create the Pipe for intercommunication
   iml_retcode = pipe(imrl_pipearr);
   if (iml_retcode != 0)
   {
     uml_funresult = errno;
     close(iml_devnull_id);
     return(DRBG_EXEC_GET_PIPE_FAIL);
   }
   ;

   // fork the child process now
   dsl_child_procid = fork();
   if (dsl_child_procid < 0)
   {
     uml_funresult = errno;
     close(imrl_pipearr[0]);
     close(imrl_pipearr[1]);
     close(iml_devnull_id);

     return(DRBG_EXEC_FORK_FAIL);
   }

   if (dsl_child_procid == 0)
   { // child process continues here
     achl_tmp = NULL;
     aachl_argv = NULL;

     // duplicate handles
     ;
     dup2(iml_devnull_id, STDIN_FILENO);
     // dup2(imrl_pipearr[0], STDIN_FILENO);
     dup2(imrl_pipearr[1],STDOUT_FILENO);
     // NOTE: Comment out the following line for output from child on STDERR !!!
     dup2(iml_devnull_id, STDERR_FILENO);

     close(imrl_pipearr[0]);
     close(imrl_pipearr[1]);
     close(iml_devnull_id);

     // examine and prepare the parameter passing variables
     iml_len = strlen(achp_exec_cmd);
     achl_cmd = (char *)BIT8_ARRAY_ALLOC(HMEM_CTX_REF, ((iml_len + 2) * sizeof(char)));
     if (achl_cmd == NULL)
     {
       uml_funresult = errno;
       if (aachl_argv != NULL)
       {
         FREE_ARRAY(HMEM_CTX_REF, aachl_argv);
         aachl_argv = NULL;
       }
       return(-3);
     }
     memset(achl_cmd, 0, (iml_len + 2) * sizeof(char));
     strncpy(achl_cmd, achp_exec_cmd, iml_len);

     iml_argc = 0;
     achl_tmp = achl_cmd;
     while ((achl_tmp = strtok(achl_tmp, achp_delimit)) != NULL)
     {
       iml_len = strlen(achl_tmp) + 1;
       achl_tmp += iml_len;
       iml_argc++;
     }

     aachl_argv = (char **)BIT8_ARRAY_ALLOC(HMEM_CTX_REF, ((iml_argc + 2) * sizeof(char *)));
     if (aachl_argv == NULL)
     {
       uml_funresult = errno;
       if (achl_cmd != NULL)
       {
         FREE_ARRAY(HMEM_CTX_REF, achl_cmd);
         achl_cmd = NULL;
       }
       return(-3);
     }
     memset(aachl_argv, 0, ((iml_argc + 1) * sizeof(char *)));

     for (iml_idx = 0, achl_tmp = achl_cmd; iml_idx < iml_argc; iml_idx++)
     {
       aachl_argv[iml_idx] = achl_tmp;
       iml_len = strlen(achl_tmp);
       achl_tmp += (iml_len + 1);
     }

     // execute the passed command
     iml_retcode = execvp(achl_cmd, aachl_argv);
     if (iml_retcode < 0)
     {
       uml_funresult = errno;
     }

     FREE_ARRAY(HMEM_CTX_REF, aachl_argv);
     aachl_argv = NULL;
     FREE_ARRAY(HMEM_CTX_REF, achl_cmd);
     achl_cmd = NULL;
     exit(iml_retcode);
   }

   // parent continues here...
   close(imrl_pipearr[1]);
   iml_bytescount = 0;
   uml_idx = 0;

   for( ; ; )
   {
     // wait for data received on STDIN, EOF
     dsl_tv_wait.tv_sec  = UNIX_WAIT_DELAY;  // UNIX_WAIT_DELAY secs timeout
     dsl_tv_wait.tv_usec = 0;

     FD_ZERO(&dsl_readfd_set);
     FD_SET(imrl_pipearr[0], &dsl_readfd_set);

//     DBG_PRINT("m_execute_command: before select.\n");
     iml_retcode = select((imrl_pipearr[0] + 1), &dsl_readfd_set, NULL, NULL, &dsl_tv_wait);
//     printf("m_execute_command: past select, retcode = %d.\n", iml_retcode);

     iml_numbytes = 0;

     switch (iml_retcode)
     {
       case 0:  // timed out
//             DBG_PRINT("m_execute_command: child input timed out, aborting !\n");
             iml_retcode = DRBG_EXEC_CHILD_INP_TIMEOUT;
             break;
       case 1:  // data available
             iml_retcode = 0;
             for( ; ; )
             {
               memset(ucrl_buf, 0, sizeof(ucrl_buf));
               iml_numbytes = read(imrl_pipearr[0], ucrl_buf, CHAR_OUTPUT_ARRAY_LENGTH);
               if (iml_numbytes == -1)
               {
                 if (errno == EINTR)
                    continue;
                 uml_funresult = errno;
                 iml_retcode = DRBG_EXEC_STDIN_READ_ERR;
                 break;
               }
               else if (iml_numbytes == 0)
               {
                 ;
                 iml_retcode = 0;
                 break;
               }

               // fill output
               if (aump_pids != NULL)
               {
                 achl_tmp = (char*)ucrl_buf;
                 while ((uml_idx < ump_array_len) && (achl_tmp < (char *)(&ucrl_buf[CHAR_OUTPUT_ARRAY_LENGTH])))
                 {
                   achl_tmp = strtok(achl_tmp, achp_delimit);
                   if (achl_tmp == NULL)
                      break;
                   aump_pids[uml_idx] = strtoul(achl_tmp, &achl_ep, 10);
                   iml_len = strlen(achl_tmp);
//                   iml_bytescount += iml_len;
                   iml_len++;
                   achl_tmp += iml_len;
                   uml_idx++;
                 }                    
               }
               else if (pShaArray != NULL)
               {
                 SHA256_Update(pShaArray,(char*)ucrl_buf,0,(iml_numbytes * sizeof(unsigned char)));
                 iml_bytescount += iml_numbytes;
                 if (aim_hashedbycount != NULL)
                    *aim_hashedbycount += iml_numbytes;
               }
               iml_retcode = 1;
             } // end of for( ; ; )
             break;
       default:
             if (iml_retcode < 0)
             {
               uml_funresult = errno;
             }
             iml_retcode = DRBG_EXEC_SELECT_ERR;
             break;
     } // end of switch (iml_retcode)

     if (iml_retcode <= 0)
        break;
   } // end of for( ; ; )

   if (iml_retcode < 0)
   {
     close(imrl_pipearr[0]);
     close(iml_devnull_id);
     kill(dsl_child_procid, SIGTERM);
     waitpid(dsl_child_procid, NULL, 0);
     return(iml_retcode);
   }

   // trying a "do ... while" loop for the 'waitpid' function as suggested in the 'waitpid' manual
   do
   {
     iml_retcode = waitpid(dsl_child_procid, &iml_idx, 0);  // iml_idx = child status
     if (iml_retcode != dsl_child_procid)
     {
       close(imrl_pipearr[0]);
       close(iml_devnull_id);
       uml_funresult = errno;
       return(DRBG_EXEC_WRONG_CHILD_PID);
     }
   }
   while ((WIFEXITED(iml_idx) == 0) && (WIFSIGNALED(iml_idx) == 0));

   close(imrl_pipearr[0]);
   close(iml_devnull_id);

   // process status from child termination if available
   if (WIFEXITED(iml_idx) != 0)  // iml_idx = child status
   { // child terminated normally
     iml_retcode = WEXITSTATUS(iml_idx);  // get child's exit status
     if (iml_retcode == imp_exp_exitcode)  // is as expected
     {
       return(iml_bytescount);
     }
     else
     {
       return(0);  // no data added...
     }
   }
   else
   {
     ;
     return(DRBG_EXEC_CHILD_ABNORMAL_TERMINATE);
   }
//
 #undef UNIX_WAIT_DELAY
 #undef CHAR_OUTPUT_ARRAY_LENGTH
}  // end of static int m_execute_command(...)
//
//
#if defined HL_LINUX
/**
* m_get_proc_io_mem - 
* Read from a fixed path, either "/io" or "/statm". <br>
* -- Linux only Version --
*
* 
*  @param achp_dir_path path to process
*  @param adsp_info structure to be filled
*  @param adsp_mem structure to be filled
*/
static void m_get_proc_io_mem(const char * achp_dir_path,
                              proc_io_t * adsp_info, proc_mem_t * adsp_mem)
{
 #define BUFSIZE (8*1024)
   FILE * adsl_fp;
   char chrl_tmp_buff[BUFSIZE];
   unsigned long uml_value;
   unsigned int uml_size;
   unsigned int uml_len;
   char * achl_tmp;
   unsigned int uml_idx;
   unsigned int uml_funresult;
   char * achl_ep;
   char chrl_delim[] = { 0x20, 0x09, 0xa, 0 };
   unsigned int * auml_struct;
   char * achl_path;
   const char * achl_destinat;
   const char * achl_path_io = "/io";
   const char * achl_path_mem = "/statm";
//
#if defined XH_INTERFACE
   ds__hmem * vp__ctx = m_get_mem_context();
#endif

   // test passed parameters
   if ((achp_dir_path == NULL) || ((adsp_info == NULL) && (adsp_mem == NULL)))
   {
     ;
      return;
   }
   if ((adsp_info != NULL) && (adsp_mem != NULL))
   {
     ;
     return;
   }

   // initialize variables
   adsl_fp = NULL;
   achl_path = NULL;
   achl_destinat = NULL;
   uml_idx = 0;
   uml_size = 0;
   uml_funresult = 0;

   // test passed filename
   if (adsp_info != NULL)
      achl_destinat = achl_path_io;
   if (adsp_mem != NULL)
      achl_destinat = achl_path_mem;
   uml_len = ((strlen(achp_dir_path) + strlen(achl_destinat) + 7) & (~0x03));
   if (uml_len >= INT_PATH_FILENAME_LIMIT)
      return;
   achl_path = (char *)BIT8_ARRAY_ALLOC(HMEM_CTX_REF, (uml_len * sizeof(char)));
   if (achl_path == NULL)
   {
     uml_funresult = errno;
     return;
   }

   memset(achl_path, 0, uml_len);
   strncpy(achl_path, achp_dir_path, strlen(achp_dir_path));
   strcat(achl_path, achl_destinat);

   adsl_fp = fopen(achl_path, "r");
   if (adsl_fp == NULL)
   { // permission denied
     uml_funresult = errno;
     FREE_ARRAY(HMEM_CTX_REF, achl_path);
     return;  // in case of permission denied => do nothing
   }

   memset(chrl_tmp_buff, 0, sizeof chrl_tmp_buff);
   uml_size = fread(chrl_tmp_buff, 1, BUFSIZE - 1, adsl_fp);
   achl_tmp = chrl_tmp_buff;
   if (adsp_info != NULL)
      auml_struct = (unsigned int *)adsp_info;
   if (adsp_mem != NULL)
      auml_struct = (unsigned int *)adsp_mem;
   while ((achl_tmp = strtok(achl_tmp, chrl_delim)) != NULL)
   {
     if ((uml_idx & 0x1) != 0)
     {
       uml_value = strtoul(achl_tmp, &achl_ep, 10);
       auml_struct[uml_idx >> 1] = uml_value;
     }
     uml_len = strlen(achl_tmp) + 1;
     achl_tmp += uml_len;
     uml_idx++;
   }

   fclose(adsl_fp);
   FREE_ARRAY(HMEM_CTX_REF, achl_path);
 #undef BUFSIZE
}  // end of static void m_get_proc_io_mem(...)
#endif  // HL_LINUX
//
//
#if defined HL_LINUX
/**
* m_get_proc_file - 
* Read from the specified file in the specified path.
* Either the content is used directly or the content is examined 
* and selected parts of the content are used. 
* The control flag determines which option is active:
* <br>  ~ control flag: bit 0 = 0 -- use content
* <br>  ~ control flag: bit 0 = 1 -- interpret content
* <br>
* -- Linux only Version --
*
* 
*  @param achp_dir_path  path to process
*  @param achp_filename  file to process
*  @param inp_read_file_or_param  control flag
*  @param pShaArray  SHA256 array to use
*  @param aimp_hashedbycount  hashed bytes count pointer
*  @return int state 
*  <br>            > 0 o.k.
*  <br>            == 0 nothing processed
*  <br>            < 0 error condition
*/
static int m_get_proc_file(const char * achp_dir_path,
                           const char * achp_filename,
                           int inp_read_file_or_param,
                           int* pShaArray, int * aimp_hashedbycount)
{
 #define BUFSIZE (8*1024)
 #define NUM_VALUES (32)
   //
   FILE * adsl_file_fp;
   int iml_numbytes;
   unsigned int uml1;
   unsigned int uml2;
   unsigned int uml_len;
   unsigned int uml_funresult;
   char * achl_path;
   char * achl_tmp;
   char * achl_ep;
   char chrl_tmp_buff[BUFSIZE];
   unsigned int umrl_values[NUM_VALUES];
   char chrl_delim[] = { 0x20, 0x09, 0xa, 0 };
//
#if defined XH_INTERFACE
   ds__hmem * vp__ctx = m_get_mem_context();
#endif

   // test passed parameters
   if ((achp_dir_path == NULL) || (achp_filename == NULL))
      return(PRGINI_NULL_PTR);  // (-1), empty input parameters => do nothing

   // initialize variables
   adsl_file_fp = NULL;
   achl_path = NULL;
   uml_funresult = 0;

   uml_len = ((strlen(achp_dir_path) + strlen(achp_filename) + 7) & (~0x03));
   if (uml_len >= INT_PATH_FILENAME_LIMIT)
      return(-3);
   achl_path = (char *)BIT8_ARRAY_ALLOC(HMEM_CTX_REF, (uml_len * sizeof(char)));
   if (achl_path == NULL)
   {
     uml_funresult = errno;
     return(PRGINI_ALLOC_ERR);  //(-2)
   }

   memset(achl_path, 0, uml_len);
   achl_path[0] = '\0';
   strncpy(achl_path, achp_dir_path, strlen(achp_dir_path));
   strncat(achl_path, achp_filename, strlen(achp_filename));

   adsl_file_fp = fopen(achl_path, "r");
   if (adsl_file_fp == NULL)
   { // permission denied
     uml_funresult = errno;
     FREE_ARRAY(HMEM_CTX_REF, achl_path);
     return(0);  // in case of permission denied => do nothing
   }

   // test control flag
   if ((inp_read_file_or_param & 0x01) == 0)
   {
   	 // read file and use content
     for (uml2 = 1; uml2 < 0x7FFFFFF; uml2++)  // uml2 used for emergency break
     {
       memset(chrl_tmp_buff, 0, sizeof(chrl_tmp_buff));
       iml_numbytes = fread(chrl_tmp_buff, 1, (BUFSIZE - 1), adsl_file_fp);
       if (iml_numbytes == -1)
       {
         uml_funresult = errno;
         if (uml_funresult == EINTR)
            continue;
       }
       else
       {
         if ((pShaArray != NULL) && (iml_numbytes > 0))
         {
           SHA256_Update(pShaArray,(char*)chrl_tmp_buff,0,(unsigned int)iml_numbytes);
           if (aimp_hashedbycount != NULL)
             *aimp_hashedbycount += iml_numbytes;
         }
       }
       if ((feof(adsl_file_fp) == 0) || (iml_numbytes <= 0))
          break;
     } // end of for (uml2 = 0; uml2 < 0x7FFFFFF; uml2++)
   }
   else
   {
   	 // read file and interpret content
     memset(umrl_values, 0, sizeof umrl_values);
     uml1 = 0;
     uml2 = 0;

     for (uml2 = 0; uml2 < NUM_VALUES; )
     {
       memset(chrl_tmp_buff, 0, sizeof(chrl_tmp_buff));
       iml_numbytes = fread(chrl_tmp_buff, 1, (BUFSIZE - 1), adsl_file_fp);
       if (iml_numbytes == -1)
       {
         uml_funresult = errno;
         if (uml_funresult == EINTR)
            continue;
       }
       else
       {
         achl_tmp = chrl_tmp_buff;
         while ((achl_tmp = strtok(achl_tmp, chrl_delim)) != NULL)
         {
           if ((uml2 < NUM_VALUES) && (uml1 > 0) && (((uml1 - 1) % 3) == 0))
                umrl_values[uml2++] = strtoul(achl_tmp, &achl_ep, 10);
           uml_len = strlen(achl_tmp) + 1;
           achl_tmp += uml_len;
           uml1++;
         }
       }
       if ((feof(adsl_file_fp) == 0) || (iml_numbytes <= 0))
          break;
     } // end of for (uml2 = 0; uml2 < 0x7FFFFFF; uml2++)

     if ((uml2 > 0) && (pShaArray != NULL))
     {
       uml1 = (uml2 * sizeof(unsigned int));
       SHA256_Update(pShaArray,(char*)(&(umrl_values[0])),0,uml1);
       if (aimp_hashedbycount != NULL)
          *aimp_hashedbycount += (int)uml1;
     }
   } // end of else if ((inp_read_file_or_param & 0x01) == 0)

   fclose(adsl_file_fp);
   adsl_file_fp = NULL;
   FREE_ARRAY(HMEM_CTX_REF, achl_path);
   achl_path = NULL;
   return((int)uml2);
 #undef BUFSIZE
}  // end of static void m_get_proc_file(...)
#endif  // HL_LINUX
//
//
#if defined HL_LINUX
/**
* m_get_threadids - 
* Read from the specified file in the specified path and get entries. <br>
* -- Linux only Version --
*
* 
*  @param achp_dir_path  path to process
*  @param achp_filename  file to process
*  @param pShaArray  SHA256 array to use
*  @param aimp_hashedbycount  hashed bytes count pointer
*/
static void m_get_threadids(const char * achp_dir_path, const char * achp_filename,
                            int* pShaArray, int * aimp_hashedbycount)
{
   DIR * adsl_dir;
   struct dirent * adsl_dirent;
   char * achl_complete_path;
   unsigned int uml1;
   unsigned int uml_funresult;
   int im_pid;
//
#if defined XH_INTERFACE
   ds__hmem * vp__ctx = m_get_mem_context();
#endif

   // test passed parameters
   if ((achp_dir_path == NULL) || (achp_filename == NULL))
      return;  // empty input parameters => do nothing

   // initialize variables
   errno = 0;
   adsl_dir = NULL;
   achl_complete_path = NULL;

   uml1 = ((strlen(achp_dir_path) + strlen(achp_filename) + 7) & (~0x03));
   if (uml1 >= INT_PATH_FILENAME_LIMIT)
      return;
   achl_complete_path = (char *)BIT8_ARRAY_ALLOC(HMEM_CTX_REF, (uml1 * sizeof(char)));
   if (achl_complete_path == NULL)
   {
     uml_funresult = errno;
     return;
   }

   memset(achl_complete_path, 0, (uml1 * sizeof(char)));
   achl_complete_path[0] = '\0';
   strcpy(achl_complete_path, achp_dir_path);
   strcat(achl_complete_path, achp_filename);

   adsl_dir = opendir(achl_complete_path);
   if (adsl_dir == NULL)      
   { // permission denied
     uml_funresult = errno;
     achl_complete_path[0] = '\0';
     FREE_ARRAY(HMEM_CTX_REF, achl_complete_path);
     return;  // in case of permission denied => do nothing
   }

   // enumerate directory entries
   uml1 = 0;
   for ( ; ; )
   {
     errno = 0;  // assure errno is 0  !!!
     adsl_dirent = readdir(adsl_dir);
     if (adsl_dirent == NULL)
     {
       uml_funresult = errno;
       break;
     }
     else
     {
       if (adsl_dirent->d_name[0] != '.')  // ignore '.' and '..' entries
       {
         if (adsl_dirent->d_type == DT_DIR)
         {
           im_pid = (int)strtol(adsl_dirent->d_name, NULL, 10);
           if (im_pid > 0)
           {
             if (pShaArray != NULL)
             {
               SHA256_Update(pShaArray,(char*)(&im_pid),0,sizeof(int));
               if (aimp_hashedbycount != NULL)
                  *aimp_hashedbycount += sizeof(int);
             }
             uml1++;
           }
           if (uml1 > 512)
              break;
         }
       }
     }
   } // end of for ( ; ; )

   closedir(adsl_dir);
   achl_complete_path[0] = '\0';
   FREE_ARRAY(HMEM_CTX_REF, achl_complete_path);
}  // end of static void m_get_threadids(...)
#endif  // HL_LINUX
//
//
/**
* m_get_pidinforma - 
* Get PIDs of currently running processes and return corresponding 
* status values under Linux or get further information about the 
* active processes for the UNIX OSs. <br>
* -- Linux and UNIX Version --
*
* 
*  @param ach_exec_cmd  command to process
*                       including all parameters
*  @param achp_delimit  string delimiter for separation
*  @param imp_exp_exitcode  expected exit code
*  @param ump_process_count  number of processes (Linux only)
*  @param pShaArray  SHA256 array to use
*  @param aim_hashedbycount  hashed bytes count pointer
*  @return int state 
*  <br>            >= 0 o.k., number of bytes collected
*  <br>            < 0 error condition
*/
static int m_get_pidinforma(const char * achp_exec_cmd, const char * achp_delimit,
                            int imp_exp_exitcode, unsigned int ump_process_count,
                            int* pShaArray, int * aimp_hashedbycount)
{
   int iml_retcode;
   unsigned int uml_funresult;
#if defined HL_LINUX
   unsigned int uml1;
   unsigned int uml2;
   char * achl_proc_pid;   
   unsigned int * auml_tmp_buf;
   proc_io_t dsl_procio;
   proc_mem_t dsl_procmem;
#endif  // HL_LINUX
//
#if defined XH_INTERFACE
   ds__hmem * vp__ctx = m_get_mem_context();
#endif

   // test passed parameters
   if ((achp_exec_cmd == NULL) || (achp_delimit == NULL))
      return(-1);
#if defined HL_LINUX
   if (ump_process_count == 0)  // Attention: this value is valid only for LINUX !!!
      return(-3);
#endif  // HL_LINUX
   // initialize variables
   errno = 0;
#if defined HL_LINUX
   auml_tmp_buf = NULL;
   achl_proc_pid = NULL;
#endif  // HL_LINUX
//
#if defined HL_LINUX
   // get PIDs of currently running processes and return "/stat", "/maps" and "/task" values
   auml_tmp_buf = (unsigned int *)BIT8_ARRAY_ALLOC(HMEM_CTX_REF, ((ump_process_count + 2) * sizeof(unsigned int)));
   if (auml_tmp_buf == NULL)
   {
     uml_funresult = errno;
     return(-2);
   }

   memset(auml_tmp_buf, 0, ((ump_process_count + 2) * sizeof(unsigned int)));
   iml_retcode = m_execute_command(achr_commands_ps[1], achrl_delimit_ps[1], imp_exp_exitcode,
                                   auml_tmp_buf, ump_process_count, NULL, NULL);
   if (iml_retcode < 0)
   {
     uml_funresult = errno;
     if (auml_tmp_buf != NULL)
        FREE_ARRAY(HMEM_CTX_REF, auml_tmp_buf);
     return(iml_retcode);
   }

   // process returned list of pid values
   uml2 = (strlen(PROC_PATH) + 10 + 1);
   achl_proc_pid = (char *)BIT8_ARRAY_ALLOC(HMEM_CTX_REF, ((uml2 + 2) * sizeof(char)));
   if (achl_proc_pid == NULL)
   {
     uml_funresult = errno;
     if (auml_tmp_buf != NULL)
        FREE_ARRAY(HMEM_CTX_REF, auml_tmp_buf);
     return(-3);
   }
   errno = 0;
   uml1 = 0;
   while (auml_tmp_buf[uml1] > 0)
   {
     memset(achl_proc_pid, 0, (uml2 + 2));
     snprintf(achl_proc_pid, uml2, "%s%u", PROC_PATH, auml_tmp_buf[uml1]);

     // GetProcessIoCounters, /proc/.../io
     memset(&dsl_procio, 0, sizeof(proc_io_t));
     m_get_proc_io_mem(achl_proc_pid, &dsl_procio, NULL);
     if (pShaArray != NULL)
     {
       SHA256_Update(pShaArray,(char*)(&dsl_procio),0,sizeof(proc_io_t));
       if (aimp_hashedbycount != NULL)
          *aimp_hashedbycount += sizeof(proc_io_t);
     }

     // GetProcessTimes, /proc/.../stat
     m_get_proc_file(achl_proc_pid, "/stat", 0, pShaArray, aimp_hashedbycount);

     // GetProcessMemoryInfo, /proc/.../statm
     memset(&dsl_procmem, 0, sizeof(proc_mem_t));
     m_get_proc_io_mem(achl_proc_pid, NULL, &dsl_procmem);
     if (pShaArray != NULL)
     {
       SHA256_Update(pShaArray,(char*)(&dsl_procmem),0,sizeof(proc_mem_t));
       if (aimp_hashedbycount != NULL)
          *aimp_hashedbycount += sizeof(proc_mem_t);
     }

     // GetModules, /proc/.../maps
     m_get_proc_file(achl_proc_pid, "/maps", 0, pShaArray, aimp_hashedbycount);

     // ThreadIDs, /proc/.../task
     m_get_threadids(achl_proc_pid, "/task", pShaArray, aimp_hashedbycount);

     uml1++;
   } // end of while (auml_tmp_buf[uml1] > 0)

   FREE_ARRAY(HMEM_CTX_REF, achl_proc_pid);
   FREE_ARRAY(HMEM_CTX_REF, auml_tmp_buf);
   iml_retcode = (int)uml1;
//
#else
   // !Linux - GetProcessStatus, /usr/bin/ps
   iml_retcode = m_execute_command(achr_commands_ps[1], achrl_delimit_ps[1], imp_exp_exitcode,
                                   NULL, 0, pShaArray, aimp_hashedbycount);
   if (iml_retcode < 0)
   {
     uml_funresult = errno;
   	 uml_funresult = ump_process_count;
   }
#endif  // HL_LINUX

   return(iml_retcode);
}  // end of static int m_get_pidinforma(...)
//
//
/**
* m_get_system_times - 
* Read the "/proc/stat" special file and return data. 
* The return data string from a read command to "/proc/stat" 
* is interpreted and the required values are returned. 
* "/proc/stat" is not available on IBM AIX systems.
* <br>
* -- Linux and UNIX Version (without IBM AIX) --
*
* 
*  @param adsp_idle return pointer for the idle time
*  @param adsp_kernel return ptr for the kernel time
*  @param adsp_user return pointer for the user time
*  @return int state
*  <br>            >= 0 o.k., number of bytes collected
*  <br>            < 0 error condition
*/
static int m_get_system_times(split_long_t * adsp_idle,
                              split_long_t * adsp_kernel,
                              split_long_t * adsp_user)
{
#define BUFSIZE (200)  // 8 * 20 + 40
  //
  unsigned long ull_use;
  unsigned long ull_ice;
  unsigned long ull_sys;
  unsigned long ull_ide;
  unsigned long ull_iow;
  unsigned long ull_xxx;
  unsigned long ull_yyy;
  unsigned long ull_zzz;
  int iml_fd;
  const char* achl_buf;
  char chrl_buff[BUFSIZE];

  for ( ; ; )  // not a loop !
  {
    iml_fd = 0;
    chrl_buff[BUFSIZE - 1] = 0;
    iml_fd = open("/proc/stat", O_RDONLY, 0);
    if (iml_fd == -1)
       break;
    read(iml_fd, chrl_buff, BUFSIZE - 1);
    close(iml_fd);
    iml_fd = 0;
    achl_buf = strstr(chrl_buff, "cpu ");
    if (achl_buf == NULL)
    {
      iml_fd = -2;
      break;
    }
    sscanf(achl_buf,  "cpu  %lu %lu %lu %lu %lu %lu %lu %lu", 
           &ull_use, &ull_ice, &ull_sys, &ull_ide, &ull_iow, &ull_xxx, &ull_yyy, &ull_zzz);
    adsp_idle->ull_value = ull_ide;
    adsp_kernel->ull_value = (ull_sys + ull_xxx + ull_yyy);
    adsp_user->ull_value = (ull_use + ull_ice);
    break;
  } // end of for ( ; ; )
  if (iml_fd < 0)
  {
    adsp_idle->ull_value = 0;
    adsp_kernel->ull_value = 0;
    adsp_user->ull_value = 0; 
  }
  return(iml_fd);
#undef BUFSIZE
} // end of static int m_get_system_times(...)
//
//
/**
* m_get_clock_rusage - 
* Return the "getrusage" return array and the current clock value. 
* If aump_clock_rusage_buf equals NULL and aump_fill_len is given, 
* the function returns the size of the required buffer in bytes. 
* the buffer must be allocated as unsigned long buffer. 
* If aump_clock_rusage_buf is passed, ump_array_len must give the 
* available size of the buffer and the value in aump_fill_len returns 
* the size of the available data in aump_clock_rusage_buf.
* <br>
* -- Linux and UNIX Version --
*
* 
*  @param aump_clock_rusage_buf data pointer
*  @param aump_fill_len available data/required size
*  @param ump_array_len size of data pointer
*  @return int state 
*  <br>            > 0 data available
*  <br>            = 0 no data available / array too short
*  <br>            < 0 error condition
*/
static int m_get_clock_rusage(unsigned long * aump_clock_rusage_buf,
                              unsigned int * aump_fill_len,
                              unsigned int ump_array_len)
{
   int iml_retval;
   unsigned int uml1;
   unsigned int uml_idx;
   long int ill_tempval;
   struct rusage dsl_rusagestruc;

   iml_retval = 0;
   if (aump_clock_rusage_buf == NULL)
   {
     if (aump_fill_len != NULL)
     {
       uml1 = ((sizeof(struct rusage) + sizeof(unsigned long) +
                sizeof(unsigned long) + 7) / sizeof(unsigned long));
       *aump_fill_len = (uml1 * sizeof(unsigned long));
     }
     else
        iml_retval = -1;
     ill_tempval = clock();
     return(iml_retval);
   }

   if (ump_array_len <= sizeof(unsigned long))
   {
     iml_retval = -2;
     return(iml_retval);
   }

   uml_idx = 0;
   ill_tempval = clock();  // returns the number of clock ticks elapsed since the program was launched
   if (ill_tempval != -1L)
   {
     iml_retval |= 0x01;
     aump_clock_rusage_buf[uml_idx] = (unsigned long)ill_tempval;
     uml_idx++;
   }

   if (getrusage(RUSAGE_SELF, &dsl_rusagestruc) == 0)
   {
   	 uml1 = ((uml_idx * sizeof(unsigned long)) + sizeof(struct rusage));
   	 if (uml1 > ump_array_len)
   	    uml1 = (ump_array_len - (uml_idx * sizeof(unsigned long)));
   	 else
   	    uml1 = sizeof(struct rusage);

     if (uml1 > 0)
     {
       iml_retval |= 0x02;
       memcpy((void *)(&(aump_clock_rusage_buf[uml_idx])), (&dsl_rusagestruc), uml1);
     }
     uml1 += (uml_idx * sizeof(unsigned long));
   }
   else
   {
     uml1 = (uml_idx * sizeof(unsigned long));
     ;
   }

   if (aump_fill_len != NULL)
   {
     *aump_fill_len = uml1;
   }

   return(iml_retval);
}  // end of static int m_get_clock_rusage(...)
//
//
/**
* m_print_dir - 
* Get the 'stat' information of all files in a given directory 
* and process this function recursively through all subfolders. 
* The function has a time limit in micro seconds that is 
* reduced when the next level is called.
* <br>
* -- Linux and UNIX Version --
*
* 
*  @param achp_dirname  directory name
*  @param imp_timval_usec  allowed time for current level
*  @param pShaArray  SHA256 array to use
*  @param aimp_hashedbycount  hashed bytes count pointer
*/
static void m_print_dir(const char * achp_dirname, int imp_timval_usec,
                        int* pShaArray, int * aimp_hashedbycount)
{
   int inl_idx;
   int inl_length;
   int inl_emgcexit;
   int inl_retlen;
   int inl_timeidx;
   int iml_bythshd;
   int iml_dumval;
   unsigned int uml_funresult;
   long long  ill_strttim, illcurrtim;
   DIR * adsl_dir;
   struct dirent * adsl_dirent;
   struct stat dsl_statstruc;
   struct timeval  dsl_tv_currenttime;
   char * achl_complete_path;
   char * achl_help_path;
//
#if defined XH_INTERFACE
   ds__hmem * vp__ctx = m_get_mem_context();
#endif

   // test passed parameters
   if (achp_dirname == NULL)
      return;  // in case of no input name => do nothing
   uml_funresult = 0;
   // test passed filename
   adsl_dir = NULL;
   achl_complete_path = NULL;
   inl_length = ((strlen(achp_dirname) + NAME_MAX + 7) & (~0x03));
   if (inl_length >= INT_PATH_FILENAME_LIMIT)
      return;
   achl_complete_path = (char *)BIT8_ARRAY_ALLOC(HMEM_CTX_REF, ((inl_length + 1) * 2 * sizeof(char)));
   if (achl_complete_path == NULL)
   {
     uml_funresult = errno;
     return;
   }
   if (imp_timval_usec == 0)
      return;
   if (aimp_hashedbycount == NULL)
   {
   	 iml_dumval = 0;
   	 aimp_hashedbycount = (&iml_dumval);
   }
   iml_bythshd = *aimp_hashedbycount;
   memset(achl_complete_path, 0, (inl_length * sizeof(char)));

   adsl_dir = opendir(achp_dirname);
   if (adsl_dir == NULL)
   {
     FREE_ARRAY(HMEM_CTX_REF, achl_complete_path);
     return;  // in case of permission denied => do nothing
   }
   achl_help_path = (&(achl_complete_path[inl_length]));

   // get current start time
   if (gettimeofday(&dsl_tv_currenttime, NULL) != 0)
      ill_strttim = 0LL;
   else
     ill_strttim = ((((long long)(dsl_tv_currenttime.tv_sec)) * 1000000LL) +
                    ((long long)(dsl_tv_currenttime.tv_usec)));

   // enumerate directory entries
//   for (inl_emgcexit = 0; inl_emgcexit < 10000; )
   for (inl_emgcexit = 0, inl_timeidx = 1; inl_emgcexit < 1000; inl_timeidx++)
   {
     errno = 0;  // assure errno is 0  !!!
     adsl_dirent = readdir(adsl_dir);
     if (adsl_dirent == NULL)
     {
       if ((errno != 0) && (errno != ENOENT))  // error != no entry
       {
         uml_funresult = errno;
         inl_emgcexit++;
         continue;  // has an error, skip entry
       }
       break;  // end loop
     }
     else
     {
       // found next entry in current directory
       inl_emgcexit = 0;
       if (adsl_dirent->d_name[0] != '.')
       {
         memset(achl_complete_path, 0, (inl_length * 2 * sizeof(char)));
         achl_complete_path[0] = '\0';
         if ((strlen(achp_dirname) + strlen(adsl_dirent->d_name)) > ((unsigned int)(inl_length - 2)))
         {
           continue;
         }
         // construct path name
         strcpy(achl_complete_path, achp_dirname);
         strcat(achl_complete_path, adsl_dirent->d_name);

         // test, if a symbolic link refers backwards to a previous directory and thus creates an endless loop
         // get status of current symbolic link
         // lstat() stats the file pointed to by path and fills in stat structure. 
         // if path is a symbolic link, then the link itself is stat-ed, not the file that it refers to.
         if (lstat(achl_complete_path, &dsl_statstruc) == 0)
         {
           if (S_ISLNK(dsl_statstruc.st_mode) != 0)
           {
             // place the contents of the symbolic link referred to by achl_complete_path in the buffer achl_help_path
             inl_retlen = readlink(achl_complete_path, achl_help_path, (inl_length * sizeof(char)));
             // The value SSIZE_MAX for "size_t bufsiz" is removed because it may allow to access 2 GByte.

             if (inl_retlen > 0)
             {
               for (inl_idx = 0; inl_idx < inl_retlen; inl_idx++)
               {
                 if ((achl_help_path[inl_idx] != '.') && (achl_help_path[inl_idx] != '/'))
                    break;
               }
               if (inl_idx >= inl_retlen)
               {
                 // only '.' and '/' is found, this kind of path may cause useless loops
                 inl_emgcexit++;
                 continue;
               }
               else
               {
               	 // do further research on the string found in the symbolic link
                 if (inl_retlen <= (int)strlen(achp_dirname))
                 {
                 	 if (strncmp(achp_dirname, achl_help_path, inl_retlen) == 0)
                      continue;  // symbolic link represents a part of the
                 }
                 // check, if single '.' characters are found
                 for (inl_idx = 0; inl_idx < inl_retlen; inl_idx++)
                 {
                   if (achl_help_path[inl_idx] == '.')
                      break;
                 }
                 if (inl_idx < inl_retlen)
                 {
                   // at least one '.' is found, this kind of path may cause useless loops
                   continue;
                 }
                 else
                 {
               	   // maybe it is necessary to identify identical parts
                 }
               }
             }
             else
                continue;
           }
         }
         else
         {
           uml_funresult = errno;
         }

         memset(&dsl_statstruc, 0, sizeof(struct stat));

         // get status of current directory using the fully qualified path
         // stat() stats the file pointed to by path and fills in stat structure. 
         // If path is a symbolic link, then the file that it refers to is stat-ed.
         if (stat(achl_complete_path, &dsl_statstruc) == 0)
         {
           if (pShaArray != NULL)
           {
             SHA256_Update(pShaArray,(char*)(&dsl_statstruc),0,sizeof(struct stat));
             *aimp_hashedbycount += sizeof(struct stat);
           }
           if (S_ISDIR(dsl_statstruc.st_mode))
           {
             // test time only every 4th try
             if ((inl_timeidx & 0x03) == 0)
             {
               // get current time and test time
               if (gettimeofday(&dsl_tv_currenttime, NULL) != 0)
                  illcurrtim = 0LL;
               else
                  illcurrtim = ((((long long)(dsl_tv_currenttime.tv_sec)) * 1000000LL) +
                                ((long long)(dsl_tv_currenttime.tv_usec)));
               if (illcurrtim > ill_strttim)
               {
               	 inl_idx = (int)(illcurrtim - ill_strttim);
                 if (inl_idx > imp_timval_usec)
                    break;  // leave the current level, if time limit is reached
               }
             }
             if (imp_timval_usec > 1000)
                inl_idx = (imp_timval_usec >> 2);
             else
                inl_idx = (imp_timval_usec >> 1);

             strcat(achl_complete_path, "/");
             m_print_dir(achl_complete_path, inl_idx, pShaArray, aimp_hashedbycount);
           }
         }
         else
         {
           uml_funresult = errno;
         }

       } // end of if (adsl_dirent->d_name[0] != '.')
     } // end of else if (adsl_dirent == NULL)

//     if (((*aimp_hashedbycount) - iml_bythshd) > 10000)
//        break;

   } // end of for (inl_emgcexit = 0; inl_emgcexit < 16; )

   if (adsl_dir != NULL)
      closedir(adsl_dir);
   memset(achl_complete_path, 0, (inl_length * sizeof(char)));
   FREE_ARRAY(HMEM_CTX_REF, achl_complete_path);
}  // end of static void m_print_dir(...)
//
//
/**
* m_getfnfromcwd - 
* Get the name of a file in a given directory. 
* This function just returns the name of any arbitrary file 
* that is found in this directory and that can be accessed 
* with lstat and that has a size of more than 16 Bytes. 
* This is needed as a parameter for the statvfs() function. 
* <br>
* -- Linux and UNIX Version --
*
* 
*  @param achp_pathname  directory for file search
*  @param achp_filename  buffer to return the filename
*  @param unp_fnlength  size of return buffer
*  @return int state 
*  <br>             > 0 length of returned filename
*  <br>             = 0 empty input directory name
*  <br>             < 0 error condition
*/
static int m_getfnfromcwd(const char * achp_pathname, 
                          char * achp_filename,
                          unsigned int unp_fnlength)
{
   DIR *  adsl_dir;
   struct dirent *  adsl_dirent;
   struct stat  dsl_statstruc;
   char *  achl_complete_path;
   int  inl_length;
   int  inl_emgcexit;
   unsigned int  uml1;
   unsigned int  uml_funresult = 0;
//
#if defined XH_INTERFACE
   ds__hmem * vp__ctx = m_get_mem_context();
#endif

   // test passed parameters
   if (achp_pathname == NULL)
      return(-1);  // in case of no input file => do nothing
   if ((achp_filename == NULL) || (unp_fnlength <= 0))
      return(-2);  // in case of no output array => do nothing

   adsl_dir = NULL;
   achl_complete_path = NULL;
   uml1 = (PATH_MAX + FILENAME_MAX);
   if (uml1 > INT_PATH_FILENAME_LIMIT)
      uml1 = INT_PATH_FILENAME_LIMIT;
   inl_length = strlen(achp_pathname);
   if ((inl_length > INT_PATH_FILENAME_LIMIT) || (inl_length < 0))
      return(-3);
   if (inl_length == 0)
      return(0);
   inl_length += ((int)uml1 + 2);

   achl_complete_path = (char *)BIT8_ARRAY_ALLOC(HMEM_CTX_REF, (inl_length * sizeof(char)));
   if (achl_complete_path == NULL)
   {
     uml_funresult = errno;
     return(-4);
   }
   memset(achl_complete_path, 0, (inl_length * sizeof(char)));
   achp_filename[0] = '\0';

   adsl_dir = opendir(achp_pathname);
   if (adsl_dir == NULL)
   {
     FREE_ARRAY(HMEM_CTX_REF, achl_complete_path);
     uml_funresult = errno;
     return(-5);  // in case of permission denied => do nothing
   }

   // enumerate directory entries
   for (inl_emgcexit = 0; inl_emgcexit < 10000; )
   {
     errno = 0;  // assure errno is 0  !!!
     adsl_dirent = readdir(adsl_dir);
     if (adsl_dirent == NULL)
     {
       if ((errno != 0) && (errno != ENOENT))  // error != no entry
       {
         uml_funresult = errno;
         inl_emgcexit++;
         continue;  // has an error, skip entry
       }
       break;  // end loop
     }
     else
     {
       inl_emgcexit = 0;
       if (adsl_dirent->d_name[0] != '.')
       {
         memset(achl_complete_path, 0, (inl_length * sizeof(char)));
         achl_complete_path[0] = '\0';
         if ((strlen(achp_pathname) + strlen(adsl_dirent->d_name)) > ((unsigned int)(inl_length - 2)))
         {
           continue;
         }
         strcpy(achl_complete_path, achp_pathname);
         strcat(achl_complete_path, "/");
         strcat(achl_complete_path, adsl_dirent->d_name);

         // found next entry, get status
         if (lstat(achl_complete_path, &dsl_statstruc) == 0)
         {
           if (dsl_statstruc.st_size > 16L)
           {
             if (strlen(adsl_dirent->d_name) < unp_fnlength)
             {
               strcpy(achp_filename, adsl_dirent->d_name);
               break;
             }
           }
         }
         else
         {
           uml_funresult = errno;
         }
       } // end of if (adsl_dirent->d_name[0] != '.')
     } // end of else if (adsl_dirent == NULL)
   } // end of for (inl_emgcexit = 0; inl_emgcexit < 10000; )

   if (adsl_dir != NULL)
      closedir(adsl_dir);
   achl_complete_path[0] = '\0';
   FREE_ARRAY(HMEM_CTX_REF, achl_complete_path);

   inl_length = strlen(achp_filename);

   return(inl_length);
}  // end of static int m_getfnfromcwd(...)
//
//
/**
* m_hashdevrandom - Add '/dev/(u)random' data to the hash array.
* <br><br>
* Read 24 Bytes from the Linux/UNIX random devices ('/dev/random' 
* and '/dev/urandom'). 3 Bytes are read from '/dev/random' or from 
* '/dev/urandom' if the system does not support '/dev/random'. 
* Then the rest is read from '/dev/urandom' in 2 steps. <br>
* -- Linux and UNIX Version --
*
* 
*  @param pShaArray  SHA256 array to use
*  @param unp_dvrndnum  number of bytes that shall be read from /dev/random
*  @param aimp_hashedbycount  hashed bytes count pointer
*  @return int state
*  <br>            > 0 number of hashed '/dev/random' bytes
*  <br>            = 0 ok, but no '/dev/random' data available
*  <br>            < 0 error condition
*/

static int m_hashdevrandom(int* pShaArray, unsigned int ump_dvrndnum,
                           int * aimp_hashedbycount)
{
   //
   int  inl_frd;
   int  inl_devrndcount;
   unsigned int  uml1;
   unsigned int  uml2;
   unsigned int  uml3;
   unsigned int  uml_rand_pass;
   unsigned int  uml_funresult;
   unsigned char  byrl_randdata[RANDBUFSIZE];
   FILE *  adsl_rand_fp;

   // check passed
   if (ump_dvrndnum > (RANDBUFSIZE / 2))
      return(-2);
   ;

   // initialize variables
   inl_devrndcount = 0;
   uml_funresult = 0;
   adsl_rand_fp = NULL;

   // clear destination array
   memset(byrl_randdata, 0, RANDBUFSIZE * sizeof(unsigned char));
   uml1 = 0;
//
#if !defined HL_LINUX_ARM
   adsl_rand_fp = fopen("/dev/random", "r");
#else
   adsl_rand_fp = fopen("/dev/urandom", "r");
#endif  // HL_LINUX_ARM

   if (adsl_rand_fp == NULL)
   {
     uml_funresult = errno;
   }
   else
   { // read 3 Bytes from /dev/random
     for ( ; ; )
     {
       // read the /dev/random data
       inl_frd = fread((void *)(&(byrl_randdata[uml1])), 
                       sizeof(unsigned char), (ump_dvrndnum - uml1), adsl_rand_fp);
       if (inl_frd != (int)((ump_dvrndnum - uml1) * sizeof(unsigned char)))
       {
         uml_funresult = errno;
         if (inl_frd == -1)
         { // check, whether EINTR was causing the error
           if (uml_funresult == EINTR)
           {
             uml_funresult = 0;
             continue;
           }
           break;
         }
       }
       if (inl_frd > 0)
       {
#if !defined HL_LINUX_ARM
         inl_devrndcount += inl_frd;
#endif  // HL_LINUX_ARM
         uml1 += (unsigned int)inl_frd;
       }
       if (uml1 >= ump_dvrndnum)
          break;
     } // end of for ( ; ; )
   } // end of else if (adsl_rand_fp == NULL)
//
#if !defined HL_LINUX_ARM
   if (adsl_rand_fp != NULL)
      fclose(adsl_rand_fp);

   adsl_rand_fp = fopen("/dev/urandom", "r");
   if (adsl_rand_fp == NULL)
   {
     uml_funresult = errno;
   }
#endif  // HL_LINUX_ARM

   if (adsl_rand_fp != NULL)
   { // do reading the rest from /dev/urandom twice to fill up the required number of bytes
     for (uml_rand_pass = 2; uml_rand_pass > 0; uml_rand_pass--)
     { // read the /dev/urandom data in a loop to increase the variance of the delta time
     	 uml3 = 0;
     	 uml2 = ((RANDBUFSIZE - uml1) >> (uml_rand_pass - 1));
       for ( ; ((uml2 > 0) && (uml2 <= RANDBUFSIZE)); )
       {
         inl_frd = fread((void *)(&(byrl_randdata[uml1])), 
                         sizeof(unsigned char), (uml2 - uml3), adsl_rand_fp);
         if (inl_frd != (int)(uml2 - uml3))
         {
           uml_funresult = errno;
           if (inl_frd == -1)
           { // check, whether EINTR was causing the error
             if (uml_funresult == EINTR)
             {
               uml_funresult = 0;
               continue;
             }
             break;
           }
         }
         if (inl_frd > 0)
         {
           uml3 += (unsigned int)inl_frd;
           uml1 += (unsigned int)inl_frd;
         }
         if (uml3 >= uml2)
            break;
       } // end of for ( ; ((uml2 > 0) && (uml2 <= RANDBUFSIZE)); )
     } // end of for (uml_rand_pass = 2; uml_rand_pass > 0; uml_rand_pass--)

     fclose(adsl_rand_fp);
     adsl_rand_fp = NULL;
   }

   if ((uml1 > 0) && (pShaArray != NULL))
   {
     SHA256_Update(pShaArray,(char*)(&(byrl_randdata[0])),0,(uml1 * sizeof(unsigned char)));
     if (aimp_hashedbycount != NULL)
        *aimp_hashedbycount += uml1;
   }

   if (uml_funresult != 0)
   {
   	 inl_devrndcount = (int)uml_funresult;
   	 if (inl_devrndcount > 0)
   	    inl_devrndcount = (inl_devrndcount * -1);
   }
   return(inl_devrndcount);
}  // end of static int m_hashdevrandom(...)
//
/**
Calculates an entropy estimation for the values in the given timestamp array.

The estimation is for a single entry, NOT for the entire array.
The array is expected to be of lenght PERFCOUNTBUFLEN.

@param[in]  allp_timestamps Array containing the timestamps to be tested.

@return The entropy estimation for the values in the array.
*/
static double m_get_entropy_est(long long* allp_timestamps)
{
#define PERFCOUNTBUFLEN  8
    char byrl_tmpdata[20];

    memset(byrl_tmpdata, 0, sizeof(byrl_tmpdata));
    // separate the lower 2 decimal digits and collect basic statistic information
     for (int inl_idx = 0; inl_idx < PERFCOUNTBUFLEN; inl_idx++)
     {
       // test the isolated decimal number
       unsigned int uml_val = (unsigned int)(allp_timestamps[inl_idx] % 10L);
       byrl_tmpdata[uml_val]++;  // count the number of single values
       if (uml_val > 5)  // check upper/lower half of possible numbers
          byrl_tmpdata[17]++;
       else
          byrl_tmpdata[16]++;
       if ((uml_val & 0x01) == 0)  // check even/odd half of possible numbers
          byrl_tmpdata[18]++;
       else
          byrl_tmpdata[19]++;
       uml_val = (unsigned int)((allp_timestamps[inl_idx] / 10L) % 10L);
       byrl_tmpdata[uml_val]++;  // count the number of single values
       if (uml_val > 5)  // check upper/lower half of possible numbers
          byrl_tmpdata[17]++;
       else
          byrl_tmpdata[16]++;
       if ((uml_val & 0x01) == 0)  // check even/odd half of possible numbers
          byrl_tmpdata[18]++;
       else
          byrl_tmpdata[19]++;
     }
     // check the results and decrease the amount of entropy per value, if inconsistencies are found
     double fdl_val1 = 42.0;  // this is the maximum possible entropy value for 7 values containing 6 bits of entropy
     unsigned int uml_unsitmp = 0;
     for (int inl_idx = 0; inl_idx < 10; inl_idx++)
     {
       if (byrl_tmpdata[inl_idx] == 0)
          uml_unsitmp++;
     }
     // decrease the entropy by 3.75, if one number out of 0 ... 9 is missing in the above collected 16 values
     if (uml_unsitmp > 0)
        fdl_val1 -= (double)(((float)uml_unsitmp) * 6.0F * (10.0F / (PERFCOUNTBUFLEN * 2)));  // 6 * 10/(2*8) = 3.75
     // check whether the distribution of higher and lower values is irregular
     uml_unsitmp = (((int)byrl_tmpdata[16]) < ((int)byrl_tmpdata[17])) ?
                    ((int)byrl_tmpdata[16]) : ((int)byrl_tmpdata[17]);
     if (uml_unsitmp <= 5)
        fdl_val1 -= (fdl_val1 * ((6.0 - ((double)uml_unsitmp)) / 10.0));  // decrease the entropy by 10% ... 50%
     // check whether the distribution of even and odd values is irregular
     uml_unsitmp = (((int)byrl_tmpdata[18]) < ((int)byrl_tmpdata[19])) ?
                    ((int)byrl_tmpdata[18]) : ((int)byrl_tmpdata[19]);
     if (uml_unsitmp <= 5)
        fdl_val1 -= (fdl_val1 * ((6.0 - ((double)uml_unsitmp)) / 10.0));  // decrease the entropy by 10% ... 50%
     // set the final entropy value that is assumed for one item of the OS-API time
     return (fdl_val1 / ((double)(PERFCOUNTBUFLEN - 1)));
     // Note: it should be examined whether this testing can be done by using a runs test on the data

}// static double m_get_entropy_est(HMEM_CTX_DEF long long* allp_timestamps);

/**
* SysGetEntropy - Collect entropy for DRBG seed on UNIX/Linux systems. 
* 
* This is the core function that collects entropy from the various 
* system API calls. After all entropy gathering functions are 
* processed the results from the qualified entropy sources that 
* are analyzed are tested. As it is known that the amount of entropy 
* from the analyzed sources is given if the processing works correctly, 
* the results from these functions must simply be tested for their 
* availability. If no error condition is detected the required amount 
* of entropy is contained in the seed data. 
* <br>
* The local variable 'fll_entropest' is used to estimate an entropy 
* value in bits. The return values from the function m_calc_pi_wallis 
* (entropy source Wallis product)are examined and, if entropy is missing 
* due to bad CPU performance, the missing entropy is tightened by more 
* bytes that are used from the system device file "/dev/random". The third 
* part that is used for entropy estimation is the OS-API-time that is 
* determined as an event time before and after a group of commands is 
* processed. After all relevant items contributed to 'fll_entropest' 
* this value is tested against 50.0. 50 bits entropy is the minimum 
* requirement for the Common Criteria evaluation to guarantee a proper 
* seed value for the considered scenario the software is used in.
* <br>
* The output of the wallis product is valued according to the number of 
* loops that were performed in the function and the number of rounds that 
* were returned from the function. With 2 valid loops and a sufficient 
* numbver of rounds it is assumed that 13 bits entropy are available. If 
* more loops with less rounds are executed the amount od entropy is 
* reduced accordingly. If the portion of entropy bits gain from the 
* wallis product is found to be less equal to 5 bits, then 3 bytes are 
* fetched from the system device file "/dev/random" instead of 2.
* <br>
* Linux and the different UNIX OSs require slightly modified or 
* different or even additional actions to be taken in the groups of 
* commands used for the OS-API-time entropy source. The main differences 
* are apparent in the constant String defines that are used for the 
* in-program executed console commands.
* <br>
* -- Linux and UNIX Version --
*
*  @param abyp_pdigest Output buffer, 32 bytes
*  @param ainp_byteshashed Number of bytes hashed
*  @return int state 
*  <br>            > 0 reference value for the collected data
*  <br>            <= 0 error condition
*/
int SysGetEntropy(HMEM_CTX_DEF char* abyp_pdigest,
                               int* ainp_byteshashed)
{
#define PERFCOUNTBUFLEN  8
   //
   int  inl2;
   int  inl_retcode;
   int  inl_byteshashed;
   int  inl_idx;
   int  inl_len;
   int  inl_devrnd_value;
   int  inl_totalpercentage;
   unsigned int  uml_val;
   unsigned int  uml_unsitmp;
   unsigned int  uml_funresult;
   int  iml_tmpval;
   long long  ill_val64;
   long  ill_pi_val;
   long  ill_longval;
   float fll_entropest;
   double fdl_val1;
   double fdl_val2;
   time_t  dsl_systemtime;
   struct tm  dsl_tm_systime;
   struct timeval  dsl_timeval_qperf;
   struct tms  dsl_tmptime;
#ifndef HL_ANDROID
   struct statvfs  dsl_stvfsbuf;
#else
   struct statfs  dsl_stvfsbuf;
#endif  // HL_ANDROID
   system_info_t  dsl_performinform;
   split_long_t  dsl_idletime1;
   split_long_t  dsl_kerneltime1;
   split_long_t  dsl_usertime1;
   split_long_t  dsl_idletime2;
   split_long_t  dsl_kerneltime2;
   split_long_t  dsl_usertime2;
   split_long_t  dsrl_wallis_rounds[5];
   char byrl_tmpdata[256];
   int ShaArray[SHA256_ARRAY_SIZE];
   long long ulrl_perfcountbuf[PERFCOUNTBUFLEN];
   unsigned long long ulrl_tsc_buf[PERFCOUNTBUFLEN];
   char *  achl_fnametmp;
   char *  achl_curprocpath;
   unsigned long *  auml_ulng_buf;
   //
   //-------------------------------------------------------
   // Initialize variables and the SHA-256 hash array
   //-------------------------------------------------------
   inl_byteshashed = 0;
   inl_totalpercentage = 0;
   fll_entropest = 0.0F;
   SHA256_Init(ShaArray);
   memset(((void *)(&(ulrl_perfcountbuf[0]))), 0, (sizeof(long long) * PERFCOUNTBUFLEN));
   memset(((void *)(&(ulrl_tsc_buf[0]))), 0, (sizeof(unsigned long long) * PERFCOUNTBUFLEN));
#if defined XH_INTERFACE
#else
   ;
#endif   // XH_INTERFACE

   //-------------------------------------------------
   // 1. Collect all the performance counter values 
   //    at the start of the entropy gathering and 
   //    after the end of the processing of each 
   //    specific group of items
   //-------------------------------------------------
   // 1a. Add the performance counter value before 
   //     the start of processing item 2.
   //-------------------------------------------------
   if (m_get_high_resolutime(&ill_val64) >= 0)
   {
     ulrl_perfcountbuf[0] = ill_val64;
     ulrl_tsc_buf[0] = m_get_tsc();
     Sleep(2);  // wait for 2 msec
   }
   else
   {
     SHA256_Update(ShaArray,(char*)(&ill_val64),0,sizeof(long long));
     inl_byteshashed += sizeof(long long);
   }
   // -------------------------------------------------------------------------
   // 2. get Local Time, the Process ID, the Parent Process ID, the Thread ID, 
   //    the current Tick Count, the clock value for the processor time and 
   //    the performance info values
   // -------------------------------------------------------------------------
   inl_idx = 0;
   // get local time
   dsl_systemtime = time(NULL);  // Time / Date
   localtime_r(&dsl_systemtime, &dsl_tm_systime);  // format the time
   long2char(((int)(dsl_tm_systime.tm_mday)), byrl_tmpdata, inl_idx);
   long2char(((int)(dsl_tm_systime.tm_mon)), byrl_tmpdata, inl_idx);
   long2char(((int)(dsl_tm_systime.tm_year)), byrl_tmpdata, inl_idx);
   long2char(((int)(dsl_tm_systime.tm_hour)), byrl_tmpdata, inl_idx);
   long2char(((int)(dsl_tm_systime.tm_min)), byrl_tmpdata, inl_idx);
   long2char(((int)(dsl_tm_systime.tm_sec)), byrl_tmpdata, inl_idx);
   long2char(((int)(dsl_tm_systime.tm_yday)), byrl_tmpdata, inl_idx);
   if (gettimeofday(&dsl_timeval_qperf, NULL) == 0)
   {
     long2char(((int)(dsl_timeval_qperf.tv_sec)), byrl_tmpdata, inl_idx);
     long2char(((int)(dsl_timeval_qperf.tv_usec)), byrl_tmpdata, inl_idx);
   }
   // get the process ID
   iml_tmpval = getpid();  // Process ID
   long2char(iml_tmpval, byrl_tmpdata, inl_idx);
   // get the parent process ID
   iml_tmpval = getppid();
   long2char(iml_tmpval, byrl_tmpdata, inl_idx);
   // get the thread ID
#if defined HL_LINUX
#ifndef HL_ANDROID
   iml_tmpval = syscall(SYS_gettid);  // return the thread ID of the current process for standard Linux OSs
# else
   iml_tmpval = syscall(__NR_gettid);  // return the thread ID of the current process for the Android OS
#endif  // HL_ANDROID
   long2char(iml_tmpval, byrl_tmpdata, inl_idx);
#endif  // HL_LINUX
#if defined HL_HPUX
   iml_tmpval = pthread_self();  // obtain the thread ID for the calling thread
   long2char(iml_tmpval, byrl_tmpdata, inl_idx);
#endif  // HL_HPUX
   // get the real user ID of the calling process
   iml_tmpval = getuid();
   long2char(iml_tmpval, byrl_tmpdata, inl_idx);
   // get the frequency of the high-resolution performance counter
   uml_unsitmp = sysconf(_SC_CLK_TCK);  // Hz value
   if (uml_unsitmp != 0)
   {
     long2char(uml_unsitmp, byrl_tmpdata, inl_idx);
     // get tick count in milliseconds
     iml_tmpval = (int)((times(&dsl_tmptime) * uml_unsitmp) / 1000); 
     long2char(iml_tmpval, byrl_tmpdata, inl_idx);
   }
   else
   {
     iml_tmpval = times(&dsl_tmptime);
     long2char(iml_tmpval, byrl_tmpdata, inl_idx);
   }
   // get the clock value for the processor time
   iml_tmpval = clock();
   if (iml_tmpval != -1)
   {
     long2char(iml_tmpval, byrl_tmpdata, inl_idx);
     inl_totalpercentage += 1;
     ;
   }
   // add the values to the hash
   SHA256_Update(ShaArray,byrl_tmpdata,0,inl_idx);
   inl_byteshashed += inl_idx;
   inl_totalpercentage += 6;
   //
   // get the performance info values
   if (m_get_perform_info(&dsl_performinform) > 0)
   {
     SHA256_Update(ShaArray,(char*)(&dsl_performinform),0,sizeof(system_info_t));
     inl_byteshashed += sizeof(system_info_t);
     inl_totalpercentage += 5;
   }
   //---------------------------------------------------------------
   // 1b. Add the performance counter value after processing item 2.
   //---------------------------------------------------------------
   if (m_get_high_resolutime(&ill_val64) >= 0)
   {
     ulrl_perfcountbuf[1] = ill_val64;
     ulrl_tsc_buf[1] = m_get_tsc();
     Sleep(2);  // wait for 2 msec
   }
   else
   {
     SHA256_Update(ShaArray,(char*)(&ill_val64),0,sizeof(long long));
     inl_byteshashed += sizeof(long long);
   }
   // -------------------------------------------------------------------------
   // 3. get information related to all processes running on the system 
   //    which can be accessed; this is the IO information, the timer 
   //    information and the memory information; furthermore module and 
   //    thread information is collected which is related to each found 
   //    process
   // -------------------------------------------------------------------------
   inl_retcode = m_execute_command(achr_commands_ps[0], achrl_delimit_ps[0], 0,
                                   NULL, 0, ShaArray, &inl_byteshashed);
   if (inl_retcode > 0)
   {
     inl_totalpercentage += (((inl_retcode >> 4) < 20) ? (inl_retcode >> 4) : 20);
   }
   else
   {
     uml_funresult = errno;
   }
//
#if defined HL_LINUX
       // get PIDs of currently running processes and return "/stat", "/maps" and "/task" values
   uml_unsitmp = dsl_performinform.um_process_count;  // Attention: this value is valid only for LINUX !!!
#else
   uml_unsitmp = 0;
#endif  // HL_LINUX
   inl_retcode = m_get_pidinforma(achr_commands_ps[1], achrl_delimit_ps[1], 0,
                                  uml_unsitmp, ShaArray, &inl_byteshashed);
   if (inl_retcode > 0)
   {
     inl_totalpercentage += (((inl_retcode >> 4) < 20) ? (inl_retcode >> 4) : 20);
   }
   else
   {
     uml_funresult = errno;
   }
   //---------------------------------------------------------------
   // 1c. Add the performance counter value after processing item 3.
   //---------------------------------------------------------------
   if (m_get_high_resolutime(&ill_val64) >= 0)
   {
     ulrl_perfcountbuf[2] = ill_val64;
     ulrl_tsc_buf[2] = m_get_tsc();
     Sleep(2);  // wait for 2 msec
   }
   else
   {
     SHA256_Update(ShaArray,(char*)(&ill_val64),0,sizeof(long long));
     inl_byteshashed += sizeof(long long);
   }
   // -------------------------------------------------------------------------
   // 4. get System Times (corresponds with CPU load, i.e. idle time, kernel 
   //    time and user time), do calculation program (Wallis) and measure time
   // -------------------------------------------------------------------------
   // do the processing to get the system time information before Wallis
   inl_retcode = m_get_system_times(&dsl_idletime1, &dsl_kerneltime1, &dsl_usertime1);
   auml_ulng_buf = NULL;
   uml_val = 0;
   inl_retcode = m_get_clock_rusage(NULL, &uml_val, 0);

   // do the processing to get rusage information before Wallis
   for ( ; inl_retcode > 0; )  // not a loop, just an if !
   {
     auml_ulng_buf = (unsigned long *)BIT8_ARRAY_ALLOC(HMEM_CTX_REF, (uml_val * sizeof(unsigned char)));
     if (auml_ulng_buf == NULL)
     {
       uml_funresult = errno;
       break;
     }
     memset(auml_ulng_buf, 0, uml_val);
     uml_unsitmp = 0;
     inl_retcode = m_get_clock_rusage((&(auml_ulng_buf[0])), &uml_unsitmp, uml_val);

     if (inl_retcode > 0)
     {
       SHA256_Update(ShaArray,(char*)auml_ulng_buf,0,uml_unsitmp);
       inl_byteshashed += (int)uml_unsitmp;
       inl_totalpercentage += 3;
       ;
     }
     break;
   }
   //
   // Wallis product (calculate the number pi with a very lousy routine)
   ill_pi_val = m_calc_pi_wallis(&(dsrl_wallis_rounds[0]));
   //
   // test whether any of the values falls below a certain limit which is a hint for incorrect processing
   if (ill_pi_val > 0L)
   {
     for (inl_idx = 0; inl_idx < 4; inl_idx++)
     {
       if ((dsrl_wallis_rounds[inl_idx].ull_value > 0L) &&
           (dsrl_wallis_rounds[inl_idx].ull_value < (MIN_PI_ROUNDS / 100)))
       {
         ill_pi_val = 0L;
         break;
       }
     }
   }
   // test the returned data and determine an estimated entropy value
   if (ill_pi_val > 0L)
   {
     fdl_val2 = 0.0;
     dsrl_wallis_rounds[4].ull_value = (dsrl_wallis_rounds[0].ull_value + dsrl_wallis_rounds[1].ull_value + 
                                        dsrl_wallis_rounds[2].ull_value + dsrl_wallis_rounds[3].ull_value);
     if (dsrl_wallis_rounds[4].ds_split.um_high > 0)
        fdl_val1 = 13.0;
     else
     {
       uml_val = dsrl_wallis_rounds[4].ds_split.um_low;
       if (uml_val > MIN_PI_ROUNDS)
          fdl_val1 = 13.0;
       else if (uml_val > MIN_PI_ROUNDS * 3 / 4)
          fdl_val1 = 9.75;
       else if (uml_val > MIN_PI_ROUNDS / 2)
          fdl_val1 = 6.5;
       else if (uml_val > MIN_PI_ROUNDS / 4)
          fdl_val1 = 3.25;
       else
          fdl_val1 = 0.0;
     }
     if (dsrl_wallis_rounds[3].ull_value > 0LL)
        uml_val = 4;
     else if (dsrl_wallis_rounds[2].ull_value > 0LL)
        uml_val = 3;
     else if (dsrl_wallis_rounds[1].ull_value > 0LL)
        uml_val = 2;
     else
        uml_val = 1;
     //
     // calculate the final entropy estimation sum and add values
     for (inl_idx = 0; inl_idx < 4; inl_idx++)
     {
       if (dsrl_wallis_rounds[inl_idx].ull_value > (MIN_PI_ROUNDS / uml_val))
          fdl_val2 += (double)(fdl_val1 / uml_val);
       else if (dsrl_wallis_rounds[inl_idx].ull_value > (MIN_PI_ROUNDS / (uml_val * 2)))
          fdl_val2 += (double)(fdl_val1 / (uml_val * 2));
       //
       // add the return values of Wallis rounds to the hash pool
       if (dsrl_wallis_rounds[inl_idx].ull_value > 0LL)
       {
         SHA256_Update(ShaArray,(char*)(&(dsrl_wallis_rounds[inl_idx].ull_value)),0,sizeof(split_long_t));
         inl_byteshashed += sizeof(split_long_t);
       }
     }

     if ((ill_pi_val >= 3133000L) && (ill_pi_val <= 3150000)){
        // Add entropy from Wallis Product only, if it is within the bounds.
        fll_entropest += (float)fdl_val2;
        inl_totalpercentage += (int)fdl_val2;
     }
   } // end of if (ill_pi_val > 0L)
   // clear the returned data
   SecClearByteArray((char*)dsrl_wallis_rounds, (5 * sizeof(split_long_t)));
   //
   // do the processing to get the system time information after Wallis
   inl_retcode = m_get_system_times(&dsl_idletime2, &dsl_kerneltime2, &dsl_usertime2);

   // do the processing to get rusage information after Wallis
   inl_retcode = 0;
   if (auml_ulng_buf != NULL)
   {
     memset(auml_ulng_buf, 0, uml_val);
     uml_unsitmp = 0;
     inl_retcode = m_get_clock_rusage((&(auml_ulng_buf[0])), &uml_unsitmp, uml_val);

     if (inl_retcode > 0)
     {
       SHA256_Update(ShaArray,(char*)auml_ulng_buf,0,uml_unsitmp);
       inl_byteshashed += (int)uml_unsitmp;
       inl_totalpercentage += 3;
       ;
     }
   }
//
#if !defined HL_SOLARIS
   SHA256_Update(ShaArray,(char*)(&dsl_idletime1),0,sizeof(split_long_t));
   SHA256_Update(ShaArray,(char*)(&dsl_kerneltime1),0,sizeof(split_long_t));
   SHA256_Update(ShaArray,(char*)(&dsl_usertime1),0,sizeof(split_long_t));
   SHA256_Update(ShaArray,(char*)(&dsl_idletime2),0,sizeof(split_long_t));
   SHA256_Update(ShaArray,(char*)(&dsl_kerneltime2),0,sizeof(split_long_t));
   SHA256_Update(ShaArray,(char*)(&dsl_usertime2),0,sizeof(split_long_t));
   ;
   inl_byteshashed += (sizeof(split_long_t) * 6);
   inl_totalpercentage += 3;
#endif  // !HL_SOLARIS

   if (auml_ulng_buf != NULL)
   {
     FREE_ARRAY(HMEM_CTX_REF, auml_ulng_buf);
     auml_ulng_buf = NULL;
   }
#if defined HL_SOLARIS
   // read from PROC and collect create/access/write time and file-length
   m_print_dir(PROC_PATH, 0x00080000, ShaArray, &inl_byteshashed);
   ;
   inl_totalpercentage += 3;
#endif  // !HL_SOLARIS
   //---------------------------------------------------------------
   // 1d. Add the performance counter value after processing item 4.
   //---------------------------------------------------------------
   if (m_get_high_resolutime(&ill_val64) >= 0)
   {
     ulrl_perfcountbuf[3] = ill_val64;
     ulrl_tsc_buf[3] = m_get_tsc();
     Sleep(2);  // wait for 2 msec
   }
   else
   {
     SHA256_Update(ShaArray,(char*)(&ill_val64),0,sizeof(long long));
     inl_byteshashed += sizeof(long long);
   }
   // -------------------------------------------------------------------------
   // 5. fetch information with statvfs, read values from /proc/meminfo on 
   //    Linux OSs, get information from results calling one or more of the 
   //    following command 'ipcs', 'vmstat', 'prtconf', 'swap', 'prstat', 
   //    'getconf xxx', 'lsattr', 'lscfg' that depend on the OS the program 
   //    is running on.
   // -------------------------------------------------------------------------
   // a file in the path to the current working directory is needed for 'statvfs'
   errno = 0;
   achl_fnametmp = NULL;
   achl_curprocpath = NULL;
   uml_val = (PATH_MAX + FILENAME_MAX);
   ill_longval = pathconf("/", _PC_PATH_MAX);
   if ((ill_longval < 0L) && (errno == 0))
   // not defined
      uml_unsitmp = INT_PATH_FILENAME_LIMIT + 64;
   else
      uml_unsitmp = (((unsigned int)((int)ill_longval)) + 64);
   if (uml_unsitmp < uml_val)
      uml_unsitmp = uml_val;
   inl2 = 0;
   achl_curprocpath = (char *)BIT8_ARRAY_ALLOC(HMEM_CTX_REF, (uml_unsitmp * sizeof(char)));
   if (achl_curprocpath == NULL)
   {
     uml_funresult = errno;
   }
   else
   {
     if (getcwd(achl_curprocpath, (uml_unsitmp - 2)) == NULL)
     {
       uml_funresult = errno;
     }
     else
     {
       inl_len = strlen(achl_curprocpath);
       if (inl_len > 0)
       {
         achl_fnametmp = (char *)BIT8_ARRAY_ALLOC(HMEM_CTX_REF, ((uml_val + 1) * sizeof(char)));
         if (achl_fnametmp == NULL)
         {
           uml_funresult = errno;
         }
         else
         {
           inl2 = m_getfnfromcwd(achl_curprocpath, achl_fnametmp, uml_val);
           if (inl2 > 0)
           {
             strcat(achl_curprocpath, "/");
             if (((unsigned int)(inl_len + inl2)) < (uml_unsitmp - 2))
                strncat(achl_curprocpath, achl_fnametmp, (uml_unsitmp - ((unsigned int)(inl_len + 1))));
             else
                inl2 = 0;
           }
         }
       }
     } // end of else if (getcwd(achl_curprocpath, (uml_unsitmp - 2)) == NULL)

     if (achl_fnametmp != NULL)
     {
       FREE_ARRAY(HMEM_CTX_REF, achl_fnametmp);
       achl_fnametmp = NULL;
     }

     if (inl2 > 0)
     {
#ifndef HL_ANDROID
       // The statvfs() function returns a "generic superblock" describing 
       // a file system; it can be used to acquire information about mounted 
       // file systems. The buf argument is a pointer to a statvfs structure 
       // that is filled by the function.
       if (statvfs(achl_curprocpath, &dsl_stvfsbuf) == 0)
       {
         SHA256_Update(ShaArray,(char*)(&dsl_stvfsbuf),0,sizeof(struct statvfs));
         ;
         inl_byteshashed += sizeof(struct statvfs);
         inl_totalpercentage += 3;
       }
#else
       // The statfs() function returns information about a mounted file 
       // system. It requires the path name of any file within the mounted 
       // filesystem. The buf argument is a pointer to a statfs structure 
       // that is filled by the function.
       if (statfs(achl_curprocpath, &dsl_stvfsbuf) == 0)
       {
         SHA256_Update(ShaArray,(char*)(&dsl_stvfsbuf),0,sizeof(struct statfs));
         ;
         inl_byteshashed += sizeof(struct statfs);
         inl_totalpercentage += 3;
       }
#endif  // HL_ANDROID
     }

     if (achl_curprocpath != NULL)
     {
       FREE_ARRAY(HMEM_CTX_REF, achl_curprocpath);
       achl_curprocpath = NULL;
     }
   } // end of else if (achl_curprocpath == NULL)
//
#if defined HL_LINUX
   // read out (32) values from /proc/meminfo
   inl_retcode = m_get_proc_file(PROC_PATH, "meminfo", 0x01, ShaArray, &inl_byteshashed);
   if (inl_retcode > 0)
      inl_totalpercentage += 4;
#endif  // HL_LINUX

   // process 'achr_commands_mcp' commands

   for (inl_idx = 0; 
        inl_idx < (int)(sizeof(achr_commands_mcp) / sizeof(achr_commands_mcp[0])); 
        ++inl_idx)
   {
     inl_retcode = m_execute_command(achr_commands_mcp[inl_idx], chrl_delim_1, 0, NULL, 0, 
                                     ShaArray, &inl_byteshashed);
     if (inl_retcode < 0)
     {
       uml_funresult = errno;
     }
     else
     {
       inl_totalpercentage += 5;
     }
   } // end of (inl_idx = 0; inl_idx < (sizeof(...)); ++inl_idx)
   //---------------------------------------------------------------
   // 1e. Add the performance counter value after processing item 5.
   //---------------------------------------------------------------
   if (m_get_high_resolutime(&ill_val64) >= 0)
   {
     ulrl_perfcountbuf[4] = ill_val64;
     ulrl_tsc_buf[4] = m_get_tsc();
     Sleep(2);  // wait for 2 msec
   }
   else
   {
     SHA256_Update(ShaArray,(char*)(&ill_val64),0,sizeof(long long));
     inl_byteshashed += sizeof(long long);
   }
   // -------------------------------------------------------------------------
   // 6. get Event and Logging file information
   // -------------------------------------------------------------------------
   // read from VAR and collect create/access/write time and file-length
   m_print_dir(VAR_PATH, 0x00080000, ShaArray, &inl_byteshashed);
   inl_totalpercentage += 12;
   //---------------------------------------------------------------
   // 1f. Add the performance counter value after processing item 6.
   //---------------------------------------------------------------
   if (m_get_high_resolutime(&ill_val64) >= 0)
   {
     ulrl_perfcountbuf[5] = ill_val64;
     ulrl_tsc_buf[5] = m_get_tsc();
     Sleep(2);  // wait for 2 msec
   }
   else
   {
     SHA256_Update(ShaArray,(char*)(&ill_val64),0,sizeof(long long));
     inl_byteshashed += sizeof(long long);
   }
   // -------------------------------------------------------------------------
   // 7. get bytes from /dev/random and /dev/urandom
   //    - fetch 3 (or 4)Bytes from /dev/random (if possible on OS) and
   //      21 (or 20) Bytes from /dev/urandom in 2 separate access cycles
   //      to increase the variance of the delta time; if /dev/random is 
   //      not available, 24 bytes are fetched from /dev/urandom
   // -------------------------------------------------------------------------
   // determine the number of /dev/random bytes to fetch
   uml_val = 3;
   if (fll_entropest <= 5.0)
      uml_val++;
   // bytes from /dev/random and /dev/urandom
   inl_devrnd_value = m_hashdevrandom(ShaArray, uml_val, &inl_byteshashed);
   if (inl_devrnd_value >= 0)  // contains the number of bytes read from /dev/random
   {
#if defined HL_LINUX_ARM
     if (inl_devrnd_value == 0)
        inl_devrnd_value = (RANDBUFSIZE / 8);  // fake a 3 (= 24 / 8) for the ARM processor in the privacy cube
#endif  // HL_LINUX_ARM
     inl_totalpercentage += (inl_devrnd_value * 8);
     fll_entropest += (inl_devrnd_value * 8.0F);
   }
   else
   {
     SHA256_Update(ShaArray,(char*)(&inl_devrnd_value),0,sizeof(int));
     inl_byteshashed += sizeof(int);
   }
   //---------------------------------------------------------------
   // 1g. Add the performance counter value after processing item 7.
   //---------------------------------------------------------------
   if (m_get_high_resolutime(&ill_val64) >= 0)
   {
     ulrl_perfcountbuf[6] = ill_val64;
     ulrl_tsc_buf[6] = m_get_tsc();
     Sleep(2);  // wait for 2 msec
   }
   else
   {
     SHA256_Update(ShaArray,(char*)(&ill_val64),0,sizeof(long long));
     inl_byteshashed += sizeof(long long);
   }
   // -------------------------------------------------------------------------
   // 8. get network information by calling netstat
   // -------------------------------------------------------------------------

   for (inl_idx = 0; 
        inl_idx < (int)(sizeof(achr_commands_net) / sizeof(achr_commands_net[0])); 
        ++inl_idx)
   {
     inl_retcode = m_execute_command(achr_commands_net[inl_idx], chrl_delim_1, 0, NULL, 0, 
                                     ShaArray, &inl_byteshashed);
     if (inl_retcode < 0)
     {
       uml_funresult = errno;
     }
     else
     {
       inl_totalpercentage += (((inl_retcode >> 5) < 24) ? (inl_retcode >> 5) : 24);
     }
   } // end of (inl_idx = 0; inl_idx < (sizeof(...)); ++inl_idx)
   ;
   //---------------------------------------------------------------
   // 1h. Add the performance counter value after processing item 8.
   //---------------------------------------------------------------
   if (m_get_high_resolutime(&ill_val64) >= 0)
   {
     ulrl_perfcountbuf[7] = ill_val64;
     ulrl_tsc_buf[7] = m_get_tsc();
   }
   else
   {
     SHA256_Update(ShaArray,(char*)(&ill_val64),0,sizeof(long long));
     inl_byteshashed += sizeof(long long);
   }
   ;
   //----------------------------------------------------------------
   // Hash the performance counter values and test the collected data
   //----------------------------------------------------------------
   SHA256_Update(ShaArray,(char*)(&(ulrl_perfcountbuf[0])),0,(sizeof(long long) * PERFCOUNTBUFLEN));
   SHA256_Update(ShaArray,(char*)(&(ulrl_tsc_buf[0])),0,(sizeof(long long) * PERFCOUNTBUFLEN));
   inl_byteshashed += (sizeof(long long) * PERFCOUNTBUFLEN);
   //
   // test the collected OS-API time data and determine an estimated entropy value
   // perform simple tests to assure the entropy and reduce entropy per value accordingly
   for (inl_idx = 0; inl_idx < 20; inl_idx++)
      byrl_tmpdata[inl_idx] = 0x00;
   fdl_val2 = 3.2;
   if (PERFCOUNTBUFLEN < 31)  // safety check
   {
       // We make entropy estimations for both the counters based on m_get_high_resolutime() and m_get_tsc()
       double fdl_entropy_perf_cnt = m_get_entropy_est(ulrl_perfcountbuf);
       double fdl_entropy_timestamp = m_get_entropy_est((long long*)ulrl_tsc_buf);

       // We use the better entropy value. Using the sum would not work, as the two are very likely correlated.
       if(fdl_entropy_perf_cnt > fdl_entropy_timestamp){
           fdl_val2 = fdl_entropy_perf_cnt;
       } else {
           fdl_val2 = fdl_entropy_timestamp;
       }
   } // end of if (PERFCOUNTBUFLEN < 31) => safety check

   // check the performance counter values
   for (inl_idx = 0, uml_unsitmp = 0; inl_idx < (PERFCOUNTBUFLEN - 1); inl_idx++)
   {
     ill_val64 = (ulrl_perfcountbuf[inl_idx + 1] - ulrl_perfcountbuf[inl_idx]);
     if (ill_val64 > 2000000L)
     {
       uml_unsitmp++;
       inl_totalpercentage += 3;
       // add the determined amount of entropy for every proper OS-API-time
       fll_entropest += (float)fdl_val2;
     }
   }
   if (((unsigned long long)ulrl_perfcountbuf[0]) > 0xFFFFL)
   {
     inl_totalpercentage += 1;
     uml_unsitmp++;
   }
   
   //----------------------------------------------------------------
   // Add entropy from random CAS
   //----------------------------------------------------------------
   ms_add_cas_random(ShaArray, inl_byteshashed, inl_totalpercentage, fll_entropest);

   m_entropy_out(fll_entropest);
   // test the qualified entropy sources
   inl_retcode = inl_totalpercentage;
   // the entropy estimation must sum up to 50 bits or more
   if (fll_entropest < 50.0F)
   {
#if defined XH_INTERFACE
       PrintAux(HMEM_CTX_REF1 "SECDRBG: entropy estimation insufficient, value = %f\n", fll_entropest);
#endif   // XH_INTERFACE
     inl_retcode = DRBG_SEC_INIT_FAILED;
   }
   
   //----------------------------------------------------------
   // Clear data arrays
   //----------------------------------------------------------
   m_sec_zero_mem(ulrl_perfcountbuf, (PERFCOUNTBUFLEN*sizeof(long long)));
   m_sec_zero_mem(ulrl_tsc_buf, (PERFCOUNTBUFLEN*sizeof(long long)));
   m_sec_zero_mem(byrl_tmpdata, 255);
   //----------------------------------------------------------
   // Create the final hash value and return all necessary data
   //----------------------------------------------------------
   SHA256_Final(ShaArray,abyp_pdigest,0);
   ainp_byteshashed[0] = inl_byteshashed;
   return(inl_retcode);
}  // end of int SysGetEntropy(...)
//
#endif // UNIX only  (=> else WIN32 || WIN64)

//
extern "C"  int m_add_qualified_seed_impl(HMEM_CTX_DEF int imp_init, const char * achp_caller_func_name)
{
   int iml_retcode;
   int iml_byteshashed;
   char byrl_entropydata[32];
#ifdef ALT_SEEDING_SOURCE
   BOOL bol_auxret;
#endif // ALT_SEEDING_SOURCE

#if !defined ALT_SEEDING_SOURCE || !defined XH_INTERFACE
   iml_retcode = SecRandStruc.amc_get_entropy(HMEM_CTX_REF1 byrl_entropydata, &iml_byteshashed);
#if defined XH_INTERFACE || defined HL_ANDROID
   if (achp_caller_func_name != NULL)
      PrintAux(HMEM_CTX_REF1 "SECDRBG - %s: Confirmation coefficient in method A: %d\n", 
               achp_caller_func_name, iml_retcode);
#else
#endif // XH_INTERFACE && HL_ANDROID

   // check error condition
   if (iml_retcode <= 0)
   {
     if (imp_init == 0)
        return(DRBG_SEC_RESEED_FAILED);
     else
        return(DRBG_SEC_INIT_FAILED);
   }
   // check returned quality parameters
   if (iml_retcode < CONF_COEF_LIMIT)
   {
     if (imp_init == 0)
        return(DRBG_SEC_RESEED_FAILED);
     else
        return(DRBG_SEC_INIT_FAILED);
   }
   if (iml_byteshashed < HASH_LIMIT)
      return(DRBG_SEC_HASH_WEAK);
#else
   // get seed data from a seeder daemon
   bol_auxret = vp__ctx->am__aux2(vp__ctx->vp__context, DEF_AUX_SECURE_SEED,
                                  (void *)(&(byrl_entropydata[0])), 32);
   if (bol_auxret == FALSE)
   {
     PrintAux(HMEM_CTX_REF1 "SECDRBG - %s: Retrieving seed material from seeder process failed.\n",
              achp_caller_func_name);
     return(DRBG_SEC_INIT_FAILED);
   }
   else
   {
#if defined DEBUG || defined _DEBUG
      PrintAux(HMEM_CTX_REF1 "SECDRBG - %s: Seed material from seeder process ok.\n",
               achp_caller_func_name);
#endif  // defined DEBUG || defined _DEBUG
      iml_retcode = (CONF_COEF_LIMIT + 1);
   }
#endif  // !defined ALT_SEEDING_SOURCE || !defined XH_INTERFACE

   // pass entropy to generator
   if (imp_init == 0)
      // reseeding with entropy
      CTR_DRBG_Reseed128(&SecRandStruc, byrl_entropydata);
   else
      // instantiation with entropy 
      CTR_DRBG_Instantiate128(&SecRandStruc, byrl_entropydata);
   // clear the entropy byte array
   SecClearByteArray(byrl_entropydata, 32);

   return(iml_retcode);
}  // end of static int m_add_qualified_seed_impl(...)

//
extern "C"  int m_add_qualified_seed(HMEM_CTX_DEF int imp_init, const char * achp_caller_func_name)
{
   int iml_retcode;
   dss_critsect.m_enter();
   iml_retcode = m_add_qualified_seed_impl(HMEM_CTX_REF1 imp_init, achp_caller_func_name);
   dss_critsect.m_leave();
   return(iml_retcode);
}  // end of static int m_add_qualified_seed(...)

//
/**
* SecDrbgInit_impl - Initialize the secure random generator.
* <br><br>
* Fetch 32 bytes entropy from the system, initialize structure
* and set global initialized flag.
*
*
*  @return int state 
*  <br>         > 0 o.k.
*  <br>         <= 0 fetch entropy failed
*/
static  int SecDrbgInit_impl(HMEM_CTX_DEF1)
{
   int inl_retcode;

   if (SecRandInitFlag != 0)
      return(100);

   //------------------------------------------------
   // 1. Perform DRBG selfcheck
   //------------------------------------------------
   inl_retcode = CTR_DRBG_Test();
   if (inl_retcode != 0)
      return(DRBG_SEC_TEST_FAILED);


   //---------------------------------------------------
   // 2. Fetch entropy according to system in use,
   //    check percentage estimate returned
   // 3.a) Initialize the DRBG with the seed data
   //---------------------------------------------------
   inl_retcode = m_add_qualified_seed_impl(HMEM_CTX_REF1 1, "SecDrbgInit");
   if (inl_retcode <= 0)
      return(inl_retcode);

    //------------------------------------------------
   // 3.b) Set the DRBG initialization flag now
   //------------------------------------------------
   SecRandInitFlag = 1;
   return(inl_retcode);
}  // end of PUBLIC STATIC int SecDrbgInit_impl()
//

/**
* SecDrbgInit - Initialize the secure random generator.
* <br><br>
* Fetch 32 bytes entropy from the system, initialize structure
* and set global initialized flag.
*
* This function is thread-safe. It is implemented by SecDrbgInit_impl.
*
*  @return int state 
*  <br>         > 0 o.k.
*  <br>         <= 0 fetch entropy failed
*/
extern "C"  int SecDrbgInit(HMEM_CTX_DEF1)
{
   int inl_ret = 0;
   dss_critsect.m_enter();
   inl_ret = SecDrbgInit_impl(HMEM_CTX_REF);
   dss_critsect.m_leave();
   return inl_ret;
}

//
/**
* SecDrbgRandBytes_impl - Get random data output.
* <br><br>
* Fetch random bytes from secure random generator. 
* If reseed is required, fetch 32 byte entropy from 
* system and reseed the generator.
*
* 
*  @param ainp_pdstbuf Destination for output
*  @param inp_dstoff start of data in buffer
*  @param inp_dstlen size of data requested
*  @return int state 
*  <br>         == 0 o.k.
*  <br>         < 0 fetch entropy failed/DRBG not initialized
*/
static  int SecDrbgRandBytes_impl(HMEM_CTX_DEF char* ainp_pdstbuf,
                                        int inp_dstoff, int inp_dstlen)
{
   int inl_retcode;

   //----------------------------------------
   // 0. Check if generator is initialized
   //----------------------------------------
   if (SecRandInitFlag == 0)
      return(DRBG_SEC_RAND_FAILED);

   //----------------------------------------
   // 1. Get bytes as requested, check result
   //----------------------------------------
   inl_retcode = DRBGGetRandBytes(&SecRandStruc, 
                                  ainp_pdstbuf, inp_dstoff, inp_dstlen, 0);
   if (inl_retcode == 0)
      return(inl_retcode);

   if (inl_retcode != 2)
      return(DRBG_SEC_RAND_FAILED);
   //----------------------------------------------------------
   // 2. DRBG needs reseeding, fetch entropy for reseed, reseed
   //----------------------------------------------------------
   inl_retcode = CTR_DRBG_Test();
   if (inl_retcode != 0)
   {
     m_drbg_change_crng_flags(&SecRandStruc, 0, 0x01);	 // set to not initialized
     return(DRBG_SEC_TEST_FAILED);
   }
   SecRandStruc.Ck = 1;

   // call system entropy gathering function, test result and reseed if ok
   inl_retcode = m_add_qualified_seed_impl(HMEM_CTX_REF1 0, "SecDrbgRandBytes");
   if (inl_retcode <= 0)
      return(inl_retcode);

   //-------------------------------------------
   // 3. Retry random bytes fetch
   //-------------------------------------------
   inl_retcode = DRBGGetRandBytes(&SecRandStruc, 
                                  ainp_pdstbuf, inp_dstoff, inp_dstlen, 0);
   if (inl_retcode != 0)
      return(DRBG_SEC_RAND_FAILED);
   return(0);
}  // end of PUBLIC STATIC int SecDrbgRandBytes_impl(...)
//

/**
* SecDrbgRandBytes - Get random data output.
* <br><br>
* Fetch random bytes from secure random generator. 
* If reseed is required, fetch 32 byte entropy from 
* system and reseed the generator.
*
* This function is thread-safe. It is implemented by SecDrbgRandBytes.
* 
*  @param ainp_pdstbuf Destination for output
*  @param inp_dstoff start of data in buffer
*  @param inp_dstlen size of data requested
*  @return int state 
*  <br>         == 0 o.k.
*  <br>         < 0 fetch entropy failed/DRBG not initialized
*/
extern "C"  int SecDrbgRandBytes(HMEM_CTX_DEF char* ainp_pdstbuf,
                                        int inp_dstoff, int inp_dstlen)
{
   int inl_ret = 0;
   dss_critsect.m_enter();
   inl_ret = SecDrbgRandBytes_impl(HMEM_CTX_REF1 ainp_pdstbuf, inp_dstoff, 
      inp_dstlen);
   dss_critsect.m_leave();
   return inl_ret;
}

/**
* m_ssl_seed_rng_impl  <br>
* This function is to be used to initialize the random generator and 
* the seed gathering before the and independently from the HOBLink 
* Secure SSL Initialize function.
*
* 
*  @param abyrp_dstbuf Destination for output
*  @param imp_dstlen Size of data requested
*  @return bool state  
*  <br>        true o.k.
*  <br>        false fetch Entropy failed/DRBG not initialized
*/
static BOOL m_ssl_seed_rng_impl()
{
   int iml_retcode;
//
#if defined XH_INTERFACE
   ds__hmem * vp__ctx = m_get_mem_context();
#endif
   //------------------------------------------
   // Test whether DRBG is already initialized
   //------------------------------------------
   if (SecRandInitFlag != 0)
      iml_retcode = 127;
   else
   {
#if defined XH_INTERFACE
     PrintAux(HMEM_CTX_REF1 "SECDRBG: Initialization starts now! (m_ssl_seed_rng_impl called)\n");
#endif   // XH_INTERFACE

     iml_retcode = SecDrbgInit_impl(HMEM_CTX_REF);
     if (iml_retcode <= 0)
        iml_retcode = DRBG_SEC_RAND_FAILED;
   }
#if defined XH_INTERFACE
   PrintAux(HMEM_CTX_REF1 "SECDRBG: m_ssl_seed_rng_impl state value = %d.\n, iml_retcode");
#endif   // XH_INTERFACE
   if (iml_retcode >= 0)
      return(TRUE);
   else
      return(FALSE);
}  // end of int m_ssl_seed_rng_impl()

/**
* m_ssl_seed_rng_impl  <br>
* This function is to be used to initialize the random generator and 
* the seed gathering before the and independently from the HOBLink 
* Secure SSL Initialize function.
*
* This function is thread-safe. It is implemented by m_ssl_seed_rng_impl.
*
*  @param abyrp_dstbuf Destination for output
*  @param imp_dstlen Size of data requested
*  @return bool state  
*  <br>        true o.k.
*  <br>        false fetch Entropy failed/DRBG not initialized
*/
BOOL m_ssl_seed_rng(){
   BOOL bol_ret = 0;
   dss_critsect.m_enter();
   bol_ret = m_ssl_seed_rng_impl();
   dss_critsect.m_leave();
   return bol_ret;
}

/**
* m_secdrbg_randbytes_impl  <br>
* Fetch random bytes from secure random generator and 
* seed or reseed the generator if required.
*
* 
*  @param abyrp_dstbuf Destination for output
*  @param imp_dstlen Size of data requested
*  @return int state  
*  <br>        == 0 o.k.
*  <br>        != 0 fetch Entropy failed/DRBG not initialized
*/
static int m_secdrbg_randbytes_impl(char * abyrp_dstbuf, int imp_dstlen)
{
   int iml_retcode;

#if defined XH_INTERFACE
   ds__hmem * vp__ctx = m_get_mem_context();
#endif
   //----------------------------------------
   // 0. Check if generator is initialized
   //----------------------------------------
   if (SecRandInitFlag == 0)
   {
     iml_retcode = SecDrbgInit_impl(HMEM_CTX_REF);
     if (iml_retcode <= 0)
        return(DRBG_SEC_RAND_FAILED);
   }
   //----------------------------------------
   // 1. Get bytes as requested, check result
   //----------------------------------------
   iml_retcode = DRBGGetRandBytes(&SecRandStruc,
                                  abyrp_dstbuf, 0, imp_dstlen, 0);
   if (iml_retcode == 0)
      return(iml_retcode);

   if (iml_retcode != 2)
      return(DRBG_SEC_RAND_FAILED);
   //----------------------------------------------------------
   // 2. DRBG needs reseeding, fetch entropy for reseed, reseed
   //----------------------------------------------------------
   iml_retcode = CTR_DRBG_Test();
   if (iml_retcode != 0)
   {
     m_drbg_change_crng_flags(&SecRandStruc, 0, 0x01);	 // set to not initialized
     return(DRBG_SEC_TEST_FAILED);
   }
   SecRandStruc.Ck = 1;

   iml_retcode = m_add_qualified_seed_impl(HMEM_CTX_REF1 0, NULL);
   if (iml_retcode <= 0)
      return(iml_retcode);
   //-------------------------------------------
   // 3. Retry random bytes fetch
   //-------------------------------------------
   iml_retcode = DRBGGetRandBytes(&SecRandStruc,
                                  abyrp_dstbuf, 0, imp_dstlen, 0);
   if (iml_retcode != 0)
      return(DRBG_SEC_RAND_FAILED);
   return(0);
}  // end of int m_secdrbg_randbytes_impl(...)

/**
* m_secdrbg_randbytes  <br>
* Fetch random bytes from secure random generator and 
* seed or reseed the generator if required.
*
* This function is thread-safe. It is implemented by m_secdrbg_randbytes_impl.
*
*  @param abyrp_dstbuf Destination for output
*  @param imp_dstlen Size of data requested
*  @return int state  
*  <br>        == 0 o.k.
*  <br>        != 0 fetch Entropy failed/DRBG not initialized
*/
extern "C" int m_secdrbg_randbytes(char * abyrp_dstbuf, int imp_dstlen)
{
   int inl_ret = 0;
   dss_critsect.m_enter();
   inl_ret = m_secdrbg_randbytes_impl(abyrp_dstbuf, imp_dstlen);
   dss_critsect.m_leave();
   return inl_ret;
}

//
/**
* SecDrbgRandBytes_Test_impl
* Fetch random bytes from secure random generator without 
* reseed checking or update. 
* This function/method is for testing purposes only !!!
*
* 
*  @param ainp_pdstbuf Destination for output
*  @param inp_dstoff Start of data in buffer
*  @param inp_dstlen Size of data requested
*  @return int state 
*  <br>            == 0 o.k.
*  <br>            != 0 fetch entropy failed/
*                       DRBG not initialized
*/
static int SecDrbgRandBytes_Test_impl(char* ainp_pdstbuf,
                                      int inp_dstoff,
                                      int inp_dstlen)
{
   int iml_retcode;

   //----------------------------------------
   // 0. Check if generator is initialized
   //----------------------------------------
   if (SecRandInitFlag == 0)
      return(DRBG_SEC_RAND_FAILED);

   printf("Warning: PRNG without reseeding used!\n");

   //-----------------------------------------
   // 1. Get bytes as requested, return result
   //-----------------------------------------
   iml_retcode = DRBGGetRandBytes(&SecRandStruc, 
                                  ainp_pdstbuf, inp_dstoff, inp_dstlen, 1);
   return(iml_retcode);
}  // end of PUBLIC STATIC int SecDrbgRandBytes_Test_impl(...)
//
/**
* SecDrbgRandBytes_Test
* Fetch random bytes from secure random generator without 
* reseed checking or update. 
* This function/method is for testing purposes only !!!
*
* This function is thread-safe. It is implemented by SecDrbgRandBytes_Test_impl.
*
*  @param ainp_pdstbuf Destination for output
*  @param inp_dstoff Start of data in buffer
*  @param inp_dstlen Size of data requested
*  @return int state 
*  <br>            == 0 o.k.
*  <br>            != 0 fetch entropy failed/
*                       DRBG not initialized
*/
extern "C"  int SecDrbgRandBytes_Test(HMEM_CTX_DEF char* ainp_pdstbuf,
					     int inp_dstoff, int inp_dstlen)
{
   int inl_ret = 0;
   dss_critsect.m_enter();
   inl_ret = SecDrbgRandBytes_Test_impl(ainp_pdstbuf, inp_dstoff, inp_dstlen);
   dss_critsect.m_leave();
   return inl_ret;
}

//
/**
* CTR_DRBG_AddSeed256_impl - Add extra entropy data.
* <br><br>
* Adds given entropy to DRBG, hashes Input data and 
* updates the DRBG Key and Count.  <br>
* The reseed counter stays unaffected. The passed data 
* array must be cleared after calling this function !!  <br>
* -- Windows and Linux/UNIX Version --
*
* 
*  @param abyrp_newentropy  entropy input
*  @param imp_entropylen  size of input
*  @return int state - 0 o.k., else error occurred
*/
static  int  CTR_DRBG_AddSeed256_impl(char* abyrp_newentropy,
                                      int imp_entropylen)
{
   char DigestBuf[32];
   char SeedMaterial[32];
   int ShaArray[SHA256_ARRAY_SIZE];

   //---------------------------------------------
   // Check parameters
   //---------------------------------------------
   if ((abyrp_newentropy == NULL) || (imp_entropylen <= 0))
      return(-1);
   if (SecRandInitFlag == 0)
      return(DRBG_SEC_RAND_FAILED);

   SHA256_Init(ShaArray);
   SHA256_Update(ShaArray,abyrp_newentropy,0,imp_entropylen);
   SHA256_Final(ShaArray,DigestBuf,0);
   //-------------------------------------------------
   // Preprocess entropy using the Derivation function
   //-------------------------------------------------
   BlockCipherDf_AES128(DigestBuf, SeedMaterial);
   SecClearByteArray(DigestBuf,32);
   //-------------------------------------------------
   // Update the key and counter states
   //-------------------------------------------------
   CTR_DRBG_Update128(&SecRandStruc, SeedMaterial);
   SecClearByteArray(SeedMaterial,32);
   return(0);
} // end of CTR_DRBG_AddSeed256_impl(...)

/**
* CTR_DRBG_AddSeed256 - Add extra entropy data.
* <br><br>
* Adds given entropy to DRBG, hashes Input data and 
* updates the DRBG Key and Count.  <br>
* The reseed counter stays unaffected. The passed data 
* array must be cleared after calling this function !!  <br>
*
* This function is thread-safe. it is implemented by CTR_DRBG_AddSeed256_impl.
* 
*  @param abyrp_newentropy  entropy input
*  @param imp_entropylen  size of input
*  @return int state - 0 o.k., else error occurred
*/
extern "C"  int  CTR_DRBG_AddSeed256(char* abyrp_newentropy,
                                     int imp_entropylen)
{
   int inl_ret = 0;
   dss_critsect.m_enter();
   inl_ret = CTR_DRBG_AddSeed256_impl(abyrp_newentropy, imp_entropylen);
   dss_critsect.m_leave();
   return inl_ret;
}

#ifdef XH_INTERFACE
/**
Fetches entropy, using the aux function from the memory manager structure.

If the structure is the static memory context of the DRBG, the call is delegated 
to SysGetEntropy.
*/
static int m_aux_get_entropy(HMEM_CTX_DEF
                             char* abyp_pdigest,
                             int* ainp_byteshashed)
{

    if(HMEM_CTX_REF == m_get_mem_context()){
        // We have a call with the static memory context, fall back to standard function
        return SysGetEntropy(HMEM_CTX_REF1 abyp_pdigest, ainp_byteshashed);
    }

    // get seed data from the aux seeding function
    BOOL bol_auxret = vp__ctx->am__aux2(vp__ctx->vp__context,
                                        DEF_AUX_SECURE_SEED,
                                        (void *)(abyp_pdigest),
                                        32);
    if (bol_auxret == FALSE)
    {
        return(DRBG_SEC_INIT_FAILED);
    }

    // We simulate sufficient hash and coefficients
    *ainp_byteshashed = HASH_LIMIT+1;
    return (CONF_COEF_LIMIT + 1);
}

extern "C" int m_init_random_aux(BOOL (* amp_aux)(void * vp__p_ctx,
                                                  int in__funct,
                                                  void * vp__p_mem,
                                                  int  in__size),
                                 void* avop_user_field)
{
    dss_critsect.m_enter();
    if(SecRandInitFlag == 0) {
        SecRandStruc.amc_get_entropy = m_aux_get_entropy;
    }
    ds__hmem dsl_memory = m_make_mem_struct(amp_aux, avop_user_field, 0);
    int inl_ret = SecDrbgInit_impl(&dsl_memory);
    if(SecRandInitFlag == 0) {
        // DRBG still not initialized, return to default seeder
        SecRandStruc.amc_get_entropy = SysGetEntropy;
    }
    dss_critsect.m_leave();
    return inl_ret;
}

#endif

/** @} */


#endif //HL_ENCR_RAND
// end of file ../RAND/rn2.cpp


#ifdef HL_ENCR_RAND
/*+-------------------------------------------------------------------+*/
/*|                                                                   |*/
/*| PROGRAM NAME: xs-ari-entropy-01.cpp                               |*/
/*| -------------                                                     |*/
/*|  created 30.12.16 KB                                              |*/
/*|  Subroutine arithmetic compression to generate bits with entropy  |*/
/*|  derived from xs-cdf-arithm-01.cpp                                |*/
/*|                                                                   |*/
/*| COPYRIGHT:                                                        |*/
/*| ----------                                                        |*/
/*|  Copyright (C) HOB Germany 2016                                   |*/
/*|                                                                   |*/
/*| WHAT THIS PROGRAM DOES:                                           |*/
/*| -----------------------                                           |*/
/*|  This program is a subroutine to other programs and               |*/
/*|  compresses data.                                                 |*/
/*|                                                                   |*/
/*| WHAT YOU NEED TO COMPILE THIS PROGRAM:                            |*/
/*| --------------------------------------                            |*/
/*|                                                                   |*/
/*|  REQUIRED FILES:                                                  |*/
/*|  ---------------                                                  |*/
/*|                                                                   |*/
/*|    UCDPA01.C      - Source code                                   |*/
/*|    UCDDEF.H       - Application header file                       |*/
/*|                                                                   |*/
/*|    OS2.H          - Presentation Manager include file             |*/
/*|    STDLIB.H       - Standard library function declarations        |*/
/*|    STRING.H       - String handling function declarations         |*/
/*|                                                                   |*/
/*|  REQUIRED LIBRARIES:                                              |*/
/*|  -------------------                                              |*/
/*|                                                                   |*/
/*|    OS2386.LIB     - Presentation Manager/OS2 library              |*/
/*|    DDE4NBS.LIB    - Subsystem Development Library                 |*/
/*|                                                                   |*/
/*|  REQUIRED PROGRAMS:                                               |*/
/*|  ------------------                                               |*/
/*|                                                                   |*/
/*|    IBM C Set/2 Compiler                                           |*/
/*|    IBM Linker                                                     |*/
/*|                                                                   |*/
/*| EXPECTED INPUT:                                                   |*/
/*| ---------------                                                   |*/
/*|                                                                   |*/
/*| EXPECTED OUTPUT:                                                  |*/
/*| ----------------                                                  |*/
/*|                                                                   |*/
/*+-------------------------------------------------------------------+*/

/*+-------------------------------------------------------------------+*/
/*| System and library header files.                                  |*/
/*+-------------------------------------------------------------------+*/
#if defined(_WIN32) || defined (__x86_64__) || defined (__i386__)
#ifdef IBMOS2
#define INCL_NOCOMMON
#define INCL_DOSFILEMGR
#define INCL_DOSPROCESS
#define INCL_DOSSEMAPHORES
#define INCL_DOSQUEUES
#define INCL_DOSERRORS
#define INCL_DOSMEMMGR
#include <os2.h>
#endif
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

/*+--------------------------------------------------------------------------+*/
/*| Application header files.                                                |*/
/*+--------------------------------------------------------------------------+*/
#if (defined _WIN32) & (_MSC_VER < 1700)
#ifndef _STDINT
#define _STDINT
// MSVC lower than 17.00 does not have stdint.h, assure, all needed types are defined

typedef unsigned __int16 uint16_t;

typedef unsigned __int32 uint32_t;

typedef unsigned __int64 uint64_t;

#endif // !_STDINT
#else
#include <stdint.h>
#endif
#include <stddef.h>
#ifdef _WIN32
#define WIN32_LEAN_AND_MEAN
#include <Windows.h>
#undef WIN32_LEAN_AND_MEAN
#else// Define system-specific HL_* defines here
#ifndef HL_UNIX
#define HL_UNIX

#if (defined __gnu_linux__) || (defined __linux__)
#define HL_LINUX
#endif

#if (defined __APPLE__) && (defined __MACH__)
#define HL_LINUX
#define HL_MACOS
#endif

#ifdef _AIX
#define HL_AIX
#define HL_BIG_ENDIAN
#endif

#ifdef __FreeBSD__
#define HL_FREEBSD
#endif

#if (defined _hpux) || (defined hpux) || (defined __hpux)
#define HL_HPUX
#define HL_BIG_ENDIAN
#endif

#if (defined sun) || (defined __sun)
#define HL_SOLARIS
#endif

#if (defined __arm__) || (defined __aarch64__)
#define HL_LINUX_ARM
#endif

#ifdef __ANDROID__
#define HL_ANDROID
#endif

#endif
#include <hob-unix01.h>
#endif
#ifdef __APPLE__
/* We get target conditionals to keep apart Mac OS, iOS and iOS simulator.
   The conditionals are TARGET_IPHONE_SIMULATOR, TARGET_OS_IPHONE and TARGET_OS_MAC.
   TARGET_IPHONE_SIMULATOR has the highest priority, TARGET_OS_MAC the lowest.
   Always test, if the conditional is 1, as they will be defined as 0, if we 
   are not compiling for the target.
   */
#include <TargetConditionals.h>
#endif

#include "hob-encry-1.h"
#include <string.h>
#include <stdlib.h>
#include "hob-encry-intern-1.h"

#ifndef DEF_IFUNC_START
#define DEF_IFUNC_START        0            /* start of processing, initialize */
#endif
#ifndef DEF_IFUNC_CONT
#define DEF_IFUNC_CONT         1            /* process data as specified */
                                            /* by buffer pointers      */
#endif
#ifndef DEF_IFUNC_RESET
#define DEF_IFUNC_RESET        2
#endif
#ifndef DEF_IFUNC_END
#define DEF_IFUNC_END          3
#endif

/* calculation of number of elements in table                          */
/* i1 = (number of elements - 1) >> 1;                                 */
/* do {                                                                */
/*   i2 = (i1 + 1) >> 1;                                               */
/*   i1 >>= 1;                                                         */
/* } while (i1);                                                       */

#define DEF_ARI_MAX_CHAR  512
#define DEF_ARI_TABLE (513 + 128 + 64 + 32 + 16 + 8 + 4 + 2 + 1 + 1)
#define DEF_ARI_EOF_CHAR  256

struct dsd_encode {
   int        imc_cont;                     /* where to continue       */
#define DEF_C_ECCO10  0
#define DEF_C_ECCO34  1
#define DEF_C_ECCO84  2
#define DEF_C_ECCO92  3
   unsigned short int usc_arr_total;        /* total occurence of char */
   unsigned short int usc_arr_notab;        /* number of table-places  */
   unsigned short int usrc_arr_tab[DEF_ARI_MAX_CHAR];  /* place in table */
   unsigned short int usrc_arr_rc[DEF_ARI_MAX_CHAR + 1];  /* for reconstruction */
   unsigned short int usrc_count[DEF_ARI_TABLE];  /* occurence of single character */
   unsigned short int usc_upperlimit;       /* upper limit             */
   unsigned short int usc_lowerlimit;       /* lower limit             */
   int        imc_underfl;                  /* current underflow       */
   int        imc_cur_char;                 /* current character       */
   int        imc_cur_enc;                  /* current for encoding    */
   BOOL       boc_escape;                   /* output escape-character */
   int        imc_out_count_bits;           /* number of output bits   */
   char       byc_out_ch;                   /* character of output bits */
};

/*+--------------------------------------------------------------------------+*/
/*| Static global variables and local constants.                             |*/
/*+--------------------------------------------------------------------------+*/

static unsigned short int usdectab1[] =
  { 513,
    513 + 128,
    513 + 128 + 64,
    513 + 128 + 64 + 32,
    513 + 128 + 64 + 32 + 16,
    513 + 128 + 64 + 32 + 16 + 8,
    513 + 128 + 64 + 32 + 16 + 8 + 4,
    513 + 128 + 64 + 32 + 16 + 8 + 4 + 2,
    513 + 128 + 64 + 32 + 16 + 8 + 4 + 2 + 1,
    513 + 128 + 64 + 32 + 16 + 8 + 4 + 2 + 1 + 1 };

/*+--------------------------------------------------------------------------+*/
/*| Main control procedure.                                                  |*/
/*+--------------------------------------------------------------------------+*/

extern "C" void m_call_ari_entropy_01( struct dsd_ari_entropy_01 *adsp_ae ) {
   /* Declare local variables.                                         */
   struct dsd_encode *adsl_denc;            /* fields for encode       */
   int        iml1, iml2, iml3, iml4;
   BOOL       bol1;
   struct {
     unsigned short int usc_current_cur;    /* count up to this char   */
     unsigned short int usc_pred_char;      /* count incl. predecessor */
     unsigned short int usc_total;          /* total in table          */
   } dsl_ari_count;

   if (adsp_ae->imc_func == DEF_IFUNC_CONT) goto pecco00;
   if (adsp_ae->imc_func == DEF_IFUNC_END) {
     adsl_denc = (struct dsd_encode *) adsp_ae->ac_ext;  /* get address of fields */
     goto pecco98;                          /* free all resources      */
   }

   /* function start                                                   */
   adsp_ae->imc_func = DEF_IFUNC_CONT;            /* next call continue      */
   adsp_ae->imc_return = DEF_IRET_NORMAL;         /* once more call subrout  */
   bol1 = (*adsp_ae->amc_aux)( adsp_ae->vpc_userfld, DEF_AUX_MEMGET, &adsl_denc, sizeof(struct dsd_encode) );
                                            /* get memory              */
   if (bol1 == FALSE) {
     adsp_ae->imc_return = DEF_IRET_ERRAU;  /* message error         */
     return;                                /* return to main-prog     */
   }
   adsl_denc->usc_arr_total = 0;            /* characters found        */
   adsl_denc->usc_arr_notab = 0;            /* number of pl in table   */
   memset( adsl_denc->usrc_arr_tab, 0, sizeof(adsl_denc->usrc_arr_tab) );
   memset( adsl_denc->usrc_count, 0, sizeof(adsl_denc->usrc_count) );
   adsl_denc->usc_upperlimit = 0XFFFF;      /* upper limit             */
   adsl_denc->usc_lowerlimit = 0;           /* lower limit             */
   adsl_denc->boc_escape = FALSE;           /* no escape at beginning  */
   adsl_denc->imc_underfl = 0;              /* not yet underflow       */
   adsl_denc->imc_out_count_bits = 0;       /* no output bits          */

   adsl_denc->imc_cont = DEF_C_ECCO10;         /* continue normal         */

   adsp_ae->ac_ext = adsl_denc;                       /* store address of fields */
   return;

   pecco00:                                 /* continue encode         */
   adsl_denc = (struct dsd_encode *) adsp_ae->ac_ext;  /* get address of fields */

   switch ( adsl_denc->imc_cont ) {
     case DEF_C_ECCO10:
       goto pecco10;
     case DEF_C_ECCO34:
       goto pecco34;
     case DEF_C_ECCO84:
       goto pecco84;
     case DEF_C_ECCO92:
       goto pecco92;
   }

   pecco10:                                 /* encode next character   */
   if (adsp_ae->achc_out_cur >= adsp_ae->achc_out_end) {  /* end of output buffer */
     return;
   }
   if (adsp_ae->achc_in_cur >= adsp_ae->achc_in_end) {  /* end of input buffer */
     if (adsp_ae->boc_eof) {              /* end of input stream     */
       adsl_denc->imc_cur_char = DEF_ARI_EOF_CHAR;  /* set character EOF */
     } else {
       return;
     }
   } else {
     adsl_denc->imc_cur_char = (unsigned char) *adsp_ae->achc_in_cur++;  /* get byte input */
   }
   adsl_denc->imc_cur_enc = adsl_denc->usrc_arr_tab[adsl_denc->imc_cur_char];  /* pointer tab  */
   if (adsl_denc->usc_arr_total == 0) goto pecco54;  /* do not output first escape */
   dsl_ari_count.usc_pred_char = 0;         /* clear count             */
   if (adsl_denc->imc_cur_enc & 1) {        /* if last bit set         */
     dsl_ari_count.usc_pred_char = adsl_denc->usrc_count[adsl_denc->imc_cur_enc & 0XFFFE];
   }
   iml1 = (DEF_ARI_MAX_CHAR + 1 - 1) >> 1;  /* size of table           */
   iml2 = DEF_ARI_MAX_CHAR + 1;             /* number of characters    */
   iml3 = adsl_denc->imc_cur_enc;           /* current character       */
   do {                                     /* loop                    */
     iml3 >>= 1;                            /* get next deaper         */
     if (iml3 & 1) {                        /* if last bit set         */
       dsl_ari_count.usc_pred_char += adsl_denc->usrc_count[iml2 + (iml3 >> 1)];
     }                                      /* increment counter       */
     iml2 += (iml1 + 1) >> 1;               /* next start of table     */
     iml1 >>= 1;                            /* shift                   */
   } while (iml1);
   dsl_ari_count.usc_current_cur = dsl_ari_count.usc_pred_char
                         + adsl_denc->usrc_count[adsl_denc->imc_cur_enc];
                                            /* count current character */
   dsl_ari_count.usc_total = adsl_denc->usc_arr_total;  /* get number total */

   pecco30:                                 /* count high-value bits   */
   iml1 = (long) ( adsl_denc->usc_upperlimit - adsl_denc->usc_lowerlimit ) + 1;
   adsl_denc->usc_upperlimit = adsl_denc->usc_lowerlimit
                         + (unsigned short int)
                           ( (iml1 * dsl_ari_count.usc_current_cur)
                             / dsl_ari_count.usc_total - 1 );
   adsl_denc->usc_lowerlimit = adsl_denc->usc_lowerlimit
                         + (unsigned short int)
                           ( (iml1 * dsl_ari_count.usc_pred_char)
                             / dsl_ari_count.usc_total );

   pecco32:                                 /* count high-value bits   */
   if ((adsl_denc->usc_upperlimit & 0X8000)
       != (adsl_denc->usc_lowerlimit & 0X8000)) goto pecco50;
   adsl_denc->imc_out_count_bits++;         /* count output            */
   adsl_denc->byc_out_ch <<= 1;             /* shift output bits       */
   if (adsl_denc->usc_upperlimit & 0X8000) adsl_denc->byc_out_ch |= 1;  /* set bit */
   if (adsl_denc->imc_out_count_bits < 8) goto pecco36;  /* continue   */

   pecco34:                                 /* output character        */
   adsl_denc->imc_cont = DEF_C_ECCO34;      /* set to continue         */
   if (adsp_ae->achc_out_cur >= adsp_ae->achc_out_end) {  /* end of output buffer */
     return;
   }
   adsl_denc->imc_cont = DEF_C_ECCO10;      /* continue normal         */
   *adsp_ae->achc_out_cur++ = adsl_denc->byc_out_ch;  /* output character */
   adsl_denc->imc_out_count_bits = 0;       /* no bits in buffer       */

   pecco36:                                 /* output bit finished     */
   if (adsl_denc->imc_underfl == 0) goto pecco46;  /* no underflow     */
   if (   (adsl_denc->imc_out_count_bits == 0)  /* try total byte      */
       && (adsl_denc->imc_underfl >= 8)) {
     adsl_denc->imc_underfl -= 8;           /* one byte less           */
     adsl_denc->byc_out_ch = 0XFF;          /* set output byte         */
     if (adsl_denc->usc_upperlimit & 0X8000) {  /* if high-order bit set */
       adsl_denc->byc_out_ch = 0;           /* clear output byte       */
     }
     goto pecco34;                          /* output this character   */
   }
   /* output a single bit                                              */
   adsl_denc->imc_out_count_bits++;         /* count output            */
   adsl_denc->byc_out_ch <<= 1;             /* shift output bits       */
   if (!(adsl_denc->usc_upperlimit & 0X8000)) adsl_denc->byc_out_ch |= 1;  /* set bit */
   adsl_denc->imc_underfl--;                /* one bit less            */
   if (adsl_denc->imc_out_count_bits < 8) goto pecco36;   /* continue */
   goto pecco34;                            /* output this character   */

   pecco46:                                 /* output underfl finished */
   adsl_denc->usc_lowerlimit <<= 1;         /* shift lower limit       */
   adsl_denc->usc_upperlimit <<= 1;         /* shift upper limit       */
   adsl_denc->usc_upperlimit |= 1;          /* set lower bit           */
   goto pecco32;                            /* continue high-value bit */

   pecco50:                                 /* try underflow           */
   if ((adsl_denc->usc_lowerlimit & 0X4000)
       && !(adsl_denc->usc_upperlimit & 0X4000)) {
     adsl_denc->imc_underfl++;              /* count underflow         */
     adsl_denc->usc_lowerlimit <<= 1;       /* shift lower limit       */
     adsl_denc->usc_lowerlimit &= 0X7FFF;   /* adjust lower limit      */
     adsl_denc->usc_upperlimit <<= 1;       /* shift upper limit       */
     adsl_denc->usc_upperlimit |= 0X8001;   /* set bits upper limit    */
     goto pecco50;                          /* continue underflow      */
   }

   pecco54:                                 /* end of output code      */
   if (adsl_denc->imc_cur_enc == 0) {       /* if output escape        */
     if (adsl_denc->boc_escape == FALSE) {
       adsl_denc->boc_escape = TRUE;        /* set to continue         */
       adsl_denc->usc_arr_notab++;          /* one more in table       */
       adsl_denc->usrc_arr_tab[adsl_denc->imc_cur_char] = adsl_denc->usc_arr_notab;   /* set table */
       adsl_denc->usrc_count[adsl_denc->usc_arr_notab] = 1;  /* set occurrence */
       iml1 = (DEF_ARI_MAX_CHAR + 1 - 1) >> 1;  /* number of characters */
       iml2 = DEF_ARI_MAX_CHAR + 1;         /* start from here         */
       iml3 = adsl_denc->usc_arr_notab;     /* current character       */
       do {                                 /* loop                    */
         iml3 >>= 1;                        /* get next deaper         */
         if (!(iml3 & 1)) {                 /* if last bit zero        */
           adsl_denc->usrc_count[iml2 + (iml3 >> 1)]++;  /* count this one */
         }
         iml2 += (iml1 + 1) >> 1;           /* next start of table     */
         iml1 >>= 1;                        /* number next table       */
       } while (iml1);
       adsl_denc->usc_arr_total++;          /* one more encoded        */
       dsl_ari_count.usc_pred_char = adsl_denc->imc_cur_char;  /* get current value */
       dsl_ari_count.usc_current_cur = dsl_ari_count.usc_pred_char + 1;  /* next value */
       dsl_ari_count.usc_total = DEF_ARI_MAX_CHAR;  /* get number total */
       goto pecco30;                        /* output value            */
     } else {
       adsl_denc->boc_escape = FALSE;       /* set to normal mode      */
     }
   }
   if (adsl_denc->imc_cur_char == DEF_ARI_EOF_CHAR) {  /* if character EOF */
     goto pecco80;
   }
   /* count one byte encoded                                           */
   adsl_denc->usrc_count[ adsl_denc->imc_cur_enc ]++;  /* count this one */
   iml1 = (DEF_ARI_MAX_CHAR + 1 - 1) >> 1;  /* size of table           */
   iml2 = DEF_ARI_MAX_CHAR + 1;             /* number of characters    */
   iml3 = adsl_denc->imc_cur_enc;           /* current character       */
   do {                                     /* loop                    */
     iml3 >>= 1;                            /* get next deaper         */
     if (!(iml3 & 1)) {                     /* if last bit zero        */
       adsl_denc->usrc_count[ iml2 + (iml3 >> 1) ]++;  /* count this one */
     }
     iml2 += (iml1 + 1) >> 1;               /* next start of table     */
     iml1 >>= 1;                            /* number next table       */
   } while (iml1);
   adsl_denc->usc_arr_total++;              /* increment total         */
   if (adsl_denc->usc_arr_total < 16384) goto pecco10;  /* continue output */

   /* reconstruct the tables                                           */
   adsl_denc->usrc_count[0] >>= 1;          /* divide by two           */
   if (adsl_denc->usrc_count[0] == 0) {     /* zero not allowed        */
     adsl_denc->usrc_count[0] = 1;          /* set minimum value       */
   }
   iml1 = 1;                                /* start from this element */
   iml2 = 0;                                /* first new element       */
   memset( adsl_denc->usrc_arr_rc, 0, sizeof(adsl_denc->usrc_arr_rc) );  /* clear table */
   do {                                     /* loop                    */
     adsl_denc->usrc_count[ iml1 ] >>= 1;   /* divide by two           */
     if (adsl_denc->usrc_count[ iml1 ]) {   /* if not zero             */
       iml2++;                              /* next element new        */
       adsl_denc->usrc_arr_rc[ iml1 ] = iml2;  /* save new number      */
       if (iml2 != iml1) {                  /* if at new place         */
         adsl_denc->usrc_count[ iml2 ] = adsl_denc->usrc_count[ iml1 ];  /* set new element */
       }
     }
     iml1++;                                /* point to next element   */
   } while (iml1 <= adsl_denc->usc_arr_notab);  /* for all elements    */
   adsl_denc->usc_arr_notab = iml2;         /* set new highest number  */
   iml2++;                                  /* next element new        */

   /* clear all other elements                                         */
   memset( &adsl_denc->usrc_count[iml2], 0,
           (DEF_ARI_TABLE - iml2) * sizeof(adsl_denc->usrc_count[0]) );
   /* new places for elements                                          */
   iml1 = 0;                                /* start from zero         */
   do {                                     /* loop                    */
     adsl_denc->usrc_arr_tab[ iml1 ] = adsl_denc->usrc_arr_rc[ adsl_denc->usrc_arr_tab[ iml1 ] ];
     iml1++;                                /* next element            */
   } while (iml1 < DEF_ARI_MAX_CHAR);       /* for all characters      */

   /* set new sums of elements                                         */
   iml1 = 0;                                /* start from zero         */
   adsl_denc->usc_arr_total = 0;            /* clear total of all      */
   do {
     adsl_denc->usc_arr_total += adsl_denc->usrc_count[iml1];  /* set total */
     iml2 = (DEF_ARI_MAX_CHAR + 1 - 1) >> 1;  /* highest element       */
     iml3 = DEF_ARI_MAX_CHAR + 1;           /* element to start        */
     iml4 = iml1;                           /* start with element      */
     do {                                   /* loop                    */
       iml4 >>= 1;                          /* get next deaper         */
       if (!(iml4 & 1)) {                   /* if last bit zero        */
         adsl_denc->usrc_count[iml3 + (iml4 >> 1)] += adsl_denc->usrc_count[iml1];
       }
       iml3 += (iml2 + 1) >> 1;             /* next start of table     */
       iml2 >>= 1;                          /* number next table       */
     } while (iml2);
     iml1++;                                /* next element            */
   } while (iml1 <= adsl_denc->usc_arr_notab);  /* for all valid elements */
   goto pecco10;                            /* continue output         */

   pecco80:                                 /* end of input stream     */
   /* output last bit                                                  */
   adsl_denc->imc_out_count_bits++;         /* count output            */
   adsl_denc->byc_out_ch <<= 1;             /* shift output bits       */
   if (adsl_denc->usc_upperlimit & 0X4000) adsl_denc->byc_out_ch |= 1;  /* set bit */
   adsl_denc->imc_underfl++;                /* count underflow         */

   pecco82:                                 /* at end-of-file          */
   if (adsl_denc->imc_out_count_bits < 8) goto pecco90;   /* continue                */

   pecco84:                                 /* output character        */
   adsl_denc->imc_cont = DEF_C_ECCO84;      /* set to continue         */
   if (adsp_ae->achc_out_cur >= adsp_ae->achc_out_end) {  /* end of output buffer */
     return;
   }
   adsl_denc->imc_cont = DEF_C_ECCO10;      /* continue normal         */
   *adsp_ae->achc_out_cur++ = adsl_denc->byc_out_ch;  /* output character */
   adsl_denc->imc_out_count_bits = 0;       /* no bits in buffer       */

   pecco90:                                 /* continue underflow      */
   if (adsl_denc->imc_underfl) {            /* if more underflow       */
     adsl_denc->imc_out_count_bits++;       /* count output            */
     adsl_denc->byc_out_ch <<= 1;           /* shift output bits       */
     if (!(adsl_denc->usc_upperlimit & 0X4000)) adsl_denc->byc_out_ch |= 1;
                                            /* set bit                 */
     adsl_denc->imc_underfl--;              /* count underflow         */
     goto pecco82;                          /* output this bit         */
   }
   if (adsl_denc->imc_out_count_bits == 0) goto pecco98;  /* no more bits */
   adsl_denc->byc_out_ch <<= 8 - adsl_denc->imc_out_count_bits;  /* shift output bits */
   adsl_denc->imc_cont = DEF_C_ECCO92;      /* set to continue         */

   pecco92:                                 /* output character        */
   if (adsp_ae->achc_out_cur >= adsp_ae->achc_out_end) {  /* end of output buffer */
     return;
   }
   *adsp_ae->achc_out_cur++ = adsl_denc->byc_out_ch;  /* output character */

   pecco98:                                 /* end of subroutine       */
   bol1 = (*adsp_ae->amc_aux)( adsp_ae->vpc_userfld, DEF_AUX_MEMFREE, &adsl_denc, sizeof(struct dsd_encode) );
                                            /* free memory             */
   if (bol1 == FALSE) {
     adsp_ae->imc_return = DEF_IRET_ERRAU;  /* message error         */
     return;                                /* return to main-prog     */
   }
   adsp_ae->imc_return = DEF_IRET_END;    /* end-of-data             */
   return;
} /* end D_M_CDF_ENC()                                                 */
#endif //  defined(_WIN32) || defined (__x86_64__) || defined (__i386__)

#endif //HL_ENCR_RAND
// end of file ../RAND/xs-ari-entropy-01.cpp


#ifdef HL_ENCR_RAND
#if defined(_WIN32) || defined (__x86_64__) || defined (__i386__)
/*+-------------------------------------------------------------------+*/
/*|                                                                   |*/
/*| PROGRAM NAME: xs-random-cas-02                                    |*/
/*| -------------                                                     |*/
/*|  HOB subroutine to generate random / seed thru CAS                |*/
/*|  KB 20.03.16                                                      |*/
/*|                                                                   |*/
/*| COPYRIGHT:                                                        |*/
/*| ----------                                                        |*/
/*|  Copyright (C) HOB Germany 2016                                   |*/
/*|                                                                   |*/
/*+-------------------------------------------------------------------+*/

/**
 * this program is not reentrant
*/

/*+-------------------------------------------------------------------+*/
/*| System and library header files.                                  |*/
/*+-------------------------------------------------------------------+*/

#include <stddef.h>
#include <time.h>
#ifdef _WIN32
#include <winsock2.h>
#include <ws2tcpip.h>
#include <windows.h>
#else
#include <stdlib.h>
#include <stdarg.h>
#include <string.h>
#include <errno.h>
#include <unistd.h>
#include <pthread.h>
#include <sys/time.h>
#include "hob-unix01.h"
#endif
#include <hob-xslhcla1.hpp>
#if (defined _WIN32) & (_MSC_VER < 1700)
#ifndef _STDINT
#define _STDINT
// MSVC lower than 17.00 does not have stdint.h, assure, all needed types are defined

typedef unsigned __int16 uint16_t;

typedef unsigned __int32 uint32_t;

typedef unsigned __int64 uint64_t;

#endif // !_STDINT
#else
#include <stdint.h>
#endif
#include <stddef.h>
#ifdef _WIN32
#define WIN32_LEAN_AND_MEAN
#include <Windows.h>
#undef WIN32_LEAN_AND_MEAN
#else// Define system-specific HL_* defines here
#ifndef HL_UNIX
#define HL_UNIX

#if (defined __gnu_linux__) || (defined __linux__)
#define HL_LINUX
#endif

#if (defined __APPLE__) && (defined __MACH__)
#define HL_LINUX
#define HL_MACOS
#endif

#ifdef _AIX
#define HL_AIX
#define HL_BIG_ENDIAN
#endif

#ifdef __FreeBSD__
#define HL_FREEBSD
#endif

#if (defined _hpux) || (defined hpux) || (defined __hpux)
#define HL_HPUX
#define HL_BIG_ENDIAN
#endif

#if (defined sun) || (defined __sun)
#define HL_SOLARIS
#endif

#if (defined __arm__) || (defined __aarch64__)
#define HL_LINUX_ARM
#endif

#ifdef __ANDROID__
#define HL_ANDROID
#endif

#endif
#include <hob-unix01.h>
#endif
#ifdef __APPLE__
/* We get target conditionals to keep apart Mac OS, iOS and iOS simulator.
   The conditionals are TARGET_IPHONE_SIMULATOR, TARGET_OS_IPHONE and TARGET_OS_MAC.
   TARGET_IPHONE_SIMULATOR has the highest priority, TARGET_OS_MAC the lowest.
   Always test, if the conditional is 1, as they will be defined as 0, if we 
   are not compiling for the target.
   */
#include <TargetConditionals.h>
#endif

#include "hob-encry-1.h"
#include <string.h>
#include <stdlib.h>
#include "hob-encry-intern-1.h"


#define MAX_THREAD_NO          256          /* maximum number of threads used */

//#define NO_ALLOCS              16           /* number of allocs        */
/* 10.04.16 KB - good results with number of allocs == 3               */
#define NO_ALLOCS              3            /* number of allocs        */
#define MAX_ALLOCS             256          /* maximum number of allocs */

#ifndef HL_LONGLONG
#ifdef _WIN32
#define HL_LONGLONG LONGLONG
#else
#define HL_LONGLONG long long int
#endif
#endif

/*+-------------------------------------------------------------------+*/
/*| Internal function prototypes.                                     |*/
/*+-------------------------------------------------------------------+*/

extern "C" BOOL m_hl_lock_dec_b( int * );
extern "C" void m_hl_lock_set_true_1( int * );

extern "C" void * m_random_cas_get( void ** );
extern "C" void m_random_cas_put( void **, void * );
extern "C" void m_random_rdtsc( char * );

extern "C" int m_hl1_printf( const char *aptext, ... );

#ifdef _WIN32
static DWORD WINAPI m_thread_run( LPVOID );
#endif
#ifndef _WIN32
static void * m_thread_run( void * );
#endif
static int m_get_no_cpu( void );
#ifndef _WIN32
static HL_LONGLONG m_get_epoch_nanoseconds( void );
#endif

/*+-------------------------------------------------------------------+*/
/*| global used dsects = structures.                                  |*/
/*+-------------------------------------------------------------------+*/

struct dsd_thread_stor {                    /* structure for thread    */
#ifdef _WIN32
   HANDLE     dsc_thread_handle;            /* handle of thread        */
#endif
#ifndef _WIN32
   pthread_t  dsc_pthread_t;
#endif
   int        imc_thread_no;                /* number of thread        */
#ifdef _WIN32
   int        imc_thread_prio;              /* priority of threads / zero == default */
#endif
   int        imc_alloc_no;                 /* number of allocs        */
   BOOL       boc_cas_time_rel;             /* store CAS time relative */
   HL_LONGLONG ilc_cas_time_sta;            /* save time CAS started   */
};

struct dsd_memory_chunk_01 {                /* memory chunk used for testing */
   struct dsd_memory_chunk_01 *adsc_next;   /* for chaining            */
// to-do 23.03.16 KB - add storage index
//   no, from displacement
   int        imc_content;                  /* content of test pattern */
};

struct dsd_random_generated {               /* random generated        */
   char       byrc_time[ sizeof(HL_LONGLONG) ];  /* time elapsed / ended */
   unsigned short int usc_thread_no;        /* thread number           */
   unsigned short int usc_memory_chunk_no;  /* number of memory chunk  */
   unsigned int umc_storage_index;          /* index of storage error  */
   unsigned int umc_run_no;                 /* number of run           */
};

/*+-------------------------------------------------------------------+*/
/*| Static global variables and local constants.                      |*/
/*+-------------------------------------------------------------------+*/

static volatile BOOL bos_threads_running;   /* threads are running (FALSE) */

static BOOL   ims_threads_running;          /* threads are running (-1) */

static class dsd_hcla_event_1 dss_event;    /* event threads ended     */

static void * as_random_cas_anchor;         /* pseudo lifo chain       */

static void * as_test_memory;               /* memory used for test patterns */

static HL_LONGLONG ils_epoch_stop;          /* epoch when to stop random generation */
static HL_LONGLONG ils_epoch_last;          /* epoch when last random was generated */
static HL_LONGLONG ils_epoch_run_started;   /* epoch when last run was started */

static struct dsd_random_generated dss_rg_cur;  /* random generated    */
//static char * achs_rg_end;                  /* end maximum random generated */
static BOOL   bos_random_set;               /* variables have been set */

#ifdef _WIN32
static HL_LONGLONG ils_freq = 0;            /* QueryPerformanceFrequency() */

static const int imrs_prio_values[5] = { THREAD_PRIORITY_LOWEST,
                                         THREAD_PRIORITY_BELOW_NORMAL,
                                         THREAD_PRIORITY_NORMAL,
                                         THREAD_PRIORITY_ABOVE_NORMAL,
                                         THREAD_PRIORITY_HIGHEST };
#endif
#ifndef _WIN32
static const int imrs_prio_values[5] = { -20, -10, 0, 10, 19 };
static pthread_attr_t dss_phread_attr;
#endif

/*+-------------------------------------------------------------------+*/
/*| Main subroutine.                                                  |*/
/*+-------------------------------------------------------------------+*/

extern "C" int m_call_random_cas_02( struct dsd_random_cas_02 *adsp_crc_01 ) {
#ifdef _WIN32
   BOOL       bol_rc;                       /* return code             */
   DWORD      dwl_rc;                       /* return code             */
#endif
   int        iml_rc;                       /* return code             */
   int        iml_error;                    /* error returned          */
   int        iml_no_cpu;                   /* number of CPUs / threads */
   int        iml_alloc_no;                 /* number of allocs        */
   int        iml_thread_no;                /* number of thread        */
   int        iml1;                         /* working-variable        */
   int        iml_wait;                     /* wait maximum for CAS computed */
   HL_LONGLONG ill_w1;                      /* working-variable        */
   HL_LONGLONG ill_cas_time_sta;            /* save time CAS started   */
   char       *achl_test_memory;            /* memory used for test patterns */
   struct dsd_thread_stor *adsl_thread_stor_w1;  /* structure for thread  */
#ifndef _WIN32
   struct sched_param dsl_thread_sched_param;
#endif
   struct dsd_ari_entropy_01 dsl_ae;        /* compute entropy of data */

   iml_no_cpu = m_get_no_cpu();             /* get number of CPU cores */
   if (iml_no_cpu <= 1) {                   /* only one core           */
     return -1;                             /* return error            */
   }
   /* for compiler only                                                */
   ill_cas_time_sta = 0;                    /* pass time CAS started   */

   iml1 = MAX_THREAD_NO;                    /* maximum number of threads used */
   if (adsp_crc_01->imc_max_cores) {        /* use maximum number of cores / zero == all */
     iml1 = adsp_crc_01->imc_max_cores;     /* use maximum number of cores / zero == all */
   }
   if (iml_no_cpu > iml1) {                 /* wanted number of threads used */
     iml_no_cpu = iml1;                     /* set maximum number      */
     if (iml_no_cpu <= 1) {                 /* only one core           */
       return -1;                           /* return error            */
     }
   }

   iml_alloc_no = NO_ALLOCS;                /* number of allocs        */
   if (adsp_crc_01->imc_alloc_no) {         /* number of allocs        */
     iml_alloc_no = adsp_crc_01->imc_alloc_no;  /* number of allocs    */
   }
   if (iml_alloc_no > MAX_ALLOCS) {         /* maximum number of allocs */
     iml_alloc_no = MAX_ALLOCS;             /* maximum number of allocs */
   }

#ifdef _WIN32
   bol_rc = QueryPerformanceFrequency( (LARGE_INTEGER *) &ils_freq );
   if (bol_rc == FALSE) {                 /* error occured           */
     m_hl1_printf( "xs-random-cas-02-l%05d-W QueryPerformanceFrequency() Error %d.",
             __LINE__, GetLastError() );
     return -1;
   }
   bol_rc = QueryPerformanceCounter( (LARGE_INTEGER *) &ill_w1 );
   if (bol_rc == FALSE) {                 /* error occured           */
     m_hl1_printf( "xs-random-cas-02-l%05d-W QueryPerformanceCounter() Error %d.",
             __LINE__, GetLastError() );
   }
   ils_epoch_stop                           /* epoch when to stop random generation */
     = ill_w1
         + ((HL_LONGLONG) adsp_crc_01->imc_proc_max_msec  /* process for number of milli-seconds maximum */
               * ils_freq / 1000);
//             * 1000 / ils_freq);
#endif
#ifndef _WIN32
   iml_rc = pthread_attr_init( &dss_phread_attr );
   if (iml_rc != 0) {                       /* returned error          */
     m_hl1_printf( "xs-random-cas-02-l%05d-W pthread_attr_init() failed %d %d.",
                   __LINE__, iml_rc, errno );
   }
   if (adsp_crc_01->imc_thread_prio) {      /* priority of threads / zero == default */
     iml_rc = pthread_attr_getschedparam( &dss_phread_attr, &dsl_thread_sched_param );
     if (iml_rc != 0) {                     /* returned error          */
       m_hl1_printf( "xs-random-cas-02-l%05d-W pthread_attr_getschedparam() failed %d %d.",
                     __LINE__, iml_rc, errno );
     }
     dsl_thread_sched_param.sched_priority = imrs_prio_values[ adsp_crc_01->imc_thread_prio - 1 ];
     iml_rc = pthread_attr_setschedparam( &dss_phread_attr, &dsl_thread_sched_param );
     if (iml_rc != 0) {                     /* returned error          */
       m_hl1_printf( "xs-random-cas-02-l%05d-W pthread_attr_setschedparam() failed %d %d.",
                     __LINE__, iml_rc, errno );
     }
   }
   ill_w1 = m_get_epoch_nanoseconds();
   ils_epoch_stop                           /* epoch when to stop random generation */
     = ill_w1
         + ((HL_LONGLONG) adsp_crc_01->imc_proc_max_msec  /* process for number of milli-seconds maximum */
               * 1000000);
#endif
   /* perpare arithmetic compression                                   */
   memset( &dsl_ae, 0, sizeof(struct dsd_ari_entropy_01) );  /* compute entropy of data */
   dsl_ae.amc_aux = &m_aux;                 /* auxiliary helper routine pointer */
   dsl_ae.achc_in_end = (char*) &dss_rg_cur + sizeof(struct dsd_random_generated);  /* end of buffer with input data */
   dsl_ae.achc_out_cur = adsp_crc_01->achc_random;  /* current end of output data */
   dsl_ae.achc_out_end = adsp_crc_01->achc_random + adsp_crc_01->imc_max_len_random;  /* end of buffer for output data */
   m_call_ari_entropy_01( &dsl_ae );

   /* acquire memory for all fields                                    */
   as_test_memory                           /* memory used for test patterns */
     = malloc( iml_no_cpu * iml_alloc_no * sizeof(struct dsd_memory_chunk_01)
                 + iml_no_cpu * sizeof(struct dsd_thread_stor) );
   if (as_test_memory == NULL) {            /* out of memory           */
     return -1;                             /* return error            */
   }

   p_next_run_00:                           /* next run                */
   /* set time when maximum ended                                      */
#ifdef _WIN32
   bol_rc = QueryPerformanceCounter( (LARGE_INTEGER *) &ils_epoch_last );  /* epoch when last random was generated */
   if (bol_rc == FALSE) {                   /* error occured           */
     m_hl1_printf( "xs-random-cas-02-l%05d-W QueryPerformanceCounter() Error %d.",
                   __LINE__, GetLastError() );
   }
#endif
#ifndef _WIN32
   ils_epoch_last = m_get_epoch_nanoseconds();
#endif
   iml_thread_no = 0;                       /* number of thread        */
   bos_threads_running = FALSE;             /* threads are running (FALSE) */
   as_random_cas_anchor = NULL;             /* pseudo lifo empty       */
   achl_test_memory = (char *) as_test_memory;  /* memory used for test patterns */
   iml1 = iml_no_cpu * iml_alloc_no;
   do {
     m_random_cas_put( &as_random_cas_anchor, achl_test_memory );
     achl_test_memory += sizeof(struct dsd_memory_chunk_01);
     iml1--;                                /* decrement index         */
   } while (iml1 > 0);
   adsl_thread_stor_w1 = (struct dsd_thread_stor *) achl_test_memory;  /* structure for thread - start */
   iml_rc = dss_event.m_create( &iml_error );  /* event for threads    */
   if (iml_rc < 0) {                        /* error occured           */
     m_hl1_printf( "xs-random-cas-02-l%05d-W event m_create Return Code %d Error %d.",
                   __LINE__, iml_rc, iml_error );
   }
   ims_threads_running = iml_no_cpu - 1;    /* threads are running (-1) */
#ifdef _WIN32
   bol_rc = QueryPerformanceCounter( (LARGE_INTEGER *) &ils_epoch_run_started );  /* epoch when last run was started */
   if (bol_rc == FALSE) {                 /* error occured           */
     m_hl1_printf( "xs-random-cas-02-l%05d-W QueryPerformanceCounter() Error %d.",
             __LINE__, GetLastError() );
   }
#endif
#ifndef _WIN32
   ils_epoch_run_started = m_get_epoch_nanoseconds();
#endif
// ils_epoch_last -= ils_epoch_run_started;  /* epoch when last run was started */
   if (adsp_crc_01->boc_cas_time_rel) {     /* store CAS time relative */
     m_random_rdtsc( (char *) &ill_cas_time_sta );  /* current time-stamp counter */
   }
   bos_random_set = FALSE;                  /* variables have been set */

   p_start_thr_00:                          /* start the threads       */
   adsl_thread_stor_w1->imc_thread_no = iml_thread_no;
#ifdef _WIN32
   adsl_thread_stor_w1->imc_thread_prio = adsp_crc_01->imc_thread_prio;  /* priority of threads / zero == default */
#endif
   adsl_thread_stor_w1->imc_alloc_no = iml_alloc_no;  /* number of allocs */
   adsl_thread_stor_w1->boc_cas_time_rel = adsp_crc_01->boc_cas_time_rel;  /* store CAS time relative */
   adsl_thread_stor_w1->ilc_cas_time_sta = ill_cas_time_sta;  /* pass time CAS started */
#ifdef _WIN32
   adsl_thread_stor_w1->dsc_thread_handle
//   = CreateThread( NULL, 0, &m_thread_run, adsl_thread_stor_w1, 0, &adsl_thread_stor_w1->umc_threadid );
     = CreateThread( NULL, 0, &m_thread_run, adsl_thread_stor_w1, 0, NULL );
   if (adsl_thread_stor_w1->dsc_thread_handle == NULL) {
     m_hl1_printf( "xs-random-cas-02-l%05d-W CreateThread() thread-no %d failed %d.",
                   __LINE__, iml_thread_no, GetLastError() );
   }
#endif
#ifndef _WIN32
   iml_rc = pthread_create( &adsl_thread_stor_w1->dsc_pthread_t,
                            &dss_phread_attr,
                            &m_thread_run,
                            adsl_thread_stor_w1 );
   if (iml_rc != 0) {                       /* returned error          */
     m_hl1_printf( "xs-random-cas-02-l%05d-W pthread_create() thread-no %d failed %d %d.",
                   __LINE__, iml_thread_no, iml_rc, errno );
   }
#endif
   iml_thread_no++;                         /* number of thread        */
   adsl_thread_stor_w1++;                   /* structure for thread    */
   if (iml_thread_no < iml_no_cpu) {
     goto p_start_thr_00;                   /* start the threads       */
   }

   do {
     if (bos_threads_running == FALSE) {    /* threads are running (FALSE) */
#ifdef _WIN32
       bol_rc = QueryPerformanceCounter( (LARGE_INTEGER *) &ill_w1 );
       if (bol_rc == FALSE) {               /* error occured           */
         m_hl1_printf( "xs-random-cas-02-l%05d-W QueryPerformanceCounter() Error %d.",
                 __LINE__, GetLastError() );
       }
// UUUU 10.12.16 KB - milliseconds for wait
       iml_wait                             /* wait this time in milliseconds */
         = (ils_epoch_stop                  /* epoch when to stop random generation */
//           - ill_w1) * ils_freq
//           / 1000;
             - ill_w1) * 1000
             / ils_freq;
       if (iml_wait <= 0) {                 /* wait this time          */
         m_hl_lock_set_true_1( (BOOL *) &bos_threads_running );  /* threads are running (FALSE) */
       }
#endif
#ifndef _WIN32
       ill_w1 = m_get_epoch_nanoseconds();
       iml_wait                             /* wait this time          */
         = ((HL_LONGLONG) ils_epoch_stop    /* epoch when to stop random generation */
             - ill_w1)
             / 1000;
       if (iml_wait <= 0) {                 /* wait this time          */
         m_hl_lock_set_true_1( (BOOL *) &bos_threads_running );  /* threads are running (FALSE) */
       }
#endif
       if (iml_wait > 0) {                  /* wait this time          */
         iml_rc = dss_event.m_wait_msec( iml_wait, &iml_error );  /* event for threads */
         if (iml_rc != 0) {                 /* timeout or error occured */
           m_hl_lock_set_true_1( (BOOL *) &bos_threads_running );  /* threads are running (FALSE) */
         }
       }
     }
   } while (ims_threads_running >= 0);      /* threads are running (-1) */
   while (ims_threads_running >= 0) {       /* threads are running (-1) */
     iml_rc = dss_event.m_wait( &iml_error );  /* event for threads    */
     if (iml_rc < 0) {                      /* error occured           */
       m_hl1_printf( "xs-random-cas-02-l%05d-W event m_wait Return Code %d Error %d.",
                     __LINE__, iml_rc, iml_error );
     }
   }
   /* check if all threads have ended                                  */
   adsl_thread_stor_w1 = (struct dsd_thread_stor *) achl_test_memory;  /* structure for thread - start */
   iml1 = iml_no_cpu;
   do {                                     /* loop over all threads   */
#ifdef _WIN32
     dwl_rc = WaitForSingleObject( adsl_thread_stor_w1->dsc_thread_handle, INFINITE );
     if (dwl_rc != WAIT_OBJECT_0) {         /* error occured           */
       m_hl1_printf( "xs-random-cas-02-l%05d-W WaitForSingleObject() thread Return Code %d Error %d.",
                     __LINE__, dwl_rc, GetLastError() );
     }
     bol_rc = CloseHandle( adsl_thread_stor_w1->dsc_thread_handle );
     if (bol_rc == FALSE) {                 /* error occured           */
       m_hl1_printf( "xs-random-cas-02-l%05d-W CloseHandle() thread Error %d.",
                     __LINE__, GetLastError() );
     }
#endif
#ifndef _WIN32
//   iml_rc = pthread_join( adsl_thread_stor_w1->dsc_pthread_t, &vpl_retval );
     iml_rc = pthread_join( adsl_thread_stor_w1->dsc_pthread_t, NULL );
     if (iml_rc != 0) {                     /* error occured           */
       m_hl1_printf( "xs-random-cas-02-l%05d-W pthread_join() Error %d.",
                     __LINE__, iml_rc );
     }
#endif
     adsl_thread_stor_w1++;
     iml1--;
   } while (iml1 > 0);

   iml_rc = dss_event.m_close( &iml_error );  /* event for threads    */
   if (iml_rc < 0) {                        /* error occured           */
     m_hl1_printf( "xs-random-cas-02-l%05d-W event m_close Return Code %d Error %d.",
                   __LINE__, iml_rc, iml_error );
   }
// 10.12.16 KB
// adss_rg_cur++;                           /* random generated        */
   if (bos_random_set) {                    /* variables have been set */
     dsl_ae.achc_in_cur = (char*) &dss_rg_cur;  /* current position input data */
     m_call_ari_entropy_01( &dsl_ae );
   }
   if (ils_epoch_last                       /* epoch when last random was generated */
         < ils_epoch_stop) {                /* epoch when to stop random generation */
     if ((dsl_ae.achc_out_cur - adsp_crc_01->achc_random)  /* current end of output data */
           < adsp_crc_01->imc_max_len_random) {
       goto p_next_run_00;                  /* next run                */
   }
   }

   free( as_test_memory );                  /* memory used for test patterns */

   if (dsl_ae.imc_return == DEF_IRET_NORMAL) {
     dsl_ae.imc_func = DEF_IFUNC_END;       /* free resources arithmetic compression */
     m_call_ari_entropy_01( &dsl_ae );
   }

   return dsl_ae.achc_out_cur - adsp_crc_01->achc_random;  /* current end of output data */
} /* end m_call_random_cas_02()                                        */

/** run the test thread                                                */
#ifdef _WIN32
static DWORD WINAPI m_thread_run( void * ap_param ) {
#endif
#ifdef FORKEDIT
}
#endif
#ifndef _WIN32
static void * m_thread_run( void * ap_param ) {
#endif
   BOOL       bol1;                         /* working variable        */
#ifdef _WIN32
   BOOL       bol_rc;                       /* return code             */
#endif
   int        iml_rc;                       /* return code             */
   int        iml_error;                    /* error returned          */
   int        iml_run;                      /* times run               */
   int        iml_alloc;
   int        iml1;
   char       *achl_w1, *achl_w2;
   HL_LONGLONG ill_epoch_w1;                /* working variable        */
   struct dsd_thread_stor *adsl_thread_stor_l;  /* structure for thread */
   struct dsd_memory_chunk_01 *adsl_mc_w1;  /* current entry memory chunk */
   struct dsd_memory_chunk_01 *adsrl_mc[ MAX_ALLOCS ];  /* memory chunk used for testing */

   adsl_thread_stor_l = (struct dsd_thread_stor *) ap_param;  /* structure for thread */
#ifdef _WIN32
   if (adsl_thread_stor_l->imc_thread_prio) {  /* priority of threads / zero == default */
     bol_rc = SetThreadPriority( adsl_thread_stor_l->dsc_thread_handle,
                                 imrs_prio_values[ adsl_thread_stor_l->imc_thread_prio - 1 ] );
   }
#endif

   iml_run = 0;                             /* times run               */

   p_run_00:                                /* one pass                */
   iml_alloc = 0;

   p_run_20:                                /* acquire memory          */
   if (bos_threads_running) {               /* threads are running (FALSE) */
     goto p_thread_end;                     /* thread is ending        */
   }
   adsl_mc_w1 = (struct dsd_memory_chunk_01 *) m_random_cas_get( &as_random_cas_anchor );
   if (adsl_mc_w1 == NULL) {                /* no more memory          */
     goto p_thread_error;                   /* error has occured       */
   }
   adsl_mc_w1->imc_content                  /* content of test pattern */
     = iml_alloc | (adsl_thread_stor_l->imc_thread_no << 16);
   adsrl_mc[ iml_alloc ] = adsl_mc_w1;

   iml_alloc++;
   if (iml_alloc < adsl_thread_stor_l->imc_alloc_no) {  /* number of allocs */
     goto p_run_20;                         /* acquire memory          */
   }

   iml_alloc = 0;

   p_run_40:                                /* free memory             */
   if (bos_threads_running) {               /* threads are running (FALSE) */
     goto p_thread_end;                     /* thread is ending        */
   }
   adsl_mc_w1 = adsrl_mc[ iml_alloc ];
   if (adsl_mc_w1->imc_content              /* content of test pattern */
         != (iml_alloc | (adsl_thread_stor_l->imc_thread_no << 16))) {
     goto p_thread_error;                   /* error has occured       */
   }
   m_random_cas_put( &as_random_cas_anchor, adsl_mc_w1 );
   iml_alloc++;
   if (iml_alloc < adsl_thread_stor_l->imc_alloc_no) {  /* number of allocs */
     goto p_run_40;                         /* free memory             */
   }

   iml_run++;                               /* times run               */
   goto p_run_00;                           /* next pass               */

   p_thread_error:                          /* error has occured       */
   m_hl_lock_set_true_1( (BOOL *) &bos_threads_running );  /* threads are running (FALSE) */
#ifdef _WIN32
   bol_rc = QueryPerformanceCounter( (LARGE_INTEGER *) &ils_epoch_last );  /* epoch when last random was generated */
   if (bol_rc == FALSE) {                 /* error occured           */
     m_hl1_printf( "xs-random-cas-02-l%05d-W QueryPerformanceCounter() Error %d.",
             __LINE__, GetLastError() );
   }
#endif
#ifndef _WIN32
   ils_epoch_last = m_get_epoch_nanoseconds();
#endif
   /* alignment                                                        */
   m_random_rdtsc( (char *) &ill_epoch_w1 );  /* current time-stamp counter */
   if (adsl_thread_stor_l->boc_cas_time_rel) {  /* store CAS time relative */
     ill_epoch_w1
       -= adsl_thread_stor_l->ilc_cas_time_sta;  /* save time CAS started */
   }
   achl_w1 = dss_rg_cur.byrc_time;
   achl_w2 = (char *) &ill_epoch_w1;
   iml1 = sizeof(HL_LONGLONG);
   do {
     *achl_w1++ = *achl_w2++;
     iml1--;                                /* decrement index         */
   } while (iml1 > 0);
   dss_rg_cur.usc_thread_no = (unsigned short int) adsl_thread_stor_l->imc_thread_no;  /* thread number */
   dss_rg_cur.usc_memory_chunk_no = (unsigned short int) iml_alloc;  /* number of memory chunk */
   dss_rg_cur.umc_storage_index = 0;        /* index of storage error  */
   if (adsl_mc_w1) {                        /* current entry memory chunk */
     dss_rg_cur.umc_storage_index = adsl_mc_w1 - (struct dsd_memory_chunk_01 *) as_test_memory;
   }
   dss_rg_cur.umc_run_no = (unsigned int) iml_run;  /* number of run   */
   bos_random_set = TRUE;                   /* variables have been set */

   p_thread_end:                            /* thread is ending        */
   bol1 = m_hl_lock_dec_b( &ims_threads_running );  /* threads are running (-1) */
#ifdef _WIN32
   if (bol1 == FALSE) return 0;
#endif
#ifndef _WIN32
   if (bol1 == FALSE) return NULL;
#endif
   iml_rc = dss_event.m_post( &iml_error );  /* event for threads    */
   if (iml_rc < 0) {                        /* error occured           */
     m_hl1_printf( "xs-random-cas-02-l%05d-W event m_post Return Code %d Error %d.",
                   __LINE__, iml_rc, iml_error );
   }
#ifdef _WIN32
   return 0;
#endif
#ifndef _WIN32
   return NULL;
#endif
} /* end m_thread_run()                                                */

#ifdef _WIN32
/** query the OS, number of CPUs                                       */
static int m_get_no_cpu( void ) {
   SYSTEM_INFO dsl_systeminfo;              /* query OS                */

   GetSystemInfo( &dsl_systeminfo );
   return dsl_systeminfo.dwNumberOfProcessors;
} /* end m_get_no_cpu()                                                */
#endif
#ifndef _WIN32
/** query the OS, number of CPUs                                       */
static int m_get_no_cpu( void ) {
#ifndef HL_HPUX
   return sysconf( _SC_NPROCESSORS_ONLN );
#else
   struct pst_dynamic dsl_psd;

   pstat_getdynamic( &dsl_psd, sizeof(struct pst_dynamic), 1, 0 );
   return (int) dsl_psd.psd_proc_cnt;
#endif
} /* end m_get_no_cpu()                                                */
#endif

#ifndef _WIN32
/** return the Epoch value in nanoseconds                              */
static HL_LONGLONG m_get_epoch_nanoseconds( void ) {
   int        iml_rc;                       /* return code             */
   struct timespec dsl_timespec;
   struct timeval dsl_timeval;

   iml_rc = clock_gettime( CLOCK_REALTIME, &dsl_timespec );
   if (iml_rc >= 0) {                       /* succeeded               */
     return (((HL_LONGLONG) dsl_timespec.tv_sec) * 1000 * 1000 * 1000 + dsl_timespec.tv_nsec);
   }
   gettimeofday( &dsl_timeval, NULL );
   return (((HL_LONGLONG) dsl_timeval.tv_sec) * 1000 * 1000 * 1000 + dsl_timeval.tv_usec * 1000);
} /* end m_get_epoch_nanoseconds()                                     */
#endif
#endif //defined(_WIN32) || defined (__x86_64__) || defined (__i386__)

#endif //HL_ENCR_RAND
// end of file ../RAND/xs-random-cas-02.cpp


#ifdef HL_ENCR_LNUM
/** @defgroup lnum32 Large number module
* This module implements large integer number arithmetic required for public
* key processing, key generation etc. 
*
* Each large integer number is represented
* as a structure that contains the number buffer, consisting of 32bit elements,
* the amount of current used elements from that buffer and the total allocated
* size (in elements) of that buffer.
*
* This module operates on unsigned large numbers only.
*
* Some functions allow the use of a context to avoid temporary allocations and
* so speed up the calculations.
*
* Some functions may use a callback function for periodical callbacks (about 1
* sec intervals). This can be used for progress bars.
*
* Whenever a WLarge number is used as parameter to take results, the internal 
* buffer may be enlarged as necessary.
*
* This module can be considered as a basic module. It depends only on:
*<ul>
* <li> @ref rand "Pseudo random number generator" for generating prime number
*                candidates
*</ul>
* Overview of functions implemented
* =================================
*
* General functions:
*<ul>
* <li> Allocate a large number structure with buffer of given size
* <li> Free a large number structure and the buffer
* <li> Zero large number structure buffer, free structure and buffer
* <li> Zero large number structure buffer
* <li> Allocate/reallocate number structure number buffer for given size
*</ul>
* Context functions:
* 
* Contexts are used as a large number pool for temporary usage to avoid repeated
* allocation/deallocation.
* 
* Standard Contexts:
*<ul>
* <li> Allocate a context structure with specified amount of large number 
*     structures and given number buffer size
* <li> Free a context structure and all large number structures and their 
*     respective buffers.
* <li> Get a large number structure from a context with given buffer size
* <li> Return large number structure(s) and buffer to context
*</ul>
* Montgomery contexts:
*<ul>
* <li> Allocate context for montgomery operations on large number modulus
* <li> Free montgomery context
*</ul>
* Number format query/conversion routines:
*<ul>
* <li> Get size of stored large number in number structure in bytes (used for 
*        conversions)
* <li> Convert a big endian large number (byte representation) to a large number,
*        store the number to buffer in 32bit elements.
* <li> Convert large number from internal structure buffer format to big endian
*        byte buffer format.
*</ul>
* Arithmetic routines:
*<ul>
* <li> Copy one large number to another
* <li> Compare (unsigned) large numbers (<, ==, >)
* <li> Check large number for zero ( == 0)
* <li> Check large number for one ( == 1)
* <li> Shift left large number n bits
* <li> Shift left large number 1 bit
* <li> Shift right large number n bits
* <li> Shift right large number 1 bit
* <li> Add two (unsigned) large numbers
* <li> Add Element (32Bit value) to a large number
* <li> Subtract two (unsigned) large numbers, 2nd must be <= 1st
* <li> Subtract Element (32Bit value) from a large number
* <li> Multiply two large numbers
* <li> Square a large number
* <li> Divide two large numbers, get quotient, remainder
* <li> Divide two large numbers, get quotient only
* <li> Divide two large numbers, get remainder only (Modulus)
* <li> Calculate remainder of large number for a given 16bit modulus (used for 
*        key generation purposes)
* <li> Multiply two large numbers, reduce result modulo a third large number, 
*        get modulus (remainder) [MulMod]
* <li> Exponentiate large number by large number exponent, reduce result modulo
*        a third large number, get modulus (remainder) [ExpMod] <br>
*        Two versions exist: Standard method and method using Montgomery 
*        multiplication (for odd base only).
* <li> Get greatest common divisor of two large numbers (GCD)
* <li> Invert a large number modulus a second large number (INVMOD)
*</ul>
* Montgomery arithmetic routines:
*<ul>
* <li> Convert montgomery context to large number
* <li> Convert a large number to montgomery representation for a given 
*        montgomery modulus context
* <li> Generate large number montgomery representation of the value 1 for a 
*        given montgomery context
* <li> Perform montgomery multiplication and modulo reduction of two large 
*        numbers using a montgomery modulus context
* <li> Exponentiate two large numbers modulo third number using montgomery 
*        multiplication
*</ul>
* Miscellaneous functions:
*<ul>
* <li> Get a random large number of specified number size (bits)
* <li> Prime number generating/testing
* <li> Perform eratosthenes sieving of a large number for small prime factors 
*        weed out
* <li> Perform Miller-Rabin primality check on a large number
* <li> Get a (probable) prime large number of given size (bits)
*</ul>
*@{
* @file
* New 32 Bit Large Number system library using either
* Target 64 Bit mode or 64 Bit Emulation mode (if no INT64 available)
*
* NOTE:
*  -# All Elements for calculation are defined as SIGNED types
*     but will be used to produce unsigned results anyway !
*	   THIS NEEDS PROPER CASTING IN ANY CASE !!!
*  -# Two's complement arithmetic is needed for proper operation!
*@}
*/
#include <stdlib.h>
#include <string.h>
#if (defined _WIN32) & (_MSC_VER < 1700)
#ifndef _STDINT
#define _STDINT
// MSVC lower than 17.00 does not have stdint.h, assure, all needed types are defined

typedef unsigned __int16 uint16_t;

typedef unsigned __int32 uint32_t;

typedef unsigned __int64 uint64_t;

#endif // !_STDINT
#else
#include <stdint.h>
#endif
#include <stddef.h>
#ifdef _WIN32
#define WIN32_LEAN_AND_MEAN
#include <Windows.h>
#undef WIN32_LEAN_AND_MEAN
#else// Define system-specific HL_* defines here
#ifndef HL_UNIX
#define HL_UNIX

#if (defined __gnu_linux__) || (defined __linux__)
#define HL_LINUX
#endif

#if (defined __APPLE__) && (defined __MACH__)
#define HL_LINUX
#define HL_MACOS
#endif

#ifdef _AIX
#define HL_AIX
#define HL_BIG_ENDIAN
#endif

#ifdef __FreeBSD__
#define HL_FREEBSD
#endif

#if (defined _hpux) || (defined hpux) || (defined __hpux)
#define HL_HPUX
#define HL_BIG_ENDIAN
#endif

#if (defined sun) || (defined __sun)
#define HL_SOLARIS
#endif

#if (defined __arm__) || (defined __aarch64__)
#define HL_LINUX_ARM
#endif

#ifdef __ANDROID__
#define HL_ANDROID
#endif

#endif
#include <hob-unix01.h>
#endif
#ifdef __APPLE__
/* We get target conditionals to keep apart Mac OS, iOS and iOS simulator.
   The conditionals are TARGET_IPHONE_SIMULATOR, TARGET_OS_IPHONE and TARGET_OS_MAC.
   TARGET_IPHONE_SIMULATOR has the highest priority, TARGET_OS_MAC the lowest.
   Always test, if the conditional is 1, as they will be defined as 0, if we 
   are not compiling for the target.
   */
#include <TargetConditionals.h>
#endif

#include "hob-encry-1.h"
#include "hob-encry-intern-1.h"

//INTARRAYI
static const int UsedBitTab[16] = { // fast conversion table for bit-counts
//       0          1          2          3	   Nibble value
        0x00,      0x01,      0x02,      0x02,	// Top Most Bit Number
//       4          5          6          7	   Nibble value
        0x03,      0x03,      0x03,      0x03,	// Top Most Bit Number 
//       8          9          A          B	   Nibble value 
        0x04,      0x04,      0x04,      0x04,	// Top Most Bit Number 
//       C          D          E          F	   Nibble value  
        0x04,      0x04,      0x04,      0x04,	// Top Most Bit Number 
};

//()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()
//
// General Helper routines
//
//()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()

/** @addtogroup lnum32
* @{
*/
extern "C" int HardGetByteCntWLnumElem(int WElement)
{
  int ByteCnt = 4;

  if(WElement == 0)				// special case, none set
    return(0);
  //--------------------------------------------------
  // find topmost byte that is not zero
  //--------------------------------------------------
  for(;;)
  {
    if((WElement & 0xFF000000) != 0)		// found a byte with bits set
      return(ByteCnt);
    WElement <<= 8;				// shift up next
    ByteCnt--;					// reduce available bytes
  }
}

extern "C" int HardGetBitCntWLnumElem(int WElement)
{
  int NibbleCnt = 7;

  if(WElement == 0)				// special case, none set
    return(0);
  //--------------------------------------------------
  // find topmost Nibble that is not zero
  //--------------------------------------------------
  for(;;)
  {
    if((WElement & 0xF0000000) != 0)		// found a nibble with bits
      return(UsedBitTab[(WElement >> 28) & 0x0F] + (NibbleCnt*4));
    WElement <<= 4;				// shift up next
    NibbleCnt--;				// reduce available nibbles
  }
}

//()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()
//
// WLarge Number/Context Allocation, Access and Freeing routines
//
//()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()

extern "C" WLARGENUM* AllocNewWLnum(HMEM_CTX_DEF
					   int Size)
{
  WLARGENUM* pWLnum;
  int* pBuf;
  //-------------------------------------------------------------
  // Allocate, initialize structure
  //-------------------------------------------------------------
  pWLnum = (WLARGENUM*)
             ((void *) BIT8_ARRAY_CALLOC(HMEM_CTX_REF,1, sizeof(WLARGENUM)));
  if(pWLnum == NULL)
    return(NULL);
  //-------------------------------------------------------------
  // Allocate Number buffer if requested
  //-------------------------------------------------------------
  if(Size > 0)
  {
    if((pBuf = BIT32_ARRAY_ALLOC(HMEM_CTX_REF,Size)) == NULL)
    {
      FREE_CARRAY(HMEM_CTX_REF,pWLnum);
      return(NULL);
    }
    pWLnum->AllocSize = Size;
    pWLnum->lpEl = pBuf;
  }
  return(pWLnum);
}

extern "C" void FreeWLnum(HMEM_CTX_DEF WLARGENUM* pWLnum)
{
  if(pWLnum != NULL)
  {
    FREE_ARRAY(HMEM_CTX_REF,pWLnum->lpEl);
    FREE_ARRAY(HMEM_CTX_REF,pWLnum);
  }
}

extern "C" void ClearFreeWLnum(HMEM_CTX_DEF WLARGENUM* pWLnum)
{
  int* pBuf;

  if(pWLnum != NULL)
  {
    if((pBuf = pWLnum->lpEl) != NULL)
    {
      ClearBit32Array(pBuf, 0, pWLnum->AllocSize);
      FREE_CARRAY(HMEM_CTX_REF,pBuf);
    }
    FREE_CARRAY(HMEM_CTX_REF,pWLnum);
  }
}

extern "C" void ClearWLnumElements(WLARGENUM* pWLnum)
{
  int* pBuf;

  if((pWLnum != NULL) && (pWLnum->AllocSize != 0) &&
     ((pBuf = pWLnum->lpEl) != NULL))
  {
    ClearBit32Array(pBuf, 0, pWLnum->AllocSize);
    pWLnum->UsedSize = 0;
  }
}

extern "C" int AllocWLnumElements(HMEM_CTX_DEF
				WLARGENUM* pWLnum, int NewSize)
{
  int AllocedSize;
#if defined XH_INTERFACE
  int CopyCnt;
  int* pOldBuf;
#endif // XH_INTERFACE
  int* pNewBuf = NULL;
  //----------------------------------------------------------------
  // check if we have already allocated memory, and if so, check size
  //----------------------------------------------------------------
  AllocedSize = pWLnum->AllocSize;	// get element count
  if(AllocedSize > 0)				// allocated element(s) present
  {
    if(NewSize > 0)				// Element present, resize
    {
//      PRINT("\nREALLOC ");
      //------------------------------------------------------------
      // we must re-allocate memory, different for JAVA / C
      // NOTE: now same routine for C as for JAVA when external
      // ----- interface is to be used !!!!!
      //------------------------------------------------------------
#if !defined XH_INTERFACE
      if((pNewBuf = (int*) realloc(pWLnum->lpEl,
                            NewSize * sizeof(int))) == NULL)
      {
        pWLnum->UsedSize = 0;
        return(LNUM_OP_ALLOC_ERR);
      }
      pWLnum->lpEl      = pNewBuf;	// set new buffer
      pWLnum->AllocSize = NewSize;	// set new size
      //------------------------------------------------------------
      // Clear the new allocated portion if larger than before
      //------------------------------------------------------------
      if(NewSize > AllocedSize)
        ClearBit32Array(pNewBuf,AllocedSize,NewSize - AllocedSize);
      //------------------------------------------------------------------
      // Correct used size if buffer shrinked ??? -> should not happen !!!
      // CHECK if we should *REALLY* renormalize !!!!
      //------------------------------------------------------------------
//    if(NewSize < WLNUM_UsedSize(pWLnum))
//      WLNUM_UsedSize(pWLnum) = NewSize;
      return(LNUM_OP_OK);

#else // !XH_INTERFACE mode
      if((pNewBuf = BIT32_ARRAY_ALLOC(HMEM_CTX_REF,NewSize)) == NULL)
      {
        pWLnum->UsedSize = 0;
        return(LNUM_OP_ALLOC_ERR);
      }
      pOldBuf = pWLnum->lpEl;
      pWLnum->lpEl      = pNewBuf;	// set new buffer
      pWLnum->AllocSize = NewSize;	// set new size
      //-----------------------------------------------------------------------
      // copy data to new buffer if any, clear the rest if larger (not needed!)
      //-----------------------------------------------------------------------
      CopyCnt = AllocedSize;			// assume all to copy
      if(NewSize < AllocedSize)			// new is smaller (but NOT 0)
        CopyCnt = NewSize;
      memcpy(pNewBuf+0,pOldBuf+0,(CopyCnt)*4);
      FREE_CARRAY(HMEM_CTX_REF,pOldBuf);
      //------------------------------------------------------------------
      // Correct used size if buffer shrinked ??? -> should not happen !!!
      // CHECK if we should *REALLY* renormalize !!!!
      //------------------------------------------------------------------
//    if(NewSize < WLNUM_UsedSize(pWLnum))
//      WLNUM_UsedSize(pWLnum) = NewSize;
      return(LNUM_OP_OK);
#endif
    } // NewSize > 0
    else
    {
      //----------------------------------------------------------
      // Buffer release option, New Size <= 0, AllocedSize was > 0
      //----------------------------------------------------------
      FREE_ARRAY(HMEM_CTX_REF,pWLnum->lpEl); // also sets NULL !
      pWLnum->AllocSize = 0;		// nothing allocated
      pWLnum->UsedSize  = 0;		// nothing used
      return(LNUM_OP_OK);				// o.k.
    } // Element present
  }
  //--------------------------------------------------------------
  // no elements have been allocated yet, allocate elements now,
  // check for trivial case of NewSize <= 0 also !
  //--------------------------------------------------------------
  if(NewSize > 0)				// new buffer requested
  {
    pNewBuf = (int*)
	        ((void *) BIT8_ARRAY_CALLOC(HMEM_CTX_REF,1,
					    NewSize * sizeof(int)));
    if(pNewBuf == NULL)
      return(LNUM_OP_ALLOC_ERR);
    pWLnum->lpEl      = pNewBuf;
    pWLnum->AllocSize = NewSize;
    pWLnum->UsedSize  = 0;
  }
  return(LNUM_OP_OK);
}

extern "C" void FreeWLnumContext(HMEM_CTX_DEF WLNUM_CONTEXT* pCtx)
{
  int Index;
  WLARGENUM** pNumArr;

  if(pCtx == NULL)
    return;
  Index = pCtx->AllocedNumCnt;
  pNumArr = pCtx->pWLnumArr;
  while(Index != 0)
  {
    Index--;
    FreeWLnum(HMEM_CTX_REF1 pNumArr[Index]);
  }
  FREE_ARRAY(HMEM_CTX_REF,pNumArr);
  FREE_ARRAY(HMEM_CTX_REF,pCtx);
}

extern "C" WLNUM_CONTEXT* AllocWLnumContext(HMEM_CTX_DEF
					int NumCnt, int ElementSize)
{
  int Index = 0;
  WLARGENUM** pNumArr;
  WLNUM_CONTEXT* pCtx;

  if((NumCnt <= 0) || (ElementSize < 0))	// should not happen
    return(NULL);
  //------------------------------------------------------
  // Allocate the Structure and the Pointer array
  //------------------------------------------------------
  pCtx    = (WLNUM_CONTEXT*)
	      ((void *) BIT8_ARRAY_CALLOC(HMEM_CTX_REF,1,
				          sizeof(WLNUM_CONTEXT)));
  pNumArr = (WLARGENUM**)
	      ((void *) BIT8_ARRAY_CALLOC(HMEM_CTX_REF,1,
				          sizeof(WLARGENUM*) * NumCnt));
  if(pCtx == NULL)
    return(NULL);
  if(pNumArr == NULL)
  {
    FREE_CARRAY(HMEM_CTX_REF,pCtx);
    return(NULL);    
  }
  pCtx->AllocedNumCnt = NumCnt;
  pCtx->pWLnumArr     = pNumArr;
  //----------------------------------------------------------
  // Allocate the WLNUM Structures and Elements
  //----------------------------------------------------------
  do
  {
    if((pNumArr[Index] = AllocNewWLnum(HMEM_CTX_REF1
				       ElementSize)) == NULL)
      break;
    Index++;
  }while(Index < NumCnt);
  if(Index != NumCnt)
  {
    FreeWLnumContext(HMEM_CTX_REF1 pCtx);
    pCtx = NULL;
  }
  return(pCtx);  
}

extern "C" int GetWLnumFromContext(HMEM_CTX_DEF
			WLNUM_CONTEXT* pCtx, int ElementSize,
			WLARGENUM** ppWLnum)
{
  int Index;
  int* pEl;
  WLARGENUM* pWLnum;
  //------------------------------------------------------
  // Check parameters, remove later !!
  //------------------------------------------------------
  if((pCtx == NULL) || (ppWLnum == NULL))
    return(LNUM_OP_NULL_PTR);
  if(ElementSize < 0)
    return(LNUM_OP_PARAM_ERR);
  //------------------------------------------------------
  // Check if still elements available in Context
  //------------------------------------------------------
  if((Index = pCtx->NextFreeIndex) >= pCtx->AllocedNumCnt)
    return(LNUM_OP_CTX_FULL);
  pWLnum = pCtx->pWLnumArr[Index];
  //------------------------------------------------------
  // Check Size, reallocate if needed
  //------------------------------------------------------
  if(pWLnum->AllocSize < ElementSize)
  {
    if((pEl = BIT32_ARRAY_ALLOC(HMEM_CTX_REF,ElementSize)) == NULL)
      return(LNUM_OP_ALLOC_ERR);
    FREE_CARRAY(HMEM_CTX_REF,pWLnum->lpEl);
    pWLnum->lpEl      = pEl;
    pWLnum->AllocSize = ElementSize;
  }
  pWLnum->UsedSize = 0;
  pCtx->NextFreeIndex = Index + 1;
  ppWLnum[0] = pWLnum;  
  return(LNUM_OP_OK);
}

extern "C" WLARGENUM* GetWLnumPtrFromContext(HMEM_CTX_DEF
		WLNUM_CONTEXT* pCtx, int ElementSize)
{
  int Index;
  int* pEl;
  WLARGENUM* pWLnum;
  //------------------------------------------------------
  // Check parameters, remove later !!
  //------------------------------------------------------
  if((pCtx == NULL) | (ElementSize < 0))
    return(NULL);
  //------------------------------------------------------
  // Check if still elements available in Context
  //------------------------------------------------------
  if((Index = pCtx->NextFreeIndex) >= pCtx->AllocedNumCnt)
    return(NULL);
  pWLnum = pCtx->pWLnumArr[Index];
  //------------------------------------------------------
  // Check Size, reallocate if needed
  //------------------------------------------------------
  if(pWLnum->AllocSize < ElementSize)
  {
    if((pEl = BIT32_ARRAY_ALLOC(HMEM_CTX_REF,ElementSize)) == NULL)
      return(NULL);
    FREE_CARRAY(HMEM_CTX_REF,pWLnum->lpEl);
    pWLnum->lpEl      = pEl;
    pWLnum->AllocSize = ElementSize;
  }
  pWLnum->UsedSize = 0;
  pCtx->NextFreeIndex = Index + 1;
  return(pWLnum);
}

extern "C" void ReleaseWLnumsFromContext(WLNUM_CONTEXT* pCtx,
				int WLnumCnt)
{
  if(pCtx != NULL)
  {
    if((pCtx->NextFreeIndex -= WLnumCnt) < 0)
      pCtx->NextFreeIndex = 0;
  }
  return;
}

//()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()
//()								()
//() Large Number package CORE routines, are trimmed for speed.	()
//() BE EXTREMLY CAREFUL WHEN CHANGING ANY OF THESE ROUTINES !!!()
//()								()
//()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()

//***************************************************************
//*								*
//* 64 Bit Emulation Mode routines				*
//*								*
//* Assumptions:						*
//* - No unsigned types available				*
//* - Largest internal type is a (signed) BIT32			*
//* - No Carry out available from 32Bit Addition/Subtraction	*
//* - No High Word (32Bits) available from 32Bit multiplication	*
//* - No 64Bit by 32Bit Division available			*
//***************************************************************

//***************************************************************
//*								*
//* 64 Bit routines						*
//*								*
//* Assumptions:						*
//* - No unsigned types available				*
//* - Largest internal type is a (signed) BIT64			*
//* - No Carry out available from 64Bit Addition/Subtraction	*
//* - No High Word (64Bits) available from 64Bit multiplication	*
//* - No 64Bit by 32Bit Division available			*
//***************************************************************

/*
* <br>            *               Testpattern for full reduction cycles, i.e. qhat = 4 * <br>            q:
* <br>            ---------------------------------------------------------
* <br>            Dividend: FFFFFFFF 80000000
* <br>            Divisor: 80000001
*/
/**
* Divides 64 bit dividend by 32 bit divisor. Used for division algorithms.
*
* NOTE: Divisor must be B32 normalized, i.e. divisor is >= B32/2 
* 
*  @param uH Dividend high part
*  @param uL Dividend low part
*  @param v Divisor
*  @param pQH Quotient high part
*  @param pQL Quotient low part
*  @return BIT32 Remainder
*/
//NormDiv64By32Bit64

static int NormDiv64By32Bit64(int uH, int uL, int v,
		int* pQH, int* pQL)
{
  long long A63, X31, qhat, rhat2, w;
  //---------------------------------------------------------------------
  // We assume that Dividend and Divisor are represented as follows
  // Dividend = A63*2 + B1
  // Divisor  = X31*2 + Y1
  // First we calculate estimate qhat, rhat.
  // NOTE: if Y1 == 0 qhat will be the desired result for q (max 33 bits)
  // ----- if Y1 == 1 qhat must be checked for reduce (up to 4 times)
  //---------------------------------------------------------------------

  A63 = ((((long long) uH << 32) | ((long long) uL & ((long long)0x0FFFFFFFFLL))) >> 1) &
        ((long long)0x07FFFFFFFFFFFFFFFLL);
  w   = (long long) v & ((long long)0x0FFFFFFFFLL);

  X31 = (w >> 1) & ((long long)0x07FFFFFFFLL);

  qhat  = A63 / X31;				// 0 <= qhat <= 2**33 - 1
  rhat2 = ((A63 - (qhat * X31)) << 1) + 	// 0 <= rhat2 < X31*2 + 1
          ((long long) uL & ((long long)0x01LL));

//  PRINT("qhat = ");
//  PRINT_HEX_BIT64((BIT32) (qhat >> 32), (BIT32) qhat);
//  PRINT(" rhat2 = ");
//  PRINT_HEX_BIT32_NL((BIT32) rhat2);
  
  //--------------------------------------------------------------------
  // Check special reduce case (Y1 == 1)
  //--------------------------------------------------------------------
  if((v & 0x01) != 0)				// Y1 == 1
  {
    //---------------------------------------------------------------------
    // Y1 is *NOT* 0, must subtract qhat to get remainder
    // NOTE: we use the fact that we have to add V in total as
    // ----- X31*2 + 1 (for qhat reduction correction) == v for Y1 == 1 !!
    //---------------------------------------------------------------------
    rhat2 -= qhat;				// r = rhat*2 + B1 - qhat
//  PRINT("w = ");
//  PRINT_HEX_BIT64((BIT32) (w >> 32), (BIT32) w);

//  PRINT(" rem = ");
//  PRINT_HEX_BIT64_NL((BIT32) (rem >> 32), (BIT32) rem);

    while(rhat2 < 0)				// reduction loop
    {
//    PRINT("Reduce, ");
      qhat--;					// reduce estimate
      rhat2 += w;				// r = r + 2*X31 - 1
//    PRINT(" rem = ");
//    PRINT_HEX_BIT64_NL((BIT32) (rem >> 32), (BIT32) rem);
    }
  }
  pQH[0] = (int) ((qhat >> 32) & 0x01);	// set MSW
  pQL[0] = (int) qhat;			// set LSW
  return((int) rhat2);
}

/**
* Divides 32 bit dividend by 16 bit divisor. Used for word remainder
* calculation.
*
* NOTE: Dividend and Divisor must be normalized, i.e. divisor is >= B16/2 
* 
*  @param u Dividend
*  @param v Divisor (only lower 16 Bits used)
*  @param pQ Quotient. Optional
*  @return BIT32 Remainder
*/
//NormDiv32By16Bit64

static int NormDiv32By16Bit64(int u, int v, int* pQ)
{
  long long Quot, Rem;
  //---------------------------------------------------------------------
  // Divide direct
  //---------------------------------------------------------------------
  if(pQ != NULL)
  {
    Quot = ((long long) u & ((long long)0x0FFFFFFFFLL)) /
            ((long long) v & ((long long)0x0FFFFLL));
    pQ[0] = (int) Quot;
  }
  Rem  = ((long long) u & ((long long)0x0FFFFFFFFLL)) %
         ((long long) v & ((long long)0x0FFFFLL));
  return((int) Rem);
}

/**
* Implements WLnumber addition, using the actual <code>BIT32PTR</code> (HardAddWLnumBit64). 
* The destination may be one of the sources.
*
*  @param uvMinLen Size of smaller number
*  @param pR Result buffer
*  @param pU Summand1 buffer
*  @param pV Summand2 buffer
*  @param uvDifLen Size difference of numbers
*
*  @return == 0 if no Carry out
* <br>            == 1 if Carry out
*/
static int HardAddWLnumBit64(int uvMinLen, int* pR,
		int* pU, int* pV, int uvDifLen)
{
  int Index = 0;
  long long Sum = 0;

  do
  {
    Sum = ((long long) pU[Index] & ((long long)0x0FFFFFFFFLL)) +
          ((long long) pV[Index] & ((long long)0x0FFFFFFFFLL)) +
	  ((Sum >> 32) & ((long long)0x0FFFFFFFFLL));	// u + v + Carry
    pR[Index++] = (int) Sum;			// save value
    uvMinLen--;
  }while(uvMinLen != 0);
  //-------------------------------------------------------
  // propagate the carry if one set or not if needed
  // Note: it is more effective to streamline the code by
  // ----- avoiding decision steps (!)
  //-------------------------------------------------------
  while(uvDifLen != 0)
  {
    Sum = ((long long) pU[Index] & ((long long)0x0FFFFFFFFLL)) +
	  ((Sum >> 32) & ((long long)0x0FFFFFFFFLL));// add Carry
    pR[Index++] = (int) Sum;			// store result
    uvDifLen--;
  }
  return((int) (Sum >> 32));			// -1 > 1
}

/**
* Implements WLnumber subtraction, using the actual <code>BIT32PTR</code> (HardSubWLnumBit64).
* The destination may be one of the sources.
*
* Note: If numbers of different sizes are subtracted, the first
*       number (minuend) must be that with the longer size !
*
*  @param vLen Size of subtrahend
*  @param pR Result buffer
*  @param pU Minuend (1st) buffer
*  @param pV Subtrahend (2nd) buffer
*  @param uvDifLen Size difference of
*               minuend and subtrahend
*
*  @return == 0 if no Borrow out
* <br>            == 1 if Borrow out
*/
static int HardSubWLnumBit64(int vLen, int* pR,
		int* pU, int* pV, int uvDifLen)
{
  int Index = 0;
  long long Dif = 0;

  do
  {
    Dif = ((long long) pU[Index] & ((long long)0x0FFFFFFFFLL)) -
          ((long long) pV[Index] & ((long long)0x0FFFFFFFFLL)) +
	  (Dif >> 32);				// u - v - Borrow [neg. Borrow]
    pR[Index++] = (int) Dif;			// save value
    vLen--;
  }while(vLen != 0);
  //-------------------------------------------------------
  // propagate the borrow if one set or not if needed
  // Note: it is more effective to streamline the code by
  // ----- avoiding decision steps (!)
  //-------------------------------------------------------
  while(uvDifLen != 0)
  {
    Dif = ((long long) pU[Index] & ((long long)0x0FFFFFFFFLL)) +
	  (Dif >> 32);				// "subtract" neg. Borrow
    pR[Index++] = (int) Dif;			// store result
    uvDifLen--;
  }
  return((int) (-Dif));				// -1 > 1
}

/**
* Multiplies two WLarge numbers u and v. Result parameter must be different 
* from u and v (MulWLnumBit64).
*
*  @param pProd Pointer to result
*  @param pU Pointer to Multiplicand u
*  @param pV Pointer to Multiplier v
*  @return 0 on success, error code otherwise
*/
static int MulWLnumBit64(HMEM_CTX_DEF
		WLARGENUM* pProd, WLARGENUM* pU, WLARGENUM* pV)
{
  int  i,j, Retcode, uSize, vSize, MaxSize;

  int k;
  long long Prod, Mul;

  int* pTmpEl2;
  int* pTmpEl1;
  int* pTmpEl0;
//  BIT32ARRAY(pTmp,1);

//  if((pProd == NULL) || (pU == NULL) || (pV == NULL))
//    return(LNUM_OP_NULL_PTR);			// null pointer error
  //------------------------------------------------
  // Check if one (or both) factor is zero
  //------------------------------------------------
  i = pU->UsedSize;
  j = pV->UsedSize;
  if((i<=0) || (j <= 0))
  {
    if((i == 0) || (j == 0) ||
    ((i == 1) && (pU->lpEl[0] == 0)) ||
    ((j == 1) && (pV->lpEl[0] == 0)))
    {
      pProd->UsedSize = 0;			// set Zero
      return(LNUM_OP_OK);
    }
  }
  //-------------------------------------------------
  // check which number is longer...
  //-------------------------------------------------
  MaxSize = i + j;			// get required length
  if(i >= j)
  {
    pTmpEl1 = pU->lpEl;
    pTmpEl0 = pV->lpEl;
    uSize = i;
    vSize = j;
  }
  else
  {
    pTmpEl1 = pV->lpEl;
    pTmpEl0 = pU->lpEl;
    uSize    = j;
    vSize    = i;
  }

  if(pProd->AllocSize < MaxSize)
  {
    if((Retcode = AllocWLnumElements(HMEM_CTX_REF1
				pProd, MaxSize)) != LNUM_OP_OK)
      return(Retcode);
  }
  //------------------------------------------------------------
  // multiply loop 1 (without add)
  //------------------------------------------------------------
  pTmpEl2 = pProd->lpEl;			// Result pointer

  Mul = (long long) pTmpEl0[0] & ((long long)0x0FFFFFFFFLL); // get multiplier
  i = uSize;					// multiplier Count
  j = 0;
  Prod = 0;
  do
  {
    Prod += (((long long) pTmpEl1[j] & ((long long)0x0FFFFFFFFLL)) * Mul);
    pTmpEl2[j++] = (int) Prod;		// store low Element
    Prod = (Prod >> 32) & ((long long)0x0FFFFFFFFLL);// save high part
  }while((--i) != 0);
  pTmpEl2[j] = (int) Prod;			// store saved low element 
  //------------------------------------------------------------
  // multiply loop 2 (with add)
  //------------------------------------------------------------
  i = 0;
  while((++i) < vSize)
  {
    Mul = (long long) pTmpEl0[i] & ((long long)0x0FFFFFFFFLL);	// get multiplier
    j = 0;
    k = i;

    Prod = 0;
    do
    {
      Prod = Prod +
             (((long long) pTmpEl1[j] & ((long long)0x0FFFFFFFFLL)) * Mul) +
             ((long long) pTmpEl2[k] & ((long long)0x0FFFFFFFFLL));
      pTmpEl2[k++] = (int) Prod;			// store low Element
      Prod = (Prod >> 32) & ((long long)0x0FFFFFFFFLL);	// save high part
    }while((++j) < uSize);
    pTmpEl2[k] = (int) Prod;			// store saved Element
  }
  if((Prod & ((long long)0x0FFFFFFFFLL)) == 0)	// check if top element is 0
    MaxSize--;

  pProd->UsedSize = MaxSize;		// set max. size
  return(LNUM_OP_OK);
}
/**
* Implements add and multiply routine used for Montgomery algorithm
* to calculate  c = u + q*v for i=0 to sLen-1,
* and division of c by 2**(w*sLen).
*
* NOTE: As a final carry may be generated size of number c must be
*   at least (2*sLen + 1).
*	 The following modulo reduction will shrink down size of c
*	 to 2*sLen anyway.
*
*  @param aLen Size of number to convert
*  @param pA Input number to convert
*  @param sLen Size of multiplicand V
*  @param pC Result C, size is 2*sLen+1
*  @param pN Multiplicand N (modulus)
*  @param Ni0 Multiplier Ni0 = - n[0]**(-1)
*  @return Size of number
*/

//HardMulAddMontBit64

static int HardMulAddMontBit64(int aLen, int* pA,
		int sLen, int* pC, int* pN, int Ni0)
{
  int cLen,nLen,cIndex,nIndex;
  long long QLong;
  long long Prod, Sum;
  int sIndex = 0;
  //----------------------------------------------------------------
  // copy input number to destination, clear not used elements
  //----------------------------------------------------------------
  memcpy(pC+0,pA+0,(aLen)*4);
  ClearBit32Array(pC,aLen,(2*sLen+1)-aLen);  
  //----------------------------------------------------------------
  // outer loop over sLen (size of modulus)
  //----------------------------------------------------------------
  while(sIndex < sLen)
  {
    nLen   = sLen;
    nIndex = 0;
    cLen   = sLen * 2;
    cIndex = sIndex;
    Prod  = 0;
    Sum   = 0;
    QLong = (long long) ((pC[cIndex] * Ni0) & ((long long)0x0FFFFFFFFLL));

    //---------------------------------------------------------------
    // inner loop, perform multiply and add
    //---------------------------------------------------------------
    do
    {
      //--------------------------------------------------------------
      // Calculate new 64 Bit product add saved 32 High Bits from Last
      // Note: no carry out possible !!
      //--------------------------------------------------------------
      Prod = (((long long) pN[nIndex++] & ((long long)0x0FFFFFFFFLL)) * QLong) +
	      ((Prod >> 32) & ((long long)0x0FFFFFFFFLL));
      //--------------------------------------------------------------
      // Calculate Sum c + q*n with carry
      //--------------------------------------------------------------
      Sum = ((long long) pC[cIndex] & ((long long)0x0FFFFFFFFLL)) +
             (Prod & ((long long)0x0FFFFFFFFLL)) +
             (Sum >> 32);
      pC[cIndex++] = (int) Sum;
      nLen--;
    }while(nLen != 0);
    //----------------------------------------------------------------
    // Calculate topmost C element from remaining Product
    //----------------------------------------------------------------
    Sum = ((long long) pC[cIndex] & ((long long)0x0FFFFFFFFLL)) +
          ((Prod >> 32) & ((long long)0x0FFFFFFFFLL)) +
          (Sum >> 32);
    pC[cIndex++] = (int) Sum;
    Sum >>= 32;
    //----------------------------------------------------------------
    // Check if carry out is set
    //----------------------------------------------------------------
    if(Sum != 0)				// carry, occured...
    {
      //---------------------------------------------------------------
      // add the carry to remaining elements of U
      //---------------------------------------------------------------
      do
      {
        //-------------------------------------------------------------
        // Calculate C + Carry
        //-------------------------------------------------------------
        Sum = ((long long) pC[cIndex] & ((long long)0x0FFFFFFFFLL)) + Sum;
        pC[cIndex++] = (int) Sum;
        Sum >>= 32;
        if(Sum == 0)				// no more carry...
          break;				// exit carry loop
      }while(cIndex < cLen);
    }
    sIndex++;
  }
  //-----------------------------------------------------------
  // Get size of calculated number, i.e. skip leading zeroes
  //-----------------------------------------------------------
  sIndex = 2 * sLen;				// set top element index
  while(sIndex >= 0)
  {
    if(pC[sIndex] != 0)				// found non zero element
      break;
    sIndex--;
  }
  //-----------------------------------------------------------
  // Shift right calculated number by sLen Elements (if appropriate!)
  // NOTE: 1. Start shift at the least significant word of pU to avoid
  // -----    overwrite !!!! 
  //	   2. remaining (non zero) elements can be ignored
  //-----------------------------------------------------------
  sIndex = sIndex-sLen+1;			// resulting used size
  cIndex = 0;					// destination index
  while(cIndex < sIndex)
  {
    pC[cIndex] = pC[cIndex+sLen];		// shift right sLen elements
    cIndex++;
  }
  return(sIndex);				// report used size
}

/**
* Implements subtract and multiply routine used for division algorithm
* to calculate  u - q*v. If Result in too small, backadds v
* and signals that.
*
*  @param vLen length of divisor v
*  @param pU Dividend u
*  @param uIndex Start index for u
*  @param pV Divisor v
*  @param Q Multiplier q
*  @return == 0 no backadd occured
* <br>            != 0 a backadd was performed, reduce Q by 1
*/

//HardMulSubWLnumBit64

static int HardMulSubWLnumBit64(int vLen, int* pU, int uIndex,
		int* pV, int Q)
{

  int vLenSave = vLen;
  int uIndexSave = uIndex;
  int vIndex = 0;
  long long QLong = (long long) Q & ((long long)0x0FFFFFFFFLL);
  long long Prod = 0;
  long long Dif  = 0;
  //---------------------------------------------------------------
  // perform multiply and subtract
  //---------------------------------------------------------------
  do
  {
    //--------------------------------------------------------------
    // Calculate new 64 Bit product add saved 32 High Bits from Last
    // Note: no carry out possible !!
    //--------------------------------------------------------------
    Prod = (((long long) pV[vIndex++] & ((long long)0x0FFFFFFFFLL)) * QLong) +
	    ((Prod >> 32) & ((long long)0x0FFFFFFFFLL));
    //--------------------------------------------------------------
    // Calculate Difference u - q*v with borrow
    //--------------------------------------------------------------
    Dif  = ((long long) pU[uIndex] & ((long long)0x0FFFFFFFFLL)) -
           (Prod & ((long long)0x0FFFFFFFFLL)) +
           (Dif >> 32);
    pU[uIndex++] = (int) Dif;
    vLen--;
  }while(vLen != 0);
  //----------------------------------------------------------------
  // Calculate topmost U element from remaining Product
  //----------------------------------------------------------------
  Dif = ((long long) pU[uIndex] & ((long long)0x0FFFFFFFFLL)) -
        ((Prod >> 32) & ((long long)0x0FFFFFFFFLL)) +
        (Dif >> 32);
  pU[uIndex] = (int) Dif;
  Dif >>= 32;
  //----------------------------------------------------------------
  // Check if borrow out is set
  //----------------------------------------------------------------
  if(Dif == 0)					// no borrow, o.k.
    return(0);
  //---------------------------------------------------------------
  // perform backadd of V to U
  //---------------------------------------------------------------
//  PRINT_NL("Before Backadd");

  Dif = 0;
  vIndex = 0;
  uIndex = uIndexSave;
  do
  {
    //-------------------------------------------------------------
    // Calculate U + V with Carry
    //-------------------------------------------------------------

    Dif = ((long long) pU[uIndex] & ((long long)0x0FFFFFFFFLL)) +
          ((long long) pV[vIndex++] & ((long long)0x0FFFFFFFFLL)) +
          (Dif >> 32);				// positive Carry!
    pU[uIndex++] = (int) Dif;

//    PRINT(" U': ");
//    PRINT_HEX_BIT32(pU[uIndex-1]);

    vLenSave--;
  }while(vLenSave != 0);
  //----------------------------------------------------------
  // Backadd the last Carry Bit to original
  //----------------------------------------------------------
  Dif = pU[uIndex] + (Dif >> 32);
  pU[uIndex] = (int) Dif;
  return(1);					// signal backadd
}
/**
* Calculates the sum of a WLarge
* number and a given <code>BIT32</code> element (AddElementWLnumBit64).
* The source is also the destination.
*
*  @param pWnumU Large number struc.
*  @param Summand Given summand
*  @return 0 on success, error code otherwise
*/
static int AddElementWLnumBit64(HMEM_CTX_DEF
			WLARGENUM* pWnumU, int Summand)
{
  int i,UsedSize;
  long long Sum;
  int* pElu;

  if(pWnumU == NULL)
    return(LNUM_OP_NULL_PTR);
  //----------------------------------------------------------
  // check if necessary size allocated, if not, allocate
  //----------------------------------------------------------
  UsedSize = pWnumU->UsedSize;		// get used size
  if((UsedSize == 0) && (Summand == 0))
    return(LNUM_OP_OK);

  if(pWnumU->AllocSize <= UsedSize)
  {
    if((i = AllocWLnumElements(HMEM_CTX_REF1
			pWnumU, UsedSize+1)) != LNUM_OP_OK)
      return(i);
  }
  pElu = pWnumU->lpEl;			// get base
  if(UsedSize == 0)
  {
    pElu[0] = 0;
    UsedSize++;
    pWnumU->UsedSize = UsedSize;
  }
  //----------------------------------------------------------
  // add up
  //----------------------------------------------------------
  i = 0;					// startindex
  Sum = ((long long) Summand & ((long long)0x0FFFFFFFFLL)); // set Number to add
  do
  {
    Sum = Sum + ((long long) pElu[i] & ((long long)0x0FFFFFFFFLL));// add values
    pElu[i++] = (int) Sum;			// store back
    Sum = Sum >> 32;
    UsedSize--;					// reduce count
  }while(UsedSize != 0);
  //----------------------------------------------------------
  // check for Carry out
  //----------------------------------------------------------
  if(Sum != 0)					// had a carry out
  {
    pElu[i] = 1;				// save carry
    pWnumU->UsedSize++;			// increment valid size
  }
  return(LNUM_OP_OK);
}

/**
* Calculates the difference of a
* WLarge number and a given <code>BIT32</code> element (SubElementWLnumBit64).
* The source is also the destination.
*
* Note: It is assumed that the large number is larger/same than the subtrahend.
*
*  @param pWnumU Large number struc.
*  @param Subtrahend Given subtrahend
*  @return 0 on success, error code otherwise
*/
static int SubElementWLnumBit64(WLARGENUM* pWnumU,
					      int Subtrahend)
{
  int i,j, UsedSize;
  long long Dif;
  int* pElu;

  if(pWnumU == NULL)
    return(LNUM_OP_NULL_PTR);
  //----------------------------------------------------------
  // check if necessary size allocated, if not, allocate
  //----------------------------------------------------------
  UsedSize = pWnumU->UsedSize;		// get used size
  if(UsedSize == 0)				// cannot subtract
    return(LNUM_OP_ZERO_SIZE);
  pElu = pWnumU->lpEl;			// get base
  //----------------------------------------------------------
  // subtract lowest Element, is the only full subtraction (!)
  //----------------------------------------------------------
  i = 0;					// startindex
  Dif = ((long long) pElu[0] & ((long long)0x0FFFFFFFFLL)) -	// generate start value
        ((long long) Subtrahend & ((long long)0x0FFFFFFFFLL));
  pElu[0] = (int) Dif;
  Dif = Dif >> 32;				// get borrow
  UsedSize--;					// reduce count
  j = UsedSize;					// save
  //---------------------------------------------------------
  // propagate Borrow if still set and elements present
  //---------------------------------------------------------
  for(;UsedSize > 0;UsedSize--)
  {
    if(Dif == 0)				// no more borrow, ended
      break;
    i++;					// to next Minuend element

    Dif = ((long long) pElu[i] & ((long long)0x0FFFFFFFFLL)) + Dif;	// propagate the borrow
    pElu[i] = (int) Dif;         
    Dif = Dif >> 32;				// get borrow
  }
  //----------------------------------------------------------
  // check for topmost Element Zero
  //----------------------------------------------------------
  if(pElu[j] == 0)				// top Element zero
    pWnumU->UsedSize--;
  return(LNUM_OP_OK);
}

/**
* Squares a WLnum number u using binomial
* formula. See 32Bit emulation routine for description.
* Destination and source must be different.
*
*  @param pProd Pointer to destination
*  @param pU Pointer to number u
*/

//SquareWLnumBit64

static int SquareWLnumBit64(HMEM_CTX_DEF
					 WLARGENUM* pProd, WLARGENUM* pU)
{
  int Retcode,i;
  int uSize,ProdSize;

  int ind0,ind1,ind2,ind3,j;
  long long Mul, Prod, Carry, p, q;

  int* pElProd;
  int* pElu;
//  BIT32ARRAY(Tmp,1);

// if((pProd == NULL) || (pU == NULL)) return(LNUM_OP_NULL_PTR);

  //------------------------------------------------------------
  // check range of product, clear it
  //------------------------------------------------------------
  uSize = pU->UsedSize;		// get length
  pElu=pU->lpEl;			// get pointer
  ProdSize = uSize * 2;			// needed size
  if(pProd->AllocSize < ProdSize)
  {
    if((Retcode = AllocWLnumElements(HMEM_CTX_REF1
			pProd, ProdSize)) != LNUM_OP_OK)
      return(Retcode);
  }
  pProd->UsedSize = ProdSize;	// set length count
  if(uSize == 0)			// nothing to do !!
    return(LNUM_OP_OK);

  pElProd = pProd->lpEl;		// get pointer
  pElProd[0] = 0;			// clear starting Element
  pElProd[ProdSize-1] = 0;		// clear topmost  Element
  //------------------------------------------------------------
  // calculate 1st partial sum
  //------------------------------------------------------------
  i = uSize - 1;			// figure count - 1
  if(i != 0)				// at least 2 figures
  {
    j = i;				// set for multiply
    ind0 = 1;				// start Source/Destination index

    Prod = 0;				// clear
    Carry = 0;				// dto.
    Mul = (long long) pElu[0] & ((long long)0x0FFFFFFFFLL);// get multiplier, 32 Bits max.
    do
    {
      //--------------------------------------------------
      // Multiply a0 * SUM
      //--------------------------------------------------
      p     = ((long long) pElu[ind0] & ((long long)0x0FFFFFFFFLL)) * Mul;// 64 Bits max.
      q     = (p & ((long long)0x0FFFFFFFFLL)) + Prod + Carry;	// add from Last + Carry
      Carry = (q >> 32);
      pElProd[ind0++] = (int) q;
      Prod  = (p >> 32) & ((long long)0x0FFFFFFFFLL);

    }while((--j) != 0);
    Prod += Carry;			

    pElProd[ind0++] = (int) Prod;		// save stored value
    pElProd[ind0]   = (int) (Prod >> 32);	// dto.
    i--;				// reduce figure count

//    ShowLnum(pProd);

    //----------------------------------------------------------
    // calculate remaining partial sums
    //----------------------------------------------------------
    if(i != 0)				// at least 2 figures
    {
      ind3 = 1+2;			// destination index to 3rd elem.
      ind0 = 1;				// start Source index
      do
      {
        Mul = (long long) pElu[ind0++] & ((long long)0x0FFFFFFFFLL);// get multiplier, incr. index
        ind1 = ind0;			// assign Source index
        ind2 = ind3;			// assign Destination index
	ind3 += 2;

        j = i;				// set for multiply
        Carry = 0;
        Prod  = 0;
        do
        {
          p     = ((long long) pElu[ind1++] & ((long long)0x0FFFFFFFFLL)) * Mul; // a1 * SUM
          Prod += (p & ((long long)0x0FFFFFFFFLL)) +
                  ((long long) pElProd[ind2] & ((long long)0x0FFFFFFFFLL)) +
                  Carry;					 // pos. carry!
          q     = ((p >> 32) & ((long long)0x0FFFFFFFFLL)) +
                  ((Prod >> 32) & ((long long)0x0FFFFFFFFLL));
          Carry = (q >> 32) & ((long long)0x0FFFFFFFFLL);

          pElProd[ind2++] = (int) Prod;
          Prod  = q & ((long long)0x0FFFFFFFFLL);
        }while((--j) != 0);

        Prod += ((long long) pElProd[ind2] & ((long long)0x0FFFFFFFFLL)) +
		Carry;					 // pos. carry
        pElProd[ind2++] = (int) Prod;
        pElProd[ind2]   = (int) (Prod >> 32);
      }while((--i) != 0);
    }

//    ShowLnum(pProd);

    //----------------------------------------------------------
    // multiply actual partial sum times 2 (shift left 1 Bit)
    //----------------------------------------------------------
    i = ProdSize-1;			// number of figures to shift
    Prod = 0;
    ind0 = 1;
    do
    {
      Mul = (long long) pElProd[ind0] & ((long long)0x0FFFFFFFFLL);
      Prod = (Mul << 1) + Prod;
      pElProd[ind0++] = (int) Prod;
      Prod = (Mul >> 31) & 0x01; 		// correct

//    Prod = (Prod >> 32) & 0xFFFFFFFFL;	// wrong !
//    Prod = (Prod >> 33) & 0xFFFFFFFFL;	// also wrong !
    } while((--i) != 0);
  }

//  ShowLnum(pProd);

  //------------------------------------------------------------
  // add up figure squares
  //------------------------------------------------------------
  Prod = 0;
  Carry = 0;
  ind0 = 0;
  ind1 = 0;
  do
  {
    Mul   = (long long) pElu[ind0++] & ((long long)0x0FFFFFFFFLL);
    p     = Mul * Mul;

    Prod = (p & ((long long)0x0FFFFFFFFLL)) +
           ((long long) pElProd[ind1] & ((long long)0x0FFFFFFFFLL)) +
	   Carry;					// pos. carry

    pElProd[ind1++] = (int) Prod;

    Prod = ((Prod >> 32) & ((long long)0x0FFFFFFFFLL)) +
            ((p >> 32) & ((long long)0x0FFFFFFFFLL)) +
            ((long long) pElProd[ind1] & ((long long)0x0FFFFFFFFLL));
    Carry = ((Prod >> 32) & ((long long)0x0FFFFFFFFLL));

    pElProd[ind1++] = (int) Prod;

  }while((--uSize) != 0);

//  ShowLnum(pProd);

  //------------------------------------------------------------
  // check result topmost figure for zero
  //------------------------------------------------------------
  if(pElProd[ind1-1] == 0)
    pProd->UsedSize--;
  return(LNUM_OP_OK);
}
/**
* Calculates qhat from given
* values u[n+m], u[n+m-1], u[n+m-2], v[n-1], v[n-2].
* This is the trial divisor calculation for division.
*
* NOTE: Normalized dividend/divisor is assumed !
*
*  @param pU current dividend
*  @param uIndex Index to topmost element n+m
*  @param vnM1 v[n-1] 
*  @param vnM2 v[n-2] 
*  @return BIT32 qhat
*/

//GetQ32EstimateBit64
static int GetQ32EstimateBit64(int* pU, int uIndex,
		int vnM1, int vnM2)
{
  int TmpH[1];
  int TmpL[1];

  long long Sum1, Sum2, Dif;
  int qhatL, rhat;

  //--------------------------------------------------------
  // calculate: qhat = (u[n+m] || u[n+m-1]) / v[n-1] and
  //            rhat = (u[n+m] || u[n+m-1]) % v[n-1]
  // NOTE: qhat <= 2**32 + 1, rhat < 2**32
  //--------------------------------------------------------
  rhat = NormDiv64By32Bit64(pU[uIndex], pU[uIndex-1], vnM1, TmpH, TmpL);
  qhatL = TmpL[0];

  //--------------------------------------------------------------------
  // Check case, where qhat is either SURE too large, i.e. qhat == 2**32+1
  // or qhat might be too large by one only, i.e qhat == 2**32
  //--------------------------------------------------------------------
  if(TmpH[0] != 0)
  {
    qhatL--;					// reduce by one
    //----------------------------------------------------------------
    // Check special, trivial case: qhat == 2**32+1 ahead.
    // In that case we can always set q == 2**31-1 for the following:
    // 1. q <= 2**32 - 1 MUST hold and
    // 2. qhat - 2 <= q <= qhat
    //----------------------------------------------------------------
    if(qhatL == 0)				// qhat == 2**31+1
    {
      qhatL--;					// use q = 2*+31-1 always
      return(qhatL);
    }
    //----------------------------------------------------------------
    // Case qhat == 2**32, reduce by one and check further
    // NOTE: when reducing qhat, rhat must be increased by v[n-1].
    // ----- if now rhat >= b, no further checking is needed
    //----------------------------------------------------------------
    Sum1 = ((long long) rhat & ((long long)0x0FFFFFFFFLL)) +	// correct for qhat--
           ((long long) vnM1 & ((long long)0x0FFFFFFFFLL));
    if((Sum1 & ((long long)0x0FFFFFFFF00000000LL)) != 0)	// rhat >= b
    {
      return(qhatL);
    }
    //----------------------------------------------------------------
    // Case qhat == 2**32 and rhat' = rhat + vnM1 < b, must
    // check if s = qhat * v[n-2]  >  t = b * rhat' + u[n-m-2]
    //----------------------------------------------------------------
    rhat = (int) Sum1;

    Sum1 = ((long long) vnM2 & ((long long)0x0FFFFFFFFLL)) *		// s
           ((long long) qhatL & ((long long)0x0FFFFFFFFLL));
    Sum2 = ((long long) rhat << 32) +
           ((long long) pU[uIndex-2] & ((long long)0x0FFFFFFFFLL));	// t
    Dif  = Sum2 - Sum1;
    if(((((~Sum2) & Sum1) | (Dif & (~(Sum2^Sum1)))) >> 63) != 0)
    {
      qhatL--;
    }
    return(qhatL);
  }
  //----------------------------------------------------------------
  // In the following cases qhat < 2**32 so may be 1 or 2 too large
  // Calculate: s = qhat * v[n-2] and: t = rhat * 2**32 + u[n+m-2],
  // check if s > t.
  // NOTE: s > t is equivalent to calculate t - s and check for borrow
  //----------------------------------------------------------------

  Sum1 = ((long long) qhatL & ((long long)0x0FFFFFFFFLL)) *
         ((long long) vnM2 & ((long long)0x0FFFFFFFFLL));				 // s
  Sum2 = ((long long) rhat << 32) +
         ((long long) pU[uIndex-2] & ((long long)0x0FFFFFFFFLL));  // t
  Dif  = Sum2 - Sum1;				// t - s
  if(((((~Sum2) & Sum1) | (Dif & (~(Sum2^Sum1)))) >> 63) != 0)
  {
    //---------------------------------------------------------------
    // qhat at least one too large, reduce, increase rhat, check rhat
    //---------------------------------------------------------------

    qhatL--;
    Dif = ((long long) rhat & ((long long)0x0FFFFFFFFLL)) +
          ((long long) vnM1 & ((long long)0x0FFFFFFFFLL));

    if((Dif & ((long long)0x0FFFFFFFF00000000LL)) == 0)	// could be too large
    {
      //----------------------------------------------------------------
      // In the following cases qhat may still be 1 too large
      // Calculate: s = qhat * v[n-2] and: t = rhat * 2**32 + u[n+m-2],
      // check if s > t.
      // NOTE: s > t is equivalent to calculate t - s and check for borrow
      //----------------------------------------------------------------
//    rhat += vnM1;
      Sum1 = ((long long) vnM2 & ((long long)0x0FFFFFFFFLL)) *		// s
             ((long long) qhatL & ((long long)0x0FFFFFFFFLL));

      Sum2 = ((long long) Dif << 32) +
             ((long long) pU[uIndex-2] & ((long long)0x0FFFFFFFFLL));	// t
      Dif  = Sum2 - Sum1;
      if(((((~Sum2) & Sum1) | (Dif & (~(Sum2^Sum1)))) >> 63) != 0)
      {
        qhatL--;
      }
    }
  }
  return(qhatL);
}

//()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()
//
// Only Local Available Basic functions
//
//()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()

/**
* Copies a WLarge numbers <code>BIT32PTR</code> starting at the LSB (HardCpyWLnum).
* Destination and source may be the same and may overlap.
*
* NOTE: Inline where needed direct !!
*
*  @param uSize Length of the number
*  @param pR Destination buffer
*  @param pU Source buffer
*  @param uOffset Source offset
*/
static void HardCpyWLnum(int uSize, int* pR,
		int* pU, int uOffset)
{
  memcpy(pR+0,pU+uOffset,(uSize)*4);
}
/**
* Copies a WLarge numbers <code>BIT32PTR</code> starting at the MSB (HardCpyWLnumTop).
* Destination and source may be the same and may overlap.
*
*  @param uSize Length of the number
*  @param pR Destination buffer
*  @param rOffset Destination offset
*  @param pU Source buffer
*/
static void HardCpyWLnumTop(int uSize, int* pR,
			int rOffset, int* pU)
{
  while(uSize > 0)
  {
    uSize--;				// pre-decrement, use as index
    pR[uSize+rOffset] = pU[uSize];	// Copy Element
  }
}

/**
* Shifts WLarge number left by n bit. Destination may be same as
* source, so shift is started from top of number (HardLshiftnWLnum).
*
* Note: Shiftcount must be in Range 0 < n < 32
*
*  @param nBits Number of bits to shift
*  @param pR Result buffer
*  @param rOffset Destination offset of result
*  @param uLen Size of number in elements
*  @param pU Source buffer
*/

static void HardLshiftnWLnum(int nBits, int* pR,
		int rOffset, int uLen, int* pU)
{
  int uIndex = uLen-1;			// source      top most index
  int rIndex = uIndex + rOffset;		// destination top most index
  int MaskShift = 32 - nBits;		// ??
  int Mask = ~(0xFFFFFFFF << nBits);		// AND Mask
  int Tmp0 = (pU[uIndex] >> MaskShift) & Mask;	// Saver 
  int Tmp1 = (pU[uIndex--] << nBits);		// Saver
  //----------------------------------------------------------------
  // check for left shift out bits in topmost source element
  // if so store at top + 1
  // Note: the calling routine is responsible for correct allocation
  // ----- of required destination size !!!
  //----------------------------------------------------------------
  if(Tmp0 != 0)				// top element shift out occured
    pR[rIndex+1] = Tmp0;		// save as top + 1 element !!!
  //----------------------------------------------------------
  // check if more than one element present in source
  //----------------------------------------------------------
  uLen--;				// reduce count
  while(uLen > 0)			// more elements than one
  {
    Tmp0 = (pU[uIndex] >> MaskShift) & Mask;	// get left outshift
    pR[rIndex--] = Tmp1 | Tmp0;			// store bits in next element
    Tmp1 = pU[uIndex--] << nBits;		// save in Element shifted bits
    uLen--;
  }
  pR[rIndex] = Tmp1;			// save lowest Element
}
/**
* Shift WLarge number left by 1 bit. Destination may be same as
* source (HardLshift1WLnum).
*
* NOTE: The calling routine is responsible for allocation of
*    required destination size if a left shift out occurs.
*
*  @param pR Result buffer
*  @param pU Source buffer
*  @param uLen Size of number in elements
*/
static void HardLshift1WLnum(int* pR, int* pU, int uLen)
{
  int Index = 0;			// index for source and result
  int Tmp0;
  int Tmp1 = 0;
  
  while(uLen > 0)
  {
    Tmp0 = pU[Index];			// fetch Element
    Tmp1 = Tmp0 + Tmp0 - Tmp1;		// add with [negative] Carry
    pR[Index++] = Tmp1;
    Tmp1 = Tmp0 >> 31;			// generate [negative] Carry
    uLen--;
  }
  if(Tmp1 != 0)				// NOTE: do NOT store if no shift out!!
    pR[Index] = 1;			// save remaining bit( ONLY if set)
}
/**
* Shifts WLarge number right by n bit. Destination may be same as
* source and may overlap, so shift is started from bottom of
* number + offset (HardRshiftnWLnum).
*
* Note: Shiftcount must be in Range 0 < n < 32
*
*  @param nBits Number of bits to shift
*  @param pR Result buffer
*  @param uLen Size of number in elements
*  @param pU Source buffer
*  @param uOffset Source offset
*/

static void HardRshiftnWLnum(int nBits, int* pR, int uLen,
		int* pU, int uOffset)
{
  int uIndex = uOffset;				// source index
  int rIndex = 0;				// result index
  int MaskShift = 32 - nBits;			// downshift count

  int Mask = ~(0xFFFFFFFF << MaskShift);	// AND bit mask
  			         	        // for upper elements
  int Tmp0 = (pU[uIndex++] >> nBits) & Mask;	// get startvalue
  int Tmp1;
  int Tmp2 = 0;

  uLen--;					// reduce count
  while(uLen > 0)				// not a single element
  {
    Tmp1 = pU[uIndex++];			// get next source element
    Tmp2 = (Tmp1 >> nBits) & Mask;		// isolate new low bits
    Tmp1 = (Tmp1 << MaskShift) | Tmp0;		// shift left lower,append rest
    pR[rIndex++] = Tmp1;			// save
    Tmp0 = Tmp2;				// save lower bits for next
    uLen--;
  }
  pR[rIndex] = Tmp0;				// save remaining bits
}
/**
* Shifts WLarge number right by 1 bit. Destination may be same as
* source (HardRshift1WLnum).
* Note: Shift is started from bottom of source.
*   (this is the reason for the LEFT(!) shifts)
*
*  @param pR Result buffer
*  @param pU Source buffer
*  @param uLen Size of number in elements
*/
static void HardRshift1WLnum(int* pR, int* pU, int uLen)
{
  int uIndex = 0;				// source index
  int rIndex = 0;				// result index

  int Tmp0 = (pU[uIndex++] >> 1) & 0x7FFFFFFF;// get Bottom startvalue
  int Tmp1;
  int Tmp2 = 0;

  uLen--;
  while(uLen > 0)
  {
    Tmp1 = pU[uIndex++];			// get next source element
    Tmp2 = (Tmp1 >> 1) & 0x7FFFFFFF;		// isolate new lower bits
    Tmp1 = (Tmp1 << 31) | Tmp0;			// shift left (!!)
    pR[rIndex++] = Tmp1;			// save
    Tmp0 = Tmp2;				// save upper bits for next
    uLen--;
  }
  pR[rIndex] = Tmp0;				// save remaining bits
}

//()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()
//
// Global Available Basic functions
//
//()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()

extern "C" int GetBitCntWLnum(WLARGENUM* pNum)
{
  int UsedSize;

  if((pNum == NULL) || ((UsedSize = pNum->UsedSize) == 0))
    return(0);

  return(((UsedSize-1) * 32) +
         HardGetBitCntWLnumElem(pNum->lpEl[UsedSize-1]));
}

extern "C" int GetByteCntWLnum(WLARGENUM* pNum)
{
  int UsedSize;

  if((pNum == NULL) || ((UsedSize = pNum->UsedSize) == 0))
    return(0);

  return(((UsedSize-1) * 4) +
         HardGetByteCntWLnumElem(pNum->lpEl[UsedSize-1]));
}

extern "C" int CopyWLnum(HMEM_CTX_DEF
			WLARGENUM* pDst, WLARGENUM* pSrc)
{
  int Retcode, SrcSize;
  //-------------------------------------------------------
  // Check size of Destination, realloc if needed
  //-------------------------------------------------------
  SrcSize = pSrc->UsedSize;
  if(SrcSize > pDst->AllocSize)		// Dst. Element too small
  {
    if((Retcode = AllocWLnumElements(HMEM_CTX_REF1
			pDst, SrcSize)) != LNUM_OP_OK)
      return(Retcode);
  }
  //-------------------------------------------------------
  // Set Destination used size, copy if data to copy
  //-------------------------------------------------------
  pDst->UsedSize = SrcSize;		// set same used sizes
  if(SrcSize != 0)
    memcpy(pDst->lpEl+0,pSrc->lpEl+0,(SrcSize)*4);
  return(LNUM_OP_OK);
}

extern "C" int UcompWLnum(WLARGENUM* pU, WLARGENUM* pV)
{
  int uIndex = pU->UsedSize;
  int vIndex = pV->UsedSize;
  int Dif;

  int* pElu;
  int* pElv;

  if(uIndex > vIndex) return(WLNUM_1ST_GT_2ND);		// u > v
  if(uIndex < vIndex) return(WLNUM_1ST_LT_2ND);		// u < v
  if(uIndex == 0)     return(WLNUM_1ST_EQ_2ND);		// u = v = 0
  //----------------------------------------------------------
  // Elements have equal size, tougher work to do...
  //----------------------------------------------------------
  pElu = pU->lpEl;				// array base 1st
  pElv = pV->lpEl;				// array base 2nd
  //----------------------------------------------------------
  // Skip Equal Elements till exhausted or difference found
  //----------------------------------------------------------
  uIndex--;						// take care for Single
  while((uIndex >= 0) && (pElu[uIndex] == pElv[uIndex]))
    uIndex--;
  //----------------------------------------------------------
  // Check result now
  //----------------------------------------------------------
  if(uIndex < 0)
    return(WLNUM_1ST_EQ_2ND);				// u == v
  //----------------------------------------------------------
  // Elements are *NOT* same, subtract, check borrow
  //----------------------------------------------------------
  Dif = pElu[uIndex] - pElv[uIndex];			// subtract
  if((
     (((~pElu[uIndex]) & pElv[uIndex]) |
       (Dif & (~(pElu[uIndex]^pElv[uIndex])))) & 0x80000000) != 0)
    return(WLNUM_1ST_LT_2ND);				// had borrow, u < v
  return(WLNUM_1ST_GT_2ND);				// no  borrow, u > v
}  

extern void DoAddcWLnum(WLARGENUM* pSum, WLARGENUM* pU,
		WLARGENUM* pV,int uSize, int vSize)
{
  if(HardAddWLnumBit64(vSize, pSum->lpEl, // dto.
               pU->lpEl, pV->lpEl, uSize-vSize) == 0)
    pSum->UsedSize = uSize;			// set max. used elements

  else						// remaining carry
  {
    pSum->UsedSize = uSize+1;		// one more Element
    pSum->lpEl[uSize] = 1;		// set Carry
  }
}

extern void DoSubbWLnum(WLARGENUM* pDif, WLARGENUM* pU,
		WLARGENUM* pV, int uSize, int vSize)
{
  int i;
  int* pBuf = pDif->lpEl;

  HardSubWLnumBit64(vSize,pDif->lpEl,pU->lpEl, // do sub, ign. Borrow
              pV->lpEl, uSize-vSize);
  //-----------------------------------------------------
  // readjust Used Elementsize after Subtract 
  //-----------------------------------------------------
  for(i = uSize-1;i >=0 ;i--)
  {
    if(pBuf[i] != 0)				// first non zero'ed element
      return;
    pDif->UsedSize--;			// reduce used element count
  }
}

extern "C" int IsZeroWLnum(WLARGENUM* pU)
{
  if(pU->UsedSize == 0) return(1);	// length 0, is zero
  if((pU->UsedSize == 1) &&		// length 1
     (pU->lpEl[0] == 0)) return(1);	// but zero contents
  return(0);					// not zero
}

extern "C" int IsOneWLnum(WLARGENUM* pU)
{
  if((pU->UsedSize == 1) &&		// size must be 1 element
    (pU->lpEl[0] == 1)) return(1);	// value must be one
  return(0);
} 

extern "C" int LshiftWLnum(HMEM_CTX_DEF
			WLARGENUM* pR, WLARGENUM* pU, int sBitcnt)
{
  int Retcode, uSize, MaxSize, sElementCnt;

  int* pElr;
  int* pElu;

  if(IsZeroWLnum(pU) != 0)			// nothing to do
  {
    pR->UsedSize = 0;
    return(LNUM_OP_OK);
  }
  uSize = pU->UsedSize;			// get size
  //-----------------------------------------------------------
  // calculate required Elementcount for destination
  // !!! CHECK THAT !!!
  //-----------------------------------------------------------
  sElementCnt = ((sBitcnt >> 5) & (~(0xFFFFFFFF << (32-5))));

  sBitcnt &= 0x1F;				// get residual bit count
  Retcode = HardGetBitCntWLnumElem(pU->lpEl[uSize-1]); // get Topmost Bitcount
  MaxSize = sElementCnt + uSize;		// required size
  if((Retcode + sBitcnt) > 32)			// check for shift out
    MaxSize ++;					// shift out, one more element
  //----------------------------------------------------------------
  // allocate required dest. buffer if necessary
  //----------------------------------------------------------------
  if(pR->AllocSize < MaxSize)
  {
    if((Retcode = AllocWLnumElements(HMEM_CTX_REF1
			pR, MaxSize)) != LNUM_OP_OK)
      return(Retcode);
  }
  //----------------------------------------------------
  // prepare for doing shift
  //----------------------------------------------------
  pElr = pR->lpEl;			// get result base
  pElu = pU->lpEl;			// get source base
  pR->UsedSize = MaxSize;			// set new size result
  //----------------------------------------------------
  // check if only full elements to shift left
  //----------------------------------------------------
  if(sBitcnt == 0)				// no residual bits
  {
    //--------------------------------------------------
    // full elements to shift left, special case
    //--------------------------------------------------
    HardCpyWLnumTop(uSize,pElr,sElementCnt,pElu);// copy others TOP->BOTTOM !!
  }
  else
  {
    //--------------------------------------------------
    // real  b i t  shift required...
    //--------------------------------------------------
    HardLshiftnWLnum(sBitcnt,pElr,sElementCnt,uSize,pElu); // do shift
  }
  //----------------------------------------------------
  // post-process (clear) unused elements
  //----------------------------------------------------
  if(sElementCnt != 0)					// we had a dst. offset <> 0
    ClearBit32Array(pElr,0,sElementCnt);
  return(LNUM_OP_OK);    
}

extern "C" int Lshift1WLnum(HMEM_CTX_DEF
			WLARGENUM* pR, WLARGENUM* pU)
{
  int Retcode, uSize, MaxSize;

// ???????????? can this case be removed ????

  if(IsZeroWLnum(pU) != 0)			// nothing to do
  {
    pR->UsedSize = 0;
    return(LNUM_OP_OK);
  }

  uSize = pU->UsedSize;
  MaxSize = uSize;

  //----------------------------------------------------
  // check if shift out will occur
  //----------------------------------------------------
  if((pU->lpEl[uSize-1] & 0x80000000) != 0) // shift out
    MaxSize++;
  //----------------------------------------------------
  // allocate required dest. buffer
  //----------------------------------------------------
  if(pR->AllocSize < MaxSize)
  {
    if((Retcode = AllocWLnumElements(HMEM_CTX_REF1
			pR, MaxSize)) != LNUM_OP_OK)
      return(Retcode);
  }
  pR->UsedSize = MaxSize;
  HardLshift1WLnum(pR->lpEl,pU->lpEl,uSize);	// do shift
  return(LNUM_OP_OK);    
}

extern "C" int RshiftWLnum(HMEM_CTX_DEF
			WLARGENUM* pR, WLARGENUM* pU, int sBitcnt)
{
  int Retcode, ui, uSize, MaxSize, sElementCnt;

  if(IsZeroWLnum(pU) != 0)			// nothing to do
  {
    pR->UsedSize = 0;
    return(LNUM_OP_OK);
  }
  uSize = pU->UsedSize;
  //-----------------------------------------------------------
  // calculate remaining byte/elementcount for dest.
  //-----------------------------------------------------------
  sElementCnt = (sBitcnt >> 5) &		// get element count
       (~(0xFFFFFFFF << (32-5)));

  sBitcnt &= 0x1F;				// get residual bit count
  ui = HardGetBitCntWLnumElem(pU->lpEl[uSize-1]);// get Topmost Bitcount

  if((sElementCnt >= uSize) ||			// all zeroed !!
    ((sElementCnt == (uSize-1)) && (sBitcnt >= ui))) // dto.
  {
    pR->UsedSize = 0;			// 0
    return(LNUM_OP_OK);
  }

  MaxSize = uSize - sElementCnt;
  pR->UsedSize = MaxSize;
  //-----------------------------------------------------------
  // check if destination has appropriate size for shift
  //-----------------------------------------------------------
  if(pR != pU)					// DST not same as SRC
  {
    if(pR->AllocSize < MaxSize)		// must alloc/realloc
    {
      if((Retcode = AllocWLnumElements(HMEM_CTX_REF1
			pR, MaxSize)) != LNUM_OP_OK)
        return(Retcode);
    }
  }
  //--------------------------------------------------------------
  // check if only whole elements to shift right
  //--------------------------------------------------------------
  if(sBitcnt == 0)				// no residual bits
  {
    HardCpyWLnum(MaxSize,pR->lpEl,pU->lpEl,sElementCnt); // copy others
  }
  else						// residual bits
  {
    HardRshiftnWLnum(sBitcnt,pR->lpEl,MaxSize,
		     pU->lpEl,sElementCnt);	// do shift
    if(pR->lpEl[MaxSize-1] == 0)		// check top
      pR->UsedSize--;			// is zero, reduce
  }
  return(LNUM_OP_OK);    
}

extern "C" int Rshift1WLnum(HMEM_CTX_DEF
				    WLARGENUM* pR, WLARGENUM* pU)
{
  int Retcode, uSize;

//
// ?????? can the following trivial cases be removed ???
//
  if(IsZeroWLnum(pU) != 0)			// nothing to do
  {
    pR->UsedSize = 0;
    return(LNUM_OP_OK);
  }
  uSize = pU->UsedSize;
  if((uSize == 1) &&
     ((pU->lpEl[0] & 0xFFFFFFFE) == 0))	// only one bit present
  {
    pR->UsedSize = 0;
    return(LNUM_OP_OK);
  }

  pR->UsedSize = uSize;
  if(pR != pU)
  {
    if(pR->AllocSize < uSize)
    {
      if((Retcode = AllocWLnumElements(HMEM_CTX_REF1
			pR, uSize)) != LNUM_OP_OK)
      return(Retcode);
    }
  }
  HardRshift1WLnum(pR->lpEl,pU->lpEl,uSize); // do shift
  if(pR->lpEl[uSize-1] == 0)		// check for topmost element == 0
    pR->UsedSize--;
  return(LNUM_OP_OK);    
}

extern "C" int AddWLnum(HMEM_CTX_DEF
		WLARGENUM* pSum, WLARGENUM* pU, WLARGENUM* pV)
{
  int Retcode, uSize, vSize, MaxSize;

//  if((pU == NULL) || (pV == NULL) || (pSum == NULL))
//    return (LNUM_OP_NULL_PTR);		// error, no structure
  uSize = pU->UsedSize;
  vSize = pV->UsedSize;

// ???? can the simple cases be removed ??????
  //----------------------------------------
  // check for one or both zero
  //----------------------------------------
  if((uSize == 0) || (vSize == 0))
  {
    if((uSize == 0) && (vSize == 0))
    {
      pSum->UsedSize = 0;			// Zero length
      return(LNUM_OP_OK);
    }
    if(uSize == 0)				// 1st is zero, 2nd not !
    {
      if(pSum != pV)
        return(CopyWLnum(HMEM_CTX_REF1
			 pSum,pV));		// just copy 2nd number
      return(LNUM_OP_OK);			// no copy needed !!
    }
    else  
    {
      if(pSum != pU)
        return(CopyWLnum(HMEM_CTX_REF1
			 pSum, pU));		// just copy 1st number
      return(LNUM_OP_OK);			// no copy needed !!
    }
  }
  //-----------------------------------------------
  // both valid, get maximum requested sum length
  //-----------------------------------------------
  MaxSize = uSize;				// assume u > v
  if(MaxSize < vSize)
    MaxSize = vSize;
  MaxSize ++;					// get maximum required length

  if(pSum->AllocSize < MaxSize)		// too small yet
  {
    if((Retcode = AllocWLnumElements(HMEM_CTX_REF1
			pSum, MaxSize)) != LNUM_OP_OK)
      return(Retcode);
  }

  if(uSize >= vSize)
  {
    pSum->UsedSize = uSize;		// preset size
    DoAddcWLnum(pSum, pU, pV, uSize, vSize);	// add up, u >= v
  }
  else
  {
    pSum->UsedSize = vSize;		// preset size
    DoAddcWLnum(pSum, pV, pU, vSize, uSize);	// add up, u < v
  }
  return(LNUM_OP_OK);
}

extern "C" int AddElementWLnum(HMEM_CTX_DEF
				WLARGENUM* pWnumU, int Summand)
{
  return(AddElementWLnumBit64(HMEM_CTX_REF1 pWnumU,Summand));
}

extern "C" int SubWLnum(HMEM_CTX_DEF
			WLARGENUM* pDif,	WLARGENUM* pU, WLARGENUM* pV)
{
  int Retcode, i, uSize, vSize, MaxSize;

//  if((pU == NULL) || (pV == NULL) || (pDif == NULL))	// error, no structure
//    return(LNUM_OP_NULL_PTR);

// ?????? can the trivial cases be removed ????

  uSize = pU->UsedSize;
  vSize = pV->UsedSize;
  if((uSize == 0) && (vSize == 0))
  {
    pDif->UsedSize = 0;			// Zero length
    return(LNUM_OP_OK);
  }
  if(uSize == 0)				// 1st is zero, 2nd not !
  {
    if(pDif != pV)
      return(CopyWLnum(HMEM_CTX_REF1
		       pDif, pV));		// only copy 2nd number
    return(LNUM_OP_OK);				// no copy needed !!
  }
  if(vSize == 0)				// 2nd is zero, 1st not !
  {
    if(pDif != pU)
      return(CopyWLnum(HMEM_CTX_REF1
		       pDif, pU));		// only copy 1st number
    return(LNUM_OP_OK);				// no copy needed !!
  }

 // both valid, get max. required length
  if(uSize >= vSize)
    MaxSize = uSize + 1;
  else
    MaxSize = vSize + 1;

  if(pDif->AllocSize < MaxSize)			// too small yet
  {
    if((Retcode = AllocWLnumElements(HMEM_CTX_REF1
			pDif, MaxSize)) != LNUM_OP_OK)
      return(Retcode);
  }

  if((i = UcompWLnum(pU,pV)) == WLNUM_1ST_EQ_2ND)// check which is smaller
  {						// same numbers, yields zero
    pDif->UsedSize = 0;			// 0
  }
  else
  {
    if(i == WLNUM_1ST_GT_2ND)
    {
      pDif->UsedSize = uSize;		// preset size
      DoSubbWLnum(pDif, pU, pV, uSize,vSize);	// subtract, u >= v
    }
    else
    {
      pDif->UsedSize = vSize;		// preset size
      DoSubbWLnum(pDif, pV, pU, vSize, uSize);	// subtract, u < v
    }
  }
  return(LNUM_OP_OK);
}

extern "C" int SubElementWLnum(WLARGENUM* pWnumU, int Subtrahend)
{
  return(SubElementWLnumBit64(pWnumU, Subtrahend));
}

extern "C" int MulWLnum(HMEM_CTX_DEF
			WLARGENUM* pProd, WLARGENUM* pU, WLARGENUM* pV)
{
  return(MulWLnumBit64(HMEM_CTX_REF1 pProd, pU, pV));
}

extern "C" int SquareWLnum(HMEM_CTX_DEF
				   WLARGENUM* pProd, WLARGENUM* pU)
{
  return(SquareWLnumBit64(HMEM_CTX_REF1 pProd, pU));
}

/**
* Calculates u[n-1,n-2,..,0] / B (HardDiv32Single).
* This is a special case for short divisors (1 element in size).
*
* NOTE: Divisor must not be 0.
*
*  @param uLen Size of dividend
*  @param pQ Pointer to quotient. Optional
*  @param pRem Pointer to remainder. Optional
*  @param pU Pointer to dividend
*  @param v Divisor element
*/
static void HardDiv32Single (int uLen, int* pQ,
		int* pRem, int* pU, int v)
{
  int SrcIndex = uLen-1;
  int DstIndex = uLen-1;
  int d, sh;
  int uH, uL, MH, MR;
  int TmpQH[1];
  int TmpQL[1];
  //-----------------------------------------------------------
  // Check if Dividend is already normalized
  //-----------------------------------------------------------
  if((v & 0x80000000) != 0)			// IS normalized !
  {
    uH = 0;
    if(pQ != NULL)				// with quotient
    {
      while(SrcIndex >= 0)
      {
        //------------------------------------------------------
        // Divide REM, u[i] by v, store quotient
        //------------------------------------------------------
        uH = NormDiv64By32Bit64(uH, pU[SrcIndex--], v, TmpQH, TmpQL);
        pQ[DstIndex--] = TmpQL[0];
      }
    }
    else					// no quotient
    {
      while(SrcIndex >= 0)
      {
        //------------------------------------------------------
        // Divide REM, u[i] by v, store quotient
        //------------------------------------------------------
        uH = NormDiv64By32Bit64(uH, pU[SrcIndex--], v, TmpQH, TmpQL);
      }
    }
    if(pRem != NULL)
      pRem[0] = uH;
    return;
  }
  //-----------------------------------------------------------
  // Dividend is NOT normalized, normalize it
  //-----------------------------------------------------------
  d = 32 - HardGetBitCntWLnumElem(v);		// get normalize shift
  v <<= d;					// normalize Divisor

  sh = 32 - d;					// uH Right Shift count
  MH = 0x7FFFFFFF >> (31-d);			// uH Mask after Right Shift

  MR = 0x7FFFFFFF >> (d-1);
  //--------------------------------------------------------
  // Setup processing Start
  //--------------------------------------------------------
  uH = (pU[SrcIndex] >> sh) & MH;
  uL = pU[SrcIndex] << d;
  SrcIndex--;
  while(SrcIndex >= 0)
  {
    //------------------------------------------------------
    // insert next Dividend Element High Bits, Divide
    //------------------------------------------------------
    uL = uL | ((pU[SrcIndex] >> sh) & MH);
    uH = NormDiv64By32Bit64(uH, uL, v, TmpQH, TmpQL);
    if(pQ != NULL)
      pQ[DstIndex--] = TmpQL[0];
    uL = pU[SrcIndex--] << d;
//    SrcIndex--; // seems to be wrong !! --> IS DEFINITLY WRONG
  }
  //--------------------------------------------------------
  // Final Division Step
  //--------------------------------------------------------
  uH = NormDiv64By32Bit64(uH, uL, v, TmpQH, TmpQL);
  if(pQ != NULL)
    pQ[DstIndex--] = TmpQL[0];

  if(pRem != NULL)
    pRem[0] = (uH >> d) & MR;
}

extern "C" int DivWLnum(HMEM_CTX_DEF
		WLARGENUM* pQuot, WLARGENUM* pRem,
		WLARGENUM* pU, WLARGENUM* pV, WLNUM_CONTEXT* pCtx)
{
  int Retcode, i, NormalShift, LoopCnt, uSize, vSize;

  int uIndex;					// index into number u
  int vIndex;					// index into number v

  WLARGENUM* pNumU;
  WLARGENUM* pNumV = NULL;
  WLARGENUM* ppTmpWLnum[1];
  WLNUM_CONTEXT* pTmpCtx = NULL;

  int qhatL, vnM1, vnM2;

  int* pEluBase;
  int* pElvBase;
  int* pElQuot;
  int* pElRem;
  int WLnumReleaseCnt = 0;
  //------------------------------------------------------------
  // Check for null-pointers and Divisor == Zero
  //------------------------------------------------------------
//  if(((quot == NULL) && (rem == NULL)) || (u == NULL) || (v == NULL))
//    return(LNUM_OP_NULL_PTR);			// null pointer error
  if(IsZeroWLnum(pV) != 0)
    return LNUM_OP_ZERO_DIV;			// Divide by zero err.
  //----------------------------------------------------
  // check if division is required i.e. u > v
  //----------------------------------------------------
  i = UcompWLnum(pU, pV);			// check DIVIDEND >= DIVISOR
  if(i == WLNUM_1ST_EQ_2ND)			// 1st is equal to 2nd
  {
    //--------------------------------------------------
    // u == v: --> quotient = 1, remainder = 0
    //--------------------------------------------------
    if(pRem != NULL)				// remainder requested
      pRem->UsedSize = 0;			// set zero
    if(pQuot != NULL)				// quotient requested
    {
      if(pQuot->lpEl == NULL)		// no Element Allocated
      {
        if((pQuot->lpEl = BIT32_ARRAY_ALLOC(HMEM_CTX_REF,1)) == NULL)
          return(LNUM_OP_ALLOC_ERR);
      }
      pQuot->UsedSize = 1;		// set length 1 Element
      pQuot->lpEl[0] = 1;			// set Quotient
    }
    return(LNUM_OP_OK);
  }

  else if(i == WLNUM_1ST_LT_2ND)		// u < v
  {
    //--------------------------------------------------
    // u < v: --> quotient = 0, remainder = v
    //--------------------------------------------------
    if(pQuot != NULL)
      pQuot->UsedSize = 0;		// set zero
    if((pRem != NULL) && (pRem != pU))
      return(CopyWLnum(HMEM_CTX_REF1
		       pRem, pU));		// copy u -> remainder
    return(LNUM_OP_OK);
  }
  //====================================================================
  // u > v, real work must be done !
  //====================================================================
  //
  //--------------------------------------------------------------------
  // check for vsize == 1 first
  //--------------------------------------------------------------------
  pElQuot  = NULL;				// pre-Initialize
  pElRem   = NULL;				// dto.
  uSize    = pU->UsedSize;
  vSize    = pV->UsedSize;
  pEluBase = pU->lpEl;			// set base pointer
  if(vSize == 1)				// easier way to use
  {
    //--------------------------------------------------
    // special case, divide by a single Element only
    //--------------------------------------------------
    if(pRem != NULL)				// remainder requested
    {
      if(pRem->AllocSize == 0)		// check if remainder allocated
      {
        if((pRem->lpEl = BIT32_ARRAY_ALLOC(HMEM_CTX_REF,1)) == NULL)	// alloc error
          return(LNUM_OP_ALLOC_ERR);
      }
      pElRem = pRem->lpEl;		// set pointer
      pRem->UsedSize = 1;			// preset length
    }
    if(pQuot != NULL)				// quotient requested
    {
      if(pQuot->AllocSize < uSize)
      {
        if((Retcode = AllocWLnumElements(HMEM_CTX_REF1
			pQuot, uSize)) != LNUM_OP_OK)
        return(Retcode);
      }
      pElQuot = pQuot->lpEl;		// set pointer to bottom
    }
    HardDiv32Single(uSize, pElQuot, pElRem,
		    pEluBase, pV->lpEl[0]);	// do divide
    if(pQuot != NULL)				// get true quotient length
    {
      do
      {
        if(pElQuot[uSize-1] != 0) break;	// first non zero digit found
        uSize--;
      } while(uSize != 0);
      pQuot->UsedSize = uSize;		// set true size
    }

    if(pRem != NULL)				// get true remainder length
    {
      pRem->UsedSize = 1;			// preset length
      if(pElRem[0] == 0)			// is zero, special case
        pRem->UsedSize = 0;		// true size
    }
    return(LNUM_OP_OK);
  }
  //===========================================================
  // The long, hard way needed
  //===========================================================
  pElvBase = pV->lpEl;			// set base pointer
  vIndex = vSize - 1;				// index to v[n-1]
  NormalShift = 0;
  LoopCnt = uSize - vSize;
  //-----------------------------------------------------------------
  // if no Context given, allocate one with 2 Elements of proper size
  //-----------------------------------------------------------------
  if(pCtx == NULL)
  {
    if((pTmpCtx = AllocWLnumContext(HMEM_CTX_REF1 2, uSize+1)) == NULL)
      return(LNUM_OP_ALLOC_ERR);
    pCtx = pTmpCtx;
  }
  //----------------------------------------------------------
  // calculate Divisor normalization shift (v[n-1] >= b/2)
  // if required allocate temporary divisor and do shift
  //----------------------------------------------------------
  if((pElvBase[vIndex] & 0x80000000) == 0)	//not normalized
  {
//    PRINT_NL("DivLong do normalize");
    NormalShift = 32 - 				// Element size -
      HardGetBitCntWLnumElem(pElvBase[vIndex]);	// Topmost Element Bitcount

//    PRINT("Shift up count is: ");
//    PRINT_INT_NL(NormalShift);

    if((Retcode = GetWLnumFromContext(HMEM_CTX_REF1
			pCtx, vSize, ppTmpWLnum)) != LNUM_OP_OK)
    {
      FreeWLnumContext(HMEM_CTX_REF1 pTmpCtx);
      return(Retcode);
    }
    WLnumReleaseCnt++;

    pNumV = ppTmpWLnum[0];
    LshiftWLnum(HMEM_CTX_REF1
		pNumV, pV ,NormalShift);	// shift up
    pElvBase = pNumV->lpEl;		// set base pointer

//    PRINT_NL("Top Divisor Element now: ");
//    PRINT_HEX_BIT32_NL(pElvBase[vIndex]);

  }
  vnM1 = pElvBase[vIndex--];			// get v[n-1]
  vnM2 = pElvBase[vIndex];			// get v[n-2]
  //----------------------------------------------------------
  // Allocate temporary Dividend Element and normalize
  //----------------------------------------------------------
  uIndex = uSize;				// required length, minimum
  if((NormalShift +
        HardGetBitCntWLnumElem(pU->lpEl[uIndex-1])) >= 32) //  u[n-1]
  {
    uIndex++;					// one more element required
    LoopCnt++;					// one more round
  }

  if((Retcode = GetWLnumFromContext(HMEM_CTX_REF1
			pCtx, uIndex, ppTmpWLnum)) != LNUM_OP_OK)
  {
    if(pTmpCtx != NULL)
    {
      FreeWLnumContext(HMEM_CTX_REF1 pTmpCtx);
    }
    else
      ReleaseWLnumsFromContext(pCtx, WLnumReleaseCnt);
    return(Retcode);
  }
  WLnumReleaseCnt++;
  pNumU = ppTmpWLnum[0];
  pEluBase = pNumU->lpEl;			// set base pointer

  if(uIndex != uSize)				// one more element allocated
  {
    pEluBase[uSize] = 0;			// clear topmost Element
    LshiftWLnum(HMEM_CTX_REF1
		pNumU, pU, NormalShift);	// normalize
  }
  else						// usize > vsize as u > v !
  {
    if(NormalShift == 0)			// no shift required
      CopyWLnum(HMEM_CTX_REF1
		pNumU, pU);			// only copy to tmp
    else
      LshiftWLnum(HMEM_CTX_REF1
		  pNumU, pU, NormalShift);	// assure u/v consistency
  }
  //----------------------------------------------------------
  // resize Quotient Element if required
  //----------------------------------------------------------
  if(pQuot != NULL)				// Q: Element required ?
  {						//  Y: check/reallocate
    if(pQuot->AllocSize < LoopCnt)
    {
      if((Retcode = AllocWLnumElements(HMEM_CTX_REF1
			pQuot, LoopCnt)) != LNUM_OP_OK)
      {
        if(pTmpCtx != NULL)
        {
          FreeWLnumContext(HMEM_CTX_REF1 pTmpCtx);
        }
        else
          ReleaseWLnumsFromContext(pCtx, WLnumReleaseCnt);
        return(Retcode);			// error occured
      }
    }
    pElQuot = pQuot->lpEl;		// preset pointer
    pQuot->UsedSize = LoopCnt;		// preset quotient size
  }

  //----------------------------------------------------------
  // Division loop
  //----------------------------------------------------------
  do
  {
    uIndex--;			// number u access index TOP
    LoopCnt --;			// predecrement count, now can be used as index!
				// for u BASE
    //--------------------------------------------------------
    // get estimate qhat for quotient q
    //--------------------------------------------------------
    qhatL = GetQ32EstimateBit64(pEluBase, uIndex, vnM1, vnM2);

    //--------------------------------------------------------
    // Perform multiply and subtraction
    //--------------------------------------------------------
    if(HardMulSubWLnumBit64(vSize,			// ui = ui - qi * v
                         pEluBase,LoopCnt,pElvBase, qhatL) != 0)
    {
      qhatL--;						// reduce estimate
    }

    //--------------------------------------------------------
    // Store Quotient digit if requested
    //--------------------------------------------------------
    if(pQuot != NULL)				// buffer present
      pElQuot[LoopCnt] = qhatL;			// store digit
  } while(LoopCnt != 0);			// End of Division Loop
  //----------------------------------------------------------
  // Correct length of Quotient if requested
  //----------------------------------------------------------
  if(pQuot != NULL)
  {
    if(pElQuot[pQuot->UsedSize-1] == 0)	// zero element on top,
      pQuot->UsedSize --;		// reduce size
  }
  //----------------------------------------------------------
  // if Remainder requested, renormalize Reminder (from lnumu)
  //----------------------------------------------------------
  Retcode = LNUM_OP_OK;
  if(pRem != NULL)				// remainder requested
  {
    uSize = pNumU->UsedSize;		// get figure count (> 0!)
    i = uSize - 1;				// top element index
    do
    {
      if(pEluBase[i--] != 0) break;		// figure <> 0
        uSize--;
    } while (uSize != 0);
    pNumU->UsedSize = uSize;		// max. used figures
    if(uSize == 0)				// remainder is zero
      pRem->UsedSize = 0;			// is Zero
    else
    {
      if(NormalShift == 0)			// no shift required
        Retcode = CopyWLnum(HMEM_CTX_REF1
			    pRem, pNumU);	// only copy buffer
      else
        Retcode = RshiftWLnum(HMEM_CTX_REF1
			pRem,pNumU,NormalShift);// do normalize shift right
    }
  }
  if(pTmpCtx != NULL)
  {
    FreeWLnumContext(HMEM_CTX_REF1 pTmpCtx);
  }
  else
    ReleaseWLnumsFromContext(pCtx, WLnumReleaseCnt);
  return(Retcode);
}

extern "C" int QuotWLnum(HMEM_CTX_DEF
	WLARGENUM* pQuot, WLARGENUM* pU, WLARGENUM* pV, WLNUM_CONTEXT* pCtx)
{
  int Retcode, i, NormalShift, LoopCnt, uSize, vSize;

  int uIndex;					// index into number u
  int vIndex;					// index into number v

  WLARGENUM* pNumU;
  WLARGENUM* pNumV = NULL;
  WLARGENUM* ppTmpWLnum[1];
  WLNUM_CONTEXT* pTmpCtx = NULL;

  int qhatL, vnM1, vnM2;

  int* pEluBase;
  int* pElvBase;
  int* pElQuot;
  int WLnumReleaseCnt = 0;
  //------------------------------------------------------------
  // Check for null-pointers and Divisor == Zero
  //------------------------------------------------------------
//  if(((pQuot == NULL) && (pRem == NULL)) || (pU == NULL) || (pV == NULL))
//    return(LNUM_OP_NULL_PTR);			// null pointer error
  if(IsZeroWLnum(pV) != 0)
    return LNUM_OP_ZERO_DIV;			// Divide by zero err.
  //----------------------------------------------------
  // check if division is required i.e. u > v
  //----------------------------------------------------
  i = UcompWLnum(pU, pV);			// check DIVIDEND >= DIVISOR
  if(i == WLNUM_1ST_EQ_2ND)			// 1st is equal to 2nd
  {
    //--------------------------------------------------
    // u == v: --> quotient = 1, remainder = 0
    //--------------------------------------------------
    if(pQuot->lpEl == NULL)		// no Element Allocated
    {
      if((pQuot->lpEl = BIT32_ARRAY_ALLOC(HMEM_CTX_REF,1)) == NULL)
        return(LNUM_OP_ALLOC_ERR);
    }
    pQuot->UsedSize = 1;		// set length 1 Element
    pQuot->lpEl[0] = 1;			// set Quotient
    return(LNUM_OP_OK);
  }
  else if(i == WLNUM_1ST_LT_2ND)		// u < v
  {
    //--------------------------------------------------
    // u < v: --> quotient = 0, remainder = v
    //--------------------------------------------------
    pQuot->UsedSize = 0;			// set zero
    return(LNUM_OP_OK);
  }
  //====================================================================
  // u > v, real work must be done !
  //====================================================================
  //--------------------------------------------------------------------
  // check for vsize == 1 first
  //--------------------------------------------------------------------
  pElQuot  = NULL;				// pre-Initialize
  uSize    = pU->UsedSize;
  vSize    = pV->UsedSize;
  pEluBase = pU->lpEl;			// set base pointer
  if(vSize == 1)				// easier way to use
  {
    //--------------------------------------------------
    // special case, divide by a single Element only
    //--------------------------------------------------
    if(pQuot->AllocSize < uSize)
    {
      if((Retcode = AllocWLnumElements(HMEM_CTX_REF1
			pQuot, uSize)) != LNUM_OP_OK)
      return(Retcode);
    }
    pElQuot = pQuot->lpEl;		// set pointer to bottom
    HardDiv32Single(uSize, pElQuot, NULL,
		    pEluBase, pV->lpEl[0]);	// do divide
    do
    {
      if(pElQuot[uSize-1] != 0) break;	// first non zero digit found
      uSize--;
    } while(uSize != 0);
    pQuot->UsedSize = uSize;		// set true size
    return(LNUM_OP_OK);
  }
  //===========================================================
  // The long, hard way needed
  //===========================================================
  pElvBase = pV->lpEl;			// set base pointer
  vIndex = vSize - 1;				// index to v[n-1]
  NormalShift = 0;
  LoopCnt = uSize - vSize;
  //-----------------------------------------------------------------
  // if no Context given, allocate one with 2 Elements of proper size
  //-----------------------------------------------------------------
  if(pCtx == NULL)
  {
    if((pTmpCtx = AllocWLnumContext(HMEM_CTX_REF1 2, uSize+1)) == NULL)
      return(LNUM_OP_ALLOC_ERR);
    pCtx = pTmpCtx;
  }
  //----------------------------------------------------------
  // calculate Divisor normalization shift (v[n-1] >= b/2)
  // if required allocate temporary divisor and do shift
  //----------------------------------------------------------
  if((pElvBase[vIndex] & 0x80000000) == 0)	//not normalized
  {
    NormalShift = 32 - 				// Element size -
      HardGetBitCntWLnumElem(pElvBase[vIndex]);	// Topmost Element Bitcount
    if((Retcode = GetWLnumFromContext(HMEM_CTX_REF1
			pCtx, vSize, ppTmpWLnum)) != LNUM_OP_OK)
    {
      FreeWLnumContext(HMEM_CTX_REF1 pTmpCtx);
      return(Retcode);
    }
    WLnumReleaseCnt++;
    pNumV = ppTmpWLnum[0];
    LshiftWLnum(HMEM_CTX_REF1
		pNumV, pV ,NormalShift);	// shift up
    pElvBase = pNumV->lpEl;		// set base pointer
  }
  vnM1 = pElvBase[vIndex--];			// get v[n-1]
  vnM2 = pElvBase[vIndex];			// get v[n-2]
  //----------------------------------------------------------
  // allocate temporary Dividend Element and normalize
  //----------------------------------------------------------
  uIndex = uSize;				// required length, minimum
  if((NormalShift +
        HardGetBitCntWLnumElem(pU->lpEl[uIndex-1])) >= 32) //  u[n-1]
  {
    uIndex++;					// one more element required
    LoopCnt++;					// one more round
  }
  if((Retcode = GetWLnumFromContext(HMEM_CTX_REF1
			pCtx, uIndex, ppTmpWLnum)) != LNUM_OP_OK)
  {
    if(pTmpCtx != NULL)
    {
      FreeWLnumContext(HMEM_CTX_REF1 pTmpCtx);
    }
    else
      ReleaseWLnumsFromContext(pCtx, WLnumReleaseCnt);
    return(Retcode);
  }
  WLnumReleaseCnt++;
  pNumU = ppTmpWLnum[0];
  pEluBase = pNumU->lpEl;			// set base pointer

  if(uIndex != uSize)				// one more element allocated
  {
    pEluBase[uSize] = 0;			// clear topmost Element
    LshiftWLnum(HMEM_CTX_REF1
		pNumU, pU, NormalShift);	// normalize
  }
  else						// usize > vsize as u > v !
  {
    if(NormalShift == 0)			// no shift required
      CopyWLnum(HMEM_CTX_REF1
		pNumU, pU);			// only copy to tmp
    else
      LshiftWLnum(HMEM_CTX_REF1
		  pNumU, pU, NormalShift);	// assure u/v consistency
  }
  //----------------------------------------------------------
  // resize Quotient Element if required
  //----------------------------------------------------------
  if(pQuot->AllocSize < LoopCnt)
  {
    if((Retcode = AllocWLnumElements(HMEM_CTX_REF1
			pQuot, LoopCnt)) != LNUM_OP_OK)
    {
      if(pTmpCtx != NULL)
      {
        FreeWLnumContext(HMEM_CTX_REF1 pTmpCtx);
      }
      else
        ReleaseWLnumsFromContext(pCtx, WLnumReleaseCnt);
      return(Retcode);				// error occured
    }
  }
  pElQuot = pQuot->lpEl;			// preset pointer
  pQuot->UsedSize = LoopCnt;		// preset quotient size
  //----------------------------------------------------------
  // Division loop
  //----------------------------------------------------------
  do
  {
    uIndex--;			// number u access index TOP
    LoopCnt --;			// predecrement count, now can be used as index!
				// for u BASE
    //--------------------------------------------------------
    // get estimate qhat for quotient q
    //--------------------------------------------------------
    qhatL = GetQ32EstimateBit64(pEluBase, uIndex, vnM1, vnM2);
    //--------------------------------------------------------
    // Perform multiply and subtraction
    //--------------------------------------------------------
    if(HardMulSubWLnumBit64(vSize,			// ui = ui - qi * v
                         pEluBase,LoopCnt,pElvBase, qhatL) != 0)
      qhatL--;						// reduce estimate
    //--------------------------------------------------------
    // Store Quotient digit
    //--------------------------------------------------------
    pElQuot[LoopCnt] = qhatL;			// store digit
  } while(LoopCnt != 0);			// End of Division Loop
  //----------------------------------------------------------
  // Correct length of Quotient
  //----------------------------------------------------------
  if(pElQuot[pQuot->UsedSize-1] == 0)	// zero element on top,
    pQuot->UsedSize --;		// reduce size
  if(pTmpCtx != NULL)
  {
    FreeWLnumContext(HMEM_CTX_REF1 pTmpCtx);
  }
  else
    ReleaseWLnumsFromContext(pCtx, WLnumReleaseCnt);
  return(LNUM_OP_OK);
}

extern "C" int ModWLnum(HMEM_CTX_DEF
		WLARGENUM* pRem,	WLARGENUM* pU, WLARGENUM* pV, WLNUM_CONTEXT* pCtx)
{
  int Retcode, i, NormalShift, LoopCnt, uSize, vSize;

  int uIndex;					// index into number u
  int vIndex;					// index into number v

  WLARGENUM* pNumU;
  WLARGENUM* pNumV = NULL;
  WLARGENUM* ppTmpWLnum[1];
  WLNUM_CONTEXT* pTmpCtx = NULL;

  int qhatL, vnM1, vnM2;

  int* pEluBase;
  int* pElvBase;
  int* pElRem;
  int WLnumReleaseCnt = 0;

  //------------------------------------------------------------
  // Check for null-pointers and Divisor == Zero
  //------------------------------------------------------------
//  if(((pQuot == NULL) && (pRem == NULL)) || (pU == NULL) || (pV == NULL))
//    return(LNUM_OP_NULL_PTR);			// null pointer error
  if(IsZeroWLnum(pV) != 0) return LNUM_OP_ZERO_DIV;	// Divide by zero err.
  //----------------------------------------------------
  // check if division is required i.e. u > v
  //----------------------------------------------------
  i = UcompWLnum(pU, pV);			// check DIVIDEND >= DIVISOR
  if(i == WLNUM_1ST_EQ_2ND)			// 1st is equal to 2nd
  {
    //--------------------------------------------------
    // u == v: --> quotient = 1, remainder = 0
    //--------------------------------------------------
    pRem->UsedSize = 0;			// set zero
    return(LNUM_OP_OK);
  }
  else if(i == WLNUM_1ST_LT_2ND)		// u < v
  {
    //--------------------------------------------------
    // u < v: --> quotient = 0, remainder = v
    //--------------------------------------------------
    if(pRem != pU)
      return(CopyWLnum(HMEM_CTX_REF1
		       pRem, pU));		// copy u -> remainder
    return(LNUM_OP_OK);
  }
  //====================================================================
  // u > v, real work must be done !
  //====================================================================
  //--------------------------------------------------------------------
  // check for vsize == 1 first
  //--------------------------------------------------------------------
  pElRem   = NULL;				// dto.
  uSize    = pU->UsedSize;
  vSize    = pV->UsedSize;
  pEluBase = pU->lpEl;			// set base pointer
  if(vSize == 1)				// easier way to use
  {
    //--------------------------------------------------
    // special case, divide by a single Element only
    //--------------------------------------------------
    if(pRem->AllocSize == 0)		// check if remainder allocated
    {
      if((pRem->lpEl = BIT32_ARRAY_ALLOC(HMEM_CTX_REF,1)) == NULL)	// alloc error
        return(LNUM_OP_ALLOC_ERR);
    }
    pElRem = pRem->lpEl;		// set pointer
    pRem->UsedSize = 1;			// preset length
    HardDiv32Single(uSize, NULL, pElRem,
		    pEluBase, pV->lpEl[0]);	// do divide
    pRem->UsedSize = 1;			// preset length
    if(pElRem[0] == 0)				// is zero, special case
      pRem->UsedSize = 0;			// true size
    return(LNUM_OP_OK);
  }
  //===========================================================
  // The long, hard way needed
  //===========================================================
  pElvBase = pV->lpEl;			// set base pointer
  vIndex = vSize - 1;				// index to v[n-1]
  NormalShift = 0;
  LoopCnt = uSize - vSize;
  //-----------------------------------------------------------------
  // if no Context given, allocate one with 2 Elements of proper size
  //-----------------------------------------------------------------
  if(pCtx == NULL)
  {
    if((pTmpCtx = AllocWLnumContext(HMEM_CTX_REF1 2, uSize+1)) == NULL)
      return(LNUM_OP_ALLOC_ERR);
    pCtx = pTmpCtx;
  }
  //----------------------------------------------------------
  // calculate Divisor normalization shift (v[n-1] >= b/2)
  // if required allocate temporary divisor and do shift
  //----------------------------------------------------------
  if((pElvBase[vIndex] & 0x80000000) == 0)	//not normalized
  {
    NormalShift = 32 - 				// Element size -
      HardGetBitCntWLnumElem(pElvBase[vIndex]);	// Topmost Element Bitcount
    if((Retcode = GetWLnumFromContext(HMEM_CTX_REF1
			pCtx, vSize, ppTmpWLnum)) != LNUM_OP_OK)
    {
      FreeWLnumContext(HMEM_CTX_REF1 pTmpCtx);
      return(Retcode);
    }
    WLnumReleaseCnt++;
    pNumV = ppTmpWLnum[0];
    LshiftWLnum(HMEM_CTX_REF1
		pNumV, pV ,NormalShift);	// shift up
    pElvBase = pNumV->lpEl;		// set base pointer
  }
  vnM1 = pElvBase[vIndex--];			// get v[n-1]
  vnM2 = pElvBase[vIndex];			// get v[n-2]
  //----------------------------------------------------------
  // allocate temporary Dividend Element and normalize
  //----------------------------------------------------------
  uIndex = uSize;				// required length, minimum
  if((NormalShift +
        HardGetBitCntWLnumElem(pU->lpEl[uIndex-1])) >= 32) //  u[n-1]
  {
    uIndex++;					// one more element required
    LoopCnt++;					// one more round
  }
  if((Retcode = GetWLnumFromContext(HMEM_CTX_REF1
			pCtx, uIndex, ppTmpWLnum)) != LNUM_OP_OK)
  {
    if(pTmpCtx != NULL)
    {
      FreeWLnumContext(HMEM_CTX_REF1 pTmpCtx);
    }
    else
      ReleaseWLnumsFromContext(pCtx, WLnumReleaseCnt);
    return(Retcode);
  }
  WLnumReleaseCnt++;
  pNumU = ppTmpWLnum[0];
  pEluBase = pNumU->lpEl;			// set base pointer

  if(uIndex != uSize)				// one more element allocated
  {
    pEluBase[uSize] = 0;			// clear topmost Element
    LshiftWLnum(HMEM_CTX_REF1
		pNumU, pU, NormalShift);	// normalize
  }
  else						// usize > vsize as u > v !
  {
    if(NormalShift == 0)			// no shift required
      CopyWLnum(HMEM_CTX_REF1
		pNumU, pU);			// only copy to tmp
    else
      LshiftWLnum(HMEM_CTX_REF1
		  pNumU, pU, NormalShift);	// assure u/v consistency
  }
  //----------------------------------------------------------
  // Division loop
  //----------------------------------------------------------
  do
  {
    uIndex--;			// number u access index TOP
    LoopCnt --;			// predecrement count, now can be used as index!
				// for u BASE
    //--------------------------------------------------------
    // get estimate qhat for quotient q
    //--------------------------------------------------------
    qhatL = GetQ32EstimateBit64(pEluBase, uIndex, vnM1, vnM2);

    //--------------------------------------------------------
    // Perform multiply and subtraction
    //--------------------------------------------------------
    if(HardMulSubWLnumBit64(vSize,			// ui = ui - qi * v
                          pEluBase,LoopCnt,pElvBase, qhatL) != 0)
    {
    }
  } while(LoopCnt != 0);			// End of Division Loop
  //----------------------------------------------------------
  // renormalize Remainder (from lnumu)
  //----------------------------------------------------------
  Retcode = LNUM_OP_OK;
  uSize = pNumU->UsedSize;		// get figure count (> 0!)
  i = uSize - 1;				// top element index
  do
  {
    if(pEluBase[i--] != 0) break;		// figure <> 0
      uSize--;
  } while (uSize != 0);
  pNumU->UsedSize = uSize;		// max. used figures
  if(uSize == 0)				// remainder is zero
    pRem->UsedSize = 0;			// is Zero
  else
  {
    if(NormalShift == 0)			// no shift required
      Retcode = CopyWLnum(HMEM_CTX_REF1
			  pRem, pNumU);	// only copy buffer
    else
      Retcode = RshiftWLnum(HMEM_CTX_REF1
			pRem,pNumU,NormalShift);// do normalize shift right
  }
  if(pTmpCtx != NULL)
  {
    FreeWLnumContext(HMEM_CTX_REF1 pTmpCtx);
  }
  else
    ReleaseWLnumsFromContext(pCtx, WLnumReleaseCnt);
  return(Retcode);
}

extern "C" int MulModWLnum(HMEM_CTX_DEF
		WLARGENUM* pRem, WLARGENUM* pU,
		WLARGENUM* pV, WLARGENUM* pMod, WLNUM_CONTEXT* pCtx)
{
  int Retcode;
  int MaxSize;
  WLARGENUM* pNumTmp;
  WLARGENUM* ppTmpWLnum[1];
  WLNUM_CONTEXT* pTmpCtx = NULL;

//  if((pRem==NULL) || (pU==NULL) || (pV==NULL) || (pMod==NULL))
//    return(LNUM_OP_NULL_PTR);

  if(pMod->UsedSize == 0)
    return(LNUM_OP_ZERO_DIV);
  //------------------------------------------------------------
  // Get maximum required size for temporary number
  //------------------------------------------------------------
  MaxSize = pU->UsedSize + pV->UsedSize;

  //-----------------------------------------------------------------
  // if no Context given, allocate one with 3 Elements of proper size
  //-----------------------------------------------------------------
  if(pCtx == NULL)
  {
    if((pTmpCtx = AllocWLnumContext(HMEM_CTX_REF1 3, MaxSize+1)) == NULL)
      return(LNUM_OP_ALLOC_ERR);
    pCtx = pTmpCtx;
  }
  //-----------------------------------------------------------------
  // Get Temporary Number of appropriate size
  //-----------------------------------------------------------------
  if((Retcode = GetWLnumFromContext(HMEM_CTX_REF1
			pCtx, MaxSize, ppTmpWLnum)) != LNUM_OP_OK)
  {
    if(pTmpCtx != NULL)
    {
      FreeWLnumContext(HMEM_CTX_REF1 pTmpCtx);
    }
    else
      ReleaseWLnumsFromContext(pCtx, 1);
    return(Retcode);
  }
  pNumTmp = ppTmpWLnum[0];
//  WLNUM_UsedSize(pNumTmp) = 0;
  //------------------------------------------------------------
  // Multiply, Divide by modulus
  //------------------------------------------------------------
  if(pU == pV)
    Retcode = SquareWLnumBit64(HMEM_CTX_REF1
			       pNumTmp, pU);	// only do square
  else
    Retcode = MulWLnumBit64(HMEM_CTX_REF1
			    pNumTmp, pU, pV); 	// do real multiply 

  if(pU == pV)
  {
  }
  else
  {
  }

  if(Retcode == LNUM_OP_OK)
  {
    Retcode = ModWLnum(HMEM_CTX_REF1
		pRem,pNumTmp,pMod,pCtx);	// get remainder divided by m
  }
  if(pTmpCtx != NULL)
  {
    FreeWLnumContext(HMEM_CTX_REF1 pTmpCtx);
  }
  else
    ReleaseWLnumsFromContext(pCtx, 1);
  return(Retcode);
}

/**
* Calculates (u ** v) mod m using a precomputed
* table of powers to reduce amount of caclulations needed (ExpModStdWLnum).
*
* -- slow version --
*
* The size of the table depends on the size of the value v.
* The content will be (u) mod m, (u**3) mod m, (u**5) mod m
* and so on.
* The power p is scanned from top to bottom using a window of
* size 1 to 6 bits, depending on the magnitude of v.
*
* Destination and source must be different.
* 3 CTX Elements required + max. 32 for Table.
*
*  @param pRem pointer to destination
*  @param pU pointer to number u
*  @param pV pointer to power v
*  @param pMod pointer to modulus m
*  @param pCtx Work context. Optional
*  @param callback Callback pointer. Optional
*  @return 0 on success, error code otherwise
*/
static int ExpModStdWLnum(HMEM_CTX_DEF
				   WLARGENUM* pRem, WLARGENUM* pU, WLARGENUM* pV,
				   WLARGENUM* pMod, WLNUM_CONTEXT* pCtx,
				  void (*callback)(int))
{

  int Retcode;

  int i = 0;
  int j;
  int k = 0;
  int win=0;
  int vIndex=0;
  int vIndexSave;

  int AllocIndex = 0;
  int MulFlag=0;
  int WinStart=0;
  int WinSize;
  
  int wIndex;
  int MaxSize;

  int LastUtc = 0;
  int ThisUtc = 0;

  WLARGENUM* pNumTmp0 = NULL;

  WLARGENUM* CalcTab[32];			// precalculated numbers

  int* pElv = NULL;

  int BitMask = 0;
  int BitMaskSave;

//  if((pRem==NULL) || (pU==NULL) || (pV==NULL) || (pMod==NULL))
//    return(LNUM_OP_NULL_PTR);

  //--------------------------------------------------------------
  // Check for Modulus m == 0
  //--------------------------------------------------------------
  MaxSize = pMod->UsedSize;		// get length
  if((MaxSize == 0) ||
     ((MaxSize == 1) && (pMod->lpEl[0] == 0)))
    return(LNUM_OP_ZERO_DIV);
  //------------------------------------------------------------
  // calculate maximal needed elements for temporary values
  //------------------------------------------------------------
  if((pMod->lpEl[MaxSize-1] & 0x80000000) != 0) // need one element more
    MaxSize ++;					// 1 element more
  for(;;)	// ERROR FOR
  {
    //----------------------------------------------------------
    // preset value 1 for result,increase buffersize if needed
    //----------------------------------------------------------
    if(pRem->AllocSize < MaxSize)		// too few elements
    {
      if((Retcode = AllocWLnumElements(HMEM_CTX_REF1
			pRem,MaxSize)) != LNUM_OP_OK)
        break;
    }
    pRem->UsedSize = 1;
    pRem->lpEl[0] = 1;
    //----------------------------------------------------------
    // Allocate 1st element and calculate (u) mod m
    //----------------------------------------------------------
    if((CalcTab[0] = AllocNewWLnum(HMEM_CTX_REF1
				   MaxSize)) == NULL)
    {
      Retcode = LNUM_OP_ALLOC_ERR;
      break;
    }
    AllocIndex++;				// one more allocated element
    if((Retcode=ModWLnum(HMEM_CTX_REF1
		  CalcTab[0],pU,pMod,pCtx)) != LNUM_OP_OK) // get (u)mod m
      break;

    //----------------------------------------------------------
    // Get size of power, allocate required temporary buffer
    //----------------------------------------------------------
    pElv = pV->lpEl;			// number base
    vIndex = pV->UsedSize-1;		// get topmost element index

    if((i = (vIndex * 32) +			// get number of bits
           (int) HardGetBitCntWLnumElem(pElv[vIndex])) == 0)
						// (u ** 0) mod m = 1
    {
      FreeWLnum(HMEM_CTX_REF1 CalcTab[0]);
      return(LNUM_OP_OK);
    }

    WinStart = i-1;				// first Bit +1 to test
    BitMask = (int)
               ((int) 1 << ((i-1) & (int) 0x1F));// initial test bit mask

    //----------------------------------------------------------
    // Get window size to use
    // Changed according to Algorithm 1.2.2.4 from H. Cohen:
    // lg N <= (k * (k+1) * 2^(2k))/(2^(k+1) -k - 2)
    // k = 1 for bits <= 8
    // k = 2 for bits <= 24
    // k = 3 for bits <= 69
    // k = 4 for bits <= 196
    // k = 5 for bits <= 538 bits (and above)
    //----------------------------------------------------------
    if(i <= 8) win = 1;
    else if(i <= 24) win = 2;
    else if(i <= 69) win = 3;
    else if(i <= 196) win = 4;
    else if(i <= 538) win = 5;
    else win = 6;

//    PRINT("WIN: ");
//    PRINT_INT(win);

    if(win != 1)				// must build more elements
    {
      if((pNumTmp0 = AllocNewWLnum(HMEM_CTX_REF1
				   MaxSize)) == NULL)// allocate temporary
      {
        Retcode = LNUM_OP_ALLOC_ERR;
        break;
      }
      if((Retcode=MulModWLnum(HMEM_CTX_REF1		// get (u**2) mod m
		      pNumTmp0,CalcTab[0],
                      CalcTab[0],pMod, pCtx)) != LNUM_OP_OK) break;

      //----------------------------------------------------------
      // precalculate Table values
      //----------------------------------------------------------
      j = (1<<(win-1)) - 1;			// maximal index (rel. 0)
      k = 1;					// set start index ([1])
      do					// process alloc/preset
      {
        if((CalcTab[k] = AllocNewWLnum(HMEM_CTX_REF1
				       MaxSize)) == NULL) // allocation error
        {
	  Retcode = LNUM_OP_ALLOC_ERR;
	  break;
        }
	AllocIndex++;				// one more Element
						// get next table entry
        if((Retcode=MulModWLnum(HMEM_CTX_REF1 CalcTab[k],CalcTab[k-1],
                       pNumTmp0,pMod,pCtx)) != LNUM_OP_OK) break;
        k++;					// to next table index
      }while((--j) != 0);
    } // win != 1    
    if(Retcode == LNUM_OP_OK) break;	// no Error, continue
    while(AllocIndex != 0)      	// free elements
    {
      AllocIndex--;
      FreeWLnum(HMEM_CTX_REF1 CalcTab[AllocIndex]);
    }
    FreeWLnum(HMEM_CTX_REF1 pNumTmp0);
    return(Retcode);
  } // Error FOR

  if(callback != NULL)
  {
    if(i < 128)
    {
      callback = (void(*)(int)) NULL;
    }
    else
//      LastUtc = GET_SYSTEM_TIME_UTC(RANDinst);
      LastUtc = SecGetSystemTimeUTC();
  }
  //------------------------------------------------------------
  // processing loop
  //------------------------------------------------------------
//  Retcode = LNUM_OP_OK;
  for(;;)					// process 'infinite'
  {
    //----------------------------------------------------------
    // search 1st v-bit that is One, starting at the MSB-Bit
    //----------------------------------------------------------
    if((pElv[vIndex] & BitMask) == 0)	// no startbit found
    {
      if(MulFlag != 0)			// should we do multiply ?
      {

        if((Retcode=MulModWLnum(HMEM_CTX_REF1	// multiply * rem mod m
				pRem,pRem,pRem,pMod,pCtx)) != LNUM_OP_OK)
          break;

//      SquareCount++;
      }
      if((BitMask = ((BitMask >> 1) & 0x7FFFFFFF)) == 0)
      {
        BitMask = (int) 0x80000000;
        vIndex--;
      }
      if((--WinStart) < 0)
      {
        break;					// all done
      }
      continue;					// keep on searching
    } // Bit was zero
    //----------------------------------------------------------
    // bit found, correct bitmask
    //----------------------------------------------------------
    if((BitMask = ((BitMask >> 1) & 0x7FFFFFFF)) == 0)
    {
      BitMask = (int) 0x80000000;
      vIndex--;
    }
    //----------------------------------------------------------
    // get window size and Table Index from winsize bits
    // N O T E: take care of bitmask !!!
    //----------------------------------------------------------
    WinSize = 0;				// no size yet
    wIndex = 1;
    vIndexSave = vIndex;			// save pointer
    BitMaskSave = BitMask;			// save mask
    for(i=1;i<win;i++)				// get sizes
    {
      if((WinStart - i) < 0) break;		// check for data end
      if((pElv[vIndex] & BitMask) != 0)		// one bit found
      {
        wIndex = (wIndex << (i-WinSize)) | 1;	// correct index,insert new bit
        WinSize = i;				// save size
        BitMaskSave = BitMask;			// get current bitmask
        vIndexSave = vIndex;			// get current pointer
        if((BitMaskSave = ((BitMaskSave >>1) & (int) 0x7FFFFFFF)) == 0)
        {
          BitMaskSave = (int) 0x80000000;
          vIndexSave--;
        }
      }
      if((BitMask = ((BitMask >> 1) & (int) 0x7FFFFFFF)) == 0)
      {
        BitMask = (int) 0x80000000;
        vIndex--;
      }
    }
    BitMask = BitMaskSave;
    vIndex = vIndexSave;
    //----------------------------------------------------------
    // correct modulo operation (1 figure)
    //----------------------------------------------------------
    j = WinSize+1;			// number of corrections needed
    do
    {

      if((Retcode=MulModWLnum(HMEM_CTX_REF1	// multiply * (rem) mod m
			pRem,pRem,pRem,pMod,pCtx)) != LNUM_OP_OK)
        break;
//    SquareCount++;
      j--;
    }while(j != 0);
    if(j != 0) break;			// error occured
    //----------------------------------------------------------
    // multiply with appropriate table value
    //----------------------------------------------------------

					// multiply * (Table) mod m
    if((Retcode=MulModWLnum(HMEM_CTX_REF1
		   pRem,pRem,CalcTab[wIndex>>1],pMod,pCtx)) != LNUM_OP_OK)
      break;

//  MulCount++;
    //----------------------------------------------------------
    // check if more input data present
    //----------------------------------------------------------
    MulFlag = 1;				// enable multiplying now
    if((WinStart -= (WinSize+1)) < 0) break;	// reduce data count
    if(callback != NULL)
    {
//    ThisUtc = GET_SYSTEM_TIME_UTC(RANDinst);
      ThisUtc = SecGetSystemTimeUTC();
      if(ThisUtc != LastUtc)
      {
        LastUtc = ThisUtc;
	callback(1);
      }
    }
  } // for
  //------------------------------------------------------------
  // free buffers, exit
  //------------------------------------------------------------
  while(AllocIndex != 0)
  {
    AllocIndex--;      
    FreeWLnum(HMEM_CTX_REF1 CalcTab[AllocIndex]);
  }
  FreeWLnum(HMEM_CTX_REF1 pNumTmp0);
// TEST TEST TEST
//  fprintf(stdout,"\nPseudo-Mult: %d, True-Mult: %d",a,b);
// TEST TEST TEST

  return(Retcode);
}

extern "C" int GcdWLnum(HMEM_CTX_DEF
			WLARGENUM* pRes, WLARGENUM* pU, WLARGENUM* pV)
{

//  if((pRes == NULL) || (pU == NULL) || (pV == NULL))
//    return(LNUM_OP_NULL_PTR);

  int Retcode;
  int ShiftCnt=0;

  WLARGENUM* pUtmp;
  WLARGENUM* pVtmp;
  WLARGENUM* pTmpLnum;
  
  //------------------------------------------------------------
  // allocate temporary number variables
  //------------------------------------------------------------
  if((pUtmp = AllocNewWLnum(HMEM_CTX_REF1
			    pU->UsedSize+1)) == NULL) // allocate temporary
    return(LNUM_OP_ALLOC_ERR);			   // error occured
  if((pVtmp = AllocNewWLnum(HMEM_CTX_REF1
			    pV->UsedSize+1)) == NULL) // allocate temporary
  {
    FreeWLnum(HMEM_CTX_REF1 pUtmp);
    return(LNUM_OP_ALLOC_ERR);			// error occured
  }
  //------------------------------------------------------------
  // make copy of input numbers
  //------------------------------------------------------------
  if(((Retcode = CopyWLnum(HMEM_CTX_REF1 pUtmp, pU)) != LNUM_OP_OK) ||
     ((Retcode = CopyWLnum(HMEM_CTX_REF1 pVtmp, pV)) != LNUM_OP_OK))
  {
    FreeWLnum(HMEM_CTX_REF1 pUtmp);
    FreeWLnum(HMEM_CTX_REF1 pVtmp);
    return(Retcode);
  }
  //------------------------------------------------------------
  // assure utmp >= vtmp
  //------------------------------------------------------------
  if(UcompWLnum(pUtmp,pVtmp) == WLNUM_1ST_LT_2ND)
  {
    pTmpLnum = pUtmp;				// exchange u,v
    pUtmp = pVtmp;
    pVtmp = pTmpLnum;
  }
  //------------------------------------------------------------
  // Start euclidian processing
  //------------------------------------------------------------
  Retcode = LNUM_OP_OK;
  for(;;)
  {
    if(IsZeroWLnum(pVtmp) != 0) break;		// terminate
    switch(((pUtmp->lpEl[0] & 1) << 1) |	// get decision variable
           (pVtmp->lpEl[0] & 1))
//    switch(j)
    {
      case 0:					// both even, divide both by 2
        if(((Retcode = Rshift1WLnum(HMEM_CTX_REF1
				    pUtmp,pUtmp)) != LNUM_OP_OK) ||
           ((Retcode = Rshift1WLnum(HMEM_CTX_REF1
				    pVtmp,pVtmp)) != LNUM_OP_OK))
          break;
        ShiftCnt ++;
	continue;				// to outer loop

      case 1:					// utmp even, vtmp odd
        Retcode = Rshift1WLnum(HMEM_CTX_REF1
			       pUtmp,pUtmp);	// divide by two
        break;        

      case 2:					// utmp odd, vtmp even
        Retcode = Rshift1WLnum(HMEM_CTX_REF1
			       pVtmp,pVtmp);	// divide by two
	break;

      case 3:					// both odd
						// calculate utmp=(utmp-vtmp)/2
        if((Retcode = SubWLnum(HMEM_CTX_REF1
				pUtmp,pUtmp,pVtmp)) != LNUM_OP_OK)
          break;
        Retcode = Rshift1WLnum(HMEM_CTX_REF1
				pUtmp,pUtmp);
	break;
    } // switch
    if(Retcode != LNUM_OP_OK)			// had an error
      break;

    if(UcompWLnum(pUtmp,pVtmp) == WLNUM_1ST_LT_2ND)
    {
      pTmpLnum = pUtmp;				// exchange u,v
      pUtmp = pVtmp;
      pVtmp = pTmpLnum;
    }
  } // Euclidian FOR
  //------------------------------------------------------------
  // copy back result
  //------------------------------------------------------------
  if(Retcode == LNUM_OP_OK)
  {
    if(ShiftCnt != 0)
      Retcode = LshiftWLnum(HMEM_CTX_REF1
			    pUtmp,pUtmp,ShiftCnt);

    if(Retcode == LNUM_OP_OK)
      Retcode = CopyWLnum(HMEM_CTX_REF1 pRes, pUtmp);
  }

  FreeWLnum(HMEM_CTX_REF1 pUtmp);
  FreeWLnum(HMEM_CTX_REF1 pVtmp);
  return(Retcode);
}

extern "C" int InvModWLnum(HMEM_CTX_DEF
		WLARGENUM* pUinv,
		WLARGENUM* pU, WLARGENUM* pMod, WLNUM_CONTEXT* pCtx)
{
  int Retcode, i;
  int MaxSize;
  int Sign=1;
  int WLnumReleaseCnt = 0;

  WLARGENUM* Q;				// tmp. Quotient
  WLARGENUM* R;				// tmp. Remainder
  WLARGENUM* U;				// tmp. variable for GCD
  WLARGENUM* V;				// dto.
  WLARGENUM* X;				// tmp. variable for Inverse
  WLARGENUM* Y;				// dto.
  WLARGENUM* S;				// dto.

  WLARGENUM** pNumArr;

  WLNUM_CONTEXT* pTmpCtx = NULL;

//  if((pUinv == NULL) || (pU == NULL) || (pMod == NULL))
//    return(LNUM_OP_NULL_PTR);

  //------------------------------------------------------------
  // Get size of/allocate required Helper-Variables
  //------------------------------------------------------------
  MaxSize = pU->UsedSize;			// assume u large
  if(MaxSize < pMod->UsedSize)
    MaxSize = pMod->UsedSize;
  MaxSize ++;
  if(pCtx == NULL)				// no context
  {
    if((pTmpCtx = AllocWLnumContext(HMEM_CTX_REF1 2+6, MaxSize)) == NULL)
      return(LNUM_OP_ALLOC_ERR);
    pNumArr = pTmpCtx->pWLnumArr;
    U = pNumArr[0];
    V = pNumArr[1];
    X = pNumArr[2];
    Y = pNumArr[3];
    Q = pNumArr[4];
    R = pNumArr[5];
    pTmpCtx->NextFreeIndex = 6;
    pCtx = pTmpCtx;
  }
  else						// context is given
  {
    i = pCtx->NextFreeIndex;
    if((i + 2+6) >= pCtx->AllocedNumCnt)
      return(LNUM_OP_CTX_FULL);

    U = GetWLnumPtrFromContext(HMEM_CTX_REF1 pCtx, MaxSize);
    V = GetWLnumPtrFromContext(HMEM_CTX_REF1 pCtx, MaxSize);
    X = GetWLnumPtrFromContext(HMEM_CTX_REF1 pCtx, MaxSize);
    Y = GetWLnumPtrFromContext(HMEM_CTX_REF1 pCtx, MaxSize);
    Q = GetWLnumPtrFromContext(HMEM_CTX_REF1 pCtx, MaxSize);
    R = GetWLnumPtrFromContext(HMEM_CTX_REF1 pCtx, MaxSize);
    if((U == NULL) || (V == NULL) || (X == NULL) || (Y == NULL) ||
       (Q == NULL) || (R == NULL))
      return(LNUM_OP_ALLOC_ERR);

    WLnumReleaseCnt = 6;
  }
//  k = 0;				// prepare for freeing !!

  for(;;)		// Error FOR
  {
    //------------------------------------------------------------
    // Prepare Start of Algorithm
    //------------------------------------------------------------
    X->UsedSize = 0;			// X = 0
    Y->UsedSize = 1;			// Y = 1
    Y->lpEl[0] = 1;
    if(((Retcode = CopyWLnum(HMEM_CTX_REF1 U,pU)) != LNUM_OP_OK) || // U = u
       ((Retcode = CopyWLnum(HMEM_CTX_REF1 V,pMod)) != LNUM_OP_OK)) // V = m
      break;
    //------------------------------------------------------------
    // Processing Loop
    //------------------------------------------------------------
    for(;;)
    {
      Retcode = LNUM_OP_OK;
      if(IsZeroWLnum(V) != 0) break;		// remainder is zero, stop

//      PRINT("U: ");
//      ShowLnum(U);
//      PRINT("V: ");
//      ShowLnum(V);

      if((Retcode=DivWLnum(HMEM_CTX_REF1
		    Q,R,U,V,pCtx)) != LNUM_OP_OK)// Divide U/V with remainder
        break;

//      PRINT("Q: ");
//      ShowLnum(Q);
//      PRINT("R: ");
//      ShowLnum(R);

      S = U;					// U is now free
      U = V;					// set next Dividend
      V = R;					// set next Divisor
      if((Retcode = MulWLnumBit64(HMEM_CTX_REF1
				  S,Q,X)) != LNUM_OP_OK)	// Q * X
        break;
//      PRINT("SMult: ");
//      ShowLnum(S);
//      PRINT("Y: ");
//      ShowLnum(Y);

      if((Retcode = AddWLnum(HMEM_CTX_REF1
			     S,S,Y)) != LNUM_OP_OK)	// Q * X + Y
        break;

//      PRINT("S: ");
//      ShowLnum(S);

      R = Y;					// Y is now free
      Y = X;
      X = S;
      Sign = - Sign;
    }
    if(Retcode != LNUM_OP_OK)
      break;
    //------------------------------------------------------------
    // Check if odd number of loops, if so set Y = -Y
    //------------------------------------------------------------
    if(Sign < 0)				// odd number, readjust
    {
      if((Retcode = SubWLnum(HMEM_CTX_REF1
			Y,pMod,Y)) != LNUM_OP_OK) //prepare -Y mod m
        break;
//      PRINT("Past subtract: ");
//      ShowLnum(Y);

    }
    //------------------------------------------------------------
    // Check if gcd is 1; if not, inverse does not exist
    //------------------------------------------------------------
    if(IsOneWLnum(U) == 0)
    {
      Retcode = LNUM_OP_NO_INVERSE;
      break;
    }
    //------------------------------------------------------------
    // calculate final inverse
    //------------------------------------------------------------
//    PRINT("Inverse before MOD: ");
//    ShowLnum(Y);

    Retcode = ModWLnum(HMEM_CTX_REF1 pUinv,Y, pMod, pCtx);
    break;
  } // Error FOR

  if(pTmpCtx != NULL)
  {
    FreeWLnumContext(HMEM_CTX_REF1 pTmpCtx);
  }
  else if(WLnumReleaseCnt != 0)
    ReleaseWLnumsFromContext(pCtx, WLnumReleaseCnt);
  return(Retcode);
}

extern "C" int WLnum_bin2wlnum(HMEM_CTX_DEF
			WLARGENUM* pWLnum, char* pSrcBuf,
			int SrcOffset, int SrcLen)
{
  int Retcode, ElementCnt, SrcRemainCnt, DstIndex;

  int WElement;
  int* pEl;
  //----------------------------------------------------
  // Check parameters, remove later ?
  //----------------------------------------------------
  if((pWLnum == NULL) || (pSrcBuf == NULL))
    return(LNUM_OP_NULL_PTR);
  if(SrcLen <= 0)
    return(LNUM_OP_PARAM_ERR);
  //----------------------------------------------------
  // Skip leading zeroes in Source, may all be zero !
  //----------------------------------------------------
  while(SrcLen != 0)
  {
    if(pSrcBuf[SrcOffset] != 0)
      break;
    SrcOffset++;
    SrcLen--;
  }
  //----------------------------------------------------
  // Check for all zeroes first
  //----------------------------------------------------
  if(SrcLen == 0)
  {
    pWLnum->UsedSize = 0;
    return(LNUM_OP_OK);
  }
  //----------------------------------------------------
  // Not all zeroes, get number of BIT32 Elements needed
  //----------------------------------------------------
  ElementCnt = (SrcLen + 3) / 4;		// get numer of BIT32 Elements
  if(pWLnum->AllocSize < ElementCnt)
  {
    if((Retcode = AllocWLnumElements(HMEM_CTX_REF1
			pWLnum,ElementCnt)) != LNUM_OP_OK)
      return(Retcode);
  }
  pWLnum->UsedSize = ElementCnt;		// set size
  DstIndex = ElementCnt - 1;			// set Index to top Element
  pEl = pWLnum->lpEl;
  //----------------------------------------------------
  // check if partial element must be processed first
  //----------------------------------------------------
  if((SrcRemainCnt = (SrcLen & 0x03)) != 0)	// partial element present
  {
    SrcLen -= SrcRemainCnt;			// full elements left
    WElement = 0;
    do
    {
      WElement <<= 8;				// shift up bytes
      WElement |= (int) pSrcBuf[SrcOffset++] & 0xFF; // insert next element
      SrcRemainCnt--;
    }while(SrcRemainCnt != 0);
    pEl[DstIndex--] = WElement;    
  }
  //----------------------------------------------------
  // store remaining full elements (if any)
  //----------------------------------------------------
  while(DstIndex >= 0)
  {
    WElement = ((int) pSrcBuf[SrcOffset]   << 24) |
               (((int) pSrcBuf[SrcOffset+1] & 0xFF) << 16) |
               (((int) pSrcBuf[SrcOffset+2] & 0xFF) << 8) |
               ((int) pSrcBuf[SrcOffset+3] & 0xFF);
    pEl[DstIndex--] = WElement;
    SrcOffset += 4;
  }
  return(LNUM_OP_OK);
}

extern "C" int WLnum_bin2wlnumLe(HMEM_CTX_DEF
			WLARGENUM* pWLnum, char* pSrcBuf,
			int SrcOffset, int SrcLen)
{
  int Retcode, ElementCnt, SrcRemainCnt, DstIndex;

  int WElement;
  int* pEl;
  //----------------------------------------------------
  // Check parameters, remove later ?
  //----------------------------------------------------
  if((pWLnum == NULL) || (pSrcBuf == NULL))
    return(LNUM_OP_NULL_PTR);
  if(SrcLen <= 0)
    return(LNUM_OP_PARAM_ERR);
  //----------------------------------------------------
  // Skip leading zeroes in Source, may all be zero !
  //----------------------------------------------------
  SrcOffset = SrcLen-1;			// to top of buffer
   while(SrcLen != 0)
   {
      if(pSrcBuf[SrcOffset] != 0)
         break;
      SrcOffset--;
      SrcLen--;
   }
  //----------------------------------------------------
  // Check for all zeroes first
  //----------------------------------------------------
  if(SrcLen == 0)
  {
    pWLnum->UsedSize = 0;
    return(LNUM_OP_OK);
  }
  //----------------------------------------------------
  // Not all zeroes, get number of BIT32 Elements needed
  //----------------------------------------------------
  ElementCnt = (SrcLen + 3) / 4;		// get numer of BIT32 Elements
  if(pWLnum->AllocSize < ElementCnt)
  {
    if((Retcode = AllocWLnumElements(HMEM_CTX_REF1
			pWLnum,ElementCnt)) != LNUM_OP_OK)
      return(Retcode);
  }
  pWLnum->UsedSize = ElementCnt;		// set size
  DstIndex = ElementCnt - 1;			// set Index to top Element
  pEl = pWLnum->lpEl;
  //----------------------------------------------------
  // check if partial element must be processed first
  //----------------------------------------------------
  if((SrcRemainCnt = (SrcLen & 0x03)) != 0)	// partial element present
  {
    SrcLen -= SrcRemainCnt;			// full elements left
    WElement = 0;
    do
    {
      WElement <<= 8;				// shift up bytes
      WElement |= (int) pSrcBuf[SrcOffset--] & 0xFF; // insert next element
      SrcRemainCnt--;
    }while(SrcRemainCnt != 0);
    pEl[DstIndex--] = WElement;    
  }
  //----------------------------------------------------
  // store remaining full elements (if any)
  //----------------------------------------------------
  while(DstIndex >= 0)
  {
    WElement = ((int) pSrcBuf[SrcOffset]   << 24) |
               (((int) pSrcBuf[SrcOffset-1] & 0xFF) << 16) |
               (((int) pSrcBuf[SrcOffset-2] & 0xFF) << 8) |
               ((int) pSrcBuf[SrcOffset-3] & 0xFF);
    pEl[DstIndex--] = WElement;
    SrcOffset -= 4;
  }
  return(LNUM_OP_OK);
}

extern "C" int WLnum_wlnum2bin(char* pDstBuf, int DstIndex,
		int* pDstLen, WLARGENUM* pWLnum, int ZeroFlag)
{
  int BufLen = pDstLen[0];
  int ElementIndex;
  int ElementCnt;
  int DstStart = DstIndex;
  int RemainCnt;

  int WElement;
  int* pEl;
  //-----------------------------------------------------
  // check parameters, assure Destination buffer size > 0
  //-----------------------------------------------------
  if((pDstBuf ==  NULL) || (pWLnum == NULL))
    return(LNUM_OP_NULL_PTR);
  if(BufLen <= 0)
    return(LNUM_OP_ZERO_SIZE);
  //-----------------------------------------------------
  // check special case WLnum == 0
  //-----------------------------------------------------
  ElementCnt = pWLnum->UsedSize;
  if(ElementCnt == 0)
  {
    pDstBuf[DstIndex] = 0;
    pDstLen[0] = 1;
    return(LNUM_OP_OK);
  }
  //----------------------------------------------------
  // Prepare check for buffer length
  //----------------------------------------------------
  pEl = pWLnum->lpEl;			// get base pointer
  ElementIndex = ElementCnt - 1;		// index to top element
  WElement = pEl[ElementIndex];			// get top Element
  RemainCnt = HardGetByteCntWLnumElem(WElement);// get number of bytes
  if((ZeroFlag != 0) &&				// insert zero if Top Bit set
    ((WElement & ((int) 0x80 << ((RemainCnt-1)*8))) != 0))
  {
    pDstBuf[DstIndex++] = 0;			// Insert NULL Byte
    BufLen--;					// reduce size for check...
  }    
  if((((ElementCnt-1) * 4) + RemainCnt) > BufLen)
    return(LNUM_OP_PARAM_ERR);
  //----------------------------------------------------
  // Process incomplete element if present
  //----------------------------------------------------
  if(RemainCnt != 4)				// incomplete Element
  {
    while(RemainCnt != 0)
    {
      RemainCnt--;
      pDstBuf[DstIndex++] = (char) (WElement >> (RemainCnt*8));
    }
    ElementIndex--;
  }
  //----------------------------------------------------
  // Process remaining full elements if present
  //----------------------------------------------------
  while(ElementIndex >= 0)
  {
    WElement = pEl[ElementIndex];
    pDstBuf[DstIndex]   = (char) (WElement >> 24);
    pDstBuf[DstIndex+1] = (char) (WElement >> 16);
    pDstBuf[DstIndex+2] = (char) (WElement >> 8);
    pDstBuf[DstIndex+3] = (char) WElement;
    DstIndex += 4;
    ElementIndex--;
  }
  //------------------------------------------------------------
  // save length of transferred data
  //------------------------------------------------------------
  pDstLen[0] = DstIndex-DstStart;
  return(LNUM_OP_OK);
}

extern "C" int WLnum_wlnum2binLe(char* pDstBuf, int DstIndex,
		int* pDstLen, WLARGENUM* pWLnum, int ZeroFlag)
{
   int BufLen = pDstLen[0];
   int ElementIndex;
   int ElementCnt;
   int DstEnd;
   int RemainCnt;

   int WElement;
   int * pEl;
   //-----------------------------------------------------
   // check parameters, assure Destination buffer size > 0
   //-----------------------------------------------------
   if((pDstBuf ==  NULL) || (pWLnum == NULL))
      return(LNUM_OP_NULL_PTR);
   if(BufLen <= 0)
      return(LNUM_OP_ZERO_SIZE);
   //-----------------------------------------------------
   // check special case WLnum == 0
   //-----------------------------------------------------
   ElementCnt = pWLnum->UsedSize;
   if(ElementCnt == 0)
   {
      pDstBuf[DstIndex] = 0;
      pDstLen[0] = 1;
      return(LNUM_OP_OK);
   }
   //----------------------------------------------------
   // Prepare check for buffer length
   //----------------------------------------------------
   pEl = pWLnum->lpEl;				// get base pointer
   ElementIndex = ElementCnt - 1;		// index to top element
   WElement = pEl[ElementIndex];			// get top Element
   RemainCnt = HardGetByteCntWLnumElem(WElement);// get number of bytes

   DstIndex = (ElementCnt-1)*4 + RemainCnt - 1;	// to buffer top
   DstEnd = DstIndex;

   if((ZeroFlag != 0) &&				// insert zero if Top Bit set
      ((WElement & ((int) 0x080 << ((RemainCnt-1)*8))) != 0))
   {
      pDstBuf[DstIndex--] = 0;			// Insert NULL Byte
      BufLen--;					// reduce size for check...
   }    
   if((((ElementCnt-1) * 4) + RemainCnt) > BufLen)
      return(LNUM_OP_PARAM_ERR);
   //----------------------------------------------------
   // Process incomplete element if present
   //----------------------------------------------------
   if(RemainCnt != 4)				// incomplete Element
   {
      while(RemainCnt != 0)
      {
         RemainCnt--;
         pDstBuf[DstIndex--] = (char) (WElement >> (RemainCnt*8));
      }
      ElementIndex--;
   }
   //----------------------------------------------------
   // Process remaining full elements if present
   //----------------------------------------------------
   while(ElementIndex >= 0)
   {
      WElement = pEl[ElementIndex];
      pDstBuf[DstIndex]   = (char) (WElement >> 24);
      pDstBuf[DstIndex-1] = (char) (WElement >> 16);
      pDstBuf[DstIndex-2] = (char) (WElement >> 8);
      pDstBuf[DstIndex-3] = (char) WElement;
      DstIndex -= 4;
      ElementIndex--;
   }
   //------------------------------------------------------------
   // save length of transferred data
   //------------------------------------------------------------
   pDstLen[0] = DstEnd - DstIndex;
   return(LNUM_OP_OK);
}

extern "C" int WLnum_wlnum2binFill(char* pDstBuf, int DstIndex,
		int* pDstLen, WLARGENUM* pWLnum, int ReqNumLen)
{
  int BufLen = pDstLen[0];
  int ElementIndex;
  int ElementCnt;
//  int DstStart = DstIndex;
  int RemainCnt;
  int NumLen;
  int FillCount;

  int WElement;
  int* pEl;
  //-----------------------------------------------------
  // check parameters, assure Destination buffer size > 0
  //-----------------------------------------------------
  if((pDstBuf ==  NULL) || (pWLnum == NULL))
    return(LNUM_OP_NULL_PTR);

  if((BufLen <= 0) || (ReqNumLen <= 0))
    return(LNUM_OP_ZERO_SIZE);

  if(ReqNumLen > BufLen)
    return(LNUM_OP_PARAM_ERR);

  pDstLen[0] = ReqNumLen;
  //------------------------------------------------------
  // Get used bytecount for number, generate leading zeros
  // Check if number was 0
  //------------------------------------------------------
  NumLen = GetByteCntWLnum(pWLnum);
  if(NumLen > ReqNumLen)			// ReqNumLen <= BufLen !!
    return(LNUM_OP_PARAM_ERR);

  FillCount = ReqNumLen - NumLen;
  if(FillCount != 0)
  {
    ClearBit8Array(pDstBuf, DstIndex, FillCount);
    DstIndex += FillCount;
  }
  if(NumLen == 0)				// number WAS zero!
    return(LNUM_OP_OK);
  //----------------------------------------------------
  // Prepare for number output
  //----------------------------------------------------
  ElementCnt = pWLnum->UsedSize;
  pEl = pWLnum->lpEl;			// get base pointer
  ElementIndex = ElementCnt - 1;		// index to top element
  WElement = pEl[ElementIndex];			// get top Element
  RemainCnt = HardGetByteCntWLnumElem(WElement);// get number of bytes
  //----------------------------------------------------
  // Process incomplete element if present
  //----------------------------------------------------
  if(RemainCnt != 4)				// incomplete Element
  {
    while(RemainCnt != 0)
    {
      RemainCnt--;
      pDstBuf[DstIndex++] = (char) (WElement >> (RemainCnt*8));
    }
    ElementIndex--;
  }
  //----------------------------------------------------
  // Process remaining full elements if present
  //----------------------------------------------------
  while(ElementIndex >= 0)
  {
    WElement = pEl[ElementIndex];
    pDstBuf[DstIndex]   = (char) (WElement >> 24);
    pDstBuf[DstIndex+1] = (char) (WElement >> 16);
    pDstBuf[DstIndex+2] = (char) (WElement >> 8);
    pDstBuf[DstIndex+3] = (char) WElement;
    DstIndex += 4;
    ElementIndex--;
  }
  return(LNUM_OP_OK);
}
#ifdef XH_INTERFACE

#define HMEM_USR_FLD HMEM_CTX_REF
#define USR_FLD_HMEM (ds__hmem *)vpp_user_field,

#else


#define HMEM_USR_FLD NULL
#define USR_FLD_HMEM 

#endif // XH_INTERFACE

/**
Wrapper function for SecDrbgRandBytes to match amd_get_rand.

The user field parameter is used to hand over the hmem pointer, if 
XH_INTERFACE is defined. Otherwise, it is not used and may be left undefined.


@param[in]  vpp_user_field Pointer to hmem structure.
@param[out] achp_dest      Pointer to buffer to be filled.
@param[in]  inp_dest_len   Length of buffer in bytes.

@return TRUE on success, FALSE on error.
*/
extern "C" BOOL m_rand_wrapper(void* vpp_user_field, 
                           char* achp_dest, 
                           int inp_dest_len)
{
   int inl_ret = SecDrbgRandBytes(USR_FLD_HMEM achp_dest, 0, inp_dest_len);

   return inl_ret == 0;
}

extern "C" int WLnumRand(HMEM_CTX_DEF
                         WLARGENUM* pRnd, int BitSize,
                         int TopFlag, int OddFlag)
{
   return WLnumRand_impl(HMEM_CTX_REF1 pRnd, BitSize, TopFlag, OddFlag, HMEM_USR_FLD, m_rand_wrapper);
}

extern "C" int WLnumRand_impl(HMEM_CTX_DEF
				 WLARGENUM* pRnd, int BitSize,
				 int TopFlag, int OddFlag,
             void* vpp_user_field, amd_get_random amp_get_rand)
{
  char* pBuffer;
  int ByteCount, MsbBit, BitMask, i;
//  BIT32 l;
//  BIT8ARRAY(Bit8Fld,4);			// helper for RandSeed

  if(BitSize <= 0)				// no bits requested
    return(LNUM_OP_ZERO_SIZE);
  //------------------------------------------------------------
  // calculate Byte requirement for buffer, allocate
  //------------------------------------------------------------
  ByteCount = (BitSize+7)/8;			// calculate required bytes
  MsbBit = BitSize % 8;				// get number of MSB (rel. 0)
  if((pBuffer = BIT8_ARRAY_ALLOC(HMEM_CTX_REF,ByteCount)) == NULL)
    return(LNUM_OP_ALLOC_ERR);			// exit
  //------------------------------------------------------------
  // seed random generator and get random number
  // NOTE: the random number will be interpreted as BIG ENDIAN
  //------------------------------------------------------------

// NOTE: New Random generator used
//  printf("\r\nGetting Random Bytes");
//  RAND_BYTES(RANDinst, pBuffer, 0, ByteCount);	// get random
    BOOL bol_rand_success = amp_get_rand(vpp_user_field, pBuffer,ByteCount);
    if(!bol_rand_success)
    {
      FREE_CARRAY(HMEM_CTX_REF,pBuffer);
      return(-1);
    }
//  printf("\r\nGot Random Bytes");
  //------------------------------------------------------------
  // check if odd number is requested
  //------------------------------------------------------------
  if(OddFlag != 0)				// odd number requested
    pBuffer[ByteCount-1] |= 1;			// set odd (BIG ENDIAN order !)
  //------------------------------------------------------------
  // check if top most bits should be set to 1
  //------------------------------------------------------------
  if(MsbBit == 0)				// no bits to mask off
    BitMask = 0xFF;
  else						// generate mask
    BitMask = ~(0xFF << MsbBit);

  pBuffer[0] = (unsigned char) (pBuffer[0] & BitMask);	// mask off non required bits

  if(TopFlag != 0)				// must set topmost bits
  {
    if(MsbBit == 0)				// full byte, no mask off
      pBuffer[0] |= 0xC0;			// set topmost bits
    else
    {
      if(MsbBit == 1)				// special case
      {
        pBuffer[0] = 1;				// set bit
        pBuffer[1] |= (unsigned char) 0x80;		// dto.
      }
      else
      {
        pBuffer[0] = (unsigned char)
          (pBuffer[0] | (3 << (MsbBit-2)));	// set topmost bits
      }
    }
  }
  else
  {
    if(MsbBit == 0)				// full byte, no mask off
      pBuffer[0] |= (unsigned char) 0x80;		// set topmost bit
    else
    {
      pBuffer[0] = (unsigned char)
        (pBuffer[0] | (1 << (MsbBit-1)));	// set topmost bit
    }
  }
  //------------------------------------------------------------
  // convert random number to long number representation
  //------------------------------------------------------------
//  printf("\r\nConverting to large number");

  i = WLnum_bin2wlnum(HMEM_CTX_REF1 pRnd, pBuffer, 0, ByteCount);
//  printf("\r\nConverted to large number");
  do
  {
    ByteCount--;			// predecrement
    pBuffer[ByteCount] = 0;		// clear
  }while(ByteCount != 0);
  FREE_CARRAY(HMEM_CTX_REF,pBuffer);
  return(i);
}

extern "C" int ModWordWLnum(WLARGENUM* pWnumU, short Modulus)
{
  int i, d;
  int uH, uL, w, ML, SL, Rem;
  int v = (int) Modulus & 0xFFFF;
  int* pEl;

  if(pWnumU == NULL)
    return(-1);
  //----------------------------------------------------------
  // check for zero divisor, by definition x mod 0 = x
  //----------------------------------------------------------
  if(Modulus == 0)				// out of range
    return(LNUM_OP_ZERO_DIV);
  if(IsZeroWLnum(pWnumU) != 0)			// 0 mod n = 0
    return(0);
  //------------------------------------------------------------
  // Normalize the Divisor to Base 16
  //------------------------------------------------------------
  d = 16 - HardGetBitCntWLnumElem(v);		// get normalize shift
  v = v << d;					// normalize Divisor
  //-------------------------------------------------------------
  // Get the BIT32 Dividend Elements normalize Shift Counts/Masks
  //-------------------------------------------------------------
  SL = (32-d) & 0x1F;				// Dividend Low right(!) shift
  ML = 0;					// assume no bits to shift
  if(SL != 0)					// must propagate bits !
  {
    ML = ~((int) 0x80000000 >>(31-d)); // Dividend Low  AND mask
  }

  //-------------------------------------------------------------
  // Initialize Operation
  //-------------------------------------------------------------
  pEl = pWnumU->lpEl;
  uL = 0;
  Rem = 0;
  //-----------------------------------------------------------------
  // Calculate the remainder
  //-----------------------------------------------------------------
  if(d == 0)					// special case, full elements
  {
    i = pWnumU->UsedSize;			// should not be zero
    do
    {
      i--;					// predecrement, use as index
      w = pEl[i];				// get next BIT32 Element
      Rem = NormDiv32By16Bit64((Rem << 16) | ((w >> 16) & 0xFFFF), v, NULL);
      Rem = NormDiv32By16Bit64((Rem << 16) | (w & 0xFFFF), v, NULL);
    }while(i != 0);
  }
  else
  {
    //-----------------------------------------------------------------
    // Dividend smaller than 16 bit
    //-----------------------------------------------------------------
    i = pWnumU->UsedSize;			// should not be zero
    do
    {
      i--;					// predecrement, use as index
      uH = uL;
      uL = pEl[i];				// get next BIT32 Element
      w = (uH << d) | ((uL >> SL) & ML);	// combine to normalized Divid.
      Rem = NormDiv32By16Bit64((Rem << 16) | ((w >> 16) & 0xFFFF), v, NULL);
      Rem = NormDiv32By16Bit64((Rem << 16) | (w & 0xFFFF), v, NULL);
    }while(i != 0);
    //-----------------------------------------------------------------
    // Post-Process remaining Element if any, renormalize
    //-----------------------------------------------------------------
    w = (uL << d);				// combine to normalized Divid.
    Rem = NormDiv32By16Bit64((Rem << 16) | ((w >> 16) & 0xFFFF), v, NULL);
    Rem = NormDiv32By16Bit64((Rem << 16) | (w & 0xFFFF), v, NULL);
    Rem = (Rem >> d);				// re-normalize
  }
  return(Rem & 0x0000FFFF);
}

//()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()
//
// Prime Generation routines, only used for KEY Generation !!
//
//()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()

// NOTE: The quick sieve algorithm approach to weeding out primes is
// ----  Philip Zimmermann's, as implemented in PGP.

/** @} */
#define	WRND_BITS_LIMIT	32	// for Miller Rabin test
#define WSMALL_PRIME_CNT	302	// small numbers < 2000, suggested
					// by B.SCHNEIER

/** @addtogroup lnum32
*  @{
*/
extern "C" int DoEratosthenesWSieve(HMEM_CTX_DEF
		short* pPrimesArr, int MaxNums)
{
  char BitMask = (char) ((unsigned char) 0x80);
  char BitMaskHlp;

  char* pBitFieldBuf;

  int	PrimeCnt=0;				// counter and index !!
  int	NumberRange;

  int	i,k;
  int   MaxRange;
  int	HelpSize;

  int	j=0;					// S1: Initialisation
  int	p=3;					// dto.
  int	q=4;					// dto.
  //------------------------------------------------------------
  // Calculate approx. required Number-Range M = N/2
  //------------------------------------------------------------
  NumberRange = ((int) MaxNums ) * 5;		// times 10/2
  if(NumberRange >= 0x8000)			// is too large
    return(-1);
  MaxRange = (int) (NumberRange & 0xFFFF);	// M
  HelpSize = (int) ((NumberRange + 7) >> 3);	// required Bytes
  //------------------------------------------------------------
  // S1: Allocate Helper-Bitfield and preload with all ones
  //------------------------------------------------------------
  if((pBitFieldBuf = BIT8_ARRAY_ALLOC(HMEM_CTX_REF,HelpSize)) == NULL)
    return(0);					// allocate failure
  i = HelpSize;
  do
  {
    i--;					// predecrement, use as index
    pBitFieldBuf[i] = (char) ((unsigned char) 0xFF);	// load value
  }while(i != 0);
  //------------------------------------------------------------
  // Start algorithm (note: 0 <= k < M)
  //------------------------------------------------------------
  i = 0;					// index to bottom
  do
  {
    //----------------------------------------------------------
    // S2: Check if bit set; if so, number is prime
    //----------------------------------------------------------
    if((pBitFieldBuf[i] & BitMask) != 0)	// found prime number
    {
      pPrimesArr[PrimeCnt] = (short) p;		// save prime number
      PrimeCnt++;
      if(PrimeCnt >= MaxNums)			// Table is full
      {
        FREE_CARRAY(HMEM_CTX_REF,pBitFieldBuf);
        return(PrimeCnt);
      }
      //--------------------------------------------------------
      // S3: Zero out related bits 
      //--------------------------------------------------------
      k = q-1;					// Bit Startindex
      do
      {
        BitMaskHlp =
          (char) ((int) 0x80 >> (k & 0x07));	// get bit mask
        pBitFieldBuf[k >> 3] = (unsigned char)
          (pBitFieldBuf[k >> 3] & ~BitMaskHlp);	// zero bit
        k += p;
      } while(k < MaxRange);
    }     
    //----------------------------------------------------------
    // S4: to next, recalculate, advance bitmask
    //----------------------------------------------------------
    BitMask = (char) ((BitMask >> 1) & 0x7F);	// to next Bitmask
    if(BitMask == 0)
    {
      BitMask = (char) ((unsigned char) 0x80);
      i++;
    }
    j++;
    p += 2;
    q += 2*(p-1);
  } while(q < MaxRange);
  //------------------------------------------------------------
  // S5: check if more bits are set to one
  //------------------------------------------------------------
  while(j < MaxRange)
  {
    if((pBitFieldBuf[i] & BitMask) != 0)		// found number
    {
      pPrimesArr[PrimeCnt] = (short)((2*j) + 3);	// save number
      PrimeCnt++;
      if(PrimeCnt >= MaxNums)			// Table is full
      {
        FREE_CARRAY(HMEM_CTX_REF,pBitFieldBuf);
        return(PrimeCnt);
      }
    }
    BitMask = (char) ((BitMask >> 1) & 0x7F);	// next Bitmask
    if(BitMask == 0)
    {
      BitMask = (char) ((unsigned char) 0x80);
      i++;
    }
    j++;
  }
  FREE_CARRAY(HMEM_CTX_REF,pBitFieldBuf);
  return(PrimeCnt);
}

extern "C" int WLnumMillerRabin(HMEM_CTX_DEF
			WLARGENUM* pWnumN, int CheckCount,
			int* pResult, WLNUM_CONTEXT* pCtx,
			void callback(int))
{
  int i,j,k;

  int RndBits;				// bitcount for random number
  int ElementCnt;			// elements used in number n
  int Retcode = LNUM_OP_OK;		// assume o.k.
  int CheckStat = 0;			// probable prime, <>0 not.
  int WLnumReleaseCnt = 0;

  WLARGENUM* pWnm1 = NULL;		// n - 1
  WLARGENUM* pWrnd = NULL;		// random a
  WLARGENUM* pWx   = NULL;		// a ** q etc.
  WLARGENUM* pWres = NULL;		// temporary result

  WLARGENUM* pWtmp;			// needed for reference swap

  WLARGENUM** pNumArr;
  WLNUM_CONTEXT* pTmpCtx = NULL;

  int Elu;
  int u;
  int* pEl;
  //-----------------------------------------------------------
  // assure that we do at least one check !
  //-----------------------------------------------------------
  if(CheckCount <= 0)
    CheckCount = 1;			// at least one check needed
  //-----------------------------------------------------------
  // for easier error processing we use an indefinite FOR loop
  //-----------------------------------------------------------
  for(;;)
  {
    //---------------------------------------------------------
    // check that number n is odd
    //-----------------------------------------------------------
    ElementCnt = pWnumN->UsedSize;	// get elementcount
    u = pWnumN->lpEl[0];			// get the LSB Element
    if(((u & 0x01) == 0) ||			// 'even' prime !!
       ((ElementCnt == 1) &&
        ((u & 0xFFFFFF00) == 0) && (u < 3)))		// too small
    {
//      if((u & 0x01) == 0)				// TEST TEST TEST
//        PRINT("\nMILLER RABIN: Number not odd");	// TEST TEST TEST
//      else						// TEST TEST TEST
//        PRINT("\nMILLER RABIN: Number too small");	// TEST TEST TEST
      Retcode = LNUM_OP_INVALID_PRIME;
      break;
    }
    //---------------------------------------------------------
    // get required bitsize for random number
    //-----------------------------------------------------------
    i = ElementCnt-1;				// topmost used
    j = HardGetBitCntWLnumElem(pWnumN->lpEl[i])+ (32*i);
    RndBits = j-1;				// set for random gen.
    if(RndBits > WRND_BITS_LIMIT)		// shrink if necessary
      RndBits = WRND_BITS_LIMIT;
    //---------------------------------------------------------
    // allocate required large numbers
    // NOTE: Take from CTX structure !!!
    //---------------------------------------------------------
    i = ElementCnt+1;				// required size + 1
    if(pCtx == NULL)				// no context given
    {
//      PRINT("MR:Alloc Context, WLNUM-Size: ");
//      PRINT_INT_NL(i);

      if((pTmpCtx = AllocWLnumContext(HMEM_CTX_REF1 3+4+36+32, i)) == NULL)
      {
        Retcode = LNUM_OP_ALLOC_ERR;
        break;
      }
      pNumArr = pTmpCtx->pWLnumArr;
      pWnm1 = pNumArr[0];
      pWrnd = pNumArr[1];
      pWx   = pNumArr[2];
      pWres = pNumArr[3];
      pTmpCtx->NextFreeIndex = 4;
      pCtx = pTmpCtx;
    }
    else					// context is given, check size
    {
      j = pCtx->NextFreeIndex;
      if((j + 3+4+36) >= pCtx->AllocedNumCnt)
      {
        Retcode = LNUM_OP_CTX_FULL;
        break;
      }
      pWnm1 = GetWLnumPtrFromContext(HMEM_CTX_REF1 pCtx, i);
      pWrnd = GetWLnumPtrFromContext(HMEM_CTX_REF1 pCtx, i);
      pWx   = GetWLnumPtrFromContext(HMEM_CTX_REF1 pCtx, i);
      pWres = GetWLnumPtrFromContext(HMEM_CTX_REF1 pCtx, i);
      if((pWnm1 == NULL) || (pWrnd == NULL) ||	// allocation failure
         (pWx   == NULL) || (pWres == NULL))
      {
        Retcode = LNUM_OP_ALLOC_ERR;
        break;
      }
      WLnumReleaseCnt = 4;
    }
    //-----------------------------------------------------------
    // 1. get n-1, q and loopcount k
    //-----------------------------------------------------------
    if((Retcode = CopyWLnum(HMEM_CTX_REF1
			    pWnm1,pWnumN)) != LNUM_OP_OK) // copy n -> n-1
      break;
    pWnm1->lpEl[0] = (pWnm1->lpEl[0] & 0xFFFFFFFE);	// subtract one (was odd !!)

    if((Retcode = CopyWLnum(HMEM_CTX_REF1
			    pWres,pWnm1)) != LNUM_OP_OK) // copy (n-1) -> x
      break;
    //----------------------------------------------------------
    // search for first Element not zero to get shift count
    // NOTE: There MUST be at least one element !!
    // -----
    //----------------------------------------------------------
    pEl = pWres->lpEl;
    k = 0;					// clear shiftcount
    i = 0;					// startindex
    for(;;)					// search non zero element
    {
      if(pEl[i] != 0)
        break;
      k += 32;					// one element more
      i++;
    }

    Elu = pWres->lpEl[i];			// get element
    for(;;)
    {
      if((Elu & 0x01) != 0)			// non zero bit found
        break;
      Elu = (Elu >> 1) & 0x7FFFFFFF;		// to next bit-->optimize!!
      k++;					// increment count
    }

//    PRINT("MR:WRes before normalize shift: ");
//    ShowLnum(pWres);
    if((Retcode = RshiftWLnum(HMEM_CTX_REF1
			pWres,pWres,k)) != LNUM_OP_OK) // normalize q
      break;
//    PRINT("MR:WRes after normalize shift: ");
//    ShowLnum(pWres);
    //===========================================================
    // Check loop
    //===========================================================
//    PRINT("R-Checkloop enter..");
    do
    {
      //---------------------------------------------------------
      // 2. Get Random number
      //---------------------------------------------------------
      if((Retcode = WLnumRand(HMEM_CTX_REF1 pWrnd, RndBits,0,0)) != LNUM_OP_OK)
        break;					// leave inner loop
//      PRINT("MR: Wnm1 = ");
//      ShowLnum(pWnm1);
      //---------------------------------------------------------
      // 3. Calculate a ** q mod n, check if result is 1 or -1;
      //    if so -> probably prime
      //---------------------------------------------------------
//    PRINT("Expmod enter..");

      Retcode = ExpModWLnum(HMEM_CTX_REF1
			    pWx, pWrnd, pWres, pWnumN, pCtx, callback);

//    PRINT_NL("  Expmod left");

      if(Retcode != LNUM_OP_OK)			// leave check loop
        break;
      if((IsOneWLnum(pWx) != 0) ||			// is 1
         (UcompWLnum(pWx, pWnm1) == WLNUM_1ST_EQ_2ND))	// is -1
      {
//      PRINT("-Might be prime-");
        CheckCount--;
	if(callback != NULL)
          callback(1);
        continue;				// may be prime
      }
      //-------------------------------------------------------
      // 4. initialize inner test loopcount, check if <> 0
      //    if count  i s  0 -> not prime
      //-------------------------------------------------------
      i = k-1;					// set loopcnt
      if(i == 0)
      {
//      PRINT_NL("NotPrime1");
        CheckStat = 1;				// not prime
        break;					// exit
      }
      do
      {
        //-----------------------------------------------------
        // 5. Calculate x = (x ** 2) mod n, decide on result
        //-----------------------------------------------------

        if((Retcode = MulModWLnum(HMEM_CTX_REF1
			pWres,pWx,pWx,pWnumN,pCtx)) != LNUM_OP_OK)
          break;

        if(IsOneWLnum(pWres) != 0)		// = 1, not prime
        {
//        PRINT_NL("NotPrime2");
          CheckStat = 1;			// set  n o t  prime
          break;
        }
        if(UcompWLnum(pWres,pWnm1) == WLNUM_1ST_EQ_2ND) // = -1
          break;				// further checking if req.

        pWtmp = pWx;				// exchg. lpres <-> lpx
        pWx   = pWres;
        pWres = pWtmp;
        i--;
      }while(i != 0);			
      //-----------------------------------------------------
      // check if all k loops processed, if so, not prime
      //-----------------------------------------------------
      if(Retcode != LNUM_OP_OK) break;// error occured, exit check loop
      if(CheckStat != 0) break;	// not prime found, exit check loop
      if(i == 0)
      {
        CheckStat = 1;		// set  n o t  prime
//      PRINT("NotPrime3");
        break;			// exit outer check loop
      }
      CheckCount--;			// reduce counter
      if(callback != NULL)
        callback(1);
    }while(CheckCount > 0);
    //-----------------------------------------------------------
    // all checks processed / Error occured / not prime stated
    //-----------------------------------------------------------
    break;				// exit for loop
  } // outmost FOR loop
  //-----------------------------------------------------------
  // report result, free allocated buffers
  //-----------------------------------------------------------
  if(Retcode != LNUM_OP_OK)		// we had an error
  {
//    PRINT("Miller Rabin Retcode: ");
//    PRINT_INT_NL(Retcode);
    pResult[0] = 1;			// force not prime
  }
  else
    pResult[0] = CheckStat;		// report true state  

  if(pTmpCtx != NULL)
  {
    FreeWLnumContext(HMEM_CTX_REF1 pTmpCtx);
  }
  if(WLnumReleaseCnt != 0)
    ReleaseWLnumsFromContext(pCtx, WLnumReleaseCnt);
  return(Retcode);
}

/**
* Generates a WLarge number that has specified number of bits and no small 
* prime divisors (GetWPrimeCandidate).
* If requested selects only numbers that are potential 
* candidates for strong primality checking.
*
* NOTE: No checking for strong primality or special Diffie Hellman
*       requirements is done.
*
*  @param pW Large number struct pointer
*  @param Bits Number of random bits to use
*  @param Strong != 0 strong prime (Bit 1 = 1)
*  @param PrimeArray small primes array
*  @param PrimeCnt Max number of small primes
*               in the small prime array
*  @param ModArray Array for modulus calculation
*  @param DeltaStart Start for delta
*  @param DeltaMax Upper limit for delta
*  @return Status / Current Delta if >= 0
*/
static int GetWPrimeCandidate(HMEM_CTX_DEF
			WLARGENUM* pW, int Bits, int Strong,
			short* PrimeArray, int PrimeCnt,
			short* ModArray, int DeltaStart, int DeltaMax)
{
  int i;
  int Retcode = 0;
  int RetryCnt = 0;
  int l;
  int delta=DeltaStart;		// increment to next trial num.

  //-----------------------------------------------------------------
  // for easier error processing we use an outer for loop 
  //-----------------------------------------------------------------
  for(;;)
  {
    if(delta == 0)
    {
      DeltaStart = 0; 
      //--------------------------------------------------------------
      // Get a random number to start generation, preload sieve values
      //--------------------------------------------------------------
      Retcode = WLnumRand(HMEM_CTX_REF1
			  pW, Bits, 1, 1);	// get random WLnum, odd/topset
      if(Retcode != LNUM_OP_OK)
        break;
      if(Strong != 0)
        pW->lpEl[0] |= 0x02;		// to avoid (p-1)/2 to be even

      i = PrimeCnt;
      do
      {
        i--;					// predecrement, use as index
        l = ModWordWLnum(pW, PrimeArray[i]);	// get p mod (prime) 
        if( l < 0)
        {
          Retcode = LNUM_OP_ZERO_DIV;		// out of range
          break;					// leave inner loop
        }
        ModArray[i] = (short) l;			// save modulus
      }while(i != 0);
      if(Retcode != LNUM_OP_OK)
        break;					// we had an error
    }
    else					// delta from last, advance
    {
      if(Strong == 0)
        delta += 2;
      else
        delta += 4;
    }
    //--------------------------------------------------------
    // now check pW for possible primality using small primes,
    // if p not prime modify p using the addition increment
    //--------------------------------------------------------
//    PRINT_NL("Check small primes... ");
    for(;;)
    {
      //------------------------------------------------------
      // weed out small prime numbers (2 is not checked);
      // this is done using a simple modulo operation
      //------------------------------------------------------
      i = 0;
      do
      {
        if(((delta + ((int) ModArray[i] & 0xFFFF)) %
            ((int) PrimeArray[i] & 0xFFFF)) <= 1) // not a prime
          break;
        i++;					// to next index
      }while(i < PrimeCnt);
      if(i == PrimeCnt)				// all test passed
      {
        RetryCnt = -1;
         
        Retcode = AddElementWLnumBit64(HMEM_CTX_REF1
			pW,delta-DeltaStart);// generate number

	RetryCnt = -1;
        break;					// exit loop
      }
      else					// not a prime
      {
        if(Strong == 0) 
          delta += 2;				// to next number
        else
          delta += 4;				// keep Bit 1 set !

        if(delta <= DeltaMax)			// just advance
          continue;				// do small prime check

        RetryCnt++;
        delta = 0;
//      PRINT("R");
        break;
      }
    } // Prime Check loop
    if(RetryCnt < 0)				// got a prime/error
      break;
    if(RetryCnt > 10)
    {
      Retcode = LNUM_OP_INVALID_PRIME;		// set error
      break;
    }    
  }
  if(Retcode == LNUM_OP_OK)			// without error
    Retcode = (int) delta;

  return(Retcode);
}

/**
* Generates a large number that has specified number of bits and no small prime
* divisors (GetWPrimeCandidate_DH). 
* Selects only those numbers that also satisfy base/generator 
* restrictions for Diffie-Hellman.
* Uses 1 + 2 CTX elements.
*
*  @param pWLnum Large number struct pointer
*  @param Bits Number of random bits to use
*  @param pAdd Distance to add to random
*  @param pRem Remainder for additional test:
*               (p) mod add = rem
*  @param PrimeArray Small primes array
*  @param PrimeCnt Max number of small primes
*               in the small prime array
*  @param pCtx Context for WLNUMs. Optional
*  @return 0 on success, error code otherwise
*/
static int GetWPrimeCandidate_DH(HMEM_CTX_DEF
		WLARGENUM* pWLnum, int Bits,
		WLARGENUM* pAdd, WLARGENUM* pRem,
		short* PrimeArray, int PrimeCnt, WLNUM_CONTEXT* pCtx)
{
  int i,j, Retcode;
  int WLnumReleaseCnt = 0;

  int l;

  WLARGENUM* pTmp = NULL;
  WLNUM_CONTEXT* pTmpCtx = NULL;
 
  //-----------------------------------------------------------------
  // allocate temporary number structure
  //-----------------------------------------------------------------
  i = (Bits + 32-1) / 32 + 1; // get Element count needed
  if(pCtx == NULL)				// no context
  {
    if((pTmpCtx = AllocWLnumContext(HMEM_CTX_REF1 1+2, i)) == NULL)
      return(LNUM_OP_ALLOC_ERR);
    pTmp = pTmpCtx->pWLnumArr[0];
    pTmpCtx->NextFreeIndex = 6;
    pCtx = pTmpCtx;
  }
  else						// context given
  {
    j = pCtx->NextFreeIndex;
    if((j + 1+2) >= pCtx->AllocedNumCnt)
      return(LNUM_OP_CTX_FULL);
    if((pTmp = GetWLnumPtrFromContext(HMEM_CTX_REF1 pCtx, i)) == NULL)
      return(LNUM_OP_ALLOC_ERR);
    WLnumReleaseCnt = 1;
  }
  //-----------------------------------------------------------------
  // for easier error processing we use an outer for loop 
  //-----------------------------------------------------------------
  for(;;)
  {
    //---------------------------------------------------
    // get odd random number
    //---------------------------------------------------
    if((Retcode = WLnumRand(HMEM_CTX_REF1 pWLnum, Bits, 0, 1)) != LNUM_OP_OK)
      break;
    //---------------------------------------------------
    // adjust odd random to satisfy pWLnum mod pAdd = pRem:
    // 1. r = p - p mod add -> r mod add = 0 i.e. r = k * add;
    //    since add is always even, r will be even too
    // 2. p' = r + rem -> s mod add = (k*add + rem) mod add =
    //    (k*add) mod add + (rem) mod add = 0 + rem = rem
    //    so p' satisfies ganerator condition and since
    //    r is even and rem is always odd p' will also be odd !
    //---------------------------------------------------
    if((Retcode = ModWLnum(HMEM_CTX_REF1
		    pTmp, pWLnum, pAdd, pCtx)) != LNUM_OP_OK) // tmp = p mod a
      break;

    if((Retcode = SubWLnum(HMEM_CTX_REF1
			pWLnum,pWLnum,pTmp)) != LNUM_OP_OK) //p=p- p mod a (Rest)
      break;

    if(pRem == NULL)				// assume rem = 1
    {
      Retcode = AddElementWLnumBit64(HMEM_CTX_REF1
				     pWLnum,1);// p=(p - p mod a)+1
      if(Retcode != LNUM_OP_OK) break;
    }
    else
    {
      Retcode = AddWLnum(HMEM_CTX_REF1
			 pWLnum,pWLnum,pRem);// p = (p - p mod a) + rem
      if(Retcode != LNUM_OP_OK) break;
    }
    //--------------------------------------------------------
    // now check p for possible primality using small primes,
    // if p not prime modify p using the addition increment
    //--------------------------------------------------------
    for(;;)
    {
      //------------------------------------------------------
      // weed out small prime numbers (2 is not checked)
      // this is done using mod operation
      //------------------------------------------------------
      i = 0;
      do
      {
        l = ModWordWLnum(pWLnum,PrimeArray[i]);	// p mod (prime) must be > 1 ??
        if(l < 0)
        {
          Retcode = LNUM_OP_ZERO_DIV;		// out of range
          break;				// leave inner loop
        }
        if(l <= 1)				// not prime, get next
        {
          Retcode = AddWLnum(HMEM_CTX_REF1
			     pWLnum,pWLnum,pAdd);// use given increment for p
          break;				// must retry / leave on error
        }
	i++;					// to next prime number
      }while(i < PrimeCnt);
      if(i == PrimeCnt) break;			// all test passed, leave loop
      if(Retcode != LNUM_OP_OK) break;		// error occured
    } // retry processing FOR-Loop
    break;					// exit outmost loop
  } // Error FOR

  if(pTmpCtx != NULL)
  {
    FreeWLnumContext(HMEM_CTX_REF1 pTmpCtx);
  }
  if(WLnumReleaseCnt != 0)
    ReleaseWLnumsFromContext(pCtx, WLnumReleaseCnt);
  return(Retcode);
}

/**
* Generates a large number that has specified number of bits and no small prime
* divisors (GetWPrimeCandidate_DH_Strong). 
* Selects only those numbers that also satisfy base/generator 
* restrictions for Diffie-Hellman and are candidates as strong prime numbers.
* Uses 3+2 CTX elements.
*
*  @param pWLnum Large number struct pointer
*  @param Bits Number of random bits to use
*  @param pAdd Distance to add to random
*  @param pRem Remainder for additional test:
*               (p) mod add = rem
*  @param PrimeArray Small primes array
*  @param PrimeCnt Max number of small primes
*               in the small prime array
*  @param pCtx Context for WLNUMs. Optional
*  @return 0 on success, error code otherwise
*/
static int GetWPrimeCandidate_DH_Strong(HMEM_CTX_DEF
	  WLARGENUM* pWLnum,
	  int Bits, WLARGENUM* pAdd, WLARGENUM* pRem,
	  short* PrimeArray, int PrimeCnt, WLNUM_CONTEXT* pCtx)

{
  int i,j;
  int Retcode;
  int WLnumReleaseCnt = 0;

  int l1,l2;

  WLARGENUM* pQ;
  WLARGENUM* p2Add;
  WLARGENUM* pTmp;
  WLARGENUM** pNumArr;

  WLNUM_CONTEXT* pTmpCtx = NULL;
  //-----------------------------------------------------------------
  // allocate temporary number structures
  //-----------------------------------------------------------------
  i = (Bits + 32-1) / 32 + 1;			// get Element count
  if(pCtx == NULL)				// no context given
  {
    if((pTmpCtx = AllocWLnumContext(HMEM_CTX_REF1 3+2, i)) == NULL)
     return(LNUM_OP_ALLOC_ERR);
    pNumArr = pTmpCtx->pWLnumArr;
    pQ    = pNumArr[0];
    p2Add = pNumArr[1];
    pTmp  = pNumArr[2];
    pTmpCtx->NextFreeIndex = 3;
    pCtx = pTmpCtx;
  }
  else						// context is given, check size
  {
    j = pCtx->NextFreeIndex;
    if((j + 3+2) >= pCtx->AllocedNumCnt)
      return(LNUM_OP_CTX_FULL);

    pQ    = GetWLnumPtrFromContext(HMEM_CTX_REF1 pCtx, i);
    p2Add = GetWLnumPtrFromContext(HMEM_CTX_REF1 pCtx, i);
    pTmp  = GetWLnumPtrFromContext(HMEM_CTX_REF1 pCtx, i);
    if((pQ == NULL) || (p2Add == NULL) ||	// allocation failure
       (pTmp == NULL))
      return(LNUM_OP_ALLOC_ERR);

    WLnumReleaseCnt = 3;
  }
  //-----------------------------------------------------------------
  // for easier error processing we use an outer for loop 
  //-----------------------------------------------------------------
  for(;;)
  {
    //---------------------------------------------------------------
    // a strong prime satisfies the condition p = 2*q + 1 where
    // q is also prime. we generate q first and derive p from it.
    // For the known generators the following conditions 
    // p mod 24 = 11, generator = 2  or
    // p mod 10 = 3 or 7, generator = 5 must hold.
    // for q this implies: q mod 24 = 5 or  q mod 10 = 1 or 3 must hold,
    // i.e. the modulus and the INT(remainder/2) is taken for q
    // generation so p will necessarily satisfy the conditions
    // proof: given q mod add = (rem-1)/2 with 'add'even, (rem-1)/2 odd
    //        1. q will be odd as q = k*add + (rem-1)/2
    //        2. p = 2 * q + 1 = 2*k*add + 2*(rem-1)/2 + 1 = 2*k*add + rem
    //           so p mod add = (2*k*add + rem) mod add =
    //		   ((2*k*add) mod add + rem mod add) mod add =
    //		   ( 0 + rem) mod add = rem q.e.d
    //---------------------------------------------------------------
    Bits--;					// 1 bit less (q is half of p) 

    Retcode = Lshift1WLnum(HMEM_CTX_REF1
			   p2Add,pAdd);		// get addition value for p
    if(Retcode != LNUM_OP_OK) break;

    Retcode = WLnumRand(HMEM_CTX_REF1		// get an odd random q
			pQ, Bits, 0, 1);
    if(Retcode != LNUM_OP_OK) break;

    /* we need ((rnd-rem) % add) == 0 to satisfy DH generator requirements */

    Retcode = ModWLnum(HMEM_CTX_REF1
		       pTmp, pQ, pAdd, pCtx);	// tmp = q mod a
    if(Retcode != LNUM_OP_OK) break;

    Retcode = SubWLnum(HMEM_CTX_REF1
			 pQ,pQ,pTmp);		// q = q - q mod a
    if(Retcode != LNUM_OP_OK) break;

    if(pRem == NULL)				// assume rem = 1
    {
      Retcode = AddElementWLnumBit64(HMEM_CTX_REF1
				     pQ,1);	// q = q + 1;
      if(Retcode != LNUM_OP_OK) break;
    }
    else
    {
      Retcode = Rshift1WLnum(HMEM_CTX_REF1
			     pTmp,pRem);	// tmp = (rem-1)/2
      if(Retcode != LNUM_OP_OK) break;
      Retcode = AddWLnum(HMEM_CTX_REF1
			 pQ,pQ,pTmp);		// q = q + (rem-1)/2
      if(Retcode != LNUM_OP_OK) break;
    }
    //---------------------------------------------------------
    // calculate number p from q
    //---------------------------------------------------------
    Retcode = Lshift1WLnum(HMEM_CTX_REF1
			   pWLnum,pQ);		// p = 2 * q
    if(Retcode != LNUM_OP_OK) break;

    Retcode = AddElementWLnumBit64(HMEM_CTX_REF1
				   pWLnum,1);	// p = 2q + 1
    if(Retcode != LNUM_OP_OK) break;
    //--------------------------------------------------------
    // now check p,q for possible primality using small primes,
    // if p,q not prime modify p,q using the addition increment
    //--------------------------------------------------------
    for(;;)
    {
      //------------------------------------------------------
      // weed out small prime numbers (2 is not checked !)
      // this is done using mod operation
      //------------------------------------------------------
      i = 0;
      do
      {
        l1 = ModWordWLnum(pWLnum,PrimeArray[i]);// p mod (prime) must be <> 0
        l2 = ModWordWLnum(pQ,PrimeArray[i]);	// q mod (prime) must be <> 0
        if((l1 < 0) || (l2 < 0))
        {
          Retcode = LNUM_OP_ZERO_DIV;		// out of range
          break;				// leave inner loop
        }
        if((l1 == 0) || (l2 == 0))		// not prime, get next
        {
          Retcode = AddWLnum(HMEM_CTX_REF1
			     pWLnum,pWLnum,p2Add);// use increment for p
          if(Retcode != LNUM_OP_OK) break;	// leave inner loop
          Retcode = AddWLnum(HMEM_CTX_REF1
			     pQ,pQ,pAdd);	// use given increment
          break;				// must retry / leave on error
        }
	i++;					// to next prime number
      }while(i < PrimeCnt);
      if(i == PrimeCnt) break;			// all test passed, leave loop
      if(Retcode != LNUM_OP_OK) break;		// error occured
    } // retry processing FOR-Loop
    break;					// exit outmost loop
  }
  if(pTmpCtx != NULL)
  {
    FreeWLnumContext(HMEM_CTX_REF1 pTmpCtx);
  }
  if(WLnumReleaseCnt != 0)
    ReleaseWLnumsFromContext(pCtx, WLnumReleaseCnt);
  return(Retcode);
}

extern "C" int GenPrimeWLnum(HMEM_CTX_DEF
	WLARGENUM* pPrime, int Bits,
        WLARGENUM* pStep, WLARGENUM* pRem, int Strong, WLNUM_CONTEXT* pCtx,
        void (*callback)(int))

{
  int i,j;
  int Retcode = LNUM_OP_OK;
  int WLnumReleaseCnt = 0;
  int CheckCount;
  int DeltaStart = 0;
  int DeltaMax;

  int pCheckState[1];

  short* pPrimeArray;				// prime number array
  short* pModArray;
  WLARGENUM* pTmp = NULL;

  WLNUM_CONTEXT* pTmpCtx = NULL;
  //----------------------------------------------------
  // Allocate temporary small prime number array
  //----------------------------------------------------
  if((pPrimeArray = BIT16_ARRAY_ALLOC(HMEM_CTX_REF,WSMALL_PRIME_CNT)) == NULL)
    return(LNUM_OP_ALLOC_ERR);
  //--------------------------------------------------------------
  // Allocate modulus array
  //--------------------------------------------------------------
  if((pModArray = BIT16_ARRAY_ALLOC(HMEM_CTX_REF,WSMALL_PRIME_CNT)) == NULL)
  {
    FREE_CARRAY(HMEM_CTX_REF,pPrimeArray);
    return(LNUM_OP_ALLOC_ERR);
  }
  //-----------------------------------------------------------
  // Set number of Miller-Rabin checks needed
  // according to ISO/IEC 18032 and FIPS 186-3 for 2**-100 propability
  // Note: only values for RSA primes are included, without auxillary primes
  //-----------------------------------------------------------

// NEW for ISO / FIPS
  if(Bits >= 2048)
    CheckCount =2;
  else if(Bits >= 1536)
    CheckCount = 3;
  else if(Bits >= 1024)
    CheckCount = 4;
  else if(Bits >= 512)
    CheckCount = 7;
  else if(Bits >= 256)
    CheckCount = 16;
  else
    CheckCount = 27;

  //-----------------------------------------------------------
  // Calculate Delta Maximum = Bits + Bits/2
  //-----------------------------------------------------------
  DeltaMax = (int) (Bits + Bits/2);

  //----------------------------------------------------
  // Generate small prime numbers
  //----------------------------------------------------
  DoEratosthenesWSieve(HMEM_CTX_REF1 pPrimeArray, WSMALL_PRIME_CNT);
  //-----------------------------------------------------------
  // for easier error processing we use an indefinite FOR loop
  //-----------------------------------------------------------
  for(;;)
  {
    //---------------------------------------------------------
    // Calculate WLNUM size needed for CTX/temp. number
    //---------------------------------------------------------
    i = (Bits + 32-1) / 32 + 1 + 1;		// get Element size count
    if(pCtx == NULL)
    {
      if((pTmpCtx = AllocWLnumContext(HMEM_CTX_REF1 1+43+1+32, i)) == NULL)
        return(LNUM_OP_ALLOC_ERR);
      pCtx = pTmpCtx;
    }
    else
    {
      j = pCtx->NextFreeIndex;
      if((j + 1+43) >= pCtx->AllocedNumCnt)
        return(LNUM_OP_CTX_FULL);
    }      
    //--------------------------------------------------------
    // Get temporary number structure if strong requested
    //--------------------------------------------------------
    if(Strong != 0)
    {
      if((pTmp = GetWLnumPtrFromContext(HMEM_CTX_REF1 pCtx, i)) == NULL)
      {
        Retcode = LNUM_OP_ALLOC_ERR;
        break;
      }
      if(pTmpCtx == NULL)
        WLnumReleaseCnt = 1;
    } 
    //--------------------------------------------------------
    // generate random number, according to desired mode
    //--------------------------------------------------------
    for(;;)
    {
      if(pStep == NULL)				// standard mode
      {
//      PRINT_NL("Getting Candidate");
        Retcode = GetWPrimeCandidate(HMEM_CTX_REF1	// get candidate
		     pPrime, Bits, Strong,
	             pPrimeArray, WSMALL_PRIME_CNT, pModArray,
		     DeltaStart, DeltaMax);
        DeltaStart = (int) Retcode;
        if(Retcode > 0)
          Retcode = 0;
//      PRINT_NL("Got Candidate");
      }
      else						// Diffie/Hellman
      {
        if(Strong == 0)					// no strong prime
          Retcode = GetWPrimeCandidate_DH(HMEM_CTX_REF1	// get candidate
			pPrime, Bits, pStep, pRem,
			pPrimeArray, WSMALL_PRIME_CNT, pCtx);
        else
          Retcode = GetWPrimeCandidate_DH_Strong(HMEM_CTX_REF1 // get candidate
		  	pPrime, Bits, pStep, pRem,
			pPrimeArray, WSMALL_PRIME_CNT, pCtx);
      }
      if(Retcode != LNUM_OP_OK)
//    {						// TEST TEST TEST
//      PRINT("\nCANDIDATE ERR");			// TEST TEST TEST
        break;			// error occured
//    }						// TEST TEST TEST
      if(callback != NULL)
        callback(0);				// signal prime check
      //------------------------------------------------------
      // check candidate for primality using Miller/Rabin test
      //------------------------------------------------------
//    PRINT("Doing Miller Rabin");

      Retcode = WLnumMillerRabin(HMEM_CTX_REF1
			pPrime, CheckCount, pCheckState, pCtx,
			callback);
//    PRINT(" finished Miller Rabin");

      if(Retcode != LNUM_OP_OK)
//    {						// TEST TEST TEST
//      PRINT("\nMILLER RABIN ERR");			// TEST TEST TEST
        break;		// leave inner loop
//    }   						// TEST TEST TEST
      //------------------------------------------------------
      // if strong prime requested must check q = (p-1)/2 too
      //------------------------------------------------------
      if((Strong != 0) && (pCheckState[0] == 0)) // strong prime requested
      {
//        PRINT(" StrongCheck ");
        if((pPrime->lpEl[0] & 0x02) == 0)	// (p-1)/2 is even, no check
        {
//          PRINT("P");
          pCheckState[0] = 1;
        }
        else
        {
          Retcode = Rshift1WLnum(HMEM_CTX_REF1
				 pTmp,pPrime);	// divide by 2 (prime is odd!)
          if(Retcode != LNUM_OP_OK)
          {
//            PRINT("\nRSHIFT ERR");		// TEST TEST TEST
            break;	// error occured
          }
          Retcode = WLnumMillerRabin(HMEM_CTX_REF1
			pTmp, CheckCount, pCheckState, pCtx,
			callback);
          if(Retcode != LNUM_OP_OK)
          {					// TEST TEST TEST
//              PRINT("\nMILLER RABIN ERROR 2");		// TEST TEST TEST
             break;	// leave inner loop
          }					// TEST TEST TEST
          if(pCheckState[0] == 0)			// TEST TEST TEST
          {
//            PRINT("\nStrong");
            break;
          }
        }
      }
      if(pCheckState[0] == 0)			// all tests passed
        break;
      if(callback != NULL)
      {
        callback(2);				// signal retry number

      }    
    } // retry loop
    break;
  } // outmost FOR loop

  FREE_CARRAY(HMEM_CTX_REF,pPrimeArray);
  FREE_CARRAY(HMEM_CTX_REF,pModArray);
  if(pTmpCtx != NULL)
  {
    FreeWLnumContext(HMEM_CTX_REF1 pTmpCtx);
  }
  if(WLnumReleaseCnt != 0)
    ReleaseWLnumsFromContext(pCtx, WLnumReleaseCnt);
  return(Retcode);
}

//()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()
//
// Montgomery routines
//
//()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()

/**
* Calculates the inverse element N0' for montgomery conversion
* based on the equality:	N0(2**i) * N0'(2**i) = 1 (mod 2**i)
* 				for i = 1...w (w = 32)
*
*  @param N0 lowest Element of modulus n
*  @return N0' negative(!) invers to N0 mod 2**32
*/
static int WLnumMontInvN0(int N0)
{
  int i;
  int Prod;
  int Ni0 = 1;
  int Mask = 1;

  //------------------------------------------------------------
  // get the invers Ni0 modulo 2**32
  //------------------------------------------------------------
  for(i=2;i<=32;i++)
  {
    Prod = N0 * Ni0;
    Mask = (Mask << 1) | 0x01;		// generate modulo mask 2**i
    Prod = Prod & Mask;			// isolate modulus
    if(Prod != 1)
    {
      Ni0 = Ni0 + ((int) 1 << (i-1));	// N0' = N0' + 2**(i-1)
    }
  }
  //------------------------------------------------------------
  // negate Ni0 modulo 2**32:
  // -Ni0 = (2**32 - Ni0) mod 2**32
  //------------------------------------------------------------

//  if(Ni0 == 0)			// special case, 2**32 mod 2**32 = 0
//    return(Ni);

  Ni0 = (~Ni0) + 1;			// 2's complement (0->0)

  return(Ni0);
}

/**
* Frees a montgomery context and its elements (FreeWLnumMontCtx).
*
*  @param pMontCtx Pointer to context
*/
extern "C" void FreeWLnumMontCtx(HMEM_CTX_DEF MONT_CONTEXT* pMontCtx)
{
  if(pMontCtx == NULL)
    return;
  FreeWLnum(HMEM_CTX_REF1 pMontCtx->pModN);
  FreeWLnum(HMEM_CTX_REF1 pMontCtx->pRSquare);
  FreeWLnum(HMEM_CTX_REF1 pMontCtx->pTmpLnum);
  FreeWLnum(HMEM_CTX_REF1 pMontCtx->pTmpMontLnum);

  FREE_ARRAY(HMEM_CTX_REF,pMontCtx);
}

/**
* Allocates a montgomery context and its elements,
* initializes the elements (AllocWLnumMontCtx).
*
*  @param pModN Modulus to use
*  @return New <code>MONT_CTX_PTR</code>/ NULL on error
*/
extern "C" MONT_CONTEXT* AllocWLnumMontCtx(HMEM_CTX_DEF WLARGENUM* pModN)
{
  int sLen;
  int* lpEl;
  MONT_CONTEXT* pMontCtx;
  //---------------------------------------------------------
  // check parameters first, modulus > 0 and odd !
  //---------------------------------------------------------
  if((pModN == NULL) || (pModN->UsedSize == 0) ||
     ((pModN->lpEl[0] & 0x01) == 0))
    return(NULL);
  //---------------------------------------------------------
  // allocate context, clear it
  //---------------------------------------------------------
  pMontCtx = (MONT_CONTEXT*)
             ((void *) BIT8_ARRAY_CALLOC(HMEM_CTX_REF,1,
					 sizeof(MONT_CONTEXT)));
  if(pMontCtx == NULL)
    return(NULL);
  //---------------------------------------------------------
  // get size s for r, r > n, r = 2**(s*w), w = 32
  // allocate large number buffers for n, r**2 and tmp
  //---------------------------------------------------------
  sLen = pModN->UsedSize;			// elements to use

  for(;;)		// error FOR
  {
    pMontCtx->pModN        = AllocNewWLnum(HMEM_CTX_REF1 sLen);
    pMontCtx->pRSquare     = AllocNewWLnum(HMEM_CTX_REF1 (2*sLen+1));
    pMontCtx->pTmpLnum     = AllocNewWLnum(HMEM_CTX_REF1 (2*sLen+1));
    pMontCtx->pTmpMontLnum = AllocNewWLnum(HMEM_CTX_REF1 (2*sLen+1));

    if((pMontCtx->pModN == NULL) ||
       (pMontCtx->pRSquare == NULL) ||
       (pMontCtx->pTmpLnum == NULL) ||
       (pMontCtx->pTmpMontLnum == NULL))
      break;
    //---------------------------------------------------------
    // copy modulus to context
    //---------------------------------------------------------
    memcpy(pMontCtx->pModN->lpEl+0,pModN->lpEl+0,(sLen)*4);
    pMontCtx->pModN->UsedSize = sLen;
    //---------------------------------------------------------
    // Generate RSquare = r**2 (mod n)
    //---------------------------------------------------------
    lpEl = pMontCtx->pTmpLnum->lpEl;	// get buffer pointer
    ClearBit32Array(lpEl,0,sLen*2);
    lpEl[2*sLen] = 1;				// set r = 2**(2*s*w)
    pMontCtx->pTmpLnum->UsedSize = 2*sLen + 1; 

    if(ModWLnum(HMEM_CTX_REF1 pMontCtx->pRSquare,
		     pMontCtx->pTmpLnum, pModN, NULL) != LNUM_OP_OK)
      break;
    //--------------------------------------------------------
    // Generate Ni0 from n(x)[0], save s
    //--------------------------------------------------------
    pMontCtx->Ni0  = WLnumMontInvN0(pModN->lpEl[0]);
    pMontCtx->sLen = sLen;
    return(pMontCtx);
  } // error FOR
  FreeWLnumMontCtx(HMEM_CTX_REF1 pMontCtx);
  return(NULL);
}
/**
* Converts montgomery representation a~ to normal WLarge number c (MontToWLnum).
*
* NOTE:
* <ol>
* <li> Destination c may be same as source a.
* <li> a must be reduced (mod n) aka. a < n.
* <li> To avoid reallocation of number elements, size of
*	    destination SHOULD be >= 2 * Size(Modulus n) !!
*</ol>
*  @param pWLnumC Converted large number c
*  @param pWLnumA Montgomery number a~
*  @param pMontCtx Montgomery context
*  @return 0 on success, error code otherwise
*/
extern "C" int MontToWLnum(HMEM_CTX_DEF WLARGENUM* pWLnumC,
		WLARGENUM* pWLnumA, MONT_CONTEXT* pMontCtx)
{
  int Retcode,sLen,NumSize;
  int ALen;
  int* pC;
  int* pA;
  WLARGENUM* pTmpLnum = NULL;
  //--------------------------------------------------------
  // Check parameters, remove later
  //--------------------------------------------------------
  if((pWLnumA == NULL) || (pWLnumC == NULL) || (pMontCtx == NULL))
    return(LNUM_OP_NULL_PTR);
  //--------------------------------------------------------
  // Avoid multiply by 0 !!
  //--------------------------------------------------------
  if(pWLnumA->UsedSize == 0)
  {
    pWLnumC->UsedSize = 0;
    return(LNUM_OP_OK);
  }
  //----------------------------------------------------------------
  // get number pointers and sizes for processing
  //----------------------------------------------------------------
  sLen = pMontCtx->sLen;
  pA   = pWLnumA->lpEl;
  ALen = pWLnumA->UsedSize;
  if(ALen > (2*sLen))				// sanity check !
    return(LNUM_OP_PARAM_ERR);

  if(pWLnumC != pWLnumA)			// dst c(x) <> src a(x)
    pTmpLnum = pWLnumC;
  else						// dst c(x) == src a(x)
    pTmpLnum = pMontCtx->pTmpLnum;
  //------------------------------------------------------------
  // Assure that CLen >= 2*sLen+1
  //------------------------------------------------------------
  if(pTmpLnum->AllocSize <= (2*sLen+1))
  {
    if((Retcode = AllocWLnumElements(HMEM_CTX_REF1
				     pTmpLnum, (2*sLen+1))) != LNUM_OP_OK)
      return(Retcode);
  }
  pC   = pTmpLnum->lpEl;
  //--------------------------------------------------------
  // Generate Montgomery product and used size:
  // 1. copies number to destination at startup (T <= A)
  // 2. clears unused elements
  // 3. multiplicates and adds up result(s)
  // 4. shifts result right s Elemets (divide by 2**(s*w))
  //--------------------------------------------------------
  NumSize = HardMulAddMontBit64(ALen, pA, sLen, pC,
		      pMontCtx->pModN->lpEl,
		      pMontCtx->Ni0);
  //--------------------------------------------------------
  // shift right result by s elements (divide by 2**(w*s))
  //--------------------------------------------------------
//  HardRshiftBit32WLnum(sLen, pC, NumSize);
//  WLNUM_UsedSize(pTmpLnum) = NumSize - sLen;
  pTmpLnum->UsedSize = NumSize;
  //--------------------------------------------------------
  // Check if c >= n
  // NOTE: c will always be < 2*n (per definitionem of Algorithmus)
  //--------------------------------------------------------
  if(UcompWLnum(pTmpLnum,pMontCtx->pModN) != WLNUM_1ST_LT_2ND)
  {
    Retcode = SubWLnum(HMEM_CTX_REF1 pTmpLnum, pTmpLnum,
		       pMontCtx->pModN);
    if(Retcode != LNUM_OP_OK)
      return(Retcode);
  }
  //--------------------------------------------------------
  // Copy Result to destination if required
  //--------------------------------------------------------
  if(pWLnumC == pTmpLnum)		// no copy needed   
    return(LNUM_OP_OK);

  Retcode = CopyWLnum(HMEM_CTX_REF1 pWLnumC, pTmpLnum);
  return(Retcode);
}

/**
* Performs montgomery modulo multiplication (MontMulModWLnum).
* Implements the word level algorithm.
* NOTE:
* <ol>
* <li> Destination c may be same as sources a,b.
* <li> Multiplicands must be reduced to modulus n.
* </ol>
*  @param pWLnumC Result large number
*  @param pWLnumA Multiplicand 1
*  @param pWLnumB Multiplicand 2
*  @param pMontCtx Montgomery context
*  @return 0 on success, error code otherwise
*/
extern "C" int MontMulModWLnum(HMEM_CTX_DEF WLARGENUM* pWLnumC,
	WLARGENUM* pWLnumA, WLARGENUM* pWLnumB, MONT_CONTEXT* pMontCtx)
{
  int Retcode,sLen;
  WLARGENUM* pTmpLnum;
  //--------------------------------------------------------
  // Check parameters, remove later
  //--------------------------------------------------------
  if((pWLnumA == NULL) || (pWLnumB == NULL) ||
     (pWLnumC == NULL) || (pMontCtx == NULL))
    return(LNUM_OP_NULL_PTR);
  //----------------------------------------------------------------
  // get temporary number for processing
  //----------------------------------------------------------------
  sLen     = pMontCtx->sLen;
  pTmpLnum = pMontCtx->pTmpMontLnum;
  //----------------------------------------------------------------
  // 1. Precalculate c = a~ * b~
  //----------------------------------------------------------------
  if(pWLnumA == pWLnumB)		// use squaring (faster)
  {
    Retcode = SquareWLnum(HMEM_CTX_REF1 pTmpLnum, pWLnumA);
  }
  else					// use standard multiplication
  {
    Retcode = MulWLnum(HMEM_CTX_REF1 pTmpLnum, pWLnumA, pWLnumB);
  }
  if(Retcode != LNUM_OP_OK)
    return(Retcode);
  //----------------------------------------------------------------
  // 2. convert c = a~ * b~ to c~ = a~ * b~ * r**(-1) (mod n)
  //----------------------------------------------------------------
  Retcode = MontToWLnum(HMEM_CTX_REF1 pWLnumC, pTmpLnum, pMontCtx);
  return(Retcode);
}

/**
* Generates montgomery representation a~ of number '1',
* using simplified MontMulMod with b(x) = 1 (MontOneWLnum).
*
*  @param pWLnumC Result large number
*  @param pMontCtx Montgomery context
*  @return 0 on success, error code otherwise
*/
extern "C" int MontOneWLnum(HMEM_CTX_DEF WLARGENUM* pWLnumC,
			MONT_CONTEXT* pMontCtx)
{
  int Retcode;

  //-----------------------------------------------------------
  // We use backward conversion a = a~ * r**(-1) (mod n) for
  // the number RSquare (mod n).
  // This yields: a = r**2 * r**(-1) (mod n) = r (mod n)
  // montgomery representation of 1 is: 1~ = 1 * r (mod n)
  //-----------------------------------------------------------
  Retcode = MontToWLnum(HMEM_CTX_REF1 pWLnumC, pMontCtx->pRSquare,
			pMontCtx);
  return(Retcode);
}
/**
* Converts a normal large number a to montgomery representation a~,
* using standard montgomery multplication (WLnumToMont).
* Destination a may be same as source a.
*
*  @param pWLnumC Result momtgomery number a~
*  @param pWLnumA Standard large number a
*  @param pMontCtx Montgomery context
*  @return 0 on success, error code otherwise
*/
extern "C" int WLnumToMont(HMEM_CTX_DEF WLARGENUM* pWLnumC,
	WLARGENUM* pWLnumA, MONT_CONTEXT* pMontCtx)
{
  int Retcode;
  //--------------------------------------------------------
  // Check parameters, remove later
  //--------------------------------------------------------
  if((pWLnumA == NULL) || (pWLnumC == NULL) || (pMontCtx == NULL))
    return(LNUM_OP_NULL_PTR);
  //----------------------------------------------------------------
  // calculate: c = MontMulMod(a,r**2 (mod n))
  //----------------------------------------------------------------
  Retcode = MontMulModWLnum(HMEM_CTX_REF1 pWLnumC, pWLnumA,
		pMontCtx->pRSquare, pMontCtx);
  return(Retcode);
}

static unsigned int ms_get_window_val(size_t* aszp_cur_shift,
                                      unsigned int* aunp_exponent,
                                      unsigned int* aunp_exp_index,
                                      unsigned int unp_window_bits,
                                      unsigned int unp_mask)
{
    unsigned int unl_window_val;
    if(*aszp_cur_shift < unp_window_bits){
        // Window goes into next word of the exponent
        size_t szl_l_shift = unp_window_bits-*aszp_cur_shift;
        unl_window_val = aunp_exponent[*aunp_exp_index] << szl_l_shift;
        *aunp_exp_index-=1;
        *aszp_cur_shift = (sizeof(unsigned int)*8)-szl_l_shift;
        unl_window_val |= aunp_exponent[*aunp_exp_index] >> *aszp_cur_shift;
    } else {
        *aszp_cur_shift -= unp_window_bits;
        unl_window_val = aunp_exponent[*aunp_exp_index] >> *aszp_cur_shift;
    }
    unl_window_val &= unp_mask;
    return unl_window_val;
}

/**
* Calculates (u ** v) mod m using montgomery
* multiplication and a precomputed table of montgomery powers
* to reduce amount of caclulations needed (ExpModMontWLnum).
* The size of the table depends on the size of the value v.
* The contents will be (u~) mod m, (u~**3) mod m, (u~**5) mod m
* and so on.
* The power p is scanned from top to bottom using a window of
* size 1 to 6 bits, depending on the magnitude of v.
*
* Destination and source must be different.
* 4 CTX Elements required + max. 32 for Table.
* Modulus must be > 0 AND odd.
*
*  @param pRem Pointer to destination
*  @param pU Pointer to number u
*  @param pV Pointer to power v
*  @param pMod Pointer to modulus m
*  @param pCtx Work context. Optional
*  @param callback Callback pointer. Optional
*  @return 0 on success, error code otherwise
*/
static int ExpModMontWLnum(HMEM_CTX_DEF
                           WLARGENUM* adsp_dest,
                           WLARGENUM* adsp_base,
                           WLARGENUM* adsp_exp,
                           WLARGENUM* adsp_mod,
                           WLNUM_CONTEXT* adsp_num_ctx,
                           void (*callback)(int))
{
    if(IsZeroWLnum(adsp_mod) != 0){
        return LNUM_OP_ZERO_DIV;
    }

    if((adsp_mod->lpEl[0] & 0x01) == 0){
        return LNUM_OP_INVALID_MONT_MODULUS;
    }

    // assure size of remainder >= inl_max_size
    int inl_max_size = (adsp_mod->UsedSize * 2) + 1;

    int inl_ret;
    if(adsp_dest->AllocSize < inl_max_size) {
        inl_ret = AllocWLnumElements(HMEM_CTX_REF1 adsp_dest,inl_max_size);
        if(inl_ret != LNUM_OP_OK){
            return inl_ret;
        }
    }
    adsp_dest->UsedSize = 0;

    // Check special conditions for u**v (mod n)

    if(IsZeroWLnum(adsp_exp) != 0) {
        adsp_dest->lpEl[0]  = 1;
        adsp_dest->UsedSize = 1;
        return LNUM_OP_OK;
    }
    if(IsZeroWLnum(adsp_base) != 0){
        return LNUM_OP_OK;
    }

    // allocate/initialize montgomery context, check modulus n
    MONT_CONTEXT* adsl_mont_ctx = AllocWLnumMontCtx(HMEM_CTX_REF1 adsp_mod);
    if(adsl_mont_ctx == NULL){
        return LNUM_OP_ALLOC_ERR;
    }

    int inl_bit_size = GetBitCntWLnum(adsp_exp);
    //----------------------------------------------------------
    // Get window size to use
    // Changed according to Algorithm 1.2.2.4 from H. Cohen:
    // lg N <= (k * (k+1) * 2^(2k))/(2^(k+1) -k - 2)
    // k = 1 for bits <= 8
    // k = 2 for bits <= 24
    // k = 3 for bits <= 69
    // k = 4 for bits <= 196
    // k = 5 for bits <= 538
    // k = 6 for bits > 538
    //----------------------------------------------------------
    int unl_window_bits;
    if(inl_bit_size <= 8){
        unl_window_bits = 1;
    } else if(inl_bit_size <= 24){
        unl_window_bits = 2;
    } else if(inl_bit_size <= 69){
        unl_window_bits = 3;
    } else if(inl_bit_size <= 196){
        unl_window_bits = 4;
    } else  if(inl_bit_size <= 538) {
        unl_window_bits = 5;
    } else {
        unl_window_bits = 6;
    } 

    // Allocate context / check given context
    int inl_temp_cnt = (1<<unl_window_bits);
    WLNUM_CONTEXT* adsl_num_ctx = adsp_num_ctx;
    if(adsl_num_ctx == NULL) {
        adsl_num_ctx = AllocWLnumContext(HMEM_CTX_REF1 inl_temp_cnt, inl_max_size);
        if( adsl_num_ctx == NULL){
            FreeWLnumMontCtx(HMEM_CTX_REF1 adsl_mont_ctx);
            return LNUM_OP_ALLOC_ERR ;
        }
    } else {
        if((adsl_num_ctx->NextFreeIndex + inl_temp_cnt) >= adsl_num_ctx->AllocedNumCnt) {
            FreeWLnumMontCtx(HMEM_CTX_REF1 adsl_mont_ctx);
            return LNUM_OP_CTX_FULL;
        }
    }

    // Prepare the actual processing loop
    // Done here to be beofre any error gotos

    size_t szl_exp_bits = (size_t)GetBitCntWLnum(adsp_exp);
    size_t szl_cur_shift = szl_exp_bits % (sizeof(int)*8);

    if(szl_cur_shift == 0){
        szl_cur_shift = (sizeof(int)*8);
    }

    unsigned int unl_mask = (1<<unl_window_bits) -1;
    unsigned int* aunl_exponent = (unsigned int*)adsp_exp->lpEl;
    unsigned unl_exp_index = adsp_exp->UsedSize-1;
    unsigned int unl_window_val;

    int inl_last_utc;
    int inl_this_utc;

    // Generate the pre-calculation table
    // Fetch all needed temps

    int inl_mod_elements = adsp_mod->UsedSize;
    WLARGENUM* adsrl_precalc[1<<6];
    memset(adsrl_precalc, 0, sizeof(adsrl_precalc));

    unsigned unl_precomp_count = (1<<unl_window_bits);
    inl_ret = LNUM_OP_ALLOC_ERR;
    int inl_temp_used = 0;

    for(unsigned unl_index = 0; unl_index < unl_precomp_count; unl_index++) {
        adsrl_precalc[unl_index] = GetWLnumPtrFromContext(HMEM_CTX_REF1 adsl_num_ctx, inl_mod_elements);
        if(adsrl_precalc[unl_index] == NULL) {
            goto mont_exp_end;
        }
        inl_temp_used++;
    }

    // Montgomerize 1 and the base at index 0 and 1
    inl_ret = MontOneWLnum(HMEM_CTX_REF1 adsrl_precalc[0], adsl_mont_ctx);
    if(inl_ret != LNUM_OP_OK){
        goto mont_exp_end;
    }
    inl_ret = WLnumToMont(HMEM_CTX_REF1 adsrl_precalc[1], adsp_base, adsl_mont_ctx);
    if(inl_ret != LNUM_OP_OK){
        goto mont_exp_end;
    }

    // Set dest to 1 in Montgomery form
    CopyWLnum(HMEM_CTX_REF1 adsp_dest, adsrl_precalc[0]);

    // Calculate the remaining precomputation table using Montgomery multiplication
    for(unsigned unl_index = 2; unl_index < unl_precomp_count; unl_index++) {
        inl_ret = MontMulModWLnum(HMEM_CTX_REF1
                                  adsrl_precalc[unl_index],
                                  adsrl_precalc[unl_index-1],
                                  adsrl_precalc[1],
                                  adsl_mont_ctx);
        if(inl_ret != LNUM_OP_OK){
            goto mont_exp_end;
        }
    }


    // Do callback, if available
    if(callback != NULL) {
        if(unl_window_bits < 128) {
            callback = (void(*)(int)) NULL;
        } else {
            inl_last_utc = SecGetSystemTimeUTC();
        }
    }
    // Perform the Square and multiplies for all full windows
    while(szl_exp_bits > unl_window_bits) {
        
        for(unsigned unl_count = unl_window_bits; unl_count > 0; unl_count--){
            inl_ret= MontMulModWLnum(HMEM_CTX_REF1
                                     adsp_dest,
                                     adsp_dest,
                                     adsp_dest,
                                     adsl_mont_ctx);
            if(inl_ret != LNUM_OP_OK){
                goto mont_exp_end;
            }
        }

        unl_window_val = ms_get_window_val(&szl_cur_shift, aunl_exponent, &unl_exp_index, unl_window_bits, unl_mask);
        // Multiply with pre-calculation
        inl_ret= MontMulModWLnum(HMEM_CTX_REF1
                                 adsp_dest,
                                 adsrl_precalc[unl_window_val],
                                 adsp_dest,
                                 adsl_mont_ctx);
        if(inl_ret != LNUM_OP_OK){
            goto mont_exp_end;
        }

        // get the next window
        szl_exp_bits -= unl_window_bits;

        if(callback != NULL) {
            inl_this_utc = SecGetSystemTimeUTC();
            if(inl_this_utc != inl_last_utc) {
                inl_last_utc = inl_this_utc;
                callback(1);
            }
        }
    }

    unl_window_val = aunl_exponent[0] & ((1<<szl_exp_bits)-1);

    // Final loop may be smaller, than window size!
    while(szl_exp_bits > 0) {
        inl_ret= MontMulModWLnum(HMEM_CTX_REF1
                                 adsp_dest,
                                 adsp_dest,
                                 adsp_dest,
                                 adsl_mont_ctx);
        if(inl_ret != LNUM_OP_OK){
            goto mont_exp_end;
        }
        szl_exp_bits--;
    }

    // Multiply with the final window
    inl_ret= MontMulModWLnum(HMEM_CTX_REF1
                             adsp_dest,
                             adsrl_precalc[unl_window_val],
                             adsp_dest,
                             adsl_mont_ctx);

    if(inl_ret != LNUM_OP_OK){
        goto mont_exp_end;
    }

    inl_ret = MontToWLnum(HMEM_CTX_REF1
                          adsp_dest,
                          adsp_dest,
                          adsl_mont_ctx);
mont_exp_end:
    FreeWLnumMontCtx(HMEM_CTX_REF1 adsl_mont_ctx);
    if(adsp_num_ctx != NULL){
        ReleaseWLnumsFromContext(adsp_num_ctx, inl_temp_used);
    } else {
        FreeWLnumContext(HMEM_CTX_REF1 adsl_num_ctx);
    }

    return inl_ret;
}

extern "C" int ExpModWLnum(HMEM_CTX_DEF
				   WLARGENUM* pRem, WLARGENUM* pU, WLARGENUM* pV,
				   WLARGENUM* pMod, WLNUM_CONTEXT* pCtx,
				  void callback(int))
{
  int Retcode;
  //---------------------------------------------------------
  // check for modulus 0 first
  //---------------------------------------------------------
  if(IsZeroWLnum(pMod) != 0)			// m == 0
    return LNUM_OP_ZERO_DIV;			// Divide by zero err.
  //-------------------------------------------------------
  // Check for special mode u ** v=0 mod n, always yields 1 
  //-------------------------------------------------------
  if(IsZeroWLnum(pV) != 0)			// power V is 0
  {
    if(pRem->AllocSize < 1)		// too few elements
    {
      if((Retcode = AllocWLnumElements(HMEM_CTX_REF1
			pRem,1)) != LNUM_OP_OK)
        return(Retcode);
    }
    pRem->UsedSize = 1;
    pRem->lpEl[0] = 1;
    return(LNUM_OP_OK);
  }
  //-------------------------------------------------------
  // Check for special mode u=0 ** x mod n, always yields 0 
  //-------------------------------------------------------
  if(IsZeroWLnum(pU) != 0)			// base U is 0
  {
    pRem->UsedSize = 0;
    return(LNUM_OP_OK);
  }

  //---------------------------------------------------------
  // check which type of modulus given, Even/Odd
  //---------------------------------------------------------
  if((pMod->lpEl[0] & 0x01) == 0)		// modulus is EVEN-> Slow
  {
    return(ExpModStdWLnum(HMEM_CTX_REF1
		pRem, pU, pV, pMod, pCtx, callback));
  }
  else
  {
    return(ExpModMontWLnum(HMEM_CTX_REF1
		pRem, pU, pV, pMod, pCtx, callback));
  }
}

extern "C" int m_exp_mod_blind(HMEM_CTX_DEF
				   WLARGENUM* pRem, WLARGENUM* pU, WLARGENUM* pV,
				   WLARGENUM* pMod, WLNUM_CONTEXT* pCtx,
               int inp_flags,
				  void (*callback)(int))
{
   return m_exp_mod_blind_impl(HMEM_CTX_REF1 pRem, pU, pV, pMod, pCtx, inp_flags, callback, HMEM_USR_FLD, m_rand_wrapper);
}

extern "C" int m_exp_mod_blind_impl(HMEM_CTX_DEF
				   WLARGENUM* pRem, WLARGENUM* pU, WLARGENUM* pV,
				   WLARGENUM* pMod, WLNUM_CONTEXT* pCtx,
               int inp_flags,
				  void (*callback)(int),
             void* vpp_user_field, amd_get_random amp_get_rand)
{
  int Retcode;
  WLARGENUM* adsl_used_base = NULL;
  WLARGENUM* adsl_used_mod = NULL;
  WLARGENUM* adsl_used_exp = NULL;
  WLARGENUM* adsl_used_r_exp = NULL;
  WLARGENUM* adsl_tmp_res = NULL;
  WLARGENUM* adsl_tmp_wlnum = AllocNewWLnum(HMEM_CTX_REF1 2);
#if defined NO_RSA_BLINDING
// only allow deactivating RSA blinding during tests
#if !defined(_DEBUG) && !defined(DEBUG)
#error "Deactivated RSA blinding in release code."
#else
  inp_flags = 0;      // Skip blinding
#endif
#endif

  //---------------------------------------------------------
  // check for modulus 0 first
  //---------------------------------------------------------
  if(IsZeroWLnum(pMod) != 0)			// m == 0
    return LNUM_OP_ZERO_DIV;			// Divide by zero err.
  //-------------------------------------------------------
  // Check for special mode u ** (v=0) mod n, always yields 1 
  //-------------------------------------------------------
  if(IsZeroWLnum(pV) != 0)			// power V is 0
  {
    if(pRem->AllocSize < 1)		// too few elements
    {
      if((Retcode = AllocWLnumElements(HMEM_CTX_REF1
			pRem,1)) != LNUM_OP_OK)
        return(Retcode);
    }
    pRem->UsedSize = 1;
    pRem->lpEl[0] = 1;
    return(LNUM_OP_OK);
  }
  //-------------------------------------------------------
  // Check for special mode (u=0) ** x mod n, always yields 0 
  //-------------------------------------------------------
  if(IsZeroWLnum(pU) != 0)			// base U is 0
  {
    pRem->UsedSize = 0;
    return(LNUM_OP_OK);
  }
  //-------------------------------------------------------
  // Blind as requested
  //-------------------------------------------------------
  for(;;){// for error handling
     if((inp_flags & WLNUM_USE_BASE_BLINDING) != 0){ // Additive base blinding
           adsl_used_base = AllocNewWLnum(HMEM_CTX_REF1 pMod->UsedSize+3);
           Retcode = WLnumRand_impl(HMEM_CTX_REF1 adsl_tmp_wlnum,64,0,0,
              vpp_user_field,amp_get_rand);
           if(Retcode != LNUM_OP_OK) break;
           Retcode = MulWLnum(HMEM_CTX_REF1 adsl_used_base, adsl_tmp_wlnum, pMod);
           if(Retcode != LNUM_OP_OK) break;
           Retcode = AddWLnum(HMEM_CTX_REF1 adsl_used_base, adsl_used_base, pU); 
     } else {
        adsl_used_base = pU;
     }
     if((inp_flags & (WLNUM_USE_MOD_BLINDING|WLNUM_USE_BASE_BLINDING)) != 0){ //modulus blinding required
        adsl_used_mod = AllocNewWLnum(HMEM_CTX_REF1 pMod->UsedSize+2);
        Retcode = WLnumRand_impl(HMEM_CTX_REF1 adsl_tmp_wlnum,64,0,1,
           vpp_user_field,amp_get_rand); //blinding factor for Mod odd, to keep modulus odd
        if(Retcode != LNUM_OP_OK) break;
        Retcode = MulWLnum(HMEM_CTX_REF1 adsl_used_mod, adsl_tmp_wlnum, pMod);
        if(Retcode != LNUM_OP_OK) break;
        adsl_tmp_res = AllocNewWLnum(HMEM_CTX_REF1 adsl_used_mod->UsedSize);
     } else {
        adsl_used_mod = pMod;
        adsl_tmp_res = pRem;
     }

     if((inp_flags & WLNUM_USE_EXP_BLINDING) != 0){ // Exponent blinding
        adsl_used_r_exp = AllocNewWLnum(HMEM_CTX_REF1 pV->UsedSize/2+1);
        Retcode = WLnumRand_impl(HMEM_CTX_REF1 adsl_used_r_exp,GetBitCntWLnum(pV)/2,0,0,
           vpp_user_field,amp_get_rand);
        if(Retcode != LNUM_OP_OK) break;
        adsl_used_exp = AllocNewWLnum(HMEM_CTX_REF1 adsl_used_mod->UsedSize);
        SubWLnum(HMEM_CTX_REF1 adsl_used_exp, pV, adsl_used_r_exp);
        if(Retcode != LNUM_OP_OK) break;
     } else {
        adsl_used_exp = pV;
     }
  //---------------------------------------------------------
  // Perform the blinded exp mod
  //---------------------------------------------------------
     Retcode = (ExpModWLnum(HMEM_CTX_REF1
        adsl_tmp_res, adsl_used_base, adsl_used_exp, adsl_used_mod, pCtx, callback));
     if(Retcode != LNUM_OP_OK) break;
     if(adsl_used_r_exp != NULL){ // exponent splitting was used
        Retcode = (ExpModWLnum(HMEM_CTX_REF1
           adsl_used_exp, adsl_used_base, adsl_used_r_exp, adsl_used_mod, pCtx, callback));
        if(Retcode != LNUM_OP_OK) break;
        // Multiply split results
        Retcode = MulModWLnum(HMEM_CTX_REF1 adsl_tmp_res, adsl_tmp_res, adsl_used_exp, adsl_used_mod, pCtx);
        if(Retcode != LNUM_OP_OK) break;
     }
     if((inp_flags & (WLNUM_USE_MOD_BLINDING|WLNUM_USE_BASE_BLINDING)) != 0){ // remove modulus blinding
        Retcode = ModWLnum(HMEM_CTX_REF1 pRem, adsl_tmp_res, pMod, pCtx);
     }
     break;
  }// Error for
  //---------------------------------------------------------
  // cleanup temporaries
  //---------------------------------------------------------
  if((inp_flags & (WLNUM_USE_BASE_BLINDING)) != 0){
     ClearFreeWLnum(HMEM_CTX_REF1 adsl_used_base);
  }
  if((inp_flags & (WLNUM_USE_MOD_BLINDING|WLNUM_USE_BASE_BLINDING)) != 0){
     ClearFreeWLnum(HMEM_CTX_REF1 adsl_used_mod);
     ClearFreeWLnum(HMEM_CTX_REF1 adsl_tmp_res);
  }
  if((inp_flags & WLNUM_USE_EXP_BLINDING) != 0){
     ClearFreeWLnum(HMEM_CTX_REF1 adsl_used_exp);
     ClearFreeWLnum(HMEM_CTX_REF1 adsl_used_r_exp);
  }
  ClearFreeWLnum(HMEM_CTX_REF1 adsl_tmp_wlnum);

  return Retcode;
}

extern "C" int m_lcm_wlnum(HMEM_CTX_DEF
                                   WLARGENUM* adsp_u, WLARGENUM* adsp_v,
                                   WLARGENUM* adsp_result)
{
   WLARGENUM* adsl_gcd = NULL;
   WLARGENUM* adsl_div_result = NULL;
   int inl_u_bytesize = GetByteCntWLnum(adsp_u);
   int inl_retcode = LNUM_OP_OK;
   adsl_gcd = AllocNewWLnum(HMEM_CTX_REF1 inl_u_bytesize);
   for(;;){ //simpler error handling
      inl_retcode = GcdWLnum(HMEM_CTX_REF1 adsl_gcd,adsp_u,adsp_v);
      if(inl_retcode != LNUM_OP_OK)
      {
         break;
      }
      adsl_div_result = AllocNewWLnum(HMEM_CTX_REF1 inl_u_bytesize);
      inl_retcode = DivWLnum(HMEM_CTX_REF1 adsl_div_result,NULL,adsp_u,adsl_gcd,NULL); // div_res = u/GCD(u,v)
      if(inl_retcode != LNUM_OP_OK)
      {
         break;
      }
      inl_retcode = MulWLnum(HMEM_CTX_REF1 adsp_result,adsl_div_result,adsp_v); // LCM(u,v) = div_res * v
      break;
   }
   FreeWLnum(HMEM_CTX_REF1 adsl_gcd);
   FreeWLnum(HMEM_CTX_REF1 adsl_div_result);
   return inl_retcode;  
}
/** @} */


#endif //HL_ENCR_LNUM
// end of file ../lnum32/Lnum32.cpp


#ifdef HL_ENCR_PBKDF2
// PBKDF2 implementation
#include <string.h>
#if (defined _WIN32) & (_MSC_VER < 1700)
#ifndef _STDINT
#define _STDINT
// MSVC lower than 17.00 does not have stdint.h, assure, all needed types are defined

typedef unsigned __int16 uint16_t;

typedef unsigned __int32 uint32_t;

typedef unsigned __int64 uint64_t;

#endif // !_STDINT
#else
#include <stdint.h>
#endif
#include <stddef.h>
#ifdef _WIN32
#define WIN32_LEAN_AND_MEAN
#include <Windows.h>
#undef WIN32_LEAN_AND_MEAN
#else// Define system-specific HL_* defines here
#ifndef HL_UNIX
#define HL_UNIX

#if (defined __gnu_linux__) || (defined __linux__)
#define HL_LINUX
#endif

#if (defined __APPLE__) && (defined __MACH__)
#define HL_LINUX
#define HL_MACOS
#endif

#ifdef _AIX
#define HL_AIX
#define HL_BIG_ENDIAN
#endif

#ifdef __FreeBSD__
#define HL_FREEBSD
#endif

#if (defined _hpux) || (defined hpux) || (defined __hpux)
#define HL_HPUX
#define HL_BIG_ENDIAN
#endif

#if (defined sun) || (defined __sun)
#define HL_SOLARIS
#endif

#if (defined __arm__) || (defined __aarch64__)
#define HL_LINUX_ARM
#endif

#ifdef __ANDROID__
#define HL_ANDROID
#endif

#endif
#include <hob-unix01.h>
#endif
#ifdef __APPLE__
/* We get target conditionals to keep apart Mac OS, iOS and iOS simulator.
   The conditionals are TARGET_IPHONE_SIMULATOR, TARGET_OS_IPHONE and TARGET_OS_MAC.
   TARGET_IPHONE_SIMULATOR has the highest priority, TARGET_OS_MAC the lowest.
   Always test, if the conditional is 1, as they will be defined as 0, if we 
   are not compiling for the target.
   */
#include <TargetConditionals.h>
#endif

#include "hob-encry-1.h"

inline int m_get_mac_len(int inp_hmac_id){
   switch(inp_hmac_id){
   case HMAC_MD5_ID:           //!< Use MD5 for HMAC
      return 16;
   case HMAC_SHA1_ID:        //!< Use SHA1 for HMAC
   case HMAC_RMD160_ID:        //!< Use RIPEMD160 for HMAC
      return 20;
   case HMAC_SHA256_ID:       //!< Use SHA256 for HMAC
      return 32;
   case HMAC_SHA384_ID:        //!< Use SHA384 for HMAC
      return 48;
   case HMAC_SHA512_ID:
      return 64;
   default:
      return -1;
   }
}

inline void m_inc_cnt(unsigned char* aucp_cnt){
   if(0 != (++(aucp_cnt[3]))){
      return;
   }
   if(0 != (++(aucp_cnt[2]))){
      return;
   }
   if(0 != (++(aucp_cnt[1]))){
      return;
   }
   ++(aucp_cnt[0]);
}

inline int m_calc_f_funct( const char* achp_password, 
                     size_t szp_pw_len, 
                     const char* achp_salt, 
                     size_t szp_salt_len,
                     const unsigned char* aucp_counter,
                     unsigned int unp_iterations,
                     unsigned char* aucp_dest,
                     int inp_hash_type)
{
   struct dsd_gather_i_1 dsrl_salt_and_cnt[2];
   char chrl_u_buf[64];
   int inl_dest_len = m_get_mac_len(inp_hash_type);
   int inl_ret = 0;

   dsrl_salt_and_cnt[0].adsc_next = dsrl_salt_and_cnt+1;
   dsrl_salt_and_cnt[0].achc_ginp_cur = const_cast<char*>(achp_salt);
   dsrl_salt_and_cnt[0].achc_ginp_end = dsrl_salt_and_cnt[0].achc_ginp_cur+szp_salt_len;
   
   dsrl_salt_and_cnt[1].adsc_next = NULL;
   dsrl_salt_and_cnt[1].achc_ginp_cur = (char*)(const_cast<unsigned char*>(aucp_counter));
   dsrl_salt_and_cnt[1].achc_ginp_end = dsrl_salt_and_cnt[1].achc_ginp_cur+4;

   inl_ret = GenHMACGath(achp_password, 0, (int)szp_pw_len, dsrl_salt_and_cnt, inp_hash_type, 
      chrl_u_buf, 0,&inl_dest_len);
   if( 0 != inl_ret ){
      return inl_ret;
   }

   memcpy(aucp_dest, chrl_u_buf, inl_dest_len);

   unp_iterations--;

   while( 0 != unp_iterations){
      inl_ret = GenHMAC(achp_password, 0, (int)szp_pw_len, chrl_u_buf,0,inl_dest_len, inp_hash_type, 
         chrl_u_buf, 0,&inl_dest_len);
      if( 0 != inl_ret ){
         return inl_ret;
      }
      for(int inl_index = 0; inl_dest_len > inl_index; inl_index++){
         aucp_dest[inl_index] ^= chrl_u_buf[inl_index];
      }
      unp_iterations--;
   }

   memset(chrl_u_buf,0,64);
   return 0;
}

extern "C" int m_pbkdf2_hmac(const char* achp_password, 
                  size_t szp_pw_len, 
                  const char* achp_salt, 
                  size_t szp_salt_len,
                  unsigned int unp_iterations, 
                  unsigned char* aucp_dest,
                  size_t szp_dest_len,
                  int inp_hash_type)
{
   unsigned char ucrl_t_buf[64];
   unsigned char ucrl_cnt[4];
   int inl_mac_len = m_get_mac_len(inp_hash_type);

   // input validation
   if( NULL == achp_password || NULL == achp_salt || NULL == aucp_dest 
      || 0 == unp_iterations || 0xffffffff < szp_dest_len || 0 >= inl_mac_len)
   {
      return -1;
   }

   memset(ucrl_cnt, 0, 4);

   while( static_cast<unsigned int>(inl_mac_len) <= szp_dest_len )
   {
      m_inc_cnt(ucrl_cnt);
      m_calc_f_funct(achp_password, szp_pw_len, achp_salt, szp_salt_len, ucrl_cnt, 
         unp_iterations, aucp_dest, inp_hash_type);
      aucp_dest += inl_mac_len;
      szp_dest_len -= inl_mac_len;
   }

   if( 0 != szp_dest_len){
      m_inc_cnt(ucrl_cnt);
      m_calc_f_funct(achp_password, szp_pw_len, achp_salt, szp_salt_len, ucrl_cnt, 
         unp_iterations, ucrl_t_buf, inp_hash_type);
      memcpy(aucp_dest, ucrl_t_buf, szp_dest_len);
   }

   return 0;
}


extern "C" int m_pbkdf2(const dsd_pbkdf2_params* adsp_params,
                        unsigned char* abyp_output,
                        size_t szp_output_len)
{
    return m_pbkdf2_hmac(adsp_params->achc_password, 
                         adsp_params->szc_password_len,
                         adsp_params->achc_salt,
                         adsp_params->szc_salt_len,
                         adsp_params->umc_iterations,
                         abyp_output,
                         szp_output_len,
                         adsp_params->iec_hmac_id);
}

#endif //HL_ENCR_PBKDF2
// end of file ../pbkdf2/pbkdf2_hmac.cpp


#ifdef HL_ENCR_RSA

#if (defined _WIN32) & (_MSC_VER < 1700)
#ifndef _STDINT
#define _STDINT
// MSVC lower than 17.00 does not have stdint.h, assure, all needed types are defined

typedef unsigned __int16 uint16_t;

typedef unsigned __int32 uint32_t;

typedef unsigned __int64 uint64_t;

#endif // !_STDINT
#else
#include <stdint.h>
#endif
#include <stddef.h>
#ifdef _WIN32
#define WIN32_LEAN_AND_MEAN
#include <Windows.h>
#undef WIN32_LEAN_AND_MEAN
#else// Define system-specific HL_* defines here
#ifndef HL_UNIX
#define HL_UNIX

#if (defined __gnu_linux__) || (defined __linux__)
#define HL_LINUX
#endif

#if (defined __APPLE__) && (defined __MACH__)
#define HL_LINUX
#define HL_MACOS
#endif

#ifdef _AIX
#define HL_AIX
#define HL_BIG_ENDIAN
#endif

#ifdef __FreeBSD__
#define HL_FREEBSD
#endif

#if (defined _hpux) || (defined hpux) || (defined __hpux)
#define HL_HPUX
#define HL_BIG_ENDIAN
#endif

#if (defined sun) || (defined __sun)
#define HL_SOLARIS
#endif

#if (defined __arm__) || (defined __aarch64__)
#define HL_LINUX_ARM
#endif

#ifdef __ANDROID__
#define HL_ANDROID
#endif

#endif
#include <hob-unix01.h>
#endif
#ifdef __APPLE__
/* We get target conditionals to keep apart Mac OS, iOS and iOS simulator.
   The conditionals are TARGET_IPHONE_SIMULATOR, TARGET_OS_IPHONE and TARGET_OS_MAC.
   TARGET_IPHONE_SIMULATOR has the highest priority, TARGET_OS_MAC the lowest.
   Always test, if the conditional is 1, as they will be defined as 0, if we 
   are not compiling for the target.
   */
#include <TargetConditionals.h>
#endif

#include <string.h>
#include <stdlib.h>
#include "hob-encry-1.h"
#include "hob-encry-intern-1.h"

//================================================================
// Perform RSA Exponentation (either public or private exponent)
// NOTE: 1. All numeric data must be specified in BIG endian format !
// ----- 2. Destination buffer must have at least same size as the rsa
//	    modulus n !
//
// Input parameters:	unsigned char * abyp_rsa_data	  plain/ciphertext (IN)
//			int	        imp_rsa_data_len  length in byte
//			unsigned char * abyp_rsa_exp	  exponent e or d
//			int 		imp_rsa_exp_len	  length of exponent
//			unsigned char * abyp_rsa_modulus  modulus n
//			int		imp_rsa_modulus_len length of modulus
//			unsigned char * abyp_dst_buf	  buffer for result
//			int *		aimp_dst_len	  IN: buffer size
//							  OUT: bytes used
// Returns: int status - 0 o.k., else error occured
//================================================================
extern "C" int m_rsa_crypt_raw_big(HMEM_CTX_DEF
	unsigned char * abyp_rsa_data, int imp_rsa_data_len,
	unsigned char * abyp_rsa_exp,  int imp_rsa_exp_len,
	unsigned char * abyp_rsa_modulus, int imp_rsa_modulus_len,
	unsigned char * abyp_dst_buf, int * aimp_dst_len)
{
  int iml_retcode;
  int iml_rsa_lnum_elements;
  int iml_dst_buf_len;

  WLNUM * dsl_lnum_data;			// Plain/Ciphertext (in)
  WLNUM * dsl_lnum_exp;				// Exponent e/d
  WLNUM * dsl_lnum_modulus;			// Modulus n
  WLNUM * dsl_lnum_result;			// Cipher/Plaintext (out)

#if defined __INSURE__
  _Insure_checking_enable(0);
#endif

  //----------------------------------------------------------
  // check parameters given first
  //----------------------------------------------------------
  if((abyp_rsa_data == NULL) || (abyp_rsa_exp == NULL) ||
     (abyp_rsa_modulus == NULL) || (aimp_dst_len == NULL))
  {
#if defined __INSURE__
    _Insure_checking_enable(1);
#endif
    return(LNUM_OP_NULL_PTR);
  }

  iml_dst_buf_len = * aimp_dst_len;

  if((imp_rsa_modulus_len <= 0) || (imp_rsa_data_len <= 0) ||
     (imp_rsa_exp_len <= 0) || (iml_dst_buf_len <= 0))
  {
#if defined __INSURE__
    _Insure_checking_enable(1);
#endif
    return(LNUM_OP_PARAM_ERR);
  }
  //----------------------------------------------------------
  // check consistency of parameters
  //----------------------------------------------------------
  if((imp_rsa_data_len > imp_rsa_modulus_len) ||
     (imp_rsa_exp_len > imp_rsa_modulus_len) ||
     (iml_dst_buf_len < imp_rsa_modulus_len))
  {
#if defined __INSURE__
    _Insure_checking_enable(1);
#endif
    return(LNUM_OP_PARAM_ERR);
  }
  //----------------------------------------------------------
  // Allocate needed large numbers for calculation
  //----------------------------------------------------------
  iml_rsa_lnum_elements = ((imp_rsa_modulus_len + 3) / 4) + 1;

  for(;;)	// error FOR
  {
    dsl_lnum_data    = AllocNewWLnum(HMEM_CTX_REF1 iml_rsa_lnum_elements);
    dsl_lnum_exp     = AllocNewWLnum(HMEM_CTX_REF1 iml_rsa_lnum_elements);
    dsl_lnum_modulus = AllocNewWLnum(HMEM_CTX_REF1 iml_rsa_lnum_elements);
    dsl_lnum_result  = AllocNewWLnum(HMEM_CTX_REF1 iml_rsa_lnum_elements);
    if((dsl_lnum_data == NULL) || (dsl_lnum_exp == NULL) ||
       (dsl_lnum_modulus == NULL) || (dsl_lnum_result == NULL))
    {
      iml_retcode = LNUM_OP_ALLOC_ERR;
      break;
    }
    //----------------------------------------------------------
    // Convert data from buffers to large number format
    //----------------------------------------------------------
    if((iml_retcode = WLnum_bin2wlnum(HMEM_CTX_REF1
	  dsl_lnum_data,
          (char *) abyp_rsa_data,0,imp_rsa_data_len)) != LNUM_OP_OK)
      break;

    if((iml_retcode = WLnum_bin2wlnum(HMEM_CTX_REF1
	  dsl_lnum_exp,
          (char *) abyp_rsa_exp,0,imp_rsa_exp_len)) != LNUM_OP_OK)
      break;

    if((iml_retcode = WLnum_bin2wlnum(HMEM_CTX_REF1
          dsl_lnum_modulus,
          (char *) abyp_rsa_modulus,0,imp_rsa_modulus_len)) != LNUM_OP_OK)
      break;
    //------------------------------------------------------------
    // Exponentiate now ( C = P ** e mod n   /   P = C ** d mod n)
    //------------------------------------------------------------
    if((iml_retcode = ExpModWLnum(HMEM_CTX_REF1
         dsl_lnum_result, dsl_lnum_data,
         dsl_lnum_exp, dsl_lnum_modulus,
         NULL,NULL)) != LNUM_OP_OK)
         break;
    //------------------------------------------------------------
    // Convert result large number back to byte buffer
    //------------------------------------------------------------
    iml_retcode = WLnum_wlnum2bin((char *) abyp_dst_buf,0,aimp_dst_len,
		                  dsl_lnum_result,0);
    break;
  }
  //---------------------------------------------------------
  // Free temporary large numbers, clear private key one
  //---------------------------------------------------------
  ClearFreeWLnum(HMEM_CTX_REF1 dsl_lnum_exp);
  FreeWLnum(HMEM_CTX_REF1 dsl_lnum_data);
  FreeWLnum(HMEM_CTX_REF1 dsl_lnum_result);
  FreeWLnum(HMEM_CTX_REF1 dsl_lnum_modulus);
  if(iml_retcode != 0)
  {
    * aimp_dst_len = 0;
  }

#if defined __INSURE__
  _Insure_checking_enable(1);
#endif
  return(iml_retcode);
}
//================================================================
// Perform RSA Exponentation (either public or private exponent)
// NOTE: 1. All numeric data must be specified in LITTLE endian format !
// ----- 2. Destination buffer must have at least same size as the rsa
//	    modulus n !
//
// Input parameters:	unsigned char * abyp_rsa_data	  plain/ciphertext (IN)
//			int	        imp_rsa_data_len  length in byte
//			unsigned char * abyp_rsa_exp	  exponent e or d
//			int 		imp_rsa_exp_len	  length of exponent
//			unsigned char * abyp_rsa_modulus  modulus n
//			int		imp_rsa_modulus_len length of modulus
//			unsigned char * abyp_dst_buf	  buffer for result
//			int *		aimp_dst_len	  IN: buffer size
//							  OUT: bytes used
// Returns: int status - 0 o.k., else error occured
//================================================================
extern "C" int m_rsa_crypt_raw_little(HMEM_CTX_DEF
	unsigned char * abyp_rsa_data, int imp_rsa_data_len,
	unsigned char * abyp_rsa_exp,  int imp_rsa_exp_len,
	unsigned char * abyp_rsa_modulus, int imp_rsa_modulus_len,
	unsigned char * abyp_dst_buf, int * aimp_dst_len)
{
  int iml_retcode;
  int iml_rsa_lnum_elements;
  int iml_dst_buf_len;

  WLNUM * dsl_lnum_data;			// Plain/Ciphertext (in)
  WLNUM * dsl_lnum_exp;				// Exponent e/d
  WLNUM * dsl_lnum_modulus;			// Modulus n
  WLNUM * dsl_lnum_result;			// Cipher/Plaintext (out)

  //----------------------------------------------------------
  // check parameters given first
  //----------------------------------------------------------
  if((abyp_rsa_data == NULL) || (abyp_rsa_exp == NULL) ||
     (abyp_rsa_modulus == NULL) || (aimp_dst_len == NULL))
    return(LNUM_OP_NULL_PTR);

  iml_dst_buf_len = * aimp_dst_len;

  if((imp_rsa_modulus_len <= 0) || (imp_rsa_data_len <= 0) ||
     (imp_rsa_exp_len <= 0) || (iml_dst_buf_len <= 0))
    return(LNUM_OP_PARAM_ERR);
  //----------------------------------------------------------
  // check consistency of parameters
  //----------------------------------------------------------
  if((imp_rsa_data_len > imp_rsa_modulus_len) ||
     (imp_rsa_exp_len > imp_rsa_modulus_len) ||
     (iml_dst_buf_len < imp_rsa_modulus_len))
    return(LNUM_OP_PARAM_ERR);
  //----------------------------------------------------------
  // Allocate needed large numbers for calculation
  //----------------------------------------------------------
  iml_rsa_lnum_elements = ((imp_rsa_modulus_len + 3) / 4) + 1;

  for(;;)	// error FOR
  {
    dsl_lnum_data    = AllocNewWLnum(HMEM_CTX_REF1 iml_rsa_lnum_elements);
    dsl_lnum_exp     = AllocNewWLnum(HMEM_CTX_REF1 iml_rsa_lnum_elements);
    dsl_lnum_modulus = AllocNewWLnum(HMEM_CTX_REF1 iml_rsa_lnum_elements);
    dsl_lnum_result  = AllocNewWLnum(HMEM_CTX_REF1 iml_rsa_lnum_elements);
    if((dsl_lnum_data == NULL) || (dsl_lnum_exp == NULL) ||
       (dsl_lnum_modulus == NULL) || (dsl_lnum_result == NULL))
    {
      iml_retcode = LNUM_OP_ALLOC_ERR;
      break;
    }
    //----------------------------------------------------------
    // Convert data from buffers to large number format
    //----------------------------------------------------------
    if((iml_retcode = WLnum_bin2wlnumLe(HMEM_CTX_REF1
	  dsl_lnum_data,
          (char *) abyp_rsa_data,0,imp_rsa_data_len)) != LNUM_OP_OK)
      break;

    if((iml_retcode = WLnum_bin2wlnumLe(HMEM_CTX_REF1
	  dsl_lnum_exp,
          (char *) abyp_rsa_exp,0,imp_rsa_exp_len)) != LNUM_OP_OK)
      break;

    if((iml_retcode = WLnum_bin2wlnumLe(HMEM_CTX_REF1
          dsl_lnum_modulus,
          (char *) abyp_rsa_modulus,0,imp_rsa_modulus_len)) != LNUM_OP_OK)
      break;
    //------------------------------------------------------------
    // Exponentiate now ( C = P ** e mod n   /   P = C ** d mod n)
    //------------------------------------------------------------
    if((iml_retcode = ExpModWLnum(HMEM_CTX_REF1
         dsl_lnum_result, dsl_lnum_data,
         dsl_lnum_exp, dsl_lnum_modulus,
         NULL,NULL)) != LNUM_OP_OK)
         break;
    //------------------------------------------------------------
    // Convert result large number back to byte buffer
    //------------------------------------------------------------
    iml_retcode = WLnum_wlnum2binLe((char *) abyp_dst_buf,0,aimp_dst_len,
		                    dsl_lnum_result,0);
    break;
  }
  //---------------------------------------------------------
  // Free temporary large numbers, clear private key one
  //---------------------------------------------------------
  ClearFreeWLnum(HMEM_CTX_REF1 dsl_lnum_exp);
  FreeWLnum(HMEM_CTX_REF1 dsl_lnum_data);
  FreeWLnum(HMEM_CTX_REF1 dsl_lnum_result);
  FreeWLnum(HMEM_CTX_REF1 dsl_lnum_modulus);
  if(iml_retcode != 0)
  {
    * aimp_dst_len = 0;
  }
  return(iml_retcode);
}

extern "C" int m_rsa_crypt_raw_le_blind(HMEM_CTX_DEF
	unsigned char * abyp_rsa_data, int imp_rsa_data_len,
	unsigned char * abyp_rsa_exp,  int imp_rsa_exp_len,
	unsigned char * abyp_rsa_modulus, int imp_rsa_modulus_len,
	unsigned char * abyp_dst_buf, int * aimp_dst_len,
   void* vpp_user_field, amd_get_random amp_get_rand)
{
  int iml_retcode;
  int iml_rsa_lnum_elements;
  int iml_dst_buf_len;

  WLNUM * dsl_lnum_data;			// Plain/Ciphertext (in)
  WLNUM * dsl_lnum_exp;				// Exponent e/d
  WLNUM * dsl_lnum_modulus;			// Modulus n
  WLNUM * dsl_lnum_result;			// Cipher/Plaintext (out)

  //----------------------------------------------------------
  // check parameters given first
  //----------------------------------------------------------
  if((abyp_rsa_data == NULL) || (abyp_rsa_exp == NULL) ||
     (abyp_rsa_modulus == NULL) || (aimp_dst_len == NULL))
    return(LNUM_OP_NULL_PTR);

  iml_dst_buf_len = * aimp_dst_len;

  if((imp_rsa_modulus_len <= 0) || (imp_rsa_data_len <= 0) ||
     (imp_rsa_exp_len <= 0) || (iml_dst_buf_len <= 0))
    return(LNUM_OP_PARAM_ERR);
  //----------------------------------------------------------
  // check consistency of parameters
  //----------------------------------------------------------
  if((imp_rsa_data_len > imp_rsa_modulus_len) ||
     (imp_rsa_exp_len > imp_rsa_modulus_len) ||
     (iml_dst_buf_len < imp_rsa_modulus_len))
    return(LNUM_OP_PARAM_ERR);
  //----------------------------------------------------------
  // Allocate needed large numbers for calculation
  //----------------------------------------------------------
  iml_rsa_lnum_elements = ((imp_rsa_modulus_len + 3) / 4) + 1;

  for(;;)	// error FOR
  {
    dsl_lnum_data    = AllocNewWLnum(HMEM_CTX_REF1 iml_rsa_lnum_elements);
    dsl_lnum_exp     = AllocNewWLnum(HMEM_CTX_REF1 iml_rsa_lnum_elements);
    dsl_lnum_modulus = AllocNewWLnum(HMEM_CTX_REF1 iml_rsa_lnum_elements);
    dsl_lnum_result  = AllocNewWLnum(HMEM_CTX_REF1 iml_rsa_lnum_elements);
    if((dsl_lnum_data == NULL) || (dsl_lnum_exp == NULL) ||
       (dsl_lnum_modulus == NULL) || (dsl_lnum_result == NULL))
    {
      iml_retcode = LNUM_OP_ALLOC_ERR;
      break;
    }
    //----------------------------------------------------------
    // Convert data from buffers to large number format
    //----------------------------------------------------------
    if((iml_retcode = WLnum_bin2wlnumLe(HMEM_CTX_REF1
	  dsl_lnum_data,
          (char *) abyp_rsa_data,0,imp_rsa_data_len)) != LNUM_OP_OK)
      break;

    if((iml_retcode = WLnum_bin2wlnumLe(HMEM_CTX_REF1
	  dsl_lnum_exp,
          (char *) abyp_rsa_exp,0,imp_rsa_exp_len)) != LNUM_OP_OK)
      break;

    if((iml_retcode = WLnum_bin2wlnumLe(HMEM_CTX_REF1
          dsl_lnum_modulus,
          (char *) abyp_rsa_modulus,0,imp_rsa_modulus_len)) != LNUM_OP_OK)
      break;
    //------------------------------------------------------------
    // Exponentiate now ( C = P ** e mod n   /   P = C ** d mod n)
    //------------------------------------------------------------
    if((iml_retcode = m_exp_mod_blind_impl(HMEM_CTX_REF1
            dsl_lnum_result, dsl_lnum_data,
			   dsl_lnum_exp, dsl_lnum_modulus,
			   NULL,(WLNUM_USE_BASE_BLINDING|WLNUM_USE_MOD_BLINDING),NULL, 
            vpp_user_field, amp_get_rand)) != LNUM_OP_OK)
      break;
    //------------------------------------------------------------
    // Convert result large number back to byte buffer
    //------------------------------------------------------------
    iml_retcode = WLnum_wlnum2binLe((char *) abyp_dst_buf,0,aimp_dst_len,
		                    dsl_lnum_result,0);
    break;
  }
  //---------------------------------------------------------
  // Free temporary large numbers, clear private key one
  //---------------------------------------------------------
  ClearFreeWLnum(HMEM_CTX_REF1 dsl_lnum_exp);
  FreeWLnum(HMEM_CTX_REF1 dsl_lnum_data);
  FreeWLnum(HMEM_CTX_REF1 dsl_lnum_result);
  FreeWLnum(HMEM_CTX_REF1 dsl_lnum_modulus);
  if(iml_retcode != 0)
  {
    * aimp_dst_len = 0;
  }
  return(iml_retcode);
  
}

extern "C" int m_rsa_crypt_raw_be_blind(HMEM_CTX_DEF
	unsigned char * abyp_rsa_data, int imp_rsa_data_len,
	unsigned char * abyp_rsa_exp,  int imp_rsa_exp_len,
	unsigned char * abyp_rsa_modulus, int imp_rsa_modulus_len,
	unsigned char * abyp_dst_buf, int * aimp_dst_len,
   void* vpp_user_field, amd_get_random amp_get_rand)
{
  int iml_retcode;
  int iml_rsa_lnum_elements;
  int iml_dst_buf_len;

  WLNUM * dsl_lnum_data;			// Plain/Ciphertext (in)
  WLNUM * dsl_lnum_exp;				// Exponent e/d
  WLNUM * dsl_lnum_modulus;			// Modulus n
  WLNUM * dsl_lnum_result;			// Cipher/Plaintext (out)

  //----------------------------------------------------------
  // check parameters given first
  //----------------------------------------------------------
  if((abyp_rsa_data == NULL) || (abyp_rsa_exp == NULL) ||
     (abyp_rsa_modulus == NULL) || (aimp_dst_len == NULL))
    return(LNUM_OP_NULL_PTR);

  iml_dst_buf_len = * aimp_dst_len;

  if((imp_rsa_modulus_len <= 0) || (imp_rsa_data_len <= 0) ||
     (imp_rsa_exp_len <= 0) || (iml_dst_buf_len <= 0))
    return(LNUM_OP_PARAM_ERR);
  //----------------------------------------------------------
  // check consistency of parameters
  //----------------------------------------------------------
  if((imp_rsa_data_len > imp_rsa_modulus_len) ||
     (imp_rsa_exp_len > imp_rsa_modulus_len) ||
     (iml_dst_buf_len < imp_rsa_modulus_len))
    return(LNUM_OP_PARAM_ERR);
  //----------------------------------------------------------
  // Allocate needed large numbers for calculation
  //----------------------------------------------------------
  iml_rsa_lnum_elements = ((imp_rsa_modulus_len + 3) / 4) + 1;

  for(;;)	// error FOR
  {
    dsl_lnum_data    = AllocNewWLnum(HMEM_CTX_REF1 iml_rsa_lnum_elements);
    dsl_lnum_exp     = AllocNewWLnum(HMEM_CTX_REF1 iml_rsa_lnum_elements);
    dsl_lnum_modulus = AllocNewWLnum(HMEM_CTX_REF1 iml_rsa_lnum_elements);
    dsl_lnum_result  = AllocNewWLnum(HMEM_CTX_REF1 iml_rsa_lnum_elements);
    if((dsl_lnum_data == NULL) || (dsl_lnum_exp == NULL) ||
       (dsl_lnum_modulus == NULL) || (dsl_lnum_result == NULL))
    {
      iml_retcode = LNUM_OP_ALLOC_ERR;
      break;
    }
    //----------------------------------------------------------
    // Convert data from buffers to large number format
    //----------------------------------------------------------
    if((iml_retcode = WLnum_bin2wlnum(HMEM_CTX_REF1
	  dsl_lnum_data,
          (char *) abyp_rsa_data,0,imp_rsa_data_len)) != LNUM_OP_OK)
      break;

    if((iml_retcode = WLnum_bin2wlnum(HMEM_CTX_REF1
	  dsl_lnum_exp,
          (char *) abyp_rsa_exp,0,imp_rsa_exp_len)) != LNUM_OP_OK)
      break;

    if((iml_retcode = WLnum_bin2wlnum(HMEM_CTX_REF1
          dsl_lnum_modulus,
          (char *) abyp_rsa_modulus,0,imp_rsa_modulus_len)) != LNUM_OP_OK)
      break;
    //------------------------------------------------------------
    // Exponentiate now ( C = P ** e mod n   /   P = C ** d mod n)
    //------------------------------------------------------------
    if((iml_retcode = m_exp_mod_blind_impl(HMEM_CTX_REF1
            dsl_lnum_result, dsl_lnum_data,
			   dsl_lnum_exp, dsl_lnum_modulus,
			   NULL,(WLNUM_USE_BASE_BLINDING|WLNUM_USE_MOD_BLINDING),NULL, 
            vpp_user_field, amp_get_rand)) != LNUM_OP_OK)
      break;
    //------------------------------------------------------------
    // Convert result large number back to byte buffer
    //------------------------------------------------------------
    iml_retcode = WLnum_wlnum2bin((char *) abyp_dst_buf,0,aimp_dst_len,
		                    dsl_lnum_result,0);
    break;
  }
  //---------------------------------------------------------
  // Free temporary large numbers, clear private key one
  //---------------------------------------------------------
  ClearFreeWLnum(HMEM_CTX_REF1 dsl_lnum_exp);
  FreeWLnum(HMEM_CTX_REF1 dsl_lnum_data);
  FreeWLnum(HMEM_CTX_REF1 dsl_lnum_result);
  FreeWLnum(HMEM_CTX_REF1 dsl_lnum_modulus);
  if(iml_retcode != 0)
  {
    * aimp_dst_len = 0;
  }
  return(iml_retcode);
}

#endif //HL_ENCR_RSA
// end of file ../RSA/xs-rsa-raw.cpp


#ifdef HL_ENCR_HMEM
/** @addtogroup hmem
*@{
*@file
* This file contains the security library local memory manager functions. A 
* simple approach is taken for local memory management. Small memory blocks 
* (up to 512 bytes) are handed out as fixed sized blocks (16, 32, 64, 128, 256
* and 512 byte) from allocated, partitioned base memory using simple access bit
* lists. When more elements are needed a new memory block is fetched from the 
* WebSecureProxy, partitioned accordingly and appended to the respective 
* control list. Larger memory is managed by a pool list (free/used anchors). 
* When new large memory is needed, needed size is fetched from the 
* WebSecureProxy and linked to one of that lists.
*
* The local memory manager functions are only used with the WebSecureProxy C interface.
* @}
*/
#ifdef XH_INTERFACE

//***********************************************************
//
// Memory management functions for internal memory manager
// - Small/Medium block manager functions
//
//***********************************************************
#include <string.h>
#if (defined _WIN32) & (_MSC_VER < 1700)
#ifndef _STDINT
#define _STDINT
// MSVC lower than 17.00 does not have stdint.h, assure, all needed types are defined

typedef unsigned __int16 uint16_t;

typedef unsigned __int32 uint32_t;

typedef unsigned __int64 uint64_t;

#endif // !_STDINT
#else
#include <stdint.h>
#endif
#include <stddef.h>
#ifdef _WIN32
#define WIN32_LEAN_AND_MEAN
#include <Windows.h>
#undef WIN32_LEAN_AND_MEAN
#else// Define system-specific HL_* defines here
#ifndef HL_UNIX
#define HL_UNIX

#if (defined __gnu_linux__) || (defined __linux__)
#define HL_LINUX
#endif

#if (defined __APPLE__) && (defined __MACH__)
#define HL_LINUX
#define HL_MACOS
#endif

#ifdef _AIX
#define HL_AIX
#define HL_BIG_ENDIAN
#endif

#ifdef __FreeBSD__
#define HL_FREEBSD
#endif

#if (defined _hpux) || (defined hpux) || (defined __hpux)
#define HL_HPUX
#define HL_BIG_ENDIAN
#endif

#if (defined sun) || (defined __sun)
#define HL_SOLARIS
#endif

#if (defined __arm__) || (defined __aarch64__)
#define HL_LINUX_ARM
#endif

#ifdef __ANDROID__
#define HL_ANDROID
#endif

#endif
#include <hob-unix01.h>
#endif
#ifdef __APPLE__
/* We get target conditionals to keep apart Mac OS, iOS and iOS simulator.
   The conditionals are TARGET_IPHONE_SIMULATOR, TARGET_OS_IPHONE and TARGET_OS_MAC.
   TARGET_IPHONE_SIMULATOR has the highest priority, TARGET_OS_MAC the lowest.
   Always test, if the conditional is 1, as they will be defined as 0, if we 
   are not compiling for the target.
   */
#include <TargetConditionals.h>
#endif

#include "hob-encry-1.h"
#include "hob-encry-intern-1.h"
#include "hob-encry-err-1.h"

//#define	DISABLE_MEMMGR

#if defined DISABLE_MEMMGR
#if defined _WIN32
#pragma message("MEM-Manager disabled!")
#endif // WIN32/64
#endif
//
#if defined DISABLE_MANAGED_BUFFERS
#if defined _WIN32
#pragma message("Small buffer MEM-Manager disabled!")
#endif // WIN32/64
#endif

#define	ALIGN_SIZE	16

//()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()
//
// Small buffer management functions
//
//()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()

// Templates
//FreeAllMemPoolLists
static  void FreeAllMemPoolLists(HMEM_CTX_DEF
                                      HMEMDESC* pMemDescStruc);

/** @addtogroup hmem
* @{
*/

/**
* Get left most one bit number of a value (LmoBit).
*
*  @param Value
*  @return int BitNumber, rel. 1 (0 - no bits set) 
*/
static  int LmoBit(int Value)
{
   int Count;

   if(Value == 0)
      return(0);

   Count = 32;
   for(;;)
   {
      if((Value & 0x80000000) != 0)		// found LMO bit
         return(Count);      
      Value <<= 1;
      Count--;
   }
}

/**
* Frees a memory manager control structure and buffers (FreeHmemCtlStruc).
*
*  @param vp__ctx Pointer to the used memory information structure
*  @param pMemCtlStruc Pointer to the control structure to be freed
*/
extern "C"  void FreeHmemCtlStruc(HMEM_CTX_DEF
                                       HMEMHDR* pMemCtlStruc)
{
   m__hextfree(HMEM_CTX_REF, pMemCtlStruc);
}

/**
* Allocates memory control structure, used bit array and the
* buffer to manage, initialize the control structure (AllocHmemCtlStruc).
* It is initialized with the given block size and count.
*
*  @param vp__ctx Pointer to the used memory information structure
*  @param BlockSize Size of blocks to manage
*  @param BlockCount Amount of blocks to manage
*
*  @return Pointer to the new control structure / NULL on allocation error
*/
extern "C"  HMEMHDR* AllocHmemCtlStruc(HMEM_CTX_DEF
                                            int BlockSize, int BlockCount)
{
   int i,j;
   int BufLen;
   int BitArrayElements;
   int BitArrayLen;
   int TotalLen;

   char* pAllocBuf = NULL;
   HMEMHDR* pMemCtlStruc;
   //-------------------------------------------------------
   // Check parameters
   //-------------------------------------------------------
   if((BlockSize <= 0) || (BlockCount <= 0))
      return(NULL);
   //-------------------------------------------------------
   // Align Blocksize to next higher power of 2
   //-------------------------------------------------------
   i = LmoBit(BlockSize);		// get left most set (+1)
   j = 0x01 << (i-1);			// calculate power 2 base
   if(j < BlockSize)			// must use next power of 2
      j <<= 1;
   BlockSize = j;
   if(BlockSize < 16)
      BlockSize = 16;
   //-------------------------------------------------------
   // Round up Blockcount to next multiple of 32
   //-------------------------------------------------------
   BlockCount = ((BlockCount + 31) / 32) * 32;

   //-------------------------------------------------------
   // Calculate buffer size needed and size of Bitarray
   //-------------------------------------------------------
   BufLen = BlockSize * BlockCount;
   BitArrayElements = BlockCount / 32;
   BitArrayLen = BitArrayElements * 4;
   //-------------------------------------------------------
   // Allocate total buffer size needed
   //-------------------------------------------------------
   TotalLen = sizeof(HMEMHDR) + BitArrayLen + BufLen;
   if((pAllocBuf = (char*) m__hextmalloc(HMEM_CTX_REF,
      TotalLen + ALIGN_SIZE)) == NULL)
      return(NULL);
   //-------------------------------------------------------
   // Clear the used slot bit array
   //-------------------------------------------------------
   memset(pAllocBuf + sizeof(HMEMHDR),0,BitArrayLen);

   //-------------------------------------------------------
   // Initialize structure and used bit array
   //-------------------------------------------------------
   pMemCtlStruc = (HMEMHDR*) ((void*) pAllocBuf);

   pMemCtlStruc->pNextMemHdr = NULL;
   pMemCtlStruc->BlockSize   = BlockSize;
   pMemCtlStruc->BlockCount  = BlockCount;
   pMemCtlStruc->MaxUsedCount = 0;
   pMemCtlStruc->ActUsedCount = 0;
   pMemCtlStruc->pUsedBlockBitArray = (int*)
      ((void*) (pAllocBuf + sizeof(HMEMHDR)));
   pMemCtlStruc->pBufStart   = (char *) (
      (ptrdiff_t) ((pAllocBuf + sizeof(HMEMHDR) + BitArrayLen + ALIGN_SIZE)) &
      (ptrdiff_t) (~((ptrdiff_t) ALIGN_SIZE-1)) );

   pMemCtlStruc->pBufEnd     = pMemCtlStruc->pBufStart + BufLen - 1;
   return(pMemCtlStruc);
}

/**
* Frees a linked list of control structure and buffers (FreeHmemCtlStrucList).
*
*  @param vp__ctx Pointer to the used memory information structure
*  @param pMemCtlStruc Pointer to the first list entry to be freed
*/
extern "C"  void FreeHmemCtlStrucList(HMEM_CTX_DEF
                                           HMEMHDR* pMemCtlStruc)
{
   HMEMHDR* pNextMemCtlStruc;

   for(;;)
   {
      if(pMemCtlStruc == NULL)
         return;
      pNextMemCtlStruc = pMemCtlStruc->pNextMemHdr;
      m__hextfree(HMEM_CTX_REF,pMemCtlStruc);
      pMemCtlStruc = pNextMemCtlStruc;
   }
}

/**
* Frees a managed buffer from the slot list (if from list...) (FreeManagedBuffer).
*
*  @param pMemCtlStruc
*  @param pMemSlot
*  @return int Status - 0 not found,
* \n            > 0 freed,
* \n            < 0 error: -1 Base is invalid
* \n            -2 Already freed
*/
extern "C"  int FreeManagedBuffer(HMEMHDR* pMemCtlStruc,
                                       char* pMemSlot)
{
   int ArrayBitNr;
   int ArrayElementNr;
   int ElementBitNr;

   ptrdiff_t Offset;
   uint32_t Mask;

   //  HMEM_HDR_PTR pNext

   if((pMemCtlStruc == NULL) || (pMemSlot == NULL))
      return(HMEM_NULL_PTR);
   //-----------------------------------------------------
   // Find the structure where buffer was allocated from
   //-----------------------------------------------------
   for(;;)
   {
      if(((ptrdiff_t) pMemSlot >= (ptrdiff_t) pMemCtlStruc->pBufStart) &&
         ((ptrdiff_t) pMemSlot <= (ptrdiff_t) pMemCtlStruc->pBufEnd))
      {
         //-------------------------------------------------
         // Buffer is from this Element, find allocation bit
         //-------------------------------------------------
         Offset = (ptrdiff_t) pMemSlot - (ptrdiff_t) pMemCtlStruc->pBufStart;
         ArrayBitNr = (int) ((ptrdiff_t) Offset / (ptrdiff_t) pMemCtlStruc->BlockSize);
         if(((ptrdiff_t) pMemCtlStruc->BlockSize * ArrayBitNr) != Offset)
         {

            return(-1);
         }

         ArrayElementNr = ArrayBitNr / 32;		// 32 bits per element
         ElementBitNr   = ArrayBitNr % 32;		// Bit in element
         Mask = 0x01 << ElementBitNr;
         if((pMemCtlStruc->pUsedBlockBitArray[ArrayElementNr] & Mask) == 0)
         {
            return(-2);
         }
         pMemCtlStruc->pUsedBlockBitArray[ArrayElementNr] &= (~Mask);
         pMemCtlStruc->ActUsedCount--;
         return(1);
      }
      //----------------------------------------------------
      // Buffer not from this element, try next
      //----------------------------------------------------
      pMemCtlStruc = pMemCtlStruc->pNextMemHdr;
      if(pMemCtlStruc == NULL)
         return(0);				// not found...
   }
}

/**
* Allocates space from managed buffer array/list (AllocManagedBuffer).
* NOTE: If no slot can be found, allocate a new structure
*   and append to list.
*
*  @param vp__ctx Pointer to the used memory information structure
*  @param pMemCtlStruc
*  @return BIT8PTR pMem / NULL
*/
extern "C"  char* AllocManagedBuffer(HMEM_CTX_DEF
                                          HMEMHDR* pMemCtlStruc)
{
   int ArrayIndex;
   int MaxIndex;
   int BitCnt;
   int ArrayElementNr;
   int ArrayElement;
   HMEMHDR* pNewMemCtlStruc;
   char* pUserBuf;

   if(pMemCtlStruc == NULL)
      return(NULL);

   for(;;)
   {
      //---------------------------------------------------
      // find a free slot to use
      //---------------------------------------------------
      ArrayIndex = 0;
      MaxIndex = pMemCtlStruc->BlockCount/32;
      while(ArrayIndex < MaxIndex)
      {
         ArrayElement = pMemCtlStruc->pUsedBlockBitArray[ArrayIndex];
         if((~ArrayElement) != 0)			// not all bits set
         {
            //-------------------------------------------------
            // found an element with free slots, get first free
            //-------------------------------------------------
            BitCnt = 0;
            for(;;)
            {
               if((ArrayElement & 0x01) == 0)
                  break;
               ArrayElement >>= 1;
               BitCnt++;
            }
            ArrayElementNr = (ArrayIndex * 32) + BitCnt;	// Bit nr.
            pUserBuf = pMemCtlStruc->pBufStart +
               (pMemCtlStruc->BlockSize * ArrayElementNr);
            pMemCtlStruc->pUsedBlockBitArray[ArrayIndex] |= (0x01 << BitCnt);
            pMemCtlStruc->ActUsedCount++;
            if(pMemCtlStruc->ActUsedCount > pMemCtlStruc->MaxUsedCount)
               pMemCtlStruc->MaxUsedCount = pMemCtlStruc->ActUsedCount;
            return(pUserBuf);
         }
         ArrayIndex++;
      }
      //-----------------------------------------------------
      // no free slot found, check if more structures present
      //-----------------------------------------------------
      if(pMemCtlStruc->pNextMemHdr == NULL)	// was last one...
         break;
      pMemCtlStruc = pMemCtlStruc->pNextMemHdr;
   }
   //-------------------------------------------------------
   // No empty slot found, allocate a new structure, append
   //-------------------------------------------------------
   if((pNewMemCtlStruc = AllocHmemCtlStruc(HMEM_CTX_REF1
      pMemCtlStruc->BlockSize,
      pMemCtlStruc->BlockCount)) == NULL)
      return(NULL);
   //----------------------------------------------------------
   // link structure to last used, get block from first element
   //----------------------------------------------------------
   pMemCtlStruc->pNextMemHdr = pNewMemCtlStruc;
   pUserBuf = pNewMemCtlStruc->pBufStart;
   pNewMemCtlStruc->pUsedBlockBitArray[0] |= 0x01;
   pNewMemCtlStruc->ActUsedCount = 1;
   pNewMemCtlStruc->MaxUsedCount = 1;

   return(pUserBuf);  
}

/**
* Frees all small buffer management lists (FreeSmallMemDescStruc).
*
*  @param vp__ctx Pointer to the used memory information structure
*  @param pMemDescStruc
*/
extern "C"  void FreeSmallMemDescStruc(HMEM_CTX_DEF
                                            HMEMDESC* pMemDescStruc)
{
   if(pMemDescStruc == NULL)
      return;

   //--------------------------------------------------------
   // Free pool lists first !
   //--------------------------------------------------------
   FreeAllMemPoolLists(HMEM_CTX_REF1 pMemDescStruc);

   //--------------------------------------------------------
   // Free the management buffer lists now
   //--------------------------------------------------------
   FreeHmemCtlStrucList(HMEM_CTX_REF1 pMemDescStruc->pMemCtlAnchor16Byte);
   FreeHmemCtlStrucList(HMEM_CTX_REF1 pMemDescStruc->pMemCtlAnchor32Byte);
   FreeHmemCtlStrucList(HMEM_CTX_REF1 pMemDescStruc->pMemCtlAnchor64Byte);
   FreeHmemCtlStrucList(HMEM_CTX_REF1 pMemDescStruc->pMemCtlAnchor256Byte);
   FreeHmemCtlStrucList(HMEM_CTX_REF1 pMemDescStruc->pMemCtlAnchor512Byte);
   m__hextfree(HMEM_CTX_REF,pMemDescStruc);
}

extern "C"  void HMemMgrFree(HMEM_CTX_DEF1)
{

   HMEMDESC*	pMemDescStruc = ((ds__hmem *) vp__ctx)->pHmemDesc;

   if(pMemDescStruc == NULL)
      return;

   //--------------------------------------------------------
   // Free pool lists first !
   //--------------------------------------------------------
   FreeAllMemPoolLists(HMEM_CTX_REF1 ((ds__hmem *)vp__ctx)->pHmemDesc);

   //--------------------------------------------------------
   // Free the management buffer lists now
   //--------------------------------------------------------
   FreeHmemCtlStrucList(HMEM_CTX_REF1 pMemDescStruc->pMemCtlAnchor16Byte);
   FreeHmemCtlStrucList(HMEM_CTX_REF1 pMemDescStruc->pMemCtlAnchor32Byte);
   FreeHmemCtlStrucList(HMEM_CTX_REF1 pMemDescStruc->pMemCtlAnchor64Byte);
   FreeHmemCtlStrucList(HMEM_CTX_REF1 pMemDescStruc->pMemCtlAnchor256Byte);
   FreeHmemCtlStrucList(HMEM_CTX_REF1 pMemDescStruc->pMemCtlAnchor512Byte);
   m__hextfree(HMEM_CTX_REF,pMemDescStruc);
   ((ds__hmem *) vp__ctx)->pHmemDesc = NULL;

}

ds__hmem m_make_mem_struct(BOOL (* am__aux2)(void * vp__p_ctx,
                                             int in__funct,
                                             void * vp__p_mem,
                                             int  in__size),
                            void* avop_user_field,
                            int inp_flags)
{
    ds__hmem dsl_new_struct;
    
    memset(&dsl_new_struct, 0, sizeof(ds__hmem));
    dsl_new_struct.in__aux_up_version = 1;
    dsl_new_struct.am__aux2 = am__aux2;
    dsl_new_struct.in__flags = inp_flags;
    dsl_new_struct.vp__context =avop_user_field;

    return dsl_new_struct;
}

/**
* Allocates small buffer management structure description array (AllocSmallMemDescStruc).
*
*  @param vp__ctx Pointer to the used memory information structure
* 
*  @return HMEM_DESC_PTR pMemDescStruc / NULL if failed
*/
extern "C"  HMEMDESC* AllocSmallMemDescStruc(HMEM_CTX_DEF1)
{
   HMEMDESC* pMemDescStruc;

   HMEMINFO MemInfoStruc;
   //-------------------------------------------------------------
   // Get size of default blocks to allocate
   //-------------------------------------------------------------
   memset(&MemInfoStruc,0,sizeof(MemInfoStruc));
   MemInfoStruc.InfoStrucSize = sizeof(MemInfoStruc);

   if(((ds__hmem *) vp__ctx)->pMemSizeInfoCallback != NULL)
   {
      ((ds__hmem *) vp__ctx)->pMemSizeInfoCallback(&MemInfoStruc);
      // call the info subroutine...
   }

   if(MemInfoStruc.InitialByte16BlockCount <= 0)
      MemInfoStruc.InitialByte16BlockCount = HMEM_DEFAULT_16BYTE_BLOCKS;

   if(MemInfoStruc.InitialByte32BlockCount <= 0)
      MemInfoStruc.InitialByte32BlockCount = HMEM_DEFAULT_32BYTE_BLOCKS;

   if(MemInfoStruc.InitialByte64BlockCount <= 0)
      MemInfoStruc.InitialByte64BlockCount = HMEM_DEFAULT_64BYTE_BLOCKS;

   if(MemInfoStruc.InitialByte256BlockCount <= 0)
      MemInfoStruc.InitialByte256BlockCount = HMEM_DEFAULT_256BYTE_BLOCKS;

   if(MemInfoStruc.InitialByte512BlockCount <= 0)
      MemInfoStruc.InitialByte512BlockCount = HMEM_DEFAULT_512BYTE_BLOCKS;

   //-------------------------------------------------------------
   // Allocate the descriptor structure
   //-------------------------------------------------------------

   pMemDescStruc = (HMEMDESC*)
      m__hextcalloc(HMEM_CTX_REF,1,sizeof(HMEMDESC));
   if(pMemDescStruc == NULL)
      return(NULL);
   //-------------------------------------------------------------
   // Allocate the management elements with default size each
   //-------------------------------------------------------------
   pMemDescStruc->pMemCtlAnchor16Byte  = AllocHmemCtlStruc(HMEM_CTX_REF1
      16,MemInfoStruc.InitialByte16BlockCount);
   pMemDescStruc->pMemCtlAnchor32Byte  = AllocHmemCtlStruc(HMEM_CTX_REF1
      32,MemInfoStruc.InitialByte32BlockCount);
   pMemDescStruc->pMemCtlAnchor64Byte  = AllocHmemCtlStruc(HMEM_CTX_REF1
      64,MemInfoStruc.InitialByte64BlockCount);
   pMemDescStruc->pMemCtlAnchor256Byte = AllocHmemCtlStruc(HMEM_CTX_REF1
      256,MemInfoStruc.InitialByte256BlockCount);
   pMemDescStruc->pMemCtlAnchor512Byte = AllocHmemCtlStruc(HMEM_CTX_REF1
      512,MemInfoStruc.InitialByte512BlockCount);

   if((pMemDescStruc->pMemCtlAnchor16Byte == NULL) ||
      (pMemDescStruc->pMemCtlAnchor32Byte == NULL) ||
      (pMemDescStruc->pMemCtlAnchor64Byte == NULL) ||
      (pMemDescStruc->pMemCtlAnchor256Byte == NULL) ||
      (pMemDescStruc->pMemCtlAnchor512Byte == NULL))
   {
      FreeSmallMemDescStruc(HMEM_CTX_REF1 pMemDescStruc);
      return(NULL);
   }
   return(pMemDescStruc);
}

/**
* Frees a memory block from local managed buffers or global (HFreeManagedBuffer).
*
*  @param vp__ctx Pointer to the used memory information structure
*  @param pMem Memory base
*  @param pMemDesc descriptor structure
*  @return int Status - 0 o.k., else error occured
*/
extern "C"  int HFreeManagedBuffer(HMEM_CTX_DEF
                                        char* pMem, HMEMDESC* pMemDesc)
{
   int Retcode;

   if((pMem == NULL) || (pMemDesc == NULL))
      return(HMEM_NULL_PTR);

#if defined DISABLE_MEMMGR || defined DISABLE_MANAGED_BUFFERS

   m__hextfree(HMEM_CTX_REF,pMem);
   return(HMEM_OP_OK);

#else

   //-------------------------------------------------
   // Find buffer in local structures
   //-------------------------------------------------
   for(;;)
   {
      if((Retcode =
         FreeManagedBuffer(pMemDesc->pMemCtlAnchor16Byte,pMem)) != 0)
         break;

      if((Retcode =
         FreeManagedBuffer(pMemDesc->pMemCtlAnchor32Byte,pMem)) != 0)
         break;

      if((Retcode =
         FreeManagedBuffer(pMemDesc->pMemCtlAnchor64Byte,pMem)) != 0)
         break;

      if((Retcode =
         FreeManagedBuffer(pMemDesc->pMemCtlAnchor256Byte,pMem)) != 0)
         break;
      if((Retcode =
         FreeManagedBuffer(pMemDesc->pMemCtlAnchor512Byte,pMem)) != 0)
         break;
      m__hextfree(HMEM_CTX_REF,pMem);
      return(HMEM_OP_OK);
   }
   if(Retcode > 0)
      Retcode = HMEM_OP_OK;
   return(Retcode);
#endif // defined DISABLE_MEMMGR || defined DISABLE_MANAGED_BUFFERS
}

/**
* Allocates a memory block from local managed buffers or global (HAllocManagedBuffer).
*
*  @param vp__ctx Pointer to the used memory information structure
*  @param BufSize size requested
*  @param pMemDesc descriptor structure
*  @return BIT8PTR ach_pmem / NULL if failed
*/
extern "C"  char* HAllocManagedBuffer(HMEM_CTX_DEF
                                           int BufSize, HMEMDESC* pMemDesc)
{
   if((pMemDesc == NULL) || (BufSize <= 0))
      return(NULL);

#if defined DISABLE_MEMMGR || defined DISABLE_MANAGED_BUFFERS

   return(m__hextmalloc(HMEM_CTX_REF,BufSize));

#else // !defined DISABLE_MEMMGR

   //-------------------------------------------------
   // Check size of requested buffer
   //-------------------------------------------------
   if(BufSize > 512)
   {
      return((char*) m__hextmalloc(HMEM_CTX_REF,BufSize));
   }
   if(BufSize <= 16)
   {
      return((char*)
         AllocManagedBuffer(HMEM_CTX_REF1 pMemDesc->pMemCtlAnchor16Byte));
   }
   if(BufSize <= 32)
   {
      return((char*)
         AllocManagedBuffer(HMEM_CTX_REF1 pMemDesc->pMemCtlAnchor32Byte));
   }
   if(BufSize <= 64)
   {
      return((char*)
         AllocManagedBuffer(HMEM_CTX_REF1 pMemDesc->pMemCtlAnchor64Byte));
   }
   if(BufSize <= 256)
   {
      return((char*)
         AllocManagedBuffer(HMEM_CTX_REF1 pMemDesc->pMemCtlAnchor256Byte));
   }
   return((char*)
      AllocManagedBuffer(HMEM_CTX_REF1 pMemDesc->pMemCtlAnchor512Byte));
#endif // defined DISABLE_MEMMGR || defined DISABLE_MANAGED_BUFFERS
}

//()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()
//
// Buffer pool management functions
// NOTE: Rely on small buffer management !!!!
//
//()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()

/**
* Free a buffer pool list and the buffers (FreeMemPoolList).
* NOTE: Buffers are freed direct from system, structures through
* ----- small buffer management routines
*	 ... AT THE MOMENT USE DIRECT FREE ! ...
*
*  @param pPoolList
*               TESTED O.K.
*/
static  void FreeMemPoolList(HMEM_CTX_DEF
                                  HMEMPOOL_STRUC* pPoolList)
{
   char* pBuf;
   HMEMPOOL_STRUC* pActPoolStruc = pPoolList;
   HMEMPOOL_STRUC* pNextPoolStruc;

   while(pActPoolStruc != NULL)
   {
      pNextPoolStruc = pActPoolStruc->pNext;	// save next pointer
      if((pBuf = pActPoolStruc->pMemBase) != NULL)
      {
         m__hextfree(HMEM_CTX_REF1 pBuf);    	// free direct by system
      }
      m__hextfree(HMEM_CTX_REF1 pActPoolStruc);	// free with buffer manager
      pActPoolStruc = pNextPoolStruc;
   }
}
/**
* Free all buffer pool lists and the buffers (FreeAllMemPoolLists).
* NOTE: Buffers are freed from system, structures with small
* ----- buffer management routines
*	 ... AT THE MOMENT USE DIRECT FREE ! ...
*
*  @param pMemDescStruc
*               TESTED O.K.
*/
static  void FreeAllMemPoolLists(HMEM_CTX_DEF
                                      HMEMDESC* pMemDescStruc)
{
   if(pMemDescStruc == NULL)
      return;

   FreeMemPoolList(HMEM_CTX_REF1 pMemDescStruc->pUsedPoolListAnchor);
   pMemDescStruc->pUsedPoolListAnchor = NULL;
   FreeMemPoolList(HMEM_CTX_REF1 pMemDescStruc->pFreePoolListAnchor);
   pMemDescStruc->pFreePoolListAnchor = NULL;
}

/**
* Allocate a buffer pool structure and the buffer of requested
* size (AllocBufferPoolStruc).
* Note: Buffer is allocated direct from system, structure through
* ----- small buffer management routines
*	 ... AT THE MOMENT USE DIRECT ALLOCATION !!! ...
*
*  @param MemSize Buffer size to allocate
*  @return HMEMPOOL_PTR pPoolDescStruc / NULL
*/
static  HMEMPOOL_STRUC* AllocBufferPoolStruc(HMEM_CTX_DEF
                                                  int MemSize)
{
   char* pBuf;
   HMEMPOOL_STRUC* pMemPoolStruc;

   //----------------------------------------------------
   // Allocate the control structure
   //----------------------------------------------------
   if((pMemPoolStruc = (HMEMPOOL_STRUC*) m__hextcalloc(HMEM_CTX_REF1
      1,sizeof(HMEMPOOL_STRUC))) == NULL)
      return(NULL);

   //----------------------------------------------------
   // Allocate the buffer if needed
   //----------------------------------------------------
   if(MemSize > 0)
   {
      if((pBuf = (char*) m__hextmalloc(HMEM_CTX_REF1 MemSize)) == NULL)
      {
         m__hextfree(HMEM_CTX_REF1 pMemPoolStruc);
         return(NULL);
      }
      pMemPoolStruc->AllocSize = MemSize;
      pMemPoolStruc->pMemBase  = pBuf;
   }
   return(pMemPoolStruc);
}
/**
* Re-Allocate a buffer in a pool structure (ReAllocBufferPoolStruc).
* Note: Buffer is allocated direct from system
* ----- Old buffer is freed in all cases !!
*
*               HMEMPOOL_PTR pPoolDescStruc
*  @param NewMemSize New buffer size to allocate
*  @return int Status - 0 o.k.
* \n            > 0 new buffer could not be allocated
* \n            < 0 error occured
* \n            TESTED O.K.
*/
static  int ReAllocBufferPoolStruc(HMEM_CTX_DEF
                                        HMEMPOOL_STRUC* pMemPoolStruc, int NewMemSize)
{
   char* pNewBuf;

   if(pMemPoolStruc == NULL)
      return(HMEM_NULL_PTR);

   //-----------------------------------------------------
   // Free the current buffer, allocate the new buffer
   //-----------------------------------------------------
   if(pMemPoolStruc->AllocSize >= NewMemSize)	// no realloc needed...
      return(0);

   if(pMemPoolStruc->pMemBase != NULL)		// a buffer is present
   {
      m__hextfree(HMEM_CTX_REF1 pMemPoolStruc->pMemBase);
      pMemPoolStruc->pMemBase  = NULL;
      pMemPoolStruc->AllocSize = 0;
   }

   if(NewMemSize > 0)
   {
      if((pNewBuf = (char*) m__hextmalloc(HMEM_CTX_REF1 NewMemSize)) == NULL)
         return(1);				// alloc failed !
      pMemPoolStruc->AllocSize = NewMemSize;
      pMemPoolStruc->pMemBase  = pNewBuf;
   }
   return(0);
}

/**
* Pre-Allocate a pooled buffered list with given buffer size
* and number of elements (AllocPoolList).
* NOTE: Buffersize may be 0 (no buffers allocated, only list)
*
*  @param BufSize Size of each buffer requested
*  @param ElementCnt Number of elements requested
*  @return HMEMPOOL_PTR pPoolList / NULL
*/
static  HMEMPOOL_STRUC* AllocPoolList(HMEM_CTX_DEF int BufSize,
                                      int ElementCnt)
{
   HMEMPOOL_STRUC* pPoolListAnchor = NULL;
   HMEMPOOL_STRUC* pLastPoolStruc = NULL;
   HMEMPOOL_STRUC* pNewPoolStruc;

   if(ElementCnt <= 0)
      return(NULL);

   //-----------------------------------------------------------
   // Allocate the structure elements, concatenate to list
   //-----------------------------------------------------------
   while(ElementCnt > 0)
   {
      if((pNewPoolStruc = AllocBufferPoolStruc(HMEM_CTX_REF1
         BufSize)) == NULL)
      {
         if(pPoolListAnchor != NULL)
         {
            FreeMemPoolList(HMEM_CTX_REF1 pPoolListAnchor);
         }
         return(NULL);
      }
      //-----------------------------------------------------
      // Link new element to list end
      //-----------------------------------------------------
      if(pLastPoolStruc == NULL)			// 1st element
      {
         pPoolListAnchor = pNewPoolStruc;		// load list anchor pointer
         pLastPoolStruc  = pNewPoolStruc;
      }
      else
      {
         pLastPoolStruc->pNext = pNewPoolStruc;	// link to end of list
         pLastPoolStruc = pNewPoolStruc;
      }
      ElementCnt--;
   }
   return(pPoolListAnchor);
}

/**
* 'Free' a pooled buffer (FreePooledBuffer).
* 1. find the control structure from the used pool buffer list
* 2. unlink structure from list
* 3. link structure to head of free list
*
*  @param pMemDescStruc control structure
*  @param pMem Buffer base
*  @return int Status - 0 not found in list
* \n            > 0 succesfully freed
* \n            < 0 error occured
* \n            Tested: o.k., all pathes checked.
*/
static int FreePooledBuffer(HMEMDESC* pMemDescStruc, void * pMem)
{
   HMEMPOOL_STRUC* pActUsedStruc;
   HMEMPOOL_STRUC* pLastUsedStruc;
   HMEMPOOL_STRUC* pNextUsedStruc;

   if(pMem == NULL)
      return(HMEM_NULL_PTR);
   //-----------------------------------------------------
   // 1. Find the controlling structure for the buffer
   //-----------------------------------------------------
   if(pMemDescStruc == NULL)		// obviously not from pool...
      return(0);

   pActUsedStruc = pMemDescStruc->pUsedPoolListAnchor;	// get anchor
   if(pActUsedStruc == NULL)		// not from used pool
      return(0);

   pLastUsedStruc = NULL;
   for(;;)
   {
      pNextUsedStruc = pActUsedStruc->pNext;	// get the next used pointer
      if(pMem == pActUsedStruc->pMemBase)		// found the entry
      {
         //-----------------------------------------------------------
         // unlink structure from used list, put to front of free list
         //-----------------------------------------------------------
         pActUsedStruc->pNext = pMemDescStruc->pFreePoolListAnchor; // to front
         pMemDescStruc->pFreePoolListAnchor = pActUsedStruc;	// set next

         if(pLastUsedStruc == NULL)		// was first element in list
         {
            pMemDescStruc->pUsedPoolListAnchor = pNextUsedStruc;
         }
         else
         {
            pLastUsedStruc->pNext = pNextUsedStruc;
         }
         return(1);
      }
      //-------------------------------------------------------
      // Entry not yet found, advance to next if present
      //-------------------------------------------------------
      if(pNextUsedStruc == NULL)			// was last element
         return(0);
      pLastUsedStruc = pActUsedStruc;
      pActUsedStruc  = pNextUsedStruc;
   }
}

/**
* 'Allocate' a pooled buffer of requested size (AllocPooledBuffer).
* Algorithm used:
* 1. Check if there are free pool elements available at all
*    a) no: allocate a pooled buffer structure with requested buffer
*           size and link to head of used pool list.
*    b) yes: goto 2.
*
* 2. Free elements are available. Search for an element that matches
*    the requested size AND is the optimal one (smallest suitable in list)
*    a) found appropriate pool element:
*	 - unlink from the free list and link to head of used list
*	 - return the buffer pointer
*    b) no appropriate element was found: goto 3.
*
* 3.  No matching pool element found. Do the following:
* 3.1 Search for the element with largest allocated buffer to reallocate it.
*    a) No element has a buffer allocated:
*       - Should not happen !!!
*    b) Best fit element's buffer size > requested size:
*	 - unlink from the free list and link to head of used list
*	 - return the buffer pointer
*    c) Best fit element's buffer size < requested size:
*       - Reallocate element to requested size
*       I) Realloc fails (NOTE: previous buffer has been freed!):
*	    - unlink element from free list and free structure
*	    - go back to 3.1. This will allow the system to concatenate
*	      unused buffers to satisfy a new alloc request
*	 II) Realloc succeeds:
*	     - unlink from the free list and link to head of used list
*	     - return the buffer pointer
*
*
*  @param pMemDescStruc control structure
*  @param MemSize requested size
*  @return BIT8PTR pMem / NULL
* \n            TESTED O.K.
*/
static  char* AllocPooledBuffer(HMEM_CTX_DEF
                                     HMEMDESC* pMemDescStruc, int MemSize)
{
   int Retcode;
   int NewMemSize = (int) MemSize;
   int BestFitSize;

   HMEMPOOL_STRUC* pNextFreePool;
   HMEMPOOL_STRUC* pActFreePool;
   HMEMPOOL_STRUC* pLastFreePool;
   HMEMPOOL_STRUC* pNewPool;
   HMEMPOOL_STRUC* pActBestFitFreePool;
   HMEMPOOL_STRUC* pLastBestFitFreePool;

   if(NewMemSize <= 0)
      return(NULL);

   if(pMemDescStruc == NULL)
   {
      //--------------------------------------------------------
      // 0. initialize small buffer management, checked o.k.
      //--------------------------------------------------------
      pMemDescStruc = AllocSmallMemDescStruc(HMEM_CTX_REF);
      if(pMemDescStruc == NULL)
      {
         return((char*) m__hextmalloc(HMEM_CTX_REF1 MemSize)); // get direct from system...
      }
      ((ds__hmem *) vp__ctx)->pHmemDesc = pMemDescStruc;

      pNewPool = AllocPoolList(HMEM_CTX_REF,DEFAULT_HMEM_POOL_SIZE,
         DEFAULT_HMEM_POOL_COUNT);
      pMemDescStruc->pFreePoolListAnchor = pNewPool;
   }

   for(;;) // RETRY LOOP!!
   {
      //-----------------------------------------------------------
      // 1. Check if free pool elements are available at all
      //-----------------------------------------------------------
      if((pActFreePool = pMemDescStruc->pFreePoolListAnchor) == NULL)
      {
         //------------------------------------------------------------
         // no elements on free list, get new element, put to used list
         // TESTED O.K.
         //------------------------------------------------------------
         if((pNewPool = AllocBufferPoolStruc(HMEM_CTX_REF1 MemSize)) == NULL)
            return(NULL);

         pNewPool->pNext = pMemDescStruc->pUsedPoolListAnchor;
         pMemDescStruc->pUsedPoolListAnchor = pNewPool;
         return(pNewPool->pMemBase);
      }
      //--------------------------------------------------------------
      // 2. Free pool elements are present, find the best matching one
      // ALL PATHS TESTED O.K.
      //--------------------------------------------------------------
      pActBestFitFreePool  = NULL;
      pLastBestFitFreePool = NULL;

      pLastFreePool = NULL;
      BestFitSize = 0;

      for(;;)
      {
         if(pActFreePool->AllocSize == NewMemSize)	// optimal match !!
         {
            //-------------------------------------------------------------
            // 2.1. optimal match, unlink from free list, link to used list
            // ALL PATHS TESTED O.K.
            //-------------------------------------------------------------
            if(pLastFreePool == NULL)		// was first free element!
            {
               pMemDescStruc->pFreePoolListAnchor = pActFreePool->pNext; // unlink
            }
            else
            {
               pLastFreePool->pNext = pActFreePool->pNext; // unlink, not anchor
            }
            pActFreePool->pNext = pMemDescStruc->pUsedPoolListAnchor; // link in
            pMemDescStruc->pUsedPoolListAnchor = pActFreePool;	// to head
            return(pActFreePool->pMemBase);
         }
         else if(NewMemSize > pActFreePool->AllocSize) // MemSize > ElementSize
         {
            //----------------------------------------------------------------
            // 2.2. Requested buffer size LARGER than actual free element's
            //      buffer size, check if current element is a better fit than
            //      already scanned ones (aka. size difference is smaller)
            // TESTED O.K.
            //----------------------------------------------------------------
            if(pActFreePool->AllocSize > BestFitSize)	// is larger than last
            {
               pLastBestFitFreePool = pLastFreePool;		// set new last ptr
               pActBestFitFreePool  = pActFreePool;		// set new actual
               BestFitSize          = pActFreePool->AllocSize;
            }
         }
         else					// MemSize < ElementSize
         {
            //----------------------------------------------------------------
            // 2.3. Requested buffer size SMALLER than actual free element's
            //      buffer size, check if current element is a better fit than 
            //      already scanned ones (aka. size difference is smaller)
            // TESTED O.K.
            //----------------------------------------------------------------
            if((BestFitSize == 0) ||			// no best element yet
               (BestFitSize < NewMemSize) ||		// smaller was best
               (pActFreePool->AllocSize < BestFitSize))	// distance smaller
            {
               pLastBestFitFreePool = pLastFreePool;		// set new last ptr
               pActBestFitFreePool  = pActFreePool;		// set new actual
               BestFitSize          = pActFreePool->AllocSize;
            }
         }
         pLastFreePool = pActFreePool;		// save current
         pActFreePool  = pActFreePool->pNext;	// advance
         if(pActFreePool == NULL)			// was last one
            break;
      }
      //-----------------------------------------------------------
      // 3.0 Now we have information about (current) best fit
      //-----------------------------------------------------------
      if(BestFitSize == 0)		// SHOULD NOT HAPPEN !!!!
      {
         //-----------------------------------------------------------------
         // No buffers found on free list, STRANGE, list should be empty now
         //-----------------------------------------------------------------
         continue;					// back to start ???
      }
      //-----------------------------------------------------------
      // 3.1 Found a candidate element, check if usable
      // ALL PATHS TESTED O.K.
      //-----------------------------------------------------------
      if(BestFitSize > NewMemSize)		// apporopriate buffer found
      {
         //----------------------------------------------------------
         // 3.2 usable buffer, unlink best fit element from free list,
         //     link to used list
         // ALL PATHS TESTED O.K.
         //----------------------------------------------------------
         if(pLastBestFitFreePool == NULL)		// was first in free list
         {
            pMemDescStruc->pFreePoolListAnchor = pActBestFitFreePool->pNext;
         }
         else					// not first, unlink
         {
            pLastBestFitFreePool->pNext = pActBestFitFreePool->pNext;
         }

         if(pMemDescStruc->pUsedPoolListAnchor == NULL)	// first element now
         {
            pActBestFitFreePool->pNext = NULL;	// terminate list
            pMemDescStruc->pUsedPoolListAnchor = pActBestFitFreePool;
         }
         else
         {
            pActBestFitFreePool->pNext = pMemDescStruc->pUsedPoolListAnchor; // link
            pMemDescStruc->pUsedPoolListAnchor = pActBestFitFreePool;
         }
         return(pActBestFitFreePool->pMemBase);
      }
      //-------------------------------------------------------------
      // 3.2. No buffer element with size > Memsize found, reallocate
      // ALL PATHS TESTED O.K.
      //-------------------------------------------------------------
      Retcode = ReAllocBufferPoolStruc(HMEM_CTX_REF,
         pActBestFitFreePool,MemSize);
      if(Retcode == 0)				// realloc succeeded
      {
         //------------------------------------------------------
         // Got a fitting element, unlink from free, link to used
         // ALL PATHS TESTED O.K.
         //------------------------------------------------------
         if(pLastBestFitFreePool == NULL)		// was first in free list
         {
            pMemDescStruc->pFreePoolListAnchor = pActBestFitFreePool->pNext;
         }
         else					// not first, unlink
         {
            pLastBestFitFreePool->pNext = pActBestFitFreePool->pNext;
         }

         if(pMemDescStruc->pUsedPoolListAnchor == NULL)	// first element mow
         {
            pActBestFitFreePool->pNext = NULL;	// terminate list
            pMemDescStruc->pUsedPoolListAnchor = pActBestFitFreePool;
         }
         else
         {
            pActBestFitFreePool->pNext = pMemDescStruc->pUsedPoolListAnchor; // link
            pMemDescStruc->pUsedPoolListAnchor = pActBestFitFreePool;
         }
         return(pActBestFitFreePool->pMemBase);
      }
      //-------------------------------------------------------------
      // 3.3. Reallocate failed, remove element from the list, free
      //	    and retry the procedure...
      // ALL PATHS TESTED O.K.
      //-------------------------------------------------------------
      pNextFreePool = pActBestFitFreePool->pNext;	// save next pointer
      m__hfree(HMEM_CTX_REF,pActBestFitFreePool);
      if(pLastBestFitFreePool == NULL)
      {
         pMemDescStruc->pFreePoolListAnchor = pNextFreePool;
      }
      else
      {  
         pLastBestFitFreePool->pNext = pNextFreePool;
      }
   } // outer loop FOR
}

extern "C"  void m__hpoolfree(HMEM_CTX_DEF void * ach_ppool_mem)
{
   int Retcode;

   if(ach_ppool_mem == NULL)
      return;

#if defined DISABLE_MEMMGR

   m__hextfree(HMEM_CTX_REF,ach_ppool_mem);
   return;

#else // !defined DISABLE_MEMMGR

   if((((ds__hmem *) vp__ctx)->in__flags & HMEM_NO_POOLS_FLAG_BIT) != 0)
   {
      m__hfree(HMEM_CTX_REF,ach_ppool_mem);
      return;
   }

   //-----------------------------------------------------
   // Try to free from buffer pool first
   //-----------------------------------------------------
   Retcode = FreePooledBuffer(((ds__hmem *) vp__ctx)->pHmemDesc, ach_ppool_mem);

   if(Retcode <= 0)			// not found on list(or error?)
   {
      m__hfree(HMEM_CTX_REF,ach_ppool_mem);
      return;
   }
   //-----------------------------------------------------
   // Buffer was from pool list
   //-----------------------------------------------------
#endif // defined DISABLE_MEMMGR
}

extern "C"  char* m__hpoolmalloc(HMEM_CTX_DEF int in__memory_size)
{
   char* pPoolMem;

   if(in__memory_size <= 0)
      return(NULL);

#if defined DISABLE_MEMMGR

   pPoolMem = m__hextmalloc(HMEM_CTX_REF,in__memory_size);
   return(pPoolMem);

#else // !defined DISABLE_MEMMGR

   //------------------------------------------------------------------
   // Filter small buffer requests (handled by small buffer management)
   //------------------------------------------------------------------
#if !defined DISABLE_MANAGED_BUFFERS
   if(in__memory_size <= HMEM_MAX_MANAGED_BUF_SIZE)
   {
      pPoolMem = (char*) m__hmalloc(HMEM_CTX_REF,in__memory_size);
      return(pPoolMem);
   }
#endif // !defined DISABLE_MANAGED_BUFFERS

   if((((ds__hmem *) vp__ctx)->in__flags & HMEM_NO_POOLS_FLAG_BIT) != 0)
   {
      return(NULL);
   }

   //----------------------------------------------------
   // use buffer pool list
   //----------------------------------------------------
   pPoolMem = AllocPooledBuffer(HMEM_CTX_REF,
      ((ds__hmem *) vp__ctx)->pHmemDesc, in__memory_size);

   return(pPoolMem);
#endif // defined DISABLE_MEMMGR
}

/** @} */

#endif // XH_INTERFACE

#endif //HL_ENCR_HMEM
// end of file ../hmem/hmemmgr.cpp


#ifdef HL_ENCR_HMEM
/** @defgroup hmem HOB memory management
* @brief HOB memory management module for WSP
*
* This module provides memory management functions for the WSP. It is only 
* compiled into the SSL Library for WSP.
*
* The functions provided by this module behave equivalent to the C standard
* memory management functions, but take an additional input parameter, pointing
* at a special memory management structure.
*
* This module has no external dependencies.
*
* @author g.oed
* @date 2004/08/15
*@{
*@file
* This file provides implementations for generic, C-style memory management
* functions for the WSP.
*@}
*/
/*****************************************************************************/
/* Project:       hob ssl / others                                         */
/* Source:        memfunc.c                                                  */
/* Description:   allocation functions through external routines              */
/*                                                                           */
/* Copyright 2004 HOB GmbH & Co. KG                                          */
/*                                                                           */
/* Created by:    g.oed                                                      */
/* Creation Date: 2004/08/15                                                 */
/*                                                                           */
/* Operating system(architecture): -                                         */
/*                                                                           */
/* Compile with:  XH_SERVER                                                  */
/*                                                                           */
/* Additional requirements:                                                  */
/*                                                                           */
/* Changed by:                                                               */
/*                                                                           */
/*****************************************************************************/

#if defined XH_INTERFACE

#include <stdlib.h>
#include <string.h>
#if (defined _WIN32) & (_MSC_VER < 1700)
#ifndef _STDINT
#define _STDINT
// MSVC lower than 17.00 does not have stdint.h, assure, all needed types are defined

typedef unsigned __int16 uint16_t;

typedef unsigned __int32 uint32_t;

typedef unsigned __int64 uint64_t;

#endif // !_STDINT
#else
#include <stdint.h>
#endif
#include <stddef.h>
#ifdef _WIN32
#define WIN32_LEAN_AND_MEAN
#include <Windows.h>
#undef WIN32_LEAN_AND_MEAN
#else// Define system-specific HL_* defines here
#ifndef HL_UNIX
#define HL_UNIX

#if (defined __gnu_linux__) || (defined __linux__)
#define HL_LINUX
#endif

#if (defined __APPLE__) && (defined __MACH__)
#define HL_LINUX
#define HL_MACOS
#endif

#ifdef _AIX
#define HL_AIX
#define HL_BIG_ENDIAN
#endif

#ifdef __FreeBSD__
#define HL_FREEBSD
#endif

#if (defined _hpux) || (defined hpux) || (defined __hpux)
#define HL_HPUX
#define HL_BIG_ENDIAN
#endif

#if (defined sun) || (defined __sun)
#define HL_SOLARIS
#endif

#if (defined __arm__) || (defined __aarch64__)
#define HL_LINUX_ARM
#endif

#ifdef __ANDROID__
#define HL_ANDROID
#endif

#endif
#include <hob-unix01.h>
#endif
#ifdef __APPLE__
/* We get target conditionals to keep apart Mac OS, iOS and iOS simulator.
   The conditionals are TARGET_IPHONE_SIMULATOR, TARGET_OS_IPHONE and TARGET_OS_MAC.
   TARGET_IPHONE_SIMULATOR has the highest priority, TARGET_OS_MAC the lowest.
   Always test, if the conditional is 1, as they will be defined as 0, if we 
   are not compiling for the target.
   */
#include <TargetConditionals.h>
#endif

#include "hob-encry-1.h"
#include "hob-encry-intern-1.h"

/** @addtogroup hmem
*@{
*/

//===================================================================
// memory allocation function, session associated
//
// input parameters: ds__hmem * ads__p_hmem_struc	context to use
//		     int        in__memory_size         size to allocate
// returns: void * vp__p_mem / NULL
//-------------------------------------------------------------------
// jdc:
//
//===================================================================
//m__hextmalloc
extern "C" void * m__hextmalloc(ds__hmem * ads__p_hmem_struc,int in__memory_size)
{
  void * vp_m;			// a void pointer

  if((ads__p_hmem_struc == NULL) || (in__memory_size <= 0))
  {

    return NULL;
  }

  if(ads__p_hmem_struc->in__aux_up_version == 0) // old version of alloc
  {
    if(!ads__p_hmem_struc->am__aux1(DEF_AUX_MEMGET,&vp_m,in__memory_size))
    {

      return NULL;
    }
  }
  else						// new version of alloc  
  {
    if(!ads__p_hmem_struc->am__aux2(ads__p_hmem_struc->vp__context,
                                    DEF_AUX_MEMGET,&vp_m,in__memory_size))
    {

      return NULL;
    }
  }

  return vp_m;
}
//===================================================================
// memory allocation function, global heap (session independent)
//
// input parameters: ds__hmem * ads__p_hmem_struc	context to use
//		     int        in__memory_size         size to allocate
// returns: void * vp__p_mem / NULL
//-------------------------------------------------------------------
// jdc:
//
//===================================================================
//m__hextmalloc_glbl
extern "C" void * m__hextmalloc_glbl(ds__hmem * ads__p_hmem_struc,
				 int in__memory_size)
{
  void * vp_m;			// a void pointer

  if((ads__p_hmem_struc == NULL) || (in__memory_size <= 0))
  {

    return NULL;
  }

  if(ads__p_hmem_struc->in__aux_up_version == 0) // old version of alloc
  {
    if(!ads__p_hmem_struc->am__aux1(DEF_AUX_MEMGET,&vp_m,in__memory_size))
    {

      return NULL;
    }
  }
  else						// new version of alloc  
  {
    if(!ads__p_hmem_struc->am__aux2(NULL,
                                    DEF_AUX_MEMGET,&vp_m,in__memory_size))
    {

      return NULL;
    }
  }

  return vp_m;
}

//===================================================================
// memory allocation function with clear, session associated
//
// input parameters: ds__hmem * ads__p_hmem_struc	context to use
//                   int        in__element_count       elements to alloc
//		     int        in__element_size        size to allocate
// returns: void * vp__p_mem / NULL
//-------------------------------------------------------------------
// jdc:
//
//===================================================================
//m__hextcalloc
extern "C" void * m__hextcalloc(ds__hmem * ads__p_hmem_struc,
		 	    int in__element_cnt, int in__element_size)
{
  void * vp_m;			// a void pointer

  if((ads__p_hmem_struc == NULL) || (in__element_cnt <= 0) ||
     (in__element_size <= 0))
  {

    return NULL;
  }

  if(ads__p_hmem_struc->in__aux_up_version == 0) // old version of alloc
  {
    if(!ads__p_hmem_struc->am__aux1(DEF_AUX_MEMGET,&vp_m,
                                    in__element_cnt * in__element_size))
    {

      return NULL;
    }
  }
  else
  {
    if(!ads__p_hmem_struc->am__aux2(ads__p_hmem_struc->vp__context,
                                    DEF_AUX_MEMGET,&vp_m,
                                    in__element_cnt * in__element_size))
    {

      return NULL;
    }
  }
  memset(vp_m,0,in__element_cnt*in__element_size);

  return vp_m;
}
//===================================================================
// memory allocation function with clear, global heap (session independent)
//
// input parameters: ds__hmem * ads__p_hmem_struc	context to use
//                   int        in__element_count       elements to alloc
//		     int        in__element_size        size to allocate
// returns: void * vp__p_mem / NULL
//-------------------------------------------------------------------
// jdc:
//
//===================================================================
//m__hextcalloc_glbl
extern "C" void * m__hextcalloc_glbl(ds__hmem * ads__p_hmem_struc,
		 	         int in__element_cnt, int in__element_size)
{
  void * vp_m;			// a void pointer

  if((ads__p_hmem_struc == NULL) || (in__element_cnt <= 0) ||
     (in__element_size <= 0))
  {

    return NULL;
  }

  if(ads__p_hmem_struc->in__aux_up_version == 0) // old version of alloc
  {
    if(!ads__p_hmem_struc->am__aux1(DEF_AUX_MEMGET,&vp_m,
                                    in__element_cnt * in__element_size))
    {

      return NULL;
    }
  }
  else
  {
    if(!ads__p_hmem_struc->am__aux2(NULL,
                                    DEF_AUX_MEMGET,&vp_m,
                                    in__element_cnt * in__element_size))
    {

      return NULL;
    }
  }
  memset(vp_m,0,in__element_cnt*in__element_size);

  return vp_m;
}

//===================================================================
// memory free function, session associated
//
// input parameters: ds__hmem * ads__p_hmem_struc	context to use
//                   void*      vp__p_mem               memory
// returns: nothing
//-------------------------------------------------------------------
// jdc:
//
//===================================================================
//m__hextfree
extern "C" void m__hextfree(ds__hmem * ads__p_hmem_struc,void * vp__p_mem)
{

  if((ads__p_hmem_struc == NULL) || (vp__p_mem == NULL))
  {

    return;
  }

  if(ads__p_hmem_struc->in__aux_up_version == 0) // old version of alloc
  {
    ads__p_hmem_struc->am__aux1(DEF_AUX_MEMFREE,&vp__p_mem,0);
  }
  else
  {
    ads__p_hmem_struc->am__aux2(ads__p_hmem_struc->vp__context,
                               DEF_AUX_MEMFREE,&vp__p_mem,0);
  }
}
//===================================================================
// memory free function, global heap (session independent)
//
// input parameters: ds__hmem * ads__p_hmem_struc	context to use
//                   void*      vp__p_mem               memory
// returns: nothing
//-------------------------------------------------------------------
// jdc:
//
//===================================================================
//m__hextfree_glbl
extern "C" void m__hextfree_glbl(ds__hmem * ads__p_hmem_struc,void * vp__p_mem)
{

  if((ads__p_hmem_struc == NULL) || (vp__p_mem == NULL))
  {

    return;
  }

  if(ads__p_hmem_struc->in__aux_up_version == 0) // old version of alloc
  {
    ads__p_hmem_struc->am__aux1(DEF_AUX_MEMFREE,&vp__p_mem,0);
  }
  else
  {
    ads__p_hmem_struc->am__aux2(NULL,DEF_AUX_MEMFREE,&vp__p_mem,0);
  }
}

//m__hmalloc
extern "C" void * m__hmalloc(ds__hmem * ads__p_hmem_struc,int in__memory_size)
{
  void * vp_m;

  if((ads__p_hmem_struc == NULL) || (in__memory_size <= 0))
  {

    return NULL;
  }

  //---------------------------------------------------------
  // Check if buffersize is larger than internal managed
  //---------------------------------------------------------
  if(in__memory_size > HMEM_MAX_MANAGED_BUF_SIZE)
  {
    return(m__hextmalloc(ads__p_hmem_struc,in__memory_size));
  }
  //---------------------------------------------------------
  // Buffer size is smaller, manage self
  //---------------------------------------------------------
  if((ads__p_hmem_struc->in__flags & HMEM_LOCKED_STRUC_FLAG_BIT) != 0)
  {

    return(NULL);
  }

  if(ads__p_hmem_struc->pHmemDesc == NULL)	// no structure yet...
  {
    ads__p_hmem_struc->pHmemDesc =
      AllocSmallMemDescStruc(ads__p_hmem_struc);
    if(ads__p_hmem_struc->pHmemDesc == NULL)
    {

      return(NULL);
    }
  }

  vp_m = HAllocManagedBuffer(ads__p_hmem_struc,in__memory_size,
			     ads__p_hmem_struc->pHmemDesc);

  return(vp_m);
}
//===================================================================
// Internal memory allocation function with clear
//
// input parameters: ds__hmem * ads__p_hmem_struc	context to use
//                   int        in__element_count       elements to alloc
//		     int        in__element_size        size to allocate
// returns: void * vp__p_mem / NULL
//-------------------------------------------------------------------
// jdc:
//
//===================================================================
//m__hcalloc
extern "C" void * m__hcalloc(ds__hmem * ads__p_hmem_struc,
		 	 int in__element_cnt, int in__element_size)
{
  int in__request_size;
  void * vp_m;			// a void pointer

  if((ads__p_hmem_struc == NULL) || (in__element_cnt <= 0) ||
     (in__element_size <= 0))
  {

    return NULL;
  }

  //---------------------------------------------------------
  // Check if buffersize is larger than internal managed
  //---------------------------------------------------------
  in__request_size = in__element_cnt * in__element_size;
  if(in__request_size > HMEM_MAX_MANAGED_BUF_SIZE)
  {
    return(m__hextcalloc(ads__p_hmem_struc,in__element_cnt,in__element_size));
  }
  //---------------------------------------------------------
  // Buffer size is smaller, manage self
  //---------------------------------------------------------
  if((ads__p_hmem_struc->in__flags & HMEM_LOCKED_STRUC_FLAG_BIT) != 0)
  {

    return(NULL);
  }

  if(ads__p_hmem_struc->pHmemDesc == NULL)	// no structure yet...
  {
    ads__p_hmem_struc->pHmemDesc =
      AllocSmallMemDescStruc(ads__p_hmem_struc);
    if(ads__p_hmem_struc->pHmemDesc == NULL)
    {

      return(NULL);
    }
  }

  vp_m = (void *) HAllocManagedBuffer(ads__p_hmem_struc,in__request_size,
				      ads__p_hmem_struc->pHmemDesc);
  if(vp_m != NULL)
  {
    memset(vp_m,0,in__request_size);

  }

  return(vp_m);
}
//===================================================================
// memory free function
//
// input parameters: ds__hmem * ads__p_hmem_struc	context to use
//                   void*      vp__p_mem               memory
// returns: nothing
//-------------------------------------------------------------------
// jdc:
//
//===================================================================
//m__hfree
extern "C" void m__hfree(ds__hmem * ads__p_hmem_struc,void * vp__p_mem)
{
  if((ads__p_hmem_struc == NULL) || (vp__p_mem == NULL))
  {

    return;
  }

  //-------------------------------------------------------
  // Check if we have an internal memory manager structure
  //-------------------------------------------------------
  if(ads__p_hmem_struc->pHmemDesc == NULL)	// no structure yet...
  {
    m__hextfree(ads__p_hmem_struc,vp__p_mem);
    return;
  }
  //-------------------------------------------------------
  // Free by internal buffer management
  //-------------------------------------------------------
  if((ads__p_hmem_struc->in__flags & HMEM_LOCKED_STRUC_FLAG_BIT) != 0)
  {

    return;
  }

  HFreeManagedBuffer(ads__p_hmem_struc,
				   (char*) vp__p_mem,
				   ads__p_hmem_struc->pHmemDesc);

}
/** @}*/
#endif // XH_INTERFACE


#endif //HL_ENCR_HMEM
// end of file ../hmem/memfunc.cpp


#ifdef HL_ENCR_HMEM
//**********************************************************************
//
// Memory allocation / free helper functions, needed for tester programs
// that are translated and linked in XH_INTERFACE mode
//
//**********************************************************************

#if defined XH_INTERFACE
#include <stdlib.h>
#include <string.h>
#if (defined _WIN32) & (_MSC_VER < 1700)
#ifndef _STDINT
#define _STDINT
// MSVC lower than 17.00 does not have stdint.h, assure, all needed types are defined

typedef unsigned __int16 uint16_t;

typedef unsigned __int32 uint32_t;

typedef unsigned __int64 uint64_t;

#endif // !_STDINT
#else
#include <stdint.h>
#endif
#include <stddef.h>
#ifdef _WIN32
#define WIN32_LEAN_AND_MEAN
#include <Windows.h>
#undef WIN32_LEAN_AND_MEAN
#else// Define system-specific HL_* defines here
#ifndef HL_UNIX
#define HL_UNIX

#if (defined __gnu_linux__) || (defined __linux__)
#define HL_LINUX
#endif

#if (defined __APPLE__) && (defined __MACH__)
#define HL_LINUX
#define HL_MACOS
#endif

#ifdef _AIX
#define HL_AIX
#define HL_BIG_ENDIAN
#endif

#ifdef __FreeBSD__
#define HL_FREEBSD
#endif

#if (defined _hpux) || (defined hpux) || (defined __hpux)
#define HL_HPUX
#define HL_BIG_ENDIAN
#endif

#if (defined sun) || (defined __sun)
#define HL_SOLARIS
#endif

#if (defined __arm__) || (defined __aarch64__)
#define HL_LINUX_ARM
#endif

#ifdef __ANDROID__
#define HL_ANDROID
#endif

#endif
#include <hob-unix01.h>
#endif
#ifdef __APPLE__
/* We get target conditionals to keep apart Mac OS, iOS and iOS simulator.
   The conditionals are TARGET_IPHONE_SIMULATOR, TARGET_OS_IPHONE and TARGET_OS_MAC.
   TARGET_IPHONE_SIMULATOR has the highest priority, TARGET_OS_MAC the lowest.
   Always test, if the conditional is 1, as they will be defined as 0, if we 
   are not compiling for the target.
   */
#include <TargetConditionals.h>
#endif

#include "hob-encry-1.h"
#include "hob-encry-intern-1.h"
/** @addtogroup hmem
* @{
* @file
* This file implements helper routines, needed for tester programs
* that are translated and linked in XH_INTERFACE mode.
*/

/**
* Allocation Helper routine, Version 1 mode
*/
extern "C"  BOOL MemMgrV1(int Function, void * MemPtr, int Size)
{
  //--------------------------------------------
  // Distribute by function...
  //--------------------------------------------
  switch(Function)
  {
    case DEF_AUX_MEMGET:
      if((MemPtr == NULL) || (Size <= 0))
        return(FALSE);
      *((void **) MemPtr) = (void *) malloc(Size);
      if(*((void **) MemPtr) == NULL)
        return(FALSE);
      return(TRUE);

    case DEF_AUX_MEMFREE:
      if((MemPtr != NULL) && (*((void **) MemPtr) != NULL))
        free(*((void **) MemPtr));
      return(TRUE);

    default:
      return(FALSE);
  } // switch
}

/**
* Allocation Helper routine, Version 2 mode
*/
extern "C"  BOOL MemMgrV2(void * , int Function,
			    void * MemPtr, int Size)
{
  //--------------------------------------------
  // Distribute by function...
  //--------------------------------------------
  switch(Function)
  {
    case DEF_AUX_MEMGET:
      if((MemPtr == NULL) || (Size <= 0))
        return(FALSE);
      *((void ** ) MemPtr) = (void *) malloc(Size);
      if(*((void **) MemPtr) == NULL)
        return(FALSE);
      return(TRUE);

    case DEF_AUX_MEMFREE:
      if((MemPtr != NULL) && (*((void **) MemPtr) != NULL))
        free(*((void **) MemPtr));
      return(TRUE);

    default:
      return(FALSE);
  } // switch
}

extern "C"  ds__hmem * AllocFillMemCtxStruc(int InterfaceMode)
{
  ds__hmem * pCtxStruc = NULL;

  if((pCtxStruc = (ds__hmem *) calloc(1,sizeof(ds__hmem))) == NULL)
  {
    return(NULL);
  }

  pCtxStruc->in__struc_size       = sizeof(ds__hmem);
//  pCtxStruc->in__flags	          = 0;
//  pCtxStruc->pMemSizeInfoCallback = NULL;
//  pCtxStruc->pHmemDesc            = NULL;
//  pCtxStruc->vp__context          = NULL;		// not used here
  pCtxStruc->am__aux1             = &MemMgrV1;
  pCtxStruc->am__aux2             = &MemMgrV2;
  pCtxStruc->in__aux_up_version   = InterfaceMode;
  return(pCtxStruc);
}
/** @} */
#endif // XH_INTERFACE

#endif //HL_ENCR_HMEM
// end of file ../hmem/memhlp.cpp


#ifdef HL_ENCR_VERSION

#if (defined _WIN32) & (_MSC_VER < 1700)
#ifndef _STDINT
#define _STDINT
// MSVC lower than 17.00 does not have stdint.h, assure, all needed types are defined

typedef unsigned __int16 uint16_t;

typedef unsigned __int32 uint32_t;

typedef unsigned __int64 uint64_t;

#endif // !_STDINT
#else
#include <stdint.h>
#endif
#include <stddef.h>
#include <stdio.h>
#ifdef _WIN32
#define WIN32_LEAN_AND_MEAN
#include <Windows.h>
#undef WIN32_LEAN_AND_MEAN
#define vsnprintf(a,b,...) vsnprintf_s(a,b,b,__VA_ARGS__)
#else// Define system-specific HL_* defines here
#ifndef HL_UNIX
#define HL_UNIX

#if (defined __gnu_linux__) || (defined __linux__)
#define HL_LINUX
#endif

#if (defined __APPLE__) && (defined __MACH__)
#define HL_LINUX
#define HL_MACOS
#endif

#ifdef _AIX
#define HL_AIX
#define HL_BIG_ENDIAN
#endif

#ifdef __FreeBSD__
#define HL_FREEBSD
#endif

#if (defined _hpux) || (defined hpux) || (defined __hpux)
#define HL_HPUX
#define HL_BIG_ENDIAN
#endif

#if (defined sun) || (defined __sun)
#define HL_SOLARIS
#endif

#if (defined __arm__) || (defined __aarch64__)
#define HL_LINUX_ARM
#endif

#ifdef __ANDROID__
#define HL_ANDROID
#endif

#endif
#include <hob-unix01.h>
#endif
#ifdef __APPLE__
/* We get target conditionals to keep apart Mac OS, iOS and iOS simulator.
   The conditionals are TARGET_IPHONE_SIMULATOR, TARGET_OS_IPHONE and TARGET_OS_MAC.
   TARGET_IPHONE_SIMULATOR has the highest priority, TARGET_OS_MAC the lowest.
   Always test, if the conditional is 1, as they will be defined as 0, if we 
   are not compiling for the target.
   */
#include <TargetConditionals.h>
#endif

#include "hob-encry-1.h"
#include "hob-encry-err-1.h"

#ifndef DEF_AUX_CONSOLE_OUT
#define DEF_AUX_CONSOLE_OUT        2        // output to console
#endif

#ifndef OPTIMIZE_OFF
#ifdef _WIN32
#define OPTIMIZE_OFF __pragma(optimize("", off))
#define OPTIMIZE_ON __pragma(optimize("", on))
#else
#define OPTIMIZE_OFF
#define OPTIMIZE_ON 
#endif
#endif

extern "C"  int m_encry_getversioninfo(int* ainp_version,  
                                       char* achp_dst_buf, 
                                       int* ainp_dst_len)
{
  int inl_buf_len;

  char chrl_version_str[] = HSSL_VERSION_PROD_TXT " " HSSL_VERSION_DESC_TXT
                    ", Version " HSSL_VERSION_1_STR "." HSSL_VERSION_2_STR " "
                    HSSL_VERSION_3_STR "." HSSL_VERSION_4_STR ", Rev. "     
                    HSSL_RELEASE_MAJ_STR "." HSSL_RELEASE_MIN_STR
                    ", " HSSL_VERSION_DATE_TXT;
  //------------------------------------------------------
  // Check parameters first
  //------------------------------------------------------
  if (((ainp_version == NULL) && (achp_dst_buf == NULL) && (ainp_dst_len == NULL)) ||
      ((achp_dst_buf != NULL) && (ainp_dst_len == NULL)))
    return(HMEM_NULL_PTR);

  //------------------------------------------------------
  // Set the Version Number
  //------------------------------------------------------
  if (ainp_version != NULL)
  {
    ainp_version[0] = (HSSL_VERSION_3_NO << 24) |
                      (HSSL_VERSION_4_NO << 16) |
                                  (HSSL_RELEASE_MAJ_NO << 8) |
                                             (HSSL_RELEASE_MIN_NO);
  }
  //------------------------------------------------------
  // Check if string is requested...
  //------------------------------------------------------
  if (ainp_dst_len != NULL)
  {
    //----------------------------------------------------------
    // Get required buffer size, check if only size is requested
    //----------------------------------------------------------
    inl_buf_len = (int) strlen(chrl_version_str);

    if (achp_dst_buf == NULL)
    {
      ainp_dst_len[0] = inl_buf_len + 1;
      return(HMEM_OP_OK);
    }
    //-----------------------------------------------------
    // Check buffer size given
    //-----------------------------------------------------
    if (ainp_dst_len[0] <= inl_buf_len)
    {
      ainp_dst_len[0] = inl_buf_len + 1;
      return(HMEM_PARAM_ERR);
    }

    //-----------------------------------------------------
    // Copy String to user buffer
    //-----------------------------------------------------
    ainp_dst_len[0] = inl_buf_len;                                            // exclusive NUL !
    memcpy(achp_dst_buf, chrl_version_str, inl_buf_len);
    achp_dst_buf[inl_buf_len] = 0;                                           // delimiting NUL
  }
  return(HMEM_OP_OK);
} // end of extern "C"  int m_encry_getversioninfo(...)

#ifndef _WIN32

extern "C" void m_sec_zero_mem(void* avop_mem, size_t szp_len)
{
   memset(avop_mem,0,szp_len);
}
#else
extern "C" void m_sec_zero_mem(void* avop_mem, size_t szp_len)
{
   SecureZeroMemory(avop_mem, szp_len);
}
#endif //!_WIN32

OPTIMIZE_OFF
extern "C" int const_time_memcmp(const void *adsp_mem_1, 
                                 const void *adsp_mem_2,
                                 size_t szc_mem_len)
{
   const char *achl_mem1 = static_cast<const char*>(adsp_mem_1);
   const char *achl_mem2 = static_cast<const char*>(adsp_mem_2);
   size_t szl_index;
   int inl_result = 0;

   for (szl_index = 0; szl_index < szc_mem_len; szl_index++) {
      inl_result |= (achl_mem1[szl_index] ^ achl_mem2[szl_index]);
   }
   return inl_result;
}
OPTIMIZE_ON

    
#if defined XH_INTERFACE
/**
* Prints a message using WSP AUX function.
*
* Formating options work as per ANSI C printf(), maximum length 511 characters.
*
*  @param ach_format Formating string
*/
extern "C" void PrintAux(HMEM_CTX_DEF const char * ach_format,...)
{
  char rch_buffer[512];
  int  inl_size;
  va_list args;

  va_start(args,ach_format);
  inl_size = vsnprintf(&rch_buffer[0],511,ach_format,args);
  va_end(args);

  rch_buffer[inl_size] = 0;

  if(vp__ctx->am__aux2 != NULL)
    vp__ctx->am__aux2(vp__ctx->vp__context,DEF_AUX_CONSOLE_OUT,
		     (void *) rch_buffer,inl_size);
}
#else
extern "C" void PrintAux(HMEM_CTX_DEF const char * ach_format,...)
{
  int  inl_size;
  va_list args;

  va_start(args,ach_format);
  inl_size = vprintf(ach_format,args);
  va_end(args);
}
#endif // defined XH_INTERFACE

#endif //HL_ENCR_VERSION
// end of file ../hssl/xs_encry_version_1.cpp

