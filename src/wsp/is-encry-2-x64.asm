;Generated by: xbprecomp01 is-encry-2-x64.pre is-encry-2-x64.asm "%%SET WIN$VC=1;"

;-----------------------------------------------------------------------------------------;
;  Assembler : MASM (Microsoft ASM)                                                       ;
;-----------------------------------------------------------------------------------------;







;   This macro is used for movq with GP-Registers. MASM uses movd for moving 64 bit registers from and to XMM
movq_r   macro DEST, SRC
        movd  DEST, SRC
        endm

;        is-encry-2-x64.asm
;        Copyright (C) HOB Germany 2016
;

public m_impl_add
public m_impl_sub
public m_impl_cmp
public m_impl_mult_basic
public m_impl_square
public m_impl_add_karatsuba
public m_impl_sub_karatsuba
public m_impl_add_word
public m_impl_sqr_8
public m_impl_mont_mul_add
public m_impl_first_bit
public m_impl_last_bit
public m_impl_aes_256_key_expansion
public m_impl_aes_192_key_expansion
public m_impl_aes_128_key_expansion
public m_impl_aes_revert_key
public m_impl_aes_ecb_encrypt
public m_impl_aes_ctr
public m_impl_aes_cbc_encrypt
public m_impl_aes_cbc_decrypt
public m_impl_ghash_stream
public m_x86_capabilities






LEN_QWORD          equ  8
LEN_LNUM_ELE       equ  8
.code
GCM_BSWAP BYTE 15,14,13,12,11,10,9,8,7,6,5,4,3,2,1,0

;       extern "C" int m_impl_add(LNUM_WORD* ap_dest,
;                                 LNUM_WORD* ap_a,
;                                 unsigned int szp_a_len,
;                                 LNUM_WORD* ap_b,
;                                 unsigned int szp_b_len);

m_impl_add proc
;-----------------------------------------------------------------------------------------;
;  Calling convention: Microsoft x64                                                      ;
;-----------------------------------------------------------------------------------------;
;           scratch (volatile) registers:   RAX, RCX, RDX, R8, R9, R10, R11               ;
;   callee-save (non-volatile) registers:   RBX, RBP, RDI, RSI, RSP, R12, R13, R14, R15   ;
;                    parameter registers:   RCX, RDX, R8, R9                              ;
;-----------------------------------------------------------------------------------------;
;    ---------------------------------------
;   |            REGISTER STATUS            |
;   |  dst  : RCX                           |
;   |  src1 : RDX         src1_len : R8     |
;   |  src2 : R9          src2_len : stack  |
;    ---------------------------------------
    mov  r10, rcx                       ;   destination to R10, freeing RCX
    mov  ecx, [rsp+028H]                ;   RCX = src2_len (accesing position of the 5th parameter).
                                        ;       0x28 bytes = 0x20 shadow space + 8 return address

;    ---------------------------------------
;   |            REGISTER STATUS            |
;   |  dst  : R10                           |
;   |  src1 : RDX         src1_len : R8     |
;   |  src2 : R9          src2_len : RCX    |
;    ---------------------------------------
    cmp  r8, rcx                        ;   src1_len ? src2_len
    jge  add_start                      ;   jump to the first loop configuration if src1_len >= src2_len

    ; src2 is longer, so we swap the pointers and lengths
    xchg rcx, r8                        ;   [ greater length (g_len) in R8   ;  smaller length (s_len) in RCX ]
    xchg rdx, r9                        ;   [ greater    src (g_src) in RDX  ;  smaller    src (s_src) in R9  ]

add_start:
;    ----------------------------------
;   |          REGISTER STATUS         |
;   |  dst   : R10                     |
;   |  g_src : RDX        g_len : R8   |
;   |  s_src : R9         s_len : RCX  |
;    ----------------------------------
    shr  r8, 3                          ;   Scale length parameters from bytes to (64-bit) words
    shr  rcx, 3
    sub  r8, rcx                        ;   Calculate, how many additional words the longer parameter has over the shorter
    xor  r11, r11                       ;   Clear R11 for use as address offset for the source and dest pointers

;    --------------------------------------------------------
;   |                    REGISTER STATUS                     |
;   |  dst   :  R10       temporary:                    RAX  |
;   |  g_src :  RDX       word for addition :           RCX  |
;   |  s_src :  R9        words for carry propagation : R8   |
;   |  offset : R11                                          |
;    --------------------------------------------------------
    xor  rax,rax                        ;   Clear RAX. AH will be used to store the flags to keep CF between loop runs, so this will effectively clear the CF.
    sub  rcx, 32                        ;   This checks, if at least 32 words are available and prepares the 32 word loop.
                                        ;   sub is used over cmp for the following reason:
                                        ;       At the end of the unrolled loop, 32 will be subtracted again from RCX.
                                        ;       By subtracting an additional block here, this will underflow, when there is less, than 32 words left, signaling the end of the loop.
    jl   add_unroll_32_end              ;   Jump beyond the loop, if less than 32 words are available for addition


align 16
add_unroll_loop_32:

    sahf                                            ;   Restore carry flag

    mov  rax, [rdx + r11 + 0 * LEN_LNUM_ELE]  ;   g_src                       |  mov  :  no flags affected
    adc  rax, [ r9 + r11 + 0 * LEN_LNUM_ELE]  ;   g_src + s_src + carry       |  adc  :  CF is set regarding the carry value (OK: wished behaviour)
    mov  [r10 + r11 + 0 * LEN_LNUM_ELE], rax  ;   dst = g_src + s_src + carry |  mov  :  no flags affected
    mov  rax, [rdx + r11 + 1 * LEN_LNUM_ELE]  ;   g_src                       |  mov  :  no flags affected
    adc  rax, [ r9 + r11 + 1 * LEN_LNUM_ELE]  ;   g_src + s_src + carry       |  adc  :  CF is set regarding the carry value (OK: wished behaviour)
    mov  [r10 + r11 + 1 * LEN_LNUM_ELE], rax  ;   dst = g_src + s_src + carry |  mov  :  no flags affected
    mov  rax, [rdx + r11 + 2 * LEN_LNUM_ELE]  ;   g_src                       |  mov  :  no flags affected
    adc  rax, [ r9 + r11 + 2 * LEN_LNUM_ELE]  ;   g_src + s_src + carry       |  adc  :  CF is set regarding the carry value (OK: wished behaviour)
    mov  [r10 + r11 + 2 * LEN_LNUM_ELE], rax  ;   dst = g_src + s_src + carry |  mov  :  no flags affected
    mov  rax, [rdx + r11 + 3 * LEN_LNUM_ELE]  ;   g_src                       |  mov  :  no flags affected
    adc  rax, [ r9 + r11 + 3 * LEN_LNUM_ELE]  ;   g_src + s_src + carry       |  adc  :  CF is set regarding the carry value (OK: wished behaviour)
    mov  [r10 + r11 + 3 * LEN_LNUM_ELE], rax  ;   dst = g_src + s_src + carry |  mov  :  no flags affected
    mov  rax, [rdx + r11 + 4 * LEN_LNUM_ELE]  ;   g_src                       |  mov  :  no flags affected
    adc  rax, [ r9 + r11 + 4 * LEN_LNUM_ELE]  ;   g_src + s_src + carry       |  adc  :  CF is set regarding the carry value (OK: wished behaviour)
    mov  [r10 + r11 + 4 * LEN_LNUM_ELE], rax  ;   dst = g_src + s_src + carry |  mov  :  no flags affected
    mov  rax, [rdx + r11 + 5 * LEN_LNUM_ELE]  ;   g_src                       |  mov  :  no flags affected
    adc  rax, [ r9 + r11 + 5 * LEN_LNUM_ELE]  ;   g_src + s_src + carry       |  adc  :  CF is set regarding the carry value (OK: wished behaviour)
    mov  [r10 + r11 + 5 * LEN_LNUM_ELE], rax  ;   dst = g_src + s_src + carry |  mov  :  no flags affected
    mov  rax, [rdx + r11 + 6 * LEN_LNUM_ELE]  ;   g_src                       |  mov  :  no flags affected
    adc  rax, [ r9 + r11 + 6 * LEN_LNUM_ELE]  ;   g_src + s_src + carry       |  adc  :  CF is set regarding the carry value (OK: wished behaviour)
    mov  [r10 + r11 + 6 * LEN_LNUM_ELE], rax  ;   dst = g_src + s_src + carry |  mov  :  no flags affected
    mov  rax, [rdx + r11 + 7 * LEN_LNUM_ELE]  ;   g_src                       |  mov  :  no flags affected
    adc  rax, [ r9 + r11 + 7 * LEN_LNUM_ELE]  ;   g_src + s_src + carry       |  adc  :  CF is set regarding the carry value (OK: wished behaviour)
    mov  [r10 + r11 + 7 * LEN_LNUM_ELE], rax  ;   dst = g_src + s_src + carry |  mov  :  no flags affected
    mov  rax, [rdx + r11 + 8 * LEN_LNUM_ELE]  ;   g_src                       |  mov  :  no flags affected
    adc  rax, [ r9 + r11 + 8 * LEN_LNUM_ELE]  ;   g_src + s_src + carry       |  adc  :  CF is set regarding the carry value (OK: wished behaviour)
    mov  [r10 + r11 + 8 * LEN_LNUM_ELE], rax  ;   dst = g_src + s_src + carry |  mov  :  no flags affected
    mov  rax, [rdx + r11 + 9 * LEN_LNUM_ELE]  ;   g_src                       |  mov  :  no flags affected
    adc  rax, [ r9 + r11 + 9 * LEN_LNUM_ELE]  ;   g_src + s_src + carry       |  adc  :  CF is set regarding the carry value (OK: wished behaviour)
    mov  [r10 + r11 + 9 * LEN_LNUM_ELE], rax  ;   dst = g_src + s_src + carry |  mov  :  no flags affected
    mov  rax, [rdx + r11 + 10 * LEN_LNUM_ELE]  ;   g_src                       |  mov  :  no flags affected
    adc  rax, [ r9 + r11 + 10 * LEN_LNUM_ELE]  ;   g_src + s_src + carry       |  adc  :  CF is set regarding the carry value (OK: wished behaviour)
    mov  [r10 + r11 + 10 * LEN_LNUM_ELE], rax  ;   dst = g_src + s_src + carry |  mov  :  no flags affected
    mov  rax, [rdx + r11 + 11 * LEN_LNUM_ELE]  ;   g_src                       |  mov  :  no flags affected
    adc  rax, [ r9 + r11 + 11 * LEN_LNUM_ELE]  ;   g_src + s_src + carry       |  adc  :  CF is set regarding the carry value (OK: wished behaviour)
    mov  [r10 + r11 + 11 * LEN_LNUM_ELE], rax  ;   dst = g_src + s_src + carry |  mov  :  no flags affected
    mov  rax, [rdx + r11 + 12 * LEN_LNUM_ELE]  ;   g_src                       |  mov  :  no flags affected
    adc  rax, [ r9 + r11 + 12 * LEN_LNUM_ELE]  ;   g_src + s_src + carry       |  adc  :  CF is set regarding the carry value (OK: wished behaviour)
    mov  [r10 + r11 + 12 * LEN_LNUM_ELE], rax  ;   dst = g_src + s_src + carry |  mov  :  no flags affected
    mov  rax, [rdx + r11 + 13 * LEN_LNUM_ELE]  ;   g_src                       |  mov  :  no flags affected
    adc  rax, [ r9 + r11 + 13 * LEN_LNUM_ELE]  ;   g_src + s_src + carry       |  adc  :  CF is set regarding the carry value (OK: wished behaviour)
    mov  [r10 + r11 + 13 * LEN_LNUM_ELE], rax  ;   dst = g_src + s_src + carry |  mov  :  no flags affected
    mov  rax, [rdx + r11 + 14 * LEN_LNUM_ELE]  ;   g_src                       |  mov  :  no flags affected
    adc  rax, [ r9 + r11 + 14 * LEN_LNUM_ELE]  ;   g_src + s_src + carry       |  adc  :  CF is set regarding the carry value (OK: wished behaviour)
    mov  [r10 + r11 + 14 * LEN_LNUM_ELE], rax  ;   dst = g_src + s_src + carry |  mov  :  no flags affected
    mov  rax, [rdx + r11 + 15 * LEN_LNUM_ELE]  ;   g_src                       |  mov  :  no flags affected
    adc  rax, [ r9 + r11 + 15 * LEN_LNUM_ELE]  ;   g_src + s_src + carry       |  adc  :  CF is set regarding the carry value (OK: wished behaviour)
    mov  [r10 + r11 + 15 * LEN_LNUM_ELE], rax  ;   dst = g_src + s_src + carry |  mov  :  no flags affected
    mov  rax, [rdx + r11 + 16 * LEN_LNUM_ELE]  ;   g_src                       |  mov  :  no flags affected
    adc  rax, [ r9 + r11 + 16 * LEN_LNUM_ELE]  ;   g_src + s_src + carry       |  adc  :  CF is set regarding the carry value (OK: wished behaviour)
    mov  [r10 + r11 + 16 * LEN_LNUM_ELE], rax  ;   dst = g_src + s_src + carry |  mov  :  no flags affected
    mov  rax, [rdx + r11 + 17 * LEN_LNUM_ELE]  ;   g_src                       |  mov  :  no flags affected
    adc  rax, [ r9 + r11 + 17 * LEN_LNUM_ELE]  ;   g_src + s_src + carry       |  adc  :  CF is set regarding the carry value (OK: wished behaviour)
    mov  [r10 + r11 + 17 * LEN_LNUM_ELE], rax  ;   dst = g_src + s_src + carry |  mov  :  no flags affected
    mov  rax, [rdx + r11 + 18 * LEN_LNUM_ELE]  ;   g_src                       |  mov  :  no flags affected
    adc  rax, [ r9 + r11 + 18 * LEN_LNUM_ELE]  ;   g_src + s_src + carry       |  adc  :  CF is set regarding the carry value (OK: wished behaviour)
    mov  [r10 + r11 + 18 * LEN_LNUM_ELE], rax  ;   dst = g_src + s_src + carry |  mov  :  no flags affected
    mov  rax, [rdx + r11 + 19 * LEN_LNUM_ELE]  ;   g_src                       |  mov  :  no flags affected
    adc  rax, [ r9 + r11 + 19 * LEN_LNUM_ELE]  ;   g_src + s_src + carry       |  adc  :  CF is set regarding the carry value (OK: wished behaviour)
    mov  [r10 + r11 + 19 * LEN_LNUM_ELE], rax  ;   dst = g_src + s_src + carry |  mov  :  no flags affected
    mov  rax, [rdx + r11 + 20 * LEN_LNUM_ELE]  ;   g_src                       |  mov  :  no flags affected
    adc  rax, [ r9 + r11 + 20 * LEN_LNUM_ELE]  ;   g_src + s_src + carry       |  adc  :  CF is set regarding the carry value (OK: wished behaviour)
    mov  [r10 + r11 + 20 * LEN_LNUM_ELE], rax  ;   dst = g_src + s_src + carry |  mov  :  no flags affected
    mov  rax, [rdx + r11 + 21 * LEN_LNUM_ELE]  ;   g_src                       |  mov  :  no flags affected
    adc  rax, [ r9 + r11 + 21 * LEN_LNUM_ELE]  ;   g_src + s_src + carry       |  adc  :  CF is set regarding the carry value (OK: wished behaviour)
    mov  [r10 + r11 + 21 * LEN_LNUM_ELE], rax  ;   dst = g_src + s_src + carry |  mov  :  no flags affected
    mov  rax, [rdx + r11 + 22 * LEN_LNUM_ELE]  ;   g_src                       |  mov  :  no flags affected
    adc  rax, [ r9 + r11 + 22 * LEN_LNUM_ELE]  ;   g_src + s_src + carry       |  adc  :  CF is set regarding the carry value (OK: wished behaviour)
    mov  [r10 + r11 + 22 * LEN_LNUM_ELE], rax  ;   dst = g_src + s_src + carry |  mov  :  no flags affected
    mov  rax, [rdx + r11 + 23 * LEN_LNUM_ELE]  ;   g_src                       |  mov  :  no flags affected
    adc  rax, [ r9 + r11 + 23 * LEN_LNUM_ELE]  ;   g_src + s_src + carry       |  adc  :  CF is set regarding the carry value (OK: wished behaviour)
    mov  [r10 + r11 + 23 * LEN_LNUM_ELE], rax  ;   dst = g_src + s_src + carry |  mov  :  no flags affected
    mov  rax, [rdx + r11 + 24 * LEN_LNUM_ELE]  ;   g_src                       |  mov  :  no flags affected
    adc  rax, [ r9 + r11 + 24 * LEN_LNUM_ELE]  ;   g_src + s_src + carry       |  adc  :  CF is set regarding the carry value (OK: wished behaviour)
    mov  [r10 + r11 + 24 * LEN_LNUM_ELE], rax  ;   dst = g_src + s_src + carry |  mov  :  no flags affected
    mov  rax, [rdx + r11 + 25 * LEN_LNUM_ELE]  ;   g_src                       |  mov  :  no flags affected
    adc  rax, [ r9 + r11 + 25 * LEN_LNUM_ELE]  ;   g_src + s_src + carry       |  adc  :  CF is set regarding the carry value (OK: wished behaviour)
    mov  [r10 + r11 + 25 * LEN_LNUM_ELE], rax  ;   dst = g_src + s_src + carry |  mov  :  no flags affected
    mov  rax, [rdx + r11 + 26 * LEN_LNUM_ELE]  ;   g_src                       |  mov  :  no flags affected
    adc  rax, [ r9 + r11 + 26 * LEN_LNUM_ELE]  ;   g_src + s_src + carry       |  adc  :  CF is set regarding the carry value (OK: wished behaviour)
    mov  [r10 + r11 + 26 * LEN_LNUM_ELE], rax  ;   dst = g_src + s_src + carry |  mov  :  no flags affected
    mov  rax, [rdx + r11 + 27 * LEN_LNUM_ELE]  ;   g_src                       |  mov  :  no flags affected
    adc  rax, [ r9 + r11 + 27 * LEN_LNUM_ELE]  ;   g_src + s_src + carry       |  adc  :  CF is set regarding the carry value (OK: wished behaviour)
    mov  [r10 + r11 + 27 * LEN_LNUM_ELE], rax  ;   dst = g_src + s_src + carry |  mov  :  no flags affected
    mov  rax, [rdx + r11 + 28 * LEN_LNUM_ELE]  ;   g_src                       |  mov  :  no flags affected
    adc  rax, [ r9 + r11 + 28 * LEN_LNUM_ELE]  ;   g_src + s_src + carry       |  adc  :  CF is set regarding the carry value (OK: wished behaviour)
    mov  [r10 + r11 + 28 * LEN_LNUM_ELE], rax  ;   dst = g_src + s_src + carry |  mov  :  no flags affected
    mov  rax, [rdx + r11 + 29 * LEN_LNUM_ELE]  ;   g_src                       |  mov  :  no flags affected
    adc  rax, [ r9 + r11 + 29 * LEN_LNUM_ELE]  ;   g_src + s_src + carry       |  adc  :  CF is set regarding the carry value (OK: wished behaviour)
    mov  [r10 + r11 + 29 * LEN_LNUM_ELE], rax  ;   dst = g_src + s_src + carry |  mov  :  no flags affected
    mov  rax, [rdx + r11 + 30 * LEN_LNUM_ELE]  ;   g_src                       |  mov  :  no flags affected
    adc  rax, [ r9 + r11 + 30 * LEN_LNUM_ELE]  ;   g_src + s_src + carry       |  adc  :  CF is set regarding the carry value (OK: wished behaviour)
    mov  [r10 + r11 + 30 * LEN_LNUM_ELE], rax  ;   dst = g_src + s_src + carry |  mov  :  no flags affected
    mov  rax, [rdx + r11 + 31 * LEN_LNUM_ELE]  ;   g_src                       |  mov  :  no flags affected
    adc  rax, [ r9 + r11 + 31 * LEN_LNUM_ELE]  ;   g_src + s_src + carry       |  adc  :  CF is set regarding the carry value (OK: wished behaviour)
    mov  [r10 + r11 + 31 * LEN_LNUM_ELE], rax  ;   dst = g_src + s_src + carry |  mov  :  no flags affected

    lahf                                            ;   save carry flag

    lea  r11, [r11 + 32 * LEN_LNUM_ELE]             ;   increase pointer offset
    sub  rcx, 32                                    ;   subtract the processed words
    jge  add_unroll_loop_32                         ;   keep up the loop, until there are not enough words left

add_unroll_32_end:

;    --------------------------------------------------------
;   |                    REGISTER STATUS                     |
;   |  dst   :  R10       temporary:                    RAX  |
;   |  g_src :  RDX       word for addition - 32 :      RCX  |
;   |  s_src :  R9        words for carry propagation : R8   |
;   |  offset : R11                                          |
;    --------------------------------------------------------
    add  rcx, (32-8)                                ;   we subtracted one additional 32 word block, so restore that part, minus 8 words
                                                    ;   the same loop construct will be used for the 8 word unroll
    jnc  add_unroll_8_end                           ;   the add didn't cause a carry. This signals, that there are less, than 8 words, so we skip that loop

align 16
add_unroll_loop_8:

    sahf                                            ;   Restore carry flag

    mov  rax, [rdx + r11 + 0 * LEN_LNUM_ELE]  ;   g_src                       |  mov  :  no flags affected
    adc  rax, [ r9 + r11 + 0 * LEN_LNUM_ELE]  ;   g_src + s_src + carry       |  adc  :  CF is set regarding the carry value (OK: wished behaviour)
    mov  [r10 + r11 + 0 * LEN_LNUM_ELE], rax  ;   dst = g_src + s_src + carry |  mov  :  no flags affected
    mov  rax, [rdx + r11 + 1 * LEN_LNUM_ELE]  ;   g_src                       |  mov  :  no flags affected
    adc  rax, [ r9 + r11 + 1 * LEN_LNUM_ELE]  ;   g_src + s_src + carry       |  adc  :  CF is set regarding the carry value (OK: wished behaviour)
    mov  [r10 + r11 + 1 * LEN_LNUM_ELE], rax  ;   dst = g_src + s_src + carry |  mov  :  no flags affected
    mov  rax, [rdx + r11 + 2 * LEN_LNUM_ELE]  ;   g_src                       |  mov  :  no flags affected
    adc  rax, [ r9 + r11 + 2 * LEN_LNUM_ELE]  ;   g_src + s_src + carry       |  adc  :  CF is set regarding the carry value (OK: wished behaviour)
    mov  [r10 + r11 + 2 * LEN_LNUM_ELE], rax  ;   dst = g_src + s_src + carry |  mov  :  no flags affected
    mov  rax, [rdx + r11 + 3 * LEN_LNUM_ELE]  ;   g_src                       |  mov  :  no flags affected
    adc  rax, [ r9 + r11 + 3 * LEN_LNUM_ELE]  ;   g_src + s_src + carry       |  adc  :  CF is set regarding the carry value (OK: wished behaviour)
    mov  [r10 + r11 + 3 * LEN_LNUM_ELE], rax  ;   dst = g_src + s_src + carry |  mov  :  no flags affected
    mov  rax, [rdx + r11 + 4 * LEN_LNUM_ELE]  ;   g_src                       |  mov  :  no flags affected
    adc  rax, [ r9 + r11 + 4 * LEN_LNUM_ELE]  ;   g_src + s_src + carry       |  adc  :  CF is set regarding the carry value (OK: wished behaviour)
    mov  [r10 + r11 + 4 * LEN_LNUM_ELE], rax  ;   dst = g_src + s_src + carry |  mov  :  no flags affected
    mov  rax, [rdx + r11 + 5 * LEN_LNUM_ELE]  ;   g_src                       |  mov  :  no flags affected
    adc  rax, [ r9 + r11 + 5 * LEN_LNUM_ELE]  ;   g_src + s_src + carry       |  adc  :  CF is set regarding the carry value (OK: wished behaviour)
    mov  [r10 + r11 + 5 * LEN_LNUM_ELE], rax  ;   dst = g_src + s_src + carry |  mov  :  no flags affected
    mov  rax, [rdx + r11 + 6 * LEN_LNUM_ELE]  ;   g_src                       |  mov  :  no flags affected
    adc  rax, [ r9 + r11 + 6 * LEN_LNUM_ELE]  ;   g_src + s_src + carry       |  adc  :  CF is set regarding the carry value (OK: wished behaviour)
    mov  [r10 + r11 + 6 * LEN_LNUM_ELE], rax  ;   dst = g_src + s_src + carry |  mov  :  no flags affected
    mov  rax, [rdx + r11 + 7 * LEN_LNUM_ELE]  ;   g_src                       |  mov  :  no flags affected
    adc  rax, [ r9 + r11 + 7 * LEN_LNUM_ELE]  ;   g_src + s_src + carry       |  adc  :  CF is set regarding the carry value (OK: wished behaviour)
    mov  [r10 + r11 + 7 * LEN_LNUM_ELE], rax  ;   dst = g_src + s_src + carry |  mov  :  no flags affected

    lahf                                            ;   save carry flag

    lea  r11, [r11 + 8 * LEN_LNUM_ELE]             ;   increase pointer offset
    sub  rcx, 8                                    ;   subtract the processed words
    jge  add_unroll_loop_8                         ;   keep up the loop, until there are not enough words left

add_unroll_8_end:
;    --------------------------------------------------------
;   |                    REGISTER STATUS                     |
;   |  dst   :  R10       temporary:                    RAX  |
;   |  g_src :  RDX       word for addition - 8 :       RCX  |
;   |  s_src :  R9        words for carry propagation : R8   |
;   |  offset : R11                                          |
;    --------------------------------------------------------
    add  rcx, 8                             ;   Add back the missing 8 words from the count

    sahf                                    ;   load carry flag
    jrcxz add_single_loop_end               ;   If no words for addition are left, jump to carry propagation

align 16
add_single_loop:
    mov  rax, [ rdx + r11 ]                 ;   g_src                       |  mov  :  no flags affected
    adc  rax, [  r9 + r11 ]                 ;   g_src + s_src + carry       |  adc  :  CF is set regarding the carry value (OK: wished behaviour)
    mov  [ r10 + r11 ], rax                 ;   dst = g_src + s_src + carry |  mov  :  no flags affected
    lea  r11, [ r11 + LEN_LNUM_ELE ]        ;   increment offset            |  lea  :  no flags affected
    loop add_single_loop                    ;                               |  loop :  no flags affected

add_single_loop_end:
    mov  rcx, r8                            ;   load the number of word, that need carry propagation
                                            ;   this means the words, that the larger input is longer, than the shorter
;    --------------------------------------------------------
;   |                    REGISTER STATUS                     |
;   |  dst   :  R10       temporary:                    RAX  |
;   |  g_src :  RDX       words for carry propagation : RCX  |
;   |  s_src :  R9        offset :                      R11  |
;    --------------------------------------------------------
    jrcxz add_carry_end                     ;   if both inputs were same size, jump the carry of the extra word

align 16
add_propagate_carry:
    mov  rax, [ rdx + r11 ]                 ;   g_src                       |  mov  :  no flags affected
    adc  rax, 0                             ;   g_src + cf                  |  adc  :  CF is set regarding the carry value (OK: wished behaviour)
    mov  [ r10 + r11 ], rax                 ;   dst = g_src + s_src + carry |  mov  :  no flags affected
    lea  r11, [ r11 + LEN_LNUM_ELE ]        ;   increment offset            |  lea  :  no flags affected
    loop add_propagate_carry                ;                               |  loop :  no flags affected

add_carry_end:
    jnc  add_epilogue                       ;   if no additional carry is there, go to the end
    mov  rax, 1                             ;   Load the carry out to RAX
    mov  [ r10 + r11 ], rax                 ;   Write the carry to the last destination word
    lea  r11, [ r11 + LEN_LNUM_ELE ]        ;   Increment the offset once more to get the total of bytes in the result

;----------------------------------------------------------------
add_epilogue:
    mov  rax, r11                           ;   Load bytes total into the RAX
    ret                                     ;   return
;----------------------------------------------------------------
m_impl_add endp


;       extern "C" int m_impl_sub(LNUM_WORD* ap_dest,
;                                 LNUM_WORD* ap_a,
;                                 unsigned int szp_a_len,
;                                 LNUM_WORD* ap_b,
;                                 unsigned int szp_b_len);

m_impl_sub proc
;-----------------------------------------------------------------------------------------;
;  Calling convention: Microsoft x64                                                      ;
;-----------------------------------------------------------------------------------------;
;           scratch (volatile) registers:   RAX, RCX, RDX, R8, R9, R10, R11               ;
;   callee-save (non-volatile) registers:   RBX, RBP, RDI, RSI, RSP, R12, R13, R14, R15   ;
;                    parameter registers:   RCX, RDX, R8, R9                              ;
;-----------------------------------------------------------------------------------------;
;    ---------------------------------------
;   |            REGISTER STATUS            |
;   |  dst  : RCX                           |
;   |  src1 : RDX         src1_len : R8     |
;   |  src2 : R9          src2_len : stack  |
;    ---------------------------------------
    mov  r10, rcx                       ;   destination to R10, freeing RCX
    mov  ecx, [rsp+028H]                ;   RCX = src2_len (accesing position of the 5th parameter).
                                        ;       0x28 bytes = 0x20 shadow space + 8 return address

;    ---------------------------------------
;   |            REGISTER STATUS            |
;   |  dst  : R10                           |
;   |  min  : RDX          min_len : R8     |
;   |  sub  : R9           sub_len : RCX    |
;    ---------------------------------------
    sub  r8, rcx                        ;   Calculate, how many additional words the longer parameter has over the shorter
    xor  r11, r11                       ;   Clear R11 for use as address offset for the source and dest pointers

;    --------------------------------------------------------
;   |                    REGISTER STATUS                     |
;   |  dst    : R10       temporary:                    RAX  |
;   |  min    : RDX       word for addition :           RCX  |
;   |  sub    : R9        words for borrow propagation : R8  |
;   |  offset : R11                                          |
;    --------------------------------------------------------
    shr  r8, 3                          ;   Scale length parameters from bytes to (64-bit) words
    shr  rcx, 3
    xor  rax,rax                        ;   Clear RAX. AH will be used to store the flags to keep CF between loop runs, so this will effectively clear the CF.
    sub  rcx, 32                        ;   This checks, if at least 32 words are available and prepares the 32 word loop.
                                        ;   sub is used over cmp for the following reason:
                                        ;       At the end of the unrolled loop, 32 will be subtracted again from RCX.
                                        ;       By subtracting an additional block here, this will underflow, when there is less, than 32 words left, signaling the end of the loop.
    jl   sub_unroll_32_end              ;   Jump beyond the loop, if less than 32 words are available for addition

align 16
sub_unroll_loop_32:

    sahf                                            ;   Restore carry flag

    mov  rax, [rdx + r11 + 0 * LEN_LNUM_ELE]  ;   min                      |  mov  :  no flags affected
    sbb  rax, [ r9 + r11 + 0 * LEN_LNUM_ELE]  ;   min - sub - borrow       |  sbb  :  CF is set regarding the borrow value (OK: wished behaviour)
    mov  [r10 + r11 + 0 * LEN_LNUM_ELE], rax  ;   dst = min - sub - borrow |  mov  :  no flags affected
    mov  rax, [rdx + r11 + 1 * LEN_LNUM_ELE]  ;   min                      |  mov  :  no flags affected
    sbb  rax, [ r9 + r11 + 1 * LEN_LNUM_ELE]  ;   min - sub - borrow       |  sbb  :  CF is set regarding the borrow value (OK: wished behaviour)
    mov  [r10 + r11 + 1 * LEN_LNUM_ELE], rax  ;   dst = min - sub - borrow |  mov  :  no flags affected
    mov  rax, [rdx + r11 + 2 * LEN_LNUM_ELE]  ;   min                      |  mov  :  no flags affected
    sbb  rax, [ r9 + r11 + 2 * LEN_LNUM_ELE]  ;   min - sub - borrow       |  sbb  :  CF is set regarding the borrow value (OK: wished behaviour)
    mov  [r10 + r11 + 2 * LEN_LNUM_ELE], rax  ;   dst = min - sub - borrow |  mov  :  no flags affected
    mov  rax, [rdx + r11 + 3 * LEN_LNUM_ELE]  ;   min                      |  mov  :  no flags affected
    sbb  rax, [ r9 + r11 + 3 * LEN_LNUM_ELE]  ;   min - sub - borrow       |  sbb  :  CF is set regarding the borrow value (OK: wished behaviour)
    mov  [r10 + r11 + 3 * LEN_LNUM_ELE], rax  ;   dst = min - sub - borrow |  mov  :  no flags affected
    mov  rax, [rdx + r11 + 4 * LEN_LNUM_ELE]  ;   min                      |  mov  :  no flags affected
    sbb  rax, [ r9 + r11 + 4 * LEN_LNUM_ELE]  ;   min - sub - borrow       |  sbb  :  CF is set regarding the borrow value (OK: wished behaviour)
    mov  [r10 + r11 + 4 * LEN_LNUM_ELE], rax  ;   dst = min - sub - borrow |  mov  :  no flags affected
    mov  rax, [rdx + r11 + 5 * LEN_LNUM_ELE]  ;   min                      |  mov  :  no flags affected
    sbb  rax, [ r9 + r11 + 5 * LEN_LNUM_ELE]  ;   min - sub - borrow       |  sbb  :  CF is set regarding the borrow value (OK: wished behaviour)
    mov  [r10 + r11 + 5 * LEN_LNUM_ELE], rax  ;   dst = min - sub - borrow |  mov  :  no flags affected
    mov  rax, [rdx + r11 + 6 * LEN_LNUM_ELE]  ;   min                      |  mov  :  no flags affected
    sbb  rax, [ r9 + r11 + 6 * LEN_LNUM_ELE]  ;   min - sub - borrow       |  sbb  :  CF is set regarding the borrow value (OK: wished behaviour)
    mov  [r10 + r11 + 6 * LEN_LNUM_ELE], rax  ;   dst = min - sub - borrow |  mov  :  no flags affected
    mov  rax, [rdx + r11 + 7 * LEN_LNUM_ELE]  ;   min                      |  mov  :  no flags affected
    sbb  rax, [ r9 + r11 + 7 * LEN_LNUM_ELE]  ;   min - sub - borrow       |  sbb  :  CF is set regarding the borrow value (OK: wished behaviour)
    mov  [r10 + r11 + 7 * LEN_LNUM_ELE], rax  ;   dst = min - sub - borrow |  mov  :  no flags affected
    mov  rax, [rdx + r11 + 8 * LEN_LNUM_ELE]  ;   min                      |  mov  :  no flags affected
    sbb  rax, [ r9 + r11 + 8 * LEN_LNUM_ELE]  ;   min - sub - borrow       |  sbb  :  CF is set regarding the borrow value (OK: wished behaviour)
    mov  [r10 + r11 + 8 * LEN_LNUM_ELE], rax  ;   dst = min - sub - borrow |  mov  :  no flags affected
    mov  rax, [rdx + r11 + 9 * LEN_LNUM_ELE]  ;   min                      |  mov  :  no flags affected
    sbb  rax, [ r9 + r11 + 9 * LEN_LNUM_ELE]  ;   min - sub - borrow       |  sbb  :  CF is set regarding the borrow value (OK: wished behaviour)
    mov  [r10 + r11 + 9 * LEN_LNUM_ELE], rax  ;   dst = min - sub - borrow |  mov  :  no flags affected
    mov  rax, [rdx + r11 + 10 * LEN_LNUM_ELE]  ;   min                      |  mov  :  no flags affected
    sbb  rax, [ r9 + r11 + 10 * LEN_LNUM_ELE]  ;   min - sub - borrow       |  sbb  :  CF is set regarding the borrow value (OK: wished behaviour)
    mov  [r10 + r11 + 10 * LEN_LNUM_ELE], rax  ;   dst = min - sub - borrow |  mov  :  no flags affected
    mov  rax, [rdx + r11 + 11 * LEN_LNUM_ELE]  ;   min                      |  mov  :  no flags affected
    sbb  rax, [ r9 + r11 + 11 * LEN_LNUM_ELE]  ;   min - sub - borrow       |  sbb  :  CF is set regarding the borrow value (OK: wished behaviour)
    mov  [r10 + r11 + 11 * LEN_LNUM_ELE], rax  ;   dst = min - sub - borrow |  mov  :  no flags affected
    mov  rax, [rdx + r11 + 12 * LEN_LNUM_ELE]  ;   min                      |  mov  :  no flags affected
    sbb  rax, [ r9 + r11 + 12 * LEN_LNUM_ELE]  ;   min - sub - borrow       |  sbb  :  CF is set regarding the borrow value (OK: wished behaviour)
    mov  [r10 + r11 + 12 * LEN_LNUM_ELE], rax  ;   dst = min - sub - borrow |  mov  :  no flags affected
    mov  rax, [rdx + r11 + 13 * LEN_LNUM_ELE]  ;   min                      |  mov  :  no flags affected
    sbb  rax, [ r9 + r11 + 13 * LEN_LNUM_ELE]  ;   min - sub - borrow       |  sbb  :  CF is set regarding the borrow value (OK: wished behaviour)
    mov  [r10 + r11 + 13 * LEN_LNUM_ELE], rax  ;   dst = min - sub - borrow |  mov  :  no flags affected
    mov  rax, [rdx + r11 + 14 * LEN_LNUM_ELE]  ;   min                      |  mov  :  no flags affected
    sbb  rax, [ r9 + r11 + 14 * LEN_LNUM_ELE]  ;   min - sub - borrow       |  sbb  :  CF is set regarding the borrow value (OK: wished behaviour)
    mov  [r10 + r11 + 14 * LEN_LNUM_ELE], rax  ;   dst = min - sub - borrow |  mov  :  no flags affected
    mov  rax, [rdx + r11 + 15 * LEN_LNUM_ELE]  ;   min                      |  mov  :  no flags affected
    sbb  rax, [ r9 + r11 + 15 * LEN_LNUM_ELE]  ;   min - sub - borrow       |  sbb  :  CF is set regarding the borrow value (OK: wished behaviour)
    mov  [r10 + r11 + 15 * LEN_LNUM_ELE], rax  ;   dst = min - sub - borrow |  mov  :  no flags affected
    mov  rax, [rdx + r11 + 16 * LEN_LNUM_ELE]  ;   min                      |  mov  :  no flags affected
    sbb  rax, [ r9 + r11 + 16 * LEN_LNUM_ELE]  ;   min - sub - borrow       |  sbb  :  CF is set regarding the borrow value (OK: wished behaviour)
    mov  [r10 + r11 + 16 * LEN_LNUM_ELE], rax  ;   dst = min - sub - borrow |  mov  :  no flags affected
    mov  rax, [rdx + r11 + 17 * LEN_LNUM_ELE]  ;   min                      |  mov  :  no flags affected
    sbb  rax, [ r9 + r11 + 17 * LEN_LNUM_ELE]  ;   min - sub - borrow       |  sbb  :  CF is set regarding the borrow value (OK: wished behaviour)
    mov  [r10 + r11 + 17 * LEN_LNUM_ELE], rax  ;   dst = min - sub - borrow |  mov  :  no flags affected
    mov  rax, [rdx + r11 + 18 * LEN_LNUM_ELE]  ;   min                      |  mov  :  no flags affected
    sbb  rax, [ r9 + r11 + 18 * LEN_LNUM_ELE]  ;   min - sub - borrow       |  sbb  :  CF is set regarding the borrow value (OK: wished behaviour)
    mov  [r10 + r11 + 18 * LEN_LNUM_ELE], rax  ;   dst = min - sub - borrow |  mov  :  no flags affected
    mov  rax, [rdx + r11 + 19 * LEN_LNUM_ELE]  ;   min                      |  mov  :  no flags affected
    sbb  rax, [ r9 + r11 + 19 * LEN_LNUM_ELE]  ;   min - sub - borrow       |  sbb  :  CF is set regarding the borrow value (OK: wished behaviour)
    mov  [r10 + r11 + 19 * LEN_LNUM_ELE], rax  ;   dst = min - sub - borrow |  mov  :  no flags affected
    mov  rax, [rdx + r11 + 20 * LEN_LNUM_ELE]  ;   min                      |  mov  :  no flags affected
    sbb  rax, [ r9 + r11 + 20 * LEN_LNUM_ELE]  ;   min - sub - borrow       |  sbb  :  CF is set regarding the borrow value (OK: wished behaviour)
    mov  [r10 + r11 + 20 * LEN_LNUM_ELE], rax  ;   dst = min - sub - borrow |  mov  :  no flags affected
    mov  rax, [rdx + r11 + 21 * LEN_LNUM_ELE]  ;   min                      |  mov  :  no flags affected
    sbb  rax, [ r9 + r11 + 21 * LEN_LNUM_ELE]  ;   min - sub - borrow       |  sbb  :  CF is set regarding the borrow value (OK: wished behaviour)
    mov  [r10 + r11 + 21 * LEN_LNUM_ELE], rax  ;   dst = min - sub - borrow |  mov  :  no flags affected
    mov  rax, [rdx + r11 + 22 * LEN_LNUM_ELE]  ;   min                      |  mov  :  no flags affected
    sbb  rax, [ r9 + r11 + 22 * LEN_LNUM_ELE]  ;   min - sub - borrow       |  sbb  :  CF is set regarding the borrow value (OK: wished behaviour)
    mov  [r10 + r11 + 22 * LEN_LNUM_ELE], rax  ;   dst = min - sub - borrow |  mov  :  no flags affected
    mov  rax, [rdx + r11 + 23 * LEN_LNUM_ELE]  ;   min                      |  mov  :  no flags affected
    sbb  rax, [ r9 + r11 + 23 * LEN_LNUM_ELE]  ;   min - sub - borrow       |  sbb  :  CF is set regarding the borrow value (OK: wished behaviour)
    mov  [r10 + r11 + 23 * LEN_LNUM_ELE], rax  ;   dst = min - sub - borrow |  mov  :  no flags affected
    mov  rax, [rdx + r11 + 24 * LEN_LNUM_ELE]  ;   min                      |  mov  :  no flags affected
    sbb  rax, [ r9 + r11 + 24 * LEN_LNUM_ELE]  ;   min - sub - borrow       |  sbb  :  CF is set regarding the borrow value (OK: wished behaviour)
    mov  [r10 + r11 + 24 * LEN_LNUM_ELE], rax  ;   dst = min - sub - borrow |  mov  :  no flags affected
    mov  rax, [rdx + r11 + 25 * LEN_LNUM_ELE]  ;   min                      |  mov  :  no flags affected
    sbb  rax, [ r9 + r11 + 25 * LEN_LNUM_ELE]  ;   min - sub - borrow       |  sbb  :  CF is set regarding the borrow value (OK: wished behaviour)
    mov  [r10 + r11 + 25 * LEN_LNUM_ELE], rax  ;   dst = min - sub - borrow |  mov  :  no flags affected
    mov  rax, [rdx + r11 + 26 * LEN_LNUM_ELE]  ;   min                      |  mov  :  no flags affected
    sbb  rax, [ r9 + r11 + 26 * LEN_LNUM_ELE]  ;   min - sub - borrow       |  sbb  :  CF is set regarding the borrow value (OK: wished behaviour)
    mov  [r10 + r11 + 26 * LEN_LNUM_ELE], rax  ;   dst = min - sub - borrow |  mov  :  no flags affected
    mov  rax, [rdx + r11 + 27 * LEN_LNUM_ELE]  ;   min                      |  mov  :  no flags affected
    sbb  rax, [ r9 + r11 + 27 * LEN_LNUM_ELE]  ;   min - sub - borrow       |  sbb  :  CF is set regarding the borrow value (OK: wished behaviour)
    mov  [r10 + r11 + 27 * LEN_LNUM_ELE], rax  ;   dst = min - sub - borrow |  mov  :  no flags affected
    mov  rax, [rdx + r11 + 28 * LEN_LNUM_ELE]  ;   min                      |  mov  :  no flags affected
    sbb  rax, [ r9 + r11 + 28 * LEN_LNUM_ELE]  ;   min - sub - borrow       |  sbb  :  CF is set regarding the borrow value (OK: wished behaviour)
    mov  [r10 + r11 + 28 * LEN_LNUM_ELE], rax  ;   dst = min - sub - borrow |  mov  :  no flags affected
    mov  rax, [rdx + r11 + 29 * LEN_LNUM_ELE]  ;   min                      |  mov  :  no flags affected
    sbb  rax, [ r9 + r11 + 29 * LEN_LNUM_ELE]  ;   min - sub - borrow       |  sbb  :  CF is set regarding the borrow value (OK: wished behaviour)
    mov  [r10 + r11 + 29 * LEN_LNUM_ELE], rax  ;   dst = min - sub - borrow |  mov  :  no flags affected
    mov  rax, [rdx + r11 + 30 * LEN_LNUM_ELE]  ;   min                      |  mov  :  no flags affected
    sbb  rax, [ r9 + r11 + 30 * LEN_LNUM_ELE]  ;   min - sub - borrow       |  sbb  :  CF is set regarding the borrow value (OK: wished behaviour)
    mov  [r10 + r11 + 30 * LEN_LNUM_ELE], rax  ;   dst = min - sub - borrow |  mov  :  no flags affected
    mov  rax, [rdx + r11 + 31 * LEN_LNUM_ELE]  ;   min                      |  mov  :  no flags affected
    sbb  rax, [ r9 + r11 + 31 * LEN_LNUM_ELE]  ;   min - sub - borrow       |  sbb  :  CF is set regarding the borrow value (OK: wished behaviour)
    mov  [r10 + r11 + 31 * LEN_LNUM_ELE], rax  ;   dst = min - sub - borrow |  mov  :  no flags affected

    lahf                                            ;   save carry flag

    lea  r11, [r11 + 32 * LEN_LNUM_ELE]             ;   increase pointer offset
    sub  rcx, 32                                    ;   subtract the processed words
    jge  sub_unroll_loop_32                         ;   keep up the loop, until there are not enough words left

sub_unroll_32_end:

;    --------------------------------------------------------
;   |                    REGISTER STATUS                     |
;   |  dst   :  R10       temporary:                    RAX  |
;   |  min   :  RDX       word for subtraction - 32 :   RCX  |
;   |  sub   :  R9        words for borrow propagation : R8  |
;   |  offset : R11                                          |
;    --------------------------------------------------------
    add  rcx, (32-8)                                ;   we subtracted one additional 32 word block, so restore that part, minus 8 words
                                                    ;   the same loop construct will be used for the 8 word unroll
    jnc  sub_unroll_8_end                           ;   the add didn't cause a carry. This signals, that there are less, than 8 words, so we skip that loop

align 16
sub_unroll_loop_8:

    sahf                                            ;   Restore carry flag

    mov  rax, [rdx + r11 + 0 * LEN_LNUM_ELE]  ;   min                      |  mov  :  no flags affected
    sbb  rax, [ r9 + r11 + 0 * LEN_LNUM_ELE]  ;   min - sub - borrow       |  sbb  :  CF is set regarding the borrow value (OK: wished behaviour)
    mov  [r10 + r11 + 0 * LEN_LNUM_ELE], rax  ;   dst = min - sub - borrow |  mov  :  no flags affected
    mov  rax, [rdx + r11 + 1 * LEN_LNUM_ELE]  ;   min                      |  mov  :  no flags affected
    sbb  rax, [ r9 + r11 + 1 * LEN_LNUM_ELE]  ;   min - sub - borrow       |  sbb  :  CF is set regarding the borrow value (OK: wished behaviour)
    mov  [r10 + r11 + 1 * LEN_LNUM_ELE], rax  ;   dst = min - sub - borrow |  mov  :  no flags affected
    mov  rax, [rdx + r11 + 2 * LEN_LNUM_ELE]  ;   min                      |  mov  :  no flags affected
    sbb  rax, [ r9 + r11 + 2 * LEN_LNUM_ELE]  ;   min - sub - borrow       |  sbb  :  CF is set regarding the borrow value (OK: wished behaviour)
    mov  [r10 + r11 + 2 * LEN_LNUM_ELE], rax  ;   dst = min - sub - borrow |  mov  :  no flags affected
    mov  rax, [rdx + r11 + 3 * LEN_LNUM_ELE]  ;   min                      |  mov  :  no flags affected
    sbb  rax, [ r9 + r11 + 3 * LEN_LNUM_ELE]  ;   min - sub - borrow       |  sbb  :  CF is set regarding the borrow value (OK: wished behaviour)
    mov  [r10 + r11 + 3 * LEN_LNUM_ELE], rax  ;   dst = min - sub - borrow |  mov  :  no flags affected
    mov  rax, [rdx + r11 + 4 * LEN_LNUM_ELE]  ;   min                      |  mov  :  no flags affected
    sbb  rax, [ r9 + r11 + 4 * LEN_LNUM_ELE]  ;   min - sub - borrow       |  sbb  :  CF is set regarding the borrow value (OK: wished behaviour)
    mov  [r10 + r11 + 4 * LEN_LNUM_ELE], rax  ;   dst = min - sub - borrow |  mov  :  no flags affected
    mov  rax, [rdx + r11 + 5 * LEN_LNUM_ELE]  ;   min                      |  mov  :  no flags affected
    sbb  rax, [ r9 + r11 + 5 * LEN_LNUM_ELE]  ;   min - sub - borrow       |  sbb  :  CF is set regarding the borrow value (OK: wished behaviour)
    mov  [r10 + r11 + 5 * LEN_LNUM_ELE], rax  ;   dst = min - sub - borrow |  mov  :  no flags affected
    mov  rax, [rdx + r11 + 6 * LEN_LNUM_ELE]  ;   min                      |  mov  :  no flags affected
    sbb  rax, [ r9 + r11 + 6 * LEN_LNUM_ELE]  ;   min - sub - borrow       |  sbb  :  CF is set regarding the borrow value (OK: wished behaviour)
    mov  [r10 + r11 + 6 * LEN_LNUM_ELE], rax  ;   dst = min - sub - borrow |  mov  :  no flags affected
    mov  rax, [rdx + r11 + 7 * LEN_LNUM_ELE]  ;   min                      |  mov  :  no flags affected
    sbb  rax, [ r9 + r11 + 7 * LEN_LNUM_ELE]  ;   min - sub - borrow       |  sbb  :  CF is set regarding the borrow value (OK: wished behaviour)
    mov  [r10 + r11 + 7 * LEN_LNUM_ELE], rax  ;   dst = min - sub - borrow |  mov  :  no flags affected

    lahf                                            ;   save carry flag

    lea  r11, [r11 + 8 * LEN_LNUM_ELE]             ;   increase pointer offset
    sub  rcx, 8                                    ;   subtract the processed words
    jge  sub_unroll_loop_8                         ;   keep up the loop, until there are not enough words left

sub_unroll_8_end:
;    --------------------------------------------------------
;   |                    REGISTER STATUS                     |
;   |  dst   :  R10       temporary:                    RAX  |
;   |  min   :  RDX       word for addition - 8 :       RCX  |
;   |  sub   :  R9        words for borrow propagation : R8  |
;   |  offset : R11                                          |
;    --------------------------------------------------------
    add  rcx, 8                             ;   Add back the missing 8 words from the count

    sahf                                    ;   load carry flag
    jrcxz sub_single_loop_end               ;   If no words for subtraction are left, jump to borrow propagation

align 16
sub_single_loop:
    mov  rax, [ rdx + r11 ]                 ;   min                      |  mov  :  no flags affected
    sbb  rax, [  r9 + r11 ]                 ;   min - sub - borrow       |  sbb  :  CF is set regarding the borrow value (OK: wished behaviour)
    mov  [ r10 + r11 ], rax                 ;   dst = min - sub - borrow |  mov  :  no flags affected
    lea  r11, [ r11 + LEN_LNUM_ELE ]        ;   increment offset         |  lea  :  no flags affected
    loop sub_single_loop                    ;                            |  loop :  no flags affected

sub_single_loop_end:
    mov  rcx, r8                            ;   load the number of word, that need carry propagation
                                            ;   this means the words, that the larger input is longer, than the shorter
;    --------------------------------------------------------
;   |                    REGISTER STATUS                     |
;   |  dst   :  R10       temporary:                    RAX  |
;   |  min   :  RDX       words for borrow propagation: RCX  |
;   |  sub   :  R9        offset :                      R11  |
;    --------------------------------------------------------
    jrcxz sub_borrow_end                    ;   if both inputs were same size, jump the carry of the extra word

align 16
sub_propagate_borrow:
    mov  rax, [ rdx + r11 ]                 ;   min                       |  mov  :  no flags affected
    sbb  rax, 0                             ;   min - borrow              |  adc  :  CF is set regarding the carry value (OK: wished behaviour)
    mov  [ r10 + r11 ], rax                 ;   dst = min - borrow        |  mov  :  no flags affected
    lea  r11, [ r11 + LEN_LNUM_ELE ]        ;   increment offset          |  lea  :  no flags affected
    loop sub_propagate_borrow               ;                             |  loop :  no flags affected

sub_borrow_end:
    mov  rcx, r11                           ;   R11 is the offset, so it contains the number of written bytes
    jrcxz sub_epilogue                      ;   If no offset was ever generated, just jump to the end

sub_calc_ret_loop:
    mov  rax, [ r10 + rcx - LEN_LNUM_ELE]   ;   load the word BEFORE the current offset
    cmp  rax, 0                             ;   check, if that word is still 0
    jne  sub_epilogue                       ;   if we found the first non-0 word, break the loop
                                            ;   RCX will contain the index of that word + 8, so the total of used bytes.
    sub  rcx, 7                             ;   loop down with decrement of 8
    loop sub_calc_ret_loop                  ;   if RCX reaches 0, that would mean the LSW is 0, so we can also return 0

sub_epilogue:
    mov  rax, rcx                           ;   put the result
    ret                                     ;   return
;----------------------------------------------------------------
m_impl_sub endp


; extern "C" int m_impl_cmp(const LNUM_WORD* ap_a,
;                           const LNUM_WORD* ap_b,
;                           unsigned int szp_b_len);
m_impl_cmp proc
;-----------------------------------------------------------------------------------------;
;  Calling convention: Microsoft x64                                                      ;
;-----------------------------------------------------------------------------------------;
;           scratch (volatile) registers:   RAX, RCX, RDX, R8, R9, R10, R11               ;
;   callee-save (non-volatile) registers:   RBX, RBP, RDI, RSI, RSP, R12, R13, R14, R15   ;
;                    parameter registers:   RCX, RDX, R8, R9                              ;
;-----------------------------------------------------------------------------------------;
;    ---------------------------------------
;   |            REGISTER STATUS            |
;   |  src1 : RCX                           |
;   |  src2 : RDX         src_len : R8      |
;    ---------------------------------------
    mov  r10, rcx                       ;   src1 to R10, freeing RCX
    mov  rcx, r8                        ;   load length to RCX

;    ---------------------------------------
;   |            REGISTER STATUS            |
;   |  src1 : R10                           |
;   |  src2 : RDX         src_len : RCX     |
;    ---------------------------------------

    jrcxz cmp_equal             ;   Length is 0, so the numbers are equal
    shr   rcx, 3                ;   Scale length parameter from bytes to (64-bit) words

    ;   this loop runs over the input from the highest order word to the lowest (i (length-1) to 0)
cmp_impl_loop:
    mov  r9, [ r10 + rcx * LEN_LNUM_ELE - LEN_LNUM_ELE]     ;   load word src1[i]
    cmp  r9, [ rdx + rcx * LEN_LNUM_ELE - LEN_LNUM_ELE]     ;   compare src1[i] with src2[i]
    jb cmp_1_less_than_2                                    ;   if src1[i] < src2[i], stop the loop, src1 is less
    ja cmp_1_greater_than_2                                 ;   if src1[i] > src2[i], stop the loop, src1 is greater
                                                            ;   ja and jb are required here, as they implement the unsigned cmp. jl and jg do not work
    loop cmp_impl_loop                                      ;   decrement RCX and keep looping

cmp_equal:
    mov  eax, 0                                             ;   All words were equal, so both numbers are equal. Set return value to 0.
    ret

cmp_1_less_than_2:
    mov  eax, -1                                            ;   src1 is less, than src2. Set return value to -1.
    ret

cmp_1_greater_than_2:
    mov  eax, 1                                             ;   src1 is greater, than src2. Set return value to 1.
    ret

m_impl_cmp endp



; extern "C" void m_impl_mult_basic(LNUM_WORD* ap_dest,
;                                   const LNUM_WORD* ap_a,
;                                   unsigned int szp_a_len,
;                                   const LNUM_WORD* ap_b,
;                                   unsigned int szp_b_len);
; This implementation is based on Combas Method, also called product scanning
m_impl_mult_basic proc
;-----------------------------------------------------------------------------------------;
;  Calling convention: Microsoft x64                                                      ;
;-----------------------------------------------------------------------------------------;
;           scratch (volatile) registers:   RAX, RCX, RDX, R8, R9, R10, R11               ;
;   callee-save (non-volatile) registers:   RBX, RBP, RDI, RSI, RSP, R12, R13, R14, R15   ;
;                    parameter registers:   RCX, RDX, R8, R9                              ;
;-----------------------------------------------------------------------------------------;
;    ---------------------------------------
;   |            REGISTER STATUS            |
;   |  dst  : RCX                           |
;   |  src1 : RDX         src1_len : R8     |
;   |  src2 : R9          src2_len : stack  |
;    ---------------------------------------
    push  rdi
    push  rsi
    mov   rdi, rcx                      ;   load dst to RDI to match UNIX
    mov   rsi, rdx                      ;   load src1 to RSI to match UNIX
    mov   ecx, [rsp+038H]               ;   R8 = src2_len (accesing position of the 5th parameter).
                                        ;       0x38 bytes = 0x20 shadow space + 8 return address + 2*8 for pushed registers

    push  rbx
    push  rbp
    push  r12
    push  r13
    push  r14
    push  r15
;    ---------------------------------------
;   |            REGISTER STATUS            |
;   |  dst  : RDI                           |
;   |  src1 : RSI         src1_len : R8     |
;   |  src2 : R9          src2_len : RCX    |
;    ---------------------------------------

    cmp   r8,rcx                    ;   Check which input is larger
    jge    mult_basic_start          ;   if src1 is larger, do nothing
    xchg  rsi, r9                   ;   swap src1 and src2
    xchg  r8,rcx                    ;   swap src1_len and src2_len

mult_basic_start:
;    ---------------------------------------
;   |            REGISTER STATUS            |
;   |  dst  : RDI                           |
;   |  src_l: RSI         src_l_len : R8    |
;   |  src_s: R9          src_s_len : RCX   |
;    ---------------------------------------
    shr   r8, 3                         ;   Scale length parameters from bytes to (64-bit) words
    shr   rcx, 3                        
    mov   rax, [rsi]                    ;   RAX = src_l[0];
    mul   QWORD PTR[r9]                 ;   (RDX|RAX) = src_l[0]*src_s[0]
    mov   [rdi], rax                    ;   dst[0] = RAX
    lea   rdi, [ rdi + LEN_LNUM_ELE ]   ;   get next dst pointer
    mov   r11, rdx                      ;   set carry for the loop
    xor   r10, r10                      ;   set carry for the loop
    mov   rbp, 1                        ;   set i_dest = 1
    cmp   rcx, 1                        ;   check if src_s_len is bigger, than 1
    je    mult_basic_middle_loop_setup  ;   src_s_len == 1, skip the first loop
    mov   rbx, LEN_LNUM_ELE             ;   i_src_s = 1

mult_basic_first_loop_outer:
;    ---------------------------------------
;   |            REGISTER STATUS            |
;   |  dst  : RDI         i_dest: RBP       |
;   |  src_l: RSI         src_l_len : R8    |
;   |  src_s: R9          src_s_len : RCX   |
;   |  (t1|t2|t3): R10|R11|R12              |
;   |  i_src_s: RBX                         |
;    ---------------------------------------
    mov   r12, r11                      ;   shift the carry from last round
    mov   r11, r10                      ;   shift the carry from last round
    xor   r10, r10                      ;   shift the carry from last round
    lea   rbx, [ rbx + LEN_LNUM_ELE ]   ;   i_src_s++

mult_basic_first_loop_inner:
    mov   rax, [rsi]                    ;   RAX = src_l[i_src_l];
    lea   rbx, [ rbx - LEN_LNUM_ELE ]   ;   i_src_s--
    mul   QWORD PTR[r9 + rbx]            ;   (RDX|RAX) = src_l[i_src_l]*src_s[i_src_s]
    add   r12,rax                       ;   t3 = t3 + RAX           | can cause carry
    lea   rsi, [ rsi + LEN_LNUM_ELE ]   ;   i_src_l++
    adc   r11,rdx                       ;   t2 = t2 + RDX + carry   | can cause carry
    adc   r10,0                         ;   t1 = t1 + carry         | no carry
    cmp   rbx, 0                        ;   loop untill we reached src_s[0]
    jne   mult_basic_first_loop_inner
    
    inc   rbp                           ;   i_dest++
    mov   [rdi], r12                    ;   dest[i_dest-1] = t3
    lea   rdi, [ rdi + LEN_LNUM_ELE ]   ;   get next dst pointer
    lea   rbx, [ rbp * LEN_LNUM_ELE ]   ;   load new i_src_s
    sub   rsi, rbx                      ;   restore src_l
    cmp   rbp, rcx                      ;   check for further iterations
    jl    mult_basic_first_loop_outer

mult_basic_middle_loop_setup:
    cmp   rcx, r8                       ;   if both inputs are equal, no middle loop is needed
    je    mult_basic_final_loop_setup
    
    lea   rbx, [ rcx * LEN_LNUM_ELE ]   ;   i_src_s = src_s_len
mult_basic_middle_loop_outer:
;    ---------------------------------------
;   |            REGISTER STATUS            |
;   |  dst  : RDI         i_dest: RBP       |
;   |  src_l: RSI         src_l_len : R8    |
;   |  src_s: R9          src_s_len : RCX   |
;   |  (t1|t2|t3): R10|R11|R12              |
;   |  i_src_s: RBX                         |
;    ---------------------------------------
    mov   r12, r11                      ;   shift the carry from last round
    mov   r11, r10                      ;   shift the carry from last round
    xor   r10, r10                      ;   shift the carry from last round
    lea   rsi, [ rsi + LEN_LNUM_ELE ]   ;   i_src_s++
    
mult_basic_middle_loop_inner:
    mov   rax, [rsi]                    ;   RAX = src_l[i_src_l];
    lea   rbx, [ rbx - LEN_LNUM_ELE ]   ;   i_src_s--
    mul   QWORD PTR[r9 + rbx]            ;   (RDX|RAX) = src_l[i_src_l]*src_s[i_src_s]
    add   r12,rax                       ;   t3 = t3 + RAX           | can cause carry
    lea   rsi, [ rsi + LEN_LNUM_ELE ]   ;   i_src_l++
    adc   r11,rdx                       ;   t2 = t2 + RDX + carry   | can cause carry
    adc   r10,0                         ;   t1 = t1 + carry         | no carry
    cmp   rbx, 0                        ;   loop untill we reached src_s[0]
    jne   mult_basic_middle_loop_inner
    
    mov   [rdi], r12                    ;   dst[i_dst] = t3
    lea   rdi, [ rdi + LEN_LNUM_ELE ]   ;   get next dst pointer
    lea   rbx, [ rcx * LEN_LNUM_ELE ]   ;   load new i_src_s
    sub   rsi, rbx                      ;   restore src_l
    inc   rbp                           ;   i_dst++
    cmp   rbp, r8                       ;   check for further iterations
    jne   mult_basic_middle_loop_outer

mult_basic_final_loop_setup:
    cmp   rcx, 1                        ;   with len 1 input, no final loop is needed
    je mult_basic_last_word
    dec   rcx                           ;   src_s_len--
    lea   rbx, [ rcx * LEN_LNUM_ELE ]   ;   i_src_s = src_s_len
    lea   rsi, [ rsi + LEN_LNUM_ELE ]   ;   get next src_l pointer

mult_basic_final_loop_outer:
;    ---------------------------------------
;   |            REGISTER STATUS            |
;   |  dst  : RDI         i_dest: RBP       |
;   |  src_l: RSI         src_l_len : R8    |
;   |  src_s: R9          src_s_len : RCX   |
;   |  (t1|t2|t3): R10|R11|R12              |
;   |  i_src_s: RBX                         |
;    ---------------------------------------
    mov   r12, r11                      ;   shift the carry from last round
    mov   r11, r10                      ;   shift the carry from last round
    xor   r10, r10                      ;   shift the carry from last round
    lea   r9, [ r9 + LEN_LNUM_ELE ]     ;   get next src_s pointer

mult_basic_final_loop_inner:
    mov   rax, [rsi]                    ;   RAX = src_l[i_src_l];
    lea   rbx, [ rbx - LEN_LNUM_ELE ]   ;   i_src_s--
    mul   QWORD PTR[r9 + rbx]            ;   (RDX|RAX) = src_l[i_src_l]*src_s[i_src_s]
    add   r12,rax                       ;   t3 = t3 + RAX           | can cause carry
    lea   rsi, [ rsi + LEN_LNUM_ELE ]   ;   i_src_l++
    adc   r11,rdx                       ;   t2 = t2 + RDX + carry   | can cause carry
    adc   r10,0                         ;   t1 = t1 + carry         | no carry
    cmp   rbx, 0                        ;   loop untill we reached src_s[0]
    jne   mult_basic_final_loop_inner
    
    mov   [rdi], r12
    lea   rdi, [ rdi + LEN_LNUM_ELE ]   ;   get next dst pointer
    dec   rcx
    jz    mult_basic_last_word
    lea   rbx, [ rcx * LEN_LNUM_ELE ]
    sub   rsi, rbx
    jmp   mult_basic_final_loop_outer

mult_basic_last_word:
    mov   [rdi], r11
    cmp   r11,0
    je    mult_basic_end
    inc   rbp

mult_basic_end:
    mov   rax, rbp
    pop   r15
    pop   r14
    pop   r13
    pop   r12
    pop   rbp
    pop   rbx
    pop   rsi
    pop   rdi
    ret
m_impl_mult_basic endp


;extern "C" void m_impl_square(LNUM_WORD* ap_dest,
;                              const LNUM_WORD* ap_a,
;                              unsigned int szp_a_len);
; This implementation is based on Algorithm 14.16 from the book 'Handbook of Applied Cryptography' by A. Menezes, P. van Oorschot, and S. Vanstone.
; Step 2.1 was extracted to a separate loop, replacing step 1.
m_impl_square proc
;-----------------------------------------------------------------------------------------;
;  Calling convention: Microsoft x64                                                      ;
;-----------------------------------------------------------------------------------------;
;           scratch (volatile) registers:   RAX, RCX, RDX, R8, R9, R10, R11               ;
;   callee-save (non-volatile) registers:   RBX, RBP, RDI, RSI, RSP, R12, R13, R14, R15   ;
;                    parameter registers:   RCX, RDX, R8, R9                              ;
;-----------------------------------------------------------------------------------------;
    cmp   r8,64
    je    m_impl_sqr_8
    push  rdi
    push  rsi
    mov   rdi, rcx
    mov   rsi, rdx
    shr   r8, 3                                 ;   Scale length parameters from bytes to (64-bit) words
    mov   rcx, r8                               ;   load length to RCX
    push  rbx
    push  r12
    push  r13
;    ---------------------------------------
;   |            REGISTER STATUS            |
;   |  dest : RDI                           |
;   |  src :  RSI         src_len : R8, RCX |
;    ---------------------------------------

    xor   r11, r11

align 16
sqr_first_loop:
    mov   rax, [ rsi + r11 ]                    ;   RAX = src[i]
    mul   rax                                   ;   (RDX|RAX) = w[2i+1]|w[2i] = src[i]*src[i]
    mov   [ rdi + 2*r11 ], rax                  ;   dest[2i] = w[2i]
    mov   [ rdi + 2*r11 + LEN_LNUM_ELE ], rdx   ;   dest[2i+1]= w[2i+1]
    lea   r11, [ r11 + LEN_LNUM_ELE ]           ;   increment offset
    loop  sqr_first_loop                        ;   loop over the entire src

    dec   r8                                    ;   decrement the remaining count by one, before entering the multiplication loop
    jz    sqr_end                               ;   no multiplication loop is required, if src_len was 1

    xor   r13, r13                              ;   reset R13 to be used as carry out
    lea   rdi, [ rdi - LEN_LNUM_ELE ]           ;   RDI = dest-1. this is done to allow incrementing the dest base by two words for each big loop
;    ---------------------------------------
;   |            REGISTER STATUS            |
;   |  dest-1 : RDI       carry_out: R13    |
;   |  src :  RSI         src_len : R8      |
;    ---------------------------------------
align 16
sqr_mul_outer_loop:
    mov   r9, [rsi]                             ;   R9 = src[i]
    lea   rsi, [ rsi + LEN_LNUM_ELE ]           ;   RSI = src+i+1
    lea   rdi, [ rdi + LEN_LNUM_ELE*2 ]         ;   RDI = dest+i+1
    mov   rcx, r8
    xor   r11, r11                              ;   clear offset
    xor   r12, r12                              ;   clear c_low
    xor   r10, r10                              ;   clear c_high
    xor   rbx, rbx                              ;   clear temp
    shl   rcx, 3                                ;   calculate the number of bytes for the inner loop

;    -------------------------------------------
;   |            REGISTER STATUS                |
;   |  dest+2i+1: RDI        carry_out: R13     |
;   |  src+i+1:  RSI         src_len-(i+1): R8  |
;   |  src[i]:   R9          input_bytes: RCX   |
;    -------------------------------------------

; Step 2.2 of the algorithm
; The mov and add operations have been strongly interleaved for improved performance!
align 16
sqr_mul_inner_loop:
    mov   rax, r9                               ;   RAX = src[i]
    mul   QWORD PTR[ rsi + r11 ]                ;   (RDX|RAX) = u|v = src[i]*src[j]
    add   rax, rax                              ;   v = v+v = 2*v           | faster than shift.
    adc   rdx, rdx                              ;   u = u+u+cf = 2*u+cf     | faster than shift.
    adc   rbx, 0                                ;   store carry out from the shift
    add   rax, r12                              ;   v = v+c_low             | carry possible
    adc   rdx, r10                              ;   u = u+c_high+cf         | carry possible
    mov   r12, rdx                              ;   c_low = u               | carry unaffected
    adc   rbx, 0                                ;   store carry out of this loop step
    mov   r10, rbx                              ;   c_high = temp
    add   [ rdi + r11 ], rax                    ;   dest[i+j] = v+w[i+j]    | carry possible
    lea   r11, [ r11 + LEN_LNUM_ELE ]           ;   increment offset. j++   | carry unaffected
    adc   r12, 0                                ;   c_low = c_low+cf        | carry possible
    mov   rbx, 0                                ;   reset temp              | carry unaffected
    adc   r10, 0                                ;   store carry out of this loop step
    cmp   rcx, r11                              ;   check, if the offset reached the number of input bytes
    jne   sqr_mul_inner_loop                    ;   loop over the remaining part of src

;    -------------------------------------------
;   |            REGISTER STATUS                |
;   |  dest+2i+1: RDI        carry_out: R13     |
;   |  src+i+1:  RSI         src_len-(i+1): R8  |
;   |  src[i]:   R9          c_low: R12         |
;   |  c_high:   R10         cur. offset: R11   |
;    -------------------------------------------

    add   r13, r12                              ;   c_low = c_low + carry_out   | add carry out from last outer loop
    adc   r10, 0                                ;   c_high = c_high + cf
    add   [ rdi + r11 ], r13                    ;   dest[i+j+1] = w[i+j+1]+ c_low   | may cause carry
    adc   r10, 0                                ;   c_high = c_high +cf
    mov   r13, r10                              ;   carry_out = c_high
    dec   r8                                    ;   decrement remaining length. this is in effect i++
    jnz   sqr_mul_outer_loop                    ;   repeat until remaining length reaches 0

    add   [ rdi + r11 + LEN_LNUM_ELE ], r13     ;   add last carry out to high dest word. This cannot cause carry

sqr_end:
    pop   r13
    pop   r12
    pop   rbx
    pop   rsi
    pop   rdi
    ret
m_impl_square endp



;extern "C" int m_impl_add_karatsuba(LNUM_WORD* ap_dest,
;                                    const LNUM_WORD* ap_a,
;                                    const LNUM_WORD* ap_b,
;                                    unsigned int szp_len);
m_impl_add_karatsuba proc
;-----------------------------------------------------------------------------------------;
;  Calling convention: Microsoft x64                                                      ;
;-----------------------------------------------------------------------------------------;
;           scratch (volatile) registers:   RAX, RCX, RDX, R8, R9, R10, R11               ;
;   callee-save (non-volatile) registers:   RBX, RBP, RDI, RSI, RSP, R12, R13, R14, R15   ;
;                    parameter registers:   RCX, RDX, R8, R9                              ;
;-----------------------------------------------------------------------------------------;
;    ---------------------------------------
;   |            REGISTER STATUS            |
;   |  dest : RCX         src1:     RDX     |
;   |  src2 : R8          src_len : R9      |
;    ---------------------------------------
    mov  r10, rcx                       ;   dest to R10, freeing RCX
    mov  rcx, r9                        ;   load length to RCX
;    ---------------------------------------
;   |            REGISTER STATUS            |
;   |  dest: R10         src1: RDX          |
;   |  src2: R8          src_len: RCX       |
;    ---------------------------------------

    shr  rcx, 3                         ;   Scale length parameters from bytes to (64-bit) words
    xor  r11, r11                       ;   Clear R11 for use as address offset for the source and dest pointers

    xor  rax,rax                        ;   Clear RAX. AH will be used to store the flags to keep CF between loop runs, so this will effectively clear the CF.
    sub  rcx, 32                        ;   This checks, if at least 32 words are available and prepares the 32 word loop.
                                        ;   sub is used over cmp for the following reason:
                                        ;       At the end of the unrolled loop, 32 will be subtracted again from RCX.
                                        ;       By subtracting an additional block here, this will underflow, when there is less, than 32 words left, signaling the end of the loop.
    jl   karatsuba_add_unroll_32_end    ;   Jump beyond the loop, if less than 32 words are available for addition


align 16
karatsuba_add_unroll_loop_32:

    sahf                                            ;   Restore carry flag

    mov  rax, [rdx + r11 + 0 * LEN_LNUM_ELE]  ;   src_1                       |  mov  :  no flags affected
    adc  rax, [ r8 + r11 + 0 * LEN_LNUM_ELE]  ;   src_1 + src_2 + carry       |  adc  :  CF is set regarding the carry value (OK: wished behaviour)
    mov  [r10 + r11 + 0 * LEN_LNUM_ELE], rax  ;   dst = src_1 + src_2 + carry |  mov  :  no flags affected
    mov  rax, [rdx + r11 + 1 * LEN_LNUM_ELE]  ;   src_1                       |  mov  :  no flags affected
    adc  rax, [ r8 + r11 + 1 * LEN_LNUM_ELE]  ;   src_1 + src_2 + carry       |  adc  :  CF is set regarding the carry value (OK: wished behaviour)
    mov  [r10 + r11 + 1 * LEN_LNUM_ELE], rax  ;   dst = src_1 + src_2 + carry |  mov  :  no flags affected
    mov  rax, [rdx + r11 + 2 * LEN_LNUM_ELE]  ;   src_1                       |  mov  :  no flags affected
    adc  rax, [ r8 + r11 + 2 * LEN_LNUM_ELE]  ;   src_1 + src_2 + carry       |  adc  :  CF is set regarding the carry value (OK: wished behaviour)
    mov  [r10 + r11 + 2 * LEN_LNUM_ELE], rax  ;   dst = src_1 + src_2 + carry |  mov  :  no flags affected
    mov  rax, [rdx + r11 + 3 * LEN_LNUM_ELE]  ;   src_1                       |  mov  :  no flags affected
    adc  rax, [ r8 + r11 + 3 * LEN_LNUM_ELE]  ;   src_1 + src_2 + carry       |  adc  :  CF is set regarding the carry value (OK: wished behaviour)
    mov  [r10 + r11 + 3 * LEN_LNUM_ELE], rax  ;   dst = src_1 + src_2 + carry |  mov  :  no flags affected
    mov  rax, [rdx + r11 + 4 * LEN_LNUM_ELE]  ;   src_1                       |  mov  :  no flags affected
    adc  rax, [ r8 + r11 + 4 * LEN_LNUM_ELE]  ;   src_1 + src_2 + carry       |  adc  :  CF is set regarding the carry value (OK: wished behaviour)
    mov  [r10 + r11 + 4 * LEN_LNUM_ELE], rax  ;   dst = src_1 + src_2 + carry |  mov  :  no flags affected
    mov  rax, [rdx + r11 + 5 * LEN_LNUM_ELE]  ;   src_1                       |  mov  :  no flags affected
    adc  rax, [ r8 + r11 + 5 * LEN_LNUM_ELE]  ;   src_1 + src_2 + carry       |  adc  :  CF is set regarding the carry value (OK: wished behaviour)
    mov  [r10 + r11 + 5 * LEN_LNUM_ELE], rax  ;   dst = src_1 + src_2 + carry |  mov  :  no flags affected
    mov  rax, [rdx + r11 + 6 * LEN_LNUM_ELE]  ;   src_1                       |  mov  :  no flags affected
    adc  rax, [ r8 + r11 + 6 * LEN_LNUM_ELE]  ;   src_1 + src_2 + carry       |  adc  :  CF is set regarding the carry value (OK: wished behaviour)
    mov  [r10 + r11 + 6 * LEN_LNUM_ELE], rax  ;   dst = src_1 + src_2 + carry |  mov  :  no flags affected
    mov  rax, [rdx + r11 + 7 * LEN_LNUM_ELE]  ;   src_1                       |  mov  :  no flags affected
    adc  rax, [ r8 + r11 + 7 * LEN_LNUM_ELE]  ;   src_1 + src_2 + carry       |  adc  :  CF is set regarding the carry value (OK: wished behaviour)
    mov  [r10 + r11 + 7 * LEN_LNUM_ELE], rax  ;   dst = src_1 + src_2 + carry |  mov  :  no flags affected
    mov  rax, [rdx + r11 + 8 * LEN_LNUM_ELE]  ;   src_1                       |  mov  :  no flags affected
    adc  rax, [ r8 + r11 + 8 * LEN_LNUM_ELE]  ;   src_1 + src_2 + carry       |  adc  :  CF is set regarding the carry value (OK: wished behaviour)
    mov  [r10 + r11 + 8 * LEN_LNUM_ELE], rax  ;   dst = src_1 + src_2 + carry |  mov  :  no flags affected
    mov  rax, [rdx + r11 + 9 * LEN_LNUM_ELE]  ;   src_1                       |  mov  :  no flags affected
    adc  rax, [ r8 + r11 + 9 * LEN_LNUM_ELE]  ;   src_1 + src_2 + carry       |  adc  :  CF is set regarding the carry value (OK: wished behaviour)
    mov  [r10 + r11 + 9 * LEN_LNUM_ELE], rax  ;   dst = src_1 + src_2 + carry |  mov  :  no flags affected
    mov  rax, [rdx + r11 + 10 * LEN_LNUM_ELE]  ;   src_1                       |  mov  :  no flags affected
    adc  rax, [ r8 + r11 + 10 * LEN_LNUM_ELE]  ;   src_1 + src_2 + carry       |  adc  :  CF is set regarding the carry value (OK: wished behaviour)
    mov  [r10 + r11 + 10 * LEN_LNUM_ELE], rax  ;   dst = src_1 + src_2 + carry |  mov  :  no flags affected
    mov  rax, [rdx + r11 + 11 * LEN_LNUM_ELE]  ;   src_1                       |  mov  :  no flags affected
    adc  rax, [ r8 + r11 + 11 * LEN_LNUM_ELE]  ;   src_1 + src_2 + carry       |  adc  :  CF is set regarding the carry value (OK: wished behaviour)
    mov  [r10 + r11 + 11 * LEN_LNUM_ELE], rax  ;   dst = src_1 + src_2 + carry |  mov  :  no flags affected
    mov  rax, [rdx + r11 + 12 * LEN_LNUM_ELE]  ;   src_1                       |  mov  :  no flags affected
    adc  rax, [ r8 + r11 + 12 * LEN_LNUM_ELE]  ;   src_1 + src_2 + carry       |  adc  :  CF is set regarding the carry value (OK: wished behaviour)
    mov  [r10 + r11 + 12 * LEN_LNUM_ELE], rax  ;   dst = src_1 + src_2 + carry |  mov  :  no flags affected
    mov  rax, [rdx + r11 + 13 * LEN_LNUM_ELE]  ;   src_1                       |  mov  :  no flags affected
    adc  rax, [ r8 + r11 + 13 * LEN_LNUM_ELE]  ;   src_1 + src_2 + carry       |  adc  :  CF is set regarding the carry value (OK: wished behaviour)
    mov  [r10 + r11 + 13 * LEN_LNUM_ELE], rax  ;   dst = src_1 + src_2 + carry |  mov  :  no flags affected
    mov  rax, [rdx + r11 + 14 * LEN_LNUM_ELE]  ;   src_1                       |  mov  :  no flags affected
    adc  rax, [ r8 + r11 + 14 * LEN_LNUM_ELE]  ;   src_1 + src_2 + carry       |  adc  :  CF is set regarding the carry value (OK: wished behaviour)
    mov  [r10 + r11 + 14 * LEN_LNUM_ELE], rax  ;   dst = src_1 + src_2 + carry |  mov  :  no flags affected
    mov  rax, [rdx + r11 + 15 * LEN_LNUM_ELE]  ;   src_1                       |  mov  :  no flags affected
    adc  rax, [ r8 + r11 + 15 * LEN_LNUM_ELE]  ;   src_1 + src_2 + carry       |  adc  :  CF is set regarding the carry value (OK: wished behaviour)
    mov  [r10 + r11 + 15 * LEN_LNUM_ELE], rax  ;   dst = src_1 + src_2 + carry |  mov  :  no flags affected
    mov  rax, [rdx + r11 + 16 * LEN_LNUM_ELE]  ;   src_1                       |  mov  :  no flags affected
    adc  rax, [ r8 + r11 + 16 * LEN_LNUM_ELE]  ;   src_1 + src_2 + carry       |  adc  :  CF is set regarding the carry value (OK: wished behaviour)
    mov  [r10 + r11 + 16 * LEN_LNUM_ELE], rax  ;   dst = src_1 + src_2 + carry |  mov  :  no flags affected
    mov  rax, [rdx + r11 + 17 * LEN_LNUM_ELE]  ;   src_1                       |  mov  :  no flags affected
    adc  rax, [ r8 + r11 + 17 * LEN_LNUM_ELE]  ;   src_1 + src_2 + carry       |  adc  :  CF is set regarding the carry value (OK: wished behaviour)
    mov  [r10 + r11 + 17 * LEN_LNUM_ELE], rax  ;   dst = src_1 + src_2 + carry |  mov  :  no flags affected
    mov  rax, [rdx + r11 + 18 * LEN_LNUM_ELE]  ;   src_1                       |  mov  :  no flags affected
    adc  rax, [ r8 + r11 + 18 * LEN_LNUM_ELE]  ;   src_1 + src_2 + carry       |  adc  :  CF is set regarding the carry value (OK: wished behaviour)
    mov  [r10 + r11 + 18 * LEN_LNUM_ELE], rax  ;   dst = src_1 + src_2 + carry |  mov  :  no flags affected
    mov  rax, [rdx + r11 + 19 * LEN_LNUM_ELE]  ;   src_1                       |  mov  :  no flags affected
    adc  rax, [ r8 + r11 + 19 * LEN_LNUM_ELE]  ;   src_1 + src_2 + carry       |  adc  :  CF is set regarding the carry value (OK: wished behaviour)
    mov  [r10 + r11 + 19 * LEN_LNUM_ELE], rax  ;   dst = src_1 + src_2 + carry |  mov  :  no flags affected
    mov  rax, [rdx + r11 + 20 * LEN_LNUM_ELE]  ;   src_1                       |  mov  :  no flags affected
    adc  rax, [ r8 + r11 + 20 * LEN_LNUM_ELE]  ;   src_1 + src_2 + carry       |  adc  :  CF is set regarding the carry value (OK: wished behaviour)
    mov  [r10 + r11 + 20 * LEN_LNUM_ELE], rax  ;   dst = src_1 + src_2 + carry |  mov  :  no flags affected
    mov  rax, [rdx + r11 + 21 * LEN_LNUM_ELE]  ;   src_1                       |  mov  :  no flags affected
    adc  rax, [ r8 + r11 + 21 * LEN_LNUM_ELE]  ;   src_1 + src_2 + carry       |  adc  :  CF is set regarding the carry value (OK: wished behaviour)
    mov  [r10 + r11 + 21 * LEN_LNUM_ELE], rax  ;   dst = src_1 + src_2 + carry |  mov  :  no flags affected
    mov  rax, [rdx + r11 + 22 * LEN_LNUM_ELE]  ;   src_1                       |  mov  :  no flags affected
    adc  rax, [ r8 + r11 + 22 * LEN_LNUM_ELE]  ;   src_1 + src_2 + carry       |  adc  :  CF is set regarding the carry value (OK: wished behaviour)
    mov  [r10 + r11 + 22 * LEN_LNUM_ELE], rax  ;   dst = src_1 + src_2 + carry |  mov  :  no flags affected
    mov  rax, [rdx + r11 + 23 * LEN_LNUM_ELE]  ;   src_1                       |  mov  :  no flags affected
    adc  rax, [ r8 + r11 + 23 * LEN_LNUM_ELE]  ;   src_1 + src_2 + carry       |  adc  :  CF is set regarding the carry value (OK: wished behaviour)
    mov  [r10 + r11 + 23 * LEN_LNUM_ELE], rax  ;   dst = src_1 + src_2 + carry |  mov  :  no flags affected
    mov  rax, [rdx + r11 + 24 * LEN_LNUM_ELE]  ;   src_1                       |  mov  :  no flags affected
    adc  rax, [ r8 + r11 + 24 * LEN_LNUM_ELE]  ;   src_1 + src_2 + carry       |  adc  :  CF is set regarding the carry value (OK: wished behaviour)
    mov  [r10 + r11 + 24 * LEN_LNUM_ELE], rax  ;   dst = src_1 + src_2 + carry |  mov  :  no flags affected
    mov  rax, [rdx + r11 + 25 * LEN_LNUM_ELE]  ;   src_1                       |  mov  :  no flags affected
    adc  rax, [ r8 + r11 + 25 * LEN_LNUM_ELE]  ;   src_1 + src_2 + carry       |  adc  :  CF is set regarding the carry value (OK: wished behaviour)
    mov  [r10 + r11 + 25 * LEN_LNUM_ELE], rax  ;   dst = src_1 + src_2 + carry |  mov  :  no flags affected
    mov  rax, [rdx + r11 + 26 * LEN_LNUM_ELE]  ;   src_1                       |  mov  :  no flags affected
    adc  rax, [ r8 + r11 + 26 * LEN_LNUM_ELE]  ;   src_1 + src_2 + carry       |  adc  :  CF is set regarding the carry value (OK: wished behaviour)
    mov  [r10 + r11 + 26 * LEN_LNUM_ELE], rax  ;   dst = src_1 + src_2 + carry |  mov  :  no flags affected
    mov  rax, [rdx + r11 + 27 * LEN_LNUM_ELE]  ;   src_1                       |  mov  :  no flags affected
    adc  rax, [ r8 + r11 + 27 * LEN_LNUM_ELE]  ;   src_1 + src_2 + carry       |  adc  :  CF is set regarding the carry value (OK: wished behaviour)
    mov  [r10 + r11 + 27 * LEN_LNUM_ELE], rax  ;   dst = src_1 + src_2 + carry |  mov  :  no flags affected
    mov  rax, [rdx + r11 + 28 * LEN_LNUM_ELE]  ;   src_1                       |  mov  :  no flags affected
    adc  rax, [ r8 + r11 + 28 * LEN_LNUM_ELE]  ;   src_1 + src_2 + carry       |  adc  :  CF is set regarding the carry value (OK: wished behaviour)
    mov  [r10 + r11 + 28 * LEN_LNUM_ELE], rax  ;   dst = src_1 + src_2 + carry |  mov  :  no flags affected
    mov  rax, [rdx + r11 + 29 * LEN_LNUM_ELE]  ;   src_1                       |  mov  :  no flags affected
    adc  rax, [ r8 + r11 + 29 * LEN_LNUM_ELE]  ;   src_1 + src_2 + carry       |  adc  :  CF is set regarding the carry value (OK: wished behaviour)
    mov  [r10 + r11 + 29 * LEN_LNUM_ELE], rax  ;   dst = src_1 + src_2 + carry |  mov  :  no flags affected
    mov  rax, [rdx + r11 + 30 * LEN_LNUM_ELE]  ;   src_1                       |  mov  :  no flags affected
    adc  rax, [ r8 + r11 + 30 * LEN_LNUM_ELE]  ;   src_1 + src_2 + carry       |  adc  :  CF is set regarding the carry value (OK: wished behaviour)
    mov  [r10 + r11 + 30 * LEN_LNUM_ELE], rax  ;   dst = src_1 + src_2 + carry |  mov  :  no flags affected
    mov  rax, [rdx + r11 + 31 * LEN_LNUM_ELE]  ;   src_1                       |  mov  :  no flags affected
    adc  rax, [ r8 + r11 + 31 * LEN_LNUM_ELE]  ;   src_1 + src_2 + carry       |  adc  :  CF is set regarding the carry value (OK: wished behaviour)
    mov  [r10 + r11 + 31 * LEN_LNUM_ELE], rax  ;   dst = src_1 + src_2 + carry |  mov  :  no flags affected

    lahf                                            ;   save carry flag

    lea  r11, [r11 + 32 * LEN_LNUM_ELE]             ;   increase pointer offset
    sub  rcx, 32                                    ;   subtract the processed words
    jge  karatsuba_add_unroll_loop_32               ;   keep up the loop, until there are not enough words left

karatsuba_add_unroll_32_end:

;    ---------------------------------------------------
;   |            REGISTER STATUS                        |
;   |  dest: R10         src1: RDX                      |
;   |  src2: R8          word for addition - 32 : RCX   |
;   |  temp: RAX         offset: R11                    |
;    ---------------------------------------------------
    add  rcx, (32-8)                                ;   we subtracted one additional 32 word block, so restore that part, minus 8 words
                                                    ;   the same loop construct will be used for the 8 word unroll
    jnc  karatsuba_add_unroll_8_end                 ;   the add didn't cause a carry. This signals, that there are less, than 8 words, so we skip that loop

align 16
karatsuba_add_unroll_loop_8:

    sahf                                            ;   Restore carry flag

    mov  rax, [rdx + r11 + 0 * LEN_LNUM_ELE]  ;   src_1                       |  mov  :  no flags affected
    adc  rax, [ r8 + r11 + 0 * LEN_LNUM_ELE]  ;   src_1 + src_2 + carry       |  adc  :  CF is set regarding the carry value (OK: wished behaviour)
    mov  [r10 + r11 + 0 * LEN_LNUM_ELE], rax  ;   dst = src_1 + src_2 + carry |  mov  :  no flags affected
    mov  rax, [rdx + r11 + 1 * LEN_LNUM_ELE]  ;   src_1                       |  mov  :  no flags affected
    adc  rax, [ r8 + r11 + 1 * LEN_LNUM_ELE]  ;   src_1 + src_2 + carry       |  adc  :  CF is set regarding the carry value (OK: wished behaviour)
    mov  [r10 + r11 + 1 * LEN_LNUM_ELE], rax  ;   dst = src_1 + src_2 + carry |  mov  :  no flags affected
    mov  rax, [rdx + r11 + 2 * LEN_LNUM_ELE]  ;   src_1                       |  mov  :  no flags affected
    adc  rax, [ r8 + r11 + 2 * LEN_LNUM_ELE]  ;   src_1 + src_2 + carry       |  adc  :  CF is set regarding the carry value (OK: wished behaviour)
    mov  [r10 + r11 + 2 * LEN_LNUM_ELE], rax  ;   dst = src_1 + src_2 + carry |  mov  :  no flags affected
    mov  rax, [rdx + r11 + 3 * LEN_LNUM_ELE]  ;   src_1                       |  mov  :  no flags affected
    adc  rax, [ r8 + r11 + 3 * LEN_LNUM_ELE]  ;   src_1 + src_2 + carry       |  adc  :  CF is set regarding the carry value (OK: wished behaviour)
    mov  [r10 + r11 + 3 * LEN_LNUM_ELE], rax  ;   dst = src_1 + src_2 + carry |  mov  :  no flags affected
    mov  rax, [rdx + r11 + 4 * LEN_LNUM_ELE]  ;   src_1                       |  mov  :  no flags affected
    adc  rax, [ r8 + r11 + 4 * LEN_LNUM_ELE]  ;   src_1 + src_2 + carry       |  adc  :  CF is set regarding the carry value (OK: wished behaviour)
    mov  [r10 + r11 + 4 * LEN_LNUM_ELE], rax  ;   dst = src_1 + src_2 + carry |  mov  :  no flags affected
    mov  rax, [rdx + r11 + 5 * LEN_LNUM_ELE]  ;   src_1                       |  mov  :  no flags affected
    adc  rax, [ r8 + r11 + 5 * LEN_LNUM_ELE]  ;   src_1 + src_2 + carry       |  adc  :  CF is set regarding the carry value (OK: wished behaviour)
    mov  [r10 + r11 + 5 * LEN_LNUM_ELE], rax  ;   dst = src_1 + src_2 + carry |  mov  :  no flags affected
    mov  rax, [rdx + r11 + 6 * LEN_LNUM_ELE]  ;   src_1                       |  mov  :  no flags affected
    adc  rax, [ r8 + r11 + 6 * LEN_LNUM_ELE]  ;   src_1 + src_2 + carry       |  adc  :  CF is set regarding the carry value (OK: wished behaviour)
    mov  [r10 + r11 + 6 * LEN_LNUM_ELE], rax  ;   dst = src_1 + src_2 + carry |  mov  :  no flags affected
    mov  rax, [rdx + r11 + 7 * LEN_LNUM_ELE]  ;   src_1                       |  mov  :  no flags affected
    adc  rax, [ r8 + r11 + 7 * LEN_LNUM_ELE]  ;   src_1 + src_2 + carry       |  adc  :  CF is set regarding the carry value (OK: wished behaviour)
    mov  [r10 + r11 + 7 * LEN_LNUM_ELE], rax  ;   dst = src_1 + src_2 + carry |  mov  :  no flags affected

    lahf                                             ;   save carry flag

    lea  r11, [r11 + 8 * LEN_LNUM_ELE]             ;   increase pointer offset
    sub  rcx, 8                                    ;   subtract the processed words
    jge  karatsuba_add_unroll_loop_8               ;   keep up the loop, until there are not enough words left

karatsuba_add_unroll_8_end:
;    ---------------------------------------------------
;   |            REGISTER STATUS                        |
;   |  dest: R10         src1: RDX                      |
;   |  src2: R8          word for addition - 8 : RCX    |
;   |  temp: RAX         offset: R11                    |
;    ---------------------------------------------------
    add  rcx, 8                             ;   Add back the missing 8 words from the count

    sahf                                    ;   load carry flag
    jrcxz karatsuba_add_single_loop_end     ;   If no words for addition are left, jump to carry propagation

karatsuba_add_loop:
    mov   rax, [ rdx + r11 ]                ;   RAX = src1
    adc   rax, [ r8 + r11 ]                 ;   src1 + src2 + carry     | carry set
    mov   [ r10 + r11 ], rax                ;   dest = src1 + src2 + carry
    lea   r11, [ r11 + LEN_LNUM_ELE ]       ;   increment index
    loop karatsuba_add_loop                 ;   loop over the entire length. src1 and src2 are equal length

karatsuba_add_single_loop_end:
    mov   rax, 0                            ;   clear eax, without affecting carry flag
    adc   rax, 0                            ;   add the carry out to eax

    ret
m_impl_add_karatsuba endp

;extern "C" int m_impl_sub_karatsuba(LNUM_WORD* ap_dest,
;                                    const LNUM_WORD* ap_a,
;                                    const LNUM_WORD* ap_b,
;                                    unsigned int szp_len);
m_impl_sub_karatsuba proc
;-----------------------------------------------------------------------------------------;
;  Calling convention: Microsoft x64                                                      ;
;-----------------------------------------------------------------------------------------;
;           scratch (volatile) registers:   RAX, RCX, RDX, R8, R9, R10, R11               ;
;   callee-save (non-volatile) registers:   RBX, RBP, RDI, RSI, RSP, R12, R13, R14, R15   ;
;                    parameter registers:   RCX, RDX, R8, R9                              ;
;-----------------------------------------------------------------------------------------;
;    ---------------------------------------
;   |            REGISTER STATUS            |
;   |  dest : RCX         src1:     RDX     |
;   |  src2 : R8          src_len : R9      |
;    ---------------------------------------
    mov  r10, rcx                       ;   dest to R10, freeing RCX
    mov  rcx, r9                        ;   load length to RCX
;    ---------------------------------------
;   |            REGISTER STATUS            |
;   |  dest: R10         src1: RDX          |
;   |  src2: R8          src_len: RCX       |
;    ---------------------------------------


    shr  rcx, 3                         ;   Scale length parameters from bytes to (64-bit) words
    xor  r11, r11                       ;   Clear R11 for use as address offset for the source and dest pointers

    xor  rax,rax                        ;   Clear RAX. AH will be used to store the flags to keep CF between loop runs, so this will effectively clear the CF.
    sub  rcx, 32                        ;   This checks, if at least 32 words are available and prepares the 32 word loop.
                                        ;   sub is used over cmp for the following reason:
                                        ;       At the end of the unrolled loop, 32 will be subtracted again from RCX.
                                        ;       By subtracting an additional block here, this will underflow, when there is less, than 32 words left, signaling the end of the loop.
    jl   karatsuba_sub_unroll_32_end    ;   Jump beyond the loop, if less than 32 words are available for addition


align 16
karatsuba_sub_unroll_loop_32:

    sahf                                            ;   Restore carry flag

    mov  rax, [rdx + r11 + 0 * LEN_LNUM_ELE]  ;   src_1                        |  mov  :  no flags affected
    sbb  rax, [ r8 + r11 + 0 * LEN_LNUM_ELE]  ;   src_1 - src_2 - borrow       |  sbb  :  CF is set regarding the carry value (OK: wished behaviour)
    mov  [r10 + r11 + 0 * LEN_LNUM_ELE], rax  ;   dst = src_1 - src_2 - borrow |  mov  :  no flags affected
    mov  rax, [rdx + r11 + 1 * LEN_LNUM_ELE]  ;   src_1                        |  mov  :  no flags affected
    sbb  rax, [ r8 + r11 + 1 * LEN_LNUM_ELE]  ;   src_1 - src_2 - borrow       |  sbb  :  CF is set regarding the carry value (OK: wished behaviour)
    mov  [r10 + r11 + 1 * LEN_LNUM_ELE], rax  ;   dst = src_1 - src_2 - borrow |  mov  :  no flags affected
    mov  rax, [rdx + r11 + 2 * LEN_LNUM_ELE]  ;   src_1                        |  mov  :  no flags affected
    sbb  rax, [ r8 + r11 + 2 * LEN_LNUM_ELE]  ;   src_1 - src_2 - borrow       |  sbb  :  CF is set regarding the carry value (OK: wished behaviour)
    mov  [r10 + r11 + 2 * LEN_LNUM_ELE], rax  ;   dst = src_1 - src_2 - borrow |  mov  :  no flags affected
    mov  rax, [rdx + r11 + 3 * LEN_LNUM_ELE]  ;   src_1                        |  mov  :  no flags affected
    sbb  rax, [ r8 + r11 + 3 * LEN_LNUM_ELE]  ;   src_1 - src_2 - borrow       |  sbb  :  CF is set regarding the carry value (OK: wished behaviour)
    mov  [r10 + r11 + 3 * LEN_LNUM_ELE], rax  ;   dst = src_1 - src_2 - borrow |  mov  :  no flags affected
    mov  rax, [rdx + r11 + 4 * LEN_LNUM_ELE]  ;   src_1                        |  mov  :  no flags affected
    sbb  rax, [ r8 + r11 + 4 * LEN_LNUM_ELE]  ;   src_1 - src_2 - borrow       |  sbb  :  CF is set regarding the carry value (OK: wished behaviour)
    mov  [r10 + r11 + 4 * LEN_LNUM_ELE], rax  ;   dst = src_1 - src_2 - borrow |  mov  :  no flags affected
    mov  rax, [rdx + r11 + 5 * LEN_LNUM_ELE]  ;   src_1                        |  mov  :  no flags affected
    sbb  rax, [ r8 + r11 + 5 * LEN_LNUM_ELE]  ;   src_1 - src_2 - borrow       |  sbb  :  CF is set regarding the carry value (OK: wished behaviour)
    mov  [r10 + r11 + 5 * LEN_LNUM_ELE], rax  ;   dst = src_1 - src_2 - borrow |  mov  :  no flags affected
    mov  rax, [rdx + r11 + 6 * LEN_LNUM_ELE]  ;   src_1                        |  mov  :  no flags affected
    sbb  rax, [ r8 + r11 + 6 * LEN_LNUM_ELE]  ;   src_1 - src_2 - borrow       |  sbb  :  CF is set regarding the carry value (OK: wished behaviour)
    mov  [r10 + r11 + 6 * LEN_LNUM_ELE], rax  ;   dst = src_1 - src_2 - borrow |  mov  :  no flags affected
    mov  rax, [rdx + r11 + 7 * LEN_LNUM_ELE]  ;   src_1                        |  mov  :  no flags affected
    sbb  rax, [ r8 + r11 + 7 * LEN_LNUM_ELE]  ;   src_1 - src_2 - borrow       |  sbb  :  CF is set regarding the carry value (OK: wished behaviour)
    mov  [r10 + r11 + 7 * LEN_LNUM_ELE], rax  ;   dst = src_1 - src_2 - borrow |  mov  :  no flags affected
    mov  rax, [rdx + r11 + 8 * LEN_LNUM_ELE]  ;   src_1                        |  mov  :  no flags affected
    sbb  rax, [ r8 + r11 + 8 * LEN_LNUM_ELE]  ;   src_1 - src_2 - borrow       |  sbb  :  CF is set regarding the carry value (OK: wished behaviour)
    mov  [r10 + r11 + 8 * LEN_LNUM_ELE], rax  ;   dst = src_1 - src_2 - borrow |  mov  :  no flags affected
    mov  rax, [rdx + r11 + 9 * LEN_LNUM_ELE]  ;   src_1                        |  mov  :  no flags affected
    sbb  rax, [ r8 + r11 + 9 * LEN_LNUM_ELE]  ;   src_1 - src_2 - borrow       |  sbb  :  CF is set regarding the carry value (OK: wished behaviour)
    mov  [r10 + r11 + 9 * LEN_LNUM_ELE], rax  ;   dst = src_1 - src_2 - borrow |  mov  :  no flags affected
    mov  rax, [rdx + r11 + 10 * LEN_LNUM_ELE]  ;   src_1                        |  mov  :  no flags affected
    sbb  rax, [ r8 + r11 + 10 * LEN_LNUM_ELE]  ;   src_1 - src_2 - borrow       |  sbb  :  CF is set regarding the carry value (OK: wished behaviour)
    mov  [r10 + r11 + 10 * LEN_LNUM_ELE], rax  ;   dst = src_1 - src_2 - borrow |  mov  :  no flags affected
    mov  rax, [rdx + r11 + 11 * LEN_LNUM_ELE]  ;   src_1                        |  mov  :  no flags affected
    sbb  rax, [ r8 + r11 + 11 * LEN_LNUM_ELE]  ;   src_1 - src_2 - borrow       |  sbb  :  CF is set regarding the carry value (OK: wished behaviour)
    mov  [r10 + r11 + 11 * LEN_LNUM_ELE], rax  ;   dst = src_1 - src_2 - borrow |  mov  :  no flags affected
    mov  rax, [rdx + r11 + 12 * LEN_LNUM_ELE]  ;   src_1                        |  mov  :  no flags affected
    sbb  rax, [ r8 + r11 + 12 * LEN_LNUM_ELE]  ;   src_1 - src_2 - borrow       |  sbb  :  CF is set regarding the carry value (OK: wished behaviour)
    mov  [r10 + r11 + 12 * LEN_LNUM_ELE], rax  ;   dst = src_1 - src_2 - borrow |  mov  :  no flags affected
    mov  rax, [rdx + r11 + 13 * LEN_LNUM_ELE]  ;   src_1                        |  mov  :  no flags affected
    sbb  rax, [ r8 + r11 + 13 * LEN_LNUM_ELE]  ;   src_1 - src_2 - borrow       |  sbb  :  CF is set regarding the carry value (OK: wished behaviour)
    mov  [r10 + r11 + 13 * LEN_LNUM_ELE], rax  ;   dst = src_1 - src_2 - borrow |  mov  :  no flags affected
    mov  rax, [rdx + r11 + 14 * LEN_LNUM_ELE]  ;   src_1                        |  mov  :  no flags affected
    sbb  rax, [ r8 + r11 + 14 * LEN_LNUM_ELE]  ;   src_1 - src_2 - borrow       |  sbb  :  CF is set regarding the carry value (OK: wished behaviour)
    mov  [r10 + r11 + 14 * LEN_LNUM_ELE], rax  ;   dst = src_1 - src_2 - borrow |  mov  :  no flags affected
    mov  rax, [rdx + r11 + 15 * LEN_LNUM_ELE]  ;   src_1                        |  mov  :  no flags affected
    sbb  rax, [ r8 + r11 + 15 * LEN_LNUM_ELE]  ;   src_1 - src_2 - borrow       |  sbb  :  CF is set regarding the carry value (OK: wished behaviour)
    mov  [r10 + r11 + 15 * LEN_LNUM_ELE], rax  ;   dst = src_1 - src_2 - borrow |  mov  :  no flags affected
    mov  rax, [rdx + r11 + 16 * LEN_LNUM_ELE]  ;   src_1                        |  mov  :  no flags affected
    sbb  rax, [ r8 + r11 + 16 * LEN_LNUM_ELE]  ;   src_1 - src_2 - borrow       |  sbb  :  CF is set regarding the carry value (OK: wished behaviour)
    mov  [r10 + r11 + 16 * LEN_LNUM_ELE], rax  ;   dst = src_1 - src_2 - borrow |  mov  :  no flags affected
    mov  rax, [rdx + r11 + 17 * LEN_LNUM_ELE]  ;   src_1                        |  mov  :  no flags affected
    sbb  rax, [ r8 + r11 + 17 * LEN_LNUM_ELE]  ;   src_1 - src_2 - borrow       |  sbb  :  CF is set regarding the carry value (OK: wished behaviour)
    mov  [r10 + r11 + 17 * LEN_LNUM_ELE], rax  ;   dst = src_1 - src_2 - borrow |  mov  :  no flags affected
    mov  rax, [rdx + r11 + 18 * LEN_LNUM_ELE]  ;   src_1                        |  mov  :  no flags affected
    sbb  rax, [ r8 + r11 + 18 * LEN_LNUM_ELE]  ;   src_1 - src_2 - borrow       |  sbb  :  CF is set regarding the carry value (OK: wished behaviour)
    mov  [r10 + r11 + 18 * LEN_LNUM_ELE], rax  ;   dst = src_1 - src_2 - borrow |  mov  :  no flags affected
    mov  rax, [rdx + r11 + 19 * LEN_LNUM_ELE]  ;   src_1                        |  mov  :  no flags affected
    sbb  rax, [ r8 + r11 + 19 * LEN_LNUM_ELE]  ;   src_1 - src_2 - borrow       |  sbb  :  CF is set regarding the carry value (OK: wished behaviour)
    mov  [r10 + r11 + 19 * LEN_LNUM_ELE], rax  ;   dst = src_1 - src_2 - borrow |  mov  :  no flags affected
    mov  rax, [rdx + r11 + 20 * LEN_LNUM_ELE]  ;   src_1                        |  mov  :  no flags affected
    sbb  rax, [ r8 + r11 + 20 * LEN_LNUM_ELE]  ;   src_1 - src_2 - borrow       |  sbb  :  CF is set regarding the carry value (OK: wished behaviour)
    mov  [r10 + r11 + 20 * LEN_LNUM_ELE], rax  ;   dst = src_1 - src_2 - borrow |  mov  :  no flags affected
    mov  rax, [rdx + r11 + 21 * LEN_LNUM_ELE]  ;   src_1                        |  mov  :  no flags affected
    sbb  rax, [ r8 + r11 + 21 * LEN_LNUM_ELE]  ;   src_1 - src_2 - borrow       |  sbb  :  CF is set regarding the carry value (OK: wished behaviour)
    mov  [r10 + r11 + 21 * LEN_LNUM_ELE], rax  ;   dst = src_1 - src_2 - borrow |  mov  :  no flags affected
    mov  rax, [rdx + r11 + 22 * LEN_LNUM_ELE]  ;   src_1                        |  mov  :  no flags affected
    sbb  rax, [ r8 + r11 + 22 * LEN_LNUM_ELE]  ;   src_1 - src_2 - borrow       |  sbb  :  CF is set regarding the carry value (OK: wished behaviour)
    mov  [r10 + r11 + 22 * LEN_LNUM_ELE], rax  ;   dst = src_1 - src_2 - borrow |  mov  :  no flags affected
    mov  rax, [rdx + r11 + 23 * LEN_LNUM_ELE]  ;   src_1                        |  mov  :  no flags affected
    sbb  rax, [ r8 + r11 + 23 * LEN_LNUM_ELE]  ;   src_1 - src_2 - borrow       |  sbb  :  CF is set regarding the carry value (OK: wished behaviour)
    mov  [r10 + r11 + 23 * LEN_LNUM_ELE], rax  ;   dst = src_1 - src_2 - borrow |  mov  :  no flags affected
    mov  rax, [rdx + r11 + 24 * LEN_LNUM_ELE]  ;   src_1                        |  mov  :  no flags affected
    sbb  rax, [ r8 + r11 + 24 * LEN_LNUM_ELE]  ;   src_1 - src_2 - borrow       |  sbb  :  CF is set regarding the carry value (OK: wished behaviour)
    mov  [r10 + r11 + 24 * LEN_LNUM_ELE], rax  ;   dst = src_1 - src_2 - borrow |  mov  :  no flags affected
    mov  rax, [rdx + r11 + 25 * LEN_LNUM_ELE]  ;   src_1                        |  mov  :  no flags affected
    sbb  rax, [ r8 + r11 + 25 * LEN_LNUM_ELE]  ;   src_1 - src_2 - borrow       |  sbb  :  CF is set regarding the carry value (OK: wished behaviour)
    mov  [r10 + r11 + 25 * LEN_LNUM_ELE], rax  ;   dst = src_1 - src_2 - borrow |  mov  :  no flags affected
    mov  rax, [rdx + r11 + 26 * LEN_LNUM_ELE]  ;   src_1                        |  mov  :  no flags affected
    sbb  rax, [ r8 + r11 + 26 * LEN_LNUM_ELE]  ;   src_1 - src_2 - borrow       |  sbb  :  CF is set regarding the carry value (OK: wished behaviour)
    mov  [r10 + r11 + 26 * LEN_LNUM_ELE], rax  ;   dst = src_1 - src_2 - borrow |  mov  :  no flags affected
    mov  rax, [rdx + r11 + 27 * LEN_LNUM_ELE]  ;   src_1                        |  mov  :  no flags affected
    sbb  rax, [ r8 + r11 + 27 * LEN_LNUM_ELE]  ;   src_1 - src_2 - borrow       |  sbb  :  CF is set regarding the carry value (OK: wished behaviour)
    mov  [r10 + r11 + 27 * LEN_LNUM_ELE], rax  ;   dst = src_1 - src_2 - borrow |  mov  :  no flags affected
    mov  rax, [rdx + r11 + 28 * LEN_LNUM_ELE]  ;   src_1                        |  mov  :  no flags affected
    sbb  rax, [ r8 + r11 + 28 * LEN_LNUM_ELE]  ;   src_1 - src_2 - borrow       |  sbb  :  CF is set regarding the carry value (OK: wished behaviour)
    mov  [r10 + r11 + 28 * LEN_LNUM_ELE], rax  ;   dst = src_1 - src_2 - borrow |  mov  :  no flags affected
    mov  rax, [rdx + r11 + 29 * LEN_LNUM_ELE]  ;   src_1                        |  mov  :  no flags affected
    sbb  rax, [ r8 + r11 + 29 * LEN_LNUM_ELE]  ;   src_1 - src_2 - borrow       |  sbb  :  CF is set regarding the carry value (OK: wished behaviour)
    mov  [r10 + r11 + 29 * LEN_LNUM_ELE], rax  ;   dst = src_1 - src_2 - borrow |  mov  :  no flags affected
    mov  rax, [rdx + r11 + 30 * LEN_LNUM_ELE]  ;   src_1                        |  mov  :  no flags affected
    sbb  rax, [ r8 + r11 + 30 * LEN_LNUM_ELE]  ;   src_1 - src_2 - borrow       |  sbb  :  CF is set regarding the carry value (OK: wished behaviour)
    mov  [r10 + r11 + 30 * LEN_LNUM_ELE], rax  ;   dst = src_1 - src_2 - borrow |  mov  :  no flags affected
    mov  rax, [rdx + r11 + 31 * LEN_LNUM_ELE]  ;   src_1                        |  mov  :  no flags affected
    sbb  rax, [ r8 + r11 + 31 * LEN_LNUM_ELE]  ;   src_1 - src_2 - borrow       |  sbb  :  CF is set regarding the carry value (OK: wished behaviour)
    mov  [r10 + r11 + 31 * LEN_LNUM_ELE], rax  ;   dst = src_1 - src_2 - borrow |  mov  :  no flags affected

    lahf                                            ;   save carry flag

    lea  r11, [r11 + 32 * LEN_LNUM_ELE]             ;   increase pointer offset
    sub  rcx, 32                                    ;   subtract the processed words
    jge  karatsuba_sub_unroll_loop_32               ;   keep up the loop, until there are not enough words left

karatsuba_sub_unroll_32_end:

;    ---------------------------------------------------
;   |            REGISTER STATUS                        |
;   |  dest: R10         src1: RDX                      |
;   |  src2: R8          word for addition - 32 : RCX   |
;   |  temp: RAX         offset: R11                    |
;    ---------------------------------------------------
    add  rcx, (32-8)                                ;   we subtracted one additional 32 word block, so restore that part, minus 8 words
                                                    ;   the same loop construct will be used for the 8 word unroll
    jnc  karatsuba_sub_unroll_8_end                 ;   the add didn't cause a carry. This signals, that there are less, than 8 words, so we skip that loop

align 16
karatsuba_sub_unroll_loop_8:

    sahf                                            ;   Restore carry flag

    mov  rax, [rdx + r11 + 0 * LEN_LNUM_ELE]  ;   src_1                        |  mov  :  no flags affected
    sbb  rax, [ r8 + r11 + 0 * LEN_LNUM_ELE]  ;   src_1 - src_2 - borrow       |  sbb  :  CF is set regarding the carry value (OK: wished behaviour)
    mov  [r10 + r11 + 0 * LEN_LNUM_ELE], rax  ;   dst = src_1 - src_2 - borrow |  mov  :  no flags affected
    mov  rax, [rdx + r11 + 1 * LEN_LNUM_ELE]  ;   src_1                        |  mov  :  no flags affected
    sbb  rax, [ r8 + r11 + 1 * LEN_LNUM_ELE]  ;   src_1 - src_2 - borrow       |  sbb  :  CF is set regarding the carry value (OK: wished behaviour)
    mov  [r10 + r11 + 1 * LEN_LNUM_ELE], rax  ;   dst = src_1 - src_2 - borrow |  mov  :  no flags affected
    mov  rax, [rdx + r11 + 2 * LEN_LNUM_ELE]  ;   src_1                        |  mov  :  no flags affected
    sbb  rax, [ r8 + r11 + 2 * LEN_LNUM_ELE]  ;   src_1 - src_2 - borrow       |  sbb  :  CF is set regarding the carry value (OK: wished behaviour)
    mov  [r10 + r11 + 2 * LEN_LNUM_ELE], rax  ;   dst = src_1 - src_2 - borrow |  mov  :  no flags affected
    mov  rax, [rdx + r11 + 3 * LEN_LNUM_ELE]  ;   src_1                        |  mov  :  no flags affected
    sbb  rax, [ r8 + r11 + 3 * LEN_LNUM_ELE]  ;   src_1 - src_2 - borrow       |  sbb  :  CF is set regarding the carry value (OK: wished behaviour)
    mov  [r10 + r11 + 3 * LEN_LNUM_ELE], rax  ;   dst = src_1 - src_2 - borrow |  mov  :  no flags affected
    mov  rax, [rdx + r11 + 4 * LEN_LNUM_ELE]  ;   src_1                        |  mov  :  no flags affected
    sbb  rax, [ r8 + r11 + 4 * LEN_LNUM_ELE]  ;   src_1 - src_2 - borrow       |  sbb  :  CF is set regarding the carry value (OK: wished behaviour)
    mov  [r10 + r11 + 4 * LEN_LNUM_ELE], rax  ;   dst = src_1 - src_2 - borrow |  mov  :  no flags affected
    mov  rax, [rdx + r11 + 5 * LEN_LNUM_ELE]  ;   src_1                        |  mov  :  no flags affected
    sbb  rax, [ r8 + r11 + 5 * LEN_LNUM_ELE]  ;   src_1 - src_2 - borrow       |  sbb  :  CF is set regarding the carry value (OK: wished behaviour)
    mov  [r10 + r11 + 5 * LEN_LNUM_ELE], rax  ;   dst = src_1 - src_2 - borrow |  mov  :  no flags affected
    mov  rax, [rdx + r11 + 6 * LEN_LNUM_ELE]  ;   src_1                        |  mov  :  no flags affected
    sbb  rax, [ r8 + r11 + 6 * LEN_LNUM_ELE]  ;   src_1 - src_2 - borrow       |  sbb  :  CF is set regarding the carry value (OK: wished behaviour)
    mov  [r10 + r11 + 6 * LEN_LNUM_ELE], rax  ;   dst = src_1 - src_2 - borrow |  mov  :  no flags affected
    mov  rax, [rdx + r11 + 7 * LEN_LNUM_ELE]  ;   src_1                        |  mov  :  no flags affected
    sbb  rax, [ r8 + r11 + 7 * LEN_LNUM_ELE]  ;   src_1 - src_2 - borrow       |  sbb  :  CF is set regarding the carry value (OK: wished behaviour)
    mov  [r10 + r11 + 7 * LEN_LNUM_ELE], rax  ;   dst = src_1 - src_2 - borrow |  mov  :  no flags affected

    lahf                                             ;   save carry flag

    lea  r11, [r11 + 8 * LEN_LNUM_ELE]             ;   increase pointer offset
    sub  rcx, 8                                    ;   subtract the processed words
    jge  karatsuba_sub_unroll_loop_8               ;   keep up the loop, until there are not enough words left

karatsuba_sub_unroll_8_end:
;    ---------------------------------------------------
;   |            REGISTER STATUS                        |
;   |  dest: R10         src1: RDX                      |
;   |  src2: R8          word for addition - 8 : RCX    |
;   |  temp: RAX         offset: R11                    |
;    ---------------------------------------------------
    add  rcx, 8                             ;   Add back the missing 8 words from the count

    sahf                                    ;   load carry flag
    jrcxz karatsuba_sub_single_loop_end     ;   If no words for addition are left, jump to carry propagation

karatsuba_sub_loop:
    mov   rax, [ rdx + r11 ]                ;   RAX = src1
    sbb   rax, [ r8 + r11 ]                 ;   src1 - src2 - borrow    | borrow set
    mov   [ r10 + r11 ], rax                ;   dest = src1 - src2 - borrow
    lea   r11, [ r11 + LEN_LNUM_ELE ]       ;   increment index
    loop karatsuba_sub_loop                 ;   loop over the entire length. src1 and src2 are equal length

karatsuba_sub_single_loop_end:
    mov   rax, 0                            ;   clear eax, without affecting carry flag
    adc   rax, 0                            ;   add the borrow out to eax

    ret
m_impl_sub_karatsuba endp

;extern "C" void m_impl_add_word(LNUM_WORD* ap_dest_a,
;                                LNUM_WORD up_b);
m_impl_add_word proc
;-----------------------------------------------------------------------------------------;
;  Calling convention: Microsoft x64                                                      ;
;-----------------------------------------------------------------------------------------;
;           scratch (volatile) registers:   RAX, RCX, RDX, R8, R9, R10, R11               ;
;   callee-save (non-volatile) registers:   RBX, RBP, RDI, RSI, RSP, R12, R13, R14, R15   ;
;                    parameter registers:   RCX, RDX, R8, R9                              ;
;-----------------------------------------------------------------------------------------;

    add   [rcx], rdx                        ;   dest = dest + src   | carry set

    jnc add_word_end                        ;   if no carry was generated, jump to the end

add_word_loop:
    lea   rcx, [rcx + LEN_LNUM_ELE]         ;   increment destination pointer directly. This is so simple, no index needed
    adc   QWORD PTR[rcx], 0                ;   dest = dest + carry | carry set
    jc add_word_loop                        ;   repeat, while we generate carry

add_word_end:

    ret
m_impl_add_word endp

m_impl_sqr_8 proc
;-----------------------------------------------------------------------------------------;
;  Calling convention: Microsoft x64                                                      ;
;-----------------------------------------------------------------------------------------;
;           scratch (volatile) registers:   RAX, RCX, RDX, R8, R9, R10, R11               ;
;   callee-save (non-volatile) registers:   RBX, RBP, RDI, RSI, RSP, R12, R13, R14, R15   ;
;                    parameter registers:   RCX, RDX, R8, R9                              ;
;-----------------------------------------------------------------------------------------;
    push  rsi
    push r12
    mov  rsi, rdx
    xor  r9, r9                             ;   clear R9 as temporary
    xor  r12, r12                           ;   clear R12 as temporary

;    -----------------------------------
;   |            REGISTER STATUS        |
;   |  dest: rcx            src: RSI    |
;   |  temporaries: R8-R12              |
;    -----------------------------------

    mov  rax, [ rsi ]                           ;   RAX = src[0]
    mul  rax                                    ;   (RDX|RAX) = u|v = src[0]^2
    mov  [ rcx ], rax                           ;   dest[0] = v
    mov  r8, rdx                                ;   c_low = u

;    -----------------------------------
;   |            REGISTER STATUS        |
;   |  dest: rcx            src: RSI    |
;   |  c_low: R8            c_high: R9  |
;    -----------------------------------

    mov  rax, [ rsi + LEN_LNUM_ELE*0 ]          ;   RAX = src[0]
    mul  QWORD PTR [ rsi + LEN_LNUM_ELE*1 ]     ;   (RDX|RAX) = u|v = src[0]*src[1]
    mov  r10, rax                               ;   sum_low = v
    mov  r11, rdx                               ;   sum_mid = u
    add  r10, r10                               ;   sum_low = 2*sum_low             |   carry set
    adc  r11, r11                               ;   sum_mid = 2*sum_mid + cf        |   carry set
    adc  r12, r12                               ;   sum_high = 2*sum_high + cf      |   will not cause carry
    add  r10, r8                                ;   sum_low = sum_low + c_low       |   carry set
    adc  r11, r9                                ;   sum_mid = sum_mid + c_mid + cf  |   carry set
    adc  r12, 0                                 ;   sum_high = sum_high + cf        |   carry propagation only
    mov  [ rcx + LEN_LNUM_ELE ], r10            ;   dest[1] = sum_low
    xor  r10, r10                               ;   clear sum_low

;    -----------------------------------
;   |            REGISTER STATUS        |
;   |  dest: rcx            src: RSI    |
;   |  c_low: R11           c_high: R12 |
;   |  cleared temp: R10                |
;    -----------------------------------

    mov  rax, [ rsi + LEN_LNUM_ELE*0 ]          ;   RAX = src[0]
    mul  QWORD PTR [ rsi + LEN_LNUM_ELE*2 ]     ;   (RDX|RAX) = u|v = src[0]*src[2]
    mov  r8, rax                               ;   sum_low = v
    mov  r9, rdx                               ;   sum_mid = u
    add  r8, r8                               ;   sum_low = 2*sum_low             |   carry set
    adc  r9, r9                               ;   sum_mid = 2*sum_mid + cf        |   carry set
    adc  r10, r10                               ;   sum_high = 2*sum_high + cf      |   will not cause carry
    add  r8, r11                                ;   sum_low = sum_low + c_low       |   carry set
    adc  r9, r12                                ;   sum_mid = sum_mid + c_mid + cf  |   carry set
    adc  r10, 0                                 ;   sum_high = sum_high + cf        |   carry propagation only
    mov  rax, [ rsi + LEN_LNUM_ELE*1 ]          ;   RAX = src[1]
    mul  rax                                    ;   (RDX|RAX) = u|v = src[1]^2
    add  r8, rax                               ;   sum_low = sum_low + v           |   carry set
    adc  r9, rdx                               ;   sum_mid = sum_mid + u +cf       |   carry set
    adc  r10, 0                                 ;   sum_high = sum_high + cf        |   carry propagation only
    mov  [ rcx + 2*LEN_LNUM_ELE ], r8           ;   dest[2] = sum_low
    xor  r8, r8                                 ;   clear sum_low

;    -----------------------------------
;   |            REGISTER STATUS        |
;   |  dest: rcx            src: RSI    |
;   |  c_low: R9            c_high: R10 |
;   |  cleared temp: R8                 |
;    -----------------------------------

    mov  rax, [ rsi + LEN_LNUM_ELE*0 ]          ;   RAX = src[0]
    mul  QWORD PTR [ rsi + LEN_LNUM_ELE*3 ]     ;   (RDX|RAX) = u|v = src[0]*src[3]
    mov  r11, rax                               ;   sum_low = v
    mov  r12, rdx                               ;   sum_mid = u
    mov  rax, [ rsi + LEN_LNUM_ELE*1 ]          ;   RAX = src[1]
    mul  QWORD PTR [ rsi + LEN_LNUM_ELE*2 ]     ;   (RDX|RAX) = u|v = src[1]*src[2]
    add  r11, rax                               ;   sum_low = sum_low + v           |   carry set
    adc  r12, rdx                               ;   sum_mid = sum_mid + u +cf       |   carry set
    adc  r8, 0                                 ;   sum_high = sum_high + cf        |   carry propagation only
    add  r11, r11                               ;   sum_low = 2*sum_low             |   carry set
    adc  r12, r12                               ;   sum_mid = 2*sum_mid + cf        |   carry set
    adc  r8, r8                               ;   sum_high = 2*sum_high + cf      |   will not cause carry
    add  r11, r9                                ;   sum_low = sum_low + c_low       |   carry set
    adc  r12, r10                                ;   sum_mid = sum_mid + c_mid + cf  |   carry set
    adc  r8, 0                                 ;   sum_high = sum_high + cf        |   carry propagation only
    mov  [ rcx + 3*LEN_LNUM_ELE ], r11          ;   dest[3] = sum_low
    xor  r11, r11                               ;   clear sum_low

;    -----------------------------------
;   |            REGISTER STATUS        |
;   |  dest: rcx            src: RSI    |
;   |  c_low: R12           c_high: R8  |
;   |  cleared temp: R11                |
;    -----------------------------------

    mov  rax, [ rsi + LEN_LNUM_ELE*0 ]          ;   RAX = src[0]
    mul  QWORD PTR [ rsi + LEN_LNUM_ELE*4 ]     ;   (RDX|RAX) = u|v = src[0]*src[4]
    mov  r9, rax                               ;   sum_low = v
    mov  r10, rdx                               ;   sum_mid = u
    mov  rax, [ rsi + LEN_LNUM_ELE*1 ]          ;   RAX = src[1]
    mul  QWORD PTR [ rsi + LEN_LNUM_ELE*3 ]     ;   (RDX|RAX) = u|v = src[1]*src[3]
    add  r9, rax                               ;   sum_low = sum_low + v           |   carry set
    adc  r10, rdx                               ;   sum_mid = sum_mid + u +cf       |   carry set
    adc  r11, 0                                 ;   sum_high = sum_high + cf        |   carry propagation only
    add  r9, r9                               ;   sum_low = 2*sum_low             |   carry set
    adc  r10, r10                               ;   sum_mid = 2*sum_mid + cf        |   carry set
    adc  r11, r11                               ;   sum_high = 2*sum_high + cf      |   will not cause carry
    add  r9, r12                                ;   sum_low = sum_low + c_low       |   carry set
    adc  r10, r8                                ;   sum_mid = sum_mid + c_mid + cf  |   carry set
    adc  r11, 0                                 ;   sum_high = sum_high + cf        |   carry propagation only
    mov  rax, [ rsi + LEN_LNUM_ELE*2 ]          ;   RAX = src[2]
    mul  rax                                    ;   (RDX|RAX) = u|v = src[2]^2
    add  r9, rax                               ;   sum_low = sum_low + v           |   carry set
    adc  r10, rdx                               ;   sum_mid = sum_mid + u +cf       |   carry set
    adc  r11, 0                                 ;   sum_high = sum_high + cf        |   carry propagation only
    mov  [ rcx + 4*LEN_LNUM_ELE ], r9           ;   dest[4] = sum_low
    xor  r9, r9                                 ;   clear sum_low

;    -----------------------------------
;   |            REGISTER STATUS        |
;   |  dest: rcx            src: RSI    |
;   |  c_low: R10           c_high: R11 |
;   |  cleared temp: R9                 |
;    -----------------------------------

    mov  rax, [ rsi + LEN_LNUM_ELE*0 ]          ;   RAX = src[0]
    mul  QWORD PTR [ rsi + LEN_LNUM_ELE*5 ]     ;   (RDX|RAX) = u|v = src[0]*src[5]
    mov  r12, rax                               ;   sum_low = v
    mov  r8, rdx                               ;   sum_mid = u
    mov  rax, [ rsi + LEN_LNUM_ELE*1 ]          ;   RAX = src[1]
    mul  QWORD PTR [ rsi + LEN_LNUM_ELE*4 ]     ;   (RDX|RAX) = u|v = src[1]*src[4]
    add  r12, rax                               ;   sum_low = sum_low + v           |   carry set
    adc  r8, rdx                               ;   sum_mid = sum_mid + u +cf       |   carry set
    adc  r9, 0                                 ;   sum_high = sum_high + cf        |   carry propagation only
    mov  rax, [ rsi + LEN_LNUM_ELE*2 ]          ;   RAX = src[2]
    mul  QWORD PTR [ rsi + LEN_LNUM_ELE*3 ]     ;   (RDX|RAX) = u|v = src[2]*src[3]
    add  r12, rax                               ;   sum_low = sum_low + v           |   carry set
    adc  r8, rdx                               ;   sum_mid = sum_mid + u +cf       |   carry set
    adc  r9, 0                                 ;   sum_high = sum_high + cf        |   carry propagation only
    add  r12, r12                               ;   sum_low = 2*sum_low             |   carry set
    adc  r8, r8                               ;   sum_mid = 2*sum_mid + cf        |   carry set
    adc  r9, r9                               ;   sum_high = 2*sum_high + cf      |   will not cause carry
    add  r12, r10                                ;   sum_low = sum_low + c_low       |   carry set
    adc  r8, r11                                ;   sum_mid = sum_mid + c_mid + cf  |   carry set
    adc  r9, 0                                 ;   sum_high = sum_high + cf        |   carry propagation only
    mov  [ rcx + 5*LEN_LNUM_ELE ], r12          ;   dest[5] = sum_low
    xor  r12, r12                               ;   clear sum_low

;    -----------------------------------
;   |            REGISTER STATUS        |
;   |  dest: rcx            src: RSI    |
;   |  c_low: R8            c_high: R9  |
;   |  cleared temp: R12                |
;    -----------------------------------

    mov  rax, [ rsi + LEN_LNUM_ELE*0 ]          ;   RAX = src[0]
    mul  QWORD PTR [ rsi + LEN_LNUM_ELE*6 ]     ;   (RDX|RAX) = u|v = src[0]*src[6]
    mov  r10, rax                               ;   sum_low = v
    mov  r11, rdx                               ;   sum_mid = u
    mov  rax, [ rsi + LEN_LNUM_ELE*1 ]          ;   RAX = src[1]
    mul  QWORD PTR [ rsi + LEN_LNUM_ELE*5 ]     ;   (RDX|RAX) = u|v = src[1]*src[5]
    add  r10, rax                               ;   sum_low = sum_low + v           |   carry set
    adc  r11, rdx                               ;   sum_mid = sum_mid + u +cf       |   carry set
    adc  r12, 0                                 ;   sum_high = sum_high + cf        |   carry propagation only
    mov  rax, [ rsi + LEN_LNUM_ELE*2 ]          ;   RAX = src[2]
    mul  QWORD PTR [ rsi + LEN_LNUM_ELE*4 ]     ;   (RDX|RAX) = u|v = src[2]*src[4]
    add  r10, rax                               ;   sum_low = sum_low + v           |   carry set
    adc  r11, rdx                               ;   sum_mid = sum_mid + u +cf       |   carry set
    adc  r12, 0                                 ;   sum_high = sum_high + cf        |   carry propagation only
    add  r10, r10                               ;   sum_low = 2*sum_low             |   carry set
    adc  r11, r11                               ;   sum_mid = 2*sum_mid + cf        |   carry set
    adc  r12, r12                               ;   sum_high = 2*sum_high + cf      |   will not cause carry
    add  r10, r8                                ;   sum_low = sum_low + c_low       |   carry set
    adc  r11, r9                                ;   sum_mid = sum_mid + c_mid + cf  |   carry set
    adc  r12, 0                                 ;   sum_high = sum_high + cf        |   carry propagation only
    mov  rax, [ rsi + LEN_LNUM_ELE*3 ]          ;   RAX = src[3]
    mul  rax                                    ;   (RDX|RAX) = u|v = src[3]^2
    add  r10, rax                               ;   sum_low = sum_low + v           |   carry set
    adc  r11, rdx                               ;   sum_mid = sum_mid + u +cf       |   carry set
    adc  r12, 0                                 ;   sum_high = sum_high + cf        |   carry propagation only
    mov  [ rcx + 6*LEN_LNUM_ELE ], r10          ;   dest[6] = sum_low
    xor  r10, r10                               ;   clear sum_low

;    -----------------------------------
;   |            REGISTER STATUS        |
;   |  dest: rcx            src: RSI    |
;   |  c_low: R11           c_high: R12 |
;   |  cleared temp: R10                |
;    -----------------------------------

    mov  rax, [ rsi + LEN_LNUM_ELE*0 ]          ;   RAX = src[0]
    mul  QWORD PTR [ rsi + LEN_LNUM_ELE*7 ]     ;   (RDX|RAX) = u|v = src[0]*src[7]
    mov  r8, rax                               ;   sum_low = v
    mov  r9, rdx                               ;   sum_mid = u
    mov  rax, [ rsi + LEN_LNUM_ELE*1 ]          ;   RAX = src[1]
    mul  QWORD PTR [ rsi + LEN_LNUM_ELE*6 ]     ;   (RDX|RAX) = u|v = src[1]*src[6]
    add  r8, rax                               ;   sum_low = sum_low + v           |   carry set
    adc  r9, rdx                               ;   sum_mid = sum_mid + u +cf       |   carry set
    adc  r10, 0                                 ;   sum_high = sum_high + cf        |   carry propagation only
    mov  rax, [ rsi + LEN_LNUM_ELE*2 ]          ;   RAX = src[2]
    mul  QWORD PTR [ rsi + LEN_LNUM_ELE*5 ]     ;   (RDX|RAX) = u|v = src[2]*src[5]
    add  r8, rax                               ;   sum_low = sum_low + v           |   carry set
    adc  r9, rdx                               ;   sum_mid = sum_mid + u +cf       |   carry set
    adc  r10, 0                                 ;   sum_high = sum_high + cf        |   carry propagation only
    mov  rax, [ rsi + LEN_LNUM_ELE*3 ]          ;   RAX = src[3]
    mul  QWORD PTR [ rsi + LEN_LNUM_ELE*4 ]     ;   (RDX|RAX) = u|v = src[3]*src[4]
    add  r8, rax                               ;   sum_low = sum_low + v           |   carry set
    adc  r9, rdx                               ;   sum_mid = sum_mid + u +cf       |   carry set
    adc  r10, 0                                 ;   sum_high = sum_high + cf        |   carry propagation only
    add  r8, r8                               ;   sum_low = 2*sum_low             |   carry set
    adc  r9, r9                               ;   sum_mid = 2*sum_mid + cf        |   carry set
    adc  r10, r10                               ;   sum_high = 2*sum_high + cf      |   will not cause carry
    add  r8, r11                                ;   sum_low = sum_low + c_low       |   carry set
    adc  r9, r12                                ;   sum_mid = sum_mid + c_mid + cf  |   carry set
    adc  r10, 0                                 ;   sum_high = sum_high + cf        |   carry propagation only
    mov  [ rcx + 7*LEN_LNUM_ELE ], r8           ;   dest[7] = sum_low
    xor  r8, r8                                 ;   clear sum_low

;    -----------------------------------
;   |            REGISTER STATUS        |
;   |  dest: rcx            src: RSI    |
;   |  c_low: R9            c_high: R10 |
;   |  cleared temp: R8                 |
;    -----------------------------------

    mov  rax, [ rsi + LEN_LNUM_ELE*1 ]          ;   RAX = src[1]
    mul  QWORD PTR [ rsi + LEN_LNUM_ELE*7 ]     ;   (RDX|RAX) = u|v = src[1]*src[7]
    mov  r11, rax                               ;   sum_low = v
    mov  r12, rdx                               ;   sum_mid = u
    mov  rax, [ rsi + LEN_LNUM_ELE*2 ]          ;   RAX = src[2]
    mul  QWORD PTR [ rsi + LEN_LNUM_ELE*6 ]     ;   (RDX|RAX) = u|v = src[2]*src[6]
    add  r11, rax                               ;   sum_low = sum_low + v           |   carry set
    adc  r12, rdx                               ;   sum_mid = sum_mid + u +cf       |   carry set
    adc  r8, 0                                 ;   sum_high = sum_high + cf        |   carry propagation only
    mov  rax, [ rsi + LEN_LNUM_ELE*3 ]          ;   RAX = src[3]
    mul  QWORD PTR [ rsi + LEN_LNUM_ELE*5 ]     ;   (RDX|RAX) = u|v = src[3]*src[5]
    add  r11, rax                               ;   sum_low = sum_low + v           |   carry set
    adc  r12, rdx                               ;   sum_mid = sum_mid + u +cf       |   carry set
    adc  r8, 0                                 ;   sum_high = sum_high + cf        |   carry propagation only
    add  r11, r11                               ;   sum_low = 2*sum_low             |   carry set
    adc  r12, r12                               ;   sum_mid = 2*sum_mid + cf        |   carry set
    adc  r8, r8                               ;   sum_high = 2*sum_high + cf      |   will not cause carry
    add  r11, r9                                ;   sum_low = sum_low + c_low       |   carry set
    adc  r12, r10                                ;   sum_mid = sum_mid + c_mid + cf  |   carry set
    adc  r8, 0                                 ;   sum_high = sum_high + cf        |   carry propagation only
    mov  rax, [ rsi + LEN_LNUM_ELE*4 ]          ;   RAX = src[4]
    mul  rax                                    ;   (RDX|RAX) = u|v = src[4]^2
    add  r11, rax                               ;   sum_low = sum_low + v           |   carry set
    adc  r12, rdx                               ;   sum_mid = sum_mid + u +cf       |   carry set
    adc  r8, 0                                 ;   sum_high = sum_high + cf        |   carry propagation only
    mov  [ rcx + 8*LEN_LNUM_ELE ], r11          ;   dest[8] = sum_low
    xor  r11, r11                               ;   clear sum_low

;    -----------------------------------
;   |            REGISTER STATUS        |
;   |  dest: rcx            src: RSI    |
;   |  c_low: R12           c_high: R8  |
;   |  cleared temp: R11                |
;    -----------------------------------

    mov  rax, [ rsi + LEN_LNUM_ELE*2 ]          ;   RAX = src[2]
    mul  QWORD PTR [ rsi + LEN_LNUM_ELE*7 ]     ;   (RDX|RAX) = u|v = src[2]*src[7]
    mov  r9, rax                               ;   sum_low = v
    mov  r10, rdx                               ;   sum_mid = u
    mov  rax, [ rsi + LEN_LNUM_ELE*3 ]          ;   RAX = src[3]
    mul  QWORD PTR [ rsi + LEN_LNUM_ELE*6 ]     ;   (RDX|RAX) = u|v = src[3]*src[6]
    add  r9, rax                               ;   sum_low = sum_low + v           |   carry set
    adc  r10, rdx                               ;   sum_mid = sum_mid + u +cf       |   carry set
    adc  r11, 0                                 ;   sum_high = sum_high + cf        |   carry propagation only
    mov  rax, [ rsi + LEN_LNUM_ELE*4 ]          ;   RAX = src[4]
    mul  QWORD PTR [ rsi + LEN_LNUM_ELE*5 ]     ;   (RDX|RAX) = u|v = src[4]*src[5]
    add  r9, rax                               ;   sum_low = sum_low + v           |   carry set
    adc  r10, rdx                               ;   sum_mid = sum_mid + u +cf       |   carry set
    adc  r11, 0                                 ;   sum_high = sum_high + cf        |   carry propagation only
    add  r9, r9                               ;   sum_low = 2*sum_low             |   carry set
    adc  r10, r10                               ;   sum_mid = 2*sum_mid + cf        |   carry set
    adc  r11, r11                               ;   sum_high = 2*sum_high + cf      |   will not cause carry
    add  r9, r12                                ;   sum_low = sum_low + c_low       |   carry set
    adc  r10, r8                                ;   sum_mid = sum_mid + c_mid + cf  |   carry set
    adc  r11, 0                                 ;   sum_high = sum_high + cf        |   carry propagation only
    mov  [ rcx + 9*LEN_LNUM_ELE ], r9           ;   dest[9] = sum_low
    xor  r9, r9                                 ;   clear sum_low

;    -----------------------------------
;   |            REGISTER STATUS        |
;   |  dest: rcx            src: RSI    |
;   |  c_low: R10           c_high: R11 |
;   |  cleared temp: R9                 |
;    -----------------------------------

    mov  rax, [ rsi + LEN_LNUM_ELE*3 ]          ;   RAX = src[3]
    mul  QWORD PTR [ rsi + LEN_LNUM_ELE*7 ]     ;   (RDX|RAX) = u|v = src[3]*src[7]
    mov  r12, rax                               ;   sum_low = v
    mov  r8, rdx                               ;   sum_mid = u
    mov  rax, [ rsi + LEN_LNUM_ELE*4 ]          ;   RAX = src[4]
    mul  QWORD PTR [ rsi + LEN_LNUM_ELE*6 ]     ;   (RDX|RAX) = u|v = src[4]*src[6]
    add  r12, rax                               ;   sum_low = sum_low + v           |   carry set
    adc  r8, rdx                               ;   sum_mid = sum_mid + u +cf       |   carry set
    adc  r9, 0                                 ;   sum_high = sum_high + cf        |   carry propagation only
    add  r12, r12                               ;   sum_low = 2*sum_low             |   carry set
    adc  r8, r8                               ;   sum_mid = 2*sum_mid + cf        |   carry set
    adc  r9, r9                               ;   sum_high = 2*sum_high + cf      |   will not cause carry
    add  r12, r10                                ;   sum_low = sum_low + c_low       |   carry set
    adc  r8, r11                                ;   sum_mid = sum_mid + c_mid + cf  |   carry set
    adc  r9, 0                                 ;   sum_high = sum_high + cf        |   carry propagation only
    mov  rax, [ rsi + LEN_LNUM_ELE*5 ]          ;   RAX = src[5]
    mul  rax                                    ;   (RDX|RAX) = u|v = src[5]^2
    add  r12, rax                               ;   sum_low = sum_low + v           |   carry set
    adc  r8, rdx                               ;   sum_mid = sum_mid + u +cf       |   carry set
    adc  r9, 0                                 ;   sum_high = sum_high + cf        |   carry propagation only
    mov  [ rcx + 10*LEN_LNUM_ELE ], r12         ;   dest[10] = sum_low
    xor  r12, r12                               ;   clear sum_low

;    -----------------------------------
;   |            REGISTER STATUS        |
;   |  dest: rcx            src: RSI    |
;   |  c_low: R8            c_high: R9  |
;   |  cleared temp: R12                |
;    -----------------------------------

    mov  rax, [ rsi + LEN_LNUM_ELE*4 ]          ;   RAX = src[4]
    mul  QWORD PTR [ rsi + LEN_LNUM_ELE*7 ]     ;   (RDX|RAX) = u|v = src[4]*src[7]
    mov  r10, rax                               ;   sum_low = v
    mov  r11, rdx                               ;   sum_mid = u
    mov  rax, [ rsi + LEN_LNUM_ELE*5 ]          ;   RAX = src[5]
    mul  QWORD PTR [ rsi + LEN_LNUM_ELE*6 ]     ;   (RDX|RAX) = u|v = src[5]*src[6]
    add  r10, rax                               ;   sum_low = sum_low + v           |   carry set
    adc  r11, rdx                               ;   sum_mid = sum_mid + u +cf       |   carry set
    adc  r12, 0                                 ;   sum_high = sum_high + cf        |   carry propagation only
    add  r10, r10                               ;   sum_low = 2*sum_low             |   carry set
    adc  r11, r11                               ;   sum_mid = 2*sum_mid + cf        |   carry set
    adc  r12, r12                               ;   sum_high = 2*sum_high + cf      |   will not cause carry
    add  r10, r8                                ;   sum_low = sum_low + c_low       |   carry set
    adc  r11, r9                                ;   sum_mid = sum_mid + c_mid + cf  |   carry set
    adc  r12, 0                                 ;   sum_high = sum_high + cf        |   carry propagation only
    mov  [ rcx + 11*LEN_LNUM_ELE ], r10         ;   dest[11] = sum_low
    xor  r10, r10                               ;   clear sum_low

;    -----------------------------------
;   |            REGISTER STATUS        |
;   |  dest: rcx            src: RSI    |
;   |  c_low: R11           c_high: R12 |
;   |  cleared temp: R10                |
;    -----------------------------------

    mov  rax, [ rsi + LEN_LNUM_ELE*5 ]          ;   RAX = src[5]
    mul  QWORD PTR [ rsi + LEN_LNUM_ELE*7 ]     ;   (RDX|RAX) = u|v = src[5]*src[7]
    mov  r8, rax                               ;   sum_low = v
    mov  r9, rdx                               ;   sum_mid = u
    add  r8, r8                               ;   sum_low = 2*sum_low             |   carry set
    adc  r9, r9                               ;   sum_mid = 2*sum_mid + cf        |   carry set
    adc  r10, r10                               ;   sum_high = 2*sum_high + cf      |   will not cause carry
    add  r8, r11                                ;   sum_low = sum_low + c_low       |   carry set
    adc  r9, r12                                ;   sum_mid = sum_mid + c_mid + cf  |   carry set
    adc  r10, 0                                 ;   sum_high = sum_high + cf        |   carry propagation only
    mov  rax, [ rsi + LEN_LNUM_ELE*6 ]          ;   RAX = src[6]
    mul  rax                                    ;   (RDX|RAX) = u|v = src[6]^2
    add  r8, rax                               ;   sum_low = sum_low + v           |   carry set
    adc  r9, rdx                               ;   sum_mid = sum_mid + u +cf       |   carry set
    adc  r10, 0                                 ;   sum_high = sum_high + cf        |   carry propagation only
    mov  [ rcx + 12*LEN_LNUM_ELE ], r8          ;   dest[12] = sum_low
    xor  r8, r8                                 ;   clear sum_low

;    -----------------------------------
;   |            REGISTER STATUS        |
;   |  dest: rcx            src: RSI    |
;   |  c_low: R9            c_high: R10 |
;   |  cleared temp: R8                 |
;    -----------------------------------

    mov  rax, [ rsi + LEN_LNUM_ELE*6 ]          ;   RAX = src[6]
    mul  QWORD PTR [ rsi + LEN_LNUM_ELE*7 ]     ;   (RDX|RAX) = u|v = src[6]*src[7]
    mov  r11, rax                               ;   sum_low = v
    mov  r12, rdx                               ;   sum_mid = u
    add  r11, r11                               ;   sum_low = 2*sum_low             |   carry set
    adc  r12, r12                               ;   sum_mid = 2*sum_mid + cf        |   carry set
    adc  r8, r8                               ;   sum_high = 2*sum_high + cf      |   will not cause carry
    add  r11, r9                                ;   sum_low = sum_low + c_low       |   carry set
    adc  r12, r10                                ;   sum_mid = sum_mid + c_mid + cf  |   carry set
    adc  r8, 0                                 ;   sum_high = sum_high + cf        |   carry propagation only
    mov  [ rcx + 13*LEN_LNUM_ELE ], r11         ;   dest[13] = sum_low
    xor  r11, r11                               ;   clear sum_low

;    -----------------------------------
;   |            REGISTER STATUS        |
;   |  dest: rcx            src: RSI    |
;   |  c_low: R12           c_high: R8  |
;   |  cleared temp: R11                |
;    -----------------------------------

    mov  rax, [ rsi + 7*LEN_LNUM_ELE ]
    mul  rax
    add  r12, rax
    adc  r8, rdx
    mov  [ rcx + 14*LEN_LNUM_ELE ], r12          ;   dest[14] = sum_low
    mov  [ rcx + 15*LEN_LNUM_ELE ], r8           ;   dest[15] = sum_mid

    pop  r12
    pop   rsi
    ret
m_impl_sqr_8 endp

;extern "C"
;void m_impl_mont_mul_add(LNUM_WORD* aurp_prod,
;                         LNUM_WORD urp_n_0_inv,
;                         const LNUM_WORD* aurp_mod,
;                         size_t szp_mod_len,
;                         const LNUM_WORD* aurp_src);
m_impl_mont_mul_add proc
;-----------------------------------------------------------------------------------------;
;  Calling convention: Microsoft x64                                                      ;
;-----------------------------------------------------------------------------------------;
;           scratch (volatile) registers:   RAX, RCX, RDX, R8, R9, R10, R11               ;
;   callee-save (non-volatile) registers:   RBX, RBP, RDI, RSI, RSP, R12, R13, R14, R15   ;
;                    parameter registers:   RCX, RDX, R8, R9                              ;
;-----------------------------------------------------------------------------------------;
;    ---------------------------------------
;   |            REGISTER STATUS            |
;   |  dest: RCX         m_0_inv: RDX       |
;   |  mod:  R8          mod_len: R9        |
;   |  P:    stack                          |
;    ---------------------------------------
    mov  r10, rcx                       ;   destination to R10, freeing RCX
    mov  rcx, [rsp+028H]                ;   RCX = P (accesing position of the 5th parameter).
                                        ;       0x28 bytes = 0x20 shadow space + 8 return address
    test  r9, 63
    jz    ms_impl_mont_mul_add_8
    cmp   r9, 8
    je    ms_impl_mont_mul_add_1
    push  rsi
    push  rdi
    push  rbx
    push  r12
    push  r13
    push  r14
    push  r15
;    ---------------------------------------
;   |            REGISTER STATUS            |
;   |  dest: R10         m_0_inv: RDX       |
;   |  mod:  R8          mod_len: R9        |
;   |  P:    RCX                            |
;    ---------------------------------------

    lea  r10, [r10 + r9]                        ;   move dest to the second half of the buffer for consistency

;   the case i=0 is handled here
    mov  rax, [rcx]                             ;   RAX = P[0]
    xor  r12, r12                               ;   t = 0
    mov  r14, rax                               ;   v = P[0]
    mov  r15, [R8]                              ;   R15 = m[0]
    xor  r13, r13                               ;   u = 0
    mov  rsi, rdx                               ;   RSI = m_0_inv       |   free RDX for MUL
    mul  rsi                                    ;   (RDX|RAX) = v*m_0_inv
    mov  [r10], rax                             ;   dest[0] = v*m_0_inv mod 2^w
    mul  r15                                    ;   (RDX|RAX) = dest[0]*m[0]

    mov  rdi, LEN_LNUM_ELE                      ;   Load first loop index
    add  rax, r14                               ;   v = v+RAX                   |   can generate carry
    adc  rdx, 0                                 ;   u = u(is 0)+ RDX + carry    |   can generate carry
    adc  r13, 0                                 ;   combine t = t+carry; u=t    |   no carry
    mov  r14, rdx                               ;   v = RAX

mont_mul_add_growing_loop_outer:
;    ---------------------------------------
;   |            REGISTER STATUS            |
;   |  dest: R10         m_0_inv:      RSI  |
;   |  m_i:  R8          mod_word_len: R9   |
;   |  P:    RCX         m_0:          R15  |
;   |  cur_i_off: RDI                       |
;   |  (t,u,v): R12,R13,R14                 |
;    ---------------------------------------
    xor  r11, r11                               ;   Reset inner index j
    lea  r8, [ r8 + rdi]                        ;   m_cur = m_(i) for inner loop
mont_mul_add_growing_loop_inner:
    mov  rax, [r8]                              ;   RAX = m[i-j]
    mul  QWORD PTR[ r10 + r11 ]              ;   (RDX|RAX) = m[i-j]*dest[j]
    add  r14, rax                               ;   v = v + RAX         |   carry possible
    adc  r13, rdx                               ;   u = u + RDX + carry |   carry possible
    adc  r12, 0                                 ;   t = t + carry       |   no carry
    lea  r8, [ r8 - LEN_LNUM_ELE ]              ;   m[i-j] = m[i-(j+1)]
    lea  r11, [ r11 + LEN_LNUM_ELE ]            ;   j++
    cmp  r11, rdi                               ;   check i > j
    jl   mont_mul_add_growing_loop_inner        ;   loop while i > j

    add  r14, [rcx + rdi]                       ;   v = v + P[i]    |   carry possible
    adc  r13, 0                                 ;   u = u + carry   |   carry possible
    adc  r12, 0                                 ;   t = t + carry   |   no carry
    mov  rax, r14                               ;   RAX = v
    mul  rsi                                    ;   (RDX|RAX) = v*m_0_inv
    mov  [ r10 + r11 ], rax                     ;   dest[i] = v*m_0_inv mod 2^w
    mul  r15                                    ;   (RDX|RAX) = dest[i]*m[0]
    add  r14, rax                               ;   v = v + RAX         |   carry possible
    adc  r13, rdx                               ;   u = u + RDX + carry |   carry possible
    adc  r12, 0                                 ;   t = t + carry       |   no carry
    mov  r14, r13                               ;   v = u
    mov  r13, r12                               ;   u = t
    xor  r12, r12                               ;   t = 0
    lea  rdi, [ rdi + LEN_LNUM_ELE ]            ;   i++
    cmp  rdi, r9                                ;   check i < mod_len
    jl   mont_mul_add_growing_loop_outer        ;   loop while i < mod_len

    lea  rcx, [rcx+r9]                          ;   P = P + s
    xor  rdi, rdi                               ;   i = 0
    sub  r9, LEN_LNUM_ELE                       ;   calculate s-1 offset

mont_mul_add_shrinking_loop_outer:
;    ---------------------------------------
;   |            REGISTER STATUS            |
;   |  dest: R10         m_0_inv:      RSI  |
;   |  mod:  R8          s-1 offset:   R9   |
;   |  P[s]: RCX         m_0:          R15  |
;   |  cur_i_off: RDI                       |
;   |  (t,u,v): R12,R13,R14                 |
;    ---------------------------------------
    lea  r11,[rdi + LEN_LNUM_ELE ]              ;   Reset inner index j to i+1
    lea  rbx, [ r8 + r9 ]                       ;   m_cur = m_(s-1) for inner loop
mont_mul_add_shrinking_loop_inner:
    mov  rax, [ rbx ]                           ;   RAX = m[i-j]
    mul  QWORD PTR[ r10 + r11 ]              ;   (RDX|RAX) = m[i-j]*dest[j]
    add  r14, rax                               ;   v = v + RAX         |   carry possible
    adc  r13, rdx                               ;   u = u + RDX + carry |   carry possible
    adc  r12, 0                                 ;   t = t + carry       |   no carry
    lea  rbx, [ rbx - LEN_LNUM_ELE ]            ;   m[i-j] = m[i-(j+1)]
    lea  r11, [ r11 + LEN_LNUM_ELE ]            ;   j++
    cmp  r11, r9                                ;   check j < (s-1)
    jle  mont_mul_add_shrinking_loop_inner      ;   loop while j < (s-1)

    add  r14, [rcx + rdi]                       ;   v = v + P[s+i]  |   carry possible
    adc  r13, 0                                 ;   u = u + carry   |   carry possible
    adc  r12, 0                                 ;   t = t + carry   |   no carry
    mov  [ r10 + rdi ], r14                     ;   dest[i] = v
    mov  r14, r13                               ;   v = u
    mov  r13, r12                               ;   u = t
    xor  r12, r12                               ;   t = 0
    lea  rdi, [ rdi + LEN_LNUM_ELE ]            ;   i++
    cmp  rdi, r9
    jl   mont_mul_add_shrinking_loop_outer

mont_mul_add_end:
    add  r14, [rcx + rdi]
    adc  r13, 0
    mov  [ r10 + r9 ], r14
    mov  [ r10 + r9 + LEN_LNUM_ELE ], r13

    pop  r15
    pop  r14
    pop  r13
    pop  r12
    pop  rbx
    pop   rdi
    pop   rsi
    ret
m_impl_mont_mul_add endp


;extern "C" void m_impl_first_bit(LNUM_WORD url_word)
m_impl_first_bit proc
;-----------------------------------------------------------------------------------------;
;  Calling convention: Microsoft x64                                                      ;
;-----------------------------------------------------------------------------------------;
;           scratch (volatile) registers:   RAX, RCX, RDX, R8, R9, R10, R11               ;
;   callee-save (non-volatile) registers:   RBX, RBP, RDI, RSI, RSP, R12, R13, R14, R15   ;
;                    parameter registers:   RCX, RDX, R8, R9                              ;
;-----------------------------------------------------------------------------------------;
    mov   r8, rcx
    bsf   rax, r8
    ret
m_impl_first_bit endp


;extern "C" void m_impl_last_bit(LNUM_WORD url_word)
m_impl_last_bit proc
;-----------------------------------------------------------------------------------------;
;  Calling convention: Microsoft x64                                                      ;
;-----------------------------------------------------------------------------------------;
;           scratch (volatile) registers:   RAX, RCX, RDX, R8, R9, R10, R11               ;
;   callee-save (non-volatile) registers:   RBX, RBP, RDI, RSI, RSP, R12, R13, R14, R15   ;
;                    parameter registers:   RCX, RDX, R8, R9                              ;
;-----------------------------------------------------------------------------------------;
    mov   r8, rcx
    bsr   rax, r8
    ret
m_impl_last_bit endp
    


    



MONT_8_STACK_CNT       equ  3
MONT_8_DEST_MID_INDEX  equ  LEN_LNUM_ELE
;void ms_impl_mont_mul_add_8(LNUM_WORD* aurp_prod,
;                            LNUM_WORD urp_n_0_inv,
;                            const LNUM_WORD* aurp_mod,
;                            size_t szp_mod_len,
;                            const LNUM_WORD* aurp_src);
ms_impl_mont_mul_add_8 proc
;-----------------------------------------------------------------------------------------;
;  Calling convention: Microsoft x64                                                      ;
;-----------------------------------------------------------------------------------------;
;           scratch (volatile) registers:   RAX, RCX, RDX, R8, R9, R10, R11               ;
;   callee-save (non-volatile) registers:   RBX, RBP, RDI, RSI, RSP, R12, R13, R14, R15   ;
;                    parameter registers:   RCX, RDX, R8, R9                              ;
;-----------------------------------------------------------------------------------------;
    push  rsi
    push  rdi
    push rbp
    push rbx
    push r12
    push r13
    push r14
    push r15
    sub  rsp, LEN_LNUM_ELE*MONT_8_STACK_CNT
;    ---------------------------------------
;   |            REGISTER STATUS            |
;   |  dest: R10         m_0_inv: RDX       |
;   |  mod:  R8          mod_len: R9        |
;   |  P:    RCX                            |
;    ---------------------------------------
    shr  r9, 3                        ;   Scale length parameters from bytes to (64-bit) words    
    mov  rdi, r10
    mov  rbp, r8
    mov  rsi, r9
    movq_r xmm0, rdx                                ;   Store m_0_inv
    lea  r10, [r10+r9*LEN_LNUM_ELE]                 ;   Calcualte z_s
    mov  [rsp+MONT_8_DEST_MID_INDEX], r10           ;   Store z_s

;    ---------------------------------------
;   |            REGISTER STATUS            |
;   |  z_cur:RDI         m_0_inv: XMM0      |
;   |  mod:  RBP         mod_len: RSI       |
;   |  P:    RCX         z_s: [RSP+MONT_8_DEST_MID_INDEX]    |
;    ---------------------------------------
    ;   Instead of setting V = 0 and add P_0, we just load P_0
    mov  r8, [rcx + 0 * LEN_LNUM_ELE]               ;   v_0 = p_0
    mov  r9, [rcx + 1 * LEN_LNUM_ELE]               ;   v_1 = p_1
    mov  r10, [rcx + 2 * LEN_LNUM_ELE]               ;   v_2 = p_2
    mov  r11, [rcx + 3 * LEN_LNUM_ELE]               ;   v_3 = p_3
    mov  r12, [rcx + 4 * LEN_LNUM_ELE]               ;   v_4 = p_4
    mov  r13, [rcx + 5 * LEN_LNUM_ELE]               ;   v_5 = p_5
    mov  r14, [rcx + 6 * LEN_LNUM_ELE]               ;   v_6 = p_6
    mov  r15, [rcx + 7 * LEN_LNUM_ELE]               ;   v_7 = p_7
    lea  rax, [rcx + 8 * LEN_LNUM_ELE ]             ;   Get pointer to next source block
    movq_r xmm1, rax                                ;   Store current src ptr
    mov  rcx, 8                                     ;   Set counter for init loop

mont_mul_add_8_init_loop:
;    ---------------------------------------
;   |            REGISTER STATUS            |
;   |  dest: RDI         m_0_inv: XMM0      |
;   |  mod:  RBP         mod_len: RSI       |
;   |  P:    XMM1        dest_end: [RSP]    |
;    ---------------------------------------
    movq_r rbx, xmm0                                ;   Load m_0_inv
    imul rbx, r8                                    ;   z_(i+l) = v_0*m_0_inv mod 2^64
    mov  rax, [rbp]                                 ;   Load m_0
    mov  [rdi], rbx                                 ;   write z_(i+l)
    lea  rdi, [rdi + LEN_LNUM_ELE]                  ;   l++
    mul  rbx                                        ;   (RDX|RAX)=z_(i+l)*m_0
    neg  r8                                         ;   carry(RAX+v_0)  |   RAX+v_0 = v_0*m_0_inv*m_0 + v_0 = v_0*0xFFFFFFFFFFFFFFFF+v_0, so if v_0 != 0, then carry is set
    mov  rax, [rbp + LEN_LNUM_ELE]                  ;   Load m_1, RAX will be discarded anyway
    adc  rdx, 0                                     ;   RDX += carry
    mov  r8, rdx                                    ;   v_0 = RDX

    mul  rbx                                        ;   (RDX|RAX) = m_1*z_(i+l)
    add  r8, rax                                   ;   v_0 = v_0+RAX
    mov  rax, [rbp + 2*LEN_LNUM_ELE]                ;   Load m_2
    adc  rdx, 0                                     ;   propagate carry
    add  r8, r9                                    ;   v_0 = v_0+v_1
    adc  rdx, 0                                     ;   propagate carry
    mov  r9, rdx                                   ;   v_1 = RDX

    mul  rbx                                        ;   (RDX|RAX) = m_2*z_(i+l)
    add  r9, rax                                   ;   v_1 = v_1+RAX
    mov  rax, [rbp + 3*LEN_LNUM_ELE]                ;   Load m_3
    adc  rdx, 0                                     ;   propagate carry
    add  r9, r10                                    ;   v_1 = v_1+v_2
    adc  rdx, 0                                     ;   propagate carry
    mov  r10, rdx                                   ;   v_2 = RDX

    mul  rbx                                        ;   (RDX|RAX) = m_3*z_(i+l)
    add  r10, rax                                   ;   v_2 = v_2+RAX
    mov  rax, [rbp + 4*LEN_LNUM_ELE]                ;   Load m_4
    adc  rdx, 0                                     ;   propagate carry
    add  r10, r11                                    ;   v_2 = v_2+v_3
    adc  rdx, 0                                     ;   propagate carry
    mov  r11, rdx                                   ;   v_3 = RDX

    mul  rbx                                        ;   (RDX|RAX) = m_4*z_(i+l)
    add  r11, rax                                   ;   v_3 = v_3+RAX
    mov  rax, [rbp + 5*LEN_LNUM_ELE]                ;   Load m_5
    adc  rdx, 0                                     ;   propagate carry
    add  r11, r12                                    ;   v_3 = v_3+v_4
    adc  rdx, 0                                     ;   propagate carry
    mov  r12, rdx                                   ;   v_4 = RDX

    mul  rbx                                        ;   (RDX|RAX) = m_5*z_(i+l)
    add  r12, rax                                   ;   v_4 = v_4+RAX
    mov  rax, [rbp + 6*LEN_LNUM_ELE]                ;   Load m_6
    adc  rdx, 0                                     ;   propagate carry
    add  r12, r13                                    ;   v_4 = v_4+v_5
    adc  rdx, 0                                     ;   propagate carry
    mov  r13, rdx                                   ;   v_5 = RDX

    mul  rbx                                        ;   (RDX|RAX) = m_6*z_(i+l)
    add  r13, rax                                   ;   v_5 = v_5+RAX
    mov  rax, [rbp + 7*LEN_LNUM_ELE]                ;   Load m_7
    adc  rdx, 0                                     ;   propagate carry
    add  r13, r14                                    ;   v_5 = v_5+v_6
    adc  rdx, 0                                     ;   propagate carry
    mov  r14, rdx                                   ;   v_6 = RDX

    mul  rbx                                        ;   (RDX|RAX) = m_7*z_(i+l)
    add  r14, rax                                   ;   v_6 = v_6+RAX
    adc  rdx, 0                                     ;   propagate carry
    add  r14, r15                                    ;   v_6 = v_6+v_7
    adc  rdx, 0                                     ;   propagate carry
    mov  r15, rdx                                   ;   v_7 = RDX


    dec  rcx                                        ;   decrement counter
    mov  r15, rdx                                    ;   v_7 = RDX
    jnz  mont_mul_add_8_init_loop
    
    pxor   xmm4, xmm4                               ;   u = 0
    pxor   xmm5, xmm5                               ;   t = 0

    cmp  rsi, 8                                     ;   Check, if mod_len = b
    je   mont_mul_add_8_final                       ;   if so, skip the loops

    lea  rsi, [rdi + 8*LEN_LNUM_ELE]                ;   Load end of the next block
    mov  [rsp], rsi                                 ;   Store end of next block
    mov  rcx, 8*LEN_LNUM_ELE                        ;   Prepare inner loop counter
    movq_r xmm2, rcx                                ;   Store loop counter
mont_mul_add_8_growing_outer:
;    ---------------------------------------
;   |            REGISTER STATUS            |
;   |  dest: RDI         m_0_inv:  XMM0     |
;   |  mod:  RBP         loop_cnt: XMM2     |
;   |  P:    XMM1        z_s:  [RSP+LEN_LNUM_ELE]   |
;   |  (t|u): XMM5|4     block_end: [RSP]   |
;   |  temp: RSI         V = R8-R15          |
;    ---------------------------------------
    movq_r rax, xmm1                            ;   Load src ptr
    movq_r rsi, xmm4                            ;   Load u
    add  r8, [rax]                              ;   v_0 += p_i              |   carry possible
    adc  r9, [rax+1 * LEN_LNUM_ELE]            ;   v_1 += p_(i+1) + carry  |   carry possible
    adc  r10, [rax+2 * LEN_LNUM_ELE]            ;   v_2 += p_(i+2) + carry  |   carry possible
    adc  r11, [rax+3 * LEN_LNUM_ELE]            ;   v_3 += p_(i+3) + carry  |   carry possible
    adc  r12, [rax+4 * LEN_LNUM_ELE]            ;   v_4 += p_(i+4) + carry  |   carry possible
    adc  r13, [rax+5 * LEN_LNUM_ELE]            ;   v_5 += p_(i+5) + carry  |   carry possible
    adc  r14, [rax+6 * LEN_LNUM_ELE]            ;   v_6 += p_(i+6) + carry  |   carry possible
    adc  r15, [rax+7 * LEN_LNUM_ELE]            ;   v_7 += p_(i+7) + carry  |   carry possible

    adc  rsi, 0                                 ;   u += carry
    movq_r xmm4, rsi                            ;   store u
    lea  rax, [rax + 8*LEN_LNUM_ELE]            ;   Next P_i
    movq_r xmm1, rax                            ;   Store P_i

mont_mul_add_8_growing_inner:
    lea  rdi, [rdi - 8*LEN_LNUM_ELE]            ;   Get address for next z_(j+l)
    lea  rbp, [rbp + 8*LEN_LNUM_ELE]            ;   Get address for next M_(i-j)
    mov  rbx, [rdi]                             ;   Load z_(j+l)
    mov  rax, [rbp]                             ;   Load m_(i-j)

    mul  rbx                                    ;   (RDX|RAX) = z_k*m_(i+0-j)
    add  r8, rax                                ;   v_0 += RAX      |   carry possible
    mov  rax, [rbp + 1*LEN_LNUM_ELE]            ;   Load m_(i+1-j)
    adc  rdx, 0                                 ;   RDX += carry    |   no carry possible
    mov  rsi, rdx                               ;   tmp = RDX

    mul  rbx                                    ;   (RDX|RAX) = z_k*m_(i+1-j)
    add  r9, rax                                ;   v_1 += RAX      |   carry possible
    mov  rax, [rbp + 2*LEN_LNUM_ELE]            ;   Load m_(i+2-j)
    adc  rdx, 0                                 ;   RDX += carry    |   no carry possible
    add  r9, rsi                                ;   v_1 += tmp      |   carry possible
    adc  rdx, 0                                 ;   RDX += carry    |   no carry possible
    mov  rsi, rdx                               ;   tmp = RDX

    mul  rbx                                    ;   (RDX|RAX) = z_k*m_(i+2-j)
    add  r10, rax                                ;   v_2 += RAX      |   carry possible
    mov  rax, [rbp + 3*LEN_LNUM_ELE]            ;   Load m_(i+3-j)
    adc  rdx, 0                                 ;   RDX += carry    |   no carry possible
    add  r10, rsi                                ;   v_2 += tmp      |   carry possible
    adc  rdx, 0                                 ;   RDX += carry    |   no carry possible
    mov  rsi, rdx                               ;   tmp = RDX

    mul  rbx                                    ;   (RDX|RAX) = z_k*m_(i+3-j)
    add  r11, rax                                ;   v_3 += RAX      |   carry possible
    mov  rax, [rbp + 4*LEN_LNUM_ELE]            ;   Load m_(i+4-j)
    adc  rdx, 0                                 ;   RDX += carry    |   no carry possible
    add  r11, rsi                                ;   v_3 += tmp      |   carry possible
    adc  rdx, 0                                 ;   RDX += carry    |   no carry possible
    mov  rsi, rdx                               ;   tmp = RDX

    mul  rbx                                    ;   (RDX|RAX) = z_k*m_(i+4-j)
    add  r12, rax                                ;   v_4 += RAX      |   carry possible
    mov  rax, [rbp + 5*LEN_LNUM_ELE]            ;   Load m_(i+5-j)
    adc  rdx, 0                                 ;   RDX += carry    |   no carry possible
    add  r12, rsi                                ;   v_4 += tmp      |   carry possible
    adc  rdx, 0                                 ;   RDX += carry    |   no carry possible
    mov  rsi, rdx                               ;   tmp = RDX

    mul  rbx                                    ;   (RDX|RAX) = z_k*m_(i+5-j)
    add  r13, rax                                ;   v_5 += RAX      |   carry possible
    mov  rax, [rbp + 6*LEN_LNUM_ELE]            ;   Load m_(i+6-j)
    adc  rdx, 0                                 ;   RDX += carry    |   no carry possible
    add  r13, rsi                                ;   v_5 += tmp      |   carry possible
    adc  rdx, 0                                 ;   RDX += carry    |   no carry possible
    mov  rsi, rdx                               ;   tmp = RDX

    mul  rbx                                    ;   (RDX|RAX) = z_k*m_(i+6-j)
    add  r14, rax                                ;   v_6 += RAX      |   carry possible
    mov  rax, [rbp + 7*LEN_LNUM_ELE]            ;   Load m_(i+7-j)
    adc  rdx, 0                                 ;   RDX += carry    |   no carry possible
    add  r14, rsi                                ;   v_6 += tmp      |   carry possible
    adc  rdx, 0                                 ;   RDX += carry    |   no carry possible
    mov  rsi, rdx                               ;   tmp = RDX

    mul  rbx                                    ;   (RDX|RAX) = z_k*m_(i+1-j)
    add  rax, rsi                               ;   RAX += tmp      |   carry possible
    movq_r rsi, xmm4                            ;   load u
    adc  rdx,0                                  ;   RDX += carry    |   no carry possible
    add  r15, rax                                ;   v_7 += RAX      |   carry possible
    movq_r rax, xmm5                            ;   load t
    adc  rsi, rdx                               ;   u += RDX+carry  |   carry possible
    movq_r xmm4, rsi                            ;   store u
    adc  rax, 0                                 ;   t += carry      |   no carry possible
    movq_r xmm5, rax                            ;   store t

    sub  rcx, 8*LEN_LNUM_ELE                    ;   Decrement loop count
    jg   mont_mul_add_8_growing_inner
    
    movq_r rcx, xmm2                            ;   Restore loop counter
    sub  rbp, rcx                               ;   Restore mod ptr
    lea  rdi, [rdi + rcx]                       ;   Restore dest ptr

    movq_r rbx, xmm0                            ;   Load m_0_inv
    imul rbx, r8                                ;   z_(i+l) = v_0*m_0_inv mod 2^64
    mov  rax, [rbp]                             ;   Load m_0
    mov  [rdi], rbx                             ;   write z_(i+l)
    lea  rdi, [rdi + LEN_LNUM_ELE]              ;   l++
    mul  rbx                                    ;   (RDX|RAX)=z_i*m_0
    neg  r8                                     ;   carry(RAX+v_0)   |   RAX+v_0 = v_0*m_0_inv*m_0 + v_0 = v_0*0xFFFFFFFFFFFFFFFF+v_0
    mov  rax, [rbp + LEN_LNUM_ELE]              ;   Load m_1, RAX will be discarded anyway
    adc  rdx, 0                                 ;   RDX += carry
    mov  r8, rdx                                ;   v_0 = RDX

    mul  rbx                                    ;   (RDX|RAX) = m_1*z_(i+l)
    add  r8, rax                               ;   v_0 = v_0+RAX       |   carry possible
    mov  rax, [rbp + 2*LEN_LNUM_ELE]            ;   Load m_2
    adc  rdx, 0                                 ;   propagate carry     |   no carry possible
    add  r8, r9                               ;   v_0 = v_0+v_1       |   carry possible
    adc  rdx, 0                                 ;   propagate carry     |   no carry possible
    mov  r9, rdx                               ;   v_1 = RDX

    mul  rbx                                    ;   (RDX|RAX) = m_2*z_(i+l)
    add  r9, rax                               ;   v_1 = v_1+RAX       |   carry possible
    mov  rax, [rbp + 3*LEN_LNUM_ELE]            ;   Load m_3
    adc  rdx, 0                                 ;   propagate carry     |   no carry possible
    add  r9, r10                               ;   v_1 = v_1+v_2       |   carry possible
    adc  rdx, 0                                 ;   propagate carry     |   no carry possible
    mov  r10, rdx                               ;   v_2 = RDX

    mul  rbx                                    ;   (RDX|RAX) = m_3*z_(i+l)
    add  r10, rax                               ;   v_2 = v_2+RAX       |   carry possible
    mov  rax, [rbp + 4*LEN_LNUM_ELE]            ;   Load m_4
    adc  rdx, 0                                 ;   propagate carry     |   no carry possible
    add  r10, r11                               ;   v_2 = v_2+v_3       |   carry possible
    adc  rdx, 0                                 ;   propagate carry     |   no carry possible
    mov  r11, rdx                               ;   v_3 = RDX

    mul  rbx                                    ;   (RDX|RAX) = m_4*z_(i+l)
    add  r11, rax                               ;   v_3 = v_3+RAX       |   carry possible
    mov  rax, [rbp + 5*LEN_LNUM_ELE]            ;   Load m_5
    adc  rdx, 0                                 ;   propagate carry     |   no carry possible
    add  r11, r12                               ;   v_3 = v_3+v_4       |   carry possible
    adc  rdx, 0                                 ;   propagate carry     |   no carry possible
    mov  r12, rdx                               ;   v_4 = RDX

    mul  rbx                                    ;   (RDX|RAX) = m_5*z_(i+l)
    add  r12, rax                               ;   v_4 = v_4+RAX       |   carry possible
    mov  rax, [rbp + 6*LEN_LNUM_ELE]            ;   Load m_6
    adc  rdx, 0                                 ;   propagate carry     |   no carry possible
    add  r12, r13                               ;   v_4 = v_4+v_5       |   carry possible
    adc  rdx, 0                                 ;   propagate carry     |   no carry possible
    mov  r13, rdx                               ;   v_5 = RDX

    mul  rbx                                    ;   (RDX|RAX) = m_6*z_(i+l)
    add  r13, rax                               ;   v_5 = v_5+RAX       |   carry possible
    mov  rax, [rbp + 7*LEN_LNUM_ELE]            ;   Load m_7
    adc  rdx, 0                                 ;   propagate carry     |   no carry possible
    add  r13, r14                               ;   v_5 = v_5+v_6       |   carry possible
    adc  rdx, 0                                 ;   propagate carry     |   no carry possible
    mov  r14, rdx                               ;   v_6 = RDX


    mul  rbx                                    ;   (RDX|RAX) = m_7*z_(i+l)
    add  r14, rax                               ;   v_6 = v_0+RAX     |   carry possible
    adc  rdx, 0                                 ;   propagate carry     |   no carry possible
    add  r14, r15                               ;   v_6 = v_6+v_7       |   carry possible
    movq_r r15, xmm4                             ;   v_7 = u
    adc  r15, rdx                               ;   v_7 += RDX + carry  |   carry possible
    movq_r rsi, xmm5                            ;   load t
    adc  rsi, 0                                 ;   t += carry          |   no carry possible
    movq_r xmm4, rsi                            ;   store u = t
    pxor xmm5, xmm5                             ;   t = 0
    
    cmp  rdi, [rsp]                             ;   check if the end of the inner loop is reached
    jne  mont_mul_add_8_growing_inner
    
    lea  rsi, [rdi + 8*LEN_LNUM_ELE]            ;   Load end of the next block
    mov  [rsp], rsi                             ;   Store end of next block
    cmp  rdi, [rsp+MONT_8_DEST_MID_INDEX]       ;   Check if the end of the outer loop is reached  
    je   mont_mul_add_8_shrinking_start         ;   Jump to second loop, if so

    add  rcx, 8*LEN_LNUM_ELE                    ;   Increment loop count for inner loop
    movq_r xmm2, rcx                            ;   Store loop counter
    jmp  mont_mul_add_8_growing_outer

mont_mul_add_8_shrinking_start:
    movq_r xmm3, rdi                            ;   Store dest ptr

mont_mul_add_8_shrinking_outer:
;    ---------------------------------------
;   |            REGISTER STATUS            |
;   |  dest: XMM3        m_0_inv:  XMM0     |
;   |  mod:  RBP         loop_cnt: XMM2     |
;   |  P:    XMM1        z_s:  [RSP+LEN_LNUM_ELE]   |
;   |  (t|u): XMM5|4     block_end: [RSP]   |
;   |  temp: RSI         V = R8-R9          |
;   |  z_(s+l): RDI                         |
;    ---------------------------------------
    mov  rdi, [rsp+MONT_8_DEST_MID_INDEX]       ;   Load z_s
    movq_r rax, xmm1                            ;   Load src ptr
    movq_r rsi, xmm4                            ;   Load u
    add  r8, [rax]                              ;   v_0 += p_i              |   carry possible
    adc  r9, [rax+1 * LEN_LNUM_ELE]            ;   v_1 += p_(i+1) + carry  |   carry possible
    adc  r10, [rax+2 * LEN_LNUM_ELE]            ;   v_2 += p_(i+2) + carry  |   carry possible
    adc  r11, [rax+3 * LEN_LNUM_ELE]            ;   v_3 += p_(i+3) + carry  |   carry possible
    adc  r12, [rax+4 * LEN_LNUM_ELE]            ;   v_4 += p_(i+4) + carry  |   carry possible
    adc  r13, [rax+5 * LEN_LNUM_ELE]            ;   v_5 += p_(i+5) + carry  |   carry possible
    adc  r14, [rax+6 * LEN_LNUM_ELE]            ;   v_6 += p_(i+6) + carry  |   carry possible
    adc  r15, [rax+7 * LEN_LNUM_ELE]            ;   v_7 += p_(i+7) + carry  |   carry possible

    adc  rsi, 0                                 ;   u += carry
    movq_r xmm4, rsi                            ;   store u
    lea  rax, [rax + 8*LEN_LNUM_ELE]            ;   Next P_i
    movq_r xmm1, rax                            ;   Store P_i
    
mont_mul_add_8_shrinking_inner:
    lea  rdi, [rdi - 8*LEN_LNUM_ELE]            ;   Get address for next z_(j+l)
    lea  rbp, [rbp + 8*LEN_LNUM_ELE]            ;   Get address for next M_(i-j)
    mov  rbx, [rdi]                             ;   Load z_(j+l)
    mov  rax, [rbp]                             ;   Load m_(i-j)

    mul  rbx                                    ;   (RDX|RAX) = z_k*m_(i+0-j)
    add  r8, rax                                ;   v_0 += RAX      |   carry possible
    mov  rax, [rbp + 1*LEN_LNUM_ELE]            ;   Load m_(i+1-j)
    adc  rdx, 0                                 ;   RDX += carry    |   no carry possible
    mov  rsi, rdx                               ;   tmp = RDX

    mul  rbx                                    ;   (RDX|RAX) = z_k*m_(i+1-j)
    add  r9, rax                                ;   v_1 += RAX      |   carry possible
    mov  rax, [rbp + 2*LEN_LNUM_ELE]            ;   Load m_(i+2-j)
    adc  rdx, 0                                 ;   RDX += carry    |   no carry possible
    add  r9, rsi                                ;   v_1 += tmp      |   carry possible
    adc  rdx, 0                                 ;   RDX += carry    |   no carry possible
    mov  rsi, rdx                               ;   tmp = RDX

    mul  rbx                                    ;   (RDX|RAX) = z_k*m_(i+2-j)
    add  r10, rax                                ;   v_2 += RAX      |   carry possible
    mov  rax, [rbp + 3*LEN_LNUM_ELE]            ;   Load m_(i+3-j)
    adc  rdx, 0                                 ;   RDX += carry    |   no carry possible
    add  r10, rsi                                ;   v_2 += tmp      |   carry possible
    adc  rdx, 0                                 ;   RDX += carry    |   no carry possible
    mov  rsi, rdx                               ;   tmp = RDX

    mul  rbx                                    ;   (RDX|RAX) = z_k*m_(i+3-j)
    add  r11, rax                                ;   v_3 += RAX      |   carry possible
    mov  rax, [rbp + 4*LEN_LNUM_ELE]            ;   Load m_(i+4-j)
    adc  rdx, 0                                 ;   RDX += carry    |   no carry possible
    add  r11, rsi                                ;   v_3 += tmp      |   carry possible
    adc  rdx, 0                                 ;   RDX += carry    |   no carry possible
    mov  rsi, rdx                               ;   tmp = RDX

    mul  rbx                                    ;   (RDX|RAX) = z_k*m_(i+4-j)
    add  r12, rax                                ;   v_4 += RAX      |   carry possible
    mov  rax, [rbp + 5*LEN_LNUM_ELE]            ;   Load m_(i+5-j)
    adc  rdx, 0                                 ;   RDX += carry    |   no carry possible
    add  r12, rsi                                ;   v_4 += tmp      |   carry possible
    adc  rdx, 0                                 ;   RDX += carry    |   no carry possible
    mov  rsi, rdx                               ;   tmp = RDX

    mul  rbx                                    ;   (RDX|RAX) = z_k*m_(i+5-j)
    add  r13, rax                                ;   v_5 += RAX      |   carry possible
    mov  rax, [rbp + 6*LEN_LNUM_ELE]            ;   Load m_(i+6-j)
    adc  rdx, 0                                 ;   RDX += carry    |   no carry possible
    add  r13, rsi                                ;   v_5 += tmp      |   carry possible
    adc  rdx, 0                                 ;   RDX += carry    |   no carry possible
    mov  rsi, rdx                               ;   tmp = RDX

    mul  rbx                                    ;   (RDX|RAX) = z_k*m_(i+6-j)
    add  r14, rax                                ;   v_6 += RAX      |   carry possible
    mov  rax, [rbp + 7*LEN_LNUM_ELE]            ;   Load m_(i+7-j)
    adc  rdx, 0                                 ;   RDX += carry    |   no carry possible
    add  r14, rsi                                ;   v_6 += tmp      |   carry possible
    adc  rdx, 0                                 ;   RDX += carry    |   no carry possible
    mov  rsi, rdx                               ;   tmp = RDX

    mul  rbx                                    ;   (RDX|RAX) = z_k*m_(i+1-j)
    add  rax, rsi                               ;   RAX += tmp      |   carry possible
    movq_r rsi, xmm4                            ;   load u
    adc  rdx,0                                  ;   RDX += carry    |   no carry possible
    add  r15, rax                                ;   v_7 += RAX      |   carry possible
    movq_r rax, xmm5                            ;   load t
    adc  rsi, rdx                               ;   u += RDX+carry  |   carry possible
    movq_r xmm4, rsi                            ;   store u
    adc  rax, 0                                 ;   t += carry      |   no carry possible
    movq_r xmm5, rax                            ;   store t

    sub  rcx, 8*LEN_LNUM_ELE                    ;   Decrement loop count
    jg   mont_mul_add_8_shrinking_inner
    
    movq_r rcx, xmm2                            ;   Restore loop counter
    sub  rbp, rcx                               ;   Restore mod ptr
    lea  rdi, [rdi + rcx + LEN_LNUM_ELE]        ;   Restore Z pointer and increment for next iteration

    movq_r rsi, xmm3                            ;   Load dest ptr
    mov  [rsi], r8                              ;   z_(s+i+l) = v_0
    lea  rsi, [rsi + LEN_LNUM_ELE]              ;   Increment dest ptr
    
    movq_r xmm3, rsi                            ;   Store dest ptr
    mov  r8, r9                                 ;   v_0 = v_1
    mov  r9, r10                                 ;   v_1 = v_2
    mov  r10, r11                                 ;   v_2 = v_3
    mov  r11, r12                                 ;   v_3 = v_4
    mov  r12, r13                                 ;   v_4 = v_5
    mov  r13, r14                                 ;   v_5 = v_6
    mov  r14, r15                                 ;   v_6 = v_7
    movq_r r15, xmm4                             ;   v_7 = u
    movdqa  xmm4, xmm5                          ;   u = t
    pxor xmm5, xmm5                             ;   t = 0
    
    cmp  rdi, [rsp]                             ;   check if the end of the inner loop is reached
    jne  mont_mul_add_8_shrinking_inner
    
    sub  rcx, 8*LEN_LNUM_ELE                    ;   Decrement inner loop counter
    jle  mont_mul_add_8_pre_final               ;   If no inner loops left, jump to final addition
    movq_r xmm2, rcx                            ;   Store loop counter
    lea  rbp, [rbp + 8*LEN_LNUM_ELE]            ;    Move mod ptr by b
    jmp mont_mul_add_8_shrinking_outer

mont_mul_add_8_pre_final:
    movq_r rdi, xmm3                            ;   Load dest ptr
mont_mul_add_8_final:
    movq_r rax, xmm1                            ;   Load src ptr
    movq_r rsi, xmm4                            ;   Load u
    add  r8, [rax]                              ;   v_0 += p_i              |   carry possible
    adc  r9, [rax+1 * LEN_LNUM_ELE]            ;   v_1 += p_(i+1) + carry  |   carry possible
    adc  r10, [rax+2 * LEN_LNUM_ELE]            ;   v_2 += p_(i+2) + carry  |   carry possible
    adc  r11, [rax+3 * LEN_LNUM_ELE]            ;   v_3 += p_(i+3) + carry  |   carry possible
    adc  r12, [rax+4 * LEN_LNUM_ELE]            ;   v_4 += p_(i+4) + carry  |   carry possible
    adc  r13, [rax+5 * LEN_LNUM_ELE]            ;   v_5 += p_(i+5) + carry  |   carry possible
    adc  r14, [rax+6 * LEN_LNUM_ELE]            ;   v_6 += p_(i+6) + carry  |   carry possible
    adc  r15, [rax+7 * LEN_LNUM_ELE]            ;   v_7 += p_(i+7) + carry  |   carry possible

    adc  rsi, 0                                 ;   u += carry
    movq_r xmm4, rsi                            ;   store u

    mov  [rdi+0*LEN_LNUM_ELE], r8               ;   z_(s-8) = v_0
    mov  [rdi+1*LEN_LNUM_ELE], r9               ;   z_(s-7) = v_1
    mov  [rdi+2*LEN_LNUM_ELE], r10               ;   z_(s-6) = v_2
    mov  [rdi+3*LEN_LNUM_ELE], r11               ;   z_(s-5) = v_3
    mov  [rdi+4*LEN_LNUM_ELE], r12               ;   z_(s-4) = v_4
    mov  [rdi+5*LEN_LNUM_ELE], r13               ;   z_(s-3) = v_5
    mov  [rdi+6*LEN_LNUM_ELE], r14               ;   z_(s-2) = v_6
    mov  [rdi+7*LEN_LNUM_ELE], r15               ;   z_(s-1) = v_7
    mov  [rdi+8*LEN_LNUM_ELE], rsi              ;   z_s = u

    add  rsp, LEN_LNUM_ELE*MONT_8_STACK_CNT
    pop  r15
    pop  r14
    pop  r13
    pop  r12
    pop  rbx
    pop  rbp
    pop   rdi
    pop   rsi
    ret
ms_impl_mont_mul_add_8 endp

;void ms_impl_mont_mul_add_8(LNUM_WORD* aurp_prod,
;                            LNUM_WORD urp_n_0_inv,
;                            const LNUM_WORD* aurp_mod,
;                            size_t szp_mod_len,
;                            const LNUM_WORD* aurp_src);
ms_impl_mont_mul_add_1 proc
;-----------------------------------------------------------------------------------------;
;  Calling convention: Microsoft x64                                                      ;
;-----------------------------------------------------------------------------------------;
;           scratch (volatile) registers:   RAX, RCX, RDX, R8, R9, R10, R11               ;
;   callee-save (non-volatile) registers:   RBX, RBP, RDI, RSI, RSP, R12, R13, R14, R15   ;
;                    parameter registers:   RCX, RDX, R8, R9                              ;
;-----------------------------------------------------------------------------------------;
;    ---------------------------------------
;   |            REGISTER STATUS            |
;   |  dest: R10         m_0_inv: RDX       |
;   |  mod:  R8          mod_len: R9        |
;   |  P:    RCX                            |
;    ---------------------------------------
    mov rax, [rcx]                              ;   RAX = p[0]
    mul rdx                                     ;   q = p[0]*m_inv mod 2^64
    mul QWORD PTR[r8]                           ;   (u,v) = m[0]*q
    add rax, [rcx]                              ;   v += p[0]           |   carry possible
    adc rdx, [rcx + LEN_LNUM_ELE]               ;   u += p[1] + carry   |   no carry possible
    mov [r10 + LEN_LNUM_ELE], rdx               ;   Write u
    mov QWORD PTR[r10 + 2*LEN_LNUM_ELE], 0      ;   0 the carry out word

    ret
ms_impl_mont_mul_add_1 endp
    
;int m_x86_capabilities();
m_x86_capabilities proc
;-----------------------------------------------------------------------------------------;
;  Calling convention: Microsoft x64                                                      ;
;-----------------------------------------------------------------------------------------;
;           scratch (volatile) registers:   RAX, RCX, RDX, R8, R9, R10, R11               ;
;   callee-save (non-volatile) registers:   RBX, RBP, RDI, RSI, RSP, R12, R13, R14, R15   ;
;                    parameter registers:   RCX, RDX, R8, R9                              ;
;-----------------------------------------------------------------------------------------;
    push rbx
    mov rax, 1
    cpuid
    xor r8, r8
    bt  ecx, 25                             ; AES Instruction expansion
    jnc capabilities_pmul
    or  r8, 1                              ; HL_HARDWARE_SUPPORT_FLAG_AES  1 
capabilities_pmul:
    bt  ecx, 1                              ; PCLMULQDQ
    jnc capabilities_sha
    bt  ecx, 9                              ; Supplemental SSE3
    jnc capabilities_sha
    or  r8, 2                              ; HL_HARDWARE_SUPPORT_FLAG_PMUL  2
capabilities_sha:
    xor eax, eax                            ; Verify if cpuid can report as high as eax=7
    cpuid
    cmp eax, 7                              
    jl capabilities_end
    mov eax, 7                              ; SHA feature flag is reported for eax=7, ecx=0
    xor ecx, ecx
    cpuid
    bt  ebx, 29                             ; SHA
    jnc capabilities_end
    or  r8, 48                              ; HL_HARDWARE_SUPPORT_FLAG_SHA1  16 | HL_HARDWARE_SUPPORT_FLAG_SHA256  32
capabilities_end:
    mov rax, r8
    pop rbx
    ret
m_x86_capabilities endp

ms_prepare_roundkey_128 proc
;-----------------------------------------------------------------------------------------;
;  Calling convention: Microsoft x64                                                      ;
;-----------------------------------------------------------------------------------------;
;           scratch (volatile) registers:   RAX, RCX, RDX, R8, R9, R10, R11               ;
;   callee-save (non-volatile) registers:   RBX, RBP, RDI, RSI, RSP, R12, R13, R14, R15   ;
;                    parameter registers:   RCX, RDX, R8, R9                              ;
;-----------------------------------------------------------------------------------------;
	pshufd		xmm2,xmm2,255
	movdqa		xmm3,xmm1
	pslldq		xmm3,4
	pxor		xmm1,xmm3
	pslldq		xmm3,4
	pxor		xmm1,xmm3
	pslldq		xmm3,4
	pxor		xmm1,xmm3
	pxor		xmm1,xmm2
	ret
ms_prepare_roundkey_128 endp

ms_prepare_roundkey_192 proc
;-----------------------------------------------------------------------------------------;
;  Calling convention: Microsoft x64                                                      ;
;-----------------------------------------------------------------------------------------;
;           scratch (volatile) registers:   RAX, RCX, RDX, R8, R9, R10, R11               ;
;   callee-save (non-volatile) registers:   RBX, RBP, RDI, RSI, RSP, R12, R13, R14, R15   ;
;                    parameter registers:   RCX, RDX, R8, R9                              ;
;-----------------------------------------------------------------------------------------;
	pshufd		xmm2,xmm2,55h
	movdqu		xmm4,xmm1
	pslldq		xmm4,4
	pxor		xmm1,xmm4
	pslldq		xmm4,4
	pxor		xmm1,xmm4
	pslldq		xmm4,4
	pxor		xmm1,xmm4
	pxor		xmm1,xmm2
	pshufd		xmm2,xmm1,0FFh
	movdqu		xmm4,xmm3
	pslldq		xmm4,4
	pxor		xmm3,xmm4
	pxor		xmm3,xmm2
	ret
ms_prepare_roundkey_192 endp

ms_make_rk256_a proc
;-----------------------------------------------------------------------------------------;
;  Calling convention: Microsoft x64                                                      ;
;-----------------------------------------------------------------------------------------;
;           scratch (volatile) registers:   RAX, RCX, RDX, R8, R9, R10, R11               ;
;   callee-save (non-volatile) registers:   RBX, RBP, RDI, RSI, RSP, R12, R13, R14, R15   ;
;                    parameter registers:   RCX, RDX, R8, R9                              ;
;-----------------------------------------------------------------------------------------;
	pshufd		xmm2,xmm2,0FFh
	movdqa		xmm4,xmm1
	pslldq		xmm4,4
	pxor		xmm1,xmm4
	pslldq		xmm4,4
	pxor		xmm1,xmm4
	pslldq		xmm4,4
	pxor		xmm1,xmm4
	pxor		xmm1,xmm2
	ret
ms_make_rk256_a endp
    
ms_make_rk256_b proc
;-----------------------------------------------------------------------------------------;
;  Calling convention: Microsoft x64                                                      ;
;-----------------------------------------------------------------------------------------;
;           scratch (volatile) registers:   RAX, RCX, RDX, R8, R9, R10, R11               ;
;   callee-save (non-volatile) registers:   RBX, RBP, RDI, RSI, RSP, R12, R13, R14, R15   ;
;                    parameter registers:   RCX, RDX, R8, R9                              ;
;-----------------------------------------------------------------------------------------;
	pshufd		xmm2,xmm2,0AAh
	movdqa		xmm4,xmm3
	pslldq		xmm4,4
	pxor		xmm3,xmm4
	pslldq		xmm4,4
	pxor		xmm3,xmm4
	pslldq		xmm4,4
	pxor		xmm3,xmm4
	pxor		xmm3,xmm2
	ret
ms_make_rk256_b endp

;extern "C" void m_impl_aes_128_key_expansion(const unsigned char * abyp_userkey,
;                                            unsigned char * abyp_key);
m_impl_aes_128_key_expansion proc
;-----------------------------------------------------------------------------------------;
;  Calling convention: Microsoft x64                                                      ;
;-----------------------------------------------------------------------------------------;
;           scratch (volatile) registers:   RAX, RCX, RDX, R8, R9, R10, R11               ;
;   callee-save (non-volatile) registers:   RBX, RBP, RDI, RSI, RSP, R12, R13, R14, R15   ;
;                    parameter registers:   RCX, RDX, R8, R9                              ;
;-----------------------------------------------------------------------------------------;
;    ---------------------------------------
;   |            REGISTER STATUS            |
;   |  src: rcx          dest: rdx          |
;    ---------------------------------------
	movdqu		xmm1,[rcx]
	movdqu		[rdx],xmm1

   	aeskeygenassist	xmm2,xmm1,1
	call		ms_prepare_roundkey_128
	movdqu		[rdx+16],xmm1

   	aeskeygenassist	xmm2,xmm1,2
	call		ms_prepare_roundkey_128
	movdqu		[rdx+32],xmm1

    aeskeygenassist	xmm2,xmm1,4
	call		ms_prepare_roundkey_128
	movdqu		[rdx+48],xmm1

    aeskeygenassist	xmm2,xmm1,8
	call		ms_prepare_roundkey_128
	movdqu		[rdx+64],xmm1

    aeskeygenassist	xmm2,xmm1,16
	call		ms_prepare_roundkey_128
	movdqu		[rdx+80],xmm1

    aeskeygenassist	xmm2,xmm1,32
	call		ms_prepare_roundkey_128
	movdqu		[rdx+96],xmm1

    aeskeygenassist	xmm2,xmm1,64
	call		ms_prepare_roundkey_128
	movdqu		[rdx+112],xmm1

    aeskeygenassist	xmm2,xmm1,80h
	call		ms_prepare_roundkey_128
	movdqu		[rdx+128],xmm1

    aeskeygenassist	xmm2,xmm1,1Bh
	call		ms_prepare_roundkey_128
	movdqu		[rdx+144],xmm1

    aeskeygenassist	xmm2,xmm1,36h
	call		ms_prepare_roundkey_128
	movdqu		[rdx+160],xmm1
	ret
m_impl_aes_128_key_expansion endp
    
;extern "C" void m_impl_aes_192_key_expansion(const unsigned char * abyp_userkey,
;                                            unsigned char * abyp_key);
m_impl_aes_192_key_expansion proc
;-----------------------------------------------------------------------------------------;
;  Calling convention: Microsoft x64                                                      ;
;-----------------------------------------------------------------------------------------;
;           scratch (volatile) registers:   RAX, RCX, RDX, R8, R9, R10, R11               ;
;   callee-save (non-volatile) registers:   RBX, RBP, RDI, RSI, RSP, R12, R13, R14, R15   ;
;                    parameter registers:   RCX, RDX, R8, R9                              ;
;-----------------------------------------------------------------------------------------;
;    ---------------------------------------
;   |            REGISTER STATUS            |
;   |  src: rcx          dest: rdx          |
;    ---------------------------------------
	movdqu		xmm1,[rcx]
	movq_r      xmm3,QWORD PTR[rcx+16]

	movdqu		[rdx],xmm1
	movdqa		xmm5,xmm3

    aeskeygenassist	xmm2,xmm3,1
	call		ms_prepare_roundkey_192
	shufpd		xmm5,xmm1,0
	movdqu		[rdx+16],xmm5
	movdqa		xmm6,xmm1
	shufpd		xmm6,xmm3,1
	movdqu		[rdx+32],xmm6

    aeskeygenassist	xmm2,xmm3,2
	call		ms_prepare_roundkey_192
	movdqu		[rdx+48],xmm1
	movdqa		xmm5,xmm3

    aeskeygenassist	xmm2,xmm3,4
	call		ms_prepare_roundkey_192
	shufpd		xmm5,xmm1,0
	movdqu		[rdx+64],xmm5
	movdqa		xmm6,xmm1
	shufpd		xmm6,xmm3,1
	movdqu		[rdx+80],xmm6

    aeskeygenassist	xmm2,xmm3,8
	call		ms_prepare_roundkey_192
	movdqu		[rdx+96],xmm1
	movdqa		xmm5,xmm3

    aeskeygenassist	xmm2,xmm3,16
	call		ms_prepare_roundkey_192
	shufpd		xmm5,xmm1,0
	movdqu		[rdx+112],xmm5
	movdqa		xmm6,xmm1
	shufpd		xmm6,xmm3,1
	movdqu		[rdx+128],xmm6

    aeskeygenassist	xmm2,xmm3,32
	call		ms_prepare_roundkey_192
	movdqu		[rdx+144],xmm1
	movdqa		xmm5,xmm3

    aeskeygenassist	xmm2,xmm3,64
	call		ms_prepare_roundkey_192
	shufpd		xmm5,xmm1,0
	movdqu		[rdx+160],xmm5
	movdqa		xmm6,xmm1
	shufpd		xmm6,xmm3,1
	movdqu		[rdx+176],xmm6

    aeskeygenassist	xmm2,xmm3,128
	call		ms_prepare_roundkey_192
	movdqu		[rdx+192],xmm1
	movdqu		[rdx+208],xmm3
	ret
m_impl_aes_192_key_expansion endp

;extern "C" void m_impl_aes_256_key_expansion(const unsigned char * abyp_userkey,
;                                            unsigned char * abyp_key);
m_impl_aes_256_key_expansion proc
;-----------------------------------------------------------------------------------------;
;  Calling convention: Microsoft x64                                                      ;
;-----------------------------------------------------------------------------------------;
;           scratch (volatile) registers:   RAX, RCX, RDX, R8, R9, R10, R11               ;
;   callee-save (non-volatile) registers:   RBX, RBP, RDI, RSI, RSP, R12, R13, R14, R15   ;
;                    parameter registers:   RCX, RDX, R8, R9                              ;
;-----------------------------------------------------------------------------------------;
;    ---------------------------------------
;   |            REGISTER STATUS            |
;   |  src: rcx          dest: rdx          |
;    ---------------------------------------
	movdqu		xmm1,[rcx]
	movdqu		xmm3,[rcx+16]

	movdqu		[rdx],xmm1
	movdqu		[rdx+16],xmm3

    aeskeygenassist	xmm2,xmm3,1
	call		ms_make_rk256_a
	movdqu		[rdx+32],xmm1

    aeskeygenassist	xmm2,xmm1,0
	call		ms_make_rk256_b
	movdqu		[rdx+48],xmm3

    aeskeygenassist	xmm2,xmm3,2
	call		ms_make_rk256_a
	movdqu		[rdx+64],xmm1

    aeskeygenassist	xmm2,xmm1,0
	call		ms_make_rk256_b
	movdqu		[rdx+80],xmm3

    aeskeygenassist	xmm2,xmm3,4
	call		ms_make_rk256_a
	movdqu		[rdx+96],xmm1

    aeskeygenassist	xmm2,xmm1,0
	call		ms_make_rk256_b
	movdqu		[rdx+112],xmm3

    aeskeygenassist	xmm2,xmm3,8
	call		ms_make_rk256_a
	movdqu		[rdx+128],xmm1

    aeskeygenassist	xmm2,xmm1,0
	call		ms_make_rk256_b
	movdqu		[rdx+144],xmm3

    aeskeygenassist	xmm2,xmm3,16
	call		ms_make_rk256_a
	movdqu		[rdx+160],xmm1

    aeskeygenassist	xmm2,xmm1,0
	call		ms_make_rk256_b
	movdqu		[rdx+176],xmm3

    aeskeygenassist	xmm2,xmm3,32
	call		ms_make_rk256_a
	movdqu		[rdx+192],xmm1

    aeskeygenassist	xmm2,xmm1,0
	call		ms_make_rk256_b
	movdqu		[rdx+208],xmm3

    aeskeygenassist	xmm2,xmm3,64
	call		ms_make_rk256_a
	movdqu		[rdx+224],xmm1

	ret
m_impl_aes_256_key_expansion endp
    
;extern "C" void m_impl_aes_revert_key(unsigned char * adsp_key,
;                                     unsigned char * adsp_rev_key,
;                                     size_t szp_rounds);
m_impl_aes_revert_key proc
;-----------------------------------------------------------------------------------------;
;  Calling convention: Microsoft x64                                                      ;
;-----------------------------------------------------------------------------------------;
;           scratch (volatile) registers:   RAX, RCX, RDX, R8, R9, R10, R11               ;
;   callee-save (non-volatile) registers:   RBX, RBP, RDI, RSI, RSP, R12, R13, R14, R15   ;
;                    parameter registers:   RCX, RDX, R8, R9                              ;
;-----------------------------------------------------------------------------------------;

	mov	r9,r8
	shl	r9,4		; * 16
	add	rdx,r9		; to topmost element

	movdqu	xmm1,[rcx]
	movdqu	[rdx],xmm1
	add	rcx,16
	sub	rdx,16
	dec	r8

revert_loop:
	movdqu	xmm1,[rcx]
    aesimc	xmm1,xmm1
	movdqu	[rdx],xmm1
	add	rcx,16
	sub	rdx,16
	dec	r8
	jnz	revert_loop

	movdqu	xmm1,[rcx]
	movdqu	[rdx],xmm1

	ret
m_impl_aes_revert_key endp









ms_aes_enc_4 proc
;-----------------------------------------------------------------------------------------;
;  Calling convention: Microsoft x64                                                      ;
;-----------------------------------------------------------------------------------------;
;           scratch (volatile) registers:   RAX, RCX, RDX, R8, R9, R10, R11               ;
;   callee-save (non-volatile) registers:   RBX, RBP, RDI, RSI, RSP, R12, R13, R14, R15   ;
;                    parameter registers:   RCX, RDX, R8, R9                              ;
;-----------------------------------------------------------------------------------------;
;    ---------------------------------------
;   |            REGISTER STATUS            |
;   |  src: rcx          key: r8            |
;   |  result: XMM0-3                       |
;    ---------------------------------------
    movdqu      xmm14, [r8]
    movdqu      xmm12, [r8 + 010h]
    movdqu      xmm13, [r8 + 020h]
    movdqu      xmm15, [r8 + r10]
    pxor        xmm0,xmm14                       ; Apply round key to block 0
    pxor        xmm1,xmm14                       ; Apply round key to block 1
    pxor        xmm2,xmm14                       ; Apply round key to block 2
    pxor        xmm3,xmm14                       ; Apply round key to block 3
    cmp         rdi,12

    aesenc      xmm0, xmm12                     ; Encryption round 1 for block 0
    aesenc      xmm1, xmm12                     ; Encryption round 1 for block 1
    aesenc      xmm2, xmm12                     ; Encryption round 1 for block 2
    aesenc      xmm3, xmm12                     ; Encryption round 1 for block 3
    movdqu      xmm12, [r8 + 030h]              ; Preload key 3
    aesenc      xmm0, xmm13                     ; Encryption round 2 for block 0
    aesenc      xmm1, xmm13                     ; Encryption round 2 for block 1
    aesenc      xmm2, xmm13                     ; Encryption round 2 for block 2
    aesenc      xmm3, xmm13                     ; Encryption round 2 for block 3
    movdqu      xmm13, [r8 + 040h]              ; Preload key 4
    aesenc      xmm0, xmm12                     ; Encryption round 3 for block 0
    aesenc      xmm1, xmm12                     ; Encryption round 3 for block 1
    aesenc      xmm2, xmm12                     ; Encryption round 3 for block 2
    aesenc      xmm3, xmm12                     ; Encryption round 3 for block 3
    movdqu      xmm12, [r8 + 050h]              ; Preload key 5
    aesenc      xmm0, xmm13                     ; Encryption round 4 for block 0
    aesenc      xmm1, xmm13                     ; Encryption round 4 for block 1
    aesenc      xmm2, xmm13                     ; Encryption round 4 for block 2
    aesenc      xmm3, xmm13                     ; Encryption round 4 for block 3
    movdqu      xmm13, [r8 + 060h]              ; Preload key 6
    aesenc      xmm0, xmm12                     ; Encryption round 5 for block 0
    aesenc      xmm1, xmm12                     ; Encryption round 5 for block 1
    aesenc      xmm2, xmm12                     ; Encryption round 5 for block 2
    aesenc      xmm3, xmm12                     ; Encryption round 5 for block 3
    movdqu      xmm12, [r8 + 070h]              ; Preload key 7
    aesenc      xmm0, xmm13                     ; Encryption round 6 for block 0
    aesenc      xmm1, xmm13                     ; Encryption round 6 for block 1
    aesenc      xmm2, xmm13                     ; Encryption round 6 for block 2
    aesenc      xmm3, xmm13                     ; Encryption round 6 for block 3
    movdqu      xmm13, [r8 + 080h]              ; Preload key 8
    aesenc      xmm0, xmm12                     ; Encryption round 7 for block 0
    aesenc      xmm1, xmm12                     ; Encryption round 7 for block 1
    aesenc      xmm2, xmm12                     ; Encryption round 7 for block 2
    aesenc      xmm3, xmm12                     ; Encryption round 7 for block 3
    movdqu      xmm12, [r8 + 090h]              ; Preload key 9
    aesenc      xmm0, xmm13                     ; Encryption round 8 for block 0
    aesenc      xmm1, xmm13                     ; Encryption round 8 for block 1
    aesenc      xmm2, xmm13                     ; Encryption round 8 for block 2
    aesenc      xmm3, xmm13                     ; Encryption round 8 for block 3
    movdqu      xmm13, [r8 + 0A0h]              ; Preload key 10
    aesenc      xmm0, xmm12                     ; Encryption round 9 for block 0
    aesenc      xmm1, xmm12                     ; Encryption round 9 for block 1
    aesenc      xmm2, xmm12                     ; Encryption round 9 for block 2
    aesenc      xmm3, xmm12                     ; Encryption round 9 for block 3
    movdqu      xmm12, [r8 + 0B0h]              ; Preload key 11
    jb              aes_enc_4_last              ; jump, if less than 12 rounds (128 bit AES)
    aesenc      xmm0, xmm13                     ; Encryption round 8 for block 0
    aesenc      xmm1, xmm13                     ; Encryption round 8 for block 1
    aesenc      xmm2, xmm13                     ; Encryption round 8 for block 2
    aesenc      xmm3, xmm13                     ; Encryption round 8 for block 3
    movdqu      xmm13, [r8 + 0C0h]              ; Preload key 12
    aesenc      xmm0, xmm12                     ; Encryption round 9 for block 0
    aesenc      xmm1, xmm12                     ; Encryption round 9 for block 1
    aesenc      xmm2, xmm12                     ; Encryption round 9 for block 2
    aesenc      xmm3, xmm12                     ; Encryption round 9 for block 3
    movdqu      xmm12, [r8 + 0D0h]              ; Preload key 13
    je              aes_enc_4_last              ; jump, if 12 rounds (196 bit AES)
    aesenc      xmm0, xmm13                     ; Encryption round 12 for block 0
    aesenc      xmm1, xmm13                     ; Encryption round 12 for block 1
    aesenc      xmm2, xmm13                     ; Encryption round 12 for block 2
    aesenc      xmm3, xmm13                     ; Encryption round 12 for block 3
    aesenc      xmm0, xmm12                     ; Encryption round 13 for block 0
    aesenc      xmm1, xmm12                     ; Encryption round 13 for block 1
    aesenc      xmm2, xmm12                     ; Encryption round 13 for block 2
    aesenc      xmm3, xmm12                     ; Encryption round 13 for block 3
aes_enc_4_last:
    aesenclast  xmm0, xmm15                ; Last encryption round for block 0
    aesenclast  xmm1, xmm15                ; Last encryption round for block 1
    aesenclast  xmm2, xmm15                ; Last encryption round for block 2
    aesenclast  xmm3, xmm15                ; Last encryption round for block 3
    ret
ms_aes_enc_4 endp

ms_aes_enc_1 proc
;-----------------------------------------------------------------------------------------;
;  Calling convention: Microsoft x64                                                      ;
;-----------------------------------------------------------------------------------------;
;           scratch (volatile) registers:   RAX, RCX, RDX, R8, R9, R10, R11               ;
;   callee-save (non-volatile) registers:   RBX, RBP, RDI, RSI, RSP, R12, R13, R14, R15   ;
;                    parameter registers:   RCX, RDX, R8, R9                              ;
;-----------------------------------------------------------------------------------------;
;    ---------------------------------------
;   |            REGISTER STATUS            |
;   |  src: rcx          key: r8            |
;   |  result: XMM0-3                       |
;    ---------------------------------------
    pxor        xmm0, xmm3                      ; Apply round key
    cmp         rdi,12

    aesenc      xmm0, xmm4                      ; Encryption round 4
    aesenc      xmm0, xmm5                      ; Encryption round 5
    aesenc      xmm0, xmm6                      ; Encryption round 6
    aesenc      xmm0, xmm7                      ; Encryption round 7
    aesenc      xmm0, xmm8                      ; Encryption round 8
    aesenc      xmm0, xmm9                      ; Encryption round 9
    aesenc      xmm0, xmm10                      ; Encryption round 10
    aesenc      xmm0, xmm11                      ; Encryption round 11
    aesenc      xmm0, xmm12                      ; Encryption round 12
    jb          aes_enc_1_last                  ; jump, if less than 12 rounds (128 bit AES)
    movdqu      xmm13, [r8 + 0A0h ]
    aesenc      xmm0, xmm13                     ; Encryption round 10
    movdqu      xmm14, [r8 + 0B0h ]
    movdqu      xmm13, [r8 + 0C0h ]
    aesenc      xmm0, xmm14                     ; Encryption round 11
    movdqu      xmm14, [r8 + 0D0h ]
    je          aes_enc_1_last                  ; jump, if 12 rounds (196 bit AES)
    aesenc      xmm0, xmm13                     ; Encryption round 12
    aesenc      xmm0, xmm14                     ; Encryption round 13
aes_enc_1_last:
    aesenclast  xmm0, xmm15
    ret
ms_aes_enc_1 endp

ms_aes_dec_4 proc
;-----------------------------------------------------------------------------------------;
;  Calling convention: Microsoft x64                                                      ;
;-----------------------------------------------------------------------------------------;
;           scratch (volatile) registers:   RAX, RCX, RDX, R8, R9, R10, R11               ;
;   callee-save (non-volatile) registers:   RBX, RBP, RDI, RSI, RSP, R12, R13, R14, R15   ;
;                    parameter registers:   RCX, RDX, R8, R9                              ;
;-----------------------------------------------------------------------------------------;
;    ---------------------------------------
;   |            REGISTER STATUS            |
;   |  src: rcx          key: r8            |
;   |  result: XMM0-3                       |
;    ---------------------------------------
    movdqu      xmm12, [r8 + 010h]              ; Preload key 1
    movdqu      xmm13, [r8 + 020h]              ; Preload key 2

    pxor        xmm0,xmm14                      ; Apply round key to block 0
    pxor        xmm1,xmm14                      ; Apply round key to block 1
    pxor        xmm2,xmm14                      ; Apply round key to block 2
    pxor        xmm3,xmm14                      ; Apply round key to block 3
    cmp         rdi,12

    aesdec      xmm0, xmm12                     ; Decryption round 1 for block 0
    aesdec      xmm1, xmm12                     ; Decryption round 1 for block 1
    aesdec      xmm2, xmm12                     ; Decryption round 1 for block 2
    aesdec      xmm3, xmm12                     ; Decryption round 1 for block 3
    movdqu      xmm12, [r8 + 030h]              ; Preload key 3
    aesdec      xmm0, xmm13                     ; Decryption round 2 for block 0
    aesdec      xmm1, xmm13                     ; Decryption round 2 for block 1
    aesdec      xmm2, xmm13                     ; Decryption round 2 for block 2
    aesdec      xmm3, xmm13                     ; Decryption round 2 for block 3
    movdqu      xmm13, [r8 + 040h]              ; Preload key 4
    aesdec      xmm0, xmm12                     ; Decryption round 3 for block 0
    aesdec      xmm1, xmm12                     ; Decryption round 3 for block 1
    aesdec      xmm2, xmm12                     ; Decryption round 3 for block 2
    aesdec      xmm3, xmm12                     ; Decryption round 3 for block 3
    movdqu      xmm12, [r8 + 050h]              ; Preload key 5
    aesdec      xmm0, xmm13                     ; Decryption round 4 for block 0
    aesdec      xmm1, xmm13                     ; Decryption round 4 for block 1
    aesdec      xmm2, xmm13                     ; Decryption round 4 for block 2
    aesdec      xmm3, xmm13                     ; Decryption round 4 for block 3
    movdqu      xmm13, [r8 + 060h]              ; Preload key 6
    aesdec      xmm0, xmm12                     ; Decryption round 5 for block 0
    aesdec      xmm1, xmm12                     ; Decryption round 5 for block 1
    aesdec      xmm2, xmm12                     ; Decryption round 5 for block 2
    aesdec      xmm3, xmm12                     ; Decryption round 5 for block 3
    movdqu      xmm12, [r8 + 070h]              ; Preload key 7
    aesdec      xmm0, xmm13                     ; Decryption round 6 for block 0
    aesdec      xmm1, xmm13                     ; Decryption round 6 for block 1
    aesdec      xmm2, xmm13                     ; Decryption round 6 for block 2
    aesdec      xmm3, xmm13                     ; Decryption round 6 for block 3
    movdqu      xmm13, [r8 + 080h]              ; Preload key 8
    aesdec      xmm0, xmm12                     ; Decryption round 7 for block 0
    aesdec      xmm1, xmm12                     ; Decryption round 7 for block 1
    aesdec      xmm2, xmm12                     ; Decryption round 7 for block 2
    aesdec      xmm3, xmm12                     ; Decryption round 7 for block 3
    movdqu      xmm12, [r8 + 090h]              ; Preload key 9
    aesdec      xmm0, xmm13                     ; Decryption round 8 for block 0
    aesdec      xmm1, xmm13                     ; Decryption round 8 for block 1
    aesdec      xmm2, xmm13                     ; Decryption round 8 for block 2
    aesdec      xmm3, xmm13                     ; Decryption round 8 for block 3
    movdqu      xmm13, [r8 + 0A0h]              ; Preload key 10
    aesdec      xmm0, xmm12                     ; Decryption round 9 for block 0
    aesdec      xmm1, xmm12                     ; Decryption round 9 for block 1
    aesdec      xmm2, xmm12                     ; Decryption round 9 for block 2
    aesdec      xmm3, xmm12                     ; Decryption round 9 for block 3
    movdqu      xmm12, [r8 + 0B0h]              ; Preload key 11
    jb              aes_dec_4_last              ; jump, if less than 12 rounds (128 bit AES)
    aesdec      xmm0, xmm13                     ; Decryption round 8 for block 0
    aesdec      xmm1, xmm13                     ; Decryption round 8 for block 1
    aesdec      xmm2, xmm13                     ; Decryption round 8 for block 2
    aesdec      xmm3, xmm13                     ; Decryption round 8 for block 3
    movdqu      xmm13, [r8 + 0C0h]              ; Preload key 12
    aesdec      xmm0, xmm12                     ; Decryption round 9 for block 0
    aesdec      xmm1, xmm12                     ; Decryption round 9 for block 1
    aesdec      xmm2, xmm12                     ; Decryption round 9 for block 2
    aesdec      xmm3, xmm12                     ; Decryption round 9 for block 3
    movdqu      xmm12, [r8 + 0D0h]              ; Preload key 13
    je              aes_dec_4_last              ; jump, if 12 rounds (196 bit AES)
    aesdec      xmm0, xmm13                     ; Decryption round 12 for block 0
    aesdec      xmm1, xmm13                     ; Decryption round 12 for block 1
    aesdec      xmm2, xmm13                     ; Decryption round 12 for block 2
    aesdec      xmm3, xmm13                     ; Decryption round 12 for block 3
    aesdec      xmm0, xmm12                     ; Decryption round 13 for block 0
    aesdec      xmm1, xmm12                     ; Decryption round 13 for block 1
    aesdec      xmm2, xmm12                     ; Decryption round 13 for block 2
    aesdec      xmm3, xmm12                     ; Decryption round 13 for block 3
aes_dec_4_last:
    aesdeclast  xmm0, xmm15                     ; Last decryption round for block 0
    aesdeclast  xmm1, xmm15                     ; Last decryption round for block 1
    aesdeclast  xmm2, xmm15                     ; Last decryption round for block 2
    aesdeclast  xmm3, xmm15                     ; Last decryption round for block 3
    ret
ms_aes_dec_4 endp

ms_aes_dec_1 proc
;-----------------------------------------------------------------------------------------;
;  Calling convention: Microsoft x64                                                      ;
;-----------------------------------------------------------------------------------------;
;           scratch (volatile) registers:   RAX, RCX, RDX, R8, R9, R10, R11               ;
;   callee-save (non-volatile) registers:   RBX, RBP, RDI, RSI, RSP, R12, R13, R14, R15   ;
;                    parameter registers:   RCX, RDX, R8, R9                              ;
;-----------------------------------------------------------------------------------------;
;    ---------------------------------------
;   |            REGISTER STATUS            |
;   |  src: rcx          key: r8            |
;   |  result: XMM0-3                       |
;    ---------------------------------------
    pxor        xmm0, xmm3                      ; Apply round key
    cmp         rdi,12

    aesdec      xmm0, xmm4                      ; Decryption round 4
    aesdec      xmm0, xmm5                      ; Decryption round 5
    aesdec      xmm0, xmm6                      ; Decryption round 6
    aesdec      xmm0, xmm7                      ; Decryption round 7
    aesdec      xmm0, xmm8                      ; Decryption round 8
    aesdec      xmm0, xmm9                      ; Decryption round 9
    aesdec      xmm0, xmm10                      ; Decryption round 10
    aesdec      xmm0, xmm11                      ; Decryption round 11
    aesdec      xmm0, xmm12                      ; Decryption round 12
    jb          aes_dec_1_last                  ; jump, if less than 12 rounds (128 bit AES)
    movdqu      xmm13, [r8 + 0A0h ]
    aesdec      xmm0, xmm13                     ; Decryption round 10
    movdqu      xmm14, [r8 + 0B0h ]
    movdqu      xmm13, [r8 + 0C0h ]
    aesdec      xmm0, xmm14                     ; Decryption round 11
    movdqu      xmm14, [r8 + 0D0h ]
    je          aes_dec_1_last                  ; jump, if 12 rounds (196 bit AES)
    aesdec      xmm0, xmm13                     ; Decryption round 12
    aesdec      xmm0, xmm14                     ; Decryption round 13
aes_dec_1_last:
    aesdeclast  xmm0, xmm15                     ; Decryption last round
    ret
ms_aes_dec_1 endp

    
;extern "C" void m_impl_aes_ecb_encrypt(const unsigned char * abyp_in,
;                                      unsigned char * abyp_out,
;                                      const unsigned char * abyp_key,
;                                      size_t szp_block_count,
;                                      size_t imp_number_of_rounds);
m_impl_aes_ecb_encrypt proc
;-----------------------------------------------------------------------------------------;
;  Calling convention: Microsoft x64                                                      ;
;-----------------------------------------------------------------------------------------;
;           scratch (volatile) registers:   RAX, RCX, RDX, R8, R9, R10, R11               ;
;   callee-save (non-volatile) registers:   RBX, RBP, RDI, RSI, RSP, R12, R13, R14, R15   ;
;                    parameter registers:   RCX, RDX, R8, R9                              ;
;-----------------------------------------------------------------------------------------;
    ; ommit stack frame, it is not used
    push rdi
    mov  rdi, [rsp+030H]
    sub     rsp, 0100h
    movdqu  xmm6,[rsp + 000h]
    movdqu  xmm7,[rsp + 010h]
    movdqu  xmm8,[rsp + 020h]
    movdqu  xmm9,[rsp + 030h]
    movdqu  xmm10,[rsp + 040h]
    movdqu  xmm11,[rsp + 050h]
    movdqu  xmm12,[rsp + 060h]
    movdqu  xmm13,[rsp + 070h]
    movdqu  xmm14,[rsp + 080h]
    movdqu  xmm15,[rsp + 090h]

;    ---------------------------------------
;   |            REGISTER STATUS            |
;   |  src: rcx          dest: rdx          |
;   |  key: r8           block cnt: r9      |
;   |  rounds: rdi                          |
;    ---------------------------------------
    cmp         r9,0
    jz          ecb_enc_end_4

    mov         r10, rdi
    shl         r10, 4

;    ---------------------------------------
;   |            REGISTER STATUS              |
;   |  src: rcx          dest: rdx            |
;   |  key: r8           block cnt: r9        |
;   |  rounds: rdi       last key offset: R10 |
;    ---------------------------------------
    cmp         r9,4
    jl          ecb_enc_4_loop_end

align 16
ecb_enc_4_loop_start:
    movdqu      xmm0,[rcx + 00h]               ; Load input block 0
    movdqu      xmm1,[rcx + 010h]               ; Load input block 1
    movdqu      xmm2,[rcx + 020h]               ; Load input block 2
    movdqu      xmm3,[rcx + 030h]               ; Load input block 3
    call        ms_aes_enc_4
    lea         rcx,[rcx+40h]
    movdqu      [rdx + 00h], xmm0              ; Store output block 0
    movdqu      [rdx + 010h], xmm1              ; Store output block 1
    movdqu      [rdx + 020h], xmm2              ; Store output block 2
    movdqu      [rdx + 030h], xmm3              ; Store output block 3
    lea         rdx,[rdx+40h]
    sub         r9,4
    jz          ecb_enc_end_4
    cmp         r9,4
    jge         ecb_enc_4_loop_start

    add         r9,4
ecb_enc_4_loop_end:
    mov         r10, rdi
    shl         r10, 4
    
    movdqu      xmm3, [r8]
    movdqu      xmm4, [r8 + 010h]
    movdqu      xmm5, [r8 + 020h]
    movdqu      xmm6, [r8 + 030h]
    movdqu      xmm7, [r8 + 040h]
    movdqu      xmm8, [r8 + 050h]
    movdqu      xmm9, [r8 + 060h]
    movdqu      xmm10, [r8 + 070h]
    movdqu      xmm11, [r8 + 080h]
    movdqu      xmm12, [r8 + 090h]
    movdqu      xmm15, [r8 + r10]
ecb_enc_loop_4_2:
    movdqu      xmm0,[rcx + 00h]               ; Load input block 0
    call        ms_aes_enc_1
    lea         rcx,[rcx+16]
    movdqu      [rdx],xmm0
    lea         rdx,[rdx+16]
    dec         r9
    jnz         ecb_enc_loop_4_2

ecb_enc_end_4:

    movdqu  [rsp + 000h],xmm6
    movdqu  [rsp + 010h],xmm7
    movdqu  [rsp + 020h],xmm8
    movdqu  [rsp + 030h],xmm9
    movdqu  [rsp + 040h],xmm10
    movdqu  [rsp + 050h],xmm11
    movdqu  [rsp + 060h],xmm12
    movdqu  [rsp + 070h],xmm13
    movdqu  [rsp + 080h],xmm14
    movdqu  [rsp + 090h],xmm15
    add     rsp, 0100h
    pop rdi
    ret
m_impl_aes_ecb_encrypt endp

;extern "C" void m_impl_aes_ctr(const unsigned char * abyp_input,
;                              unsigned char * abyp_output,
;                              const unsigned char * adsp_key,
;                              size_t szp_block_count,
;                              size_t inp_rounds,
;                              unsigned char * abyp_iv);
m_impl_aes_ctr proc
;-----------------------------------------------------------------------------------------;
;  Calling convention: Microsoft x64                                                      ;
;-----------------------------------------------------------------------------------------;
;           scratch (volatile) registers:   RAX, RCX, RDX, R8, R9, R10, R11               ;
;   callee-save (non-volatile) registers:   RBX, RBP, RDI, RSI, RSP, R12, R13, R14, R15   ;
;                    parameter registers:   RCX, RDX, R8, R9                              ;
;-----------------------------------------------------------------------------------------;
    push rsi
    mov  rsi, [rsp+038H]
    push rdi
    mov  rdi, [rsp+038H]
    push        r12
    push        r13
    push        r14
    sub     rsp, 020h
    movdqu  xmm6,[rsp + 000h]
    movdqu  xmm7,[rsp + 010h]
;    ---------------------------------------
;   |            REGISTER STATUS            |
;   |  src: rcx          dest: rdx          |
;   |  key: r8           block cnt: r9      |
;   |  rounds: rdi       IV: rsi            |
;    ---------------------------------------

    mov         r10, rdi
    shl         r10, 4

    movdqu      xmm0, [rsi]
    mov         eax, [rsi+0Ch]
    bswap       eax
    dec         eax
    sub         rsp, 040h
    movdqu      [rsp], xmm0

    movdqu      [rsp + 010h], xmm0
    movdqu      [rsp + 020h], xmm0
    movdqu      [rsp + 030h], xmm0
        
    movdqa      xmm2, xmm0
    cmp         r9,4
    jl          aes_ctr_1_start
aes_ctr_4_loop:
    movdqa      xmm0, xmm2
    lea         r11d, [eax+1]
    bswap       r11d
    pinsrw      xmm0, r11d, 6
    shr         r11d, 16
    pinsrw      xmm0, r11d, 7
    movdqa      xmm1, xmm2
    lea         r12d, [eax+2]
    bswap       r12d
    pinsrw      xmm1, r12d, 6
    shr         r12d, 16
    pinsrw      xmm1, r12d, 7
    movdqa      xmm2, xmm2
    lea         r13d, [eax+3]
    bswap       r13d
    pinsrw      xmm2, r13d, 6
    shr         r13d, 16
    pinsrw      xmm2, r13d, 7
    movdqa      xmm3, xmm2
    lea         r14d, [eax+4]
    bswap       r14d
    pinsrw      xmm3, r14d, 6
    shr         r14d, 16
    pinsrw      xmm3, r14d, 7
    lea         eax, [eax+4]
    call        ms_aes_enc_4
    movdqu      xmm4,[rcx + 00h]               ; Load input block 4
    movdqu      xmm5,[rcx + 010h]               ; Load input block 5
    movdqu      xmm6,[rcx + 020h]               ; Load input block 6
    movdqu      xmm7,[rcx + 030h]               ; Load input block 7
    lea         rcx, [rcx + 16*4]
    pxor        xmm0, xmm4
    pxor        xmm1, xmm5
    pxor        xmm2, xmm6
    pxor        xmm3, xmm7
    movdqu      [rdx + 00h], xmm0              ; Store output block 0
    movdqu      [rdx + 010h], xmm1              ; Store output block 1
    movdqu      [rdx + 020h], xmm2              ; Store output block 2
    movdqu      [rdx + 030h], xmm3              ; Store output block 3
    movdqu      xmm2, [rsp]
    lea         rdx, [rdx + 16*4]
    sub         r9,4
    cmp         r9,4
    jge         aes_ctr_4_loop

aes_ctr_1_start:
    mov         r10, rdi
    shl         r10, 4
    
    movdqu      xmm3, [r8]
    movdqu      xmm4, [r8 + 010h]
    movdqu      xmm5, [r8 + 020h]
    movdqu      xmm6, [r8 + 030h]
    movdqu      xmm7, [r8 + 040h]
    movdqu      xmm8, [r8 + 050h]
    movdqu      xmm9, [r8 + 060h]
    movdqu      xmm10, [r8 + 070h]
    movdqu      xmm11, [r8 + 080h]
    movdqu      xmm12, [r8 + 090h]
    movdqu      xmm15, [r8 + r10]
    cmp         r9,0
    jz          aes_ctr_end
aes_ctr_1_loop:
    inc         eax
    movdqa      xmm0, xmm2
    mov         r12d, eax
    bswap       r12d
    pinsrw      xmm0, r12d, 6
    shr         r12d, 16
    pinsrw      xmm0, r12d, 7
    call        ms_aes_enc_1
    movdqu      xmm1, [rcx]
    lea         rcx, [rcx+16]
    pxor        xmm1,xmm0
    movdqu      [rdx],xmm1
    lea         rdx, [rdx+16]
    dec         r9
    jnz         aes_ctr_1_loop
    movdqa      xmm0, xmm2

aes_ctr_end:
    inc         eax
    bswap       eax
    pinsrw      xmm0, eax, 6
    shr         eax, 16
    pinsrw      xmm0, eax, 7
    call        ms_aes_enc_1
    movdqu      [rsi], xmm0

    add         rsp, 040h

    movdqu  [rsp + 000h],xmm6
    movdqu  [rsp + 010h],xmm7
    add     rsp, 020h
    pop         r14
    pop         r13
    pop         r12
    pop rdi
    pop rsi
    ret
m_impl_aes_ctr endp

m_impl_aes_cbc_encrypt proc
;-----------------------------------------------------------------------------------------;
;  Calling convention: Microsoft x64                                                      ;
;-----------------------------------------------------------------------------------------;
;           scratch (volatile) registers:   RAX, RCX, RDX, R8, R9, R10, R11               ;
;   callee-save (non-volatile) registers:   RBX, RBP, RDI, RSI, RSP, R12, R13, R14, R15   ;
;                    parameter registers:   RCX, RDX, R8, R9                              ;
;-----------------------------------------------------------------------------------------;
    push rsi
    mov  rsi, [rsp+038H]
    push rdi
    mov  rdi, [rsp+038H]
    sub     rsp, 0100h
    movdqu  xmm6,[rsp + 000h]
    movdqu  xmm7,[rsp + 010h]
    movdqu  xmm8,[rsp + 020h]
    movdqu  xmm9,[rsp + 030h]
    movdqu  xmm10,[rsp + 040h]
    movdqu  xmm11,[rsp + 050h]
    movdqu  xmm12,[rsp + 060h]
    movdqu  xmm13,[rsp + 070h]
    movdqu  xmm14,[rsp + 080h]
    movdqu  xmm15,[rsp + 090h]
;    ---------------------------------------
;   |            REGISTER STATUS            |
;   |  src: rcx          dest: rdx          |
;   |  key: r8           block cnt: r9      |
;   |  rounds: rdi       IV: rsi            |
;    ---------------------------------------
    
    cmp         r9, 0
    je          aes_cbc_enc_end

    mov         r10, rdi
    shl         r10, 4
    
    movdqu      xmm3, [r8]
    movdqu      xmm4, [r8 + 010h]
    movdqu      xmm5, [r8 + 020h]
    movdqu      xmm6, [r8 + 030h]
    movdqu      xmm7, [r8 + 040h]
    movdqu      xmm8, [r8 + 050h]
    movdqu      xmm9, [r8 + 060h]
    movdqu      xmm10, [r8 + 070h]
    movdqu      xmm11, [r8 + 080h]
    movdqu      xmm12, [r8 + 090h]
    movdqu      xmm15, [r8 + r10]
    movdqu      xmm0, [rsi]                  ; Load IV
aes_cbc_enc_loop:
;    ---------------------------------------
;   |            REGISTER STATUS            |
;   |  src: rcx          dest: rdx          |
;   |  key: r8           block cnt: r9      |
;   |  rounds: rdi       curr IV: XMM0          |
;    ---------------------------------------
    movdqu      xmm1, [rcx]                  ; Load source
    lea         rcx, [rcx+16]
    pxor        xmm0, xmm1
    call        ms_aes_enc_1
    movdqu      [rdx], xmm0
    lea         rdx, [rdx+16]
    dec         r9
    jnz         aes_cbc_enc_loop

aes_cbc_enc_end:
    
    movdqu  [rsp + 000h],xmm6
    movdqu  [rsp + 010h],xmm7
    movdqu  [rsp + 020h],xmm8
    movdqu  [rsp + 030h],xmm9
    movdqu  [rsp + 040h],xmm10
    movdqu  [rsp + 050h],xmm11
    movdqu  [rsp + 060h],xmm12
    movdqu  [rsp + 070h],xmm13
    movdqu  [rsp + 080h],xmm14
    movdqu  [rsp + 090h],xmm15
    add     rsp, 0100h
    pop rdi
    pop rsi
    ret
m_impl_aes_cbc_encrypt endp
    
m_impl_aes_cbc_decrypt proc
;-----------------------------------------------------------------------------------------;
;  Calling convention: Microsoft x64                                                      ;
;-----------------------------------------------------------------------------------------;
;           scratch (volatile) registers:   RAX, RCX, RDX, R8, R9, R10, R11               ;
;   callee-save (non-volatile) registers:   RBX, RBP, RDI, RSI, RSP, R12, R13, R14, R15   ;
;                    parameter registers:   RCX, RDX, R8, R9                              ;
;-----------------------------------------------------------------------------------------;
    push rsi
    mov  rsi, [rsp+038H]
    push rdi
    mov  rdi, [rsp+038H]
    sub     rsp, 0100h
    movdqu  xmm6,[rsp + 000h]
    movdqu  xmm7,[rsp + 010h]
    movdqu  xmm8,[rsp + 020h]
    movdqu  xmm9,[rsp + 030h]
    movdqu  xmm10,[rsp + 040h]
    movdqu  xmm11,[rsp + 050h]
    movdqu  xmm12,[rsp + 060h]
    movdqu  xmm13,[rsp + 070h]
    movdqu  xmm14,[rsp + 080h]
    movdqu  xmm15,[rsp + 090h]
;    ---------------------------------------
;   |            REGISTER STATUS            |
;   |  src: rcx          dest: rdx          |
;   |  key: r8           block cnt: r9      |
;   |  rounds: rdi       IV: rsi            |
;    ---------------------------------------

    cmp         r9, 0
    je          aes_cbc_dec_end


    movdqu      xmm8, [rsi]                  ; Load first IV
    
    cmp         r9, 4
    jl          aes_cbc_dec_1_start

    mov         r10, rdi
    shl         r10, 4

    movdqu      xmm14, [r8]                 ; Preload roundkey
    movdqu      xmm15, [r8 + r10]                 ; Preload last key
aes_cbc_dec_4_loop:
    movdqu      xmm0,[rcx + 00h]               ; Load input block 0
    movdqu      xmm1,[rcx + 010h]               ; Load input block 1
    movdqu      xmm2,[rcx + 020h]               ; Load input block 2
    movdqu      xmm3,[rcx + 030h]               ; Load input block 3
    lea         rcx, [rcx + 040h]
    movdqa      xmm4, xmm8
    movdqa      xmm5, xmm0
    movdqa      xmm6, xmm1
    movdqa      xmm7, xmm2
    movdqa      xmm8, xmm3
    call        ms_aes_dec_4
    pxor        xmm0, xmm4
    movdqu      [rdx], xmm0
    pxor        xmm1, xmm5
    movdqu      [rdx+010h], xmm1
    pxor        xmm2, xmm6
    movdqu      [rdx+020h], xmm2
    pxor        xmm3, xmm7
    movdqu      [rdx+030h], xmm3
    lea         rdx, [rdx + 040h]
    sub         r9,4
    jz          aes_cbc_dec_end
    cmp         r9,4
    jge         aes_cbc_dec_4_loop

aes_cbc_dec_1_start:
    movdqa      xmm1, xmm8
    mov         r10, rdi
    shl         r10, 4
    
    movdqu      xmm3, [r8]
    movdqu      xmm4, [r8 + 010h]
    movdqu      xmm5, [r8 + 020h]
    movdqu      xmm6, [r8 + 030h]
    movdqu      xmm7, [r8 + 040h]
    movdqu      xmm8, [r8 + 050h]
    movdqu      xmm9, [r8 + 060h]
    movdqu      xmm10, [r8 + 070h]
    movdqu      xmm11, [r8 + 080h]
    movdqu      xmm12, [r8 + 090h]
    movdqu      xmm15, [r8 + r10]
aes_cbc_dec_1_loop:
    movdqu      xmm0, [rcx]
    lea         rcx, [rcx+16]
    movdqa      xmm2, xmm0
    call        ms_aes_dec_1
    pxor        xmm0, xmm1
    movdqu      [rdx], xmm0
    lea         rdx, [rdx+16]
    movdqa      xmm1, xmm2
    dec         r9
    jnz         aes_cbc_dec_1_loop

aes_cbc_dec_end:
    movdqu  [rsp + 000h],xmm6
    movdqu  [rsp + 010h],xmm7
    movdqu  [rsp + 020h],xmm8
    movdqu  [rsp + 030h],xmm9
    movdqu  [rsp + 040h],xmm10
    movdqu  [rsp + 050h],xmm11
    movdqu  [rsp + 060h],xmm12
    movdqu  [rsp + 070h],xmm13
    movdqu  [rsp + 080h],xmm14
    movdqu  [rsp + 090h],xmm15
    add     rsp, 0100h
    pop rdi
    pop rsi
    ret
m_impl_aes_cbc_decrypt endp

ms_ghash_asm proc
;-----------------------------------------------------------------------------------------;
;  Calling convention: Microsoft x64                                                      ;
;-----------------------------------------------------------------------------------------;
;           scratch (volatile) registers:   RAX, RCX, RDX, R8, R9, R10, R11               ;
;   callee-save (non-volatile) registers:   RBX, RBP, RDI, RSI, RSP, R12, R13, R14, R15   ;
;                    parameter registers:   RCX, RDX, R8, R9                              ;
;-----------------------------------------------------------------------------------------;
;RSP+038H holds Hash key H (128 bits)
;xmm1 holds new X (128 bits)
;rsp+048H holds the old state and takes the new
    pshufb      xmm1, [RSP+058H]    ; Byte-swap input

    pxor        xmm1, [rsp+048H]
    movdqu      xmm3, [RSP+038H]
    pclmulqdq   xmm3, xmm1, 0       ; xmm3 holds D = a0*b0

    movdqu      xmm6, [RSP+038H]
    pclmulqdq   xmm6, xmm1, 17      ; xmm6 holds C= a1*b1

    movdqa      xmm7, xmm1
    psrldq      xmm1, 8             ; b0 = b1
    pxor        xmm1, xmm7          ; b0 = b1+b0
    pclmulqdq   xmm1, [RSP+008H], 0 ; xmm1 holds E = (a0+a1)*(b0+b1)

    pxor        xmm1, xmm3          ; E += D
    pxor        xmm1, xmm6          ; E += C
    movdqa      xmm4, xmm1          ; load E = E+D+C
    psrldq      xmm1, 8             ; get e1+d1+c1 in low DQword
    pslldq      xmm4, 8             ; get e0+c0+d0 in high DQword
    pxor        xmm6, xmm1          ; x2 = c0+e1+d1+c1, x3 = c1
    pxor        xmm3, xmm4          ; x1 = d1+e0+d0+c0, x0 = d0
        
    ; <xmm6:xmm3> holds the result of 
; the carry
; shift the result by one bit position to the left cope for the fact
; that bits are reversed
    movdqa      xmm7, xmm3
    movdqa      xmm1, xmm6
    pslld       xmm3, 1
    pslld       xmm6, 1
    psrld       xmm7, 31
    psrld       xmm1, 31
    movdqa      xmm4, xmm7
    pslldq      xmm1, 4
    pslldq      xmm7, 4
    psrldq      xmm4, 12
    por         xmm3, xmm7
    por         xmm6, xmm1
    por         xmm6, xmm4
; first phase of the reduction
    movdqa      xmm7, xmm3
    movdqa      xmm1, xmm3
    movdqa      xmm4, xmm3   
    pslld       xmm7, 31            ; packed right shifting << 31 
    pslld       xmm1, 30            ; packed right shifting shift << 30
    pslld       xmm4, 25            ; packed right shifting shift << 25 
    pxor        xmm7, xmm1          ; xor the shifted versions
    pxor        xmm7, xmm4  
    movdqa      xmm1, xmm7
    pslldq      xmm7, 12
    psrldq      xmm1, 4
    pxor        xmm3, xmm7          ; first phase of the reduction complete 
    movdqa      xmm2, xmm3          ; second phase of the reduction
    movdqa      xmm4, xmm3
    movdqa      xmm5, xmm3  
    psrld       xmm2, 1             ; packed left shifting >> 1
    psrld       xmm4, 2             ; packed left shifting >> 2
    psrld       xmm5, 7             ; packed left shifting >> 7   
    pxor        xmm2, xmm4          ; xor the shifted versions
    pxor        xmm2, xmm5
    pxor        xmm2, xmm1
    pxor        xmm3, xmm2 
    pxor        xmm6, xmm3          ; the result is in xmm6 
    movdqu      [rsp+048H], xmm6    ; store the result

    ret
ms_ghash_asm endp

;extern "C" void m_impl_ghash_stream(unsigned char* achp_hash_state,
;								    const unsigned char* achp_hash_key,
;								    const unsigned char* achp_data,
;							 	   size_t szp_data_len);
m_impl_ghash_stream proc
;-----------------------------------------------------------------------------------------;
;  Calling convention: Microsoft x64                                                      ;
;-----------------------------------------------------------------------------------------;
;           scratch (volatile) registers:   RAX, RCX, RDX, R8, R9, R10, R11               ;
;   callee-save (non-volatile) registers:   RBX, RBP, RDI, RSI, RSP, R12, R13, R14, R15   ;
;                    parameter registers:   RCX, RDX, R8, R9                              ;
;-----------------------------------------------------------------------------------------;
    sub     rsp, 020h
    movdqu  xmm6,[rsp + 000h]
    movdqu  xmm7,[rsp + 010h]

    lea         rax, [ GCM_BSWAP]                ; Load address of byte swap mask, avoids problems with largeaddressaware and on MAC
    movdqu      xmm0, [rcx]
    movdqu      xmm1, [rdx]
    movdqu      xmm3, [rax]
    ; move stack the same way as m_impl_aes_gcm_auth_* do, so m_ghash_asm can be used
    ; we don't need the full space, just as far as m_ghash_asm requires
    sub         rsp, 068h

    pshufb      xmm1, xmm3                      ; byte swap the key
	pshufb		xmm0, xmm3						; byte swap the state
    movdqa      [rsp+040h], xmm0                ; state in RSP+040h (048h in m_ghash_asm)
    movdqa      [rsp+030h], xmm1                ; key in RSP+030h (038h in m_ghash_asm)
    movdqa      [rsp+050h], xmm3                ; swap mask in RSP+050h (058h in m_ghash_asm)
    movdqa      xmm2, xmm1
    psrldq      xmm2, 8                         ; a0 = a1
    pxor        xmm2, xmm1                      ; a0 = a1+a0
    movdqa      [RSP], xmm2                     ; self-added key in RSP+000h (008h in m_ghash_asm)

    cmp         r9, 010h
    jl          gcm_stream_partial

gcm_stream_block_loop:
    movdqu      xmm1, [r8]                      ; input to xmm1
    call        ms_ghash_asm
    lea         r8, [r8+010h]
    sub         r9, 010h
    cmp         r9, 010h
    jge         gcm_stream_block_loop
 
gcm_stream_partial:
    cmp         r9, 0
    je          gcm_stream_no_partial
    pxor        xmm0, xmm0
    movdqa      [rsp+010H], xmm0                ; push a 0 block to stack to generate 0-padding

gcm_stream_partial_loop:
    mov         al, [r8+r9-01h]
    mov         [rsp+r9+00fh], al
    dec         r9
    jnz         gcm_stream_partial_loop
    movdqu      xmm1, [rsp+010h]
    call        ms_ghash_asm

gcm_stream_no_partial:
    movdqu      xmm0, [rsp+040h]			; load state from stack
	pshufb		xmm0, [rsp+050h]			; byte swap the state
    movdqu      [rcx], xmm0					; store state back to parameter

    lea         rsp, [rsp+068h]

    movdqu  [rsp + 000h],xmm6
    movdqu  [rsp + 010h],xmm7
    add     rsp, 020h
    ret
m_impl_ghash_stream endp

end
