%IF DEF UNIX$NASM;
%DISP:precompiling is-encry-2-x64.pre for Unix NASM
;Generated by: xbprecomp01 is-encry-2-x64.pre is-encry-2-x64.s "%%%%SET UNIX$NASM=1;"

;-----------------------------------------------------------------------------------------;
;  Assembler : NASM                                                                       ;
;  Reference version: 2.09                                                                ;
;  Recommended flags:                                                                     ;
;    on Linux/FreeBSD: -f elf64 -F dwarf -g                                               ;
;    on Mac OS:        -f macho64                                                         ;
;-----------------------------------------------------------------------------------------;
section .data

GCM_BSWAP: db 15,14,13,12,11,10,9,8,7,6,5,4,3,2,1,0

section .text

; NASM uses 'QWORD' not 'QWORD PTR'. This define will make it work
%%define PTR
%DEFT FUNCTION_EXTERN:global_function
%DEFT PUSH_RDI:
%DEFT POP_RDI:
%DEFT PUSH_RSI:
%DEFT POP_RSI:
%DEFT PARAM_1:rdi
%DEFT PARAM_2:rsi
%DEFT PARAM_3:rdx
%DEFT PARAM_4:rcx
%DEFT PARAM_5:r8
%DEFT PARAM_6:r9

%MACRO:FUNCTION_HEADER(mtext:name, mint:params);
%TEXT:name;:
_%TEXT:name;:
;-----------------------------------------------------------------------------------------;
;  Calling convention: System V AMD64 ABI                                                 ;
;-----------------------------------------------------------------------------------------;
;           scratch (volatile) registers:   RAX, RCX, RDX, RDI, RSI, R8, R9, R10, R11     ;
;   callee-save (non-volatile) registers:   RBX, RBP, RSP, R12, R13, R14, R15             ;
;                    parameter registers:   RDI, RSI, RDX, RCX, R8, R9                    ;
;-----------------------------------------------------------------------------------------;
%IF EQ params-5;
;    ---------------------------------------
;   |            REGISTER STATUS            |
;   |  dst  : RDI                           |
;   |  src1 : RSI         src1_len : RDX    |
;   |  src2 : RCX         src2_len : R8     |
;    ---------------------------------------
    mov  r10, rdi                       ;   Move destination pointer to R10 for consistency with Windows
    mov  r9, rcx                        ;   Move src2 to R9 for consistency with Windows
    mov  rcx, rdx                       ;   Move src1_len to RCX
    xchg rcx, r8                        ;   swap R8 and RCX for consistency with Windows
    mov  rdx, rsi                       ;   Move src1 to RDX for consistency with Windows
%CEND;
%IF EQ params+5;
;    ---------------------------------------
;   |            REGISTER STATUS            |
;   |  dst  : RDI                           |
;   |  src1 : RSI         src1_len : RDX    |
;   |  src2 : RCX         src2_len : R8     |
;    ---------------------------------------
    mov   r9, rcx                       ;   load src2 to r9, matching windows
    mov   rcx, r8                       ;   load src2_len to rcx, matching windows
    mov   r8, rdx                       ;   load src1_len to r8, matching windows
%CEND;
%IF EQ params-3;
;    ---------------------------------------
;   |            REGISTER STATUS            |
;   |  src1 : RDI                           |
;   |  src2 : RSI         src_len : RDX     |
;    ---------------------------------------
    mov  r10, rdi                       ;   Move src1 to R10 for consistency with Windows
    mov  rcx, rdx                       ;   Move src_len to RCX
    mov  rdx, rsi                       ;   Move src2 to RDX for consistency with Windows
%CEND;
%IF EQ params-4;
;    ---------------------------------------
;   |            REGISTER STATUS            |
;   |  dest : RDI         src1:     RSI     |
;   |  src2 : RDX         src_len : RCX     |
;    ---------------------------------------
    mov  r10, rdi                       ;   Move dest to R10 for consistency with Windows
    mov  r8, rdx                        ;   Move src2 to R8
    mov  rdx, rsi                       ;   Move src1 to RDX for consistency with Windows
%CEND;
%MEND;

%MACRO:FUNCTION_END(mtext:name);
%MEND;
%MACRO:LOAD_PARAMS(mint:count);
%MEND;

%MACRO:POP_PARAMS(mint:count);
%MEND;

%MACRO:PUSH_XMM(mint:first_xmm, mint:last_xmm);
%MEND;
%MACRO:POP_XMM(mint:first_xmm, mint:last_xmm);
%MEND;

;   This macro is used for movq with GP-Registers, as MASM doesn't implement this well
%%macro  movq_r  2
        movq  %%1, %%2
%%endmacro

%CEND;
%IF DEF WIN$VC;
%DISP:precompiling is-encry-2-x64.pre for Windows Visual Studio
;Generated by: xbprecomp01 is-encry-2-x64.pre is-encry-2-x64.asm "%%%%SET WIN$VC=1;"

;-----------------------------------------------------------------------------------------;
;  Assembler : MASM (Microsoft ASM)                                                       ;
;-----------------------------------------------------------------------------------------;
%DEFT FUNCTION_EXTERN:public
%DEFT PUSH_RDI:    push  rdi
%DEFT POP_RDI:    pop   rdi
%DEFT PUSH_RSI:    push  rsi
%DEFT POP_RSI:    pop   rsi
%DEFT PARAM_1:rcx
%DEFT PARAM_2:rdx
%DEFT PARAM_3:r8
%DEFT PARAM_4:r9
%DEFT PARAM_5:rdi
%DEFT PARAM_6:rsi

%MACRO:FUNCTION_HEADER(mtext:name, mint:params);
%TEXT:name; proc
;-----------------------------------------------------------------------------------------;
;  Calling convention: Microsoft x64                                                      ;
;-----------------------------------------------------------------------------------------;
;           scratch (volatile) registers:   RAX, RCX, RDX, R8, R9, R10, R11               ;
;   callee-save (non-volatile) registers:   RBX, RBP, RDI, RSI, RSP, R12, R13, R14, R15   ;
;                    parameter registers:   RCX, RDX, R8, R9                              ;
;-----------------------------------------------------------------------------------------;
%IF EQ params-5;
;    ---------------------------------------
;   |            REGISTER STATUS            |
;   |  dst  : RCX                           |
;   |  src1 : RDX         src1_len : R8     |
;   |  src2 : R9          src2_len : stack  |
;    ---------------------------------------
    mov  r10, rcx                       ;   destination to R10, freeing RCX
    mov  ecx, [rsp+028H]                ;   RCX = src2_len (accesing position of the 5th parameter).
                                        ;       0x28 bytes = 0x20 shadow space + 8 return address
%CEND;
%IF EQ params+5;
;    ---------------------------------------
;   |            REGISTER STATUS            |
;   |  dst  : RCX                           |
;   |  src1 : RDX         src1_len : R8     |
;   |  src2 : R9          src2_len : stack  |
;    ---------------------------------------
    push  rdi
    push  rsi
    mov   rdi, rcx                      ;   load dst to RDI to match UNIX
    mov   rsi, rdx                      ;   load src1 to RSI to match UNIX
    mov   ecx, [rsp+038H]               ;   R8 = src2_len (accesing position of the 5th parameter).
                                        ;       0x38 bytes = 0x20 shadow space + 8 return address + 2*8 for pushed registers

%CEND;
%IF EQ params-3;
;    ---------------------------------------
;   |            REGISTER STATUS            |
;   |  src1 : RCX                           |
;   |  src2 : RDX         src_len : R8      |
;    ---------------------------------------
    mov  r10, rcx                       ;   src1 to R10, freeing RCX
    mov  rcx, r8                        ;   load length to RCX
%CEND;
%IF EQ params-4;
;    ---------------------------------------
;   |            REGISTER STATUS            |
;   |  dest : RCX         src1:     RDX     |
;   |  src2 : R8          src_len : R9      |
;    ---------------------------------------
    mov  r10, rcx                       ;   dest to R10, freeing RCX
    mov  rcx, r9                        ;   load length to RCX
%CEND;
%MEND;

%MACRO:FUNCTION_END(mtext:name);
%TEXT:name; endp
%MEND;

%MACRO:LOAD_PARAMS(mint:count);
%IF EQ count-5;
    push rdi
    mov  rdi, [rsp+030H]
%CEND;
%IF EQ count-6;
    push rsi
    mov  rsi, [rsp+038H]
    push rdi
    mov  rdi, [rsp+038H]
%CEND;
%MEND;

%MACRO:POP_PARAMS(mint:count);
%IF EQ count-5;
    pop rdi
%CEND;
%IF EQ count-6;
    pop rdi
    pop rsi
%CEND;
%MEND;

%MACRO:PUSH_XMM(mint:first_xmm, mint:last_xmm);
%SET TOTAL_REGISTERS=last_xmm-first_xmm+1;
    sub     rsp, 0%INT:TOTAL_REGISTERS;0h
%SET INDEX=0;
%SET REGISTER=first_xmm;
%RPTN TOTAL_REGISTERS;
    movdqu  xmm%INT:REGISTER;,[rsp + 0%INT:INDEX;0h]
%SET INDEX=INDEX+1;
%SET REGISTER=REGISTER+1;
%REND;
%MEND;

%MACRO:POP_XMM(mint:first_xmm, mint:last_xmm);
%SET TOTAL_REGISTERS=last_xmm-first_xmm+1;
%SET INDEX=0;
%SET REGISTER=first_xmm;
%RPTN TOTAL_REGISTERS;
    movdqu  [rsp + 0%INT:INDEX;0h],xmm%INT:REGISTER;
%SET INDEX=INDEX+1;
%SET REGISTER=REGISTER+1;
%REND;
    add     rsp, 0%INT:TOTAL_REGISTERS;0h
%MEND;

;   This macro is used for movq with GP-Registers. MASM uses movd for moving 64 bit registers from and to XMM
movq_r   macro DEST, SRC
        movd  DEST, SRC
        endm

%CEND;
;        is-encry-2-x64.asm
;        Copyright (C) HOB Germany 2016
;
%IF DEF UNIX$NASM;

; This macro will generate the right symbols for the external functions, depending on output format
%%ifidn __OUTPUT_FORMAT__,macho64
%%macro global_function 1
global %%1
global _%%1
%%endmacro
%%else
%%macro global_function 1
global %%1:function
global _%%1:function
%%endmacro
%%endif
%CEND;

%TEXT:FUNCTION_EXTERN; m_impl_add
%TEXT:FUNCTION_EXTERN; m_impl_sub
%TEXT:FUNCTION_EXTERN; m_impl_cmp
%TEXT:FUNCTION_EXTERN; m_impl_mult_basic
%TEXT:FUNCTION_EXTERN; m_impl_square
%TEXT:FUNCTION_EXTERN; m_impl_add_karatsuba
%TEXT:FUNCTION_EXTERN; m_impl_sub_karatsuba
%TEXT:FUNCTION_EXTERN; m_impl_add_word
%TEXT:FUNCTION_EXTERN; m_impl_sqr_8
%TEXT:FUNCTION_EXTERN; m_impl_mont_mul_add
%TEXT:FUNCTION_EXTERN; m_impl_first_bit
%TEXT:FUNCTION_EXTERN; m_impl_last_bit
%TEXT:FUNCTION_EXTERN; m_impl_aes_256_key_expansion
%TEXT:FUNCTION_EXTERN; m_impl_aes_192_key_expansion
%TEXT:FUNCTION_EXTERN; m_impl_aes_128_key_expansion
%TEXT:FUNCTION_EXTERN; m_impl_aes_revert_key
%TEXT:FUNCTION_EXTERN; m_impl_aes_ecb_encrypt
%TEXT:FUNCTION_EXTERN; m_impl_aes_ctr
%TEXT:FUNCTION_EXTERN; m_impl_aes_cbc_encrypt
%TEXT:FUNCTION_EXTERN; m_impl_aes_cbc_decrypt
%TEXT:FUNCTION_EXTERN; m_impl_ghash_stream
%TEXT:FUNCTION_EXTERN; m_x86_capabilities

%MACRO:mul_add_carry(mint:offset_1, mint:offset_2, mtext:register_low, mtext:register_mid, mtext:register_high);
    mov  rax, [ rsi + LEN_LNUM_ELE*%INT:offset_1; ]          ;   RAX = src[%INT:offset_1;]
    mul  QWORD PTR [ rsi + LEN_LNUM_ELE*%INT:offset_2; ]     ;   (RDX|RAX) = u|v = src[%INT:offset_1;]*src[%INT:offset_2;]
    add  %TEXT:register_low;, rax                               ;   sum_low = sum_low + v           |   carry set
    adc  %TEXT:register_mid;, rdx                               ;   sum_mid = sum_mid + u +cf       |   carry set
    adc  %TEXT:register_high;, 0                                 ;   sum_high = sum_high + cf        |   carry propagation only
%MEND;

%MACRO:mul_mov(mint:offset_1, mint:offset_2, mtext:register_low, mtext:register_mid);
    mov  rax, [ rsi + LEN_LNUM_ELE*%INT:offset_1; ]          ;   RAX = src[%INT:offset_1;]
    mul  QWORD PTR [ rsi + LEN_LNUM_ELE*%INT:offset_2; ]     ;   (RDX|RAX) = u|v = src[%INT:offset_1;]*src[%INT:offset_2;]
    mov  %TEXT:register_low;, rax                               ;   sum_low = v
    mov  %TEXT:register_mid;, rdx                               ;   sum_mid = u
%MEND;

%MACRO:double_3_words(mtext:register_low, mtext:register_mid, mtext:register_high);
    add  %TEXT:register_low;, %TEXT:register_low;                               ;   sum_low = 2*sum_low             |   carry set
    adc  %TEXT:register_mid;, %TEXT:register_mid;                               ;   sum_mid = 2*sum_mid + cf        |   carry set
    adc  %TEXT:register_high;, %TEXT:register_high;                               ;   sum_high = 2*sum_high + cf      |   will not cause carry
%MEND;

%MACRO:add_2_to_3_words(mtext:dest_low, mtext:dest_mid, mtext:dest_high, mtext:src_low, mtext:src_high);
    add  %TEXT:dest_low;, %TEXT:src_low;                                ;   sum_low = sum_low + c_low       |   carry set
    adc  %TEXT:dest_mid;, %TEXT:src_high;                                ;   sum_mid = sum_mid + c_mid + cf  |   carry set
    adc  %TEXT:dest_high;, 0                                 ;   sum_high = sum_high + cf        |   carry propagation only
%MEND;

%MACRO:sqr_add_carry(mint:offset_1, mtext:register_low, mtext:register_mid, mtext:register_high);
    mov  rax, [ rsi + LEN_LNUM_ELE*%INT:offset_1; ]          ;   RAX = src[%INT:offset_1;]
    mul  rax                                    ;   (RDX|RAX) = u|v = src[%INT:offset_1;]^2
    add  %TEXT:register_low;, rax                               ;   sum_low = sum_low + v           |   carry set
    adc  %TEXT:register_mid;, rdx                               ;   sum_mid = sum_mid + u +cf       |   carry set
    adc  %TEXT:register_high;, 0                                 ;   sum_high = sum_high + cf        |   carry propagation only
%MEND;

LEN_QWORD          equ  8
LEN_LNUM_ELE       equ  8
%IF DEF WIN$VC;
.code
GCM_BSWAP BYTE 15,14,13,12,11,10,9,8,7,6,5,4,3,2,1,0
%CEND;

;       extern "C" int m_impl_add(LNUM_WORD* ap_dest,
;                                 LNUM_WORD* ap_a,
;                                 unsigned int szp_a_len,
;                                 LNUM_WORD* ap_b,
;                                 unsigned int szp_b_len);

%FUNCTION_HEADER(m_impl_add, 5);

;    ---------------------------------------
;   |            REGISTER STATUS            |
;   |  dst  : R10                           |
;   |  src1 : RDX         src1_len : R8     |
;   |  src2 : R9          src2_len : RCX    |
;    ---------------------------------------
    cmp  r8, rcx                        ;   src1_len ? src2_len
    jge  add_start                      ;   jump to the first loop configuration if src1_len >= src2_len

    ; src2 is longer, so we swap the pointers and lengths
    xchg rcx, r8                        ;   [ greater length (g_len) in R8   ;  smaller length (s_len) in RCX ]
    xchg rdx, r9                        ;   [ greater    src (g_src) in RDX  ;  smaller    src (s_src) in R9  ]

add_start:
;    ----------------------------------
;   |          REGISTER STATUS         |
;   |  dst   : R10                     |
;   |  g_src : RDX        g_len : R8   |
;   |  s_src : R9         s_len : RCX  |
;    ----------------------------------
    shr  r8, 3                          ;   Scale length parameters from bytes to (64-bit) words
    shr  rcx, 3
    sub  r8, rcx                        ;   Calculate, how many additional words the longer parameter has over the shorter
    xor  r11, r11                       ;   Clear R11 for use as address offset for the source and dest pointers

;    --------------------------------------------------------
;   |                    REGISTER STATUS                     |
;   |  dst   :  R10       temporary:                    RAX  |
;   |  g_src :  RDX       word for addition :           RCX  |
;   |  s_src :  R9        words for carry propagation : R8   |
;   |  offset : R11                                          |
;    --------------------------------------------------------
    xor  rax,rax                        ;   Clear RAX. AH will be used to store the flags to keep CF between loop runs, so this will effectively clear the CF.
    sub  rcx, 32                        ;   This checks, if at least 32 words are available and prepares the 32 word loop.
                                        ;   sub is used over cmp for the following reason:
                                        ;       At the end of the unrolled loop, 32 will be subtracted again from RCX.
                                        ;       By subtracting an additional block here, this will underflow, when there is less, than 32 words left, signaling the end of the loop.
    jl   add_unroll_32_end              ;   Jump beyond the loop, if less than 32 words are available for addition

%SET UNROLL_COUNT=32;
%SET IML$LE$02=8;

align 16
add_unroll_loop_%INT:UNROLL_COUNT;:

    sahf                                            ;   Restore carry flag

%SET STEP_NR=0;
%RPTN UNROLL_COUNT;
    mov  rax, [rdx + r11 + %INT:STEP_NR; * LEN_LNUM_ELE]  ;   g_src                       |  mov  :  no flags affected
    adc  rax, [ r9 + r11 + %INT:STEP_NR; * LEN_LNUM_ELE]  ;   g_src + s_src + carry       |  adc  :  CF is set regarding the carry value (OK: wished behaviour)
    mov  [r10 + r11 + %INT:STEP_NR; * LEN_LNUM_ELE], rax  ;   dst = g_src + s_src + carry |  mov  :  no flags affected
%SET STEP_NR=STEP_NR+1;
%REND;

    lahf                                            ;   save carry flag

    lea  r11, [r11 + %INT:UNROLL_COUNT; * LEN_LNUM_ELE]             ;   increase pointer offset
    sub  rcx, %INT:UNROLL_COUNT;                                    ;   subtract the processed words
    jge  add_unroll_loop_%INT:UNROLL_COUNT;                         ;   keep up the loop, until there are not enough words left

add_unroll_32_end:

;    --------------------------------------------------------
;   |                    REGISTER STATUS                     |
;   |  dst   :  R10       temporary:                    RAX  |
;   |  g_src :  RDX       word for addition - 32 :      RCX  |
;   |  s_src :  R9        words for carry propagation : R8   |
;   |  offset : R11                                          |
;    --------------------------------------------------------
    add  rcx, (32-8)                                ;   we subtracted one additional 32 word block, so restore that part, minus 8 words
                                                    ;   the same loop construct will be used for the 8 word unroll
    jnc  add_unroll_8_end                           ;   the add didn't cause a carry. This signals, that there are less, than 8 words, so we skip that loop
%SET UNROLL_COUNT=8;

align 16
add_unroll_loop_%INT:UNROLL_COUNT;:

    sahf                                            ;   Restore carry flag

%SET STEP_NR=0;
%RPTN UNROLL_COUNT;
    mov  rax, [rdx + r11 + %INT:STEP_NR; * LEN_LNUM_ELE]  ;   g_src                       |  mov  :  no flags affected
    adc  rax, [ r9 + r11 + %INT:STEP_NR; * LEN_LNUM_ELE]  ;   g_src + s_src + carry       |  adc  :  CF is set regarding the carry value (OK: wished behaviour)
    mov  [r10 + r11 + %INT:STEP_NR; * LEN_LNUM_ELE], rax  ;   dst = g_src + s_src + carry |  mov  :  no flags affected
%SET STEP_NR=STEP_NR+1;
%REND;

    lahf                                            ;   save carry flag

    lea  r11, [r11 + %INT:UNROLL_COUNT; * LEN_LNUM_ELE]             ;   increase pointer offset
    sub  rcx, %INT:UNROLL_COUNT;                                    ;   subtract the processed words
    jge  add_unroll_loop_%INT:UNROLL_COUNT;                         ;   keep up the loop, until there are not enough words left

add_unroll_8_end:
;    --------------------------------------------------------
;   |                    REGISTER STATUS                     |
;   |  dst   :  R10       temporary:                    RAX  |
;   |  g_src :  RDX       word for addition - 8 :       RCX  |
;   |  s_src :  R9        words for carry propagation : R8   |
;   |  offset : R11                                          |
;    --------------------------------------------------------
    add  rcx, 8                             ;   Add back the missing 8 words from the count

    sahf                                    ;   load carry flag
    jrcxz add_single_loop_end               ;   If no words for addition are left, jump to carry propagation

align 16
add_single_loop:
    mov  rax, [ rdx + r11 ]                 ;   g_src                       |  mov  :  no flags affected
    adc  rax, [  r9 + r11 ]                 ;   g_src + s_src + carry       |  adc  :  CF is set regarding the carry value (OK: wished behaviour)
    mov  [ r10 + r11 ], rax                 ;   dst = g_src + s_src + carry |  mov  :  no flags affected
    lea  r11, [ r11 + LEN_LNUM_ELE ]        ;   increment offset            |  lea  :  no flags affected
    loop add_single_loop                    ;                               |  loop :  no flags affected

add_single_loop_end:
    mov  rcx, r8                            ;   load the number of word, that need carry propagation
                                            ;   this means the words, that the larger input is longer, than the shorter
;    --------------------------------------------------------
;   |                    REGISTER STATUS                     |
;   |  dst   :  R10       temporary:                    RAX  |
;   |  g_src :  RDX       words for carry propagation : RCX  |
;   |  s_src :  R9        offset :                      R11  |
;    --------------------------------------------------------
    jrcxz add_carry_end                     ;   if both inputs were same size, jump the carry of the extra word

align 16
add_propagate_carry:
    mov  rax, [ rdx + r11 ]                 ;   g_src                       |  mov  :  no flags affected
    adc  rax, 0                             ;   g_src + cf                  |  adc  :  CF is set regarding the carry value (OK: wished behaviour)
    mov  [ r10 + r11 ], rax                 ;   dst = g_src + s_src + carry |  mov  :  no flags affected
    lea  r11, [ r11 + LEN_LNUM_ELE ]        ;   increment offset            |  lea  :  no flags affected
    loop add_propagate_carry                ;                               |  loop :  no flags affected

add_carry_end:
    jnc  add_epilogue                       ;   if no additional carry is there, go to the end
    mov  rax, 1                             ;   Load the carry out to RAX
    mov  [ r10 + r11 ], rax                 ;   Write the carry to the last destination word
    lea  r11, [ r11 + LEN_LNUM_ELE ]        ;   Increment the offset once more to get the total of bytes in the result

;----------------------------------------------------------------
add_epilogue:
    mov  rax, r11                           ;   Load bytes total into the RAX
    ret                                     ;   return
;----------------------------------------------------------------
%FUNCTION_END(m_impl_add);


;       extern "C" int m_impl_sub(LNUM_WORD* ap_dest,
;                                 LNUM_WORD* ap_a,
;                                 unsigned int szp_a_len,
;                                 LNUM_WORD* ap_b,
;                                 unsigned int szp_b_len);

%FUNCTION_HEADER(m_impl_sub, 5);

;    ---------------------------------------
;   |            REGISTER STATUS            |
;   |  dst  : R10                           |
;   |  min  : RDX          min_len : R8     |
;   |  sub  : R9           sub_len : RCX    |
;    ---------------------------------------
    sub  r8, rcx                        ;   Calculate, how many additional words the longer parameter has over the shorter
    xor  r11, r11                       ;   Clear R11 for use as address offset for the source and dest pointers

;    --------------------------------------------------------
;   |                    REGISTER STATUS                     |
;   |  dst    : R10       temporary:                    RAX  |
;   |  min    : RDX       word for addition :           RCX  |
;   |  sub    : R9        words for borrow propagation : R8  |
;   |  offset : R11                                          |
;    --------------------------------------------------------
    shr  r8, 3                          ;   Scale length parameters from bytes to (64-bit) words
    shr  rcx, 3
    xor  rax,rax                        ;   Clear RAX. AH will be used to store the flags to keep CF between loop runs, so this will effectively clear the CF.
    sub  rcx, 32                        ;   This checks, if at least 32 words are available and prepares the 32 word loop.
                                        ;   sub is used over cmp for the following reason:
                                        ;       At the end of the unrolled loop, 32 will be subtracted again from RCX.
                                        ;       By subtracting an additional block here, this will underflow, when there is less, than 32 words left, signaling the end of the loop.
    jl   sub_unroll_32_end              ;   Jump beyond the loop, if less than 32 words are available for addition
%SET UNROLL_COUNT=32;

align 16
sub_unroll_loop_%INT:UNROLL_COUNT;:

    sahf                                            ;   Restore carry flag

%SET STEP_NR=0;
%RPTN UNROLL_COUNT;
    mov  rax, [rdx + r11 + %INT:STEP_NR; * LEN_LNUM_ELE]  ;   min                      |  mov  :  no flags affected
    sbb  rax, [ r9 + r11 + %INT:STEP_NR; * LEN_LNUM_ELE]  ;   min - sub - borrow       |  sbb  :  CF is set regarding the borrow value (OK: wished behaviour)
    mov  [r10 + r11 + %INT:STEP_NR; * LEN_LNUM_ELE], rax  ;   dst = min - sub - borrow |  mov  :  no flags affected
%SET STEP_NR=STEP_NR+1;
%REND;

    lahf                                            ;   save carry flag

    lea  r11, [r11 + %INT:UNROLL_COUNT; * LEN_LNUM_ELE]             ;   increase pointer offset
    sub  rcx, %INT:UNROLL_COUNT;                                    ;   subtract the processed words
    jge  sub_unroll_loop_%INT:UNROLL_COUNT;                         ;   keep up the loop, until there are not enough words left

sub_unroll_32_end:

;    --------------------------------------------------------
;   |                    REGISTER STATUS                     |
;   |  dst   :  R10       temporary:                    RAX  |
;   |  min   :  RDX       word for subtraction - 32 :   RCX  |
;   |  sub   :  R9        words for borrow propagation : R8  |
;   |  offset : R11                                          |
;    --------------------------------------------------------
    add  rcx, (32-8)                                ;   we subtracted one additional 32 word block, so restore that part, minus 8 words
                                                    ;   the same loop construct will be used for the 8 word unroll
    jnc  sub_unroll_8_end                           ;   the add didn't cause a carry. This signals, that there are less, than 8 words, so we skip that loop
%SET UNROLL_COUNT=8;

align 16
sub_unroll_loop_%INT:UNROLL_COUNT;:

    sahf                                            ;   Restore carry flag

%SET STEP_NR=0;
%RPTN UNROLL_COUNT;
    mov  rax, [rdx + r11 + %INT:STEP_NR; * LEN_LNUM_ELE]  ;   min                      |  mov  :  no flags affected
    sbb  rax, [ r9 + r11 + %INT:STEP_NR; * LEN_LNUM_ELE]  ;   min - sub - borrow       |  sbb  :  CF is set regarding the borrow value (OK: wished behaviour)
    mov  [r10 + r11 + %INT:STEP_NR; * LEN_LNUM_ELE], rax  ;   dst = min - sub - borrow |  mov  :  no flags affected
%SET STEP_NR=STEP_NR+1;
%REND;

    lahf                                            ;   save carry flag

    lea  r11, [r11 + %INT:UNROLL_COUNT; * LEN_LNUM_ELE]             ;   increase pointer offset
    sub  rcx, %INT:UNROLL_COUNT;                                    ;   subtract the processed words
    jge  sub_unroll_loop_%INT:UNROLL_COUNT;                         ;   keep up the loop, until there are not enough words left

sub_unroll_8_end:
;    --------------------------------------------------------
;   |                    REGISTER STATUS                     |
;   |  dst   :  R10       temporary:                    RAX  |
;   |  min   :  RDX       word for addition - 8 :       RCX  |
;   |  sub   :  R9        words for borrow propagation : R8  |
;   |  offset : R11                                          |
;    --------------------------------------------------------
    add  rcx, 8                             ;   Add back the missing 8 words from the count

    sahf                                    ;   load carry flag
    jrcxz sub_single_loop_end               ;   If no words for subtraction are left, jump to borrow propagation

align 16
sub_single_loop:
    mov  rax, [ rdx + r11 ]                 ;   min                      |  mov  :  no flags affected
    sbb  rax, [  r9 + r11 ]                 ;   min - sub - borrow       |  sbb  :  CF is set regarding the borrow value (OK: wished behaviour)
    mov  [ r10 + r11 ], rax                 ;   dst = min - sub - borrow |  mov  :  no flags affected
    lea  r11, [ r11 + LEN_LNUM_ELE ]        ;   increment offset         |  lea  :  no flags affected
    loop sub_single_loop                    ;                            |  loop :  no flags affected

sub_single_loop_end:
    mov  rcx, r8                            ;   load the number of word, that need carry propagation
                                            ;   this means the words, that the larger input is longer, than the shorter
;    --------------------------------------------------------
;   |                    REGISTER STATUS                     |
;   |  dst   :  R10       temporary:                    RAX  |
;   |  min   :  RDX       words for borrow propagation: RCX  |
;   |  sub   :  R9        offset :                      R11  |
;    --------------------------------------------------------
    jrcxz sub_borrow_end                    ;   if both inputs were same size, jump the carry of the extra word

align 16
sub_propagate_borrow:
    mov  rax, [ rdx + r11 ]                 ;   min                       |  mov  :  no flags affected
    sbb  rax, 0                             ;   min - borrow              |  adc  :  CF is set regarding the carry value (OK: wished behaviour)
    mov  [ r10 + r11 ], rax                 ;   dst = min - borrow        |  mov  :  no flags affected
    lea  r11, [ r11 + LEN_LNUM_ELE ]        ;   increment offset          |  lea  :  no flags affected
    loop sub_propagate_borrow               ;                             |  loop :  no flags affected

sub_borrow_end:
    mov  rcx, r11                           ;   R11 is the offset, so it contains the number of written bytes
    jrcxz sub_epilogue                      ;   If no offset was ever generated, just jump to the end

sub_calc_ret_loop:
    mov  rax, [ r10 + rcx - LEN_LNUM_ELE]   ;   load the word BEFORE the current offset
    cmp  rax, 0                             ;   check, if that word is still 0
    jne  sub_epilogue                       ;   if we found the first non-0 word, break the loop
                                            ;   RCX will contain the index of that word + 8, so the total of used bytes.
    sub  rcx, 7                             ;   loop down with decrement of 8
    loop sub_calc_ret_loop                  ;   if RCX reaches 0, that would mean the LSW is 0, so we can also return 0

sub_epilogue:
    mov  rax, rcx                           ;   put the result
    ret                                     ;   return
;----------------------------------------------------------------
%FUNCTION_END(m_impl_sub);


; extern "C" int m_impl_cmp(const LNUM_WORD* ap_a,
;                           const LNUM_WORD* ap_b,
;                           unsigned int szp_b_len);
%FUNCTION_HEADER(m_impl_cmp, 3);

;    ---------------------------------------
;   |            REGISTER STATUS            |
;   |  src1 : R10                           |
;   |  src2 : RDX         src_len : RCX     |
;    ---------------------------------------

    jrcxz cmp_equal             ;   Length is 0, so the numbers are equal
    shr   rcx, 3                ;   Scale length parameter from bytes to (64-bit) words

    ;   this loop runs over the input from the highest order word to the lowest (i (length-1) to 0)
cmp_impl_loop:
    mov  r9, [ r10 + rcx * LEN_LNUM_ELE - LEN_LNUM_ELE]     ;   load word src1[i]
    cmp  r9, [ rdx + rcx * LEN_LNUM_ELE - LEN_LNUM_ELE]     ;   compare src1[i] with src2[i]
    jb cmp_1_less_than_2                                    ;   if src1[i] < src2[i], stop the loop, src1 is less
    ja cmp_1_greater_than_2                                 ;   if src1[i] > src2[i], stop the loop, src1 is greater
                                                            ;   ja and jb are required here, as they implement the unsigned cmp. jl and jg do not work
    loop cmp_impl_loop                                      ;   decrement RCX and keep looping

cmp_equal:
    mov  eax, 0                                             ;   All words were equal, so both numbers are equal. Set return value to 0.
    ret

cmp_1_less_than_2:
    mov  eax, -1                                            ;   src1 is less, than src2. Set return value to -1.
    ret

cmp_1_greater_than_2:
    mov  eax, 1                                             ;   src1 is greater, than src2. Set return value to 1.
    ret

%FUNCTION_END(m_impl_cmp);



; extern "C" void m_impl_mult_basic(LNUM_WORD* ap_dest,
;                                   const LNUM_WORD* ap_a,
;                                   unsigned int szp_a_len,
;                                   const LNUM_WORD* ap_b,
;                                   unsigned int szp_b_len);
; This implementation is based on Combas Method, also called product scanning
%FUNCTION_HEADER(m_impl_mult_basic, -5);
    push  rbx
    push  rbp
    push  r12
    push  r13
    push  r14
    push  r15
;    ---------------------------------------
;   |            REGISTER STATUS            |
;   |  dst  : RDI                           |
;   |  src1 : RSI         src1_len : R8     |
;   |  src2 : R9          src2_len : RCX    |
;    ---------------------------------------

    cmp   r8,rcx                    ;   Check which input is larger
    jge    mult_basic_start          ;   if src1 is larger, do nothing
    xchg  rsi, r9                   ;   swap src1 and src2
    xchg  r8,rcx                    ;   swap src1_len and src2_len

mult_basic_start:
;    ---------------------------------------
;   |            REGISTER STATUS            |
;   |  dst  : RDI                           |
;   |  src_l: RSI         src_l_len : R8    |
;   |  src_s: R9          src_s_len : RCX   |
;    ---------------------------------------
    shr   r8, 3                         ;   Scale length parameters from bytes to (64-bit) words
    shr   rcx, 3                        
    mov   rax, [rsi]                    ;   RAX = src_l[0];
    mul   QWORD PTR[r9]                 ;   (RDX|RAX) = src_l[0]*src_s[0]
    mov   [rdi], rax                    ;   dst[0] = RAX
    lea   rdi, [ rdi + LEN_LNUM_ELE ]   ;   get next dst pointer
    mov   r11, rdx                      ;   set carry for the loop
    xor   r10, r10                      ;   set carry for the loop
    mov   rbp, 1                        ;   set i_dest = 1
    cmp   rcx, 1                        ;   check if src_s_len is bigger, than 1
    je    mult_basic_middle_loop_setup  ;   src_s_len == 1, skip the first loop
    mov   rbx, LEN_LNUM_ELE             ;   i_src_s = 1

mult_basic_first_loop_outer:
;    ---------------------------------------
;   |            REGISTER STATUS            |
;   |  dst  : RDI         i_dest: RBP       |
;   |  src_l: RSI         src_l_len : R8    |
;   |  src_s: R9          src_s_len : RCX   |
;   |  (t1|t2|t3): R10|R11|R12              |
;   |  i_src_s: RBX                         |
;    ---------------------------------------
    mov   r12, r11                      ;   shift the carry from last round
    mov   r11, r10                      ;   shift the carry from last round
    xor   r10, r10                      ;   shift the carry from last round
    lea   rbx, [ rbx + LEN_LNUM_ELE ]   ;   i_src_s++

mult_basic_first_loop_inner:
    mov   rax, [rsi]                    ;   RAX = src_l[i_src_l];
    lea   rbx, [ rbx - LEN_LNUM_ELE ]   ;   i_src_s--
    mul   QWORD PTR[r9 + rbx]            ;   (RDX|RAX) = src_l[i_src_l]*src_s[i_src_s]
    add   r12,rax                       ;   t3 = t3 + RAX           | can cause carry
    lea   rsi, [ rsi + LEN_LNUM_ELE ]   ;   i_src_l++
    adc   r11,rdx                       ;   t2 = t2 + RDX + carry   | can cause carry
    adc   r10,0                         ;   t1 = t1 + carry         | no carry
    cmp   rbx, 0                        ;   loop untill we reached src_s[0]
    jne   mult_basic_first_loop_inner
    
    inc   rbp                           ;   i_dest++
    mov   [rdi], r12                    ;   dest[i_dest-1] = t3
    lea   rdi, [ rdi + LEN_LNUM_ELE ]   ;   get next dst pointer
    lea   rbx, [ rbp * LEN_LNUM_ELE ]   ;   load new i_src_s
    sub   rsi, rbx                      ;   restore src_l
    cmp   rbp, rcx                      ;   check for further iterations
    jl    mult_basic_first_loop_outer

mult_basic_middle_loop_setup:
    cmp   rcx, r8                       ;   if both inputs are equal, no middle loop is needed
    je    mult_basic_final_loop_setup
    
    lea   rbx, [ rcx * LEN_LNUM_ELE ]   ;   i_src_s = src_s_len
mult_basic_middle_loop_outer:
;    ---------------------------------------
;   |            REGISTER STATUS            |
;   |  dst  : RDI         i_dest: RBP       |
;   |  src_l: RSI         src_l_len : R8    |
;   |  src_s: R9          src_s_len : RCX   |
;   |  (t1|t2|t3): R10|R11|R12              |
;   |  i_src_s: RBX                         |
;    ---------------------------------------
    mov   r12, r11                      ;   shift the carry from last round
    mov   r11, r10                      ;   shift the carry from last round
    xor   r10, r10                      ;   shift the carry from last round
    lea   rsi, [ rsi + LEN_LNUM_ELE ]   ;   i_src_s++
    
mult_basic_middle_loop_inner:
    mov   rax, [rsi]                    ;   RAX = src_l[i_src_l];
    lea   rbx, [ rbx - LEN_LNUM_ELE ]   ;   i_src_s--
    mul   QWORD PTR[r9 + rbx]            ;   (RDX|RAX) = src_l[i_src_l]*src_s[i_src_s]
    add   r12,rax                       ;   t3 = t3 + RAX           | can cause carry
    lea   rsi, [ rsi + LEN_LNUM_ELE ]   ;   i_src_l++
    adc   r11,rdx                       ;   t2 = t2 + RDX + carry   | can cause carry
    adc   r10,0                         ;   t1 = t1 + carry         | no carry
    cmp   rbx, 0                        ;   loop untill we reached src_s[0]
    jne   mult_basic_middle_loop_inner
    
    mov   [rdi], r12                    ;   dst[i_dst] = t3
    lea   rdi, [ rdi + LEN_LNUM_ELE ]   ;   get next dst pointer
    lea   rbx, [ rcx * LEN_LNUM_ELE ]   ;   load new i_src_s
    sub   rsi, rbx                      ;   restore src_l
    inc   rbp                           ;   i_dst++
    cmp   rbp, r8                       ;   check for further iterations
    jne   mult_basic_middle_loop_outer

mult_basic_final_loop_setup:
    cmp   rcx, 1                        ;   with len 1 input, no final loop is needed
    je mult_basic_last_word
    dec   rcx                           ;   src_s_len--
    lea   rbx, [ rcx * LEN_LNUM_ELE ]   ;   i_src_s = src_s_len
    lea   rsi, [ rsi + LEN_LNUM_ELE ]   ;   get next src_l pointer

mult_basic_final_loop_outer:
;    ---------------------------------------
;   |            REGISTER STATUS            |
;   |  dst  : RDI         i_dest: RBP       |
;   |  src_l: RSI         src_l_len : R8    |
;   |  src_s: R9          src_s_len : RCX   |
;   |  (t1|t2|t3): R10|R11|R12              |
;   |  i_src_s: RBX                         |
;    ---------------------------------------
    mov   r12, r11                      ;   shift the carry from last round
    mov   r11, r10                      ;   shift the carry from last round
    xor   r10, r10                      ;   shift the carry from last round
    lea   r9, [ r9 + LEN_LNUM_ELE ]     ;   get next src_s pointer

mult_basic_final_loop_inner:
    mov   rax, [rsi]                    ;   RAX = src_l[i_src_l];
    lea   rbx, [ rbx - LEN_LNUM_ELE ]   ;   i_src_s--
    mul   QWORD PTR[r9 + rbx]            ;   (RDX|RAX) = src_l[i_src_l]*src_s[i_src_s]
    add   r12,rax                       ;   t3 = t3 + RAX           | can cause carry
    lea   rsi, [ rsi + LEN_LNUM_ELE ]   ;   i_src_l++
    adc   r11,rdx                       ;   t2 = t2 + RDX + carry   | can cause carry
    adc   r10,0                         ;   t1 = t1 + carry         | no carry
    cmp   rbx, 0                        ;   loop untill we reached src_s[0]
    jne   mult_basic_final_loop_inner
    
    mov   [rdi], r12
    lea   rdi, [ rdi + LEN_LNUM_ELE ]   ;   get next dst pointer
    dec   rcx
    jz    mult_basic_last_word
    lea   rbx, [ rcx * LEN_LNUM_ELE ]
    sub   rsi, rbx
    jmp   mult_basic_final_loop_outer

mult_basic_last_word:
    mov   [rdi], r11
    cmp   r11,0
    je    mult_basic_end
    inc   rbp

mult_basic_end:
    mov   rax, rbp
    pop   r15
    pop   r14
    pop   r13
    pop   r12
    pop   rbp
    pop   rbx
%TEXT:POP_RSI;
%TEXT:POP_RDI;
    ret
%FUNCTION_END(m_impl_mult_basic);


;extern "C" void m_impl_square(LNUM_WORD* ap_dest,
;                              const LNUM_WORD* ap_a,
;                              unsigned int szp_a_len);
; This implementation is based on Algorithm 14.16 from the book 'Handbook of Applied Cryptography' by A. Menezes, P. van Oorschot, and S. Vanstone.
; Step 2.1 was extracted to a separate loop, replacing step 1.
%FUNCTION_HEADER(m_impl_square, 0);
    cmp   %TEXT:PARAM_3;,64
    je    m_impl_sqr_8
%IF DEF WIN$VC;
    push  rdi
    push  rsi
    mov   rdi, rcx
    mov   rsi, rdx
    shr   r8, 3                                 ;   Scale length parameters from bytes to (64-bit) words
    mov   rcx, r8                               ;   load length to RCX
%CEND;
%IF DEF UNIX$NASM;
    mov   rcx, rdx
    shr   rcx, 3                                ;   Scale length parameters from bytes to (64-bit) words
    mov   r8, rcx
%CEND;
    push  rbx
    push  r12
    push  r13
;    ---------------------------------------
;   |            REGISTER STATUS            |
;   |  dest : RDI                           |
;   |  src :  RSI         src_len : R8, RCX |
;    ---------------------------------------

    xor   r11, r11

align 16
sqr_first_loop:
    mov   rax, [ rsi + r11 ]                    ;   RAX = src[i]
    mul   rax                                   ;   (RDX|RAX) = w[2i+1]|w[2i] = src[i]*src[i]
    mov   [ rdi + 2*r11 ], rax                  ;   dest[2i] = w[2i]
    mov   [ rdi + 2*r11 + LEN_LNUM_ELE ], rdx   ;   dest[2i+1]= w[2i+1]
    lea   r11, [ r11 + LEN_LNUM_ELE ]           ;   increment offset
    loop  sqr_first_loop                        ;   loop over the entire src

    dec   r8                                    ;   decrement the remaining count by one, before entering the multiplication loop
    jz    sqr_end                               ;   no multiplication loop is required, if src_len was 1

    xor   r13, r13                              ;   reset R13 to be used as carry out
    lea   rdi, [ rdi - LEN_LNUM_ELE ]           ;   RDI = dest-1. this is done to allow incrementing the dest base by two words for each big loop
;    ---------------------------------------
;   |            REGISTER STATUS            |
;   |  dest-1 : RDI       carry_out: R13    |
;   |  src :  RSI         src_len : R8      |
;    ---------------------------------------
align 16
sqr_mul_outer_loop:
    mov   r9, [rsi]                             ;   R9 = src[i]
    lea   rsi, [ rsi + LEN_LNUM_ELE ]           ;   RSI = src+i+1
    lea   rdi, [ rdi + LEN_LNUM_ELE*2 ]         ;   RDI = dest+i+1
    mov   rcx, r8
    xor   r11, r11                              ;   clear offset
    xor   r12, r12                              ;   clear c_low
    xor   r10, r10                              ;   clear c_high
    xor   rbx, rbx                              ;   clear temp
    shl   rcx, 3                                ;   calculate the number of bytes for the inner loop

;    -------------------------------------------
;   |            REGISTER STATUS                |
;   |  dest+2i+1: RDI        carry_out: R13     |
;   |  src+i+1:  RSI         src_len-(i+1): R8  |
;   |  src[i]:   R9          input_bytes: RCX   |
;    -------------------------------------------

; Step 2.2 of the algorithm
; The mov and add operations have been strongly interleaved for improved performance!
align 16
sqr_mul_inner_loop:
    mov   rax, r9                               ;   RAX = src[i]
    mul   QWORD PTR[ rsi + r11 ]                ;   (RDX|RAX) = u|v = src[i]*src[j]
    add   rax, rax                              ;   v = v+v = 2*v           | faster than shift.
    adc   rdx, rdx                              ;   u = u+u+cf = 2*u+cf     | faster than shift.
    adc   rbx, 0                                ;   store carry out from the shift
    add   rax, r12                              ;   v = v+c_low             | carry possible
    adc   rdx, r10                              ;   u = u+c_high+cf         | carry possible
    mov   r12, rdx                              ;   c_low = u               | carry unaffected
    adc   rbx, 0                                ;   store carry out of this loop step
    mov   r10, rbx                              ;   c_high = temp
    add   [ rdi + r11 ], rax                    ;   dest[i+j] = v+w[i+j]    | carry possible
    lea   r11, [ r11 + LEN_LNUM_ELE ]           ;   increment offset. j++   | carry unaffected
    adc   r12, 0                                ;   c_low = c_low+cf        | carry possible
    mov   rbx, 0                                ;   reset temp              | carry unaffected
    adc   r10, 0                                ;   store carry out of this loop step
    cmp   rcx, r11                              ;   check, if the offset reached the number of input bytes
    jne   sqr_mul_inner_loop                    ;   loop over the remaining part of src

;    -------------------------------------------
;   |            REGISTER STATUS                |
;   |  dest+2i+1: RDI        carry_out: R13     |
;   |  src+i+1:  RSI         src_len-(i+1): R8  |
;   |  src[i]:   R9          c_low: R12         |
;   |  c_high:   R10         cur. offset: R11   |
;    -------------------------------------------

    add   r13, r12                              ;   c_low = c_low + carry_out   | add carry out from last outer loop
    adc   r10, 0                                ;   c_high = c_high + cf
    add   [ rdi + r11 ], r13                    ;   dest[i+j+1] = w[i+j+1]+ c_low   | may cause carry
    adc   r10, 0                                ;   c_high = c_high +cf
    mov   r13, r10                              ;   carry_out = c_high
    dec   r8                                    ;   decrement remaining length. this is in effect i++
    jnz   sqr_mul_outer_loop                    ;   repeat until remaining length reaches 0

    add   [ rdi + r11 + LEN_LNUM_ELE ], r13     ;   add last carry out to high dest word. This cannot cause carry

sqr_end:
    pop   r13
    pop   r12
    pop   rbx
%TEXT:POP_RSI;
%TEXT:POP_RDI;
    ret
%FUNCTION_END(m_impl_square);



;extern "C" int m_impl_add_karatsuba(LNUM_WORD* ap_dest,
;                                    const LNUM_WORD* ap_a,
;                                    const LNUM_WORD* ap_b,
;                                    unsigned int szp_len);
%FUNCTION_HEADER(m_impl_add_karatsuba, 4);
;    ---------------------------------------
;   |            REGISTER STATUS            |
;   |  dest: R10         src1: RDX          |
;   |  src2: R8          src_len: RCX       |
;    ---------------------------------------

    shr  rcx, 3                         ;   Scale length parameters from bytes to (64-bit) words
    xor  r11, r11                       ;   Clear R11 for use as address offset for the source and dest pointers

    xor  rax,rax                        ;   Clear RAX. AH will be used to store the flags to keep CF between loop runs, so this will effectively clear the CF.
    sub  rcx, 32                        ;   This checks, if at least 32 words are available and prepares the 32 word loop.
                                        ;   sub is used over cmp for the following reason:
                                        ;       At the end of the unrolled loop, 32 will be subtracted again from RCX.
                                        ;       By subtracting an additional block here, this will underflow, when there is less, than 32 words left, signaling the end of the loop.
    jl   karatsuba_add_unroll_32_end    ;   Jump beyond the loop, if less than 32 words are available for addition

%SET UNROLL_COUNT=32;
%SET IML$LE$02=8;

align 16
karatsuba_add_unroll_loop_%INT:UNROLL_COUNT;:

    sahf                                            ;   Restore carry flag

%SET STEP_NR=0;
%RPTN UNROLL_COUNT;
    mov  rax, [rdx + r11 + %INT:STEP_NR; * LEN_LNUM_ELE]  ;   src_1                       |  mov  :  no flags affected
    adc  rax, [ r8 + r11 + %INT:STEP_NR; * LEN_LNUM_ELE]  ;   src_1 + src_2 + carry       |  adc  :  CF is set regarding the carry value (OK: wished behaviour)
    mov  [r10 + r11 + %INT:STEP_NR; * LEN_LNUM_ELE], rax  ;   dst = src_1 + src_2 + carry |  mov  :  no flags affected
%SET STEP_NR=STEP_NR+1;
%REND;

    lahf                                            ;   save carry flag

    lea  r11, [r11 + %INT:UNROLL_COUNT; * LEN_LNUM_ELE]             ;   increase pointer offset
    sub  rcx, %INT:UNROLL_COUNT;                                    ;   subtract the processed words
    jge  karatsuba_add_unroll_loop_%INT:UNROLL_COUNT;               ;   keep up the loop, until there are not enough words left

karatsuba_add_unroll_32_end:

;    ---------------------------------------------------
;   |            REGISTER STATUS                        |
;   |  dest: R10         src1: RDX                      |
;   |  src2: R8          word for addition - 32 : RCX   |
;   |  temp: RAX         offset: R11                    |
;    ---------------------------------------------------
    add  rcx, (32-8)                                ;   we subtracted one additional 32 word block, so restore that part, minus 8 words
                                                    ;   the same loop construct will be used for the 8 word unroll
    jnc  karatsuba_add_unroll_8_end                 ;   the add didn't cause a carry. This signals, that there are less, than 8 words, so we skip that loop
%SET UNROLL_COUNT=8;

align 16
karatsuba_add_unroll_loop_%INT:UNROLL_COUNT;:

    sahf                                            ;   Restore carry flag

%SET STEP_NR=0;
%RPTN UNROLL_COUNT;
    mov  rax, [rdx + r11 + %INT:STEP_NR; * LEN_LNUM_ELE]  ;   src_1                       |  mov  :  no flags affected
    adc  rax, [ r8 + r11 + %INT:STEP_NR; * LEN_LNUM_ELE]  ;   src_1 + src_2 + carry       |  adc  :  CF is set regarding the carry value (OK: wished behaviour)
    mov  [r10 + r11 + %INT:STEP_NR; * LEN_LNUM_ELE], rax  ;   dst = src_1 + src_2 + carry |  mov  :  no flags affected
%SET STEP_NR=STEP_NR+1;
%REND;

    lahf                                             ;   save carry flag

    lea  r11, [r11 + %INT:UNROLL_COUNT; * LEN_LNUM_ELE]             ;   increase pointer offset
    sub  rcx, %INT:UNROLL_COUNT;                                    ;   subtract the processed words
    jge  karatsuba_add_unroll_loop_%INT:UNROLL_COUNT;               ;   keep up the loop, until there are not enough words left

karatsuba_add_unroll_8_end:
;    ---------------------------------------------------
;   |            REGISTER STATUS                        |
;   |  dest: R10         src1: RDX                      |
;   |  src2: R8          word for addition - 8 : RCX    |
;   |  temp: RAX         offset: R11                    |
;    ---------------------------------------------------
    add  rcx, 8                             ;   Add back the missing 8 words from the count

    sahf                                    ;   load carry flag
    jrcxz karatsuba_add_single_loop_end     ;   If no words for addition are left, jump to carry propagation

karatsuba_add_loop:
    mov   rax, [ rdx + r11 ]                ;   RAX = src1
    adc   rax, [ r8 + r11 ]                 ;   src1 + src2 + carry     | carry set
    mov   [ r10 + r11 ], rax                ;   dest = src1 + src2 + carry
    lea   r11, [ r11 + LEN_LNUM_ELE ]       ;   increment index
    loop karatsuba_add_loop                 ;   loop over the entire length. src1 and src2 are equal length

karatsuba_add_single_loop_end:
    mov   rax, 0                            ;   clear eax, without affecting carry flag
    adc   rax, 0                            ;   add the carry out to eax

    ret
%FUNCTION_END(m_impl_add_karatsuba);

;extern "C" int m_impl_sub_karatsuba(LNUM_WORD* ap_dest,
;                                    const LNUM_WORD* ap_a,
;                                    const LNUM_WORD* ap_b,
;                                    unsigned int szp_len);
%FUNCTION_HEADER(m_impl_sub_karatsuba, 4);
;    ---------------------------------------
;   |            REGISTER STATUS            |
;   |  dest: R10         src1: RDX          |
;   |  src2: R8          src_len: RCX       |
;    ---------------------------------------


    shr  rcx, 3                         ;   Scale length parameters from bytes to (64-bit) words
    xor  r11, r11                       ;   Clear R11 for use as address offset for the source and dest pointers

    xor  rax,rax                        ;   Clear RAX. AH will be used to store the flags to keep CF between loop runs, so this will effectively clear the CF.
    sub  rcx, 32                        ;   This checks, if at least 32 words are available and prepares the 32 word loop.
                                        ;   sub is used over cmp for the following reason:
                                        ;       At the end of the unrolled loop, 32 will be subtracted again from RCX.
                                        ;       By subtracting an additional block here, this will underflow, when there is less, than 32 words left, signaling the end of the loop.
    jl   karatsuba_sub_unroll_32_end    ;   Jump beyond the loop, if less than 32 words are available for addition

%SET UNROLL_COUNT=32;
%SET IML$LE$02=8;

align 16
karatsuba_sub_unroll_loop_%INT:UNROLL_COUNT;:

    sahf                                            ;   Restore carry flag

%SET STEP_NR=0;
%RPTN UNROLL_COUNT;
    mov  rax, [rdx + r11 + %INT:STEP_NR; * LEN_LNUM_ELE]  ;   src_1                        |  mov  :  no flags affected
    sbb  rax, [ r8 + r11 + %INT:STEP_NR; * LEN_LNUM_ELE]  ;   src_1 - src_2 - borrow       |  sbb  :  CF is set regarding the carry value (OK: wished behaviour)
    mov  [r10 + r11 + %INT:STEP_NR; * LEN_LNUM_ELE], rax  ;   dst = src_1 - src_2 - borrow |  mov  :  no flags affected
%SET STEP_NR=STEP_NR+1;
%REND;

    lahf                                            ;   save carry flag

    lea  r11, [r11 + %INT:UNROLL_COUNT; * LEN_LNUM_ELE]             ;   increase pointer offset
    sub  rcx, %INT:UNROLL_COUNT;                                    ;   subtract the processed words
    jge  karatsuba_sub_unroll_loop_%INT:UNROLL_COUNT;               ;   keep up the loop, until there are not enough words left

karatsuba_sub_unroll_32_end:

;    ---------------------------------------------------
;   |            REGISTER STATUS                        |
;   |  dest: R10         src1: RDX                      |
;   |  src2: R8          word for addition - 32 : RCX   |
;   |  temp: RAX         offset: R11                    |
;    ---------------------------------------------------
    add  rcx, (32-8)                                ;   we subtracted one additional 32 word block, so restore that part, minus 8 words
                                                    ;   the same loop construct will be used for the 8 word unroll
    jnc  karatsuba_sub_unroll_8_end                 ;   the add didn't cause a carry. This signals, that there are less, than 8 words, so we skip that loop
%SET UNROLL_COUNT=8;

align 16
karatsuba_sub_unroll_loop_%INT:UNROLL_COUNT;:

    sahf                                            ;   Restore carry flag

%SET STEP_NR=0;
%RPTN UNROLL_COUNT;
    mov  rax, [rdx + r11 + %INT:STEP_NR; * LEN_LNUM_ELE]  ;   src_1                        |  mov  :  no flags affected
    sbb  rax, [ r8 + r11 + %INT:STEP_NR; * LEN_LNUM_ELE]  ;   src_1 - src_2 - borrow       |  sbb  :  CF is set regarding the carry value (OK: wished behaviour)
    mov  [r10 + r11 + %INT:STEP_NR; * LEN_LNUM_ELE], rax  ;   dst = src_1 - src_2 - borrow |  mov  :  no flags affected
%SET STEP_NR=STEP_NR+1;
%REND;

    lahf                                             ;   save carry flag

    lea  r11, [r11 + %INT:UNROLL_COUNT; * LEN_LNUM_ELE]             ;   increase pointer offset
    sub  rcx, %INT:UNROLL_COUNT;                                    ;   subtract the processed words
    jge  karatsuba_sub_unroll_loop_%INT:UNROLL_COUNT;               ;   keep up the loop, until there are not enough words left

karatsuba_sub_unroll_8_end:
;    ---------------------------------------------------
;   |            REGISTER STATUS                        |
;   |  dest: R10         src1: RDX                      |
;   |  src2: R8          word for addition - 8 : RCX    |
;   |  temp: RAX         offset: R11                    |
;    ---------------------------------------------------
    add  rcx, 8                             ;   Add back the missing 8 words from the count

    sahf                                    ;   load carry flag
    jrcxz karatsuba_sub_single_loop_end     ;   If no words for addition are left, jump to carry propagation

karatsuba_sub_loop:
    mov   rax, [ rdx + r11 ]                ;   RAX = src1
    sbb   rax, [ r8 + r11 ]                 ;   src1 - src2 - borrow    | borrow set
    mov   [ r10 + r11 ], rax                ;   dest = src1 - src2 - borrow
    lea   r11, [ r11 + LEN_LNUM_ELE ]       ;   increment index
    loop karatsuba_sub_loop                 ;   loop over the entire length. src1 and src2 are equal length

karatsuba_sub_single_loop_end:
    mov   rax, 0                            ;   clear eax, without affecting carry flag
    adc   rax, 0                            ;   add the borrow out to eax

    ret
%FUNCTION_END(m_impl_sub_karatsuba);

;extern "C" void m_impl_add_word(LNUM_WORD* ap_dest_a,
;                                LNUM_WORD up_b);
%FUNCTION_HEADER(m_impl_add_word, 2);

    add   [%TEXT:PARAM_1;], %TEXT:PARAM_2;                        ;   dest = dest + src   | carry set

    jnc add_word_end                        ;   if no carry was generated, jump to the end

add_word_loop:
    lea   %TEXT:PARAM_1;, [%TEXT:PARAM_1; + LEN_LNUM_ELE]         ;   increment destination pointer directly. This is so simple, no index needed
    adc   QWORD PTR[%TEXT:PARAM_1;], 0                ;   dest = dest + carry | carry set
    jc add_word_loop                        ;   repeat, while we generate carry

add_word_end:

    ret
%FUNCTION_END(m_impl_add_word);

%FUNCTION_HEADER(m_impl_sqr_8, 2);
%TEXT:PUSH_RSI;
    push r12
    mov  rsi, %TEXT:PARAM_2;
    xor  r9, r9                             ;   clear R9 as temporary
    xor  r12, r12                           ;   clear R12 as temporary

;    -----------------------------------
;   |            REGISTER STATUS        |
;   |  dest: %TEXT:PARAM_1;            src: RSI    |
;   |  temporaries: R8-R12              |
;    -----------------------------------

    mov  rax, [ rsi ]                           ;   RAX = src[0]
    mul  rax                                    ;   (RDX|RAX) = u|v = src[0]^2
    mov  [ %TEXT:PARAM_1; ], rax                           ;   dest[0] = v
    mov  r8, rdx                                ;   c_low = u

;    -----------------------------------
;   |            REGISTER STATUS        |
;   |  dest: %TEXT:PARAM_1;            src: RSI    |
;   |  c_low: R8            c_high: R9  |
;    -----------------------------------

%mul_mov(0, 1, r10, r11);
%double_3_words(r10, r11, r12);
%add_2_to_3_words(r10, r11, r12, r8, r9);
    mov  [ %TEXT:PARAM_1; + LEN_LNUM_ELE ], r10            ;   dest[1] = sum_low
    xor  r10, r10                               ;   clear sum_low

;    -----------------------------------
;   |            REGISTER STATUS        |
;   |  dest: %TEXT:PARAM_1;            src: RSI    |
;   |  c_low: R11           c_high: R12 |
;   |  cleared temp: R10                |
;    -----------------------------------

%mul_mov(0, 2, r8, r9);
%double_3_words(r8, r9, r10);
%add_2_to_3_words(r8, r9, r10, r11, r12);
%sqr_add_carry(1, r8, r9, r10);
    mov  [ %TEXT:PARAM_1; + 2*LEN_LNUM_ELE ], r8           ;   dest[2] = sum_low
    xor  r8, r8                                 ;   clear sum_low

;    -----------------------------------
;   |            REGISTER STATUS        |
;   |  dest: %TEXT:PARAM_1;            src: RSI    |
;   |  c_low: R9            c_high: R10 |
;   |  cleared temp: R8                 |
;    -----------------------------------

%mul_mov(0, 3, r11, r12);
%mul_add_carry(1, 2, r11, r12, r8);
%double_3_words(r11, r12, r8);
%add_2_to_3_words(r11, r12, r8, r9, r10);
    mov  [ %TEXT:PARAM_1; + 3*LEN_LNUM_ELE ], r11          ;   dest[3] = sum_low
    xor  r11, r11                               ;   clear sum_low

;    -----------------------------------
;   |            REGISTER STATUS        |
;   |  dest: %TEXT:PARAM_1;            src: RSI    |
;   |  c_low: R12           c_high: R8  |
;   |  cleared temp: R11                |
;    -----------------------------------

%mul_mov(0, 4, r9, r10);
%mul_add_carry(1, 3, r9, r10, r11);
%double_3_words(r9, r10, r11);
%add_2_to_3_words(r9, r10, r11, r12, r8);
%sqr_add_carry(2, r9, r10, r11);
    mov  [ %TEXT:PARAM_1; + 4*LEN_LNUM_ELE ], r9           ;   dest[4] = sum_low
    xor  r9, r9                                 ;   clear sum_low

;    -----------------------------------
;   |            REGISTER STATUS        |
;   |  dest: %TEXT:PARAM_1;            src: RSI    |
;   |  c_low: R10           c_high: R11 |
;   |  cleared temp: R9                 |
;    -----------------------------------

%mul_mov(0, 5, r12, r8);
%mul_add_carry(1, 4, r12, r8, r9);
%mul_add_carry(2, 3, r12, r8, r9);
%double_3_words(r12, r8, r9);
%add_2_to_3_words(r12, r8, r9, r10, r11);
    mov  [ %TEXT:PARAM_1; + 5*LEN_LNUM_ELE ], r12          ;   dest[5] = sum_low
    xor  r12, r12                               ;   clear sum_low

;    -----------------------------------
;   |            REGISTER STATUS        |
;   |  dest: %TEXT:PARAM_1;            src: RSI    |
;   |  c_low: R8            c_high: R9  |
;   |  cleared temp: R12                |
;    -----------------------------------

%mul_mov(0, 6, r10, r11);
%mul_add_carry(1, 5, r10, r11, r12);
%mul_add_carry(2, 4, r10, r11, r12);
%double_3_words(r10, r11, r12);
%add_2_to_3_words(r10, r11, r12, r8, r9);
%sqr_add_carry(3, r10, r11, r12);
    mov  [ %TEXT:PARAM_1; + 6*LEN_LNUM_ELE ], r10          ;   dest[6] = sum_low
    xor  r10, r10                               ;   clear sum_low

;    -----------------------------------
;   |            REGISTER STATUS        |
;   |  dest: %TEXT:PARAM_1;            src: RSI    |
;   |  c_low: R11           c_high: R12 |
;   |  cleared temp: R10                |
;    -----------------------------------

%mul_mov(0, 7, r8, r9);
%mul_add_carry(1, 6, r8, r9, r10);
%mul_add_carry(2, 5, r8, r9, r10);
%mul_add_carry(3, 4, r8, r9, r10);
%double_3_words(r8, r9, r10);
%add_2_to_3_words(r8, r9, r10, r11, r12);
    mov  [ %TEXT:PARAM_1; + 7*LEN_LNUM_ELE ], r8           ;   dest[7] = sum_low
    xor  r8, r8                                 ;   clear sum_low

;    -----------------------------------
;   |            REGISTER STATUS        |
;   |  dest: %TEXT:PARAM_1;            src: RSI    |
;   |  c_low: R9            c_high: R10 |
;   |  cleared temp: R8                 |
;    -----------------------------------

%mul_mov(1, 7, r11, r12);
%mul_add_carry(2, 6, r11, r12, r8);
%mul_add_carry(3, 5, r11, r12, r8);
%double_3_words(r11, r12, r8);
%add_2_to_3_words(r11, r12, r8, r9, r10);
%sqr_add_carry(4, r11, r12, r8);
    mov  [ %TEXT:PARAM_1; + 8*LEN_LNUM_ELE ], r11          ;   dest[8] = sum_low
    xor  r11, r11                               ;   clear sum_low

;    -----------------------------------
;   |            REGISTER STATUS        |
;   |  dest: %TEXT:PARAM_1;            src: RSI    |
;   |  c_low: R12           c_high: R8  |
;   |  cleared temp: R11                |
;    -----------------------------------

%mul_mov(2, 7, r9, r10);
%mul_add_carry(3, 6, r9, r10, r11);
%mul_add_carry(4, 5, r9, r10, r11);
%double_3_words(r9, r10, r11);
%add_2_to_3_words(r9, r10, r11, r12, r8);
    mov  [ %TEXT:PARAM_1; + 9*LEN_LNUM_ELE ], r9           ;   dest[9] = sum_low
    xor  r9, r9                                 ;   clear sum_low

;    -----------------------------------
;   |            REGISTER STATUS        |
;   |  dest: %TEXT:PARAM_1;            src: RSI    |
;   |  c_low: R10           c_high: R11 |
;   |  cleared temp: R9                 |
;    -----------------------------------

%mul_mov(3, 7, r12, r8);
%mul_add_carry(4, 6, r12, r8, r9);
%double_3_words(r12, r8, r9);
%add_2_to_3_words(r12, r8, r9, r10, r11);
%sqr_add_carry(5, r12, r8, r9);
    mov  [ %TEXT:PARAM_1; + 10*LEN_LNUM_ELE ], r12         ;   dest[10] = sum_low
    xor  r12, r12                               ;   clear sum_low

;    -----------------------------------
;   |            REGISTER STATUS        |
;   |  dest: %TEXT:PARAM_1;            src: RSI    |
;   |  c_low: R8            c_high: R9  |
;   |  cleared temp: R12                |
;    -----------------------------------

%mul_mov(4, 7, r10, r11);
%mul_add_carry(5, 6, r10, r11, r12);
%double_3_words(r10, r11, r12);
%add_2_to_3_words(r10, r11, r12, r8, r9);
    mov  [ %TEXT:PARAM_1; + 11*LEN_LNUM_ELE ], r10         ;   dest[11] = sum_low
    xor  r10, r10                               ;   clear sum_low

;    -----------------------------------
;   |            REGISTER STATUS        |
;   |  dest: %TEXT:PARAM_1;            src: RSI    |
;   |  c_low: R11           c_high: R12 |
;   |  cleared temp: R10                |
;    -----------------------------------

%mul_mov(5, 7, r8, r9);
%double_3_words(r8, r9, r10);
%add_2_to_3_words(r8, r9, r10, r11, r12);
%sqr_add_carry(6, r8, r9, r10);
    mov  [ %TEXT:PARAM_1; + 12*LEN_LNUM_ELE ], r8          ;   dest[12] = sum_low
    xor  r8, r8                                 ;   clear sum_low

;    -----------------------------------
;   |            REGISTER STATUS        |
;   |  dest: %TEXT:PARAM_1;            src: RSI    |
;   |  c_low: R9            c_high: R10 |
;   |  cleared temp: R8                 |
;    -----------------------------------

%mul_mov(6, 7, r11, r12);
%double_3_words(r11, r12, r8);
%add_2_to_3_words(r11, r12, r8, r9, r10);
    mov  [ %TEXT:PARAM_1; + 13*LEN_LNUM_ELE ], r11         ;   dest[13] = sum_low
    xor  r11, r11                               ;   clear sum_low

;    -----------------------------------
;   |            REGISTER STATUS        |
;   |  dest: %TEXT:PARAM_1;            src: RSI    |
;   |  c_low: R12           c_high: R8  |
;   |  cleared temp: R11                |
;    -----------------------------------

    mov  rax, [ rsi + 7*LEN_LNUM_ELE ]
    mul  rax
    add  r12, rax
    adc  r8, rdx
    mov  [ %TEXT:PARAM_1; + 14*LEN_LNUM_ELE ], r12          ;   dest[14] = sum_low
    mov  [ %TEXT:PARAM_1; + 15*LEN_LNUM_ELE ], r8           ;   dest[15] = sum_mid

    pop  r12
%TEXT:POP_RSI;
    ret
%FUNCTION_END(m_impl_sqr_8);

;extern "C"
;void m_impl_mont_mul_add(LNUM_WORD* aurp_prod,
;                         LNUM_WORD urp_n_0_inv,
;                         const LNUM_WORD* aurp_mod,
;                         size_t szp_mod_len,
;                         const LNUM_WORD* aurp_src);
%FUNCTION_HEADER(m_impl_mont_mul_add, 0);
%IF DEF UNIX$NASM;
;    ---------------------------------------
;   |            REGISTER STATUS            |
;   |  dest: RDI         m_0_inv: RSI       |
;   |  mod:  RDX         mod_len: RCX       |
;   |  P:    R8                             |
;    ---------------------------------------
    mov  r10, rdi                       ;   Move destination pointer to R10 for consistency with Windows
    mov  r9, rcx                        ;   Move mod_len to R9 for consistency with Windows
    mov  rcx, rdx                       ;   Move mod to RCX
    xchg rcx, r8                        ;   swap R8 and RCX for consistency with Windows
    mov  rdx, rsi                       ;   Move m_0_inv to RDX for consistency with Windows
%CEND;
%IF DEF WIN$VC;
;    ---------------------------------------
;   |            REGISTER STATUS            |
;   |  dest: RCX         m_0_inv: RDX       |
;   |  mod:  R8          mod_len: R9        |
;   |  P:    stack                          |
;    ---------------------------------------
    mov  r10, rcx                       ;   destination to R10, freeing RCX
    mov  rcx, [rsp+028H]                ;   RCX = P (accesing position of the 5th parameter).
                                        ;       0x28 bytes = 0x20 shadow space + 8 return address
%CEND;
    test  r9, 63
    jz    ms_impl_mont_mul_add_8
    cmp   r9, 8
    je    ms_impl_mont_mul_add_1
%TEXT:PUSH_RSI;
%TEXT:PUSH_RDI;
    push  rbx
    push  r12
    push  r13
    push  r14
    push  r15
;    ---------------------------------------
;   |            REGISTER STATUS            |
;   |  dest: R10         m_0_inv: RDX       |
;   |  mod:  R8          mod_len: R9        |
;   |  P:    RCX                            |
;    ---------------------------------------

    lea  r10, [r10 + r9]                        ;   move dest to the second half of the buffer for consistency

;   the case i=0 is handled here
    mov  rax, [rcx]                             ;   RAX = P[0]
    xor  r12, r12                               ;   t = 0
    mov  r14, rax                               ;   v = P[0]
    mov  r15, [R8]                              ;   R15 = m[0]
    xor  r13, r13                               ;   u = 0
    mov  rsi, rdx                               ;   RSI = m_0_inv       |   free RDX for MUL
    mul  rsi                                    ;   (RDX|RAX) = v*m_0_inv
    mov  [r10], rax                             ;   dest[0] = v*m_0_inv mod 2^w
    mul  r15                                    ;   (RDX|RAX) = dest[0]*m[0]

    mov  rdi, LEN_LNUM_ELE                      ;   Load first loop index
    add  rax, r14                               ;   v = v+RAX                   |   can generate carry
    adc  rdx, 0                                 ;   u = u(is 0)+ RDX + carry    |   can generate carry
    adc  r13, 0                                 ;   combine t = t+carry; u=t    |   no carry
    mov  r14, rdx                               ;   v = RAX

mont_mul_add_growing_loop_outer:
;    ---------------------------------------
;   |            REGISTER STATUS            |
;   |  dest: R10         m_0_inv:      RSI  |
;   |  m_i:  R8          mod_word_len: R9   |
;   |  P:    RCX         m_0:          R15  |
;   |  cur_i_off: RDI                       |
;   |  (t,u,v): R12,R13,R14                 |
;    ---------------------------------------
    xor  r11, r11                               ;   Reset inner index j
    lea  r8, [ r8 + rdi]                        ;   m_cur = m_(i) for inner loop
mont_mul_add_growing_loop_inner:
    mov  rax, [r8]                              ;   RAX = m[i-j]
    mul  QWORD PTR[ r10 + r11 ]              ;   (RDX|RAX) = m[i-j]*dest[j]
    add  r14, rax                               ;   v = v + RAX         |   carry possible
    adc  r13, rdx                               ;   u = u + RDX + carry |   carry possible
    adc  r12, 0                                 ;   t = t + carry       |   no carry
    lea  r8, [ r8 - LEN_LNUM_ELE ]              ;   m[i-j] = m[i-(j+1)]
    lea  r11, [ r11 + LEN_LNUM_ELE ]            ;   j++
    cmp  r11, rdi                               ;   check i > j
    jl   mont_mul_add_growing_loop_inner        ;   loop while i > j

    add  r14, [rcx + rdi]                       ;   v = v + P[i]    |   carry possible
    adc  r13, 0                                 ;   u = u + carry   |   carry possible
    adc  r12, 0                                 ;   t = t + carry   |   no carry
    mov  rax, r14                               ;   RAX = v
    mul  rsi                                    ;   (RDX|RAX) = v*m_0_inv
    mov  [ r10 + r11 ], rax                     ;   dest[i] = v*m_0_inv mod 2^w
    mul  r15                                    ;   (RDX|RAX) = dest[i]*m[0]
    add  r14, rax                               ;   v = v + RAX         |   carry possible
    adc  r13, rdx                               ;   u = u + RDX + carry |   carry possible
    adc  r12, 0                                 ;   t = t + carry       |   no carry
    mov  r14, r13                               ;   v = u
    mov  r13, r12                               ;   u = t
    xor  r12, r12                               ;   t = 0
    lea  rdi, [ rdi + LEN_LNUM_ELE ]            ;   i++
    cmp  rdi, r9                                ;   check i < mod_len
    jl   mont_mul_add_growing_loop_outer        ;   loop while i < mod_len

    lea  rcx, [rcx+r9]                          ;   P = P + s
    xor  rdi, rdi                               ;   i = 0
    sub  r9, LEN_LNUM_ELE                       ;   calculate s-1 offset

mont_mul_add_shrinking_loop_outer:
;    ---------------------------------------
;   |            REGISTER STATUS            |
;   |  dest: R10         m_0_inv:      RSI  |
;   |  mod:  R8          s-1 offset:   R9   |
;   |  P[s]: RCX         m_0:          R15  |
;   |  cur_i_off: RDI                       |
;   |  (t,u,v): R12,R13,R14                 |
;    ---------------------------------------
    lea  r11,[rdi + LEN_LNUM_ELE ]              ;   Reset inner index j to i+1
    lea  rbx, [ r8 + r9 ]                       ;   m_cur = m_(s-1) for inner loop
mont_mul_add_shrinking_loop_inner:
    mov  rax, [ rbx ]                           ;   RAX = m[i-j]
    mul  QWORD PTR[ r10 + r11 ]              ;   (RDX|RAX) = m[i-j]*dest[j]
    add  r14, rax                               ;   v = v + RAX         |   carry possible
    adc  r13, rdx                               ;   u = u + RDX + carry |   carry possible
    adc  r12, 0                                 ;   t = t + carry       |   no carry
    lea  rbx, [ rbx - LEN_LNUM_ELE ]            ;   m[i-j] = m[i-(j+1)]
    lea  r11, [ r11 + LEN_LNUM_ELE ]            ;   j++
    cmp  r11, r9                                ;   check j < (s-1)
    jle  mont_mul_add_shrinking_loop_inner      ;   loop while j < (s-1)

    add  r14, [rcx + rdi]                       ;   v = v + P[s+i]  |   carry possible
    adc  r13, 0                                 ;   u = u + carry   |   carry possible
    adc  r12, 0                                 ;   t = t + carry   |   no carry
    mov  [ r10 + rdi ], r14                     ;   dest[i] = v
    mov  r14, r13                               ;   v = u
    mov  r13, r12                               ;   u = t
    xor  r12, r12                               ;   t = 0
    lea  rdi, [ rdi + LEN_LNUM_ELE ]            ;   i++
    cmp  rdi, r9
    jl   mont_mul_add_shrinking_loop_outer

mont_mul_add_end:
    add  r14, [rcx + rdi]
    adc  r13, 0
    mov  [ r10 + r9 ], r14
    mov  [ r10 + r9 + LEN_LNUM_ELE ], r13

    pop  r15
    pop  r14
    pop  r13
    pop  r12
    pop  rbx
%TEXT:POP_RDI;
%TEXT:POP_RSI;
    ret
%FUNCTION_END(m_impl_mont_mul_add);


;extern "C" void m_impl_first_bit(LNUM_WORD url_word)
%FUNCTION_HEADER(m_impl_first_bit , 2);
    mov   r8, %TEXT:PARAM_1;
    bsf   rax, r8
    ret
%FUNCTION_END(m_impl_first_bit);


;extern "C" void m_impl_last_bit(LNUM_WORD url_word)
%FUNCTION_HEADER(m_impl_last_bit, 2);
    mov   r8, %TEXT:PARAM_1;
    bsr   rax, r8
    ret
%FUNCTION_END(m_impl_last_bit);
    


    

%MACRO:ADD_P_TO_T(mquote:comment);
    movq_r rax, xmm1                            ;   Load src ptr
    movq_r rsi, xmm4                            ;   Load u
    add  r8, [rax]                              ;   v_0 += p_i              |   carry possible
%SET UNROLL_COUNT=MONT_UNROLL-1;
%SET STEP_NR=1;
%RPTN UNROLL_COUNT;
    adc  r%INT:STEP_NR+8;, [rax+%INT:STEP_NR; * LEN_LNUM_ELE]            ;   v_%INT:STEP_NR; += p_(i+%INT:STEP_NR;) + carry  |   carry possible
%SET STEP_NR=STEP_NR+1;
%REND;

    adc  rsi, 0                                 ;   u += carry
    movq_r xmm4, rsi                            ;   store u
%MEND;

%MACRO:MONT_HSPS_INNER(mtext:label);
%TEXT:label;:
    lea  rdi, [rdi - %INT:MONT_UNROLL;*LEN_LNUM_ELE]            ;   Get address for next z_(j+l)
    lea  rbp, [rbp + %INT:MONT_UNROLL;*LEN_LNUM_ELE]            ;   Get address for next M_(i-j)
    mov  rbx, [rdi]                             ;   Load z_(j+l)
    mov  rax, [rbp]                             ;   Load m_(i-j)

%SET UNROLL_COUNT=MONT_UNROLL-1;
%SET STEP_NR=0;
%RPTN UNROLL_COUNT;
    mul  rbx                                    ;   (RDX|RAX) = z_k*m_(i+%INT:STEP_NR;-j)
    add  r%INT:STEP_NR+8;, rax                                ;   v_%INT:STEP_NR; += RAX      |   carry possible
    mov  rax, [rbp + %INT:STEP_NR+1;*LEN_LNUM_ELE]            ;   Load m_(i+%INT:STEP_NR+1;-j)
    adc  rdx, 0                                 ;   RDX += carry    |   no carry possible
%IF GT STEP_NR;
    add  r%INT:STEP_NR+8;, rsi                                ;   v_%INT:STEP_NR; += tmp      |   carry possible
    adc  rdx, 0                                 ;   RDX += carry    |   no carry possible
%CEND;
    mov  rsi, rdx                               ;   tmp = RDX

%SET STEP_NR=STEP_NR+1;
%REND;
    mul  rbx                                    ;   (RDX|RAX) = z_k*m_(i+1-j)
    add  rax, rsi                               ;   RAX += tmp      |   carry possible
    movq_r rsi, xmm4                            ;   load u
    adc  rdx,0                                  ;   RDX += carry    |   no carry possible
    add  r%INT:MONT_UNROLL+7;, rax                                ;   v_%INT:MONT_UNROLL-1; += RAX      |   carry possible
    movq_r rax, xmm5                            ;   load t
    adc  rsi, rdx                               ;   u += RDX+carry  |   carry possible
    movq_r xmm4, rsi                            ;   store u
    adc  rax, 0                                 ;   t += carry      |   no carry possible
    movq_r xmm5, rax                            ;   store t

    sub  rcx, %INT:MONT_UNROLL;*LEN_LNUM_ELE                    ;   Decrement loop count
    jg   %TEXT:label;
%MEND;

%SET MONT_UNROLL=8;
MONT_8_STACK_CNT       equ  3
MONT_8_DEST_MID_INDEX  equ  LEN_LNUM_ELE
;void ms_impl_mont_mul_add_8(LNUM_WORD* aurp_prod,
;                            LNUM_WORD urp_n_0_inv,
;                            const LNUM_WORD* aurp_mod,
;                            size_t szp_mod_len,
;                            const LNUM_WORD* aurp_src);
%FUNCTION_HEADER(ms_impl_mont_mul_add_8, 0);
%TEXT:PUSH_RSI;
%TEXT:PUSH_RDI;
    push rbp
    push rbx
    push r12
    push r13
    push r14
    push r15
    sub  rsp, LEN_LNUM_ELE*MONT_8_STACK_CNT
;    ---------------------------------------
;   |            REGISTER STATUS            |
;   |  dest: R10         m_0_inv: RDX       |
;   |  mod:  R8          mod_len: R9        |
;   |  P:    RCX                            |
;    ---------------------------------------
    shr  r9, 3                        ;   Scale length parameters from bytes to (64-bit) words    
    mov  rdi, r10
    mov  rbp, r8
    mov  rsi, r9
    movq_r xmm0, rdx                                ;   Store m_0_inv
    lea  r10, [r10+r9*LEN_LNUM_ELE]                 ;   Calcualte z_s
    mov  [rsp+MONT_8_DEST_MID_INDEX], r10           ;   Store z_s

;    ---------------------------------------
;   |            REGISTER STATUS            |
;   |  z_cur:RDI         m_0_inv: XMM0      |
;   |  mod:  RBP         mod_len: RSI       |
;   |  P:    RCX         z_s: [RSP+MONT_8_DEST_MID_INDEX]    |
;    ---------------------------------------
    ;   Instead of setting V = 0 and add P_0, we just load P_0
%SET UNROLL_COUNT=MONT_UNROLL;
%SET STEP_NR=0;
%RPTN UNROLL_COUNT;
    mov  r%INT:STEP_NR+8;, [rcx + %INT:STEP_NR; * LEN_LNUM_ELE]               ;   v_%INT:STEP_NR; = p_%INT:STEP_NR;
%SET STEP_NR=STEP_NR+1;
%REND;
    lea  rax, [rcx + %INT:UNROLL_COUNT; * LEN_LNUM_ELE ]             ;   Get pointer to next source block
    movq_r xmm1, rax                                ;   Store current src ptr
    mov  rcx, %INT:MONT_UNROLL;                                     ;   Set counter for init loop

mont_mul_add_8_init_loop:
;    ---------------------------------------
;   |            REGISTER STATUS            |
;   |  dest: RDI         m_0_inv: XMM0      |
;   |  mod:  RBP         mod_len: RSI       |
;   |  P:    XMM1        dest_end: [RSP]    |
;    ---------------------------------------
    movq_r rbx, xmm0                                ;   Load m_0_inv
    imul rbx, r8                                    ;   z_(i+l) = v_0*m_0_inv mod 2^64
    mov  rax, [rbp]                                 ;   Load m_0
    mov  [rdi], rbx                                 ;   write z_(i+l)
    lea  rdi, [rdi + LEN_LNUM_ELE]                  ;   l++
    mul  rbx                                        ;   (RDX|RAX)=z_(i+l)*m_0
    neg  r8                                         ;   carry(RAX+v_0)  |   RAX+v_0 = v_0*m_0_inv*m_0 + v_0 = v_0*0xFFFFFFFFFFFFFFFF+v_0, so if v_0 != 0, then carry is set
    mov  rax, [rbp + LEN_LNUM_ELE]                  ;   Load m_1, RAX will be discarded anyway
    adc  rdx, 0                                     ;   RDX += carry
    mov  r8, rdx                                    ;   v_0 = RDX

%SET UNROLL_COUNT=MONT_UNROLL-1;
%SET LAST_STEP=MONT_UNROLL-2;
%SET STEP_NR=0;
%RPTN UNROLL_COUNT;
    mul  rbx                                        ;   (RDX|RAX) = m_%INT:STEP_NR+1;*z_(i+l)
    add  r%INT:STEP_NR+8;, rax                                   ;   v_%INT:STEP_NR; = v_%INT:STEP_NR;+RAX
%IF LT STEP_NR-LAST_STEP;
    mov  rax, [rbp + %INT:STEP_NR+2;*LEN_LNUM_ELE]                ;   Load m_%INT:STEP_NR+2;
%CEND;
    adc  rdx, 0                                     ;   propagate carry
    add  r%INT:STEP_NR+8;, r%INT:STEP_NR+9;                                    ;   v_%INT:STEP_NR; = v_%INT:STEP_NR;+v_%INT:STEP_NR+1;
    adc  rdx, 0                                     ;   propagate carry
    mov  r%INT:STEP_NR+9;, rdx                                   ;   v_%INT:STEP_NR+1; = RDX

%SET STEP_NR=STEP_NR+1;
%REND;

    dec  rcx                                        ;   decrement counter
    mov  r%INT:MONT_UNROLL+7;, rdx                                    ;   v_%INT:MONT_UNROLL-1; = RDX
    jnz  mont_mul_add_8_init_loop
    
    pxor   xmm4, xmm4                               ;   u = 0
    pxor   xmm5, xmm5                               ;   t = 0

    cmp  rsi, %INT:MONT_UNROLL;                                     ;   Check, if mod_len = b
    je   mont_mul_add_8_final                       ;   if so, skip the loops

    lea  rsi, [rdi + %INT:MONT_UNROLL;*LEN_LNUM_ELE]                ;   Load end of the next block
    mov  [rsp], rsi                                 ;   Store end of next block
    mov  rcx, %INT:MONT_UNROLL;*LEN_LNUM_ELE                        ;   Prepare inner loop counter
    movq_r xmm2, rcx                                ;   Store loop counter
mont_mul_add_8_growing_outer:
;    ---------------------------------------
;   |            REGISTER STATUS            |
;   |  dest: RDI         m_0_inv:  XMM0     |
;   |  mod:  RBP         loop_cnt: XMM2     |
;   |  P:    XMM1        z_s:  [RSP+LEN_LNUM_ELE]   |
;   |  (t|u): XMM5|4     block_end: [RSP]   |
;   |  temp: RSI         V = R8-R%INT:MONT_UNROLL+7;          |
;    ---------------------------------------
    %ADD_P_TO_T('');
    lea  rax, [rax + %INT:MONT_UNROLL;*LEN_LNUM_ELE]            ;   Next P_i
    movq_r xmm1, rax                            ;   Store P_i

    %MONT_HSPS_INNER(mont_mul_add_8_growing_inner);
    
    movq_r rcx, xmm2                            ;   Restore loop counter
    sub  rbp, rcx                               ;   Restore mod ptr
    lea  rdi, [rdi + rcx]                       ;   Restore dest ptr

    movq_r rbx, xmm0                            ;   Load m_0_inv
    imul rbx, r8                                ;   z_(i+l) = v_0*m_0_inv mod 2^64
    mov  rax, [rbp]                             ;   Load m_0
    mov  [rdi], rbx                             ;   write z_(i+l)
    lea  rdi, [rdi + LEN_LNUM_ELE]              ;   l++
    mul  rbx                                    ;   (RDX|RAX)=z_i*m_0
    neg  r8                                     ;   carry(RAX+v_0)   |   RAX+v_0 = v_0*m_0_inv*m_0 + v_0 = v_0*0xFFFFFFFFFFFFFFFF+v_0
    mov  rax, [rbp + LEN_LNUM_ELE]              ;   Load m_1, RAX will be discarded anyway
    adc  rdx, 0                                 ;   RDX += carry
    mov  r8, rdx                                ;   v_0 = RDX

%SET UNROLL_COUNT=MONT_UNROLL-2;
%SET LAST_STEP=MONT_UNROLL-2;
%SET STEP_NR=0;
%RPTN UNROLL_COUNT;
    mul  rbx                                    ;   (RDX|RAX) = m_%INT:STEP_NR+1;*z_(i+l)
    add  r%INT:STEP_NR+8;, rax                               ;   v_%INT:STEP_NR; = v_%INT:STEP_NR;+RAX       |   carry possible
    mov  rax, [rbp + %INT:STEP_NR+2;*LEN_LNUM_ELE]            ;   Load m_%INT:STEP_NR+2;
    adc  rdx, 0                                 ;   propagate carry     |   no carry possible
    add  r%INT:STEP_NR+8;, r%INT:STEP_NR+9;                               ;   v_%INT:STEP_NR; = v_%INT:STEP_NR;+v_%INT:STEP_NR+1;       |   carry possible
    adc  rdx, 0                                 ;   propagate carry     |   no carry possible
    mov  r%INT:STEP_NR+9;, rdx                               ;   v_%INT:STEP_NR+1; = RDX

%SET STEP_NR=STEP_NR+1;
%REND;

    mul  rbx                                    ;   (RDX|RAX) = m_%INT:MONT_UNROLL-1;*z_(i+l)
    add  r%INT:MONT_UNROLL+6;, rax                               ;   v_%INT:MONT_UNROLL-2; = v_0+RAX     |   carry possible
    adc  rdx, 0                                 ;   propagate carry     |   no carry possible
    add  r%INT:MONT_UNROLL+6;, r%INT:MONT_UNROLL+7;                               ;   v_%INT:MONT_UNROLL-2; = v_%INT:MONT_UNROLL-2;+v_%INT:MONT_UNROLL-1;       |   carry possible
    movq_r r%INT:MONT_UNROLL+7;, xmm4                             ;   v_%INT:MONT_UNROLL-1; = u
    adc  r%INT:MONT_UNROLL+7;, rdx                               ;   v_%INT:MONT_UNROLL-1; += RDX + carry  |   carry possible
    movq_r rsi, xmm5                            ;   load t
    adc  rsi, 0                                 ;   t += carry          |   no carry possible
    movq_r xmm4, rsi                            ;   store u = t
    pxor xmm5, xmm5                             ;   t = 0
    
    cmp  rdi, [rsp]                             ;   check if the end of the inner loop is reached
    jne  mont_mul_add_8_growing_inner
    
    lea  rsi, [rdi + %INT:MONT_UNROLL;*LEN_LNUM_ELE]            ;   Load end of the next block
    mov  [rsp], rsi                             ;   Store end of next block
    cmp  rdi, [rsp+MONT_8_DEST_MID_INDEX]       ;   Check if the end of the outer loop is reached  
    je   mont_mul_add_8_shrinking_start         ;   Jump to second loop, if so

    add  rcx, %INT:MONT_UNROLL;*LEN_LNUM_ELE                    ;   Increment loop count for inner loop
    movq_r xmm2, rcx                            ;   Store loop counter
    jmp  mont_mul_add_8_growing_outer

mont_mul_add_8_shrinking_start:
    movq_r xmm3, rdi                            ;   Store dest ptr

mont_mul_add_8_shrinking_outer:
;    ---------------------------------------
;   |            REGISTER STATUS            |
;   |  dest: XMM3        m_0_inv:  XMM0     |
;   |  mod:  RBP         loop_cnt: XMM2     |
;   |  P:    XMM1        z_s:  [RSP+LEN_LNUM_ELE]   |
;   |  (t|u): XMM5|4     block_end: [RSP]   |
;   |  temp: RSI         V = R8-R9          |
;   |  z_(s+l): RDI                         |
;    ---------------------------------------
    mov  rdi, [rsp+MONT_8_DEST_MID_INDEX]       ;   Load z_s
    %ADD_P_TO_T('');
    lea  rax, [rax + %INT:MONT_UNROLL;*LEN_LNUM_ELE]            ;   Next P_i
    movq_r xmm1, rax                            ;   Store P_i
    
    %MONT_HSPS_INNER(mont_mul_add_8_shrinking_inner);
    
    movq_r rcx, xmm2                            ;   Restore loop counter
    sub  rbp, rcx                               ;   Restore mod ptr
    lea  rdi, [rdi + rcx + LEN_LNUM_ELE]        ;   Restore Z pointer and increment for next iteration

    movq_r rsi, xmm3                            ;   Load dest ptr
    mov  [rsi], r8                              ;   z_(s+i+l) = v_0
    lea  rsi, [rsi + LEN_LNUM_ELE]              ;   Increment dest ptr
    
    movq_r xmm3, rsi                            ;   Store dest ptr
%SET UNROLL_COUNT=MONT_UNROLL-1;
%SET STEP_NR=0;
%RPTN UNROLL_COUNT;
    mov  r%INT:STEP_NR+8;, r%INT:STEP_NR+9;                                 ;   v_%INT:STEP_NR; = v_%INT:STEP_NR+1;
%SET STEP_NR=STEP_NR+1;
%REND;
    movq_r r%INT:MONT_UNROLL+7;, xmm4                             ;   v_%INT:MONT_UNROLL-1; = u
    movdqa  xmm4, xmm5                          ;   u = t
    pxor xmm5, xmm5                             ;   t = 0
    
    cmp  rdi, [rsp]                             ;   check if the end of the inner loop is reached
    jne  mont_mul_add_8_shrinking_inner
    
    sub  rcx, %INT:MONT_UNROLL;*LEN_LNUM_ELE                    ;   Decrement inner loop counter
    jle  mont_mul_add_8_pre_final               ;   If no inner loops left, jump to final addition
    movq_r xmm2, rcx                            ;   Store loop counter
    lea  rbp, [rbp + %INT:MONT_UNROLL;*LEN_LNUM_ELE]            ;    Move mod ptr by b
    jmp mont_mul_add_8_shrinking_outer

mont_mul_add_8_pre_final:
    movq_r rdi, xmm3                            ;   Load dest ptr
mont_mul_add_8_final:
    %ADD_P_TO_T('');

%SET UNROLL_COUNT=MONT_UNROLL;
%SET STEP_NR=0;
%RPTN UNROLL_COUNT;
    mov  [rdi+%INT:STEP_NR;*LEN_LNUM_ELE], r%INT:STEP_NR+8;               ;   z_(s-%INT:MONT_UNROLL-STEP_NR;) = v_%INT:STEP_NR;
%SET STEP_NR=STEP_NR+1;
%REND;
    mov  [rdi+%INT:MONT_UNROLL;*LEN_LNUM_ELE], rsi              ;   z_s = u

    add  rsp, LEN_LNUM_ELE*MONT_8_STACK_CNT
    pop  r15
    pop  r14
    pop  r13
    pop  r12
    pop  rbx
    pop  rbp
%TEXT:POP_RDI;
%TEXT:POP_RSI;
    ret
%FUNCTION_END(ms_impl_mont_mul_add_8);

;void ms_impl_mont_mul_add_8(LNUM_WORD* aurp_prod,
;                            LNUM_WORD urp_n_0_inv,
;                            const LNUM_WORD* aurp_mod,
;                            size_t szp_mod_len,
;                            const LNUM_WORD* aurp_src);
%FUNCTION_HEADER(ms_impl_mont_mul_add_1, 0);
;    ---------------------------------------
;   |            REGISTER STATUS            |
;   |  dest: R10         m_0_inv: RDX       |
;   |  mod:  R8          mod_len: R9        |
;   |  P:    RCX                            |
;    ---------------------------------------
    mov rax, [rcx]                              ;   RAX = p[0]
    mul rdx                                     ;   q = p[0]*m_inv mod 2^64
    mul QWORD PTR[r8]                           ;   (u,v) = m[0]*q
    add rax, [rcx]                              ;   v += p[0]           |   carry possible
    adc rdx, [rcx + LEN_LNUM_ELE]               ;   u += p[1] + carry   |   no carry possible
    mov [r10 + LEN_LNUM_ELE], rdx               ;   Write u
    mov QWORD PTR[r10 + 2*LEN_LNUM_ELE], 0      ;   0 the carry out word

    ret
%FUNCTION_END(ms_impl_mont_mul_add_1);
    
;int m_x86_capabilities();
%FUNCTION_HEADER(m_x86_capabilities, 0);
    push rbx
    mov rax, 1
    cpuid
    xor r8, r8
    bt  ecx, 25                             ; AES Instruction expansion
    jnc capabilities_pmul
    or  r8, 1                              ; HL_HARDWARE_SUPPORT_FLAG_AES  1 
capabilities_pmul:
    bt  ecx, 1                              ; PCLMULQDQ
    jnc capabilities_sha
    bt  ecx, 9                              ; Supplemental SSE3
    jnc capabilities_sha
    or  r8, 2                              ; HL_HARDWARE_SUPPORT_FLAG_PMUL  2
capabilities_sha:
    xor eax, eax                            ; Verify if cpuid can report as high as eax=7
    cpuid
    cmp eax, 7                              
    jl capabilities_end
    mov eax, 7                              ; SHA feature flag is reported for eax=7, ecx=0
    xor ecx, ecx
    cpuid
    bt  ebx, 29                             ; SHA
    jnc capabilities_end
    or  r8, 48                              ; HL_HARDWARE_SUPPORT_FLAG_SHA1  16 | HL_HARDWARE_SUPPORT_FLAG_SHA256  32
capabilities_end:
    mov rax, r8
    pop rbx
    ret
%FUNCTION_END(m_x86_capabilities); 

%FUNCTION_HEADER(ms_prepare_roundkey_128, 0);
	pshufd		xmm2,xmm2,255
	movdqa		xmm3,xmm1
	pslldq		xmm3,4
	pxor		xmm1,xmm3
	pslldq		xmm3,4
	pxor		xmm1,xmm3
	pslldq		xmm3,4
	pxor		xmm1,xmm3
	pxor		xmm1,xmm2
	ret
%FUNCTION_END(ms_prepare_roundkey_128);

%FUNCTION_HEADER(ms_prepare_roundkey_192, 0);
	pshufd		xmm2,xmm2,55h
	movdqu		xmm4,xmm1
	pslldq		xmm4,4
	pxor		xmm1,xmm4
	pslldq		xmm4,4
	pxor		xmm1,xmm4
	pslldq		xmm4,4
	pxor		xmm1,xmm4
	pxor		xmm1,xmm2
	pshufd		xmm2,xmm1,0FFh
	movdqu		xmm4,xmm3
	pslldq		xmm4,4
	pxor		xmm3,xmm4
	pxor		xmm3,xmm2
	ret
%FUNCTION_END(ms_prepare_roundkey_192);

%FUNCTION_HEADER(ms_make_rk256_a, 0);
	pshufd		xmm2,xmm2,0FFh
	movdqa		xmm4,xmm1
	pslldq		xmm4,4
	pxor		xmm1,xmm4
	pslldq		xmm4,4
	pxor		xmm1,xmm4
	pslldq		xmm4,4
	pxor		xmm1,xmm4
	pxor		xmm1,xmm2
	ret
%FUNCTION_END(ms_make_rk256_a);
    
%FUNCTION_HEADER(ms_make_rk256_b, 0);
	pshufd		xmm2,xmm2,0AAh
	movdqa		xmm4,xmm3
	pslldq		xmm4,4
	pxor		xmm3,xmm4
	pslldq		xmm4,4
	pxor		xmm3,xmm4
	pslldq		xmm4,4
	pxor		xmm3,xmm4
	pxor		xmm3,xmm2
	ret
%FUNCTION_END(ms_make_rk256_b);

;extern "C" void m_impl_aes_128_key_expansion(const unsigned char * abyp_userkey,
;                                            unsigned char * abyp_key);
%FUNCTION_HEADER(m_impl_aes_128_key_expansion, 0);
;    ---------------------------------------
;   |            REGISTER STATUS            |
;   |  src: %TEXT:PARAM_1;          dest: %TEXT:PARAM_2;          |
;    ---------------------------------------
	movdqu		xmm1,[%TEXT:PARAM_1;]
	movdqu		[%TEXT:PARAM_2;],xmm1

   	aeskeygenassist	xmm2,xmm1,1
	call		ms_prepare_roundkey_128
	movdqu		[%TEXT:PARAM_2;+16],xmm1

   	aeskeygenassist	xmm2,xmm1,2
	call		ms_prepare_roundkey_128
	movdqu		[%TEXT:PARAM_2;+32],xmm1

    aeskeygenassist	xmm2,xmm1,4
	call		ms_prepare_roundkey_128
	movdqu		[%TEXT:PARAM_2;+48],xmm1

    aeskeygenassist	xmm2,xmm1,8
	call		ms_prepare_roundkey_128
	movdqu		[%TEXT:PARAM_2;+64],xmm1

    aeskeygenassist	xmm2,xmm1,16
	call		ms_prepare_roundkey_128
	movdqu		[%TEXT:PARAM_2;+80],xmm1

    aeskeygenassist	xmm2,xmm1,32
	call		ms_prepare_roundkey_128
	movdqu		[%TEXT:PARAM_2;+96],xmm1

    aeskeygenassist	xmm2,xmm1,64
	call		ms_prepare_roundkey_128
	movdqu		[%TEXT:PARAM_2;+112],xmm1

    aeskeygenassist	xmm2,xmm1,80h
	call		ms_prepare_roundkey_128
	movdqu		[%TEXT:PARAM_2;+128],xmm1

    aeskeygenassist	xmm2,xmm1,1Bh
	call		ms_prepare_roundkey_128
	movdqu		[%TEXT:PARAM_2;+144],xmm1

    aeskeygenassist	xmm2,xmm1,36h
	call		ms_prepare_roundkey_128
	movdqu		[%TEXT:PARAM_2;+160],xmm1
	ret
%FUNCTION_END(m_impl_aes_128_key_expansion); 
    
;extern "C" void m_impl_aes_192_key_expansion(const unsigned char * abyp_userkey,
;                                            unsigned char * abyp_key);
%FUNCTION_HEADER(m_impl_aes_192_key_expansion, 0);
;    ---------------------------------------
;   |            REGISTER STATUS            |
;   |  src: %TEXT:PARAM_1;          dest: %TEXT:PARAM_2;          |
;    ---------------------------------------
	movdqu		xmm1,[%TEXT:PARAM_1;]
	movq_r      xmm3,QWORD PTR[%TEXT:PARAM_1;+16]

	movdqu		[%TEXT:PARAM_2;],xmm1
	movdqa		xmm5,xmm3

    aeskeygenassist	xmm2,xmm3,1
	call		ms_prepare_roundkey_192
	shufpd		xmm5,xmm1,0
	movdqu		[%TEXT:PARAM_2;+16],xmm5
	movdqa		xmm6,xmm1
	shufpd		xmm6,xmm3,1
	movdqu		[%TEXT:PARAM_2;+32],xmm6

    aeskeygenassist	xmm2,xmm3,2
	call		ms_prepare_roundkey_192
	movdqu		[%TEXT:PARAM_2;+48],xmm1
	movdqa		xmm5,xmm3

    aeskeygenassist	xmm2,xmm3,4
	call		ms_prepare_roundkey_192
	shufpd		xmm5,xmm1,0
	movdqu		[%TEXT:PARAM_2;+64],xmm5
	movdqa		xmm6,xmm1
	shufpd		xmm6,xmm3,1
	movdqu		[%TEXT:PARAM_2;+80],xmm6

    aeskeygenassist	xmm2,xmm3,8
	call		ms_prepare_roundkey_192
	movdqu		[%TEXT:PARAM_2;+96],xmm1
	movdqa		xmm5,xmm3

    aeskeygenassist	xmm2,xmm3,16
	call		ms_prepare_roundkey_192
	shufpd		xmm5,xmm1,0
	movdqu		[%TEXT:PARAM_2;+112],xmm5
	movdqa		xmm6,xmm1
	shufpd		xmm6,xmm3,1
	movdqu		[%TEXT:PARAM_2;+128],xmm6

    aeskeygenassist	xmm2,xmm3,32
	call		ms_prepare_roundkey_192
	movdqu		[%TEXT:PARAM_2;+144],xmm1
	movdqa		xmm5,xmm3

    aeskeygenassist	xmm2,xmm3,64
	call		ms_prepare_roundkey_192
	shufpd		xmm5,xmm1,0
	movdqu		[%TEXT:PARAM_2;+160],xmm5
	movdqa		xmm6,xmm1
	shufpd		xmm6,xmm3,1
	movdqu		[%TEXT:PARAM_2;+176],xmm6

    aeskeygenassist	xmm2,xmm3,128
	call		ms_prepare_roundkey_192
	movdqu		[%TEXT:PARAM_2;+192],xmm1
	movdqu		[%TEXT:PARAM_2;+208],xmm3
	ret
%FUNCTION_END(m_impl_aes_192_key_expansion); 

;extern "C" void m_impl_aes_256_key_expansion(const unsigned char * abyp_userkey,
;                                            unsigned char * abyp_key);
%FUNCTION_HEADER(m_impl_aes_256_key_expansion, 0);
;    ---------------------------------------
;   |            REGISTER STATUS            |
;   |  src: %TEXT:PARAM_1;          dest: %TEXT:PARAM_2;          |
;    ---------------------------------------
	movdqu		xmm1,[%TEXT:PARAM_1;]
	movdqu		xmm3,[%TEXT:PARAM_1;+16]

	movdqu		[%TEXT:PARAM_2;],xmm1
	movdqu		[%TEXT:PARAM_2;+16],xmm3

    aeskeygenassist	xmm2,xmm3,1
	call		ms_make_rk256_a
	movdqu		[%TEXT:PARAM_2;+32],xmm1

    aeskeygenassist	xmm2,xmm1,0
	call		ms_make_rk256_b
	movdqu		[%TEXT:PARAM_2;+48],xmm3

    aeskeygenassist	xmm2,xmm3,2
	call		ms_make_rk256_a
	movdqu		[%TEXT:PARAM_2;+64],xmm1

    aeskeygenassist	xmm2,xmm1,0
	call		ms_make_rk256_b
	movdqu		[%TEXT:PARAM_2;+80],xmm3

    aeskeygenassist	xmm2,xmm3,4
	call		ms_make_rk256_a
	movdqu		[%TEXT:PARAM_2;+96],xmm1

    aeskeygenassist	xmm2,xmm1,0
	call		ms_make_rk256_b
	movdqu		[%TEXT:PARAM_2;+112],xmm3

    aeskeygenassist	xmm2,xmm3,8
	call		ms_make_rk256_a
	movdqu		[%TEXT:PARAM_2;+128],xmm1

    aeskeygenassist	xmm2,xmm1,0
	call		ms_make_rk256_b
	movdqu		[%TEXT:PARAM_2;+144],xmm3

    aeskeygenassist	xmm2,xmm3,16
	call		ms_make_rk256_a
	movdqu		[%TEXT:PARAM_2;+160],xmm1

    aeskeygenassist	xmm2,xmm1,0
	call		ms_make_rk256_b
	movdqu		[%TEXT:PARAM_2;+176],xmm3

    aeskeygenassist	xmm2,xmm3,32
	call		ms_make_rk256_a
	movdqu		[%TEXT:PARAM_2;+192],xmm1

    aeskeygenassist	xmm2,xmm1,0
	call		ms_make_rk256_b
	movdqu		[%TEXT:PARAM_2;+208],xmm3

    aeskeygenassist	xmm2,xmm3,64
	call		ms_make_rk256_a
	movdqu		[%TEXT:PARAM_2;+224],xmm1

	ret
%FUNCTION_END(m_impl_aes_256_key_expansion); 
    
;extern "C" void m_impl_aes_revert_key(unsigned char * adsp_key,
;                                     unsigned char * adsp_rev_key,
;                                     size_t szp_rounds);
%FUNCTION_HEADER(m_impl_aes_revert_key, 0);

	mov	r9,%TEXT:PARAM_3;
	shl	r9,4		; * 16
	add	%TEXT:PARAM_2;,r9		; to topmost element

	movdqu	xmm1,[%TEXT:PARAM_1;]
	movdqu	[%TEXT:PARAM_2;],xmm1
	add	%TEXT:PARAM_1;,16
	sub	%TEXT:PARAM_2;,16
	dec	%TEXT:PARAM_3;

revert_loop:
	movdqu	xmm1,[%TEXT:PARAM_1;]
    aesimc	xmm1,xmm1
	movdqu	[%TEXT:PARAM_2;],xmm1
	add	%TEXT:PARAM_1;,16
	sub	%TEXT:PARAM_2;,16
	dec	%TEXT:PARAM_3;
	jnz	revert_loop

	movdqu	xmm1,[%TEXT:PARAM_1;]
	movdqu	[%TEXT:PARAM_2;],xmm1

	ret
%FUNCTION_END(m_impl_aes_revert_key);


%MACRO:aes_dec_blocks(mint:block_cnt, mint:round, mint:xmm_index);
%SET CUR_BLOCK=0;
%RPTN block_cnt;
    aesdec      xmm%INT:CUR_BLOCK;, xmm%INT:xmm_index;                     ; Decryption round %INT:round; for block %INT:CUR_BLOCK;
%SET CUR_BLOCK=CUR_BLOCK+1;
%REND;
%MEND;

%MACRO:aes_dec_last_blocks(mint:block_cnt, mtext:last_offset);
%SET CUR_BLOCK=0;
%RPTN block_cnt;
    aesdeclast  xmm%INT:CUR_BLOCK;, xmm15                     ; Last decryption round for block %INT:CUR_BLOCK;
%SET CUR_BLOCK=CUR_BLOCK+1;
%REND;
%MEND;

%MACRO:aes_enc_blocks(mint:block_cnt, mint:round, mint:xmm_index);
%SET CUR_BLOCK=0;
%RPTN block_cnt;
    aesenc      xmm%INT:CUR_BLOCK;, xmm%INT:xmm_index;                     ; Encryption round %INT:round; for block %INT:CUR_BLOCK;
%SET CUR_BLOCK=CUR_BLOCK+1;
%REND;
%MEND;

%MACRO:aes_enc_last_blocks(mint:block_cnt, mtext:last_offset);
%SET CUR_BLOCK=0;
%RPTN block_cnt;
    aesenclast  xmm%INT:CUR_BLOCK;, xmm15                ; Last encryption round for block %INT:CUR_BLOCK;
%SET CUR_BLOCK=CUR_BLOCK+1;
%REND;
%MEND;

%MACRO:aes_load_blocks(mint:block_cnt,mtext:base,mint:first_index);
%SET CUR_BLOCK=first_index;
%SET OFFSET=0;
%RPTN block_cnt;
    movdqu      xmm%INT:CUR_BLOCK;,[%TEXT:BASE; + 0%INT:OFFSET;h]               ; Load input block %INT:CUR_BLOCK;
%SET CUR_BLOCK=CUR_BLOCK+1;
%SET OFFSET=OFFSET+10;
%REND;
%MEND;

%MACRO:aes_store_blocks(mint:block_cnt,mtext:base);
%SET CUR_BLOCK=0;
%RPTN block_cnt;
%SET OFFSET=CUR_BLOCK*10;
    movdqu      [%TEXT:BASE; + 0%INT:OFFSET;h], xmm%INT:CUR_BLOCK;              ; Store output block %INT:CUR_BLOCK;
%SET CUR_BLOCK=CUR_BLOCK+1;
%REND;
%MEND;

%MACRO:aes_load_keys_1(mint:dummy);
    mov         r10, %TEXT:PARAM_5;
    shl         r10, 4
    
    movdqu      xmm3, [%TEXT:PARAM_3;]
    movdqu      xmm4, [%TEXT:PARAM_3; + 010h]
    movdqu      xmm5, [%TEXT:PARAM_3; + 020h]
    movdqu      xmm6, [%TEXT:PARAM_3; + 030h]
    movdqu      xmm7, [%TEXT:PARAM_3; + 040h]
    movdqu      xmm8, [%TEXT:PARAM_3; + 050h]
    movdqu      xmm9, [%TEXT:PARAM_3; + 060h]
    movdqu      xmm10, [%TEXT:PARAM_3; + 070h]
    movdqu      xmm11, [%TEXT:PARAM_3; + 080h]
    movdqu      xmm12, [%TEXT:PARAM_3; + 090h]
    movdqu      xmm15, [%TEXT:PARAM_3; + r10]
%MEND;

%FUNCTION_HEADER(ms_aes_enc_4, 0);
;    ---------------------------------------
;   |            REGISTER STATUS            |
;   |  src: %TEXT:PARAM_1;          key: %TEXT:PARAM_3;            |
;   |  result: XMM0-3                       |
;    ---------------------------------------
    movdqu      xmm14, [%TEXT:PARAM_3;]
    movdqu      xmm12, [%TEXT:PARAM_3; + 010h]
    movdqu      xmm13, [%TEXT:PARAM_3; + 020h]
    movdqu      xmm15, [%TEXT:PARAM_3; + r10]
%SET CUR_BLOCK=0;
%RPTN 4;
    pxor        xmm%INT:CUR_BLOCK;,xmm14                       ; Apply round key to block %INT:CUR_BLOCK;
%SET CUR_BLOCK=CUR_BLOCK+1;
%REND;
    cmp         %TEXT:PARAM_5;,12

    %aes_enc_blocks(4, 1, 12);
    movdqu      xmm12, [%TEXT:PARAM_3; + 030h]              ; Preload key 3
    %aes_enc_blocks(4, 2, 13);
    movdqu      xmm13, [%TEXT:PARAM_3; + 040h]              ; Preload key 4
    %aes_enc_blocks(4, 3, 12);
    movdqu      xmm12, [%TEXT:PARAM_3; + 050h]              ; Preload key 5
    %aes_enc_blocks(4, 4, 13);
    movdqu      xmm13, [%TEXT:PARAM_3; + 060h]              ; Preload key 6
    %aes_enc_blocks(4, 5, 12);
    movdqu      xmm12, [%TEXT:PARAM_3; + 070h]              ; Preload key 7
    %aes_enc_blocks(4, 6, 13);
    movdqu      xmm13, [%TEXT:PARAM_3; + 080h]              ; Preload key 8
    %aes_enc_blocks(4, 7, 12);
    movdqu      xmm12, [%TEXT:PARAM_3; + 090h]              ; Preload key 9
    %aes_enc_blocks(4, 8, 13);
    movdqu      xmm13, [%TEXT:PARAM_3; + 0A0h]              ; Preload key 10
    %aes_enc_blocks(4, 9, 12);
    movdqu      xmm12, [%TEXT:PARAM_3; + 0B0h]              ; Preload key 11
    jb              aes_enc_4_last              ; jump, if less than 12 rounds (128 bit AES)
    %aes_enc_blocks(4, 8, 13);
    movdqu      xmm13, [%TEXT:PARAM_3; + 0C0h]              ; Preload key 12
    %aes_enc_blocks(4, 9, 12);
    movdqu      xmm12, [%TEXT:PARAM_3; + 0D0h]              ; Preload key 13
    je              aes_enc_4_last              ; jump, if 12 rounds (196 bit AES)
    %aes_enc_blocks(4, 12, 13);
    %aes_enc_blocks(4, 13, 12);
aes_enc_4_last:
    %aes_enc_last_blocks(4, r10);
    ret
%FUNCTION_END(ms_aes_enc_4);

%FUNCTION_HEADER(ms_aes_enc_1, 0);
;    ---------------------------------------
;   |            REGISTER STATUS            |
;   |  src: %TEXT:PARAM_1;          key: %TEXT:PARAM_3;            |
;   |  result: XMM0-3                       |
;    ---------------------------------------
    pxor        xmm0, xmm3                      ; Apply round key
    cmp         %TEXT:PARAM_5;,12

%SET ROUND=1;
%RPTN 9;
%SET KEY_INDEX=ROUND+3;
    aesenc      xmm0, xmm%INT:KEY_INDEX;                      ; Encryption round %INT:KEY_INDEX;
%SET ROUND=ROUND+1;
%REND;
    jb          aes_enc_1_last                  ; jump, if less than 12 rounds (128 bit AES)
    movdqu      xmm13, [%TEXT:PARAM_3; + 0A0h ]
    aesenc      xmm0, xmm13                     ; Encryption round 10
    movdqu      xmm14, [%TEXT:PARAM_3; + 0B0h ]
    movdqu      xmm13, [%TEXT:PARAM_3; + 0C0h ]
    aesenc      xmm0, xmm14                     ; Encryption round 11
    movdqu      xmm14, [%TEXT:PARAM_3; + 0D0h ]
    je          aes_enc_1_last                  ; jump, if 12 rounds (196 bit AES)
    aesenc      xmm0, xmm13                     ; Encryption round 12
    aesenc      xmm0, xmm14                     ; Encryption round 13
aes_enc_1_last:
    aesenclast  xmm0, xmm15
    ret
%FUNCTION_END(ms_aes_enc_1);

%FUNCTION_HEADER(ms_aes_dec_4, 0);
;    ---------------------------------------
;   |            REGISTER STATUS            |
;   |  src: %TEXT:PARAM_1;          key: %TEXT:PARAM_3;            |
;   |  result: XMM0-3                       |
;    ---------------------------------------
%SET CUR_BLOCK=0;
    movdqu      xmm12, [%TEXT:PARAM_3; + 010h]              ; Preload key 1
    movdqu      xmm13, [%TEXT:PARAM_3; + 020h]              ; Preload key 2

%RPTN 4;
    pxor        xmm%INT:CUR_BLOCK;,xmm14                      ; Apply round key to block %INT:CUR_BLOCK;
%SET CUR_BLOCK=CUR_BLOCK+1;
%REND;
    cmp         %TEXT:PARAM_5;,12

    %aes_dec_blocks(4, 1, 12);
    movdqu      xmm12, [%TEXT:PARAM_3; + 030h]              ; Preload key 3
    %aes_dec_blocks(4, 2, 13);
    movdqu      xmm13, [%TEXT:PARAM_3; + 040h]              ; Preload key 4
    %aes_dec_blocks(4, 3, 12);
    movdqu      xmm12, [%TEXT:PARAM_3; + 050h]              ; Preload key 5
    %aes_dec_blocks(4, 4, 13);
    movdqu      xmm13, [%TEXT:PARAM_3; + 060h]              ; Preload key 6
    %aes_dec_blocks(4, 5, 12);
    movdqu      xmm12, [%TEXT:PARAM_3; + 070h]              ; Preload key 7
    %aes_dec_blocks(4, 6, 13);
    movdqu      xmm13, [%TEXT:PARAM_3; + 080h]              ; Preload key 8
    %aes_dec_blocks(4, 7, 12);
    movdqu      xmm12, [%TEXT:PARAM_3; + 090h]              ; Preload key 9
    %aes_dec_blocks(4, 8, 13);
    movdqu      xmm13, [%TEXT:PARAM_3; + 0A0h]              ; Preload key 10
    %aes_dec_blocks(4, 9, 12);
    movdqu      xmm12, [%TEXT:PARAM_3; + 0B0h]              ; Preload key 11
    jb              aes_dec_4_last              ; jump, if less than 12 rounds (128 bit AES)
    %aes_dec_blocks(4, 8, 13);
    movdqu      xmm13, [%TEXT:PARAM_3; + 0C0h]              ; Preload key 12
    %aes_dec_blocks(4, 9, 12);
    movdqu      xmm12, [%TEXT:PARAM_3; + 0D0h]              ; Preload key 13
    je              aes_dec_4_last              ; jump, if 12 rounds (196 bit AES)
    %aes_dec_blocks(4, 12, 13);
    %aes_dec_blocks(4, 13, 12);
aes_dec_4_last:
    %aes_dec_last_blocks(4, r10);
    ret
%FUNCTION_END(ms_aes_dec_4);

%FUNCTION_HEADER(ms_aes_dec_1, 0);
;    ---------------------------------------
;   |            REGISTER STATUS            |
;   |  src: %TEXT:PARAM_1;          key: %TEXT:PARAM_3;            |
;   |  result: XMM0-3                       |
;    ---------------------------------------
    pxor        xmm0, xmm3                      ; Apply round key
    cmp         %TEXT:PARAM_5;,12

%SET ROUND=1;
%RPTN 9;
%SET KEY_INDEX=ROUND+3;
    aesdec      xmm0, xmm%INT:KEY_INDEX;                      ; Decryption round %INT:KEY_INDEX;
%SET ROUND=ROUND+1;
%REND;
    jb          aes_dec_1_last                  ; jump, if less than 12 rounds (128 bit AES)
    movdqu      xmm13, [%TEXT:PARAM_3; + 0A0h ]
    aesdec      xmm0, xmm13                     ; Decryption round 10
    movdqu      xmm14, [%TEXT:PARAM_3; + 0B0h ]
    movdqu      xmm13, [%TEXT:PARAM_3; + 0C0h ]
    aesdec      xmm0, xmm14                     ; Decryption round 11
    movdqu      xmm14, [%TEXT:PARAM_3; + 0D0h ]
    je          aes_dec_1_last                  ; jump, if 12 rounds (196 bit AES)
    aesdec      xmm0, xmm13                     ; Decryption round 12
    aesdec      xmm0, xmm14                     ; Decryption round 13
aes_dec_1_last:
    aesdeclast  xmm0, xmm15                     ; Decryption last round
    ret
%FUNCTION_END(ms_aes_dec_1);

    
;extern "C" void m_impl_aes_ecb_encrypt(const unsigned char * abyp_in,
;                                      unsigned char * abyp_out,
;                                      const unsigned char * abyp_key,
;                                      size_t szp_block_count,
;                                      size_t imp_number_of_rounds);
%FUNCTION_HEADER(m_impl_aes_ecb_encrypt, 0);
    ; ommit stack frame, it is not used
    %LOAD_PARAMS(5);
    %PUSH_XMM(6,15);

;    ---------------------------------------
;   |            REGISTER STATUS            |
;   |  src: %TEXT:PARAM_1;          dest: %TEXT:PARAM_2;          |
;   |  key: %TEXT:PARAM_3;           block cnt: %TEXT:PARAM_4;      |
;   |  rounds: %TEXT:PARAM_5;                          |
;    ---------------------------------------
    cmp         %TEXT:PARAM_4;,0
    jz          ecb_enc_end_4

    mov         r10, %TEXT:PARAM_5;
    shl         r10, 4

;    ---------------------------------------
;   |            REGISTER STATUS              |
;   |  src: %TEXT:PARAM_1;          dest: %TEXT:PARAM_2;            |
;   |  key: %TEXT:PARAM_3;           block cnt: %TEXT:PARAM_4;        |
;   |  rounds: %TEXT:PARAM_5;       last key offset: R10 |
;    ---------------------------------------
    cmp         %TEXT:PARAM_4;,4
    jl          ecb_enc_4_loop_end

align 16
ecb_enc_4_loop_start:
    %aes_load_blocks(4, %TEXT:PARAM_1;,0);
    call        ms_aes_enc_4
    lea         %TEXT:PARAM_1;,[%TEXT:PARAM_1;+40h]
    %aes_store_blocks(4, %TEXT:PARAM_2;);
    lea         %TEXT:PARAM_2;,[%TEXT:PARAM_2;+40h]
    sub         %TEXT:PARAM_4;,4
    jz          ecb_enc_end_4
    cmp         %TEXT:PARAM_4;,4
    jge         ecb_enc_4_loop_start

    add         %TEXT:PARAM_4;,4
ecb_enc_4_loop_end:
    %aes_load_keys_1(0);
ecb_enc_loop_4_2:
    %aes_load_blocks(1, %TEXT:PARAM_1;,0);
    call        ms_aes_enc_1
    lea         %TEXT:PARAM_1;,[%TEXT:PARAM_1;+16]
    movdqu      [%TEXT:PARAM_2;],xmm0
    lea         %TEXT:PARAM_2;,[%TEXT:PARAM_2;+16]
    dec         %TEXT:PARAM_4;
    jnz         ecb_enc_loop_4_2

ecb_enc_end_4:

    %POP_XMM(6,15);
    %POP_PARAMS(5);
    ret
%FUNCTION_END(m_impl_aes_ecb_encrypt);

;extern "C" void m_impl_aes_ctr(const unsigned char * abyp_input,
;                              unsigned char * abyp_output,
;                              const unsigned char * adsp_key,
;                              size_t szp_block_count,
;                              size_t inp_rounds,
;                              unsigned char * abyp_iv);
%FUNCTION_HEADER(m_impl_aes_ctr, 0);
    %LOAD_PARAMS(6);
    push        r12
    push        r13
    push        r14
    %PUSH_XMM(6,7);
;    ---------------------------------------
;   |            REGISTER STATUS            |
;   |  src: %TEXT:PARAM_1;          dest: %TEXT:PARAM_2;          |
;   |  key: %TEXT:PARAM_3;           block cnt: %TEXT:PARAM_4;      |
;   |  rounds: %TEXT:PARAM_5;       IV: %TEXT:PARAM_6;            |
;    ---------------------------------------

%SET UNROLL_CNT=4;
    mov         r10, %TEXT:PARAM_5;
    shl         r10, 4

    movdqu      xmm0, [%TEXT:PARAM_6;]
    mov         eax, [%TEXT:PARAM_6;+0Ch]
    bswap       eax
    dec         eax
    sub         rsp, 040h
    movdqu      [rsp], xmm0

    movdqu      [rsp + 010h], xmm0
    movdqu      [rsp + 020h], xmm0
    movdqu      [rsp + 030h], xmm0
        
    movdqa      xmm2, xmm0
    cmp         %TEXT:PARAM_4;,%INT:UNROLL_CNT;
    jl          aes_ctr_1_start
aes_ctr_%INT:UNROLL_CNT;_loop:
%SET INDEX=1;
%SET XMM_INDEX=0;
%SET COUNTER_OFFSET=0;
%RPTN UNROLL_CNT;
    movdqa      xmm%INT:XMM_INDEX;, xmm2
    lea         r1%INT:INDEX;d, [eax+%INT:INDEX;]
    bswap       r1%INT:INDEX;d
    pinsrw      xmm%INT:XMM_INDEX;, r1%INT:INDEX;d, 6
    shr         r1%INT:INDEX;d, 16
    pinsrw      xmm%INT:XMM_INDEX;, r1%INT:INDEX;d, 7
%SET XMM_INDEX=XMM_INDEX+1;
%SET INDEX=INDEX+1;
%SET COUNTER_OFFSET=COUNTER_OFFSET+1;
%REND;
    lea         eax, [eax+%INT:UNROLL_CNT;]
    call        ms_aes_enc_%INT:UNROLL_CNT;
    %aes_load_blocks(%INT:UNROLL_CNT;, %TEXT:PARAM_1;, %INT:UNROLL_CNT;);
    lea         %TEXT:PARAM_1;, [%TEXT:PARAM_1; + 16*%INT:UNROLL_CNT;]
%SET KEY_INDEX=0;
%SET SRC_INDEX=UNROLL_CNT;
%RPTN UNROLL_CNT;
    pxor        xmm%INT:KEY_INDEX;, xmm%INT:SRC_INDEX;
%SET KEY_INDEX=KEY_INDEX+1;
%SET SRC_INDEX=SRC_INDEX+1;
%REND;
    %aes_store_blocks(%INT:UNROLL_CNT;, %TEXT:PARAM_2;);
    movdqu      xmm2, [rsp]
    lea         %TEXT:PARAM_2;, [%TEXT:PARAM_2; + 16*%INT:UNROLL_CNT;]
    sub         %TEXT:PARAM_4;,%INT:UNROLL_CNT;
    cmp         %TEXT:PARAM_4;,%INT:UNROLL_CNT;
    jge         aes_ctr_%INT:UNROLL_CNT;_loop

aes_ctr_1_start:
    %aes_load_keys_1(0);
    cmp         %TEXT:PARAM_4;,0
    jz          aes_ctr_end
aes_ctr_1_loop:
    inc         eax
    movdqa      xmm0, xmm2
    mov         r12d, eax
    bswap       r12d
    pinsrw      xmm0, r12d, 6
    shr         r12d, 16
    pinsrw      xmm0, r12d, 7
    call        ms_aes_enc_1
    movdqu      xmm1, [%TEXT:PARAM_1;]
    lea         %TEXT:PARAM_1;, [%TEXT:PARAM_1;+16]
    pxor        xmm1,xmm0
    movdqu      [%TEXT:PARAM_2;],xmm1
    lea         %TEXT:PARAM_2;, [%TEXT:PARAM_2;+16]
    dec         %TEXT:PARAM_4;
    jnz         aes_ctr_1_loop
    movdqa      xmm0, xmm2

aes_ctr_end:
    inc         eax
    bswap       eax
    pinsrw      xmm0, eax, 6
    shr         eax, 16
    pinsrw      xmm0, eax, 7
    call        ms_aes_enc_1
    movdqu      [%TEXT:PARAM_6;], xmm0

    add         rsp, 040h

    %POP_XMM(6,7);
    pop         r14
    pop         r13
    pop         r12
    %POP_PARAMS(6);
    ret
%FUNCTION_END(m_impl_aes_ctr);

%FUNCTION_HEADER(m_impl_aes_cbc_encrypt, 0);
    %LOAD_PARAMS(6);
    %PUSH_XMM(6,15);
;    ---------------------------------------
;   |            REGISTER STATUS            |
;   |  src: %TEXT:PARAM_1;          dest: %TEXT:PARAM_2;          |
;   |  key: %TEXT:PARAM_3;           block cnt: %TEXT:PARAM_4;      |
;   |  rounds: %TEXT:PARAM_5;       IV: %TEXT:PARAM_6;            |
;    ---------------------------------------
    
    cmp         %TEXT:PARAM_4;, 0
    je          aes_cbc_enc_end

    %aes_load_keys_1(0);
    movdqu      xmm0, [%TEXT:PARAM_6;]                  ; Load IV
aes_cbc_enc_loop:
;    ---------------------------------------
;   |            REGISTER STATUS            |
;   |  src: %TEXT:PARAM_1;          dest: %TEXT:PARAM_2;          |
;   |  key: %TEXT:PARAM_3;           block cnt: %TEXT:PARAM_4;      |
;   |  rounds: %TEXT:PARAM_5;       curr IV: XMM0          |
;    ---------------------------------------
    movdqu      xmm1, [%TEXT:PARAM_1;]                  ; Load source
    lea         %TEXT:PARAM_1;, [%TEXT:PARAM_1;+16]
    pxor        xmm0, xmm1
    call        ms_aes_enc_1
    movdqu      [%TEXT:PARAM_2;], xmm0
    lea         %TEXT:PARAM_2;, [%TEXT:PARAM_2;+16]
    dec         %TEXT:PARAM_4;
    jnz         aes_cbc_enc_loop

aes_cbc_enc_end:
    
    %POP_XMM(6,15);
    %POP_PARAMS(6);
    ret
%FUNCTION_END(m_impl_aes_cbc_encrypt);
    
%FUNCTION_HEADER(m_impl_aes_cbc_decrypt, 0);
    %LOAD_PARAMS(6);
    %PUSH_XMM(6,15);
;    ---------------------------------------
;   |            REGISTER STATUS            |
;   |  src: %TEXT:PARAM_1;          dest: %TEXT:PARAM_2;          |
;   |  key: %TEXT:PARAM_3;           block cnt: %TEXT:PARAM_4;      |
;   |  rounds: %TEXT:PARAM_5;       IV: %TEXT:PARAM_6;            |
;    ---------------------------------------

    cmp         %TEXT:PARAM_4;, 0
    je          aes_cbc_dec_end


    movdqu      xmm8, [%TEXT:PARAM_6;]                  ; Load first IV
    
    cmp         %TEXT:PARAM_4;, 4
    jl          aes_cbc_dec_1_start

    mov         r10, %TEXT:PARAM_5;
    shl         r10, 4

    movdqu      xmm14, [%TEXT:PARAM_3;]                 ; Preload roundkey
    movdqu      xmm15, [%TEXT:PARAM_3; + r10]                 ; Preload last key
aes_cbc_dec_4_loop:
    %aes_load_blocks(4, %TEXT:PARAM_1;, 0);
    lea         %TEXT:PARAM_1;, [%TEXT:PARAM_1; + 040h]
    movdqa      xmm4, xmm8
    movdqa      xmm5, xmm0
    movdqa      xmm6, xmm1
    movdqa      xmm7, xmm2
    movdqa      xmm8, xmm3
    call        ms_aes_dec_4
    pxor        xmm0, xmm4
    movdqu      [%TEXT:PARAM_2;], xmm0
    pxor        xmm1, xmm5
    movdqu      [%TEXT:PARAM_2;+010h], xmm1
    pxor        xmm2, xmm6
    movdqu      [%TEXT:PARAM_2;+020h], xmm2
    pxor        xmm3, xmm7
    movdqu      [%TEXT:PARAM_2;+030h], xmm3
    lea         %TEXT:PARAM_2;, [%TEXT:PARAM_2; + 040h]
    sub         %TEXT:PARAM_4;,4
    jz          aes_cbc_dec_end
    cmp         %TEXT:PARAM_4;,4
    jge         aes_cbc_dec_4_loop

aes_cbc_dec_1_start:
    movdqa      xmm1, xmm8
    %aes_load_keys_1(0);
aes_cbc_dec_1_loop:
    movdqu      xmm0, [%TEXT:PARAM_1;]
    lea         %TEXT:PARAM_1;, [%TEXT:PARAM_1;+16]
    movdqa      xmm2, xmm0
    call        ms_aes_dec_1
    pxor        xmm0, xmm1
    movdqu      [%TEXT:PARAM_2;], xmm0
    lea         %TEXT:PARAM_2;, [%TEXT:PARAM_2;+16]
    movdqa      xmm1, xmm2
    dec         %TEXT:PARAM_4;
    jnz         aes_cbc_dec_1_loop

aes_cbc_dec_end:
    %POP_XMM(6,15);
    %POP_PARAMS(6);
    ret
%FUNCTION_END(m_impl_aes_cbc_decrypt);

%FUNCTION_HEADER(ms_ghash_asm, 0);
;RSP+038H holds Hash key H (128 bits)
;xmm1 holds new X (128 bits)
;rsp+048H holds the old state and takes the new
    pshufb      xmm1, [RSP+058H]    ; Byte-swap input

    pxor        xmm1, [rsp+048H]
    movdqu      xmm3, [RSP+038H]
    pclmulqdq   xmm3, xmm1, 0       ; xmm3 holds D = a0*b0

    movdqu      xmm6, [RSP+038H]
    pclmulqdq   xmm6, xmm1, 17      ; xmm6 holds C= a1*b1

    movdqa      xmm7, xmm1
    psrldq      xmm1, 8             ; b0 = b1
    pxor        xmm1, xmm7          ; b0 = b1+b0
    pclmulqdq   xmm1, [RSP+008H], 0 ; xmm1 holds E = (a0+a1)*(b0+b1)

    pxor        xmm1, xmm3          ; E += D
    pxor        xmm1, xmm6          ; E += C
    movdqa      xmm4, xmm1          ; load E = E+D+C
    psrldq      xmm1, 8             ; get e1+d1+c1 in low DQword
    pslldq      xmm4, 8             ; get e0+c0+d0 in high DQword
    pxor        xmm6, xmm1          ; x2 = c0+e1+d1+c1, x3 = c1
    pxor        xmm3, xmm4          ; x1 = d1+e0+d0+c0, x0 = d0
        
    ; <xmm6:xmm3> holds the result of 
; the carry
; shift the result by one bit position to the left cope for the fact
; that bits are reversed
    movdqa      xmm7, xmm3
    movdqa      xmm1, xmm6
    pslld       xmm3, 1
    pslld       xmm6, 1
    psrld       xmm7, 31
    psrld       xmm1, 31
    movdqa      xmm4, xmm7
    pslldq      xmm1, 4
    pslldq      xmm7, 4
    psrldq      xmm4, 12
    por         xmm3, xmm7
    por         xmm6, xmm1
    por         xmm6, xmm4
; first phase of the reduction
    movdqa      xmm7, xmm3
    movdqa      xmm1, xmm3
    movdqa      xmm4, xmm3   
    pslld       xmm7, 31            ; packed right shifting << 31 
    pslld       xmm1, 30            ; packed right shifting shift << 30
    pslld       xmm4, 25            ; packed right shifting shift << 25 
    pxor        xmm7, xmm1          ; xor the shifted versions
    pxor        xmm7, xmm4  
    movdqa      xmm1, xmm7
    pslldq      xmm7, 12
    psrldq      xmm1, 4
    pxor        xmm3, xmm7          ; first phase of the reduction complete 
    movdqa      xmm2, xmm3          ; second phase of the reduction
    movdqa      xmm4, xmm3
    movdqa      xmm5, xmm3  
    psrld       xmm2, 1             ; packed left shifting >> 1
    psrld       xmm4, 2             ; packed left shifting >> 2
    psrld       xmm5, 7             ; packed left shifting >> 7   
    pxor        xmm2, xmm4          ; xor the shifted versions
    pxor        xmm2, xmm5
    pxor        xmm2, xmm1
    pxor        xmm3, xmm2 
    pxor        xmm6, xmm3          ; the result is in xmm6 
    movdqu      [rsp+048H], xmm6    ; store the result

    ret
%FUNCTION_END(ms_ghash_asm);

%IF DEF UNIX$NASM;
%DEFT REL:rel
%CEND;
;extern "C" void m_impl_ghash_stream(unsigned char* achp_hash_state,
;								    const unsigned char* achp_hash_key,
;								    const unsigned char* achp_data,
;							 	   size_t szp_data_len);
%FUNCTION_HEADER(m_impl_ghash_stream, 0);
%PUSH_XMM(6,7);

    lea         rax, [%TEXT:REL; GCM_BSWAP]                ; Load address of byte swap mask, avoids problems with largeaddressaware and on MAC
    movdqu      xmm0, [%TEXT:PARAM_1;]
    movdqu      xmm1, [%TEXT:PARAM_2;]
    movdqu      xmm3, [rax]
    ; move stack the same way as m_impl_aes_gcm_auth_* do, so m_ghash_asm can be used
    ; we don't need the full space, just as far as m_ghash_asm requires
    sub         rsp, 068h

    pshufb      xmm1, xmm3                      ; byte swap the key
	pshufb		xmm0, xmm3						; byte swap the state
    movdqa      [rsp+040h], xmm0                ; state in RSP+040h (048h in m_ghash_asm)
    movdqa      [rsp+030h], xmm1                ; key in RSP+030h (038h in m_ghash_asm)
    movdqa      [rsp+050h], xmm3                ; swap mask in RSP+050h (058h in m_ghash_asm)
    movdqa      xmm2, xmm1
    psrldq      xmm2, 8                         ; a0 = a1
    pxor        xmm2, xmm1                      ; a0 = a1+a0
    movdqa      [RSP], xmm2                     ; self-added key in RSP+000h (008h in m_ghash_asm)

    cmp         %TEXT:PARAM_4;, 010h
    jl          gcm_stream_partial

gcm_stream_block_loop:
    movdqu      xmm1, [%TEXT:PARAM_3;]                      ; input to xmm1
    call        ms_ghash_asm
    lea         %TEXT:PARAM_3;, [%TEXT:PARAM_3;+010h]
    sub         %TEXT:PARAM_4;, 010h
    cmp         %TEXT:PARAM_4;, 010h
    jge         gcm_stream_block_loop
 
gcm_stream_partial:
    cmp         %TEXT:PARAM_4;, 0
    je          gcm_stream_no_partial
    pxor        xmm0, xmm0
    movdqa      [rsp+010H], xmm0                ; push a 0 block to stack to generate 0-padding

gcm_stream_partial_loop:
    mov         al, [%TEXT:PARAM_3;+%TEXT:PARAM_4;-01h]
    mov         [rsp+%TEXT:PARAM_4;+00fh], al
    dec         %TEXT:PARAM_4;
    jnz         gcm_stream_partial_loop
    movdqu      xmm1, [rsp+010h]
    call        ms_ghash_asm

gcm_stream_no_partial:
    movdqu      xmm0, [rsp+040h]			; load state from stack
	pshufb		xmm0, [rsp+050h]			; byte swap the state
    movdqu      [%TEXT:PARAM_1;], xmm0					; store state back to parameter

    lea         rsp, [rsp+068h]

%POP_XMM(6,7);
    ret
%FUNCTION_END(m_impl_ghash_stream);

%IF DEF WIN$VC;
end
%CEND;
