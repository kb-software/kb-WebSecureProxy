// This file was generated by the script combine_sources.rb
/** @date Wed Sep 27 12:11:26 2017  (creation) */
/**
*/
#if (!defined HL_CERT_ASN_1_MAIN) && (!defined HL_CERT_ASN_1_HELPER) && (!defined HL_CERT_CLIB) && (!defined HL_CERT_OCSP) && (!defined HL_CERT_PKCS5) && (!defined HL_CERT_PKCS12) && (!defined HL_CERT_PKCS11) && (!defined HL_SSL_LLIB) && (!defined HL_BASE64_PEM)
#define HL_CERT_ASN_1_MAIN
#define HL_CERT_ASN_1_HELPER
#define HL_CERT_CLIB
#define HL_CERT_OCSP
#define HL_CERT_PKCS5
#define HL_CERT_PKCS12
#define HL_CERT_PKCS11
#define HL_SSL_LLIB
#define HL_BASE64_PEM
#endif

#ifdef HL_CERT_ASN_1_MAIN
/** @defgroup asn1 Certificate handling
* This module contains functions for certificate handling.
* 
* In the context of this CC evaluation this module is used for:
*<ul>
* <li> Extraction of data from certificates.
* <li> Comparison of certificates (only in case of java SSL classes comparing server
* certificates).
* <li> Checking of the digital signatures3: the content of the certificate is hashed and
* compared to the hash that was delivered with the certificate (which had to be
* decrypted using the public key of the signing authority).
* Depending on the connection type, this is done with one certificate (server, HTTPS)
* or both (server and client, SSL/TLS).
* <li> Checking of validity periods4: the current system time has to lie in between the
* beginning and the end of the certificate validity period.
* Depending on the connection type, this is done with one certificate (server, HTTPS)
* or both (server and client, SSL/TLS).
*</ul>
* This module also provides functions to verify or build certificate trees, to process key
* parameters and certificate extensions and more.
*
* The general ASN.1 processing (composition/decomposition) routines are implemented
* based on control tables for the ASN.1 structures to handle.
*
* The two most common structures of this module are <code>IDATA</code> and 
* <code>IDATPARR</code>, which are primarily used to organize data buffers.
* <code>IDATA</code> describes an individual data buffer, <code>IDATPARR</code>
* describes a number of data buffers.
*
* It is very important to note, that <code>IDATA</code> elements may reference
* the same buffer and a whole <code>IDATPARR</code> can describe a single data
* buffer. However, it is also possible, that each <code>IDATA</code> element
* of an <code>IDATPARR</code> structure has an own buffer, that is just 
* allocated for that element.
*
* To prevent both data corruption and memory errors, the user must always be
* aware, if a structure generated by a function references the original source
* data ('shwallow copy') or has its own data ('deep copy').
*
* This module depends on the following modules:
*<ul>
* <li> @ref md5 "MD5" hashing functions
* <li> @ref sha1 "SHA-1" hashing functions
* <li> @ref lnum32 "Large number" functions
* <li> @ref rsa "RSA" encryption/decryption/signature functions
* <li> @ref dsa_dh "DSA" signature / diffie-hellman functions
* <li> @ref pkcs5 "PKCS5" encryption/decryption functions
* <li> @ref gutil "Generic Utility" for reading configurations for external 
*                  cert store
*</ul>
*  @{
*  @file
* This file contains the main implementation of certificate handling routines.
*
*NOTE: The file hasn1.c is used for C interface versions. For JAVA, a copy from
* hasn1.c is used named h1.c to reduce naming overhead.
* The file h1.c is generated during software compilation from hasn1.c.
*  @}
*/
//=====================================================================
//
// ASN.1 Basic Processing Module
//
//
//=====================================================================
#if (defined _WIN32) & (_MSC_VER < 1700)
#ifndef _STDINT
#define _STDINT
// MSVC lower than 17.00 does not have stdint.h, assure, all needed types are defined

typedef unsigned __int16 uint16_t;

typedef unsigned __int32 uint32_t;

typedef unsigned __int64 uint64_t;

#endif // !_STDINT
#else
#include <stdint.h>
#endif
#include <stddef.h>
#ifdef _WIN32
#define WIN32_LEAN_AND_MEAN
#include <Windows.h>
#undef WIN32_LEAN_AND_MEAN
#else// Define system-specific HL_* defines here
#ifndef HL_UNIX
#define HL_UNIX

#if (defined __gnu_linux__) || (defined __linux__)
#define HL_LINUX
#endif

#if (defined __APPLE__) && (defined __MACH__)
#define HL_LINUX
#define HL_MACOS
#endif

#ifdef _AIX
#define HL_AIX
#define HL_BIG_ENDIAN
#endif

#ifdef __FreeBSD__
#define HL_FREEBSD
#endif

#if (defined _hpux) || (defined hpux) || (defined __hpux)
#define HL_HPUX
#define HL_BIG_ENDIAN
#endif

#if (defined sun) || (defined __sun)
#define HL_SOLARIS
#endif

#if (defined __arm__) || (defined __aarch64__)
#define HL_LINUX_ARM
#endif

#ifdef __ANDROID__
#define HL_ANDROID
#endif

#ifdef __ANDROID__
#define HL_ANDROID
#endif

#endif
#include <hob-unix01.h>
#endif
#ifdef __APPLE__
/* We get target conditionals to keep apart Mac OS, iOS and iOS simulator.
   The conditionals are TARGET_IPHONE_SIMULATOR, TARGET_OS_IPHONE and TARGET_OS_MAC.
   TARGET_IPHONE_SIMULATOR has the highest priority, TARGET_OS_MAC the lowest.
   Always test, if the conditional is 1, as they will be defined as 0, if we 
   are not compiling for the target.
   */
#include <TargetConditionals.h>
#endif

#ifdef HL_ANDROID
#include <netdb.h>
#include <unistd.h>
#include <linux/in.h>
#ifndef SOCKLEN_T
#define SOCKLEN_T      int
#endif
#ifndef SA_FAMILY_T
#define SA_FAMILY_T  short
#endif
#include <sys/endian.h>
#include <asm/ioctls.h>
#include <errno.h>
#endif

#include "hob-encry-1.h"
#include "hob-cert-ext.h"
#ifdef _WIN32
#include <winsock.h>
#endif
#include "hob-cert-err.h"
#include <string.h>
#include "hob-cert-intern.h"

#if defined _WIN32
#pragma warning(disable:4996)
#endif

#include <stdarg.h>
#if !defined _WIN32 && !defined XH_INTERFACE
// UNIX system
#include <hob-unix01.h>
#endif
#include <hob-xslunic1.h>
#if !defined C_OUT
#include <time.h>
#if !defined _AIX
#include <memory.h>
#else
#include <stdlib.h>
#endif
#include <string.h>
#endif // C_OUT

//-----------------------------------------------------------------------------
// This section was formerly included from asnobjid.c
//-----------------------------------------------------------------------------

/** @addtogroup asn1
* @{
* @file
* This file contains tables of OIDs and supporting data for OID handling.
* @}
*/
// WARNING: This file was automatically generated by program GENOBJS.
// DO NOT CHANGE MANUALLY ! If changes are required change the source
// script and run GENOBJS.
// Source Script was: hasn1obj.src

//-------------------------------------------
// OID Array 
//-------------------------------------------

unsigned char OID_Table[748] = {
  (unsigned char) 0x01, (unsigned char) 0x00, (unsigned char) 0x03,
  (unsigned char) 0x55, (unsigned char) 0x04, (unsigned char) 0x03,

  (unsigned char) 0x01, (unsigned char) 0x00, (unsigned char) 0x03,
  (unsigned char) 0x55, (unsigned char) 0x04, (unsigned char) 0x04,

  (unsigned char) 0x01, (unsigned char) 0x00, (unsigned char) 0x03,
  (unsigned char) 0x55, (unsigned char) 0x04, (unsigned char) 0x06,

  (unsigned char) 0x01, (unsigned char) 0x00, (unsigned char) 0x03,
  (unsigned char) 0x55, (unsigned char) 0x04, (unsigned char) 0x07,

  (unsigned char) 0x01, (unsigned char) 0x00, (unsigned char) 0x03,
  (unsigned char) 0x55, (unsigned char) 0x04, (unsigned char) 0x08,

  (unsigned char) 0x01, (unsigned char) 0x00, (unsigned char) 0x03,
  (unsigned char) 0x55, (unsigned char) 0x04, (unsigned char) 0x09,

  (unsigned char) 0x01, (unsigned char) 0x00, (unsigned char) 0x03,
  (unsigned char) 0x55, (unsigned char) 0x04, (unsigned char) 0x0A,

  (unsigned char) 0x01, (unsigned char) 0x00, (unsigned char) 0x03,
  (unsigned char) 0x55, (unsigned char) 0x04, (unsigned char) 0x0B,

  (unsigned char) 0x01, (unsigned char) 0x00, (unsigned char) 0x03,
  (unsigned char) 0x55, (unsigned char) 0x04, (unsigned char) 0x0C,

  (unsigned char) 0x01, (unsigned char) 0x00, (unsigned char) 0x03,
  (unsigned char) 0x55, (unsigned char) 0x04, (unsigned char) 0x11,

  (unsigned char) 0x01, (unsigned char) 0x00, (unsigned char) 0x03,
  (unsigned char) 0x55, (unsigned char) 0x04, (unsigned char) 0x14,

  (unsigned char) 0x01, (unsigned char) 0x00, (unsigned char) 0x03,
  (unsigned char) 0x55, (unsigned char) 0x04, (unsigned char) 0x29,

  (unsigned char) 0x01, (unsigned char) 0x00, (unsigned char) 0x03,
  (unsigned char) 0x55, (unsigned char) 0x04, (unsigned char) 0x2A,

  (unsigned char) 0x01, (unsigned char) 0x00, (unsigned char) 0x03,
  (unsigned char) 0x55, (unsigned char) 0x04, (unsigned char) 0x2B,

  (unsigned char) 0x01, (unsigned char) 0x00, (unsigned char) 0x03,
  (unsigned char) 0x55, (unsigned char) 0x04, (unsigned char) 0x2C,

  (unsigned char) 0x01, (unsigned char) 0x00, (unsigned char) 0x03,
  (unsigned char) 0x55, (unsigned char) 0x04, (unsigned char) 0x2E,

  (unsigned char) 0x03, (unsigned char) 0x00, (unsigned char) 0x03,
  (unsigned char) 0x55, (unsigned char) 0x1D, (unsigned char) 0x09,

  (unsigned char) 0x03, (unsigned char) 0x00, (unsigned char) 0x03,
  (unsigned char) 0x55, (unsigned char) 0x1D, (unsigned char) 0x0E,

  (unsigned char) 0x03, (unsigned char) 0x00, (unsigned char) 0x03,
  (unsigned char) 0x55, (unsigned char) 0x1D, (unsigned char) 0x0F,

  (unsigned char) 0x03, (unsigned char) 0x00, (unsigned char) 0x03,
  (unsigned char) 0x55, (unsigned char) 0x1D, (unsigned char) 0x10,

  (unsigned char) 0x03, (unsigned char) 0x00, (unsigned char) 0x03,
  (unsigned char) 0x55, (unsigned char) 0x1D, (unsigned char) 0x11,

  (unsigned char) 0x03, (unsigned char) 0x00, (unsigned char) 0x03,
  (unsigned char) 0x55, (unsigned char) 0x1D, (unsigned char) 0x12,

  (unsigned char) 0x03, (unsigned char) 0x00, (unsigned char) 0x03,
  (unsigned char) 0x55, (unsigned char) 0x1D, (unsigned char) 0x13,

  (unsigned char) 0x03, (unsigned char) 0x00, (unsigned char) 0x03,
  (unsigned char) 0x55, (unsigned char) 0x1D, (unsigned char) 0x14,

  (unsigned char) 0x03, (unsigned char) 0x00, (unsigned char) 0x03,
  (unsigned char) 0x55, (unsigned char) 0x1D, (unsigned char) 0x15,

  (unsigned char) 0x03, (unsigned char) 0x00, (unsigned char) 0x03,
  (unsigned char) 0x55, (unsigned char) 0x1D, (unsigned char) 0x17,

  (unsigned char) 0x03, (unsigned char) 0x00, (unsigned char) 0x03,
  (unsigned char) 0x55, (unsigned char) 0x1D, (unsigned char) 0x18,

  (unsigned char) 0x03, (unsigned char) 0x00, (unsigned char) 0x03,
  (unsigned char) 0x55, (unsigned char) 0x1D, (unsigned char) 0x1B,

  (unsigned char) 0x03, (unsigned char) 0x00, (unsigned char) 0x03,
  (unsigned char) 0x55, (unsigned char) 0x1D, (unsigned char) 0x1C,

  (unsigned char) 0x03, (unsigned char) 0x00, (unsigned char) 0x03,
  (unsigned char) 0x55, (unsigned char) 0x1D, (unsigned char) 0x1D,

  (unsigned char) 0x03, (unsigned char) 0x00, (unsigned char) 0x03,
  (unsigned char) 0x55, (unsigned char) 0x1D, (unsigned char) 0x1E,

  (unsigned char) 0x03, (unsigned char) 0x00, (unsigned char) 0x03,
  (unsigned char) 0x55, (unsigned char) 0x1D, (unsigned char) 0x1F,

  (unsigned char) 0x03, (unsigned char) 0x00, (unsigned char) 0x03,
  (unsigned char) 0x55, (unsigned char) 0x1D, (unsigned char) 0x20,

  (unsigned char) 0x03, (unsigned char) 0x00, (unsigned char) 0x03,
  (unsigned char) 0x55, (unsigned char) 0x1D, (unsigned char) 0x21,

  (unsigned char) 0x03, (unsigned char) 0x00, (unsigned char) 0x03,
  (unsigned char) 0x55, (unsigned char) 0x1D, (unsigned char) 0x23,

  (unsigned char) 0x03, (unsigned char) 0x00, (unsigned char) 0x03,
  (unsigned char) 0x55, (unsigned char) 0x1D, (unsigned char) 0x24,

  (unsigned char) 0x03, (unsigned char) 0x00, (unsigned char) 0x03,
  (unsigned char) 0x55, (unsigned char) 0x1D, (unsigned char) 0x25,

  (unsigned char) 0x00, (unsigned char) 0x24, (unsigned char) 0x05,
  (unsigned char) 0x2B, (unsigned char) 0x0E, (unsigned char) 0x03, (unsigned char) 0x02,
  (unsigned char) 0x0C,

  (unsigned char) 0x00, (unsigned char) 0x08, (unsigned char) 0x05,
  (unsigned char) 0x2B, (unsigned char) 0x0E, (unsigned char) 0x03, (unsigned char) 0x02,
  (unsigned char) 0x0D,

  (unsigned char) 0x00, (unsigned char) 0x08, (unsigned char) 0x05,
  (unsigned char) 0x2B, (unsigned char) 0x0E, (unsigned char) 0x03, (unsigned char) 0x02,
  (unsigned char) 0x1A,

  (unsigned char) 0x00, (unsigned char) 0x08, (unsigned char) 0x05,
  (unsigned char) 0x2B, (unsigned char) 0x0E, (unsigned char) 0x03, (unsigned char) 0x02,
  (unsigned char) 0x1D,

  (unsigned char) 0x00, (unsigned char) 0x04, (unsigned char) 0x05,
  (unsigned char) 0x2B, (unsigned char) 0x24, (unsigned char) 0x03, (unsigned char) 0x02,
  (unsigned char) 0x01,

  (unsigned char) 0x00, (unsigned char) 0x08, (unsigned char) 0x06,
  (unsigned char) 0x2B, (unsigned char) 0x24, (unsigned char) 0x03, (unsigned char) 0x03,
  (unsigned char) 0x01, (unsigned char) 0x02,

  (unsigned char) 0x04, (unsigned char) 0x00, (unsigned char) 0x07,
  (unsigned char) 0x2A, (unsigned char) 0x86, (unsigned char) 0x48, (unsigned char) 0xCE,
  (unsigned char) 0x38, (unsigned char) 0x02, (unsigned char) 0x01,

  (unsigned char) 0x04, (unsigned char) 0x00, (unsigned char) 0x07,
  (unsigned char) 0x2A, (unsigned char) 0x86, (unsigned char) 0x48, (unsigned char) 0xCE,
  (unsigned char) 0x38, (unsigned char) 0x02, (unsigned char) 0x02,

  (unsigned char) 0x04, (unsigned char) 0x00, (unsigned char) 0x07,
  (unsigned char) 0x2A, (unsigned char) 0x86, (unsigned char) 0x48, (unsigned char) 0xCE,
  (unsigned char) 0x38, (unsigned char) 0x02, (unsigned char) 0x03,

  (unsigned char) 0x00, (unsigned char) 0x64, (unsigned char) 0x07,
  (unsigned char) 0x2A, (unsigned char) 0x86, (unsigned char) 0x48, (unsigned char) 0xCE,
  (unsigned char) 0x38, (unsigned char) 0x04, (unsigned char) 0x01,

  (unsigned char) 0x00, (unsigned char) 0x08, (unsigned char) 0x07,
  (unsigned char) 0x2A, (unsigned char) 0x86, (unsigned char) 0x48, (unsigned char) 0xCE,
  (unsigned char) 0x38, (unsigned char) 0x04, (unsigned char) 0x03,

  (unsigned char) 0x00, (unsigned char) 0x61, (unsigned char) 0x07,
  (unsigned char) 0x2A, (unsigned char) 0x86, (unsigned char) 0x48, (unsigned char) 0xCE,
  (unsigned char) 0x3E, (unsigned char) 0x02, (unsigned char) 0x01,

  (unsigned char) 0x00, (unsigned char) 0x04, (unsigned char) 0x08,
  (unsigned char) 0x60, (unsigned char) 0x86, (unsigned char) 0x48, (unsigned char) 0x01,
  (unsigned char) 0x65, (unsigned char) 0x03, (unsigned char) 0x04, (unsigned char) 0x02,

  (unsigned char) 0x03, (unsigned char) 0x00, (unsigned char) 0x08,
  (unsigned char) 0x2B, (unsigned char) 0x06, (unsigned char) 0x01, (unsigned char) 0x05,
  (unsigned char) 0x05, (unsigned char) 0x07, (unsigned char) 0x01, (unsigned char) 0x01,

  (unsigned char) 0x06, (unsigned char) 0x00, (unsigned char) 0x08,
  (unsigned char) 0x2B, (unsigned char) 0x06, (unsigned char) 0x01, (unsigned char) 0x05,
  (unsigned char) 0x05, (unsigned char) 0x07, (unsigned char) 0x03, (unsigned char) 0x01,

  (unsigned char) 0x06, (unsigned char) 0x00, (unsigned char) 0x08,
  (unsigned char) 0x2B, (unsigned char) 0x06, (unsigned char) 0x01, (unsigned char) 0x05,
  (unsigned char) 0x05, (unsigned char) 0x07, (unsigned char) 0x03, (unsigned char) 0x02,

  (unsigned char) 0x06, (unsigned char) 0x00, (unsigned char) 0x08,
  (unsigned char) 0x2B, (unsigned char) 0x06, (unsigned char) 0x01, (unsigned char) 0x05,
  (unsigned char) 0x05, (unsigned char) 0x07, (unsigned char) 0x03, (unsigned char) 0x03,

  (unsigned char) 0x06, (unsigned char) 0x00, (unsigned char) 0x08,
  (unsigned char) 0x2B, (unsigned char) 0x06, (unsigned char) 0x01, (unsigned char) 0x05,
  (unsigned char) 0x05, (unsigned char) 0x07, (unsigned char) 0x03, (unsigned char) 0x04,

  (unsigned char) 0x06, (unsigned char) 0x00, (unsigned char) 0x08,
  (unsigned char) 0x2B, (unsigned char) 0x06, (unsigned char) 0x01, (unsigned char) 0x05,
  (unsigned char) 0x05, (unsigned char) 0x07, (unsigned char) 0x03, (unsigned char) 0x05,

  (unsigned char) 0x06, (unsigned char) 0x00, (unsigned char) 0x08,
  (unsigned char) 0x2B, (unsigned char) 0x06, (unsigned char) 0x01, (unsigned char) 0x05,
  (unsigned char) 0x05, (unsigned char) 0x07, (unsigned char) 0x03, (unsigned char) 0x06,

  (unsigned char) 0x06, (unsigned char) 0x00, (unsigned char) 0x08,
  (unsigned char) 0x2B, (unsigned char) 0x06, (unsigned char) 0x01, (unsigned char) 0x05,
  (unsigned char) 0x05, (unsigned char) 0x07, (unsigned char) 0x03, (unsigned char) 0x07,

  (unsigned char) 0x06, (unsigned char) 0x00, (unsigned char) 0x08,
  (unsigned char) 0x2B, (unsigned char) 0x06, (unsigned char) 0x01, (unsigned char) 0x05,
  (unsigned char) 0x05, (unsigned char) 0x07, (unsigned char) 0x03, (unsigned char) 0x08,

  (unsigned char) 0x06, (unsigned char) 0x00, (unsigned char) 0x08,
  (unsigned char) 0x2B, (unsigned char) 0x06, (unsigned char) 0x01, (unsigned char) 0x05,
  (unsigned char) 0x05, (unsigned char) 0x07, (unsigned char) 0x03, (unsigned char) 0x09,

  (unsigned char) 0x06, (unsigned char) 0x00, (unsigned char) 0x08,
  (unsigned char) 0x2B, (unsigned char) 0x06, (unsigned char) 0x01, (unsigned char) 0x05,
  (unsigned char) 0x05, (unsigned char) 0x07, (unsigned char) 0x03, (unsigned char) 0x0A,

  (unsigned char) 0x06, (unsigned char) 0x00, (unsigned char) 0x08,
  (unsigned char) 0x2B, (unsigned char) 0x06, (unsigned char) 0x01, (unsigned char) 0x05,
  (unsigned char) 0x05, (unsigned char) 0x07, (unsigned char) 0x03, (unsigned char) 0x0D,

  (unsigned char) 0x06, (unsigned char) 0x00, (unsigned char) 0x08,
  (unsigned char) 0x2B, (unsigned char) 0x06, (unsigned char) 0x01, (unsigned char) 0x05,
  (unsigned char) 0x05, (unsigned char) 0x07, (unsigned char) 0x03, (unsigned char) 0x0E,

  (unsigned char) 0x06, (unsigned char) 0x00, (unsigned char) 0x08,
  (unsigned char) 0x2B, (unsigned char) 0x06, (unsigned char) 0x01, (unsigned char) 0x05,
  (unsigned char) 0x05, (unsigned char) 0x07, (unsigned char) 0x03, (unsigned char) 0x0F,

  (unsigned char) 0x06, (unsigned char) 0x00, (unsigned char) 0x08,
  (unsigned char) 0x2B, (unsigned char) 0x06, (unsigned char) 0x01, (unsigned char) 0x05,
  (unsigned char) 0x05, (unsigned char) 0x07, (unsigned char) 0x03, (unsigned char) 0x10,

  (unsigned char) 0x00, (unsigned char) 0x67, (unsigned char) 0x09,
  (unsigned char) 0x2A, (unsigned char) 0x86, (unsigned char) 0x48, (unsigned char) 0x86,
  (unsigned char) 0xF7, (unsigned char) 0x0D, (unsigned char) 0x01, (unsigned char) 0x01,
  (unsigned char) 0x01,

  (unsigned char) 0x00, (unsigned char) 0x08, (unsigned char) 0x09,
  (unsigned char) 0x2A, (unsigned char) 0x86, (unsigned char) 0x48, (unsigned char) 0x86,
  (unsigned char) 0xF7, (unsigned char) 0x0D, (unsigned char) 0x01, (unsigned char) 0x01,
  (unsigned char) 0x02,

  (unsigned char) 0x00, (unsigned char) 0x08, (unsigned char) 0x09,
  (unsigned char) 0x2A, (unsigned char) 0x86, (unsigned char) 0x48, (unsigned char) 0x86,
  (unsigned char) 0xF7, (unsigned char) 0x0D, (unsigned char) 0x01, (unsigned char) 0x01,
  (unsigned char) 0x04,

  (unsigned char) 0x00, (unsigned char) 0x08, (unsigned char) 0x09,
  (unsigned char) 0x2A, (unsigned char) 0x86, (unsigned char) 0x48, (unsigned char) 0x86,
  (unsigned char) 0xF7, (unsigned char) 0x0D, (unsigned char) 0x01, (unsigned char) 0x01,
  (unsigned char) 0x05,

  (unsigned char) 0x00, (unsigned char) 0x08, (unsigned char) 0x09,
  (unsigned char) 0x2A, (unsigned char) 0x86, (unsigned char) 0x48, (unsigned char) 0x86,
  (unsigned char) 0xF7, (unsigned char) 0x0D, (unsigned char) 0x01, (unsigned char) 0x01,
  (unsigned char) 0x0B,

  (unsigned char) 0x00, (unsigned char) 0x08, (unsigned char) 0x09,
  (unsigned char) 0x2A, (unsigned char) 0x86, (unsigned char) 0x48, (unsigned char) 0x86,
  (unsigned char) 0xF7, (unsigned char) 0x0D, (unsigned char) 0x01, (unsigned char) 0x01,
  (unsigned char) 0x0C,

  (unsigned char) 0x00, (unsigned char) 0x08, (unsigned char) 0x09,
  (unsigned char) 0x2A, (unsigned char) 0x86, (unsigned char) 0x48, (unsigned char) 0x86,
  (unsigned char) 0xF7, (unsigned char) 0x0D, (unsigned char) 0x01, (unsigned char) 0x01,
  (unsigned char) 0x0D,

  (unsigned char) 0x00, (unsigned char) 0x08, (unsigned char) 0x09,
  (unsigned char) 0x2A, (unsigned char) 0x86, (unsigned char) 0x48, (unsigned char) 0x86,
  (unsigned char) 0xF7, (unsigned char) 0x0D, (unsigned char) 0x01, (unsigned char) 0x01,
  (unsigned char) 0x0E,

  (unsigned char) 0x00, (unsigned char) 0x21, (unsigned char) 0x09,
  (unsigned char) 0x2A, (unsigned char) 0x86, (unsigned char) 0x48, (unsigned char) 0x86,
  (unsigned char) 0xF7, (unsigned char) 0x0D, (unsigned char) 0x01, (unsigned char) 0x03,
  (unsigned char) 0x01,

  (unsigned char) 0x00, (unsigned char) 0x10, (unsigned char) 0x09,
  (unsigned char) 0x2A, (unsigned char) 0x86, (unsigned char) 0x48, (unsigned char) 0x86,
  (unsigned char) 0xF7, (unsigned char) 0x0D, (unsigned char) 0x01, (unsigned char) 0x05,
  (unsigned char) 0x01,

  (unsigned char) 0x00, (unsigned char) 0x10, (unsigned char) 0x09,
  (unsigned char) 0x2A, (unsigned char) 0x86, (unsigned char) 0x48, (unsigned char) 0x86,
  (unsigned char) 0xF7, (unsigned char) 0x0D, (unsigned char) 0x01, (unsigned char) 0x05,
  (unsigned char) 0x03,

  (unsigned char) 0x00, (unsigned char) 0x10, (unsigned char) 0x09,
  (unsigned char) 0x2A, (unsigned char) 0x86, (unsigned char) 0x48, (unsigned char) 0x86,
  (unsigned char) 0xF7, (unsigned char) 0x0D, (unsigned char) 0x01, (unsigned char) 0x05,
  (unsigned char) 0x0A,

  (unsigned char) 0x05, (unsigned char) 0x00, (unsigned char) 0x09,
  (unsigned char) 0x2A, (unsigned char) 0x86, (unsigned char) 0x48, (unsigned char) 0x86,
  (unsigned char) 0xF7, (unsigned char) 0x0D, (unsigned char) 0x01, (unsigned char) 0x07,
  (unsigned char) 0x01,

  (unsigned char) 0x05, (unsigned char) 0x00, (unsigned char) 0x09,
  (unsigned char) 0x2A, (unsigned char) 0x86, (unsigned char) 0x48, (unsigned char) 0x86,
  (unsigned char) 0xF7, (unsigned char) 0x0D, (unsigned char) 0x01, (unsigned char) 0x07,
  (unsigned char) 0x02,

  (unsigned char) 0x02, (unsigned char) 0x00, (unsigned char) 0x09,
  (unsigned char) 0x2A, (unsigned char) 0x86, (unsigned char) 0x48, (unsigned char) 0x86,
  (unsigned char) 0xF7, (unsigned char) 0x0D, (unsigned char) 0x01, (unsigned char) 0x09,
  (unsigned char) 0x01,

  (unsigned char) 0x00, (unsigned char) 0x04, (unsigned char) 0x09,
  (unsigned char) 0x60, (unsigned char) 0x86, (unsigned char) 0x48, (unsigned char) 0x01,
  (unsigned char) 0x65, (unsigned char) 0x03, (unsigned char) 0x04, (unsigned char) 0x02,
  (unsigned char) 0x01,

  (unsigned char) 0x00, (unsigned char) 0x04, (unsigned char) 0x09,
  (unsigned char) 0x60, (unsigned char) 0x86, (unsigned char) 0x48, (unsigned char) 0x01,
  (unsigned char) 0x65, (unsigned char) 0x03, (unsigned char) 0x04, (unsigned char) 0x02,
  (unsigned char) 0x02,

  (unsigned char) 0x00, (unsigned char) 0x04, (unsigned char) 0x09,
  (unsigned char) 0x60, (unsigned char) 0x86, (unsigned char) 0x48, (unsigned char) 0x01,
  (unsigned char) 0x65, (unsigned char) 0x03, (unsigned char) 0x04, (unsigned char) 0x02,
  (unsigned char) 0x03,

  (unsigned char) 0x00, (unsigned char) 0x04, (unsigned char) 0x09,
  (unsigned char) 0x60, (unsigned char) 0x86, (unsigned char) 0x48, (unsigned char) 0x01,
  (unsigned char) 0x65, (unsigned char) 0x03, (unsigned char) 0x04, (unsigned char) 0x02,
  (unsigned char) 0x04,

  (unsigned char) 0x02, (unsigned char) 0x00, (unsigned char) 0x0A,
  (unsigned char) 0x09, (unsigned char) 0x92, (unsigned char) 0x26, (unsigned char) 0x89,
  (unsigned char) 0x93, (unsigned char) 0xF2, (unsigned char) 0x2C, (unsigned char) 0x64,
  (unsigned char) 0x01, (unsigned char) 0x19,
};

//-------------------------------------------
// OID Index Array 
//-------------------------------------------

int OID_Offset_Table[85] = {
      0,    6,   12,   18,
     24,   30,   36,   42,
     48,   54,   60,   66,
     72,   78,   84,   90,
     96,  102,  108,  114,
    120,  126,  132,  138,
    144,  150,  156,  162,
    168,  174,  180,  186,
    192,  198,  204,  210,
    216,  222,  230,  238,
    246,  254,  262,  271,
    281,  291,  301,  311,
    321,  331,  342,  353,
    364,  375,  386,  397,
    408,  419,  430,  441,
    452,  463,  474,  485,
    496,  507,  519,  531,
    543,  555,  567,  579,
    591,  603,  615,  627,
    639,  651,  663,  675,
    687,  699,  711,  723,
    735,
};

//-------------------------------------------
// Group Index Arrays 
//-------------------------------------------

int ALGOR_ID_IndexTab[26] = {
     37,   38,   39,   40,
     41,   42,   46,   47,
     48,   49,   65,   66,
     67,   68,   69,   70,
     71,   72,   73,   74,
     75,   76,   80,   81,
     82,   83,
};

int X520_ATT_IndexTab[16] = {
      0,    1,    2,    3,
      4,    5,    6,    7,
      8,    9,   10,   11,
     12,   13,   14,   15,
};

int X520_EXT_ATT_IndexTab[2] = {
     79,   84,
};

int X509_EXT_ATT_IndexTab[22] = {
     16,   17,   18,   19,
     20,   21,   22,   23,
     24,   25,   26,   27,
     28,   29,   30,   31,
     32,   33,   34,   35,
     36,   50,
};

int CRL_ENTRY_EXT_IndexTab[3] = {
     43,   44,   45,
};

int PKCS7_ATT_IndexTab[2] = {
     77,   78,
};

int PKIX_KEY_PURPOSE_IndexTab[14] = {
     51,   52,   53,   54,
     55,   56,   57,   58,
     59,   60,   61,   62,
     63,   64,
};

//-------------------------------------------
// Group Offset Arrays 
//-------------------------------------------

int ALGOR_ID_OffsetTab[26] = {
    222,  230,  238,  246,
    254,  262,  301,  311,
    321,  331,  507,  519,
    531,  543,  555,  567,
    579,  591,  603,  615,
    627,  639,  687,  699,
    711,  723,
};

int X520_ATT_OffsetTab[16] = {
      0,    6,   12,   18,
     24,   30,   36,   42,
     48,   54,   60,   66,
     72,   78,   84,   90,
};

int X520_EXT_ATT_OffsetTab[2] = {
    675,  735,
};

int X509_EXT_ATT_OffsetTab[22] = {
     96,  102,  108,  114,
    120,  126,  132,  138,
    144,  150,  156,  162,
    168,  174,  180,  186,
    192,  198,  204,  210,
    216,  342,
};

int CRL_ENTRY_EXT_OffsetTab[3] = {
    271,  281,  291,
};

int PKCS7_ATT_OffsetTab[2] = {
    651,  663,
};

int PKIX_KEY_PURPOSE_OffsetTab[14] = {
    353,  364,  375,  386,
    397,  408,  419,  430,
    441,  452,  463,  474,
    485,  496,
};

//-----------------------------------------------------------------------------
// This section was formerly included from hasn1ctl.hc
//-----------------------------------------------------------------------------

// Include-File for HASN1.C
// NOTE: Java portion is generated with CTRLSTR.C from the C-Arrays !
// -----

//================================================================
// ASN.1 Control structures used for conversion to and from
// internal data objects. Control entries have fixed length of 4
// bytes.
// NOTE: See documentation of Parser Control Structures (which does not
// ----- yet exist ...) before making changes !!!
//================================================================
/** @addtogroup asn1
* @{
* @file
* This 'header' contains the control structures, used for encoding and decoding
* ASN.1 certificates and containers.
* @}
*/
//----------------------------------------------------------------
// IBM Certificate Split/Combine Control Structure:
// from/to IBM Certificate <-> CertOrdinalNr., Certificate with/without
// private key, Issuer name, Flags, Optional data
// Used for Keyring databases and for Server Certificate List processing
//
//----------------------------------------------------------------
unsigned char IBMContainerCtl[IBM_CONTAINER_CTL_SIZE]={

						// L1 SEQ: IBM Container
 (unsigned char) (X_ONLY | CONSTRUCT),
 (unsigned char) (ASN1_UNIVERSAL_SEQUENCE | ASN1_CONSTRUCTED),
 (unsigned char) 0x00,
 (unsigned char) 0x00,
						// L2 INT; Ordinal number
						// DataIndex: 0
 (unsigned char) (X_FIRST | DATA_INDEX),
 (unsigned char) (ASN1_UNIVERSAL_INTEGER),
 (unsigned char) IBM_ORDINAL_INDEX,
 (unsigned char) 0x00,
						// L2 ETAG[0]: Certificate Req.
						// with private key
						// (DataIndex: 1,2)
 (unsigned char) (X_MIDDLE | CONSTRUCT | OPTIONAL | DATA_INDEX),
 (unsigned char)	(ASN1_CLASS_CONTEXT_SPECIFIC | ASN1_CONSTRUCTED | 0x00),
 (unsigned char) IBM_REQ_CERT_DATA_INDEX,		// check for build
 (unsigned char) 0x00,
						// L3 SEQ: Certreq./Key
 (unsigned char) (X_ONLY | CONSTRUCT),
 (unsigned char) (ASN1_UNIVERSAL_SEQUENCE | ASN1_CONSTRUCTED),
 (unsigned char) 0x00,
 (unsigned char) 0x00,
						// L4 ANY: Certificate Request
						// DataIndex: 1
 (unsigned char) (X_FIRST | DATA_INDEX | ANY_ASN1),
 (unsigned char) (ASN1_UNIVERSAL_EOC),
 (unsigned char) IBM_REQ_CERT_DATA_INDEX,
 (unsigned char) 0x00,
						// L4 SEQ: PrivKeyInfo
						// DataIndex: 4 (!)
 (unsigned char) (X_LAST | DATA_INDEX | ANY_ASN1),
 (unsigned char) (ASN1_UNIVERSAL_EOC),
 (unsigned char) IBM_PRIV_KEY_INFO_INDEX,
 (unsigned char) 0x00,
						// L2 ETAG[1]: Certificate
						// DataIndex: 2
 (unsigned char) (X_MIDDLE | CONSTRUCT | OPTIONAL | DATA_INDEX),
 (unsigned char)	(ASN1_CLASS_CONTEXT_SPECIFIC | ASN1_CONSTRUCTED | 0x01),
 (unsigned char) IBM_STD_CERT_DATA_INDEX,
 (unsigned char) 0x00,
						// L3 ANY: Certificate
						// DataIndex: 2
 (unsigned char) (X_ONLY | DATA_INDEX | ANY_ASN1),
 (unsigned char)	(ASN1_UNIVERSAL_EOC),
 (unsigned char) IBM_STD_CERT_DATA_INDEX,
 (unsigned char) 0x00,
						// L2 ETAG[2]: Cert with key
						// DataIndex: 3,4
 (unsigned char) (X_MIDDLE | CONSTRUCT | OPTIONAL | DATA_INDEX),
 (unsigned char)	(ASN1_CLASS_CONTEXT_SPECIFIC | ASN1_CONSTRUCTED | 0x02),
 (unsigned char) IBM_SPC_CERT_DATA_INDEX,		// check for build
 (unsigned char) 0x00,
						// L3 SEQ: Cert/Key
 (unsigned char) (X_ONLY | CONSTRUCT),
 (unsigned char) (ASN1_UNIVERSAL_SEQUENCE | ASN1_CONSTRUCTED),
 (unsigned char) 0x00,
 (unsigned char) 0x00,
						// L4 ANY: Certificate
						// DataIndex: 3
 (unsigned char) (X_FIRST | DATA_INDEX | ANY_ASN1),
 (unsigned char) (ASN1_UNIVERSAL_EOC),
 (unsigned char) IBM_SPC_CERT_DATA_INDEX,
 (unsigned char) 0x00,
						// L4 SEQ: PrivKeyInfo
						// DataIndex: 4
 (unsigned char) (X_LAST | DATA_INDEX | ANY_ASN1),
 (unsigned char) (ASN1_UNIVERSAL_EOC),
 (unsigned char) IBM_PRIV_KEY_INFO_INDEX,
 (unsigned char) 0x00,
						// L2 VISSTR: Container name
						// DataIndex: 5
 (unsigned char) (X_MIDDLE | DATA_INDEX | OPTIONAL),
 (unsigned char) (ASN1_UNIVERSAL_VISIBLESTR),
 (unsigned char) IBM_CONTAINER_NAME_INDEX,
 (unsigned char) 0x00,
						// L2: BITSTR: Flags 
						// DataIndex: 6
 (unsigned char) (X_MIDDLE | DATA_INDEX),
 (unsigned char) (ASN1_UNIVERSAL_BITSTRING),
 (unsigned char) IBM_FLAGS_INDEX,
 (unsigned char) 0x00,
						// L2: SEQ: unknown 
						// DataIndex: 7
 (unsigned char) (X_LAST | DATA_INDEX),
 (unsigned char) (ASN1_UNIVERSAL_SEQUENCE | ASN1_CONSTRUCTED),
 (unsigned char) IBM_UNKNOWN_INDEX,
 (unsigned char) 0x00,
};
//----------------------------------------------------------------
// X509 V3 Certificate Split/Combine Control Structure:
// from/to TBS Certificate, Signature Algorithm / Params and the
// Signature itsself.
// Used for Signature Verification / Signature appending.
// NOTE: The Verification Public Algorithm and Params come from the
// ----- next higher certificate in the chain if not self signed,
//	 in which case the root must be trusted and the
//	 parameters are included in the certificate itself !!
// NOT SPLIT/COMBINED ARE: Algorithm Params (type ANY)
// -----------------------
//----------------------------------------------------------------
unsigned char X509CertCtl[X509_CERT_CTL_SIZE]={

						// L1 SEQ: Certificate
 (unsigned char) (X_ONLY | CONSTRUCT),
 (unsigned char) (ASN1_UNIVERSAL_SEQUENCE | ASN1_CONSTRUCTED),
 (unsigned char) 0x00,
 (unsigned char) 0x00,
						// L2 SEQ: TBSCertificate
						// DataIndex: 0
 (unsigned char) (X_FIRST | DATA_INDEX | ANY_ASN1),
 (unsigned char) (ASN1_UNIVERSAL_EOC),
 (unsigned char) X509_TBS_CERT_INDEX,
 (unsigned char) 0x00,
						// L2 SEQ: Signature Algor
 (unsigned char) (X_MIDDLE | CONSTRUCT),
 (unsigned char) (ASN1_UNIVERSAL_SEQUENCE | ASN1_CONSTRUCTED),
 (unsigned char) 0x00,
 (unsigned char) 0x00,
						// L3 OBJID: Signat AlgorID
						// DataIndex: 1
 (unsigned char) (X_FIRST | DATA_INDEX),
 (unsigned char) (ASN1_UNIVERSAL_OBJECT_ID),
 (unsigned char) X509_VFY_SIGNAT_ALGOR_ID_INDEX,
 (unsigned char) 0x00,
						// L3 ANY: Signat Params
						// DataIndex: 2
 (unsigned char) (X_LAST | DATA_INDEX | ANY_ASN1 | OPTIONAL),
 (unsigned char) (ASN1_UNIVERSAL_EOC),
 (unsigned char) X509_VFY_SIGNAT_ALGOR_PAR_INDEX,
 (unsigned char) 0x00,
						// L2 BITSTR: Signature
						// DataIndex: 3
 (unsigned char) (X_LAST | DATA_INDEX | ZERO_LEAD_FLAG),
 (unsigned char) (ASN1_UNIVERSAL_BITSTRING),
 (unsigned char) X509_VFY_SIGNAT_DATA_INDEX,
 (unsigned char) 0x00,
};
//----------------------------------------------------------------
// X509 V3 TBS (To Be Signed) Certificate Split/Combine Control
// structure: form/to all structures found in TBS Certificate
// down to deepest possible level of knowledge from X509 V3 ASN.1
// Description including following optional fields:
//  - Version 		(ETAG [0], Integer, DEFAULT 0)
//  - Issuer  Unique ID (ITAG [1], Bitstring)
//  - Subject Unique ID (ITAG [2], Bitstring)
//  - Extensions        (ETAG [3], Sequence)
//
// NOT SPLIT/COMBINED ARE: Issuer name, Subject Name, Signature
// ----------------------- Algorithm Params, Public key Algorithm
//			   Params, Public Value and Extensions
//----------------------------------------------------------------
unsigned char X509_TBSCertCtl[X509_TBS_CERT_CTL_SIZE]={

						// L1 SEQ: TBSCertificate
 (unsigned char) (X_FIRST | CONSTRUCT),
 (unsigned char) (ASN1_UNIVERSAL_SEQUENCE | ASN1_CONSTRUCTED),
 (unsigned char) 0x00,
 (unsigned char) 0x00,
						// L2 ETAG: Version OPTIONAL
						// DataIndex: 0
 (unsigned char) (X_FIRST | CONSTRUCT | DATA_INDEX | OPTIONAL),
 (unsigned char)	(ASN1_CLASS_CONTEXT_SPECIFIC | ASN1_CONSTRUCTED | 0x00),
 (unsigned char) X509_VERSION_INDEX,
 (unsigned char) 0x00,
						// L3 INT: Version
						// DataIndex: 0
 (unsigned char) (X_ONLY | DATA_INDEX),
 (unsigned char) (ASN1_UNIVERSAL_INTEGER),
 (unsigned char) X509_VERSION_INDEX,
 (unsigned char) 0x00,
						// L2 INT: SerialNumber
						// DataIndex: 1
 (unsigned char) (X_MIDDLE | DATA_INDEX | ZERO_LEAD_FLAG),
 (unsigned char) (ASN1_UNIVERSAL_INTEGER),
 (unsigned char) X509_SERIAL_INDEX,
 (unsigned char) 0x00,
						// L2 SEQ: Signature Algor
 (unsigned char) (X_MIDDLE | CONSTRUCT),
 (unsigned char) (ASN1_UNIVERSAL_SEQUENCE | ASN1_CONSTRUCTED),
 (unsigned char) 0x00,
 (unsigned char) 0x00,
						// L3 OBJID: AlgorID
						// DataIndex: 2
 (unsigned char) (X_FIRST | DATA_INDEX),
 (unsigned char) (ASN1_UNIVERSAL_OBJECT_ID),
 (unsigned char) X509_SIGNAT_ALGOR_ID_INDEX,
 (unsigned char) 0x00,
						// L3 ANY: Algor Params
						// DataIndex: 3
 (unsigned char) (X_LAST | DATA_INDEX | ANY_ASN1 | OPTIONAL),
 (unsigned char) (ASN1_UNIVERSAL_EOC),
 (unsigned char) X509_SIGNAT_ALGOR_PAR_INDEX,
 (unsigned char) 0x00,
						// L2 SEQ: Issuer, WITH Header!
						// DataIndex: 4
 (unsigned char) (X_MIDDLE | DATA_INDEX | ANY_ASN1),
// (BYTE) (ASN1_UNIVERSAL_SEQUENCE | ASN1_CONSTRUCTED),
 (unsigned char) (ASN1_UNIVERSAL_EOC),
 (unsigned char) X509_ISSUER_NAME_INDEX,
 (unsigned char) 0x00,
						// L2 SEQ: Validity
 (unsigned char) (X_MIDDLE | CONSTRUCT),
 (unsigned char) (ASN1_UNIVERSAL_SEQUENCE | ASN1_CONSTRUCTED),
 (unsigned char) 0x00,
 (unsigned char) 0x00,
						// L3 ANY: notBefore
						// DataIndex: 5
 (unsigned char) (X_FIRST | DATA_INDEX | ANY_ASN1),
 (unsigned char) (ASN1_UNIVERSAL_EOC),
 (unsigned char) X509_NOT_BEFORE_INDEX,
 (unsigned char) 0x00,
						// L3 ANY: notAfter
						// DataIndex: 6
 (unsigned char) (X_LAST | DATA_INDEX | ANY_ASN1),
 (unsigned char) (ASN1_UNIVERSAL_EOC),
 (unsigned char) X509_NOT_AFTER_INDEX,
 (unsigned char) 0x00,
						// L2 SEQ: Subject
						// DataIndex: 7
 (unsigned char) (X_MIDDLE | DATA_INDEX | ANY_ASN1),
// (BYTE) (ASN1_UNIVERSAL_SEQUENCE | ASN1_CONSTRUCTED),
 (unsigned char) (ASN1_UNIVERSAL_EOC),
 (unsigned char) X509_SUBJECT_NAME_INDEX,
 (unsigned char) 0x00,
						// L2 SEQ: SubjectPublInfo
 (unsigned char) (X_MIDDLE | CONSTRUCT),
 (unsigned char) (ASN1_UNIVERSAL_SEQUENCE | ASN1_CONSTRUCTED),
 (unsigned char) 0x00,
 (unsigned char) 0x00,
						// L3 SEQ: Algorithm
 (unsigned char) (X_FIRST | CONSTRUCT),
 (unsigned char) (ASN1_UNIVERSAL_SEQUENCE | ASN1_CONSTRUCTED),
 (unsigned char) 0x00,
 (unsigned char) 0x00,

						// L4 OBJID: AlgorID
						// DataIndex: 8
 (unsigned char) (X_FIRST | DATA_INDEX),
 (unsigned char) (ASN1_UNIVERSAL_OBJECT_ID),
 (unsigned char) X509_PUBLIC_ALGOR_ID_INDEX,
 (unsigned char) 0x00,
						// L4 ANY: Algor Params
						// DataIndex: 9
 (unsigned char) (X_LAST | DATA_INDEX | ANY_ASN1 | OPTIONAL),
 (unsigned char) (ASN1_UNIVERSAL_EOC),
 (unsigned char) X509_PUBLIC_ALGOR_PAR_INDEX,
 (unsigned char) 0x00,
						// L3 BITSTR: Public Value Data
						// DataIndex: 10
 (unsigned char) (X_LAST | DATA_INDEX | ZERO_LEAD_FLAG),
 (unsigned char) (ASN1_UNIVERSAL_BITSTRING),
 (unsigned char) X509_PUBLIC_DATA_INDEX,
 (unsigned char) 0x00,
						// L2 ITAG Issuer ID
						// DataIndex: 11
 (unsigned char) (X_MIDDLE | DATA_INDEX | OPTIONAL | ZERO_LEAD_FLAG),
 (unsigned char)	(ASN1_CLASS_CONTEXT_SPECIFIC | 0x01),
 (unsigned char) X509_ISSUER_UNIQUE_ID_INDEX,
 (unsigned char) 0x00,
						// L2 ITAG Subject ID
						// DataIndex: 12
 (unsigned char) (X_MIDDLE | DATA_INDEX | OPTIONAL | ZERO_LEAD_FLAG),
 (unsigned char)	(ASN1_CLASS_CONTEXT_SPECIFIC | 0x02),
 (unsigned char) X509_SUBJECT_UNIQUE_ID_INDEX,
 (unsigned char) 0x00,
						// L1 ETAG: Extensions OPTIONAL
						// DataIndex: 13
 (unsigned char) (X_LAST | CONSTRUCT | DATA_INDEX | OPTIONAL),
 (unsigned char)	(ASN1_CLASS_CONTEXT_SPECIFIC | ASN1_CONSTRUCTED | 0x03),
 (unsigned char) X509_EXTENSION_DATA_INDEX,
 (unsigned char) 0x00,
						// L2 SEQ: Extensions
						// DataIndex: 13
 (unsigned char) (X_ONLY | DATA_INDEX),
 (unsigned char) (ASN1_UNIVERSAL_SEQUENCE | ASN1_CONSTRUCTED),
 (unsigned char) X509_EXTENSION_DATA_INDEX,
 (unsigned char) 0x00,
};
//----------------------------------------------------------------
// Relative Distinguished Name AVA Entry Control Structure
//----------------------------------------------------------------
static  unsigned char X501RdnAvaCtl[X501_RDN_AVA_CTL_SIZE]={
						// L1 SEQ: value, Object IDs
 (unsigned char) (X_ONLY | DATA_INDEX),
 (unsigned char) (ASN1_UNIVERSAL_SET | ASN1_CONSTRUCTED),
 (unsigned char) X501_RDN_AVA_INDEX,			// DataIndex: 0
 (unsigned char) 0x00,
};

//----------------------------------------------------------------
// Attribute Value Association Control Structure
//----------------------------------------------------------------
unsigned char X501AvaCtl[X501_AVA_CTL_SIZE]={
						// L1 SEQ: Attribute
 (unsigned char) (X_ONLY | CONSTRUCT),
 (unsigned char) (ASN1_UNIVERSAL_SEQUENCE | ASN1_CONSTRUCTED),
 (unsigned char) 0x00,
 (unsigned char) 0x00,
						// L2 OBJID: Type
						// DataIndex: 0
 (unsigned char) (X_FIRST | DATA_INDEX),
 (unsigned char) (ASN1_UNIVERSAL_OBJECT_ID),
 (unsigned char) X501_AVA_OBJID_INDEX,
 (unsigned char) 0x00,

						// L2 ANY: Value
						// DataIndex: 1
 (unsigned char) (X_LAST | DATA_INDEX | ANY_ASN1),
 (unsigned char) (ASN1_UNIVERSAL_EOC),
 (unsigned char) X501_AVA_VALUE_INDEX,
 (unsigned char) 0x00,
};

//----------------------------------------------------------------
// Extensions Entry Control Structure
//----------------------------------------------------------------
unsigned char X509ExtCtl[X509_EXT_CTL_SIZE]={

						// L1 SEQ: Extension
 (unsigned char) (X_ONLY | CONSTRUCT),
 (unsigned char) (ASN1_UNIVERSAL_SEQUENCE | ASN1_CONSTRUCTED),
 (unsigned char) 0x00,
 (unsigned char) 0x00,
						// L2 OBJID: ExtensionID
						// DataIndex: 0
 (unsigned char) (X_FIRST | DATA_INDEX),
 (unsigned char) (ASN1_UNIVERSAL_OBJECT_ID),
 (unsigned char) X509_EXT_OBJID_INDEX,
 (unsigned char) 0x00,
						// L2 BOOL: Critical
						// DataIndex: 1
 (unsigned char) (X_MIDDLE | DATA_INDEX | OPTIONAL),
 (unsigned char) (ASN1_UNIVERSAL_BOOLEAN),
 (unsigned char) X509_EXT_CRITICAL_INDEX,
 (unsigned char) 0x00,

						// L2 OCTETSTR: ExtnValue
						// DataIndex: 2
 (unsigned char) (X_LAST | DATA_INDEX),
 (unsigned char) (ASN1_UNIVERSAL_OCTETSTRING),
 (unsigned char) X509_EXT_VALUE_INDEX,
 (unsigned char) 0x00,
};
//----------------------------------------------------------------
// RSA Public Key Info/Signature Sub-Control Structures
//----------------------------------------------------------------
unsigned char RSA_AlgorParamsCtl[RSA_PUB_ALG_CTL_SIZE]={
						// L1 NULL: no params
 (unsigned char) (X_ONLY),
 (unsigned char) (ASN1_UNIVERSAL_NULL),
 (unsigned char) 0x00,
 (unsigned char) 0x00
};

unsigned char RSA_PublicValueCtl[RSA_PUB_VAL_CTL_SIZE]={
						// L1 SEQ: publicValue
 (unsigned char) (X_ONLY | CONSTRUCT),
 (unsigned char) (ASN1_UNIVERSAL_SEQUENCE | ASN1_CONSTRUCTED),
 (unsigned char) 0x00,
 (unsigned char) 0x00,
						// L2 INT: modulus n
						// DataIndex: 0
 (unsigned char) (X_FIRST | DATA_INDEX | ZERO_LEAD_FLAG),
 (unsigned char) (ASN1_UNIVERSAL_INTEGER),
 (unsigned char) RSA_PUB_VAL_MOD_INDEX,
 (unsigned char) 0x00,
						// L2 INT: publ. exp. e
						// DataIndex: 1
 (unsigned char) (X_LAST | DATA_INDEX | ZERO_LEAD_FLAG),
 (unsigned char) (ASN1_UNIVERSAL_INTEGER),
 (unsigned char) RSA_PUB_VAL_EXP_INDEX,
 (unsigned char) 0x00,
};

unsigned char RSA_SignatValueCtl[RSA_SIG_VAL_CTL_SIZE]={
						// L1 ANY: Pure Data
 (unsigned char) (X_ONLY | DATA_INDEX | ANY_ASN1),
 (unsigned char) (ASN1_UNIVERSAL_INTEGER),
 (unsigned char) RSA_SIG_VAL_INDEX,
 (unsigned char) 0x00,
};
//----------------------------------------------------------------
// Diffie Hellman Public Key Info Sub-Control Structures
//----------------------------------------------------------------
unsigned char DH_AlgorParamsCtl[DH_PUB_ALG_CTL_SIZE]={
						// L1 SEQ: params
 (unsigned char) (X_ONLY | CONSTRUCT),
 (unsigned char) (ASN1_UNIVERSAL_SEQUENCE | ASN1_CONSTRUCTED),
 (unsigned char) 0x00,
 (unsigned char) 0x00,
						// L2 INT: p
						// DataIndex: 0
 (unsigned char) (X_FIRST | DATA_INDEX | ZERO_LEAD_FLAG),
 (unsigned char) (ASN1_UNIVERSAL_INTEGER),
 (unsigned char) DH_ALG_PAR_P_INDEX,
 (unsigned char) 0x00,
						// L2 INT: g
						// DataIndex: 1
 (unsigned char) (X_MIDDLE | DATA_INDEX | ZERO_LEAD_FLAG),
 (unsigned char) (ASN1_UNIVERSAL_INTEGER),
 (unsigned char) DH_ALG_PAR_G_INDEX,
 (unsigned char) 0x00,
						// L2 INT: q
						// DataIndex: 2
 (unsigned char) (X_MIDDLE | DATA_INDEX | ZERO_LEAD_FLAG),
 (unsigned char) (ASN1_UNIVERSAL_INTEGER),
 (unsigned char) DH_ALG_PAR_Q_INDEX,
 (unsigned char) 0x00,
						// L2 INT: j
						// DataIndex: 3
 (unsigned char) (X_MIDDLE | DATA_INDEX | ZERO_LEAD_FLAG | OPTIONAL),
 (unsigned char) (ASN1_UNIVERSAL_INTEGER),
 (unsigned char) DH_ALG_PAR_J_INDEX,
 (unsigned char) 0x00,
						// L2 SEQ: validation params
						// if Seed present
 (unsigned char) (X_LAST | CONSTRUCT | OPTIONAL | DATA_INDEX),
 (unsigned char) (ASN1_UNIVERSAL_SEQUENCE | ASN1_CONSTRUCTED),
 (unsigned char) DH_ALG_PAR_SEED_INDEX,
 (unsigned char) 0x00,
						// L3 BITSTR: seed
						// DataIndex: 4
 (unsigned char) (X_FIRST | DATA_INDEX | OPTIONAL),
 (unsigned char) (ASN1_UNIVERSAL_BITSTRING),
 (unsigned char) DH_ALG_PAR_SEED_INDEX,
 (unsigned char) 0x00,
						// L3 INT: pgencounter
						// DataIndex: 5
 (unsigned char) (X_LAST | OPTIONAL | ZERO_LEAD_FLAG),
 (unsigned char) (ASN1_UNIVERSAL_INTEGER),
 (unsigned char) DH_ALG_PAR_PGCNT_INDEX,
 (unsigned char) 0x00
};

unsigned char DH_PublicValueCtl[DH_PUB_VAL_CTL_SIZE]={
						// L1 INT: publicValue y
						// DataIndex: 0
 (unsigned char) (X_ONLY | DATA_INDEX | ZERO_LEAD_FLAG),
 (unsigned char) (ASN1_UNIVERSAL_INTEGER),
 (unsigned char) DH_PUB_VAL_Y_INDEX,
 (unsigned char) 0x00
};
//----------------------------------------------------------------
// DSA Public Key Info/Signature Sub-Control Structures X9.57 !!
//----------------------------------------------------------------
unsigned char DSA_AlgorParamsCtl[DSA_PUB_ALG_CTL_SIZE]={
						// L1 SEQ: params
 (unsigned char) (X_ONLY | CONSTRUCT | OPTIONAL),
 (unsigned char) (ASN1_UNIVERSAL_SEQUENCE | ASN1_CONSTRUCTED),
 (unsigned char) 0x00,
 (unsigned char) 0x00,
						// L2 INT: p
						// DataIndex: 0
 (unsigned char) (X_FIRST | DATA_INDEX | ZERO_LEAD_FLAG),
 (unsigned char) (ASN1_UNIVERSAL_INTEGER),
 (unsigned char) DSA_ALG_PAR_P_INDEX,
 (unsigned char) 0x00,
						// L2 INT: Q
						// DataIndex: 1
 (unsigned char) (X_MIDDLE | DATA_INDEX | ZERO_LEAD_FLAG),
 (unsigned char) (ASN1_UNIVERSAL_INTEGER),
 (unsigned char) DSA_ALG_PAR_Q_INDEX,
 (unsigned char) 0x00,
						// L2 INT: g
						// DataIndex: 2
 (unsigned char) (X_LAST | DATA_INDEX | ZERO_LEAD_FLAG),
 (unsigned char) (ASN1_UNIVERSAL_INTEGER),
 (unsigned char) DSA_ALG_PAR_G_INDEX,
 (unsigned char) 0x00
};

unsigned char DSA_PublicValueCtl[DSA_PUB_VAL_CTL_SIZE]={
						// L1 INT: publicValue Y
						// DataIndex: 0
 (unsigned char) (X_ONLY | DATA_INDEX | ZERO_LEAD_FLAG),
 (unsigned char) (ASN1_UNIVERSAL_INTEGER),
 (unsigned char) DSA_PUB_VAL_Y_INDEX,
 (unsigned char) 0x00
};
//----------------------------------------------------------------
// OIW DSA Public Key Info/Signature Sub-Control Structures,
// different from X9.57: Params NULL, Params included in public value
//----------------------------------------------------------------
static  unsigned char OIW_DSA_AlgorParamsCtl[OIW_DSA_PUB_ALG_CTL_SIZE]={
						// L1 NULL: no params
 (unsigned char) (X_ONLY),
 (unsigned char) (ASN1_UNIVERSAL_NULL),
 (unsigned char) 0x00,
 (unsigned char) 0x00
};

static  unsigned char OIW_DSA_PublicValueCtl[OIW_DSA_PUB_VAL_CTL_SIZE]={
						// L1 SEQ: Params/Value
 (unsigned char) (X_ONLY | CONSTRUCT),
 (unsigned char) (ASN1_UNIVERSAL_SEQUENCE | ASN1_CONSTRUCTED),
 (unsigned char) 0x00,
 (unsigned char) 0x00,
						// L2 INT: p
						// DataIndex: 0
 (unsigned char) (X_FIRST | DATA_INDEX | ZERO_LEAD_FLAG | OPTIONAL),
 (unsigned char) (ASN1_UNIVERSAL_INTEGER),
 (unsigned char) DSA_ALG_PAR_P_INDEX,
 (unsigned char) 0x00,
						// L2 INT: Q
						// DataIndex: 1
 (unsigned char) (X_MIDDLE | DATA_INDEX | ZERO_LEAD_FLAG | OPTIONAL),
 (unsigned char) (ASN1_UNIVERSAL_INTEGER),
 (unsigned char) DSA_ALG_PAR_Q_INDEX,
 (unsigned char) 0x00,
						// L2 INT: g
						// DataIndex: 1
 (unsigned char) (X_MIDDLE | DATA_INDEX | ZERO_LEAD_FLAG | OPTIONAL),
 (unsigned char) (ASN1_UNIVERSAL_INTEGER),
 (unsigned char) DSA_ALG_PAR_G_INDEX,
 (unsigned char) 0x00,
						// L2 INT: y
						// DataIndex: 3
 (unsigned char) (X_LAST | DATA_INDEX | ZERO_LEAD_FLAG),
 (unsigned char) (ASN1_UNIVERSAL_INTEGER),
 (unsigned char) OIW_DSA_PUB_VAL_Y_INDEX,
 (unsigned char) 0x00
};
//----------------------------------------------------------------
// DSA Signature additional control structures
//----------------------------------------------------------------
static  unsigned char DSA_SignatAlgCtl[DSA_SIG_ALG_CTL_SIZE]={
						// L1 NULL: Parameters
 (unsigned char) (X_ONLY | OPTIONAL),
 (unsigned char) (ASN1_UNIVERSAL_NULL),
 (unsigned char) 0x00,
 (unsigned char) 0x00,
};

static  unsigned char DSA_SignatValueCtl[DSA_SIG_VAL_CTL_SIZE]={
						// L1 ANY: Pure Data
 (unsigned char) (X_ONLY | DATA_INDEX | ANY_ASN1),
 (unsigned char) (ASN1_UNIVERSAL_INTEGER),
 (unsigned char) DSA_SIG_VAL_INDEX,
 (unsigned char) 0x00,
};

//----------------------------------------------------------------
// PKCS8 Private Key Info Sub-Control Structure
//----------------------------------------------------------------
unsigned char PKCS8_PrivKeyInfoCtl[PKCS8_PRIV_KEY_INFO_CTL_SIZE]={

						// L1 SEQ: PrivKeyInfo
 (unsigned char) (X_ONLY | CONSTRUCT),
 (unsigned char) (ASN1_UNIVERSAL_SEQUENCE | ASN1_CONSTRUCTED),
 (unsigned char) 0x00,
 (unsigned char) 0x00,
						// L2 INT: Version
						// DataIndex: 0
 (unsigned char) (X_FIRST | DATA_INDEX),
 (unsigned char) (ASN1_UNIVERSAL_INTEGER),
 (unsigned char) PKCS8_VERSION_INDEX,
 (unsigned char) 0x00,
						// L2 SEQ: Algorithm
 (unsigned char) (X_MIDDLE | CONSTRUCT),
 (unsigned char) (ASN1_UNIVERSAL_SEQUENCE | ASN1_CONSTRUCTED),
 (unsigned char) 0x00,
 (unsigned char) 0x00,
						// L3 OID: Algorithm ID
						// DataIndex: 1
 (unsigned char) (X_FIRST | DATA_INDEX),
 (unsigned char) (ASN1_UNIVERSAL_OBJECT_ID),
 (unsigned char) PKCS8_KEY_ALGOR_INDEX,
 (unsigned char) 0x00,
						// L3 ANY: Algor Params
						// DataIndex: 2
 (unsigned char) (X_LAST | DATA_INDEX | ANY_ASN1),
 (unsigned char) (ASN1_UNIVERSAL_OBJECT_ID),
 (unsigned char) PKCS8_KEY_ALG_PAR_INDEX,
 (unsigned char) 0x00,
						// L2 OCTSTR: Private Key
						// DataIndex: 3
 (unsigned char) (X_LAST | DATA_INDEX),
 (unsigned char) (ASN1_UNIVERSAL_OCTETSTRING),
 (unsigned char) PKCS8_KEY_VALUE_INDEX,
 (unsigned char) 0x00,

};
//----------------------------------------------------------------
// PKCS-1 RSA Private Key Control Structure
//----------------------------------------------------------------
unsigned char RSA_PrivKeyCtl[RSA_PRIV_KEY_CTL_SIZE]={
						// L1 SEQ: RSA PrivKey
 (unsigned char) (X_ONLY | CONSTRUCT),
 (unsigned char) (ASN1_UNIVERSAL_SEQUENCE | ASN1_CONSTRUCTED),
 (unsigned char) 0x00,
 (unsigned char) 0x00,
						// L2 INT: Version
						// DataIndex: 8
 (unsigned char) (X_FIRST | DATA_INDEX | ZERO_LEAD_FLAG),
 (unsigned char) (ASN1_UNIVERSAL_INTEGER),
 (unsigned char) RSA_PRIV_KEY_VERSION_INDEX,
 (unsigned char) 0x00,
						// L2 INT: Modulus
						// DataIndex: 0
 (unsigned char) (X_MIDDLE | DATA_INDEX | ZERO_LEAD_FLAG),
 (unsigned char) (ASN1_UNIVERSAL_INTEGER),
 (unsigned char) RSA_PRIV_KEY_MODULUS_INDEX,
 (unsigned char) 0x00,
						// L2 INT: Public Exponent
						// DataIndex: 1
 (unsigned char) (X_MIDDLE | DATA_INDEX | ZERO_LEAD_FLAG),
 (unsigned char) (ASN1_UNIVERSAL_INTEGER),
 (unsigned char) RSA_PRIV_KEY_PUBL_EXP_INDEX,
 (unsigned char) 0x00,
						// L2 INT: Private Exponent
						// DataIndex: 2
 (unsigned char) (X_MIDDLE | DATA_INDEX | ZERO_LEAD_FLAG),
 (unsigned char) (ASN1_UNIVERSAL_INTEGER),
 (unsigned char) RSA_PRIV_KEY_PRIV_EXP_INDEX,
 (unsigned char) 0x00,
						// L2 INT: Prime p
						// DataIndex: 3
 (unsigned char) (X_MIDDLE | DATA_INDEX | ZERO_LEAD_FLAG),
 (unsigned char) (ASN1_UNIVERSAL_INTEGER),
 (unsigned char) RSA_PRIV_KEY_PRIME_P_INDEX,
 (unsigned char) 0x00,
						// L2 INT: Prime q
						// DataIndex: 4
 (unsigned char) (X_MIDDLE | DATA_INDEX | ZERO_LEAD_FLAG),
 (unsigned char) (ASN1_UNIVERSAL_INTEGER),
 (unsigned char) RSA_PRIV_KEY_PRIME_Q_INDEX,
 (unsigned char) 0x00,
						// L2 INT: Exp1
						// DataIndex: 5
 (unsigned char) (X_MIDDLE | DATA_INDEX | ZERO_LEAD_FLAG),
 (unsigned char) (ASN1_UNIVERSAL_INTEGER),
 (unsigned char) RSA_PRIV_KEY_EXP1_INDEX,
 (unsigned char) 0x00,
						// L2 INT: Exp2
						// DataIndex: 6
 (unsigned char) (X_MIDDLE | DATA_INDEX | ZERO_LEAD_FLAG),
 (unsigned char) (ASN1_UNIVERSAL_INTEGER),
 (unsigned char) RSA_PRIV_KEY_EXP2_INDEX,
 (unsigned char) 0x00,
						// L2 INT: Coefficient
						// DataIndex: 7
 (unsigned char) (X_LAST | DATA_INDEX | ZERO_LEAD_FLAG),
 (unsigned char) (ASN1_UNIVERSAL_INTEGER),
 (unsigned char) RSA_PRIV_KEY_COEFF_INDEX,
 (unsigned char) 0x00,
};
//----------------------------------------------------------------
// DSA Private Key Control Structure
//----------------------------------------------------------------
unsigned char DSA_PrivKeyCtl[DSA_PRIV_KEY_CTL_SIZE]={
						// L1 SEQ: DSA PrivKey
 (unsigned char) (X_ONLY | CONSTRUCT),
 (unsigned char) (ASN1_UNIVERSAL_SEQUENCE | ASN1_CONSTRUCTED),
 (unsigned char) 0x00,
 (unsigned char) 0x00,
						// L2 INT: Version
						// DataIndex: 2
 (unsigned char) (X_FIRST | DATA_INDEX | ZERO_LEAD_FLAG),
 (unsigned char) (ASN1_UNIVERSAL_INTEGER),
 (unsigned char) DSA_PRIV_KEY_VERSION_INDEX,
 (unsigned char) 0x00,
						// L2 INT: Puplic key y
						// DataIndex: 0
 (unsigned char) (X_MIDDLE | DATA_INDEX | ZERO_LEAD_FLAG),
 (unsigned char) (ASN1_UNIVERSAL_INTEGER),
 (unsigned char) DSA_PRIV_KEY_YKEY_INDEX,
 (unsigned char) 0x00,
						// L2 INT: Private key x
						// DataIndex: 1
 (unsigned char) (X_LAST | DATA_INDEX | ZERO_LEAD_FLAG),
 (unsigned char) (ASN1_UNIVERSAL_INTEGER),
 (unsigned char) DSA_PRIV_KEY_XKEY_INDEX,
 (unsigned char) 0x00,
};
//----------------------------------------------------------------
// X9.42 DH Private Key Control Structure
//----------------------------------------------------------------
unsigned char DH_PrivKeyCtl[DH_PRIV_KEY_CTL_SIZE]={
						// L1 SEQ: DH PrivKey
 (unsigned char) (X_ONLY | CONSTRUCT),
 (unsigned char) (ASN1_UNIVERSAL_SEQUENCE | ASN1_CONSTRUCTED),
 (unsigned char) 0x00,
 (unsigned char) 0x00,
						// L2 INT: Version
						// DataIndex: 2
 (unsigned char) (X_FIRST | DATA_INDEX | ZERO_LEAD_FLAG),
 (unsigned char) (ASN1_UNIVERSAL_INTEGER),
 (unsigned char) DH_PRIV_KEY_VERSION_INDEX,
 (unsigned char) 0x00,
						// L2 INT: Public value y
						// DataIndex: 0
 (unsigned char) (X_MIDDLE | DATA_INDEX | ZERO_LEAD_FLAG),
 (unsigned char) (ASN1_UNIVERSAL_INTEGER),
 (unsigned char) DH_PRIV_KEY_YKEY_INDEX,
 (unsigned char) 0x00,
						// L2 INT: Private value x
						// DataIndex: 1
 (unsigned char) (X_LAST | DATA_INDEX | ZERO_LEAD_FLAG),
 (unsigned char) (ASN1_UNIVERSAL_INTEGER),
 (unsigned char) DH_PRIV_KEY_XKEY_INDEX,
 (unsigned char) 0x00,
};
//================================================================
// Extensions Parser Control Structures
//================================================================

//----------------------------------------------------------------
// Authority key Identifier Control Structure IMPLICIT Tagged
//----------------------------------------------------------------
unsigned char AuthKeyIdExtCtl[AUTH_KEY_ID_CTL_SIZE]={

						// L1 SEQ: value
 (unsigned char) (X_ONLY | CONSTRUCT),
 (unsigned char) (ASN1_UNIVERSAL_SEQUENCE | ASN1_CONSTRUCTED),
 (unsigned char) 0x00,
 (unsigned char) 0x00,
						// L2 ITAG[0]: Key Identifier
						// implicit OCTESTSTRING
						// DataIndex: 0
 (unsigned char) (X_FIRST | DATA_INDEX | OPTIONAL),
 (unsigned char)	(ASN1_CLASS_CONTEXT_SPECIFIC | 0x00),
 (unsigned char) AUTH_KEY_ID_INDEX,
 (unsigned char) 0x00,

						// L2 ETAG[1]: Auth Cert Issuer
						// implicit SEQ: GeneralName
						// DataIndex: 1
 (unsigned char) (X_MIDDLE | DATA_INDEX | OPTIONAL ),
 (unsigned char)	(ASN1_CLASS_CONTEXT_SPECIFIC | ASN1_CONSTRUCTED | 0x01),
 (unsigned char) AUTH_CERT_ISSUER_INDEX,
 (unsigned char) 0x00,
						// L2 ITAG[2]: Auth Cert Serial
						// implicit INTEGER
						// DataIndex: 2
 (unsigned char) (X_LAST | DATA_INDEX | ZERO_LEAD_FLAG | OPTIONAL ),
 (unsigned char)	(ASN1_CLASS_CONTEXT_SPECIFIC | 0x02),
 (unsigned char) AUTH_SERIAL_INDEX,
 (unsigned char) 0x00,
};
//----------------------------------------------------------------
// Subject key Identifier Control Structure
//----------------------------------------------------------------
unsigned char SubjKeyIdExtCtl[SUBJ_KEY_ID_CTL_SIZE]={

						// L1 OCTET STRING: Key ID
						// DataIndex: 0
 (unsigned char) (X_ONLY | DATA_INDEX),
 (unsigned char) (ASN1_UNIVERSAL_OCTETSTRING),
 (unsigned char) SUBJ_KEY_ID_INDEX,
 (unsigned char) 0x00,
};
//----------------------------------------------------------------
// Key Usage Control Structure
//----------------------------------------------------------------
unsigned char KeyUsageExtCtl[KEY_USAGE_CTL_SIZE]={

						// L1 BIT-STRING: Flags
						// DataIndex: 0
 (unsigned char) (X_ONLY | DATA_INDEX),
 (unsigned char) (ASN1_UNIVERSAL_BITSTRING),
 (unsigned char) KEY_USAGE_INDEX,
 (unsigned char) 0x00,
};
//----------------------------------------------------------------
// Extended Key Usage Control Structure
//----------------------------------------------------------------
unsigned char ExtKeyUsageExtCtl[EXT_KEY_USAGE_CTL_SIZE]={

						// L1 SEQ: value, Object IDs
 (unsigned char) (X_ONLY | DATA_INDEX),
 (unsigned char) (ASN1_UNIVERSAL_SEQUENCE | ASN1_CONSTRUCTED),
 (unsigned char) EXT_KEY_USAGE_INDEX,
 (unsigned char) 0x00,
};
//----------------------------------------------------------------
// Extended Key Usage ObjectID split Control Structure
//----------------------------------------------------------------
unsigned char ObjIDSplitCtl[OBJID_SPLIT_CTL_SIZE]={

						// L1 OID
						// DataIndex: 0
 (unsigned char) (X_ONLY | DATA_INDEX),
 (unsigned char) (ASN1_UNIVERSAL_OBJECT_ID),
 (unsigned char) OID_SPLIT_INDEX,
 (unsigned char) 0x00,
};

//----------------------------------------------------------------
// Private Key Usage Period Control Structure IMPLICIT tagged
//----------------------------------------------------------------
unsigned char PrivKeyUsePeriodExtCtl[PRIV_KEY_USE_PERIOD_CTL_SIZE]={

						// L1 SEQ: value
 (unsigned char) (X_ONLY | CONSTRUCT),
 (unsigned char) (ASN1_UNIVERSAL_SEQUENCE | ASN1_CONSTRUCTED),
 (unsigned char) 0x00,
 (unsigned char) 0x00,
						// L2 ITAG[0]: not before
						// implicit GENERALIZED TIME
						// DataIndex: 0
 (unsigned char) (X_FIRST | DATA_INDEX | OPTIONAL),
 (unsigned char)	(ASN1_CLASS_CONTEXT_SPECIFIC | 0x00),
 (unsigned char) PRIV_KEY_USE_NOT_BEFORE_INDEX,
 (unsigned char) 0x00,
						// L2 ITAG[1]: not after
						// implicit GENERALIZED TIME
						// DataIndex: 1
 (unsigned char) (X_LAST | DATA_INDEX | OPTIONAL ),
 (unsigned char)	(ASN1_CLASS_CONTEXT_SPECIFIC | 0x01),
 (unsigned char) PRIV_KEY_USE_NOT_AFTER_INDEX,
 (unsigned char) 0x00,
};
//----------------------------------------------------------------
// Certificate Policies Control Structures
//----------------------------------------------------------------
unsigned char PoliciesExtCtl[POLICIES_CONTENT_CTL_SIZE]={

						// L1 ANY: value
						// DataIndex: 0
 (unsigned char) (X_ONLY | DATA_INDEX),
 (unsigned char) (ASN1_UNIVERSAL_SEQUENCE | ASN1_CONSTRUCTED),
 (unsigned char) POLICIES_CONTENT_INDEX,
 (unsigned char) 0x00,
};

unsigned char PolicyElementCtl[POLICY_ELEMENT_CTL_SIZE]={

						// L1 SEQ: value
 (unsigned char) (X_ONLY | CONSTRUCT),
 (unsigned char) (ASN1_UNIVERSAL_SEQUENCE | ASN1_CONSTRUCTED),
 (unsigned char) 0x00,
 (unsigned char) 0x00,
						// L2 OBJECT ID: Element ID
						// DataIndex: 0
 (unsigned char) (X_FIRST | DATA_INDEX),
 (unsigned char) (ASN1_UNIVERSAL_OBJECT_ID),
 (unsigned char) POLICY_ELEMENT_ID_INDEX,
 (unsigned char) 0x00,
						// L2 SEQ: Qualifiers, optional
						// DataIndex: 1
 (unsigned char) (X_LAST | DATA_INDEX | OPTIONAL),
 (unsigned char) (ASN1_UNIVERSAL_SEQUENCE | ASN1_CONSTRUCTED),
 (unsigned char) POLICY_ELEMENT_QUAL_INDEX,
 (unsigned char) 0x00,
};
//----------------------------------------------------------------
// Policies Mapping Control Structures
//----------------------------------------------------------------
unsigned char PolicyMapExtCtl[POLICY_MAP_CTL_SIZE]={

						// L1 SEQ: value
						// DataIndex: 0
 (unsigned char) (X_ONLY | DATA_INDEX),
 (unsigned char) (ASN1_UNIVERSAL_SEQUENCE | ASN1_CONSTRUCTED),
 (unsigned char) POLICIES_MAP_CONTENT_INDEX,
 (unsigned char) 0x00,
};

unsigned char PolicyMapElementCtl[POLICY_MAP_ELEMENT_CTL_SIZE]={

						// L1 SEQ: Policy MappingInfo
 (unsigned char) (X_ONLY | CONSTRUCT),
 (unsigned char) (ASN1_UNIVERSAL_SEQUENCE | ASN1_CONSTRUCTED),
 (unsigned char) 0x00,
 (unsigned char) 0x00,
						// L2 OBJECT ID:IssuerPolicy
						// DataIndex: 0
 (unsigned char) (X_FIRST | DATA_INDEX),
 (unsigned char) (ASN1_UNIVERSAL_OBJECT_ID),
 (unsigned char) ISSUER_DOMAIN_POLICY_ID_INDEX,
 (unsigned char) 0x00,
						// L2 OBJECT ID:SubjectPolicy
						// DataIndex: 1
 (unsigned char) (X_LAST | DATA_INDEX),
 (unsigned char) (ASN1_UNIVERSAL_OBJECT_ID),
 (unsigned char) SUBJECT_DOMAIN_POLICY_ID_INDEX,
 (unsigned char) 0x00,
};
//----------------------------------------------------------------
// Subject/Issuer Alternate Name Control Structures
//----------------------------------------------------------------
unsigned char AltNameExtCtl[ALT_NAME_CTL_SIZE]={

						// L1 SEQ: value
						// DataIndex: 0
 (unsigned char) (X_ONLY | DATA_INDEX),
 (unsigned char) (ASN1_UNIVERSAL_SEQUENCE | ASN1_CONSTRUCTED),
 (unsigned char) ALT_NAMES_CONTENT_INDEX,
 (unsigned char) 0x00,
};

// NOTE: GeneralName is implicit tagged !!
unsigned char GeneralName[GENERAL_NAME_CTL_SIZE]={

						// L1 ETAG[0]: OtherName
						// implicit SEQ
						// DataIndex: 0
 (unsigned char) (X_FIRST | DATA_INDEX | OPTIONAL),
 (unsigned char)	(ASN1_CLASS_CONTEXT_SPECIFIC | ASN1_CONSTRUCTED | 0x00),
 (unsigned char) OTHER_NAME_INDEX,
 (unsigned char) 0x00,
						// L1 ITAG[1]: RFC822 Name
						// implicit IA5STRING
						// DataIndex: 1
 (unsigned char) (X_MIDDLE | DATA_INDEX | OPTIONAL),
 (unsigned char)	(ASN1_CLASS_CONTEXT_SPECIFIC | 0x01),
 (unsigned char) RFC822_NAME_INDEX,
 (unsigned char) 0x00,
						// L1 ITAG[2]: DNS Name
						// implicit IA5STRING
						// DataIndex: 2
 (unsigned char) (X_MIDDLE | DATA_INDEX | OPTIONAL),
 (unsigned char)	(ASN1_CLASS_CONTEXT_SPECIFIC | 0x02),
 (unsigned char) DNS_NAME_INDEX,
 (unsigned char) 0x00,
						// L1 ETAG[3]: X400 Address
						// implicit SEQ???
						// DataIndex: 3
 (unsigned char) (X_MIDDLE | DATA_INDEX | OPTIONAL),
 (unsigned char)	(ASN1_CLASS_CONTEXT_SPECIFIC | ASN1_CONSTRUCTED | 0x03),
 (unsigned char) X400_NAME_INDEX,
 (unsigned char) 0x00,

						// L1 ETAG[4]: Directory Name
						// implicit SEQ: RDN
						// DataIndex: 4
 (unsigned char) (X_MIDDLE | DATA_INDEX | OPTIONAL),
 (unsigned char)	(ASN1_CLASS_CONTEXT_SPECIFIC | ASN1_CONSTRUCTED | 0x04),
 (unsigned char) GEN_RDN_NAME_INDEX,
 (unsigned char) 0x00,
						// L1 ETAG[5]: EDI Party Name
						// implicit SEQ
						// DataIndex: 5
 (unsigned char) (X_MIDDLE | DATA_INDEX | OPTIONAL),
 (unsigned char)	(ASN1_CLASS_CONTEXT_SPECIFIC | ASN1_CONSTRUCTED | 0x05),
 (unsigned char) EDI_PARTY_NAME_INDEX,
 (unsigned char) 0x00,
						// L1 ITAG[6]: URI Name
						// Implicit IA5STRING
						// DataIndex: 6
 (unsigned char) (X_MIDDLE | DATA_INDEX | OPTIONAL),
 (unsigned char)	(ASN1_CLASS_CONTEXT_SPECIFIC | 0x06),
 (unsigned char) URI_NAME_INDEX,
 (unsigned char) 0x00,
						// L1 ITAG[7]: IP Address
						// Implicit OCTETSTRING
						// DataIndex: 7
 (unsigned char) (X_MIDDLE | DATA_INDEX | OPTIONAL),
 (unsigned char)	(ASN1_CLASS_CONTEXT_SPECIFIC | 0x07),
 (unsigned char) IP_ADR_NAME_INDEX,
 (unsigned char) 0x00,
						// L1 ITAG[8]: registered ID
						// Implicit OBJECTID
						// DataIndex: 8
 (unsigned char) (X_LAST | DATA_INDEX | OPTIONAL),
 (unsigned char)	(ASN1_CLASS_CONTEXT_SPECIFIC | 0x08),
 (unsigned char) REGISTERED_NAME_INDEX,
 (unsigned char) 0x00,
};
//----------------------------------------------------------------
// Basic Constraints Control Structures
//----------------------------------------------------------------
unsigned char BasicConstraintsExtCtl[BASIC_CONSTRAINTS_CTL_SIZE]={

						// L1 SEQ: values
 (unsigned char) (X_ONLY | CONSTRUCT),
 (unsigned char) (ASN1_UNIVERSAL_SEQUENCE | ASN1_CONSTRUCTED),
 (unsigned char) 0x00,
 (unsigned char) 0x00,
						// L2 BOOL: CA-Flag
						// DataIndex: 0
 (unsigned char) (X_FIRST | DATA_INDEX | OPTIONAL),
 (unsigned char) (ASN1_UNIVERSAL_BOOLEAN),
 (unsigned char) CA_FLAG_INDEX,
 (unsigned char) 0x00,
						// L2 INTEGER: Pathlen Constr.
						// DataIndex: 1
 (unsigned char) (X_LAST | DATA_INDEX | OPTIONAL),
 (unsigned char) (ASN1_UNIVERSAL_INTEGER),
 (unsigned char) PATHLEN_CONSTR_INDEX,
 (unsigned char) 0x00,
};
//----------------------------------------------------------------
// Name Constraints Control Structures, IMPLICIT tagged
//----------------------------------------------------------------
unsigned char NameConstraintsExtCtl[NAME_CONSTRAINTS_CTL_SIZE]={

						// L1 SEQ: values
 (unsigned char) (X_ONLY | CONSTRUCT),
 (unsigned char) (ASN1_UNIVERSAL_SEQUENCE | ASN1_CONSTRUCTED),
 (unsigned char) 0x00,
 (unsigned char) 0x00,
						// L2 ETAG[0]: permitted SubTr.
						// implicit SEQ
						// DataIndex: 0
 (unsigned char) (X_FIRST | DATA_INDEX | OPTIONAL),
 (unsigned char)	(ASN1_CLASS_CONTEXT_SPECIFIC | ASN1_CONSTRUCTED | 0x00),
 (unsigned char) PERMITTED_SUBTREE_INDEX,
 (unsigned char) 0x00,
						// L2 ETAG[1]: excluded SubTr.
						// implicit SEQ
						// DataIndex: 1
 (unsigned char) (X_LAST | DATA_INDEX | OPTIONAL),
 (unsigned char)	(ASN1_CLASS_CONTEXT_SPECIFIC | ASN1_CONSTRUCTED | 0x01),
 (unsigned char) EXCLUDED_SUBTREE_INDEX,
 (unsigned char) 0x00,
};

// Note: GeneralSubtree is IMPLICIT tagged

unsigned char GeneralSubtreeExtCtl[GENERAL_SUBTREE_CTL_SIZE]={

						// L1 SEQ: values
 (unsigned char) (X_ONLY | CONSTRUCT),
 (unsigned char) (ASN1_UNIVERSAL_SEQUENCE | ASN1_CONSTRUCTED),
 (unsigned char) 0x00,
 (unsigned char) 0x00,
						// L2 ANY ASN1: base name
						// DataIndex: 0
 (unsigned char) (X_FIRST | DATA_INDEX | ANY_ASN1),
 (unsigned char)	(ASN1_UNIVERSAL_EOC),
 (unsigned char) BASE_NAME_INDEX,
 (unsigned char) 0x00,
						// L2 ITAG[0]: min. base dist.
						// implicit INTEGER
						// DataIndex: 1
 (unsigned char) (X_MIDDLE | DATA_INDEX | ZERO_LEAD_FLAG | OPTIONAL),
 (unsigned char)	(ASN1_CLASS_CONTEXT_SPECIFIC | 0x00),
 (unsigned char) MIN_BASE_DIST_INDEX,
 (unsigned char) 0x00,
						// L2 ITAG[1]: max. base dist.
						// implicit INTEGER
						// DataIndex: 2
 (unsigned char) (X_LAST | DATA_INDEX | ZERO_LEAD_FLAG | OPTIONAL),
 (unsigned char)	(ASN1_CLASS_CONTEXT_SPECIFIC | 0x01),
 (unsigned char) MAX_BASE_DIST_INDEX,
 (unsigned char) 0x00,
};
//----------------------------------------------------------------
// Policy Constraints Control Structures IMPLICIT tagged
//----------------------------------------------------------------
unsigned char PolicyConstraintsExtCtl[POLICY_CONSTRAINTS_CTL_SIZE]={

						// L1 SEQ: values
 (unsigned char) (X_ONLY | CONSTRUCT),
 (unsigned char) (ASN1_UNIVERSAL_SEQUENCE | ASN1_CONSTRUCTED),
 (unsigned char) 0x00,
 (unsigned char) 0x00,
						// L2 ITAG[0]: req. skip
						// implicit INTEGER
						// DataIndex: 0
 (unsigned char) (X_FIRST | DATA_INDEX | ZERO_LEAD_FLAG | OPTIONAL),
 (unsigned char)	(ASN1_CLASS_CONTEXT_SPECIFIC | 0x00),
 (unsigned char) REQ_EXPL_POLICY_SKIP_INDEX,
 (unsigned char) 0x00,
						// L2 ITAG[1]: inh. skip
						// implicit INTEGER
						// DataIndex: 1
 (unsigned char) (X_LAST | DATA_INDEX | ZERO_LEAD_FLAG | OPTIONAL),
 (unsigned char)	(ASN1_CLASS_CONTEXT_SPECIFIC | 0x01),
 (unsigned char) INH_POLICY_MAP_SKIP_INDEX,
 (unsigned char) 0x00,
};
//----------------------------------------------------------------
// CRL distribution points Control Structures
//----------------------------------------------------------------
unsigned char CRLDistrPointsExtCtl[CRL_DIST_POINTS_CTL_SIZE]={

						// L1 SEQ: values
						// DataIndex: 0
 (unsigned char) (X_ONLY | DATA_INDEX),
 (unsigned char) (ASN1_UNIVERSAL_SEQUENCE | ASN1_CONSTRUCTED),
 (unsigned char) DIST_POINTS_INDEX,
 (unsigned char) 0x00,
};

// Note: DistributionPoint is IMPLICIT tagged
unsigned char CRLDistrPointCtl[CRL_DIST_POINT_CTL_SIZE]={

						// L1 SEQ
 (unsigned char) (X_ONLY | CONSTRUCT),
 (unsigned char) (ASN1_UNIVERSAL_SEQUENCE | ASN1_CONSTRUCTED),
 (unsigned char) 0x00,
 (unsigned char) 0x00,
						// L2 ETAG[0]: Dist Point Name
						// implicit SEQ
						// DataIndex: 0
 (unsigned char) (X_FIRST | DATA_INDEX | OPTIONAL),
 (unsigned char)	(ASN1_CLASS_CONTEXT_SPECIFIC | ASN1_CONSTRUCTED | 0x00),
 (unsigned char) CRL_DIST_POINT_NAME_INDEX,
 (unsigned char) 0x00,
						// L2 ITAG[1]: Reason Flags
						// implicit BITSTRING
						// DataIndex: 1
 (unsigned char) (X_MIDDLE | DATA_INDEX | OPTIONAL),
 (unsigned char)	(ASN1_CLASS_CONTEXT_SPECIFIC | 0x01),
 (unsigned char) CRL_REASONS_INDEX,
 (unsigned char) 0x00,
						// L2 ETAG[2]: CRL Issuer
						// implicit SEQ
						// DataIndex: 2
 (unsigned char) (X_LAST | DATA_INDEX | OPTIONAL),
 (unsigned char)	(ASN1_CLASS_CONTEXT_SPECIFIC | ASN1_CONSTRUCTED | 0x02),
 (unsigned char) CRL_ISSUER_NAME_INDEX,
 (unsigned char) 0x00,
};

// NOTE: implicit tagged
unsigned char DistPointNameCtl[DIST_POINT_NAME_CTL_SIZE]={

						// L1 ETAG[0]: GeneralName
						// implicit SEQ
						// Data Index: 0
 (unsigned char) (X_FIRST | DATA_INDEX),
 (unsigned char)	(ASN1_CLASS_CONTEXT_SPECIFIC | ASN1_CONSTRUCTED | 0x00),
 (unsigned char) DIST_POINT_GEN_NAME_INDEX,
 (unsigned char) 0x00,

						// L1 ETAG[1]: RDN
						// implicit SEQ
 (unsigned char) (X_LAST | DATA_INDEX),
 (unsigned char)	(ASN1_CLASS_CONTEXT_SPECIFIC | ASN1_CONSTRUCTED | 0x01),
 (unsigned char) DIST_POINT_RDN_NAME_INDEX,
 (unsigned char) 0x00,
};

//----------------------------------------------------------------
// Common Sequence unwrapping/wrapping Control Structure
//----------------------------------------------------------------
static  unsigned char SequenceWrapCtl[SEQ_WRAP_CTL_SIZE]={

						// L1 SEQ: Any Data
						// DataIndex: 0
 (unsigned char) (X_ONLY | DATA_INDEX),
 (unsigned char) (ASN1_UNIVERSAL_SEQUENCE | ASN1_CONSTRUCTED),
 (unsigned char) SEQ_WRAP_INDEX,
 (unsigned char) 0x00,
};
//************************************************************
//------------------------------------------------------
// RDN OID Construction / Decomposition Index Array
// NOTE: Must match Index Definitions from HASNSTRU.h !!
//------------------------------------------------------
char RDN_OidIndexArray[GRP_X520_ATT_CNT+ GRP_X520_EXT_ATT_CNT] = {
	OID_X520_COUNTRY_NAME,			// 55 04 06
	OID_X520_LOCALITY_NAME,			// 55 04 07
	OID_X520_STATE_OR_PROVINCE_NAME,	// 55 04 08
	OID_X520_STREET_ADDRESS,		// 55 04 09
	OID_X520_ORGANIZATION_NAME,		// 55 04 0A
	OID_X520_ORGANIZATION_UNIT_NAME,	// 55 04 0B
	OID_X520_TITLE,				// 55 04 0C
	OID_X520_POSTAL_CODE,			// 55 04 11
	OID_X520_PHONE_NUMBER,			// 55 04 14
	OID_X520_NAME,				// 55 04 29
	OID_X520_COMMON_NAME,			// 55 04 03
	OID_X520_SURNAME,			// 55 04 04
	OID_X520_GIVEN_NAME,			// 55 04 2A
	OID_X520_INITIALS,			// 55 04 2B
	OID_X520_GENERATION_QUALIFIER,		// 55 04 2C
	OID_X520_DIST_NAME_QUALIFIER,		// 55 04 2E
	OID_PKCS9_EMAIL_ADDRESS,		// PKCS9-Att.
	OID_MICROSOFT_DOMAIN_COMPONENT,		// Microsoft-Att.
};

//------------------------------------------------------------------
// Helper array for checking valid day number upper limits per month.
// NOTE: february has maximum of 29 days, further checks required !
// -----
//------------------------------------------------------------------
 int MaxDaysOfMonth[12] = {31,29,31,30,31,30,31,31,30,31,30,31};

/** @addtogroup asn1
* @{
*/

extern "C"  void FreeIDATA_Array(HMEM_CTX_DEF
				        IDATA** DatArray,
				        int ElementCount,
					int FreeFlags)
{
  int i;
  int FreeFlag,ClearFlag;
  IDATA* pIdata;
  //---------------------------------------------
  // Check for Base NULL pointer first, then for
  // zero entry count
  //---------------------------------------------
  if(DatArray == NULL)
    return;
  if(ElementCount != 0)
  {
    FreeFlag  = FreeFlags & FREE_BIT_MASK;
    ClearFlag = FreeFlags & FREE_CLEAR_BIT_MASK;
    i=ElementCount;
    do
    {
      i--;
      pIdata = DatArray[i];
      if(pIdata != NULL)
      {
        if((pIdata->Base != NULL) && (FreeFlag != 0))
        {
          if(ClearFlag != 0)
          {
            ClearBit8Array(pIdata->Base,
			   (int) pIdata->Off,
			   (int) pIdata->Len);
          }
          FREE_CARRAY(HMEM_CTX_REF,pIdata->Base);
        }        
        FREE_CARRAY(HMEM_CTX_REF,pIdata);
      }
    }while(i != 0);
  }
  FREE_CARRAY(HMEM_CTX_REF,DatArray);
}

extern "C"  int AllocIDATA_Array(HMEM_CTX_DEF
	IDATA*** pDatArray, int ElementCount)
{
  int i;
  int Index;
  IDATA** DatArray;
//  IDATA_PTR pIdata;

  pDatArray[0] = NULL;			// set invalid
  if(ElementCount <= 0) return(ASN1_IDATA_ALLOC_PARAMERR);
  //------------------------------------------
  // 1. Allocate the Array itsself, clear it
  //------------------------------------------
  DatArray = (IDATA **)
	      ((void *) BIT8_ARRAY_CALLOC(HMEM_CTX_REF,
				          ElementCount,sizeof(IDATA *)));
  //------------------------------------------
  // 2. Allocate the Entries and clear them
  //------------------------------------------
  i = ElementCount;
  Index = 0;
  do
  {
    DatArray[Index] = (IDATA *)
	((void *) BIT8_ARRAY_CALLOC(HMEM_CTX_REF, 1,sizeof(IDATA)));
    if(DatArray[Index] == NULL)
      break;

    Index++;
    i--;
  }while(i != 0);
  if(i != 0)
  {
    FreeIDATA_Array(HMEM_CTX_REF1
		    DatArray,ElementCount,0);
    DatArray = NULL;
    return(ASN1_IDATA_ALLOC_ALLOC_ERR);
  }
  pDatArray[0] = DatArray;
  return(ASN1_OP_OK);
}

extern "C"  void FreeIDATPARR_Struc(HMEM_CTX_DEF
			IDATPARR* DatArrayDesc)
{
  int ElementCount;
  int FreeFlags;
  IDATA** pDatArray;
  //---------------------------------------------
  // Check for Base NULL pointer first, then for
  // zero entry count
  //---------------------------------------------
  if(DatArrayDesc == NULL) return;		// no descriptor
  pDatArray     = DatArrayDesc->ppArr;
  ElementCount  = DatArrayDesc->Cnt;
  FreeFlags     = DatArrayDesc->Flags &
			(FREE_BIT_MASK | FREE_CLEAR_BIT_MASK);
  if(pDatArray == NULL)			// no elements anyway
  {
     FREE_ARRAY(HMEM_CTX_REF,DatArrayDesc);	// was missing !
     return;
  }
  FreeIDATA_Array(HMEM_CTX_REF1
		  pDatArray, ElementCount, FreeFlags);
  DatArrayDesc->Cnt = 0;
  DatArrayDesc->ppArr = NULL;
  FREE_ARRAY(HMEM_CTX_REF,DatArrayDesc);
}

extern "C"  int AllocIDATPARR_Struc(HMEM_CTX_DEF
	IDATPARR** pDatArrayDesc, int ElementCount)
{
  int i;
  int Index;
  int Retcode;

  IDATPARR* TmpDatArrayDesc;
  IDATA** DatArray = NULL;
//  IDATA_PTR pIdata;

  pDatArrayDesc[0] = NULL;			// set invalid
  for(;;)					// Error FOR
  {
    Retcode = ASN1_IDATA_ALLOC_ALLOC_ERR;	// assume error
    //-----------------------------------------------
    // 1. Allocate the Descriptor structure, clear it
    //-----------------------------------------------
    TmpDatArrayDesc = (IDATPARR *)
	((void *) BIT8_ARRAY_CALLOC(HMEM_CTX_REF,1,sizeof(IDATPARR)));
    if(TmpDatArrayDesc == NULL)
      break;

    if(ElementCount <= 0)
    {
      pDatArrayDesc[0] = TmpDatArrayDesc;
      return(ASN1_OP_OK);
    }
    //---------------------------------------------------
    // 2. Allocate the Pointer Array itsself, clear, init
    //---------------------------------------------------
    DatArray = (IDATA**)
	((void *) BIT8_ARRAY_CALLOC(HMEM_CTX_REF,
				    ElementCount,sizeof(IDATA *)));
    if(DatArray == NULL)
      break;

    TmpDatArrayDesc->Cnt   = ElementCount;
    TmpDatArrayDesc->ppArr = DatArray;
    //------------------------------------------
    // 3. Allocate the Entries and clear
    //------------------------------------------
    i = ElementCount;
    Index = 0;
    do
    {
      DatArray[Index] = (IDATA *)
	((void *) BIT8_ARRAY_CALLOC(HMEM_CTX_REF,1,sizeof(IDATA)));
      if(DatArray[Index] == NULL)
        break;
      Index++;
      i--;
    }while(i != 0);
    if(i == 0) Retcode = ASN1_OP_OK;
    break;
  } // Error FOR
  pDatArrayDesc[0] = TmpDatArrayDesc;
  if(Retcode == ASN1_OP_OK) return(Retcode);
  FreeIDATPARR_Struc(HMEM_CTX_REF1 TmpDatArrayDesc);
  pDatArrayDesc[0] = NULL;
  return(Retcode);
}

extern "C"  int EnlargeIDATPARR_Struc(HMEM_CTX_DEF
	IDATPARR* DatArrayDesc, int NewElementCount)
{
//  int Retcode;
  int Index, ActCnt;

  IDATA** NewDatArray = NULL;
  IDATA** OldDatArray = NULL;
  //--------------------------------------------------------------
  // Check parameters
  //--------------------------------------------------------------
  if(DatArrayDesc == NULL)
    return(ASN1_NULL_PTR);
  if(NewElementCount <= 0)
    return(ASN1_PARAM_ERR);

  ActCnt = DatArrayDesc->Cnt;
  if(ActCnt >= NewElementCount)
    return(ASN1_OP_OK);
  //---------------------------------------------------------
  // Must increase the IDATA Array,
  // 1. Allocate a new Pointer Array, clear it
  //---------------------------------------------------------
  NewDatArray = (IDATA**)
    ((void *) BIT8_ARRAY_CALLOC(HMEM_CTX_REF,
			        1,NewElementCount*sizeof(IDATA *)));
  if(NewDatArray == NULL)
    return(ASN1_ALLOC_ERR);

  //------------------------------------------------------------
  // 2. Copy Elements from old array to new one, if one exists !
  //------------------------------------------------------------
  Index = 0;
  OldDatArray = DatArrayDesc->ppArr;
  if(OldDatArray != NULL)
  {
    while(Index < ActCnt)
    {
      NewDatArray[Index] = OldDatArray[Index];
      Index++;
    }      
  }
  //------------------------------------------------------------
  // 3. Set the new elements count, free old array
  //------------------------------------------------------------
  FREE_ARRAY(HMEM_CTX_REF,OldDatArray);
  DatArrayDesc->ppArr = NewDatArray;
  DatArrayDesc->Cnt   = NewElementCount;

//  Retcode = ASN1_IDATA_ALLOC_ALLOC_ERR;		// assume error

  //------------------------------------------
  // 4. Allocate the new Entries and init
  //------------------------------------------
  while(Index < NewElementCount)
  {
    NewDatArray[Index] = (IDATA *)
	((void *) BIT8_ARRAY_CALLOC(HMEM_CTX_REF,1,sizeof(IDATA)));
    if(NewDatArray[Index] == NULL)
      return(ASN1_IDATA_ALLOC_ALLOC_ERR);

    Index++;
  }
  return(ASN1_OP_OK);
}

extern "C"  void FreeX501DN_Struc(HMEM_CTX_DEF
					 X501_DN* pNameStruc)
{
  int RDNCount, Index;

  IDATPARR** ppRDNArr;
  //---------------------------------------------
  // Check for Base NULL pointer first, then for
  // zero entry count
  //---------------------------------------------
  if(pNameStruc == NULL)			// no descriptor
    return;

  RDNCount = pNameStruc->Cnt;		// number of RDNs
  ppRDNArr = pNameStruc->ppArr;		// Array of structures
  if(ppRDNArr == NULL)
  {
    FREE_ARRAY(HMEM_CTX_REF,pNameStruc);
    return;
  }
  Index = 0;
  while(Index < RDNCount)
  {
    FreeIDATPARR_Struc(HMEM_CTX_REF1 ppRDNArr[Index]);
    Index++;
  }
  FREE_ARRAY(HMEM_CTX_REF,ppRDNArr);
  FREE_ARRAY(HMEM_CTX_REF,pNameStruc);
} 

extern "C"  X501_DN* AllocX501DN_Struc(HMEM_CTX_DEF
		int RDNCount, int ElementCnt,
		int AllocFlag, int FreeFlag)
{
  int Index;
  int Retcode;

  IDATPARR** pRdnArr = NULL;
  X501_DN* pNameDesc = NULL;
  IDATPARR* ppTmpRDNDesc[1];

  //----------------------------------------------------------
  // 1. Allocate the Structure itself, clear it
  //----------------------------------------------------------
  pNameDesc = (X501_DN*)
    ((void *) BIT8_ARRAY_CALLOC(HMEM_CTX_REF,1, sizeof(X501_DN)));
  if(pNameDesc == NULL)
    return(NULL);
  //----------------------------------------------------------------
  // 2. Allocate the Array of IDATPARR structure pointers, if needed
  //----------------------------------------------------------------
  if(RDNCount <= 0)
    return(pNameDesc);
  pRdnArr = (IDATPARR**)
    ((void *) BIT8_ARRAY_CALLOC(HMEM_CTX_REF,
			        1,RDNCount * sizeof(IDATPARR*)));
  if(pRdnArr == NULL)
  {
    FREE_ARRAY(HMEM_CTX_REF,pNameDesc);
    return(NULL);
  }
  pNameDesc->Cnt   = RDNCount;
  pNameDesc->ppArr = pRdnArr;
  //-----------------------------------------------------------------
  // 3. Allocate the RDN Elements IDATPARR structures if needed
  //-----------------------------------------------------------------
  if(AllocFlag == 0)			// no structures needed...
    return(pNameDesc);

  Index = 0;
  while(Index < RDNCount)
  {
    Retcode = AllocIDATPARR_Struc(HMEM_CTX_REF1 
				  ppTmpRDNDesc,ElementCnt);
    if(Retcode != ASN1_OP_OK)
    {
      FreeX501DN_Struc(HMEM_CTX_REF1 pNameDesc);
      return(NULL);
    }
    if(FreeFlag != 0)
      ppTmpRDNDesc[0]->Flags |= FREE_BIT_MASK;
    pRdnArr[Index] = ppTmpRDNDesc[0];
    Index++;
  }
  return(pNameDesc);
}

extern "C"  int FromLnumToArrayDescElement(HMEM_CTX_DEF
		IDATPARR* DatArrayDesc,
		int Index, WLARGENUM* lplnum)
{
  char* pMem = NULL;

  int i;
  int BufLen;

  int TmpLen[1];

  IDATA* pIdata;
  IDATA** DatArray; 

  //------------------------------------------------------
  // check parameters
  //------------------------------------------------------
  if((DatArrayDesc == NULL) || (lplnum == NULL))
    return(ASN1_LNUM_TO_DESC_NULLPTR_ERR);
  DatArray = DatArrayDesc->ppArr;		// get Array base
  if(DatArray == NULL) return(ASN1_LNUM_TO_DESC_NULLPTR_ERR);
  pIdata = DatArray[Index];
  if(pIdata == NULL) return(ASN1_LNUM_TO_DESC_NULLPTR_ERR);
  if((DatArrayDesc->Flags & FREE_BIT_MASK) == 0)
    return(ASN1_LNUM_TO_DESC_INV_DESC_ERR);
  //------------------------------------------------------
  // Allocate conversion buffer
  //------------------------------------------------------
//  BufLen = LNUM_UsedSize(lplnum) + 1;		// get length
//  BufLen = LNUM_UsedSize(lplnum);		// get length, old
  BufLen = GetByteCntWLnum(lplnum);	// get length, new

  if(BufLen == 0)				// no number
  {
    pIdata->Len = 0;
    return(ASN1_OP_OK);
  }
  pMem = BIT8_ARRAY_ALLOC(HMEM_CTX_REF,BufLen);
  if(pMem == NULL)
    return(ASN1_LNUM_TO_DESC_ALLOC_ERR);
  //------------------------------------------------------
  // Convert the large number (with leading zero if required)
  //------------------------------------------------------
  TmpLen[0] = BufLen;
//  i = LNUM_LNUM_2_BIN(LNUMinst,HMEM_CTX_REF,
//			pMem,0,TmpLen,lplnum,1);
  i = WLnum_wlnum2bin(pMem,0,TmpLen,lplnum,0);
  if(i != LNUM_OP_OK)
  {
    FREE_ARRAY(HMEM_CTX_REF,pMem);
    return(ASN1_LNUM_TO_DESC_ALLOC_ERR);
  }
  //------------------------------------------------------
  // Store the values to the element
  //------------------------------------------------------
  if(pIdata->Base != NULL)
    FREE_ARRAY(HMEM_CTX_REF,pIdata->Base);
  pIdata->Base = pMem;
  pIdata->Off = 0;
  pIdata->Len = TmpLen[0];
  return(ASN1_OP_OK);
}

extern "C"  void FromDatArrayToBuf(IDATA** DatArray,
			int Index, char** Base,
			int* Offset, int* Length)
{
  IDATA* pIdata;

  Base[0] = NULL;
  Offset[0] = 0;
  Length[0] = 0;

  if(DatArray == NULL) return;
  pIdata = DatArray[Index];
  if(pIdata == NULL) return;

  Base[0]   = pIdata->Base;
  Offset[0] = (int) pIdata->Off;
  Length[0] = pIdata->Len;
}

extern "C"  int FromBufToDatArray(HMEM_CTX_DEF
			IDATA** DatArray,
			int Index, char* SrcBuf, int SrcOffset,
			int SrcLen, int Mode)
{

  char* pMem;
  IDATA* pIdata;

  //-------------------------------------------------
  // Check Parameters
  //-------------------------------------------------
  if((DatArray == NULL) || (SrcBuf == NULL))
    return(ASN1_BUF_TO_DATARR_NULLPTR_ERR);
  pIdata = DatArray[Index];

  if(pIdata == NULL)
    return(ASN1_BUF_TO_DATARR_NULLPTR_ERR);
  //-------------------------------------------------
  // Distribute according to mode
  //-------------------------------------------------
  if(Mode == 0)					// direct copy mode
  {
    pIdata->Base = SrcBuf;
    pIdata->Off = (int) SrcOffset;
    pIdata->Len = SrcLen;
    return(ASN1_OP_OK);
  }
  //-------------------------------------------------
  // Copy Mode selected, free / allocate
  //-------------------------------------------------
  pIdata->Off = 0;			// clear offset
  pIdata->Len = 0;			// clear length
  if(pIdata->Base != NULL)		// free Buffer, clear pointer
  {
    FREE_ARRAY(HMEM_CTX_REF,pIdata->Base);
  }
  if(SrcLen == 0) return(ASN1_OP_OK);		// no data given ...
  pMem = BIT8_ARRAY_ALLOC(HMEM_CTX_REF,SrcLen);
  if(pMem == NULL)
    return(ASN1_BUF_TO_DATARR_ALLOC_ERR);
  memcpy(pMem+0,SrcBuf+SrcOffset,SrcLen);
  pIdata->Base = pMem;
  pIdata->Len = SrcLen;
  return(ASN1_OP_OK);
}

extern "C"  void FromDescToBuf(IDATPARR* ArrayDesc,
			int Index, char** Base,
			int* Offset, int* Length)
{
  int Count=0;

  IDATA** DatArray;

  Base[0] = NULL;
  Offset[0] = 0;
  Length[0] = 0;

  if(ArrayDesc == NULL) return;
  Count    = ArrayDesc->Cnt;
  DatArray = ArrayDesc->ppArr;
  if((Count <= 0) || (Index >= Count)) return;
  FromDatArrayToBuf(DatArray,Index,Base,Offset,Length);
}

extern "C"  int FromBufToDesc(HMEM_CTX_DEF
			char* Base, int Offset, int Length,
			int Index, int FreeFlag,IDATPARR** pArrayDesc)
{
  int Count = 0;
  int Retcode = ASN1_OP_OK;

  IDATA** pTmpDatArray[1];
  IDATA** DatArray = NULL;
//  IDATA_PTR pTmpIdata;
  IDATA* pIdata;

  IDATPARR* pTmpDatArrayDesc[1];
  IDATPARR* DatArrayDesc;

  if(pArrayDesc == NULL) return(ASN1_BUF_TO_DESC_NULL_PTR_ERR);
  if(Base == NULL) return(ASN1_OP_OK);
  DatArrayDesc = pArrayDesc[0];

  pTmpDatArrayDesc[0] = NULL;
  pTmpDatArray[0] = NULL;
//  pTmpIdata = NULL;

  for(;;)
  {
    if(DatArrayDesc == NULL)
    {
      Retcode = AllocIDATPARR_Struc(HMEM_CTX_REF1 
				    pTmpDatArrayDesc,Index+1);  
      if(Retcode != ASN1_OP_OK) break;
      DatArrayDesc = pTmpDatArrayDesc[0]; 
    }
    DatArray = DatArrayDesc->ppArr;
    if(DatArray == NULL)
    {
      Retcode = AllocIDATA_Array(HMEM_CTX_REF1
				 pTmpDatArray, Index+1);
      if(Retcode != ASN1_OP_OK) break;
      DatArrayDesc->Cnt = Index + 1;
      DatArray = pTmpDatArray[0];
    }  
    Count = DatArrayDesc->Cnt;
    if(Index >= Count)
    {
      Retcode = ASN1_BUF_TO_DESC_WRONG_INDEX;
      break;
    }

    pIdata = DatArray[Index];
    pIdata->Base = Base;
    pIdata->Off  = (int) Offset;
    pIdata->Len  = Length;
    if(FreeFlag != 0) DatArrayDesc->Flags |= FREE_BIT_MASK;
    break;
  } // Error FOR
  if(Retcode == ASN1_OP_OK)
  {
    if(pTmpDatArrayDesc[0] != NULL)
      pArrayDesc[0] = DatArrayDesc;
    return(Retcode);
  }
  if(pTmpDatArrayDesc[0] != NULL)
  {
    FreeIDATPARR_Struc(HMEM_CTX_REF1 DatArrayDesc);
    return(Retcode);
  }  
  if(pTmpDatArray[0] != NULL)
    FreeIDATA_Array(HMEM_CTX_REF1 DatArray,Count,0);
  return(Retcode);
}

extern "C"  void CopyIdataContents(IDATA* DstStruc,
					  IDATA* SrcStruc)
{
  IDATA* pDstIdata = DstStruc;
  IDATA* pSrcIdata = SrcStruc;

  pDstIdata->Base = pSrcIdata->Base;
  pDstIdata->Off  = pSrcIdata->Off;
  pDstIdata->Len  = pSrcIdata->Len;
}

extern "C"  int CopyToLocalDatArrayDesc(HMEM_CTX_DEF
			IDATPARR* DatArrayDesc)
{
  int i;
  int Retcode = ASN1_OP_OK;
  int Index1;
//  int Index2;
  int ElementCount;

  int Offset;
  int Len;

  char** BufArray = NULL;
  char* pBuf;
  char* Base;

  IDATA** DatArray;
  IDATA* pIdata;

  ElementCount = DatArrayDesc->Cnt;
  DatArray     = DatArrayDesc->ppArr;
  //------------------------------------------------------------
  // 1. Allocate buffer array for elements, clear it
  //------------------------------------------------------------
  BufArray = (char **)
    ((void *) BIT8_ARRAY_CALLOC(HMEM_CTX_REF,
				ElementCount, sizeof(char*)));
  if(BufArray == NULL)
    return(ASN1_COPY_TO_LCL_ARR_ALLOC_ERR);

  for(;;)					// Error FOR
  {
    //---------------------------------------------------
    // 2. Allocate buffers for the Entries (if present)
    //---------------------------------------------------
    i = ElementCount;
    Index1 = 0;
    do
    {
      pIdata = DatArray[Index1];
      Base   = pIdata->Base;
      if(Base != NULL)			// Element is present
      {
        Offset = (int) pIdata->Off;
        Len    = pIdata->Len;
        pBuf = BIT8_ARRAY_ALLOC(HMEM_CTX_REF,Len);
        if(pBuf == NULL)
        {
          Retcode = ASN1_COPY_TO_LCL_BUF_ALLOC_ERR;
          break;
        }
	memcpy(pBuf+0,Base+Offset,Len);

        BufArray[Index1] = pBuf;
      }
      Index1++;
      i--;
    }while(i != 0);
    if(Retcode != ASN1_OP_OK)
      break;
    //---------------------------------------------------
    // 3. All buffers allocated, copied, replace Dataarrays
    //---------------------------------------------------
    i = ElementCount;
    Index1 = 0;
    do
    {
      pIdata = DatArray[Index1];
      pIdata->Base = BufArray[Index1++];
      pIdata->Off  = 0;
      i--;
    } while(i != 0);
    FREE_CARRAY(HMEM_CTX_REF,BufArray);

    BufArray = NULL;
    DatArrayDesc->Flags |= FREE_BIT_MASK;	// must free buffers
    break;
  } // Error FOR
  if(BufArray != NULL)
  {
    i = ElementCount;
    Index1 = 0;
    do
    {
      if(BufArray[Index1] != NULL)
        FREE_CARRAY(HMEM_CTX_REF,BufArray[Index1]);
      Index1++;
      i--;
    }while(i != 0);
    FREE_CARRAY(HMEM_CTX_REF,BufArray);
 }
  return(Retcode);
}

extern "C"  int AllocCopyDatArrayElements(HMEM_CTX_DEF
		IDATA** SrcDatArray, int SrcIndex,
		IDATA** DstDatArray, int DstIndex,
		int ElementCnt, int CopyMode)
{
  char* pMem;

  int SrcLen;
  int SrcOff;

  char* SrcBase;
  char* DstBase;

  IDATA* SrcpIdata;
  IDATA* DstpIdata;

  //------------------------------------------------------
  // check parameters
  //------------------------------------------------------
  if((SrcDatArray == NULL) || (DstDatArray == NULL))
    return(ASN1_DATARR_ELEM_COPY_NULPT_ERR);
  //------------------------------------------------------
  // Copy the Elements
  //------------------------------------------------------
  do
  {
    SrcpIdata = SrcDatArray[SrcIndex++];	// get source pointer
    SrcBase = SrcpIdata->Base;
    SrcOff  = (int) SrcpIdata->Off;
    SrcLen  = SrcpIdata->Len;
    DstpIdata = DstDatArray[DstIndex++];
    DstBase = DstpIdata->Base;
    if(CopyMode == 0)				// only copy pointers
    {
      DstpIdata->Base = SrcBase;
      DstpIdata->Off  = (int) SrcOff;
      DstpIdata->Len  = SrcLen;
    }
    else
    {
      if(DstBase != NULL)
      {
        FREE_ARRAY(HMEM_CTX_REF,DstBase);			// free
        DstpIdata->Base = NULL;
      }
      DstpIdata->Off = 0;
      DstpIdata->Len = 0;
      if((SrcBase != NULL) && (SrcLen != 0))	// Source is present
      {
        pMem = BIT8_ARRAY_ALLOC(HMEM_CTX_REF,SrcLen);	// Allocate
        if(pMem == NULL)
          return(ASN1_DATARR_ELEM_COPY_ALLOC_ERR);
        DstpIdata->Base = pMem;		// set memory
        memcpy(pMem+0,SrcBase+SrcOff,SrcLen); // copy data
        DstpIdata->Len = SrcLen;		// set length
      }
    }
    ElementCnt--;
  }while(ElementCnt != 0);
  return(ASN1_OP_OK);
}

extern "C"  int AllocCopyDatArrayToDatArray(HMEM_CTX_DEF
		IDATPARR* SrcDatArrayDesc, int SrcIndex,
		IDATPARR* DstDatArrayDesc, int DstIndex,
		int ElementCnt, int CopyMode)
{
  IDATA** SrcDatArray; 
  IDATA** DstDatArray; 

  //------------------------------------------------------
  // check parameters
  //------------------------------------------------------
  if((SrcDatArrayDesc == NULL) || (DstDatArrayDesc == NULL))
    return(ASN1_DATARR_COPY_NULLPTR_ERR);
  SrcDatArray = SrcDatArrayDesc->ppArr;
  DstDatArray = DstDatArrayDesc->ppArr;
  if((SrcDatArray == NULL) || (DstDatArray == NULL))
    return(ASN1_DATARR_COPY_NULLPTR_ERR);
  if((CopyMode != 0) &&
     ((DstDatArrayDesc->Flags & FREE_BIT_MASK) == 0))
    return(ASN1_DATARR_COPY_INV_DST_ERR);
  if(((ElementCnt + SrcIndex) > (SrcDatArrayDesc->Cnt)) ||
     ((ElementCnt + DstIndex) > (DstDatArrayDesc->Cnt)) ||
     (ElementCnt <= 0))
    return(ASN1_DATARR_COPY_INV_CNT_ERR);
  //------------------------------------------------------
  // Copy the Elements
  //------------------------------------------------------
  return(AllocCopyDatArrayElements(HMEM_CTX_REF1
	    SrcDatArray, SrcIndex,
	    DstDatArray, DstIndex, ElementCnt, CopyMode));
}
/**
* Reads a <code>WLARGENUM</code> from an element of a <code>IDATPARR</code>
* structure (FromArrayDescElementToLnum). 
* Performs (re-)allocation as needed. If the source element
* contains no data and pLnum has a valid <code>WLARGENUM</code>, sets used size
* to 0. Doesn't allocate a <code>WLARGENUM</code> for this special case.
*
* Makes deep copy of data.
*
*  @param DatArrayDesc Source structure
*  @param Index Index to read
*  @param pLnum Pointer to destination. Destination may be NULL
*
*  @return ASN1_OP_OK on success, error code otherwise
*/
static  int FromArrayDescElementToLnum(HMEM_CTX_DEF
		IDATPARR* DatArrayDesc,
		int Index, WLARGENUM** pLnum)
{
//  BIT8PTR pMem = NULL;

  int i;
  int BufLen;
  int BufOff;

  char* BufBase;

  IDATA* pIdata;
  IDATA** DatArray; 

  WLARGENUM* pTmpLnum = NULL;  
  WLARGENUM* pDstLnum;  
  //------------------------------------------------------
  // check parameters
  //------------------------------------------------------
  if((DatArrayDesc == NULL) || (pLnum == NULL))
    return(ASN1_DESC_TO_LNUM_NULLPTR_ERR);

  DatArray = DatArrayDesc->ppArr;	// get Array base
  if(DatArray == NULL)
    return(ASN1_DESC_TO_LNUM_NULLPTR_ERR);
  pIdata = DatArray[Index];
  if(pIdata == NULL)
     return(ASN1_DESC_TO_LNUM_NULLPTR_ERR);
  pDstLnum = pLnum[0];				// get destination pointer
  //------------------------------------------------------
  // get the buffer parameters
  //------------------------------------------------------
  BufBase = pIdata->Base;			// get buffer base
  BufOff  = (int) pIdata->Off;		// get offset
  BufLen  = pIdata->Len;			// get datalength
  //------------------------------------------------------
  // Check if Buffer is present for conversion...
  //------------------------------------------------------
  if(BufBase == NULL)				// no buffer present
  {
    if(pDstLnum != NULL)			// if descriptor present...
      pDstLnum->UsedSize = 0;		// set zero element length
    return(ASN1_OP_OK);
  }
  //---------------------------------------------------------------
  // Buffer is present for conversion check if descriptor allocated
  //---------------------------------------------------------------
  if(pDstLnum == NULL)				// no descriptor present
  {
//    pTmpLnum = ALLOC_LNUM(LNUMinst,BufLen);	// allocate element Desc., old
    pTmpLnum = AllocNewWLnum(HMEM_CTX_REF1 (BufLen + sizeof(int)-1)/sizeof(int));// allocate element Desc.,new

    if(pTmpLnum == NULL)			// failed to allocate
      return(ASN1_DESC_TO_LNUM_ALLOC_ERR);

    i = WLnum_bin2wlnum(HMEM_CTX_REF1 pTmpLnum,BufBase,BufOff,BufLen);
    if(i != LNUM_OP_OK)
    {
      FreeWLnum(HMEM_CTX_REF1 pTmpLnum);
      return(ASN1_DESC_TO_LNUM_CONV_ERR);
    }
    pLnum[0] = pTmpLnum;
    return(ASN1_OP_OK);
  }
  i = WLnum_bin2wlnum(HMEM_CTX_REF1 pDstLnum,BufBase,BufOff,BufLen);
  if(i != LNUM_OP_OK)
    return(ASN1_DESC_TO_LNUM_CONV_ERR);
  return(ASN1_OP_OK);
}

extern "C"  int FromArrayDescToRSAPubParams(HMEM_CTX_DEF
		IDATPARR* PubParValsDesc, RSA_STRUC** pRsaStruc)
{
  int Retcode = ASN1_OP_OK;

  IDATA** ParValDatArray;

  RSA_STRUC* rsa = NULL; 

  WLARGENUM* pTmpLnum[1];
  //------------------------------------------------
  // Check for NULL pointers
  //------------------------------------------------
  if((PubParValsDesc == NULL) || (pRsaStruc == NULL))
    return(ASN1_PUB_INF_TO_RSA_NULLPTR_ERR);
  pRsaStruc[0] = NULL;
  //------------------------------------------------
  // Get the Data values
  //------------------------------------------------
  ParValDatArray = PubParValsDesc->ppArr;

  rsa = RSA_New(HMEM_CTX_REF1 
                (ParValDatArray[RSA_PUB_VAL_MOD_INDEX+RSA_ALG_PAR_MAX_INDEX]->Len+ sizeof(int)-1)/sizeof(int),
                (ParValDatArray[RSA_PUB_VAL_EXP_INDEX+RSA_ALG_PAR_MAX_INDEX]->Len+ sizeof(int)-1)/sizeof(int),
                0,
                0,
                0);

  if(rsa == NULL)
    return(ASN1_PUB_INF_TO_RSA_ALLOC_ERR);

  for(;;)					// number conversion Error FOR
  {
    pTmpLnum[0] = rsa->Modul;
    Retcode = FromArrayDescElementToLnum(HMEM_CTX_REF1
		PubParValsDesc,
		RSA_ALG_PAR_MAX_INDEX+
		RSA_PUB_VAL_MOD_INDEX,pTmpLnum);
    if(Retcode != ASN1_OP_OK)
      break;

    pTmpLnum[0] = rsa->PubExp;
    Retcode = FromArrayDescElementToLnum(HMEM_CTX_REF1
		PubParValsDesc,
		RSA_ALG_PAR_MAX_INDEX+
		RSA_PUB_VAL_EXP_INDEX,pTmpLnum);
    break;
  } // Error For
  if(Retcode != ASN1_OP_OK)
  {
    RSA_Free(HMEM_CTX_REF1 rsa);
    return(Retcode);
  }
  pRsaStruc[0] = rsa;
  return(ASN1_OP_OK);            
}

extern "C"  int FromArrayDescToDSAPubParams(HMEM_CTX_DEF
	IDATPARR* PubParValsDesc, DSA_STRUC** pDsaStruc)
{
  int Retcode = ASN1_OP_OK;

  IDATA** ParValDatArray;

  DSA_STRUC* dsa = NULL; 

  WLARGENUM* pTmpLnum[1];

  //------------------------------------------------
  // Check for NULL pointers
  //------------------------------------------------
  if((PubParValsDesc == NULL) || (pDsaStruc == NULL))
    return(ASN1_PUB_INF_TO_DSA_NULLPTR_ERR);

  pDsaStruc[0] = NULL;
  //----------------------------------------------------
  // Allocate structure with appropriate element lengths
  //----------------------------------------------------
  ParValDatArray = PubParValsDesc->ppArr;

  dsa = DSA_New(HMEM_CTX_REF1 
                (ParValDatArray[DSA_ALG_PAR_P_INDEX]->Len + sizeof(int)-1)/ sizeof(int),
                (ParValDatArray[DSA_ALG_PAR_Q_INDEX]->Len + sizeof(int)-1)/ sizeof(int),
                (ParValDatArray[DSA_ALG_PAR_G_INDEX]->Len + sizeof(int)-1)/ sizeof(int),
                (ParValDatArray[DSA_ALG_PAR_MAX_INDEX+ DSA_PUB_VAL_Y_INDEX]->Len + sizeof(int)-1)/ sizeof(int),
                0);

  if(dsa == NULL) return(ASN1_PUB_INF_TO_DSA_ALLOC_ERR);

  for(;;)					// number conversion Error FOR
  {

    pTmpLnum[0] = dsa->p;
    Retcode = FromArrayDescElementToLnum(HMEM_CTX_REF1
		PubParValsDesc,
		DSA_ALG_PAR_P_INDEX,pTmpLnum);
    if(Retcode != ASN1_OP_OK) break;

    pTmpLnum[0] = dsa->q;
    Retcode = FromArrayDescElementToLnum(HMEM_CTX_REF1
		PubParValsDesc,
		DSA_ALG_PAR_Q_INDEX,pTmpLnum);
    if(Retcode != ASN1_OP_OK) break;

    pTmpLnum[0] = dsa->g;
    Retcode = FromArrayDescElementToLnum(HMEM_CTX_REF1
		PubParValsDesc,
		DSA_ALG_PAR_G_INDEX,pTmpLnum);
    if(Retcode != ASN1_OP_OK) break;

    pTmpLnum[0] = dsa->y;
    Retcode = FromArrayDescElementToLnum(HMEM_CTX_REF1
		PubParValsDesc,
		DSA_ALG_PAR_MAX_INDEX+
		DSA_PUB_VAL_Y_INDEX,pTmpLnum);
    break;
  } // Error For
  if(Retcode != ASN1_OP_OK)
  {
    DSA_Free(HMEM_CTX_REF1 dsa);
    return(Retcode);
  }
  pDsaStruc[0] = dsa;
  return(ASN1_OP_OK);            
}

extern "C"  int FromArrayDescToDHPubParams(HMEM_CTX_DEF
	IDATPARR* PubParValsDesc, DH_STRUC** pDhStruc)
{
  int Retcode = ASN1_OP_OK;

  IDATA** ParValDatArray;

  DH_STRUC* dh = NULL; 

  WLARGENUM* pTmpLnum[1];

  //------------------------------------------------
  // Check for NULL pointers
  //------------------------------------------------
  if((PubParValsDesc == NULL) || (pDhStruc == NULL))
    return(ASN1_PUB_INF_TO_DH_NULLPTR_ERR);

  pDhStruc[0] = NULL;
  //------------------------------------------------
  // Get the Parameters from the array
  //------------------------------------------------
  ParValDatArray = PubParValsDesc->ppArr;

  dh = DH_New(HMEM_CTX_REF1 
              (ParValDatArray[DH_ALG_PAR_P_INDEX]->Len + sizeof(int)-1)/ sizeof(int),
              (ParValDatArray[DH_ALG_PAR_Q_INDEX]->Len + sizeof(int)-1)/ sizeof(int),
              (ParValDatArray[DH_ALG_PAR_G_INDEX]->Len + sizeof(int)-1)/ sizeof(int),
              (ParValDatArray[DH_ALG_PAR_MAX_INDEX+ DH_PUB_VAL_Y_INDEX]->Len + sizeof(int)-1)/ sizeof(int),
              0);

  if(dh == NULL) return(ASN1_PUB_INF_TO_DH_ALLOC_ERR);

  for(;;)					// number conversion Error FOR
  {
    pTmpLnum[0] = dh->p;
    Retcode = FromArrayDescElementToLnum(HMEM_CTX_REF1
		PubParValsDesc,
		DH_ALG_PAR_P_INDEX,pTmpLnum);
    if(Retcode != ASN1_OP_OK) break;

    pTmpLnum[0] = dh->g;
    Retcode = FromArrayDescElementToLnum(HMEM_CTX_REF1
		PubParValsDesc,
		DH_ALG_PAR_G_INDEX,pTmpLnum);
    if(Retcode != ASN1_OP_OK) break;

    pTmpLnum[0] = dh->PubKey;
    Retcode = FromArrayDescElementToLnum(HMEM_CTX_REF1
		PubParValsDesc,
		DH_ALG_PAR_MAX_INDEX+DH_PUB_VAL_Y_INDEX,pTmpLnum);
    break;
  } // Error For
  if(Retcode != ASN1_OP_OK)
  {
    DH_Free(HMEM_CTX_REF1 dh);
    return(Retcode);
  }
  pDhStruc[0] = dh;
  return(ASN1_OP_OK);            
}

extern "C"  int FromDHPubParamsToArrayDesc(HMEM_CTX_DEF
		 DH_STRUC* DhStruc, IDATPARR** pPubParValsDesc)
{
  int Retcode;

  IDATPARR* pTmpArrDesc[1];
  IDATPARR* DatArrayDesc = NULL;
  //------------------------------------------------
  // Check for NULL pointers
  //------------------------------------------------
  if((pPubParValsDesc == NULL) || (DhStruc == NULL))
    return(ASN1_DH_PUB_TO_DESC_NULPTR_ERR);
  pPubParValsDesc[0] = NULL;
  //------------------------------------------------
  // Allocate the Descriptor Array, mark as freeable
  //------------------------------------------------
  Retcode = AllocIDATPARR_Struc(HMEM_CTX_REF1 pTmpArrDesc,
		 DH_ALG_PAR_MAX_INDEX+DH_PUB_VAL_MAX_INDEX);
  if(Retcode != ASN1_OP_OK)
    return(ASN1_DH_PUB_TO_DESC_ALLOC_ERR);
  DatArrayDesc = pTmpArrDesc[0];
  DatArrayDesc->Flags |= FREE_BIT_MASK;	// mark as freeable
  for(;;)	// Error FOR
  {
    //------------------------------------------------
    // Convert/Store the Prime p
    //------------------------------------------------
    Retcode = FromLnumToArrayDescElement(HMEM_CTX_REF1
		DatArrayDesc,
		DH_ALG_PAR_P_INDEX,DhStruc->p);
    if(Retcode != ASN1_OP_OK) break;
    //------------------------------------------------
    // Convert/Store the Prime q
    //------------------------------------------------
    Retcode = FromLnumToArrayDescElement(HMEM_CTX_REF1
		DatArrayDesc,
		DH_ALG_PAR_Q_INDEX,DhStruc->q);
    if(Retcode != ASN1_OP_OK) break;
    //------------------------------------------------
    // Convert/Store the Generator g
    //------------------------------------------------
    Retcode = FromLnumToArrayDescElement(HMEM_CTX_REF1
		DatArrayDesc,
		DH_ALG_PAR_G_INDEX,DhStruc->g);
    if(Retcode != ASN1_OP_OK) break;
    //------------------------------------------------
    // Convert/Store the public value y
    //------------------------------------------------
    Retcode = FromLnumToArrayDescElement(HMEM_CTX_REF1
		DatArrayDesc,
		DH_ALG_PAR_MAX_INDEX+DH_PUB_VAL_Y_INDEX,
                DhStruc->PubKey);
    break;
  } // Error FOR
  if(Retcode != ASN1_OP_OK)
  {
    FreeIDATPARR_Struc(HMEM_CTX_REF1 DatArrayDesc);
    return(Retcode);
  }
  pPubParValsDesc[0] = DatArrayDesc;
  return(ASN1_OP_OK);            
}

extern "C"  int FromArrayDescToRSAPrivParams(HMEM_CTX_DEF
		IDATPARR* PrivParValsDesc, RSA_STRUC** pRsaStruc)
{
  int Retcode = ASN1_OP_OK;

  IDATA** ParValDatArray;

  RSA_STRUC* rsa = NULL; 

  WLARGENUM* pTmpLnum[1];
  //------------------------------------------------
  // Check for NULL pointers
  //------------------------------------------------
  if((PrivParValsDesc == NULL) || (pRsaStruc == NULL))
    return(ASN1_PRIV_INF_TO_RSA_NULPTR_ERR);
  pRsaStruc[0] = NULL;
  //------------------------------------------------
  // Get the Data values
  //------------------------------------------------
  ParValDatArray = PrivParValsDesc->ppArr;

  rsa = RSA_New(HMEM_CTX_REF1 
                (ParValDatArray[RSA_ALG_PAR_MAX_INDEX+ RSA_PRIV_KEY_MODULUS_INDEX]->Len + sizeof(int)-1)/ sizeof(int),
                (ParValDatArray[RSA_ALG_PAR_MAX_INDEX+ RSA_PRIV_KEY_PUBL_EXP_INDEX]->Len + sizeof(int)-1)/ sizeof(int),
                (ParValDatArray[RSA_ALG_PAR_MAX_INDEX+ RSA_PRIV_KEY_PRIV_EXP_INDEX]->Len + sizeof(int)-1)/ sizeof(int),
                (ParValDatArray[RSA_ALG_PAR_MAX_INDEX+ RSA_PRIV_KEY_PRIME_P_INDEX]->Len + sizeof(int)-1)/ sizeof(int),
                (ParValDatArray[RSA_ALG_PAR_MAX_INDEX+ RSA_PRIV_KEY_PRIME_Q_INDEX]->Len + sizeof(int)-1)/ sizeof(int));

  if(rsa == NULL) return(ASN1_PRIV_INF_TO_RSA_ALLOC_ERR);

  for(;;)					// number conversion Error FOR
  {
    pTmpLnum[0] = rsa->Modul;
    Retcode = FromArrayDescElementToLnum(HMEM_CTX_REF1
		PrivParValsDesc,
		RSA_ALG_PAR_MAX_INDEX+RSA_PRIV_KEY_MODULUS_INDEX,pTmpLnum);
    if(Retcode != ASN1_OP_OK) break;

    pTmpLnum[0] = rsa->PubExp;
    Retcode = FromArrayDescElementToLnum(HMEM_CTX_REF1
		PrivParValsDesc,
		RSA_ALG_PAR_MAX_INDEX+RSA_PRIV_KEY_PUBL_EXP_INDEX,pTmpLnum);
    if(Retcode != ASN1_OP_OK) break;

    pTmpLnum[0] = rsa->PrivExp;
    Retcode = FromArrayDescElementToLnum(HMEM_CTX_REF1
		PrivParValsDesc,
		RSA_ALG_PAR_MAX_INDEX+RSA_PRIV_KEY_PRIV_EXP_INDEX,pTmpLnum);
    if(Retcode != ASN1_OP_OK) break;

    pTmpLnum[0] = rsa->Prime_p;
    Retcode = FromArrayDescElementToLnum(HMEM_CTX_REF1
		PrivParValsDesc,
		RSA_ALG_PAR_MAX_INDEX+RSA_PRIV_KEY_PRIME_P_INDEX,pTmpLnum);
    if(Retcode != ASN1_OP_OK) break;

    pTmpLnum[0] = rsa->Prime_q;
    Retcode = FromArrayDescElementToLnum(HMEM_CTX_REF1
		PrivParValsDesc,
		RSA_ALG_PAR_MAX_INDEX+RSA_PRIV_KEY_PRIME_Q_INDEX,pTmpLnum);
    if(Retcode != ASN1_OP_OK) break;

    pTmpLnum[0] = rsa->Dmodpm1;
    Retcode = FromArrayDescElementToLnum(HMEM_CTX_REF1
		PrivParValsDesc,
		RSA_ALG_PAR_MAX_INDEX+RSA_PRIV_KEY_EXP1_INDEX,pTmpLnum);
    if(Retcode != ASN1_OP_OK) break;

    pTmpLnum[0] = rsa->Dmodqm1;
    Retcode = FromArrayDescElementToLnum(HMEM_CTX_REF1
		PrivParValsDesc,
		RSA_ALG_PAR_MAX_INDEX+RSA_PRIV_KEY_EXP2_INDEX,pTmpLnum);
    if(Retcode != ASN1_OP_OK) break;

    pTmpLnum[0] = rsa->Invqmp;
    Retcode = FromArrayDescElementToLnum(HMEM_CTX_REF1
		PrivParValsDesc,
		RSA_ALG_PAR_MAX_INDEX+RSA_PRIV_KEY_COEFF_INDEX,pTmpLnum);
    break;
  } // Error For
  if(Retcode != ASN1_OP_OK)
  {
    RSA_Free(HMEM_CTX_REF1 rsa);
    return(Retcode);
  }
  pRsaStruc[0] = rsa;
  return(ASN1_OP_OK);            
}

extern "C"  int FromArrayDescToDSAPrivParams(HMEM_CTX_DEF
	IDATPARR* PrivParValsDesc, DSA_STRUC** pDsaStruc)
{
  int Retcode = ASN1_OP_OK;

  IDATA** ParValDatArray;

  DSA_STRUC* dsa = NULL; 

  WLARGENUM* pTmpLnum[1];

  //------------------------------------------------
  // Check for NULL pointers
  //------------------------------------------------
  if((PrivParValsDesc == NULL) || (pDsaStruc == NULL))
    return(ASN1_PRIV_INF_TO_DSA_NULPTR_ERR);

  pDsaStruc[0] = NULL;
  //----------------------------------------------------
  // Allocate structure with appropriate element lengths
  //----------------------------------------------------
  ParValDatArray = PrivParValsDesc->ppArr;

  dsa = DSA_New(HMEM_CTX_REF1 
                (ParValDatArray[DSA_ALG_PAR_P_INDEX]->Len + sizeof(int)-1)/ sizeof(int),
                (ParValDatArray[DSA_ALG_PAR_Q_INDEX]->Len + sizeof(int)-1)/ sizeof(int),
                (ParValDatArray[DSA_ALG_PAR_G_INDEX]->Len + sizeof(int)-1)/ sizeof(int),
                (ParValDatArray[DSA_ALG_PAR_MAX_INDEX+ DSA_PRIV_KEY_YKEY_INDEX]->Len + sizeof(int)-1)/ sizeof(int),
                (ParValDatArray[DSA_ALG_PAR_MAX_INDEX+ DSA_PRIV_KEY_XKEY_INDEX]->Len + sizeof(int)-1)/ sizeof(int));

  if(dsa == NULL) return(ASN1_PRIV_INF_TO_DSA_ALLOC_ERR);

  for(;;)					// number conversion Error FOR
  {

    pTmpLnum[0] = dsa->p;
    Retcode = FromArrayDescElementToLnum(HMEM_CTX_REF1
		PrivParValsDesc,
		DSA_ALG_PAR_P_INDEX,pTmpLnum);
    if(Retcode != ASN1_OP_OK) break;

    pTmpLnum[0] = dsa->q;
    Retcode = FromArrayDescElementToLnum(HMEM_CTX_REF1
		PrivParValsDesc,
		DSA_ALG_PAR_Q_INDEX,pTmpLnum);
    if(Retcode != ASN1_OP_OK) break;

    pTmpLnum[0] = dsa->g;
    Retcode = FromArrayDescElementToLnum(HMEM_CTX_REF1
		PrivParValsDesc,
		DSA_ALG_PAR_G_INDEX,pTmpLnum);
    if(Retcode != ASN1_OP_OK) break;

    pTmpLnum[0] = dsa->y;
    Retcode = FromArrayDescElementToLnum(HMEM_CTX_REF1
		PrivParValsDesc,
		DSA_ALG_PAR_MAX_INDEX+
		DSA_PRIV_KEY_YKEY_INDEX,pTmpLnum);
    if(Retcode != ASN1_OP_OK) break;

    pTmpLnum[0] = dsa->x;
    Retcode = FromArrayDescElementToLnum(HMEM_CTX_REF1
		PrivParValsDesc,
		DSA_ALG_PAR_MAX_INDEX+
		DSA_PRIV_KEY_XKEY_INDEX,pTmpLnum);
    break;
  } // Error For
  if(Retcode != ASN1_OP_OK)
  {
    DSA_Free(HMEM_CTX_REF1 dsa);
    return(Retcode);
  }
  pDsaStruc[0] = dsa;
  return(ASN1_OP_OK);            
}

extern "C"  int FromArrayDescToDHPrivParams(HMEM_CTX_DEF
	IDATPARR* PrivParValsDesc, DH_STRUC** pDhStruc)
{
  int Retcode = ASN1_OP_OK;

  IDATA** ParValDatArray;

  DH_STRUC* dh = NULL; 

  WLARGENUM* pTmpLnum[1];

  //------------------------------------------------
  // Check for NULL pointers
  //------------------------------------------------
  if((PrivParValsDesc == NULL) || (pDhStruc == NULL))
    return(ASN1_PRIV_INF_TO_DH_NULPTR_ERR);

  pDhStruc[0] = NULL;
  //----------------------------------------------------
  // Allocate structure with appropriate element lengths
  //----------------------------------------------------
  ParValDatArray = PrivParValsDesc->ppArr;

  dh = DH_New(HMEM_CTX_REF1 
              (ParValDatArray[DH_ALG_PAR_P_INDEX]->Len + sizeof(int)-1)/ sizeof(int),
              (ParValDatArray[DH_ALG_PAR_Q_INDEX]->Len + sizeof(int)-1)/ sizeof(int),
              (ParValDatArray[DH_ALG_PAR_G_INDEX]->Len + sizeof(int)-1)/ sizeof(int),
              (ParValDatArray[DH_ALG_PAR_MAX_INDEX+ DH_PRIV_KEY_YKEY_INDEX]->Len + sizeof(int)-1)/ sizeof(int),
              (ParValDatArray[DH_ALG_PAR_MAX_INDEX+ DH_PRIV_KEY_XKEY_INDEX]->Len + sizeof(int)-1)/ sizeof(int));

  if(dh == NULL) return(ASN1_PRIV_INF_TO_DH_ALLOC_ERR);

  for(;;)					// number conversion Error FOR
  {

    pTmpLnum[0] = dh->p;
    Retcode = FromArrayDescElementToLnum(HMEM_CTX_REF1
		PrivParValsDesc,
		DH_ALG_PAR_P_INDEX,pTmpLnum);
    if(Retcode != ASN1_OP_OK) break;

    pTmpLnum[0] = dh->q;
    Retcode = FromArrayDescElementToLnum(HMEM_CTX_REF1
		PrivParValsDesc,
		DH_ALG_PAR_Q_INDEX,pTmpLnum);
    if(Retcode != ASN1_OP_OK) break;

    pTmpLnum[0] = dh->g;
    Retcode = FromArrayDescElementToLnum(HMEM_CTX_REF1
		PrivParValsDesc,
		DH_ALG_PAR_G_INDEX,pTmpLnum);
    if(Retcode != ASN1_OP_OK) break;

    pTmpLnum[0] = dh->PubKey;
    Retcode = FromArrayDescElementToLnum(HMEM_CTX_REF1
		PrivParValsDesc,
		DH_ALG_PAR_MAX_INDEX+
		DH_PRIV_KEY_YKEY_INDEX,pTmpLnum);
    if(Retcode != ASN1_OP_OK) break;

    pTmpLnum[0] = dh->PrivKey;
    Retcode = FromArrayDescElementToLnum(HMEM_CTX_REF1
		PrivParValsDesc,
		DH_ALG_PAR_MAX_INDEX+
		DH_PRIV_KEY_XKEY_INDEX,pTmpLnum);
    break;
  } // Error For
  if(Retcode != ASN1_OP_OK)
  {
    DH_Free(HMEM_CTX_REF1 dh);
    return(Retcode);
  }
  pDhStruc[0] = dh;
  return(ASN1_OP_OK);            
}

// formerly in HASN1HLI

extern "C"  int GenOIDIdataEntry(HMEM_CTX_DEF
					int OID_Index,
				        int ArrayIndex,
				        IDATA** pDatArray)
{
  int i;

  int OID_Len;
  int OID_Offset;
  int Index;

  IDATA* OID_DatArray;

  char* DatBufBase;

  if(pDatArray == NULL) return(ASN1_GEN_OID_NULL_PTR_ERR);
  if(OID_Index >= MAX_OID_COUNT) return(ASN1_GEN_OID_UNKNOWN_OID);

  OID_Offset = OID_Offset_Table[OID_Index];// get start of OID desc.
  OID_Len = (int) OID_Table[OID_Offset+2] & 0xFF;  // get Length
  OID_DatArray = pDatArray[ArrayIndex];
  //-----------------------------------------------------------
  // Allocate the Buffer for the OID
  //-----------------------------------------------------------
  DatBufBase = BIT8_ARRAY_ALLOC(HMEM_CTX_REF,OID_Len);
  if(DatBufBase == NULL) return(ASN1_GEN_OID_BUF_ALLOC_ERR);
  //-----------------------------------------------------------
  // Copy the OID to the Buffer
  //-----------------------------------------------------------
  i = OID_Len;
  Index = 0;
  OID_Offset += 3;			// to start of OID
  do
  {
    DatBufBase[Index++] = OID_Table[OID_Offset++];
    i--;
  }while(i != 0);
  //-----------------------------------------------------------
  // Put Base and Length to Data Element
  //-----------------------------------------------------------
  OID_DatArray->Base = DatBufBase;
  OID_DatArray->Off  = 0;
  OID_DatArray->Len  = OID_Len;
  return(ASN1_OP_OK);
}
// formerly in HASN1HLI

extern "C"  int SubEncodeSignature(HMEM_CTX_DEF
			IDATA** SrcDatArray,
			int ElementCnt,	int SignatTypeAlgor, int Mode,
			IDATPARR** pDstArrayDesc)
{
  int i;
  int Retcode = ASN1_OP_OK;
  int AlgorOIDIndex=0;
  int TotalCnt;

  int SignatCnt;
  int SignatCtlCnt;
  int SignatErrCode;

  char * pSignatCtl;
  char* pMem;

  char* pTmpBuf[1];

  int pTmpData[1];

  IDATPARR* pTmpArrayDesc[1];
  IDATPARR* DatArrayDesc = NULL;

  IDATA** DatArray=NULL;

  //----------------------------------------------------
  // check for NULL-Pointers
  //----------------------------------------------------
  if((SrcDatArray == NULL) || (pDstArrayDesc == NULL))
    return(ASN1_ENC_SIGNAT_NULL_PTR_ERR);
  pDstArrayDesc[0] = NULL;
  //----------------------------------------------------
  // check if the Type is known...
  //----------------------------------------------------
  switch(SignatTypeAlgor)
  {
    case PKCS1_MD2_WITH_RSA_ENC:
    case PKCS1_MD5_WITH_RSA_ENC:
    case PKCS1_SHA1_WITH_RSA_ENC:
    case TELESEC_RSA_WITH_RIPEMD160:
    case PKCS1_SHA256_WITH_RSA_ENC:
    case PKCS1_SHA384_WITH_RSA_ENC:
    case PKCS1_SHA512_WITH_RSA_ENC:
    case PKCS1_SHA224_WITH_RSA_ENC:
        
      SignatCnt     = RSA_SIG_MAX_INDEX;
      SignatCtlCnt  = RSA_SIG_VAL_CTL_CNT;
      pSignatCtl    = (char *) RSA_SignatValueCtl;
      SignatErrCode = ASN1_ENC_SIGNAT_RSA_VAL_ERR;

      switch(SignatTypeAlgor)
      {
        case PKCS1_MD2_WITH_RSA_ENC:
          AlgorOIDIndex  = OID_PKCS1_MD2_WITH_RSA_ENC;
          break;

        case PKCS1_MD5_WITH_RSA_ENC:
          AlgorOIDIndex  = OID_PKCS1_MD5_WITH_RSA_ENC;
          break;

        case PKCS1_SHA1_WITH_RSA_ENC:
          AlgorOIDIndex  = OID_PKCS1_SHA1_WITH_RSA_ENC;
          break;

        case TELESEC_RSA_WITH_RIPEMD160:
          AlgorOIDIndex  = OID_TELESEC_RSA_WITH_RIPEMD160;
          break;

        case PKCS1_SHA256_WITH_RSA_ENC:
          AlgorOIDIndex = OID_PKCS1_SHA256_WITH_RSA_ENC;
          break;

        case PKCS1_SHA384_WITH_RSA_ENC:
          AlgorOIDIndex = OID_PKCS1_SHA384_WITH_RSA_ENC;
          break;

        case PKCS1_SHA512_WITH_RSA_ENC:
          AlgorOIDIndex = OID_PKCS1_SHA512_WITH_RSA_ENC;
          break;

        case PKCS1_SHA224_WITH_RSA_ENC:
          AlgorOIDIndex = OID_PKCS1_SHA224_WITH_RSA_ENC;
          break;

      } // RSA_Switch
      break;

    case X957_DSA_WITH_SHA1:
    case OIW_DSA_WITH_SHA:
    case OIW_DSA_WITH_SHA1:

      SignatCnt      = DSA_SIG_MAX_INDEX;
      SignatCtlCnt   = DSA_SIG_VAL_CTL_CNT;
      pSignatCtl     = (char *) DSA_SignatValueCtl;
      SignatErrCode  = ASN1_ENC_SIGNAT_DSA_VAL_ERR;
      switch(SignatTypeAlgor)
      {
        case X957_DSA_WITH_SHA1:
          AlgorOIDIndex  = OID_X957_DSA_WITH_SHA1;
          break;

        case OIW_DSA_WITH_SHA:
          AlgorOIDIndex  = OID_OIW_DSA_WITH_SHA;
          break;

        case OIW_DSA_WITH_SHA1:
          AlgorOIDIndex  = OID_OIW_DSA_WITH_SHA;
          break;
      }
      break;

    default:
      return(ASN1_ENC_SIGNAT_INV_REQ_TYPE);
  } // switch
  TotalCnt = 2;					// assume only OID and Params
  if(Mode != 0) TotalCnt += SignatCnt;		// incl. Data
  //--------------------------------------------------------
  // Check if necessarey Data Count presented...
  //--------------------------------------------------------
  if(ElementCnt != (TotalCnt - 2))
    return(ASN1_ENC_SIGNAT_INV_DATA);

  for(;;)
  {							// Error FOR
    //--------------------------------------------------------
    // Allocate Data Array for OID, Params (and Values)
    //--------------------------------------------------------
    i = AllocIDATPARR_Struc(HMEM_CTX_REF1
			    pTmpArrayDesc,TotalCnt);
    if(i != ASN1_OP_OK)
    {
      Retcode = ASN1_ENC_SIGNAT_ARR_ALLOC_ERR;
      break;
    }
    DatArrayDesc = pTmpArrayDesc[0];
    DatArray = DatArrayDesc->ppArr;
    DatArrayDesc->Flags |= FREE_BIT_MASK;
    //--------------------------------------------------------
    // Generate the OID Entry (1st entry)
    //--------------------------------------------------------
    i = GenOIDIdataEntry(HMEM_CTX_REF1
			 AlgorOIDIndex,0,DatArray);
    if(i != ASN1_OP_OK)
    {
      Retcode = ASN1_ENC_SIGNAT_OID_GEN_ERR;
      break;
    }
    //--------------------------------------------------------
    // Generate the ASN1 NULL Element (2nd entry, params)
    //--------------------------------------------------------
    pMem = BIT8_ARRAY_ALLOC(HMEM_CTX_REF,2);
    if(pMem == NULL)
    {
      Retcode = ASN1_ENC_SIGNAT_PAR_ALLOC_ERR;
      break;
    }
    pMem[0] = ASN1_UNIVERSAL_NULL;
    pMem[1] = 0;
    Retcode = FromBufToDatArray(HMEM_CTX_REF1
				DatArray,1,pMem,0,2,0);	      
    if(Retcode != ASN1_OP_OK) break;
    //-----------------------------------------------------
    // If Requested, Generate the Signature Values Buffer,
    // put to Descriptor
    //-----------------------------------------------------
    if(Mode != 0)
    {
      i = ToASN1(HMEM_CTX_REF1
		 SrcDatArray, 0,
		 pSignatCtl, SignatCtlCnt, pTmpBuf,pTmpData);
      if(i != ASN1_OP_OK)
      {
        Retcode = SignatErrCode;
        break;
      }
      Retcode = FromBufToDesc(HMEM_CTX_REF1
			      pTmpBuf[0], 0, pTmpData[0],
			      2,0,pTmpArrayDesc);
    }
    break;
  } // Error FOR
  if(Retcode != ASN1_OP_OK)
  {
    FreeIDATPARR_Struc(HMEM_CTX_REF1 DatArrayDesc);
    return(Retcode);
  }
  pDstArrayDesc[0] = DatArrayDesc;
  return(Retcode);
}
// formerly in HASN1HLI

extern "C"  int SetSignatAlgAndData(HMEM_CTX_DEF
			IDATA** DatArray,
			int IndexOffset, IDATA** SrcArray,
			int ElementCnt, int SignatTypeAlgor)
{
  int Retcode;

  IDATA** TmpDatArray;
  IDATPARR* pTmpArrayDesc[1];
  //-------------------------------------------------------
  // Encode Algor-ID, Parameter and data fields
  //-------------------------------------------------------
  Retcode = SubEncodeSignature(HMEM_CTX_REF1
			       SrcArray,ElementCnt,
                               SignatTypeAlgor, 1, pTmpArrayDesc);
  if(Retcode != ASN1_OP_OK) return(Retcode);
  TmpDatArray = pTmpArrayDesc[0]->ppArr;
  //-------------------------------------------------------
  // Copy Descriptor Elements to TBS Array (real Copy)
  //-------------------------------------------------------
  Retcode = AllocCopyDatArrayElements(HMEM_CTX_REF1
				      TmpDatArray,0,
                                      DatArray,IndexOffset,3,1);
  //------------------------------------------------------------
  // Release the temporary Array Descriptor and its elements
  //------------------------------------------------------------
  FreeIDATPARR_Struc(HMEM_CTX_REF1 pTmpArrayDesc[0]);	// Free Structure
  return(Retcode);
}  

// formerly in HASN1HLI but with other name/params: SignTBSCert_CertReq

extern "C"  int SignTBSData(HMEM_CTX_DEF
		char* pMsgBuf, int MsgOff, int MsgLen,
		RSA_STRUC* RsaStruc, DSA_STRUC* DsaStruc,
                int SignatTypeAlgor, char** pDstBuf, int* pDstLen)
{

  int i;

  int SigAlgor;
  int SigBufLen;

  char* pSignatMem = NULL;

  int pTmpLen[1];

  //------------------------------------------------
  // Check for NULL pointers
  //------------------------------------------------
  if((pMsgBuf == NULL) || (pDstBuf == NULL) || (pDstLen == NULL))
    return(ASN1_SIGN_TBS_DATA_NULL_PTR_ERR);

  //------------------------------------------------
  // Distribute by Signature type
  //------------------------------------------------
  switch(SignatTypeAlgor)
  {
    case PKCS1_MD2_WITH_RSA_ENC:
    case PKCS1_MD5_WITH_RSA_ENC:
    case PKCS1_SHA1_WITH_RSA_ENC:
    case TELESEC_RSA_WITH_RIPEMD160:
    case PKCS1_SHA256_WITH_RSA_ENC:
    case PKCS1_SHA384_WITH_RSA_ENC:
    case PKCS1_SHA512_WITH_RSA_ENC:
    case PKCS1_SHA224_WITH_RSA_ENC:
      if(RsaStruc  == NULL) return(ASN1_SIGN_TBS_DATA_NULL_PTR_ERR);
      SigBufLen = RSA_Size(RsaStruc);
      if(SigBufLen == 0) return(ASN1_SIGN_TBS_DATA_RSA_LEN_ERR);
      SigBufLen++;
      SigAlgor = RSA_PUBLIC_ALGOR;
      break;
     

    case X957_DSA_WITH_SHA1:
      if(DsaStruc  == NULL) return(ASN1_SIGN_TBS_DATA_NULL_PTR_ERR);
      SigBufLen = DSA_SignatMaxLen(DsaStruc);
      if(SigBufLen == 0) return(ASN1_SIGN_TBS_DATA_DSA_LEN_ERR);
      SigAlgor = DSA_PUBLIC_ALGOR;
      break;

    default:
      return(ASN1_SIGN_TBS_DATA_INV_ALG_ERR);
  }
  //------------------------------------------------
  // Allocate Buffer for signature
  //------------------------------------------------
  pSignatMem = BIT8_ARRAY_ALLOC(HMEM_CTX_REF,SigBufLen);
  if(pSignatMem == NULL) return(ASN1_SIGN_TBS_DATA_ALLOC_ERR);
  pTmpLen[0] = SigBufLen;			// set length
  if(SigAlgor == RSA_PUBLIC_ALGOR)
  {
    i = RSA_signEx(HMEM_CTX_REF1 SignatTypeAlgor,pMsgBuf,MsgOff,MsgLen,pSignatMem,0,pTmpLen,RsaStruc,0,-1);
    if(i != RSA_OP_OK)
    {
      FREE_ARRAY(HMEM_CTX_REF,pSignatMem);
      return(ASN1_SIGN_TBS_DATA_RSA_SIGN_ERR);
    }
    SigBufLen = pTmpLen[0];			// get true length
  }
  else
  {
    i = DSA_Sign(HMEM_CTX_REF1 pMsgBuf,MsgOff,MsgLen,pSignatMem,0,pTmpLen,DsaStruc,NULL,0);
    if(i != DSA_OP_OK)
    {
      FREE_ARRAY(HMEM_CTX_REF,pSignatMem);
      return(ASN1_SIGN_TBS_DATA_DSA_SIGN_ERR);
    }
  }
  pDstBuf[0] = pSignatMem;
  pDstLen[0] = pTmpLen[0];		// set true length
  return(ASN1_OP_OK);
}

/**
* Subroutine MatchDatArrays compares two IDATA_PTR array structures
* for equality (MatchDatArrays). 
* All elements specified must have same contents
* NOTE: no checking on indices/sizes/counters is done
*
*  @param DatArray1 Array 1
*  @param StartIndex1 Index Array 1
*  @param DatArray2 Array 2
*  @param StartIndex2 Index Array 2
*  @param ElementCount number of elements
*  @return int Result ASN1_SAME
* <br>            ASN1_NOT_SAME
*/
extern int MatchDatArrays(IDATA** DatArray1,
			int StartIndex1, IDATA** DatArray2,
			int StartIndex2, int ElementCount)
{
  int Retcode = ASN1_NOT_SAME;

  int Index1 = StartIndex1;
  int Offset1;

  int Index2 = StartIndex2;
  int Offset2;

  int Len;

  char* Base1 = NULL;
  char* Base2 = NULL;

  IDATA* pIdata1;
  IDATA* pIdata2;

  if(ElementCount <= 0) return(Retcode);
  //---------------------------------------------------
  // check if both arrays present
  //---------------------------------------------------
  if(((DatArray1 == NULL) && (DatArray2 != NULL)) ||	// not both present
     ((DatArray1 != NULL) && (DatArray2 == NULL)))
    return(Retcode);
  if(DatArray1 == NULL) return(ASN1_SAME);		// both absent
  //---------------------------------------------------
  // both arrays present, start compare
  //---------------------------------------------------
  do
  {
    pIdata1 = DatArray1[Index1++];
    pIdata2 = DatArray2[Index2++];
    if(((pIdata1 == NULL) && (pIdata2 != NULL)) || // not both absent/present
       ((pIdata1 != NULL) && (pIdata2 == NULL)))
      return(Retcode);

    if(pIdata1 != NULL)					// Elements present
    {
      Base1 = pIdata1->Base;
      Base2 = pIdata2->Base;
      if(((Base1 == NULL) && (Base2 != NULL)) ||  // not both absent/present
         ((Base1 != NULL) && (Base2 == NULL)))
        return(Retcode);
      if(Base1 != NULL)				// data pointers present
      {
        Len = pIdata1->Len;		// get data length
        if(Len != pIdata2->Len)		// not same length
          return(Retcode);
        if(Len != 0)				// data to compare
        {
          Offset1 = (int) pIdata1->Off;
          Offset2 = (int) pIdata2->Off;
          do
          {
            if(Base1[Offset1++] != Base2[Offset2++])
              return(Retcode);
            Len--;
          }while(Len != 0);
        } // data compare
      } // both data present/absent
    } // both elements present/absent
    ElementCount--;
  }while(ElementCount != 0);
  return(ASN1_SAME);
}

extern "C"  int MatchIDATPARRStrucs(IDATPARR* DatArrayDesc1,
			int StartIndex1, IDATPARR* DatArrayDesc2,
			int StartIndex2, int ElementCount)
{
  int Retcode = ASN1_NOT_SAME;

  if(((DatArrayDesc1 == NULL) && (DatArrayDesc2 != NULL)) ||
     ((DatArrayDesc1 != NULL) && (DatArrayDesc2 == NULL)))
    return(Retcode);
  if(DatArrayDesc1 == NULL) return(ASN1_SAME);	// both absent

  if(((StartIndex1 + ElementCount) > DatArrayDesc1->Cnt) ||
     ((StartIndex2 + ElementCount) > DatArrayDesc2->Cnt))
    return(Retcode);

  return(MatchDatArrays(DatArrayDesc1->ppArr, StartIndex1,
			DatArrayDesc2->ppArr, StartIndex2,
			ElementCount));
}

extern "C"  int GenASN1_LenField(char* DstBuf, int DstOff,
					 int DataLen)
{
  int DstIndex = DstOff;

  if((DataLen < 0) || (DataLen > 65535)) return(-1);
  if(DataLen < 0x80)				// 1 Byte used
  {
    DstBuf[DstIndex] = (char) DataLen;
    return(1);
  }
  if(DataLen < 0x100)				// 2 Bytes used
  {
    DstBuf[DstIndex++] = (char) ((unsigned char) 0x81);	// set header
    DstBuf[DstIndex]   = (unsigned char) DataLen;
    return(2);
  }
  DstBuf[DstIndex++] = (char) ((unsigned char) 0x82);	// 3 bytes used
  DstBuf[DstIndex++] = (unsigned char) (DataLen>>8);
  DstBuf[DstIndex] = (unsigned char) DataLen;
  return(3);
}

extern "C"  int DecodeASN1_LenField(char* SrcBuf, int SrcOff,
				int SrcLen, int* DataLen)
{
  int SrcIndex = SrcOff;
  int DataCnt = SrcLen;

  int i;

  if(DataCnt == 0) return(-2);		// out of data
  //-----------------------------------------------------
  // get length field byte len
  //-----------------------------------------------------
  i = (int) SrcBuf[SrcIndex++] & 0xFF;	// get byte
  DataCnt--;				// reduce
  if(i < 0x80)				// 1 Byte only
  {
    if(DataCnt < i) return(-2);		// too few data present
    DataLen[0] = (int) i;
    return(1);				// 1 byte used
  }
  if(i == 0x80)				// indefinite length, special case
  {
    DataLen[0] = -1;
    return(-1);
  }
  //-----------------------------------------------------
  // decode multibyte length field
  //-----------------------------------------------------
  i &= 0x7F;				// get bytecount
  if(i > 3) return(-3);			// length Error

  if(i > DataCnt) return(-2);		// out of data  
  DataCnt -= i;				// reduce length

  DataLen[0] = (int) SrcBuf[SrcIndex++] & 0xFF;	// get byte

  if(i >= 2)
  {
    DataLen[0] <<= 8;			// shift up
    DataLen[0] |= ((int) SrcBuf[SrcIndex++] & 0xFF);	// get byte
  }
  if(i == 3)
  {
    DataLen[0] <<= 8;			// shift up
    DataLen[0] |= ((int) SrcBuf[SrcIndex] & 0xFF);	// get byte
  }

 if(((int) DataCnt & 0x0FFFFFF) < DataLen[0])	// too few data
    return(-2);
  return(i+1);
}
/**
* Subroutine GetASN1_FieldLength decodes ASN.1 length field,
* processes definite A N D indefinite length field sizes (GetASN1_FieldLength).
* Note: 1.) Datacount is limited to 0..65535 bytes !!
*       2.) Input Datacount is checked for enough data for
*	     length field and remaining data !!
*	 3.) Indefinite Length is indicated setting length Bit 31 = 1
*
*  @param SrcBuf pointer to buffer base
*  @param SrcOff Start of data
*  @param SrcLen Length of Available Data
*  @param ASN1Type Type of field to process
*  @param DataLen converted length
*               BIT31 = 1 -> from indef. len,
*               EOC included !!
*
*  @return int LenFieldLen < 0 - Error occurred:
* <br>            -1 : invalid indefinite length
* <br>            -2 : too few data
* <br>            -3 : length field too large
* <br>            >= 0 - number of bytes of header/EOC
*/
static  int GetASN1_FieldLength(char* SrcBuf, int SrcOff,
				int SrcLen, char ASN1Type, int* DataLen)
{
  char ActASN1LeadTag;
  char Octet;

  int Retcode;
  int StartIndex;

  int ProcessLevel;
  int FldLenSize;
  
  //--------------------------------------------------------
  // get the length of the field, check if indefinite length
  //--------------------------------------------------------
  Retcode = DecodeASN1_LenField(SrcBuf,SrcOff,SrcLen,DataLen);
  if(Retcode != -1) return(Retcode);		// not indefinite length/error
// TEST TEST TEST the following Was temporarily removed !!!
  if((ASN1Type & ASN1_CONSTRUCTED_MASK) == 0)	// only allowed for constr.
    return(Retcode);
  //--------------------------------------------------------
  // indefinite length field, special processing required
  //--------------------------------------------------------
  Retcode = -2;					// assume too few data error
  SrcOff++;
  SrcLen--;
  if(SrcLen == 0)
    return(Retcode);		// out of data

  ProcessLevel = 0;
  StartIndex = SrcOff;				// save start of field data
  //---------------------------------------------------------
  // fetch embedded ASN.1 fields and process until EOC
  //---------------------------------------------------------
  for(;;)
  {
    //-------------------------------------------------------
    // Get / Skip ASN1 TAG field
    //-------------------------------------------------------
    ActASN1LeadTag = SrcBuf[SrcOff++];		// get first TAG byte
    SrcLen--;
    if(SrcLen == 0) return(Retcode);		// out of data
    if((ActASN1LeadTag & ASN1_UNIVERSAL_TYPE_MASK) == // high TAG
        ASN1_UNIVERSAL_TYPE_MASK)
    {
      for(;;)					// skip high TAG bytes
      {
        Octet = SrcBuf[SrcOff++];		// get next byte
        SrcLen--;
        if(SrcLen == 0)			// out of data
           return(Retcode);
        if((Octet & 0x80) == 0) break;		// last byte of TAG
      }
    }
    //-------------------------------------------------------
    // Get associated length of field
    //-------------------------------------------------------
    FldLenSize = DecodeASN1_LenField(SrcBuf,SrcOff,SrcLen,DataLen);
    if(FldLenSize < -1)
      return(FldLenSize);	// error occurred
    if(FldLenSize == -1) FldLenSize = 1;	// always 1 byte length
    SrcOff += FldLenSize;
    SrcLen -= FldLenSize;
    //-------------------------------------------------------
    // process field according to ASN1 type
    //-------------------------------------------------------
    if(ActASN1LeadTag == ASN1_UNIVERSAL_EOC)	// EOC
    {
      //-----------------------------------------------------
      // EOC processing ...
      //-----------------------------------------------------
      if(DataLen[0] != 0) return(-1);		// invalid length for EOC !
      if(ProcessLevel == 0)
      {
        DataLen[0] = (SrcOff - StartIndex);	// set length incl. EOC
        if(DataLen[0] < 0) return(-3);		// too many data
        DataLen[0] |= (int) 0x80000000;	// set flag for indefinite
        return(1);				// indefinite length
      }
      ProcessLevel--;				// reduce level
    }
    else
    {
      //-----------------------------------------------------
      // not EOC processing
      //-----------------------------------------------------
      if(DataLen[0] != -1)			// definite length
      {
        SrcOff += (DataLen[0] & 0x0FFFFFF);	// skip field
        SrcLen -= (DataLen[0] & 0x0FFFFFF);	// dto.
      }
      else					// indefinite length
      {
        if((ActASN1LeadTag & ASN1_CONSTRUCTED_MASK) == 0) // not constructed
          return(-1);				// invalid indef. length
        ProcessLevel ++;			// one more EOC required
      }
    }
    //-------------------------------------------------------
    // check if more data present (there must be data !)
    //-------------------------------------------------------
    if(SrcLen == 0)
      return(Retcode);		// out of data
  }
}
/**
* Subroutine CountASN1_Fields retrieves number of entries of
* same given ASN.1 type or ANY-Type in an ASN.1 Sub-Encoding (CountASN1_Fields).
* This is used for further processing of RNDs, Validity and
* Extension processing.
*
* Note: The surrounding structures have already been removed!!
* ____
*
*  @param InpBuf Buffer Base
*  @param InpOffset Start of data
*  @param InpLen Length of data
*  @param ASN1_Type Type to scan for
*  @param Count Number of fields
*               data according to
*               control structure
*  @return ASN1_OP_OK on success, error code otherwise
* <br>            - else Error occurred
*/
static  int CountASN1_Fields(char* InpBuf, int InpOffset,
				        int InpLen, char ASN1_Type,
				        int* Count)
{
  char CurrASN1_Type;

  int Cnt=0;  
  int InpIndex = InpOffset;
  int DataLen;
  int FldLenSize;

  int TmpLen[1];

  Count[0] = 0;				// assume none found
  if((InpLen == 0) || (InpBuf == NULL))
     return(ASN1_OP_OK);		// no data, no fields
  //----------------------------------------------------
  // processing loop
  //----------------------------------------------------
  for(;;)
  {
    InpLen--;				// reduce data count
    if(InpLen == 0)			// only Type Byte, Error
      return(ASN1_CNT_DATA_MISSING);
    CurrASN1_Type = InpBuf[InpIndex++];	// get ASN.1 Type    
//    FldLenSize = DecodeASN1_LenField(InpBuf,InpIndex,InpLen,TmpLen);
    FldLenSize = GetASN1_FieldLength(InpBuf,InpIndex,InpLen,
				     CurrASN1_Type,TmpLen);
    if(FldLenSize < 0)				// error occurred
    {
      if(FldLenSize == -2) return(ASN1_CNT_DATA_MISSING);
      return(ASN1_CNT_FLDLEN_ERR);		// length field in error
    }
    InpIndex += FldLenSize;			// skip length field
    InpLen -= FldLenSize;			// reduce Datacount
    DataLen = (int) TmpLen[0] & 0x0FFFFFF;

    InpIndex += DataLen;
    InpLen -= DataLen; 
    if(ASN1_Type == (char) ((unsigned char) ASN1_RESERVED_OR_ANY)) // match any
      Cnt++;
    else
    {
      if(CurrASN1_Type == ASN1_Type)		// match given
        Cnt++;
    }
    if(InpLen == 0)
    {
      Count[0] = Cnt;
      return(ASN1_OP_OK);
    }
  } // for
}
/**
* GetASN1TypeLenValFromIDATA extracts from a internal represented
* ASN.1 Datastring (with ASN.1 Header) the ASN.1 type, the
* length of the lengthfield and the datalen. Course checks are
* done for plausibility (GetASN1TypeLenValFromIDAT).
* NOTE: in case of indefinite length field the reported size does NOT
*       include the ASN.1 EOC type field
*
*  @param Desc Descriptor
*  @param pASN1Type Extracted type
*  @param pHdrLen Length of lengthfield+Tag
*  @param pDataLen Length of data
*
*  @return ASN1_OP_OK on success, error code otherwise
* <br>            else Error occurred
*/
static  int GetASN1TypeLenValFromIDAT(IDATA* Desc,
			char* pASN1Type, int* pHdrLen,
			int* pDataLen)
{
  int i;

  int Index;

  int Len;
  int DataLen;

  char* Base;

  int TmpDataLen[1];
  //--------------------------------------------------
  // 1. Check presence of IDATA ptr, base and length
  //--------------------------------------------------
  if(Desc == NULL) return(ASN1_HDR_GET_NOT_PRESENT);	// not present
  Base = Desc->Base;
  if(Base == NULL) return(ASN1_HDR_GET_NO_BASE);	// no base pointer
  Len = Desc->Len;
  if(Len == 0)  return(ASN1_HDR_GET_NO_DATA);	// no Data
  //--------------------------------------------------
  // 2. Load Offset, get ASN.1 Type
  //--------------------------------------------------
  Index = (int) Desc->Off;
  pASN1Type[0] = Base[Index++];
  Len--;
  //--------------------------------------------------
  // 3. Get ASN1 Datalength,  check plausibility
  //--------------------------------------------------
//  i = DecodeASN1_LenField(Base, Index, Len, TmpDataLen);
  i = GetASN1_FieldLength(Base, Index, Len, pASN1Type[0], TmpDataLen);
  if(i < 0)					// error occurred
  {
    if(i == -2) return(ASN1_HDR_GET_DATA_INCOMPLETE);
    else return(ASN1_HDR_GET_FLDLEN_ERR);
  }
  pHdrLen[0] = i+1;				// set length of header
  Len -= i;					// reduce Datacount
  DataLen = (int) TmpDataLen[0] & 0xFF;
  if((TmpDataLen[0] & 0x80000000) != 0)		// indefinite case
  {
    DataLen -= 2;
    Len -= 2;
  }
  if(DataLen != Len)				// length error !!
    return(ASN1_HDR_GET_INCONSIST_DATLEN);
  pDataLen[0] = DataLen;
  return(ASN1_OP_OK);
}
//=======================================================================
//StoreOptional_FromAsn1
static  int StoreOptional_FromAsn1(char* InpBuf,
			int* pInpIndex,
			char * CtlArray,IDATA** DatArray,
			int DatArrayIndex, int Flags, int* Stack,
			int CcI, int* pCsI, int* pCaDC, int* pContFlag)
{
  char ASN1Type;
  int Retcode = ASN1_OP_OK;
  int i;

  int CsI  = pCsI[0];
  int CaDC = pCaDC[0];
  int InpIndex = pInpIndex[0];
  int FldLenSize;
  int DataLen;
  int EOCLen;
  IDATA* pDatArray;

  int TmpLen[1];
  //----------------------------------------------------
  // Extract the data now, only store if Data Index present
  // and not constructed
  //----------------------------------------------------
  pContFlag[0] = 0;
  ASN1Type = InpBuf[InpIndex++];		// get type
//  InpIndex++;					// to next byte
  CaDC --;					// reduce length
//  FldLenSize = DecodeASN1_LenField(InpBuf, InpIndex,CaDC,TmpLen);
  FldLenSize = GetASN1_FieldLength(InpBuf,InpIndex,CaDC,ASN1Type,TmpLen);
  if(FldLenSize < 0)				// error occurred
  {
    if(FldLenSize == -2) Retcode = ASN1_TO_INT_DATA_MISSING;
    else Retcode = ASN1_TO_INT_FLDLEN_ERR;
    return(Retcode);
  }
  InpIndex += FldLenSize;			// skip length field
  CaDC -= FldLenSize;				// reduce Datacount

  DataLen = (int) TmpLen[0] & 0x0FFFFFF;

  EOCLen = 0;
  if((TmpLen[0] & 0x80000000) != 0)		// indef. len
  {
    EOCLen = 2;
    DataLen -= 2;
  }
  if((Flags & CONSTRUCT) != 0)			// is constructed, must stack
  {
    CsI += 4;
    Stack[CsI] = (int) Flags & 0xFF;		// save flags
    Stack[CsI+1] = CaDC;			// save current data count
    Stack[CsI+2] = DataLen;			// save next data count
    Stack[CsI+3] = EOCLen;			// save length of EOC
    CaDC = DataLen;				// set new length
    pContFlag[0] = 1;
  }
  else						// not constructed
  {
    if((Flags & DATA_INDEX) != 0)		// do store
    {
      i = CtlArray[CcI+DATA_INDEX_OFF];		// get index
      pDatArray = DatArray[i+DatArrayIndex];	// get Entry pointer
      pDatArray->Base = InpBuf;		// set base
      pDatArray->Off  = (int) InpIndex;	// set offset
      pDatArray->Len  = DataLen;		// set length
      if((Flags & ANY_ASN1) != 0)		// header is also needed
      {
        pDatArray->Off -= (int) (FldLenSize+1); // reduce offset
        pDatArray->Len += (FldLenSize+1); // increase length
      }
      else if((Flags & ZERO_LEAD_FLAG) != 0)	// supress leading zero byte
      {
        if((DataLen > 1) && (InpBuf[InpIndex] == 0)) // enough data/zero
        {
          pDatArray->Off ++;		// skip first byte
          pDatArray->Len --;		// reduce length
        }
      }
    }
    InpIndex += DataLen + EOCLen;		// skip data
    CaDC -= (DataLen + EOCLen);			// subtract data length
  }
  pInpIndex[0] = InpIndex;
  pCaDC[0] = CaDC;
  pCsI[0]  = CsI;
  return(Retcode); 
}
//=======================================================================
//SkipOptionalConstructed
static  int SkipOptionalConstructed(char * CtlArray,int CcI,
				int MaxCcI, int Flags, int* pCcI)
{
  int Retcode = ASN1_OP_OK;

  int TmpFlags = Flags;
  int i=0;
  //----------------------------------------------
  // skip descriptors for optional field if constructed
  //----------------------------------------------
  pCcI[0] = CcI;
  if((TmpFlags & CONSTRUCT) == 0)
    return(Retcode);

  for(;;)
  {
    if(CcI == (MaxCcI-CTL_ENTRY_SIZE)) break;	// no more entries
    CcI += CTL_ENTRY_SIZE;			// to next entry
    TmpFlags = CtlArray[CcI+FLAG_OFFSET];	// get next flags
    if((TmpFlags & X_FIRST) != 0) i++;	// increment
    if((TmpFlags & X_LAST) != 0) i--;		// decrement
    if(i < 0)
    {
      Retcode = ASN1_TO_INT_SKIP_ERR;	 // error occurred
      return(Retcode);
    }
    if((i == 0) && ((TmpFlags & CONSTRUCT) == 0))
      break; // last to skip
  } // skip FOR Loop
  pCcI[0] = CcI;
  return(Retcode);
}  
//=======================================================================
//FromAsn1ProcessStack
static  int FromAsn1ProcessStack(int* Stack, int CcI, int MaxCcI,
		int* pCaDC, int* pCsI, int* pCont, int* pSkip)
{
  int Retcode = ASN1_OP_OK;
  int DataLen;
  int EOCLen;
  char Flags;
  int SkipLen = 0;

  int CaDC = pCaDC[0];
  int CsI  = pCsI[0];
  pSkip[0] = 0;
  //-------------------------------------------------
  // Process the Stack
  //-------------------------------------------------
  pCont[0] = 0;					// assume stop processing
  for(;;)
  {
    if(CaDC != 0)				// data error
    {
      Retcode = ASN1_TO_INT_LEN_ERR;		// set errorcode
      return(Retcode);
    }
    if(CsI < 0)					// empty stack
    {
      if(CcI != (MaxCcI - CTL_ENTRY_SIZE)) // more descriptors, error
      {
        Retcode = ASN1_TO_INT_STACK_ERR;
        return(Retcode);
      }
      break;					// stop processing
    }
    EOCLen   = Stack[CsI+3];			// get EOC saver
    DataLen  = Stack[CsI+2];			// get saved constructed length
    CaDC     = Stack[CsI+1];			// get saved previous length
    Flags    = (char) Stack[CsI];		// get Flags
    CsI -= 4;					// reduce Stack
    CaDC -= (DataLen+EOCLen);			// reduce datacount
    SkipLen += EOCLen;
    if((Flags & X_LAST) == 0)			// not last, exit inner for
    {
      pCont[0] = 1;				// will continue
      break;					// not last
    }
  } // for
  pCaDC[0] = CaDC;
  pCsI[0]  = CsI;
  pSkip[0] = SkipLen;
  return(Retcode);
}

extern "C"  int FromASN1(HMEM_CTX_DEF
				char* InpBuf, int InpOffset, int InpLen,
				char * CtlArray, int EntryCnt,
				IDATA** DatArray, int DatArrayIndex)
{
  char ASN1_Type;				// Current ASN.1 Type 
  char CurrASN1_Type;				// *REAL* ASN.1 Type
  char Flags;					// Current Flags
  char FlagsSave;				// Saved Flags

  IDATA* pDatArray;

  int* Stack;

  int i;
  int InpIndex = InpOffset;

  int CaDC;
  int CsI;
  int CcI;
  int MaxCcI = CTL_ENTRY_SIZE * EntryCnt;

  int ErrCode = ASN1_OP_OK;
  int OuterContFlag = 0;
  int DataLen;
  int FldLenSize;
  int EOCLen;

  int pInpIndex[1];
  int pCaDC[1];
  int pCsI[1];
  int pCcI[1];
  int pContFlag[1];
  int pSkip[1];

  int TmpLen[1];
  //----------------------------------------------------
  // Do some course checks on pointers and length
  //----------------------------------------------------
  if((InpBuf == NULL) || (DatArray == NULL) || (CtlArray == NULL) ||
     (EntryCnt == 0))
    return(ASN1_TO_INT_PARAMERR);
  if(InpLen == 0) return(ASN1_OP_OK);		// strange case !!
  //----------------------------------------------------
  // Allocate temporary Stack: EntryCnt * 3 integers
  //----------------------------------------------------
  Stack = INT_ARRAY_ALLOC(HMEM_CTX_REF,EntryCnt * 4);
  if(Stack == NULL) return(ASN1_TO_INT_ALLOC_ERR);
  //-------------------------------------------------------------------
  // 0. Initialize Indices / lengths
  //-------------------------------------------------------------------
  CcI = - CTL_ENTRY_SIZE;			// invalidate
  CaDC = InpLen;				// full length
  CsI = -4;					// empty Stack
  FlagsSave = 0;				// no Flags
  //----------------------------------------------------
  // 1. outmost FOR loop
  //----------------------------------------------------
  for(;;)
  {
    CcI += CTL_ENTRY_SIZE;			// to next control element
    if(CcI == MaxCcI) break;			// no more Control Entries
    ASN1_Type = CtlArray[CcI + ASN1_TYPE_OFF];	// get type to check
    Flags = (unsigned char) (CtlArray[CcI+FLAG_OFFSET] | FlagsSave); // get flags
    FlagsSave = 0;				// clear saved
    OuterContFlag = 0;
//  CurrASN1_Type = InpBuf[InpIndex];	// WRONG POSITION !!!!!!!
    //--------------------------------------------------
    // Check if Input ASN.1 Type is same as in control
    // element if not optional.
    // If optional different modes possible...
    //--------------------------------------------------
    if((Flags & OPTIONAL) != 0)			// Optional Control ...
    {
      if((CaDC != 0) &&				// data available

        ((((Flags & MUST_MATCH) != 0) &&	// condition 1, must have match
          (InpBuf[InpIndex] == ASN1_Type)) ||

        (((Flags & MUST_MATCH) == 0) &&		// no strict match required

        (((Flags & ANY_ASN1) != 0) ||		// ANY Type will match
         (InpBuf[InpIndex] == ASN1_Type)))))	// Data present,same
      {
        pInpIndex[0] = InpIndex;
        pCaDC[0] = CaDC;
        pCsI[0]  = CsI;
        ErrCode = StoreOptional_FromAsn1(InpBuf, pInpIndex, CtlArray,
			DatArray, DatArrayIndex, Flags, Stack,
			CcI,pCsI, pCaDC, pContFlag);
        if(ErrCode != ASN1_OP_OK)
          break;
        InpIndex = pInpIndex[0];
        CaDC = pCaDC[0];
        CsI  = pCsI[0];
        OuterContFlag = pContFlag[0];		// get continue state
      }
      else					// no data/not same ASN.1
      {
        //----------------------------------------------
        // skip descriptors for optional field, save actual
        // Flag State for post-processing
        //----------------------------------------------
        ErrCode = SkipOptionalConstructed(CtlArray,CcI,MaxCcI,Flags,pCcI);
        if(ErrCode != ASN1_OP_OK)
          break;
        CcI = pCcI[0];				// get new stack index
        //-------------------------------------------------
        // check primary Flags state ...
        //-------------------------------------------------
//        OuterContFlag = 0;			// assume LAST processing
        Flags &= X_ONLY;			// isolate X-State bits
        if((CaDC != 0) && (Flags != X_LAST))	// More Data present, not LAST
        {
          OuterContFlag = 1;			// continue outer for
          if(Flags == X_FIRST)			// keep saved first state
            FlagsSave = Flags;			// save first chain bit
        }  
      } // Optional skip
      //---------------------------------------------------
      // check how to continue
      //---------------------------------------------------
      if((OuterContFlag == 0) && ((Flags & X_LAST) != 0))
      {
        //-------------------------------------------------
        // Last, must process stack ...
        //-------------------------------------------------
        pCaDC[0] = CaDC;
        pCsI[0]  = CsI;
        ErrCode = FromAsn1ProcessStack(Stack, CcI, MaxCcI, pCaDC, pCsI,
				       pContFlag, pSkip);
        if(ErrCode != ASN1_OP_OK)		// error occurred
          break;
        CaDC = pCaDC[0];
        CsI  = pCsI[0];
        InpIndex += pSkip[0];
        if(pContFlag[0] == 0)			// exit outer FOR loop
          break;
      } // Last processing
    }
    else					// not optional !!
    {
      //---------------------------------------------------
      // Control element is not flagged as optional,
      // ASN.1 type must be present and same as expected if not
      // flagged as ANY type
      //---------------------------------------------------
      if(CaDC == 0)				// no more data, error
      {
        ErrCode = ASN1_TO_INT_DATA_MISSING;	// set Error
        break;
      }
      CurrASN1_Type = InpBuf[InpIndex];		// save ASN1 type !!
      CaDC --;					// reduce datacount
      if((InpBuf[InpIndex++] != ASN1_Type) &&	// not same type,
        ((Flags & ANY_ASN1) == 0))		// and any not allowed
      {
        ErrCode = ASN1_TO_INT_WRONG_DATA;	// set Error
        break;
      }
      //-------------------------------------------------
      // get the data, reduce data count
      //-------------------------------------------------
//    FldLenSize = DecodeASN1_LenField(InpBuf, InpIndex,CaDC,TmpLen);
      FldLenSize = GetASN1_FieldLength(InpBuf,InpIndex,CaDC,
				       CurrASN1_Type,TmpLen);
      if(FldLenSize < 0)			// error occurred
      {
        if(FldLenSize == -2)
          ErrCode = ASN1_TO_INT_DATA_MISSING;
        else
          ErrCode = ASN1_TO_INT_FLDLEN_ERR;
        break;				// exit for loop
      }
      InpIndex += FldLenSize;			// skip length field
      CaDC -= FldLenSize;			// reduce Datacount
      DataLen = (int) TmpLen[0] & 0x0FFFFFF;

      EOCLen = 0;
      if((TmpLen[0] & 0x80000000) != 0)		// indef. len
      {
        EOCLen = 2;
        DataLen -= 2;
      }
      //-------------------------------------------------
      // Check how to continue ...
      //-------------------------------------------------
      if((Flags & CONSTRUCT) != 0)		// constructed, must stack..
      {
        CsI += 4;				// increment stack pointer
        Stack[CsI] = (int) Flags & 0xFF;	// save Flags
        Stack[CsI+1] = CaDC;			// save current remaining len
        Stack[CsI+2] = DataLen;			// save total length
        Stack[CsI+3] = EOCLen;			// save EOC
        CaDC = DataLen;				// set new total length
      }
      else					// not constructed
      {      
        //-------------------------------------------------
        // not constructed, save data pointers / length
        //-------------------------------------------------
        if((Flags & DATA_INDEX) != 0)		// pointer present
        {
          i = CtlArray[CcI+DATA_INDEX_OFF];	// get index
          pDatArray = DatArray[i+DatArrayIndex];// get Entry pointer
          pDatArray->Base = InpBuf;	// set base
          pDatArray->Off = (int) InpIndex; // set offset
          pDatArray->Len = DataLen;	// set length
          if((Flags & ANY_ASN1) != 0)		// header is also needed, also
          {					// EOC-Len !!!
            pDatArray->Off -= (int) (FldLenSize+1); // reduce offset
//          IDATA_Len(pDatArray) += (FldLenSize+1); // increase length
            pDatArray->Len += (FldLenSize+1 + EOCLen); // increase length
          }
          else if((Flags & ZERO_LEAD_FLAG) != 0)// supress leading zero byte
          {
            if((DataLen > 1) && (InpBuf[InpIndex] == 0)) // enugh data / zero
            {
              pDatArray->Off ++;		// skip first byte
              pDatArray->Len --;		// reduce length
            }
          }
        }
        //------------------------------------------------------
        // skip processed ASN.1 field, check if last element
        //------------------------------------------------------
        InpIndex += DataLen + EOCLen;		// skip data
        CaDC -= (DataLen + EOCLen);		// subtract data length
        if((Flags & X_LAST) != 0)		// last
        {
          //-------------------------------------------------
          // Last, not constructed, process stack ...
          //-------------------------------------------------
          pCaDC[0] = CaDC;
          pCsI[0]  = CsI;
          ErrCode = FromAsn1ProcessStack(Stack, CcI, MaxCcI, pCaDC, pCsI,
				         pContFlag, pSkip);
          if(ErrCode != ASN1_OP_OK)		// error occurred
            break;
          CaDC = pCaDC[0];
          CsI  = pCsI[0];
          InpIndex += pSkip[0];

          if(pContFlag[0] == 0)			// exit outer FOR loop
            break;
        } // Stack processing
      } // not constructed
    } // not optional
  } // Outmost FOR
  //------------------------------------------------
  // End processing, assure Stack is empty
  //------------------------------------------------
  if((ErrCode == ASN1_OP_OK) && (CsI >= 0))	// still data on stack !
    ErrCode = ASN1_TO_INT_STACK_ERR;
  FREE_ARRAY(HMEM_CTX_REF,Stack);
  return(ErrCode);
}
/**
* Subroutine ToASN1_Phase1 generates from given Data structures
* in internal notation ('Data Elements') and given Control
* structures the ASN.1 header data (the length fields)
* and the total required buffer size (ToASN1_Phase1).
*
*  @param DatArray Array loaded with
*               data according to
*               control structure
*  @param DatArrayIndex First Index to use
*  @param CtlArray Base of Control Structure
*  @param EntryCnt number of entries in
*               Control structure
*  @param HdrDescBuf Header Description buffer
*  @param HdrDescBufOff Start within buffer
*  @param RequiredLen Number of bytes required
*
*  @return ASN1_OP_OK on success, error code otherwise
* <br>            - else Error occurred
*/
static  int ToASN1_Phase1(HMEM_CTX_DEF
		IDATA** DatArray, int DatArrayIndex,
		char * CtlArray, int EntryCnt,
		char* HdrDescBuf, int HdrDescBufOff,
		int* RequiredLen)
{
  char Flags;					// Current Flags
  char ASN1_Type;
  int* Stack;

  IDATA* pDatArray;

  int ErrCode = ASN1_OP_OK;
  int CnDC;					// Current Node-List DataCount
  int CaDC;					// Curr. accumulated DataCount
  int CnI;					// Current Node (control) index
  int CcI;					// Control Index
  int CsI;					// Stack Index
  int MaxCcI = EntryCnt * CTL_ENTRY_SIZE;	// Max. Index

  int ContFlag;
  int HdrLen;
  int i,j,k;
  //----------------------------------------------------
  // Do some course checks on pointers and length
  //----------------------------------------------------
  if((DatArray == NULL) || (CtlArray == NULL) || (HdrDescBuf == NULL) ||
     (EntryCnt == 0))
    return(INT_TO_ASN1_PARAMERR_PHASE1);
  RequiredLen[0] = 0;
  //----------------------------------------------------
  // Allocate temporary Stack: EntryCnt * 2 integers
  //----------------------------------------------------
  Stack = INT_ARRAY_ALLOC(HMEM_CTX_REF,EntryCnt * 2);
  if(Stack == NULL) return(INT_TO_ASN1_ALLOC_ERR);
  //-------------------------------------------------------------------
  // 0. Initialize Indices / lengths, preset length Array with not used
  //-------------------------------------------------------------------
  CcI = (-CTL_ENTRY_SIZE);			// to first Element
  CaDC = -1;					// no accumulated length
  CsI = -2;					// empty Stack
  i = EntryCnt*HDR_ENTRY_SIZE;			// set top length field index+1
  do
  {
    i = i - HDR_ENTRY_SIZE;			// pre-decrement
    HdrDescBuf[i+HdrDescBufOff+HDR_LEN_FLD_LEN_OFF] =
	 (char) ((unsigned char) 0xFF);			// set invalid
  } while(i > 0);
  //----------------------------------------------------
  // 1. outmost FOR loop
  //----------------------------------------------------
  for(;;)
  {
    CcI += CTL_ENTRY_SIZE;			// to next control element
    if(CcI == MaxCcI) break;			// no more Control Entries
    Flags = CtlArray[CcI+FLAG_OFFSET];		// get the flags
    CnDC = -1;					// preload length counter
    //-----------------------------------------------------------
    // check if constructed control, if so, must stack if present
    //-----------------------------------------------------------
    if((Flags & CONSTRUCT) != 0)		// constructed
    {
      //==========================================================
      // constructed control, check if data present (for optional)
      //==========================================================
      if((Flags & DATA_INDEX) != 0)		// data may be there, check
      {
        i = CtlArray[CcI + DATA_INDEX_OFF];	// get data array index
        j = 1;					// preset check range
//-------------------------------------------------

//-------------------------------------------------

        k = i + j - 1 + DatArrayIndex;		// set top check index
        do
        {
          if(DatArray[k--]->Base == NULL)	// not present
            break;
          j--;					// decrement
        }while(j != 0);

        if(j != 0)				// no data/not all present
        {
          if((Flags & OPTIONAL) == 0)		// not optional !!
          {
            ErrCode = INT_TO_ASN1_DATA_MISSING;
            break;
          }
          //----------------------------------------------
          // optional field, skip descriptors for constructed
          //----------------------------------------------
          i = 0;				// init Counter
          for(;;)
          {
            ContFlag = 0;			// assume end outmost loop
            if(CcI == (MaxCcI-CTL_ENTRY_SIZE)) break;	// no more entries
            CcI += CTL_ENTRY_SIZE;		// to next
            Flags = CtlArray[CcI+FLAG_OFFSET];	// get next flags
            if((Flags & X_FIRST) != 0) i++;	// increment
            if((Flags & X_LAST) != 0) i--;	// decrement
            if(i < 0)
            {
              ErrCode = INT_TO_ASN1_SKIP_ERR;	// error occurred
              break;
            }
            ContFlag = 1;
            if((i == 0) && ((Flags & CONSTRUCT) == 0)) break;
          } // skip FOR Loop
          if(ContFlag != 0) continue;		// more ctrl elements
          break;				// no more controls/Error !!
        } // No Data Check
      } // No data Index or all data present
      //---------------------------------------------------------------------
      // constructed control, no data required / all data present, must stack
      //---------------------------------------------------------------------
      CsI += 2;					// to next Stack Entry
      Stack[CsI] = CcI;				// Stack actual Index
      Stack[CsI+1] = CaDC;			// Stack accumulated count
      CaDC = -1;				// as a new root starts !!!
      continue;					// to next Entry
    }
    else					// not constructed
    {
      //==================================================
      // end node control, do not stack, process direct !!
      //==================================================
      //------------------------------------------------
      // process data of End-Node (if present !)
      //------------------------------------------------
      i = CtlArray[CcI+DATA_INDEX_OFF];		// get index to data
      pDatArray = DatArray[i+DatArrayIndex];	// get pointer
      if(pDatArray->Base == NULL)		// no data, check if optional
						// or NULL ASN.1 Type
      {
        ASN1_Type = CtlArray[CcI+ASN1_TYPE_OFF];// get the ASN.1 type
        if(((Flags & OPTIONAL) == 0) &&		// must have data,
           (ASN1_Type != ASN1_UNIVERSAL_NULL))	// or must be NULL field
        {
          ErrCode = INT_TO_ASN1_DATA_MISSING;	// report error
          break;
        }
        //------------------------------------------------
        // optional Field / NULL Field
        //------------------------------------------------
        if(ASN1_Type != ASN1_UNIVERSAL_NULL)
          CnDC = -1;				// no data present, optional
        else
        {					// NULL-Field
          CnDC = 0;				// no data
          HdrLen = GenASN1_LenField(HdrDescBuf,i+1,CnDC);
          if(HdrLen < 0)
          {
            ErrCode = INT_TO_ASN1_LEN_ERR;
            break;
          }
          HdrDescBuf[i] = (unsigned char) HdrLen;	// insert length in bytes
          CnDC += (HdrLen + 1);			// sum up length
        }
      }
      else					// data present
      {
        //------------------------------------------------
        // not an optional End-Node, data present, process
        //------------------------------------------------
        CnDC = pDatArray->Len;		// get data length
        i = (CcI / CTL_ENTRY_SIZE) * HDR_ENTRY_SIZE + // get destination index
            HdrDescBufOff;
        //------------------------------------------------
        // generate length field bytes for not RAW End Node
        //------------------------------------------------
        if((Flags & ANY_ASN1) == 0)      	// regular field
        {
          if((Flags & ZERO_LEAD_FLAG) != 0)	// special case !!
          {
            ASN1_Type = CtlArray[CcI+ASN1_TYPE_OFF];  // get ASN.1 type
            if(ASN1_Type == ASN1_UNIVERSAL_BITSTRING) // always insert zero !!
              CnDC++;
            else if((ASN1_Type == ASN1_UNIVERSAL_INTEGER) &&
                  ((pDatArray->Base[pDatArray->Off] & 0x80) !=
                    0))
              CnDC++;
          }
          HdrLen = GenASN1_LenField(HdrDescBuf,i+1,CnDC);
          if(HdrLen < 0)
          {
            ErrCode = INT_TO_ASN1_LEN_ERR;
            break;
          }
          HdrDescBuf[i] = (unsigned char) HdrLen;	// insert length in bytes
          CnDC += (HdrLen + 1);			// sum up length
        }
        else HdrDescBuf[i] = (char) ((unsigned char) ANY_ASN1_LEN_FLD_LEN); // ANY-Type
      } // End node header processing
      //------------------------------------------------
      // Endnode processed, check how to continue ...
      //------------------------------------------------
      if((Flags & X_FIRST) != 0) CaDC = CnDC;	// FIRST/ONLY
      else					// MIDDLE/LAST
      {
        if(CnDC != -1)				// data to add up present
        {
          if(CaDC == -1) CaDC = CnDC;		// set current data as sum
          else CaDC += CnDC;			// sum up
        }
      }
      if((Flags & X_LAST) == 0) continue;	// NOT LAST in X-Chain
    } // not constructed
    //------------------------------------------------
    // 2. End of X-Chain on Level Y reached, process Stack
    //------------------------------------------------
    for(;;)
    {
      ContFlag = 0;				// assume end outer for loop
      CnDC = CaDC;				// save current sum
      if(CsI < 0) break;			// no stacked Data 
      CaDC = Stack[CsI +1];			// get from Stack
      CnI = Stack[CsI];				// dto.
      CsI -= 2;					// decrement stack pointer
      if(CnDC != -1)				// data to add up
      {
        if(CaDC == -1) CaDC = CnDC;		// set as sum
	else CaDC += CnDC;			// sum up
      }
      //------------------------------------------------
      // generate length field bytes for Entry if present
      //------------------------------------------------
      if(CnDC != -1)				// there are really bytes
      {
        i = (CnI / CTL_ENTRY_SIZE) * HDR_ENTRY_SIZE + // get destination index
          HdrDescBufOff;
        HdrLen = GenASN1_LenField(HdrDescBuf,i+1,CnDC);
        if(HdrLen < 0)
        {
          ErrCode = INT_TO_ASN1_LEN_ERR;
          break;
        }
        HdrDescBuf[i] = (unsigned char) HdrLen;		// insert length in bytes
        CaDC += (HdrLen + 1);			// sum up length
      }
      //------------------------------------------------
      // check how to continue
      //------------------------------------------------
      Flags = CtlArray[CnI+FLAG_OFFSET];	// get flags      
      if((Flags & X_LAST) != 0) continue;	// was last, more stack data
      ContFlag = 1;				// may continue outmost loop
      break;					// not last
    } // Step 2 FOR loop
    if(ContFlag != 0) continue;			// go on processing
    //------------------------------------------------
    // 3. End of X-Chain on Level Y reached, empty Stack
    //------------------------------------------------
    if((ErrCode == ASN1_OP_OK) &&		// no error
       (CcI != (MaxCcI-CTL_ENTRY_SIZE))) continue;// more Control Entries
    if((ErrCode != ASN1_OP_OK) ||		// we had an error
       (CaDC == -1)) RequiredLen[0] = 0;	// or very strange case
    else RequiredLen[0] = CaDC;			// report length
    FREE_CARRAY(HMEM_CTX_REF,Stack);
    return(ErrCode);
  } // outmost for loop !!
  //--------------------------------------------------
  // no more control elements  o r  Error
  //--------------------------------------------------
  if(ErrCode == ASN1_OP_OK)			// no error
  {
    //--------------------------------------------------
    // 4. no more control elements, check stack !!
    //--------------------------------------------------
    for(;;)
    {
      if(CsI < 0) break;			// no more stack elements
      i = CaDC;					// save
      CaDC = Stack[CsI+1];			// get from Stack
      CnI = Stack[CsI];				// dto.
      CsI -= 2;					// reduce Stack
      if(i != -1)				// data to add up
      {
        if(CaDC == -1) CaDC = i;		// set as sum
        else CaDC += i;				// sum up
      }
      //------------------------------------------------
      // generate length field bytes for Entry if present
      //------------------------------------------------
      if(CaDC != -1)				// there are really bytes
      {
        i = (CnI / CTL_ENTRY_SIZE) * HDR_ENTRY_SIZE + // get destination index
            HdrDescBufOff;
        HdrLen = GenASN1_LenField(HdrDescBuf,i+1,CaDC);
        if(HdrLen < 0) return(INT_TO_ASN1_LEN_ERR);
        HdrDescBuf[i] = (unsigned char) HdrLen;		// insert length in bytes
        CaDC += (HdrLen + 1);			// sum up length
      }
      //------------------------------------------------
      // check how to continue
      //------------------------------------------------
      Flags = CtlArray[CnI+FLAG_OFFSET];	// get flags      
      if((Flags & X_LAST) != 0) continue;	// was last, more stack data
      //------------------------------------------------
      // Last Bit not set, check if at start of description
      // and Stack empty -> no surrounding field !!
      //------------------------------------------------
      if((CsI < 0) && (CnI == 0)) break;	// empty stack and at first
      FREE_CARRAY(HMEM_CTX_REF,Stack);
      return(INT_TO_ASN1_PHASE1_ERR);
    } // Step 4 FOR loop
  } // no Error Post-Processing
  //------------------------------------------------
  // 5. End of processing, check error
  //------------------------------------------------
  if((CaDC == -1) || (ErrCode != ASN1_OP_OK))
    RequiredLen[0] = 0;				// strange case/Error
  else RequiredLen[0] = CaDC;			// report length
  FREE_CARRAY(HMEM_CTX_REF,Stack);
  return(ErrCode);
}
/**
* Subroutine ToASN1_Phase2 generates from preprocessed
* Control and data structures ASN.1 output (ToASN1_Phase2).
* NOTE: 1) the header descriptor buffers must have been loaded !!
*       2) the length of the Destination array is assumed to be
*	    sufficient for the output !!
*
*  @param DatArray Array loaded with
*               data according to
*               control structure
*  @param DatArrayIndex First Index to use
*  @param CtlArray Base of Control Structure
*  @param EntryCnt number of entries in
*               Control structure
*  @param HdrDescBuf Header Description buffer
*  @param HdrDescBufOff Offset into buffer
*  @param DstBuf Base of Destination
*  @param DstOff Start of data
*  @param TotalLen Number of bytes generated
*
*  @return ASN1_OP_OK on success, error code otherwise
* <br>            - else Error occurred
*/
static  int ToASN1_Phase2(IDATA** DatArray, int DatArrayIndex,
				     char * CtlArray,
				     int EntryCnt, char* HdrDescBuf,
				     int HdrDescBufOff,
				     char* DstBuf, int DstOff,
				     int* TotalLen)
{
  char Flags;
  char ASN1_Type;
  int DstIndex = DstOff;

  int ChI = 0;				// Current header array index
  int CcI = 0;				// Current control array index
  int CdI = 0;				// current Data Array Index

  int HdrLenFldLen;
  int i;
  int CopyLen;
  int CopyStart;

  char* CopyBase;
  //----------------------------------------------------
  // Do some course checks on pointers and length
  //----------------------------------------------------
  if((DatArray == NULL) || (CtlArray == NULL) || (HdrDescBuf == NULL) ||
     (EntryCnt == 0) || (TotalLen[0] == 0))
    return(INT_TO_ASN1_PARAMERR_PHASE2);
  //----------------------------------------------------
  // Generate the ASN.1 Output Data
  //----------------------------------------------------
  do
  {
						 // get length / special state
    HdrLenFldLen = (int) HdrDescBuf[ChI + HDR_LEN_FLD_LEN_OFF +
                                    HdrDescBufOff] & 0xFF;
    if(HdrLenFldLen != UNUSED_LEN_FLD_LEN)	// field is used, process
    {
      //----------------------------------------------------------
      // Generate ASN.1 header if not already present in data !!
      //----------------------------------------------------------
      ASN1_Type = CtlArray[CcI + ASN1_TYPE_OFF]; // get ASN.1 Type
      if(HdrLenFldLen != ANY_ASN1_LEN_FLD_LEN)	
      {
        DstBuf[DstIndex++] = ASN1_Type;		// set ASN.1 Type
        i = ChI + HDR_LEN_FLD_OFF+HdrDescBufOff;// set field-length start
        do
        {
          DstBuf[DstIndex++] = HdrDescBuf[i++];	// copy length field
          HdrLenFldLen--;			// reduce count
        }while(HdrLenFldLen != 0);
      }  
      //----------------------------------------------------------
      // if field is NOT Constructed and HAS data, copy to destination
      //----------------------------------------------------------
      Flags = CtlArray[CcI + FLAG_OFFSET];	// get associated flags
      if(((Flags & CONSTRUCT) == 0) &&		// not constructed
         ((Flags & DATA_INDEX) != 0))		// data present
      {
        CdI = CtlArray[CcI + DATA_INDEX_OFF] +	// get array index
              DatArrayIndex;
        CopyBase  = DatArray[CdI]->Base;	// get source base
        CopyLen   = DatArray[CdI]->Len;	// get source copy length
        CopyStart = (int) DatArray[CdI]->Off;	// get source start offset
        if((Flags & ZERO_LEAD_FLAG) != 0)	// special case
        {
          if((ASN1_Type == ASN1_UNIVERSAL_BITSTRING) || // is bitstring
            ((ASN1_Type == ASN1_UNIVERSAL_INTEGER) && 	// is Integer
                  ((CopyBase[CopyStart] & 0x80) != 0)))	// with neg. bit
            DstBuf[DstIndex++] = 0;		    // always leading zero
        }
        for(;CopyLen != 0;CopyLen--)		// null data are possible !!
          DstBuf[DstIndex++] = CopyBase[CopyStart++];	// copy the RAW data
      }
    } // field processed
    //----------------------------------------------------------
    // Field processed, check if more present ...
    //----------------------------------------------------------
    CcI += CTL_ENTRY_SIZE;			// to next control field
    ChI += HDR_ENTRY_SIZE;			// to next header field
    EntryCnt--;					// reduce count
  } while(EntryCnt != 0);
  TotalLen[0] = DstIndex - DstOff;		// report bytes generated
  return(ASN1_OP_OK);
}

extern "C"  int ToASN1(HMEM_CTX_DEF
			      IDATA** DatArray, int DatArrayIndex,
			      char * CtlArray,
			      int EntryCnt, char** DstBuf, int* DataLen)
{
  int i;

  char* pHdrBuf;
  int TmpLen[1];

  DataLen[0] = 0;
  if(EntryCnt <= 0) return(ASN1_OP_OK);		// no action required
  //-------------------------------------------------------------
  // Allocate Header Buffer for Phase 1
  //-------------------------------------------------------------
  pHdrBuf = BIT8_ARRAY_ALLOC(HMEM_CTX_REF,HDR_ENTRY_SIZE * EntryCnt);
  if(pHdrBuf == NULL) return(INT_TO_ASN1_ALLOC_ERR);
  //-------------------------------------------------------------
  // Perform Phase1
  //-------------------------------------------------------------
  i = ToASN1_Phase1(HMEM_CTX_REF1
		    DatArray,DatArrayIndex,
                    CtlArray,EntryCnt,
                    pHdrBuf,0,TmpLen);
  if(i != ASN1_OP_OK)
  {
    FREE_CARRAY(HMEM_CTX_REF,pHdrBuf);
    return(i);
  }
  //-------------------------------------------------------------
  // Allocate destination buffer for Phase 2
  //-------------------------------------------------------------
  DstBuf[0] = BIT8_ARRAY_ALLOC(HMEM_CTX_REF,TmpLen[0]);
  if(DstBuf[0] == NULL)
  {
    FREE_CARRAY(HMEM_CTX_REF,pHdrBuf);
    return(INT_TO_ASN1_ALLOC_ERR);
  }
  //-------------------------------------------------------------
  // Process phase 2
  //-------------------------------------------------------------
  i = ToASN1_Phase2(DatArray, DatArrayIndex, CtlArray, EntryCnt, pHdrBuf,0,
		    DstBuf[0],0, TmpLen);
  if(i != ASN1_OP_OK)
  {
    FREE_CARRAY(HMEM_CTX_REF,pHdrBuf);
    FREE_CARRAY(HMEM_CTX_REF,DstBuf[0]);
    return(i);
  }
  DataLen[0] = TmpLen[0];
  FREE_CARRAY(HMEM_CTX_REF,pHdrBuf);
  return(ASN1_OP_OK);
}

extern "C"  int FromASN1_IBMContainer(HMEM_CTX_DEF
			char* InpBuf, int InpOffset,
			int InpLen,
			IDATPARR** pDatArrayDesc, int* DatArraySize,
                        int* SubErrCode)
{
  int i;

  IDATPARR* pTmpDatArrayDesc[1];
  IDATPARR* DatArrayDesc;
  IDATA** DatArray;

  pDatArrayDesc[0] = NULL;			// invalidate
  DatArraySize[0] = 0;			// dto.
  //---------------------------------------------------------------
  // allocate the required IDATA ptr array and the elements
  //---------------------------------------------------------------
  i =  AllocIDATPARR_Struc(HMEM_CTX_REF1
		pTmpDatArrayDesc,IBM_CONTAINER_MAX_DATA_INDEX);
  if(i != ASN1_OP_OK) return(ASN1_IBM_CONT_TO_INT_ALLOC_ERR);
  DatArrayDesc = pTmpDatArrayDesc[0];
  DatArray = DatArrayDesc->ppArr;
  //---------------------------------------------------------------
  // Split the Container contents...
  //---------------------------------------------------------------
  i = FromASN1(HMEM_CTX_REF1
	       InpBuf,InpOffset,InpLen,
               (char *) IBMContainerCtl,IBM_CONTAINER_CTL_CNT,
               DatArray,0);
  if(i != ASN1_OP_OK)
  {
    FreeIDATPARR_Struc(HMEM_CTX_REF1 DatArrayDesc);
    SubErrCode[0] = i;
    return(ASN1_IBM_CONT_TO_INT_ERR);    
  }
  //-------------------------------------------------------------------
  // Check if exactly one TAG was present(Cert-Req, Std-Cert, Spc-Cert)
  //-------------------------------------------------------------------
  i = 0;
  if(DatArray[IBM_REQ_CERT_DATA_INDEX]->Base != NULL) i++;
  if(DatArray[IBM_STD_CERT_DATA_INDEX]->Base != NULL) i++;
  if(DatArray[IBM_SPC_CERT_DATA_INDEX]->Base != NULL) i++;
  if(i != 1)
  {
    FreeIDATPARR_Struc(HMEM_CTX_REF1 DatArrayDesc);
    SubErrCode[0] = 0;
    return(ASN1_IBM_CONT_INV_CONT_ERR);    
  }
  pDatArrayDesc[0] = DatArrayDesc;		// set valid
  DatArraySize[0] = IBM_CONTAINER_MAX_DATA_INDEX;// dto.
  return(ASN1_OP_OK);
}

extern "C"  int FromASN1_Cert(HMEM_CTX_DEF
			char* InpBuf, int InpOffset, int InpLen,
			IDATPARR** pDatArrayDesc, int* DatArraySize,
                        int* SubErrCode)
{
  int i;

  IDATPARR* pTmpDatArrayDesc[1];
  IDATPARR* DatArrayDesc;
  IDATA** DatArray;

  pDatArrayDesc[0] = NULL;			// invalidate
  DatArraySize[0] = 0;			// dto.
  //---------------------------------------------------------------
  // allocate the required IDATA ptr array and the elements
  //---------------------------------------------------------------
  i =  AllocIDATPARR_Struc(HMEM_CTX_REF1
		pTmpDatArrayDesc,X509_CERT_MAX_DATA_INDEX);
  if(i != ASN1_OP_OK) return(ASN1_CERT_TO_INT_ALLOC_ERR);
  DatArrayDesc = pTmpDatArrayDesc[0];
  DatArray = DatArrayDesc->ppArr;
  //---------------------------------------------------------------
  // Split the Certificate...
  //---------------------------------------------------------------
  i = FromASN1(HMEM_CTX_REF1
	       InpBuf,InpOffset,InpLen,
               (char *) X509CertCtl,X509_CERT_CTL_CNT,
               DatArray,0);
  if(i != ASN1_OP_OK)
  {
    FreeIDATPARR_Struc(HMEM_CTX_REF1 DatArrayDesc);
    SubErrCode[0] = i;
    return(ASN1_CERT_TO_INT_ERR);    
  }
  pDatArrayDesc[0] = DatArrayDesc;		// set valid
  DatArraySize[0] = X509_CERT_MAX_DATA_INDEX;	// dto.
  return(ASN1_OP_OK);
}

extern "C" int FromASN1_TBS_Cert(HMEM_CTX_DEF
			char* InpBuf, int InpOffset,
			int InpLen, IDATPARR** pDatArrayDesc,
			int* DatArraySize,
			int* SubErrCode)
{
  int i;
  IDATPARR* pTmpDatArrayDesc[1];
  IDATPARR* DatArrayDesc;

  IDATA** DatArray;

  pDatArrayDesc[0] = NULL;		// invalidate
  DatArraySize[0] = 0;			// dto.
  //---------------------------------------------------------------
  // allocate the required IDATA ptr array and the elements
  //---------------------------------------------------------------
  i =  AllocIDATPARR_Struc(HMEM_CTX_REF1
		pTmpDatArrayDesc,X509_TBS_CERT_MAX_DATA_INDEX);
  if(i != ASN1_OP_OK) return(ASN1_TBS_CERT_TO_INT_ALLOC_ERR);
  DatArrayDesc = pTmpDatArrayDesc[0];
  DatArray = DatArrayDesc->ppArr;
  //---------------------------------------------------------------
  // Split the Certificate...
  //---------------------------------------------------------------
  i = FromASN1(HMEM_CTX_REF1
	       InpBuf,InpOffset,InpLen,
               (char *) X509_TBSCertCtl,X509_TBS_CERT_CTL_CNT,
               DatArray,0);
  if(i != ASN1_OP_OK)
  {
    FreeIDATPARR_Struc(HMEM_CTX_REF1 DatArrayDesc);
    SubErrCode[0] = i;
    return(ASN1_TBS_CERT_TO_INT_ERR);    
  }
  pDatArrayDesc[0] = DatArrayDesc;			// set valid
  DatArraySize[0] = X509_TBS_CERT_MAX_DATA_INDEX;	// dto.
  return(ASN1_OP_OK);
}

extern "C"  int FromASN1_SubStr(HMEM_CTX_DEF
			char* InpBuf, int InpOffset,
			int InpLen, char * CtlArray, int EntryCnt,
			int DatEntryCnt, IDATPARR** pDatArrayDesc,
			int* DatArraySize)
{
  char ASN1_Type;

  int i; 
  int ErrCode;
  int Count=0;
  int FldLen;
  int FldLenSize;
  int DatIndex = 0;
  int DatArrayMaxSize;

  IDATPARR* pTmpArrayDesc[1];
  IDATPARR* DatArrayDesc = NULL;
  IDATA** DatArray = NULL;

  int TmpCnt[1];
  int TmpLen[1];

  DatArraySize[0] = 0;

  //----------------------------------------------------
  // Get ASN.1 Type from Control Structure first entry
  // and Number of required Data Entries per Field from
  // Control structure
  //----------------------------------------------------
  ASN1_Type = CtlArray[ASN1_TYPE_OFF];	// get requested type
  if(DatEntryCnt == 0) return(ASN1_SUB_TO_INT_PARAM_ERR);
  //----------------------------------------------------
  // Get number of Fields, calculate allocate sizes
  //----------------------------------------------------
  ErrCode = CountASN1_Fields(InpBuf,InpOffset,InpLen, ASN1_Type,TmpCnt);
  if(ErrCode != ASN1_OP_OK) return(ErrCode);
  Count = TmpCnt[0];
  if(Count == 0) return(ASN1_OP_OK);

  DatArrayMaxSize = (Count * DatEntryCnt);
  for(;;)					// Error processing FOR loop
  {
    //----------------------------------------------------
    // Allocate IDATA Array and Elements
    //----------------------------------------------------
    i = AllocIDATPARR_Struc(HMEM_CTX_REF1
			    pTmpArrayDesc,DatArrayMaxSize);
    if(i != ASN1_OP_OK)
    {
      ErrCode = ASN1_SUB_TO_INT_ALLOC_ERR;
      break;
    }
    DatArrayDesc = pTmpArrayDesc[0];
    DatArray = DatArrayDesc->ppArr;
    //----------------------------------------------------
    // processing loop
    //----------------------------------------------------
    for(;;)
    {
      //--------------------------------------------------
      // Get length of field for parsing
      //--------------------------------------------------
//    FldLenSize = DecodeASN1_LenField(InpBuf,InpOffset+1,InpLen-1,TmpLen);
      FldLenSize = GetASN1_FieldLength(InpBuf,InpOffset+1,InpLen-1,
					ASN1_Type,TmpLen);
      if(FldLenSize < 0)			// error occurred
      {
        if(FldLenSize == -2) ErrCode = ASN1_SUB_TO_INT_DATA_MISSING;
        else ErrCode = ASN1_SUB_TO_INT_FLDLEN_ERR;
        break;					// exit for loop
      }
      FldLen = FldLenSize + (int) (TmpLen[0] & 0x0FFFFFF) + 1;
      ErrCode = FromASN1(HMEM_CTX_REF1
			 InpBuf,InpOffset,FldLen,CtlArray,
		         EntryCnt,DatArray,DatIndex);
      if(ErrCode != ASN1_OP_OK) break;
      DatIndex += DatEntryCnt;			// to next
      InpOffset += FldLen;
      InpLen -= FldLen;

      Count--;
      if(Count == 0) break;
    } // inner FOR
    break;
  } // outer FOR
  //-------------------------------------------------------
  // free buffers if error occurred
  //-------------------------------------------------------
  if(ErrCode != ASN1_OP_OK)
  {
    FreeIDATPARR_Struc(HMEM_CTX_REF1 DatArrayDesc);
    pDatArrayDesc[0] = NULL;
  }
  else
  {
    DatArraySize[0] = DatArrayMaxSize;
    pDatArrayDesc[0] = DatArrayDesc;
  }

  return(ErrCode);
}

extern "C"  int ToASN1_SubStr(HMEM_CTX_DEF
			IDATA** DatArray,
			int DatArrayIndex, int DatArrayCnt,
			char * CtlArray, int EntryCnt, int DatEntryCnt,
			char** pDstBuf, int* DstLen)
{
  char* DstBuf=NULL;

  int i; 
  int ErrCode=ASN1_OP_OK;

  int DatIndex = DatArrayIndex;

  int DstIndex = 0;
  int TotalDstLen = 0;

  int HdrBufIndex = 0;
  int HdrBufSize;
  int HdrBufMaxSize;

  int Count;				// number of entries to process
  int PhaseCount;			// number of entries per phase

  char* HdrBuf;
  int TmpLen[1];

  pDstBuf[0] = NULL;
  DstLen[0] = 0;
  //----------------------------------------------------
  // First check DataArray Entry count
  //----------------------------------------------------
  Count = DatArrayCnt / DatEntryCnt;		// calculate processing count
  if((Count == 0) ||				// no count
     ((Count * DatEntryCnt) != DatArrayCnt))	// not same as requested
    return(ASN1_INT_TO_SUB_PARAM_ERR);		// error occurred
  //----------------------------------------------------
  // Get ASN.1 Type from Control Structure first entry,
  // number of required HDR-Buffer data per entry and
  // total Number of required Header buffer Entries
  //----------------------------------------------------
  HdrBufSize = EntryCnt * CTL_ENTRY_SIZE;	// number of elements 
  HdrBufMaxSize = HdrBufSize * Count;		// total number of buffer data
  //----------------------------------------------------
  // Allocate Header Buffer Structure
  //----------------------------------------------------
  HdrBuf = BIT8_ARRAY_ALLOC(HMEM_CTX_REF,HdrBufMaxSize * HDR_ENTRY_SIZE);
  if(HdrBuf == NULL) return(ASN1_INT_TO_SUB_ALLOC_ERR); // error occurred
  for(;;)					// Error Processing FOR
  {
    //----------------------------------------------------
    // Process Phase 1 (Header Length Generation) for each
    // given Data Array Element entry and add up size of each
    // processed element for end processing the elements.
    //----------------------------------------------------
    PhaseCount = Count;
    do
    {
      i = ToASN1_Phase1(HMEM_CTX_REF1
			DatArray,DatIndex,CtlArray,EntryCnt,
                        HdrBuf,HdrBufIndex,TmpLen);
      if(i != ASN1_OP_OK)
      {
        ErrCode = ASN1_INT_TO_SUB_ERR;
        break;
      }
      TotalDstLen += TmpLen[0];			// calculate new size ...
      PhaseCount --;
      DatIndex += DatEntryCnt;
      HdrBufIndex += HdrBufSize;
    }while(PhaseCount != 0);
    if(ErrCode != ASN1_OP_OK) break;		// leave processing FOR loop
    //----------------------------------------------------
    // Allocate required Destination buffer for processing
    //------------------------------------------------------
    DstBuf = BIT8_ARRAY_ALLOC(HMEM_CTX_REF,TotalDstLen);
    if(DstBuf == NULL)
    {
      ErrCode = ASN1_INT_TO_SUB_DST_ALLOC_ERR; // error occurred
      break;
    }
    //----------------------------------------------------
    // Generate the ASN.1 Substrings
    //------------------------------------------------------
    PhaseCount = Count;				// setup counter
    DatIndex = DatArrayIndex;			// set base index
    TotalDstLen = 0;				// set new size zero
    HdrBufIndex = 0;				// dto.
    do
    {
      i = ToASN1_Phase2(DatArray, DatIndex,
                        CtlArray, EntryCnt,
			HdrBuf, HdrBufIndex,
		        DstBuf, DstIndex, TmpLen);
      if(i != ASN1_OP_OK)
      {
        ErrCode = ASN1_INT_TO_SUB_DST_CONV_ERR; // error occurred
        break;
      }
      PhaseCount --;
      DatIndex += DatEntryCnt;
      HdrBufIndex += HdrBufSize;
      TotalDstLen += TmpLen[0];
      DstIndex += TmpLen[0];
    }while(PhaseCount != 0);
    break;
  }
  //------------------------------------------------------
  // free header buffer (no longer required...
  //------------------------------------------------------
  FREE_CARRAY(HMEM_CTX_REF,HdrBuf);
  //------------------------------------------------------
  // check if error occurred...
  //------------------------------------------------------
  if(ErrCode != ASN1_OP_OK)				// we had an error...
  {
    FREE_CARRAY(HMEM_CTX_REF,DstBuf);
  }
  else
  {
    pDstBuf[0] = DstBuf;		// transfer buffer
    DstLen[0] = TotalDstLen;		// and number of bytes
  }
  return(ErrCode);
}
/**
* Generates data structures in internal
* notation ('Data Elements') from given ASN.1 encoded RDN substring
* input byte stream(FromASN1_RDN). The entries must be of same type (SEQ).
*
* Does not copy input data.     
*
*  @param InpBuf ASN.1 datastream base
*  @param InpOffset Start of data
*  @param InpLen Length of data
*  @param pDatArrayDesc Pointer for generated structure
*  @param DatArraySize Number of elements generated
*  @param SubErrCode Error code from higher level
*
*  @return ASN1_OP_OK on success, error code otherwise
*/
extern "C"  int FromASN1_RDN(HMEM_CTX_DEF
			char* InpBuf, int InpOffset, int InpLen,
			IDATPARR** pDatArrayDesc, int* DatArraySize,
			int* SubErrCode)
{
  int i;

  i = FromASN1_SubStr(HMEM_CTX_REF1
		      InpBuf, InpOffset, InpLen,
	              (char *) X501AvaCtl, X501_AVA_CTL_CNT,
		      X501_AVA_MAX_DATA_INDEX,
		      pDatArrayDesc, DatArraySize);
  if(i == ASN1_OP_OK) return(i);
  SubErrCode[0] = i;
  return(ASN1_RDN_TO_INT_ERROR);
}
/**
* Converts data structures in internal
* notation ('Data Elements') to desired ASN.1 encoded RDN
* substring byte stream (ToASN1_RDN). 
* The entries will be of same type (SEQ)
*
* Output will contain a deep copy of the inputs content.      
*
*  @param DatArray Array loaded with
*               data elements
*  @param DatArrayIndex First index of elements to use
*  @param DatArrayCnt Number of elements loaded
*  @param pDstBuf Pointer for generated datastream
*  @param DstLen Length of data returned
*  @param SubErrCode Error code from higher level
*
*  @return ASN1_OP_OK on success, error code otherwise
*/
extern "C"  int ToASN1_RDN(HMEM_CTX_DEF
			IDATA** DatArray,
			int DatArrayIndex,int DatArrayCnt,
			char** pDstBuf, int* DstLen,
			int* SubErrCode)
{
  int i;

  i = ToASN1_SubStr(HMEM_CTX_REF1
		    DatArray, DatArrayIndex, DatArrayCnt,
		    (char *) X501AvaCtl, X501_AVA_CTL_CNT,
		    X501_AVA_MAX_DATA_INDEX,
		    pDstBuf,DstLen);

  if(i == ASN1_OP_OK) return(i);
  SubErrCode[0] = i;
  return(ASN1_INT_TO_RDN_ERROR);
}

extern "C"  int FromASN1_EXT(HMEM_CTX_DEF
			char* InpBuf, int InpOffset, int InpLen,
			IDATPARR** pDatArrayDesc, int* DatArraySize,
			int* SubErrCode)
{
  int i;

  i = FromASN1_SubStr(HMEM_CTX_REF1
		      InpBuf, InpOffset, InpLen,
		      (char *) X509ExtCtl,X509_EXT_CTL_CNT,
		      X509_EXT_MAX_DATA_INDEX,
		      pDatArrayDesc, DatArraySize);
  if(i == ASN1_OP_OK) return(i);
  SubErrCode[0] = i;
  return(ASN1_EXT_TO_INT_ERROR);
}

extern "C"  int FromASN1_Sequence(HMEM_CTX_DEF
			char* InpBuf, int InpOffset,
			int InpLen, int* pDstOff, int* pDstLen)
{
  int i;

  IDATA* pIdata;
  IDATA** pIdataArr;
  IDATA** pTmpDatArray[1];

  pDstLen[0] = 0;			// invalidate
  pDstOff[0] = InpOffset;		// dto.
  //---------------------------------------------------------------
  // Allocate the IData Array
  //---------------------------------------------------------------
  i = AllocIDATA_Array(HMEM_CTX_REF1
		       pTmpDatArray,SEQ_WRAP_MAX_DATA_INDEX);
  if(i != ASN1_OP_OK)
    return(ASN1_SEQ_UNWRAP_ALLOC_ERR);
  pIdataArr = pTmpDatArray[0];
  //---------------------------------------------------------------
  // Split the Sequence
  //---------------------------------------------------------------
  i = FromASN1(HMEM_CTX_REF1
	       InpBuf,InpOffset,InpLen,
               (char *) SequenceWrapCtl,SEQ_WRAP_CTL_CNT,
               pIdataArr,0);
  if(i != ASN1_OP_OK)
  {
    FreeIDATA_Array(HMEM_CTX_REF1
		    pIdataArr, SEQ_WRAP_MAX_DATA_INDEX, 0);
    return(ASN1_SEQ_UNWRAP_ERR);    
  }
  //-------------------------------------------------------------------
  // set the return parameters
  //-------------------------------------------------------------------
  pIdata = pIdataArr[0];
  pDstOff[0] = (int) pIdata->Off;
  pDstLen[0] = pIdata->Len;
  FreeIDATA_Array(HMEM_CTX_REF1
		  pIdataArr, SEQ_WRAP_MAX_DATA_INDEX, 0);
  return(ASN1_OP_OK);
}

extern "C"  int ToASN1_Sequence(HMEM_CTX_DEF
			char* InpBuf, int InpOffset, int InpLen,
			char** pDstBuf, int* DstLen)
{
  int i;

  IDATA* pIdata;
  IDATA** pIdataArr;
  IDATA** pTmpDatArray[1];

  pDstBuf[0] = NULL;			// invalidate
  DstLen[0] = 0;			// dto.
  //---------------------------------------------------------------
  // Allocate the IData Array
  //---------------------------------------------------------------
  i = AllocIDATA_Array(HMEM_CTX_REF1
		       pTmpDatArray,SEQ_WRAP_MAX_DATA_INDEX);
  if(i != ASN1_OP_OK)
    return(ASN1_SEQ_WRAP_ALLOC_ERR);
  //---------------------------------------------------------------
  // Load 1st Element with buffer data
  //---------------------------------------------------------------
  pIdataArr = pTmpDatArray[0];
  pIdata = pIdataArr[0];
  pIdata->Base = InpBuf;
  pIdata->Off  = InpOffset;
  pIdata->Len  = InpLen;
  //---------------------------------------------------------------
  // Build the Sequence...
  //---------------------------------------------------------------
  i = ToASN1(HMEM_CTX_REF1
	     pIdataArr, 0,
             (char *) SequenceWrapCtl,SEQ_WRAP_CTL_CNT,
             pDstBuf,DstLen);

  FreeIDATA_Array(HMEM_CTX_REF1
		  pIdataArr, SEQ_WRAP_MAX_DATA_INDEX, 0);

  if(i == ASN1_OP_OK)
    return(i);
  return(ASN1_SEQ_WRAP_ERR);    
}

extern "C"  int FromASN1_DN(HMEM_CTX_DEF
		char* InpBuf, int InpOffset, int InpLen,
		X501_DN** ppDnNameDesc)
{
  int Retcode;
  int RdnCount;
  int Index;

  IDATA* pIdata;
  IDATA** pIdataArr;
  IDATPARR* pRdnDescStruc = NULL;
  IDATPARR** pRdnStrucArr;
  IDATPARR* pTmpArrDesc[1];

  X501_DN* pNameDesc = NULL;

  int pTmpCnt[1];
  //-------------------------------------------------------------
  // Split the DN into RDN elements, each RDN element is a SET OF
  //-------------------------------------------------------------
  Retcode = FromASN1_SubStr(HMEM_CTX_REF1
		      InpBuf, InpOffset, InpLen,
	              (char *) X501RdnAvaCtl, X501_RDN_AVA_CTL_CNT,
		      X501_RDN_AVA_MAX_DATA_INDEX,
		      pTmpArrDesc, pTmpCnt);
  if(Retcode != ASN1_OP_OK)
    return(Retcode);

  pRdnDescStruc = pTmpArrDesc[0];
  RdnCount      = pTmpCnt[0];
  //-------------------------------------------------------------
  // Allocate the X501 RDN structure, no IDATA elements for now
  //-------------------------------------------------------------
  if((pNameDesc = AllocX501DN_Struc(HMEM_CTX_REF1
				    RdnCount, 0, 0, 0)) == NULL)
  {
    FreeIDATPARR_Struc(HMEM_CTX_REF1 pRdnDescStruc);
    return(ASN1_ALLOC_ERR);
  }
  //-------------------------------------------------------------
  // Process the RDN structures one by one
  //-------------------------------------------------------------
  if(pRdnDescStruc == NULL)
  {
    ppDnNameDesc[0] = pNameDesc;
    return(ASN1_OP_OK);
  }
  pRdnStrucArr = pNameDesc->ppArr;
  pIdataArr    = pRdnDescStruc->ppArr;
  Index = 0;
  while(Index < RdnCount)
  {
    pIdata = pIdataArr[Index];			// buffer description for RDN
    Retcode = FromASN1_SubStr(HMEM_CTX_REF1
			      pIdata->Base,
			      (int) pIdata->Off,
			      pIdata->Len,
	              	      (char *) X501AvaCtl, X501_AVA_CTL_CNT,
		              X501_AVA_MAX_DATA_INDEX,
		              pTmpArrDesc, pTmpCnt);
    if(Retcode != ASN1_OP_OK)
    {
      FreeX501DN_Struc(HMEM_CTX_REF1 pNameDesc);
      FreeIDATPARR_Struc(HMEM_CTX_REF1 pRdnDescStruc);
      return(Retcode);
    }
    pRdnStrucArr[Index] = pTmpArrDesc[0];	// save element structure
    Index++;
  }
  FreeIDATPARR_Struc(HMEM_CTX_REF1 pRdnDescStruc);
  ppDnNameDesc[0] = pNameDesc;
  return(ASN1_OP_OK);
}  

extern "C"  int ToASN1_DN(HMEM_CTX_DEF
		X501_DN* pNameDesc, char** ppDstBuf, int* pDstLen)
{
  int Retcode;
  int RdnCount;
  int Index;

  IDATA* pIdata;

  IDATPARR* pBufferDescStruc = NULL;
  IDATA**   pBufferIdataArr  = NULL;

  IDATPARR* pRdnDescStruc = NULL;
  IDATPARR** pRdnStrucArr;
  IDATPARR* pTmpArrDesc[1];

  char* pTmpBuf[1];

  int pTmpLen[1];
  int pTmpRet[1];

  ppDstBuf[0] = NULL;
  pDstLen[0]  = 0;
  //-------------------------------------------------------------
  // Get number of RDNs to process, if any !
  //-------------------------------------------------------------
  RdnCount = pNameDesc->Cnt;
  if(RdnCount <= 0)				// strange case !!!!!
    return(ASN1_OP_OK);
  //-------------------------------------------------------------
  // Allocate Helper Array for the RDN buffers, mark as freeable
  //-------------------------------------------------------------
  Retcode = AllocIDATPARR_Struc(HMEM_CTX_REF1 pTmpArrDesc,RdnCount);
  if(Retcode != ASN1_OP_OK)
    return(Retcode);
  pBufferDescStruc = pTmpArrDesc[0];
  pBufferDescStruc->Flags |= FREE_BIT_MASK;	// mark as freeable

  pBufferIdataArr = pBufferDescStruc->ppArr;
  //-------------------------------------------------------------
  // Process the RDNs one by one, save the buffers
  //-------------------------------------------------------------
  pRdnStrucArr = pNameDesc->ppArr;
  Index = 0;
  while(Index < RdnCount)
  {
    pRdnDescStruc = pRdnStrucArr[Index];    
    pIdata = pBufferIdataArr[Index];

    Retcode = ToASN1_RDN(HMEM_CTX_REF1
			 pRdnDescStruc->ppArr,
			 0,
			 pRdnDescStruc->Cnt,
			 pTmpBuf,pTmpLen,pTmpRet);
    if(Retcode != ASN1_OP_OK)
    {
      FreeIDATPARR_Struc(HMEM_CTX_REF1 pBufferDescStruc);
      return(Retcode);
    }
    pIdata->Base = pTmpBuf[0];
    pIdata->Len  = pTmpLen[0];
    Index++;
  }
  //-------------------------------------------------------------
  // Embed the RDN Element buffers into SET substructures
  //-------------------------------------------------------------
  Retcode = ToASN1_SubStr(HMEM_CTX_REF1
			  pBufferIdataArr, 0, RdnCount,
		          (char *) X501RdnAvaCtl, X501_RDN_AVA_CTL_CNT,
		          X501_RDN_AVA_MAX_DATA_INDEX,
		          ppDstBuf,pDstLen);
 
  FreeIDATPARR_Struc(HMEM_CTX_REF1 pBufferDescStruc);
  return(Retcode);
}    

/**
* Generates data structures in internal
* notation ('Data Elements') from given ASN.1 encoded ObjectID List (FromASN1_OIDList).
* The Entries must be of same type (OID).
*
* No copy of the data is made.
*
*  @param InpBuf ASN.1 datastream base
*  @param InpOffset Start of data
*  @param InpLen Length of data
*  @param pDatArrayDesc Pointer for generated data structure
*  @param DatArraySize Number of elements generated
*  @param SubErrCode Error code from higher level
*
*  @return ASN1_OP_OK on success, error code otherwise
*/
extern "C"  int FromASN1_OIDList(HMEM_CTX_DEF
			char* InpBuf, int InpOffset, int InpLen,
			IDATPARR** pDatArrayDesc, int* DatArraySize,
			int* SubErrCode)
{
  int Retcode;
  //-----------------------------------------------------------
  // Split the OID Elements list
  //-----------------------------------------------------------
  Retcode = FromASN1_SubStr(HMEM_CTX_REF1
		      InpBuf, InpOffset, InpLen,
		      (char *) ObjIDSplitCtl,OBJID_SPLIT_CTL_CNT,
		      OID_SPLIT_MAX_DATA_INDEX,
		      pDatArrayDesc, DatArraySize);
  if(Retcode == ASN1_OP_OK)
    return(Retcode);
  SubErrCode[0] = Retcode;
  return(ASN1_OIDLIST_TO_INT_ERROR);
}

//************************************************************
//************************************************************
//************************************************************
//
// Functions formerly in HASN1HLI, now needed for Ext. Certs
//
//************************************************************
//************************************************************
//************************************************************

extern "C"  int GetRDN_WellKnownIndex(IDATA* pObjID_Desc,
			int* pAccessIndex)
{
  int i;
  int ObjID_Offset;
  int ObjID_Len;
  
  int X520AttCnt    = GRP_X520_ATT_CNT;
  int X520ExtAttCnt = GRP_X520_EXT_ATT_CNT;

  int ActRDNOidIndex = 0;
  int RDNOidIndex;

  int ActOID_Index;
  int ActOID_Len;
  int ArrayIndex;

  char* pObjID_Base;
  //--------------------------------------------------
  // Check parameters
  //--------------------------------------------------
  if((pObjID_Desc == NULL) || (pAccessIndex == NULL))
    return(ASN1_NULL_PTR);
  pAccessIndex[0] = -1;			// set not found  
  //--------------------------------------------------
  // Get start and length of Object ID
  //--------------------------------------------------
  pObjID_Base  = pObjID_Desc->Base;
  ObjID_Offset = (int) pObjID_Desc->Off;
  ObjID_Len    = pObjID_Desc->Len;

  if((pObjID_Base == NULL) || (ObjID_Len <= 0))	// no Object ID !
    return(ASN1_OP_OK);

  RDNOidIndex = -1;			// assume not found
  for(;;)				// Error for...
  {
    //--------------------------------------------------
    // search the X520 Attributes Table for OID match
    //--------------------------------------------------
    ActRDNOidIndex = 0;
    do
    {
      ActOID_Index = X520_ATT_OffsetTab[ActRDNOidIndex];
      ActOID_Len = (int) OID_Table[ActOID_Index+2] & 0xFF;
      i = MatchASN1ValuesByteByByte(pObjID_Base, ObjID_Offset, ObjID_Len,
        	      (char *) OID_Table, ActOID_Index+3,ActOID_Len);
      if(i == ASN1_SAME)
        break;					// same found
      ActRDNOidIndex++;
      X520AttCnt --;
    }while(X520AttCnt != 0);
    if(X520AttCnt != 0)
    {
      RDNOidIndex = X520_ATT_IndexTab[ActRDNOidIndex];
      break;
    }
    //--------------------------------------------------------
    // search the X520 Extended Attributes Table for OID match
    //--------------------------------------------------------
    ActRDNOidIndex = 0;
    do
    {
      ActOID_Index = X520_EXT_ATT_OffsetTab[ActRDNOidIndex];
      ActOID_Len = (int) OID_Table[ActOID_Index+2] & 0xFF;
      i = MatchASN1ValuesByteByByte(pObjID_Base, ObjID_Offset, ObjID_Len,
		(char *) OID_Table, ActOID_Index+3,ActOID_Len);
      if(i == ASN1_SAME)				// same found
        break;
      ActRDNOidIndex++;
      X520ExtAttCnt --;
    }while(X520ExtAttCnt != 0);
    if(X520ExtAttCnt != 0)
    {
      RDNOidIndex = X520_EXT_ATT_IndexTab[ActRDNOidIndex];
      break;
    }
    break;
  }
  //-------------------------------------------------------------
  // Check if the OID was recognized at all
  //-------------------------------------------------------------
  if(RDNOidIndex < 0)				// not recognized...
    return(ASN1_OP_OK);
  //-------------------------------------------------------------
  // Find position of the index in associated table for ID
  //-------------------------------------------------------------
  i = RDN_ARRAY_MAX_DATA_INDEX;			// number of elements
  ArrayIndex = 0;
  do
  {
    if(RDN_OidIndexArray[ArrayIndex] == (char) RDNOidIndex)
      break;
    ArrayIndex++;
    i--;
  }while(i != 0);
  if(i != 0)
  {
    pAccessIndex[0] = ArrayIndex;
  }
  return(ASN1_OP_OK);
}

extern "C"  int FromASN1_DN_ToStringArray(HMEM_CTX_DEF
		X501_DN* pNameDesc, IDATPARR** ppDstArrDesc)
{
   /** @todo Perhaps they should be displayed in HEX format (do That later). */
  int Retcode = ASN1_OP_OK;
  int i;
  int SrcIndex = 0;
//  int ActOidIndex;
  int RdnIndex;

  int RdnCount;
  int ElementCnt;
  int ArrayIndex;

  char* pTmpBuf[1];

  int pTmpInt[1];

  IDATA** pDatArray;
  IDATA** pDstArray;

  IDATA* pObjIdata;
  IDATA* pContIdata;

  IDATPARR* DatArrayDesc;
  IDATPARR* pDstArrayDesc;
  IDATPARR* pTmpArrDesc[1];

  IDATPARR** pRdnStrucArr;
  //----------------------------------------------------------------
  // check parameters, allocate array, clear
  //----------------------------------------------------------------
  if((pNameDesc == NULL) || (ppDstArrDesc == NULL))
    return(ASN1_RDN_TO_STR_NULL_PTR_ERR);

  Retcode = AllocIDATPARR_Struc(HMEM_CTX_REF1
			        pTmpArrDesc, RDN_ARRAY_MAX_DATA_INDEX);
  if(Retcode != ASN1_OP_OK)
    return(ASN1_RDN_TO_STR_ALLOC_ERR);
  pDstArrayDesc = pTmpArrDesc[0];
  pDstArrayDesc->Flags |= FREE_BIT_MASK;	// set freeable
  pDstArray = pDstArrayDesc->ppArr;
  ppDstArrDesc[0] = pDstArrayDesc;
  //----------------------------------------------------------------
  // Get Number of RDN-Entries to process
  //----------------------------------------------------------------
  RdnCount = pNameDesc->Cnt;
  if(RdnCount <= 0)				// no Elements...
    return(ASN1_OP_OK);

  RdnIndex     = 0;
  pRdnStrucArr = pNameDesc->ppArr;

  while(RdnIndex < RdnCount)
  {
    SrcIndex = 0;				// start at bottom
    DatArrayDesc = pRdnStrucArr[RdnIndex];
    ElementCnt   = DatArrayDesc->Cnt;	// get number

    if((ElementCnt & 0x01) != 0)			// must be even
    {
      FreeIDATPARR_Struc(HMEM_CTX_REF1 pDstArrayDesc);
      return(ASN1_RDN_TO_STR_INV_ELEM_CNT);
    }
    ElementCnt >>= 1;
    if(ElementCnt != 0)
    {
      pDatArray = DatArrayDesc->ppArr;	// get pointer
      if(pDatArray == NULL)
      {
        FreeIDATPARR_Struc(HMEM_CTX_REF1 pDstArrayDesc);
        return(ASN1_RDN_TO_STR_NO_SRC_DAT);
      }
      //----------------------------------------------------------------
      // Process the Entries
      //----------------------------------------------------------------
      do
      {
        pObjIdata  = pDatArray[SrcIndex++];	// Get OID Element
        pContIdata = pDatArray[SrcIndex++];	// Get Contents
        if((pObjIdata == NULL) || (pContIdata == NULL)) // invalid
        {
          Retcode = ASN1_RDN_TO_STR_SRC_ERR;
          break;
        }
        //-------------------------------------------------------------
        // Fetch the Index of the Object ID (if known)
        // Fetch the OID table reference index (well known ID) if known
        //-------------------------------------------------------------
        Retcode = GetRDN_WellKnownIndex(pObjIdata, pTmpInt);
        if(Retcode != ASN1_OP_OK)
          break;
        ArrayIndex = pTmpInt[0];
        if(ArrayIndex >= 0)			// OID was found, index also...
        {
          //-------------------------------------------------------------
          // Generate the String Entry if decodeable
          //-------------------------------------------------------------
          Retcode = FromASN1_String(HMEM_CTX_REF1
				pContIdata->Base,
				(int) pContIdata->Off,
				pContIdata->Len,
				pTmpBuf);
          if((Retcode != ASN1_OP_OK) &&
            (Retcode != ASN1_FROM_STRING_INV_TYPE_ERR)) break;
          if((Retcode == ASN1_OP_OK) && (pTmpBuf[0] != NULL))
          {
            pDstArray[ArrayIndex]->Base = pTmpBuf[0];	// save base
            BIGchar2wordn(pTmpBuf[0],i,0);			// get element count
            pDstArray[ArrayIndex]->Len  = i*2+2;	// set length
          }
        } // known OID
        ElementCnt--;
      }while(ElementCnt != 0);
      if(ElementCnt != 0)			// not all processed, error !
        break;
    }
    RdnIndex++;
  }
  if(RdnIndex == RdnCount)
    return(ASN1_OP_OK);
  //------------------------------------------------
  // Error occurred, free elements
  //------------------------------------------------
  FreeIDATPARR_Struc(HMEM_CTX_REF1 pDstArrayDesc);
  ppDstArrDesc[0] = NULL;
  return(Retcode);
}

extern "C"  int UnsignedBIT32NumToByteBuf(HMEM_CTX_DEF
		int Number,
		char** pDstBuf, int* pDstLen)
{
  char* pMem = NULL;

  int Index = 0;
  int Count = 4;

  int lnum = Number;
  //----------------------------------------------------------------
  // check parameters, allocate buffer clear first byte
  //----------------------------------------------------------------
  if((pDstBuf == NULL) || (pDstLen == NULL))
    return(ASN1_BIT32NUM_TO_BUF_NULPTR_ERR);

  pMem = BIT8_ARRAY_ALLOC(HMEM_CTX_REF,5); // allocate buffer
  if(pMem == NULL) return(ASN1_BIT32NUM_TO_BUF_ALLOC_ERR);

  pMem[0] = 0;				// set 1st Element zero
  pDstBuf[0] = pMem;
  pDstLen[0] = 1;			// set length = 1
  if(lnum == 0)				// special case
    return(ASN1_OP_OK);
  if(lnum < 0) Index++;			// would be negative
  //----------------------------------------------------------------
  // Convert number
  //----------------------------------------------------------------
  do
  {
    if((lnum & 0xFF000000) != 0) break;	// test current MSB Byte
    lnum <<= 8;				// shift up byte
    Count--;
  }while(Count != 0);
  for(;Count != 0;Count--)
  {
    pMem[Index++] = (char) ((lnum >>24) & 0xFF); // store byte
    lnum <<= 8;
  }
  pDstLen[0] = Index;
  return(ASN1_OP_OK);
}

extern "C"  int SetIBMContainerOrdinal(HMEM_CTX_DEF
		IDATA** DatArray,
		int IndexOffset, int OrdinalNum)
{
  int Retcode;

  char* pTmpBuf[1];
  int pTmpLen[1];

  //-------------------------------------------------------
  // Check Parameters
  //-------------------------------------------------------
  if(DatArray == NULL) return(ASN1_TO_CONT_ORDINAL_NULPTR_ERR);
  if(OrdinalNum <= 0)  return(ASN1_TO_CONT_ORDINAL_INVNUM_ERR);
  //-------------------------------------------------------
  // Convert Number to byte string
  //-------------------------------------------------------
  Retcode = UnsignedBIT32NumToByteBuf(HMEM_CTX_REF1
				      OrdinalNum,pTmpBuf,pTmpLen);
  if(Retcode != ASN1_OP_OK) return(Retcode);
  //-------------------------------------------------------
  // Copy to Element (but do not copy the contents !)
  //-------------------------------------------------------
  Retcode = FromBufToDatArray(HMEM_CTX_REF1
			      DatArray,
                              IBM_ORDINAL_INDEX+IndexOffset,
                              pTmpBuf[0],0,pTmpLen[0],0);
  if(Retcode == ASN1_OP_OK) return(Retcode);
//  FREE_ARRAY(HMEM_CTX_REF,pTmpBuf[0]);	// MUST NOT FREE !!!
  return(Retcode);
}

extern "C"  int SetIBMContainerCertOrReq(HMEM_CTX_DEF
		IDATA** DatArray,
		int IndexOffset, char* SrcBuf, int SrcOff, int SrcLen,
		int Type)
{
  int CtlIndex;
  //-------------------------------------------------------
  // Check Parameters
  //-------------------------------------------------------
  if((DatArray == NULL) || (SrcBuf == NULL))
    return(ASN1_TO_CONT_CERT_NULPTR_ERR);
  if(SrcLen <= 0)  return(ASN1_TO_CONT_CERT_INV_LEN_ERR);
  switch(Type)
  {
    case 0:
      CtlIndex = IBM_REQ_CERT_DATA_INDEX;
      break;

    case 1:
      CtlIndex = IBM_STD_CERT_DATA_INDEX;
      break;

    case 2:
      CtlIndex = IBM_SPC_CERT_DATA_INDEX;
      break;

    default:
      return(ASN1_TO_CONT_CERT_INV_TYPE_ERR);
  }
  //-------------------------------------------------------
  // Copy to Element contents
  //-------------------------------------------------------
  return(FromBufToDatArray(HMEM_CTX_REF1
			   DatArray,CtlIndex+IndexOffset,
                           SrcBuf,SrcOff,SrcLen,1));
}

extern "C"  int SetIBMContainerName(HMEM_CTX_DEF
		IDATA** DatArray,
		int IndexOffset, char* ContainerName,
		int ContainerNameLen)
{
  //-------------------------------------------------------
  // Check Parameters
  //-------------------------------------------------------
  if((DatArray == NULL) || (ContainerName == NULL))
    return(ASN1_TO_CONT_NAME_NULPTR_ERR);
  if(ContainerNameLen <= 0)  return(ASN1_TO_CONT_NAME_INV_LEN_ERR);
  //-------------------------------------------------------
  // Copy to Element contents
  //-------------------------------------------------------
  return(FromBufToDatArray(HMEM_CTX_REF1
			   DatArray,
                           IBM_CONTAINER_NAME_INDEX+IndexOffset,
                           ContainerName,0,ContainerNameLen,1));
}

extern "C"  int BIT32FlagsToBitBuf(HMEM_CTX_DEF
		int Flags, int UsedBits,
		char** pDstBuf, int* pDstLen)
{
  char* pMem = NULL;

  int i;
  int Index = 1;
  int UsedBytes;
  int UnusedBits;

  int lFlags = Flags;
  //----------------------------------------------------------------
  // check parameters, allocate buffer clear first byte
  //----------------------------------------------------------------
  if((pDstBuf == NULL) || (pDstLen == NULL))
    return(ASN1_BIT32FLG_TO_BUF_NULPTR_ERR);
  if((UsedBits <= 0) || (UsedBits > 32))
    return(ASN1_BIT32FLG_TO_BUF_INVCNT_ERR);

  pMem = BIT8_ARRAY_ALLOC(HMEM_CTX_REF,5); // allocate buffer
  if(pMem == NULL) return(ASN1_BIT32FLG_TO_BUF_ALLOC_ERR);

  pDstBuf[0] = pMem;
  //----------------------------------------------------------------
  // shift up bits to byte boundary and store
  //----------------------------------------------------------------
  UsedBytes = (UsedBits+7)/8;		// number of bytes
  pDstLen[0] = UsedBytes+1;
  UnusedBits = (8 - (UsedBits & 0x07)) % 8;
  pMem[0] = (char) UnusedBits;
  lFlags <<= (((4-UsedBytes) * 8)+UnusedBits);	// to topmost element and bit
  for(i=UsedBytes;i>0;i--)
  {
    pMem[Index++] = (char) ((lFlags >> 24) & 0xFF);
    lFlags <<= 8;
  }
  return(ASN1_OP_OK);
}

extern "C"  int SetIBMContainerFlags(HMEM_CTX_DEF
		IDATA** DatArray,
		int IndexOffset, int Flags, int UsedBits)
{
  int Retcode;

  char* pTmpBuf[1];
  int pTmpLen[1];
  //-------------------------------------------------------
  // Check Parameters
  //-------------------------------------------------------
  if(DatArray == NULL) return(ASN1_TO_CONT_FLAGS_NULPTR_ERR);
  if((UsedBits <= 0) || (UsedBits > 32))
    return(ASN1_TO_CONT_FLAGS_INV_BITS_ERR);
  //-------------------------------------------------------
  // Convert to Bitstring
  //-------------------------------------------------------
  Retcode = BIT32FlagsToBitBuf(HMEM_CTX_REF1
			       Flags, UsedBits, pTmpBuf, pTmpLen);
  if(Retcode != ASN1_OP_OK) return(Retcode);
  //-------------------------------------------------------
  // Put to Element contents (no copy!)
  //-------------------------------------------------------
  Retcode = FromBufToDatArray(HMEM_CTX_REF1
			      DatArray,
			      IBM_FLAGS_INDEX+IndexOffset,
                              pTmpBuf[0],0,pTmpLen[0],0);
  if(Retcode == ASN1_OP_OK) return(Retcode);
  FREE_ARRAY(HMEM_CTX_REF,pTmpBuf[0]);
  return(Retcode);
}

extern "C"  int ToIBMContainer(HMEM_CTX_DEF
		IDATPARR* DatArrayDesc,
		char** pDstBuf, int* pDstLen)
{
  int Retcode;
  
  //-------------------------------------------------------
  // Check Parameters
  //-------------------------------------------------------
  if((DatArrayDesc == NULL) || (pDstBuf == NULL) || (pDstLen == NULL))
    return(ASN1_TO_IBM_CONT_NULPTR_ERR);
  //-------------------------------------------------------
  // Convert to ASN1
  //-------------------------------------------------------
  Retcode = ToASN1(HMEM_CTX_REF1
		DatArrayDesc->ppArr, 0,
              (char *) IBMContainerCtl,IBM_CONTAINER_CTL_CNT,
                   pDstBuf,pDstLen);
  //-------------------------------------------------------
  // Free the data array (and Elements as all are copies)
  //-------------------------------------------------------
  FreeIDATPARR_Struc(HMEM_CTX_REF1 DatArrayDesc);
  return(Retcode);
}

extern "C"  int GenIbmStdContainer(HMEM_CTX_DEF
	char* SrcBuf, int SrcOff,
	int SrcLen, int OrdinalNumber,
	char* ContainerName, int ContNameLen, int Flags, int UsedBits,
	char** pDstBuf, int* pDstLen)
{

  char* pMem;

  int Retcode;

  IDATA* pIdata;

  IDATA** DatArray;
  IDATPARR* DatArrayDesc = NULL;
  IDATPARR* pTmpDatArrayDesc[1];

  //-------------------------------------------------------
  // Get Array for Container Construction, mark as freeable
  //-------------------------------------------------------
  Retcode = AllocIDATPARR_Struc(HMEM_CTX_REF1 pTmpDatArrayDesc,
                                IBM_CONTAINER_MAX_DATA_INDEX);
  if(Retcode != ASN1_OP_OK) return(Retcode);
  DatArrayDesc = pTmpDatArrayDesc[0];
  DatArrayDesc->Flags |= FREE_BIT_MASK;  
  DatArray = DatArrayDesc->ppArr;
  for(;;)
  {
    //-------------------------------------------------------
    // Set the Ordinal number
    //-------------------------------------------------------
    Retcode = SetIBMContainerOrdinal(HMEM_CTX_REF1
				     DatArray,0,OrdinalNumber);
    if(Retcode != ASN1_OP_OK) break;
    //-------------------------------------------------------
    // Set Certificate
    //-------------------------------------------------------
    Retcode = SetIBMContainerCertOrReq(HMEM_CTX_REF1
		 DatArray,0,
		 SrcBuf,SrcOff,SrcLen,1);
    if(Retcode != ASN1_OP_OK) break;
    //-------------------------------------------------------
    // Set Container Name
    //-------------------------------------------------------
//    PRINT("\nSetting Container Name");
    Retcode = SetIBMContainerName(HMEM_CTX_REF1
				  DatArray,0, ContainerName,
				  ContNameLen);
//    PRINT("\nSetting Container Name End");
    if(Retcode != ASN1_OP_OK) break;
    //-------------------------------------------------------
    // Set Flags
    //-------------------------------------------------------
    Retcode = SetIBMContainerFlags(HMEM_CTX_REF1
				   DatArray,0, Flags, UsedBits);
    if(Retcode != ASN1_OP_OK) break;
    //-------------------------------------------------------
    // Set Unknown buffer to Zero length data
    //-------------------------------------------------------
    pMem = BIT8_ARRAY_ALLOC(HMEM_CTX_REF,1);	// allocate Dummy Array
    if(pMem == NULL)
    {
      Retcode = ASN1_TO_CONT_UNK_ALLOC_ERR;
      break;
    }
    pIdata = DatArray[IBM_UNKNOWN_INDEX];
    pIdata->Base = pMem;			// set Buffer Base
    pIdata->Len = 0;
    //-------------------------------------------------------
    // Generate the Container
    //-------------------------------------------------------
//    PRINT("\nBefore To Container");
    Retcode = ToIBMContainer(HMEM_CTX_REF1
			     DatArrayDesc,pDstBuf,pDstLen);
    DatArrayDesc = NULL;
//    PRINT("\nAfter To Container");
    break;
  } // Error For
  FreeIDATPARR_Struc(HMEM_CTX_REF1 DatArrayDesc);
  return(Retcode);
}

//************************************************************
//************************************************************
//************************************************************
//
// Functions for RDN Comparisons
//
//************************************************************
//************************************************************
//************************************************************

extern "C"  int CmpASN1_ObjIDs(IDATA* ObjID1Desc,
			              IDATA* ObjID2Desc,
			              int* Result)
{
  char c1,c2,x1,x2,y1,y2;
  int i,j;
  int ObjID1Index;
  int ObjID1Offset;
  int ObjID1Len;
  int ObjID2Index;
  int ObjID2Offset;
  int ObjID2Len;
  int ObjID1ComponentCnt;
  int ObjID2ComponentCnt;

  char* ObjID1;
  char* ObjID2;

  char ObjID1CompLenArray[ASN1_MAX_OBJID_COMPONENTS];
  char ObjID2CompLenArray[ASN1_MAX_OBJID_COMPONENTS];

  if((ObjID1Desc == NULL) || (ObjID2Desc == NULL))
    return(ASN1_OBJID_CMP_PARAM_ERR);
  //---------------------------------------------------
  // extract information from descriptors
  //---------------------------------------------------
  ObjID1	= ObjID1Desc->Base;
  ObjID1Offset	= (int) ObjID1Desc->Off;
  ObjID1Len     = ObjID1Desc->Len;

  ObjID2	= ObjID2Desc->Base;
  ObjID2Offset  = (int) ObjID2Desc->Off;
  ObjID2Len     = ObjID2Desc->Len;
  //--------------------------------------------------------------
  // 1. Compare length, if same length, check for zero length !
  //--------------------------------------------------------------
  if(ObjID1Len != ObjID2Len)
  {
    if(ObjID1Len < ObjID2Len)			// 1st < 2nd
      Result[0] = ASN1_1ST_LT_2ND;
    else					// 1st > 2nd
      Result[0] = ASN1_1ST_GT_2ND;
    return(ASN1_OP_OK);
  }
  if(ObjID1Len == 0)				// are same (no data)
  {
    Result[0] = ASN1_1ST_EQ_2ND;		// 1st == 2nd
    return(ASN1_OP_OK);
  }
  if((ObjID1 == NULL) || (ObjID2 == NULL)) // invalid !!
    return(ASN1_OBJID_CMP_MISSING_ENTRY);
  //--------------------------------------------------------------
  // 2. Get each OBJ-ID's Component Count and their Lengths
  //--------------------------------------------------------------
  ObjID1ComponentCnt = 0;			// first byte not counted !
  ObjID2ComponentCnt = 0;			// dto.
  if(ObjID1Len > 1)				// only if more than 1 byte
  {
    ObjID1Index = ObjID1Offset+1;		// start at second byte
    ObjID2Index = ObjID2Offset+1;		// dto.
    //------------------------------------------------------------
    // a) get first IDs component count and their lengths
    //------------------------------------------------------------
    i = ObjID1Len-1;				// set byte count
    j = 0;					// set length zero
    do
    {
      j++;					// increment component length
      c1 = (char) (ObjID1[ObjID1Index++] & 0x80); // get continuation Bit
      if(c1 == 0)				// end of component
      {
        if(j > 255)
          return(ASN1_OBJID_CMP_TOO_LARGE_PART); // error occurred
        ObjID1CompLenArray[ObjID1ComponentCnt++] =(char) j;// store count/incr.
        if(ObjID1ComponentCnt >=		// too many componets
           ASN1_MAX_OBJID_COMPONENTS)
           return(ASN1_OBJID_CMP_TOO_MANY_PARTS);
        j = 0;					// set next size zero
      }
      i--;					// reduce byte count
    }while (i != 0);
    if(c1 != 0) return(ASN1_OBJID_CMP_MISFORMED_OBJID);	// no end found !!
    //------------------------------------------------------------
    // b) get second IDs component count and their lengths
    //------------------------------------------------------------
    i = ObjID2Len-1;				// set byte count
    j = 0;					// set length zero
    do
    {
      j++;					// increment component length
      c1 = (char) (ObjID2[ObjID2Index++] & 0x80); // get continuation Bit
      if(c1 == 0)				// end of component
      {
        if(j > 255)
          return(ASN1_OBJID_CMP_TOO_LARGE_PART); // error occurred
        ObjID2CompLenArray[ObjID2ComponentCnt++] = (char)j;// store count/incr.
        if(ObjID2ComponentCnt >=		// too many componets
           ASN1_MAX_OBJID_COMPONENTS)
           return(ASN1_OBJID_CMP_TOO_MANY_PARTS);
        j = 0;					// set next size zero
      }
      i--;					// reduce byte count
    }while (i != 0);
    if(c1 != 0) return(ASN1_OBJID_CMP_MISFORMED_OBJID);	// no end found !!
  }
  //------------------------------------------------------------
  // c) compare component count
  //------------------------------------------------------------
  if(ObjID1ComponentCnt != ObjID2ComponentCnt)	// not same count
  {
    if(ObjID1ComponentCnt < ObjID2ComponentCnt)	// 1st < 2nd
      Result[0] =ASN1_1ST_LT_2ND;
    else
      Result[0] =ASN1_1ST_GT_2ND;
    return(ASN1_OP_OK);
  }
  //------------------------------------------------------------
  // 3. compare each Component's length (if components present)
  //------------------------------------------------------------
  if(ObjID1ComponentCnt != 0)			// components present
  {
    i = ObjID1ComponentCnt;			// set count
    j = 0;					// set start index
    do
    {
      if(ObjID1CompLenArray[j] !=		// not same length
         ObjID2CompLenArray[j])
      {
        if(ObjID1CompLenArray[j] <		// 1st < 2nd
           ObjID2CompLenArray[j])
          Result[0] =ASN1_1ST_LT_2ND;
        else
          Result[0] =ASN1_1ST_GT_2ND;
        return(ASN1_OP_OK);
      }
      j++;					// to next entry
      i--;           
    } while(i != 0);
  }
  //------------------------------------------------------------
  // 4. compare Components
  // a) compare first byte:
  //   is combined: 40 * x + y, 0 <= x <= 2) :
  //
  //    x = 0: itu-t,		0 <= y <=  39 (total value:  0..39)
  //	x = 1: iso,   		0 <= y <=  39 (total value: 40..79)
  //    x = 2: joint-iso-itu-t  0 <= y <= 127 (total value: 80..255)
  //------------------------------------------------------------
  ObjID1Index = ObjID1Offset;			// start of object ID1
  ObjID2Index = ObjID2Offset;			// start of object ID2

  i = (int) ObjID1[ObjID1Index++] & 0xFF;	// get first byte (expanded)
  x1 = (char) (i / OBJ_ROOT_MULTIPLIER);	// get ITU/ISO/JOINED root
  if(x1 > JOINT_ISO_ITU_T_ROOT)			// must correct (1)
  {
    x1 = JOINT_ISO_ITU_T_ROOT;			// set corrected root value
    y1 = (char) (i - 
         (JOINT_ISO_ITU_T_ROOT *OBJ_ROOT_MULTIPLIER));	 // get 1st leave
  }
  else y1 = (char) (i - (x1 * OBJ_ROOT_MULTIPLIER));	// get 1st leave

  i = (int) ObjID2[ObjID2Index++] & 0xFF;	// get first byte (expanded)
  x2 = (char) (i / OBJ_ROOT_MULTIPLIER);	// get ITU/ISO/JOINED root
  if(x2 > JOINT_ISO_ITU_T_ROOT)			// must correct (1)
  {
    x2 = JOINT_ISO_ITU_T_ROOT;			// set corrected root value
    y2 = (char) (i -
         (JOINT_ISO_ITU_T_ROOT *OBJ_ROOT_MULTIPLIER));	// get 1st leave
  }
  else y2 = (char) (i - (x2 * OBJ_ROOT_MULTIPLIER));	// get 1st leave

  if(x1 != x2)					// not same roots
  {
    if(x1 < x2) Result[0] = ASN1_1ST_LT_2ND;
    else Result[0] = ASN1_1ST_GT_2ND;
    return(ASN1_OP_OK);
  }
  if(y1 != y2)					// not same start leaves
  {
    if(y1 < y2) Result[0] = ASN1_1ST_LT_2ND;
    else Result[0] = ASN1_1ST_GT_2ND;
    return(ASN1_OP_OK);
  }
  //------------------------------------------------------------
  // b) check if additional components present
  //------------------------------------------------------------
  if(ObjID1ComponentCnt == 0)			// no more components
  {
    Result[0] =ASN1_1ST_EQ_2ND;
    return(ASN1_OP_OK);
  }
  //------------------------------------------------------------
  // c) compare additional components starting with the first one,
  // Note: as all components must now have the same length,
  // ----- comparison is done on a byte by byte basis, but only
  //       7 bits per element !
  //------------------------------------------------------------
  i = ObjID1Len-1;				// get remaining byte count
  do
  {
    c1 = (char) (ObjID1[ObjID1Index++] & 0x7F);	// get ID1 part
    c2 = (char) (ObjID2[ObjID2Index++] & 0x7F);	// get ID2 part
    if(c1 != c2)				// not same component value
    {
      if(((int) c1 & 0xFF) < ((int) c2 & 0xFF)) // 1st < 2nd
         Result[0] = ASN1_1ST_LT_2ND;
      else					// 1st > 2nd
         Result[0] = ASN1_1ST_GT_2ND;
      return(ASN1_OP_OK);
    }
    i--;
  } while(i != 0);
  Result[0] = ASN1_1ST_EQ_2ND;
  return(ASN1_OP_OK);
}

extern "C"  int SortASN1_DN(X501_DN* pDnNameStruc)
{
  int RetCode;
  int IndexBase;
  int ActIndex;
  int StartCount;
  int ActCount;
  int SortFlag=0;

  int CmpResult[1];

  IDATA* pIdataType1;
  IDATA* pIdataType2;

  IDATA**   pRDN1_Arr;
  IDATA**   pRDN2_Arr;

  IDATPARR* pRDN1_Desc;
  IDATPARR* pRDN2_Desc;

  IDATPARR** pRDNArray;

  int RDN_Count = 0;

  //---------------------------------------------------
  // Check for correct params first
  //---------------------------------------------------
  if(pDnNameStruc == NULL)
    return(ASN1_AVA_SORT_PARAM_ERR);
  //---------------------------------------------------
  // Check if sort is required at all
  //---------------------------------------------------
  if((RDN_Count = pDnNameStruc->Cnt) <= 1) // less than 2 elements
    return(ASN1_OP_OK);
  pRDNArray = pDnNameStruc->ppArr;	// fetch RDN access array
  //---------------------------------------------------
  // Setup Start Parameters for sort
  //---------------------------------------------------
  StartCount = RDN_Count-1;			// number of RDN-Elements - 1
  IndexBase  = 0;				// index of starting RDN
  do
  {
    ActIndex = IndexBase;
    ActCount = StartCount;
    //---------------------------------------------------
    // inner loop
    //---------------------------------------------------
    do
    {
      pRDN1_Desc  = pRDNArray[ActIndex];	// get first to compare to
      pRDN2_Desc  = pRDNArray[ActIndex+1];	// get second for compare

      pRDN1_Arr   = pRDN1_Desc->ppArr;	// AVA elements array
      pRDN2_Arr   = pRDN2_Desc->ppArr;	// dto.

      pIdataType1 = pRDN1_Arr[0];		// get first element's 1st AVA
      pIdataType2 = pRDN2_Arr[0];		// get second element's 1st AVA

      RetCode = CmpASN1_ObjIDs(pIdataType1,		// do compare
			       pIdataType2,
			       CmpResult);

      if(RetCode != ASN1_OP_OK) return(RetCode);	// stop processing
      if(CmpResult[0] == ASN1_1ST_GT_2ND)		// must resort
      {
        pRDNArray[ActIndex]   = pRDN2_Desc;		// exchange types
        pRDNArray[ActIndex+1] = pRDN1_Desc;
        SortFlag = 1;
      }
      ActIndex++;				// to next Type
      ActCount--;
    }while(ActCount != 0);
    if(SortFlag == 0) break;			// finished, no more sort
    SortFlag = 0;
    StartCount--;  
  }while(StartCount != 0);
  return(ASN1_OP_OK);
}

/**
* Sorts given AVA array (for example RDN substring) by the ASN.1 object ID (See object
* ID comparison subroutine for description of sort order) (SortAVA_IDATA_Array).
* A simple bubble sort is used from bottom to top.
*
* <ol>
* <li> The Array must have an even number of entries.
* <li> The even numbered entries (0,2,...) are ObjectID descriptors,
*	    the odd  numbered entries (1,3,...) are the value data (ANY).
* </ol>
*  @param AVA_Array Array base
*  @param IndexBase Start index to use
*  @param ElementCnt Number of elements in
*               the array
*
*  @return ASN1_OP_OK on success, error code otherwise
*/
extern "C"  int SortAVA_IDATA_Array(IDATA** AVA_Array,
			                   int IndexBase,
					   int ElementCnt)
{
   /** @todo check for a more efficient sorting algorithm */
  int RetCode;

  int ActIndex;

  int StartCount;
  int ActCount;
  int SortFlag=0;

  int CmpResult[1];

  IDATA* pIdataType1;
  IDATA* pIdataType2;

  IDATA* pIdataSave;
  //---------------------------------------------------
  // Check for correct params first
  //---------------------------------------------------
  if((AVA_Array == NULL) || ((ElementCnt & 0x01) != 0))
    return(ASN1_AVA_SORT_PARAM_ERR);

  //---------------------------------------------------
  // Setup Start Parameters for sort
  //---------------------------------------------------
  StartCount = (ElementCnt / 2)-1;		// number of Pairs-1
//  if(ElementCnt <= 0) return(ASN1_OP_OK);	// is WRONG !!!
  if(StartCount <= 0) return(ASN1_OP_OK);	// *RIGHT*, no sort
  do
  {
    ActIndex = IndexBase;
    ActCount = StartCount;
    //---------------------------------------------------
    // inner loop
    //---------------------------------------------------
    do
    {
      pIdataType1 = AVA_Array[ActIndex];		// get first
      pIdataType2 = AVA_Array[ActIndex+2];		// get second

      RetCode = CmpASN1_ObjIDs(pIdataType1,		// do compare
			       pIdataType2,
			       CmpResult);

      if(RetCode != ASN1_OP_OK) return(RetCode);	// stop processing
      if(CmpResult[0] == ASN1_1ST_GT_2ND)		// must resort
      {
        AVA_Array[ActIndex]   = pIdataType2;		// exchange types
        AVA_Array[ActIndex+2] = pIdataType1;
        pIdataSave = AVA_Array[ActIndex+1];		// get value
        AVA_Array[ActIndex+1] = AVA_Array[ActIndex+3]; // exchange
        AVA_Array[ActIndex+3] = pIdataSave;
        SortFlag = 1;
      }
      ActIndex+=2;				// to next Type
      ActCount--;
    }while(ActCount != 0);
    if(SortFlag == 0) break;			// finished, no more sort
    SortFlag = 0;
    StartCount--;  
  }while(StartCount != 0);
  return(ASN1_OP_OK);
}
/**
* Subroutine SortExt_IDATA_Array sorts given Extensions Array
* by the ASN.1 Object ID (See Object ID Comparison Subroutine
* for Description of Sort Order) (SortExt_IDATA_Array).
* A simple bubble sort is used from bottom to top.
* (Should be changed to more efficient method...)
*
* Note: 1. The Array consists of 3 Entries per extension
*       2. The 1st  Entry is an PbjectID Descriptor,
*	    the 2nd  Entry is a Boolean,
*	    the 3rd  Entry is the Value data (ANY)
* 
*  @param Ext_Array Array base
*  @param IndexBase Start Index to use
*  @param ElementCnt Number of Elements in
*               the Array
*
*  @return ASN1_OP_OK on success, error code otherwise
* <br>            else Error occurred
*/
static  int SortExt_IDATA_Array(IDATA** Ext_Array,
			                   int IndexBase,
					   int ElementCnt)
{
  int RetCode;

  int ActIndex;

  int StartCount;
  int ActCount;
  int SortFlag=0;

  int CmpResult[1];

  IDATA* pIdataType1;
  IDATA* pIdataType2;

  IDATA* pIdataSave;
  //---------------------------------------------------
  // Check for correct params first
  //---------------------------------------------------
  if((Ext_Array == NULL) || ((ElementCnt % 3) != 0))
    return(ASN1_AVA_SORT_PARAM_ERR);

  //---------------------------------------------------
  // Setup Start Parameters for sort
  //---------------------------------------------------
  StartCount = (ElementCnt / 3)-1;		// number of Pairs-1
  if(StartCount <= 0) return(ASN1_OP_OK);
  do
  {
    ActIndex = IndexBase;
    ActCount = StartCount;
    //---------------------------------------------------
    // inner loop
    //---------------------------------------------------
    do
    {
      pIdataType1 = Ext_Array[ActIndex];		// get first OID
      pIdataType2 = Ext_Array[ActIndex+3];		// get second OID

      RetCode = CmpASN1_ObjIDs(pIdataType1,		// do compare
			       pIdataType2,
			       CmpResult);

      if(RetCode != ASN1_OP_OK) return(RetCode);	// stop processing
      if(CmpResult[0] == ASN1_1ST_GT_2ND)		// must resort
      {
        Ext_Array[ActIndex] = pIdataType2;		// exchange types
        Ext_Array[ActIndex+3] = pIdataType1;
        pIdataSave = Ext_Array[ActIndex+1];		// get boolean
        Ext_Array[ActIndex+1] = Ext_Array[ActIndex+4]; // exchange
        Ext_Array[ActIndex+4] = pIdataSave;
        pIdataSave = Ext_Array[ActIndex+2];		// get value
        Ext_Array[ActIndex+2] = Ext_Array[ActIndex+5]; // exchange
        Ext_Array[ActIndex+5] = pIdataSave;
        SortFlag = 1;
      }
      ActIndex+=3;				// to next Type
      ActCount--;
    }while(ActCount != 0);
    if(SortFlag == 0) break;			// finished, no more sort
    SortFlag = 0;
    StartCount--;  
  }while(StartCount != 0);
  return(ASN1_OP_OK);
}
/**
* Subroutine CheckValidASN1TimeType checks if a given ASN.1 Type
* is a valid ASN.1 Time Type, if so reports type of time (CheckValidASN1TimeType).
*
* A valid ASN.1 time type has the following characteristics:
* - Class Universal, primitive,
* - Type  either UTCTime or GeneralizedTime
*
*
*  @param ASN1Type ASN1 Tag type
*  @return int Status ASN1_TIME_TYPE_INVALID 0 not a valid time type
* <br>            ASN1_TIME_TYPE_UTC 1 UTC time type
* <br>            ASN1_TIME_TYPE_GENTIME 2 Generalized time type
*/
static  int CheckValidASN1TimeType(char ASN1Type)
{
  //-------------------------------------------------------------
  // check for ASN1 universal primitive encoding
  //-------------------------------------------------------------
  if((ASN1Type & (ASN1_CLASS_MASK | ASN1_CONSTRUCTED_MASK)) != 0)
    return(ASN1_TIME_TYPE_INVALID);
  //--------------------------------------------------------
  // Check ASN1 Universal type
  //--------------------------------------------------------
  if(ASN1Type == ASN1_UNIVERSAL_UTC_TIMESTR)
    return(ASN1_TIME_TYPE_UTC);
  if(ASN1Type == ASN1_UNIVERSAL_GEN_TIMESTR)
    return(ASN1_TIME_TYPE_GENTIME);
  return(ASN1_TIME_TYPE_INVALID);
}
/**
* Subroutine CheckLeapYear checks if a given year is a leap year
* or not (gregorian calendar based) (CheckLeapYear).
*
* Decision Algorithm:
*      --------------
* 1. if a year is not divisible by 4 it is no leap year
* 2. if divisible by 4 and by 100 but not divisible by 400 it is no
*    leapyear
* 3. if divisible by 4, by 100 and by 400 it is a leap year (e.g. 2000)
*
*
*  @param Year Year to check
*
*  @return STATUS IS_NOT_LEAP_YEAR
* <br>            IS_LEAP_YEAR <> 0 - is leap year
*/
static  int CheckLeapYear(int Year)
{
  if((Year & 0x3) != 0) return(IS_NOT_LEAP_YEAR); // not divisible by 4
  if((Year % 100) != 0) return(IS_LEAP_YEAR);	  // not divisible by 100
  if((Year % 400) != 0) return(IS_NOT_LEAP_YEAR); // divisible by 4,100 not
						  // by 400
  return(IS_LEAP_YEAR);				  // divisible by 4, 100, 400
}
/**
* Subroutine GetDayOfYear gets day of year for a given date
* absolute time, limits it and stores back (GetDayOfYear).
*
*  @param AbsTimeArray Absolute Time Array
*
*  @return int DayOfYear > 0 - o.k., from 1..366
* <br>            <= 0 - Error occurred
*/
static  int GetDayOfYear(int* AbsTimeArray)

{
  int i,j;
  int DayOfYear;
  int Year;
  //-------------------------------------------------------
  // Get current day of year (leap year processing !)
  //-------------------------------------------------------
  DayOfYear = AbsTimeArray[TIME_DAY_INDEX];		// get Day rel. 1
  if((DayOfYear < 1) || (DayOfYear > 31)) return(0);	// invalid
  i = AbsTimeArray[TIME_MONTH_INDEX];		// get month rel. 1 (january)
  if((i < 1) || (i > 12)) return(0);		// invalid
  j = 0;					// set Table Base
  i --;						// number of months to add
  for(;i != 0;i--) DayOfYear += MaxDaysOfMonth[j++];	// add up
  if(DayOfYear > (31 + 28))			// February processed, check..
  {
    Year = AbsTimeArray[TIME_YEAR_INDEX];
    if(Year <= GREGORIAN_YEAR) return(0);
    if(CheckLeapYear(Year) == IS_NOT_LEAP_YEAR) DayOfYear--;
  }
  return(DayOfYear);
}

/**
* Subroutine LongAddLimitTime, adds a delta time and carry to an
* absolute time, limits it and stores back (LongAddLimitTime).
*
*  @param AbsTimeArray Absolute Time Array
*  @param DeltaTimeArray Delta Time Array
*  @param timeIndex Index to use
*  @param pCarry Carry
*  @param Limit Limiting Value
*
*  @return int STATUS == 0 - o.k.
* <br>            <> 0 - Error occurred
*/
static  int LongAddLimitTime(int* AbsTimeArray,
		int* DeltaTimeArray, int timeIndex,
		int* pCarry, int Limit)
{
    int TmpResult;
    int Carry;
    //-------------------------------------------------------
    // Add up
    //-------------------------------------------------------
    TmpResult = (int) AbsTimeArray[timeIndex] +	// add + carry
                (int) DeltaTimeArray[timeIndex]+
		pCarry[0];
    if(TmpResult < 0) return(-1);		// unhandled condition
    Carry = TmpResult / Limit;			// generate carry
    TmpResult -= (Carry * Limit);		// generate result
    AbsTimeArray[timeIndex] = (int) TmpResult;	// store
    pCarry[0] = Carry;
    return(0);
}
/**
* Subroutine LongSubLimitTime, subtracts a delta time and carry
* from an absolute time, limits it and stores back (LongSubLimitTime).
*
*  @param AbsTimeArray Absolute Time Array
*  @param DeltaTimeArray Delta Time Array
*  @param timeIndex Index to use
*  @param pBorrow Borrow
*  @param Limit Limiting Value
*
*  @return int STATUS == 0 - o.k.
* <br>            <> 0 - Error occurred
*/
static  int LongSubLimitTime(int* AbsTimeArray,
		int* DeltaTimeArray, int timeIndex,
		int* pBorrow, int Limit)
{
    int TmpResult;
    int Borrow=0;
    //-------------------------------------------------------
    // Add up
    //-------------------------------------------------------
    TmpResult = (int) AbsTimeArray[timeIndex]   -	// subtract
                (int) DeltaTimeArray[timeIndex] -
		pBorrow[0];
    if(TmpResult > Limit) return(-1);		// was malformed !
    if(TmpResult < 0)				// not in range, must correct
    {
      Borrow = (Limit-1-TmpResult) / Limit;	// get number of adds      
      TmpResult += (Borrow * Limit);		// correct
    }
    AbsTimeArray[timeIndex] = (int) TmpResult;	// store
    pBorrow[0] = Borrow;
    return(0);
}

extern "C"  int AddTimeArrayDeltaTime(int* AbsTimeArray,
			 int* DeltaTimeArray, int Mode)
{

  int pCarry[1]={0};
  int TmpResult;

  int i;
  int DayOfYear;

  int timeIndex = TIME_MILLI_SECONDS_INDEX;	// Top of Array !
  //---------------------------------------------------------
  // Decide if add or subtract...
  //---------------------------------------------------------
  if(Mode == 0)
  {
    //==========================================
    // Delta addition
    //==========================================
    if(LongAddLimitTime(AbsTimeArray,			// Add Milliseconds
			DeltaTimeArray,
			timeIndex--,
		        pCarry,MAX_MILLI_SECONDS+1) != 0) return(-1);

    if(LongAddLimitTime(AbsTimeArray,			// Add Seconds
			DeltaTimeArray,
			timeIndex--,
		        pCarry,60) != 0) return(-1);

    if(LongAddLimitTime(AbsTimeArray,			// Add Minutes
			DeltaTimeArray,
			timeIndex--,
		        pCarry,60) != 0) return(-1);

    if(LongAddLimitTime(AbsTimeArray,			// Add hours
			DeltaTimeArray,
			timeIndex--,
		        pCarry,24) != 0) return(-1);

    //-------------------------------------------------------
    // Get current day of year (leap year processing !)
    //-------------------------------------------------------
    DayOfYear = GetDayOfYear(AbsTimeArray);
    if(DayOfYear < 1) return(-1);
    //-------------------------------------------------------
    // Add up current day of year, delta days, months and carry
    //-------------------------------------------------------
    TmpResult = (int) DayOfYear +		
                (int) DeltaTimeArray[TIME_DAY_INDEX] +
                ((int) DeltaTimeArray[TIME_MONTH_INDEX] * 30) +
		pCarry[0];
    if(TmpResult < 0) return(-1);		// unhandled condition
    //-------------------------------------------------------
    // Process forward leap year correction now
    //-------------------------------------------------------
    for(;;)
    {
      if(TmpResult <= 365) break;		// within same current year
      TmpResult -= 365;				// subtract 1 standard year
      if(CheckLeapYear(AbsTimeArray[TIME_YEAR_INDEX]) == // we have a leap year
           IS_LEAP_YEAR)
      {
        TmpResult--;				// reduce count by 1 day
        if(TmpResult == 0)			// we were in same year
        {
          TmpResult += 366;			// must correct
          break;
        }     
      }
      AbsTimeArray[TIME_YEAR_INDEX]++;	// to next year
    } // FOR loop   
    //-------------------------------------------------------
    // we now have a Day of year, convert back to day / month
    //-------------------------------------------------------
    DayOfYear = (int) TmpResult;		// get the day
    if(CheckLeapYear(AbsTimeArray[TIME_YEAR_INDEX]) == IS_NOT_LEAP_YEAR)
    {
     if(DayOfYear > (31+28)) DayOfYear++;	// past february normal year
    }
    i = 0;					// Field index january
    for(;;)
    {
      if(DayOfYear <= MaxDaysOfMonth[i]) break;	// date decoded
      DayOfYear -= MaxDaysOfMonth[i++];		// reduce days, incr. index
    }
    //-------------------------------------------------------
    // Store new absolute array Month and Day now
    //-------------------------------------------------------
    AbsTimeArray[TIME_MONTH_INDEX] = (i+1);	// save month
    AbsTimeArray[TIME_DAY_INDEX] = DayOfYear;	// save day
    //-------------------------------------------------------
    // Add up years
    //-------------------------------------------------------
    TmpResult = (int) AbsTimeArray[TIME_YEAR_INDEX] +
                (int) DeltaTimeArray[TIME_YEAR_INDEX];
    if(TmpResult <= GREGORIAN_YEAR)		// not allowed
      return(-1);				// unhandled condition

    AbsTimeArray[TIME_YEAR_INDEX] = (int) TmpResult;// store
    //-------------------------------------------------------
    // Process final forward leap year correction now
    //-------------------------------------------------------
    if((AbsTimeArray[TIME_MONTH_INDEX] == 2) &&	// is february
       (AbsTimeArray[TIME_DAY_INDEX] == 29)  && // is 29th
       (CheckLeapYear(AbsTimeArray[TIME_YEAR_INDEX]) ==
         IS_NOT_LEAP_YEAR))
    {
      AbsTimeArray[TIME_MONTH_INDEX] = 3;	// set march
      AbsTimeArray[TIME_DAY_INDEX] = 1;		// set 1st
    }
    return(0);					// o.k.
  }
  else
  {
    //==========================================
    // Delta subtraction
    //==========================================
    if(LongSubLimitTime(AbsTimeArray,			// Subtract Millisecs
			DeltaTimeArray,
			timeIndex--,
		        pCarry,MAX_MILLI_SECONDS+1) != 0) return(-1);

    if(LongSubLimitTime(AbsTimeArray,			// Subtract Seconds
			DeltaTimeArray,
			timeIndex--,
		        pCarry,60) != 0) return(-1);

    if(LongSubLimitTime(AbsTimeArray,			// Subtract Minutes
			DeltaTimeArray,
			timeIndex--,
		        pCarry,60) != 0) return(-1);

    if(LongSubLimitTime(AbsTimeArray,			// Subtract Hours
			DeltaTimeArray,
			timeIndex--,
		        pCarry,24) != 0) return(-1);
    //-------------------------------------------------------
    // Get current day of year (leap year processing !)
    //-------------------------------------------------------
    DayOfYear = GetDayOfYear(AbsTimeArray);
    if(DayOfYear < 1) return(-1);
    //-------------------------------------------------------
    // Subtract from current day of year delta days months and carry
    //-------------------------------------------------------
    TmpResult = (int) DayOfYear -		
                (int) DeltaTimeArray[TIME_DAY_INDEX] -
                ((int) DeltaTimeArray[TIME_MONTH_INDEX] * 30) -
		pCarry[0];
    if(TmpResult > 366) return(-1);		// unhandled condition
    if((TmpResult > 365) &&
      (CheckLeapYear(AbsTimeArray[TIME_YEAR_INDEX]) == IS_NOT_LEAP_YEAR))
      return(-1);				// unhandled condition
    //-------------------------------------------------------
    // Process backward with leap year correction now
    //-------------------------------------------------------
    for(;;)
    {
      if(TmpResult >= 1) break;			// within current year
      TmpResult += 365;				// add one Leap year
      AbsTimeArray[TIME_YEAR_INDEX]--;		// reduce years
      i = AbsTimeArray[TIME_YEAR_INDEX];	// get value
      if( i <= GREGORIAN_YEAR) return(-1);
      if(CheckLeapYear(i) == IS_LEAP_YEAR)	// now in leap year
        TmpResult ++;				// correct
    }
    //-------------------------------------------------------
    // we now have a Day of year, convert back to day / month
    //-------------------------------------------------------
    DayOfYear = (int) TmpResult;
    if(CheckLeapYear(AbsTimeArray[TIME_YEAR_INDEX]) == IS_NOT_LEAP_YEAR)
    {
     if(DayOfYear > (31+28)) DayOfYear++;	// past february normal year
    }
    i = 0;					// Field index january
    for(;;)
    {
      if(DayOfYear <= MaxDaysOfMonth[i]) break;	// date decoded
      DayOfYear -= MaxDaysOfMonth[i++];		// reduce days, incr. index
    }
    //-------------------------------------------------------
    // Store new absolute array Month and Day now
    //-------------------------------------------------------
    AbsTimeArray[TIME_MONTH_INDEX] = (i+1);	// save month
    AbsTimeArray[TIME_DAY_INDEX] = DayOfYear;	// save day
    //-------------------------------------------------------
    // Subtract years
    //-------------------------------------------------------
    TmpResult = (int) AbsTimeArray[TIME_YEAR_INDEX] -
                (int) DeltaTimeArray[TIME_YEAR_INDEX];
    if(TmpResult < GREGORIAN_YEAR) return(-1);	// not allowed
    AbsTimeArray[TIME_YEAR_INDEX] = (int) TmpResult;// store
    //-------------------------------------------------------
    // Process final backward leap year correction now
    //-------------------------------------------------------
    if((AbsTimeArray[TIME_MONTH_INDEX] == 2) &&	// is march
       (AbsTimeArray[TIME_DAY_INDEX] == 29)  && // is 29th
       (CheckLeapYear(AbsTimeArray[TIME_YEAR_INDEX]) ==
         IS_NOT_LEAP_YEAR))
    {
      AbsTimeArray[TIME_MONTH_INDEX] = 3;	// set march
      AbsTimeArray[TIME_DAY_INDEX] = 1;		// set 1st
    }
    return(0);					// o.k.
  } // Mode ELSE
}
/**
* Subroutine AsciiDecimalNumToInteger, converts and stores
* a given ASCII decimal number representation to a HEX value (int) (AsciiDecimalNumToInteger).
*
* Note: 1. The Validity of the buffer length is N O T checked
*       2. The converted decimal value must be <= 0x7FFF !
*
*  @param InpData Array base
*  @param InpOffset Offset to start of string
*  @param Digits Number of digits to convert
*  @param Result Array base for result
*  @param ResultIndex Array index for result
*
*  @return ASN1_OP_OK Convertion succeeded
* <br>            ASN1_INVALID_ASCII_DIGIT non Decimal ASCII found
* <br>            ASN1_INTERNAL_ERROR processing error
*/
static  int AsciiDecimalNumToInteger(char* InpData,
			int InpOffset, int Digits, int* Result,
                        int ResultIndex)
{
  int InpIndex = InpOffset;
  int Number;
  int Temp;
  int c;

  Number=0;  
  while(Digits != 0)
  {
    Temp = Number << 3;			// * 8
    Temp += (Number * 2);		// * 10
    if(Temp < 0)
      return(ASN1_DEC_NUM_TO_INT_DIGITS_ERR);	// should not happen
    c = ((int) InpData[InpIndex++] & 0xFF) - 0x30;	// get hex value
    if((c < 0) || (c > 9))
      return(ASN1_DEC_NUM_TO_INT_INV_DIGIT);	// not a valid digit
    Number = Temp + c;				// add digit
    if(Number < 0)
      return(ASN1_DEC_NUM_TO_INT_NEGATIVE_ER);	// should not happen
    Digits--;
  }
  Result[ResultIndex] = Number;
  return(ASN1_OP_OK);  
}

extern "C"  int ConvChkASN1_TimeStr(char* InpData, int InpOffset,
			    int InpLen, int* TimeArray, int TimeType)
{
  int i,j;
  int timeIndex=0;
  int InpIndex = InpOffset;
  int DataLen = InpLen;
  int MinLen=UTC_TIME_MIN_LEN;
  int FractLen;
  int Temp;
  int Year;
  int Month;
  int Day;
  int Hour;
  int Minute;
  int DeltaHour = 0;
  int DeltaMinute = 0;
  int DeltaSign = 0;

  int DeltaTimeArray[TIME_ARRAY_SIZE];
  //-------------------------------------------------------
  // check minimal necessary datalength
  //-------------------------------------------------------
  if(TimeType != ASN1_TIME_TYPE_UTC) MinLen = GENERAL_TIME_MIN_LEN;
  if(InpLen < MinLen) return(ASN1_TIME_TO_INT_DATA_MISSING);
  //-------------------------------------------------------
  // get Year
  //-------------------------------------------------------
  if(TimeType == ASN1_TIME_TYPE_UTC)
  {
    i = AsciiDecimalNumToInteger(InpData, InpIndex, 2, TimeArray,
			         timeIndex);
    if(i != ASN1_OP_OK) return(i);
    Year = TimeArray[timeIndex];
    if(Year >= 50) Year += 1900;		// 1950-1999
    else Year += 2000;				// 2000-2049
    InpIndex += 2;
    TimeArray[timeIndex] = Year;
  }
  else
  {
    i = AsciiDecimalNumToInteger(InpData, InpIndex, 4, TimeArray,
			         timeIndex);
    if(i != ASN1_OP_OK) return(i);
    Year = TimeArray[timeIndex];
    if((Year <= GREGORIAN_YEAR) || (Year > MAX_YEAR))
      return(ASN1_TIME_TO_INT_INVAL_YEAR);
    InpIndex += 4;
  }
  timeIndex++;
  //-------------------------------------------------------
  // get Month, check value
  //-------------------------------------------------------
  i = AsciiDecimalNumToInteger(InpData, InpIndex, 2, TimeArray,
			       timeIndex);
  if(i != ASN1_OP_OK) return(i);
  Month = TimeArray[timeIndex];
  if((Month < 1) || (Month > 12))
    return(ASN1_TIME_TO_INT_INVAL_MONTH);
  InpIndex += 2;
  timeIndex++;
  //-------------------------------------------------------
  // get Day, check value
  //-------------------------------------------------------
  i = AsciiDecimalNumToInteger(InpData, InpIndex, 2, TimeArray,
			       timeIndex);
  if(i != ASN1_OP_OK) return(i);
  Day = TimeArray[timeIndex];
  Temp = MaxDaysOfMonth[Month-1];		// get upper limit
  if((Month == 2) && (CheckLeapYear(Year) == IS_NOT_LEAP_YEAR))
    Temp--;					// 1 day less
  if((Day < 1) || (Day > Temp))
    return(ASN1_TIME_TO_INT_INVAL_DAY);
  InpIndex += 2;
  timeIndex++;
  //-------------------------------------------------------
  // get Hour, check value
  //-------------------------------------------------------
  i = AsciiDecimalNumToInteger(InpData, InpIndex, 2, TimeArray,
			       timeIndex);
  if(i != ASN1_OP_OK) return(i);
  Hour = TimeArray[timeIndex];
  if(Hour >= 24) return(ASN1_TIME_TO_INT_INVAL_HOUR);
  InpIndex += 2;
  timeIndex++;
  //-------------------------------------------------------
  // get Minute, check value
  //-------------------------------------------------------
  i = AsciiDecimalNumToInteger(InpData, InpIndex, 2, TimeArray,
			       timeIndex);
  if(i != ASN1_OP_OK) return(i);
  Minute = TimeArray[timeIndex];
  if(Minute > 59) return(ASN1_TIME_TO_INT_INVAL_MINUTES);
  InpIndex += 2;
  timeIndex++;
  //-------------------------------------------------------
  // preload seconds/milliseconds with 0, check if seconds
  // present, End or Time Differential
  //-------------------------------------------------------
  TimeArray[timeIndex] = 0;
  TimeArray[timeIndex+1] = 0;

  DataLen -= MinLen;

  if(DataLen == 0)
  {
    TimeArray[TIME_LOCAL_FLAG] = 1;
    return(ASN1_OP_OK);
  }
  Temp = (int) InpData[InpIndex] & 0xFF;	// get next character  
  if((Temp != MINUS_CHAR) && (Temp != PLUS_CHAR) &&	// seconds present
     (Temp != ZULU_CHAR))
  {
    //-------------------------------------------------
    // process seconds
    //-------------------------------------------------
    if(DataLen < 2)				// must have >=2 bytes !!
      return(ASN1_TIME_TO_INT_DATA_MISSING);
    i = AsciiDecimalNumToInteger(InpData, InpIndex, 2, TimeArray,
			         timeIndex);
    if(i != ASN1_OP_OK) return(i);
    if(TimeArray[timeIndex] > 59)
      return(ASN1_TIME_TO_INT_INVAL_SECONDS);
    DataLen -=2;					// 2 characters processed
    InpIndex += 2;
    timeIndex++;				// to milliseconds
    //-------------------------------------------------------
    // Check if End / SecondFractions / Differential
    //-------------------------------------------------------
    Temp = (int) InpData[InpIndex++] & 0xFF;	// get next character  
    DataLen--;					// reduce count
    if(Temp == ZULU_CHAR)			// End reached
    {
      if(DataLen == 0) return(ASN1_OP_OK);
      return(ASN1_TIME_TO_INT_INVAL_DATLEN);
    }
    if(((Temp == DOT_CHAR) && (TimeType == ASN1_TIME_TYPE_UTC)) ||
        ((Temp != MINUS_CHAR) && (Temp != PLUS_CHAR) &&
         (Temp != DOT_CHAR)))
      return(ASN1_TIME_TO_INT_INVAL_DATA);
    if((Temp == DOT_CHAR) && (DataLen < 2))
      return(ASN1_TIME_TO_INT_DATA_MISSING);
    if(Temp == DOT_CHAR)
    {
      //-------------------------------------------------
      // process milliseconds, count number of figures
      //-------------------------------------------------
      FractLen=0;
      i = DataLen;	      			// get remaining length
      j = InpIndex;				// get current pos.
      do
      {
        Temp = (int) InpData[j++] & 0xFF;	  // get next
        if((Temp < 0x30) || (Temp > 0x39)) break; // not a number
        FractLen++;
        i--;
      }while(i != 0);
      if(FractLen == 0) return(ASN1_TIME_TO_INT_INVAL_MSECS);
      i = FractLen;
      if(i > 3) i = 3;				// truncate to 3 digits
      i = AsciiDecimalNumToInteger(InpData, InpIndex, i, TimeArray,
				   timeIndex);
      if(i != ASN1_OP_OK) return(i);
      if(FractLen < 3)				// must normalize !!
      {
        i = 3 - FractLen;
        do{TimeArray[timeIndex] *= 10;i--;}while(i!=0);
      }
      DataLen -= FractLen;
      InpIndex += FractLen;      
      if(DataLen == 0)
      {
        TimeArray[TIME_LOCAL_FLAG] = 1;
        return(ASN1_OP_OK);
      }
      Temp = (int) InpData[InpIndex++];
      DataLen--;				// reduce
    }
  }
  else
  {
     InpIndex++;				// was +/-/Z-Character
     DataLen--;
  }
  //-------------------------------------------------------
  // Extension present or END, decide what to do
  //-------------------------------------------------------
  switch(Temp)
  {
    case ZULU_CHAR:				// UPPER Z
      if(DataLen != 0) return (ASN1_TIME_TO_INT_INVAL_DATLEN);
      return(ASN1_OP_OK);
 
    case PLUS_CHAR:				// PLUS  SIGN
      DeltaSign = 1;				// must subtract (!)

    case MINUS_CHAR:				// MINUS SIGN
      if(DataLen < 4) return(ASN1_TIME_TO_INT_DATA_MISSING);
      if(DataLen != 4) return(ASN1_TIME_TO_INT_INVAL_DATLEN);
      break;

    default:
      return(ASN1_TIME_TO_INT_INVAL_DATA);
  }
  //-------------------------------------------------------
  // Clear temporary Delta Time Array
  //-------------------------------------------------------
  i=TIME_ARRAY_SIZE;
  do{i--;DeltaTimeArray[i] = 0;}while(i!=0);
  //-------------------------------------------------------
  // get Delta Hour, check value
  //-------------------------------------------------------
  i = AsciiDecimalNumToInteger(InpData, InpIndex, 2,
			       DeltaTimeArray,TIME_HOUR_INDEX);

  if(i != ASN1_OP_OK) return(i);
  DeltaHour = DeltaTimeArray[TIME_HOUR_INDEX];
  if((DeltaHour < 0) || (DeltaHour >= 24))
    return(ASN1_TIME_TO_INT_INVAL_DELTHOUR);
  InpIndex += 2;
  //-------------------------------------------------------
  // get Delta Minute, check value
  //-------------------------------------------------------
  i = AsciiDecimalNumToInteger(InpData, InpIndex, 2,
			       DeltaTimeArray,TIME_MINUTES_INDEX);
  if(i != ASN1_OP_OK) return(i);
  DeltaMinute = DeltaTimeArray[TIME_MINUTES_INDEX];
  if((DeltaMinute < 0) || (DeltaMinute > 59))
    return(ASN1_TIME_TO_INT_INVAL_DELTMINS);
  //-------------------------------------------------------
  // check if adjustment is required (both deltas != 0)
  //-------------------------------------------------------
  if((DeltaHour == 0) && (DeltaMinute == 0))	// no adjustment
    return(ASN1_OP_OK);
  //-------------------------------------------------------
  // Adjustment required, check add/subtract
  //-------------------------------------------------------
  i = AddTimeArrayDeltaTime(TimeArray,DeltaTimeArray,DeltaSign);
  if(i != 0) return(ASN1_TIME_TO_INT_INVAL_DATLEN);
  return(ASN1_OP_OK);
}

extern "C"  int CompareTimeArrays(int* TimeArray1,
			 	  	 int* TimeArray2)
{
  int i;
  //------------------------------------------------
  // compare beginning with the year, do NOT compare
  // local flag, this will be done outside !!
  //------------------------------------------------
  for(i=0; i<TIME_ARRAY_SIZE-1;i++)
  {
    if(TimeArray1[i] == TimeArray2[i]) continue;// same values
    if(TimeArray1[i] > TimeArray2[i])
      return(ASN1_1ST_GT_2ND);			// 1st > 2nd
    else return(ASN1_1ST_LT_2ND);		// 1st < 2nd
  }
  return(ASN1_1ST_EQ_2ND);
}

//GetCheckLocalTimeArray
extern "C"  int GetCheckLocalTimeArray(int UTCTime, int Mode,
				int* TimeArray)
{
  int	Index;
  int	Carry;
  int	Temp;
  int   MilliSecs;
  int	Seconds;
  int	Minutes;
  int   Hour;
  int	Day;
  int	Month;
  int	Year;
  int   Retcode;
  //----------------------------------------------
  // Get/Set Date and time from UTC
  //----------------------------------------------
  time_t timer;
  struct tm * timeStruc;

  if(Mode == 0)					// use current time
    time(&timer);				// get the UTC time
  else 
    timer = UTCTime;				// set given

  timeStruc = gmtime(&timer);			// convert to date/time format

  if(Mode == 0)					// current time
    Retcode = ASN1_GET_CHK_LCL_INV_CURR_TIME;
  else						// UTC set
    Retcode = ASN1_GET_CHK_LCL_INV_UTC_TIME;

  if(timeStruc == NULL) return(Retcode);	// should not happen
  //----------------------------------------------
  // load the time array from the structure
  //----------------------------------------------
  Year      = timeStruc->tm_year;		// get year
  Month     = timeStruc->tm_mon + 1;	// get month
  Day       = timeStruc->tm_mday;		// get day
  Hour      = timeStruc->tm_hour;		// get hours
  Minutes   = timeStruc->tm_min;	// get minutes
  Seconds   = timeStruc->tm_sec;	// get seconds
  MilliSecs = 0;		// get milli seconds

  if(Year < 1900) Year += 1900;			// no correction with JAVA
  for(;;)					// Error processing for
  {
    //------------------------------------------------------
    // Verify/Correct the time array (e.g. seconds = 60, hour = 24)
    //------------------------------------------------------
    Carry = 0;
    if((Seconds < 0) || (Seconds > 60)) break;
    if(Seconds == 60) Seconds = 59;		// simlpy ignore
    if((Minutes < 0) || (Minutes > 59)) break;
    if((Hour    < 0) || (Hour > 24)) break;
    if(Hour == 24)
    {
      if((Minutes != 0) || (Seconds != 0)) break;
      Hour = 0;
      Carry = 1;
    }
    if((Year < GREGORIAN_YEAR) || (Year > 9999)) break;
    if((Month < 1) || (Month > 12)) break;
    Temp = MaxDaysOfMonth[Month-1];
    if((Month == 2) && (CheckLeapYear(Year) == IS_NOT_LEAP_YEAR))
      Temp--;
    if((Day < 1) || (Day > Temp)) break;

    Retcode = ASN1_OP_OK;
    if(Carry == 0) break;			// no adjust needed
    //------------------------------------------------------
    // Adjust strange case of 24:00:00
    //------------------------------------------------------
    Day ++;					// to next day
    if(Day < Temp) break;			// in range
    Day = 1;					// to Start of month
    Month++;					// to next month
    if(Month < 12) break;			// in range
    Month = 1;					// to Start of Year
    Year++;
    if(Year < 9999) break;			// valid
    if(Mode == 0)
      Retcode = ASN1_GET_CHK_LCL_INV_CURR_TIME;	// set returncode
    else
      Retcode = ASN1_GET_CHK_LCL_INV_UTC_TIME;	// set returncode
    break;
  } // Error-FOR Loop
  if(Retcode == ASN1_OP_OK)
  {
    Index = TIME_YEAR_INDEX;			// base of Array
    TimeArray[Index++] = Year;
    TimeArray[Index++] = Month;
    TimeArray[Index++] = Day;
    TimeArray[Index++] = Hour;
    TimeArray[Index++] = Minutes;
    TimeArray[Index++] = Seconds;
    TimeArray[Index++] = MilliSecs;
    TimeArray[Index] = UTC_TIME_FLAG;
  }
  return(Retcode);
}
/**
* Subroutine MatchASN1_TimeTypes compares two ASN.1 Time Strings (MatchASN1_TimeTypes).
* either UTC/GeneralTime (mixed mode allowed)
* Equality definition:
*      ---------------
* Same contents and same type (local/Utc)
*
*
*  @param Base1 Data Base 1
*  @param InpOffset1 Start Data 1
*  @param DataLen1 length Data 1
*  @param Time1Type type, UTC/General
*  @param Base2 Data Base 2
*  @param InpOffset2 Start Data 2
*  @param DataLen2 length Data 2
*  @param Time2Type type, UTC/General
*  @param CmpResult result
*  @return ASN1_OP_OK on success, error code otherwise
* <br>            - else Error occurred
*/
static  int  MatchASN1_TimeTypes(char* Base1,
			int InpOffset1, int DataLen1, int Time1Type,
			char* Base2, int InpOffset2, int DataLen2,
			int Time2Type, int* CmpResult)
{

  int RetCode;

  int Time1Array[TIME_ARRAY_SIZE];
  int Time2Array[TIME_ARRAY_SIZE];

  CmpResult[0] = ASN1_NOT_SAME; 
  //------------------------------------------------------
  // Convert first type to Array
  //------------------------------------------------------
  RetCode = ConvChkASN1_TimeStr(Base1,InpOffset1,DataLen1,
				Time1Array,Time1Type);
  if(RetCode != ASN1_OP_OK) return(RetCode);
  //------------------------------------------------------
  // Convert Second Type to Array
  //------------------------------------------------------
  RetCode = ConvChkASN1_TimeStr(Base2,InpOffset2,DataLen2,
				Time2Array,Time2Type);
  if(RetCode != ASN1_OP_OK) return(RetCode);
  //------------------------------------------------------
  // Compare time types first
  //------------------------------------------------------
  if(Time1Array[TIME_LOCAL_FLAG] != Time2Array[TIME_LOCAL_FLAG])
    return(ASN1_OP_OK);				// not same
  //------------------------------------------------------
  // Compare time Arrays
  //------------------------------------------------------
  RetCode = CompareTimeArrays(Time1Array,Time2Array);
  if(RetCode == 0) CmpResult[0] = ASN1_SAME;		// same
  return(ASN1_OP_OK);
}
/**
* Subroutine CheckValidASN1DirStringType checks if an attribute
* value encoding is a valid Directory String Type (CheckValidASN1DirStringType).
*
* Note: Only the following ASN.1 string types are supported:
*      
*	ASN1_UNIVERSAL_PRINTABLESTR
*	ASN1_UNIVERSAL_TELETEXSTR
*	ASN1_UNIVERSAL_IA5STR
*	ASN1_UNIVERSAL_BMPSTR
*	ASN1_UNIVERSAL_UNIVSTR
*	ASN1_UNIVERSAL_UTF8STR
*
*  @param ASN1Type class/constructed/type
*
*  @return int Result: >= 0 o.k.
* <br>            < 0 not supported
*/
static  int CheckValidASN1DirStringType(char ASN1Type)
{
  char Asn1Type=ASN1Type;			// local

  //-------------------------------------------------------------
  // check for ASN1 universal primitive encoding
  //-------------------------------------------------------------
  if((Asn1Type & (ASN1_CLASS_MASK | ASN1_CONSTRUCTED_MASK)) != 0)
    return(0);

  switch(Asn1Type)
  {
    case ASN1_UNIVERSAL_PRINTABLESTR:
    case ASN1_UNIVERSAL_TELETEXSTR:
    case ASN1_UNIVERSAL_IA5STR:
    case ASN1_UNIVERSAL_BMPSTR:
    case ASN1_UNIVERSAL_UNIVSTR:
    case ASN1_UNIVERSAL_UTF8STR:
      return(1);				// supported

    default:
      return(-1);				// unsupported type
  }
}
/**
* Subroutine GetASN1StringCharCellSize gets the cell size (in bytes)
* per character for asn Asn.1 defined string type (GetASN1StringCharCellSize).
* Note: The ASN.1 Type must be universal primitive !!
*      
*
* Note: Only the following ASN.1 string types ares supported:
*      
*	ASN1_UNIVERSAL_PRINTABLESTR			* 1 Byte per cell
*	ASN1_UNIVERSAL_TELETEXSTR			* dto.
*	ASN1_UNIVERSAL_IA5STR				* dto.
*	ASN1_UNIVERSAL_BMPSTR				* 2 Bytes per cell
*	ASN1_UNIVERSAL_UNIVSTR				* 4 Bytes per cell
*	ASN1_UNIVERSAL_UTF8STR				* variable size
*
*  @param ASN1Type ASN1-Type
*
*  @return int Result: >= 0 o.k.
* <br>            < 0 not supported
*/
static  int GetASN1StringCharCellSize(char ASN1Type)
{
  int StrCellSize = -1;				// preload invalid

  char Asn1Type=ASN1Type;			// local
  //--------------------------------------------------------------
  // get the appropriate string type's cellsize
  //--------------------------------------------------------------
  switch(Asn1Type)
  {
    case ASN1_UNIVERSAL_PRINTABLESTR:
    case ASN1_UNIVERSAL_TELETEXSTR:
    case ASN1_UNIVERSAL_IA5STR:
      StrCellSize = 1;					// 1 byte types
      break;

    case ASN1_UNIVERSAL_BMPSTR:
      StrCellSize = 2;					// 2 byte types
      break;

    case ASN1_UNIVERSAL_UNIVSTR:
      StrCellSize = 4;					// 4 byte types
      break;

    case ASN1_UNIVERSAL_UTF8STR:
      StrCellSize = 0;					// variable size
      break;

    default:
      break;						// unknown type
  }
  return(StrCellSize);
}
/**
* Subroutine CheckWhitespace checks if character is a whitespace (CheckWhitespace).
* Note: Only ASCII/LATIN1 characterset is used for check !
*      
*
* Whitespaces are: ASCII-Character: SPACE 0x20
*      ----------- ASCII-Control:   TAB   0x09
*		    ASCII-Control:   LF    0x0A
*		    ASCII-Control:   ??	   0x0B
*		    ASCII-Control:   ??    0x0C
*		    ASCII-Control:   CR    0x0D
*		    LATIN1-Space           0xA0
*
*  @param Char Character to check
*
*  @return int Result == 0 - Is not a Whitespace
* <br>            <> 0 - Is a Whitespace
*/
static  int CheckWhitespace(int Char)
{
  //--------------------------------------------------------------
  // Check if character is an ASCII/LATIN1 white space
  //--------------------------------------------------------------
  if((Char >> 8) != 0) return(0);		// not from ASCII/LATIN1 set
  if((Char == 0x20) || (Char == 0xA0) ||	// is an ASCII/Latin1 Space
     ((Char >= 0x09) && (Char <= 0x0D)))	// is a valid contol ASCII
    return(1);					// is a Whitespace
  return(0);
}
/**
* Subroutine ToUpperAsn1Char converts a recognized lower case
* character to an uppercase character (ToUpperAsn1Char).
*
* Note: Only ASCII/LATIN1 characterset is converted
*       (LATIN1 has to be implemented !!!)
*
*  @param Char character to convert
*
*  @return BIT32 Converted/unchanged character
*/
static  int ToUpperAsn1Char(int Char)
{
  //--------------------------------------------------------------
  // Check if character is an ASCII/LATIN1 character (page0/page1)
  //--------------------------------------------------------------
  if((Char >> 8) != 0) return(Char);		// not from ASCII/LATIN1 set
  if(Char > 0x80)				// is from LATIN1
  {
    //------------------------------------------------------------
    // is LATIN1 character, check/convert
    //------------------------------------------------------------
    if((Char >= 0xE0) && (Char <= 0xFE))	// might be lower char
      if(Char != 0xF7) Char &= (~0x20) & 0xFF;	// convert to upper
    return(Char);
  }
  //--------------------------------------------------------------
  // is ASCII character, check/convert
  //--------------------------------------------------------------
  if((Char >= 0x61) && (Char <= 0x7A))		// is lower ASCII (page0)
    Char &= (~0x20) & 0xFF;			// convert to Upper    
  return(Char);
}

extern "C"  int GetUCS4Char(char* StrData, int StrOffset,
			    int StrLen, int StrCellSize, int* Char)
{
  char c8;
  int c32;

  int i;
  int CharCnt;

  int InpIndex = StrOffset;
  int DataLen = StrLen;

  //-------------------------------------------------------
  // check if string data present
  //-------------------------------------------------------
  if(DataLen == 0) return(0);		// end of string
  //-------------------------------------------------------
  // distribute according to cell size
  //-------------------------------------------------------
  switch(StrCellSize)
  {
    //-------------------------------------------------------
    // cell size 4, Universal String
    //-------------------------------------------------------
    case 4:						// UCS-4
      if(DataLen < 4) return(-1);			// not enough data
      Char[0] =
       ((int)
        ((((short) StrData[InpIndex] << 8) & 0xFFFF)   | // get 1st byte
          ((short) StrData[InpIndex+1] & 0xFF)) << 16) | // get 2nd byte

        ((int)
         ((short) StrData[InpIndex+2] << 8) & 0xFFFF) |	// get 3rd byte
        ((int)  StrData[InpIndex+3] & 0xFF);		// get 4th byte
      return(4);
    //-------------------------------------------------------
    // cell size 2, Unicode / BMP String
    //-------------------------------------------------------
    case 2:						// UCS-2
      if(DataLen < 2) return(-1);			// not enough data
      Char[0] =
        ((int)
         ((short) StrData[InpIndex]  << 8) & 0xFFFF) |	// get 1st byte
      	 ((int) (StrData[InpIndex+1] & 0xFF));	// get 2nd byte
      return(2);
    //-------------------------------------------------------
    // cell size 1, printable/teletex string
    //-------------------------------------------------------
    case 1:						// Standard
      Char[0] = (int) StrData[InpIndex++] & 0xFF;	// get 1st byte
      return(1);
    //-------------------------------------------------------
    // cell size 0, UTF-8 String (what a mess !)
    //-------------------------------------------------------
    case 0:						// UTF-8
      c8 = StrData[InpIndex++];				// get 1st byte
      if((c8 & 0x80) == 0)				// Plain old ASCII
      {
        Char[0] = (int) c8;
        return(1);
      }
      //-------------------------------------------------------
      // get UTF-8 total byte count (2..6)
      //-------------------------------------------------------
      CharCnt = 0;					// set zero
      for(;;)
      {
        CharCnt++;					// increment count
        c8 <<= 1;					// shift up 1 bit
        if((c8 & 0x80) == 0) break;			// all bits processed
      }
      //-------------------------------------------------------
      // check valid total count and enough data present
      //-------------------------------------------------------
      if((CharCnt < 2) || (CharCnt > 6) ||		// invalid size
         (CharCnt > DataLen)) return(-1);		// too few data
      //-------------------------------------------------------
      // decode the UTF-8 representation to UCS-4
      //-------------------------------------------------------
      c32 = c8 >> CharCnt;				// set top bits
      i = CharCnt-1;					// ignore 1st byte !!
      do
      {
        c8 = StrData[InpIndex++];			// get next byte
        if((c8 & 0xC0) != 0x80) return(-1);		// invalid encoding
        c32 = (c32 <<6) | (c8 & 0x3F);			// insert bits
        i--;
      } while(i != 0);
      Char[0] = c32;
      return(CharCnt);
    //---------------------------------------------------------
    // invalid cell size (should not happen)
    //---------------------------------------------------------
    default:						// unknown size
      return(-1);	

  } // switch
}
/**
* Subroutine SkipASN1StringWhiteSpaces skips whitespaces
* in a Asn1 Directory type String (SkipASN1StringWhiteSpace).
*
*  @param StrData *               Array base
*  @param StrOffset *               Offset to Start, updated
*  @param StrLen *               Length of data, updated
*  @param StrCellSize *               1, 2, 4 and 0 (variable)
*
*  @return int Status == 0 - End of String
* <br>            < 0 Not enough data/Error
* <br>            Offset/Len NOT updated
* <br>            > 0 - more data present
*/
static  int SkipASN1StringWhiteSpace(char* StrData,
					        int* StrOffset,
					        int* StrLen,
					        int StrCellSize)
{
  int i;
  int InpIndex = StrOffset[0];
  int DataLen = StrLen[0];

  int c32[1];

  //----------------------------------------------------------
  // check if string data present
  //----------------------------------------------------------
  if(DataLen == 0) return(0);		// nothing to do
  //----------------------------------------------------------
  // skip whitespaces
  //----------------------------------------------------------
  do
  {
    i = GetUCS4Char(StrData,InpIndex,DataLen,StrCellSize,c32);
    if(i <= 0) return(i);
    if(CheckWhitespace(c32[0]) == 0)	// not a whitespace
    {
      StrOffset[0] = InpIndex;
      StrLen[0] = DataLen;
      return(1);
    }
    DataLen -= i;			// reduce count
    InpIndex += i;			// increment index
  } while(DataLen > 0);
  return(0);
}
/**
* Subroutine GetUTF8_CharByteCount calculates required
* byte count for UTF8 encoded character (GetUTF8_CharByteCount).
*
*  @param StartChar First Char. of UTF8
*  @return int Count > 0 number of elements
* <br>            == 0 invalid starting character
*/
static  int GetUTF8_CharByteCount(char StartChar)
{
  char c = StartChar;
  int Cnt = 0;

  if((c & 0x80) == 0) return(1);		// 7 Bit
  do
  {
    c <<= 1;					// shift up 1 bit
    Cnt++;
    if((c & 0x80) == 0) break;  
  }while(Cnt <= 6);
  if((Cnt < 1) || (Cnt > 6)) return(0);	// invalid
  return(Cnt);
}

extern "C"  int FromASN1_String(HMEM_CTX_DEF
		char* SrcBuf, int SrcOff,
		int SrcLen, char** ppDstBuf)
{
  char	c;

  char ASN1Type;

  int SrcIndex = SrcOff;

  int DstIndex = 0;
  int DstCnt;

  int i;
  int TmpCnt;
  int TmpIndex;

  int CharCellSize;

  int Tmp;
  int TmpLen;
  int pTmpLen[1];

  char* pBuf = NULL;

  //-----------------------------------------
  // Check pointers
  //-----------------------------------------
  if((SrcBuf == NULL) || (ppDstBuf == NULL))
    return(ASN1_FROM_STRING_NULLPTR_ERR);
  if(SrcLen < 2)
    return(ASN1_FROM_STRING_INSUF_DATA_ERR);
  ppDstBuf[0] = NULL;
  //------------------------------------------------------------
  // Get ASN.1 Type and length, check if a recognized stringtype
  //------------------------------------------------------------
  ASN1Type = SrcBuf[SrcIndex++];		// get type
  SrcLen--;
						// get length and lenfld len:
  i = DecodeASN1_LenField(SrcBuf,SrcIndex,SrcLen,pTmpLen);
  if(i < 0)
  {
    if(i == -2) return(ASN1_FROM_STRING_INSUF_DATA_ERR);
    return(ASN1_FROM_STRING_INV_LEN_ERR);
  }
  SrcIndex += i;			// skip lengthfield
  TmpLen = pTmpLen[0];			// fetch data count
  if(TmpLen == 0)			// no data -> no output
    return(ASN1_OP_OK);
  if(TmpLen > (0x7FFF-8))		// max. length
    return(ASN1_FROM_STRING_INV_LEN_ERR);

  switch(ASN1Type)
  {
    case ASN1_UNIVERSAL_VISIBLESTR:
    case ASN1_UNIVERSAL_IA5STR:
    case ASN1_UNIVERSAL_NUMERICSTR:
    case ASN1_UNIVERSAL_PRINTABLESTR:
    case ASN1_UNIVERSAL_TELETEXSTR:
      CharCellSize = 1;				// 1 byte types
      if(TmpLen > (0x3FFF-4))
        return(ASN1_FROM_STRING_INV_LEN_ERR);
      DstCnt = (int) TmpLen;
      break;

    case ASN1_UNIVERSAL_BMPSTR:
      CharCellSize = 2;				// 2 byte types
      if((TmpLen & 0x01) != 0)
        return(ASN1_FROM_STRING_INV_LEN_ERR);
      DstCnt = (int) (TmpLen >> 1);
      break;

    case ASN1_UNIVERSAL_UNIVSTR:
      CharCellSize = 4;				// 4 byte types
      if((TmpLen & 0x03) != 0)
        return(ASN1_FROM_STRING_INV_LEN_ERR);
      DstCnt = (int) (TmpLen >> 2);
      break;

    case ASN1_UNIVERSAL_UTF8STR:
      CharCellSize = 0;				// variable size
      TmpIndex = SrcIndex;
      TmpCnt = (int) TmpLen;			// get length
      DstCnt=0;
      do
      {
        c = SrcBuf[TmpIndex++];			// get character
        TmpCnt--;
        DstCnt++;
        i = GetUTF8_CharByteCount(c);		// get total count
        if(i <= 0)				// invalid encoding
          return(ASN1_FROM_STRING_INV_DATA_ERR);
        i--;					// set relative Startbyte
        if(i > TmpCnt)				// too few data
	  return(ASN1_FROM_STRING_INSUF_DATA_ERR);
        TmpIndex += i;				// skip
        TmpCnt -= i;				// reduce
      }while(TmpCnt != 0);
      if(DstCnt > (0x3FFF - 4))			// too much elements
        return(ASN1_FROM_STRING_INV_LEN_ERR);
      break;

    default:
      return(ASN1_FROM_STRING_INV_TYPE_ERR);
  }
  //-------------------------------------------------
  // Allocate required destination buffer
  //-------------------------------------------------
  pBuf = BIT8_ARRAY_ALLOC(HMEM_CTX_REF,(DstCnt+1)*2);
  if(pBuf == NULL)
    return(ASN1_FROM_STRING_ALLOC_ERR);
  BIGword2char(DstCnt,pBuf,DstIndex);		// set element count
  //-------------------------------------------------
  // Convert the types
  //-------------------------------------------------
  switch(CharCellSize)
  {
    case 1:					// UCS1
      do
      {
        pBuf[DstIndex++] = 0;			// clear MSB
        pBuf[DstIndex++] = SrcBuf[SrcIndex++];
	DstCnt--;
      }while(DstCnt != 0);
      break;      

    case 2:					// UCS2
      memcpy(pBuf+DstIndex,SrcBuf+SrcIndex,DstCnt*2);
      break;

    case 4:
      do
      {
        BIGchar2long(SrcBuf,Tmp,SrcIndex);	// get character
	if((Tmp & 0xFFFF0000) != 0)		// not displayable
	{
          pBuf[DstIndex++] = 0;
          pBuf[DstIndex++] = (char) '-';
        }
        else BIGword2char(Tmp,pBuf,DstIndex);	// store full word
        DstCnt--;
      }while(DstCnt != 0);
      break;

    case 0:
      do
      {
        i = GetUCS4Char(SrcBuf,SrcIndex,(int) TmpLen,0,pTmpLen);
        if(i <= 0)
        {
          FREE_ARRAY(HMEM_CTX_REF,pBuf);
          return(ASN1_FROM_STRING_INSUF_DATA_ERR);
        }
        SrcIndex += i;			// skip Element
        TmpLen -= i;			// reduce length
        Tmp = pTmpLen[0];		// get UCS 4
	if((Tmp & 0xFFFF0000) != 0)		// not displayable
	{
          pBuf[DstIndex++] = 0;
          pBuf[DstIndex++] = (char) '-';
        }
        else BIGword2char(Tmp,pBuf,DstIndex);	// store full word
        DstCnt--;
      }while(DstCnt != 0);
      break;
  } // switch
  ppDstBuf[0] = pBuf;
  return(ASN1_OP_OK);
}

extern "C"  int BitBuftoBIT32Flagsf(char* SrcBuf,
		int SrcOff, int SrcLen,	int* pFlags)
{
  int Index = SrcOff;
  int UsedBytes = SrcLen-1;
  int UnusedBits;

  int lFlags=0;
  int Mask = 0x7FFFFFFF;
  //----------------------------------------------------------------
  // check parameters
  //----------------------------------------------------------------
  if((SrcBuf == NULL) || (pFlags == NULL))
    return(ASN1_BUF_TO_BIT32FLG_NULPTR_ERR);
  if((SrcLen <= 1) || (SrcLen > 5))
    return(ASN1_BUF_TO_BIT32FLG_INVLEN_ERR);
  UnusedBits = SrcBuf[Index++];
  if((UnusedBits < 0) || (UnusedBits > 7))  
    return(ASN1_BUF_TO_BIT32FLG_INVBIT_ERR);
  //----------------------------------------------------------------
  // Copy to number
  //----------------------------------------------------------------
  do
  {
    lFlags <<= 8;			// shift up
    lFlags |= (int) SrcBuf[Index++] & 0xFF;
    UsedBytes--;
  }while(UsedBytes != 0);
  //----------------------------------------------------------------
  // Shift down unused bits
  //----------------------------------------------------------------
  if(UnusedBits != 0)
  {
    Mask >>= (UnusedBits-1);
    lFlags = (lFlags >> UnusedBits) & Mask;
  }
  pFlags[0] = lFlags;
  return(ASN1_OP_OK);
}

/**
* Compares 2 ASN1 Ddirectory name strings for equivalence (CheckSameASN1DirNameStrings).
*
* Supported types are X.500 defined directory name string types.
* These will be compared in whitespace compressed form and case
* insensitive if required.
*
* NOTE: Only equivalence (restricted to ASCII/LATIN1 upper/lower
*       conversion rules [case insensitive]) check is supported.
*
* Supported ASN.1 string types are:
*<ul>
* <li> PrintableString				(1 Byte  per cell)
* <li> TeletexString				(1 Byte  per cell)
* <li> IA5String					(1 Byte  per cell)
* <li> BMPString					(2 Bytes per cell)
* <li> UniversalString				(4 Bytes per cell)
* <li> UTF8String				(1..6 Bytes per cell)
*</ul>
* This is needed for comparing Directory string types according
* to X.500 / X.520 comparison rules.
*
* Note: No consistency check is done on lengths or buffer pointers
*      
*
*  @param Str1Data Source1 base
*  @param Str1Offset Source1 offset
*  @param Str1Len Source1 Size in bytes
*  @param Str1Type Source1 ASN.1 type
*  @param Str2Data Source2 base
*  @param Str2Offset Source2 offset
*  @param Str2Len Source2 Size in bytes
*  @param Str2Type Source2 ASN.1 type
*  @param Result Comparison result: <br>
*               <> 0 strings are different <br>
*               == 0 strings match
*
*  @return int Status ASN1_OP_OK
* <br>            ASN1_INTERNAL_ERROR
*/
static  int CheckSameASN1DirNameStrings(char* Str1Data,
			int Str1Offset, int Str1Len, char Str1Type,
			char* Str2Data, int Str2Offset, int Str2Len,
			char Str2Type, int* Result)
{
  int   i,j;

  int	Str1CellSize;
  int	Str2CellSize;
  int	Str1CaseMode = 0;			// case sensitive
  int	Str2CaseMode = 0;			// dto.

  int Str1Index[1];
  int Str2Index[1];
  int Str1DataLen[1];
  int Str2DataLen[1];

  int Str1Char[1];
  int Str2Char[1];

  //--------------------------------------------------------------
  // 1. Check if one or both strings have zero length
  //--------------------------------------------------------------
  Result[0] = ASN1_NOT_SAME_STRINGS;		// preload different strings
  if((Str1Len == 0) || (Str2Len == 0))
  {
    if(Str1Len == Str2Len)			// assume same !
      Result[0] = ASN1_SAME_STRINGS;
    return(ASN1_OP_OK);				// operation succeeded
  }
  //--------------------------------------------------------------
  // 2. Get the cellsize for each string, check if type is supported.
  //--------------------------------------------------------------
  Str1CellSize = GetASN1StringCharCellSize(Str1Type); // get cell size
  Str2CellSize = GetASN1StringCharCellSize(Str2Type); // dto.
  if((Str1CellSize < 0) || (Str2CellSize < 0))		// not supported
    return(ASN1_DIR_NAME_CMP_CELL_SIZE_ERR);		// should not occur !
  if(Str1Type == ASN1_UNIVERSAL_PRINTABLESTR)		// case insensitive
     Str1CaseMode=1;
  if(Str2Type == ASN1_UNIVERSAL_PRINTABLESTR)		// case insensitive
     Str2CaseMode=1;
  //--------------------------------------------------------------
  // 3. Load Offset and length fields
  //--------------------------------------------------------------
  Str1Index[0] = Str1Offset;
  Str2Index[0] = Str2Offset;
  Str1DataLen[0] = Str1Len;
  Str2DataLen[0] = Str2Len;
  //--------------------------------------------------------------
  // 4. Skip leading whitespaces until start is found
  //--------------------------------------------------------------
  i = SkipASN1StringWhiteSpace(Str1Data,Str1Index,Str1DataLen,
			       Str1CellSize);
  j = SkipASN1StringWhiteSpace(Str2Data,Str2Index,Str2DataLen,
			       Str2CellSize);
  if((i <= 0) || (j <= 0))			// one/both end or error
  {
    //------------------------------------------------------------
    // One or both strings empty/decoding error
    //------------------------------------------------------------
    if((i < 0) || (j < 0))			// too few data/encoding error
      return(ASN1_OP_OK);			// n o t  same strings
    if((i == 0) || (j == 0))
    {
      Result[0] = ASN1_SAME_STRINGS;		// same strings (or error ?)
      return(ASN1_DIR_NAME_CMP_EMPTY_STRINGS);	// signal warning !!
    }
    return(ASN1_OP_OK);				// not same strings
  }
  //--------------------------------------------------------------
  // 5. Compare strings, case insensitive if required, character by
  //    character until not same
  //--------------------------------------------------------------
  for(;;)
  {
    //------------------------------------------------------------
    // 5a. fetch a character from each string, check if end/Error
    //------------------------------------------------------------
    i = GetUCS4Char(Str1Data,Str1Index[0],Str1DataLen[0], // get char
		    Str1CellSize, Str1Char);
    j = GetUCS4Char(Str2Data,Str2Index[0],Str2DataLen[0], // get char
		    Str2CellSize, Str2Char);
    if((i <= 0) || (j <= 0))			// one/both end or error
    {
      if((i < 0) || (j < 0))			// too few data/encoding error
        return(ASN1_OP_OK);			// n o t  same strings
      if((i == 0) && (j == 0))
        Result[0] = ASN1_SAME_STRINGS;		// same strings
      return(ASN1_OP_OK);			// not same strings
    }
    //------------------------------------------------------------
    // 5b. Convert Characters to upper if required
    //------------------------------------------------------------
    if(Str1CaseMode != 0)  Str1Char[0] = ToUpperAsn1Char(Str1Char[0]);
    if(Str2CaseMode != 0)  Str2Char[0] = ToUpperAsn1Char(Str2Char[0]);
    //------------------------------------------------------------
    // 5c. Compare characters for equality
    //------------------------------------------------------------
    if(Str1Char[0] != Str2Char[0])		// different
      return(ASN1_OP_OK);			// not same strings
    //------------------------------------------------------------
    // 5d. Adjust Indices/Lengths for next character
    //------------------------------------------------------------
    Str1Index[0] += i;				// skip processd char
    Str2Index[0] += j;				// dto.
    Str1DataLen[0] -= i;			// reduce remaining size
    Str2DataLen[0] -= j;			// dto.
    //------------------------------------------------------------
    // 5e. Check if a whitespace has been compared, if so skip whitespaces
    //------------------------------------------------------------
    if(CheckWhitespace(Str1Char[0]) != 0)	// we had a white space
    {
      //--------------------------------------------------------------
      // 5e1. Skip intermediate/trailing whitespaces in both strings
      //--------------------------------------------------------------
      i = SkipASN1StringWhiteSpace(Str1Data,Str1Index,Str1DataLen,
				   Str1CellSize);
      j = SkipASN1StringWhiteSpace(Str2Data,Str2Index,Str2DataLen,
				   Str2CellSize);
      if((i <= 0) || (j <= 0))			// one/both end or error
      {
        //------------------------------------------------------------
        // one or bothe strings ended/decoding error
        //------------------------------------------------------------
        if((i < 0) || (j < 0))			// too few data/encoding error
          return(ASN1_OP_OK);			// n o t  same strings
        if((i == 0) && (j == 0))		// same strings
          Result[0] = ASN1_SAME_STRINGS;
        return(ASN1_OP_OK);			// terminate processing
      }
    }
    //------------------------------------------------------------
    // 5e2. was not a whitespace, check if more data present for compare
    //------------------------------------------------------------
    else
    {
      if((Str1DataLen[0] == 0) || (Str2DataLen[0] == 0)) // end encountered
      {
        if(Str1DataLen[0] == Str2DataLen[0])		// both ended
          Result[0] = ASN1_SAME_STRINGS;		// same strings
        return(ASN1_OP_OK);
      }
    }
  } // for loop
}
/**
* Subroutine GetASN1TypeCompareRule gets comparison (equality
* matching rule internal ID) rule for given ASN.1 Type (GetASN1TypeCompareRule).
*
* Supported comparison rules are:
*  0. Unknown
*  1. Boolean
*  2. Integer
*  3. Bitstring
*  4. OctetString
*  5. NULL
*  6. ObjectID
*  7. UTC time
*  8. GENERALTIME time
*
*----------------------------------------------------------------
*  @param ASN1Type ASN.1 Type
*  @return int Comparison rule internal ID
*/
static  int GetASN1TypeCompareRule(char ASN1Type)
{
  char Asn1Type=ASN1Type;			// local

  //-------------------------------------------------------------
  // check for ASN1 universal primitive encoding
  //-------------------------------------------------------------
  if((Asn1Type & (ASN1_CLASS_MASK | ASN1_CONSTRUCTED_MASK)) != 0)
    return(ASN1_MATCH_RULE_UNKNOWN);
  //-------------------------------------------------------------
  // ASN1 universal primitive encoding, distribute
  //-------------------------------------------------------------
  switch(Asn1Type)
  {
    case ASN1_UNIVERSAL_BOOLEAN:
      return(ASN1_MATCH_RULE_BOOLEAN);

    case ASN1_UNIVERSAL_INTEGER:
      return(ASN1_MATCH_RULE_INTEGER);

    case ASN1_UNIVERSAL_BITSTRING:
      return(ASN1_MATCH_RULE_BITSTRING);

    case ASN1_UNIVERSAL_OCTETSTRING:
      return(ASN1_MATCH_RULE_OCTETSTRING);

    case ASN1_UNIVERSAL_NULL:
      return(ASN1_MATCH_RULE_NULL);

    case ASN1_UNIVERSAL_OBJECT_ID:
      return(ASN1_MATCH_RULE_OBJECTID);

    case ASN1_UNIVERSAL_NUMERICSTR:
      return(ASN1_MATCH_RULE_NUMERICSTRING);

    case ASN1_UNIVERSAL_UTCTIME:
      return(ASN1_MATCH_RULE_UTC);

    case ASN1_UNIVERSAL_GENERAL_TIME:
      return(ASN1_MATCH_RULE_GENERAL_TIME);

    default:
      return(ASN1_MATCH_RULE_UNKNOWN);
  } 
}
/**
* Subroutine MatchASN1NumericStrings compares two ASN.1 numeric
* strings, spaces are skipped (MatchASN1NumericStrings).
* Equality definition:
*      ---------------
* Same number of numeric characters with same contents
*
*
*  @param Base1 Data Base 1
*  @param InpOffset1 Start Data 1
*  @param DataLen1 length Data 1
*  @param Base2 Data Base 2
*  @param InpOffset2 Start Data 2
*  @param DataLen2 length Data 2
*
*  @return int Comparison result
*/
static  int  MatchASN1NumericStrings(char* Base1,
				int InpOffset1,int DataLen1,
				char* Base2, int InpOffset2,int DataLen2)
{
  char* pBase;

  char c1,c2;

  int i,j;
  int Index1  = InpOffset1;
  int Len1    = DataLen1;

  int Index2  = InpOffset2;
  int Len2    = DataLen2;

  int Result = ASN1_NOT_SAME;	// preset result

  //-----------------------------------------------------
  // 1. check if both Base pointers present
  //-----------------------------------------------------
  if((Base1 == NULL) || (Base2 == NULL))	// one or both not present
  {
    if(Base1 == Base2)
      Result = ASN1_SAME;
    return(Result);
  }
  //-----------------------------------------------------
  // 2. Start Comparison
  //-----------------------------------------------------
  for(;;)
  {
    //---------------------------------------------------------
    // String End check
    //---------------------------------------------------------
    if((Len1 == 0) || (Len2 == 0))  		// one /both ended
    {
      if(Len1 == Len2)				// both zero, must be same !
      {
        Result = ASN1_SAME;
	break;
      }
      //-------------------------------------------------------
      // only one ended, scan other for more numeric characters
      //-------------------------------------------------------
      pBase = Base1;
      i = Len1;
      j = Index1;  
      if(Len1 == 0)				// first ended, not second
      {
        pBase = Base2;
        i = Len2;
        j = Index2;  
      }
      do
      {
        if(pBase[j++] != (char) 0x20) break;	// another number
        i--;
      }while(i!=0);
      if(i == 0) Result = ASN1_SAME;		// only trailing spaces
      break;
    }        
    //---------------------------------------------------------
    // Strings both have data, compare
    //---------------------------------------------------------
    c1 = Base1[Index1++];
    c2 = Base2[Index2++];
    Len1--;
    Len2--;
    if(c1 == c2) continue;			// same (may also be spaces
    if((c1 != 0x20) && (c2 != 0x20)) break;	// different value
    if(c1 == 0x20)				// must Skip String 1 spaces
    {
      //-----------------------------------------------------
      // Skip Spaces String 1 until next number or End
      //-----------------------------------------------------
      do
      {
        c1 = Base1[Index1++];
        Len1--;
      }while((Len1 != 0) && (c1 == (char) 0x20));
      if((Len1 == 0) && (c1 == (char) 0x20)) break; // only trailing spaces
      if(c1 != c2) break;			// different
    }
    else					// must Skip String 2 spaces
    {
      //-----------------------------------------------------
      // Skip Spaces String 2 until next number or End
      //-----------------------------------------------------
      do
      {
        c2 = Base2[Index2++];
        Len2--;
      }while((Len2 != 0) && (c2 == (char) 0x20));
      if((Len2 == 0) && (c2 == (char) 0x20)) break; // only trailing spaces
      if(c1 != c2) break;			// different
    }
  } // compare FOR loop
  return(Result);
}

extern "C"  int  MatchASN1ValuesByteByByte(char* Base1,
				int InpOffset1,int DataLen1,
				char* Base2, int InpOffset2,int DataLen2)
{
  int i;
  int Index1 = InpOffset1;
  int Index2 = InpOffset2;

  int Result = ASN1_NOT_SAME;	// preset result

  //-----------------------------------------------------
  // 1. check if both Base pointers present
  //-----------------------------------------------------
  if((Base1 == NULL) || (Base2 == NULL))	// one or both not present
  {
    if(Base1 == Base2)
      Result = ASN1_SAME;
    return(Result);
  }
  //-----------------------------------------------------
  // 2a. check if both length are same
  //-----------------------------------------------------
  if(DataLen1 != DataLen2)			// shure not same !!!
    return(Result);
  //-----------------------------------------------------
  // 2b. check if one/both length are 0
  //-----------------------------------------------------
//  if((DataLen1 == 0) || (DataLen2 == 0))	// one or both zero length
  if(DataLen1 == 0)				// one or both zero length
    return(ASN1_SAME);
  //-----------------------------------------------------
  // 3. Compare both for equivalence
  //-----------------------------------------------------
  i = DataLen1;					// set count
  do 
  {
    if(Base1[Index1++] != Base2[Index2++])	// not same
      return(Result);    
    i--;
  }while(i != 0);
  return(ASN1_SAME);
}

extern "C"  int CmpASN1_Values(IDATA* Value1,
				      IDATA* Value2,
				      int* Result)
{
  char ASN1_Type1;
  char ASN1_Type2;

  int i;
  int RetCode;

  int Index1;
  int Index2;

  int Len1;
  int Len2;
  int DataLen1;
  int Time1TypeFlag;
  int Str1TypeFlag;

  int Off1;
  int Off2;
  int DataLen2;
  int Time2TypeFlag;
  int Str2TypeFlag;

  char* Base1;
  char* Base2;

  IDATA TmpIdataId1;
  IDATA TmpIdataId2;

  int CmpResult[1];
  int TmpDataLen[1];

  Result[0] = ASN1_NOT_SAME;		// preload
  //--------------------------------------------------
  // 1. Check presence of both first
  //--------------------------------------------------
  if((Value1 == NULL) || (Value2 == NULL))	// one or both not present
  {
    if(Value1 == Value2)			// both not present
      Result[0] = ASN1_SAME;
    return(ASN1_OP_OK);
  }
  //--------------------------------------------------
  // 2. Load Base Pointers, compare
  //--------------------------------------------------
  Base1 = Value1->Base;
  Base2 = Value2->Base;
  if((Base1 == NULL) || (Base2 == NULL))	// one or both no data
  {
    if(Base1 == Base2)				// both not present
      Result[0] = ASN1_SAME;
    return(ASN1_OP_OK);
  }
  //--------------------------------------------------
  // 3. Load Length, compare for presence
  //--------------------------------------------------
  Len1 = Value1->Len;
  Len2 = Value2->Len;
  if((Len1 == 0) || (Len2 == 0))		// one or both no data
  {
    if(Len1 == Len2)				// both no data
      Result[0] = ASN1_SAME;
    return(ASN1_OP_OK);
  }
  //--------------------------------------------------
  // 4. Load Offsets, get ASN.1 Types, check if valid
  //--------------------------------------------------
  Off1 = (int) Value1->Off;
  Off2 = (int) Value2->Off;
  Index1 = Off1;
  Index2 = Off2;
  ASN1_Type1 = Base1[Index1++];
  ASN1_Type2 = Base2[Index2++];
  if(((ASN1_Type1 & ASN1_UNIVERSAL_TYPE_MASK) == // continuation not supp.
        ASN1_UNIVERSAL_CONTINUATION) ||
     ((ASN1_Type2 & ASN1_UNIVERSAL_TYPE_MASK) == // continuation not supp.
        ASN1_UNIVERSAL_CONTINUATION))
    return(ASN1_VAL_CMP_INVALID_ASN1_TYPE);
  Len1--;
  Len2--;
  //--------------------------------------------------
  // 5. Get ASN1 Datalength for both, check plausibility
  //--------------------------------------------------
  i = DecodeASN1_LenField(Base1, Index1, Len1, TmpDataLen);
  if(i < 0)					// error occurred
  {
    if(i == -2) return(ASN1_VAL_CMP_DATA_MISSING);
    else return(ASN1_VAL_CMP_FLDLEN_ERR);
  }
  Len1 -= i;					// reduce Datacount
  Index1 += i;					// to start of data
  DataLen1 = (int) TmpDataLen[0] & 0xFF;

  i = DecodeASN1_LenField(Base2, Index2, Len2, TmpDataLen);
  if(i < 0)					// error occurred
  {
    if(i == -2) return(ASN1_VAL_CMP_DATA_MISSING);
    else return(ASN1_VAL_CMP_FLDLEN_ERR);
  }
  Len2 -= i;					// reduce Datacount
  Index2 += i;					// to start of data
  DataLen2 = (int) TmpDataLen[0] & 0xFF;

  if((DataLen1 != Len1) || (DataLen2 != Len2))	// length error !!
    return(ASN1_VAL_CMP_INCONSIST_DATLEN);
  //--------------------------------------------------
  // 6. Check if one /both of length zero
  //--------------------------------------------------
  if((DataLen1 == 0) || (DataLen2 == 0))	// one or both zero length
  {
    if(DataLen1 == DataLen2)			// both Zero length
      Result[0] = ASN1_SAME;
    return(ASN1_OP_OK);
  }
  //--------------------------------------------------
  // 7. Both have datalength <> 0, check if both are
  //    known ASN.1 StringTypes
  //--------------------------------------------------
  Str1TypeFlag = CheckValidASN1DirStringType(ASN1_Type1);
  Str2TypeFlag = CheckValidASN1DirStringType(ASN1_Type2);
  if((Str1TypeFlag >=0) && (Str2TypeFlag >= 0))	// both of String Type...
  {
    //------------------------------------------------
    // both known ASN.1 string types, try match
    //------------------------------------------------
    i = CheckSameASN1DirNameStrings(Base1,Index1,DataLen1,ASN1_Type1,
				    Base2,Index2,DataLen2,ASN1_Type2,
				    CmpResult);
    if(i != ASN1_OP_OK) return(i);
    if(CmpResult[0] == ASN1_SAME_STRINGS)	// strings match
      Result[0] = ASN1_SAME;
    return(ASN1_OP_OK);
  }
  //-------------------------------------------------------------
  // 8. Not both ASN1 known String Type, check if same ASN1 types
  //-------------------------------------------------------------
  if(ASN1_Type1 != ASN1_Type2)			// not same
  {
    Time1TypeFlag=CheckValidASN1TimeType(ASN1_Type1);
    Time2TypeFlag=CheckValidASN1TimeType(ASN1_Type2);
    if((Time1TypeFlag != ASN1_TIME_TYPE_INVALID) &&	//1st is time
       (Time2TypeFlag != ASN1_TIME_TYPE_INVALID))	//2nd is time
    {
      RetCode = MatchASN1_TimeTypes(Base1,Index1,DataLen1,Time1TypeFlag,
				    Base2,Index2,DataLen2,Time2TypeFlag,
				    CmpResult);
      if(RetCode != ASN1_OP_OK) return(RetCode);	// stop processing
      if(CmpResult[0] == ASN1_1ST_EQ_2ND)
        Result[0] = ASN1_SAME;
    }
    return(ASN1_OP_OK);				// processed
  }
  //-------------------------------------------------------------
  // 9. Both of same type (but not of known string type),
  //    get comparison rule and distribute...
  //-------------------------------------------------------------
  i = GetASN1TypeCompareRule(ASN1_Type1);
  switch(i)
  {
    //-----------------------------------------------------------
    // Boolean Match rule
    //-----------------------------------------------------------
    case ASN1_MATCH_RULE_BOOLEAN:
      if(DataLen1 != DataLen2) break;			// not same, different
      if(DataLen1 != 1) break;				// invalid ...
      if(Base1[Index1] != Base2[Index2]) break;		// not same (DER !!)
      Result[0] = ASN1_SAME;				// are same
      break;
    //-----------------------------------------------------------
    // Integer Match rule
    //-----------------------------------------------------------
    case ASN1_MATCH_RULE_INTEGER:
      if((DataLen1 > 1) && (Base1[Index1] == 0))	// skip leading zero
      {
        DataLen1 --;
        Index1++;
      }
      if((DataLen2 > 1) && (Base2[Index2] == 0))	// skip leading zero
      {
        DataLen2 --;
        Index2++;
      }
      Result[0] = MatchASN1ValuesByteByByte(Base1,Index1,DataLen1,
					  Base2,Index2,DataLen2);
      break;

    //-----------------------------------------------------------
    // Bitstring, Octetstring match rule
    //-----------------------------------------------------------
    case ASN1_MATCH_RULE_BITSTRING:
    case ASN1_MATCH_RULE_OCTETSTRING:
      Result[0] = MatchASN1ValuesByteByByte(Base1,Index1,DataLen1,
				          Base2,Index2,DataLen2);
      break;
    //-----------------------------------------------------------
    // NULL match rule: no data may be present for both
    //-----------------------------------------------------------
    case ASN1_MATCH_RULE_NULL:
      if((DataLen1 != 0) || (DataLen2 != 0)) break;	// not same
      Result[0] = ASN1_SAME;
      break;
    //-----------------------------------------------------------
    // Object ID match rule, special case: Construct IDATA entries
    //-----------------------------------------------------------
    case ASN1_MATCH_RULE_OBJECTID:
      TmpIdataId1.Base = Base1;
      TmpIdataId1.Off  = Index1;
      TmpIdataId1.Len  = DataLen1;
      TmpIdataId2.Base = Base2;
      TmpIdataId2.Off  = Index2;
      TmpIdataId2.Len  = DataLen2;

      RetCode = CmpASN1_ObjIDs(&TmpIdataId1,
			       &TmpIdataId2,
			       CmpResult);

      if(RetCode != ASN1_OP_OK) return(RetCode);	// stop processing
      if(CmpResult[0] == ASN1_1ST_EQ_2ND)
        Result[0] = ASN1_SAME;
      break;
    //-----------------------------------------------------------
    // Numeric String match rule, special case, spaces ignored
    //-----------------------------------------------------------
    case ASN1_MATCH_RULE_NUMERICSTRING:
      Result[0] = MatchASN1NumericStrings(Base1,Index1,DataLen1,
					  Base2,Index2,DataLen2);
      break;
    //-----------------------------------------------------------
    // UTC-Time match rule, special case
    //-----------------------------------------------------------
    case ASN1_MATCH_RULE_UTC:
      RetCode = MatchASN1_TimeTypes(Base1,Index1,DataLen1,
			ASN1_TIME_TYPE_UTC,
			Base2,Index2,DataLen2,ASN1_TIME_TYPE_UTC,
			CmpResult);
      if(RetCode != ASN1_OP_OK) return(RetCode);	// stop processing
      if(CmpResult[0] == ASN1_1ST_EQ_2ND)
        Result[0] = ASN1_SAME;
      break;
    //-----------------------------------------------------------
    // General-Time match rule, special case
    //-----------------------------------------------------------
    case ASN1_MATCH_RULE_GENERAL_TIME:
      RetCode = MatchASN1_TimeTypes(Base1,Index1,DataLen1,
			ASN1_TIME_TYPE_GENTIME,
			Base2,Index2,DataLen2,ASN1_TIME_TYPE_GENTIME,
			CmpResult);
      if(RetCode != ASN1_OP_OK) return(RetCode);	// stop processing
      if(CmpResult[0] == ASN1_1ST_EQ_2ND)
        Result[0] = ASN1_SAME;
      break;
    //-----------------------------------------------------------
    // non specific matching, byte by byte compare ...
    //-----------------------------------------------------------
    case ASN1_MATCH_RULE_UNKNOWN:
    default:
      Result[0] = MatchASN1ValuesByteByByte(Base1,Index1,DataLen1,
				          Base2,Index2,DataLen2);
      break;
  } // comparison rule switch
 return(ASN1_OP_OK);
}

extern "C"  int MatchAVA_SubStrings(IDATA** AVA_Array1,
		int IndexBase1, int IndexCnt1,
		IDATA** AVA_Array2, int IndexBase2, int IndexCnt2,
		int* Result)
{
  int i;
  int RetCode;

  int CmpCount;
  int Index1Start = IndexBase1;
  int Index2Start = IndexBase2;

  int Index1;
  int Index2;

  int CmpResult[1];

  Result[0] = ASN1_NOT_SAME;		// preload
  //--------------------------------------------------
  // 1. Check Presence of base
  //--------------------------------------------------
  if((AVA_Array1 == NULL) || (AVA_Array2 == NULL))	// one or both null
  {
    if((AVA_Array1 == NULL) && (AVA_Array2 == NULL))	// both not present
      Result[0] = ASN1_SAME;
    return(ASN1_OP_OK);
  }   
  //--------------------------------------------------
  // 2. Check same number of pairs and not odd count
  //--------------------------------------------------
  if((IndexCnt1 != IndexCnt2) ||			// different elements
     ((IndexCnt1 & 0x01) != 0))				// same but odd
    return(ASN1_OP_OK);					// different
  //--------------------------------------------------
  // 2. Check same AVA types
  //--------------------------------------------------
  CmpCount = IndexCnt1 / 2;			// number of Pairs
  Index1 = Index1Start;
  Index2 = Index2Start;
  i = CmpCount;
  do
  {
    RetCode = CmpASN1_ObjIDs(AVA_Array1[Index1],
			     AVA_Array2[Index2],
			     CmpResult);
    if(RetCode != ASN1_OP_OK) return(RetCode);
    if(CmpResult[0] != ASN1_1ST_EQ_2ND)
      return(ASN1_OP_OK);			// different
    Index1 += 2;				// to next
    Index2 += 2;				// dto.
    i--;
  }while(i != 0);
  //--------------------------------------------------
  // 3. Check same AVA Values
  //--------------------------------------------------
  Index1 = Index1Start+1;
  Index2 = Index2Start+1;
  i = CmpCount;
  do
  {
    RetCode = CmpASN1_Values(AVA_Array1[Index1],
			     AVA_Array2[Index2],
			     CmpResult);
    if(RetCode != ASN1_OP_OK) return(RetCode);
    if(CmpResult[0] != ASN1_1ST_EQ_2ND)
      return(ASN1_OP_OK);			// different
    Index1 += 2;				// to next
    Index2 += 2;				// dto.
    i--;
  }while(i != 0);
  Result[0] = ASN1_SAME;
  return(ASN1_OP_OK);
}

extern "C"  int MatchX501_DNs(X501_DN* pName1Desc,
				     X501_DN* pName2Desc, int* pResult)
{
  int Retcode, Index, RDNsCount;

  IDATPARR** pRdn1DescArr;
  IDATPARR** pRdn2DescArr;

  IDATPARR* pActRdn1Desc;
  IDATPARR* pActRdn2Desc;

  int pTmpResult[1];
  //---------------------------------------------------------------
  // Check Parameters first...
  //---------------------------------------------------------------
  if((pName1Desc == NULL) || (pName2Desc == NULL) || (pResult == NULL))
    return(ASN1_NULL_PTR);
  
  pResult[0] = ASN1_NOT_SAME;		// preload
  //---------------------------------------------------------------
  // Check if both have same number of RDN elements and count is
  // at least 1 RDN
  //---------------------------------------------------------------
  RDNsCount = pName1Desc->Cnt;
  if((RDNsCount != pName2Desc->Cnt) || (RDNsCount <= 0))
    return(ASN1_OP_OK);
  //---------------------------------------------------------------
  // Both have same number of RDNs, compare each RDN element
  //---------------------------------------------------------------
  Index = 0;
  pRdn1DescArr = pName1Desc->ppArr;
  pRdn2DescArr = pName2Desc->ppArr;

  while(Index < RDNsCount)
  {
    pActRdn1Desc = pRdn1DescArr[Index];		// RDN Elements 1st name
    pActRdn2Desc = pRdn2DescArr[Index];		// RDN Elements 2nd name
    Retcode = MatchAVA_SubStrings(pActRdn1Desc->ppArr, 0,
				  pActRdn1Desc->Cnt,
				  pActRdn2Desc->ppArr, 0,
				  pActRdn2Desc->Cnt,
				  pTmpResult);
    if(Retcode != ASN1_OP_OK)
      return(Retcode);
    if(pTmpResult[0] != ASN1_SAME)
      return(ASN1_OP_OK);

    Index++;
  }
  pResult[0] = ASN1_SAME;
  return(ASN1_OP_OK);
}

extern "C"  int FromASN1_DNCommonNameToString(HMEM_CTX_DEF
		X501_DN* pNameDesc, char** pDstNameBuf)
{
  int Retcode = ASN1_OP_OK;
  int SrcIndex = 0;
  int ElementCnt;
  int RdnCount;
  int RdnIndex;

  int CommonNameOIDIndex;
  int CommonNameOIDLen;
  int ObjID_Len;
  int Result;

  IDATA** pDatArray;

  IDATA* pObjIdata;
  IDATA* pContIdata;
  IDATPARR*  pActRdnDesc;
  IDATPARR** pRdnDescArr;

  //----------------------------------------------------------------
  // check parameters, clear Destination pointer
  //----------------------------------------------------------------
  if((pNameDesc == NULL) || (pDstNameBuf == NULL))
    return(ASN1_RDN_TO_CNAMESTR_NULPTR_ERR);
  pDstNameBuf[0] = NULL;			// invalidate pointer
  //----------------------------------------------------------------
  // Get Number of RDN-Entries to process
  //----------------------------------------------------------------
  RdnCount = pNameDesc->Cnt;		// number of RDNs
  if(RdnCount <= 0)				// none...
    return(ASN1_OP_OK);				// no Elements..., exit

  pRdnDescArr = pNameDesc->ppArr;	// Elements Array
  //----------------------------------------------------------------
  // Get Common Name Table OID Compare Start
  //----------------------------------------------------------------
  CommonNameOIDIndex = X520_ATT_OffsetTab[OID_X520_COMMON_NAME];
  CommonNameOIDLen   = (int) OID_Table[CommonNameOIDIndex+2] & 0xFF;
  CommonNameOIDIndex += 3;		// to start of Data to compare
  //----------------------------------------------------------------
  // Process the Entries, search for CommonName OID
  //----------------------------------------------------------------
  RdnIndex = 0;
  Result = ASN1_NOT_SAME;
  while(RdnIndex < RdnCount)
  {
    SrcIndex = 0;
    pActRdnDesc = pRdnDescArr[RdnIndex];	// actual RDN Descriptor
    pDatArray   = pActRdnDesc->ppArr;
    ElementCnt  = pActRdnDesc->Cnt;
    if((ElementCnt & 0x01) != 0)			// must be even
      return(ASN1_RDN_TO_CNAMESTR_INV_CNT);
    ElementCnt >>= 1;
    while(ElementCnt != 0)
    {
      pObjIdata  = pDatArray[SrcIndex++];	// Get OID Element
      if(pObjIdata == NULL)			 // invalid
        return(ASN1_RDN_TO_CNAMESTR_SRC_ERR);

      ObjID_Len = pObjIdata->Len;		// get length
      if(ObjID_Len == CommonNameOIDLen)		// same, further check
      {
        Result = MatchASN1ValuesByteByByte(pObjIdata->Base,
				        (int) pObjIdata->Off,
				        ObjID_Len,
				        (char *) OID_Table,
					CommonNameOIDIndex,
					CommonNameOIDLen);
        if(Result == ASN1_SAME)		// found Common Name OID
        {
          //------------------------------------------------------
          // Found Common Name Entry, convert to internal string
          //------------------------------------------------------
          pContIdata = pDatArray[SrcIndex];		// Get Contents
          if((pContIdata == NULL) || (pContIdata->Base == NULL))
            return(ASN1_OP_OK);
          Retcode = FromASN1_String(HMEM_CTX_REF1
				    pContIdata->Base,
			            (int) pContIdata->Off,
			            pContIdata->Len,
			            pDstNameBuf);
          return(Retcode);
        }
      }
      SrcIndex++;				// skip contents
      ElementCnt--;
    }
    RdnIndex++;
  }
  return(ASN1_OP_OK);
}

extern "C"  int CheckKnownCertSubjCommonName(HMEM_CTX_DEF
		X509CERT * CertStruc,
		char* pListBuf, int* pResult)
{
  int Retcode;
  int SrcIndex;
  int DstIndex=0;
  int TmpIndex;

  int SubjListNamesCount;
  int SubjListNameLen;
  int CommonNameLen; 
  int Count;

  char* CommonNameBuf = NULL;
  char* pTmpCommonNameBuf[1];

//  IDATPARR_PTR pSubjRDNDesc;
  X501_DN* pSubjNameDesc;
  //------------------------------------------
  // Check Parameterts 
  //------------------------------------------
  if((CertStruc == NULL) || (pListBuf == NULL) || (pResult == NULL))
    return(ASN1_CHK_SUBJ_COMNAME_NULPTR);

  pResult[0] = ASN1_NOT_SAME;				// preset result

  BIGchar2word(pListBuf,SubjListNamesCount,DstIndex);	// get name elem. count
  if(SubjListNamesCount <= 0)
    return(ASN1_CHK_SUBJ_COMNAME_INV_LIST);
  //-------------------------------------------------------
  // Get the Subjects common name in internal string format
  //-------------------------------------------------------
  pSubjNameDesc = CertStruc->Subject;	// get Descriptor

  pTmpCommonNameBuf[0] = NULL;			// preset empty buffer
  Retcode = FromASN1_DNCommonNameToString(HMEM_CTX_REF1
				pSubjNameDesc,pTmpCommonNameBuf);
  if(Retcode != ASN1_OP_OK)
    return(Retcode);
  CommonNameBuf = pTmpCommonNameBuf[0];		// get buffer base
  if(CommonNameBuf == NULL)
    return(Retcode);				// not found
  BIGchar2wordn(CommonNameBuf,CommonNameLen,0);	// get elements
  CommonNameLen *= 2;				// to bytes
  //-------------------------------------------------------
  // Compare the Common Name with the List Entries
  //-------------------------------------------------------
  do
  {
    BIGchar2word(pListBuf,SubjListNameLen,DstIndex);	// get entry elements
    SubjListNameLen *= 2;			// to bytes
    if(SubjListNameLen == CommonNameLen)	// might be same
    {
      SrcIndex = 2;				// set compare start
      TmpIndex = DstIndex;			// dto.
      Count = CommonNameLen;
      do
      {
        if(pListBuf[TmpIndex++] != CommonNameBuf[SrcIndex++])
          break;
        Count--;
      }while(Count != 0);
      if(Count == 0)
      {
        FREE_ARRAY(HMEM_CTX_REF,CommonNameBuf);
        pResult[0] = ASN1_SAME;
        return(ASN1_OP_OK);
      }
    }
    DstIndex += SubjListNameLen;		// to next entry
    SubjListNamesCount--;
  }while(SubjListNamesCount != 0);
  FREE_ARRAY(HMEM_CTX_REF,CommonNameBuf);
  return(ASN1_OP_OK);				// not found
}
/**
* Subroutine GetCertTimeValidity converts Certificates NOT_BEFORE
* and NOT_AFTER ASN1 Strings to Internal Representation (GetCertTimeValidity).
*
* 1. Convert NOT_BEFORE String to a Time Array
* 2. Convert NOT_AFTER String to a Time Array
*
*----------------------------------------------------------------
*  @param NotBefore Pointer to data Structure
*  @param NotAfter dto.
*  @param NotBeforeTimeArray Destination Array
*  @param NotAfterTimeArray dto.
*               NOTE: The destination arrays must have been allocated !!!
*               -----
*
*  @return ASN1_OP_OK on success, error code otherwise
* <br>            else Error occurred
*/
static  int GetCertTimeValidity(IDATA* NotBefore,
				IDATA* NotAfter,
				int* NotBeforeTimeArray,
				int* NotAfterTimeArray)
{
  char* BaseNotBefore;
  char* BaseNotAfter;

  int DataOffNotBefore;
  int DataLenNotBefore;
  int TimeTypeNotBefore;

  int DataOffNotAfter;
  int DataLenNotAfter;
  int TimeTypeNotAfter;

  int RetCode = ASN1_OP_OK;

  char TmpASN1Type[1];
  int TmpHdrLen[1];
  int TmpDataLen[1];

  for(;;)					// Error FOR loop
  {
    //--------------------------------------------------
    // 1. Check/Load ASN.1 Params for NotBefore Field
    //--------------------------------------------------
    RetCode = GetASN1TypeLenValFromIDAT(NotBefore,TmpASN1Type,
					TmpHdrLen,TmpDataLen);
    if(RetCode != ASN1_OP_OK) break;
    BaseNotBefore = NotBefore->Base;
    DataOffNotBefore  = (int) NotBefore->Off+TmpHdrLen[0];// Start of Data
    DataLenNotBefore  = TmpDataLen[0];
    TimeTypeNotBefore = CheckValidASN1TimeType(TmpASN1Type[0]);
    //--------------------------------------------------
    // 2. Check/Load ASN.1 Params for NotAfter Field
    //--------------------------------------------------
    RetCode = GetASN1TypeLenValFromIDAT(NotAfter,TmpASN1Type,
					TmpHdrLen,TmpDataLen);
    if(RetCode != ASN1_OP_OK) break;
    BaseNotAfter = NotAfter->Base;
    DataOffNotAfter  = (int) NotAfter->Off+TmpHdrLen[0];// Start of Data
    DataLenNotAfter  = TmpDataLen[0];
    TimeTypeNotAfter = CheckValidASN1TimeType(TmpASN1Type[0]);
    //--------------------------------------------------
    // 3. Check if both are valid time types
    //--------------------------------------------------
    if((TimeTypeNotBefore == ASN1_TIME_TYPE_INVALID) ||
       (TimeTypeNotAfter  == ASN1_TIME_TYPE_INVALID))
    {
      RetCode = ASN1_CERT_GET_TIME_INV_TIMETYPE;
      break;
    }
    //--------------------------------------------------
    // 4. Convert to time arrays
    //--------------------------------------------------
    RetCode = ConvChkASN1_TimeStr(BaseNotBefore, DataOffNotBefore,
		DataLenNotBefore,NotBeforeTimeArray,
		TimeTypeNotBefore);
    if(RetCode != ASN1_OP_OK) break;

    RetCode = ConvChkASN1_TimeStr(BaseNotAfter, DataOffNotAfter,
		DataLenNotAfter,NotAfterTimeArray,
		TimeTypeNotAfter);
    break;
  }
  return(RetCode);				// processed
}

/**
* Subroutine ChkActCertTimeValidity checks validity of given
* Certificates NOT_BEFORE and NOT_AFTER Time Arrays in Internal
* Representation against current time (ChkActCertTimeValidity).
*
* Certificate Time Validation is done in the following way:
* 1. Get Current date and time, store to Time Array
* 2. Check that NOT_BEFORE Time/Date is <= Current Time/Date
* 3. Check that NOT_AFTER  Time/Date is >= Current Time/Date
*
*----------------------------------------------------------------
*  @param Cert Pointer to Certificate
*  @param Result Result of Compare
*
*  @return ASN1_OP_OK on success, error code otherwise
* <br>            else Error occurred
*/
static  int ChkActCertTimeValidity(X509CERT * Cert, int* Result)
{
  int i;
  int Retcode = ASN1_OP_OK;

  int CurrentTimeArray[TIME_ARRAY_SIZE];

  Result[0] = ASN1_CERT_TIME_STATE_UNKNOWN;	// preload
  //--------------------------------------------------
  // 1. Get Local Time Timearray
  //--------------------------------------------------
  Retcode = GetCheckLocalTimeArray(0,0,CurrentTimeArray);
  if(Retcode != ASN1_OP_OK)
    return(Retcode);
  //--------------------------------------------------
  // 2. Compare Time Array contents
  //--------------------------------------------------
  i = CompareTimeArrays(Cert->pNotBeforeTimeArray,CurrentTimeArray);
  if(i == ASN1_1ST_GT_2ND)			// is not yet valid
  {
    Result[0] = ASN1_CERT_TIME_NOT_YET_VALID;
    return(Retcode);
  }
  i = CompareTimeArrays(Cert->pNotAfterTimeArray, CurrentTimeArray);
  if(i == ASN1_1ST_LT_2ND)			// is no longer valid
    Result[0] = ASN1_CERT_TIME_NO_LONGER_VALID;
  else    
    Result[0] = ASN1_CERT_TIME_VALID;		// is valid !
  return(Retcode);				// processed
}
/**
* Subroutine GetAlgorIndex checks if an ASN1 ObjectID (without
* header) is a known Algorithm ID with the specified purpose (GetAlgorIndex).
* If found and the Purposes Match, the OID's Index is returned. 
*
*----------------------------------------------------------------
*  @param ObjID_Desc ObjID-Descriptor
*  @param PurposeMask Bitmask to check
*  @param AlgorID_Index Index of OID
*
*  @return ASN1_OP_OK on success, error code otherwise
* <br>            else Error occurred
*/
static  int GetAlgorIndex(IDATA* ObjID_Desc,
			int PurposeMask, int* AlgorID_Index)
{
  int i;
  int ObjID_Offset;
  int ObjID_Len;
  
  int AlgorCnt = GRP_ALGOR_ID_CNT;
  int ActAlgorIndex = 0;

  int ActOID_Index;
  int ActOID_Len;

  char* ObjID_Base;
  //--------------------------------------------------
  // get start and length of Object ID
  //--------------------------------------------------
  if(ObjID_Desc == NULL) return(ASN1_GET_ALG_PARAM_ERR);
  
  ObjID_Base   = ObjID_Desc->Base;
  ObjID_Offset = (int) ObjID_Desc->Off;
  ObjID_Len    = ObjID_Desc->Len;

  if((ObjID_Base == NULL) || (ObjID_Len <= 0))
    return(ASN1_GET_ALG_NO_OID);
  //--------------------------------------------------
  // search the AlgorID Table for OID match
  //--------------------------------------------------
  do
  {
    ActOID_Index = ALGOR_ID_OffsetTab[ActAlgorIndex];
    ActOID_Len = (int) OID_Table[ActOID_Index+2] & 0xFF;
    i = MatchASN1ValuesByteByByte(ObjID_Base, ObjID_Offset, ObjID_Len,
			  (char *) OID_Table, ActOID_Index+3,ActOID_Len);
    if(i == ASN1_SAME) break;				// same found
    ActAlgorIndex++;
    AlgorCnt --;
  }while(AlgorCnt != 0);
  if(AlgorCnt == 0) return(ASN1_GET_ALG_UNKNOWN_OID);
  //--------------------------------------------------
  // ID Found, check the Purposes Mask (if Given)
  //--------------------------------------------------
  if(PurposeMask != 0)
  {
    i = (int) OID_Table[ActOID_Index+1] & 0xFF;	// get purpose Flags
    i &= PurposeMask;				// isolate Purposes
    if(i != PurposeMask)
      return(ASN1_GET_ALG_PURP_NOT_SUPPORTED);
  }
  AlgorID_Index[0] = ALGOR_ID_IndexTab[ActAlgorIndex];
  return(ASN1_OP_OK);
}
/**
* Subroutine ChkKnownPublicKeyInfoAlgor checks if an ASN1 ObjectID
* (without header) is a known Algorithm ID for the Subject Public
* key info field. If so returns internal OID Index (ChkKnownPublicKeyInfoAlgor).
*
*  @param ObjID_Desc ObjID-Descriptor
*  @param AlgorID_Index Index of OID
*
*  @return ASN1_OP_OK on success, error code otherwise
* <br>            else Error occurred
*/
static  int ChkKnownPublicKeyInfoAlgor(IDATA* ObjID_Desc,
						   int* AlgorID_Index)
{
  return(GetAlgorIndex(ObjID_Desc,PURP_PUBLIC_VALUE_ALGOR,AlgorID_Index));
}

/**
* Subroutine ChkKnownSignatType checks if an ASN1 ObjectID
* (without header) is a known Signature Type description. If so
* returns internal OID Index (ChkKnownSignatType).
*
*  @param ObjID_Desc ObjID-Descriptor
*  @param AlgorID_Index Index of OID
*
*  @return ASN1_OP_OK on success, error code otherwise
* <br>            else Error occurred
*/
static  int ChkKnownSignatType(IDATA* ObjID_Desc,
					   int* AlgorID_Index)
{
  return(GetAlgorIndex(ObjID_Desc,PURP_SIGNAT_TYPE_AND_ALGOR,AlgorID_Index));
}
/**
* Subroutine ChkKnownPrivateKeyInfoAlgor checks if an ASN1 ObjectID
* (without header) is a known Algorithm ID for the Private key
* info field. If so returns internal OID Index (ChkKnownPrivateKeyInfoAlgor).
*
*  @param ObjID_Desc ObjID-Descriptor
*  @param AlgorID_Index Index of OID
*
*  @return ASN1_OP_OK on success, error code otherwise
* <br>            else Error occurred
*/
static  int ChkKnownPrivateKeyInfoAlgor(IDATA* ObjID_Desc,
						  int* AlgorID_Index)
{
  return(GetAlgorIndex(ObjID_Desc,PURP_PRIVATE_VALUE_ALGOR,AlgorID_Index));
}

extern "C"  int SubDecodePubKeyInfo(HMEM_CTX_DEF
			IDATA* ObjID_Desc,
			IDATA* AlgorPar_Desc,
			IDATA* PublicVal_Desc,
			IDATPARR** pDstDatArrayDesc,
			int* PubAlgorType)
{
  int i;
  int Retcode = ASN1_OP_OK;
  int AlgorType;
  int DataCnt;
  int ParamCnt;

  int ParamLen;
  int ParamOffset;
  int ParamCtlCnt;
  int ParamErrCode;

  int ValueLen;
  int ValueOffset;
  int ValueIndex=0;
  int ValueCtlCnt;
  int ValueErrCode;

  char* ParamBase;
  char* ValueBase;
  char * pParamCtl;
  char * pValueCtl;

  int TmpData[1];

  IDATPARR* DatArrayDesc = NULL;
  IDATPARR* pTmpArrayDesc[1];

  //----------------------------------------------------
  // check for NULL-Pointers
  //----------------------------------------------------
  if((ObjID_Desc == NULL) || (AlgorPar_Desc == NULL) ||
     (PublicVal_Desc == NULL) || (pDstDatArrayDesc == NULL))
    return(ASN1_DEC_PUB_KEY_NULL_PTR_ERR);
  pDstDatArrayDesc[0] = NULL;
  //---------------------------------------------
  // check if the OID is known and is usable
  //---------------------------------------------
  Retcode = ChkKnownPublicKeyInfoAlgor(ObjID_Desc,TmpData);
  if(Retcode != ASN1_OP_OK) return(Retcode);
  //---------------------------------------------------
  // Known and usable, allocate required array for Data
  //---------------------------------------------------
  switch(TmpData[0])
  {
    case OID_PKCS1_RSA_ENCRYPTION:
      AlgorType     = RSA_PUBLIC_ALGOR;
      ParamCnt	    = RSA_ALG_PAR_MAX_INDEX;
      DataCnt       = RSA_PUB_DATA_MAX_INDEX;

      ParamCtlCnt   = RSA_PUB_ALG_CTL_CNT;
      pParamCtl     = (char *) RSA_AlgorParamsCtl;
      ParamErrCode  = ASN1_DEC_PUB_KEY_RSA_PAR_ERR;

      ValueCtlCnt   = RSA_PUB_VAL_CTL_CNT;
      pValueCtl     = (char *) RSA_PublicValueCtl;
      ValueIndex    = RSA_ALG_PAR_MAX_INDEX;
      ValueErrCode  = ASN1_DEC_PUB_KEY_RSA_VAL_ERR;
      break;

    case OID_X942_DH_PUBL_NUMBER:
      AlgorType     = DH_PUBLIC_ALGOR;
      ParamCnt	    = DH_ALG_PAR_MAX_INDEX;
      DataCnt       = DH_PUB_DATA_MAX_INDEX;

      ParamCtlCnt   = DH_PUB_ALG_CTL_CNT;
      pParamCtl     = (char *) DH_AlgorParamsCtl;
      ParamErrCode  = ASN1_DEC_PUB_KEY_DH_PAR_ERR;

      ValueCtlCnt   = DH_PUB_VAL_CTL_CNT;
      ValueIndex    = DH_ALG_PAR_MAX_INDEX;
      pValueCtl     = (char *) DH_PublicValueCtl;
      ValueErrCode  = ASN1_DEC_PUB_KEY_DH_VAL_ERR;
      break;

    case OID_X957_DSA_SIGNAT_ALGOR:
      AlgorType     = DSA_PUBLIC_ALGOR;
      ParamCnt	    = DSA_ALG_PAR_MAX_INDEX;
      DataCnt       = DSA_PUB_DATA_MAX_INDEX;

      ParamCtlCnt   = DSA_PUB_ALG_CTL_CNT;
      pParamCtl     = (char *) DSA_AlgorParamsCtl;
      ParamErrCode  = ASN1_DEC_PUB_KEY_DSA_PAR_ERR;

      ValueCtlCnt   = DSA_PUB_VAL_CTL_CNT;
      ValueIndex    = DSA_ALG_PAR_MAX_INDEX;
      pValueCtl     = (char *) DSA_PublicValueCtl;
      ValueErrCode  = ASN1_DEC_PUB_KEY_DSA_VAL_ERR;
      break;

    case OID_OIW_DSA_SIGNAT_ALGOR:
      AlgorType     = DSA_PUBLIC_ALGOR;
      ParamCnt      = OIW_DSA_ALG_PAR_MAX_INDEX;
      DataCnt       = DSA_PUB_DATA_MAX_INDEX;

      ParamCtlCnt   = OIW_DSA_PUB_ALG_CTL_CNT;
      pParamCtl     = (char *) OIW_DSA_AlgorParamsCtl;
      ParamErrCode  = ASN1_DEC_PUB_KEY_DSA_PAR_ERR;

      ValueCtlCnt   = OIW_DSA_PUB_VAL_CTL_CNT;
      ValueIndex    = 0;
      pValueCtl     = (char *) OIW_DSA_PublicValueCtl;
      ValueErrCode  = ASN1_DEC_PUB_KEY_DSA_VAL_ERR;
      break;

    default:
      return(ASN1_DEC_PUB_INTERNAL_ERR);
  }
  i = AllocIDATPARR_Struc(HMEM_CTX_REF1 pTmpArrayDesc,ParamCnt+DataCnt);
  if(i != ASN1_OP_OK) return(ASN1_DEC_PUB_KEY_ALLOC_ERR);
  DatArrayDesc = pTmpArrayDesc[0];

  ValueBase   = PublicVal_Desc->Base;
  ValueOffset = (int) PublicVal_Desc->Off;
  ValueLen    = PublicVal_Desc->Len;

  ParamBase   = AlgorPar_Desc->Base;
  ParamOffset = (int) AlgorPar_Desc->Off;
  ParamLen    = AlgorPar_Desc->Len;

  for(;;)						// Error FOR
  {
    //---------------------------------------------------
    // Process the Parameters and values
    //---------------------------------------------------
    if(ParamBase != NULL)			// Special case for DSA !!
    {    
      i = FromASN1(HMEM_CTX_REF1
		   ParamBase,ParamOffset,ParamLen, pParamCtl, ParamCtlCnt,
                   DatArrayDesc->ppArr,0);
      if(i != ASN1_OP_OK)
      {
        Retcode = ParamErrCode;
        break;
      }
    }
    i = FromASN1(HMEM_CTX_REF1
		 ValueBase,ValueOffset,ValueLen, pValueCtl, ValueCtlCnt,
                 DatArrayDesc->ppArr, ValueIndex);
    if(i != ASN1_OP_OK) Retcode = ValueErrCode;
    break;
  } // Error FOR
  pDstDatArrayDesc[0] = DatArrayDesc;
  PubAlgorType[0] = AlgorType;
  if(Retcode != ASN1_OP_OK)
  {
    FreeIDATPARR_Struc(HMEM_CTX_REF1 DatArrayDesc);
    pDstDatArrayDesc[0] = NULL;
  }
  return(Retcode);
}

extern "C"  int GetChkSignatTypeAlg(HMEM_CTX_DEF
			IDATA* SignatTypeAlg_Desc,
			IDATA* SignatAlgPar_Desc,
                        int* pSignatAlgor, int* pSignatType)
{
  int i;
  int Retcode = ASN1_OP_OK;
  int OIDSignatType;
  int SignatType=0;
  int SignatAlgor;

  int ParamCnt;
  int ParamLen;
  int ParamOffset;
  int ParamCtlCnt;
  int ParamErrCode;

  char* ParamBase;
  char * pParamCtl;

  int TmpData[1];

  IDATPARR* pTmpArrayDesc[1];
  IDATPARR* DatArrayDesc = NULL;

  IDATA** DatArray=NULL;

  //----------------------------------------------------
  // check for NULL-Pointers
  //----------------------------------------------------
  if((SignatTypeAlg_Desc == NULL) || (SignatAlgPar_Desc == NULL) ||
     (pSignatAlgor == NULL) || (pSignatType == NULL))
    return(ASN1_GET_CHK_SIGNAT_NULLPTR_ERR);
  pSignatAlgor[0] = INVALID_ALGOR;
  pSignatType[0] = INVALID_ALGOR;
  //----------------------------------------------------
  // check if the OID is known and is usable for signing
  //----------------------------------------------------
  Retcode = ChkKnownSignatType(SignatTypeAlg_Desc,TmpData);
  if(Retcode != ASN1_OP_OK) return(Retcode);
  //---------------------------------------------
  // Known and usable, setup Algor/Signature Data
  //---------------------------------------------
  OIDSignatType = TmpData[0];
  switch(OIDSignatType)
  {
    //-----------------------------------------------------
    // Setup RSA-Signature Data
    //-----------------------------------------------------
    case OID_PKCS1_MD2_WITH_RSA_ENC:
    case OID_PKCS1_MD5_WITH_RSA_ENC:
    case OID_PKCS1_SHA1_WITH_RSA_ENC:
    case OID_OIW_RSA_WITH_SHA1:
    case OID_TELESEC_RSA_WITH_RIPEMD160:
    case OID_PKCS1_SHA256_WITH_RSA_ENC:
    case OID_PKCS1_SHA384_WITH_RSA_ENC:
    case OID_PKCS1_SHA512_WITH_RSA_ENC:
    case OID_PKCS1_SHA224_WITH_RSA_ENC:

      SignatAlgor   = RSA_PUBLIC_ALGOR;

      ParamCnt      = RSA_ALG_PAR_MAX_INDEX;
      ParamCtlCnt   = RSA_PUB_ALG_CTL_CNT;
      pParamCtl     = (char *) RSA_AlgorParamsCtl;
      ParamErrCode  = ASN1_GET_CHK_SIGNAT_RSA_PAR_ERR;

      switch(OIDSignatType)
      {
        case OID_PKCS1_MD2_WITH_RSA_ENC:
          SignatType  = PKCS1_MD2_WITH_RSA_ENC;
          break;
        case OID_PKCS1_MD5_WITH_RSA_ENC:
          SignatType  = PKCS1_MD5_WITH_RSA_ENC;
          break;
        case OID_PKCS1_SHA1_WITH_RSA_ENC:
        case OID_OIW_RSA_WITH_SHA1:
          SignatType  = PKCS1_SHA1_WITH_RSA_ENC;
          break;
        case OID_TELESEC_RSA_WITH_RIPEMD160:
          SignatType  = TELESEC_RSA_WITH_RIPEMD160;
          break;
        case OID_PKCS1_SHA256_WITH_RSA_ENC:
          SignatType  = PKCS1_SHA256_WITH_RSA_ENC;
          break;
        case OID_PKCS1_SHA384_WITH_RSA_ENC:
          SignatType  = PKCS1_SHA384_WITH_RSA_ENC;
          break;
        case OID_PKCS1_SHA512_WITH_RSA_ENC:
          SignatType  = PKCS1_SHA512_WITH_RSA_ENC;
          break;
        case OID_PKCS1_SHA224_WITH_RSA_ENC:
          SignatType  = PKCS1_SHA224_WITH_RSA_ENC;
          break;

      } // RSA-Switch
      break;
    //-----------------------------------------------------
    // Setup DSA-Signature Data
    //-----------------------------------------------------
    case OID_OIW_DSA_WITH_SHA:
    case OID_OIW_DSA_WITH_SHA1:
      SignatAlgor   = DSA_PUBLIC_ALGOR;
      SignatType    = OIW_DSA_WITH_SHA1;
      if(OIDSignatType == OID_OIW_DSA_WITH_SHA)
        SignatType  = OIW_DSA_WITH_SHA;

      ParamCnt      = RSA_ALG_PAR_MAX_INDEX;
      ParamCtlCnt   = RSA_PUB_ALG_CTL_CNT;
      pParamCtl     = (char *) RSA_AlgorParamsCtl;
      ParamErrCode   = ASN1_GET_CHK_SIGNAT_DSA_PAR_ERR;
      break;

    case OID_X957_DSA_WITH_SHA1:
      SignatAlgor   = DSA_PUBLIC_ALGOR;
      SignatType    = X957_DSA_WITH_SHA1;

      ParamCnt       = DSA_ALG_PAR_MAX_INDEX;
      ParamCtlCnt    = DSA_PUB_ALG_CTL_CNT;
      pParamCtl      = (char *) DSA_AlgorParamsCtl;
      ParamErrCode   = ASN1_GET_CHK_SIGNAT_DSA_PAR_ERR;
      break;

    default:
      return(ASN1_GET_CHK_SIGNAT_INV_TYPE);
  } // switch
  //----------------------------------------------------------------------
  // Known, usable and same as requested, allocate required array for Data
  //----------------------------------------------------------------------
  i = AllocIDATPARR_Struc(HMEM_CTX_REF1 pTmpArrayDesc,ParamCnt);
  if(i != ASN1_OP_OK) return(ASN1_GET_CHK_SIGNAT_ALLOC_ERR);
  DatArrayDesc = pTmpArrayDesc[0];
  DatArray     = DatArrayDesc->ppArr;

  ParamBase   	    = SignatAlgPar_Desc->Base;
  ParamOffset       = (int) SignatAlgPar_Desc->Off;
  ParamLen          = SignatAlgPar_Desc->Len;
  //---------------------------------------------------
  // Process the Parameters (should be NULL / absent)
  //---------------------------------------------------
  if(ParamBase != NULL)				// Special case for DSA !!
  {    
    i = FromASN1(HMEM_CTX_REF1
                 ParamBase,ParamOffset,ParamLen,
                 pParamCtl, ParamCtlCnt,DatArrayDesc->ppArr,0);
    if(i != ASN1_OP_OK) Retcode = ParamErrCode;
    if((SignatAlgor == DSA_PUBLIC_ALGOR) && (SignatType == X957_DSA_WITH_SHA1))
    {
      if((DatArray[0]->Base != NULL) ||
        (DatArray[1]->Base != NULL) ||
        (DatArray[2]->Base != NULL)) Retcode = ParamErrCode;
    }
  }
  if(DatArrayDesc != NULL)
    FreeIDATPARR_Struc(HMEM_CTX_REF1 DatArrayDesc);
  if(Retcode != ASN1_OP_OK)
    return(Retcode);
  pSignatAlgor[0] = SignatAlgor;
  pSignatType[0] = SignatType;
  return(Retcode);
}

extern "C"  int SubDecodeSignature(HMEM_CTX_DEF
			IDATA* Signat_Desc,
			int SignatAlgor,
			IDATPARR** pDstDatArrayDesc)
{
  int i;

  int SignatCnt;

  IDATPARR* pTmpArrayDesc[1];
  IDATPARR* DatArrayDesc;

  IDATA** DatArray=NULL;

  //----------------------------------------------------
  // check for NULL-Pointers
  //----------------------------------------------------
  if((Signat_Desc == NULL) || (pDstDatArrayDesc == NULL))
    return(ASN1_DEC_SIGNAT_NULL_PTR_ERR);
  pDstDatArrayDesc[0] = NULL;

  switch(SignatAlgor)
  {
    //-----------------------------------------------------
    // Setup RSA-Signature Data
    //-----------------------------------------------------
    case RSA_PUBLIC_ALGOR:
      SignatCnt     = RSA_SIG_MAX_INDEX;
      break;
    //-----------------------------------------------------
    // Setup DSA-Signature Data NOTE: the r,s params
    // are not yet split !
    //-----------------------------------------------------
    case DSA_PUBLIC_ALGOR:
      SignatCnt     = RSA_SIG_MAX_INDEX;
      break;

    default:
      return(ASN1_DEC_SIGNAT_INV_ALG_TYPE);
  } // switch
  //----------------------------------------------------------------------
  // allocate required array for Data
  //----------------------------------------------------------------------
  i = AllocIDATPARR_Struc(HMEM_CTX_REF1 pTmpArrayDesc,SignatCnt);
  if(i != ASN1_OP_OK) return(ASN1_DEC_SIGNAT_ALLOC_ERR);
  DatArrayDesc = pTmpArrayDesc[0];
  DatArray     = DatArrayDesc->ppArr;
  //---------------------------------------------------
  // RSA, no subprocessing, copy direct to destination
  // DSA: no subprocessing done yet !!
  //---------------------------------------------------
//  if(SignatAlgor == RSA_PUBLIC_ALGOR)		// no ASN1 processing...
//  {
    CopyIdataContents(DatArray[0],Signat_Desc);
    pDstDatArrayDesc[0] = DatArrayDesc;
    return(ASN1_OP_OK);
//  }
  //---------------------------------------------------
  // DSA, Subprocess the Signature
  // not yet done, as DSA Verify does it itself !!
  //---------------------------------------------------

}

extern "C"  int SubDecodeCopyPrivKeyInfo(HMEM_CTX_DEF
			char* PrivKeyBuf,
                        int PrivKeyOffset, int PrivKeyLen,
			int* pPrivKeyType, int* pPrivKeyUsage,
			IDATPARR** pDstDatArrayDesc)
{
  int i;
  int Retcode = ASN1_OP_OK;

  int AlgorType = 0;
  int DataCnt;

  int ParamOffset;
  int ParamLen;
  int ParamCtlCnt;
  int ParamErrCode;

  int ValueOffset;
  int ValueLen;
  int ValueIndex=0;
  int ValueCtlCnt;
  int ValueErrCode;

  int PrivKeyUsage = 0;

  char* ParamBase;
  char* ValueBase;

  char * pParamCtl;
  char * pValueCtl;

  int TmpData[1];

  IDATPARR* pTmpArrayDesc[1];
  IDATPARR* DatArrayDesc = NULL;
  IDATPARR* PrivKeyDatArrayDesc;

  IDATA** PrivKeyDatArray;

  IDATA* PrivateParArray;
  IDATA* PrivateValArray;

  //----------------------------------------------------
  // 0. check for NULL-Pointers
  //----------------------------------------------------
  if((PrivKeyBuf == NULL) || (pDstDatArrayDesc == NULL) ||
     (pPrivKeyType == NULL) || (pPrivKeyUsage == NULL))
    return(ASN1_DEC_PRIV_KEY_NULL_PTR_ERR);
  pDstDatArrayDesc[0] = NULL;
  //----------------------------------------------------
  // 1. Allocate Array descriptor for Key Split
  //----------------------------------------------------
  i = AllocIDATPARR_Struc(HMEM_CTX_REF1
			  pTmpArrayDesc,PKCS8_KEY_MAX_DATA_INDEX);
  if(i != ASN1_OP_OK) return(i);
  PrivKeyDatArrayDesc = pTmpArrayDesc[0];
  PrivKeyDatArrayDesc->Flags |= FREE_CLEAR_BIT_MASK;
  PrivKeyDatArray     = PrivKeyDatArrayDesc->ppArr;
  //----------------------------------------------------
  // 2. Split the PKCS-8 encoded Private Key Info
  //----------------------------------------------------
  i = FromASN1(HMEM_CTX_REF1
	       PrivKeyBuf,PrivKeyOffset,PrivKeyLen,
               (char *) PKCS8_PrivKeyInfoCtl,PKCS8_PRIV_KEY_INFO_CTL_CNT,
               PrivKeyDatArray, 0);
  if(i != ASN1_OP_OK) return(i);
  PrivateParArray = PrivKeyDatArray[PKCS8_KEY_ALG_PAR_INDEX];
  PrivateValArray = PrivKeyDatArray[PKCS8_KEY_VALUE_INDEX];

  for(;;)					//Error FOR
  {
    //----------------------------------------------------
    // 2. get the private key algor type
    //----------------------------------------------------
    Retcode = ChkKnownPrivateKeyInfoAlgor(
                 PrivKeyDatArray[PKCS8_KEY_ALGOR_INDEX],
                 TmpData);
    if(Retcode != ASN1_OP_OK) break;
    //---------------------------------------------------
    // 3. Known and usable, allocate required arrays
    //---------------------------------------------------
    switch(TmpData[0])
    {
      case OID_PKCS1_RSA_ENCRYPTION:
        AlgorType     = RSA_PUBLIC_ALGOR;
        DataCnt       = RSA_PRIV_KEY_MAX_INDEX+RSA_ALG_PAR_MAX_INDEX;
	PrivKeyUsage  = (int) ( X509_KEYUSAGE_DIG_SIGNAT_BIT | X509_KEYUSAGE_KEY_ENC_BIT | X509_KEYUSAGE_DATA_ENC_BIT | X509_KEYUSAGE_KEY_AGREE_BIT | X509_KEYUSAGE_CERT_SIGN_BIT);

        ParamCtlCnt   = RSA_PUB_ALG_CTL_CNT;
        pParamCtl     = (char *) RSA_AlgorParamsCtl;
        ParamErrCode  = ASN1_DEC_PRIV_KEY_RSA_PAR_ERR;

        ValueCtlCnt   = RSA_PRIV_KEY_CTL_CNT;
        ValueIndex    = RSA_ALG_PAR_MAX_INDEX;
        pValueCtl     = (char *) RSA_PrivKeyCtl;
        ValueErrCode  = ASN1_DEC_PRIV_KEY_RSA_VAL_ERR;
        break;

      case OID_X942_DH_PUBL_NUMBER:
        AlgorType     = DH_PUBLIC_ALGOR;
        DataCnt       = DH_PRIV_KEY_MAX_INDEX+DH_ALG_PAR_MAX_INDEX;
	PrivKeyUsage  = X509_KEYUSAGE_KEY_AGREE_BIT;

        ParamCtlCnt   = DH_PUB_ALG_CTL_CNT;
        pParamCtl     = (char *) DH_AlgorParamsCtl;
        ParamErrCode  = ASN1_DEC_PRIV_KEY_DH_PAR_ERR;

        ValueCtlCnt   = DH_PRIV_KEY_CTL_CNT;
        ValueIndex    = DH_ALG_PAR_MAX_INDEX;
        pValueCtl     = (char *) DH_PrivKeyCtl;
        ValueErrCode  = ASN1_DEC_PRIV_KEY_DH_VAL_ERR;
        break;

      case OID_X957_DSA_SIGNAT_ALGOR:
        AlgorType     = DSA_PUBLIC_ALGOR;
        DataCnt       = DSA_PRIV_KEY_MAX_INDEX+DSA_ALG_PAR_MAX_INDEX;
	PrivKeyUsage  = (int) ( X509_KEYUSAGE_DIG_SIGNAT_BIT | X509_KEYUSAGE_CERT_SIGN_BIT);

        ParamCtlCnt   = DSA_PUB_ALG_CTL_CNT;
        pParamCtl     = (char *) DSA_AlgorParamsCtl;
        ParamErrCode  = ASN1_DEC_PRIV_KEY_DSA_PAR_ERR;

        ValueCtlCnt   = DSA_PRIV_KEY_CTL_CNT;
        ValueIndex    = DSA_ALG_PAR_MAX_INDEX;
        pValueCtl     = (char *) DSA_PrivKeyCtl;
        ValueErrCode  = ASN1_DEC_PRIV_KEY_DSA_VAL_ERR;
        break;

      default:
        return(ASN1_DEC_PRIV_KEY_INTERNAL_ERR);
    }
    i = AllocIDATPARR_Struc(HMEM_CTX_REF1 pTmpArrayDesc,DataCnt);
    if(i != ASN1_OP_OK) return(ASN1_DEC_PRIV_KEY_ALLOC_ERR);
    DatArrayDesc = pTmpArrayDesc[0];
    DatArrayDesc->Flags |= FREE_CLEAR_BIT_MASK;

    ValueBase   = PrivateValArray->Base;
    ValueOffset = (int) PrivateValArray->Off;
    ValueLen    = PrivateValArray->Len;

    ParamBase   = PrivateParArray->Base;
    ParamOffset = (int) PrivateParArray->Off;
    ParamLen    = PrivateParArray->Len;
    //---------------------------------------------------
    // 4. Process the Parameters and values
    //---------------------------------------------------
    if((ParamBase ==NULL)&&
      ((AlgorType == DSA_PUBLIC_ALGOR)||	// no DSA params !!
       (AlgorType == DH_PUBLIC_ALGOR)))		// no DH  params !!
    {
      Retcode = ParamErrCode;
      break;
    }
    if(ParamBase != NULL)			// no parameters for RSA !!
    {
      i = FromASN1(HMEM_CTX_REF1
		   ParamBase,ParamOffset,ParamLen, pParamCtl, ParamCtlCnt,
                   DatArrayDesc->ppArr,0);
      if(i != ASN1_OP_OK)
      {
        Retcode = ParamErrCode;
        break;
      }
    }
    i = FromASN1(HMEM_CTX_REF1
		 ValueBase,ValueOffset,ValueLen, pValueCtl, ValueCtlCnt,
                 DatArrayDesc->ppArr, ValueIndex);
    if(i != ASN1_OP_OK)
    {
      Retcode = ValueErrCode;
      break;
    }
    //---------------------------------------------------
    // 5. Copy the Data to local allocated arrays
    //---------------------------------------------------
    Retcode = CopyToLocalDatArrayDesc(HMEM_CTX_REF1
				      DatArrayDesc);
    break;
  } // Error FOR
  FreeIDATPARR_Struc(HMEM_CTX_REF1 PrivKeyDatArrayDesc);
  pDstDatArrayDesc[0] = DatArrayDesc;
  pPrivKeyType[0]  = AlgorType;
  pPrivKeyUsage[0] = PrivKeyUsage | X509_KEYUSAGE_VALID_BIT;
  if(Retcode != ASN1_OP_OK)
  {
    FreeIDATPARR_Struc(HMEM_CTX_REF1 DatArrayDesc);
    pDstDatArrayDesc[0] = NULL;
  }
  return(Retcode);
}

extern "C"  void FreeDnListArray(HMEM_CTX_DEF
		X501_DN** pDNListArray, int DNCount)
{
  if(pDNListArray != NULL)			// array was allocated
  {
    if(DNCount != 0)
    {
      do
      {
        DNCount--;
	FreeX501DN_Struc(HMEM_CTX_REF1 pDNListArray[DNCount]);
      }while(DNCount != 0);
    }
    FREE_ARRAY(HMEM_CTX_REF,pDNListArray);
  }
}

extern "C"  void FreeCertStruc(HMEM_CTX_DEF
				      X509CERT * CertStruc)
{
  //---------------------------------------------
  // Check for Base NULL pointer first
  //---------------------------------------------
  if(CertStruc == NULL) return;

  FreeIDATPARR_Struc(HMEM_CTX_REF1 CertStruc->Certificate);
  FreeIDATPARR_Struc(HMEM_CTX_REF1 CertStruc->TBS_Certificate);
  FreeIDATPARR_Struc(HMEM_CTX_REF1 CertStruc->CertSignature);
  FreeIDATPARR_Struc(HMEM_CTX_REF1 CertStruc->Version);
  FreeIDATPARR_Struc(HMEM_CTX_REF1 CertStruc->SerialNumber);
  FreeIDATPARR_Struc(HMEM_CTX_REF1 CertStruc->IssuerNameOcsp);
  FreeX501DN_Struc(HMEM_CTX_REF1 CertStruc->Issuer);
  FreeIDATPARR_Struc(HMEM_CTX_REF1 CertStruc->NotBefore);
  FreeIDATPARR_Struc(HMEM_CTX_REF1 CertStruc->NotAfter);
  FreeIDATPARR_Struc(HMEM_CTX_REF1 CertStruc->SubjectNameOcsp);
  FreeX501DN_Struc(HMEM_CTX_REF1 CertStruc->Subject);
  FreeIDATPARR_Struc(HMEM_CTX_REF1 CertStruc->SubjPubKeyParVal);
  FreeIDATPARR_Struc(HMEM_CTX_REF1 CertStruc->PubKeyValueOcsp);
  FreeIDATPARR_Struc(HMEM_CTX_REF1 CertStruc->IssuerUniqueID);
  FreeIDATPARR_Struc(HMEM_CTX_REF1 CertStruc->SubjectUniqueID);
  FreeIDATPARR_Struc(HMEM_CTX_REF1 CertStruc->Extensions);
  FreeIDATPARR_Struc(HMEM_CTX_REF1 CertStruc->AuthorityKeyID);
  FreeIDATPARR_Struc(HMEM_CTX_REF1 CertStruc->SubjectKeyID);
  FreeIDATPARR_Struc(HMEM_CTX_REF1 CertStruc->KeyUsage);
  FreeIDATPARR_Struc(HMEM_CTX_REF1 CertStruc->CertPolicies);
  FreeIDATPARR_Struc(HMEM_CTX_REF1 CertStruc->SubjAltName);
  FreeIDATPARR_Struc(HMEM_CTX_REF1 CertStruc->IssuerAltName);
  FreeIDATPARR_Struc(HMEM_CTX_REF1 CertStruc->BasicConstraints);
  FreeIDATPARR_Struc(HMEM_CTX_REF1 CertStruc->NameConstraints);
  FreeIDATPARR_Struc(HMEM_CTX_REF1 CertStruc->PolicyConstraints);
  FreeIDATPARR_Struc(HMEM_CTX_REF1 CertStruc->ExtendedKeyUsage);
  FreeIDATPARR_Struc(HMEM_CTX_REF1 CertStruc->CrlDistPoints);
  FreeIDATPARR_Struc(HMEM_CTX_REF1 CertStruc->PrivKeyData);
  FREE_ARRAY(HMEM_CTX_REF,CertStruc->pNotBeforeTimeArray);
  FREE_ARRAY(HMEM_CTX_REF,CertStruc->pNotAfterTimeArray);
  FREE_ARRAY(HMEM_CTX_REF,CertStruc);
}

extern "C"  int AllocCertStruc(HMEM_CTX_DEF
				      X509CERT ** pCertStruc)
{
  int Retcode = ASN1_CERT_ALLOC_ELEM_ALLOC_ERR;

  IDATPARR* pIdatapArray[1];
  X509CERT * Cert;
  

  if(pCertStruc == NULL) return(ASN1_CERT_ALLOC_NULL_PTR_ERR);
  pCertStruc[0] = NULL;
  //-----------------------------------------------
  // Allocate the Certificate Structure, clear it
  //-----------------------------------------------
  Cert = (X509CERT*)
            ((void *) BIT8_ARRAY_CALLOC(HMEM_CTX_REF,1,sizeof(X509CERT)));
  if(Cert == NULL)
    return(ASN1_CERT_ALLOC_ALLOC_ERR);
  //-----------------------------------------------
  // Initialize structure
  //-----------------------------------------------

  Cert->VersionNumber	   = -1;
  Cert->SignatAlgor   = INVALID_ALGOR;
  Cert->SignatType    = INVALID_ALGOR;
  Cert->PublicKeyType    = INVALID_ALGOR;
  Cert->PublicKeyPurpose = -1;
  Cert->PrivKeyType   = INVALID_ALGOR;
  Cert->DateTimeValidity = ASN1_CERT_TIME_STATE_UNKNOWN;
  Cert->BasicConstrCAMode  = X509_BASICCONSTR_CA_FLAG_UNDEF;
  Cert->BasicConstrPathLen = X509_BASICCONSTR_PATHLEN_UNDEF;
  //----------------------------------------------------------
  // Allocate the Element Descriptors
  //----------------------------------------------------------
  for(;;)
  {
    if(AllocIDATPARR_Struc(HMEM_CTX_REF1 pIdatapArray,1) != ASN1_OP_OK) break;
    Cert->Certificate = pIdatapArray[0];

    if(AllocIDATPARR_Struc(HMEM_CTX_REF1 pIdatapArray,1) != ASN1_OP_OK) break;
    Cert->TBS_Certificate       = pIdatapArray[0];

    if(AllocIDATPARR_Struc(HMEM_CTX_REF1 pIdatapArray,1) != ASN1_OP_OK) break;
    Cert->CertSignature        = pIdatapArray[0];

    if(AllocIDATPARR_Struc(HMEM_CTX_REF1 pIdatapArray,1) != ASN1_OP_OK) break;
    Cert->Version       = pIdatapArray[0];

    if(AllocIDATPARR_Struc(HMEM_CTX_REF1 pIdatapArray,1) != ASN1_OP_OK) break;
    Cert->SerialNumber        = pIdatapArray[0];

    if(AllocIDATPARR_Struc(HMEM_CTX_REF1 pIdatapArray,1) != ASN1_OP_OK) break;
    Cert->IssuerNameOcsp= pIdatapArray[0];

    if(AllocIDATPARR_Struc(HMEM_CTX_REF1 pIdatapArray,1) != ASN1_OP_OK) break;
    Cert->NotBefore     = pIdatapArray[0];

    if(AllocIDATPARR_Struc(HMEM_CTX_REF1 pIdatapArray,1) != ASN1_OP_OK) break;
    Cert->NotAfter      = pIdatapArray[0];

    if(AllocIDATPARR_Struc(HMEM_CTX_REF1 pIdatapArray,1) != ASN1_OP_OK) break;
    Cert->SubjectNameOcsp= pIdatapArray[0];

    if(AllocIDATPARR_Struc(HMEM_CTX_REF1 pIdatapArray,1) != ASN1_OP_OK) break;
    Cert->PubKeyValueOcsp = pIdatapArray[0];

    if(AllocIDATPARR_Struc(HMEM_CTX_REF1 pIdatapArray,1) != ASN1_OP_OK) break;
    Cert->IssuerUniqueID      = pIdatapArray[0];

    if(AllocIDATPARR_Struc(HMEM_CTX_REF1 pIdatapArray,1) != ASN1_OP_OK) break;
    Cert->SubjectUniqueID     = pIdatapArray[0];

    if(AllocIDATPARR_Struc(HMEM_CTX_REF1 pIdatapArray,1) != ASN1_OP_OK) break;
    Cert->Extensions    = pIdatapArray[0];

    if(AllocIDATPARR_Struc(HMEM_CTX_REF1 pIdatapArray,1) != ASN1_OP_OK) break;
    Cert->AuthorityKeyID     = pIdatapArray[0];
    if(AllocIDATPARR_Struc(HMEM_CTX_REF1 pIdatapArray,1) != ASN1_OP_OK) break;
    Cert->SubjectKeyID     = pIdatapArray[0];
    if(AllocIDATPARR_Struc(HMEM_CTX_REF1 pIdatapArray,1) != ASN1_OP_OK) break;
    Cert->KeyUsage      = pIdatapArray[0];
    if(AllocIDATPARR_Struc(HMEM_CTX_REF1 pIdatapArray,1) != ASN1_OP_OK) break;
    Cert->CertPolicies      = pIdatapArray[0];
    if(AllocIDATPARR_Struc(HMEM_CTX_REF1 pIdatapArray,1) != ASN1_OP_OK) break;
    Cert->SubjAltName   = pIdatapArray[0];
    if(AllocIDATPARR_Struc(HMEM_CTX_REF1 pIdatapArray,1) != ASN1_OP_OK) break;
    Cert->IssuerAltName = pIdatapArray[0];
    if(AllocIDATPARR_Struc(HMEM_CTX_REF1 pIdatapArray,1) != ASN1_OP_OK) break;
    Cert->BasicConstraints   = pIdatapArray[0];
    if(AllocIDATPARR_Struc(HMEM_CTX_REF1 pIdatapArray,1) != ASN1_OP_OK) break;
    Cert->NameConstraints    = pIdatapArray[0];
    if(AllocIDATPARR_Struc(HMEM_CTX_REF1 pIdatapArray,1) != ASN1_OP_OK) break;
    Cert->PolicyConstraints  = pIdatapArray[0];
    if(AllocIDATPARR_Struc(HMEM_CTX_REF1 pIdatapArray,1) != ASN1_OP_OK) break;
    Cert->ExtendedKeyUsage   = pIdatapArray[0];
    if(AllocIDATPARR_Struc(HMEM_CTX_REF1 pIdatapArray,1) != ASN1_OP_OK) break;
    Cert->CrlDistPoints = pIdatapArray[0];

    Retcode = ASN1_OP_OK;			// asssume o.k.
    Cert->pNotBeforeTimeArray = INT_ARRAY_ALLOC(HMEM_CTX_REF,TIME_ARRAY_SIZE);
    Cert->pNotAfterTimeArray  = INT_ARRAY_ALLOC(HMEM_CTX_REF,TIME_ARRAY_SIZE);
    if((Cert->pNotBeforeTimeArray == NULL) ||
       (Cert->pNotAfterTimeArray == NULL))
      Retcode = ASN1_CERT_ALLOC_ALLOC_ERR;
    memset(Cert->pNotBeforeTimeArray,0,TIME_ARRAY_SIZE * sizeof(int));
    memset(Cert->pNotAfterTimeArray,0,TIME_ARRAY_SIZE * sizeof(int));

    break;
  } // Error FOR
  pCertStruc[0] = Cert;
  if(Retcode != ASN1_OP_OK)
  {
    FreeCertStruc(HMEM_CTX_REF1 Cert);
    FREE_CARRAY(HMEM_CTX_REF,Cert);
    pCertStruc[0] = NULL;
  }
  return(Retcode);
}

extern "C"  void FreeCertList(HMEM_CTX_DEF
		X509CERT ** pCertArray, int CertCount)
{
  if(pCertArray != NULL)			// array was allocated
  {
    while(CertCount != 0){
        CertCount--;
		if(pCertArray[CertCount] != NULL){
            // only free, if there is a cert
			FreeCertStruc(HMEM_CTX_REF1 pCertArray[CertCount]);
        }
    }
    FREE_ARRAY(HMEM_CTX_REF,pCertArray);
  }
}
//******************************************************************
//******************************************************************
//
// Certificate Extensions Processing routines
//
//******************************************************************
//******************************************************************

extern "C"  int GetBoolValueFromBuf(char* pBuf, int Offset, int Len,
			int* pValue)
{
  //-------------------------------------------------------
  // Check parameters
  //-------------------------------------------------------
  if((pBuf == NULL) || (pValue == NULL))
    return(ASN1_NULL_PTR);

  if(Len != 1)
    return(ASN1_GET_BOOLEAN_INVALID_SIZE); 
  //-------------------------------------------------------
  // Return the Value
  //-------------------------------------------------------
  pValue[0] = 0;		// preset FALSE
  if(pBuf[Offset] != 0)
    pValue[0] = 1;		// set true
  return(ASN1_OP_OK);
}

extern "C"  int GetOptBoolValueFromDesc(IDATPARR* pSrcDesc,
		int SrcIndex, int OptionalFlag, int DefaultValue,
		int* pValue)
{
  IDATA* pIdata;
  IDATA** ppArr;
  //-------------------------------------------------------
  // Check parameters
  //-------------------------------------------------------
  if((pSrcDesc == NULL) || (pValue == NULL) ||
     ((ppArr = pSrcDesc->ppArr) == NULL))
    return(ASN1_NULL_PTR);

  if(SrcIndex >= pSrcDesc->Cnt)
    return(ASN1_PARAM_ERR);
  //-------------------------------------------------------
  // Check if Boolean is present
  //-------------------------------------------------------
  pIdata = ppArr[SrcIndex];
  if((pIdata != NULL) && (pIdata->Base != NULL) &&
     (pIdata->Len > 0))
  {
    //-----------------------------------------------------
    // Boolean is present anyway, decode
    //-----------------------------------------------------
    return(GetBoolValueFromBuf(pIdata->Base, (int) pIdata->Off,
		pIdata->Len, pValue));
  }
  //-------------------------------------------------------
  // Boolean is NOT present, check if allowed
  //-------------------------------------------------------
  if(OptionalFlag == 0)
    return(ASN1_GET_BOOLEAN_NOT_PRESENT); 
  pValue[0] = 0;			// preset FALSE
  if(DefaultValue > 0)
    pValue[0] = 1;
  else if(DefaultValue < 0)
    pValue[0] = -1;
  return(ASN1_OP_OK);
}  

extern "C"  int GetBit32MsbBitsFromBitstring(char* pBuf,
			int Offset, int Len, int MaxBitCnt,
			int* pBits)
{
  int UnusedBits;
  int ByteCount;
  int ShiftCount;
  int BitBuf = 0;

  pBits[0] = 0;
  if((pBuf == NULL) || (Len <= 0))
    return(ASN1_GET_BITSTR_BITS_INVAL_SIZE); 
  //-------------------------------------------------------
  // Get unused Bits count and number of bytes, check
  //-------------------------------------------------------
  ByteCount = Len-1;
  if(ByteCount > 4)
    return(ASN1_GET_BITSTR_BITS_TOO_MANY); 
  UnusedBits = (int) pBuf[Offset++] & 0xFF;
  if(UnusedBits > 7)
    return(ASN1_GET_BITSTR_BITS_INVAL_FMT); 
  if(ByteCount == 0)
  {
    if(UnusedBits != 0)
      return(ASN1_GET_BITSTR_BITS_INVAL_FMT); 
    return(ASN1_OP_OK);
  }
  if(((ByteCount * 8) - UnusedBits) > MaxBitCnt)
    return(ASN1_GET_BITSTR_BITS_TOO_MANY); 
  //-------------------------------------------------------
  // Extract the Bits, shift them up as required
  //-------------------------------------------------------
  ShiftCount = 3 * 8;
  while(ByteCount != 0)
  {
    BitBuf = BitBuf | (((int) pBuf[Offset++] & 0xFF) << ShiftCount);
    ShiftCount -= 8;
    ByteCount--;
  }
  BitBuf = BitBuf & (~((int) UnusedBits));	// mask off invalid ones
  pBits[0] = BitBuf;
  return(ASN1_OP_OK);
}

extern "C"  int ByteBufToUnsignedBIT32Num(char* pSrcBuf,
	int SrcOff, int SrcLen, int* pValue)
{
  int Value = 0;
  //----------------------------------------------------------------
  // check parameters, allocate buffer clear first byte
  //----------------------------------------------------------------
  if((pSrcBuf == NULL) || (pValue == NULL))
    return(ASN1_NULL_PTR);

  if(SrcLen <= 0)
    return(ASN1_BUF_TO_BIT32NUM_INVLEN_ERR);

  if(pSrcBuf[SrcOff] == 0)
  {
    SrcLen--;
    SrcOff++;
  }
  if(SrcLen > 4)
    return(ASN1_BUF_TO_BIT32NUM_INVLEN_ERR);
  //----------------------------------------------------------------
  // Convert to BIT32 (leading zero will be shifted out)
  //----------------------------------------------------------------
  while(SrcLen != 0)
  {
    Value <<= 8;				// shift up
    Value |= (int) pSrcBuf[SrcOff++] & 0xFF;	// insert byte
    SrcLen--;
  }
  pValue[0] = Value;				// set return value
  return(ASN1_OP_OK);
}
/**
* Gets max. 32 Bits (possible optional) from ASN.1 INTEGER value data
* descriptor (GetOptBIT32IntValueFromDesc).
*
*  @param pSrcDesc Descriptor with data
*  @param SrcIndex Descriptor index
*  @param OptionalFlag 0 - must be present, else opt.
*  @param pValue Value extracted
*  @param pPresentFlag 0 - was not present
*  @return 0 on success, error code otherwise
*/
extern "C"  int GetOptBIT32IntValueFromDesc(IDATPARR* pSrcDesc,
		int SrcIndex, int OptionalFlag, int* pValue,
		int* pPresentFlag)
{
  IDATA* pIdata;
  IDATA** ppArr;
  //-------------------------------------------------------
  // Check parameters
  //-------------------------------------------------------
  if((pSrcDesc == NULL) || (pValue == NULL) || (pPresentFlag == NULL) ||
     ((ppArr = pSrcDesc->ppArr) == NULL))
    return(ASN1_NULL_PTR);

  if(SrcIndex >= pSrcDesc->Cnt)
    return(ASN1_PARAM_ERR);
  //-------------------------------------------------------
  // Check if Integer is present
  //-------------------------------------------------------
  pPresentFlag[0] = 0;
  pIdata = ppArr[SrcIndex];
  if((pIdata != NULL) && (pIdata->Base != NULL) &&
     (pIdata->Len > 0))
  {
    //-----------------------------------------------------
    // Integer is present, decode anyway
    //-----------------------------------------------------
    pPresentFlag[0] = 1;
    return(ByteBufToUnsignedBIT32Num(pIdata->Base,
				     (int) pIdata->Off,
				     pIdata->Len, pValue));
  }
  //-------------------------------------------------------
  // Integer is NOT present, check if allowed
  //-------------------------------------------------------
  if(OptionalFlag == 0)
    return(ASN1_GET_SHORTINT_NOT_PRESENT); 
  return(ASN1_OP_OK);
}  

extern "C"  int FromASN1_Type(HMEM_CTX_DEF
			char* InpBuf, int InpOffset,
			int InpLen, char * pCtlArray, int CtlElementCnt,
			int DataElementCnt, int BaseErrorCode,
			IDATPARR** ppDstDesc, int* SubErrCode)
{
  int Retcode;

  IDATPARR* pDstDesc;
  IDATPARR* ppTmpDesc[1];

  ppDstDesc[0] = NULL;				// invalidate
  //---------------------------------------------------------------
  // allocate the required IDATA ptr array and the elements
  //---------------------------------------------------------------
  if((Retcode = AllocIDATPARR_Struc(HMEM_CTX_REF1 ppTmpDesc,
			             DataElementCnt)) != ASN1_OP_OK)
    return(Retcode);
  pDstDesc = ppTmpDesc[0];
  //---------------------------------------------------------------
  // Split the ASN.1 Type now
  //---------------------------------------------------------------
  if((Retcode = FromASN1(HMEM_CTX_REF1
			 InpBuf,InpOffset,InpLen,
 		         pCtlArray, CtlElementCnt,
			 pDstDesc->ppArr, 0)) != ASN1_OP_OK)
  {
    FreeIDATPARR_Struc(HMEM_CTX_REF1 pDstDesc);
    if(SubErrCode != NULL)
      SubErrCode[0] = Retcode;
    return(BaseErrorCode);    
  }
  ppDstDesc[0] = pDstDesc;		// set valid
  return(ASN1_OP_OK);
}

extern "C"  int FromASN1_DescToDesc(HMEM_CTX_DEF
	IDATPARR* pSrcDesc,
	int SrcIndex, char * pCtlArray, int CtlElementCnt,
	int DataElementCnt, int BaseErrorCode,
	IDATPARR** ppDstDesc, int* SubErrCode)
{
  int Retcode;
  IDATA* pIdata;
  IDATA** ppArr;

  IDATPARR* ppTmpDesc[1];
  //-----------------------------------------------------------
  // Check the Buffer from the source descriptor
  //-----------------------------------------------------------
  if((pSrcDesc == NULL) || (pCtlArray == NULL) || (ppDstDesc == NULL))
    return(ASN1_NULL_PTR);
  if((ppArr = pSrcDesc->ppArr) == NULL)
    return(ASN1_NULL_PTR);
  if(SrcIndex >= pSrcDesc->Cnt)
    return(ASN1_PARAM_ERR);

  if(((pIdata = ppArr[SrcIndex]) == NULL) || (pIdata->Base == NULL))
    return(ASN1_NULL_PTR);
  //------------------------------------------------------------
  // ASN.1 Split the Data to new descriptor
  //------------------------------------------------------------
  if((Retcode = FromASN1_Type(HMEM_CTX_REF1
		  pIdata->Base, (int) pIdata->Off,
		  pIdata->Len, pCtlArray, CtlElementCnt,
		  DataElementCnt, BaseErrorCode, ppTmpDesc,
		  SubErrCode)) != ASN1_OP_OK)
    return(Retcode);
  //------------------------------------------------------------
  // Free Old Descriptor (if present), set new one
  //------------------------------------------------------------
  if(ppDstDesc[0] != NULL)
    FreeIDATPARR_Struc(HMEM_CTX_REF1 ppDstDesc[0]);
  ppDstDesc[0] = ppTmpDesc[0];
  return(ASN1_OP_OK);
}

extern "C"  int GetX509Ext_OidIndex(IDATA* ObjID_Desc,
			int* pExt_OidIndex)
{
  int i;
  int ObjID_Offset;
  int ObjID_Len;
  
  int X509ExtCnt = GRP_X509_EXT_ATT_CNT;

  int ActExtOidIndex = 0;

  int ActOID_Index;
  int ActOID_Len;

  char* ObjID_Base;
  //--------------------------------------------------
  // get start and length of Object ID
  //--------------------------------------------------
  if((ObjID_Desc == NULL) || (pExt_OidIndex == NULL))
    return(ASN1_GET_RDN_OID_ERR);

  pExt_OidIndex[0] = -1;		// signal not recognized
  
  ObjID_Base   = ObjID_Desc->Base;
  ObjID_Offset = (int) ObjID_Desc->Off;
  ObjID_Len    = ObjID_Desc->Len;

  if((ObjID_Base == NULL) || (ObjID_Len <= 0))
    return(ASN1_GET_EXT_OID_NO_OID);
  //-----------------------------------------------
  // search the X509 Extensions Table for OID match
  //-----------------------------------------------
  do
  {
    ActOID_Index = X509_EXT_ATT_OffsetTab[ActExtOidIndex];
    ActOID_Len = (int) OID_Table[ActOID_Index+2] & 0xFF;
    i = MatchASN1ValuesByteByByte(ObjID_Base, ObjID_Offset, ObjID_Len,
        	    (char *) OID_Table, ActOID_Index+3,ActOID_Len);
    if(i == ASN1_SAME) break;				// same found
    ActExtOidIndex++;
    X509ExtCnt --;
  }while(X509ExtCnt != 0);
  if(X509ExtCnt != 0)
    pExt_OidIndex[0] = X509_EXT_ATT_IndexTab[ActExtOidIndex];
  return(ASN1_OP_OK);
}
/**
* Searches for an ASN1 ObjectID (without header) among the known PKIX keypurpose 
* OIDs (GetPKIX_KeyPurposeOidIndex).
* If found, the OID's Index is returned. 
*
*  @param ObjID_Desc ObjID-Descriptor
*  @param pPkix_OidIndex Index of OID, -1 if not found
*
*  @return ASN1_OP_OK on success, error code otherwise, else Error occurred
*/
extern "C"  int GetPKIX_KeyPurposeOidIndex(IDATA* ObjID_Desc,
			int* pPkix_OidIndex)
{
  int i;
  int ObjID_Offset;
  int ObjID_Len;
  
  int PkixKeyPurposeCnt = GRP_PKIX_KEY_PURPOSE_CNT;

  int ActPkixOidIndex = 0;

  int ActOID_Index;
  int ActOID_Len;

  char* ObjID_Base;
  //--------------------------------------------------
  // get start and length of Object ID
  //--------------------------------------------------
  if((ObjID_Desc == NULL) || (pPkix_OidIndex == NULL))
    return(ASN1_GET_RDN_OID_ERR);

  pPkix_OidIndex[0] = -1;		// signal not recognized
  
  ObjID_Base   = ObjID_Desc->Base;
  ObjID_Offset = (int) ObjID_Desc->Off;
  ObjID_Len    = ObjID_Desc->Len;

  if((ObjID_Base == NULL) || (ObjID_Len <= 0))
    return(ASN1_GET_EXT_OID_NO_OID);
  //-----------------------------------------------
  // search the PKIX Key purpose Table for OID match
  //-----------------------------------------------
  do
  {
    ActOID_Index = PKIX_KEY_PURPOSE_OffsetTab[ActPkixOidIndex];
    ActOID_Len = (int) OID_Table[ActOID_Index+2] & 0xFF;
    i = MatchASN1ValuesByteByByte(ObjID_Base, ObjID_Offset, ObjID_Len,
        	    (char *) OID_Table, ActOID_Index+3,ActOID_Len);
    if(i == ASN1_SAME) break;				// same found
    ActPkixOidIndex++;
    PkixKeyPurposeCnt --;
  }while(PkixKeyPurposeCnt != 0);
  if(PkixKeyPurposeCnt != 0)
    pPkix_OidIndex[0] = PKIX_KEY_PURPOSE_IndexTab[ActPkixOidIndex];
  return(ASN1_OP_OK);
}

/**
* Subroutine Process_PKIX_KeyPurposeOIDs scans given list of OIDs
* (from X509 extended key usage) for PKIX key purpose OIDs, if
* recognized and in range set appropriate Flags (Process_PKIX_KeyPurposeOids).
*
*  @param pCert Certificate structure
*  @param pOidsArray Array of OIDs 
*  @param OidCount Number of OIDs
*
*  @return ASN1_OP_OK on success, error code otherwise, else Error occurred
*/
static  int Process_PKIX_KeyPurposeOids(X509CERT * pCert,
		IDATA** pOidsArray, int OidCount)
{
  char KeyPurposeID;

  int Retcode;
  int ActOidIndex = 0;
  

  int pTmpPkixIndex[1];
  IDATA* pIdata;

  while(OidCount > 0)
  {
    //-----------------------------------------------------
    // Check if OID is a recognized PKIX Key purpose OID
    //-----------------------------------------------------
    pIdata = pOidsArray[ActOidIndex++];
    if((Retcode = GetPKIX_KeyPurposeOidIndex(pIdata,
			pTmpPkixIndex)) != ASN1_OP_OK)
      return(Retcode);
    if(pTmpPkixIndex[0] >= 0)
    {
      //---------------------------------------------------
      // OID IS a PKIX key purpose ID, get last byte of OID
      //---------------------------------------------------
      KeyPurposeID =
	pIdata->Base[(int) pIdata->Off + pIdata->Len - 1];
      if((KeyPurposeID >= PKIX_KEYPURP_MIN_ID) &&
         (KeyPurposeID <= PKIX_KEYPURP_MAX_ID))
      {
        //-------------------------------------------------
        // is a valid key purpose ID, set appropriate Flags
        //-------------------------------------------------
        pCert->PkixKeyPurposeFlags |=
          (1 << (KeyPurposeID - PKIX_KEYPURP_MIN_ID));
        pCert->ExtKeyUsageFlags |=
		(int) X509_EXT_KEYUSAGE_PKIX_PRES_BIT;
      }
    }
    OidCount--;
  }
  return(ASN1_OP_OK);
}

/**
* Subroutine ProcessX509_ExtKeyUsage, process X509 extended key usage
* extension data (if any present, should be so) (ProcessX509_ExtKeyUsage).
* NOTE: Only PKIX key purpose OIDs are processed at the moment.
*      
*
*  @param pCert Certificate with Extension array
*  @return ASN1_OP_OK on success, error code otherwise, else Error occurred
*/
static  int ProcessX509_ExtKeyUsage(HMEM_CTX_DEF
				X509CERT * pCert)
{
  int Retcode;
  IDATA* pIdata;

  int pSubErrCode[1];
  int pTmpCnt[1];

  IDATPARR* pTmpDatArrayDesc[1];
  IDATPARR* OidDatArrayDesc;

  IDATA** OidDatArray = NULL;
  //--------------------------------------------------
  // Check if we have Extended Key usage data at all
  //--------------------------------------------------
  pIdata = pCert->ExtendedKeyUsage->ppArr[0];
  if((pIdata->Base == NULL) || (pIdata->Len <= 0))
    return(ASN1_OP_OK);
  //--------------------------------------------------
  // Split the extended key usage OID list sequence
  //--------------------------------------------------
  Retcode = FromASN1_OIDList(HMEM_CTX_REF1
			pIdata->Base,
			(int) pIdata->Off,
			pIdata->Len,
			pTmpDatArrayDesc,pTmpCnt,pSubErrCode);
  if(Retcode != ASN1_OP_OK)
    return(Retcode);
  OidDatArrayDesc = pTmpDatArrayDesc[0];
  //--------------------------------------------------
  // Assure that OIDs are present
  //--------------------------------------------------
  if(pTmpCnt[0] <= 0)
  {
    FreeIDATPARR_Struc(HMEM_CTX_REF1 OidDatArrayDesc);
    return(ASN1_OP_OK);
  }
  OidDatArray = OidDatArrayDesc->ppArr;
  //--------------------------------------------------
  // Process the OID List by PKIX Keypurpose routine
  //--------------------------------------------------
  Retcode = Process_PKIX_KeyPurposeOids(pCert,
			OidDatArray, pTmpCnt[0]);

  FreeIDATPARR_Struc(HMEM_CTX_REF1 OidDatArrayDesc);
  return(Retcode);
}

/**
* Subroutine ProcessCertExtensions,
* process X509 Standard extensions from a Certificate (ProcessCertExtensions).
* 1. Check if Extensions are present at all
* 2. Get Extension Critical Flag
* 3. Check if Extension is supported
*    a) yes: Process to internal
*    b)  no: - if Not Critical just ignore
*	      - if Critical, set Flag for non recognized
*
*  @param pCert Certificate to process
*               int pNotRecognCritical[] 0 - o.k., else unknown critical
*  @return 0 on success, error code otherwise
*/
static  int ProcessCertExtensions(HMEM_CTX_DEF
		X509CERT * pCert,	int* pNotRecognizedCritical)
{
  int Retcode;
  int Index = 0;
  int ExtensionsCnt;
  int CriticalFlag;
  int OIDIndex;
  int ActExtDataIndex;
  int CtlElementCnt;
  int MaxDataIndex;
  int UnknownCriticalExtFlag = 0;
  int PresenceMask;

  int pTmpVal[1];
  int pTmpLong[1];

  char * pCtlArray;

  IDATA* pIdata;
  IDATA** pExtArr;
  IDATPARR* pExtDesc;
  IDATPARR* pDstDesc;
  IDATPARR* ppTmpDesc[1];

  pNotRecognizedCritical[0] = 0;

  //----------------------------------------------------------
  // Check if extensions have to be processed
  //----------------------------------------------------------
  if(((pExtDesc = pCert->Extensions) == NULL) ||
      ((pExtArr  = pExtDesc->ppArr) == NULL) ||
      ((ExtensionsCnt = pExtDesc->Cnt/
			  X509_EXT_MAX_DATA_INDEX) <= 0))
    return(ASN1_OP_OK);
  //----------------------------------------------------------
  // Process the extensions
  //----------------------------------------------------------
  while(ExtensionsCnt != 0)
  {
    //--------------------------------------------------------
    // Check if Critical Flag is present for Extension
    //--------------------------------------------------------
//  CriticalFlag = 0;
    if((Retcode = GetOptBoolValueFromDesc(pExtDesc,
			Index + X509_EXT_CRITICAL_INDEX, 1, 0,
		  	pTmpVal)) != ASN1_OP_OK)
      return(Retcode);
    CriticalFlag = pTmpVal[0];
    //--------------------------------------------------------------
    // Compare OID to known X509 Extension (that could be processed)
    //--------------------------------------------------------------
    pIdata = pExtArr[Index + X509_EXT_OBJID_INDEX];

    if((Retcode = GetX509Ext_OidIndex(pIdata, pTmpVal)) != ASN1_OP_OK)
      return(Retcode);
    OIDIndex = pTmpVal[0];
    //-------------------------------------------------------
    // get Extension data pointer, prepare for next extension
    //-------------------------------------------------------
    ActExtDataIndex = Index + X509_EXT_VALUE_INDEX;
//    pExtValIdata = pExtArr[Index + X509_EXT_VALUE_INDEX];
    Index += X509_EXT_MAX_DATA_INDEX;
    ExtensionsCnt--;
    //-----------------------------------------------------
    // Check if Extension is recognized at all
    //-----------------------------------------------------
    if(OIDIndex < 0)			// not recognized
    {
      if(CriticalFlag != 0)		// was marked as critical !
        UnknownCriticalExtFlag = 1;	// set Flag
      continue;				// skip this extension
    }
    //-----------------------------------------------------
    // Extension has been recognized, distribute
    //-----------------------------------------------------
    switch(OIDIndex)
    {
      case OID_X509_EXT_KEY_USAGE:
        pDstDesc  = pCert->KeyUsage;	// set destination (for free)
	pCtlArray = (char *) KeyUsageExtCtl;
	CtlElementCnt = KEY_USAGE_CTL_CNT;	
	MaxDataIndex  = KEY_USAGE_MAX_DATA_INDEX;
        PresenceMask  = X509EXT_KEY_USAGE_PRES_BIT;
        break;

      case OID_X509_EXT_EXT_KEY_USAGE:
        pDstDesc  = pCert->ExtendedKeyUsage;	// set destination (for free)
	pCtlArray = (char *) ExtKeyUsageExtCtl;
	CtlElementCnt = EXT_KEY_USAGE_CTL_CNT;	
	MaxDataIndex  = EXT_KEY_USAGE_MAX_DATA_INDEX;
        PresenceMask  = X509EXT_EXT_KEYUSAGE_PRES_BIT;
        break;

      case OID_X509_EXT_BASIC_CONSTR:
        pDstDesc  = pCert->BasicConstraints;	// set destination (for free)
	pCtlArray = (char *) BasicConstraintsExtCtl;
	CtlElementCnt = BASIC_CONSTRAINTS_CTL_CNT;	
	MaxDataIndex  = BASIC_CONSTR_MAX_DATA_INDEX;
        PresenceMask  = X509EXT_BASIC_CONSTR_PRES_BIT;
        break;

      case OID_X509_EXT_NAME_CONSTR:
        pDstDesc  = pCert->NameConstraints;	// set destination (for free)
	pCtlArray = (char *) NameConstraintsExtCtl;
	CtlElementCnt = NAME_CONSTRAINTS_CTL_CNT;	
	MaxDataIndex  = NAME_CONSTRAINTS_MAX_DATA_INDEX;
        PresenceMask  = X509EXT_NAME_CONSTR_PRES_BIT;
        break;

      case OID_X509_EXT_POLICY_CONSTR:
        pDstDesc  = pCert->PolicyConstraints;	// set destination (for free)
	pCtlArray = (char *) PolicyConstraintsExtCtl;
	CtlElementCnt = POLICY_CONSTRAINTS_CTL_CNT;	
	MaxDataIndex  = POLICY_CONSTR_MAX_DATA_INDEX;
        PresenceMask  = X509EXT_POLICY_CONSTR_PRES_BIT;
        break;

      case OID_X509_EXT_AUTH_KEY_ID:
        pDstDesc  = pCert->AuthorityKeyID;	// set destination (for free)
	pCtlArray = (char *) AuthKeyIdExtCtl;
	CtlElementCnt = AUTH_KEY_ID_CTL_CNT;	
	MaxDataIndex  = AUTH_KEY_ID_MAX_DATA_INDEX;
        PresenceMask  = X509EXT_AUTH_KEYID_PRES_BIT;
        break;

      case OID_X509_EXT_SUBJ_KEY_ID:
        pDstDesc  = pCert->SubjectKeyID;	// set destination (for free)
	pCtlArray = (char *) SubjKeyIdExtCtl;
	CtlElementCnt = SUBJ_KEY_ID_CTL_CNT;	
	MaxDataIndex  = SUBJ_KEY_ID_MAX_DATA_INDEX;
        PresenceMask  = X509EXT_SUBJ_KEYID_PRES_BIT;
        break;

      case OID_X509_EXT_SUBJ_ALT_NAME:
      case OID_X509_EXT_ISSUER_ALT_NAME:
        if(OIDIndex == OID_X509_EXT_SUBJ_ALT_NAME)
        {
          pDstDesc  = pCert->SubjAltName;	// set destination (for free)
          PresenceMask  = X509EXT_SUBJ_ALTNAME_PRES_BIT;
        }
        else
        {
          pDstDesc  = pCert->IssuerAltName; // set destination (for free)
          PresenceMask  = X509EXT_ISSUER_ALTNAME_PRES_BIT;
        }
	pCtlArray = (char *) AltNameExtCtl;
	CtlElementCnt = ALT_NAME_CTL_CNT;	
	MaxDataIndex  = ALT_NAMES_MAX_DATA_INDEX;
        break;

      case OID_X509_EXT_CERT_POLICIES:
        pDstDesc  = pCert->CertPolicies;	// set destination (for free)
	pCtlArray = (char *) PoliciesExtCtl;
	CtlElementCnt = POLICIES_CONTENT_CTL_CNT;	
	MaxDataIndex  = POLICIES_CONTENT_MAX_DATA_INDEX;
        PresenceMask  = X509EXT_CERT_POLICIES_PRES_BIT;
        break;

      case OID_X509_EXT_CRL_DISTR_POINTS:
        pDstDesc  = pCert->CrlDistPoints;	// set destination (for free)
	pCtlArray = (char *) CRLDistrPointsExtCtl;
	CtlElementCnt = CRL_DIST_POINTS_CTL_CNT;	
	MaxDataIndex  = CRL_DISTR_POINTS_MAX_DATA_INDEX;
        PresenceMask  = X509EXT_CRL_DISTPOINTS_PRES_BIT;
        break;

      //-----------------------------------------------------------
      // Extensions that are not yet handled, but might be critical
      // Are ignored at the moment (HUK)
      //-----------------------------------------------------------
      case OID_PKIX_EXT_AUTH_INFO_ACCESS:
        continue;			// SKIP !!

      //--------------------------------------------------------
      // Extensions that are not yet handled, check for critical
      //--------------------------------------------------------

      case OID_X509_EXT_SUBJ_DIR_ATTS:
      case OID_X509_EXT_PRIV_KEY_USAGE:
      case OID_X509_EXT_CRL_NUMBER:
      case OID_X509_EXT_REASON_CODE:
      case OID_X509_EXT_INSTRUCTION_CODE:
      case OID_X509_EXT_INVALIDY_DATE:
      case OID_X509_EXT_DELTA_CRL_IND:
      case OID_X509_EXT_ISS_DISTR_POINT:
      case OID_X509_EXT_CERT_ISSUER:
      case OID_X509_EXT_CERT_POLICY_MAP:

      default:
        if(CriticalFlag != 0)		// was marked as critical !
          UnknownCriticalExtFlag = 1;	// set Flag
        continue;			// SKIP !!
    }
    //-----------------------------------------------------------
    // Extract, Split the Data according to parameters
    //-----------------------------------------------------------
    ppTmpDesc[0] = pDstDesc;
    if((Retcode = FromASN1_DescToDesc(HMEM_CTX_REF1
		      pExtDesc, ActExtDataIndex,
		      pCtlArray, CtlElementCnt, MaxDataIndex,
	      	      ASN1_SPLIT_X509_EXT_DATA_ERR, ppTmpDesc,
		      NULL)) != ASN1_OP_OK)
       return(Retcode);
    //------------------------------------------------------------
    // Put the new Descriptor back to the Certificate, postprocess
    //------------------------------------------------------------
    switch(OIDIndex)
    {
      //-------------------------------------------------
      // Key usage processing, get data, store
      //-------------------------------------------------
      case OID_X509_EXT_KEY_USAGE:
        pCert->KeyUsage = ppTmpDesc[0];
        pIdata = ppTmpDesc[0]->ppArr[KEY_USAGE_INDEX];
        if((Retcode = GetBit32MsbBitsFromBitstring(
			pIdata->Base, (int) pIdata->Off,
			pIdata->Len, X509_KEYUSAGE_USED_BITS,
			pTmpLong)) != ASN1_OP_OK)
          return(Retcode);
        pCert->KeyUsageFlags = pTmpLong[0] | X509_KEYUSAGE_VALID_BIT;
        if(CriticalFlag != 0)
          pCert->KeyUsageFlags |= X509_KEYUSAGE_CRITICAL_BIT;
        break;

      case OID_X509_EXT_EXT_KEY_USAGE:
        pCert->ExtendedKeyUsage = ppTmpDesc[0];
        if((Retcode = ProcessX509_ExtKeyUsage(HMEM_CTX_REF1 pCert)) !=
				ASN1_OP_OK)
          return(Retcode);

        pCert->ExtKeyUsageFlags |= X509_EXT_KEYUSAGE_VALID_BIT;
        if(CriticalFlag != 0)
          pCert->ExtKeyUsageFlags |= X509_EXT_KEYUSAGE_CRITICAL_BIT;
        break;

      //-------------------------------------------------
      // Basic constraints processing, get the data
      //-------------------------------------------------
      case OID_X509_EXT_BASIC_CONSTR:
        if(CriticalFlag != 0)
          pCert->BasicConstrCAMode = X509_BASICCONSTR_CRIT_FLAG;
        else
          pCert->BasicConstrCAMode = 0;		// is defined
        
        pCert->BasicConstraints = ppTmpDesc[0];
        if((Retcode = GetOptBoolValueFromDesc(ppTmpDesc[0], CA_FLAG_INDEX,
			1, 0, pTmpVal)) != ASN1_OP_OK)
          return(Retcode);

        if(pTmpVal[0] != 0)			// may act as CA
          pCert->BasicConstrCAMode |= X509_BASICCONSTR_CA_FLAG;

        if((Retcode = GetOptBIT32IntValueFromDesc(ppTmpDesc[0], 
			PATHLEN_CONSTR_INDEX, 1, pTmpLong,
			pTmpVal)) != ASN1_OP_OK)
          return(Retcode);
        if(pTmpVal[0] == 0)		// was not present
          pCert->BasicConstrPathLen = X509_BASICCONSTR_PATHLEN_UNDEF;
        else				// was present
          pCert->BasicConstrPathLen = pTmpLong[0]; // (non negative!)
        break;

      case OID_X509_EXT_NAME_CONSTR:
        pCert->NameConstraints = ppTmpDesc[0];
        break;

      case OID_X509_EXT_POLICY_CONSTR:
        pCert->PolicyConstraints = ppTmpDesc[0];
        break;

      case OID_X509_EXT_AUTH_KEY_ID:
        pCert->AuthorityKeyID = ppTmpDesc[0];
        break;

      case OID_X509_EXT_SUBJ_KEY_ID:
        pCert->SubjectKeyID = ppTmpDesc[0];
        break;

      case OID_X509_EXT_SUBJ_ALT_NAME:
        pCert->SubjAltName = ppTmpDesc[0];
        break;

      case OID_X509_EXT_ISSUER_ALT_NAME:
        pCert->IssuerAltName = ppTmpDesc[0];
        break;

      case OID_X509_EXT_CERT_POLICIES:
        pCert->CertPolicies = ppTmpDesc[0];
        break;

      case OID_X509_EXT_CRL_DISTR_POINTS:
        pCert->CrlDistPoints = ppTmpDesc[0];
        break;
    }
    //-----------------------------------------------------
    // Set the Extension presence bits
    //-----------------------------------------------------
    pCert->ExtPresFlags |= PresenceMask;
  }
  pNotRecognizedCritical[0] = UnknownCriticalExtFlag;
  return(ASN1_OP_OK);
}

/**
*  Subroutine m_extract_alter_name,
*  processes Subject/Issuer Alternative Name extensions from a Certificate (m_extract_alter_name).
*  <br>
*  The IDATPARR_PTR dsp_i2_alt_name_inp defines the input of this function which contains 
*  the IDATA reference to a subject/issuer alternative name part within the data of a 
*  certificate. If the variable adsp_i2_split_name_out is passed as null, the content of 
*  the INTPTR ainp_len_i2_out returns the length of required IDATA elements in the 
*  IDATPARR_PTR adsp_i2_split_name_out that must be allocated and passed as a reference 
*  when the function is called a second time to return the data. The IDATA array in the 
*  adsp_i2_split_name_out reference contains pairs of IDATA elements which refer to the object 
*  identifier plus length information in the even array elements and the data value itself 
*  in the odd array elements.
*
*  @param dsp_i2_alt_name_inp  Descriptor input array
*  @param adsp_i2_split_name_out  Address of descriptor output array
*  @param ainp_len_i2_out  Address of integer to return the number of 
*                          elements in the descriptor output array
*               
*  @return 0 on success, error code otherwise
*/
extern "C"  int m_extract_alter_name(IDATPARR* dsp_i2_alt_name_inp,
                         IDATPARR** adsp_i2_split_name_out, int* ainp_len_i2_out)
{
     int inl1;
     int inl2;
     int inl3;
     int inl4;
     int inl_len;
     int inl_obj_id;
     int inl_i2_len;
     int inl_retval;
     int inl_len_i2_out;
     int inl_len_out_av;  // available output length  
     int ainl_ret_data_len[1];
     IDATA*  dsl_i1_curr;
     IDATA** adsl_pi1_tmp;
     IDATA** adsl_pi1_out;

     //---------------------------------------------------
     // Check for correct parameters first
     //---------------------------------------------------
     if ((dsp_i2_alt_name_inp == NULL) || (ainp_len_i2_out == NULL))
        return(ASN1_X509_EXT_ALTN_NULLPT_ERR);  // -2857 : ASN1_ERROR: input null pointer
     inl_len_i2_out = 0;
     //-----------------------------------------
     // Prepare length values for the processing
     //-----------------------------------------
     inl_i2_len = dsp_i2_alt_name_inp->Cnt;  // c = count
     if (inl_i2_len <= 0)
        return(0);

     adsl_pi1_tmp = dsp_i2_alt_name_inp->ppArr;
     if (adsl_pi1_tmp == NULL)
        return(0);

     inl4 = 0;
     inl_len_out_av = 0;
     adsl_pi1_out = NULL;
     if ((adsp_i2_split_name_out != NULL) && (adsp_i2_split_name_out[0] != NULL) &&
         (adsp_i2_split_name_out[0]->Cnt > 0))
     {
       inl_len_out_av = adsp_i2_split_name_out[0]->Cnt;
       adsl_pi1_out = adsp_i2_split_name_out[0]->ppArr;
     }
     //------------------------------------------------------------------
     // Determine required output length and process output, if requested
     //------------------------------------------------------------------
     for (inl1 = 0; inl1 < inl_i2_len; inl1++)
     {
       dsl_i1_curr = adsl_pi1_tmp[inl1];
       if (dsl_i1_curr != NULL)
       {
         inl_len = dsl_i1_curr->Len;
         if (inl_len > 1)
         {
           inl2 = 0;
           do
           {
             inl4 = inl_len_i2_out;
             ainl_ret_data_len[0] = -1;
             // get name type identifier
             inl_obj_id = ((int)(dsl_i1_curr->Base[dsl_i1_curr->Off + inl2]) & 0xFF);
             inl3 = (inl_obj_id & 0x1F);
             inl2++;
             if ((inl3 < 0) || (inl3 > 0x08))
                return(ASN1_X509_EXT_ALTN_UNDEF_VALS);  // -2858 : ASN1_ERROR: undefined object identifiers
                // undefined values end the processing

             // determine the length of the data contained in the current sequence
             if ((inl_obj_id & 0x20) == 0)
             { // primitive identifiers are always processed
               inl_retval = DecodeASN1_LenField(dsl_i1_curr->Base, (dsl_i1_curr->Off + inl2), 
                                                (inl_len - inl2), ainl_ret_data_len);
             }
             else
             { // constructed identifiers are processed but require further processing
               inl_retval = GetASN1_FieldLength(dsl_i1_curr->Base, (dsl_i1_curr->Off + inl2), 
                                                (inl_len - inl2), ((unsigned char)inl_obj_id), ainl_ret_data_len);
             }
             if (inl_retval < 0)
                return(inl_retval);

             inl3 = ainl_ret_data_len[0];  // get the length of following data
             if (((inl_obj_id & 0x20) != 0) && (inl3 < 0)) 
                inl3 = (inl3 * -1);  // indefinite length is found

             if (inl4 < inl_len_out_av)
             {
               adsl_pi1_out[inl4]->Base = dsl_i1_curr->Base;
               adsl_pi1_out[inl4]->Len = (1 + inl_retval);
               adsl_pi1_out[inl4]->Off = (dsl_i1_curr->Off + inl2 - 1);
               inl4++;
             }
             inl2 += inl_retval;
             if (inl3 > 0)
             {
               if ((inl2 + inl3 <= inl_len))
               {
                 if (inl4 < inl_len_out_av)
                 {
                   adsl_pi1_out[inl4]->Base = dsl_i1_curr->Base;
                   adsl_pi1_out[inl4]->Len = inl3;
                   adsl_pi1_out[inl4]->Off = (dsl_i1_curr->Off + inl2);
                   inl4++;
                 }
                 inl_len_i2_out += 2;
               }
               inl2 += inl3; 
             }
           }
           while (inl2 < inl_len);
         }
       }
     } // end of for (inl1 = 0; inl1 < inl_i2_len; inl1++)
     //----------------------
     // Prepare return values
     //----------------------
     inl_retval = ASN1_OP_OK;  // ASN1_OP_OK
     if (adsp_i2_split_name_out == NULL)
        ainp_len_i2_out[0] = inl_len_i2_out;
     else
     {
       if (inl_len_i2_out > ainp_len_i2_out[0])
          inl_retval = ASN1_X509_EXT_ALTN_TOOLESSITM;  // -2859 : ASN1_WARNING: too less items processed !
       else
          ainp_len_i2_out[0] = inl_len_i2_out;
     }
     return(inl_retval);
   } // end of public static int m_extract_alter_name(...)

//******************************************************************
//******************************************************************
//
// Certificate Processing routines
//
//******************************************************************
//******************************************************************

extern "C"  int FromASN1CertToCertStrucEX(HMEM_CTX_DEF
		char* SrcBuf,
		int SrcOffset, int SrcLen,
		int CertType, int ProcessFlags, char* Pwd, int PwdLen,
		X509CERT ** pCertStruc)
{
  int Retcode;
  int SignatAlgor;
  int SignatType;
  int Index1;
  int Index2;
  int Len;
  int CertLen;
  int CertOffset;
  int PrivKeyFlag = 0;
  int TmpLong;

  X509CERT * pCert[1];
  X509CERT * Cert;

  char* pBuf;
  char* pCertBuf;
  char* pPrivKeyBuf = NULL;

  IDATPARR* pTmpDatArrayDesc[1];

  IDATPARR* IBMContainerDatArrayDesc = NULL;
  IDATPARR* CertStrucDatArrayDesc   	= NULL;
  IDATPARR* CertDatArrayDesc 	= NULL;
  IDATPARR* TbsDatArrayDesc 		= NULL;
  IDATPARR* ExtDatArrayDesc 		= NULL;

  IDATA** IBMContainerDatArray = NULL;
  IDATA** CertDatArray;
  IDATA** TbsDatArray;
  IDATA** ExtDatArray     = NULL;

  IDATA* pIdata;

  int pTmpDat[1];
  int pTmpDat1[1];
  int pSubErrCode[1];

  char* pTmpBase[1];
  int pTmpOff[1];
  int pTmpLen[1];
  int pTmpFlags[1];

  WLARGENUM* pLnum = NULL;
  WLARGENUM* pTmpLnum[1];

  X501_DN* pIssuerNameDesc  = NULL;
  X501_DN* pSubjectNameDesc = NULL;
  X501_DN* pTmpNameDesc[1];

  //----------------------------------------------
  // 0. Do some checks first
  //----------------------------------------------
  if((SrcBuf == NULL) || (pCertStruc == NULL))
    return(ASN1_CERT_TO_STRUC_NULL_PTR_ERR);
  pCertStruc[0] = NULL;
  if(SrcLen <= 0) return(ASN1_CERT_TO_STRUC_NO_DATA);
  //----------------------------------------------
  // 1. Allocate the structure and the Descriptors
  //----------------------------------------------
  Retcode = AllocCertStruc(HMEM_CTX_REF1 pCert);
  if(Retcode != ASN1_OP_OK) return(Retcode);
  Cert = pCert[0];

  CertLen = SrcLen;					// Assume Standard cert
  CertOffset = SrcOffset;
  pCertBuf  = SrcBuf;
  for(;;)						// Error FOR
  {
    //--------------------------------------------------------------
    // 2a. Check if an IBM Enveloped Certificate is given
    //--------------------------------------------------------------
    if((CertType == 1) || (CertType == 2) ||	// special processing
       (CertType == 3))
    {
      //------------------------------------------------------------
      // Split IBM Container
      //------------------------------------------------------------
      Retcode = FromASN1_IBMContainer(HMEM_CTX_REF1
			SrcBuf,SrcOffset,SrcLen,
			pTmpDatArrayDesc,pTmpDat, pSubErrCode);
      if(Retcode != ASN1_OP_OK)
        break;
      IBMContainerDatArrayDesc = pTmpDatArrayDesc[0];
      IBMContainerDatArray = IBMContainerDatArrayDesc->ppArr;
      //------------------------------------------------------------
      // Get the IBM Container's Flags
      //------------------------------------------------------------
      pIdata = IBMContainerDatArray[IBM_FLAGS_INDEX];	// the Flags
      Retcode = BitBuftoBIT32Flagsf(pIdata->Base,
				    (int) pIdata->Off,
				    pIdata->Len,
				    pTmpFlags);
      if(Retcode != ASN1_OP_OK)
        break;

      Cert->ContFlags = pTmpFlags[0];
      //------------------------------------------------------------
      // get Certificate base pointer according to requested type
      //------------------------------------------------------------
      pIdata = IBMContainerDatArray[IBM_SPC_CERT_DATA_INDEX];// assume with key
      PrivKeyFlag = 1;
      if((pIdata == NULL) || (pIdata->Base == NULL)) // not with key
      {
        if(CertType == 2)				// must have key !
        {
          Retcode = ASN1_CERT_TO_STRUC_NO_SRVR_CERT;
          break;
        }
        pIdata = IBMContainerDatArray[IBM_STD_CERT_DATA_INDEX];// assume no key
        if((pIdata == NULL) || (pIdata->Base == NULL)) // no Certificate
        {
          Retcode = ASN1_CERT_TO_STRUC_NO_IBM_CERT;
          break;
        }
        PrivKeyFlag = 0;
        if((ProcessFlags & 0x10) != 0)		// do Check for External Key
        {
          if((Cert->ContFlags & IBM_CONT_FLAG_EXT_PRIV_KEY) != 0)
            Cert->Flags |= PRIV_KEY_MASK;
        }
      }
      else					// private key present,
      {						// check if needed
        if(CertType == 1)			// not needed
          PrivKeyFlag = 0;
      }

      pCertBuf   = pIdata->Base;
      CertOffset = (int) pIdata->Off;
      CertLen    = pIdata->Len;
      if(pCertBuf == NULL)
      {
        Retcode = ASN1_CERT_TO_STRUC_NO_IBM_CERT;
        break;
      }
    }
    //----------------------------------------------
    // 2b. allocate a buffer for the Raw Certificate,
    //     copy to buffer and insert into Descriptor
    //----------------------------------------------
    CertStrucDatArrayDesc = Cert->Certificate;
    pIdata = CertStrucDatArrayDesc->ppArr[0];
    pBuf = BIT8_ARRAY_ALLOC(HMEM_CTX_REF,CertLen);
    if(pBuf == NULL)
    {
      Retcode = ASN1_CERT_TO_STRUC_ALLOC_ERR;
      break;
    }
//    Index1 = 0;
//    Index2 = CertOffset;
//    Len = CertLen;

    memcpy(pBuf+0,pCertBuf+CertOffset,CertLen);

//    do{pBuf[Index1++] = pCertBuf[Index2++];Len--;}while(Len != 0);

    pIdata->Base = pBuf;
    pIdata->Off  = 0;
    pIdata->Len  = CertLen;
    CertStrucDatArrayDesc->Flags |= FREE_BIT_MASK;
    //----------------------------------------------
    // 3.   Do Splitting the components
    // 3.1. Split the Certificate in TBS-Cert, SignatAlgor,
    //      SignatAlgParams and Signature
    //--------------------------------------------------
    Retcode = FromASN1_Cert(HMEM_CTX_REF1
			    pBuf,0,CertLen,
			    pTmpDatArrayDesc,pTmpDat, pSubErrCode);
    if(Retcode != ASN1_OP_OK) break;
    CertDatArrayDesc = pTmpDatArrayDesc[0];
    CertDatArray = CertDatArrayDesc->ppArr;
    //--------------------------------------------------
    // 3.2. Load components into the structure Descriptors
    // NOTE: Signature Algor/Params are verified/loaded later
    //--------------------------------------------------
    CopyIdataContents(Cert->TBS_Certificate->ppArr[0],
                      CertDatArray[X509_TBS_CERT_INDEX]);
    //--------------------------------------------------
    // 3.3.  Split TBS Certificate into Pieces
    // 3.3.1 Get Buffer base, offset and length of TBS Cert
    // 3.3.2 Split the TBS Cert
    //--------------------------------------------------
    FromDescToBuf(Cert->TBS_Certificate,0,pTmpBase,pTmpOff,pTmpLen);
    Retcode = FromASN1_TBS_Cert(HMEM_CTX_REF1
				pTmpBase[0],pTmpOff[0],pTmpLen[0],
			        pTmpDatArrayDesc,pTmpDat, pSubErrCode);
    if(Retcode != ASN1_OP_OK) break;
    TbsDatArrayDesc = pTmpDatArrayDesc[0];
    TbsDatArray = TbsDatArrayDesc->ppArr;
    //------------------------------------------------------
    // 3.3.3. Load components into the structure Descriptors
    //------------------------------------------------------
    CopyIdataContents(Cert->Version->ppArr[0],
                      TbsDatArray[X509_VERSION_INDEX]);

    CopyIdataContents(Cert->SerialNumber->ppArr[0],
                      TbsDatArray[X509_SERIAL_INDEX]);

    CopyIdataContents(Cert->NotBefore->ppArr[0],
                      TbsDatArray[X509_NOT_BEFORE_INDEX]);

    CopyIdataContents(Cert->NotAfter->ppArr[0],
                      TbsDatArray[X509_NOT_AFTER_INDEX]);

    CopyIdataContents(Cert->IssuerUniqueID->ppArr[0],
                      TbsDatArray[X509_ISSUER_UNIQUE_ID_INDEX]);

    CopyIdataContents(Cert->SubjectUniqueID->ppArr[0],
                      TbsDatArray[X509_SUBJECT_UNIQUE_ID_INDEX]);
    //------------------------------------------------------------------
    // 3.4.1 Check/Convert Certificate Version, (also allow type 0)
    //------------------------------------------------------------------
    if(Cert->Version->ppArr[0]->Base == NULL)
      Cert->VersionNumber = 0;		// none, Default
    else
    {
      pTmpLnum[0] = NULL;		// force Allocate
      Retcode = FromArrayDescElementToLnum(HMEM_CTX_REF1
				Cert->Version,0,pTmpLnum);
      if(Retcode != ASN1_OP_OK) break;
      pLnum = pTmpLnum[0];

      if(pLnum->UsedSize == 0)
        Cert->VersionNumber = 0;		// DEFAULT *IS* Present !!
      else
      {
//      Len = (int) LNUM_lpEl(pLnum)[0] & ELEMENT_MASK; // old version
        TmpLong = (int) pLnum->lpEl[0];
//      if((LNUM_UsedSize(pLnum) != 1) || (Len < 0) || (Len > 2)) // old version
        if((GetByteCntWLnum(pLnum) != 1) ||
          (TmpLong < 0) || (TmpLong > 2))
        {
          Retcode = ASN1_CERT_TO_STRUC_VERSION_ERR;
          break;
        }
        Cert->VersionNumber = (int) TmpLong;
      }
      FreeWLnum(HMEM_CTX_REF1 pLnum);
      pLnum = NULL;
    }
    //------------------------------------------------------------------
    // 3.4. Get/Check the Signature Algor and Params from Cert
    //------------------------------------------------------------------
    Retcode = GetChkSignatTypeAlg(HMEM_CTX_REF1
			CertDatArray[X509_VFY_SIGNAT_ALGOR_ID_INDEX],
			CertDatArray[X509_VFY_SIGNAT_ALGOR_PAR_INDEX],
                        pTmpDat,pTmpDat1);
    if(Retcode != ASN1_OP_OK) break;
    SignatAlgor = pTmpDat[0];
    SignatType  = pTmpDat1[0]; 
    //------------------------------------------------------------------
    // 3.5. Get/Check the Signature Algor and Params from the TBS Cert,
    //      compare if same...
    //------------------------------------------------------------------
    Retcode = GetChkSignatTypeAlg(HMEM_CTX_REF1
			TbsDatArray[X509_SIGNAT_ALGOR_ID_INDEX],
			TbsDatArray[X509_SIGNAT_ALGOR_PAR_INDEX],
                        pTmpDat,pTmpDat1);
    if(Retcode != ASN1_OP_OK) break;
    if((pTmpDat[0] != SignatAlgor) || (pTmpDat1[0] != SignatType))
    {
      Retcode = ASN1_CERT_TO_STRUC_ALG_MISMATCH;
      break;
    }
    //------------------------------------------------------------------
    // 3.6. Subdecode the Signature
    //------------------------------------------------------------------
    Retcode = SubDecodeSignature(HMEM_CTX_REF1
				 CertDatArray[X509_VFY_SIGNAT_DATA_INDEX],
				 SignatAlgor,pTmpDatArrayDesc);
    if(Retcode != ASN1_OP_OK) break;
    Cert->SignatAlgor = SignatAlgor;
    Cert->SignatType  = SignatType;

// MUST FREE, else memory leaks !!!
    FreeIDATPARR_Struc(HMEM_CTX_REF1 Cert->CertSignature);

    Cert->CertSignature      = pTmpDatArrayDesc[0];
    //------------------------------------------------------------------
    // 3.7. Subdecode/Check Public Key, Params and values
    //------------------------------------------------------------------
    CopyIdataContents(Cert->PubKeyValueOcsp->ppArr[0],
                      TbsDatArray[X509_PUBLIC_DATA_INDEX]);

    Retcode = SubDecodePubKeyInfo(HMEM_CTX_REF1
			TbsDatArray[X509_PUBLIC_ALGOR_ID_INDEX],
			TbsDatArray[X509_PUBLIC_ALGOR_PAR_INDEX],
			TbsDatArray[X509_PUBLIC_DATA_INDEX],
			pTmpDatArrayDesc, pTmpDat);
    if(Retcode != ASN1_OP_OK) break;
    Cert->SubjPubKeyParVal = pTmpDatArrayDesc[0];
    Cert->PublicKeyType      = pTmpDat[0];
    switch(Cert->PublicKeyType)
    {
      case RSA_PUBLIC_ALGOR:
        Cert->PublicKeyPurpose = PURP_KEY_EXCHG_ALGOR |
				PURP_PUBLIC_ENCR_ALGOR |
				PURP_SIGNAT_ALGOR;
        break;

      case DSA_PUBLIC_ALGOR:
        Cert->PublicKeyPurpose = PURP_SIGNAT_ALGOR; 
        break;

      case DH_PUBLIC_ALGOR:
        Cert->PublicKeyPurpose = PURP_KEY_EXCHG_ALGOR;
        break;
    }
    //------------------------------------------------------------------
    // 3.8 Subdecode Issuer RDN, sort by OBJIDs if requested
    // NOTE: Now decoded WITH Sequence header (for OCSP)
    //------------------------------------------------------------------
    FromDatArrayToBuf(TbsDatArray,X509_ISSUER_NAME_INDEX,
		      pTmpBase,pTmpOff,pTmpLen);

    // Save Raw encoding for OCSP
    pTmpDatArrayDesc[0] = Cert->IssuerNameOcsp;
    Retcode = FromBufToDesc(HMEM_CTX_REF1
			    pTmpBase[0], pTmpOff[0], pTmpLen[0],
			    0, 0, pTmpDatArrayDesc);
    if(Retcode != ASN1_OP_OK) break;

    // remove the Sequence
    Retcode = FromASN1_Sequence(HMEM_CTX_REF1
				pTmpBase[0],pTmpOff[0],pTmpLen[0],
				pTmpOff,pTmpLen);
    if(Retcode != ASN1_OP_OK) break;

    if((pTmpBase[0] != NULL) && (pTmpLen[0] != 0))
    {
      Retcode = FromASN1_DN(HMEM_CTX_REF1
			    pTmpBase[0],pTmpOff[0],pTmpLen[0],
                            pTmpNameDesc);
      if(Retcode != ASN1_OP_OK) break;
      pIssuerNameDesc = pTmpNameDesc[0];

      if((ProcessFlags & 0x01) == 0)
      {
        Retcode = SortASN1_DN(pIssuerNameDesc);
        if(Retcode != ASN1_OP_OK) break;
      }
    }
    //------------------------------------------------------------------
    // 3.9 Subdecode Subject RDN, sort by OBJIDs if requested
    // NOTE: Now decoded WITH Sequence header (for OCSP)
    //------------------------------------------------------------------
    FromDatArrayToBuf(TbsDatArray,X509_SUBJECT_NAME_INDEX,
		      pTmpBase,pTmpOff,pTmpLen);

    // Save Raw encoding for OCSP
    pTmpDatArrayDesc[0] = Cert->SubjectNameOcsp;
    Retcode = FromBufToDesc(HMEM_CTX_REF1
			    pTmpBase[0], pTmpOff[0], pTmpLen[0],
			    0, 0, pTmpDatArrayDesc);
    if(Retcode != ASN1_OP_OK) break;

    // remove the Sequence
    Retcode = FromASN1_Sequence(HMEM_CTX_REF1
				pTmpBase[0],pTmpOff[0],pTmpLen[0],
				pTmpOff,pTmpLen);
    if(Retcode != ASN1_OP_OK) break;

    if((pTmpBase[0] != NULL) && (pTmpLen[0] != 0))
    {
      Retcode = FromASN1_DN(HMEM_CTX_REF1
			    pTmpBase[0],pTmpOff[0],pTmpLen[0],
			    pTmpNameDesc);
      if(Retcode != ASN1_OP_OK) break;
      pSubjectNameDesc = pTmpNameDesc[0];

      if((ProcessFlags & 0x01) == 0)
      {
        Retcode = SortASN1_DN(pSubjectNameDesc);
        if(Retcode != ASN1_OP_OK) break;
      }
    }
    //------------------------------------------------------------------
    // 3.10. Check if selfsigned Certificate
    //------------------------------------------------------------------
    if((pIssuerNameDesc != NULL) && (pSubjectNameDesc != NULL))
    {
      Retcode = MatchX501_DNs(pIssuerNameDesc, pSubjectNameDesc,pTmpDat);
      if(Retcode != ASN1_OP_OK) break;
      if(pTmpDat[0] == ASN1_SAME) Cert->Flags |= SELF_SIGNED_MASK;
    }   
    Cert->Issuer  = pIssuerNameDesc;
    Cert->Subject = pSubjectNameDesc;
    pIssuerNameDesc  = NULL;
    pSubjectNameDesc = NULL;
    //------------------------------------------------------------------
    // 3.11. Subdecode Extensions, sort by OBJIDs
    //------------------------------------------------------------------
    FromDatArrayToBuf(TbsDatArray,X509_EXTENSION_DATA_INDEX,
		      pTmpBase,pTmpOff,pTmpLen);
    if((pTmpBase[0] != NULL) && (pTmpLen[0] != 0))
    {
      Retcode = FromASN1_EXT(HMEM_CTX_REF1
			     pTmpBase[0],pTmpOff[0],pTmpLen[0],
                             pTmpDatArrayDesc,pTmpDat, pSubErrCode);
      if(Retcode != ASN1_OP_OK) break;
      ExtDatArrayDesc = pTmpDatArrayDesc[0];
      ExtDatArray = ExtDatArrayDesc->ppArr;

      Retcode = SortExt_IDATA_Array(ExtDatArray,0,
				    ExtDatArrayDesc->Cnt);
      if(Retcode != ASN1_OP_OK) break;

      FreeIDATPARR_Struc(HMEM_CTX_REF1 Cert->Extensions);// else mem leak !!
      Cert->Extensions = ExtDatArrayDesc;
      ExtDatArrayDesc = NULL;
    }
    //------------------------------------------------------------------
    // 3.12a Get/Convert the Certificate Validity Period
    //------------------------------------------------------------------
    Retcode = GetCertTimeValidity(TbsDatArray[X509_NOT_BEFORE_INDEX],
				  TbsDatArray[X509_NOT_AFTER_INDEX],
				  Cert->pNotBeforeTimeArray,
				  Cert->pNotAfterTimeArray);
    if(Retcode != ASN1_OP_OK) break;
    //------------------------------------------------------------------
    // 3.12. Check if Certificate Validity Period is correct
    //------------------------------------------------------------------
    Retcode = ChkActCertTimeValidity(Cert,pTmpDat);
    if(Retcode != ASN1_OP_OK) break;
    Cert->DateTimeValidity = pTmpDat[0];
    if(pTmpDat[0] != ASN1_CERT_TIME_VALID)
      Cert->Flags |= INVALID_TIME_MASK;
    //------------------------------------------------------------------
    // 4. Check if a Certificate with private key was processed
    //------------------------------------------------------------------
    if((PrivKeyFlag != 0) && (IBMContainerDatArray != NULL))
    {
      //------------------------------------------------------
      // 4.1. Decrypt the private key
      //------------------------------------------------------
      pIdata = IBMContainerDatArray[IBM_PRIV_KEY_INFO_INDEX];
      if(pIdata == NULL)
      {
        Retcode = ASN1_CERT_TO_STRUC_NO_PRIVKEY;
        break;
      }
      pBuf   = pIdata->Base;
      Index1 = (int) pIdata->Off;
      Len    = pIdata->Len;
      Index2 =  DecryptPrivateKey(HMEM_CTX_REF1 pBuf,Index1,Len,Pwd,PwdLen,pTmpBase,pTmpLen,NULL,NULL);
      if(Index2 != PKCS5_OP_OK)
      {
        Retcode = ASN1_CERT_TO_STRUC_PRIVKEY_ERR;
        break;
      }
      pPrivKeyBuf = pTmpBase[0];
      //------------------------------------------------------
      // 4.2. Subdecode the PKCS-8 encoded Private key
      //      NOTE: an explizit copy of the parameters is done !
      //------------------------------------------------------
      Retcode = SubDecodeCopyPrivKeyInfo(HMEM_CTX_REF1
					 pPrivKeyBuf,0,pTmpLen[0],
				         pTmpDat,pTmpFlags,pTmpDatArrayDesc);

      ClearBit8Array(pPrivKeyBuf,0,pTmpLen[0]);	// assure cleared !!
      if(Retcode != ASN1_OP_OK)
        break;
      Cert->PrivKeyType  = pTmpDat[0];
      Cert->PrivKeyData  = pTmpDatArrayDesc[0];
      Cert->PrivKeyUsageFlags = pTmpFlags[0];
      Cert->Flags |= PRIV_KEY_MASK;
    }
    //------------------------------------------------------------------
    // 5. Process Certificate Extensions if requested
    //------------------------------------------------------------------
    if((ProcessFlags & 0x02) != 0)
    {
      if((Retcode = ProcessCertExtensions(HMEM_CTX_REF1
					  Cert,pTmpDat)) != ASN1_OP_OK)
      {
        if((ProcessFlags & 0x08) != 0)		// ignore the errors
          Retcode = ASN1_OP_OK;
        break;
      }
      if(pTmpDat[0] != 0)			// we had CRITICAL unrecognized
      {
        if((ProcessFlags & 0x04) != 0)		// ignore unknown critical
          break;
        Retcode = ASN1_CERT_TO_STRUC_UNRECOG_CRIT;
      }
    }
    break;
  } // Error FOR
  //----------------------------------------------------------
  // now we free the temporary allocated descriptors
  //----------------------------------------------------------
  FreeWLnum(HMEM_CTX_REF1 pLnum);
  FreeIDATPARR_Struc(HMEM_CTX_REF1 IBMContainerDatArrayDesc);
  FreeIDATPARR_Struc(HMEM_CTX_REF1 CertDatArrayDesc);
  FreeIDATPARR_Struc(HMEM_CTX_REF1 TbsDatArrayDesc);
  FreeX501DN_Struc(HMEM_CTX_REF1 pIssuerNameDesc);
  FreeX501DN_Struc(HMEM_CTX_REF1 pSubjectNameDesc);
  FreeIDATPARR_Struc(HMEM_CTX_REF1 ExtDatArrayDesc);
  FREE_CARRAY(HMEM_CTX_REF,pPrivKeyBuf);

  pCertStruc[0] = Cert;
  if(Retcode == ASN1_OP_OK)
    return(Retcode);

  pCertStruc[0] = NULL;
  FreeCertStruc(HMEM_CTX_REF1 Cert);
  return(Retcode);
}

extern "C"  int FromASN1CertToCertStruc(HMEM_CTX_DEF
		char* SrcBuf,
		int SrcOffset, int SrcLen,
		int CertType, int SortFlag, char* Pwd, int PwdLen,
		X509CERT ** pCertStruc)
{
  int ProcessFlags = 0;
  if(SortFlag != 0)
    ProcessFlags |= 0x01;
  return(FromASN1CertToCertStrucEX(HMEM_CTX_REF1
		SrcBuf, SrcOffset, SrcLen,
		CertType, ProcessFlags, Pwd, PwdLen, pCertStruc));
}

extern "C"  int MatchCerts(X509CERT * pCert1, X509CERT * pCert2,
				  int Mode, int* Result)
{
  int Retcode = ASN1_OP_OK;

  IDATPARR* DatArrayDesc1;
  IDATPARR* DatArrayDesc2;

  IDATA** DatArray1;
  IDATA** DatArray2;

  IDATA* pIdata1;
  IDATA* pIdata2;

  X501_DN* pNameDesc1;
  X501_DN* pNameDesc2;

  if((pCert1 == NULL) || (pCert2 == NULL) || (Result == NULL))
    return(ASN1_MATCH_CERT_NULL_PTR_ERR);

  Result[0] = ASN1_NOT_SAME;			// no match
  //-------------------------------------------
  // Check for Identity match
  //-------------------------------------------
  pNameDesc1 = pCert1->Issuer;
  pNameDesc2 = pCert2->Issuer;
  if(Mode == IDENTITY_MATCH)
  {
    DatArrayDesc1 = pCert1->Certificate;
    DatArrayDesc2 = pCert2->Certificate;

    if((DatArrayDesc1 == NULL) || (DatArrayDesc2 == NULL)) // not both present
      return(Retcode);
    DatArray1 = DatArrayDesc1->ppArr;
    DatArray2 = DatArrayDesc2->ppArr;
    if((DatArray1 == NULL) || (DatArray2 == NULL))	// not both present
      return(Retcode);

    pIdata1 = DatArray1[0];
    pIdata2 = DatArray2[0];

    Result[0] = MatchASN1ValuesByteByByte(pIdata1->Base,
                (int) pIdata1->Off, pIdata1->Len,
                pIdata2->Base,
                (int) pIdata2->Off, pIdata2->Len);

    return(Retcode);
  }
  //-------------------------------------------
  // Match Name RDNS according to mode
  //-------------------------------------------
  if(Mode == CHAIN_MATCH)				// chain matching
    pNameDesc2 = pCert2->Subject;

  if((pNameDesc1 == NULL) || (pNameDesc2 == NULL)) // not both present
    return(Retcode);

  Retcode = MatchX501_DNs(pNameDesc1, pNameDesc2, Result);

  if((Mode == CHAIN_MATCH) || (Retcode != ASN1_OP_OK)) return(Retcode);
  //-------------------------------------------
  // Match Serial numbers, if issuers are same
  //-------------------------------------------
  if(Result[0] != ASN1_SAME) return(Retcode);
  Result[0] = ASN1_NOT_SAME;		// preset not same

  DatArrayDesc1 = pCert1->SerialNumber;
  DatArrayDesc2 = pCert2->SerialNumber;
  if((DatArrayDesc1 == NULL) || (DatArrayDesc2 == NULL)) // not both present
    return(Retcode);
  DatArray1 = DatArrayDesc1->ppArr;
  DatArray2 = DatArrayDesc2->ppArr;
  if((DatArray1 == NULL) || (DatArray2 == NULL))	// not both present
    return(Retcode);

  pIdata1 = DatArray1[0];
  pIdata2 = DatArray2[0];

  Result[0] = MatchASN1ValuesByteByByte(pIdata1->Base,
              (int) pIdata1->Off, pIdata1->Len,
              pIdata2->Base,
              (int) pIdata2->Off, pIdata2->Len);

  return(Retcode);
}

extern "C"  int VerifyCertSignat(HMEM_CTX_DEF
			X509CERT * pCert,
			IDATPARR* pPubParVals, int PubAlgType,
			int* pResult)
{
  int Retcode;
  int SignatAlgor, SignatType;
  int SignatOffset, SignatLen;
  int MessageOffset, MessageLen;

  char* SignatBase;
  char* MessageBase;

  IDATA* pIdata;
  IDATA** pParValArray;

  RSA_STRUC* pRsaStruc[1];
  DSA_STRUC* pDsaStruc[1];

  int pTmpLen[1];

  //------------------------------------------------
  // Check for NULL pointers
  //------------------------------------------------
  if((pCert == NULL) || (pPubParVals == NULL) || (pResult == NULL))
    return(ASN1_NULL_PTR);

  pResult[0] = ASN1_SIGNAT_VERIFY_FAILED;	// set general fail reason
  pCert->Flags &= (~VERIFIED_SIGNAT_MASK);	// reset verified mask
  //------------------------------------------------
  // Check if Signature Algor and Public Algor match
  //------------------------------------------------
  SignatAlgor = pCert->SignatAlgor;	// get the Algor type  
  SignatType  = pCert->SignatType;		// get Signature mode
  if(PubAlgType != SignatAlgor)
  {
    pResult[0] = ASN1_SIGNAT_ALGOR_MISMATCH;	// set Fail reason
    return(ASN1_OP_OK);				// not an error...
  }

  pParValArray = pPubParVals->ppArr;

  pIdata = pCert->CertSignature->ppArr[0];
  SignatBase   = pIdata->Base;
  SignatOffset = (int) pIdata->Off;
  SignatLen    = pIdata->Len;

  pIdata = pCert->TBS_Certificate->ppArr[0];
  MessageBase   = pIdata->Base;
  MessageOffset = (int) pIdata->Off;
  MessageLen    = pIdata->Len;

  //----------------------------------------------------------------
  // Distribute according to signature Algorithm
  //----------------------------------------------------------------
  switch(SignatAlgor)
  {
    //--------------------------------------------------------------
    // Signature type RSA, check presence of parameters, verify
    //--------------------------------------------------------------
    case RSA_PUBLIC_ALGOR:
      if((pParValArray[RSA_ALG_PAR_MAX_INDEX+RSA_PUB_VAL_MOD_INDEX] == NULL) ||
         (pParValArray[RSA_ALG_PAR_MAX_INDEX+RSA_PUB_VAL_EXP_INDEX] == NULL))
      {
        pResult[0] = ASN1_SIGNAT_PARAMS_MISSING;
        return(ASN1_OP_OK);
      }

      if((Retcode = FromArrayDescToRSAPubParams(HMEM_CTX_REF1
				pPubParVals, pRsaStruc)) != ASN1_OP_OK)
        return(ASN1_VFY_CERT_RSASTRU_LOAD_ERR);

      pTmpLen[0] = SignatLen;
      Retcode = RSA_sign(HMEM_CTX_REF1 SignatType,MessageBase,MessageOffset,MessageLen,SignatBase,SignatOffset,pTmpLen,pRsaStruc[0],1);
      RSA_Free(HMEM_CTX_REF1 pRsaStruc[0]);
      if(Retcode == RSA_OP_OK)
        pResult[0] = ASN1_SIGNAT_VFY_OK;
      break;

    //--------------------------------------------------------------
    // Signature type DSA, check presence of parameters, verify
    //--------------------------------------------------------------
    case DSA_PUBLIC_ALGOR:
      if((pParValArray[DSA_ALG_PAR_P_INDEX] == NULL) ||
         (pParValArray[DSA_ALG_PAR_Q_INDEX] == NULL) ||
         (pParValArray[DSA_ALG_PAR_G_INDEX] == NULL) ||
         (pParValArray[DSA_ALG_PAR_MAX_INDEX+RSA_PUB_VAL_MOD_INDEX] == NULL))
      {
        pResult[0] = ASN1_SIGNAT_PARAMS_MISSING;
        return(ASN1_OP_OK);
      }

      Retcode = FromArrayDescToDSAPubParams(HMEM_CTX_REF1
					    pPubParVals,pDsaStruc);
      if(Retcode != ASN1_OP_OK)
        return(ASN1_VFY_CERT_DSASTRU_LOAD_ERR);

      Retcode = DSA_Verify(HMEM_CTX_REF1 MessageBase,MessageOffset,MessageLen,SignatBase,SignatOffset,SignatLen,pDsaStruc[0],0);
      DSA_Free(HMEM_CTX_REF1 pDsaStruc[0]);
      if(Retcode == DSA_OP_OK)
        pResult[0] = ASN1_SIGNAT_VFY_OK;
      break;

    default:
      pResult[0] = ASN1_SIGNAT_UNKNOWN_ALGOR;
      break;
  } // switch
  if(pResult[0] == ASN1_SIGNAT_VFY_OK)
    pCert->Flags |= VERIFIED_SIGNAT_MASK;
  return(ASN1_OP_OK);            
}
/**
* Verify signature of a certificate by a second one's
* Public values (VerifyCertSignatFromCert).
*  Needed for Chain/Tree build with multiple
* Issuers with same DNs
*
*  @param pCertToVerify Certificate to Verify
*  @param pCertForPubKey Certificate used to verify
*  @return int Status - 0 signature verified ok, else error occurred
*/
static  int VerifyCertSignatFromCert(HMEM_CTX_DEF
					    X509CERT * pCertToVerify,
					    X509CERT * pCertForPubKey)
{
  int Retcode;
  int IssuerPubKeyType;
  int pTmpResult[1];
  IDATPARR* pIssuerParValDesc;
  //---------------------------------------------------
  // Get public parameters from 2nd certificate
  //---------------------------------------------------
  pIssuerParValDesc   = pCertForPubKey->SubjPubKeyParVal;// get public values
  IssuerPubKeyType    = pCertForPubKey->PublicKeyType; // get type of key

  if((Retcode = VerifyCertSignat(HMEM_CTX_REF1
			pCertToVerify, pIssuerParValDesc,
			IssuerPubKeyType, pTmpResult)) != ASN1_OP_OK)
    return(Retcode);

  if(pTmpResult[0] != ASN1_SIGNAT_VFY_OK)	// signature mismatch
    return(1);

  return(0);					// signature matches o.k.
}

extern "C" int GetCertChainEX(HMEM_CTX_DEF
			IDATPARR* InpCertsDesc,
			int CertType, int ProcessFlags,
			char* Pwd, int PwdLen,
			X509CERT *** pCerts, int* pCertCnt)
{
  int i;
  int Retcode = ASN1_OP_OK;
  int CertCount = 0;
  int CertIndex;

  char* pTmpBase[1];
  
  int pTmpOffset[1];
  int pTmpLen[1];

  IDATA** SrcCertsDatArray;

  X509CERT ** pCertArray = NULL;
  X509CERT * pTmpCertArray[1];

  //----------------------------------------------------
  // check for NULL pointers
  //----------------------------------------------------
  if((InpCertsDesc == NULL) || (pCerts == NULL) || (pCertCnt == NULL))
    return(ASN1_GET_CERTCHAIN_NULLPTR_ERR);
  pCertCnt[0] = 0;
  pCerts[0] = NULL;

  SrcCertsDatArray = InpCertsDesc->ppArr;
  CertCount        = InpCertsDesc->Cnt;

  if(CertCount == 0) return(ASN1_GET_CERTCHAIN_NO_CERTS);
  for(;;)						// Error FOR
  {
    //----------------------------------------------------
    // Allocate Array for Certificate pointers, clear
    //----------------------------------------------------
    pCertArray = (X509CERT **)
      ((void *) BIT8_ARRAY_CALLOC(HMEM_CTX_REF,CertCount, sizeof(X509CERT *)));
    if(pCertArray == NULL)
    {
      Retcode = ASN1_GET_CERTCHAIN_ARR_ALLOCERR;
      break;
    }
    //----------------------------------------------------
    // Decode / Store the Certificates 
    //----------------------------------------------------
    i = CertCount;
    CertIndex = 0;
    do
    {
      FromDatArrayToBuf(SrcCertsDatArray,CertIndex,	// get buffer data
			pTmpBase,pTmpOffset,pTmpLen);

      Retcode = FromASN1CertToCertStrucEX(HMEM_CTX_REF1
				pTmpBase[0], pTmpOffset[0],
				pTmpLen[0],
				CertType, ProcessFlags, Pwd, PwdLen,
                		pTmpCertArray);

      if(Retcode != ASN1_OP_OK) break;
      pCertArray[CertIndex++] = pTmpCertArray[0];	// save pointer
      i --;						// reduce count
    } while(i != 0);
    break;
  } // Error FOR
  if(Retcode != ASN1_OP_OK)
  {
    if(pCertArray != NULL)			// array was allocated
    {
      i = CertCount;
      do{i--;FreeCertStruc(HMEM_CTX_REF1 pCertArray[i]);}while(i != 0);
      FREE_CARRAY(HMEM_CTX_REF,pCertArray);
    }
    return(Retcode);
  }
  pCertCnt[0] = CertCount;
  pCerts[0]   = pCertArray;
  return(Retcode);
}

/**
* Subroutine GetTreeCertType formats from Certificate
* Public Algorithm Type and Signature Type the CNode Type
* of Certificate (GetTreeCertType).
*
*  @param pCert Pointer to Cert Struct
*  @param Type returned type
*  @return int Status GEN_CERT_TREE_OP_OK o.k.
* <br>            else error occurred
*/
static  int GetTreeCertType(X509CERT * pCert, int* Type)
{
  int Retcode = ASN1_OP_OK;
  int CertType=-1;
  //-----------------------------------------------
  // Distribute according to public algorithm
  //-----------------------------------------------
  switch(pCert->PublicKeyType)	// get Public Algor
  {
    case RSA_PUBLIC_ALGOR:
      CertType = CNODE_RSA_CERT;	// RSA sign
      break;

    case DSA_PUBLIC_ALGOR:
      CertType = CNODE_DSS_CERT;	// DSS sign
      break;

    case DH_PUBLIC_ALGOR:
      if(pCert->SignatAlgor == RSA_SIGNAT_ALGOR)
      {
	CertType = CNODE_DH_RSA_CERT;
        break;
      }
      if(pCert->SignatAlgor == DSA_SIGNAT_ALGOR)
      {
        CertType = CNODE_DH_DSS_CERT;
        break;
      }
      Retcode = ASN1_GEN_CERT_TREE_INV_ALGOR;
      break;

    default:
      Retcode = ASN1_GEN_CERT_TREE_INV_ALGOR;
      break;
  }// switch
  Type[0] = CertType;
  return(Retcode);
}

extern "C" int GenCertTreeArray(HMEM_CTX_DEF
			X509CERT ** CertList,
			int TotalCertCount, int** ppCNodeArray,
			int* pRootCertCount,
			int* pRootRsaEndCount, int* pRootDssEndCount,
			int* pNonRootCertCount, int* pMaxLevel)
{
  X509CERT * pCert1;
  X509CERT * pCert2;

  int Retcode = ASN1_OP_OK;

  int Index;
  int TmpIndex;
  int Result;

  int* pCNodeArr = NULL;
  int* pCurrLvlArr = NULL;
  int* pNextLvlArr = NULL;
  int* pCurrCertsArr = NULL;
  int* pNextCertsArr = NULL;

  int	CNodeIndex = 0;
  int	CNodeCount = 0;

  int	CNodeHelpIndex = 0;

  int	LastCurrCertsCount;
  int	CurrCertsCount = 0;
  int	NextCertsCount = 0;
  
  int   RootCertCount   = 0;
  int	RootRsaEndCount = 0;
  int	RootDssEndCount = 0;

  int	CurrLvlCount = 0;
  int	NextLvlCount = 0;

  int   CNIndex;
  int	Counter;
  int	NonRootCertCount = 0;

  int	ActLevel = 0;
  int	ActCertIndex;

  int pTmpInt[1];

  int* pTmpPtr;

  int	ActCNAncestorIndex;
  //------------------------------------------------------
  // Check parameters
  //------------------------------------------------------
  if((CertList == NULL) || (ppCNodeArray == NULL) ||
     (pRootCertCount == NULL) || (pNonRootCertCount == NULL) ||
     (pMaxLevel == NULL))
    return(ASN1_GEN_CERT_TREE_NULL_PTR);

  if(TotalCertCount <= 0)
    return(ASN1_GEN_CERT_TREE_PARAM_ERR);
  pMaxLevel[0] = 0;
  //------------------------------------------------------
  // Allocate Arrays for CNodes, Tests and Levels
  //------------------------------------------------------
  pCNodeArr = INT_ARRAY_ALLOC(HMEM_CTX_REF,TotalCertCount*CNODE_SIZE); // CNODE Array

  pCurrLvlArr = INT_ARRAY_ALLOC(HMEM_CTX_REF,TotalCertCount);	// Current Level Array
  pNextLvlArr = INT_ARRAY_ALLOC(HMEM_CTX_REF,TotalCertCount);	// next Level Array

  pCurrCertsArr = INT_ARRAY_ALLOC(HMEM_CTX_REF,TotalCertCount); // current to process
  pNextCertsArr = INT_ARRAY_ALLOC(HMEM_CTX_REF,TotalCertCount); // next to process

  if((pCNodeArr == NULL) ||
     (pCurrLvlArr == NULL) || (pNextLvlArr == NULL) ||
     (pCurrCertsArr == NULL) || (pNextCertsArr == NULL))
  {  
    FREE_ARRAY(HMEM_CTX_REF,pCNodeArr);
    FREE_ARRAY(HMEM_CTX_REF,pCurrLvlArr);
    FREE_ARRAY(HMEM_CTX_REF,pNextLvlArr);
    FREE_ARRAY(HMEM_CTX_REF,pCurrCertsArr);
    FREE_ARRAY(HMEM_CTX_REF,pNextCertsArr);
    return(ASN1_GEN_CERT_TREE_ALLOC_ERR);
  }
  for(;;) // Error For
  {
    //------------------------------------------------------
    // 1. Put Root-CA Certs to the CNode Array and their CNode
    //    indices to the Current Level Array, non Root Certs
    //    indices to the Current Certs Array.
    //------------------------------------------------------
    Index = 0;
    Counter = TotalCertCount;
    CNodeHelpIndex = 0;
    do
    {
      pCNodeArr[CNodeHelpIndex+CN_JTREE_INDEX] = -1;// preset invalid
      CNodeHelpIndex+= CNODE_SIZE;

      pCert1 = CertList[Index];			// get Certificate pointer
      if((pCert1->Flags & SELF_SIGNED_MASK) != 0)	// is a ROOT CA
      {
	//-------------------------------------------------
        // process Root CA
	//-------------------------------------------------
        RootCertCount++;
        pCurrLvlArr[CurrLvlCount++] = CNodeIndex;
        pCNodeArr[CNodeIndex+CN_P_INDEX] = -1;	// no parent for root CA
        pCNodeArr[CNodeIndex+CN_S_INDEX] = -1;	// no same family elements
        pCNodeArr[CNodeIndex+CN_C_INDEX] = -1;	// no child elements yet

        pCNodeArr[CNodeIndex+CN_LEVEL] = 0;	// at base level
        pCNodeArr[CNodeIndex+CN_CERTLIST_INDEX] = Index;// Index into list
        pCNodeArr[CNodeIndex+CN_FLAGS] = (int)
          pCert1->Flags & (SELF_SIGNED_MASK | PRIV_KEY_MASK);

        if((pCert1->Flags & (PRIV_KEY_MASK)) != 0)  // with private key
        {
          if(pCert1->PublicKeyType == RSA_PUBLIC_ALGOR) // is RSA
            RootRsaEndCount++;				// usable as End-Cert
          else if(pCert1->PublicKeyType == DSA_PUBLIC_ALGOR) // is DSS
            RootDssEndCount++;				// usable as Sign-Cert
        }

        Retcode = GetTreeCertType(pCert1,pTmpInt);	// get type
        if(Retcode != ASN1_OP_OK) break;
        pCNodeArr[CNodeIndex+CN_CERT_TYPE] = pTmpInt[0]; // save
        CNodeCount++;
	CNodeIndex+= CNODE_SIZE;
      }
      else
      {
	//-------------------------------------------------
        // process non Root CA Cert
	//-------------------------------------------------
        pCurrCertsArr[CurrCertsCount++] = Index;	// save
	NonRootCertCount++;
      }
      Index++;
      Counter--;
    }while(Counter != 0);
    CurrLvlCount = RootCertCount;
    //------------------------------------------------------
    // 2. Check if at least one root is present and if other
    //    Certificates are present.
    //------------------------------------------------------
    if(Retcode != ASN1_OP_OK) break;		// error occurred
    if(RootCertCount == 0)
    {
      Retcode = ASN1_GEN_CERT_TREE_NO_ROOTS_ERR;
      break;
    }
    pMaxLevel[0] = 1;				// roots present
    if(NonRootCertCount == 0) break;		// no other Certificates
    //------------------------------------------------------
    // More certificates to be processed, search issuer of
    // Certificate Entry from the Current Level Array
    //------------------------------------------------------
    ActLevel = 0;
    for(;;)					// Level processing
    {
      LastCurrCertsCount = CurrCertsCount;	// save number of certs
      ActLevel++;
      NextLvlCount = 0;
      NextCertsCount = 0;
      do					// Current Level processing
      {
        CurrCertsCount--;				// pre decrement
        ActCertIndex = pCurrCertsArr[CurrCertsCount]; // get index into list
        pCert1 = CertList[ActCertIndex];		// get descriptor 
        Counter = CurrLvlCount;			// compare counter
        CNIndex = 0;
        do
        {
          ActCNAncestorIndex=pCurrLvlArr[CNIndex++];//get index into Node Array
          pCert2 = CertList[pCNodeArr[ActCNAncestorIndex+CN_CERTLIST_INDEX]];
          TmpIndex = MatchCerts(pCert1,pCert2,CHAIN_MATCH,pTmpInt);
          if(TmpIndex != ASN1_OP_OK)
          {
            Retcode = ASN1_GEN_CERT_TREE_MATCH_ERR;
            break;
          }
	  Result = VerifyCertSignatFromCert(HMEM_CTX_REF1 pCert1,pCert2);

          if((pTmpInt[0] == ASN1_SAME) && (Result == 0)) // found a match !
          {
            //-------------------------------------------------------
            // Ancestor found for Certificate, put Cert to CNode Array
	    // and Index to the Next Level Array
	    //-------------------------------------------------------
            pNextLvlArr[NextLvlCount++] = CNodeIndex; // put to next Level Arr.
            pCNodeArr[CNodeIndex+CN_P_INDEX] = ActCNAncestorIndex;// set parent
            pCNodeArr[CNodeIndex+CN_S_INDEX] = -1;   // no same family elements
            pCNodeArr[CNodeIndex+CN_C_INDEX] = -1;   // no child elements yet

            pCNodeArr[CNodeIndex+CN_LEVEL] = ActLevel;	// at this level
            pCNodeArr[CNodeIndex+CN_CERTLIST_INDEX] = ActCertIndex;//List Index
            pCNodeArr[CNodeIndex+CN_FLAGS] = (int)
              pCert1->Flags & PRIV_KEY_MASK;

            Retcode = GetTreeCertType(pCert1,pTmpInt);	// get type
            if(Retcode != ASN1_OP_OK) break;
            pCNodeArr[CNodeIndex+CN_CERT_TYPE] = pTmpInt[0]; // save
            //-------------------------------------------------------
            // Find the previous reference entry point for this child
	    //-------------------------------------------------------
            if(pCNodeArr[ActCNAncestorIndex+CN_C_INDEX] == -1) // no childs yet
	      pCNodeArr[ActCNAncestorIndex+CN_C_INDEX] = CNodeIndex;// set this
            else					// already childs !
            {
              TmpIndex =
                pCNodeArr[ActCNAncestorIndex+CN_C_INDEX];// start at ancestor's
							 // 1st child
              for(;;)
              {
                if(pCNodeArr[TmpIndex+CN_S_INDEX] == -1) break;// found entry
                TmpIndex = pCNodeArr[TmpIndex+CN_S_INDEX];	// to next
              }
              pCNodeArr[TmpIndex+CN_S_INDEX] = CNodeIndex;	// insert this
            }
            CNodeCount++;				// one more entry
	    CNodeIndex+= CNODE_SIZE;
            break;
          }
          Counter--;				// check if all level refs
        }while(Counter != 0);
        if(Retcode != ASN1_OP_OK) break;	// we had an error

        if(Counter == 0)			// no match found
          pNextCertsArr[NextCertsCount++] = ActCertIndex; // put to other array
      
      }while(CurrCertsCount !=0);		// for all in Current Array
      if(Retcode != ASN1_OP_OK) break;
      //-----------------------------------------------------------
      // Level processed, check if there are still Certs to process
      //-----------------------------------------------------------
      if((NextCertsCount == 0) ||		// all processed
	 (NextCertsCount == LastCurrCertsCount)) // no more match possible
      {
        if((NextCertsCount == LastCurrCertsCount) && // must reduce act. level
           (ActLevel != 0))
          ActLevel--;
        break;
      }
      //-----------------------------------------------------------
      // more Certs to process exchange counters and Arrays
      //-----------------------------------------------------------
      CurrCertsCount = NextCertsCount;		// set new count
      CurrLvlCount   = NextLvlCount;

      pTmpPtr = pCurrCertsArr;			// exchange next and current
      pCurrCertsArr = pNextCertsArr;
      pNextCertsArr = pTmpPtr; 

      pTmpPtr = pCurrLvlArr;			// dto.
      pCurrLvlArr = pNextLvlArr;
      pNextLvlArr = pTmpPtr;

      pTmpPtr = NULL;
    } // Level processing FOR
    break;
  } // Error FOR
  FREE_ARRAY(HMEM_CTX_REF,pCurrLvlArr);
  FREE_ARRAY(HMEM_CTX_REF,pNextLvlArr);
  FREE_ARRAY(HMEM_CTX_REF,pCurrCertsArr);
  FREE_ARRAY(HMEM_CTX_REF,pNextCertsArr);
  if(Retcode != ASN1_OP_OK)
  {
    FREE_ARRAY(HMEM_CTX_REF,pCNodeArr);
    return(Retcode);
  }
  ppCNodeArray[0]      = pCNodeArr;
  pRootCertCount[0]    = RootCertCount;
  pRootRsaEndCount[0]  = RootRsaEndCount;
  pRootDssEndCount[0]  = RootDssEndCount;
  pNonRootCertCount[0] = NonRootCertCount;
  if(ActLevel != 0)			// additional certs
    pMaxLevel[0] = ActLevel+1;
  return(Retcode);
}

extern "C"  void FreeCertTreeStruc(HMEM_CTX_DEF
				CTREESTR * pStruc)
{
  if(pStruc == NULL) return;
  FreeCertList(HMEM_CTX_REF1
	       pStruc->ppCertList,pStruc->CListCount);// free the list
  FREE_ARRAY(HMEM_CTX_REF,pStruc->CNodeArray);
  FREE_ARRAY(HMEM_CTX_REF,pStruc->RootCaIndexArray);
  FREE_ARRAY(HMEM_CTX_REF,pStruc->RootEndRsaIndexArray);
  FREE_ARRAY(HMEM_CTX_REF,pStruc->RootEndDssIndexArray);
  FREE_ARRAY(HMEM_CTX_REF,pStruc->SubCaIndexArray);
  FREE_ARRAY(HMEM_CTX_REF,pStruc->EndRsaIndexArray);
  FREE_ARRAY(HMEM_CTX_REF,pStruc->EndDssIndexArray);
  FREE_ARRAY(HMEM_CTX_REF,pStruc->EndDhRsaIndexArray);
  FREE_ARRAY(HMEM_CTX_REF,pStruc->EndDhDssIndexArray);
  FREE_ARRAY(HMEM_CTX_REF,pStruc);
}
/**
* Subroutine AllocCertTreeStruc allocates and initializes
* the Certificate Tree Structure (without CertList and CNode Arrays) (AllocCertTreeStruc).
*
*  @param RootCertCnt root certs
*  @param RootRsaEndCnt root RSA End Certs
*  @param RootDssEndCnt root DSS End Certs
*  @param SubCaCertCnt Sub CA certs
*  @param EndRsaCertCnt RSA sign End certs
*  @param EndDssCertCnt DSS sign End certs
*  @param EndDhRsaCertCnt DH-RSA End Certs
*  @param EndDhDssCertCnt DH-DSS End Certs
*  @param pCTreeStruc allocated structure
*  @return ASN1_OP_OK on success, error code otherwise
* <br>            else error occurred
*/
static  int AllocCertTreeStruc(HMEM_CTX_DEF
			int RootCertCnt, int RootRsaEndCnt, int RootDssEndCnt,
			int SubCaCertCnt,
			int EndRsaCertCnt, int EndDssCertCnt,
			int EndDhRsaCertCnt, int EndDhDssCertCnt,
			CTREESTR ** pCTreeStruc)
{
  int Retcode;

  CTREESTR * pStruc;

  int* pBuf;
  //---------------------------------------------------
  // Check parameters
  //---------------------------------------------------
  if(pCTreeStruc == NULL)
    return(ASN1_GEN_CERT_TREE_NULL_PTR);
  pCTreeStruc[0] = NULL;
  //---------------------------------------------------
  // Allocate the Array itself, clear / initialize
  //---------------------------------------------------
  Retcode = ASN1_GEN_CERT_TREE_ALLOC_ERR;
  pStruc = (CTREESTR *)
    ((void *) BIT8_ARRAY_CALLOC(HMEM_CTX_REF,
				1,sizeof(CTREESTR)));
  if(pStruc == NULL)
    return(Retcode);

  pStruc->RootCaCount       = RootCertCnt;
  pStruc->RootEndRsaCount = RootRsaEndCnt;
  pStruc->RootEndDssCount = RootDssEndCnt;
  pStruc->SubCaCount      = SubCaCertCnt;
  pStruc->EndRsaCount     = EndRsaCertCnt;
  pStruc->EndDssCount     = EndDssCertCnt;
  pStruc->EndDhRsaCount   = EndDhRsaCertCnt;
  pStruc->EndDhDssCount = EndDhDssCertCnt;

  for(;;) // Error FOR
  {
    //---------------------------------------------------
    // Allocate the Elements
    //---------------------------------------------------
    if(RootCertCnt != 0)
    {
      pStruc->RootCaIndexArray = pBuf = INT_ARRAY_ALLOC(HMEM_CTX_REF,RootCertCnt);
      if(pBuf == NULL) break;
    }
    if(RootRsaEndCnt != 0)
    {
      pStruc->RootEndRsaIndexArray = pBuf = INT_ARRAY_ALLOC(HMEM_CTX_REF,RootRsaEndCnt);
      if(pBuf == NULL) break;
    }
    if(RootDssEndCnt != 0)
    {
      pStruc->RootEndDssIndexArray = pBuf = INT_ARRAY_ALLOC(HMEM_CTX_REF,RootDssEndCnt);
      if(pBuf == NULL) break;
    }
    if(SubCaCertCnt != 0)
    {
      pStruc->SubCaIndexArray = pBuf = INT_ARRAY_ALLOC(HMEM_CTX_REF,SubCaCertCnt);
      if(pBuf == NULL) break;
    }
    if(EndRsaCertCnt != 0)
    {
      pStruc->EndRsaIndexArray = pBuf = INT_ARRAY_ALLOC(HMEM_CTX_REF,EndRsaCertCnt);
      if(pBuf == NULL) break;
    }
    if(EndDssCertCnt != 0)
    {
      pStruc->EndDssIndexArray = pBuf = INT_ARRAY_ALLOC(HMEM_CTX_REF,EndDssCertCnt);
      if(pBuf == NULL) break;
    }
    if(EndDhRsaCertCnt != 0)
    {
      pStruc->EndDhRsaIndexArray = pBuf = INT_ARRAY_ALLOC(HMEM_CTX_REF,EndDhRsaCertCnt);
      if(pBuf == NULL) break;
    }
    if(EndDhDssCertCnt != 0)
    {
      pStruc->EndDhDssIndexArray = pBuf = INT_ARRAY_ALLOC(HMEM_CTX_REF,EndDhDssCertCnt);
      if(pBuf == NULL) break;
    }
    Retcode = ASN1_OP_OK;
    break;
  } // Error FOR
  if(Retcode == ASN1_OP_OK)
  {
    pCTreeStruc[0] = pStruc;
  }
  return(Retcode);
}

extern "C" int GenCertNodeAndIndexTabs(HMEM_CTX_DEF
			X509CERT ** CertList,
			int TotalCertCount, int,
			CTREESTR ** ppTreeStruc)
{
  int Retcode;

  int Index;
  int Index1;
  int Index2;

  int RootCertCount;
  int RootRsaEndCount;
  int RootDssEndCount;
  int NonRootCertCount;
  int TreeLevel;
  int Counter;

  int SubCaCnt = 0;
  int EndRsaCnt = 0;
  int EndDssCnt = 0;
  int EndDhRsaCnt = 0;
  int EndDhDssCnt = 0;

  int ActSubCaIndex    = 0;
  int ActEndRsaIndex   = 0;
  int ActEndDssIndex   = 0;
  int ActEndDhRsaIndex = 0;
  int ActEndDhDssIndex = 0;

  int CNRootIndex;
  int CNIndex;

  int Flags;
  int CertType;

  int* pCNodeArr = NULL;
  int* pRootArr;
  int* pRootRsaEndArr;
  int* pRootDssEndArr;
  int* pSubCaArr;
  int* pEndRsaArr;
  int* pEndDssArr;
  int* pEndDhRsaArr;
  int* pEndDhDssArr;

  int* ppTmpArr[1];
  int pTmpCnt1[1];
  int pTmpCnt2[1];
  int pTmpCnt3[1];
  int pTmpCnt4[1];
  int pTmpCnt5[1];

  CTREESTR * pTreeStruc;
  CTREESTR * pTmpStruc[1];
  
  if(ppTreeStruc == NULL)
    return(ASN1_GEN_CERT_TREE_NULL_PTR);
  //-------------------------------------------------
  // Generate the CNode Array
  //-------------------------------------------------
  Retcode = GenCertTreeArray(HMEM_CTX_REF1
			CertList, TotalCertCount, ppTmpArr,
			pTmpCnt1, pTmpCnt2, pTmpCnt3, pTmpCnt4, pTmpCnt5);
  if(Retcode != ASN1_OP_OK) return(Retcode);

  pCNodeArr = ppTmpArr[0];
  RootCertCount    = pTmpCnt1[0];
  RootRsaEndCount  = pTmpCnt2[0];
  RootDssEndCount  = pTmpCnt3[0];
  NonRootCertCount = pTmpCnt4[0];
  TreeLevel = pTmpCnt5[0];
  //------------------------------------------------------------
  // Check if this is a server; if so at least 1 endcert or
  // a root certificate with private key is needed
  // --> moved that checking to HSSLPROT
  //------------------------------------------------------------
  if(NonRootCertCount == 0)
  {

    //-----------------------------------------------------------------
    // Allocate the Tree Structure, generate only the Root Index Arrays
    //-----------------------------------------------------------------
    Retcode = AllocCertTreeStruc(HMEM_CTX_REF1
				 RootCertCount,RootRsaEndCount,RootDssEndCount,
				 0,0,0,0,0,pTmpStruc);
    if(Retcode != ASN1_OP_OK)
    {
      FREE_ARRAY(HMEM_CTX_REF,pCNodeArr);
      return(Retcode);
    }
    pTreeStruc = pTmpStruc[0];
    pTreeStruc->ppCertList   = CertList;		// set the list
    pTreeStruc->CListCount   = TotalCertCount;	// set size
    pTreeStruc->CNodeArray   = pCNodeArr;		// set the node array
    pTreeStruc->CNodeCount   = TotalCertCount;	// set size
    pTreeStruc->CTreeDepth = TreeLevel;		// set depth of tree
    Index = 0;
    Index1 = 0;
    Index2 = 0;
    CNIndex = 0;
    Counter = RootCertCount;
    pRootArr = pTreeStruc->RootCaIndexArray; 
    pRootRsaEndArr = pTreeStruc->RootEndRsaIndexArray;
    pRootDssEndArr = pTreeStruc->RootEndDssIndexArray;
    do
    {    
      pRootArr[Index++] = CNIndex;
      if((pCNodeArr[CNIndex + CN_FLAGS] & PRIV_KEY_MASK) != 0) // has private
      {
        if(pCNodeArr[CNIndex + CN_CERT_TYPE] == CNODE_RSA_CERT) // is RSA
           pRootRsaEndArr[Index1++] = CNIndex;

        else if(pCNodeArr[CNIndex + CN_CERT_TYPE] == CNODE_DSS_CERT) // is DSS
           pRootDssEndArr[Index2++] = CNIndex;
      }

      CNIndex+=CNODE_SIZE;
      Counter--;
    }while(Counter != 0);
    ppTreeStruc[0] = pTreeStruc;
    return(Retcode);    
  }
  //------------------------------------------------------------
  // Count the SubCA Certs and EndCerts starting at the roots
  //------------------------------------------------------------
  CNRootIndex = 0;
  Counter = RootCertCount;
  do
  {
    CNIndex = pCNodeArr[CNRootIndex+CN_C_INDEX];// index to 1st. child
    if(CNIndex != -1)				// subelements present
    {
      for(;;)
      {
        if(pCNodeArr[CNIndex+CN_C_INDEX] == -1)		// found End-Node
        {
	  //---------------------------------------------------
	  // Get Flags and Cert Type of Endnode
	  //---------------------------------------------------
          Flags    = pCNodeArr[CNIndex+CN_FLAGS];	// get Flags
          CertType = pCNodeArr[CNIndex+CN_CERT_TYPE];	// get type 
          switch(CertType)
          {
            case CNODE_RSA_CERT:
	    case CNODE_DSS_CERT:
//	      if(((Flags & PRIV_KEY_MASK) == 0) &&	// no private key
//               (Entity == SERVER_CERT_LIST))		// but for server
	      if((Flags & PRIV_KEY_MASK) == 0)		// no private key
              {
                SubCaCnt++;
		break;
              }
              if(CertType == CNODE_RSA_CERT)
		EndRsaCnt++;
	      else
                EndDssCnt++;
              break;

	    case CNODE_DH_RSA_CERT:
            case CNODE_DH_DSS_CERT:
              if((Flags & PRIV_KEY_MASK) == 0) break;	// ignore
              if(CertType == CNODE_DH_RSA_CERT)
  	        EndDhRsaCnt++;
	      else              
	        EndDhDssCnt++;
	      break;              

          } // switch
	  //---------------------------------------------------
	  // Endnode processed (no childs) walk horizontal/down
	  //---------------------------------------------------
          for(;;)
          {
            if(pCNodeArr[CNIndex+CN_S_INDEX] != -1)	// more in same level
	    {
              CNIndex = pCNodeArr[CNIndex+CN_S_INDEX];	// get next to check
              break;
            }
            CNIndex = pCNodeArr[CNIndex+CN_P_INDEX];	// get parent
	    if(CNIndex == -1) break;			// at root, stop
          }
          if(CNIndex == -1) break;			// all in root process.
        } // Endnode
	else
        {
          SubCaCnt++;					// right position ??
	  //-------------------------------------------
	  // Child found, not End node walk up the tree
	  //-------------------------------------------
          CNIndex = pCNodeArr[CNIndex+CN_C_INDEX];
        }
      } // inner FOR loop
    } // subelements present
    CNRootIndex += CNODE_SIZE;
    Counter--;
  }while(Counter != 0);
  //------------------------------------------------------------
  // Check if this is a server; if so at least 1 endcert is needed
  // Note: moved that to HSSLPROT
  //------------------------------------------------------------

  //----------------------------------------------------------
  // Allocate the Structure incl. Cert-List and node array
  //----------------------------------------------------------
  Retcode = AllocCertTreeStruc(HMEM_CTX_REF1
			       RootCertCount,RootRsaEndCount,RootDssEndCount,
			       SubCaCnt,EndRsaCnt,EndDssCnt,
			       EndDhRsaCnt,EndDhDssCnt,pTmpStruc);
  if(Retcode != ASN1_OP_OK)
  {
    FREE_ARRAY(HMEM_CTX_REF,pCNodeArr);
    return(Retcode);
  }
  pTreeStruc = pTmpStruc[0];
  pTreeStruc->ppCertList   = CertList;		// set the list
  pTreeStruc->CListCount   = TotalCertCount;	// set size
  pTreeStruc->CNodeArray   = pCNodeArr;		// set the node array
  pTreeStruc->CNodeCount   = TotalCertCount;	// set size
  pTreeStruc->CTreeDepth = TreeLevel;		// set depth of tree

  pRootArr       = pTreeStruc->RootCaIndexArray;
  pRootRsaEndArr = pTreeStruc->RootEndRsaIndexArray;
  pRootDssEndArr = pTreeStruc->RootEndDssIndexArray;
  pSubCaArr      = pTreeStruc->SubCaIndexArray;
  pEndRsaArr     = pTreeStruc->EndRsaIndexArray;
  pEndDssArr     = pTreeStruc->EndDssIndexArray;
  pEndDhRsaArr   = pTreeStruc->EndDhRsaIndexArray;
  pEndDhDssArr   = pTreeStruc->EndDhDssIndexArray;
  //----------------------------------------------------------
  // Generate the Root and RootRsaEnd Index Arrays
  //----------------------------------------------------------
  Index = 0;
  Index1 = 0;
  Index2 = 0;
  CNIndex = 0;
  Counter = RootCertCount;
  pRootArr = pTreeStruc->RootCaIndexArray; 
  do
  {    
    pRootArr[Index++] = CNIndex;
    if((pCNodeArr[CNIndex + CN_FLAGS] & PRIV_KEY_MASK) != 0) // with Priv. Key
    {
      if(pCNodeArr[CNIndex + CN_CERT_TYPE] == CNODE_RSA_CERT) // is RSA
        pRootRsaEndArr[Index1++] = CNIndex;
      else if(pCNodeArr[CNIndex + CN_CERT_TYPE] == CNODE_DSS_CERT) // is DSS
        pRootDssEndArr[Index2++] = CNIndex;
    }

    CNIndex+=CNODE_SIZE;
    Counter--;
  }while(Counter != 0);
  //--------------------------------------------------------------------
  // Generate the SubCA and EndCerts index arrays, starting at the roots
  //--------------------------------------------------------------------
  CNRootIndex = 0;
  Counter = RootCertCount;
  do
  {
    CNIndex = pCNodeArr[CNRootIndex+CN_C_INDEX];// index to 1st. child
    if(CNIndex != -1)				// subelements present
    {
      for(;;)
      {
        if(pCNodeArr[CNIndex+CN_C_INDEX] == -1)	// found End-Node
        {
	  //---------------------------------------------------
	  // Get Flags and Cert Type of Endnode
	  //---------------------------------------------------
          Flags    = pCNodeArr[CNIndex+CN_FLAGS];	// get Flags
          CertType = pCNodeArr[CNIndex+CN_CERT_TYPE];	// get type 
          switch(CertType)
          {
            case CNODE_RSA_CERT:
	    case CNODE_DSS_CERT:
//	      if(((Flags & PRIV_KEY_MASK) == 0) &&	// no private key
//                (Entity == SERVER_CERT_LIST))		// but for server
	      if((Flags & PRIV_KEY_MASK) == 0)		// no private key
              {
		pSubCaArr[ActSubCaIndex++] = CNIndex;	// save index
		break;
              }
              if(CertType == CNODE_RSA_CERT)
		pEndRsaArr[ActEndRsaIndex++] = CNIndex;
	      else
                pEndDssArr[ActEndDssIndex++] = CNIndex;
              break;

	    case CNODE_DH_RSA_CERT:
	    case CNODE_DH_DSS_CERT:
              if((Flags & PRIV_KEY_MASK) == 0) break;	// ignore
              if(CertType == CNODE_DH_RSA_CERT)
	        pEndDhRsaArr[ActEndDhRsaIndex++] = CNIndex;
	      else              
	        pEndDhDssArr[ActEndDhDssIndex++] = CNIndex;
	      break;              

          } // switch
	  //---------------------------------------------------
	  // Endnode processed (no childs) walk horizontal/down
	  //---------------------------------------------------
          for(;;)
          {
            if(pCNodeArr[CNIndex+CN_S_INDEX] != -1)	// more in same level
	    {
              CNIndex = pCNodeArr[CNIndex+CN_S_INDEX];	// get next to check
              break;
            }
            CNIndex = pCNodeArr[CNIndex+CN_P_INDEX];	// get parent
	    if(CNIndex == -1) break;			// at root, stop
          }
          if(CNIndex == -1) break;			// all in root process.
        } // Endnode
	else
        {
          pSubCaArr[ActSubCaIndex++] = CNIndex;	// save index ??
	  //-------------------------------------------
	  // Child found, not End node walk up the tree
	  //-------------------------------------------
          CNIndex = pCNodeArr[CNIndex+CN_C_INDEX];
        }
      } // inner FOR loop
    } // subelements present
    CNRootIndex += CNODE_SIZE;
    Counter--;
  }while(Counter != 0);
  ppTreeStruc[0] = pTreeStruc;
  return(Retcode);
}

extern "C"  int GenTreeFromASN1DatArrayDescEX(HMEM_CTX_DEF
			IDATPARR* pCertsDatArrayDesc,
			int CertType, int ProcessFlags, int ReqEntity,
			char* pPwdBuf, int PwdLen,
			CTREESTR ** ppTreeStruc)
{
  int Retcode;
  int CertCount;

  X509CERT ** pCertList = NULL;
  X509CERT ** pTmpCertList[1];

  int pTmpCnt[1];
  //---------------------------------------------------------
  // Convert the ASN1 Entries to certificate List, RDN sorted
  //---------------------------------------------------------
  if(CertType == 2)
    CertType++;				// include also certs w/o priv key !
  Retcode = GetCertChainEX(HMEM_CTX_REF1
			   pCertsDatArrayDesc, CertType, ProcessFlags,
			   pPwdBuf, PwdLen, pTmpCertList,pTmpCnt);
  if(Retcode != ASN1_OP_OK) return(Retcode);
  pCertList = pTmpCertList[0];
  CertCount = pTmpCnt[0];
  //--------------------------------------------------------------
  // Generate the node and index Arrays for ROOTS, SUB-CAs,
  // and Endcertificates. 
  //-------------------------------------------------------------
  Retcode = GenCertNodeAndIndexTabs(HMEM_CTX_REF1
			pCertList,CertCount,ReqEntity,ppTreeStruc);
  if(Retcode != ASN1_OP_OK)
  {
    FreeCertList(HMEM_CTX_REF1
		 pCertList,CertCount);
  }
  return(Retcode);
}

extern "C"  int GenTreeFromASN1DatArrayDesc(HMEM_CTX_DEF
			IDATPARR* pCertsDatArrayDesc,
			int CertType, int SortFlag, int ReqEntity,
			char* pPwdBuf, int PwdLen,
			CTREESTR ** ppTreeStruc)
{
  int ProcessFlags = 0;
  if(SortFlag != 0)
    ProcessFlags |= 0x01;
  return(GenTreeFromASN1DatArrayDescEX(HMEM_CTX_REF1
		pCertsDatArrayDesc, CertType,
		ProcessFlags, ReqEntity, pPwdBuf, PwdLen, ppTreeStruc));
}

extern "C"  int CheckTrustedRootCert(X509CERT * pCert,
			CTREESTR * pTreeStruc,
			int* pResult, int* pCNIndex)
{
  int CertCount;
  int CertIndex;
  int Result;
  int ActCNIndex;
  int ActRootIndex;

  IDATA* CertSignatIdata;
  IDATA* CertCertIdata;
  IDATA* ActRootCertIdata;

  X509CERT * ActRootCert;
  //----------------------------------------------------
  // check for NULL pointers, and if root cert count != 0
  //----------------------------------------------------
  if((pCert == NULL) || (pTreeStruc == NULL) ||
     (pResult ==NULL) || (pCNIndex == NULL))
    return(ASN1_CHK_TRUST_ROOT_NULLPTR_ERR);

  pResult[0] = ASN1_NOT_TRUSTED_ROOT;
  pCNIndex[0] = -1;

  CertCount = pTreeStruc->RootCaCount;	// get number of roots
  if(CertCount <= 0)
    return(ASN1_CHK_TRUST_ROOT_NO_CERTS);
  //------------------------------------------------------
  // Search for same Signatures, do compare
  //------------------------------------------------------
  CertSignatIdata = pCert->CertSignature->ppArr[0]; // Signature pointer
  CertCertIdata = pCert->Certificate->ppArr[0]; // certificate self

  CertIndex = 0;
  do  
  {
    ActCNIndex = pTreeStruc->RootCaIndexArray[CertIndex]; // get index into 
							// CNode Array
    ActRootIndex =					// get index into list
       pTreeStruc->CNodeArray[ActCNIndex+CN_CERTLIST_INDEX];

    ActRootCert = pTreeStruc->ppCertList[ActRootIndex];
							// get pointer to cert
    ActRootCertIdata = ActRootCert->CertSignature->ppArr[0];
    Result = MatchASN1ValuesByteByByte(CertSignatIdata->Base,
                 (int) CertSignatIdata->Off, CertSignatIdata->Len,
                 ActRootCertIdata->Base,(int)ActRootCertIdata->Off,
	         ActRootCertIdata->Len);

    if(Result == ASN1_SAME)
    {
      //------------------------------------------------------
      // Same Signatures, compare in total
      //------------------------------------------------------
      ActRootCertIdata = ActRootCert->Certificate->ppArr[0];
      Result = MatchASN1ValuesByteByByte(CertCertIdata->Base,
                 (int)CertCertIdata->Off, CertCertIdata->Len,
                 ActRootCertIdata->Base,(int)ActRootCertIdata->Off,
	         ActRootCertIdata->Len);

      if(Result == ASN1_SAME)			// found it !
      {
        pResult[0] = ASN1_TRUSTED_ROOT;		// set Result
	pCNIndex[0] = ActCNIndex;		// set index to root
        return(ASN1_OP_OK);
      }
    }
    CertIndex++;
    CertCount--;
  }
  while(CertCount != 0);
  return(ASN1_OP_OK);
}

/**
* Subroutine GetTreeAnchorForCert searches the tree to find an
* anchor for a given certificate in the given tree (GetTreeAnchorForCert). 
* Search for
* match is done by the issuer of the given certificate.
* First the roots are checked, then the SubCAs.
*
*  @param pCert Certificate structure
*               CTREE_PTR pCertTree Cert Tree struc. array
*  @param pCNIndex result of search:
*               < 0 not found
*               >= 0 CNode index
*
*  @return ASN1_OP_OK on success, error code otherwise
* <br>            - else Error occurred
*/
static  int GetTreeAnchorForCert(HMEM_CTX_DEF X509CERT * pCert,
			CTREESTR * pTreeStruc, int* pCNIndex)
{
  int CertIndex;
  int Retcode;
  int Result;
  int RootCertCount;
  int SubCACertCount;
  int ActCNIndex;
  int ActRootIndex;
  int ActSubCAIndex;

  int pTmpResult[1];

  X509CERT * ActRootCert;
  X509CERT * ActSubCACert;
  //----------------------------------------------------
  // check for NULL pointers, and if root cert count != 0
  //----------------------------------------------------
  if((pCert == NULL) || (pTreeStruc == NULL) || (pCNIndex == NULL))
    return(ASN1_GET_TRUST_ROOT_NULLPTR_ERR);
  pCNIndex[0] = -1;

  //------------------------------------------------------
  // Search for Root subject to cert issuer match
  //------------------------------------------------------
  CertIndex = 0;
  RootCertCount = pTreeStruc->RootCaCount;	// get number of roots
  while(RootCertCount > 0)
  {
    ActCNIndex = pTreeStruc->RootCaIndexArray[CertIndex]; // get index into 
							// CNode Array
    ActRootIndex =					// get index into list
       pTreeStruc->CNodeArray[ActCNIndex+CN_CERTLIST_INDEX];

    ActRootCert = pTreeStruc->ppCertList[ActRootIndex];
							// get pointer to cert

    if((Retcode = MatchCerts(pCert, ActRootCert, CHAIN_MATCH,
			     pTmpResult)) != ASN1_OP_OK)
      return(Retcode);

    Result = VerifyCertSignatFromCert(HMEM_CTX_REF1 pCert,ActRootCert); // check signature

    if((pTmpResult[0] == ASN1_SAME) && (Result == 0))
    {
      pCNIndex[0] = ActCNIndex;
      return(Retcode);
    }
    CertIndex++;
    RootCertCount--;
  }
  //------------------------------------------------------
  // Search for SubCA subject to cert issuer match
  //------------------------------------------------------
  CertIndex = 0;
  SubCACertCount = pTreeStruc->SubCaCount;	// get number of SubCAs
  while(SubCACertCount > 0)
  {
    ActCNIndex = pTreeStruc->SubCaIndexArray[CertIndex]; // get index into 
							// CNode Array
    ActSubCAIndex =					// get index into list
       pTreeStruc->CNodeArray[ActCNIndex+CN_CERTLIST_INDEX];

    ActSubCACert = pTreeStruc->ppCertList[ActSubCAIndex];
							// get pointer to cert

    if((Retcode = MatchCerts(pCert, ActSubCACert, CHAIN_MATCH,
			     pTmpResult)) != ASN1_OP_OK)
      return(Retcode);

    Result = VerifyCertSignatFromCert(HMEM_CTX_REF1 pCert,ActSubCACert);

    if((pTmpResult[0] == ASN1_SAME) && (Result == 0))
    {
      pCNIndex[0] = ActCNIndex;
      return(Retcode);
    }
    CertIndex++;
    SubCACertCount--;
  }
  return(ASN1_OP_OK);	// none found...
}

extern "C"  int GetCertDateTimeValidity(X509CERT * pCert, int* pResult)
{
  return(ChkActCertTimeValidity(pCert, pResult));
}

extern "C"  int CompleteCertChain(HMEM_CTX_DEF
			X509CERT ** pCertChain, int CertCount,
			CTREESTR * pCertTree, int* pCNIndex,
			X509CERT *** ppNewCertChain, int* pNewCertCount)
{
  int Retcode;
  int AddCount;
  int ActCNIndex;
  int LastCNIndex;
  int ActCertIndex;
  int NewCertCount;

  int* pCNArray;

  int pTmpCNIndex[1];

  X509CERT * pActCert;
  X509CERT ** pCertList = NULL;
  X509CERT ** pNewCertChain = NULL;

  //----------------------------------------------------
  // check parameters first
  //----------------------------------------------------
  if((pCertChain == NULL) || (pCertTree == NULL) || (pCNIndex == NULL) ||
     (ppNewCertChain == NULL) || (pNewCertCount == NULL))
    return(ASN1_COMPLETE_CHAIN_NULLPTR_ERR);

  pCNIndex[0] = -1;
  ppNewCertChain[0] = NULL;
  pNewCertCount[0]  = 0;

  if(CertCount <= 0)
    return(ASN1_COMPLETE_CHAIN_NO_CERTS);

  //-----------------------------------------------------------
  // Find a completion anchor in the Tree for the Top most Cert
  //-----------------------------------------------------------
  pActCert = pCertChain[CertCount-1];		// get the certificate
  if((Retcode = GetTreeAnchorForCert(HMEM_CTX_REF1 pActCert, pCertTree,
                                     pTmpCNIndex)) != ASN1_OP_OK)
    return(Retcode);
  
  if((ActCNIndex = pTmpCNIndex[0]) < 0)		// no anchor found...
    return(ASN1_OP_OK);
  LastCNIndex = ActCNIndex;		// initialize
  //---------------------------------------------------------------
  // Get number of elements needed down to root, allocate new List
  //---------------------------------------------------------------
  pCNArray = pCertTree->CNodeArray;
  AddCount = pCNArray[ActCNIndex + CN_LEVEL]+1;		// get level+ base
  pCertList = pCertTree->ppCertList;		// get list

  NewCertCount = CertCount + AddCount;

  pNewCertChain = (X509CERT **)
    ((void *) BIT8_ARRAY_ALLOC(HMEM_CTX_REF,
				(NewCertCount*sizeof(X509CERT *))));
  if(pNewCertChain == NULL)
    return(ASN1_ALLOC_ERR);
  //-------------------------------------------------------
  // Put the Certificates from the given chain to new array
  //-------------------------------------------------------
  memcpy(pNewCertChain,pCertChain,CertCount*sizeof(X509CERT *));
  //-------------------------------------------------------
  // Append the certificates from the tree now
  //-------------------------------------------------------
  while(AddCount > 0)
  {
    LastCNIndex = ActCNIndex;

    ActCertIndex =					// get index into list
       pCNArray[ActCNIndex+CN_CERTLIST_INDEX];

    pActCert = pCertList[ActCertIndex];			// get pointer to cert
    pNewCertChain[CertCount++] = pActCert;

    ActCNIndex = pCNArray[LastCNIndex+CN_P_INDEX];	// Index of next
    if(ActCNIndex < 0)					// already at root...
      break;
    AddCount--;
  }
  ppNewCertChain[0] = pNewCertChain;
  pNewCertCount[0]  = NewCertCount;
  pCNIndex[0]       = LastCNIndex;
  return(ASN1_OP_OK);
}

/**
Fetches the lowest 'NNotAfter' time in the certificate chain.
*/
static int* m_get_min_not_after(X509CERT** aadsp_src,
                                int inp_len)
{
    int inl_index = 0;
    int* ainl_min_not_after = aadsp_src[inl_index]->pNotAfterTimeArray;
    inl_index++;
    
    while(inl_index < inp_len){
        int inl_cmp = CompareTimeArrays(ainl_min_not_after,
                                        aadsp_src[inl_index]->pNotAfterTimeArray);
        if( inl_cmp == 1){
            ainl_min_not_after = aadsp_src[inl_index]->pNotAfterTimeArray;
        }
        inl_index++;
    }
    return ainl_min_not_after;
}

/**
* Subroutine CheckCertsChainTimeValidities checks a certificate
* chain for validity of the 'NotBefore' and 'NotAfter' Entries (CheckCertsChainTimeValidities).
* If requested a detailed status result list will be generated.
*
* NOTE: 1. Certificate for first list index is the end certificate
*       2. No parameters checked, must be done ahead
*
* Checking preparation step: Set CheckTime = CurrentTime
* Now for each certificate do the following:
* 1. Verify that 'NotBefore' <= CheckTime <= 'NotAfter'
*    for the currently processed certificate.
* 2. Set CheckTime = 'NotBefore' of the currently processed
*    certificate.
* 3. If extended checking is selected (Internet PKI mode, RFC3280)
*    also verify that 'NotBefore' <= CurrentTime <= 'NotAfter'
* 4. When Status Array is given, also generate specific Flag bits
*    for NotBefore and NotAfter conditions:
* 4.1. Perform checks for current certificate against current time:
*    - If CurrentTime >= NotBefore(Actual) set NotBeforeValid Bit 
*    - If CurrentTime <= NotAfter(Actual)  set NotAfterValid Bit 
*    - If DeltaTime Array is given and
*	 CurrentTime + DeltaTime <= NotBefore(Actual)
*	   set NotAfterDeltaValidBit
* 4.2. Perform Validity Chaining test for earliest not-after time
	   in chain against the current certificate:
*	- If NotBefore(Actual) < NotAfter(Minimum),
*	  chain is not valid, set statusBit of current certificate
*
* Perform this for all certificates down to the first certificate
* in the list (which may be a root or not...).
*
*
* Assumption: Certificate chain has already been checked for
*      ------ correct order (aka. Issuer/Subject linkage)
*
*
*  @param pCertChain Certificate chain (list) array
*  @param CertCount Number of certificates in list
*  @param TestModeFlags Specifiy testmode to apply:
*               Bit 0: 1 - Extended Checking
*               enable
*  @param pDeltaTimeArr Array for Flagbits / NULL
*  @param pStatusArr Detailed status report. Optional
*  @param pResult Summary of check result
*
*  @return ASN1_OP_OK on success, error code otherwise
* <br>            - else Error occurred
*/
static  int CheckCertsChainTimeValidities(X509CERT ** pCertChain,
	int CertCount, int TestModeFlags, int* pDeltaTimeArr,
        int* pStatusArr, int* pResult)
{
  int Retcode;
  int Index,i,j;
  int FutureCheck = 0;
  int TotalResult;
  int TimeFlags;
  X509CERT * adsl_cur_cert;

  int* pNBefLastTimeArr;
  int* pNAftLastTimeArr;

  int CurrentTimeArray[TIME_ARRAY_SIZE];
  int FutureTimeArray[TIME_ARRAY_SIZE];
  //-------------------------------------------------------
  // Initialize Time array with current time
  //-------------------------------------------------------
  if((Retcode = GetCheckLocalTimeArray(0,0,CurrentTimeArray)) != ASN1_OP_OK)
    return(Retcode);
  pNBefLastTimeArr = CurrentTimeArray;
  pNAftLastTimeArr = CurrentTimeArray;
  //-----------------------------------------------------------
  // Calculate the Time array for 'NotAfter' checking if needed
  //-----------------------------------------------------------
  if((pStatusArr != NULL) && (pDeltaTimeArr != NULL))
  {
    FutureCheck = 1;
    memcpy(FutureTimeArray+0,CurrentTimeArray+0,(TIME_ARRAY_SIZE)*sizeof(int));
    if((Retcode = AddTimeArrayDeltaTime(FutureTimeArray,
			pDeltaTimeArr,0)) != ASN1_OP_OK)
      return(Retcode);
  }

  
  int* ainl_min_not_after = m_get_min_not_after(pCertChain, CertCount);
  //-------------------------------------------------------
  // Start Verification beginning with the End certificate
  //-------------------------------------------------------
  TotalResult = 0;
  Index = 0;
  while(Index < CertCount)
  {
    adsl_cur_cert = pCertChain[Index];		// fetch Certificate    
    if(pStatusArr != NULL)
    {
      // reset errors and flags
      pStatusArr[Index] &= (int) (~(ASN1_CSTAT_TIME_VALIDITY_MASK | ASN1_CSTAT_TIMEFLAGS_MASK));
    }
    //---------------------------------------------------------
    // 1. Trivial check, Certificate's 'NotBefore' < 'NotAfter'
    //---------------------------------------------------------
    i = CompareTimeArrays(adsl_cur_cert->pNotBeforeTimeArray,
                          adsl_cur_cert->pNotAfterTimeArray);
    if(i != ASN1_1ST_LT_2ND)			// Cert has a problem...
    {
      if(pStatusArr != NULL)
      {
        pStatusArr[Index] |= ASN1_CSTAT_MISFORMED_VALIDITY;	// 0x01      
      }

      if(Index == 0)					// Is End Certificate
      {
        TotalResult = ASN1_ENDCERT_NOT_YET_VALID |	// set both
		      ASN1_ENDCERT_EXPIRED |
		      ASN1_ENDCERT_VALIDITY_INVALID;	// basically invalid !
      }
      else
      {
        TotalResult |= (ASN1_ENDCERT_CHAIN_ELEM_TIMEOUT | // intermediate timeout
		        ASN1_ENDCERT_VALIDITY_INVALID);	// basically invalid !

      }
      Index++;
      continue;						// to next one...
    }
    //------------------------------------------------------------------
    // 2. Generate Time Validity State Flags if required
    //------------------------------------------------------------------
    if(pStatusArr != NULL)
    {
      TimeFlags = 0;
      //---------------------------------------------------------
      // Check NotBefore / NotAfter Validity against Current time
      //---------------------------------------------------------
      i = CompareTimeArrays(CurrentTimeArray,adsl_cur_cert->pNotBeforeTimeArray);
      if(i != ASN1_1ST_LT_2ND)			// CurrentTime >= NotBefore
	TimeFlags |= ASN1_CSTAT_NBEF_IS_VALID_BIT; // NotBefore is valid

      i = CompareTimeArrays(CurrentTimeArray,adsl_cur_cert->pNotAfterTimeArray);
      if(i != ASN1_1ST_GT_2ND)			// CurrentTime <= NotAfter
	TimeFlags |= ASN1_CSTAT_NAFT_IS_VALID_BIT; // NotAfter is valid
      //---------------------------------------------------------
      // Check NotAfter Validity against Current time + DeltaTime
      //---------------------------------------------------------
      if(FutureCheck != 0)
      {
        i = CompareTimeArrays(FutureTimeArray,adsl_cur_cert->pNotAfterTimeArray);
        if(i != ASN1_1ST_GT_2ND)		// Curr+Delta <= NotAfter
          TimeFlags |= ASN1_CSTAT_NAFT_DELTA_VALID_BIT; // NotAfter valid later
      }
      //---------------------------------------------------------
      // Check NotBefore[Last] / NotAfter[Last] against current
      // NotBefore/NotAfter time
      // NOTE: Certificate position in chain controls Checkmode !
      //---------------------------------------------------------
      if(Index == 0)				// is Endcert or Only Cert
      {
        //-------------------------------------------------------
        // First Certificate, special case:
        // - root certificate: set both InRange Bits
	// - other cert (Endcert): do not set any bits, delay until next index
        //-------------------------------------------------------
        if((adsl_cur_cert->Flags & SELF_SIGNED_MASK) != 0)	// is a Root !
        {
          TimeFlags |= (ASN1_CSTAT_NBEF_IN_RANGE_BIT |
		        ASN1_CSTAT_NAFT_IN_RANGE_BIT);
        }
      }        
      else
      {
        //-------------------------------------------------------------
        // Is *NOT* the first certificate, compare *LAST* certificate's
        // NotBefore and NotAfter times against current Notbefore/NotAfter
        // interval
        //-------------------------------------------------------------
        i = CompareTimeArrays(pNBefLastTimeArr,adsl_cur_cert->pNotBeforeTimeArray);
        j = CompareTimeArrays(pNBefLastTimeArr,adsl_cur_cert->pNotAfterTimeArray);
        if((i != ASN1_1ST_LT_2ND) &&		// NBLast >= NBAct
           (j != ASN1_1ST_GT_2ND))		// NBLast <= NAAct
          pStatusArr[Index-1] |= ASN1_CSTAT_NBEF_IN_RANGE_BIT;

        i = CompareTimeArrays(pNAftLastTimeArr,adsl_cur_cert->pNotBeforeTimeArray);
        j = CompareTimeArrays(pNAftLastTimeArr,adsl_cur_cert->pNotAfterTimeArray);
        if((i != ASN1_1ST_LT_2ND) &&		// NALast >= NBAct
           (j != ASN1_1ST_GT_2ND))		// NALast <= NAAct
          pStatusArr[Index-1] |= ASN1_CSTAT_NAFT_IN_RANGE_BIT;
        //-------------------------------------------------------------
        // Check if the actual certificate is the LAST one
        //-------------------------------------------------------------
        if(Index == (CertCount - 1))		// MUST be a root, set both bit
        {
          TimeFlags |= (ASN1_CSTAT_NBEF_IN_RANGE_BIT |
		        ASN1_CSTAT_NAFT_IN_RANGE_BIT);
        }
      }
      pStatusArr[Index] |= TimeFlags;		// set result for current cert
    }
    
    //------------------------------------------------------------------
    // 3. Basic Check: Check if the earliest not-after time is not before
    //                 not-before time of current certificate. 
    //                 This assures that there exists a time where all
    //                 certificates are valid.
    //------------------------------------------------------------------
    i = CompareTimeArrays(ainl_min_not_after,adsl_cur_cert->pNotBeforeTimeArray);

    pNBefLastTimeArr = adsl_cur_cert->pNotBeforeTimeArray;
    pNAftLastTimeArr = adsl_cur_cert->pNotAfterTimeArray;

    if(i == ASN1_1ST_LT_2ND)		// min not after < NBcur
    {
        if(pStatusArr != NULL)
        {
          pStatusArr[Index] |= ASN1_CSTAT_MISMATCHED_VALIDITY;
        }
        TotalResult |= ASN1_ENDCERT_CHAIN_ELEM_TIMEOUT;
    }

    if(Index == 0){
        // Check end certificate validity
        i = CompareTimeArrays(CurrentTimeArray,adsl_cur_cert->pNotBeforeTimeArray);
        j = CompareTimeArrays(CurrentTimeArray,adsl_cur_cert->pNotAfterTimeArray);

        if(i == ASN1_1ST_LT_2ND) {
            if(pStatusArr != NULL){
                pStatusArr[Index] |= ASN1_CSTAT_NOT_YET_VALID;
            }
            TotalResult = ASN1_ENDCERT_NOT_YET_VALID;
        } 
        if(j == ASN1_1ST_GT_2ND) {
            if(pStatusArr != NULL){
                pStatusArr[Index] |= ASN1_CSTAT_HAS_EXPIRED;
            }
            TotalResult = ASN1_ENDCERT_EXPIRED;
        }   
    }

    if(((TestModeFlags & 0x01) != 0) &&		// extended validity mode...
       (Index != 0))				// not the 'end' certificate
    {
      //---------------------------------------------------------
      // 2. Check if 'NotBefore' <= CurrentTime <= 'NotAfter'
      //---------------------------------------------------------
      i = CompareTimeArrays(CurrentTimeArray,adsl_cur_cert->pNotBeforeTimeArray);
      j = CompareTimeArrays(CurrentTimeArray,adsl_cur_cert->pNotAfterTimeArray);
      if((i == ASN1_1ST_LT_2ND) || (j == ASN1_1ST_GT_2ND))
      {
        if((adsl_cur_cert->Flags & SELF_SIGNED_MASK) != 0)
          TotalResult |= ASN1_ENDCERT_ROOT_TIMEOUT;		// at root...
        else
          TotalResult |= ASN1_ENDCERT_CHAIN_ELEM_TIMEOUT;	// SUB-CA

	if(pStatusArr != NULL)
        {     
          if(i == ASN1_1ST_LT_2ND)			// not yet valid
            pStatusArr[Index] |= ASN1_CSTAT_NOT_YET_VALID;	// 0x03
          else						// has expired
            pStatusArr[Index] |= ASN1_CSTAT_HAS_EXPIRED;	// 0x04
        }
      }
    }
    Index++;
  } // while loop
  //-------------------------------------------------------
  // set accumulated Result
  //-------------------------------------------------------
  pResult[0] = TotalResult;
  return(ASN1_OP_OK);
}

/**
* Subroutine CheckCertsChainIssuerSubjMatch checks a certificate
* chain for correct matching of issuer and subject, assures that
* there are no interspersed selfsigned certs (CheckCertsChainIssuerSubjMatch).
*
* NOTE: 1. Certificate for first list index is the end certificate
*       2. No parameters checked, must be done ahead
*
*  @param pCertChain Certificate chain (list) array
*  @param CertCount Number of certificates in list
*  @param pStatusArr Detailed status report. Optional
*  @param pResult Summary of check result
*
*  @return ASN1_OP_OK on success, error code otherwise
* <br>            - else Error occurred
*/
static  int CheckCertsChainIssuerSubjMatch(X509CERT ** pCertChain,
	int CertCount, int* pStatusArr, int* pResult)
{
  int Retcode;
  int Index;
  int TotalResult;
  X509CERT * pPrevCert;
  X509CERT * pActCert;
  int pTmpResult[1];

  TotalResult = 0;
  Index = CertCount-1;
  //----------------------------------------------------------------------
  // Special processing for the last certificate in chain, should be root
  //----------------------------------------------------------------------
  if(pStatusArr != NULL)
    pStatusArr[Index] &= (~ASN1_CSTAT_ISSUER_SUBJ_MASK);// reset error
  pActCert = pCertChain[Index];				// get certificate
  if((pActCert->Flags & SELF_SIGNED_MASK) == 0)
  {
    if(pStatusArr != NULL)
      pStatusArr[Index] |= ASN1_CSTAT_ISSUER_UNKNOWN;	// set not known
    TotalResult = ASN1_ENDCERT_NO_ROOT;
  }
  //----------------------------------------------------------------
  // Process the remaining certificates in the chain
  //----------------------------------------------------------------
  Index--;
  while(Index >= 0)
  {
    pPrevCert = pActCert;					// save as previous
    pActCert  = pCertChain[Index];			// get next cert
    if(pStatusArr != NULL)
    {
      pStatusArr[Index] &= (~ASN1_CSTAT_ISSUER_SUBJ_MASK); // reset Errors
    }
    //----------------------------------------------------------
    // 1. Assure that not a selfsigned certificate...
    //----------------------------------------------------------
    if((pActCert->Flags & SELF_SIGNED_MASK) != 0)
    {
      if(pStatusArr != NULL)
      {
        pStatusArr[Index] |= ASN1_CSTAT_SELFSIGNED_NOT_ROOT;
      }
      TotalResult |= ASN1_ENDCERT_SELFS_NOT_ALLOWED;
      Index--;
      continue;
    }
    //----------------------------------------------------------
    // 2. Perform Actual Issuer / previous Subject matching
    //----------------------------------------------------------
    if((Retcode = MatchCerts(pActCert, pPrevCert, CHAIN_MATCH,
			    pTmpResult)) != ASN1_OP_OK)
      return(Retcode);

    if(pTmpResult[0] != ASN1_SAME)
    {
      if(pStatusArr != NULL)
        pStatusArr[Index] |= ASN1_CSTAT_ISSUER_SUBJ_MISMATCH;
      TotalResult |= ASN1_ENDCERT_CHAIN_BROKEN;
    }
    Index--;
  }
  //-------------------------------------------------------
  // set accumulated Result
  //-------------------------------------------------------
  pResult[0] = TotalResult;
  return(ASN1_OP_OK);
}

/**
* Subroutine CheckCertsChainBasicConstraints checks a certificate
* chain for correct basic constraints usage (CheckCertsChainBasicConstraints).
*
* NOTE: 1. Certificate for first list index is the end certificate
*       2. No parameters checked, must be done ahead
*
*  @param pCertChain Certificate chain (list) array
*  @param CertCount Number of certificates in list
*  @param pStatusArr Detailed status report. Optional
*  @param pResult Summary of check result
*
*  @return ASN1_OP_OK on success, error code otherwise
* <br>            - else Error occurred
*/
static  int CheckCertsChainBasicConstraints(X509CERT ** pCertChain,
	int CertCount, int* pStatusArr, int* pResult)
{
  int Index;
  int CAMode, PathLen, TmpLen;
  int TotalResult, CumulativeFlags;
  X509CERT * pActCert;

  TotalResult = 0;
  CumulativeFlags = 0;
  CAMode  = X509_BASICCONSTR_CA_FLAG_UNDEF;
  PathLen = X509_BASICCONSTR_PATHLEN_UNDEF;
  //----------------------------------------------------------------
  // Process the Certificates starting from the base (root)
  //----------------------------------------------------------------
  Index = CertCount-1;
  while(Index >= 0)
  {
    //--------------------------------------------------------------
    // Get next Certificate
    //--------------------------------------------------------------
    pActCert  = pCertChain[Index];			// get next cert
    if(pStatusArr != NULL)
      pStatusArr[Index] &= (~ASN1_CSTAT_BCSTR_MASK);	// reset Errors
    //--------------------------------------------------------------
    // 1. Check if CA-Mode is active
    //--------------------------------------------------------------
    if(CAMode != X509_BASICCONSTR_CA_FLAG_UNDEF)	// CA restriction active
    {
      if((CAMode & X509_BASICCONSTR_CA_FLAG) == 0)	// not allowed !
      {
        CumulativeFlags |= ASN1_CSTAT_BCSTR_CA_NOT_ALLOWED;
        TotalResult |= ASN1_ENDCERT_BASIC_CONSTR_FAIL;
      }
    }
    //--------------------------------------------------------------
    // 2. Check Path length from last CA certificate if active...
    //--------------------------------------------------------------
    if(PathLen >= 0)				// Pathlength Constraint active
    {
      if(PathLen == 0)				// exhausted, none may follow!
      {
        CumulativeFlags |= ASN1_CSTAT_BCSTR_PATHLEN_EXCEED;
        TotalResult = ASN1_ENDCERT_BASIC_CONSTR_FAIL;
      }
      else if(PathLen == 1)			// only Endcert may follow
      {
        //-----------------------------------------------------------------
        // Only an Endcertificate may follow, check if may act as CA is set
        //-----------------------------------------------------------------
        if((pActCert->BasicConstrCAMode !=	// extension is present
            X509_BASICCONSTR_CA_FLAG_UNDEF) &&
           ((pActCert->BasicConstrCAMode &	// may act as CA is set
             X509_BASICCONSTR_CA_FLAG) != 0))
        {
          CumulativeFlags |= ASN1_CSTAT_BCSTR_PATHLEN_EXCEED;
          TotalResult = ASN1_ENDCERT_BASIC_CONSTR_FAIL;
        }
        PathLen--;           
      }
      else					// all types may follow...
      {
        PathLen--;
      }
    }
    if(pStatusArr != NULL)
      pStatusArr[Index] |= CumulativeFlags;
    //--------------------------------------------------------------
    // 3. Check if current certificate has CA Mode/Path constraints 
    //--------------------------------------------------------------
    if(pActCert->BasicConstrCAMode != X509_BASICCONSTR_CA_FLAG_UNDEF)
    {
      //------------------------------------------------------------
      // Basic constraint is present check if current mode is set
      //------------------------------------------------------------
      if((CAMode == X509_BASICCONSTR_CA_FLAG_UNDEF) ||	// none active
         ((CAMode & X509_BASICCONSTR_CA_FLAG) != 0))	// active, as CA
      {
        CAMode = pActCert->BasicConstrCAMode;	// set new one
      }
      //------------------------------------------------------------
      // Check if Pathlen constraint is present check if current set
      //------------------------------------------------------------
      TmpLen = pActCert->BasicConstrPathLen;
      if(TmpLen != X509_BASICCONSTR_PATHLEN_UNDEF)
      {
        TmpLen++;
        if(PathLen == X509_BASICCONSTR_PATHLEN_UNDEF)	// none before
        {
          PathLen = TmpLen;
        }
        else						// had a constraint..
        {
          if(TmpLen < PathLen)				// more restrictive
            PathLen = TmpLen;
        }
      }
    }
    Index--;
  }
  //-------------------------------------------------------
  // set accumulated Result
  //-------------------------------------------------------
  pResult[0] = TotalResult;
  return(ASN1_OP_OK);
}

static int m_check_sig_key_usage(int* ainp_status_array,
                                 int inp_status_index,
                                 X509CERT* adsp_cert,
                                 bool bop_is_solo_root)
{
    int inl_key_usage = adsp_cert->KeyUsageFlags;
    if(bop_is_solo_root)
    {
        if(((inl_key_usage & X509_KEYUSAGE_CERT_SIGN_BIT) == 0) &&   // reject certificate, if both flags are missing 
            ((inl_key_usage & X509_KEYUSAGE_DIG_SIGNAT_BIT) == 0))    // in the key usage of a "solo" root cert. LS - 18.02.2014
        {
            if((adsp_cert->PkixKeyPurposeFlags & PKIX_KEYPURP_SERVER_AUTH_BIT) != 0){
                // Special case: Windows terminal server certificates
                return ASN1_ENDCERT_WTS_GENERATED_CERT;
            } else {
                if(ainp_status_array != NULL){
                    ainp_status_array[inp_status_index] |= ASN1_CSTAT_SIGN_INV_KEYUSAGE;
                }
                return ASN1_ENDCERT_KEYUSAGE_INVALID;
            }
        }
    }
    else					// more certificates follow!
    {
        if((inl_key_usage & X509_KEYUSAGE_CERT_SIGN_BIT) == 0) // not allowed !
        {
            if(ainp_status_array != NULL){
                ainp_status_array[inp_status_index] |= ASN1_CSTAT_SIGN_INV_KEYUSAGE;
            }
            return ASN1_ENDCERT_KEYUSAGE_INVALID;
        }
    }
    return 0;
}

/**
* Subroutine CheckCertsChainSignatures checks a certificate chain
* for correct signature matching and appropriate Key Usage (CheckCertsChainSignatures).
*
* NOTE: 1. Certificate for first list index is the end certificate
*       2. No parameters checked, must be done ahead
*
*  @param pCertChain Certificate chain (list) array
*  @param CertCount Number of certificates in list
*  @param pStatusArr Detailed status report. Optional
*  @param pResult Summary of check result
*
*  @return ASN1_OP_OK on success, error code otherwise
* <br>            - else Error occurred
*/
static  int CheckCertsChainSignatures(HMEM_CTX_DEF
	X509CERT ** pCertChain,
	int CertCount, int* pStatusArr, int* pResult)
{
  int Retcode;
  int Index;
  int TotalResult;
  int IssuerPubKeyType;
  int IssuerKeyUsageFlags;
  int IssuerCAModeFlags;

  X509CERT * pActCert;

  IDATA* pIdata;
  IDATA** pIssuerParValArray;

  IDATPARR* ppTmpDsaParValDesc[1];
  IDATPARR* pIssuerParValDesc;
  IDATPARR* pActDsaParValDesc = NULL;

  int pTmpResult[1];

  //---------------------------------------------------------
  // Allocate 'Default' DSA Parameters/Value Descriptor
  //---------------------------------------------------------
  if((Retcode = AllocIDATPARR_Struc(HMEM_CTX_REF1 ppTmpDsaParValDesc,
	        DSA_ALG_PAR_MAX_INDEX + DSA_PUB_VAL_MAX_INDEX)) != ASN1_OP_OK)
    return(ASN1_VFY_CHAIN_DSA_DEF_ALLOCERR);
  pActDsaParValDesc = ppTmpDsaParValDesc[0];
  pActDsaParValDesc->Flags |= FREE_BIT_MASK; // set freeable

  TotalResult = 0;
  Index = CertCount-1;
  //----------------------------------------------------------------
  // Preprocess the last certificate, should normally be a root...
  //----------------------------------------------------------------
  if(pStatusArr != NULL)
    pStatusArr[Index] &= (~ASN1_CSTAT_SIGN_MASK);	// reset errors

  pActCert            = pCertChain[Index];		// get the first one
  pIssuerParValDesc   = pActCert->SubjPubKeyParVal;	// get public values
  pIssuerParValArray  = pIssuerParValDesc->ppArr;// Array pointer
  IssuerPubKeyType    = pActCert->PublicKeyType;	// get type of key
  IssuerKeyUsageFlags = pActCert->KeyUsageFlags;	// get Key usage
  IssuerCAModeFlags   = pActCert->BasicConstrCAMode; // get CA mode

  if((pActCert->Flags & SELF_SIGNED_MASK) == 0)	// not a root !
  {
    //-------------------------------------------------------------
    // First one is *NOT* a root, cannot check signature !!
    //-------------------------------------------------------------
    TotalResult |= ASN1_ENDCERT_SIGNAT_NOT_CHECKED;	// set error...
    if(pStatusArr != NULL)
      pStatusArr[Index] |= ASN1_CSTAT_SIGN_FIRST_UNCHECKED;
  }
  else
  {
    //-------------------------------------------------------------
    // Last one IS a root, check key usage and signature
    //-------------------------------------------------------------
    if((IssuerKeyUsageFlags & X509_KEYUSAGE_VALID_BIT) != 0)	 // present
    {
        TotalResult |= m_check_sig_key_usage(pStatusArr, Index, pActCert, (CertCount <= 1));
    }

    if((Retcode = VerifyCertSignat(HMEM_CTX_REF1
			pActCert, pIssuerParValDesc,
			IssuerPubKeyType, pTmpResult)) != ASN1_OP_OK)
    {
      FreeIDATPARR_Struc(HMEM_CTX_REF1 pActDsaParValDesc);
      return(Retcode);
    }
    if(pTmpResult[0] != ASN1_SIGNAT_VFY_OK)			// verify fail
    {
      TotalResult |= ASN1_ENDCERT_SIGNAT_FAIL;
      if(pStatusArr != NULL)
      {
        if(pTmpResult[0] == ASN1_SIGNAT_ALGOR_MISMATCH)
          pStatusArr[Index] |= ASN1_CSTAT_SIGN_ALGOR_MISMATCH;
        if(pTmpResult[0] == ASN1_SIGNAT_PARAMS_MISSING)
          pStatusArr[Index] |= ASN1_CSTAT_SIGN_PARAMS_MISSING;
        else
          pStatusArr[Index] |= ASN1_CSTAT_SIGN_INVALID;
      }
    }
  }
  //----------------------------------------------------------------
  // Check if certificate has a DSA key, if so setup the DSA
  // params/values
  //----------------------------------------------------------------
  if(IssuerPubKeyType == DSA_PUBLIC_ALGOR)
  {
    AllocCopyDatArrayToDatArray(HMEM_CTX_REF1
				pIssuerParValDesc,0,
			        pActDsaParValDesc,0,
                                DSA_ALG_PAR_MAX_INDEX+DSA_PUB_VAL_MAX_INDEX,1);
//  DefaultDsaParamsAvailFlag = 1;
  }
  //-----------------------------------------------------------------
  // Verify the other Certificates now
  // NOTE: Keyusage check is special on last certificate !!!
  //-----------------------------------------------------------------
  Index--;				// start with next
  while(Index >= 0)
  {
    //--------------------------------------------------------------
    // Get next Certificate, check Issuer key usage
    //--------------------------------------------------------------
    pActCert  = pCertChain[Index];			// get next cert
    if(pStatusArr != NULL)
      pStatusArr[Index] &= (~ASN1_CSTAT_SIGN_MASK);	// reset Errors

//    if(((IssuerKeyUsageFlags & X509_KEYUSAGE_VALID_BIT) != 0) && // present
//       ((IssuerKeyUsageFlags & X509_KEYUSAGE_CRITICAL_BIT) != 0))// critical
    if((IssuerKeyUsageFlags & X509_KEYUSAGE_VALID_BIT) != 0)	// present
    {
      if((IssuerKeyUsageFlags & X509_KEYUSAGE_CERT_SIGN_BIT) == 0) // not allowed !
      {
        TotalResult |= ASN1_ENDCERT_KEYUSAGE_INVALID;
        if(pStatusArr != NULL)
          pStatusArr[0] |= ASN1_CSTAT_SIGN_INV_KEYUSAGE;
      }
      if(IssuerCAModeFlags != X509_BASICCONSTR_CA_FLAG_UNDEF)	// is present
      {
        if((IssuerCAModeFlags & X509_BASICCONSTR_CA_FLAG) == 0) // NOT a CA !!
        {
          TotalResult |= ASN1_ENDCERT_KEYUSAGE_INVALID;
          if(pStatusArr != NULL)
          pStatusArr[Index] |= ASN1_CSTAT_SIGN_INV_KEYUSAGE;
        }
      }
    }
    //----------------------------------------------------------------
    // Verify the Signature, for DSA, use the *global* parameter/value
    // structure (that is combined from earlier certificate's parameters
    // and the latest issuer's certificate parameters/value)
    //----------------------------------------------------------------
    if(IssuerPubKeyType == DSA_PUBLIC_ALGOR)
    {
      Retcode = VerifyCertSignat(HMEM_CTX_REF1
				 pActCert,pActDsaParValDesc,
			         IssuerPubKeyType, pTmpResult);
    }
    else
    {
      Retcode = VerifyCertSignat(HMEM_CTX_REF1
				 pActCert,pIssuerParValDesc,
			         IssuerPubKeyType, pTmpResult);
    }
    if(Retcode != ASN1_OP_OK)
    {
      FreeIDATPARR_Struc(HMEM_CTX_REF1 pActDsaParValDesc);
      return(Retcode);
    }
    if(pTmpResult[0] != ASN1_SIGNAT_VFY_OK)			// verify fail
    {
      TotalResult |= ASN1_ENDCERT_SIGNAT_FAIL;
      if(pStatusArr != NULL)
      {
        if(pTmpResult[0] == ASN1_SIGNAT_ALGOR_MISMATCH)
          pStatusArr[Index] |= ASN1_CSTAT_SIGN_ALGOR_MISMATCH;
        if(pTmpResult[0] == ASN1_SIGNAT_PARAMS_MISSING)
          pStatusArr[Index] |= ASN1_CSTAT_SIGN_PARAMS_MISSING;
        else
          pStatusArr[Index] |= ASN1_CSTAT_SIGN_INVALID;
      }
    }
    Index--;

// NOTE: If necessary, key usage of last certificate (endcert)
// ----- can be done here...

    //--------------------------------------------------------------
    // Check if already all processed... 
    //--------------------------------------------------------------
    if(Index < 0)
      break;
    //--------------------------------------------------------------
    // more certificates must be processed, set the current
    // certificate's key and algor as issuer for next stage
    //--------------------------------------------------------------
    pIssuerParValDesc   = pActCert->SubjPubKeyParVal; // get public values
    pIssuerParValArray  = pIssuerParValDesc->ppArr; // Array pointer
    IssuerPubKeyType    = pActCert->PublicKeyType;	  // get type of key
    IssuerKeyUsageFlags = pActCert->KeyUsageFlags;   // get Key usage
    IssuerCAModeFlags   = pActCert->BasicConstrCAMode; // get CA mode
    //--------------------------------------------------------------
    // If the Certificate has a DSA key, set up the DSA descriptor:
    // If Parameters are Present copy parameters and public value else
    // copy only the public value
    //--------------------------------------------------------------
    if(IssuerPubKeyType == DSA_PUBLIC_ALGOR)
    {
      if((pIssuerParValArray[DSA_ALG_PAR_P_INDEX] != NULL) &&
         (pIssuerParValArray[DSA_ALG_PAR_Q_INDEX] != NULL) &&
         (pIssuerParValArray[DSA_ALG_PAR_G_INDEX] != NULL))
      {
        AllocCopyDatArrayToDatArray(HMEM_CTX_REF1
				    pIssuerParValDesc,0,
			            pActDsaParValDesc,0,
                                DSA_ALG_PAR_MAX_INDEX+DSA_PUB_VAL_MAX_INDEX,1);
      }
      else						// no parameters (!)
      {
        AllocCopyDatArrayToDatArray(HMEM_CTX_REF1
				    pIssuerParValDesc,DSA_ALG_PAR_MAX_INDEX,
			            pActDsaParValDesc,DSA_ALG_PAR_MAX_INDEX,
                                    DSA_PUB_VAL_MAX_INDEX,1);
      }
    }
    else					// not DSA type->invalidate 
    {
      if((pIdata = pActDsaParValDesc->ppArr[0]) != NULL)
      {
        FREE_ARRAY(HMEM_CTX_REF,pIdata->Base);
      }
    }
  }
  FreeIDATPARR_Struc(HMEM_CTX_REF1 pActDsaParValDesc);
  pResult[0] = TotalResult;
  return(ASN1_OP_OK);
}

extern "C"  int CheckCertificateChain(HMEM_CTX_DEF
			X509CERT ** pCertChain,
			int CertCount, int TestModeFlags,
			int* pDeltaTimeArr,
			int* pStatusArr, int* pResult)
{
  int Retcode;
  int TotalResult;
  int pTmpResult[1];
  //-----------------------------------------------------------
  // Check necessary parameters first
  //-----------------------------------------------------------
  if((pCertChain == NULL) || (pResult == NULL))
    return(ASN1_NULL_PTR);
  if(CertCount <= 0)
    return(ASN1_PARAM_ERR);

  pResult[0]  = ASN1_ENDCERT_NOT_USABLE_MASK;
  TotalResult = 0;
  //-----------------------------------------------------------
  // 1. Check Subject/Issuer chain matching
  //-----------------------------------------------------------
  if((TestModeFlags & 0x04) == 0)
  {
    if((Retcode = CheckCertsChainIssuerSubjMatch(
			pCertChain, CertCount,
			pStatusArr, pTmpResult)) != ASN1_OP_OK)
      return(Retcode);
    TotalResult = pTmpResult[0];
  }
  //-----------------------------------------------------------
  // 2. Check Chain of Signatures and Key usage
  //-----------------------------------------------------------
  if((TestModeFlags & 0x08) == 0)
  {
    if((Retcode = CheckCertsChainSignatures(HMEM_CTX_REF1
			pCertChain, CertCount,
			pStatusArr, pTmpResult)) != ASN1_OP_OK)
      return(Retcode);
    TotalResult |= pTmpResult[0];
  }
  //-----------------------------------------------------------
  // 3. Check Basic Constraints usage within chain
  //-----------------------------------------------------------
  if((TestModeFlags & 0x10) == 0)
  {
    if((Retcode = CheckCertsChainBasicConstraints(pCertChain, CertCount,
			pStatusArr, pTmpResult)) != ASN1_OP_OK)
      return(Retcode);
    TotalResult |= pTmpResult[0];
  }
  //-----------------------------------------------------------
  // 4. Check Time Validity across chain
  //-----------------------------------------------------------
  if((TestModeFlags & 0x20) == 0)
  {
    if((Retcode = CheckCertsChainTimeValidities(pCertChain, CertCount,
			TestModeFlags, pDeltaTimeArr,
			pStatusArr, pTmpResult)) != ASN1_OP_OK)
      return(Retcode);
    TotalResult |= pTmpResult[0];
  }

  if(TotalResult != 0)
    TotalResult |= ASN1_ENDCERT_NOT_USABLE_MASK;
  pResult[0] = TotalResult;
  return(ASN1_OP_OK);
}

extern "C"  int VerifyCertsChainEX(HMEM_CTX_DEF
	X509CERT ** pCertChain, int CertCount,
	int TestModeFlags, int* pDeltaTimeArr,
	int* pStatusArr, int* pResult,
	CTREESTR * pTreeStruc, int* pRootIndex)
{
  int Retcode;
  int RootCNIndex;
  int CertsToCheckCount;
  int TotalResult;

  X509CERT * pCert;

  X509CERT ** pCertsToCheckChain;
  X509CERT ** pTmpCertsChain = NULL;

  X509CERT ** ppTmpNewChain[1];

  int* pCheckStatusArr;
  int* pTmpStatusArr = NULL;

  int pTmpResult[1];
  int pTmpCnt[1];
  int pTmpCNIndex[1];
  int pTmpResult32[1];
  //------------------------------------------------------
  // Check required parameters first
  //------------------------------------------------------
  if((pCertChain == NULL) || (pResult == NULL))
    return(ASN1_NULL_PTR);
  if(CertCount <= 0)
    return(ASN1_PARAM_ERR);

  if(pRootIndex != NULL)
    pRootIndex[0] = -1;

  pCertsToCheckChain = pCertChain;
  CertsToCheckCount  = CertCount;
  pCheckStatusArr    = pStatusArr;
  TotalResult        = 0;
  //------------------------------------------------------
  // Check type of last certificate in list
  //------------------------------------------------------
  pCert = pCertChain[CertCount-1];		// get root/Last
  if((pCert->Flags & SELF_SIGNED_MASK) == 0)
  {
    //------------------------------------------------------------
    // Last certificate in list is *NOT* a root certificate !
    // Check if we have a well known root for the chain
    //------------------------------------------------------------
    if(pTreeStruc == NULL)			// no tree, no root...
    {
      TotalResult = ASN1_ENDCERT_NO_ROOT;
    }
    else
    {
      //----------------------------------------------------------
      // Complete the chain now (with one or more certs)
      //----------------------------------------------------------
      if((Retcode = CompleteCertChain(HMEM_CTX_REF1
				      pCertChain, CertCount,
				      pTreeStruc, pTmpCNIndex,
				      ppTmpNewChain, pTmpCnt)) != ASN1_OP_OK)
        return(Retcode);
      RootCNIndex = pTmpCNIndex[0];
      if(RootCNIndex < 0)
      {
        TotalResult = ASN1_ENDCERT_NO_ROOT;
      }
      else
      {
        //--------------------------------------------------------
        // Chain has been completed, set the new array / count
        //--------------------------------------------------------
        pCertsToCheckChain = ppTmpNewChain[0];
        CertsToCheckCount  = pTmpCnt[0];

        if(pRootIndex != NULL)
          pRootIndex[0] = RootCNIndex;		// report the Index

        //--------------------------------------------------------
        // Allocate Temporary status array if required
        //--------------------------------------------------------
        if(pStatusArr != NULL)
        {
          if((pTmpStatusArr = BIT32_ARRAY_ALLOC(HMEM_CTX_REF,
				CertsToCheckCount)) == NULL)
          {
            FREE_CARRAY(HMEM_CTX_REF,pCertsToCheckChain);
            return(ASN1_ALLOC_ERR);
          }
          pCheckStatusArr = pTmpStatusArr;
        }
      }
    }
  }
  else
  {
    //------------------------------------------------------------
    // Last certificate in list *IS* a root certificate !
    // Check if this is a well known root for the chain
    //------------------------------------------------------------
    pCert->Flags &= (~WELL_KNOWN_CA_MASK);
    if((TestModeFlags & 0x02) == 0)		// Perform Trusted Root Check
    {
      if((pTreeStruc == NULL) ||		// no tree, not known...
         (pTreeStruc->RootCaCount <= 0))	// no roots, not known...
      {
        TotalResult = ASN1_ENDCERT_NO_TRUST_ROOT;
      }      
      else					// have a tree...
      {
        if((Retcode = CheckTrustedRootCert(pCert, pTreeStruc,
			pTmpResult, pTmpCNIndex)) != ASN1_OP_OK)
          return(Retcode);
        if(pTmpResult[0] != ASN1_TRUSTED_ROOT)
        {
          if((TestModeFlags & 0x02) == 0)		// do NOT supress Error
          {
            TotalResult = ASN1_ENDCERT_NO_TRUST_ROOT;
          }
        }
        else					// IS a trusted root
        {
          if(pRootIndex != NULL)
            pRootIndex[0] = pTmpCNIndex[0];
          pCert->Flags |= WELL_KNOWN_CA_MASK;
        }
      }
    }
  }
  //------------------------------------------------------------
  // Perform Checking of the chain now    
  //------------------------------------------------------------
  Retcode = CheckCertificateChain(HMEM_CTX_REF1
			pCertsToCheckChain, CertsToCheckCount,
			TestModeFlags, pDeltaTimeArr,
			pCheckStatusArr, pTmpResult32);
  if(pTmpCertsChain != NULL)
  {
    FREE_CARRAY(HMEM_CTX_REF,pTmpCertsChain);
    if(pStatusArr != NULL)
    {
      memcpy(pStatusArr+0,pCheckStatusArr+0,(CertCount)*4);
      FREE_CARRAY(HMEM_CTX_REF,pCheckStatusArr);
    }
  }
  if(Retcode != ASN1_OP_OK)
  {
    pResult[0] = TotalResult | ASN1_ENDCERT_NOT_USABLE_MASK;
    return(Retcode);
  }
  TotalResult |= pTmpResult32[0];
  if(TotalResult != 0)
    TotalResult |= ASN1_ENDCERT_NOT_USABLE_MASK;

  pResult[0] = TotalResult;
  return(ASN1_OP_OK);
}

extern "C"  int VerifyCertificateChainNew(HMEM_CTX_DEF
			X509CERT ** pCertChain,
			int CertCount, CTREESTR * pTreeStruc, int Flags,
			int* pResult, int* pReason,
			int* pRootIndex)
{
  int Retcode;
  int Reason;
  int CheckResult;
  int pTmpResult[1];
  //-------------------------------------------------------------
  // Check variables needed
  //-------------------------------------------------------------
  if((pCertChain == NULL) || (pTreeStruc == NULL) || (pResult == NULL) ||
     (pReason == NULL) || (pRootIndex == NULL))
    return(ASN1_NULL_PTR);

  pResult[0] = ASN1_ENDCERT_NOT_USABLE_MASK;	// Preset
  pReason[0] = 0;
  //-------------------------------------------------------------
  // Check that at least one certificate and a root are available
  //-------------------------------------------------------------
  if(CertCount <= 0)
  {
    return(ASN1_CERT_CHAIN_VFY_NO_CERTS);
  }
  if(pTreeStruc->RootCaCount <= 0)
  {
    return(ASN1_CERT_CHAIN_VFY_NO_ROOTS);
  }
  //-------------------------------------------------------------
  // Verify the Certificate chain, check/decode result
  //-------------------------------------------------------------
  if((Retcode = VerifyCertsChainEX(HMEM_CTX_REF1
			pCertChain, CertCount,
			Flags & 0x01, NULL, NULL,
			pTmpResult, pTreeStruc, pRootIndex)) != ASN1_OP_OK)
    return(Retcode);
  CheckResult = pTmpResult[0];

  if(CheckResult == 0)			// all tests passed...
  {
    pResult[0] = 0;
    return(ASN1_OP_OK);
  }
  //-------------------------------------------------------------
  // If requested map No-Root error to no trusted root error
  //-------------------------------------------------------------
  if((Flags & 0x02) != 0)
  {
    if((CheckResult & ASN1_ENDCERT_NO_ROOT) != 0)
    {
      CheckResult &=
        (~(ASN1_ENDCERT_NO_ROOT | ASN1_ENDCERT_SIGNAT_NOT_CHECKED));
      CheckResult |= ASN1_ENDCERT_NO_TRUST_ROOT;
    }
  }
  //-------------------------------------------------------------
  // something is wrong with the chain, check for FATAL reason
  //-------------------------------------------------------------
  if((CheckResult & ASN1_ENDCERT_CRITICAL_MASK) != 0)
  {
    //-----------------------------------------------------------
    // Transcode Critical errors to old reason codes...
    //-----------------------------------------------------------
    if((CheckResult & ASN1_ENDCERT_NO_ROOT) != 0)
    {
      Reason = ASN1_VFY_CHAIN_NO_ROOT_ERR;
    }
    else if((CheckResult & ASN1_ENDCERT_SELFS_NOT_ALLOWED) != 0)
    {
      Reason = ASN1_VFY_CHAIN_SELFSIGN_NOT_TOP;
    }
    else if((CheckResult & ASN1_ENDCERT_CHAIN_BROKEN) != 0)
    {
      Reason = ASN1_VFY_CHAIN_ISSSUBJ_MISMATCH;
    }
    else if((CheckResult & ASN1_ENDCERT_BASIC_CONSTR_FAIL) != 0)
    {
      Reason = ASN1_VFY_CHAIN_BASIC_CONSTR_ERR;
    }
    else if((CheckResult & ASN1_ENDCERT_SIGNAT_NOT_CHECKED) != 0)
    {
      Reason = ASN1_VFY_CHAIN_SIGNAT_CHK_ERR;
    }
    else if((CheckResult & ASN1_ENDCERT_SIGNAT_FAIL) != 0)
    {
      Reason = ASN1_VFY_CHAIN_INVALID_SIGNAT;
    }
    else if((CheckResult & ASN1_ENDCERT_KEYUSAGE_INVALID) != 0)
    {
      Reason = ASN1_VFY_CHAIN_KEYUSAGE_ERR;
    }
    else
    {
      Reason = ASN1_VFY_CHAIN_SIGNAT_CHK_ERR;
    }
    pReason[0] = Reason;
    return(ASN1_OP_OK);
  }
  //--------------------------------------------------------
  // not a fatal error, set the reply status from lower bits
  //--------------------------------------------------------
  pResult[0] = ((int) CheckResult & ASN1_ENDCERT_POLICY_MASK) | ASN1_ENDCERT_NOT_USABLE_MASK;
  return(ASN1_OP_OK);
}

/**
* Subroutine ChkValidEndCertAlgors checks if a given, preprocessed
* Certificate in internal notation has the correct Algorithms,
* CA Issuer DN and in case of DH the same params for a given SSL/TLS
* Key Exchange Algorithm (ChkValidEndCertAlgors).
* NOTE: no check on pointers is done !
*      
*
*  @param pTreeStruc Tree Stucture
*  @param CertCNIndex Index into CNode Array 
*  @param PublicAlgor Algor (from KeyExchgID)
*  @param SignatAlgor Algor (from KeyExchgID)
*  @param pDNList List of CA RDNs/NULL
*  @param DnCount Number of Elements
*  @param pDHParams Parameters /NULL
*  @param pResult result of compare
*
*  @return ASN1_OP_OK on success, error code otherwise
* <br>            - else Error occurred
*/
static  int ChkValidEndCertAlgors(CTREESTR * pTreeStruc,
		int CertCNIndex, int PublicAlgor, int SignatAlgor,
		X501_DN** pDNList, int DnCount,
		IDATPARR* pDHParams,
		int* pResult)
{
  int Retcode = ASN1_OP_OK;
  int Result;
  int Index = 0;
  int ActCertIndex;
 
  IDATPARR* DatArrayDesc;

  int pTmpResult[1];

  X509CERT * pCert;

  X501_DN* pActNameDesc;

  pResult[0] = ASN1_END_CERT_ALGORS_MISMATCH;

  ActCertIndex = 				// get index to Cert List
    pTreeStruc->CNodeArray[CertCNIndex+CN_CERTLIST_INDEX];
  pCert = pTreeStruc->ppCertList[ActCertIndex];	// get Certificate
  //-------------------------------------------------------
  // Compare Certificate Algorithms
  //-------------------------------------------------------
  if((pCert->PublicKeyType != PublicAlgor) ||
     ((SignatAlgor != ANY_SIGNAT_ALGOR) &&
      (pCert->SignatAlgor != SignatAlgor)))
    return(Retcode);					// no match, o.k.
  //---------------------------------------------------------
  // Check if the Public Algorithm is DH and DH Params given
  //---------------------------------------------------------
  if((PublicAlgor == DH_PUBLIC_ALGOR) && (pDHParams != NULL))
  {
    DatArrayDesc = pCert->SubjPubKeyParVal;
    if(DatArrayDesc == NULL)
    {
      pResult[0] = ASN1_END_CERT_PARAMS_MISMATCH;
      return(Retcode);
    }
    for(;;)
    {
      //-------------------------------------------------
      // Prime P and Generator G must match
      //-------------------------------------------------
      Result = MatchIDATPARRStrucs(DatArrayDesc,DH_ALG_PAR_P_INDEX,
				   pDHParams,DH_ALG_PAR_P_INDEX,1);
      if(Result != ASN1_SAME) break;

      Result = MatchIDATPARRStrucs(DatArrayDesc,DH_ALG_PAR_G_INDEX,
				   pDHParams,DH_ALG_PAR_G_INDEX,1);
      if(Result != ASN1_SAME) break;
      //-------------------------------------------------
      // Public value Yc must be same or absent
      //-------------------------------------------------
      Result = MatchIDATPARRStrucs(DatArrayDesc,
			DH_ALG_PAR_MAX_INDEX+DH_PUB_VAL_Y_INDEX,
			pDHParams,
			DH_ALG_PAR_MAX_INDEX+DH_PUB_VAL_Y_INDEX,
			1);
      break;
    }
    if(Result != ASN1_SAME)
    {
      pResult[0] = ASN1_END_CERT_PARAMS_MISMATCH;
      return(Retcode);
    }
  }
  //------------------------------------------------------------
  // Check if there is a CA issuer name constraints list present
  //------------------------------------------------------------
  if((pDNList != NULL) && (DnCount > 0))
  {
    pResult[0] = ASN1_END_CERT_CA_ROOT_MISMATCH;
    for(;;)
    {
      if(pTreeStruc->CNodeArray[CertCNIndex+CN_P_INDEX] == -1)
        break;					// no more parents, at the root
      CertCNIndex = 				// get index to Parent
        pTreeStruc->CNodeArray[CertCNIndex+CN_P_INDEX];
    }
    ActCertIndex = 				// get index to Cert List
      pTreeStruc->CNodeArray[CertCNIndex+CN_CERTLIST_INDEX];
    pCert = pTreeStruc->ppCertList[ActCertIndex];	// get Root Certificate

    pActNameDesc = pCert->Issuer;

    Index = 0;
    do
    {
      Retcode = MatchX501_DNs(pActNameDesc,pDNList[Index],pTmpResult);
      if(Retcode != ASN1_OP_OK) return(Retcode);
      if(pTmpResult[0] == ASN1_SAME) break;		// found match !
      Index++;
      DnCount--;
    }while(DnCount != 0);
    if(DnCount == 0) return(Retcode);			// no match !
  }
  pResult[0] = ASN1_END_CERT_MATCH;
  return(Retcode);
}

extern "C"  int GetSpecificEndCertFromListEX(HMEM_CTX_DEF
		CTREESTR * pTreeStruc,
		int VerifyEnable, int VerifyModeFlags, 
		int PublicAlgor, int SignatAlgor,
		X501_DN** pDNList, int DnCount,
		IDATPARR* pDHParams, int* pResult)
{
  int Retcode = ASN1_OP_OK;
  int CertIndex = 0;
  int Cnt=0;
  int ActCNIndex;
  int CertListIndex;

  int RSA_AlternateFlag = 0;
  int DSS_AlternateFlag = 0;
  int Dh_AlternateFlag  = 0;

  int* pCertIndexList = NULL;

  int pTmpResult[1];
  int pVerifyResult[1];

  X509CERT * pCert;

  //------------------------------------------------------------
  // Get Count and List pointer according to given Algors
  //------------------------------------------------------------
  pResult[0] = -1;				// not found
  switch(PublicAlgor)
  {
    case RSA_PUBLIC_ALGOR:
      Cnt            = pTreeStruc->EndRsaCount;  
      pCertIndexList = pTreeStruc->EndRsaIndexArray;      
      if(Cnt != 0)					// there are Endcerts
      {
        if(pTreeStruc->RootEndRsaCount != 0)	// there are roots
          RSA_AlternateFlag = 1;			// alternate root get
	  break;
      }
      Cnt	     = pTreeStruc->RootEndRsaCount;
      pCertIndexList = pTreeStruc->RootEndRsaIndexArray;
      break;

    case DSA_PUBLIC_ALGOR:
      Cnt            = pTreeStruc->EndDssCount;  
      pCertIndexList = pTreeStruc->EndDssIndexArray;      
      if(Cnt != 0)					// there are Endcerts
      {
        if(pTreeStruc->RootEndDssCount != 0)	// there are roots
          DSS_AlternateFlag = 1;			// alternate root get
	  break;
      }
      Cnt	     = pTreeStruc->RootEndDssCount;
      pCertIndexList = pTreeStruc->RootEndDssIndexArray;
      break;

    case DH_PUBLIC_ALGOR:
      switch(SignatAlgor)
      {
        case RSA_SIGNAT_ALGOR:
          Cnt	         = pTreeStruc->EndDhRsaCount;
          pCertIndexList = pTreeStruc->EndDhRsaIndexArray;      
          break;

        case DSA_SIGNAT_ALGOR:
          Cnt	         = pTreeStruc->EndDhDssCount;
          pCertIndexList = pTreeStruc->EndDhDssIndexArray;      
          break;

        case ANY_SIGNAT_ALGOR:
          Cnt	         = pTreeStruc->EndDhRsaCount;
          pCertIndexList = pTreeStruc->EndDhRsaIndexArray;      
          if(Cnt != 0)
          {
	    if(pTreeStruc->EndDhDssCount != 0)	
	      Dh_AlternateFlag = 1;
            break;
          }
          Cnt	         = pTreeStruc->EndDhDssCount;
          pCertIndexList = pTreeStruc->EndDhDssIndexArray;      
          break;
      }       
      break;		// for CSHARP       
  } // outer switch
  if(Cnt <= 0) return(Retcode);
  //------------------------------------------------------------
  // Search list of specific certificates for a Match
  //------------------------------------------------------------
  for(;;)				// in case of DH all sign algors
  {
    CertIndex = 0;
    do
    {
      ActCNIndex = pCertIndexList[CertIndex];	// get index to Node array
      CertListIndex = 				// get index to Cert List
        pTreeStruc->CNodeArray[ActCNIndex+CN_CERTLIST_INDEX];
      pCert = pTreeStruc->ppCertList[CertListIndex]; // get Certificate
      if((pCert->ContFlags & IBM_CONT_FLAG_EXT_PRIV_KEY) == 0)
      {
        Retcode = ChkValidEndCertAlgors(pTreeStruc,ActCNIndex,
		    PublicAlgor, SignatAlgor, pDNList, DnCount,
		    pDHParams, pTmpResult);

        if(Retcode != ASN1_OP_OK)
          return(Retcode);
        if(pTmpResult[0] == ASN1_END_CERT_MATCH)	// found certificate
        {
          //-----------------------------------------------------
          // Verify the Chain originating at Endcert if requested
          //-----------------------------------------------------
          if(VerifyEnable == 0)			// no Verify required
          {
            pResult[0] = ActCNIndex;
            return(Retcode);
          }
          Retcode = VerifyLclCertChain(HMEM_CTX_REF1
			pTreeStruc, ActCNIndex,
			VerifyModeFlags, pVerifyResult);
          if(Retcode != ASN1_OP_OK)
            return(Retcode);
          if(pVerifyResult[0] == 0)		// verified o.k.
          {
            pResult[0] = ActCNIndex;
            return(Retcode);
          }
        }
      }  
      CertIndex++;
      Cnt--;
    }while(Cnt != 0);
    if((RSA_AlternateFlag == 0) &&
       (DSS_AlternateFlag == 0) &&
       (Dh_AlternateFlag == 0))
      break;
    //--------------------------------------------------------
    // There are either alternate RSA, DSS or DH possibilities
    //--------------------------------------------------------
    if(RSA_AlternateFlag != 0)
    {
      Cnt	     = pTreeStruc->RootEndRsaCount;
      pCertIndexList = pTreeStruc->RootEndRsaIndexArray;
      RSA_AlternateFlag = 0;
    }
    else if(DSS_AlternateFlag != 0)
    {
      Cnt	     = pTreeStruc->RootEndDssCount;
      pCertIndexList = pTreeStruc->RootEndDssIndexArray;
      DSS_AlternateFlag = 0;
    }
    else
    {
      Cnt	     = pTreeStruc->EndDhDssCount;
      pCertIndexList = pTreeStruc->EndDhDssIndexArray;      
      Dh_AlternateFlag = 0;
    }
  } // for
  return(Retcode);
}

extern "C"  int GetSpecificEndCertFromList(HMEM_CTX_DEF
		CTREESTR * pTreeStruc,
		int PublicAlgor, int SignatAlgor,
		X501_DN** pDNList, int DnCount,
		IDATPARR* pDHParams, int* pResult)
{
  return(GetSpecificEndCertFromListEX(HMEM_CTX_REF1
		pTreeStruc, 0, 0,
		PublicAlgor, SignatAlgor, pDNList, DnCount,
		pDHParams, pResult));
}

extern "C"  int BuildCertChainEX(HMEM_CTX_DEF
		CTREESTR * pTreeStruc,
		int VerifyEnable, int VerifyModeFlags,
		int PublicAlgor, int SignatAlgor,
	        X501_DN** pDNList, int DnCount,
		IDATPARR* pDHParams,
		int* pCNIndex, IDATPARR** pDstCertsDesc)
{
  int Retcode = ASN1_OP_OK;

  int ActCNIndex;
  int ActCertIndex;
  int DstIndex;
  int Cnt;

  int* pCNArray;

  int pTmpCNIndex[1];

  IDATPARR* pTmpDatArrayDesc[1];
  IDATPARR* DatArrayDesc;

  IDATA** DatArray;

  X509CERT * pCert;
  X509CERT ** pCertList;

  //------------------------------------------------------
  // check for NULL pointers
  //------------------------------------------------------
  if((pTreeStruc == NULL) || (pDstCertsDesc == NULL) ||
     (pCNIndex == NULL))
    return(ASN1_TO_CERT_CHAIN_NULLPTR_ERR);
  pDstCertsDesc[0] = NULL;
  //---------------------------------------------------------------
  // Find a Endcertificate for given specifics (algors, params, names),
  // if requested also assure that that Endcert's chain verifies o.k.
  //---------------------------------------------------------------
  Retcode = GetSpecificEndCertFromListEX(HMEM_CTX_REF1
			pTreeStruc,
			VerifyEnable, VerifyModeFlags,
			PublicAlgor, SignatAlgor,
			pDNList, DnCount,
			pDHParams, pTmpCNIndex);
  if(Retcode != ASN1_OP_OK)		// error occurred
    return(Retcode);
  ActCNIndex = pTmpCNIndex[0];
  if(ActCNIndex < 0)
    return(ASN1_TO_CERT_CHAIN_NO_CERTS);		// not found
  pCNIndex[0] = ActCNIndex;				// set for caller
  //---------------------------------------------------------------
  // Get number of elements needed down to root
  //---------------------------------------------------------------
  pCNArray = pTreeStruc->CNodeArray;
  Cnt = pCNArray[ActCNIndex + CN_LEVEL]+1;		// get level+ base
  pCertList = pTreeStruc->ppCertList;		// get list
  //------------------------------------------------------
  // Allocate the output data structure
  //------------------------------------------------------
  Retcode = AllocIDATPARR_Struc(HMEM_CTX_REF1 pTmpDatArrayDesc,Cnt);
  if(Retcode != ASN1_OP_OK)
    return(Retcode);
  DatArrayDesc = pTmpDatArrayDesc[0];
  DatArray = DatArrayDesc->ppArr;
  //-------------------------------------------------------------
  // Get the Elements (ASN.1 Certs) and copy to Destination Array
  //-------------------------------------------------------------
  DstIndex = 0;
  for(;;)
  {
    ActCertIndex = pCNArray[ActCNIndex + CN_CERTLIST_INDEX]; // Cert Index
    pCert = pCertList[ActCertIndex];		// Cert Structure pointer
    CopyIdataContents(DatArray[DstIndex],
		      pCert->Certificate->ppArr[0]);
    DstIndex++;    
    ActCNIndex = pCNArray[ActCNIndex + CN_P_INDEX];	// get parent index
    if(ActCNIndex == -1) break;				// no more parents
  }
  pDstCertsDesc[0] = DatArrayDesc;
  return(Retcode);
}

extern "C"  int BuildCertChain(HMEM_CTX_DEF
		CTREESTR * pTreeStruc,
		int PublicAlgor, int SignatAlgor,
	        X501_DN** pDNList, int DnCount,
		IDATPARR* pDHParams,
		int* pCNIndex, IDATPARR** pDstCertsDesc)
{

  return(BuildCertChainEX(HMEM_CTX_REF1
		pTreeStruc, 0, 0,
		PublicAlgor, SignatAlgor,
	        pDNList, DnCount, pDHParams, pCNIndex, pDstCertsDesc));
}

extern "C"  int BuildLclCertChain(HMEM_CTX_DEF
		CTREESTR * pTreeStruc,
		int CNIndex, IDATPARR** pDstCertsDesc)
{
  int Retcode = ASN1_OP_OK;

  int ActCNIndex = CNIndex;
  int ActCertIndex;
  int DstIndex;
  int Cnt;

  int* pCNArray;

  IDATPARR* pTmpDatArrayDesc[1];
  IDATPARR* DatArrayDesc;

  IDATA** DatArray;

  X509CERT * pCert;
  X509CERT ** pCertList;

  //------------------------------------------------------
  // check for NULL pointers
  //------------------------------------------------------
  if((pTreeStruc == NULL) || (pDstCertsDesc == NULL))
    return(ASN1_TO_CERT_CHAIN_NULLPTR_ERR);
  pDstCertsDesc[0] = NULL;
  //---------------------------------------------------------------
  // Get number of elements needed down to root
  //---------------------------------------------------------------
  pCNArray = pTreeStruc->CNodeArray;
  Cnt = pCNArray[ActCNIndex + CN_LEVEL]+1;		// get level+ base
  pCertList = pTreeStruc->ppCertList;		// get list
  //------------------------------------------------------
  // Allocate the output data structure
  //------------------------------------------------------
  Retcode = AllocIDATPARR_Struc(HMEM_CTX_REF1 pTmpDatArrayDesc,Cnt);
  if(Retcode != ASN1_OP_OK) return(Retcode);
  DatArrayDesc = pTmpDatArrayDesc[0];
  DatArray = DatArrayDesc->ppArr;
  //-------------------------------------------------------------
  // Get the Elements (ASN.1 Certs) and copy to Destination Array
  //-------------------------------------------------------------
  DstIndex = 0;
  for(;;)
  {
    ActCertIndex = pCNArray[ActCNIndex + CN_CERTLIST_INDEX]; // Cert Index
    pCert = pCertList[ActCertIndex];		// Cert Structure pointer
    CopyIdataContents(DatArray[DstIndex],
		      pCert->Certificate->ppArr[0]);
    DstIndex++;    
    ActCNIndex = pCNArray[ActCNIndex + CN_P_INDEX];	// get parent index
    if(ActCNIndex == -1) break;				// no more parents
  }
  pDstCertsDesc[0] = DatArrayDesc;
  return(Retcode);
}

extern "C"  int VerifyLclCertChain(HMEM_CTX_DEF
		CTREESTR * pTreeStruc,
		int CNIndex, int TestModeFlags, int* pResult)
{
  int Retcode;

  int ActCNIndex, ActCertIndex;
  int DstIndex, CertCnt;

  int* pCNArray;

  X509CERT * pCert;
  X509CERT ** pCertList;
  X509CERT ** pCertChain;
  //------------------------------------------------------
  // check for NULL pointers
  //------------------------------------------------------
  if((pTreeStruc == NULL) || (pResult == NULL))
    return(ASN1_NULL_PTR);
  if(CNIndex < 0)
    return(ASN1_PARAM_ERR);

  pResult[0] = ASN1_ENDCERT_NOT_USABLE_MASK;
  //---------------------------------------------------------------
  // Get number of elements needed down to root
  //---------------------------------------------------------------
  ActCNIndex = CNIndex;

  pCNArray = pTreeStruc->CNodeArray;
  CertCnt  = pCNArray[ActCNIndex + CN_LEVEL]+1;		// get level+ base
  pCertList = pTreeStruc->ppCertList;		// get list
  //------------------------------------
  // Allocate the Certificate List Array
  //------------------------------------
  pCertChain = (X509CERT **)
    ((void *) BIT8_ARRAY_CALLOC(HMEM_CTX_REF,
				 1,CertCnt * sizeof(X509CERT *)));
  if(pCertChain == NULL)
    return(ASN1_ALLOC_ERR);
  //------------------------------------------------------
  // Get the Elements (ASN.1 Certs) and put to Chain Array
  //------------------------------------------------------
  DstIndex = 0;
  for(;;)
  {
    ActCertIndex = pCNArray[ActCNIndex + CN_CERTLIST_INDEX]; // Cert Index
    pCert = pCertList[ActCertIndex];		// Cert Structure pointer
    pCertChain[DstIndex] = pCert;
    DstIndex++;    
    ActCNIndex = pCNArray[ActCNIndex + CN_P_INDEX];	// get parent index
    if(ActCNIndex == -1)				// no more parents
      break;
  }
  //------------------------------------------------------
  // Verify the Chain from the Tree now
  //------------------------------------------------------
  Retcode = VerifyCertsChainEX(HMEM_CTX_REF1
	      pCertChain, CertCnt,
	      TestModeFlags, NULL, NULL, pResult, pTreeStruc, NULL);
  FREE_CARRAY(HMEM_CTX_REF,pCertChain);
  return(Retcode);
}

extern "C"  int BuildRootRDNsList(HMEM_CTX_DEF
		CTREESTR * pTreeStruc,
		IDATPARR** pDstRDNsDesc)
{
  int Retcode = ASN1_OP_OK;
  int RootListIndex = 0;
  int RootCount;

  int ActCNIndex;
  int ActRootIndex;

  IDATPARR* pTmpDatArrayDesc[1];
  IDATPARR* DstDatArrayDesc = NULL;

  X509CERT * Cert;

  char* pTmpDstBuf[1];

  int pTmpLen[1];
  //------------------------------------------------------
  // check for NULL pointers
  //------------------------------------------------------
  if((pTreeStruc == NULL) || (pDstRDNsDesc == NULL))
    return(ASN1_TO_ROOT_RDNLIST_NULLPTR);
  pDstRDNsDesc[0] = NULL;
  //------------------------------------------------------
  // check if at least 1 root present
  //------------------------------------------------------
  RootCount = pTreeStruc->RootCaCount;

  if(RootCount <= 0) return(ASN1_TO_ROOT_RDNLIST_NO_ROOTS);
  //------------------------------------------------------
  // Allocate the output data structure
  //------------------------------------------------------
  Retcode = AllocIDATPARR_Struc(HMEM_CTX_REF1 pTmpDatArrayDesc,RootCount);
  if(Retcode != ASN1_OP_OK)
    return(Retcode);
  DstDatArrayDesc = pTmpDatArrayDesc[0];
  DstDatArrayDesc->Flags |= FREE_BIT_MASK;	// assure freeing
  //------------------------------------------------------
  // Now we generate the names and load the output structure
  //------------------------------------------------------
  do
  {
    ActCNIndex =				// get index to Node array
      pTreeStruc->RootCaIndexArray[RootListIndex];
    ActRootIndex = 				// get index to Cert List
       pTreeStruc->CNodeArray[ActCNIndex+CN_CERTLIST_INDEX];

    Cert = pTreeStruc->ppCertList[ActRootIndex];	// get Certificate

    Retcode = ToASN1_DN(HMEM_CTX_REF1
			Cert->Subject, pTmpDstBuf, pTmpLen);

    if(Retcode != ASN1_OP_OK) break;

    Retcode = FromBufToDesc(HMEM_CTX_REF1
			    pTmpDstBuf[0], 0, pTmpLen[0],
			    RootListIndex, 0, pTmpDatArrayDesc);
    if(Retcode != ASN1_OP_OK) break;
    RootListIndex++;
    RootCount--;
  }while(RootCount != 0);
  if(Retcode == ASN1_OP_OK)
  {
    pDstRDNsDesc[0] = DstDatArrayDesc;
    return(Retcode);
  }
  FreeIDATPARR_Struc(HMEM_CTX_REF1 DstDatArrayDesc);
  return(Retcode);
}
/**
* Subroutine GetVectorLen decodes length in network order
* to 32 bit value (GetVectorLen).
* NOTE: no check on pointers is done
*      
*
*  @param SrcBuf Base of buffer
*  @param SrcOffset Start of data
*  @param SrcLen length of data
*  @param LenBytes number of bytes to convert,
*               1..3 are valid
*
*  @return BIT32 length >= 0 : length of data
* <br>            else error occurred
*/
static  int GetVectorLen(char* SrcBuf, int SrcOffset,
				      int SrcLen, int LenBytes)
{
  int DataLen=0;

  if((LenBytes <= 0) || (LenBytes > 3))
    return(ASN1_GET_VEC_LEN_LENCNT_ERR);
  if(SrcLen < (int) LenBytes)
    return(ASN1_GET_VEC_LEN_TOO_FEW_DATA);

  do
  {
    DataLen <<= 8;				// shift up 1 byte
    DataLen |= (int) SrcBuf[SrcOffset++] & 0xFF; // insert byte
    LenBytes--;
  }while(LenBytes != 0);
  return(DataLen);
}
/**
* Subroutine PutVectorLen encodes length for 32 bit value
* to network order and writes to buffer (PutVectorLen).
* NOTE: no check on pointers is done
*      
*
*  @param DstBuf Base of buffer
*  @param DstOffset Start of data
*  @param DataLength length to write
*  @param LenBytes number of bytes to convert,
*               1..3 are valid
*
*  @return ASN1_OP_OK on success, error code otherwise
* <br>            - else Error occurred
*/
static  int PutVectorLen(char* DstBuf, int DstOffset,
				    int DataLength, int LenBytes)
{
  int ShiftCount;

  int Mask;
  int DataLen = DataLength;

  if((LenBytes <= 0) || (LenBytes > 3))
    return(ASN1_PUT_VEC_LEN_LENCNT_ERR);

//  Mask = (0x00FFFFFF) >> (3-LenBytes)*8;	// test mask
  Mask = (0x00FFFFFF) >> ((3-LenBytes)*8);	// test mask
  if((DataLen & (~Mask)) != 0)			// too long for size
    return(ASN1_PUT_VEC_LEN_LENGTH_ERR);

  ShiftCount = LenBytes - 1;
  do
  {
    DstBuf[DstOffset++] = (unsigned char) (DataLen >> (ShiftCount*8)); // store value
    ShiftCount--;
    LenBytes--;
  }while(LenBytes != 0);
  return(ASN1_OP_OK);
}
/**
* Get index of the endcertificate from an unsorted list of
* certificates (GetEndcertFromList).
*
*  @param pCertsList List of certificates
*  @param CertsCount Number of certificates in list
*  @return int Index rel. 0 or -1 if none found
*/
static  int GetEndcertFromList(X509CERT ** pCertsList,
					   int CertsCount)
{
  int Index1,Index2,Retcode,Result;
  X509CERT * pCert1;
  X509CERT * pCert2;
  int pResult[1];

  if(CertsCount == 1)		// special case, only one element
    return(0);			// is endcert or root

  for(Index1=0;Index1<CertsCount;Index1++)
  {
    pCert1 = pCertsList[Index1];
    Result = 0;
    for(Index2=0;Index2<CertsCount;Index2++)
    {
      if(Index2 == Index1)	// do NOT compare with certificate self
        continue;
      pCert2 = pCertsList[Index2];

      Retcode = MatchCerts(pCert2,pCert1,CHAIN_MATCH,pResult);
      if(Retcode != ASN1_OP_OK)
        return(-1);
      if(pResult[0] == ASN1_SAME)	// found subject for 1st certificate
      {
        Result=1;
        break;
      }
    }
    if(Result == 0)
      return(Index1);
  }
  return(-1);
}
/**
* Get index of the issuer of a certificate from an unsorted list of
* certificates (GetCertIssuerFromList).
*
*  @param pCertsList List of certificates
*  @param CertsCount Number of certificates in list
*  @param pCert Certificate to check
*  @return int Index rel. 0 or -1 if none found
*/
static  int GetCertIssuerFromList(X509CERT ** pCertsList,
					      int CertsCount,
					      X509CERT * pCert)
{
  int Index,Retcode;
  X509CERT * pCert2;
  int pResult[1];

  for(Index=0;Index<CertsCount;Index++)
  {
    pCert2 = pCertsList[Index];
	if(pCert2 == NULL)
		continue;
    Retcode = MatchCerts(pCert,pCert2,CHAIN_MATCH,pResult);
    if(Retcode != ASN1_OP_OK)
      return(-1);
    if(pResult[0] == ASN1_SAME)
      return(Index);
  }
  return(-1);
}
/**
* Sort a certificate list by subject/issuer starting from
* endcertificate up to root (if present) (SortCertList).
*
*  @param pCertsInList Input List
*  @param pCertsOutList Output List
*  @param pCertsCount IN: Number of Certificates in the input list.
*                     OUT: Number of Certificates in the output list.
*  @return 0 on success, error code otherwise
*/
static  int SortCertList(X509CERT ** pCertsInList,
				     X509CERT ** pCertsOutList,
				     int* pCertsCount)
{
  int Index,IndexOut;
  X509CERT * pCert;

  int CertsCount = *pCertsCount;
  if(CertsCount == 1)
  {
    pCertsOutList[0] = pCertsInList[0];
	pCertsInList[0] = NULL;
    return(ASN1_OP_OK);
  }

  // 1. Get Endcertificate as first element
  Index = GetEndcertFromList(pCertsInList,CertsCount);
  if(Index == -1)			// none found, strange!
    return(ASN1_FROM_SSL_CERTLIST_LIST_ERR);
  pCertsOutList[0] = pCertsInList[Index];
  pCert = pCertsInList[Index];
  pCertsInList[Index] = NULL;

  // 2. Get Issuers for all others
  for(IndexOut=1;IndexOut<CertsCount;IndexOut++)
  {
    Index = GetCertIssuerFromList(pCertsInList,CertsCount,pCert);
    if(Index == -1)			// none found, strange!
      break;
    pCertsOutList[IndexOut] = pCertsInList[Index];
    pCert = pCertsInList[Index];
	pCertsInList[Index] = NULL;
  }
  *pCertsCount = IndexOut;
  return(ASN1_OP_OK);
}

extern "C"  int FromSSLCertListEX(HMEM_CTX_DEF
		char* SrcBuf,
		int SrcOffset, int SrcLen, X509CERT *** pCertList,
		int* pCertCnt, int* pCertListLen, int ProcessFlags)
{
  int Retcode = ASN1_OP_OK;
  int CertIndex = 0;
  int CertCnt = 0;

  int DataIndex;
  int DataLen;
  int ListLen;
  int ActCertLen;
  int ActDataLen;

  int pTmpCnt[1];

  IDATPARR* pTmpDatArrayDesc[1];
  IDATPARR* BufDatArrayDesc;

  IDATA** BufDatArray;
  IDATA* pIdata;

//  CERT_PTR pCert; // TEST TEST TEST

  X509CERT ** pTmpCertList[1];
  //------------------------------------------------------------
  // Check for null pointers
  //------------------------------------------------------------
  if((SrcBuf == NULL) || (pCertList == NULL) ||
     (pCertCnt == NULL) || (pCertListLen == NULL))
    return(ASN1_FROM_SSL_CERTLIST_NULL_PTR);

  pCertList[0]    = NULL;
  pCertCnt[0]     = 0;
  pCertListLen[0] = 0;

  if(SrcLen <= 0) return(ASN1_OP_OK);		// no data present
  DataLen   = SrcLen;
  DataIndex = SrcOffset; 
  //------------------------------------------------------------
  // get the length of the list
  //------------------------------------------------------------
  ListLen = GetVectorLen(SrcBuf,DataIndex,DataLen,3);
  if(ListLen < 0) return((int) ListLen);	// return Error code
  DataLen   -= 3;
  DataIndex += 3;
  if(ListLen == 0) return(ASN1_OP_OK);		// no certificate data
  //------------------------------------------------------------
  // now we count the number of Certificates in the list
  //------------------------------------------------------------
  ActDataLen = ListLen;
  do
  {
    ActCertLen = GetVectorLen(SrcBuf,DataIndex,DataLen,3); // get Certlen
    if(ActCertLen < 0) return((int) ActCertLen);	// return Error code
    if(ActCertLen != 0) CertCnt++;	// Cert with data
    ActCertLen += 3;			// include header
    DataLen   -= ActCertLen;		// reduce total datacount
    DataIndex += ActCertLen;		// to start of next
    ActDataLen -= ActCertLen;
  }while(ActDataLen > 0);    
  if(ActDataLen != 0)			// list encoding error !
    return(ASN1_FROM_SSL_CERTLIST_LIST_ERR);
  if(CertCnt == 0) return(ASN1_OP_OK);	// no certificates
  //----------------------------------------------------
  // Allocate / Initialize IDATA_Struc Array for the raw data
  //----------------------------------------------------
  Retcode = AllocIDATPARR_Struc(HMEM_CTX_REF1 pTmpDatArrayDesc,CertCnt);
  if(Retcode != ASN1_OP_OK) return(Retcode);
  BufDatArrayDesc = pTmpDatArrayDesc[0];
  BufDatArray = BufDatArrayDesc->ppArr;
  //-------------------------------------------------------
  // Load data structures with the certificate descriptions
  //-------------------------------------------------------
  DataLen    = SrcLen;			// dummy for inhibit checks
  ActDataLen = ListLen;
  DataIndex  = SrcOffset + 3; 		// start of list entries
  do
  {
    ActCertLen = GetVectorLen(SrcBuf,DataIndex,DataLen,3); // get Certlen
    DataIndex  += 3;
    ActDataLen -= 3;
    if(ActCertLen != 0)			// Cert with data
    {
      pIdata = BufDatArray[CertIndex++];	// get pointer
      pIdata->Base = SrcBuf;		// set base
      pIdata->Off  = DataIndex;		// set offset
      pIdata->Len  = (int) ActCertLen;	// set length          
    }
    DataIndex  += ActCertLen;		// to start of next
    ActDataLen -= ActCertLen;
  }while(ActDataLen > 0);    
  //-------------------------------------------------------
  // Check if we have received a duplicate root (Novell)
  //-------------------------------------------------------
  if(CertCnt > 1)
  {
    Retcode = MatchIDATPARRStrucs(BufDatArrayDesc,CertCnt-1,
				  BufDatArrayDesc,CertCnt-2,1);
    if(Retcode == ASN1_SAME)
    {
      BufDatArray[CertCnt-1] = NULL;	// discard last one
      BufDatArrayDesc->Cnt --;	// reduce number of elements
      CertCnt--;			// dto.
    }
  }

  //-------------------------------------------------------
  // Build the certificate chain in internal notation
  //-------------------------------------------------------
  Retcode = GetCertChainEX(HMEM_CTX_REF1
			 BufDatArrayDesc,
			 0,ProcessFlags,	// Type: ASN1, sorted/notSorted
			 NULL,0,		// no password
			 pTmpCertList,
                         pTmpCnt);
  FreeIDATPARR_Struc(HMEM_CTX_REF1 BufDatArrayDesc);		// free the array
  if(Retcode != ASN1_OP_OK) return(Retcode);

  pCertList[0]    = pTmpCertList[0];
  pCertCnt[0]     = CertCnt;
  pCertListLen[0] = ListLen+3;
  //-------------------------------------------------------
  // Sort the chain by subject/issuer now
  //-------------------------------------------------------

  pTmpCertList[0] = (X509CERT **)
      ((void *) BIT8_ARRAY_CALLOC(HMEM_CTX_REF,CertCnt, sizeof(X509CERT *)));
  pTmpCnt[0] = CertCnt;
  Retcode = SortCertList(pCertList[0],pTmpCertList[0],pTmpCnt);
  FreeCertList(HMEM_CTX_REF1 pCertList[0],CertCnt);
  if(Retcode != ASN1_OP_OK)
  {
    FREE_ARRAY(HMEM_CTX_REF,pTmpCertList[0]);
    return(Retcode);
  }

  pCertList[0] = pTmpCertList[0];
  pCertCnt[0] = pTmpCnt[0];

  return(Retcode);
}

extern "C"  int FromSSLCertList(HMEM_CTX_DEF
		char* SrcBuf,
		int SrcOffset, int SrcLen, X509CERT *** pCertList,
		int* pCertCnt, int* pCertListLen, int SortFlag)
{
  int ProcessFlags = 0;
  if(SortFlag != 0)
    ProcessFlags |= 0x01;
  return(FromSSLCertListEX(HMEM_CTX_REF1
			SrcBuf, SrcOffset, SrcLen,
			pCertList, pCertCnt, pCertListLen,
			ProcessFlags));
}

extern "C"  int FromSSL_DNList(HMEM_CTX_DEF
		char* SrcBuf,
		int SrcOffset, int SrcLen, X501_DN*** pDNList,
		int* pDNCnt, int* pDNListLen, int SortFlag)
{
  int Retcode = ASN1_OP_OK;
  int DNIndex = 0;
  int DNCnt = 0;
  int ActDNCnt;

  int DataIndex;
  int DataLen;
  int ListLen;
  int ActDNLen;
  int ActDataLen;

  int pTmpOff[1];
  int pTmpLen[1];

//  IDATPARR_PPTR pDatArrayDescArray;
  X501_DN* pActNameDesc;
  X501_DN** pNameDescArray;
  X501_DN* pTmpNameDesc[1];

  //------------------------------------------------------------
  // Check for null pointers
  //------------------------------------------------------------
  if((SrcBuf == NULL) || (pDNList == NULL) || (pDNCnt == NULL))
    return(ASN1_FROM_SSL_RDNLIST_NULL_PTR);

  pDNList[0]    = NULL;
  pDNCnt[0]     = 0;
  if(pDNListLen != NULL)
    pDNListLen[0] = 0;

  if(SrcLen <= 0) return(ASN1_OP_OK);		// no data present
  DataLen   = (int) SrcLen & 0xFFFF;
  DataIndex = (int) SrcOffset & 0xFFFF; 
  //------------------------------------------------------------
  // get the length of the list
  //------------------------------------------------------------
  ListLen = GetVectorLen(SrcBuf,DataIndex,DataLen,2);
  if(ListLen < 0) return((int) ListLen);	// return Error code
  DataLen   -= 2;
  DataIndex += 2;
  if(ListLen == 0) return(ASN1_OP_OK);		// no certificate data
  //------------------------------------------------------------
  // now we count the number of DNs in the list
  //------------------------------------------------------------
  ActDataLen = ListLen;
  do
  {
    ActDNLen = GetVectorLen(SrcBuf,DataIndex,DataLen,2); // get DN length
    if(ActDNLen < 0) return((int) ActDNLen);	// return Error code
    if(ActDNLen != 0) DNCnt++;		// DN with data
    ActDNLen += 2;			// include header
    DataLen   -= ActDNLen;		// reduce total datacount
    DataIndex += ActDNLen;		// to start of next
    ActDataLen -= ActDNLen;
  }while(ActDataLen > 0);    
  if(ActDataLen != 0)			// list encoding error !
    return(ASN1_FROM_SSL_RDNLIST_LIST_ERR);
  if(DNCnt == 0) return(ASN1_OP_OK);	// no RDNs
  //----------------------------------------------------
  // Allocate / Initialize X501_DN_PTR Array
  //----------------------------------------------------
  pNameDescArray = (X501_DN**)
    ((void *) BIT8_ARRAY_CALLOC(HMEM_CTX_REF,
				1,sizeof(X501_DN*) * DNCnt));
  if(pNameDescArray == NULL)
    return(ASN1_FROM_SSL_RDNLIST_ALLOC_ERR);
  //-------------------------------------------------------
  // Load data structures with the DN name descriptions
  //-------------------------------------------------------
  DNIndex    = 0;
  ActDNCnt   = DNCnt;
  DataLen    = SrcLen;			// dummy for inhibit checks
  ActDataLen = ListLen;
  DataIndex  = SrcOffset + 2; 		// start of list entries
  do
  {
    ActDNLen = GetVectorLen(SrcBuf,DataIndex,DataLen,2); // get RDN length
    DataIndex  += 2;
    if(ActDNLen != 0)			// DN with data
    {
      //-----------------------------------------------------------
      // Check if old format (ASN.1 set) or new (ASN.1 sequence)
      //-----------------------------------------------------------
      if(SrcBuf[DataIndex] == (ASN1_UNIVERSAL_SEQUENCE | ASN1_CONSTRUCTED))
      {
        //---------------------------------------------------------
        // new fromat, strip off the sequence
        //---------------------------------------------------------
        Retcode = FromASN1_Sequence(HMEM_CTX_REF1
				    SrcBuf, (int) DataIndex, (int) ActDNLen,
			            pTmpOff, pTmpLen);
        if(Retcode != ASN1_OP_OK)
          break;
        if(pTmpLen[0] > 0){
        Retcode = FromASN1_DN(HMEM_CTX_REF1
			      SrcBuf, pTmpOff[0], pTmpLen[0],
                              pTmpNameDesc);
        } else {
             pTmpNameDesc[0] = NULL;
             DNCnt--;
        }
      }
      else
      {
        //---------------------------------------------------------
        // old format, just concatenation of ASN.1 sets
        //---------------------------------------------------------
        Retcode = FromASN1_DN(HMEM_CTX_REF1
			      SrcBuf,(int) DataIndex, (int) ActDNLen,
                              pTmpNameDesc);
      }
      if(Retcode != ASN1_OP_OK) break;

        if(pTmpNameDesc[0] != NULL){
        pActNameDesc = pTmpNameDesc[0];
        pNameDescArray[DNIndex++] = pActNameDesc;			// load

        if(SortFlag == 0)
        {
          Retcode = SortASN1_DN(pActNameDesc);
          if(Retcode != ASN1_OP_OK) break;
        }
      }
    }

    DataIndex  += ActDNLen;		// to start of next
    ActDNCnt--;
  }while(ActDNCnt != 0);    
  if(Retcode == ASN1_OP_OK)
  {
    pDNList[0]     = pNameDescArray;
    pDNCnt[0]      = DNCnt;
    if(pDNListLen != NULL)
      pDNListLen[0]  = (int) (ListLen + 3);
    return(Retcode);
  }

  if(pNameDescArray != NULL)
  {
    DNIndex = 0;
    ActDNCnt = DNCnt;
    do
    {
      FreeX501DN_Struc(HMEM_CTX_REF1 pNameDescArray[DNIndex++]);
      ActDNCnt--;
    }while(ActDNCnt != 0);
    FREE_ARRAY(HMEM_CTX_REF,pNameDescArray);
  }
  return(Retcode);
}

/**
* Subroutine ToSSL_List converts list in internal
* notation to a SSL list (ToSSL_List).
* Note: A buffer will be alloceted for the destination list
*       so that it can be freed when no longer used without
*	 affecting the internal certificates.
*
*               IDATPARR_PTR pRDNDesc[] RDN list base
*  @param HeaderLen additional buffer length
*  @param VectorLenBytes number of bytes for Vector
*  @param pDstBuf Pointer to buffer
*  @param pDstLen Length of list
*
*  @return ASN1_OP_OK on success, error code otherwise
* <br>            - else Error occurred
*/
static  int ToSSL_List(HMEM_CTX_DEF
		IDATPARR* pListDesc, int HeaderLen,
		int VectorLenBytes, char** pDstBuf, int* pDstLen)
{
  int Retcode = ASN1_OP_OK;
  int ListCnt;
  int ListIndex = 0;
  int ActListCnt;
  int SrcOffset;
  int SrcLen;

  int DstIndex = (int) HeaderLen;
  int BufLen;
  int ListLen = 0;

  IDATA** ListDatArray;
  IDATA* pIdata;
  
  char* DstBuf;
  char* SrcBase;

  //------------------------------------------------------------
  // Check for null pointers
  //------------------------------------------------------------
  if((pListDesc == NULL) || (pDstBuf == NULL) || (pDstLen == NULL))
    return(ASN1_TO_SSL_LIST_NULL_PTR);

  pDstBuf[0]    = NULL;
  pDstLen[0]     = 0;

  ListDatArray = pListDesc->ppArr;
  ListCnt      = pListDesc->Cnt;

  //--------------------------------------------------------
  // check for empty list
  //--------------------------------------------------------
  if(ListCnt == 0)
  {
    if(HeaderLen == 0)			// no additional header data
      return(ASN1_OP_OK);		// no data present
    else
    {
      DstBuf = BIT8_ARRAY_ALLOC_POOL(HMEM_CTX_REF,HeaderLen);
      if(DstBuf == NULL)
        return(ASN1_TO_SSL_LIST_ALLOC_ERR);
      else
      {
        pDstBuf[0] = DstBuf;
        pDstLen[0] = HeaderLen;
        return(ASN1_OP_OK);		// only header buffer
      }
    }
  }
  //------------------------------------------------------------
  // Get required total size of buffer
  //------------------------------------------------------------
  ActListCnt = ListCnt;
  do
  {
    pIdata = ListDatArray[ListIndex++];

    SrcBase = pIdata->Base;
    SrcLen  = pIdata->Len;
    if((SrcBase != NULL) && (SrcLen != 0))
      ListLen += ((int) SrcLen + VectorLenBytes);
    ActListCnt--;
  }while(ActListCnt != 0);
  //--------------------------------------------------------
  // check again for empty list
  //--------------------------------------------------------
  if(ListLen == 0)
  {
    if(HeaderLen == 0)			// no additional header data
      return(ASN1_OP_OK);		// no data present
    else
    {
      DstBuf = BIT8_ARRAY_ALLOC_POOL(HMEM_CTX_REF,HeaderLen);
      if(DstBuf == NULL)
        return(ASN1_TO_SSL_LIST_ALLOC_ERR);
      else
      {
        pDstBuf[0] = DstBuf;
        pDstLen[0] = HeaderLen;
        return(ASN1_OP_OK);		// only header buffer
      }
    }
  }
  BufLen = ListLen + VectorLenBytes + HeaderLen;
  //------------------------------------------------------------
  // Allocate required buffer space
  //------------------------------------------------------------
  DstBuf = BIT8_ARRAY_ALLOC_POOL(HMEM_CTX_REF,(int) BufLen);
  if(DstBuf == NULL)
    return(ASN1_TO_SSL_LIST_ALLOC_ERR);
  for(;;)					// Error FOR
  {
    //------------------------------------------------------------
    // generate the list from the elements
    //------------------------------------------------------------
    Retcode = PutVectorLen(DstBuf, DstIndex, ListLen, // set length
			   VectorLenBytes);
    if(Retcode != ASN1_OP_OK) break;
    DstIndex += VectorLenBytes;
    ActListCnt = ListCnt;
    ListIndex = 0;
    do
    {
      pIdata = ListDatArray[ListIndex++];
      SrcBase = pIdata->Base;
      SrcLen  = pIdata->Len;
      if((SrcBase != NULL) && (SrcLen != 0))
      {
        Retcode = PutVectorLen(DstBuf, DstIndex, (int) SrcLen,
			       VectorLenBytes);			 // length
        if(Retcode != ASN1_OP_OK)
          break;
        DstIndex += VectorLenBytes;
        SrcOffset = (int) pIdata->Off;
	memcpy(DstBuf+DstIndex,SrcBase+SrcOffset,SrcLen);
        DstIndex += SrcLen;
      }
      ActListCnt--;
    }while(ActListCnt != 0);
    break;
  } // Error FOR
  if(Retcode == ASN1_OP_OK)
  {
    pDstBuf[0] = DstBuf;
    pDstLen[0] = BufLen;
    return(Retcode);
  }
  FREE_ARRAY_POOL(HMEM_CTX_REF,DstBuf);
  return(Retcode);
}

extern "C"  int ToSSLCertList(HMEM_CTX_DEF
		IDATPARR* pCertsDesc,
		int HdrLen, char** pDstBuf, int* pDstLen)
{
  return(ToSSL_List(HMEM_CTX_REF1 pCertsDesc,HdrLen, 3, pDstBuf, pDstLen));
}

extern "C"  int ToSSL_RDNList(HMEM_CTX_DEF
		IDATPARR* pRDNsDesc,
		int HdrLen,char** pDstBuf, int* pDstLen,
		int FormatType)
{
  int Retcode;
  int Index;
  int Count;

  char* ppTmpDstBuf[1];
  int pTmpDstLen[1];

  IDATA* pSrcIdata;
  IDATA* pDstIdata;
  IDATA** pSrcIdataArr;
  IDATA** pDstIdataArr;

  IDATPARR* pSeqRdnDesc = NULL;
  IDATPARR* ppTmpDesc[1];

  if(FormatType != 0)			// new Format !!!
  {
    //----------------------------------------------------------
    // Allocate helper Array Descriptor
    //----------------------------------------------------------
    Count = pRDNsDesc->Cnt;		// get elements
    Retcode = AllocIDATPARR_Struc(HMEM_CTX_REF1 ppTmpDesc, Count);
    if(Retcode != ASN1_OP_OK)
      return(ASN1_TO_SSL_LIST_ALLOC_ERR);
    pSeqRdnDesc = ppTmpDesc[0];

    pSeqRdnDesc->Flags |= FREE_BIT_MASK; // set Auto-Free mode

    pSrcIdataArr = pRDNsDesc->ppArr;
    pDstIdataArr = pSeqRdnDesc->ppArr;

    //----------------------------------------------------------
    // Generate Sequence surrounded buffers for the list
    //----------------------------------------------------------
    Index = 0;
//  Retcode = ASN1_OP_OK;
    do
    {
      pSrcIdata = pSrcIdataArr[Index];      
      pDstIdata = pDstIdataArr[Index];      

      Retcode = ToASN1_Sequence(HMEM_CTX_REF1
				pSrcIdata->Base,
				(int) pSrcIdata->Off,
				pSrcIdata->Len,
				ppTmpDstBuf,
				pTmpDstLen);
      if(Retcode != ASN1_OP_OK)
        break;

      pDstIdata->Base = ppTmpDstBuf[0];
      pDstIdata->Off  = 0;
      pDstIdata->Len  = pTmpDstLen[0];

      Index++;
    }while(Index < Count);
    if(Retcode != ASN1_OP_OK)
    {
      FreeIDATPARR_Struc(HMEM_CTX_REF1 pSeqRdnDesc);
      return(Retcode);
    }
    pRDNsDesc = pSeqRdnDesc;		// use other source !
  } // new Format

  //--------------------------------------------------------------
  // Convert the Array to a list now
  //--------------------------------------------------------------
  Retcode = ToSSL_List(HMEM_CTX_REF1
		       pRDNsDesc,HdrLen, 2, pDstBuf, pDstLen);
  if(pSeqRdnDesc != NULL)
    FreeIDATPARR_Struc(HMEM_CTX_REF1 pSeqRdnDesc);
  return(Retcode);
}

//()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()
//
// Certificate Displaying Helper functions
//
//()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()
/**
* Subroutine FromBytes_ToHexString converts byte array to
* Hex Characterstring in internal representation
* (BIGwords with leading ElementCount) (FromBytes_ToHexStringPriv).
*
* NOTE: Number of String Elements is limited to 10000 !
*      
*
*  @param SrcBuf Base of SrcBuf
*  @param SrcOff Start of Data
*  @param SrcLen length of buffer
*  @param pDstBuf Allocated Element
*  @return ASN1_OP_OK on success, error code otherwise
* <br>            - else Error occurred
*/
static  int FromBytes_ToHexStringPriv(HMEM_CTX_DEF
		char* SrcBuf, int SrcOff,
		int SrcLen, char** pDstBuf)
{
  char	c,c1;

  int SrcIndex = SrcOff;
  int DstIndex=0;

  char* pBuf = NULL;
  //-----------------------------------------
  // Check pointers
  //-----------------------------------------
  if((SrcBuf == NULL) || (pDstBuf == NULL))
    return(ASN1_FROM_BYTES_NULLPTR_ERR);
  pDstBuf[0] = NULL;
  if(SrcLen == 0)
    return(ASN1_OP_OK);
  if(SrcLen > (0x7FFF-8))		// max. length
    return(ASN1_FROM_BYTES_INV_LEN_ERR);
  //-------------------------------------------------
  // Allocate required destination buffer
  //-------------------------------------------------
  pBuf = BIT8_ARRAY_ALLOC(HMEM_CTX_REF,(int) (SrcLen*2+1)*2);// 2 nibbles per byte to word!
  if(pBuf == NULL)
    return(ASN1_FROM_BYTES_ALLOC_ERR);
  //-------------------------------------------------
  // Set Element Count, convert to HEX
  //-------------------------------------------------
  BIGword2char((SrcLen*2),pBuf,DstIndex);	// set element count * 2
  do
  {
    c = SrcBuf[SrcIndex++];			// get byte
    c1 = (unsigned char) ((c & 0x0F) + (unsigned char) '0');	// low nibble to ASCII
    if(c1 > (unsigned char) '9') c1 += 7;		// to HEX
    c = (unsigned char) (((c>>4) & 0x0F) + (unsigned char) '0');	// high nibble to ASCII
    if(c > (unsigned char) '9') c += 7;			// to HEX
    pBuf[DstIndex++] = 0;			// clear MSB
    pBuf[DstIndex++] = c;			// Store high nibble
    pBuf[DstIndex++] = 0;			// clear MSB
    pBuf[DstIndex++] = c1;			// Store low nibble
    SrcLen--;
  }while(SrcLen != 0);
  pDstBuf[0] = pBuf;
  return(ASN1_OP_OK);
}

/**
* Frees a <code>BIT8PTR</code> array and all its elements (Free_BIT8PTR_Array).
*
*  @param pArr Array pointer
*  @param ElementCnt Length of array
*/
extern "C"  void Free_BIT8PTR_Array(HMEM_CTX_DEF
			char** pArr, int ElementCnt)
{
  int Index;

  if(pArr == NULL)
    return;
  //----------------------------------------------------
  // Free the Elements in the Array
  //----------------------------------------------------
  Index = 0;
  while(Index < ElementCnt)
  {
    FREE_ARRAY(HMEM_CTX_REF,pArr[Index]);
    Index++;
  }
  FREE_ARRAY(HMEM_CTX_REF,pArr);
}
/**
* Allocs a <code>BIT8PTR</code> array (Alloc_BIT8PTR_Array).
*
*  @param ElementCnt Requested size of the array
*  @return New <code>BIT8PTR</code> array / NULL
*/
extern "C"  char** Alloc_BIT8PTR_Array(HMEM_CTX_DEF
					int ElementCnt)
{
  char** pArr;

  if(ElementCnt <= 0)
    return(NULL);
  pArr = (char**)
           ((void *) BIT8_ARRAY_CALLOC(HMEM_CTX_REF,
			  	       1, sizeof(char*) * ElementCnt));
  return(pArr);
}

/**
* Frees a <code>HCERWTXT</code> structure and its elements (Free_HCERWTXT_Struc).
*
*  @param pCertWTxtStruc Structure to be freed
*/
extern "C"  void Free_HCERWTXT_Struc(HMEM_CTX_DEF
			HCERWTXT * pCertWTxtStruc)
{
  if(pCertWTxtStruc == NULL)
    return;
  //------------------------------------------------------
  // Free Issuer's/Subject's RDN WText Array(s) if present
  //------------------------------------------------------
  Free_BIT8PTR_Array(HMEM_CTX_REF1
		     pCertWTxtStruc->pIssuerWTxtArr,
		     pCertWTxtStruc->IssuerWTxtCnt);
  Free_BIT8PTR_Array(HMEM_CTX_REF1
		     pCertWTxtStruc->pSubjectWTxtArr,
		     pCertWTxtStruc->SubjectWTxtCnt);
  //------------------------------------------------------
  // Free the Display- SerialNumber- and Fingerprint Texts
  //------------------------------------------------------
  FREE_CARRAY(HMEM_CTX_REF,pCertWTxtStruc->pIssuerDispWTxt);
  FREE_CARRAY(HMEM_CTX_REF,pCertWTxtStruc->pSubjectDispWTxt);
  FREE_CARRAY(HMEM_CTX_REF,pCertWTxtStruc->pSerialNumWTxt);
  FREE_CARRAY(HMEM_CTX_REF,pCertWTxtStruc->pMD5FingerPrintWTxt);
  //------------------------------------------------------
  // Free the Structure self
  //------------------------------------------------------
  FREE_CARRAY(HMEM_CTX_REF,pCertWTxtStruc);
}
/**
* Allocate a HCERWTXT Structure, initialize it (Alloc_HCERWTXT_STRUC).
*
*  @param WTxtArraySize Number of Slots for Text arr. alloc
*  @return HCERWTXT_PTR pStruc / NULL
*/
static  HCERWTXT * Alloc_HCERWTXT_STRUC(HMEM_CTX_DEF
			int WTxtArraySize)
{
  HCERWTXT * pCertWTxtStruc;
  //------------------------------------------------------
  // Allocate the Structure
  //------------------------------------------------------
  pCertWTxtStruc = (HCERWTXT *)
    ((void *) BIT8_ARRAY_CALLOC(HMEM_CTX_REF,
				1, sizeof(HCERWTXT)));
  if(pCertWTxtStruc == NULL)
    return(NULL);
  //-------------------------------------------------
  // Allocate Issuer/Subject WTxt Arrays if requested
  //-------------------------------------------------
  if(WTxtArraySize > 0)
  {
    if((pCertWTxtStruc->pIssuerWTxtArr =
	Alloc_BIT8PTR_Array(HMEM_CTX_REF1 WTxtArraySize)) == NULL)
    {
      FREE_ARRAY(HMEM_CTX_REF,pCertWTxtStruc);
      return(NULL);
    }

    if((pCertWTxtStruc->pSubjectWTxtArr =
	Alloc_BIT8PTR_Array(HMEM_CTX_REF1 WTxtArraySize)) == NULL)
    {
      FREE_ARRAY(HMEM_CTX_REF,pCertWTxtStruc->pSubjectWTxtArr);
      FREE_ARRAY(HMEM_CTX_REF,pCertWTxtStruc);
      return(NULL);
    }
    pCertWTxtStruc->IssuerWTxtCnt  = WTxtArraySize;
    pCertWTxtStruc->SubjectWTxtCnt = WTxtArraySize;
  }
  return(pCertWTxtStruc);
}

extern "C"  void Free_HCERWTXT_StrucArr(HMEM_CTX_DEF
	HCERWTXT ** pCertWTxtStrucArr,int ElementCnt)
{
  int Index;

  if(pCertWTxtStrucArr == NULL)
    return;

  Index = 0;
  while(Index < ElementCnt)
  {
    Free_HCERWTXT_Struc(HMEM_CTX_REF1
			pCertWTxtStrucArr[Index]);
//  pCertWTxtStrucArr[Index] = NULL;
    Index++;
  }
  FREE_CARRAY(HMEM_CTX_REF,pCertWTxtStrucArr);
}
/**
* Allocate an Array of HCERWTXT Structures, and the respective
* RDN WTxtArrays if requested (Alloc_HCERWTXT_StrucArr).
*
*  @param ElementCnt Number of structures needed
*  @param WTxtArraySize Slots for Issuer/Subject
*  @return HCERWTXT_PPTR pCertWTxtStrucArr / NULL
*/
static  HCERWTXT ** Alloc_HCERWTXT_StrucArr(HMEM_CTX_DEF
		int ElementCnt, int WTxtArraySize)
{
  int Index;
  HCERWTXT ** pCertWTxtStrucArr;

  if(ElementCnt <= 0)
    return(NULL);

  pCertWTxtStrucArr = (HCERWTXT **)
	((void *) BIT8_ARRAY_CALLOC(HMEM_CTX_REF,
				    1, sizeof(HCERWTXT *) * ElementCnt));
  if(pCertWTxtStrucArr == NULL)
    return(NULL);

  Index = 0;
  while(Index < ElementCnt)
  {
    if((pCertWTxtStrucArr[Index] =
       Alloc_HCERWTXT_STRUC(HMEM_CTX_REF1
			    WTxtArraySize)) == NULL)
      break;
    Index++;
  }
  if(Index != ElementCnt)
  {
    Free_HCERWTXT_StrucArr(HMEM_CTX_REF1
			   pCertWTxtStrucArr, ElementCnt);
    return(NULL);
  }
  return(pCertWTxtStrucArr);
}

/**
* Move Buffer Pointers from IDATPARR Structure to a BIT8PTR Array (MoveDescBufsToArray).
* NOTE: it is assumed that there are no offsets into the buffers.
*       (all buffers were local allocated)
*
*  @param pDesc Source for move
*  @param pDstArr Destination of Move
*  @param DstLen Number of slots available
*  @return 0 on success, error code otherwise
*/
static  int MoveDescBufsToArray(HMEM_CTX_DEF
	IDATPARR* pDesc, char** pDstArr, int DstLen)
{
  int Count, Index;

  char* pBuf;
  IDATA* pIdata;
  IDATA** ppArr;

  if((pDesc == NULL) || ((ppArr = pDesc->ppArr) == NULL) ||
     (pDstArr == NULL))
    return(ASN1_NULL_PTR);

  Count = pDesc->Cnt;
  if((Count <= 0) || (Count > DstLen))
    return(ASN1_PARAM_ERR);

  Index = 0;
  while(Index < Count)
  {
    pBuf = NULL;
    pIdata = ppArr[Index];
    if(pIdata != NULL)			// Element is present
    {
      pBuf = pIdata->Base;	// get buffer pointer/NULL
      if(pIdata->Len <= 0)	// is an empty buffer
        FREE_ARRAY(HMEM_CTX_REF,pBuf);	// free it and set NULL

      pIdata->Base = NULL;	// remove
      pIdata->Off = 0;      
      pIdata->Len = 0;
    }
    pDstArr[Index] = pBuf;
    Index++;
  }
  return(ASN1_OP_OK);
}

/**
* Get number of Elements from an internal String representation,
* check consistency (GetWStringElementCnt).
*
*  @param pIdata Element containing String
*  @return int ElementCnt - number of Elements
*/
static  int GetWStringElementCnt(IDATA* pIdata)
{

  int Offset,Len,ElementCount;
  char* pBuf;

  if((pIdata == NULL) || ((pBuf = pIdata->Base) == NULL) ||
     ((Len = pIdata->Len) < 2) || ((Len & 0x01) != 0))
    return(0);
  //-----------------------------------------------------
  // Extract Element count from header, check consistency
  //-----------------------------------------------------
  Offset = (int) pIdata->Off;  
  ElementCount = (((int) pBuf[Offset] & 0xFF) << 8) |
                  ((int) pBuf[Offset+1] & 0xFF);
  if((ElementCount <= 0) || (((ElementCount * 2) + 2) > Len))
    return(0);
  return(ElementCount);
}

/**
* Generate Displayable text from RDN IDATPARR (Issuer/Subject) (WriteCertInfoToTxtArray).
* - select CommonName and/or OrganizationName and/or Org.UnitName
*   as displayable string (max. 2 if more present selected)
*
*  @param pRDNDesc RDN Descriptor
*               BIT8PTR ppbyDstBuf[] Destination buffer, allocated
*  @return 0 on success, error code otherwise
*/
static  int WriteCertInfoToTxtArray(HMEM_CTX_DEF
	IDATPARR* pRDNDesc, char** ppDstBuf)
{
  int 	Len, ElementCnt, SrcIndex, DstIndex;

  int CommonNameElementCnt = 0;
  int OrganizationNameElementCnt = 0;
  int OrganizationUnitElementCnt = 0;

  int Src1NameIDLen  = 0;
  int Src1ElementCnt = 0;
  int Src2NameIDLen  = 0;
  int Src2ElementCnt = 0;

  char* pSrc1NameIDStr = NULL;
  char* pSrc2NameIDStr = NULL;
  char* pDstBuf;

  char ComNameIDStrBuf[2] = {(unsigned char) 'C', (unsigned char) 'N'};
  char OrgNameIDStrBuf[1] = {(unsigned char) 'O'};
  char OrgUnitIDStrBuf[2] = {(unsigned char) 'O', (unsigned char) 'U'};

  IDATA* pIdata;
  IDATA* pSrc1Idata = NULL;
  IDATA* pSrc2Idata = NULL;
  IDATA* pCommonNameIdata = NULL;
  IDATA* pOrganizationNameIdata = NULL;
  IDATA* pOrganizationUnitIdata = NULL;
  IDATA** ppArr;
  //------------------------------------------------------------
  // Get Elements for CommonName, Organization, OrganizationUnit
  //------------------------------------------------------------
  ppArr  = pRDNDesc->ppArr;
  pIdata = ppArr[RDN_COMMON_NAME_INDEX];
  if((ElementCnt = GetWStringElementCnt(pIdata)) > 0)
  {
    pCommonNameIdata     = pIdata;
    CommonNameElementCnt = ElementCnt;
  }
  pIdata = ppArr[RDN_ORGANIZATION_NAME_INDEX];
  if((ElementCnt = GetWStringElementCnt(pIdata)) > 0)
  {
    pOrganizationNameIdata     = pIdata;
    OrganizationNameElementCnt = ElementCnt;
  }
  pIdata = ppArr[RDN_ORGANIZATION_UNIT_INDEX];
  if((ElementCnt = GetWStringElementCnt(pIdata)) > 0)
  {
    pOrganizationUnitIdata     = pIdata;
    OrganizationUnitElementCnt = ElementCnt;
  }
  //------------------------------------------------------------
  // Select Elements to use for Copy
  //------------------------------------------------------------
  if(pCommonNameIdata != NULL)
  {
    pSrc1Idata     = pCommonNameIdata;
    Src1ElementCnt = CommonNameElementCnt;
    pSrc1NameIDStr = ComNameIDStrBuf;
    Src1NameIDLen  = 2;
    if(pOrganizationNameIdata != NULL)
    {
      pSrc2Idata     = pOrganizationNameIdata;
      Src2ElementCnt = OrganizationNameElementCnt;
      pSrc2NameIDStr = OrgNameIDStrBuf;
      Src2NameIDLen  = 1;
    }
    else if(pOrganizationUnitIdata != NULL)
    {
      pSrc2Idata     = pOrganizationUnitIdata;
      Src2ElementCnt = OrganizationUnitElementCnt;
      pSrc2NameIDStr = OrgUnitIDStrBuf;
      Src2NameIDLen  = 2;
    }
  }
  else if(pOrganizationNameIdata != NULL)
  {
    pSrc1Idata     = pOrganizationNameIdata;
    Src1ElementCnt = OrganizationNameElementCnt;
    pSrc1NameIDStr = OrgNameIDStrBuf;
    Src1NameIDLen  = 1;
    if(pOrganizationUnitIdata != NULL)
    {
      pSrc2Idata     = pOrganizationUnitIdata;
      Src2ElementCnt = OrganizationUnitElementCnt;
      pSrc2NameIDStr = OrgUnitIDStrBuf;
      Src2NameIDLen  = 2;
    }
  }
  else if(pOrganizationUnitIdata != NULL)
  {
    pSrc1Idata     = pOrganizationUnitIdata;
    Src1ElementCnt = OrganizationUnitElementCnt;
    pSrc1NameIDStr = OrgUnitIDStrBuf;
    Src1NameIDLen  = 2;
  }
  //----------------------------------------------------------
  // Allocate required Destination buffer, size:
  // Source1 (ID-StrLen + 1)*2 + ElementCnt*2
  // Source2 (ID-StrLen + 1)*2 + ElementCnt*2
  // + 2 byte Element Count and 2 Byte for ',' delimiter
  //----------------------------------------------------------
  Len = (Src1NameIDLen+1)*2 + (Src1ElementCnt*2) +
        (Src2NameIDLen+1)*2 + (Src2ElementCnt*2) + 4;
  if((pDstBuf = BIT8_ARRAY_ALLOC(HMEM_CTX_REF,Len)) == NULL)
    return(ASN1_ALLOC_ERR);
  //----------------------------------------------------------
  // Copy the Element(s) --if any-- to destination
  //----------------------------------------------------------
  DstIndex = 2;
  if(Src1ElementCnt != 0)			// at least one present
  {
    SrcIndex = 0;
    while(SrcIndex < Src1NameIDLen)
    {
      pDstBuf[DstIndex++] = 0;
      pDstBuf[DstIndex++] = pSrc1NameIDStr[SrcIndex++];
    }      
    pDstBuf[DstIndex++] = 0;
    pDstBuf[DstIndex++] = (unsigned char) '=';

    Len = Src1ElementCnt*2;
    memcpy(pDstBuf+DstIndex,pSrc1Idata->Base+(int) pIdata->Off + 2,Len);
    DstIndex += Len;
    if(Src2ElementCnt != 0)
    {
      pDstBuf[DstIndex++] = 0;
      pDstBuf[DstIndex++] = (unsigned char) ',';
      SrcIndex = 0;
      while(SrcIndex < Src2NameIDLen)
      {
        pDstBuf[DstIndex++] = 0;
        pDstBuf[DstIndex++] = pSrc2NameIDStr[SrcIndex++];
      }      
      pDstBuf[DstIndex++] = 0;
      pDstBuf[DstIndex++] = (unsigned char) '=';

      Len = Src2ElementCnt*2;
      memcpy(pDstBuf+DstIndex,pSrc2Idata->Base+(int) pIdata->Off + 2,Len);
      DstIndex += Len;
    }
  }
  //------------------------------------------------------
  // Set the Element count
  //------------------------------------------------------
  ElementCnt = (DstIndex - 2)/2;
  pDstBuf[0] = (unsigned char) (ElementCnt >> 8);
  pDstBuf[1] = (unsigned char) ElementCnt;
  ppDstBuf[0] = pDstBuf;
  return(ASN1_OP_OK);
}

/**
* Generate Displayable text from a HEX formatted internal string (WriteHexInfoToTxtArray).
* - insert ':' between the ASCII byte representation
*
*  @param pSrcBuf Source Buffer with HEX ASCII
*  @param ppDstBuf Destination buffer, allocated
*  @return 0 on success, error code otherwise
*/
static  int WriteHexInfoToTxtArray(HMEM_CTX_DEF
			char* pSrcBuf,
			char** ppDstBuf)
{
  int	ElementCnt, BufLen, DstIndex, SrcIndex; 
  char*   pDstBuf;
  //--------------------------------------------------
  // Check parameters first
  //--------------------------------------------------
  if((pSrcBuf == NULL) || (ppDstBuf == NULL))
    return(ASN1_NULL_PTR);
  //----------------------------------------------------
  // Get number of Input Elements, check if any and EVEN 
  //----------------------------------------------------
  ElementCnt = (((int) pSrcBuf[0] & 0xFF) << 8) |
                ((int) pSrcBuf[1] & 0xFF);
  if((ElementCnt & 0x01) != 0)
    return(ASN1_PARAM_ERR);
  if(ElementCnt <= 0)
    return(ASN1_OP_OK);
  //------------------------------------------------------
  // Calculate required destination buffer size, allocate:
  // 2 Elements form a HEX Output Element so (n/2-1)
  // Delimiters must be inserted 
  //------------------------------------------------------
  BufLen = (ElementCnt * 2) + (((ElementCnt/2) - 1) * 2) + 2;
  if((pDstBuf = BIT8_ARRAY_ALLOC(HMEM_CTX_REF,BufLen)) == NULL)
    return(ASN1_ALLOC_ERR);
  //---------------------------------------------
  // Copy Source Elements to destination
  //---------------------------------------------
  SrcIndex = 2;				// Start past Element Count
  DstIndex = 2;				// dto.
  while(ElementCnt > 0)
  {
    // Copy 2 Elements, check if more Elements
    memcpy(pDstBuf+DstIndex,pSrcBuf+SrcIndex,4);
    SrcIndex += 4;
    DstIndex += 4;
    ElementCnt -= 2;
    if(ElementCnt > 0)
    {
      pDstBuf[DstIndex++] = 0;
      pDstBuf[DstIndex++] = (unsigned char) ':';
    }
  }
  //---------------------------------------------
  // set new Element Count
  //---------------------------------------------
  ElementCnt = (DstIndex - 2) / 2;
  pDstBuf[0] = (unsigned char) (ElementCnt >> 8);
  pDstBuf[1] = (unsigned char) ElementCnt;
  ppDstBuf[0] = pDstBuf;
  return(ASN1_OP_OK);
}

extern "C"  int PrepCertWTxtsList(HMEM_CTX_DEF
	X509CERT ** pCertList,
	int CertsCnt, HCERWTXT *** ppCertsWTxtArr,
	char* pChainDigest)
{
  int Retcode, Index;

  char MD5DigestBuf[MD5_DIGEST_LEN];
  int MD5Array[MD5_ARRAY_SIZE];
  int SHA1Array[SHA_ARRAY_SIZE];

  char* pBuf = NULL;
  char* ppTmpBuf[1];

  IDATA* pIdata;
  IDATPARR* pRDNNamesDesc = NULL;
  IDATPARR* ppTmpDesc[1];

  X509CERT * pActCert;

  HCERWTXT * pActCertWTxtStruc;
  HCERWTXT ** pCertsWTxtStrucArr = NULL;

  ppCertsWTxtArr[0] = NULL;
  //----------------------------------------------------------
  // Allocate new Array of Structures for all the Certificates
  //----------------------------------------------------------
  if((pCertsWTxtStrucArr = Alloc_HCERWTXT_StrucArr(HMEM_CTX_REF1
		CertsCnt,RDN_ARRAY_MAX_DATA_INDEX)) == NULL)
    return(ASN1_ALLOC_ERR);
  //----------------------------------------------------------
  // Initialize the Chain SHA1 hash
  //----------------------------------------------------------
  SHA1_Init(SHA1Array);

  Index = 0;
  Retcode = ASN1_OP_OK;
  while(Index < CertsCnt)
  {
    pActCert = pCertList[Index];
    pActCertWTxtStruc = pCertsWTxtStrucArr[Index];
    //---------------------------------------------------------
    // Generate the Issuer RDN text Elements  
    //---------------------------------------------------------
    if((Retcode = FromASN1_DN_ToStringArray(HMEM_CTX_REF1
			pActCert->Issuer,
			ppTmpDesc)) != ASN1_OP_OK)
      break;

    pRDNNamesDesc = ppTmpDesc[0];
    //----------------------------------------------------------
    // Generate the Issuer Display WTxtx String
    //----------------------------------------------------------
    Retcode = WriteCertInfoToTxtArray(HMEM_CTX_REF1
				      pRDNNamesDesc, ppTmpBuf);
    if(Retcode != ASN1_OP_OK)
      break;
    pActCertWTxtStruc->pIssuerDispWTxt = ppTmpBuf[0];
    //----------------------------------------------------------
    // Put the Elements From Descriptor to the Issuer WTxt Array
    //----------------------------------------------------------
    if((Retcode = MoveDescBufsToArray(HMEM_CTX_REF1
		    pRDNNamesDesc,
		    pActCertWTxtStruc->pIssuerWTxtArr,
		    pActCertWTxtStruc->IssuerWTxtCnt)) != ASN1_OP_OK)
      break;
    FreeIDATPARR_Struc(HMEM_CTX_REF1 pRDNNamesDesc);
    pRDNNamesDesc = NULL;			// avoid freeing
    //---------------------------------------------------------
    // Generate the Subject RDN text Elements  
    //---------------------------------------------------------
    if((Retcode = FromASN1_DN_ToStringArray(HMEM_CTX_REF1
			pActCert->Subject,
			ppTmpDesc)) != ASN1_OP_OK)
      break;
    pRDNNamesDesc = ppTmpDesc[0];
    //----------------------------------------------------------
    // Generate the Subject Display WTxtx String
    //----------------------------------------------------------
    Retcode = WriteCertInfoToTxtArray(HMEM_CTX_REF1
				      pRDNNamesDesc, ppTmpBuf);
    if(Retcode != ASN1_OP_OK)
      break;
    pActCertWTxtStruc->pSubjectDispWTxt = ppTmpBuf[0];
    //-----------------------------------------------------------
    // Put the Elements From Descriptor to the Subject WTxt Array
    //-----------------------------------------------------------
    if((Retcode = MoveDescBufsToArray(HMEM_CTX_REF1
		    pRDNNamesDesc,
		    pActCertWTxtStruc->pSubjectWTxtArr,
		    pActCertWTxtStruc->SubjectWTxtCnt)) != ASN1_OP_OK)
      break;
    FreeIDATPARR_Struc(HMEM_CTX_REF1 pRDNNamesDesc);
    pRDNNamesDesc = NULL;			// avoid freeing
    //----------------------------------------------------------
    // Get Not Before Time Array (just copy)
    //----------------------------------------------------------
    memcpy(pActCertWTxtStruc->NotBeforeTimeArr+0,pActCert->pNotBeforeTimeArray+0,(TIME_ARRAY_SIZE)*sizeof(int));
    //----------------------------------------------------------
    // Get Not After Time Array (just copy)
    //----------------------------------------------------------
    memcpy(pActCertWTxtStruc->NotAfterTimeArr+0,pActCert->pNotAfterTimeArray+0,(TIME_ARRAY_SIZE)*sizeof(int));
    //----------------------------------------------------------
    // Get the Serial Number as HEX WTxt String
    //----------------------------------------------------------
    pIdata = pActCert->SerialNumber->ppArr[0];
    if((Retcode = FromBytes_ToHexStringPriv(HMEM_CTX_REF1
			pIdata->Base,
			(int) pIdata->Off, pIdata->Len,
			ppTmpBuf)) != ASN1_OP_OK)
      break;

    pBuf = ppTmpBuf[0];
    Retcode =  WriteHexInfoToTxtArray(HMEM_CTX_REF1
				      pBuf, ppTmpBuf);
    FREE_ARRAY(HMEM_CTX_REF,pBuf);		// also sets pBuf = NULL
    if(Retcode != ASN1_OP_OK)
      break;

    pActCertWTxtStruc->pSerialNumWTxt = ppTmpBuf[0];
    //-------------------------------------------------------------
    // Hash the Certificate with MD5 (and also with SHA1 for chain)
    //-------------------------------------------------------------
    pIdata = pActCert->Certificate->ppArr[0];

    MD5_Init(MD5Array);
    MD5_Update(MD5Array,pIdata->Base,(int) pIdata->Off,pIdata->Len);
    MD5_Final(MD5Array,MD5DigestBuf,0);

    SHA1_Update(SHA1Array,pIdata->Base,(int) pIdata->Off,pIdata->Len);
    //--------------------------------------------------------------
    // Convert Digest to internal String
    //--------------------------------------------------------------
    if((Retcode = FromBytes_ToHexStringPriv(HMEM_CTX_REF1
		MD5DigestBuf, 0 ,MD5_DIGEST_LEN, ppTmpBuf)) != ASN1_OP_OK)
      break;

    pBuf = ppTmpBuf[0];
    Retcode =  WriteHexInfoToTxtArray(HMEM_CTX_REF1
				      pBuf, ppTmpBuf);
    FREE_ARRAY(HMEM_CTX_REF,pBuf);		// also sets pBuf = NULL
    if(Retcode != ASN1_OP_OK)
      break;

    pActCertWTxtStruc->pMD5FingerPrintWTxt = ppTmpBuf[0];
    //--------------------------------------------------------------
    // Set the Certificate State Flags
    // NOTE: there are free bits that can be used for other purposes
    //--------------------------------------------------------------
    pActCertWTxtStruc->StateFlags =
      pActCert->DateTimeValidity;

    Index++;
  }
  //--------------------------------------------------------
  // Free Temporary used variables if still set, check Error
  //--------------------------------------------------------
  FREE_CARRAY(HMEM_CTX_REF,pBuf);
  FreeIDATPARR_Struc(HMEM_CTX_REF1 pRDNNamesDesc);
  if(Retcode != ASN1_OP_OK)
  {
    Free_HCERWTXT_StrucArr(HMEM_CTX_REF1
			   pCertsWTxtStrucArr, CertsCnt);
    return(Retcode);
  }
  //--------------------------------------------------------
  // Set the Structure Array, build the final SHA1 Digest
  //--------------------------------------------------------
  ppCertsWTxtArr[0] = pCertsWTxtStrucArr;
  SHA1_Final(SHA1Array,pChainDigest,0);
  return(ASN1_OP_OK);
}

/**
* Generates a SHA1 or a MD5 hash of any input data (GenDataHash).
*
* 
*  @param pbyDataInput Buffer containing the data to be hashed
*  @param nDataOff Offset to start of data in buffer
*  @param nDataLen Length of data to be hashed
*  @param pbyHashRet Buffer to store the hash
*  @param nHashRetOff Offset to the start of hash in buffer
*  @param nHashRetLen Size of available hash-Bufferb
*  @param nHashType Type of hash function to use: 0 - MD5, 1 - SHA1
*
*  @return 0 on success, error code otherwise
*/
extern "C"  int GenDataHash(char* pbyDataInput, int nDataOff,
		int nDataLen, char* pbyHashRet, int nHashRetOff,
		int nHashRetLen, int nHashType)
{
  int anDigArray[SHA_ARRAY_SIZE];	// note MD5, SHA same size

  //----------------------------------------------------------
  // check Parameters
  //----------------------------------------------------------
  if((pbyDataInput == NULL) || (pbyHashRet == NULL))
    return(ASN1_NULL_PTR);

  if(nDataLen <= 0)
    return(ASN1_PARAM_ERR);

  switch(nHashType)
  {
    case 0:						// MD5
      if(nHashRetLen < MD5_DIGEST_LEN)
        return(ASN1_PARAM_ERR);
      MD5_Init(anDigArray);
      MD5_Update(anDigArray,pbyDataInput,nDataOff,nDataLen);
      MD5_Final(anDigArray,pbyHashRet,nHashRetOff);
      return(ASN1_OP_OK);

    case 1:						// SHA1
      if(nHashRetLen < SHA_DIGEST_LEN)
        return(ASN1_PARAM_ERR);
      SHA1_Init(anDigArray);
      SHA1_Update(anDigArray,pbyDataInput,nDataOff,nDataLen);
      SHA1_Final(anDigArray,pbyHashRet,nHashRetOff);
      return(ASN1_OP_OK);

    default:						// others
      return(ASN1_PARAM_ERR);

  }
 }

extern "C"  int m_check_cert_from_array_sig_type(X509CERT ** adsp_target_cert_array,
                                              int inp_cert_off,
                                              char* abyp_sig_types)
{
   int inl_result = 0;
   int inl_index =1;

   for(; inl_index <= (int)abyp_sig_types[0]; inl_index++){
      if(adsp_target_cert_array[inp_cert_off]->SignatType == (int)abyp_sig_types[inl_index]){
         inl_result = 1;
         break;
      }
   }
   return inl_result;
}

/**
* Subroutine m_check_cert_chain_algors checks if a given, preprocessed
* Certificate in internal notation has the correct Algorithms,
* CA Issuer DN and in case of DH the same params for a given SSL/TLS
* Key Exchange Algorithm (m_check_cert_chain_algors).
* NOTE: no check on pointers is done !
*      
*
*  @param   adsp_tree_struc	Tree Stucture
*  @param	inp_cert_cn_index Index into CNode Array 
*	@param	inp_public_algor	Public algor for end cert
*	@param	abyp_sig_types	   Allowed signature types for whole chain
*	@param   adsp_dn_list		List of CA RDNs/NULL
*	@param	inp_dn_count		Number of Elements
*	@param   adsp_dh_params		Parameters /NULL
*	@param	ainp_result		   result of compare
*
* Return: int Status			- ASN1_OP_OK: o.k.
*					- else Error occurred
*/
static  int m_check_cert_chain_algors(CTREESTR * adsp_tree_struc,
     int inp_cert_cn_index, int inp_public_algor, char* abyp_sig_types,
     X501_DN** adsp_dn_list, int inp_dn_count, IDATPARR* adsp_dh_params,
     int* ainp_result)
{
   int Retcode = ASN1_OP_OK;
   int Result;
   int Index = 0;
   int ActCertIndex;
   int inl_next_cn_index = inp_cert_cn_index;

   IDATPARR* DatArrayDesc;

   int pTmpResult[1];

   X509CERT * adsl_end_cert;

   X501_DN* pActNameDesc;

   ainp_result[0] = ASN1_END_CERT_ALGORS_MISMATCH;

   ActCertIndex = 				// get index to Cert List
      adsp_tree_struc->CNodeArray[inp_cert_cn_index+CN_CERTLIST_INDEX];
   adsl_end_cert = adsp_tree_struc->ppCertList[ActCertIndex];	// get Certificate
   //-------------------------------------------------------
   // Compare Certificate Algorithms
   //-------------------------------------------------------
   if((adsl_end_cert->PublicKeyType != inp_public_algor))
      return(Retcode);					// no match, o.k.
   while(inl_next_cn_index >= 0){
      ActCertIndex = adsp_tree_struc->CNodeArray[inl_next_cn_index+CN_CERTLIST_INDEX];
      
      if(m_check_cert_from_array_sig_type(adsp_tree_struc->ppCertList, ActCertIndex, 
            abyp_sig_types) == 0){
         return(Retcode);					// no match, o.k.
      }
      inl_next_cn_index = adsp_tree_struc->CNodeArray[inl_next_cn_index+CN_P_INDEX];
   }
   //---------------------------------------------------------
   // Check if the Public Algorithm is DH and DH Params given
   //---------------------------------------------------------
   if((inp_public_algor == DH_PUBLIC_ALGOR) && (adsp_dh_params != NULL))
   {
      DatArrayDesc = adsl_end_cert->SubjPubKeyParVal;
      if(DatArrayDesc == NULL)
      {
         ainp_result[0] = ASN1_END_CERT_PARAMS_MISMATCH;
         return(Retcode);
      }
      for(;;)
      {
         //-------------------------------------------------
         // Prime P and Generator G must match
         //-------------------------------------------------
         Result = MatchIDATPARRStrucs(DatArrayDesc,DH_ALG_PAR_P_INDEX,
            adsp_dh_params,DH_ALG_PAR_P_INDEX,1);
         if(Result != ASN1_SAME) break;

         Result = MatchIDATPARRStrucs(DatArrayDesc,DH_ALG_PAR_G_INDEX,
            adsp_dh_params,DH_ALG_PAR_G_INDEX,1);
         if(Result != ASN1_SAME) break;
         //-------------------------------------------------
         // Public value Yc must be same or absent
         //-------------------------------------------------
         Result = MatchIDATPARRStrucs(DatArrayDesc,
            DH_ALG_PAR_MAX_INDEX+DH_PUB_VAL_Y_INDEX,
            adsp_dh_params,
            DH_ALG_PAR_MAX_INDEX+DH_PUB_VAL_Y_INDEX,
            1);
         break;
      }
      if(Result != ASN1_SAME)
      {
         ainp_result[0] = ASN1_END_CERT_PARAMS_MISMATCH;
         return(Retcode);
      }
   }
   //------------------------------------------------------------
   // Check if there is a CA issuer name constraints list present
   //------------------------------------------------------------
   if((adsp_dn_list != NULL) && (inp_dn_count > 0))
   {
      ainp_result[0] = ASN1_END_CERT_CA_ROOT_MISMATCH;
      for(;;)
      {
         if(adsp_tree_struc->CNodeArray[inp_cert_cn_index+CN_P_INDEX] == -1)
            break;					// no more parents, at the root
         inp_cert_cn_index = 				// get index to Parent
            adsp_tree_struc->CNodeArray[inp_cert_cn_index+CN_P_INDEX];
      }
      ActCertIndex = 				// get index to Cert List
         adsp_tree_struc->CNodeArray[inp_cert_cn_index+CN_CERTLIST_INDEX];
      adsl_end_cert = adsp_tree_struc->ppCertList[ActCertIndex];	// get Root Certificate

      pActNameDesc = adsl_end_cert->Issuer;

      Index = 0;
      do
      {
         Retcode = MatchX501_DNs(pActNameDesc,adsp_dn_list[Index],pTmpResult);
         if(Retcode != ASN1_OP_OK) return(Retcode);
         if(pTmpResult[0] == ASN1_SAME) break;		// found match !
         Index++;
         inp_dn_count--;
      }while(inp_dn_count != 0);
      if(inp_dn_count == 0) return(Retcode);			// no match !
   }
   ainp_result[0] = ASN1_END_CERT_MATCH;
   return(Retcode);
}

extern "C"  int GetSpecificEndCertFromListTLS12(HMEM_CTX_DEF
		CTREESTR * adsp_tree_struc, int inp_verify_enable, int inp_verfy_flags, 
		int inp_public_alg, char* abyp_sig_types, X501_DN** aadsp_dn_list,
      int inp_dn_count, IDATPARR* adsp_dh_params, int* ainp_result)
{
  int Retcode = ASN1_OP_OK;
  int CertIndex = 0;
  int Cnt=0;
  int ActCNIndex;
  int CertListIndex;

  int RSA_AlternateFlag = 0;
  int DSS_AlternateFlag = 0;
  int Dh_AlternateFlag  = 0;

  int* pCertIndexList = NULL;

  int pTmpResult[1];
  int pVerifyResult[1];

  X509CERT * pCert;

  //------------------------------------------------------------
  // Get Count and List pointer according to given Algors
  //------------------------------------------------------------
  ainp_result[0] = -1;				// not found
  switch(inp_public_alg)
  {
    case RSA_PUBLIC_ALGOR:
      Cnt            = adsp_tree_struc->EndRsaCount;  
      pCertIndexList = adsp_tree_struc->EndRsaIndexArray;      
      if(Cnt != 0)					// there are Endcerts
      {
        if(adsp_tree_struc->RootEndRsaCount != 0)	// there are roots
          RSA_AlternateFlag = 1;			// alternate root get
	  break;
      }
      Cnt	     = adsp_tree_struc->RootEndRsaCount;
      pCertIndexList = adsp_tree_struc->RootEndRsaIndexArray;
      break;

    case DSA_PUBLIC_ALGOR:
      Cnt            = adsp_tree_struc->EndDssCount;  
      pCertIndexList = adsp_tree_struc->EndDssIndexArray;      
      if(Cnt != 0)					// there are Endcerts
      {
        if(adsp_tree_struc->RootEndDssCount != 0)	// there are roots
          DSS_AlternateFlag = 1;			// alternate root get
	  break;
      }
      Cnt	     = adsp_tree_struc->RootEndDssCount;
      pCertIndexList = adsp_tree_struc->RootEndDssIndexArray;
      break;

    case DH_PUBLIC_ALGOR:
          Cnt	         = adsp_tree_struc->EndDhRsaCount;
          pCertIndexList = adsp_tree_struc->EndDhRsaIndexArray;      
          if(Cnt != 0)
          {
	    if(adsp_tree_struc->EndDhDssCount != 0)	
	      Dh_AlternateFlag = 1;
            break;
          }
          Cnt	         = adsp_tree_struc->EndDhDssCount;
          pCertIndexList = adsp_tree_struc->EndDhDssIndexArray;      
          break;
  } // outer switch
  if(Cnt <= 0) return(Retcode);
  //------------------------------------------------------------
  // Search list of specific certificates for a Match
  //------------------------------------------------------------
  for(;;)				// in case of DH all sign algors
  {
    CertIndex = 0;
    do
    {
      ActCNIndex = pCertIndexList[CertIndex];	// get index to Node array
      CertListIndex = 				// get index to Cert List
        adsp_tree_struc->CNodeArray[ActCNIndex+CN_CERTLIST_INDEX];
      pCert = adsp_tree_struc->ppCertList[CertListIndex]; // get Certificate
      if((pCert->ContFlags & IBM_CONT_FLAG_EXT_PRIV_KEY) == 0)
      {
        Retcode = m_check_cert_chain_algors(adsp_tree_struc,ActCNIndex,
		    inp_public_alg, abyp_sig_types, aadsp_dn_list, inp_dn_count,
		    adsp_dh_params, pTmpResult);

        if(Retcode != ASN1_OP_OK)
          return(Retcode);
        if(pTmpResult[0] == ASN1_END_CERT_MATCH)	// found certificate
        {
          //-----------------------------------------------------
          // Verify the Chain originating at Endcert if requested
          //-----------------------------------------------------
          if(inp_verify_enable == 0)			// no Verify required
          {
            ainp_result[0] = ActCNIndex;
            return(Retcode);
          }
          Retcode = VerifyLclCertChain(HMEM_CTX_REF1
			adsp_tree_struc, ActCNIndex,
			inp_verfy_flags, pVerifyResult);
          if(Retcode != ASN1_OP_OK)
            return(Retcode);
          if(pVerifyResult[0] == 0)		// verified o.k.
          {
            ainp_result[0] = ActCNIndex;
            return(Retcode);
          }
        }
      }  
      CertIndex++;
      Cnt--;
    }while(Cnt != 0);
    if((RSA_AlternateFlag == 0) &&
       (DSS_AlternateFlag == 0) &&
       (Dh_AlternateFlag == 0))
      break;
    //--------------------------------------------------------
    // There are either alternate RSA, DSS or DH possibilities
    //--------------------------------------------------------
    if(RSA_AlternateFlag != 0)
    {
      Cnt	     = adsp_tree_struc->RootEndRsaCount;
      pCertIndexList = adsp_tree_struc->RootEndRsaIndexArray;
      RSA_AlternateFlag = 0;
    }
    else if(DSS_AlternateFlag != 0)
    {
      Cnt	     = adsp_tree_struc->RootEndDssCount;
      pCertIndexList = adsp_tree_struc->RootEndDssIndexArray;
      DSS_AlternateFlag = 0;
    }
    else
    {
      Cnt	     = adsp_tree_struc->EndDhDssCount;
      pCertIndexList = adsp_tree_struc->EndDhDssIndexArray;      
      Dh_AlternateFlag = 0;
    }
  } // for
  return(Retcode);
}

extern "C"  int BuildCertChainFromSigList(HMEM_CTX_DEF
          CTREESTR * pTreeStruc, int VerifyEnable, int VerifyModeFlags,
          int PublicAlgor, char* SignatAlgors, X501_DN* pDNList[],
          int DnCount, IDATPARR* pDHParams, int pCNIndex[], 
          IDATPARR* pDstCertsDesc[])
{
   int Retcode = ASN1_OP_OK;

   int ActCNIndex;
   int ActCertIndex;
   int DstIndex;
   int Cnt;

   int* pCNArray;

   int pTmpCNIndex[1];

   IDATPARR* pTmpDatArrayDesc[1];
   IDATPARR* DatArrayDesc;

   IDATA** DatArray;

   X509CERT * pCert;
   X509CERT ** pCertList;

   //------------------------------------------------------
   // check for NULL pointers
   //------------------------------------------------------
   if((pTreeStruc == NULL) || (pDstCertsDesc == NULL) ||
      (pCNIndex == NULL))
      return(ASN1_TO_CERT_CHAIN_NULLPTR_ERR);
   pDstCertsDesc[0] = NULL;
   //---------------------------------------------------------------
   // Find a Endcertificate for given specifics (algors, params, names),
   // if requested also assure that that Endcert's chain verifies o.k.
   //---------------------------------------------------------------
   Retcode = GetSpecificEndCertFromListTLS12(HMEM_CTX_REF1
      pTreeStruc,
      VerifyEnable, VerifyModeFlags,
      PublicAlgor, SignatAlgors,
      pDNList, DnCount,
      pDHParams, pTmpCNIndex);
   if(Retcode != ASN1_OP_OK)		// error occurred
      return(Retcode);
   ActCNIndex = pTmpCNIndex[0];
   if(ActCNIndex < 0)
      return(ASN1_TO_CERT_CHAIN_NO_CERTS);		// not found
   pCNIndex[0] = ActCNIndex;				// set for caller
   //---------------------------------------------------------------
   // Get number of elements needed down to root
   //---------------------------------------------------------------
   pCNArray = pTreeStruc->CNodeArray;
   Cnt = pCNArray[ActCNIndex + CN_LEVEL]+1;		// get level+ base
   pCertList = pTreeStruc->ppCertList;		// get list
   //------------------------------------------------------
   // Allocate the output data structure
   //------------------------------------------------------
   Retcode = AllocIDATPARR_Struc(HMEM_CTX_REF1 pTmpDatArrayDesc,Cnt);
   if(Retcode != ASN1_OP_OK)
      return(Retcode);
   DatArrayDesc = pTmpDatArrayDesc[0];
   DatArray = DatArrayDesc->ppArr;
   //-------------------------------------------------------------
   // Get the Elements (ASN.1 Certs) and copy to Destination Array
   //-------------------------------------------------------------
   DstIndex = 0;
   for(;;)
   {
      ActCertIndex = pCNArray[ActCNIndex + CN_CERTLIST_INDEX]; // Cert Index
      pCert = pCertList[ActCertIndex];		// Cert Structure pointer
      CopyIdataContents(DatArray[DstIndex],
         pCert->Certificate->ppArr[0]);
      DstIndex++;    
      ActCNIndex = pCNArray[ActCNIndex + CN_P_INDEX];	// get parent index
      if(ActCNIndex == -1) break;				// no more parents
   }
   pDstCertsDesc[0] = DatArrayDesc;
   return(Retcode);
}

extern "C" int m_write_cn_to_string(X501_DN* adsp_rdn, 
                                    struct dsd_unicode_string* adsp_ucs_dest)
{
  int Retcode = ASN1_OP_OK;
  int SrcIndex = 0;
  int ElementCnt;
  int RdnCount;
  int RdnIndex;

  int CommonNameOIDIndex;
  int CommonNameOIDLen;
  int ObjID_Len;
  int Result;

  char ASN1Type;
  int inl_cont_index;
  int inl_cont_len;
  char* achl_cont_data;
  int inl_string_len = 0;

  IDATA** pDatArray;

  IDATA* pObjIdata;
  IDATA* pContIdata;
  IDATPARR*  pActRdnDesc;
  IDATPARR** pRdnDescArr;

  // check parameters, preset string len to 0
  if((adsp_rdn == NULL) || (adsp_ucs_dest == NULL))
     return(ASN1_RDN_TO_CNAMESTR_NULPTR_ERR);
  adsp_ucs_dest->imc_len_str = 0;
  adsp_ucs_dest->ac_str = NULL;

  // Get Number of RDN-Entries to process
  RdnCount = adsp_rdn->Cnt;		// number of RDNs
  if(RdnCount <= 0)				// none...
     return(ASN1_OP_OK);				// no Elements..., exit

  pRdnDescArr = adsp_rdn->ppArr;	// Elements Array

  // Get Common Name Table OID Compare Start
  CommonNameOIDIndex = X520_ATT_OffsetTab[OID_X520_COMMON_NAME];
  CommonNameOIDLen   = (int) OID_Table[CommonNameOIDIndex+2] & 0xFF;
  CommonNameOIDIndex += 3;		// to start of Data to compare

  // Process the Entries, search for CommonName OID
  RdnIndex = 0;
  Result = ASN1_NOT_SAME;
  while(RdnIndex < RdnCount)
  {
     SrcIndex = 0;
     pActRdnDesc = pRdnDescArr[RdnIndex];	// actual RDN Descriptor
     pDatArray   = pActRdnDesc->ppArr;
     ElementCnt  = pActRdnDesc->Cnt;
     if((ElementCnt & 0x01) != 0)			// must be even
        return(ASN1_RDN_TO_CNAMESTR_INV_CNT);
     ElementCnt >>= 1;
     while(ElementCnt != 0)
     {
        pObjIdata  = pDatArray[SrcIndex++];	// Get OID Element
        if(pObjIdata == NULL)			 // invalid
           return(ASN1_RDN_TO_CNAMESTR_SRC_ERR);

        ObjID_Len = pObjIdata->Len;		// get length
        if(ObjID_Len == CommonNameOIDLen)		// same, further check
        {
           Result = MatchASN1ValuesByteByByte(pObjIdata->Base,
              (int) pObjIdata->Off,
              ObjID_Len,
              (char *) OID_Table,
              CommonNameOIDIndex,
              CommonNameOIDLen);
           if(Result == ASN1_SAME)		// found Common Name OID
           {
              // Found Common Name Entry, convert to internal string
              pContIdata = pDatArray[SrcIndex];		// Get Contents
              if((pContIdata == NULL) || (pContIdata->Base == NULL))
                 return(ASN1_OP_OK);
              inl_cont_index = (int) pContIdata->Off;
              achl_cont_data = pContIdata->Base;
              inl_cont_len = pContIdata->Len;
              ASN1Type = achl_cont_data[inl_cont_index++];		// get type
              inl_cont_len--;
              // get length and lenfld len:
              Retcode = DecodeASN1_LenField(achl_cont_data,inl_cont_index,inl_cont_len,&inl_string_len);
              if(Retcode < 0)
              {
                 if(Retcode == -2) return(ASN1_FROM_STRING_INSUF_DATA_ERR);
                 return(ASN1_FROM_STRING_INV_LEN_ERR);
              }
              inl_cont_index += Retcode;			// skip lengthfield
              if(inl_string_len == 0){
                 adsp_ucs_dest->imc_len_str = 0;
                 return(ASN1_OP_OK);
              }
              if(inl_string_len > (0x7FFF-8))		// max. length
                 return(ASN1_FROM_STRING_INV_LEN_ERR);

              switch(ASN1Type)
              {
              case ASN1_UNIVERSAL_VISIBLESTR:
              case ASN1_UNIVERSAL_IA5STR:
              case ASN1_UNIVERSAL_NUMERICSTR:
              case ASN1_UNIVERSAL_PRINTABLESTR:
              case ASN1_UNIVERSAL_TELETEXSTR:
                 if(inl_string_len > (0x3FFF-4))
                    return(ASN1_FROM_STRING_INV_LEN_ERR);
                 adsp_ucs_dest->imc_len_str = inl_string_len;
                 adsp_ucs_dest->ac_str = achl_cont_data+ inl_cont_index;
                 adsp_ucs_dest->iec_chs_str = ied_chs_ascii_850;
                 break;

              case ASN1_UNIVERSAL_BMPSTR:
                 if((inl_string_len & 0x01) != 0)
                    return(ASN1_FROM_STRING_INV_LEN_ERR);
                 adsp_ucs_dest->imc_len_str = inl_string_len>>1;
                 adsp_ucs_dest->ac_str = achl_cont_data+ inl_cont_index;
                 adsp_ucs_dest->iec_chs_str = ied_chs_be_utf_16;
                 break;

              case ASN1_UNIVERSAL_UNIVSTR:
                 if((inl_string_len & 0x03) != 0)
                    return(ASN1_FROM_STRING_INV_LEN_ERR);
                 adsp_ucs_dest->imc_len_str = inl_string_len>>2;
                 adsp_ucs_dest->ac_str = achl_cont_data+ inl_cont_index;
                 adsp_ucs_dest->iec_chs_str = ied_chs_be_utf_32;
                 break;

              case ASN1_UNIVERSAL_UTF8STR:
                 if(inl_string_len > (0x3FFF - 4))			// too much elements
                    return(ASN1_FROM_STRING_INV_LEN_ERR);
                 adsp_ucs_dest->imc_len_str = inl_string_len;
                 adsp_ucs_dest->ac_str = achl_cont_data+ inl_cont_index;
                 adsp_ucs_dest->iec_chs_str = ied_chs_utf_8;
                 break;

              default:
                 return(ASN1_FROM_STRING_INV_TYPE_ERR);
              }

              return (ASN1_OP_OK);
           }
        }
        SrcIndex++;				// skip contents
        ElementCnt--;
     }
     RdnIndex++;
  }
  return(ASN1_OP_OK);
}

extern "C"  int m_get_cert_dns_names( X509CERT * adsp_pcert, 
                                             struct dsd_unicode_string* adsp_ucs_name_array, 
                                             size_t szp_array_size)
{
   IDATPARR* adsl_psan_desc;
   int iml_ext_presence;
   int ainl_len_i2_out[1];
   int inl_retval;
   int inl_len;
   IDATA* adsl_pi2_content[200];
   IDATA adsl_data_insts[200];
   IDATPARR dsl_pi2_struc;
   IDATPARR* adsl_pi2_datarraydsc[1];
   int inl1;
   IDATA** adsl_idata_tmp;
   int inl2;
   int inl_ret_val = 0;
   size_t szl_name_cnt = 0;
   unsigned int unl_index =0;

   // First get the subject common name
   inl_ret_val= m_write_cn_to_string(adsp_pcert->Subject, adsp_ucs_name_array);
   if(inl_ret_val != ASN1_OP_OK){
      return inl_ret_val;
   }
   if(adsp_ucs_name_array->imc_len_str != 0){
      // Common name found
      szl_name_cnt++;
      inl_ret_val++;
   }

   // process the subject alternative name extension
   iml_ext_presence = adsp_pcert->ExtPresFlags;  // get the Extension presence bits
   if ((iml_ext_presence & X509EXT_SUBJ_ALTNAME_PRES_BIT) == 0)
   {
      // No SAN
      return (int)szl_name_cnt;
   }
   
   adsl_psan_desc = adsp_pcert->SubjAltName;  // set address of Subject Alternative Name
   if (adsl_psan_desc == NULL)
   {
      // SAN pointer missing
      return -1;
   }
   
   // get the length of the return array and thus the number of available alternative subject names
   ainl_len_i2_out[0] = 0;
   inl_retval = m_extract_alter_name(adsl_psan_desc, NULL, ainl_len_i2_out);
   if (inl_retval != ASN1_OP_OK)
   { 
      // Error at m_extract_alter_name
      return inl_retval;
   }
   
   inl_len = ainl_len_i2_out[0];  // length of return array
   if ((inl_len <= 0) && ((inl_len & 0x01) == 1))
   {
      // Invalid length
      return -1;
   }
   // ToDo: prepare collecting of RDN name strings
   //       maximum nuber of possible RND names = (inl_len / 2)

   adsl_pi2_datarraydsc[0] = &dsl_pi2_struc;
   adsl_pi2_datarraydsc[0]->Cnt = 200;
   adsl_pi2_datarraydsc[0]->Flags = 0;
   adsl_pi2_datarraydsc[0]->ppArr = adsl_pi2_content;

   for(unl_index = 0; 200 > unl_index; unl_index++){
      adsl_pi2_content[unl_index] = adsl_data_insts+unl_index;
   }

   ainl_len_i2_out[0] = inl_len;
   inl_retval = m_extract_alter_name(adsl_psan_desc, adsl_pi2_datarraydsc, ainl_len_i2_out);
   if (inl_retval != ASN1_OP_OK)
   {
      // Error in m_extract_alter_name
      return inl_retval;
   }
   adsl_idata_tmp = adsl_pi2_datarraydsc[0]->ppArr;
   inl1 = 0;
   while (inl1 < ainl_len_i2_out[0])
   {
      inl2 = 0;  // object identifier not yet determined
      if (inl1 < adsl_pi2_datarraydsc[0]->Cnt)
      {
         inl_len = adsl_idata_tmp[inl1]->Len;
         if (inl_len > 0)
         {
            inl2 = ((int)(adsl_idata_tmp[inl1]->Base[adsl_idata_tmp[inl1]->Off]) & 0xFF);
            if ((inl2 & 0x1F) != 0x02)  // dnsName
            {
               inl2 = 0;  // object identifier not equal to DNSName
            }
         }
      }
      inl1++;
      if ((inl1 < adsl_pi2_datarraydsc[0]->Cnt) && (inl2 != 0))
      {
         if ((inl2 & 0x20) == 0)
         { // primitive identifier
            inl_len = adsl_idata_tmp[inl1]->Len;
            if (inl_len > 0)
            {
               // Check, if there is still space in the array
               if(szl_name_cnt != szp_array_size){
                  // Write DNS name. Assume IDNA coding to be safe.
                  adsp_ucs_name_array[szl_name_cnt].ac_str = adsl_idata_tmp[inl1]->Base+adsl_idata_tmp[inl1]->Off;
                  adsp_ucs_name_array[szl_name_cnt].imc_len_str = inl_len;
                  adsp_ucs_name_array[szl_name_cnt].iec_chs_str = ied_chs_idna_1;

                  // Increment counter
                  szl_name_cnt++;
               }
               inl_ret_val++;
            }
         }
         else
         { // constructed identifier

            // ToDo: Console/Logging output
            //       "Subject Alternative Name as constructed identifier of type = " +
            //       "\"DNSName\" is not yet implemented.\n");

         }
      }
      inl1++;

   } // end of while (inl1 < ainl_len_i2_out[0])
   return inl_ret_val;
}

/** @} */


#endif //HL_CERT_ASN_1_MAIN
// end of file ../hasn1/hasn1src/hasn1.cpp


#ifdef HL_CERT_ASN_1_HELPER
//********************************************************
// Helper Library for ASN1 processing of certificate Requests,
// CRLs (planned, not yet supported)
// BASE64 encoding / decoding of certificates / certificate
// requests for export and import to library,
// Character String converters form/to internale format
//
//
//********************************************************
/** @defgroup asn1_hli ASN.1 Helper routines
*  @ingroup asn1
*  @{
*  @file
*  This contains ASN.1 helper processing functions. These functions are not 
*  used for the TLS/SSL library modules but are e.g. needed for the security
*  manager for generation of certificates, certificate requests, CRL
*  processing etc.
*
This module depends on the following modules:
- s1.c SHA-1 hashing functions
- lnum32.c large number functions
- r6.c rsa encryption/decryption/signature functions
- d3.c dsa signature / diffie-hellman functions
- p5e.c pkcs5 encrypt functions
- p5d.c pkcs5 decrypt functions
- hasn1.c general ASN.1 routines
- memfunc.c memory management functions for WebSecureProxy C interface
*/
#include <stdlib.h>
#include <string.h>
#if (defined _WIN32) & (_MSC_VER < 1700)
#ifndef _STDINT
#define _STDINT
// MSVC lower than 17.00 does not have stdint.h, assure, all needed types are defined

typedef unsigned __int16 uint16_t;

typedef unsigned __int32 uint32_t;

typedef unsigned __int64 uint64_t;

#endif // !_STDINT
#else
#include <stdint.h>
#endif
#include <stddef.h>
#ifdef _WIN32
#define WIN32_LEAN_AND_MEAN
#include <Windows.h>
#undef WIN32_LEAN_AND_MEAN
#else// Define system-specific HL_* defines here
#ifndef HL_UNIX
#define HL_UNIX

#if (defined __gnu_linux__) || (defined __linux__)
#define HL_LINUX
#endif

#if (defined __APPLE__) && (defined __MACH__)
#define HL_LINUX
#define HL_MACOS
#endif

#ifdef _AIX
#define HL_AIX
#define HL_BIG_ENDIAN
#endif

#ifdef __FreeBSD__
#define HL_FREEBSD
#endif

#if (defined _hpux) || (defined hpux) || (defined __hpux)
#define HL_HPUX
#define HL_BIG_ENDIAN
#endif

#if (defined sun) || (defined __sun)
#define HL_SOLARIS
#endif

#if (defined __arm__) || (defined __aarch64__)
#define HL_LINUX_ARM
#endif

#ifdef __ANDROID__
#define HL_ANDROID
#endif

#endif
#include <hob-unix01.h>
#endif
#ifdef __APPLE__
/* We get target conditionals to keep apart Mac OS, iOS and iOS simulator.
   The conditionals are TARGET_IPHONE_SIMULATOR, TARGET_OS_IPHONE and TARGET_OS_MAC.
   TARGET_IPHONE_SIMULATOR has the highest priority, TARGET_OS_MAC the lowest.
   Always test, if the conditional is 1, as they will be defined as 0, if we 
   are not compiling for the target.
   */
#include <TargetConditionals.h>
#endif

#ifdef HL_ANDROID
#include <netdb.h>
#include <unistd.h>
#include <linux/in.h>
#ifndef SOCKLEN_T
#define SOCKLEN_T      int
#endif
#ifndef SA_FAMILY_T
#define SA_FAMILY_T  short
#endif
#include <sys/endian.h>
#include <asm/ioctls.h>
#include <errno.h>
#endif

#include "hob-encry-1.h"
#include "hob-cert-ext.h"
#ifdef _WIN32
#include <winsock.h>
#endif
#include "hob-cert-err.h"
#include <string.h>
#include "hob-cert-intern.h"
#include "hob-cert-err.h"

//-----------------------------------------------------------------------------
// This section was included from the file hasn1hcl.hc
//-----------------------------------------------------------------------------

// Include-File for HASN1HLIB.C, the additional ASN.1 Helper library
// for Certificate Requests, Certificate Revocation lists etc.
// NOTE: Java portion is generated with CTRLSTR.C from the C-Arrays !
// -----

//================================================================
// Additional ASN.1 Control structures used for conversion to and from
// internal data objects. Control entries have fixed length of 4
// bytes.
// NOTE: See documentation of Parser Control Structures (which does not
// ----- yet exist ...) before making changes !!!
//================================================================

//----------------------------------------------------------------
// OpenSSL RSA private key control structures
//----------------------------------------------------------------
 unsigned char Openssl_RSA_Privkey_Ctl[OPSSL_RSA_PRIVKEY_CTL_SIZE]={

						// L1 SEQ: RSA Private Key
 (unsigned char) (X_ONLY | CONSTRUCT),
 (unsigned char) (ASN1_UNIVERSAL_SEQUENCE | ASN1_CONSTRUCTED),
 (unsigned char) 0x00,
 (unsigned char) 0x00,
						// L2 INT: Version (0)
						// DataIndex: 0
 (unsigned char) (X_FIRST | DATA_INDEX | ZERO_LEAD_FLAG),
 (unsigned char) (ASN1_UNIVERSAL_INTEGER),
 (unsigned char) OPSSL_RSA_PRIV_VERSION_INDEX,
 (unsigned char) 0x00,
						// L2 INT: Modulus n
						// DataIndex: 1
 (unsigned char) (X_MIDDLE | DATA_INDEX | ZERO_LEAD_FLAG),
 (unsigned char) (ASN1_UNIVERSAL_INTEGER),
 (unsigned char) OPSSL_RSA_PRIV_MODULUS_INDEX,
 (unsigned char) 0x00,
						// L2 INT: Public exponent e
						// DataIndex: 2
 (unsigned char) (X_MIDDLE | DATA_INDEX | ZERO_LEAD_FLAG),
 (unsigned char) (ASN1_UNIVERSAL_INTEGER),
 (unsigned char) OPSSL_RSA_PRIV_PUBEXP_INDEX,
 (unsigned char) 0x00,
						// L2 INT: Private exponent d
						// DataIndex: 3
 (unsigned char) (X_MIDDLE | DATA_INDEX | ZERO_LEAD_FLAG),
 (unsigned char) (ASN1_UNIVERSAL_INTEGER),
 (unsigned char) OPSSL_RSA_PRIV_PRIVEXP_INDEX,
 (unsigned char) 0x00,
						// L2 INT: Prime p
						// DataIndex: 4
 (unsigned char) (X_MIDDLE | DATA_INDEX | ZERO_LEAD_FLAG),
 (unsigned char) (ASN1_UNIVERSAL_INTEGER),
 (unsigned char) OPSSL_RSA_PRIV_PRIME_P_INDEX,
 (unsigned char) 0x00,
						// L2 INT: Prime q
						// DataIndex: 5
 (unsigned char) (X_MIDDLE | DATA_INDEX | ZERO_LEAD_FLAG),
 (unsigned char) (ASN1_UNIVERSAL_INTEGER),
 (unsigned char) OPSSL_RSA_PRIV_PRIME_Q_INDEX,
 (unsigned char) 0x00,
						// L2 INT: Exp1 d mod(p-1)
						// DataIndex: 6
 (unsigned char) (X_MIDDLE | DATA_INDEX | ZERO_LEAD_FLAG),
 (unsigned char) (ASN1_UNIVERSAL_INTEGER),
 (unsigned char) OPSSL_RSA_PRIV_DMODP_INDEX,
 (unsigned char) 0x00,
						// L2 INT: Exp2 d mod(q-1)
						// DataIndex: 7
 (unsigned char) (X_MIDDLE | DATA_INDEX | ZERO_LEAD_FLAG),
 (unsigned char) (ASN1_UNIVERSAL_INTEGER),
 (unsigned char) OPSSL_RSA_PRIV_DMODQ_INDEX,
 (unsigned char) 0x00,

						// L2 INT: Coeff q**-1 mod p
						// DataIndex: 8
 (unsigned char) (X_LAST | DATA_INDEX | ZERO_LEAD_FLAG),
 (unsigned char) (ASN1_UNIVERSAL_INTEGER),
 (unsigned char) OPSSL_RSA_PRIV_INVQMP_INDEX,
 (unsigned char) 0x00,
};

//----------------------------------------------------------------
// OpenSSL DSA private key control structures
//----------------------------------------------------------------
 unsigned char Openssl_DSA_Privkey_Ctl[OPSSL_DSA_PRIVKEY_CTL_SIZE]={

						// L1 SEQ: DSA Private key
 (unsigned char) (X_ONLY | CONSTRUCT),
 (unsigned char) (ASN1_UNIVERSAL_SEQUENCE | ASN1_CONSTRUCTED),
 (unsigned char) 0x00,
 (unsigned char) 0x00,
						// L2 INT: Version (0)
						// DataIndex: 0
 (unsigned char) (X_FIRST | DATA_INDEX | ZERO_LEAD_FLAG),
 (unsigned char) (ASN1_UNIVERSAL_INTEGER),
 (unsigned char) OPSSL_DSA_PRIV_VERSION_INDEX,
 (unsigned char) 0x00,
						// L2 INT: Modulus p
						// DataIndex: 1
 (unsigned char) (X_MIDDLE | DATA_INDEX | ZERO_LEAD_FLAG),
 (unsigned char) (ASN1_UNIVERSAL_INTEGER),
 (unsigned char) OPSSL_DSA_PRIV_MODULUS_P_INDEX,
 (unsigned char) 0x00,
						// L2 INT: Subgroup q
						// DataIndex: 2
 (unsigned char) (X_MIDDLE | DATA_INDEX | ZERO_LEAD_FLAG),
 (unsigned char) (ASN1_UNIVERSAL_INTEGER),
 (unsigned char) OPSSL_DSA_PRIV_GROUP_Q_INDEX,
 (unsigned char) 0x00,
						// L2 INT: Generator g
						// DataIndex: 3
 (unsigned char) (X_MIDDLE | DATA_INDEX | ZERO_LEAD_FLAG),
 (unsigned char) (ASN1_UNIVERSAL_INTEGER),
 (unsigned char) OPSSL_DSA_PRIV_GEN_G_INDEX,
 (unsigned char) 0x00,
						// L2 INT: Public value y
						// DataIndex: 4
 (unsigned char) (X_MIDDLE | DATA_INDEX | ZERO_LEAD_FLAG),
 (unsigned char) (ASN1_UNIVERSAL_INTEGER),
 (unsigned char) OPSSL_DSA_PRIV_PUBVAL_Y_INDEX,
 (unsigned char) 0x00,
						// L2 INT: Private value x
						// DataIndex: 5
 (unsigned char) (X_LAST | DATA_INDEX | ZERO_LEAD_FLAG),
 (unsigned char) (ASN1_UNIVERSAL_INTEGER),
 (unsigned char) OPSSL_DSA_PRIV_PRIVVAL_X_INDEX,
 (unsigned char) 0x00,
};

//----------------------------------------------------------------
// PKCS10 Certificate Request Split/Combine Control Structure:
// from/to Certificate Request Info, Signature Algor ID,
// Signature Algor Params and Signature Value
//
// NOT SPLIT/COMBINED ARE: Certificate Request Info
// -----------------------
//
// Used for Keypair databases, Certificate Request generation and
// for Test CA implementations to generate a signed Certificate
//----------------------------------------------------------------
static  unsigned char CertReqCtl[CERT_REQ_CTL_SIZE]={

						// L1 SEQ: PKCS10 Certificate
						//         Request
 (unsigned char) (X_ONLY | CONSTRUCT),
 (unsigned char) (ASN1_UNIVERSAL_SEQUENCE | ASN1_CONSTRUCTED),
 (unsigned char) 0x00,
 (unsigned char) 0x00,
						// L2 ANY: Certificate Request
						//         Info
						// DataIndex: 0
 (unsigned char) (X_FIRST | DATA_INDEX | ANY_ASN1),
 (unsigned char) (ASN1_UNIVERSAL_EOC),
 (unsigned char) CERT_REQ_INFO_INDEX,
 (unsigned char) 0x00,
						// L2 SEQ: Signature Algor
 (unsigned char) (X_MIDDLE | CONSTRUCT),
 (unsigned char) (ASN1_UNIVERSAL_SEQUENCE | ASN1_CONSTRUCTED),
 (unsigned char) 0x00,
 (unsigned char) 0x00,
						// L3 OBJID: Signat AlgorID
						// DataIndex: 1
 (unsigned char) (X_FIRST | DATA_INDEX),
 (unsigned char) (ASN1_UNIVERSAL_OBJECT_ID),
 (unsigned char) CERT_REQ_SIGNAT_ALGOR_ID_INDEX,
 (unsigned char) 0x00,
						// L3 ANY: Signat Params
						// DataIndex: 2
 (unsigned char) (X_LAST | DATA_INDEX | ANY_ASN1),
 (unsigned char) (ASN1_UNIVERSAL_EOC),
 (unsigned char) CERT_REQ_SIGNAT_ALGOR_PAR_INDEX,
 (unsigned char) 0x00,
						// L2 BITSTR: Signature
						// DataIndex: 3
 (unsigned char) (X_LAST | DATA_INDEX | ZERO_LEAD_FLAG),
 (unsigned char) (ASN1_UNIVERSAL_BITSTRING),
 (unsigned char) CERT_REQ_SIGNAT_DATA_INDEX,
 (unsigned char) 0x00,
};
//----------------------------------------------------------------
// PKCS10 TBS Certificate Request Split/Combine Control Structure:
// from/to all structures found in TBS CertificationRequest Definition
// down to deepest possible level of knowledge from PKCS10 Description
//
// NOT SPLIT/COMBINED ARE: Subject Name, Public key Algorithm/
// ----------------------- Params, Public Value Signature Algorithm
//			   Signature Algor.Params and the attributes
//
// Used for Keypair databases, Certificate Request generation and
// for Test CA implementations to generate a signed Certificate
//----------------------------------------------------------------
static  unsigned char TBSCertReqCtl[TBS_CERT_REQ_CTL_SIZE]={

						// L1 SEQ: Certificate Request
						//         Info
 (unsigned char) (X_ONLY | CONSTRUCT),
 (unsigned char) (ASN1_UNIVERSAL_SEQUENCE | ASN1_CONSTRUCTED),
 (unsigned char) 0x00,
 (unsigned char) 0x00,
						// L2 INT; Version number
						// DataIndex: 0
 (unsigned char) (X_FIRST | DATA_INDEX),
 (unsigned char) (ASN1_UNIVERSAL_INTEGER),
 (unsigned char) TBS_CERT_REQ_VERSION_INDEX,
 (unsigned char) 0x00,
						// L2 SEQ: Subject RDN
						// DataIndex: 1
 (unsigned char) (X_MIDDLE | DATA_INDEX),
 (unsigned char) (ASN1_UNIVERSAL_SEQUENCE | ASN1_CONSTRUCTED),
 (unsigned char) TBS_CERT_REQ_SUBJECT_RDN_INDEX,
 (unsigned char) 0x00,
						// L2 SEQ: SubjectPublInfo
 (unsigned char) (X_MIDDLE | CONSTRUCT),
 (unsigned char) (ASN1_UNIVERSAL_SEQUENCE | ASN1_CONSTRUCTED),
 (unsigned char) 0x00,
 (unsigned char) 0x00,
						// L3 SEQ: Algorithm
 (unsigned char) (X_FIRST | CONSTRUCT),
 (unsigned char) (ASN1_UNIVERSAL_SEQUENCE | ASN1_CONSTRUCTED),
 (unsigned char) 0x00,
 (unsigned char) 0x00,
						// L4 OBJID: AlgorID
						// DataIndex: 2
 (unsigned char) (X_FIRST | DATA_INDEX),
 (unsigned char) (ASN1_UNIVERSAL_OBJECT_ID),
 (unsigned char) TBS_CERT_REQ_PUB_ALGOR_ID_INDEX,
 (unsigned char) 0x00,
						// L4 ANY: Algor Params
						// DataIndex: 3
 (unsigned char) (X_LAST | DATA_INDEX | ANY_ASN1 | OPTIONAL),
 (unsigned char) (ASN1_UNIVERSAL_EOC),
 (unsigned char) TBS_CERT_REQ_PUB_ALG_PAR_INDEX,
 (unsigned char) 0x00,
						// L3 BITSTR: Public Value Data
						// DataIndex: 4
 (unsigned char) (X_LAST | DATA_INDEX | ZERO_LEAD_FLAG),
 (unsigned char) (ASN1_UNIVERSAL_BITSTRING),
 (unsigned char) TBS_CERT_REQ_PUBLIC_DATA_INDEX,
 (unsigned char) 0x00,

						// L2 ETAG[0]: Attribs
						// DataIndex: 5
 (unsigned char) (X_LAST | DATA_INDEX),
 (unsigned char)	(ASN1_CLASS_CONTEXT_SPECIFIC | ASN1_CONSTRUCTED | 0x00),
 (unsigned char) TBS_CERT_REQ_ATTRIBUTES_INDEX,
 (unsigned char) 0x00,
};

//()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()
//
// X.509 CRL Related descriptors
//
//()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()

//----------------------------------------------------------------
// X509 V3 CRL Split/Combine Control Structure:
// from/to TBS Crl, Signature Algorithm / Params and the
// Signature itsself.
// Used for Signature Verification / Signature appending.
// NOTE: Public Algorithm and Params matching must be done the same
// ----- way as with ordinary certificates (i.e. the public key
//	 must be taken from the issuers root certificate.
// NOT SPLIT/COMBINED ARE: Algorithm Params (type ANY)
// -----------------------
//----------------------------------------------------------------
static  unsigned char X509CrlCtl[X509_CRL_CTL_SIZE]={

						// L1 SEQ: CRL
 (unsigned char) (X_ONLY | CONSTRUCT),
 (unsigned char) (ASN1_UNIVERSAL_SEQUENCE | ASN1_CONSTRUCTED),
 (unsigned char) 0x00,
 (unsigned char) 0x00,
						// L2 SEQ: TBS Crl
						// DataIndex: 0, with header
 (unsigned char) (X_FIRST | DATA_INDEX | ANY_ASN1 | MUST_MATCH),
 (unsigned char) (ASN1_UNIVERSAL_SEQUENCE | ASN1_CONSTRUCTED),
 (unsigned char) X509_CRL_TBS_CRL_INDEX,
 (unsigned char) 0x00,
						// L2 SEQ: Signature Algor
 (unsigned char) (X_MIDDLE | CONSTRUCT),
 (unsigned char) (ASN1_UNIVERSAL_SEQUENCE | ASN1_CONSTRUCTED),
 (unsigned char) 0x00,
 (unsigned char) 0x00,
						// L3 OBJID: Signat AlgorID
						// DataIndex: 1
 (unsigned char) (X_FIRST | DATA_INDEX),
 (unsigned char) (ASN1_UNIVERSAL_OBJECT_ID),
 (unsigned char) X509_CRL_SIGNAT_ALGOR_ID_INDEX,
 (unsigned char) 0x00,
						// L3 ANY: Signat Params
						// DataIndex: 2
 (unsigned char) (X_LAST | DATA_INDEX | ANY_ASN1),
 (unsigned char) (ASN1_UNIVERSAL_EOC),
 (unsigned char) X509_CRL_SIGNAT_ALGOR_PAR_INDEX,
 (unsigned char) 0x00,
						// L2 BITSTR: Signature
						// DataIndex: 3
 (unsigned char) (X_LAST | DATA_INDEX | ZERO_LEAD_FLAG),
 (unsigned char) (ASN1_UNIVERSAL_BITSTRING),
 (unsigned char) X509_CRL_SIGNAT_DATA_INDEX,
 (unsigned char) 0x00,
};
//----------------------------------------------------------------
// X509 V3 TBS CRL (To Be Signed) CRL Split/Combine Contol
// structure: form/to all structures found in TBS Crl down to deepest
// possible level of knowledge from ASN.1 description of CRL including
// following optional fields:
//  - Version 		(Integer, DEFAULT 0 [V1])
//  - NextUpdate	(Time)
//  - CRLExtensions     (ETAG [0], Sequence)
//
// NOT SPLIT/COMBINED ARE: Issuer name, thisUpdate, nextUpdate,
// 			   revokedCertificates, CRLExtensions
//----------------------------------------------------------------
static  unsigned char X509_TBSCrlCtl[X509_TBS_CRL_CTL_SIZE]={

						// L1 SEQ: TBS CRL
 (unsigned char) (X_FIRST | CONSTRUCT),
 (unsigned char) (ASN1_UNIVERSAL_SEQUENCE | ASN1_CONSTRUCTED),
 (unsigned char) 0x00,
 (unsigned char) 0x00,
						// L2 Integer: Version OPTIONAL
						// DataIndex: 0
 (unsigned char) (X_FIRST | DATA_INDEX | ZERO_LEAD_FLAG | OPTIONAL),
 (unsigned char)	(ASN1_UNIVERSAL_INTEGER),
 (unsigned char) X509_TBS_CRL_VERSION_INDEX,
 (unsigned char) 0x00,
						// L2 SEQ: Signature Algor
 (unsigned char) (X_MIDDLE | CONSTRUCT),
 (unsigned char) (ASN1_UNIVERSAL_SEQUENCE | ASN1_CONSTRUCTED),
 (unsigned char) 0x00,
 (unsigned char) 0x00,
						// L3 OBJID: AlgorID
						// DataIndex: 1
 (unsigned char) (X_FIRST | DATA_INDEX),
 (unsigned char) (ASN1_UNIVERSAL_OBJECT_ID),
 (unsigned char) X509_TBS_CRL_SIGN_ALG_ID_INDEX,
 (unsigned char) 0x00,
						// L3 ANY: Algor Params
						// DataIndex: 2
 (unsigned char) (X_LAST | DATA_INDEX | ANY_ASN1),
 (unsigned char) (ASN1_UNIVERSAL_EOC),
 (unsigned char) X509_TBS_CRL_SIGN_ALG_PAR_INDEX,
 (unsigned char) 0x00,
						// L2 SEQ: Issuer
						// DataIndex: 3, with header
 (unsigned char) (X_MIDDLE | DATA_INDEX | ANY_ASN1 | MUST_MATCH),
 (unsigned char) (ASN1_UNIVERSAL_SEQUENCE | ASN1_CONSTRUCTED),
 (unsigned char) X509_TBS_CRL_ISSUER_NAME_INDEX,
 (unsigned char) 0x00,
						// L2 ANY: thisUpdate
						// DataIndex: 4, with header
 (unsigned char) (X_MIDDLE | DATA_INDEX | ANY_ASN1),
 (unsigned char) (ASN1_UNIVERSAL_EOC),
 (unsigned char) X509_TBS_CRL_THIS_UPDATE_INDEX,
 (unsigned char) 0x00,
						// L2 ANY: nextUpdate, OPTIONAL
						// DataIndex: 5, with header
 (unsigned char) (X_MIDDLE | DATA_INDEX | ANY_ASN1 | OPTIONAL),
 (unsigned char) (ASN1_UNIVERSAL_EOC),
 (unsigned char) X509_TBS_CRL_NEXT_UPDATE_INDEX,
 (unsigned char) 0x00,
						// L2 SEQ: revokedCertsList, OPT
						// DataIndex: 6, with header!
 (unsigned char) (X_MIDDLE | DATA_INDEX | ANY_ASN1 | OPTIONAL | MUST_MATCH),
 (unsigned char) (ASN1_UNIVERSAL_SEQUENCE | ASN1_CONSTRUCTED),
 (unsigned char) X509_TBS_CRL_REVOKD_CERTS_INDEX,
 (unsigned char) 0x00,
						// L2 ETAG: CRL Extensions OPT.
 (unsigned char) (X_LAST | CONSTRUCT | OPTIONAL | DATA_INDEX),
 (unsigned char)	(ASN1_CLASS_CONTEXT_SPECIFIC | ASN1_CONSTRUCTED | 0x00),
 (unsigned char) X509_TBS_CRL_EXTENS_DATA_INDEX,		// check for build
 (unsigned char) 0x00,

						// L3 SEQ: Extension List
						// DataIndex: 7, no header
 (unsigned char) (X_ONLY | DATA_INDEX),
 (unsigned char) (ASN1_UNIVERSAL_SEQUENCE | ASN1_CONSTRUCTED),
 (unsigned char) X509_TBS_CRL_EXTENS_DATA_INDEX,
 (unsigned char) 0x00,
};

//----------------------------------------------------------------
// X509 V3 Revoked certificate CRL entry split/combine contol
// structure: form/to all structures found in a CRL's revokedCertificate
// entry: cert serialnumber, revocation date, crl entry exytensions
//----------------------------------------------------------------
static  unsigned char RevokedCertCtl[REVOKED_CERT_CTL_SIZE]={
						// L1 SEQ: RevokedCertificate
 (unsigned char) (X_ONLY | CONSTRUCT),
 (unsigned char) (ASN1_UNIVERSAL_SEQUENCE | ASN1_CONSTRUCTED),
 (unsigned char) 0x00,
 (unsigned char) 0x00,
						// L2 INT: SerialNumber
						// DataIndex: 0
 (unsigned char) (X_FIRST | DATA_INDEX | ZERO_LEAD_FLAG),
 (unsigned char) (ASN1_UNIVERSAL_INTEGER),
 (unsigned char) REVOKED_CERT_SERIAL_INDEX,
 (unsigned char) 0x00,
						// L2 ANY: revocationDate
						// DataIndex: 1, with header
 (unsigned char) (X_MIDDLE | DATA_INDEX | ANY_ASN1),
 (unsigned char) (ASN1_UNIVERSAL_EOC),
 (unsigned char) REVOKED_CERT_DATE_INDEX,
 (unsigned char) 0x00,
						// L2 SEQ: EntryExtension OPT.
						// DataIndex: 2, no header
 (unsigned char) (X_LAST | DATA_INDEX | OPTIONAL),
 (unsigned char) (ASN1_UNIVERSAL_SEQUENCE | ASN1_CONSTRUCTED),
 (unsigned char) REVOKED_CERT_EXT_INDEX,
 (unsigned char) 0x00,
};

//================================================================
//
// CRL Extensions Control Structures
//
//================================================================

//----------------------------------------------------------------
// CRL Number extension control structure
//----------------------------------------------------------------
static  unsigned char CRLNumberCtl[CRL_EXT_NUMBER_CTL_SIZE]={

						// L1 INTEGER: CRL-Number
						// DataIndex: 0
 (unsigned char) (X_ONLY | DATA_INDEX | ZERO_LEAD_FLAG),
 (unsigned char) (ASN1_UNIVERSAL_INTEGER),
 (unsigned char) CRL_EXT_NUMBER_INDEX,
 (unsigned char) 0x00,
};

//----------------------------------------------------------------
// CRL Issuing Distribution Point extension control structure
//----------------------------------------------------------------
static  unsigned char CRLIssDistPointCtl[CRL_EXT_ISS_DIST_POINT_CTL_SIZE]={

						// L1 SEQ: Distrib. Point
 (unsigned char) (X_ONLY | CONSTRUCT),
 (unsigned char) (ASN1_UNIVERSAL_SEQUENCE | ASN1_CONSTRUCTED),
 (unsigned char) 0x00,
 (unsigned char) 0x00,

						// L2 ETAG[0]: Dist. Point Name
						// DataIndex: 0
 (unsigned char) (X_FIRST | DATA_INDEX | ANY_ASN1 | OPTIONAL | MUST_MATCH),
 (unsigned char)	(ASN1_CLASS_CONTEXT_SPECIFIC | ASN1_CONSTRUCTED | 0x00),
 (unsigned char) CRL_EXT_DISTPNT_NAME_INDEX,
 (unsigned char) 0x00,
						// L2 ITAG[1] (BOOL):
						// Only UserCerts Flag
						// DataIndex: 1
 (unsigned char) (X_MIDDLE | DATA_INDEX | OPTIONAL),
 (unsigned char)	(ASN1_CLASS_CONTEXT_SPECIFIC | 0x01),
 (unsigned char) CRL_EXT_USER_CERTS_ONLY_INDEX,
 (unsigned char) 0x00,
						// L2 ITAG[2] (BOOL):
						// Only CACerts Flag
						// DataIndex: 2
 (unsigned char) (X_MIDDLE | DATA_INDEX | OPTIONAL),
 (unsigned char)	(ASN1_CLASS_CONTEXT_SPECIFIC | 0x02),
 (unsigned char) CRL_EXT_CA_CERTS_ONLY_INDEX,
 (unsigned char) 0x00,
						// L2 ITAG[3] (BITSTR):
						// SomeReasons Flag Bits
						// DataIndex: 3
 (unsigned char) (X_MIDDLE | DATA_INDEX | OPTIONAL),
 (unsigned char)	(ASN1_CLASS_CONTEXT_SPECIFIC | 0x03),
 (unsigned char) CRL_EXT_SOME_REASONS_INDEX,
 (unsigned char) 0x00,
						// L2 ITAG[4] (BOOL):
						// Indirect CRL Flag
						// DataIndex: 4
 (unsigned char) (X_LAST | DATA_INDEX | OPTIONAL),
 (unsigned char)	(ASN1_CLASS_CONTEXT_SPECIFIC | 0x04),
 (unsigned char) CRL_EXT_INDIRECT_CRL_INDEX,
 (unsigned char) 0x00,
};

//----------------------------------------------------------------
// CRL Delta CRL Indicator extension control structure
//----------------------------------------------------------------
static  unsigned char CRLDeltaCRLCtl[CRL_EXT_DELTA_CRL_CTL_SIZE]={

						// L1 INTEGER: Base CRL-Number
						// DataIndex: 0
 (unsigned char) (X_ONLY | DATA_INDEX | ZERO_LEAD_FLAG),
 (unsigned char) (ASN1_UNIVERSAL_INTEGER),
 (unsigned char) CRL_EXT_BASE_NUMBER_INDEX,
 (unsigned char) 0x00,
};

//================================================================
//
// CRL Entry extensions
//
//================================================================

//----------------------------------------------------------------
// CRL Entry Reason Code extension control structure
//----------------------------------------------------------------
static  unsigned char CRLEntryReasonCtl[CRL_ENT_REASON_CTL_SIZE]={

						// L1 ENUMERATED: ReasonCode
						// DataIndex: 0
 (unsigned char) (X_ONLY | DATA_INDEX | ZERO_LEAD_FLAG),
 (unsigned char) (ASN1_UNIVERSAL_ENUMERATED),
 (unsigned char) CRL_ENTRY_REASON_CODE_INDEX,
 (unsigned char) 0x00,
};

//----------------------------------------------------------------
// CRL Entry Invalidity Date extension control structure
//----------------------------------------------------------------
static  unsigned char CRLEntryInvalDateCtl[CRL_ENT_INVAL_DATE_CTL_SIZE]={

						// L1 GENTIME: Invalidity Date
						// DataIndex: 0, with header
 (unsigned char) (X_ONLY | DATA_INDEX | ANY_ASN1 | MUST_MATCH),
 (unsigned char) (ASN1_UNIVERSAL_GEN_TIMESTR),
 (unsigned char) CRL_ENTRY_INVAL_DATE_INDEX,
 (unsigned char) 0x00,
};
//----------------------------------------------------------------
// CRL Entry Certificate Issuer extension control structure
//----------------------------------------------------------------
static  unsigned char CRLEntryCertIssuerCtl[CRL_ENT_CERT_ISSUER_CTL_SIZE]={

						// L1 SEQUENCE: GeneralNames
						// DataIndex: 0
 (unsigned char) (X_ONLY | DATA_INDEX),
 (unsigned char) (ASN1_UNIVERSAL_SEQUENCE | ASN1_CONSTRUCTED),
 (unsigned char) CRL_ENTRY_CERT_ISSUER_INDEX,
 (unsigned char) 0x00,
};

//()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()
//
// PKCS7 Control structures
//
//()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()

//----------------------------------------------------------------
// PKCS7 Signed data Certificates Structure
//----------------------------------------------------------------
static  unsigned char Pkcs7CertsListCtl[PKCS7_CERTS_LIST_CTL_SIZE]={
						// L1 SEQ: ContentInfo, BER
 (unsigned char) (X_ONLY | CONSTRUCT),
 (unsigned char) (ASN1_UNIVERSAL_SEQUENCE | ASN1_CONSTRUCTED),
 (unsigned char) 0x00,
 (unsigned char) 0x00,
						// L2 OBJID: ContentType, BER
						// DataIndex: 0
 (unsigned char) (X_FIRST | DATA_INDEX),
 (unsigned char) (ASN1_UNIVERSAL_OBJECT_ID),
 (unsigned char) PKCS7_SDATA_OID_INDEX,
 (unsigned char) 0x00,

						// L2 ETAG[0]: Content, BER
 (unsigned char) (X_LAST | CONSTRUCT),
 (unsigned char)	(ASN1_CLASS_CONTEXT_SPECIFIC | ASN1_CONSTRUCTED | 0x00),
 (unsigned char) 0x00,
 (unsigned char) 0x00,

						// L3 SEQ: SignedData, BER
 (unsigned char) (X_ONLY | CONSTRUCT),
 (unsigned char) (ASN1_UNIVERSAL_SEQUENCE | ASN1_CONSTRUCTED),
 (unsigned char) 0x00,
 (unsigned char) 0x00,
						// L4 INT: Version
						// DataIndex: 1
 (unsigned char) (X_FIRST | DATA_INDEX),
 (unsigned char) (ASN1_UNIVERSAL_INTEGER),
 (unsigned char) PKCS7_SDATA_VERSION_INDEX,
 (unsigned char) 0x00,
						// L4 ANY: digestAlgors, BER ?
						// DataIndex: 2
 (unsigned char) (X_MIDDLE | DATA_INDEX | ANY_ASN1),
 (unsigned char) (ASN1_UNIVERSAL_EOC),
 (unsigned char) PKCS7_SDATA_DIGEST_ALGORS_INDEX,
 (unsigned char) 0x00,

						// L4 SEQ: ContentInfo, BER
 (unsigned char) (X_MIDDLE | CONSTRUCT),
 (unsigned char) (ASN1_UNIVERSAL_SEQUENCE | ASN1_CONSTRUCTED),
 (unsigned char) 0x00,
 (unsigned char) 0x00,
						// L5 OBJID: ContentType, BER
						// DataIndex: 3
 (unsigned char) (X_FIRST | DATA_INDEX),
 (unsigned char) (ASN1_UNIVERSAL_OBJECT_ID),
 (unsigned char) PKCS7_SDATA_DATA_OID_INDEX,
 (unsigned char) 0x00,
						// L5 ANY: Content, BER
						// DataIndex: 4
 (unsigned char) (X_LAST | DATA_INDEX | OPTIONAL | ANY_ASN1),
 (unsigned char) (ASN1_UNIVERSAL_EOC),
 (unsigned char) PKCS7_SDATA_DATA_CONT_INDEX,
 (unsigned char) 0x00,

						// L4 ETAG[0]: Certificates,BER
						// DataIndex: 5
 (unsigned char) (X_MIDDLE | DATA_INDEX),
 (unsigned char)	(ASN1_CLASS_CONTEXT_SPECIFIC | ASN1_CONSTRUCTED | 0x00),
 (unsigned char) PKCS7_SDATA_CERTS_INDEX,
 (unsigned char) 0x00,
						// L4 ETAG[1]: CRLs,BER
						// DataIndex: 6
 (unsigned char) (X_MIDDLE | DATA_INDEX | OPTIONAL | MUST_MATCH | ANY_ASN1),
 (unsigned char)	(ASN1_CLASS_CONTEXT_SPECIFIC | ASN1_CONSTRUCTED | 0x01),
 (unsigned char) PKCS7_SDATA_CRLS_INDEX,
 (unsigned char) 0x00,

						// L4 ANY: SignerInfos, BER ?
						// DataIndex: 7
 (unsigned char) (X_LAST | DATA_INDEX | ANY_ASN1),
 (unsigned char) (ASN1_UNIVERSAL_EOC),
 (unsigned char) PKCS7_SDATA_SIGNER_INFOS_INDEX,
 (unsigned char) 0x00,
};
//----------------------------------------------------------------
// Certificate Entries Control Structure (PKCS7)
//----------------------------------------------------------------
static  unsigned char X509CertEntryCtl[X509_CERT_ENTRY_CTL_SIZE]={

						// L1 SEQ: Certificate
 (unsigned char) (X_ONLY | DATA_INDEX | ANY_ASN1),
 (unsigned char) (ASN1_UNIVERSAL_SEQUENCE | ASN1_CONSTRUCTED),
 (unsigned char) X509_CERT_ENTRY_INDEX,
 (unsigned char) 0x00,
};

//-----------------------------------------------------------------------------
// This section was included from the file pchartab.hc
//-----------------------------------------------------------------------------

//----------------------------------------------------------------------
// Flags Tab for valid ASN.1 Printable String Characters (Range 00h-7Fh)
//----------------------------------------------------------------------

static  const char ASN1PrtStrFlagTab[128]  = {
//	        0            1            2            3
	(unsigned char) 0x00, (unsigned char) 0x00, (unsigned char) 0x00, (unsigned char) 0x00,// 00h-03h
//	       NUL
//
//	        4            5            6            7
	(unsigned char) 0x00, (unsigned char) 0x00, (unsigned char) 0x00, (unsigned char) 0x00,// 04h-07h
//
//
//	        8            9            A            B
	(unsigned char) 0x00, (unsigned char) 0x00, (unsigned char) 0x00, (unsigned char) 0x00,// 08h-0Bh
//	    BACK-TAB	    TAB 	  LF	       
//
//	        C            D            E            F
	(unsigned char) 0x00, (unsigned char) 0x00, (unsigned char) 0x00, (unsigned char) 0x00,// 0Ch-0Fh
//	        FF	     CR		  
//
//	        0            1            2            3
	(unsigned char) 0x00, (unsigned char) 0x00, (unsigned char) 0x00, (unsigned char) 0x00,// 10h-13h
//	                    DC1          DC2          DC3
//
//	        4            5            6            7
	(unsigned char) 0x00, (unsigned char) 0x00, (unsigned char) 0x00, (unsigned char) 0x00,// 14h-17h
//	       DC4
//
//	        8            9            A            B
	(unsigned char) 0x00, (unsigned char) 0x00, (unsigned char) 0x00, (unsigned char) 0x00,// 18h-1Bh
//	        
//
//	        C            D            E            F
	(unsigned char) 0x00, (unsigned char) 0x00, (unsigned char) 0x00, (unsigned char) 0x00,// 1Ch-1Fh
//	        
//
//	        0            1            2            3
	(unsigned char) 0x01, (unsigned char) 0x00, (unsigned char) 0x01, (unsigned char) 0x00,// 20h-23h
//	       Space	     !		  "		#	
//
//	        4            5            6            7
	(unsigned char) 0x00, (unsigned char) 0x00, (unsigned char) 0x00, (unsigned char) 0x00,// 24h-27h
//	        $            %            &            '
//
//	        8            9            A            B
	(unsigned char) 0x01, (unsigned char) 0x01, (unsigned char) 0x00, (unsigned char) 0x01,// 28h-2Bh
//	        (	     )		  *	       +
//
//	        C            D            E            F
	(unsigned char) 0x01, (unsigned char) 0x01, (unsigned char) 0x0B, (unsigned char) 0x01,// 2Ch-2Fh
//		,	     -		  .	       /
//
//	        0            1            2            3
	(unsigned char) 0x01, (unsigned char) 0x01, (unsigned char) 0x01, (unsigned char) 0x01,// 30h-33h
//	       '0'          '1'		 '2'	      '3'
//
//	        4            5            6            7
	(unsigned char) 0x01, (unsigned char) 0x01, (unsigned char) 0x01, (unsigned char) 0x01,// 34h-37h
//	       '4'          '5'          '6'          '7'
//
//	        8            9            A            B
	(unsigned char) 0x01, (unsigned char) 0x01, (unsigned char) 0x01, (unsigned char) 0x00,// 38h-3Bh
//	       '8'          '9'           :            ;
//
//	        C            D            E            F
	(unsigned char) 0x00, (unsigned char) 0x01, (unsigned char) 0x00, (unsigned char) 0x01,// 3Ch-3Fh
//	        <            =            >            ? 
//
//	        0            1            2            3
	(unsigned char) 0x00, (unsigned char) 0x01, (unsigned char) 0x01, (unsigned char) 0x01,// 40h-43h
//	        @            A            B            C 
//
//	        4            5            6            7
	(unsigned char) 0x01, (unsigned char) 0x01, (unsigned char) 0x01, (unsigned char) 0x01,// 44h-47h
//	        D            E            F            G
//
//	        8            9            A            B
	(unsigned char) 0x01, (unsigned char) 0x01, (unsigned char) 0x01, (unsigned char) 0x01,// 48h-4Bh
//	        H            I            J            K
//
//	        C            D            E            F
	(unsigned char) 0x01, (unsigned char) 0x01, (unsigned char) 0x01, (unsigned char) 0x01,// 4Ch-4Fh
//	        L            M            N            O
//
//	        0            1            2            3
	(unsigned char) 0x01, (unsigned char) 0x01, (unsigned char) 0x01, (unsigned char) 0x01,// 50h-53h
//	        P            Q            R            S
//
//	        4            5            6            7
	(unsigned char) 0x01, (unsigned char) 0x01, (unsigned char) 0x01, (unsigned char) 0x01,// 54h-57h
//	        T            U            V            W
//
//	        8            9            A            B
	(unsigned char) 0x01, (unsigned char) 0x01, (unsigned char) 0x01, (unsigned char) 0x00,// 58h-5Bh
//	        X            Y            Z             [
//
//	        C            D            E            F
	(unsigned char) 0x00, (unsigned char) 0x00, (unsigned char) 0x00, (unsigned char) 0x00,// 5Ch-5Fh
//	        \            ]            ^            _
//
//	        0            1            2            3
	(unsigned char) 0x01, (unsigned char) 0x01, (unsigned char) 0x01, (unsigned char) 0x01,// 60h-63h
//	        `            a            b            c
//
//	        4            5            6            7
	(unsigned char) 0x01, (unsigned char) 0x01, (unsigned char) 0x01, (unsigned char) 0x01,// 64h-67h
//	        d            e            f            g
//
//	        8            9            A            B
	(unsigned char) 0x01, (unsigned char) 0x01, (unsigned char) 0x01, (unsigned char) 0x01,// 68h-6Bh
//	        h            i            j            k
//
//	        C            D            E            F
	(unsigned char) 0x01, (unsigned char) 0x01, (unsigned char) 0x01, (unsigned char) 0x01,// 6Ch-6Fh
//	        l            m            n            o
//
//	        0            1            2            3
	(unsigned char) 0x01, (unsigned char) 0x01, (unsigned char) 0x01, (unsigned char) 0x01,// 70h-73h
//	        p            q            r            s
//
//	        4            5            6            7
	(unsigned char) 0x01, (unsigned char) 0x01, (unsigned char) 0x01, (unsigned char) 0x01,// 74h-77h
//	        t            u            v            w
//
//	        8            9            A            B
	(unsigned char) 0x01, (unsigned char) 0x01, (unsigned char) 0x01, (unsigned char) 0x00,// 58h-5Bh
//	        x            y            z            {
//
//	        C            D            E            F
	(unsigned char) 0x00, (unsigned char) 0x00, (unsigned char) 0x00, (unsigned char) 0x00,// 7Ch-7Fh
//	        |            }            ~           DEL 
};

/**
* Encodes given number of X.509 certificate extension elements (triples with
* Object ID, critical flag, value) given in an IDATA pointer array starting 
* at specified index to the ASN.1 encoding (ToASN1_EXT).
*  A destination buffer is allocated
* and the encoding stored to that buffer. The buffer and used data length are
* returned.
*
*  @param DatArray Array loaded with
*               data elements
*  @param DatArrayIndex First index to use
*  @param DatArrayCnt Number of elements loaded
*  @param pDstBuf Destination array base ptr
*  @param DstLen Length of data returned
*  @param SubErrCode Error Code from higher level
*
*  @return ASN1_OP_OK on success, error code otherwise
*/
static  int  ToASN1_EXT(HMEM_CTX_DEF
			IDATA** DatArray,
			int DatArrayIndex,int DatArrayCnt,
			char** pDstBuf, int* DstLen,
			int* SubErrCode)
{
  int i;

  i = ToASN1_SubStr(HMEM_CTX_REF1 DatArray,DatArrayIndex,DatArrayCnt,(char*)X509ExtCtl,X509_EXT_CTL_CNT,X509_EXT_MAX_DATA_INDEX,pDstBuf,DstLen);

  if(i == ASN1_OP_OK) return(i);
  SubErrCode[0] = i;
  return(ASN1_INT_TO_RDN_ERROR);
}

/**
* Convert a byte value to 2 ASCII Hex Nibbles in internal notation (ByteValToIntstr).
*
*  @param Value Byte calue for conversion
*  @param pDstBuf Destination buffer
*  @param DstOff Offset for writing
*/
static  void  ByteValToIntstr(char Value, char* pDstBuf,
					 int DstOff)
{
  char c;
  c = (unsigned char) ((Value & 0x0F) + (unsigned char) '0');	// low nibble to ASCII
  if(c > (unsigned char) '9') c += 7;			// to HEX
  Value = (unsigned char) (((Value>>4) & 0x0F) + (unsigned char) '0');// high nibble to ASCII
  if(Value > (unsigned char) '9') Value += 7;		// to HEX
  pDstBuf[DstOff] = 0;				// clear MSB
  pDstBuf[DstOff+1] = Value;			// Store high nibble
  pDstBuf[DstOff+2] = 0;			// clear MSB
  pDstBuf[DstOff+3] = c;			// Store low nibble
}

/**
* Converts internal large number to a readable hex string in internal string 
* format (BIGwords with leading ElementCount) (FromLnum_ToHexString). 
* The string is stored in a newly
* allocated buffer.
*
* NOTE: Number of string elements is limited to 10000
*
*  @param lplnum Large Number to convert
*  @param pDstBuf Return parameter for new buffer
*  @return ASN1_OP_OK on success, error code otherwise
*/
extern "C"  int  FromLnum_ToHexString(HMEM_CTX_DEF
			WLARGENUM* lplnum, char** pDstBuf)
{
  int SrcIndex;
  int SrcLen;
  int DstLen;
  int DstIndex=0;

  int RemainCnt;
  int WElement;

  char* pBuf = NULL;

  int * lpEl;
  //-----------------------------------------
  // Check pointers
  //-----------------------------------------
  if((lplnum == NULL) || (pDstBuf == NULL))
    return(ASN1_FROM_LNUMHEX_NULLPTR_ERR);
  pDstBuf[0] = NULL;
  //-------------------------------------------
  // Check if number present, if so, get length
  //-------------------------------------------
  lpEl = lplnum->lpEl;
  if(lpEl == NULL)
    return(ASN1_OP_OK);				// not present
  SrcLen = lplnum->UsedSize;		// number of elements
  //-------------------------------------------
  // check for Number Zero
  //-------------------------------------------
  if(SrcLen == 0)				// Zero, special case
  {
    pBuf = BIT8_ARRAY_ALLOC(HMEM_CTX_REF,4);	// 1 Element + length
    if(pBuf == NULL)
      return(ASN1_FROM_LNUMHEX_ALLOC_ERR);
    BIGword2char(1,pBuf,DstIndex);		// set element count 1
    pBuf[DstIndex++] = 0;			// set NUL
    pBuf[DstIndex] = (unsigned char) '0';		// set ASCII 0
    pDstBuf[0] = pBuf;
    return(ASN1_OP_OK);
  }
  //-------------------------------------------------
  // Allocate required destination buffer
  //-------------------------------------------------
  DstLen = GetByteCntWLnum(lplnum);	// get size in bytes (!)
  pBuf = BIT8_ARRAY_ALLOC(HMEM_CTX_REF,(DstLen*2+1)*2);	// 2 nibbles per byte to word!
  if(pBuf == NULL)
    return(ASN1_FROM_LNUMHEX_ALLOC_ERR);
  //-------------------------------------------------
  // Set Element Count, convert to HEX
  // CHANGE THAT !!!!
  //-------------------------------------------------
  BIGword2char((DstLen*2),pBuf,DstIndex);	// set element count * 2
  SrcIndex = SrcLen-1;				// top Element Index

  WElement = lpEl[SrcIndex];
  RemainCnt = (DstLen & 0x03);		// incomplete Element byte count
  if(RemainCnt != 0)
  {
    while(RemainCnt != 0)
    {
      RemainCnt--;
      ByteValToIntstr((char) (WElement >> (RemainCnt*8)), pBuf, DstIndex);
      DstIndex += 4;
    }
    SrcIndex--;
  }
  while(SrcIndex >= 0)
  {
    WElement = lpEl[SrcIndex];
    ByteValToIntstr((char) (WElement >> 24), pBuf, DstIndex);
    DstIndex += 4;
    ByteValToIntstr((char) (WElement >> 16), pBuf, DstIndex);
    DstIndex += 4;
    ByteValToIntstr((char) (WElement >>  8), pBuf, DstIndex);
    DstIndex += 4;
    ByteValToIntstr((char) WElement, pBuf, DstIndex);
    DstIndex += 4;
    SrcIndex--;
  }  

  pDstBuf[0] = pBuf;
  return(ASN1_OP_OK);
}
/**
* Converts byte array to a readable hex string in internal string format 
* (BIGwords with leading ElementCount) (FromBytes_ToHexString). 
* The string is stored in a newly 
* allocated buffer.
*
* NOTE: Number of string elements is limited to 10000
*
*  @param SrcBuf Buffer containing data to convert
*  @param SrcOff Start offset of data
*  @param SrcLen Length of data
*  @param pDstBuf Return parameter for new buffer
*  @return ASN1_OP_OK on success, error code otherwise
*/
extern "C"  int  FromBytes_ToHexString(HMEM_CTX_DEF
	char* SrcBuf, int SrcOff, int SrcLen, char** pDstBuf)
{
  char	c,c1;

  int SrcIndex = SrcOff;
  int DstIndex=0;

  char* pBuf = NULL;
  //-----------------------------------------
  // Check pointers
  //-----------------------------------------
  if((SrcBuf == NULL) || (pDstBuf == NULL))
    return(ASN1_FROM_BYTES_NULLPTR_ERR);
  pDstBuf[0] = NULL;
  if(SrcLen == 0)
    return(ASN1_OP_OK);
  if(SrcLen > (0x7FFF-8))		// max. length
    return(ASN1_FROM_BYTES_INV_LEN_ERR);
  //-------------------------------------------------
  // Allocate required destination buffer
  //-------------------------------------------------
  pBuf = BIT8_ARRAY_ALLOC(HMEM_CTX_REF,
			  (int) (SrcLen*2+1)*2);// 2 nibbles per byte to word!
  if(pBuf == NULL)
    return(ASN1_FROM_BYTES_ALLOC_ERR);
  //-------------------------------------------------
  // Set Element Count, convert to HEX
  //-------------------------------------------------
  BIGword2char((SrcLen*2),pBuf,DstIndex);	// set element count * 2
  do
  {
    c = SrcBuf[SrcIndex++];			// get byte
    c1 = (unsigned char) ((c & 0x0F) + (unsigned char) '0');	// low nibble to ASCII
    if(c1 > (unsigned char) '9') c1 += 7;		// to HEX
    c = (unsigned char) (((c>>4) & 0x0F) + (unsigned char) '0');	// high nibble to ASCII
    if(c > (unsigned char) '9') c += 7;			// to HEX
    pBuf[DstIndex++] = 0;			// clear MSB
    pBuf[DstIndex++] = c;			// Store high nibble
    pBuf[DstIndex++] = 0;			// clear MSB
    pBuf[DstIndex++] = c1;			// Store low nibble
    SrcLen--;
  }while(SrcLen != 0);
  pDstBuf[0] = pBuf;
  return(ASN1_OP_OK);
}
/**
* Converts ASN.1 integer/bitstring/octetstring to  a readable hex string in 
* internal string format (BIGwords with leading ElementCount) (FromASN1_IntBitOctToHexString). 
* The string is 
* stored in a newly allocated buffer.
* If Input type is an ASN1-Integer supresses leading zero byte.
*
* NOTE: Number of string elements is limited to 10000 !
*
*  @param SrcBuf Buffer containing data to convert
*  @param SrcOff Start offset of data
*  @param SrcLen Length of data
*  @param pDstBuf Allocated Element
*  @return ASN1_OP_OK on success, error code otherwise
*/
extern "C"  int  FromASN1_IntBitOctToHexString(HMEM_CTX_DEF
	char* SrcBuf, int SrcOff, int SrcLen, char** pDstBuf)
{
  char	c,c1;

  int SrcIndex = SrcOff;

  int DstIndex=0;
  int DstCnt;

  int i;

  int ASN1Type;

  int pTmpLen[1];

  char* pBuf = NULL;

  //-----------------------------------------
  // Check pointers
  //-----------------------------------------
  if((SrcBuf == NULL) || (pDstBuf == NULL))
    return(ASN1_FROM_INTBOC_NULLPTR_ERR);
  if(SrcLen < 2)
    return(ASN1_FROM_INTBOC_INSUF_DATA_ERR);
  pDstBuf[0] = NULL;
  //------------------------------------------------------------
  // Get ASN.1 Type and length
  //------------------------------------------------------------
  ASN1Type = SrcBuf[SrcIndex++];		// get type
  SrcLen--;
						// get length and lenfld len:
  i = DecodeASN1_LenField(SrcBuf,SrcIndex,SrcLen,pTmpLen);
  if(i < 0)
  {
    if(i == -1)
      return(ASN1_FROM_INTBOC_INSUF_DATA_ERR);
    return(ASN1_FROM_INTBOC_INV_LEN_ERR);
  }
  SrcIndex += i;			// skip lengthfield
  DstCnt = pTmpLen[0];			// fetch data count
  if(DstCnt == 0)			// no data -> no output
    return(ASN1_OP_OK);
  if(DstCnt > (0x7FFF-8))		// max. length
    return(ASN1_FROM_INTBOC_INV_LEN_ERR);
  //--------------------------------------------------
  // Check for Integer/Octetstring type
  //--------------------------------------------------
  if((ASN1Type != ASN1_UNIVERSAL_INTEGER) &&
     (ASN1Type != ASN1_UNIVERSAL_BITSTRING) &&
     (ASN1Type != ASN1_UNIVERSAL_OCTETSTRING))
      return(ASN1_FROM_INTBOC_INV_TYPE_ERR);
  //-------------------------------------------------
  // Allocate required destination buffer
  //-------------------------------------------------
  pBuf = BIT8_ARRAY_ALLOC(HMEM_CTX_REF,
			  (int) (DstCnt*2+1)*2);// 2 nibbles per byte to word!
  if(pBuf == NULL)
    return(ASN1_FROM_INTBOC_ALLOC_ERR);
  //-------------------------------------------------
  // Check for leading zero in Integer
  //-------------------------------------------------
  if((ASN1Type == ASN1_UNIVERSAL_INTEGER) &&	// check for integer
     (SrcBuf[SrcIndex] == 0))			// check for leading zero
  {
    //---------------------------------------------------
    // ASN.1 integer with leading zero, check if only one
    //---------------------------------------------------
    if(DstCnt == 1)				// is the only one
    {
      BIGword2char(DstCnt,pBuf,DstIndex);	// set element count 1
      pBuf[DstIndex++] = 0;			// set NUL
      pBuf[DstIndex] = (unsigned char) '0';		// set ASCII 0
      pDstBuf[0] = pBuf;
      return(ASN1_OP_OK);
    }
    DstCnt--;					// reduce count
    SrcIndex++;					// skip Element
  }
  //-------------------------------------------------
  // Set Element Count, convert to HEX
  //-------------------------------------------------
  BIGword2char((DstCnt*2),pBuf,DstIndex);	// set element count * 2
  do
  {
    c = SrcBuf[SrcIndex++];			// get byte
    c1 = (unsigned char) ((c & 0x0F) + (unsigned char) '0');	// low nibble to ASCII
    if(c1 > (unsigned char) '9') c1 += 7;		// to HEX
    c = (unsigned char) (((c>>4) & 0x0F) + (unsigned char) '0');	// high nibble to ASCII
    if(c > (unsigned char) '9') c += 7;			// to HEX
    pBuf[DstIndex++] = 0;			// clear MSB
    pBuf[DstIndex++] = c;			// Store high nibble
    pBuf[DstIndex++] = 0;			// clear MSB
    pBuf[DstIndex++] = c1;			// Store low nibble
    DstCnt--;
  }while(DstCnt != 0);
  pDstBuf[0] = pBuf;
  return(ASN1_OP_OK);
}
/**
* Converts ASN.1 Timestring of
* types UTC-Time and GeneralTime format to Time Array (FromASN1_TimeString). 
* The result is stored
* in a newly allocated buffer.
*
*  @param SrcBuf Buffer containing data to convert
*  @param SrcOff Start offset of data
*  @param SrcLen Length of data
*  @param ppTimeArray Pointer where to store time array structure
*  @return ASN1_OP_OK on success, error code otherwise
*/
extern "C"  int  FromASN1_TimeString(HMEM_CTX_DEF
	char* SrcBuf, int SrcOff, int SrcLen, int** ppTimeArray)
{
  char ASN1Type;

  int SrcIndex = SrcOff;

  int i;

  int TimeType;

  int TmpLen;
  int pTmpLen[1];

  int* pTimeArray;
  //-----------------------------------------
  // Check pointers
  //-----------------------------------------
  if((SrcBuf == NULL) || (ppTimeArray == NULL))
    return(ASN1_FROM_TIMESTR_NULLPTR_ERR);
  if(SrcLen < 2)
    return(ASN1_FROM_TIMESTR_DATA_MISSING);
  ppTimeArray[0] = NULL;
  //------------------------------------------------------------
  // Get ASN.1 Type and length, check if a recognized Timetype
  //------------------------------------------------------------
  ASN1Type = SrcBuf[SrcIndex++];		// get type
  SrcLen--;
						// get length and lenfld len:
  i = DecodeASN1_LenField(SrcBuf,SrcIndex,SrcLen,pTmpLen);
  if(i < 0)
  {
    if(i == -1) return(ASN1_FROM_TIMESTR_DATA_MISSING);
    return(ASN1_FROM_TIMESTR_INV_LEN);
  }
  SrcIndex += i;			// skip lengthfield
  TmpLen = pTmpLen[0];			// fetch data count
  if(TmpLen == 0)			// no data -> no output
    return(ASN1_OP_OK);
  if(TmpLen > (0x7FFF-8))		// max. length
    return(ASN1_FROM_TIMESTR_INV_LEN);

  switch(ASN1Type)
  {
    case ASN1_UNIVERSAL_UTC_TIMESTR:
      TimeType = ASN1_TIME_TYPE_UTC;
      break;

    case ASN1_UNIVERSAL_GEN_TIMESTR:
      TimeType = ASN1_TIME_TYPE_GENTIME;
      break;

    default:
      return(ASN1_FROM_TIMESTR_INV_TYPE);
  }
  //--------------------------------------------------
  // Allocate the Time Array
  //--------------------------------------------------
  pTimeArray = INT_ARRAY_ALLOC(HMEM_CTX_REF,TIME_ARRAY_SIZE);
  if(pTimeArray == NULL)
    return(ASN1_FROM_TIMESTR_ALLOC_ERR);
  //--------------------------------------------------
  // Convert to time array in absolut (UTC) Format
  //--------------------------------------------------
  i = ConvChkASN1_TimeStr(SrcBuf,SrcIndex,(int) TmpLen,pTimeArray,TimeType);
  if(i != ASN1_OP_OK)
  {
    FREE_ARRAY(HMEM_CTX_REF,pTimeArray);
    return(ASN1_FROM_TIMESTR_DECODE_ERR);
  }
  ppTimeArray[0] = pTimeArray;
  return(i);
}

/**
* Converts an OID subelement byte string to internal HEX notation (ConvStoreOidSubElemToHexIntstr).
*<ul>
* <li> The byte string is compacted from 7 Bit input to full 8 bit output.
* <li> A header with '0x' is prepended.
* <li> No intervening spaces are output.
*</ul>
* NOTE: No parameters checked
*
*  @param pSrcBuf Input data buffer
*  @param SrcOff Start in buffer
*  @param SrcLen Number of source bytes
*  @param pDstBuf Output buffer base
*  @param DstOff Offset for output
*  @return Number of bytes written
*/
static  int  ConvStoreOidSubElemToHexIntstr(char* pSrcBuf,
	int SrcOff, int SrcLen, char* pDstBuf, int DstOff)
{
  char c;
  int DstStartOff = DstOff;
  int AvailableBitCnt;
  int CollectBuf;
  //---------------------------------------------------------
  // Output prefix data
  //---------------------------------------------------------
  pDstBuf[DstOff++] = 0;
  pDstBuf[DstOff++] = (unsigned char) '0';
  pDstBuf[DstOff++] = 0;
  pDstBuf[DstOff++] = (unsigned char) 'x';
  //---------------------------------------------------------
  // Check special case of zero input size
  //---------------------------------------------------------
  if(SrcLen <= 0)
  {
    pDstBuf[DstOff++] = 0;
    pDstBuf[DstOff++] = (unsigned char) '0';
  }
  else
  {
    //-------------------------------------------------------------
    // Calculate number of source bits, set available bits, convert
    //-------------------------------------------------------------
    CollectBuf = 0;				// clear (pseudo available)
    AvailableBitCnt  = 8 - ((SrcLen * 7)%8);	// number of unused bits, 
    while(SrcLen != 0)
    {
      CollectBuf <<= 7;				// shift up current bits
      CollectBuf |= (int) pSrcBuf[SrcOff++] & 0x7F; // insert next bits
      AvailableBitCnt += 7;			// new number of bits available
      SrcLen--;
      while(AvailableBitCnt >= 4)
      {
        AvailableBitCnt -= 4;			// reduce amount available
        c = (unsigned char) (((CollectBuf >> AvailableBitCnt) & 0x0F) + 0x30); //ASCII Nib
        if(c > (unsigned char) 0x39)			// convert to ASCII letter
          c = (unsigned char) (c + 7);
        pDstBuf[DstOff++] = 0;
        pDstBuf[DstOff++] = c;
      } 
    }
  }
  return(DstOff-DstStartOff);
}

/**
* Converts an OID Subelement byte string to internal DECIMAL notation (ConvStoreOidSubElemToDecIntstr).
*<ul>
* <li> The byte string size *MUST* be limited to 4 bytes (9 decimal digits).
* <li> Leading Zeroes are suppressed.
* <li> No intervening spaces are output.
*</ul>
* NOTE: No parameters checked !!!
*
*  @param pSrcBuf Input data buffer
*  @param SrcOff Start in buffer
*  @param SrcLen Number of source bytes
*  @param pDstBuf Output buffer base
*  @param DstOff Offset for output
*  @return Number of bytes(!) written
*/
static  int  ConvStoreOidSubElemToDecIntstr(char* pSrcBuf,
	int SrcOff, int SrcLen, char* pDstBuf, int DstOff)
{
#define	INT_DIGIT_BUF_SIZE	18
  char c;
  int TmpIndex, TmpCnt;
  int CollectBuf = 0;
  char IntDigitBuf[INT_DIGIT_BUF_SIZE];
  //--------------------------------------------------------
  // Get the Bitrepresentation from the input string
  //--------------------------------------------------------
  while(SrcLen > 0)
  {
    CollectBuf <<= 7;					// shift up old bits
    CollectBuf |= (int) (pSrcBuf[SrcOff++] & 0x7F);	// insert new bits
    SrcLen--;
  }
  //---------------------------------------------------------
  // Convert the bitrepresentation to decimal internal buffer
  //---------------------------------------------------------
  TmpIndex = INT_DIGIT_BUF_SIZE-1;	// least sign. decimal buffer index
  do
  {
    c = (unsigned char) (CollectBuf%10 + 0x30);	// get low digit value in ASCII
    IntDigitBuf[TmpIndex] = c;		// store it
    TmpIndex--;
    IntDigitBuf[TmpIndex] = 0;
    TmpIndex--;
    CollectBuf = CollectBuf/10;
  }while(CollectBuf != 0);
  //---------------------------------------------------------
  // Copy the data to the destination now
  //---------------------------------------------------------
  TmpCnt = (INT_DIGIT_BUF_SIZE-1)-TmpIndex;
  memcpy(pDstBuf+DstOff,IntDigitBuf+TmpIndex+1,TmpCnt);
  return(TmpCnt);
}

/**
* Converts an ASN.1 object ID to a decimal dot string in internal
* notification. The result is stored in a newly allocated buffer (OIDToIntStr).
*
* Restrictions:
* SubElements longer than 4 bytes will be output as HEX.
* 
* NOTE: OID without TAG and length expected
*
*  @param pOidBuf OID buffer base
*  @param OidOffset Start of OID in buffer
*  @param OidLen Size of OID
*  @param ppDstBuf Pointer where to store destination buffer
*  @param pDstBufLen Pointer where to store size of data in buffer. Optional
*  @return 0 on success, error code otherwise
*/
extern "C"  int  OIDToIntStr(HMEM_CTX_DEF
		char* pOidBuf, int OidOffset, int OidLen,
		char** ppDstBuf, int* pDstBufLen)
{
  char c=0;
  int i;
  int SrcIndex, TopIndex, DstIndex, DstStartIndex;
  int DstCharCnt, TmpSrcIndex, TmpDstIndex, TmpLen;
  int ElementByteCnt;
  int ElementBuf;
  char* pTmpSrcBuf;
  char* pDstBuf;
  //-----------------------------------------------------------------
  // Check parameters
  //-----------------------------------------------------------------
  if((pOidBuf == NULL) || (ppDstBuf == NULL))
    return(ASN1_NULL_PTR);
  if(OidLen <= 0)
    return(ASN1_PARAM_ERR);
  ppDstBuf[0]   = NULL;
  if(pDstBufLen != NULL)
    pDstBufLen[0] = 0;
  //------------------------------------------------------
  // Calculate the number of needed destination characters
  //------------------------------------------------------
  TopIndex = OidOffset + OidLen;
  SrcIndex = OidOffset;
  DstCharCnt = 0;
  while(SrcIndex < TopIndex)
  {
    //----------------------------------------------------
    // Count bytes of OID Sub Element
    //----------------------------------------------------
    ElementByteCnt = 0;
    while(SrcIndex < TopIndex)
    {
      c = pOidBuf[SrcIndex++];
      ElementByteCnt++;
      if((c & 0x80) == 0)			// last byte for element
        break;
    }
    if((c & 0x80) != 0)				// ended with MSB set !!!
      return(ASN1_OID_TO_INTSTR_INVALID_OID);
    //--------------------------------------------------------------
    // Calculate required number of characters needed for element
    // 7 Bits are relevant per byte, up to 4 bytes will be converted
    //--------------------------------------------------------------
    if(ElementByteCnt <= 4)			// DEZ, max. 9 decimals + dot
    {
      DstCharCnt += (ElementByteCnt*2) + 1 + 1;
    }
    else					// HEX, '0x' leader+dot
    {
      DstCharCnt += (ElementByteCnt*2) + 2 + 1;
    }
  }
  //--------------------------------------------------------------------
  // Calculate number of internal elements needed incl. header, allocate
  //--------------------------------------------------------------------
  DstCharCnt += 4;				// for first element (special)
  DstCharCnt = ((DstCharCnt + 1) * 2);		// incl. Element count prefix
  if((pDstBuf = BIT8_ARRAY_ALLOC(HMEM_CTX_REF,DstCharCnt)) == NULL)
    return(ASN1_ALLOC_ERR);
  DstIndex = 2;					// start past element count
  DstStartIndex = DstIndex;			// save for later
  //--------------------------------------------------------------------
  // Convert the elements now; first must be treated special...
  //--------------------------------------------------------------------
  SrcIndex = OidOffset;
  while(SrcIndex < TopIndex)
  {
    c = (unsigned char) (pOidBuf[SrcIndex++] & 0xFF);	// get Subelement byte
    if((c & 0x80) == 0)				// last byte of SubElement
      break;
  }
  ElementByteCnt = SrcIndex - OidOffset;
  //-----------------------------------------------------------------------
  // Output first Element X,Y components (Note that W = X*40 + Y, W <= 127)
  //-----------------------------------------------------------------------
  if(ElementByteCnt == 1)			// X = 0/1 and 0 <= Y <= 39)
  {						// *OR* X = 2 and 0 <= Y <= 47
    //-----------------------------------------------------------
    // Both elements are included in the first byte (BIT 7 == 0!)
    // Calculate the 1st and 2nd component for output
    //-----------------------------------------------------------
    i = (int) c;				// NOTE: Bit 7 = 0 !
    if(i < 40)					// X = 0, 0 <= Y <= 39	
    {
      c = (unsigned char) '0';					// X = 0
    }  
    else if(i < 80)				// X = 1, 0 <= Y <= 39	
    {
      c = (unsigned char) '1';				// X = 1
      i -= 40;
    }
    else					// X = 2, 0 <= Y <= 47
    {
      c = (unsigned char) '2';				// X = 1
      i -= 80;
    }
    pDstBuf[DstIndex++] = 0;			// Clear MSB of X
    pDstBuf[DstIndex++] = c;			// store X value

    pDstBuf[DstIndex++] = 0;			// Clear MSB
    pDstBuf[DstIndex++] = (unsigned char) '.';		// store 'Dot'

    c = (unsigned char) ((i / 10) + 0x30);		// get Y high digit
    if(c != (unsigned char) 0x30)			// non zero...
    {
      pDstBuf[DstIndex++] = 0;			// Clear MSB
      pDstBuf[DstIndex++] = c;			// store Y high digit
    }
    c  = (unsigned char) ((i % 10) + 0x30);		// get Y low digit
    pDstBuf[DstIndex++] = 0;			// Clear MSB
    pDstBuf[DstIndex++] = c;			// set low digit
  }
  else
  {
    //--------------------------------------------------------------
    // Second Sub-Element Y, has *MORE* than one byte, so:
    // First element X = 2, Y element is any size MINUS 80 (decimal)
    // another still more weird case, allocate temporary buffer...
    //--------------------------------------------------------------
    if((pTmpSrcBuf = BIT8_ARRAY_ALLOC(HMEM_CTX_REF,ElementByteCnt)) == NULL)
    {
      FREE_CARRAY(HMEM_CTX_REF,pDstBuf);
      return(ASN1_ALLOC_ERR);
    }
    //--------------------------------------------------------------
    // Copy the SubElement's components to helper buffer, subtract
    // 80 = 2 * 40 to get Y (in 7 Bit packed format!)
    //--------------------------------------------------------------
    memcpy(pTmpSrcBuf+0,pOidBuf+OidOffset,ElementByteCnt);

    ElementBuf = -80;				// value to subtract...
    TmpDstIndex = ElementByteCnt - 1;		// start from LSB (right most)
    while(TmpDstIndex >= 0)
    {
      ElementBuf += ((int) pTmpSrcBuf[TmpDstIndex] & 0x7F); // subtract
      c = (unsigned char) (pTmpSrcBuf[TmpDstIndex] & 0x80); // save the MSB bit
      pTmpSrcBuf[TmpDstIndex] = (unsigned char)		// store back, 7 bits, MSB kept
        ((ElementBuf & 0x7F) | c);
      ElementBuf = (ElementBuf >> 7);		// isolate Borrow/Carry
      TmpDstIndex--;
    }
    //--------------------------------------------------------------
    // Set up conversion mode and convert now
    //--------------------------------------------------------------
    pDstBuf[DstIndex++] = 0;			// Clear MSB of first (X)
    pDstBuf[DstIndex++] = (unsigned char) '2';		// X == 2
    pDstBuf[DstIndex++] = 0;			// Clear MSB
    pDstBuf[DstIndex++] = (unsigned char) '.';
    if(ElementByteCnt <= 4)			// can be represented normal...
    {
      TmpLen = ConvStoreOidSubElemToDecIntstr(pTmpSrcBuf,0,ElementByteCnt,
	                                      pDstBuf, DstIndex);
    }
    else
    {
      TmpLen = ConvStoreOidSubElemToHexIntstr(pTmpSrcBuf,0,ElementByteCnt,
					      pDstBuf, DstIndex);
    }
    DstIndex += TmpLen;
    FREE_CARRAY(HMEM_CTX_REF,pTmpSrcBuf);
  }
  //---------------------------------------------------------------
  // Process the remaining elements now, one by one...
  //---------------------------------------------------------------
  OidLen -= ElementByteCnt;
  while(OidLen != 0)
  {
    //-------------------------------------------------------------
    // Sub-Element is to follow, output a 'Dot'
    //-------------------------------------------------------------
    pDstBuf[DstIndex++] = 0;			// Clear MSB
    pDstBuf[DstIndex++] = (unsigned char) '.';		// Set 'Dot'

    ElementByteCnt = 0;
    TmpSrcIndex = SrcIndex;
    while(OidLen != 0)
    {
      ElementByteCnt++;
      OidLen--;
      c = pOidBuf[SrcIndex++];
      if((c & 0x80) == 0)
        break;
    }
    if(ElementByteCnt <= 4)			// can be represented normal...
    {
      TmpLen = ConvStoreOidSubElemToDecIntstr(pOidBuf,TmpSrcIndex,
				ElementByteCnt, pDstBuf, DstIndex);
    }
    else
    {
      TmpLen = ConvStoreOidSubElemToHexIntstr(pOidBuf,TmpSrcIndex,
				ElementByteCnt, pDstBuf, DstIndex);
    }
    DstIndex += TmpLen;
  }
  //-------------------------------------------------------------
  // store number of internal elements
  //-------------------------------------------------------------
  TmpLen = (DstIndex - DstStartIndex) / 2;	// Elements = bytes/2
  pDstBuf[0] = (unsigned char) (TmpLen >> 8);	// Store MSB
  pDstBuf[1] = (unsigned char) (TmpLen);	// Store LSB
  
  ppDstBuf[0]   = pDstBuf;
  if(pDstBufLen != NULL)
    pDstBufLen[0] = DstIndex;			// used size...
  return(ASN1_OP_OK);
} 

/**
* Frees an X501 Attribute/Value
* string structure and the attribute OID/attribute value elements (FreeX501AvaStr_Struc).
*
*  @param pAvaStruc Pointer to structure
*/
static  void  FreeX501AvaStr_Struc(HMEM_CTX_DEF
					      X501_AVA_STR * pAvaStruc)
{
  //---------------------------------------------
  // Check parameters
  //---------------------------------------------
  if(pAvaStruc == NULL)				// no descriptor
    return;
  //---------------------------------------------
  // release buffers and structure itself
  //---------------------------------------------
  FREE_ARRAY(HMEM_CTX_REF,pAvaStruc->pOidStr);
  FREE_ARRAY(HMEM_CTX_REF,pAvaStruc->pValStr);
  FREE_ARRAY(HMEM_CTX_REF,pAvaStruc);
}
/**
* Allocates an X501 attribute
* type/value string description structure used in RDN elements (AllocX501AvaStr_Struc).
*
*  @return Pointer to the allocated structure, NULL on failure
*/
static  X501_AVA_STR *  AllocX501AvaStr_Struc(HMEM_CTX_DEF1)
{
  X501_AVA_STR * pAvaStruc;
  //----------------------------------------------------------
  // 1. Allocate the structure itself, clear it
  //----------------------------------------------------------
  pAvaStruc = (X501_AVA_STR *) BIT8_ARRAY_CALLOC(HMEM_CTX_REF,
					1, sizeof(X501_AVA_STR));
  if(pAvaStruc == NULL)
    return(NULL);
  //----------------------------------------------------------------
  // 2. Initialize structure types indicators
  //----------------------------------------------------------------
  pAvaStruc->OidIndex = -1;	// set unknown attribute ID
  pAvaStruc->ValType  = -1;	// set unknown string type
  return(pAvaStruc);
}

/**
* Frees an X501 RDN string structure,
* which is a collection of X501_AVA structures, and the contained AVA
* structures (FreeX501RdnStr_Struc).
*
*  @param pRdnStruc Pointer to structure
*/
static  void  FreeX501RdnStr_Struc(HMEM_CTX_DEF
					      X501_RDN_STR * pRdnStruc)
{
  int AvaCount, Index;

  X501_AVA_STR *  pActAvaStruc;
  X501_AVA_STR ** pAvaArr;
  //-------------------------------------------------------------
  // Check for base NULL pointer first, then for zero entry count
  //-------------------------------------------------------------
  if(pRdnStruc == NULL)				// no descriptor
    return;
  pAvaArr  = pRdnStruc->pAvaArr;	// Entries pointer array
  AvaCount = pRdnStruc->AvaCnt;	// number of RDN elements
  if((pAvaArr == NULL) || (AvaCount <= 0))	// no entries...
  {
    FREE_ARRAY(HMEM_CTX_REF,pAvaArr);
    FREE_ARRAY(HMEM_CTX_REF,pRdnStruc);
    return;
  }
  //-------------------------------------------------------------
  // Entries are present, free them
  //-------------------------------------------------------------
  Index = 0;
  do
  {
    pActAvaStruc = pAvaArr[Index++];		// get AVA structure entry
    FreeX501AvaStr_Struc(HMEM_CTX_REF1 pActAvaStruc);
  }while(Index < AvaCount);
  FREE_ARRAY(HMEM_CTX_REF,pAvaArr);
  FREE_ARRAY(HMEM_CTX_REF,pRdnStruc);
}

/**
* Allocates structure to hold the
* X501 AVA elements for RDN's strings with a specified number of AVA elements (AllocX501RdnStr_Struc).
*
*  @param AvaCount Number of AVA Elements needed
*  @return Pointer to the allocated structure, NULL on failure
*/
static  X501_RDN_STR *  AllocX501RdnStr_Struc(HMEM_CTX_DEF
							   int AvaCount)
{
  int Index;
  X501_RDN_STR * pRdnStruc;
  X501_AVA_STR ** pAvaArr;
  //-------------------------------------------
  // 1. Allocate the structure itself, clear it
  //-------------------------------------------
  pRdnStruc = (X501_RDN_STR *) BIT8_ARRAY_CALLOC(HMEM_CTX_REF,
					1, sizeof(X501_RDN_STR));
  if(pRdnStruc == NULL)
    return(NULL);
  //-----------------------------------------------------
  // 2. Allocate the Array of X501_AVA structure pointers
  //-----------------------------------------------------
  if(AvaCount <= 0)
    return(pRdnStruc);

  pAvaArr = (X501_AVA_STR **) BIT8_ARRAY_CALLOC(HMEM_CTX_REF,
				      1,AvaCount * sizeof(X501_AVA_STR *));
  if(pAvaArr == NULL)
  {
    FREE_ARRAY(HMEM_CTX_REF,pRdnStruc);
    return(NULL);
  }

  pRdnStruc->AvaCnt  = AvaCount;
  pRdnStruc->pAvaArr = pAvaArr;
  //-----------------------------------------------------------------
  // 3. Allocate the AVA structure elements
  //-----------------------------------------------------------------
  Index = 0;
  do  
  {
    if((pAvaArr[Index] = AllocX501AvaStr_Struc(HMEM_CTX_REF)) == NULL)
    {
      FreeX501RdnStr_Struc(HMEM_CTX_REF1 pRdnStruc);
      return(NULL);
    }
    Index++;
  }while(Index < AvaCount);
  return(pRdnStruc);
}

/**
* Frees an X501 DN string structure and all the
* elements / subelements (FreeX501DnStr_Struc).
*
*  @param pDnStrStruc Pointer to structure
*/
extern "C"  void  FreeX501DnStr_Struc(HMEM_CTX_DEF
					    X501_DN_STR * pDnStrStruc)
{
  int RdnCount, Index;

  X501_RDN_STR *  pActRdnStruc;
  X501_RDN_STR ** pRdnArr;
  //-------------------------------------------------------------
  // Check for base NULL pointer first, then for zero entry count
  //-------------------------------------------------------------
  if(pDnStrStruc == NULL)				// no descriptor
    return;

  pRdnArr  = pDnStrStruc->pRdnArr;	// Entries pointer array
  RdnCount = pDnStrStruc->RdnCnt;	// number of RDN elements
  if((pRdnArr == NULL) || (RdnCount <= 0))	// no entries...
  {
    FREE_ARRAY(HMEM_CTX_REF,pRdnArr);
    FREE_ARRAY(HMEM_CTX_REF,pDnStrStruc);
    return;
  }
  //-------------------------------------------------------------
  // Entries are present, free them
  //-------------------------------------------------------------
  Index = 0;
  do
  {
    pActRdnStruc = pRdnArr[Index++];		// get AVA structure entry
    FreeX501RdnStr_Struc(HMEM_CTX_REF1 pActRdnStruc);
  }while(Index < RdnCount);
  FREE_ARRAY(HMEM_CTX_REF,pRdnArr);
  FREE_ARRAY(HMEM_CTX_REF,pDnStrStruc);
}

/**
* Allocates structure to hold the
* internal string representations of a X501 DN (distinguished name),
* capable of holding a requested number of entries (AllocX501DnStr_Struc).
*
* NOTE: The RDN entries are NOT yet allocated, only the pointer array
*
*  @param RdnCount Number of RDN Elements needed
*  @return Pointer to the allocated structure, NULL on failure
*/
static  X501_DN_STR *  AllocX501DnStr_Struc(HMEM_CTX_DEF
						         int RdnCount)
{
  X501_DN_STR * pDnStruc;
  X501_RDN_STR ** pRdnArr;
  //-------------------------------------------
  // 1. Allocate the structure itself, clear it
  //-------------------------------------------
  pDnStruc = (X501_DN_STR *) BIT8_ARRAY_CALLOC(HMEM_CTX_REF,
					1, sizeof(X501_DN_STR));
  if(pDnStruc == NULL)
    return(NULL);
  //-----------------------------------------------------
  // 2. Allocate the Array of X501_RDN structure pointers
  //-----------------------------------------------------
  if(RdnCount <= 0)
    return(pDnStruc);

  pRdnArr = (X501_RDN_STR ** ) BIT8_ARRAY_CALLOC(HMEM_CTX_REF,
			      1,RdnCount * sizeof(X501_RDN_STR *));
  if(pRdnArr == NULL)
  {
    FREE_ARRAY(HMEM_CTX_REF,pDnStruc);
    return(NULL);
  }

  pDnStruc->RdnCnt  = RdnCount;
  pDnStruc->pRdnArr = pRdnArr;
  return(pDnStruc);
}

/**
* Converts a X.501 destinguished name (DN) into aa array of internal
* format strings, containing the name elements (ConvX501DnToIntStruc). 
* This array and its elements
* are newly allocated.
*
* This is required to display unknown object IDs and multi object-ID
* RDNs and for VPN access checking.
*
*  @param pDnNameStruc X501 Name structure
*  @param ppDnStringStruc Array with name elements
*  @return 0 on success, error code otherwise
*/
extern "C"  int  ConvX501DnToIntStruc(HMEM_CTX_DEF
	X501_DN* pDnNameStruc, X501_DN_STR ** ppDnStringStruc)
{
  int Retcode;
  int RdnCount,RdnIndex,ElementIndex;
  int ElementCount;
  int AvaIndex,AvaCount;
  int OidIndex;

  IDATA* pActAttIdata;
  IDATA* pActValIdata;

  IDATPARR** pRdnStrucArr;
  IDATA** pActRdnDescArr;

  IDATPARR* pActRDNStruc;

  int pTmpIndex[1];

  X501_AVA_STR *  pActAvaStrStruc;
  X501_AVA_STR ** pAvaStrStrucArr;

  X501_RDN_STR *  pActRdnStrStruc;
  X501_RDN_STR ** pRdnStrStrucArr;

  X501_DN_STR * pDnStringStruc;

  char* pTmpBuf[1];
  //---------------------------------------------------
  // Check parameters
  //---------------------------------------------------
  if((pDnNameStruc == NULL) || (ppDnStringStruc == NULL))
    return(ASN1_NULL_PTR);
  ppDnStringStruc[0] = NULL;

  if((RdnCount = pDnNameStruc->Cnt) <= 0)
    return(ASN1_PARAM_ERR);
  //--------------------------------------------------------------
  // Allocate a X501 String descriptor structure, without elements
  //--------------------------------------------------------------
  if((pDnStringStruc = AllocX501DnStr_Struc(HMEM_CTX_REF1
					    RdnCount)) == NULL)
    return(ASN1_ALLOC_ERR);
  //--------------------------------------------------------------
  // Now Convert the Elements, RDNs and AVAs in the RDNs
  //--------------------------------------------------------------
  pRdnStrucArr    = pDnNameStruc->ppArr;
  pRdnStrStrucArr = pDnStringStruc->pRdnArr;
  //-------------------------------------------------------
  // Process all RDN Elements, skip empty ones
  //-------------------------------------------------------
  RdnIndex = 0;
  while(RdnIndex < RdnCount)
  {
    pActRDNStruc = pRdnStrucArr[RdnIndex];
    if((pActRDNStruc == NULL) ||			// no elements,
       ((ElementCount = pActRDNStruc->Cnt) <= 0))	// dto.
    {
      RdnIndex++;
      continue;
    }
    if((ElementCount & 0x01) != 0)		// must be EVEN !
    {
      FreeX501DnStr_Struc(HMEM_CTX_REF1 pDnStringStruc);
      return(ASN1_PARAM_ERR);
    }
    AvaCount = ElementCount / 2;		// number of AVAs for this RDN
    //-----------------------------------------------------
    // Allocate the RDN String Structure with AVA entries
    //-----------------------------------------------------
    if((pActRdnStrStruc = AllocX501RdnStr_Struc(HMEM_CTX_REF1
						AvaCount)) == NULL)
    {
      FreeX501DnStr_Struc(HMEM_CTX_REF1 pDnStringStruc);
      return(ASN1_ALLOC_ERR);
    }
    pRdnStrStrucArr[RdnIndex] = pActRdnStrStruc; // save the RDN structure
    //-------------------------------------------------------
    // Process the entries for a RDN as attribute/value pairs
    //-------------------------------------------------------
    pActRdnDescArr  = pActRDNStruc->ppArr;
    pAvaStrStrucArr = pActRdnStrStruc->pAvaArr;

    AvaIndex = 0;
    while(AvaIndex < AvaCount)
    {

      pActAvaStrStruc = pAvaStrStrucArr[AvaIndex];	// structure to load

      //-----------------------------------------------------
      // Get attribute (OID) / value pair
      //-----------------------------------------------------
      ElementIndex = AvaIndex * 2;			// 2 Elements per AVA
      pActAttIdata = pActRdnDescArr[ElementIndex];
      pActValIdata = pActRdnDescArr[ElementIndex+1];

      AvaIndex++;
      //-----------------------------------------------------
      // Process attibute's object ID, check if known
      //-----------------------------------------------------
      Retcode = GetRDN_WellKnownIndex(pActAttIdata,pTmpIndex);
      if(Retcode != ASN1_OP_OK)
      {
        FreeX501DnStr_Struc(HMEM_CTX_REF1 pDnStringStruc);
        return(Retcode);
      }
      OidIndex = pTmpIndex[0];
      if(OidIndex >= 0)				// OID *IS* known...
      {
        //--------------------------------------------------------
        // Known OID, save the internal Index as ID
        //--------------------------------------------------------
        pActAvaStrStruc->OidIndex = OidIndex; // set Index
//      X501_AVA_STR_pOidStr(pActAvaStrStruc)  = NULL;	   // no data...
      }
      else
      {
        //--------------------------------------------------------
        // Unknown OID, save as decimal dotted internal string
        //--------------------------------------------------------
        Retcode = OIDToIntStr(HMEM_CTX_REF1
			      pActAttIdata->Base,
                              (int) pActAttIdata->Off,
                              pActAttIdata->Len,
		              pTmpBuf, NULL);
        if(Retcode != ASN1_OP_OK)
        {
          FreeX501DnStr_Struc(HMEM_CTX_REF1 pDnStringStruc);
          return(Retcode);
        }
//      X501_AVA_STR_OidIndex(pActAvaStrStruc) = -1;	// set Index unknown
        pActAvaStrStruc->pOidStr  = pTmpBuf[0];   // set data ptr
      }     
      //-------------------------------------------------------------
      // Process the Value information.
      // 1. Try to decode value as ASN.1 String Type
      //-------------------------------------------------------------
      Retcode = FromASN1_String(HMEM_CTX_REF1 pActValIdata->Base,(int) pActValIdata->Off,pActValIdata->Len,pTmpBuf);
      if(Retcode == ASN1_OP_OK)
      {
        pActAvaStrStruc->ValType = 0;	    // set type=string
        pActAvaStrStruc->pValStr = pTmpBuf[0]; // set data ptr
        continue;				// to next AVA pair
      }
      if(Retcode != ASN1_FROM_STRING_INV_TYPE_ERR)	// severe error !
      {
        FreeX501DnStr_Struc(HMEM_CTX_REF1 pDnStringStruc);
        return(Retcode);
      }
      //-------------------------------------------------------
      // Value not decodeable as string type, try others
      //-------------------------------------------------------
      Retcode = FromASN1_IntBitOctToHexString(HMEM_CTX_REF1
				pActValIdata->Base,
				(int) pActValIdata->Off,
				pActValIdata->Len, pTmpBuf);
      if(Retcode == ASN1_OP_OK)
      {
        pActAvaStrStruc->ValType = 1;	    // set type=others
        pActAvaStrStruc->pValStr = pTmpBuf[0]; // set data ptr
        continue;				// to next AVA pair
      }
      if(Retcode != ASN1_FROM_INTBOC_INV_TYPE_ERR)	// severe error !
      {
        FreeX501DnStr_Struc(HMEM_CTX_REF1 pDnStringStruc);
        return(Retcode);
      }
      //-------------------------------------------------------
      // Value is something else, generate pure hex data...
      //-------------------------------------------------------
      Retcode = FromBytes_ToHexString(HMEM_CTX_REF1
				pActValIdata->Base,
				(int) pActValIdata->Off,
				pActValIdata->Len, pTmpBuf);
      if(Retcode != ASN1_OP_OK)			// severe error !
      {
        FreeX501DnStr_Struc(HMEM_CTX_REF1 pDnStringStruc);
        return(Retcode);
      }
//    X501_AVA_STR_ValType(pActAvaStrStruc) = -1;	    // set type=unknown
      pActAvaStrStruc->pValStr = pTmpBuf[0]; // set data ptr
    } // AVA Element loop for RDN
    RdnIndex++;
  } // RDN Element loop

  ppDnStringStruc[0] = pDnStringStruc;
  return(ASN1_OP_OK);
}

/**
* Converts strings in internal
* format to ASN.1 String types PRINTABLE STRING, BMP_STRING or
* UTF8 STRING, depending on request and contents of string (ToASN1_RDNString).
* The destination will be newly allocated.
*
* NOTE: Number of string elements is limited to 10000
*
*  @param SrcBuf Base of string
*  @param SrcOff Start of data
*  @param UTF8_Flag == 0 do not use UTF8 <br>
*               != 0 always use UTF8
*  @param pDstIdata Pointer where to store allocated, filled IDATA structure
*  @return ASN1_OP_OK on success, error code otherwise
*/
extern "C"  int  ToASN1_RDNString(HMEM_CTX_DEF
	char* SrcBuf, int SrcOff, int UTF8_Flag,IDATA** pDstIdata)
{
  int SrcCnt;
  int SrcIndex = SrcOff;

  int DstIndex=0;

  int i,j;
  int TmpIndex;
  int IA5Flag;

  int Tmp;
  int length;

  char* pBuf = NULL;

  IDATA* pIdata = NULL;
  //-----------------------------------------
  // Check pointers
  //-----------------------------------------
  if((SrcBuf == NULL) || (pDstIdata == NULL))
    return(ASN1_TO_RDN_STRING_NULLPTR_ERR);
  pDstIdata[0] = NULL;
  BIGchar2word(SrcBuf,SrcCnt,SrcIndex);
  if((SrcCnt <= 0) || (SrcCnt > 10000))
    return(ASN1_TO_RDN_STRING_INVLEN_ERR);
  //-----------------------------------------
  // Allocate IDATA Element and Buffer
  //-----------------------------------------
  pIdata = (IDATA*) BIT8_ARRAY_ALLOC(HMEM_CTX_REF,sizeof(IDATA));
  if(pIdata == NULL)
    return(ASN1_TO_RDN_STRING_ALLOC_ERR);

  i = SrcCnt*2 + 4;			// incl. ASN1.type and length
//  if(UTF8_Flag != 0) i += SrcCnt;	// is UTF8, more buffer needed
  i += SrcCnt;				// for UTF8, more buffer needed

  pBuf = BIT8_ARRAY_ALLOC(HMEM_CTX_REF,i);	// get buffer
  if(pBuf == NULL)
  {
    FREE_ARRAY(HMEM_CTX_REF,pIdata);
    return(ASN1_TO_RDN_STRING_ALLOC_ERR);
  }
  pIdata->Base = pBuf;
  pIdata->Off = 0;

  //----------------------------------------------------
  // Convert String according to requested mode
  //----------------------------------------------------
  i = SrcCnt;
  TmpIndex = SrcIndex;
  if(UTF8_Flag == 0)				// Standard character
  {
    //------------------------------------------------------
    // Standard Conversion, depends on contents if printable
    //------------------------------------------------------
    IA5Flag = 0;				// Assume PrintableString
    do
    {
      if(SrcBuf[TmpIndex++] != 0) break;	// MSB != 0 -> must use BMP
      j = (int) SrcBuf[TmpIndex++] & 0xFF;	// get LSB
      if(j >= 0x80) break;			// LATIN1 -> must use BMP
      if(ASN1PrtStrFlagTab[j] == 0)
        IA5Flag = 1;				// not Printable, IA5String
//	break;					// not Printable -> use BMP

      i--;
    }while(i != 0);
    if(i == 0)					// Printable/IA5 String
    {
      if(IA5Flag == 0)				// Printable String
        pBuf[DstIndex++] = ASN1_UNIVERSAL_PRINTABLESTR;	// Set Type
      else
        pBuf[DstIndex++] = ASN1_UNIVERSAL_IA5STR;	// Set Type

      i = GenASN1_LenField(pBuf,DstIndex,(int) SrcCnt & 0xFFFF);
      DstIndex += i;				// increment pointer
      SrcIndex++;				// to Low Byte indices
      do
      {
        pBuf[DstIndex++] = SrcBuf[SrcIndex];
	SrcIndex+=2;
	SrcCnt--;
      }while(SrcCnt != 0);
    }
    else

    {						// BMP-String
      SrcCnt <<= 1;
      pBuf[DstIndex++] = ASN1_UNIVERSAL_BMPSTR;
      i = GenASN1_LenField(pBuf,DstIndex,(int) SrcCnt & 0x1FFFF);
      DstIndex += i;				// increment pointer
      memcpy(pBuf+DstIndex,SrcBuf+SrcIndex,SrcCnt);
      DstIndex += SrcCnt;
    }

  }
//  else
  if(UTF8_Flag != 0)				// UTF8 characters
  {
    //----------------------------------------------------
    // UTF8 Conversion requested
    //----------------------------------------------------
    i = SrcCnt;
    TmpIndex = SrcIndex;
    length = 0;
    do
    {    
      BIGchar2word(SrcBuf,Tmp,TmpIndex);	// Get Character
      length++;				// assume 1 byte
      if(Tmp >= 0x80) length++;		// at least 2 bytes
      if(Tmp >= 0x800) length++;		// 3 bytes
      i--;
    }while(i != 0);

//    System.out.println("UTF8Len="+length);	// TEST TEST TEST

    pBuf[DstIndex++] = ASN1_UNIVERSAL_UTF8STR; // UTF-8
    i = GenASN1_LenField(pBuf,DstIndex,(int) length & 0xFFFF);
    DstIndex += i;				// increment pointer

    do
    {
      BIGchar2word(SrcBuf,Tmp,SrcIndex);	// Get Character
      if(Tmp < 0x80) pBuf[DstIndex++] = (char) Tmp;
      else
      {
        if(Tmp < 0x800)			//2 or 3 bytes
        {					// 2 Byte format
          pBuf[DstIndex++] =			// first 5 Bits
	    (unsigned char) (0xC0 | ((Tmp >> 6) & 0x1F));
        }
        else					// 3 Byte Format
        {
          pBuf[DstIndex++] =			// first 4 Bits
	    (unsigned char) (0xE0 | ((Tmp >> 12) & 0x0F));
	  pBuf[DstIndex++] =			// following 6 Bits
	    (unsigned char) (0x80 | ((Tmp >> 6) & 0x3F));
         }
         pBuf[DstIndex++] =			// remaining 6 Bits
	    (unsigned char) (0x80 |  (Tmp & 0x3F));
      }
      SrcCnt--;
    }while(SrcCnt != 0);
 //   System.out.println("UTF8StrLen="+DstIndex);	// TEST TEST TEST

  }
  pIdata->Len = DstIndex;
  pDstIdata[0] = pIdata;
  return(ASN1_OP_OK);
}
/**
* Converts string in internal format to ASN.1 String type VISIBLE STRING (ToASN1_VisibleString).
* The destination will be newly allocated.
*
* NOTE: 
* <ol>
* <li> Number of string elements is limited to 32763.
* <li> Only 1 Byte entries may be present.
* </ol>
*
*  @param SrcBuf Base of string
*  @param SrcOff Start of data
*  @param pDstIdata Pointer where to store allocated, filled IDATA structure
*  @return ASN1_OP_OK on success, error code otherwise
*/
extern "C"  int  ToASN1_VisibleString(HMEM_CTX_DEF
	char* SrcBuf, int SrcOff, IDATA** pDstIdata)
{
  int SrcCnt;
  int SrcIndex = SrcOff;

  int DstIndex=0;

  int i;

  char* pBuf = NULL;

  IDATA* pIdata = NULL;
  //-----------------------------------------
  // Check pointers
  //-----------------------------------------
  if((SrcBuf == NULL) || (pDstIdata == NULL))
    return(ASN1_TO_VIS_STRING_NULLPTR_ERR);
  pDstIdata[0] = NULL;
  BIGchar2word(SrcBuf,SrcCnt,SrcIndex);
  if((SrcCnt <= 0) || (SrcCnt > (0x7FFF - 4)))
    return(ASN1_TO_VIS_STRING_INVLEN_ERR);
  //-----------------------------------------
  // Allocate IDATA Element and Buffer
  //-----------------------------------------
  pIdata = (IDATA*) BIT8_ARRAY_ALLOC(HMEM_CTX_REF,sizeof(IDATA));
  if(pIdata == NULL)
    return(ASN1_TO_VIS_STRING_ALLOC_ERR);

  pBuf = BIT8_ARRAY_ALLOC(HMEM_CTX_REF,SrcCnt*2+4);	// get buffer
  if(pBuf == NULL)
  {
    FREE_ARRAY(HMEM_CTX_REF,pIdata);
    return(ASN1_TO_VIS_STRING_ALLOC_ERR);
  }
  pIdata->Base = pBuf;
  pIdata->Off = 0;

  //----------------------------------------------------
  // Convert String 
  //----------------------------------------------------
  pBuf[DstIndex++] = ASN1_UNIVERSAL_VISIBLESTR;		// Set Type
  i = GenASN1_LenField(pBuf,DstIndex,(int) SrcCnt & 0xFFFF);
  DstIndex += i;				// increment pointer
  do
  {
    if(SrcBuf[SrcIndex++] != 0) break;		// invalid entry
    pBuf[DstIndex++] = SrcBuf[SrcIndex++];	// copy byte
    SrcCnt--;
  }while(SrcCnt != 0);
  if(SrcCnt != 0)		// Error occured
  {
    pDstIdata[0] = NULL;
    FREE_ARRAY(HMEM_CTX_REF,pBuf);
    FREE_ARRAY(HMEM_CTX_REF,pIdata);
    return(ASN1_TO_VIS_STRING_DATA_ERR);
  }
  pIdata->Len = DstIndex;
  pDstIdata[0] = pIdata;
  return(ASN1_OP_OK);
}

/**
* Generates a <code>X501_DN</code> structure from a given <code>IDATPARR</code>
* structure. The order of  the strings is fixed internally (FromStringArrayToASN1_DN). 
* Allocates the 
* <code>X501_DN</code> container structure and the elements needed, converts 
* the internal strings to ASN.1 encoding and stores the encoded data with the 
* appropriate object ID to the name  elements.
* Only those entries are generated that have non null string pointers.
*
*  @param SrcArrayDesc Pointer to <code>IDATA</code> container structure
*  @param UTF8_Flag == 0 use best match <br>
*               != 0 alwaqys use UTF8
*  @param ppDnNameDesc Pointer where to store allocated destination name structure
*  @return ASN1_OP_OK on success, error code otherwise
*/
extern "C"  int  FromStringArrayToASN1_DN(HMEM_CTX_DEF
	IDATPARR* SrcArrayDesc, int UTF8_Flag, X501_DN** ppDnNameDesc)
{
  int i;
  int Retcode;
  int RdnCount;
  int RdnIndex;

  int ArrayIndex = 0;

  IDATA** pSrcArray;

  IDATA* pTmpIdata[1];

  IDATA** pActIdataArr;

  IDATPARR* pActRdnDesc;
  IDATPARR** pRdnDescArr;

  X501_DN* pDnNameDesc;
 
  //----------------------------------------------------------------
  // check parameters, count non Null Entries
  //----------------------------------------------------------------
  if((SrcArrayDesc == NULL) || (ppDnNameDesc == NULL))
    return(ASN1_STR_ARR_TO_RDN_NULL_PTR);

  pSrcArray = SrcArrayDesc->ppArr;
  if((pSrcArray == NULL) ||
     (SrcArrayDesc->Cnt != RDN_ARRAY_MAX_DATA_INDEX))
    return(ASN1_STR_ARR_TO_RDN_INV_DATA);

  RdnCount = 0;
  i = RDN_ARRAY_MAX_DATA_INDEX;
  do
  {
    i--;
    if(pSrcArray[i]->Base != NULL)
      RdnCount++;
  }while(i != 0);
  if(RdnCount == 0)
    return(ASN1_STR_ARR_TO_RDN_NODATA_ERR);
  //-----------------------------------------------------------------
  // Allocate required X501 DN structure, Elements marked as freeable
  //-----------------------------------------------------------------
  pDnNameDesc = AllocX501DN_Struc(HMEM_CTX_REF1 RdnCount,2,1,1);
  if(pDnNameDesc == NULL)
    return(ASN1_ALLOC_ERR);

  pRdnDescArr = pDnNameDesc->ppArr;
  //----------------------------------------------------------------
  // Process the non Null Entries
  //----------------------------------------------------------------
  i = RDN_ARRAY_MAX_DATA_INDEX;
  Retcode = 0;
  ArrayIndex = 0;
  RdnIndex   = 0;
  do
  {
    if(pSrcArray[ArrayIndex]->Base != NULL)	// Entry present
    {
      pActRdnDesc  = pRdnDescArr[RdnIndex];
      pActIdataArr = pActRdnDesc->ppArr;

      Retcode = GenOIDIdataEntry(HMEM_CTX_REF1 RDN_OidIndexArray[ArrayIndex] & 0xFF,0,pActIdataArr);
      if(Retcode != ASN1_OP_OK)
        break;

      Retcode = ToASN1_RDNString(HMEM_CTX_REF1
			pSrcArray[ArrayIndex]->Base,0,
			UTF8_Flag,pTmpIdata);
      if(Retcode != ASN1_OP_OK)
        break;
      CopyIdataContents(pActIdataArr[1],pTmpIdata[0]);
      FREE_ARRAY(HMEM_CTX_REF,pTmpIdata[0]);
      RdnIndex++;
    }
    ArrayIndex++;
    i--;
  }while(i != 0);
  if(i == 0)
  {
    ppDnNameDesc[0] = pDnNameDesc;
    return(ASN1_OP_OK);
  }
  FreeX501DN_Struc(HMEM_CTX_REF1 pDnNameDesc);
  ppDnNameDesc[0] = NULL;
  return(Retcode);
}

extern "C"  int  AllocCopyDatArrayDesc(HMEM_CTX_DEF
	IDATPARR* SrcDatArrayDesc, IDATPARR* DstDatArrayDesc)
{
  int Retcode;

  int SrcElementCnt;
  int DstElementCnt;
  int DstFreeFlag;

  IDATA** pSrcDatArray;
  IDATA** pDstDatArray;

  IDATA** ppTmpDatArray[1];
  //---------------------------------------------------------
  // Check Parameters
  //---------------------------------------------------------
  if((SrcDatArrayDesc == NULL) || (DstDatArrayDesc == NULL))
    return(ASN1_DATARRDESC_COPY_NULPT_ERR);
  pSrcDatArray  = SrcDatArrayDesc->ppArr;	// get Array pointer
  SrcElementCnt = SrcDatArrayDesc->Cnt;	// get Source count

  pDstDatArray  = DstDatArrayDesc->ppArr;	// get Array pointer
  DstElementCnt = DstDatArrayDesc->Cnt;	// get Source count
  DstFreeFlag   = (DstDatArrayDesc->Flags
                   & FREE_BIT_MASK); // get flag
  //------------------------------------------------------------------------
  // Check if Element Count matches (case of Zero Dst.Elements also handled)
  //------------------------------------------------------------------------
  if(SrcElementCnt != DstElementCnt)			// not same
  {
    //------------------------------------------------------
    // Element Count different, free Array (and Elements)
    //------------------------------------------------------
    FreeIDATA_Array(HMEM_CTX_REF1 pDstDatArray,DstElementCnt,DstFreeFlag);			 // free Array
    DstDatArrayDesc->ppArr = NULL;		// set invalid
    DstDatArrayDesc->Cnt = 0;			// no Elements
    DstDatArrayDesc->Flags &= (~FREE_BIT_MASK);// clear Flags
    //------------------------------------------------------
    // Allocate new Array if required, mark descriptor as freeable
    //------------------------------------------------------
    if(SrcElementCnt == 0) return(ASN1_OP_OK);		// nothing to do...
    Retcode = AllocIDATA_Array(HMEM_CTX_REF1 ppTmpDatArray,SrcElementCnt);
    if(Retcode != ASN1_OP_OK) return(Retcode);		// Alloc Error
    DstDatArrayDesc->ppArr = ppTmpDatArray[0];	// set valid
    DstDatArrayDesc->Cnt = SrcElementCnt;	// no Elements
    DstDatArrayDesc->Flags |= FREE_BIT_MASK;	// set Flag
    pDstDatArray = ppTmpDatArray[0];			// set Array
  }
  //------------------------------------------------------------------------
  // Counts are same (or have been made same) check for Zero Source count
  //------------------------------------------------------------------------
  if(SrcElementCnt == 0) return(ASN1_OP_OK);
  //------------------------------------------------------------------------
  // Elements must be copied (and allocated)
  //------------------------------------------------------------------------
//  Retcode = AllocCopyDatArrayElements(pSrcDatArray,0,pDstDatArray,0,
//	      SrcElementCnt,1);
  Retcode = AllocCopyDatArrayElements(HMEM_CTX_REF1 pSrcDatArray,0,pDstDatArray,0,SrcElementCnt,1);
  return(Retcode);
}

/**
* Allocates an array descriptor
* structure, the array of <code>IDATA</code> atructure alements of given count
* but does NOT allocate the <code>IDATA</code> entries (AllocRawIDATPARR_Struc).
*
*  @param pDatArrayDesc Array desc base
*  @param ElementCount Number of elements requested
*
*  @return ASN1_OP_OK on success, error code otherwise
*/
extern "C"  int  AllocRawIDATPARR_Struc(HMEM_CTX_DEF
	IDATPARR** pDatArrayDesc, int ElementCount)
{
  int Retcode;

  IDATPARR* TmpDatArrayDesc;
  IDATA** DatArray = NULL;

  pDatArrayDesc[0] = NULL;			// set invalid
  for(;;)					// Error FOR
  {
    Retcode = ASN1_IDATA_ALLOC_ALLOC_ERR;	// assume error
    //-----------------------------------------------
    // 1. Allocate the Descriptor structure, clear it
    //-----------------------------------------------
    TmpDatArrayDesc = (IDATPARR *)
	((void *) BIT8_ARRAY_CALLOC(HMEM_CTX_REF,1,sizeof(IDATPARR)));
    if(TmpDatArrayDesc == NULL)
      break;

    if(ElementCount <= 0)
    {
      pDatArrayDesc[0] = TmpDatArrayDesc;
      return(ASN1_OP_OK);
    }
    //---------------------------------------------------
    // 2. Allocate the Pointer Array itsself, clear
    //---------------------------------------------------
    DatArray = (IDATA**)
	((void *) BIT8_ARRAY_CALLOC(HMEM_CTX_REF,
				    ElementCount,sizeof(IDATA *)));
    if(DatArray == NULL)
      break;

    TmpDatArrayDesc->Cnt   = ElementCount;
    TmpDatArrayDesc->ppArr = DatArray;
    Retcode = ASN1_OP_OK;
    break;
  } // Error FOR
  pDatArrayDesc[0] = TmpDatArrayDesc;
  if(Retcode == ASN1_OP_OK)
    return(Retcode);

  FreeIDATPARR_Struc(HMEM_CTX_REF1 TmpDatArrayDesc);
  pDatArrayDesc[0] = NULL;
  return(Retcode);
}

/**
* Appends given data array to the end of given <code>IDATPARR</code> (AppendDatArrayToDatArrayDesc).
*
* NOTE: The destination descriptor must have allocated (freeable) elements.
*       The source data array must also be allocated (elements will be moved).
* 
*  @param ppDstDesc Destination descriptor
*  @param pSrcArray Array of pointers to <code>IDATA</code> structures
*  @param SrcCnt Number of elements to append
*  @return 0 on success. else error occured
*/
extern "C"  int  AppendDatArrayToDatArrayDesc(HMEM_CTX_DEF
	IDATPARR** ppDstDesc, IDATA** pSrcArray, int SrcCnt)
{
  int Retcode;

  int OldSrcElementCnt;
  int NewDstElementCnt;
  int SrcIndex;
  int DstIndex;

  IDATA** pSrcDatArray;
  IDATA** pDstDatArray;

  IDATPARR* ppTmpDesc[1];
 
  IDATPARR* pNewDesc = NULL;
  IDATPARR* pOldDesc = NULL;
  //---------------------------------------------------------
  // Check Parameters
  //---------------------------------------------------------
  if((ppDstDesc == NULL) || (pSrcArray == NULL))
    return(ASN1_NULL_PTR);

  if(SrcCnt <= 0)				// nothing to do...
    return(ASN1_OP_OK);
  //---------------------------------------------------------
  // Calculate new needed element count
  //---------------------------------------------------------
  OldSrcElementCnt = 0;
  NewDstElementCnt = SrcCnt;
  pOldDesc = ppDstDesc[0];			// get input pointer
  if(pOldDesc != NULL)				// input structure present
  {
    if(((pOldDesc->Flags & FREE_BIT_MASK) == 0) ||
       (pOldDesc->Cnt < 0))
      return(ASN1_PARAM_ERR);

    NewDstElementCnt += pOldDesc->Cnt;
  }
  //---------------------------------------------------------
  // Allocate new descriptor of required size
  //---------------------------------------------------------
  if((Retcode = AllocRawIDATPARR_Struc(HMEM_CTX_REF1
			ppTmpDesc,NewDstElementCnt)) != ASN1_OP_OK)
    return(Retcode);

  pNewDesc = ppTmpDesc[0];
  pNewDesc->Flags |= FREE_BIT_MASK;	// mark as freeable
  //---------------------------------------------------------
  // Copy data from old descriptor if present
  //---------------------------------------------------------
  pDstDatArray = pNewDesc->ppArr;
  DstIndex = 0;

  if(OldSrcElementCnt > 0)
  {
    pSrcDatArray = pOldDesc->ppArr;
    SrcIndex = 0;
    do
    {
      pDstDatArray[DstIndex++] = pSrcDatArray[SrcIndex];
      pSrcDatArray[SrcIndex++] = NULL;		// avoid freeing
    }while(SrcIndex < OldSrcElementCnt);
  }
  //---------------------------------------------------------
  // Copy data from new data array
  //---------------------------------------------------------
  SrcIndex = 0;
  do
  {    
    pDstDatArray[DstIndex++] = pSrcArray[SrcIndex];
    pSrcArray[SrcIndex++] = NULL;			// avoid freeing
  }while(SrcIndex < SrcCnt);
  //---------------------------------------------------------
  // Free old structure if present
  //---------------------------------------------------------
  if(pOldDesc != NULL)
  {
    FreeIDATPARR_Struc(HMEM_CTX_REF1 pOldDesc);
  }
  ppDstDesc[0] = pNewDesc;
  return(ASN1_OP_OK);
}

extern "C"  int  AllocCopyX501DnDesc(HMEM_CTX_DEF
	X501_DN* pSrcNameDesc, X501_DN* pDstNameDesc)
{
  int Retcode;
  int Index;
  int Count;

  int SrcElementCnt;
  int DstElementCnt;

  IDATPARR* pActSrcDesc;
  IDATPARR* pActDstDesc;
  IDATPARR* pTmpDesc[1];

  IDATPARR** pSrcDescArray;
  IDATPARR** pDstDescArray;
  IDATPARR** pNewDstDescArray;
  //---------------------------------------------------------
  // Check Parameters
  //---------------------------------------------------------
  if((pSrcNameDesc == NULL) || (pDstNameDesc == NULL))
    return(ASN1_NULL_PTR);

  //---------------------------------------------------------
  // Get source and destination size
  // Note: We assume that at least the RDN slots array has
  // ----- the size indicated, but elements may be NUL !
  //---------------------------------------------------------
  SrcElementCnt = pSrcNameDesc->Cnt;
  if(SrcElementCnt <= 0)			// no source....
    return(ASN1_OP_OK);

  pSrcDescArray = pSrcNameDesc->ppArr;
  pDstDescArray = pDstNameDesc->ppArr;

  DstElementCnt = pDstNameDesc->Cnt;
  if(DstElementCnt < SrcElementCnt)
  {
    Index = 0;
    pNewDstDescArray = (IDATPARR**) BIT8_ARRAY_CALLOC(HMEM_CTX_REF,
			        1,SrcElementCnt * sizeof(IDATPARR*));
    if(pNewDstDescArray == NULL)
      return(ASN1_ALLOC_ERR);
    pDstNameDesc->ppArr = pNewDstDescArray;
    pDstNameDesc->Cnt   = SrcElementCnt;
    FREE_ARRAY(HMEM_CTX_REF,pDstDescArray);
    pDstDescArray = pNewDstDescArray;
    DstElementCnt = SrcElementCnt;
  }
  //-----------------------------------------------------------------
  // Copy the Elements, one by one
  // NOTE: if there is NO destination IDATPARR array, allocate a new one
  //-----------------------------------------------------------------
  Index = 0;
  while(Index < SrcElementCnt)
  {
    pActSrcDesc = pSrcDescArray[Index];
    if(pActSrcDesc != NULL)
    {
      pActDstDesc = pDstDescArray[Index];
      if(pActDstDesc == NULL)
      {
        Count = pActSrcDesc->Cnt;
        Retcode = AllocIDATPARR_Struc(HMEM_CTX_REF1 pTmpDesc,Count);
        if(Retcode != ASN1_OP_OK)
          return(Retcode);
        pActDstDesc = pTmpDesc[0];
        pActDstDesc->Flags |= FREE_BIT_MASK;
        pDstDescArray[Index] = pActDstDesc;
      }
      if((Retcode = AllocCopyDatArrayDesc(HMEM_CTX_REF1
			pActSrcDesc,pActDstDesc)) != ASN1_OP_OK)
        return(Retcode);
    }
    Index++;
  }
  return(ASN1_OP_OK);
} 

/**
* Generates ASN.1 Bitstring from max. 32 Bits, MSB aligned (ToASN1_32MsbBitsBitstringBuf). 
* The string is
* put into a newly allocated buffer.
*
* NOTE: No parameters checked
*
*  @param Bits Value to set
*  @param ppBuf Allocated buffer
*  @param pDataLen Size of data returned
*  @return 0 on success, error code otherwise
*/
extern int  ToASN1_32MsbBitsBitstringBuf(HMEM_CTX_DEF
	int Bits, char** ppBuf, int* pDataLen)
{
  int BufLen, DstIndex, UnusedBits, ByteCnt, ShiftCnt;
  char* pBuf;

  if((ppBuf == NULL) || (pDataLen == NULL))
    return(ASN1_NULL_PTR);

  ppBuf[0] = NULL;
  pDataLen[0] = 0;
  //-------------------------------------------------------
  // Get Number of Bytes to use
  //-------------------------------------------------------
  ByteCnt = 4;
  while(ByteCnt > 0)
  {
    if((Bits & 0xFF) != 0)			// found a set bit
      break;
    Bits = Bits >> 8;				// BE CAREFUL: MSB may be set!
    ByteCnt--;
  }
  //-------------------------------------------------------
  // Allocate buffer for result
  //-------------------------------------------------------
  BufLen = ByteCnt + 3;				// TAG, LEN, UNUSED BITS
  if((pBuf = BIT8_ARRAY_ALLOC(HMEM_CTX_REF,BufLen)) == NULL)
    return(ASN1_ALLOC_ERR);
  //-------------------------------------------------------
  // Format the buffer ASN.1 Header
  //-------------------------------------------------------
  pBuf[0] = ASN1_UNIVERSAL_BITSTRING;
  pBuf[1] = (unsigned char) (ByteCnt + 1);		// including unused bits
  pBuf[2] = 0;					// assume no unused bits
  ppBuf[0]    = pBuf;
  pDataLen[0] = BufLen;
  if(ByteCnt == 0)
    return(ASN1_OP_OK);
  //-------------------------------------------------------
  // Put data to buffer
  //-------------------------------------------------------
  DstIndex = 3;					// Start of data to set
  ShiftCnt = (ByteCnt-1) * 8;
  while(ByteCnt != 0)
  {
    pBuf[DstIndex++] = (unsigned char) (Bits >> ShiftCnt);
    ShiftCnt = ShiftCnt-8;
    ByteCnt--;
  }
  //-------------------------------------------------------
  // Count the unused bits
  //-------------------------------------------------------
  UnusedBits = 0;
  while(UnusedBits < 8)
  {
    if((Bits & 0x01) != 0)
      break;
    Bits >>= 1;
    UnusedBits++;
  }
  pBuf[2] = (unsigned char) UnusedBits;
  return(ASN1_OP_OK);
}

/**
* Generates an X509 extension in internal notation from given OID-index,
* critical flag and the value field (GenX509Extension).
* The generated extension elements (OID, CriticalFlag, value) will be
* added to the end of the given IDATPARR descriptor.
* NOTE: To encode the extensions the descriptor must be run through
*       X.509 extension substring decoder !
*
*  @param OIDIndex Known extension OID to use
*  @param CriticalFlag == 0 non critical, else critical
*  @param pValueBuf Value to set
*  @param ValueOff Start of data
*  @param ValueLen Size of value data
*  @param ppDesc IN: Old descriptor /NULL <br>
*               OUT: New, expanded Descriptor
*  @return 0 on success, error code otherwise
*/
static  int  GenX509Extension(HMEM_CTX_DEF
	int OIDIndex, int CriticalFlag,
	char* pValueBuf, int ValueOff, int ValueLen,
	IDATPARR** ppDesc)
{
  int Retcode;
  int DstIndex, AllocSize;

  char BoolBuf[1];
  char* pOIDBuf = NULL;

  IDATA* pIdata;
  IDATA** ppArr;
  IDATPARR* pOldDesc = NULL; 
  IDATPARR* pNewDesc = NULL; 

  IDATPARR* pExtDesc = NULL;
  IDATPARR* ppTmpDesc[1];
  //-----------------------------------------------------
  // Check parameters
  //-----------------------------------------------------
  if((pValueBuf == NULL) || (ppDesc == NULL))
    return(ASN1_NULL_PTR);
  if(ValueLen <= 0)
    return(ASN1_PARAM_ERR);
  //-----------------------------------------------------
  // Allocate Temporary structure for the Extension
  //-----------------------------------------------------
  if((Retcode = AllocIDATPARR_Struc(HMEM_CTX_REF1 ppTmpDesc,3)) != ASN1_OP_OK)
    return(Retcode);
  pExtDesc = ppTmpDesc[0];
  ppArr = pExtDesc->ppArr;
  for(;;)		// Error FOR
  {
    //-----------------------------------------------------
    // Generate the OID Entry from given Index
    //-----------------------------------------------------
    if((Retcode = GenOIDIdataEntry(HMEM_CTX_REF1 OIDIndex,0,ppArr)) != ASN1_OP_OK)
      break;
    pOIDBuf = ppArr[0]->Base;
    //-----------------------------------------------------
    // Set the ASN.1 Boolean Critical Flag if required
    //-----------------------------------------------------
    if(CriticalFlag != 0)
    {
      BoolBuf[0] = (unsigned char) 0xFF;			// set DER 'True' value
      pIdata = ppArr[1];
      pIdata->Base = BoolBuf;
      pIdata->Off  = 0;
      pIdata->Len  = 1;
    }
    //-----------------------------------------------------
    // Set the Value Buffer
    //-----------------------------------------------------
    pIdata = ppArr[2];
    pIdata->Base = pValueBuf;
    pIdata->Off  = ValueOff;
    pIdata->Len  = ValueLen;
    //-----------------------------------------------------
    // Allocate New Descriptor of (possibly) Increased Size
    //-----------------------------------------------------
    DstIndex  = 0;
    AllocSize = 3;
    pOldDesc  = ppDesc[0];
    if(pOldDesc != NULL)
    {
      DstIndex   = pOldDesc->Cnt;	// get used Elements size
      AllocSize += DstIndex;			// 3 more elements
    }
    if((Retcode = AllocIDATPARR_Struc(HMEM_CTX_REF1 ppTmpDesc,AllocSize)) != ASN1_OP_OK)
      break;
    pNewDesc = ppTmpDesc[0];
    pNewDesc->Flags |= FREE_BIT_MASK;	// mark as freeable
    //-----------------------------------------------------
    // Copy the new Elements to new Descriptor as TRUE copy
    //-----------------------------------------------------
    if((Retcode = AllocCopyDatArrayToDatArray(HMEM_CTX_REF1 pExtDesc,0,pNewDesc,DstIndex,3,1)) != ASN1_OP_OK)
      break;
    //-----------------------------------------------------
    // if Old Descriptor given, move elements to new one
    //-----------------------------------------------------
    if(pOldDesc != NULL)
    {
      if((Retcode = AllocCopyDatArrayToDatArray(HMEM_CTX_REF1 pOldDesc,0,pNewDesc,0,DstIndex,0)) != ASN1_OP_OK)
        break;
      pOldDesc->Flags &= (~FREE_BIT_MASK); // avoid freeing    
    }
    break;
  }
  //-------------------------------------------------------
  // Free temporary structures/buffers
  //-------------------------------------------------------
  FREE_CARRAY(HMEM_CTX_REF,pOIDBuf);
  FreeIDATPARR_Struc(HMEM_CTX_REF1 pExtDesc);
  if(Retcode != ASN1_OP_OK)
  {
    FreeIDATPARR_Struc(HMEM_CTX_REF1 pNewDesc);
    return(Retcode);
  }
  ppDesc[0] = pNewDesc;
  FreeIDATPARR_Struc(HMEM_CTX_REF1 pOldDesc);
  return(ASN1_OP_OK);
}
/**
* Generates X.509 BasicConstraints extension from certificate
* structure CA-Flag and PathLen (GenX509BasicConstraints).
*
*  @param pCertStruc Certificate structure
*  @param ppDesc IN: Descriptor to use <br>
*               OUT: New descriptor
*  @return 0 on success, error code otherwise
*/
static  int  GenX509BasicConstraints(HMEM_CTX_DEF
		X509CERT * pCertStruc, IDATPARR** ppDesc)
{
  int Retcode;

  char BoolBuf[1];
  char* pLenBuf = NULL;
  char* pConstraintsBuf = NULL;

  char* ppTmpBuf[1];
  int pTmpLen[1];

  IDATA* pIdata;
  IDATA** ppArr;

  IDATPARR* pValueDesc = NULL;
  IDATPARR* ppTmpDesc[1];

  //--------------------------------------------------
  // Check parameters
  //--------------------------------------------------
  if((pCertStruc == NULL) || (ppDesc == NULL))
    return(ASN1_NULL_PTR);
  //--------------------------------------------------
  // Check if Constraints shall be generated at all
  //--------------------------------------------------
  if(pCertStruc->BasicConstrCAMode == X509_BASICCONSTR_CA_FLAG_UNDEF)
    return(ASN1_OP_OK);

  //--------------------------------------------------
  // Allocate temporary Descriptor
  //--------------------------------------------------
  if((Retcode = AllocIDATPARR_Struc(HMEM_CTX_REF1 ppTmpDesc,2)) != ASN1_OP_OK)
    return(Retcode);
  pValueDesc = ppTmpDesc[0];
  ppArr = pValueDesc->ppArr;

  for(;;)
  {
    //--------------------------------------------------
    // Generate the CA-Flag Boolean Value if Flag is set,
    // and the Path constraint if CA-Flag is True
    //--------------------------------------------------
    if((pCertStruc->BasicConstrCAMode !=
          X509_BASICCONSTR_CA_FLAG_UNDEF) &&
       ((pCertStruc->BasicConstrCAMode & X509_BASICCONSTR_CA_FLAG) != 0))
    {
      BoolBuf[0] = (unsigned char) 0xFF;		// set DER Boolean value TRUE
      pIdata = ppArr[0];
      pIdata->Base = BoolBuf;
//    IDATA_Off(pIdata)  = 0;
      pIdata->Len  = 1;
      if(pCertStruc->BasicConstrPathLen != X509_BASICCONSTR_PATHLEN_UNDEF)
      {
        if((Retcode = UnsignedBIT32NumToByteBuf(HMEM_CTX_REF1 pCertStruc->BasicConstrPathLen,ppTmpBuf,pTmpLen)) != ASN1_OP_OK)
          break;    
        pLenBuf = ppTmpBuf[0];
        pIdata = ppArr[1];
        pIdata->Base = pLenBuf;
//      IDATA_Off(pIdata)  = 0;
	pIdata->Len  = pTmpLen[0];
      }
    }
    else					// may not act as a CA
    {
      BoolBuf[0] = (unsigned char) 0x00;			// set DER Boolean value FALSE
      pIdata = ppArr[0];
      pIdata->Base = BoolBuf;
//    IDATA_Off(pIdata)  = 0;
      pIdata->Len  = 1;
    }
    //-----------------------------------------------------------
    // Get the ASN.1 encoded Basic Constraints value
    //-----------------------------------------------------------
    if((Retcode = ToASN1(HMEM_CTX_REF1 ppArr,0,(char *) BasicConstraintsExtCtl,BASIC_CONSTRAINTS_CTL_CNT,ppTmpBuf,pTmpLen)) != ASN1_OP_OK)
      break;
    pConstraintsBuf = ppTmpBuf[0];
    //-----------------------------------------------------------
    // Generate the X.509 Critical extension Entry
    //-----------------------------------------------------------
    Retcode = GenX509Extension(HMEM_CTX_REF1
			       OID_X509_EXT_BASIC_CONSTR, 1,
			       pConstraintsBuf, 0, pTmpLen[0], ppDesc);
    break;
  }
  //----------------------------------------------------
  // Free temporary buffers/structures
  //----------------------------------------------------
  FREE_CARRAY(HMEM_CTX_REF,pLenBuf);
  FREE_CARRAY(HMEM_CTX_REF,pConstraintsBuf);
  FreeIDATPARR_Struc(HMEM_CTX_REF1 pValueDesc);
  return(Retcode);
}
/**
* Generates X.509 KeyUsage extension from certificate structure
* KeyUsage bits (GenX509KeyUsage).
*
*  @param pCertStruc Certificate structure
*  @param ppDesc IN: Descriptor to use
*               OUT: New descriptor
*  @return 0 on success, error code otherwise
*/
static  int  GenX509KeyUsage(HMEM_CTX_DEF
		X509CERT * pCertStruc, IDATPARR** ppDesc)
{
  int Retcode;

  char* pUsageBuf = NULL;

  char* ppTmpBuf[1];
  int pTmpLen[1];
  //--------------------------------------------------
  // Check parameters
  //--------------------------------------------------
  if((pCertStruc == NULL) || (ppDesc == NULL))
    return(ASN1_NULL_PTR);

  for(;;)
  {
    //--------------------------------------------------
    // Generate the Key Usage Bitstring
    //--------------------------------------------------
    if((Retcode = ToASN1_32MsbBitsBitstringBuf(HMEM_CTX_REF1
		pCertStruc->KeyUsageFlags & (~X509_KEYUSAGE_VALID_BIT),
		ppTmpBuf, pTmpLen)) != ASN1_OP_OK)
      break;
    pUsageBuf = ppTmpBuf[0];
    //-----------------------------------------------------------
    // Generate the X.509 Critical extension Entry
    //-----------------------------------------------------------
    Retcode = GenX509Extension(HMEM_CTX_REF1
			       OID_X509_EXT_KEY_USAGE, 1,
			       pUsageBuf, 0, pTmpLen[0], ppDesc);
    break;
  }
  //----------------------------------------------------
  // Free temporary buffers/structures
  //----------------------------------------------------
  FREE_CARRAY(HMEM_CTX_REF,pUsageBuf);
  return(Retcode);
}

/**
* Finds OID table index for PKIX key purpose type specified by
* contents of the OID's last byte (GetPkixKeyPurposeOidIndex).
*
*  @param KeyPurposeType Content of last OID byte
*  @param pOidIndex Index if found, else -1
*  @return 0  on success, error code otherwise
*/
static  int  GetPkixKeyPurposeOidIndex(int KeyPurposeType,
				int* pOidIndex)
{
  int OidIndex;
  int OID_Offset;
  int OID_Len;
  int OID_Type;

  if(pOidIndex == NULL)
    return(ASN1_NULL_PTR);

  //-----------------------------------------------------
  // Check possible range ahead
  //-----------------------------------------------------
  pOidIndex[0] = -1;				// preset not found
  if((KeyPurposeType < PKIX_KEYPURP_MIN_ID) ||
     (KeyPurposeType > PKIX_KEYPURP_MAX_ID))
    return(ASN1_OP_OK);
  //--------------------------------------------------------
  // find the corresponding OID table offset for key purpose
  //--------------------------------------------------------
  OidIndex = 0;
  do
  {
    OID_Offset = PKIX_KEY_PURPOSE_OffsetTab[OidIndex];
    OID_Len  = (int) OID_Table[OID_Offset+2] & 0xFF;  // get Length
    OID_Type = (int) OID_Table[OID_Offset+2+OID_Len] & 0xFF;
    if(OID_Type == KeyPurposeType)
    {
      pOidIndex[0] = PKIX_KEY_PURPOSE_IndexTab[OidIndex];
      return(ASN1_OP_OK);
    }
    OidIndex++;
  }while(OidIndex < GRP_PKIX_KEY_PURPOSE_CNT);
  return(ASN1_OP_OK);
}
/**
* Generates PKIX key purpose OID list from certificate flags (GeneratePkixKeyPurposeOidList).
*
*  @param pCert Certificate structure
*  @param ppDesc IN: Descriptor to use <br>
*               OUT: New descriptor
*  @return 0 on success, error code otherwise
*/
static  int  GeneratePkixKeyPurposeOidList(HMEM_CTX_DEF
			X509CERT * pCert, IDATPARR** ppDesc)
{
  int Retcode;
  int DstIndex;
  int KeyPurposeType;
  int KeyPurposeBits;

  int pTmpOidIndex[1];

  IDATA** pDstDatArray = NULL;
  IDATA** pTmpDatArray[1];

  //-----------------------------------------------------------
  // Check parameters
  //-----------------------------------------------------------
  if((pCert == NULL) || (ppDesc == NULL))
    return(ASN1_NULL_PTR);

  //-----------------------------------------------------------
  // Check if PKIX key purpose extensions should be generated
  //-----------------------------------------------------------
  if((pCert->ExtKeyUsageFlags & X509_EXT_KEYUSAGE_PKIX_PRES_BIT) == 0)
    return(ASN1_OP_OK);

  KeyPurposeBits = pCert->PkixKeyPurposeFlags &
                     PKIX_KEYPURP_VALID_BITS_MASK;
  if(KeyPurposeBits == 0)
    return(ASN1_OP_OK);
  //-----------------------------------------------------------
  // Allocate OID array with maximum needed size
  //-----------------------------------------------------------
  Retcode = AllocIDATA_Array(HMEM_CTX_REF1 pTmpDatArray,GRP_PKIX_KEY_PURPOSE_CNT);
  if(Retcode != ASN1_OP_OK)
    return(Retcode);
  pDstDatArray = pTmpDatArray[0];
  //-----------------------------------------------------------
  // Generate the OID list according to set bits
  //-----------------------------------------------------------
  DstIndex = 0;
  KeyPurposeType = PKIX_KEYPURP_MIN_ID;		// MUST start with 1!
  do
  {
    if((KeyPurposeBits & 0x01) != 0)		// bit is set
    {
      if((Retcode = GetPkixKeyPurposeOidIndex(KeyPurposeType,
					      pTmpOidIndex)) != ASN1_OP_OK)
        break;
      if(pTmpOidIndex[0] != -1)			// found OID
      {
        if((Retcode = GenOIDIdataEntry(HMEM_CTX_REF1 pTmpOidIndex[0],DstIndex,pDstDatArray)) != ASN1_OP_OK)
          break;
        DstIndex++;
      }
    }
    KeyPurposeBits = KeyPurposeBits >> 1;	// to next higher bit
    KeyPurposeType++;
  }while(KeyPurposeType <= PKIX_KEYPURP_MAX_ID);
  //-----------------------------------------------------------
  // check if error occured
  //-----------------------------------------------------------
  if(Retcode != ASN1_OP_OK)
  {
    FreeIDATA_Array(HMEM_CTX_REF1 pDstDatArray,GRP_PKIX_KEY_PURPOSE_CNT,1);
    return(Retcode);
  }
  //----------------------------------------------------------
  // Append the used elements to the descriptor structure
  //----------------------------------------------------------
  Retcode = AppendDatArrayToDatArrayDesc(HMEM_CTX_REF1 ppDesc,
			pDstDatArray, DstIndex);

  FreeIDATA_Array(HMEM_CTX_REF1 pDstDatArray,GRP_PKIX_KEY_PURPOSE_CNT,1);
  return(Retcode);
}

/**
* Generates X.509 ExtendedKeyUsage extension from certificate structure
* ExtendedKeyUsage bits (GenX509ExtKeyUsage).
*
* NOTE: At the moment ONLY PKIX extensions are generated if any.
*
*  @param pCert Certificate structure
*  @param ppDesc IN: Descriptor to use <br>
*               OUT: New descriptor
*  @return 0 on success, error code otherwise
*/
static  int  GenX509ExtKeyUsage(HMEM_CTX_DEF
		X509CERT * pCert, IDATPARR** ppDesc)
{
  int Retcode;
  int CriticalFlag;

  char* pTmpBuf = NULL;

  char* ppTmpBuf[1];
  int pTmpLen[1];

  IDATPARR* pTmpArrayDesc[1];
  //--------------------------------------------------
  // Check parameters
  //--------------------------------------------------
  if((pCert == NULL) || (ppDesc == NULL))
    return(ASN1_NULL_PTR);
  //-------------------------------------------------------
  // Check if extended Key Usage should be generated at all
  //-------------------------------------------------------
  if((pCert->ExtKeyUsageFlags & X509_EXT_KEYUSAGE_PKIX_PRES_BIT) == 0)
    return(ASN1_OP_OK);

  pTmpArrayDesc[0] = NULL;
  //---------------------------------------------------
  // Generate PKIX OID list (if any)
  //---------------------------------------------------
  Retcode = GeneratePkixKeyPurposeOidList(HMEM_CTX_REF1
					   pCert, pTmpArrayDesc);
  if(Retcode != ASN1_OP_OK)
    return(Retcode);

  if(pTmpArrayDesc[0] == NULL)			// no data generated...
    return(ASN1_OP_OK);

  //---------------------------------------------------
  // Generate other OID lists (future...)
  //---------------------------------------------------

  //---------------------------------------------------
  // Convert OID Array to flat OID list
  //---------------------------------------------------
  Retcode = ToASN1_SubStr(HMEM_CTX_REF1 pTmpArrayDesc[0]->ppArr,0,pTmpArrayDesc[0]->Cnt,(char*)ObjIDSplitCtl,OBJID_SPLIT_CTL_CNT,OID_SPLIT_MAX_DATA_INDEX,ppTmpBuf,pTmpLen);

  FreeIDATPARR_Struc(HMEM_CTX_REF1 pTmpArrayDesc[0]);
  if(Retcode != ASN1_OP_OK)
    return(Retcode);

  pTmpArrayDesc[0] = NULL;
  pTmpBuf = ppTmpBuf[0];
  //---------------------------------------------------------------
  // Generate the ASN.1 encoded extended key usage value (OID list)
  //---------------------------------------------------------------
  Retcode = FromBufToDesc(HMEM_CTX_REF1 ppTmpBuf[0],0,pTmpLen[0],0,0,pTmpArrayDesc);
  if(Retcode != ASN1_OP_OK)
  {
    FREE_ARRAY(HMEM_CTX_REF,pTmpBuf);
    return(Retcode);
  }

  Retcode = ToASN1(HMEM_CTX_REF1 pTmpArrayDesc[0]->ppArr,0,(char *) ExtKeyUsageExtCtl,EXT_KEY_USAGE_CTL_CNT,ppTmpBuf,pTmpLen);

  FREE_ARRAY(HMEM_CTX_REF,pTmpBuf);
  FreeIDATPARR_Struc(HMEM_CTX_REF1 pTmpArrayDesc[0]);
  if(Retcode != ASN1_OP_OK)
    return(Retcode);

  pTmpBuf = ppTmpBuf[0];
  //-----------------------------------------------------------
  // Generate the X.509 extension Entry, either critical or not
  //-----------------------------------------------------------
  CriticalFlag = 0;
  if((pCert->ExtKeyUsageFlags & X509_EXT_KEYUSAGE_CRITICAL_BIT) != 0)
    CriticalFlag = 1;

  Retcode = GenX509Extension(HMEM_CTX_REF1
			     OID_X509_EXT_EXT_KEY_USAGE,
			     CriticalFlag,
			     pTmpBuf,0,pTmpLen[0], ppDesc);
  //----------------------------------------------------
  // Free temporary buffers/structures
  //----------------------------------------------------
  FREE_CARRAY(HMEM_CTX_REF,pTmpBuf);
  return(Retcode);
}

/**
* Generates own certificate extensions from given certificate
* structure (GenCertX509Extensions).
*
*  @param pCertStruc Certificate structure
*  @return 0 on success, error code otherwise
*/
static  int  GenCertX509Extensions(HMEM_CTX_DEF
					      X509CERT * pCertStruc)
{
  int Retcode;
  IDATPARR* ppTmpDesc[1];
  //--------------------------------------------------
  // Check parameters
  //--------------------------------------------------
  if(pCertStruc == NULL)
    return(ASN1_NULL_PTR);
  //---------------------------------------------------------
  // Free eventually present extension structure, clear Flags
  //---------------------------------------------------------
  ppTmpDesc[0] = NULL;
  FreeIDATPARR_Struc(HMEM_CTX_REF1 pCertStruc->Extensions);
  pCertStruc->Extensions = NULL;
  pCertStruc->ExtPresFlags = 0;

  for(;;)
  {
    //-----------------------------------------------------------------
    // Generate X.509 KeyUsage extension
    //-----------------------------------------------------------------
    if((Retcode = GenX509KeyUsage(HMEM_CTX_REF1
				  pCertStruc, ppTmpDesc)) != ASN1_OP_OK)
      break;
    //---------------------------------------------------------------------
    // Generate X.509 BasicConstraints extension if CA-Flag is true (?) or always ?
    //---------------------------------------------------------------------
    if((Retcode = GenX509BasicConstraints(HMEM_CTX_REF1
					  pCertStruc,ppTmpDesc)) != ASN1_OP_OK)
      break;
    //---------------------------------------------------------------------
    // Generate X.509 ExtendedKeyUsage extension if needed
    //---------------------------------------------------------------------
    if((Retcode = GenX509ExtKeyUsage(HMEM_CTX_REF1
					  pCertStruc,ppTmpDesc)) != ASN1_OP_OK)
      break;

    break;
  }
  if(Retcode != ASN1_OP_OK)
  {
    FreeIDATPARR_Struc(HMEM_CTX_REF1 ppTmpDesc[0]);
    return(Retcode);
  }
  pCertStruc->Extensions = ppTmpDesc[0];
  return(ASN1_OP_OK);
}

/**
* Generates OBJID, ASN.1 encoded
* AlgorParams and public values from given internal representation of 
* params/value array and selected Algorithm Type (SubEncodePubKeyInfo).
* The Output Arrays are allocated, and the local free bit is set.
*
* NOTE:
*<ol>
* <li> The source structure must be freed separately !
* <li> The Output data are a true copy, so that a local free
*	    can be done without affecting the source data !!!
*</ol>
*  @param SrcDatArray Source data array
*  @param ElementCnt Number of elements loaded
*  @param PubAlgorType Type of algorithm
*  @param pDstArrayDesc Pointer to place new destination buffer
*
*  @return ASN1_OP_OK on success, error code otherwise
*/
static  int  SubEncodePubKeyInfo(HMEM_CTX_DEF
		IDATA** SrcDatArray, int ElementCnt, int PubAlgorType,
		IDATPARR** pDstArrayDesc)
{
  int i;
  int Retcode = ASN1_OP_OK;
  int AlgorOIDIndex;
  int TotalCnt;

  int ParamCtlCnt;
  int ParamErrCode;

  int ValueIndex=0;
  int ValueCtlCnt;
  int ValueErrCode;

  char * pParamCtl;
  char * pValueCtl;

  char* pPubParMem = NULL;
  char* pPubValMem = NULL;

  char* pTmpBuf[1];

  int pTmpData[1];

  IDATPARR* pTmpArrayDesc[1];
  IDATPARR* DatArrayDesc = NULL;

  IDATA** DatArray = NULL;

  //----------------------------------------------------
  // check for NULL-Pointers
  //----------------------------------------------------
  if((SrcDatArray == NULL) || (pDstArrayDesc == NULL))
    return(ASN1_ENC_PUB_KEY_NULL_PTR_ERR);
  pDstArrayDesc[0] = NULL;
  //--------------------------------------------------------
  // check if the Algor is known, get Param/Value data count
  //--------------------------------------------------------
  switch(PubAlgorType)
  {
    case RSA_PUBLIC_ALGOR:
      AlgorOIDIndex = OID_PKCS1_RSA_ENCRYPTION;

      ParamCtlCnt   = RSA_PUB_ALG_CTL_CNT;
      pParamCtl     = (char*)RSA_AlgorParamsCtl;
      ParamErrCode  = ASN1_ENC_PUB_KEY_RSA_PAR_ERR;

      ValueIndex    = RSA_ALG_PAR_MAX_INDEX;
      ValueCtlCnt   = RSA_PUB_VAL_CTL_CNT;
      pValueCtl     = (char*)RSA_PublicValueCtl;
      ValueErrCode  = ASN1_ENC_PUB_KEY_RSA_VAL_ERR;

      TotalCnt      = RSA_ALG_PAR_MAX_INDEX + RSA_PUB_VAL_MAX_INDEX+1;

      break;

   case DH_PUBLIC_ALGOR:
      AlgorOIDIndex = OID_X942_DH_PUBL_NUMBER;

      ParamCtlCnt   = DH_PUB_ALG_CTL_CNT;
      pParamCtl     = (char*)DH_AlgorParamsCtl;
      ParamErrCode  = ASN1_ENC_PUB_KEY_DH_PAR_ERR;

      ValueIndex    = DH_ALG_PAR_MAX_INDEX;
      ValueCtlCnt   = DH_PUB_VAL_CTL_CNT;
      pValueCtl     = (char*)DH_PublicValueCtl;
      ValueErrCode  = ASN1_ENC_PUB_KEY_DH_VAL_ERR;

      TotalCnt      = DH_ALG_PAR_MAX_INDEX + DH_PUB_VAL_MAX_INDEX+1;
      break;

    case DSA_PUBLIC_ALGOR:
      AlgorOIDIndex = OID_X957_DSA_SIGNAT_ALGOR;

      ParamCtlCnt   = DSA_PUB_ALG_CTL_CNT;
      pParamCtl     = (char*)DSA_AlgorParamsCtl;
      ParamErrCode  = ASN1_ENC_PUB_KEY_DSA_PAR_ERR;

      ValueIndex    = DSA_ALG_PAR_MAX_INDEX;
      ValueCtlCnt   = DSA_PUB_VAL_CTL_CNT;
      pValueCtl     = (char*)DSA_PublicValueCtl;
      ValueErrCode  = ASN1_ENC_PUB_KEY_DSA_VAL_ERR;

      TotalCnt      = DSA_ALG_PAR_MAX_INDEX + DSA_PUB_VAL_MAX_INDEX+1;
      break;

    default:
      return(ASN1_ENC_PUB_KEY_UNKNOWN_ALGOR);
  }
  //--------------------------------------------------------
  // Check if necessarey Data Count presented...
  //--------------------------------------------------------
  if(ElementCnt != (TotalCnt - 1))
    return(ASN1_ENC_PUB_KEY_INV_DATA);
  for(;;)						// Error FOR
  {
    //--------------------------------------------------------
    // Allocate Data Array for Encoded OID, Params and Values
    //--------------------------------------------------------
    i = AllocIDATPARR_Struc(HMEM_CTX_REF1 pTmpArrayDesc,3);
    if(i != ASN1_OP_OK)
    {
      Retcode = ASN1_ENC_PUB_KEY_ARR_ALLOC_ERR;
      break;
    }
    DatArrayDesc = pTmpArrayDesc[0];
    DatArray = DatArrayDesc->ppArr;
    DatArrayDesc->Flags |= FREE_BIT_MASK;
    //--------------------------------------------------------
    // Generate the OID Entry (1st entry)
    //--------------------------------------------------------
    i = GenOIDIdataEntry(HMEM_CTX_REF1 AlgorOIDIndex,0,DatArray);
    if(i != ASN1_OP_OK)
    {
      Retcode = ASN1_ENC_PUB_KEY_OID_GEN_ERR;
      break;
    }
    //---------------------------------------------------------------
    // Generate the Algor Param Buffer, put to descriptor (2nd Entry)
    //---------------------------------------------------------------
    i = ToASN1(HMEM_CTX_REF1 SrcDatArray,0,pParamCtl,ParamCtlCnt,pTmpBuf,pTmpData);
    if(i != ASN1_OP_OK)
    {
      Retcode = ParamErrCode;
      break;
    }
    pPubParMem = pTmpBuf[0];			// save for free
    i = FromBufToDesc(HMEM_CTX_REF1 pTmpBuf[0],0,pTmpData[0],1,0,pTmpArrayDesc);
    if(i != ASN1_OP_OK)
    {
      Retcode = ParamErrCode;
      break;
    }
    pPubParMem = NULL;
    //-----------------------------------------------------------------
    // Generate the Public Values Buffer, put to Descriptor (3rd Entry)
    //-----------------------------------------------------------------
    i = ToASN1(HMEM_CTX_REF1 SrcDatArray,ValueIndex,pValueCtl,ValueCtlCnt,pTmpBuf,pTmpData);
    if(i != ASN1_OP_OK)
    {
      Retcode = ValueErrCode;
      break;
    }
    pPubValMem = pTmpBuf[0];			// save for free
    i = FromBufToDesc(HMEM_CTX_REF1 pTmpBuf[0],0,pTmpData[0],2,0,pTmpArrayDesc);
    if(i != ASN1_OP_OK)
    {
      Retcode = ParamErrCode;
      break;
    }
    pPubValMem = NULL;
    break;
  } // Error FOR
  if(Retcode != ASN1_OP_OK)
  {
    FREE_ARRAY(HMEM_CTX_REF,pPubParMem);
    FREE_ARRAY(HMEM_CTX_REF,pPubValMem);
    FreeIDATPARR_Struc(HMEM_CTX_REF1 DatArrayDesc);
    return(Retcode);
  }
  pDstArrayDesc[0] = DatArrayDesc;
  return(Retcode);
}

/**
* Generates either a General or 
* UTC time string from a given TimeArray (GenerateTimeString).
*
* NOTE:
*<ol>
* <li> Input Array Base must be valid, is N O T checked !
* <li> No milliseconds or time differentials are generated.
* <li> Always an Utc value is generated (Trailing 'Z').
*</ol>
*  @param TimeArray Source buffer
*  @param DstBuf Destination buffer
*  @param DstOffset Destination offset
*  @param BufLen Available destination length
*  @param DstLen location for stored data count
*  @param Mode Conversion mode: <br>
*               <> 0 : generate General Time
*               (YYYYMMDDHHMMSS"Z") <br>
*               == 0 : generate UTC Time,
*               1950-2049
*               (YYMMDDHHMMSS"Z")
*
*  @return ASN1_OP_OK Boolean retrieved
* <br>            ASN1_INVALID_UTC_TIME TimeArray Value Error
* <br>            ASN1_INTERNAL_ERROR processing error
*/
static  int  GenerateTimeString(int* TimeArray,
				          char* DstBuf,
				          int  DstOffset,
				          int  BufLen,
				          int* DstLen,
				          int  Mode)
{
  int i,j;
  int Temp;
  int timeIndex = 0;
  int DstIndex = DstOffset;
  int DataLen = UTC_TIME_DEFAULT_LEN;

  if(Mode != 0) DataLen = GENERAL_TIME_DEFAULT_LEN;
  if(BufLen < DataLen)
    return(ASN1_GEN_TIMESTR_BUF_TOO_SMALL);	// should not happen
  //--------------------------------------------------------
  // Convert the Time Array Entry to UTC-Time String
  //--------------------------------------------------------
  //--------------------------------------------------------
  // 1. Special processing of year (General/UTC-Time)
  //--------------------------------------------------------
  Temp = TimeArray[timeIndex++];
  j=4;					// Counter (YYYY)
  if(Mode == 0)				// UTC Time
  {
    if((Temp < 1950) || (Temp > 2049))	// check for correct range
      return(ASN1_GEN_TIMESTR_INV_UTC_TIME);
    j=2;				// reduced Counter
    if(Temp < 2000) Temp -= 1900;	// 1950-1999
    else Temp -= 2000;			// 2000-2049
  }
  i = j-1;
  do
  {
    DstBuf[DstIndex+i] =(char) ((Temp % 10) + 0x30); // save digit
    Temp = Temp / 10;
    i--;
  }while(i >= 0);
  DstIndex += j;			// skip stored data
  //--------------------------------------------------------
  // 2. process rest of data (without milliseconds !)
  //--------------------------------------------------------
  j = TIME_SECONDS_INDEX-TIME_YEAR_INDEX; // get number of elements
  do
  {
    Temp = TimeArray[timeIndex++];	// get value
    DstBuf[DstIndex++] =(char) ((Temp / 10) + 0x30); // save high digit
    DstBuf[DstIndex++] =(char) ((Temp % 10) + 0x30); // save low digit
    j--;
  } while(j != 0);
  //--------------------------------------------------------
  // 3. append "ZULU" character, set size
  //--------------------------------------------------------
  DstBuf[DstIndex] = (char) ZULU_CHAR;
  DstLen[0] = DataLen;
  return(ASN1_OP_OK);
}

extern "C"  int  ToASN1_TimeString(HMEM_CTX_DEF
	int* TimeArray, int TimeType, IDATPARR** pDstArrDesc)
{
  char TimeHdr = ASN1_UNIVERSAL_UTC_TIMESTR;

  int Retcode;
  int TimeLen;

  int TmpLen[1];
  IDATPARR* pTmpDatArrayDesc[1];

  char TimeBuf[GENERAL_TIME_DEFAULT_LEN+10];
  //------------------------------------------------------
  // Check parameters
  //------------------------------------------------------
  if((TimeArray == NULL) || (pDstArrDesc == NULL))
    return(TO_ASN1_TIME_STRING_NULLPTR_ERR);

  if((TimeType != ASN1_TIME_TYPE_UTC) &&
     (TimeType != ASN1_TIME_TYPE_GENTIME))
    return(TO_ASN1_TIME_STRING_TIMETYP_ERR);
  TimeType--;					// set relative zero (== UTC)
  //------------------------------------------------------
  // Preset Header with ASN.1 Type
  //------------------------------------------------------
  if(TimeType != 0) TimeHdr = ASN1_UNIVERSAL_GEN_TIMESTR;
  TimeBuf[0] = TimeHdr;
  //------------------------------------------------------
  // Generate the Time String
  //------------------------------------------------------
  Retcode = GenerateTimeString(TimeArray, TimeBuf, 2,
			GENERAL_TIME_DEFAULT_LEN+8,TmpLen,TimeType);
  if(Retcode != ASN1_OP_OK) return(Retcode);
  TimeBuf[1] = (char) TmpLen[0];		// set ASN1 Length
  TimeLen = TmpLen[0]+2;
  //------------------------------------------------------
  // Allocate Descriptor Element
  //------------------------------------------------------
  Retcode = AllocIDATPARR_Struc(HMEM_CTX_REF1 pTmpDatArrayDesc,1);
  if(Retcode != ASN1_OP_OK) return(Retcode);
  pTmpDatArrayDesc[0]->Flags |= FREE_BIT_MASK;
  //------------------------------------------------------
  // Load String into Descriptor array element idata
  //------------------------------------------------------
  Retcode = FromBufToDatArray(HMEM_CTX_REF1 pTmpDatArrayDesc[0]->ppArr,0,TimeBuf,0,TimeLen,1);
  if(Retcode == ASN1_OP_OK)
    pDstArrDesc[0] = pTmpDatArrayDesc[0];
  else
    FreeIDATPARR_Struc(HMEM_CTX_REF1 pTmpDatArrayDesc[0]);
  return(Retcode);
}
/**
* Generates data structures in internal
* notation ('Data Elements') from given ASN.1 encoded 
* PKCS10 certificate request input byte stream (FromASN1_CertReq). 
* The certificate
* request is split into:
* <ol>
* <li> Certificate request Info
* <li> Signature algorithm
* <ol>
* <li> Signature algor ID
* <li> Signature algor params (not further parsed)
* </ol>
* <li> Signature bitstring
* </ol>
* 
* This is used for certificate request verification and processing.
*
* Note: Required databuffer structure will be allocated and filled.
*
*  @param InpBuf Buffer with ASN.1 encoding of a PKCS10 certificate request data
*  @param InpOffset Start offset of data
*  @param InpLen Length of data
*  @param pDatArrayDesc Pointer where to store <code>IDATA</code> container 
*                       structure with split elements
*  @param SubErrCode Pointer where to store ASN.1 decoding error
*
*  @return ASN1_OP_OK on success, error code otherwise
*/
extern "C"  int  FromASN1_CertReq(HMEM_CTX_DEF
			char* InpBuf, int InpOffset,
			int InpLen, IDATPARR** pDatArrayDesc,
                        int* SubErrCode)
{
  int i;

  IDATPARR* pTmpDatArrayDesc[1];
  IDATPARR* DatArrayDesc;
  IDATA** DatArray;

  pDatArrayDesc[0] = NULL;			// invalidate
  //---------------------------------------------------------------
  // allocate the required IDATA ptr array and the elements
  //---------------------------------------------------------------
  i = AllocIDATPARR_Struc(HMEM_CTX_REF1 pTmpDatArrayDesc,CERT_REQ_MAX_DATA_INDEX);
  if(i != ASN1_OP_OK) return(ASN1_CERT_REQ_TO_INT_ALLOC_ERR);
  DatArrayDesc = pTmpDatArrayDesc[0];
  DatArray = DatArrayDesc->ppArr;
  //---------------------------------------------------------------
  // Split the Certificate Request...
  //---------------------------------------------------------------
  i = FromASN1(HMEM_CTX_REF1 InpBuf,InpOffset,InpLen,(char *) CertReqCtl,CERT_REQ_CTL_CNT,DatArray,0);
  if(i != ASN1_OP_OK)
  {
    FreeIDATPARR_Struc(HMEM_CTX_REF1 DatArrayDesc);
    SubErrCode[0] = i;
    return(ASN1_CERT_REQ_TO_INT_ERR);    
  }
  pDatArrayDesc[0] = DatArrayDesc;		// set valid
  return(ASN1_OP_OK);
}
/**
* Generates data structures in
* internal notation ('Data Elements') from given ASN.1 encoded 
* PKCS10 certificate request Info input byte stream (FromASN1_TBSCertReqInfo).
*  The certificate
* request Info is split into:
* <ol>
* <li> Version nNumber
* <li> Subject RDN (not further parsed)
* <li> Subject public key info:
* <ol>
* <li> Public key algorithm ID
* <li> Public key algorithm parameters (not further parsed)
* <li> Public values (not further parsed)
* </ol>
* <li> Attributes (Optional, not further parsed)
* </ol>
* 
* This is used for certificate request verification and processing.
*
* Note: Required data buffer structure will be allocated and filled.
*
*  @param InpBuf Buffer with ASN.1 encoding of a PKCS10 certificate request data
*  @param InpOffset Start offset of data
*  @param InpLen Length of data
*  @param pDatArrayDesc Pointer where to store <code>IDATA</code> container 
*                       structure with split elements
*  @param SubErrCode Pointer where to store ASN.1 decoding error
*
*  @return ASN1_OP_OK on success, error code otherwise
*/
extern "C"  int  FromASN1_TBSCertReqInfo(HMEM_CTX_DEF
			char* InpBuf, int InpOffset,
			int InpLen, IDATPARR** pDatArrayDesc,
                        int* SubErrCode)
{
  int i;

  IDATPARR* pTmpDatArrayDesc[1];
  IDATPARR* DatArrayDesc;
  IDATA** DatArray;

  pDatArrayDesc[0] = NULL;			// invalidate
  //---------------------------------------------------------------
  // allocate the required IDATA ptr array and the elements
  //---------------------------------------------------------------
  i = AllocIDATPARR_Struc(HMEM_CTX_REF1 pTmpDatArrayDesc,TBS_CERT_REQ_MAX_DATA_INDEX);
  if(i != ASN1_OP_OK) return(ASN1_TBSCRT_RQ_TO_INT_ALLOC_ERR);
  DatArrayDesc = pTmpDatArrayDesc[0];
  DatArray = DatArrayDesc->ppArr;
  //---------------------------------------------------------------
  // Split the Certificate Request...
  //---------------------------------------------------------------
  i = FromASN1(HMEM_CTX_REF1 InpBuf,InpOffset,InpLen,(char *) TBSCertReqCtl,TBS_CERT_REQ_CTL_CNT,DatArray,0);
  if(i != ASN1_OP_OK)
  {
    FreeIDATPARR_Struc(HMEM_CTX_REF1 DatArrayDesc);
    SubErrCode[0] = i;
    return(ASN1_TBSCERT_REQ_TO_INT_ERR);    
  }
  pDatArrayDesc[0] = DatArrayDesc;		// set valid
  return(ASN1_OP_OK);
}
/**
* Converts data structures in internal
* notation ('Data Elements') to desired ASN.1 encoded PKCS10
* certificate request byte stream (ToASN1_CertReq). 
* The certificate request
* is built from:
* <ol>
* <li> ASN.1 encoded TBS certificate request info
* <li> Signature algorithm
* <ol>
* <li> Signature algor ID
* <li> Signature algor params (not further parsed)
* </ol>
* <li> Signature bitstring
* </ol>
* 
* This is used for certificate request generation.
*
* Note: Required databuffer will be allocated and filled.
*
*  @param DatArray Array of pointers to <code>IDATA</code> structures
*  @param DatArrayIndex Start <code>IDATA</code> pointer index for conversion
*  @param DatArraySize Number of elements in array
*  @param pDstBuf Pointer where to store destination buffer
*  @param DstLen Length of generated Data
*  @param SubErrCode Error code from ASN.1 encoding subroutine
*
*  @return ASN1_OP_OK on success, error code otherwise
*/
extern "C"  int  ToASN1_CertReq(HMEM_CTX_DEF
				IDATA** DatArray,
				int DatArrayIndex, int DatArraySize,
				char** pDstBuf, int* DstLen,
				int* SubErrCode)
{
  int i;

  pDstBuf[0] = NULL;			// invalidate
  DstLen[0] = 0;			// dto.
  //---------------------------------------------------------------
  // check given IDATA ptr array element count if valid
  //---------------------------------------------------------------
  if(DatArraySize != CERT_REQ_MAX_DATA_INDEX)
    return(ASN1_INT_TO_CERT_REQ_PARAM_ERR);
  //---------------------------------------------------------------
  // Build the Certificate Request...
  //---------------------------------------------------------------
  i = ToASN1(HMEM_CTX_REF1 DatArray,DatArrayIndex,(char *) CertReqCtl,CERT_REQ_CTL_CNT,pDstBuf,DstLen);
  if(i == ASN1_OP_OK) return(i);
  SubErrCode[0] = i;
  return(ASN1_INT_TO_CERT_REQ_ERR);    
}
/**
* Converts data structures in internal
* notation ('Data Elements') to desired ASN.1 encoded PKCS10
* certificate request info byte stream (ToASN1_TBSCertReqInfo). 
* The certificate request Info
* is built from:
* <ol>
* <li> Version number
* <li> Subject RDN (not further parsed)
* <li> Subject public key info:
* <ol>
* <li> Public key algorithm ID
* <li> Public key algorithm parameters (not further parsed)
* <li> Public values (not further parsed)
* </ol>
* <li> Attributes (Optional, not further parsed)
* </ol>
* 
* This is used for certificate request generation.
*
* Note: Required databuffer will be allocated and filled.
*
*  @param DatArray Array of pointers to <code>IDATA</code> structures
*  @param DatArrayIndex Start <code>IDATA</code> pointer index for conversion
*  @param DatArraySize Number of elements in array
*  @param pDstBuf Pointer where to store destination buffer
*  @param DstLen Length of generated Data
*  @param SubErrCode Error code from ASN.1 encoding subroutine
*
*  @return ASN1_OP_OK on success, error code otherwise
*/
extern "C"  int  ToASN1_TBSCertReqInfo(HMEM_CTX_DEF
				IDATA** DatArray,
				int DatArrayIndex, int DatArraySize,
				char** pDstBuf, int* DstLen,
				int* SubErrCode)
{
  int i;

  pDstBuf[0] = NULL;			// invalidate
  DstLen[0] = 0;			// dto.
  //---------------------------------------------------------------
  // check given IDATA ptr array element count if valid
  //---------------------------------------------------------------
  if(DatArraySize != TBS_CERT_REQ_MAX_DATA_INDEX)
    return(ASN1_INT_TO_TBSCRT_RQ_PARAM_ERR);
  //---------------------------------------------------------------
  // Build the Certificate Request...
  //---------------------------------------------------------------
  i = ToASN1(HMEM_CTX_REF1 DatArray,DatArrayIndex,(char *) TBSCertReqCtl,TBS_CERT_REQ_CTL_CNT,pDstBuf,DstLen);
  if(i == ASN1_OP_OK) return(i);
  SubErrCode[0] = i;
  return(ASN1_INT_TO_TBSCERT_REQ_ERR);    
}
/**
* Generates the version number ASN.1 encoding for a to be signed certificate 
* structure from given version number and stores the encoding to an <code>IDATA</code> 
* element in the given <code>IDATA</code> pointer array at specified index (SetTBSCertVersion).
*  Allocates as
* necessary.
*
* NOTE: no checks done on input params
*
*  @param DatArray Pointer to array with <code>IDATA</code> structure pointers
*  @param IndexOffset Array index to destination <code>IDATA</code> structure
*  @param Version 0 - Version 1 <br>
*               1 - Version 2 <br>
*               2 - Version 3
*
*  @return ASN1_OP_OK on success, error code otherwise
*/
extern "C"  int  SetTBSCertVersion(HMEM_CTX_DEF
	IDATA** DatArray, int IndexOffset, int Version)
{
  char TmpVersion[1];

  if(Version == 0) return(ASN1_OP_OK);		// Default Version, ignore
  TmpVersion[0] = (char) Version;		// other, save
  return(FromBufToDatArray(HMEM_CTX_REF1 DatArray,X509_VERSION_INDEX+IndexOffset,TmpVersion,0,1,1));
}
/**
* Allocates buffer for serial number,
* if required and sets appropriate array descriptor element at the requested
* index (SetTBSCertSerial).
*
* NOTE: no checks done on input params
*
*  @param DatArray Pointer to array with <code>IDATA</code> structure pointers
*  @param IndexOffset Array index to destination <code>IDATA</code> structure
*  @param SerialBuf Buffer containing serial number data
*  @param SerialOff Start of data
*  @param SerialLen Length of data
*
*  @return ASN1_OP_OK on success, error code otherwise
*/
extern "C"  int  SetTBSCertSerial(HMEM_CTX_DEF
				IDATA** DatArray,
				int IndexOffset, char* SerialBuf,
				int SerialOff, int SerialLen)
{
  return(FromBufToDatArray(HMEM_CTX_REF1 DatArray,X509_SERIAL_INDEX+IndexOffset,SerialBuf,SerialOff,SerialLen,1));
}  
/**
* Allocates buffer for algorithm
* OID and parameters and sets appropriate array descriptor element at the requested
* index (SetTBSCertSignatAlgor).
*
* NOTE: no checks done on input params
*
*  @param SrcDatArray Array of <code>IDATA</code> structure pointers with algorithm parameters
*  @param SrcIndex Array start index to parameters
*  @param DstDatArray Pointer to array with <code>IDATA</code> structure pointers
*  @param DstIndex Array index to destination <code>IDATA</code> structure
*  @param SignatTypeAlgor Type of signature
*
*  @return ASN1_OP_OK on success, error code otherwise
*/
extern "C"  int  SetTBSCertSignatAlgor(HMEM_CTX_DEF
		IDATA** SrcDatArray,
		int SrcIndex, IDATA** DstDatArray, int DstIndex,
		int SignatTypeAlgor)
{
  int Retcode;

  IDATA** TmpDatArray;
  IDATPARR* pTmpArrayDesc[1];
  //-------------------------------------------------------
  // Encode Algor-ID and Parameter fields
  //-------------------------------------------------------
  Retcode = SubEncodeSignature(HMEM_CTX_REF1 SrcDatArray,SrcIndex,SignatTypeAlgor,0,pTmpArrayDesc);
//  Retcode = SubEncodeSignature(HMEM_CTX_REF1
//				 SrcDatArray,
//				 SrcIndex, SignatTypeAlgor, 0,
//			         pTmpArrayDesc);
  if(Retcode != ASN1_OP_OK) return(Retcode);
  TmpDatArray = pTmpArrayDesc[0]->ppArr;
  //-------------------------------------------------------
  // Copy Descriptor Elements to TBS Array (real Copy)
  //-------------------------------------------------------
  Retcode = AllocCopyDatArrayElements(HMEM_CTX_REF1 TmpDatArray,0,DstDatArray,DstIndex,2,1);
  //------------------------------------------------------------
  // Release the temporary Array Descriptor and its elements
  //------------------------------------------------------------
  FreeIDATPARR_Struc(HMEM_CTX_REF1 pTmpArrayDesc[0]);	// Free Structure
  return(Retcode);
}  
/**
* Allocates buffer for issuer RDN
* if required and sets appropriate array descriptor element at the requested
* index (SetTBSCertIssuerRDN).
*
* NOTE: no checks done on input params !
*
*  @param DatArray Pointer to array with <code>IDATA</code> structure pointers
*  @param IndexOffset Array index to destination <code>IDATA</code> structure
*  @param IssuerRDNBuf Buffer containing the RDN data
*  @param IssuerRDNOff Start of data
*  @param IssuerRDNLen Length of data
*
*  @return ASN1_OP_OK on success, error code otherwise
*/
extern "C"  int  SetTBSCertIssuerRDN(HMEM_CTX_DEF
				IDATA** DatArray,
				int IndexOffset, char* IssuerRDNBuf,
				int IssuerRDNOff, int IssuerRDNLen)
{
  return(FromBufToDatArray(HMEM_CTX_REF1 DatArray,X509_ISSUER_NAME_INDEX+IndexOffset,IssuerRDNBuf,IssuerRDNOff,IssuerRDNLen,1));
}  
/**
* Allocates buffer for subject RDN
* if required and sets appropriate array descriptor element at the requested
* index (SetTBSCertSubjectRDN).
*
* NOTE: no checks done on input params
*
*  @param DatArray Pointer to array with <code>IDATA</code> structure pointers
*  @param IndexOffset Array index to destination <code>IDATA</code> structure
*  @param SubjectRDNBuf Buffer containing the RDN data
*  @param SubjectRDNOff Start of data
*  @param SubjectRDNLen Length of data
*
*  @return ASN1_OP_OK on success, error code otherwise
*/
extern "C"  int  SetTBSCertSubjectRDN(HMEM_CTX_DEF
				IDATA** DatArray,
				int IndexOffset, char* SubjectRDNBuf,
				int SubjectRDNOff, int SubjectRDNLen)
{
  return(FromBufToDatArray(HMEM_CTX_REF1 DatArray,X509_SUBJECT_NAME_INDEX+IndexOffset,SubjectRDNBuf,SubjectRDNOff,SubjectRDNLen,1));
}  
/**
* Allocates buffer for validity elements
* if required and sets appropriate array descriptor element at the requested
* index (SetTBSCertValidity).
*
*  @param DatArray Pointer to array with <code>IDATA</code> structure pointers
*  @param IndexOffset Array index to destination <code>IDATA</code> structure
*  @param NotBeforeTime Pointer to time structure representing validity period
*                       start time
*  @param NotAfterTime pointer to time structure representing validity period
*                      end time
*  @param TimeType 1 - UTC <br>
*               2 - Generalized Time
*
*  @return ASN1_OP_OK on success, error code otherwise
*/
extern "C"  int  SetTBSCertValidity(HMEM_CTX_DEF
				IDATA** DatArray,
				int IndexOffset, int* NotBeforeTime,
				int* NotAfterTime, int TimeType)
{
  char TimeHdr = ASN1_UNIVERSAL_UTC_TIMESTR;

  int Retcode;
  int NotBeforeLen;
  int NotAfterLen;

  int TmpLen[1];

  char NotBeforeBuf[GENERAL_TIME_DEFAULT_LEN+10];
  char NotAfterBuf[GENERAL_TIME_DEFAULT_LEN+10];

  //------------------------------------------------------
  // Check parameters
  //------------------------------------------------------
  if((DatArray == NULL) || (NotBeforeTime == NULL) ||
     (NotAfterTime == NULL))
    return(ASN1_TO_TBSVALIDITY_NULLPTR_ERR);

  if((TimeType != ASN1_TIME_TYPE_UTC) &&
     (TimeType != ASN1_TIME_TYPE_GENTIME))
    return(ASN1_TO_TBSVALIDITY_TIMETYP_ERR);
  TimeType--;					// set relative zero (== UTC)
  //------------------------------------------------------
  // Preset Header with ASN.1 Type
  //------------------------------------------------------
  if(TimeType != 0) TimeHdr = ASN1_UNIVERSAL_GEN_TIMESTR;
  NotBeforeBuf[0] = TimeHdr;
  NotAfterBuf[0]  = TimeHdr;
  //------------------------------------------------------
  // Generate Not Before String
  //------------------------------------------------------
  Retcode = GenerateTimeString(NotBeforeTime, NotBeforeBuf, 2,
			GENERAL_TIME_DEFAULT_LEN+8,TmpLen,TimeType);
  if(Retcode != ASN1_OP_OK) return(Retcode);
  NotBeforeBuf[1] = (char) TmpLen[0];		// set ASN1 Length
  NotBeforeLen = TmpLen[0]+2;
  //------------------------------------------------------
  // Generate Not After String
  //------------------------------------------------------
  Retcode = GenerateTimeString(NotAfterTime, NotAfterBuf, 2,
			GENERAL_TIME_DEFAULT_LEN+8,TmpLen,TimeType);
  if(Retcode != ASN1_OP_OK) return(Retcode);
  NotAfterBuf[1] = (char) TmpLen[0];		// set ASN1 Length
  NotAfterLen = TmpLen[0]+2;
  //------------------------------------------------------
  // Load Strings into Array
  //------------------------------------------------------
  Retcode = FromBufToDatArray(HMEM_CTX_REF1 DatArray,X509_NOT_BEFORE_INDEX+IndexOffset,NotBeforeBuf,0,NotBeforeLen,1);
  if(Retcode != ASN1_OP_OK) return(Retcode);
  Retcode = FromBufToDatArray(HMEM_CTX_REF1 DatArray,X509_NOT_AFTER_INDEX+IndexOffset,NotAfterBuf,0,NotAfterLen,1);
  return(Retcode);
}
/**
* Allocates buffer for public key
* OID, parameters and values and sets appropriate array descriptor element 
* at the requested index (SetTBSCertSubjPubKeyInfo).
*
*  @param DatArray Pointer to array with <code>IDATA</code> structure pointers
*  @param IndexOffset Array index to destination <code>IDATA</code> structure
*  @param SrcArray Array of <code>IDATA</code> structure pointers containing the public 
*                  algorithm parameters/values
*  @param ElementCnt Number of elements in source array
*  @param PubAlgorType Type of public algorithm
*
*  @return ASN1_OP_OK on success, error code otherwise
*/
extern "C"  int  SetTBSCertSubjPubKeyInfo(HMEM_CTX_DEF
				IDATA** DatArray,
				int IndexOffset,
				IDATA** SrcArray, int ElementCnt,
				int PubAlgorType)
{
  int Retcode;

  IDATA** TmpDatArray;
  IDATPARR* pTmpArrayDesc[1];
  //-------------------------------------------------------
  // Encode Algor-ID, Parameter and value fields
  //-------------------------------------------------------
//  Retcode = SUB_ENCODE_PUB_KEY_INFO(HASN1inst,HMEM_CTX_REF,
//				      SrcArray,ElementCnt,
//				      PubAlgorType, pTmpArrayDesc);
  Retcode = SubEncodePubKeyInfo(HMEM_CTX_REF1
				SrcArray,ElementCnt,
				PubAlgorType, pTmpArrayDesc);
  if(Retcode != ASN1_OP_OK) return(Retcode);
  TmpDatArray = pTmpArrayDesc[0]->ppArr;
  //-------------------------------------------------------
  // Copy Descriptor Elements to TBS Array (real Copy)
  //-------------------------------------------------------
  Retcode = AllocCopyDatArrayElements(HMEM_CTX_REF1 TmpDatArray,0,DatArray,X509_PUBLIC_ALGOR_ID_INDEX+IndexOffset,3,1);
  //------------------------------------------------------------
  // Release the temporary Array Descriptor and its elements
  //------------------------------------------------------------
  FreeIDATPARR_Struc(HMEM_CTX_REF1 pTmpArrayDesc[0]);	// Free Structure
  return(Retcode);
}  
/**
* Converts data structures in internal
* notation ('Data Elements') to desired ASN.1 encoded 'To Be Signed'
* certificate output byte stream (ToASN1_TBS_Cert).
* The TBS certificate is constructed
* from:
* <ol>
* <li> Version		      	    (OPTIONAL)
* <li> Serial number
* <li> Signature algor ID
* <li> Signature algor params	    (ANY)
* <li> Issuer RDN substring	    (OPTIONAL, ANY)
* <li> Validity: Not before	    (ANY)
* <li> Validity: Not after	    (ANY)
* <li> Subject RDN substring	    (OPTIONAL, ANY)
* <li> Subj.PublInfo: Algor ID 
* <li> Subj.PublInfo: Algor params  (ANY)
* <li> Subj.PublInfo: PublValue
* <li> IssuerUniqueID		    (BITSTRING, OPTIONAL)
* <li> SubjectUniqueID		    (BITSTRING, OPTIONAL)
* <li> Extensions substring	    (OPTIONAL)	Must be processed further
* </ol>
* 
* This is used for certificate generation.
*
* Note: Required databuffer will be allocated and filled.
*
*  @param DatArray Array of pointers to <code>IDATA</code> structures
*  @param DatArrayIndex start <code>IDATA</code> pointer index for conversion
*  @param DatArraySize Numberof elements in array
*  @param pDstBuf Pointer where to store destination buffer
*  @param DstLen Length of generated data
*  @param SubErrCode Error code from ASN.1 encoding subroutine
*
*  @return ASN1_OP_OK on success, error code otherwise
*/
extern "C"  int  ToASN1_TBS_Cert(HMEM_CTX_DEF
				IDATA** DatArray,
				int DatArrayIndex, int DatArraySize,
				char** pDstBuf, int* DstLen,
				int* SubErrCode)
{
  int i;

  pDstBuf[0] = NULL;			// invalidate
  DstLen[0] = 0;			// dto.
  //---------------------------------------------------------------
  // check given IDATA ptr array element count if valid
  //---------------------------------------------------------------
  if(DatArraySize != X509_TBS_CERT_MAX_DATA_INDEX)
    return(ASN1_INT_TO_TBS_CERT_PARAM_ERR);
  //---------------------------------------------------------------
  // Build the TBS certificate...
  //---------------------------------------------------------------
  i = ToASN1(HMEM_CTX_REF1 DatArray,DatArrayIndex,(char *) X509_TBSCertCtl,X509_TBS_CERT_CTL_CNT,pDstBuf,DstLen);
  if(i == ASN1_OP_OK) return(i);
  SubErrCode[0] = i;
  return(ASN1_INT_TO_TBS_CERT_ERR);    
}

/**
* Gets an <code>IDATA</code> pointer array containing the ASN.1 encoding of a TBS 
* certificate or certificate request starting at given index (SignTBSCert_CertReq). 
* Generates
* the ASN.1 encoded signature data according to requested signature type from 
* the associated parameters, either from the RSA or the DSA structure. A 
* destination buffer is allocated and the encoding is stored to that buffer.
*
*  @param DatArray Array of pointers to <code>IDATA</code> structures
*  @param IndexOffset Start index of data
*  @param RsaStruc RSA structure / NULL
*  @param DsaStruc DSA structure / NULL
*  @param SignatTypeAlgor Type of signature
*  @param pDstBuf Pointer for storing the destination buffer
*  @param pDstLen Length of result data
*
*  @return ASN1_OP_OK on success, error code otherwise
*/
extern "C"  int  SignTBSCert_CertReq(HMEM_CTX_DEF
		IDATA** DatArray,
		int IndexOffset, RSA_STRUC* RsaStruc, DSA_STRUC* DsaStruc,
                int SignatTypeAlgor, char** pDstBuf, int* pDstLen)
{
  int MessageOffset;
  int MessageLen;

  char* MessageBase;

  IDATA* pIdata;
  //------------------------------------------------
  // Check for NULL pointers
  //------------------------------------------------
  if((DatArray == NULL) || (pDstBuf == NULL) || (pDstLen == NULL))
    return(ASN1_SIGN_TBS_DATA_NULL_PTR_ERR);
//  return(ASN1_SIGN_TBS_CERT_NULL_PTR_ERR);

  pIdata = DatArray[X509_TBS_CERT_INDEX+IndexOffset];
  if(pIdata == NULL)
    return(ASN1_SIGN_TBS_DATA_NULL_PTR_ERR);
//  return(ASN1_SIGN_TBS_CERT_NULL_PTR_ERR);

  MessageBase   = pIdata->Base;
  MessageOffset = (int) pIdata->Off;
  MessageLen    = pIdata->Len;

  if(MessageBase == NULL)
    return(ASN1_SIGN_TBS_DATA_NULL_PTR_ERR);
//  return(ASN1_SIGN_TBS_CERT_NULL_PTR_ERR);

  return(SignTBSData(HMEM_CTX_REF1 MessageBase,MessageOffset,MessageLen,RsaStruc,DsaStruc,SignatTypeAlgor,pDstBuf,pDstLen));
}

/**
* Converts data structures in internal
* notation ('Data Elements') to desired ASN.1 encoded certificate
* input byte stream (ToASN1_Cert). 
* The certificate is built from:
* <ol>
* <li> TBS certificate
* <li> Signature algor ID
* <li> Signature algor params (not further parsed)
* <li> Signature
* </ol>
* 
* This is used for certificate generation.
*
* Note: Required data buffer will be allocated and filled.
*
*  @param DatArray Array of pointers to <code>IDATA</code> structures
*  @param DatArrayIndex start <code>IDATA</code> pointer index for conversion
*  @param DatArraySize Numberof elements in array
*  @param pDstBuf Pointer where to store destination buffer
*  @param DstLen Length of generated data
*  @param SubErrCode Error code from ASN.1 encoding subroutine
*
*  @return ASN1_OP_OK on success, error code otherwise
*/
extern "C"  int  ToASN1_Cert(HMEM_CTX_DEF
				IDATA** DatArray,
				int DatArrayIndex, int DatArraySize,
				char** pDstBuf, int* DstLen,
				int* SubErrCode)
{
  int i;

  pDstBuf[0] = NULL;			// invalidate
  DstLen[0] = 0;			// dto.
  //---------------------------------------------------------------
  // check given IDATA ptr array element count if valid
  //---------------------------------------------------------------
  if(DatArraySize != X509_CERT_MAX_DATA_INDEX)
    return(ASN1_INT_TO_CERT_PARAM_ERR);
  //---------------------------------------------------------------
  // Build the Certificate...
  //---------------------------------------------------------------
  i = ToASN1(HMEM_CTX_REF1 DatArray,DatArrayIndex,(char *) X509CertCtl,X509_CERT_CTL_CNT,pDstBuf,DstLen);
  if(i == ASN1_OP_OK) return(i);
  SubErrCode[0] = i;
  return(ASN1_INT_TO_CERT_ERR);    
}
/**
* Generates signed, ASN.1 encoded certificate
* from given TBS certificate, RSA/DSA private key and signature type (GenSignedCertificate).
*
* NOTE: Required data buffer will be allocated and filled.
*
*  @param SrcBuf Buffer containing ASN.1 encoded TBS certificate data
*  @param SrcOff Start of data
*  @param SrcLen Data length
*  @param SignatTypeAlgor Type of signature
*  @param rsa RSA structure / NULL
*  @param dsa DSA structure / NULL
*  @param pDstBuf Pointer where to store destination buffer
*  @param pDstLen Length of generated data
*
*  @return ASN1_OP_OK on success, error code otherwise
* <br>            - else Error occured
*/
extern "C"  int  GenSignedCertificate(HMEM_CTX_DEF
		char* SrcBuf, int SrcOff,
		int SrcLen, int SignatTypeAlgor, RSA_STRUC* rsa,
		DSA_STRUC* dsa, char** pDstBuf, int* pDstLen)

{

  int Retcode;
  int SignatLen;

  char* pSignatMem=NULL;

  char* pTmpBuf[1];
  int pTmpLen[1];
  int pTmpErrCode[1];

  IDATA** pSrcDatArray = NULL;
  IDATA** pTmpDatArray[1];

  IDATA** DatArray;
  IDATPARR* DatArrayDesc = NULL;
  IDATPARR* pTmpDatArrayDesc[1];

  //-------------------------------------------------------
  // Get Array for Certificate Construction, mark as freeable
  //-------------------------------------------------------
  Retcode = AllocIDATPARR_Struc(HMEM_CTX_REF1 pTmpDatArrayDesc,X509_CERT_MAX_DATA_INDEX);
  if(Retcode != ASN1_OP_OK) return(Retcode);
  DatArrayDesc = pTmpDatArrayDesc[0];
  DatArrayDesc->Flags |= FREE_BIT_MASK;  
  DatArray = DatArrayDesc->ppArr;
  for(;;)
  {
    //-------------------------------------------------------
    // Copy TBS-Cert to Array Element
    //-------------------------------------------------------
    Retcode = FromBufToDatArray(HMEM_CTX_REF1 DatArray,X509_TBS_CERT_INDEX,SrcBuf,SrcOff,SrcLen,1);
    if(Retcode != ASN1_OP_OK) break;
    //-------------------------------------------------------
    // Generate the Signature, put to Element
    //-------------------------------------------------------
    Retcode = SignTBSCert_CertReq(HMEM_CTX_REF1
				  DatArray,0,rsa,dsa,SignatTypeAlgor,
			          pTmpBuf,pTmpLen);
    if(Retcode != ASN1_OP_OK) break;
    pSignatMem = pTmpBuf[0];
    SignatLen  = pTmpLen[0];

    Retcode = AllocIDATA_Array(HMEM_CTX_REF1 pTmpDatArray,1);
    if(Retcode != ASN1_OP_OK) break;
    pSrcDatArray = pTmpDatArray[0];

    Retcode = FromBufToDatArray(HMEM_CTX_REF1 pSrcDatArray,0,pSignatMem,0,SignatLen,0);
       if(Retcode != ASN1_OP_OK) break;
    //-------------------------------------------------------
    // Append Signature type, algor and data to Array
    //-------------------------------------------------------
//    Retcode = SetSignatAlgAndData(DatArray,X509_VFY_SIGNAT_ALGOR_ID_INDEX,
//			pSrcDatArray,1,SignatTypeAlgor);
    Retcode = SetSignatAlgAndData(HMEM_CTX_REF1 DatArray,X509_VFY_SIGNAT_ALGOR_ID_INDEX,pSrcDatArray,1,SignatTypeAlgor);
    if(Retcode != ASN1_OP_OK) break;
    //-------------------------------------------------------
    // Generate the Certificate
    //-------------------------------------------------------
    Retcode = ToASN1_Cert(HMEM_CTX_REF1
			  DatArray,0,X509_CERT_MAX_DATA_INDEX,
			  pTmpBuf,pTmpLen,pTmpErrCode);
    if(Retcode != ASN1_OP_OK) Retcode = pTmpErrCode[0];
    break;
  } // Error FOR
  FREE_ARRAY(HMEM_CTX_REF,pSrcDatArray);	// free signature buffer
  FreeIDATPARR_Struc(HMEM_CTX_REF1 DatArrayDesc);
  if(Retcode != ASN1_OP_OK)
    return(Retcode);
  pDstBuf[0] = pTmpBuf[0];
  pDstLen[0] = pTmpLen[0];
  return(ASN1_OP_OK);
}

/**
* Stores the RSA parameters
* into a given parameter/value data array descriptor as newly allocated element (FromRSAPubParamsToArrayDesc).
*
*  @param RsaStruc RSA key structure
*  @param pPubParValsDesc Pointer to destination structure
*
*  @return ASN1_OP_OK on success, error code otherwise
*/
extern "C"  int  FromRSAPubParamsToArrayDesc(HMEM_CTX_DEF
		 RSA_STRUC* RsaStruc, IDATPARR** pPubParValsDesc)
{
  int Retcode;

  IDATPARR* pTmpArrDesc[1];
  IDATPARR* DatArrayDesc = NULL;
  //------------------------------------------------
  // Check for NULL pointers
  //------------------------------------------------
  if((pPubParValsDesc == NULL) || (RsaStruc == NULL))
    return(ASN1_RSA_PUB_TO_DESC_NULPTR_ERR);
  pPubParValsDesc[0] = NULL;
  //------------------------------------------------
  // Allocate the Descriptor Array, mark as freeable
  //------------------------------------------------
  Retcode = AllocIDATPARR_Struc(HMEM_CTX_REF1 pTmpArrDesc,RSA_ALG_PAR_MAX_INDEX+ RSA_PUB_VAL_MAX_INDEX);
  if(Retcode != ASN1_OP_OK)
    return(ASN1_RSA_PUB_TO_DESC_ALLOC_ERR);
  DatArrayDesc = pTmpArrDesc[0];			// get descriptor base
  DatArrayDesc->Flags |= FREE_BIT_MASK;	// mark as freeable
  for(;;)	// Error FOR
  {
    //------------------------------------------------
    // Convert/Store the modulus
    //------------------------------------------------
    Retcode = FromLnumToArrayDescElement(HMEM_CTX_REF1 DatArrayDesc,RSA_ALG_PAR_MAX_INDEX+ RSA_PUB_VAL_MOD_INDEX,RsaStruc->Modul);
    if(Retcode != ASN1_OP_OK) break;
    //------------------------------------------------
    // Convert/Store the public exponent
    //------------------------------------------------
    Retcode = FromLnumToArrayDescElement(HMEM_CTX_REF1 DatArrayDesc,RSA_ALG_PAR_MAX_INDEX+ RSA_PUB_VAL_EXP_INDEX,RsaStruc->PubExp);
    break;
  } // Error FOR
  if(Retcode != ASN1_OP_OK)
  {
    FreeIDATPARR_Struc(HMEM_CTX_REF1 DatArrayDesc);
    return(Retcode);
  }
  pPubParValsDesc[0] = DatArrayDesc;
  return(ASN1_OP_OK);            
}
/**
* Stores the DSA parameters
* into a given parameter/value data array descriptor as newly allocated element (FromDSAPubParamsToArrayDesc).
*
*  @param DsaStruc DSA key structure
*  @param pPubParValsDesc Pointer to destination structure
*
*  @return ASN1_OP_OK on success, error code otherwise
*/
extern "C"  int  FromDSAPubParamsToArrayDesc(HMEM_CTX_DEF
		 DSA_STRUC* DsaStruc,IDATPARR** pPubParValsDesc)
{
  int Retcode;

  IDATPARR* pTmpArrDesc[1];
  IDATPARR* DatArrayDesc = NULL;
  //------------------------------------------------
  // Check for NULL pointers
  //------------------------------------------------
  if((pPubParValsDesc == NULL) || (DsaStruc == NULL))
    return(ASN1_DSA_PUB_TO_DESC_NULPTR_ERR);
  pPubParValsDesc[0] = NULL;
  //------------------------------------------------
  // Allocate the Descriptor Array, mark as freeable
  //------------------------------------------------
  Retcode = AllocIDATPARR_Struc(HMEM_CTX_REF1 pTmpArrDesc,DSA_ALG_PAR_MAX_INDEX+ DSA_PUB_VAL_MAX_INDEX);
  if(Retcode != ASN1_OP_OK)
    return(ASN1_DSA_PUB_TO_DESC_ALLOC_ERR);
  DatArrayDesc = pTmpArrDesc[0];
  DatArrayDesc->Flags |= FREE_BIT_MASK;	// mark as freeable
  for(;;)	// Error FOR
  {
    //------------------------------------------------
    // Convert/Store the Prime p
    //------------------------------------------------
    Retcode = FromLnumToArrayDescElement(HMEM_CTX_REF1 DatArrayDesc,DSA_ALG_PAR_P_INDEX,DsaStruc->p);
    if(Retcode != ASN1_OP_OK) break;
    //------------------------------------------------
    // Convert/Store the Prime q
    //------------------------------------------------
    Retcode = FromLnumToArrayDescElement(HMEM_CTX_REF1 DatArrayDesc,DSA_ALG_PAR_Q_INDEX,DsaStruc->q);
    if(Retcode != ASN1_OP_OK) break;
    //------------------------------------------------
    // Convert/Store the Generatore g
    //------------------------------------------------
    Retcode = FromLnumToArrayDescElement(HMEM_CTX_REF1 DatArrayDesc,DSA_ALG_PAR_G_INDEX,DsaStruc->g);
    if(Retcode != ASN1_OP_OK) break;
    //------------------------------------------------
    // Convert/Store the public value
    //------------------------------------------------
    Retcode = FromLnumToArrayDescElement(HMEM_CTX_REF1 DatArrayDesc,DSA_ALG_PAR_MAX_INDEX+DSA_PUB_VAL_Y_INDEX,DsaStruc->y);
    break;
  } // Error FOR
  if(Retcode != ASN1_OP_OK)
  {
    FreeIDATPARR_Struc(HMEM_CTX_REF1 DatArrayDesc);
    return(Retcode);
  }
  pPubParValsDesc[0] = DatArrayDesc;
  return(ASN1_OP_OK);            
}
/**
* Stores the RSA algorithm
* parameters (NULL) and values for the private key
* into a given parameter/value data array descriptor as newly allocated element (FromRSAPrivParamsToArrayDesc).
*
* NOTE: Is also used for OPENSSL private key (PEM) files
*
*  @param RsaStruc RSA key structure
*  @param pPrivParValsDesc Pointer to destination structure
*
*  @return ASN1_OP_OK on success, error code otherwise
*/
extern "C"  int  FromRSAPrivParamsToArrayDesc(HMEM_CTX_DEF
		 RSA_STRUC* RsaStruc, IDATPARR** pPrivParValsDesc)
{
  int Retcode;

  char PrivKeyVersion[1] = {0};

  IDATPARR* pTmpArrDesc[1];
  IDATPARR* DatArrayDesc = NULL;
  //------------------------------------------------
  // Check for NULL pointers
  //------------------------------------------------
  if((pPrivParValsDesc == NULL) || (RsaStruc == NULL))
    return(ASN1_RSA_PUB_TO_DESC_NULPTR_ERR);
  pPrivParValsDesc[0] = NULL;
  //------------------------------------------------
  // Allocate the Descriptor Array, mark as freeable
  //------------------------------------------------
  Retcode = AllocIDATPARR_Struc(HMEM_CTX_REF1 pTmpArrDesc,RSA_ALG_PAR_MAX_INDEX+ RSA_PRIV_KEY_MAX_INDEX);
  if(Retcode != ASN1_OP_OK)
    return(ASN1_RSA_PRIV_TO_DESC_ALLOC_ERR);
  DatArrayDesc = pTmpArrDesc[0];
  DatArrayDesc->Flags |= (FREE_BIT_MASK|FREE_CLEAR_BIT_MASK);  
  for(;;)	// Error FOR
  {
    //------------------------------------------------
    // Convert/Store the modulus
    //------------------------------------------------
    Retcode = FromLnumToArrayDescElement(HMEM_CTX_REF1 DatArrayDesc,RSA_ALG_PAR_MAX_INDEX+RSA_PRIV_KEY_MODULUS_INDEX,RsaStruc->Modul);
    if(Retcode != ASN1_OP_OK) break;
    //------------------------------------------------
    // Convert/Store the public exponent
    //------------------------------------------------
    Retcode = FromLnumToArrayDescElement(HMEM_CTX_REF1 DatArrayDesc,RSA_ALG_PAR_MAX_INDEX+RSA_PRIV_KEY_PUBL_EXP_INDEX,RsaStruc->PubExp);
    if(Retcode != ASN1_OP_OK) break;
    //------------------------------------------------
    // Convert/Store the private exponent
    //------------------------------------------------
    Retcode = FromLnumToArrayDescElement(HMEM_CTX_REF1 DatArrayDesc,RSA_ALG_PAR_MAX_INDEX+RSA_PRIV_KEY_PRIV_EXP_INDEX,RsaStruc->PrivExp);
    if(Retcode != ASN1_OP_OK) break;
    //------------------------------------------------
    // Convert/Store the prime p
    //------------------------------------------------
    Retcode = FromLnumToArrayDescElement(HMEM_CTX_REF1 DatArrayDesc,RSA_ALG_PAR_MAX_INDEX+RSA_PRIV_KEY_PRIME_P_INDEX,RsaStruc->Prime_p);
    if(Retcode != ASN1_OP_OK) break;
    //------------------------------------------------
    // Convert/Store the prime q
    //------------------------------------------------
    Retcode = FromLnumToArrayDescElement(HMEM_CTX_REF1 DatArrayDesc,RSA_ALG_PAR_MAX_INDEX+RSA_PRIV_KEY_PRIME_Q_INDEX,RsaStruc->Prime_q);
    if(Retcode != ASN1_OP_OK) break;
    //------------------------------------------------
    // Convert/Store the Dmodp-1
    //------------------------------------------------
    Retcode = FromLnumToArrayDescElement(HMEM_CTX_REF1 DatArrayDesc,RSA_ALG_PAR_MAX_INDEX+RSA_PRIV_KEY_EXP1_INDEX,RsaStruc->Dmodpm1);
    if(Retcode != ASN1_OP_OK) break;
    //------------------------------------------------
    // Convert/Store the Dmodq-1
    //------------------------------------------------
    Retcode = FromLnumToArrayDescElement(HMEM_CTX_REF1 DatArrayDesc,RSA_ALG_PAR_MAX_INDEX+RSA_PRIV_KEY_EXP2_INDEX,RsaStruc->Dmodqm1);
    if(Retcode != ASN1_OP_OK) break;
    //------------------------------------------------
    // Convert/Store the Invqmodp
    //------------------------------------------------
    Retcode = FromLnumToArrayDescElement(HMEM_CTX_REF1 DatArrayDesc,RSA_ALG_PAR_MAX_INDEX+RSA_PRIV_KEY_COEFF_INDEX,RsaStruc->Invqmp);
    if(Retcode != ASN1_OP_OK) break;
    //------------------------------------------------
    // Convert/Store the Version
    //------------------------------------------------
    Retcode = FromBufToDatArray(HMEM_CTX_REF1 DatArrayDesc->ppArr,RSA_ALG_PAR_MAX_INDEX+RSA_PRIV_KEY_VERSION_INDEX,PrivKeyVersion,0,1,1);
    break;
  } // Error FOR
  if(Retcode != ASN1_OP_OK)
  {
    FreeIDATPARR_Struc(HMEM_CTX_REF1 DatArrayDesc);
    return(Retcode);
  }
  pPrivParValsDesc[0] = DatArrayDesc;
  return(ASN1_OP_OK);            
}
/**
* Stores the DSA algorithm
* parameters and the private key values
* into a given parameter/value data array descriptor as newly allocated element (FromDSAPrivParamsToArrayDesc).
*
* NOTE: Is also used for OPENSSL private key (PEM) files
*
*  @param DsaStruc DSA key structure
*  @param pPrivParValsDesc Pointer to destination structure
*
*  @return ASN1_OP_OK on success, error code otherwise
*/
extern "C"  int  FromDSAPrivParamsToArrayDesc(HMEM_CTX_DEF
		 DSA_STRUC* DsaStruc, IDATPARR** pPrivParValsDesc)
{
  int Retcode;

  char PrivKeyVersion[1] = {0};

  IDATPARR* pTmpArrDesc[1];
  IDATPARR* DatArrayDesc = NULL;
  //------------------------------------------------
  // Check for NULL pointers
  //------------------------------------------------
  if((pPrivParValsDesc == NULL) || (DsaStruc == NULL))
    return(ASN1_DSA_PRIV_TO_DESC_NULPT_ERR);
  pPrivParValsDesc[0] = NULL;
  //------------------------------------------------
  // Allocate the Descriptor Array, mark as freeable
  //------------------------------------------------
  Retcode = AllocIDATPARR_Struc(HMEM_CTX_REF1 pTmpArrDesc,DSA_ALG_PAR_MAX_INDEX+ DSA_PRIV_KEY_MAX_INDEX);
  if(Retcode != ASN1_OP_OK)
    return(ASN1_DSA_PRIV_TO_DESC_ALLOC_ERR);
  DatArrayDesc = pTmpArrDesc[0];
  DatArrayDesc->Flags |= (FREE_BIT_MASK|FREE_CLEAR_BIT_MASK);  
  for(;;)	// Error FOR
  {
    //------------------------------------------------
    // Convert/Store the Prime p
    //------------------------------------------------
    Retcode = FromLnumToArrayDescElement(HMEM_CTX_REF1 DatArrayDesc,DSA_ALG_PAR_P_INDEX,DsaStruc->p);
    if(Retcode != ASN1_OP_OK) break;
    //------------------------------------------------
    // Convert/Store the Prime q
    //------------------------------------------------
    Retcode = FromLnumToArrayDescElement(HMEM_CTX_REF1 DatArrayDesc,DSA_ALG_PAR_Q_INDEX,DsaStruc->q);
    if(Retcode != ASN1_OP_OK) break;
    //------------------------------------------------
    // Convert/Store the Generatore g
    //------------------------------------------------
    Retcode = FromLnumToArrayDescElement(HMEM_CTX_REF1 DatArrayDesc,DSA_ALG_PAR_G_INDEX,DsaStruc->g);
    if(Retcode != ASN1_OP_OK) break;
    //------------------------------------------------
    // Convert/Store the public value y
    //------------------------------------------------
    Retcode = FromLnumToArrayDescElement(HMEM_CTX_REF1 DatArrayDesc,DSA_ALG_PAR_MAX_INDEX+DSA_PRIV_KEY_YKEY_INDEX,DsaStruc->y);
    if(Retcode != ASN1_OP_OK) break;
    //------------------------------------------------
    // Convert/Store the private value x
    //------------------------------------------------
    Retcode = FromLnumToArrayDescElement(HMEM_CTX_REF1 DatArrayDesc,DSA_ALG_PAR_MAX_INDEX+DSA_PRIV_KEY_XKEY_INDEX,DsaStruc->x);
    if(Retcode != ASN1_OP_OK) break;
    //------------------------------------------------
    // Convert/Store the Version
    //------------------------------------------------
    Retcode = FromBufToDatArray(HMEM_CTX_REF1 DatArrayDesc->ppArr,DSA_ALG_PAR_MAX_INDEX+DSA_PRIV_KEY_VERSION_INDEX,PrivKeyVersion,0,1,1);
    break;
  } // Error FOR
  if(Retcode != ASN1_OP_OK)
  {
    FreeIDATPARR_Struc(HMEM_CTX_REF1 DatArrayDesc);
    return(Retcode);
  }
  pPrivParValsDesc[0] = DatArrayDesc;
  return(ASN1_OP_OK);            
}
/**
* Stores the DH algorithm
* parameters and the public and private key values
* into a given parameter/value data array descriptor as newly allocated element (FromDHPrivParamsToArrayDesc).
*
*  @param DhStruc DH structure
*  @param pPrivParValsDesc Pointer to destination structure
*
*  @return ASN1_OP_OK on success, error code otherwise
*/
extern "C"  int  FromDHPrivParamsToArrayDesc(HMEM_CTX_DEF
		 DH_STRUC* DhStruc, IDATPARR** pPrivParValsDesc)
{
  int Retcode;

  char PrivKeyVersion[1] = {0};

  IDATPARR* pTmpArrDesc[1];
  IDATPARR* DatArrayDesc = NULL;
  //------------------------------------------------
  // Check for NULL pointers
  //------------------------------------------------
  if((pPrivParValsDesc == NULL) || (DhStruc == NULL))
    return(ASN1_DH_PRIV_TO_DESC_NULPT_ERR);
  pPrivParValsDesc[0] = NULL;
  //------------------------------------------------
  // Allocate the Descriptor Array, mark as freeable
  //------------------------------------------------
  Retcode = AllocIDATPARR_Struc(HMEM_CTX_REF1 pTmpArrDesc,DH_ALG_PAR_MAX_INDEX+ DH_PRIV_KEY_MAX_INDEX);
  if(Retcode != ASN1_OP_OK)
    return(ASN1_DH_PRIV_TO_DESC_ALLOC_ERR);
  DatArrayDesc = pTmpArrDesc[0];
  DatArrayDesc->Flags |= (FREE_BIT_MASK|FREE_CLEAR_BIT_MASK);  
  for(;;)	// Error FOR
  {
    //------------------------------------------------
    // Convert/Store the Prime p
    //------------------------------------------------
    Retcode = FromLnumToArrayDescElement(HMEM_CTX_REF1 DatArrayDesc,DH_ALG_PAR_P_INDEX,DhStruc->p);
    if(Retcode != ASN1_OP_OK) break;
    //------------------------------------------------
    // Convert/Store the Generator g
    //------------------------------------------------
    Retcode = FromLnumToArrayDescElement(HMEM_CTX_REF1 DatArrayDesc,DH_ALG_PAR_G_INDEX,DhStruc->g);
    if(Retcode != ASN1_OP_OK) break;
    //------------------------------------------------
    // Convert/Store the Prime q
    //------------------------------------------------
    Retcode = FromLnumToArrayDescElement(HMEM_CTX_REF1 DatArrayDesc,DH_ALG_PAR_Q_INDEX,DhStruc->q);
    if(Retcode != ASN1_OP_OK) break;
    //------------------------------------------------
    // Convert/Store the Factor j
    //------------------------------------------------
    Retcode = FromLnumToArrayDescElement(HMEM_CTX_REF1 DatArrayDesc,DH_ALG_PAR_J_INDEX,DhStruc->j);
    if(Retcode != ASN1_OP_OK) break;
    //------------------------------------------------
    // Convert/Store the public value y
    //------------------------------------------------
    Retcode = FromLnumToArrayDescElement(HMEM_CTX_REF1 DatArrayDesc,DH_ALG_PAR_MAX_INDEX+DH_PRIV_KEY_YKEY_INDEX,DhStruc->PubKey);
    if(Retcode != ASN1_OP_OK) break;
    //------------------------------------------------
    // Convert/Store the private value x
    //------------------------------------------------
    Retcode = FromLnumToArrayDescElement(HMEM_CTX_REF1 DatArrayDesc,DH_ALG_PAR_MAX_INDEX+DH_PRIV_KEY_XKEY_INDEX,DhStruc->PrivKey);
    if(Retcode != ASN1_OP_OK) break;
    //------------------------------------------------
    // Convert/Store the Version
    //------------------------------------------------
    Retcode = FromBufToDatArray(HMEM_CTX_REF1 DatArrayDesc->ppArr,DH_ALG_PAR_MAX_INDEX+DH_PRIV_KEY_VERSION_INDEX,PrivKeyVersion,0,1,1);
    break;
  } // Error FOR
  if(Retcode != ASN1_OP_OK)
  {
    FreeIDATPARR_Struc(HMEM_CTX_REF1 DatArrayDesc);
    return(Retcode);
  }
  pPrivParValsDesc[0] = DatArrayDesc;
  return(ASN1_OP_OK);            
}

extern "C"  int  FromOpensslRsaPrivKey(HMEM_CTX_DEF
	char* pInpBuf, int InpOff, int InpLen, RSA_STRUC** ppRsaStruc)
{
  int Retcode;
  IDATPARR* pDatArrayDesc = NULL;
  IDATPARR* pTmpDatArrDesc[1];

  if((pInpBuf == NULL) || (ppRsaStruc == NULL))
    return(ASN1_NULL_PTR);

  ppRsaStruc[0] = NULL;
  //-------------------------------------------------------
  // Allocate the required Element array
  //-------------------------------------------------------
  if((Retcode = AllocIDATPARR_Struc(HMEM_CTX_REF1 pTmpDatArrDesc,OPSSL_RSA_PRIV_MAX_DATA_INDEX)) != ASN1_OP_OK)
    return(Retcode);
  //-------------------------------------------------------
  // ASN.1 decode the structure
  //-------------------------------------------------------
  pDatArrayDesc = pTmpDatArrDesc[0];
  
  if((Retcode = FromASN1(HMEM_CTX_REF1 pInpBuf,InpOff,InpLen,(char *) Openssl_RSA_Privkey_Ctl,OPSSL_RSA_PRIVKEY_CTL_CNT,pDatArrayDesc->ppArr,0)) != ASN1_OP_OK)
  {
    FreeIDATPARR_Struc(HMEM_CTX_REF1 pDatArrayDesc);
    return(Retcode);
  }
  //-------------------------------------------------------
  // Convert the structure into RSA structure
  //-------------------------------------------------------
  Retcode = FromArrayDescToRSAPrivParams(HMEM_CTX_REF1 pDatArrayDesc,ppRsaStruc);
  FreeIDATPARR_Struc(HMEM_CTX_REF1 pDatArrayDesc);
  return(Retcode);
}  

extern "C"  int  ToOpensslRsaPrivKey(HMEM_CTX_DEF
	RSA_STRUC* pRsaStruc, char** ppDstBuf, int* pDstLen)
{
  int Retcode;
  IDATPARR* pDatArrayDesc = NULL;
  IDATPARR* pTmpDatArrDesc[1];

  if((pRsaStruc == NULL) || (ppDstBuf == NULL) || (pDstLen == NULL))
    return(ASN1_NULL_PTR);

  ppDstBuf[0] = NULL;
  pDstLen[0]  = 0;

  //-------------------------------------------------------
  // Convert the RSA structure to data array descriptor
  //-------------------------------------------------------
  if((Retcode = FromRSAPrivParamsToArrayDesc(HMEM_CTX_REF1
			pRsaStruc, pTmpDatArrDesc)) != ASN1_OP_OK)
    return(Retcode);

  pDatArrayDesc = pTmpDatArrDesc[0];
  //-------------------------------------------------------
  // ASN.1 encode the Array descriptor
  //-------------------------------------------------------
  Retcode = ToASN1(HMEM_CTX_REF1 pDatArrayDesc->ppArr,0,(char *) Openssl_RSA_Privkey_Ctl,OPSSL_RSA_PRIVKEY_CTL_CNT,ppDstBuf,pDstLen);
  FreeIDATPARR_Struc(HMEM_CTX_REF1 pDatArrayDesc);
  return(Retcode);
}

extern "C"  int  FromOpensslDsaPrivKey(HMEM_CTX_DEF
	char* pInpBuf, int InpOff, int InpLen, DSA_STRUC** ppDsaStruc)
{
  int Retcode;
  IDATPARR* pDatArrayDesc = NULL;
  IDATPARR* pTmpDatArrDesc[1];

  if((pInpBuf == NULL) || (ppDsaStruc == NULL))
    return(ASN1_NULL_PTR);

  ppDsaStruc[0] = NULL;
  //-------------------------------------------------------
  // Allocate the required Element array
  //-------------------------------------------------------
  if((Retcode = AllocIDATPARR_Struc(HMEM_CTX_REF1 pTmpDatArrDesc,OPSSL_DSA_PRIV_MAX_DATA_INDEX)) != ASN1_OP_OK)
    return(Retcode);
  //-------------------------------------------------------
  // ASN.1 decode the structure
  //-------------------------------------------------------
  pDatArrayDesc = pTmpDatArrDesc[0];
 
  if((Retcode = FromASN1(HMEM_CTX_REF1 pInpBuf,InpOff,InpLen,(char *) Openssl_DSA_Privkey_Ctl,OPSSL_DSA_PRIVKEY_CTL_CNT,pDatArrayDesc->ppArr,0)) != ASN1_OP_OK)
  {
    FreeIDATPARR_Struc(HMEM_CTX_REF1 pDatArrayDesc);
    return(Retcode);
  }
  //-------------------------------------------------------
  // Convert the structure into DSA structure
  //-------------------------------------------------------
  Retcode = FromArrayDescToDSAPrivParams(HMEM_CTX_REF1 pDatArrayDesc,ppDsaStruc);
  FreeIDATPARR_Struc(HMEM_CTX_REF1 pDatArrayDesc);
  return(Retcode);
}  

extern "C"  int  ToOpensslDsaPrivKey(HMEM_CTX_DEF
	DSA_STRUC* pDsaStruc, char** ppDstBuf, int* pDstLen)
{
  int Retcode;
  IDATPARR* pDatArrayDesc = NULL;
  IDATPARR* pTmpDatArrDesc[1];

  if((pDsaStruc == NULL) || (ppDstBuf == NULL) || (pDstLen == NULL))
    return(ASN1_NULL_PTR);

  ppDstBuf[0] = NULL;
  pDstLen[0]  = 0;

  //-------------------------------------------------------
  // Convert the DSA structure to data array descriptor
  //-------------------------------------------------------
  if((Retcode = FromDSAPrivParamsToArrayDesc(HMEM_CTX_REF1
			pDsaStruc, pTmpDatArrDesc)) != ASN1_OP_OK)
    return(Retcode);

  pDatArrayDesc = pTmpDatArrDesc[0];
  //-------------------------------------------------------
  // ASN.1 encode the Array descriptor
  //-------------------------------------------------------
  Retcode = ToASN1(HMEM_CTX_REF1 pDatArrayDesc->ppArr,0,(char *) Openssl_DSA_Privkey_Ctl,OPSSL_DSA_PRIVKEY_CTL_CNT,ppDstBuf,pDstLen);
  FreeIDATPARR_Struc(HMEM_CTX_REF1 pDatArrayDesc);
  return(Retcode);
}

/**
* Sets the RSA public key info for a TBS certificate (SetTBSCertRSASubjPubKeyInfo).
* Allocates required buffers, generates the algorithm OID, parameters and values
* and stores it to the given array.
*
*  @param DatArray Array for data elements
*  @param IndexOffset Start index to add to base
*  @param RsaStruc Given RSA structure
*
*  @return ASN1_OP_OK on success, error code otherwise
*/
extern "C"  int  SetTBSCertRSASubjPubKeyInfo(HMEM_CTX_DEF
		IDATA** DatArray,
		int IndexOffset, RSA_STRUC* RsaStruc)
{
  int Retcode;
  int ElementCnt;

  IDATA** pTmpArray;
  IDATPARR* pTmpArrayDesc[1];

  //----------------------------------------------------
  // Generate the Array Descriptor for RSA Params/Values
  //----------------------------------------------------
  Retcode = FromRSAPubParamsToArrayDesc(HMEM_CTX_REF1
				        RsaStruc,pTmpArrayDesc);
  if(Retcode != ASN1_OP_OK) return(Retcode);
  pTmpArray = pTmpArrayDesc[0]->ppArr;		// get Array Base
  ElementCnt = pTmpArrayDesc[0]->Cnt;		// get count
  //----------------------------------------------------
  // Generate the TBS Parameter/Values Entries for RSA
  //----------------------------------------------------
  Retcode = SetTBSCertSubjPubKeyInfo(HMEM_CTX_REF1
			DatArray,IndexOffset,
			pTmpArray,ElementCnt, RSA_PUBLIC_ALGOR);
  FreeIDATPARR_Struc(HMEM_CTX_REF1 pTmpArrayDesc[0]);	// release Array
  return(Retcode);
}
/**
* Sets the DSA public key info for a TBS certificate (SetTBSCertDSASubjPubKeyInfo).
* Allocates required buffers, generates th algorithm OID, parameters and values
* and stores it to the given array.
*
*  @param DatArray Array for data elements
*  @param IndexOffset Start index to add to base
*  @param DsaStruc Given DSA structure
*
*  @return ASN1_OP_OK on success, error code otherwise
*/
extern "C"  int  SetTBSCertDSASubjPubKeyInfo(HMEM_CTX_DEF
		IDATA** DatArray,
		int IndexOffset, DSA_STRUC* DsaStruc)
{
  int Retcode;
  int ElementCnt;

  IDATA** pTmpArray;
  IDATPARR* pTmpArrayDesc[1];

  //----------------------------------------------------
  // Generate the Array Descriptor for DSA Params/Values
  //----------------------------------------------------
  Retcode = FromDSAPubParamsToArrayDesc(HMEM_CTX_REF1
					DsaStruc,pTmpArrayDesc);
  if(Retcode != ASN1_OP_OK) return(Retcode);
  pTmpArray = pTmpArrayDesc[0]->ppArr;		// get Array Base
  ElementCnt = pTmpArrayDesc[0]->Cnt;		// get count
  //----------------------------------------------------
  // Generate the TBS Parametr/Values Entries for DSA
  //----------------------------------------------------
  Retcode = SetTBSCertSubjPubKeyInfo(HMEM_CTX_REF1
			DatArray,IndexOffset,
			pTmpArray,ElementCnt, DSA_PUBLIC_ALGOR);
  FreeIDATPARR_Struc(HMEM_CTX_REF1 pTmpArrayDesc[0]);	// release Array
  return(Retcode);
}
/**
* Sets the DH public key info for a TBS certificate (SetTBSCertDHSubjPubKeyInfo).
* Allocates required buffers, generates th algorithm OID, parameters and values
* and stores it to the given array.
*
*  @param DatArray Array for data elements
*  @param IndexOffset Start index to add to base
*  @param DhStruc Given DH structure
**
*  @return ASN1_OP_OK on success, error code otherwise
*/
extern "C"  int  SetTBSCertDHSubjPubKeyInfo(HMEM_CTX_DEF
		IDATA** DatArray, int IndexOffset, DH_STRUC* DhStruc)
{
  int Retcode;
  int ElementCnt;

  IDATA** pTmpArray;
  IDATPARR* pTmpArrayDesc[1];

  //----------------------------------------------------
  // Generate the Array Descriptor for DH Params/Values
  //----------------------------------------------------
  Retcode = FromDHPubParamsToArrayDesc(HMEM_CTX_REF1 DhStruc,pTmpArrayDesc);
  if(Retcode != ASN1_OP_OK) return(Retcode);
  pTmpArray = pTmpArrayDesc[0]->ppArr;		// get Array Base
  ElementCnt = pTmpArrayDesc[0]->Cnt;		// get count
  //----------------------------------------------------
  // Generate the TBS Parametr/Values Entries for DSA
  //----------------------------------------------------
  Retcode = SetTBSCertSubjPubKeyInfo(HMEM_CTX_REF1
			DatArray,IndexOffset,
			pTmpArray,ElementCnt, DH_PUBLIC_ALGOR);
  FreeIDATPARR_Struc(HMEM_CTX_REF1 pTmpArrayDesc[0]);	// release Array
  return(Retcode);
}
/**
* Generates the PKCS8 private key info
* ASN.1 structure from given public/private key algorithm and the
* algor params/private values data array (SubEncodePrivKeyInfo).
*
* NOTE:
* <ol>
* <li> The source structure must be freed separately
* <li> The output data are a deep copy, so that a local free
*	    can be done without affecting the source data
* </ol>
*
*  @param SrcDatArray Array of pointers to <code>IDATA</code> structures
*  @param ElementCnt Number of elements in the array
*  @param PubAlgorType Type of public algorithm
*  @param pDstBuf Pointer where to store destination buffer
*  @param pDstLen Length of destination buffer
*
*  @return ASN1_OP_OK on success, error code otherwise
*/
extern "C"  int  SubEncodePrivKeyInfo(HMEM_CTX_DEF
		IDATA** SrcDatArray, int ElementCnt, int PubAlgorType,
		char** pDstBuf, int* pDstLen)
{
  int i;
  int Retcode = ASN1_OP_OK;
  int AlgorOIDIndex;
  int TotalCnt;

  int ParamCtlCnt;
  int ParamErrCode;

  int ValueIndex=0;
  int ValueCtlCnt;
  int ValueErrCode;

  int KeyBufLen;

  char * pParamCtl;
  char * pValueCtl;

  char* pKeyBuf = NULL;
  char* pParamBuf = NULL;

  char* pTmpBuf[1];

  char KeyInfoVersion[1]={0};

  int pTmpLen[1];

  IDATPARR* pTmpArrayDesc[1];
  IDATPARR* DatArrayDesc = NULL;

  IDATA** DatArray = NULL;

  //----------------------------------------------------
  // check for NULL-Pointers
  //----------------------------------------------------
  if((SrcDatArray == NULL) || (pDstBuf == NULL))
    return(ASN1_ENC_PRIV_KEY_NULL_PTR_ERR);
  pDstBuf[0] = NULL;
  //--------------------------------------------------------
  // check if the Algor is known, get Param/Value data count
  //--------------------------------------------------------
  switch(PubAlgorType)
  {
    case RSA_PUBLIC_ALGOR:
      AlgorOIDIndex = OID_PKCS1_RSA_ENCRYPTION;

      ParamCtlCnt   = RSA_PUB_ALG_CTL_CNT;
      pParamCtl     = (char*)RSA_AlgorParamsCtl;
      ParamErrCode  = ASN1_ENC_PRIV_KEY_RSA_PAR_ERR;

      ValueIndex    = RSA_ALG_PAR_MAX_INDEX;
      ValueCtlCnt   = RSA_PRIV_KEY_CTL_CNT;
      pValueCtl     = (char*)RSA_PrivKeyCtl;
      ValueErrCode  = ASN1_ENC_PRIV_KEY_RSA_VAL_ERR;

      TotalCnt      = RSA_ALG_PAR_MAX_INDEX + RSA_PRIV_KEY_MAX_INDEX;
      break;

    case DSA_PUBLIC_ALGOR:
      AlgorOIDIndex = OID_X957_DSA_SIGNAT_ALGOR;

      ParamCtlCnt   = DSA_PUB_ALG_CTL_CNT;
      pParamCtl     = (char*)DSA_AlgorParamsCtl;
      ParamErrCode  = ASN1_ENC_PRIV_KEY_DSA_PAR_ERR;

      ValueIndex    = DSA_ALG_PAR_MAX_INDEX;
      ValueCtlCnt   = DSA_PRIV_KEY_CTL_CNT;
      pValueCtl     = (char*)DSA_PrivKeyCtl;
      ValueErrCode  = ASN1_ENC_PRIV_KEY_DSA_VAL_ERR;

      TotalCnt      = DSA_ALG_PAR_MAX_INDEX + DSA_PRIV_KEY_MAX_INDEX;
      break;

    case DH_PUBLIC_ALGOR:
      AlgorOIDIndex = OID_X942_DH_PUBL_NUMBER;

      ParamCtlCnt   = DH_PUB_ALG_CTL_CNT;
      pParamCtl     = (char*)DH_AlgorParamsCtl;
      ParamErrCode  = ASN1_ENC_PRIV_KEY_DH_PAR_ERR;

      ValueIndex    = DH_ALG_PAR_MAX_INDEX;
      ValueCtlCnt   = DH_PRIV_KEY_CTL_CNT;
      pValueCtl     = (char*)DH_PrivKeyCtl;
      ValueErrCode  = ASN1_ENC_PRIV_KEY_DH_VAL_ERR;

      TotalCnt      = DH_ALG_PAR_MAX_INDEX + DH_PRIV_KEY_MAX_INDEX;
      break;

    default:
      return(ASN1_ENC_PRIV_KEY_UNKNOWN_ALGOR);
  }
  //--------------------------------------------------------
  // Check if necessarey Data Count presented...
  //--------------------------------------------------------
  if(ElementCnt != TotalCnt)
    return(ASN1_ENC_PRIV_KEY_INV_DATA);
  for(;;)						// Error FOR
  {
    //-------------------------------------------------------
    // generate the private key sequence from key data
    //-------------------------------------------------------
    i = ToASN1(HMEM_CTX_REF1 SrcDatArray,ValueIndex,pValueCtl,ValueCtlCnt,pTmpBuf,pTmpLen);
    if(i != ASN1_OP_OK)
    {
      Retcode = ValueErrCode;
      break;
    }
    pKeyBuf   = pTmpBuf[0];
    KeyBufLen = pTmpLen[0];
    //--------------------------------------------------------
    // Allocate Data Array for Version, OID, Params and KeyData
    //--------------------------------------------------------
    i = AllocIDATPARR_Struc(HMEM_CTX_REF1 pTmpArrayDesc,PKCS8_KEY_MAX_DATA_INDEX);
    if(i != ASN1_OP_OK)
    {
      Retcode = ASN1_ENC_PRIV_KEY_ARR_ALLOC_ERR;
      break;
    }
    DatArrayDesc = pTmpArrayDesc[0];
    DatArray = DatArrayDesc->ppArr;
    DatArrayDesc->Flags |= FREE_BIT_MASK;
    //--------------------------------------------------------
    // Generate the Version Entry (1st entry)
    //--------------------------------------------------------
    i = FromBufToDatArray(HMEM_CTX_REF1 DatArrayDesc->ppArr,PKCS8_VERSION_INDEX,KeyInfoVersion,0,1,1);
    if(i != ASN1_OP_OK)
    {
      Retcode = ASN1_ENC_PRIV_KEY_VERS_GEN_ERR;
      break;
    }
    //--------------------------------------------------------
    // Generate the OID Entry (2nd entry)
    //--------------------------------------------------------
    i = GenOIDIdataEntry(HMEM_CTX_REF1 AlgorOIDIndex,PKCS8_KEY_ALGOR_INDEX,DatArray);
    if(i != ASN1_OP_OK)
    {
      Retcode = ASN1_ENC_PRIV_KEY_OID_GEN_ERR;
      break;
    }
    //---------------------------------------------------------------
    // Generate the Algor Param Buffer, put to descriptor (3rd entry)
    //---------------------------------------------------------------
    i = ToASN1(HMEM_CTX_REF1 SrcDatArray,0,pParamCtl,ParamCtlCnt,pTmpBuf,pTmpLen);
    if(i != ASN1_OP_OK)
    {
      Retcode = ParamErrCode;
      break;
    }
    pParamBuf = pTmpBuf[0];			// save in case of error !

    i = FromBufToDesc(HMEM_CTX_REF1 pTmpBuf[0],0,pTmpLen[0],PKCS8_KEY_ALG_PAR_INDEX,0,pTmpArrayDesc);
    if(i != ASN1_OP_OK)
    {
      Retcode = ParamErrCode;
      break;
    }
    pParamBuf = NULL;				// buffer has been transfered
    //-----------------------------------------------------
    // Put the Private Key Buffer to Descriptor (4th Entry)
    //-----------------------------------------------------
    i = FromBufToDesc(HMEM_CTX_REF1 pKeyBuf,0,KeyBufLen,PKCS8_KEY_VALUE_INDEX,0,pTmpArrayDesc);
    if(i != ASN1_OP_OK)
    {
      Retcode = ASN1_ENC_PRIV_KEY_KEY_COPY_ERR;
      break;
    }
    pKeyBuf = NULL;				// buffer transferred
    //-----------------------------------------------------
    // Convert the descriptor to buffer
    //-----------------------------------------------------
						// Start at Index 0
    i = ToASN1(HMEM_CTX_REF1 DatArray,0,(char *) PKCS8_PrivKeyInfoCtl,PKCS8_PRIV_KEY_INFO_CTL_CNT,pTmpBuf,pTmpLen);
    if(i != ASN1_OP_OK)
    {
      Retcode = ASN1_ENC_PRIV_KEY_INF_GEN_ERR;
      break;
    }
    break;
  } // Error FOR
  FREE_ARRAY(HMEM_CTX_REF,pKeyBuf);
  FREE_ARRAY(HMEM_CTX_REF,pParamBuf);
  FreeIDATPARR_Struc(HMEM_CTX_REF1 DatArrayDesc);
  if(Retcode != ASN1_OP_OK)
    return(Retcode);
  pDstBuf[0] = pTmpBuf[0];
  pDstLen[0] = pTmpLen[0];
  return(Retcode);
}

/**
* Generates the PKCS8 private key element, encrypts it according to PKCS5, 
* writes it into a new buffer and puts it in the data array (SetIBMContainerPrivKey).
*
*  @param DatArray Array of pointers to <code>IDATA</code> structures
*  @param IndexOffset Start index to add to data array
*  @param rsa Pointer to structure for RSA/NULL
*  @param dsa Pointer to structure for DSA/NULL
*  @param dh Pointer to structure for DH/NULL
*  @param Passwd Buffer with password data
*  @param PasswdLen Length of password
*  @param PubAlgorType Algorithm to use
*  @param IteratCount Number of PCKS5 encryption iterations
*  @param HashType PKCS5 hash type: 0 == MD2, <> 0 MD5
*
*  @return ASN1_OP_OK on success, error code otherwise
*/
extern "C"  int  SetIBMContainerPrivKey(HMEM_CTX_DEF
		IDATA** DatArray,
		int IndexOffset,
		RSA_STRUC* rsa, DSA_STRUC* dsa, DH_STRUC* dh,
		char* Passwd, int PasswdLen, int PubAlgorType,
		int IteratCount, int HashType)
{
  int i;
  int Retcode=ASN1_OP_OK;
  int KeyInfoLen;
  int ElementCnt=0;

  char* pKeyInfoMem = NULL;

  char* pTmpBuf[1];

  int pTmpLen[1];

  IDATPARR* DatArrayDesc = NULL;

  IDATPARR* pTmpArrayDesc[1];
  //-----------------------------------------------------------
  // check parameters
  //-----------------------------------------------------------
  if((DatArray == NULL) || (Passwd == NULL))
    return(ASN1_TO_CONT_PRIVKEY_NULPTR_ERR);
  if((PubAlgorType != RSA_PUBLIC_ALGOR) &&
     (PubAlgorType != DSA_PUBLIC_ALGOR) &&
     (PubAlgorType != DH_PUBLIC_ALGOR))
    return(ASN1_TO_CONT_PRIVKEY_INVALG_ERR);
  //-----------------------------------------------------------
  // Preset Params, Generate the Descriptor array from the structure
  //-----------------------------------------------------------
  switch(PubAlgorType)
  {
    case RSA_PUBLIC_ALGOR:
      if(rsa == NULL) return(ASN1_TO_CONT_PRIVKEY_NULPTR_ERR);
      ElementCnt = RSA_ALG_PAR_MAX_INDEX+RSA_PRIV_KEY_MAX_INDEX;
      Retcode = FromRSAPrivParamsToArrayDesc(HMEM_CTX_REF1
					     rsa,pTmpArrayDesc);
      break;

    case DSA_PUBLIC_ALGOR:
      if(dsa == NULL) return(ASN1_TO_CONT_PRIVKEY_NULPTR_ERR);
      ElementCnt = DSA_ALG_PAR_MAX_INDEX+DSA_PRIV_KEY_MAX_INDEX;
      Retcode = FromDSAPrivParamsToArrayDesc(HMEM_CTX_REF1
					     dsa,pTmpArrayDesc);
      break;

    case DH_PUBLIC_ALGOR:
      if(dh == NULL) return(ASN1_TO_CONT_PRIVKEY_NULPTR_ERR);
      ElementCnt = DH_ALG_PAR_MAX_INDEX+DH_PRIV_KEY_MAX_INDEX;
      Retcode = FromDHPrivParamsToArrayDesc(HMEM_CTX_REF1
					    dh,pTmpArrayDesc);
      break;
  }
  if(Retcode != ASN1_OP_OK) return(Retcode);
  DatArrayDesc = pTmpArrayDesc[0];
  //-----------------------------------------------------------
  // Generate PKCS8 formatted Private Key Info Structure
  //-----------------------------------------------------------
  Retcode = SubEncodePrivKeyInfo(HMEM_CTX_REF1
			DatArrayDesc->ppArr, ElementCnt,
			PubAlgorType,pTmpBuf,pTmpLen);
//  FREE_IDATPARR_STRUC(HASN1inst,HMEM_CTX_REF,DatArrayDesc);
  if(Retcode != ASN1_OP_OK) return(Retcode);
  pKeyInfoMem = pTmpBuf[0];
  KeyInfoLen  = pTmpLen[0];
  //-----------------------------------------------------------
  // PKCS5 Encrypt PKCS8 formatted Private Key Info Structure
  //-----------------------------------------------------------
  i = EncryptPrivateKey(HMEM_CTX_REF1 pKeyInfoMem,0,KeyInfoLen,Passwd,PasswdLen,IteratCount,HashType,NULL,pTmpBuf,pTmpLen);
  FREE_ARRAY(HMEM_CTX_REF,pKeyInfoMem);
  if(i != PKCS5_OP_OK)
    return(ASN1_TO_CONT_PRIVKEY_ENCR_ERR);
  pKeyInfoMem = pTmpBuf[0];
  KeyInfoLen  = pTmpLen[0];
  //-----------------------------------------------------------
  // Put to Container Descriptor Index (direct set, no copy)
  //-----------------------------------------------------------
  Retcode = FromBufToDatArray(HMEM_CTX_REF1 DatArray,IBM_PRIV_KEY_INFO_INDEX+IndexOffset,pKeyInfoMem,0,KeyInfoLen,0);
  if(Retcode == ASN1_OP_OK)
    return(Retcode);
  FREE_ARRAY(HMEM_CTX_REF,pKeyInfoMem);
  return(Retcode);
}

/**
* Generates an ASN.1 encoded certificate request, standard certificate or 
* server certificate container (GenIbmContainer).
*
* The container made from the following elements:
* <ol>
* <li> Ordinal number
* <li> ASN.1 encoded certificate request / certificate
* <li> Private key if certificate request or server certificate
* <li> Container name
* <li> Flags
* </ol>
*
* The buffer for the container is newly allocated.
*
*  @param SrcBuf Buffer containing ASN.1 encoded certificate or certificate
*                 request data
*  @param SrcOff Start offset of source data
*  @param SrcLen Source data length
*  @param ContainerType Type of container to generate: <br>
*                 0 - Certificate req. (with key) <br>
*                 1 - Standard certificate <br>
*                 2 - Server cert. (with key)
*  @param OrdinalNumber Number for container
*  @param RsaStruc Pointer to RSA key structure/NULL
*  @param DsaStruc Pointer to DSA key structure/NULL
*  @param DhStruc Pointer to DH key structure/NULL
*  @param Passwd Buffer with password data
*  @param PasswdLen Length of password
*  @param PubAlgorType Public algorithm to use
*  @param IteratCount PKCS5 iteration count to use
*  @param HashType PKCS5 hash to use
*  @param ContainerName Buffer with name to attach to container
*  @param ContNameLen Length of the name
*  @param Flags Flags to set
*  @param UsedBits Number of bits used in flags (from LSB)
*  @param pDstBuf Pointer where to store destination buffer
*  @param pDstLen Length of generated container data
*
*  @return ASN1_OP_OK on success, error code otherwise
*/
extern "C"  int  GenIbmContainer(HMEM_CTX_DEF
	char* SrcBuf, int SrcOff, int SrcLen,
	int ContainerType, int OrdinalNumber,
	RSA_STRUC* RsaStruc, DSA_STRUC* DsaStruc, DH_STRUC* DhStruc,
	char* Passwd, int PasswdLen, int PubAlgorType,
	int IteratCount, int HashType, char* ContainerName,
	int ContNameLen, int Flags, int UsedBits,
	char** pDstBuf, int* pDstLen)
{

  char* pMem;

  int Retcode;

  IDATA* pIdata;

  IDATA** DatArray;
  IDATPARR* DatArrayDesc = NULL;
  IDATPARR* pTmpDatArrayDesc[1];

  //-------------------------------------------------------
  // Get Array for Container Construction, mark as freeable
  //-------------------------------------------------------
  Retcode = AllocIDATPARR_Struc(HMEM_CTX_REF1 pTmpDatArrayDesc,IBM_CONTAINER_MAX_DATA_INDEX);
  if(Retcode != ASN1_OP_OK) return(Retcode);
  DatArrayDesc = pTmpDatArrayDesc[0];
  DatArrayDesc->Flags |= FREE_BIT_MASK;  
  DatArray = DatArrayDesc->ppArr;
  for(;;)
  {
    //-------------------------------------------------------
    // Set the Ordinal number
    //-------------------------------------------------------
    Retcode = SetIBMContainerOrdinal(HMEM_CTX_REF1 DatArray,0,OrdinalNumber);
    if(Retcode != ASN1_OP_OK) break;
    //-------------------------------------------------------
    // Set Certificate Request / Certificate
    //-------------------------------------------------------
    Retcode = SetIBMContainerCertOrReq(HMEM_CTX_REF1 DatArray,0,SrcBuf,SrcOff,SrcLen,ContainerType);
    if(Retcode != ASN1_OP_OK) break;
    //-------------------------------------------------------
    // Set Private Key if Cert. Request or Server Cert.
    //-------------------------------------------------------
    if((ContainerType == 0) || (ContainerType == 2))
    {
//      PRINT("\nSetting Private Key");
      Retcode = SetIBMContainerPrivKey(HMEM_CTX_REF1
		  DatArray,0,
		  RsaStruc,DsaStruc,DhStruc,
		  Passwd, PasswdLen, PubAlgorType, IteratCount,
		  HashType);
//      PRINT("\nSetting Private Key End");
      if(Retcode != ASN1_OP_OK) break;
    }
    //-------------------------------------------------------
    // Set Container Name
    //-------------------------------------------------------
//    PRINT("\nSetting Container Name");
    Retcode = SetIBMContainerName(HMEM_CTX_REF1 DatArray,0,ContainerName,ContNameLen);
//    PRINT("\nSetting Container Name End");
    if(Retcode != ASN1_OP_OK) break;
    //-------------------------------------------------------
    // Set Flags
    //-------------------------------------------------------
    Retcode = SetIBMContainerFlags(HMEM_CTX_REF1 DatArray,0,Flags,UsedBits);
    if(Retcode != ASN1_OP_OK) break;
    //-------------------------------------------------------
    // Set Unknown buffer to Zero length data
    //-------------------------------------------------------
    pMem = BIT8_ARRAY_ALLOC(HMEM_CTX_REF,1);	// allocate Dummy Array
    if(pMem == NULL)
    {
      Retcode = ASN1_TO_CONT_UNK_ALLOC_ERR;
      break;
    }
    pIdata = DatArray[IBM_UNKNOWN_INDEX];
    pIdata->Base = pMem;			// set Buffer Base
    pIdata->Len = 0;
    //-------------------------------------------------------
    // Generate the Container
    //-------------------------------------------------------
//    PRINT("\nBefore To Container");
    Retcode = ToIBMContainer(HMEM_CTX_REF1 DatArrayDesc,pDstBuf,pDstLen);
    DatArrayDesc = NULL;
//    PRINT("\nAfter To Container");
    break;
  } // Error For
  FreeIDATPARR_Struc(HMEM_CTX_REF1 DatArrayDesc);
  return(Retcode);
}

extern "C"  void  FreeCertReqStruc(HMEM_CTX_DEF
					 PKCS10_CERTREQ * CertReqStruc)
{
  //---------------------------------------------
  // Check for Base NULL pointer first
  //---------------------------------------------
  if(CertReqStruc == NULL) return;

  FreeIDATPARR_Struc(HMEM_CTX_REF1 CertReqStruc->CertificateRequest);
  FreeIDATPARR_Struc(HMEM_CTX_REF1 CertReqStruc->TBS_CertReqInfo);
  FreeIDATPARR_Struc(HMEM_CTX_REF1 CertReqStruc->CertReqSignature);
  FreeIDATPARR_Struc(HMEM_CTX_REF1 CertReqStruc->VersionNumber);
  FreeX501DN_Struc(HMEM_CTX_REF1 CertReqStruc->Subject);
  FreeIDATPARR_Struc(HMEM_CTX_REF1 CertReqStruc->SubjPubKeyParVal);
  FreeIDATPARR_Struc(HMEM_CTX_REF1 CertReqStruc->Attributes);
  FreeIDATPARR_Struc(HMEM_CTX_REF1 CertReqStruc->PrivKeyData);
  FreeIDATPARR_Struc(HMEM_CTX_REF1 CertReqStruc->PEMTextData);
}


extern "C"  int  AllocCertReqStruc(HMEM_CTX_DEF
					 PKCS10_CERTREQ ** pCertReqStruc)
{
  int Retcode = ASN1_CERTREQ_ELEM_ALLOC_ERR;

  IDATPARR* pIdatapArray[1];
  PKCS10_CERTREQ * CertReq;

  if(pCertReqStruc == NULL) return(ASN1_CERTREQ_ALLOC_NULL_PTR_ERR);
  pCertReqStruc[0] = NULL;
  //-----------------------------------------------
  // Allocate the Certificate Request Structure
  //-----------------------------------------------
  CertReq = (PKCS10_CERTREQ *) BIT8_ARRAY_CALLOC(HMEM_CTX_REF,
				1,sizeof(PKCS10_CERTREQ));
  if(CertReq == NULL)
    return(ASN1_CERTREQ_ALLOC_ERR);
  //-----------------------------------------------
  // Initialize structure, not specified means init as 0
  //-----------------------------------------------

  CertReq->SignatAlgor   = INVALID_ALGOR;
  CertReq->SignatType    = INVALID_ALGOR;
  CertReq->PublicKeyType    = INVALID_ALGOR;
  CertReq->PrivKeyType   = INVALID_ALGOR;

  //-----------------------------------------------
  // Allocate the Element Descriptors
  //-----------------------------------------------
  for(;;)
  {
    if(AllocIDATPARR_Struc(HMEM_CTX_REF1 pIdatapArray,1) != ASN1_OP_OK)
      break;
    CertReq->CertificateRequest = pIdatapArray[0];

    if(AllocIDATPARR_Struc(HMEM_CTX_REF1 pIdatapArray,1) != ASN1_OP_OK)
      break;
    CertReq->TBS_CertReqInfo       = pIdatapArray[0];

    if(AllocIDATPARR_Struc(HMEM_CTX_REF1 pIdatapArray,1) != ASN1_OP_OK)
      break;
    CertReq->CertReqSignature        = pIdatapArray[0];

    if(AllocIDATPARR_Struc(HMEM_CTX_REF1 pIdatapArray,1) != ASN1_OP_OK)
      break;
    CertReq->VersionNumber       = pIdatapArray[0];

    if(AllocIDATPARR_Struc(HMEM_CTX_REF1 pIdatapArray,1) != ASN1_OP_OK)
      break;
    CertReq->Attributes    = pIdatapArray[0];

    Retcode = ASN1_OP_OK;
    break;
  } // Error FOR
  pCertReqStruc[0] = CertReq;
  if(Retcode != ASN1_OP_OK)
  {
    FreeCertReqStruc(HMEM_CTX_REF1 CertReq);
    FREE_CARRAY(HMEM_CTX_REF,CertReq); 
    pCertReqStruc[0] = NULL;
  }
  return(Retcode);
}
/**
* Verifies the signature of 
* a certificate request and sets verified flag, if successfull (VerifyCertReqSignat).
*
*  @param pCertReq Certificate request to verify
*  @param pPubParVals Public params/values to use
*  @param PubAlgType Type of public algorithm
*  @param Result Result of verify
*
*  @return ASN1_OP_OK on success, error code otherwise
*/
extern "C"  int  VerifyCertReqSignat(HMEM_CTX_DEF
			PKCS10_CERTREQ * pCertReq,
			IDATPARR* pPubParVals, int PubAlgType,
			int* Result)
{
  int i;
  int Retcode = ASN1_OP_OK;
  int SignatAlgor;
  int SignatType;

  int SignatOffset;
  int SignatLen;

  int MessageOffset;
  int MessageLen;

  char* SignatBase;
  char* MessageBase;

  IDATA** DatArray;

  IDATA* pIdata;

  RSA_STRUC* pRsaStruc[1];
  DSA_STRUC* pDsaStruc[1];

  int pTmpLen[1];

  //------------------------------------------------
  // Check for NULL pointers
  //------------------------------------------------
  if((pCertReq == NULL) || (pPubParVals == NULL) || (Result == NULL))
    return(ASN1_VFY_CERTREQ_NULL_PTR_ERR);

  Result[0] = ASN1_SIGNAT_VERIFY_FAILED;	// not verified
  //------------------------------------------------
  // Check if Signature Algor and Public Algor match
  //------------------------------------------------
  SignatAlgor = pCertReq->SignatAlgor;	// get the Algor type  
  SignatType  = pCertReq->SignatType;	// get Signature mode
  if(PubAlgType != SignatAlgor)
    return(ASN1_VFY_CERTREQ_ALGOR_MISMATCH);	// error

  DatArray = pCertReq->CertReqSignature->ppArr;
  pIdata = DatArray[0];
  SignatBase   = pIdata->Base;
  SignatOffset = (int) pIdata->Off;
  SignatLen    = pIdata->Len;

  DatArray = pCertReq->TBS_CertReqInfo->ppArr;
  pIdata = DatArray[0];
  MessageBase   = pIdata->Base;
  MessageOffset = (int) pIdata->Off;
  MessageLen    = pIdata->Len;

  //------------------------------------------------
  // Distribute according to signature Algorithm
  //------------------------------------------------
  switch(SignatAlgor)
  {
    case RSA_PUBLIC_ALGOR:
      Retcode = FromArrayDescToRSAPubParams(HMEM_CTX_REF1 pPubParVals,pRsaStruc);
      if(Retcode != ASN1_OP_OK) return(ASN1_VFY_CRTRQ_RSASTRU_LOAD_ERR);

      pTmpLen[0] = SignatLen;
      i = RSA_sign(HMEM_CTX_REF1 SignatType,MessageBase,MessageOffset,MessageLen,SignatBase,SignatOffset,pTmpLen,pRsaStruc[0],1);
      RSA_Free(HMEM_CTX_REF1 pRsaStruc[0]);
      if(i != RSA_OP_OK) return(ASN1_VFY_CERTREQ_RSA_SIGNAT_ERR);
      break;

    case DSA_PUBLIC_ALGOR:
      Retcode = FromArrayDescToDSAPubParams(HMEM_CTX_REF1 pPubParVals,pDsaStruc);
      if(Retcode != ASN1_OP_OK) return(ASN1_VFY_CRTRQ_DSASTRU_LOAD_ERR);
      i = DSA_Verify(HMEM_CTX_REF1 MessageBase,MessageOffset,MessageLen,SignatBase,SignatOffset,SignatLen,pDsaStruc[0],0);
      DSA_Free(HMEM_CTX_REF1 pDsaStruc[0]);
      if(i != DSA_OP_OK) return(ASN1_VFY_CERTREQ_DSA_SIGNAT_ERR);
      break;            

    default:
      return(ASN1_VFY_CERTREQ_INV_ALGOR_ERR);
  } // switch
  Result[0] = ASN1_SIGNAT_VFY_OK;		// verified
  pCertReq->Flags |= VERIFIED_SIGNAT_MASK;
  return(ASN1_OP_OK);            
}

extern "C"  int  FromASN1CertReqToCertReqStruc(HMEM_CTX_DEF
		char* SrcBuf, int SrcOffset, int SrcLen,
		int CertReqType, int SortFlag, char* Pwd, int PwdLen,
		PKCS10_CERTREQ ** pCertReqStruc)
{
  int Retcode;
  int SignatAlgor;
  int SignatType;
  int Index1;
  int Index2;
  int Len;
  int CertReqLen;
  int CertReqOffset;

  PKCS10_CERTREQ * pCertReq[1];
  PKCS10_CERTREQ * CertReq;

  char* pBuf;
  char* pCertReqBuf;
  char* pPrivKeyBuf = NULL;

  IDATPARR* pTmpDatArrayDesc[1];

  IDATPARR* IBMContainerDatArrayDesc  = NULL;
  IDATPARR* CertReqStrucDatArrayDesc  = NULL;
  IDATPARR* CertReqDatArrayDesc 	 = NULL;
  IDATPARR* TbsDatArrayDesc 		 = NULL;
  IDATPARR* AttribDatArrayDesc 	 = NULL;

  IDATA** IBMContainerDatArray = NULL;
  IDATA** CertReqDatArray;
  IDATA** TbsDatArray;

  X501_DN* pSubjectNameDesc = NULL;
  X501_DN* pTmpNameDesc[1];

  IDATA* pIdata;

  int pTmpDat[1];
  int pTmpDat1[1];
  int pSubErrCode[1];

  char* pTmpBase[1];
  int pTmpOff[1];
  int pTmpLen[1];
  int pTmpLong[1];

  //----------------------------------------------
  // 0. Do some checks first
  //----------------------------------------------
  if((SrcBuf == NULL) || (pCertReqStruc == NULL))
    return(ASN1_CERTREQ_TO_STRU_NULPTR_ERR);
  pCertReqStruc[0] = NULL;
  if(SrcLen <= 0) return(ASN1_CERTREQ_TO_STRUC_NO_DATA);
  //----------------------------------------------
  // 1. Allocate the structure and the Descriptors
  //----------------------------------------------
  Retcode = AllocCertReqStruc(HMEM_CTX_REF1 pCertReq);
  if(Retcode != ASN1_OP_OK) return(Retcode);
  CertReq = pCertReq[0];

  CertReqLen = SrcLen;					// Assume Standard
  CertReqOffset = SrcOffset;
  pCertReqBuf  = SrcBuf;
  for(;;)						// Error FOR
  {
    //--------------------------------------------------------------
    // 2a. Check if an IBM Enveloped Certificate is given
    //--------------------------------------------------------------
    if((CertReqType == SERVER_CERT) ||			// special processing
       (CertReqType == CLIENT_CERT))
    {
      //------------------------------------------------------------
      // Split IBM Container
      //------------------------------------------------------------
      Retcode = FromASN1_IBMContainer(HMEM_CTX_REF1 SrcBuf,SrcOffset,SrcLen,pTmpDatArrayDesc,pTmpDat,pSubErrCode);
      if(Retcode != ASN1_OP_OK) break;
      IBMContainerDatArrayDesc = pTmpDatArrayDesc[0];
      IBMContainerDatArray = IBMContainerDatArrayDesc->ppArr;
      //------------------------------------------------------------
      // get Certificate Request base pointer according to requested type
      //------------------------------------------------------------
      pIdata = IBMContainerDatArray[IBM_REQ_CERT_DATA_INDEX];// assume with key
      if(pIdata == NULL)				// not with key
      {
        Retcode = ASN1_CERTREQ_TO_STRUC_NO_KEY;
        break;
      }
      pCertReqBuf   = pIdata->Base;
      CertReqOffset = (int) pIdata->Off;
      CertReqLen    = pIdata->Len;
      if(pCertReqBuf == NULL)
      {
        Retcode = ASN1_CERTREQ_TO_STRUC_NO_CRTREQ;
        break;
      }
    }
    //----------------------------------------------
    // 2b. allocate a buffer for the Raw Certificate Request
    //     copy to buffer and insert into Descriptor
    //----------------------------------------------
    CertReqStrucDatArrayDesc = CertReq->CertificateRequest;
    pIdata = CertReqStrucDatArrayDesc->ppArr[0];
    pBuf = BIT8_ARRAY_ALLOC(HMEM_CTX_REF,CertReqLen);
    if(pBuf == NULL)
    {
      Retcode = ASN1_CERTREQ_TO_STRUC_ALLOC_ERR;
      break;
    }
    Index1 = 0;
    Index2 = CertReqOffset;
    Len = CertReqLen;
    do{pBuf[Index1++] = pCertReqBuf[Index2++];Len--;}while(Len != 0);

    pIdata->Base = pBuf;
    pIdata->Off  = 0;
    pIdata->Len  = CertReqLen;
    CertReqStrucDatArrayDesc->Flags |= FREE_BIT_MASK;
    //----------------------------------------------
    // 3.   Do Splitting the components
    // 3.1. Split the Certificate in TBS-Cert Request, SignatAlgor,
    //      SignatAlgParams and Signature
    //--------------------------------------------------
    Retcode = FromASN1_CertReq(HMEM_CTX_REF1
			       pBuf,0,CertReqLen,
			       pTmpDatArrayDesc, pSubErrCode);
    if(Retcode != ASN1_OP_OK) break;
    CertReqDatArrayDesc = pTmpDatArrayDesc[0];
    CertReqDatArray = CertReqDatArrayDesc->ppArr;
    //--------------------------------------------------
    // 3.2. Load components into the structure Descriptors
    // NOTE: Signature Algor/Params are verified/loaded later
    //--------------------------------------------------
    CopyIdataContents(CertReq->TBS_CertReqInfo->ppArr[0],CertReqDatArray[CERT_REQ_INFO_INDEX]);
    //--------------------------------------------------
    // 3.3.  Split TBS Certificate Request into Pieces
    // 3.3.1 Get Buffer base, offset and length of TBS Cert Request
    // 3.3.2 Split the TBS Cert Request
    //--------------------------------------------------
    FromDescToBuf(CertReq->TBS_CertReqInfo,0,pTmpBase,pTmpOff,pTmpLen);
    Retcode = FromASN1_TBSCertReqInfo(HMEM_CTX_REF1
				      pTmpBase[0],pTmpOff[0],pTmpLen[0],
			              pTmpDatArrayDesc, pSubErrCode);
    if(Retcode != ASN1_OP_OK) break;
    TbsDatArrayDesc = pTmpDatArrayDesc[0];
    TbsDatArray = TbsDatArrayDesc->ppArr;
    //------------------------------------------------------
    // 3.3.3. Load components into the structure Descriptors
    //------------------------------------------------------
    CopyIdataContents(CertReq->VersionNumber->ppArr[0],TbsDatArray[TBS_CERT_REQ_VERSION_INDEX]);
    //------------------------------------------------------------------
    // 3.4. Get/Check the Signature Algor and Params from CertReq
    //------------------------------------------------------------------
    Retcode = GetChkSignatTypeAlg(HMEM_CTX_REF1 CertReqDatArray[CERT_REQ_SIGNAT_ALGOR_ID_INDEX],CertReqDatArray[CERT_REQ_SIGNAT_ALGOR_PAR_INDEX],pTmpDat,pTmpDat1);
    if(Retcode != ASN1_OP_OK) break;
    SignatAlgor = pTmpDat[0];
    SignatType  = pTmpDat1[0]; 
    //------------------------------------------------------------------
    // 3.6. Subdecode the Signature
    //------------------------------------------------------------------
    Retcode = SubDecodeSignature(HMEM_CTX_REF1 CertReqDatArray[CERT_REQ_SIGNAT_DATA_INDEX],SignatAlgor,pTmpDatArrayDesc);
    if(Retcode != ASN1_OP_OK) break;
    CertReq->SignatAlgor = SignatAlgor;
    CertReq->SignatType  = SignatType;
    CertReq->CertReqSignature      = pTmpDatArrayDesc[0];
    //------------------------------------------------------------------
    // 3.7. Subdecode/Check Public Key, Params and values
    //------------------------------------------------------------------
    Retcode = SubDecodePubKeyInfo(HMEM_CTX_REF1 
                                  TbsDatArray[TBS_CERT_REQ_PUB_ALGOR_ID_INDEX],
                                  TbsDatArray[TBS_CERT_REQ_PUB_ALG_PAR_INDEX],
                                  TbsDatArray[TBS_CERT_REQ_PUBLIC_DATA_INDEX],
                                  pTmpDatArrayDesc,pTmpDat);
    if(Retcode != ASN1_OP_OK) break;
    CertReq->SubjPubKeyParVal = pTmpDatArrayDesc[0];
    CertReq->PublicKeyType      = pTmpDat[0];
    //------------------------------------------------------------------
    // 3.9. Subdecode Subject RDN, sort by OBJIDs
    //------------------------------------------------------------------
    FromDatArrayToBuf(TbsDatArray,TBS_CERT_REQ_SUBJECT_RDN_INDEX,pTmpBase,pTmpOff,pTmpLen);
    if((pTmpBase[0] != NULL) && (pTmpLen[0] != 0))
    {
      Retcode = FromASN1_DN(HMEM_CTX_REF1 pTmpBase[0],pTmpOff[0],pTmpLen[0],pTmpNameDesc);
      if(Retcode != ASN1_OP_OK) break;
      pSubjectNameDesc = pTmpNameDesc[0];
//      SubjectDatArray = IDATPARR_ppArr(SubjectDatArrayDesc);

      if(SortFlag == 0)
      {

	Retcode = SortASN1_DN(pSubjectNameDesc);
        if(Retcode != ASN1_OP_OK) break;
      }
    }
    CertReq->Subject = pSubjectNameDesc;
    pSubjectNameDesc = NULL;
    //------------------------------------------------------------------
    // 4. Check if a Server Certificate was processed
    //------------------------------------------------------------------
    if(CertReqType == SERVER_CERT)
    {
      //------------------------------------------------------
      // 4.1. Decrypt the private key
      //------------------------------------------------------
      pIdata = IBMContainerDatArray[IBM_PRIV_KEY_INFO_INDEX];
      if(pIdata == NULL)
      {
        Retcode = ASN1_CRTREQ_TO_STRUC_NO_PRIVKEY;
        break;
      }
      pBuf   = pIdata->Base;
      Index1 = (int) pIdata->Off;
      Len    = pIdata->Len;
      Index2 =  DecryptPrivateKey(HMEM_CTX_REF1 pBuf,Index1,Len,Pwd,PwdLen,pTmpBase,pTmpLen,NULL,NULL);
      if(Index2 != PKCS5_OP_OK)
      {
        Retcode = ASN1_CRTREQ_TO_STRUC_PRIVKY_ERR;
        break;
      }
      pPrivKeyBuf = pTmpBase[0];
      //------------------------------------------------------
      // 4.2. Subdecode the PKCS-8 encoded Private key
      //      NOTE: an explizit copy of the parameters is done !
      //------------------------------------------------------
      Retcode = SubDecodeCopyPrivKeyInfo(HMEM_CTX_REF1 pPrivKeyBuf,0,pTmpLen[0],pTmpDat,pTmpLong,pTmpDatArrayDesc);
      if(Retcode != ASN1_OP_OK) break;
      CertReq->PrivKeyType = pTmpDat[0];
      CertReq->PrivKeyData = pTmpDatArrayDesc[0];
    }
    break;
  } // Error FOR
  //----------------------------------------------------------
  // now we free the temporary allocated descriptors
  //----------------------------------------------------------
  if(IBMContainerDatArrayDesc != NULL)
     FreeIDATPARR_Struc(HMEM_CTX_REF1 IBMContainerDatArrayDesc);
  if(CertReqDatArrayDesc != NULL)
     FreeIDATPARR_Struc(HMEM_CTX_REF1 CertReqDatArrayDesc);
  if(TbsDatArrayDesc != NULL)
     FreeIDATPARR_Struc(HMEM_CTX_REF1 TbsDatArrayDesc);
  if(pSubjectNameDesc != NULL)
    FreeX501DN_Struc(HMEM_CTX_REF1 pSubjectNameDesc);
  if(AttribDatArrayDesc != NULL)
    FreeIDATPARR_Struc(HMEM_CTX_REF1 AttribDatArrayDesc);
  pCertReqStruc[0] = CertReq;
  if(Retcode == ASN1_OP_OK) return(Retcode);
  pCertReqStruc[0] = NULL;
  FreeCertReqStruc(HMEM_CTX_REF1 CertReq);
  FREE_CARRAY(HMEM_CTX_REF,pPrivKeyBuf);
  return(Retcode);
}

extern "C"  int  FromCertStrucToASN1Cert(HMEM_CTX_DEF
	X509CERT * CertStruc,
	int CertType, int OrdinalNumber,
	RSA_STRUC* RsaSignStruc, DSA_STRUC* DsaSignStruc,
	char* Pwd, int PwdLen,
        int IteratCount, int HashType,
	char* ContainerName, int ContNameLen,
	int Flags, int UsedBits,
	char** pDstBuf, int* pDstLen)
{
  int Retcode;
  int TBSCertLen;
  int CertLen;

  char* pCertBuf = NULL;
  char* pTBSCertBuf = NULL;

  IDATPARR* pTmpDatArrayDesc[1];

  IDATPARR* TBSDatArrayDesc = NULL;

  IDATA** TBSDatArray;

  int pSubErrCode[1];

  char* pTmpBuf[1];
  char* pTmpBufHlp[1];

  int pTmpLen[1];

  RSA_STRUC* pTmpRsaStruc[1] = {NULL};
  DSA_STRUC* pTmpDsaStruc[1] = {NULL};
  DH_STRUC* pTmpDhStruc[1] = {NULL};
  //----------------------------------------------
  // 0. Do some checks first
  //----------------------------------------------
  if((CertStruc == NULL) || (pDstBuf == NULL) || (pDstLen == NULL))
    return(ASN1_STRUC_TO_CERT_NULPTR_ERR);

  pDstBuf[0] = NULL;
  for(;;) // Error FOR
  {
    //--------------------------------------------------------------
    // 1. Allocate the Data-Array for the TBS Certificate formatting
    //--------------------------------------------------------------
    Retcode = AllocIDATPARR_Struc(HMEM_CTX_REF1 pTmpDatArrayDesc,X509_TBS_CERT_MAX_DATA_INDEX);
    if(Retcode != ASN1_OP_OK) break;
    TBSDatArrayDesc = pTmpDatArrayDesc[0];		// get descriptor
    TBSDatArrayDesc->Flags |= FREE_BIT_MASK;	// mark freeable
    TBSDatArray = TBSDatArrayDesc->ppArr;
    //--------------------------------------------------------------
    // 2. Copy simple types
    //--------------------------------------------------------------
    Retcode = AllocCopyDatArrayToDatArray(HMEM_CTX_REF1 CertStruc->Version,0,TBSDatArrayDesc,X509_VERSION_INDEX,1,1);
    if(Retcode != ASN1_OP_OK) break;

    Retcode = AllocCopyDatArrayToDatArray(HMEM_CTX_REF1 CertStruc->SerialNumber,0,TBSDatArrayDesc,X509_SERIAL_INDEX,1,1);
    if(Retcode != ASN1_OP_OK) break;

    Retcode = AllocCopyDatArrayToDatArray(HMEM_CTX_REF1 CertStruc->NotBefore,0,TBSDatArrayDesc,X509_NOT_BEFORE_INDEX,1,1);
    if(Retcode != ASN1_OP_OK) break;

    Retcode = AllocCopyDatArrayToDatArray(HMEM_CTX_REF1 CertStruc->NotAfter,0,TBSDatArrayDesc,X509_NOT_AFTER_INDEX,1,1);
    if(Retcode != ASN1_OP_OK) break;

    Retcode = AllocCopyDatArrayToDatArray(HMEM_CTX_REF1 CertStruc->IssuerAltName,0,TBSDatArrayDesc,X509_ISSUER_UNIQUE_ID_INDEX,1,1);
    if(Retcode != ASN1_OP_OK) break;

    Retcode = AllocCopyDatArrayToDatArray(HMEM_CTX_REF1 CertStruc->SubjAltName,0,TBSDatArrayDesc,X509_SUBJECT_UNIQUE_ID_INDEX,1,1);
    if(Retcode != ASN1_OP_OK) break;
    //--------------------------------------------------------------
    // 3. Generate Signature Algor Field
    //--------------------------------------------------------------
    Retcode = SetTBSCertSignatAlgor(HMEM_CTX_REF1
			CertStruc->CertSignature->ppArr,0,
			TBSDatArray,X509_SIGNAT_ALGOR_ID_INDEX,
			CertStruc->SignatType);
    if(Retcode != ASN1_OP_OK) break;
    //--------------------------------------------------------------
    // 4. Generate Issuer RDN
    //--------------------------------------------------------------
    Retcode = ToASN1_DN(HMEM_CTX_REF1 CertStruc->Issuer,pTmpBuf,pTmpLen);
    if(Retcode != ASN1_OP_OK) break;

    // Wrap into an ASN.1 SEQUENCE
    Retcode = ToASN1_Sequence(HMEM_CTX_REF1 pTmpBuf[0],0,pTmpLen[0],pTmpBufHlp,pTmpLen);
    FREE_ARRAY(HMEM_CTX_REF,pTmpBuf[0]);		// release buffer
    if(Retcode != ASN1_OP_OK) break;

    Retcode = FromBufToDatArray(HMEM_CTX_REF1 TBSDatArray,X509_ISSUER_NAME_INDEX,pTmpBufHlp[0],0,pTmpLen[0],1);
    FREE_ARRAY(HMEM_CTX_REF,pTmpBufHlp[0]);		// release buffer
    if(Retcode != ASN1_OP_OK) break;
    //--------------------------------------------------------------
    // 5. Generate Subject RDN
    //--------------------------------------------------------------
    Retcode = ToASN1_DN(HMEM_CTX_REF1 CertStruc->Subject,pTmpBuf,pTmpLen);
    if(Retcode != ASN1_OP_OK) break;

    // Wrap into an ASN.1 SEQUENCE
    Retcode = ToASN1_Sequence(HMEM_CTX_REF1 pTmpBuf[0],0,pTmpLen[0],pTmpBufHlp,pTmpLen);
    FREE_ARRAY(HMEM_CTX_REF,pTmpBuf[0]);		// release buffer
    if(Retcode != ASN1_OP_OK) break;

    Retcode = FromBufToDatArray(HMEM_CTX_REF1 TBSDatArray,X509_SUBJECT_NAME_INDEX,pTmpBufHlp[0],0,pTmpLen[0],1);
    FREE_ARRAY(HMEM_CTX_REF,pTmpBufHlp[0]);		// release buffer
    if(Retcode != ASN1_OP_OK) break;
    //--------------------------------------------------------------
    // 6. Generate Public Algor fields
    //--------------------------------------------------------------
    Retcode = SetTBSCertSubjPubKeyInfo(HMEM_CTX_REF1
		TBSDatArray,0,
		CertStruc->SubjPubKeyParVal->ppArr, //Array Base
                CertStruc->SubjPubKeyParVal->Cnt,	// count
		CertStruc->PublicKeyType);			// type
    if(Retcode != ASN1_OP_OK) break;
    //--------------------------------------------------------------
    // 7.a. Generate Extensions if Version is V3 (!)
    //--------------------------------------------------------------
    if(CertStruc->VersionNumber == 2)		// is V3 (0 -> V1)
    {
      Retcode = GenCertX509Extensions(HMEM_CTX_REF1 CertStruc);
      if(Retcode != ASN1_OP_OK)
        break;
    }

    //--------------------------------------------------------------
    // 7.b. Add extensions if any present and Version is V3
    //--------------------------------------------------------------
    if((CertStruc->Extensions->ppArr[0]->Base != NULL) &&
       (CertStruc->VersionNumber == 2))
    {
      Retcode = ToASN1_EXT(HMEM_CTX_REF1
			   CertStruc->Extensions->ppArr,0,
			   CertStruc->Extensions->Cnt,
			   pTmpBuf,pTmpLen,pSubErrCode);
      if(Retcode != ASN1_OP_OK) break;

      Retcode = FromBufToDatArray(HMEM_CTX_REF1 TBSDatArray,X509_EXTENSION_DATA_INDEX,pTmpBuf[0],0,pTmpLen[0],1);
      FREE_ARRAY(HMEM_CTX_REF,pTmpBuf[0]);		// release buffer
      if(Retcode != ASN1_OP_OK) break;
    }
    //--------------------------------------------------------------
    // 8. Generate the TBS Certificate
    //--------------------------------------------------------------
    Retcode = ToASN1_TBS_Cert(HMEM_CTX_REF1
			      TBSDatArray,0,X509_TBS_CERT_MAX_DATA_INDEX,
			      pTmpBuf,pTmpLen,pSubErrCode);
    if(Retcode != ASN1_OP_OK) break;
    pTBSCertBuf = pTmpBuf[0];
    TBSCertLen  = pTmpLen[0];
//    PRINT("\nGenerating Signed Cert");
    //--------------------------------------------------------------
    // 9. Generate the Signed Certificate from Certifying issuer's
    //    RSA/DSA loaded structure
    //--------------------------------------------------------------
    Retcode = GenSignedCertificate(HMEM_CTX_REF1
		pTBSCertBuf,0,TBSCertLen,
		CertStruc->SignatType,RsaSignStruc,DsaSignStruc,	
		pTmpBuf,pTmpLen);
//    PRINT("\nGenerating Signed Cert End");
    if(Retcode != ASN1_OP_OK) break;

    pCertBuf = pTmpBuf[0];
    CertLen  = pTmpLen[0];
    //--------------------------------------------------------------
    // 10. Check if a container should be built
    //--------------------------------------------------------------
    if(CertType == 0)
    {
      pDstBuf[0] = pCertBuf;
      pDstLen[0] = CertLen;
      pCertBuf = NULL;
      break;
    }
    //------------------------------------------------------------------
    // 11. A container is requested, check if with / without Private Key
    //------------------------------------------------------------------
    if(CertType == 2) // with Private Key
    {
      switch(CertStruc->PublicKeyType)
      {
        case RSA_PUBLIC_ALGOR:
          Retcode = FromArrayDescToRSAPrivParams(HMEM_CTX_REF1 CertStruc->PrivKeyData,pTmpRsaStruc);
          break;

        case DSA_PUBLIC_ALGOR:
          Retcode = FromArrayDescToDSAPrivParams(HMEM_CTX_REF1 CertStruc->PrivKeyData,pTmpDsaStruc);
          break;

        case DH_PUBLIC_ALGOR:
          Retcode = FromArrayDescToDHPrivParams(HMEM_CTX_REF1 CertStruc->PrivKeyData,pTmpDhStruc);
          break;
      }
      if(Retcode != ASN1_OP_OK) break;
    }
    //------------------------------------------------------------------
    // 12. Build the container
    //------------------------------------------------------------------
    Retcode = GenIbmContainer(HMEM_CTX_REF1
		pCertBuf, 0, CertLen, CertType,
		OrdinalNumber, pTmpRsaStruc[0],
		pTmpDsaStruc[0], pTmpDhStruc[0],
		Pwd, PwdLen, CertStruc->PublicKeyType,
		IteratCount, HashType, ContainerName,
		ContNameLen, Flags, UsedBits,
		pTmpBuf, pTmpLen);
//    PRINT("\nGenerating Container End");

    if(Retcode == ASN1_OP_OK)
    {
      pDstBuf[0] = pTmpBuf[0];
      pDstLen[0] = pTmpLen[0];
    }
    break;
  } // Error FOR
  //----------------------------------------------------------
  // now we free the temporary allocated descriptors
  //----------------------------------------------------------
  if(TBSDatArrayDesc != NULL)
     FreeIDATPARR_Struc(HMEM_CTX_REF1 TBSDatArrayDesc);
  FREE_ARRAY(HMEM_CTX_REF,pTBSCertBuf);
  FREE_ARRAY(HMEM_CTX_REF,pCertBuf);
  RSA_Free(HMEM_CTX_REF1 pTmpRsaStruc[0]);
  DSA_Free(HMEM_CTX_REF1 pTmpDsaStruc[0]);
  DH_Free(HMEM_CTX_REF1 pTmpDhStruc[0]);

  return(Retcode);
}
/**
* Allocates buffer for public key
* OID, parameters and values and puts the ASN.1 encoded result in the
* data array structure (SetTBSCertReqSubjPubKeyInfo).
*
*  @param DatArray Array of pointers to <code>IDATA</code> structures for destination data
*  @param IndexOffset Start index to add to destination
*  @param SrcArray Input data array
*  @param ElementCnt Number of input elements
*  @param PubAlgorType Type of public algorithm
*
*  @return ASN1_OP_OK on success, error code otherwise
*/
extern "C"  int  SetTBSCertReqSubjPubKeyInfo(HMEM_CTX_DEF
				IDATA** DatArray,
				int IndexOffset,
				IDATA** SrcArray, int ElementCnt,
				int PubAlgorType)
{
  int Retcode;

  IDATA** TmpDatArray;
  IDATPARR* pTmpArrayDesc[1];
  //-------------------------------------------------------
  // Encode Algor-ID, Parameter and value fields
  //-------------------------------------------------------
//  Retcode = SUB_ENCODE_PUB_KEY_INFO(HASN1inst,HMEM_CTX_REF,
//				      SrcArray,ElementCnt,
//				      PubAlgorType, pTmpArrayDesc);
  Retcode = SubEncodePubKeyInfo(HMEM_CTX_REF1
				SrcArray,ElementCnt,
				PubAlgorType, pTmpArrayDesc);
  if(Retcode != ASN1_OP_OK) return(Retcode);
  TmpDatArray = pTmpArrayDesc[0]->ppArr;
  //-------------------------------------------------------
  // Copy Descriptor Elements to Cewrt-Req TBS Array (real Copy)
  //-------------------------------------------------------
  Retcode = AllocCopyDatArrayElements(HMEM_CTX_REF1 TmpDatArray,0,DatArray,TBS_CERT_REQ_PUB_ALGOR_ID_INDEX+IndexOffset,3,1);
  //------------------------------------------------------------
  // Release the temporary Array Descriptor and its elements
  //------------------------------------------------------------
  FreeIDATPARR_Struc(HMEM_CTX_REF1 pTmpArrayDesc[0]);	// Free Structure
  return(Retcode);
}  
/**
* Generates signed certificate
* request from given TBS certificate request, RSA/DSA private key and
* signature type and stores the ASN.1 encoded result in a newly allocated 
* buffer (GenSignedCertificateRequest).
*
* NOTE: The TBS certificate request must be freed outside.
*
*  @param SrcBuf Buffer containing ASN.1 encoded TBS certificate request data
*  @param SrcOff Start offset of data
*  @param SrcLen Data length
*  @param SignatTypeAlgor Type of signature
*  @param rsa RSA structure / NULL
*  @param dsa DSA structure / NULL
*  @param pDstBuf Pointer for result buffer
*  @param pDstLen Length of result data
*
*  @return ASN1_OP_OK on success, error code otherwise
*/
extern "C"  int  GenSignedCertificateRequest(HMEM_CTX_DEF
		char* SrcBuf, int SrcOff,
		int SrcLen, int SignatTypeAlgor, RSA_STRUC* rsa,
		DSA_STRUC* dsa, char** pDstBuf, int* pDstLen)
{

  int Retcode;
  int SignatLen;

  char* pSignatMem=NULL;

  char* pTmpBuf[1];
  int pTmpLen[1];
  int pTmpErrCode[1];

  IDATA** pSrcDatArray = NULL;
  IDATA** pTmpDatArray[1];

  IDATA** DatArray;
  IDATPARR* DatArrayDesc = NULL;
  IDATPARR* pTmpDatArrayDesc[1];

  //-----------------------------------------------------------------
  // Get Array for Certificate Request Construction, mark as freeable
  //-----------------------------------------------------------------
  Retcode = AllocIDATPARR_Struc(HMEM_CTX_REF1 pTmpDatArrayDesc,CERT_REQ_MAX_DATA_INDEX);
  if(Retcode != ASN1_OP_OK) return(Retcode);
  DatArrayDesc = pTmpDatArrayDesc[0];
  DatArrayDesc->Flags |= FREE_BIT_MASK;  
  DatArray = DatArrayDesc->ppArr;
  for(;;)
  {
    //-------------------------------------------------------
    // Copy TBS-CertReq to Array Element
    //-------------------------------------------------------
    Retcode = FromBufToDatArray(HMEM_CTX_REF1 DatArray,CERT_REQ_INFO_INDEX,SrcBuf,SrcOff,SrcLen,1);
    if(Retcode != ASN1_OP_OK) break;
    //-------------------------------------------------------
    // Generate the Signature, put to Element
    //-------------------------------------------------------
    Retcode = SignTBSCert_CertReq(HMEM_CTX_REF1
				  DatArray,0,rsa,dsa,SignatTypeAlgor,
			          pTmpBuf,pTmpLen);
    if(Retcode != ASN1_OP_OK) break;
    pSignatMem = pTmpBuf[0];
    SignatLen  = pTmpLen[0];

    Retcode = AllocIDATA_Array(HMEM_CTX_REF1 pTmpDatArray,1);
    if(Retcode != ASN1_OP_OK) break;
    pSrcDatArray = pTmpDatArray[0];

    Retcode = FromBufToDatArray(HMEM_CTX_REF1 pSrcDatArray,0,pSignatMem,0,SignatLen,0);
       if(Retcode != ASN1_OP_OK) break;
    //-------------------------------------------------------
    // Append Signature type, algor and data to Array
    //-------------------------------------------------------
//    Retcode = SetSignatAlgAndData(DatArray,CERT_REQ_SIGNAT_ALGOR_ID_INDEX,
//			pSrcDatArray,1,SignatTypeAlgor);
    Retcode = SetSignatAlgAndData(HMEM_CTX_REF1 DatArray,CERT_REQ_SIGNAT_ALGOR_ID_INDEX,pSrcDatArray,1,SignatTypeAlgor);
    if(Retcode != ASN1_OP_OK) break;
    //-------------------------------------------------------
    // Generate the Certificate Request
    //-------------------------------------------------------
    Retcode = ToASN1_CertReq(HMEM_CTX_REF1
			     DatArray,0,CERT_REQ_MAX_DATA_INDEX,
			     pTmpBuf,pTmpLen,pTmpErrCode);
    if(Retcode != ASN1_OP_OK) Retcode = pTmpErrCode[0];
    break;
  } // Error FOR
  FREE_ARRAY(HMEM_CTX_REF,pSrcDatArray);	// free signature buffer
  FreeIDATPARR_Struc(HMEM_CTX_REF1 DatArrayDesc);
  if(Retcode != ASN1_OP_OK)
    return(Retcode);
  pDstBuf[0] = pTmpBuf[0];
  pDstLen[0] = pTmpLen[0];
  return(ASN1_OP_OK);
}

extern "C"  int  FromCertReqStrucToASN1CertReq(HMEM_CTX_DEF
	PKCS10_CERTREQ * CertReqStruc,
	int CertReqType,
	RSA_STRUC* RsaSignStruc, DSA_STRUC* DsaSignStruc,
	char* Pwd, int PwdLen,
        int IteratCount, int HashType,
	int OrdinalNumber,
	char* ContainerName, int ContNameLen,
	int Flags, int UsedBits,
	char** pDstBuf, int* pDstLen)
{
  int Retcode;
  int TBSCertReqLen;
  int CertReqLen;

  char* pMem = NULL;
  char* pCertReqBuf = NULL;
  char* pTBSCertReqBuf = NULL;

  IDATPARR* pTmpDatArrayDesc[1];
  IDATPARR* TBSDatArrayDesc = NULL;

  IDATA** TBSDatArray;
  IDATA* pIdata;

  int pSubErrCode[1];

  char* pTmpBuf[1];

  int pTmpLen[1];

  RSA_STRUC* pTmpRsaStruc[1] = {NULL};
  DSA_STRUC* pTmpDsaStruc[1] = {NULL};
  DH_STRUC* pTmpDhStruc[1] = {NULL};
  //----------------------------------------------
  // 0. Do some checks first
  //----------------------------------------------
  if((CertReqStruc == NULL) || (pDstBuf == NULL) || (pDstLen == NULL))
    return(ASN1_STRUC_TO_CREQ_NULPTR_ERR);

  pDstBuf[0] = NULL;
  for(;;) // Error FOR
  {
    //---------------------------------------------------------------
    // 1. Allocate Data-Array for Certificate Request Info formatting
    //---------------------------------------------------------------
    Retcode = AllocIDATPARR_Struc(HMEM_CTX_REF1 pTmpDatArrayDesc,TBS_CERT_REQ_MAX_DATA_INDEX);
    if(Retcode != ASN1_OP_OK) break;
    TBSDatArrayDesc = pTmpDatArrayDesc[0];		// get descriptor
    TBSDatArrayDesc->Flags |= FREE_BIT_MASK;	// mark freeable
    TBSDatArray = TBSDatArrayDesc->ppArr;
    //--------------------------------------------------------------
    // 2. Copy simple types
    //--------------------------------------------------------------
    Retcode = AllocCopyDatArrayToDatArray(HMEM_CTX_REF1 CertReqStruc->VersionNumber,0,TBSDatArrayDesc,TBS_CERT_REQ_VERSION_INDEX,1,1);
    if(Retcode != ASN1_OP_OK) break;
    //--------------------------------------------------------------
    // 3. Generate Subject RDN
    //--------------------------------------------------------------
    Retcode = ToASN1_DN(HMEM_CTX_REF1 CertReqStruc->Subject,pTmpBuf,pTmpLen);
    if(Retcode != ASN1_OP_OK) break;

    Retcode = FromBufToDatArray(HMEM_CTX_REF1 TBSDatArray,TBS_CERT_REQ_SUBJECT_RDN_INDEX,pTmpBuf[0],0,pTmpLen[0],1);
    FREE_ARRAY(HMEM_CTX_REF,pTmpBuf[0]);	// release buffer
    if(Retcode != ASN1_OP_OK) break;
    //--------------------------------------------------------------
    // 4. Generate Public Algor fields
    //--------------------------------------------------------------
    Retcode = SetTBSCertReqSubjPubKeyInfo(HMEM_CTX_REF1
		TBSDatArray,0,
	CertReqStruc->SubjPubKeyParVal->ppArr, //Array Base
        CertReqStruc->SubjPubKeyParVal->Cnt,	// count
		CertReqStruc->PublicKeyType);		// type
    if(Retcode != ASN1_OP_OK) break;
    //--------------------------------------------------------------
    // 5. Generate Attributes (if present), if empty allocate a dummy
    //    (empty) buffer to force output of sequence !!
    //--------------------------------------------------------------
    if(CertReqStruc->Attributes->ppArr[0]->Base != NULL)
    {

    }
    else
    {
      //-------------------------------------------------------
      // Set Unknown buffer to Zero length data
      //-------------------------------------------------------
      pMem = BIT8_ARRAY_ALLOC(HMEM_CTX_REF,1);	// allocate Dummy Array
      if(pMem == NULL)
      {
        Retcode = ASN1_TO_CREQ_ATTBUF_ALLOC_ERR;
        break;
      }
      pIdata = TBSDatArray[TBS_CERT_REQ_ATTRIBUTES_INDEX];
      pIdata->Base = pMem;		// set Buffer Base
      pIdata->Len = 0;
      pMem = NULL;
    }
    //--------------------------------------------------------------
    // 6. Generate the TBS Certificate Request Info
    //--------------------------------------------------------------
    Retcode = ToASN1_TBSCertReqInfo(HMEM_CTX_REF1
			TBSDatArray,0,TBS_CERT_REQ_MAX_DATA_INDEX,
			pTmpBuf,pTmpLen,pSubErrCode);
    if(Retcode != ASN1_OP_OK) break;
    pTBSCertReqBuf = pTmpBuf[0];
    TBSCertReqLen  = pTmpLen[0];
//    PRINT("\nGenerating Signed Cert");
    //--------------------------------------------------------------
    // 7. Generate the Signed Certificate Request from
    //    RSA/DSA loaded structure
    //--------------------------------------------------------------
    Retcode = GenSignedCertificateRequest(HMEM_CTX_REF1
		pTBSCertReqBuf,0,TBSCertReqLen,
		CertReqStruc->SignatType,RsaSignStruc,DsaSignStruc,
		pTmpBuf,pTmpLen);
//    PRINT("\nGenerating Signed Cert End");
    if(Retcode != ASN1_OP_OK) break;

    pCertReqBuf = pTmpBuf[0];
    CertReqLen  = pTmpLen[0];
    //--------------------------------------------------------------
    // 8. Check if a container should be built
    //--------------------------------------------------------------
    if(CertReqType == 0)
    {
      pDstBuf[0] = pCertReqBuf;
      pDstLen[0] = CertReqLen;
      pCertReqBuf = NULL;
      break;
    }
    //------------------------------------------------------------------
    // 9. A container is requested, check if with / without Private Key
    //------------------------------------------------------------------
    if(CertReqType == 2) // with Private Key
    {
      switch(CertReqStruc->PublicKeyType)
      {
        case RSA_PUBLIC_ALGOR:
          Retcode = FromArrayDescToRSAPrivParams(HMEM_CTX_REF1 CertReqStruc->PrivKeyData,pTmpRsaStruc);
          break;

        case DSA_PUBLIC_ALGOR:
          Retcode = FromArrayDescToDSAPrivParams(HMEM_CTX_REF1 CertReqStruc->PrivKeyData,pTmpDsaStruc);
          break;

        case DH_PUBLIC_ALGOR:
          Retcode = FromArrayDescToDHPrivParams(HMEM_CTX_REF1 CertReqStruc->PrivKeyData,pTmpDhStruc);
          break;
      }
      if(Retcode != ASN1_OP_OK) break;
    }
    //------------------------------------------------------------------
    // 12. Build the container
    //------------------------------------------------------------------
    Retcode = GenIbmContainer(HMEM_CTX_REF1
		pCertReqBuf, 0, CertReqLen, 0,
		OrdinalNumber, pTmpRsaStruc[0],
		pTmpDsaStruc[0], pTmpDhStruc[0],
		Pwd, PwdLen, CertReqStruc->PublicKeyType,
		IteratCount, HashType, ContainerName,
		ContNameLen, Flags, UsedBits,
		pTmpBuf, pTmpLen);
//    PRINT("\nGenerating Container End");

    if(Retcode == ASN1_OP_OK)
    {
      pDstBuf[0] = pTmpBuf[0];
      pDstLen[0] = pTmpLen[0];
    }
    break;
  } // Error FOR
  //----------------------------------------------------------
  // now we free the temporary allocated descriptors
  //----------------------------------------------------------
  if(TBSDatArrayDesc != NULL)
     FreeIDATPARR_Struc(HMEM_CTX_REF1 TBSDatArrayDesc);
  FREE_ARRAY(HMEM_CTX_REF,pTBSCertReqBuf);
  FREE_ARRAY(HMEM_CTX_REF,pCertReqBuf);
  FREE_ARRAY(HMEM_CTX_REF,pMem);
  RSA_Free(HMEM_CTX_REF1 pTmpRsaStruc[0]);
  DSA_Free(HMEM_CTX_REF1 pTmpDsaStruc[0]);
  DH_Free(HMEM_CTX_REF1 pTmpDhStruc[0]);

  return(Retcode);
}
/**
* Decrypts and reencrypts the private keys of certificate/
* certificate request IBM containers with a new password (with same
* iteration count and hash type, but different salt-value) and
* overwrites  the old encrypted private key with the
* new encrypted one of same length (ReencryptContainerPrivKey).
* 
*  @param IbmContDesc Pointer to <code>IDATA</code> container structure with split ASN.1 
*                     container elements
*  @param DecryptPwd Password for decrypt
*  @param DecryptPwdLen Length of decrypt password
*  @param EncryptPwd Password for reencrypt
*  @param EncryptPwdLen Length of reencrypt password
*
*  @return ASN1_OP_OK on success, error code otherwise
*/
extern "C"  int  ReencryptContainerPrivKey(HMEM_CTX_DEF
		IDATPARR* IbmContDesc,
		char* DecryptPwd, int DecryptPwdLen,
		char* EncryptPwd, int EncryptPwdLen)
{
  int Retcode;
  int CertIndex;
  int Index;
  int Len;
  int pOldPrivKeyLen = 0;

  int SrcOff;
  int SrcLen;
  int CertCount;

  char* SrcBuf;
  char* pBuf;

  char* pOldPrivKeyBuf = NULL;
  char* pNewPrivKeyBuf = NULL;

  IDATPARR* pTmpDatArrayDesc[1];

  IDATPARR* IBMContainerDatArrayDesc = NULL;

  IDATA** pDatArray = NULL;
  IDATA** IBMContainerDatArray = NULL;

  IDATA* pIdata;

  int pTmpDat[1];
  int pSubErrCode[1];
  int pTmpIteratCnt[1];
  int pTmpHashType[1];

  char* pTmpBase[1];
  int pTmpLen[1];
  //-------------------------------------------------------------
  // 0. Do some checks first, get number of Certificates/Requests
  //-------------------------------------------------------------
  if((IbmContDesc == NULL) || (DecryptPwd == NULL) || (EncryptPwd == NULL))
    return(ASN1_REENC_PRIVKEY_NULPTR_ERR);
  pDatArray = IbmContDesc->ppArr;	// get Array
  if(pDatArray == NULL)
    return(ASN1_REENC_PRIVKEY_NULPTR_ERR);

  CertCount = IbmContDesc->Cnt;
  if(CertCount == 0)
    return(ASN1_OP_OK);
  //-------------------------------------------------------------
  // Process all the Certificates/Requests
  //-------------------------------------------------------------
  CertIndex = 0;
  do
  {
    //------------------------------------------------------------
    // 1. Get pointer to Certificate/Req.
    //------------------------------------------------------------
    pIdata = pDatArray[CertIndex++];		// get descriptor
    if(pIdata == NULL)
    {
      Retcode = ASN1_REENC_PRIVKEY_NULPTR_ERR;
      break;
    }
    SrcBuf = pIdata->Base;
    SrcOff = (int) pIdata->Off;
    SrcLen = pIdata->Len;

    if((SrcBuf == NULL) || (SrcLen <= 0))
    {
      Retcode = ASN1_REENC_PRIVKEY_NO_DATA_ERR;
      break;
    }
    //------------------------------------------------------------
    // 2. Split IBM Container, check if private key present
    //------------------------------------------------------------
    Retcode = FromASN1_IBMContainer(HMEM_CTX_REF1 SrcBuf,SrcOff,SrcLen,pTmpDatArrayDesc,pTmpDat,pSubErrCode);
    if(Retcode != ASN1_OP_OK)
      break;
    IBMContainerDatArrayDesc = pTmpDatArrayDesc[0];
    IBMContainerDatArray = IBMContainerDatArrayDesc->ppArr;
    pIdata = IBMContainerDatArray[IBM_PRIV_KEY_INFO_INDEX];
    pBuf  = pIdata->Base;
    Index = (int) pIdata->Off;
    Len   = pIdata->Len;
    if((pBuf != NULL) && (Len != 0))
    {
      //-------------------------------------------------------
      // 3. Decrypt the Private Key
      //-------------------------------------------------------
      Retcode =  DecryptPrivateKey(HMEM_CTX_REF1 pBuf,Index,Len,DecryptPwd,DecryptPwdLen,pTmpBase,pTmpLen,pTmpIteratCnt,pTmpHashType);
      if(Retcode != PKCS5_OP_OK)
      {
        Retcode = ASN1_REENC_PRIVKEY_DECRYPT_ERR;
        break;
      }
      pOldPrivKeyBuf = pTmpBase[0];
      pOldPrivKeyLen = pTmpLen[0];
      //------------------------------------------------------------------
      // 4. Encrypt the private key with new password
      //------------------------------------------------------------------
      Retcode = EncryptPrivateKey(HMEM_CTX_REF1 pOldPrivKeyBuf,0,pOldPrivKeyLen,EncryptPwd,EncryptPwdLen,pTmpIteratCnt[0],pTmpHashType[0],NULL,pTmpBase,pTmpLen);
      if(Retcode != PKCS5_OP_OK)
      {
        Retcode = ASN1_REENC_PRIVKEY_ENCRYPT_ERR;
        break;
      }
      pNewPrivKeyBuf = pTmpBase[0];
      //------------------------------------------------------------------
      // 5. Copy new data back to container (length is same !)
      //------------------------------------------------------------------
      memcpy(pBuf+Index,pNewPrivKeyBuf+0,Len);
      Index = pOldPrivKeyLen;		// set size
      do{Index--;pOldPrivKeyBuf[Index] = 0;}while(Index != 0);
      FREE_ARRAY(HMEM_CTX_REF,pOldPrivKeyBuf);
      FREE_ARRAY(HMEM_CTX_REF,pNewPrivKeyBuf);
      pOldPrivKeyBuf = NULL;
      pNewPrivKeyBuf = NULL;
    }
    FreeIDATPARR_Struc(HMEM_CTX_REF1 IBMContainerDatArrayDesc);
    IBMContainerDatArrayDesc = NULL;
    CertCount--;
  }while(CertCount != 0);
  if(CertCount == 0)
    return(ASN1_OP_OK);
  //------------------------------------------------------------------
  // error occured, free remaining the temporary allocated descriptors
  //------------------------------------------------------------------
  if(IBMContainerDatArrayDesc != NULL)
    FreeIDATPARR_Struc(HMEM_CTX_REF1 IBMContainerDatArrayDesc);
  if(pOldPrivKeyBuf != NULL)
  {
    Index = pOldPrivKeyLen;		// set size
    do{Index--;pOldPrivKeyBuf[Index] = 0;}while(Index != 0);
    FREE_ARRAY(HMEM_CTX_REF,pOldPrivKeyBuf);
  }
  FREE_ARRAY(HMEM_CTX_REF,pNewPrivKeyBuf);
  return(Retcode);
}
/**
* Matches a certificate and a
* certificate request in internal notation (MatchCertToCertReq). 
* The certificate and
* certificate request must have been preprocessed.
* The matching is done as follows:
*<ol>
* <li> The subject RDN from the certificate is compared to the
*    subject RDN of the certificate request in direct order (not sorted).
*    If no direct match is possible, a sorted match is tried. 
*    If no match can be achieved (changed subject by issuer!)
*    continue with 2.
*
* <li> The public key types of both is compared.
* <li> The subject public parameters of the certificate are compared
*    to the subject public parameters of the certificate request.
*</ol>
*  @param pCert Certificate to be matched
*  @param pCertReq Certificate request to be matched
*  @param Result Result of match: <br>
*                    ASN1_SAME (0) <br>
*                    ASN1_NOT_SAME (1) <br>
*                    ASN1_PARTIALLY_SAME (2) <br>
*                    ASN1_CONTENT_SAME(3)
*
*  @return ASN1_OP_OK on success, error code otherwise
*/
extern "C"  int  MatchCertToCertReq(HMEM_CTX_DEF X509CERT * pCert,
			PKCS10_CERTREQ * pCertReq, int* Result)
{
  int Retcode = ASN1_OP_OK;

  int ElementCount;

  int SortedMatchFlag  = 0;
  int SubjectMatchFlag = 0;

  IDATA* pIdata;

  IDATPARR* DatArrayDesc1;
  IDATPARR* DatArrayDesc2;

  X501_DN* pNameDesc1;
  X501_DN* pNameDesc2;

  X509CERT * pTmpCert[1];
  PKCS10_CERTREQ * pTmpCertReq[1];

  //-------------------------------------------
  // Check Parameters
  //-------------------------------------------
  if((pCert == NULL) || (pCertReq == NULL) || (Result == NULL))
    return(ASN1_MATCH_CERTREQ_NULL_PTR_ERR);

  Result[0] = ASN1_NOT_SAME;			// no match
  //-------------------------------------------
  // 1. Match Subject RDNs if possible
  //-------------------------------------------
  pNameDesc1 = pCert->Subject;
  pNameDesc2 = pCertReq->Subject;

  if((pNameDesc1 == NULL) || (pNameDesc2 == NULL))	// not both present
    return(Retcode);

  Retcode = MatchX501_DNs(pNameDesc1,pNameDesc2,Result);
  if(Retcode != ASN1_OP_OK)
    return(Retcode);

  if(Result[0] == ASN1_SAME)			// Subject DOES match
  {
    SubjectMatchFlag = 1;
  }
  else						// Could not match yet...
  {
    //--------------------------------------------------------
    // 1.1. Try a subject sorted match now
    //--------------------------------------------------------
    pIdata = pCertReq->CertificateRequest->ppArr[0];

    Retcode = FromASN1CertReqToCertReqStruc(HMEM_CTX_REF1
			pIdata->Base,
			(int) pIdata->Off,
			pIdata->Len,
			0,			// pure ASN1
			0,			// do DN sorting
			NULL,0,			// no password
			pTmpCertReq);
    if(Retcode != ASN1_OP_OK)
      return(Retcode);

    pIdata = pCert->Certificate->ppArr[0];

    Retcode = FromASN1CertToCertStrucEX(HMEM_CTX_REF1 pIdata->Base,(int) pIdata->Off,pIdata->Len,0,2,NULL,0,pTmpCert);
    if(Retcode != ASN1_OP_OK)
    {
      FreeCertReqStruc(HMEM_CTX_REF1 pTmpCertReq[0]);
      return(Retcode);
    }

    pNameDesc1 = pTmpCert[0]->Subject;
    pNameDesc2 = pTmpCertReq[0]->Subject;

    if((pNameDesc1 == NULL) || (pNameDesc2 == NULL))	// not both present
    {
      FreeCertReqStruc(HMEM_CTX_REF1 pTmpCertReq[0]);
      FreeCertStruc(HMEM_CTX_REF1 pTmpCert[0]);
      return(Retcode);
    }
    Retcode = MatchX501_DNs(pNameDesc1,pNameDesc2,Result);
    FreeCertReqStruc(HMEM_CTX_REF1 pTmpCertReq[0]);
    FreeCertStruc(HMEM_CTX_REF1 pTmpCert[0]);
    if(Retcode != ASN1_OP_OK)
      return(Retcode);

    if(Result[0] == ASN1_SAME)
    {
      SubjectMatchFlag = 1; 
      SortedMatchFlag  = 1;
    }
  }
  //-------------------------------------------
  // 2. Compare Public Key Algorithms
  //-------------------------------------------
  Result[0] = ASN1_NOT_SAME;		// assume remaining mismatch
  if(pCert->PublicKeyType != pCertReq->PublicKeyType)
    return(Retcode);
  //-----------------------------------------------
  // 3. Match specific Subject public params/values
  //-----------------------------------------------
  DatArrayDesc1 = pCert->SubjPubKeyParVal;
  DatArrayDesc2 = pCertReq->SubjPubKeyParVal;
  if((DatArrayDesc1 == NULL) || (DatArrayDesc2 == NULL)) // not both present
    return(Retcode);

  ElementCount = DatArrayDesc1->Cnt;	// get number of elements
  if(ElementCount != DatArrayDesc2->Cnt)
    return(Retcode);

  Result[0] = MatchIDATPARRStrucs(DatArrayDesc1,0,DatArrayDesc2,0,ElementCount);

  if(Result[0] == ASN1_SAME)
  {
    if(SubjectMatchFlag == 0)		// no subject match !!
    {
      Result[0] = ASN1_PARTIALLY_SAME;
    }
    else
    {
      if(SortedMatchFlag != 0)		// same but not identic
      {
        Result[0] = ASN1_CONTENT_SAME;
      }
    }
  }
  return(Retcode);
}

extern "C"  int  AllocCertStructList(HMEM_CTX_DEF
	X509CERT *** ppCertListArray, int CertCount)
{
//  int Index;

    X509CERT ** pCertListArray;
    //----------------------------------------------------
    // Check parameters
    //----------------------------------------------------
    if(ppCertListArray == NULL)
       return(ASN1_CERTLIST_ALLOC_NULL_PTR);
    ppCertListArray[0] = NULL;
    if(CertCount == 0) return(ASN1_OP_OK);
    //----------------------------------------------------
    // Allocate Array for Certificates, clear it
    //----------------------------------------------------
    pCertListArray = (X509CERT **) BIT8_ARRAY_CALLOC(HMEM_CTX_REF,
				       1,CertCount * sizeof(X509CERT *));
    if(pCertListArray == NULL)
      return(ASN1_CERTLIST_ALLOC_ERR);

    
    ppCertListArray[0] = pCertListArray;
    return(ASN1_OP_OK);
}

extern "C"  int  FromCertListToCertStrucListEX(HMEM_CTX_DEF
	IDATPARR* CertDescList, int ProcessFlags,
	X509CERT *** ppCertsArray)
{
  int Retcode;
  int CertsCount;
  int i;

  IDATA* pIdata;
  IDATA** pCertListArray;

  X509CERT ** pCertsArray = NULL;
  X509CERT * pTmpCert[1];
  //----------------------------------------------------
  // check parameters
  //----------------------------------------------------
  if((CertDescList == NULL) || (ppCertsArray == NULL))
    return(ASN1_CERTLIST_NULL_PTR);

  CertsCount = CertDescList->Cnt;	// get number of certs
  if(CertsCount == 0) return(ASN1_CERTLIST_NO_CERTS);	// none present
  pCertListArray = CertDescList->ppArr;// get array base
  //----------------------------------------------------
  // allocate required X509 Certificate Structures
  //----------------------------------------------------
  Retcode = AllocCertStructList(HMEM_CTX_REF1
				ppCertsArray,CertsCount);
  if(Retcode != ASN1_OP_OK) return(Retcode);
  pCertsArray = ppCertsArray[0];
  //----------------------------------------------------
  // process the Certificates from the list
  //----------------------------------------------------
  i = CertsCount;
  do
  {
    i--;				// pre-decrement, use as index
    pIdata = pCertListArray[i];    	// get source cert data element

    Retcode = FromASN1CertToCertStrucEX(HMEM_CTX_REF1 pIdata->Base,(int) pIdata->Off,pIdata->Len,0,ProcessFlags,NULL,0,pTmpCert);
    if(Retcode != ASN1_OP_OK) break;	// error occured...
    pCertsArray[i] = pTmpCert[0];	// save structure
  }while(i != 0);			
  if(Retcode != ASN1_OP_OK)
  {
    FreeCertList(HMEM_CTX_REF1 pCertsArray,CertsCount);
    ppCertsArray[0] = NULL;
  }
  return(Retcode);
}
/**
* Wrapper for FromCertListToCertStrucListEX, setting parameter ProcessFlags 0 (FromCertListToCertStrucList).
*
*  @param CertDescList Pointer to <code>IDATA</code> container structure with list of 
*                       certificates as elements
*  @param ppCertsArray Pointer to place new ceritficate array
*
*  @return ASN1_OP_OK on success, error code otherwise
*/
extern "C"  int  FromCertListToCertStrucList(HMEM_CTX_DEF
		IDATPARR* CertDescList, X509CERT *** ppCertsArray)
{
  return(FromCertListToCertStrucListEX(HMEM_CTX_REF1
				       CertDescList, 0, ppCertsArray));
}

extern "C"  int  FromASN1_PKCS7CertListEX(HMEM_CTX_DEF
	char* InpBuf, int InpOffset, int InpLen, int ProcessFlags,
	X509CERT *** ppCertStrucList, int* pCertCnt)
{
  int Retcode;
  int i;
  int Len;
  int Off;
  int OID_Len;

  char* pBuf;

  IDATPARR* pTmpDatArrayDesc[1];
  IDATPARR* DatArrayDesc;
  IDATA** DatArray;
  IDATA* pIdata;

  int pTmpCnt[1];
  int pTmpLen[1];
  //---------------------------------------------------------------
  // check parameters
  //---------------------------------------------------------------
  if((InpBuf == NULL) || (ppCertStrucList == NULL) || (pCertCnt == NULL))
    return(ASN1_PKCS7_CERT_LIST_NULL_PTR);

  ppCertStrucList[0] = NULL;			// invalidate
  //---------------------------------------------------------------
  // verify ASN1 sequence header
  //---------------------------------------------------------------
  if((InpLen <= 1) ||
     (InpBuf[InpOffset] != (ASN1_UNIVERSAL_SEQUENCE | ASN1_CONSTRUCTED)))
  {
    return(ASN1_PKCS7_CERT_LIST_FMT_ERR);
  }
  i = DecodeASN1_LenField(InpBuf,InpOffset+1,InpLen-1,pTmpLen);
  if((i < 0) && (i != -1))			// indefinite is allowed!
  {
    return(ASN1_PKCS7_CERT_LIST_FMT_ERR);
  }
  else if(i != -1)				// not the Indefinite case
  {
    i = 1 + i + (int) pTmpLen[0];		// total needed
    if(InpLen > i)				// Too many data given !!
      InpLen = i;				// truncate
  }
  //---------------------------------------------------------------
  // allocate the required IDATA ptr array and the elements
  //---------------------------------------------------------------
  i = AllocIDATPARR_Struc(HMEM_CTX_REF1 pTmpDatArrayDesc,PKCS7_CERTS_LIST_MAX_DATA_INDEX);
  if(i != ASN1_OP_OK)
    return(ASN1_PKCS7_CERT_LIST_ALLOC_ERR);

  DatArrayDesc = pTmpDatArrayDesc[0];
  DatArray = DatArrayDesc->ppArr;
  //---------------------------------------------------------------
  // Split the PKCS7 certificate List...
  //---------------------------------------------------------------
  for(;;)
  {
    i = FromASN1(HMEM_CTX_REF1 InpBuf,InpOffset,InpLen,(char *) Pkcs7CertsListCtl,PKCS7_CERTS_LIST_CTL_CNT,DatArray,0);
    if(i != ASN1_OP_OK)
    {
      Retcode = ASN1_PKCS7_CERT_LIST_TO_INT_ERR;    
      break;
    }
    //---------------------------------------------------------------
    // validate the certificate list format (Version, OIDs)
    //---------------------------------------------------------------
    Retcode = ASN1_PKCS7_CERT_LIST_VERS_ERR;		// preset Retcode
    pIdata = DatArray[PKCS7_SDATA_VERSION_INDEX];
    pBuf = pIdata->Base;
    Off  = (int) pIdata->Off;
    Len  = pIdata->Len;
    if((pBuf == NULL) || (Len != 1) || ((pBuf[Off] != 0) && (pBuf[Off] != 1)))
      break;

    Retcode = ASN1_PKCS7_CERT_LIST_FMT_ERR;		// preset Retcode
    pIdata = DatArray[PKCS7_SDATA_OID_INDEX];
    pBuf = pIdata->Base;
    Off  = (int) pIdata->Off;
    Len  = pIdata->Len;
    if((pBuf == NULL) || (Len == 0)) break;		// no OID

    i = OID_Offset_Table[OID_PKCS7_SIGNED_DATA]; // get index
    OID_Len = (int) OID_Table[i+2] & 0xFF;
    i = MatchASN1ValuesByteByByte(pBuf,Off,Len,(char*)OID_Table,i+3,OID_Len);
    if(i != ASN1_SAME) break;				// not same

    pIdata = DatArray[PKCS7_SDATA_DATA_OID_INDEX];
    pBuf = pIdata->Base;
    Off  = (int) pIdata->Off;
    Len  = pIdata->Len;
    i = OID_Offset_Table[OID_PKCS7_DATA]; // get index
    OID_Len = (int) OID_Table[i+2] & 0xFF;
    i = MatchASN1ValuesByteByByte(pBuf,Off,Len,(char*)OID_Table,i+3,OID_Len);
    if(i != ASN1_SAME) break;				// not same
    //---------------------------------------------------------------
    // Sub-Decode the certificates to single structures, free struct.
    //---------------------------------------------------------------
    Retcode = ASN1_OP_OK;				// assume success
    pIdata = DatArray[PKCS7_SDATA_CERTS_INDEX];		// get Certs Desc.
    pBuf = pIdata->Base;
    Off  = (int) pIdata->Off;
    Len  = pIdata->Len;

    Retcode = ASN1_PKCS7_CERT_LIST_SPLIT_ERR;
    i = FromASN1_SubStr(HMEM_CTX_REF1 pBuf,Off,Len,(char *) X509CertEntryCtl,X509_CERT_ENTRY_CTL_CNT,X509_CERT_ENTRY_MAX_DATA_INDEX,pTmpDatArrayDesc,pTmpCnt);

    FreeIDATPARR_Struc(HMEM_CTX_REF1 DatArrayDesc);	// free the struct.
    DatArrayDesc = pTmpDatArrayDesc[0];

    if(i != ASN1_OP_OK) break;
    //---------------------------------------------------------------
    // Convert the certificates to internal structures
    //---------------------------------------------------------------
    pCertCnt[0] = DatArrayDesc->Cnt;		// get number of certs
    Retcode = FromCertListToCertStrucListEX(HMEM_CTX_REF1
					    DatArrayDesc,
					    ProcessFlags,
					    ppCertStrucList);
    if(Retcode != ASN1_OP_OK) Retcode = ASN1_PKCS7_CERT_CONV_ERR;   

    break;
  }
  FreeIDATPARR_Struc(HMEM_CTX_REF1 DatArrayDesc);
  return(Retcode);
}
/**
* Wrapper for FromASN1_PKCS7CertListEX, setting all flags to 0 (FromASN1_PKCS7CertList).
*
*  @param InpBuf ASN.1 datastream buffer
*  @param InpOffset Start offset of data
*  @param InpLen Length of data
*  @param ppCertStrucList Pointer where to store list array of certificate 
*                         structures
*  @param pCertCnt Number of certificates
*
*  @return ASN1_OP_OK on success, error code otherwise
*/
extern "C"  int  FromASN1_PKCS7CertList(HMEM_CTX_DEF
			char* InpBuf, int InpOffset,
			int InpLen, X509CERT *** ppCertStrucList,
			int* pCertCnt)
{
  return(FromASN1_PKCS7CertListEX(HMEM_CTX_REF1
				  InpBuf, InpOffset, InpLen, 0,
		       		  ppCertStrucList, pCertCnt));
}

extern "C"  int  ToASN1_PKCS7CertList(HMEM_CTX_DEF
		X509CERT ** pCertStrucList, int CertsCnt,
		char** ppDstBuf, int* pDstLen)
{
  int Retcode;
  int i;
  int DstIndex = 0;
  int CertsDataLen = 0;

  char TmpVersion[2];

  char* pBuf;

  IDATA* pIdata;
  IDATA** DatArray;

  IDATPARR* DatArrayDesc;
  IDATPARR* pTmpDatArrayDesc[1];
  //---------------------------------------------------------------
  // check parameters
  //---------------------------------------------------------------
  if((pCertStrucList == NULL) || (ppDstBuf == NULL) || (pDstLen == NULL))
    return(ASN1_PKCS7_INT_TO_CERTLST_NULLP);
  if(CertsCnt <= 0) return(ASN1_PKCS7_INT_TO_CERTLST_EMPTY);
  //-----------------------------------------------------------------------
  // Count the certificates to DER encoded elements data sizes
  //-----------------------------------------------------------------------
  i = CertsCnt;
  do
  {
    i--;					// predecrement, use as index
    DatArrayDesc = pCertStrucList[i]->Certificate;// get descr.
    pIdata = DatArrayDesc->ppArr[0];	// get Element
    if((pIdata->Base == NULL) || (pIdata->Len == 0))
      return(ASN1_PKCS7_INT_TO_CERTLST_ERR);

    CertsDataLen += pIdata->Len;
  }while(i != 0);

  pBuf = BIT8_ARRAY_ALLOC(HMEM_CTX_REF,CertsDataLen);
  if(pBuf == NULL)
    return(ASN1_PKCS7_CERTBUF_ALLOC_ERR);
  i = CertsCnt;
  do
  {
    i--;					// predecrement, use as index
    DatArrayDesc = pCertStrucList[i]->Certificate;// get descr.
    pIdata = DatArrayDesc->ppArr[0];	// get Element
    memcpy(pBuf+DstIndex,pIdata->Base+0,pIdata->Len);
    DstIndex += pIdata->Len;
  }while(i != 0);
  //---------------------------------------------------------------
  // allocate the required IDATA ptr array and the elements
  //---------------------------------------------------------------
  i = AllocIDATPARR_Struc(HMEM_CTX_REF1 pTmpDatArrayDesc,PKCS7_CERTS_LIST_MAX_DATA_INDEX);
  if(i != ASN1_OP_OK)
  {
    FREE_ARRAY(HMEM_CTX_REF,pBuf);
    return(ASN1_PKCS7_CERT_LIST_ALLOC_ERR);
  }
  DatArrayDesc = pTmpDatArrayDesc[0];
  DatArrayDesc->Flags |= FREE_BIT_MASK;	// mark as freeable
  DatArray = DatArrayDesc->ppArr;
  //---------------------------------------------------------------
  // Generate the PKCS7 certificate List...
  //---------------------------------------------------------------
  for(;;)
  {
    //---------------------------------------------------
    // Store the certificates list to appropriate element
    //---------------------------------------------------
    FromBufToDatArray(HMEM_CTX_REF1 DatArray,PKCS7_SDATA_CERTS_INDEX,pBuf,0,CertsDataLen,0);	      
    //---------------------------------------------------
    // Set version element, signed data OID, data OID
    //---------------------------------------------------
    TmpVersion[0] = PKCS7_VERSION;		// set the version
    Retcode = FromBufToDatArray(HMEM_CTX_REF1 DatArray,PKCS7_SDATA_VERSION_INDEX,TmpVersion,0,1,1);
    if(Retcode != ASN1_OP_OK) break;

    Retcode = GenOIDIdataEntry(HMEM_CTX_REF1 OID_PKCS7_SIGNED_DATA,PKCS7_SDATA_OID_INDEX,DatArray);
    if(Retcode != ASN1_OP_OK) break;

    Retcode = GenOIDIdataEntry(HMEM_CTX_REF1 OID_PKCS7_DATA,PKCS7_SDATA_DATA_OID_INDEX,DatArray);
    if(Retcode != ASN1_OP_OK) break;
    //----------------------------------------------------------
    // Set empty SET OF Elements for the unused, required fields
    //----------------------------------------------------------
    TmpVersion[0] = ASN1_UNIVERSAL_SET | ASN1_CONSTRUCTED;
    TmpVersion[1] = 0;				// Zero length
    FromBufToDatArray(HMEM_CTX_REF1 DatArray,PKCS7_SDATA_DIGEST_ALGORS_INDEX,TmpVersion,0,2,0);
    FromBufToDatArray(HMEM_CTX_REF1 DatArray,PKCS7_SDATA_SIGNER_INFOS_INDEX,TmpVersion,0,2,0);
    //---------------------------------------------------
    // Generate the DER encoded data
    //---------------------------------------------------
    Retcode = ToASN1(HMEM_CTX_REF1 DatArray,0,(char *) Pkcs7CertsListCtl,PKCS7_CERTS_LIST_CTL_CNT,ppDstBuf,pDstLen);
    DatArray[PKCS7_SDATA_DIGEST_ALGORS_INDEX]->Base = NULL; // clear !
    DatArray[PKCS7_SDATA_SIGNER_INFOS_INDEX]->Base = NULL; // clear !
    DatArray[PKCS7_SDATA_VERSION_INDEX]->Base = NULL; // clear !

    break;
  }
  FreeIDATPARR_Struc(HMEM_CTX_REF1 DatArrayDesc);	// free the struct.
  return(Retcode);
}
/**
* Frees a certificate array descriptor
* structure (FreeCertParrStruc).
*
* NOTE: The elements are not freed.
*
*  @param pCertsDesc Allocated structure
*/
static  void  FreeCertParrStruc(HMEM_CTX_DEF
					   CERTPARR * pCertsDesc)
{
  X509CERT ** pCertArray;
  //----------------------------------------------------
  // Free the Array and the structure
  //----------------------------------------------------
  if(pCertsDesc == NULL) return;
  pCertArray = pCertsDesc->ppArr;
  if(pCertArray != NULL)
    FREE_ARRAY(HMEM_CTX_REF,pCertArray);
  FREE_ARRAY(HMEM_CTX_REF,pCertsDesc);
}

/**
* Allocates a certificate list container structure with certificate list array 
* of given size (AllocCertParrStruc). 
* All array elements are initialized to NULL.
*
*  @param ppCertsDesc Pointer for returning allocated structure
*  @param CertsCount Requested size
*  @return ASN1_OP_OK on success, error code otherwise
*/
extern "C"  int  AllocCertParrStruc(HMEM_CTX_DEF
		CERTPARR ** ppCertsDesc, int CertsCount)
{
  CERTPARR * pCertsDesc;   
  X509CERT ** pTmpCertListArray[1];
  //----------------------------------------------------
  // Check parameters
  //----------------------------------------------------
  if(ppCertsDesc == NULL)
    return(ASN1_CERTPARR_ALLOC_NULL_PTR);
  ppCertsDesc[0] = NULL;
  if(CertsCount <= 0)
    return(ASN1_CERTPARR_ALLOC_PARAM_ERR);
  //----------------------------------------------------
  // Allocate the basic structure
  //----------------------------------------------------
  pCertsDesc = (CERTPARR *) BIT8_ARRAY_ALLOC(HMEM_CTX_REF,sizeof(CERTPARR));
  if(pCertsDesc == NULL)
    return(ASN1_CERTPARR_ALLOC_ALLOC_ERR);
  //----------------------------------------------------
  // Allocate the Cert structures list Array
  //----------------------------------------------------
  if(AllocCertStructList(HMEM_CTX_REF1
			 pTmpCertListArray, CertsCount) != ASN1_OP_OK)
  {
    FREE_CARRAY(HMEM_CTX_REF,pCertsDesc);
    return(ASN1_CERTPARR_ALLOC_ALLOC_ERR);
  }
  //----------------------------------------------------
  // insert base information into structure
  //----------------------------------------------------
  pCertsDesc->ppArr = pTmpCertListArray[0];
  pCertsDesc->Cnt   = CertsCount;
  pCertsDesc->Flags = 0;
  ppCertsDesc[0] = pCertsDesc;
  return(ASN1_OP_OK);
}
/**
* Generates new TreeInfo certificate lists from given certificate
* structures list (GenCertsTreeInfo).
* All TreeInfo lists start with the endcert/subCA/rootcert
* respectively and include the depending issuer certificates in
* increasing order.
* If PEM mode is selected, the first certificate in the
* certificate structures list is assumed to be the only endcert.
* 
* NOTE: In PEM mode, there will be only one TreeInfo list; possible
*       other certificates will be discarded.
*
*  @param pCertStrucList Array of certificate structure pointers
*  @param CertsCount Number of certificates
*  @param DataType Type of data: <br>
*               PEM_REQ_DATA_TYPE: PEM-Mode <br>
*               PEM_REPLY_DATA_TYPE: PEM-Mode <br>
*               PKCS7_DATA_TYPE: PKCS7-Mode <br>
*               PKCS12_DATA_TYPE: PKCS12-Mode
*  @param ppCertTreeList Pointer where to store array of certificate container
*                        structure pointers
*  @param pCertTreeCount Number of certificate trees generated
*
*  @return ASN1_OP_OK on success, error code otherwise
*/
extern "C"  int  GenCertsTreeInfo(HMEM_CTX_DEF
			X509CERT ** pCertStrucList,
			int CertsCount, int DataType,
			CERTPARR *** ppCertTreeList,
			int* pCertTreeCount)
{
  int i,j;
  int Retcode;
  int SrcCertIndex;
  int CmpCertIndex;
  int EndCertsCount=CertsCount;
  int SameFlag;

  char* pFlagArray     = NULL;
  int*  pIssuerArray   = NULL;
  int*  pEndCertsArray = NULL;
  int*  pDepthArray    = NULL;

  int pTmpResult[1];

  X509CERT * pSrcCert;
  X509CERT ** pCertTreeArray;
  CERTPARR ** pCertTreeListsArr;
  CERTPARR * pTmpCertDescPtr[1];
  //-----------------------------------------------------
  // check parameters 
  //-----------------------------------------------------
  if((pCertStrucList == NULL) || (ppCertTreeList == NULL) ||
     (pCertTreeCount == NULL))
    return(ASN1_GEN_CERTTREE_INFO_NULL_PTR);
  ppCertTreeList[0] = NULL;
  pCertTreeCount[0] = 0;

  if(CertsCount <= 0) return(ASN1_GEN_CERTTREE_INFO_NO_CERTS);

  for(;;) // Error FOR
  {
    //-----------------------------------------------------
    // allocate required arrays
    //-----------------------------------------------------
    Retcode = ASN1_GEN_CERTTREE_INFO_ALLOC_ER;	// assume error
    pFlagArray = BIT8_ARRAY_ALLOC(HMEM_CTX_REF,CertsCount);// allocate Flag array
    if(pFlagArray == NULL) break;
    memset(pFlagArray,0,CertsCount);
    pIssuerArray = INT_ARRAY_ALLOC(HMEM_CTX_REF,CertsCount);// allocate issuer array
    if(pIssuerArray == NULL) break;
    i = CertsCount;
    do{i--;pIssuerArray[i] = -1;}while(i != 0);	// preset with invalid
    //-----------------------------------------------------
    // get the issuers index for all certificates
    //-----------------------------------------------------
    Retcode = ASN1_OP_OK;
    SrcCertIndex = 0;
    i = CertsCount;
    do
    {
      pSrcCert = pCertStrucList[SrcCertIndex];	// get cert

      {
	//-------------------------------------------------
	// eliminate duplicate certificate's from endcerts
	//-------------------------------------------------
	SameFlag = 0;

        {
          CmpCertIndex = 0;
	  while(CmpCertIndex < SrcCertIndex)
          {
            Retcode = MatchCerts(pCertStrucList[CmpCertIndex],pSrcCert,IDENTITY_MATCH,pTmpResult);
	    if(Retcode != ASN1_OP_OK) break;
	    if(pTmpResult[0] == ASN1_SAME)		// found same one
	    {
	      pFlagArray[SrcCertIndex] |= 0x04;		// set flag
	      EndCertsCount--;				// reduce count
              pIssuerArray[SrcCertIndex] = pIssuerArray[CmpCertIndex];
	      SameFlag = 1;
	      break;					// leave inner for
	    }
	    CmpCertIndex++;
	  }
	  if(Retcode != ASN1_OP_OK) break;		// leave outer for
	}
        if((SameFlag == 0) &&
           ((pSrcCert->Flags & SELF_SIGNED_MASK) == 0))
	{
	  //-------------------------------------------------
	  // not a duplicate, search issuer
	  //-------------------------------------------------
          CmpCertIndex = 0;
	  j = CertsCount;
	  do
	  {
	    if((CmpCertIndex != SrcCertIndex) &&
               ((pFlagArray[CmpCertIndex] & 0x04) == 0))
	    {
	      Retcode = MatchCerts(pSrcCert,pCertStrucList[CmpCertIndex],CHAIN_MATCH,pTmpResult);
	      if(Retcode != ASN1_OP_OK) break;
	      if(pTmpResult[0] == ASN1_SAME)	// found the issuer
	      {
	        pIssuerArray[SrcCertIndex] = CmpCertIndex; // set issuer index
	        if((pFlagArray[CmpCertIndex] & 0x01) == 0) // had no subj.
	          EndCertsCount--;
	        pFlagArray[CmpCertIndex] |= 0x01; // set subject present flag
	        break;				// leave inner FOR
	      }
	    }
            CmpCertIndex++;
	    j--;
	  }while(j != 0);
	  if(Retcode != ASN1_OP_OK) break;	// leave outer FOR
        }
      }  
      SrcCertIndex++;
      i--;
    }while(i != 0);      
    if(Retcode != ASN1_OP_OK) break;		// error exit

    if((DataType == PKCS7_DATA_TYPE) ||		// for PKCS7/PKCS12 mode
       (DataType == PKCS12_DATA_TYPE))
    {
      //------------------------------------------------------------
      // Allocate the endcerts array and a helper branch count array
      //------------------------------------------------------------
      Retcode = ASN1_GEN_CERTTREE_INFO_ALLOC_ER;
      pEndCertsArray = INT_ARRAY_ALLOC(HMEM_CTX_REF,EndCertsCount);
      if(pEndCertsArray == NULL) break;
      pDepthArray = INT_ARRAY_ALLOC(HMEM_CTX_REF,EndCertsCount);
      if(pDepthArray == NULL) break;
      Retcode = ASN1_OP_OK;
      //------------------------------------------------------------
      // Store the endcerts indices and branch depth
      //------------------------------------------------------------
      i = CertsCount;
      j = 0;
      do
      {
        i--;					// predecrement, use as index
        if((pFlagArray[i] & 0x07) == 0)		// found one
        {
	  CmpCertIndex = 0;			// clear counter
          pEndCertsArray[j] = i;		// set index
	  SrcCertIndex = i;			// save
	  for(;;)
	  {
            SrcCertIndex = pIssuerArray[SrcCertIndex]; // get next issuer
	    if(SrcCertIndex == -1) break;	// no more
	    CmpCertIndex++;			// one more
	  }
          pDepthArray[j] = CmpCertIndex;	// set depth
	  j++;
	}
      }while(i != 0);
      //------------------------------------------------------------
      // Sort EndIndex array in decreasing branch length order
      //------------------------------------------------------------
      if(EndCertsCount <= 1) break;		// no sort required
      i = EndCertsCount - 1;			// Top Index
      do
      {
        j = 0;					// set start
        CmpCertIndex = 0;			// clear sortflag
	do
        {
	  if(pDepthArray[j] < pDepthArray[j+1])
	  {
	    SrcCertIndex        = pDepthArray[j];	// exchange
	    pDepthArray[j]      = pDepthArray[j+1];
	    pDepthArray[j+1]    = SrcCertIndex;

	    SrcCertIndex        = pEndCertsArray[j]; // dto.
	    pEndCertsArray[j]   = pEndCertsArray[j+1];
	    pEndCertsArray[j+1] = SrcCertIndex;

	    CmpCertIndex = 1;			// set sorted flag
	  }
          j++;        				// to next bubble
	}while(j < i);
        if(CmpCertIndex == 0) break;	// completed
        i--;
      }while(i > 0);
    } // DATATYPE IF
    break;
  } // ERROR FOR
  FREE_ARRAY(HMEM_CTX_REF,pDepthArray);
  FREE_ARRAY(HMEM_CTX_REF,pFlagArray);
  if(Retcode != ASN1_OP_OK)
  {
    FREE_ARRAY(HMEM_CTX_REF,pEndCertsArray);
    FREE_ARRAY(HMEM_CTX_REF,pIssuerArray);
    return(Retcode);
  }
  //---------------------------------------------------------
  // Now convert the Index arrays to CertParr structures
  //---------------------------------------------------------
  if(EndCertsCount == 0)		// none survived, o.k.
  {
    FREE_ARRAY(HMEM_CTX_REF,pEndCertsArray);
    FREE_ARRAY(HMEM_CTX_REF,pIssuerArray);
    return(ASN1_OP_OK);
  }
  pCertTreeListsArr = (CERTPARR **) BIT8_ARRAY_CALLOC(HMEM_CTX_REF,
				1,sizeof(CERTPARR *)*EndCertsCount);
  if(pCertTreeListsArr == NULL)
  {
    FREE_ARRAY(HMEM_CTX_REF,pEndCertsArray);
    FREE_ARRAY(HMEM_CTX_REF,pIssuerArray);
    return(ASN1_GEN_CERTTREE_INFO_ALLOC_ER);
  }

  //---------------------------------------------------------
  // For each 'Endcert' construct the List Info structure
  //---------------------------------------------------------
  i = EndCertsCount;
  CmpCertIndex = 0;			// start with first element
  do
  {
    j = 0;
    SrcCertIndex = pEndCertsArray[CmpCertIndex]; // get index of act. endcert
    //-------------------------------------------------------
    // Count Elements required for current tree
    //-------------------------------------------------------
    for(;;)
    {
      j++;				// increment needed element count
      SrcCertIndex = pIssuerArray[SrcCertIndex]; // get issuer
      if(SrcCertIndex == -1)		// no more issuers
        break;
    }
    //-------------------------------------------------------
    // Allocate a CERTPARR structure for this Tree
    //-------------------------------------------------------
    Retcode = AllocCertParrStruc(HMEM_CTX_REF1 pTmpCertDescPtr,j);
    if(Retcode != ASN1_OP_OK) break;			  // allocate failed
    pCertTreeListsArr[CmpCertIndex] = pTmpCertDescPtr[0]; // save Element
    pCertTreeArray = pTmpCertDescPtr[0]->ppArr;  // get Array pointer
    //-----------------------------------------------------------
    // Fill Elements in this list element with structure pointers
    //-----------------------------------------------------------
    SrcCertIndex = pEndCertsArray[CmpCertIndex]; // get index of act. endcert
    j = 0;
    pCertTreeArray[j++] = pCertStrucList[SrcCertIndex];  // store Endcert
    for(;;)
    {
      SrcCertIndex = pIssuerArray[SrcCertIndex]; // get issuer
      if(SrcCertIndex == -1)		// no more issuers
        break;
      pCertTreeArray[j++] = pCertStrucList[SrcCertIndex]; // store issuer
    }
    CmpCertIndex++;
    i--;
  }while(i != 0);
  //--------------------------------------------------
  // Check for Error
  //--------------------------------------------------
  if(i != 0)				// Error occured
  {
    FREE_ARRAY(HMEM_CTX_REF,pEndCertsArray);
    FREE_ARRAY(HMEM_CTX_REF,pIssuerArray);
    i = EndCertsCount;
    do
    {
      i--;
      FreeCertParrStruc(HMEM_CTX_REF1 pCertTreeListsArr[i]);
    }while(i != 0);
    return(ASN1_GEN_CERTTREE_INFO_ALLOC_ER);
  }  
  //--------------------------------------------------
  // Everything is o.k., report tree lists
  //--------------------------------------------------
  ppCertTreeList[0] = pCertTreeListsArr;
  pCertTreeCount[0] = EndCertsCount;
  FREE_ARRAY(HMEM_CTX_REF,pEndCertsArray);
  FREE_ARRAY(HMEM_CTX_REF,pIssuerArray);
  return(ASN1_OP_OK);
}

/**
* Checks a certificate chain starting
* with an End-/Sub-CA- or a Root-certificate
* and ending with a Root-certificate (VerifyCertList).
*
* Verification is done in Toto, only name constraints are not
* yet checked.
*
*  @param pCertChain Pointer to certificate chain
*  @param CertCount Number of certificates
*  @param TestModeFlags Specific testmodes to apply: <br>
*               Bit 0: 1 - Extended time
*               check enable <br>
*               Bit 1: ignored <br>
*               other bits: reserved
*  @param pDeltaTimeArr Delta time array
*  @param ppStatusArr Per certificate status array,
*               allocated
*  @param pResult Overall verify result
*  @param pFailIndex index of 1st failing
*               cert, rel. 0
*
*  @return 0 on success, error code otherwise
*/
static  int  VerifyCertList(HMEM_CTX_DEF
		X509CERT ** pCertChain, int CertCount,
		int TestModeFlags, int* pDeltaTimeArr,
		int** ppStatusArr,
		int* pResult, int* pFailIndex)
{
  int Retcode,Index;
  int* pStatusArr;
  //------------------------------------------------------
  // Check Parameters
  //------------------------------------------------------
  if((pCertChain == NULL) || (ppStatusArr == NULL) ||
     (pResult == NULL) || (pFailIndex == NULL))
    return(ASN1_CERT_LIST_VFY_NULLPTR_ERR);

  if(CertCount <= 0)
    return(ASN1_CERT_LIST_VFY_NO_CERTS);

  pFailIndex[0]  = -1;				// Assume First Issuer failed
  ppStatusArr[0] = NULL;
  //------------------------------------------------------
  // Allocate the Individual Status Array, clear Elements
  //------------------------------------------------------
  pStatusArr = (int*) BIT8_ARRAY_CALLOC(HMEM_CTX_REF,
					1,CertCount*sizeof(int));
  if(pStatusArr == NULL)
    return(ASN1_ALLOC_ERR);
  //-----------------------------------------------------------
  // Verify the certificate chain, *WITHOUT* trusted root check
  //-----------------------------------------------------------
  Retcode = VerifyCertsChainEX(HMEM_CTX_REF1 pCertChain,CertCount,(TestModeFlags | 0x02),pDeltaTimeArr,pStatusArr,pResult,NULL,NULL);
  if(Retcode != ASN1_OP_OK)
  {
    FREE_CARRAY(HMEM_CTX_REF,pStatusArr);
    return(Retcode);
  }
  //-----------------------------------------------------------
  // Verify processing without catastrophic error, check result
  //-----------------------------------------------------------
  ppStatusArr[0] = pStatusArr;			// set Array for external acc.
  if(pResult[0] == 0)				// everything is fine...
  {
//  FREE_CARRAY(HMEM_CTX_REF,pStatusArr);
    return(ASN1_OP_OK);
  }

  Index = 0;
  while(Index < CertCount)
  {
    if(pStatusArr[Index] != 0)			// found first failing
      break;
    Index++;
  }
  pFailIndex[0] = Index;
  return(ASN1_OP_OK);
}

//========================================================
//
// JAVA Callback function helpers
//
//========================================================

/**
* Searches a given tree's list
* for a specified certificate (CheckCertInTreeList). 
* The search is done for the given certificate
* or its issuer.
*
* NOTE: No parameter checking is done !
*
*  @param Cert Certificate used for the search
*  @param ListCNIndexArr Index array into node list
*  @param CertListLen Number of elements in List
*  @param TreeStruc Certificate tree structure
*  @param MatchMode Type of comparison check: <br>
*               CHAIN_MATCH - get issuer <br>
*               ROOT_MATCH - get same RDN/Ser. <br>
*               IDENTITY_MATCH - check same
*  @param pCNIndex Index into the CNode-array if
*               found, -1 if not found
*/
static  void  CheckCertInTreeList(X509CERT * Cert,
			int* ListCNIndexArr, int CertListLen,
			CTREESTR * TreeStruc, int MatchMode,
			int* pCNIndex)
{
  int ActCNIndex;
  int ActCertIndex;
  int CertIndex=0;

  X509CERT * pTreeCert;
  int pTmpResult[1];

  pCNIndex[0] = -1;			// preset Result for not found
  //--------------------------------------------------
  // search in the specified List, if not empty
  //--------------------------------------------------
  if(CertListLen == 0) return;		// zero length, not found
  do
  {
    ActCNIndex = ListCNIndexArr[CertIndex++]; // get index of List-certificate
    ActCertIndex =					// get index into list
          TreeStruc->CNodeArray[ActCNIndex+CN_CERTLIST_INDEX];
    pTreeCert = TreeStruc->ppCertList[ActCertIndex]; // get cert.

    MatchCerts(Cert,pTreeCert,MatchMode,pTmpResult);
    if(pTmpResult[0] == ASN1_SAME)
    {
      pCNIndex[0] = ActCNIndex;			// set index of Cert-List
      return;					// exit
    }
    CertListLen--;
  }while(CertListLen != 0);
}
/**
* Searches the given tree for a
* specified certificate, or issuer of it (CheckCertInTree).
*
* NOTE: No parameter checking is done.
*
*  @param Cert Certificate to look for
*  @param TreeStruc Tree to search
*  @param MatchMode type of comparison check(if
*               certificate is not a Root-Cert): <br>
*               CHAIN_MATCH - get issuer <br>
*               ROOT_MATCH - get same RDN/Ser. <br>
*               IDENTITY_MATCH - check same
*  @param pCNIndex Index into the CNode-Array if
*               found, -1 if not found
*/
extern "C"  void  CheckCertInTree(X509CERT * Cert, CTREESTR * TreeStruc,
				        int MatchMode, int* pCNIndex)
{
  //----------------------------------------------
  // check for the search mode
  //----------------------------------------------
  if((Cert->Flags & SELF_SIGNED_MASK) != 0) // is a root, !
  {
    //-------------------------------------------------------------------
    // given certificate is a root, search only in Roots-List, match same
    //-------------------------------------------------------------------
    CheckCertInTreeList(Cert,TreeStruc->RootCaIndexArray,
			TreeStruc->RootCaCount, TreeStruc,
			ROOT_MATCH,pCNIndex);
  }
  else
  {
    //--------------------------------------------------------------
    // given certificate is not a root, search End-/Sub-CA Certlists    
    // but not in rootlist if matchmode is  n o t  CHAIN_MATCH
    //--------------------------------------------------------------
    if(MatchMode == CHAIN_MATCH)
    {
      CheckCertInTreeList(Cert,TreeStruc->RootCaIndexArray,
			  TreeStruc->RootCaCount, TreeStruc,
			  MatchMode,pCNIndex);
      if(pCNIndex[0] >= 0) return;		// found
    }

    CheckCertInTreeList(Cert,TreeStruc->SubCaIndexArray,
			TreeStruc->SubCaCount, TreeStruc,
			MatchMode,pCNIndex);
    if(pCNIndex[0] >= 0) return;		// found  

    CheckCertInTreeList(Cert,TreeStruc->EndRsaIndexArray,
			TreeStruc->EndRsaCount, TreeStruc,
			MatchMode,pCNIndex);
    if(pCNIndex[0] >= 0) return;		// found  

    CheckCertInTreeList(Cert,TreeStruc->EndDssIndexArray,
			TreeStruc->EndDssCount, TreeStruc,
			MatchMode,pCNIndex);
    if(pCNIndex[0] >= 0) return;		// found  

    CheckCertInTreeList(Cert,TreeStruc->EndDhRsaIndexArray,
			TreeStruc->EndDhRsaCount, TreeStruc,
			MatchMode,pCNIndex);
    if(pCNIndex[0] >= 0) return;		// found  

    CheckCertInTreeList(Cert,TreeStruc->EndDhDssIndexArray,
			TreeStruc->EndDhDssCount, TreeStruc,
			MatchMode,pCNIndex);
  }
}

/**
* Checks a given, sorted certificate list for consistency, validity and if it
* may be inserted in the given tree (ProcessInsertionCertListEX). 
* Then the list is checked 
* against a tree structure, to see, if all elements/part of elements are 
* already in the tree or if the chain is a continuation of a node in the tree.
*
* NOTE: The cert list is sorted starting from endcert up to
*       root/CA cert.
*
*
*  @param CertListDesc Pointer to certificate container structure
*  @param TreeStruc Tree to check against
*  @param DontChkDhPrivKey Diffie-Hellman private value check control
*                          (only for certificates with DH public key): <br>
*                          == 0 check if top certificate has valid
*                          private value <br>
*                          != 0 do not check if top certificate has
*                          valid private value
*  @param TestModeFlags Specific verify modes
*               to apply: <br>
*               Bit 0: 1 - Extended time
*               check enable <br>
*               Bit 1: ignored <br>
*               Bit 2: 1 - No issuer/subj match
*               checking <br>
*               Bit 3: 1 - No signat./keyusage
*               checking <br>
*               Bit 4: 1 - No BasicConstraints
*               checking <br>
*               Bit 5: 1 - No time validity
*               checking
*  @param VerifyErrorMode Return type for pInsertCnt parameter: <br>
*                          == 0 Index of error (cert) returned in pInsertCnt <br>
*                          != 0 pInsertCnt reflects number of certs to insert
*  @param pDeltaTimeArr Pointer to time array with delta time
*  @param pInsertCnt Number of certificates
*               to insert in tree/error index
*  @param pInsertStatus Pointer where to store insertion status: <br>
*                0 - may insert <br>
*               -1 - is a duplicate <br>
*               -2 - no root <br>
*               -3 - verify error <br>
*               -4 - malformed list <br>
*               -5 - has no PrivKey, 
*               but PrivKey needed
*               e.g. DH
*  @param pVfyResult Pointer where to store overall verify result
*  @param ppStatusArr Pointer to array for check status reports on a 
*                     per certificate basis
*
*  @return ASN1_OP_OK on success, error code otherwise
*/
extern "C"  int  ProcessInsertionCertListEX(HMEM_CTX_DEF
			CERTPARR * CertListDesc,
			CTREESTR * TreeStruc, int DontChkDhPrivKey,
			int TestModeFlags, int VerifyErrorMode,
			int* pDeltaTimeArr,
			int* pInsertCnt, int* pInsertStatus,
			int* pVfyResult, int** ppStatusArr)
{
  int Retcode;

  int ActCertIndex;

  int ListCertsCount;
  int CertIndex;
  int CertsCount;

  int IssuerCNIndex;
  int VfyCertsCount;

  int pTmpIndex[1];
  int pTmpErrIndex[1];

  X509CERT * pCert;

  X509CERT ** pCertListArr;
  X509CERT ** pVfyCertArr;
  //-----------------------------------------------
  // Check parameters
  //-----------------------------------------------
  if((CertListDesc == NULL) || (TreeStruc == NULL) ||
     (pInsertCnt == NULL) || (pInsertStatus == NULL) ||
     (pVfyResult == NULL) || (ppStatusArr== NULL))
    return(ASN1_INSERT_LIST_NULLPTR_ERR);

  ppStatusArr[0] = NULL;
  pVfyResult[0]  = ASN1_ENDCERT_NOT_USABLE_MASK;

  ListCertsCount = CertListDesc->Cnt;
  pCertListArr   = CertListDesc->ppArr;

  if(ListCertsCount <= 0)
    return(ASN1_INSERT_LIST_NO_CERTS);
  //-----------------------------------------------
  // Check if this is a root certificate or not
  //-----------------------------------------------
  pCert = pCertListArr[0];			// get start certificate
  if((pCert->Flags & SELF_SIGNED_MASK) != 0) // is a root !
  {
    //===============================================
    // found root certificate, process
    //===============================================
    pInsertCnt[0] = 0;			// Index of 1st certificate (Err. case)
    if(ListCertsCount != 1)
    {
      pInsertStatus[0] = -4;			//  misformed list
      return(ASN1_OP_OK);
    }
    //---------------------------------------------
    // Check if this root is already in the tree
    //---------------------------------------------
    CheckCertInTree(pCert,TreeStruc,ROOT_MATCH, pTmpIndex);
    if(pTmpIndex[0] >= 0)
    {
      pInsertStatus[0] = -1;			// is a duplicate
      return(ASN1_OP_OK);
    }
    //---------------------------------------------
    // Verify the root *NEW* Root certificate
    //---------------------------------------------
    Retcode = VerifyCertList(HMEM_CTX_REF1
		pCertListArr, ListCertsCount,
		TestModeFlags, pDeltaTimeArr, ppStatusArr,
		pVfyResult, pTmpErrIndex);
    if((Retcode != ASN1_OP_OK) || (pVfyResult[0] != 0))
    {
      pInsertStatus[0] = -3;		// signal verify Error        
      if(VerifyErrorMode != 0)		// should set the count to insert...
        pInsertCnt[0] = 1;
    }
    else
    {
      pInsertCnt[0] = 1;		// number of Certs to insert
      pInsertStatus[0] = 0;		// signal o.k.
    }
    return(Retcode);
  }
  else
  {
    //=======================================
    // is  n o t  a root certificate, process
    //=======================================
    pInsertCnt[0] = 1;			// at least one to insert
    //--------------------------------------------------------
    // If private key checking is active, check if certificate
    // is a special type (DH) and private key is present
    //-----------------------------------------------------
    if((DontChkDhPrivKey == 0) &&			// checking is active
       (pCert->PublicKeyType == DH_PUBLIC_ALGOR) &&	// is DH
       ((pCert->Flags & PRIV_KEY_MASK) == 0))	// but no private key
    {
      pInsertCnt[0] = 0;		// error in first one
      pInsertStatus[0] = -5;		// signal reason
      return(ASN1_OP_OK);
    }
    //-----------------------------------------------------
    // Certificate is not a special type, check if in tree
    //-----------------------------------------------------
    if(TreeStruc->CListCount == 0)	// no list, no check !
    {
      //--------------------------------------------------
      // case of empty tree, must be a full list to a root
      //--------------------------------------------------
      pCert = pCertListArr[ListCertsCount-1];	// get top certificate
      if((pCert->Flags & SELF_SIGNED_MASK) == 0) // is a  n o t root !
      {
        pInsertStatus[0] = -2;			// signal no root
	pInsertCnt[0] = ListCertsCount-1;	// set error locus
        return(ASN1_OP_OK);
      }
      pTmpErrIndex[0] = 0;
      Retcode = VerifyCertList(HMEM_CTX_REF1
		  pCertListArr, ListCertsCount,
		  TestModeFlags, pDeltaTimeArr,
		  ppStatusArr, pVfyResult, pTmpErrIndex);
      if((Retcode != ASN1_OP_OK) || (pVfyResult[0] != 0))
      {
        pInsertStatus[0] = -3;		// signal verify Error        

        if(VerifyErrorMode != 0)	// should set the count to insert...
          pInsertCnt[0] = ListCertsCount;
        else
          pInsertCnt[0] = pTmpErrIndex[0];// set error locus
      }
      else
      {
        pInsertCnt[0] = ListCertsCount;	// set insertion count
        pInsertStatus[0] = 0;		// signal o.k.
      }
      return(Retcode);
    }     
    //----------------------------------------------------------
    // Tree is not empty, check for duplicate certificate
    //----------------------------------------------------------
    CheckCertInTree(pCert,TreeStruc,ROOT_MATCH,pTmpIndex);
    if(pTmpIndex[0] >= 0)
    {
      pInsertCnt[0] = 0;			// set error locus
      pInsertStatus[0] = -1;			// is a duplicate
      return(ASN1_OP_OK);
    }
    //---------------------------------------------------------------
    // Search Issuer for the certificate List until found/end of list
    //---------------------------------------------------------------
    CertsCount = ListCertsCount;		// get total count
    CertIndex = 0;				// index at the first one
    for(;;)
    {
      CheckCertInTree(pCert,TreeStruc,CHAIN_MATCH,pTmpIndex);
      if(pTmpIndex[0] >= 0)			// found the issuer
        break;
      CertsCount--;				// not found, reduce count
      if(CertsCount == 0)			// no issuer found
      {
        //-------------------------------------------------------
	// no issuer found, check if last is a root certificate
        //-------------------------------------------------------
        if((pCert->Flags & SELF_SIGNED_MASK) == 0) // is not a root
        {
	  pInsertStatus[0] = -2;		// signal no root
	  pInsertCnt[0] = CertIndex;		// set error locus
	  return(ASN1_OP_OK);
	}
        //---------------------------------------------------------
	// last in list is root, verify complete list, down to root
        //---------------------------------------------------------
        pTmpErrIndex[0] = 0;
        Retcode = VerifyCertList(HMEM_CTX_REF1
		    pCertListArr, ListCertsCount,
		    TestModeFlags, pDeltaTimeArr,
		    ppStatusArr, pVfyResult, pTmpErrIndex);
        if((Retcode != ASN1_OP_OK) || (pVfyResult[0] != 0))
        {
          pInsertStatus[0] = -3;		// signal verify Error        
          if(VerifyErrorMode != 0)	// should set the count to insert...
            pInsertCnt[0] = ListCertsCount;
          else
            pInsertCnt[0] = pTmpErrIndex[0];	// set error locus
        }
        else
        {
          pInsertCnt[0]    = ListCertsCount;	// set count to insert
          pInsertStatus[0] = 0;			// signal o.k.
        }
        return(Retcode);
      }
      CertIndex++;				// pre-Increment
      pCert = pCertListArr[CertIndex];		// get next certificate
      pInsertCnt[0] ++;				// increment insertable count
    } // for
    //---------------------------------------------------------------
    // found an issuer in the list, construct verification list
    //---------------------------------------------------------------
    IssuerCNIndex = pTmpIndex[0];
    ListCertsCount = CertIndex+1;		// number of rel. list elements
    CertsCount = TreeStruc->CNodeArray[IssuerCNIndex+CN_LEVEL]+1; // get parents
    VfyCertsCount = ListCertsCount + CertsCount;	// sum up

    pVfyCertArr = (X509CERT **) BIT8_ARRAY_ALLOC(HMEM_CTX_REF,
				   sizeof(X509CERT *) * VfyCertsCount);
    if(pVfyCertArr == NULL)
      return(ASN1_INSERT_LIST_ALLOC_ERR);

    //---------------------------------------------------------
    // copy elements from given list and parents to verify list
    //---------------------------------------------------------
    CertIndex = 0;
    do
    {
      pVfyCertArr[CertIndex] = pCertListArr[CertIndex];	// copy from the list
      CertIndex++;
      ListCertsCount--;
    }while(ListCertsCount != 0);

    do
    {
      ActCertIndex =					// get index into list
          TreeStruc->CNodeArray[IssuerCNIndex+CN_CERTLIST_INDEX];
      pCert = TreeStruc->ppCertList[ActCertIndex];  // get certificate
      pVfyCertArr[CertIndex++] = pCert;			// insert
      
      IssuerCNIndex =
          TreeStruc->CNodeArray[IssuerCNIndex+CN_P_INDEX]; // get issuer
      CertsCount--;
    }while(CertsCount != 0);
    //---------------------------------------------------------
    // verify complete list, down to root
    //---------------------------------------------------------
    pTmpErrIndex[0] = 0;
    Retcode = VerifyCertList(HMEM_CTX_REF1
		    pVfyCertArr, VfyCertsCount,
		    TestModeFlags, pDeltaTimeArr,
		    ppStatusArr, pVfyResult, pTmpErrIndex);
    FREE_ARRAY(HMEM_CTX_REF,pVfyCertArr);
    if((Retcode != ASN1_OP_OK) || (pVfyResult[0] != 0))
    {
      pInsertStatus[0] = -3;		// signal verify Error        
      if(VerifyErrorMode == 0)		// should signal Error Index
        pInsertCnt[0] = pTmpErrIndex[0];// set error locus
    }
    else
    {
       pInsertStatus[0] = 0;			// signal o.k. (count IS set !)
    }
    return(Retcode);
  } // not root else
}

//()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()
//
// CRL related routines
//
//()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()

/**
* Frees a CRL entry structure and its elements (FreeCrlEntStruc).
*
*  @param pCrlEntStruc Target structure
*/
extern "C"  void  FreeCrlEntStruc(HMEM_CTX_DEF
					CRLENT * pCrlEntStruc)
{

  if(pCrlEntStruc == NULL)
    return;

  FreeIDATPARR_Struc(HMEM_CTX_REF1 pCrlEntStruc->pCertSerial);
  FREE_CARRAY(HMEM_CTX_REF,pCrlEntStruc->RevocationDate);
  FreeIDATPARR_Struc(HMEM_CTX_REF1 pCrlEntStruc->pEntryExtensions);
  FREE_CARRAY(HMEM_CTX_REF,pCrlEntStruc->InvalidityDate);
  FreeIDATPARR_Struc(HMEM_CTX_REF1 pCrlEntStruc->pCertIssuer);

  FREE_CARRAY(HMEM_CTX_REF,pCrlEntStruc);

}

/**
* Allocates a CRL entry structure and its elements (AllocCrlEntStruc).
*
*  @return Pointer to the new structure, NULL on error
*/
extern "C"  CRLENT *  AllocCrlEntStruc(HMEM_CTX_DEF1)
{
  int Retcode;

  IDATPARR* ppTmpDesc[1];
  CRLENT * pCrlEntStruc;
  //----------------------------------------------------
  // Allocate structure itself
  //----------------------------------------------------
  pCrlEntStruc = (CRLENT *) BIT8_ARRAY_CALLOC(HMEM_CTX_REF,
					1,sizeof(CRLENT));
  if(pCrlEntStruc == NULL)
    return(NULL);

  pCrlEntStruc->RevocationDateTimeType = -1;
  pCrlEntStruc->RevocReason = CRL_REVOC_REASON_INVALID;;
  //----------------------------------------------------
  // Allocate the elements
  //----------------------------------------------------
  for(;;)
  {
    if((Retcode = AllocIDATPARR_Struc(HMEM_CTX_REF1 ppTmpDesc,1)) != ASN1_OP_OK)
      break;
    pCrlEntStruc->pCertSerial = ppTmpDesc[0];

    if((Retcode = AllocIDATPARR_Struc(HMEM_CTX_REF1 ppTmpDesc,1)) != ASN1_OP_OK)
      break;
    pCrlEntStruc->pEntryExtensions = ppTmpDesc[0];

    if((Retcode = AllocIDATPARR_Struc(HMEM_CTX_REF1 ppTmpDesc,1)) != ASN1_OP_OK)
      break;
    pCrlEntStruc->pCertIssuer = ppTmpDesc[0];

    return(pCrlEntStruc);
  }
  FreeCrlEntStruc(HMEM_CTX_REF1 pCrlEntStruc);
  return(NULL);
}

/**
* Frees a CRL entry structure list and the elements in the list (FreeCrlEntriesList).
*
*  @param pCrlEntriesList Entry list to be freed
*  @param CrlEntriesCount Number of entries in the list
*/
extern "C"  void  FreeCrlEntriesList(HMEM_CTX_DEF
		CRLENT ** pCrlEntriesList, int CrlEntriesCount)
{
  int Index = 0;

  CRLENT * pActCrlEntStruc;

  if(pCrlEntriesList == NULL)
    return;

  while(Index < CrlEntriesCount)
  {
    pActCrlEntStruc = pCrlEntriesList[Index++];
    FreeCrlEntStruc(HMEM_CTX_REF1 pActCrlEntStruc);
  }

  FREE_CARRAY(HMEM_CTX_REF,pCrlEntriesList);
}

/**
* Frees a CRL structure and its elements (FreeCrlStruc).
*
*  @param pCrlStruc Structure to be freed.
*/
extern "C"  void  FreeCrlStruc(HMEM_CTX_DEF
				     CRLSTRU * pCrlStruc)
{

  if(pCrlStruc == NULL)
    return;

  FreeIDATPARR_Struc(HMEM_CTX_REF1 pCrlStruc->pSignatAlgPar);
  FreeIDATPARR_Struc(HMEM_CTX_REF1 pCrlStruc->pSignature);
  FreeIDATPARR_Struc(HMEM_CTX_REF1 pCrlStruc->pTBSCrl);
  FreeIDATPARR_Struc(HMEM_CTX_REF1 pCrlStruc->pTBSSignatAlgPar);

  FreeIDATPARR_Struc(HMEM_CTX_REF1 pCrlStruc->pIssuerName);
  FreeX501DN_Struc(HMEM_CTX_REF1 pCrlStruc->pIssuerDN);

  FREE_CARRAY(HMEM_CTX_REF,pCrlStruc->ThisUpdate);
  FREE_CARRAY(HMEM_CTX_REF,pCrlStruc->NextUpdate);

  FreeCrlEntriesList(HMEM_CTX_REF1
		     pCrlStruc->pRevokedCertsList,
		     pCrlStruc->RevokedCertsCount);

  FreeIDATPARR_Struc(HMEM_CTX_REF1 pCrlStruc->pCrlExtensions);

  FreeIDATPARR_Struc(HMEM_CTX_REF1 pCrlStruc->pCrlNumber);
  FreeIDATPARR_Struc(HMEM_CTX_REF1 pCrlStruc->pBaseCrlNumber);
  FreeIDATPARR_Struc(HMEM_CTX_REF1 pCrlStruc->pAuthKeyID);
  FreeIDATPARR_Struc(HMEM_CTX_REF1 pCrlStruc->pIssuerAltName);
  FreeIDATPARR_Struc(HMEM_CTX_REF1 pCrlStruc->pCrlDistPoint);

  FREE_CARRAY(HMEM_CTX_REF,pCrlStruc);

}

/**
* Allocates a CRL Entry structure and its elements (AllocCrlStruc).
*
*  @return Pointer to the new structure, NULL on error
*/
extern "C"  CRLSTRU *  AllocCrlStruc(HMEM_CTX_DEF1)
{
  int Retcode;

  IDATPARR* ppTmpDesc[1];
  CRLSTRU * pCrlStruc;
  //----------------------------------------------------
  // Allocate structure itself
  //----------------------------------------------------
  pCrlStruc = (CRLSTRU *) BIT8_ARRAY_CALLOC(HMEM_CTX_REF,1,sizeof(CRLSTRU));
  if(pCrlStruc == NULL)
    return(NULL);
  //----------------------------------------------------
  // Initialize some values
  //----------------------------------------------------
  pCrlStruc->SignatAlgor = INVALID_ALGOR;
  pCrlStruc->SignatType  = INVALID_ALGOR;

  pCrlStruc->Version        = INVALID_CRL_VERSION;
  pCrlStruc->TBSSignatAlgor = INVALID_ALGOR;
  pCrlStruc->TBSSignatType  = INVALID_ALGOR;

  pCrlStruc->ThisUpdateTimeType = -1;
  pCrlStruc->NextUpdateTimeType = -1;

  pCrlStruc->CrlNumber     = -1;
  pCrlStruc->BaseCrlNumber = -1;
  //---------------------------------------------------------
  // Allocate the elements needed
  // NOTE: we do NOT allocate elements for decoded extesnions
  //---------------------------------------------------------
  for(;;)
  {
    if((Retcode = AllocIDATPARR_Struc(HMEM_CTX_REF1 ppTmpDesc,2)) != ASN1_OP_OK)
      break;
    pCrlStruc->pSignatAlgPar = ppTmpDesc[0];

    if((Retcode = AllocIDATPARR_Struc(HMEM_CTX_REF1 ppTmpDesc,1)) != ASN1_OP_OK)
      break;
    pCrlStruc->pSignature = ppTmpDesc[0];

    if((Retcode = AllocIDATPARR_Struc(HMEM_CTX_REF1 ppTmpDesc,1)) != ASN1_OP_OK)
      break;
    pCrlStruc->pTBSCrl = ppTmpDesc[0];

    if((Retcode = AllocIDATPARR_Struc(HMEM_CTX_REF1 ppTmpDesc,2)) != ASN1_OP_OK)
      break;
    pCrlStruc->pTBSSignatAlgPar = ppTmpDesc[0];

    if((Retcode = AllocIDATPARR_Struc(HMEM_CTX_REF1 ppTmpDesc,1)) != ASN1_OP_OK)
      break;
    pCrlStruc->pIssuerName = ppTmpDesc[0];

    if((Retcode = AllocIDATPARR_Struc(HMEM_CTX_REF1 ppTmpDesc,1)) != ASN1_OP_OK)
      break;
    pCrlStruc->pCrlExtensions = ppTmpDesc[0];

    return(pCrlStruc);
  }
  FreeCrlStruc(HMEM_CTX_REF1 pCrlStruc);
  return(NULL);
}

/**
* Converts an ASN.1 Time encoding (UTC/Generaltime) to a newly allocated
* internal data array (FromASN1TimeToTimeArray).
*
* NOTE: If no source buffer is given or size <= 0,
*   no Array will be allocated. This simplifies conversion
*	 of OPTIONAL time types !
*
*  @param pSrcBuf Buffer with encoding/NULL
*  @param SrcOff start offset of data
*  @param SrcLen Size of data
*  @param pTimeType Decoded type / NULL
*  @param ppTimeArr Allocated, filled structure/NULL
*  @return 0  on success, error code otherwise
*/
static  int  FromASN1TimeToTimeArray(HMEM_CTX_DEF
		char* pSrcBuf, int SrcOff, int SrcLen,
		int* pTimeType, int** ppTimeArr)
{
  int Retcode;
  int TimeType;
  int Asn1TimeType;  

  int* pTimeArr;

  ppTimeArr[0] = NULL;

  //------------------------------------------------
  // Check if source data present at all
  //------------------------------------------------
  if((pSrcBuf == NULL) || (SrcLen <= 0))
  {
    if(pTimeType != NULL)
      pTimeType[0] = -1;			// not set
    return(ASN1_OP_OK);
  }
  //------------------------------------------------
  // Check what time type to use
  //------------------------------------------------
  Asn1TimeType = (int) pSrcBuf[SrcOff] & 0xFF;
  if(Asn1TimeType == ASN1_UNIVERSAL_UTC_TIMESTR)
    TimeType = ASN1_TIME_TYPE_UTC;
  else if(Asn1TimeType == ASN1_UNIVERSAL_GEN_TIMESTR)
    TimeType = ASN1_TIME_TYPE_GENTIME;
  else
    return(ASN1_FROM_TIMESTR_INV_TYPE);    

  if(pTimeType != NULL)
    pTimeType[0] = TimeType;
  //------------------------------------------------
  // Allocate Time Array
  //------------------------------------------------
  if((pTimeArr = INT_ARRAY_ALLOC(HMEM_CTX_REF,TIME_ARRAY_SIZE)) == NULL)
    return(ASN1_ALLOC_ERR);

  if((Retcode = ConvChkASN1_TimeStr(pSrcBuf,SrcOff+2,SrcLen-2,pTimeArr,TimeType)) != ASN1_OP_OK)
  {
    FREE_CARRAY(HMEM_CTX_REF,pTimeArr);
  }
  else
    ppTimeArr[0] = pTimeArr;

  return(Retcode);
}
/**
* Generates ASN.1 encoding of internal time array and writes it to a newly
* allocated buffer (FromTimeArrayToASN1Time).
*
*  @param pTimeArr Array in internal notation
*  @param TimeType 0 - UTC/General Time, check Year <br>
*               1 - UTC <br>
*               2 - General Time
*  @param ppDstBuf Allocated buffer with encoding
*  @param pDstLen Length of data in buffer
*  @return 0  on success, error code otherwise
*/
static  int  FromTimeArrayToASN1Time(HMEM_CTX_DEF
		int* pTimeArr, int TimeType,
		char** ppDstBuf, int* pDstLen)
{
  int Retcode;

  char* pDstBuf;
  int pTmpLen[1];
  //------------------------------------------------
  // Check parameters
  //------------------------------------------------
  if((pTimeArr == NULL) || (ppDstBuf == NULL) || (pDstLen == NULL))
    return(ASN1_NULL_PTR);
  if((TimeType < 0) || (TimeType > 2))
    return(ASN1_PARAM_ERR);

  ppDstBuf[0] = NULL;
  pDstLen[0]  = 0;
  //------------------------------------------------
  // Allocate destination buffer
  //------------------------------------------------
  if((pDstBuf = BIT8_ARRAY_ALLOC(HMEM_CTX_REF,
				 GENERAL_TIME_DEFAULT_LEN+10)) == NULL)
    return(ASN1_ALLOC_ERR);
  //------------------------------------------------
  // Get ASN.1 Time Type to use, set up
  //------------------------------------------------
  if(TimeType == 0)				// choose by value of year
  {
    if(pTimeArr[TIME_YEAR_INDEX] <= 2049)	// UTC mode
      TimeType = ASN1_TIME_TYPE_UTC;
    else
      TimeType = ASN1_TIME_TYPE_GENTIME;
  }
  if(TimeType == ASN1_TIME_TYPE_UTC)
    pDstBuf[0] = ASN1_UNIVERSAL_UTC_TIMESTR;
  else
    pDstBuf[0] = ASN1_UNIVERSAL_GEN_TIMESTR;
  //------------------------------------------------------
  // Generate the Time String
  //------------------------------------------------------
  TimeType--;					// set rel. 0 !!
  if((Retcode = GenerateTimeString(pTimeArr, pDstBuf, 2,
		  GENERAL_TIME_DEFAULT_LEN+8,pTmpLen,TimeType)) != ASN1_OP_OK)
  {
    FREE_CARRAY(HMEM_CTX_REF,pDstBuf);
    return(Retcode);
  }
  pDstBuf[1] = (char) pTmpLen[0];		// set ASN1 Length

  ppDstBuf[0] = pDstBuf;
  pDstLen[0]  = pTmpLen[0] + 2;
  return(Retcode);
}

/**
* Processes CRL-Entry extensions if present, checks for unrecognized
* critical extensions (FromCRLEntExtensions).
*
*  @param pCrlEntStruc Structure to process
*  @param pNotRecognizedCritical 0 - none found
*  @return 0  on success, error code otherwise
*/
static  int  FromCRLEntExtensions(HMEM_CTX_DEF
	CRLENT * pCrlEntStruc, int* pNotRecognizedCritical)
{
  int Retcode;
  int Index = 0;
  int ExtensionsCnt;
  int CriticalFlag;
  int OIDIndex;
  int ActExtDataIndex;
  int CtlElementCnt;
  int MaxDataIndex;
  int UnknownCriticalExtFlag = 0;
  int RevocReason;

  int pTmpVal[1];

  char * pCtlArray;

  int* ppTmpTimeArr[1];

  IDATA* pIdata;
  IDATA** pExtArr;
  IDATPARR* pExtDesc;
  IDATPARR* pDstDesc;
  IDATPARR* pHlpDesc = NULL;
  IDATPARR* ppTmpDesc[1];

  //--------------------------------------------
  // check parameters
  //--------------------------------------------
  if((pCrlEntStruc == NULL) || (pNotRecognizedCritical == NULL))
    return(ASN1_NULL_PTR);

  pNotRecognizedCritical[0] = 0;

  //----------------------------------------------------------
  // Check if extensions have to be processed
  //----------------------------------------------------------
  if(((pExtDesc = pCrlEntStruc->pEntryExtensions) == NULL) ||
      ((pExtArr  = pExtDesc->ppArr) == NULL) ||
      ((ExtensionsCnt = pExtDesc->Cnt/
			  X509_EXT_MAX_DATA_INDEX) <= 0))
    return(ASN1_OP_OK);
  //----------------------------------------------------------
  // Process the extensions
  //----------------------------------------------------------
  while(ExtensionsCnt != 0)
  {
    //--------------------------------------------------------
    // Check if Critical Flag is present for extension
    //--------------------------------------------------------
//  CriticalFlag = 0;
    if((Retcode = GetOptBoolValueFromDesc(pExtDesc,Index + X509_EXT_CRITICAL_INDEX,1,0,pTmpVal)) != ASN1_OP_OK)
      return(Retcode);
    CriticalFlag = pTmpVal[0];
    //--------------------------------------------------------------
    // Compare OID to known X509 extension (that could be processed)
    //--------------------------------------------------------------
    pIdata = pExtArr[Index + X509_EXT_OBJID_INDEX];

    if((Retcode = GetX509Ext_OidIndex(pIdata,pTmpVal)) != ASN1_OP_OK)
      return(Retcode);
    OIDIndex = pTmpVal[0];
    //-------------------------------------------------------
    // get extension data pointer, prepare for next extension
    //-------------------------------------------------------
    ActExtDataIndex = Index + X509_EXT_VALUE_INDEX;
//    pExtValIdata = pExtArr[Index + X509_EXT_VALUE_INDEX];
    Index += X509_EXT_MAX_DATA_INDEX;
    ExtensionsCnt--;
    //-----------------------------------------------------
    // Check if extension is recognized at all
    //-----------------------------------------------------
    if(OIDIndex < 0)			// not recognized
    {
      if(CriticalFlag != 0)		// was marked as critical !
        UnknownCriticalExtFlag = 1;	// set Flag
      continue;				// skip this extension
    }
    //-----------------------------------------------------
    // Extension has been recognized, distribute
    //-----------------------------------------------------

    switch(OIDIndex)
    {
      case OID_X509_EXT_REASON_CODE:
        pDstDesc  = NULL;
	pCtlArray = (char *) CRLEntryReasonCtl;
	CtlElementCnt = CRL_ENT_REASON_CTL_CNT;	
	MaxDataIndex  = CRL_ENTRY_REASON_MAX_DATA_INDEX;
        break;

      case OID_X509_EXT_INVALIDY_DATE:
        pDstDesc  = NULL;
	pCtlArray = (char *) CRLEntryInvalDateCtl;
	CtlElementCnt = CRL_ENT_INVAL_DATE_CTL_CNT;	
	MaxDataIndex  = CRL_ENTRY_IVDATE_MAX_DATA_INDEX;
        break;

      case OID_X509_EXT_CERT_ISSUER:
        pDstDesc  = pCrlEntStruc->pCertIssuer;
	pCtlArray = (char *) CRLEntryCertIssuerCtl;
	CtlElementCnt = CRL_ENT_CERT_ISSUER_CTL_CNT;	
	MaxDataIndex  = CRL_ENTRY_CERTISS_MAX_DATA_IND;
        break;

      //--------------------------------------------------------
      // Extensions that are not yet handled, check for critical
      //--------------------------------------------------------
      default:
        if(CriticalFlag != 0)		// was marked as critical !
          UnknownCriticalExtFlag = 1;	// set Flag
        continue;			// SKIP !!
    }
    //-----------------------------------------------------------
    // Extract, Split the Data according to parameters
    //-----------------------------------------------------------
    if(pDstDesc == NULL)
    {
      if((Retcode = AllocIDATPARR_Struc(HMEM_CTX_REF1 ppTmpDesc,1)) != ASN1_OP_OK)
        return(ASN1_ALLOC_ERR);
      pHlpDesc = ppTmpDesc[0];
    }
    else
    {
      pHlpDesc = NULL;
      ppTmpDesc[0] = pDstDesc;
    }
    if((Retcode = FromASN1_DescToDesc(HMEM_CTX_REF1 pExtDesc,ActExtDataIndex,pCtlArray,CtlElementCnt,MaxDataIndex,ASN1_SPLIT_X509_EXT_DATA_ERR,ppTmpDesc,NULL)) != ASN1_OP_OK)
    {
      FreeIDATPARR_Struc(HMEM_CTX_REF1 pHlpDesc);
      return(Retcode);
    }
    if(pDstDesc == NULL)			// prepare for freeing...
      pHlpDesc = ppTmpDesc[0];
    //------------------------------------------------------------
    // Put the new Descriptor back to the CRL Entry, postprocess
    //------------------------------------------------------------
    switch(OIDIndex)
    {
      //-------------------------------------------------
      // Revocation reason processing, get data, store
      //-------------------------------------------------
      case OID_X509_EXT_REASON_CODE:
        pIdata = ppTmpDesc[0]->ppArr[CRL_ENTRY_REASON_CODE_INDEX];

        pCrlEntStruc->RevocReason = CRL_REVOC_REASON_INVALID;

        if((pIdata->Base != NULL) && (pIdata->Len > 0))
        {
          RevocReason = (int)
            pIdata->Base[(int) pIdata->Off] & 0xFF;

          if((pIdata->Len != 1) ||
             (RevocReason == CRL_REVOC_REASON_UNUSED) ||
             (RevocReason > CRL_REVOC_REASON_REMOVE_CRL))
          {
            Retcode = ASN1_FROM_CRL_INVAL_REV_REASON; 
            break;
          }
          pCrlEntStruc->RevocReason = RevocReason;
        }
        break;

      //-------------------------------------------------
      // Invalidity date processing, get data, store
      //-------------------------------------------------
      case OID_X509_EXT_INVALIDY_DATE:
        pIdata = ppTmpDesc[0]->ppArr[CRL_ENTRY_INVAL_DATE_INDEX];
        Retcode = FromASN1_TimeString(HMEM_CTX_REF1
				      pIdata->Base,
				      (int) pIdata->Off,
				      pIdata->Len,
				      ppTmpTimeArr);

        if(Retcode == ASN1_OP_OK)
          pCrlEntStruc->InvalidityDate = ppTmpTimeArr[0];
        break;

      //-------------------------------------------------
      // Certificate issuer processing, get data, store
      //-------------------------------------------------
      case OID_X509_EXT_CERT_ISSUER:
        pCrlEntStruc->pCertIssuer = ppTmpDesc[0];
        break;
    }
    FreeIDATPARR_Struc(HMEM_CTX_REF1 pHlpDesc);
    pHlpDesc = NULL;

  }
  pNotRecognizedCritical[0] = UnknownCriticalExtFlag;
  return(ASN1_OP_OK);
}

/**
* Generates X.509 CRLReason extension from CRL entry structure (GenX509CrlReason).
*
*  @param pCrlEntStruc CRL entry structure
*  @param ppDesc IN: Descriptor to use
*               OUT: New descriptor
*  @return 0 on success, error code otherwise
*/
static  int  GenX509CrlReason(HMEM_CTX_DEF
		CRLENT * pCrlEntStruc, IDATPARR** ppDesc)
{
  int Retcode;

  char* pReasonBuf = NULL;

  char* ppTmpBuf[1];
  int pTmpLen[1];

  IDATA** pDstArr = NULL;
  IDATA** ppTmpDatArr[1];

  char TmpBuf[1];
  //--------------------------------------------------
  // Check parameters
  //--------------------------------------------------
  if((pCrlEntStruc == NULL) || (ppDesc == NULL))
    return(ASN1_NULL_PTR);

  //--------------------------------------------------
  // Get descriptor for ASN.1 conversion
  //--------------------------------------------------
  if((Retcode = AllocIDATA_Array(HMEM_CTX_REF1 ppTmpDatArr,CRL_ENTRY_REASON_MAX_DATA_INDEX)) != ASN1_OP_OK)
    return(Retcode);
  pDstArr = ppTmpDatArr[0];

  for(;;)
  {
    //--------------------------------------------------
    // Set value to use, convert to ASN.1 encoding
    //--------------------------------------------------
    TmpBuf[0] = (char) pCrlEntStruc->RevocReason;

    FromBufToDatArray(HMEM_CTX_REF1 pDstArr,CRL_ENTRY_REASON_CODE_INDEX,TmpBuf,0,1,0);

    if((Retcode = ToASN1(HMEM_CTX_REF1 pDstArr,0,(char *) CRLEntryReasonCtl,CRL_ENT_REASON_CTL_CNT,ppTmpBuf,pTmpLen)) != ASN1_OP_OK)
      break;

    pReasonBuf = ppTmpBuf[0];    
    //-----------------------------------------------------------
    // Generate the X.509 NON Critical extension Entry
    //-----------------------------------------------------------
    Retcode = GenX509Extension(HMEM_CTX_REF1
			       OID_X509_EXT_REASON_CODE, 0,
			       pReasonBuf, 0, pTmpLen[0], ppDesc);
    break;
  }
  //----------------------------------------------------
  // Free temporary buffers/structures
  //----------------------------------------------------
  FreeIDATA_Array(HMEM_CTX_REF1 pDstArr,CRL_ENTRY_REASON_MAX_DATA_INDEX,0);
  FREE_CARRAY(HMEM_CTX_REF,pReasonBuf);
  return(Retcode);
}

/**
* Generate X.509 CRL entry Invalidity date extension from
* CRL entry structure (GenX509CrlInvalidityDate).
*
*  @param pCrlEntStruc CRL entry structure
*  @param ppDesc IN: Descriptor to use <br>
*               OUT: New Descriptor
*  @return 0 on success, error code otherwise
*/
static  int  GenX509CrlInvalidityDate(HMEM_CTX_DEF
		CRLENT * pCrlEntStruc, IDATPARR** ppDesc)
{
  int Retcode;

  char* pTimeBuf = NULL;

  char* ppTmpBuf[1];
  int pTmpLen[1];
  //--------------------------------------------------
  // Check parameters
  //--------------------------------------------------
  if((pCrlEntStruc == NULL) || (ppDesc == NULL))
    return(ASN1_NULL_PTR);

  //--------------------------------------------------
  // Convert the time array to ASN.1 encoding
  //--------------------------------------------------
  for(;;)
  {  
    if((Retcode = FromTimeArrayToASN1Time(HMEM_CTX_REF1
			pCrlEntStruc->InvalidityDate,
			ASN1_TIME_TYPE_GENTIME,
			ppTmpBuf,pTmpLen)) != ASN1_OP_OK)
      break;
    pTimeBuf = ppTmpBuf[0];
    //-----------------------------------------------------------
    // Generate the X.509 NON Critical extension Entry
    //-----------------------------------------------------------
    Retcode = GenX509Extension(HMEM_CTX_REF1
			       OID_X509_EXT_INVALIDY_DATE, 0,
			       pTimeBuf, 0, pTmpLen[0], ppDesc);
    break;
  }
  //----------------------------------------------------
  // Free temporary buffers/structures
  //----------------------------------------------------
  FREE_CARRAY(HMEM_CTX_REF,pTimeBuf);
  return(Retcode);
}

/**
* Generates own X509 CRL entry extensions from given CRL entry
* structure (GenCrlEntX509Extensions).
*
* NOTE: Certificate issuer extension is copied if present.
*
*  @param pCrlEntStruc CRL entry structure
*  @return 0 on success, error code otherwise
*/
static  int  GenCrlEntX509Extensions(HMEM_CTX_DEF
						CRLENT * pCrlEntStruc)
{
  int Retcode = ASN1_OP_OK;

  int pTmpLen[1];
  int pTmpErrCode[1];
  char* ppTmpBuf[1];

  IDATA* pIdata;
  IDATPARR* ppTmpDesc[1];
  //--------------------------------------------------
  // Check parameters
  //--------------------------------------------------
  if(pCrlEntStruc == NULL)
    return(ASN1_NULL_PTR);
  //---------------------------------------------------------
  // Free eventually present extension structure, clear Flags
  //---------------------------------------------------------
  ppTmpDesc[0] = NULL;
  FreeIDATPARR_Struc(HMEM_CTX_REF1 pCrlEntStruc->pEntryExtensions);
  pCrlEntStruc->pEntryExtensions = NULL;

  for(;;)
  {
    //-----------------------------------------------------------------
    // Generate X.509 CRLReason extension if reason code given
    //-----------------------------------------------------------------
    if(pCrlEntStruc->RevocReason != CRL_REVOC_REASON_INVALID)
    {
      if((Retcode = GenX509CrlReason(HMEM_CTX_REF1
			pCrlEntStruc,ppTmpDesc)) != ASN1_OP_OK)
        break;
    }
    //-----------------------------------------------------------------
    // Generate X.509 CRL Invalidity date extension if date is set
    //-----------------------------------------------------------------
    if(pCrlEntStruc->InvalidityDate != NULL)
    {
      if((Retcode = GenX509CrlInvalidityDate(HMEM_CTX_REF1
			pCrlEntStruc, ppTmpDesc)) != ASN1_OP_OK)
        break;
    }
    //----------------------------------------------------------------
    // Generate X.509 CRL Cert Issuer Critical extension Entry if data
    //----------------------------------------------------------------
    if(pCrlEntStruc->pCertIssuer != NULL)
    {
      pIdata = pCrlEntStruc->pCertIssuer->ppArr[0];
      if((pIdata != NULL) && (pIdata->Base != NULL) &&
         (pIdata->Len > 0))
      {   
        if((Retcode = GenX509Extension(HMEM_CTX_REF1
			OID_X509_EXT_CERT_ISSUER, 1,
			pIdata->Base,
			(int) pIdata->Off,
			pIdata->Len,
			ppTmpDesc)) != ASN1_OP_OK)
          break;
      }
    }
    //--------------------------------------------------------------
    // ASN.1 encode the extensions if any set
    //--------------------------------------------------------------
    if((ppTmpDesc[0] != NULL) && (ppTmpDesc[0]->Cnt > 0))
    {
      Retcode = ToASN1_EXT(HMEM_CTX_REF1
			   ppTmpDesc[0]->ppArr,0,
			   ppTmpDesc[0]->Cnt,
			   ppTmpBuf,pTmpLen,pTmpErrCode);
      FreeIDATPARR_Struc(HMEM_CTX_REF1 ppTmpDesc[0]);
      ppTmpDesc[0] = NULL;

      if(Retcode != ASN1_OP_OK)
        break;

      if((Retcode = AllocIDATPARR_Struc(HMEM_CTX_REF1 ppTmpDesc,1)) != ASN1_OP_OK)
      {
        FREE_CARRAY(HMEM_CTX_REF,ppTmpBuf[0]);
        break;
      }
      ppTmpDesc[0]->Flags |= FREE_BIT_MASK;

      FromBufToDatArray(HMEM_CTX_REF1 ppTmpDesc[0]->ppArr,0,ppTmpBuf[0],0,pTmpLen[0],0);
    }
    break;
  }
  if(Retcode != ASN1_OP_OK)
  {
    FreeIDATPARR_Struc(HMEM_CTX_REF1 ppTmpDesc[0]);
    return(Retcode);
  }
  pCrlEntStruc->pEntryExtensions = ppTmpDesc[0];
  return(ASN1_OP_OK);
}

/**
* Processes an (already ASN.1 decoded) <code>IDATA</code> structure and puts
* content to a new CRL entry structure (ProcessCrlEntry).
*
*  @param pDatArr Array of <code>IDATA</code> structures
*  @param DatArrayIndex Start of data elements
*  @param ppCrlEntStruc Pointer for returning new structure
*  @return 0  on success, error code otherwise
*/
extern "C"  int  ProcessCrlEntry(HMEM_CTX_DEF
		IDATA** pDatArr, int DatArrayIndex,
		CRLENT ** ppCrlEntStruc)
{
  int Retcode;

  int pTmpCnt[1];
  int pTmpErr[1];
  int pTimeType[1];
  int* ppTimeArr[1];

  IDATA* pIdata;

  IDATPARR* ppTmpDesc[1];

  CRLENT * pCrlEntStruc;

  //--------------------------------------------
  // check parameters
  //--------------------------------------------
  if((pDatArr == NULL) || (ppCrlEntStruc == NULL))
    return(ASN1_NULL_PTR);

  ppCrlEntStruc[0] = NULL;

  //--------------------------------------------
  // allocate entry structure
  //--------------------------------------------
  if((pCrlEntStruc = AllocCrlEntStruc(HMEM_CTX_REF)) == NULL)
    return(ASN1_ALLOC_ERR);

  for(;;)
  {
    //---------------------------------------------------------
    // put elements to structure
    // 1. Copy serial number
    //---------------------------------------------------------
    if((Retcode = AllocCopyDatArrayElements(HMEM_CTX_REF1 pDatArr,DatArrayIndex+REVOKED_CERT_SERIAL_INDEX,pCrlEntStruc->pCertSerial->ppArr,0,1,1)) != ASN1_OP_OK)
      break;
    //---------------------------------------------------------
    // 2. Decode the revoked date to internal structure
    //---------------------------------------------------------
    pIdata = pDatArr[DatArrayIndex+REVOKED_CERT_DATE_INDEX];

    if((Retcode = FromASN1TimeToTimeArray(HMEM_CTX_REF1
				pIdata->Base,
				(int) pIdata->Off,
				pIdata->Len, pTimeType,
				ppTimeArr)) != ASN1_OP_OK)
      break;

    pCrlEntStruc->RevocationDate         = ppTimeArr[0];
    pCrlEntStruc->RevocationDateTimeType = pTimeType[0];
    //---------------------------------------------------------
    // 3. Subdecode CrlEntry extensions if present
    //---------------------------------------------------------
    pIdata = pDatArr[DatArrayIndex+REVOKED_CERT_EXT_INDEX];
    if((pIdata->Base != NULL) && (pIdata->Len > 0))
    {
      if((Retcode = FromASN1_EXT(HMEM_CTX_REF1 pIdata->Base,(int) pIdata->Off,pIdata->Len,ppTmpDesc,pTmpCnt,pTmpErr)) != ASN1_OP_OK)
        break;

      FreeIDATPARR_Struc(HMEM_CTX_REF1 pCrlEntStruc->pEntryExtensions);

      pCrlEntStruc->pEntryExtensions = ppTmpDesc[0];

      if((Retcode = FromCRLEntExtensions(HMEM_CTX_REF1
					 pCrlEntStruc,pTmpCnt)) != ASN1_OP_OK)
        break;

      if(pTmpCnt[0] != 0)
        pCrlEntStruc->ExtFlags |= CRLENT_EXT_UNRECOGN_CRIT_FLAG;

    }
    break;
  } // Error FOR
  if(Retcode != ASN1_OP_OK)
    FreeCrlEntStruc(HMEM_CTX_REF1 pCrlEntStruc);
  else
    ppCrlEntStruc[0] = pCrlEntStruc;

  return(Retcode);
}

/**
* Generates ASN.1 encoding of a CRL entry from given structure and puts it
* into a newly allocated buffer (ToAsn1CrlEntry).
*
*  @param pCrlEntStruc Source CRL entry structure
*  @param ppDstBuf Pointer for destination buffer
*  @param pDstLen Length of generated data
*  @return 0  on success, error code otherwise
*/
extern "C"  int  ToAsn1CrlEntry(HMEM_CTX_DEF
	CRLENT * pCrlEntStruc, char** ppDstBuf, int* pDstLen)
{
  int Retcode;

  char* pTimeBuf = NULL;
  char* ppTmpBuf[1];
  int pTmpLen[1];

  IDATA* pIdata;
  IDATA** pDstArr;
  IDATA** ppTmpArr[1];

  //--------------------------------------------
  // check parameters
  //--------------------------------------------
  if((pCrlEntStruc == NULL) || (ppDstBuf == NULL) || (pDstLen == NULL))
    return(ASN1_NULL_PTR);

  //--------------------------------------------------------
  // Allocate conversion array needed
  //--------------------------------------------------------
  if((Retcode = AllocIDATA_Array(HMEM_CTX_REF1 ppTmpArr,REVOKED_CERT_MAX_DATA_INDEX)) != ASN1_OP_OK)
    return(ASN1_ALLOC_ERR);

  pDstArr = ppTmpArr[0];

  for(;;)
  {
    //---------------------------------------------------------
    // 1. set up the certificate serial number
    //---------------------------------------------------------
    CopyIdataContents(pDstArr[REVOKED_CERT_SERIAL_INDEX],pCrlEntStruc->pCertSerial->ppArr[0]);

    //---------------------------------------------------------
    // 2. Generate Time encoding
    //---------------------------------------------------------
    if((Retcode = FromTimeArrayToASN1Time(HMEM_CTX_REF1
			pCrlEntStruc->RevocationDate,
			pCrlEntStruc->RevocationDateTimeType,
			ppTmpBuf,pTmpLen)) != ASN1_OP_OK)
      break;

    pTimeBuf = ppTmpBuf[0];

    pIdata = pDstArr[REVOKED_CERT_DATE_INDEX];
    pIdata->Base = pTimeBuf;
    pIdata->Off  = 0;
    pIdata->Len  = pTmpLen[0];

    //---------------------------------------------------------
    // 3. generate the entry extensions
    //---------------------------------------------------------
    if((Retcode = GenCrlEntX509Extensions(HMEM_CTX_REF1
					  pCrlEntStruc)) != ASN1_OP_OK)
      break;

    if(pCrlEntStruc->pEntryExtensions != NULL)
    {
      CopyIdataContents(pDstArr[REVOKED_CERT_EXT_INDEX],pCrlEntStruc->pEntryExtensions->ppArr[0]);
    }

    Retcode = ToASN1(HMEM_CTX_REF1 pDstArr,0,(char *) RevokedCertCtl,REVOKED_CERT_CTL_CNT,ppDstBuf,pDstLen);
    break;
  }
  FreeIDATA_Array(HMEM_CTX_REF1 pDstArr,REVOKED_CERT_MAX_DATA_INDEX,0);
  FREE_CARRAY(HMEM_CTX_REF,pTimeBuf);
  return(Retcode);
}

/**
* Converts a list of ASN.1 encoded Crl cert entries to a list of
* newly allocated internal structures (FromAsn1CertEntList).
*
* NOTE: The ASN.1 Encoding must have a surrounding SEQUENCE !!
*
*  @param pSrcBuf Buffer with encoding
*  @param SrcOff Start offset of data
*  @param SrcLen Size of data
*  @param ppCrlEntList Allocated, filled list
*  @param pCrlEntCount Number of elements in list
*  @return 0  on success, error code otherwise
*/
static  int  FromAsn1CertEntList(HMEM_CTX_DEF
		char* pSrcBuf, int SrcOff, int SrcLen,
		CRLENT *** ppCrlEntList, int* pCrlEntCount)
{
  int Retcode;
  int ListEntries;
  int DstIndex,SrcIndex;

  int pTmpOff[1];
  int pTmpLen[1];

  IDATA** pListArr = NULL;

  IDATPARR* pListDesc = NULL;
  IDATPARR* ppTmpDesc[1];

  CRLENT ** pCrlEntList = NULL;

  CRLENT * ppTmpCrlEnt[1];

  //--------------------------------------------
  // check parameters
  //--------------------------------------------
  if((pSrcBuf == NULL) || (ppCrlEntList == NULL) || (pCrlEntCount == NULL))
    return(ASN1_NULL_PTR);
  if(SrcLen <= 0)
    return(ASN1_PARAM_ERR);

  ppCrlEntList[0] = NULL;
  pCrlEntCount[0] = 0;

  //-------------------------------------------------
  // strip off surrounding SEQUENCE from the encoding
  //-------------------------------------------------
  if((Retcode = FromASN1_Sequence(HMEM_CTX_REF1 pSrcBuf,SrcOff,SrcLen,pTmpOff,pTmpLen)) != ASN1_OP_OK)
    return(Retcode);

  SrcOff = pTmpOff[0];
  SrcLen = pTmpLen[0];
  //-------------------------------------------------
  // Subdecode the CRL certificate entry elements
  //-------------------------------------------------
  if((Retcode = FromASN1_SubStr(HMEM_CTX_REF1 pSrcBuf,SrcOff,SrcLen,(char *) RevokedCertCtl,REVOKED_CERT_CTL_CNT,REVOKED_CERT_MAX_DATA_INDEX,ppTmpDesc,pTmpLen)) != ASN1_OP_OK)
    return(Retcode);

  pListDesc   = ppTmpDesc[0];
  pListArr    = pListDesc->ppArr;
  ListEntries = pTmpLen[0] / X509_EXT_MAX_DATA_INDEX;

  for(;;)
  {
    //-----------------------------------------------
    // Allocate List pointer array
    //-----------------------------------------------
    pCrlEntList = (CRLENT **) BIT8_ARRAY_CALLOC(HMEM_CTX_REF,
				    1,sizeof(CRLENT *)*ListEntries);
    if(pCrlEntList == NULL)
    {
      Retcode = ASN1_ALLOC_ERR;
      break;
    }
    //-----------------------------------------------
    // Convert all entries to structure
    //-----------------------------------------------
    SrcIndex = 0;
    DstIndex = 0;
    Retcode = ASN1_OP_OK;
    while(DstIndex < ListEntries)
    {
      if((Retcode = ProcessCrlEntry(HMEM_CTX_REF1
			pListArr, SrcIndex, ppTmpCrlEnt)) != ASN1_OP_OK)
        break;

      pCrlEntList[DstIndex] = ppTmpCrlEnt[0];
      SrcIndex += X509_EXT_MAX_DATA_INDEX;
      DstIndex++;
    }
    break;
  }
  FreeIDATPARR_Struc(HMEM_CTX_REF1 pListDesc);
  if(Retcode != ASN1_OP_OK)
    FreeCrlEntriesList(HMEM_CTX_REF1 pCrlEntList,ListEntries);
  else
  {
    ppCrlEntList[0] = pCrlEntList;
    pCrlEntCount[0] = ListEntries;
  }
  return(Retcode);
}

/**
* Converts a list of CRL certificate entry structures to ASN.1
* encoding (with surrounding SEQUENCE) in a newly allocated buffer (ToAsn1CertEntList).
*
*  @param pCrlEntList List of structures
*  @param CrlEntCount Number of elements
*  @param ppDstBuf Allocated, filled buffer
*  @param pDstLen Size of data
*  @return 0  on success, error code otherwise
*/
static  int  ToAsn1CertEntList(HMEM_CTX_DEF
		CRLENT ** pCrlEntList, int CrlEntCount,
		char** ppDstBuf, int* pDstLen)
{
  int Retcode;
  int TotalBufLen;
  int Index, DstIndex;

  char* pTotalBuf = NULL;

  IDATA* pIdata;
  IDATA** ppArr;

  IDATPARR* pListDesc = NULL;
  IDATPARR* ppTmpDesc[1];

  //--------------------------------------------
  // check parameters
  //--------------------------------------------
  if((pCrlEntList == NULL) || (ppDstBuf == NULL) || (pDstLen == NULL))
    return(ASN1_NULL_PTR);

  ppDstBuf[0] = NULL;
  pDstLen[0] = 0;

  if(CrlEntCount <= 0)
    return(ASN1_PARAM_ERR);
  //---------------------------------------------------------
  // Allocate descriptor for conversion, mark as freeable
  //---------------------------------------------------------
  if((Retcode = AllocIDATPARR_Struc(HMEM_CTX_REF1 ppTmpDesc,CrlEntCount)) != ASN1_OP_OK)
    return(Retcode);

  pListDesc = ppTmpDesc[0];

  pListDesc->Flags |= FREE_BIT_MASK;

  ppArr = pListDesc->ppArr;
  //---------------------------------------------------------
  // Convert the Crl entries list to ASN.1 encoded buffers
  //---------------------------------------------------------
  Retcode = ASN1_OP_OK;
  Index = 0;
  TotalBufLen = 0;
  while(Index < CrlEntCount)
  {
    //-------------------------------------------------------
    // Convert next entry to ASN.1
    //-------------------------------------------------------
    if((Retcode = ToAsn1CrlEntry(HMEM_CTX_REF1
			pCrlEntList[Index], ppDstBuf, pDstLen)) != ASN1_OP_OK)
      break;
    //---------------------------------------------------------
    // Store ASN.1 encoding to descriptor, advance buffer count
    //---------------------------------------------------------
    if((Retcode = FromBufToDatArray(HMEM_CTX_REF1 ppArr,Index,ppDstBuf[0],0,pDstLen[0],0)) != ASN1_OP_OK)
      break;
    TotalBufLen += pDstLen[0];
    Index++;
  }
  if(Retcode != ASN1_OP_OK)
  {
    FreeIDATPARR_Struc(HMEM_CTX_REF1 pListDesc);
    return(Retcode);
  }
  //-----------------------------------------------------------
  // Allocate combine buffer, concatenate ASN.1 encodings
  //-----------------------------------------------------------
  if((pTotalBuf = BIT8_ARRAY_ALLOC(HMEM_CTX_REF,TotalBufLen)) == NULL)
  {
    FreeIDATPARR_Struc(HMEM_CTX_REF1 pListDesc);
    return(ASN1_ALLOC_ERR);
  }
  Index = 0;
  DstIndex = 0;
  while(Index < CrlEntCount)
  {
    pIdata = ppArr[Index];
    memcpy(pTotalBuf+DstIndex,pIdata->Base+(int) pIdata->Off,pIdata->Len);
    DstIndex += pIdata->Len;
    Index++;
  }
  FreeIDATPARR_Struc(HMEM_CTX_REF1 pListDesc);
  //-----------------------------------------------------------
  // Wrap buffer into a sequence to get the list
  //-----------------------------------------------------------
  Retcode = ToASN1_Sequence(HMEM_CTX_REF1 pTotalBuf,0,TotalBufLen,ppDstBuf,pDstLen);
  FREE_CARRAY(HMEM_CTX_REF,pTotalBuf);
  return(Retcode);
}

/**
* Processes CRL extensions if present, checks for unrecognized
* critical extensions (FromCRLExtensions).
*
*  @param pCrlStruc Structure to process
*  @param pNotRecognizedCritical 0 - none found
*  @return 0  on success, error code otherwise
*/
static  int  FromCRLExtensions(HMEM_CTX_DEF
		CRLSTRU * pCrlStruc, int* pNotRecognizedCritical)
{
  int Retcode;
  int Index = 0;
  int ExtensionsCnt;
  int CriticalFlag;
  int OIDIndex;
  int ActExtDataIndex;
  int CtlElementCnt;
  int MaxDataIndex;
  int UnknownCriticalExtFlag = 0;
  int ExtFlags;

  int pTmpVal[1];
  int pTmpLong[1];

  char * pCtlArray;

  IDATA* pIdata;
  IDATA** pExtArr;
  IDATPARR* pExtDesc;
  IDATPARR* pDstDesc;
  IDATPARR* ppTmpDesc[1];

  //--------------------------------------------
  // check parameters
  //--------------------------------------------
  if((pCrlStruc == NULL) || (pNotRecognizedCritical == NULL))
    return(ASN1_NULL_PTR);

  pNotRecognizedCritical[0] = 0;

  //----------------------------------------------------------
  // Check if extensions have to be processed
  //----------------------------------------------------------
  if(((pExtDesc = pCrlStruc->pCrlExtensions) == NULL) ||
      ((pExtArr  = pExtDesc->ppArr) == NULL) ||
      ((ExtensionsCnt = pExtDesc->Cnt/
			  X509_EXT_MAX_DATA_INDEX) <= 0))
    return(ASN1_OP_OK);
  //----------------------------------------------------------
  // Process the extensions
  //----------------------------------------------------------
  while(ExtensionsCnt != 0)
  {
    //--------------------------------------------------------
    // Check if Critical Flag is present for extension
    //--------------------------------------------------------
//  CriticalFlag = 0;
    if((Retcode = GetOptBoolValueFromDesc(pExtDesc,Index + X509_EXT_CRITICAL_INDEX,1,0,pTmpVal)) != ASN1_OP_OK)
      return(Retcode);
    CriticalFlag = pTmpVal[0];
    //--------------------------------------------------------------
    // Compare OID to known X509 extension (that could be processed)
    //--------------------------------------------------------------
    pIdata = pExtArr[Index + X509_EXT_OBJID_INDEX];

    if((Retcode = GetX509Ext_OidIndex(pIdata,pTmpVal)) != ASN1_OP_OK)
      return(Retcode);
    OIDIndex = pTmpVal[0];
    //-------------------------------------------------------
    // get extension data pointer, prepare for next extension
    //-------------------------------------------------------
    ActExtDataIndex = Index + X509_EXT_VALUE_INDEX;
//    pExtValIdata = pExtArr[Index + X509_EXT_VALUE_INDEX];
    Index += X509_EXT_MAX_DATA_INDEX;
    ExtensionsCnt--;
    //-----------------------------------------------------
    // Check if extension is recognized at all
    //-----------------------------------------------------
    if(OIDIndex < 0)			// not recognized
    {
      if(CriticalFlag != 0)		// was marked as critical !
        UnknownCriticalExtFlag = 1;	// set Flag
      continue;				// skip this extension
    }
    //-----------------------------------------------------
    // extension has been recognized, distribute
    //-----------------------------------------------------

    switch(OIDIndex)
    {
      case OID_X509_EXT_CRL_NUMBER:
        pDstDesc  = pCrlStruc->pCrlNumber;
	pCtlArray = (char *) CRLNumberCtl;
	CtlElementCnt = CRL_EXT_NUMBER_CTL_CNT;	
	MaxDataIndex  = CRL_EXT_NUMBER_MAX_DATA_INDEX;
        break;

      case OID_X509_EXT_DELTA_CRL_IND:
        pDstDesc  = pCrlStruc->pBaseCrlNumber;
	pCtlArray = (char *) CRLDeltaCRLCtl;
	CtlElementCnt = CRL_EXT_DELTA_CRL_CTL_CNT;	
	MaxDataIndex  = CRL_EXT_BASE_NUM_MAX_DATA_INDEX;
        break;

      case OID_X509_EXT_ISS_DISTR_POINT:
        pDstDesc  = pCrlStruc->pCrlDistPoint;
	pCtlArray = (char *) CRLIssDistPointCtl;
	CtlElementCnt = CRL_EXT_ISS_DIST_POINT_CTL_CNT;	
	MaxDataIndex  = CRL_EXT_DISTPNT_MAX_DATA_INDEX;
        break;

      case OID_X509_EXT_AUTH_KEY_ID:
        pDstDesc  = pCrlStruc->pAuthKeyID;
	pCtlArray = (char *) AuthKeyIdExtCtl;
	CtlElementCnt = AUTH_KEY_ID_CTL_CNT;	
	MaxDataIndex  = AUTH_KEY_ID_MAX_DATA_INDEX;
        break;

      case OID_X509_EXT_ISSUER_ALT_NAME:
        pDstDesc  = pCrlStruc->pIssuerAltName;
	pCtlArray = (char *) AltNameExtCtl;
	CtlElementCnt = ALT_NAME_CTL_CNT;	
	MaxDataIndex  = ALT_NAMES_MAX_DATA_INDEX;
        break;

      //--------------------------------------------------------
      // Extensions that are not yet handled, check for critical
      //--------------------------------------------------------
      default:
        if(CriticalFlag != 0)		// was marked as critical !
          UnknownCriticalExtFlag = 1;	// set Flag
        continue;			// SKIP !!
    }
    //-----------------------------------------------------------
    // Extract, Split the Data according to parameters
    //-----------------------------------------------------------
    ppTmpDesc[0] = pDstDesc;
    if((Retcode = FromASN1_DescToDesc(HMEM_CTX_REF1 pExtDesc,ActExtDataIndex,pCtlArray,CtlElementCnt,MaxDataIndex,ASN1_SPLIT_X509_EXT_DATA_ERR,ppTmpDesc,NULL)) != ASN1_OP_OK)
       return(Retcode);
    //------------------------------------------------------------
    // Put the new Descriptor back to the CRL, postprocess
    //------------------------------------------------------------
    switch(OIDIndex)
    {
      //-------------------------------------------------
      // CRL Number, decode data
      //-------------------------------------------------
      case OID_X509_EXT_CRL_NUMBER:
        pCrlStruc->pCrlNumber = ppTmpDesc[0];
        pIdata = ppTmpDesc[0]->ppArr[CRL_EXT_NUMBER_INDEX];
        Retcode = ByteBufToUnsignedBIT32Num(pIdata->Base,(int) pIdata->Off,pIdata->Len,pTmpLong);
        if(Retcode == ASN1_OP_OK)
          pCrlStruc->CrlNumber = pTmpLong[0];
        break;
      //-------------------------------------------------
      // Delta CRL Indicator, get base CRL Number,
      //-------------------------------------------------
      case OID_X509_EXT_DELTA_CRL_IND:
        pCrlStruc->pBaseCrlNumber = ppTmpDesc[0];
        pIdata = ppTmpDesc[0]->ppArr[CRL_EXT_BASE_NUMBER_INDEX];
        Retcode = ByteBufToUnsignedBIT32Num(pIdata->Base,(int) pIdata->Off,pIdata->Len,pTmpLong);
        if(Retcode == ASN1_OP_OK)
          pCrlStruc->BaseCrlNumber = pTmpLong[0];
        break;
      //-------------------------------------------------
      // Authority Key ID, nothing to post process yet
      //-------------------------------------------------
      case OID_X509_EXT_AUTH_KEY_ID:
        pCrlStruc->pAuthKeyID = ppTmpDesc[0];
        break;

      //---------------------------------------------------
      // Issuer Alternate name, nothing to post process yet
      //---------------------------------------------------
      case OID_X509_EXT_ISSUER_ALT_NAME:
        pCrlStruc->pIssuerAltName = ppTmpDesc[0];
        break;

      //--------------------------------------------------
      // CRL Distribution point, extract the Flags/Reasons
      //--------------------------------------------------
      case OID_X509_EXT_ISS_DISTR_POINT:
        pCrlStruc->pCrlDistPoint = ppTmpDesc[0];
	ExtFlags = CRL_EXT_IS_DISTR_POINT_FLAG;
        if((Retcode = GetOptBoolValueFromDesc(ppTmpDesc[0],CRL_EXT_USER_CERTS_ONLY_INDEX,1,0,pTmpVal)) != ASN1_OP_OK)
	  break;
        if(pTmpVal[0] != 0)
	  ExtFlags |= CRL_EXT_ONLY_USER_CERTS_FLAG;

        if((Retcode = GetOptBoolValueFromDesc(ppTmpDesc[0],CRL_EXT_CA_CERTS_ONLY_INDEX,1,0,pTmpVal)) != ASN1_OP_OK)
	  break;
        if(pTmpVal[0] != 0)
	  ExtFlags |= CRL_EXT_ONLY_CA_CERTS_FLAG;

        if((Retcode = GetOptBoolValueFromDesc(ppTmpDesc[0],CRL_EXT_INDIRECT_CRL_INDEX,1,0,pTmpVal)) != ASN1_OP_OK)
	  break;
        if(pTmpVal[0] != 0)
	  ExtFlags |= CRL_EXT_INDIRECT_CRL_FLAG;

	pIdata = ppTmpDesc[0]->ppArr[CRL_EXT_SOME_REASONS_INDEX]; 
        if((pIdata->Base != NULL) && (pIdata->Len > 0))
        {
	  if((Retcode = GetBit32MsbBitsFromBitstring(pIdata->Base,(int) pIdata->Off,pIdata->Len,CRL_EXT_DIST_POINT_REASON_BITS,pTmpLong)) != ASN1_OP_OK)
            break;
	  ExtFlags |= (int) ((pTmpLong[0] >> 16) & 0x0FF00);
        }
        pCrlStruc->ExtFlags = ExtFlags;
	break;
    }
  }
  pNotRecognizedCritical[0] = UnknownCriticalExtFlag;
  return(ASN1_OP_OK);
}

/**
* Generates X.509 Authority Key Identifier extension from filled
* descriptor; used for CRLs (GenX509AuthKeyIDExt).
*
*  @param pSrcDesc Descriptor for conversion
*  @param ppDesc IN: Descriptor to use <br>
*               OUT: New Descriptor
*  @return 0 on success, error code otherwise
*/
static  int  GenX509AuthKeyIDExt(HMEM_CTX_DEF
		IDATPARR* pSrcDesc, IDATPARR** ppDesc)
{
  int Retcode;

  char* pValueBuf = NULL;

  char* ppTmpBuf[1];
  int pTmpLen[1];

  IDATA** pSrcArr;

  //--------------------------------------------------
  // Check parameters
  //--------------------------------------------------
  if((pSrcDesc == NULL) || (ppDesc == NULL))
    return(ASN1_NULL_PTR);

  //--------------------------------------------------------
  // Get the Conversion array, convert to ASN.1 encoding
  //--------------------------------------------------------
  if((pSrcArr = pSrcDesc->ppArr) == NULL)
    return(ASN1_NULL_PTR);

  if(pSrcDesc->Cnt != AUTH_KEY_ID_MAX_DATA_INDEX)
    return(ASN1_PARAM_ERR);

  if((Retcode = ToASN1(HMEM_CTX_REF1 pSrcArr,0,(char *) AuthKeyIdExtCtl,AUTH_KEY_ID_CTL_CNT,ppTmpBuf,pTmpLen)) != ASN1_OP_OK)
    return(Retcode);

  pValueBuf = ppTmpBuf[0];    
  //-----------------------------------------------------------
  // Generate the X.509 non Critical extension Entry
  //-----------------------------------------------------------
  Retcode = GenX509Extension(HMEM_CTX_REF1
			     OID_X509_EXT_AUTH_KEY_ID, 0,
			     pValueBuf, 0, pTmpLen[0], ppDesc);
  //----------------------------------------------------
  // Free temporary buffers/structures
  //----------------------------------------------------
  FREE_CARRAY(HMEM_CTX_REF,pValueBuf);
  return(Retcode);
}

/**
* Generates X.509 Issuer alternate name extension from filled
* descriptor; used for CRLs (GenX509IssuerAltNameExt).
*
*  @param pSrcDesc Descriptor for conversion
*  @param ppDesc IN: Descriptor to use <br>
*               OUT: New Descriptor
*  @return 0 on success, error code otherwise
*/
static  int  GenX509IssuerAltNameExt(HMEM_CTX_DEF
	IDATPARR* pSrcDesc, IDATPARR** ppDesc)
{
  int Retcode;

  char* pValueBuf = NULL;

  char* ppTmpBuf[1];
  int pTmpLen[1];

  IDATA** pSrcArr;

  //--------------------------------------------------
  // Check parameters
  //--------------------------------------------------
  if((pSrcDesc == NULL) || (ppDesc == NULL))
    return(ASN1_NULL_PTR);

  //--------------------------------------------------------
  // Get the Conversion array, convert to ASN.1 encoding
  //--------------------------------------------------------
  if((pSrcArr = pSrcDesc->ppArr) == NULL)
    return(ASN1_NULL_PTR);

  if(pSrcDesc->Cnt != ALT_NAMES_MAX_DATA_INDEX)
    return(ASN1_PARAM_ERR);

  if((Retcode = ToASN1(HMEM_CTX_REF1 pSrcArr,0,(char *) AltNameExtCtl,ALT_NAME_CTL_CNT,ppTmpBuf,pTmpLen)) != ASN1_OP_OK)
    return(Retcode);

  pValueBuf = ppTmpBuf[0];    
  //-----------------------------------------------------------
  // Generate the X.509 non Critical extension Entry
  //-----------------------------------------------------------
  Retcode = GenX509Extension(HMEM_CTX_REF1
			     OID_X509_EXT_ISSUER_ALT_NAME, 0,
			     pValueBuf, 0, pTmpLen[0], ppDesc);
  //----------------------------------------------------
  // Free temporary buffers/structures
  //----------------------------------------------------
  FREE_CARRAY(HMEM_CTX_REF,pValueBuf);
  return(Retcode);
}

/**
* Generates X.509 CRLNumber extension from CRL structure (GenX509CrlNumberExt).
*
*  @param pCrlStruc CRL entry structure
*  @param ppDesc IN: Descriptor to use <br>
*               OUT: New Descriptor
*  @return 0 on success, error code otherwise
*/
static  int  GenX509CrlNumberExt(HMEM_CTX_DEF
		CRLSTRU * pCrlStruc, IDATPARR** ppDesc)
{
  int Retcode;

  char* pNumberBuf = NULL;

  char* ppTmpBuf[1];
  int pTmpLen[1];

  IDATA** pDstArr;
  IDATA** ppTmpArr[1];

  //--------------------------------------------------
  // Check parameters
  //--------------------------------------------------
  if((pCrlStruc == NULL) || (ppDesc == NULL))
    return(ASN1_NULL_PTR);

  //--------------------------------------------------------
  // Allocate conversion array needed
  //--------------------------------------------------------
  if((Retcode = AllocIDATA_Array(HMEM_CTX_REF1 ppTmpArr,CRL_EXT_NUMBER_MAX_DATA_INDEX)) != ASN1_OP_OK)
    return(ASN1_ALLOC_ERR);

  pDstArr = ppTmpArr[0];

  for(;;)
  {
    //--------------------------------------------------
    // 1. Generate the value for the ASN.1 encoding
    //--------------------------------------------------
    if((Retcode = UnsignedBIT32NumToByteBuf(HMEM_CTX_REF1 pCrlStruc->CrlNumber,ppTmpBuf,pTmpLen)) != ASN1_OP_OK)
      break;

    FromBufToDatArray(HMEM_CTX_REF1 pDstArr,CRL_EXT_NUMBER_INDEX,ppTmpBuf[0],0,pTmpLen[0],0);	      

    //--------------------------------------------------
    // 2. Generate the Integer ASN.1 encoding
    //--------------------------------------------------
    if((Retcode = ToASN1(HMEM_CTX_REF1 pDstArr,0,(char *) CRLNumberCtl,CRL_EXT_NUMBER_CTL_CNT,ppTmpBuf,pTmpLen)) != ASN1_OP_OK)
      break;
    pNumberBuf = ppTmpBuf[0];
    //-----------------------------------------------------------
    // 3. Generate the X.509 NON Critical extension Entry
    //-----------------------------------------------------------
    Retcode = GenX509Extension(HMEM_CTX_REF1
			       OID_X509_EXT_CRL_NUMBER, 0,
			       pNumberBuf,0,pTmpLen[0],ppDesc);
    break;
  }
  //----------------------------------------------------
  // Free temporary buffers/structures
  //----------------------------------------------------
  FREE_CARRAY(HMEM_CTX_REF,pNumberBuf);
  FreeIDATA_Array(HMEM_CTX_REF1 pDstArr,CRL_EXT_NUMBER_MAX_DATA_INDEX,1);
  return(Retcode);
}

/**
* Generates X.509 Delta CRL extension from CRL structure (GenX509DeltaCrlIndicatorExt).
*
*  @param pCrlStruc CRL entry structure
*  @param ppDesc IN: Descriptor to use <br>
*               OUT: New Descriptor
*  @return 0 on success, error code otherwise
*/
static  int  GenX509DeltaCrlIndicatorExt(HMEM_CTX_DEF
		CRLSTRU * pCrlStruc, IDATPARR** ppDesc)
{
  int Retcode;

  char* pNumberBuf = NULL;

  char* ppTmpBuf[1];
  int pTmpLen[1];

  IDATA** pDstArr;
  IDATA** ppTmpArr[1];

  //--------------------------------------------------
  // Check parameters
  //--------------------------------------------------
  if((pCrlStruc == NULL) || (ppDesc == NULL))
    return(ASN1_NULL_PTR);

  //--------------------------------------------------------
  // Allocate conversion array needed
  //--------------------------------------------------------
  if((Retcode = AllocIDATA_Array(HMEM_CTX_REF1 ppTmpArr,CRL_EXT_BASE_NUM_MAX_DATA_INDEX)) != ASN1_OP_OK)
    return(ASN1_ALLOC_ERR);

  pDstArr = ppTmpArr[0];

  for(;;)
  {
    //--------------------------------------------------
    // 1. Generate the value for the ASN.1 encoding
    //--------------------------------------------------
    if((Retcode = UnsignedBIT32NumToByteBuf(HMEM_CTX_REF1 pCrlStruc->BaseCrlNumber,ppTmpBuf,pTmpLen)) != ASN1_OP_OK)
      break;

    FromBufToDatArray(HMEM_CTX_REF1 pDstArr,CRL_EXT_BASE_NUMBER_INDEX,ppTmpBuf[0],0,pTmpLen[0],0);	      

    //--------------------------------------------------
    // 2. Generate the Integer ASN.1 encoding
    //--------------------------------------------------
    if((Retcode = ToASN1(HMEM_CTX_REF1 pDstArr,0,(char *) CRLDeltaCRLCtl,CRL_EXT_DELTA_CRL_CTL_CNT,ppTmpBuf,pTmpLen)) != ASN1_OP_OK)
      break;
    pNumberBuf = ppTmpBuf[0];
    //-----------------------------------------------------------
    // 3. Generate the X.509 NON Critical extension Entry
    //-----------------------------------------------------------
    Retcode = GenX509Extension(HMEM_CTX_REF1
			       OID_X509_EXT_DELTA_CRL_IND, 0,
			       pNumberBuf,0,pTmpLen[0],ppDesc);
    break;
  }
  //----------------------------------------------------
  // Free temporary buffers/structures
  //----------------------------------------------------
  FREE_CARRAY(HMEM_CTX_REF,pNumberBuf);
  FreeIDATA_Array(HMEM_CTX_REF1 pDstArr,CRL_EXT_BASE_NUM_MAX_DATA_INDEX,1);
  return(Retcode);
}

/**
* Generates a possible optional ANS1 Boolean encoding (ToAsn1OptionalBoolVal).
*
* Note: The buffer for the option data is allocated and must be
*      freed !!!
*
*  @param pDatArr Array with entries
*  @param DatArrayIndex Slot to use
*  @param BoolValue 0 - set false, else true
*  @param OptionalFlag 0 - must be set, else default
*  @param DefaultValue 0 - false, else true is default
*  @return 0 on success, error code otherwise
*/
static  int  ToAsn1OptionalBoolVal(HMEM_CTX_DEF
		IDATA** pDatArr, int DatArrayIndex,
		int BoolValue, int OptionalFlag, int DefaultValue)
{
  int MustSetValue = 0;

  char* pDstBuf;
  IDATA* pIdata;

  //--------------------------------------------------
  // Check parameters
  //--------------------------------------------------
  if(pDatArr == NULL)
    return(ASN1_NULL_PTR);

  //----------------------------------------------------------
  // Check if the Boolean has to be set or is Optional/Default
  //----------------------------------------------------------
  if(OptionalFlag == 0)				// not optional
    MustSetValue = 1;
  else						// optional
  {
    if(((BoolValue == 0) && (DefaultValue != 0)) ||
       ((BoolValue != 0) && (DefaultValue == 0)))
      MustSetValue = 1;
  }
  //----------------------------------------------------------
  // Set the bool value if required
  //----------------------------------------------------------
  pIdata = pDatArr[DatArrayIndex];

  if(MustSetValue == 0)
  {
    pIdata->Len = 0;			// no value size !!
    return(ASN1_OP_OK);
  }
  if((pDstBuf = BIT8_ARRAY_ALLOC(HMEM_CTX_REF,3)) == NULL) // allocate buffer
    return(ASN1_ALLOC_ERR);

  pDstBuf[0] = ASN1_UNIVERSAL_BOOLEAN;		// Tag
  pDstBuf[1] = 1;				// Length
  if(BoolValue == 0)
    pDstBuf[0] = (unsigned char) 0x00;			// set FALSE
  else
    pDstBuf[2] = (unsigned char) 0xFF;			// set TRUE

  pIdata->Base = pDstBuf;
  pIdata->Off  = 0;
  pIdata->Len  = 3;
  return(ASN1_OP_OK);
}

/**
* Generates X.509 CRL Issuing distribution point extension from
* CRL entry structure (GenX509CrlDistrPointExt).
*
*  @param pCrlStruc CRL structure
*  @param ppDesc IN: Descriptor to use <br>
*               OUT: New Descriptor
*  @return 0 on success, error code otherwise
*/
static  int  GenX509CrlDistrPointExt(HMEM_CTX_DEF
		CRLSTRU * pCrlStruc, IDATPARR** ppDesc)
{
  int Retcode;
  int Flags;

  char* pValueBuf = NULL;

  char* ppTmpBuf[1];
  int pTmpLen[1];

  IDATA* pIdata;

  IDATA** pDstArr;

  IDATA** ppTmpArr[1];

  //--------------------------------------------------
  // Check parameters
  //--------------------------------------------------
  if((pCrlStruc == NULL) || (ppDesc == NULL))
    return(ASN1_NULL_PTR);

  //--------------------------------------------------------
  // Allocate conversion array needed
  //--------------------------------------------------------
  if((Retcode = AllocIDATA_Array(HMEM_CTX_REF1 ppTmpArr,CRL_EXT_DISTPNT_MAX_DATA_INDEX)) != ASN1_OP_OK)
    return(ASN1_ALLOC_ERR);

  pDstArr = ppTmpArr[0];

  for(;;)
  {
    //---------------------------------------------------------
    // 1. set up the Distribution point name if present
    //---------------------------------------------------------
    if(pCrlStruc->pCrlDistPoint != NULL)
    {
      pIdata = pCrlStruc->pCrlDistPoint->ppArr
	                      [CRL_EXT_DISTPNT_NAME_INDEX];
      if((pIdata->Base != NULL) && (pIdata->Len > 0))
      {
        if((Retcode = FromBufToDatArray(HMEM_CTX_REF1 pDstArr,CRL_EXT_DISTPNT_NAME_INDEX,pIdata->Base,(int) pIdata->Off,pIdata->Len,1)) != ASN1_OP_OK)
          break;
      }
    }
    //---------------------------------------------------------
    // 2. set up the Booleans from flags
    //---------------------------------------------------------
    Flags = pCrlStruc->ExtFlags;
    if((Retcode = ToAsn1OptionalBoolVal(HMEM_CTX_REF1
		pDstArr,CRL_EXT_USER_CERTS_ONLY_INDEX,
		(Flags & CRL_EXT_ONLY_USER_CERTS_FLAG), 1, 0)) != ASN1_OP_OK)
      break;

    if((Retcode = ToAsn1OptionalBoolVal(HMEM_CTX_REF1
		pDstArr,CRL_EXT_CA_CERTS_ONLY_INDEX,
		(Flags & CRL_EXT_ONLY_CA_CERTS_FLAG), 1, 0)) != ASN1_OP_OK)
      break;

    if((Retcode = ToAsn1OptionalBoolVal(HMEM_CTX_REF1
		pDstArr,CRL_EXT_INDIRECT_CRL_INDEX,
		(Flags & CRL_EXT_INDIRECT_CRL_FLAG), 1, 0)) != ASN1_OP_OK)
      break;
    //---------------------------------------------------------
    // 3. set up the Reasons from flags as bitstring
    //---------------------------------------------------------
    if((Retcode = ToASN1_32MsbBitsBitstringBuf(HMEM_CTX_REF1
				((int) Flags & 0x0FE00) << 16,
				ppTmpBuf, pTmpLen)) != ASN1_OP_OK)
      break;
    FromBufToDatArray(HMEM_CTX_REF1 pDstArr,CRL_EXT_SOME_REASONS_INDEX,ppTmpBuf[0],0,pTmpLen[0],0);
    //-------------------------------------------------------------
    // 4. generate the ASN.1 encoding of the extension value
    //-------------------------------------------------------------
    if((Retcode = ToASN1(HMEM_CTX_REF1 pDstArr,0,(char *) CRLIssDistPointCtl,CRL_EXT_ISS_DIST_POINT_CTL_CNT,ppTmpBuf,pTmpLen)) != ASN1_OP_OK)
      break;

    pValueBuf = ppTmpBuf[0];    
    //-----------------------------------------------------------
    // 5. Generate the X.509 *Critical* extension Entry
    //-----------------------------------------------------------
    Retcode = GenX509Extension(HMEM_CTX_REF1
			       OID_X509_EXT_CRL_NUMBER, 0,
			       pValueBuf, 0, pTmpLen[0], ppDesc);
    break;
  }
  //----------------------------------------------------
  // Free temporary buffers/structures
  //----------------------------------------------------
  FreeIDATA_Array(HMEM_CTX_REF1 pDstArr,CRL_EXT_DISTPNT_MAX_DATA_INDEX,1);
  FREE_CARRAY(HMEM_CTX_REF,pValueBuf);
  return(Retcode);
}

/**
* Generates own X509 CRL extensions from given CRL structure (ToAsn1CrlX509Extensions).
*
*  @param pCrlStruc CRL structure
*  @return 0 on success, error code otherwise
*/
static  int  ToAsn1CrlX509Extensions(HMEM_CTX_DEF
						CRLSTRU * pCrlStruc)
{
  int Retcode = ASN1_OP_OK;

  int pTmpLen[1];
  int pTmpErrCode[1];
  char* ppTmpBuf[1];

  IDATPARR* ppTmpDesc[1];
  //--------------------------------------------------
  // Check parameters
  //--------------------------------------------------
  if(pCrlStruc == NULL)
    return(ASN1_NULL_PTR);
  //---------------------------------------------------------
  // Free eventually present extension structure, clear Flags
  //---------------------------------------------------------
  ppTmpDesc[0] = NULL;
  FreeIDATPARR_Struc(HMEM_CTX_REF1 pCrlStruc->pCrlExtensions);
  pCrlStruc->pCrlExtensions = NULL;

  for(;;)
  {
    //-----------------------------------------------------------------
    // 1. Generate Authority key identifier extension if given
    //-----------------------------------------------------------------
    if(pCrlStruc->pAuthKeyID != NULL)
    {
      if((Retcode = GenX509AuthKeyIDExt(HMEM_CTX_REF1
				pCrlStruc->pAuthKeyID,
				ppTmpDesc)) != ASN1_OP_OK)
        break;
    }
    //-----------------------------------------------------------------
    // 2. Generate Issuer alternate name extension if given
    //-----------------------------------------------------------------
    if(pCrlStruc->pIssuerAltName != NULL)
    {
      if((Retcode = GenX509IssuerAltNameExt(HMEM_CTX_REF1
				pCrlStruc->pIssuerAltName,
				ppTmpDesc)) != ASN1_OP_OK)
        break;
    }
    //-----------------------------------------------------------------
    // 3. Generate CRL Number extension if given
    //-----------------------------------------------------------------
    if(pCrlStruc->CrlNumber >= 0)
    {
      if((Retcode = GenX509CrlNumberExt(HMEM_CTX_REF1
				pCrlStruc,ppTmpDesc)) != ASN1_OP_OK)
        break;
    }
    //-----------------------------------------------------------------
    // 4. Generate CRL Delta indicator extension if given
    //-----------------------------------------------------------------
    if(pCrlStruc->BaseCrlNumber >= 0)
    {
      if((Retcode = GenX509DeltaCrlIndicatorExt(HMEM_CTX_REF1
				pCrlStruc, ppTmpDesc)) != ASN1_OP_OK)
        break;
    }
    //-----------------------------------------------------------------
    // 5. Generate CRL Issuing distribution point extension if given
    //-----------------------------------------------------------------
    if((pCrlStruc->ExtFlags & CRL_EXT_IS_DISTR_POINT_FLAG) != 0)
    {
      if((Retcode = GenX509CrlDistrPointExt(HMEM_CTX_REF1
			pCrlStruc, ppTmpDesc)) != ASN1_OP_OK)
        break;
    }
    //--------------------------------------------------------------
    // 6. ASN.1 encode the extensions if any set
    //--------------------------------------------------------------
    if((ppTmpDesc[0] != NULL) && (ppTmpDesc[0]->Cnt > 0))
    {
      Retcode = ToASN1_EXT(HMEM_CTX_REF1
			   ppTmpDesc[0]->ppArr,0,
			   ppTmpDesc[0]->Cnt,
			   ppTmpBuf,pTmpLen,pTmpErrCode);
      FreeIDATPARR_Struc(HMEM_CTX_REF1 ppTmpDesc[0]);
      ppTmpDesc[0] = NULL;

      if(Retcode != ASN1_OP_OK)
        break;

      if((Retcode = AllocIDATPARR_Struc(HMEM_CTX_REF1 ppTmpDesc,1)) != ASN1_OP_OK)
      {
        FREE_CARRAY(HMEM_CTX_REF,ppTmpBuf[0]);
        break;
      }
      ppTmpDesc[0]->Flags |= FREE_BIT_MASK;

      FromBufToDatArray(HMEM_CTX_REF1 ppTmpDesc[0]->ppArr,0,ppTmpBuf[0],0,pTmpLen[0],0);
    }
    break;
  }
  if(Retcode != ASN1_OP_OK)
  {
    FreeIDATPARR_Struc(HMEM_CTX_REF1 ppTmpDesc[0]);
    return(Retcode);
  }
  pCrlStruc->pCrlExtensions = ppTmpDesc[0];
  return(ASN1_OP_OK);
}

/**
* Decodes an ASN.1 encoded TBS CRL and puts it into a given CRL structure (FromAsn1TBSCrl).
*
*  @param pSrcBuf Buffer with encoding
*  @param SrcOff Start of data
*  @param SrcLen Size of data
*  @param pCrlStruc Destination CRL structure
*  @return 0  on success, error code otherwise
*/
extern "C"  int  FromAsn1TBSCrl(HMEM_CTX_DEF
		char* pSrcBuf, int SrcOff, int SrcLen, CRLSTRU * pCrlStruc)
{
  int Retcode;
  int CRLVersion;

  int pTmpCnt[1];
  int pTmpType[1];
  int pTmpErr[1];
  int pTmpOff[1];

  int* ppTmpTimeArr[1];

  int pTmpBit32Val[1];

  IDATA* pIdata;
  IDATA** pTmpArr;
  
  IDATA** pDatArr = NULL;
  IDATA** ppTmpDatArr[1];
  IDATPARR* ppTmpDesc[1];

  X501_DN* ppTmpDnName[1];

  CRLENT ** ppTmpCrlEntList[1];

  //--------------------------------------------
  // check parameters
  //--------------------------------------------
  if((pSrcBuf == NULL) || (pCrlStruc == NULL))
    return(ASN1_NULL_PTR);
  if(SrcLen <= 0)
    return(ASN1_PARAM_ERR);

  for(;;)
  {
    //---------------------------------------------------------
    // allocate conversion structure needed, convert from ASN.1
    //---------------------------------------------------------
    if((Retcode = AllocIDATA_Array(HMEM_CTX_REF1 ppTmpDatArr,X509_TBS_CRL_MAX_DATA_INDEX)) != ASN1_OP_OK)
      break;

     pDatArr = ppTmpDatArr[0];

     if((Retcode = FromASN1(HMEM_CTX_REF1 pSrcBuf,SrcOff,SrcLen,(char *) X509_TBSCrlCtl,X509_TBS_CRL_CTL_CNT,pDatArr,0)) != ASN1_OP_OK)
       break;
    //---------------------------------------------------------
    // 1. Subdecode CRL ASN.1 version (need not be present)
    //---------------------------------------------------------
    CRLVersion = INVALID_CRL_VERSION;
    pIdata = pDatArr[X509_TBS_CRL_VERSION_INDEX];
    if((pIdata->Base == NULL) || (pIdata->Len <= 0))
    {
      CRLVersion = CRL_VERSION_DEFAULT;
    }
    else
    {
      if(pIdata->Len > 4)
      {
        Retcode = ASN1_FROM_TBS_CRL_INVAL_VERSNUM;
        break;
      }
      if((Retcode = ByteBufToUnsignedBIT32Num(pIdata->Base,(int) pIdata->Off,pIdata->Len,pTmpBit32Val)) != ASN1_OP_OK)
        break;

      CRLVersion = (int) pTmpBit32Val[0];
    }
    if((CRLVersion != CRL_VERSION_V1) &&
       (CRLVersion != CRL_VERSION_V2))
    {
      Retcode = ASN1_FROM_TBS_CRL_UNKOWN_VERS;
      break;
    }

    pCrlStruc->Version = CRLVersion;
    //---------------------------------------------------------
    // 2.1. Save Signature Algor ID and Params
    //---------------------------------------------------------
    if((Retcode = AllocCopyDatArrayElements(HMEM_CTX_REF1 pDatArr,X509_TBS_CRL_SIGN_ALG_ID_INDEX,pCrlStruc->pTBSSignatAlgPar->ppArr,0,2,1)) != ASN1_OP_OK)
      break;
    //---------------------------------------------------------
    // 2.2. Get Signature Algorithm and type
    //---------------------------------------------------------
    pTmpArr = pCrlStruc->pTBSSignatAlgPar->ppArr;

    if((Retcode = GetChkSignatTypeAlg(HMEM_CTX_REF1 pTmpArr[0],pTmpArr[1],pTmpCnt,pTmpType)) != ASN1_OP_OK)
      break;

    pCrlStruc->TBSSignatAlgor = pTmpCnt[0];
    pCrlStruc->TBSSignatType  = pTmpType[0];
    //---------------------------------------------------------
    // 3.1. Save Issuer name (raw) as copy (for the DN !!)
    //---------------------------------------------------------
    pIdata = pDatArr[X509_TBS_CRL_ISSUER_NAME_INDEX];

    if((Retcode = FromBufToDatArray(HMEM_CTX_REF1 pCrlStruc->pIssuerName->ppArr,0,pIdata->Base,(int) pIdata->Off,pIdata->Len,1)) != ASN1_OP_OK)
      break;
    //---------------------------------------------------------
    // 3.2. get the issuer's DN name as X501_DN structure
    //---------------------------------------------------------
    pIdata = pCrlStruc->pIssuerName->ppArr[0];

    if((Retcode = FromASN1_Sequence(HMEM_CTX_REF1 pIdata->Base,(int) pIdata->Off,pIdata->Len,pTmpOff,pTmpCnt)) != ASN1_OP_OK)

      break;

    if((Retcode = FromASN1_DN(HMEM_CTX_REF1 pIdata->Base,pTmpOff[0],pTmpCnt[0],ppTmpDnName)) != ASN1_OP_OK)
      break;

    pCrlStruc->pIssuerDN = ppTmpDnName[0];
    //----------------------------------------------------------
    // 4. Get ThisUpdate, decode
    //----------------------------------------------------------
    pIdata = pDatArr[X509_TBS_CRL_THIS_UPDATE_INDEX]; 

    if((Retcode = FromASN1TimeToTimeArray(HMEM_CTX_REF1
			pIdata->Base,
			(int) pIdata->Off,
			pIdata->Len,
			pTmpType, ppTmpTimeArr)) != ASN1_OP_OK)
      break;

    pCrlStruc->ThisUpdate         = ppTmpTimeArr[0];
    pCrlStruc->ThisUpdateTimeType = pTmpType[0];
    //----------------------------------------------------------
    // 5. Get NextUpdate (Optional), decode
    //----------------------------------------------------------
    pIdata = pDatArr[X509_TBS_CRL_NEXT_UPDATE_INDEX]; 

    if((Retcode = FromASN1TimeToTimeArray(HMEM_CTX_REF1
			pIdata->Base,
			(int) pIdata->Off,
			pIdata->Len,
			pTmpType, ppTmpTimeArr)) != ASN1_OP_OK)
      break;

    pCrlStruc->NextUpdate         = ppTmpTimeArr[0];
    pCrlStruc->NextUpdateTimeType = pTmpType[0];
    //----------------------------------------------------------
    // 6. Check if revoked certlist is present
    //----------------------------------------------------------
    pIdata = pDatArr[X509_TBS_CRL_REVOKD_CERTS_INDEX];
    if((pIdata->Base != NULL) && (pIdata->Len > 0))
    {
      //--------------------------------------------------------
      // Generate the Entry structures list
      //--------------------------------------------------------
      if((Retcode = FromAsn1CertEntList(HMEM_CTX_REF1
				pIdata->Base,
				(int) pIdata->Off,
				pIdata->Len,
				ppTmpCrlEntList, pTmpCnt)) != ASN1_OP_OK)
	break;

      pCrlStruc->pRevokedCertsList = ppTmpCrlEntList[0];
      pCrlStruc->RevokedCertsCount = pTmpCnt[0];
    }
    //----------------------------------------------------------
    // 7. Check if extensions are present
    //----------------------------------------------------------
    pIdata = pDatArr[X509_TBS_CRL_EXTENS_DATA_INDEX];
    if((pIdata->Base != NULL) && (pIdata->Len > 0))
    {
      if((Retcode = FromASN1_EXT(HMEM_CTX_REF1 pIdata->Base,(int) pIdata->Off,pIdata->Len,ppTmpDesc,pTmpCnt,pTmpErr)) != ASN1_OP_OK)
        break;

      FreeIDATPARR_Struc(HMEM_CTX_REF1 pCrlStruc->pCrlExtensions);

      pCrlStruc->pCrlExtensions = ppTmpDesc[0];

      if((Retcode = FromCRLExtensions(HMEM_CTX_REF1
				pCrlStruc, pTmpType)) != ASN1_OP_OK)
        break;
      if(pTmpType[0] != 0)		// unrecognized critical !!
        pCrlStruc->ExtFlags |= CRL_EXT_UNRECOGNIZED_CRIT_FLAG;
    }
    break;
  } // Error FOR
  FreeIDATA_Array(HMEM_CTX_REF1 pDatArr,X509_TBS_CRL_MAX_DATA_INDEX,0);
  return(Retcode);
}

/**
* Generates ASN.1 encoding of a TBS-CRL from a given structure (ToAsn1TBSCrl).
*
* Allocates the destination buffer.
*
*  @param pCrlStruc CRL structure to be encoded
*  @param ppDstBuf Destination buffer
*  @param pDstLen Length of data
*  @return 0  on success, error code otherwise
*/
extern "C"  int  ToAsn1TBSCrl(HMEM_CTX_DEF
		CRLSTRU * pCrlStruc, char** ppDstBuf, int* pDstLen)
{
  int Retcode;

  char* ppTmpBuf[1];
  int pTmpLen[1];

  IDATA* pIdata;
  IDATA** pDstArr;
  IDATA** ppTmpArr[1];

  //--------------------------------------------
  // check parameters
  //--------------------------------------------
  if((pCrlStruc == NULL) || (ppDstBuf == NULL) || (pDstLen == NULL))
    return(ASN1_NULL_PTR);

  //--------------------------------------------------------
  // Allocate conversion array needed
  //--------------------------------------------------------
  if((Retcode = AllocIDATA_Array(HMEM_CTX_REF1 ppTmpArr,X509_TBS_CRL_MAX_DATA_INDEX)) != ASN1_OP_OK)
    return(ASN1_ALLOC_ERR);

  pDstArr = ppTmpArr[0];

  for(;;)
  {
    //---------------------------------------------------------
    // 1. set up the TBS version number (if not the default)
    //---------------------------------------------------------
    if(pCrlStruc->Version > CRL_VERSION_V1)	// is not the default...
    {
      if((Retcode = UnsignedBIT32NumToByteBuf(HMEM_CTX_REF1 (int) pCrlStruc->Version,ppTmpBuf,pTmpLen)) != ASN1_OP_OK)
        break;

      FromBufToDatArray(HMEM_CTX_REF1 pDstArr,X509_TBS_CRL_VERSION_INDEX,ppTmpBuf[0],0,pTmpLen[0],0);
    }
    //-------------------------------------------------------------
    // 2. generate the TBS Signature type and Algorithm (as copy !)
    //-------------------------------------------------------------
    if((Retcode = SetTBSCertSignatAlgor(HMEM_CTX_REF1
			pCrlStruc->pTBSSignatAlgPar->ppArr,0,
			pDstArr,X509_TBS_CRL_SIGN_ALG_ID_INDEX,
			pCrlStruc->TBSSignatType)) != ASN1_OP_OK)
      break;

    //-------------------------------------------------------------
    // 3. generate the issuer name (as copy !)
    //    NOTE: we take NOT the DN descriptor but the RAW one !!
    //-------------------------------------------------------------
    pIdata = pCrlStruc->pIssuerName->ppArr[0];
    if((FromBufToDatArray(HMEM_CTX_REF1 pDstArr,X509_TBS_CRL_ISSUER_NAME_INDEX,pIdata->Base,(int) pIdata->Off,pIdata->Len,1)) != ASN1_OP_OK)
      break;

    //-------------------------------------------------------------
    // 4. generate the ThisUpdate time (as copy !)
    //-------------------------------------------------------------
    if((Retcode = FromTimeArrayToASN1Time(HMEM_CTX_REF1
			pCrlStruc->ThisUpdate,
			pCrlStruc->ThisUpdateTimeType,
			ppTmpBuf,pTmpLen)) != ASN1_OP_OK)
      break;

    FromBufToDatArray(HMEM_CTX_REF1 pDstArr,X509_TBS_CRL_THIS_UPDATE_INDEX,ppTmpBuf[0],0,pTmpLen[0],0);

    //-------------------------------------------------------------
    // 5. generate the NextUpdate time (as copy !) if present
    //-------------------------------------------------------------
    if(pCrlStruc->NextUpdate != NULL)
    {
      if((Retcode = FromTimeArrayToASN1Time(HMEM_CTX_REF1
			pCrlStruc->NextUpdate,
			pCrlStruc->NextUpdateTimeType,
			ppTmpBuf,pTmpLen)) != ASN1_OP_OK)
        break;

      FromBufToDatArray(HMEM_CTX_REF1 pDstArr,X509_TBS_CRL_NEXT_UPDATE_INDEX,ppTmpBuf[0],0,pTmpLen[0],0);

    }
    //-------------------------------------------------------------
    // 6. generate the Revoked certificates list if present
    //-------------------------------------------------------------
    if((pCrlStruc->pRevokedCertsList != NULL) &&
       (pCrlStruc->RevokedCertsCount > 0))
    {
      if((Retcode = ToAsn1CertEntList(HMEM_CTX_REF1
			pCrlStruc->pRevokedCertsList,
			pCrlStruc->RevokedCertsCount,
			ppTmpBuf,pTmpLen)) != ASN1_OP_OK)
        break;
    
      FromBufToDatArray(HMEM_CTX_REF1 pDstArr,X509_TBS_CRL_REVOKD_CERTS_INDEX,ppTmpBuf[0],0,pTmpLen[0],0);
    }
    //-------------------------------------------------------------
    // 7. generate the CRL extensions
    //-------------------------------------------------------------
    if((Retcode = ToAsn1CrlX509Extensions(HMEM_CTX_REF1
					  pCrlStruc)) != ASN1_OP_OK)
      break;

    if(pCrlStruc->pCrlExtensions != NULL)
    {
      pIdata = pCrlStruc->pCrlExtensions->ppArr[0];
      if((pIdata->Base != NULL) && (pIdata->Len > 0))
      {
        if((Retcode = FromBufToDatArray(HMEM_CTX_REF1 pDstArr,X509_TBS_CRL_EXTENS_DATA_INDEX,pIdata->Base,(int) pIdata->Off,pIdata->Len,1)) != ASN1_OP_OK)
          break;
      }
    }
    //-------------------------------------------------------------
    // 8. generate the ASN.1 encoding of the CRL-TBS
    //-------------------------------------------------------------
    Retcode = ToASN1(HMEM_CTX_REF1 pDstArr,0,(char *) X509_TBSCrlCtl,X509_TBS_CRL_CTL_CNT,ppDstBuf,pDstLen);
    break;
  }
  // NOTE: Must also free elements !!
  FreeIDATA_Array(HMEM_CTX_REF1 pDstArr,X509_TBS_CRL_MAX_DATA_INDEX,1);
  return(Retcode);
}
/**
* Decodes an ASN.1 encoded CRL and puts it into a given CRL structure (FromAsn1Crl).
*
*  @param pSrcBuf Buffer with encoding
*  @param SrcOff Start of data
*  @param SrcLen Size of data
*  @param pCrlStruc Destination CRL structure
*  @return 0  on success, error code otherwise
*/
extern "C"  int  FromAsn1Crl(HMEM_CTX_DEF
			char* pSrcBuf, int SrcOff, int SrcLen,
			CRLSTRU * pCrlStruc)
{
  int Retcode;

  int pTmpCnt[1];
  int pTmpType[1];

  IDATA* pIdata;
  IDATA** pTmpArr;
  
  IDATA** pDatArr = NULL;
  IDATA** ppTmpDatArr[1];

  //--------------------------------------------
  // check parameters
  //--------------------------------------------
  if((pSrcBuf == NULL) || (pCrlStruc == NULL))
    return(ASN1_NULL_PTR);
  if(SrcLen <= 0)
    return(ASN1_PARAM_ERR);

  for(;;)
  {
    //---------------------------------------------------------
    // allocate conversion structure needed, convert from ASN.1
    //---------------------------------------------------------
    if((Retcode = AllocIDATA_Array(HMEM_CTX_REF1 ppTmpDatArr,X509_CRL_MAX_DATA_INDEX)) != ASN1_OP_OK)
      break;

     pDatArr = ppTmpDatArr[0];

     if((Retcode = FromASN1(HMEM_CTX_REF1 pSrcBuf,SrcOff,SrcLen,(char *) X509CrlCtl,X509_CRL_CTL_CNT,pDatArr,0)) != ASN1_OP_OK)
       break;
    //---------------------------------------------------------
    // 1. Copy TBS-CRL entry to structure
    //---------------------------------------------------------
    if((Retcode = AllocCopyDatArrayElements(HMEM_CTX_REF1 pDatArr,X509_CRL_TBS_CRL_INDEX,pCrlStruc->pTBSCrl->ppArr,0,1,1)) != ASN1_OP_OK)
      break;
    //---------------------------------------------------------
    // 2.1. Save Signature Algor ID and Params
    //---------------------------------------------------------
    if((Retcode = AllocCopyDatArrayElements(HMEM_CTX_REF1 pDatArr,X509_CRL_SIGNAT_ALGOR_ID_INDEX,pCrlStruc->pSignatAlgPar->ppArr,0,2,1)) != ASN1_OP_OK)
      break;
    //---------------------------------------------------------
    // 2.2. Get Signature Algorithm and type
    //---------------------------------------------------------
    pTmpArr = pCrlStruc->pSignatAlgPar->ppArr;

    if((Retcode = GetChkSignatTypeAlg(HMEM_CTX_REF1 pTmpArr[0],pTmpArr[1],pTmpCnt,pTmpType)) != ASN1_OP_OK)
      break;

    pCrlStruc->SignatAlgor = pTmpCnt[0];
    pCrlStruc->SignatType  = pTmpType[0];
    //---------------------------------------------------------
    // 3. Copy Signature to structure
    //---------------------------------------------------------
    if((Retcode = AllocCopyDatArrayElements(HMEM_CTX_REF1 pDatArr,X509_CRL_SIGNAT_DATA_INDEX,pCrlStruc->pSignature->ppArr,0,1,1)) != ASN1_OP_OK)
      break;
    //---------------------------------------------------------
    // 4. Process the TBS-CRL
    //---------------------------------------------------------
    pIdata = pCrlStruc->pTBSCrl->ppArr[0];

    if((Retcode = FromAsn1TBSCrl(HMEM_CTX_REF1
				 pIdata->Base,
				 (int) pIdata->Off,
				 pIdata->Len,
				 pCrlStruc)) != ASN1_OP_OK)
      break;
    //---------------------------------------------------------
    // 5. Check that the signature Algor and Type match
    //---------------------------------------------------------
    if((pCrlStruc->SignatAlgor != pCrlStruc->TBSSignatAlgor) ||
       (pCrlStruc->SignatType != pCrlStruc->TBSSignatType))
    {
      Retcode = ASN1_FROM_CRL_SIGALGOR_MISMATCH;
      break;
    }
    //---------------------------------------------------------
    // 6. Check if there are any unknown critical extensions
    //---------------------------------------------------------

    break;
  } // Error FOR
  FreeIDATA_Array(HMEM_CTX_REF1 pDatArr,X509_CRL_MAX_DATA_INDEX,0);
  return(Retcode);
}

/**
* Matches a given hash (SHA-1) against a certificates public keys hash (MatchCertPubKeyHash).
*
*  @param pCert Certificate to check
*  @param pHashBuf Buffer with SHA1 hash of key
* 
*  @param pResult Result (ASN1_SAME/NOT_SAME)
*  @return 0 on success, error code otherwise
*/
extern int  MatchCertPubKeyHash(X509CERT * pCert,
		char* pHashBuf, int* pResult)
{

  IDATA* pIdata;

  int ShaArray[SHA_ARRAY_SIZE];
  char DigestBuf[SHA_DIGEST_LEN];

  //-----------------------------------------------------
  // Check parameters
  //-----------------------------------------------------
  if((pCert == NULL) || (pHashBuf == NULL) || (pResult == NULL))
    return(ASN1_NULL_PTR);

  pResult[0] = ASN1_NOT_SAME;

  //------------------------------------------------------
  // Calculate the certificate public key hash
  //------------------------------------------------------
  pIdata = pCert->PubKeyValueOcsp->ppArr[0];
  if((pIdata->Base == NULL) || (pIdata->Len <= 0))
    return(ASN1_MATCH_HASH_NO_CERT_PUBKEY);

  SHA1_Init(ShaArray);
  SHA1_Update(ShaArray,pIdata->Base,(int) pIdata->Off,pIdata->Len);
  SHA1_Final(ShaArray,DigestBuf,0);

  pResult[0] = CmpBit8Arrays(pHashBuf,0,DigestBuf,0,SHA_DIGEST_LEN);
  return(ASN1_OP_OK);
}
/**
* Matches a given X501 Distinguished Name against a certificate subject (MatchCertSubjName).
*
*  @param pCert Certificate to check
*  @param pDNName DN Name to match
*  @param pResult Result (ASN1_SAME/NOT_SAME)
*  @return 0 on success, error code otherwise
*/
extern int  MatchCertSubjName(X509CERT * pCert,
		X501_DN* pDNName, int* pResult)
{

  //-----------------------------------------------------
  // Check parameters
  //-----------------------------------------------------
  if((pCert == NULL) || (pDNName == NULL) || (pResult == NULL))
    return(ASN1_NULL_PTR);

  return(MatchX501_DNs(pDNName,pCert->Subject,pResult));
}

/**
* Finds a certificate in a part (subtree) of the certificate tree that
* matches a given Subject name or public key hash (FindCertInSubTree).
*
* NOTE: No parameters checked.
*
*  @param pDNName DN-name / NULL
*  @param pHashBuf Buffer with SHA1 hash
*  @param Mode == 0 - from DN <br>
*               != 0 - from Hash
*  @param pCertTree Tree from CDB file
*  @param pIndexArray Type array to use
*  @param CertsCount Elements in index array
*  @param pCNIndex Index of found certificate, -1, if no match
*  @return 0 on success, error code otherwise
*/
extern int  FindCertInSubTree(X501_DN* pDNName,
		char* pHashBuf, int Mode,
		CTREESTR * pCertTree, int* pIndexArray,
		int CertsCount, int* pCNIndex)
{
  int Retcode;
  int ArrayIndex;
  int ActCNIndex;
  int ActCertIndex;
  X509CERT * pActCert;

  int pTmpResult[1];

  pCNIndex[0] = -1;
  //------------------------------------------------------
  // Search for Root subject to cert issuer match
  //------------------------------------------------------
  ArrayIndex = 0;
  while(CertsCount > 0)
  {
    ActCNIndex = pIndexArray[ArrayIndex]; 	// get index into CNode Array
    ActCertIndex =				// get index into list
       pCertTree->CNodeArray[ActCNIndex+CN_CERTLIST_INDEX];

    pActCert = pCertTree->ppCertList[ActCertIndex];
							// get pointer to cert

    if(Mode == 0)
      Retcode = MatchCertSubjName(pActCert,pDNName,pTmpResult);
    else
      Retcode = MatchCertPubKeyHash(pActCert,pHashBuf,pTmpResult);

    if(Retcode != ASN1_OP_OK)
      return(Retcode);

    if(pTmpResult[0] == ASN1_SAME)
    {
      pCNIndex[0] = ActCNIndex;
      return(Retcode);
    }
    ArrayIndex++;
    CertsCount--;
  }
  return(ASN1_OP_OK);			// none found
}

/**
* Finds a certificate in the certificate tree that matches a given
* Subject name or public key hash (FindCertInTree). 
* This is needed to get the
* certificate for OCSP response signature checking.
* Only RSA and DSS certificates are checked.
*
* NOTE: No parameters checked.
*
*  @param pDNName DN-name / NULL
*  @param pHashBuf Buffer with SHA1 hash
*  @param Mode == 0 - from DN <br>
*               != 0 - from Hash
*  @param Range == 0 - CAs, SubCAs only <br>
*               <> 0 - all
*  @param pCertTree Tree from CDB file
*  @param pCNIndex Index of found certificate, -1, if no match
*  @return 0 on success, error code otherwise
*/
extern int  FindCertInTree(X501_DN* pDNName, char* pHashBuf,
		int Mode, int Range, CTREESTR * pCertTree, int* pCNIndex)
{
  int Retcode;

  //------------------------------------------------------
  // 1. Search the Sub CA certificate list
  //------------------------------------------------------
  if((Retcode =  FindCertInSubTree(pDNName, pHashBuf, Mode, pCertTree,
                                   pCertTree->SubCaIndexArray,
			           pCertTree->SubCaCount,
				   pCNIndex)) != ASN1_OP_OK)
    return(Retcode);
   if(pCNIndex[0] >= 0)
     return(ASN1_OP_OK);
  //------------------------------------------------------
  // 2. Search the CA certificate list
  //------------------------------------------------------
  if((Retcode =  FindCertInSubTree(pDNName, pHashBuf, Mode, pCertTree,
                                   pCertTree->RootCaIndexArray,
			           pCertTree->RootCaCount,
				   pCNIndex)) != ASN1_OP_OK)
    return(Retcode);

  if(pCNIndex[0] >= 0)
    return(ASN1_OP_OK);
 
  if(Range == 0)
    return(ASN1_OP_OK);
  //------------------------------------------------------
  // 3. Search the RSA Endcertificates list
  //------------------------------------------------------
  if((Retcode =  FindCertInSubTree(pDNName, pHashBuf, Mode, pCertTree,
                                   pCertTree->EndRsaIndexArray,
			           pCertTree->EndRsaCount,
				   pCNIndex)) != ASN1_OP_OK)
    return(Retcode);

  if(pCNIndex[0] >= 0)
    return(ASN1_OP_OK);
  //------------------------------------------------------
  // 4. Search the DSS Endcertificates list
  //------------------------------------------------------
  if((Retcode =  FindCertInSubTree(pDNName, pHashBuf, Mode, pCertTree,
                                   pCertTree->EndDssIndexArray,
			           pCertTree->EndDssCount,
				   pCNIndex)) != ASN1_OP_OK)
    return(Retcode);

  if(pCNIndex[0] >= 0)
    return(ASN1_OP_OK);
  //------------------------------------------------------
  // 5. Search the RSA Root certificates list
  //------------------------------------------------------
  if((Retcode =  FindCertInSubTree(pDNName, pHashBuf, Mode, pCertTree,
                                   pCertTree->RootEndRsaIndexArray,
			           pCertTree->RootEndRsaCount,
				   pCNIndex)) != ASN1_OP_OK)
    return(Retcode);

  if(pCNIndex[0] >= 0)
    return(ASN1_OP_OK);

  //------------------------------------------------------
  // 6. Search the DSS Root certificates list
  //------------------------------------------------------
  if((Retcode =  FindCertInSubTree(pDNName, pHashBuf, Mode, pCertTree,
                                   pCertTree->RootEndDssIndexArray,
			           pCertTree->RootEndDssCount,
				   pCNIndex)) != ASN1_OP_OK)
    return(Retcode);

  return(ASN1_OP_OK);
}

/**
* Constructs a new certificate chain (End to Root) from given
* X501 Distinguished Name or given Public Key (SHA-1) hash (GenCertChainForNameOrHash).
* This is needed to get the cert for signature verification of
* an OCSP Response and also validity checking.
*
* NOTE: The certificates in the chain may NOT be freed !!!
* 
*  @param pDNName DN-name / NULL
*  @param pHashBuf Buffer with SHA1 hash
*  @param Mode == 0 - from DN <br>
*               != 0 - from Hash
*  @param pCertTree Tree from CDB file
*  @param ppCertChain Chain, array of certs
*  @param pCertsCount Number of elemens
*  @return 0 on success, error code otherwise
*/
extern "C" int  GenCertChainForNameOrHash(HMEM_CTX_DEF
		X501_DN* pDNName,
		char* pHashBuf, int Mode, CTREESTR * pCertTree,
		X509CERT *** ppCertChain, int* pCertsCount)
{ 
  int Retcode;

  int CertCNIndex;
  int CertsCount;
  int ActCNIndex, LastCNIndex;
  int ActCertIndex;
  int ChainIndex;

  int* pCNArray;
  int pTmpCNIndex[1];

  X509CERT * pActCert;
  X509CERT ** pTreeCertList = NULL;
  X509CERT ** pCertChain = NULL;

  //-----------------------------------------------------
  // Check parameters
  //-----------------------------------------------------
  if(((Mode == 0) && (pDNName == NULL)) ||
     ((Mode != 0) && (pHashBuf == NULL)) ||
     (pCertTree == NULL) || (ppCertChain == NULL) || (pCertsCount == NULL))
    return(ASN1_NULL_PTR);

  ppCertChain[0] = NULL;
  pCertsCount[0] = 0;

  //-----------------------------------------------------------------
  // Find a certificate from the tree to match either X501-DN or hash
  // Note: All certificates are checked !!!
  //-----------------------------------------------------------------
  if((Retcode = FindCertInTree(pDNName, pHashBuf, Mode, 1, pCertTree,
				pTmpCNIndex)) != ASN1_OP_OK)
    return(Retcode);

  CertCNIndex = pTmpCNIndex[0];

  if(CertCNIndex < 0)				// none found, no tree !
    return(ASN1_OP_OK);
  //-----------------------------------------------------------------
  // found the appropriate certificate, construct the list
  //-----------------------------------------------------------------
  pCNArray      = pCertTree->CNodeArray;
  CertsCount    = pCNArray[CertCNIndex + CN_LEVEL]+1;	// get level+ base
  pTreeCertList = pCertTree->ppCertList;		// get list

  pCertChain = (X509CERT **) BIT8_ARRAY_ALLOC(HMEM_CTX_REF,
					    CertsCount*sizeof(X509CERT *));
  if(pCertChain == NULL)
    return(ASN1_ALLOC_ERR);
  //-------------------------------------------------------
  // put certificates from the tree to the chain array
  //-------------------------------------------------------
  ActCNIndex = CertCNIndex;

  ChainIndex = 0;
  while(ChainIndex < CertsCount)
  {
    LastCNIndex = ActCNIndex;

    ActCertIndex =					// get index into list
       pCNArray[ActCNIndex+CN_CERTLIST_INDEX];

    pActCert = pTreeCertList[ActCertIndex];		// get pointer to cert
    pCertChain[ChainIndex++] = pActCert;

    ActCNIndex = pCNArray[LastCNIndex+CN_P_INDEX];	// Index of next
    if(ActCNIndex < 0)					// already at root...
      break;
  }
  ppCertChain[0] = pCertChain;
  pCertsCount[0] = CertsCount;
  return(ASN1_OP_OK);
}

/**
* Verifies the signature of a CRL (VerifyCrlSignature).
*<ol>
* <li> Find certificate for CRL issuer in Tree by DN
* <li> Build certificate chain down to root
* <li> Verify the certificate chain (Validity)
* <li> Verify the CRL signature
*</ol>
* NOTE: The certificates in the chain may NOT be freed.
* 
*  @param pCrlStruc CRL structure
*  @param pCertTree Tree from CDB file
*  @return 0 on success, error code otherwise
*/
extern "C"  int  VerifyCrlSignature(HMEM_CTX_DEF
			CRLSTRU * pCrlStruc, CTREESTR * pCertTree)
{
  int Retcode;
  int CertsCount;
  int ChainStatus = 0;
  int VerifyStatus;
  int PublicAlgor;
  int SignatType;
  int SignRetcode;

  int MessageOffset, MessageLen;
  int SignatOffset, SignatLen;

  char* pMessageBase;
  char* pSignatBase;

  IDATA* pIdata;

  int pTmpCnt[1];
//  INTARRAY(pTmpResult,1);
  int pTmpRootIndex[1];

  int pTmpResult[1];

  IDATPARR* pPubParVals;

  X509CERT * pSignCert;
  X509CERT ** pCertChain = NULL;
  X509CERT ** ppTmpChain[1];

  RSA_STRUC* pRsaStruc[1];
  DSA_STRUC* pDsaStruc[1];

  //-----------------------------------------------------
  // Check parameters
  //-----------------------------------------------------
  if((pCrlStruc == NULL) || (pCertTree == NULL))
    return(ASN1_NULL_PTR);

  //-----------------------------------------------------
  // Generate the certificate chain for the CRL issuer
  //-----------------------------------------------------
  if((Retcode = GenCertChainForNameOrHash(HMEM_CTX_REF1
		  pCrlStruc->pIssuerDN, NULL, 0,
		  pCertTree, ppTmpChain, pTmpCnt)) != ASN1_OP_OK)
    return(Retcode);

  pCertChain = ppTmpChain[0];
  CertsCount = pTmpCnt[0];

  if(CertsCount <= 0)
  {
    pCrlStruc->SignatVerifyState = CRL_SIGNAT_NO_CERT;
    return(ASN1_OP_OK);
  }
  for(;;)
  {
    //-----------------------------------------------------------
    // A certificate chain has been retrieved, verify the chain
    //-----------------------------------------------------------
    if((Retcode = VerifyCertificateChainNew(HMEM_CTX_REF1 pCertChain,CertsCount,pCertTree,0,pTmpResult,pTmpCnt,pTmpRootIndex)) != ASN1_OP_OK)
      break;

    pCrlStruc->SignatChainResult = (int) pTmpResult[0];
    pCrlStruc->SignatChainReason = pTmpCnt[0];
    if((pTmpResult[0] == 0) && (pTmpCnt[0] == 0))
      ChainStatus = 1;
    //-----------------------------------------------------------
    // First certificate in chain has the public key to use
    // Check that signature algorithm matches cert's public algor
    //-----------------------------------------------------------
    pSignCert = pCertChain[0];
    PublicAlgor = pSignCert->PublicKeyType;
    pPubParVals = pSignCert->SubjPubKeyParVal;

    pIdata = pCrlStruc->pTBSCrl->ppArr[0];
    pMessageBase  = pIdata->Base;
    MessageOffset = (int) pIdata->Off;
    MessageLen    = pIdata->Len;

    pIdata = pCrlStruc->pSignature->ppArr[0];
    pSignatBase   = pIdata->Base;
    SignatOffset  = (int) pIdata->Off;
    SignatLen     = pIdata->Len;

    SignatType = pCrlStruc->SignatType;

    if(PublicAlgor != pCrlStruc->SignatAlgor)
    {
      pCrlStruc->SignatVerifyState = CRL_SIGNAT_INV_ALGOR; 
      break;
    }
    //----------------------------------------------------------------
    // Distribute according to signature Algorithm
    //----------------------------------------------------------------
    switch(PublicAlgor)
    {
      //--------------------------------------------------------------
      // Signature type RSA, get the RSA structure from params
      //--------------------------------------------------------------
      case RSA_PUBLIC_ALGOR:
        if((Retcode = FromArrayDescToRSAPubParams(HMEM_CTX_REF1 pPubParVals,pRsaStruc)) != ASN1_OP_OK)
          break;

        pTmpCnt[0] = SignatLen;

        SignRetcode = RSA_sign(HMEM_CTX_REF1 SignatType,pMessageBase,MessageOffset,MessageLen,pSignatBase,SignatOffset,pTmpCnt,pRsaStruc[0],1);
        RSA_Free(HMEM_CTX_REF1 pRsaStruc[0]);

        VerifyStatus = CRL_SIGNAT_BAD;
        if(SignRetcode == RSA_OP_OK)
        {
          if(ChainStatus == 0)			// problem with chain
            VerifyStatus = CRL_SIGNAT_CHAIN_PROBLEM;
          else
            VerifyStatus = CRL_SIGNAT_VERIFY_OK;
        }
        pCrlStruc->SignatVerifyState = VerifyStatus;
        break;
      //--------------------------------------------------------------
      // Signature type DSA, check presence of parameters, verify
      //--------------------------------------------------------------
      case DSA_PUBLIC_ALGOR:
        if((Retcode = FromArrayDescToDSAPubParams(HMEM_CTX_REF1 pPubParVals,pDsaStruc)) != ASN1_OP_OK)
          break;

	SignRetcode = DSA_Verify(HMEM_CTX_REF1 pMessageBase,MessageOffset,MessageLen,pSignatBase,SignatOffset,SignatLen,pDsaStruc[0],0);
        DSA_Free(HMEM_CTX_REF1 pDsaStruc[0]);

        VerifyStatus = CRL_SIGNAT_BAD;
        if(SignRetcode == DSA_OP_OK)
        {
          if(ChainStatus == 0)			// problem with chain
            VerifyStatus = CRL_SIGNAT_CHAIN_PROBLEM;
          else
            VerifyStatus = CRL_SIGNAT_VERIFY_OK;
        }
        pCrlStruc->SignatVerifyState = VerifyStatus;
        break;

      default:
        pCrlStruc->SignatVerifyState = CRL_SIGNAT_INV_ALGOR;
        break;
    }
    break;
  }
  FREE_CARRAY(HMEM_CTX_REF,pCertChain);
  return(Retcode);
}

/**
* Signs data with the private key from a given certificate and puts the result
* in a newly allocated buffer (SignTBSFromCert).
* Used for CRLs.
*
*  @param pCert Certificate with priv. key
*  @param SignatType Type of signature to apply,
*               if < 0 use default for
*               private key type
*  @param pMessageBuf Message to sign
*  @param MessageOff Start of message data
*  @param MessageLen Size of data
*  @param ppDstBuf Allocated buffer
*  @param pDstLen Size of data
*  @param pUsedSignatType actual used sign. type/NULL
*  @return 0 on success, error code otherwise
*/
static  int  SignTBSFromCert(HMEM_CTX_DEF
		X509CERT * pCert, int SignatType,
		char* pMessageBuf, int MessageOff, int MessageLen,
		char** ppDstBuf, int* pDstLen, int* pUsedSignatType)
{
  int Retcode;
  int PrivKeyAlgor;

  RSA_STRUC* ppTmpRsaStruc[1];
  DSA_STRUC* ppTmpDsaStruc[1];

  //-----------------------------------------------------
  // Check parameters
  //-----------------------------------------------------
  if((pCert == NULL) || (pMessageBuf == NULL) ||
     (ppDstBuf == NULL) || (pDstLen == NULL))
    return(ASN1_NULL_PTR);

  ppDstBuf[0] = NULL;
  pDstLen[0]  = 0;

  //-----------------------------------------------------
  // Check if certificate has a usable private key, get
  // the key data for signing
  //-----------------------------------------------------
  ppTmpRsaStruc[0] = NULL;
  ppTmpDsaStruc[0] = NULL;

  PrivKeyAlgor = pCert->PrivKeyType;

  switch(PrivKeyAlgor)
  {
    case RSA_PUBLIC_ALGOR:
      if(SignatType < 0)		// should use default
        SignatType = PKCS1_SHA1_WITH_RSA_ENC;
      else
      {
        if((SignatType != PKCS1_MD2_WITH_RSA_ENC) &&
           (SignatType != PKCS1_MD5_WITH_RSA_ENC) &&
           (SignatType != PKCS1_SHA1_WITH_RSA_ENC) &&
           (SignatType != TELESEC_RSA_WITH_RIPEMD160) &&
           (SignatType != PKCS1_SHA256_WITH_RSA_ENC) &&
           (SignatType != PKCS1_SHA384_WITH_RSA_ENC) &&
           (SignatType != PKCS1_SHA512_WITH_RSA_ENC) &&
           (SignatType != PKCS1_SHA224_WITH_RSA_ENC))
          return(ASN1_SIGN_TBS_INVALID_SIG_ALG);
      }
      if((Retcode = FromArrayDescToRSAPrivParams(HMEM_CTX_REF1 pCert->PrivKeyData,ppTmpRsaStruc)) != ASN1_OP_OK)
        return(Retcode);
      break;

    case DSA_PUBLIC_ALGOR:
      if(SignatType < 0)		// should use default
        SignatType = X957_DSA_WITH_SHA1;
      else
      {
        if(SignatType != X957_DSA_WITH_SHA1)
          return(ASN1_SIGN_TBS_INVALID_SIG_ALG);
      }
      if((Retcode = FromArrayDescToDSAPrivParams(HMEM_CTX_REF1 pCert->PrivKeyData,ppTmpDsaStruc)) != ASN1_OP_OK)
        return(Retcode);
      break;

    default:
      return(ASN1_SIGN_TBS_INVALID_KEYTYPE);
  }
  //----------------------------------------------------------
  // Sign the TBS data with the appropriate key and algor type
  //----------------------------------------------------------
  if(pUsedSignatType != NULL)
    pUsedSignatType[0] = SignatType;
  Retcode = SignTBSData(HMEM_CTX_REF1 pMessageBuf,MessageOff,MessageLen,ppTmpRsaStruc[0],ppTmpDsaStruc[0],SignatType,ppDstBuf,pDstLen);
  RSA_Free(HMEM_CTX_REF1 ppTmpRsaStruc[0]);
  DSA_Free(HMEM_CTX_REF1 ppTmpDsaStruc[0]);
  return(Retcode);
}

/**
* Decodes a signed CRL ASN.1 encoding and puts the elements to a newly 
* allocated structure (FromAsn1SignedCrl). 
* If a certificate tree is given, tries to verify the CRL
* signature.
*
*  @param pSrcBuf Buffer with encoding
*  @param SrcOff Start of data
*  @param SrcLen Size of data
*  @param pCertTree Tree of certificates
*  @param ppCrlStruc Pointer to return new CRL structure
*  @return 0  on success, error code otherwise
*/
extern "C"  int  FromAsn1SignedCrl(HMEM_CTX_DEF
	char* pSrcBuf, int SrcOff,
	int SrcLen, CTREESTR * pCertTree, CRLSTRU ** ppCrlStruc)
{
  int Retcode = ASN1_OP_OK;

  CRLSTRU * pCrlStruc = NULL;
  //--------------------------------------------
  // check parameters
  //--------------------------------------------
  if((pSrcBuf == NULL) || (ppCrlStruc == NULL))
    return(ASN1_NULL_PTR);
  if(SrcLen <= 0)
    return(ASN1_PARAM_ERR);

  ppCrlStruc[0] = NULL;
  //--------------------------------------------
  // Allocate a CRL structure to use
  //--------------------------------------------
  if((pCrlStruc = AllocCrlStruc(HMEM_CTX_REF)) == NULL)
    return(ASN1_ALLOC_ERR);

  for(;;)
  {
    //--------------------------------------------
    // 1. ASN.1 decode the CRL now
    //--------------------------------------------
    if((Retcode = FromAsn1Crl(HMEM_CTX_REF1
			      pSrcBuf, SrcOff, SrcLen,
			      pCrlStruc)) != ASN1_OP_OK)
      break;
    //----------------------------------------------
    // 2. When certificate tree given, try to verify
    //----------------------------------------------
    if(pCertTree != NULL)
    {
      if((Retcode = VerifyCrlSignature(HMEM_CTX_REF1
				       pCrlStruc,pCertTree)) != ASN1_OP_OK)
        break;
    }
    break;
  } // Error FOR

  if(Retcode != ASN1_OP_OK)
    FreeCrlStruc(HMEM_CTX_REF1 pCrlStruc);
  else
    ppCrlStruc[0] = pCrlStruc;
  return(Retcode);
}

/**
* Generates ASN.1 encoding of a signed CRL from a given structure and stores it
* to a newly allocated buffer (ToAsn1SignedCrl).
*
*  @param pCrlStruc Pointer to CRL structure
*  @param pCert Certificate with priv. key
*  @param SignatType Type of signature to apply,
*               if < 0 use default for
*               private key type
*  @param ppDstBuf Pointer for destination buffer
*  @param pDstLen Length of data
*  @return 0  on success, error code otherwise
*/
extern "C"  int  ToAsn1SignedCrl(HMEM_CTX_DEF
		CRLSTRU * pCrlStruc, X509CERT * pCert,
		int SignatType,	char** ppDstBuf, int* pDstLen)
{
  int Retcode;

  char* ppTmpBuf[1];
  int pTmpLen[1];
  int pTmpSignatType[1];

//  IDATA_PTR pIdata;
  IDATA** pDstArr;
  IDATA** ppTmpArr[1];

  //--------------------------------------------
  // check parameters
  //--------------------------------------------
  if((pCrlStruc == NULL) || (pCert == NULL) ||
     (ppDstBuf == NULL) || (pDstLen == NULL))
    return(ASN1_NULL_PTR);

  //--------------------------------------------------------
  // Allocate conversion array needed
  //--------------------------------------------------------
  if((Retcode = AllocIDATA_Array(HMEM_CTX_REF1 ppTmpArr,X509_CRL_MAX_DATA_INDEX)) != ASN1_OP_OK)
    return(ASN1_ALLOC_ERR);

  pDstArr = ppTmpArr[0];

  for(;;)
  {
    //---------------------------------------------------------
    // 1.1. Generate the TBS-CRL encoding
    //---------------------------------------------------------
    if((Retcode = ToAsn1TBSCrl(HMEM_CTX_REF1
			       pCrlStruc, ppTmpBuf, pTmpLen)) != ASN1_OP_OK)
      break;

    FromBufToDatArray(HMEM_CTX_REF1 pDstArr,X509_CRL_TBS_CRL_INDEX,ppTmpBuf[0],0,pTmpLen[0],0);
    //---------------------------------------------------------
    // 1.2. Sign the TBS-CRL with certificate key
    //---------------------------------------------------------
    if((Retcode = SignTBSFromCert(HMEM_CTX_REF1
			pCert, SignatType,
			ppTmpBuf[0], 0, pTmpLen[0],
			ppTmpBuf, pTmpLen, pTmpSignatType)) != ASN1_OP_OK)
      break;

    pCrlStruc->TBSSignatAlgor = pCert->PublicKeyType;
    pCrlStruc->TBSSignatType  = pTmpSignatType[0];

    pCrlStruc->SignatAlgor    = pCert->PublicKeyType;
    pCrlStruc->SignatType     = pTmpSignatType[0];
    //-------------------------------------------------------------
    // 2. setup Signature Algorithm/Params (as copy !)
    //-------------------------------------------------------------
    if((Retcode = SetTBSCertSignatAlgor(HMEM_CTX_REF1
			pCrlStruc->pSignatAlgPar->ppArr,0,
			pDstArr,X509_CRL_SIGNAT_ALGOR_ID_INDEX,
			pCrlStruc->SignatType)) != ASN1_OP_OK)
      break;

    //-------------------------------------------------------------
    // 3. setup the signature (as copy !)
    //-------------------------------------------------------------
    if((Retcode = FromBufToDatArray(HMEM_CTX_REF1 pDstArr,X509_CRL_SIGNAT_DATA_INDEX,ppTmpBuf[0],0,pTmpLen[0],1)) != ASN1_OP_OK)
      break;

    //-------------------------------------------------------------
    // 4. generate the ASN.1 encoding of the CRL-TBS
    //-------------------------------------------------------------
    Retcode = ToASN1(HMEM_CTX_REF1 pDstArr,0,(char *) X509CrlCtl,X509_CRL_CTL_CNT,ppDstBuf,pDstLen);

    break;
  }
  // NOTE: Must also free elements !!
  FreeIDATA_Array(HMEM_CTX_REF1 pDstArr,X509_CRL_MAX_DATA_INDEX,1);
  return(Retcode);
}

/**
* Generates authority key identifier ASN.1 encoding from given
* certificate (FromCertToAsn1AuthkeyId). 
* Elements to set can be chosen from flags.
* Possible components are:
*<ul>
* <li> Key ID: SHA1 hash of the public key bitstring's value field.
* <li> Issuer name: General name encoding of subject DN.
* <li> Cert serial: Serial number of the certificate.
*</ul>
* Output is either a plain buffer or an allocated, filled descriptor.
*
*  @param pCert Certificate to use
*  @param ComponentFlags Bit 0: With KeyID <br>
*               Bit 1: With issuer name <br>
*               Bit 2: With serial number <br>
*               other bits - reserved
*  @param ppDstBuf Pointer for destination buffer. Optional
*  @param pDstLen Length of data. Optional
*  @param ppDesc Destination file descriptor. Optional
*  @return 0 on success, error code otherwise
*/
extern "C"  int  FromCertToAsn1AuthkeyId(HMEM_CTX_DEF
		X509CERT * pCert,
		int ComponentFlags, char** ppDstBuf, int* pDstLen,
		IDATPARR** ppDesc)
{
  int Retcode;
  int DataLen;

  char* pBuf;

  IDATA* pIdata;

  IDATA** pDstArr;

  IDATPARR* pDesc = NULL;

  int ShaArray[SHA_ARRAY_SIZE];
  char DigestBuf[SHA_DIGEST_LEN];
  IDATPARR* ppTmpDesc[1];

  //---------------------------------------------------
  // Check parameters
  //---------------------------------------------------
  if((pCert == NULL) || 
     ((ppDstBuf != NULL) && (pDstLen == NULL)) ||
     ((ppDstBuf == NULL) && (ppDesc == NULL)))
    return(ASN1_NULL_PTR);

  if((ComponentFlags & 0x07) == 0)
    return(ASN1_PARAM_ERR);

  if(ppDstBuf != NULL)
  {
    ppDstBuf[0] = NULL;
    pDstLen[0]  = 0;
  }
  if(ppDesc != NULL)
    ppDesc[0] = NULL;
  //---------------------------------------------------
  // Allocate conversion descriptor
  //---------------------------------------------------
  if((Retcode = AllocIDATPARR_Struc(HMEM_CTX_REF1 ppTmpDesc,AUTH_KEY_ID_MAX_DATA_INDEX)) != ASN1_OP_OK)
    return(Retcode);

  pDesc   = ppTmpDesc[0];
  pDesc->Flags |= FREE_BIT_MASK;
  pDstArr = pDesc->ppArr;

  for(;;)
  {
    //-------------------------------------------------
    // 1. generate KeyID if requested
    //-------------------------------------------------
    if((ComponentFlags & 0x01) != 0)		// with keyID
    {
      //------------------------------------------------------
      // 1.1 Calculate the certificate public key SHA1 hash
      //------------------------------------------------------
      pIdata = pCert->PubKeyValueOcsp->ppArr[0];
      if((pIdata->Base == NULL) || (pIdata->Len <= 0))
      {
        Retcode = ASN1_TO_AUTH_KEYID_NO_PUBKEY;
        break;
      }
      SHA1_Init(ShaArray);
      SHA1_Update(ShaArray,pIdata->Base,(int) pIdata->Off,pIdata->Len);
      SHA1_Final(ShaArray,DigestBuf,0);
      //------------------------------------------------------
      // 1.2 Set the key hash for conversion (as copy)
      //------------------------------------------------------
      if((Retcode = FromBufToDatArray(HMEM_CTX_REF1 pDstArr,AUTH_KEY_ID_INDEX,DigestBuf,0,SHA_DIGEST_LEN,1)) != ASN1_OP_OK)
        break;
    }
    //-----------------------------------------------------
    // 2. generate Issuer name from subject DN if requested
    //-----------------------------------------------------
    if((ComponentFlags & 0x02) != 0)		// with IssuerName
    {
      //------------------------------------------------------------
      // 2.1. generate a copy of the subject DN (raw, with sequence)
      //------------------------------------------------------------
      pIdata = pCert->SubjectNameOcsp->ppArr[0];
      if((pIdata->Base == NULL) || (pIdata->Len <= 0))
      {
        Retcode = ASN1_TO_AUTH_KEYID_NO_SUBJNAME;
        break;
      }
      DataLen = pIdata->Len;
      if((pBuf = BIT8_ARRAY_ALLOC(HMEM_CTX_REF,DataLen)) == NULL)
      {
        Retcode = ASN1_ALLOC_ERR;
        break;
      }
      memcpy(pBuf+0,pIdata->Base+(int) pIdata->Off,DataLen);
      //------------------------------------------------------------
      // 2.2. replace outer ASN.1 SEQUENCE with ITAG[4] (type = DN)
      //------------------------------------------------------------
      pBuf[0] = (unsigned char) (ASN1_CLASS_CONTEXT_SPECIFIC | ASN1_CONSTRUCTED | 0x04);

      //------------------------------------------------------
      // 2.3 Set the name for conversion (no copy required)
      //------------------------------------------------------
      if((Retcode = FromBufToDatArray(HMEM_CTX_REF1 pDstArr,AUTH_CERT_ISSUER_INDEX,pBuf,0,DataLen,0)) != ASN1_OP_OK)
        break;
    }
    //-----------------------------------------------------
    // 3. generate cert serial number if requested
    //-----------------------------------------------------
    if((ComponentFlags & 0x04) != 0)		// with SerialNumber
    {
      //------------------------------------------------------------
      // 3.1. generate a copy of the serial number
      //------------------------------------------------------------
      pIdata = pCert->SerialNumber->ppArr[0];
      if((pIdata->Base == NULL) || (pIdata->Len <= 0))
      {
        Retcode = ASN1_TO_AUTH_KEYID_NO_SERIALNR;
        break;
      }
      DataLen = pIdata->Len;
      if((pBuf = BIT8_ARRAY_ALLOC(HMEM_CTX_REF,DataLen)) == NULL)
      {
        Retcode = ASN1_ALLOC_ERR;
        break;
      }
      memcpy(pBuf+0,pIdata->Base+(int) pIdata->Off,DataLen);
      //-------------------------------------------------------
      // 3.2 Set the serialnr for conversion (no copy required)
      //-------------------------------------------------------
      if((Retcode = FromBufToDatArray(HMEM_CTX_REF1 pDstArr,AUTH_SERIAL_INDEX,pBuf,0,DataLen,0)) != ASN1_OP_OK)
        break;
    }
    //-----------------------------------------------------------
    // 4.1. generate ASN.1 encoding of the Authority key identifier
    //    if Requested
    //-----------------------------------------------------------
    if(ppDstBuf != NULL)
    {
     if((Retcode = ToASN1(HMEM_CTX_REF1 pDstArr,0,(char *) AuthKeyIdExtCtl,AUTH_KEY_ID_CTL_CNT,ppDstBuf,pDstLen)) != ASN1_OP_OK)
      break;
    }
    //-----------------------------------------------------------
    // 4.2. hand out descriptor if requested
    //-----------------------------------------------------------
    if(ppDesc != NULL)
    {
      ppDesc[0] = pDesc;
      pDesc = NULL;
    }
    break;
  }
  FreeIDATPARR_Struc(HMEM_CTX_REF1 pDesc);
  return(Retcode);
}


#endif //HL_CERT_ASN_1_HELPER
// end of file ../hasn1/hasn1src/Hasn1hli.cpp


#ifdef HL_CERT_CLIB
//*******************************************************************
//
// Socket Functions used for connect / bind
// Socket helper Functions (Name resolution etc.)
// Advanced IPV6 compatible functions
//
//*******************************************************************
#if (defined _WIN32) & (_MSC_VER < 1700)
#ifndef _STDINT
#define _STDINT
// MSVC lower than 17.00 does not have stdint.h, assure, all needed types are defined

typedef unsigned __int16 uint16_t;

typedef unsigned __int32 uint32_t;

typedef unsigned __int64 uint64_t;

#endif // !_STDINT
#else
#include <stdint.h>
#endif
#include <stddef.h>
#ifdef _WIN32
#define WIN32_LEAN_AND_MEAN
#include <Windows.h>
#undef WIN32_LEAN_AND_MEAN
#else// Define system-specific HL_* defines here
#ifndef HL_UNIX
#define HL_UNIX

#if (defined __gnu_linux__) || (defined __linux__)
#define HL_LINUX
#endif

#if (defined __APPLE__) && (defined __MACH__)
#define HL_LINUX
#define HL_MACOS
#endif

#ifdef _AIX
#define HL_AIX
#define HL_BIG_ENDIAN
#endif

#ifdef __FreeBSD__
#define HL_FREEBSD
#endif

#if (defined _hpux) || (defined hpux) || (defined __hpux)
#define HL_HPUX
#define HL_BIG_ENDIAN
#endif

#if (defined sun) || (defined __sun)
#define HL_SOLARIS
#endif

#if (defined __arm__) || (defined __aarch64__)
#define HL_LINUX_ARM
#endif

#ifdef __ANDROID__
#define HL_ANDROID
#endif

#endif
#include <hob-unix01.h>
#endif
#ifdef __APPLE__
/* We get target conditionals to keep apart Mac OS, iOS and iOS simulator.
   The conditionals are TARGET_IPHONE_SIMULATOR, TARGET_OS_IPHONE and TARGET_OS_MAC.
   TARGET_IPHONE_SIMULATOR has the highest priority, TARGET_OS_MAC the lowest.
   Always test, if the conditional is 1, as they will be defined as 0, if we 
   are not compiling for the target.
   */
#include <TargetConditionals.h>
#endif

#ifdef HL_ANDROID
#include <netdb.h>
#include <unistd.h>
#include <linux/in.h>
#ifndef SOCKLEN_T
#define SOCKLEN_T      int
#endif
#ifndef SA_FAMILY_T
#define SA_FAMILY_T  short
#endif
#include <sys/endian.h>
#include <asm/ioctls.h>
#include <errno.h>
#endif

#include "hob-encry-1.h"
#include "hob-cert-ext.h"
#ifdef _WIN32
#include <winsock.h>
#endif
#include "hob-cert-err.h"
#include <string.h>
#include "hob-cert-intern.h"
#include "hob-cert-err.h"

#if defined _WIN32
#pragma warning(disable:4996)
#endif

/** @addtogroup util
* @{
* @file
* This file implements various C-style socket functionality.
* @}
*/

//()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()
//
// IPV4/V6 Address Conversion Helper Functions
//
//()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()

/**
* Convert ASCII decimal (shortest) representation of a byte to
* the byte value (DecimalAsciiToByte).
*
*  @param pSrcBuf Source string
*  @param SrcOff Start of data
*  @param SrcLen Length of data
*  @param pValue decoded value
*  @return int ProcessedLen Number of characters processed if >= 0,
* <br>            else error (number too large)
*/
static  int  DecimalAsciiToByte(char* pSrcBuf, int SrcOff,
				int SrcLen, char* pValue)
{
  int c;
  int StartOff = SrcOff;
  int Value = 0;

//  if(pValue == NULL)
//    return(-1);

  pValue[0] = 0;

  if((pSrcBuf == NULL) || (SrcLen <= 0))
    return(0);

  while(SrcLen != 0)
  {
    c = (int) pSrcBuf[SrcOff] & 0xFF;
    if((c < 0x30) || (c > 0x39))		// not a digit
      break;
    Value = (Value * 10) + (c - 0x30);		// get next digit
    if(Value > 255)
      return(-2);
    SrcOff++;
    SrcLen--;
  }
  pValue[0] = (char) Value;
  return(SrcOff - StartOff);
}
/**
* Convert shortes Ascii HEX word representation to 16 bit word (HexAsciiToBigWord).
*
*  @param pSrcBuf Source Byte buffer
*  @param SrcOff Start of data
*  @param SrcLen length of data
*  @param pWord Result
*  @return int ProcessedLen Number of characters processed if >= 0,
* <br>            else error (number too large)
*/
static  int  HexAsciiToBigWord(char* pSrcBuf, int SrcOff,
			int SrcLen, int* pWord)
{
  int c;
  int StartOff = SrcOff;
  int WordVal = 0;

// if(pWord == NULL)
//   return(-1);

  pWord[0] = 0;
  if((pSrcBuf == NULL) || (SrcLen <= 0))
    return(0);
  //-----------------------------------------------------------
  // Read the number, nibble by nibble
  //-----------------------------------------------------------
  while(SrcLen > 0)
  {
    c = pSrcBuf[SrcOff];
    if((c >= 0x30) && (c <= 0x39))		// is decimal digit 0-9
      c -= 0x30;
    else if((c >= 0x41) && (c <= 0x46))		// upper letter A-F
      c -= 0x37;
    else if((c >= 0x61) && (c <= 0x66))		// lower letter a-f
      c -= 0x57;
    else					// not a hex digit
      break;
    WordVal = (WordVal << 4) | c;		// shift up, append nibble
    if((WordVal & 0xFFFF0000) != 0)		// overflow occured anyway
      return(-1);
    SrcOff++;
    SrcLen--;
  }
  pWord[0] = (int) WordVal;
  return(SrcOff-StartOff);
}
/**
* Convert a byte to ASCII decimal representation in shortest form (ByteToDecimalAscii).
* NOTE: no parameters checked !!!
*
*  @param InpByte Byte to convert
*  @param pDstBuf Destination buffer
*  @param DstOff Start of Data
*  @return int OutpLen Number of Elements stored
*/
static  int  ByteToDecimalAscii(char InpByte, char* pDstBuf,
				           int DstOff)
{
  int i = (int) InpByte & 0xFF;

  if(i < 10)
  {
    pDstBuf[DstOff] = (unsigned char) (i + 0x30);
    return(1);
  }
  if(i < 100)
  {
    pDstBuf[DstOff+1] = (unsigned char) (i%10 + 0x30);
    pDstBuf[DstOff]   = (unsigned char) (i/10 + 0x30);
    return(2);
  }
  pDstBuf[DstOff+2] = (unsigned char) (i%10 + 0x30);
  i = i/10;
  pDstBuf[DstOff+1] = (unsigned char) (i%10 + 0x30);
  pDstBuf[DstOff]   = (unsigned char) (i/10 + 0x30);
  return(3);
}
/**
* Convert 2 consecutive bytes in network order to shortes Ascii Hex
* representation (BigWordToHexAscii).
* NOTE: no parameters checked !!!
*
*  @param pSrcBuf Source Byte buffer
*  @param SrcOff Start of data
*  @param pDstBuf Destination buffer
*  @param DstOff Start of Data
*  @param UpperFlag == 0 use lower case Hex letters
*  @return int OutpLen Number of Elements stored
*/
static  int  BigWordToHexAscii(char* pSrcBuf, int SrcOff,
			char* pDstBuf, int DstOff, int UpperFlag)
{
  char c;
  int StartOff = DstOff;
  int Value = ((int) pSrcBuf[SrcOff] << 8) | ((int) pSrcBuf[SrcOff+1] & 0xFF);
  int Count = 4;
  while(Count != 0)
  {
    c = (char) ((Value >> 12) & 0x0F);		// get highest nibble
    Value <<= 4;				// shift up next lower nibble
    if((c != 0) || (DstOff != StartOff))	// must store anyway
    {
      if((c = (char) (c + 0x30)) > (char) 0x39)	// to Ascii, check letter
      {
        if(UpperFlag == 0)
          c = (char) (c + 0x27);                // to lower
        else
          c = (char) (c + 7);                   // to upper
      }
      pDstBuf[DstOff++] = c;
    }
    Count--;
  }
  if(DstOff == StartOff)			// all zeroes, nothing stored
    pDstBuf[DstOff++] = (unsigned char) 0x30;		// store an ASCII zero
  return(DstOff-StartOff);
}
/**
* Convert an IPV4 binary address to standard String Representation,
* without trailing NUL (IPV4ToString).
* NOTE: no parameters checked, output buffer must be at least
* ----- 4*3+3 bytes long (exclusive trailing NUL)
*
*  @param pSrcBuf Address in Network order
*  @param SrcOff Start of data
*  @param pDstBuf Destination buffer
*  @param DstOff Start of Data
*  @return int OutpLen Number of Elements stored
*/
static  int  IPV4ToString(char* pSrcBuf, int SrcOff,
				     char* pDstBuf, int DstOff)
{
  int StartOff = DstOff;
  int Count = 4;
  while(Count != 0)
  {
    DstOff += ByteToDecimalAscii(pSrcBuf[SrcOff++],pDstBuf,DstOff);
    Count--;
    if(Count != 0)
      pDstBuf[DstOff++] = (unsigned char) '.';
  }
  return(DstOff-StartOff);
}
/**
* Find longest run of zero 16 bit elements in IPV6 address (FindLongestZeroWordRun).
* Note: 1. A run consist of at leaset 2 consecutive zero elements !
* ----- 2. no parameters checked !
*
*  @param pSrcBuf Address buffer
*  @param SrcOff Start of Data
*  @return Result: 0 - no run found, else
* <br>            Bit 15-8: start Index of run (in Bytes, rel. 0)
* <br>            Bit 7-0: length of run (in Elements!)
*/
static  int  FindLongestZeroWordRun(char* pSrcBuf, int SrcOff)
{
  int StartOff = SrcOff;
  int LastRunStart = -1;
  int ActRunStart  = -1;
  int LastRunLen = 0;
  int ActRunLen = 0;

  int Count = 8;
  do
  {
    if((pSrcBuf[SrcOff] == 0) && (pSrcBuf[SrcOff+1] == 0))
    {
      //----------------------------------------------------
      // Found a run condition, check last condition
      //----------------------------------------------------
      if(ActRunLen == 0)			// not inside a run  
        ActRunStart = SrcOff;
      ActRunLen++;
    }
    else
    {
      //----------------------------------------------------
      // Found a run end condition, check last condition
      //----------------------------------------------------
      if((ActRunLen != 0) && (ActRunLen > LastRunLen)) // larger run now
      {
        LastRunLen = ActRunLen;
        LastRunStart = ActRunStart;
      }
      ActRunLen = 0;
    }
    SrcOff += 2;
    Count--;
  }while(Count > 0);
  //--------------------------------------------------------
  // Check if a run is still active and is larger than last
  //--------------------------------------------------------
  if((ActRunLen != 0) && (ActRunLen > LastRunLen))
  {
    LastRunLen = ActRunLen;
    LastRunStart = ActRunStart;
  }
  if(LastRunLen < 2)				// none/ only one found
    return(0);
  LastRunStart -= StartOff;			// set rel. 0
  return((LastRunStart << 8) | LastRunLen);
}
/**
* Convert an IPV6 binary address to String Representation,
* without trailing NUL (IPV6ToString).
* NOTE: no parameters checked, output buffer must be at least
* ----- 6*4 + 6 + 4*3+3 bytes long (exclusive trailing NUL)
*
*  @param pSrcBuf Address in Network order
*  @param SrcOff Start of data
*  @param pDstBuf Destination buffer
*  @param DstOff Start of Data
*  @param ModeFlags Bit 0 - 1: use mixed mode
*               Bit 1 - 1: use shortcut if pos.
*               Bit 2 - 1: use upper HEX chars
*  @return int OutpLen Number of Elements stored
*/
static  int  IPV6ToString(char* pSrcBuf, int SrcOff,
				     char* pDstBuf, int DstOff,
				     int ModeFlags)
{
  int DstStartOff = DstOff;
//  int SrcStartOff = SrcOff;
  int SrcEndOff;
  int Count;
  int RunLen = 0;
  int UpperFlag = ModeFlags & 0x04;	// isolate Upper mode flag
  int RunStart;
  //------------------------------------------------------------------
  // If shortcut mode is requested, get maximal zero run info
  //------------------------------------------------------------------
  if(((ModeFlags & 0x02) != 0) &&
     ((RunLen = FindLongestZeroWordRun(pSrcBuf, SrcOff)) != 0))
  {
    //----------------------------------------------------------------
    // A zero run has been found, check if usable (obey mixed mode !)
    //----------------------------------------------------------------
    RunStart = (RunLen >> 8) & 0xFF;	// isolate starting index (in bytes !)
    RunLen   = RunLen & 0xFF;		// isolate length in elements
    SrcEndOff = SrcOff + IPV6_ADRLEN;	// set last sorce index to process

    if(((ModeFlags & 0x01) == 0) ||	// hex only mode, use always
       (((ModeFlags & 0x01) != 0) && (RunStart < 12))) // mixed mode, can use
    {
      //--------------------------------------------------------------
      // the zero run is useful, output data till run starts
      //--------------------------------------------------------------
      Count = RunStart / 2;		// number of elements till run starts
      if(Count == 0)			// no Elements
        pDstBuf[DstOff++] = (unsigned char) ':';	// output 'dummy' element
      else				// at least one element
      {
        do
        {
          DstOff += BigWordToHexAscii(pSrcBuf,SrcOff,pDstBuf,DstOff,UpperFlag);
          pDstBuf[DstOff++] = (unsigned char) ':';
          SrcOff += 2;
          Count--;
        }while(Count != 0);
      }
      //--------------------------------------------------------------
      // Run start reached, skip data till run end, obey mixed mode !
      //--------------------------------------------------------------
      SrcOff += RunLen*2;			// skip count (excl.last!)
      if((ModeFlags & 0x01) == 0)		// all hex mode
      {
        Count = (SrcEndOff - SrcOff)/2;		// get remaining count
        if(Count == 0)				// no more elements
          pDstBuf[DstOff++] = (unsigned char) ':';	// output 'dummy' element
        else
        {
          do
          {
            pDstBuf[DstOff++] = (unsigned char) ':';	// delimit next at start
            DstOff += BigWordToHexAscii(pSrcBuf,SrcOff,pDstBuf,DstOff,UpperFlag);
            SrcOff += 2;
            Count--;
          }while(Count != 0);
        }
      }
      else					// mixed mode, special
      {
        //-------------------------------------------------------
        // output remaining data till 6th Element processed
        //-------------------------------------------------------
        Count = (SrcEndOff - SrcOff) / 2;	// get remaining elements
        Count -= 2;				// must have at least 2 Elem.
        if(Count <= 0)				// run propagates into IPV4
          SrcOff = SrcEndOff - IPV4_ADRLEN;	// back to start of IPV4
        else
        {
          do
          {
            pDstBuf[DstOff++] = (unsigned char) ':';	// delimit next at start
            DstOff += BigWordToHexAscii(pSrcBuf,SrcOff,pDstBuf,DstOff,UpperFlag);
            SrcOff += 2;
            Count--;
          }while(Count != 0);
        }
        pDstBuf[DstOff++] = (unsigned char) ':';		// output delimiter
        DstOff += IPV4ToString(pSrcBuf, SrcOff, pDstBuf, DstOff);
      }
      return(DstOff-DstStartOff);
    } // usable run
  } // with shortening
  //------------------------------------------------------------------
  // prepare leading/all output in hex
  //------------------------------------------------------------------
  Count = 8;				// assume all hex mode, 8 elements
  if((ModeFlags & 0x01) != 0)		// must use mixed mode
    Count = 6;				// only convert first 6 elements
  //------------------------------------------------------------------
  // output whole number / leading 6 elements as hex
  //------------------------------------------------------------------
  while(Count != 0)
  {
    DstOff += BigWordToHexAscii(pSrcBuf,SrcOff,pDstBuf,DstOff,UpperFlag);
    Count--;
    SrcOff += 2;
    if(Count != 0)
      pDstBuf[DstOff++] = (unsigned char) ':';
  }
  //------------------------------------------------------------------
  // Check if IPV4 like part shall be appended
  //------------------------------------------------------------------
  if((ModeFlags & 0x01) != 0)
  {
    pDstBuf[DstOff++] = (unsigned char) ':';	// append delimiter
    DstOff += IPV4ToString(pSrcBuf,SrcOff,pDstBuf,DstOff);
  }
  return(DstOff-DstStartOff);
}
    

/**
* Converts an IPV4/6 Network Address in binary format (Network order)
* to string representation (InetNtop). 
*
* Output format is:
*<ol>
* <li> IPV4: ddd.ddd.ddd.ddd where ddd is decimal representation 0-255) of
*	    the associated byte
* <li> IPV6: There are two possible base formats with a short form each:
*    Format I, all hex mode:<ol>
*	<li> Baseformat, no shortform
*		xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:xxxx
*	<li> Short format: longest run of zero 16 bit elements replaced by '::'
*	     e.g.: xxxx::xxxx:xxxx </ol>
*    Format II, mixed hex/decimal mode:<ol>
*	<li> Baseformat, no shortform
*		xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:ddd.ddd.ddd.ddd
*	<li> Short format: longest run of zero 16 bit elements replaced by '::'
*	     e.g.: xxxx::ddd.ddd.ddd.ddd</ol>
*</ol>
*  @param AddressFamily AF_INET/AF_INET6
*  @param pSrcBuf Address source
*  @param SrcOff Start of source data
*  @param pDstBuf String write buffer
*  @param DstOff Start offset for writing data
*  @param DstBufLen Length of buffer
*  @param ModeFlags Flags for IPV6 Conversion: <br>
*               Bit 0 - 1: mixed mode <br>
*               Bit 1 - 1: with shortcut <br>
*               Bit 2 - 1: use upper HEX chars
*  @return Bytes written, <0 if error occured
*/
extern "C"  int  InetNtop(int AddressFamily, char* pSrcBuf,
	int SrcOff, char* pDstBuf, int DstOff, int DstBufLen, int ModeFlags)
{
  int StrLen;
  char pTmpBuf[INET6_ADDRSTRLEN];

  if((pSrcBuf == NULL) || (pDstBuf == NULL))
    return(-1);
  if((AddressFamily != AF_INET) && (AddressFamily != AF_INET6))
    return(-2);
  //--------------------------------------------------------
  // Convert Address to IPV4/IPV6 address format
  //--------------------------------------------------------
  if(AddressFamily == AF_INET)
    StrLen = IPV4ToString(pSrcBuf,SrcOff, pTmpBuf,0);
  else
    StrLen = IPV6ToString(pSrcBuf,SrcOff,pTmpBuf,0,ModeFlags);
  //-------------------------------------------------------------
  // Copy string to user if enough buffer space, delimit with NUL
  //-------------------------------------------------------------
  if(DstBufLen < StrLen)			// buffer too small
    return(-3);
  memcpy(pDstBuf+DstOff,pTmpBuf+0,StrLen);
  if(DstBufLen > StrLen)			// can delimit also
    pDstBuf[DstOff+StrLen] = 0;
  return(StrLen);
}
/**
* Gets format of an IP address string (GetInetAddressStringType).
*
* See InetNtop.
*
*  @param pSrcBuf Source string
*  @param SrcOff Start of data
*  @param SrcLen Length of data
*  @return < 0 - invalid format
* <br>            == 0 - IPV4
* <br>            == 1 - IPV6 Hex
* <br>            == 2 - IPV6 Mixed
*/
extern "C"  int  GetInetAddressStringType(char* pSrcBuf, int SrcOff,
				                 int SrcLen)
{
  char c;
  int i;
  int Flags = 0;
  int DotCount = 0;
  int ElementSizeMin = SrcLen;
  int ElementSizeMax = 0;
  int LastIndex = SrcOff;
  //----------------------------------------------------
  // check parameters
  //----------------------------------------------------
  if((pSrcBuf == NULL) || (SrcLen <= 0))
    return(-1);
  //------------------------------------------------------------
  // scan the address for '.' and ':', need not check syntax yet
  //------------------------------------------------------------
  while(SrcLen != 0)
  {
    c = pSrcBuf[SrcOff++];
    SrcLen--;
    if((c == (unsigned char) '.') || (c == (unsigned char) ':'))		// found dot
    {
      i = SrcOff - LastIndex - 1;
      if(i < ElementSizeMin)
        ElementSizeMin = i;
      if(i > ElementSizeMax)
        ElementSizeMax = i;
      LastIndex = SrcOff;
      if(c == (unsigned char) '.')
      {
        Flags |= 0x01;
        DotCount++;
      }
      else						// found colon
      {
        Flags |= 0x02;
      }
    }
  }
  if(Flags == 0)				// none found, invalid anyway
    return(-1);  

  else if(Flags == 3)				// both, IPV6 mixed
    return(2);

  else if(Flags == 1)				// dot only, IPV4
  {
    if(DotCount != 3)				// not IP
      return(-1);
    if((ElementSizeMin < 1) ||
       (ElementSizeMax > 3))
      return(-1);

    return(0);
  }
  return(1);					// colon only, IPV6 hex
}
/**
* Get length of current IPV6 address element (GetIPV6AdrElementLen).
* An element is assumed to stop at next '.' or ':' character or
* when the length is exhausted.
*
*  @param pSrcBuf Source string
*  @param SrcOff Start of data
*  @param SrcLen Length of data
*  @param pDelim Delimiter found / 0
*  @return int ElementLen
*/
static  int  GetIPV6AdrElementLen(char* pSrcBuf, int SrcOff,
				              int SrcLen, char* pDelim)
{
  int StartOff = SrcOff;

  pDelim[0] = 0;
  while(SrcLen > 0)  
  {
    if((pSrcBuf[SrcOff] == (unsigned char) ':') ||	// found delimiter
       (pSrcBuf[SrcOff] == (unsigned char) '.'))
    {
      pDelim[0] = pSrcBuf[SrcOff];
      break;
    }
    SrcOff++;
    SrcLen--;
  }
  return(SrcOff-StartOff);
}
/**
* Scan IPV6 Address, perform first syntax check and preprocess shortcut
* notation if found (ScanIPV6AddressString).
* Note: 1. there may be only 1 shortcut in an IPV6 Address String
* ----- 2. scan stops when either length is reached or first non
*	    decodeable character is encountered.
*
*  @param pSrcBuf Source string
*  @param SrcOff Start of data
*  @param SrcLen Length of data
*  @param pMixedFlag 0 - pure hex mode, else mixed
*  @return int RunInfo if >= 0: BIT 15-7 1st Element Index of the run rel. 0
* <br>            BIT 7-0 length of the Run
* <br>            < 0 Address is malformed
*/
static  int  ScanIPV6AddressString(char* pSrcBuf, int SrcOff,
					      int SrcLen, char* pMixedFlag)
{
  int LeadElementCnt, TrailElementCnt, TotalElementCnt, Len;
  int ShortcutStart = -1;
  int ShortcutSize = 0;  
  int InIPV4Cnt = 0;

  char pTmpDelim[1];

  pMixedFlag[0] = 0;				// assume all hex
  if(SrcLen < 2)				// minimal 2 bytes needed
    return(-2);
  //-----------------------------------------------------------
  // Check special case first: '::' given only
  //-----------------------------------------------------------
  if((pSrcBuf[SrcOff] == (unsigned char) ':') &&
     (pSrcBuf[SrcOff+1] == (unsigned char) ':') &&
     (SrcLen == 2))
  {
    ShortcutStart = 0;
    ShortcutSize  = 8;
    return((ShortcutStart << 8) | ShortcutSize);
  }

  TotalElementCnt = 0;
  //---------------------------------------------------------
  // Scan Elements till shortcut found or ended
  //---------------------------------------------------------
  while(SrcLen > 0)
  {
    Len = GetIPV6AdrElementLen(pSrcBuf,SrcOff,SrcLen,pTmpDelim);
    if(Len == 0)				// could be a shortcut
    {
      if((pTmpDelim[0] != (unsigned char) ':') ||	// is not a shortcut
         (InIPV4Cnt != 0))			// wrong position anyway
        return(-2);
      //------------------------------------------------------
      // found a shortcut, set Element Index where found, skip
      //------------------------------------------------------
      ShortcutStart = TotalElementCnt;
      SrcOff++;					// skip shortcut
      SrcLen--;
      if((TotalElementCnt == 0) && (SrcLen > 0)) // first ommited
      {
        SrcOff++;				// skip next!
        SrcLen--;
      }
      break;
    }
    //--------------------------------------------------------
    // Standard element, process
    //--------------------------------------------------------
    SrcOff += Len;				// skip element
    SrcLen -= Len;
    if(pTmpDelim[0] != 0)			// Delimiter is present
    {
      SrcOff++;
      SrcLen--;
    }

    if(pTmpDelim[0] == (unsigned char) ':')		// is an IPV6 element
    {
      if(InIPV4Cnt != 0)			// but is not valid here!
        return(-2);
      if((TotalElementCnt++) > 8)		// one more, check length
        return(-2);
    }
    else if(pTmpDelim[0] == (unsigned char) '.')		// is an IPV4 element
    {
      if((InIPV4Cnt++) > 3)			// one more, check maximum
        return(-2);
      if((InIPV4Cnt & 0x01) == 0)		// a full word processed
      {
        if((TotalElementCnt++) > 8)		// one more element, check
          return(-2);
      }
    }
    else					// last element !
    {
      if((InIPV4Cnt != 0) &&			// was in IPV4 trailer
         (InIPV4Cnt != 3))			// not correct anyway
        return(-2);

      if((TotalElementCnt++) > 8)		// last word processed,one more
        return(-2);
      break;					// all processed
    }
  }
  //------------------------------------------------------------
  // Check if a Shortcut was found
  //------------------------------------------------------------
  if(ShortcutStart == -1)			// none found
  {
    pMixedFlag[0] = (char) InIPV4Cnt;
    return((TotalElementCnt != 8) ? -2 : 0);	// not all/all elements
  }
  if((TotalElementCnt++) > 8)			// shortcut is at least one long
    return(-2);					// too much anyway
  //---------------------------------------------------------------------
  // a Shortcut was found, set Lead Element Count, scan for Tail Elements
  //---------------------------------------------------------------------
  LeadElementCnt = ShortcutStart;		// set Elements ahead Count
  TrailElementCnt  = 0;
  while(SrcLen > 0)
  {
    Len = GetIPV6AdrElementLen(pSrcBuf,SrcOff,SrcLen,pTmpDelim);
    if(Len == 0)				// should not happen
      return(-2);
    SrcOff += Len;				// skip element
    SrcLen -= Len;
    if(pTmpDelim[0] != 0)			// delimiter present
    {
      SrcOff++;					// skip delimiter
      SrcLen--;
    }

    if(pTmpDelim[0] == (unsigned char) ':')		// is an IPV6 element
    {
      if(InIPV4Cnt != 0)			// but is not valid here!
        return(-2);
      if((TotalElementCnt++) > 8)
        return(-2);				// too much anyway
      TrailElementCnt++;
    }
    else if(pTmpDelim[0] == (unsigned char) '.')		// is an IPV4 element
    {
      if((InIPV4Cnt++) > 3)			// one more
        return(-2);				// is invalid anyway
      if((InIPV4Cnt & 0x01) == 0)		// a full word processed
      {
        if((TotalElementCnt++) > 8)
          return(-2);				// too much anyway
        TrailElementCnt++;
      }
    }
    else					// last element !
    {
      if((InIPV4Cnt != 0) &&			// was in IPV4 trailer
         (InIPV4Cnt != 3))			// but too few elements
        return(-2);
      if((TotalElementCnt++) > 8)		// one more element
        return(-2);				// too much anyway
      TrailElementCnt++;
      break;					// all processed
    }
  }
  //--------------------------------------------------------------
  // all processed o.k. so far with shortcut present, get its size
  //--------------------------------------------------------------
  pMixedFlag[0] = (char) InIPV4Cnt;
  ShortcutSize = IPV6_ADRLEN/2 - LeadElementCnt - TrailElementCnt;
  return((ShortcutStart << 8) | ShortcutSize);
}

/**
* Convert an IPV4 Standard string representation to binary format (StringToIPV4).
*
*  @param pSrcBuf String buffer
*  @param SrcOff Start of data
*  @param SrcLen Length of data
*  @param pDstBuf Destination buffer
*  @param DstOff Start of Data
*  @return int ProcessedCharCnt number of characters processed, if
* <br>            <= 0, error occured
*/
static  int  StringToIPV4(char* pSrcBuf, int SrcOff,
			int SrcLen, char* pDstBuf, int DstOff)
{
  int Count = 4;
  int Len;
  int StartOff = SrcOff;
  char pTmpVal[1];

  while(Count != 0)
  {
    Len = DecimalAsciiToByte(pSrcBuf, SrcOff, SrcLen, pTmpVal);
    if(Len <= 0)			// error, missing number
      return(-2);
    pDstBuf[DstOff++] = pTmpVal[0];	// store byte
    Count--;
    SrcOff += Len;
    SrcLen -= Len;
    if(Count != 0)
    {
      if((SrcLen <= 0) || (pSrcBuf[SrcOff] != (unsigned char) '.')) // missing delimiter
        return(-2);
      SrcOff++;
      SrcLen--;            
    }
  }
  return(SrcOff-StartOff);
}

/**
* Convert an IPV6 Standard string representation to binary format (StringToIPV6).
*
*  @param pSrcBuf String buffer
*  @param SrcOff Start of data
*  @param SrcLen Length of data
*  @param pDstBuf Destination buffer
*  @param DstOff Start of Data
*  @return int ProcessedCharCnt number of characters processed, if
* <br>            <= 0, error occured
*/
static  int  StringToIPV6(char* pSrcBuf, int SrcOff,
			int SrcLen, char* pDstBuf, int DstOff)
{
  int Count;
  int Len;
  int StartOff = SrcOff;

  int ShortcutLen;
  int TailElementCnt;
  int MixedFlag = 0;
  char pTmpFlag[1];
  int pTmpVal[1];
  //----------------------------------------------------------------
  // Preprocess the Address, check for correct format
  //----------------------------------------------------------------
  if((Len = ScanIPV6AddressString(pSrcBuf,SrcOff,SrcLen,pTmpFlag)) < 0)
    return(Len);					// malformed address
  if(pTmpFlag[0] != 0)
    MixedFlag = 1;

  if(Len == 0)					// no shortcut found
  {
    //-------------------------------------------------------------
    // Address without shortform, direct conversion
    //-------------------------------------------------------------
    Count = 8;
    if(MixedFlag != 0)				// has IPV4 Trailer
      Count = 6;
    while(Count != 0)
    {
      Len = HexAsciiToBigWord(pSrcBuf,SrcOff,SrcLen,pTmpVal);
      if(Len <= 0)				// error, missing number
        return(-2);
      pDstBuf[DstOff++] = (unsigned char) (pTmpVal[0] >> 8);	// store MSB byte
      pDstBuf[DstOff++] = (unsigned char) pTmpVal[0];		// store LSB byte

      Count--;
      SrcOff += Len;
      SrcLen -= Len;
      if((Count != 0) ||				// not the last one
         ((Count == 0) && (MixedFlag != 0)))		// last in mixed mode
      {
        if((SrcLen <= 0) || (pSrcBuf[SrcOff] != (unsigned char) ':')) 
          return(-2);
         SrcOff++;
         SrcLen--;
      }
    }
    if(MixedFlag != 0)				// IPV4 part is present
    {
      if((Len = StringToIPV4(pSrcBuf, SrcOff, SrcLen, pDstBuf, DstOff)) < 0)
        return(-2);				// error occured
      SrcOff += Len;
    }
    return(SrcOff-StartOff);
  }
  //-----------------------------------------------------------
  // A shortcut was found, check for special case All zeroes
  //-----------------------------------------------------------
  Count = (Len >> 8) & 0xFF;			// isolate start index
  ShortcutLen = Len & 0xFF;			// isolate length of stortcut
  if(ShortcutLen == 8)				// special case
  {
    ShortcutLen = IPV6_ADRLEN;			// byte count
    while(ShortcutLen > 0)
    {
      pDstBuf[DstOff++] = 0;			// clear all
      ShortcutLen--;
    }
    return(2);					// can only be '::'
  }
  TailElementCnt = IPV6_ADRLEN/2 - Count - ShortcutLen;
  //--------------------------------------------------------------
  // A 'true' shortcut has been found, process elements till start
  //--------------------------------------------------------------
  while(Count > 0)
  {
    Len = HexAsciiToBigWord(pSrcBuf,SrcOff,SrcLen,pTmpVal);
    if(Len <= 0)				// error, missing number
      return(-2);
    pDstBuf[DstOff++] = (unsigned char) (pTmpVal[0] >> 8);	// store MSB byte
    pDstBuf[DstOff++] = (unsigned char) pTmpVal[0];		// store LSB byte

    Count--;
    SrcOff += Len;
    SrcLen -= Len;
    if(Count != 0)				// not the last one
    {
      if((SrcLen <= 0) || (pSrcBuf[SrcOff] != (unsigned char) ':')) 
        return(-2);
      SrcOff++;
      SrcLen--;
    }
  }
  //---------------------------------------------------------
  // Fill zeroes for the shortcut, skip the shortcut
  //---------------------------------------------------------
  while(ShortcutLen != 0)
  {
    pDstBuf[DstOff++] = 0;
    pDstBuf[DstOff++] = 0;
    ShortcutLen--;
  }
  SrcOff+=2;
  SrcLen-=2;
  if(TailElementCnt == 0)			// all processed
    return(SrcOff-StartOff);
  //---------------------------------------------------------
  // process elements past the shortcut
  //---------------------------------------------------------
  if(MixedFlag != 0)				// with IPV4 portion
  {
    TailElementCnt -= 2;			// leave 32 bits !
    if(TailElementCnt < 0)			// malformed
      return(-2);
  }
  while(TailElementCnt > 0)
  {
    Len = HexAsciiToBigWord(pSrcBuf,SrcOff,SrcLen,pTmpVal);
    if(Len <= 0)				// error, missing number
      return(-2);
    pDstBuf[DstOff++] = (unsigned char) (pTmpVal[0] >> 8);	// store MSB byte
    pDstBuf[DstOff++] = (unsigned char) pTmpVal[0];		// store LSB byte

    TailElementCnt--;
    SrcOff += Len;
    SrcLen -= Len;
    if((TailElementCnt != 0) ||				// not the last one
       ((TailElementCnt == 0) && (MixedFlag != 0)))	// last but mixed
    {
      if((SrcLen <= 0) || (pSrcBuf[SrcOff] != (unsigned char) ':')) 
        return(-2);
      SrcOff++;
      SrcLen--;
    }
  }
  if(MixedFlag != 0)				// IPV4 part is present
  {
    if((Len = StringToIPV4(pSrcBuf, SrcOff, SrcLen, pDstBuf, DstOff)) < 0)
      return(-2);				// error occured
    SrcOff += Len;
  }
  return(SrcOff-StartOff);
}

/**
* Converts an IPV4/6 network address in string representation to the binary
* format (Network order) (InetPton).
* Recognized string formats:<ol>
* <li> IPV4: ddd.ddd.ddd.ddd where ddd is decimal representation 0-255) of
*	    the associated byte
* <li> IPV6: Format I, all hex mode: <ol>
*	<li> Baseformat, no shortform
*		xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:xxxx
*	<li> Short format: longest run of zero 16 bit elements replaced by '::'
*	     e.g.: xxxx::xxxx:xxxx </ol>
*    Format II, mixed hex/decimal mode: <ol>
*	<li> Baseformat, no shortform
*		xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:ddd.ddd.ddd.ddd
*	<li> Short format: longest run of zero 16 bit elements replaced by '::'
*	     e.g.: xxxx::ddd.ddd.ddd.ddd </ol>
*</ol>
* Note: Destination buffer must be large enough for address type !
*
*  @param AddressFamily AF_INET/AF_INET6
*  @param pSrcBuf String source buffer
*  @param SrcOff Start of source data
*  @param SrcLen Length of string data
*  @param pDstBuf Address return buffer
*  @param DstOff Start offset for writing
*  @return Number of processed characters, <0 on error
*/
extern "C"  int  InetPton(int AddressFamily, char* pSrcBuf,
	int SrcOff, int SrcLen, char* pDstBuf, int DstOff)
{
  int StrLen;

  if((pSrcBuf == NULL) || (pDstBuf == NULL))
    return(-1);
  if((AddressFamily != AF_INET) && (AddressFamily != AF_INET6))
    return(-2);
  //--------------------------------------------------------
  // Convert Address from IPV4/IPV6 string format
  //--------------------------------------------------------
  if(AddressFamily == AF_INET)
    StrLen = StringToIPV4(pSrcBuf,SrcOff,SrcLen,pDstBuf,DstOff);
  else
    StrLen = StringToIPV6(pSrcBuf,SrcOff,SrcLen,pDstBuf,DstOff);
  //-------------------------------------------------------------
  // Copy string to user if enough buffer space, delimit with NUL
  //-------------------------------------------------------------
  return(StrLen);
}
//()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()
//
// Address resolution Functions (DNS/Localhost etc.)
//
//()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()

/**
* Frees an address info structure and its components (FreeAddrInfoStruct).
*
*  @param pAddrInfo Structure to be freed
*/
extern "C"  void  FreeAddrInfoStruct(HMEM_CTX_DEF
					   ADDRINF * pAddrInfo)
{
  ADDRINF * pNextInfo;

  while(pAddrInfo != NULL)
  {
    FREE_ARRAY(HMEM_CTX_REF,pAddrInfo->pCanonName);
    FREE_ARRAY(HMEM_CTX_REF,pAddrInfo->pSockAdr);
    pNextInfo = pAddrInfo->pNext;
    FREE_ARRAY(HMEM_CTX_REF,pAddrInfo);
    pAddrInfo = pNextInfo;
  }
}
/**
* Allocates an address info structure and the associated address structure,
* if requested (AllocAddrInfoStruct).
*
*  @param Mode 0 - Also alloc address structure
*  @return ADDRINF_PTR pAdrInfo / NULL
*/
extern "C"  ADDRINF *  AllocAddrInfoStruct(HMEM_CTX_DEF
					           int Mode)
{
  ADDRINF * pAdrInfo;

  pAdrInfo  = (ADDRINF *) 
      ((void *) BIT8_ARRAY_CALLOC(HMEM_CTX_REF,1,sizeof(ADDRINF)));
  if(pAdrInfo == NULL)
    return(NULL);
  if(Mode == 0)
  {
    pAdrInfo->pSockAdr = (SADDRIN *)
	((void *) BIT8_ARRAY_CALLOC(HMEM_CTX_REF,1,sizeof(SADDRIN)));
    if(pAdrInfo->pSockAdr == NULL)
   {
      FREE_CARRAY(HMEM_CTX_REF,pAdrInfo);
      return(NULL);
    }
  }
  return(pAdrInfo);
}

/**
* Frees a hostentry structure and its components (FreeHostentStruct).
*
*  @param pHostEnt Structure to be freed
*/
extern "C"  void  FreeHostentStruct(HMEM_CTX_DEF
					  HSTENT* pHostEnt)
{
  int Len;
  if(pHostEnt == NULL)
    return;
  FREE_ARRAY(HMEM_CTX_REF,pHostEnt->pHostName);
  Len = pHostEnt->AliasNamesCnt;
  while(Len > 0)
  {
    Len--;
    FREE_ARRAY(HMEM_CTX_REF,pHostEnt->pAliasArr[Len]);
  }
  FREE_ARRAY(HMEM_CTX_REF,pHostEnt->pAliasArr);

  Len = pHostEnt->AdrCnt;
  while(Len > 0)
  {
    Len--;
    FREE_ARRAY(HMEM_CTX_REF,pHostEnt->pAdrArr[Len]);
  }
  FREE_ARRAY(HMEM_CTX_REF,pHostEnt->pAdrArr);
  FREE_CARRAY(HMEM_CTX_REF,pHostEnt);
}
/**
* Duplicates a SADDRIN structure (DupAdrStruc).
* This is a shallow copy.
*
*  @param pSrcAdr Source structure
*  @return Copy of the source structure, NULL on error
*/
extern "C"  SADDRIN *  DupAdrStruc(HMEM_CTX_DEF
				SADDRIN * pSrcAdr)
{
  SADDRIN * pDupAdr;
  //-----------------------------------------------------------
  // Allocate a new Structure
  //-----------------------------------------------------------
  pDupAdr = (SADDRIN *) 
    ((void *) BIT8_ARRAY_CALLOC(HMEM_CTX_REF,1,sizeof(SADDRIN)));
  if(pDupAdr == NULL)
    return(NULL);
  memcpy(pDupAdr,pSrcAdr,sizeof(SADDRIN));
  return(pDupAdr);  
}

/**
* Retrieves a host name (Name and Address etc.) from address (GetHostByAddr).
*
*  @param pAddrStruc Adress structure
*  @return New <code>HOSTENT_PTR</code> structure/NULL on error
*/
extern "C"  HSTENT*  GetHostByAddr(HMEM_CTX_DEF
					     SADDRIN * pAddrStruc)
{

  int Len, AdrLen;
  int AdrFamily;
  struct hostent * pCHostEnt;
  struct hostent TmpHostEnt;
  char* pTmpAdrList[2];
  char** pCPtrArr;
  char** pPtrArr;

  HSTENT* pHostEnt;

  if(pAddrStruc == NULL)
    return(NULL);

  AdrFamily = pAddrStruc->AdrFamily;
  AdrLen    = pAddrStruc->AdrLen;
  if(((AdrFamily != AF_INET) && (AdrFamily != AF_INET6)) ||
     ((AdrFamily == AF_INET) && (AdrLen != IPV4_ADRLEN)) ||
     ((AdrFamily == AF_INET6) && (AdrLen != IPV6_ADRLEN)))
    return(NULL);
  //-----------------------------------------------------------
  // C-Version, get Information to process  
  //-----------------------------------------------------------
  pCHostEnt = gethostbyaddr(pAddrStruc->InetAdr,AdrLen,AdrFamily);
  if(pCHostEnt == NULL)
  {
    //---------------------------------------------------------
    // Simulate a 'hostent' Structure from pAddrStruc...
    //---------------------------------------------------------
    memset(&TmpHostEnt,0,sizeof(struct hostent));	// Clear structure
    TmpHostEnt.h_addrtype  = (short) AdrFamily;
    TmpHostEnt.h_length    = (short) AdrLen;
    pTmpAdrList[0] = (char *) ((void * ) &pAddrStruc->InetAdr);
    pTmpAdrList[1] = NULL;
    TmpHostEnt.h_addr_list = pTmpAdrList;
    
    pCHostEnt = &TmpHostEnt;
  }
  //-----------------------------------------------------------
  // Allocate structure, clear
  //-----------------------------------------------------------
  if((pHostEnt = (HSTENT*)
    ((void *) BIT8_ARRAY_CALLOC(HMEM_CTX_REF,1,sizeof(HSTENT))))== NULL)
    return(NULL);
  //-----------------------------------------------------------
  // Transfer data from static structure to allocated
  //-----------------------------------------------------------
  if((pCHostEnt->h_name != NULL) && ((int) strlen(pCHostEnt->h_name) > 0))
  {
    if((pHostEnt->pHostName =
	  Strdup(HMEM_CTX_REF1 pCHostEnt->h_name,0)) == NULL)
    {
      FreeHostentStruct(HMEM_CTX_REF1 pHostEnt);
      return(NULL);
    }
  }
  //-----------------------------------------------------------
  // Copy Alias Array if present
  //-----------------------------------------------------------
  pCPtrArr = pCHostEnt->h_aliases;
  if((pCPtrArr != NULL) && (pCPtrArr[0] != NULL))
  {
    Len = 0;
    while(pCPtrArr[Len] != NULL)		// count elements
      Len++;
    if((pPtrArr = (char**)
	 ((void *) BIT8_ARRAY_CALLOC(HMEM_CTX_REF,
				     Len,sizeof(char*)))) == NULL)
    {
      FreeHostentStruct(HMEM_CTX_REF1 pHostEnt);
      return(NULL);
    }
    pHostEnt->pAliasArr = pPtrArr;
    pHostEnt->AliasNamesCnt = Len;
    while(Len != 0)
    {
      Len--;
      if((pPtrArr[Len] =
        Strdup(HMEM_CTX_REF1 pCPtrArr[Len],0)) == NULL)
      {
        FreeHostentStruct(HMEM_CTX_REF1 pHostEnt);
        return(NULL);
      }
    }
  }
  //-----------------------------------------------------------
  // Copy Address family, address length
  //-----------------------------------------------------------
  pHostEnt->AdrFamily = pCHostEnt->h_addrtype;
  AdrLen = pCHostEnt->h_length;
  pHostEnt->AdrLen    = AdrLen;
  //-----------------------------------------------------------
  // Copy Address Array if present
  //-----------------------------------------------------------
  pCPtrArr = pCHostEnt->h_addr_list;
  if((AdrLen > 0) && (pCPtrArr != NULL) && (pCPtrArr[0] != NULL))
  {
    Len = 0;
    while(pCPtrArr[Len] != NULL)		// count elements
      Len++;
    if((pPtrArr = (char**)
          ((void *) BIT8_ARRAY_CALLOC(HMEM_CTX_REF,
				      Len,sizeof(char*)))) == NULL)
    {
      FreeHostentStruct(HMEM_CTX_REF1 pHostEnt);
      return(NULL);
    }
    pHostEnt->pAdrArr = pPtrArr;
    pHostEnt->AdrCnt = Len;
    while(Len != 0)
    {
      Len--;
      if((pPtrArr[Len] = 
	    BIT8_ARRAY_CALLOC(HMEM_CTX_REF,1,AdrLen)) == NULL)
      {
        FreeHostentStruct(HMEM_CTX_REF1 pHostEnt);
        return(NULL);
      }
// NOTE NOTE NOTE: Address is byte reversed with WIN32 !!!! -> Change !!
      memcpy(pPtrArr[Len],pCPtrArr[Len],AdrLen);
    }
  }
  return(pHostEnt);

}

/**
* Resolves a hosts DNS name to its address, return structure
* filled with information if successful (HGetHostByName).
*
*  @param pNameBuf Name to resolve, ASCIIz
*  @param NameOff Start of Data
*  @return New <code>HOSTENT_PTR</code> structure/NULL on error
*/
extern "C"  HSTENT*  HGetHostByName(HMEM_CTX_DEF
			char* pNameBuf, int NameOff)
{

  int Len, AdrLen;
  struct hostent * pCHostEnt;
  char** pCPtrArr;
  char** pPtrArr;

  HSTENT* pHostEnt;

  if(pNameBuf == NULL)
    return(NULL);

  //-----------------------------------------------------------
  // C-Version, get Information to process  
  //-----------------------------------------------------------
  pCHostEnt = gethostbyname(pNameBuf+NameOff);
  if(pCHostEnt == NULL)
    return(NULL);
  //-----------------------------------------------------------
  // Allocate structure, clear
  //-----------------------------------------------------------
  if((pHostEnt = (HSTENT*)
	((void *) BIT8_ARRAY_CALLOC(HMEM_CTX_REF,
				    1,sizeof(HSTENT)))) == NULL)
    return(NULL);
  //-----------------------------------------------------------
  // Transfer data from static structure to allocated
  //-----------------------------------------------------------
  if((pCHostEnt->h_name != NULL) && ((int) strlen(pCHostEnt->h_name) > 0))
  {
    if((pHostEnt->pHostName =
          Strdup(HMEM_CTX_REF1 pCHostEnt->h_name,0)) == NULL)
    {
      FreeHostentStruct(HMEM_CTX_REF1 pHostEnt);
      return(NULL);
    }
  }
  //-----------------------------------------------------------
  // Copy Alias Array if present
  //-----------------------------------------------------------
  pCPtrArr = pCHostEnt->h_aliases;
  if((pCPtrArr != NULL) && (pCPtrArr[0] != NULL))
  {
    Len = 0;
    while(pCPtrArr[Len] != NULL)		// count elements
      Len++;
    if((pPtrArr = (char**)
          ((void *) BIT8_ARRAY_CALLOC(HMEM_CTX_REF,
				      Len,sizeof(char*)))) == NULL)
    {
      FreeHostentStruct(HMEM_CTX_REF1 pHostEnt);
      return(NULL);
    }
    pHostEnt->pAliasArr = pPtrArr;
    pHostEnt->AliasNamesCnt = Len;
    while(Len != 0)
    {
      Len--;
      if((pPtrArr[Len] = 
            Strdup(HMEM_CTX_REF1 pCPtrArr[Len],0)) == NULL)
      {
        FreeHostentStruct(HMEM_CTX_REF1 pHostEnt);
        return(NULL);
      }
    }
  }
  //-----------------------------------------------------------
  // Copy Address family, address length
  //-----------------------------------------------------------
  pHostEnt->AdrFamily = pCHostEnt->h_addrtype;
  AdrLen = pCHostEnt->h_length;
  pHostEnt->AdrLen    = AdrLen;
  //-----------------------------------------------------------
  // Copy Address Array if present
  //-----------------------------------------------------------
  pCPtrArr = pCHostEnt->h_addr_list;
  if((AdrLen > 0) && (pCPtrArr != NULL) && (pCPtrArr[0] != NULL))
  {
    Len = 0;
    while(pCPtrArr[Len] != NULL)		// count elements
      Len++;
    if((pPtrArr = (char**)
	  ((void *) BIT8_ARRAY_CALLOC(HMEM_CTX_REF,
				      Len,sizeof(char*)))) == NULL)
    {
      FreeHostentStruct(HMEM_CTX_REF1 pHostEnt);
      return(NULL);
    }
    pHostEnt->pAdrArr = pPtrArr;
    pHostEnt->AdrCnt = Len;
    while(Len != 0)
    {
      Len--;
      if((pPtrArr[Len] =
            BIT8_ARRAY_CALLOC(HMEM_CTX_REF,1,AdrLen)) == NULL)
      {
        FreeHostentStruct(HMEM_CTX_REF1 pHostEnt);
        return(NULL);
      }
      memcpy(pPtrArr[Len],pCPtrArr[Len],AdrLen);
    }
  }
  return(pHostEnt);
}

/**
* Gets local hosts name as fully qualified name (ASCIIz) (HGetHostName).
*
*  @param pNameBuf Buffer where to store name
*  @param NameOff Start of data
*  @param NameBufLen length of buffer
*  @return 0 o.k., else error occured
*/
extern "C"  int  HGetHostName(char* pNameBuf, int NameOff,
				    int NameBufLen)
{

  char TmpBuf[NI_MAXHOST];
  int Len;

  struct hostent * pHostEnt;
  int Retcode;
  int FullLen;

  if(pNameBuf == NULL)
    return(-1);

  //------------------------------------------------------------
  // C-Version, retrieve name, check if present
  //------------------------------------------------------------
  TmpBuf[0] = 0;
  Retcode = gethostname(TmpBuf,NI_MAXHOST-1);
  Len = (int) strlen(TmpBuf);
  if((Retcode != 0) || (Len <= 0))		// failed
    return(1);
  //------------------------------------------------------------
  // supply name to more global function and retry
  //------------------------------------------------------------
  pHostEnt = gethostbyname(TmpBuf);  
  if((pHostEnt != NULL) && (pHostEnt->h_name != NULL) &&  
      ((FullLen = (int) strlen(pHostEnt->h_name)) > 0))
  {
    if(FullLen > Len)
    {
      strncpy(TmpBuf,pHostEnt->h_name,NI_MAXHOST-1);
      TmpBuf[NI_MAXHOST-1] = 0;
    }
  }
  //------------------------------------------------------------
  // Copy name to user
  //------------------------------------------------------------
  Len = (int) strlen(TmpBuf);
  if(Len > NameBufLen+1)
    return(2);
  strcpy(pNameBuf+NameOff,TmpBuf);
  return(0);
}

//()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()
//
// Connection related functions (socket functions)
//
//()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()

/**
* Get remote/local partner's name (i.e. its IP address and port)
* from a connected socket (GetLclRemSockName).
* If successful, structure is filled.
*
*  @param TheSocket connected socket
*  @param pAdrStruc Address structure
*  @param Mode 0 - local, else remote
*
*  @return 0 on success, else error occured
*/
static  int  GetLclRemSockName(SOCKET TheSocket,
				   SADDRIN * pAdrStruc, int Mode)
{
  int Retcode;
  struct sockaddr_in SinAddr;
  SOCKLEN_T AddrLen = sizeof(struct sockaddr_in);

  int AdrFamily,AdrLen;

  if(pAdrStruc == NULL)
    return(-1);

  //-----------------------------------------------------
  // C-Function, get structure and copy to supplied
  //-----------------------------------------------------
  if(Mode == 0)
    Retcode = getsockname(TheSocket,
                   (struct sockaddr *)((void *) &SinAddr),
                   (SOCKLEN_T *) &AddrLen);
  else  
    Retcode = getpeername(TheSocket,
                   (struct sockaddr *)((void *) &SinAddr),
                   (SOCKLEN_T *) &AddrLen);
  if(Retcode != 0)
    return(1);					// failed  

  AdrFamily = SinAddr.sin_family;
  if((AdrFamily != AF_INET) && (AdrFamily != AF_INET6))
    return(2);

  pAdrStruc->AdrFamily = AdrFamily;
  if(AdrFamily == AF_INET)			// IPV4
    AdrLen = IPV4_ADRLEN;
  else
    AdrLen = IPV6_ADRLEN;
  pAdrStruc->AdrLen = AdrLen;
  pAdrStruc->Port   = ntohs(SinAddr.sin_port);
  memcpy(pAdrStruc->InetAdr+0,&SinAddr.sin_addr+0,AdrLen);
  return(0);

}

/**
* Gets peers IP address and port (GetPeerName).
* If successful, structure is filled.
*
*  @param TheSocket Connected socket
*  @param pRemAdrStruc Address structure to be filled
*
*  @return 0 on success, else error occured
*/
extern "C"  int  GetPeerName(SOCKET TheSocket,
				   SADDRIN * pRemAdrStruc)
{
  return(GetLclRemSockName(TheSocket,pRemAdrStruc,1));
}

/**
* Gets local ends IP address and port (GetSockName).
* If successful, structure is filled.
*
*  @param TheSocket Connected socket
*  @param pLclAdrStruc Address structure to befilled
*
*  @return 0 on success, else error occured
*/
extern "C"  int  GetSockName(SOCKET TheSocket,
				   SADDRIN * pLclAdrStruc)
{
  return(GetLclRemSockName(TheSocket,pLclAdrStruc,0));
}

//#if !defined __HSSH__		// not needed for SSH
/**
* Gets current option setting from a socket.
* Note: only partial implemented:
<table>
<tr><td>Option name</td><td>C</td><td>Java</td><td>C#</td></tr>
<tr><td>TCP_NODELAY</td><td>yes</td><td>yes</td><td>yes</td></tr>
<tr><td>SO_LINGER</td><td>yes</td><td>yes</td><td>yes</td></tr>
<tr><td>SO_REUSEADDR</td><td>yes</td><td>no</td><td>yes</td></tr>
<tr><td>SO_KEEPALIVE</td><td>yes</td><td>Java 1.3 and higher</td><td>yes</td></tr>
</table>
*
*  @param TheSocket Socket to query
*  @param OptName Option to fetch
*  @param pOptState actual state
*  @param pAddVal Additional data/Null
*
*  @return 0 on success, else error occured
*/
//GetSockOpt
extern "C"  int  GetSockOpt(SOCKET TheSocket, int OptName,
				  int* pOptState, int* pAddVal)
{

  char RetVal[16];
  SOCKLEN_T RetLen = sizeof(BOOL);
  struct linger LingerStruct;

  if(pOptState == NULL)
    return(-1);

  pOptState[0] = 0;			// preset 'FALSE' i.e. disabled
  //----------------------------------------------------------------
  // Distribute by option
  //----------------------------------------------------------------
  switch(OptName)
  {
    //--------------------------------------------------------
    // TCP_NODELAY Option, JAVA: supported since V1.1
    //--------------------------------------------------------
    case SOCK_OPT_TCP_NODELAY:
      if(getsockopt(TheSocket,IPPROTO_TCP,TCP_NODELAY,RetVal,&RetLen) != 0)
        return(1);
      if(*((BOOL*) RetVal) != 0)
        pOptState[0] = 1;
      return(0);
    //--------------------------------------------------------
    // Keepalive Option, JAVA: not supported (V1.3 needed)
    //--------------------------------------------------------
    case SOCK_OPT_KEEPALIVE:
      if(getsockopt(TheSocket,SOL_SOCKET,SO_KEEPALIVE,RetVal,&RetLen) != 0)
        return(1);
      if(*((BOOL*) RetVal) != 0)
        pOptState[0] = 1;
      return(0);
    //--------------------------------------------------------
    // Reuse Address Option, JAVA: not supported
    //--------------------------------------------------------
    case SOCK_OPT_REUSEADDR:
      if(getsockopt(TheSocket,SOL_SOCKET,SO_REUSEADDR,RetVal,&RetLen) != 0)
        return(1);
      if(*((BOOL*) RetVal) != 0)
        pOptState[0] = 1;
      return(0);
    //--------------------------------------------------------
    // Linger Option
    //--------------------------------------------------------
    case SOCK_OPT_LINGER:
      RetLen = sizeof(struct linger);
      if(getsockopt(TheSocket,SOL_SOCKET,SO_LINGER,
          (char*) ((void *) &LingerStruct),&RetLen) != 0)
        return(1);
      if(LingerStruct.l_onoff != 0)
        pOptState[0] = 1;
      if(pAddVal != NULL)
        pAddVal[0] = LingerStruct.l_linger;
      //------------------------------------------------
      return(0);

    default:
      return(-2);
  }
}
//#endif // !defined __HSSH__

/**
* Sets option for a socket (SetSockOpt).
* Note: only partial implemented !
* 
* See GetSockOpt.
*
*  @param TheSocket Socket to query
*  @param OptName Option to set
*  @param OptState state to set 0 - off
*  @param AddVal Additional data
*
*  @return 0 on success, else error occured
*/
extern "C"  int  SetSockOpt(SOCKET TheSocket, int OptName,
				  int OptState, int AddVal)
{

  BOOL BoolVal = (OptState != 0) ? 1 : 0;
//  int RetLen = sizeof(BOOL);
  struct linger LingerStruct;
  //----------------------------------------------------------------
  // Distribute by option
  //----------------------------------------------------------------
  switch(OptName)
  {
    //--------------------------------------------------------
    // TCP_NODELAY Option, JAVA: supported since V1.1
    //--------------------------------------------------------
    case SOCK_OPT_TCP_NODELAY:
      if(setsockopt(TheSocket,IPPROTO_TCP,TCP_NODELAY,
          (const char *) ((void *) &BoolVal),sizeof(BOOL)) != 0)
        return(1);
      return(0);
    //--------------------------------------------------------
    // Keepalive Option, JAVA: not supported (V1.3 needed)
    //--------------------------------------------------------
    case SOCK_OPT_KEEPALIVE:
      if(setsockopt(TheSocket,SOL_SOCKET,SO_KEEPALIVE,
	  (const char*) ((void *) &BoolVal),sizeof(BOOL)) != 0)
        return(1);
      return(0);
    //--------------------------------------------------------
    // Reuse Address Option, JAVA: not supported
    //--------------------------------------------------------
    case SOCK_OPT_REUSEADDR:
      if(setsockopt(TheSocket,SOL_SOCKET,SO_REUSEADDR,
	(const char*) ((void *) &BoolVal),sizeof(BOOL)) != 0)
        return(1);
      return(0);
    //--------------------------------------------------------
    // Linger Option
    //--------------------------------------------------------
    case SOCK_OPT_LINGER:
      if((OptState == 0) || (AddVal == 0) || (AddVal == -1))
      {
        LingerStruct.l_onoff = 0;
        LingerStruct.l_linger = 0;
      }
      else
      {
        LingerStruct.l_onoff = 1;
        LingerStruct.l_linger = (short) AddVal;
      }
      if(setsockopt(TheSocket,SOL_SOCKET,SO_LINGER,
	(const char*) ((void *) &LingerStruct),sizeof(struct linger)) != 0)
        return(1);
      return(0);

    default:
      return(-2);
  }
}

/**
* Sets socket mode Blocking/Non Blocking (IoctlSocket).
* Note: simulated for JAVA by setting the timeout on the socket
*
*  @param TheSocket Socket to query
*  @param Mode 0 - non blocking
*  @param Timeout Timeout for Java.
*
*  @return 0 on success, else error occured
*/
extern "C"  int  IoctlSocket(SOCKET TheSocket, int Mode, int )
{

  uint32_t Arg = 0;			// false: blocking mode

  // UNIX / WIN mode
  if(Mode == 0)
    Arg = 1;				// set blocking mode
#if !(defined _WIN32)  // not windows -> UNIX
  if(ioctl(TheSocket,FIONBIO,&Arg) != 0)
#else
  if(ioctlsocket(TheSocket,FIONBIO,(unsigned long*)&Arg) != 0)
#endif
    return(1);
  return(0);
}

/**
* Converts an unsigned 16 Bit Value to shortest Ascii Decimal
* representation (WordToDecimalAscii).
* NOTE: No parameters checked.
*
*  @param BinWord Word to convert (Lower 2 bytes)
*  @param pDstBuf Destination buffer
*  @param DstOff Start offset for writing
*  @return Bytes written
*/
extern "C"  int  WordToDecimalAscii(int BinWord,
			char* pDstBuf, int DstOff)
{
  int Index = 0;
  int Len;
  char TmpBuf[5];
  //---------------------------------------------------------
  // Limit Value to 16 bit and convert to decimal (reversed!)
  //---------------------------------------------------------
  BinWord &= 0xFFFF;				// limit to 16 Bits
  do
  {
    TmpBuf[Index++] = (char) ((BinWord % 10) + 0x30);	// lowest Remainder
    BinWord /= 10;				// divide down
  }while(BinWord != 0);
  //---------------------------------------------------------
  // Copy string in reversed order to destination
  //---------------------------------------------------------
  Len = Index;
  do
  {
    Index--;
    pDstBuf[DstOff++] = TmpBuf[Index];
  }while(Index > 0);
  return(Len);
}
/**
* Gets length of ARPA hostname from Full Qualified Domain Name (GetArpaHostnameLen).
* A valid ARPA Hostname has the following properties: <ul>
* <li> Name can only consist of digits, letters and hyphens.
* <li> Name must start with letter.
* <li> Name must end with letter or digit.
*</ul>
*  @param pNameBuf Buffer with name
*  @param NameOff Start of data
*  @param NameLen Length of data
*  @return Bytes written, <=0 if not found
*/
static  int  GetArpaHostnameLen(char* pNameBuf, int NameOff,
					   int NameLen)
{
  int c;
  int StartOff = NameOff;

  if((pNameBuf == NULL) || (NameLen <= 0))
    return(0);
  //--------------------------------------------------
  // Check start condition
  //--------------------------------------------------
  c = (int) pNameBuf[NameOff++] & 0xFF;
  NameLen--;
  if(IsAlpha(c) == 0)		// does not start with letter
    return(0);
  if(NameLen == 0)
    return(1);
  //--------------------------------------------------
  // Scan along while name condition satiesfied
  //--------------------------------------------------
  while(NameLen > 0)
  {
    c = (int) pNameBuf[NameOff] & 0xFF;
    if((IsAlnum(c) == 0) && (c != '-'))
      return(NameOff - StartOff);
    NameOff++;
    NameLen--;
  }
  if(IsAlnum(c) == 0)	// not proper ended
    return(0);
  return(NameOff - StartOff);
}
/**
* Checks, if a given IP-Address belongs to the local host (CheckLocalInetAdr).
*
*  @param pAdrStruc Address structure to be tested
*  @return > 0 is an address of the local host
* <br>            == 0 does not belong to the local host
* <br>            < 0 Error occurred
*/
extern "C"  int  CheckLocalInetAdr(HMEM_CTX_DEF
			SADDRIN * pAdrStruc)
{
  int AdrFamily,AdrLen,AdrCnt;
  char NameBuf[NI_MAXHOST];
  HSTENT* pHostEnt = NULL;
  char* pActAdr;
  //-------------------------------------------------------
  // verify Input address
  //-------------------------------------------------------
  if(pAdrStruc == NULL)
    return(0);

  AdrFamily = pAdrStruc->AdrFamily;
  AdrLen    = pAdrStruc->AdrFamily;
  if((AdrFamily != AF_INET) && (AdrFamily != AF_INET6))
    return(-1);

  if(((AdrFamily == AF_INET) && (AdrLen != IPV4_ADRLEN)) ||
     ((AdrFamily == AF_INET6) && (AdrLen != IPV6_ADRLEN)))
    return(-1);
  //-------------------------------------------------------
  // get name of the local host
  //-------------------------------------------------------
  if(HGetHostName(NameBuf,0,NI_MAXHOST-1) != 0)
    return(-1);
  //-------------------------------------------------------
  // get adresses of the local host
  //-------------------------------------------------------
  if((pHostEnt = HGetHostByName(HMEM_CTX_REF1 NameBuf,0)) == NULL)
    return(-1);
  if(((AdrCnt = pHostEnt->AdrCnt) > 0) &&
      (pHostEnt->AdrFamily == AdrFamily) &&
      (pHostEnt->AdrLen == AdrLen))
  {
    //------------------------------------------------------
    // Adresses are present, same family and length, compare
    //------------------------------------------------------
    while(AdrCnt > 0)
    {
      AdrCnt--;				// predecrement, use as index
      pActAdr = pHostEnt->pAdrArr[AdrCnt];
      if(Memcmp(pActAdr,0,pAdrStruc->InetAdr,0,AdrLen) == 0)
      {
        FreeHostentStruct(HMEM_CTX_REF1 pHostEnt);
        return(1);
      }        
    }
  }
  FreeHostentStruct(HMEM_CTX_REF1 pHostEnt);
  return(0);
}
/**
* Parse a String representation of a 16 bit unsigned integer
* Value, skips leading whitespaces, checks for trailing whitespaces (DecimalAsciiToWord).
* NOTE: no parameters checked !!!
*
*  @param pSrcBuf String to scan
*  @param SrcOff Start of data
*  @param SrcLen Length of data
*  @return BIT32 Value >= 0 else parse error
*/
static  int  DecimalAsciiToWord(char* pSrcBuf, int SrcOff,
			int SrcLen)
{
  char c = 0;
  int Value = 0;
  //---------------------------------------------------------
  // Skip whitespaces till start
  //---------------------------------------------------------
  if((pSrcBuf == NULL) || (SrcLen <= 0))
    return(-1);
  while(SrcLen > 0)
  {
    c = pSrcBuf[SrcOff];
    if((c != (unsigned char) 0x09) && (c != (unsigned char) 0x20))
      break;
    SrcOff++;
    SrcLen--;
  }
  if((SrcLen <= 0) ||
     (!((c >= (unsigned char) 0x30) && (c <= (unsigned char) 0x39))))
    return(-1);
  //---------------------------------------------------------
  // Parse the number
  //---------------------------------------------------------
  while(SrcLen > 0)
  {
    c = pSrcBuf[SrcOff];
    if(!((c >= (unsigned char) 0x30) && (c <= (unsigned char) 0x39)))
      break;
    c -= (unsigned char) 0x30;
    Value = (Value * 10) + ((int) c & 0xFF);
    if((Value & 0xFFFF0000) != 0)
      return(-2);				// overflow
    SrcOff++;
    SrcLen--;
  }
  //---------------------------------------------------------
  // assure only trailing whitespaces
  //---------------------------------------------------------
  while(SrcLen > 0)
  {
    c = pSrcBuf[SrcOff++];
    SrcLen--;
    if((c != (unsigned char) 0x09) && (c != (unsigned char) 0x20))
      return(-3);
  }
  return(Value);
}

/**
* Resolves host name and port (GetNameInfo).
* IPV6 compatible. Address can be resolved to numerical or name formats.
*
*  @param pAdrStruc Address structure to query
*  @param pHostName Buffer for address. Optional
*  @param HostNameOff Start offset for writing address 
*  @param HostNameBufLen Length of host name buffer
*  @param pPortName Buffer for port. Optional
*  @param PortNameOff Start offset for writing port
*  @param PortNameBufLen Length of port buffer
*  @param Flags see IPV6 API spec.
*  @return 0 on success, else error occured
*/
extern "C"  int  GetNameInfo(HMEM_CTX_DEF
			SADDRIN * pAdrStruc,
			char* pHostName, int HostNameOff, int HostNameBufLen,
			char* pPortName, int PortNameOff, int PortNameBufLen,
			int Flags)
{
  char TmpNameBuf[NI_MAXHOST];
  int AdrFamily,AdrLen;
  int Len,NameLen;
  HSTENT* pHostEnt = NULL;
  //--------------------------------------------------------------
  // Check Parameters
  //--------------------------------------------------------------
  if((pAdrStruc == NULL) ||
     ((pHostName == NULL) && (pPortName == NULL)))
    return(-1);

  if((Flags & 
        (~(NI_NOFQDN | NI_NUMERICHOST | NI_NAMEREQD | NI_NUMERICSERV)))!= 0)
    return(EAI_BADFLAGS);

  if(((pHostName != NULL) && (HostNameBufLen <= 0)) ||
     ((pPortName != NULL) && (PortNameBufLen <= 0)))
    return(EAI_NONAME);

  AdrFamily = pAdrStruc->AdrFamily;
  AdrLen    = pAdrStruc->AdrLen;
  if((AdrFamily != AF_INET) && (AdrFamily != AF_INET6))
    return(EAI_ADDRFAMILY);

  if(((AdrFamily == AF_INET) && (AdrLen != IPV4_ADRLEN)) ||
     ((AdrFamily == AF_INET6) && (AdrLen != IPV6_ADRLEN)))
    return(-2);
  //------------------------------------------------------------
  // Process Port if requested
  //------------------------------------------------------------
  if(pPortName != NULL)				// must return Port
  {
    if((Flags & NI_NUMERICSERV) == 0)		// not numeric
      pPortName[PortNameOff] = 0;		// set not resolveable
    else					// is numeric request
    {
      Len = WordToDecimalAscii(pAdrStruc->Port,TmpNameBuf,0);
      TmpNameBuf[Len] = 0;
      if(PortNameBufLen <= Len)			// too few
        return(-3);
      memcpy(pPortName+PortNameOff,TmpNameBuf+0,Len+1);
    }
  }
  //-----------------------------------------------------------
  // Process Address if requested
  //-----------------------------------------------------------
  if(pHostName == NULL)
    return(0);
  //-----------------------------------------------------------
  // Check if all numeric name is requested
  //-----------------------------------------------------------
  if((Flags & NI_NUMERICHOST) != 0)
  {
    if((Len = InetNtop(AdrFamily,pAdrStruc->InetAdr,0,
	               TmpNameBuf,0,INET6_ADDRSTRLEN,0)) <= 0)
       return(-4);				// should not happen
    if(Len >= HostNameBufLen)
      return(-3);
    memcpy(pHostName+HostNameOff,TmpNameBuf+0,Len);
    pHostName[HostNameOff+Len] = 0;
    return(0);
  }
  //-----------------------------------------------------------
  // Name shall be retrieved, fetch it
  //-----------------------------------------------------------
  pHostEnt = GetHostByAddr(HMEM_CTX_REF1 pAdrStruc);
  if((pHostEnt != NULL) && (pHostEnt->pHostName != NULL) &&
     ((Len = Strlen(pHostEnt->pHostName,0)) > 0))
  {
    //---------------------------------------------------------
    // Found a hostname
    //---------------------------------------------------------
    if((Flags & NI_NOFQDN) != 0)		// name portion only
    {
      NameLen = GetArpaHostnameLen(pHostEnt->pHostName,0,Len);
      if(NameLen < Len)
      {
        //------------------------------------------------------------------
        // is a full qualified name, check if the address was for local host
        //------------------------------------------------------------------
        if(CheckLocalInetAdr(HMEM_CTX_REF1 pAdrStruc) > 0) // is a local one
          Len = NameLen;			// truncate name
      }
    }
    //-----------------------------------------------------------
    // copy name to user
    //-----------------------------------------------------------
    if(Len >= HostNameBufLen)
      return(-3);
    memcpy(pHostName+HostNameOff,pHostEnt->pHostName+0,Len);
    pHostName[HostNameOff+Len] = 0;
    FreeHostentStruct(HMEM_CTX_REF1 pHostEnt);
    return(0);
  }
  //-----------------------------------------------------------
  // No name available, check if name must be present
  //-----------------------------------------------------------
  FreeHostentStruct(HMEM_CTX_REF1 pHostEnt);
  if((Flags & NI_NAMEREQD) != 0)
    return(EAI_NODATA);
  //-----------------------------------------------------------
  // use the address as the name
  //-----------------------------------------------------------
  if((Len = InetNtop(AdrFamily,pAdrStruc->InetAdr,0,
	             TmpNameBuf,0,INET6_ADDRSTRLEN,0)) <= 0)
     return(-4);				// should not happen
  if(Len >= HostNameBufLen)
    return(-3);
  memcpy(pHostName+HostNameOff,TmpNameBuf+0,Len);
  pHostName[HostNameOff+Len] = 0;
  return(0);
}

/**
* Resolves host- and/or servicename to address (GetAddrInfo). 
* IPV6 compatible.
*
*  @param pHostName Hostname, ASCIIz
*  @param HostNameOff Start of host name
*  @param pServName Servicename, ASCIIz
*  @param ServNameOff Start of service name
*  @param pHint Hints Structure / NULL
*  @param ppAdrInfo returned list of structures
*  @return 0 on success, else error occured
*/
extern "C"  int  GetAddrInfo(HMEM_CTX_DEF
			char* pHostName, int HostNameOff,
			char* pServName, int ServNameOff,
			ADDRINF * pHint, ADDRINF ** ppAdrInfo)
{
  int HintFlags  = 0;
  int HintFamily = PF_UNSPEC;		// all V4 / V6
  int HintSockType  = SOCK_STREAM;	// streams only supported
  int HintProtocol = IPPROTO_IP;	// IPV4 

  int AdrLen,AdrType,AdrFamily,AdrProtocol,ProtoFamily;
  int AdrCount;
  int Index;

  int HostNameLen = 0;
  int ServNameLen = 0;
  int Port = 0;
  int TmpVal;
  char NameBuf[NI_MAXHOST];
  SADDRIN * pAdrStruc;
  HSTENT* pHostEnt = NULL;
  ADDRINF * pBaseInfo;
  ADDRINF * pLastInfo;
  ADDRINF * pNextInfo;
  char* pBufPtr;
  char** pAdrArr;
  //----------------------------------------------------
  // check parameters
  //----------------------------------------------------
  if(ppAdrInfo == NULL)
    return(-1);
  HostNameLen = Strlen(pHostName,HostNameOff);
  ServNameLen = Strlen(pServName,ServNameOff);

  if((HostNameLen <= 0) && (ServNameLen <= 0))
    return(EAI_NONAME);
  //----------------------------------------------------
  // check parameters
  //----------------------------------------------------
  if(pHint != NULL)
  {
    //-------------------------------------------------------
    // Check Hint structure for reserved and correct settings
    //-------------------------------------------------------
    if((pHint->AdrLen != 0) ||
       (pHint->pCanonName != NULL) ||
       (pHint->pSockAdr != NULL) ||
       (pHint->pNext != NULL))
       return(-2);				// param error

    HintFlags  = pHint->Flags;
    HintFamily = pHint->AdrFamily;	// is actually ProtocolFam.
    HintSockType = pHint->SockType;
    HintProtocol = pHint->Protocol;

    if((HintFlags & (~(AI_PASSIVE | AI_CANONNAME | AI_NUMERICHOST))) != 0)
      return(EAI_BADFLAGS);
    if((HintFamily != PF_UNSPEC) && (HintFamily != PF_INET) &&
       (HintFamily != PF_INET6))
      return(EAI_FAMILY);
    if((HintSockType != 0) && (HintSockType != SOCK_STREAM))    
      return(EAI_SOCKTYPE);
    if((HintProtocol != IPPROTO_IP) && (HintProtocol != IPPROTO_IPV6))
      return(EAI_FAMILY);
  }
  //------------------------------------------------------------------
  // Check if Service shall be processed, check if specified as number
  //------------------------------------------------------------------
  if(ServNameLen != 0)
  {
    if((TmpVal = DecimalAsciiToWord(pServName,ServNameOff,ServNameLen)) < 0)
      return(EAI_SERVICE);
    Port = (int) TmpVal;
  }
  //------------------------------------------------------------------
  // Check if a hostname is given at all, if not: specific case!!!
  //------------------------------------------------------------------
  if(HostNameLen == 0)
  {
    if(HintFamily == PF_UNSPEC)			// none given
      return(EAI_FAMILY);
    if((pBaseInfo = AllocAddrInfoStruct(HMEM_CTX_REF1 0)) == NULL)
      return(EAI_MEMORY);

    if(HintFamily == PF_INET)
    {
      AdrFamily = AF_INET;
      AdrLen    = IPV4_ADRLEN;
    }
    else
    {
      AdrFamily = AF_INET6;
      AdrLen    = IPV6_ADRLEN;
    }

    pBaseInfo->AdrFamily = HintFamily;
    pBaseInfo->SockType  = SOCK_STREAM;
    pBaseInfo->Protocol  = HintProtocol;
    pBaseInfo->AdrLen    = AdrLen;  

    pAdrStruc = pBaseInfo->pSockAdr;

    pAdrStruc->AdrFamily = AdrFamily;
    pAdrStruc->AdrLen    = AdrLen;
    pAdrStruc->Port      = Port;
    if((HintFlags & AI_PASSIVE) == 0)
    {
      //-------------------------------------------------------
      // set local loopback address (127.0.0.1 / 0::1)
      //-------------------------------------------------------
      pBufPtr = pAdrStruc->InetAdr;
      if(AdrFamily == AF_INET)
      {
        pBufPtr[0] = 127;
        pBufPtr[3] = 1;
      }
      else
        pBufPtr[15] = 1;
    }
    ppAdrInfo[0] = pBaseInfo;
    return(0);
  }
  //------------------------------------------------------------------
  // Hostname given, check Format of supplied hostname
  // NOTE: the further checks show if it was *really* a numeric address
  //------------------------------------------------------------------
  for(;;) // error for
  {
    if((AdrType =
        GetInetAddressStringType(pHostName,HostNameOff,HostNameLen)) >= 0)
    {
      //---------------------------------------------------
      // Could be a numeric IP address, convert to Address
      //---------------------------------------------------
      if(AdrType == 0)				// IPV4
      {
        AdrLen = IPV4_ADRLEN;
        AdrFamily = AF_INET;
        if((HintFamily != PF_UNSPEC) && (HintFamily != PF_INET))
          return(EAI_ADDRFAMILY);
      }
      else					// IPV6
      {
        AdrLen = IPV6_ADRLEN;
        AdrFamily = AF_INET6;
        if((HintFamily != PF_UNSPEC) && (HintFamily != PF_INET6))
          return(EAI_ADDRFAMILY);
      }
      if(InetPton(AdrFamily,pHostName,HostNameOff,HostNameLen,NameBuf,0) > 0)
      {
        //---------------------------------------------------
        // is a numeric address, convert to structure
        //---------------------------------------------------
        pAdrStruc = (SADDRIN *)
          ((void*) BIT8_ARRAY_ALLOC(HMEM_CTX_REF,sizeof(SADDRIN)));
        if(pAdrStruc == NULL)      
          return(EAI_MEMORY);
        pAdrStruc->AdrFamily = AdrFamily;
        pAdrStruc->AdrLen    = AdrLen;
        pAdrStruc->Port	   = Port;
        memcpy(pAdrStruc->InetAdr+0,NameBuf+0,AdrLen);
        //---------------------------------------------------
        // get hostent from Address
        //---------------------------------------------------
        pHostEnt = GetHostByAddr(HMEM_CTX_REF1 pAdrStruc);
        FREE_ARRAY(HMEM_CTX_REF,pAdrStruc);
        if(pHostEnt == NULL)
          return(EAI_NODATA);
        break;					// got Hostent !
      }
    }
    //--------------------------------------------------------
    // A host name in DNS format has been given
    //--------------------------------------------------------
    if((HintFlags & AI_NUMERICHOST) != 0)	// but has been specified so!
      return(EAI_NONAME);

    pHostEnt = HGetHostByName(HMEM_CTX_REF1 pHostName,HostNameOff);
    if(pHostEnt == NULL)
      return(EAI_NODATA);
    break;
  } // Error FOR
  //--------------------------------------------------------------
  // HostEntry Structure is present, check if any addresses present
  // and the host name is there (if requested)
  //--------------------------------------------------------------
  if(((AdrCount = pHostEnt->AdrCnt) <= 0) || // no addresses specified
    ((pHostEnt->pHostName == NULL) &&	     // no Name
     ((HintFlags & AI_CANONNAME) != 0)))	     // but required !
  {
    FreeHostentStruct(HMEM_CTX_REF1 pHostEnt);
    return(EAI_NODATA);
  }
  //--------------------------------------------------------------
  // Check if the returned information is compatible with hints
  //--------------------------------------------------------------
  pAdrArr   = pHostEnt->pAdrArr;
  AdrFamily = pHostEnt->AdrFamily;
  AdrLen    = pHostEnt->AdrLen;
  if(((AdrFamily != AF_INET) && (AdrFamily != AF_INET6)) ||
      ((AdrFamily == AF_INET) && (AdrLen != IPV4_ADRLEN)) ||
      ((AdrFamily == AF_INET6) && (AdrLen != IPV6_ADRLEN)))
  {
    FreeHostentStruct(HMEM_CTX_REF1 pHostEnt);
    return(EAI_NODATA);
  }
  if(AdrFamily == AF_INET)
  {
    AdrProtocol = IPPROTO_IP;
    ProtoFamily = PF_INET;
  }
  else
  {
    AdrProtocol = IPPROTO_IPV6;
    ProtoFamily = PF_INET6;
  }

  if(((HintFamily != PF_UNSPEC) && (HintFamily != ProtoFamily)) ||
     ((HintProtocol != IPPROTO_IP) && (HintProtocol != AdrProtocol)))
  {
    FreeHostentStruct(HMEM_CTX_REF1 pHostEnt);
    return(EAI_NODATA);
  }
  //--------------------------------------------------------------
  // Allocate the Basic Address Info Structure and load it
  //--------------------------------------------------------------
  Index = 0;
  if((pBaseInfo = AllocAddrInfoStruct(HMEM_CTX_REF1 0)) == NULL)
  {
    FreeHostentStruct(HMEM_CTX_REF1 pHostEnt);
    return(EAI_MEMORY);
  }
  pBaseInfo->AdrFamily = ProtoFamily;
  pBaseInfo->SockType  = SOCK_STREAM;
  pBaseInfo->Protocol  = AdrProtocol;
  pBaseInfo->AdrLen    = AdrLen;  

  if((HintFlags & AI_CANONNAME) != 0)
  {
    if((pBufPtr = Strdup(HMEM_CTX_REF1 pHostEnt->pHostName,0)) == NULL)
    {
      FreeHostentStruct(HMEM_CTX_REF1 pHostEnt);
      FreeAddrInfoStruct(HMEM_CTX_REF1 pBaseInfo);
      return(EAI_MEMORY);
    }
    pBaseInfo->pCanonName = pBufPtr;
  }   
  pAdrStruc = pBaseInfo->pSockAdr;
  pAdrStruc->AdrFamily = AdrFamily;
  pAdrStruc->AdrLen    = AdrLen;
  pAdrStruc->Port      = Port;
  memcpy(pAdrStruc->InetAdr+0,pAdrArr[Index]+0,AdrLen);
  AdrCount--;
  pLastInfo = pBaseInfo;
  while(AdrCount != 0)
  {
    //--------------------------------------------------
    // more than one address present
    //--------------------------------------------------
    Index++;					// to next address
    if((pNextInfo = AllocAddrInfoStruct(HMEM_CTX_REF1 0)) == NULL)
    {
      FreeAddrInfoStruct(HMEM_CTX_REF1 pBaseInfo);
      return(EAI_MEMORY);
    }
    pNextInfo->AdrFamily = ProtoFamily;
    pNextInfo->SockType  = SOCK_STREAM;
    pNextInfo->Protocol  = AdrProtocol;
    pNextInfo->AdrLen    = AdrLen;  

    pAdrStruc = pNextInfo->pSockAdr;
    pAdrStruc->AdrFamily = AdrFamily;
    pAdrStruc->AdrLen    = AdrLen;
    pAdrStruc->Port      = Port;
    memcpy(pAdrStruc->InetAdr+0,pAdrArr[Index]+0,AdrLen);

    pLastInfo->pNext = pNextInfo;
    pLastInfo = pNextInfo;
    AdrCount--;
  }
  FreeHostentStruct(HMEM_CTX_REF1 pHostEnt);
  ppAdrInfo[0] = pBaseInfo;
  return(0);
}

//()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()
//
// Connection/Data related socket functions
//
//()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()

/**
* Accepts incoming connections on the given listener socket (SockAccept).
* Construct the socket and fill the address structure from peer information.
*
*  @param ListenSocket Listener socket
*  @param pAddrStruc Address structure
*  @param pNewSock Accepted socket
*  @return 0 on success, else error occured
*/
extern "C"  int  SockAccept(SRVR_SOCKET ListenSocket,
			SADDRIN * pAddrStruc,
			SOCKET * pNewSock)
{
  struct sockaddr_in SrcAddr;
  SOCKLEN_T AddrLen = sizeof(struct sockaddr_in);
  int AdrLen = IPV4_ADRLEN;
  SOCKET ConnSock;

  if((pAddrStruc == NULL) || (pNewSock == NULL))
    return(-1);

  //----------------------------------------------------------
  // C style processing
  //----------------------------------------------------------
  ConnSock = (int) accept(ListenSocket,
                    (struct sockaddr*) ((void *) &SrcAddr),
		    (SOCKLEN_T * ) &AddrLen);
  if(ConnSock == INVALID_SOCKET)
    return(-2);

  pAddrStruc->AdrFamily = (int) SrcAddr.sin_family;
  if(SrcAddr.sin_family == AF_INET6)
    AdrLen = IPV6_ADRLEN;
  pAddrStruc->AdrLen = AdrLen;
  pAddrStruc->Port   = (int) ntohs(SrcAddr.sin_port);
  memcpy(pAddrStruc->InetAdr+0,&SrcAddr.sin_addr+0,AdrLen);
  pNewSock[0] = ConnSock;
  return(0);
}

/**
* Disables send, receive or both on a socket (SockShutdown).
*
*  @param TheSocket Socket to close
*  @param How 0 - Disable recv
*               1 - Disable send
*               2 - Disable both
*  @return 0 on success, else error occured
*/
extern "C"  int  SockShutdown(SOCKET TheSocket, int How)
{
  return(shutdown(TheSocket,How));  
}

/**
* Closes a socket (CloseSocket).
*
*  @param TheSocket Socket to close
*  @return 0 on success, else error occured
*/
extern "C"  int  CloseSocket(SOCKET TheSocket)
{
#if !(defined _WIN32)  // not windows -> UNIX
  return(close(TheSocket));
#else
  return(closesocket(TheSocket));  
#endif

}

/**
* Closes server (listening) socket (CloseServerSocket).
*
*  @param TheSocket Socket to close
*  @return 0 on success, else error occured
*/
extern "C"  int  CloseServerSocket(SRVR_SOCKET TheSocket)
{
#if !(defined _WIN32)  // not windows -> UNIX
  return(close(TheSocket));
#else
  return(closesocket(TheSocket));  
#endif

}

/**
* Checks, if a given IP address is a specific one or a special one (GetAdrType).
*
* NOTE: Not all special IPV6 addresses are checked.
*
*  @param pAddr Buffer with address
*  @param AddrLen Length of address
*  @return - < 0 Error occured
* <br>            == 0 Specific address
* <br>            == 1 Loopback
* <br>            == 2 NUL address (all zeroes)
* <br>            == 3 ALL Ones
* <br>            == 4 Broadcast/Multicast (IPV6)
*/
extern "C"  int  GetAdrType(char* pAddr, int AddrLen)
{
  unsigned char AndMask = (unsigned char) 0xFF;
  unsigned char OrMask  = 0;
  unsigned char IPV4LeadOrMask = 0;
  unsigned char IPV6LoopbackOrMask = 0;
  int Index = 0;
  int IPV4LeadEndIndex = IPV6_ADRLEN-IPV4_ADRLEN-2; // exclusive last 6 bytes
  int IPV6LoopbackEndIndex = IPV6_ADRLEN - 1;	    // 15 bytes

  if(pAddr == NULL)
    return(-1);
  if((AddrLen != IPV4_ADRLEN) && (AddrLen != IPV6_ADRLEN))
    return(-2);

  while(Index < AddrLen)
  {
    if(Index < IPV4LeadEndIndex)		// IPV6 embedded/mapped IPV4
      IPV4LeadOrMask = (char) (IPV4LeadOrMask | pAddr[Index]);
    if(Index < IPV6LoopbackEndIndex)
      IPV6LoopbackOrMask = (char) (IPV6LoopbackOrMask | pAddr[Index]);

    AndMask = (char) (AndMask & pAddr[Index]);
    OrMask  = (char) (OrMask | pAddr[Index++]);
  }
  if(OrMask == 0)
    return(2);					// all Zeroes

  if(AndMask == (unsigned char) 0xFF)
    return(3);					// all ones
  //----------------------------------------------------------
  // Check specific IPV6 addresses
  //----------------------------------------------------------
  if(AddrLen == IPV6_ADRLEN)
  {
    if(pAddr[0] == (char) ((unsigned char) 0x0FF))	// multicast
      return(4);
    if((IPV6LoopbackOrMask == 0) && (pAddr[15] == 0x01)) // 0:0:0:0:0:0:0:1
      return(1);				// IPV6 loopback
    if(IPV4LeadOrMask != 0)			// cannot be embedded/mapped V4
      return(0);
    OrMask = (unsigned char) (pAddr[10] | pAddr[11]);
    AndMask = (unsigned char) (pAddr[10] & pAddr[11]);

    if((OrMask != 0) && (AndMask != (unsigned char) 0xFF))// neither embedded nor mapped
      return(0);				// is an individual address
  }
  //----------------------------------------------------------
  // IPV4 or IPV6 embedded/mapped IPV4 address, check loopback
  //----------------------------------------------------------
  if(pAddr[AddrLen - IPV4_ADRLEN] == 127)	// V4 loopback
    return(1);
  return(0);
}
/**
* Generates a server socket (BindAndListen).
* Opens a stream socket, binds it to the provided address and
* set it into listen mode.
*
*  @param pListenAddr Listen Address,Port
*  @param BackLog Size of queue
*  @param pListenSock Generated listener socket
*  @return 0 on success, else error occured
*/
extern "C"  int  BindAndListen(SADDRIN * pListenAddr, int BackLog,
				     SRVR_SOCKET_PTR pListenSock)
{
  struct sockaddr_in SinAddr;
  SOCKLEN_T AddrLen = sizeof(struct sockaddr_in);
//  int AdrLen = IPV4_ADRLEN;
  int ListenPort = 0;
  int ListenAdrType = -1;
  int ListenFamily = 0;
  int ListenAdrLen = 0;
  SRVR_SOCKET ListenSock;

  if((pListenAddr == NULL) || (pListenSock == NULL))
    return(-1);
  //----------------------------------------------------------
  // Check if given Listener Address Family and port are valid
  //----------------------------------------------------------
  ListenFamily = pListenAddr->AdrFamily;
  if((ListenFamily != AF_INET) && (ListenFamily != AF_INET6))
    return(-2);
  ListenPort = pListenAddr->Port;
  if(ListenPort == 0)
    return(-2);
  //----------------------------------------------------------
  // Check if a listener address is given and if so is valid
  //----------------------------------------------------------
  ListenAdrLen = pListenAddr->AdrLen;
  if(ListenAdrLen != 0)
  {
    if(((ListenFamily == AF_INET) && (ListenAdrLen != IPV4_ADRLEN)) ||
       ((ListenFamily == AF_INET6) && (ListenAdrLen != IPV6_ADRLEN)))
      return(-2);
    ListenAdrType = GetAdrType(pListenAddr->InetAdr, ListenAdrLen);
    if(ListenAdrType < 0)
        return(-2);
  }

  //----------------------------------------------------------
  // C style processing, get a socket type Stream
  //----------------------------------------------------------
  ListenSock = (int) socket(ListenFamily,SOCK_STREAM, 0);
  if(ListenSock == INVALID_SOCKET)
    return(-3);
  //----------------------------------------------------------
  // bind to local address/port
  //----------------------------------------------------------
  memset(&SinAddr,0,AddrLen);
  SinAddr.sin_family = (SA_FAMILY_T) ListenFamily;
  SinAddr.sin_port   = htons((uint16_t) ListenPort);
  if((ListenAdrLen != 0) && ((ListenAdrType == 0) || (ListenAdrType == 3)))
    memcpy(&SinAddr.sin_addr+0,pListenAddr->InetAdr+0,ListenAdrLen);
  if(bind(ListenSock,(struct sockaddr*) ((void *) &SinAddr),AddrLen) != 0)
  {
#if !(defined _WIN32)  // not windows -> UNIX
    close(ListenSock);
#else
    closesocket(ListenSock);
#endif
    return(-4);
  }
  //----------------------------------------------------------
  // Put Socket into listen mode
  //----------------------------------------------------------
  if(listen(ListenSock,BackLog) != 0)
  {
#if !(defined _WIN32)  // not windows -> UNIX
    close(ListenSock);
#else
    closesocket(ListenSock);
#endif
    return(-5);
  }
  pListenSock[0] = ListenSock;
  return(0);

}

/**
* Generates a connected client socket (BindAndConnect).
* Gets a stream socket, bind it to local address, if requested and
* connect to the peer.
*
*  @param pDstAddr Peer address
*  @param pSrcAddr Local address. Optional
*  @param pNewSock Connected socket
*  @return - == 0 o.k., else error occured:
* <br>            < 0 - Parameter errors
* <br>            > 0 - Connection refusal:
* <br>            1 - Socket refused (WIN32/64, UNIX)
* <br>            2 - BIND refused (WIN32/64, UNIX, JAVA)
* <br>            3 - Connect refused (WIN32/64, UNIX, JAVA)
*/
extern "C"  int  BindAndConnect(SADDRIN * pDstAddr,
		SADDRIN * pSrcAddr, SOCKET * pNewSock)
{
  struct sockaddr_in SrcAddr;
  int AddrLen = sizeof(struct sockaddr_in);
//  int AdrLen = IPV4_ADRLEN;
  int Retcode;
  int DstFamily;
  int DstAdrLen;
  int DstPort;
  int SrcPort = 0;
  int SrcAdrType = -1;
  int SrcFamily = 0;
  int SrcAdrLen = 0;
  SOCKET ConnSock;

  if((pDstAddr == NULL) || (pNewSock == NULL))
    return(-1);
  //----------------------------------------------------------
  // Check if destination address is a valid, specific address
  // and a valid Destination port is given
  //----------------------------------------------------------
  DstPort = pDstAddr->Port;
  if(DstPort == 0)				// is invalid !
    return(-2);
  DstFamily = pDstAddr->AdrFamily;
  if((DstFamily != AF_INET) && (DstFamily != AF_INET6))
    return(-2);
  DstAdrLen = pDstAddr->AdrLen;
  if(((DstFamily == AF_INET) && (DstAdrLen != IPV4_ADRLEN)) ||
     ((DstFamily == AF_INET6) && (DstAdrLen != IPV6_ADRLEN)))     
    return(-2);

  Retcode = GetAdrType(pDstAddr->InetAdr,pDstAddr->AdrLen);
  if((Retcode != 0) && (Retcode != 1))		// also obey loopback...
    return(-2);
  //----------------------------------------------------------
  // Check if a source address is given and if so is valid
  //----------------------------------------------------------
  if(pSrcAddr != NULL)				// structure present
  {
    SrcFamily = pSrcAddr->AdrFamily;
    if(SrcFamily != DstFamily)
      return(-2);
    SrcAdrLen = pSrcAddr->AdrLen;
    if(SrcAdrLen != 0)
    {
     if(SrcAdrLen != DstAdrLen)
        return(-2);
      SrcAdrType = GetAdrType(pSrcAddr->InetAdr, SrcAdrLen);
      if(SrcAdrType < 0)
        return(-2);
    }
    SrcPort = pSrcAddr->Port;
  }

  //----------------------------------------------------------
  // C style processing, get a socket type Stream
  //----------------------------------------------------------
//  ConnSock = socket(SADDRIN_AdrFamily(pDstAddr),SOCK_STREAM, PF_INET);
  ConnSock = (int) socket(pDstAddr->AdrFamily,SOCK_STREAM,0);
  if(ConnSock == INVALID_SOCKET)
    return(1);
  //----------------------------------------------------------
  // Check if bind to local address/port is required
  //----------------------------------------------------------
  if((SrcPort != 0) || (SrcAdrType == 0) || (SrcAdrType == 1))
  {
    memset(&SrcAddr,0,AddrLen);
    SrcAddr.sin_family = (SA_FAMILY_T) SrcFamily;
    SrcAddr.sin_port = htons((uint16_t) SrcPort);
    if((SrcAdrLen != 0) && ((SrcAdrType == 0) || (SrcAdrType == 3)))
      memcpy(&SrcAddr.sin_addr+0,pSrcAddr->InetAdr+0,SrcAdrLen);
    if(bind(ConnSock,(struct sockaddr*) ((void *) &SrcAddr),AddrLen) != 0)
    {
      CloseSocket(ConnSock);
      return(2);
    }
  }
  //----------------------------------------------------------
  // Connect to the partner
  //----------------------------------------------------------
  SrcAddr.sin_family = (SA_FAMILY_T) DstFamily;
  SrcAddr.sin_port   = htons((uint16_t) pDstAddr->Port);
  memcpy(&SrcAddr.sin_addr+0,pDstAddr->InetAdr+0,DstAdrLen);
  if(connect(ConnSock,(struct sockaddr*) ((void *) &SrcAddr),AddrLen) != 0)
  {
    CloseSocket(ConnSock);
    return(3);
  }
  pNewSock[0] = ConnSock;
  return(0);

}

/**
* Sends on connected socket (SendSock).
*
* NOTE: C    - amount sent result depends on Blocking/Non Blocking mode.
*     JAVA - all data are normally sent.
*
*  @param TheSocket Socket to be used
*  @param pTxBuf Send buffer
*  @param TxOff Start of data
*  @param TxLen Amount to send
*  @return Bytes sent, <0 on error
*/
extern "C"  int  SendSock(SOCKET TheSocket, char* pTxBuf, int TxOff,
				int TxLen)
{
  int SentCount;
  SentCount = send(TheSocket,pTxBuf+TxOff, TxLen,0);
  if(SentCount == SOCKET_ERROR)
  {
#if !(defined _WIN32)  // not windows -> UNIX
    if((errno == EAGAIN) || (errno == EWOULDBLOCK))
      return(0);
#else
    if(WSAGetLastError() == WSAEWOULDBLOCK)
      return(0);
#endif // WIN32/64
    return(-1);
  }
  return(SentCount);
}

#if !(defined _WIN32)  // not windows -> UNIX
/**
* Allocate fd_set array of needed size for select(..) (AllocFdSet).
* Only needed for Unix
*
*  @param MaxHandle File/Sockethandle
*  @return fd_set * <br>            / NULL
*/
static  fd_set * AllocFdSet(int MaxHandle)
{
#if !defined NFDBITS
#define	NFDBITS	(8 * sizeof(unsigned long))
typedef	unsigned long int fd_mask;
#endif

#ifdef HL_ANDROID
typedef	unsigned long int fd_mask;
#endif

  fd_set * pFdSet = NULL;
  if(MaxHandle < 0)
    return(NULL);
  //--------------------------------------------------------------
  // allocate as many bits (in NFDBITS increments) that are needed
  // NOTE: the NULL handle counts also as a bit, even if not used !
  //--------------------------------------------------------------
  pFdSet = (fd_set *) malloc(((MaxHandle+1 + (NFDBITS-1)) / NFDBITS) *
                             sizeof(fd_mask));
  return(pFdSet);
}
#endif // UNIX

//#if !defined __HSSH__		// not needed for SSH
/**
* Sends on connected socket until all data is sent or a timeout occurs (SendWaitSock).
*
*  @param TheSocket Socket to be used
*  @param pTxBuf Send buffer
*  @param TxOff Start of data
*  @param TxLen Amount to send
*  @param Timeout == 0 wait forever
*  @return Bytes sent, <0 on error
*/
extern "C"  int  SendWaitSock(SOCKET TheSocket, char* pTxBuf,int TxOff,
				int TxLen, int Timeout)
{
  int SentCount;
  int ActSentCount = 0;
  int Result;
#if defined _WIN32
  struct fd_set writefds;
#else
  fd_set * writefds = NULL;
//  struct fd_set * writefds = NULL;
#endif
  struct timeval timeout;

  for(;;)
  {
    //-------------------------------------------------------------
    // Try to send the data, check result
    //-------------------------------------------------------------
    if((SentCount = send(TheSocket,pTxBuf+TxOff, TxLen,0)) == SOCKET_ERROR)
    {
#if !(defined _WIN32)  // not windows -> UNIX
      if((errno != EAGAIN) && (errno != EWOULDBLOCK))
      {
        free(writefds);
        return(-1);
      }
#else
      Result = WSAGetLastError();
      if((Result != WSAEWOULDBLOCK) && (Result != WSAENOBUFS))
        return(-1);
#endif
    }
    else					// partial / full sent
    {
      TxLen -= SentCount;
      TxOff += SentCount;      
      ActSentCount += SentCount;
      if(TxLen <= 0)				// all sent, o.k.
      {
#if !(defined _WIN32)  // not windows -> UNIX
        free(writefds);
#endif 
        return(ActSentCount);
      }
      if(SentCount != 0)			// did send, retry immediate ?
        continue;
    }
    //-------------------------------------------------------------
    // Not all data sent, setup select for Writeability wait
    // NOTE: Don't wait forever, limit to 120 seconds maximum !!
    //-------------------------------------------------------------
    if((Timeout <= 0) || (Timeout > 120))
      Timeout = 120;
    timeout.tv_sec = Timeout;			// setup Timeout
    timeout.tv_usec = 0;
#if !(defined _WIN32)  // not windows -> UNIX
    if(writefds == NULL)
    {
      if((writefds = AllocFdSet(TheSocket)) == NULL)
        return(-3);
    }
    FD_ZERO(writefds);
    FD_SET(TheSocket,writefds);
    Result = select(TheSocket+1,NULL,writefds,NULL,&timeout);
#else // !defined UNIX
    FD_ZERO(&writefds);
#if defined _WIN32
#pragma warning(disable:4127)
#endif
    FD_SET(TheSocket,&writefds);
#if defined _WIN32
#pragma warning(default:4127)
#endif
    Result = select(0,NULL,&writefds,NULL,&timeout);	// WIN32/64 only !!!
#endif

    if(Result == 0)				// had a timeout
    {
#if !(defined _WIN32)  // not windows -> UNIX
      free(writefds);
#endif
      return(0);				// report timeout
    }
    continue;
  }
}
//#endif // !defined __HSSH__

/**
* Receives from connected socket (ReceiveSock).
*
*  @param TheSocket Socket to be used
*  @param pRxBuf Receive buffer
*  @param RxOff Start offset for writing
*  @param RxBufLen Available buffer length
*  @return Special cases possible:
* <br>            > 0 - amount of data received
* <br>            == 0 - closed by remote
* <br>            == -1 - error occured
* <br>            == -2 - timed out (JAVA, C in NonBlocking Mode)
*/
extern "C"  int  ReceiveSock(SOCKET TheSocket, char* pRxBuf, int RxOff,
				int RxBufLen)
{
  int RxCount = 0;

  if(RxBufLen <= 0)
    return(-1);

  RxCount = recv(TheSocket,pRxBuf+RxOff, RxBufLen,0);
  if(RxCount == SOCKET_ERROR)
  {
#if !(defined _WIN32)  // not windows -> UNIX
    if((errno == EWOULDBLOCK) || (errno == EAGAIN))
#else
    if(WSAGetLastError() == WSAEWOULDBLOCK)
#endif
      return(-2);
    return(-1);
  }
  return(RxCount);
}
/**
* Receives from connected socket, until data are received or a timeout happens (ReceiveWaitSock).
*
*  @param TheSocket Socket to be used
*  @param pRxBuf Receive buffer
*  @param RxOff Start offset for writing
*  @param RxBufLen Buffer length
*  @param Timeout == 0 wait forever 
*  @return Special cases possible:
* <br>            > 0 - amount of data received
* <br>            == 0 - closed by remote
* <br>            == -1 - error occured
* <br>            == -2 - timed out (JAVA, C in NonBlocking Mode)
*/
extern "C"  int  ReceiveWaitSock(SOCKET TheSocket, char* pRxBuf,
		int RxOff, int RxBufLen, int Timeout)
{
#if defined _WIN32
  struct fd_set readfds;
#else
  fd_set * readfds = NULL;
#endif // UNIX
  struct timeval timeout;
  int RxCount = 0;
  int Result;

  if(RxBufLen <= 0)
    return(-1);

  for(;;)
  {
    //----------------------------------------------------
    // Receive data, check if any presented
    //----------------------------------------------------
    RxCount = recv(TheSocket,pRxBuf+RxOff, RxBufLen,0);
    if(RxCount != SOCKET_ERROR)			// data or remote closed case
      return(RxCount);
#if !(defined _WIN32)  // not windows -> UNIX
    if((errno != EWOULDBLOCK) && (errno != EAGAIN))
#else
    if(WSAGetLastError() != WSAEWOULDBLOCK)
#endif
      return(-1);
    //----------------------------------------------------
    // No data yet, setup Select for readability
    // NOTE: Don't wait forever, limit to 120 seconds maximum !!
    //-------------------------------------------------------------
    if((Timeout <= 0) || (Timeout > 120))
      Timeout = 120;
    timeout.tv_sec = Timeout;			// setup Timeout
    timeout.tv_usec = 0;
#if !(defined _WIN32)  // not windows -> UNIX
    if(readfds == NULL)
    {
      if((readfds = AllocFdSet(TheSocket)) == NULL)
        return(-3);
    }
    FD_ZERO(readfds);
    FD_SET(TheSocket,readfds);
    Result = select(TheSocket+1,readfds,NULL,NULL,&timeout);
#else // !defined UNIX
    FD_ZERO(&readfds);
#if defined _WIN32
#pragma warning(disable:4127)
#endif
    FD_SET(TheSocket,&readfds);
#if defined _WIN32
#pragma warning(default:4127)
#endif
    Result = select(0,&readfds,NULL,NULL,&timeout);	// WIN32/64 only !!!
#endif

    if(Result == 0)				// had a timeout
    {
#if !(defined _WIN32)  // not windows -> UNIX
      free(readfds);
#endif
      return(-2);				// report timeout
    }
    continue;
  }

}


#endif //HL_CERT_CLIB
// end of file ../hclib/hcsock.cpp


#ifdef HL_CERT_CLIB
/** @addtogroup hstring
* @{
* @file
* This file contains string and buffer helper routines, which are often needed,
* but not part of the C standard library.
* @}
*/
//************************************************************
//
//
// String Helper routines, often needed but not in standard library
//
//
//************************************************************
#include <string.h>
#if (defined _WIN32) & (_MSC_VER < 1700)
#ifndef _STDINT
#define _STDINT
// MSVC lower than 17.00 does not have stdint.h, assure, all needed types are defined

typedef unsigned __int16 uint16_t;

typedef unsigned __int32 uint32_t;

typedef unsigned __int64 uint64_t;

#endif // !_STDINT
#else
#include <stdint.h>
#endif
#include <stddef.h>
#ifdef _WIN32
#define WIN32_LEAN_AND_MEAN
#include <Windows.h>
#undef WIN32_LEAN_AND_MEAN
#else// Define system-specific HL_* defines here
#ifndef HL_UNIX
#define HL_UNIX

#if (defined __gnu_linux__) || (defined __linux__)
#define HL_LINUX
#endif

#if (defined __APPLE__) && (defined __MACH__)
#define HL_LINUX
#define HL_MACOS
#endif

#ifdef _AIX
#define HL_AIX
#define HL_BIG_ENDIAN
#endif

#ifdef __FreeBSD__
#define HL_FREEBSD
#endif

#if (defined _hpux) || (defined hpux) || (defined __hpux)
#define HL_HPUX
#define HL_BIG_ENDIAN
#endif

#if (defined sun) || (defined __sun)
#define HL_SOLARIS
#endif

#if (defined __arm__) || (defined __aarch64__)
#define HL_LINUX_ARM
#endif

#ifdef __ANDROID__
#define HL_ANDROID
#endif

#endif
#include <hob-unix01.h>
#endif
#ifdef __APPLE__
/* We get target conditionals to keep apart Mac OS, iOS and iOS simulator.
   The conditionals are TARGET_IPHONE_SIMULATOR, TARGET_OS_IPHONE and TARGET_OS_MAC.
   TARGET_IPHONE_SIMULATOR has the highest priority, TARGET_OS_MAC the lowest.
   Always test, if the conditional is 1, as they will be defined as 0, if we 
   are not compiling for the target.
   */
#include <TargetConditionals.h>
#endif

#ifdef HL_ANDROID
#include <netdb.h>
#include <unistd.h>
#include <linux/in.h>
#ifndef SOCKLEN_T
#define SOCKLEN_T      int
#endif
#ifndef SA_FAMILY_T
#define SA_FAMILY_T  short
#endif
#include <sys/endian.h>
#include <asm/ioctls.h>
#include <errno.h>
#endif

#include "hob-encry-1.h"
#include "hob-cert-ext.h"
#ifdef _WIN32
#include <winsock.h>
#endif
#include "hob-cert-err.h"
#include <string.h>
#include "hob-cert-intern.h"

#define	HTAB_CHAR	0x09
#define	CR_CHAR		0x0D
#define	LF_CHAR		0x0A
#define	SPC_CHAR	0x20

/** @addtogroup hstring
* @{
*/
/**
* Reverses the buffer content in place (Memrev).
*
*  @param pBuf Data buffer
*  @param Off Start offset of data
*  @param Len Length of data
*/
extern "C"  void  Memrev(char* pBuf, int Off, int Len)
{
  char c;
  int LowerIndex, UpperIndex;

  if((pBuf == NULL) || (Len <= 1))
    return;

  LowerIndex = Off;			// at start
  UpperIndex = Off + Len - 1;		// at End
  Len = Len/2;				// even count
  do
  {
    c = pBuf[LowerIndex];
    pBuf[LowerIndex++] = pBuf[UpperIndex];
    pBuf[UpperIndex--] = c;
    Len--;
  }while(Len > 0);
}
/**
* Converts an ASCII character to lower case (ToLowerChar).
*
*  @param c Character to convert
*  @return Converted character
*/
extern "C"  char  ToLowerChar(char c)
{
  int c1 = (int) c & 0xFF;

  if((c1 >= (int) 'A') && (c1 <= (int) 'Z'))
    c1 += 0x20;
  return((char) c1);
}
/**
* Converts two ASCII HEX characters to a binary byte (HexAsciiCharsToBin).
*
* NOTE: The characters are checked for valid HEX representations.
*
*  @param c1 First (MSB) character
*  @param c2 Second (LSB) character
*
*  @return 0-255 (unsigned value of byte) on success, else error
*/
extern "C"  int  HexAsciiCharsToBin(char c1, char c2)
{
  int i1 = (int) c1 & 0xFF;
  int i2 = (int) c2 & 0xFF;

  if((IsXdigit(i1) == 0) ||
     (IsXdigit(i2) == 0))
    return(-1);

  i1 = To_Lower(i1) - 0x30;
  if(i1 > 9)					// was lower alpha
    i1 -= 0x27;					// 'a' (0x61) -> 0x0A
  i2 = To_Lower(i2) - 0x30;
  if(i2 > 9)					// was lower alpha
    i2 -= 0x27;					// 'a' (0x61) -> 0x0A
  return((i1 << 4) | i2);
}

/**
* Gets the length of a sized, possibly ASCIIz string (StrnSlen).
*
*  @param pStr String data buffer
*  @param Off Start offset of data
*  @param Len Length of data
*  @return Length of the ASCIIz string or Len, if no NUL was found
*/
extern "C"  int  StrnSlen(char* pStr, int Off, int Len)
{
  int StartOff = Off;
  if(pStr == NULL)
    return(0);
  //---------------------------------------------
  // Scan for End of String, if length > 0
  //---------------------------------------------
  while(Len > 0)
  {
    if(pStr[Off] == (unsigned char) 0)
      break;
    Off++;
    Len--;
  }
  return(Off-StartOff);
}

/**
* Duplicates a sized, possibly ASCIIz string, always terminate with NUL (Strndup).
*
*  @param pStr String data buffer
*  @param Off Start offset of data
*  @param Len Length of data
*  @return New buffer, containing the copied string / NULL
*/
extern "C"  char*  Strndup(HMEM_CTX_DEF
				   char* pStr, int Off, int Len)
{
  char* pBuf;

  if(pStr == NULL)
    return(NULL);
  //-------------------------------------------
  // Get true length of String, allocate buffer
  //-------------------------------------------
  Len = StrnSlen(pStr, Off, Len);
  if((pBuf = BIT8_ARRAY_ALLOC(HMEM_CTX_REF,Len+1)) == NULL)
    return(NULL);
  pBuf[0] = (unsigned char) 0;
  if(Len != 0)
  {
    memcpy(pBuf+0,pStr+Off,Len);
    pBuf[Len] = (unsigned char) 0;
  }
  return(pBuf);
}
/**
* Duplicates a JAVA/C-ASCIIz string, to an ASCIIz string,
* always terminate with NUL (JStrdup).
*
* NOTE: If a NULL pointer is supplied, a NULL pointer is returned
*
*  @param pStr String to duplicate
*  @return New buffer, containing the copied string / NULL
*/
extern "C"  char*  JStrdup(HMEM_CTX_DEF
				   char * pStr)
{
  if(pStr == NULL)
    return(NULL);
  return(Strdup(HMEM_CTX_REF1 pStr,0));	// generate a Copy
}

/**
* Compares two NUL delimited strings, case insensitive
* (relative to ASCII codeset) (Stricmp).
*
* NOTE: Missing strings are also handled.
*
*  @param pStr1 String 1 data buffer
*  @param Str1Off Start offset of string 1 data 
*  @param pStr2 String 2 Data buffer
*  @param Str2Off Start offset of string 2 data
*  @return == 0 - String1 same as String2
* <br>            < 0 - String1 < String 2
* <br>            > 0 - String1 > String 2
*/
extern "C"  int  Stricmp(char* pStr1, int Str1Off,
			       char* pStr2, int Str2Off)
{
  char c1 = 0;
  char c2 = 0;
  int Str1Len,Str2Len;
  //----------------------------------------------------------
  // Check very special cases first
  //----------------------------------------------------------
  if((pStr1 == NULL) || (pStr2 == NULL))
  {
    if((pStr1 == NULL) && (pStr2 == NULL))	// both absent, say same
      return(0);
    if(pStr1 == NULL)				// 1st absent, say less
      return(-1);
    return(1);
  }
  Str1Len = Strlen(pStr1,0);
  Str2Len = Strlen(pStr2,0);
  //----------------------------------------------------------
  // Check further special cases first
  //----------------------------------------------------------
  if((Str1Len <= 0) || (Str2Len <= 0))
  {
    if((Str1Len <= 0) && (Str2Len <= 0))	// both empty
      return(0);
    if(Str2Len <= 0)				// 2nd is empty, 1st not
    {
      if(pStr1[Str1Off] == 0)			// also empty
        return(0);
      return(1);				// 2nd missing
    }
    else					// 1st is empty
    {
      if(pStr2[Str2Off] == 0)			// also empty
        return(0);
      return(-1);				// 1st missing
    }
  }
  //-----------------------------------------------------------
  // Compare the Strings, case insensitive
  //-----------------------------------------------------------
  while((Str1Len > 0) && (Str2Len > 0))
  {
    c1 = ToLowerChar(pStr1[Str1Off++]);
    c2 = ToLowerChar(pStr2[Str2Off++]);
    if((c1 != c2) || (c1 == 0) || (c2 == 0))	// different / any ended
      break;
    Str1Len--;
    Str2Len--;
  }
  if(c1 == c2)					// were same
  {
    //---------------------------------------------
    // check if both had same length
    //---------------------------------------------
    if((c1 == 0) ||				// both ended
       ((Str1Len == 0) && (Str2Len == 0)))	// both same and same size
      return(0);

    if(Str1Len > 0)				// 1st is larger
      return(1);
    return(-1);					// 2nd is larger
  }
  //-----------------------------------------------
  // not same, get ending condition
  //-----------------------------------------------
  if(((int) c1 & 0xFF) < ((int) c2 & 0xFF))
    return(-1);
  return(1);
}

/**
* Compares two possibly NUL delimited strings, case insensitive
* (relative to ASCII codeset) (Strnicmp).
*
* NOTE: Missing strings are also handled !
*
*  @param pStr1 String 1 data buffer
*  @param Str1Off Start offset of string 1 data 
*  @param Str1Len Max.Length of string 1 data 
*  @param pStr2 String 2 data buffer
*  @param Str2Off Start offset of string 2 data
*  @param Str2Len Max.Length of string 2 data 
*  @return == 0 - String1 same as String2
* <br>            < 0 - String1 < String 2
* <br>            > 0 - String1 > String 2
*/
extern "C"  int  Strnicmp(char* pStr1, int Str1Off, int Str1Len,
				char* pStr2, int Str2Off, int Str2Len)
{
  char c1 = 0;
  char c2 = 0;
  //----------------------------------------------------------
  // Check very special cases first
  //----------------------------------------------------------
  if((pStr1 == NULL) || (pStr2 == NULL))
  {
    if((pStr1 == NULL) && (pStr2 == NULL))	// both absent, say same
      return(0);
    if(pStr1 == NULL)				// 1st absent, say less
      return(-1);
    return(1);
  }
  //----------------------------------------------------------
  // Check further special cases first
  //----------------------------------------------------------
  if((Str1Len <= 0) || (Str2Len <= 0))
  {
    if((Str1Len <= 0) && (Str2Len <= 0))	// both empty
      return(0);
    if(Str2Len <= 0)				// 2nd is empty, 1st not
    {
      if(pStr1[Str1Off] == 0)			// also empty
        return(0);
      return(1);				// 2nd missing
    }
    else					// 1st is empty
    {
      if(pStr2[Str2Off] == 0)			// also empty
        return(0);
      return(-1);				// 1st missing
    }
  }
  //-----------------------------------------------------------
  // Compare the Strings, case insensitive
  //-----------------------------------------------------------
  while((Str1Len > 0) && (Str2Len > 0))
  {
    c1 = ToLowerChar(pStr1[Str1Off++]);
    c2 = ToLowerChar(pStr2[Str2Off++]);
    if((c1 != c2) || (c1 == 0) || (c2 == 0))	// different / any ended
      break;
    Str1Len--;
    Str2Len--;
  }
  if(c1 == c2)					// were same
  {
    //---------------------------------------------
    // check if both had same length
    //---------------------------------------------
    if((c1 == 0) ||				// both ended
       ((Str1Len == 0) && (Str2Len == 0)))	// both same and same size
      return(0);

    if(Str1Len > 0)				// 1st is larger
      return(1);
    return(-1);					// 2nd is larger
  }
  //-----------------------------------------------
  // not same, get ending condition
  //-----------------------------------------------
  if(((int) c1 & 0xFF) < ((int) c2 & 0xFF))
    return(-1);
  return(1);
}

/**
* Compares a sized, possibly ASCIIz string to a given string,
* either an ASCIIz or a JAVA String, (relative to ASCII codeset)
* either case sensitive or insensitive (JStrncmp).
*
* NOTE: Missing strings are also handled !
*
*  @param pStr1 String 1 data buffer
*  @param Str1Off Start offset of string 1 data 
*  @param Str1Len Max.Length of string 1 data 
*  @param pStr2 String 2
*  @param CaseIgnoreFlag == 0 obey case, else ignore
*  @return == 0 - String1 same as String2
* <br>            < 0 - String1 < String 2
* <br>            > 0 - String1 > String 2
*/
extern "C"  int  JStrncmp(char* pStr1, int Str1Off, int Str1Len,
				char * pStr2, int CaseIgnoreFlag)
{
  char c1 = 0;
  char c2 = 0;
  int Str2Len, Str2Off;
  //----------------------------------------------------------
  // Check very special cases first
  //----------------------------------------------------------
  if((pStr1 == NULL) || (pStr2 == NULL))
  {
    if((pStr1 == NULL) && (pStr2 == NULL))	// both absent, say same
      return(0);
    if(pStr1 == NULL)				// 1st absent, say less
      return(-1);
    return(1);
  }
  //----------------------------------------------------------
  // Get length of 2nd String
  //----------------------------------------------------------
  Str2Len = Strlen(pStr2,0);
  //----------------------------------------------------------
  // Check further special cases first
  //----------------------------------------------------------
  if((Str1Len <= 0) || (Str2Len <= 0))
  {
    if((Str1Len <= 0) && (Str2Len <= 0))	// both empty
      return(0);
    if(Str2Len <= 0)				// 2nd is empty, 1st not
    {
      if(pStr1[Str1Off] == (unsigned char) 0)		// also empty
        return(0);
      return(1);				// 2nd missing
    }
    else					// 1st is empty, 2nd not
      return(-1);				// 1st missing
  }
  //-----------------------------------------------------------
  // Compare the Strings, case sensitive
  //-----------------------------------------------------------
  Str2Off = 0;
  while((Str1Len > 0) && (Str2Len > 0))
  {
    c1 = pStr1[Str1Off++];      
    c2 = pStr2[Str2Off++];
    if(CaseIgnoreFlag != 0)
    {
      c1 = ToLowerChar(c1);
      c2 = ToLowerChar(c2);
    }
    if(c1 != c2)				// not same, stop
      break;
    Str1Len--;
    Str2Len--;
  }
  if(c1 == c2)					// were same
  {
    //---------------------------------------------
    // check if both had same length
    //---------------------------------------------
    if((Str1Len == 0) && (Str2Len == 0))	// both ended
      return(0);
    if(Str1Len == 0)				// first ended
      return(-1);				// 2nd is larger
    return(1);					// secon ended, 1st is larger
  }
  //-----------------------------------------------
  // not same, get ending condition
  //-----------------------------------------------
  if(((int) c1 & 0xFF) < ((int) c2 & 0xFF))
    return(-1);
  return(1);
}

/**
* Scans a buffer till next LF/CRLF, returns length of line up to
* LF/CRLF, exclusive, and, if requested, total line length
* inclusive LF/CRLF (GetAsciizLineLen).
*
* NOTE: A Null character is also considered as End of Line !
*
*  @param pSrcBuf Data buffer
*  @param SrcOff Start offset of data
*  @param SrcLen Length of data
*  @param pSkipLen Pointer for line length including LF/CRLF. Optional
*  @return Length of the line, <0 on error
*/
extern "C"  int  GetAsciizLineLen(char* pSrcBuf, int SrcOff,
		int SrcLen, int* pSkipLen)
{
  char c = 0;

  int StartOff = SrcOff;
  int SkipCnt;

  if(pSkipLen != NULL)
    pSkipLen[0] = 0;

  if((pSrcBuf == NULL) && (SrcLen > 0))
    return(-1);
  if(SrcLen <= 0)
    return(0);
  //---------------------------------------------------------
  // Scan for a LF character till NUL or end of buffer
  //---------------------------------------------------------
  while(SrcLen > 0)
  {
    c = pSrcBuf[SrcOff];			// get character
    if((c == (unsigned char) 0) || (c == (unsigned char) LF_CHAR)) // End of String or LF
      break;
    SrcOff++;
    SrcLen--;
  }
  //-----------------------------------------------------------
  // postprocess line length / skip length
  //-----------------------------------------------------------
  SrcLen  = SrcOff-StartOff;		// length till End
  SkipCnt = SrcLen;
  if(c == (unsigned char) LF_CHAR)		// last character was LF, skip 1
    SkipCnt++;

  if((SrcLen != 0) && (c == (unsigned char) LF_CHAR) &&	// Data in String
     (pSrcBuf[SrcOff-1] == (unsigned char) CR_CHAR))	// was CR/LF
  {
    SrcLen--;
//    SkipCnt++; // we were at LF !!
  }

  if(pSkipLen != NULL)
    pSkipLen[0] = SkipCnt;
  return(SrcLen);
}
/**
* Counts whitespaces till next non whitespace character or End
* of String/NUL; characters always considered as whitespace are
* Space and HTab (GetWspacesAsciizStr). 
*
* The Mode flag parameter controls additional
* Whitespace characters to consider: <br>
* Bit 0 - 1: Also consider CR and LF as whitespaces. <br>
* Bit 1 - 1: Also consider '=' character as whitespace. <br>
* Bit 2 - 1: Also consider parameter supplied character.
*
*  @param pStr String data buffer
*  @param StrOff Start offset of string data
*  @param StrLen Maximum length of string data
*  @param ModeFlags Operation mode bits, see above
*  @param SpcChar Character for additional check
*  @return Number of couted whitespaces
*/
extern "C"  int  GetWspacesAsciizStr(char* pStr, int StrOff,
			int StrLen, int ModeFlags, int SpcChar)
{
  unsigned char c;
  int StartOff = StrOff;

  if((pStr == NULL) || (StrLen <= 0))
    return(0);
  //----------------------------------------------------------
  // Skip the whitespaces
  //----------------------------------------------------------
  while(StrLen > 0)
  {
    c = pStr[StrOff];				// get character

    if((c == (unsigned char) 0) ||			// End of String
       !((c == (unsigned char) SPC_CHAR) || (c == (unsigned char) HTAB_CHAR) || // Space or HTAB
         (((ModeFlags & 0x01) != 0) &&			// also obey CR, LF
          ((c == (unsigned char) CR_CHAR) || (c == (unsigned char) LF_CHAR))) ||
         (((ModeFlags & 0x02) != 0) && (c == (unsigned char) '=')) ||
         (((ModeFlags & 0x04) != 0) && (c == (unsigned char) SpcChar))))
      break;
    StrOff++;
    StrLen--;
  }
  return(StrOff-StartOff);
}
/**
* Counts whitespaces beginning at End of String till next non
* whitespace character or start of string reached (GetWspacesRevAsciizStr).
*
*  @param pStr String data buffer
*  @param StrOff Start offset of string data
*  @param StrLen Maximum length of string data
*  @return Number of couted whitespaces
*/
extern "C"  int  GetWspacesRevAsciizStr(char* pStr, int StrOff,
			int StrLen)
{
  unsigned char c;
  int StartOff;

  if((pStr == NULL) || (StrLen <= 0))
    return(0);

  StrOff += StrLen;			// past end of String
  StartOff = StrOff;			// save
  //----------------------------------------------------------
  // Skip the whitespaces
  //----------------------------------------------------------
  while(StrLen > 0)
  {
    StrOff--;					// to character to check
    c = pStr[StrOff];				// get character
    if((c != (unsigned char) SPC_CHAR) && (c != (unsigned char) HTAB_CHAR)) // not space/HTAB
    {
      StrOff++;					// correct offset
      break;
    }
    StrLen--;
  }
  return(StartOff-StrOff);
}
/**
* Counts whitespaces till next non whitespace character or End
* of String/NUL; characters always considered as whitespace are
* Space and HTab (GetNonWspacesAsciizStr).
*
* The Mode flag parameter controls additional
* Whitespace characters to consider: <br>
* Bit 0 - 1: Also consider CR and LF as whitespaces. <br>
* Bit 1 - 1: Also consider '=' character as whitespace. <br>
* Bit 2 - 1: Also consider parameter supplied character.
*
*  @param pStr String data buffer
*  @param StrOff Start offset of string data
*  @param StrLen Maximum length of string data
*  @param ModeFlags Operation mode bits, see above
*  @param SpcChar Character for additional check
*  @return Number of couted non whitespaces
*/
extern "C"  int  GetNonWspacesAsciizStr(char* pStr, int StrOff,
			int StrLen, int ModeFlags, int SpcChar)
{
  unsigned char c;
  int StartOff = StrOff;

  if((pStr == NULL) || (StrLen <= 0))
    return(0);
  //----------------------------------------------------------
  // Count all *non* Whitespace characters
  //----------------------------------------------------------
  while(StrLen > 0)
  {
    c = pStr[StrOff];				// get character

    if((c == (unsigned char) 0) ||			// End of String
       ((c == (unsigned char) SPC_CHAR) || (c == (unsigned char) HTAB_CHAR) || // Space or HTAB
         (((ModeFlags & 0x01) != 0) &&			// also obey CR, LF
          ((c == (unsigned char) CR_CHAR) || (c == (unsigned char) LF_CHAR))) ||
         (((ModeFlags & 0x02) != 0) && (c == (unsigned char) '=')) ||
         (((ModeFlags & 0x04) != 0) && (c == (unsigned char) SpcChar))))
      break;
    StrOff++;
    StrLen--;
  }
  return(StrOff-StartOff);
}
/**
* Converts a binary string to ASCII-Hex string, zero terminated (BinToAsciizHexStr).
*
* NOTE: Returned size is exclusive trailing NUL.
*
*  @param pSrcBuf Input data buffer
*  @param SrcOff Start of input data
*  @param SrcLen Data length
*  @param pDstBuf Destination buffer
*  @param DstOff Start offset for writing
*  @param DstBufLen Size of destination buffer
*  @return Length of written string, <0 on error
*/
extern "C"  int  BinToAsciizHexStr(char* pSrcBuf, int SrcOff,
	int SrcLen, char* pDstBuf, int DstOff, int DstBufLen)
{
  int c;
  int StartOff = DstOff;

  if((pSrcBuf == NULL) || (pDstBuf == NULL))
    return(-1);

  if((SrcLen < 0) || (DstBufLen < (2*SrcLen + 1)))
    return(-2);

  while(SrcLen > 0)
  {
    c = (((int) pSrcBuf[SrcOff] >> 4) & 0x0F) + 0x30;
    if(c > 0x39)
      c += 7;
    pDstBuf[DstOff++] = (char) c;
    c = ((int) pSrcBuf[SrcOff] & 0x0F) + 0x30;
    if(c > 0x39)
      c += 7;
    pDstBuf[DstOff++] = (char) c;
    SrcOff++;
    SrcLen--;
  }
  pDstBuf[DstOff] = 0;
  return(DstOff - StartOff);
}
/**
* Converts a possibly zero terminated HEX ASCIIz string to a
* binary string (HexAsciizToBinStr).
* Strips leading whitespaces.
* Converts pairs of input characters until hex representation or destination
* buffer end.
*
*  @param pSrcBuf Input data buffer
*  @param SrcOff Start of input data
*  @param SrcLen Data length
*  @param pDstBuf Destination buffer
*  @param DstOff Start offset for writing
*  @param DstBufLen Size of destination buffer
*  @param pProcessedLen Pointer to return processed source count. Optional
*  @return Length of written string, <0 on error
*/
extern "C"  int  HexAsciizToBinStr(char* pSrcBuf, int SrcOff,
	int SrcLen, char* pDstBuf, int DstOff, int DstBufLen,
	int* pProcessedLen)
{
  int i;
  int DstStartOff = DstOff;
  int SrcStartOff = SrcOff;

  if((pSrcBuf == NULL) || (pDstBuf == NULL))
    return(-1);
  if(pProcessedLen != NULL)
    pProcessedLen[0] = 0;

  if((SrcLen <= 0) || (DstBufLen <= 0))		// nothing to do...
    return(0);
  //--------------------------------------------------------
  // Strip leading whitespaces
  //--------------------------------------------------------
  i = GetWspacesAsciizStr(pSrcBuf, SrcOff, SrcLen, 0, 0);
  SrcOff += i;
  SrcLen -= i;
  while((SrcLen >= 2) && (DstBufLen > 0))
  {
    if((i = HexAsciiCharsToBin(pSrcBuf[SrcOff],pSrcBuf[SrcOff+1])) < 0)
      break;
    pDstBuf[DstOff++] = (char) i;
    SrcOff += 2;
    SrcLen -= 2;    
    DstBufLen--;
  }
  if(pProcessedLen != NULL)
    pProcessedLen[0] = SrcOff-SrcStartOff;
  return(DstOff-DstStartOff);
}

/**
* Scans forward an ASCIIz string for a given character to match (Strnchr).
*
*  @param pStr String data buffer
*  @param StrOff Start offset of string data
*  @param StrLen Length of string data
*  @param FindChar Character to look for
*  @return Index of found character, 0<, if not found/error
*/
extern "C"  int  Strnchr(char* pStr, int StrOff, int StrLen,
			       char FindChar)
{
  char c;
  int StartOff = StrOff;

  if(pStr == NULL) 				// no buffer
      return(-1);
  //----------------------------------------------------------
  // Scan the String forward till either found or NUL
  //----------------------------------------------------------
  while(StrLen > 0)
  {
    c = pStr[StrOff];
    if(c == FindChar)
      return(StrOff - StartOff);		// found character
    if(c == (unsigned char) 0)
      return(-1);				// end of String, not found
    StrOff++;
    StrLen--;
  }
  return(-1);
}
/**
* Scans forward an ASCIIz string for a given character to match,
* case insensitive (Strnichr).
*
*  @param pStr String data buffer
*  @param StrOff Start offset of string data
*  @param StrLen Length of string data
*  @param FindChar Character to look for
*  @return Index of found character, 0<, if not found/error
*/
extern "C"  int  Strnichr(char* pStr, int StrOff, int StrLen,
			        char FindChar)
{
  char c;
  int StartOff = StrOff;

  if(pStr == NULL) 				// no buffer
      return(-1);
  //----------------------------------------------------------
  // Scan the String forward till either found or NUL
  //----------------------------------------------------------
  FindChar = ToLowerChar(FindChar);
  while(StrLen > 0)
  {
    c = ToLowerChar(pStr[StrOff]);
    if(c == FindChar)
      return(StrOff - StartOff);		// found character
    if(c == (unsigned char) 0)
      return(-1);				// end of String, not found
    StrOff++;
    StrLen--;
  }
  return(-1);
}

/**
* Scans backward an ASCIIz string for a given character to match (Strnrchr).
*
* NOTE: Scanning is started from end of string; any NULs are ignored
*
*  @param pStr String data buffer
*  @param StrOff Start offset of string data
*  @param StrLen Length of string data
*  @param FindChar Character to look for
*  @return Index of found character, 0<, if not found/error
*/
extern "C"  int  Strnrchr(char* pStr, int StrOff, int StrLen,
			        char FindChar)
{
  int StartOff = StrOff;

  if(pStr == NULL)				// no buffer/no data
    return(-1);
  //----------------------------------------------------------
  // Scan the String backward till either found or start
  //----------------------------------------------------------
  StrOff += StrLen;				// to End of String + 1
  while(StrLen > 0)
  {
    StrOff--;					// one back
    if(pStr[StrOff] == FindChar)		// found it
      return(StrOff-StartOff);
    StrLen--;
  }
  return(-1);
}

/**
* Counts the number of characters within an ASCIIz string until the first 
* character, that is NOT in a given character set (Strnspn).
* The character set to be counted is defined by an ASCIIz string.
* The count excludes the first mismatch.
*
*  @param pStr String data buffer
*  @param StrOff Start offset of string data
*  @param StrLen Length of string data
*  @param pCharset Character set buffer
*  @param CharsetOff Start of character set data
*  @param CharsetLen Length of character set
*  @return Number of characters
*/
extern "C"  int  Strnspn(char* pStr, int StrOff, int StrLen,
			       char* pCharset,int CharsetOff, int CharsetLen)
{
  char c;
  int StartOff = StrOff;

  if((pStr == NULL) || (pCharset == NULL) ||
     (StrLen <= 0) || (CharsetLen <= 0))
    return(0);
  //------------------------------------------------------------------
  // Scan the String forward till either NUL or *not* in Character set
  //------------------------------------------------------------------
  while(StrLen > 0)
  {
    c = pStr[StrOff];			// get character
    if((c == (unsigned char) 0) ||		// end of string anyway
       (Strnchr(pCharset,CharsetOff,CharsetLen, c) < 0))
      break;
    StrOff++;
    StrLen--;
  }
  return(StrOff-StartOff);
}

/**
* Counts the number of characters within an ASCIIz string until the first 
* character, that is in a given character set (Strnpbrk).
* The character set to be counted is defined by an ASCIIz string.
* The count excludes the first match.
*
*  @param pStr String data buffer
*  @param StrOff Start offset of string data
*  @param StrLen Length of string data
*  @param pCharset Character set buffer
*  @param CharsetOff Start of character set data
*  @param CharsetLen Length of character set
*  @return Number of characters
*/
extern "C"  int  Strnpbrk(char* pStr, int StrOff, int StrLen,
			        char* pCharset,int CharsetOff,int CharsetLen)
{
  char c;
  int StartOff = StrOff;

  if((pStr == NULL) || (pCharset == NULL) ||
     (StrLen <= 0) || (CharsetLen <= 0))
    return(0);
  //------------------------------------------------------------------
  // Scan the String forward till either NUL or *is* in Character set
  //------------------------------------------------------------------
  while(StrLen > 0)
  {
    c = pStr[StrOff];			// get character
    if((c == 0) ||			// end of String, anyway
       (Strnchr(pCharset,CharsetOff,CharsetLen,c) >= 0)) // in character set
      break;
    StrOff++;
    StrLen--;
  }
  return(StrOff-StartOff);
}

/**
* Counts the number of characters within an ASCIIz string until the last 
* character, that is in a given character set (StrnpbrkRev).
* The character set to be counted is defined by an ASCIIz string.
* The count includes the first match.
*
*  @param pStr String data buffer
*  @param StrOff Start offset of string data
*  @param StrLen Length of string data
*  @param pCharset Character set buffer
*  @param CharsetOff Start of character set data
*  @param CharsetLen Length of character set
*  @return Number of characters
*/
extern "C"  int  StrnpbrkRev(char* pStr, int StrOff, int StrLen,
			        char* pCharset,int CharsetOff,int CharsetLen)
{
  char c;
  int StartOff = StrOff;

  if((pStr == NULL) || (pCharset == NULL) ||
     (StrLen <= 0) || (CharsetLen <= 0))
    return(0);
  //------------------------------------------------------------------
  // Scan the String backward till a character *is* in Character set
  //------------------------------------------------------------------
  StrOff += StrLen;			// past last character
  while(StrLen > 0)
  {
    StrOff--;
    c = pStr[StrOff];			// get character
    if(Strnchr(pCharset,CharsetOff,CharsetLen,c) >= 0) // in character set
      break;
    StrLen--;
  }
  return(StrOff-StartOff);
}

/**
* Replaces the first found CR or
* LF character within an ASCIIz string with NUL (ChopAsciizStrCrLf).
*
*  @param pStr String data buffer
*  @param StrOff Start offset of string data
*  @return Length of the substring, generated by the replacing
*/
extern "C"  int  ChopAsciizStrCrLf(char* pStr, int StrOff)
{
  char c;
  int StartOff = StrOff;

  if(pStr == NULL)				// no buffer
      return(-1);
  //----------------------------------------------------------
  // Scan the String forward till CR, LF , NUL)
  //----------------------------------------------------------
  for(;;)
  {
    c = pStr[StrOff];
    if(c == (unsigned char) 0)			// End of string anyway
      break;
    if((c == (unsigned char) CR_CHAR) || (c == (unsigned char) LF_CHAR)) // CR or LF
    {
      pStr[StrOff] = (unsigned char) 0;		// delimit
      break;
    }
    StrOff++;
  }
  return(StrOff - StartOff);  
}

/**
* Gets next element from a comma separated string List, strip leading
* and trailing whitespaces (GetListElement).
*
* Note:
* <ol>
*  <li> Skips leading whitespaces and, if present, the comma
*  <li> Searches forward for next comma
*	<li> Scans backward from end / comma till non whitespace found
*	<li> Return total touched character count
*	<li> Empty list elements are *also* skipped
* </ol>
*  @param pList List data buffer
*  @param ListOff Start of list data
*  @param ListLen Length of list data
*  @param pElementIndex Return pointer for element index, relative to the 
*                       offset
*  @param pElementLen Return pointer for the length of the element
*  @return Total number of scanned characters, <0 on error
*/
extern "C"  int  GetListElement(char* pList, int ListOff, int ListLen,
		int* pElementIndex, int* pElementLen)
{
  char c;
  int StartOff = ListOff;
  int EndOff;
  int Len;
  //-------------------------------------------------
  // check parameters, process simple cases
  //-------------------------------------------------
  if((pList == NULL) || (pElementIndex == NULL) || (pElementLen == NULL))
    return(-1);

  pElementIndex[0] = 0;
  pElementLen[0]   = 0;

  if(ListLen <= 0)
    return(0);
  //--------------------------------------------------------
  // find start of next element, skip empty list entries
  //--------------------------------------------------------
  c = 0;
  for(;;)
  {
    //-------------------------------------------------
    // Skip leading whitespaces
    //-------------------------------------------------
    while(ListLen > 0)
    {
      c = pList[ListOff];
      if((c != 0x09) && (c != 0x20))		// not a white space
        break;
      ListOff++;
      ListLen--;
    }
    if(ListLen <= 0)				// no more data
      return(ListOff-StartOff);
    //---------------------------------------------------
    // Check if character found is a 'Comma', if so, skip
    //---------------------------------------------------
    if(c != (unsigned char) ',')				// is *NOT* a comma
      break;
    ListOff++;
    ListLen--;
    if(ListLen <= 0)				// no more data
      return(ListOff-StartOff);
  }
  //--------------------------------------------------------
  // Found Start of Element, save relativ (!) Starting Index
  //--------------------------------------------------------
  pElementIndex[0] = ListOff-StartOff;	
  EndOff = ListOff;				// save 'start' offset
  //------------------------------------------------------
  // Scan forward for next 'Comma' if one is present
  //------------------------------------------------------
  Len = Strnchr(pList,ListOff,ListLen,(unsigned char) ',');
  if(Len >= 0)					// found next 'Comma'
  {
    EndOff  = ListOff + Len + 1;		// set past comma
    ListLen = Len;				// limit backward scan
  }
  else						// not found, scan till NULL
  {
    while(ListLen > 0)
    {
      if(pList[ListOff] == (unsigned char) 0)    
        break;
      ListOff++;
      ListLen--;
    }
    ListLen = ListOff - EndOff;			// get remaining length
    Len     = ListOff;				// save ending offset
    ListOff = EndOff;				// set start offset
    EndOff  = Len;				// set true end offset
  }
  if(ListLen <= 0)
    return(EndOff - StartOff);
  //-----------------------------------------------------------
  // Scan backward either from End or Comma till non whitespace/NUL
  //-----------------------------------------------------------
  ListOff = EndOff-1;				// Start at last character
  while(ListLen > 0)
  {
    c = pList[ListOff];
    if((c != 0x09) && (c != 0x20) && (c != (unsigned char) ','))
    {
      ListOff++;			// correct the offset !
      break;
    }
    ListOff--;
    ListLen--;
  }
  pElementLen[0] = ListOff -StartOff - pElementIndex[0];
  return(EndOff - StartOff);
}

/**
* Counts number of non empty elements in a comma separated string list (CountListElements).
*
*  @param pList List data buffer
*  @param ListOff Start of list data
*  @param ListLen Length of list data
*  @return Number of non empty elements, <0 on error
*/
extern "C"  int  CountListElements(char* pList,int ListOff,int ListLen)
{
  int ElementCount = 0;
  int SkipLen;

  int pTmpIndex[1];
  int pTmpLen[1];
  //-------------------------------------------------
  // check parameters, process simple cases
  //-------------------------------------------------
  if(pList == NULL)
    return(-1);

  for(;;)
  {
    SkipLen = GetListElement(pList, ListOff, ListLen, pTmpIndex, pTmpLen);
    if(SkipLen < 0)
      return(SkipLen);
    if(SkipLen == 0)			// no more data
      return(ElementCount);

    if(pTmpLen[0] > 0)			// element not empty
      ElementCount++;
    ListOff += SkipLen;
    ListLen -= SkipLen;
    if(ListLen <= 0)
      return(ElementCount);
  }
}

/**
* Finds the first element in the primary comma separated, possibly ASCIIz
* string list, that is also contained in the secondary comma separated, 
* possibly ASCIIz string list (MatchLists).
*
* Note: The Lists may include whitespaces, multi commata and may both
*     be empty. 
*	    Leading or trailing whitespaces for list elements are not
*	    considered for comparison.
*
*  @param pPrimList Primary list buffer
*  @param PrimOff Primary list data start
*  @param PrimLen Primary list length
*  @param pSecList Secondary list buffer
*  @param SecOff Secondary list data start
*  @param SecLen Secondary list length
*  @param CaseIgnoreFlag == 0 obey case, else ignore
*  @param pElementIndex Pointer to return found element index, relative to 
*                       starting offset
*  @param pElementLen Pointer to return found element length
*  @return < 0 Error occured (Null pointer)
* <br>            == 0 match found
* <br>            > 0 no match found
*/
extern "C"  int  MatchLists(char* pPrimList, int PrimOff, int PrimLen,
		char* pSecList, int SecOff, int SecLen, int CaseIgnoreFlag,
		int* pElementIndex, int* pElementLen)
{
  int SecHasElements = 0;
  int PrimElementIndex;
  int PrimElementLen;
  int PrimSkipLen = 0;
  int SecSkipLen;
  int Result;
  int PrimStartOff = PrimOff;
  int SecStartOff = SecOff;
  int SecStartLen = SecLen;

  int pTmpIndex[1];
  int pTmpLen[1];

  //----------------------------------------------
  // Check Parameters first
  //----------------------------------------------
  if((pPrimList == NULL) || (pSecList == NULL))
    return(-1);

  if((PrimLen <= 0) || (SecLen <= 0))		// cannot match anyway
    return(1);

  for(;;)
  {
    //---------------------------------------------------------------
    // Get Next Element from Primary List
    //---------------------------------------------------------------
    PrimOff += PrimSkipLen;
    PrimLen -= PrimSkipLen;
    if(PrimLen <= 0)
      return(1);

    PrimSkipLen = GetListElement(pPrimList,PrimOff,PrimLen,pTmpIndex,pTmpLen);
    if(PrimSkipLen < 0)
      return(-1);
    PrimElementIndex = PrimOff + pTmpIndex[0];
    PrimElementLen   = pTmpLen[0];    
    if(PrimElementLen <= 0)			// no more elements
      return(1);
    //---------------------------------------------------------------
    // Scan Secondary List Elements
    //---------------------------------------------------------------
    SecOff = SecStartOff;
    SecLen = SecStartLen;
    SecSkipLen = 0;
    for(;;)
    {
      //---------------------------------------------------------------
      // Get Next Element from Secondary List
      //---------------------------------------------------------------
      SecOff += SecSkipLen;
      SecLen -= SecSkipLen;
      if(SecLen <= 0)				// no more Elements
        break;

      SecSkipLen = GetListElement(pSecList,SecOff,SecLen,pTmpIndex,pTmpLen);
      if(SecSkipLen < 0)
        return(-1);
      if(pTmpLen[0] <= 0)			// no more Elements
        break;
      SecHasElements = 1;
      //---------------------------------------------------------------
      // Compare Elements, case sensitive/insensitive
      //---------------------------------------------------------------
      if(pTmpLen[0] != PrimElementLen)		// cannot match anyway
        continue;
      if(CaseIgnoreFlag == 0)			// compare with case
        Result = Memcmp(pPrimList,PrimElementIndex,pSecList,SecOff+pTmpIndex[0],PrimElementLen);
      else
        Result = Strnicmp(pPrimList,PrimElementIndex,PrimElementLen,
		          pSecList,SecOff+pTmpIndex[0],PrimElementLen);
      if(Result == 0)				// Found a match !!
      {
        if(pElementIndex != NULL)
          pElementIndex[0] = PrimElementIndex - PrimStartOff;
        if(pElementLen != NULL)
          pElementLen[0] = PrimElementLen;
        return(0);
      }
    } // Secondary FOR
    //---------------------------------------------------------------
    // No match found so far, check if secondary had elements at all
    //---------------------------------------------------------------
    if(SecHasElements == 0)			// no Elements
      return(1);
  } // Primary FOR
}

/**
* Checks, if all or none of the elements of a comma separated, possibly ASCIIz,
* primary list are included in a comma separated, possibly ASCIIz, secondary list (ListInList).
*
* Note:  The lists may include whitespaces,multi commata and may both
*    be empty. Leading or trailing whitespaces for list elements are
*	  not considered for comparison.
*
*  @param pPrimList Primary list buffer
*  @param PrimOff Primary list data start
*  @param PrimLen Primary list length
*  @param pSecList Secondary list buffer
*  @param SecOff Secondary list data start
*  @param SecLen Secondary list length
*  @param CaseIgnoreFlag == 0 obey case, else ignore
*  @param ExcludeMode == 0 check for all elements, else check for none
*  @return < 0 Error occured (Null pointer)
* <br>            == 0 match found
* <br>            > 0 no match found
*/
extern "C"  int  ListInList(char* pPrimList, int PrimOff, int PrimLen,
		char* pSecList, int SecOff, int SecLen,
		int CaseIgnoreFlag, int ExcludeMode)
{
  int PrimHasElements = 0;
  int SecHasElements = 0;
  int PrimElementIndex;
  int PrimElementLen;
  int PrimSkipLen = 0;
  int SecSkipLen;
  int Result;
  int SecStartOff = SecOff;
  int SecStartLen = SecLen;

  int pTmpIndex[1];
  int pTmpLen[1];

  //----------------------------------------------
  // Check Parameters first
  //----------------------------------------------
  if((pPrimList == NULL) || (pSecList == NULL))
    return(-1);

  if((PrimLen <= 0) || (SecLen <= 0))		// cannot match anyway
    return(1);

  for(;;)
  {
    //---------------------------------------------------------------
    // Get Next Element from Primary List
    //---------------------------------------------------------------
    PrimOff += PrimSkipLen;
    PrimLen -= PrimSkipLen;
    if(PrimLen <= 0)				// no more Elements
    {
      if(PrimHasElements == 0)			// was empty !
        return(1);
      return(0);
    }
    PrimSkipLen = GetListElement(pPrimList,PrimOff,PrimLen,pTmpIndex,pTmpLen);
    if(PrimSkipLen < 0)
      return(-1);
    PrimElementIndex = PrimOff + pTmpIndex[0];
    PrimElementLen   = pTmpLen[0];    
    if(PrimElementLen <= 0)			// no more elements
    {
      if(PrimHasElements == 0)			// was empty !
        return(1);
      return(0);
    }
    PrimHasElements = 1;			// list had Elements
    //---------------------------------------------------------------
    // Scan Secondary List Elements
    //---------------------------------------------------------------
    SecOff = SecStartOff;
    SecLen = SecStartLen;
    SecSkipLen = 0;
    Result = -1;				// assume not matched
    for(;;)
    {
      //---------------------------------------------------------------
      // Get Next Element from Secondary List
      //---------------------------------------------------------------
      SecOff += SecSkipLen;
      SecLen -= SecSkipLen;
      if(SecLen <= 0)				// no more Elements
        break;

      SecSkipLen = GetListElement(pSecList,SecOff,SecLen,pTmpIndex,pTmpLen);
      if(SecSkipLen < 0)
        return(-1);
      if(pTmpLen[0] <= 0)			// no more Elements
        break;
      SecHasElements = 1;
      //---------------------------------------------------------------
      // Compare Elements, case sensitive/insensitive
      //---------------------------------------------------------------
      if(pTmpLen[0] != PrimElementLen)		// cannot match anyway
        continue;
      if(CaseIgnoreFlag == 0)			// compare with case
        Result = Memcmp(pPrimList,PrimElementIndex,pSecList,SecOff+pTmpIndex[0],PrimElementLen);
      else
        Result = Strnicmp(pPrimList,PrimElementIndex,PrimElementLen,
		          pSecList,SecOff+pTmpIndex[0],PrimElementLen);
      if(Result == 0)				// Found a match
        break;
    } // Secondary FOR
    //---------------------------------------------------------------
    // Check match conditions
    //---------------------------------------------------------------
    if(ExcludeMode == 0)			// all should be present
    {
      if(Result != 0)				// was *not* present
        return(1);				// signal mismatch
    }
    else					// none should be present
    {
      if(Result == 0)				// a match was found
        return(1);				// signal mismatch
      if(SecHasElements == 0)			// need not scan further
        return(0);
    }
  } // Primary FOR
}

/**
* Finds index of a sized, possibly ASCIIz string to a given String Array (FindStrIndex).
*
*  @param pStrBuf String Buffer
*  @param StrOff Start offset of string data
*  @param StrLen length of data
*  @param pStrArr String Array
*  @param StartIndex Starting Index
*  @param ArrayLen Number of Elements in array
*  @param CaseIgnoreFlag == 0 obey, else ignore case
*  @return int ArrayIndex if >= 0, else not found
*/
extern "C"  int  FindStrIndex(char* pStrBuf, int StrOff, int StrLen,
		char ** pStrArr, int StartIndex, int ArrayLen,
		int CaseIgnoreFlag)
{
  char * pStr;

  if((pStrBuf == NULL) || (pStrArr == NULL) ||
     (StrLen <= 0) || (ArrayLen <= 0) || (StartIndex < 0) ||
     (StartIndex >= ArrayLen))
    return(-1);

  while(StartIndex < ArrayLen)
  {
    pStr = pStrArr[StartIndex];			// get pointer
    if(pStr != NULL)
    {
      if(JStrncmp(pStrBuf, StrOff, StrLen, pStr, CaseIgnoreFlag) == 0)
        return(StartIndex);
    }
    StartIndex++;
  }
  return(-2);
}

/**
* Converts content of an ASCIIz string array to a comma separated ASCIIz list (ArrayToList).
*
* The generated list will be newly allocated.
*
*  @param pStrArr String array
*  @param StartIndex Starting index
*  @param ArrayLen Number of elements in array
*  @param ppList Pointer for generated list
*  @param pListLen Pointer for length of list. Optional
*  @return 0 on success, error code otherwise
*/
extern "C"  int  ArrayToList(HMEM_CTX_DEF
		char ** pStrArr, int StartIndex,
		int ArrayLen, char** ppList, int* pListLen)
{
  int ElementCnt;
  int ArrayIndex,DstIndex;
  int NeededLen;
  int Len;
  char * pStr;
  char* pList;
  //----------------------------------------------
  // Check Parameters first
  //----------------------------------------------
  if((pStrArr == NULL) || (ppList == NULL))
    return(-1);
  ppList[0] = NULL;
  if(pListLen != NULL)
    pListLen[0] = 0;

  if((ArrayLen <= 0) || (StartIndex >= ArrayLen))
    return(-2);
  //------------------------------------------------------
  // Get total size needed for the list, allocate the list
  //------------------------------------------------------
  ElementCnt = 0;
  NeededLen = 1;			// at Least a NUL is needed
  ArrayIndex = StartIndex;
  while(ArrayIndex < ArrayLen)
  {
    pStr = pStrArr[ArrayIndex++];
    if(pStr != NULL)
    {
      Len = Strlen(pStr,0);
      NeededLen += Len;
      if(Len != 0)
        ElementCnt++;
    }
  }
  if(ElementCnt != 0)
    NeededLen += (ElementCnt-1);	// commas needed

  pList = BIT8_ARRAY_ALLOC(HMEM_CTX_REF,NeededLen);
  if(pList == NULL)
    return(-3);
  //-----------------------------------------------------
  // Copy the Strings to the buffer, if any were present
  //-----------------------------------------------------
  ppList[0] = pList;
  if(pListLen != NULL)
    pListLen[0] = NeededLen-1;

  if(ElementCnt == 0)			// no data
    return(0);

  ArrayIndex = StartIndex;
  DstIndex = 0;
  while(ArrayIndex < ArrayLen)
  {
    pStr = pStrArr[ArrayIndex++];
    if(pStr != NULL)
    {
      Len = Strlen(pStr,0);
      if(Len != 0)
      {
        if(DstIndex != 0)		// already data present
          pList[DstIndex++] = (unsigned char) ',';
        memcpy(pList+DstIndex,pStr,Len);
        DstIndex += Len;
      }
    }
  }
  pList[DstIndex] = (unsigned char) 0;
  return(0);
}

/**
* Finds the IDs of the strings in a coma separated list (StrListToIDList).
* ID-String association is defined by a string array and corresponding ID 
* array.
* The IDs of the strings in the coma separated list are put into a newly
* allocated list. Duplicate IDs are removed. All strings must be found in
* the string array.
*
*  @param pStrList List buffer
*  @param StrListOff Start of list Data
*  @param StrListLen Length of list
*  @param pStrArr String array
*  @param pIDArr ID array
*  @param StartIndex Starting index for both arrays
*  @param ArrayLen Number of elements in array
*  @param CaseIgnoreFlag == 0 respect case, else ignore case
*  @param ppIDList Allocated IDList. Optional
*  @param pIDListLen Length of IDList. Optional
*  @return 0 on success, error code otherwise
*/
extern "C"  int  StrListToIDList(HMEM_CTX_DEF
	char* pStrList, int StrListOff,
	int StrListLen, char ** pStrArr, int* pIDArr,
	int StartIndex,	int ArrayLen, int CaseIgnoreFlag,
	char** ppIDList, int* pIDListLen)
{
  char c;
  int ElementCnt;
  int ElementIndex,ElementLen;
  int SrcIndex,DstIndex,ScanIndex;
  int SkipLen;
  int Retcode;
  char* pIDList;
  char* pBuf;
  int pTmpIndex[1];
  int pTmpLen[1];
  //----------------------------------------------
  // Check Parameters first
  //----------------------------------------------
  if((pStrList == NULL) || (pStrArr == NULL) || (pIDArr == NULL))
    return(-1);
  if(ppIDList != NULL)
    ppIDList[0] = NULL;
  if(pIDListLen != NULL)
    pIDListLen[0] = 0;

  if((ArrayLen <= 0) || (StartIndex >= ArrayLen) || (StartIndex < 0))
    return(-2);
  //------------------------------------------------------
  // Get total size needed for the list, allocate the list
  //------------------------------------------------------
  ElementCnt = CountListElements(pStrList,StrListOff,StrListLen);
  if(ElementCnt <= 0)
    return(ElementCnt);
  pIDList = BIT8_ARRAY_ALLOC(HMEM_CTX_REF,ElementCnt);
  if(pIDList == NULL)
    return(-3);
  //------------------------------------------------------
  // Extract, Parse the Elements, construct ID list
  //------------------------------------------------------
  DstIndex = 0;
  for(;;)
  {
    SkipLen = GetListElement(pStrList,StrListOff,StrListLen,pTmpIndex,pTmpLen);
    if(SkipLen < 0)
    {
      FREE_ARRAY(HMEM_CTX_REF,pIDList);
      return(SkipLen);
    }
    if(SkipLen == 0)			// no more data
      break;

    ElementLen = pTmpLen[0];
    if(ElementLen > 0)			// element not empty
    {
      //--------------------------------------------------------
      // Fetch the Index into the String Array, get the ID
      //--------------------------------------------------------
      ElementIndex = StrListOff+pTmpIndex[0];	// get start of the Element
      Retcode = FindStrIndex(pStrList, ElementIndex, ElementLen,
		             pStrArr, StartIndex, ArrayLen, CaseIgnoreFlag);
      if(Retcode < 0)
      {
        FREE_ARRAY(HMEM_CTX_REF,pIDList);
        return(-4);
      }
      pIDList[DstIndex++] = (char) pIDArr[Retcode]; // get, store the ID
    }
    StrListOff += SkipLen;
    StrListLen -= SkipLen;
    if(StrListLen <= 0)
      break;
  }
  //-------------------------------------------------------
  // Check if ID-List shall be returned at all
  //-------------------------------------------------------
  if(ppIDList == NULL)			// not required
  {
    FREE_ARRAY(HMEM_CTX_REF,pIDList);
    if(pIDListLen != NULL)
      pIDListLen[0] = DstIndex;
    return(0);
  }
  //-------------------------------------------------------
  // The ID list shall be returned, so eliminate duplicates
  // NOTE: to not disturb the preference order, duplicate
  // ----- removal is processed from List End to Start
  //-------------------------------------------------------
  if(DstIndex <= 1)
  {
    ppIDList[0] = pIDList;
    if(pIDListLen != NULL)
      pIDListLen[0] = DstIndex;
    return(0);
  }

  pBuf = BIT8_ARRAY_ALLOC(HMEM_CTX_REF,DstIndex);
					// get Working buffer
  if(pBuf == NULL)
  {
    FREE_ARRAY(HMEM_CTX_REF,pIDList);
    return(-3);
  }
  SrcIndex = DstIndex - 1;
  DstIndex = 0;				// store Index
  while(SrcIndex > 0)
  {
    c = pIDList[SrcIndex];		// get comparison character
    ScanIndex = SrcIndex -1;		// 1 lower
    while(ScanIndex >= 0)
    {
      if(pIDList[ScanIndex] == c)
        break;
      ScanIndex--;
    }
    if(ScanIndex < 0)			// not a duplicate
      pBuf[DstIndex++] = c;		// save
    SrcIndex--;
  }
  FREE_ARRAY(HMEM_CTX_REF,pIDList);

  Memrev(pBuf,0,DstIndex);		// mirror resulting list
  ppIDList[0] = pBuf;
  if(pIDListLen != NULL)
    pIDListLen[0] = DstIndex;
  return(0);
}

/**
* Multiply a given BIT32 Number by a BIT8 unsigned Base value, add
* Current BIT8 Digit value and limit return value to given mask (Mul32By8AndLimit).
*
*  @param Multiplicand Unsigned Multiplicand
*  @param Multiplicator Unsigned Multiplicator
*  @param NextDigitValue Current Digit's value to add
*  @param LimitMask AND-Mask to apply
*  @param pResult Resulting Number
*/
static  void  Mul32By8AndLimit(int Multiplicand,
		int Multiplicator, int NextDigitValue,
		int LimitMask, int* pResult)
{
  int DstIndex = 0;
  int TmpResult;
  char MultBuf[4];
  //------------------------------------------------------
  // Store Number to Byte Multiply Buffer
  //------------------------------------------------------
  MultBuf[0] = (unsigned char) (Multiplicand);			// LSB
  MultBuf[1] = (unsigned char) (Multiplicand >> 8);
  MultBuf[2] = (unsigned char) (Multiplicand >> 16);
  MultBuf[3] = (unsigned char) (Multiplicand >> 24);		// MSB
  //--------------------------------------------------------
  // Multiply by base and add the next digit (is also carry)
  //--------------------------------------------------------
  do
  {
    TmpResult =  ((int) MultBuf[DstIndex] & 0xFF) * Multiplicator +
                 NextDigitValue;
    MultBuf[DstIndex++] = (unsigned char) TmpResult;
    NextDigitValue = (int) (TmpResult >> 8) & 0xFF;
  }while(DstIndex < 4);
  //--------------------------------------------------------
  // Generate masked Multiply/Add result
  //--------------------------------------------------------
  pResult[0] = (((int) MultBuf[0] & 0xFF) |
                (((int) MultBuf[1] & 0xFF) << 8) |
                (((int) MultBuf[2] & 0xFF) << 16) |
                (((int) MultBuf[3] & 0xFF) << 24)) & LimitMask;
}

/**
* Parses an integer number from a string (StrToBit32Num).
* Decimal, octal and
* hex, signed and unsigned are supported. The generated number will be of type 
* <code>BIT32</code>.
*
*  @param pInpBuf Input data buffer
*  @param InpOff Start of input data
*  @param InpLen (remaining) length of data
*  @param NumberType Type of Number: <br>
*              NUMBER_TYPE_OCTAL - parse as octal <br>
*              NUMBER_TYPE_HEX - parse as hex <br>
*              NUMBER_TYPE_INTEGER - detect by prefix (0 for octal, 0x for hex) <br>
*              else parse as decimal
*  @param pNumber Pointer to place the generated number
*  @return int ParsedLen > 0 o.k, else Parse Error occured
*/
extern "C"  int  StrToBit32Num(char* pInpBuf, int InpOff,
		int InpLen, int NumberType, int* pNumber)
{
  char c;
  int Retcode;
  int StartOff = InpOff;
  int NegFlag = 0;
  int Base;
  int NextDigit;
  int DigitCnt = 0;

  if((pInpBuf == NULL) || (pNumber == NULL) ||
     (InpLen <= 0))
    return(-1);
  pNumber[0] = 0;
  //------------------------------------------------------------
  // Get true length
  //------------------------------------------------------------
  InpLen = StrnSlen(pInpBuf, InpOff, InpLen);
  //------------------------------------------------------------
  // Skip leading Whitespaces
  //------------------------------------------------------------
  Retcode = GetWspacesAsciizStr(pInpBuf, InpOff, InpLen, 0, 0);
  InpOff += Retcode;
  InpLen -= Retcode;
  if(InpLen <= 0)
    return(0);					// no number start found
  //------------------------------------------------------------
  // Get Number Sign Character if present, skip
  //------------------------------------------------------------
  c = pInpBuf[InpOff];
  if((c == (unsigned char) '+') || (c == (unsigned char) '-'))	// is a sign
  {
    if(c == (unsigned char) '-')
      NegFlag = 1;
    InpOff++;
    InpLen--;
    if(InpLen <= 0)
      return(0);
    c = pInpBuf[InpOff];			// get following character
  }
  //------------------------------------------------------------
  // Setup Number Parse Options
  //------------------------------------------------------------
  Base = 10;					// assume decimal
//  if((NumberType == NUMBER_TYPE_U_DECIMAL) ||	// unsigned decimal Number
//     (NumberType == NUMBER_TYPE_UL_DECIMAL))	// dto., long
//    UnsignedFlag = 1;

  if(NumberType == NUMBER_TYPE_OCTAL)		// octal Number
    Base = 8;
  else if(NumberType == NUMBER_TYPE_HEX)	// hexa Number
    Base = 16;
  else if(NumberType == NUMBER_TYPE_INTEGER)	// variable base type
  {
    if(c == (unsigned char) '0')				// might be octal type
    {
      InpOff++;					// advance
      InpLen--;					// reduce length
      Base = 8;					// assume octal
      if(InpLen <= 0)				// number ended !
        return(InpOff-StartOff);
      c = pInpBuf[InpOff];			// get next digit/HexID        
      if((c == (unsigned char) 'x') || (c == (unsigned char) 'X')) // is Hex
      {
        InpOff++;				// advance
        InpLen--;				// reduce length
        Base = 16;				// must be hex
        if(InpLen <= 0)				// number incomplete !
          return(0);
        c = pInpBuf[InpOff];			// get next Digit
      }
    }
  }
  //------------------------------------------------------------
  // Process the Number's digits now, as long as valid Digit
  //------------------------------------------------------------
  while(InpLen > 0)
  {
    c = pInpBuf[InpOff];			// Fetch Digit
    if((c < (unsigned char) '0') || (c > (unsigned char) 'f'))	// not a valid number anyway
      break;
    if(((Base == 8)  && (c > (unsigned char) '7')) ||	// not an octal number
       ((Base == 10) && (c > (unsigned char) '9')) ||	// not a decimal number
       ((c > (unsigned char) '9') && (c < (unsigned char) 'A')) ||
       ((c > (unsigned char) 'F') && (c < (unsigned char) 'a')))	// not a HEX number
         break;
    InpOff++;
    InpLen--;
    //--------------------------------------------------------------
    // valid Number, convert to HEX, multiply current number by base
    //--------------------------------------------------------------
    DigitCnt++;
    NextDigit = ((int) c | (0x20)) - 0x30;	// to lower and to Hex
    if(NextDigit > 9)				// is a HEX digit !
      NextDigit -= 0x27;			// 'a'-'f' -> 0x0A-0x0F
    Mul32By8AndLimit(pNumber[0], Base, NextDigit,
		     (int) 0xFFFFFFFF, pNumber);
  }
  if(DigitCnt == 0)			// not valid anyway
    return(0);

  if(NegFlag != 0)
    pNumber[0] = -pNumber[0]; 
  return(InpOff-StartOff);
}

/**
* Matches a string against a pattern (MatchPattern).
* Both are sized and may be ASCIIz.
* NOTE: 
* <ol>
*  <li> '*' and '?' characters in Pattern are considered wildcards: <ul>
*    <li> '?' matches any single character from string.
*	  <li> '*' matches any sequence of characters from string. </ul>
*	<li> Consecutive pattern wildcard characters that start with a '*'
*	    are treated as a single '*' character.</ol>
*
*  @param pStr String data
*  @param StrOff Start of string data
*  @param StrLen Length of string data
*  @param pPat Pattern data
*  @param PatOff Start of pattern
*  @param PatLen Length of pattern data
*  @param CaseIgnoreFlag == 0 obey case, else ignore
*  @return 0, if no match is found, non-0 otherwise
*/
extern "C"  int  MatchPattern(char* pStr, int StrOff, int StrLen,
		char* pPat, int PatOff, int PatLen, int CaseIgnoreFlag)
{
  char cs,cp;
  int Len;

  if((pStr == NULL) || (pPat == NULL))	// cannot decide either
    return(0);
  //--------------------------------------------------------
  // Normalize String length, check resulting sizes 
  //--------------------------------------------------------
  StrLen = StrnSlen(pStr,StrOff,StrLen);
  PatLen = StrnSlen(pPat,PatOff,PatLen);
  if((StrLen <= 0) || (PatLen <= 0))	// dto.
    return(0);
  //--------------------------------------------------------
  // Start match now
  //--------------------------------------------------------
  for(;;)
  {
    //----------------------------------------------------------
    // fetch next pattern character, if still characters present
    //----------------------------------------------------------
    if(PatLen <= 0)			// pattern ended
      return((StrLen == 0) ? 1 : 0);	// decide if string also at end
    cp = pPat[PatOff++];		// get pattern character
    PatLen--;
    if(cp != (unsigned char) '*')
    {
      //--------------------------------------------------
      // Standard single character match
      //--------------------------------------------------
      if(StrLen <= 0)			// string ended
        return(0);
      if(cp == (unsigned char) '?')		// is a wildcard match
      {
        StrOff++;
        StrLen--;
        continue;
      }
      cs = pStr[StrOff++];		// get string character
      StrLen--;
      if(CaseIgnoreFlag != 0)
      {
        cp = ToLowerChar(cp);
        cs = ToLowerChar(cs);
      }
      if(cp != cs)			// different characters
        return(0);
      continue;
    }
    //---------------------------------------------------------
    // special wildcard matching mode, pattern contained '*'
    // scan for next pattern character that is *NOT* a wildcard
    //---------------------------------------------------------
    if(PatLen <= 0)			// is last character, so always match
      return(1);
    while(PatLen != 0)
    {
      cp = pPat[PatOff++];
      PatLen--;
      if((cp != (unsigned char)'*') && (cp != (unsigned char) '?'))
        break;
    }
    if((PatLen <= 0) && ((cp == (unsigned char) '*') || (cp == (unsigned char) '?')))
      return(1);
    //----------------------------------------------------------
    // found a character that must be present anywhere in string
    //----------------------------------------------------------
    if(StrLen <= 0)			// string ended
      return(0);
    if(CaseIgnoreFlag == 0)
      Len = Strnchr(pStr,StrOff,StrLen,cp);	// case sensitive
    else
      Len = Strnichr(pStr,StrOff,StrLen,cp);	// not case sensitive
    if(Len < 0)				// not found
      return(0);
    StrOff += (Len + 1);
    StrLen -= (Len + 1);
  } // for
}
/**
* Matches a string against a pattern list (MatchPatternList).
* Both are sized and may be ASCIIz, the list is comma separated.
* Patterns are explained in the function MatchPattern.
*
* NOTE: A pattern, starting with '!' is asking for a negative match, meaning
*  the pattern must not be in the string. Such a request has priority over
*  positive matches.
*	 To not miss a negative match, *all* patterns are scanned.
*
*  @param pStr String data
*  @param StrOff Start of string data
*  @param StrLen Length of string data
*  @param pList Pattern list data
*  @param ListOff Start of list ata
*  @param ListLen Length of list data
*  @param CaseIgnoreFlag == 0 obey case, else ignore
*  @return == 0 no match,
* <br>            < 0 - negative match found,
* <br>            > 0 - positive match found, no negative
*/
extern "C"  int  MatchPatternList(char* pStr, int StrOff, int StrLen,
		char* pList, int ListOff, int ListLen, int CaseIgnoreFlag)
{
  int Result;
  int SkipLen = 0;
  int NegFlag;
  int HadPosMatch = 0;
  int PatOff,PatLen;

  int pTmpIndex[1];
  int pTmpLen[1];

  if((pStr == NULL) || (pList == NULL))	// cannot decide either
    return(0);
  //--------------------------------------------------------
  // Normalize String length, check resulting sizes 
  //--------------------------------------------------------
  StrLen  = StrnSlen(pStr,StrOff,StrLen);
  ListLen = StrnSlen(pList,ListOff,ListLen);
  if((StrLen <= 0) || (ListLen <= 0))	// dto.
    return(0);

  for(;;)
  {
    //--------------------------------------------------------
    // Extract next pattern from list
    //--------------------------------------------------------
    ListOff += SkipLen;
    ListLen -= SkipLen;
    if(ListLen <= 0)
      return(HadPosMatch);    
    SkipLen = GetListElement(pList,ListOff,ListLen,pTmpIndex,pTmpLen);
    if(SkipLen < 0)
      return(HadPosMatch);
    PatLen = pTmpLen[0];
    if(PatLen <= 0)
      continue;
    //--------------------------------------------------------
    // Got next pattern, check for negated
    //--------------------------------------------------------
    PatOff = ListOff+pTmpIndex[0];		// start of pattern
    NegFlag = 0;
    if(pList[PatOff] == (unsigned char) '!')
    {
      NegFlag = 1;
      PatOff++;
      PatLen--;
    }
    //--------------------------------------------------------
    // Match the string against the pattern
    //--------------------------------------------------------
    Result = MatchPattern(pStr,StrOff,StrLen,pList,PatOff,PatLen,
			  CaseIgnoreFlag);
    if(Result != 0)				// had a match
    {
      if(NegFlag != 0)				// was a negative match
        return(-1);				// always stop
      HadPosMatch = 1;				// save that we had a match
    }
  } // For
}
/**
* Canonicalizes an ASCIIz comma separated list (GenCanonicList).
* Strips all unnecessary whitespaces and commas from a given list and
* terminates the list with NUL. The canonic list is written into a newly
* allocated buffer.
*
* NOTE: Whitespaces are considered unnecessary if at start or end
*   of a (non empty) list element.
*
*  @param pSrcList Target list
*  @param SrcOff Start offset of data
*  @param SrcLen Length of list
*  @param ppDstList Pointer to place the cannonic list
*  @param pDstListLen Pointer for the length of the list. Optional
*  @return 0 on success, error code otherwise
*/
extern "C"  int  GenCanonicList(HMEM_CTX_DEF
			char* pSrcList, int SrcOff,
			int SrcLen, char** ppDstList, int* pDstListLen)
{
  int Len,ElementEndIndex,ElementLen;
  int DstIndex = 0;
  int SkipLen = 0;
  char* pDstList;

  //----------------------------------------------
  // Check Parameters first
  //----------------------------------------------
  if((pSrcList == NULL) || (ppDstList == NULL))
    return(-1);
  ppDstList[0] = NULL;
  if(pDstListLen != NULL)
    pDstListLen[0] = 0;

  SrcLen = StrnSlen(pSrcList,SrcOff,SrcLen);	// get TRUE length
  if(SrcLen <= 0)
    return(-2);
  //------------------------------------------------------
  // Allocate Destination buffer, same size + 1 (NUL)
  //------------------------------------------------------
  if((pDstList = BIT8_ARRAY_ALLOC(HMEM_CTX_REF,SrcLen+1)) == NULL)
    return(-3);

  for(;;)
  {
    //-----------------------------------------------------
    // remove last processed element from source
    //-----------------------------------------------------
    SrcOff += SkipLen;
    SrcLen -= SkipLen;
    if(SrcLen <= 0)				// all processed
      break;
    //-----------------------------------------------------
    // Skip leading whitespaces
    //-----------------------------------------------------
    Len  = GetWspacesAsciizStr(pSrcList,SrcOff,SrcLen,0,0);
    SrcOff += Len;
    SrcLen -= Len;
    if(SrcLen <= 0)				// all processed
      break;
    //-----------------------------------------------------
    // check if empty field, i.e. ',' found -> discard
    //-----------------------------------------------------
    if(pSrcList[SrcOff] == (unsigned char) ',')		// empty Element
    {
      SkipLen = 1;
      continue;
    }
    //-----------------------------------------------------
    // Valid Element Start found, scan forward for next ','
    //-----------------------------------------------------
    ElementEndIndex = Strnchr(pSrcList,SrcOff,SrcLen,(unsigned char) ',');
    if(ElementEndIndex < 0)			// not Found
    {
      ElementEndIndex = SrcOff + SrcLen;	// use End of String
      ElementLen = SrcLen;
      SkipLen    = SrcLen;
    }
    else					// found a ','
    {
      ElementLen = ElementEndIndex;
      SkipLen = ElementLen+1;
    }
    if(ElementLen <= 0)				// is empty
      continue;
    //-----------------------------------------------------
    // Skip trailing whitespaces
    //-----------------------------------------------------
    Len  = GetWspacesRevAsciizStr(pSrcList,SrcOff,ElementLen);
    ElementLen -= Len;
    if(ElementLen <= 0)
      continue;					// very strange !!
    //-----------------------------------------------------
    // Found next element, copy to destination
    //-----------------------------------------------------
    if(DstIndex != 0)				// not the first Element !
      pDstList[DstIndex++] = (unsigned char) ',';	// set delimiter
    memcpy(pDstList+DstIndex,pSrcList+SrcOff,ElementLen);
    DstIndex += ElementLen;
  }
  //-------------------------------------------------------
  // All Elements processed, terminate the new List
  //-------------------------------------------------------
  pDstList[DstIndex] = 0;
  ppDstList[0] = pDstList;
  if(pDstListLen != NULL)
    pDstListLen[0] = DstIndex;
  return(0);
}

/**
* Converts a signed/unsigned long/short integer to an ASCIIz string (Bit32ToAsciizStr).
*
* NOTE: If no destination pointer given, returns just the length needed.
* If the destination is to short, an error is signaled and nothing is written.
*
*  @param IntVal Value to be converted
*  @param FormatFlags Formatting flags/tpes: <br>
*               Bit 0: 1 - Unsigned conversion <br>
*               Bit 1: 1 - Always output sign <br>
*               Bit 2: 1 - Prefix space if positive
*  @param pDstBuf Destination buffer. Optional
*  @param DstOff Start offset for writing
*  @param DstBufLen Length of destination buffer
*  @return Characters written/required, <0 on error.
*/
extern "C"  int  Bit32ToAsciizStr(int IntVal, int FormatFlags,
	char* pDstBuf, int DstOff, int DstBufLen)
{
  char SignChar = 0;
  int SrcIndex,DstIndex;
  int DigitCnt,BufLen;
  int Carry=0;
//  int UnsignedFlag = 0;
  int ShiftFlag = 0;

  int ConvVal = IntVal;

  char AsciiNumBuf[11];			// Number incl. sign

  //----------------------------------------------------------------
  // obey signed/unsigned modes, prepropcess
  //----------------------------------------------------------------
  if((FormatFlags & 0x01) != 0)			// is a signed type
  {
    if((ConvVal & 0x80000000) != 0)		// is negative
    {
      ConvVal = -ConvVal;			// make positive
      SignChar = (char) '-';
    }
    else					// is positive
    {
      if((FormatFlags & 0x02) != 0)		// always use sign
        SignChar = (char) '+';
      else if((FormatFlags & 0x04) != 0)	// use a sign position
        SignChar = (char) ' ';
    }
  }
  else						// is an unsigned type
  {
//    UnsignedFlag = 1;				// set unsigned
    if((ConvVal & 0x80000000) != 0)		// is 'negative'
    {
      ConvVal = (ConvVal >> 1) & 0x7FFFFFFF;	// reduce
      ShiftFlag = 1;
      Carry = (int) (IntVal & 0x01);
    }
  }
  //----------------------------------------------------------------
  // convert number from lowest to highest digit in reverse order
  //----------------------------------------------------------------
  DigitCnt = 0;
  while(ConvVal != 0)
  {
    AsciiNumBuf[DigitCnt] =
      (unsigned char) ((ConvVal % 10) + 0x30);		// get digit in ASCII
    DigitCnt++;
    ConvVal = ConvVal/10;
  }
  if(ShiftFlag != 0)				// must multiply * 2 !
  {
    SrcIndex = 0;
    while(SrcIndex < DigitCnt)
    {
      Carry = (AsciiNumBuf[SrcIndex] & 0x0F)*2 + Carry; // value * 2 + Carry
      AsciiNumBuf[SrcIndex] = (char) (Carry %10 + 0x30);
      Carry = Carry / 10;
      SrcIndex++;
    }
    if(Carry != 0)
      AsciiNumBuf[DigitCnt++] = (unsigned char) '1';
  }

  if(DigitCnt == 0)				// none generated, special
  {
    AsciiNumBuf[0] = (unsigned char) '0';
    DigitCnt++;
  }

  //-------------------------------------------------------------------
  // Calculate length of buffer needed, check if necessary size given
  //-------------------------------------------------------------------
  BufLen = DigitCnt;				// minimum length
  if(SignChar != 0)
    BufLen++;

  BufLen++;				// trailing NUL
  if(pDstBuf == NULL)			// length only requested
    return(BufLen);

  if(DstBufLen < BufLen)
    return(-1);
  //-------------------------------------------------------------
  // left padded output, output sign if required and number
  //-------------------------------------------------------------
  DstIndex = DstOff;				// start from left
  if(SignChar != 0)				// output sign/blank
    pDstBuf[DstIndex++] = SignChar;
  while(DigitCnt != 0)
  {
    DigitCnt--;
    pDstBuf[DstIndex++] = AsciiNumBuf[DigitCnt];
  }
  pDstBuf[DstIndex] = 0;
  return(DstIndex - DstOff);
}

/** @} */


#endif //HL_CERT_CLIB
// end of file ../hclib/hstrhlp.cpp


#ifdef HL_CERT_CLIB
/** @defgroup hstring C String functions
* @ingroup util
* @brief A module for emulating various C style string functions.
*
* This module is used to emulate several C string functions both in Java and
* if they are not available for a certain platfrom.
* 
* Description of specific notations:
* <ul>
*  <li> ASCIIstring: a byte string containing ASCII characters (0x00-0x7F) and
*         Latin-1 extensions (0x80-0xFF).
*  <li> ASCIIz string: an ASCII string that is NUL (0x00) terminated.
*  <li> ASCII(z) string: an ASCII string that can be NUL (0x00) terminated but 
*         need not (the length must be specified then).
* </ul>
*@{
*@file
* This file implements several string routines, that act like C standard 
* functions of the same name. In these functions, character pointers are 
* replaced by <code>BIT8PTR</code> and an offset, to allow the use for both
* C and Java.
*@}
*/
//******************************************************************
//
// C-compatible String function library,
// Type Conversion functions
//
//******************************************************************
#if (defined _WIN32) & (_MSC_VER < 1700)
#ifndef _STDINT
#define _STDINT
// MSVC lower than 17.00 does not have stdint.h, assure, all needed types are defined

typedef unsigned __int16 uint16_t;

typedef unsigned __int32 uint32_t;

typedef unsigned __int64 uint64_t;

#endif // !_STDINT
#else
#include <stdint.h>
#endif
#include <stddef.h>
#ifdef _WIN32
#define WIN32_LEAN_AND_MEAN
#include <Windows.h>
#undef WIN32_LEAN_AND_MEAN
#else// Define system-specific HL_* defines here
#ifndef HL_UNIX
#define HL_UNIX

#if (defined __gnu_linux__) || (defined __linux__)
#define HL_LINUX
#endif

#if (defined __APPLE__) && (defined __MACH__)
#define HL_LINUX
#define HL_MACOS
#endif

#ifdef _AIX
#define HL_AIX
#define HL_BIG_ENDIAN
#endif

#ifdef __FreeBSD__
#define HL_FREEBSD
#endif

#if (defined _hpux) || (defined hpux) || (defined __hpux)
#define HL_HPUX
#define HL_BIG_ENDIAN
#endif

#if (defined sun) || (defined __sun)
#define HL_SOLARIS
#endif

#if (defined __arm__) || (defined __aarch64__)
#define HL_LINUX_ARM
#endif

#ifdef __ANDROID__
#define HL_ANDROID
#endif

#endif
#include <hob-unix01.h>
#endif
#ifdef __APPLE__
/* We get target conditionals to keep apart Mac OS, iOS and iOS simulator.
   The conditionals are TARGET_IPHONE_SIMULATOR, TARGET_OS_IPHONE and TARGET_OS_MAC.
   TARGET_IPHONE_SIMULATOR has the highest priority, TARGET_OS_MAC the lowest.
   Always test, if the conditional is 1, as they will be defined as 0, if we 
   are not compiling for the target.
   */
#include <TargetConditionals.h>
#endif

#ifdef HL_ANDROID
#include <netdb.h>
#include <unistd.h>
#include <linux/in.h>
#ifndef SOCKLEN_T
#define SOCKLEN_T      int
#endif
#ifndef SA_FAMILY_T
#define SA_FAMILY_T  short
#endif
#include <sys/endian.h>
#include <asm/ioctls.h>
#include <errno.h>
#endif

#include "hob-encry-1.h"
#include "hob-cert-ext.h"
#ifdef _WIN32
#include <winsock.h>
#endif
#include "hob-cert-err.h"
#include <string.h>
#include "hob-cert-intern.h"

#if defined _WIN32
#pragma warning(disable:4996)
#endif

#include <ctype.h>

/** @addtogroup hstring
* @{
*/

/**
* Copies memory to memory, until either specified character copied or
* specified size reached (Memccpy). The stop character will be the last to be copied.
*
*  @param pDstBuf Destination buffer
*  @param DstOff Start offset for writing
*  @param pSrcBuf Source buffer
*  @param SrcOff Start offset of data
*  @param StopChar Character to stop copy
*  @param CopyLen Length of data
*/
extern "C"  void  Memccpy(char* pDstBuf, int DstOff,
			        char* pSrcBuf, int SrcOff, int StopChar,
			        int CopyLen)
{
  memccpy(pDstBuf+DstOff,pSrcBuf+SrcOff, StopChar, CopyLen);
}

/**
* Finds a byte in the given memory buffer (Memchr). The parameter c is being cast
* to a single byte type for this.
*
*  @param pBuf Buffer to scan
*  @param Offset Start offset for scan
*  @param c Byte to scan for
*  @param FindLen Length of data to scan
*  @return Total offset (including initial offset) of the found byte, <0,
*          if the byte was not found.
*/
extern "C"  int  Memchr(char* pBuf, int Offset, int c, int FindLen)
{
  char* pEnd;
  if(FindLen <= 0)
    return(-1);

  pEnd = (char*) memchr(pBuf+Offset,c,FindLen);
  if(pEnd == NULL)
    return(-1);
  return((int) (pEnd-pBuf));
}

/**
* Compares two blocks of memory of equal length (Memcmp).
* Comparison is done on a byte by byte basis. The result is derived
* as follows:
* <ol>
* <li> Buffer contents are the same: Result = 0
* <li> Buffer contents are different:
*  <ul>
*    <li> if value of unsigned character in Buf1 is > Buf2: Result = +1
*    <li> if value of unsigned character in Buf1 is < Buf2: Result = -1
*  </ul>
* </ol>
*
*  @param pBuf1 Buffer 1
*  @param Buf1Off Start of data in buffer 1
*  @param pBuf2 Buffer 2
*  @param Buf2Off Start of data in buffer 2
*  @param DataLen Length of data
*  @return see description above
*/
extern "C"  int  Memcmp(char* pBuf1, int Buf1Off,
			      char* pBuf2, int Buf2Off, int DataLen)
{
  return(memcmp(pBuf1+Buf1Off,pBuf2+Buf2Off,DataLen));
}  

/**
* Copies memory to memory (Memcpy). 
* Wrapper routine for memcpy() in C and 
* System.arraycopy() in Java.
* 
* Note: For C, behaviour on overlapping source and destination is undefined.
*
*  @param pDstBuf Destination buffer
*  @param DstOff Start offset to write data
*  @param pSrcBuf Source buffer
*  @param SrcOff Start offset of input data
*  @param SrcLen Length of data
*/
extern "C"  void  Memcpy(char* pDstBuf, int DstOff,
			       char* pSrcBuf, int SrcOff, int SrcLen)
{
  memcpy(pDstBuf+DstOff,pSrcBuf+SrcOff,SrcLen);
}

/**
* Moves memory to memory (Memmove). 
* Wrapper routine for memmove() in C and
* System.arraycopy() in Java.
*
*  @param pDstBuf Destination buffer
*  @param DstOff Start offset to write data
*  @param pSrcBuf Source buffer
*  @param SrcOff Start offset of input data
*  @param SrcLen Length of data
*/
extern "C"  void  Memmove(char* pDstBuf, int DstOff,
			        char* pSrcBuf, int SrcOff, int SrcLen)
{
  memmove(pDstBuf+DstOff,pSrcBuf+SrcOff,SrcLen);
}

/**
* Fills memory with given byte (Memset). The first byte of c is used.
*
*  @param pBuf Destination buffer
*  @param Offset Start offset for writing
*  @param c Byte to set
*  @param BufLen Length to write
*/
extern "C"  void  Memset(char* pBuf, int Offset, int c, int BufLen)
{
  memset(pBuf+Offset,c,BufLen);
}

/**
* Gets the length of an ASCIIZ string (Strlen).
*
*  @param pBuf String buffer
*  @param Offset Start offset of data
*  @return Length of the string, without the terminating \0 byte.
*/
extern "C"  int  Strlen(char* pBuf, int Offset)
{
  if(pBuf == NULL)
    return(0);
  return((int) strlen(pBuf+Offset));
}

/**
* Converts a string to a double precision float value (Atof).
* NOTE: Java string parser does *not* accept the 'd' or 'D' Notation
*   for the eExponent, must be converted to 'E'before parsing.
*
*  @param pBuf String buffer
*  @param Offset Start offset of data
*  @return Converted double value, 0.0 if not convertable
*/
extern "C"  double  Atof(char* pBuf, int Offset)
{
  return(atof(pBuf+Offset));
}

/**
* Converts a string to an int value (Atoi).
*
*  @param pBuf String buffer
*  @param Offset Start offset of data
*  @return Converted int value, 0 if not convertable
*/
extern "C"  int  Atoi(char* pBuf, int Offset)
{
  return(atoi(pBuf+Offset));
}

/**
* Converts a string to a 32 bit integer value (Atol).
*
*  @param pBuf String buffer
*  @param Offset Start offset of data
*  @return Converted 32 bit value, 0 if not convertable
*/
extern "C"  int  Atol(char* pBuf, int Offset)
{
  return(atol(pBuf+Offset));
}

/**
* Concatenates two ASCIIz strings, not size limited (Strcat).
* The designated source buffer is appended to the string in the designated
* destination buffer.
*
* NOTE: This is highly risky with C-Runtime
*
*  @param pDstBuf 1st source, destination buffer
*  @param DstOff Start offset of data in destination buffer
*  @param pSrcBuf 2nd source to append
*  @param SrcOff Start offset of data in source buffer
*/
extern "C"  void  Strcat(char* pDstBuf, int DstOff,
			       char* pSrcBuf, int SrcOff)
{
  strcat(pDstBuf+DstOff,pSrcBuf+SrcOff);
}

/**
* Concatenates ASCIIz strings, the size of the string to append is limited (Strncat).
* The designated source buffer is appended to the string in the designated
* destination buffer.
*
* NOTE: This is potentially risky with C-Runtime
*
*  @param pDstBuf 1st source, destination buffer
*  @param DstOff Start offset of data in destination buffer
*  @param pSrcBuf 2nd source to append
*  @param SrcOff Start offset of data in source buffer
*  @param AppendLen Maximum size to append
*  @return Total length of the new string in the destination buffer
*/
extern "C"  int  Strncat(char* pDstBuf, int DstOff,
			       char* pSrcBuf, int SrcOff, int AppendLen)
{
  strncat(pDstBuf+DstOff,pSrcBuf+SrcOff,AppendLen);
  return((int) strlen(pDstBuf+DstOff));
}

/**
* Copies an ASCIIz string, not size limited (Strcpy).
*
* NOTE: This is highly risky with C-Runtime
*
*  @param pDstBuf Destination buffer
*  @param DstOff Start offset for writing
*  @param pSrcBuf Source to copy
*  @param SrcOff Start offset of data
*/
extern "C"  void  Strcpy(char* pDstBuf, int DstOff,
			       char* pSrcBuf, int SrcOff)
{
  strcpy(pDstBuf+DstOff,pSrcBuf+SrcOff);
}

/**
* Copies an ASCIIz string, size limited (Strncpy).
*
* NOTE: This is potentially risky with C-Runtime !!
*
*  @param pDstBuf Destination buffer
*  @param DstOff Start offset for writing
*  @param pSrcBuf Source to copy
*  @param SrcOff Start offset of data
*  @param BufLen Maximum bytes to copy
*  @return Number of copied bytes
*/
extern "C"  int  Strncpy(char* pDstBuf, int DstOff,
			       char* pSrcBuf, int SrcOff, int BufLen)
{
  strncpy(pDstBuf+DstOff,pSrcBuf+SrcOff,BufLen);
//  return(strlen(pDstBuf));
  if(pDstBuf[DstOff+BufLen-1] != 0)		// no NULL appended !!!
    return(BufLen);
  else
    return((int) strlen(pDstBuf+DstOff));	// do NOT include previous!
}

/**
* Scans an ASCIIz string for first occurance of given byte (from left) (Strchr).
* Note: The character to scan for may be the NUL character, as the
*   delimiting NUL character is included in the scan.
*
*  @param pBuf Data buffer
*  @param Offset Start offset of data
*  @param c Byte to search for
*  @return Absolute offset (including starting offset) of the found byte, <0,
*          if the byte wasn't found
*/
extern "C"  int  Strchr(char* pBuf, int Offset, int c)
{
  char* pEnd;

  pEnd = strchr(pBuf+Offset,c);
  if(pEnd == NULL)
    return(-1);
  return((int) (pEnd - pBuf));

}

/**
* Scans an ASCIIz string for last occurance of given byte (from right) (Strrchr).
* Note: The character to scan for may be the NUL character, as the
*  delimiting NUL character is included in the scan.
*
*  @param pBuf Data buffer
*  @param Offset Start offset of data
*  @param c Byte to search for
*  @return Absolute offset (including starting offset) of the found byte, <0,
*          if the byte wasn't found
*/
extern "C"  int  Strrchr(char* pBuf, int Offset, int c)
{
  char* pEnd;

  pEnd = strrchr(pBuf+Offset,c);
  if(pEnd == NULL)
    return(-1);
  return((int) (pEnd - pBuf));

}

/**
* Compares two ASCIIz strings for equality (Strcmp).
* Note: Comparison is done on pure binary representation of characters:
* <ol>
*  <li> Both strings are identical: Result = 0; this includes
*	    the case of both strings empty.
*	<li> Numeric difference of first *NON* identical characters from
*	    String1 and String2 defines relationship:
*     <ul>
*	    <li> If String1 Character is > String2 character: Result = +1
*	    <li> If String1 Character is < String2 character: Result = -1
*     </ul>
*	<li> If one of the Strings is empty *OR* is a NULL ptr:
*     <ul>
*	    <li> If String1 is empty/NULL: Result = -1
*	    <li> If String2 is empty/NULL: Result = +1
*     </ul>
* </ol>
*
*  @param pStr1 1st string buffer
*  @param Str1Off Start offset of 1st string data
*  @param pStr2 2nd string buffer
*  @param Str2Off Start offset of 2nd string data
*  @return Result as defined above
*/
extern "C"  int  Strcmp(char* pStr1, int Str1Off,
			      char* pStr2, int Str2Off)
{
  return(strcmp(pStr1+Str1Off, pStr2+Str2Off));
}
/**
* Compares two ASCIIz strings for equality, size limited (Strncmp).
*
* Note: For comparison algorithm see Strcmp routine.
*
*  @param pStr1 1st string buffer
*  @param Str1Off Start offset of 1st string data
*  @param pStr2 2nd string buffer
*  @param Str2Off Start offset of 2nd string data
*  @param MaxCmpLen Maximum number of compared bytes
*  @return int Result, 0 - same, 1 - 1st > 2nd, -1 - 1st < 2nd
*/
extern "C"  int  Strncmp(char* pStr1, int Str1Off,
			       char* pStr2, int Str2Off, int MaxCmpLen)
{
  return(strncmp(pStr1+Str1Off, pStr2+Str2Off, MaxCmpLen));
}
/**
* Duplicates an ASCIIz string (Strdup).
* Note: 
* <ol>
*  <li> If the given String is a NULL ptr no memory is allocated.
*  <li> If the given String is Empty, an empty String is returned.
* </ol>
*
*  @param pStr Base of string buffer
*  @param Offset Start offset of data
*  @return BIT8PTR pStrCopy / NULL
*/
extern "C"  char*  Strdup(HMEM_CTX_DEF
				  char* pStr, int Offset)
{
  int BufLen;
  char* pNewBuf;

  if(pStr == NULL)
    return(NULL);
  BufLen = (int) strlen(pStr+Offset)+1;
  if(BufLen <= 0)
    return(NULL);
  if((pNewBuf = BIT8_ARRAY_ALLOC(HMEM_CTX_REF,BufLen)) == NULL)
    return(NULL);
  memcpy(pNewBuf,pStr+Offset,BufLen);
  pNewBuf[BufLen-1] = 0;
  return(pNewBuf);

}

/**
* Finds the length of a substring in the given string terminated by
* any byte in the given delimiter set (Strcspn).
*
* NOTE: String delimiting NUL characters are not included in search.
*   The delimiter set must be NUL terminated.
*
*  @param pStr Base of string buffer
*  @param StrOff Start offset of string data
*  @param pDelim Base of delimiting alphabet
*  @param DelimOff Start offset of delimiter data
*  @return Length of the substring, excluding the found delimiter byte
*/
extern "C"  int  Strcspn(char* pStr, int StrOff,
			       char* pDelim, int DelimOff)
{
  return((int) strcspn(pStr+StrOff, pDelim+DelimOff));
}

/**
* Finds the length of a substring in the given string terminated by
* any byte NOT in the given allowed set (Strspn).
*
* NOTE: String delimiting NUL characters are not included in search.
*   The allowed set must be NUL terminated.
*
*  @param pStr Base of string buffer
*  @param StrOff Start offset of string data
*  @param pAllowed Base of allowed alphabet
*  @param AllowedOff Start offset of allowed data
*  @return Length of the substring, excluding the first found non-allowed byte
*/
extern "C"  int  Strspn(char* pStr, int StrOff,
			      char* pAllowed, int AllowedOff)
{
  return((int) strspn(pStr+StrOff, pAllowed+AllowedOff));
}

/**
* Finds start position of substring in given string defined by
* character in given selection set (Strpbrk).
*
* NOTE: String delimiting NUL characters are not included in search
*    The selection set must be NUL terminated.
*
*  @param pStr Base of string buffer
*  @param StrOff Start offset of string data
*  @param pSel Base of selection alphabet
*  @param SelOff Start offset of selection data
*  @return Total offset (including StrOff) of the first found selection byte,
*          <0, if none was found.
*/
extern "C"  int  Strpbrk(char* pStr, int StrOff,
			       char* pSel, int SelOff)
{
  char* pEnd;
  pEnd = strpbrk(pStr+StrOff, pSel+SelOff);
  if(pEnd == NULL)
    return(-1);
  return((int) (pEnd - pStr));
}

/**
* Finds the start position of the first occurence of given substring in
* the given string (Strstr).
*
*  @param pStr Base of string buffer
*  @param StrOff Start offset of string data
*  @param pSub Base of substring
*  @param SubOff Start offset of substring data
*  @return Total offset (including StrOff) of the start of the substring,
*          <0, if it wasn't found.
*/
extern "C"  int  Strstr(char* pStr, int StrOff,
			      char* pSub, int SubOff)
{
  char* pEnd;
  pEnd = strstr(pStr+StrOff, pSub+SubOff);
  if(pEnd == NULL)
    return(-1);
  return((int) (pEnd - pStr));
}

/**
* Finds the start position of first occurence of a token, skips
* leading delimiters specified from given delimiter det (Strtok).
*
* NOTE: This routine does *NOT* use static buffers for next token
* ----- search as used with the C-Library.
*
*
*  @param pStr Base of string buffer
*  @param StrOff Start offset of string data
*  @param pDelim Base of delimiter alphabet
*  @param DelimOff Start offset of delimiter data
*  @return Total offset (including StrOff) of the first found token,
*          <0, if none was found.
*/
extern "C"  int  Strtok(char* pStr, int StrOff,
			      char* pDelim, int DelimOff)
{
  char c;
  int StrLen, ScanIndex, DelimLen, DelimIndex, Count;
  //------------------------------------------------------------
  // get size of String to parse, check special conditions first
  //------------------------------------------------------------
  if((pStr == NULL) || ((StrLen = Strlen(pStr, StrOff)) == 0))
    return(-1);
  //------------------------------------------------------------
  // get size of Delimiter Alphabet, check special conditions
  //------------------------------------------------------------
  if((pDelim == NULL) || ((DelimLen = Strlen(pDelim, DelimOff)) == 0))
    return(StrOff);				// Cannot search...
  //------------------------------------------------------------
  // Skip all leading bytes that are Delimiter String elements
  //------------------------------------------------------------
  ScanIndex = StrOff;
  while(StrLen != 0)
  {
    //-------------------------------------------------------
    // Check for a skip 'Delimiter' character match
    //-------------------------------------------------------
    c = pStr[ScanIndex];		// get 1st character to compare to
    ScanIndex++;
    StrLen--;
    if(c == pDelim[DelimOff])		// does match a skip value...
      continue;
    //-------------------------------------------------------
    // 1st character is *NOT* a first match, check the rest
    //-------------------------------------------------------
    Count = DelimLen-1;			// setup compare size excl. 1st char.
    if(Count == 0)			// single character compare !
      return(ScanIndex-1);		// report start of match

    DelimIndex = DelimOff+1;		// setup Start of Array excl. 1st char.
    do
    {
      if(c == pDelim[DelimIndex])	// same as delimiter, try next from source
        break;
      DelimIndex++;			// to next Delimiter character
      Count--;
    }while(Count != 0);
    if(Count == 0)			// is *NOT* a character to skip
      return(ScanIndex-1);		// report start of match
  }
  //---------------------------------------------------------
  // no start found
  //---------------------------------------------------------
  return(-1);
}

//*******************************************************************
//
// Type conversion routines
//
//*******************************************************************

/**
* Converts 'character' to lower case (To_Lower).
*
*  @param c Character to convert
*  @return Character in lower case
*/
extern "C"  int  To_Lower(int c)
{
  return(tolower(c));
}

/**
* Converts 'character' to upper case (To_Upper).
*
*  @param c Character to convert
*  @return Character in upper case
*/
extern "C"  int  To_Upper(int c)
{
  return(toupper(c));
}

/**
* Converts an ASCIIz string completely to lower case (Strlower).
* The source string is overwritten.
*
*  @param pStr Base of string buffer
*  @param StrOff Start offset of string data
*/
extern "C"  void  Strlower(char* pStr, int StrOff)
{
  int StrLen;
  //------------------------------------------------------------
  // get size of String to parse, check special conditions first
  //------------------------------------------------------------
  StrLen = Strlen(pStr, StrOff);
  while(StrLen != 0)
  {
    pStr[StrOff] = (unsigned char) To_Lower((int) pStr[StrOff] & 0xFF);
    StrOff++;
    StrLen--;
  }
}

//*******************************************************************
//
// ASCII Type recognition routines
//
//*******************************************************************

/**
* Checks, if character is ASCII Alpha-Numeric ('A'-'Z', 'a'-'z', '0'-'9') (IsAlnum).
*
*  @param c Character to check
*  @return 0, if it is not of that type, <>0 if it is
*/
extern "C"  int  IsAlnum(int c)
{
  return(isalnum(c));
}

/**
* Checks, if character is ASCII Alpha, i.e. 'A'-'Z', 'a'-'z' (IsAlpha).
*
*  @param c Character to check
*  @return 0, if it is not of that type, <>0 if it is
*/
extern "C"  int  IsAlpha(int c)
{
  return(isalpha(c));
}

/**
* Checks if character is an ASCII character (0x00-0x7F)(IsAscii).
*
*  @param c Character to check
*  @return 0, if it is not of that type, <>0 if it is
*/
extern "C"  int  IsAscii(int c)
{
  return(isascii(c));
}

/**
* Checks, if character is ASCII control, i.e. 0x00-0x1F, 0x7F (IsCntrl).
*
*  @param c Character to check
*  @return 0, if it is not of that type, <>0 if it is
*/
extern "C"  int  IsCntrl(int c)
{
  return(iscntrl(c));
}

/**
* Checks, if character is ASCII digit, i.e. '0'-'9' (IsDigit).
*
*  @param c Character to check
*  @return 0, if it is not of that type, <>0 if it is
*/
extern "C"  int  IsDigit(int c)
{
  return(isdigit(c));
}

/**
* Checks, if character is ASCII printable except space, i.e. 0x21-0x7E (IsGraph).
*
*  @param c Character to check
*  @return 0, if it is not of that type, <>0 if it is
*/
extern "C"  int  IsGraph(int c)
{
  return(isgraph(c));
}

/**
* Checks, if character is ASCII lower case, i.e. 'a'-'z' (IsLower).
*
*  @param c Character to check
*  @return 0, if it is not of that type, <>0 if it is
*/
extern "C"  int  IsLower(int c)
{
  return(islower(c));
}

/**
* Checks, if character is ASCII printable, i.e. 0x20-0x7E (IsPrint).
*
*  @param c Character to check
*  @return 0, if it is not of that type, <>0 if it is
*/
extern "C"  int  IsPrint(int c)
{
  return(isprint(c));
}

/**
* Checks, if character is ASCII punctuation, i.e. 0x21-0x2F,
* 0x3A-0x40, 0x5B-0x60, 0x7B-0x7E (IsPunct).
*
*  @param c Character to check
*  @return 0, if it is not of that type, <>0 if it is
*/
extern "C"  int  IsPunct(int c)
{
  return(ispunct(c));
}

/**
* Checks, if character is ASCII whitespace, i.e. 0x09-0x0D, 0x20 (IsSpace).
*
*  @param c Character to check
*  @return 0, if it is not of that type, <>0 if it is
*/
extern "C"  int  IsSpace(int c)
{
  return(isspace(c));
}

/**
* Checks, if character is ASCII upper case, i.e. 'A'-'Z' (IsUpper).
*
*  @param c Character to check
*  @return 0, if it is not of that type, <>0 if it is
*/
extern "C"  int  IsUpper(int c)
{
  return(isupper(c));
}

/**
* Checks, if character is ASCII hex-digit, i.e. '0'-'9','A'-'F', 'a'-'f' (IsXdigit).
*
*  @param c Character to check
*  @return 0, if it is not of that type, <>0 if it is
*/
extern "C"  int  IsXdigit(int c)
{
  return(isxdigit(c));
}

/** @} */

#endif //HL_CERT_CLIB
// end of file ../hclib/hstring.cpp


#ifdef HL_CERT_OCSP
//********************************************************************
//
// OCSP ASN.1 processing module
// - generates OCSP-Request data, also signed if requested
// - decodes OCSP-Response data
//
// Date:    2004/05/04
// Version: 1.0
// Author:  G.Oed, HOB
// (C):     HOB GmbH & Co. KG, Cadolzburg, Germany
//
//********************************************************************
//#include <basetype.h>
/** @defgroup hocsp OCSP processing
* This module generates OCSP requests and processes responses.
*
* @{
* @file
* This file implements the OCSP request generation and response processing.
* @}
*/
#if (defined _WIN32) & (_MSC_VER < 1700)
#ifndef _STDINT
#define _STDINT
// MSVC lower than 17.00 does not have stdint.h, assure, all needed types are defined

typedef unsigned __int16 uint16_t;

typedef unsigned __int32 uint32_t;

typedef unsigned __int64 uint64_t;

#endif // !_STDINT
#else
#include <stdint.h>
#endif
#include <stddef.h>
#ifdef _WIN32
#define WIN32_LEAN_AND_MEAN
#include <Windows.h>
#undef WIN32_LEAN_AND_MEAN
#else// Define system-specific HL_* defines here
#ifndef HL_UNIX
#define HL_UNIX

#if (defined __gnu_linux__) || (defined __linux__)
#define HL_LINUX
#endif

#if (defined __APPLE__) && (defined __MACH__)
#define HL_LINUX
#define HL_MACOS
#endif

#ifdef _AIX
#define HL_AIX
#define HL_BIG_ENDIAN
#endif

#ifdef __FreeBSD__
#define HL_FREEBSD
#endif

#if (defined _hpux) || (defined hpux) || (defined __hpux)
#define HL_HPUX
#define HL_BIG_ENDIAN
#endif

#if (defined sun) || (defined __sun)
#define HL_SOLARIS
#endif

#if (defined __arm__) || (defined __aarch64__)
#define HL_LINUX_ARM
#endif

#ifdef __ANDROID__
#define HL_ANDROID
#endif

#endif
#include <hob-unix01.h>
#endif
#ifdef __APPLE__
/* We get target conditionals to keep apart Mac OS, iOS and iOS simulator.
   The conditionals are TARGET_IPHONE_SIMULATOR, TARGET_OS_IPHONE and TARGET_OS_MAC.
   TARGET_IPHONE_SIMULATOR has the highest priority, TARGET_OS_MAC the lowest.
   Always test, if the conditional is 1, as they will be defined as 0, if we 
   are not compiling for the target.
   */
#include <TargetConditionals.h>
#endif

#ifdef HL_ANDROID
#include <netdb.h>
#include <unistd.h>
#include <linux/in.h>
#ifndef SOCKLEN_T
#define SOCKLEN_T      int
#endif
#ifndef SA_FAMILY_T
#define SA_FAMILY_T  short
#endif
#include <sys/endian.h>
#include <asm/ioctls.h>
#include <errno.h>
#endif

#include "hob-encry-1.h"
#include "hob-cert-ext.h"
#ifdef _WIN32
#include <winsock.h>
#endif
#include "hob-cert-err.h"
#include <string.h>
#include "hob-cert-intern.h"
#include "hob-cert-err.h"

//()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()
//
// Control Structures from X.509 certificates / extensions
//
//()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()
/** @addtogroup hocsp
* @{
* @file
* This file contains macros and definitions for cotnrolling ASN.1 processing
* of OCSP messages.
* @}
*/

//--------------------------------------------------------------------
// OCSP Hash OID definitions
//--------------------------------------------------------------------
static  char OCSP_Sha1HashOID[5] = {
  (unsigned char) 0x2B, (unsigned char) 0x0E, (unsigned char) 0x03, (unsigned char) 0x02,
  (unsigned char) 0x1A
};

//--------------------------------------------------------------------
// OCSP OID definitions
//--------------------------------------------------------------------

static  char OCSPBasicRespBaseOID[9] = {
  (unsigned char) 0x2B, (unsigned char) 0x06, (unsigned char) 0x01, (unsigned char) 0x05,
  (unsigned char) 0x05, (unsigned char) 0x07, (unsigned char) 0x30, (unsigned char) 0x01,
  (unsigned char) 0x01,
};

static  char OCSPNonceBaseOID[9] = {
  (unsigned char) 0x2B, (unsigned char) 0x06, (unsigned char) 0x01, (unsigned char) 0x05,
  (unsigned char) 0x05, (unsigned char) 0x07, (unsigned char) 0x30, (unsigned char) 0x01,
  (unsigned char) 0x02,
};

//====================================================================
//
// X.509 Extension basic structure
// from/to X.509 Extension PDU <-> extnID, critical, extnValue
//
//====================================================================
unsigned char OCSP_ExtCtl[(4 * HDR_ENTRY_SIZE)]={

						// L1 SEQ: Extension PDU
 (unsigned char) (X_ONLY | CONSTRUCT),
 (unsigned char) (ASN1_UNIVERSAL_SEQUENCE | ASN1_CONSTRUCTED),
 (unsigned char) 0x00,
 (unsigned char) 0x00,
 //------------------------------------------------------------------
 // 1. Extension ID: OBJECT IDENTIFIER
 //------------------------------------------------------------------
						// L2 OID: extnID
						// DataIndex: 0
 (unsigned char) (X_FIRST | DATA_INDEX),
 (unsigned char) (ASN1_UNIVERSAL_OBJECT_ID),
 (unsigned char) 0,
 (unsigned char) 0x00,

 //------------------------------------------------------------------
 // 2. Critical Flag: BOOLEAN
 //------------------------------------------------------------------
						// L2 BOOL: critical
						// DataIndex: 1
 (unsigned char) (X_MIDDLE | DATA_INDEX | OPTIONAL),
 (unsigned char) (ASN1_UNIVERSAL_BOOLEAN),
 (unsigned char) 1,
 (unsigned char) 0x00,

 //------------------------------------------------------------------
 // 3. Extension value: OCTET STRING
 //------------------------------------------------------------------
						// L2 OCTET: extnValue
						// DataIndex: 2
 (unsigned char) (X_LAST | DATA_INDEX),
 (unsigned char) (ASN1_UNIVERSAL_OCTETSTRING),
 (unsigned char) 2,
 (unsigned char) 0x00,
};

//()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()
//
// General OCSP Control structures
//
//()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()

//====================================================================
// CertID structure, used in OCSP-Request and OCSP-Response,
// from/to OCSP CertID PDU <->HashAlgor, IssuerNameHash, IssuerKeyHash
//                            CertSerialNumber
// Note: HashAlgor is processed and split deeper
// -----
//
//====================================================================
unsigned char OCSP_CertIDCtl[(7 * HDR_ENTRY_SIZE)]={

						// L1 SEQ: CertID PDU
 (unsigned char) (X_ONLY | CONSTRUCT),
 (unsigned char) (ASN1_UNIVERSAL_SEQUENCE | ASN1_CONSTRUCTED),
 (unsigned char) 0x00,
 (unsigned char) 0x00,
 //------------------------------------------------------------------
 // 1. Hash algorithm identifier: SEQUENCE
 //------------------------------------------------------------------
						// L2 SEQ: hashAlgorithm
 (unsigned char) (X_FIRST | CONSTRUCT),
 (unsigned char) (ASN1_UNIVERSAL_SEQUENCE | ASN1_CONSTRUCTED),
 (unsigned char) 0x00,
 (unsigned char) 0x00,
 //------------------------------------------------------------------
 // 1.1. Hash algorithm 'algorithm': OID
 //------------------------------------------------------------------
						// L3 OID: algorithm
						// DataIndex: 0
 (unsigned char) (X_FIRST | DATA_INDEX),
 (unsigned char) (ASN1_UNIVERSAL_OBJECT_ID),
 (unsigned char) 0,
 (unsigned char) 0x00,
 //------------------------------------------------------------------
 // 1.2. Hash algorithm 'parameters': ANY
 //------------------------------------------------------------------
						// L3 ANY: params
						// DataIndex: 1
 (unsigned char) (X_LAST | DATA_INDEX | ANY_ASN1 | OPTIONAL),
 (unsigned char) (ASN1_UNIVERSAL_EOC),
 (unsigned char) 1,
 (unsigned char) 0x00,
 //------------------------------------------------------------------
 // 2. Hash of issuer's DN: OCTESTSTR
 //------------------------------------------------------------------
						// L2 OCT: issuerNameHash
						// DataIndex: 2
 (unsigned char) (X_MIDDLE | DATA_INDEX),
 (unsigned char) (ASN1_UNIVERSAL_OCTETSTRING),
 (unsigned char) 2,
 (unsigned char) 0x00,
 //------------------------------------------------------------------
 // 3. Hash of issuer's public key: OCTESTSTR
 //------------------------------------------------------------------
						// L2 OCT: issuerKeyHash
						// DataIndex: 3
 (unsigned char) (X_MIDDLE | DATA_INDEX),
 (unsigned char) (ASN1_UNIVERSAL_OCTETSTRING),
 (unsigned char) 3,
 (unsigned char) 0x00,
 //------------------------------------------------------------------
 // 4. Certificate's serial number: INT
 //------------------------------------------------------------------
						// L2 INT: serialNumber
						// DataIndex: 4
 (unsigned char) (X_LAST | DATA_INDEX | ZERO_LEAD_FLAG),
 (unsigned char) (ASN1_UNIVERSAL_INTEGER),
 (unsigned char) 4,
 (unsigned char) 0x00,
};

//()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()
//
// OCSP Control structures used in requests only
//
//()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()

//====================================================================
// Signature structure, optionally used in OCSP-Request only,
// from/to OCSP Request signature PDU <-> signatAlgor, signature, certs
// Note: signatAlgor is processed and split deeper
// -----
//
//====================================================================
unsigned char OCSP_ReqSignatCtl[(7 * HDR_ENTRY_SIZE)]={

						// L1 SEQ: Signature PDU
 (unsigned char) (X_ONLY | CONSTRUCT),
 (unsigned char) (ASN1_UNIVERSAL_SEQUENCE | ASN1_CONSTRUCTED),
 (unsigned char) 0x00,
 (unsigned char) 0x00,
 //------------------------------------------------------------------
 // 1. Signature algorithm: SEQUENCE
 //------------------------------------------------------------------
						// L2 SEQ: signatureAlgorithm
 (unsigned char) (X_FIRST | CONSTRUCT),
 (unsigned char) (ASN1_UNIVERSAL_SEQUENCE | ASN1_CONSTRUCTED),
 (unsigned char) 0x00,
 (unsigned char) 0x00,
 //------------------------------------------------------------------
 // 1.1. Signature algorithm's 'algorithm': OID
 //------------------------------------------------------------------
						// L3 OID: algorithm
						// DataIndex: 0
 (unsigned char) (X_FIRST | DATA_INDEX),
 (unsigned char) (ASN1_UNIVERSAL_OBJECT_ID),
 (unsigned char) 0,
 (unsigned char) 0x00,
 //------------------------------------------------------------------
 // 1.2. Signature algorithm's 'parameters': ANY
 //------------------------------------------------------------------
						// L3 ANY: params
						// DataIndex: 1
 (unsigned char) (X_LAST | DATA_INDEX | ANY_ASN1 | OPTIONAL),
 (unsigned char) (ASN1_UNIVERSAL_EOC),
 (unsigned char) 1,
 (unsigned char) 0x00,
 //------------------------------------------------------------------
 // 2. Signature: BITSTRING (NOTE: must have ZERO LEAD set !!)
 //------------------------------------------------------------------
						// L2 BITST: Signature
						// DataIndex: 2
 (unsigned char) (X_MIDDLE | DATA_INDEX | ZERO_LEAD_FLAG),
 (unsigned char) (ASN1_UNIVERSAL_BITSTRING),
 (unsigned char) 2,
 (unsigned char) 0x00,

 //------------------------------------------------------------------
 // 3. Certificates: ETAG[0], optional
 //------------------------------------------------------------------
						// L2 ETAG[0]: certs
 (unsigned char) (X_LAST | CONSTRUCT | OPTIONAL | DATA_INDEX),
 (unsigned char)	(ASN1_CLASS_CONTEXT_SPECIFIC | ASN1_CONSTRUCTED | 0x00),
 (unsigned char) 3,
 (unsigned char) 0x00,
 //------------------------------------------------------------------
 // 3.1. Certificate list: SEQUENCE
 //------------------------------------------------------------------
						// L3 SEQ: Certificates
						// DataIndex: 3
 (unsigned char) (X_ONLY | DATA_INDEX),
 (unsigned char) (ASN1_UNIVERSAL_SEQUENCE | ASN1_CONSTRUCTED),
 (unsigned char) 3,
 (unsigned char) 0x00,
};

//====================================================================
// Request structure used for a single element from a request list
// from/to an OCSP single 'Request' PDU <-> CertID, singleRequestExtensions
// Note: This is only used to construct OCSP-Requests, so no element
// ----- checking is needed
//
//
//====================================================================
unsigned char OCSP_SingleReqCtl[(3 * HDR_ENTRY_SIZE)]={

						// L1 SEQ: [single]Request
 (unsigned char) (X_ONLY | CONSTRUCT),
 (unsigned char) (ASN1_UNIVERSAL_SEQUENCE | ASN1_CONSTRUCTED),
 (unsigned char) 0x00,
 (unsigned char) 0x00,
 //------------------------------------------------------------------
 // 1. Certificate Identification: CertID, pre-encoded data
 //------------------------------------------------------------------
						// L2 ANY: CertID
						// DataIndex: 0
 (unsigned char) (X_FIRST | DATA_INDEX | ANY_ASN1),
 (unsigned char) (ASN1_UNIVERSAL_EOC),
 (unsigned char) 0,
 (unsigned char) 0x00,
 //------------------------------------------------------------------
 // 2. Single request's extensions: ETAG[0], optional
 //------------------------------------------------------------------
						// L2 ETAG[0]: extensions
						// DataIndex: 1
 (unsigned char) (X_LAST | DATA_INDEX | ANY_ASN1 | OPTIONAL),
 (unsigned char)	(ASN1_CLASS_CONTEXT_SPECIFIC | ASN1_CONSTRUCTED | 0x00),
 (unsigned char) 1,
 (unsigned char) 0x00,
};

//====================================================================
// To be signed Request structure, used in OCSP-Request only 
// from/to an tbsRequest PDU <-> version, requestorName,requestList,
//				 requestExtensions
//
//====================================================================
unsigned char OCSP_TbsReqCtl[(6 * HDR_ENTRY_SIZE)]={

						// L1 SEQ: OCSPRequest
 (unsigned char) (X_ONLY | CONSTRUCT),
 (unsigned char) (ASN1_UNIVERSAL_SEQUENCE | ASN1_CONSTRUCTED),
 (unsigned char) 0x00,
 (unsigned char) 0x00,
 //------------------------------------------------------------------
 // 1. Version number, needs only be present if non Default v1: ETAG[0]
 //------------------------------------------------------------------
						// L2 ETAG[0]: version
						// DataIndex: 0
 (unsigned char) (X_FIRST | DATA_INDEX | OPTIONAL),
 (unsigned char)	(ASN1_CLASS_CONTEXT_SPECIFIC | ASN1_CONSTRUCTED | 0x00),
 (unsigned char) 0,
 (unsigned char) 0x00,
 //------------------------------------------------------------------
 // 2. Requestor's name, optional: ETAG[1]
 //------------------------------------------------------------------
						// L2 ETAG[1]: requestorName
						// DataIndex: 1
 (unsigned char) (X_MIDDLE | DATA_INDEX | OPTIONAL),
 (unsigned char)	(ASN1_CLASS_CONTEXT_SPECIFIC | ASN1_CONSTRUCTED | 0x01),
 (unsigned char) 1,
 (unsigned char) 0x00,
 //------------------------------------------------------------------
 // 3. List of Request: SEQUENCE
 //------------------------------------------------------------------
						// L2 SEQ: requestList
						// DataIndex: 2
 (unsigned char) (X_MIDDLE | DATA_INDEX | ANY_ASN1),
 (unsigned char)	(ASN1_UNIVERSAL_SEQUENCE | ASN1_CONSTRUCTED),
 (unsigned char) 2,
 (unsigned char) 0x00,
 //------------------------------------------------------------------
 // 4. Request extensions (for all), optional: ETAG[2]
 //------------------------------------------------------------------
						// L2 ETAG[2]: requestExtensions
						// DataIndex: 3
 (unsigned char) (X_LAST | DATA_INDEX | OPTIONAL | CONSTRUCT),
 (unsigned char)	(ASN1_CLASS_CONTEXT_SPECIFIC | ASN1_CONSTRUCTED | 0x02),
 (unsigned char) 3,
 (unsigned char) 0x00,

						// L3 SEQ: List of Extensions
						// DataIndex: 3
 (unsigned char) (X_ONLY | DATA_INDEX),
 (unsigned char) (ASN1_UNIVERSAL_SEQUENCE | ASN1_CONSTRUCTED),
 (unsigned char) 3,
 (unsigned char) 0x00,

};

//====================================================================
// The OCSP request structure in total,
// from/to an OCSPRequest PDU <-> tbsRequest, optionalSignature
//
//====================================================================
unsigned char OCSP_ReqCtl[(3 * HDR_ENTRY_SIZE)]={

						// L1 SEQ: OCSPRequest
 (unsigned char) (X_ONLY | CONSTRUCT),
 (unsigned char) (ASN1_UNIVERSAL_SEQUENCE | ASN1_CONSTRUCTED),
 (unsigned char) 0x00,
 (unsigned char) 0x00,
 //------------------------------------------------------------------
 // 1. To be signed request: tbsRequest
 //------------------------------------------------------------------
						// L2 ANY: tbsRequest 
						// DataIndex: 0
 (unsigned char) (X_FIRST | DATA_INDEX | ANY_ASN1),
 (unsigned char) (ASN1_UNIVERSAL_EOC),
 (unsigned char) 0,
 (unsigned char) 0x00,
 //------------------------------------------------------------------
 // 2. Optional signature: Signature
 //------------------------------------------------------------------
						// ETAG[0]: Signature
						// DataIndex: 1
 (unsigned char) (X_LAST | DATA_INDEX | OPTIONAL),
 (unsigned char)	(ASN1_CLASS_CONTEXT_SPECIFIC | ASN1_CONSTRUCTED | 0x00),
 (unsigned char) 1,
 (unsigned char) 0x00,
};

//()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()
//
// OCSP Control structures used in responses only
//
//()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()

//====================================================================
// Single response structure, used in OCSP-Response only,
// from/to OCSP SingleResponse PDU <-> certID, certStatus, thisUpdate,
//				       nextUpdate, singleExtensions
// NOTE: this is ONLY used for decoding
// -----
//
//====================================================================
unsigned char OCSP_SingleRespCtl[(13 * HDR_ENTRY_SIZE)]={

						// L1 SEQ: SingleResponse 
 (unsigned char) (X_ONLY | CONSTRUCT),
 (unsigned char) (ASN1_UNIVERSAL_SEQUENCE | ASN1_CONSTRUCTED),
 (unsigned char) 0x00,
 (unsigned char) 0x00,
 //------------------------------------------------------------------
 // 1. Certificate's ID: certID
 //------------------------------------------------------------------
						// L2 SEQ: CertID 
						// DataIndex: 0, with header
 (unsigned char) (X_FIRST | DATA_INDEX | ANY_ASN1),
 (unsigned char) (ASN1_UNIVERSAL_EOC),
 (unsigned char) 0,
 (unsigned char) 0x00,
 //------------------------------------------------------------------
 // 2. Certificate's status reported: certStatus
 //    NOTE: As there are implict tagged NULL objects possible,
 //    ----- the headers MUST also be stored, to allow presence
 //	     recognition (either sizes would be 0 ...)
 //------------------------------------------------------------------
 //------------------------------------------------------------------
 // 2.1. Good information: IMPLICIT NULL
 //------------------------------------------------------------------
						// L2 ITAG[0]: good
						// DataIndex: 1, with header
 (unsigned char) (X_MIDDLE | DATA_INDEX | ANY_ASN1 | MUST_MATCH | OPTIONAL),
 (unsigned char)	(ASN1_CLASS_CONTEXT_SPECIFIC | 0x00),
 (unsigned char) 1,
 (unsigned char) 0x00,
 //------------------------------------------------------------------
 // 2.2. Revoked information: IMPLICIT (SEQ) RevokedInfo
 //------------------------------------------------------------------
						// L2 I(E)TAG[1]: revokedInfo
 (unsigned char) (X_MIDDLE | CONSTRUCT | ANY_ASN1 | MUST_MATCH | OPTIONAL),
 (unsigned char)	(ASN1_CLASS_CONTEXT_SPECIFIC | ASN1_CONSTRUCTED | 0x01),
 (unsigned char) 0x00,
 (unsigned char) 0x00,
 //------------------------------------------------------------------
 // 2.2.1. Revocation Time and Reason (Optional)
 //------------------------------------------------------------------
						// L3 GENTIME: revocationTime
						// DataIndex: 3
 (unsigned char) (X_FIRST | DATA_INDEX),
 (unsigned char) (ASN1_UNIVERSAL_GEN_TIMESTR),
 (unsigned char) 2,
 (unsigned char) 0x00,
						// L3 ETAG[0]: CRLReason
 (unsigned char) (X_LAST | CONSTRUCT | OPTIONAL),
 (unsigned char)	(ASN1_CLASS_CONTEXT_SPECIFIC | ASN1_CONSTRUCTED | 0x00),
 (unsigned char) 0x00,
 (unsigned char) 0x00,
						// L4 ENUM: Reason
						// DataIndex: 4
 (unsigned char) (X_ONLY | DATA_INDEX),
 (unsigned char) (ASN1_UNIVERSAL_ENUMERATED),
 (unsigned char) 3,
 (unsigned char) 0x00,

 //------------------------------------------------------------------
 // 2.3. Unknown information: IMPLICIT NULL/ENUM
 //------------------------------------------------------------------
						// L2 ITAG[2]: unknown
						// DataIndex: 5, with header
 (unsigned char) (X_MIDDLE | DATA_INDEX | ANY_ASN1 | MUST_MATCH | OPTIONAL),
 (unsigned char)	(ASN1_CLASS_CONTEXT_SPECIFIC | 0x02),
 (unsigned char) 4,
 (unsigned char) 0x00,
 //------------------------------------------------------------------
 // 3. Validity start time: GENERALIZED TIME
 //------------------------------------------------------------------
						// L2 GENTIME: thisUpdate
						// DataIndex: 6
 (unsigned char) (X_MIDDLE | DATA_INDEX),
 (unsigned char) (ASN1_UNIVERSAL_GEN_TIMESTR),
 (unsigned char) 5,
 (unsigned char) 0x00,
 //------------------------------------------------------------------
 // 4. Validity end time, optional ETAG[0] - GENERALIZED TIME
 //------------------------------------------------------------------
						// L2 ETAG[0]: nextUpdate
 (unsigned char) (X_MIDDLE | CONSTRUCT | OPTIONAL),
 (unsigned char)	(ASN1_CLASS_CONTEXT_SPECIFIC | ASN1_CONSTRUCTED | 0x00),
 (unsigned char) 0x00,
 (unsigned char) 0x00,
 //------------------------------------------------------------------
 // 4.1. Validity end time value: GENERALIZED TIME
 //------------------------------------------------------------------
						// L3 GENTIME: NextUpdate
						// DataIndex: 7
 (unsigned char) (X_ONLY | DATA_INDEX),
 (unsigned char) (ASN1_UNIVERSAL_GEN_TIMESTR),
 (unsigned char) 6,
 (unsigned char) 0x00,
 //------------------------------------------------------------------
 // 5. Extensions for this Response, optional ETAG[1]
 //------------------------------------------------------------------
						// L2 ETAG[1]: singleExtensions
 (unsigned char) (X_LAST | CONSTRUCT | OPTIONAL),
 (unsigned char)	(ASN1_CLASS_CONTEXT_SPECIFIC | ASN1_CONSTRUCTED | 0x01),
 (unsigned char) 0x00,
 (unsigned char) 0x00,
						// L3 SEQ: Extensions
						// DataIndex: 8, no Header
 (unsigned char) (X_ONLY | DATA_INDEX),
 (unsigned char) (ASN1_UNIVERSAL_SEQUENCE | ASN1_CONSTRUCTED),
 (unsigned char) 7,
 (unsigned char) 0x00,

};

//====================================================================
// Sequence Control Structure used to subsplit the response list
// NOTE: this is ONLY used for decoding
// -----
//
//====================================================================
unsigned char OCSP_RespListCtl[(1 * HDR_ENTRY_SIZE)]={

						// L1 SEQ: Response
						// DataIndex: 0, with header
 (unsigned char) (X_ONLY | DATA_INDEX | ANY_ASN1 | MUST_MATCH),
 (unsigned char) (ASN1_UNIVERSAL_SEQUENCE | ASN1_CONSTRUCTED),
 (unsigned char) 0,
 (unsigned char) 0x00,
};

//====================================================================
// Response data structure, used in OCSP-Response only,
// from/to OCSP ResponseData PDU <-> version, responderID, producedAt
//				     responses, pesponseExtensions
// NOTE: this is ONLY used for decoding
// -----
//
//====================================================================
unsigned char OCSP_RespDataCtl[(11 * HDR_ENTRY_SIZE)]={

						// L1 SEQ: ResponseData
 (unsigned char) (X_ONLY | CONSTRUCT),
 (unsigned char) (ASN1_UNIVERSAL_SEQUENCE | ASN1_CONSTRUCTED),
 (unsigned char) 0x00,
 (unsigned char) 0x00,
 //------------------------------------------------------------------
 // 1. Version, optional: ETAG[0]
 //------------------------------------------------------------------
						// L2 ETAG[0]: version
 (unsigned char) (X_FIRST | CONSTRUCT | OPTIONAL),
 (unsigned char)	(ASN1_CLASS_CONTEXT_SPECIFIC | ASN1_CONSTRUCTED | 0x00),
 (unsigned char) 0x00,
 (unsigned char) 0x00,
 //------------------------------------------------------------------
 // 1.1. Version value: INTEGER
 //------------------------------------------------------------------
						// L3 INT: Version
						// DataIndex: 0
 (unsigned char) (X_ONLY | DATA_INDEX),
 (unsigned char) (ASN1_UNIVERSAL_INTEGER),
 (unsigned char) 0,
 (unsigned char) 0x00,
 //------------------------------------------------------------------
 // 2. Responder ID either byName or byKey, exact one must be present
 //------------------------------------------------------------------
						// L2 ETAG[1]: RespID byName
 (unsigned char) (X_MIDDLE | CONSTRUCT | OPTIONAL),
 (unsigned char)	(ASN1_CLASS_CONTEXT_SPECIFIC | ASN1_CONSTRUCTED | 0x01),
 (unsigned char) 0x00,
 (unsigned char) 0x00,
 //------------------------------------------------------------------
 // 2.1. Responder Name, Distinguished Name
 //------------------------------------------------------------------
						// L3 SEQ: DistinguishedName
						// DataIndex: 1, NO header
 (unsigned char) (X_ONLY | DATA_INDEX),
 (unsigned char) (ASN1_UNIVERSAL_SEQUENCE | ASN1_CONSTRUCTED),
 (unsigned char) 1,
 (unsigned char) 0x00,

						// L2 ETAG[2]: RespID byKey
 (unsigned char) (X_MIDDLE | CONSTRUCT | OPTIONAL),
 (unsigned char)	(ASN1_CLASS_CONTEXT_SPECIFIC | ASN1_CONSTRUCTED | 0x02),
 (unsigned char) 0x00,
 (unsigned char) 0x00,
 //----------------------------------------------------------------------
 // 2.2. Responder Key, SHA-1 hash of responders public key (without T/L)
 //----------------------------------------------------------------------
						// L3 OCTET: KeyHash
						// DataIndex: 2
 (unsigned char) (X_ONLY | DATA_INDEX),
 (unsigned char) (ASN1_UNIVERSAL_OCTETSTRING),
 (unsigned char) 2,
 (unsigned char) 0x00,
 //------------------------------------------------------------------
 // 3. Time when responses were produced: GENERALIZED TIME
 //------------------------------------------------------------------
						// L2 GENTIME: producedAt
						// DataIndex: 3
 (unsigned char) (X_MIDDLE | DATA_INDEX),
 (unsigned char) (ASN1_UNIVERSAL_GEN_TIMESTR),
 (unsigned char) 3,
 (unsigned char) 0x00,
 //------------------------------------------------------------------
 // 4. List of responses: SEQUENCE
 //------------------------------------------------------------------
						// L2 SEQ: responses
						// DataIndex: 4, no header
 (unsigned char) (X_MIDDLE | DATA_INDEX),
 (unsigned char) (ASN1_UNIVERSAL_SEQUENCE | ASN1_CONSTRUCTED),
 (unsigned char) 4,
 (unsigned char) 0x00,
 //------------------------------------------------------------------
 // 5. Extensions for all the Responses, optional ETAG[1]
 //------------------------------------------------------------------
						// L2 ETAG[1]: responseExtensions
 (unsigned char) (X_LAST | CONSTRUCT | OPTIONAL),
 (unsigned char)	(ASN1_CLASS_CONTEXT_SPECIFIC | ASN1_CONSTRUCTED | 0x01),
 (unsigned char) 0x00,
 (unsigned char) 0x00,
						// L3 SEQ: Extensions
						// DataIndex: 5, no header
 (unsigned char) (X_ONLY | DATA_INDEX),
 (unsigned char)	(ASN1_UNIVERSAL_SEQUENCE | ASN1_CONSTRUCTED),
 (unsigned char) 5,
 (unsigned char) 0x00,

};

//====================================================================
// Basic OCSP Response data structure, used in OCSP-Response only,
// from/to BasicOCSPResponse PDU <-> tbsResponseData, signatureAlgor,
//				     signature, certs
// NOTE: this is ONLY used for decoding
// -----
//
//====================================================================
unsigned char OCSP_BasicRespCtl[(8 * HDR_ENTRY_SIZE)]={

						// L1 SEQ: BasicOCSPResponse
 (unsigned char) (X_ONLY | CONSTRUCT),
 (unsigned char) (ASN1_UNIVERSAL_SEQUENCE | ASN1_CONSTRUCTED),
 (unsigned char) 0x00,
 (unsigned char) 0x00,
 //------------------------------------------------------------------
 // 1. To be signed response data: tbsResponseData (Sequence)
 //------------------------------------------------------------------
						// L2 ANY: tbsResponseData
						// DataIndex: 0
 (unsigned char) (X_FIRST | DATA_INDEX | ANY_ASN1),
 (unsigned char)	(ASN1_UNIVERSAL_EOC),
 (unsigned char) 0,
 (unsigned char) 0x00,
 //------------------------------------------------------------------
 // 2. Signature algorithm: SEQUENCE
 //------------------------------------------------------------------
						// L2 SEQ: signatureAlgorithm
 (unsigned char) (X_MIDDLE | CONSTRUCT),
 (unsigned char) (ASN1_UNIVERSAL_SEQUENCE | ASN1_CONSTRUCTED),
 (unsigned char) 0x00,
 (unsigned char) 0x00,
 //------------------------------------------------------------------
 // 2.1. Signature algorithm's 'algorithm': OID
 //------------------------------------------------------------------
						// L3 OID: algorithm
						// DataIndex: 1
 (unsigned char) (X_FIRST | DATA_INDEX),
 (unsigned char) (ASN1_UNIVERSAL_OBJECT_ID),
 (unsigned char) 1,
 (unsigned char) 0x00,
 //------------------------------------------------------------------
 // 2.2. Signature algorithm's 'parameters': ANY
 //------------------------------------------------------------------
						// L3 ANY: params
						// DataIndex: 2
 (unsigned char) (X_LAST | DATA_INDEX | ANY_ASN1 | OPTIONAL),
 (unsigned char) (ASN1_UNIVERSAL_EOC),
 (unsigned char) 2,
 (unsigned char) 0x00,
 //------------------------------------------------------------------
 // 3. Signature: BITSTRING
 //------------------------------------------------------------------
						// L2 BITST: Signature
						// DataIndex: 3
 (unsigned char) (X_MIDDLE | DATA_INDEX),
 (unsigned char) (ASN1_UNIVERSAL_BITSTRING),
 (unsigned char) 3,
 (unsigned char) 0x00,

 //------------------------------------------------------------------
 // 4. Certificates: ETAG[0], optional
 //------------------------------------------------------------------
						// L2 ETAG: certs
 (unsigned char) (X_LAST | CONSTRUCT | OPTIONAL),
 (unsigned char)	(ASN1_CLASS_CONTEXT_SPECIFIC | ASN1_CONSTRUCTED | 0x00),
 (unsigned char) 0x00,
 (unsigned char) 0x00,
 //------------------------------------------------------------------
 // 4.1. Certificate list: SEQUENCE
 //------------------------------------------------------------------
						// L3 SEQ: Certificates
						// DataIndex: 4
 (unsigned char) (X_ONLY | DATA_INDEX),
 (unsigned char) (ASN1_UNIVERSAL_SEQUENCE | ASN1_CONSTRUCTED),
 (unsigned char) 4,
 (unsigned char) 0x00,
};

//====================================================================
// OCSP Response bytes data structure, used in OCSP-Response only,
// from/to ResponseBytes PDU <-> responseType, response
// NOTE: this is ONLY used for decoding
// -----
//
//====================================================================
unsigned char OCSP_RespBytesCtl[(3 * HDR_ENTRY_SIZE)]={

						// L1 SEQ: ResponseBytes
 (unsigned char) (X_ONLY | CONSTRUCT),
 (unsigned char) (ASN1_UNIVERSAL_SEQUENCE | ASN1_CONSTRUCTED),
 (unsigned char) 0x00,
 (unsigned char) 0x00,
 //------------------------------------------------------------------
 // 1. Type of response: OBJECT IDENTIFIER
 //------------------------------------------------------------------
						// L2 OID: responseType
						// DataIndex: 0
 (unsigned char) (X_FIRST | DATA_INDEX),
 (unsigned char)	(ASN1_UNIVERSAL_OBJECT_ID),
 (unsigned char) 0,
 (unsigned char) 0x00,
 //------------------------------------------------------------------
 // 2. Response data themself: OCTET STRING
 //------------------------------------------------------------------
						// L2 OCT: response
						// DataIndex: 1
 (unsigned char) (X_LAST | DATA_INDEX),
 (unsigned char) (ASN1_UNIVERSAL_OCTETSTRING),
 (unsigned char) 1,
 (unsigned char) 0x00,
};

//====================================================================
// Full OCSP Response data structure, used in OCSP-Response only,
// from/to OCSPResponse PDU <-> responseStatus, responseBytes
// NOTE: this is ONLY used for decoding
// -----
//
//====================================================================
unsigned char OCSP_RespCtl[(3 * HDR_ENTRY_SIZE)]={

						// L1 SEQ: OCSPResponse
 (unsigned char) (X_ONLY | CONSTRUCT),
 (unsigned char) (ASN1_UNIVERSAL_SEQUENCE | ASN1_CONSTRUCTED),
 (unsigned char) 0x00,
 (unsigned char) 0x00,
 //------------------------------------------------------------------
 // 1. Response status: ENUMERATED
 //------------------------------------------------------------------
						// L2 ENUM: responseStatus
						// DataIndex: 0
 (unsigned char) (X_FIRST | DATA_INDEX),
 (unsigned char)	(ASN1_UNIVERSAL_ENUMERATED),
 (unsigned char) 0,
 (unsigned char) 0x00,
 //------------------------------------------------------------------
 // 2. Response Bytes, optional: ETAG[0]
 //------------------------------------------------------------------
						// L2 ETAG[0]: responseBytes
						// DataIndex: 1
 (unsigned char) (X_LAST | DATA_INDEX | OPTIONAL),
 (unsigned char)	(ASN1_CLASS_CONTEXT_SPECIFIC | ASN1_CONSTRUCTED | 0x00),
 (unsigned char) 1,
 (unsigned char) 0x00,
};

/**
* Routine CmpBit8Arrays compares contents of 2 Bit8 Arrays (LclCmpBit8Arrays).
*
*  @param pArr1 Array Base
*  @param Arr1Off Start of Data
*  @param pArr2 Array Base
*  @param Arr2Off Start of Data
*  @param ArrLen Length of Data
*  @return int Status - ASN1_SAME -> Match found, else not
*/
static  int  LclCmpBit8Arrays(char* pArr1, int Arr1Off,
				         char* pArr2, int Arr2Off,
					 int ArrLen)
{
  if((pArr1 == NULL) || (pArr2 == NULL) || (ArrLen <= 0))
    return(ASN1_NOT_SAME);

  while(ArrLen != 0)
  {
    if(pArr1[Arr1Off++] != pArr2[Arr2Off++])
      return(ASN1_NOT_SAME);
    ArrLen--;
  }
  return(ASN1_SAME);
}

/**
* Free a CertID structure (FreeCertIdStruc).
*
*  @param pCertIdStruc
*/
static  void  FreeCertIdStruc(HMEM_CTX_DEF
			HOCSCID * pCertIdStruc)
{
  if(pCertIdStruc == NULL)
    return;

  FreeIDATPARR_Struc(HMEM_CTX_REF1 pCertIdStruc->HashAlgor);
  FreeIDATPARR_Struc(HMEM_CTX_REF1 pCertIdStruc->IssuerNameHash);
  FreeIDATPARR_Struc(HMEM_CTX_REF1 pCertIdStruc->IssuerKeyHash);
  FreeIDATPARR_Struc(HMEM_CTX_REF1 pCertIdStruc->SerialNumber);
  FREE_CARRAY(HMEM_CTX_REF,pCertIdStruc);
}

/**
* Allocate, initialize a CertID structure (AllocCertIdStruc).
*
*               none
*  @return HOCSP_CERTID_PTR pCertIdStruc / NULL
*/
static  HOCSCID *  AllocCertIdStruc(HMEM_CTX_DEF1)
{
  HOCSCID * pCertIdStruc;
  IDATPARR* pTmpDesc[1];

  pCertIdStruc = (HOCSCID *)
    ((void *) BIT8_ARRAY_CALLOC(HMEM_CTX_REF, 1, sizeof(HOCSCID)));
  if(pCertIdStruc == NULL)
    return(NULL);
  //---------------------------------------------------------
  // Initialize variables
  //---------------------------------------------------------

  pCertIdStruc->HashAlgorType   = OCSP_HASH_ALGOR_UNKNOWN;
  pCertIdStruc->ResponseID	     = OCSP_RESPONSE_ID_INVALID;

  //----------------------------------------------------------
  // Allocate the Element Descriptors
  //----------------------------------------------------------
  for(;;)
  {
    if(AllocIDATPARR_Struc(HMEM_CTX_REF1 pTmpDesc,2) != ASN1_OP_OK)
      break;
    pCertIdStruc->HashAlgor = pTmpDesc[0];

    if(AllocIDATPARR_Struc(HMEM_CTX_REF1 pTmpDesc,1) != ASN1_OP_OK)
      break;
    pCertIdStruc->IssuerNameHash = pTmpDesc[0];

    if(AllocIDATPARR_Struc(HMEM_CTX_REF1 pTmpDesc,1) != ASN1_OP_OK)
      break;
    pCertIdStruc->IssuerKeyHash = pTmpDesc[0];

    if(AllocIDATPARR_Struc(HMEM_CTX_REF1 pTmpDesc,1) != ASN1_OP_OK)
      break;
    pCertIdStruc->SerialNumber = pTmpDesc[0];

    return(pCertIdStruc);
  }
  FreeCertIdStruc(HMEM_CTX_REF1 pCertIdStruc);
  return(NULL);
}

/**
* Free a CertID list (FreeCertIdList).
*
*  @param pCertIdList List array
*  @param CertIdCount Number of elements
*/
static  void  FreeCertIdList(HMEM_CTX_DEF
		HOCSCID ** pCertIdList, int CertIdCount)
{
  if(pCertIdList == NULL)
    return;

  while(CertIdCount > 0)
  {
    CertIdCount--;			// index to list element
    FreeCertIdStruc(HMEM_CTX_REF1 pCertIdList[CertIdCount]);
  }
  FREE_CARRAY(HMEM_CTX_REF,pCertIdList);
}

/**
* Free an Ocsp request structure (FreeOcspReqStruc).
*
*  @param pReqStruc
*/
static  void  FreeOcspReqStruc(HMEM_CTX_DEF
				HOCSREQ * pReqStruc)
{
  if(pReqStruc == NULL)
    return;
  //------------------------------------------------
  // Free list of CertID structures, nonce
  //------------------------------------------------
  FreeCertIdList(HMEM_CTX_REF1
		 pReqStruc->pCertIdList,
		 pReqStruc->CertIdCount);
  FREE_CARRAY(HMEM_CTX_REF,pReqStruc->pNonceData);
  //-------------------------------------------------------
  // Free requestor name, request list, request extensions
  // and signature
  //------------------------------------------------------
  FreeIDATPARR_Struc(HMEM_CTX_REF1 pReqStruc->RequestorName);
  FreeIDATPARR_Struc(HMEM_CTX_REF1 pReqStruc->RequestList);
  FreeIDATPARR_Struc(HMEM_CTX_REF1 pReqStruc->RequestExt);
  FreeIDATPARR_Struc(HMEM_CTX_REF1 pReqStruc->Signature);
  FreeIDATPARR_Struc(HMEM_CTX_REF1 pReqStruc->OCSPRequest);
  FREE_CARRAY(HMEM_CTX_REF,pReqStruc);
}

/**
* Allocate, initialize an Ocsp request structure  (AllocOcspReqStruc).
*
*               none
*  @return HOCSP_REQ_PTR pReqStruc / NULL
*/
static  HOCSREQ *  AllocOcspReqStruc(HMEM_CTX_DEF1)
{

  HOCSREQ * pReqStruc = NULL;

  IDATPARR* pTmpDesc[1];

  pReqStruc = (HOCSREQ *)
    ((void *) BIT8_ARRAY_CALLOC(HMEM_CTX_REF,1, sizeof(HOCSREQ)));
  if(pReqStruc == NULL)
    return(NULL);
  //---------------------------------------------------------
  // Initialize variables
  //---------------------------------------------------------

  pReqStruc->HashAlgorType   = OCSP_HASH_ALGOR_UNKNOWN;
  pReqStruc->SignatType      = INVALID_ALGOR;

  //----------------------------------------------------------
  // Allocate the Element Descriptors
  //----------------------------------------------------------
  for(;;)
  {
    if(AllocIDATPARR_Struc(HMEM_CTX_REF1 pTmpDesc,1) != ASN1_OP_OK)
      break;
    pReqStruc->RequestorName = pTmpDesc[0];

    if(AllocIDATPARR_Struc(HMEM_CTX_REF1 pTmpDesc,1) != ASN1_OP_OK)
      break;
    pReqStruc->RequestList = pTmpDesc[0];

    if(AllocIDATPARR_Struc(HMEM_CTX_REF1 pTmpDesc,1) != ASN1_OP_OK)
      break;
    pReqStruc->RequestExt = pTmpDesc[0];

    if(AllocIDATPARR_Struc(HMEM_CTX_REF1 pTmpDesc,1) != ASN1_OP_OK)
      break;
    pReqStruc->Signature = pTmpDesc[0];

    if(AllocIDATPARR_Struc(HMEM_CTX_REF1 pTmpDesc,1) != ASN1_OP_OK)
      break;
    pReqStruc->OCSPRequest = pTmpDesc[0];

    return(pReqStruc);
  }
  FreeOcspReqStruc(HMEM_CTX_REF1 pReqStruc);
  return(NULL);
}

/**
* Generates a certificate ID structure from given certificate (BuildOcspCertIdStruc).
*
* Note: Certificate IDs are used in OCSP requests to specify
*   a shortform for a certificate to test. If the certificate
*	 to test is NOT a selfsigned one then the certificate of
*	 the issuer must also be specified.
*	 The only hash algorithm supported at the moment is SHA-1 (0).
*
*  @param pSubjectCert Certificate of subject
*  @param pIssuerCert Certificate of issuer. Optional
*  @param HashAlgorType Algorithm of hash to use
*  @param ppCertIdStruc Pointer to return generated ID structure
*  @return 0 on success, error code otherwise
*/
extern "C"  int  BuildOcspCertIdStruc(HMEM_CTX_DEF
		X509CERT * pSubjectCert,
		X509CERT * pIssuerCert, int HashAlgorType,
		HOCSCID ** ppCertIdStruc)
{
  int Retcode;

  HOCSCID * pCertIdStruc;
  IDATA* pIdata;
  IDATA** ppArr;

  int pTmpResult[1];

  char ShaDigestBuf[SHA_DIGEST_LEN];
  int ShaArray[SHA_ARRAY_SIZE];

  //--------------------------------------------------
  // Check parameters
  //--------------------------------------------------
  if((pSubjectCert == NULL) || (ppCertIdStruc == NULL))
    return(HOCSP_NULL_PTR);

  if(HashAlgorType != OCSP_HASH_ALGOR_SHA1)
    return(HOCSP_CERTID_HASHTYPE_UNSUPP);
  //---------------------------------------------------
  // If no issuer certificate given the subject certificate
  // must be selfsigned...
  //---------------------------------------------------
  if(pIssuerCert == NULL)		// no issuer certificate
  {
    if((pSubjectCert->Flags & SELF_SIGNED_MASK) == 0)
      return(HOCSP_CERTID_NO_ISSUER_CERT);
    pIssuerCert = pSubjectCert;		// use for both
  }
  else
  {
    //-------------------------------------------------
    // Issuer certificate is given, check name matching
    //-------------------------------------------------
    if((Retcode = MatchCerts(pSubjectCert,pIssuerCert,CHAIN_MATCH,pTmpResult)) != ASN1_OP_OK)
      return(Retcode);
    if(pTmpResult[0] != ASN1_SAME)
      return(HOCSP_CERTID_ISS_SUBJ_MISMATCH);
  }
  //---------------------------------------------------
  // Allocate CertID structure, initialize
  //---------------------------------------------------
  if((pCertIdStruc = AllocCertIdStruc(HMEM_CTX_REF)) == NULL)
    return(HOCSP_ALLOC_ERR);

  for(;;)		// Error FOR
  {
    //----------------------------------------------------------
    // Generate the Algorithm identifier OID for SHA-1 OID and
    // params NULL
    //----------------------------------------------------------
    pCertIdStruc->HashAlgor->Flags |= FREE_BIT_MASK;
    ppArr = pCertIdStruc->HashAlgor->ppArr;

    if((Retcode = FromBufToDatArray(HMEM_CTX_REF1 ppArr,0,OCSP_Sha1HashOID,0,5,1)) != ASN1_OP_OK)
      break;

    ShaDigestBuf[0] = ASN1_UNIVERSAL_NULL;
    ShaDigestBuf[1] = 0;

    if((Retcode = FromBufToDatArray(HMEM_CTX_REF1 ppArr,1,ShaDigestBuf,0,2,1)) != ASN1_OP_OK)
      break;
    //-------------------------------------------------------
    // Generate the SHA-1 hash of issuer DN from subject cert
    //-------------------------------------------------------
    pIdata = pSubjectCert->IssuerNameOcsp->ppArr[0];

    SHA1_Init(ShaArray);
    SHA1_Update(ShaArray,pIdata->Base,(int) pIdata->Off,pIdata->Len);
    SHA1_Final(ShaArray,ShaDigestBuf,0);

    pCertIdStruc->IssuerNameHash->Flags |= FREE_BIT_MASK;
    ppArr = pCertIdStruc->IssuerNameHash->ppArr;

    if((Retcode = FromBufToDatArray(HMEM_CTX_REF1 ppArr,0,ShaDigestBuf,0,SHA_DIGEST_LEN,1)) != ASN1_OP_OK)
      break;
    //--------------------------------------------------------------
    // Generate the SHA-1 hash of issuer public key from issuer cert
    //--------------------------------------------------------------
    pIdata = pIssuerCert->PubKeyValueOcsp->ppArr[0];

    SHA1_Init(ShaArray);
    SHA1_Update(ShaArray,pIdata->Base,(int) pIdata->Off,pIdata->Len);
    SHA1_Final(ShaArray,ShaDigestBuf,0);

    pCertIdStruc->IssuerKeyHash->Flags |= FREE_BIT_MASK;
    ppArr = pCertIdStruc->IssuerKeyHash->ppArr;

    if((Retcode = FromBufToDatArray(HMEM_CTX_REF1 ppArr,0,ShaDigestBuf,0,SHA_DIGEST_LEN,1)) != ASN1_OP_OK)
      break;
    //---------------------------------------------------------------
    // Copy serial number from subject certificate
    //---------------------------------------------------------------
    if((Retcode = AllocCopyDatArrayElements(HMEM_CTX_REF1 pSubjectCert->SerialNumber->ppArr,0,pCertIdStruc->SerialNumber->ppArr,0,1,1)) != ASN1_OP_OK)
      break;
    pCertIdStruc->SerialNumber->Flags |= FREE_BIT_MASK;
    
    ppCertIdStruc[0] = pCertIdStruc;
    return(HOCSP_OP_OK);
  }
  FreeCertIdStruc(HMEM_CTX_REF1 pCertIdStruc);
  return(Retcode);
}

/**
* Generates a certificate ID list from a given certificate chain
* and hash algorithm (BuildOcspCertIdList).
*
* Note: <ol>
* <li> The list is used to generate the OCSP request and
*     to match the single OCSP responses with the certificates
*	    (to assure correct replies).
* <li> The bottom certificate in the list is the end certificate.
* <li> Number of returned ID structures is same as certificates.
*</ol>
*  @param pCertList Array of certificates
*  @param CertCount Number of certificates in list
*  @param HashAlgorType Hash algorithm to use
*  @param ppCertIdList Generated ID list
*  @return 0 on success, error code otherwise
*/
extern "C"  int  BuildOcspCertIdList(HMEM_CTX_DEF
		X509CERT ** pCertList,
		int CertCount, int HashAlgorType,
		HOCSCID *** ppCertIdList)
{
  int Retcode;
  int Index;
  int CertIdCount;

  X509CERT * pSubjectCert;
  X509CERT * pIssuerCert;

  HOCSCID ** pCertIdList;
  HOCSCID * ppTmpCertIdStruc[1];
  //--------------------------------------------------------
  // check parameters
  //--------------------------------------------------------
  if((pCertList == NULL) || (ppCertIdList == NULL))
    return(HOCSP_NULL_PTR);

  ppCertIdList[0] = NULL;
  if(CertCount <= 0)			// strange case...
    return(HOCSP_OP_OK);
  //--------------------------------------------------------
  // allocate the CertId structure array
  //--------------------------------------------------------
  CertIdCount = CertCount;
  pCertIdList = (HOCSCID **)
    ((void *) BIT8_ARRAY_CALLOC(HMEM_CTX_REF,1,
				sizeof(HOCSCID *)*CertIdCount));
  if(pCertIdList == NULL)
    return(HOCSP_ALLOC_ERR);
  //--------------------------------------------------------
  // build the CertId elements from the certificate chain
  //--------------------------------------------------------
  Index = 0;
  while(CertCount > 0)
  {
    pSubjectCert = pCertList[Index];
    if(CertCount > 1)			// not the last (a root)
      pIssuerCert = pCertList[Index+1];
    else				// last (or only in list)
      pIssuerCert = pSubjectCert;

    Retcode = BuildOcspCertIdStruc(HMEM_CTX_REF1
				   pSubjectCert, pIssuerCert,
				   HashAlgorType, ppTmpCertIdStruc);
    if(Retcode != HOCSP_OP_OK)
    {
      FreeCertIdList(HMEM_CTX_REF1
		     pCertIdList,CertIdCount);
      return(Retcode);
    }
    pCertIdList[Index] = ppTmpCertIdStruc[0];

    Index++;
    CertCount--;
  }
  ppCertIdList[0] = pCertIdList;
  return(HOCSP_OP_OK);
}

//()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()
//
// OCSP Request handler functions
//
//()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()

/**
* Generate ASN.1 representation of a CertID structure (ToASN1CertID).
*
*  @param pCertIdStruc Structure
*  @param ppDstBuf Allocated buffer
*  @param pDstLen Size of data
*  @return 0 on success, error code otherwise
*/
static  int  ToASN1CertID(HMEM_CTX_DEF
			HOCSCID * pCertIdStruc,
			char** ppDstBuf, int* pDstLen)
{
  int Retcode;

  IDATPARR* pTmpDesc[1];
  IDATPARR* pDataDesc;

  //-----------------------------------------------------
  // Check parameters
  //-----------------------------------------------------
  if((pCertIdStruc == NULL) || (ppDstBuf == NULL) ||
     (pDstLen == NULL))
    return(HOCSP_NULL_PTR);

  ppDstBuf[0] = NULL;
  pDstLen[0] = 0;

  //-----------------------------------------------------
  // Allocate Descriptor array for conversion
  //-----------------------------------------------------
  if((Retcode = AllocIDATPARR_Struc(HMEM_CTX_REF1 pTmpDesc,5)) != ASN1_OP_OK)
    return(Retcode);

  pDataDesc = pTmpDesc[0];
  //------------------------------------------------------
  // Load the Descriptors for conversion, convert to ASN.1
  //------------------------------------------------------
  for(;;)	// error for
  {
    // Copy the Signature algorithm components
    if((Retcode = AllocCopyDatArrayToDatArray(HMEM_CTX_REF1 pCertIdStruc->HashAlgor,0,pDataDesc,0,2,0)) != ASN1_OP_OK)
       break;

    // Copy the issuer name hash component
    if((Retcode = AllocCopyDatArrayToDatArray(HMEM_CTX_REF1 pCertIdStruc->IssuerNameHash,0,pDataDesc,2,1,0)) != ASN1_OP_OK)
      break;

    // Copy the issuer key hash component
    if((Retcode = AllocCopyDatArrayToDatArray(HMEM_CTX_REF1 pCertIdStruc->IssuerKeyHash,0,pDataDesc,3,1,0)) != ASN1_OP_OK)
      break;

    // Copy the serial number component
    if((Retcode = AllocCopyDatArrayToDatArray(HMEM_CTX_REF1 pCertIdStruc->SerialNumber,0,pDataDesc,4,1,0)) != ASN1_OP_OK)
      break;

    if((Retcode = ToASN1(HMEM_CTX_REF1 pDataDesc->ppArr,0,(char *) OCSP_CertIDCtl,7,ppDstBuf,pDstLen)) != ASN1_OP_OK)
      break;
    
    FreeIDATPARR_Struc(HMEM_CTX_REF1 pDataDesc);
    return(HOCSP_OP_OK);
  }
  FreeIDATPARR_Struc(HMEM_CTX_REF1 pDataDesc);
  return(Retcode);
}

/**
* Generate ASN.1 representation of a (single) request structure (ToASN1SingleRequest).
* Note: we do not use any extensions, only the CertID !
* -----
*
*  @param pCertIdStruc Structure
*  @param ppDstBuf Allocated buffer
*  @param pDstLen Size of data
*  @return 0 on success, error code otherwise
*/
static  int  ToASN1SingleRequest(HMEM_CTX_DEF
			HOCSCID * pCertIdStruc,
			char** ppDstBuf, int* pDstLen)
{
  int Retcode;

  int CertIdDataLen;
  char* pCertIdDataBuf = NULL;

  char* ppTmpBuf[1];
  int pTmpLen[1];

  IDATPARR* pTmpDesc[1];
  IDATPARR* pDataDesc;

  //-----------------------------------------------------
  // Check parameters
  //-----------------------------------------------------
  if((pCertIdStruc == NULL) || (ppDstBuf == NULL) ||
     (pDstLen == NULL))
    return(HOCSP_NULL_PTR);

  ppDstBuf[0] = NULL;
  pDstLen[0] = 0;

  //-----------------------------------------------------
  // Allocate Descriptor array for conversion
  //-----------------------------------------------------
  if((Retcode = AllocIDATPARR_Struc(HMEM_CTX_REF1 pTmpDesc,2)) != ASN1_OP_OK)
    return(Retcode);

  pDataDesc = pTmpDesc[0];
  for(;;)
  {
    //-----------------------------------------------------
    // Convert the CertID to ASN.1 representation
    //-----------------------------------------------------
    if((Retcode = ToASN1CertID(HMEM_CTX_REF1
			pCertIdStruc, ppTmpBuf, pTmpLen)) != HOCSP_OP_OK)
      break;
    pCertIdDataBuf = ppTmpBuf[0];
    CertIdDataLen  = pTmpLen[0];
    //------------------------------------------------------
    // Load the Descriptors for conversion, convert to ASN.1
    //------------------------------------------------------

    // Copy the ASN.1 converted CertID to destination
    if((Retcode = FromBufToDatArray(HMEM_CTX_REF1 pDataDesc->ppArr,0,pCertIdDataBuf,0,CertIdDataLen,0)) != ASN1_OP_OK)
      break;

    Retcode = ToASN1(HMEM_CTX_REF1 pDataDesc->ppArr,0,(char *) OCSP_SingleReqCtl,3,ppDstBuf,pDstLen);
    break;
  }
  FREE_CARRAY(HMEM_CTX_REF,pCertIdDataBuf);
  FreeIDATPARR_Struc(HMEM_CTX_REF1 pDataDesc);
  return(Retcode);
}

/**
* Generates ASN.1 representation of a RequestList from a list of
* certIds (ToASN1RequestList).
* Allocates the result buffer.
*	
*  @param pCertIdList List of IDs
*  @param CertIdCount number of IDs given
*  @param ppDstBuf Allocated result buffer
*  @param pDstLen Size of generated data
* 
*  @return 0 on success, error code otherwise
*/
extern "C"  int  ToASN1RequestList(HMEM_CTX_DEF
		HOCSCID ** pCertIdList,
		int CertIdCount, char** ppDstBuf, int* pDstLen)
{
  int Retcode;
  int Index,DstIndex;
  int TotalBufLen;

  char* pTotalBuf;

  IDATA* pIdata;
  IDATA** ppArr;

  IDATPARR* pDataDesc = NULL;
  IDATPARR* ppTmpDesc[1];

  //--------------------------------------------------------
  // check parameters
  //--------------------------------------------------------
  if((pCertIdList == NULL) || (ppDstBuf == NULL) || (pDstLen == NULL))
    return(HOCSP_NULL_PTR);

  ppDstBuf[0] = NULL;
  pDstLen[0] = 0;

  if(CertIdCount <= 0)
    return(HOCSP_REQLIST_NO_CERT_IDS);

  //-----------------------------------------------------------
  // Allocate Descriptor array for conversion, mark as freeable
  //-----------------------------------------------------------
  if((Retcode = AllocIDATPARR_Struc(HMEM_CTX_REF1 ppTmpDesc,CertIdCount)) != ASN1_OP_OK)
    return(Retcode);

  pDataDesc = ppTmpDesc[0];
  
  pDataDesc->Flags |= FREE_BIT_MASK;

  ppArr = pDataDesc->ppArr;
  //-----------------------------------------------------------
  // Convert the certidlist to list of ASN.1 encoded buffers
  //-----------------------------------------------------------
  Index = 0;
  TotalBufLen = 0;
  while(Index < CertIdCount)
  {
    //---------------------------------------------------------
    // Convert next CertID structure to ASN.1
    //---------------------------------------------------------
    if((Retcode =ToASN1SingleRequest(HMEM_CTX_REF1
			pCertIdList[Index], ppDstBuf, pDstLen)) != HOCSP_OP_OK)
    {
      FreeIDATPARR_Struc(HMEM_CTX_REF1 pDataDesc);
      return(Retcode);
    }
    //---------------------------------------------------------
    // Store ASN.1 encoding to descriptor, advance buffer count
    //---------------------------------------------------------
    if((Retcode = FromBufToDatArray(HMEM_CTX_REF1 ppArr,Index,ppDstBuf[0],0,pDstLen[0],0)) != ASN1_OP_OK)
    {
      FreeIDATPARR_Struc(HMEM_CTX_REF1 pDataDesc);
      return(Retcode);
    }
    TotalBufLen += pDstLen[0];
    Index++;
  }
  //-------------------------------------------------------------
  // Allocate the combine buffer, concatenate the ASN.1 encodings
  //-------------------------------------------------------------
  if((pTotalBuf = BIT8_ARRAY_ALLOC(HMEM_CTX_REF,
				   TotalBufLen)) == NULL)
  {
    FreeIDATPARR_Struc(HMEM_CTX_REF1 pDataDesc);
    return(HOCSP_ALLOC_ERR);
  }
  Index = 0;
  DstIndex = 0;
  while(Index < CertIdCount)
  {
    pIdata = ppArr[Index];

    memcpy(pTotalBuf+DstIndex,pIdata->Base+0,pIdata->Len);

    DstIndex += pIdata->Len;
    Index++;
  }
  FreeIDATPARR_Struc(HMEM_CTX_REF1 pDataDesc);
  //----------------------------------------------------------
  // Wrap buffer in a sequence to get the list
  //----------------------------------------------------------
  Retcode = ToASN1_Sequence(HMEM_CTX_REF1 pTotalBuf,0,TotalBufLen,ppDstBuf,pDstLen);
  FREE_CARRAY(HMEM_CTX_REF,pTotalBuf);
  return(Retcode);
}

/**
* Generate ASN.1 representation of RequestorName (without surrounding
* ETAG[1]) from a given X501 DN DER encoding (raw format) (ToASN1RequestorName).
*
* Note: 1. we use the DN format for general name
* ----- 2. RFC2560 specifies a DN to be implicit tagged [4] !
*
*  @param pX501_DER_Name
*  @param ppDstBuf Allocated buffer
*  @param pDstLen Size of data
*  @return 0 on success, error code otherwise
*/
static  int  ToASN1RequestorName(HMEM_CTX_DEF
	IDATPARR* pX501_DER_Name, char** ppDstBuf, int* pDstLen)
{
  int Retcode;

  char* pDstBuf;
  IDATA* pIdata;

  //-----------------------------------------------------
  // Check parameters
  //-----------------------------------------------------
  if((pX501_DER_Name == NULL) || (ppDstBuf == NULL) ||
     (pDstLen == NULL))
    return(HOCSP_NULL_PTR);

  ppDstBuf[0] = NULL;
  pDstLen[0] = 0;
  //-----------------------------------------------------------
  // Wrap the DN into a Sequence
  //-----------------------------------------------------------
  pIdata = pX501_DER_Name->ppArr[0];

  Retcode = ToASN1_Sequence(HMEM_CTX_REF1 pIdata->Base,(int) pIdata->Off,pIdata->Len,ppDstBuf,pDstLen);
  if(Retcode != ASN1_OP_OK)
    return(Retcode);
  //-----------------------------------------------------------
  // Replace the 'SEQUENCE' by ITAG[4] (constructed!)
  //-----------------------------------------------------------
  pDstBuf = ppDstBuf[0];

  pDstBuf[0] = (char)
    ((unsigned char) (ASN1_CLASS_CONTEXT_SPECIFIC | ASN1_CONSTRUCTED | 0x04));

  return(HOCSP_OP_OK);
}

/**
* Sign the TBS Request with the private key from a given
* certificate (SignTBSRequest).
*
*
*  @param pCert Certificate with priv. key
*  @param SignatType Type of signature to apply,
*               if < 0 use default for
*               private key type
*  @param pRequestBuf Request buffer
*  @param RequestOff Start of Data
*  @param RequestLen Size of data
*  @param ppDstBuf Allocated buffer
*  @param pDstLen Size of data
*  @param pUsedSignatType actual used signature type
*  @return 0 on success, error code otherwise
*/
static  int 	SignTBSRequest(HMEM_CTX_DEF
		X509CERT * pCert, int SignatType,
		char* pRequestBuf, int RequestOff, int RequestLen,
		char** ppDstBuf, int* pDstLen, int* pUsedSignatType)
{
  int Retcode;
  int PrivKeyAlgor;

  RSA_STRUC* ppTmpRsaStruc[1];
  DSA_STRUC* ppTmpDsaStruc[1];

  //-----------------------------------------------------
  // Check parameters
  //-----------------------------------------------------
  if((pCert == NULL) || (pRequestBuf == NULL) ||
     (ppDstBuf == NULL) || (pDstLen == NULL) || (pUsedSignatType == NULL))
    return(HOCSP_NULL_PTR);

  //-----------------------------------------------------
  // Check if certificate has a usable private key, get
  // the key data for signing
  //-----------------------------------------------------
  ppTmpRsaStruc[0] = NULL;
  ppTmpDsaStruc[0] = NULL;

  PrivKeyAlgor = pCert->PrivKeyType;

  switch(PrivKeyAlgor)
  {
    case RSA_PUBLIC_ALGOR:
      if(SignatType < 0)		// should use default
        SignatType = PKCS1_SHA1_WITH_RSA_ENC;
      else
      {
        if((SignatType != PKCS1_MD2_WITH_RSA_ENC) &&
           (SignatType != PKCS1_MD5_WITH_RSA_ENC) &&
           (SignatType != PKCS1_SHA1_WITH_RSA_ENC))
          return(HOCSP_SIGN_REQ_INVALID_SIG_ALG);
      }
      if((Retcode = FromArrayDescToRSAPrivParams(HMEM_CTX_REF1 pCert->PrivKeyData,ppTmpRsaStruc)) != ASN1_OP_OK)
        return(Retcode);
      break;

    case DSA_PUBLIC_ALGOR:
      if(SignatType < 0)		// should use default
        SignatType = X957_DSA_WITH_SHA1;
      else
      {
        if(SignatType != X957_DSA_WITH_SHA1)
          return(HOCSP_SIGN_REQ_INVALID_SIG_ALG);
      }
      if((Retcode = FromArrayDescToDSAPrivParams(HMEM_CTX_REF1 pCert->PrivKeyData,ppTmpDsaStruc)) != ASN1_OP_OK)
        return(Retcode);
      break;

    default:
      return(HOCSP_SIGN_REQ_INVALID_KEYTYPE);
  }
  //----------------------------------------------------------
  // Sign the TBS data with the appropriate key and algor type
  //----------------------------------------------------------
  pUsedSignatType[0] = SignatType;
  Retcode = SignTBSData(HMEM_CTX_REF1 pRequestBuf,RequestOff,RequestLen,ppTmpRsaStruc[0],ppTmpDsaStruc[0],SignatType,ppDstBuf,pDstLen);
  RSA_Free(HMEM_CTX_REF1 ppTmpRsaStruc[0]);
  DSA_Free(HMEM_CTX_REF1 ppTmpDsaStruc[0]);
  return(Retcode);
}

/**
* Generate ASN.1 representation of a Request signature with/without
* signer's certificate (ToASN1Signature).
*
*
*  @param pSignatBuf Buffer with the signature
*  @param SignatOff Start of data
*  @param SignatLen Size of data
*  @param SignatType signature type used for signing
*  @param pCert Signers certificate / NULL
*  @param ppDstBuf Allocated buffer
*  @param pDstLen Size of data
*  @return 0 on success, error code otherwise
*/
static  int  ToASN1Signature(HMEM_CTX_DEF
		char* pSignatBuf, int SignatOff,
		int SignatLen, int SignatType, X509CERT * pCert,
		char** ppDstBuf, int* pDstLen)
{
  int Retcode;

  IDATA* pIdata;

  IDATA** pDstArr = NULL;
  IDATA** pSigArr = NULL;
  IDATA** ppTmpDatArr[1];

  IDATPARR* pDstDesc;
  IDATPARR* ppTmpDesc[1];

  //-----------------------------------------------------
  // Check parameters
  //-----------------------------------------------------
  if((pSignatBuf == NULL) || (ppDstBuf == NULL) || (pDstLen == NULL))
    return(HOCSP_NULL_PTR);

  //--------------------------------------------------------
  // Allocate conversion descriptor needed, mark as freeable
  //--------------------------------------------------------
  if((Retcode = AllocIDATPARR_Struc(HMEM_CTX_REF1 ppTmpDesc,4)) != ASN1_OP_OK)
    return(Retcode);

  pDstDesc = ppTmpDesc[0];  
  pDstArr = pDstDesc->ppArr;

  pDstDesc->Flags |= FREE_BIT_MASK;

  for(;;)
  {
    //--------------------------------------------------------
    // Allocate IDATA-Array needed for signature generation
    // NOTE: This will hold the signature data
    //--------------------------------------------------------
    if((Retcode = AllocIDATA_Array(HMEM_CTX_REF1 ppTmpDatArr,1)) != ASN1_OP_OK)
      break;

    pSigArr = ppTmpDatArr[0];

    if((Retcode = FromBufToDatArray(HMEM_CTX_REF1 pSigArr,0,pSignatBuf,SignatOff,SignatLen,0)) != ASN1_OP_OK)
      break;
    //-----------------------------------------------------------------
    // Generate Signature Algor OID, Params (NULL) and data (BITSTRING)
    //-----------------------------------------------------------------
    Retcode = SetSignatAlgAndData(HMEM_CTX_REF1 pDstArr,0,pSigArr,1,SignatType);
    FreeIDATA_Array(HMEM_CTX_REF1 pSigArr,1,0);
    pSigArr = NULL;
    if(Retcode != ASN1_OP_OK)
      break;
    //-----------------------------------------------------------------
    // Check if a certificate given, if so insert certificate
    //-----------------------------------------------------------------
    if(pCert != NULL)
    {
      pIdata = pCert->Certificate->ppArr[0];
      if((Retcode = FromBufToDatArray(HMEM_CTX_REF1 pDstArr,3,pIdata->Base,(int) pIdata->Off,pIdata->Len,1)) != ASN1_OP_OK)
      break;
    }
    Retcode = ToASN1(HMEM_CTX_REF1 pDstArr,0,(char *) OCSP_ReqSignatCtl,7,ppDstBuf,pDstLen);
    break;
  }
  FreeIDATA_Array(HMEM_CTX_REF1 pSigArr,1,0);
  FreeIDATPARR_Struc(HMEM_CTX_REF1 pDstDesc);
  return(Retcode);
}

/**
* Generate ASN.1 representation of OCSP-Nonce extension
* from given NONCE data (ToASN1_OcspNonce).
* NOTE: This is always a non critical extension
*
*  @param pSrcBuf Nonce data buffer
*  @param SrcOff Start of data
*  @param SrcLen Size of data
*  @param ppDstBuf Allocated buffer
*  @param pDstLen Size of data
*  @return 0 on success, error code otherwise
*/
static  int  ToASN1_OcspNonce(HMEM_CTX_DEF
			char* pSrcBuf, int SrcOff,
			int SrcLen, char** ppDstBuf, int* pDstLen)
{

  int Retcode;

  IDATA** pDatArr = NULL;
  IDATA** ppTmpDatArr[1];

  //-----------------------------------------------------
  // Check parameters
  //-----------------------------------------------------
  if((pSrcBuf == NULL) || (ppDstBuf == NULL) ||
     (pDstLen == NULL))
    return(HOCSP_NULL_PTR);

  if(SrcLen <= 0)
    return(HOCSP_PARAM_ERR);

  ppDstBuf[0] = NULL;
  pDstLen[0] = 0;
  //-----------------------------------------------------------
  // Get descriptor for ASN.1 conversion
  //-----------------------------------------------------------
  if((Retcode = AllocIDATA_Array(HMEM_CTX_REF1 ppTmpDatArr,3)) != ASN1_OP_OK)
    return(Retcode);

  pDatArr = ppTmpDatArr[0];

  for(;;)
  {
    //-----------------------------------------------------------
    // Set the OCSP-Nonce OID (direct, no copy)
    //-----------------------------------------------------------
    if((Retcode = FromBufToDatArray(HMEM_CTX_REF1 pDatArr,0,OCSPNonceBaseOID,0,9,0)) != ASN1_OP_OK)
      break;
    //-----------------------------------------------------------
    // Set the Nonce data (direct, no copy)
    //-----------------------------------------------------------
    if((Retcode = FromBufToDatArray(HMEM_CTX_REF1 pDatArr,2,pSrcBuf,SrcOff,SrcLen,0)) != ASN1_OP_OK)
      break;
    //-----------------------------------------------------------
    // Generate ASN.1 encoding
    //-----------------------------------------------------------
    Retcode = ToASN1(HMEM_CTX_REF1 pDatArr,0,(char *) OCSP_ExtCtl,4,ppDstBuf,pDstLen);
    break;
  }
  FreeIDATA_Array(HMEM_CTX_REF1 pDatArr,3,0);
  return(Retcode);
}

/**
* Generates an OCSP request from a list of certificates. The request can be 
* either signed or  unsigned (GenerateOCSPRequest).
*
*  @param pCertList Array of certificates
*  @param CertCount Number of certificates in list
*  @param HashAlgorType Hash algorithm to use
*  @param pSignerCert Certificate for signing
*  @param SignatType Either specific or ANY
*  @param ProcessFlags Bit 0: 1 - don't sign anyway
*               Bit 1: 1 - don't send nonce
*  @param ppOcspReq Structure with data to send
*
*  @return 0 on success, error code otherwise
*/
extern "C"  int  GenerateOCSPRequest(HMEM_CTX_DEF
		X509CERT ** pCertList,
		int CertCount, int HashAlgorType, X509CERT * pSignerCert,
		int SignatType, int ProcessFlags,
		HOCSREQ ** ppOcspReq)
{
  int Retcode;
  int TbsRequestLen;

  char* pTbsRequestBuf = NULL;

  int pTmpLen[1];
  int pTmpSigType[1];

  char* ppTmpBuf[1];
  char* ppTmpBufHlp[1];

  IDATA* pIdata;
  IDATA** pDatArr = NULL;
  IDATA** ppTmpDatArr[1];

  IDATPARR* ppTmpDesc[1];

  HOCSREQ * pReqStruc = NULL;
  HOCSCID ** ppTmpCertIdList[1];

  //-----------------------------------------------------
  // Check parameters
  //-----------------------------------------------------
  if((pCertList == NULL) || (ppOcspReq == NULL))
    return(HOCSP_NULL_PTR);

  if(CertCount <= 0)
    return(HOCSP_PARAM_ERR);

  ppOcspReq[0] = NULL;

  //----------------------------------------------------
  // Allcoate the Request structure
  //----------------------------------------------------
  if((pReqStruc = AllocOcspReqStruc(HMEM_CTX_REF)) == NULL)
    return(HOCSP_ALLOC_ERR);

  pReqStruc->SignatType = SignatType;

  for(;;)	// Error FOR
  {
    //====================================================
    // A) Generate the TBS Request elements
    //====================================================

    //----------------------------------------------------
    // 1.1. Generate the list of request structures
    //----------------------------------------------------
    if((Retcode = BuildOcspCertIdList(HMEM_CTX_REF1
			pCertList, CertCount,
			HashAlgorType,ppTmpCertIdList)) != HOCSP_OP_OK)
      break;

    pReqStruc->pCertIdList = ppTmpCertIdList[0];
    pReqStruc->CertIdCount = CertCount;
    //----------------------------------------------------
    // 1.2. Generate ASN.1 Representation of List
    //----------------------------------------------------
    if((Retcode = ToASN1RequestList(HMEM_CTX_REF1
				    ppTmpCertIdList[0], CertCount,
				    ppTmpBuf, pTmpLen)) != HOCSP_OP_OK)
      break;

    ppTmpDesc[0] = pReqStruc->RequestList;

    if((Retcode = FromBufToDesc(HMEM_CTX_REF1 ppTmpBuf[0],0,pTmpLen[0],0,1,ppTmpDesc)) != ASN1_OP_OK)
    {
      FREE_CARRAY(HMEM_CTX_REF,ppTmpBuf[0]);
      break;
    }
    ppTmpBuf[0] = NULL;
    //--------------------------------------------------------
    // 2. Generate requestor name if request is to be signed
    //--------------------------------------------------------
    if((pSignerCert != NULL) &&
       ((ProcessFlags & OCSP_PROC_FLAG_DONT_SIGN) == 0))
    {
      if((Retcode = ToASN1RequestorName(HMEM_CTX_REF1
				pSignerCert->SubjectNameOcsp,
				ppTmpBuf, pTmpLen)) != HOCSP_OP_OK)
        break;

      ppTmpDesc[0] = pReqStruc->RequestorName;
   
      if((Retcode = FromBufToDesc(HMEM_CTX_REF1 ppTmpBuf[0],0,pTmpLen[0],0,1,ppTmpDesc)) != ASN1_OP_OK)
      {
        FREE_CARRAY(HMEM_CTX_REF,ppTmpBuf[0]);
        break;
      }
      ppTmpBuf[0] = NULL;
    }
    //--------------------------------------------------------
    // 3. Generate Nonce Extension if not inhibited
    //--------------------------------------------------------
    if((ProcessFlags & OCSP_PROC_FLAG_NO_REQ_NONCE) == 0)
    {
      if((ppTmpBuf[0] = BIT8_ARRAY_ALLOC(HMEM_CTX_REF,
					 OCSP_NONCE_SIZE)) == NULL)
      {
        Retcode = HOCSP_ALLOC_ERR;
        break;
      }
      pReqStruc->pNonceData   = ppTmpBuf[0];
      pReqStruc->NonceDataLen = OCSP_NONCE_SIZE;

//      RAND_BYTES(RANDinst,ppTmpBuf[0], 0, OCSP_NONCE_SIZE);
      if((Retcode = SecDrbgRandBytes(HMEM_CTX_REF1 ppTmpBuf[0],0,OCSP_NONCE_SIZE)) != 0)
        break;

      if((Retcode = ToASN1_OcspNonce(HMEM_CTX_REF1
				     ppTmpBuf[0], 0, OCSP_NONCE_SIZE,
			             ppTmpBuf, pTmpLen)) != HOCSP_OP_OK)
        break;

      ppTmpDesc[0] = pReqStruc->RequestExt;

      if((Retcode = FromBufToDesc(HMEM_CTX_REF1 ppTmpBuf[0],0,pTmpLen[0],0,1,ppTmpDesc)) != ASN1_OP_OK)
      {
        FREE_CARRAY(HMEM_CTX_REF,ppTmpBuf[0]);
        break;
      }
      ppTmpBuf[0] = NULL;
    }
    //====================================================
    // B) Generate the ASN.1 encoded TBS request
    //====================================================
    if((Retcode = AllocIDATA_Array(HMEM_CTX_REF1 ppTmpDatArr,4)) != ASN1_OP_OK)
      break;

    pDatArr = ppTmpDatArr[0];

    pIdata = pReqStruc->RequestorName->ppArr[0];
    FromBufToDatArray(HMEM_CTX_REF1 pDatArr,1,pIdata->Base,(int) pIdata->Off,pIdata->Len,0);

    pIdata = pReqStruc->RequestList->ppArr[0];
    FromBufToDatArray(HMEM_CTX_REF1 pDatArr,2,pIdata->Base,(int) pIdata->Off,pIdata->Len,0);

    pIdata = pReqStruc->RequestExt->ppArr[0];
    FromBufToDatArray(HMEM_CTX_REF1 pDatArr,3,pIdata->Base,(int) pIdata->Off,pIdata->Len,0);

    Retcode = ToASN1(HMEM_CTX_REF1 pDatArr,0,(char *) OCSP_TbsReqCtl,6,ppTmpBuf,pTmpLen);
    
    FreeIDATA_Array(HMEM_CTX_REF1 pDatArr,4,0);

    if(Retcode != ASN1_OP_OK)
      break;

    pTbsRequestBuf = ppTmpBuf[0];
    TbsRequestLen  = pTmpLen[0];
    //====================================================
    // C) Generate signature of TBS request if a signer certificate
    //    is present and request is to be signed
    //====================================================
    if((pSignerCert != NULL) &&
       ((ProcessFlags & OCSP_PROC_FLAG_DONT_SIGN) == 0))
    {
      if((Retcode = SignTBSRequest(HMEM_CTX_REF1
			pSignerCert, SignatType,
			pTbsRequestBuf, 0, TbsRequestLen,
			ppTmpBuf, pTmpLen, pTmpSigType)) != HOCSP_OP_OK)
        break;

      pReqStruc->SignatType = pTmpSigType[0];

      Retcode = ToASN1Signature(HMEM_CTX_REF1
		  ppTmpBuf[0], 0, pTmpLen[0],
		  pTmpSigType[0], pSignerCert,ppTmpBufHlp, pTmpLen);

      FREE_CARRAY(HMEM_CTX_REF,ppTmpBuf[0]);

      if(Retcode != HOCSP_OP_OK)
        break;

      ppTmpDesc[0] = pReqStruc->Signature;

      if((Retcode = FromBufToDesc(HMEM_CTX_REF1 ppTmpBufHlp[0],0,pTmpLen[0],0,1,ppTmpDesc)) != ASN1_OP_OK)
      {
        FREE_CARRAY(HMEM_CTX_REF,ppTmpBufHlp[0]);
        break;
      }
    }

    //====================================================
    // D) Generate the OCSP request components
    //====================================================
    if((Retcode = AllocIDATA_Array(HMEM_CTX_REF1 ppTmpDatArr,2)) != ASN1_OP_OK)
      break;

    pDatArr = ppTmpDatArr[0];

    if((Retcode = FromBufToDatArray(HMEM_CTX_REF1 pDatArr,0,pTbsRequestBuf,0,TbsRequestLen,0)) != ASN1_OP_OK)
    {
      FreeIDATA_Array(HMEM_CTX_REF1 pDatArr,2,0);
      break;
    }

    pIdata = pReqStruc->Signature->ppArr[0];
    FromBufToDatArray(HMEM_CTX_REF1 pDatArr,1,pIdata->Base,(int) pIdata->Off,pIdata->Len,0);

    Retcode = ToASN1(HMEM_CTX_REF1 pDatArr,0,(char *) OCSP_ReqCtl,3,ppTmpBuf,pTmpLen);
    
    FreeIDATA_Array(HMEM_CTX_REF1 pDatArr,2,0);

    if(Retcode != ASN1_OP_OK)
      break;

//    IDATPARR_Flags(HOCSP_REQ_OCSPRequest(pReqStruc)) |= FREE_BIT_MASK;
    ppTmpDesc[0] = pReqStruc->OCSPRequest;

    Retcode = FromBufToDesc(HMEM_CTX_REF1 ppTmpBuf[0],0,pTmpLen[0],0,1,ppTmpDesc);
    break;
  }
  FREE_CARRAY(HMEM_CTX_REF,pTbsRequestBuf);

  if(Retcode != HOCSP_OP_OK)
    FreeOcspReqStruc(HMEM_CTX_REF1 pReqStruc);
  else
    ppOcspReq[0] = pReqStruc;

  return(Retcode);
}

//()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()
//
// OCSP Response handler functions
//
//()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()

/**
* Free an OCSP single response structure (FreeOCSPSingleRespStruc).
*
*  @param pSrespStruc structure to free
*/
static  void  FreeOCSPSingleRespStruc(HMEM_CTX_DEF
		HOCSRSP * pSrespStruc)
{
  if(pSrespStruc == NULL)
    return;

  FreeCertIdStruc(HMEM_CTX_REF1 pSrespStruc->pCertID);
  FREE_CARRAY(HMEM_CTX_REF,pSrespStruc->pRevocationTimeArr);
  FREE_CARRAY(HMEM_CTX_REF,pSrespStruc->pThisUpdateTimeArr);
  FREE_CARRAY(HMEM_CTX_REF,pSrespStruc->pNextUpdateTimeArr);

  FreeIDATPARR_Struc(HMEM_CTX_REF1 pSrespStruc->pSingleExtensions);

  FREE_CARRAY(HMEM_CTX_REF,pSrespStruc);
}

/**
* Allocate an OCSP single response structure with elements required (AllocOCSPSingleRespStruc).
*
*               none
*  @return HOCSP_SRESP_PTR pSrespStruc / NULL if failed
*/
static  HOCSRSP *  AllocOCSPSingleRespStruc(HMEM_CTX_DEF1)
{
  HOCSRSP * pSrespStruc;
  IDATPARR* ppTmpDesc[1];
  //--------------------------------------------------------
  // Allocate structure
  //--------------------------------------------------------
  pSrespStruc = (HOCSRSP *)
      ((void *) BIT8_ARRAY_CALLOC(HMEM_CTX_REF,1, sizeof(HOCSRSP)));
  if(pSrespStruc == NULL)
    return(NULL);

  pSrespStruc->CertStatus  = OCSP_CERT_STATUS_INVALID;
  pSrespStruc->RequestID   = OCSP_REQUEST_ID_INVALID;
  pSrespStruc->RevocationReason = OCSP_REVOC_REASON_INVALID;

  if(AllocIDATPARR_Struc(HMEM_CTX_REF1 ppTmpDesc,1) != ASN1_OP_OK)
  {
    FREE_CARRAY(HMEM_CTX_REF,pSrespStruc);
    return(NULL);
  }
  pSrespStruc->pSingleExtensions = ppTmpDesc[0];
  return(pSrespStruc);
}

/**
* Free a list of Single Response structures (FreeResponseList).
*
*  @param pRespList list of responses
*  @param ResponseCount number of elements in list
*/
static  void  FreeResponseList(HMEM_CTX_DEF
	HOCSRSP ** pRespList, int ResponseCount)
{
  if(pRespList == NULL)
    return;
  while(ResponseCount > 0)  
  {
    ResponseCount--;
    FreeOCSPSingleRespStruc(HMEM_CTX_REF1 pRespList[ResponseCount]);
  }
  FREE_CARRAY(HMEM_CTX_REF,pRespList);
}

/**
* Frees an Ocsp response structure (FreeOcspRespStruc).
*
*  @param pRespStruc Structure to be freed
*/
extern "C"  void  FreeOcspRespStruc(HMEM_CTX_DEF
				HOCRESP * pRespStruc)
{
  if(pRespStruc == NULL)
    return;
  //------------------------------------------------
  // Free the response list
  //------------------------------------------------
  FreeResponseList(HMEM_CTX_REF1
		   pRespStruc->pResponseList,
		   pRespStruc->ResponseCount);
  //------------------------------------------------
  // Free the ProducedAt time array
  //------------------------------------------------
  FREE_ARRAY(HMEM_CTX_REF,pRespStruc->pProducedAtTime);
  //-------------------------------------------------------
  // Free the certificate list
  //-------------------------------------------------------
  FreeCertList(HMEM_CTX_REF1 pRespStruc->pCertList,pRespStruc->CertsCount);
  //-------------------------------------------------------
  // Free the NONCE data and Responder Key Hash
  //------------------------------------------------
  FREE_ARRAY(HMEM_CTX_REF,pRespStruc->pNonceData);
  FREE_CARRAY(HMEM_CTX_REF,pRespStruc->pResponderKeyHash);
  //----------------------------------------------------------
  // Free TBS response, Responder name, Responder key hash
  // Signature algor/params, Signature and Response extensions
  //----------------------------------------------------------
  FreeIDATPARR_Struc(HMEM_CTX_REF1 pRespStruc->pTBSResponse);
  FreeIDATPARR_Struc(HMEM_CTX_REF1 pRespStruc->pResponderName);
  FreeX501DN_Struc(HMEM_CTX_REF1 pRespStruc->pResponderDNName);

//  FREE_IDATPARR_STRUC(HASN1inst,HMEM_CTX_REF,HOCSP_RESP_pResponderKeyHash(pRespStruc));
  FreeIDATPARR_Struc(HMEM_CTX_REF1 pRespStruc->pSignatAlgor);
  FreeIDATPARR_Struc(HMEM_CTX_REF1 pRespStruc->pResponseExts);
  FreeIDATPARR_Struc(HMEM_CTX_REF1 pRespStruc->pSignature);

  FREE_CARRAY(HMEM_CTX_REF,pRespStruc);
}

/**
* Allocate, initialize an Ocsp response structure  (AllocOcspRespStruc).
*
*               none
*  @return HOCSP_RESP_PTR pRespStruc / NULL
*/
static  HOCRESP *  AllocOcspRespStruc(HMEM_CTX_DEF1)
{

  HOCRESP * pRespStruc = NULL;

  IDATPARR* pTmpDesc[1];

  pRespStruc = (HOCRESP *)
      ((void*) BIT8_ARRAY_CALLOC(HMEM_CTX_REF,1, sizeof(HOCRESP)));
  if(pRespStruc == NULL)
    return(NULL);
  //---------------------------------------------------------
  // Initialize variables
  //---------------------------------------------------------
  pRespStruc->ResponseStatus    = OCSP_RESP_STATUS_INVALID;
  pRespStruc->Version           = OCSP_RESP_VERSION_INVALID;
  pRespStruc->ResponderIDType   = OCSP_RESP_RESPONDER_ID_INVALID;
  pRespStruc->SignatAlgor       = INVALID_ALGOR;
  pRespStruc->SignatType        = INVALID_ALGOR;
  pRespStruc->SignatVerifyState = OCSP_RESP_SIGNAT_NOT_VERIFIED;
  //----------------------------------------------------------
  // Allocate the Element Descriptors
  //----------------------------------------------------------
  for(;;)
  {
    if(AllocIDATPARR_Struc(HMEM_CTX_REF1 pTmpDesc,1) != ASN1_OP_OK)
      break;
    pRespStruc->pTBSResponse = pTmpDesc[0];

    if(AllocIDATPARR_Struc(HMEM_CTX_REF1 pTmpDesc,1) != ASN1_OP_OK)
      break;
    pRespStruc->pResponderName = pTmpDesc[0];

//    if(ALLOC_IDATPARR_STRUC(HASN1inst,HMEM_CTX_REF,
//			      pTmpDesc,1) != ASN1_OP_OK)
//      break;
//    HOCSP_RESP_pResponderKeyHash(pRespStruc) = pTmpDesc[0];

    if(AllocIDATPARR_Struc(HMEM_CTX_REF1 pTmpDesc,2) != ASN1_OP_OK)
      break;
    pRespStruc->pSignatAlgor = pTmpDesc[0];

    if(AllocIDATPARR_Struc(HMEM_CTX_REF1 pTmpDesc,1) != ASN1_OP_OK)
      break;
    pRespStruc->pSignature = pTmpDesc[0];

    if(AllocIDATPARR_Struc(HMEM_CTX_REF1 pTmpDesc,1) != ASN1_OP_OK)
      break;
    pRespStruc->pResponseExts = pTmpDesc[0];

    return(pRespStruc);
  }
  FreeOcspRespStruc(HMEM_CTX_REF1 pRespStruc);
  return(NULL);
}

/**
* Split an OCSP CertID ASN.1 encoding and put to a structure (FromASN1_OCSPCertID).
*
*  @param pSrcBuf Buffer with ASN.1 data
*  @param SrcOff Start of data
*  @param SrcLen Size of data
*  @param ppCertIdStruc allocated filled
*  @return 0 on success, error code otherwise
*/
static  int  FromASN1_OCSPCertID(HMEM_CTX_DEF
		char* pSrcBuf, int SrcOff, int SrcLen,
		HOCSCID ** ppCertIdStruc)
{
  HOCSCID * pCertIdStruc;

  int Retcode;

  IDATA* pIdata;
  IDATA** pDatArr = NULL;
  IDATA** ppTmpDatArr[1];

  //-----------------------------------------------------
  // Check parameters
  //-----------------------------------------------------
  if((pSrcBuf == NULL) || (ppCertIdStruc == NULL))
    return(HOCSP_NULL_PTR);

  ppCertIdStruc[0] = NULL;

  //------------------------------------------------------
  // Allocate the base structure
  //------------------------------------------------------
  if((pCertIdStruc = AllocCertIdStruc(HMEM_CTX_REF)) == NULL)
    return(HOCSP_ALLOC_ERR);

  for(;;)
  {
    //----------------------------------------------------
    // Allocate helper structure for split, split ASN.1
    //----------------------------------------------------
    if((Retcode = AllocIDATA_Array(HMEM_CTX_REF1 ppTmpDatArr,5)) != ASN1_OP_OK)
      break;
    pDatArr = ppTmpDatArr[0];

    if((Retcode = FromASN1(HMEM_CTX_REF1 pSrcBuf,SrcOff,SrcLen,(char *) OCSP_CertIDCtl,7,pDatArr,0)) != ASN1_OP_OK)
      break;
    //----------------------------------------------------
    // Put elements to structure:
    // 1. Hash algorithm description
    //----------------------------------------------------
    if((Retcode = AllocCopyDatArrayElements(HMEM_CTX_REF1 pDatArr,0,pCertIdStruc->HashAlgor->ppArr,0,2,1)) != ASN1_OP_OK)
      break;

    pCertIdStruc->HashAlgor->Flags |= FREE_BIT_MASK;
    //----------------------------------------------------
    // 2. Issuer name hash
    //----------------------------------------------------
    if((Retcode = AllocCopyDatArrayElements(HMEM_CTX_REF1 pDatArr,2,pCertIdStruc->IssuerNameHash->ppArr,0,1,1)) != ASN1_OP_OK)
      break;

    pCertIdStruc->IssuerNameHash->Flags |= FREE_BIT_MASK;
    //----------------------------------------------------
    // 3. Issuer public key hash
    //----------------------------------------------------
    if((Retcode = AllocCopyDatArrayElements(HMEM_CTX_REF1 pDatArr,3,pCertIdStruc->IssuerKeyHash->ppArr,0,1,1)) != ASN1_OP_OK)
      break;

    pCertIdStruc->IssuerKeyHash->Flags |= FREE_BIT_MASK;
    //----------------------------------------------------
    // 4. Certificate serial number
    //----------------------------------------------------
    if((Retcode = AllocCopyDatArrayElements(HMEM_CTX_REF1 pDatArr,4,pCertIdStruc->SerialNumber->ppArr,0,1,1)) != ASN1_OP_OK)
      break;

    pCertIdStruc->SerialNumber->Flags |= FREE_BIT_MASK;
    
    FreeIDATA_Array(HMEM_CTX_REF1 pDatArr,5,0);
    pDatArr = NULL;
    //--------------------------------------------------------
    // 5. Verify that the hash algorithm is SHA-1
    //    NOTE: as we send the requests with SHA-1 we expect
    //    ----- also SHA-1 in responses !!
    //--------------------------------------------------------
    pIdata = pCertIdStruc->HashAlgor->ppArr[0];
    if((pIdata->Len != 5) ||
       (LclCmpBit8Arrays(pIdata->Base, (int) pIdata->Off,
                OCSP_Sha1HashOID, 0, 5) != ASN1_SAME))
    {
      Retcode = HOCSP_SRESP_INVALID_HASH_ALGOR;
      break;
    }
    pCertIdStruc->HashAlgorType   = OCSP_HASH_ALGOR_SHA1;

    ppCertIdStruc[0] = pCertIdStruc;
    return(HOCSP_OP_OK);
  }

  FreeIDATA_Array(HMEM_CTX_REF1 pDatArr,5,0);
  FreeCertIdStruc(HMEM_CTX_REF1 pCertIdStruc);
  return(Retcode);
}

/**
* Check if an extension list contains any critical extensions (CheckExtensionListForCritical).
*
*  @param pSrcBuf Buffer with ASN.1 data (Extensions)
*  @param SrcOff Start of data
*  @param SrcLen Size of data
*  @param pResult == 0 - no critical extension found
*               > 0 - there is at least one critical
*  @return 0 on success, error code otherwise
*/
static  int  CheckExtensionListForCritical(HMEM_CTX_DEF
	char* pSrcBuf, int SrcOff, int SrcLen, int* pResult)
{
  int Retcode;
  int Index, ElementBaseIndex;
  int ExtensionCount;

  int pTmpCnt[1];
  int pTmpErr[1];

  IDATPARR* pExtensionsDesc = NULL;

  IDATPARR* ppTmpDesc[1];

  pResult[0] = 0;
  //---------------------------------------------------------------------
  // Subdecode the Extensions(list) into single Elements.
  // Each Element consists of 3 Entries:
  // Type [OID], Critical[BOOL], Value[OCTETSTRING]
  //---------------------------------------------------------------------
  if((Retcode = FromASN1_EXT(HMEM_CTX_REF1 pSrcBuf,SrcOff,SrcLen,ppTmpDesc,pTmpCnt,pTmpErr)) != ASN1_OP_OK)
    return(Retcode);

  pExtensionsDesc = ppTmpDesc[0];
  ExtensionCount = pTmpCnt[0] / X509_EXT_MAX_DATA_INDEX;
  //---------------------------------------------------------------------
  // Process the Elements until a critical is found or end of list
  //---------------------------------------------------------------------
  Index = 0;
  ElementBaseIndex = 0;

  Retcode = HOCSP_OP_OK;
  while(Index < ExtensionCount)
  {
    //------------------------------------------------------
    // Check if extension is marked critical
    //------------------------------------------------------
    if((Retcode = GetOptBoolValueFromDesc(pExtensionsDesc,ElementBaseIndex + X509_EXT_CRITICAL_INDEX,1,0,pTmpCnt)) != ASN1_OP_OK)
      break;

    if(pTmpCnt[0] > 0)
    {
      pResult[0] = 1;
      break;
    }
    Index ++;
    ElementBaseIndex += X509_EXT_MAX_DATA_INDEX;
  }
  FreeIDATPARR_Struc(HMEM_CTX_REF1 pExtensionsDesc);
  return(Retcode);
}

/**
* Split an OCSP SingleResponse ASN.1 encoding and put to a
* structure (FromASN1_OCSPSingleResponse).
*
*  @param pSrcBuf Buffer with ASN.1 data
*  @param SrcOff Start of data
*  @param SrcLen Size of data
*  @param ppSrespStruc allocated filled
*  @return 0 on success, error code otherwise
*/
static  int  FromASN1_OCSPSingleResponse(HMEM_CTX_DEF
	char* pSrcBuf, int SrcOff, int SrcLen,
	HOCSRSP ** ppSrespStruc)
{

  int Retcode;
  int CertStatus;
  int RevocReason;
  int Index;

  int* pTimeArr;

  int pTmpResult[1];

  IDATA* pIdata;
  IDATA** pDatArr = NULL;
  IDATA** ppTmpDatArr[1];
  HOCSRSP * pSrespStruc;

  HOCSCID * ppTmpCertIdStruc[1];

  //-----------------------------------------------------
  // Check parameters
  //-----------------------------------------------------
  if((pSrcBuf == NULL) || (ppSrespStruc == NULL))
    return(HOCSP_NULL_PTR);

  ppSrespStruc[0] = NULL;

  //------------------------------------------------------
  // Allocate the base structure
  //------------------------------------------------------
  if((pSrespStruc = AllocOCSPSingleRespStruc(HMEM_CTX_REF)) == NULL)
    return(HOCSP_ALLOC_ERR);

  for(;;)
  {
    //----------------------------------------------------
    // Allocate helper structure for split, split ASN.1
    //----------------------------------------------------
    if((Retcode = AllocIDATA_Array(HMEM_CTX_REF1 ppTmpDatArr,8)) != ASN1_OP_OK)
      break;

    pDatArr = ppTmpDatArr[0];
    
    if((Retcode = FromASN1(HMEM_CTX_REF1 pSrcBuf,SrcOff,SrcLen,(char *) OCSP_SingleRespCtl,13,pDatArr,0)) != ASN1_OP_OK)
      break;

    //----------------------------------------------------
    // 1. Subdecode ASN.1 CertID encoding to structure
    //----------------------------------------------------
    pIdata = pDatArr[0];

    if((Retcode = FromASN1_OCSPCertID(HMEM_CTX_REF1
				      pIdata->Base,
				      (int) pIdata->Off,
				      pIdata->Len,
				      ppTmpCertIdStruc)) != HOCSP_OP_OK)
      break;

    pSrespStruc->pCertID = ppTmpCertIdStruc[0];

    //----------------------------------------------------
    // 2. Check what Certificate Status has been returned
    //----------------------------------------------------
    CertStatus = OCSP_CERT_STATUS_INVALID;
    pIdata = pDatArr[1];
    if((pIdata->Base != NULL) && (pIdata->Len > 0))
    {
      //---------------------------------------------------------
      // Good Index found, check Data are correct ITAG[0] of NULL
      //---------------------------------------------------------
      Index = (int) pIdata->Off;
      if((pIdata->Len != 0x02) ||
         ((unsigned char) pIdata->Base[Index] !=
            (unsigned char) ASN1_CLASS_CONTEXT_SPECIFIC) ||
         (pIdata->Base[Index+1] != (unsigned char) 0x00))
      {
        Retcode = HOCSP_SRESP_INVALID_GOOD_STATUS;
        break;
      }
      CertStatus = OCSP_CERT_STATUS_GOOD;
    }

    pIdata = pDatArr[2];
    if((pIdata->Base != NULL) && (pIdata->Len > 0))
    {
      //---------------------------------------------------------
      // Revoked status found, check if Status already set
      //---------------------------------------------------------
      if(CertStatus != OCSP_CERT_STATUS_INVALID)
      {
        Retcode = HOCSP_SRESP_MULTI_CERT_STATUS;
        break;
      }
      CertStatus = OCSP_CERT_STATUS_REVOKED;
      //---------------------------------------------------------
      // Store the revocation time in internal array format
      //---------------------------------------------------------
      if((pTimeArr = INT_ARRAY_ALLOC(HMEM_CTX_REF,
				     TIME_ARRAY_SIZE)) == NULL)
      {
        Retcode = HOCSP_ALLOC_ERR;
        break;
      }
      pSrespStruc->pRevocationTimeArr = pTimeArr;

      if((Retcode = ConvChkASN1_TimeStr(pIdata->Base,(int) pIdata->Off,pIdata->Len,pTimeArr,ASN1_TIME_TYPE_GENTIME)) != ASN1_OP_OK)
        break;
      //---------------------------------------------------------
      // Store the revocation reason if given
      //---------------------------------------------------------
      pSrespStruc->RevocationReason = OCSP_REVOC_REASON_INVALID;

      pIdata = pDatArr[3];

      if((pIdata->Base != NULL) && (pIdata->Len > 0))
      {
        RevocReason = (int)
          pIdata->Base[(int) pIdata->Off] & 0xFF;

        if((pIdata->Len != 1) ||
           (RevocReason == OCSP_REVOC_REASON_UNUSED) ||
           (RevocReason > OCSP_REVOC_REASON_REMOVE_CRL))
        {
          Retcode = HOCSP_SRESP_INVALID_REV_REASON; 
          break;
        }
        pSrespStruc->RevocationReason = RevocReason;
      }
    }

    pIdata = pDatArr[4];
    if((pIdata->Base != NULL) && (pIdata->Len > 0))
    {
      //---------------------------------------------------------
      // 'Unknown' status found, check if Status already set
      //---------------------------------------------------------
      if(CertStatus != OCSP_CERT_STATUS_INVALID)
      {
        Retcode = HOCSP_SRESP_MULTI_CERT_STATUS;
        break;
      }
      //-------------------------------------------------------------------
      // Check if this is ITAG[2], according to spec any data may follow...
      //-------------------------------------------------------------------
      if((unsigned char) pIdata->Base[(int) pIdata->Off] !=
           (unsigned char) (ASN1_CLASS_CONTEXT_SPECIFIC | 0x02))
      {
        Retcode = HOCSP_SRESP_INVALID_UNK_STATUS;
        break;
      }
      CertStatus = OCSP_CERT_STATUS_UNKNOWN;
    }

    if(CertStatus == OCSP_CERT_STATUS_INVALID)
    {
      Retcode = HOCSP_SRESP_MISSING_CERT_STATUS;
      break;
    }
    pSrespStruc->CertStatus = CertStatus;
    //---------------------------------------------------------
    // 3. Store the 'ThisUpdate' time in internal array format
    //---------------------------------------------------------
    pIdata = pDatArr[5];

    if((pTimeArr = INT_ARRAY_ALLOC(HMEM_CTX_REF,
				   TIME_ARRAY_SIZE)) == NULL)
    {
      Retcode = HOCSP_ALLOC_ERR;
      break;
    }
    pSrespStruc->pThisUpdateTimeArr = pTimeArr;

    if((Retcode = ConvChkASN1_TimeStr(pIdata->Base,(int) pIdata->Off,pIdata->Len,pTimeArr,ASN1_TIME_TYPE_GENTIME)) != ASN1_OP_OK)
      break;

    //-------------------------------------------------------------
    // 4. Store 'NextUpdate' time if pres. in internal array format
    //-------------------------------------------------------------
    pIdata = pDatArr[6];
    if((pIdata->Base != NULL) && (pIdata->Len > 0))
    {
      if((pTimeArr = INT_ARRAY_ALLOC(HMEM_CTX_REF,
				     TIME_ARRAY_SIZE)) == NULL)
      {
        Retcode = HOCSP_ALLOC_ERR;
        break;
      }
      pSrespStruc->pNextUpdateTimeArr = pTimeArr;

      if((Retcode = ConvChkASN1_TimeStr(pIdata->Base,(int) pIdata->Off,pIdata->Len,pTimeArr,ASN1_TIME_TYPE_GENTIME)) != ASN1_OP_OK)
        break;
    }
    //-------------------------------------------------------------
    // 5. Store Extensions if present (NOTE: do a copy !!)
    //-------------------------------------------------------------
    pIdata = pDatArr[7];
    if((pIdata->Base != NULL) && (pIdata->Len > 0))
    {
      if((Retcode = FromBufToDatArray(HMEM_CTX_REF1 pSrespStruc->pSingleExtensions->ppArr,0,pIdata->Base,(int) pIdata->Off,pIdata->Len,1)) != ASN1_OP_OK)
        break;
      pSrespStruc->pSingleExtensions->Flags |= FREE_BIT_MASK;
      //-------------------------------------------------------------
      // 5.1 Check if any extension marked critical
      //-------------------------------------------------------------
      if((Retcode = CheckExtensionListForCritical(HMEM_CTX_REF1
		        pIdata->Base,
			(int) pIdata->Off,
			pIdata->Len,
			pTmpResult)) != HOCSP_OP_OK)
        break;

      if(pTmpResult[0] != 0)
      {
        Retcode = HOCSP_SRESP_UNKNOWN_CRIT_EXT;
        break;
      }
    }
    break;    
  }
  FreeIDATA_Array(HMEM_CTX_REF1 pDatArr,8,0);
  if(Retcode != HOCSP_OP_OK)
    FreeOCSPSingleRespStruc(HMEM_CTX_REF1 pSrespStruc);
  else
    ppSrespStruc[0] = pSrespStruc;

  return(Retcode);
}

/**
* Split an OCSP ResponseList ASN.1 encoding into single responses,
* convert each SingleResponse to internal structure (FromASN1_OCSPResponseList).
*
*  @param pSrcBuf Buffer with ASN.1 data
*  @param SrcOff Start of data
*  @param SrcLen Size of data
*  @param ppRespList list of responses
*  @param pResponseCount
*  @return 0 on success, error code otherwise
*/
static  int  FromASN1_OCSPResponseList(HMEM_CTX_DEF
		char* pSrcBuf,
		int SrcOff, int SrcLen, HOCSRSP *** ppRespList,
		int* pResponseCount)
{

  int Retcode;
  int ListEntries;
  int Index;

  IDATA* pIdata;
  int pTmpCnt[1];

  IDATA** pListArr;
  IDATPARR* pListDesc = NULL;
  IDATPARR* ppTmpDesc[1];

  HOCSRSP ** pRespList = NULL;
  HOCSRSP * ppTmpSresp[1];

  //-----------------------------------------------------
  // Check parameters
  //-----------------------------------------------------
  if((pSrcBuf == NULL) || (ppRespList == NULL) || (pResponseCount == NULL))
    return(HOCSP_NULL_PTR);

  ppRespList[0] = NULL;
  pResponseCount[0] = 0;

  //---------------------------------------------------------
  // Split the list of responses into SingleResponse elements
  //---------------------------------------------------------
  if((Retcode = FromASN1_SubStr(HMEM_CTX_REF1 pSrcBuf,SrcOff,SrcLen,(char *) OCSP_RespListCtl,1,1,ppTmpDesc,pTmpCnt)) != ASN1_OP_OK)
    return(Retcode);

  pListDesc = ppTmpDesc[0];
  pListArr  = pListDesc->ppArr;
  ListEntries = pTmpCnt[0];
  for(;;)
  {
    //---------------------------------------------------------
    // Allocate Response List Pointer array
    //---------------------------------------------------------
    pRespList = (HOCSRSP **)
      ((void *) BIT8_ARRAY_CALLOC(HMEM_CTX_REF,
				  1, ListEntries * sizeof(HOCSRSP *)));
    if(pRespList == NULL)
      break;
    //---------------------------------------------------------
    // Convert all the entries to SingleResponse structures
    //---------------------------------------------------------
    Index = 0;
    Retcode = HOCSP_OP_OK;
    while(Index < ListEntries)
    {
      pIdata = pListArr[Index]; 

      if((Retcode = FromASN1_OCSPSingleResponse(HMEM_CTX_REF1
			pIdata->Base,
			(int) pIdata->Off, pIdata->Len,
			ppTmpSresp)) != HOCSP_OP_OK)
        break;

      pRespList[Index] = ppTmpSresp[0];
      Index++;
    }
    break;
  }
  FreeIDATPARR_Struc(HMEM_CTX_REF1 pListDesc);
  if(Retcode != HOCSP_OP_OK)
    FreeResponseList(HMEM_CTX_REF1 pRespList, ListEntries);
  else
  {
    ppRespList[0] = pRespList;
    pResponseCount[0] = ListEntries;
  }
  return(Retcode);
}

/**
* Extract nonce data from OCSP Response extensions if included
* and put to a structure (ExtractResponseNonceData).
*
*  @param pSrcBuf Buffer with ASN.1 data (Extensions)
*  @param SrcOff Start of data
*  @param SrcLen Size of data
*  @param pRespStruc structure
*  @return 0 on success, error code otherwise
*/
static  int  ExtractResponseNonceData(HMEM_CTX_DEF
		char* pSrcBuf,
		int SrcOff, int SrcLen, HOCRESP * pRespStruc)
{
  int Retcode;
  int Index, ElementBaseIndex;
  int ExtensionCount;
  int NonceLen = 0;

  char* pTmpBuf;

  int pTmpCnt[1];
  int pTmpErr[1];

  IDATA* pIdata;

  IDATA** pDatArr;
  IDATPARR* pExtensionsDesc = NULL;

  IDATPARR* ppTmpDesc[1];

  //---------------------------------------------------------------------
  // Subdecode the Extensions(list) into single Elements.
  // Each Element consists of 3 Entries:
  // Type [OID], Critical[BOOL], Value[OCTETSTRING]
  //---------------------------------------------------------------------
  if((Retcode = FromASN1_EXT(HMEM_CTX_REF1 pSrcBuf,SrcOff,SrcLen,ppTmpDesc,pTmpCnt,pTmpErr)) != ASN1_OP_OK)
    return(Retcode);

  pExtensionsDesc = ppTmpDesc[0];
  ExtensionCount = pTmpCnt[0] / X509_EXT_MAX_DATA_INDEX;
  //---------------------------------------------------------------------
  // Process the Elements, check for OCSP Nonce OID, also check
  // for unknown critical extensions
  //---------------------------------------------------------------------
  Index = 0;
  ElementBaseIndex = 0;
  pDatArr = pExtensionsDesc->ppArr;

  Retcode = HOCSP_OP_OK;
  while(Index < ExtensionCount)
  {
    pIdata = pDatArr[ElementBaseIndex + X509_EXT_OBJID_INDEX];

    if((pIdata->Len == 9) &&
       (LclCmpBit8Arrays(pIdata->Base, (int) pIdata->Off,
                OCSPNonceBaseOID, 0, 9) == ASN1_SAME))
    {
      //----------------------------------------------
      // Found OCSP Nonce extension, copy the data
      //----------------------------------------------
      if(NonceLen > 0)				// already had a nonce!
      {
        Retcode = HOCSP_RESP_DUPLICATE_NONCE_EXT;
        break;
      }
      pIdata = pDatArr[ElementBaseIndex + X509_EXT_VALUE_INDEX];

      if((NonceLen = pIdata->Len) > 0)
      {
        if((pTmpBuf = BIT8_ARRAY_ALLOC(HMEM_CTX_REF,NonceLen)) == NULL)
        {
          Retcode = HOCSP_ALLOC_ERR;
          break;
        }
        memcpy(pTmpBuf+0,pIdata->Base+(int) pIdata->Off,NonceLen);
        pRespStruc->pNonceData   = pTmpBuf;
        pRespStruc->NonceDataLen = NonceLen;
      }
    }
    else
    {
      //------------------------------------------------------
      // is an 'Unknown' extension, check if marked critical
      //------------------------------------------------------
      if((Retcode = GetOptBoolValueFromDesc(pExtensionsDesc,ElementBaseIndex + X509_EXT_CRITICAL_INDEX,1,0,pTmpCnt)) != ASN1_OP_OK)
        break;

      if(pTmpCnt[0] > 0)
      {
        Retcode = HOCSP_RESP_UNKNOWN_CRIT_EXT;
        break;
      }
    }
    Index ++;
    ElementBaseIndex += X509_EXT_MAX_DATA_INDEX;
  }
  FreeIDATPARR_Struc(HMEM_CTX_REF1 pExtensionsDesc);
  return(Retcode);
}

/**
* Split the TBS Response data of an OCSP Basic Response ASN.1 encoding
* and put to a structure (FromASN1_BasicRespTBSRespData).
*
*  @param pSrcBuf Buffer with ASN.1 data
*  @param SrcOff Start of data
*  @param SrcLen Size of data
*  @param Flags Bit 0-3 ignored
*               Bit 4 - 1 sort DN, else don't sort
*               BIT 5-... ignored
*  @param pRespStruc structure
*  @return 0 on success, error code otherwise
*/
static  int  FromASN1_BasicRespTBSRespData(HMEM_CTX_DEF
	char* pSrcBuf, int SrcOff, int SrcLen,
	int Flags, HOCRESP * pRespStruc)
{

  int Retcode;
  int ResponseVersion;
  int ResponderIDType;

  char* pBuf;
  int* pTimeArr;
  
  int pTmpCnt[1];
  int pTmpBit32Val[1];

  IDATA* pIdata;
  IDATA** pDatArr = NULL;
  IDATA** ppTmpDatArr[1];

  X501_DN* ppTmpDnName[1];

  HOCSRSP ** ppTmpRespList[1];

  //-----------------------------------------------------
  // Check parameters
  //-----------------------------------------------------
  if((pSrcBuf == NULL) || (pRespStruc == NULL))
    return(HOCSP_NULL_PTR);

  for(;;)
  {
    //--------------------------------------------------------
    // Allocate helper structure for split of TBS, split ASN.1
    //--------------------------------------------------------
    if((Retcode = AllocIDATA_Array(HMEM_CTX_REF1 ppTmpDatArr,6)) != ASN1_OP_OK)
      break;

    pDatArr = ppTmpDatArr[0];

    if((Retcode = FromASN1(HMEM_CTX_REF1 pSrcBuf,SrcOff,SrcLen,(char *) OCSP_RespDataCtl,11,pDatArr,0)) != ASN1_OP_OK)
      break;

    //----------------------------------------------------
    // 1. Subdecode ASN.1 Version (need not be present)
    //----------------------------------------------------
    ResponseVersion = OCSP_RESP_VERSION_INVALID;
    pIdata = pDatArr[0];
    if((pIdata->Base == NULL) || (pIdata->Len <= 0))
    {
      ResponseVersion = 0;			// Signal DEFAULT
    }
    else
    {
      if(pIdata->Len > 4)			// is invalid anyway
      {
        Retcode = HOCSP_RESP_INVALID_VERS_NUM;
        break;
      }
      if((Retcode = ByteBufToUnsignedBIT32Num(pIdata->Base,(int) pIdata->Off,pIdata->Len,pTmpBit32Val)) != ASN1_OP_OK)
        break;
      ResponseVersion = (int) pTmpBit32Val[0];
    }
    if(ResponseVersion != OCSP_RESP_VERSION_V1)
    {
      Retcode = HOCSP_RESP_UNKNOWN_VERSION_NUM;
      break;
    }
    pRespStruc->Version = ResponseVersion;

    //----------------------------------------------------
    // 2. Save responder DN-Name if Present
    //----------------------------------------------------
    ResponderIDType = OCSP_RESP_RESPONDER_ID_INVALID;

    pIdata = pDatArr[1];
    if((pIdata->Base != NULL) && (pIdata->Len > 0))
    {
      if((Retcode = FromBufToDatArray(HMEM_CTX_REF1 pRespStruc->pResponderName->ppArr,0,pIdata->Base,(int) pIdata->Off,pIdata->Len,1)) != ASN1_OP_OK)
        break;
      pRespStruc->pResponderName->Flags |= FREE_BIT_MASK;

      // get COPY of original buffer !!
      pIdata = pRespStruc->pResponderName->ppArr[0];

      if((Retcode = FromASN1_DN(HMEM_CTX_REF1 pIdata->Base,(int) pIdata->Off,pIdata->Len,ppTmpDnName)) != ASN1_OP_OK)
        break;

      if((Flags & OCSP_PROC_FLAG_SORT_RESP_DN) != 0)
      {
        if((Retcode = SortASN1_DN(ppTmpDnName[0])) != ASN1_OP_OK)
          break;
      }
      pRespStruc->pResponderDNName = ppTmpDnName[0];
      ResponderIDType = OCSP_RESP_RESPONDER_ID_BYNAME;
    }

    //----------------------------------------------------
    // 3. Save responder key hash if Present
    //----------------------------------------------------
    pIdata = pDatArr[2];

    if((pIdata->Base != NULL) && (pIdata->Len > 0))
    {
      if(ResponderIDType != OCSP_RESP_RESPONDER_ID_INVALID)
      {
        Retcode = HOCSP_RESP_MULTI_RESPONDER_IDS; 
        break;
      }
      if(pIdata->Len != SHA_DIGEST_LEN)
      {
        Retcode = HOCSP_RESP_INVALID_KEYHASH_SIZE;
        break;
      }
      if((pBuf = BIT8_ARRAY_ALLOC(HMEM_CTX_REF,
				  SHA_DIGEST_LEN)) == NULL)
      {
        Retcode = HOCSP_ALLOC_ERR;
        break;
      }
      memcpy(pBuf+0,pIdata->Base+(int) pIdata->Off,SHA_DIGEST_LEN);

      pRespStruc->pResponderKeyHash = pBuf;
      ResponderIDType = OCSP_RESP_RESPONDER_ID_BYKEY;
    }
    if(ResponderIDType == OCSP_RESP_RESPONDER_ID_INVALID)
    {
      Retcode = HOCSP_RESP_NO_RESPONDER_ID; 
      break;
    }
    pRespStruc->ResponderIDType = ResponderIDType;
    //---------------------------------------------------------
    // 4. Store the 'ProducedAt' time in internal array format
    //---------------------------------------------------------
    pIdata = pDatArr[3];

    if((pTimeArr = INT_ARRAY_ALLOC(HMEM_CTX_REF,
				   TIME_ARRAY_SIZE)) == NULL)
    {
      Retcode = HOCSP_ALLOC_ERR;
      break;
    }
    pRespStruc->pProducedAtTime = pTimeArr;

    if((Retcode = ConvChkASN1_TimeStr(pIdata->Base,(int) pIdata->Off,pIdata->Len,pTimeArr,ASN1_TIME_TYPE_GENTIME)) != ASN1_OP_OK)
      break;
    //-------------------------------------------------------------
    // 5. Process the Response List (Subdecode etc.)
    //-------------------------------------------------------------
    pIdata = pDatArr[4];

    if((Retcode = FromASN1_OCSPResponseList(HMEM_CTX_REF1
				pIdata->Base,
				(int) pIdata->Off,
				pIdata->Len,
				ppTmpRespList, pTmpCnt)) != HOCSP_OP_OK)
      break;
    pRespStruc->pResponseList = ppTmpRespList[0];
    pRespStruc->ResponseCount = pTmpCnt[0];
    //-------------------------------------------------------------
    // 6. Store Extensions if present (NOTE: do a copy !!)
    //-------------------------------------------------------------
    pIdata = pDatArr[5];

    if((pIdata->Base != NULL) && (pIdata->Len > 0))
    {
      if((Retcode = FromBufToDatArray(HMEM_CTX_REF1 pRespStruc->pResponseExts->ppArr,0,pIdata->Base,(int) pIdata->Off,pIdata->Len,1)) != ASN1_OP_OK)
        break;
      pRespStruc->pResponseExts->Flags |= FREE_BIT_MASK;
      //----------------------------------------------------------
      // 6.1. Extension list present, extract OCSP-Nonce data
      //----------------------------------------------------------
      if((Retcode = ExtractResponseNonceData(HMEM_CTX_REF1
					 pIdata->Base,
					 (int) pIdata->Off,
					 pIdata->Len,
					 pRespStruc)) != HOCSP_OP_OK)
        break;
    }
    break;    
  }
  FreeIDATA_Array(HMEM_CTX_REF1 pDatArr,6,0);
  return(Retcode);
}

/**
* Split an OCSP Certificate List ASN.1 encoding into single certificates,
* convert each to internal structure (FromASN1_OCSPCertList).
*
*  @param pSrcBuf Buffer with ASN.1 data
*  @param SrcOff Start of data
*  @param SrcLen Size of data
*  @param ppCertList Allocated, filled list
*  @param pCertsCount Number of structures in list
*  @return 0 on success, error code otherwise
*/
static  int  FromASN1_OCSPCertList(HMEM_CTX_DEF
		char* pSrcBuf, int SrcOff, int SrcLen,
		X509CERT *** ppCertList, int* pCertsCount)
{

  int Retcode;
  int Index;
  int CertsCount;

  IDATA* pIdata;
  int pTmpCnt[1];

  IDATA** pListArr;
  IDATPARR* pListDesc = NULL;
  IDATPARR* ppTmpDesc[1];

  X509CERT ** pCertList = NULL;
  X509CERT * ppTmpCert[1];

  //-----------------------------------------------------
  // Check parameters
  //-----------------------------------------------------
  if((pSrcBuf == NULL) || (ppCertList == NULL) || (pCertsCount == NULL))
    return(HOCSP_NULL_PTR);

  ppCertList[0] = NULL;
  pCertsCount[0] = 0;

  //----------------------------------------------------------------
  // Split the list of Certificates into single certificate elements
  //----------------------------------------------------------------
  if((Retcode = FromASN1_SubStr(HMEM_CTX_REF1 pSrcBuf,SrcOff,SrcLen,(char *) OCSP_RespListCtl,1,1,ppTmpDesc,pTmpCnt)) != ASN1_OP_OK)
    return(Retcode);

  pListDesc = ppTmpDesc[0];
  pListArr  = pListDesc->ppArr;
  CertsCount = pTmpCnt[0];
  for(;;)
  {
    //---------------------------------------------------------
    // Allocate Certificate List Pointer array
    //---------------------------------------------------------
    pCertList = (X509CERT **)
      ((void *) BIT8_ARRAY_CALLOC(HMEM_CTX_REF,1,
				  CertsCount * sizeof(X509CERT *)));
    if(pCertList == NULL)
      break;
    //-----------------------------------------------------------
    // Convert all the entries to internal Certificate structures
    //-----------------------------------------------------------
    Index = 0;
    Retcode = HOCSP_OP_OK;
    while(Index < CertsCount)
    {
      pIdata = pListArr[Index]; 

      if((Retcode = FromASN1CertToCertStrucEX(HMEM_CTX_REF1 pIdata->Base,(int) pIdata->Off,pIdata->Len,0,0x03,NULL,0,ppTmpCert)) != ASN1_OP_OK)
        break;

      pCertList[Index] = ppTmpCert[0];
      Index++;
    }
    break;
  }
  FreeIDATPARR_Struc(HMEM_CTX_REF1 pListDesc);
  if(Retcode != HOCSP_OP_OK)
  {
    FreeCertList(HMEM_CTX_REF1 pCertList,CertsCount);
  }
  else
  {
    ppCertList[0]  = pCertList;
    pCertsCount[0] = CertsCount;
  }
  return(Retcode);
}

/**
* Split OCSP Basic Response data of an OCSP Response ASN.1 encoding
* and put to a structure (FromASN1_BasicResponse).
*
*  @param pSrcBuf Buffer with ASN.1 data
*  @param SrcOff Start of data
*  @param SrcLen Size of data
*  @param Flags Bit 0-3 ignored
*               Bit 4 - 1 sort DN, else don't sort
*               BIT 5-... ignored
*  @param pRespStruc structure
*  @return 0 on success, error code otherwise
*/
static  int  FromASN1_BasicResponse(HMEM_CTX_DEF
	char* pSrcBuf, int SrcOff, int SrcLen,
	int Flags, HOCRESP * pRespStruc)
{

  int Retcode;
  
  int pTmpCnt[1];
  int pTmpType[1];

  IDATA* pIdata;
  IDATA** pDatArr = NULL;
  IDATA** pTmpArr;
  IDATA** ppTmpDatArr[1];

  X509CERT ** ppTmpCertList[1];

  //-----------------------------------------------------
  // Check parameters
  //-----------------------------------------------------
  if((pSrcBuf == NULL) || (pRespStruc == NULL))
    return(HOCSP_NULL_PTR);

  for(;;)
  {
    //-------------------------------------------------------------------
    // Allocate helper structure for split of Basic Response, split ASN.1
    //-------------------------------------------------------------------
    if((Retcode = AllocIDATA_Array(HMEM_CTX_REF1 ppTmpDatArr,5)) != ASN1_OP_OK)
      break;

    pDatArr = ppTmpDatArr[0];

    if((Retcode = FromASN1(HMEM_CTX_REF1 pSrcBuf,SrcOff,SrcLen,(char *) OCSP_BasicRespCtl,8,pDatArr,0)) != ASN1_OP_OK)
      break;
    //----------------------------------------------------
    // 1. Save TBS response data (as copy)
    //----------------------------------------------------
    if((Retcode = AllocCopyDatArrayElements(HMEM_CTX_REF1 pDatArr,0,pRespStruc->pTBSResponse->ppArr,0,1,1)) != ASN1_OP_OK)
      break;

    pRespStruc->pTBSResponse->Flags |= FREE_BIT_MASK;
    //----------------------------------------------------
    // 1.1. Subdecode TBS response data
    //----------------------------------------------------
    pIdata = pDatArr[0];

    if((Retcode = FromASN1_BasicRespTBSRespData(HMEM_CTX_REF1
				pIdata->Base,
				(int) pIdata->Off,
				pIdata->Len, Flags,
				pRespStruc)) != HOCSP_OP_OK)
      break;

    //----------------------------------------------------
    // 2.1. Save Signat. Algorithm/Param elements (as copy)
    //----------------------------------------------------
    if((Retcode = AllocCopyDatArrayElements(HMEM_CTX_REF1 pDatArr,1,pRespStruc->pSignatAlgor->ppArr,0,2,1)) != ASN1_OP_OK)
      break;

    pRespStruc->pSignatAlgor->Flags |= FREE_BIT_MASK;
    //-----------------------------------------------------------------
    // 2.2. Get signature algorithm (RSA, DSA) and Type (MD5, SHA1 etc)
    //-----------------------------------------------------------------
    pTmpArr = pRespStruc->pSignatAlgor->ppArr;
    if((Retcode = GetChkSignatTypeAlg(HMEM_CTX_REF1 pTmpArr[0],pTmpArr[1],pTmpCnt,pTmpType)) != ASN1_OP_OK)
      break;

    pRespStruc->SignatAlgor = pTmpCnt[0];
    pRespStruc->SignatType  = pTmpType[0];

    //----------------------------------------------------
    // 3. Save Signature (as copy), mark descriptor freeable
    //----------------------------------------------------
    if((Retcode = AllocCopyDatArrayElements(HMEM_CTX_REF1 pDatArr,3,pRespStruc->pSignature->ppArr,0,1,1)) != ASN1_OP_OK)
      break;

    pRespStruc->pSignature->Flags |= FREE_BIT_MASK;
    //----------------------------------------------------
    // 4. Check if a Certificate List is given
    //----------------------------------------------------
    pIdata = pDatArr[4];
    if((pIdata->Base != NULL) && (pIdata->Len > 0))
    {
      //--------------------------------------------------
      // List of Certificates given, process the List
      //--------------------------------------------------
      if((Retcode = FromASN1_OCSPCertList(HMEM_CTX_REF1
				pIdata->Base,
				(int) pIdata->Off,
				pIdata->Len,
				ppTmpCertList,pTmpCnt)) != HOCSP_OP_OK)
        break;

      pRespStruc->pCertList  = ppTmpCertList[0];
      pRespStruc->CertsCount = pTmpCnt[0];
    }
    break;
  }
  FreeIDATA_Array(HMEM_CTX_REF1 pDatArr,5,0);
  return(Retcode);
}

/**
* Split OCSP response bytes ASN.1 encoding, check if type of response is
* the OCSP basic response and if so subdecode the OCSP basic response (FromASN1_ResponseBytes).
*
* 
*  @param pSrcBuf Buffer with ASN.1 data
*  @param SrcOff Start of data
*  @param SrcLen Size of data
*  @param Flags Bit 0-3 ignored
*               Bit 4 - 1 sort DN, else don't sort
*               BIT 5-... ignored
*  @param pRespStruc structure
*  @return 0 on success, error code otherwise
*/
static  int  FromASN1_ResponseBytes(HMEM_CTX_DEF
	char* pSrcBuf, int SrcOff, int SrcLen,
	int Flags, HOCRESP * pRespStruc)
{

  int Retcode;
  
  IDATA* pIdata;
  IDATA** pDatArr = NULL;
  IDATA** ppTmpDatArr[1];

  //-----------------------------------------------------
  // Check parameters
  //-----------------------------------------------------
  if((pSrcBuf == NULL) || (pRespStruc == NULL))
    return(HOCSP_NULL_PTR);

  for(;;)
  {
    //-------------------------------------------------------------------
    // Allocate helper structure for split of Response Bytes, split ASN.1
    //-------------------------------------------------------------------
    if((Retcode = AllocIDATA_Array(HMEM_CTX_REF1 ppTmpDatArr,2)) != ASN1_OP_OK)
      break;

    pDatArr = ppTmpDatArr[0];

    if((Retcode = FromASN1(HMEM_CTX_REF1 pSrcBuf,SrcOff,SrcLen,(char *) OCSP_RespBytesCtl,3,pDatArr,0)) != ASN1_OP_OK)
      break;
    //-----------------------------------------------------
    // 1. Check that the ResponseType is OCSP BasicResponse
    //-----------------------------------------------------
    pIdata = pDatArr[0];
    if((pIdata->Base != NULL) && (pIdata->Len > 0))
    {
      if((pIdata->Len != 9) ||
       (LclCmpBit8Arrays(pIdata->Base, (int) pIdata->Off,
         OCSPBasicRespBaseOID, 0, 9) != ASN1_SAME))
      {
        Retcode = HOCSP_RESP_BYTES_UNKNOWN_TYPE;
        break;
      }
    }
    else // no type specified !!!
    {
      Retcode = HOCSP_RESP_BYTES_NO_TYPE_OID;
      break;
    }
    //-----------------------------------------------------
    // 2. Subdecode the OCSPBasicResponse
    //-----------------------------------------------------
    pIdata = pDatArr[1];

    Retcode = FromASN1_BasicResponse(HMEM_CTX_REF1
				     pIdata->Base,
				     (int) pIdata->Off,
				     pIdata->Len, Flags,
		                     pRespStruc);
    break;
  }
  FreeIDATA_Array(HMEM_CTX_REF1 pDatArr,2,0);
  return(Retcode);
}

/**
* Generates an OCSP response structure from its ASN.1 representation (FromOCSPResponseToStruc).
* 
*  @param pSrcBuf Buffer with ASN.1 data
*  @param SrcOff Start of data
*  @param SrcLen Size of data
*  @param Flags Bit 0-3 ignored <br>
*               Bit 4 - 1 sort DN, else don't sort <br>
*               BIT 5-... ignored
*  @param ppRespStruc Generated response structure
*  @return 0 on success, error code otherwise
*/
extern "C"  int  FromOCSPResponseToStruc(HMEM_CTX_DEF
	char* pSrcBuf, int SrcOff, int SrcLen,
	int Flags, HOCRESP ** ppRespStruc)
{

  int Retcode;
  int ResponseStatus;
  
  IDATA* pIdata;
  IDATA** pDatArr = NULL;
  IDATA** ppTmpDatArr[1];

  HOCRESP * pRespStruc = NULL;

  //-----------------------------------------------------
  // Check parameters
  //-----------------------------------------------------
  if((pSrcBuf == NULL) || (ppRespStruc == NULL))
    return(HOCSP_NULL_PTR);

  ppRespStruc[0] = NULL;
  //-----------------------------------------------------
  // Allocate, initialize Response structure
  //-----------------------------------------------------
  if((pRespStruc = AllocOcspRespStruc(HMEM_CTX_REF)) == NULL)
    return(HOCSP_ALLOC_ERR);

  Retcode = HOCSP_OP_OK;
  for(;;)
  {
    //-------------------------------------------------------------------
    // Allocate helper structure for split of Response, split ASN.1
    //-------------------------------------------------------------------
    if((Retcode = AllocIDATA_Array(HMEM_CTX_REF1 ppTmpDatArr,2)) != ASN1_OP_OK)
      break;

    pDatArr = ppTmpDatArr[0];

    if((Retcode = FromASN1(HMEM_CTX_REF1 pSrcBuf,SrcOff,SrcLen,(char *) OCSP_RespCtl,3,pDatArr,0)) != ASN1_OP_OK)
      break;
    //-----------------------------------------------------
    // 1. Decode the returned Status, check if known
    //-----------------------------------------------------
    ResponseStatus = OCSP_RESP_STATUS_INVALID;
    pIdata = pDatArr[0];
    if((pIdata->Base != NULL) && (pIdata->Len > 0))
    {
      if(pIdata->Len != 1)
      {
        Retcode = HOCSP_RESP_INVALID_STATUS;
        break;
      }
      ResponseStatus =
        (int) pIdata->Base[(int) pIdata->Off] & 0xFF;

      if((ResponseStatus < OCSP_RESP_STATUS_SUCCESS) ||
         (ResponseStatus > OCSP_RESP_STATUS_UNAUTHORIZED) ||
         (ResponseStatus == OCSP_RESP_STATUS_UNUSED))
      {
        Retcode = HOCSP_RESP_INVALID_STATUS;
        break;
      }
      pRespStruc->ResponseStatus = ResponseStatus;
    }
    else // no status present !!
    {
      Retcode = HOCSP_RESP_NO_STATUS;
      break;
    }
    //---------------------------------------------------------
    // 2. If status is 'successful' subdecode the ResponseBytes
    //---------------------------------------------------------
    if(ResponseStatus != OCSP_RESP_STATUS_SUCCESS)
      break;

    pIdata = pDatArr[1];
    if((pIdata->Base == NULL) || (pIdata->Len <= 0))
    {
      Retcode = HOCSP_RESP_MISSING_RESP_BYTES;
      break;
    }

    Retcode = FromASN1_ResponseBytes(HMEM_CTX_REF1
				pIdata->Base,
				(int) pIdata->Off,
				pIdata->Len, Flags,
				pRespStruc);
    break;
  }
  FreeIDATA_Array(HMEM_CTX_REF1 pDatArr,2,0);

  if(Retcode != HOCSP_OP_OK)
  {
    FreeOcspRespStruc(HMEM_CTX_REF1 pRespStruc);
  }
  else
  {
    ppRespStruc[0] = pRespStruc;
  }
  return(Retcode);
}

/**
* Verifies the signature of an OCSP response (VerifyOcspResponseSignature).
*<ol>
* <li> Find certificate for OCSP responder in tree, either by name (DN) 
*     or public key hash.
* <li> Build certificate chain down to root.
* <li> Verify the certificate chain (Validity).
* <li> Verify the response signature.
*</ol>
* NOTE: The certificates in the chain may NOT be freed.
* 
*  @param pRespStruc OCSP response
*  @param pCertTree Tree from CDB file
*  @return 0 on success, error code otherwise
*/
extern "C"  int  VerifyOcspResponseSignature(HMEM_CTX_DEF
	HOCRESP * pRespStruc, CTREESTR * pCertTree)
{
  int Retcode;
  int CertsCount;
  int ChainStatus = 0;
  int VerifyStatus;
  int PublicAlgor;
  int SignatType;
  int SignRetcode;

  int MessageOffset, MessageLen;
  int SignatOffset, SignatLen;

  char* pMessageBase;
  char* pSignatBase;

  IDATA* pIdata;

  int pTmpCnt[1];
  int pTmpRootIndex[1];
  int pTmpResult[1];

  IDATPARR* pPubParVals;

  X509CERT * pSignCert;
  X509CERT ** pCertChain = NULL;
  X509CERT ** ppTmpChain[1];

  RSA_STRUC* pRsaStruc[1];
  DSA_STRUC* pDsaStruc[1];

  //-----------------------------------------------------
  // Check parameters
  //-----------------------------------------------------
  if((pRespStruc == NULL) || (pCertTree == NULL))
    return(HOCSP_NULL_PTR);

  //-----------------------------------------------------
  // Check that all required parameters are present
  //-----------------------------------------------------
  if((pRespStruc->ResponderIDType ==
        OCSP_RESP_RESPONDER_ID_INVALID) ||
     (pRespStruc->SignatType == INVALID_ALGOR))
    return(HOCSP_PARAM_ERR);

  //-----------------------------------------------------
  // Generate the Certificate chain for Responder
  //-----------------------------------------------------
  if((Retcode = GenCertChainForNameOrHash(HMEM_CTX_REF1
		  pRespStruc->pResponderDNName,
		  pRespStruc->pResponderKeyHash,
		  pRespStruc->ResponderIDType,
		  pCertTree, ppTmpChain, pTmpCnt)) != HOCSP_OP_OK)
    return(Retcode);

  pCertChain = ppTmpChain[0];
  CertsCount = pTmpCnt[0];

  if(CertsCount <= 0)
  {

    pRespStruc->SignatVerifyState = OCSP_RESP_SIGNAT_NO_CERT;
    pRespStruc->ReliabilityStatus |= OCSP_UNTRUSTED_SIGNATURE_BIT;
    return(HOCSP_OP_OK);
  }
  for(;;)
  {
    //-----------------------------------------------------------
    // A certificate chain has been retrieved, verify the chain
    //-----------------------------------------------------------
    if((Retcode = VerifyCertificateChainNew(HMEM_CTX_REF1 pCertChain,CertsCount,pCertTree,0,pTmpResult,pTmpCnt,pTmpRootIndex)) != ASN1_OP_OK)
      break;

    pRespStruc->SignatChainResult = pTmpResult[0];
    pRespStruc->SignatChainReason = pTmpCnt[0];
    if((pTmpResult[0] == 0) && (pTmpCnt[0] == 0))
      ChainStatus = 1;
    //-----------------------------------------------------------
    // First certificate in chain has the public key to use
    // Check that signature algorithm matches cert's public algor
    //-----------------------------------------------------------
    pSignCert = pCertChain[0];
    PublicAlgor = pSignCert->PublicKeyType;
    pPubParVals = pSignCert->SubjPubKeyParVal;

    pIdata = pRespStruc->pTBSResponse->ppArr[0];
    pMessageBase  = pIdata->Base;
    MessageOffset = (int) pIdata->Off;
    MessageLen    = pIdata->Len;

    pIdata = pRespStruc->pSignature->ppArr[0];
    pSignatBase   = pIdata->Base;
    SignatOffset  = (int) pIdata->Off;
    SignatLen     = pIdata->Len;

    SignatType = pRespStruc->SignatType;

    if(PublicAlgor != pRespStruc->SignatAlgor)
    {

      pRespStruc->SignatVerifyState =OCSP_RESP_SIGNAT_INV_ALGOR; 
      pRespStruc->ReliabilityStatus |= OCSP_UNTRUSTED_SIGNATURE_BIT;
      break;
    }
    //----------------------------------------------------------------
    // Distribute according to signature Algorithm
    //----------------------------------------------------------------
    switch(PublicAlgor)
    {
      //--------------------------------------------------------------
      // Signature type RSA, get the RSA structure from params
      //--------------------------------------------------------------
      case RSA_PUBLIC_ALGOR:
        if((Retcode = FromArrayDescToRSAPubParams(HMEM_CTX_REF1 pPubParVals,pRsaStruc)) != ASN1_OP_OK)
          break;

        pTmpCnt[0] = SignatLen;

        SignRetcode = RSA_sign(HMEM_CTX_REF1 SignatType,pMessageBase,MessageOffset,MessageLen,pSignatBase,SignatOffset,pTmpCnt,pRsaStruc[0],1);
        RSA_Free(HMEM_CTX_REF1 pRsaStruc[0]);

        VerifyStatus = OCSP_RESP_SIGNAT_BAD;
        if(SignRetcode == RSA_OP_OK)
        {
          if(ChainStatus == 0)			// problem with chain
            VerifyStatus = OCSP_RESP_SIGNAT_CHAIN_PROBLEM;
          else
            VerifyStatus = OCSP_RESP_SIGNAT_VERIFY_OK;
        }
        pRespStruc->SignatVerifyState = VerifyStatus;
        if(VerifyStatus != OCSP_RESP_SIGNAT_VERIFY_OK)
        {

          pRespStruc->ReliabilityStatus |=
            OCSP_UNTRUSTED_SIGNATURE_BIT;
        }
        break;
      //--------------------------------------------------------------
      // Signature type DSA, check presence of parameters, verify
      //--------------------------------------------------------------
      case DSA_PUBLIC_ALGOR:
        if((Retcode = FromArrayDescToDSAPubParams(HMEM_CTX_REF1 pPubParVals,pDsaStruc)) != ASN1_OP_OK)
          break;

	SignRetcode = DSA_Verify(HMEM_CTX_REF1 pMessageBase,MessageOffset,MessageLen,pSignatBase,SignatOffset,SignatLen,pDsaStruc[0],0);
        DSA_Free(HMEM_CTX_REF1 pDsaStruc[0]);

        VerifyStatus = OCSP_RESP_SIGNAT_BAD;
        if(SignRetcode == DSA_OP_OK)
        {
          if(ChainStatus == 0)			// problem with chain
            VerifyStatus = OCSP_RESP_SIGNAT_CHAIN_PROBLEM;
          else
            VerifyStatus = OCSP_RESP_SIGNAT_VERIFY_OK;
        }
        pRespStruc->SignatVerifyState = VerifyStatus;
        if(VerifyStatus != OCSP_RESP_SIGNAT_VERIFY_OK)
        {

          pRespStruc->ReliabilityStatus |=
            OCSP_UNTRUSTED_SIGNATURE_BIT;
        }
        break;

      default:

        pRespStruc->SignatVerifyState = OCSP_RESP_SIGNAT_INV_ALGOR;
        pRespStruc->ReliabilityStatus |=
            OCSP_UNTRUSTED_SIGNATURE_BIT;
        break;
    }
    break;
  }
  FREE_CARRAY(HMEM_CTX_REF,pCertChain);
  return(Retcode);
}

/**
* Checks the Nonces from the request and response (if returned) (CheckReqResponseNonces).
* Sets the appropriate status bits in the response structure.
*
*  @param pRespStruc OCSP response
*  @param pReqStruc OCSP request
*  @param ProcessFlags Bit 0,1 - reserved <br>
*               Bit 2 - 1 nonce required <br>
*               others reserved
*  @return 0 on success, error code otherwise
*/
extern "C"  int  CheckReqResponseNonces(HOCRESP * pRespStruc,
		HOCSREQ * pReqStruc, int ProcessFlags)
{

  //-----------------------------------------------------
  // Check parameters
  //-----------------------------------------------------
  if((pRespStruc == NULL) || (pReqStruc == NULL))
    return(HOCSP_NULL_PTR);

  //-----------------------------------------------------
  // Check if a Nonce has been sent in the Request and if
  // a Nonce has been returned
  //-----------------------------------------------------
  if((pReqStruc->pNonceData == NULL) ||
     (pReqStruc->NonceDataLen <= 0))
    return(HOCSP_OP_OK);

  if((pRespStruc->pNonceData == NULL) ||
     (pRespStruc->NonceDataLen <= 0))
  {							// no Nonce returned
    if((ProcessFlags & OCSP_PROC_FLAG_MISSING_NONCE_OK) == 0)// but IS required
    {
      pRespStruc->ReliabilityStatus |=
		OCSP_UNTRUSTED_NONCE_BIT;
    }
    return(HOCSP_OP_OK);
  }
  //-----------------------------------------------------
  // Both nonces present, compare
  //-----------------------------------------------------
  if((pReqStruc->NonceDataLen !=
      pRespStruc->NonceDataLen) ||
     (LclCmpBit8Arrays(pReqStruc->pNonceData,0,
		    pRespStruc->pNonceData,0,
		    pReqStruc->NonceDataLen) != ASN1_SAME))
  {
    pRespStruc->ReliabilityStatus |=
		OCSP_UNTRUSTED_NONCE_BIT;
  }
  return(HOCSP_OP_OK);
}

/**
* Performs reliability check on the response regarding ProducedAt (CheckProducedAtReliability).
*<ol>
* <li> ProducedAt > CurrentTime + Tolerance (minutes) -> unreliable
* <li> If response also contains a nonce (nonce already verified!)
*    ProducedAt < CurrentTime - Tolerance (minutes) -> unreliable
*</ol>
*  @param pRespStruc OCSP response
*  @param pCurrentTimeArray Current time array
*  @param DeltaMinutes Tolerance in minutes
*  @return 0 on success, error code otherwise
*/
extern "C"  int  CheckProducedAtReliability(HOCRESP * pRespStruc,
		int* pCurrentTimeArray, int DeltaMinutes)
{
  int Retcode;
  int* pProducedAtTimeArray;

  int CurrentCmpTimeArray[TIME_ARRAY_SIZE];
  int ToleranceTimeArray[TIME_ARRAY_SIZE];

  //-----------------------------------------------------
  // Check parameters
  //-----------------------------------------------------
  if((pRespStruc == NULL) || (pCurrentTimeArray == NULL))
    return(HOCSP_NULL_PTR);

  pProducedAtTimeArray = pRespStruc->pProducedAtTime;
  if(pProducedAtTimeArray == NULL)
    return(HOCSP_NULL_PTR);

  //-------------------------------------------------------
  // copy current time to local array
  //-------------------------------------------------------
  memcpy(CurrentCmpTimeArray+0,pCurrentTimeArray+0,(TIME_ARRAY_SIZE)*sizeof(int));
  //----------------------------------------------------------
  // set up the relative time array for the tolerance to apply
  //----------------------------------------------------------
  memset(ToleranceTimeArray,0,TIME_ARRAY_SIZE * sizeof(int)); // clear
  ToleranceTimeArray[TIME_MINUTES_INDEX] = DeltaMinutes;
  //-------------------------------------------------------
  // add given tolerance to the local array
  //-------------------------------------------------------
  if((Retcode = AddTimeArrayDeltaTime(CurrentCmpTimeArray,ToleranceTimeArray,0)) != ASN1_OP_OK)
    return(Retcode);
  //-------------------------------------------------------
  // 1. Check if ProducedAt <= currentTime + Tolerance
  //-------------------------------------------------------
  Retcode = CompareTimeArrays(pProducedAtTimeArray,CurrentCmpTimeArray);
  if(Retcode == ASN1_1ST_GT_2ND)
  {
    pRespStruc->ReliabilityStatus |=
			OCSP_UNRELIABLE_PRODUCED_AT_BIT;
  }
  //-------------------------------------------------------
  // 2. Check if a Nonce was returned
  //-------------------------------------------------------
  if((pRespStruc->pNonceData == NULL) ||
     (pRespStruc->NonceDataLen <= 0))
    return(HOCSP_OP_OK);

  //-------------------------------------------------------
  // copy current time to local array
  //-------------------------------------------------------
  memcpy(CurrentCmpTimeArray+0,pCurrentTimeArray+0,(TIME_ARRAY_SIZE)*sizeof(int));
  //-------------------------------------------------------
  // subtract given tolerance from the local array
  //-------------------------------------------------------
  if((Retcode = AddTimeArrayDeltaTime(CurrentCmpTimeArray,ToleranceTimeArray,1)) != ASN1_OP_OK)
    return(Retcode);
  //-------------------------------------------------------
  // 2a. Check if ProducedAt >= currentTime - Tolerance
  //-------------------------------------------------------
  Retcode = CompareTimeArrays(pProducedAtTimeArray,CurrentCmpTimeArray);
  if(Retcode == ASN1_1ST_LT_2ND)
  {
    pRespStruc->ReliabilityStatus |=
			OCSP_UNRELIABLE_PRODUCED_AT_BIT;
  }
  return(HOCSP_OP_OK);
}

/**
* Compare Values of two IDAPARR structure Elements at given index (CompareIdatparrStructs).
* NOTE: no parameters checked
* -----
*
*  @param pDesc1
*  @param pDesc2
*  @param Index
* 
*  @return int MatchStatus OCSP_SAME / OCSP_NOT_SAME
*/
static  int  CompareIdatparrStructs(IDATPARR* pDesc1,
		IDATPARR* pDesc2, int Index)
{
  int Len1, Len2;

  IDATA* pIdata1;
  IDATA* pIdata2;

  IDATA** ppArr1;
  IDATA** ppArr2;

  //------------------------------------------------------
  // Check if required elements are present
  //------------------------------------------------------
  if((pDesc1 == NULL) || (pDesc2 == NULL) || (Index < 0))
    return(OCSP_NOT_SAME);
  if((pDesc1->Cnt <= Index) || (pDesc2->Cnt <= Index))
    return(OCSP_NOT_SAME);

  ppArr1 = pDesc1->ppArr;
  ppArr2 = pDesc2->ppArr;

  if((ppArr1 == NULL) || (ppArr2 == NULL))
    return(OCSP_NOT_SAME);

  pIdata1 = ppArr1[Index];
  pIdata2 = ppArr2[Index];

  if((pIdata1 == NULL) || (pIdata2 == NULL))
    return(OCSP_NOT_SAME);

  Len1 = pIdata1->Len;
  Len2 = pIdata2->Len;

  if((Len1 <= 0) || (Len2 <= 0) || (Len1 != Len2))
    return(OCSP_NOT_SAME);

  return(LclCmpBit8Arrays(pIdata1->Base,
		       (int) pIdata1->Off,
		       pIdata2->Base,
		       (int) pIdata2->Off,
			Len1));
}

/**
* Compare Cert-ID structures for matching Serial number,
* Issuer name and public key hashes (CompareCertIDStructs).
* NOTE: no parameters checked
* -----
*
*  @param pCertIdStruc1
*  @param pCertIdStruc2
* 
*  @return int MatchStatus OCSP_SAME / OCSP_NOT_SAME
*/
static  int  CompareCertIDStructs(HOCSCID * pCertIdStruc1,
		HOCSCID * pCertIdStruc2)
{
  int Retcode;

  IDATPARR* pDesc1;
  IDATPARR* pDesc2;
  //------------------------------------------------------
  // 1. Compare serial numbers 
  //------------------------------------------------------
  pDesc1 = pCertIdStruc1->SerialNumber;
  pDesc2 = pCertIdStruc2->SerialNumber;
  if((Retcode = CompareIdatparrStructs(pDesc1,pDesc2,0)) != OCSP_SAME)
    return(Retcode);
  //------------------------------------------------------
  // 2. Compare issuer name hash
  //------------------------------------------------------
  pDesc1 = pCertIdStruc1->IssuerNameHash;
  pDesc2 = pCertIdStruc2->IssuerNameHash;
  if((Retcode = CompareIdatparrStructs(pDesc1,pDesc2,0)) != OCSP_SAME)
    return(Retcode);
  //------------------------------------------------------
  // 3. Compare issuer key hash
  //------------------------------------------------------
  pDesc1 = pCertIdStruc1->IssuerKeyHash;
  pDesc2 = pCertIdStruc2->IssuerKeyHash;
  Retcode = CompareIdatparrStructs(pDesc1,pDesc2,0);
  return(Retcode);
}

/**
* Matches OCSP responses with the request list (MatchOcspResponsesToRequests).
*
*  @param pRespStruc OCSP response
*  @param pReqStruc OCSP request
*  @param pMatchStatus match result: <br>
*               OCSP_RESP_MATCH_OK <br>
*               OCSP_RESP_MATCH_UNKNOWN <br>
*               OCSP_RESP_MATCH_DIFFERENT_CNT <br>
*               OCSP_RESP_MATCH_DUPLICATE <br>
*               OCSP_RESP_MATCH_NOT_ALL_MATCHED
*  @return 0 on success, error code otherwise
*/
extern "C"  int  MatchOcspResponsesToRequests(HOCRESP * pRespStruc,
		HOCSREQ * pReqStruc, int* pMatchStatus)
{
  int ActReqIndex = 0;
  int ActRespIndex = 0;

  int RequestCount;
  int ResponseCount;
  int MatchFlag,DuplicateFlag;

  HOCSCID * pActReqCertId;
  HOCSCID * pActRespCertId;

  HOCSRSP * pActResp;

  HOCSCID ** pReqCertIdList;
  HOCSRSP ** pResponseList;

  //-----------------------------------------------------
  // Check parameters
  //-----------------------------------------------------
  if((pRespStruc == NULL) || (pReqStruc == NULL) || (pMatchStatus == NULL))
    return(HOCSP_NULL_PTR);

  pMatchStatus[0] = OCSP_RESP_MATCH_UNKNOWN;

  //-------------------------------------------------------------
  // Check that number of responses is same as number of requests
  //-------------------------------------------------------------
  pReqCertIdList = pReqStruc->pCertIdList;
  RequestCount   = pReqStruc->CertIdCount;

  pResponseList  = pRespStruc->pResponseList;
  ResponseCount  = pRespStruc->ResponseCount;

  if(RequestCount != ResponseCount)
  {
    pMatchStatus[0] = OCSP_RESP_MATCH_DIFFERENT_CNT;
    return(HOCSP_OP_OK);
  }
  if((RequestCount <= 0) ||
     (pReqCertIdList == NULL) || (pResponseList == NULL))
    return(HOCSP_OP_OK);				// cannot determin !

  //--------------------------------------------------------------
  // match the Responses to the requests now
  //--------------------------------------------------------------
  ActReqIndex = 0;
  while(ActReqIndex < RequestCount)
  {
    pActReqCertId = pReqCertIdList[ActReqIndex];
    ActRespIndex = 0;
    MatchFlag = 0;
    DuplicateFlag = 0;
    //--------------------------------------------------------
    // Scan the responses for a match for actual request
    //--------------------------------------------------------
    while(ActRespIndex < RequestCount)
    {
      pActResp = pResponseList[ActRespIndex];
      pActRespCertId = pActResp->pCertID;

      if((pActResp->RequestID >= 0) ||	// already processed
         (pActRespCertId == NULL))			// STRANGE !!!
      {
        ActRespIndex++;
        continue;
      }        
      if(CompareCertIDStructs(pActRespCertId,pActReqCertId) != OCSP_SAME)
      {
        ActRespIndex++;
        continue;
      }        
      //----------------------------------------------------
      // found a match !
      //----------------------------------------------------
      if(MatchFlag == 0)			// first match
      {
        pActReqCertId->ResponseID = ActRespIndex; // set backlink
        pActResp->RequestID = ActReqIndex; // set forward link
        MatchFlag = 1;
      }
      else					// is a duplicate !!
      {
        DuplicateFlag = 1;
        break;
      }
      ActRespIndex++;
    }
    //----------------------------------------------------------
    // Check if request has been matched and no duplicates found
    //----------------------------------------------------------
    if(MatchFlag == 0)
    {
      pMatchStatus[0] = OCSP_RESP_MATCH_NOT_ALL_MATCHED;
      return(HOCSP_OP_OK);
    }
    if(DuplicateFlag != 0)
    {
      pMatchStatus[0] = OCSP_RESP_MATCH_DUPLICATE;
      return(HOCSP_OP_OK);
    }
    ActReqIndex++;				// to next request
  }
  //---------------------------------------------------------
  // All matched o.k.
  //---------------------------------------------------------
  pMatchStatus[0] = OCSP_RESP_MATCH_OK;
  return(HOCSP_OP_OK);
}

/**
* Performs reliability checks on the responses regarding
* ThisUpdate and NextUpdate, if present (CheckResponsesReliability).
*<ol>
* <li> ThisUpdate >= CurrentTime + Tolerance (minutes) -> unreliable
* <li> ThisUpdate >= ProducedAt  + Tolerance (minutes) -> unreliable
* <li> NextUpdate <  CurrentTime			      -> unreliable
* <li> NextUpdate <  ProducedAt			      -> unreliable
*</ol>
*  @param pRespStruc OCSP response
*  @param pCurrentTimeArray Current time array
*  @param DeltaMinutes Tolerance in minutes
*  @param ProcessFlags Bit 5 - 1 no prodAT chk
*  @param pCumulatedStatus status bits (OR)
*  @return 0 on success, error code otherwise
*/
extern "C"  int  CheckResponsesReliability(HOCRESP * pRespStruc,
		int* pCurrentTimeArray, int DeltaMinutes,
		int ProcessFlags, int* pCumulatedStatus)
{
  int Retcode;
  int CumulatedStatus = 0;
  int ResponseCount;
  int ActRespIndex;
  int ActCertStatus;
  int* pActualCheckTimeArray;
  int* pProducedAtTimeArray;

  HOCSRSP * pActResponse;
  HOCSRSP ** pResponseList;

  int CurrentCmpTimeArray[TIME_ARRAY_SIZE];
  int ProducedAtCmpTimeArray[TIME_ARRAY_SIZE];
  int ToleranceTimeArray[TIME_ARRAY_SIZE];

  //-----------------------------------------------------
  // Check parameters
  //-----------------------------------------------------
  if((pRespStruc == NULL) || (pCurrentTimeArray == NULL) ||
     (pCumulatedStatus == NULL))
    return(HOCSP_NULL_PTR);

  pCumulatedStatus[0] = 0;

  pProducedAtTimeArray = pRespStruc->pProducedAtTime;
  if(pProducedAtTimeArray == NULL)
    return(HOCSP_NULL_PTR);

  //-------------------------------------------------------
  // copy current time and produced at time to local arrays
  //-------------------------------------------------------
  memcpy(CurrentCmpTimeArray+0,pCurrentTimeArray+0,(TIME_ARRAY_SIZE)*sizeof(int));
  memcpy(ProducedAtCmpTimeArray+0,pProducedAtTimeArray+0,(TIME_ARRAY_SIZE)*sizeof(int));
  //----------------------------------------------------------
  // set up the relative time array for the tolerance to apply
  //----------------------------------------------------------
  memset(ToleranceTimeArray,0,TIME_ARRAY_SIZE * sizeof(int)); // clear
  ToleranceTimeArray[TIME_MINUTES_INDEX] = DeltaMinutes;
  //-------------------------------------------------------
  // add given tolerance to the local arrays
  //-------------------------------------------------------
  if((Retcode = AddTimeArrayDeltaTime(CurrentCmpTimeArray,ToleranceTimeArray,0)) != ASN1_OP_OK)
    return(Retcode);

  if((Retcode = AddTimeArrayDeltaTime(ProducedAtCmpTimeArray,ToleranceTimeArray,0)) != ASN1_OP_OK)
    return(Retcode);
  //-------------------------------------------------------
  // Get the list to process
  //-------------------------------------------------------
  pResponseList = pRespStruc->pResponseList;
  ResponseCount = pRespStruc->ResponseCount;

  if(ResponseCount <= 0)			// should not happen
    return(HOCSP_OP_OK);

  if(pResponseList == NULL)
    return(HOCSP_NULL_PTR);
  //-------------------------------------------------------
  // Process the responses now
  //-------------------------------------------------------
  ActRespIndex = 0;
  while(ActRespIndex < ResponseCount)
  {
    pActResponse = pResponseList[ActRespIndex];
    if(pActResponse == NULL)
      return(HOCSP_NULL_PTR);
    //-----------------------------------------------------
    // 1. Check reliability of ThisUpdate, must be present
    //-----------------------------------------------------
    pActualCheckTimeArray = pActResponse->pThisUpdateTimeArr;
    Retcode = CompareTimeArrays(pActualCheckTimeArray,CurrentCmpTimeArray);
    if(Retcode != ASN1_1ST_LT_2ND)
    {
      CumulatedStatus |= OCSP_SRESP_UNRELIABLE_BIT;
      pActResponse->ReliabilityStatus |=
		OCSP_UNRELIABLE_THIS_UPD_A_BIT;
    }

    if((ProcessFlags & OCSP_PROC_FLAG_IGNORE_PROD_AT) == 0)
    {
      Retcode = CompareTimeArrays(pActualCheckTimeArray,ProducedAtCmpTimeArray);
      if(Retcode != ASN1_1ST_LT_2ND)
      {
        CumulatedStatus |= OCSP_SRESP_UNRELIABLE_BIT;
        pActResponse->ReliabilityStatus |=
		OCSP_UNRELIABLE_THIS_UPD_B_BIT;
      }
    }
    //-----------------------------------------------------
    // 2. Check reliability of NextUpdate if present
    //-----------------------------------------------------
    pActualCheckTimeArray = pActResponse->pNextUpdateTimeArr;
    if(pActualCheckTimeArray != NULL)		// was present
    {
      Retcode = CompareTimeArrays(pActualCheckTimeArray,pCurrentTimeArray);
      if(Retcode != ASN1_1ST_GT_2ND)
      {
        CumulatedStatus |= OCSP_SRESP_UNRELIABLE_BIT;
        pActResponse->ReliabilityStatus |=
		OCSP_UNRELIABLE_NEXT_UPD_A_BIT;
      }

      if((ProcessFlags & OCSP_PROC_FLAG_IGNORE_PROD_AT) == 0)
      {
        Retcode = CompareTimeArrays(pActualCheckTimeArray,pProducedAtTimeArray);
        if(Retcode != ASN1_1ST_GT_2ND)
        {
          CumulatedStatus |= OCSP_SRESP_UNRELIABLE_BIT;
          pActResponse->ReliabilityStatus |=
		  OCSP_UNRELIABLE_NEXT_UPD_B_BIT;
        }
      }
    }
    //-----------------------------------------------------
    // 3. Check reported certificate status
    //-----------------------------------------------------
    ActCertStatus = pActResponse->CertStatus;
    if(ActCertStatus != OCSP_CERT_STATUS_GOOD)
    {
      if(ActCertStatus == OCSP_CERT_STATUS_REVOKED)
        CumulatedStatus |= OCSP_SRESP_REVOKED_BIT;
      else
        CumulatedStatus |= OCSP_SRESP_UNKNOWN_BIT;
    }
    ActRespIndex++;
  }
  pCumulatedStatus[0] = CumulatedStatus;
  return(HOCSP_OP_OK);
}

/**
* Generates OCSP response reliability/trust status (GenerateOcspRespReliability).
* 
*  @param pRespStruc OCSP response
*  @param pReqStruc OCSP request
*  @param pCertTree Tree from CDB file
*  @param ProcessFlags Bit 2 - 1 no NONCE need <br>
*               Bit 5 - 1 no prodAT chk
*  @param TimeTolerance in minutes
*  @return 0 on success, error code otherwise
*/
extern "C"  int  GenerateOcspRespReliability(HMEM_CTX_DEF
	HOCRESP * pRespStruc, HOCSREQ * pReqStruc,
        CTREESTR * pCertTree, int ProcessFlags, int TimeTolerance)
{
  int Retcode;
  int StatusBits;

  int pTmpStatus[1];
  int CurrentTimeArray[TIME_ARRAY_SIZE];

  //-----------------------------------------------------
  // Check parameters
  //-----------------------------------------------------
  if((pRespStruc == NULL) || (pReqStruc == NULL))
    return(HOCSP_NULL_PTR);

  //----------------------------------------------------
  // 1. Assure that response has status 'Successful'
  //----------------------------------------------------
  if(pRespStruc->ResponseStatus != OCSP_RESP_STATUS_SUCCESS)
  {
     pRespStruc->ReliabilityStatus |=
       OCSP_RESPONSE_UNSUCCESSFUL_BIT;
     return(HOCSP_OP_OK);
  }
  //----------------------------------------------------
  // 2. Check signature of the response, set status
  //----------------------------------------------------
  if((Retcode = VerifyOcspResponseSignature(HMEM_CTX_REF1
				 pRespStruc, pCertTree)) != HOCSP_OP_OK)
    return(Retcode);

  //----------------------------------------------------
  // 3. Check NONCE status (if present/required)
  //----------------------------------------------------
  if((Retcode = CheckReqResponseNonces(pRespStruc,
			       pReqStruc, ProcessFlags)) != HOCSP_OP_OK)
    return(Retcode);
  //----------------------------------------------------
  // 4. Check ProducedAt Time status, if enabled
  //----------------------------------------------------
  if((Retcode = GetCheckLocalTimeArray(0,0,CurrentTimeArray)) != ASN1_OP_OK)
    return(Retcode);

  if((ProcessFlags & OCSP_PROC_FLAG_IGNORE_PROD_AT) == 0)
  {

    if((Retcode = CheckProducedAtReliability(pRespStruc,
			CurrentTimeArray, TimeTolerance)) != HOCSP_OP_OK)
      return(Retcode);
  }
  //----------------------------------------------------
  // 5. Match Responses with associated Requests
  //----------------------------------------------------
  if((Retcode = MatchOcspResponsesToRequests(pRespStruc,
				pReqStruc, pTmpStatus)) != HOCSP_OP_OK)
    return(Retcode);

  switch(pTmpStatus[0])
  {
    case OCSP_RESP_MATCH_OK:
      StatusBits = 0;
      break;

    case OCSP_RESP_MATCH_DIFFERENT_CNT:
      StatusBits = OCSP_UNRELIABLE_MATCH_A_BIT;
      break;

    case OCSP_RESP_MATCH_DUPLICATE:
      StatusBits = OCSP_UNRELIABLE_MATCH_C_BIT;
      break;

    case OCSP_RESP_MATCH_NOT_ALL_MATCHED:
      StatusBits = OCSP_UNRELIABLE_MATCH_B_BIT;
      break;

    case OCSP_RESP_MATCH_UNKNOWN:
    default:
      StatusBits = OCSP_UNRELIABLE_MATCH_D_BIT;
      break;
  }
  pRespStruc->ReliabilityStatus |= StatusBits;
  //----------------------------------------------------
  // 6. Check the single response stati
  //----------------------------------------------------
  if((Retcode = CheckResponsesReliability(pRespStruc,
		  CurrentTimeArray, TimeTolerance,
		  ProcessFlags, pTmpStatus)) != HOCSP_OP_OK)
    return(Retcode);

  pRespStruc->ReliabilityStatus |= pTmpStatus[0];
  return(0);
}

/**
* Get length of an ASCIIz string, excluding NUL (LclStrLen).
* -- local function --
*
*  @param pStrBuf Data buffer
*  @param StrOff Start of Data
*  @return int Len
*/
static  int  LclStrLen(char* pStrBuf, int StrOff)
{

  if(pStrBuf == NULL)
    return(0);

  return((int) strlen(pStrBuf+StrOff));
}

/**
* Get number of URLs from a multi-ASCIIz String (CountMultiStringElements).
* NOTE: Elements are separated by NUL, last element ends with NUL NUL
* -----
*
*  @param pMultiString Data buffer
*  @param StringOff Start of Data
*  @return int ElementCount
*/
static  int  CountMultiStringElements(char* pMultiString,
				int StringOff)
{
  int ElementCount = 0;
  int ActLen;

  if(pMultiString == NULL)
    return(0);

  for(;;)
  {
    ActLen = LclStrLen(pMultiString,StringOff);
    if(ActLen <= 0)  
      return(ElementCount);
    ElementCount++;
    StringOff += (ActLen+1);
  }
}

/**
* Send an OCSP Request to a Responder (identified by URL), get the
* Response, process the response and determine reliability status (SendRequestGetResponse).
* NOTE: no params checked !!
*
*  @param pResponderUrl ASCIIz string
*  @param ResponderUrlOff Start of data
*  @param pReqStruc Request structure
*  @param pCertTree Tree for Signature Verify
*  @param ProcessFlags Bit 2: 1 - no NONCE required
*               Bit 4: 1 - sort Responder DN
*               Bit 5: 1 - no producedAT check
*  @param TimeTolerance Tolerance interval in minutes
*  @param pResponseStatus Cumulative Status
*  @param ppRespStruc Allocated Response Struc/NULL
*  @return 0 on success, error code otherwise
*/
static  int  SendRequestGetResponse(HOCSP_CTX_DEF
	HMEM_CTX_DEF
	char* pResponderUrl, int ResponderUrlOff,
	HOCSREQ * pReqStruc, CTREESTR * pCertTree,
	int ProcessFlags, int TimeTolerance, int* pResponseStatus,
	HOCRESP ** ppRespStruc)	
{
  int Retcode;
  int ResponderUrlLen;
  int ResponseLen;

  IDATA* pIdata;
  char * pResponderUrlStr;
  char* pResponseBuf = NULL;
  HOCRESP * pRespStruc = NULL;

  char* ppTmpBuf[1];
  int pTmpLen[1];

  HOCRESP * ppTmpRespStruc[1];

  pResponseStatus[0] = 0;
  if(ppRespStruc != NULL)
    ppRespStruc[0] = NULL;
  //-------------------------------------------------------
  // 1. Assure URL not empty
  //-------------------------------------------------------
//  PRINT_NL("1. GetURL Len");

  if((ResponderUrlLen = LclStrLen(pResponderUrl,ResponderUrlOff)) <= 0)
    return(HOCSP_PARAM_ERR);

//  PRINT("1a. URL Len: ");
//  PRINT_INT_NL(ResponderUrlLen);

  //-------------------------------------------------------
  // 2. Get the Request data to send from structure, send them
  //-------------------------------------------------------
//  PRINT_NL("2. Get OCSP REQ to Send");
  pIdata = pReqStruc->OCSPRequest->ppArr[0];

  pResponderUrlStr = pResponderUrl + ResponderUrlOff;

  Retcode = GetUrlOcspResponse(HOCSP_CTX_REF1 pResponderUrlStr,pIdata->Base,(int) pIdata->Off,pIdata->Len,ppTmpBuf,pTmpLen);
//  PRINT_NL("3. Past Get Response");
  if(Retcode != HOCSP_OP_OK)			// failed to get reply
  {
    //-------------------------------------------------------
    // Check if recoverable fault occured...
    //-------------------------------------------------------
    pResponseStatus[0] = OCSP_NO_RESPONSE_BIT;
    switch(Retcode)
    {
      case HTTP_CONNECT_CONNECT_FAILED:		// could not connect
      case HTTP_SEND_REQUEST_HDR_FAILED:	// transmit failed
      case HTTP_SEND_REQUEST_BODY_FAILED:	// transmit failed
      case HTTP_RESP_SERVER_ERR_STATUS:		// HTTP error response
      case HTTP_HDR_PARSE_CONN_CLOSED:		// premature receive close
      case HTTP_HDR_PARSE_RX_TIMED_OUT:		// recive time out
      case HTTP_HDR_PARSE_RX_ERR:		// receive error
      case HTTP_HDR_PARSE_NO_STATUS_LINE:	// HTTP-response error
      case HTTP_HDR_PARSE_INV_STATUS_LINE:	// invalid HTTP status line
      case HTTP_HDR_PARSE_NO_RESP_STATUS:	// no HTTP return status
      case HTTP_RESP_NOT_OCSP_TYPE:		// not an OCSP response
      case HTTP_RESP_NO_RESPONSE_DATA:		// no OCSP response data
      case HTTP_RESP_DATA_READ_FAILED:		// incomplete OCSP data
        return(HOCSP_OP_OK);

      default:					// sever other error...
        return(Retcode);
    }
  }
  pResponseBuf = ppTmpBuf[0];
  ResponseLen  = pTmpLen[0];
  //-------------------------------------------------------
  // 3. Got OCSP Response, parse it to Structure
  //-------------------------------------------------------
//  PRINT_NL("4. Response to struc");
  Retcode = FromOCSPResponseToStruc(HMEM_CTX_REF1
		pResponseBuf,0,ResponseLen,ProcessFlags,
		ppTmpRespStruc);

  FREE_CARRAY(HMEM_CTX_REF,pResponseBuf);

  if(Retcode != HOCSP_OP_OK)
  {
    pResponseStatus[0] = OCSP_RESPONSE_UNSUCCESSFUL_BIT;
    return(HOCSP_OP_OK);
  }
  pRespStruc = ppTmpRespStruc[0];
  //-------------------------------------------------------
  // 4. Determine reliability of the response
  //-------------------------------------------------------
//  PRINT_NL("5. GetReliability");
  Retcode = GenerateOcspRespReliability(HMEM_CTX_REF1
		pRespStruc, pReqStruc,
		pCertTree, ProcessFlags, TimeTolerance);
  if(Retcode != HOCSP_OP_OK)
  {
    FreeOcspRespStruc(HMEM_CTX_REF1 pRespStruc);
    return(Retcode);
  }
  //-------------------------------------------------------
  // 5. Return cumulated status to caller
  //-------------------------------------------------------
//  PRINT_NL("6. Determine Status");
  pResponseStatus[0] = pRespStruc->ReliabilityStatus;
  if(ppRespStruc != NULL)
    ppRespStruc[0] = pRespStruc;
  else
    FreeOcspRespStruc(HMEM_CTX_REF1 pRespStruc);
  return(HOCSP_OP_OK);
}

/**
* Get rightmost set bit of a BIT32 value (GetRmoBit).
*
*  @param Value
*  @return int BitNumber Number of rightmost bit set, rel. 0
* <br>            if none set, return -1
*/
static  int  GetRmoBit(int Value)
{
  int BitCounter=0;

  if(Value == 0)			// no bit is set
    return(-1);
  while(BitCounter < 32)
  {
    if((Value & (int) 0x01) != 0)	// found a set bit
      return(BitCounter);
    BitCounter++;
    Value = Value >> 1;
  }
  return(-1);
}

/**
* Allocates an OCSP parameter structure and initializes it (AllocOcspParamStruc).
*
*  @return new <code>HOCSP_PARAM_PTR</code> / NULL on error
*/
extern "C"  HOCSPPAR *  AllocOcspParamStruc(HMEM_CTX_DEF1)
{

  HOCSPPAR * pOcspParamStruc;

  //-------------------------------------------------------
  // Allocate the structure, clear it
  //-------------------------------------------------------
  pOcspParamStruc = (HOCSPPAR *)
    ((void*) BIT8_ARRAY_CALLOC(HMEM_CTX_REF,1,sizeof(HOCSPPAR)));
  if(pOcspParamStruc == NULL)
    return(NULL);
  //-------------------------------------------------------
  // Initialize elements
  //-------------------------------------------------------
#if defined XH_INTERFACE
  pOcspParamStruc->pMemCtxStruc = HMEM_CTX_REF;
#endif

  pOcspParamStruc->HashAlgorType = OCSP_HASH_ALGOR_SHA1;
  pOcspParamStruc->TimeTolerance = OCSP_DEFAULT_TIME_TOLERANCE;
  return(pOcspParamStruc);
}

#if defined XH_INTERFACE
/**
* Count number of XH-Interface OCSP connection structures in
* given list (CountXhConnStructs).
*
*               struct dsd_hl_ocsp_d_1 *               pOcspConnStrucList
*  @return int Count, if <= 0 error occured
*/
static  int  CountXhConnStructs(
		struct dsd_hl_ocsp_d_1 * pXhConnStrucList)
{
  int Count = 0;

  if(pXhConnStrucList == NULL)
    return(0);
  for(;;)
  {
    Count++;				// add one element
    pXhConnStrucList = pXhConnStrucList->adsc_next;
    if(pXhConnStrucList == NULL)
      return(Count);
  }
}

/**
* Convert an XH-Interface OCSP connect structure to an URL (XH_FromConnStrucToURL).
*
* Generates an ASCIIz string from sized URL now
*
*  @param pXhOcspConnStruc OCSP structure
*  @param ppDstBuf Allocated, filled buffer
*  @return 0 on success, error code otherwise
*/
static  int  XH_FromConnStrucToURL(HMEM_CTX_DEF
	struct dsd_hl_ocsp_d_1 * pXhOcspConnStruc,char** ppDstBuf)
{
  int UrlLen;
  char* pDstBuf;

  if((pXhOcspConnStruc == NULL) || (ppDstBuf == NULL))
    return(HOCSP_NULL_PTR);

  if((pXhOcspConnStruc->achc_url == NULL) ||
     ((UrlLen = pXhOcspConnStruc->inc_url_len) <= 0))
  {
    return(HOCSP_PARAM_ERR);
  }

  //-------------------------------------------------------
  // Allocate buffer
  //-------------------------------------------------------
  if((pDstBuf = BIT8_ARRAY_ALLOC(HMEM_CTX_REF,UrlLen+1)) == NULL)
    return(HOCSP_ALLOC_ERR);

  memcpy(pDstBuf+0,pXhOcspConnStruc->achc_url+0,UrlLen);

  pDstBuf[UrlLen++]   = 0;		// Terminate
  ppDstBuf[0] = pDstBuf;
  return(HOCSP_OP_OK);
}

#endif // XH_INTERFACE

/**
* Peforms an OCSP verification (OcspVerifyCertList).
* Generates OCSP request, send it to the OCSP responder(s) get the
* replies and process them.
*
*  @param pOcspParamStruc Structure with params
*  @return 0 on success, error code otherwise
*/
extern "C"  int  OcspVerifyCertList(HOCSPPAR * pOcspParamStruc)
{

  int Retcode;
  int ProcessFlags;

  int UrlCount;
  int* pStatusArr = NULL;
  int QueryIndex; 
  int ActStatus;
  int NextLen;
  int ActRmo,BestRmo;
  int BestIndex;

  int	  ActUrlOff  = 0;
  char* pActUrlBuf = NULL;

#if defined XH_INTERFACE
  struct dsd_hl_ocsp_d_1 * pActXhConnStruc = NULL;
#endif

  X509CERT ** pAllocedCertList = NULL;

  HOCSREQ * pReqStruc = NULL;
  HOCSREQ * ppTmpReqStruc[1];
  HOCRESP * ppTmpRespStruc[1];

  int pTmpStatus[1];
  int pTmpCNIndex[1];
  int pTmpCnt[1];

#if defined XH_INTERFACE
  char* ppTmpBuf[1];
#endif

  int CompletedCertCount;
  X509CERT * pCert;
  X509CERT ** pCompletedCertList;
  X509CERT ** ppTmpCertChain[1];  

  HMEM_CTX_DEF1;
  HOCSP_CTX_DEF1;

  //--------------------------------------------------------
  // Check parameters, initialize response status
  //--------------------------------------------------------
  if(pOcspParamStruc == NULL)
    return(HOCSP_NULL_PTR);

  pOcspParamStruc->ResponseStatusBits = OCSP_NO_RESPONSE_BIT;

  LOAD_HMEM_CTX_PTR(pOcspParamStruc->pMemCtxStruc);
  LOAD_HOCSP_CTX_PTR(pOcspParamStruc->pOcspCtxStruc);

  if((pOcspParamStruc->pCertList == NULL) ||
     (pOcspParamStruc->pCertTree == NULL))
    return(HOCSP_NULL_PTR);

  if(pOcspParamStruc->CertsCount <= 0)	// no certificates
    return(HOCSP_PARAM_ERR);

  pActUrlBuf = pOcspParamStruc->pResponderUrls;
  ActUrlOff  = pOcspParamStruc->ResponderUrlsOff;
#if defined XH_INTERFACE
  pActXhConnStruc = pOcspParamStruc->pXhConnStrucList;	// given list
#endif
  //---------------------------------------------------------
  // get number of possible Responder URLs to query
  //---------------------------------------------------------
#if !defined XH_INTERFACE
  if(pActUrlBuf == NULL)
    return(HOCSP_NULL_PTR);

  UrlCount = CountMultiStringElements(pActUrlBuf,ActUrlOff);

#else // XH_INTERFACE

  if((pActUrlBuf == NULL) && (pActXhConnStruc == NULL))
    return(HOCSP_NULL_PTR);

  if(pActXhConnStruc == NULL)
    UrlCount = CountMultiStringElements(pActUrlBuf,ActUrlOff);
  else
  {
    UrlCount = CountXhConnStructs(pActXhConnStruc);
    pActUrlBuf = NULL;
  }
#endif // XH_INTERFACE

  if(UrlCount <= 0)
    return(HOCSP_PARAM_ERR);

  ProcessFlags = pOcspParamStruc->ProcessFlags;
  //---------------------------------------------------------
  // Allocate the status array
  //---------------------------------------------------------
  if((pStatusArr = INT_ARRAY_ALLOC(HMEM_CTX_REF,UrlCount)) == NULL)
    return(HOCSP_ALLOC_ERR);

  //---------------------------------------------------------
  // Check if certificate chain shall be completed from tree
  //---------------------------------------------------------
  CompletedCertCount = pOcspParamStruc->CertsCount;
  pCompletedCertList = pOcspParamStruc->pCertList;

  if((ProcessFlags & OCSP_PROC_FLAG_NO_COMPL_CHAIN) == 0)// shall complete chain...
  {
    pCert = pCompletedCertList[CompletedCertCount-1];
    if((pCert->Flags & SELF_SIGNED_MASK) == 0)	// not a root...
    {
      Retcode = CompleteCertChain(HMEM_CTX_REF1 pOcspParamStruc->pCertList,pOcspParamStruc->CertsCount,pOcspParamStruc->pCertTree,pTmpCNIndex,ppTmpCertChain,pTmpCnt);
      if(Retcode != ASN1_OP_OK)
      {
        FREE_CARRAY(HMEM_CTX_REF,pStatusArr);
        return(Retcode);
      }
      CompletedCertCount = pTmpCnt[0];
      pCompletedCertList = ppTmpCertChain[0];
      pAllocedCertList   = pCompletedCertList;
    }
  }
  //---------------------------------------------------------
  // Generate the Request structure from certificate list etc.
  //---------------------------------------------------------
  Retcode = GenerateOCSPRequest(HMEM_CTX_REF1
		pCompletedCertList, CompletedCertCount,
		pOcspParamStruc->HashAlgorType,
		pOcspParamStruc->pSignerCert,
		pOcspParamStruc->SignatType,
		ProcessFlags,ppTmpReqStruc);
  if(Retcode != HOCSP_OP_OK)
  {
    FREE_CARRAY(HMEM_CTX_REF,pStatusArr);
    FREE_CARRAY(HMEM_CTX_REF,pAllocedCertList);
    return(Retcode);
  }
  pReqStruc = ppTmpReqStruc[0];

  //---------------------------------------------------------
  // Query the Responders until reliable response / all 
  //---------------------------------------------------------
//  PRINT("Namecount: ");
//  PRINT_INT_NL(UrlCount);

  QueryIndex = 0;
  while(QueryIndex < UrlCount)
  {
//    PRINT("NameIndex: ");
//    PRINT_INT_NL(QueryIndex);

#if defined XH_INTERFACE
    vp__ocsp_ctx->pActOcspConnStruc = NULL;	// assume no list...

    if(pActXhConnStruc != NULL)			// List is given
    {
      Retcode = XH_FromConnStrucToURL(HMEM_CTX_REF,
				      pActXhConnStruc,ppTmpBuf);
      if(Retcode != HOCSP_OP_OK)
        return(Retcode);      
      pActUrlBuf = ppTmpBuf[0];
      ActUrlOff  = 0;
      vp__ocsp_ctx->pActOcspConnStruc = pActXhConnStruc; // set connect element
    }
#endif
    //-------------------------------------------------------
    // Query a responder, get the result
    //-------------------------------------------------------
    Retcode = SendRequestGetResponse(HOCSP_CTX_REF1 HMEM_CTX_REF1
		pActUrlBuf, ActUrlOff,
		pReqStruc,
		pOcspParamStruc->pCertTree,
		pOcspParamStruc->ProcessFlags,
 		pOcspParamStruc->TimeTolerance,
		pTmpStatus, ppTmpRespStruc);
//    PRINT_NL("PastQuery now");

    FreeOcspRespStruc(HMEM_CTX_REF1 ppTmpRespStruc[0]);
//    PRINT_NL("PastFree Resp now");

#if defined XH_INTERFACE
    if(pActXhConnStruc != NULL)			// URL was from structure...
    {
      FREE_CARRAY(HMEM_CTX_REF,pActUrlBuf);
    }
#endif
    if(Retcode != HOCSP_OP_OK)
    {
      FREE_CARRAY(HMEM_CTX_REF,pStatusArr);
      FREE_CARRAY(HMEM_CTX_REF,pAllocedCertList);
      FreeOcspReqStruc(HMEM_CTX_REF1 pReqStruc);
      return(Retcode);
    }

    ActStatus = pTmpStatus[0];
    pStatusArr[QueryIndex] = ActStatus;
    //-------------------------------------------------------
    // check if we got a full reliable response, all resolved
    //-------------------------------------------------------
    if((ActStatus & OCSP_RELIABILITY_CHECK_MASK2) == 0)
    {
//      PRINT_NL("Reliable Resp");
      FREE_CARRAY(HMEM_CTX_REF,pStatusArr);
      FREE_CARRAY(HMEM_CTX_REF,pAllocedCertList);
      FreeOcspReqStruc(HMEM_CTX_REF1 pReqStruc);

      pOcspParamStruc->ResponseStatusBits = ActStatus;
      return(HOCSP_OP_OK);
    }
    //--------------------------------------------------------
    // not reliable, advance to next Responder
    //--------------------------------------------------------
#if !defined XH_INTERFACE
    NextLen = LclStrLen(pActUrlBuf,ActUrlOff);
    ActUrlOff += (NextLen+1);
#else // XH_INTERFACE
    if(pActXhConnStruc != NULL)			// a list is given
    {
      pActXhConnStruc = pActXhConnStruc->adsc_next;
    }
    else					// no list, take URL buffer
    {
      NextLen = LclStrLen(pActUrlBuf,ActUrlOff);
      ActUrlOff += (NextLen+1);
    }
#endif // XH_INTERFACE
    QueryIndex++;
  }
  //----------------------------------------------------------------
  // did not find a good condition, check if there is a reliable one
  //----------------------------------------------------------------
  QueryIndex = 0;
  while(QueryIndex < UrlCount)
  {
    ActStatus = pStatusArr[QueryIndex];
    if((ActStatus & OCSP_RELIABILITY_CHECK_MASK1) == 0)	// reliable, but unknown
    {
//      PRINT_NL("Unknown Resp");
      FREE_CARRAY(HMEM_CTX_REF,pStatusArr);
      FREE_CARRAY(HMEM_CTX_REF,pAllocedCertList);
      FreeOcspReqStruc(HMEM_CTX_REF1 pReqStruc);
      pOcspParamStruc->ResponseStatusBits = ActStatus;
      return(HOCSP_OP_OK);
    }
    QueryIndex++;
  }      
  //----------------------------------------------------------------
  // check for a still less reliable response
  //----------------------------------------------------------------
  QueryIndex = 0;
  while(QueryIndex < UrlCount)
  {
    ActStatus = pStatusArr[QueryIndex];
    if((ActStatus & OCSP_RELIABILITY_CHECK_MASK3) == 0)	// mostly reliable
    {
      FREE_CARRAY(HMEM_CTX_REF,pStatusArr);
      FREE_CARRAY(HMEM_CTX_REF,pAllocedCertList);
      FreeOcspReqStruc(HMEM_CTX_REF1 pReqStruc);
      pOcspParamStruc->ResponseStatusBits = ActStatus;
      return(HOCSP_OP_OK);
    }
    QueryIndex++;
  }      
  //----------------------------------------------------------------
  // nothing has been met, find response with most left set LSB
  //----------------------------------------------------------------
  BestIndex = 0;
  BestRmo = 0;
  QueryIndex = 0;
  while(QueryIndex < UrlCount)
  {
    ActStatus = pStatusArr[QueryIndex];
    ActRmo = GetRmoBit(ActStatus);		// get right most bit
    if((ActRmo >= 0) && (ActRmo > BestRmo))
    {
      BestRmo = ActRmo;
      BestIndex = QueryIndex;
    }
    QueryIndex++;
  }      
  ActStatus = pStatusArr[BestIndex];
  pOcspParamStruc->ResponseStatusBits = ActStatus;

  FREE_CARRAY(HMEM_CTX_REF,pStatusArr);
  FREE_CARRAY(HMEM_CTX_REF,pAllocedCertList);
  FreeOcspReqStruc(HMEM_CTX_REF1 pReqStruc);
  return(HOCSP_OP_OK);
}  


#endif //HL_CERT_OCSP
// end of file ../hocsp/hocsp.cpp


#ifdef HL_CERT_OCSP
//*****************************************************************
//
// Wrapper functions for socket access over XH interface
// 
//*****************************************************************
#if defined XH_INTERFACE
#if (defined _WIN32) & (_MSC_VER < 1700)
#ifndef _STDINT
#define _STDINT
// MSVC lower than 17.00 does not have stdint.h, assure, all needed types are defined

typedef unsigned __int16 uint16_t;

typedef unsigned __int32 uint32_t;

typedef unsigned __int64 uint64_t;

#endif // !_STDINT
#else
#include <stdint.h>
#endif
#include <stddef.h>
#ifdef _WIN32
#define WIN32_LEAN_AND_MEAN
#include <Windows.h>
#undef WIN32_LEAN_AND_MEAN
#else// Define system-specific HL_* defines here
#ifndef HL_UNIX
#define HL_UNIX

#if (defined __gnu_linux__) || (defined __linux__)
#define HL_LINUX
#endif

#if (defined __APPLE__) && (defined __MACH__)
#define HL_LINUX
#define HL_MACOS
#endif

#ifdef _AIX
#define HL_AIX
#define HL_BIG_ENDIAN
#endif

#ifdef __FreeBSD__
#define HL_FREEBSD
#endif

#if (defined _hpux) || (defined hpux) || (defined __hpux)
#define HL_HPUX
#define HL_BIG_ENDIAN
#endif

#if (defined sun) || (defined __sun)
#define HL_SOLARIS
#endif

#if (defined __arm__) || (defined __aarch64__)
#define HL_LINUX_ARM
#endif

#ifdef __ANDROID__
#define HL_ANDROID
#endif

#endif
#include <hob-unix01.h>
#endif
#ifdef __APPLE__
/* We get target conditionals to keep apart Mac OS, iOS and iOS simulator.
   The conditionals are TARGET_IPHONE_SIMULATOR, TARGET_OS_IPHONE and TARGET_OS_MAC.
   TARGET_IPHONE_SIMULATOR has the highest priority, TARGET_OS_MAC the lowest.
   Always test, if the conditional is 1, as they will be defined as 0, if we 
   are not compiling for the target.
   */
#include <TargetConditionals.h>
#endif

#ifdef HL_ANDROID
#include <netdb.h>
#include <unistd.h>
#include <linux/in.h>
#ifndef SOCKLEN_T
#define SOCKLEN_T      int
#endif
#ifndef SA_FAMILY_T
#define SA_FAMILY_T  short
#endif
#include <sys/endian.h>
#include <asm/ioctls.h>
#include <errno.h>
#endif

#include "hob-encry-1.h"
#include "hob-cert-ext.h"
#ifdef _WIN32
#include <winsock.h>
#endif
#include "hob-cert-err.h"
#include <string.h>
#include "hob-cert-intern.h"
#include "hob-cert-err.h"
/** @addtogroup hocsp
* @{
* @file
* This file implements the wrappers for socket access over WSP C interface.
* @}
*/

/** @addtogroup hocsp
* @{
*/
extern "C"  void  FreeXhOcspStruc(XH_OCSP_STRUC * pXhOcspStruc)
{
  HMEM_CTX_DEF1;

  if((pXhOcspStruc == NULL) || (pXhOcspStruc->pMemCtxStruc == NULL))
    return;

  LOAD_HMEM_CTX_PTR(pXhOcspStruc->pMemCtxStruc);
  //-----------------------------------------------------------------
  // FREE a receive structure if still present
  //-----------------------------------------------------------------
  FREE_CARRAY(HMEM_CTX_REF,pXhOcspStruc->pRxStruc);
  pXhOcspStruc->pRxBuf        = NULL;
  pXhOcspStruc->pOcspCtxStruc = NULL;

  // free TCP tester helper structure if present
  FREE_CARRAY(HMEM_CTX_REF,pXhOcspStruc->pTestHlpCtxStruc);

  //-----------------------------------------------------------------
  // free the structure self
  //-----------------------------------------------------------------
  FREE_CARRAY(HMEM_CTX_REF,pXhOcspStruc);
}

extern "C"  XH_OCSP_STRUC *  AllocXhOcspStruc(ds__hmem * pMemCtxStruc)
{
  XH_OCSP_STRUC * pXhOcspStruc;

  if(pMemCtxStruc == NULL)
    return(NULL);

  //-----------------------------------------------------------------
  // allocate the structure
  //-----------------------------------------------------------------
  if((pXhOcspStruc = (XH_OCSP_STRUC *)
        ((void *) BIT8_ARRAY_CALLOC(pMemCtxStruc,
				    1,sizeof(XH_OCSP_STRUC)))) == NULL)
    return(NULL);
  //-----------------------------------------------------------------
  // set up the memory management context
  //-----------------------------------------------------------------
  pXhOcspStruc->pMemCtxStruc = pMemCtxStruc;

  return(pXhOcspStruc);
}

extern "C"  int  XH_OcspConnect(XH_OCSP_STRUC * pXhOcspStruc)
{
  int Retcode;

//  struct dsd_hl_ocsp_d_1 * pXhOcspConnStruc;

  //----------------------------------------------------------------
  // check parameters
  //----------------------------------------------------------------
  if((pXhOcspStruc == NULL) || (pXhOcspStruc->pActOcspConnStruc == NULL) ||
     (pXhOcspStruc->amc_ocsp_start == NULL))
    return(HOCSP_NULL_PTR);

  //----------------------------------------------------------------
  // call the service routine
  //----------------------------------------------------------------
  pXhOcspStruc->ConnectedFlag = 0;

  Retcode = pXhOcspStruc->amc_ocsp_start(pXhOcspStruc->pOcspCtxStruc,
					 pXhOcspStruc->pActOcspConnStruc);
  if(Retcode == 0)
    pXhOcspStruc->ConnectedFlag = 1;

  return(Retcode);
}

extern "C"  int  XH_OcspSend(XH_OCSP_STRUC * pXhOcspStruc,
		char pSrcBuf[], int SrcOff, int SrcLen,int )
{
  int Retcode;

  //----------------------------------------------------------------
  // check parameters
  //----------------------------------------------------------------
  if((pXhOcspStruc == NULL) || (pSrcBuf == NULL) ||
     (pXhOcspStruc->amc_ocsp_send == NULL))
    return(HOCSP_NULL_PTR);
  if(SrcLen < 0)
    return(HOCSP_PARAM_ERR);

  //----------------------------------------------------------------
  // check if connected to destination
  //----------------------------------------------------------------
  if(pXhOcspStruc->ConnectedFlag == 0)
    return(HTTP_NOT_CONNECTED);

  if(SrcLen == 0)
    return(0);
  //----------------------------------------------------------------
  // call the service routine
  //----------------------------------------------------------------
  Retcode = pXhOcspStruc->amc_ocsp_send(pXhOcspStruc->pOcspCtxStruc,
					pSrcBuf+SrcOff,SrcLen);
  return(Retcode);
}

extern "C"  int  XH_OcspReceive(XH_OCSP_STRUC * pXhOcspStruc,
		char pDstBuf[], int DstOff, int DstBufLen, int )
{
  int RxLen, CopyCount;

  struct dsd_hl_ocsp_rec * pRxStruc = NULL;
  
  //----------------------------------------------------------------
  // check parameters
  //----------------------------------------------------------------
  if((pXhOcspStruc == NULL) || (pDstBuf == NULL) ||
     (pXhOcspStruc->amc_ocsp_recv == NULL))
    return(HOCSP_NULL_PTR);

  if(DstBufLen <= 0)
    return(HOCSP_PARAM_ERR);

  //----------------------------------------------------------------
  // check if connected
  //----------------------------------------------------------------
  if(pXhOcspStruc->ConnectedFlag == 0)
    return(HTTP_NOT_CONNECTED);

  //----------------------------------------------------------------
  // check if we have a receive buffer with data
  //----------------------------------------------------------------
  if((pXhOcspStruc->pRxBuf == NULL) || (pXhOcspStruc->ActRxDataLen <= 0))
  {
    //------------------------------------------------------------
    // no data available, must receive a block of data now
    //------------------------------------------------------------
    FREE_ARRAY(pXhOcspStruc->pMemCtxStruc,pXhOcspStruc->pRxStruc);
    pXhOcspStruc->pRxBuf         = NULL;
    pXhOcspStruc->ActRxDataLen   = 0;
    pXhOcspStruc->ActRxDataIndex = 0;

    pRxStruc = pXhOcspStruc->amc_ocsp_recv(pXhOcspStruc->pOcspCtxStruc);

    if(pRxStruc == NULL)		// should not happen...
    {

      return(0);			// say closed by remote
    }

    RxLen = pRxStruc->inp_data_len;	// get size of data
    if(RxLen <= 0)			// closed / error
    {
      FREE_CARRAY(pXhOcspStruc->pMemCtxStruc,pRxStruc);
      return(RxLen);
    }
    //------------------------------------------------------------
    // data available now, set up structure data
    //------------------------------------------------------------
    pXhOcspStruc->pRxStruc = pRxStruc;
    pXhOcspStruc->pRxBuf   = (char*)
	 ((void *) (((char *) ((void *) pRxStruc)) + sizeof(int)));
    pXhOcspStruc->ActRxDataLen = RxLen;
  }
  //--------------------------------------------------------------
  // Data are on the buffer, transfer as many as possible
  //--------------------------------------------------------------
  CopyCount = pXhOcspStruc->ActRxDataLen;
  if(CopyCount > DstBufLen)
    CopyCount = DstBufLen;

  memcpy(pDstBuf+DstOff,
         pXhOcspStruc->pRxBuf+pXhOcspStruc->ActRxDataIndex,
         CopyCount);

  pXhOcspStruc->ActRxDataIndex += CopyCount;
  pXhOcspStruc->ActRxDataLen   -= CopyCount;
  return(CopyCount);
}

extern "C"  int  XH_OcspDisconnect(XH_OCSP_STRUC * pXhOcspStruc)
{

  //----------------------------------------------------------------
  // check parameters
  //----------------------------------------------------------------
  if((pXhOcspStruc == NULL) ||
     (pXhOcspStruc->amc_ocsp_stop == NULL))
    return(HOCSP_NULL_PTR);

  //----------------------------------------------------------------
  // check if connected at all, if so, stop
  //----------------------------------------------------------------
  if(pXhOcspStruc->ConnectedFlag != 0)
  {
    pXhOcspStruc->amc_ocsp_stop(pXhOcspStruc->pOcspCtxStruc);
    pXhOcspStruc->ConnectedFlag = 0;
  }
  return(0);
}
/** @} */
#endif // XH_INTERFACE


#endif //HL_CERT_OCSP
// end of file ../hocsp/hocspxh.cpp


#ifdef HL_CERT_OCSP
//******************************************************************
//
// TCP helper functions needed for testing with the XH interface
// for OCSP retrieval
//
//******************************************************************
#if defined XH_INTERFACE
#if (defined _WIN32) & (_MSC_VER < 1700)
#ifndef _STDINT
#define _STDINT
// MSVC lower than 17.00 does not have stdint.h, assure, all needed types are defined

typedef unsigned __int16 uint16_t;

typedef unsigned __int32 uint32_t;

typedef unsigned __int64 uint64_t;

#endif // !_STDINT
#else
#include <stdint.h>
#endif
#include <stddef.h>
#ifdef _WIN32
#define WIN32_LEAN_AND_MEAN
#include <Windows.h>
#undef WIN32_LEAN_AND_MEAN
#else// Define system-specific HL_* defines here
#ifndef HL_UNIX
#define HL_UNIX

#if (defined __gnu_linux__) || (defined __linux__)
#define HL_LINUX
#endif

#if (defined __APPLE__) && (defined __MACH__)
#define HL_LINUX
#define HL_MACOS
#endif

#ifdef _AIX
#define HL_AIX
#define HL_BIG_ENDIAN
#endif

#ifdef __FreeBSD__
#define HL_FREEBSD
#endif

#if (defined _hpux) || (defined hpux) || (defined __hpux)
#define HL_HPUX
#define HL_BIG_ENDIAN
#endif

#if (defined sun) || (defined __sun)
#define HL_SOLARIS
#endif

#if (defined __arm__) || (defined __aarch64__)
#define HL_LINUX_ARM
#endif

#ifdef __ANDROID__
#define HL_ANDROID
#endif

#endif
#include <hob-unix01.h>
#endif
#ifdef __APPLE__
/* We get target conditionals to keep apart Mac OS, iOS and iOS simulator.
   The conditionals are TARGET_IPHONE_SIMULATOR, TARGET_OS_IPHONE and TARGET_OS_MAC.
   TARGET_IPHONE_SIMULATOR has the highest priority, TARGET_OS_MAC the lowest.
   Always test, if the conditional is 1, as they will be defined as 0, if we 
   are not compiling for the target.
   */
#include <TargetConditionals.h>
#endif

#ifdef HL_ANDROID
#include <netdb.h>
#include <unistd.h>
#include <linux/in.h>
#ifndef SOCKLEN_T
#define SOCKLEN_T      int
#endif
#ifndef SA_FAMILY_T
#define SA_FAMILY_T  short
#endif
#include <sys/endian.h>
#include <asm/ioctls.h>
#include <errno.h>
#endif

#include "hob-encry-1.h"
#include "hob-cert-ext.h"
#ifdef _WIN32
#include <winsock.h>
#endif
#include "hob-cert-err.h"
#include <string.h>
#include "hob-cert-intern.h"
#include "hob-cert-err.h"
/** @addtogroup hocsp
* @{
* @file
* This file implements TCP helper functions for OCSP retrieval.
* @}
*/

/**
* Wait specified amount of time in Milliseconds !!
*
*  @param DelayMilliSeconds
*/
static  void  SleepMillis(int DelayMilliSeconds)
{
#if defined _WIN32
  Sleep(DelayMilliSeconds);
#else  // UNIX
  if(DelayMilliSeconds < 1000)
    DelayMilliSeconds = 1000;
  sleep((unsigned int) (DelayMilliSeconds+999)/1000);
#endif
}

/**
* Frees a TCP helper structure (and elements).
*
*  @param pXhTcpHlpStruc Structure to be freed
*/
extern "C"  void  FreeXhTcpHlpStruc(XH_TCP_HLP_STRUC * pXhTcpHlpStruc)
{
  if((pXhTcpHlpStruc == NULL) || (pXhTcpHlpStruc->pMemCtxStruc == NULL))
    return;
  
  FREE_CARRAY(pXhTcpHlpStruc->pMemCtxStruc,pXhTcpHlpStruc);
}

/**
* Allocates a TCP helper structure and initializes it.
*
*  @param pMemCtxStruc Memory context structure
*  @return new <code>XH_TCP_HLP_STRUC_PTR</code> / NULL
*/
extern "C"  XH_TCP_HLP_STRUC *  AllocXhTcpHlpStruc(
					ds__hmem * pMemCtxStruc)
{
  XH_TCP_HLP_STRUC * pXhTcpHlpStruc;

  if(pMemCtxStruc == NULL)
    return(NULL);

  //--------------------------------------------------------------
  // allocate the structure, clear it
  // NOTE: Allocate direct from system !!!
  //--------------------------------------------------------------
  if((pXhTcpHlpStruc = (XH_TCP_HLP_STRUC *)
        ((void *) BIT8_ARRAY_CALLOCEX(pMemCtxStruc,
				    1,sizeof(XH_TCP_HLP_STRUC)))) == NULL)
    return(NULL);

  pXhTcpHlpStruc->pMemCtxStruc  = pMemCtxStruc;
  pXhTcpHlpStruc->ConnectedFlag = 0;
  pXhTcpHlpStruc->TcpSocket     = INVALID_SOCKET;
  return(pXhTcpHlpStruc);
}

// new version with URL
/**
* TCP Connect function for the XH interface.
*
*  @param vpp_userfld here: TCP helper context
*  @param pXhOcspConnStruc OCSP XH context structure
*  @return 0 on success, error code otherwise
*/
extern "C"  int XhTcpStart(void * vpp_userfld,
			     struct dsd_hl_ocsp_d_1 * pXhOcspConnStruc)
{
  int Retcode,Len;
  int UrlNameLen;
  int HostNameLen;
  int MaxRetryCnt,ConnectRetryCnt;
  int ActAdrFamily;
  int ConnectedFlag = 0;
  int DstPort;

  char* pUrlName;
  char* pHostName = NULL;
  char* pFullUrlName;

  URL_STRUC * pUrl;
  

  ADDRINF * pBaseAdrInfo = NULL;
  ADDRINF * pActAdrInfo;
  ADDRINF * pTmpAdrInfo[1];

  SADDRIN * pActDstAdr = NULL;

  SOCKET pTmpSock[1];

  char NumHostNameBuf[NI_MAXHOST];
  char NumPortNameBuf[NI_MAXSERV];

  XH_TCP_HLP_STRUC * pXhTcpHlpStruc =
     	(XH_TCP_HLP_STRUC *) vpp_userfld;

  HMEM_CTX_DEF1;

  if((vpp_userfld == NULL) || (pXhOcspConnStruc == NULL))
    return(HOCSP_NULL_PTR);

  LOAD_HMEM_CTX_PTR(pXhTcpHlpStruc->pMemCtxStruc);

  //---------------------------------------------------------
  // Check if already connected
  //---------------------------------------------------------
  if(pXhTcpHlpStruc->ConnectedFlag != 0)
    return(HTTP_ALREADY_CONNECTED);

//  pXhTcpHlpStruc->TcpSocket     = INVALID_SOCKET;
//  pXhTcpHlpStruc->ConnectedFlag = 0;

  //---------------------------------------------------------
  // Get the URL to use as ASCIIz string
  //---------------------------------------------------------
  pUrlName   = pXhOcspConnStruc->achc_url;
  UrlNameLen = pXhOcspConnStruc->inc_url_len;

  if((pUrlName == NULL) || (UrlNameLen <= 0))
    return(HTTP_CONNECT_NO_HOST_NAME);

  if((pFullUrlName = BIT8_ARRAY_ALLOC(HMEM_CTX_REF,
				      UrlNameLen+1)) == NULL)
    return(HOCSP_ALLOC_ERR);

  memcpy(pFullUrlName+0,pUrlName+0,UrlNameLen);

  pFullUrlName[UrlNameLen] = 0;			// delimit

  //---------------------------------------------------------
  // Retrieve destination name and port, check validity
  //---------------------------------------------------------
  Retcode = ParseUrl(HMEM_CTX_REF,pXhOcspConnStruc->achc_url,
		         &pUrl);
  FREE_CARRAY(HMEM_CTX_REF,pFullUrlName);

  if(Retcode != HOCSP_OP_OK)
    return(Retcode);

  pHostName    = pUrl->pHost;
  pUrl->pHost  = NULL;				// avoid freeing
  HostNameLen  = Strlen(pHostName,0);
  DstPort      = pUrl->PortNr;

  FreeUrlStruc(HMEM_CTX_REF,pUrl);

  if((pHostName == NULL) || (HostNameLen <= 0))
    return(HTTP_CONNECT_NO_HOST_NAME);

  if(DstPort <= 0)
  {
    FREE_CARRAY(HMEM_CTX_REF,pHostName);
    return(HTTP_CONNECT_INVALID_PORT);
  }

  //-----------------------------------------------------------------------
  // get a list of all available addresses for the named host (i.e. server)
  //-----------------------------------------------------------------------
  if((pBaseAdrInfo = AllocAddrInfoStruct(HMEM_CTX_REF1 1)) == NULL)
  {
    FREE_CARRAY(HMEM_CTX_REF,pHostName);
    return(HOCSP_ALLOC_ERR);
  }
  Len = WordToDecimalAscii(DstPort & 0xFFFF,NumPortNameBuf,0);
  NumPortNameBuf[Len] = 0;

  pBaseAdrInfo->AdrFamily = AF_UNSPEC;
  pBaseAdrInfo->SockType  = SOCK_STREAM;

  Retcode = GetAddrInfo(HMEM_CTX_REF1 pHostName,0,NumPortNameBuf,0,pBaseAdrInfo,pTmpAdrInfo);
  FreeAddrInfoStruct(HMEM_CTX_REF1 pBaseAdrInfo);
  if(Retcode != 0)
  {
    FREE_CARRAY(HMEM_CTX_REF,pHostName);

    if(Retcode == EAI_NODATA)
      return(HTTP_CONNECT_RESOLVE_DNS_FAILED);

    return(HTTP_CONNECT_GET_ADRINFO_FAILED);
  }
  pBaseAdrInfo = pTmpAdrInfo[0];		// is now reused !!!

  //----------------------------------------------------------
  // Try to connect several times.  On some machines, the first time
  // will sometimes fail.
  //----------------------------------------------------------
  MaxRetryCnt = DEFAULT_HTTP_CONNECT_RETRY_CNT;

  Retcode = HTTP_OP_OK;
  for(ConnectRetryCnt = 0;ConnectRetryCnt < MaxRetryCnt;ConnectRetryCnt++)
  {
//  if(ConnectRetryCnt > 0)
//    debug("Trying again...");
    //----------------------------------------------------------
    // Loop through addresses for this host, and try each one in
    // sequence until the connection succeeds.
    //----------------------------------------------------------
    pActAdrInfo = pBaseAdrInfo;
    for(;pActAdrInfo != NULL;pActAdrInfo= pActAdrInfo->pNext)
    {
      ActAdrFamily = pActAdrInfo->AdrFamily;
      if((ActAdrFamily != AF_INET) && (ActAdrFamily != AF_INET6))
        continue;

      pActDstAdr = pActAdrInfo->pSockAdr;

      if(GetNameInfo(HMEM_CTX_REF1 pActDstAdr,NumHostNameBuf,0,NI_MAXHOST,NumPortNameBuf,0,NI_MAXSERV,NI_NUMERICHOST | NI_NUMERICSERV) != 0)
      {
//      error("ssh_connect: getnameinfo failed");
	continue;
      }

//    debug("Connecting to %.200s [%.100s] port %s.", host, ntop, strport);

      //-------------------------------------------------------------
      // create a socket, bind to socket and connect to destination
      // NOTE: if unpriviledged requested and a bindaddress is given,
      //       the socket is also bound to the given
      //       bindaddress (i.e. the Network Adapter to use).
      //-------------------------------------------------------------
      //-----------------------------------------------------------
      // Now: Get socket, Bind local (if required) and connect
      //-----------------------------------------------------------
      if((Retcode = BindAndConnect(pActDstAdr,NULL,pTmpSock)) == HTTP_OP_OK)
      {
        ConnectedFlag = 1;
        break;
      }
    } // Addressinfo processing
    if(ConnectedFlag != 0)		// Successful connection
      break;

//    SleepMillis(1000);
    SleepMillis(200);
  } // connect retry loop
  FREE_CARRAY(HMEM_CTX_REF,pHostName);
  //-----------------------------------------------------------
  // Cleanup structures in use
  //-----------------------------------------------------------
  if(ConnectedFlag == 0)
  {
    FreeAddrInfoStruct(HMEM_CTX_REF1 pBaseAdrInfo);
    return(HTTP_CONNECT_CONNECT_FAILED);
  }

//  debug("Connection established.");

  FreeAddrInfoStruct(HMEM_CTX_REF1 pBaseAdrInfo);// no longer needed
  //-----------------------------------------------------------
  // Set the sockets options now
  //-----------------------------------------------------------

  //-----------------------------------------------------------
  // Save the socket to structure
  //-----------------------------------------------------------
  pXhTcpHlpStruc->TcpSocket = pTmpSock[0];
  pXhTcpHlpStruc->ConnectedFlag = 1;
  return(HTTP_OP_OK);
}

/**
* Sends data over TCP port to destination.
*
*  @param vpp_userfld here: TCP helper context
*  @param achp_buf Data buffer
*  @param inp_len Amount of data to send
*  @return Amount of data sent if >= 0, else error occured
*/
extern "C"  int XhTcpSend(void * vpp_userfld, char * achp_buf,
			    int inp_len)
{
  int Retcode;

  XH_TCP_HLP_STRUC * pXhTcpHlpStruc =
  	(XH_TCP_HLP_STRUC *) vpp_userfld;

  HMEM_CTX_DEF1;

  if((vpp_userfld == NULL) || (achp_buf == NULL))
    return(HOCSP_NULL_PTR);

  LOAD_HMEM_CTX_PTR(pXhTcpHlpStruc->pMemCtxStruc);

  //---------------------------------------------------------
  // Check if connected
  //---------------------------------------------------------
  if(pXhTcpHlpStruc->ConnectedFlag == 0)
    return(HTTP_NOT_CONNECTED);

  Retcode = SendWaitSock(pXhTcpHlpStruc->TcpSocket,achp_buf,0,inp_len,0);
  return(Retcode);
}

/**
* Receives data over TCP port from destination.
*
*  @param vpp_userfld here: TCP helper context
*  @return Receive structure / NULL
*/
extern "C"  struct dsd_hl_ocsp_rec * XhTcpRecv(void * vpp_userfld)
{
  int Len;

#define	XH_DEFAULT_RX_BUFLEN	128		// better suited for testing...

  char* pRxBuf = NULL;
  struct dsd_hl_ocsp_rec * pRxStruc;

  XH_TCP_HLP_STRUC * pXhTcpHlpStruc =
  	(XH_TCP_HLP_STRUC *) vpp_userfld;

  HMEM_CTX_DEF1;

  if(vpp_userfld == NULL)
    return(NULL);

  LOAD_HMEM_CTX_PTR(pXhTcpHlpStruc->pMemCtxStruc);

  //---------------------------------------------------------
  // Allocate the receive structure incl. buffer, use 1k + xxx
  // NOTE: Allocate direct from system !!!
  //---------------------------------------------------------
  if((pRxBuf = BIT8_ARRAY_ALLOCEX(HMEM_CTX_REF,XH_DEFAULT_RX_BUFLEN)) == NULL)
    return(NULL);

  pRxStruc = (struct dsd_hl_ocsp_rec *) ((void *) pRxBuf);

  //---------------------------------------------------------
  // Check if connected
  //---------------------------------------------------------
  if(pXhTcpHlpStruc->ConnectedFlag == 0)
  {
    pRxStruc->inp_data_len = HTTP_NOT_CONNECTED;
    return(pRxStruc);
  }
  //---------------------------------------------------------
  // Receive data
  //---------------------------------------------------------
  if((Len = ReceiveWaitSock(pXhTcpHlpStruc->TcpSocket,pRxBuf,sizeof(int),XH_DEFAULT_RX_BUFLEN-sizeof(int),HTTP_HEADER_TIMEOUT)) > 0)
  {
    //-------------------------------------------------------
    // receive o.k. with data
    //-------------------------------------------------------
    pRxStruc->inp_data_len = Len;
    return(pRxStruc);
  }

  switch(Len)
  {
    case 0:			// connection closed by partner      
//      pRxStruc->inp_data_len = HTTP_HDR_PARSE_CONN_CLOSED;
      pRxStruc->inp_data_len = 0;
      break;

    case -2:			// RX timeout
      pRxStruc->inp_data_len = HTTP_HDR_PARSE_RX_TIMED_OUT;
      break;

    case -1:			// RX error occured
    default:
      pRxStruc->inp_data_len = HTTP_HDR_PARSE_RX_ERR;
      break;
  }
  return(pRxStruc);
}

/**
* Closes connection to destination (if still open).
*
*  @param vpp_userfld here: TCP helper context
*/
extern "C"  void XhTcpStop(void * vpp_userfld)
{
  XH_TCP_HLP_STRUC * pXhTcpHlpStruc =
    	(XH_TCP_HLP_STRUC *) vpp_userfld;

  if(vpp_userfld == NULL)
    return;

  //---------------------------------------------------------
  // Check if socket still present
  //---------------------------------------------------------
  if(pXhTcpHlpStruc->TcpSocket != INVALID_SOCKET)
  {
    CloseSocket(pXhTcpHlpStruc->TcpSocket);
    pXhTcpHlpStruc->TcpSocket = INVALID_SOCKET;
  }
  pXhTcpHlpStruc->ConnectedFlag = 0;
}

/**
* Prepares a given OCSP XH interface structure for use with
* own tester routines.
*
*  @param pXhOcspStruc Structure to prepare
*  @return 0 on success, error code otherwise
*/
extern "C"  int  XhTestPrepOcspStruc(XH_OCSP_STRUC * pXhOcspStruc)
{

  XH_TCP_HLP_STRUC * pXhHlpStruc;

  if((pXhOcspStruc == NULL) || (pXhOcspStruc->pMemCtxStruc == NULL))
    return(HOCSP_NULL_PTR);

  //-------------------------------------------------------
  // get the helper structure for TCP tester routines
  //-------------------------------------------------------
  if((pXhHlpStruc = AllocXhTcpHlpStruc(pXhOcspStruc->pMemCtxStruc)) == NULL)
    return(HOCSP_ALLOC_ERR);

  //-------------------------------------------------------
  // Initialize the OCSP control structure now...
  //-------------------------------------------------------

  pXhOcspStruc->amc_ocsp_start = &XhTcpStart;
  pXhOcspStruc->amc_ocsp_send  = &XhTcpSend;
  pXhOcspStruc->amc_ocsp_recv  = &XhTcpRecv;
  pXhOcspStruc->amc_ocsp_stop  = &XhTcpStop;

  pXhOcspStruc->pOcspCtxStruc    = pXhHlpStruc;
  pXhOcspStruc->pTestHlpCtxStruc = pXhHlpStruc;

  pXhOcspStruc->ConnectedFlag  = 0;
  
  pXhOcspStruc->pRxBuf         = NULL;
  pXhOcspStruc->ActRxDataLen   = 0;
  pXhOcspStruc->ActRxDataIndex = 0;

//  FREE_CARRAY(pXhOcspStruc->pMemCtxStruc,pXhOcspStruc->pRxStruc);
  pXhOcspStruc->pRxStruc = NULL;

  return(HOCSP_OP_OK);
}
/** @} */

#endif // XH_INTERFACE

#endif //HL_CERT_OCSP
// end of file ../hocsp/hocsphlx.cpp


#ifdef HL_CERT_OCSP
/** @defgroup http HTTP and URL utility
* @ingroup util
* This module provides functions for HTTP connections and URL processing.
*
* It also offers a routine for sending OCSP requests and receiving the reply 
* in a single pass.
* @{
* @file
* This file implements the bulk of the HTTP module.
* @}
*/
//***************************************************************
//
// HTTP Connection and URL processing routines
//
// (C) HOB Gmbh & Co. KG, Cadolzburg, 2004
// Author: G. Oed
// Date:   2004/05/26
//
//***************************************************************
#if (defined _WIN32) & (_MSC_VER < 1700)
#ifndef _STDINT
#define _STDINT
// MSVC lower than 17.00 does not have stdint.h, assure, all needed types are defined

typedef unsigned __int16 uint16_t;

typedef unsigned __int32 uint32_t;

typedef unsigned __int64 uint64_t;

#endif // !_STDINT
#else
#include <stdint.h>
#endif
#include <stddef.h>
#ifdef _WIN32
#define WIN32_LEAN_AND_MEAN
#include <Windows.h>
#undef WIN32_LEAN_AND_MEAN
#else// Define system-specific HL_* defines here
#ifndef HL_UNIX
#define HL_UNIX

#if (defined __gnu_linux__) || (defined __linux__)
#define HL_LINUX
#endif

#if (defined __APPLE__) && (defined __MACH__)
#define HL_LINUX
#define HL_MACOS
#endif

#ifdef _AIX
#define HL_AIX
#define HL_BIG_ENDIAN
#endif

#ifdef __FreeBSD__
#define HL_FREEBSD
#endif

#if (defined _hpux) || (defined hpux) || (defined __hpux)
#define HL_HPUX
#define HL_BIG_ENDIAN
#endif

#if (defined sun) || (defined __sun)
#define HL_SOLARIS
#endif

#if (defined __arm__) || (defined __aarch64__)
#define HL_LINUX_ARM
#endif

#ifdef __ANDROID__
#define HL_ANDROID
#endif

#endif
#include <hob-unix01.h>
#endif
#ifdef __APPLE__
/* We get target conditionals to keep apart Mac OS, iOS and iOS simulator.
   The conditionals are TARGET_IPHONE_SIMULATOR, TARGET_OS_IPHONE and TARGET_OS_MAC.
   TARGET_IPHONE_SIMULATOR has the highest priority, TARGET_OS_MAC the lowest.
   Always test, if the conditional is 1, as they will be defined as 0, if we 
   are not compiling for the target.
   */
#include <TargetConditionals.h>
#endif

#ifdef HL_ANDROID
#include <netdb.h>
#include <unistd.h>
#include <linux/in.h>
#ifndef SOCKLEN_T
#define SOCKLEN_T      int
#endif
#ifndef SA_FAMILY_T
#define SA_FAMILY_T  short
#endif
#include <sys/endian.h>
#include <asm/ioctls.h>
#include <errno.h>
#endif

#include "hob-encry-1.h"
#include "hob-cert-ext.h"
#ifdef _WIN32
#include <winsock.h>
#endif
#include "hob-cert-err.h"
#include <string.h>
#include "hob-cert-intern.h"

//()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()
//
// Code/Data for C Implementation
//
//()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()

#define	KNOWN_REQ_METHODS_CNT	7

char* AllowedRequestMethods [KNOWN_REQ_METHODS_CNT] = {
	(char*) "GET",
	(char*) "POST",
        (char*) "HEAD",
        (char*) "OPTIONS",
        (char*) "PUT",
        (char*) "DELETE",
        (char*) "TRACE"
};

char HttpVersion[9]  = { "HTTP/1.1" };
char AgentVersion[6] = { HSSL_VERSION_3_STR "." HSSL_VERSION_4_STR };
char AgentName[15]   = { HSSL_VERSION_PROD_TXT };

char DefaultAcceptValue[53] = {
   "text/html, image/gif, image/jpeg, *; q=.2, */*; q=.2"};

char DefaultContentValue[34] = {
   "application/x-www-form-urlencoded"};

//()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()
//()
//() global helper routines
//()
//()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()

/** @addtogroup http
*@{
*/
#if !defined XH_INTERFACE
/**
* Wait specified amount of time in Milliseconds (SleepMillis).
*
*  @param DelayMilliSeconds
*/
static  void  SleepMillis(int DelayMilliSeconds)
{
#if defined _WIN32
  Sleep(DelayMilliSeconds);
#else // UNIX
  if(DelayMilliSeconds < 1000)
    DelayMilliSeconds = 1000;
  sleep((unsigned int) (DelayMilliSeconds+999)/1000);
#endif

}
#endif // XH_INTERFACE

/**
* Converts an ASCIIz string to upper characters (Strupper).
*
*  @param pStr Base of buffer
*  @param StrOff Start of data
*/
extern "C"  void  Strupper(char* pStr, int StrOff)
{
  int StrLen;
  //------------------------------------------------------------
  // get size of String to parse, check special conditions first
  //------------------------------------------------------------
  StrLen = Strlen(pStr,StrOff);
  while(StrLen > 0)
  {
    pStr[StrOff] = (unsigned char) To_Upper(pStr[StrOff] & 0xFF);
    StrOff++;
    StrLen--;
  }
}
//()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()
//
//
//  HTTP protocol message header processing routines
//
//
//()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()

// the HTTP header functions are now in httphdr.c
// which is included here...

/** @addtogroup http
* @{
* @file
* This file provides the HTTP module with additional support functions.
*/

/**
* Frees a message headers structure and its elements (FreeHttpMsgHdrsStruc).
*
*  @param pMsgHdrsStruc Structure to be freed
*/
extern "C"  void  FreeHttpMsgHdrsStruc(HMEM_CTX_DEF
				HTTP_MSG_HDRS * pMsgHdrsStruc)
{
  int Index;
  char** ppFieldNameArr;
  char** ppFieldValueArr;

  if(pMsgHdrsStruc == NULL)
    return;

  ppFieldNameArr  = pMsgHdrsStruc->pFieldNameArr;
  ppFieldValueArr = pMsgHdrsStruc->pFieldValueArr;

  Index = pMsgHdrsStruc->UsedSlots - 1;	// number of elements used

  while(Index >= 0)
  {
    FREE_ARRAY(HMEM_CTX_REF,ppFieldNameArr[Index]);	// will check for NULL      
    FREE_ARRAY(HMEM_CTX_REF,ppFieldValueArr[Index]);	// will check for NULL      
    Index--;
  }
  FREE_ARRAY(HMEM_CTX_REF,ppFieldNameArr);
  FREE_ARRAY(HMEM_CTX_REF,ppFieldValueArr);
  FREE_CARRAY(HMEM_CTX_REF,pMsgHdrsStruc);
}

/**
* Allocates a message headers structure and the arrays if
* requested (AllocHttpMsgHdrsStruc).
*
*  @param ElementCnt Number of elements to allocate
*  @return New HTTP_MSG_HDRS_PTR / NULL on error
*/
extern "C"  HTTP_MSG_HDRS *  AllocHttpMsgHdrsStruc(
				HMEM_CTX_DEF
				int ElementCnt)
{
  HTTP_MSG_HDRS * pMsgHdrsStruc;
  char** ppFieldNameArr  = NULL;
  char** ppFieldValueArr = NULL;

  if(ElementCnt < 0)
    return(NULL);
  //----------------------------------------------------------
  // Allocate the structure itself clear it
  //----------------------------------------------------------
  if((pMsgHdrsStruc = (HTTP_MSG_HDRS *)
        ((void *) BIT8_ARRAY_CALLOC(HMEM_CTX_REF,
				    1,sizeof(HTTP_MSG_HDRS)))) == NULL)
    return(NULL);
  //----------------------------------------------------------
  // Check if the arrays have to be allocated too
  //----------------------------------------------------------
  if(ElementCnt == 0)
    return(pMsgHdrsStruc);

  ppFieldNameArr  = (char**)
    ((void *) BIT8_ARRAY_CALLOC(HMEM_CTX_REF,
			        ElementCnt,sizeof(char*)));
  ppFieldValueArr = (char**)
    ((void *) BIT8_ARRAY_CALLOC(HMEM_CTX_REF,
				ElementCnt,sizeof(char*)));
  if((ppFieldNameArr == NULL) || (ppFieldValueArr == NULL))
  {
    FREE_ARRAY(HMEM_CTX_REF,ppFieldNameArr);
    FREE_ARRAY(HMEM_CTX_REF,ppFieldValueArr);
    FREE_CARRAY(HMEM_CTX_REF,pMsgHdrsStruc);
    return(NULL);
  }

  pMsgHdrsStruc->pFieldNameArr  = ppFieldNameArr;
  pMsgHdrsStruc->pFieldValueArr = ppFieldValueArr;
  pMsgHdrsStruc->AllocedSlots   = ElementCnt;
  return(pMsgHdrsStruc);
}
/**
* Expands message headers structure arrays by given amount (ExpandHttpMsgHdrsStrucArrays).
*
*  @param pMsgHdrsStruc Used message headers struct
*  @param ExpandCount Number of elements to append
*  @return 0 on success, else error occured
*/
extern "C"  int  ExpandHttpMsgHdrsStrucArrays(HMEM_CTX_DEF
		HTTP_MSG_HDRS * pMsgHdrsStruc, int ExpandCount)
{

  int NewSize;
  int UsedSlots;
  int Index;
  char** ppNewFieldNameArr;
  char** ppOldFieldNameArr;
  char** ppNewFieldValueArr;
  char** ppOldFieldValueArr;

  if(pMsgHdrsStruc == NULL)
    return(HTTP_NULL_PTR);
  if(ExpandCount < 0)
    return(HTTP_PARAM_ERR);

  if(ExpandCount == 0)
    return(HTTP_OP_OK);

  //-------------------------------------------------------
  // Allocate new pointer arrays
  //-------------------------------------------------------
  NewSize = ExpandCount + pMsgHdrsStruc->AllocedSlots;

  ppNewFieldNameArr  = (char**)
    ((void *) BIT8_ARRAY_CALLOC(HMEM_CTX_REF,
				NewSize, sizeof(char*)));
  ppNewFieldValueArr = (char**)
    ((void *) BIT8_ARRAY_CALLOC(HMEM_CTX_REF,
				NewSize, sizeof(char*)));

  if((ppNewFieldNameArr == NULL) || (ppNewFieldValueArr == NULL))
  {
    FREE_ARRAY(HMEM_CTX_REF,ppNewFieldNameArr);
    FREE_ARRAY(HMEM_CTX_REF,ppNewFieldValueArr);
    return(HTTP_ALLOC_ERR);
  }
  //-------------------------------------------------------
  // copy old pointers to new arrays, free old arrays
  //-------------------------------------------------------
  UsedSlots = pMsgHdrsStruc->UsedSlots;
  ppOldFieldNameArr  = pMsgHdrsStruc->pFieldNameArr;
  ppOldFieldValueArr = pMsgHdrsStruc->pFieldValueArr;

  if(ppOldFieldNameArr != NULL)
  {
    for(Index = 0; Index < UsedSlots; Index++)
      ppNewFieldNameArr[Index] = ppOldFieldNameArr[Index];

    FREE_CARRAY(HMEM_CTX_REF,ppOldFieldNameArr);
  }
  pMsgHdrsStruc->pFieldNameArr = ppNewFieldNameArr;

  if(ppOldFieldValueArr != NULL)
  {
    for(Index = 0; Index < UsedSlots; Index++)
      ppNewFieldValueArr[Index] = ppOldFieldValueArr[Index];

    FREE_CARRAY(HMEM_CTX_REF,ppOldFieldValueArr);
  }
  pMsgHdrsStruc->pFieldValueArr = ppNewFieldValueArr;
  pMsgHdrsStruc->AllocedSlots = NewSize;
  return(HTTP_OP_OK);
}

/**
* Clears a message headers structure (ClearHttpMsgHdrsStruc).
*
* This will free all in use elements and reset the in use count to 0.
*
*  @param pMsgHdrsStruc Structure to be cleared
*/
extern "C"  void  ClearHttpMsgHdrsStruc(HMEM_CTX_DEF
			HTTP_MSG_HDRS * pMsgHdrsStruc)
{
  int Index;
  char** ppFieldNameArr;
  char** ppFieldValueArr;

  if(pMsgHdrsStruc == NULL)
    return;

  ppFieldNameArr  = pMsgHdrsStruc->pFieldNameArr;
  ppFieldValueArr = pMsgHdrsStruc->pFieldValueArr;

  Index = pMsgHdrsStruc->UsedSlots - 1;	// number of elements used

  while(Index >= 0)
  {
    FREE_ARRAY(HMEM_CTX_REF,ppFieldNameArr[Index]);	// will check for NULL      
    FREE_ARRAY(HMEM_CTX_REF,ppFieldValueArr[Index]);	// will check for NULL      
    Index--;
  }
  pMsgHdrsStruc->UsedSlots = 0;
}

/**
* Gets the value for a given field name if present (FindFieldValue).
* The names array is searched from the top down to the bottom
* for a case insensitive match.
*
* NOTE: <ol>
*  <li> When the returned value pointer is NULL, the specified
*     field name was not found.
*	<li> The returned value pointer may be an empty string if
*	    no value was present for the field name.
*</ol>
*  @param pMsgHdrsStruc Message header structure to be used
*  @param pFieldName ASCIIz Name or NULL
*  @return pValue / NULL if not found
*/
extern "C"  char* FindFieldValue(HTTP_MSG_HDRS * pMsgHdrsStruc,
				char* pFieldName)
{
  int Index;
  char** ppFieldNameArr;
  char** ppFieldValueArr;

  if(pMsgHdrsStruc == NULL)
    return(NULL);

  Index = pMsgHdrsStruc->UsedSlots-1;
  if(Index < 0)
    return(NULL);

  ppFieldNameArr  = pMsgHdrsStruc->pFieldNameArr;
  ppFieldValueArr = pMsgHdrsStruc->pFieldValueArr;

  if(pFieldName == NULL)			// special case...
  {
    while(Index >= 0)
    {
      if(ppFieldNameArr[Index] == NULL)		// no name, but used
        return(ppFieldValueArr[Index]);
      Index--;
    }
  }
  else						// a name is given
  {
    while(Index >= 0)
    {
      if(ppFieldNameArr[Index] != NULL)		// a name is present
      {
        if(Stricmp(ppFieldNameArr[Index],0,pFieldName,0) == 0)
          return(ppFieldValueArr[Index]);
      }
      Index--;
    }
  }
  return(NULL);
}        
/**
* Gets the field name for a given array index (GetFieldName).
*
* This is normally used to retrieve the first part of the response
* status line (which always has index 0).
*
*  @param pMsgHdrsStruc Message header structure to be used
*  @param NameIndex 0 based !
*  @return BIT8PTR pValue / NULL if not found
*/
extern "C"  char* GetFieldName(HTTP_MSG_HDRS * pMsgHdrsStruc,
				   int NameIndex)
{
  int Index;

  if((pMsgHdrsStruc == NULL) || (NameIndex < 0))
    return(NULL);

  Index = pMsgHdrsStruc->UsedSlots-1;
  if((Index < 0) || (NameIndex > Index))
    return(NULL);

  return(pMsgHdrsStruc->pFieldNameArr[NameIndex]);
}
/**
* Gets the value for a given array index (GetFieldValue).
*
* This is normally used to retrieve the response status line
* (which always has index 0).
*
*  @param pMsgHdrsStruc Message header structure to be used
*  @param ValueIndex 0 based !
*  @return BIT8PTR pValue / NULL if not found
*/
extern "C"  char* GetFieldValue(HTTP_MSG_HDRS * pMsgHdrsStruc,
				int ValueIndex)
{
  int Index;

  if((pMsgHdrsStruc == NULL) || (ValueIndex < 0))
    return(NULL);

  Index = pMsgHdrsStruc->UsedSlots-1;
  if((Index < 0) || (ValueIndex > Index))
    return(NULL);

  return(pMsgHdrsStruc->pFieldValueArr[ValueIndex]);
}

/**
* Adds a Fieldname/Value pair to the header list at the end (AddNameValueListEnd).
*
*  @param pMsgHdrsStruc Message header structure to be used
*  @param pFieldName Name / NULL
*  @param pFieldValue Value / Null
*  @return 0 on success, else error occured
*/
extern "C"  int AddNameValueListEnd(HMEM_CTX_DEF
			HTTP_MSG_HDRS * pMsgHdrsStruc,
			char* pFieldName, char* pFieldValue)
{
  int Retcode, UsedSlots;
  char* pFieldNameDup  = NULL;
  char* pFieldValueDup = NULL;

  if(pMsgHdrsStruc == NULL)
    return(HTTP_NULL_PTR);

  //----------------------------------------------------------
  // Increase slotcount of arrays if needed
  //----------------------------------------------------------
  UsedSlots = pMsgHdrsStruc->UsedSlots;
  if(UsedSlots >= pMsgHdrsStruc->AllocedSlots)
  {
    if((Retcode = ExpandHttpMsgHdrsStrucArrays(HMEM_CTX_REF1
					 pMsgHdrsStruc, 4)) != 0)
      return(Retcode);
  }
  //----------------------------------------------------------
  // Allocate duplicates of the name and value
  //----------------------------------------------------------
  if(pFieldName != NULL)
  {
    if((pFieldNameDup =
	  Strdup(HMEM_CTX_REF1 pFieldName,0)) == NULL)
      return(HTTP_ALLOC_ERR);
  }
  if(pFieldValue == NULL)		// not present -> make empty string
  {
    if((pFieldValueDup = BIT8_ARRAY_ALLOC(HMEM_CTX_REF,4)) == NULL)
    {
      FREE_ARRAY(HMEM_CTX_REF,pFieldNameDup);
      return(HTTP_ALLOC_ERR);
    }
    pFieldValueDup[0] = 0;
  }
  else
  {
    if((pFieldValueDup =
          Strdup(HMEM_CTX_REF1 pFieldValue,0)) == NULL)
    {
      FREE_ARRAY(HMEM_CTX_REF,pFieldNameDup);
      return(HTTP_ALLOC_ERR);
    }
  }
  //--------------------------------------------------
  // Append the new values at the end
  //--------------------------------------------------
  pMsgHdrsStruc->pFieldNameArr[UsedSlots]  = pFieldNameDup;
  pMsgHdrsStruc->pFieldValueArr[UsedSlots] = pFieldValueDup;
  UsedSlots ++;
  pMsgHdrsStruc->UsedSlots = UsedSlots;
  return(HTTP_OP_OK);
}
/**
* Adds a Fieldname/Value pair to the header list at the beginning (AddNameValueListStart).
*
* NOTE: No check for duplicates done.
*
*  @param pMsgHdrsStruc Message header structure to be used
*  @param pFieldName Name / NULL
*  @param pFieldValue Value / Null
*  @return 0 on success, else error occured
*/
extern "C"  int AddNameValueListStart(HMEM_CTX_DEF
			HTTP_MSG_HDRS * pMsgHdrsStruc,
			char* pFieldName, char* pFieldValue)
{
  int Retcode, UsedSlots, Index;
  char* pFieldNameDup  = NULL;
  char* pFieldValueDup = NULL;

  if(pMsgHdrsStruc == NULL)
    return(HTTP_NULL_PTR);

  //----------------------------------------------------------
  // Increase slotcount of arrays if needed
  //----------------------------------------------------------
  UsedSlots = pMsgHdrsStruc->UsedSlots;
  if(UsedSlots >= pMsgHdrsStruc->AllocedSlots)
  {
    if((Retcode = ExpandHttpMsgHdrsStrucArrays(HMEM_CTX_REF1 
					pMsgHdrsStruc, 4)) != 0)
      return(Retcode);
  }
  //----------------------------------------------------------
  // Allocate duplicates of the name and value
  //----------------------------------------------------------
  if(pFieldName != NULL)
  {
    if((pFieldNameDup =
	  Strdup(HMEM_CTX_REF1 pFieldName,0)) == NULL)
      return(HTTP_ALLOC_ERR);
  }
  if(pFieldValue == NULL)		// not present -> make empty string
  {
    if((pFieldValueDup = BIT8_ARRAY_ALLOC(HMEM_CTX_REF,4)) == NULL)
    {
      FREE_ARRAY(HMEM_CTX_REF,pFieldNameDup);
      return(HTTP_ALLOC_ERR);
    }
    pFieldValueDup[0] = 0;
  }
  else
  {
    if((pFieldValueDup =
          Strdup(HMEM_CTX_REF1 pFieldValue,0)) == NULL)
    {
      FREE_ARRAY(HMEM_CTX_REF,pFieldNameDup);
      return(HTTP_ALLOC_ERR);
    }
  }
  //--------------------------------------------------
  // Move the entries up one position
  //--------------------------------------------------
  Index = UsedSlots;
  while(Index > 0)
  {
    pMsgHdrsStruc->pFieldNameArr[Index] =
      pMsgHdrsStruc->pFieldNameArr[Index-1];

    pMsgHdrsStruc->pFieldValueArr[Index] =
      pMsgHdrsStruc->pFieldValueArr[Index-1];
    Index--;
  }
  //--------------------------------------------------
  // Append the new values at the start
  //--------------------------------------------------
  pMsgHdrsStruc->pFieldNameArr[0]  = pFieldNameDup;
  pMsgHdrsStruc->pFieldValueArr[0] = pFieldValueDup;
  UsedSlots ++;
  pMsgHdrsStruc->UsedSlots = UsedSlots;
  return(HTTP_OP_OK);
}

/**
* Replaces FieldName and Value at given array index (ReplaceFieldNameValueIndex).
* If specified index is not actual in use, just appends to the end.
*
*  @param pMsgHdrsStruc Message header structure to be used
*  @param ArrayIndex Index into array, rel. 0
*  @param pFieldName Name / NULL
*  @param pFieldValue Value / Null
*  @return 0 on success, else error occured
*/
extern "C"  int ReplaceFieldNameValueIndex(HMEM_CTX_DEF
		HTTP_MSG_HDRS * pMsgHdrsStruc,
		int ArrayIndex, char* pFieldName, char* pFieldValue)
{
  char* pFieldNameDup  = NULL;
  char* pFieldValueDup = NULL;

  if(pMsgHdrsStruc == NULL)
    return(HTTP_NULL_PTR);

  if(ArrayIndex < 0)
    return(HTTP_PARAM_ERR);

  //--------------------------------------------------
  // check if the index is in use at all
  //--------------------------------------------------
  if(ArrayIndex >= pMsgHdrsStruc->UsedSlots)
  {
    //------------------------------------------------
    // cannot be in list, just append at the end
    //------------------------------------------------
    return(AddNameValueListEnd(HMEM_CTX_REF1 
		pMsgHdrsStruc,pFieldName,pFieldValue));
  }
  //----------------------------------------------------------
  // Allocate duplicates of the name and value
  //----------------------------------------------------------
  if(pFieldName != NULL)
  {
    if((pFieldNameDup =
	  Strdup(HMEM_CTX_REF1 pFieldName,0)) == NULL)
      return(HTTP_ALLOC_ERR);
  }
  if(pFieldValue == NULL)		// not present -> make empty string
  {
    if((pFieldValueDup = BIT8_ARRAY_ALLOC(HMEM_CTX_REF,4)) == NULL)
    {
      FREE_ARRAY(HMEM_CTX_REF,pFieldNameDup);
      return(HTTP_ALLOC_ERR);
    }
    pFieldValueDup[0] = 0;
  }
  else
  {
    if((pFieldValueDup =
	  Strdup(HMEM_CTX_REF1 pFieldValue,0)) == NULL)
    {
      FREE_ARRAY(HMEM_CTX_REF,pFieldNameDup);
      return(HTTP_ALLOC_ERR);
    }
  }
  //--------------------------------------------------
  // replace the new values at the index position
  //--------------------------------------------------
  FREE_ARRAY(HMEM_CTX_REF,pMsgHdrsStruc->pFieldNameArr[ArrayIndex]);
  FREE_ARRAY(HMEM_CTX_REF,pMsgHdrsStruc->pFieldValueArr[ArrayIndex]);

  pMsgHdrsStruc->pFieldNameArr[ArrayIndex]  = pFieldNameDup;
  pMsgHdrsStruc->pFieldValueArr[ArrayIndex] = pFieldValueDup;
  return(HTTP_OP_OK);
}

/**
* Replace the value for a given FieldName. If the field name
* exists, replaces the value (ReplaceFieldNameValue).
* If the field name does not exist,
* appends to the end of the array.
*
*  @param pMsgHdrsStruc Message header structure to be used
*  @param pFieldName Name / NULL
*  @param pFieldValue Value / Null
*  @return 0 on success, else error occured
*/
extern "C"  int ReplaceFieldNameValue(HMEM_CTX_DEF
			HTTP_MSG_HDRS * pMsgHdrsStruc,
			char* pFieldName, char* pFieldValue)
{
  int Index;
  char* pFieldValueDup = NULL;
  char** ppFieldNameArr;

  if(pMsgHdrsStruc == NULL)
    return(HTTP_NULL_PTR);
  //------------------------------------------------------------
  // check if a field name is given at all, if not append at end
  //------------------------------------------------------------
  if(pFieldName == NULL)
  {
    return(AddNameValueListEnd(HMEM_CTX_REF1 
			pMsgHdrsStruc,pFieldName,pFieldValue));
  }
  Index = pMsgHdrsStruc->UsedSlots -1;
  ppFieldNameArr = pMsgHdrsStruc->pFieldNameArr;

  while(Index >= 0)
  {
    if(ppFieldNameArr[Index] != NULL)
    {
      if(Stricmp(ppFieldNameArr[Index],0,pFieldName,0) == 0)
      {
        //-----------------------------------------------------
        // found position to replace      
        //-----------------------------------------------------
        if(pFieldValue == NULL)
        {
          if((pFieldValueDup = BIT8_ARRAY_ALLOC(HMEM_CTX_REF,4)) == NULL)
            return(HTTP_ALLOC_ERR);
          pFieldValueDup[0] = 0;
        }
        else
        {
          if((pFieldValueDup =
		Strdup(HMEM_CTX_REF1 pFieldValue,0)) == NULL)
            return(HTTP_ALLOC_ERR);
        }

        FREE_ARRAY(HMEM_CTX_REF,pMsgHdrsStruc->pFieldValueArr[Index]);
        pMsgHdrsStruc->pFieldValueArr[Index] = pFieldValueDup;          
        return(HTTP_OP_OK);
      }
    }
    Index--;
  }
  //----------------------------------------------------
  // Name not yet in array, append at end
  //----------------------------------------------------
  return(AddNameValueListEnd(HMEM_CTX_REF1 
			pMsgHdrsStruc,pFieldName,pFieldValue));
}

/**
* Puts the Fieldname and Fieldvalue to the headers structure, if
* there is no entry with the same Fieldname (SetFieldNameValueIfNotSet).
* If entry has to be added to the structure it is appended at
* the end.
*
*  @param pMsgHdrsStruc Message header structure to be used
*  @param pFieldName Name / NULL
*  @param pFieldValue Value / Null
*  @return 0 on success, else error occured
*/
extern "C"  int SetFieldNameValueIfNotSet(HMEM_CTX_DEF
			HTTP_MSG_HDRS * pMsgHdrsStruc,
			char* pFieldName, char* pFieldValue)
{

  if(pMsgHdrsStruc == NULL)
    return(HTTP_NULL_PTR);
  //----------------------------------------------------
  // check if a field with the given name already exists
  //----------------------------------------------------
  if(FindFieldValue(pMsgHdrsStruc, pFieldName) != NULL)
    return(HTTP_OP_OK);

  return(AddNameValueListEnd(HMEM_CTX_REF1 
			pMsgHdrsStruc,pFieldName,pFieldValue));
}

/** @} */

//==================================================================
//
// END of HEADER functions
//
//==================================================================

#if !defined XH_INTERFACE
/**
* Fetch a character from a socket with timeout, checks for special
* conditions (ReadHdrChar).
* Standard C version
*
*  @param TheSocket Socket structure
*  @return int Status/Character read
* <br>            < 0 - failed to read (Error/EOF/Timeout)
* <br>            >= 0 - Character in low byte
*/
static  int  ReadHdrChar(SOCKET TheSocket)
{
  int Len;
  char TmpBuf[1];

  if((Len = ReceiveWaitSock(TheSocket,TmpBuf,0,1,HTTP_HEADER_TIMEOUT)) > 0)
    return((int) TmpBuf[0] & 0x0FF);

  switch(Len)
  {
    case 0:			// connection closed by partner      
      return(HTTP_HDR_PARSE_CONN_CLOSED);

    case -2:			// RX timeout
      return(HTTP_HDR_PARSE_RX_TIMED_OUT);

    case -1:			// RX error occured
    default:
      return(HTTP_HDR_PARSE_RX_ERR);
  }
}

#else
/**
* Fetch a character from a socket with timeout, checks for special
* conditions (ReadHdrChar).
* XH-Interface C version
*
*  @param pXhOcspStruc
*  @return int Status/Character read
* <br>            < 0 - failed to read (Error/EOF/Timeout)
* <br>            >= 0 - Character in low byte
*/
static  int  ReadHdrChar(XH_OCSP_STRUC * pXhOcspStruc)
{
  int Len;
  char TmpBuf[1];

  if((Len = XH_OcspReceive(pXhOcspStruc,
			   TmpBuf,0,1, HTTP_HEADER_TIMEOUT)) > 0)
    return((int) TmpBuf[0] & 0x0FF);

  switch(Len)
  {
    case 0:			// connection closed by partner      
      return(HTTP_HDR_PARSE_CONN_CLOSED);

    case -2:			// RX timeout
      return(HTTP_HDR_PARSE_RX_TIMED_OUT);

    case -1:			// RX error occured
    default:
      return(HTTP_HDR_PARSE_RX_ERR);
  }
}
#endif // XH_INTERFACE

#if !defined XH_INTERFACE
/**
* Reads HTTP header from a socket, parses it into single lines,
* extracts the FieldName (if present) and the FieldValue,
* puts the components to the headers structure (ParseHeader).
*
*  @param pMsgHdrsStruc Headers struct to be used
*  @param HttpSock opened socket
*  @return 0 o.k., else error occured
*/
extern "C"  int  ParseHeader(HTTP_MSG_HDRS * pMsgHdrsStruc,
				   SOCKET HttpSock)
#else
/**
* Reads HTTP header from a socket, parses it into single lines,
* extracts the FieldName (if present) and the FieldValue,
* puts the components to the headers structure (ParseHeader).
*
*  @param pMsgHdrsStruc Headers struct to be used
*  @param HttpSock HttpSocket structure
*  @return 0 o.k., else error occured
*/
extern "C"  int  ParseHeader(HTTP_MSG_HDRS * pMsgHdrsStruc,
				   XH_OCSP_STRUC * HttpSock)
#endif
{
  int Retcode;
  int ActChar;
  int c;
  int LineCounter = 0;
  int LineLen = 0;
  int LineBufLen = 0;
  int LineEnded = 0;
//  int HeadersEnded = 0;
  int ValueStartPos;
  int InFieldName;			// parsing field name
  int FieldNameLen;
  int FieldValueLen;
  int TmpLen;

  char* pLineBuf = NULL;
  char* pNewBuf;

  char* pFieldName;
  char* pFieldValue;

  HMEM_CTX_DEF1;

#if !defined XH_INTERFACE
  if((pMsgHdrsStruc == NULL) || (HttpSock == INVALID_SOCKET))
    return(HTTP_NULL_PTR);
#else  // XH_INTERFACE
  if((pMsgHdrsStruc == NULL) || (HttpSock == NULL))
    return(HTTP_NULL_PTR);

  LOAD_HMEM_CTX_PTR(HttpSock->pMemCtxStruc);
#endif

  //---------------------------------------------------
  // Allocate temporary line buffer for parsing
  //---------------------------------------------------
  if((pLineBuf = BIT8_ARRAY_ALLOC(HMEM_CTX_REF,
			LINE_BUF_DEFAULT_LEN)) == NULL)
    return(HTTP_ALLOC_ERR);
  LineBufLen   = LINE_BUF_DEFAULT_LEN;

  //---------------------------------------------------
  // Fetch the first character from the header
  //---------------------------------------------------
  if((ActChar = ReadHdrChar(HttpSock)) < 0)	// read a character
  {
    FREE_CARRAY(HMEM_CTX_REF,pLineBuf);
    return(ActChar);
  }

  //----------------------------------------------------------
  // Collect Characters until end of line found or end
  // of header (Empty line)
  // on the fly check for end of the FieldName field
  // when past the FieldName skip all LWS until start of
  // FieldValue is found or line ends.
  //----------------------------------------------------------
  for(;;)
  {
    InFieldName = 0;			// not in FieldName field
    FieldNameLen = -1;			// none present
    LineLen = 0;

    if(ActChar > SPC_CHAR)		// is not a control nor a WSP
      InFieldName = 1;			// start with the FieldName field

    Retcode = HTTP_OP_OK;
    //----------------------------------------------------------------
    // Decide how next line starts, only LF or CRLF then end of header
    //----------------------------------------------------------------
    if(ActChar == LF_CHAR)			// end of line, is empty !!
      break;

    if(ActChar == CR_CHAR)			// should be end of line
    {
      if((c = ReadHdrChar(HttpSock)) < 0)	// read a character
        Retcode = c;
      break;
    }
    //---------------------------------------------------------------
    // Line is not empty buffer the starting character
    //---------------------------------------------------------------
    LineCounter++;
    pLineBuf[LineLen++] = (char) ActChar;	// save first one
    LineEnded = 0;

    for(;;)
    {
      //-------------------------------------------------------------
      // parse remaining characters in line till end
      //-------------------------------------------------------------
      if((c = ReadHdrChar(HttpSock)) < 0)	// read a character
      {
        Retcode = c;
        break;
      }
      switch(c)
      {
        case COLON_CHAR:		// found a ':' end of FieldName
          if(InFieldName != 0)		// we were parsing the field name
          {
            FieldNameLen = LineLen;	// save size of name field
            InFieldName = 0;
          }
          break;

        case HTAB_CHAR:			// Hor. TAB found, replace by space
          c = SPC_CHAR;
          InFieldName = 0;		// no header end found (?)
	  break;

	case SPC_CHAR:			// Space found
          if((InFieldName != 0) && (LineCounter == 1)) // Status line 
          {
            FieldNameLen = LineLen;
          }
          InFieldName = 0; 
          break;

        case LF_CHAR:			// IS end of line OR LWS (!!)
          c = SPC_CHAR;			// replace by a space char.
	  LineEnded = 1;
          for(;;)
          {
            if((ActChar = ReadHdrChar(HttpSock)) < 0)	// read next character
            {
              FREE_CARRAY(HMEM_CTX_REF,pLineBuf);
              return(ActChar);
            }
            if((ActChar == SPC_CHAR) || (ActChar == HTAB_CHAR)) // not a LWS
            {
              LineEnded = 0;		// was a LWS, NOT end of line !!
              continue;
            }
            else			// not a Space / HTAB
            {
              break;
            }
          }       
          break;

        case CR_CHAR:			// could be end of line LWS
          c = SPC_CHAR;			// replace with space
          break;
      } // Switch
      if(LineEnded == 0)		// interpret the line now
      {
        //------------------------------------------------------------
        // must buffer the character read, check available space
        //------------------------------------------------------------
        if(LineLen >= LineBufLen)
        {
          TmpLen = LineBufLen;
          LineBufLen = LineBufLen * 2;		// double size
          if((pNewBuf = BIT8_ARRAY_ALLOC(HMEM_CTX_REF,LineBufLen)) == NULL)
          {
            FREE_CARRAY(HMEM_CTX_REF,pLineBuf);
            return(HTTP_ALLOC_ERR);
          }
          memcpy(pNewBuf+0,pLineBuf+0,TmpLen);
          FREE_CARRAY(HMEM_CTX_REF,pLineBuf);
          pLineBuf = pNewBuf;
        }
        pLineBuf[LineLen++] = (char) c;
      }
      else				// End of line...
        break;
    } // Inner (Line) parse loop
    //-------------------------------------------------------------
    // Remove trailing spaces from line
    //-------------------------------------------------------------
    while(LineLen > 0)
    {
      if(pLineBuf[LineLen-1] != SPC_CHAR)
        break;
      LineLen--;
    }
    //-------------------------------------------------------------
    // Post-Process FieldName and FieldValue if present
    //-------------------------------------------------------------
    if(FieldNameLen <= 0)
    {
      pFieldName = NULL;
      ValueStartPos = 0;
    }
    else
    {
      if((pFieldName = BIT8_ARRAY_ALLOC(HMEM_CTX_REF,
				        (FieldNameLen+1))) == NULL)
      {
        FREE_CARRAY(HMEM_CTX_REF,pLineBuf);
        return(HTTP_ALLOC_ERR);
      }
      memcpy(pFieldName+0,pLineBuf+0,FieldNameLen);
      pFieldName[FieldNameLen] = 0;

      ValueStartPos = FieldNameLen;

      if(FieldNameLen < LineLen)
      {
        if(pLineBuf[FieldNameLen] == COLON_CHAR)	// skip the ':'
          ValueStartPos++;
      }

      // skip spaces til start of Value
      while(ValueStartPos < LineLen)
      {
        if(pLineBuf[ValueStartPos] != SPC_CHAR)
          break;
        ValueStartPos++;
      }
    }
    //----------------------------------------------------------
    // Get the FieldValue if present
    //----------------------------------------------------------
    if(ValueStartPos >= LineLen)
    {
      if((pFieldValue = BIT8_ARRAY_ALLOC(HMEM_CTX_REF,4)) == NULL)
      {
        FREE_ARRAY(HMEM_CTX_REF,pFieldName);
        FREE_CARRAY(HMEM_CTX_REF,pLineBuf);
        return(HTTP_ALLOC_ERR);
      }
      pFieldValue[0] = 0;
    }
    else
    {
      FieldValueLen = LineLen - ValueStartPos;
      if((pFieldValue = BIT8_ARRAY_ALLOC(HMEM_CTX_REF,
				FieldValueLen+1)) == NULL)
      {
        FREE_ARRAY(HMEM_CTX_REF,pFieldName);
        FREE_CARRAY(HMEM_CTX_REF,pLineBuf);
        return(HTTP_ALLOC_ERR);
      }
      memcpy(pFieldValue+0,pLineBuf+ValueStartPos,FieldValueLen);
      pFieldValue[FieldValueLen] = 0;
    }
    Retcode = AddNameValueListEnd(HMEM_CTX_REF1 
			pMsgHdrsStruc,pFieldName,pFieldValue);
    FREE_ARRAY(HMEM_CTX_REF,pFieldName);
    FREE_CARRAY(HMEM_CTX_REF,pFieldValue);
    if(Retcode != HTTP_OP_OK)
    {
      FREE_CARRAY(HMEM_CTX_REF,pLineBuf);
      return(Retcode);
    }
//    break;
  } // outer FOR (Lines Parser)
  FREE_CARRAY(HMEM_CTX_REF,pLineBuf);
  return(HTTP_OP_OK);
}

//()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()
//
//
//  HTTP and URL routines
//
//
//()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()

extern "C"  void  FreeUrlStruc(HMEM_CTX_DEF
				     URL_STRUC * pUrlStruc)
{
  if(pUrlStruc == NULL)
    return;

  FREE_ARRAY(HMEM_CTX_REF,pUrlStruc->pFullUrl);
  FREE_ARRAY(HMEM_CTX_REF,pUrlStruc->pProtocol);
  FREE_ARRAY(HMEM_CTX_REF,pUrlStruc->pHost);
  FREE_ARRAY(HMEM_CTX_REF,pUrlStruc->pFile);
  FREE_ARRAY(HMEM_CTX_REF,pUrlStruc->pQuery);
  FREE_ARRAY(HMEM_CTX_REF,pUrlStruc->pAuthority);
  FREE_ARRAY(HMEM_CTX_REF,pUrlStruc->pPath);
  FREE_ARRAY(HMEM_CTX_REF,pUrlStruc->pReference);
  FREE_CARRAY(HMEM_CTX_REF,pUrlStruc);
}

extern "C"  URL_STRUC *  AllocUrlStruc(HMEM_CTX_DEF1)
{
  URL_STRUC * pUrlStruc;

  if((pUrlStruc = (URL_STRUC *)
        ((void *) BIT8_ARRAY_CALLOC(HMEM_CTX_REF,
				    1,sizeof(URL_STRUC)))) == NULL)
    return(NULL);

  pUrlStruc->PortNr = -1;		// set 'Not Set' state
  return(pUrlStruc);
}

extern "C"  int  ParseUrl(HMEM_CTX_DEF
	char * pFullName, URL_STRUC ** ppUrlStruc)
{
  char c;
  int Retcode;
  int StartIndex;
  int Index,FullNameLen,NameLen,Len;
  int SubLen;

  char* pNameBuf = NULL;

  URL_STRUC * pUrlStruc = NULL;
  char Delimiters []	  = ":/?#";
  //-----------------------------------------------------
  // Check parameters
  //-----------------------------------------------------
  if((pFullName == NULL) || (ppUrlStruc == NULL))
    return(HTTP_NULL_PTR);

  ppUrlStruc[0] = NULL;
  FullNameLen = Strlen(pFullName,0);
  if(FullNameLen <= 0)
    return(HTTP_URL_PARSE_EMPTY);  
  //-----------------------------------------------------
  // Skip leading/trailing spaces and controls
  //-----------------------------------------------------
  Index = 0;
  while(Index < FullNameLen)
  {
    if(pFullName[Index] > (unsigned char) 0x20)
      break;
    Index++;
  }
  if(Index >= FullNameLen)
    return(HTTP_URL_PARSE_EMPTY);  

  StartIndex = Index;
  Index = FullNameLen - 1;
  while(Index > StartIndex)
  {  
    if(pFullName[Index] > (unsigned char) 0x20)
      break;
    Index--;
  }
  FullNameLen = Index+1;
  //-----------------------------------------------------
  // Get a copy of the full name, allocate URL structure
  //-----------------------------------------------------
  NameLen = FullNameLen - StartIndex;

  if((pNameBuf = BIT8_ARRAY_ALLOC(HMEM_CTX_REF,
				  NameLen + 1)) == NULL)
    return(HTTP_ALLOC_ERR);

  memcpy(pNameBuf+0,pFullName+StartIndex,NameLen);
  pNameBuf[NameLen] = 0;

  if((pUrlStruc = AllocUrlStruc(HMEM_CTX_REF)) == NULL)
  {
    FREE_CARRAY(HMEM_CTX_REF,pNameBuf);
    return(HTTP_ALLOC_ERR);
  }

  if((pUrlStruc->pFullUrl =
       Strdup(HMEM_CTX_REF1 pNameBuf,0)) == NULL)
  {
    FREE_CARRAY(HMEM_CTX_REF,pNameBuf);
    FreeUrlStruc(HMEM_CTX_REF1 pUrlStruc);
    return(HTTP_ALLOC_ERR);
  }

  Retcode = HTTP_ALLOC_ERR;		// assume allocation failure
  for(;;)				// Error FOR
  {
    if((pUrlStruc->pProtocol =
	  Strdup(HMEM_CTX_REF1 (char *) "http",0)) == NULL)
       break;
    pUrlStruc->PortNr = 0;
    //-----------------------------------------------------
    // 1. Get the protocol from the string:
    //    search the String until either ":/?#" found,
    //    if found, check if 'http'
    //-----------------------------------------------------
    StartIndex = 0;
    Len = Strcspn(pNameBuf,0,Delimiters,0);
    if((Len > 0) && (pNameBuf[Len] == ':'))	// a scheme could be given...
    {
      if((Len < NameLen) && (pNameBuf[Len+1] == '/'))   // *is* a scheme...
      {
        pNameBuf[Len] = 0;			// terminate
        if(Strcmp(pNameBuf,0,(char *) "http",0) != 0)
        {
          Retcode = HTTP_URL_PARSE_INVALID_PROTOCOL;
          break;
        }
        StartIndex  = Len+1;			// past scheme
        NameLen    -= Len+1;

        if((NameLen < 2) ||
           (pNameBuf[StartIndex]   != '/') ||
           (pNameBuf[StartIndex+1] != '/'))
        {
          Retcode = HTTP_URL_PARSE_NO_AUTHORITY;
          break;
        }
        StartIndex += 2;
        NameLen    -= 2;
      }
    }
    //-----------------------------------------------------
    // 2. Get the authority from the name:
    //    - must start with '//'
    //    - search past that until either "/?#" found
    //-----------------------------------------------------

    Len = Strcspn(pNameBuf,StartIndex,Delimiters,1);
    if(Len <= 0)
    {
      Retcode = HTTP_URL_PARSE_NO_AUTHORITY;
      break;
    }
    c = pNameBuf[StartIndex+Len];		// save delimiter
    pNameBuf[StartIndex+Len] = 0;		// delimit temporary
    //----------------------------------------------------------------
    // 2.1 Sub Parse authority, scan for port
    //----------------------------------------------------------------
    SubLen = Len;
    Index = Strrchr(pNameBuf,StartIndex,':');// scan from right
    if(Index >= 0)					// found
    {
      pUrlStruc->PortNr = Atoi(pNameBuf,Index+1);
      if(pUrlStruc->PortNr <= 0)
        pUrlStruc->PortNr = 0;
      SubLen = (Index - StartIndex);
      pNameBuf[Index] = 0;			// delimit
    }
    if(SubLen <= 0)
    {
      Retcode = HTTP_URL_PARSE_NO_SERVER;
      break;
    }
    if((pUrlStruc->pHost =
          Strdup(HMEM_CTX_REF1 pNameBuf,StartIndex)) == NULL)
      break;

    pNameBuf[StartIndex+Len] = c;		// restore delimiter

    NameLen    -= Len;
    StartIndex += Len;
    //------------------------------------------------------------------
    // 3. Check if file description present,
    //    - starts with '/'
    //    - ends with '?' or '#' or eos
    //------------------------------------------------------------------
    if((NameLen > 0) && (c == '/'))
    {
      Len = Strcspn(pNameBuf,StartIndex,Delimiters,2);
      if(Len > 0)
      {
        c = pNameBuf[StartIndex+Len];
        pNameBuf[StartIndex+Len] = 0;
        if((pUrlStruc->pPath =
              Strdup(HMEM_CTX_REF1 pNameBuf,StartIndex)) == NULL)
          break;

        pNameBuf[StartIndex+Len] = c;
        NameLen    -= Len;
        StartIndex += Len;
      }
      else				// none found ...?
      {
        if((pUrlStruc->pPath =
		BIT8_ARRAY_ALLOC(HMEM_CTX_REF,2)) == NULL)
          break;   
        pUrlStruc->pPath[0] = '/';
        pUrlStruc->pPath[1] = 0;
        NameLen--;
        StartIndex++;
      }
    }
    //--------------------------------------------------------
    // 4. Check if a Query component is present
    //    - starts with '?'
    //    - ends with '#' or eos
    //--------------------------------------------------------
    if((NameLen > 0) && (c == '?'))
    {
      StartIndex++;		// skip the '?'
      NameLen--;		// reduce length
      
      Len = Strcspn(pNameBuf,StartIndex,Delimiters,3);
      if(Len > 0)
      {
        c = pNameBuf[StartIndex+Len];
        pNameBuf[StartIndex+Len] = 0;
        if((pUrlStruc->pQuery =
              Strdup(HMEM_CTX_REF1 pNameBuf,StartIndex)) == NULL)
          break;

        pNameBuf[StartIndex+Len] = c;
        NameLen    -= Len;
        StartIndex += Len;
      }
      else				// singe '?' ??? 
      {
        NameLen--;
        StartIndex++;
      }
    }
    //--------------------------------------------------------
    // 4. Check if a Fragment component is present
    //    - starts with '#'
    //    - ends with eos
    //--------------------------------------------------------
    if((NameLen > 0) && (c == '#'))
    {
      StartIndex++;			// skip the '#'
      NameLen--;
      if((pUrlStruc->pReference =
            Strdup(HMEM_CTX_REF1 pNameBuf,StartIndex)) == NULL)
        break;
    }
    //--------------------------------------------------------
    // 5. Construct file portion from path and query
    //--------------------------------------------------------
    if(pUrlStruc->pPath == NULL)	// no file portion
    {
      if((pUrlStruc->pPath =
            Strdup(HMEM_CTX_REF1 (char *) "/",0)) == NULL)
        break;
    }

    FullNameLen = Strlen(pUrlStruc->pPath,0);
    NameLen     = Strlen(pUrlStruc->pQuery,0);
    FREE_CARRAY(HMEM_CTX_REF,pNameBuf);
    if((pNameBuf = BIT8_ARRAY_ALLOC(HMEM_CTX_REF,
				FullNameLen+NameLen+2)) == NULL) 
      break;

    memcpy(pNameBuf+0,pUrlStruc->pPath+0,FullNameLen);
    pNameBuf[FullNameLen] = 0;

    if(NameLen != 0)
    {
      pNameBuf[FullNameLen] = '?';
      memcpy(pNameBuf+FullNameLen+1,pUrlStruc->pQuery+0,NameLen);
      pNameBuf[FullNameLen+1+NameLen] = 0;
    }
    pUrlStruc->pFile = pNameBuf;
    pNameBuf = NULL;
    //--------------------------------------------------------
    // 6. Construct authority from host and port
    //--------------------------------------------------------
    Len = Strlen(pUrlStruc->pHost,0);
    if((pNameBuf = BIT8_ARRAY_ALLOC(HMEM_CTX_REF,
				    Len + 16)) == NULL)
      break;

    memcpy(pNameBuf+0,pUrlStruc->pHost+0,Len);
    pNameBuf[Len] = 0;
    if((pUrlStruc->PortNr != 0) && (pUrlStruc->PortNr != DEFAULT_HTTP_PORT))
    {
      pNameBuf[Len]=':';
      Len = Bit32ToAsciizStr(pUrlStruc->PortNr,0x01,pNameBuf,Len+1,16);
      if(Len <= 0)			// error occured
      {
        Retcode = HTTP_URL_PARSE_PORT_CONV_FAILED;
        break;
      }
    }
    pUrlStruc->pAuthority = pNameBuf;
  
    ppUrlStruc[0] = pUrlStruc;

//    FREE_CARRAY(HMEM_CTX_REF,pNameBuf);
    return(HTTP_OP_OK);
  } // Error for

  FREE_CARRAY(HMEM_CTX_REF,pUrlStruc);
  FREE_CARRAY(HMEM_CTX_REF,pNameBuf);
  return(Retcode);
}

extern "C"  void  FreeHttpUrlConnStruc(HMEM_CTX_DEF
			HTTP_URLCONN * pHttpUrlConnStruc)
{

  if(pHttpUrlConnStruc == NULL)
    return;
  //------------------------------------------------------
  // Free URL structure/elements
  //------------------------------------------------------
  FreeUrlStruc(HMEM_CTX_REF1 pHttpUrlConnStruc->pUrlStruc);
  FREE_CARRAY(HMEM_CTX_REF,pHttpUrlConnStruc->pHostAddress);
  FREE_CARRAY(HMEM_CTX_REF,pHttpUrlConnStruc->pResponseStatusMsg);
  FREE_CARRAY(HMEM_CTX_REF,pHttpUrlConnStruc->pRequestMethod);
  FreeHttpMsgHdrsStruc(HMEM_CTX_REF1 pHttpUrlConnStruc->pRequestHdrsStruc);
  FreeHttpMsgHdrsStruc(HMEM_CTX_REF1 pHttpUrlConnStruc->pResponseHdrsStruc);
  FREE_CARRAY(HMEM_CTX_REF,pHttpUrlConnStruc->pRequestData);

  FREE_CARRAY(HMEM_CTX_REF,pHttpUrlConnStruc);
}

extern "C"  HTTP_URLCONN *  AllocHttpUrlConnStruc(HMEM_CTX_DEF
		URL_STRUC * pUrlStruc)
{
  HTTP_MSG_HDRS * pRequestHdrsStruc  = NULL;
  HTTP_MSG_HDRS * pResponseHdrsStruc = NULL;
  HTTP_URLCONN * pHttpUrlConnStruc;
  //------------------------------------------------------
  // Alloc the structure and its subparts
  //------------------------------------------------------
  pHttpUrlConnStruc = (HTTP_URLCONN *)
    ((void *) BIT8_ARRAY_CALLOC(HMEM_CTX_REF,1,sizeof(HTTP_URLCONN)));

  pRequestHdrsStruc  = AllocHttpMsgHdrsStruc(HMEM_CTX_REF1 10);
  pResponseHdrsStruc = AllocHttpMsgHdrsStruc(HMEM_CTX_REF1 20);
 
  if((pHttpUrlConnStruc == NULL) ||
     (pRequestHdrsStruc == NULL) || (pResponseHdrsStruc == NULL))
  {
    FREE_ARRAY(HMEM_CTX_REF,pHttpUrlConnStruc);
    FreeHttpMsgHdrsStruc(HMEM_CTX_REF1 pRequestHdrsStruc);
    FreeHttpMsgHdrsStruc(HMEM_CTX_REF1 pResponseHdrsStruc);
    return(NULL);
  }  
  pHttpUrlConnStruc->ResponseStatusCode = -1;

  //------------------------------------------------------
  // Put the sub structures into the Connection structure
  //------------------------------------------------------
  pHttpUrlConnStruc->pUrlStruc = pUrlStruc;
 // pHttpUrlConnStruc->pHostAddress = pHostAddrStruc;
  pHttpUrlConnStruc->pRequestHdrsStruc = pRequestHdrsStruc;
  pHttpUrlConnStruc->pResponseHdrsStruc = pResponseHdrsStruc;
  return(pHttpUrlConnStruc);
}

extern "C"  int  NewHttpUrlStrucFromUrl(HMEM_CTX_DEF
		char * pUrlFullName,
		HTTP_URLCONN ** ppHttpUrlConnStruc)
{
  int Retcode;

  URL_STRUC * pUrlStruc;
  HTTP_URLCONN * pHttpUrlConnStruc;

  URL_STRUC * ppTmpUrlStruc[1];

  if((pUrlFullName == NULL) || (ppHttpUrlConnStruc == NULL))
    return(HTTP_NULL_PTR);

  //-----------------------------------------------------
  // Construct a URL structure from given parameters
  //-----------------------------------------------------
  Retcode = ParseUrl(HMEM_CTX_REF1 pUrlFullName, ppTmpUrlStruc);
  if(Retcode != HTTP_OP_OK)
    return(Retcode);

  pUrlStruc = ppTmpUrlStruc[0];
  //---------------------------------------------------------
  // Allocate HTTP connection structure, insert URL structure
  //---------------------------------------------------------
  if((pHttpUrlConnStruc =
        AllocHttpUrlConnStruc(HMEM_CTX_REF1 pUrlStruc)) == NULL)
  {
    FreeUrlStruc(HMEM_CTX_REF1 pUrlStruc);
    return(HTTP_ALLOC_ERR);
  }
  ppHttpUrlConnStruc[0] = pHttpUrlConnStruc;
  return(HTTP_OP_OK);
}

#if !defined XH_INTERFACE
extern "C"  int  HttpUrlConnect(HTTP_URLCONN * pHttpUrlConnStruc)
{
  int Retcode,Len,ConnectRetryCnt,MaxRetryCnt;
  int ActAdrFamily;
  int ConnectedFlag = 0;
  int DstPort;

  char* pHostName;

  SADDRIN * pActDstAdr = NULL;

  ADDRINF * pBaseAdrInfo = NULL;
  ADDRINF * pActAdrInfo;
  ADDRINF * pTmpAdrInfo[1];

  SOCKET pTmpSock[1];

  char NumHostNameBuf[NI_MAXHOST];
  char NumPortNameBuf[NI_MAXSERV];

  URL_STRUC * pUrlStruc;

  if((pHttpUrlConnStruc == NULL) ||
     ((pUrlStruc = pHttpUrlConnStruc->pUrlStruc) == NULL))
    return(HTTP_NULL_PTR);

  //-------------------------------------------------------------
  // Get default port if port has not been set.
  // Note: cannot use service mapping for WIN32, just set default
  //-------------------------------------------------------------
  if((DstPort = pUrlStruc->PortNr) == 0)
    DstPort = DEFAULT_HTTP_PORT;

  //-----------------------------------------------------------------------
  // get a list of all available addresses for the named host (i.e. server)
  //-----------------------------------------------------------------------
  if((pHostName = pUrlStruc->pHost) == NULL)
    return(HTTP_CONNECT_NO_HOST_NAME);

  if((pBaseAdrInfo = AllocAddrInfoStruct(HMEM_CTX_REF1 1)) == NULL)
    return(HTTP_ALLOC_ERR);

  Len = WordToDecimalAscii(DstPort & 0xFFFF,NumPortNameBuf,0);
  NumPortNameBuf[Len] = 0;

  pBaseAdrInfo->AdrFamily = AF_UNSPEC;
  pBaseAdrInfo->SockType  = SOCK_STREAM;

  Retcode = GetAddrInfo(HMEM_CTX_REF1 pHostName,0,NumPortNameBuf,0,pBaseAdrInfo,pTmpAdrInfo);
  FreeAddrInfoStruct(HMEM_CTX_REF1 pBaseAdrInfo);
  if(Retcode != 0)
  {
    if(Retcode == EAI_NODATA)
      return(HTTP_CONNECT_RESOLVE_DNS_FAILED);

    return(HTTP_CONNECT_GET_ADRINFO_FAILED);
  }
  pBaseAdrInfo = pTmpAdrInfo[0];		// is now reused !!!

  //----------------------------------------------------------
  // Try to connect several times.  On some machines, the first time
  // will sometimes fail.
  //----------------------------------------------------------
  MaxRetryCnt = DEFAULT_HTTP_CONNECT_RETRY_CNT;

  Retcode = HTTP_OP_OK;
  for(ConnectRetryCnt = 0;ConnectRetryCnt < MaxRetryCnt;ConnectRetryCnt++)
  {
//  if(ConnectRetryCnt > 0)
//    debug("Trying again...");
    //----------------------------------------------------------
    // Loop through addresses for this host, and try each one in
    // sequence until the connection succeeds.
    //----------------------------------------------------------
    pActAdrInfo = pBaseAdrInfo;
    for(;pActAdrInfo != NULL;pActAdrInfo= pActAdrInfo->pNext)
    {
      ActAdrFamily = pActAdrInfo->AdrFamily;
      if((ActAdrFamily != AF_INET) && (ActAdrFamily != AF_INET6))
        continue;

      pActDstAdr = pActAdrInfo->pSockAdr;

      if(GetNameInfo(HMEM_CTX_REF1 pActDstAdr,NumHostNameBuf,0,NI_MAXHOST,NumPortNameBuf,0,NI_MAXSERV,NI_NUMERICHOST | NI_NUMERICSERV) != 0)
      {
//      error("ssh_connect: getnameinfo failed");
	continue;
      }

//    debug("Connecting to %.200s [%.100s] port %s.", host, ntop, strport);

      //-------------------------------------------------------------
      // create a socket, bind to socket and connect to destination
      // NOTE: if unpriviledged requested and a bindaddress is given,
      //       the socket is also bound to the given
      //       bindaddress (i.e. the Network Adapter to use).
      //-------------------------------------------------------------
      //-----------------------------------------------------------
      // Now: Get socket, Bind local (if required) and connect
      //-----------------------------------------------------------
      if((Retcode = BindAndConnect(pActDstAdr,NULL,pTmpSock)) == HTTP_OP_OK)
      {
        ConnectedFlag = 1;
        break;
      }
    } // Addressinfo processing
    if(ConnectedFlag != 0)		// Successful connection
      break;

    SleepMillis(1000);
  } // connect retry loop
  //-----------------------------------------------------------
  // Cleanup structures in use
  //-----------------------------------------------------------
  if(ConnectedFlag == 0)
  {
    FreeAddrInfoStruct(HMEM_CTX_REF1 pBaseAdrInfo);
    return(HTTP_CONNECT_CONNECT_FAILED);
  }

//  debug("Connection established.");
  //-----------------------------------------------------------
  // Connect succeeded, save the host address for later
  //-----------------------------------------------------------
  if((pHttpUrlConnStruc->pHostAddress =
	DupAdrStruc(HMEM_CTX_REF1 pActDstAdr)) == NULL)
  {
    CloseSocket(pTmpSock[0]);
    FreeAddrInfoStruct(HMEM_CTX_REF1 pBaseAdrInfo);
    return(HTTP_ALLOC_ERR);
  }
  FreeAddrInfoStruct(HMEM_CTX_REF1 pBaseAdrInfo);// no longer needed

  //-----------------------------------------------------------
  // Save the socket to structure
  //-----------------------------------------------------------
  pHttpUrlConnStruc->HttpSocket = pTmpSock[0];
//  pHttpUrlConnStruc->Connected  = 1;  // is used for HTTP Request/Response

  return(HTTP_OP_OK);
}

#else // defined XH_INTERFACE
extern "C"  int  HttpUrlConnect(HTTP_URLCONN * pHttpUrlConnStruc)
{
  int Retcode;

  int FullUrlNameLen;
  char* pFullUrlName;

  struct dsd_hl_ocsp_d_1 XhConnStruc;
  struct dsd_hl_ocsp_d_1 * pXhConnStruc;

  XH_OCSP_STRUC * pXhOcspStruc;
  URL_STRUC * pUrlStruc;

  if((pHttpUrlConnStruc == NULL) ||
     ((pUrlStruc = pHttpUrlConnStruc->pUrlStruc) == NULL))
    return(HTTP_NULL_PTR);
  //-------------------------------------------------------------
  // Get the XH-Interface OCSP structure, check if connect
  // structure is given...
  //-------------------------------------------------------------
  if((pXhOcspStruc = pHttpUrlConnStruc->pXhOcspStruc) == NULL)
    return(HTTP_NULL_PTR);

  pXhConnStruc = pXhOcspStruc->pActOcspConnStruc;
  if(pXhConnStruc == NULL)
  {
    //-------------------------------------------------------
    // no structure given, setup own structure now
    //-------------------------------------------------------
    if((pFullUrlName = pUrlStruc->pFullUrl) == NULL)
      return(HTTP_CONNECT_NO_HOST_NAME);

    if((FullUrlNameLen = Strlen(pFullUrlName,0)) <= 0)
      return(HTTP_CONNECT_NO_HOST_NAME);

    XhConnStruc.adsc_next     = NULL;			// no next structure
    XhConnStruc.achc_url      = pFullUrlName;		// URL
    XhConnStruc.inc_url_len   = FullUrlNameLen;

    pXhOcspStruc->pActOcspConnStruc = &XhConnStruc; 
  }
  //---------------------------------------------------------
  // Connect now
  //---------------------------------------------------------
  Retcode = XH_OcspConnect(pHttpUrlConnStruc->pXhOcspStruc);
  return(Retcode);
}
#endif // XH_INTERFACE

extern "C"  int  HttpUrlSetDoInput(
	HTTP_URLCONN * pHttpUrlConnStruc, int NewState)
{
  if(pHttpUrlConnStruc == NULL)
    return(HTTP_NULL_PTR);

  if(pHttpUrlConnStruc->Connected != 0)
    return(HTTP_ALREADY_CONNECTED);

  if(NewState == 0)
    pHttpUrlConnStruc->doInput = 0;
  else
    pHttpUrlConnStruc->doInput = 1;
  return(HTTP_OP_OK);
}

extern "C"  int  HttpUrlSetDoOutput(
	HTTP_URLCONN * pHttpUrlConnStruc, int NewState)
{
  if(pHttpUrlConnStruc == NULL)
    return(HTTP_NULL_PTR);

  if(pHttpUrlConnStruc->Connected != 0)
    return(HTTP_ALREADY_CONNECTED);

  if(NewState == 0)
    pHttpUrlConnStruc->doOutput = 0;
  else
    pHttpUrlConnStruc->doOutput = 1;
  return(HTTP_OP_OK);
}

extern "C"  int  HttpUrlSetRequestMethod(
	HTTP_URLCONN * pHttpUrlConnStruc, char* pMethodName)
{
  int Index;
  int Len;
  char* pActStr;
  char* pNameBuf;

  HMEM_CTX_DEF1;

  if((pHttpUrlConnStruc == NULL) || (pMethodName == NULL))
    return(HTTP_NULL_PTR);

  if(pHttpUrlConnStruc->Connected != 0)
    return(HTTP_ALREADY_CONNECTED);
  
  if((Len = Strlen(pMethodName,0)) <= 0)
    return(HTTP_PARAM_ERR);

  LOAD_HMEM_CTX_PTR(pHttpUrlConnStruc->pXhOcspStruc->pMemCtxStruc);

  //--------------------------------------------------------
  // Allocate buffer for String, convert to all upper
  //--------------------------------------------------------
  if((pNameBuf = BIT8_ARRAY_ALLOC(HMEM_CTX_REF,
				  Len+1)) == NULL)
    return(HTTP_ALLOC_ERR);
  memcpy(pNameBuf+0,pMethodName+0,Len);
  pNameBuf[Len] = 0;
  Strupper(pNameBuf,0);
  //--------------------------------------------------------
  // Assure that method is known aka. valid
  //--------------------------------------------------------
  for(Index=0; Index < KNOWN_REQ_METHODS_CNT; Index++)
  {
    pActStr = AllowedRequestMethods[Index];
    if(Strcmp(pNameBuf,0,pActStr,0) == 0)
      break;
  }
  if(Index >= KNOWN_REQ_METHODS_CNT)
  {
    FREE_CARRAY(HMEM_CTX_REF,pNameBuf);
    return(HTTP_PARAM_ERR);
  }
  pHttpUrlConnStruc->pRequestMethod = pNameBuf;
  return(HTTP_OP_OK);
}

extern "C"  int  HttpUrlSetRequestProperty(
	HTTP_URLCONN * pHttpUrlConnStruc,
	char* pPropertyName, char* pPropertyValue)
{
  char c;
  int Index,Len,Retcode;
  HMEM_CTX_DEF1;

  if((pHttpUrlConnStruc == NULL) || (pPropertyName == NULL) ||
     (pHttpUrlConnStruc->pRequestHdrsStruc == NULL))
    return(HTTP_NULL_PTR);

  if(pHttpUrlConnStruc->Connected != 0)
    return(HTTP_ALREADY_CONNECTED);

  LOAD_HMEM_CTX_PTR(pHttpUrlConnStruc->pXhOcspStruc->pMemCtxStruc);

  //--------------------------------------------------------
  // Check format of Property Name and Value
  //--------------------------------------------------------
  if(Strchr(pPropertyName,0,'\n') >= 0)
    return(HTTP_PARAM_ERR);

  if((pPropertyValue != NULL) &&
     ((Len = Strlen(pPropertyValue,0)) > 0))
  {
    Index = 0;
    for(;;)
    {
      Index = Strchr(pPropertyValue,Index,'\n');
      if(Index < 0)			// none found
        break;
      Index++;				// found, skip LF
      if(Index >= Len)			// end of line
        return(HTTP_PARAM_ERR);
      c = pPropertyValue[Index];	// get next character
      if((c != (unsigned char) ' ') && (c != (unsigned char) '\t'))
        return(HTTP_PARAM_ERR);
    }
  }
  //--------------------------------------------------------
  // put the property to the requests 
  //--------------------------------------------------------
  Retcode = ReplaceFieldNameValue(HMEM_CTX_REF1 
				  pHttpUrlConnStruc->pRequestHdrsStruc,
				  pPropertyName, pPropertyValue);
  return(Retcode);
}

extern "C"  int  HttpUrlWriteReqData(
	HTTP_URLCONN * pHttpUrlConnStruc,
	char* pSrcBuf, int SrcOff, int SrcLen)
{
  int OldLen;
  int BufLen;
  char* pOldBuf;
  char* pDstBuf;
  HMEM_CTX_DEF1;

  if((pHttpUrlConnStruc == NULL) || (pSrcBuf == NULL))
    return(HTTP_NULL_PTR);

  if(pHttpUrlConnStruc->Connected != 0)
    return(HTTP_ALREADY_CONNECTED);

  if(SrcLen <= 0)
    return(HTTP_OP_OK);

  LOAD_HMEM_CTX_PTR(pHttpUrlConnStruc->pXhOcspStruc->pMemCtxStruc);

  pOldBuf = pHttpUrlConnStruc->pRequestData;
  OldLen  = pHttpUrlConnStruc->RequestDataLen;

  BufLen = OldLen + SrcLen;
  if((pDstBuf = BIT8_ARRAY_ALLOC(HMEM_CTX_REF,BufLen)) == NULL)
    return(HTTP_ALLOC_ERR);

  if(OldLen != 0)
  {
    memcpy(pDstBuf+0,pOldBuf+0,OldLen);
    FREE_CARRAY(HMEM_CTX_REF,pOldBuf);
  }  
  memcpy(pDstBuf+OldLen,pSrcBuf+SrcOff,SrcLen);

  pHttpUrlConnStruc->pRequestData   = pDstBuf;
  pHttpUrlConnStruc->RequestDataLen = BufLen;
  return(HTTP_OP_OK);
}

extern "C"  int  HttpUrlGetContentType(
	HTTP_URLCONN * pHttpUrlConnStruc, char** ppContentType)
{

  char* pContentType;

  if((pHttpUrlConnStruc == NULL) || (ppContentType == NULL))
    return(HTTP_NULL_PTR);

  ppContentType[0] = NULL;

  if(pHttpUrlConnStruc->Connected == 0)
    return(HTTP_NOT_CONNECTED);

  //-----------------------------------------------------------
  // Find the value for the contetnt type property in responses
  //-----------------------------------------------------------
  pContentType = FindFieldValue(pHttpUrlConnStruc->pResponseHdrsStruc,
				(char *) "content-type");

  ppContentType[0] = pContentType;

  return(HTTP_OP_OK);
}

extern "C"  int  HttpUrlGetContentLength(
	HTTP_URLCONN * pHttpUrlConnStruc, int* pContentLen)
{
  int ContentLen;
  char* pContentLenStr;

  if((pHttpUrlConnStruc == NULL) || (pContentLen == NULL))
    return(HTTP_NULL_PTR);

  pContentLen[0] = -1;

  if(pHttpUrlConnStruc->Connected == 0)
    return(HTTP_NOT_CONNECTED);

  //-----------------------------------------------------------
  // Find the value for the content length property in responses
  //-----------------------------------------------------------
  pContentLenStr = FindFieldValue(pHttpUrlConnStruc->pResponseHdrsStruc,
				  (char *) "content-length");
  if(pContentLenStr != NULL)
  {
    ContentLen = Atol(pContentLenStr,0);
    pContentLen[0] = ContentLen;
  }
  return(HTTP_OP_OK);
}
/**
* Prepares requests headers to be sent if not yet done (HttpUrlPrepReqHeaders).
*
*  @param pHttpUrlConnStruc HTTP connection
*
*  @return 0 on success, else error occured
*/
static  int  HttpUrlPrepReqHeaders(HMEM_CTX_DEF
	HTTP_URLCONN * pHttpUrlConnStruc)
{
  int Retcode, Index;
  int MethodLen, FileNameLen, VersionLen, BufLen;
  int AgentNameLen, AgentVersionLen;
  int HostNameLen;
  char* pBuf;

  char LenDataBuf[17];

  HTTP_MSG_HDRS * pRequestHdrsStruc;
  URL_STRUC * pUrlStruc;

  if(pHttpUrlConnStruc == NULL)
    return(HTTP_NULL_PTR);

  if(pHttpUrlConnStruc->RequestsSetFlag != 0)
    return(HTTP_OP_OK);
  //-------------------------------------------------------
  // Generate the Method line, put to start of request list
  //-------------------------------------------------------
  pUrlStruc         = pHttpUrlConnStruc->pUrlStruc;
  pRequestHdrsStruc = pHttpUrlConnStruc->pRequestHdrsStruc;
  if((pUrlStruc == NULL) || (pRequestHdrsStruc == NULL))
    return(HTTP_NULL_PTR);

  MethodLen   = Strlen(pHttpUrlConnStruc->pRequestMethod,0);
  FileNameLen = Strlen(pUrlStruc->pFile,0);
  VersionLen  = Strlen(HttpVersion,0);
  if((MethodLen <= 0) || (FileNameLen <= 0) || (VersionLen <= 0))
    return(HTTP_PARAM_ERR);

  BufLen = MethodLen + 1 + FileNameLen + 1 + VersionLen + 1;

  if((pBuf = BIT8_ARRAY_ALLOC(HMEM_CTX_REF,BufLen)) == NULL)
    return(HTTP_ALLOC_ERR);

  Index = 0;
  Strncpy(pBuf,0,pHttpUrlConnStruc->pRequestMethod,0,MethodLen);
  Index += MethodLen;
  pBuf[Index++] = ' ';
  Strncpy(pBuf,Index,pUrlStruc->pFile,0,FileNameLen);
  Index += FileNameLen;
  pBuf[Index++] = ' ';
  Strncpy(pBuf,Index,HttpVersion,0,VersionLen);
  Index += VersionLen;
  pBuf[Index] = 0;
  //------------------------------------------------------
  // Prepend the method name to list
  //------------------------------------------------------
  Retcode = AddNameValueListStart(HMEM_CTX_REF1 
				  pRequestHdrsStruc, pBuf, NULL);
  FREE_CARRAY(HMEM_CTX_REF,pBuf);
  if(Retcode != HTTP_OP_OK)
    return(Retcode);

  //------------------------------------------------------
  // Generate User-Agent Property, put to list
  //------------------------------------------------------
  AgentNameLen    = Strlen(AgentName,0);
  AgentVersionLen = Strlen(AgentVersion,0);
  BufLen = AgentNameLen + 1 + AgentVersionLen + 1 + 2;

  if((pBuf = BIT8_ARRAY_ALLOC(HMEM_CTX_REF,BufLen)) == NULL)
    return(HTTP_ALLOC_ERR);

  Index = 0;
  Strncpy(pBuf,0,AgentName,0,AgentNameLen+1);
  Index += AgentNameLen;
  pBuf[Index++] = '/';
  Strncpy(pBuf,Index,AgentVersion,0,AgentVersionLen+1);
  Index += AgentVersionLen;
  pBuf[Index] = 0;

  Retcode = SetFieldNameValueIfNotSet(HMEM_CTX_REF1
		 pRequestHdrsStruc, (char *) "User-Agent", pBuf);
  FREE_CARRAY(HMEM_CTX_REF,pBuf);
  if(Retcode != HTTP_OP_OK)
    return(Retcode);
  //------------------------------------------------------
  // Generate Host Property, put to list
  //------------------------------------------------------
  HostNameLen    = Strlen(pUrlStruc->pHost,0);
  if(HostNameLen <= 0)
    return(HTTP_PARAM_ERR);

  BufLen = HostNameLen+1;
  if((pUrlStruc->PortNr != 0) && (pUrlStruc->PortNr != DEFAULT_HTTP_PORT))
  {
    BufLen += 11;
  }

  if((pBuf = BIT8_ARRAY_ALLOC(HMEM_CTX_REF,BufLen)) == NULL)
    return(HTTP_ALLOC_ERR);

  Index = 0;
  memcpy(pBuf+0,pUrlStruc->pHost+0,HostNameLen);
  Index += HostNameLen;  
  pBuf[Index] = 0;

  if(BufLen != HostNameLen+1)
  {
    pBuf[Index++] = ':';
    Bit32ToAsciizStr(pUrlStruc->PortNr,0x01,pBuf,Index,BufLen-Index);
  }
  Retcode = SetFieldNameValueIfNotSet(HMEM_CTX_REF1
		pRequestHdrsStruc,(char *) "Host",pBuf);
  FREE_CARRAY(HMEM_CTX_REF,pBuf);
  if(Retcode != HTTP_OP_OK)
    return(Retcode);
  //------------------------------------------------------
  // Put Accept property to list
  //------------------------------------------------------
  Retcode = SetFieldNameValueIfNotSet(HMEM_CTX_REF1
		pRequestHdrsStruc,(char *) "Accept",DefaultAcceptValue);
  if(Retcode != HTTP_OP_OK)
    return(Retcode);
  //------------------------------------------------------
  // Set Connection property to list
  //------------------------------------------------------
  Retcode = SetFieldNameValueIfNotSet(HMEM_CTX_REF1
		pRequestHdrsStruc,(char *) "Connection",(char *) "keep-alive");
  if(Retcode != HTTP_OP_OK)
    return(Retcode);
  //-------------------------------------------------------
  // When Request data to send, set content type and length
  // NOTE: Content length should only be set if not chunked!
  //-------------------------------------------------------
  if(pHttpUrlConnStruc->RequestDataLen > 0)
  {
    Retcode = SetFieldNameValueIfNotSet(HMEM_CTX_REF1
		pRequestHdrsStruc,(char *) "Content-Type",DefaultContentValue);
    if(Retcode != HTTP_OP_OK)
      return(Retcode);
    
    Bit32ToAsciizStr(pHttpUrlConnStruc->RequestDataLen,0x01,LenDataBuf,0,17);

    Retcode = AddNameValueListEnd(HMEM_CTX_REF1
		pRequestHdrsStruc,(char *) "Content-Length", LenDataBuf);
    if(Retcode != HTTP_OP_OK)
      return(Retcode);
  }
  pHttpUrlConnStruc->RequestsSetFlag = 1;
  return(HTTP_OP_OK);
}
    
extern "C"  int  HttpUrlSendRequest(
		HTTP_URLCONN * pHttpUrlConnStruc)
{
  int Retcode, Index, DstIndex, Len;
  int ListEntries;
  int HeaderLen = 0;

  char* pHdrBuf = NULL;

  char* pActPropName;
  char* pActPropValue;

  HTTP_MSG_HDRS * pRequestHdrsStruc;

//  BIT8ARRAYI(TmpBuf,3) = {": "};
//  BIT8ARRAYI(CRLFBuf,3) = {"\r\n"};

  HMEM_CTX_DEF1;

  if(pHttpUrlConnStruc == NULL)
    return(HTTP_NULL_PTR);

  LOAD_HMEM_CTX_PTR(pHttpUrlConnStruc->pXhOcspStruc->pMemCtxStruc);

  //------------------------------------------------------------
  // Prepare the request list to be sent (if not yet...)
  //------------------------------------------------------------
  Retcode = HttpUrlPrepReqHeaders(HMEM_CTX_REF1 pHttpUrlConnStruc);
  if(Retcode != HTTP_OP_OK)
    return(Retcode);
  //------------------------------------------------------------
  // Send the data from the list (if any)
  //------------------------------------------------------------
  pRequestHdrsStruc = pHttpUrlConnStruc->pRequestHdrsStruc;

  //---------------------------------------------------------
  // Get required buffer size for the Header, allocate buffer
  //---------------------------------------------------------
  ListEntries = pRequestHdrsStruc->UsedSlots;
  Index = 0;
  while(Index < ListEntries)
  {
    pActPropName  = pRequestHdrsStruc->pFieldNameArr[Index];
    pActPropValue = pRequestHdrsStruc->pFieldValueArr[Index];
    Index++;

    if(pActPropName == NULL)		// no property, skip...
      continue;
    Len = Strlen(pActPropName,0);
    if(Len <= 0)
      continue;
    HeaderLen += Len;

    if((pActPropValue != NULL) &&
       ((Len = Strlen(pActPropValue,0)) > 0))
      HeaderLen += (2 + Len);

    HeaderLen += 2;
  }
  HeaderLen += 2;

  if((pHdrBuf = BIT8_ARRAY_ALLOC(HMEM_CTX_REF,HeaderLen)) == NULL)
    return(HTTP_ALLOC_ERR);

  //---------------------------------------------------------
  // generate the message header to send
  //---------------------------------------------------------
  Index = 0;
  DstIndex = 0;
  while(Index < ListEntries)
  {
    pActPropName  = pRequestHdrsStruc->pFieldNameArr[Index];
    pActPropValue = pRequestHdrsStruc->pFieldValueArr[Index];
    Index++;

    if(pActPropName == NULL)		// no property, skip...
      continue;
    Len = Strlen(pActPropName,0);
    if(Len <= 0)
      continue;

    memcpy(pHdrBuf+DstIndex,pActPropName+0,Len);
    DstIndex += Len;

    if((pActPropValue != NULL) &&
       ((Len = Strlen(pActPropValue,0)) > 0))
    {
      pHdrBuf[DstIndex++] = ':';
      pHdrBuf[DstIndex++] = ' ';
      memcpy(pHdrBuf+DstIndex,pActPropValue+0,Len);
      DstIndex += Len;
    }
    pHdrBuf[DstIndex++] = '\r';
    pHdrBuf[DstIndex++] = '\n';
  }
  pHdrBuf[DstIndex++] = '\r';
  pHdrBuf[DstIndex++] = '\n';
  //------------------------------------------------------
  // Send the Message header now
  //------------------------------------------------------
#if !defined XH_INTERFACE
  Retcode = SendWaitSock(pHttpUrlConnStruc->HttpSocket,pHdrBuf,0,HeaderLen,0);
#else // XH_INTERFACE
  Retcode = XH_OcspSend(pHttpUrlConnStruc->pXhOcspStruc,
			     pHdrBuf,0,HeaderLen, 0);
#endif			

  FREE_CARRAY(HMEM_CTX_REF,pHdrBuf);

  if(Retcode != HeaderLen)
    return(HTTP_SEND_REQUEST_HDR_FAILED);
  //------------------------------------------------
  // Send the Request message body if required
  //------------------------------------------------
  Len = pHttpUrlConnStruc->RequestDataLen;
  if(Len > 0)
  {
#if !defined XH_INTERFACE
    Retcode = SendWaitSock(pHttpUrlConnStruc->HttpSocket,pHttpUrlConnStruc->pRequestData,0,Len,0);
#else // XH_INTERFACE
    Retcode = XH_OcspSend(pHttpUrlConnStruc->pXhOcspStruc,
			       pHttpUrlConnStruc->pRequestData,0,Len, 0);
#endif

    if(Retcode != Len)
      return(HTTP_SEND_REQUEST_BODY_FAILED);
  }
  return(HTTP_OP_OK);
}

/**
* Extracts response status code and message (if present) for a 
* HTTP UrlConnection (GetResponseStatusAndMsg).
*
*  @param pHttpUrlConnStruc HTTP connection
*
*  @return 0 on success, else error occured
*/
extern "C"  int  GetResponseStatusAndMsg(
	HTTP_URLCONN * pHttpUrlConnStruc)
{
  int MsgIndex;
  char* pStatusLine = NULL;
  HTTP_MSG_HDRS * pResponseHdrsStruc;

  HMEM_CTX_DEF1;

  if((pHttpUrlConnStruc == NULL) ||
     ((pResponseHdrsStruc = pHttpUrlConnStruc->pResponseHdrsStruc) == NULL))
    return(HTTP_NULL_PTR);

  if(pHttpUrlConnStruc->Connected == 0)
    return(HTTP_NOT_CONNECTED);

  LOAD_HMEM_CTX_PTR(pHttpUrlConnStruc->pXhOcspStruc->pMemCtxStruc);

  //-----------------------------------------------------------
  // Get the Status line, is first entry in headers (name field)
  // is the HTTP type field, check if this starts with "HTTP/1."
  //-----------------------------------------------------------
  if((pStatusLine = GetFieldName(pResponseHdrsStruc, 0)) == NULL)
    return(HTTP_HDR_PARSE_NO_STATUS_LINE);

  if(Strncmp(pStatusLine,0,(char *) "HTTP/1.",0,7) != 0)
  {
    return(HTTP_HDR_PARSE_INV_STATUS_LINE);
  }
  //-----------------------------------------------------------
  // Extract the Status code and the status message if present
  //-----------------------------------------------------------
  if((pStatusLine = GetFieldValue(pResponseHdrsStruc, 0)) == NULL)
    return(HTTP_HDR_PARSE_NO_RESP_STATUS);

  pHttpUrlConnStruc->ResponseStatusCode =
    Atoi(pStatusLine,0);

  if(pHttpUrlConnStruc->ResponseStatusCode == -1)
  {  
    return(HTTP_HDR_PARSE_INV_STATUS_LINE);
  }
  MsgIndex = Strchr(pStatusLine,0,' ');
  if(MsgIndex >= 0)					// is present
  {
    if((pHttpUrlConnStruc->pResponseStatusMsg =
	  Strdup(HMEM_CTX_REF1 pStatusLine,MsgIndex+1)) == NULL)
      return(HTTP_ALLOC_ERR);
  }
  return(HTTP_OP_OK);
}

extern "C"  int  HttpUrlGetResponse(
		HTTP_URLCONN * pHttpUrlConnStruc)
{
  int Retcode;

  HTTP_MSG_HDRS * pResponseHdrsStruc;

  if(pHttpUrlConnStruc == NULL)
    return(HTTP_NULL_PTR);

  if(pHttpUrlConnStruc->Connected != 0)
    return(HTTP_ALREADY_CONNECTED);

  //------------------------------------------------------------
  // Receive the response headers
  //------------------------------------------------------------
  pResponseHdrsStruc = pHttpUrlConnStruc->pResponseHdrsStruc;
#if !defined XH_INTERFACE
  Retcode = ParseHeader(pResponseHdrsStruc, pHttpUrlConnStruc->HttpSocket);
#else
  Retcode = ParseHeader(pResponseHdrsStruc, pHttpUrlConnStruc->pXhOcspStruc);
#endif
  if(Retcode == HTTP_OP_OK)
  {
    pHttpUrlConnStruc->Connected = 1;
    Retcode = GetResponseStatusAndMsg(pHttpUrlConnStruc);
  }
  return(Retcode);
}

extern "C"  int  HttpUrlReadResponseData(
	HTTP_URLCONN * pHttpUrlConnStruc,
	char* pDstBuf, int DstOff, int DstBufLen, int Timeout,
	int* pBytesRead)
{
  int BytesRead;

  if((pHttpUrlConnStruc == NULL) || (pDstBuf == NULL) ||
     (pBytesRead == NULL))
    return(HTTP_NULL_PTR);

  pBytesRead[0] = -1;

  if(pHttpUrlConnStruc->Connected == 0)
    return(HTTP_NOT_CONNECTED);

  //------------------------------------------------------------
  // Check if connection was already closed
  //------------------------------------------------------------
  if(pHttpUrlConnStruc->ClosedFlag != 0)
    return(HTTP_OP_OK);

  //------------------------------------------------------------
  // Read data if available
  //------------------------------------------------------------
#if !defined XH_INTERFACE
  BytesRead = ReceiveWaitSock(pHttpUrlConnStruc->HttpSocket,pDstBuf,DstOff,DstBufLen,Timeout);
#else
  BytesRead = XH_OcspReceive(pHttpUrlConnStruc->pXhOcspStruc,
			          pDstBuf,DstOff,DstBufLen,Timeout);
#endif

  if(BytesRead > 0)
  {
    pBytesRead[0] = BytesRead;
    return(HTTP_OP_OK);
  }
  if(BytesRead == -2)	// Timeout occured
  {
    pBytesRead[0] = 0;
    return(HTTP_OP_OK);
  }
  if(BytesRead == 0)	// Closed by remote
  {
#if !defined XH_INTERFACE
    CloseSocket(pHttpUrlConnStruc->HttpSocket);
#else
    XH_OcspDisconnect(pHttpUrlConnStruc->pXhOcspStruc);
#endif
    pHttpUrlConnStruc->ClosedFlag = 1;
    pBytesRead[0] = -1;
    return(HTTP_OP_OK);
  }
  pBytesRead[0] = -2;	// Receive error
  return(HTTP_OP_OK);
}

extern "C"  int  HttpUrlDisconnect(
	HTTP_URLCONN * pHttpUrlConnStruc)
{
  if(pHttpUrlConnStruc == NULL)
    return(HTTP_NULL_PTR);

  //------------------------------------------------------------
  // Check if connection was already closed
  //------------------------------------------------------------
  if(pHttpUrlConnStruc->ClosedFlag == 0)
  {
#if !defined XH_INTERFACE
    CloseSocket(pHttpUrlConnStruc->HttpSocket);
#else
    XH_OcspDisconnect(pHttpUrlConnStruc->pXhOcspStruc);
#endif
    pHttpUrlConnStruc->ClosedFlag = 1;
  }
  return(HTTP_OP_OK);
}

//()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()
//
//
//  Routines that retrieve OCSP response for given request data
//  from a destination server/location URL
//
//
//()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()

extern "C"  int  GetUrlOcspResponse(HOCSP_CTX_DEF
		char * pUrlName,
		char* pRequestBuf, int RequestOff, int RequestLen,
		char** ppResponseBuf, int* pResponseLen)
{
  int Retcode;
//  int ResponseCode = -1;
  int ResponseLen = 0;
  int DataCnt,DataLen,TmpLen,Index;

  char* ResponseType;
  char* pResponse = NULL;
  char* ppTmpBuf[1];
  int pTmpLen[1];
  int pTmpBit32[1];

  HTTP_URLCONN * pHttpUrlConnStruc = NULL;
  HTTP_URLCONN * ppTmpHttpUrlConnStruc[1];

  HMEM_CTX_DEF1;

  if((pUrlName == NULL) || (pRequestBuf == NULL) ||
     (ppResponseBuf == NULL) || (pResponseLen == NULL))
    return(HTTP_NULL_PTR);

  if(RequestLen <= 0)
    return(HTTP_PARAM_ERR);

  LOAD_HMEM_CTX_PTR(vp__ocsp_ctx->pMemCtxStruc);

  //-----------------------------------------------------
  // Generate  HttpUrlConnection where to connect to
  //-----------------------------------------------------
  if((Retcode = NewHttpUrlStrucFromUrl(HMEM_CTX_REF1
		  pUrlName, ppTmpHttpUrlConnStruc)) != HTTP_OP_OK)
  {
//    PRINT("Could not generate HTTP Url connection object, Retcode: ");
//    PRINT_INT_NL(Retcode);
    return(Retcode);    
  }
  pHttpUrlConnStruc = ppTmpHttpUrlConnStruc[0];
#if defined XH_INTERFACE
  pHttpUrlConnStruc->pXhOcspStruc = HOCSP_CTX_REF;
#endif

  //---------------------------------------------------------
  // Prepare the GET method, set the Application type,
  // enable Input and output
  //---------------------------------------------------------
  HttpUrlSetDoInput(pHttpUrlConnStruc, 1);
  HttpUrlSetDoOutput(pHttpUrlConnStruc, 1);

  HttpUrlSetRequestProperty(pHttpUrlConnStruc,
			    (char *) "Content-Type",
                            (char *) "application/ocsp-request");
  HttpUrlSetRequestProperty(pHttpUrlConnStruc,
			    (char *) "Accept",
			    (char *) "application/ocsp-response");

  HttpUrlSetRequestProperty(pHttpUrlConnStruc,
			    (char *) "Cache-Control",
			    (char *) "no-cache");
  HttpUrlSetRequestProperty(pHttpUrlConnStruc,
			    (char *) "Pragma",
			    (char *) "no-cache");

  for(;;)	// Error FOR
  {
    if((Retcode = HttpUrlSetRequestMethod(pHttpUrlConnStruc,
			(char *) "POST")) != HTTP_OP_OK) 
    {
//    PRINT("Could not set HTTP request method \"POST\", Retcode: ");
//    PRINT_INT_NL(Retcode);
      break;
    }
    //--------------------------------------------------------
    // Write the data for the Request to POST stream
    //--------------------------------------------------------
    if((Retcode = HttpUrlWriteReqData(pHttpUrlConnStruc,
			pRequestBuf,RequestOff,RequestLen)) != HTTP_OP_OK)
    {
//    PRINT("Could not write to POST stream, Retcode: ");
//    PRINT_INT_NL(Retcode);
      break;
    }
    //------------------------------------------------------------
    // Open the connection, send request, get response
    //------------------------------------------------------------
    if((Retcode = HttpUrlConnect(pHttpUrlConnStruc)) != HTTP_OP_OK)
    {
//    PRINT("Could not connect to destination host, Retcode: ");
//    PRINT_INT_NL(Retcode);
      break;
    }

    if((Retcode = HttpUrlSendRequest(pHttpUrlConnStruc)) != HTTP_OP_OK)
    {
//    PRINT("Could not send HTTP Request, Retcode: ");
//    PRINT_INT_NL(Retcode);
      break;
    }

    if((Retcode = HttpUrlGetResponse(pHttpUrlConnStruc)) != HTTP_OP_OK)
    {
//    PRINT("Failed to retrieve HTTP server response, Retcode: ");
//    PRINT_INT_NL(Retcode);
      break;
    }
    //--------------------------------------------------------
    // Get the RESPONSE status, check if O.K.
    //--------------------------------------------------------
    if(pHttpUrlConnStruc->ResponseStatusCode != HTTP_RSTATUS_OK)
    {
      Retcode = HTTP_RESP_SERVER_ERR_STATUS;
      break;
    }
    //-----------------------------------------------------------
    // Check type of response (could be ordinary text data...)
    //-----------------------------------------------------------
    if((Retcode = HttpUrlGetContentType(pHttpUrlConnStruc,
			ppTmpBuf)) != HTTP_OP_OK)
    {
//    PRINT("Failed to retrieve response content type, Retcode: ");
//    PRINT_INT_NL(Retcode);
      break;  
    }
    ResponseType = ppTmpBuf[0];

    Strlower(ResponseType,0);	// convert to lower

    if(Strcmp(ResponseType,0,(char *) "application/ocsp-response",0) != 0)
    {
//    PRINT("Not an OCSP-Response: \n");
//    printf("%s\n",ResponseType);
      Retcode = HTTP_RESP_NOT_OCSP_TYPE;
      break;
    }
    //----------------------------------------------------------------
    // Fetch the response length
    //----------------------------------------------------------------
    if((Retcode = HttpUrlGetContentLength(pHttpUrlConnStruc,
				pTmpBit32)) != HTTP_OP_OK)
    {
//    PRINT("Failed to retrieve Content length from Response, Retcode: \n");
//    PRINT_INT_NL(Retcode);
      break;
    }

    ResponseLen = (int) pTmpBit32[0];
    if(ResponseLen < 0)
    {
//    PRINT("No Response length header message in response header!\n");
      Retcode = HTTP_RESP_NO_RESPONSE_DATA;
      break;
    }

    if(ResponseLen == 0)
    {
//    PRINT("Invalid Response length received: ");
      Retcode = HTTP_RESP_NO_RESPONSE_DATA;
      break;
    }

    if((pResponse = BIT8_ARRAY_ALLOC(HMEM_CTX_REF,ResponseLen)) == NULL)
    {
      Retcode = HTTP_ALLOC_ERR;
      break;
    }
    //------------------------------------------------------------------
    // Read until all data gathered or EOF
    //------------------------------------------------------------------
    DataCnt = ResponseLen;
    Index = 0;
    DataLen = 0;
    while(DataCnt > 0)
    {
      Retcode = HttpUrlReadResponseData(pHttpUrlConnStruc,
		  pResponse, Index, DataCnt, 10, pTmpLen);
      if(Retcode != HTTP_OP_OK)
      {
//      PRINT("Failed to read OCSP-Response, Retcode: ");
//      PRINT_INT_NL(Retcode);
        break;
      }
      TmpLen = pTmpLen[0];
      if(TmpLen < 0)			// EOF
        break;
      DataCnt -= TmpLen;
      Index   += TmpLen;
      DataLen += TmpLen;
    }
    if(Retcode != HTTP_OP_OK)
      break;

    if(DataLen < ResponseLen)
    {
//    PRINT("WARNING: Size of data received smaller than announced!");
      ResponseLen = DataLen;
    }
    HttpUrlDisconnect(pHttpUrlConnStruc);
    FreeHttpUrlConnStruc(HMEM_CTX_REF1 pHttpUrlConnStruc);

    ppResponseBuf[0] = pResponse;
    pResponseLen[0] = ResponseLen;
    return(HTTP_OP_OK);
  } // Error FOR

  FREE_CARRAY(HMEM_CTX_REF,pResponse);
  HttpUrlDisconnect(pHttpUrlConnStruc);
  FreeHttpUrlConnStruc(HMEM_CTX_REF1 pHttpUrlConnStruc);
  return(Retcode);
}

/** @} */


#endif //HL_CERT_OCSP
// end of file ../hocsp/httpurl.cpp


#ifdef HL_CERT_PKCS5
/** @defgroup pkcs5 PKCS 5
* This module implements PKCS#5 key storage operations.
*
* The PKCS#5 operations have been split into two sources, p5e.c which performs 
* PKCS#5 V1 private key encryption operations and p5d.c which does the 
* decryption operations. The private keys are formatted according to PKCS#8 V1
* specification. 
*
* For future releases PKCS#5 V2.0 (RFC2898) will be implemented (higher 
* encryption of private key using 3DES). 
*
* The PKCS#5 modules are used for storing/retrieving private keys attached to 
* certificates/certificate requests to/from certificate database files.
*
* External modules used by this module:
* <ul>
* <li> @ref md2 "MD2" hashing
* <li> @ref md5 "MD5" hashing
* <li> @ref des "DES" encryption/decryption
* <li> @ref rand "PRNG" for random salt generation
* </ul>
*
* @{
* @file
*
* This file implements the decryption routines for PKCS-5 password based 
* encryption standard used for storing PKCS-8 formatted private keys in 
* certificate containers.
* @}
*/
#include <stdlib.h>
#if (defined _WIN32) & (_MSC_VER < 1700)
#ifndef _STDINT
#define _STDINT
// MSVC lower than 17.00 does not have stdint.h, assure, all needed types are defined

typedef unsigned __int16 uint16_t;

typedef unsigned __int32 uint32_t;

typedef unsigned __int64 uint64_t;

#endif // !_STDINT
#else
#include <stdint.h>
#endif
#include <stddef.h>
#ifdef _WIN32
#define WIN32_LEAN_AND_MEAN
#include <Windows.h>
#undef WIN32_LEAN_AND_MEAN
#else// Define system-specific HL_* defines here
#ifndef HL_UNIX
#define HL_UNIX

#if (defined __gnu_linux__) || (defined __linux__)
#define HL_LINUX
#endif

#if (defined __APPLE__) && (defined __MACH__)
#define HL_LINUX
#define HL_MACOS
#endif

#ifdef _AIX
#define HL_AIX
#define HL_BIG_ENDIAN
#endif

#ifdef __FreeBSD__
#define HL_FREEBSD
#endif

#if (defined _hpux) || (defined hpux) || (defined __hpux)
#define HL_HPUX
#define HL_BIG_ENDIAN
#endif

#if (defined sun) || (defined __sun)
#define HL_SOLARIS
#endif

#if (defined __arm__) || (defined __aarch64__)
#define HL_LINUX_ARM
#endif

#ifdef __ANDROID__
#define HL_ANDROID
#endif

#endif
#include <hob-unix01.h>
#endif
#ifdef __APPLE__
/* We get target conditionals to keep apart Mac OS, iOS and iOS simulator.
   The conditionals are TARGET_IPHONE_SIMULATOR, TARGET_OS_IPHONE and TARGET_OS_MAC.
   TARGET_IPHONE_SIMULATOR has the highest priority, TARGET_OS_MAC the lowest.
   Always test, if the conditional is 1, as they will be defined as 0, if we 
   are not compiling for the target.
   */
#include <TargetConditionals.h>
#endif

#ifdef HL_ANDROID
#include <netdb.h>
#include <unistd.h>
#include <linux/in.h>
#ifndef SOCKLEN_T
#define SOCKLEN_T      int
#endif
#ifndef SA_FAMILY_T
#define SA_FAMILY_T  short
#endif
#include <sys/endian.h>
#include <asm/ioctls.h>
#include <errno.h>
#endif

#include "hob-encry-1.h"
#include "hob-cert-ext.h"
#ifdef _WIN32
#include <winsock.h>
#endif
#include "hob-cert-err.h"
#include <string.h>
#include "hob-cert-intern.h"
#include "hob-cert-err.h"

//BYTEARRAYI
unsigned char PKCS5_AlgorObjID[PKCS5_ALGOR_OBJID_LEN]={
  (unsigned char) 0x06, (unsigned char) 0x09, (unsigned char) 0x2A, (unsigned char) 0x86,	// pBE OBJECT-ID
  (unsigned char) 0x48, (unsigned char) 0x86, (unsigned char) 0xF7, (unsigned char) 0x0D,	// (PKCS5-1/3)
  (unsigned char) 0x01, (unsigned char) 0x05
};

/** @addtogroup pkcs5
* @{
*/
/*
* THE FOLLOWING SUBROUTINE IS A DUPLICATE FROM HASN1 !!
* (AND SHOULD BE MOVED TO HASN1.C LATER)
*/
/**
* Subroutine GetAsn1_DER_DataLen decodes length of ASN1 DER encoded
* length (no indefinite length, minimal byte values) length < 32 k) (GetAsn1_DER_DataLen).
*
*  @param inpBuf array base
*  @param inpOffset Start of data
*  @param inpLen length of Data
*  @param DatLen pointer to Data
*  @return int LenBytes 
* <br>         <> 0 number of length field bytes (1/2)
* <br>         == 0 error occured (length too large)
*/
static  int GetAsn1_DER_DataLen(char* inpBuf, int inpOffset,
					    int inpLen, int* DatLen)
{
  int Index=inpOffset;
  int i;

  if(inpLen ==  0) return(0);			// error !!
  i = (int) inpBuf[Index++] & 0xFF;		// get number of bytes
  if((i & 0x80) == 0)				// 1 byte only
  {
    DatLen[0] = i;
    return(1);
  }
  inpLen--;
  i &= 0x7F;					// get byte count
  if((i == 0) || (i > 2) || (i > inpLen))	// error occured
    return(0);
  DatLen[0] = (int) inpBuf[Index++] & 0xFF;
  i--;
  if(i == 0) return(2);				// 1 additional byte !
  if((DatLen[0] & 0x80) != 0) return(0);	// overflow !!

  DatLen[0] <<= 8;				// shift up 1 byte
  DatLen[0] |=  ((int) inpBuf[Index] & 0xFF);	// insert 2nd byte
  return(3);  
}

extern "C"  void GenPKCS5_DesKeyAndIV(char* Password,
			int PasswdLen, char* Salt, int SaltOff,
			char* DstBuf, int IteratCnt,
			int HashType)
{

  int mdArray[MD5_ARRAY_SIZE];
  //---------------------------------------------------
  // Generate the DES key/IV from Password and Salt
  //---------------------------------------------------
  if(HashType == pbeWithMD2AndDES_CBC)
  {
    MD2_Init(mdArray);
    MD2_Update(mdArray,Password,0,(int) PasswdLen);
    MD2_Update(mdArray,Salt,SaltOff,PKCS5_SALT_LENGTH);
    MD2_Final(mdArray,DstBuf,0);
    IteratCnt--;
    for(;IteratCnt != 0;IteratCnt--)
    {
      MD2_Init(mdArray);
      MD2_Update(mdArray,DstBuf,0,MD2_DIGEST_LEN);
      MD2_Final(mdArray,DstBuf,0);
    }            
  }
  else						// MD5
  {
    MD5_Init(mdArray);
    MD5_Update(mdArray,Password,0,(int) PasswdLen);
    MD5_Update(mdArray,Salt,SaltOff,PKCS5_SALT_LENGTH);
    MD5_Final(mdArray,DstBuf,0);
    IteratCnt--;
    for(;IteratCnt != 0;IteratCnt--)
    {
      MD5_Init(mdArray);
      MD5_Update(mdArray,DstBuf,0,MD5_DIGEST_LEN);
      MD5_Final(mdArray,DstBuf,0);
    }            
  }
}

extern "C"  int DecryptPrivateKey(HMEM_CTX_DEF
			char* KeyStruc,
			int KeyStrucOff, int KeyStrucLen,
			char* Password, int PasswdLen,
			char** pDstBuf, int* pDstLen,
			int* pIteratCnt, int* pHashType)
{
  int i,j;
  int PrivKeySeqLen;
  int AlgorSeqLen;
  int ParamSeqLen;
  int Index=KeyStrucOff;
  int HashType;
  int SaltIndex;
  int IteratCnt=0;
  int PrivKeyLen;

  char* DstBuf;

  int TmpLen[1];  

  char KeyIVBuf[16];

  int desSubkeyArray[DES_SUBKEY_ARRAY_SIZE];
  pDstBuf[0] = NULL;
  
  //-------------------------------------
  // 1. Get the total ASN.1 Sequence length
  //-------------------------------------
  if(KeyStrucLen < PKCS5_MIN_PRIV_SEQ_LEN)
    return(PKCS5_DEC_NOT_ENOUGH_ASN1_DATA);
  if(KeyStruc[Index++] != (char) 0x30)
    return(PKCS5_DEC_INVALID_ASN1_DATA);
  KeyStrucLen--;
  if((i = GetAsn1_DER_DataLen(KeyStruc, Index, KeyStrucLen,TmpLen)) == 0)
    return(PKCS5_DEC_INVALID_ASN1_DATA);
  KeyStrucLen -= i;				// reduce data count
  Index += i;					// skip length field
  PrivKeySeqLen = TmpLen[0];

  if(KeyStrucLen < PrivKeySeqLen)
    return(PKCS5_DEC_NOT_ENOUGH_ASN1_DATA);
  //---------------------------------------------
  // 2. Get the AlgorithmID ASN.1 Sequence length
  //---------------------------------------------
  if(KeyStruc[Index++] != (char) 0x30) return(PKCS5_DEC_INVALID_ASN1_DATA);
  PrivKeySeqLen--;
  if((i = GetAsn1_DER_DataLen(KeyStruc,Index,PrivKeySeqLen,TmpLen)) == 0)
    return(PKCS5_DEC_INVALID_ASN1_DATA);  

  PrivKeySeqLen -= i;			// reduce data count
  Index += i;				// skip length field	
  AlgorSeqLen = TmpLen[0];
  if(AlgorSeqLen > PrivKeySeqLen) return(PKCS5_DEC_INVALID_ASN1_DATA);
  PrivKeySeqLen -= AlgorSeqLen;		// subtract Algor-ID sequence
  //-----------------------------------------
  // 3. compare OBJ-ID for known pbe encoding
  //-----------------------------------------
  if(AlgorSeqLen < PKCS5_MIN_ALGOR_SEQ_LEN)
    return(PKCS5_DEC_INVALID_ALGOR_ID);
  i=PKCS5_ALGOR_OBJID_LEN;
  j=0;
  do
  {
    if(KeyStruc[Index++] != (char) PKCS5_AlgorObjID[j++])
      return(PKCS5_DEC_INVALID_ALGOR_ID);
    i--;
  }while(i != 0);
  HashType = (int) KeyStruc[Index++] & 0xFF;	// get pbe type
  if((HashType != pbeWithMD2AndDES_CBC) &&
     (HashType != pbeWithMD5AndDES_CBC))
      return(PKCS5_DEC_INVALID_ALGOR_ID);

  if(pHashType != NULL)				// report type of Hash
    pHashType[0] = HashType;

  AlgorSeqLen -= (PKCS5_ALGOR_OBJID_LEN+1);
  //----------------------------------------
  // 4. Get the Params ASN.1 Sequence length
  //----------------------------------------
  if(KeyStruc[Index++] != (char) 0x30) return(PKCS5_DEC_INVALID_ASN1_DATA);
  AlgorSeqLen --;
  if((i = GetAsn1_DER_DataLen(KeyStruc,Index,AlgorSeqLen,TmpLen)) == 0)
    return(PKCS5_DEC_INVALID_ASN1_DATA);  

  AlgorSeqLen -= i;			// dto.
  Index += i;				// skip length field	
  ParamSeqLen = TmpLen[0];
  if(ParamSeqLen != AlgorSeqLen) return(PKCS5_DEC_INVALID_ASN1_DATA);
  //------------------------------------------------------------------------
  // 5. Check the Salt encoding (OCTET STRING) and length, save data pointer
  //------------------------------------------------------------------------
  if(KeyStruc[Index++] != (char) 0x04) return(PKCS5_DEC_INVALID_ALGOR_PARAMS);
  if(KeyStruc[Index++] != (char) 0x08) return(PKCS5_DEC_INVALID_ALGOR_PARAMS);
  SaltIndex = Index;			// save pointer
  Index += PKCS5_SALT_LENGTH;
  ParamSeqLen -= (PKCS5_SALT_LENGTH + 2);	
  //-----------------------------------------------------------------
  // 6. Check the Iteration count encoding (INTEGER) length and value
  //-----------------------------------------------------------------
  if(KeyStruc[Index++] != (char) 0x02) return(PKCS5_DEC_INVALID_ALGOR_PARAMS);
  ParamSeqLen--;
  if((i = GetAsn1_DER_DataLen(KeyStruc,Index,ParamSeqLen,TmpLen)) == 0)
    return(PKCS5_DEC_INVALID_ASN1_DATA);  
  Index += i;				// skip length
  ParamSeqLen -= i;

  j = TmpLen[0];
  if(ParamSeqLen != j) return(PKCS5_DEC_INVALID_ASN1_DATA);
  if((j > 2) || (j == 0)) return(PKCS5_DEC_INVALID_ALGOR_PARAMS);
  IteratCnt = KeyStruc[Index++];
  if(j == 2)
  {
    IteratCnt <<= 8;
    IteratCnt |= (int) KeyStruc[Index++] & 0xFF;
  }
  if(IteratCnt <= 0) return(PKCS5_DEC_INVALID_ALGOR_PARAMS);
  if(pIteratCnt != NULL)			// set Iteration count
    pIteratCnt[0] = IteratCnt;
  //------------------------------------------------------
  // 7. Check Encrypted key data encoding (OCTET STRING) length
  //------------------------------------------------------
  if(KeyStruc[Index++] != (char) 0x04) return(PKCS5_DEC_INVALID_ASN1_DATA);
  PrivKeySeqLen--;
  if((i = GetAsn1_DER_DataLen(KeyStruc,Index,PrivKeySeqLen,TmpLen)) == 0)
    return(PKCS5_DEC_INVALID_ASN1_DATA);  
  Index += i;				// skip length
  PrivKeySeqLen -= i;

  PrivKeyLen = TmpLen[0];
  if(PrivKeyLen != PrivKeySeqLen) return(PKCS5_DEC_INVALID_ASN1_DATA);
  if((PrivKeyLen & 0x07) != 0) return(PKCS5_DEC_INVALID_ALGOR_PARAMS);
  //------------------------------------------------------
  // 8. Allocate Destination Buffer
  //------------------------------------------------------
  DstBuf = (char *)
    BIT8_ARRAY_ALLOC(HMEM_CTX_REF,PrivKeyLen);
  if(DstBuf == NULL) return(PKCS5_DEC_DST_BUF_ALLOC_ERR);
  //---------------------------------------------------
  // Generate the DES key/IV from Password and Salt
  //---------------------------------------------------
  GenPKCS5_DesKeyAndIV(Password,PasswdLen,KeyStruc,SaltIndex,
		       KeyIVBuf,IteratCnt,HashType);
  //---------------------------------------------------
  // Generate the DES subkeys
  //---------------------------------------------------
  GenDESSubKeys((unsigned char *) KeyIVBuf,
		(unsigned int *) desSubkeyArray);
  //---------------------------------------------------
  // Do DES CBC decrypt the data
  //---------------------------------------------------
  DES_cbc_encrypt_decrypt((unsigned char *) (KeyStruc+Index),
			  (unsigned char *) DstBuf,
			  (unsigned int *) desSubkeyArray,
                          (PrivKeyLen >> 3),
			  (unsigned char *) (KeyIVBuf+8),
			  DES_DECRYPT);
  //---------------------------------------------------
  // Check Padding data, strip off padding data
  //---------------------------------------------------
  Index = PrivKeyLen - 1;			// Offset to last byte 
  j = (int) DstBuf[Index] & 0xFF;		// get last byte
  if((j == 0) || (j > 8))
  {
    FREE_CARRAY(HMEM_CTX_REF,DstBuf);
    return(PKCS5_DEC_INVALID_PADDING_SIZE);
  }
  PrivKeyLen -= j;				// reduce size (remove padding)
  i = j;					// save value
  do
  {
    if(DstBuf[Index--] != (char) j)
    {
      FREE_CARRAY(HMEM_CTX_REF,DstBuf);
      return(PKCS5_DEC_INVALID_PADDING_DATA);
    }
    i--;
  }while(i != 0);      
  //---------------------------------------------------
  // Set pure datalengt
  //---------------------------------------------------
  pDstLen[0] = PrivKeyLen;
  pDstBuf[0] = DstBuf;
  return(PKCS5_OP_OK);
}



/**
 *  Reads the length field during ASN.1 decoding from the source buffer.
 *
 *  @param[inout]   aaucp_src_buf       IN: Source buffer pointer before reading.<br>
 *                                      OUT: Source buffer pointer after reading.
 *  @param[inout]   aszp_src_len        IN: Length of source buffer.<br>
 *                                      OUT: Length of source buffer after reading.
 *  @param[out]     aszp_value_len      Length of the value
 *  @param[out]     aszp_bytes_read     Number of bytes read
 *
 *  @return         <code>PKCS5_OP_OK</code> on success, error code otherwise
 */
static int ms_get_asn1_der_lenfield(unsigned char** aaucp_src_buf,
                                    size_t* aszp_src_len,
                                    size_t* aszp_value_len,
                                    size_t* aszp_bytes_read) {
    // Check input parameters
    // ----------------------
    
    // Check source length
    if (*aszp_src_len <= 0) { // no data
        return PKCS5_DEC_NOT_ENOUGH_ASN1_DATA;
    }
    
    // Create output working variables
    unsigned char* aucl_src_buf = *aaucp_src_buf;
    size_t szl_src_len = *aszp_src_len;
    size_t szl_value_len = 0;
    size_t szl_bytes_read = 0;
    
    // Decode length
    if (*aucl_src_buf < 0x80) {
        // Short form used
        szl_value_len = *aucl_src_buf;
        ++aucl_src_buf;
        --szl_src_len;
        ++szl_bytes_read;
    }
    else {
        // Long form used
        size_t szl_len_octets = *aucl_src_buf & 0x7F;
        ++aucl_src_buf;
        --szl_src_len;
        ++szl_bytes_read;
        
        if (szl_len_octets > szl_src_len) { // not enough data
            return PKCS5_DEC_NOT_ENOUGH_ASN1_DATA;
        }
        
        while (szl_len_octets > 0) {
            szl_value_len <<= 8;
            szl_value_len |= *aucl_src_buf;
            ++aucl_src_buf;
            --szl_src_len;
            --szl_len_octets;
            ++szl_bytes_read;
        }
    }
    
    // Set output
    *aaucp_src_buf = aucl_src_buf;
    *aszp_src_len = szl_src_len;
    *aszp_value_len = szl_value_len;
    *aszp_bytes_read = szl_bytes_read;
    
    return PKCS5_OP_OK;
}  // end of int ms_get_asn1_der_lenfield(...)



/**
 *  Subroutine ms_decode_tag_and_length reads an ASN.1 tag and
 *  an ASN.1 DER encoded length from the source buffer. Checks if the read tag is the passed
 *  tag and if the source buffer length is sufficient.
 *
 *  @param[inout]   aaucp_src_buf       IN: Source buffer pointer before reading.<br>
 *                                      OUT: Source buffer pointer after reading.
 *  @param[inout]   aszp_src_len        IN: Length of source buffer.<br>
 *                                      OUT: Length of source buffer after reading.
 *  @param[in]      aucp_tag            Expected tag of the ASN.1 TLV
 *  @param[out]     aszp_value_len      Length of the ASN.1 TLV
 *  @param[out]     aszp_bytes_read     Number of bytes read
 *
 *  @return         <code>PKCS5_OP_OK</code> on success, error code otherwise.
 */
static int ms_decode_tag_and_length(unsigned char** aaucp_src_buf,
                                    size_t* aszp_src_len,
                                    const unsigned char ucp_expected_tag,
                                    size_t* aszp_value_len,
                                    size_t* aszp_bytes_read) {
    // Check input parameters
    // ----------------------
    
    // Check source length
    if (*aszp_src_len <= 0) { // no data
        return PKCS5_DEC_NOT_ENOUGH_ASN1_DATA;
    }
    
    // Create output working variables
    unsigned char* aucl_src_buf = *aaucp_src_buf;
    size_t szl_src_len = *aszp_src_len;
    size_t szl_value_len;
    size_t szl_bytes_read_total = 0;
    size_t szl_bytes_read;
    
    // Decode tag
    unsigned char ucl_tag = *aucl_src_buf;
    if (ucl_tag != ucp_expected_tag) {  // false tag
        return PKCS5_DEC_INVALID_ASN1_DATA;
    }
    ++aucl_src_buf;
    --szl_src_len;
    ++szl_bytes_read_total;
    
    // Decode length
    int iml_retval = ms_get_asn1_der_lenfield(&aucl_src_buf,
                                              &szl_src_len,
                                              &szl_value_len,
                                              &szl_bytes_read);
    if (iml_retval != PKCS5_OP_OK) {
        return iml_retval;
    }
    else if (szl_value_len > szl_src_len) { // not enough data
        return PKCS5_DEC_NOT_ENOUGH_ASN1_DATA;
    }
    szl_bytes_read_total += szl_bytes_read;
    
    // Set output
    *aaucp_src_buf = aucl_src_buf;
    *aszp_src_len = szl_src_len;
    *aszp_value_len = szl_value_len;
    *aszp_bytes_read = szl_bytes_read_total;
    
    return PKCS5_OP_OK;
}  // end of int ms_decode_tag_and_length(...)



/**
 *  Decodes the value field in DER encoding from the source buffer.
 *
 *  @param[inout]   aaucp_src_buf       IN: Source buffer pointer before reading.<br>
 *                                      OUT: Source buffer pointer after reading.
 *  @param[inout]   aszp_src_len        IN: Length of source buffer.<br>
 *                                      OUT: Length of source buffer after reading.
 *  @param[in]      szp_int_val_len     Length of integer value.
 *  @param[out]     aimp_int_val        Integer value.
 *  @param[out]     aszp_bytes_read     Number of bytes read
 *
 *  @return         <code>PKCS5_OP_OK</code> on success, error code otherwise.
 */
static int ms_get_integer(unsigned char** aaucp_src_buf,
                          size_t* aszp_src_len,
                          size_t szp_int_val_len,
                          int* aimp_int_val,
                          size_t* aszp_bytes_read) {
    // Check input parameters
    // ----------------------
    
    // Check source length
    if (szp_int_val_len > *aszp_src_len) { // not enough data
        return PKCS5_DEC_NOT_ENOUGH_ASN1_DATA;
    }
    
    // Create output working variables
    unsigned char* aucl_src_buf = *aaucp_src_buf;
    size_t szl_src_len = *aszp_src_len;
    int iml_int_val = 0;
    size_t szl_bytes_read = 0;
    
    // Decode integer
    if (*aucl_src_buf >= 128) {
        // Negative integer
        // Add leading 0xFF to the integer
        for (size_t szl_ii = szp_int_val_len, szl_max = sizeof(int); szl_ii < szl_max; ++szl_ii) {
            iml_int_val <<= 8;
            iml_int_val |= 0xFF;
        }
    }
    while (szp_int_val_len > 0) {
        iml_int_val <<= 8;
        iml_int_val |= *aucl_src_buf;
        ++aucl_src_buf;
        --szl_src_len;
        --szp_int_val_len;
        ++szl_bytes_read;
    }
    
    // Set output
    *aaucp_src_buf = aucl_src_buf;
    *aszp_src_len = szl_src_len;
    *aimp_int_val = iml_int_val;
    *aszp_bytes_read = szl_bytes_read;
    
    return PKCS5_OP_OK;
}  // end of int ms_get_integer(...)



/**
 *  Decodes an integer in DER encoding from the source buffer.
 *  The decoding includes tag and length field.
 *
 *  @param[inout]   aaucp_src_buf       IN: Source buffer pointer before reading.<br>
 *                                      OUT: Source buffer pointer after reading.
 *  @param[inout]   aszp_src_len        IN: Length of source buffer.<br>
 *                                      OUT: Length of source buffer after reading.
 *  @param[out]     ainp_int_val        Integer value to be encoded.
 *  @param[out]     aszp_bytes_read     Number of bytes read
 *
 *  @return         <code>PKCS5_OP_OK</code> on success, error code otherwise.
 */
static int ms_decode_int(unsigned char** aaucp_src_buf,
                         size_t* aszp_src_len,
                         int* aimp_int_val,
                         size_t* aszp_bytes_read) {
    // Check input parameters
    // ----------------------
    
    // Check source length
    if (*aszp_src_len <= 0) { // no data
        return PKCS5_DEC_NOT_ENOUGH_ASN1_DATA;
    }
    
    // Create output working variables
    unsigned char* aucl_src_buf = *aaucp_src_buf;
    size_t szl_src_len = *aszp_src_len;
    int iml_int_val;
    size_t szl_bytes_read_total = 0;
    size_t szl_bytes_read;
    
    // Decode tag and length
    size_t szl_value_len;
    int iml_retval = ms_decode_tag_and_length(&aucl_src_buf,
                                              &szl_src_len,
                                              0x02,
                                              &szl_value_len,
                                              &szl_bytes_read);
    if (iml_retval != PKCS5_OP_OK) {
        return iml_retval;
    }
    szl_bytes_read_total += szl_bytes_read;
    
    // Decode value
    iml_retval = ms_get_integer(&aucl_src_buf,
                                &szl_src_len,
                                szl_value_len,
                                &iml_int_val,
                                &szl_bytes_read);
    if (iml_retval != PKCS5_OP_OK) {
        return iml_retval;
    }
    szl_bytes_read_total += szl_bytes_read;
    
    // Set output
    *aaucp_src_buf = aucl_src_buf;
    *aszp_src_len = szl_src_len;
    *aimp_int_val = iml_int_val;
    *aszp_bytes_read = szl_bytes_read_total;
    
    return PKCS5_OP_OK;
}  // end of int ms_decode_int(...)



/**
 *  Decodes an OCTET STRING in DER encoding from the source buffer.
 *  The decoding includes tag and length field.
 *  <p><b>Attention:</b> After successful execution the dereferenced pointer of
 *  <code>aaucp_octet_data</code> is an in-place pointer pointing to a part
 *  of the dereferenced pointer passed <code>aaucp_src_buf</code> pointer before execution.</p>
 *
 *  @param[inout]   aaucp_src_buf       IN: Source buffer pointer before reading.<br>
 *                                      OUT: Source buffer pointer after reading.
 *  @param[inout]   aszp_src_len        IN: Length of source buffer.<br>
 *                                      OUT: Length of source buffer after reading.
 *  @param[out]     aaucp_octet_data    Pointer to the OCTET STRING in the source buffer.
 *  @param[out]     aszp_octet_data_len Length of octet_data
 *  @param[out]     aszp_bytes_read     Number of bytes read
 *
 *  @return         <code>PKCS5_OP_OK</code> on success, error code otherwise.
 */
static int ms_decode_octet_string(unsigned char** aaucp_src_buf,
                                  size_t* aszp_src_len,
                                  unsigned char** aaucp_octet_data,
                                  size_t* aszp_octet_data_len,
                                  size_t* aszp_bytes_read) {
    // Check input parameters
    // ----------------------
    
    // Check source length
    if (*aszp_src_len <= 0) { // no data
        return PKCS5_DEC_NOT_ENOUGH_ASN1_DATA;
    }
    
    // Create output working variables
    unsigned char* aucl_src_buf = *aaucp_src_buf;
    size_t szl_src_len = *aszp_src_len;
    unsigned char* aucl_octet_data;
    size_t szl_octet_data_len;
    size_t szl_bytes_read;
    
    // Decode tag and length
    size_t szl_value_len;
    int iml_retval = ms_decode_tag_and_length(&aucl_src_buf,
                                              &szl_src_len,
                                              0x04,
                                              &szl_value_len,
                                              &szl_bytes_read);
    if (iml_retval != PKCS5_OP_OK) {
        return iml_retval;
    }
    
    // Decode value
    aucl_octet_data = aucl_src_buf;
    szl_octet_data_len = szl_value_len;
    aucl_src_buf += szl_value_len;
    szl_src_len -= szl_value_len;
    szl_bytes_read += szl_value_len;
    
    // Set output
    *aaucp_src_buf = aucl_src_buf;
    *aszp_src_len = szl_src_len;
    *aaucp_octet_data = aucl_octet_data;
    *aszp_octet_data_len = szl_octet_data_len;
    *aszp_bytes_read = szl_bytes_read;
    
    return PKCS5_OP_OK;
}  // end of int ms_decode_octet_string(...)



/**
 *  Subroutine ms_decode_object_identifier reads an object identifier array
 *  from the source buffer.
 *  <p><b>Attention:</b> After successful execution the dereferenced pointer of
 *  <code>aaucp_oid</code> is an in-place pointer pointing to a part
 *  of the dereferenced pointer passed <code>aaucp_src_buf</code> pointer before execution.</p>
 *
 *  @param[inout]   aaucp_src_buf       IN: Source buffer pointer before reading.<br>
 *                                      OUT: Source buffer pointer after reading.
 *  @param[inout]   aszp_src_len        IN: Length of source buffer.<br>
 *                                      OUT: Length of source buffer after reading.
 *  @param[out]     aaucp_oid           Pointer to the object identifier in the source buffer.
 *  @param[out]     aszp_oid_len        Length of the OID
 *  @param[out]     aszp_bytes_read     Number of bytes read
 *
 *  @return         <code>PKCS5_OP_OK</code> on success, error code otherwise.
 */
static int ms_decode_object_identifier(unsigned char** aaucp_src_buf,
                                       size_t* aszp_src_len,
                                       unsigned char** aaucp_oid,
                                       size_t* aszp_oid_len,
                                       size_t* aszp_bytes_read) {
    // Check input parameters
    // ----------------------
    
    // Check source length
    if (*aszp_src_len <= 0) { // no data
        return PKCS5_DEC_NOT_ENOUGH_ASN1_DATA;
    }
    
    // Create output working variables
    unsigned char* aucl_src_buf = *aaucp_src_buf;
    size_t szl_src_len = *aszp_src_len;
    unsigned char* aucl_oid;
    size_t szl_oid_len;
    size_t szl_bytes_read;
    
    // Decode tag and length
    size_t szl_value_len;
    int iml_retval = ms_decode_tag_and_length(&aucl_src_buf,
                                              &szl_src_len,
                                              0x06,
                                              &szl_value_len,
                                              &szl_bytes_read);
    if (iml_retval != PKCS5_OP_OK) {
        return iml_retval;
    }
    
    // Decode value
    aucl_oid = aucl_src_buf;
    szl_oid_len = szl_value_len;
    aucl_src_buf += szl_value_len;
    szl_src_len -= szl_value_len;
    szl_bytes_read += szl_value_len;
    
    // Set output
    *aaucp_src_buf = aucl_src_buf;
    *aszp_src_len = szl_src_len;
    *aaucp_oid = aucl_oid;
    *aszp_oid_len = szl_oid_len;
    *aszp_bytes_read = szl_bytes_read;
    
    return PKCS5_OP_OK;
}  // end of int ms_decode_object_identifier(...)



/**
 *  Decodes the AlgorithIdentifier of the HMAC in DER encoding from the source buffer.
 *  The decoding includes tag and length field.
 *
 *  @note Currently, AlgorithmIdentifiers for MD5 and RIPEMD160 are not implemented.
 *
 *  @param[inout]   aaucp_src_buf       IN: Source buffer pointer before reading.<br>
 *                                      OUT: Source buffer pointer after reading.
 *  @param[inout]   aszp_src_len        IN: Length of source buffer.<br>
 *                                      OUT: Length of source buffer after reading.
 *  @param[out]     aiep_hmac_type      Enum defining which HMAC type was used after decoding.
 *  @param[out]     aszp_bytes_read     Number of bytes read
 *
 *  @return         <code>PKCS5_OP_OK</code> on success, error code otherwise.
 */
static int ms_decode_hmac_alg_id(unsigned char** aaucp_src_buf,
                                 size_t* aszp_src_len,
                                 ie_hmac_types* aiep_hmac_type,
                                 size_t* aszp_bytes_read) {
    // Check input parameters
    // ----------------------
    
    // Check source length
    if (*aszp_src_len <= 0) { // no data
        return PKCS5_DEC_NOT_ENOUGH_ASN1_DATA;
    }
    
    // Create output working variables
    int iml_hmac_type = -1;
    size_t szl_hmac_alg_id_len;
    
    // Compare the source buffer with the hmac_alg_id arrays
    // Check HMAC_SHA1_ID
    szl_hmac_alg_id_len = szg_hmac_sha1_alg_id_len;
    if (*aszp_src_len >= szl_hmac_alg_id_len &&
        memcmp(*aaucp_src_buf, byrg_hmac_sha1_alg_id, szl_hmac_alg_id_len) == 0) {
        
        iml_hmac_type = HMAC_SHA1_ID;
    }
    else {
        // Check HMAC_SHA256_ID
        szl_hmac_alg_id_len = szg_hmac_sha256_alg_id_len;
        if (*aszp_src_len >= szl_hmac_alg_id_len &&
            memcmp(*aaucp_src_buf, byrg_hmac_sha256_alg_id, szl_hmac_alg_id_len) == 0) {
            
            iml_hmac_type = HMAC_SHA256_ID;
        }
        else {
            // Check HMAC_SHA384_ID
            szl_hmac_alg_id_len = szg_hmac_sha384_alg_id_len;
            if (*aszp_src_len >= szl_hmac_alg_id_len &&
                memcmp(*aaucp_src_buf, byrg_hmac_sha384_alg_id, szl_hmac_alg_id_len) == 0) {
                
                iml_hmac_type = HMAC_SHA384_ID;
            }
            else {
                // Check HMAC_SHA512_ID
                szl_hmac_alg_id_len = szg_hmac_sha512_alg_id_len;
                if (*aszp_src_len >= szl_hmac_alg_id_len &&
                    memcmp(*aaucp_src_buf, byrg_hmac_sha512_alg_id, szl_hmac_alg_id_len) == 0) {
                    
                    iml_hmac_type = HMAC_SHA512_ID;
                }
            }
        }
    }
    
    if (iml_hmac_type < 0) {
        return PKCS5_DEC_INVALID_ALGOR_ID; // no matching alg_id
    }
    
    // Set output
    *aaucp_src_buf += szl_hmac_alg_id_len;
    *aszp_src_len -= szl_hmac_alg_id_len;
    *aiep_hmac_type = (ie_hmac_types)iml_hmac_type;
    *aszp_bytes_read = szl_hmac_alg_id_len;
    
    return PKCS5_OP_OK;
    
}  // end of int ms_decode_hmac_alg_id(...)



/**
 *  Subroutine ms_decode_pbkdf2_params decodes the whole PBKDF2 parameters for
 *  PKCS#5-based password-based key generation from the source buffer.
 *
 *  @param[inout]   aaucp_src_buf       IN: Source buffer pointer before reading.<br>
 *                                      OUT: Source buffer pointer after reading.
 *  @param[inout]   aszp_src_len        IN: Length of source buffer.<br>
 *                                      OUT: Length of source buffer after reading.
 *  @param[out]     adsp_pbkdf2_output  This pointer to a dsd_stru_pkcs5_pbes_params structure
 *                                      defines all the output elements, such as output data array,
 *                                      iteration count, salt value and algorithms.
 *  @param[out]     aszp_bytes_read     Number of bytes read
 *
 *  @return         <code>PKCS5_OP_OK</code> on success, error code otherwise.
 */
static int ms_decode_pbkdf2_params(unsigned char** aaucp_src_buf,
                                   size_t* aszp_src_len,
                                   dsd_stru_pkcs5_pbes_params* adsp_pbkdf2_output,
                                   size_t* aszp_bytes_read) {
    // Check input parameters
    // ----------------------
    
    // Check source length
    if (*aszp_src_len <= 0) { // no data
        return PKCS5_DEC_NOT_ENOUGH_ASN1_DATA;
    }
    
    // Create output working variables
    unsigned char* aucl_src_buf = *aaucp_src_buf;
    size_t szl_src_len = *aszp_src_len;
    dsd_stru_pkcs5_pbes_params dsl_pbkdf2_output = *adsp_pbkdf2_output;
    size_t szl_bytes_read_total = 0;
    size_t szl_bytes_read;
    
    // Decode tag and length of the pbkdf2_params SEQUENCE
    size_t szl_sequence_len;
    int iml_retval = ms_decode_tag_and_length(&aucl_src_buf,
                                              &szl_src_len,
                                              0x30,
                                              &szl_sequence_len,
                                              &szl_bytes_read);
    if (iml_retval != PKCS5_OP_OK) {
        return iml_retval;
    }
    szl_bytes_read_total += szl_bytes_read;
    
    size_t szl_sequence_parts_len_sum = 0;
    // Decode salt
    iml_retval = ms_decode_octet_string(&aucl_src_buf,
                                        &szl_src_len,
                                        (unsigned char**)&(dsl_pbkdf2_output.achc_salt_buf),
                                        &(dsl_pbkdf2_output.szc_salt_buf_size),
                                        &szl_bytes_read);
    if (iml_retval != PKCS5_OP_OK) {
        return iml_retval;
    }
    szl_sequence_parts_len_sum += szl_bytes_read;
    szl_bytes_read_total += szl_bytes_read;
    
    // Decode iteration count
    iml_retval = ms_decode_int(&aucl_src_buf,
                               &szl_src_len,
                               (int*)&(dsl_pbkdf2_output.unc_iteration_count),
                               &szl_bytes_read);
    if (iml_retval != PKCS5_OP_OK) {
        return iml_retval;
    }
    szl_sequence_parts_len_sum += szl_bytes_read;
    szl_bytes_read_total += szl_bytes_read;
    
    // Decode key length
    iml_retval = ms_decode_int(&aucl_src_buf,
                               &szl_src_len,
                               &(dsl_pbkdf2_output.inc_encr_aes_size),
                               &szl_bytes_read);
    if (iml_retval != PKCS5_OP_OK) {
        return iml_retval;
    }
    szl_sequence_parts_len_sum += szl_bytes_read;
    szl_bytes_read_total += szl_bytes_read;
    
    // Decode hmac type
    iml_retval = ms_decode_hmac_alg_id(&aucl_src_buf,
                                       &szl_src_len,
                                       &(dsl_pbkdf2_output.iec_enc_hash_type),
                                       &szl_bytes_read);
    if (iml_retval != PKCS5_OP_OK) {
        return iml_retval;
    }
    szl_sequence_parts_len_sum += szl_bytes_read;
    szl_bytes_read_total += szl_bytes_read;
    
    if (szl_sequence_parts_len_sum != szl_sequence_len) { // sequence length not same as sequence values length sum
        return PKCS5_DEC_INVALID_ASN1_DATA;
    }
    
    // Set output
    *aaucp_src_buf = aucl_src_buf;
    *aszp_src_len = szl_src_len;
    *adsp_pbkdf2_output = dsl_pbkdf2_output;
    *aszp_bytes_read = szl_bytes_read_total;
    
    return PKCS5_OP_OK;
}  // end of int ms_decode_pbkdf2_params(...)



/**
 *  Subroutine ms_decode_pbkdf2_sequ decodes the whole PBKDF2 sequence for
 *  PKCS#5-based password-based key generation.
 *
 *
 *  @param[inout]   aaucp_src_buf       IN: Source buffer pointer before reading.<br>
 *                                      OUT: Source buffer pointer after reading.
 *  @param[inout]   aszp_src_len        IN: Length of source buffer.<br>
 *                                      OUT: Length of source buffer after reading.
 *  @param[out]     adsp_pbkdf2_output  This pointer to a dsd_stru_pkcs5_pbes_params structure
 *                                      defines all the output elements, such as output data array,
 *                                      iteration count, salt value and algorithms.
 *  @param[out]     aszp_bytes_read     Number of bytes read
 *
 *  @return         <code>PKCS5_OP_OK</code> on success, error code otherwise.
 */
static int ms_decode_pbkdf2_sequ(unsigned char** aaucp_src_buf,
                                 size_t* aszp_src_len,
                                 dsd_stru_pkcs5_pbes_params* adsp_pbkdf2_output,
                                 size_t* aszp_bytes_read) {
    // Check input parameters
    // ----------------------
    
    // Check source length
    if (*aszp_src_len <= 0) { // no data
        return PKCS5_DEC_NOT_ENOUGH_ASN1_DATA;
    }
    
    // Create output working variables
    unsigned char* aucl_src_buf = *aaucp_src_buf;
    size_t szl_src_len = *aszp_src_len;
    dsd_stru_pkcs5_pbes_params dsl_pbkdf2_output = *adsp_pbkdf2_output;
    size_t szl_bytes_read_total = 0;
    size_t szl_bytes_read;
    
    // Decode tag and length of the pbkdf2 SEQUENCE
    size_t szl_sequence_len;
    int iml_retval = ms_decode_tag_and_length(&aucl_src_buf,
                                              &szl_src_len,
                                              0x30,
                                              &szl_sequence_len,
                                              &szl_bytes_read);
    if (iml_retval != PKCS5_OP_OK) {
        return iml_retval;
    }
    szl_bytes_read_total += szl_bytes_read;
    
    size_t szl_sequence_parts_len_sum = 0;
    // Decode pbkdf2_oid
    unsigned char* aucl_oid;
    size_t szl_oid_len;
    // Save a pointer to the TLV of the pbkdf2_oid
    unsigned char* aucl_oid_tlv = aucl_src_buf;
    iml_retval = ms_decode_object_identifier(&aucl_src_buf,
                                             &szl_src_len,
                                             &aucl_oid,
                                             &szl_oid_len,
                                             &szl_bytes_read);
    if (iml_retval != PKCS5_OP_OK) {
        return iml_retval;
    }
    // Get a pointer to the TLV of the expected pbkdf2_oid
    const unsigned char* aucl_oid_exp_tlv = byrg_pbkdf2_oid;
    size_t szl_oid_exp_tlv_len = szg_pbkdf2_oid_len;
    // Check if source pbkdf2_oid equals the expected pbkdf2_oid
    size_t szl_oid_tlv_len = aucl_src_buf - aucl_oid_tlv;
    if (szl_oid_tlv_len != szl_oid_exp_tlv_len) {
        return PKCS5_DEC_INVALID_ASN1_DATA;
    }
    else if (memcmp(aucl_oid_tlv, aucl_oid_exp_tlv, szl_oid_tlv_len) != 0) {
        return PKCS5_DEC_INVALID_ASN1_DATA;
    }
    szl_sequence_parts_len_sum += szl_bytes_read;
    szl_bytes_read_total += szl_bytes_read;
    
    // Decode pbkdf2_params
    iml_retval = ms_decode_pbkdf2_params(&aucl_src_buf,
                                         &szl_src_len,
                                         &dsl_pbkdf2_output,
                                         &szl_bytes_read);
    if (iml_retval != PKCS5_OP_OK) {
        return iml_retval;
    }
    szl_sequence_parts_len_sum += szl_bytes_read;
    szl_bytes_read_total += szl_bytes_read;
    
    if (szl_sequence_parts_len_sum != szl_sequence_len) { // sequence length not same as sequence values length sum
        return PKCS5_DEC_INVALID_ASN1_DATA;
    }
    
    // Set output
    *aaucp_src_buf = aucl_src_buf;
    *aszp_src_len = szl_src_len;
    *adsp_pbkdf2_output = dsl_pbkdf2_output;
    *aszp_bytes_read = szl_bytes_read_total;
    
    return PKCS5_OP_OK;
}  // end of int ms_decode_pbkdf2_sequ(...)



/**
 *  Subroutine ms_decode_pbmac1_params decodes the whole PBMAC1 parameters for
 *  PKCS#5-based password-based HMAC creation.
 *
 *  @param[inout]   aaucp_src_buf       IN: Source buffer pointer before reading.<br>
 *                                      OUT: Source buffer pointer after reading.
 *  @param[inout]   aszp_src_len        IN: Length of source buffer.<br>
 *                                      OUT: Length of source buffer after reading.
 *  @param[out]     adsp_pbmac1_output  This pointer to a dsd_stru_pkcs5_pbes_params structure
 *                                      defines all the output elements, such as output data array,
 *                                      iteration count, salt value and algorithms.
 *  @param[out]     aszp_bytes_read     Number of bytes read
 *
 *  @return         <code>PKCS5_OP_OK</code> on success, error code otherwise.
 */
static int ms_decode_pbmac1_params(unsigned char** aaucp_src_buf,
                                   size_t* aszp_src_len,
                                   dsd_stru_pkcs5_pbes_params* adsp_pbmac1_output,
                                   size_t* aszp_bytes_read) {
    // Check input parameters
    // ----------------------
    
    // Check source length
    if (*aszp_src_len <= 0) { // no data
        return PKCS5_DEC_NOT_ENOUGH_ASN1_DATA;
    }
    
    // Create output working variables
    unsigned char* aucl_src_buf = *aaucp_src_buf;
    size_t szl_src_len = *aszp_src_len;
    dsd_stru_pkcs5_pbes_params dsl_pbmac1_output = *adsp_pbmac1_output;
    size_t szl_bytes_read_total = 0;
    size_t szl_bytes_read;
    
    // Decode tag and length of the pbmac1_params SEQUENCE
    size_t szl_sequence_len;
    int iml_retval = ms_decode_tag_and_length(&aucl_src_buf,
                                              &szl_src_len,
                                              0x30,
                                              &szl_sequence_len,
                                              &szl_bytes_read);
    if (iml_retval != PKCS5_OP_OK) {
        return iml_retval;
    }
    szl_bytes_read_total += szl_bytes_read;
    
    size_t szl_sequence_parts_len_sum = 0;
    // Decode pbkdf2
    iml_retval = ms_decode_pbkdf2_sequ(&aucl_src_buf,
                                       &szl_src_len,
                                       &dsl_pbmac1_output,
                                       &szl_bytes_read);
    if (iml_retval != PKCS5_OP_OK) {
        return iml_retval;
    }
    szl_sequence_parts_len_sum += szl_bytes_read;
    szl_bytes_read_total += szl_bytes_read;
    
    // Decode hmac type
    iml_retval = ms_decode_hmac_alg_id(&aucl_src_buf,
                                       &szl_src_len,
                                       &(dsl_pbmac1_output.iec_enc_hash_type),
                                       &szl_bytes_read);
    if (iml_retval != PKCS5_OP_OK) {
        return iml_retval;
    }
    szl_sequence_parts_len_sum += szl_bytes_read;
    szl_bytes_read_total += szl_bytes_read;
    
    
    if (szl_sequence_parts_len_sum != szl_sequence_len) { // sequence length not same as sequence values length sum
        return PKCS5_DEC_INVALID_ASN1_DATA;
    }
    
    // Set output
    *aaucp_src_buf = aucl_src_buf;
    *aszp_src_len = szl_src_len;
    *adsp_pbmac1_output = dsl_pbmac1_output;
    *aszp_bytes_read = szl_bytes_read_total;
    
    return PKCS5_OP_OK;
}  // end of int ms_decode_pbmac1_params(...)



/**
 *  Subroutine ms_decode_pbmac1_sequ decodes the whole PBMAC1 sequence
 *  for PKCS#5-based password-based HMAC creation.
 *
 *  @param[inout]   aaucp_src_buf       IN: Source buffer pointer before reading.<br>
 *                                      OUT: Source buffer pointer after reading.
 *  @param[inout]   aszp_src_len        IN: Length of source buffer.<br>
 *                                      OUT: Length of source buffer after reading.
 *  @param[out]     adsp_pbmac1_output  This pointer to a dsd_stru_pkcs5_pbes_params structure
 *                                      defines all the output elements, such as output data array,
 *                                      iteration count, salt value and algorithms.
 *  @param[out]     aszp_bytes_read     Number of bytes read
 *
 *  @return         <code>PKCS5_OP_OK</code> on success, error code otherwise.
 */
static int ms_decode_pbmac1_sequ(unsigned char** aaucp_src_buf,
                                 size_t* aszp_src_len,
                                 dsd_stru_pkcs5_pbes_params* adsp_pbmac1_output,
                                 size_t* aszp_bytes_read) {
    // Check input parameters
    // ----------------------
    
    // Check source length
    if (*aszp_src_len <= 0) { // no data
        return PKCS5_DEC_NOT_ENOUGH_ASN1_DATA;
    }
    
    // Create output working variables
    unsigned char* aucl_src_buf = *aaucp_src_buf;
    size_t szl_src_len = *aszp_src_len;
    dsd_stru_pkcs5_pbes_params dsl_pbmac1_output = *adsp_pbmac1_output;
    size_t szl_bytes_read_total = 0;
    size_t szl_bytes_read;
    
    // Decode tag and length of the pbmac1 SEQUENCE
    size_t szl_sequence_len;
    int iml_retval = ms_decode_tag_and_length(&aucl_src_buf,
                                              &szl_src_len,
                                              0x30,
                                              &szl_sequence_len,
                                              &szl_bytes_read);
    if (iml_retval != PKCS5_OP_OK) {
        return iml_retval;
    }
    szl_bytes_read_total += szl_bytes_read;
    
    size_t szl_sequence_parts_len_sum = 0;
    // Decode pbmac1_oid
    unsigned char* aucl_oid;
    size_t szl_oid_len;
    // Save a pointer to the TLV of the pbmac1_oid
    unsigned char* aucl_oid_tlv = aucl_src_buf;
    iml_retval = ms_decode_object_identifier(&aucl_src_buf,
                                             &szl_src_len,
                                             &aucl_oid,
                                             &szl_oid_len,
                                             &szl_bytes_read);
    if (iml_retval != PKCS5_OP_OK) {
        return iml_retval;
    }
    // Get a pointer to the TLV of the expected pbmac1_oid
    const unsigned char* aucl_oid_exp_tlv = byrg_pbmac1_oid;
    size_t szl_oid_exp_tlv_len = szg_pbmac1_oid_len;
    // Check if source pbmac1_oid equals the expected pbmac1_oid
    size_t szl_oid_tlv_len = aucl_src_buf - aucl_oid_tlv;
    if (szl_oid_tlv_len != szl_oid_exp_tlv_len) {
        return PKCS5_DEC_INVALID_ASN1_DATA;
    }
    else if (memcmp(aucl_oid_tlv, aucl_oid_exp_tlv, szl_oid_tlv_len) != 0) {
        return PKCS5_DEC_INVALID_ASN1_DATA;
    }
    szl_sequence_parts_len_sum += szl_bytes_read;
    szl_bytes_read_total += szl_bytes_read;
    
    // Decode pbmac1_params
    iml_retval = ms_decode_pbmac1_params(&aucl_src_buf,
                                         &szl_src_len,
                                         &dsl_pbmac1_output,
                                         &szl_bytes_read);
    if (iml_retval != PKCS5_OP_OK) {
        return iml_retval;
    }
    szl_sequence_parts_len_sum += szl_bytes_read;
    szl_bytes_read_total += szl_bytes_read;
    
    if (szl_sequence_parts_len_sum != szl_sequence_len) { // sequence length not same as sequence values length sum
        return PKCS5_DEC_INVALID_ASN1_DATA;
    }
    
    // Set output
    *aaucp_src_buf = aucl_src_buf;
    *aszp_src_len = szl_src_len;
    *adsp_pbmac1_output = dsl_pbmac1_output;
    *aszp_bytes_read = szl_bytes_read_total;
    
    return PKCS5_OP_OK;
}  // end of int ms_decode_pbmac1_sequ(...)



/**
 *  Subroutine ms_decode_pbmac1_header reads the whole PBMAC1 package
 *  for PKCS#5-based password-based HMAC creation.
 *  <p><b>Attention:</b> After successful execution the dereferenced pointer of
 *  <code>aaucp_mac_data</code> is an in-place pointer pointing to a part
 *  of the dereferenced pointer passed <code>aaucp_src_buf</code> pointer before execution.</p>
 *
 *  @param[inout]   aaucp_src_buf       IN: Source buffer pointer before reading.<br>
 *                                      OUT: Source buffer pointer after reading.
 *  @param[inout]   aszp_src_len        IN: Length of source buffer.<br>
 *                                      OUT: Length of source buffer after reading.
 *  @param[out]     adsp_pbmac1_output  This pointer to a dsd_stru_pkcs5_pbes_params structure
 *                                      defines all the output elements, such as output data array,
 *                                      iteration count, salt value and algorithms.
 *  @param[out]     aaucp_mac_data      Buffer containing the MAC data after decoding
 *  @param[out]     aszp_mac_data_len   Length of the mac_data buffer
 *  @param[out]     aszp_bytes_read     Number of bytes read
 *
 *  @return         <code>PKCS5_OP_OK</code> on success, error code otherwise.
 */
static int ms_decode_pbmac1_header(unsigned char** aaucp_src_buf,
                                   size_t* aszp_src_len,
                                   dsd_stru_pkcs5_pbes_params* adsp_pbmac1_output,
                                   unsigned char** aaucp_mac_data,
                                   size_t* aszp_mac_data_len,
                                   size_t* aszp_bytes_read) {
    // Check input parameters
    // ----------------------
    
    // Check source length
    if (*aszp_src_len <= 0) { // no data
        return PKCS5_DEC_NOT_ENOUGH_ASN1_DATA;
    }
    
    // Create output working variables
    unsigned char* aucl_src_buf = *aaucp_src_buf;
    size_t szl_src_len = *aszp_src_len;
    dsd_stru_pkcs5_pbes_params dsl_pbmac1_output = *adsp_pbmac1_output;
    unsigned char* aucl_mac_data;
    size_t szl_mac_data_len;
    size_t szl_bytes_read_total = 0;
    size_t szl_bytes_read;
    
    // Decode tag and length of the pbmac1_mac_data SEQUENCE
    size_t szl_sequence_len;
    int iml_retval = ms_decode_tag_and_length(&aucl_src_buf,
                                              &szl_src_len,
                                              0x30,
                                              &szl_sequence_len,
                                              &szl_bytes_read);
    if (iml_retval != PKCS5_OP_OK) {
        return iml_retval;
    }
    szl_bytes_read_total += szl_bytes_read;
    
    size_t szl_sequence_parts_len_sum = 0;
    // Decode pbmac1 SEQUENCE
    iml_retval = ms_decode_pbmac1_sequ(&aucl_src_buf,
                                       &szl_src_len,
                                       &dsl_pbmac1_output,
                                       &szl_bytes_read);
    if (iml_retval != PKCS5_OP_OK) {
        return iml_retval;
    }
    szl_sequence_parts_len_sum += szl_bytes_read;
    szl_bytes_read_total += szl_bytes_read;
    
    // Decode mac_data
    iml_retval = ms_decode_octet_string(&aucl_src_buf,
                                        &szl_src_len,
                                        &aucl_mac_data,
                                        &szl_mac_data_len,
                                        &szl_bytes_read);
    if (iml_retval != PKCS5_OP_OK) {
        return iml_retval;
    }
    szl_sequence_parts_len_sum += szl_bytes_read;
    szl_bytes_read_total += szl_bytes_read;
    
    if (szl_sequence_parts_len_sum != szl_sequence_len) { // sequence length not same as sequence values length sum
        return PKCS5_DEC_INVALID_ASN1_DATA;
    }
    
    // Set output
    *aaucp_src_buf = aucl_src_buf;
    *aszp_src_len = szl_src_len;
    *adsp_pbmac1_output = dsl_pbmac1_output;
    *aaucp_mac_data = aucl_mac_data;
    *aszp_mac_data_len = szl_mac_data_len;
    *aszp_bytes_read = szl_bytes_read_total;
    
    return PKCS5_OP_OK;
}  // end of int ms_decode_pbmac1_header(...)



/**
 *  Subroutine ms_decode_aes_sequ reads the whole PBES2 AES sequence
 *  for PKCS#5-based password-based AES-encrypted data.
 *  <p><b>Attention:</b> After successful execution the dereferenced pointer of
 *  <code>aachp_iv</code> is an in-place pointer pointing to a part
 *  of the dereferenced pointer passed <code>aaucp_src_buf</code> pointer before execution.</p>
 *
 *  @param[inout]   aaucp_src_buf       IN: Source buffer pointer before reading.<br>
 *                                      OUT: Source buffer pointer after reading.
 *  @param[inout]   aszp_src_len        IN: Length of source buffer.<br>
 *                                      OUT: Length of source buffer after reading.
 *  @param[in]      imp_encr_aes_size   Length of the aes key
 *  @param[out]     aachp_iv            Buffer containing the IV after decoding
 *  @param[out]     aszp_iv_len         Length of the iv buffer
 *  @param[out]     aszp_bytes_read     Number of bytes read
 *
 *  @return         <code>PKCS5_OP_OK</code> on success, error code otherwise.
 */
static int ms_decode_aes_sequ(unsigned char** aaucp_src_buf,
                              size_t* aszp_src_len,
                              int imp_encr_aes_size,
                              char** aachp_iv,
                              size_t* aszp_iv_len,
                              size_t* aszp_bytes_read) {
    // Check input parameters
    // ----------------------
    
    // Check source length
    if (*aszp_src_len <= 0) { // no data
        return PKCS5_DEC_NOT_ENOUGH_ASN1_DATA;
    }
    
    // Create output working variables
    unsigned char* aucl_src_buf = *aaucp_src_buf;
    size_t szl_src_len = *aszp_src_len;
    char* achl_iv;
    size_t szl_iv_len;
    size_t szl_bytes_read_total = 0;
    size_t szl_bytes_read;
    
    // Decode tag and length of the aes SEQUENCE
    size_t szl_sequence_len;
    int iml_retval = ms_decode_tag_and_length(&aucl_src_buf,
                                              &szl_src_len,
                                              0x30,
                                              &szl_sequence_len,
                                              &szl_bytes_read);
    if (iml_retval != PKCS5_OP_OK) {
        return iml_retval;
    }
    szl_bytes_read_total += szl_bytes_read;
    
    size_t szl_sequence_parts_len_sum = 0;
    // Decode aes_oid
    unsigned char* aucl_oid;
    size_t szl_oid_len;
    // Save a pointer to the TLV of the aes_oid
    unsigned char* aucl_oid_tlv = aucl_src_buf;
    iml_retval = ms_decode_object_identifier(&aucl_src_buf,
                                             &szl_src_len,
                                             &aucl_oid,
                                             &szl_oid_len,
                                             &szl_bytes_read);
    if (iml_retval != PKCS5_OP_OK) {
        return iml_retval;
    }
    // Get a pointer to the TLV of the expected aes_oid
    const unsigned char* aucl_oid_exp_tlv;
    size_t szl_oid_exp_tlv_len;
    switch (imp_encr_aes_size) {
        case 16:
            aucl_oid_exp_tlv = byrg_aes128_cbc_oid;
            szl_oid_exp_tlv_len = szg_aes128_cbc_oid_len;
            break;
        case 24:
            aucl_oid_exp_tlv = byrg_aes192_cbc_oid;
            szl_oid_exp_tlv_len = szg_aes192_cbc_oid_len;
            break;
        case 32:
            aucl_oid_exp_tlv = byrg_aes256_cbc_oid;
            szl_oid_exp_tlv_len = szg_aes256_cbc_oid_len;
            break;
        default:
            return PKCS5_DEC_INVALID_ASN1_DATA;
    }
    // Check if source aes_oid equals the expected aes_oid
    size_t szl_oid_tlv_len = aucl_src_buf - aucl_oid_tlv;
    if (szl_oid_tlv_len != szl_oid_exp_tlv_len) {
        return PKCS5_DEC_INVALID_ASN1_DATA;
    }
    else if (memcmp(aucl_oid_tlv, aucl_oid_exp_tlv, szl_oid_tlv_len) != 0) {
        return PKCS5_DEC_INVALID_ASN1_DATA;
    }
    szl_sequence_parts_len_sum += szl_bytes_read;
    szl_bytes_read_total += szl_bytes_read;
    
    // Decode aes_iv
    iml_retval = ms_decode_octet_string(&aucl_src_buf,
                                        &szl_src_len,
                                        (unsigned char**)&achl_iv,
                                        &szl_iv_len,
                                        &szl_bytes_read);
    if (iml_retval != PKCS5_OP_OK) {
        return iml_retval;
    }
    szl_sequence_parts_len_sum += szl_bytes_read;
    szl_bytes_read_total += szl_bytes_read;
    
    
    if (szl_sequence_parts_len_sum != szl_sequence_len) { // sequence length not same as sequence values length sum
        return PKCS5_DEC_INVALID_ASN1_DATA;
    }
    
    // Set output
    *aaucp_src_buf = aucl_src_buf;
    *aszp_src_len = szl_src_len;
    *aachp_iv = achl_iv;
    *aszp_iv_len = szl_iv_len;
    *aszp_bytes_read = szl_bytes_read_total;
    
    return PKCS5_OP_OK;
}  // end of int ms_decode_aes_sequ(...)



/**
 *  Subroutine ms_decode_pbes2_params reads the whole PBES2 parameters for PKCS#5-based
 *  password-based AES-encrypted data.
 *
 *  @param[inout]   aaucp_src_buf       IN: Source buffer pointer before reading.<br>
 *                                      OUT: Source buffer pointer after reading.
 *  @param[inout]   aszp_src_len        IN: Length of source buffer.<br>
 *                                      OUT: Length of source buffer after reading.
 *  @param[out]     adsp_pbes2_output   This pointer to a dsd_stru_pkcs5_pbes_params structure
 *                                      defines all the output elements, such as output data array,
 *                                      iteration count, salt value and algorithms.
 *  @param[out]     aszp_bytes_read     Number of bytes read
 
 *  @return         <code>PKCS5_OP_OK</code> on success, error code otherwise.
 */
static int ms_decode_pbes2_params(unsigned char** aaucp_src_buf,
                                  size_t* aszp_src_len,
                                  dsd_stru_pkcs5_pbes_params* adsp_pbes2_output,
                                  size_t* aszp_bytes_read) {
    // Check input parameters
    // ----------------------
    
    // Check source length
    if (*aszp_src_len <= 0) { // no data
        return PKCS5_DEC_NOT_ENOUGH_ASN1_DATA;
    }
    
    // Create output working variables
    unsigned char* aucl_src_buf = *aaucp_src_buf;
    size_t szl_src_len = *aszp_src_len;
    dsd_stru_pkcs5_pbes_params dsl_pbes2_output = *adsp_pbes2_output;
    size_t szl_bytes_read_total = 0;
    size_t szl_bytes_read;
    
    // Decode tag and length of the pbes2_params SEQUENCE
    size_t szl_sequence_len;
    int iml_retval = ms_decode_tag_and_length(&aucl_src_buf,
                                              &szl_src_len,
                                              0x30,
                                              &szl_sequence_len,
                                              &szl_bytes_read);
    if (iml_retval != PKCS5_OP_OK) {
        return iml_retval;
    }
    szl_bytes_read_total += szl_bytes_read;
    
    size_t szl_sequence_parts_len_sum = 0;
    // Decode pbkdf2
    iml_retval = ms_decode_pbkdf2_sequ(&aucl_src_buf,
                                       &szl_src_len,
                                       &dsl_pbes2_output,
                                       &szl_bytes_read);
    if (iml_retval != PKCS5_OP_OK) {
        return iml_retval;
    }
    szl_sequence_parts_len_sum += szl_bytes_read;
    szl_bytes_read_total += szl_bytes_read;
    
    // Decode aes
    iml_retval = ms_decode_aes_sequ(&aucl_src_buf,
                                    &szl_src_len,
                                    dsl_pbes2_output.inc_encr_aes_size,
                                    &(dsl_pbes2_output.achc_initializ_vector_buf),
                                    &(dsl_pbes2_output.szc_initializ_vector_size),
                                    &szl_bytes_read);
    if (iml_retval != PKCS5_OP_OK) {
        return iml_retval;
    }
    szl_sequence_parts_len_sum += szl_bytes_read;
    szl_bytes_read_total += szl_bytes_read;
    
    if (szl_sequence_parts_len_sum != szl_sequence_len) { // sequence length not same as sequence values length sum
        return PKCS5_DEC_INVALID_ASN1_DATA;
    }
    
    // Set output
    *aaucp_src_buf = aucl_src_buf;
    *aszp_src_len = szl_src_len;
    *adsp_pbes2_output = dsl_pbes2_output;
    *aszp_bytes_read = szl_bytes_read_total;
    
    return PKCS5_OP_OK;
}  // end of int ms_decode_pbes2_params(...)



/**
 *  Subroutine ms_decode_pbes2_sequ reads the whole PBES2 sequence
 *  for PKCS#5-based password-based AES-encrypted data.
 *
 *  @param[inout]   aaucp_src_buf       IN: Source buffer pointer before reading.<br>
 *                                      OUT: Source buffer pointer after reading.
 *  @param[inout]   aszp_src_len        IN: Length of source buffer.<br>
 *                                      OUT: Length of source buffer after reading.
 *  @param[out]     adsp_pbes2_output   This pointer to a dsd_stru_pkcs5_pbes_params structure
 *                                      defines all the output elements, such as output data array,
 *                                      iteration count, salt value and algorithms.
 *  @param[out]     aszp_bytes_read     Number of bytes read
 
 *  @return         <code>PKCS5_OP_OK</code> on success, error code otherwise.
 */
static int ms_decode_pbes2_sequ(unsigned char** aaucp_src_buf,
                                size_t* aszp_src_len,
                                dsd_stru_pkcs5_pbes_params* adsp_pbes2_output,
                                size_t* aszp_bytes_read) {
    // Check input parameters
    // ----------------------
    
    // Check source length
    if (*aszp_src_len <= 0) { // no data
        return PKCS5_DEC_NOT_ENOUGH_ASN1_DATA;
    }
    
    // Create output working variables
    unsigned char* aucl_src_buf = *aaucp_src_buf;
    size_t szl_src_len = *aszp_src_len;
    dsd_stru_pkcs5_pbes_params dsl_pbes2_output = *adsp_pbes2_output;
    size_t szl_bytes_read_total = 0;
    size_t szl_bytes_read;
    
    // Decode tag and length of the pbes2 SEQUENCE
    size_t szl_sequence_len;
    int iml_retval = ms_decode_tag_and_length(&aucl_src_buf,
                                              &szl_src_len,
                                              0x30, 
                                              &szl_sequence_len,
                                              &szl_bytes_read);
    if (iml_retval != PKCS5_OP_OK) {
        return iml_retval;
    }
    szl_bytes_read_total += szl_bytes_read;
    
    size_t szl_sequence_parts_len_sum = 0;
    // Decode pbes2_oid
    unsigned char* aucl_oid;
    size_t szl_oid_len;
    // Save a pointer to the TLV of the pbes2_oid
    unsigned char* aucl_oid_tlv = aucl_src_buf;
    iml_retval = ms_decode_object_identifier(&aucl_src_buf,
                                             &szl_src_len,
                                             &aucl_oid,
                                             &szl_oid_len,
                                             &szl_bytes_read);
    if (iml_retval != PKCS5_OP_OK) {
        return iml_retval;
    }
    // Get a pointer to the TLV of the expected pbes2_oid
    const unsigned char* aucl_oid_exp_tlv = byrg_pbes2_oid;
    size_t szl_oid_exp_tlv_len = szg_pbes2_oid_len;
    // Check if source pbes2_oid equals the expected pbes2_oid
    size_t szl_oid_tlv_len = aucl_src_buf - aucl_oid_tlv;
    if (szl_oid_tlv_len != szl_oid_exp_tlv_len) {
        return PKCS5_DEC_INVALID_ASN1_DATA;
    }
    else if (memcmp(aucl_oid_tlv, aucl_oid_exp_tlv, szl_oid_tlv_len) != 0) {
        return PKCS5_DEC_INVALID_ASN1_DATA;
    }
    szl_sequence_parts_len_sum += szl_bytes_read;
    szl_bytes_read_total += szl_bytes_read;
    
    // Decode pbes2_params
    iml_retval = ms_decode_pbes2_params(&aucl_src_buf,
                                        &szl_src_len,
                                        &dsl_pbes2_output,
                                        &szl_bytes_read);
    if (iml_retval != PKCS5_OP_OK) {
        return iml_retval;
    }
    szl_sequence_parts_len_sum += szl_bytes_read;
    szl_bytes_read_total += szl_bytes_read;
    
    if (szl_sequence_parts_len_sum != szl_sequence_len) { // sequence length not same as sequence values length sum
        return PKCS5_DEC_INVALID_ASN1_DATA;
    }
    
    // Set output
    *aaucp_src_buf = aucl_src_buf;
    *aszp_src_len = szl_src_len;
    *adsp_pbes2_output = dsl_pbes2_output;
    *aszp_bytes_read = szl_bytes_read_total;
    
    return PKCS5_OP_OK;
}  // end of int ms_decode_pbes2_sequ(...)



/**
 *  Subroutine ms_decode_pbes2_package decodes the whole PBES2 package for PKCS#5-based
 *  password-based AES-encrypted data.
 *  <p><b>Attention:</b> After successful execution the dereferenced pointer of
 *  <code>aaucp_encry_data</code> is an in-place pointer pointing to a part
 *  of the dereferenced pointer passed <code>aaucp_src_buf</code> pointer before execution.</p>
 *
 *  @param[inout]   aaucp_src_buf       IN: Source buffer pointer before reading.<br>
 *                                      OUT: Source buffer pointer after reading.
 *  @param[inout]   aszp_src_len        IN: Length of source buffer.<br>
 *                                      OUT: Length of source buffer after reading.
 *  @param[out]     adsp_pbes2_output   This pointer to a dsd_stru_pkcs5_pbes_params structure
 *                                      defines all the output elements, such as output data array,
 *                                      iteration count, salt value and algorithms.
 *  @param[out]     aaucp_encry_data    Buffer containing the encry data after decoding
 *  @param[out]     aszp_encry_data_len Length of the encry_data buffer
 *  @param[out]     aszp_bytes_read     Number of bytes read
 
 *  @return         <code>PKCS5_OP_OK</code> on success, error code otherwise.
 */
static int ms_decode_pbes2_package(unsigned char** aaucp_src_buf,
                                   size_t* aszp_src_len,
                                   dsd_stru_pkcs5_pbes_params* adsp_pbes2_output,
                                   unsigned char** aaucp_encry_data,
                                   size_t* aszp_encry_data_len,
                                   size_t* aszp_bytes_read) {
    // Check input parameters
    // ----------------------
    
    // Check source length
    if (*aszp_src_len <= 0) { // no data
        return PKCS5_DEC_NOT_ENOUGH_ASN1_DATA;
    }
    
    // Create output working variables
    unsigned char* aucl_src_buf = *aaucp_src_buf;
    size_t szl_src_len = *aszp_src_len;
    dsd_stru_pkcs5_pbes_params dsl_pbes2_output = *adsp_pbes2_output;
    unsigned char* aucl_encry_data;
    size_t szl_encry_data_len;
    size_t szl_bytes_read_total = 0;
    size_t szl_bytes_read;
    
    // Decode tag and length of the pbes2_encry_data SEQUENCE
    size_t szl_sequence_len;
    int iml_retval = ms_decode_tag_and_length(&aucl_src_buf,
                                              &szl_src_len,
                                              0x30,
                                              &szl_sequence_len,
                                              &szl_bytes_read);
    if (iml_retval != PKCS5_OP_OK) {
        return iml_retval;
    }
    szl_bytes_read_total += szl_bytes_read;
    
    size_t szl_sequence_parts_len_sum = 0;
    // Decode pbes2 SEQUENCE
    iml_retval = ms_decode_pbes2_sequ(&aucl_src_buf,
                                      &szl_src_len,
                                      &dsl_pbes2_output,
                                      &szl_bytes_read);
    if (iml_retval != PKCS5_OP_OK) {
        return iml_retval;
    }
    szl_sequence_parts_len_sum += szl_bytes_read;
    szl_bytes_read_total += szl_bytes_read;
    
    // Decode encry_data
    iml_retval = ms_decode_octet_string(&aucl_src_buf,
                                        &szl_src_len,
                                        &aucl_encry_data,
                                        &szl_encry_data_len,
                                        &szl_bytes_read);
    if (iml_retval != PKCS5_OP_OK) {
        return iml_retval;
    }
    szl_sequence_parts_len_sum += szl_bytes_read;
    szl_bytes_read_total += szl_bytes_read;
    
    if (szl_sequence_parts_len_sum != szl_sequence_len) { // sequence length not same as sequence values length sum
        return PKCS5_DEC_INVALID_ASN1_DATA;
    }
    
    // Set output
    *aaucp_src_buf = aucl_src_buf;
    *aszp_src_len = szl_src_len;
    *adsp_pbes2_output = dsl_pbes2_output;
    *aaucp_encry_data = aucl_encry_data;
    *aszp_encry_data_len = szl_encry_data_len;
    *aszp_bytes_read = szl_bytes_read_total;
    
    return PKCS5_OP_OK;
}  // end of int ms_decode_pbes2_package(...)



/**
 *  Subroutine ms_decrypt_pkcs5_aes_pbes2 decrypts data with a password using the
 *  AES decryption function. The data processing is executed according to the
 *  PKCS#5 standard.
 *
 *  @param[in]      aucp_src_buf        Source buffer pointer.
 *  @param[in]      szp_src_len         Length of source buffer.
 *  @param[inout]   adsp_pbes2_inoutput This pointer to a dsd_stru_pkcs5_pbes_params structure
 *                                      defines all the inoutput elements, such as output data array,
 *                                      iteration count, salt value and algorithms.
 
 *  @return         <code>PKCS5_OP_OK</code> on success, error code otherwise.
 */
static int ms_decrypt_pkcs5_aes_pbes2(unsigned char* aucp_src_buf,
                                      size_t szp_src_len,
                                      dsd_stru_pkcs5_pbes_params* adsp_pbes2_inoutput) {
    // Check input parameters
    // ----------------------
    
    // Check source length
    if (szp_src_len <= 0) { // no data
        return PKCS5_DEC_NOT_ENOUGH_ASN1_DATA;
    }
    
    // Create the symmetric key
    // ------------------------
    
    // Get the derived key from the key derivation function using password and salt
    unsigned char ucrl_aes_key_buf[32];
    int iml_retval = m_pbkdf2_hmac(adsp_pbes2_inoutput->achc_password_buf,
                                   adsp_pbes2_inoutput->szc_pwd_buf_size,
                                   adsp_pbes2_inoutput->achc_salt_buf,
                                   adsp_pbes2_inoutput->szc_salt_buf_size,
                                   adsp_pbes2_inoutput->unc_iteration_count,
                                   ucrl_aes_key_buf,
                                   adsp_pbes2_inoutput->inc_encr_aes_size,
                                   adsp_pbes2_inoutput->iec_enc_hash_type);
    if (iml_retval != 0) {
        return iml_retval;
    }
    
    // Create the aes decryption key from the derived key
    ds_aes_key dsl_aes_decrypt_key;
    m_aes_set_decrypt_key(ucrl_aes_key_buf,
                          ((adsp_pbes2_inoutput->inc_encr_aes_size) >> 2),
                          &dsl_aes_decrypt_key);
    
    // Decrypt the data from the source buffer
    m_aes_cbc_decrypt(aucp_src_buf,
                      aucp_src_buf,
                      &dsl_aes_decrypt_key,
                      szp_src_len >> 4,
                      (unsigned char*)adsp_pbes2_inoutput->achc_initializ_vector_buf,
                      (adsp_pbes2_inoutput->inc_encr_aes_size >> 2) + 6);
    adsp_pbes2_inoutput->achc_input_data_buf = (char*)aucp_src_buf;
    adsp_pbes2_inoutput->szc_input_buf_size = szp_src_len;
    
    // Clear keys and helper array securely
    m_sec_zero_mem(ucrl_aes_key_buf, sizeof(ucrl_aes_key_buf));
    m_sec_zero_mem(&dsl_aes_decrypt_key, sizeof(ds_aes_key));
    
    return PKCS5_OP_OK;
}  // end of int ms_decrypt_pkcs5_aes_pbes2(...)


/**
 *  Subroutine ms_pbmac1_macdata_is_valid checks a given mac data of the received data.
 *  Therefore it creates a password-based message authentication value according to the
 *  PKCS#5 standard. The mac value is preceeded by a PKCS#5-PBMAC1 structure that defines
 *  the parameters used to perform the mac creation. The key for the mac creation is formed
 *  from a password, a salt and an iteration value using the PKCS#5-PBKDF2 function.
 *
 *  @param[in]      adsp_pbmac1_params  This pointer to a dsd_stru_pkcs5_pbes_params structure
 *                                      defines all the input elements, such as input data array,
 *                                      iteration count, salt value and algorithms.
 *  @param[in]      adsp_mac_data       Buffer containing the received mac data
 *  @param[in]      szp_mac_data_len    Length of the mac data buffer
 *
 *  @return         <code>true</code> on success, <code>false</code> otherwise.
 */
static bool ms_pbmac1_macdata_is_valid(dsd_stru_pkcs5_pbes_params* adsp_pbmac1_params,
                                       unsigned char* aucp_mac_data,
                                       size_t szp_mac_data_len) {
    size_t szl_hmac_len = m_get_hmac_len(adsp_pbmac1_params->iec_enc_hash_type) - 2;
    // Check the input data: hmac len and buffer sizes
    if ((szl_hmac_len != szp_mac_data_len) || ((adsp_pbmac1_params->szc_input_buf_size) <= 0) || (szp_mac_data_len <= 0)) {
        return false;
    }
    
    // Create the symmetric key
    // ------------------------
    
    // Get the derived key from the key derivation function using password and salt
    unsigned char ucrl_mac_key_buf[32];
    int iml_retval = m_pbkdf2_hmac(adsp_pbmac1_params->achc_password_buf,
                                   adsp_pbmac1_params->szc_pwd_buf_size,
                                   adsp_pbmac1_params->achc_salt_buf,
                                   adsp_pbmac1_params->szc_salt_buf_size,
                                   adsp_pbmac1_params->unc_iteration_count,
                                   ucrl_mac_key_buf,
                                   adsp_pbmac1_params->inc_encr_aes_size,
                                   adsp_pbmac1_params->iec_enc_hash_type);
    if (iml_retval == 0) {
        // Create the mac value
        // --------------------
        
        // Create the mac value and write it to the destination buffer
        int imrl_dest_len[1] = {(int)szl_hmac_len};
        char chrl_mac_dest_buf[HMAC_MAX_DIGEST_LEN];
        iml_retval = GenHMAC((const char*)ucrl_mac_key_buf,
                             0,
                             adsp_pbmac1_params->inc_encr_aes_size,
                             adsp_pbmac1_params->achc_input_data_buf,
                             0,
                             adsp_pbmac1_params->szc_input_buf_size,
                             adsp_pbmac1_params->iec_enc_hash_type,
                             chrl_mac_dest_buf,
                             0,
                             imrl_dest_len);
        if (iml_retval == 0) {
            // Check if received hmac and created hmac are the same
            iml_retval = const_time_memcmp(chrl_mac_dest_buf, aucp_mac_data, szl_hmac_len);
            if (iml_retval != 0) {
                iml_retval = PKCS5_DEC_INVALID_ASN1_DATA;
            }
        }
    }
    
    // Clear keys array securely
    m_sec_zero_mem(ucrl_mac_key_buf, 32);
    
    return iml_retval == 0;
}  // end of bool ms_pbmac1_macdata_is_valid(...)



extern "C" int m_read_pkcs5_aes_pbes2_pbmac1(unsigned char* aucp_src_buf,
                                             size_t szp_src_len,
                                             char* achp_pwd_buf,
                                             size_t szp_pwd_len,
                                             char** aachp_decrypted_data_buf,
                                             size_t* aszp_decrypted_data_len,
                                             size_t* aszp_bytes_read) {
    // Check input parameters
    // ----------------------
    
    // Check source buffer
    if (aucp_src_buf == NULL) {
        return PKCS5_DEC_INVALID_ASN1_DATA;
    }
    
    // Check source length
    if (szp_src_len <= 0) { // no data
        return PKCS5_DEC_NOT_ENOUGH_ASN1_DATA;
    }
    
    // Initialize variables
    dsd_stru_pkcs5_pbes_params dsl_pbes2_params = {0};
    dsl_pbes2_params.achc_password_buf = achp_pwd_buf;
    dsl_pbes2_params.szc_pwd_buf_size = szp_pwd_len;
    dsd_stru_pkcs5_pbes_params dsl_pbmac1_params = {0};
    dsl_pbmac1_params.achc_password_buf = achp_pwd_buf;
    dsl_pbmac1_params.szc_pwd_buf_size = szp_pwd_len;
    
    size_t szl_bytes_read_total = 0;
    // Decode HOB eyecatcher
    size_t szl_eyecatcher_len = szg_eyecatcher_hob_len;
    if (szp_src_len < szl_eyecatcher_len) {
        return PKCS5_DEC_NOT_ENOUGH_ASN1_DATA;
    }
    else if (memcmp(aucp_src_buf, chrg_eyecatcher_hob, szl_eyecatcher_len) != 0) {
        return PKCS5_DEC_INVALID_ASN1_DATA;
    }
    aucp_src_buf += szl_eyecatcher_len;
    szp_src_len -= szl_eyecatcher_len;
    szl_bytes_read_total += szl_eyecatcher_len;
    
    // Set hmac buffer pointer for later validation
    dsl_pbmac1_params.achc_input_data_buf = (char*)aucp_src_buf;
    
    size_t szl_bytes_read;
    // Decode tag and length of the pbes2_encry_data_pbmac1_mac_data SEQUENCE
    size_t szl_sequence_len;
    int iml_retval = ms_decode_tag_and_length(&aucp_src_buf,
                                              &szp_src_len,
                                              0x30,
                                              &szl_sequence_len,
                                              &szl_bytes_read);
    if (iml_retval != PKCS5_OP_OK) {
        return iml_retval;
    }
    szl_bytes_read_total += szl_bytes_read;
    
    size_t szl_sequence_parts_len_sum = 0;
    // Decode pbes2 package
    unsigned char* aucl_encry_data;
    size_t szl_encry_data_len;
    iml_retval = ms_decode_pbes2_package(&aucp_src_buf,
                                         &szp_src_len,
                                         &dsl_pbes2_params,
                                         &aucl_encry_data,
                                         &szl_encry_data_len,
                                         &szl_bytes_read);
    if (iml_retval != PKCS5_OP_OK) {
        return iml_retval;
    }
    szl_sequence_parts_len_sum += szl_bytes_read;
    szl_bytes_read_total += szl_bytes_read;
    
    // Decode pbmac1 header
    unsigned char* aucl_mac_data;
    size_t szl_mac_data_len;
    iml_retval = ms_decode_pbmac1_header(&aucp_src_buf,
                                         &szp_src_len,
                                         &dsl_pbmac1_params,
                                         &aucl_mac_data,
                                         &szl_mac_data_len,
                                         &szl_bytes_read);
    if (iml_retval != PKCS5_OP_OK) {
        return iml_retval;
    }
    szl_sequence_parts_len_sum += szl_bytes_read;
    szl_bytes_read_total += szl_bytes_read;
    
    if (szl_sequence_parts_len_sum != szl_sequence_len) { // sequence length not same as sequence values length sum
        return PKCS5_DEC_INVALID_ASN1_DATA;
    }
    
    // Set hmac buffer size for validation
    dsl_pbmac1_params.szc_input_buf_size = ((char*)aucp_src_buf - dsl_pbmac1_params.achc_input_data_buf) - szl_mac_data_len;
    
    // Check hmac
    bool bol_pbmac1_macdata_valid = ms_pbmac1_macdata_is_valid(&dsl_pbmac1_params,
                                                               aucl_mac_data,
                                                               szl_mac_data_len);
    if (bol_pbmac1_macdata_valid == false) {
        return PKCS5_DEC_INVALID_ASN1_DATA;
    }
    
    // Decrypt encry_data
    iml_retval = ms_decrypt_pkcs5_aes_pbes2(aucl_encry_data,
                                            szl_encry_data_len,
                                            &dsl_pbes2_params);
    if (iml_retval != PKCS5_OP_OK) {
        return iml_retval;
    }
    
    // Check pkcs5_inoutput structure
    if (m_pkcs5_struc_is_valid(&dsl_pbes2_params) == false) {
        return PKCS5_DEC_INVALID_ASN1_DATA;
    }
    
    // Set the output decrypted data buffer and size
    *aachp_decrypted_data_buf = dsl_pbes2_params.achc_input_data_buf;
    *aszp_decrypted_data_len = dsl_pbes2_params.szc_input_buf_size;
    
    // Set the bytes read
    *aszp_bytes_read = szl_bytes_read_total;
    
    // Clear pkcs#5 structures securely
    m_sec_zero_mem((void *)(&dsl_pbes2_params), sizeof(dsd_stru_pkcs5_pbes_params));
    m_sec_zero_mem((void *)(&dsl_pbmac1_params), sizeof(dsd_stru_pkcs5_pbes_params));
    
    return PKCS5_OP_OK;
}  // end of int m_read_pkcs5_aes_pbes2_pbmac1(...)


/** @} */
#endif //HL_CERT_PKCS5
// end of file ../pkcs5/p5d.cpp


#ifdef HL_CERT_PKCS5
/** @addtogroup pkcs5
* @{
* @file
* This file implements the encryption routines for PKCS-5 password based 
* encryption standard used for storing PKCS-8 formatted private keys in 
* certificate containers.
* @}
*/
//===========================================================
//
// This file implements PKCS-5 password based encryption standard
// used for storing PKCS-8 formatted private keys in certificate
// containers.
//
// Encoding part only.
//
// See RSA PKCS-5 / PKCS-8 for description of algorithm.
// 
//===========================================================
#include <stdlib.h>
#include <string.h>
#if (defined _WIN32) & (_MSC_VER < 1700)
#ifndef _STDINT
#define _STDINT
// MSVC lower than 17.00 does not have stdint.h, assure, all needed types are defined

typedef unsigned __int16 uint16_t;

typedef unsigned __int32 uint32_t;

typedef unsigned __int64 uint64_t;

#endif // !_STDINT
#else
#include <stdint.h>
#endif
#include <stddef.h>
#ifdef _WIN32
#define WIN32_LEAN_AND_MEAN
#include <Windows.h>
#undef WIN32_LEAN_AND_MEAN
#else// Define system-specific HL_* defines here
#ifndef HL_UNIX
#define HL_UNIX

#if (defined __gnu_linux__) || (defined __linux__)
#define HL_LINUX
#endif

#if (defined __APPLE__) && (defined __MACH__)
#define HL_LINUX
#define HL_MACOS
#endif

#ifdef _AIX
#define HL_AIX
#define HL_BIG_ENDIAN
#endif

#ifdef __FreeBSD__
#define HL_FREEBSD
#endif

#if (defined _hpux) || (defined hpux) || (defined __hpux)
#define HL_HPUX
#define HL_BIG_ENDIAN
#endif

#if (defined sun) || (defined __sun)
#define HL_SOLARIS
#endif

#if (defined __arm__) || (defined __aarch64__)
#define HL_LINUX_ARM
#endif

#ifdef __ANDROID__
#define HL_ANDROID
#endif

#endif
#include <hob-unix01.h>
#endif
#ifdef __APPLE__
/* We get target conditionals to keep apart Mac OS, iOS and iOS simulator.
   The conditionals are TARGET_IPHONE_SIMULATOR, TARGET_OS_IPHONE and TARGET_OS_MAC.
   TARGET_IPHONE_SIMULATOR has the highest priority, TARGET_OS_MAC the lowest.
   Always test, if the conditional is 1, as they will be defined as 0, if we 
   are not compiling for the target.
   */
#include <TargetConditionals.h>
#endif

#ifdef HL_ANDROID
#include <netdb.h>
#include <unistd.h>
#include <linux/in.h>
#ifndef SOCKLEN_T
#define SOCKLEN_T      int
#endif
#ifndef SA_FAMILY_T
#define SA_FAMILY_T  short
#endif
#include <sys/endian.h>
#include <asm/ioctls.h>
#include <errno.h>
#endif

#include "hob-encry-1.h"
#include "hob-cert-ext.h"
#ifdef _WIN32
#include <winsock.h>
#endif
#include "hob-cert-err.h"
#include <string.h>
#include "hob-cert-intern.h"
#include "hob-cert-err.h"

/** @addtogroup pkcs5
* @{
*/
/*
* THE FOLLOWING 2 SUBROUTINES ARE DUPLICATES FROM HASN1 !!
* (AND SHOULD BE MOVED TO HASN1.C LATER)
*/
/** Subroutine GetAsn1_DER_LenfieldSize calculates required
* number of bytes for ASN.1 DER encoded length field for a
* given data length ( < 32k) (GetAsn1_DER_LenfieldSize).
*
*               int DataLen length of data
*  @return int LenBytes <> 0 number of length field bytes
* \n            == 0 error occured (length too large)
*/
static  int GetAsn1_DER_LenfieldSize(int DataLen)
{
  int i = (DataLen >> 8) & 0xFF;	// get MSB

  if(i > 0x80) return(0);		// too big
  if(DataLen < 0x80) return(1);		// 1 Byte needed
  if(i == 0) return(2);			// 2 bytes needed
  return(3);				// 3 bytes needed
}
/**
* Subroutine SetAsn1_DER_Lenfield generates ASN.1 encoded
* length field from a given length value (must be < 32K) (SetAsn1_DER_Lenfield).
* Note: buffer size and length value are not checked!
* 
*
*  @param dstbuf Array base
*  @param dstOffset Start of data
*  @param dstLen length of data
*
*/
static  void SetAsn1_DER_Lenfield(char* dstbuf,
					      int dstOffset, int dstLen)
{
  int Index = dstOffset;

  if(dstLen < 0x80)
  {
    dstbuf[Index] = (char) dstLen;
    return;
  }
  if(dstLen < 0x100)
  {
    dstbuf[Index++] = (char) ((unsigned char) 0x81);
    dstbuf[Index] = (unsigned char) dstLen;
    return;
  }
  dstbuf[Index++] = (char) ((unsigned char) 0x82);
  dstbuf[Index++] = (unsigned char) (dstLen >> 8);
  dstbuf[Index] = (unsigned char) dstLen;
}

extern "C"  int EncryptPrivateKey(HMEM_CTX_DEF
			char* PrivateKey,
			int PrivKeyOff, int PrivKeyLen,
			char* Password, int PasswdLen,
			int IteratCnt, int HashType, char* Salt,
			char** pDstBuf, int* pDstLen)
{
  int Retcode,i,j;

  int DstIndex = 0;

  int TotalLen;

  int PrivSeqLen;
  int PrivSeqLenFldSize;

  int AlgorSeqLen;
  int AlgorSeqLenFldSize;

  int ParamSeqLen;
  int ParamSeqLenFldSize;
  
  int IteratCntSize=1;

  int EncPrivKeyLen;
  int EncPrivKeyLenFldSize;
  int DataLen;
  int DataOffset;
  int PadLen;

  char* DstBuf = NULL;

  char SaltBuf[PKCS5_SALT_LENGTH];
  char KeyIVBuf[16];
  int desSubkeyArray[DES_SUBKEY_ARRAY_SIZE];
  //-----------------------------------------------------
  // Do primitive checks on input, calculate required DstLen
  //-----------------------------------------------------
  if((IteratCnt <= 0) || (IteratCnt > 32767) ||	// must be > 0, <= 32767
    ((HashType != pbeWithMD2AndDES_CBC) &&
     (HashType != pbeWithMD5AndDES_CBC)))
    return(PKCS5_ENC_INVALID_INPUT_DATA);

  PadLen  = 8 - (PrivKeyLen & 0x07);	// get padding count
  DataLen = PrivKeyLen + PadLen;	// get required size

  if((EncPrivKeyLenFldSize = GetAsn1_DER_LenfieldSize(DataLen)) == 0)
    return(PKCS5_ENC_INVALID_INPUT_DATA);

  EncPrivKeyLen = DataLen + EncPrivKeyLenFldSize + 1; // ASN.1 OCTET STRING

  if(IteratCnt >= 0x80) IteratCntSize++;	// 2 byte needed

  ParamSeqLen = IteratCntSize + 2 +	//  Iteration count ASN.1 INTEGER
                PKCS5_SALT_LENGTH + 2;	//  Salt ASN.1 OCTET STRING

  if((ParamSeqLenFldSize = GetAsn1_DER_LenfieldSize(ParamSeqLen)) == 0)
    return(PKCS5_ENC_INVALID_INPUT_DATA);

  AlgorSeqLen = PKCS5_ALGOR_OBJID_LEN + 1 +		// ASN.1 OBJECT ID
		  ParamSeqLen + ParamSeqLenFldSize + 1;	// ASN.1 SEQUENCE

  if((AlgorSeqLenFldSize = GetAsn1_DER_LenfieldSize(AlgorSeqLen)) == 0)
    return(PKCS5_ENC_INVALID_INPUT_DATA);

  PrivSeqLen = AlgorSeqLen + AlgorSeqLenFldSize + 1+ // ASN.1 SEQUENCE
	       EncPrivKeyLen;

  if((PrivSeqLenFldSize = GetAsn1_DER_LenfieldSize(PrivSeqLen)) == 0)
    return(PKCS5_ENC_INVALID_INPUT_DATA);

  TotalLen = PrivSeqLen + PrivSeqLenFldSize + 1;
  //-----------------------------------------------------
  // Allocate required buffer
  //-----------------------------------------------------
  DstBuf = BIT8_ARRAY_ALLOC(HMEM_CTX_REF,TotalLen);
  if(DstBuf == NULL)
    return(PKCS5_ENC_DST_BUF_ALLOC_ERR);

  DataOffset = (TotalLen - DataLen);		// start Encrypted
  //-----------------------------------------------------
  // Get 8 byte Salt data (Random)
  //-----------------------------------------------------
  if(Salt == NULL)
  {
//  RAND_BYTES(RANDinst,SaltBuf,0,PKCS5_SALT_LENGTH);
    Retcode = SecDrbgRandBytes(HMEM_CTX_REF1 SaltBuf,0,PKCS5_SALT_LENGTH);
    if(Retcode != 0)
    {
      FREE_ARRAY(HMEM_CTX_REF,DstBuf);
      return(Retcode);    
    }
  }
  else
    memcpy(SaltBuf+0,Salt+0,PKCS5_SALT_LENGTH);
  //---------------------------------------------------
  // Generate the DES key/IV from Password and Salt
  //---------------------------------------------------
  GenPKCS5_DesKeyAndIV(Password,PasswdLen,SaltBuf,0,KeyIVBuf,IteratCnt,HashType);
  //---------------------------------------------------
  // Generate the DES subkeys
  //---------------------------------------------------
  GenDESSubKeys((unsigned char *) KeyIVBuf,
                (unsigned int *) desSubkeyArray);
  //-----------------------------------------------------
  // Move the data to the Destination Buffer and PAD data
  //-----------------------------------------------------
  memcpy(DstBuf+DataOffset,PrivateKey+PrivKeyOff,PrivKeyLen);
  j = DataOffset + PrivKeyLen;
  i = PadLen;  
  do{ DstBuf[j++] = (char) PadLen;i--;}while(i != 0);	// PAD Data
  //---------------------------------------------------
  // Do DES CBC Encrypt the data
  //---------------------------------------------------
  DES_cbc_encrypt_decrypt((unsigned char *)(DstBuf+DataOffset),
                          (unsigned char *)(DstBuf+DataOffset),
			  (unsigned int *) desSubkeyArray,
                          (DataLen >> 3),
			  (unsigned char *)(KeyIVBuf+8),
			  DES_ENCRYPT);
  //---------------------------------------------------
  // Apply the ASN1. Headers
  //---------------------------------------------------
  DstBuf[DstIndex++] = 0x30;			// Outmost Sequence
  SetAsn1_DER_Lenfield(DstBuf,DstIndex,PrivSeqLen); // Length Field
  DstIndex += PrivSeqLenFldSize;		// Skip
  DstBuf[DstIndex++] = 0x30;			// Algorithm Sequence
  SetAsn1_DER_Lenfield(DstBuf,DstIndex,AlgorSeqLen); // Length Field
  DstIndex += AlgorSeqLenFldSize;		// Skip

  memcpy(DstBuf+DstIndex,PKCS5_AlgorObjID+0,PKCS5_ALGOR_OBJID_LEN);
  DstIndex += PKCS5_ALGOR_OBJID_LEN;
  DstBuf[DstIndex++] = (char) HashType;
  DstBuf[DstIndex++] = 0x30;			// Param Sequence
  SetAsn1_DER_Lenfield(DstBuf,DstIndex,ParamSeqLen); // Length Field
  DstIndex += ParamSeqLenFldSize;		// Skip
  DstBuf[DstIndex++] = 0x04;			// OCTET STRING
  DstBuf[DstIndex++] = PKCS5_SALT_LENGTH;	// length

  memcpy(DstBuf+DstIndex,SaltBuf+0,PKCS5_SALT_LENGTH);
  DstIndex += PKCS5_SALT_LENGTH;

  DstBuf[DstIndex++] = 0x02;			// INTEGER
  DstBuf[DstIndex++] = (char) IteratCntSize;	// length
  if(IteratCntSize == 2)			// 2 Bytes
    DstBuf[DstIndex++] = (unsigned char) (IteratCnt >> 8);
  DstBuf[DstIndex++] = (unsigned char) IteratCnt;  
  DstBuf[DstIndex++] = 0x04;			// OCTET STRING
  SetAsn1_DER_Lenfield(DstBuf,DstIndex,DataLen); // Length Field

  pDstBuf[0] = DstBuf;
  pDstLen[0] = TotalLen;
  return(PKCS5_OP_OK);
}



// Eyecatcher defines of the eyecatcher used by the PKCS#5 PBES 2 and PBMAC1 implementation
// ----------------------------------------------------------------------------------------
// PKCS#5 eyecatcher
const char chrg_eyecatcher_hob[] = {
    'H', 'O', 'B'
};
const size_t szg_eyecatcher_hob_len = sizeof(chrg_eyecatcher_hob);


// OID defines of the identifiers used by the PKCS#5 PBES 2 and PBMAC1 implementation
// ----------------------------------------------------------------------------------
// HMAC OIDs
const unsigned char byrg_hmac_sha1_alg_id[] = {
    0x30, 0x0c, 0x06, 0x08, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x02, 0x07, 0x05, 0x00
};
const size_t szg_hmac_sha1_alg_id_len = sizeof(byrg_hmac_sha1_alg_id);

const unsigned char byrg_hmac_sha256_alg_id[] = {
    0x30, 0x0c, 0x06, 0x08, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x02, 0x09, 0x05, 0x00
};
const size_t szg_hmac_sha256_alg_id_len = sizeof(byrg_hmac_sha256_alg_id);

const unsigned char byrg_hmac_sha384_alg_id[] = {
    0x30, 0x0c, 0x06, 0x08, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x02, 0x0a, 0x05, 0x00
};
const size_t szg_hmac_sha384_alg_id_len = sizeof(byrg_hmac_sha384_alg_id);

const unsigned char byrg_hmac_sha512_alg_id[] = {
    0x30, 0x0c, 0x06, 0x08, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x02, 0x0b, 0x05, 0x00
};
const size_t szg_hmac_sha512_alg_id_len = sizeof(byrg_hmac_sha512_alg_id);


// function OIDs
const unsigned char byrg_pbkdf2_oid[] = {
    0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x05, 0x0c
};
const size_t szg_pbkdf2_oid_len = sizeof(byrg_pbkdf2_oid);

const unsigned char byrg_pbes2_oid[] = {
    0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x05, 0x0d
};
const size_t szg_pbes2_oid_len = sizeof(byrg_pbes2_oid);

const unsigned char byrg_pbmac1_oid[] = {
    0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x05, 0x0e
};
const size_t szg_pbmac1_oid_len = sizeof(byrg_pbmac1_oid);


// AES OIDs
const unsigned char byrg_aes128_cbc_oid[] = {
    0x06, 0x09, 0x60, 0x86, 0x48, 0x01, 0x65, 0x03, 0x04, 0x01, 0x02
};
const size_t szg_aes128_cbc_oid_len = sizeof(byrg_aes128_cbc_oid);

const unsigned char byrg_aes192_cbc_oid[] = {
    0x06, 0x09, 0x60, 0x86, 0x48, 0x01, 0x65, 0x03, 0x04, 0x01, 0x16
};
const size_t szg_aes192_cbc_oid_len = sizeof(byrg_aes192_cbc_oid);

const unsigned char byrg_aes256_cbc_oid[] = {
    0x06, 0x09, 0x60, 0x86, 0x48, 0x01, 0x65, 0x03, 0x04, 0x01, 0x2A
};
const size_t szg_aes256_cbc_oid_len = sizeof(byrg_aes256_cbc_oid);


const size_t szg_aes_alg_id_len = (2 + szg_aes128_cbc_oid_len + 2 + AES_BLOCK_SIZE);
const size_t szg_hmac_id_len = szg_hmac_sha256_alg_id_len;


/**
 *  Subroutine m_getasn1_der_lenfield_size calculates required
 *  number of bytes for ASN.1 DER encoded length field for a
 *  given data length <size_t> (m_getasn1_der_lenfield_size).
 *
 *  @param inp_datalen     length of data
 *  @return                number of length field bytes
 *  <br>                    <> 0 : required length 
 *  <br>                    == 0 : error condition (invalid input)
*/
static  int m_getasn1_der_lenfield_size(size_t szp_datalen)
{
   size_t inl_shift;
   int inl_count;

   if (szp_datalen < 0x80)
      return(1);

   inl_count = 1;
   inl_shift = szp_datalen;
   do
   {
     inl_shift >>= 8;
     inl_count++;
   }
   while (inl_shift != 0);

   return(inl_count);
}  // end of int m_getasn1_der_lenfield_size(...)


/**
 *  Subroutine m_get_uint32_encoded_len calculates the required 
 *  number of bytes for an ASN.1 DER encoded unsigned integer 
 *  value of type <unsigned int> (m_get_uint32_encoded_len).
 *
 *  @param unp_value     This parameter contains the unsigned integer value.
 *  @return              The function returns the number of required bytes.
 */
static size_t m_get_uint32_encoded_len(unsigned int unp_value)
{
   if (unp_value < 0x80){
       return 1;
   }
   if (unp_value < 0x8000){
       return 2;
   }
   if (unp_value < 0x800000){
       return 3;
   }
   if (unp_value < 0x80000000){
       return 4;
   }
   return 5;
}  // end of size_t m_get_uint32_encoded_len(...)


/**
 *  Subroutine m_get_pbkdf2_param_enc_len calculates the required 
 *  number of bytes for the ASN.1 DER encoded PBKDF2 parameters 
 *  (m_get_pbkdf2_param_enc_len).
 *
 *  @param szp_salt_len        This parameter contains the length of the salt value in bytes.
 *  @param ump_iteration_cnt   This parameter contains the unsigned integer value of the 
 *                             number of iterations used by the PBKDF2 function.
 *  @return                    The function returns the number of required bytes.
 */
static size_t m_get_pbkdf2_param_enc_len(size_t szp_salt_len, 
                                         uint32_t ump_iteration_cnt)
{
   size_t szl_total = szp_salt_len;

   szl_total += (m_getasn1_der_lenfield_size(szl_total) + 1);

   size_t szl_temp = m_get_uint32_encoded_len(ump_iteration_cnt);
   szl_temp += (m_getasn1_der_lenfield_size(szl_temp) + 1);
   szl_total += szl_temp;

   szl_total += (szg_hmac_sha1_alg_id_len + 3);
   szl_total += (m_getasn1_der_lenfield_size(szl_total) + 1);

   return(szl_total);
}  // end of size_t m_get_pbkdf2_param_enc_len(...)


/**
 *  Subroutine m_get_pbes2_param_enc_len calculates the required 
 *  number of bytes for the ASN.1 DER encoded PKCS#5 PBES2 parameters 
 *  (m_get_pbes2_param_enc_len).
 *
 *  @param szp_salt_len        This parameter contains the length of the salt value in bytes.
 *  @param ump_iteration_cnt   This parameter contains the unsigned integer value of the 
 *                             number of iterations used by the PBKDF2 function.
 *  @return                    The function returns the number of required bytes.
 */
static size_t m_get_pbes2_param_enc_len(size_t szp_salt_len, 
                                        uint32_t ump_iteration_cnt)
{
   size_t szl_total = m_get_pbkdf2_param_enc_len(szp_salt_len, 
                                                 ump_iteration_cnt);

   // Total the length of keyDerivationFunc
   szl_total += szg_pbkdf2_oid_len;
   szl_total += (m_getasn1_der_lenfield_size(szl_total) + 1);

   // Add length of encryption scheme and surrounding tag and length field
   szl_total += szg_aes_alg_id_len;
   szl_total += (m_getasn1_der_lenfield_size(szl_total) + 1);

   // Add length of PBES2 OID and surrounding tag and length field
   szl_total += szg_pbes2_oid_len;
   szl_total += (m_getasn1_der_lenfield_size(szl_total) + 1);

   return(szl_total);
}  // end of size_t m_get_pbes2_param_enc_len(...)


/**
 *  Subroutine m_get_encrypted_len calculates the required number of
 *  bytes for a given data length of a plaintext that shall be AES 
 *  encrypted and enwrapped in an ASN.1 octet string structure
 *  (m_get_encrypted_len). The length of the blocks to be encrypted 
 *  shall be set regarding the AES block size filled with padding. 
 *  Padding is always required.
 *
 *  @param szc_plaintext_len   This parameter contains the length of the plaintext in bytes.
 *  @return                    The function returns the number of required bytes.
 */
static size_t m_get_encrypted_len(size_t szc_plaintext_len)
{
   // Add padding of 1-AES_BLOCK_SIZE, then length of length field and tag
   size_t szl_total = szc_plaintext_len;
   szl_total += AES_BLOCK_SIZE;
   szl_total -= (szl_total % AES_BLOCK_SIZE);
   szl_total += (m_getasn1_der_lenfield_size(szl_total) + 1);

   return(szl_total);
}  // end of size_t m_get_encrypted_len(...)


/**
 *  Subroutine m_get_pbes2_aes_encoded_len calculates the required 
 *  number of bytes for a PKCS#5 PBES2 enwrapped data structure that 
 *  consists of the PBES2 header, the encrypted data and the 
 *  enclosing sequence (m_get_encrypted_len). 
 *  The input data shall be AES encrypted.
 *
 *  @param[in]   adsp_pbes2_params     This pointer to a dsd_stru_pkcs5_pbes_params structure 
 *                                     defines all the input elements, such as input data array, 
 *                                     its length, iteration count, salt value and algorithms.
 *  @return      The function returns the number of required bytes.
 */
static size_t m_get_pbes2_aes_encoded_len(dsd_stru_pkcs5_pbes_params * adsp_pbes2_params)
{
   // Add up length of members, tag and length field
   size_t szl_total = m_get_pbes2_param_enc_len(adsp_pbes2_params->szc_salt_buf_size, 
                                                adsp_pbes2_params->unc_iteration_count);
   szl_total += m_get_encrypted_len(adsp_pbes2_params->szc_input_buf_size);
   szl_total += m_getasn1_der_lenfield_size(szl_total) + 1;

   return(szl_total);
}  // end of size_t m_get_pbes2_aes_encoded_len(...)


/**
 *  Subroutine m_get_pbmac1_param_enc_len calculates the required 
 *  number of bytes for the ASN.1 DER encoded PKCS#5 PBMAC1 parameters 
 *  (m_get_pbmac1_param_enc_len).
 *
 *  @param szp_salt_len        This parameter contains the length of the salt value in bytes.
 *  @param ump_iteration_cnt   This parameter contains the unsigned integer value of the 
 *                             number of iterations used by the PBKDF2 function.
 *  @return                    The function returns the number of required bytes.
 */
static size_t m_get_pbmac1_param_enc_len(size_t szp_salt_len, 
                                         uint32_t ump_iteration_cnt)
{
   // Calculate the length of the key derivation function paramters
   size_t szl_total = m_get_pbkdf2_param_enc_len(szp_salt_len, 
                                                 ump_iteration_cnt);

   // Sum up the length of the key derivation function OID
   szl_total += szg_pbkdf2_oid_len;
   szl_total += m_getasn1_der_lenfield_size(szl_total) + 1;

   // Add length of hmac scheme and surrounding tag and length field
   szl_total += szg_hmac_id_len;
   szl_total += m_getasn1_der_lenfield_size(szl_total) + 1;

   // Add length of PBMAC1 OID and surrounding tag and length field
   szl_total += szg_pbmac1_oid_len;
   szl_total += m_getasn1_der_lenfield_size(szl_total) + 1;

   return(szl_total);
}  // end of size_t m_get_pbmac1_param_enc_len(...)


extern "C" size_t m_get_hmac_len(enum ie_hmac_types iep_enc_hash_type)
{
   switch (iep_enc_hash_type)
   {
     case HMAC_SHA256_ID:  // 3
          return(32 + 2);
     case HMAC_SHA384_ID:  // 4
          return(48 + 2);
     case HMAC_SHA512_ID:  // 5
          return(64 + 2);
     case HMAC_SHA1_ID:  // 1
          return(20 + 2);
     default:
          return(0);
   }
}  //end of size_t m_get_hmac_len(...)


/**
 *  Subroutine m_get_pbmac1_encoded_len calculates the required 
 *  number of bytes for a PKCS#5 PBMAC1 enwrapped data structure that 
 *  consists of the PBMAC1 header, the HMAC data and the enclosing 
 *  sequence (m_get_pbmac1_encoded_len). 
 *
 *  @param[in]   adsp_pbmac1_params    This pointer to a dsd_stru_pkcs5_pbes_params structure 
 *                                     defines all the input elements, such as input data array, 
 *                                     its length, iteration count, salt value and algorithms.
 *  @return      The function returns the number of required bytes.
 */
static size_t m_get_pbmac1_encoded_len(dsd_stru_pkcs5_pbes_params* adsp_pbmac1_params)
{
   // Add up length of members, tag and length field
   size_t szl_total = m_get_pbmac1_param_enc_len(adsp_pbmac1_params->szc_salt_buf_size, 
                                                 adsp_pbmac1_params->unc_iteration_count);
   size_t szl_mac_len = m_get_hmac_len(adsp_pbmac1_params->iec_enc_hash_type);
   if (szl_mac_len <= 0)
      return(0);
   szl_total += szl_mac_len;
   szl_total += m_getasn1_der_lenfield_size(szl_total) + 1;

   return(szl_total);
}  // End of size_t m_get_pbmac1_encoded_len(...)



extern "C" bool m_pkcs5_struc_is_valid(dsd_stru_pkcs5_pbes_params * adsp_pkcs5_params)
{
   #define PKCS5_AES_IV_LENGTH   AES_BLOCK_SIZE   // 16

   // check structure pointer with input data
   if (adsp_pkcs5_params == NULL)
      return(false);
   // check the input data: input buffer
   if (((adsp_pkcs5_params->achc_input_data_buf) == NULL) ||
       ((adsp_pkcs5_params->szc_input_buf_size) == 0))
      return(false);

   // check the input data: password buffer
   if (((adsp_pkcs5_params->achc_password_buf) == NULL) ||
       ((adsp_pkcs5_params->szc_pwd_buf_size) == 0))
      return(false);

   // check the input data: iteration count
   if (((adsp_pkcs5_params->unc_iteration_count) < 1000) ||	// must be > 999 & <= 2147483647
       ((adsp_pkcs5_params->unc_iteration_count) > 0x7FFFFFF))
      return(false);

   // check the input data: encryption/hash type
   if (((adsp_pkcs5_params->iec_enc_hash_type) != HMAC_SHA256_ID) &&   // 3
       ((adsp_pkcs5_params->iec_enc_hash_type) != HMAC_SHA384_ID) &&   // 4
       ((adsp_pkcs5_params->iec_enc_hash_type) != HMAC_SHA512_ID) &&   // 5
       ((adsp_pkcs5_params->iec_enc_hash_type) != HMAC_SHA1_ID))     // 1
      return(false);

   // check the input data: salt buffer
   if (((adsp_pkcs5_params->achc_salt_buf) == NULL) ||
       ((adsp_pkcs5_params->szc_salt_buf_size) < 16))
      return(false);

   // check the aes encryption function key size in 'inc_encr_aes_size'
   if (((adsp_pkcs5_params->inc_encr_aes_size) != AES128_KEY_SIZE) &&  // 16
       ((adsp_pkcs5_params->inc_encr_aes_size) != AES192_KEY_SIZE) &&  // 24
       ((adsp_pkcs5_params->inc_encr_aes_size) != AES256_KEY_SIZE))  // 32
      return(false);

   // check the input data: initialization vector buffer
   if (((adsp_pkcs5_params->achc_initializ_vector_buf) == NULL) ||
       ((adsp_pkcs5_params->szc_initializ_vector_size) != PKCS5_AES_IV_LENGTH))  // explicitly 16 bytes are used (AES-IV)
      return(false);

   return(true);
}  // end of bool m_pkcs5_struc_is_valid(...)



/**
 *  Subroutine m_get_pkcs5_package_len calculates the required size of buffer space 
 *  to write a PKCS#5 password-based AES-encrypted and HMAC-secured package to a buffer.
 *  Note: See the special behavior in subroutine m_create_pkcs5_aes_pbes2_pbmac1 
 *        concerning the salt value.
 *
 *  @param[in]   adsp_pkcs5_params     This pointer to a dsd_stru_pkcs5_pbes_params structure 
 *                                     defines all the input elements, such as input data array, 
 *                                     iteration count, salt value and algorithms.
 *
 *  @return      Required size of buffer space that contains the transport data.
 *  <br>             > 0 ok
 *  <br>             == 0 error condition: invalid input
 */
extern "C" size_t m_get_pkcs5_package_len(dsd_stru_pkcs5_pbes_params* adsp_pkcs5_params)
{
   size_t szl_salt_len;
   dsd_stru_pkcs5_pbes_params dsl_pkcs5_params;

   // check the input structure
   if (m_pkcs5_struc_is_valid(adsp_pkcs5_params) == false)
      return(0);

   // initialize variables
   dsl_pkcs5_params = *adsp_pkcs5_params;

   // determine the salt length to create a different salt for PBES2 and PBMAC1 
   // according to the implementation in subroutine m_create_pkcs5_aes_pbes2_pbmac1
   if ((adsp_pkcs5_params->szc_salt_buf_size) < 32)
   {
     szl_salt_len = 16;
     if ((adsp_pkcs5_params->szc_salt_buf_size) == 16)
        szl_salt_len = 15;
   }
   else
   {
     szl_salt_len = ((adsp_pkcs5_params->szc_salt_buf_size) >> 1);
     if (((adsp_pkcs5_params->szc_salt_buf_size) & 0x01) != 0)
        szl_salt_len++;
   }

   // set salt length in pbes2 pass structure
   dsl_pkcs5_params.szc_salt_buf_size = szl_salt_len;

   // Add up length of members, tag and length field
   size_t szl_total = m_get_pbmac1_encoded_len(&dsl_pkcs5_params);
   szl_total += m_get_pbes2_aes_encoded_len(&dsl_pkcs5_params);
   szl_total += (m_getasn1_der_lenfield_size(szl_total) + 1);

   return(szl_total);
}  // end of size_t m_get_pkcs5_package_len(...)


/**
Writes the length field during ASN.1 encoding.

Short or long form are used, not indefinite form. Writing is done from back
to front. Writing starts at a position one BEFORE the destination pointer.

@param[in]      szp_value_len       length of data
@param[inout]   aucp_dest_buf       IN: Destination buffer pointer before writing. \n
                                    OUT: Destination buffer pointer after writing.
@param[inout]   szp_dest_size       IN: Length of destination buffer. \n
                                    OUT: Length of destination buffer after writing.
@param[out]     szp_bytes_written   Number of bytes written to the buffer.

@return 0 on success, error code otherwise.
 */
static int m_setasn1_der_lenfield(size_t szp_value_len,
                                  unsigned char*& aucp_dest_buf, 
                                  size_t& szp_dest_size,
                                  size_t& szp_bytes_written)
{
    // Go to first writable position.
    --aucp_dest_buf;
    if (szp_value_len < 128) {
        // We use short form
        *aucp_dest_buf = (unsigned char)szp_value_len;
        szp_bytes_written = 1;
        --szp_dest_size;
    } else {
        // We use long form
        size_t szl_len_octets = 0;

        while((szp_value_len > 0) && (szp_dest_size > szl_len_octets)) {
            *aucp_dest_buf-- = szp_value_len % 256;
            szp_value_len /= 256;
            szl_len_octets++;
        }

        if(szp_dest_size <= szl_len_octets){
            return (-9913);
        }
        *aucp_dest_buf = (unsigned char)(0x80 | (unsigned int)szl_len_octets);
        szp_bytes_written = (szl_len_octets + 1);
        szp_dest_size -= szp_bytes_written;
    }
    return 0;
}  // end of  int m_setasn1_der_lenfield(...)



/**
 *  Subroutine m_encode_tag_and_length writes an ASN.1 tag and 
 *  creates an ASN.1 DER encoded length.
 *
 *  @note  Buffer is written back to front. Writing starts at one before the destination pointer.
 *
 *  @param[in]     byp_tag
 *  @param[in]     szp_value_len
 *  @param[inout]  aucp_output_buf         Destination buffer pointer
 *  @param[inout]  szp_avail_output_len
 *  @param[out]    szp_bytes_written
 *
 *  @return        state of processing
 *  <br>             == 0 ok
 *  <br>             != 0 error condition
 */
static int m_encode_tag_and_length(unsigned char byp_tag,
                                   size_t szp_value_len,
                                   unsigned char *& aucp_output_buf,
                                   size_t & szp_avail_output_size,
                                   size_t & szp_bytes_written)
{
   int inl_retval;
   size_t szl_elem_bytes_writ;

   // write the ASN.1 DER encoded length to the buffer
   inl_retval = m_setasn1_der_lenfield(szp_value_len,
                                       aucp_output_buf,
                                       szp_avail_output_size, 
                                       szl_elem_bytes_writ);
   if (inl_retval != 0)
      return(inl_retval);

   szp_bytes_written = szl_elem_bytes_writ;

   if (szp_avail_output_size <= 0)
      return(-1);

   // write the tag value to the buffer
   aucp_output_buf--;
   *aucp_output_buf = byp_tag;
   szp_avail_output_size--;
   szp_bytes_written++;

   return 0;
}  // end of int m_encode_tag_and_length(...)



/**
Encodes the value field of the given integer in DER encoding.

Writing is done from back to front. Writing starts at a position one BEFORE the
destination pointer.

@param[in]      inp_int_val         Integer value to be encoded.
@param[inout]   aucp_dest_buf       IN: Destination buffer pointer before writing. \n
                                    OUT: Destination buffer pointer after writing.
@param[inout]   szp_dest_size       IN: Length of destination buffer. \n
                                    OUT: Length of destination buffer after writing.
@param[out]     szp_bytes_written   Number of bytes written to the buffer.

@return 0 on success, error code otherwise.
*/
static int m_set_integer(int imp_int_val, 
                         unsigned char*& aucp_dest_buf, 
                         size_t& szp_dest_size,
                         size_t& szp_bytes_written)
{
    // First get the first writable byte
    --aucp_dest_buf;

    unsigned char* base = aucp_dest_buf;

    if(imp_int_val >= 0) {
        // We have a positive integer (including 0)
        do {
            if(szp_dest_size < 1){
                return (-9910);
            }
            *aucp_dest_buf-- = imp_int_val % 256;
            szp_dest_size--;
            imp_int_val /= 256;
        } while(imp_int_val);

        // We add a leading 0 octet, if needed
        if(aucp_dest_buf[1] >= 128) {
            if(szp_dest_size < 1){
                return (-9910);
            }
            *aucp_dest_buf-- = 0;
            szp_dest_size--;
        }
    } else {
        // We have a negative integer
        imp_int_val = ~imp_int_val;
        do {
            if(szp_dest_size < 1){
                return (-9910);
            }
            *aucp_dest_buf-- = ~(imp_int_val % 256);
            szp_dest_size--;
            imp_int_val /= 256;
        } while(imp_int_val);
        
        // We add a leading 0xff octet, if needed
        if(aucp_dest_buf[1] < 128) {
            if(szp_dest_size < 1){
                return (-9910);
            }
            *aucp_dest_buf-- = 0xff;
            szp_dest_size--;
        }
    }

    // We write back the encoded length and correct the output buffer pointer
    szp_bytes_written = base - aucp_dest_buf;
    ++aucp_dest_buf;
    return 0;
}  // end of int m_set_integer(...)



/**
Encodes the given integer in DER encoding.

Writing is done from back to front. Writing starts at a position one BEFORE the
destination pointer. The encoding includes tag and length field.

@param[in]      inp_int_val         Integer value to be encoded.
@param[inout]   aucp_dest_buf       IN: Destination buffer pointer before writing. \n
                                    OUT: Destination buffer pointer after writing.
@param[inout]   szp_dest_size       IN: Length of destination buffer. \n
                                    OUT: Length of destination buffer after writing.
@param[out]     szp_bytes_written   Number of bytes written to the buffer.

@return 0 on success, error code otherwise.
*/
static int m_encode_int(int imp_int_val, 
                        unsigned char*& aucp_dest_buf, 
                        size_t& szp_dest_size,
                        size_t& szp_bytes_written)
{
   // We first encode the value, then Tag and length
   int inl_error = m_set_integer(imp_int_val, 
                                 aucp_dest_buf, 
                                 szp_dest_size,
                                 szp_bytes_written);
   if (inl_error != 0)
      return(inl_error);

   size_t szl_tag_len_size = 0;
   inl_error = m_encode_tag_and_length(0x02, 
                                       szp_bytes_written, 
                                       aucp_dest_buf,
                                       szp_dest_size, 
                                       szl_tag_len_size);
   if (inl_error != 0)
      return(inl_error);

   szp_bytes_written += szl_tag_len_size;

   return(inl_error);
}  // end of int m_encode_int(...)



/**
 *  Encodes the given buffer as OCTET STRING in DER encoding.
 *
 *  Writing is done from back to front. Writing starts at a position one BEFORE the
 *  destination pointer. The encoding includes tag and length field.
 *
 *  @param[in]     avop_octet_data     Buffer containing the data to be encoded.
 *  @param[in]     szp_data_len        Number of bytes to be encoded.
 *  @param[inout]  aucp_dest_buf       IN: Destination buffer pointer before writing. \n
 *                                     OUT: Destination buffer pointer after writing.
 *  @param[inout]  szp_dest_size       IN: Length of destination buffer. \n
 *                                     OUT: Length of destination buffer after writing.
 *  @param[out]    szp_bytes_written   Number of bytes written to the buffer.
 *
 *  @return        state of processing
 *  <br>             == 0 ok
 *  <br>             != 0 error condition
 */
static int m_encode_octet_string(void* avop_octet_data,
                                 size_t szp_data_len,
                                 unsigned char*& aucp_dest_buf, 
                                 size_t& szp_dest_size,
                                 size_t& szp_bytes_written)
{
   // check available size of buffer
   if (szp_dest_size < szp_data_len)
      return (-9912);

   // write the data to the destination
   aucp_dest_buf -= szp_data_len;
   memcpy(aucp_dest_buf, avop_octet_data, szp_data_len);

   szp_dest_size -= szp_data_len;

   // add the octet string tag and the length of the data
   int inl_error = m_encode_tag_and_length(0x04, 
                                           szp_data_len, 
                                           aucp_dest_buf,
                                           szp_dest_size, 
                                           szp_bytes_written);

   // add data length
   szp_bytes_written += szp_data_len;

   return(inl_error);
}  // int m_encode_octet_string(...)



/**
 *  Subroutine m_encode_object_identifier writes an object identifier array 
 *  to the destination buffer.
 *
 *  @note  Buffer is written back to front. Writing starts at one before the destination pointer.
 *
 *
 *  @param[in]     abyp_oid
 *  @param[in]     szp_oid_len
 *  @param[inout]  achp_output_buf         This is the destination buffer address the data area written to.
 *  @param[in]     szp_avail_output_size   This parameter defines the available space in bytes 
 *                                         where the data are to be written.
 *  @param[out]    szp_bytes_written       This parameter is used to return the number of bytes 
 *                                         that are actually written to the destination buffer.
 *
 *  @return        state of processing
 *  <br>             == 0 ok
 *  <br>             != 0 error condition
 */
static int m_encode_object_identifier(const unsigned char * abyp_oid,
                                      size_t szp_oid_len,
                                      unsigned char *& aucp_output_buf,
                                      size_t & szp_avail_output_size,
                                      size_t & szp_bytes_written)
{
   if (szp_avail_output_size < szp_oid_len)
   {
     return (-1);
   }

   szp_bytes_written = szp_oid_len;
   aucp_output_buf -= szp_bytes_written;

   memcpy(aucp_output_buf, abyp_oid, szp_bytes_written);
   szp_avail_output_size -= szp_bytes_written;

   return 0;
}  // end of int m_encode_object_identifier(...)



/**
 *  Encodes the AlgorithIdentifier of the given HMAC in DER encoding.
 *
 *  Writing is done from back to front. Writing starts at a position one BEFORE the
 *  destination pointer. The encoding includes tag and length field.
 *
 *  @note Currently, AlgorithmIdentifiers for MD5 and RIPEMD160 are not implemented.
 *  
 *  @param[in]     avop_octet_data    Buffer containing the data to be encoded.
 *  @param[inout]  aucp_dest_buf      IN: Destination buffer pointer before writing. \n
 *                                    OUT: Destination buffer pointer after writing.
 *  @param[inout]  szp_dest_size      IN: Length of destination buffer. \n
 *                                    OUT: Length of destination buffer after writing.
 *  @param[out]    szp_bytes_written  Number of bytes written to the buffer.
 *
 *  @return        state of processing
 *  <br>             == 0 ok
 *  <br>             != 0 error condition
 */
static int m_encode_hmac_alg_id(ie_hmac_types iep_hmac_type,
                                unsigned char*& aucp_dest_buf, 
                                size_t& szp_dest_size,
                                size_t& szp_bytes_written)
{
   if (szp_dest_size < szg_hmac_sha1_alg_id_len)
      return(-1);

   // All AlgorithmIdentifier have same encoded length. Just copy them to destination.

   szp_bytes_written = szg_hmac_sha1_alg_id_len;
   aucp_dest_buf -= szp_bytes_written;
   szp_dest_size -= szp_bytes_written;
   switch (iep_hmac_type)
   {
   case HMAC_SHA1_ID:
        memcpy(aucp_dest_buf, byrg_hmac_sha1_alg_id, szp_bytes_written);
        break;
   case HMAC_SHA256_ID:
        memcpy(aucp_dest_buf, byrg_hmac_sha256_alg_id, szp_bytes_written);
        break;
   case HMAC_SHA384_ID:
        memcpy(aucp_dest_buf, byrg_hmac_sha384_alg_id, szp_bytes_written);
        break;
   case HMAC_SHA512_ID:
        memcpy(aucp_dest_buf, byrg_hmac_sha512_alg_id, szp_bytes_written);
        break;
   case HMAC_RMD160_ID:
   case HMAC_MD5_ID:
   default:
        return(-2);
   }

   return 0;
}  // end of int m_encode_hmac_alg_id(...)



/**
 *  Subroutine m_encode_pbkdf2_params creates the whole PBKDF2 parameters for 
 *  PKCS#5-based password-based key generation.
 *
 *  @note  Buffer processing is back to front oriented. Writing starts at one before the destination pointer.
 *
 *
 *  @param[in]     adsp_pbkdf2_input       This pointer to a dsd_stru_pkcs5_pbes_params structure 
 *                                         defines all the input elements, such as input data array, 
 *                                         iteration count, salt value and algorithms.
 *  @param[inout]  achp_output_buf         This is the destination buffer address the data area written to.
 *  @param[in]     szp_avail_output_size   This parameter defines the available space in bytes 
 *                                         where the data are to be written.
 *  @param[out]    szp_bytes_written       This parameter is used to return the number of bytes 
 *                                         that are actually written to the destination buffer.
 *
 *  @return        state of processing
 *  <br>             == 0 ok
 *  <br>             != 0 error condition
 */
static int m_encode_pbkdf2_params(dsd_stru_pkcs5_pbes_params * adsp_pbkdf2_input,
                                  unsigned char *& aucp_output_buf,
                                  size_t & szp_avail_output_size,
                                  size_t & szp_bytes_written)
{
   int inl_retval;
   size_t szl_elem_bytes_writ;


   // encode "id-hmac" sequence according to the hmac that is used for the PBKDF2 function
   inl_retval = m_encode_hmac_alg_id(adsp_pbkdf2_input->iec_enc_hash_type,
                                     aucp_output_buf,
                                     szp_avail_output_size,
                                     szl_elem_bytes_writ);
   if (inl_retval != 0)
      return(inl_retval);

   szp_bytes_written = szl_elem_bytes_writ;

   // encode "key length" integer
   inl_retval = m_encode_int(adsp_pbkdf2_input->inc_encr_aes_size, 
                             aucp_output_buf,
                             szp_avail_output_size,
                             szl_elem_bytes_writ);
   if (inl_retval != 0)
      return(inl_retval);

   szp_bytes_written += szl_elem_bytes_writ;

   // encode "iteration count" integer
   inl_retval = m_encode_int(adsp_pbkdf2_input->unc_iteration_count, 
                             aucp_output_buf,
                             szp_avail_output_size,
                             szl_elem_bytes_writ);
   if (inl_retval != 0)
      return(inl_retval);

   szp_bytes_written += szl_elem_bytes_writ;

   // encode "salt" octet string
   inl_retval = m_encode_octet_string(adsp_pbkdf2_input->achc_salt_buf,
                                      adsp_pbkdf2_input->szc_salt_buf_size,
                                      aucp_output_buf,
                                      szp_avail_output_size,
                                      szl_elem_bytes_writ);
   if (inl_retval != 0)
      return(inl_retval);

   szp_bytes_written += szl_elem_bytes_writ;

   // write sequence tag and length for PBKDF2 parameters
   inl_retval = m_encode_tag_and_length(0x30, 
                                        szp_bytes_written, 
                                        aucp_output_buf,
                                        szp_avail_output_size,
                                        szl_elem_bytes_writ);
  
   szp_bytes_written += szl_elem_bytes_writ;

   return(inl_retval);
}  // end of int m_encode_pbkdf2_params(...)



/**
 *  Subroutine m_encode_pbkdf2_sequ creates the whole PBKDF2 sequence for 
 *  PKCS#5-based password-based key generation.
 *
 *  @note  Buffer processing is back to front oriented. Writing starts at one before the destination pointer.
 *
 *
 *  @param[in]     adsp_pbkdf2_input       This pointer to a dsd_stru_pkcs5_pbes_params structure 
 *                                         defines all the input elements, such as input data array, 
 *                                         iteration count, salt value and algorithms.
 *  @param[inout]  achp_output_buf         This is the destination buffer address the data area written to.
 *  @param[in]     szp_avail_output_size   This parameter defines the available space in bytes 
 *                                         where the data are to be written.
 *  @param[out]    szp_bytes_written       This parameter is used to return the number of bytes 
 *                                         that are actually written to the destination buffer.
 *
 *  @return        state of processing
 *  <br>             == 0 ok
 *  <br>             != 0 error condition
 */
static int m_encode_pbkdf2_sequ(dsd_stru_pkcs5_pbes_params * adsp_pbkdf2_input,
                                unsigned char *& aucp_output_buf,
                                size_t & szp_avail_output_size,
                                size_t & szp_bytes_written)
{
   int inl_retval;
   size_t szl_elem_bytes_writ;


   // encode PBKDF2 parameters
   inl_retval = m_encode_pbkdf2_params(adsp_pbkdf2_input,
                                       aucp_output_buf,
                                       szp_avail_output_size,
                                       szl_elem_bytes_writ);
   if (inl_retval != 0)
      return(inl_retval);

   szp_bytes_written = szl_elem_bytes_writ;

   // encode PBKDF2 Object Identifier
   inl_retval = m_encode_object_identifier(byrg_pbkdf2_oid,
                                           szg_pbkdf2_oid_len,
                                           aucp_output_buf,
                                           szp_avail_output_size,
                                           szl_elem_bytes_writ);
   if (inl_retval != 0)
      return(inl_retval);

   szp_bytes_written += szl_elem_bytes_writ;

   // write sequence tag and length for PBKDF2 algorithm identifier (OID and parameters)
   inl_retval = m_encode_tag_and_length(0x30, 
                                        szp_bytes_written, 
                                        aucp_output_buf,
                                        szp_avail_output_size,
                                        szl_elem_bytes_writ);
  
   szp_bytes_written += szl_elem_bytes_writ;

   return(inl_retval);
}  // end of int m_encode_pbkdf2_sequ(...)



/**
 *  Subroutine m_encode_pbmac1_params creates the whole PBMAC1 parameters for 
 *  PKCS#5-based password-based HMAC creation.
 *
 *  @note  Buffer processing is back to front oriented. Writing starts at one before the destination pointer.
 *
 *
 *  @param[in]     adsp_pbmac1_input       This pointer to a dsd_stru_pkcs5_pbes_params structure 
 *                                         defines all the input elements, such as input data array, 
 *                                         iteration count, salt value and algorithms.
 *  @param[inout]  achp_output_buf         This is the destination buffer address the data area written to.
 *  @param[in]     szp_avail_output_size   This parameter defines the available space in bytes 
 *                                         where the data are to be written.
 *  @param[out]    szp_bytes_written       This parameter is used to return the number of bytes 
 *                                         that are actually written to the destination buffer.
 *
 *  @return        state of processing
 *  <br>             == 0 ok
 *  <br>             != 0 error condition
 */
static int m_encode_pbmac1_params(dsd_stru_pkcs5_pbes_params * adsp_pbmac1_input,
                                  unsigned char *& aucp_output_buf,
                                  size_t & szp_avail_output_size,
                                  size_t & szp_bytes_written)
{
   int inl_retval;
   size_t szl_elem_bytes_writ;


   // encode "id-hmac" sequence
   inl_retval = m_encode_hmac_alg_id(adsp_pbmac1_input->iec_enc_hash_type,
                                     aucp_output_buf,
                                     szp_avail_output_size,
                                     szl_elem_bytes_writ);
   if (inl_retval != 0)
      return(inl_retval);

   szp_bytes_written = szl_elem_bytes_writ;

   // encode PBKDF2 Identifier sequence
   inl_retval = m_encode_pbkdf2_sequ(adsp_pbmac1_input,
                                     aucp_output_buf,
                                     szp_avail_output_size,
                                     szl_elem_bytes_writ);
   if (inl_retval != 0)
      return(inl_retval);

   szp_bytes_written += szl_elem_bytes_writ;

   // write sequence tag and length for 
   inl_retval = m_encode_tag_and_length(0x30, 
                                        szp_bytes_written, 
                                        aucp_output_buf,
                                        szp_avail_output_size,
                                        szl_elem_bytes_writ);
  
   szp_bytes_written += szl_elem_bytes_writ;

   return(inl_retval);
}  // end of int m_encode_pbmac1_params(...)



/**
 *  Subroutine m_encode_pbmac1_alg_id creates the whole PBMAC1 algorithm ID 
 *  for PKCS#5-based password-based HMAC creation.
 *
 *  @note  Buffer processing is back to front oriented. Writing starts at one before the destination pointer.
 *
 *
 *  @param[in]     adsp_pbmac1_input       This pointer to a dsd_stru_pkcs5_pbes_params structure 
 *                                         defines all the input elements, such as input data array, 
 *                                         iteration count, salt value and algorithms.
 *  @param[inout]  achp_output_buf         This is the destination buffer address the data area written to.
 *  @param[in]     szp_avail_output_size   This parameter defines the available space in bytes 
 *                                         where the data are to be written.
 *  @param[out]    szp_bytes_written       This parameter is used to return the number of bytes 
 *                                         that are actually written to the destination buffer.
 *
 *  @return        state of processing
 *  <br>             == 0 ok
 *  <br>             != 0 error condition
 */
static int m_encode_pbmac1_alg_id(dsd_stru_pkcs5_pbes_params * adsp_pbmac1_input,
                                  unsigned char *& aucp_output_buf,
                                  size_t & szp_avail_output_size,
                                  size_t & szp_bytes_written)
{
   int inl_retval;
   size_t szl_elem_bytes_writ;


   // encode PBMAC1 parameters
   inl_retval = m_encode_pbmac1_params(adsp_pbmac1_input,
                                       aucp_output_buf,
                                       szp_avail_output_size,
                                       szl_elem_bytes_writ);
   if (inl_retval != 0)
      return(inl_retval);

   szp_bytes_written = szl_elem_bytes_writ;

   // encode PBMAC1 Object Identifier
   inl_retval = m_encode_object_identifier(byrg_pbmac1_oid,
                                           szg_pbmac1_oid_len,
                                           aucp_output_buf,
                                           szp_avail_output_size,
                                           szl_elem_bytes_writ);
   if (inl_retval != 0)
      return(inl_retval);

   szp_bytes_written += szl_elem_bytes_writ;

   // write sequence tag and length for PBMAC1 algorithm identifier (OID and parameters)
   inl_retval = m_encode_tag_and_length(0x30, 
                                        szp_bytes_written, 
                                        aucp_output_buf,
                                        szp_avail_output_size,
                                        szl_elem_bytes_writ);
  
   szp_bytes_written += szl_elem_bytes_writ;

   return(inl_retval);
}  // end of int m_encode_pbmac1_alg_id(...)



/**
 *  Subroutine m_encode_pbmac1_header creates the whole PBMAC1 package 
 *  for PKCS#5-based password-based HMAC creation.
 *
 *  @note  The buffer for the HMAC value is not written, but skipped.
 *  @note  Buffer processing is back to front oriented. Writing starts at one before the destination pointer.
 *
 *
 *  @param[in]     adsp_pbmac1_input       This pointer to a dsd_stru_pkcs5_pbes_params structure 
 *                                         defines all the input elements, such as input data array, 
 *                                         iteration count, salt value and algorithms.
 *  @param[inout]  achp_output_buf         This is the destination buffer address the data area written to.
 *  @param[in]     szp_avail_output_size   This parameter defines the available space in bytes 
 *                                         where the data are to be written.
 *  @param[out]    szp_bytes_written       This parameter is used to return the number of bytes 
 *                                         that are actually written to the destination buffer.
 *
 *  @return        state of processing
 *  <br>             == 0 ok
 *  <br>             != 0 error condition
 */
static int m_encode_pbmac1_header(dsd_stru_pkcs5_pbes_params * adsp_pbmac1_input,
                                  unsigned char *& aucp_output_buf,
                                  size_t & szp_avail_output_size,
                                  size_t & szp_bytes_written)
{
   int inl_retval;
   size_t szl_elem_bytes_writ;


   // encode MAC itself by leaving out the necessary space
   size_t szl_mac_len = (m_get_hmac_len(adsp_pbmac1_input->iec_enc_hash_type) - 2);
   if (szl_mac_len <= 0)
      return(-9907);
  
   // check available buffer size
   if (szl_mac_len > szp_avail_output_size)
      return(-9905);
  
   // adapt buffer pointer and written bytes
   aucp_output_buf -= szl_mac_len;
   szp_bytes_written = szl_mac_len;
   szp_avail_output_size -= szl_mac_len;
  
   // encode tag and length of the MAC including octet string
   inl_retval = m_encode_tag_and_length(0x04,
                                        szl_mac_len,
                                        aucp_output_buf,
                                        szp_avail_output_size,
                                        szl_elem_bytes_writ);
   if (inl_retval != 0)
      return(inl_retval);
  
   szp_bytes_written += szl_elem_bytes_writ;
  
   // encode the PBMAC1 algorithm identifier (PBMAC1 & PBMAC1-parameters)
   inl_retval = m_encode_pbmac1_alg_id(adsp_pbmac1_input,
                                       aucp_output_buf,
                                       szp_avail_output_size,
                                       szl_elem_bytes_writ);
   if (inl_retval != 0)
      return(inl_retval);
  
   szp_bytes_written += szl_elem_bytes_writ;
  
   // write outer sequence tag and length for the PBMAC1 package
   inl_retval = m_encode_tag_and_length(0x30, 
                                        szp_bytes_written, 
                                        aucp_output_buf,
                                        szp_avail_output_size,
                                        szl_elem_bytes_writ);
  
   szp_bytes_written += szl_elem_bytes_writ;
  
   return(inl_retval);
}  // end of int m_encode_pbmac1_header(...)



/**
 *  Subroutine m_encode_aes_alg_id creates the whole PBES2 AES encryption algorithm ID 
 *  for PKCS#5-based password-based AES-encrypted data.
 *
 *  @note  Buffer processing is back to front oriented. Writing starts at one before the destination pointer.
 *
 *
 *  @param[in]     adsp_pbes_params        This pointer to a dsd_stru_pkcs5_pbes_params structure 
 *                                         defines all the input elements, such as input data array, 
 *                                         iteration count, salt value and algorithms.
 *  @param[inout]  achp_output_buf         This is the destination buffer address the data area written to.
 *  @param[in]     szp_avail_output_size   This parameter defines the available space in bytes 
 *                                         where the data are to be written.
 *  @param[out]    szp_bytes_written       This parameter is used to return the number of bytes 
 *                                         that are actually written to the destination buffer.
 *
 *  @return        state of processing
 *  <br>             == 0 ok
 *  <br>             != 0 error condition
 */
static int m_encode_aes_alg_id(dsd_stru_pkcs5_pbes_params * adsp_pbes_params,
                               unsigned char *& aucp_output_buf,
                               size_t & szp_avail_output_size,
                               size_t & szp_bytes_written)
{
   int inl_retval;
   size_t szl_elem_bytes_writ;


   // encode "IV" octet string
   inl_retval = m_encode_octet_string(adsp_pbes_params->achc_initializ_vector_buf,
                                      adsp_pbes_params->szc_initializ_vector_size,
                                      aucp_output_buf,
                                      szp_avail_output_size,
                                      szl_elem_bytes_writ);
   if (inl_retval != 0)
      return(inl_retval);

   szp_bytes_written = szl_elem_bytes_writ;

   switch (adsp_pbes_params->inc_encr_aes_size)
   {
     case 16:
          inl_retval = m_encode_object_identifier(byrg_aes128_cbc_oid,
                                                  szg_aes128_cbc_oid_len,
                                                  aucp_output_buf,
                                                  szp_avail_output_size,
                                                  szl_elem_bytes_writ);
          break;
     case 24:
          inl_retval = m_encode_object_identifier(byrg_aes192_cbc_oid,
                                                  szg_aes192_cbc_oid_len,
                                                  aucp_output_buf,
                                                  szp_avail_output_size,
                                                  szl_elem_bytes_writ);
          break;
     case 32:
          inl_retval = m_encode_object_identifier(byrg_aes256_cbc_oid,
                                                  szg_aes256_cbc_oid_len,
                                                  aucp_output_buf,
                                                  szp_avail_output_size,
                                                  szl_elem_bytes_writ);
          break;
     default:
          return(-9908);
          break;
   }
   if (inl_retval != 0)
      return(inl_retval);

   szp_bytes_written += szl_elem_bytes_writ;

   // write outer sequence tag and length for the PBMAC1 package
   inl_retval = m_encode_tag_and_length(0x30, 
                                        szp_bytes_written, 
                                        aucp_output_buf,
                                        szp_avail_output_size,
                                        szl_elem_bytes_writ);
   if (inl_retval != 0)
      return(inl_retval);
  
   szp_bytes_written += szl_elem_bytes_writ;

   return(inl_retval);
}  // end of int m_encode_id_encr_sequ(...)



/**
 *  Subroutine m_encode_pbes2_params creates the whole PBES2 parameters for PKCS#5-based 
 *  password-based AES-encrypted data.
 *
 *  @note  Buffer processing is back to front oriented. Writing starts at one before the destination pointer.
 *
 *
 *  @param[in]     adsp_pbes_params        This pointer to a dsd_stru_pkcs5_pbes_params structure 
 *                                         defines all the input elements, such as input data array, 
 *                                         iteration count, salt value and algorithms.
 *  @param[inout]  achp_output_buf         This is the destination buffer address the data area written to.
 *  @param[in]     szp_avail_output_size   This parameter defines the available space in bytes 
 *                                         where the data are to be written.
 *  @param[out]    szp_bytes_written       This parameter is used to return the number of bytes 
 *                                         that are actually written to the destination buffer.
 *
 *  @return        state of processing
 *  <br>             == 0 ok
 *  <br>             != 0 error condition
 */
static int m_encode_pbes2_params(dsd_stru_pkcs5_pbes_params * adsp_pbes_params,
                                 unsigned char *& aucp_output_buf,
                                 size_t & szp_avail_output_size,
                                 size_t & szp_bytes_written)
{
   int inl_retval;
   size_t szl_elem_bytes_writ;


   // encode "encryption algorithm ID" sequence (AES type + IV)
   inl_retval = m_encode_aes_alg_id(adsp_pbes_params,
                                    aucp_output_buf,
                                    szp_avail_output_size,
                                    szl_elem_bytes_writ);
   if (inl_retval != 0)
      return(inl_retval);

   szp_bytes_written = szl_elem_bytes_writ;

   // encode PBKDF2 Identifier sequence
   inl_retval = m_encode_pbkdf2_sequ(adsp_pbes_params,
                                     aucp_output_buf,
                                     szp_avail_output_size,
                                     szl_elem_bytes_writ);
   if (inl_retval != 0)
      return(inl_retval);

   szp_bytes_written += szl_elem_bytes_writ;

   // write sequence tag and length for PBES2 parameters
   inl_retval = m_encode_tag_and_length(0x30, 
                                        szp_bytes_written, 
                                        aucp_output_buf,
                                        szp_avail_output_size,
                                        szl_elem_bytes_writ);
   if (inl_retval != 0)
      return(inl_retval);
  
   szp_bytes_written += szl_elem_bytes_writ;

   return(inl_retval);
}  // end of int m_encode_pbes2_params(...)



/**
 *  Subroutine m_encode_pbes2_alg_id creates the whole PBES2 algorithm ID 
 *  for PKCS#5-based password-based AES-encrypted data.
 *
 *  @note  Buffer processing is back to front oriented. Writing starts at one before the destination pointer.
 *
 *
 *  @param[in]     adsp_pbes_params        This pointer to a dsd_stru_pkcs5_pbes_params structure 
 *                                         defines all the input elements, such as input data array, 
 *                                         iteration count, salt value and algorithms.
 *  @param[inout]  achp_output_buf         This is the destination buffer address the data area written to.
 *  @param[in]     szp_avail_output_size   This parameter defines the available space in bytes 
 *                                         where the data are to be written.
 *  @param[out]    szp_bytes_written       This parameter is used to return the number of bytes 
 *                                         that are actually written to the destination buffer.
 *
 *  @return        state of processing
 *  <br>             == 0 ok
 *  <br>             != 0 error condition
 */
static int m_encode_pbes2_alg_id(dsd_stru_pkcs5_pbes_params * adsp_pbes_params,
                                 unsigned char *& aucp_output_buf,
                                 size_t & szp_avail_output_size,
                                 size_t & szp_bytes_written)
{
   int inl_retval;
   size_t szl_elem_bytes_writ;


   // encode PBES2 parameters
   inl_retval = m_encode_pbes2_params(adsp_pbes_params,
                                      aucp_output_buf,
                                      szp_avail_output_size,
                                      szl_elem_bytes_writ);
   if (inl_retval != 0)
      return(inl_retval);

   szp_bytes_written = szl_elem_bytes_writ;

   // encode PBES2 Object Identifier
   inl_retval = m_encode_object_identifier(byrg_pbes2_oid,
                                           szg_pbes2_oid_len,
                                           aucp_output_buf,
                                           szp_avail_output_size,
                                           szl_elem_bytes_writ);
   if (inl_retval != 0)
      return(inl_retval);

   szp_bytes_written += szl_elem_bytes_writ;

   // write sequence tag and length for PBES2 algorithm identifier (OID and parameters)
   inl_retval = m_encode_tag_and_length(0x30, 
                                        szp_bytes_written, 
                                        aucp_output_buf,
                                        szp_avail_output_size,
                                        szl_elem_bytes_writ);
   if (inl_retval != 0)
      return(inl_retval);
  
   szp_bytes_written += szl_elem_bytes_writ;

   return(inl_retval);
}  // end of int m_encode_pbes2_alg_id(...)



/**
 *  Subroutine m_encrypt_pkcs5_aes_pbes2 encrypts data with a password using the 
 *  AES encryption function. The data processing is executed according to the 
 *  PKCS#5 standard and the encrypted output data is enwraped in a PKCS#5-PBES2 
 *  structure that defines the parameters used to perform the encryption.
 *
 *  @note  Buffer processing is back to front oriented. Writing starts at one before the destination pointer.
 *
 *
 *  @param[in]     adsp_pbes_params
 *  @param[inout]  achp_output_buf
 *  @param[in]     szp_avail_output_size
 *  @param[out]    szp_used_output_len
 *
 *  @return        state of processing
 *  <br>             == 0 ok
 *  <br>             != 0 error condition
 */
static int m_encrypt_pkcs5_aes_pbes2(dsd_stru_pkcs5_pbes_params * adsp_pbes_params, 
                                     unsigned char *& aucp_output_buf, 
                                     size_t & szp_avail_output_size,
                                     size_t & szp_used_output_len)
{
   int inl_retval;
   int inl_padlen;
   int inl_length;
   size_t szl_in_idx;
   size_t szl_out_idx;
   size_t szl_datalen;
   unsigned char ucrl_aes_helper_buf[AES_BLOCK_SIZE];
   unsigned char ucrl_aes_iv_tmp_buf[AES_BLOCK_SIZE];
   unsigned char ucrl_aes_key_buf[32];
   ds_aes_key dsl_aes_encrypt_key;


   // create the symmetric key
   // ------------------------

   // get the derived key from the key derivation function using password and salt
   inl_retval = m_pbkdf2_hmac((const char *)(adsp_pbes_params->achc_password_buf), 
                              (adsp_pbes_params->szc_pwd_buf_size), 
                              (const char *)(adsp_pbes_params->achc_salt_buf), 
                              (adsp_pbes_params->szc_salt_buf_size), 
                              (adsp_pbes_params->unc_iteration_count), 
                              (&(ucrl_aes_key_buf[0])), 
                              (adsp_pbes_params->inc_encr_aes_size),
                              (adsp_pbes_params->iec_enc_hash_type));
   if (inl_retval != 0)
      return(inl_retval);

   // create the aes encryption key from the derived key
   m_aes_set_encrypt_key((const unsigned char *)(&(ucrl_aes_key_buf[0])),
                         ((adsp_pbes_params->inc_encr_aes_size) >> 2),
                         &dsl_aes_encrypt_key);

   // write the data to the destination buffer
   // ----------------------------------------

   for ( ; ; )  // not a loop !!
   {
     // calculate padding length
     inl_length = ((adsp_pbes_params->szc_input_buf_size) % AES_BLOCK_SIZE);
     inl_padlen = (AES_BLOCK_SIZE - inl_length);

     // check length
     szl_datalen = ((adsp_pbes_params->szc_input_buf_size) + inl_padlen);
     if (szl_datalen > szp_avail_output_size)
     {
       inl_retval = PKCS5_ENC_INVALID_INPUT_DATA;  // error
       break;
     }

     // set start pointer
     aucp_output_buf -= szl_datalen;

     // do the encryption work
     szl_in_idx = 0;
     szl_out_idx = 0;

     // save the IV data, because the IV array will be overwritten by the m_aes_cbc_encrypt function
     memcpy((void *)(&(ucrl_aes_iv_tmp_buf[0])), 
            (const void *)(&((adsp_pbes_params->achc_initializ_vector_buf)[0])), AES_BLOCK_SIZE);

     // encrypt all entirely available blocks of the transport data
     szl_datalen = (adsp_pbes_params->szc_input_buf_size);
     if (szl_datalen >= 16)
     {
       szl_datalen >>= 4;  // number of blocks
       m_aes_cbc_encrypt((const unsigned char *)(&((adsp_pbes_params->achc_input_data_buf)[szl_in_idx])),
                         (unsigned char *)(&(aucp_output_buf[szl_out_idx])),
                         (const ds_aes_key *)(&dsl_aes_encrypt_key),
                         szl_datalen,
                         (unsigned char *)(&(ucrl_aes_iv_tmp_buf[0])),
                         (((adsp_pbes_params->inc_encr_aes_size) / 4) + 6));
       szl_datalen <<= 4;
       szl_in_idx += szl_datalen;
       szl_out_idx += szl_datalen;
     }

     // write last part of the transport data and/or padding to the helper buffer
     inl_length = static_cast<int>((adsp_pbes_params->szc_input_buf_size) - szl_in_idx);
     if ((inl_length > 16) || (inl_length < 0) || ((inl_length + inl_padlen) > 16)) 
     {
       inl_retval = PKCS5_ENC_INVALID_INPUT_DATA;  // error
       break;
     }

     if (inl_length > 0)
     {
       memcpy((void *)(&(ucrl_aes_helper_buf[0])), 
              (const void *)(&((adsp_pbes_params->achc_input_data_buf)[szl_in_idx])), inl_length);
       szl_in_idx += inl_length;
     }
     // add padding according to RFC 5652
     if (inl_padlen > 0)
     {
       memset((void *)(&(ucrl_aes_helper_buf[inl_length])), inl_padlen, inl_padlen);
       inl_length += inl_padlen;
     }
     if (inl_length != 16)
     {
       inl_retval = PKCS5_ENC_INVALID_INPUT_DATA;  // error
       break;
     }

     // save the IV data, because the IV array will be overwritten by the m_aes_cbc_encrypt function
     if (szl_out_idx > 0)
        memcpy((void *)(&(ucrl_aes_iv_tmp_buf[0])), 
               (const void *)(&(aucp_output_buf[szl_out_idx - 16])), AES_BLOCK_SIZE);
     else
        memcpy((void *)(&(ucrl_aes_iv_tmp_buf[0])), 
               (const void *)(&((adsp_pbes_params->achc_initializ_vector_buf)[0])), AES_BLOCK_SIZE);

     // encrypt 1 block of data
     m_aes_cbc_encrypt((const unsigned char *)(&(ucrl_aes_helper_buf[0])),
                       (unsigned char *)(&(aucp_output_buf[szl_out_idx])),
                       (const ds_aes_key *)(&dsl_aes_encrypt_key),
                       1,
                       (unsigned char *)(&(ucrl_aes_iv_tmp_buf[0])),
                       (((adsp_pbes_params->inc_encr_aes_size) / 4) + 6));
     szl_out_idx += 16;

     // set the used length to the return parameter
     szp_used_output_len = szl_out_idx;
     szp_avail_output_size -= szl_out_idx;

     break;
   } // end of for ( ; ; )


   // clear keys and helper array securely
   m_sec_zero_mem(ucrl_aes_key_buf, 32);
   m_sec_zero_mem(&dsl_aes_encrypt_key, sizeof(ds_aes_key));
   m_sec_zero_mem((void *)(&(ucrl_aes_helper_buf[0])), AES_BLOCK_SIZE);

   // clear IV array
   memset((void *)(&(ucrl_aes_iv_tmp_buf[0])), 0, AES_BLOCK_SIZE);

   return(inl_retval);
}  // end of int m_encrypt_pkcs5_aes_pbes2(...)



/**
 *  Subroutine m_write_pbmac1_macdata creates a password-based message authentication 
 *  value according to the PKCS#5 standard. The mac value is preceeded by a PKCS#5-PBMAC1 
 *  structure that defines the parameters used to perform the mac creation. The key for 
 *  the mac creation is formed from a password, a salt and an iteration value using the 
 *  PKCS#5-PBKDF2 function.
 *
 *  @note  This function writes with an increasing index to the passed destination address.
 *
 *
 *  @param[in]     adsp_pbmac1_params    This pointer to a dsd_stru_pkcs5_pbes_params structure 
 *                                       defines all the input elements, such as input data array, 
 *                                       iteration count, salt value and algorithms.
 *  @param[inout]  achp_mac_dest_buf     This is the destination buffer address the mac value 
 *                                       is written to.
 *  @param[in]     szp_mac_dest_size     This parameter defines the available space in bytes 
 *                                       where the data are to be written.
 *  @param[out]    szp_used_output_len   This parameter is used to return the number of bytes 
 *                                       that are actually written to the destination buffer.
 *
 *  @return        state of processing
 *  <br>             == 0 ok
 *  <br>             != 0 error condition
 */
static int m_write_pbmac1_macdata(dsd_stru_pkcs5_pbes_params * adsp_pbmac1_params,
                                  char *& achp_mac_dest_buf,
                                  size_t szp_mac_dest_size,
                                  size_t & szp_used_output_len)
{
   int inl_retval;
   int inrl_dest_len[1];
   unsigned char ucrl_mac_key_buf[32];


   // check the input data: buffer sizes
   if (((adsp_pbmac1_params->szc_input_buf_size) <= 0) || (szp_mac_dest_size <= 0))
      return(PKCS5_ENC_INVALID_INPUT_DATA);

   // create the symmetric key
   // ------------------------

   // get the derived key from the key derivation function using password and salt
   inl_retval = m_pbkdf2_hmac((const char *)(adsp_pbmac1_params->achc_password_buf), 
                              (adsp_pbmac1_params->szc_pwd_buf_size), 
                              (const char *)(adsp_pbmac1_params->achc_salt_buf), 
                              (adsp_pbmac1_params->szc_salt_buf_size), 
                              (adsp_pbmac1_params->unc_iteration_count), 
                              (&(ucrl_mac_key_buf[0])), 
                              (adsp_pbmac1_params->inc_encr_aes_size),
                              (adsp_pbmac1_params->iec_enc_hash_type));
   if (inl_retval != 0)
      return(inl_retval);

   // create the mac value
   // --------------------

   // create the mac value and write it to the destination buffer
   inrl_dest_len[0] = static_cast<int>(szp_mac_dest_size);
   inl_retval = GenHMAC((const char *)(&(ucrl_mac_key_buf[0])), 0,
                        (adsp_pbmac1_params->inc_encr_aes_size),
                        (const char *)(adsp_pbmac1_params->achc_input_data_buf), 0,
                        (adsp_pbmac1_params->szc_input_buf_size),
                        (adsp_pbmac1_params->iec_enc_hash_type),
                        achp_mac_dest_buf, 0,
                        inrl_dest_len);
   if (inl_retval != 0)
      return(inl_retval);

   szp_used_output_len = inrl_dest_len[0];

   // clear keys array securely
   m_sec_zero_mem(ucrl_mac_key_buf, 32);

   return(inl_retval);
}  // end of int m_write_pbmac1_macdata(...)



/**
 *  Subroutine m_generate_pbes2_package creates the whole PBES2 package for PKCS#5-based 
 *  password-based AES-encrypted data.
 *
 *  @note  Buffer processing is back to front oriented. Writing starts at one before the destination pointer.
 *
 *
 *  @param[in]     adsp_pbes2_input        This pointer to a dsd_stru_pkcs5_pbes_params structure 
 *                                         defines all the input elements, such as input data array, 
 *                                         iteration count, salt value and algorithms.
 *  @param[inout]  achp_output_buf         This is the destination buffer address the data area written to.
 *  @param[in]     szp_avail_output_size   This parameter defines the available space in bytes 
 *                                         where the data are to be written.
 *  @param[out]    szp_used_output_len     This parameter is used to return the number of bytes 
 *                                         that are actually written to the destination buffer.
 *
 *  @return        state of processing
 *  <br>             == 0 ok
 *  <br>             != 0 error condition
 */
static int m_generate_pbes2_package(dsd_stru_pkcs5_pbes_params * adsp_pbes2_input,
                                    unsigned char *& aucp_output_buf,
                                    size_t & szp_avail_output_size,
                                    size_t & szp_bytes_written)
{
   int inl_retval;
   size_t szl_elem_bytes_writ;


   // add the encrypted data to the output buffer
   inl_retval = m_encrypt_pkcs5_aes_pbes2(adsp_pbes2_input, 
                                          aucp_output_buf, 
                                          szp_avail_output_size,
                                          szl_elem_bytes_writ);
   if (inl_retval != 0)
      return(inl_retval);
  
   szp_bytes_written = szl_elem_bytes_writ;
  
   // encode tag and length of the encrypted data including padding
   inl_retval = m_encode_tag_and_length(0x04,
                                        szl_elem_bytes_writ,
                                        aucp_output_buf,
                                        szp_avail_output_size,
                                        szl_elem_bytes_writ);
   if (inl_retval != 0)
      return(inl_retval);
  
   szp_bytes_written += szl_elem_bytes_writ;

   // encode the PBES2 algorithm identifier (PBES2 & PBES2-parameters)
   inl_retval = m_encode_pbes2_alg_id(adsp_pbes2_input,
                                      aucp_output_buf,
                                      szp_avail_output_size,
                                      szl_elem_bytes_writ);
   if (inl_retval != 0)
      return(inl_retval);
  
   szp_bytes_written += szl_elem_bytes_writ;
  
   // write outer sequence tag and length for the PBMAC1 package
   inl_retval = m_encode_tag_and_length(0x30, 
                                        szp_bytes_written, 
                                        aucp_output_buf,
                                        szp_avail_output_size,
                                        szl_elem_bytes_writ);
   if (inl_retval != 0)
      return(inl_retval);
  
   szp_bytes_written += szl_elem_bytes_writ;

   return(inl_retval);
}  // end of int m_generate_pbes2_package(...)



extern "C"  int m_create_pkcs5_aes_pbes2_pbmac1(dsd_stru_pkcs5_pbes_params * adsp_pkcs5_params, 
                                                unsigned char * aucp_output_buf, 
                                                size_t szp_output_buf_size,
                                                size_t * aszp_used_output_len)
{
   int inl_retval;
   size_t szl_salt_len;
   size_t szl_pbes2_encoded_len;
   size_t szl_pbmac1_encoded_len;
   size_t szl_mac_len;
   size_t szl_total_length;
   size_t szl_used_len;
   size_t szl_bytes_written;
   size_t szl_remain_out_buf_len;
   char * achl_hmac_val_dest;
   unsigned char * aucl_output_current;
   dsd_stru_pkcs5_pbes_params dsl_pbes2_params;
   dsd_stru_pkcs5_pbes_params dsl_pbmac1_params;


   // check input parameters
   // ----------------------

   // check the input structure
   if (m_pkcs5_struc_is_valid(adsp_pkcs5_params) == false)
      return(PKCS5_ENC_INVALID_INPUT_DATA);

   // check output buffer pointer
   if (aucp_output_buf == NULL)
      return(PKCS5_ENC_INVALID_INPUT_DATA);
  
   // check the pointer to return the number of bytes written to the output buffer
   if (aszp_used_output_len == NULL)
      return(PKCS5_ENC_INVALID_INPUT_DATA);
  
   // process PKCS#5 AES-PBES2 and PBMAC1
   // -----------------------------------

   // initialize variables
   dsl_pbes2_params = *adsp_pkcs5_params;
   dsl_pbmac1_params = *adsp_pkcs5_params;
   szl_bytes_written = 0;

   // determine the salt length to create a different salt for PBES2 and PBMAC1
   if ((adsp_pkcs5_params->szc_salt_buf_size) < 32)
   {
     szl_salt_len = 16;
     if ((adsp_pkcs5_params->szc_salt_buf_size) == 16)
        szl_salt_len = 15;
   }
   else
   {
     szl_salt_len = ((adsp_pkcs5_params->szc_salt_buf_size) >> 1);
     if (((adsp_pkcs5_params->szc_salt_buf_size) & 0x01) != 0)
        szl_salt_len++;
   }

   // set salt length in pbes2 pass structure
   dsl_pbes2_params.szc_salt_buf_size = szl_salt_len;
   // calculate length of PBES2 header plus encrypted data length
   szl_pbes2_encoded_len = m_get_pbes2_aes_encoded_len(&dsl_pbes2_params);

   // clear input data in pbmac1 pass structure
   dsl_pbmac1_params.achc_input_data_buf = NULL;
   dsl_pbmac1_params.szc_input_buf_size = 0;
   // set salt value and length in pbmac1 pass structure
   dsl_pbmac1_params.achc_salt_buf = 
       (&((adsp_pkcs5_params->achc_salt_buf)[(adsp_pkcs5_params->szc_salt_buf_size) - szl_salt_len]));
   dsl_pbmac1_params.szc_salt_buf_size = szl_salt_len;
   // calculate length of PBMAC1 header plus MAC value length
   szl_pbmac1_encoded_len = m_get_pbmac1_encoded_len(&dsl_pbmac1_params);

   // calculate total length that is required for the output buffer
   szl_total_length = (szl_pbes2_encoded_len + szl_pbmac1_encoded_len);
   szl_total_length += (1 + m_getasn1_der_lenfield_size(szl_total_length));

   // check available output space
   if (szl_total_length >= szp_output_buf_size)
      return(PKCS5_ENC_INVALID_INPUT_DATA);

   // store the current pointer where to add the mac-value
   szl_mac_len = (m_get_hmac_len(dsl_pbmac1_params.iec_enc_hash_type) - 2);
   szl_used_len = (szl_total_length - szl_mac_len);
   achl_hmac_val_dest = (char *)(&(aucp_output_buf[szl_used_len]));

   // set the current pointer to the end of the encoding
   aucl_output_current = &(aucp_output_buf[szl_total_length]);
   szl_remain_out_buf_len = szl_total_length;

   // add the PKCS#5 PBMAC1 enwrapping header data to the output buffer
   szl_used_len = 0;
   inl_retval = m_encode_pbmac1_header(&dsl_pbmac1_params,
                                       aucl_output_current, 
                                       szl_remain_out_buf_len, 
                                       szl_used_len);
   if (inl_retval != 0)
      return(inl_retval);
   szl_bytes_written += szl_used_len;

   // add the PKCS#5 PBES2 enwrapping header data to the output buffer
   szl_used_len = 0;
   inl_retval = m_generate_pbes2_package(&dsl_pbes2_params,
                                         aucl_output_current, 
                                         szl_remain_out_buf_len, 
                                         szl_used_len);
   if (inl_retval != 0)
      return(inl_retval);
   szl_bytes_written += szl_used_len;

   // add the all including sequence at the start of the output buffer
   szl_used_len = 0;
   inl_retval = m_encode_tag_and_length(0x30, 
                                        szl_bytes_written, 
                                        aucl_output_current, 
                                        szl_remain_out_buf_len, 
                                        szl_used_len);
   if (inl_retval != 0)
      return(inl_retval);
   szl_bytes_written += szl_used_len;

   // sanity check: bytes written = total length
   if (szl_bytes_written != szl_total_length)
      return(PKCS5_ENC_INVALID_INPUT_DATA);
   // sanity check: current buffer = output buffer paramenter
   if (aucl_output_current != aucp_output_buf)
      return(PKCS5_ENC_INVALID_INPUT_DATA);

   // return the number of written bytes
   if (aszp_used_output_len != NULL)
      *aszp_used_output_len = szl_bytes_written;

   // add the mac value of all the bytes written so far to the output buffer
   // start address for the MAC = aucl_output_current, length for the MAC = (szl_total_length - szl_mac_len)
   // dest address = achl_hmac_val_dest
   dsl_pbmac1_params.achc_input_data_buf = (char *)aucl_output_current;
   dsl_pbmac1_params.szc_input_buf_size = (szl_total_length - szl_mac_len);
   szl_used_len = 0;
   inl_retval = m_write_pbmac1_macdata(&dsl_pbmac1_params,
                                       achl_hmac_val_dest,
                                       szl_mac_len,
                                       szl_used_len);
   if (inl_retval != 0)
      return(inl_retval);

   // sanity check: szl_used_len = szl_mac_len
   if (szl_used_len != szl_mac_len)
      return(PKCS5_ENC_INVALID_INPUT_DATA);

   // clear pointers and values
   achl_hmac_val_dest = NULL;
   aucl_output_current = NULL;
   szl_pbes2_encoded_len = szl_pbmac1_encoded_len = 0;
   szl_mac_len = szl_salt_len = 0;
   szl_total_length = szl_bytes_written = 0;

   // clear pkcs#5 structures securely
   m_sec_zero_mem((void *)(&dsl_pbes2_params), sizeof(dsd_stru_pkcs5_pbes_params));
   m_sec_zero_mem((void *)(&dsl_pbmac1_params), sizeof(dsd_stru_pkcs5_pbes_params));

   return(inl_retval);
}  // end of int m_create_pkcs5_aes_pbes2_pbmac1(...)



struct dsd_pbmac1_params {
    dsd_pbkdf2_params dsc_key_derivation_func;
    ie_hmac_types iec_message_auth_scheme;
};

/**
This structure represents the AlgorithmIdentifier for AES-CBC encryption schemes.

It contains key size and a pointer to the IV. This allows correct encoding and
can also be decoded from the ASN.1 encoding.
*/
struct dsd_pbes2_aes_params {
    size_t szc_key_size;                                        //!< Size of the key to be generated for encryption/decryption
    unsigned char* abyc_iv;                                     //!< IV to be used
};

struct dsd_pbes2_params {
    dsd_pbkdf2_params dsc_key_derivation_func;
    dsd_pbes2_aes_params dsc_encryption_scheme;
};

/**
Structure representing the following ASN.1 Type:

HOB-PKCS5-package ::= SEQUENCE {
EncryptionParams PBES2Algorithms,
EncryptedData OCTET STRING,         -- Value contains the PBES2 encrypted data, using EncryptionParams
MACParams PBMAC1Algorithms,
MACTag OCTET STRING                 -- Contains the MAC generated over the DER encoding of 
                                    -- EncryptionParams, EncryptionData and MACParams as defined by MACParams.
}
*/
struct dsd_hob_pkcs5_package{
    dsd_pbes2_params dsc_encryption_params;
    unsigned char* abyc_encrypted_data;                 
    size_t szc_encrypted_data_len;
    dsd_pbmac1_params dsc_mac_params;
    unsigned char* abyc_mac_tag;
    size_t szc_mac_tag_len;
};


/** @} */
#endif //HL_CERT_PKCS5
// end of file ../pkcs5/p5e.cpp


#ifdef HL_CERT_PKCS12
/** @defgroup pkcs12 PKCS 12
* This module implements the PKCS#12/pfx routines needed for private key export
* and import. The functions are only used by the Security Manager.
* 
* This module depends on the following modules:
*<ul>
* <li> @ref md2 "MD2" hashing functions
* <li> @ref md5 "MD5" hashing functions
* <li> @ref sha1 "SHA-1" hashing functions
* <li> @ref rc4 "RC4" encryption/decryption functions
* <li> @ref rc2 "RC2" encryption/decryption functions
* <li> @ref des "DES" encryption/decryption functions
* <li> @ref aes "AES" encryption/decryption functions
* <li> @ref rsa "RSA" encryption/decryption/signing functions
* <li> @ref dsa_dh "DSA" signing functions
* <li> @ref rand "Random number generator" functions
* <li> @ref asn1 "ASN.1" library functions
*</ul>
*@{
*@file
* This file is the actual implementation of the PKCS 12 module.
*@}
*/
#ifndef XH_INTERFACE
//==============================================================
//
//
// PKCS12 Processing Base Module
//
//
// NOTE: For 16 Bit, *DONT USE* optimization, will lead to errors!
//==============================================================
#if (defined _WIN32) & (_MSC_VER < 1700)
#ifndef _STDINT
#define _STDINT
// MSVC lower than 17.00 does not have stdint.h, assure, all needed types are defined

typedef unsigned __int16 uint16_t;

typedef unsigned __int32 uint32_t;

typedef unsigned __int64 uint64_t;

#endif // !_STDINT
#else
#include <stdint.h>
#endif
#include <stddef.h>
#ifdef _WIN32
#define WIN32_LEAN_AND_MEAN
#include <Windows.h>
#undef WIN32_LEAN_AND_MEAN
#else// Define system-specific HL_* defines here
#ifndef HL_UNIX
#define HL_UNIX

#if (defined __gnu_linux__) || (defined __linux__)
#define HL_LINUX
#endif

#if (defined __APPLE__) && (defined __MACH__)
#define HL_LINUX
#define HL_MACOS
#endif

#ifdef _AIX
#define HL_AIX
#define HL_BIG_ENDIAN
#endif

#ifdef __FreeBSD__
#define HL_FREEBSD
#endif

#if (defined _hpux) || (defined hpux) || (defined __hpux)
#define HL_HPUX
#define HL_BIG_ENDIAN
#endif

#if (defined sun) || (defined __sun)
#define HL_SOLARIS
#endif

#if (defined __arm__) || (defined __aarch64__)
#define HL_LINUX_ARM
#endif

#ifdef __ANDROID__
#define HL_ANDROID
#endif

#endif
#include <hob-unix01.h>
#endif
#ifdef __APPLE__
/* We get target conditionals to keep apart Mac OS, iOS and iOS simulator.
   The conditionals are TARGET_IPHONE_SIMULATOR, TARGET_OS_IPHONE and TARGET_OS_MAC.
   TARGET_IPHONE_SIMULATOR has the highest priority, TARGET_OS_MAC the lowest.
   Always test, if the conditional is 1, as they will be defined as 0, if we 
   are not compiling for the target.
   */
#include <TargetConditionals.h>
#endif

#ifdef HL_ANDROID
#include <netdb.h>
#include <unistd.h>
#include <linux/in.h>
#ifndef SOCKLEN_T
#define SOCKLEN_T      int
#endif
#ifndef SA_FAMILY_T
#define SA_FAMILY_T  short
#endif
#include <sys/endian.h>
#include <asm/ioctls.h>
#include <errno.h>
#endif

#include "hob-encry-1.h"
#include "hob-cert-ext.h"
#ifdef _WIN32
#include <winsock.h>
#endif
#include "hob-cert-err.h"
#include <string.h>
#include "hob-cert-intern.h"

//==============================================================
// Included from pkc12ctl.hc
//==============================================================

// Include-File for PKCS12.C
// NOTE: Java portion for Control Arrays must be generated with
// ----- CTRLST12.C from the C-Arrays !

//-----------------------------------------------------------------
// Array used for PKCS12 Encryption / Decryption
//-----------------------------------------------------------------
static  int PbeAlgDescArr[PBE_ALG_DESC_MAX_SIZE * PKCS12_PFX_PBE_MAX_ALGORS] = {
   //---------------------------------------------------------------
   // PKCS12-PBE SHA1 RC4 128Bit Description (PKCS12/PFX PBE-ID = 1)
   //---------------------------------------------------------------
   PKCS12_HASH_TYPE_SHA1,			// Hash   = SHA1
   PKCS12_CIPHER_ALG_FAMILY_RC4,			// Family = RC4
   0,						// no Subtype
   0,						// no Blocksize (Stream)
   16,						// KEY Size
   0,						// IV  Size
   0,						// no specific Rounds count
   0,						// Reserved
   //---------------------------------------------------------------
   // PKCS12-PBE SHA1 RC4  40Bit Description (PKCS12/PFX PBE-ID = 2)
   //---------------------------------------------------------------
   PKCS12_HASH_TYPE_SHA1,			// Hash      = SHA1
   PKCS12_CIPHER_ALG_FAMILY_RC4,			// Family    = RC4
   0,						// Subtype   = not used
   0,						// Blocksize = 0 (Stream)
   5,						// KEY Size  = 5
   0,						// IV  Size  = 0 (Stream)
   0,						// Rounds    = not used
   0,						// Reserved
   //-------------------------------------------------------------------
   // PKCS12-PBE SHA1 3DES-CBC 3Keys Description (PKCS12/PFX PBE-ID = 3)
   //-------------------------------------------------------------------
   PKCS12_HASH_TYPE_SHA1,			// Hash      = SHA1
   PKCS12_CIPHER_ALG_FAMILY_DES,			// Family    = DES
   PKCS12_CIPHER_3DES_3KEYS_ALG,			// Subtype   = 3DES-CBC 3 Keys
   8,						// Blocksize = 8
   24,						// KEY Size  = 24
   8,						// IV  Size  = 8
   0,						// Rounds    = not used
   0,						// Reserved
   //---------------------------------------------------------------------------
   // PKCS12-PBE SHA1 3DES-CBC 2Keys Description (PKCS12 PBE-ID = 4, PFX unused)
   //---------------------------------------------------------------------------
   PKCS12_HASH_TYPE_SHA1,			// Hash      = SHA1
   PKCS12_CIPHER_ALG_FAMILY_DES,			// Family    = DES
   PKCS12_CIPHER_3DES_2KEYS_ALG,			// Subtype   = 3DES-CBC 2 Keys
   8,						// Blocksize = 8
   24,						// KEY Size  = 16
   8,						// IV  Size  = 8
   0,						// Rounds    = not used
   0,						// Reserved
   //-------------------------------------------------------------------------
   // PKCS12-PBE SHA1 RC2-CBC 128 Bit Description (PKCS12 PBE-ID = 5, PFX = 4)
   //-------------------------------------------------------------------------
   PKCS12_HASH_TYPE_SHA1,			// Hash      = SHA1
   PKCS12_CIPHER_ALG_FAMILY_RC2,			// Family    = RC2
   0,						// Subtype   = not used
   8,						// Blocksize = 8
   16,						// KEY Size  = 16
   8,						// IV  Size  = 8
   0,						// Rounds    = not used
   0,						// Reserved
   //------------------------------------------------------------------------
   // PKCS12-PBE SHA1 RC2-CBC 40 Bit Description (PKCS12 PBE-ID = 6, PFX = 5)
   //------------------------------------------------------------------------
   PKCS12_HASH_TYPE_SHA1,			// Hash      = SHA1
   PKCS12_CIPHER_ALG_FAMILY_RC2,			// Family    = RC2
   0,						// Subtype   = not used
   8,						// Blocksize = 8
   5,						// KEY Size  = 5
   8,						// IV  Size  = 8
   0,						// Rounds    = not used
   0,						// Reserved
   //---------------------------------------------------------------------------
   // PKCS12-PBE SHA1 DES-CBC 56 Bit Description (PKCS12 unused, PFX PBE-ID = 6)
   //---------------------------------------------------------------------------
   PKCS12_HASH_TYPE_SHA1,			// Hash      = SHA1
   PKCS12_CIPHER_ALG_FAMILY_DES,			// Family    = DES
   PKCS12_CIPHER_DES_ALG,			// Subtype   = DES-CBC
   8,						// Blocksize = 8
   8,						// KEY Size  = 8
   8,						// IV  Size  = 8
   0,						// Rounds    = not used
   0,						// Reserved
};

//---------------------------------------------------------------
// X509 id-ce Arc OID(s) [without ASN.1 Header !]
// Used for PKCS12 private Keys (Attributes)
//---------------------------------------------------------------
static  char X509_IdCeBaseOID[X509_ID_CE_BASE_OID_LEN] = {
   (unsigned char) 0x55, (unsigned char) 0x1D,
};

//---------------------------------------------------------------
// X9.57 DSA Arc OID(s) [without ASN.1 Header !]
// Used for PKCS12 private Keys (Algor Params) / Signature Algors
//---------------------------------------------------------------
static  unsigned char X957_DsaAlgorsBaseOID[X957_DSA_ALGORS_BASE_OID_LEN] = {
   (unsigned char) 0x2A, (unsigned char) 0x86, (unsigned char) 0x48, (unsigned char) 0xCE,
   (unsigned char) 0x38, (unsigned char) 0x04,
};

//---------------------------------------------------------------
// OIW Arc OID(s) [without ASN.1 Header !]
// Used for PFX Signature Algors
//---------------------------------------------------------------
static  char OIW_AlgorsBaseOID[OIW_ALGORS_BASE_OID_LEN] = {
   (unsigned char) 0x2B, (unsigned char) 0x0E, (unsigned char) 0x03, (unsigned char) 0x02,
};

//---------------------------------------------------------------
// PKCS-1 Arc (pkcs-1) OID(s) [without ASN.1 Header !]
// Used for PKCS12 private Keys / Signature Algors
//---------------------------------------------------------------
static  unsigned char PKCS1_RsaAlgorsBaseOID[PKCS1_RSA_ALGORS_BASE_OID_LEN] = {
   (unsigned char) 0x2A, (unsigned char) 0x86, (unsigned char) 0x48, (unsigned char) 0x86,
   (unsigned char) 0xF7, (unsigned char) 0x0D, (unsigned char) 0x01, (unsigned char) 0x01
};
//---------------------------------------------------------------
// PKCS-2 Arc (pkcs-2) OID(s) [without ASN.1 Header !]
// Used for PFX private Keys / Signature Algors
//---------------------------------------------------------------
static  unsigned char PKCS2_DigestAlgorsBaseOID[PKCS2_DIGEST_ALGS_BASE_OID_LEN] = {
   (unsigned char) 0x2A, (unsigned char) 0x86, (unsigned char) 0x48, (unsigned char) 0x86,
   (unsigned char) 0xF7, (unsigned char) 0x0D, (unsigned char) 0x02,
};

//---------------------------------------------------------------
// PKCS-7 Arc (pkcs-7) OID(s) [without ASN.1 Header !]
// Used for PKCS12
//---------------------------------------------------------------
static  unsigned char PKCS7ContentTypesBaseOID[PKCS7_CONT_TYPES_BASE_OID_LEN] = {
   (unsigned char) 0x2A, (unsigned char) 0x86, (unsigned char) 0x48, (unsigned char) 0x86,
   (unsigned char) 0xF7, (unsigned char) 0x0D, (unsigned char) 0x01, (unsigned char) 0x07
};

//---------------------------------------------------------------
// PKCS-9 Attribute Arc (pkcs9-at) OID(s) [without ASN.1 Header !]
// Note: Only Friendly name (pkcs9-at-20), local KeyID (pkcs9-at-21)
// -----
//---------------------------------------------------------------
static  unsigned char PKCS9AttTypesBaseOID[PKCS9_ATT_TYPES_BASE_OID_LEN] = {
   (unsigned char) 0x2A, (unsigned char) 0x86, (unsigned char) 0x48, (unsigned char) 0x86,
   (unsigned char) 0xF7, (unsigned char) 0x0D, (unsigned char) 0x01, (unsigned char) 0x09
};
//---------------------------------------------------------------
// PKCS-9 CertTypes Arc (pkcs9-22) OID(s) [without ASN.1 Header !]
// used for PKCS12
//---------------------------------------------------------------
static  unsigned char PKCS9CertTypesBaseOID[PKCS9_CERT_TYPES_BASE_OID_LEN] = {
   (unsigned char) 0x2A, (unsigned char) 0x86, (unsigned char) 0x48, (unsigned char) 0x86,
   (unsigned char) 0xF7, (unsigned char) 0x0D, (unsigned char) 0x01, (unsigned char) 0x09,
   (unsigned char) 0x16,
};
//---------------------------------------------------------------
// PKCS-9 CrlTypes Arc (pkcs9-23) OID(s) [without ASN.1 Header !]
// used for PKCS12
//---------------------------------------------------------------
static  unsigned char PKCS9CrlTypesBaseOID[PKCS9_CRL_TYPES_BASE_OID_LEN] = {
   (unsigned char) 0x2A, (unsigned char) 0x86, (unsigned char) 0x48, (unsigned char) 0x86,
   (unsigned char) 0xF7, (unsigned char) 0x0D, (unsigned char) 0x01, (unsigned char) 0x09,
   (unsigned char) 0x17,
};

//*******************************************************************
//
// PKCS12 V1 and V3 Arcs
// NOTE: Some Arcs are multiple defined depending on Version,
// ----- or have been reassigned
//
//*******************************************************************

//---------------------------------------------------------------------------
// PKCS-12 V1 TransportMode Arc OID(s) [without ASN.1 OID Header !] pkcs-12 1
//---------------------------------------------------------------------------
static  unsigned char PFX_ModeIDsBaseOID[PFX_MODE_IDS_BASE_OID_LEN] = {
   (unsigned char) 0x2A, (unsigned char) 0x86, (unsigned char) 0x48, (unsigned char) 0x86,
   (unsigned char) 0xF7, (unsigned char) 0x0D, (unsigned char) 0x01, (unsigned char) 0x0C,
   (unsigned char) 0x01,
};

//----------------------------------------------------------------------
// PKCS-12 V3 PBE-Type Arc OID(s) [without ASN.1 OID Header !] pkcs-12 1
// NOTE: Same as PKCS12 V1 TransportMode Arc
//----------------------------------------------------------------------
static  unsigned char PKCS12PbeTypesBaseOID[PKCS12_PBE_TYPES_BASE_OID_LEN] = {
   (unsigned char) 0x2A, (unsigned char) 0x86, (unsigned char) 0x48, (unsigned char) 0x86,
   (unsigned char) 0xF7, (unsigned char) 0x0D, (unsigned char) 0x01, (unsigned char) 0x0C,
   (unsigned char) 0x01,
};

//---------------------------------------------------------------------------
// PKCS-12 V1 Espvk Arc OID(s) [without ASN.1 OID Header !] pkcs-12 2
//---------------------------------------------------------------------------
static  unsigned char PFX_EspvkIDsBaseOID[PFX_ESPVK_IDS_BASE_OID_LEN] = {
   (unsigned char) 0x2A, (unsigned char) 0x86, (unsigned char) 0x48, (unsigned char) 0x86,
   (unsigned char) 0xF7, (unsigned char) 0x0D, (unsigned char) 0x01, (unsigned char) 0x0C,
   (unsigned char) 0x02,
};
//---------------------------------------------------------------------------
// PKCS-12 V1 BagID Arc OID(s) [without ASN.1 OID Header !] pkcs-12 3
//---------------------------------------------------------------------------
static  unsigned char PFX_BagIDsBaseOID[PFX_BAG_IDS_BASE_OID_LEN] = {
   (unsigned char) 0x2A, (unsigned char) 0x86, (unsigned char) 0x48, (unsigned char) 0x86,
   (unsigned char) 0xF7, (unsigned char) 0x0D, (unsigned char) 0x01, (unsigned char) 0x0C,
   (unsigned char) 0x03,
};
//---------------------------------------------------------------------------
// PKCS-12 V1 CertType Arc OID(s) [without ASN.1 OID Header !] pkcs-12 4
//---------------------------------------------------------------------------
static  unsigned char PFX_CertIDsBaseOID[PFX_CERT_IDS_BASE_OID_LEN] = {
   (unsigned char) 0x2A, (unsigned char) 0x86, (unsigned char) 0x48, (unsigned char) 0x86,
   (unsigned char) 0xF7, (unsigned char) 0x0D, (unsigned char) 0x01, (unsigned char) 0x0C,
   (unsigned char) 0x04,
};

//-----------------------------------------------------------------------------
// PKCS-12 V1 EncryptPbe Arc OID(s) [without ASN.1 OID Header !] pkcs-12 5 1
//-----------------------------------------------------------------------------
static  unsigned char PFX_EncPbeIDsBaseOID[PFX_ENC_PBE_IDS_BASE_OID_LEN] = {
   (unsigned char) 0x2A, (unsigned char) 0x86, (unsigned char) 0x48, (unsigned char) 0x86,
   (unsigned char) 0xF7, (unsigned char) 0x0D, (unsigned char) 0x01, (unsigned char) 0x0C,
   (unsigned char) 0x05, (unsigned char) 0x01,
};

//-------------------------------------------------------------------------------
// PKCS-12 V1 PKCS5EncryptPbe Arc OID(s) [without ASN.1 OID Header!] pkcs-5 10
// NOTE: Only one PbeAlgorID, SHA1AndDES-CBC (10) is taken from this Arc !
// -----
//-------------------------------------------------------------------------------
static  unsigned char PFX_PKCS5_EncPbeIDsBaseOID[PFX_PKCS5_ENCPBEID_BASE_OID_LEN] = {
   (unsigned char) 0x2A, (unsigned char) 0x86, (unsigned char) 0x48, (unsigned char) 0x86,
   (unsigned char) 0xF7, (unsigned char) 0x0D, (unsigned char) 0x01, (unsigned char) 0x05,
   (unsigned char) 0x01,
};

//-------------------------------------------------------------------------
// PKCS-12 V3 Bag-Type Arc OID(s) [without ASN.1 OID Header !] pkcs-12 10 1 
//-------------------------------------------------------------------------
static  unsigned char PKCS12BagTypesBaseOID[PKCS12_BAG_TYPES_BASE_OID_LEN] = {
   (unsigned char) 0x2A, (unsigned char) 0x86, (unsigned char) 0x48, (unsigned char) 0x86,
   (unsigned char) 0xF7, (unsigned char) 0x0D, (unsigned char) 0x01, (unsigned char) 0x0C,
   (unsigned char) 0x0A, (unsigned char) 0x01,
};

//================================================================
// ASN.1 Control structures used for conversion to and from
// internal data objects. Control entries have fixed length of 4
// bytes.
// NOTE: See documentation of Parser Control Structures (which does not
// ----- yet exist ...) before making changes !!!
//================================================================

//()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()
//
// General ASN.1 Control Structures
//
//()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()

//================================================================
// General ASN.1 ANY Split Controls
// from/to ANY <-> Data
// NOTE: 1st one is used for decoding, 2nd one for encoding !
//
//================================================================
extern "C"  unsigned char ASN1_AnyFromCtl[ASN1_ANY_CTL_SIZE]={

   // L1 ANY: Data
   // DataIndex: 0
   (unsigned char) (X_ONLY | DATA_INDEX),
   (unsigned char) (ASN1_UNIVERSAL_EOC),
   (unsigned char) ASN1_ANY_VALUE_INDEX,
   (unsigned char) 0x00,
};
//================================================================
// General ASN.1 ANY Split Control
// from/to ANY <-> Data
//
//================================================================
extern "C"  unsigned char ASN1_AnyCtl[ASN1_ANY_CTL_SIZE]={

   // L1 ANY: Data
   // DataIndex: 0
   (unsigned char) (X_ONLY | DATA_INDEX | ANY_ASN1),
   (unsigned char) (ASN1_UNIVERSAL_EOC),
   (unsigned char) ASN1_ANY_VALUE_INDEX,
   (unsigned char) 0x00,
};
//================================================================
// General ASN.1 INTEGER Split Control
// from/to INTEGER <-> Data
// NOTE: Leading Zero Byte is skipped/inserted !
// -----
//
//================================================================
extern "C"  unsigned char ASN1IntegerCtl[ASN1_INTEGER_CTL_SIZE]={

   // L1 INTEGER: Data
   // DataIndex: 0
   (unsigned char) (X_ONLY | DATA_INDEX |  ZERO_LEAD_FLAG),
   (unsigned char) (ASN1_UNIVERSAL_INTEGER),
   (unsigned char) ASN1_INTEGER_VALUE_INDEX,
   (unsigned char) 0x00,
};

//================================================================
// General ASN.1 BITSTRING Split Control
// from/to BITSTRING <-> Data
//
//================================================================
extern "C"  unsigned char ASN1_BitstrCtl[ASN1_BITSTR_CTL_SIZE]={

   // L1 BITSTR: Data
   // DataIndex: 0
   (unsigned char) (X_ONLY | DATA_INDEX),
   (unsigned char) (ASN1_UNIVERSAL_BITSTRING),
   (unsigned char) ASN1_BITSTR_VALUE_INDEX,
   (unsigned char) 0x00,
};

//================================================================
// General ASN.1 OCTESTSTRING Split Control
// from/to OCTESTSTRING <-> Data
//
//================================================================
extern "C"  unsigned char ASN1OctetStrCtl[ASN1_OCTETSTR_CTL_SIZE]={

   // L1 OCTETSTR: Data
   // DataIndex: 0
   (unsigned char) (X_ONLY | DATA_INDEX),
   (unsigned char) (ASN1_UNIVERSAL_OCTETSTRING),
   (unsigned char) ASN1_OCTESTSTR_VALUE_INDEX,
   (unsigned char) 0x00,
};
//================================================================
// General ASN.1 Constructed OCTESTSTRING Split Control
// from/to Constructed OCTESTSTRING <-> Data
//
//================================================================
extern "C"  unsigned char ASN1ConstOctetStrCtl[ASN1_OCTETSTR_CTL_SIZE]={

   // L1 OCTETSTR: Data
   // DataIndex: 0
   (unsigned char) (X_ONLY | DATA_INDEX),
   (unsigned char) (ASN1_UNIVERSAL_OCTETSTRING | ASN1_CONSTRUCTED),
   (unsigned char) ASN1_OCTESTSTR_VALUE_INDEX,
   (unsigned char) 0x00,
};
//================================================================
// General ASN.1 BMPSTRING Split Control
// from/to BMPSTRING <-> Data
//
//================================================================
extern "C"  unsigned char ASN1BmpStrCtl[ASN1_BMPSTR_CTL_SIZE]={

   // L1 BMPSTR: Data
   // DataIndex: 0
   (unsigned char) (X_ONLY | DATA_INDEX),
   (unsigned char) (ASN1_UNIVERSAL_BMPSTR),
   (unsigned char) ASN1_BMPSTR_VALUE_INDEX,
   (unsigned char) 0x00,
};
//================================================================
// General ASN.1 SEQUENCE Split Control
// from/to SEQUENCE <-> Any Data
//
//================================================================
extern "C"  unsigned char ASN1_SequenceCtl[ASN1_SEQUENCE_CTL_SIZE]={

   // L1 SEQ: AnyData
   // DataIndex: 0
   (unsigned char) (X_ONLY | DATA_INDEX),
   (unsigned char) (ASN1_UNIVERSAL_SEQUENCE | ASN1_CONSTRUCTED),
   (unsigned char) ASN1_SEQUENCE_VALUE_INDEX,
   (unsigned char) 0x00,
};

//================================================================
// General ASN.1 SET Split Control
// from/to SET <-> Data
//
//================================================================
extern "C"  unsigned char ASN1_SetCtl[ASN1_SET_CTL_SIZE]={

   // L1 SET: AnyData
   // DataIndex: 0
   (unsigned char) (X_ONLY | DATA_INDEX),
   (unsigned char) (ASN1_UNIVERSAL_SET | ASN1_CONSTRUCTED),
   (unsigned char) ASN1_SET_VALUE_INDEX,
   (unsigned char) 0x00,
};

//()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()
//
// X501, X509  Control structures
//
//()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()

//()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()
//
// X9.57 DSA Control structures
//
//()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()

//================================================================
// X9.57 AlgorParams Split/Combine Control Structure:
// from/to X9.57 AlgorParams <-> p, q, g
// NOTE: is also present in HASN1.C (HASN1CTL.HC)
//
//----------------------------------------------------------------
extern "C"  unsigned char X957AlgParamsCtl[X957_ALGPAR_CTL_SIZE]={

   // L1 SEQ: AlgorParams
   (unsigned char) (X_ONLY | CONSTRUCT),
   (unsigned char) (ASN1_UNIVERSAL_SEQUENCE | ASN1_CONSTRUCTED),
   (unsigned char) 0x00,
   (unsigned char) 0x00,
   //------------------------------------------------------------------------
   // 1. Modulus p: INT
   //------------------------------------------------------------------------
   // L2 INTEGER: Modulus p
   // DataIndex: 0
   (unsigned char) (X_FIRST | DATA_INDEX | ZERO_LEAD_FLAG),
   (unsigned char) (ASN1_UNIVERSAL_INTEGER),
   (unsigned char) X957_ALGPAR_MODUL_P_INDEX,
   (unsigned char) 0x00,
   //------------------------------------------------------------------------
   // 2. Prime q: INT
   //------------------------------------------------------------------------
   // L2 INTEGER: Prime q
   // DataIndex: 1
   (unsigned char) (X_MIDDLE | DATA_INDEX | ZERO_LEAD_FLAG),
   (unsigned char) (ASN1_UNIVERSAL_INTEGER),
   (unsigned char) X957_ALGPAR_PRIME_Q_INDEX,
   (unsigned char) 0x00,
   //------------------------------------------------------------------------
   // 3. Generator g: INT
   //------------------------------------------------------------------------
   // L2 INTEGER: Generator g
   // DataIndex: 2
   (unsigned char) (X_LAST | DATA_INDEX | ZERO_LEAD_FLAG),
   (unsigned char) (ASN1_UNIVERSAL_INTEGER),
   (unsigned char) X957_ALGPAR_GENERATOR_G_INDEX,
   (unsigned char) 0x00,
};

//()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()
//
// PKCS1 Control structures
//
//()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()

//================================================================
// PKCS1 PrivateKey Split/Combine Control Structure:
// from/to PKCS8 PrivateKey <-> Version, n, e, d, p, q, d mod(p-1),
// d mod(q-1), q**-1 mod(p)
//
//----------------------------------------------------------------
extern "C"  unsigned char PKCS1PrivKeyCtl[PKCS1_PRIVKEY_CTL_SIZE]={

   // L1 SEQ: PrivKey
   (unsigned char) (X_ONLY | CONSTRUCT),
   (unsigned char) (ASN1_UNIVERSAL_SEQUENCE | ASN1_CONSTRUCTED),
   (unsigned char) 0x00,
   (unsigned char) 0x00,
   //------------------------------------------------------------------------
   // 1. Version: INT
   //------------------------------------------------------------------------
   // L2 INTEGER: Version (0)
   // DataIndex: 0
   (unsigned char) (X_FIRST | DATA_INDEX),
   (unsigned char) (ASN1_UNIVERSAL_INTEGER),
   (unsigned char) PKCS1_PRIVKEY_VERSION_INDEX,
   (unsigned char) 0x00,
   //------------------------------------------------------------------------
   // 2. Modulus n: INT
   //------------------------------------------------------------------------
   // L2 INTEGER: Modulus n
   // DataIndex: 1
   (unsigned char) (X_MIDDLE | DATA_INDEX | ZERO_LEAD_FLAG),
   (unsigned char) (ASN1_UNIVERSAL_INTEGER),
   (unsigned char) PKCS1_PRIVKEY_MODUL_INDEX,
   (unsigned char) 0x00,
   //------------------------------------------------------------------------
   // 3. Public Exponent e: INT
   //------------------------------------------------------------------------
   // L2 INTEGER: Public Exp. e
   // DataIndex: 2
   (unsigned char) (X_MIDDLE | DATA_INDEX | ZERO_LEAD_FLAG),
   (unsigned char) (ASN1_UNIVERSAL_INTEGER),
   (unsigned char) PKCS1_PRIVKEY_PUBEXP_INDEX,
   (unsigned char) 0x00,
   //------------------------------------------------------------------------
   // 4. Private Exponent d: INT
   //------------------------------------------------------------------------
   // L2 INTEGER: Priv. Exponent d
   // DataIndex: 3
   (unsigned char) (X_MIDDLE | DATA_INDEX | ZERO_LEAD_FLAG),
   (unsigned char) (ASN1_UNIVERSAL_INTEGER),
   (unsigned char) PKCS1_PRIVKEY_PRIVEXP_INDEX,
   (unsigned char) 0x00,
   //------------------------------------------------------------------------
   // 5. Prime p: INT
   //------------------------------------------------------------------------
   // L2 INTEGER: Prime p
   // DataIndex: 4
   (unsigned char) (X_MIDDLE | DATA_INDEX | ZERO_LEAD_FLAG),
   (unsigned char) (ASN1_UNIVERSAL_INTEGER),
   (unsigned char) PKCS1_PRIVKEY_PRIME_P_INDEX,
   (unsigned char) 0x00,
   //------------------------------------------------------------------------
   // 6. Prime q: INT
   //------------------------------------------------------------------------
   // L2 INTEGER: Prime q
   // DataIndex: 5
   (unsigned char) (X_MIDDLE | DATA_INDEX | ZERO_LEAD_FLAG),
   (unsigned char) (ASN1_UNIVERSAL_INTEGER),
   (unsigned char) PKCS1_PRIVKEY_PRIME_Q_INDEX,
   (unsigned char) 0x00,
   //------------------------------------------------------------------------
   // 7. Exponent d mod(p-1): INT
   //------------------------------------------------------------------------
   // L2 INTEGER: Exp1 d mod(p-1)
   // DataIndex: 6
   (unsigned char) (X_MIDDLE | DATA_INDEX | ZERO_LEAD_FLAG),
   (unsigned char) (ASN1_UNIVERSAL_INTEGER),
   (unsigned char) PKCS1_PRIVKEY_DMOD_PM1_INDEX,
   (unsigned char) 0x00,
   //------------------------------------------------------------------------
   // 8. Exponent d mod(q-1): INT
   //------------------------------------------------------------------------
   // L2 INTEGER: Exp2 d mod(q-1)
   // DataIndex: 7
   (unsigned char) (X_MIDDLE | DATA_INDEX | ZERO_LEAD_FLAG),
   (unsigned char) (ASN1_UNIVERSAL_INTEGER),
   (unsigned char) PKCS1_PRIVKEY_DMOD_QM1_INDEX,
   (unsigned char) 0x00,
   //------------------------------------------------------------------------
   // 9. Coefficient q**-1 mod(p): INT
   //------------------------------------------------------------------------
   // L2 INTEGER: Coeff q**-1 mod(p)
   // DataIndex: 8
   (unsigned char) (X_LAST | DATA_INDEX | ZERO_LEAD_FLAG),
   (unsigned char) (ASN1_UNIVERSAL_INTEGER),
   (unsigned char) PKCS1_PRIVKEY_INVQ_MODP_INDEX,
   (unsigned char) 0x00,
};

//()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()
//
// PKCS7 Control structures
//
//()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()

//================================================================
// PKCS7 DigestInfo Split/Combine Control Structure:
// from/to PKCS7 DigestInfo <-> DigestAlgorID, DigestAlgorParams, Digest
// Used for PFX ESPVK processing
//================================================================
extern "C"  unsigned char PKCS7DigestInfoCtl[PKCS7_DIGESTINFO_CTL_SIZE]={

   // L1 SEQ: DigestInfo
   (unsigned char) (X_FIRST | CONSTRUCT),
   (unsigned char) (ASN1_UNIVERSAL_SEQUENCE | ASN1_CONSTRUCTED),
   (unsigned char) 0x00,
   (unsigned char) 0x00,

   //------------------------------------------------------------------
   // 1. DigestAlgor: SEQUENCE
   //------------------------------------------------------------------
   // L2 SEQ: DigestAlgor
   (unsigned char) (X_FIRST | CONSTRUCT),
   (unsigned char) (ASN1_UNIVERSAL_SEQUENCE | ASN1_CONSTRUCTED),
   (unsigned char) 0x00,
   (unsigned char) 0x00,
   //------------------------------------------------------------------
   // 1.1. DigestAlgorID: OID
   //------------------------------------------------------------------
   // L3 OID: DigestAlgorID
   // DataIndex: 0
   (unsigned char) (X_FIRST | DATA_INDEX),
   (unsigned char) (ASN1_UNIVERSAL_OBJECT_ID),
   (unsigned char) PKCS7_DIGESTINFO_ALGID_INDEX,
   (unsigned char) 0x00,
   //------------------------------------------------------------------
   // 1.2. DigestAlgorParams: ANY
   //------------------------------------------------------------------
   // L3 ANY: DigestAlgor Params
   // DataIndex: 1
   (unsigned char) (X_LAST | DATA_INDEX | ANY_ASN1 | OPTIONAL),
   (unsigned char) (ASN1_UNIVERSAL_EOC),
   (unsigned char) PKCS7_DIGESTINFO_ALGPAR_INDEX,
   (unsigned char) 0x00,
   //------------------------------------------------------------------
   // 2. DigestData: OCTETSTR
   //------------------------------------------------------------------
   // L2 OCTETSTR: Digest Data
   // DataIndex: 2
   (unsigned char) (X_LAST | DATA_INDEX),
   (unsigned char) (ASN1_UNIVERSAL_OCTETSTRING),
   (unsigned char) PKCS7_DIGESTINFO_DATA_INDEX,
   (unsigned char) 0x00,
};

//================================================================
// PKCS7 Content Info Split/Combine Control Structure:
// from/to PKCS7 Content <-> Content Type OID, ContentData
// Used for PKCS12 wrapping/unwrapping
//================================================================
extern "C"  unsigned char PKCS7ContInfoCtl[PKCS7_CONTINFO_CTL_SIZE]={

   // L1 SEQ: ContentInfo
   (unsigned char) (X_ONLY | CONSTRUCT),
   (unsigned char) (ASN1_UNIVERSAL_SEQUENCE | ASN1_CONSTRUCTED),
   (unsigned char) 0x00,
   (unsigned char) 0x00,
   // L2 OID: ContentType
   // DataIndex: 0
   (unsigned char) (X_FIRST | DATA_INDEX),
   (unsigned char) (ASN1_UNIVERSAL_OBJECT_ID),
   (unsigned char) PKCS7_CONTINFO_TYPE_INDEX,
   (unsigned char) 0x00,
   // L2 ETAG[0]: content
   (unsigned char) (X_LAST | CONSTRUCT | OPTIONAL),
   (unsigned char)	(ASN1_CLASS_CONTEXT_SPECIFIC | ASN1_CONSTRUCTED | 0x00),
   (unsigned char) 0x00,
   (unsigned char) 0x00,
   // L3: PKCS-7 Contents
   // DataIndex: 1
   (unsigned char) (X_ONLY | DATA_INDEX | ANY_ASN1),
   (unsigned char) (ASN1_UNIVERSAL_EOC),
   (unsigned char) PKCS7_CONTINFO_DATA_INDEX,
   (unsigned char) 0x00,

};

//=========================================================================
// PKCS7 EncryptedData Content Type (ID=6) Split/Combine Control Structure:
// from/to PKCS7 DigestedData Content <-> Version, EncryptedContentInfo
// Used for PKCS12 password encrypted Content
//
//=========================================================================
extern "C"  unsigned char PKCS7ContEncDataCtl[PKCS7_CONT_ENCDATA_CTL_SIZE]={

   // L1 SEQ: EncryptedData
   (unsigned char) (X_ONLY | CONSTRUCT),
   (unsigned char) (ASN1_UNIVERSAL_SEQUENCE | ASN1_CONSTRUCTED),
   (unsigned char) 0x00,
   (unsigned char) 0x00,
   // L2 INT: Version (== 0)
   // DataIndex: 0
   (unsigned char) (X_FIRST | DATA_INDEX),
   (unsigned char) (ASN1_UNIVERSAL_INTEGER),
   (unsigned char) PKCS7_ENCDATA_VERSION_INDEX,
   (unsigned char) 0x00,

   // L2 SEQ: EncryptedContInfo
   (unsigned char) (X_LAST | CONSTRUCT),
   (unsigned char) (ASN1_UNIVERSAL_SEQUENCE | ASN1_CONSTRUCTED),
   (unsigned char) 0x00,
   (unsigned char) 0x00,
   // L3 OID: ContentType
   // DataIndex: 1
   (unsigned char) (X_FIRST | DATA_INDEX),
   (unsigned char) (ASN1_UNIVERSAL_OBJECT_ID),
   (unsigned char) PKCS7_ENCDATA_TYPE_INDEX,
   (unsigned char) 0x00,
   // L3 SEQ: ContentEncAlgor
   (unsigned char) (X_MIDDLE | CONSTRUCT),
   (unsigned char) (ASN1_UNIVERSAL_SEQUENCE | ASN1_CONSTRUCTED),
   (unsigned char) 0x00,
   (unsigned char) 0x00,
   // L4 OBJID: Enc AlgorID
   // DataIndex: 2
   (unsigned char) (X_FIRST | DATA_INDEX),
   (unsigned char) (ASN1_UNIVERSAL_OBJECT_ID),
   (unsigned char) PKCS7_ENCDATA_ENCALG_ID_INDEX,
   (unsigned char) 0x00,
   // L4 ANY: Enc Algor Params
   // DataIndex: 3
   (unsigned char) (X_LAST | DATA_INDEX | ANY_ASN1 | OPTIONAL),
   (unsigned char) (ASN1_UNIVERSAL_EOC),
   (unsigned char) PKCS7_ENCDATA_ENCALG_PAR_INDEX,
   (unsigned char) 0x00,
   // L3 ETAG[0]: EncryptedContent
   // DataIndex: 5 (Constructed!)
   (unsigned char) (X_MIDDLE | DATA_INDEX | OPTIONAL),
   (unsigned char)	(ASN1_CLASS_CONTEXT_SPECIFIC | ASN1_CONSTRUCTED | 0x00),
   (unsigned char) PKCS7_ENCDATA_ENCDATA_CON_INDEX,
   (unsigned char) 0x00,
   // L3 ITAG[0]: EncryptedContent
   // DataIndex: 4
   (unsigned char) (X_LAST | DATA_INDEX | OPTIONAL),
   (unsigned char)	(ASN1_CLASS_CONTEXT_SPECIFIC | 0x00),
   (unsigned char) PKCS7_ENCDATA_ENCDATA_INDEX,
   (unsigned char) 0x00,
};

//()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()
//
// PKCS8 Control structures
//
//()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()

//================================================================
// PKCS8 PrivateKeyInfo Split/Combine Control Structure:
// from/to PKCS8 PrivateKeyInfo <-> Version, Private Key Algorithm,
// Private Key, Attributes
// Is used for:
// - PKCS12 V1 Decrypted ESPVKCipherText aka. pkcs8KeyShrouding
// - PKCS12 V3 Plain KeyBag
// - PKCS12 V3 Decrypted PKCS8ShroudedKeyBag
//
//----------------------------------------------------------------
extern "C"  unsigned char PKCS8PrivKeyInfoCtl[PKCS8_PRIVKEYINFO_CTL_SIZE]={

   // L1 SEQ: PrivKeyInfo(PKCS8)
   (unsigned char) (X_ONLY | CONSTRUCT),
   (unsigned char) (ASN1_UNIVERSAL_SEQUENCE | ASN1_CONSTRUCTED),
   (unsigned char) 0x00,
   (unsigned char) 0x00,
   //------------------------------------------------------------------------
   // PKCS8 Private Key Info, NOTE: partial already in HASN1 (no Attributes!)
   //------------------------------------------------------------------------
   // L2 INTEGER: Version (0)
   // DataIndex: 0
   (unsigned char) (X_FIRST | DATA_INDEX),
   (unsigned char) (ASN1_UNIVERSAL_INTEGER),
   (unsigned char) PKCS8_PRIVKEYINFO_VERSION_INDEX,
   (unsigned char) 0x00,

   // L2 SEQ: PrivKeyAlgor
   (unsigned char) (X_MIDDLE | CONSTRUCT),
   (unsigned char) (ASN1_UNIVERSAL_SEQUENCE | ASN1_CONSTRUCTED),
   (unsigned char) 0x00,
   (unsigned char) 0x00,
   // L3 OID: PrivKeyAlgor ID
   // DataIndex: 1
   (unsigned char) (X_FIRST | DATA_INDEX),
   (unsigned char) (ASN1_UNIVERSAL_OBJECT_ID),
   (unsigned char) PKCS8_PRIVKEYINFO_ALGID_INDEX,
   (unsigned char) 0x00,
   // L3 ANY: PrivKeyAlgor Params
   // DataIndex: 2
   (unsigned char) (X_LAST | DATA_INDEX | ANY_ASN1 | OPTIONAL),
   (unsigned char) (ASN1_UNIVERSAL_EOC),
   (unsigned char) PKCS8_PRIVKEYINFO_ALGPAR_INDEX,
   (unsigned char) 0x00,

   // L2 OCTETSTR: PrivKey
   // DataIndex: 3
   (unsigned char) (X_MIDDLE | DATA_INDEX),
   (unsigned char) (ASN1_UNIVERSAL_OCTETSTRING),
   (unsigned char) PKCS8_PRIVKEYINFO_PRIVDAT_INDEX,
   (unsigned char) 0x00,

   // L2 ITAG[0]: AttributeSet
   // DataIndex: 4
   (unsigned char) (X_LAST | DATA_INDEX | OPTIONAL),
   (unsigned char)	(ASN1_CLASS_CONTEXT_SPECIFIC | ASN1_CONSTRUCTED | 0x00),
   (unsigned char) PKCS8_PRIVKEYINFO_ATTSSET_INDEX,
   (unsigned char) 0x00,
};

//()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()
//
// PKCS12 V3 Structures
//
//()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()

//----------------------------------------------------------------
// PKCS12 PFX Split/Combine Control Structure:
// from/to PKCS12 PFX PDU <-> Version, ContentInfo, MacData
// Note: Content Info and MacData are Preprocessed and split deeper !
// -----
//
//----------------------------------------------------------------
extern "C"  unsigned char PKCS12PfxPDUCtl[PKCS12_PFX_PDU_CTL_SIZE]={

   // L1 SEQ: PFX PDU
   (unsigned char) (X_ONLY | CONSTRUCT),
   (unsigned char) (ASN1_UNIVERSAL_SEQUENCE | ASN1_CONSTRUCTED),
   (unsigned char) 0x00,
   (unsigned char) 0x00,
   //------------------------------------------------------------------
   // 1. Version, Integer, V = 3
   //------------------------------------------------------------------
   // L2 INTEGER: Version (3)
   // DataIndex: 0
   (unsigned char) (X_FIRST | DATA_INDEX),
   (unsigned char) (ASN1_UNIVERSAL_INTEGER),
   (unsigned char) PKCS12_PFX_PDU_VERSION_INDEX,
   (unsigned char) 0x00,
   //------------------------------------------------------------------
   // 2. (PKCS-7) authSafe ContentInfo
   //------------------------------------------------------------------
   // L2 SEQ: ContentInfo
   (unsigned char) (X_MIDDLE | CONSTRUCT),
   (unsigned char) (ASN1_UNIVERSAL_SEQUENCE | ASN1_CONSTRUCTED),
   (unsigned char) 0x00,
   (unsigned char) 0x00,
   //------------------------------------------------------------------
   // 2.1. Content Info Encoding
   //------------------------------------------------------------------
   // L3: OID: ContentType
   // DataIndex: 1
   (unsigned char) (X_FIRST | DATA_INDEX),
   (unsigned char) (ASN1_UNIVERSAL_OBJECT_ID),
   (unsigned char) PKCS12_PFX_PDU_CONTTYPE_INDEX,
   (unsigned char) 0x00,
   // L3: ETAG[0]: Content
   (unsigned char) (X_LAST | CONSTRUCT),
   (unsigned char)	(ASN1_CLASS_CONTEXT_SPECIFIC | ASN1_CONSTRUCTED | 0x00),
   (unsigned char) 0x00,
   (unsigned char) 0x00,

   // L4: PKCS-7 Contents
   // DataIndex: 2
   (unsigned char) (X_ONLY | DATA_INDEX | ANY_ASN1),
   (unsigned char) (ASN1_UNIVERSAL_EOC),
   (unsigned char) PKCS12_PFX_PDU_CONTDATA_INDEX,
   (unsigned char) 0x00,
   //------------------------------------------------------------------
   // 3.  MacData, Sequence, optional
   //------------------------------------------------------------------
   // L2 SEQ: MacData/DigestInfo
   (unsigned char) (X_LAST | CONSTRUCT | OPTIONAL),
   (unsigned char) (ASN1_UNIVERSAL_SEQUENCE | ASN1_CONSTRUCTED),
   (unsigned char) 0x00,
   (unsigned char) 0x00,

   //------------------------------------------------------------------
   // 3.1. Mac Digest Description / Value
   //------------------------------------------------------------------
   // L3 SEQ: Mac DigestInfo
   (unsigned char) (X_FIRST | CONSTRUCT),
   (unsigned char) (ASN1_UNIVERSAL_SEQUENCE | ASN1_CONSTRUCTED),
   (unsigned char) 0x00,
   (unsigned char) 0x00,
   // L4 SEQ: Mac DigestAlgor
   (unsigned char) (X_FIRST | CONSTRUCT),
   (unsigned char) (ASN1_UNIVERSAL_SEQUENCE | ASN1_CONSTRUCTED),
   (unsigned char) 0x00,
   (unsigned char) 0x00,
   // L5 OID: Mac DigestAlgor ID
   // DataIndex: 3
   (unsigned char) (X_FIRST | DATA_INDEX),
   (unsigned char) (ASN1_UNIVERSAL_OBJECT_ID),
   (unsigned char) PKCS12_PFX_PDU_MAC_ALGID_INDEX,
   (unsigned char) 0x00,
   // L5 ANY: Mac DigestAlgor Params
   // DataIndex: 4
   (unsigned char) (X_LAST | DATA_INDEX | ANY_ASN1 | OPTIONAL),
   (unsigned char) (ASN1_UNIVERSAL_EOC),
   (unsigned char) PKCS12_PFX_PDU_MAC_ALGPAR_INDEX,
   (unsigned char) 0x00,
   // L4 OCTETSTR: Mac Digest
   // DataIndex: 5
   (unsigned char) (X_LAST | DATA_INDEX),
   (unsigned char) (ASN1_UNIVERSAL_OCTETSTRING),
   (unsigned char) PKCS12_PFX_PDU_MAC_DIGEST_INDEX,
   (unsigned char) 0x00,
   // L3 OCTETSTR: MacSalt
   // DataIndex: 6
   (unsigned char) (X_MIDDLE | DATA_INDEX),
   (unsigned char) (ASN1_UNIVERSAL_OCTETSTRING),
   (unsigned char) PKCS12_PFX_PDU_MAC_SALT_INDEX,
   (unsigned char) 0x00,
   // L3 INTEGER: MacIterations
   // DataIndex: 7, Default=1
   (unsigned char) (X_LAST | DATA_INDEX | OPTIONAL),
   (unsigned char) (ASN1_UNIVERSAL_INTEGER),
   (unsigned char) PKCS12_PFX_PDU_MAC_ITERAT_INDEX,
   (unsigned char) 0x00,
};

//================================================================
// PKCS12 SafeBag Split/Combine Control Structure:
// from/to PKCS12 SafeBag <-> BagID, BagValue, BagAttributes
//
//================================================================
extern "C"  unsigned char PKCS12SafeBagCtl[PKCS12_SAFEBAG_CTL_SIZE]={

   // L1 SEQ: SafeBag
   (unsigned char) (X_ONLY | CONSTRUCT),
   (unsigned char) (ASN1_UNIVERSAL_SEQUENCE | ASN1_CONSTRUCTED),
   (unsigned char) 0x00,
   (unsigned char) 0x00,
   // L2 OID: BagID
   // DataIndex: 0
   (unsigned char) (X_FIRST | DATA_INDEX),
   (unsigned char) (ASN1_UNIVERSAL_OBJECT_ID),
   (unsigned char) PKCS12_SAFEBAG_ID_VALUE_INDEX,
   (unsigned char) 0x00,

   // L2 ETAG[0]: BagValue
   (unsigned char) (X_MIDDLE | CONSTRUCT),
   (unsigned char)	(ASN1_CLASS_CONTEXT_SPECIFIC | ASN1_CONSTRUCTED | 0x00),
   (unsigned char) 0x00,
   (unsigned char) 0x00,
   // L3 ANY: BagValue itself
   // DataIndex: 1
   (unsigned char) (X_ONLY | DATA_INDEX | ANY_ASN1),
   (unsigned char) (ASN1_UNIVERSAL_EOC),
   (unsigned char) PKCS12_SAFEBAG_VALUE_INDEX,
   (unsigned char) 0x00,
   // L2 SET: BagAttributes
   // DataIndex: 2
   (unsigned char) (X_LAST | DATA_INDEX | OPTIONAL),
   (unsigned char) (ASN1_UNIVERSAL_SET | ASN1_CONSTRUCTED),
   (unsigned char) PKCS12_SAFEBAG_NAME_ATTS_INDEX,
   (unsigned char) 0x00,
};

//----------------------------------------------------------------
// PKCS12 PKCS8ShroudedKeyBag (ID=2) Split/Combine Control Structure:
// from/to PKCS12 PKCS8ShroudedKeyBag <-> EncryptedPrivateKeyInfo that
// consists of:
// Encryption Algorithm, Encrypted Data
//
//----------------------------------------------------------------
extern "C"  unsigned char PKCS12ShroudedKeyBagCtl[PKCS12_SHROUDED_KEYBAG_CTL_SIZE]={

   // L1 SEQ: EncPrivKeyInfo(PKCS8)
   (unsigned char) (X_ONLY | CONSTRUCT),
   (unsigned char) (ASN1_UNIVERSAL_SEQUENCE | ASN1_CONSTRUCTED),
   (unsigned char) 0x00,
   (unsigned char) 0x00,
   //------------------------------------------------------------------------
   // PKCS8 Encrypted Private Key Info
   //------------------------------------------------------------------------
   // L2 SEQ: EncryptionAlgor
   (unsigned char) (X_FIRST | CONSTRUCT),
   (unsigned char) (ASN1_UNIVERSAL_SEQUENCE | ASN1_CONSTRUCTED),
   (unsigned char) 0x00,
   (unsigned char) 0x00,
   // L3 OID: EncAlgor ID
   // DataIndex: 0
   (unsigned char) (X_FIRST | DATA_INDEX),
   (unsigned char) (ASN1_UNIVERSAL_OBJECT_ID),
   (unsigned char) PKCS12_SHRBAG_ENCALG_ID_INDEX,
   (unsigned char) 0x00,
   // L3 ANY: EncAlgor Params
   // DataIndex: 1
   (unsigned char) (X_LAST | DATA_INDEX | ANY_ASN1 | OPTIONAL),
   (unsigned char) (ASN1_UNIVERSAL_EOC),
   (unsigned char) PKCS12_SHRBAG_ENCALG_PAR_INDEX,
   (unsigned char) 0x00,

   // L2 OCTETSTR: EncryptedData
   // DataIndex: 2
   (unsigned char) (X_LAST | DATA_INDEX),
   (unsigned char) (ASN1_UNIVERSAL_OCTETSTRING),
   (unsigned char) PKCS12_SHRBAG_ENC_DATA_INDEX,
   (unsigned char) 0x00,
};

//================================================================
// PKCS12 CertBag (ID=3) Split/Combine Control Structure:
// from/to PKCS12 CertBag <-> CertType, CertValue
//
//================================================================
extern "C"  unsigned char PKCS12CertBagCtl[PKCS12_CERTBAG_CTL_SIZE]={

   // L1 SEQ: CertBag
   (unsigned char) (X_ONLY | CONSTRUCT),
   (unsigned char) (ASN1_UNIVERSAL_SEQUENCE | ASN1_CONSTRUCTED),
   (unsigned char) 0x00,
   (unsigned char) 0x00,
   // L2 OID: CertId (Type)
   // DataIndex: 0
   (unsigned char) (X_FIRST | DATA_INDEX),
   (unsigned char) (ASN1_UNIVERSAL_OBJECT_ID),
   (unsigned char) PKCS12_CERTBAG_CERT_ID_INDEX,
   (unsigned char) 0x00,

   // L2 ETAG[0]: CertValue
   (unsigned char) (X_LAST | CONSTRUCT),
   (unsigned char)	(ASN1_CLASS_CONTEXT_SPECIFIC | ASN1_CONSTRUCTED | 0x00),
   (unsigned char) 0x00,
   (unsigned char) 0x00,
   // L3 ANY: Certificate
   // DataIndex: 1
   (unsigned char) (X_ONLY | DATA_INDEX | ANY_ASN1),
   (unsigned char) (ASN1_UNIVERSAL_EOC),
   (unsigned char) PKCS12_CERTBAG_VALUE_INDEX,
   (unsigned char) 0x00,
};

//================================================================
// PKCS12 PBE Parameters Split/Combine Control Structure:
// from/to PKCS12 PBE Parameters <-> Salt, IterationCount
//================================================================
extern "C"  unsigned char PKCS12PbeParamsCtl[PKCS12_PBE_PARAMS_CTL_SIZE]={

   // L1 SEQ: PBE AlgorParams
   (unsigned char) (X_ONLY | CONSTRUCT),
   (unsigned char) (ASN1_UNIVERSAL_SEQUENCE | ASN1_CONSTRUCTED),
   (unsigned char) 0x00,
   (unsigned char) 0x00,
   // L2 OCTETSTR: salt
   // DataIndex: 0
   (unsigned char) (X_MIDDLE | DATA_INDEX),
   (unsigned char) (ASN1_UNIVERSAL_OCTETSTRING),
   (unsigned char) PKCS12_PBE_PARAMS_SALT_INDEX,
   (unsigned char) 0x00,
   // L2 INT: iterations
   // DataIndex: 1
   (unsigned char) (X_LAST | DATA_INDEX),
   (unsigned char) (ASN1_UNIVERSAL_INTEGER),
   (unsigned char) PKCS12_PBE_PARAMS_ITERAT_INDEX,
   (unsigned char) 0x00,
};

//()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()
//
// PKCS12 V1 (0.22) aka. PFX Structures
//
//()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()

//================================================================
// PKCS12 V1 PFX Split/Combine Control Structure:
// from/to PKCS12 V1 PFX PDU <->  MacData, MacSalt, authSafe ContentInfo
// Note: MacData and Content Info are Preprocessed and split deeper !
// -----
//
//================================================================
extern "C"  unsigned char PFX_PfxPDUCtl[PFX_PFX_PDU_CTL_SIZE]={

   // L1 SEQ: PFX PDU
   (unsigned char) (X_ONLY | CONSTRUCT),
   (unsigned char) (ASN1_UNIVERSAL_SEQUENCE | ASN1_CONSTRUCTED),
   (unsigned char) 0x00,
   (unsigned char) 0x00,
   //------------------------------------------------------------------
   // 1.  MacData, ETAG[0], optional
   //------------------------------------------------------------------
   // L2 ETAG[0]: MacData
   (unsigned char) (X_FIRST | CONSTRUCT | OPTIONAL),
   (unsigned char)	(ASN1_CLASS_CONTEXT_SPECIFIC | ASN1_CONSTRUCTED | 0x00),
   (unsigned char) 0x00,
   (unsigned char) 0x00,
   //------------------------------------------------------------------
   // 1.1. SafeMac / DigestInfo
   //------------------------------------------------------------------
   // L2 SEQ: SafeMac/DigestInfo
   (unsigned char) (X_FIRST | CONSTRUCT),
   (unsigned char) (ASN1_UNIVERSAL_SEQUENCE | ASN1_CONSTRUCTED),
   (unsigned char) 0x00,
   (unsigned char) 0x00,

   //------------------------------------------------------------------
   // 1.1.1 SafeMac Digest Description / Value
   //------------------------------------------------------------------
   // L3 SEQ: SafeMac DigestAlgor
   (unsigned char) (X_FIRST | CONSTRUCT),
   (unsigned char) (ASN1_UNIVERSAL_SEQUENCE | ASN1_CONSTRUCTED),
   (unsigned char) 0x00,
   (unsigned char) 0x00,
   // L4 OID:SafeMac DigestAlgorID
   // DataIndex: 3
   (unsigned char) (X_FIRST | DATA_INDEX),
   (unsigned char) (ASN1_UNIVERSAL_OBJECT_ID),
   (unsigned char) PKCS12_PFX_PDU_MAC_ALGID_INDEX,
   (unsigned char) 0x00,
   // L4 ANY: SafeMac DigestAlgor Params
   // DataIndex: 4
   (unsigned char) (X_LAST | DATA_INDEX | ANY_ASN1 | OPTIONAL),
   (unsigned char) (ASN1_UNIVERSAL_EOC),
   (unsigned char) PKCS12_PFX_PDU_MAC_ALGPAR_INDEX,
   (unsigned char) 0x00,
   // L3 OCTETSTR: Mac Digest
   // DataIndex: 5
   (unsigned char) (X_LAST | DATA_INDEX),
   (unsigned char) (ASN1_UNIVERSAL_OCTETSTRING),
   (unsigned char) PKCS12_PFX_PDU_MAC_DIGEST_INDEX,
   (unsigned char) 0x00,
   //------------------------------------------------------------------
   // 1.1.2 macSalt
   //------------------------------------------------------------------
   // L2 BITSTR: MacSalt
   // DataIndex: 6
   (unsigned char) (X_LAST | DATA_INDEX | ZERO_LEAD_FLAG),
   (unsigned char) (ASN1_UNIVERSAL_BITSTRING),
   (unsigned char) PKCS12_PFX_PDU_MAC_SALT_INDEX,
   (unsigned char) 0x00,
   //------------------------------------------------------------------
   // 2. ETAG[1] authSafe ContentInfo
   // NOTE: also ETAG given, surrounding SEQ for ContentInfo is missing!
   //------------------------------------------------------------------
   // L2 ETAG[1]: authSafe
   (unsigned char) (X_LAST | CONSTRUCT),
   (unsigned char)	(ASN1_CLASS_CONTEXT_SPECIFIC | ASN1_CONSTRUCTED | 0x01),
   (unsigned char) 0x00,
   (unsigned char) 0x00,
   //------------------------------------------------------------------
   // 2.1. (PKCS-7) ContentInfo, WITHOUT SURROUNDING SEQ !!
   //------------------------------------------------------------------
   //------------------------------------------------------------------
   // 2.1.1. Content Info Encoding
   //------------------------------------------------------------------
   // L3: OID: ContentType
   // DataIndex: 1
   (unsigned char) (X_FIRST | DATA_INDEX),
   (unsigned char) (ASN1_UNIVERSAL_OBJECT_ID),
   (unsigned char) PKCS12_PFX_PDU_CONTTYPE_INDEX,
   (unsigned char) 0x00,
   // L3: ETAG[0]: Content
   (unsigned char) (X_LAST | CONSTRUCT),
   (unsigned char)	(ASN1_CLASS_CONTEXT_SPECIFIC | ASN1_CONSTRUCTED | 0x00),
   (unsigned char) 0x00,
   (unsigned char) 0x00,

   // L4: PKCS-7 Contents
   // DataIndex: 2
   (unsigned char) (X_ONLY | DATA_INDEX | ANY_ASN1),
   (unsigned char) (ASN1_UNIVERSAL_EOC),
   (unsigned char) PKCS12_PFX_PDU_CONTDATA_INDEX,
   (unsigned char) 0x00,
};

//================================================================
// PKCS12 V1 AuthenticatedSafe Split/Combine Control Structure:
// from/to PKCS12 V1 AuthenticatedSafe <-> Version, TransportMode,
// privacySalt, Baggage, safe ContentInfo
// 
//
//================================================================
extern "C"  unsigned char PFXAuthSafeCtl[PFX_AUTHSAFE_CTL_SIZE]={

   // L1 SEQ: AuthenticatedSafe
   (unsigned char) (X_ONLY | CONSTRUCT),
   (unsigned char) (ASN1_UNIVERSAL_SEQUENCE | ASN1_CONSTRUCTED),
   (unsigned char) 0x00,
   (unsigned char) 0x00,
   //------------------------------------------------------------------
   // 1. INTEGER: Version, DEFAULT 1
   //------------------------------------------------------------------
   // L2 INT: Version, DEFAULT 1
   // DataIndex: 0
   (unsigned char) (X_FIRST | DATA_INDEX | OPTIONAL),
   (unsigned char) (ASN1_UNIVERSAL_INTEGER),
   (unsigned char) PFX_AUTHSAFE_VERSION_INDEX,
   (unsigned char) 0x00,
   //------------------------------------------------------------------
   // 2. OID: TransportMode, DEFAULT off-lineTransportMode
   //------------------------------------------------------------------
   // L2 OID: TransportMode, OPT.
   // DataIndex: 1
   (unsigned char) (X_MIDDLE | DATA_INDEX | OPTIONAL),
   (unsigned char) (ASN1_UNIVERSAL_OBJECT_ID),
   (unsigned char) PFX_AUTHSAFE_TRANSP_MODE_INDEX,
   (unsigned char) 0x00,
   //------------------------------------------------------------------
   // 3. BITSTR: PrivacySalt, OPTIONAL
   //------------------------------------------------------------------
   // L2 BITSTR: privacySalt, OPT.
   // DataIndex: 2
   (unsigned char) (X_MIDDLE | DATA_INDEX | ZERO_LEAD_FLAG | OPTIONAL),
   (unsigned char) (ASN1_UNIVERSAL_BITSTRING),
   (unsigned char) PFX_AUTHSAFE_PRIVSALT_INDEX,
   (unsigned char) 0x00,
   //------------------------------------------------------------------
   // 4. SET: Baggage, OPTIONAL
   //------------------------------------------------------------------
   // L2 SET: Baggage, ANY
   // DataIndex: 3
   (unsigned char) (X_MIDDLE | DATA_INDEX | ANY_ASN1 | OPTIONAL),
   (unsigned char)	(ASN1_UNIVERSAL_SET | ASN1_CONSTRUCTED),
   (unsigned char) PFX_AUTHSAFE_BAGGAGE_SET_IND,
   (unsigned char) 0x00,
   //------------------------------------------------------------------
   // 5. SEQ: safe ContentInfo
   //------------------------------------------------------------------
   // L2 SEQ: safe ContentInfo
   (unsigned char) (X_LAST | CONSTRUCT),
   (unsigned char)	(ASN1_UNIVERSAL_SEQUENCE | ASN1_CONSTRUCTED),
   (unsigned char) 0x00,
   (unsigned char) 0x00,
   //------------------------------------------------------------------
   // 5.1.1. safe Content Info Encoding
   //------------------------------------------------------------------
   // L3: OID: ContentType
   // DataIndex: 4
   (unsigned char) (X_FIRST | DATA_INDEX),
   (unsigned char) (ASN1_UNIVERSAL_OBJECT_ID),
   (unsigned char) PFX_AUTHSAFE_CONTTYPE_INDEX,
   (unsigned char) 0x00,
   // L3: ETAG[0]: Content
   (unsigned char) (X_LAST | CONSTRUCT),
   (unsigned char)	(ASN1_CLASS_CONTEXT_SPECIFIC | ASN1_CONSTRUCTED | 0x00),
   (unsigned char) 0x00,
   (unsigned char) 0x00,

   // L4: PKCS-7 Contents
   // DataIndex: 5
   (unsigned char) (X_ONLY | DATA_INDEX | ANY_ASN1),
   (unsigned char) (ASN1_UNIVERSAL_EOC),
   (unsigned char) PFX_AUTHSAFE_CONTDATA_INDEX,
   (unsigned char) 0x00,
};
//================================================================
// PKCS12 V1 Baggage Split/Combine Control Structure:
// from/to PKCS12 V1 Baggage SET <-> BaggageItems
//
//================================================================
extern "C"  unsigned char PFXBaggageCtl[PFX_BAGGAGE_CTL_SIZE]={

   // L1 SET: BaggageItems
   // DataIndex: 0
   (unsigned char) (X_ONLY | DATA_INDEX | ANY_ASN1),
   (unsigned char) (ASN1_UNIVERSAL_SET | ASN1_CONSTRUCTED),
   (unsigned char) PFX_BAGGAGE_DATA_INDEX,
   (unsigned char) 0x00,
};

//================================================================
// PKCS12 V1 BaggageItem Split/Combine Control Structure:
// from/to PKCS12 V1 BaggageItem <-> espvkSet, unencryptedSecretsSet
//
//================================================================
extern "C"  unsigned char PFXBaggageItemCtl[PFX_BAGGAGE_ITEM_CTL_SIZE]={

   // L1 SEQ: BaggageItem
   (unsigned char) (X_ONLY | CONSTRUCT),
   (unsigned char) (ASN1_UNIVERSAL_SEQUENCE | ASN1_CONSTRUCTED),
   (unsigned char) 0x00,
   (unsigned char) 0x00,
   //------------------------------------------------------------------
   // 1. SET: espvks, may not be empty !
   //------------------------------------------------------------------
   // L2 SET: espvks
   // DataIndex: 0
   (unsigned char) (X_FIRST | DATA_INDEX | ANY_ASN1),
   (unsigned char)	(ASN1_UNIVERSAL_SET | ASN1_CONSTRUCTED),
   (unsigned char) PFX_BAGGAGEITEM_ESPVKS_INDEX,
   (unsigned char) 0x00,
   //------------------------------------------------------------------
   // 2. SET OF: unencryptedSecrets, may be empty
   //------------------------------------------------------------------
   // L2 SET: unencryptedSecrets
   // DataIndex: 1
   (unsigned char) (X_LAST | DATA_INDEX | ANY_ASN1),
   (unsigned char)	(ASN1_UNIVERSAL_SET | ASN1_CONSTRUCTED),
   (unsigned char) PFX_BAGGAGEITEM_UNENC_SECR_IND,
   (unsigned char) 0x00,
};

//================================================================
// PKCS12 V1 ESPVK Split/Combine Control Structure:
// from/to PKCS12 V1 ESPVK <-> espvkOID, espvkData, espvkCipherText
// espvkData is subdecoded (PVKSupportingData), also
// espvkCipherText is split according to PKCS-8 EncryptedPrivateKeyInfo
//
//================================================================
extern "C"  unsigned char PFXEspvkCtl[PFX_ESPVK_CTL_SIZE]={

   // L1 SEQ: Espvk
   (unsigned char) (X_ONLY | CONSTRUCT),
   (unsigned char) (ASN1_UNIVERSAL_SEQUENCE | ASN1_CONSTRUCTED),
   (unsigned char) 0x00,
   (unsigned char) 0x00,
   //------------------------------------------------------------------
   // 1. espvkOID : OID
   //------------------------------------------------------------------
   // L2 OID: espvkOID
   // Dataindex: 0
   (unsigned char) (X_FIRST | DATA_INDEX),
   (unsigned char)	(ASN1_UNIVERSAL_OBJECT_ID),
   (unsigned char) PFX_ESPVK_OID_INDEX,
   (unsigned char) 0x00,
   //------------------------------------------------------------------
   // 2. espvkData : SEQ PVKSupportingData
   //------------------------------------------------------------------
   // L2 SEQ: espvkData
   (unsigned char) (X_MIDDLE | CONSTRUCT),
   (unsigned char)	(ASN1_UNIVERSAL_SEQUENCE | ASN1_CONSTRUCTED),
   (unsigned char) 0x00,
   (unsigned char) 0x00,
   //------------------------------------------------------------------
   // 2.1. assocCerts: SET OF Thumbprint, may be empty
   //------------------------------------------------------------------
   // L3 SET OF: Thumbprint
   // Dataindex: 1
   (unsigned char) (X_FIRST | DATA_INDEX),
   (unsigned char)	(ASN1_UNIVERSAL_SET | ASN1_CONSTRUCTED),
   (unsigned char) PFX_ESPVK_ASSOC_CERTS_INDEX,
   (unsigned char) 0x00,

   //------------------------------------------------------------------
   // 2.2. regenerable : BOOLEAN DEFAULT FALSE (Optional)
   //------------------------------------------------------------------
   // L3 BOOLEAN: regenerable
   // Dataindex: 2
   (unsigned char) (X_MIDDLE | DATA_INDEX | OPTIONAL),
   (unsigned char)	(ASN1_UNIVERSAL_BOOLEAN),
   (unsigned char) PFX_ESPVK_REGENERABLE_INDEX,
   (unsigned char) 0x00,
   //------------------------------------------------------------------
   // 2.3. nickName : BMPString
   //------------------------------------------------------------------
   // L3 BMPSTR: nickName
   // Dataindex: 3
   (unsigned char) (X_MIDDLE | DATA_INDEX),
   (unsigned char)	(ASN1_UNIVERSAL_BMPSTR),
   (unsigned char) PFX_ESPVK_NICKNAME_INDEX,
   (unsigned char) 0x00,

   //------------------------------------------------------------------
   // 2.4. pvkAdditional : SEQ OPTIONAL
   //------------------------------------------------------------------
   // L3 SEQ: pvkAdditional
   // Dataindex: 4
   (unsigned char) (X_LAST | DATA_INDEX | OPTIONAL),
   (unsigned char)	(ASN1_UNIVERSAL_SEQUENCE | ASN1_CONSTRUCTED),
   (unsigned char) PFX_ESPVK_PVKADDITIONAL_INDEX,
   (unsigned char) 0x00,

   //------------------------------------------------------------------
   // 3. espvkCipherText : ETAG[0] ANY
   //------------------------------------------------------------------
   // L2 ETAG[0]: espvkCipherText
   (unsigned char) (X_LAST | CONSTRUCT),
   (unsigned char)	(ASN1_CLASS_CONTEXT_SPECIFIC | ASN1_CONSTRUCTED | 0x00),
   (unsigned char) 0x00,
   (unsigned char) 0x00,
   //------------------------------------------------------------------
   // 3.1. espvkCipherTextContents: PKCS-8 EncryptedPrivateKeyInfo
   //------------------------------------------------------------------
   // L3 SEQ: EncryptedPrivateKeyInfo
   (unsigned char) (X_ONLY | CONSTRUCT),
   (unsigned char)	(ASN1_UNIVERSAL_SEQUENCE | ASN1_CONSTRUCTED),
   (unsigned char) 0x00,
   (unsigned char) 0x00,
   //------------------------------------------------------------------
   // 3.1.1. encryptionAlgorithm : SEQ
   //------------------------------------------------------------------
   // L4 SEQ: encryptionAlgor
   (unsigned char) (X_FIRST | CONSTRUCT),
   (unsigned char)	(ASN1_UNIVERSAL_SEQUENCE | ASN1_CONSTRUCTED),
   (unsigned char) 0x00,
   (unsigned char) 0x00,
   //------------------------------------------------------------------
   // 3.1.1.1 encryptionAlgorithmID : OID
   //------------------------------------------------------------------
   // L5 OID: encAlgorID
   // Dataindex: 5
   (unsigned char) (X_FIRST | DATA_INDEX),
   (unsigned char)	(ASN1_UNIVERSAL_OBJECT_ID),
   (unsigned char) PFX_ESPVK_CIPHALG_ID_INDEX,
   (unsigned char) 0x00,
   //------------------------------------------------------------------
   // 3.1.1.2 encryptionAlgorithmParams : PbeParams, from PKCS5
   //------------------------------------------------------------------
   // L5 SEQ: encAlgorParams
   (unsigned char) (X_LAST | CONSTRUCT),
   (unsigned char)	(ASN1_UNIVERSAL_SEQUENCE | ASN1_CONSTRUCTED),
   (unsigned char) 0x00,
   (unsigned char) 0x00,
   //------------------------------------------------------------------
   // 3.1.1.2.1 PbeParams.Salt
   //------------------------------------------------------------------
   // L6 OCTSTR: Salt
   // Dataindex: 6
   (unsigned char) (X_FIRST | DATA_INDEX),
   (unsigned char)	(ASN1_UNIVERSAL_OCTETSTRING),
   (unsigned char) PFX_ESPVK_SALT_DATA_INDEX,
   (unsigned char) 0x00,
   //------------------------------------------------------------------
   // 3.1.1.2.2 PbeParams.IterationCount
   //------------------------------------------------------------------
   // L6 INT: IterationCnt
   // Dataindex: 7
   (unsigned char) (X_LAST | DATA_INDEX),
   (unsigned char)	(ASN1_UNIVERSAL_INTEGER),
   (unsigned char) PFX_ESPVK_ITERAT_CNT_INDEX,
   (unsigned char) 0x00,

   //------------------------------------------------------------------
   // 3.1.2. EncryptedData : OCTETSTR
   //------------------------------------------------------------------
   // L4 OCTSTR: EncryptedData
   // Dataindex: 8
   (unsigned char) (X_LAST | DATA_INDEX),
   (unsigned char)	(ASN1_UNIVERSAL_OCTETSTRING),
   (unsigned char) PFX_ESPVK_ENC_DATA_INDEX,
   (unsigned char) 0x00,
};

//================================================================
// PKCS12 V1 SafeBag Split/Combine Control Structure:
// from/to PKCS12 V1 SafeBag <-> SafeBagType, SafeBagContent, SafeBagName
//
//================================================================
extern "C"  unsigned char PFXSafeBagCtl[PFX_SAFEBAG_CTL_SIZE]={

   // L1 SEQ: SafeBag
   (unsigned char) (X_ONLY | CONSTRUCT),
   (unsigned char) (ASN1_UNIVERSAL_SEQUENCE | ASN1_CONSTRUCTED),
   (unsigned char) 0x00,
   (unsigned char) 0x00,
   //------------------------------------------------------------------
   // 1. safeBagType : OID
   //------------------------------------------------------------------
   // L2 OID: safeBagTypeOID
   // Dataindex: 0
   (unsigned char) (X_FIRST | DATA_INDEX),
   (unsigned char)	(ASN1_UNIVERSAL_OBJECT_ID),
   (unsigned char) PKCS12_SAFEBAG_ID_VALUE_INDEX,
   (unsigned char) 0x00,
   //------------------------------------------------------------------
   // 2. safeBagContent : ANY
   //------------------------------------------------------------------
   // L2 ANY: SafeBagContent
   // DataIndex: 1
   (unsigned char) (X_MIDDLE | DATA_INDEX | ANY_ASN1),
   (unsigned char) (ASN1_UNIVERSAL_EOC),
   (unsigned char) PKCS12_SAFEBAG_VALUE_INDEX,
   (unsigned char) 0x00,

   //------------------------------------------------------------------
   // 2.2. safeBagName : BMPString OPTIONAL
   //------------------------------------------------------------------
   // L2 BMPSTR: safeBagName
   // Dataindex: 2
   (unsigned char) (X_LAST | DATA_INDEX | OPTIONAL),
   (unsigned char)	(ASN1_UNIVERSAL_BMPSTR),
   (unsigned char) PKCS12_SAFEBAG_NAME_ATTS_INDEX,
   (unsigned char) 0x00,
};

//=================================================================
// PKCS12 V1 CertCRL(Bag) Split/Combine Control Structure:
// from/to PKCS12 V1 CertCRL(Bag) <-> certCRLBagType, certCRLValue
// certCRLValue is subdecoded
//
//=================================================================
extern "C"  unsigned char PFXCertCRLBagCtl[PFX_CERTCRL_BAG_CTL_SIZE]={

   // L1 SEQ: certCRL(Bag)
   (unsigned char) (X_ONLY | CONSTRUCT),
   (unsigned char) (ASN1_UNIVERSAL_SEQUENCE | ASN1_CONSTRUCTED),
   (unsigned char) 0x00,
   (unsigned char) 0x00,
   //------------------------------------------------------------------
   // 1. certCRLBagType : OID
   //------------------------------------------------------------------
   // L2 OID: certCRLType
   // Dataindex: 0
   (unsigned char) (X_FIRST | DATA_INDEX),
   (unsigned char)	(ASN1_UNIVERSAL_OBJECT_ID),
   (unsigned char) PFX_CERTCRL_BAG_OID_INDEX,
   (unsigned char) 0x00,
   //------------------------------------------------------------------
   // 2. certCRLValue : ETAG[0]
   //------------------------------------------------------------------
   // L2 ETAG[0]: certCRLValue
   (unsigned char) (X_LAST | CONSTRUCT),
   (unsigned char)	(ASN1_CLASS_CONTEXT_SPECIFIC | ASN1_CONSTRUCTED | 0x00),
   (unsigned char) 0x00,
   (unsigned char) 0x00,
   //------------------------------------------------------------------
   // 2.1. certCRLValue : SEQUENCE ANY
   // NOTE: X509-Certs/CRLs are wrapped in a PKCS7 ContentInfo !!!
   // ----- SDSI-Certs are pure IA5STRINGs !
   //------------------------------------------------------------------
   // L2 SEQ: certCRLValue
   // Dataindex: 1
   (unsigned char) (X_LAST | DATA_INDEX),
   (unsigned char)	(ASN1_UNIVERSAL_SEQUENCE | ASN1_CONSTRUCTED),
   (unsigned char) PFX_CERTCRL_BAG_VALUE_INDEX,
   (unsigned char) 0x00,
};

//================================================================
// PKCS12 V1 X509CertCRL(Bag) Split/Combine Control Structure:
// from/to PKCS12 V1 X509CertCRL(Bag) <-> ContentInfo - signed data,
// Subdecodes the Content Info and the signed data
//
//================================================================
extern "C"  unsigned char PFX_X509CertCRLCtl[PFX_X509_CERTCRL_CTL_SIZE]={
   //------------------------------------------------------------------
   // 1. ContentInfo : SEQ
   //------------------------------------------------------------------
   // L1 SEQ: ContentInfo
   (unsigned char) (X_ONLY | CONSTRUCT),
   (unsigned char) (ASN1_UNIVERSAL_SEQUENCE | ASN1_CONSTRUCTED),
   (unsigned char) 0x00,
   (unsigned char) 0x00,
   //------------------------------------------------------------------
   // 1.1. ContentType : OID (PKCS7-signedData)
   //------------------------------------------------------------------
   // L2 OID: ContentType -SigData
   // Dataindex: 0
   (unsigned char) (X_FIRST | DATA_INDEX),
   (unsigned char)	(ASN1_UNIVERSAL_OBJECT_ID),
   (unsigned char) PFX_X509_CERTCRL_CONTTYPE_INDEX,
   (unsigned char) 0x00,
   //------------------------------------------------------------------
   // 1.2. ContentValue : ETAG[0]
   //------------------------------------------------------------------
   // L2 ETAG[0]: ContentValue
   (unsigned char) (X_LAST | CONSTRUCT | OPTIONAL),
   (unsigned char)	(ASN1_CLASS_CONTEXT_SPECIFIC | ASN1_CONSTRUCTED | 0x00),
   (unsigned char) 0x00,
   (unsigned char) 0x00,
   //------------------------------------------------------------------
   // 1.2.1 SignedData : SEQ
   //------------------------------------------------------------------
   // L3 SEQ: SignedData
   (unsigned char) (X_ONLY | CONSTRUCT),
   (unsigned char) (ASN1_UNIVERSAL_SEQUENCE | ASN1_CONSTRUCTED),
   (unsigned char) 0x00,
   (unsigned char) 0x00,
   //------------------------------------------------------------------------
   // 1.2.1.1. PKCS-7 SignedData.Version : INTEGER
   //------------------------------------------------------------------------
   // L4 INTEGER: Version (0)
   // DataIndex: 1
   (unsigned char) (X_FIRST | DATA_INDEX),
   (unsigned char) (ASN1_UNIVERSAL_INTEGER),
   (unsigned char) PFX_X509_CERTCRL_VERSION_INDEX,
   (unsigned char) 0x00,
   //------------------------------------------------------------------------
   // 1.2.1.2. PKCS-7 SignedData.DigestAlgorIds : SET OF
   //------------------------------------------------------------------------
   // L4 SET OF: AlgorIDs
   // DataIndex: 2
   (unsigned char) (X_MIDDLE | DATA_INDEX | ANY_ASN1),
   (unsigned char)	(ASN1_UNIVERSAL_SET | ASN1_CONSTRUCTED),
   (unsigned char) PFX_X509_CERTCRL_DIGESTALGS_IND,
   (unsigned char) 0x00,
   //------------------------------------------------------------------------
   // 1.2.1.3. PKCS-7 SignedData.ContentInfo : SEQ
   //------------------------------------------------------------------------
   // L4 SEQ: ContentInfo, ANY
   (unsigned char) (X_MIDDLE | CONSTRUCT),
   (unsigned char)	(ASN1_UNIVERSAL_SEQUENCE | ASN1_CONSTRUCTED),
   (unsigned char) 0x00,
   (unsigned char) 0x00,
   // L5 OID: ContentType
   // Dataindex: 3
   (unsigned char) (X_FIRST | DATA_INDEX),
   (unsigned char)	(ASN1_UNIVERSAL_OBJECT_ID),
   (unsigned char) PFX_X509_CERTCRL_CONT_TYPE_IND,
   (unsigned char) 0x00,
   // L5 ETAG[0]: ContentValue
   // DataIndex: 4
   (unsigned char) (X_LAST | DATA_INDEX | OPTIONAL),
   (unsigned char)	(ASN1_CLASS_CONTEXT_SPECIFIC | ASN1_CONSTRUCTED | 0x00),
   (unsigned char) PFX_X509_CERTCRL_CONT_VAL_IND,
   (unsigned char) 0x00,

   //------------------------------------------------------------------------
   // 1.2.1.4. PKCS-7 SignedData.certSet : ETAG[0] optional
   //------------------------------------------------------------------------
   // L4 ETAG[0]: certSet
   // DataIndex: 5
   (unsigned char) (X_MIDDLE | DATA_INDEX | OPTIONAL),
   (unsigned char)	(ASN1_CLASS_CONTEXT_SPECIFIC | ASN1_CONSTRUCTED | 0x00),
   (unsigned char) PFX_X509_CERTCRL_CERTS_INDEX,
   (unsigned char) 0x00,
   //------------------------------------------------------------------------
   // 1.2.1.5. PKCS-7 SignedData.crlSet : ETAG[1] optional
   //------------------------------------------------------------------------
   // L4 ETAG[1]: crlSet
   // DataIndex: 6
   (unsigned char) (X_MIDDLE | DATA_INDEX | OPTIONAL),
   (unsigned char)	(ASN1_CLASS_CONTEXT_SPECIFIC | ASN1_CONSTRUCTED | 0x01),
   (unsigned char) PFX_X509_CERTCRL_CRLS_INDEX,
   (unsigned char) 0x00,
   //------------------------------------------------------------------------
   // 1.2.1.6. PKCS-7SignedData.SignerInfos : SET OF
   //------------------------------------------------------------------------
   // L4 SET OF: SignerInfos
   // DataIndex: 7
   (unsigned char) (X_LAST | DATA_INDEX | ANY_ASN1),
   (unsigned char)	(ASN1_UNIVERSAL_SET | ASN1_CONSTRUCTED),
   (unsigned char) PFX_X509_CERTCRL_SIGINFOS_INDEX,
   (unsigned char) 0x00,
};
//================================================================
// PKCS12 V1 X509CertList Split/Combine Control Structure:
// from/to PKCS12 V1 X509CertList <-> Array of Certs
//
//================================================================
extern "C"  unsigned char PFX_X509CertListCtl[PFX_X509_CERTLIST_CTL_SIZE]={

   // L1 SEQ: Data
   // DataIndex: 0
   (unsigned char) (X_ONLY | DATA_INDEX | ANY_ASN1),
   (unsigned char) (ASN1_UNIVERSAL_SEQUENCE | ASN1_CONSTRUCTED),
   (unsigned char) PFX_X509_CERTLIST_CERT_INDEX,
   (unsigned char) 0x00,
};

//--------------------------------------------------
// Converted JAVA arrays from PKC12CTL.HC
//--------------------------------------------------

/** @addtogroup pkcs12
* @{
*/

/**
* Helper Routine SetBit8Array sets Array contents to given value (SetBit8Array).
*
*  @param pBuf Array Base
*  @param BufOff Start of Data
*  @param BufLen Size of Data
*  @param Value Value to set (Low Byte)
*/
static  void  SetBit8Array(char* pBuf, int BufOff, int BufLen,
                           int Value)
{
   if((pBuf != NULL) && (BufLen > 0))
   {
      memset(pBuf+BufOff,Value,BufLen);
   }
}
/**
* Helper Routine CLearBit16Array clears Array contents (ClearBit16Array).
*
*  @param pBuf Array Base
*  @param BufOff Start of Data
*  @param BufLen Size of Data
*/
static  void  ClearBit16Array(short* pBuf, int BufOff, int BufLen)
{
   if((pBuf != NULL) && (BufLen > 0))
   {
      memset(pBuf+BufOff,0,BufLen*sizeof(short));
   }
}

/**
* Helper Routine CLearBit32Array clears Array contents (ClearBit32Array).
*
*  @param pBuf Array Base
*  @param BufOff Start of Data
*  @param BufLen Size of Data
*/
static  void  ClearBit32Array(int* pBuf, int BufOff, int BufLen)
{
   if((pBuf != NULL) && (BufLen > 0))
   {
      memset(pBuf+BufOff,0,BufLen*sizeof(int));
   }
}
/**
* Helper Routine XorBit8Array Xors Array contents with given value (XorBit8Array).
*
*  @param pBuf Array Base
*  @param BufOff Start of Data
*  @param BufLen Size of Data
*  @param Value Value for XOR (Low Byte)
*/
static  void  XorBit8Array(char* pBuf, int BufOff, int BufLen,
                           int Value)
{
   if((pBuf != NULL) && (BufLen > 0))
   {
      while(BufLen != 0)
      {
         pBuf[BufOff++] ^= (unsigned char) Value;
         BufLen--;
      }
   }
}
/**
* Generate PKCS12/PFX Unicode password with 2 trailing NULs from
* given ASCII password (PasswdToUnicode).
*
*  @param pPasswd Password to convert
*  @param PasswdOff Start of Data
*  @param PasswdLen Size of password (may be 0)
*  @param ppUniPwd Allocated buffer
*  @param pUniPwdLen Size of expanded password
*
*  @return int Status - 0 o.k., else error occured
*/
static  int  PasswdToUnicode(char* pPasswd, int PasswdOff,
                             int PasswdLen, char** ppUniPwd, int* pUniPwdLen)
{
   int Index, Len;
   char* pPwdBuf;
   //------------------------------------------------------
   // Check parameters
   //------------------------------------------------------
   if((pPasswd == NULL) || (ppUniPwd == NULL) || (pUniPwdLen == NULL))
      return(PKCS12_NULL_PTR);
   if(PasswdLen < 0)
      return(PKCS12_PARAM_ERR);
   //------------------------------------------------------
   // Allocate buffer needed
   //------------------------------------------------------
   ppUniPwd[0] = NULL;
   pUniPwdLen[0] = 0;
   Len = (PasswdLen +1) * 2;
   if((pPwdBuf = BIT8_ARRAY_ALLOC(HMEM_CTX_REF,Len)) == NULL)
      return(PKCS12_ALLOC_ERR);
   ClearBit8Array(pPwdBuf, 0, Len);		// fill with Zeroes

   Index = 1;					// start at 1st location
   while(PasswdLen != 0)
   {
      pPwdBuf[Index] = pPasswd[PasswdOff++];
      Index += 2;
      PasswdLen--;
   }
   ppUniPwd[0] = pPwdBuf;
   pUniPwdLen[0] = Len;
   return(PKCS12_OP_OK);
}

//()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()
//
// ASN.1 Decoder/Encoder routines
//
//()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()

/**
* Routine ASN1MatchOIDArcGetSubID compares contents of an OID Array
* without ASN.1 header to a given Arc OID (also without header) (ASN1MatchOIDArcGetSubID).
* If Arc matches extracts the next byte past the Arc if present and
* compare to lower/upper limit(s) if given.
*
*  @param pOidBuf OID Base
*  @param OidOff Start of Data
*  @param OidLen Length of Data
*  @param pArcBuf Array Base
*  @param ArcOff Start of Data
*  @param ArcLen Length of Data
*  @param ExactMatch <> 0 -> must have exactly 1 more Byte
*  @param LowerLimit Check Limit Arc+1 byte, -1 dont check
*  @param UpperLimit Check Limit Arc+1 byte, -1 dont check
*  @param pSubID Arc+1 Byte
*  @return int Status -4 Arc does not match at all
* <br>            -3 Arc matches, but either no SubID or more data
* <br>            -2 Arc matches, but next below lower limit
* <br>            -1 Arc matches, but next above upper limit
* <br>            0 Arc matched but no additional data
* <br>            1 Arc matched, SubID Available
*/
static  int  ASN1MatchOIDArcGetSubID(char* pOidBuf, int OidOff,
                                     int OidLen, char* pArcBuf, int ArcOff, int ArcLen,
                                     int ExactMatch, int LowerLimit, int UpperLimit, int* pSubID)
{
   int SubID;

   pSubID[0] = -1;				// set invalid

   //---------------------------------------------------------
   // Check if Arc matching possible at all
   //---------------------------------------------------------
   if((pOidBuf == NULL) || (pArcBuf == NULL) ||
      (OidLen <= 0) || (ArcLen <= 0) || (OidLen < ArcLen))
   {
      return(-4);
   }
   //---------------------------------------------------------
   // Try to match the Arc now
   //---------------------------------------------------------
   while(ArcLen != 0)
   {
      if(pOidBuf[OidOff++] != pArcBuf[ArcOff++])
      {
         return(-4);
      }
      ArcLen--;
      OidLen--;
   }
   //---------------------------------------------------------
   // Arc matches OID, check if more OID data available
   //---------------------------------------------------------
   if((ExactMatch != 0) && (OidLen != 1))	// not the expected amount
      return(-3);
   if(OidLen == 0)				// inexact match mode
      return(0);					// no SubID present
   //---------------------------------------------------------
   // Extract the SubID, chack against Limits
   //---------------------------------------------------------
   SubID = (int) pOidBuf[OidOff] & 0xFF;
   if((LowerLimit >= 0) && (SubID < LowerLimit))
      return(-2);
   if((UpperLimit >= 0) && (SubID > UpperLimit))
      return(-1);
   pSubID[0] = SubID;
   return(1);
}

/**
* Get X509 Extension Attribute ID from given Attribute OID contents
* without ASN.1 OID Header (GetX509_ExtAttTypeID).
*
*  @param pBuf PBE OID Contents Base
*  @param Offset Start of Data
*  @param Len Length of Data
*  @param pExtAttID Extension Attribute ID
*  @return int Status - 0 o.k., else error occured
*/
static  int  GetX509_ExtAttTypeID(char* pBuf, int Offset, int Len,
                                  int* pExtAttID)
{
   int Retcode;

   if(pExtAttID == NULL)
      return(PKCS12_NULL_PTR);
   //--------------------------------------------------------
   // Match the Arc in Exact Mode with Limits, get the Sub-ID
   //--------------------------------------------------------
   if((Retcode = ASN1MatchOIDArcGetSubID(pBuf, Offset, Len,
      X509_IdCeBaseOID, 0, X509_ID_CE_BASE_OID_LEN,
      1, X509_ID_CE_SUBID_MIN, X509_ID_CE_SUBID_MAX,
      pExtAttID)) > 0)
      return(PKCS12_OP_OK);
   if(Retcode <= -2)			// no match, inexact, below lower limit
      return(PKCS12_INVALID_X509_EXT_ATT_ID);
   return(PKCS12_UNKNOWN_X509_EXT_ATT_ID);	// above upper limit
}

/**
* Get X9.57 Algorithm ID from given AlgorID OID contents
* without ASN.1 OID Header (GetX957_AlgorTypeID).
* NOTE: Always report SHA (*NOT* the SHA-1) Algor as Invalid !!!
* -----
*
*  @param pBuf PBE OID Contents Base
*  @param Offset Start of Data
*  @param Len Length of Data
*  @param pAlgorID AlgorID
*  @return int Status - 0 o.k., else error occured
*/
static  int  GetX957_AlgorTypeID(char* pBuf, int Offset, int Len,
                                 int* pAlgorID)
{
   int Retcode;

   if(pAlgorID == NULL)
      return(PKCS12_NULL_PTR);
   //--------------------------------------------------------
   // Match the Arc in Exact Mode with Limits, get the Sub-ID
   //--------------------------------------------------------
   if((Retcode = ASN1MatchOIDArcGetSubID(pBuf, Offset, Len,
      (char*) X957_DsaAlgorsBaseOID, 0,
      X957_DSA_ALGORS_BASE_OID_LEN,
      1, X957_DSA_SUBID_MIN, X957_DSA_SUBID_MAX,
      pAlgorID)) > 0)
   {
      if(pAlgorID[0] == X957_DSA_WITH_SHA_ALGOR_SUBID) // NOT SUPPORTED !!!
         return(PKCS12_INVALID_DSA_ALGOR);
      return(PKCS12_OP_OK);
   }
   if(Retcode <= -2)			// no match, inexact, below lower limit
      return(PKCS12_INVALID_DSA_ALGOR);
   return(PKCS12_UNKNOWN_DSA_ALGOR);	// above upper limit
}
/**
* Get OIW Algorithm ID from given AlgorID OID contents
* without ASN.1 OID Header (GetOIW_AlgorTypeID).
*
*  @param pBuf PBE OID Contents Base
*  @param Offset Start of Data
*  @param Len Length of Data
*  @param pAlgorID AlgorID
*  @return int Status - 0 o.k., else error occured
*/
static  int  GetOIW_AlgorTypeID(char* pBuf, int Offset, int Len,
                                int* pAlgorID)
{
   int Retcode;

   if(pAlgorID == NULL)
      return(PKCS12_NULL_PTR);
   //--------------------------------------------------------
   // Match the Arc in Exact Mode with Limits, get the Sub-ID
   //--------------------------------------------------------
   if((Retcode = ASN1MatchOIDArcGetSubID(pBuf, Offset, Len,
      OIW_AlgorsBaseOID, 0, OIW_ALGORS_BASE_OID_LEN,
      1, OIW_ALGORS_SUBID_MIN, OIW_ALGORS_SUBID_MAX,
      pAlgorID)) > 0)
   {
      //    if(pAlgorID[0] == X957_DSA_WITH_SHA_ALGOR_SUBID) // NOT SUPPORTED !!!
      //      return(PKCS12_INVALID_DSA_ALGOR);
      return(PKCS12_OP_OK);
   }
   if(Retcode <= -2)			// no match, inexact, below lower limit
      return(PKCS12_INVALID_OIW_ALGOR);
   return(PKCS12_UNKNOWN_OIW_ALGOR);	// above upper limit
}

/**
* Get PKCS1 Algorithm ID from given AlgorID OID contents
* without ASN.1 OID Header (GetPKCS1_AlgorTypeID).
* NOTE: Always report MD4 Algor as Invalid !!!
* -----
*
*  @param pBuf PBE OID Contents Base
*  @param Offset Start of Data
*  @param Len Length of Data
*  @param pAlgorID AlgorID
*  @return int Status - 0 o.k., else error occured
*/
static  int  GetPKCS1_AlgorTypeID(char* pBuf, int Offset, int Len,
                                  int* pAlgorID)
{
   int Retcode;

   if(pAlgorID == NULL)
      return(PKCS12_NULL_PTR);
   //--------------------------------------------------------
   // Match the Arc in Exact Mode with Limits, get the Sub-ID
   //--------------------------------------------------------
   if((Retcode = ASN1MatchOIDArcGetSubID(pBuf, Offset, Len,
      (char*) PKCS1_RsaAlgorsBaseOID, 0,
      PKCS1_RSA_ALGORS_BASE_OID_LEN,
      1, PKCS1_RSA_SUBID_MIN, PKCS1_RSA_SUBID_MAX,
      pAlgorID)) > 0)
   {
      if(pAlgorID[0] == PKCS1_MD4_WITH_RSA_ALGOR_SUBID) // NOT SUPPORTED !!!
         return(PKCS12_INVALID_RSA_ALGOR);
      return(PKCS12_OP_OK);
   }
   if(Retcode <= -2)			// no match, inexact, below lower limit
      return(PKCS12_INVALID_RSA_ALGOR);
   return(PKCS12_UNKNOWN_RSA_ALGOR);	// above upper limit
}
/**
* Get PKCS2 Algorithm ID from given AlgorID OID contents
* without ASN.1 OID Header (GetPKCS2_AlgorTypeID).
* NOTE: Always report MD4 Algor as Invalid !!!
* -----
*
*  @param pBuf PBE OID Contents Base
*  @param Offset Start of Data
*  @param Len Length of Data
*  @param pAlgorID AlgorID
*  @return int Status - 0 o.k., else error occured
*/
static  int  GetPKCS2_AlgorTypeID(char* pBuf, int Offset, int Len,
                                  int* pAlgorID)
{
   int Retcode;

   if(pAlgorID == NULL)
      return(PKCS12_NULL_PTR);
   //--------------------------------------------------------
   // Match the Arc in Exact Mode with Limits, get the Sub-ID
   //--------------------------------------------------------
   if((Retcode = ASN1MatchOIDArcGetSubID(pBuf, Offset, Len,
      (char*) PKCS2_DigestAlgorsBaseOID, 0,
      PKCS2_DIGEST_ALGS_BASE_OID_LEN,
      1, PKCS2_DIGESTALG_SUBID_MIN, PKCS2_DIGESTALG_SUBID_MAX,
      pAlgorID)) > 0)
   {
      if((pAlgorID[0] != PKCS2_MD2_DIGEST_ALGOR_SUBID) &&
         (pAlgorID[0] != PKCS2_MD5_DIGEST_ALGOR_SUBID))
         return(PKCS2_INVALID_DIGEST_ALGOR);
      return(PKCS12_OP_OK);
   }
   if(Retcode <= -2)			// no match, inexact, below lower limit
      return(PKCS2_INVALID_DIGEST_ALGOR);
   return(PKCS2_UNKNOWN_DIGEST_ALGOR);	// above upper limit
}

/**
* Get PKCS7 Content Type ID from given Content Type OID contents
* without ASN.1 OID Header (GetPKCS7_ContTypeID).
*
*  @param pBuf PBE OID Contents Base
*  @param Offset Start of Data
*  @param Len Length of Data
*  @param pContType Type of Content
*  @return int Status - 0 o.k., else error occured
*/
static  int  GetPKCS7_ContTypeID(char* pBuf, int Offset, int Len,
                                 int* pContType)
{
   int Retcode;

   if(pContType == NULL)
      return(PKCS12_NULL_PTR);
   //--------------------------------------------------------
   // Match the Arc in Exact Mode with Limits, get the Sub-ID
   //--------------------------------------------------------
   if((Retcode = ASN1MatchOIDArcGetSubID(pBuf, Offset, Len,
      (char*) PKCS7ContentTypesBaseOID, 0,
      PKCS7_CONT_TYPES_BASE_OID_LEN,
      1, PKCS7_CONTENT_SUBID_MIN, PKCS7_CONTENT_SUBID_MAX,
      pContType)) > 0)
      return(PKCS12_OP_OK);
   if(Retcode <= -2)			// no match, inexact, below lower limit
      return(PKCS12_INVALID_CONTENT_TYPE);
   return(PKCS12_UNKNOWN_CONTENT_TYPE);	// above upper limit
}

/**
* Get PKCS9 ExtendedAttributeType ID from given AttributeType OID
* without ASN.1 OID Header (GetPKCS9_ExtAttID).
*
*  @param pBuf Attribute OID Base
*  @param Offset Start of Data
*  @param Len Length of Data
*  @param pExtAttType Type of Attribute
*  @return int Status - 0 o.k., else error occured
*/
static  int  GetPKCS9_ExtAttID(char* pBuf, int Offset, int Len,
                               int* pExtAttType)
{
   int Retcode;

   if(pExtAttType == NULL)
      return(PKCS12_NULL_PTR);
   //--------------------------------------------------------
   // Match the Arc in Exact Mode with Limits, get the Sub-ID
   //--------------------------------------------------------
   if((Retcode = ASN1MatchOIDArcGetSubID(pBuf, Offset, Len,
      (char*) PKCS9AttTypesBaseOID, 0,
      PKCS9_ATT_TYPES_BASE_OID_LEN,
      1, PKCS9_ATT_SUBID_MIN, PKCS9_ATT_SUBID_MAX,
      pExtAttType)) > 0)
      return(PKCS12_OP_OK);
   if(Retcode <= -2)			// no match, inexact, below lower limit
      return(PKCS9_INVALID_ATT_TYPE);
   return(PKCS9_UNKNOWN_ATT_TYPE);	// above upper limit
}

/**
* Get PKCS12 / PFX PBE Encryption Algorithm ID from given PBE OID contents
* without ASN.1 OID Header (GetPKCS12_PBEAlgorID).
* NOTE: PFX IDs are mapped to PKCS12 IDs !
* -----
*
*  @param pBuf PBE OID Contents Base
*  @param Offset Start of Data
*  @param Len Length of Data
*  @param Type 0 - PKCS12, else PFX Mode
*  @param pAlgorType Type of PBE Algor
*  @return int Status - 0 o.k., else error occured
*/
static  int  GetPKCS12_PBEAlgorID(char* pBuf, int Offset, int Len,
                                  int Type, int* pAlgorType)
{
   int Retcode;

   if(pAlgorType == NULL)
      return(PKCS12_NULL_PTR);

   if(Type == 0)					// PKCS12 Mode
   {
      //--------------------------------------------------------
      // Match the Arc in Exact Mode with Limits, get the Sub-ID
      //--------------------------------------------------------
      if((Retcode = ASN1MatchOIDArcGetSubID(pBuf, Offset, Len,
         (char*) PKCS12PbeTypesBaseOID, 0,
         PKCS12_PBE_TYPES_BASE_OID_LEN,
         1, PKCS12_PBE_MIN_ALGORS, PKCS12_PBE_MAX_ALGORS,
         pAlgorType)) > 0)
         return(PKCS12_OP_OK);
      if(Retcode <= -2)			// no match, inexact, below lower limit
         return(PKCS12_INVALID_PBE_ALGOR);
      return(PKCS12_UNKNOWN_PBE_ALGOR);	// above upper limit
   }
   else						// PFX Mode
   {
      //--------------------------------------------------------
      // Match the Arc in Exact Mode with Limits, get the Sub-ID
      //--------------------------------------------------------
      if((Retcode = ASN1MatchOIDArcGetSubID(pBuf, Offset, Len,
         (char*) PFX_EncPbeIDsBaseOID,0,
         PFX_ENC_PBE_IDS_BASE_OID_LEN,
         1, PFX_PBE_MIN_ALGORS, PFX_PBE_MAX_ALGORS,
         pAlgorType)) > 0)
      {
         //------------------------------------------------------
         // Found a match, transcode to PKCS12 Range
         //------------------------------------------------------
         if(pAlgorType[0] > PKCS12_PBE_SHA_3DESC_CBC_3KEYS)
            pAlgorType[0]++;		// there is no 2Key 3DES in PFX !
         return(PKCS12_OP_OK);
      }
      //-----------------------------------------------------------------
      // no match, check if ARC Mismatch (there is a PKCS-5 type possible
      //-----------------------------------------------------------------
      if(Retcode > -4)			// Arc did match
      {
         if(Retcode <= -2)			// no match, inexact, below lower limit
            return(PFX_INVALID_PBE_ALGOR);
         return(PFX_UNKNOWN_PBE_ALGOR);	// above upper limit
      }
      //--------------------------------------------------------------
      // Match Alternate Arc in Exact Mode no Limits, get the Sub-ID
      //--------------------------------------------------------------
      if((Retcode = ASN1MatchOIDArcGetSubID(pBuf, Offset, Len,
         (char*) PFX_PKCS5_EncPbeIDsBaseOID,0,
         PFX_PKCS5_ENCPBEID_BASE_OID_LEN,
         1, -1, -1, pAlgorType)) > 0)
      {
         if(pAlgorType[0] == PFX_PKCS5_DES_ALGOR_ID)
         {
            pAlgorType[0] = PKCS12_PBE_SHA_DES_CBC;
            return(PKCS12_OP_OK);
         }
         return(PFX_UNKNOWN_PBE_ALGOR);
      }
      return(PFX_INVALID_PBE_ALGOR);
   }
}
/**
* Get PKCS12 Bagtype ID from given Bagtype OID contents
* without ASN.1 OID Header (GetPKCS12_BagTypeID).
*
*  @param pBuf PBE OID Contents Base
*  @param Offset Start of Data
*  @param Len Length of Data
*  @param pBagType Type of Bag (is really the VALUE type!)
*  @return int Status - 0 o.k., else error occured
*/
static  int  GetPKCS12_BagTypeID(char* pBuf, int Offset, int Len,
                                 int* pBagType)
{
   int Retcode;

   if(pBagType == NULL)
      return(PKCS12_NULL_PTR);
   //--------------------------------------------------------
   // Match the Arc in Exact Mode with Limits, get the Sub-ID
   //--------------------------------------------------------
   if((Retcode = ASN1MatchOIDArcGetSubID(pBuf, Offset, Len,
      (char*) PKCS12BagTypesBaseOID, 0,
      PKCS12_BAG_TYPES_BASE_OID_LEN,
      1, PKCS12_BAG_SUBID_MIN, PKCS12_BAG_SUBID_MAX,
      pBagType)) > 0)
      return(PKCS12_OP_OK);
   if(Retcode <= -2)			// no match, inexact, below lower limit
      return(PKCS12_INVALID_BAG_TYPE);
   return(PKCS12_UNKNOWN_BAG_TYPE);	// above upper limit
}
/**
* Get PKCS12 CertType ID from given CertType OID contents
* without ASN.1 OID Header (GetPKCS12_CertTypeID).
*
*  @param pBuf PBE OID Contents Base
*  @param Offset Start of Data
*  @param Len Length of Data
*  @param pCertType Type of Cert
*  @return int Status - 0 o.k., else error occured
*/
static  int  GetPKCS12_CertTypeID(char* pBuf, int Offset, int Len,
                                  int* pCertType)
{
   int Retcode;

   if(pCertType == NULL)
      return(PKCS12_NULL_PTR);
   //--------------------------------------------------------
   // Match the Arc in Exact Mode with Limits, get the Sub-ID
   //--------------------------------------------------------
   if((Retcode = ASN1MatchOIDArcGetSubID(pBuf, Offset, Len,
      (char*) PKCS9CertTypesBaseOID, 0,
      PKCS9_CERT_TYPES_BASE_OID_LEN,
      1, PKCS12_CERT_TYPE_SUBID_MIN, PKCS12_CERT_TYPE_SUBID_MAX,
      pCertType)) > 0)
      return(PKCS12_OP_OK);
   if(Retcode <= -2)			// no match, inexact, below lower limit
      return(PKCS12_INVALID_CERT_TYPE);
   return(PKCS12_UNKNOWN_CERT_TYPE);	// above upper limit
}

/**
* Get PKCS12 V1 (PFX) ESPVK ID from given OID contents
* without ASN.1 OID Header (GetPFX_EspvkTypeID).
*
*  @param pBuf PBE OID Contents Base
*  @param Offset Start of Data
*  @param Len Length of Data
*  @param pEspvkType Type of Espvk
*  @return int Status - 0 o.k., else error occured
*/
static  int  GetPFX_EspvkTypeID(char* pBuf, int Offset,
                                int Len, int* pEspvkType)
{
   int Retcode;

   if(pEspvkType == NULL)
      return(PKCS12_NULL_PTR);
   //--------------------------------------------------------
   // Match the Arc in Exact Mode with Limits, get the Sub-ID
   //--------------------------------------------------------
   if((Retcode = ASN1MatchOIDArcGetSubID(pBuf, Offset, Len,
      (char*) PFX_EspvkIDsBaseOID, 0, PFX_ESPVK_IDS_BASE_OID_LEN,
      1, PFX_ESPVK_SUBID_MIN, PFX_ESPVK_SUBID_MAX,
      pEspvkType)) > 0)
      return(PKCS12_OP_OK);
   if(Retcode <= -2)			// no match, inexact, below lower limit
      return(PFX_INVALID_ESPVK_TYPE);
   return(PFX_UNKNOWN_ESPVK_TYPE);	// above upper limit
}
/**
* Get PKCS12 V1 (PFX) Bag ID from given OID contents
* without ASN.1 OID Header (GetPFX_BagTypeID).
*
*  @param pBuf PBE OID Contents Base
*  @param Offset Start of Data
*  @param Len Length of Data
*  @param pBagType Type of Bag
*  @return int Status - 0 o.k., else error occured
*/
static  int  GetPFX_BagTypeID(char* pBuf, int Offset,
                              int Len, int* pBagType)
{
   int Retcode;

   if(pBagType == NULL)
      return(PKCS12_NULL_PTR);
   //--------------------------------------------------------
   // Match the Arc in Exact Mode with Limits, get the Sub-ID
   //--------------------------------------------------------
   if((Retcode = ASN1MatchOIDArcGetSubID(pBuf, Offset, Len,
      (char*) PFX_BagIDsBaseOID, 0, PFX_BAG_IDS_BASE_OID_LEN,
      1, PFX_BAGTYPE_SUBID_MIN, PFX_BAGTYPE_SUBID_MAX,
      pBagType)) > 0)
      return(PKCS12_OP_OK);
   if(Retcode <= -2)			// no match, inexact, below lower limit
      return(PFX_INVALID_BAG_TYPE);
   return(PFX_UNKNOWN_BAG_TYPE);		// above upper limit
}
/**
* Get PKCS12 V1 (PFX) Certype ID from given OID contents
* without ASN.1 OID Header (GetPFX_CertTypeID).
*
*  @param pBuf PBE OID Contents Base
*  @param Offset Start of Data
*  @param Len Length of Data
*  @param pCertCRLType Type of Cert/CRL
*  @return int Status - 0 o.k., else error occured
*/
static  int  GetPFX_CertTypeID(char* pBuf, int Offset,
                               int Len, int* pCertCRLType)
{
   int Retcode;

   if(pCertCRLType == NULL)
      return(PKCS12_NULL_PTR);
   //--------------------------------------------------------
   // Match the Arc in Exact Mode with Limits, get the Sub-ID
   //--------------------------------------------------------
   if((Retcode = ASN1MatchOIDArcGetSubID(pBuf, Offset, Len,
      (char*) PFX_CertIDsBaseOID, 0, PFX_CERT_IDS_BASE_OID_LEN,
      1, PFX_CERTCRL_TYPE_SUBID_MIN, PFX_CERTCRL_TYPE_SUBID_MAX,
      pCertCRLType)) > 0)
      return(PKCS12_OP_OK);
   if(Retcode <= -2)			// no match, inexact, below lower limit
   {

      return(PFX_INVALID_CERTCRL_TYPE);
   }
   return(PFX_UNKNOWN_CERTCRL_TYPE);		// above upper limit
}

/**
* Get Private Key AlgorithmID (RSA/DSA) from given OID
* without ASN.1 OID Header (GetPKCS12_PrivkeyAlgorTypeID).
* NOTE: Algorithms
* -----
*
*  @param pBuf PBE OID Contents Base
*  @param Offset Start of Data
*  @param Len Length of Data
*               int Type 0 - PKCS12, else PFX Mode
*               int pAlgorType[] Type of PBE Algor
*  @return int Status - 0 o.k., else error occured
*/
static  int  GetPKCS12_PrivkeyAlgorTypeID(char* pBuf,
                                          int Offset, int Len, int* pAlgorID)
{
   int Retcode;
   //-----------------------------------------------------------
   // Check if this is a PKCS-1 related AlgorID first
   //-----------------------------------------------------------
   Retcode = GetPKCS1_AlgorTypeID(pBuf, Offset, Len, pAlgorID);
   if(Retcode == PKCS12_OP_OK)
   {
      //---------------------------------------------------------
      // Is a recognized RSA ID, check if type pkcs-1 1 (1)
      //---------------------------------------------------------
      if(pAlgorID[0] != PKCS1_RSA_ALGOR_SUBID)	// not a recognized one
         return(PKCS12_INVALID_PRIVKEY_ALGOR);
      pAlgorID[0] = PKCS12_PRIVKEY_ALGOR_RSA;
      return(PKCS12_OP_OK);
   }
   else						// Error, check if RSA type
   {
      if(Retcode == PKCS12_UNKNOWN_RSA_ALGOR)
         return(PKCS12_INVALID_PRIVKEY_ALGOR);
   }
   //-----------------------------------------------------------
   // Check if this is a X957 related AlgorID next
   //-----------------------------------------------------------
   Retcode = GetX957_AlgorTypeID(pBuf, Offset, Len, pAlgorID);
   if(Retcode == PKCS12_OP_OK)
   {
      //---------------------------------------------------------
      // Is a recognized X9.57 ID, check if type dsa
      //---------------------------------------------------------
      if(pAlgorID[0] != X957_DSA_ALGOR_SUBID)	// not a recognized one
         return(PKCS12_INVALID_PRIVKEY_ALGOR);
      pAlgorID[0] = PKCS12_PRIVKEY_ALGOR_X957_DSA;
      return(PKCS12_OP_OK);
   }
   else						// Error, check if RSA type
   {
      if(Retcode == PKCS12_UNKNOWN_DSA_ALGOR)
         return(PKCS12_INVALID_PRIVKEY_ALGOR);
   }

   return(PKCS12_UNKNOWN_PRIVKEY_ALGOR);
}

/**
* Get PFX ThumbPrint AlgorithmID (RSA/DSA) from given OID
* without ASN.1 OID Header (GetPFX_ThumbPrintAlgorTypeID).
*
*  @param pBuf PBE OID Contents Base
*  @param Offset Start of Data
*  @param Len Length of Data
*               int Type 0 - PKCS12, else PFX Mode
*  @param pAlgorID Type of Digest Algor
*  @return int Status - 0 o.k., else error occured
*/
static  int  GetPFX_ThumbPrintAlgorTypeID(char* pBuf,
                                          int Offset, int Len, int* pAlgorID)
{
   int Retcode;
   //-----------------------------------------------------------
   // Check if this is a PKCS-2 related AlgorID first
   //-----------------------------------------------------------
   Retcode = GetPKCS2_AlgorTypeID(pBuf, Offset, Len, pAlgorID);
   if(Retcode == PKCS12_OP_OK)
   {
      //---------------------------------------------------------
      // Is a recognized RSA Digest Algor
      //---------------------------------------------------------
      if(pAlgorID[0] == PKCS2_MD2_DIGEST_ALGOR_SUBID)
         pAlgorID[0] = PKCS12_SIGNAT_ALGOR_MD2;
      else if(pAlgorID[0] == PKCS2_MD5_DIGEST_ALGOR_SUBID)
         pAlgorID[0] = PKCS12_SIGNAT_ALGOR_MD5;
      else
         return(PKCS12_INVALID_SIGNAT_ALGOR);
      return(PKCS12_OP_OK);
   }
   else						// Error, check if RSA type
   {
      if(Retcode == PKCS2_UNKNOWN_DIGEST_ALGOR)
         return(PKCS12_INVALID_SIGNAT_ALGOR);
   }
   //-----------------------------------------------------------
   // Check if this is a X957 related AlgorID next
   //-----------------------------------------------------------
   Retcode = GetX957_AlgorTypeID(pBuf, Offset, Len, pAlgorID);
   if(Retcode == PKCS12_OP_OK)
   {
      //---------------------------------------------------------
      // Is a recognized X9.57 ID, check if type dsa-signature
      //---------------------------------------------------------
      if(pAlgorID[0] != X957_DSA_WITH_SHA1_ALGOR_SUBID)	// not a recognized one
         return(PKCS12_INVALID_SIGNAT_ALGOR);
      pAlgorID[0] = PKCS12_SIGNAT_ALGOR_SHA1;
      return(PKCS12_OP_OK);
   }
   else						// Error, check if RSA type
   {
      if(Retcode == PKCS12_UNKNOWN_DSA_ALGOR)
         return(PKCS12_INVALID_SIGNAT_ALGOR);
   }
   //-----------------------------------------------------------
   // Check if this is a OIW related AlgorID next
   //-----------------------------------------------------------
   Retcode = GetOIW_AlgorTypeID(pBuf, Offset, Len, pAlgorID);
   if(Retcode == PKCS12_OP_OK)
   {
      //---------------------------------------------------------
      // Is a recognized OIW ID, check if type dsa-signature
      //---------------------------------------------------------
      if(pAlgorID[0] != OIW_DSA_ALGOR_SUBID)	// not a recognized one
         return(PKCS12_INVALID_SIGNAT_ALGOR);
      pAlgorID[0] = PKCS12_SIGNAT_ALGOR_SHA1;
      return(PKCS12_OP_OK);
   }
   else						// Error, check if RSA type
   {
      if(Retcode == PKCS12_UNKNOWN_OIW_ALGOR)
         return(PKCS12_INVALID_SIGNAT_ALGOR);
   }
   return(PKCS12_UNKNOWN_SIGNAT_ALGOR);
}

//*************************************************************

/**
* Check Descriptor Element if given for Index, Flags (CheckAllocDesc).
* If no Descriptor given, allocate required sized.
*
*  @param ppDesc IN/OUT
*  @param Index Index to Check
*  @param AllocSize Size to use for new one
*  @param pAllocedFlag Report that Alloc occured/NULL
*
*  @return int Status, 0 - o.k., else Error occured
*/
static  int  CheckAllocDesc(IDATPARR** ppDesc,
                            int Index, int AllocSize, int* pAllocedFlag)
{
   int Retcode;
   int AllocFlag = 0;
   IDATPARR* pDesc;
   //-----------------------------------------------------------
   // Check parameters
   //-----------------------------------------------------------
   if(ppDesc == NULL)
      return(PKCS12_NULL_PTR);
   if(Index < 0)
      return(PKCS12_PARAM_ERR);
   //-----------------------------------------------------------
   // Check if a descriptor is given
   //-----------------------------------------------------------
   pDesc = ppDesc[0];
   if(pDesc != NULL)
   {  
      if(((pDesc->Flags & FREE_BIT_MASK) == 0) ||
         (Index >= pDesc->Cnt))
         return(PKCS12_PARAM_ERR);
      if(pDesc->ppArr[Index] == NULL)
         return(PKCS12_NULL_PTR);
   }
   else
   {
      //-----------------------------------------------------------
      // Allocate a Descriptor if needed
      //-----------------------------------------------------------
      if(AllocSize <= 0)
         return(PKCS12_PARAM_ERR);

      if((Retcode = AllocIDATPARR_Struc(HMEM_CTX_REF1 ppDesc,AllocSize)) != ASN1_OP_OK)
         return(PKCS12_ALLOC_ERR);
      pDesc = ppDesc[0];
      pDesc->Flags |= FREE_BIT_MASK;
      AllocFlag = 1;
   }
   if(pAllocedFlag != NULL)
      pAllocedFlag[0] = AllocFlag;
   return(PKCS12_OP_OK);
}

/**
* Copy buffer pointer/offset/length to a Descriptor Element (FromBufToDescAlloc).
* If no Descriptor given, a new one of specified size will be
* allocated
*
*  @param pBuf Buffer base
*  @param Offset Start of Data
*  @param DataLen Size of Data
*  @param ppDstDesc IN/OUT
*  @param DstIndex Element to load
*  @param DstAllocSize Number of Elements required
*
*  @return int Status, 0 - o.k., else Error occured
*/
static  int  FromBufToDescAlloc(char* pBuf,int Offset,int DataLen,
                                IDATPARR** ppDstDesc, int DstIndex, int DstAllocSize)
{
   int Retcode;
   //-----------------------------------------------------------
   // Check parameters
   //-----------------------------------------------------------
   if((pBuf == NULL) || (ppDstDesc == NULL))
      return(PKCS12_NULL_PTR);
   if(DstIndex < 0)
      return(PKCS12_PARAM_ERR);
   //-----------------------------------------------------------
   // Check/Allocate Destination descriptor
   //-----------------------------------------------------------
   if((Retcode = CheckAllocDesc(ppDstDesc, DstIndex,
      DstAllocSize, NULL)) != PKCS12_OP_OK)
      return(Retcode);
   //-----------------------------------------------------------
   // Put buffer to Destination Element, if already set, free it
   //-----------------------------------------------------------
   return(FromBufToDesc(HMEM_CTX_REF1 pBuf,Offset,DataLen,DstIndex,0,ppDstDesc));
}

/**
* Allocate new buffer make copy from given, put
* pointer/offset/length to a Descriptor Element (FromBufToDescAllocCopy).
* If no Descriptor given, a new one of specified size will be
* allocated
*
*  @param pBuf Buffer base
*  @param Offset Start of Data
*  @param DataLen Size of Data
*  @param ppDstDesc IN/OUT
*  @param DstIndex Element to load
*  @param DstAllocSize Number of Elements required
*
*  @return int Status, 0 - o.k., else Error occured
*/
static  int  FromBufToDescAllocCopy(char* pBuf, int Offset,
                                    int DataLen, IDATPARR** ppDstDesc, int DstIndex, int DstAllocSize)
{
   int Retcode;
   char* pNewBuf = NULL;
   //-----------------------------------------------------------
   // Check parameters
   //-----------------------------------------------------------
   if((pBuf == NULL) || (ppDstDesc == NULL))
      return(PKCS12_NULL_PTR);
   if(DstIndex < 0)
      return(PKCS12_PARAM_ERR);
   //-----------------------------------------------------------
   // Allocate new buffer, copy contents
   //-----------------------------------------------------------
   if(DataLen > 0)
   {
      if((pNewBuf = BIT8_ARRAY_ALLOC(HMEM_CTX_REF,DataLen)) == NULL)
         return(PKCS12_ALLOC_ERR);
      memcpy(pNewBuf+0,pBuf+Offset,DataLen);
   }
   //-----------------------------------------------------------
   // Check/Allocate Destination descriptor
   //-----------------------------------------------------------
   if((Retcode = CheckAllocDesc(ppDstDesc, DstIndex,
      DstAllocSize, NULL)) != PKCS12_OP_OK)
   {
      FREE_ARRAY(HMEM_CTX_REF,pNewBuf);
      return(Retcode);
   }
   //-----------------------------------------------------------
   // Put buffer to Destination Element, if already set, free it
   //-----------------------------------------------------------
   return(FromBufToDesc(HMEM_CTX_REF1 pNewBuf,0,DataLen,DstIndex,0,ppDstDesc));
}

/**
* Generate ASN.1 Type from given Buffer Data, put result to
* given / new Descriptor (ToASN1_BufToDesc). 
* If no destination descriptor is present,
* allocates a new one of given requested size.
* NOTE: This intended for wrapping a single data buffer !!
* -----
*
*  @param pBuf Data Buffer
*  @param Offset Start of Data
*  @param DataLen Size of Data
*  @param pCtlArray Assemble Control Array
*  @param CtlElementCnt Number of Control Elements
*  @param ppDstDesc IN/OUT
*  @param DstIndex Element to load
*  @param DstAllocSize Number of Elements required
*
*  @return int Status - ASN1_OP_OK: o.k.
* <br>            - else Error occured
*/
static  int  ToASN1_BufToDesc(char* pBuf, int Offset, int DataLen,
                              char * pCtlArray, int CtlElementCnt,
                              IDATPARR** ppDstDesc, int DstIndex, int DstAllocSize)
{
   int Retcode;
   int AllocFlag = 0;

   char* ppTmpBuf[1];
   int pTmpLen[1];

   IDATPARR* ppTmpDesc[1];

   //-----------------------------------------------------------
   // Check parameters
   //-----------------------------------------------------------
   if((pBuf == NULL) || (ppDstDesc == NULL) || (pCtlArray == NULL))
      return(PKCS12_NULL_PTR);
   if((DataLen < 0) || (DstIndex < 0))
      return(PKCS12_PARAM_ERR);
   //-----------------------------------------------------------
   // Put Source buffer to Descriptor
   //-----------------------------------------------------------
   ppTmpDesc[0] = NULL;					// force allocate
   if((Retcode = FromBufToDescAlloc(pBuf, Offset, DataLen,
      ppTmpDesc, 0, 1)) != PKCS12_OP_OK)
      return(Retcode);
   //-----------------------------------------------------------
   // Check/Allocate Destination descriptor
   //-----------------------------------------------------------
   if((Retcode = CheckAllocDesc(ppDstDesc, DstIndex,
      DstAllocSize, pTmpLen)) != PKCS12_OP_OK)
   {
      ppTmpDesc[0]->Flags &= (~FREE_BIT_MASK); // KEEP BUFFER !!!
      FreeIDATPARR_Struc(HMEM_CTX_REF1 ppTmpDesc[0]);
      return(Retcode);
   }
   AllocFlag = pTmpLen[0];
   //-----------------------------------------------------------
   // Generate ASN.1 Encoding
   //-----------------------------------------------------------
   Retcode = ToASN1(HMEM_CTX_REF1 ppTmpDesc[0]->ppArr,0,pCtlArray,CtlElementCnt,ppTmpBuf,pTmpLen);
   FreeIDATPARR_Struc(HMEM_CTX_REF1 ppTmpDesc[0]);
   if(Retcode != ASN1_OP_OK)
   {
      if(AllocFlag != 0)
      {
         FreeIDATPARR_Struc(HMEM_CTX_REF1 ppDstDesc[0]);
         ppDstDesc[0] = NULL;
      }
      return(Retcode);
   }
   //-----------------------------------------------------------
   // Put buffer to Destination Element, if already set, free it
   //-----------------------------------------------------------
   return(FromBufToDesc(HMEM_CTX_REF1 ppTmpBuf[0],0,pTmpLen[0],DstIndex,0,ppDstDesc));
}

/**
* Generate ASN.1 Type from given Descriptor, put result to
* given / new Descriptor (ToASN1_DescToDesc). 
* If no destination descriptor is present,
* allocates a new one of given requested size.
*
*  @param pSrcDesc Source of operation
*  @param SrcIndex Element Index to process
*  @param pCtlArray Assemble Control Array
*  @param CtlElementCnt Number of Control Elements
*  @param BaseErrorCode Error code to use
*  @param ppDstDesc IN/OUT
*  @param DstIndex Element to load
*  @param DstAllocSize Number of Elements required
*  @param pSubErrCode error from higher /NULL
*
*  @return int Status - ASN1_OP_OK: o.k.
* <br>            - else Error occured
*/
static  int  ToASN1_DescToDesc(IDATPARR* pSrcDesc,
                               int SrcIndex, char * pCtlArray, int CtlElementCnt,
                               int BaseErrorCode,
                               IDATPARR** ppDstDesc, int DstIndex, int DstAllocSize,
                               int* pSubErrCode)
{
   int Retcode;
   int AllocFlag = 0;

   char* ppTmpBuf[1];
   int pTmpLen[1];
   //-----------------------------------------------------------
   // Check parameters
   //-----------------------------------------------------------
   if((pSrcDesc == NULL) || (ppDstDesc == NULL) || (pCtlArray == NULL))
      return(PKCS12_NULL_PTR);
   if((SrcIndex < 0) || (DstIndex < 0) ||
      (SrcIndex >= pSrcDesc->Cnt))
      return(PKCS12_PARAM_ERR);
   //-----------------------------------------------------------
   // Check/Allocate Destination descriptor
   //-----------------------------------------------------------
   if((Retcode = CheckAllocDesc(ppDstDesc, DstIndex,
      DstAllocSize, pTmpLen)) != PKCS12_OP_OK)
      return(Retcode);
   AllocFlag = pTmpLen[0];
   //-----------------------------------------------------------
   // Generate ASN.1 Encoding
   //-----------------------------------------------------------
   if((Retcode = ToASN1(HMEM_CTX_REF1 pSrcDesc->ppArr,SrcIndex,pCtlArray,CtlElementCnt,ppTmpBuf,pTmpLen)) != ASN1_OP_OK)
   {
      if(AllocFlag != 0)
      {
         FreeIDATPARR_Struc(HMEM_CTX_REF1 ppDstDesc[0]);
         ppDstDesc[0] = NULL;
      }
      if(pSubErrCode != NULL)
         pSubErrCode[0] = Retcode;
      return(BaseErrorCode);
   }
   //-----------------------------------------------------------
   // Put buffer to Destination Element, if already set, free it
   //-----------------------------------------------------------
   return(FromBufToDesc(HMEM_CTX_REF1 ppTmpBuf[0],0,pTmpLen[0],DstIndex,0,ppDstDesc));
}

/**
* Extract Data Contents of a single object to internal notation
* ('Data Elements') from given ASN.1 Type, check if Data present (FromASN1_NonEmptyType).
*
* Primarily used for unwrapper e.g. SEQUENCE, SET which may not be
* empty in contrary to SEQUENCE OF, SET OF.
* 
* Note: Required Databuffer structure will be allocated and filled
* -----
*
*  @param InpBuf ASN.1 Datastream base
*  @param InpOffset Start of Data
*  @param InpLen Length of Data
*  @param pCtlArray Split Control Array
*  @param CtlElementCnt Number of Control Elements
*  @param DataElementCnt Number of Data Elements
*  @param BaseErrorCode Error Code to use
*  @param pDatArrayDesc Array Descriptor loaded with
*               Data Elements
*  @param SubErrCode Error from higher parser/NULL
*
*  @return int Status - ASN1_OP_OK: o.k.
* <br>            - else Error occured
*/
static  int  FromASN1_NonEmptyType(char* InpBuf, int InpOffset,
                                   int InpLen, char * pCtlArray, int CtlElementCnt,
                                   int DataElementCnt, int BaseErrorCode,
                                   IDATPARR** pDatArrayDesc, int* SubErrCode)
{
   int Retcode;
   IDATA* pIdata;
   //---------------------------------------------------------------
   // Decode the Data according to the given type
   //---------------------------------------------------------------
   if((Retcode = FromASN1_Type(HMEM_CTX_REF1 InpBuf,InpOffset,InpLen,pCtlArray,CtlElementCnt,DataElementCnt,BaseErrorCode,pDatArrayDesc,SubErrCode)) != ASN1_OP_OK)
      return(Retcode);
   //---------------------------------------------------------------
   // Check if data are emedded in object (first Element)
   //---------------------------------------------------------------
   pIdata = pDatArrayDesc[0]->ppArr[0];
   if((pIdata->Base == NULL) || (pIdata->Len == 0))
      return(BaseErrorCode);
   return(ASN1_OP_OK);
}

/**
* Extract Data Contents to internal notation ('Data Elements')
* from given ASN.1 encoded INTEGER (FromASN1_INTEGER).
* 
* Note: 1. Required Databuffer structure will be allocated and filled
* ----- 2. leading Zero byte is suppressed
*
*  @param InpBuf ASN.1 Datastream base
*  @param InpOffset Start of Data
*  @param InpLen Length of Data
*  @param ppDstDesc Array Descriptor loaded with
*               Data Elements
*  @param pSubErrCode Error from higher parser/NULL
*
*  @return int Status - ASN1_OP_OK: o.k.
* <br>            - else Error occured
*/
static  int  FromASN1_INTEGER(char* InpBuf, int InpOffset,
                              int InpLen, IDATPARR** ppDstDesc,
                              int* pSubErrCode)
{
   return(FromASN1_Type(HMEM_CTX_REF1 InpBuf,InpOffset,InpLen,(char *) ASN1IntegerCtl,ASN1_INTEGER_CTL_CNT,ASN1_INTEGER_MAX_DATA_INDEX,PKCS12_INTEGER_TO_INT_ERR,ppDstDesc,pSubErrCode));
}

/**
* Extract Data Contents to internal notation ('Data Elements')
* from given ASN.1 encoded OCTET String (FromASN1_OCTETSTR).
* 
* Note: Required Databuffer structure will be allocated and filled
* -----
*
*  @param InpBuf ASN.1 Datastream base
*  @param InpOffset Start of Data
*  @param InpLen Length of Data
*  @param ppDstDesc Array Descriptor loaded with
*               Data Elements
*  @param pSubErrCode Error from higher parser/NULL
*
*  @return int Status - ASN1_OP_OK: o.k.
* <br>            - else Error occured
*/
static  int  FromASN1_OCTETSTR(char* InpBuf, int InpOffset,
                               int InpLen, IDATPARR** ppDstDesc,
                               int* pSubErrCode)
{
   return(FromASN1_Type(HMEM_CTX_REF1 InpBuf,InpOffset,InpLen,(char *) ASN1OctetStrCtl,ASN1_OCTETSTR_CTL_CNT,ASN1_OCTETSTR_MAX_DATA_INDEX,PKCS12_OCTETSTR_TO_INT_ERR,ppDstDesc,pSubErrCode));
}
/**
* Extract Data Contents to internal notation ('Data Elements')
* from given ASN.1 encoded CONSTRUCTED OCTET String (FromASN1_CONST_OCTETSTR).
* 
* Note: Required Databuffer structure will be allocated and filled
* -----
*
*  @param InpBuf ASN.1 Datastream base
*  @param InpOffset Start of Data
*  @param InpLen Length of Data
*  @param ppDstDesc Array Descriptor loaded with
*               Data Elements
*  @param pSubErrCode Error from higher parser/NULL
*
*  @return int Status - ASN1_OP_OK: o.k.
* <br>            - else Error occured
*/
static  int  FromASN1_CONST_OCTETSTR(char* InpBuf, int InpOffset,
                                     int InpLen, IDATPARR** ppDstDesc,
                                     int* pSubErrCode)
{
   return(FromASN1_Type(HMEM_CTX_REF1 InpBuf,InpOffset,InpLen,(char *) ASN1ConstOctetStrCtl,ASN1_OCTETSTR_CTL_CNT,ASN1_OCTETSTR_MAX_DATA_INDEX,PKCS12_OCTETSTR_TO_INT_ERR,ppDstDesc,pSubErrCode));
}
/**
* Put Buffer Data to ASN.1 encoded OCTET String (ToASN1_BufToDescOCTETSTR).
* 
* Note: Required Databuffer structure will be allocated and filled
* -----
*
*  @param pBuf Data so store
*  @param Offset Start of Data
*  @param DataLen Length of Data
*  @param ppDstDesc Array Descriptor to load
*  @param DstIndex Slot to use
*  @param DstAllocSize Slots to alloc if needed
*
*  @return int Status - ASN1_OP_OK: o.k.
* <br>            - else Error occured
*/
static  int  ToASN1_BufToDescOCTETSTR(char* pBuf, int Offset,
                                      int DataLen, IDATPARR** ppDstDesc, int DstIndex,
                                      int DstAllocSize)
{
   return(ToASN1_BufToDesc(pBuf, Offset, DataLen,
      (char *) ASN1OctetStrCtl,ASN1_OCTETSTR_CTL_CNT,
      ppDstDesc, DstIndex, DstAllocSize));
}

/**
* Extract Data Contents to internal notation ('Data Elements')
* from given ASN.1 encoded SEQUENCE Object (may not be empty !) (FromASN1_SEQ).
* 
* Note: Required Databuffer structure will be allocated and filled
* -----
*
*  @param InpBuf ASN.1 Datastream base
*  @param InpOffset Start of Data
*  @param InpLen Length of Data
*  @param ppDstDesc Array Descriptor loaded with
*               Data Elements
*  @param pSubErrCode Error from higher parser/NULL
*
*  @return int Status - ASN1_OP_OK: o.k.
* <br>            - else Error occured
*/
static  int  FromASN1_SEQ(char* InpBuf, int InpOffset,
                          int InpLen, IDATPARR** ppDstDesc,
                          int* pSubErrCode)
{
   return(FromASN1_NonEmptyType(InpBuf, InpOffset, InpLen,
      (char *) ASN1_SequenceCtl,
      ASN1_SEQUENCE_CTL_CNT,
      ASN1_SEQUENCE_MAX_DATA_INDEX,
      PKCS12_SEQUENCE_TO_INT_ERR,
      ppDstDesc, pSubErrCode));
}
/**
* Extract Data Contents to internal notation ('Data Elements')
* from given ASN.1 encoded SEQUENCE OF Object (*may* be empty !) (FromASN1_SEQUENCE_OF).
* 
* Note: Required Databuffer structure will be allocated and filled
* -----
*
*  @param InpBuf ASN.1 Datastream base
*  @param InpOffset Start of Data
*  @param InpLen Length of Data
*  @param ppDstDesc Array Descriptor loaded with
*               Data Elements
*  @param pSubErrCode Error from higher parser/NULL
*
*  @return int Status - ASN1_OP_OK: o.k.
* <br>            - else Error occured
*/
static  int  FromASN1_SEQUENCE_OF(char* InpBuf, int InpOffset,
                                  int InpLen, IDATPARR** ppDstDesc,
                                  int* pSubErrCode)
{
   return(FromASN1_Type(HMEM_CTX_REF1 InpBuf,InpOffset,InpLen,(char *) ASN1_SequenceCtl,ASN1_SEQUENCE_CTL_CNT,ASN1_SEQUENCE_MAX_DATA_INDEX,PKCS12_SEQUENCE_OF_TO_INT_ERR,ppDstDesc,pSubErrCode));
}

/**
* Put Buffer Data to ASN.1 encoded SEQUENCE String (ToASN1_BufToDescSEQ).
* 
* Note: Required Destination structure will be allocated/filled
* -----
*
*  @param pBuf Data so store
*  @param Offset Start of Data
*  @param DataLen Length of Data
*  @param ppDstDesc Array Descriptor to load
*  @param DstIndex Slot to use
*  @param DstAllocSize Slots to alloc if needed
*
*  @return int Status - ASN1_OP_OK: o.k.
* <br>            - else Error occured
*/
static  int  ToASN1_BufToDescSEQ(char* pBuf, int Offset,
                                 int DataLen, IDATPARR** ppDstDesc, int DstIndex,
                                 int DstAllocSize)
{
   return(ToASN1_BufToDesc(pBuf, Offset, DataLen,
      (char *) ASN1_SequenceCtl,ASN1_SEQUENCE_CTL_CNT,
      ppDstDesc, DstIndex, DstAllocSize));
}

/**
* Extract Data Contents to internal notation ('Data Elements')
* from given ASN.1 encoded SET OF Object (*may* be empty !) (FromASN1_SET_OF).
* 
* Note: Required Databuffer structure will be allocated and filled
* -----
*
*  @param InpBuf ASN.1 Datastream base
*  @param InpOffset Start of Data
*  @param InpLen Length of Data
*  @param ppDstDesc Array Descriptor loaded with
*               Data Elements
*  @param pSubErrCode Error from higher parser/NULL
*
*  @return int Status - ASN1_OP_OK: o.k.
* <br>            - else Error occured
*/
static  int  FromASN1_SET_OF(char* InpBuf, int InpOffset,
                             int InpLen, IDATPARR** ppDstDesc,
                             int* pSubErrCode)
{
   return(FromASN1_Type(HMEM_CTX_REF1 InpBuf,InpOffset,InpLen,(char *) ASN1_SetCtl,ASN1_SET_CTL_CNT,ASN1_SET_MAX_DATA_INDEX,PKCS12_SET_OF_TO_INT_ERR,ppDstDesc,pSubErrCode));
}

/**
* Put Buffer Data to ASN.1 encoded SET String (ToASN1_BufToDescSET).
* 
* Note: Required Destination structure will be allocated/filled
* -----
*
*  @param pBuf Data so store
*  @param Offset Start of Data
*  @param DataLen Length of Data
*  @param ppDstDesc Array Descriptor to load
*  @param DstIndex Slot to use
*  @param DstAllocSize Slots to alloc if needed
*
*  @return int Status - ASN1_OP_OK: o.k.
* <br>            - else Error occured
*/
static  int  ToASN1_BufToDescSET(char* pBuf, int Offset,
                                 int DataLen, IDATPARR** ppDstDesc, int DstIndex,
                                 int DstAllocSize)
{
   return(ToASN1_BufToDesc(pBuf, Offset, DataLen,
      (char *) ASN1_SetCtl,ASN1_SET_CTL_CNT,
      ppDstDesc, DstIndex, DstAllocSize));
}

/**
* Extract Data Contents to internal notation ('Data Elements')
* from given ASN.1 encoded ANY Object (*may* be empty !) (FromASN1_ANY_OBJ).
* 
* Note: Required Databuffer structure will be allocated and filled
* -----
*
*  @param InpBuf ASN.1 Datastream base
*  @param InpOffset Start of Data
*  @param InpLen Length of Data
*  @param ppDstDesc Array Descriptor loaded with
*               Data Elements
*  @param pSubErrCode Error from higher parser/NULL
*
*  @return int Status - ASN1_OP_OK: o.k.
* <br>            - else Error occured
*/
static  int  FromASN1_ANY_OBJ(char* InpBuf, int InpOffset,
                              int InpLen, IDATPARR** ppDstDesc,
                              int* pSubErrCode)
{
   return(FromASN1_Type(HMEM_CTX_REF1 InpBuf,InpOffset,InpLen,(char *) ASN1_AnyFromCtl,ASN1_ANY_CTL_CNT,ASN1_ANY_MAX_DATA_INDEX,PKCS12_ANY_ASN1_TO_INT_ERROR,ppDstDesc,pSubErrCode));
}
/**
* Extract Data Contents to internal notation ('Data Elements')
* from given ASN.1 encoded ANY OF Object (may *NOT* be empty !) (FromASN1_ANY_OF_OBJ).
* 
* Note: Required Databuffer structure will be allocated and filled
* -----
*
*  @param InpBuf ASN.1 Datastream base
*  @param InpOffset Start of Data
*  @param InpLen Length of Data
*  @param ppDstDesc Array Descriptor loaded with
*               Data Elements
*  @param pSubErrCode Error from higher parser/NULL
*
*  @return int Status - ASN1_OP_OK: o.k.
* <br>            - else Error occured
*/
static  int  FromASN1_ANY_OF_OBJ(char* InpBuf, int InpOffset,
                                 int InpLen, IDATPARR** ppDstDesc,
                                 int* pSubErrCode)
{
   return(FromASN1_NonEmptyType(InpBuf, InpOffset, InpLen,
      (char *) ASN1_AnyCtl,ASN1_ANY_CTL_CNT,
      ASN1_ANY_MAX_DATA_INDEX,
      PKCS12_ANY_OF_ASN1_TO_INT_ERROR,
      ppDstDesc, pSubErrCode));
}

/**
* Subroutine FromASN1_UniversalEmbeddedTypes decodes ASN.1 encoded
* Subtypes of same Structure embedded in a given ASN.1
* embedding structure of Universal Type  array of internal structure (FromASN1_UniversalEmbeddedType).
* At the Moment the following universal embedding types are
* implemented:
* - ASN.1 NULL			-- *NOT* embedded
* - ASN.1 OCTETSTRING		-- may be empty
* - ASN.1 SEQUENCE		-- may *NOT* be empty
* - ASN.1 SEQUENCE OF		-- may be empty
* - ASN.1 SET			-- may *NOT* be empty
* - ASN.1 SET OF		-- may be empty
* - ASN.1 ANY			-- may be empty
* - ASN.1 ANY OF		-- may *NOT be empty
*
* Note: Required Databuffer structure will be allocated and filled
* -----
*
*  @param pInpBuf ASN.1 Datastream base
*  @param InpOffset Start of Data
*  @param InpLen Length of Data
*  @param EmbeddingASN1 Type of Envelope used
*  @param EmptyAllowed 0 - must have data, else can
*  @param UseConstruct 0 - only 'pure' objects
*  @param pCtlArray Split Control Array
*  @param CtlElementCnt Number of Control Elements
*  @param DataElementCnt Number of Data Elements
*  @param BaseErrorCode Error Code to use
*  @param pDatArrayDesc Array Descriptor loaded with
*               Data Elements
*  @param pDatArraySize Number of Elements loaded
*  @param SubErrCode Error from higher parser/NULL
*
*  @return int Status - ASN1_OP_OK: o.k.
* <br>            - else Error occured
*/
static  int  FromASN1_UniversalEmbeddedType(char* pInpBuf,
                                            int InpOffset, int InpLen, int EmbeddingASN1,
                                            int EmptyAllowed, int UseConstruct,
                                            char * pCtlArray, int CtlElementCnt,
                                            int DataElementCnt, int BaseErrorCode,
                                            IDATPARR** pDatArrayDesc,
                                            int* pDatArraySize, int* SubErrCode)
{
   int Retcode;
   int pTmpRet[1];

   IDATA* pIdata;
   IDATPARR* ppTmpDesc[1];
   //-----------------------------------------------------
   // Check Parameters first, may be removed later
   //-----------------------------------------------------
   if((pInpBuf == NULL) || (pCtlArray == NULL) ||
      (pDatArrayDesc == NULL) || (pDatArraySize == NULL))
      return(PKCS12_NULL_PTR);
   if(InpLen < 0)
      return(PKCS12_PARAM_ERR);

   pDatArrayDesc[0] = NULL;
   pDatArraySize[0] = 0;
   //-----------------------------------------------------
   // Strip Surrounding Embedding Object if given
   //-----------------------------------------------------
   ppTmpDesc[0] = NULL;
   Retcode = ASN1_OP_OK;
   switch(EmbeddingASN1)
   {
      //--------------------------------------------------------
      // Elements are *NOT* embedded, but given direct
      //--------------------------------------------------------
   case ASN1_UNIVERSAL_NULL:
      break;
      //--------------------------------------------------------
      // Data embedded in ANY Object, Strip surrounding Object
      //--------------------------------------------------------
   case ASN1_UNIVERSAL_EOC:
      if(EmptyAllowed == 0)
         Retcode = FromASN1_ANY_OBJ(pInpBuf,InpOffset,InpLen,
         ppTmpDesc,pTmpRet);
      else
         Retcode = FromASN1_ANY_OF_OBJ(pInpBuf,InpOffset,InpLen,
         ppTmpDesc,pTmpRet);
      break;
      //--------------------------------------------------------
      // Elements embedded in ASN.1 OCTET String, unwrap
      //--------------------------------------------------------
   case ASN1_UNIVERSAL_OCTETSTRING:
      if(UseConstruct == 0)
         Retcode = FromASN1_OCTETSTR(pInpBuf, InpOffset, InpLen,
         ppTmpDesc, pTmpRet);
      else
         Retcode = FromASN1_CONST_OCTETSTR(pInpBuf, InpOffset, InpLen,
         ppTmpDesc, pTmpRet);
      break;
      //--------------------------------------------------------
      // Elements embedded in ASN.1 SEQUENCE/SEQUENCE OF, unwrap
      //--------------------------------------------------------
   case ASN1_UNIVERSAL_SEQUENCE:
      if(EmptyAllowed == 0)
         Retcode = FromASN1_SEQ(pInpBuf, InpOffset, InpLen,
         ppTmpDesc, pTmpRet);
      else
         Retcode = FromASN1_SEQUENCE_OF(pInpBuf, InpOffset, InpLen,
         ppTmpDesc, pTmpRet);
      break;
      //--------------------------------------------------------
      // Elements embedded in ASN.1 SET/SET OF, unwrap
      //--------------------------------------------------------
   case ASN1_UNIVERSAL_SET:
      Retcode = FromASN1_SET_OF(pInpBuf, InpOffset, InpLen,
         ppTmpDesc, pTmpRet);
      break;

   default:
      Retcode = PKCS12_UNSUPP_EMBEDDED_TYPE;
      break;
   }        
   //----------------------------------------------------------
   // Check if unwrapping succeeded so far
   //----------------------------------------------------------
   if(Retcode != ASN1_OP_OK)
      return(Retcode);
   //----------------------------------------------------------
   // Uwrapping succeeded, get (possibly) *NEW* data start/Len
   //----------------------------------------------------------
   if(ppTmpDesc[0] != NULL)
   {
      pIdata = ppTmpDesc[0]->ppArr[0];
      pInpBuf   = pIdata->Base;
      InpOffset = (int) pIdata->Off;
      InpLen    = pIdata->Len;
      FreeIDATPARR_Struc(HMEM_CTX_REF1 ppTmpDesc[0]);	 // not longer needed
   }
   //-------------------------------------------------------------
   // Unwrapping (if done) succeeded, check if still data present
   //-------------------------------------------------------------
   if((pInpBuf == NULL) || (InpLen == 0))
   {
      if(EmptyAllowed == 0)
         return(PKCS12_UNIVERSAL_UNWRAP_NO_DATA);
      return(PKCS12_OP_OK);
   }
   //-------------------------------------------------------------
   // Data are available, subdecode the elements
   //-------------------------------------------------------------
   if((Retcode = FromASN1_SubStr(HMEM_CTX_REF1 pInpBuf,InpOffset,InpLen,pCtlArray,CtlElementCnt,DataElementCnt,pDatArrayDesc,pDatArraySize)) == ASN1_OP_OK)
      return(Retcode);
   if(SubErrCode != NULL)
      SubErrCode[0] = Retcode;
   return(BaseErrorCode);
}  
/**
* Subroutine ToASN1_UniversalEmbeddedTypes encodes array of
* Data in internal notation to ASN.1 encoded Subtypes of same
* Structure and embeds them in a given ASN.1 structure of
* Universal Type (ToASN1_UniversalEmbeddedType).
* At the Moment the following universal embedding types are
* implemented:
* - ASN.1 NULL			-- *NOT* embedded
* - ASN.1 OCTETSTRING		-- may be empty
* - ASN.1 SEQUENCE		-- may *NOT* be empty
* - ASN.1 SEQUENCE OF		-- may be empty
* - ASN.1 SET			-- may *NOT* be empty
* - ASN.1 SET OF		-- may be empty
*
* Note: Required Databuffer structure will be allocated and filled
* -----
*
*  @param pSrcDesc Descriptor containing SubElem.
*  @param EmbeddingASN1 Type of Envelope to use
*  @param EmptyAllowed 0 - must have data, else can
*  @param pCtlArray Split Control Array
*  @param CtlElementCnt Number of Control Elements
*  @param DataElementCnt Number of Sub Data Elements
*  @param BaseErrorCode Error Code to use
*  @param ppDstDesc Array Descriptor to load
*  @param DstIndex Slot Index to use
*               int AllocCnt Number of slots to allocate
*  @param pSubErrCode Error from higher parser/NULL
*
*  @return int Status - ASN1_OP_OK: o.k.
* <br>            - else Error occured
*/
static  int  ToASN1_UniversalEmbeddedType(IDATPARR* pSrcDesc,
                                          int EmbeddingASN1, int EmptyAllowed,
                                          char * pCtlArray, int CtlElementCnt,
                                          int DataElementCnt, int BaseErrorCode,
                                          IDATPARR** ppDstDesc, int DstIndex, int DstAllocSize,
                                          int* pSubErrCode)
{
   int Retcode;
   int DstLen = 0;
   int SrcCnt = 0;
   int pTmpLen[1];
   char* ppTmpBuf[1];
   char* pDstBuf = NULL;

   //  IDATA_PTR pIdata;
   IDATA** ppArr;
   //  IDATPARR_PTR_ARRAY(ppTmpDesc,1);
   //-----------------------------------------------------
   // Check Parameters first, may be removed later
   //-----------------------------------------------------
   if((pCtlArray == NULL) || (ppDstDesc == NULL))
      return(PKCS12_NULL_PTR);
   //-------------------------------------------------------------
   // Check if Input Data are given for the Substrings
   //-------------------------------------------------------------
   if((pSrcDesc != NULL) && ((ppArr = pSrcDesc->ppArr) != NULL) &&
      ((SrcCnt = pSrcDesc->Cnt) > 0))
   {
      //-------------------------------------------------------------
      // Data are available, subencode the elements
      //-------------------------------------------------------------
      if((Retcode = ToASN1_SubStr(HMEM_CTX_REF1 ppArr,0,SrcCnt,pCtlArray,CtlElementCnt,DataElementCnt,ppTmpBuf,pTmpLen)) != ASN1_OP_OK)
      {
         if(pSubErrCode != NULL)
            pSubErrCode[0] = Retcode;
         return(BaseErrorCode);
      }
      pDstBuf = ppTmpBuf[0];
      DstLen  = pTmpLen[0];
   }
   else
   {
      //-------------------------------------------------------------
      // No Data are available, check if allowed
      //-------------------------------------------------------------
      if(EmptyAllowed == 0)
         return(BaseErrorCode);
   }
   //-----------------------------------------------------------
   // Check if an Embedding object is needed at all
   //-----------------------------------------------------------
   if(EmbeddingASN1 == ASN1_UNIVERSAL_NULL)
   {
      //-----------------------------------------------------------
      // No embedding needed, Check/Allocate Destination descriptor
      //-----------------------------------------------------------
      if((Retcode = FromBufToDescAlloc(pDstBuf, 0, DstLen,
         ppDstDesc, DstIndex,
         DstAllocSize)) != PKCS12_OP_OK)
         FREE_ARRAY(HMEM_CTX_REF,pDstBuf);
      return(Retcode);
   }
   //-----------------------------------------------------
   // Element has to be embedded, check how
   //-----------------------------------------------------
   Retcode = ASN1_OP_OK;
   switch(EmbeddingASN1)
   {
      //--------------------------------------------------------
      // Elements embedded in ASN.1 OCTET String, wrap
      //--------------------------------------------------------
   case ASN1_UNIVERSAL_OCTETSTRING:
      Retcode = ToASN1_BufToDescOCTETSTR(pDstBuf, 0, DstLen,
         ppDstDesc,DstIndex, DstAllocSize);
      break;
      //--------------------------------------------------------
      // Elements embedded in ASN.1 SEQUENCE/SEQUENCE OF, unwrap
      //--------------------------------------------------------
   case ASN1_UNIVERSAL_SEQUENCE:
      Retcode = ToASN1_BufToDescSEQ(pDstBuf, 0, DstLen,
         ppDstDesc, DstIndex, DstAllocSize);
      break;
      //--------------------------------------------------------
      // Elements embedded in ASN.1 SET/SET OF, unwrap
      //--------------------------------------------------------
   case ASN1_UNIVERSAL_SET:
      Retcode = ToASN1_BufToDescSET(pDstBuf, 0, DstLen,
         ppDstDesc, DstIndex, DstAllocSize);
      break;

   default:
      Retcode = PKCS12_UNSUPP_EMBEDDED_TYPE;
      break;
   }        
   //----------------------------------------------------------
   // Check if wrapping succeede
   //----------------------------------------------------------
   if(Retcode != ASN1_OP_OK)
      FREE_ARRAY(HMEM_CTX_REF,pDstBuf);
   return(Retcode);
}  

/**
* Unwrap constructed Contents to internal notation ('Data Elements')
* from given ASN.1 encoded Array of OCTET Strings (UnwrapASN1_BER_OCTETSTR).
* - Allocate buffer for concatenation
* - concatenate all subtypes to a single element
* 
* Note: Required Databuffer structure will be allocated and filled
* -----
*
*  @param InpBuf ASN.1 Datastream base
*  @param InpOffset Start of Data
*  @param InpLen Length of Data
*  @param pDatArrayDesc Array Descriptor loaded with
*               Data Elements
*  @param SubErrCode Error from higher parser/NULL
*
*  @return int Status - ASN1_OP_OK: o.k.
* <br>            - else Error occured
*/
static  int  UnwrapASN1_BER_OCTETSTR(char* InpBuf, int InpOffset,
                                     int InpLen, IDATPARR** pDatArrayDesc,
                                     int* SubErrCode)
{
   int Retcode, Index, Count, BufSize, DstOff;
   char* pBuf;

   int pTmpLen[1];
   IDATA* pIdata;
   IDATA** ppArr;
   IDATPARR* ppTmpDesc[1];
   //----------------------------------------------------------
   // Subdecode the Octetstrings
   //----------------------------------------------------------
   if((Retcode = FromASN1_UniversalEmbeddedType(InpBuf, InpOffset, InpLen,
      ASN1_UNIVERSAL_NULL, 0, 0,
      (char *) ASN1OctetStrCtl,ASN1_OCTETSTR_CTL_CNT,
      ASN1_OCTETSTR_MAX_DATA_INDEX,
      PKCS12_OCTETSTR_TO_INT_ERR,
      ppTmpDesc, pTmpLen, SubErrCode)) != PKCS12_OP_OK)
      return(Retcode);
   //----------------------------------------------------------
   // Get total size of all embedded elements
   //----------------------------------------------------------
   ppArr = ppTmpDesc[0]->ppArr;
   BufSize = 0;
   Index = 0;
   Count = pTmpLen[0];

   while(Index < Count)
   {
      pIdata = ppArr[Index++];
      if((pIdata != NULL) && (pIdata->Len > 0))
         BufSize += pIdata->Len;
   }
   //----------------------------------------------------------
   // Allocate buffer
   //----------------------------------------------------------
   if((pBuf = BIT8_ARRAY_ALLOC(HMEM_CTX_REF,BufSize)) == NULL)
   {
      FreeIDATPARR_Struc(HMEM_CTX_REF1 ppTmpDesc[0]);
      return(PKCS12_ALLOC_ERR);
   }
   //----------------------------------------------------------
   // Copy Elements to the Buffer
   //----------------------------------------------------------
   Index = 0;
   DstOff = 0;
   while(Index < Count)
   {
      pIdata = ppArr[Index++];
      if((pIdata != NULL) && (pIdata->Len > 0))
      {
         memcpy(pBuf+DstOff,pIdata->Base+(int) pIdata->Off,pIdata->Len);
         DstOff += pIdata->Len;
      }
   }
   FreeIDATPARR_Struc(HMEM_CTX_REF1 ppTmpDesc[0]);
   //----------------------------------------------------------
   // Allocate a Descriptor structure
   //----------------------------------------------------------
   if((Retcode = AllocIDATPARR_Struc(HMEM_CTX_REF1 pDatArrayDesc,1)) != ASN1_OP_OK)
   {
      FREE_ARRAY(HMEM_CTX_REF,pBuf);
      return(Retcode);
   }
   pDatArrayDesc[0]->Flags |= FREE_BIT_MASK;
   pIdata = pDatArrayDesc[0]->ppArr[0];
   pIdata->Base = pBuf;
   pIdata->Off  = 0;
   pIdata->Len  = BufSize;
   return(Retcode);
}

/**
* Extract Data Contents to internal notation ('Data Elements')
* from given ASN.1 encoded BER Encoded OCTET String (FromASN1_BER_OCTETSTR).
* The Octet string may either be Simple OR constructed
* - Inspect the TAG for constructed
* - Strip the Constructing ASN1.ID
* - Subsplit into OCTET Strings
* - Allocate buffer for concatenation
* - concatenate all subtypes to a single element
* 
* Note: Required Databuffer structure will be allocated and filled
* -----
*
*  @param InpBuf ASN.1 Datastream base
*  @param InpOffset Start of Data
*  @param InpLen Length of Data
*  @param pDatArrayDesc Array Descriptor loaded with
*               Data Elements
*  @param SubErrCode Error from higher parser/NULL
*
*  @return int Status - ASN1_OP_OK: o.k.
* <br>            - else Error occured
*/
static  int  FromASN1_BER_OCTETSTR(char* InpBuf, int InpOffset,
                                   int InpLen, IDATPARR** pDatArrayDesc,
                                   int* SubErrCode)
{
   int Retcode;

   IDATA* pIdata;
   IDATPARR* ppTmpDesc[1];
   //--------------------------------------------------------
   // Check ASN.1 Tag if Constructed
   //--------------------------------------------------------
   if(InpBuf == NULL)
      return(PKCS12_NULL_PTR);
   if(InpLen <= 0)
      return(PKCS12_PARAM_ERR);

   if((InpBuf[InpOffset] & ASN1_CONSTRUCTED) == 0)  
   {
      //--------------------------------------------------------
      // Not constructed, decode direct
      //--------------------------------------------------------
      return(FromASN1_OCTETSTR(InpBuf, InpOffset, InpLen,
         pDatArrayDesc, SubErrCode));
   }
   //----------------------------------------------------------
   // is constructed, remove embedding CONSTRUCTED OCTETSTRING
   //----------------------------------------------------------
   if((Retcode = FromASN1_CONST_OCTETSTR(InpBuf, InpOffset, InpLen,
      ppTmpDesc, SubErrCode)) != PKCS12_OP_OK)
      return(Retcode);
   //----------------------------------------------------------
   // Construct a new, local allocated Element Descriptor now
   //----------------------------------------------------------
   pIdata = ppTmpDesc[0]->ppArr[0];
   Retcode = UnwrapASN1_BER_OCTETSTR(
      pIdata->Base,
      (int) pIdata->Off,
      pIdata->Len,
      pDatArrayDesc,
      SubErrCode);
   FreeIDATPARR_Struc(HMEM_CTX_REF1 ppTmpDesc[0]);
   return(Retcode);
}

//***********************************************************************
//***********************************************************************
//***********************************************************************

/**
* Subroutine FromASN1_PFX_PDU generates data structures in internal
* notation ('Data Elements') from given ASN.1 encoded 
* PKCS12 V3 PFX PDU input byte stream (FromASN1_PFX_PDU). 
*The PFX PDU is split into:
* 1.     Version (Integer)
* 2.     authSafe:
* 2.1.   authSafe Content Type OID
* 2.2.   authSafe Content Data (Any ASN.1)
* 3.     macData: (Optional)
* 3.1.   DigestInfo:
* 3.1.1. Digest Algor OID
* 3.1.2. Digest Algor Params (Optional)
* 3.1.3. Digest Data
* 3.2.	  macSalt
* 3.3.   iterationCount
* 
*  @param InpBuf ASN.1 Datastream base
*  @param InpOffset Start of Data
*  @param InpLen Length of Data
*  @param ppDstDesc Array Descriptor loaded with
*               Data Elements
*  @param pSubErrCode Error from higher parser/NULL
*  @return int Status, 0 - o.k., else error occured
*/
static  int  FromASN1_PFX_PDU(char* InpBuf, int InpOffset,
                              int InpLen, IDATPARR** ppDstDesc,
                              int* pSubErrCode)
{
   return(FromASN1_Type(HMEM_CTX_REF1 InpBuf,InpOffset,InpLen,(char *) PKCS12PfxPDUCtl,PKCS12_PFX_PDU_CTL_CNT,PKCS12_PFX_PDU_MAX_DATA_INDEX,PKCS12_PFX_PDU_TO_INT_ERR,ppDstDesc,pSubErrCode));
}

/**
* Subroutine ToASN1_PFX_PDU generates ASN.1 encoded 
* PKCS12 V3 PFX PDU byte stream from data structures in internal
* notation ('Data Elements') (ToASN1_PFX_PDU_Desc). 
* The PFX PDU is built from:
* 1.     Version (Integer)
* 2.     authSafe:
* 2.1.   authSafe Content Type OID
* 2.2.   authSafe Content Data (Any ASN.1)
* 3.     macData: (Optional)
* 3.1.   DigestInfo:
* 3.1.1. Digest Algor OID
* 3.1.2. Digest Algor Params (Optional)
* 3.1.3. Digest Data
* 3.2.	  macSalt
* 3.3.   iterationCount
* 
*  @param pSrcDesc Source with elements
*  @param SrcIndex Slot to start with
*  @param ppDstDesc Array Slot loaded with Result 
*  @param DstIndex Slot to use
*  @param DstAllocSize Needed slots if allocate
*  @param pSubErrCode Error from higher parser/NULL
*  @return int Status, 0 - o.k., else error occured
*/
static  int  ToASN1_PFX_PDU_Desc(IDATPARR* pSrcDesc,int SrcIndex,
                                 IDATPARR** ppDstDesc, int DstIndex, int DstAllocSize,
                                 int* pSubErrCode)
{
   return(ToASN1_DescToDesc(pSrcDesc, SrcIndex,
      (char *) PKCS12PfxPDUCtl,PKCS12_PFX_PDU_CTL_CNT,
      PKCS12_PFX_PDU_FROM_INT_ERR,
      ppDstDesc, DstIndex, DstAllocSize, pSubErrCode));
}
/**
* Subroutine FromASN1_PFX_PFX generates data structures in internal
* notation ('Data Elements') from given ASN.1 encoded 
* PKCS12 V1 PFX PDU input byte stream (FromASN1_PFX_PFX).
* The PFX PDU is split into:
* 1.     MacData ETAG[0] (Optional):
* 1.1.	  SafeMac (DigestInfo):
* 1.1.1  Digest Algor OID
* 1.1.2. Digest Algor Params (Optional)
* 1.1.3. Digest Data
* 1.2.	  macSalt
* 2.     authSafe ETAG[1] (ContentInfoBODY !! [no Surrounding SEQ]):
* 2.1.   authSafe Content Type OID
* 2.2.   authSafe Content Data (Any ASN.1)
* 
*  @param InpBuf ASN.1 Datastream base
*  @param InpOffset Start of Data
*  @param InpLen Length of Data
*  @param ppDstDesc Array Descriptor loaded with
*               Data Elements
*  @param pSubErrCode Error from higher parser/NULL
*  @return int Status, 0 - o.k., else error occured
*/
static  int  FromASN1_PFX_PFX(char* InpBuf, int InpOffset,
                              int InpLen, IDATPARR** ppDstDesc,
                              int* pSubErrCode)
{
   return(FromASN1_Type(HMEM_CTX_REF1 InpBuf,InpOffset,InpLen,(char *) PFX_PfxPDUCtl,PFX_PFX_PDU_CTL_CNT,PKCS12_PFX_PDU_MAX_DATA_INDEX,PKCS12_PFX_PFX_TO_INT_ERR,ppDstDesc,pSubErrCode));
}
/**
* Subroutine ToASN1_PFX_PFX_Desc generates ASN.1 encoded 
* PKCS12 V1 PFX PDU byte stream from data structures in internal
* notation ('Data Elements') (ToASN1_PFX_PFX_Desc). 
* The PFX PDU is built from:
* 1.     MacData ETAG[0] (Optional):
* 1.1.	  SafeMac (DigestInfo):
* 1.1.1  Digest Algor OID
* 1.1.2. Digest Algor Params (Optional)
* 1.1.3. Digest Data
* 1.2.	  macSalt
* 2.     authSafe ETAG[1] (ContentInfoBODY !! [no Surrounding SEQ]):
* 2.1.   authSafe Content Type OID
* 2.2.   authSafe Content Data (Any ASN.1)
* 
*  @param pSrcDesc Source with elements
*  @param SrcIndex Slot to start with
*  @param ppDstDesc Array Slot loaded with Result 
*  @param DstIndex Slot to use
*  @param DstAllocSize Needed slots if allocate
*  @param pSubErrCode Error from higher parser/NULL
*  @return int Status, 0 - o.k., else error occured
*/
static  int  ToASN1_PFX_PFX_Desc(IDATPARR* pSrcDesc,int SrcIndex,
                                 IDATPARR** ppDstDesc, int DstIndex, int DstAllocSize,
                                 int* pSubErrCode)
{
   return(ToASN1_DescToDesc(pSrcDesc, SrcIndex,
      (char *) PFX_PfxPDUCtl,PFX_PFX_PDU_CTL_CNT,
      PKCS12_PFX_PFX_FROM_INT_ERR,
      ppDstDesc, DstIndex, DstAllocSize, pSubErrCode));
}
/**
* Subroutine FromASN1_PFX_AuthSafe generates data structures in internal
* notation ('Data Elements') from given ASN.1 encoded 
* PKCS12 V1 AuthenticatedSafe input byte stream (FromASN1_PFX_AuthSafe). 
* The AuthenticatedSafe
* is split into:
* 1.     Version INT (Optional) DEFAULT 1
* 2.     TransportMode OID (Optional) DEFAULT off-lineTransportMode
* 3.     PrivacySalt BITSTR (Optional)
* 4.	  Baggage SET (Optional):
* 4.1.   BaggegeItems
* 5.	  safe ContentInfo:
* 5.1.   Safe Content Type OID
* 5.2.   Safe Content Data (Any ASN.1)
* 
*  @param InpBuf ASN.1 Datastream base
*  @param InpOffset Start of Data
*  @param InpLen Length of Data
*  @param ppDstDesc Array Descriptor loaded with
*               Data Elements
*  @param pSubErrCode Error from higher parser/NULL
*  @return int Status, 0 - o.k., else error occured
*/
static  int  FromASN1_PFX_AuthSafe(char* InpBuf, int InpOffset,
                                   int InpLen, IDATPARR** ppDstDesc,
                                   int* pSubErrCode)
{
   return(FromASN1_Type(HMEM_CTX_REF1 InpBuf,InpOffset,InpLen,(char *) PFXAuthSafeCtl,PFX_AUTHSAFE_CTL_CNT,PFX_AUTHSAFE_MAX_DATA_INDEX,PFX_AUTHSAFE_TO_INT_ERR,ppDstDesc,pSubErrCode));
}
/**
* Subroutine ToASN1_PFX_AuthSafeDesc generates ASN.1 encoded
* PKCS12 V1 AuthenticatedSafe byte stream from data structures
* in internal notation ('Data Elements') (ToASN1_PFX_AuthSafeDesc). 
* The AuthenticatedSafe
* is built drom:
* 1.     Version INT (Optional) DEFAULT 1
* 2.     TransportMode OID (Optional) DEFAULT off-lineTransportMode
* 3.     PrivacySalt BITSTR (Optional)
* 4.	  Baggage SET (Optional):
* 4.1.   BaggegeItems
* 5.	  safe ContentInfo:
* 5.1.   Safe Content Type OID
* 5.2.   Safe Content Data (Any ASN.1)
* 
*  @param pSrcDesc Source with elements
*  @param SrcIndex Slot to start with
*  @param ppDstDesc Array Slot loaded with Result 
*  @param DstIndex Slot to use
*  @param DstAllocSize Needed slots if allocate
*  @param pSubErrCode Error from higher parser/NULL
*  @return int Status, 0 - o.k., else error occured
*/
static  int  ToASN1_PFX_AuthSafeDesc(IDATPARR* pSrcDesc,
                                     int SrcIndex, IDATPARR** ppDstDesc, int DstIndex,
                                     int DstAllocSize, int* pSubErrCode)
{
   return(ToASN1_DescToDesc(pSrcDesc, SrcIndex,
      (char *) PFXAuthSafeCtl,PFX_AUTHSAFE_CTL_CNT,
      PFX_AUTHSAFE_FROM_INT_ERR,
      ppDstDesc, DstIndex, DstAllocSize, pSubErrCode));
}
/**
* Subroutine FromASN1_PKCS12AuthenticatedSafe decodes a
* Sequence of ASN.1 encoded Content Infos to Array of their
* Content Type and Contents in internal Notation ('Data Elements') (FromASN1_PKCS12AuthentSafe).
* Each Element is Split into
* 1.     ContentType (OID)
* 2.     Content (ETAG[0]) Any
* 
*  @param InpBuf ASN.1 Datastream base
*  @param InpOffset Start of Data
*  @param InpLen Length of Data
*  @param ppDstDesc Array Descriptor loaded with
*               Data Elements
*  @param pDatArraySize Number of Elements loaded
*  @param pSubErrCode Error from higher parser/NULL
*
*  @return int Status - ASN1_OP_OK: o.k.
* <br>            - else Error occured
*/
static  int  FromASN1_PKCS12AuthentSafe(char* InpBuf,
                                        int InpOffset, int InpLen, IDATPARR** ppDstDesc,
                                        int* pDatArraySize, int* pSubErrCode)
{
   //--------------------------------------------------------------
   // Strip SEQUENCE OF, subdecode the embedded ContentInfos
   //--------------------------------------------------------------
   return(FromASN1_UniversalEmbeddedType(InpBuf, InpOffset, InpLen,
      ASN1_UNIVERSAL_SEQUENCE, 1, 0,
      (char *) PKCS7ContInfoCtl, PKCS7_CONTINFO_CTL_CNT,
      PKCS7_CONTINFO_MAX_DATA_INDEX,
      PKCS12_AUTHSAFE_TO_INT_ERROR,
      ppDstDesc, pDatArraySize, pSubErrCode));
}  

/**
* Subroutine FromASN1_PKCS7_EncDataContent generates data structures
* in internal notation ('Data Elements') from given ASN.1 encoded 
* PKCS7 EnryptedData Content input byte stream (FromASN1_PKCS7_EncDataContent). 
* The Content is split into:
* 1.     Version (Integer)
* 2.     encryptedContentInfo:
* 2.1.   Encrypted Content Type OID
* 2.2.   ContentEncrypt Algor:
* 2.2.1  EncryptAlgor OID
* 2.2.2  EncryptAlgor Params(ANY)
* 2.3	  EncryptedContent
* 
*  @param InpBuf ASN.1 Datastream base
*  @param InpOffset Start of Data
*  @param InpLen Length of Data
*  @param ppDstDesc Array Descriptor loaded with
*               Data Elements
*  @param pSubErrCode Error from higher parser/NULL
*  @return int Status, 0 - o.k., else error occured
*/
static  int  FromASN1_PKCS7_EncDataContent(char* InpBuf,
                                           int InpOffset, int InpLen, IDATPARR** ppDstDesc,
                                           int* pSubErrCode)
{
   return(FromASN1_Type(HMEM_CTX_REF1 InpBuf,InpOffset,InpLen,(char *) PKCS7ContEncDataCtl,PKCS7_CONT_ENCDATA_CTL_CNT,PKCS7_ENCDATA_MAX_DATA_INDEX,PKCS7_ENCDATA_TO_INT_ERR,ppDstDesc,pSubErrCode));
}
/**
* SubroutineToASN1_PKCS7_EncDataContent generates ASN.1 encoded
* PKCS7 EnryptedData Content byte stream from data structures
* in internal notation ('Data Elements') (ToASN1_PKCS7_EncDataContentDesc). 
* The Content is built from:
* 1.     Version (Integer)
* 2.     encryptedContentInfo:
* 2.1.   Encrypted Content Type OID
* 2.2.   ContentEncrypt Algor:
* 2.2.1  EncryptAlgor OID
* 2.2.2  EncryptAlgor Params(ANY)
* 2.3	  EncryptedContent
* 
*  @param pSrcDesc Source with elements
*  @param SrcIndex Slot to start with
*  @param ppDstDesc Array Slot loaded with Result 
*  @param DstIndex Slot to use
*  @param DstAllocSize Needed slots if allocate
*  @param pSubErrCode Error from higher parser/NULL
*  @return int Status, 0 - o.k., else error occured
*/
static  int  ToASN1_PKCS7_EncDataContentDesc(IDATPARR* pSrcDesc,
                                             int SrcIndex, IDATPARR** ppDstDesc, int DstIndex,
                                             int DstAllocSize, int* pSubErrCode)
{
   return(ToASN1_DescToDesc(pSrcDesc, SrcIndex,
      (char *) PKCS7ContEncDataCtl,
      PKCS7_CONT_ENCDATA_CTL_CNT,
      PKCS7_ENCDATA_FROM_INT_ERR,
      ppDstDesc, DstIndex, DstAllocSize, pSubErrCode));
}
/**
* Subroutine FromASN1_PKCS12PbeParams decodes ASN.1 encoded
* PKCS12 PBE Parameters sequence to internal Notation ('Data Elements') (FromASN1_PKCS12PbeParams).
* Element is Split into:
* 1.     Salt (Octet String)
* 2.     IterationCount (Integer)
* 
* Note: Required Databuffer structure will be allocated and filled
* -----
*
*  @param InpBuf ASN.1 Datastream base
*  @param InpOffset Start of Data
*  @param InpLen Length of Data
*  @param ppDstDesc Array Descriptor loaded with
*               Data Elements
*  @param pSubErrCode Error from higher parser/NULL
*
*  @return int Status - ASN1_OP_OK: o.k.
* <br>            - else Error occured
*/
static  int  FromASN1_PKCS12PbeParams(char* InpBuf, int InpOffset,
                                      int InpLen, IDATPARR** ppDstDesc,
                                      int* pSubErrCode)
{
   return(FromASN1_Type(HMEM_CTX_REF1 InpBuf,InpOffset,InpLen,(char *) PKCS12PbeParamsCtl,PKCS12_PBE_PARAMS_CTL_CNT,PKCS12_PBE_PARAMS_MAX_DATA_IND,PKCS12_PBEPARS_TO_INT_ERR,ppDstDesc,pSubErrCode));
}
/**
* Subroutine ToASN1_PKCS12PbeParamsDesc generates ASN.1 encoded
* PKCS12 PBE Parameters sequence from internal Notation ('Data Elements') (ToASN1_PKCS12PbeParamsDesc).
* Element is built from:
* 1.     Salt (Octet String)
* 2.     IterationCount (Integer)
* 
*  @param pSrcDesc Source with elements
*  @param SrcIndex Slot to start with
*  @param ppDstDesc Array Slot loaded with Result 
*  @param DstIndex Slot to use
*  @param DstAllocSize Needed slots if allocate
*  @param pSubErrCode Error from higher parser/NULL
*  @return int Status, 0 - o.k., else error occured
*/
static  int  ToASN1_PKCS12PbeParamsDesc(IDATPARR* pSrcDesc,
                                        int SrcIndex, IDATPARR** ppDstDesc, int DstIndex,
                                        int DstAllocSize, int* pSubErrCode)
{
   return(ToASN1_DescToDesc(pSrcDesc, SrcIndex,
      (char *) PKCS12PbeParamsCtl,
      PKCS12_PBE_PARAMS_CTL_CNT,
      PKCS12_PBEPARS_FROM_INT_ERR,
      ppDstDesc, DstIndex, DstAllocSize, pSubErrCode));
}
/**
* Subroutine FromASN1_PKCS12SafeContents decodes a
* Sequence of ASN.1 encoded SafeContents to Array of SafeBags
* in internal Notation ('Data Elements') (FromASN1_PKCS12SafeContents).
* Each Element is Split into:
* 1.     BagID (OID)
* 2.     BagValue ANY
* 3.	  BagAttributes (SET)
* 
*  @param InpBuf ASN.1 Datastream base
*  @param InpOffset Start of Data
*  @param InpLen Length of Data
*  @param ppDstDesc Array Descriptor loaded with
*               Data Elements
*  @param pDatArraySize Number of Elements loaded
*  @param pSubErrCode Error from higher parser/NULL
*  @return int Status, 0 - o.k., else error occured
*/
static  int  FromASN1_PKCS12SafeContents(char* InpBuf,
                                         int InpOffset, int InpLen, IDATPARR** ppDstDesc,
                                         int* pDatArraySize, int* pSubErrCode)
{
   //--------------------------------------------------------------
   // Strip SEQUENCE OF, subdecode the embedded Bags in SafeContent
   //--------------------------------------------------------------
   return(FromASN1_UniversalEmbeddedType(InpBuf, InpOffset, InpLen,
      ASN1_UNIVERSAL_SEQUENCE, 1, 0,
      (char *) PKCS12SafeBagCtl, PKCS12_SAFEBAG_CTL_CNT,
      PKCS12_SAFEBAG_MAX_DATA_INDEX,
      PKCS12_SAFECONTS_TO_INT_ERROR,
      ppDstDesc, pDatArraySize, pSubErrCode));
}  

/**
* Subroutine FromASN1_PFXSafeContents decodes an
* ASN.1 encoded SafeContents to Array of SafeBags
* in internal Notation ('Data Elements') (FromASN1_PFXSafeContents).
* Each Element is Split into:
* 
* 1.     BagID (OID)
* 2.     BagValue ANY
* 3.	  BagName (BMP_STRING)
* 
*  @param InpBuf ASN.1 Datastream base
*  @param InpOffset Start of Data
*  @param InpLen Length of Data
*  @param ppDstDesc Array Descriptor loaded with
*               Data Elements
*  @param pDatArraySize Number of Elements loaded
*  @param pSubErrCode Error from higher parser/NULL
*  @return int Status, 0 - o.k., else error occured
*/
static  int  FromASN1_PFXSafeContents(char* InpBuf,
                                      int InpOffset, int InpLen, IDATPARR** ppDstDesc,
                                      int* pDatArraySize, int* pSubErrCode)
{

   return(FromASN1_UniversalEmbeddedType(InpBuf, InpOffset, InpLen,
      ASN1_UNIVERSAL_SET, 1, 0,
      (char *) PFXSafeBagCtl, PFX_SAFEBAG_CTL_CNT,
      PKCS12_SAFEBAG_MAX_DATA_INDEX,
      PFX_SAFECONTS_TO_INT_ERROR,
      ppDstDesc, pDatArraySize, pSubErrCode));
}  
/**
* Subroutine ToASN1_PFXSafeBag ASN.1 encodes SafeBag
* in internal Notation ('Data Elements') (ToASN1_PFXSafeBagDesc).
* Each Element is built from
* 
* 1.     BagID (OID)
* 2.     BagValue ANY
* 3.	  BagName (BMP_STRING)
* 
*  @param pSrcDesc Source with elements
*  @param SrcIndex Slot to start with
*  @param ppDstDesc Array Slot loaded with Result 
*  @param DstIndex Slot to use
*  @param DstAllocSize Needed slots if allocate
*  @param pSubErrCode Error from higher parser/NULL
*  @return int Status, 0 - o.k., else error occured
*/
static  int  ToASN1_PFXSafeBagDesc(IDATPARR* pSrcDesc,
                                   int SrcIndex, IDATPARR** ppDstDesc, int DstIndex,
                                   int DstAllocSize, int* pSubErrCode)
{
   return(ToASN1_DescToDesc(pSrcDesc, SrcIndex,
      (char *) PFXSafeBagCtl, PFX_SAFEBAG_CTL_CNT,
      PFX_SAFEBAG_FROM_INT_ERROR,
      ppDstDesc, DstIndex, DstAllocSize, pSubErrCode));
}  
/**
* Subroutine ToASN1_PFXSafeContentsDesc ASN.1 encodes Array of
* SafeBags in internal Notation ('Data Elements') to ASN.1
* encoded SafeContents SET (ToASN1_PFXSafeContentsDesc). 
* Each Element is built from:
* 1.     BagID (OID)
* 2.     BagValue ANY
* 3.	  BagName (BMP_STRING)
* 
*  @param pSrcDesc Source with elements
*  @param ppDstDesc Array Slot loaded with Result 
*  @param DstIndex Slot to use
*  @param DstAllocSize Needed slots if allocate
*  @param pSubErrCode Error from higher parser/NULL
*  @return int Status, 0 - o.k., else error occured
*/
static  int  ToASN1_PFXSafeContentsDesc(IDATPARR* pSrcDesc,
                                        IDATPARR** ppDstDesc, int DstIndex,
                                        int DstAllocSize, int* pSubErrCode)
{
   //--------------------------------------------------------------
   // Subencode SafeBags, embed in a SET
   //--------------------------------------------------------------
   return(ToASN1_UniversalEmbeddedType(pSrcDesc,
      ASN1_UNIVERSAL_SET, 1,
      (char *) ASN1_AnyCtl, ASN1_ANY_CTL_CNT,
      ASN1_ANY_MAX_DATA_INDEX,
      PFX_SAFECONTS_FROM_INT_ERROR,
      ppDstDesc, DstIndex, DstAllocSize, pSubErrCode));
}  
/**
* Subroutine ToASN1_PKCS12SafeBagDesc ASN.1 encodes
* PKCS12 SafeBag from internal Notation ('Data Elements') (ToASN1_PKCS12BagDesc).
* Element is built from:
* 1.     BagType (OID)
* 2.     BagValue (ETAG[0]) ANY
* 3.     BagAtts ANY
* 
*  @param pSrcDesc Source with elements
*  @param SrcIndex Slot to start with
*  @param ppDstDesc Array Slot loaded with Result 
*  @param DstIndex Slot to use
*  @param DstAllocSize Needed slots if allocate
*  @param pSubErrCode Error from higher parser/NULL
*  @return int Status, 0 - o.k., else error occured
*/
static  int  ToASN1_PKCS12BagDesc(IDATPARR* pSrcDesc,
                                  int SrcIndex, IDATPARR** ppDstDesc, int DstIndex,
                                  int DstAllocSize, int* pSubErrCode)
{
   return(ToASN1_DescToDesc(pSrcDesc, SrcIndex,
      (char *) PKCS12SafeBagCtl,
      PKCS12_SAFEBAG_CTL_CNT,
      PKCS12_SAFEBAG_FROM_INT_ERR,
      ppDstDesc, DstIndex, DstAllocSize, pSubErrCode));
}

/**
* Subroutine FromASN1_PKCS12ShroudedKeyBag decodes ASN.1 encoded
* PKCS12 PKCS8ShroudedKeyBag to internal Notation ('Data Elements') (FromASN1_PKCS12ShroudedKeyBag).
* Element is Split into:
* 1.     EncryptionAlgor:
* 1.1.   EncryptionAlgorID (OID)
* 1.2.   EncryptionAlgorParams, ANY, Optional
* 2.	  Encrypted Data
* 
* Note: Required Databuffer structure will be allocated and filled
* -----
*
*  @param InpBuf ASN.1 Datastream base
*  @param InpOffset Start of Data
*  @param InpLen Length of Data
*  @param ppDstDesc Array Descriptor loaded with
*               Data Elements
*  @param pSubErrCode Error from higher parser/NULL
*  @return int Status, 0 - o.k., else error occured
*/
static  int  FromASN1_PKCS12ShroudedKeyBag(char* InpBuf,
                                           int InpOffset, int InpLen, IDATPARR** ppDstDesc,
                                           int* pSubErrCode)
{
   return(FromASN1_Type(HMEM_CTX_REF1 
                        InpBuf,
                        InpOffset,
                        InpLen,
                        (char *) PKCS12ShroudedKeyBagCtl,
                        PKCS12_SHROUDED_KEYBAG_CTL_CNT,
                        PKCS12_SHRBAG_MAX_DATA_INDEX,
                        PKCS12_SHRBAG_TO_INT_ERR,
                        ppDstDesc,
                        pSubErrCode));
}
/**
* Subroutine ToASN1_PKCS12ShroudedKeyBagDesc ASN.1 encodes
* PKCS12 PKCS8ShroudedKeyBag from internal Notation ('Data Elements') (ToASN1_PKCS12ShroudedKeyBagDesc).
* Element is built from:
* 1.     EncryptionAlgor:
* 1.1.   EncryptionAlgorID (OID)
* 1.2.   EncryptionAlgorParams, ANY, Optional
* 2.	  Encrypted Data
* 
*  @param pSrcDesc Source with elements
*  @param SrcIndex Slot to start with
*  @param ppDstDesc Array Slot loaded with Result 
*  @param DstIndex Slot to use
*  @param DstAllocSize Needed slots if allocate
*  @param pSubErrCode Error from higher parser/NULL
*  @return int Status, 0 - o.k., else error occured
*/
static  int  ToASN1_PKCS12ShroudedKeyBagDesc(IDATPARR* pSrcDesc,
                                             int SrcIndex, IDATPARR** ppDstDesc, int DstIndex,
                                             int DstAllocSize, int* pSubErrCode)
{
   return(ToASN1_DescToDesc(pSrcDesc, SrcIndex,
      (char *) PKCS12ShroudedKeyBagCtl,
      PKCS12_SHROUDED_KEYBAG_CTL_CNT,
      PKCS12_SHRBAG_FROM_INT_ERR,
      ppDstDesc, DstIndex, DstAllocSize, pSubErrCode));
}
/**
* Subroutine FromASN1_PKCS12CertBag decodes ASN.1 encoded
* PKCS12 PKCS8CertBag to internal Notation ('Data Elements') (FromASN1_PKCS12CertBag).
* Element is Split into:
* 1.     CertID (OID)
* 2.     CertValue (ETAG[0]) ANY
* 
*  @param InpBuf ASN.1 Datastream base
*  @param InpOffset Start of Data
*  @param InpLen Length of Data
*  @param ppDstDesc Array Descriptor loaded with
*               Data Elements
*  @param pSubErrCode Error from higher parser/NULL
*  @return int Status, 0 - o.k., else error occured
*/
static  int  FromASN1_PKCS12CertBag(char* InpBuf,
                                    int InpOffset, int InpLen, IDATPARR** ppDstDesc,
                                    int* pSubErrCode)
{
   return(FromASN1_Type(HMEM_CTX_REF1 InpBuf,InpOffset,InpLen,(char *) PKCS12CertBagCtl,PKCS12_CERTBAG_CTL_CNT,PKCS12_CERTBAG_MAX_DATA_INDEX,PKCS12_CERTBAG_TO_INT_ERR,ppDstDesc,pSubErrCode));
}
/**
* Subroutine ToASN1_PKCS12CertBagDesc ASN.1 encodes
* PKCS12 PKCS8CertBag from internal Notation ('Data Elements') (ToASN1_PKCS12CertBagDesc).
* Element is built from:
* 1.     CertID (OID)
* 2.     CertValue (ETAG[0]) ANY
* 
*  @param pSrcDesc Source with elements
*  @param SrcIndex Slot to start with
*  @param ppDstDesc Array Slot loaded with Result 
*  @param DstIndex Slot to use
*  @param DstAllocSize Needed slots if allocate
*  @param pSubErrCode Error from higher parser/NULL
*  @return int Status, 0 - o.k., else error occured
*/
static  int  ToASN1_PKCS12CertBagDesc(IDATPARR* pSrcDesc,
                                      int SrcIndex, IDATPARR** ppDstDesc, int DstIndex,
                                      int DstAllocSize, int* pSubErrCode)
{
   return(ToASN1_DescToDesc(pSrcDesc, SrcIndex,
      (char *) PKCS12CertBagCtl,
      PKCS12_CERTBAG_CTL_CNT,
      PKCS12_CERTBAG_FROM_INT_ERR,
      ppDstDesc, DstIndex, DstAllocSize, pSubErrCode));
}
/**
* Subroutine FromASN1_PFXCertCRLBag decodes ASN.1 encoded
* SET OF PFX CertCRLBag to Array of CertCRLs in
* internal Notation ('Data Elements') (FromASN1_PFXCertCRLBag).
* Each element is Split into:
* 1.     CertCRLType (OID)
* 2.     CertValue (ANY)
* 
*  @param InpBuf ASN.1 Datastream base
*  @param InpOffset Start of Data
*  @param InpLen Length of Data
*  @param ppDstDesc Array Descriptor loaded with
*               Data Elements
*  @param pDatArraySize Number of Elements loaded
*  @param pSubErrCode Error from higher parser/NULL
*  @return int Status, 0 - o.k., else error occured
*/
static  int  FromASN1_PFXCertCRLBag(char* InpBuf,
                                    int InpOffset, int InpLen, IDATPARR** ppDstDesc,
                                    int* pDatArraySize, int* pSubErrCode)
{
   return(FromASN1_UniversalEmbeddedType(InpBuf, InpOffset, InpLen,
      ASN1_UNIVERSAL_SET, 1, 0,
      (char *) PFXCertCRLBagCtl, PFX_CERTCRL_BAG_CTL_CNT,
      PFX_CERTCRL_BAG_MAX_DATA_INDEX,
      PFX_CERTCRLS_TO_INT_ERROR,
      ppDstDesc, pDatArraySize, pSubErrCode));
}  
/**
* Subroutine ToASN1_PFXCertCRLBagDesc ASN.1 encodes array of
* CertCRLs in internal Notation ('Data Elements') to ASN.1
* encoded SET OF PFX CertCRLBag (ToASN1_PFXCertCRLBagDesc).
* Each element is built from:
* 1.     CertCRLType (OID)
* 2.     CertValue (ANY)
* 
*  @param pSrcDesc Source with elements
*  @param ppDstDesc Array Slot loaded with Result 
*  @param DstIndex Slot to use
*  @param DstAllocSize Needed slots if allocate
*  @param pSubErrCode Error from higher parser/NULL
*  @return int Status, 0 - o.k., else error occured
*/
static  int  ToASN1_PFXCertCRLBagDesc(IDATPARR* pSrcDesc,
                                      IDATPARR** ppDstDesc, int DstIndex,
                                      int DstAllocSize, int* pSubErrCode)
{
   //--------------------------------------------------------------
   // Subencode CertCRLs, embed in a SET
   // WRONG ??  -> do NOT Embed in a SET!!
   //--------------------------------------------------------------
   return(ToASN1_UniversalEmbeddedType(pSrcDesc,
      ASN1_UNIVERSAL_SET, 1,
      (char *) PFXCertCRLBagCtl, PFX_CERTCRL_BAG_CTL_CNT,
      PFX_CERTCRL_BAG_MAX_DATA_INDEX,
      PFX_CERTCRLS_FROM_INT_ERROR,
      ppDstDesc, DstIndex, DstAllocSize, pSubErrCode));
}  
/**
* Subroutine FromASN1_PFX_X509CertCRL decodes ASN.1 encoded
* PFX X509CertCRL to internal Notation ('Data Elements') (FromASN1_PFX_X509CertCRL).
* Each element is Split into:
* 1.     ContentType (OID) [PKCS-7 signedData]
* 2.     SignedData.Version (INT)
* 3.	  SignedData.DigestAlgorIDs (SET OF)
* 4.	  SignedData.ContentInfo.Type (OID)
* 5.	  SignedData.ContentInfo.Value(ETAG[0], Optional)
* 6.	  SignedData.CertSet(SET OF)
* 7.	  SignedData.CRLSet (SET OF)
* 8.	  SignedData.SignerInfos(SET OF)
* 
*  @param InpBuf ASN.1 Datastream base
*  @param InpOffset Start of Data
*  @param InpLen Length of Data
*  @param ppDstDesc Array Descriptor loaded with
*               Data Elements
*  @param pSubErrCode Error from higher parser/NULL
*  @return int Status, 0 - o.k., else error occured
*/
static  int  FromASN1_PFX_X509CertCRL(char* InpBuf,
                                      int InpOffset, int InpLen, IDATPARR** ppDstDesc,
                                      int* pSubErrCode)
{
   return(FromASN1_Type(HMEM_CTX_REF1 InpBuf,InpOffset,InpLen,(char *) PFX_X509CertCRLCtl,PFX_X509_CERTCRL_CTL_CNT,PFX_X509_CERTCRL_MAX_DATA_INDEX,PFX_X509_CERTCRL_TO_INT_ERR,ppDstDesc,pSubErrCode));
}
/**
* Subroutine ToASN1_PFX_X509CertCRL ASN.1 encodes
* PFX X509CertCRL to internal Notation ('Data Elements') (ToASN1_PFX_X509CertCRLDesc).
* Each element is built from:
* 1.     ContentType (OID) [PKCS-7 signedData]
* 2.     SignedData.Version (INT)
* 3.	  SignedData.DigestAlgorIDs (SET OF)
* 4.	  SignedData.ContentInfo.Type (OID)
* 5.	  SignedData.ContentInfo.Value(ETAG[0], Optional)
* 6.	  SignedData.CertSet(SET OF)
* 7.	  SignedData.CRLSet (SET OF)
* 8.	  SignedData.SignerInfos(SET OF)
* 
*  @param pSrcDesc Source with elements
*  @param SrcIndex Slot to start with
*  @param ppDstDesc Array Slot loaded with Result 
*  @param DstIndex Slot to use
*  @param DstAllocSize Needed slots if allocate
*  @param pSubErrCode Error from higher parser/NULL
*  @return int Status, 0 - o.k., else error occured
*/
static  int  ToASN1_PFX_X509CertCRLDesc(IDATPARR* pSrcDesc,
                                        int SrcIndex, IDATPARR** ppDstDesc, int DstIndex,
                                        int DstAllocSize, int* pSubErrCode)
{
   return(ToASN1_DescToDesc(pSrcDesc, SrcIndex,
      (char *) PFX_X509CertCRLCtl,
      PFX_X509_CERTCRL_CTL_CNT,
      PFX_X509_CERTCRL_FROM_INT_ERR,
      ppDstDesc, DstIndex, DstAllocSize, pSubErrCode));
}
/**
* Subroutine FromASN1_PFXCertList decodes ASN.1 encoded
* SEQUENCE of X509Certs to Array of X509Certs in
* internal Notation ('Data Elements') (FromASN1_PFX_X509CertList).
* Each element is Split into:
* 1.     X509Cert (SEQ)
* 
*  @param InpBuf ASN.1 Datastream base
*  @param InpOffset Start of Data
*  @param InpLen Length of Data
*  @param ppDstDesc Array Descriptor loaded with
*               Data Elements
*  @param pDatArraySize Number of Elements loaded
*  @param pSubErrCode Error from higher parser/NULL
*  @return int Status, 0 - o.k., else error occured
*/
static  int  FromASN1_PFX_X509CertList(char* InpBuf,
                                       int InpOffset, int InpLen, IDATPARR** ppDstDesc,
                                       int* pDatArraySize, int* pSubErrCode)
{
   return(FromASN1_UniversalEmbeddedType(InpBuf, InpOffset, InpLen,
      ASN1_UNIVERSAL_NULL, 0, 0,
      (char *) PFX_X509CertListCtl, PFX_X509_CERTLIST_CTL_CNT,
      PFX_X509_CERTLIST_MAX_DATA_IND,
      PFX_CERTLIST_TO_INT_ERROR,
      ppDstDesc, pDatArraySize, pSubErrCode));
}  
/**
* Subroutine ToASN1_PFXCertList ASN.1 encodes Array of X509Certs
* in internal Notation ('Data Elements') zo ASN.1 encoded
* SEQUENCE of X509Certs (ToASN1_PFX_X509CertListDesc). 
* Each element is built from:
* 1.     X509Cert (SEQ)
* 
*  @param pSrcDesc Source with elements
*  @param ppDstDesc Array Slot loaded with Result 
*  @param DstIndex Slot to use
*  @param DstAllocSize Needed slots if allocate
*  @param pSubErrCode Error from higher parser/NULL
*  @return int Status, 0 - o.k., else error occured
*/
static  int  ToASN1_PFX_X509CertListDesc(IDATPARR* pSrcDesc,
                                         IDATPARR** ppDstDesc, int DstIndex,
                                         int DstAllocSize, int* pSubErrCode)
{
   return(ToASN1_UniversalEmbeddedType(pSrcDesc,
      ASN1_UNIVERSAL_NULL, 0,
      (char *) PFX_X509CertListCtl, PFX_X509_CERTLIST_CTL_CNT,
      PFX_X509_CERTLIST_MAX_DATA_IND,
      PFX_CERTLIST_FROM_INT_ERROR,
      ppDstDesc, DstIndex, DstAllocSize, pSubErrCode));
}  
/**
* Subroutine FromASN1_PFXBaggage decodes a
* Set of ASN.1 encoded Baggage Items to Array of their
* espvks and unencryptedSecrets in internal Notation ('Data Elements') (FromASN1_PFXBaggage).
* Each Element is Split into:
* 1.     espvks (SET)
* 2.     unencryptesSecrets (SET OF)
* 
* Note: 1. Required Databuffer structure will be allocated and filled
* ----- 2. SET is already stripped of
*
*  @param InpBuf ASN.1 Datastream base
*  @param InpOffset Start of Data
*  @param InpLen Length of Data
*  @param ppDstDesc Array Descriptor loaded with
*               Data Elements
*  @param pDatArraySize Number of Elements loaded
*  @param pSubErrCode Error from higher parser/NULL
*  @return int Status, 0 - o.k., else error occured
*/
static  int  FromASN1_PFXBaggage(char* InpBuf, int InpOffset,
                                 int InpLen, IDATPARR** ppDstDesc,
                                 int* pDatArraySize, int* pSubErrCode)
{
   return(FromASN1_UniversalEmbeddedType(InpBuf, InpOffset, InpLen,
      ASN1_UNIVERSAL_SET, 0, 0,
      (char *) PFXBaggageItemCtl, PFX_BAGGAGE_ITEM_CTL_CNT,
      PFX_BAGGAGEITEM_MAX_DATA_INDEX,
      PFX_BAGGAGE_TO_INT_ERROR,
      ppDstDesc, pDatArraySize, pSubErrCode));
}  
/**
* Subroutine ToASN1_PFXBaggageDesc ASN.1 encodes
* espvks and unencryptedSecrets in internal Notation ('Data Elements')
* to ASN.1 encoded Baggage Item (ToASN1_PFXBaggageItemDesc).
* 
*  @param pSrcDesc Source with elements
*  @param ppDstDesc Array Slot loaded with Result 
*  @param DstIndex Slot to use
*  @param DstAllocSize Needed slots if allocate
*  @param pSubErrCode Error from higher parser/NULL
*  @return int Status, 0 - o.k., else error occured
*/
static  int  ToASN1_PFXBaggageItemDesc(IDATPARR* pSrcDesc,
                                       IDATPARR** ppDstDesc, int DstIndex,
                                       int DstAllocSize, int* pSubErrCode)
{
   return(ToASN1_DescToDesc(pSrcDesc, 0,
      (char *) PFXBaggageItemCtl, PFX_BAGGAGE_ITEM_CTL_CNT,
      PFX_BAGGAGE_FROM_INT_ERROR,
      ppDstDesc, DstIndex, DstAllocSize, pSubErrCode));
}  
/**
* Subroutine ToASN1_PFXBaggageDesc ASN.1 encodes array of
* PFX Baggage Items to to ASN.1 encoded Baggage (ToASN1_PFXBaggageDesc).
* 
*  @param pSrcDesc Source with elements
*  @param ppDstDesc Array Slot loaded with Result 
*  @param DstIndex Slot to use
*  @param DstAllocSize Needed slots if allocate
*  @param pSubErrCode Error from higher parser/NULL
*  @return int Status, 0 - o.k., else error occured
*/
static  int  ToASN1_PFXBaggageDesc(IDATPARR* pSrcDesc,
                                   IDATPARR** ppDstDesc, int DstIndex,
                                   int DstAllocSize, int* pSubErrCode)
{
   return(ToASN1_UniversalEmbeddedType(pSrcDesc,
      ASN1_UNIVERSAL_SET, 0,
      (char *) PFXBaggageCtl, PFX_BAGGAGE_CTL_CNT,
      PFX_BAGGAGE_MAX_DATA_INDEX,
      PFX_BAGGAGE_FROM_INT_ERROR,
      ppDstDesc, DstIndex, DstAllocSize, pSubErrCode));
}  

/**
* Subroutine FromASN1_PFXEspvks decodes a
* Set of ASN.1 encoded Espvk Items to Array of representation
* in internal Notation ('Data Elements') (FromASN1_PFXEspvks).
* Each Element is Split into
* 1.     espvkOID (OID)
* 2.     espvkData (PVKSupportingData):
* 2.1.	  Thumbprints (SET OF)
* 2.2.	  RegenerableFlag (BOOLEAN) DEFAULT FALSE, Optional
* 2.3.   Nickname (BMPString)
* 2.4.	  PvkAdditional ANY Optional
* 
* Note: 1. Required Databuffer structure will be allocated and filled
* ----- 2. SET is already stripped of
*
*  @param InpBuf ASN.1 Datastream base
*  @param InpOffset Start of Data
*  @param InpLen Length of Data
*  @param ppDstDesc Array Descriptor loaded with
*               Data Elements
*  @param pDatArraySize Number of Elements loaded
*  @param pSubErrCode Error from higher parser/NULL
*
*  @return int Status - ASN1_OP_OK: o.k.
* <br>            - else Error occured
*/
static  int  FromASN1_PFXEspvks(char* InpBuf, int InpOffset,
                                int InpLen, IDATPARR** ppDstDesc,
                                int* pDatArraySize, int* pSubErrCode)
{
   return(FromASN1_UniversalEmbeddedType(InpBuf, InpOffset, InpLen,
      ASN1_UNIVERSAL_SET, 0, 0,
      (char *) PFXEspvkCtl, PFX_ESPVK_CTL_CNT,
      PFX_ESPVK_MAX_DATA_INDEX,
      PFX_ESPVK_TO_INT_ERROR,
      ppDstDesc, pDatArraySize, pSubErrCode));
}
/**
* Subroutine ToASN1_PFXEspvksDesc ASN.1 encodes Array of Espvk
* items in internal representation to ASN.1 encoded SET of
* ESPVK (ToASN1_PFXEspvksDesc). 
* Each Element is built from:
* 1.     espvkOID (OID)
* 2.     espvkData (PVKSupportingData):
* 2.1.	  Thumbprints (SET OF)
* 2.2.	  RegenerableFlag (BOOLEAN) DEFAULT FALSE, Optional
* 2.3.   Nickname (BMPString)
* 2.4.	  PvkAdditional ANY Optional
* 
*  @param pSrcDesc Source with elements
*  @param ppDstDesc Array Slot loaded with Result 
*  @param DstIndex Slot to use
*  @param DstAllocSize Needed slots if allocate
*  @param pSubErrCode Error from higher parser/NULL
*  @return int Status, 0 - o.k., else error occured
*/
static  int  ToASN1_PFXEspvksDesc(IDATPARR* pSrcDesc,
                                  IDATPARR** ppDstDesc, int DstIndex,
                                  int DstAllocSize, int* pSubErrCode)
{
   return(ToASN1_UniversalEmbeddedType(pSrcDesc,
      ASN1_UNIVERSAL_SET, 0,
      (char *) PFXEspvkCtl, PFX_ESPVK_CTL_CNT,
      PFX_ESPVK_MAX_DATA_INDEX,
      PFX_ESPVK_TO_INT_ERROR,
      ppDstDesc, DstIndex, DstAllocSize, pSubErrCode));
}  

//***********************************************************************
//***********************************************************************
//***********************************************************************

/**
* Get X509 KeyUsage ExtAtt Value if present in Attribute SET OF
* without ASN.1 SET OF Header (GetX509KeyUsage).
*
* NOTE: No parameters checked !
* -----
*
*  @param pBuf Attribute Value SET Base
*  @param Offset Start of Data
*  @param Len Length of Data
*  @param pKeyUsage Decoded Bitstring
*  @param pIsPresent 0 - Value not present
*  @return int Status - 0 o.k., else error occured
*/
static  int  GetX509KeyUsage(char* pBuf,
                             int Offset, int Len,
                             int* pKeyUsage, int* pIsPresent)
{
   int Retcode;

   int AvaCount, Index;

   int pTmpCnt[1];
   int pTmpRet[1];

   IDATA* pIdata;
   IDATA** ppArr;
   IDATPARR* ppTmpDesc[1];

   pKeyUsage[0] = 0;
   pIsPresent[0] = 0;
   //-----------------------------------------------------------
   // Check if Any data in the SET OF
   //-----------------------------------------------------------
   if((pBuf == NULL) || (Len <= 0))
      return(PKCS12_OP_OK);
   //------------------------------------------------------------
   // Split the SET contents into AVA pairs, at least one present
   //------------------------------------------------------------
   if((Retcode = FromASN1_UniversalEmbeddedType(pBuf, Offset, Len,
      ASN1_UNIVERSAL_NULL, 0, 0,
      (char *) X501AvaCtl, X501_AVA_CTL_CNT,
      X501_AVA_MAX_DATA_INDEX,
      X501_AVA_TO_INT_ERROR,
      ppTmpDesc, pTmpCnt, pTmpRet)) != ASN1_OP_OK)
      return(Retcode);
   AvaCount = pTmpCnt[0] / 2;
   //-----------------------------------------------------------
   // Find first occurence of the Keyusage ExtAtt
   //-----------------------------------------------------------
   ppArr = ppTmpDesc[0]->ppArr;
   Index = 0;
   while(AvaCount != 0)
   {
      pIdata = ppArr[Index];
      Retcode = GetX509_ExtAttTypeID(pIdata->Base,
         (int) pIdata->Off,
         pIdata->Len,
         pTmpRet);
      if((Retcode == PKCS12_OP_OK) &&
         (pTmpRet[0] == X509_ID_CE_KEY_USAGE_SUBID))
         break;
      Index += 2;				// to next pair
      AvaCount--;
   }
   if(AvaCount == 0)			// none found
   {
      FreeIDATPARR_Struc(HMEM_CTX_REF1 ppTmpDesc[0]);
      return(PKCS12_OP_OK);
   }
   //-----------------------------------------------------------
   // Found Attribute type, subdecode the value SET OF
   //-----------------------------------------------------------
   pIdata = ppArr[Index+1];			// Attribute value 
   pBuf = pIdata->Base;
   Offset = (int) pIdata->Off;
   Len    = pIdata->Len;
   FreeIDATPARR_Struc(HMEM_CTX_REF1 ppTmpDesc[0]);

   if((Retcode = FromASN1_UniversalEmbeddedType(pBuf, Offset, Len,
      ASN1_UNIVERSAL_SET, 0, 0,
      (char *) ASN1_BitstrCtl, ASN1_BITSTR_CTL_CNT,
      ASN1_BITSTR_MAX_DATA_INDEX,
      X501_ATTVAL_TO_INT_ERROR,
      ppTmpDesc, pTmpCnt, pTmpRet)) != ASN1_OP_OK)
      return(Retcode);
   //---------------------------------------------------------
   // Extract data from bitstring (1st Element)
   //---------------------------------------------------------
   pIdata = ppTmpDesc[0]->ppArr[0];
   Retcode = GetBit32MsbBitsFromBitstring(pIdata->Base,(int) pIdata->Off,pIdata->Len,X509_KEY_USAGE_MAX_BITS,pKeyUsage);
   FreeIDATPARR_Struc(HMEM_CTX_REF1 ppTmpDesc[0]);
   if(Retcode == ASN1_OP_OK)
      pIsPresent[0] = 1;
   return(Retcode);
}  

/**
* AllocCopyDatArrayElement allocates buffer for an element in a
* DescriptorArray to a local buffer (PKCS12_AllocCopyDatArrayElement).
*
* NOTE: No parameters checked !
* -----
*
*  @param pDesc Descriptor
*  @param ElementIndex Element to process
*  @param ppBuf Allocated Buffer
*  @param pBufLen size of data
*  @return int Status - 0 o.k., else error occured
*/
static  int  PKCS12_AllocCopyDatArrayElement(IDATPARR* pDesc,
                                             int ElementIndex, char** ppBuf, int* pBufLen)
{
   int BufLen;
   char* pBuf;
   IDATA* pIdata;
   IDATA** ppArr;

   if((pDesc == NULL) || ((ppArr = pDesc->ppArr) == NULL) ||
      (ppBuf == NULL) || (pBufLen == NULL))
      return(PKCS12_NULL_PTR);

   ppBuf[0] = NULL;
   pBufLen[0] = 0;

   if(ElementIndex > pDesc->Cnt)
      return(PKCS12_PARAM_ERR);

   pIdata = ppArr[ElementIndex];
   if((pIdata == NULL) || (pIdata->Base == NULL) ||
      ((BufLen = pIdata->Len) <= 0))
      return(PKCS12_OP_OK);

   if((pBuf = BIT8_ARRAY_ALLOC(HMEM_CTX_REF,BufLen)) == NULL)
      return(PKCS12_ALLOC_ERR);

   memcpy(pBuf+0,pIdata->Base+(int) pIdata->Off,pIdata->Len);
   ppBuf[0] = pBuf;
   pBufLen[0] = BufLen;
   return(PKCS12_OP_OK);
}

/**
* Get PKCS9 FriendlyName and/or LocalKeyID Attribute Values
* from Attribute SET OF without ASN.1 SET OF Header (PKCS12_GetPKCS9SelectedAtts).
*
* NOTE: No parameters checked !
* -----
*
*  @param pBuf Attribute Value SET Base
*  @param Offset Start of Data
*  @param Len Length of Data
*  @param ppFriendlyName allocated buffer / NULL
*  @param pFriendlyNameLen size of Name
*  @param ppLocalKeyID allocated buffer / NULL
*  @param pLocalKeyIDLen size of KeyID
*  @return int Status - 0 o.k., else error occured
*/
static  int  PKCS12_GetPKCS9SelectedAtts(char* pBuf,
                                         int Offset, int Len,
                                         char** ppFriendlyName, int* pFriendlyNameLen,
                                         char** ppLocalKeyID, int* pLocalKeyIDLen)
{
   int Retcode;

   int AvaCount, Index, AttType;
   int FriendlyNameLen = 0;
   int LocalKeyIDLen = 0;

   int pTmpCnt[1];
   int pTmpRet[1];

   char* pFriendlyName = NULL;
   char* pLocalKeyID = NULL;
   char* ppTmpBuf[1];

   IDATA* pIdata;
   IDATA** ppArr;

   IDATPARR* pAvaDesc = NULL;
   IDATPARR* ppTmpDesc[1];

   ppFriendlyName[0]   = NULL;
   pFriendlyNameLen[0] = 0;
   ppLocalKeyID[0]     = NULL;
   pLocalKeyIDLen[0]   = 0;
   //-----------------------------------------------------------
   // Check if Any data in the SET OF
   //-----------------------------------------------------------
   if((pBuf == NULL) || (Len <= 0))
      return(PKCS12_OP_OK);
   //------------------------------------------------------------
   // Split the SET contents into AVA pairs, at least one present
   //------------------------------------------------------------
   if((Retcode = FromASN1_UniversalEmbeddedType(pBuf, Offset, Len,
      ASN1_UNIVERSAL_NULL, 0, 0,
      (char *) X501AvaCtl, X501_AVA_CTL_CNT,
      X501_AVA_MAX_DATA_INDEX,
      X501_AVA_TO_INT_ERROR,
      ppTmpDesc, pTmpCnt, pTmpRet)) != ASN1_OP_OK)
      return(Retcode);
   pAvaDesc = ppTmpDesc[0];
   AvaCount = pTmpCnt[0] / 2;
   //-----------------------------------------------------------
   // Find first occurence of friendly Name
   //-----------------------------------------------------------
   ppArr = pAvaDesc->ppArr;
   Index = 0;
   while(AvaCount != 0)
   {
      pIdata = ppArr[Index];
      Retcode =  GetPKCS9_ExtAttID(pIdata->Base,
         (int) pIdata->Off,
         pIdata->Len,
         pTmpRet);
      if((Retcode == PKCS12_OP_OK) &&
         (((pTmpRet[0] == PKCS9_ATT_FRIENDLY_NAME_SUBID) &&
         (pFriendlyName == NULL)) ||
         ((pTmpRet[0] == PKCS9_ATT_LOCAL_KEYID_SUBID) &&
         (pLocalKeyID == NULL))))
      {
         //-------------------------------------------------------
         // found recognized, not yet found PKCS9 Attribute
         // subdecode the Value SET OF
         //-------------------------------------------------------
         AttType = pTmpRet[0];
         pIdata = ppArr[Index+1];			// Attribute value 
         pBuf = pIdata->Base;
         Offset = (int) pIdata->Off;
         Len    = pIdata->Len;
         if(AttType == PKCS9_ATT_LOCAL_KEYID_SUBID)
         {
            //-----------------------------------------------------
            // Get the local KeyID OCTETSTRING contents
            //-----------------------------------------------------
            if((Retcode = FromASN1_UniversalEmbeddedType(pBuf, Offset, Len,
               ASN1_UNIVERSAL_SET, 0, 0,
               (char *) ASN1OctetStrCtl,ASN1_OCTETSTR_CTL_CNT,
               ASN1_OCTETSTR_MAX_DATA_INDEX,
               PKCS9_OCTETSTR_TO_INT_ERR,
               ppTmpDesc, pTmpCnt, pTmpRet)) != ASN1_OP_OK)
               break;
            //-----------------------------------------------------
            // Copy contents to allocated buffer
            //-----------------------------------------------------
            Retcode = PKCS12_AllocCopyDatArrayElement(ppTmpDesc[0], 0,
               ppTmpBuf, pTmpRet);
            FreeIDATPARR_Struc(HMEM_CTX_REF1 ppTmpDesc[0]);
            if(Retcode != PKCS12_OP_OK)
               break;

            pLocalKeyID   = ppTmpBuf[0];
            LocalKeyIDLen = pTmpRet[0];
         }
         else
         {
            //-----------------------------------------------------
            // Get the FriendlyName BMPSTRING contents
            //-----------------------------------------------------
            if((Retcode = FromASN1_UniversalEmbeddedType(pBuf, Offset, Len,
               ASN1_UNIVERSAL_SET, 0, 0,
               (char *) ASN1BmpStrCtl,ASN1_BMPSTR_CTL_CNT,
               ASN1_BMPSTR_MAX_DATA_INDEX,
               PKCS9_BMPSTR_TO_INT_ERR,
               ppTmpDesc, pTmpCnt, pTmpRet)) != ASN1_OP_OK)
               break;
            //-----------------------------------------------------
            // Copy contents to allocated buffer
            //-----------------------------------------------------
            Retcode = PKCS12_AllocCopyDatArrayElement(ppTmpDesc[0], 0,
               ppTmpBuf, pTmpRet);
            FreeIDATPARR_Struc(HMEM_CTX_REF1 ppTmpDesc[0]);
            if(Retcode != PKCS12_OP_OK)
               break;

            pFriendlyName   = ppTmpBuf[0];
            FriendlyNameLen = pTmpRet[0];
         }
      }
      Retcode = PKCS12_OP_OK;
      Index += 2;				// to next pair
      AvaCount--;
   }
   //-----------------------------------------------------------
   // Free temporary used structures
   //-----------------------------------------------------------
   FreeIDATPARR_Struc(HMEM_CTX_REF1 pAvaDesc);
   if(Retcode != PKCS12_OP_OK)
   {
      FREE_ARRAY(HMEM_CTX_REF,pLocalKeyID);
      FREE_ARRAY(HMEM_CTX_REF,pFriendlyName);
      return(Retcode);
   }
   ppLocalKeyID[0]     = pLocalKeyID;
   pLocalKeyIDLen[0]   = LocalKeyIDLen;
   ppFriendlyName[0]   = pFriendlyName;
   pFriendlyNameLen[0] = FriendlyNameLen;
   return(Retcode);
}

/**
* Subroutine FromASN1_PKCS8PrivkeyInfo decodes ASN.1 encoded
* PKCS8 PrivateKeyInfo to internal Notation ('Data Elements') (FromASN1_PKCS8PrivkeyInfo).
* Each element is Split into:
* 1.     Version (INT)
* 2.	  PrivKeyAlgorTypeID (OID)
* 3.	  PrivKeyAlgorParams (ANY [here: NULL/SEQ])
* 4.	  PrivatekeyData (OCTESTSTR)
* 5.	  Attributes (ETAG[0]), Optional
* 
*  @param InpBuf ASN.1 Datastream base
*  @param InpOffset Start of Data
*  @param InpLen Length of Data
*  @param ppDstDesc Array Descriptor loaded with
*               Data Elements
*  @param pSubErrCode Error from higher parser/NULL
*  @return int Status, 0 - o.k., else error occured
*/
static  int  FromASN1_PKCS8PrivkeyInfo(char* InpBuf,
                                       int InpOffset, int InpLen, IDATPARR** ppDstDesc,
                                       int* pSubErrCode)
{
   return(FromASN1_Type(HMEM_CTX_REF1 
                        InpBuf,
                        InpOffset,
                        InpLen,
                        (char *) PKCS8PrivKeyInfoCtl,
                        PKCS8_PRIVKEYINFO_CTL_CNT,
                        PKCS8_PRIVKEYINFO_MAX_DATA_IND,
                        PKCS8_PRIVKEYINFO_TO_INT_ERR,
                        ppDstDesc,
                        pSubErrCode));
}
/**
* Subroutine ToASN1_PKCS8PrivkeyInfoDesc ASN.1 encodes
* PKCS8 PrivateKeyInfo in internal Notation ('Data Elements') (ToASN1_PKCS8PrivkeyInfoDesc).
* Each element is built from:
* 1.     Version (INT)
* 2.	  PrivKeyAlgorTypeID (OID)
* 3.	  PrivKeyAlgorParams (ANY [here: NULL/SEQ])
* 4.	  PrivatekeyData (OCTESTSTR)
* 5.	  Attributes (ETAG[0]), Optional
* 
*  @param pSrcDesc Source with elements
*  @param SrcIndex Slot to start with
*  @param ppDstDesc Array Slot loaded with Result 
*  @param DstIndex Slot to use
*  @param DstAllocSize Needed slots if allocate
*  @param pSubErrCode Error from higher parser/NULL
*  @return int Status, 0 - o.k., else error occured
*/
static  int  ToASN1_PKCS8PrivkeyInfoDesc(IDATPARR* pSrcDesc,
                                         int SrcIndex, IDATPARR** ppDstDesc, int DstIndex,
                                         int DstAllocSize, int* pSubErrCode)
{
   return(ToASN1_DescToDesc(pSrcDesc, SrcIndex,
      (char *) PKCS8PrivKeyInfoCtl,
      PKCS8_PRIVKEYINFO_CTL_CNT,
      PKCS8_PRIVKEYINFO_FROM_INT_ERR,
      ppDstDesc, DstIndex, DstAllocSize, pSubErrCode));
}

/**
* Subroutine FromASN1_PKCS8Privkey decodes ASN.1 encoded
* PKCS8 PrivateKeyInfo to internal Notation and extracts the
* private key data to internal Notation usable with the
* HASN1.C subroutines (FromASN1_PKCS8Privkey).
*
* Note: The private key format is built according to the format
* ----- used in HASN1.C:
*	RSA				DSA
*	----------------		---------------------
* 	Dummy Slot, unused		p	Modul
*	n	Modul			q	Divisor of (p-1)
*	e	Publ.Exp.		g	Generator
*	d	Priv.Exp.		y	Public value [empty slot!]
*	p	Prime1			x	Private value
*	q	Prime2			Dummy Slot, unused
*	dmodp	Exponent1 d mod(p-1)
*	dmodq	Exponent2 d mod(q-1)
*	qmp	Coefficient q**-1mod(p)
*
* NOTE: For DSA there is NO public value Y in the private key
* ----- for X9.57. This has to be filled in from the certificat
*	 the private key belongs to !!
*
*  @param pInpBuf ASN.1 Datastream base
*  @param InpOffset Start of Data
*  @param InpLen Length of Data
*               IDATPARR_PTR pDatarrayDesc[] Array Descriptor loaded with
*               Data Elements
*  @param pPrivKeyAlgorID AlgorID required by HASN1.C
*  @param pKeyUsage Key Usage bits, MSB aligned !
*  @param pUsageIsPresent Key usage was found
*  @param SubErrCode Error from higher parser/NULL
*
*  @return int Status - ASN1_OP_OK: o.k.
* <br>            - else Error occured
*/
static  int  FromASN1_PKCS8Privkey(char* pInpBuf,
                                   int InpOffset, int InpLen,
                                   IDATPARR** pDatArrayDesc,
                                   int* pPrivKeyAlgorID,
                                   int* pKeyUsage, int* pUsageIsPresent,
                                   int* SubErrCode)
{
   int Retcode,PKCS12PrivKeyAlgorID;

   IDATA* pIdata;
   IDATA** ppArr;
   int pTmpID[1];
   int pTmpLong[1];

   IDATPARR* ppTmpDesc[1];
   IDATPARR* ppTmpDesc2[1];

   if((pInpBuf == NULL) || (pDatArrayDesc == NULL) ||
      (pPrivKeyAlgorID == NULL))
      return(PKCS12_NULL_PTR);

   pPrivKeyAlgorID[0] = INVALID_ALGOR;
   pDatArrayDesc[0] = NULL;
   ppTmpDesc[0] = NULL;
   ppTmpDesc2[0] = NULL;

   for(;;) // Error processing FOR
   {
      //------------------------------------------------------------
      // Decode PKCS8 Structure first
      //------------------------------------------------------------
      if((Retcode = FromASN1_PKCS8PrivkeyInfo(pInpBuf, InpOffset,InpLen,
         ppTmpDesc, SubErrCode)) != PKCS12_OP_OK)
         return(Retcode);
      //------------------------------------------------------------
      // Check for Correct Version
      //------------------------------------------------------------
      ppArr = ppTmpDesc[0]->ppArr;
      pIdata = ppArr[PKCS8_PRIVKEYINFO_VERSION_INDEX];
      if((Retcode = ByteBufToUnsignedBIT32Num(pIdata->Base,(int) pIdata->Off,pIdata->Len,pTmpLong)) != ASN1_OP_OK)
         break;
      if(pTmpLong[0] != 0)
      {
         Retcode = PKCS8_PRIVKEYINFO_UNKNOWN_VERS;
         break;
      }
      //---------------------------------------------------------
      // Check the AlgorID if known, get type for processing
      //---------------------------------------------------------
      pIdata = ppArr[PKCS8_PRIVKEYINFO_ALGID_INDEX];

      if((Retcode = GetPKCS12_PrivkeyAlgorTypeID(pIdata->Base,
         (int) pIdata->Off, pIdata->Len,pTmpID)) !=
         PKCS12_OP_OK)
         break;
      //----------------------------------------------------------
      // Subdecode the data according to private Key algorithm
      //----------------------------------------------------------
      PKCS12PrivKeyAlgorID = pTmpID[0];
      switch(PKCS12PrivKeyAlgorID)
      {
         //----------------------------------------------------------
         // RSA-Key, subdecode direct
         //----------------------------------------------------------
      case PKCS12_PRIVKEY_ALGOR_RSA:
         pPrivKeyAlgorID[0] = RSA_PUBLIC_ALGOR;
         pIdata = ppArr[PKCS8_PRIVKEYINFO_PRIVDAT_INDEX];
         Retcode = FromASN1_Type(HMEM_CTX_REF1 
                                 pIdata->Base,
                                 (int) pIdata->Off,
                                 pIdata->Len,
                                 (char *) PKCS1PrivKeyCtl,
                                 PKCS1_PRIVKEY_CTL_CNT,
                                 PKCS1_PRIVKEY_MAX_DATA_INDEX,
                                 PKCS1_PRIVKEY_TO_INT_ERR,
                                 pDatArrayDesc,
                                 SubErrCode);
         break;
         //----------------------------------------------------------
         // X9.57 DSA-Key, more complex
         //----------------------------------------------------------
      case PKCS12_PRIVKEY_ALGOR_X957_DSA:
         pPrivKeyAlgorID[0] = DSA_PUBLIC_ALGOR;
         pIdata = ppArr[PKCS8_PRIVKEYINFO_ALGPAR_INDEX];
         //----------------------------------------------------------
         // NOTE: we allocate the params and data together, but parse
         // ----- the Parameters first
         //----------------------------------------------------------
         if((Retcode =  FromASN1_Type(HMEM_CTX_REF1 
                                      pIdata->Base,
                                      (int) pIdata->Off,
                                      pIdata->Len,
                                      (char *) X957AlgParamsCtl,
                                      X957_ALGPAR_CTL_CNT,
                                      X957_PRIVKEY_MAX_DATA_INDEX,
                                      X957_ALGPARS_TO_INT_ERR,
                                      pDatArrayDesc,
                                      SubErrCode)) != PKCS12_OP_OK)
            break;
         //----------------------------------------------------------
         // now extract the embedded private value X Integer
         //----------------------------------------------------------
         pIdata = ppArr[PKCS8_PRIVKEYINFO_PRIVDAT_INDEX];
         if((Retcode =  FromASN1_INTEGER(pIdata->Base,
            (int) pIdata->Off, pIdata->Len,
            ppTmpDesc2, SubErrCode)) != PKCS12_OP_OK)
            break;
         //----------------------------------------------------------
         // Copy contents of describing element to output
         //----------------------------------------------------------
         CopyIdataContents(pDatArrayDesc[0]->ppArr[X957_PRIVKEY_PRIV_X_INDEX],ppTmpDesc2[0]->ppArr[0]);
         break;

      default:				// should not happen
         Retcode = PKCS12_UNKNOWN_PRIVKEY_ALGOR;
         break;
      }
      if(Retcode != PKCS12_OP_OK)
         break;
      //--------------------------------------------------------------
      // Get the Key usage from Attributes (if present)
      //--------------------------------------------------------------
      pIdata = ppArr[PKCS8_PRIVKEYINFO_ATTSSET_INDEX];
      Retcode = GetX509KeyUsage(pIdata->Base,
         (int) pIdata->Off, pIdata->Len,
         pKeyUsage, pUsageIsPresent);
      break;
   } // Error FOR

   FreeIDATPARR_Struc(HMEM_CTX_REF1 ppTmpDesc[0]);
   FreeIDATPARR_Struc(HMEM_CTX_REF1 ppTmpDesc2[0]);
   //----------------------------------------------------
   // Generate local copy of Descriptor array
   //----------------------------------------------------
   if(Retcode == PKCS12_OP_OK)
      Retcode = CopyToLocalDatArrayDesc(HMEM_CTX_REF1 pDatArrayDesc[0]);

   if(Retcode != PKCS12_OP_OK)
   {
      FreeIDATPARR_Struc(HMEM_CTX_REF1 pDatArrayDesc[0]);
      pPrivKeyAlgorID[0] = INVALID_ALGOR;
   }
   return(Retcode);
}

//()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()
//
// ASN.1 Encoder Routines
//
//()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()

/**
* Generate OID-ARC from given ARC with/without following SubArcID, put
* to given Descriptor Element (GenOIDArcSetSubID).
* NOTE: OID Header will be added by ASN.1 processor
*
*  @param pArcBuf Array Base
*  @param ArcOff Start of Data
*  @param ArcLen Length of Data
*  @param SetSubArcFlag <> 0 -> set SubArc byte
*  @param SubArcID SubArc to set
*  @param ppDstDesc IN/OUT
*  @param DstIndex Index to load
*  @param DstAllocSize Size for Alloc if Dst == NULL
*  @return int Status, 0 - o.k., else Error occured
*/
static  int  GenOIDArcSetSubID(char* pArcBuf, int ArcOff,
                               int ArcLen, int SetSubArcFlag, int SubArcID,
                               IDATPARR** ppDstDesc, int DstIndex, int DstAllocSize)
{
   int Retcode;
   int BufLen = ArcLen;
   char* pBuf;
   //---------------------------------------------------------
   // Check parameters
   //---------------------------------------------------------
   if(pArcBuf == NULL)
      return(PKCS12_NULL_PTR);
   if(ArcLen <= 0)
      return(PKCS12_PARAM_ERR);
   //---------------------------------------------------------
   // Allocate required Buffer for ARC
   //---------------------------------------------------------
   if(SetSubArcFlag != 0)
      BufLen++;
   if((pBuf = BIT8_ARRAY_ALLOC(HMEM_CTX_REF,BufLen)) == NULL)  
      return(PKCS12_ALLOC_ERR);
   //---------------------------------------------------------
   // Copy the Arc to the buffer
   //---------------------------------------------------------
   memcpy(pBuf+0,pArcBuf+ArcOff,ArcLen);
   if(SetSubArcFlag != 0)
      pBuf[ArcLen] = (unsigned char) SubArcID;
   //-----------------------------------------------------------
   // Check/Allocate Destination descriptor
   //-----------------------------------------------------------
   if((Retcode = CheckAllocDesc(ppDstDesc, DstIndex,
      DstAllocSize, NULL)) != PKCS12_OP_OK)
   {
      FREE_ARRAY(HMEM_CTX_REF,pBuf);
      return(Retcode);
   }
   //-----------------------------------------------------------
   // Put buffer to Destination Element, if already set, free it
   //-----------------------------------------------------------
   return(FromBufToDesc(HMEM_CTX_REF1 pBuf,0,BufLen,DstIndex,0,ppDstDesc));
}
/**
* Generate Byte Representation of an unsigned BIT32 number, put
* to given Descriptor Element (GenUnsignedBit32Num).
*
*  @param Number Number to convert
*  @param ppDstDesc IN/OUT
*  @param DstIndex Index to load
*  @param DstAllocSize Size for Alloc if Dst == NULL
*  @return int Status, 0 - o.k., else Error occured
*/
static  int  GenUnsignedBit32Num(int Number,
                                 IDATPARR** ppDstDesc, int DstIndex, int DstAllocSize)
{
   int Retcode;

   int pTmpLen[1];
   char* ppTmpBuf[1];
   //---------------------------------------------------------
   // Convert number to byte string
   //---------------------------------------------------------
   if((Retcode = UnsignedBIT32NumToByteBuf(HMEM_CTX_REF1 Number,ppTmpBuf,pTmpLen)) != ASN1_OP_OK)
      return(Retcode);
   //-----------------------------------------------------------
   // Check/Allocate Destination descriptor
   //-----------------------------------------------------------
   if((Retcode = CheckAllocDesc(ppDstDesc, DstIndex,
      DstAllocSize, NULL)) != PKCS12_OP_OK)
   {
      FREE_ARRAY(HMEM_CTX_REF,ppTmpBuf[0]);
      return(Retcode);
   }
   //-----------------------------------------------------------
   // Put buffer to Destination Element, if already set, free it
   //-----------------------------------------------------------
   return(FromBufToDesc(HMEM_CTX_REF1 ppTmpBuf[0],0,pTmpLen[0],DstIndex,0,ppDstDesc));
}
/**
* Generate X509 id-ce OID Arc, put to given Descriptor Element (GenX509_ExtAtt_OIDArc).
*
*  @param ExtAttID Extended Attribute Type to set
*  @param ppDstDesc IN/OUT
*  @param DstIndex Index to load
*  @param DstAllocSize Size for Alloc if Dst == NULL
*  @return int Status, 0 - o.k., else Error occured
*/
static  int  GenX509_ExtAtt_OIDArc(int ExtAttID,
                                   IDATPARR** ppDstDesc, int DstIndex, int DstAllocSize)
{
   return(GenOIDArcSetSubID(X509_IdCeBaseOID, 0, X509_ID_CE_BASE_OID_LEN,
      1, ExtAttID,
      ppDstDesc, DstIndex, DstAllocSize));
}

/**
* Generate PKCS1-RSA Algor OID Arc, put to given Descriptor Element (GenPKCS1_RSA_AlgorOIDArc).
*
*  @param PKCS1_RSAAlgorID AlgorType to set (SubARC)
*  @param ppDstDesc IN/OUT
*  @param DstIndex Index to load
*  @param DstAllocSize Size for Alloc if Dst == NULL
*  @return int Status, 0 - o.k., else Error occured
*/
static  int  GenPKCS1_RSA_AlgorOIDArc(int PKCS1_RSAAlgorID,
                                      IDATPARR** ppDstDesc, int DstIndex, int DstAllocSize)
{
   return(GenOIDArcSetSubID((char*) PKCS1_RsaAlgorsBaseOID, 0,
      PKCS1_RSA_ALGORS_BASE_OID_LEN,
      1, PKCS1_RSAAlgorID,
      ppDstDesc, DstIndex, DstAllocSize));
}
/**
* Generate PKCS2-RSA DigestAlgor OID Arc, put to given Descriptor Element (GenPKCS2_DigestAlgorOIDArc).
*
*  @param PKCS2_DigestAlgorID AlgorType to set (SubARC)
*  @param ppDstDesc IN/OUT
*  @param DstIndex Index to load
*  @param DstAllocSize Size for Alloc if Dst == NULL
*  @return int Status, 0 - o.k., else Error occured
*/
static  int  GenPKCS2_DigestAlgorOIDArc(int PKCS2_DigestAlgorID,
                                        IDATPARR** ppDstDesc, int DstIndex, int DstAllocSize)
{
   return(GenOIDArcSetSubID((char*) PKCS2_DigestAlgorsBaseOID, 0,
      PKCS2_DIGEST_ALGS_BASE_OID_LEN,
      1, PKCS2_DigestAlgorID,
      ppDstDesc, DstIndex, DstAllocSize));
}
/**
* Generate PKCS7 ContentType OID Arc, put to given Descriptor Element (GenPKCS7_ContentTypeOIDArc).
*
*  @param PKCS7_ContentTypeID ContentType to set (SubARC)
*  @param ppDstDesc IN/OUT
*  @param DstIndex Index to load
*  @param DstAllocSize Size for Alloc if Dst == NULL
*  @return int Status, 0 - o.k., else Error occured
*/
static  int  GenPKCS7_ContentTypeOIDArc(int PKCS7_ContentTypeID,
                                        IDATPARR** ppDstDesc, int DstIndex, int DstAllocSize)
{
   return(GenOIDArcSetSubID((char*) PKCS7ContentTypesBaseOID, 0,
      PKCS7_CONT_TYPES_BASE_OID_LEN,
      1, PKCS7_ContentTypeID,
      ppDstDesc, DstIndex, DstAllocSize));
}
/**
* Generate PKCS9 AttrributeType OID Arc, put to given Descriptor Element (GenPKCS9_AttTypeOIDArc).
*
*  @param PKCS9_AttTypeID Attribute Type to set (SubARC)
*  @param ppDstDesc IN/OUT
*  @param DstIndex Index to load
*  @param DstAllocSize Size for Alloc if Dst == NULL
*  @return int Status, 0 - o.k., else Error occured
*/
static  int  GenPKCS9_AttTypeOIDArc(int PKCS9_AttTypeID,
                                    IDATPARR** ppDstDesc, int DstIndex, int DstAllocSize)
{
   return(GenOIDArcSetSubID((char*) PKCS9AttTypesBaseOID, 0,
      PKCS9_ATT_TYPES_BASE_OID_LEN,
      1, PKCS9_AttTypeID,
      ppDstDesc, DstIndex, DstAllocSize));
}
/**
* Generate PKCS9 CertType OID Arc, put to given Descriptor Element (GenPKCS9_CertTypeOIDArc).
*
*  @param PKCS9_CertTypeID Cert Type to set (SubARC)
*  @param ppDstDesc IN/OUT
*  @param DstIndex Index to load
*  @param DstAllocSize Size for Alloc if Dst == NULL
*  @return int Status, 0 - o.k., else Error occured
*/
static  int  GenPKCS9_CertTypeOIDArc(int PKCS9_CertTypeID,
                                     IDATPARR** ppDstDesc, int DstIndex, int DstAllocSize)
{
   return(GenOIDArcSetSubID((char*) PKCS9CertTypesBaseOID, 0,
      PKCS9_CERT_TYPES_BASE_OID_LEN,
      1, PKCS9_CertTypeID,
      ppDstDesc, DstIndex, DstAllocSize));
}
/**
* Generate PKCS12-V1 TransportModeType OID Arc, put to given Descriptor Element (GenPFX_TranspModeOIDArc).
*
*               int PFX_TranspTypeID TransportMode to set (SubARC)
*  @param ppDstDesc IN/OUT
*  @param DstIndex Index to load
*  @param DstAllocSize Size for Alloc if Dst == NULL
*  @return int Status, 0 - o.k., else Error occured
*/
static  int  GenPFX_TranspModeOIDArc(int PFX_TranspModeID,
                                     IDATPARR** ppDstDesc, int DstIndex, int DstAllocSize)
{
   return(GenOIDArcSetSubID((char*) PFX_ModeIDsBaseOID, 0,
      PFX_MODE_IDS_BASE_OID_LEN,
      1, PFX_TranspModeID,
      ppDstDesc, DstIndex, DstAllocSize));
}

/**
* Generate PKCS12-V3 PBE-Algor OID Arc, put to given Descriptor Element (GenPKCS12_PBE_AlgorOIDArc).
*
*  @param PKCS12_PBEAlgorID AlgorType to set (SubARC)
*  @param ppDstDesc IN/OUT
*  @param DstIndex Index to load
*  @param DstAllocSize Size for Alloc if Dst == NULL
*  @return int Status, 0 - o.k., else Error occured
*/
static  int  GenPKCS12_PBE_AlgorOIDArc(int PKCS12_PBEAlgorID,
                                       IDATPARR** ppDstDesc, int DstIndex, int DstAllocSize)
{
   return(GenOIDArcSetSubID((char*) PKCS12PbeTypesBaseOID, 0,
      PKCS12_PBE_TYPES_BASE_OID_LEN,
      1, PKCS12_PBEAlgorID,
      ppDstDesc, DstIndex, DstAllocSize));
}
/**
* Generate PKCS12-V1 Espvk Algor OID Arc, put to given Descriptor Element (GenPFX_ESPVK_TypeOIDArc).
*
*  @param PFX_EspvkID Type to set (SubARC)
*  @param ppDstDesc IN/OUT
*  @param DstIndex Index to load
*  @param DstAllocSize Size for Alloc if Dst == NULL
*  @return int Status, 0 - o.k., else Error occured
*/
static  int  GenPFX_ESPVK_TypeOIDArc(int PFX_EspvkID,
                                     IDATPARR** ppDstDesc, int DstIndex, int DstAllocSize)
{
   return(GenOIDArcSetSubID((char*) PFX_EspvkIDsBaseOID, 0,
      PFX_ESPVK_IDS_BASE_OID_LEN,
      1, PFX_EspvkID,
      ppDstDesc, DstIndex, DstAllocSize));
}
/**
* Generate PKCS12-V1 BagType OID Arc, put to given Descriptor Element (GenPFX_BagType_OIDArc).
*
*  @param PFX_BagTypeID Type to set (SubARC)
*  @param ppDstDesc IN/OUT
*  @param DstIndex Index to load
*  @param DstAllocSize Size for Alloc if Dst == NULL
*  @return int Status, 0 - o.k., else Error occured
*/
static  int  GenPFX_BagType_OIDArc(int PFX_BagTypeID,
                                   IDATPARR** ppDstDesc, int DstIndex, int DstAllocSize)
{
   return(GenOIDArcSetSubID((char*) PFX_BagIDsBaseOID, 0,
      PFX_BAG_IDS_BASE_OID_LEN,
      1, PFX_BagTypeID,
      ppDstDesc, DstIndex, DstAllocSize));
}
/**
* Generate PKCS12-V1 CertType OID Arc, put to given Descriptor Element (GenPFX_CertType_OIDArc).
*
*  @param PFX_CertTypeID Type to set (SubARC)
*  @param ppDstDesc IN/OUT
*  @param DstIndex Index to load
*  @param DstAllocSize Size for Alloc if Dst == NULL
*  @return int Status, 0 - o.k., else Error occured
*/
static  int  GenPFX_CertType_OIDArc(int PFX_CertTypeID,
                                    IDATPARR** ppDstDesc, int DstIndex, int DstAllocSize)
{
   return(GenOIDArcSetSubID((char*) PFX_CertIDsBaseOID, 0,
      PFX_CERT_IDS_BASE_OID_LEN,
      1, PFX_CertTypeID,
      ppDstDesc, DstIndex, DstAllocSize));
}
/**
* Generate PKCS12-V1 EncryptPBEType OID Arc, put to given Descriptor Element (GenPFX_EncPBEType_OIDArc).
*
*  @param PFX_EncPBETypeID Type to set (SubARC)
*  @param ppDstDesc IN/OUT
*  @param DstIndex Index to load
*  @param DstAllocSize Size for Alloc if Dst == NULL
*  @return int Status, 0 - o.k., else Error occured
*/
static  int  GenPFX_EncPBEType_OIDArc(int PFX_EncPBETypeID,
                                      IDATPARR** ppDstDesc, int DstIndex, int DstAllocSize)
{
   return(GenOIDArcSetSubID((char*) PFX_EncPbeIDsBaseOID,0,
      PFX_ENC_PBE_IDS_BASE_OID_LEN,
      1, PFX_EncPBETypeID,
      ppDstDesc, DstIndex, DstAllocSize));
}

/**
* Generate PKCS12-V3 BagType OID Arc, put to given Descriptor Element (GenPKCS12_BagType_OIDArc).
*
*  @param PKCS12_BagTypeID Type to set (SubARC)
*  @param ppDstDesc IN/OUT
*  @param DstIndex Index to load
*  @param DstAllocSize Size for Alloc if Dst == NULL
*  @return int Status, 0 - o.k., else Error occured
*/
static  int  GenPKCS12_BagType_OIDArc(int PKCS12_BagTypeID,
                                      IDATPARR** ppDstDesc, int DstIndex, int DstAllocSize)
{
   return(GenOIDArcSetSubID((char*) PKCS12BagTypesBaseOID, 0,
      PKCS12_BAG_TYPES_BASE_OID_LEN,
      1, PKCS12_BagTypeID,
      ppDstDesc, DstIndex, DstAllocSize));
}

/**
* Generate X9.57-DSA Algor OID Arc, put to given Descriptor Element (GenX957_DSA_AlgorOIDArc).
*
*  @param X957_DSAAlgorID AlgorType to set (SubARC)
*  @param ppDstDesc IN/OUT
*  @param DstIndex Index to load
*  @param DstAllocSize Size for Alloc if Dst == NULL
*  @return int Status, 0 - o.k., else Error occured
*/
static  int  GenX957_DSA_AlgorOIDArc(int X957_DSAAlgorID,
                                     IDATPARR** ppDstDesc, int DstIndex, int DstAllocSize)
{
   return(GenOIDArcSetSubID((char*) X957_DsaAlgorsBaseOID, 0,
      X957_DSA_ALGORS_BASE_OID_LEN,
      1, X957_DSAAlgorID,
      ppDstDesc, DstIndex, DstAllocSize));
}
/**
* Generate OIW-DSA Algor OID Arc, put to given Descriptor Element (GenOIW_DSA_AlgorOIDArc).
*
*  @param OIW_DSAAlgorID AlgorType to set (SubARC)
*  @param ppDstDesc IN/OUT
*  @param DstIndex Index to load
*  @param DstAllocSize Size for Alloc if Dst == NULL
*  @return int Status, 0 - o.k., else Error occured
*/
static  int  GenOIW_DSA_AlgorOIDArc(int OIW_DSAAlgorID,
                                    IDATPARR** ppDstDesc, int DstIndex, int DstAllocSize)
{
   return(GenOIDArcSetSubID((char*) OIW_AlgorsBaseOID, 0,
      OIW_ALGORS_BASE_OID_LEN,
      1, OIW_DSAAlgorID,
      ppDstDesc, DstIndex, DstAllocSize));
}
/**
* Generate ASN.1 Encoded PBE Parameters from given Salt and
* IterationCount, put to given Descriptor (ToASN1_PBEParamsToDesc).
*
*  @param pSalt
*  @param SaltOff
*  @param SaltLen
*  @param IteratCnt
*  @param ppDstDesc IN/OUT
*  @param DstIndex Element to load
*  @param DstAllocSize Number of Elements required
*
*  @return int Status - ASN1_OP_OK: o.k.
* <br>            - else Error occured
*/
static  int  ToASN1_PBEParamsToDesc(char* pSalt, int SaltOff,
                                    int SaltLen, int IteratCnt, IDATPARR** ppDstDesc, int DstIndex,
                                    int DstAllocSize)
{
   int Retcode;

   IDATPARR* ppTmpDesc[1];
   //-----------------------------------------------------------
   // Check parameters
   //-----------------------------------------------------------
   if(pSalt == NULL)
      return(PKCS12_NULL_PTR);
   //-----------------------------------------------------------
   // Generate / Fill Descriptor for PBE Params
   //-----------------------------------------------------------
   ppTmpDesc[0] = NULL;			// Force Allocate
   if((Retcode = FromBufToDescAlloc(pSalt, SaltOff, SaltLen,
      ppTmpDesc, PKCS12_PBE_PARAMS_SALT_INDEX,
      PKCS12_PBE_PARAMS_MAX_DATA_IND)) != PKCS12_OP_OK)
      return(Retcode);
   if((Retcode = GenUnsignedBit32Num(IteratCnt, ppTmpDesc,
      PKCS12_PBE_PARAMS_ITERAT_INDEX,0)) != PKCS12_OP_OK)
   {
      FreeIDATPARR_Struc(HMEM_CTX_REF1 ppTmpDesc[0]);
      return(Retcode);
   }
   //-----------------------------------------------------------
   // Convert to ASN.1 Representation
   //-----------------------------------------------------------
   if((Retcode = ToASN1_PKCS12PbeParamsDesc(ppTmpDesc[0], 0,
      ppDstDesc, DstIndex, DstAllocSize, NULL)) != PKCS12_OP_OK)
      FreeIDATPARR_Struc(HMEM_CTX_REF1 ppTmpDesc[0]);
   return(Retcode);
}
/**
* Subroutine ToASN1_PKCS8PrivkeyDesc extracts data from internal
* private key notation in HASN1.C format according to given algorithm
* and ASN.1 encodes it to PKCS8 PrivateKeyInfo (ToASN1_PKCS8PrivkeyDesc).
*
* Note: The private key format is built according to the format
* ----- used in HASN1.C:
*	RSA				DSA
*	----------------		---------------------
* 	Dummy Slot, unused		p	Modul
*	n	Modul			q	Divisor of (p-1)
*	e	Publ.Exp.		g	Generator
*	d	Priv.Exp.		y	Public value [empty slot!]
*	p	Prime1			x	Private value
*	q	Prime2			Dummy Slot, unused
*	dmodp	Exponent1 d mod(p-1)
*	dmodq	Exponent2 d mod(q-1)
*	qmp	Coefficient q**-1mod(p)
*
* NOTE: For DSA the public value Y in the private key
* ----- is *NOT* stored for X9.57.
*
*  @param pSrcDesc Private key elements
*  @param PrivKeyAlgorID Algorithm used
*  @param UsageIsPresent Should set key usage
*  @param KeyUsage Key Usage bits, MSB aligned !
*  @param ppDstDesc Array Descriptor
*  @param DstIndex Slot to use
*  @param DstAllocSize Slots needed if allocate
*  @return int Status - 0 o.k., else error occured
*/
static  int  ToASN1_PKCS8PrivkeyDesc(IDATPARR* pSrcDesc,
                                     int PrivKeyAlgorID, int UsageIsPresent, int KeyUsage,
                                     IDATPARR** ppDstDesc, int DstIndex, int DstAllocSize)
{
   int Retcode;

   IDATA* pIdata;
   IDATA** ppArr;
   int pTmpLen[1];

   char TmpBuf[2];
   char* ppTmpBuf[1];

   IDATPARR* ppTmpDesc[1];
   IDATPARR* ppTmpDesc2[1];

   if((pSrcDesc == NULL) || ((ppArr = pSrcDesc->ppArr) == NULL) ||
      (ppDstDesc == NULL))
      return(PKCS12_NULL_PTR);
   if((PrivKeyAlgorID != RSA_PUBLIC_ALGOR) &&
      (PrivKeyAlgorID != DSA_PUBLIC_ALGOR))
      return(PKCS12_PARAM_ERR);

   ppTmpBuf[0]   = NULL;
   ppTmpDesc[0]  = NULL;
   ppTmpDesc2[0] = NULL;

   for(;;) // Error processing FOR
   {
      //--------------------------------------------------------------
      // 1. Generate the Version Number (0), allocate the full descriptor
      //--------------------------------------------------------------
      ppTmpDesc[0] = NULL;			// Force Allocate
      if((Retcode = GenUnsignedBit32Num(0, ppTmpDesc,
         PKCS8_PRIVKEYINFO_VERSION_INDEX,
         PKCS8_PRIVKEYINFO_MAX_DATA_IND)) != PKCS12_OP_OK)
         return(Retcode);
      //--------------------------------------------------------------
      // 2. Set the private Key Algor OID
      //--------------------------------------------------------------
      if(PrivKeyAlgorID == RSA_PUBLIC_ALGOR)
      {
         if((Retcode = GenPKCS1_RSA_AlgorOIDArc(PKCS1_RSA_ALGOR_SUBID,
            ppTmpDesc, PKCS8_PRIVKEYINFO_ALGID_INDEX,
            0)) != PKCS12_OP_OK)
            break;
      }
      else
      {
         if((Retcode = GenX957_DSA_AlgorOIDArc(X957_DSA_ALGOR_SUBID,
            ppTmpDesc, PKCS8_PRIVKEYINFO_ALGID_INDEX,
            0)) != PKCS12_OP_OK)
            break;
      }
      //---------------------------------------------------------------
      // 3. Generate the Algorithm Parameters
      //---------------------------------------------------------------
      if(PrivKeyAlgorID == RSA_PUBLIC_ALGOR)
      {
         //-------------------------------------------------------------
         // RSA, no parameters, generate ASN.1 NULL
         //-------------------------------------------------------------
         TmpBuf[0] = ASN1_UNIVERSAL_NULL;
         TmpBuf[1] = 0;
         if((Retcode = FromBufToDatArray(HMEM_CTX_REF1 ppTmpDesc[0]->ppArr,PKCS8_PRIVKEYINFO_ALGPAR_INDEX,TmpBuf,0,2,1)) != ASN1_OP_OK)
            break;
      }
      else
      {
         //-------------------------------------------------------------
         // DSA, P, Q and G must be encoded for the X9.57 parameters
         //-------------------------------------------------------------
         if((Retcode = ToASN1_DescToDesc(pSrcDesc, DSA_ALG_PAR_P_INDEX,
            (char *) X957AlgParamsCtl,
            X957_ALGPAR_CTL_CNT,
            X957_ALGPARS_FROM_INT_ERR,
            ppTmpDesc, PKCS8_PRIVKEYINFO_ALGPAR_INDEX, 0,
            NULL)) != PKCS12_OP_OK)
            break;
      }
      //---------------------------------------------------------------
      // 4. Generate the Private Parameters
      //---------------------------------------------------------------
      if(PrivKeyAlgorID == RSA_PUBLIC_ALGOR)
      {
         //-------------------------------------------------------------
         // RSA, Private parameters must be packed to PKCS1 private key
         //-------------------------------------------------------------
         ppTmpDesc2[0] = NULL;			// Force Allocate
         if((Retcode = GenUnsignedBit32Num(0, ppTmpDesc2,
            PKCS1_PRIVKEY_VERSION_INDEX,
            PKCS1_PRIVKEY_MAX_DATA_INDEX)) != PKCS12_OP_OK)
            break;

         if((Retcode = AllocCopyDatArrayToDatArray(HMEM_CTX_REF1 
                                                   pSrcDesc,
                                                   (RSA_ALG_PAR_MAX_INDEX+RSA_PRIV_KEY_MODULUS_INDEX),
                                                   ppTmpDesc2[0],
                                                   PKCS1_PRIVKEY_MODUL_INDEX,
                                                   (RSA_PRIV_KEY_MAX_INDEX-1),
                                                   1)) != ASN1_OP_OK)
            break;

         if((Retcode = ToASN1_DescToDesc(ppTmpDesc2[0], 0,
            (char *) PKCS1PrivKeyCtl,
            PKCS1_PRIVKEY_CTL_CNT,
            PKCS1_PRIVKEY_FROM_INT_ERR,
            ppTmpDesc, PKCS8_PRIVKEYINFO_PRIVDAT_INDEX, 0,
            NULL)) != PKCS12_OP_OK)
            break;

         FreeIDATPARR_Struc(HMEM_CTX_REF1 ppTmpDesc2[0]);
         ppTmpDesc2[0] = NULL;
      }
      else
      {
         //----------------------------------------------------------------
         // DSA, Private parameter X must be set as an Integer, COPY FIRST!
         //----------------------------------------------------------------
         ppTmpDesc2[0] = NULL;			// force allocate
         pIdata = ppArr[DSA_ALG_PAR_MAX_INDEX+DSA_PRIV_KEY_XKEY_INDEX];
         if((Retcode = FromBufToDescAllocCopy(pIdata->Base,
            (int) pIdata->Off, pIdata->Len,
            ppTmpDesc2, 0, 1)) != PKCS12_OP_OK)
            break;

         if((Retcode = ToASN1_DescToDesc(ppTmpDesc2[0], 0,
            (char *) ASN1IntegerCtl,ASN1_INTEGER_CTL_CNT,
            X957_PRIVVAL_FROM_INT_ERR,
            ppTmpDesc, PKCS8_PRIVKEYINFO_PRIVDAT_INDEX, 0,
            NULL)) != PKCS12_OP_OK)
            break;

         FreeIDATPARR_Struc(HMEM_CTX_REF1 ppTmpDesc2[0]);
         ppTmpDesc2[0] = NULL;
      }
      //------------------------------------------------
      // 5. Set Key Usage Attribute if KeyUsage is given
      //------------------------------------------------
      if(UsageIsPresent != 0)
      {
         //-------------------------------------------------
         // 5.1 Generate the X509 ExtAtt KeyUsage OID
         //-------------------------------------------------
         ppTmpDesc2[0] = NULL;				// Force Allocate
         if((Retcode = GenX509_ExtAtt_OIDArc(X509_ID_CE_KEY_USAGE_SUBID,
            ppTmpDesc2, X501_AVA_ATTRIB_OID_INDEX,
            X501_AVA_MAX_DATA_INDEX)) != PKCS12_OP_OK)
            break;
         //--------------------------------------------------------
         // 5.2 Generate the Bitstring Value SET, put to descriptor
         //--------------------------------------------------------
         if((Retcode = ToASN1_32MsbBitsBitstringBuf(KeyUsage,
            ppTmpBuf, pTmpLen)) != PKCS12_OP_OK)
            break;

         if((Retcode = ToASN1_BufToDescSET(ppTmpBuf[0], 0, pTmpLen[0],
            ppTmpDesc2,X501_AVA_ATTRIB_VALUE_INDEX,
            0)) != PKCS12_OP_OK)
            break;
         ppTmpBuf[0] = NULL;			// Avoid Freeing
         //-------------------------------------------------------
         // 5.3 Put Attribute to slot
         // NOTE: Is an IMPLICIT SET, but we have only one Element
         //-------------------------------------------------------
         if((Retcode = ToASN1_DescToDesc(ppTmpDesc2[0], 0,
            (char *) X501AvaCtl, X501_AVA_CTL_CNT,
            X501_AVA_FROM_INT_ERROR,
            ppTmpDesc, PKCS8_PRIVKEYINFO_ATTSSET_INDEX,0,
            NULL)) != PKCS12_OP_OK)
            break;
         FreeIDATPARR_Struc(HMEM_CTX_REF1 ppTmpDesc2[0]);
         ppTmpDesc2[0] = NULL;			// avoid freeing
      }
      //---------------------------------------------------------
      // 6. ASN.1 encode the PKCS8 Private Key Info now  
      //---------------------------------------------------------
      Retcode = ToASN1_PKCS8PrivkeyInfoDesc(ppTmpDesc[0], 0,
         ppDstDesc, DstIndex, DstAllocSize, NULL);
      break;
   } // Error FOR

   FREE_ARRAY(HMEM_CTX_REF,ppTmpBuf[0]);
   FreeIDATPARR_Struc(HMEM_CTX_REF1 ppTmpDesc[0]);
   FreeIDATPARR_Struc(HMEM_CTX_REF1 ppTmpDesc2[0]);
   return(Retcode);
}

/**
* Generate PKCS9 FriendlyName and/or LocalKeyID X501 Attribute Type/Value
* Pair(s) embedded in an ASN.1 sequence, but without ASN.1 SET OF Header (PKCS12_GenPKCS9SelectedAtts).
* NOTE: if both absent an empty entry is generated
* -----
*
*  @param pFriendlyName FriendlyName/NULL UNICODE !!
*  @param FriendlyNameOff Start of data
*  @param FriendlyNameLen Size of data
*  @param pLocalKeyID LocalKeyID/NULL
*  @param LocalKeyIDOff Start of data
*  @param LocalKeyIDLen Start of data
*  @param ppDstDesc Descriptor to load/allocate
*  @param DstIndex Slot to use
*  @param DstAllocSize Required slots for allocate
*  @return int Status - 0 o.k., else error occured
*/
static  int  PKCS12_GenPKCS9SelectedAtts(char* pFriendlyName,
                                         int FriendlyNameOff, int FriendlyNameLen,
                                         char* pLocalKeyID, int LocalKeyIDOff, int LocalKeyIDLen,
                                         IDATPARR** ppDstDesc, int DstIndex, int DstAllocSize)
{
   int Retcode;

   int AVACount = 0;
   int AttTypes = 0;
   int AVAIndex;

   IDATPARR* ppTmpDesc[1];
   IDATPARR* ppTmpDesc2[1];

   //-----------------------------------------------------------
   // Check if Any data shall be created
   //-----------------------------------------------------------
   if((pFriendlyName != NULL) && (FriendlyNameLen > 0))
   {
      AVACount ++;
      AttTypes = 0x01;
   }
   if((pLocalKeyID != NULL) && (LocalKeyIDLen > 0))
   {
      AVACount ++;
      AttTypes |= 0x02;
   }
   if(AVACount == 0)
      return(PKCS12_OP_OK);

   for(;;)			// Error FOR
   {
      //-----------------------------------------------------------
      // Allocate required AVA Descriptor
      //-----------------------------------------------------------
      AVAIndex = 0;
      ppTmpDesc[0] = NULL;
      if((Retcode = AllocIDATPARR_Struc(HMEM_CTX_REF1 ppTmpDesc,AVACount*2)) != ASN1_OP_OK)
         return(Retcode);
      ppTmpDesc[0]->Flags |= FREE_BIT_MASK;
      //-----------------------------------------------------------
      // Generate PKCS9 LocalKeyID AVA element if present
      //-----------------------------------------------------------
      if((AttTypes & 0x02) != 0)
      {
         //---------------------------------------------------------
         // Generate PKCS9 LocalKeyID Attribute OID
         //---------------------------------------------------------
         if((Retcode = GenPKCS9_AttTypeOIDArc(PKCS9_ATT_LOCAL_KEYID_SUBID,
            ppTmpDesc, AVAIndex + X501_AVA_ATTRIB_OID_INDEX,
            0)) != PKCS12_OP_OK)
            break;
         //---------------------------------------------------------
         // Generate PKCS9 LocalKeyID Buffer Descriptor (as a COPY!)
         //---------------------------------------------------------
         ppTmpDesc2[0] = NULL;			// Force Allocate
         if((Retcode = FromBufToDescAllocCopy(pLocalKeyID, LocalKeyIDOff,
            LocalKeyIDLen,
            ppTmpDesc2, 0,
            1)) != PKCS12_OP_OK)
            break;
         //---------------------------------------------------------
         // Generate PKCS9 LocalKeyID Attribute Value SET.
         // Attribute Value is an OCTET-String
         //---------------------------------------------------------
         Retcode = ToASN1_UniversalEmbeddedType(ppTmpDesc2[0],
            ASN1_UNIVERSAL_SET, 0,
            (char *) ASN1OctetStrCtl,ASN1_OCTETSTR_CTL_CNT,
            ASN1_OCTETSTR_MAX_DATA_INDEX,
            PKCS9_OCTETSTR_FROM_INT_ERR,
            ppTmpDesc, AVAIndex + X501_AVA_ATTRIB_VALUE_INDEX,
            0, NULL);
         FreeIDATPARR_Struc(HMEM_CTX_REF1 ppTmpDesc2[0]);
         if(Retcode != PKCS12_OP_OK)
            break;
         AVAIndex += X501_AVA_MAX_DATA_INDEX;		// advance to next
      }
      //-----------------------------------------------------------
      // Generate PKCS9 Friendly Name AVA element if present
      //-----------------------------------------------------------
      if((AttTypes & 0x01) != 0)
      {
         //---------------------------------------------------------
         // Generate PKCS9 Friendly Name Attribute OID
         //---------------------------------------------------------
         if((Retcode = GenPKCS9_AttTypeOIDArc(PKCS9_ATT_FRIENDLY_NAME_SUBID,
            ppTmpDesc, AVAIndex + X501_AVA_ATTRIB_OID_INDEX,
            0)) != PKCS12_OP_OK)
            break;
         //------------------------------------------------------------
         // Generate PKCS9 Friendly Name Buffer Descriptor (as a COPY!)
         //------------------------------------------------------------
         ppTmpDesc2[0] = NULL;			// Force Allocate
         if((Retcode = FromBufToDescAllocCopy(pFriendlyName, FriendlyNameOff,
            FriendlyNameLen,
            ppTmpDesc2, 0,
            1)) != PKCS12_OP_OK)
            break;
         //---------------------------------------------------------
         // Generate PKCS9 Friendly Name Attribute Value SET.
         // Attribute Value is a BMP-String
         //---------------------------------------------------------
         Retcode = ToASN1_UniversalEmbeddedType(ppTmpDesc2[0],
            ASN1_UNIVERSAL_SET, 0,
            (char *) ASN1BmpStrCtl,ASN1_BMPSTR_CTL_CNT,
            ASN1_BMPSTR_MAX_DATA_INDEX,
            PKCS9_BMPSTR_FROM_INT_ERR,
            ppTmpDesc, AVAIndex + X501_AVA_ATTRIB_VALUE_INDEX,
            0, NULL);
         FreeIDATPARR_Struc(HMEM_CTX_REF1 ppTmpDesc2[0]);
         if(Retcode != PKCS12_OP_OK)
            break;
         AVAIndex += X501_AVA_MAX_DATA_INDEX;		// advance to next
      }
      //-----------------------------------------------------------
      // Encode the PKCS9 Attribute/Value pairs to X501 AVAs
      // NOT embedded (!)
      //-----------------------------------------------------------
      Retcode = ToASN1_UniversalEmbeddedType(ppTmpDesc[0],
         //			ASN1_UNIVERSAL_SEQUENCE, 0,
         ASN1_UNIVERSAL_NULL, 0,
         (char *) X501AvaCtl, X501_AVA_CTL_CNT,
         X501_AVA_MAX_DATA_INDEX,
         X501_AVA_FROM_INT_ERROR,
         ppDstDesc, DstIndex, DstAllocSize,
         NULL);
      break;
   }
   //-----------------------------------------------------------
   // Free temporary used structures
   //-----------------------------------------------------------
   FreeIDATPARR_Struc(HMEM_CTX_REF1 ppTmpDesc[0]);
   return(Retcode);
}

//()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()
//
// PKCS12 Encrypt/Decrypt routines
//
//()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()

//****************************************************************
//
// HASH / HMAC Functions
//
//****************************************************************

/**
* Initialize MD2, MD5 or SHA1 Hashing (HASH_Init).
* NOTE: no parameters checked !!!
* -----
*
*  @param pHashArray Array to use
*  @param HashType Hash to Use
* 
*/
static  void  HASH_Init(int* pHashArray, int HashType)
{
   //-----------------------------------------------------
   // Distribute by Hash type
   //-----------------------------------------------------
   if(HashType == PKCS12_HASH_TYPE_MD2)
      MD2_Init(pHashArray);
   else if(HashType == PKCS12_HASH_TYPE_MD5)
      MD5_Init(pHashArray);
   else
      SHA1_Init(pHashArray);
}
/**
* Update MD2, MD5 or SHA1 Hash (HASH_Update).
* NOTE: no parameters checked !!!
* -----
*
*  @param pHashArray Array to use
*  @param pData Data to hash
*  @param DataOff Start of data
*  @param DataLen Size of data
*  @param HashType Hash to Use
* 
*/
static  void  HASH_Update(int* pHashArray,
                          char* pData, int DataOff, int DataLen, int HashType)
{
   //-----------------------------------------------------
   // Distribute by Hash type
   //-----------------------------------------------------
   if(HashType == PKCS12_HASH_TYPE_MD2)
      MD2_Update(pHashArray,pData,DataOff,DataLen);
   else if(HashType == PKCS12_HASH_TYPE_MD5)
      MD5_Update(pHashArray,pData,DataOff,DataLen);
   else
      SHA1_Update(pHashArray,pData,DataOff,DataLen);
}
/**
* Finalize MD2, MD5 or SHA1 Hash (HASH_Final).
* NOTE: no parameters checked !!!
* -----
*
*  @param pHashArray Array to use
*  @param pDstBuf Buffer for Digest
*  @param DstOff Start of data
*  @param HashType Hash to Use
* 
*/
static  void  HASH_Final(int* pHashArray,
                         char* pDstBuf, int DstOff, int HashType)
{
   //-----------------------------------------------------
   // Distribute by Hash type
   //-----------------------------------------------------
   if(HashType == PKCS12_HASH_TYPE_MD2)
      MD2_Final(pHashArray,pDstBuf,DstOff);
   else if(HashType == PKCS12_HASH_TYPE_MD5)
      MD5_Final(pHashArray,pDstBuf,DstOff);
   else
      SHA1_Final(pHashArray,pDstBuf,DstOff);
}

/**
* Initialize HMAC using appropriate hash from given key (HMAC_Init).
* NOTE: no parameters checked !!!
* -----
*
*  @param pHashArray Array to use
*  @param pKeySaveBuf Key Saver Buffer
*  @param pKeyData Base of data
*  @param KeyDataOff Start of data
*  @param KeyDataLen Size of key
*  @param HashType Hash to Use
* 
*/
static  void  HMAC_Init(int* pHashArray, char* pKeySaveBuf,
                        char* pKeyData, int KeyDataOff, int KeyDataLen, int HashType)
{
   int KeyLen;

   //-------------------------------------------------------
   // Generate the Key buffer from Key
   //-------------------------------------------------------
   if(KeyDataLen > PKCS12_MAX_DIGEST_BLOCK_LEN)
   {
      //-----------------------------------------------------
      // Must shrink the Key down, use the appropriate hash
      //-----------------------------------------------------
      HASH_Init(pHashArray,HashType);
      HASH_Update(pHashArray,pKeyData,KeyDataOff,KeyDataLen,HashType);
      HASH_Final(pHashArray,pKeySaveBuf,0,HashType);

      if(HashType == PKCS12_HASH_TYPE_MD2)
         KeyLen = MD2_DIGEST_LEN;
      else if(HashType == PKCS12_HASH_TYPE_MD5)
         KeyLen = MD5_DIGEST_LEN;
      else
         KeyLen = SHA_DIGEST_LEN;
   }
   else
   {
      memcpy(pKeySaveBuf+0,pKeyData+KeyDataOff,KeyDataLen);
      KeyLen = KeyDataLen;
   }
   //--------------------------------------------------------
   // Pad the Key with 0x00 till Blocksize is reached
   //--------------------------------------------------------
   ClearBit8Array(pKeySaveBuf, KeyLen, PKCS12_MAX_DIGEST_BLOCK_LEN - KeyLen);

   //--------------------------------------------------------
   // XOR the Key buffer with IPAD (0x36)
   //--------------------------------------------------------
   XorBit8Array(pKeySaveBuf, 0, PKCS12_MAX_DIGEST_BLOCK_LEN, PKCS12_HMAC_IPAD);

   //--------------------------------------------------------
   // Re-Initialize hash from Xored Key
   //--------------------------------------------------------
   HASH_Init(pHashArray,HashType);
   HASH_Update(pHashArray,pKeySaveBuf,0,PKCS12_MAX_DIGEST_BLOCK_LEN,HashType);
}
/**
* Update HMAC using appropriate hash from given Data to Hash (HMAC_Update).
* NOTE: no parameters checked !!!
* -----
*
*  @param pHashArray Array to use
*  @param pHashData Base of data
*  @param HashDataOff Start of data
*  @param HashDataLen Size of data
*  @param HashType Hash to Use
*/
static  void  HMAC_Update(int* pHashArray,
                          char* pHashData, int HashDataOff, int HashDataLen, int HashType)
{
   //--------------------------------------------------------
   // Do a straight forward Update
   //--------------------------------------------------------
   HASH_Update(pHashArray,pHashData,HashDataOff,HashDataLen,HashType);
}
/**
* Finalize HMAC using appropriate hash from Hash Array (HMAC_Final).
* NOTE: no parameters checked !!!
* -----
*
*  @param pHashArray Array to use
*  @param pKeySaveBuf Key Saver Buffer
*  @param pDstBuf Digest Destination Base
*  @param DstOff Start of data
*  @param HashType Hash to Use
*/
static  void  HMAC_Final(int* pHashArray, char* pKeySaveBuf,
                         char* pDstBuf, int DstOff, int HashType)
{
   int HashLen;
   //--------------------------------------------------------
   // Finalize Inner Hash
   //--------------------------------------------------------
   HASH_Final(pHashArray,pDstBuf,DstOff,HashType);
   //--------------------------------------------------------
   // XOR the Saved Key buffer with OPAD (0x5C)
   //--------------------------------------------------------
   XorBit8Array(pKeySaveBuf, 0, PKCS12_MAX_DIGEST_BLOCK_LEN,
      PKCS12_HMAC_IPAD ^ PKCS12_HMAC_OPAD);
   //-----------------------------------------------------------
   // Build hash from concatenation of padded key and Inner Hash
   //-----------------------------------------------------------
   if(HashType == PKCS12_HASH_TYPE_MD2)
      HashLen = MD2_DIGEST_LEN;
   else if(HashType == PKCS12_HASH_TYPE_MD5)
      HashLen = MD5_DIGEST_LEN;
   else
      HashLen = SHA_DIGEST_LEN;

   HASH_Init(pHashArray,HashType);
   HASH_Update(pHashArray,pKeySaveBuf,0,PKCS12_MAX_DIGEST_BLOCK_LEN,HashType);
   HASH_Update(pHashArray,pDstBuf,DstOff,HashLen, HashType);
   HASH_Final(pHashArray,pDstBuf,DstOff,HashType);

   ClearBit8Array(pKeySaveBuf,0,PKCS12_MAX_DIGEST_BLOCK_LEN);
   ClearBit32Array(pHashArray,0,PKCS12_MAX_HASH_ARRAY_SIZE);
}

/**
* Generate iterated Hash of given type for data and count (GenIteratedHash).
* NOTE: 1. no parameters checked !
* ----- 2. MD2, MD5 can be removed if not needed (not used in PKCS12?)
*
*  @param pHashData1 Data to Hash
*  @param HashData1Off Start of data
*  @param HashData1Len Size of data
*  @param pHashData2 Additional Hashdata / NULL
*  @param HashData2Off Start of Data
*  @param HashData2Len Size, may be 0
*  @param pHashData3 Additional Hashdata / NULL
*  @param HashData3Off Start of Data
*  @param HashData3Len Size, may be 0
*  @param pHashData4 Additional Hashdata / NULL
*  @param HashData4Off Start of Data
*  @param HashData4Len Size, may be 0
*  @param HashType Type of Hash:0-MD2,1-MD5,2-SHA1
*  @param IteratCnt Iteration count for Hash
*  @param pDigestBuf Buffer for Result
*  @param DigestOff Start of data
*/
static  void  GenIteratedHash(char* pHashData1, int HashData1Off,
                              int HashData1Len, char* pHashData2, int HashData2Off, int HashData2Len,
                              char* pHashData3, int HashData3Off, int HashData3Len,
                              char* pHashData4, int HashData4Off, int HashData4Len,
                              int HashType, int IteratCnt,	char* pDigestBuf, int DigestOff)
{
   int HashLen;
   int HashArray[PKCS12_MAX_HASH_ARRAY_SIZE];

   //--------------------------------------------------------
   // Initialize Hash, Hash all Input data that are given
   //--------------------------------------------------------
   HASH_Init(HashArray,HashType);
   if((pHashData1 != NULL) && (HashData1Len != 0))
      HASH_Update(HashArray,pHashData1,HashData1Off,HashData1Len,HashType);
   if((pHashData2 != NULL) && (HashData2Len != 0))
      HASH_Update(HashArray,pHashData2,HashData2Off,HashData2Len,HashType);
   if((pHashData3 != NULL) && (HashData3Len != 0))
      HASH_Update(HashArray,pHashData3,HashData3Off,HashData3Len,HashType);
   if((pHashData4 != NULL) && (HashData4Len != 0))
      HASH_Update(HashArray,pHashData4,HashData4Off,HashData4Len,HashType);
   HASH_Final(HashArray,pDigestBuf,DigestOff,HashType);
   //--------------------------------------------------------
   // Iterate the Hash if needed
   //--------------------------------------------------------
   IteratCnt--;
   if(IteratCnt > 0)
   {
      if(HashType == PKCS12_HASH_TYPE_MD2)
         HashLen = MD2_DIGEST_LEN;
      else if(HashType == PKCS12_HASH_TYPE_MD5)
         HashLen = MD5_DIGEST_LEN;
      else
         HashLen = SHA_DIGEST_LEN;

      while(IteratCnt > 0)
      {
         HASH_Init(HashArray,HashType);
         HASH_Update(HashArray,pDigestBuf,DigestOff,HashLen,HashType);
         HASH_Final(HashArray,pDigestBuf,DigestOff,HashType);
         IteratCnt--;
      }
   }
   ClearBit32Array(HashArray,0,PKCS12_MAX_HASH_ARRAY_SIZE);
}
/**
* Perform Addition of 2 equal sized numbers without carry out and with
* initial set Carry, used for calculation of Ik = (Ik + B + 1) mod (2**v);
* the numbers are given in BIG Endian mode (AddNumsNoCyOut).
* NOTE: no parameters checked !
* -----
*
*  @param pNum1Dst First Number in, Result out
*  @param Num1DstOff Start of data / Result
*  @param pNum2 Second Number
*  @param Num2Off Start of data
*  @param NumLen Size of numbers
*/
static  void  AddNumsNoCyOut(char* pNum1Dst, int Num1DstOff,
                             char* pNum2, int Num2Off, int NumLen)
{
   int Sum = 1;

   Num1DstOff += NumLen-1;		// to LSB Byte
   Num2Off    += NumLen-1;		// dto.
   while(NumLen != 0)
   {
      Sum = Sum + ((int) pNum1Dst[Num1DstOff] & 0xFF) +
         ((int) pNum2[Num2Off--] & 0xFF);
      pNum1Dst[Num1DstOff--] = (unsigned char) Sum;
      Sum >>= 8;				// shift down carry
      NumLen--;
   }
}

/**
* Generate Key Material required for Encrypt/Decrypt/IV and HMAC
* used in PKCS12 (see PKCS-12 Spec for Algorithm)
*
*  @param pPasswd Password (Unicode, NUL terminated!)
*  @param PasswdOff Start of Data
*  @param PasswdLen Size of Password, may be 0 (none)
*  @param pSalt Salt data
*  @param SaltOff Start of Data
*  @param SaltLen Size of Salt, may be 0 (none)
*  @param IteratCnt Iteration count for Hash
*  @param HashType Type of Hash: 0-MD2, 1-MD5, 2-SHA1
*  @param KeyIDByte ID-Byte to use
*  @param pDstBuf Buffer for Key material
*  @param DstOff Start of Data
*  @param DstLen Requested size of data
*  @return int Status - 0 o.k., else error occured
*/
static  int  GenPKCS12KeyData(char* pPasswd, int PasswdOff,
                              int PasswdLen, char* pSalt, int SaltOff, int SaltLen,
                              int IteratCnt, int HashType, int KeyIDByte,
                              char* pDstBuf, int DstOff, int DstLen)
{
   int DLen, SLen, PLen, ILen, HLen, LoopCnt;
   int u,v,Index;

   //  BIT8PTR pIBuf  = NULL;
   char* pDIBuf = NULL;

   char AiBuf[PKCS12_MAX_DIGEST_LEN];
   char BBuf[PKCS12_MAX_DIGEST_BLOCK_LEN];
   //---------------------------------------------------------
   // Check parameters first
   //---------------------------------------------------------
   if(((pPasswd == NULL) && (PasswdLen != 0)) ||
      ((pSalt   == NULL) && (SaltLen != 0)) ||
      (pDstBuf == NULL))
      return(PKCS12_NULL_PTR);
   if(((HashType != PKCS12_HASH_TYPE_MD2) &&
      (HashType != PKCS12_HASH_TYPE_MD5) &&
      (HashType != PKCS12_HASH_TYPE_SHA1)) ||
      (PasswdLen < 0) || (SaltLen < 0) || (IteratCnt < 0) ||
      (DstLen <= 0))
      return(PKCS12_PARAM_ERR);
   //---------------------------------------------------------
   // Setup Parameters for calculation
   //---------------------------------------------------------
   if((HashType == PKCS12_HASH_TYPE_MD2) ||
      (HashType == PKCS12_HASH_TYPE_MD5))
   {
      u = MD5_DIGEST_LEN;				// digestsize in bytes (16)
      v = 64;				// blocksize  in bytes (64)
   }
   else
   {
      u = SHA_DIGEST_LEN;				// digestsize in bytes (20)
      v = 64;				// blocksize  in bytes (64)
   }
   //-------------------------------------------------------------
   // Calculate Required intermediate string lengths and loopcount
   //-------------------------------------------------------------
   DLen    = v;
   SLen    = v * ((SaltLen + v - 1) / v);	// NOTE: Len 0 also included
   PLen    = v * ((PasswdLen + v - 1) / v);	// dto.
   ILen    = SLen + PLen;
   HLen    = ILen + DLen;
   LoopCnt = (DstLen + u - 1) / u;		// number of loops, >= 1
   if(IteratCnt == 0)				// none given
      IteratCnt = 1;				// use Default
   //---------------------------------------------------------
   // Allocate the required buffers
   //---------------------------------------------------------
   if((pDIBuf = BIT8_ARRAY_ALLOC(HMEM_CTX_REF,HLen)) == NULL)
      return(PKCS12_ALLOC_ERR);
   //---------------------------------------------------------
   // Generate String D from KeyID Byte in ID-Buffer
   //---------------------------------------------------------
   SetBit8Array(pDIBuf,0,v,KeyIDByte);		// fill buffer
   Index = v;
   //-----------------------------------------------------------------
   // Append (repeated) Salt string, if Any to D-String
   //-----------------------------------------------------------------
   while(SLen != 0)
   {
      if(SLen <= SaltLen)				// remaining is smaller/same
      {
         memcpy(pDIBuf+Index,pSalt+SaltOff,SLen);
         Index += SLen;
         break;
      }
      memcpy(pDIBuf+Index,pSalt+SaltOff,SaltLen);
      Index += SaltLen;
      SLen  -= SaltLen;
   }
   //-----------------------------------------------------------------
   // Append (repeated) Password string, if Any to D-String
   //-----------------------------------------------------------------
   while(PLen != 0)
   {
      if(PLen <= PasswdLen)			// remaining is smaller/same
      {
         memcpy(pDIBuf+Index,pPasswd+PasswdOff,PLen);
         Index += PLen;
         break;
      }
      memcpy(pDIBuf+Index,pPasswd+PasswdOff,PasswdLen);
      Index += PasswdLen;
      PLen  -= PasswdLen;
   }
   //-----------------------------------------------------------------
   // Generate the Keymaterial bits
   //-----------------------------------------------------------------
   while(LoopCnt != 0)
   {
      //---------------------------------------------------------------
      // Generate the r-th Hash of (D || I), store bytes to destination
      //---------------------------------------------------------------
      GenIteratedHash(pDIBuf,0,HLen, NULL, 0, 0, NULL, 0, 0, NULL, 0, 0,
         HashType, IteratCnt, AiBuf,0);
      if(DstLen <= u)			// all generated so far
      {
         memcpy(pDstBuf+DstOff,AiBuf+0,DstLen);
         break;
      }
      memcpy(pDstBuf+DstOff,AiBuf+0,u);		// copy current
      DstOff += u;					// advance index
      DstLen -= u;
      //---------------------------------------------------------------
      // More bytes required, check if there was an I-String
      // portion in the DI-String present at all
      //---------------------------------------------------------------
      if(ILen != 0)				// there IS an I-String !
      {
         //-------------------------------------------------------------
         // Must modify the I-String, generate the Addition B-String of
         // Size v from concatenation of Repeated String Ai of Size u
         //-------------------------------------------------------------
         Index = 0;
         DLen  = v;
         for(;;)
         {
            if(DLen <= u)				// remaining smaller/same
            {
               memcpy(BBuf+Index,AiBuf+0,DLen);
               break;
            }
            memcpy(BBuf+Index,AiBuf+0,u);	// copy full
            Index += u;
            DLen  -= u;
         }
         //---------------------------------------------------------------
         // Modify the I-String (starts at Offset v in DI String) in
         // portions of size v till end of I-String reached
         // Note: size of I-String is *ALWAYS* a multiple of v !!
         //---------------------------------------------------------------
         Index = v;				// I-String starts at Offset v
         DLen  = ILen;				// size of String
         while(DLen != 0)
         {
            AddNumsNoCyOut(pDIBuf,Index,BBuf,0,v);	// Ij = (Ij + B + 1) mod 2**v
            Index += v;				// advance to next
            DLen  -= v;
         }
      } // I-String Present IF
      LoopCnt--;					// reduce loop count
   }
   ClearBit8Array(pDIBuf,0,HLen);
   ClearBit8Array(AiBuf,0,u);
   ClearBit8Array(BBuf,0,v);
   FREE_CARRAY(HMEM_CTX_REF,pDIBuf);
   return(PKCS12_OP_OK);
}

/**
* Expand a given Seed to required Keymaterial Size using HMAC for given
* key and hash; used for PFX (PFX_ExpandSeedData).
* NOTE: Size of Seed to expand must be <= Digest of Hashfunction to use !
* ----- No parameters checked !
*
*  @param pKeyData Keying Data
*  @param KeyDataOff Start of Data
*  @param KeyDataLen Size of keying data
*  @param pSeed Seed to expand
*  @param SeedOff Start of Data
*  @param SeedLen Size of Data
*  @param pDstBuf Destination for Data
*  @param DstOff Start of data
*  @param ExpandCnt Number of Expansions required
*  @param HashType Type of Hash to apply
*/
static  void  PFX_ExpandSeedData(char* pKeyData, int KeyDataOff,
                                 int KeyDataLen, char* pSeed, int SeedOff, int SeedLen,
                                 char* pDstBuf, int DstOff, int ExpandCnt, int HashType)
{
   int HashLen;

   char KeyBuffer[PKCS12_MAX_DIGEST_BLOCK_LEN];
   char DigestBuf[PKCS12_MAX_DIGEST_LEN];
   int HashArray[PKCS12_MAX_HASH_ARRAY_SIZE];
   //------------------------------------------------------------
   // Copy Seed to Digest buffer (used as Last Hash), zero padded
   // NOTE: This is NOT the normal way expansion should be done !
   // ----- is used for Netscape compatibility
   //------------------------------------------------------------
   if(HashType != PKCS12_HASH_TYPE_SHA1)
      HashLen = MD5_DIGEST_LEN;				// digestsize in bytes (20)
   else
      HashLen = SHA_DIGEST_LEN;				// dto.
   ClearBit8Array(DigestBuf, 0, PKCS12_MAX_DIGEST_LEN);
   memcpy(DigestBuf+0,pSeed+SeedOff,SeedLen);  
   //---------------------------------------------------------
   // Generate the HMAC Hash(es)
   //---------------------------------------------------------
   while(ExpandCnt != 0)
   {
      HMAC_Init(HashArray,KeyBuffer,pKeyData,KeyDataOff,KeyDataLen,HashType);
      HMAC_Update(HashArray,DigestBuf,0,HashLen,HashType);
      HMAC_Update(HashArray,pSeed,SeedOff,SeedLen,HashType);
      HMAC_Final(HashArray,KeyBuffer,pDstBuf,DstOff,HashType);

      DstOff += HashLen;

      HMAC_Init(HashArray,KeyBuffer,pKeyData,KeyDataOff,KeyDataLen,HashType);
      HMAC_Update(HashArray,DigestBuf,0,HashLen,HashType);
      HMAC_Final(HashArray,KeyBuffer,DigestBuf,0,HashType);
      ExpandCnt--;
   }
}

/**
* Generate PFX Key and IV (if Required) from Password (GenPFX_KeyIV). 
* The password is
* either
*  - pure ASCII type password (Private Key Crypt Mode) or
*  - Unicode Zero padded password (Safe Crypt, MAC Gen/Verify Mode).
* If a Privacy Salt is given the Password will be Prepended by the
* Privacy Salt to achieve the so called 'Virtual' password.
*
* Key material generation is done the following way:
* 1. Generate the PKCS5 like iterated SHA-1 Hash from:
*    - PrivacySalt if Given
*    - Password
*    - Salt
*    - NULLS if Password + PrivacySalt + Salt < SHA_DIGEST_LEN
* 2. Expand the Digest if requested KeyLen + IVLen > SHA_DIGEST_LEN
* 3. Use KeyLen bytes from the START of Expanded Hash for the key
* 4. Use IVLen bytes from the END of Expanded Hash for the IV
*
*  @param pPasswd Password (Unicode, NUL terminated!)
*  @param PasswdOff Start of Data
*  @param PasswdLen Size of Password, may be 0 (none)
*  @param pSalt Privacy Salt / NULL
*  @param PrivSaltOff Start of data
*  @param PrivSaltLen Size of PrivacySalt, may be 0 (none)
*               BIT8 pSalt[] Salt data
*  @param SaltOff Start of Data
*  @param SaltLen Size of Salt, may be 0 (none)
*  @param IteratCnt Iteration count for Hash
*  @param pKeyBuf Buffer for Key
*  @param KeyOff Start of Data
*  @param KeyLen Size of Key requested
*  @param pIVBuf Buffer for IV
*  @param IVOff Start of Data
*  @param IVLen Size of IV requested
*  @return int Status - 0 o.k., else error occured
*/
static  int  GenPFX_KeyIV(char* pPasswd, int PasswdOff,
                          int PasswdLen, char* pPrivSalt, int PrivSaltOff, int PrivSaltLen,
                          char* pSalt, int SaltOff, int SaltLen, int IteratCnt,
                          char* pKeyBuf, int KeyOff, int KeyLen,
                          char* pIVBuf, int IVOff, int IVLen)
{
   int BufLen;
   int ExpansionCnt;
   int PadLen = 0;

   char* pSrcBuf;
   char* pKeyIVBuf = NULL;

   char DigestBuf[PKCS12_MAX_DIGEST_LEN];
   //---------------------------------------------------------
   // Check parameters first (may be removed later)
   //---------------------------------------------------------
   if(((pPasswd == NULL) && (PasswdLen != 0)) ||
      ((pPrivSalt == NULL) && (PrivSaltLen != 0)) ||
      ((pSalt == NULL) && (SaltLen != 0)) ||
      ((pKeyBuf == NULL) && (KeyLen != 0)) ||
      ((pIVBuf == NULL) && (IVLen != 0)))
      return(PKCS12_NULL_PTR);
   if((PasswdLen < 0) || (PrivSaltLen < 0) || (SaltLen < 0) ||
      (IteratCnt < 0) || (KeyLen < 0) || (IVLen < 0))
      return(PKCS12_PARAM_ERR);
   //---------------------------------------------------------
   // Allocate needed Buffer for Key and IV generation
   //---------------------------------------------------------
   ExpansionCnt = (KeyLen + IVLen + SHA_DIGEST_LEN-1) / SHA_DIGEST_LEN;
   BufLen = ExpansionCnt * SHA_DIGEST_LEN;
   if((pKeyIVBuf = BIT8_ARRAY_ALLOC(HMEM_CTX_REF,BufLen)) == NULL)
      return(PKCS12_ALLOC_ERR);
   //---------------------------------------------------------
   // Get needed padding length (if any needed)
   //---------------------------------------------------------
   PadLen = SHA_DIGEST_LEN - (PasswdLen + PrivSaltLen + SaltLen);
   if(PadLen > 0)
      ClearBit8Array(DigestBuf,0,PadLen);
   else
      PadLen = 0;
   //---------------------------------------------------------
   // Generate Iterated Hash
   //---------------------------------------------------------
   GenIteratedHash(pPrivSalt,PrivSaltOff,PrivSaltLen,
      pPasswd, PasswdOff, PasswdLen,
      pSalt, SaltOff, SaltLen,
      DigestBuf, 0, PadLen, 
      PKCS12_HASH_TYPE_SHA1, IteratCnt, DigestBuf, 0);
   //---------------------------------------------------------
   // Check if Expansion operation is needed, Expand data
   //---------------------------------------------------------
   pSrcBuf = DigestBuf;
   if(ExpansionCnt > 1)
   {
      PFX_ExpandSeedData(DigestBuf, 0, SHA_DIGEST_LEN,
         pSalt, SaltOff, SaltLen,
         pKeyIVBuf, 0, ExpansionCnt,
         PKCS12_HASH_TYPE_SHA1);
      pSrcBuf = pKeyIVBuf;
   }
   if((pKeyBuf != NULL) && (KeyLen > 0))
      memcpy(pKeyBuf+KeyOff,pSrcBuf+0,KeyLen);
   if((pIVBuf != NULL) && (IVLen > 0))
      memcpy(pIVBuf+IVOff,pSrcBuf+BufLen-IVLen,IVLen);

   ClearBit8Array(pKeyIVBuf,0,BufLen);
   ClearBit8Array(DigestBuf,0,PKCS12_MAX_DIGEST_LEN);
   FREE_ARRAY(HMEM_CTX_REF,pKeyIVBuf);
   return(PKCS12_OP_OK);
}

//()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()
//
// Encryption / Decryption functions
//
//()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()

/**
* Encrypt/Decrypt a PFX / PKCS12 object using the appropriate PKCS12-PBE Mode
* from  PFX / PKCS12 (see PFX/PKCS-12 Spec) (PKCS12Crypt).
* NOTE: In Encrypt Mode the Destination buffer must be large enough
* ----- for the padding data to append !!
*
*  @param pPasswd Password
*  @param PasswdOff Start of Data
*  @param PasswdLen Size of Password, may be 0 (none)
*  @param pSalt Privacy Salt data/NULL (PFX only)
*  @param PrivSaltOff Start of Data
*  @param PrivSaltLen Size of PrivacySalt, may be 0 (none)
*               BIT8 pSalt[] Salt data
*  @param SaltOff Start of Data
*  @param SaltLen Size of Salt, may be 0 (none)
*  @param IteratCnt Iteration count for Hash
*  @param PBEType Type of CryptAlgor/Hash to use, rel 1!
*  @param Mode Either PKCS12_ENCRYPT or PKCS12_DECRYPT
*  @param CryptType 0 - PKCS12, else PFX-Mode
*  @param pSrcBuf Encrypted Data buffer
*  @param SrcOff Start of Data
*  @param SrcLen Length of Data
*  @param pDstBuf Decrypted Data buffer
*  @param DstOff Start of Data
*  @param pDstLen IN: Buffer size, OUT: Data Size
*  @return int Status - 0 o.k., else error occured
*/
static  int  PKCS12Crypt(char* pPasswd, int PasswdOff,
                         int PasswdLen, char* pPrivSalt, int PrivSaltOff, int PrivSaltLen,
                         char* pSalt, int SaltOff, int SaltLen,
                         int IteratCnt, int PBEType, int Mode, int CryptType,
                         char* pSrcBuf, int SrcOff, int SrcLen,
                         char* pDstBuf, int DstOff, int* pDstLen)
{

   int Retcode = PKCS12_PARAM_ERR;
   int DstBufSize,i,j;
   int DstDataLen = 0;
   int PadLen = 0;
   int CryptMode;
   int HashType,CryptFamily,CryptSubtype,CryptBlkSize,CryptKeySize,CryptIVSize;
   int CryptBlkCount = 0;
   int AlgDescIndexBase;

   char KeyBuffer[PKCS12_MAX_KEY_LEN];
   char IVBuffer[PKCS12_MAX_IV_LEN];

   char Rc4Array[RC4_STATE_SIZE];
   short Rc2Array[RC2_MAX_KEY_WORDS];
   int DesSubkey1Array[DES_SUBKEY_ARRAY_SIZE];
   int DesSubkey2Array[DES_SUBKEY_ARRAY_SIZE];
   int DesSubkey3Array[DES_SUBKEY_ARRAY_SIZE];
   int AesKeyArray[AES_KEY_ARRAY_SIZE_BIT32];

   //---------------------------------------------------------
   // Check Parameters that have to be checked ahead
   //---------------------------------------------------------
   if((pSrcBuf == NULL) || (pDstBuf == NULL) || (pDstLen == NULL))
      return(PKCS12_NULL_PTR);
   if(((SrcLen <= 0) || ((DstBufSize = pDstLen[0]) < SrcLen)) ||
      (PBEType < PKCS12_PBE_SHA_RC4_128) ||
      (PBEType > PKCS12_PBE_SHA_RC2_CBC_40) ||
      ((Mode != PKCS12_ENCRYPT) && (Mode != PKCS12_DECRYPT)))
      return(PKCS12_PARAM_ERR);
   //-------------------------------------------------------------------
   // Setup Encryption/Decryption Parameters according to given PBE Type
   //-------------------------------------------------------------------
   AlgDescIndexBase = PBE_ALG_DESC_MAX_SIZE * (PBEType-1); // get Base Arr.Index
   HashType     = PbeAlgDescArr[AlgDescIndexBase+PBE_HASH_ALG_TYPE_IND];
   CryptFamily  = PbeAlgDescArr[AlgDescIndexBase+PBE_CIPHER_ALG_FAMILY_IND];
   CryptSubtype = PbeAlgDescArr[AlgDescIndexBase+PBE_CIPHER_ALG_SUBTYPE_IND];
   CryptBlkSize = PbeAlgDescArr[AlgDescIndexBase+PBE_CIPHER_ALG_BLKSIZE_IND];
   CryptKeySize = PbeAlgDescArr[AlgDescIndexBase+PBE_CIPHER_ALG_KEYSIZE_IND];
   CryptIVSize  = PbeAlgDescArr[AlgDescIndexBase+PBE_CIPHER_ALG_IVSIZE_IND];
   //-----------------------------------------------------------------
   // Check if Input Size is multiple of Block count (for Block Algor)
   //-----------------------------------------------------------------
   PadLen = 0;			// assume no padding needed (Stream)
   if(CryptBlkSize != 0)
   {
      //---------------------------------------------------------------
      // A Blockcipher is used, check valid Input/Output length
      //---------------------------------------------------------------
      if(Mode == PKCS12_ENCRYPT)		// Encryption Mode
      {
         //-------------------------------------------------------------
         // Encrypt mode, must append at least 1 byte padding
         //-------------------------------------------------------------
         PadLen = CryptBlkSize -
            (SrcLen % CryptBlkSize);// additional padding size needed
         //     if(PadLen == 0)			// use a Full block instead !
         //       PadLen += CryptBlkSize;
         if(DstBufSize < (SrcLen + PadLen))
            return(PKCS12_ENCR_INV_DSTLEN);
         DstDataLen = SrcLen + PadLen;
         CryptBlkCount = DstDataLen / CryptBlkSize;
      }
      else				// Decryption mode
      {
         if((SrcLen % CryptBlkSize) != 0)
            return(PKCS12_DECR_INV_SRCLEN);
         CryptBlkCount = SrcLen / CryptBlkSize;
         DstDataLen = SrcLen;
      }
   }
   //---------------------------------------------------------
   // Fetch the Encryption/Decryption Key/IV Data
   //---------------------------------------------------------
   if(CryptType == 0)			// PKCS12 Mode
   {
      //---------------------------------------------------------
      // Fetch the Encrypt/Decrypt Key
      //---------------------------------------------------------
      if((Retcode = GenPKCS12KeyData(pPasswd, PasswdOff, PasswdLen,
         pSalt, SaltOff, SaltLen, IteratCnt, HashType,
         PKCS12_KEYDATA_TYPE_ID_KEY,
         KeyBuffer, 0, CryptKeySize)) != PKCS12_OP_OK)
         return(Retcode);
      //---------------------------------------------------------
      // Fetch the Encrypt/Decrypt IV if needed
      //---------------------------------------------------------
      if(CryptIVSize != 0)
      {
         if((Retcode = GenPKCS12KeyData(pPasswd, PasswdOff, PasswdLen,
            pSalt, SaltOff, SaltLen, IteratCnt, HashType,
            PKCS12_KEYDATA_TYPE_ID_IV,
            IVBuffer, 0, CryptIVSize)) != PKCS12_OP_OK)
            return(Retcode);
      }
   }
   else					// PFX-Mode
   {
      if((Retcode = GenPFX_KeyIV(pPasswd, PasswdOff, PasswdLen,
         pPrivSalt, PrivSaltOff, PrivSaltLen,
         pSalt,SaltOff,SaltLen, IteratCnt,
         KeyBuffer,0,CryptKeySize,
         IVBuffer,0,CryptIVSize)) != PKCS12_OP_OK)
         return(Retcode);
   }
   //--------------------------------------------------------------
   // Append Padding Data if Blockcipher and Mode == Encrypt
   // NOTE: Standard Padding is used: if SrcLen % Blocksize == 0
   // ----- append a full block of padding
   //--------------------------------------------------------------
   if((Mode == PKCS12_ENCRYPT) && (PadLen != 0))
   {
      memcpy(pDstBuf+DstOff,pSrcBuf+SrcOff,SrcLen); // copy originaldata
      SetBit8Array(pDstBuf,DstOff+SrcLen,PadLen,PadLen);	// append padding
      pSrcBuf = pDstBuf;				// use Destination in place
      SrcOff  = DstOff;				// dto.
   }
   //---------------------------------------------------------
   // Generate the Key Arrays needed for Decryption by Family
   // and Encrypt/Decrypt the Data
   //---------------------------------------------------------
   switch(CryptFamily)
   {
      //-------------------------------------------------------
      // RC4 Family
      //-------------------------------------------------------
   case PKCS12_CIPHER_ALG_FAMILY_RC4:
      RC4_SetKey(Rc4Array,KeyBuffer,0,CryptKeySize);
      RC4(pSrcBuf,SrcOff,SrcLen,pDstBuf,DstOff,Rc4Array);
      pDstLen[0] = SrcLen;
      ClearBit8Array(KeyBuffer,0,CryptKeySize);
      ClearBit8Array(Rc4Array,0,RC4_STATE_SIZE);
      pDstLen[0] = SrcLen;			// same size
      return(PKCS12_OP_OK);
      //-------------------------------------------------------
      // RC2 Family
      //-------------------------------------------------------
   case PKCS12_CIPHER_ALG_FAMILY_RC2:
      RC2_SetKey(Rc2Array,KeyBuffer,CryptKeySize,CryptKeySize*8);
      if(Mode == PKCS12_ENCRYPT)
         CryptMode = RC2_ENCRYPT;
      else
         CryptMode = RC2_DECRYPT;

      RC2_cbc_encdecrypt(pSrcBuf,SrcOff,pDstBuf,DstOff,DstBufSize,Rc2Array,IVBuffer,CryptMode);
      ClearBit8Array(KeyBuffer,0,CryptKeySize);
      ClearBit16Array(Rc2Array,0,RC2_MAX_KEY_WORDS);
      break;				// must strip padding for decrypt
      //-------------------------------------------------------
      // DES Family (only 3DES-CBC supported, 2 or 3 Keys)
      //-------------------------------------------------------
   case PKCS12_CIPHER_ALG_FAMILY_DES:
      if(CryptSubtype == PKCS12_CIPHER_3DES_2KEYS_ALG)
      {
         GenDESSubKeys((unsigned char*)KeyBuffer+0,(unsigned int*)DesSubkey1Array);
         GenDESSubKeys((unsigned char*)KeyBuffer+8,(unsigned int*)DesSubkey2Array);
         GenDESSubKeys((unsigned char*)KeyBuffer+0,(unsigned int*)DesSubkey3Array);
      }
      else // 3 Key Mode
      {
         GenDESSubKeys((unsigned char*)KeyBuffer+0,(unsigned int*)DesSubkey1Array);
         GenDESSubKeys((unsigned char*)KeyBuffer+8,(unsigned int*)DesSubkey2Array);
         GenDESSubKeys((unsigned char*)KeyBuffer+16,(unsigned int*)DesSubkey3Array);
      }
      if(Mode == PKCS12_ENCRYPT)
         CryptMode = DES_ENCRYPT;
      else
         CryptMode = DES_DECRYPT;

      DES3_ede_cbc_encrypt_decrypt((unsigned char*)pSrcBuf+SrcOff, 
         (unsigned char*)pDstBuf+DstOff,
         (unsigned int*)DesSubkey1Array,
         (unsigned int*)DesSubkey2Array,
         (unsigned int*)DesSubkey3Array,
         CryptBlkCount,(unsigned char*)IVBuffer,CryptMode);
      ClearBit8Array(KeyBuffer,0,CryptKeySize);
      ClearBit32Array(DesSubkey1Array,0,DES_SUBKEY_ARRAY_SIZE);
      ClearBit32Array(DesSubkey2Array,0,DES_SUBKEY_ARRAY_SIZE);
      ClearBit32Array(DesSubkey3Array,0,DES_SUBKEY_ARRAY_SIZE);
      break;				// must strip padding for decrypt
      //-------------------------------------------------------
      // AES Family
      // NOTE: Decrypt key array different from encrypt !!!
      //-------------------------------------------------------
   case PKCS12_CIPHER_ALG_FAMILY_AES:
      if(Mode == PKCS12_ENCRYPT)
      {
         CryptMode = AES_ENCRYPT;
         m_aes_set_encrypt_key((unsigned char *) KeyBuffer,
            CryptKeySize,
            (ds_aes_key *) AesKeyArray);
         m_aes_cbc_encrypt((unsigned char *) (pSrcBuf+SrcOff),
            (unsigned char *) (pDstBuf+DstOff),
            (ds_aes_key *) AesKeyArray,
            CryptBlkCount,
            (unsigned char *) IVBuffer,
            CryptKeySize/4 + 6);
      }
      else
      {
         CryptMode = AES_DECRYPT;
         m_aes_set_decrypt_key((unsigned char *) KeyBuffer,
            CryptKeySize,
            (ds_aes_key *) AesKeyArray);
         m_aes_cbc_decrypt((unsigned char *) (pSrcBuf+SrcOff),
            (unsigned char *) (pDstBuf+DstOff),
            (ds_aes_key *) AesKeyArray,
            CryptBlkCount,
            (unsigned char *) IVBuffer,
            CryptKeySize/4 + 6);
      }
      ClearBit8Array(KeyBuffer,0,CryptKeySize);
      ClearBit32Array(AesKeyArray,0,AES_KEY_ARRAY_SIZE_BIT32);
      break;				// must strip padding for decrypt
   }
   //--------------------------------------------------------------
   // Check, Strip Padding Data from Decrypted data if Mode Decrypt
   //--------------------------------------------------------------
   if(Mode == PKCS12_DECRYPT)
   {
      //-------------------------------------------------------
      // get padding value, check correct padding size
      //-------------------------------------------------------
      j = DstOff + DstDataLen -1;			// to last byte
      PadLen = (int) pDstBuf[j--] & 0xFF;		// get padding count
      if((PadLen <= 0) ||				// invalid anyway
         (PadLen > CryptBlkSize))			// dto.
         return(PKCS12_DECRYPT_INVALID_PADDING);	// invalid error
      DstDataLen -= PadLen;			// get new length
      if(DstDataLen <= 0)				// check if valid
         return(PKCS12_DECRYPT_INVALID_PADDING);	// too few data remaining
      //-------------------------------------------------------
      // check correct padding data
      //-------------------------------------------------------
      i = PadLen-1;
      while(i != 0)
      {
         if(pDstBuf[j--] != (char) PadLen)		// invalid padding
            return(PKCS12_DECRYPT_INVALID_PADDING);
         i--;
      }
      //-------------------------------------------------
      // update actual output length to new one
      //-------------------------------------------------
   }
   pDstLen[0] = DstDataLen;
   return(Retcode);
}

/**
* Generate HMAC using MD5 or SHA-1 hash from given data and key for PKCS12.
*
* @note Different from GenHMAC!
*
*  @param pKeyData Base of data
*  @param KeyDataOff Start of data
*  @param KeyDataLen Size of key
*  @param pHashData base of data to hash
*  @param HashDataOff Start of Data
*  @param HashDataLen Size of data to hash
*  @param HashType Hash to Use
*  @param pDstBuf Buffer for Output
*  @param DstOff Start of Data
*  @param pDstLen IN: Buffersize, OUT: Hashsize
*  @return int Status - 0 o.k., else error occured
*/
static  int  m_hmac_pkcs12(char* pKeyData, 
                           int KeyDataOff, 
                           int KeyDataLen, 
                           char* pHashData,
                           int HashDataOff, 
                           int HashDataLen,
                           int HashType, 
                           char* pDstBuf, 
                           int DstOff,
                           int* pDstLen)
{
    int DstBufLen;
    int HashLen;
    //  int KeyLen;

    char KeyBuffer[PKCS12_MAX_DIGEST_BLOCK_LEN];
    //  BIT8ARRAY(DigestBuffer,PKCS12_MAX_DIGEST_LEN);
    int HashArray[PKCS12_MAX_HASH_ARRAY_SIZE];

    //-------------------------------------------------------
    // Check parameters
    //-------------------------------------------------------
    if((pKeyData == NULL) || (pHashData == NULL) ||
        (pDstBuf == NULL) || (pDstLen == NULL))
        return(PKCS12_NULL_PTR);

    if((KeyDataLen <= 0) || (HashDataLen <= 0) ||
        ((DstBufLen = pDstLen[0]) <= 0) ||
        ((HashType != PKCS12_HASH_TYPE_MD5) &&
        (HashType != PKCS12_HASH_TYPE_SHA1)))
        return(PKCS12_PARAM_ERR);

    if(HashType == PKCS12_HASH_TYPE_MD2)
        HashLen = MD2_DIGEST_LEN;
    else if(HashType == PKCS12_HASH_TYPE_MD5)
        HashLen = MD5_DIGEST_LEN;
    else
        HashLen = SHA_DIGEST_LEN;

    if(DstBufLen < HashLen)
        return(PKCS12_HMAC_DST_BUF_TOO_SMALL);

    //------------------------------------------------------------
    // generate the full HMAC Hash
    //------------------------------------------------------------
    HMAC_Init(HashArray, KeyBuffer, pKeyData, KeyDataOff, KeyDataLen, HashType);
    HMAC_Update(HashArray, pHashData, HashDataOff, HashDataLen, HashType);
    HMAC_Final(HashArray, KeyBuffer, pDstBuf, DstOff, HashType);

    pDstLen[0] = HashLen;
    return(PKCS12_OP_OK);
}

/**
* Generate/Verify PKCS12 HMAC-SHA1 Hash (PKCS12GenVfyHMAC_SHA1).
*
*  @param pPasswd Password (Unicode, NUL terminated!)
*  @param PasswdOff Start of Data
*  @param PasswdLen Size of Password, may be 0 (none)
*  @param pSalt Salt data
*  @param SaltOff Start of Data
*  @param SaltLen Size of Salt, may be 0 (none)
*  @param IteratCnt Iteration count for Hash
*  @param HashType Type of Hash to use
*  @param Mode PKCS12_HMAC_GEN or PKCS12_HMAC_VFY
*  @param Type == 0 PKCS12 else PFX
*  @param pHashData Data to Hash
*  @param HashDataOff Start of Data
*  @param HashDataLen Size of Data
*  @param pDstBuf GEN: Hash generated,VFY: Hash to Check
*  @param DstOff Start of Data
*  @param DstLen GEN: Buffer size, VFY: Data Size
*  @return int Status - 0 o.k., else error occured
*/
static  int  PKCS12GenVfyHMAC_SHA1(char* pPasswd, int PasswdOff,
                                   int PasswdLen, char* pSalt, int SaltOff, int SaltLen,
                                   int IteratCnt, int HashType, int Mode, int Type,
                                   char* pHashData, int HashDataOff, int HashDataLen,
                                   char* pDstBuf, int DstOff, int DstLen)
{

   int Retcode;
   int HashLen,KeyLen;

   char KeyBuffer[PKCS12_MAX_KEY_LEN];
   char DigestBuffer[PKCS12_MAX_DIGEST_LEN];
   int pTmpLen[1];
   //---------------------------------------------------------
   // Get the HashLength
   //---------------------------------------------------------
   if(HashType == PKCS12_HASH_TYPE_MD2)
      HashLen= MD2_DIGEST_LEN;
   else if(HashType == PKCS12_HASH_TYPE_MD5)
      HashLen= MD5_DIGEST_LEN;
   else if(HashType == PKCS12_HASH_TYPE_SHA1)
      HashLen= SHA_DIGEST_LEN;
   else
      return(PKCS12_PARAM_ERR);

   //---------------------------------------------------------
   // Check Parameters that have to be checked ahead
   //---------------------------------------------------------
   if((pHashData == NULL) || (pDstBuf == NULL))
      return(PKCS12_NULL_PTR);
   if((HashDataLen <= 0) ||
      ((DstLen < HashLen) && (Type == 0)) ||
      ((DstLen != HashLen) && (Type != 0)) ||
      ((Mode == PKCS12_HMAC_GEN) && (DstLen < HashLen)) ||
      ((Mode != PKCS12_HMAC_GEN) && (Mode != PKCS12_HMAC_VFY)))
      return(PKCS12_PARAM_ERR);

   if((Mode == PKCS12_HMAC_VFY) && (DstLen != HashLen))
      return(PKCS12_HMAC_VFY_INVALID_MACLEN);
   //---------------------------------------------------------
   // Fetch the HMAC Key Data
   //---------------------------------------------------------
   if(Type == 0)
   {
      if((Retcode = GenPKCS12KeyData(pPasswd, PasswdOff, PasswdLen,
         pSalt, SaltOff, SaltLen, IteratCnt,
         HashType, PKCS12_KEYDATA_TYPE_ID_HMAC,
         KeyBuffer, 0, HashLen)) != PKCS12_OP_OK)
         return(Retcode);

      KeyLen = HashLen;
   }
   else
   {
      // NOTE: 1. Password and Salt are used in reversed order here !!
      // ----- 2. Key is taken from IV position !!!
      if((Retcode = GenPFX_KeyIV(pSalt,SaltOff,SaltLen,
         pSalt,SaltOff,SaltLen,
         pPasswd,PasswdOff, PasswdLen, 1,
         NULL, 0, 0,
         KeyBuffer,0, PFX_MAC_LEN)) != PKCS12_OP_OK)
         return(Retcode);

      KeyLen = PFX_MAC_LEN;
   }			
   //---------------------------------------------------------
   // Generate the HMAC from the Data to Hash
   //---------------------------------------------------------
   pTmpLen[0] = SHA_DIGEST_LEN;
   Retcode = m_hmac_pkcs12(KeyBuffer, 0, KeyLen,
      pHashData, HashDataOff, HashDataLen,
      HashType,
      DigestBuffer, 0, pTmpLen);
   if(Retcode != PKCS12_OP_OK)
      return(PKCS12_HMAC_GEN_FAILED);
   //---------------------------------------------------------
   // Check mode to process
   //---------------------------------------------------------
   if(Mode == PKCS12_HMAC_GEN)
   {
      memcpy(pDstBuf+DstOff,DigestBuffer+0,HashLen);
      ClearBit8Array(DigestBuffer,0,PKCS12_MAX_DIGEST_LEN);
      ClearBit8Array(KeyBuffer,0,PKCS12_MAX_KEY_LEN);
      return(PKCS12_OP_OK);
   }
   if(CmpBit8Arrays(DigestBuffer,0,pDstBuf,DstOff,HashLen) != ASN1_SAME)
      return(PKCS12_HMAC_VFY_FAILED);
   return(PKCS12_OP_OK);
}

//()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()
//
// PKCS12 / PFX Struture processing
//
//()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()

/**
* Process a PKCS12 ContentInfo from the AuthenticatedSafe and
* split it into the contained safebags (PKCS12_FromContentInfo). 
* If the content is
* encrypted, decrypt it using the parameters from the header and
* the password
*
*  @param pContTypeOID OID of Content Info
*               IDATA_PTR pContValue Value of content info
*  @param pPwd Password in Unicode
*  @param PwdOff Start of data
*               int Pwdlen Size of password
*               IDATPARR_PTR pDatarrayDesc[] loaded Array Descriptor
*  @param pBagsCnt Number of Bags split
*  @param pDecryptBufBase Buffer allocated for decryption
*  @param pDecryptBufLen Size of buffer
*  @return int Status - 0 o.k., else error occured
*/
static  int  PKCS12_FromContentInfo(IDATA* pContTypeOID,
                                    IDATA* pContTypeValue,
                                    char* pPwd, int PwdOff, int PwdLen,
                                    IDATPARR** pDatArrayDesc, int* pBagsCnt,
                                    char** pDecryptBufBase, int* pDecryptBufLen)
{
   int Retcode;
   int ContentTypeID;
   int EncAlgorID;
   int EncDataLen = 0;
   int IteratCnt;
   int PlainTextLen;

   int pTmpVal[1];
   int pTmpRet[1];
   int pTmpLong[1];

   char* pPlainTextBuf = NULL;

   IDATA* pIdata;
   IDATA* pSaltIdata;
   IDATA** ppArr;

   IDATPARR* pDataDesc = NULL;
   IDATPARR* pEncDataDesc = NULL;
   IDATPARR* pPbeParamsDesc = NULL;
   IDATPARR* pUnwrappedEncDataDesc = NULL;

   IDATPARR* ppTmpDesc[1];

   pDecryptBufBase[0] = NULL;
   //------------------------------------------------------------
   // get the type of the Content from the OID
   //------------------------------------------------------------
   if((Retcode =  GetPKCS7_ContTypeID(pContTypeOID->Base,
      (int) pContTypeOID->Off,
      pContTypeOID->Len,
      pTmpVal)) != PKCS12_OP_OK)
      return(Retcode);
   ContentTypeID = pTmpVal[0];
   //------------------------------------------------------------
   // Distribute by content type:
   //------------------------------------------------------------
   switch(ContentTypeID)
   {
      //----------------------------------------------------------
      // Plaintext Content Type
      //----------------------------------------------------------
   case PKCS7_CONTENT_DATA_SUBID:
      //--------------------------------------------------------
      // Unwrap data from OCTET STRING first
      //--------------------------------------------------------
      if((Retcode = FromASN1_BER_OCTETSTR(
         pContTypeValue->Base,
         (int) pContTypeValue->Off,
         pContTypeValue->Len,
         ppTmpDesc, pTmpRet)) != ASN1_OP_OK)
         return(Retcode);
      pDataDesc = ppTmpDesc[0];
      //--------------------------------------------------------------
      // Decode Contents to 'SafeBags'
      //--------------------------------------------------------------
      pIdata = pDataDesc->ppArr[0];
      if((Retcode = FromASN1_PKCS12SafeContents(
         pIdata->Base,
         (int) pIdata->Off,
         pIdata->Len,
         pDatArrayDesc, pBagsCnt, pTmpRet)) != PKCS12_OP_OK)
      {
         FreeIDATPARR_Struc(HMEM_CTX_REF1 pDataDesc);
         return(Retcode);
      }
      pBagsCnt[0] = pBagsCnt[0] / PKCS12_SAFEBAG_MAX_DATA_INDEX;
      //--------------------------------------------------------------
      // Check if a COPY must be made from the Descriptor
      //--------------------------------------------------------------
      if((pDataDesc->Flags & FREE_BIT_MASK) != 0)
         Retcode = CopyToLocalDatArrayDesc(HMEM_CTX_REF1 pDatArrayDesc[0]);
      FreeIDATPARR_Struc(HMEM_CTX_REF1 pDataDesc);
      return(Retcode);
      //----------------------------------------------------------
      // EncryptedData Content Type
      //----------------------------------------------------------
   case PKCS7_CONTENT_ENCDATA_SUBID:
      for(;;)					// Error Processing FOR
      {
         //--------------------------------------------------------
         // Split the EncryptedData Value
         //--------------------------------------------------------
         if((Retcode = FromASN1_PKCS7_EncDataContent(
            pContTypeValue->Base,
            (int) pContTypeValue->Off,
            pContTypeValue->Len,
            ppTmpDesc, pTmpRet)) != ASN1_OP_OK)
            return(Retcode);
         pEncDataDesc = ppTmpDesc[0];
         //--------------------------------------------------------
         // Get the Encryption Algorithm, check if recognized
         //--------------------------------------------------------
         ppArr = pEncDataDesc->ppArr;
         pIdata = ppArr[PKCS7_ENCDATA_ENCALG_ID_INDEX];
         if((Retcode = GetPKCS12_PBEAlgorID(pIdata->Base,
            (int) pIdata->Off,
            pIdata->Len,0,
            pTmpVal)) != PKCS12_OP_OK)
            break;
         EncAlgorID = pTmpVal[0];
         //--------------------------------------------------------------
         // Decode the PBE Algorithm Parameters
         //--------------------------------------------------------------
         pIdata = ppArr[PKCS7_ENCDATA_ENCALG_PAR_INDEX];
         if((Retcode = FromASN1_PKCS12PbeParams(
            pIdata->Base,
            (int) pIdata->Off,
            pIdata->Len,
            ppTmpDesc, pTmpRet)) != ASN1_OP_OK)
            break;
         pPbeParamsDesc = ppTmpDesc[0];
         //-------------------------------------------------
         // Decode the Iteration count from the Params
         //-------------------------------------------------
         pIdata =
            pPbeParamsDesc->ppArr[PKCS12_PBE_PARAMS_ITERAT_INDEX];

         if((Retcode = ByteBufToUnsignedBIT32Num(pIdata->Base,(int) pIdata->Off,pIdata->Len,pTmpLong)) != ASN1_OP_OK)
            break;  
         IteratCnt = (int) pTmpLong[0];
         //-------------------------------------------------------
         // Check if the Encrypted Data are constructed (Netscape)
         // if so unwrap first !
         //-------------------------------------------------------
         pIdata =  ppArr[PKCS7_ENCDATA_ENCDATA_INDEX];
         if((pIdata->Base == NULL) || (pIdata->Len <= 0))
         {
            //---------------------------------------------------------
            // Data seem to be a constructed (Inplizit tagged) OCTETSTR
            //---------------------------------------------------------
            pIdata =  ppArr[PKCS7_ENCDATA_ENCDATA_CON_INDEX];
            if((pIdata->Base == NULL) || (pIdata->Len <= 0))
            {
               Retcode = PKCS12_NO_SAFECONTENT_DATA;
               break;
            }
            if((Retcode = UnwrapASN1_BER_OCTETSTR(
               pIdata->Base,
               (int) pIdata->Off,
               pIdata->Len,
               ppTmpDesc, pTmpRet)) != PKCS12_OP_OK)
               break;
            pUnwrappedEncDataDesc = ppTmpDesc[0];
            pIdata = pUnwrappedEncDataDesc->ppArr[0];
         }
         //-------------------------------------------------------
         // Setup Salt, get required sizei form encrypted Data,
         // allocate buffer for decrypt
         //-------------------------------------------------------
         pSaltIdata =
            pPbeParamsDesc->ppArr[PKCS12_PBE_PARAMS_SALT_INDEX];
         pTmpRet[0] = pIdata->Len;
         EncDataLen = pTmpRet[0];

         if((pPlainTextBuf = BIT8_ARRAY_ALLOC(HMEM_CTX_REF,
            pTmpRet[0])) == NULL)
         {
            Retcode = PKCS12_ALLOC_ERR;
            break;
         }
         //-------------------------------------------------------
         // Decrypt the data now
         //-------------------------------------------------------
         if((Retcode = PKCS12Crypt(pPwd, PwdOff, PwdLen,	NULL, 0, 0,
            pSaltIdata->Base, (int) pSaltIdata->Off,
            pSaltIdata->Len, IteratCnt,
            EncAlgorID,PKCS12_DECRYPT,0,
            pIdata->Base, (int) pIdata->Off,
            pIdata->Len,
            pPlainTextBuf,0,pTmpRet)) != PKCS12_OP_OK)
            break;
         PlainTextLen = pTmpRet[0];
         //--------------------------------------------------------------
         // Decode Decrypted Contents to SafeBags
         //--------------------------------------------------------------
         if((Retcode = FromASN1_PKCS12SafeContents(
            pPlainTextBuf,0,PlainTextLen,
            pDatArrayDesc, pBagsCnt, pTmpRet)) != ASN1_OP_OK)
            break;
         pBagsCnt[0] = pBagsCnt[0] / PKCS12_SAFEBAG_MAX_DATA_INDEX;
         break;
      } // Error FOR
      break;

      //----------------------------------------------------------
      // Unsupported SafeContent types
      //----------------------------------------------------------
   case PKCS7_CONTENT_SIGDATA_SUBID:
   case PKCS7_CONTENT_ENVDATA_SUBID:
   case PKCS7_CONTENT_SIGENVDATA_SUBID:
   case PKCS7_CONTENT_DIGDATA_SUBID:
   default:
      return(PKCS12_UNSUPP_SAFECONTENT_TYPE);
   }
   //-------------------------------------------------------------
   // Free temporary Elements
   //-------------------------------------------------------------
   FreeIDATPARR_Struc(HMEM_CTX_REF1 pUnwrappedEncDataDesc);
   FreeIDATPARR_Struc(HMEM_CTX_REF1 pEncDataDesc);
   FreeIDATPARR_Struc(HMEM_CTX_REF1 pPbeParamsDesc);
   if(Retcode != PKCS12_OP_OK)
      FREE_ARRAY(HMEM_CTX_REF,pPlainTextBuf);

   if(pDecryptBufBase != NULL)
      pDecryptBufBase[0] = pPlainTextBuf;
   if(pDecryptBufLen != NULL)
      pDecryptBufLen[0] = EncDataLen;

   return(Retcode);
}

/**
* Clear and Free a IDATPARR Descriptor if buffers were allocated
* direct (ClearFreeIDATPARR_Struc).
*
*  @param pDesc Descriptor
*/
static  void  ClearFreeIDATPARR_Struc(IDATPARR* pDesc)
{
   int Count;
   IDATA** ppArr;
   IDATA* pIdata;

   if(pDesc == NULL)
      return;

   ppArr = pDesc->ppArr;
   Count = pDesc->Cnt;

   if(((pDesc->Flags & FREE_BIT_MASK) != 0) &&
      (ppArr != NULL) && (Count > 0))
   {
      //---------------------------------------------------
      // local allocated buffers, clear them and free them
      //---------------------------------------------------
      while(Count != 0)
      {
         Count--;
         pIdata = ppArr[Count];
         ClearBit8Array(pIdata->Base,(int) pIdata->Off,
            pIdata->Len);
         FREE_ARRAY(HMEM_CTX_REF,pIdata->Base);
         pIdata->Len = 0;
      }
   }
   FREE_ARRAY(HMEM_CTX_REF,ppArr);
   pDesc->ppArr = NULL;
   pDesc->Cnt = 0;
   FREE_ARRAY(HMEM_CTX_REF,pDesc);
}

/**
* Frees a PKCS12 bag structure and its elements (FreePKCS12BagStruc).
*
*  @param pBagStruc Pointer to the bag structure.
*/
extern "C"  void  FreePKCS12BagStruc(P12BAG * pBagStruc)
{

   if(pBagStruc == NULL)
      return;
   //------------------------------------------------
   // Free the attribute buffers if used
   //------------------------------------------------
   FREE_ARRAY(HMEM_CTX_REF,pBagStruc->pFriendlyName);
   FREE_ARRAY(HMEM_CTX_REF,pBagStruc->pLocalKeyID);
   //------------------------------------------------
   // Free the Private key Structures, clear them (!)
   //------------------------------------------------
   if(pBagStruc->pPrivKeyDesc != NULL)
   {
      ClearFreeIDATPARR_Struc(pBagStruc->pPrivKeyDesc);
      pBagStruc->pPrivKeyDesc = NULL;
   }
   FREE_ARRAY(HMEM_CTX_REF,pBagStruc);
}

/**
* Alloctes a PKCS12 Bag structure and initializes it (AllocPKCS12BagStruc).
*
*  @return A pointer to the new structure / NULL on error
*/
static  P12BAG *  AllocPKCS12BagStruc()
{
   P12BAG * pBagStruc;

   pBagStruc = (P12BAG*)calloc(1, sizeof(P12BAG));
   if(pBagStruc != NULL)
   {
      pBagStruc->DigestAlgor = PKCS12_SIGNAT_ALGOR_INVALID;
      pBagStruc->AssocPrivKeyBagIndex = -1;
   }
   return(pBagStruc);
}

/**
* Frees an array of PKCS12 bag structures (FreePKCS12BagStrucArr).
*
*  @param pBagStrucArr Pointer to the array of structures
*  @param Count Number of structures in array
*/
extern "C"  void  FreePKCS12BagStrucArr(P12BAG ** pBagStrucArr,
                                        int Count)
{
   if(pBagStrucArr == NULL)
      return;
   while(Count != 0)
   {
      Count--;				// use as Index
      FreePKCS12BagStruc(pBagStrucArr[Count]);
      pBagStrucArr[Count] = NULL;
   }
   FREE_ARRAY(HMEM_CTX_REF,pBagStrucArr);
   pBagStrucArr = NULL;
}

/**
* Allocte an array of PKCS12 Bag structures, initialize them (AllocInitPKCS12BagStrucArr).
*
*  @param Count Number of structures requested
*  @return PK12BAG_PPTR pStructArr
*/
static  P12BAG **  AllocInitPKCS12BagStrucArr(int Count)
{
   int Index = 0;
   P12BAG * pBagStruc;
   P12BAG ** pBagStrucArr;

   pBagStrucArr = (P12BAG**)calloc(1, sizeof(P12BAG *) * Count);
   if(pBagStrucArr == NULL)
      return(NULL);

   while(Index < Count)
   {
      if((pBagStruc = AllocPKCS12BagStruc()) == NULL)
         break;
      pBagStrucArr[Index++] = pBagStruc;
   }
   if(Index != Count)
   {
      FreePKCS12BagStrucArr(pBagStrucArr, Count);
      return(NULL);
   }
   return(pBagStrucArr);
}

/**
* Process a (presplit) PKCS12 Safebag, store result to a new allocated
* PKCS12-Bag structure (as a copy to allow freeing of original buffer) (PKCS12_FromSafebag).
*
*  @param pBagArr Array with Bag Idata Elements
*  @param BagArrayIndex Start of Bag description
*  @param pPwd Password in Unicode
*  @param PwdOff Start of data
*               int Pwdlen Size of password
*  @param ppBagStruc new allocated, filled structure
*  @return int Status - 0 o.k., else error occured
*/
static  int  PKCS12_FromSafebag(IDATA** pBagArr,
                                int BagArrayIndex, char* pPwd, int PwdOff, int PwdLen,
                                P12BAG ** ppBagStruc)
{
   int Retcode;
   int BagTypeID;
   int EncAlgorID;
   int IteratCnt;
   int EncDataLen = 0;
   int PlainTextLen;
   int CertTypeID;

   int pTmpVal[1];
   int pTmpRet[1];
   int pTmpFlag[1];
   int pTmpLong[1];

   char* pPlainTextBuf = NULL;
   char* ppTmpLocalKeyID[1];
   char* ppTmpFriendlyName[1];

   IDATA* pIdata;
   IDATA* pSaltIdata;
   IDATA** ppArr;

   IDATPARR* pShroudedBagDesc = NULL; 
   IDATPARR* pPbeParamsDesc = NULL;
   IDATPARR* pPrivKeyDesc = NULL; 
   IDATPARR* pCertDesc = NULL; 
   IDATPARR* pCertDataDesc = NULL; 

   IDATPARR* ppTmpDesc[1];
   P12BAG * pBagStruc;

   ppBagStruc[0] = NULL;
   //------------------------------------------------------------
   // Allocate PKCS12 Bag Structure
   //------------------------------------------------------------
   if((pBagStruc = AllocPKCS12BagStruc()) == NULL)
      return(PKCS12_ALLOC_ERR);

   for(;;)		// error processing FOR
   {
      //------------------------------------------------------------
      // get the type of the Bag from the OID
      //------------------------------------------------------------
      pIdata = pBagArr[BagArrayIndex + PKCS12_SAFEBAG_ID_VALUE_INDEX];
      if((Retcode = GetPKCS12_BagTypeID(
         pIdata->Base,
         (int) pIdata->Off,
         pIdata->Len,
         pTmpVal)) != PKCS12_OP_OK)
         break;
      BagTypeID = pTmpVal[0];
      pBagStruc->BagType = BagTypeID;
      pIdata = pBagArr[BagArrayIndex + PKCS12_SAFEBAG_VALUE_INDEX];
      //------------------------------------------------------------
      // Distribute by Bag type:
      //------------------------------------------------------------
      switch(BagTypeID)
      {
         //=========================================================
         // Key Bag Type (NOT encrypted!)
         //=========================================================
      case PKCS12_KEYBAG_SUBID:
         //--------------------------------------------------------------
         // Extract the Private key from key bag
         //--------------------------------------------------------------
         if((Retcode = FromASN1_PKCS8Privkey(pIdata->Base,
            (int) pIdata->Off, pIdata->Len,
            ppTmpDesc, pTmpVal, pTmpLong,
            pTmpFlag, pTmpRet)) != PKCS12_OP_OK)
            break;
         pPrivKeyDesc = ppTmpDesc[0];
         pBagStruc->PrivKeyUsageValid = pTmpFlag[0];
         pBagStruc->PrivKeyUsage      = pTmpLong[0];
         pBagStruc->PrivKeyType       = pTmpVal[0];
         //--------------------------------------------------------
         // Make a Local Copy of the Private key, put to structure
         //--------------------------------------------------------
         if((Retcode = CopyToLocalDatArrayDesc(HMEM_CTX_REF1 pPrivKeyDesc)) != ASN1_OP_OK)
            break;
         pBagStruc->pPrivKeyDesc = pPrivKeyDesc;
         pPrivKeyDesc = NULL;			// avoid freeing
         break;
         //=========================================================
         // Shrouded Key Bag Type
         //=========================================================
      case PKCS12_PKCS8_SHRBAG_SUBID:
         //--------------------------------------------------------
         // Decode shrouded keybag
         //--------------------------------------------------------
         if((Retcode = FromASN1_PKCS12ShroudedKeyBag(
            pIdata->Base, (int) pIdata->Off,
            pIdata->Len,ppTmpDesc,pTmpRet)) != PKCS12_OP_OK)
            break;
         pShroudedBagDesc = ppTmpDesc[0];
         ppArr = pShroudedBagDesc->ppArr;
         //--------------------------------------------------------
         // Get the Encryption Algorithm, check if recognized
         //--------------------------------------------------------
         pIdata = ppArr[PKCS12_SHRBAG_ENCALG_ID_INDEX];
         if((Retcode = GetPKCS12_PBEAlgorID(pIdata->Base,
            (int) pIdata->Off,
            pIdata->Len,0,
            pTmpVal)) != PKCS12_OP_OK)
            break;
         EncAlgorID = pTmpVal[0];
         //--------------------------------------------------------------
         // Decode the PBE Algorithm Parameters
         //--------------------------------------------------------------
         pIdata = ppArr[PKCS12_SHRBAG_ENCALG_PAR_INDEX];
         if((Retcode = FromASN1_PKCS12PbeParams(
            pIdata->Base,
            (int) pIdata->Off,
            pIdata->Len,
            ppTmpDesc, pTmpRet)) != ASN1_OP_OK)
            break;
         pPbeParamsDesc = ppTmpDesc[0];
         //-------------------------------------------------
         // Decode the Iteration count from the Params
         //-------------------------------------------------
         pIdata =
            pPbeParamsDesc->ppArr[PKCS12_PBE_PARAMS_ITERAT_INDEX];

         if((Retcode = ByteBufToUnsignedBIT32Num(pIdata->Base,(int) pIdata->Off,pIdata->Len,pTmpLong)) != ASN1_OP_OK)
            break;  
         IteratCnt = (int) pTmpLong[0];
         //-------------------------------------------------------
         // Setup Salt and encoded Data elements, get required size,
         // allocate buffer for decrypt
         //-------------------------------------------------------
         pSaltIdata =
            pPbeParamsDesc->ppArr[PKCS12_PBE_PARAMS_SALT_INDEX];
         pIdata = ppArr[PKCS12_SHRBAG_ENC_DATA_INDEX];

         EncDataLen = pIdata->Len;

         if((pPlainTextBuf = BIT8_ARRAY_ALLOC(HMEM_CTX_REF,
            EncDataLen)) == NULL)
         {
            Retcode = PKCS12_ALLOC_ERR;
            break;
         }
         //-------------------------------------------------------
         // Decrypt the data now
         //-------------------------------------------------------
         pTmpRet[0] = EncDataLen;
         if((Retcode = PKCS12Crypt(pPwd, PwdOff, PwdLen,	NULL, 0, 0,
            pSaltIdata->Base, (int) pSaltIdata->Off,
            pSaltIdata->Len, IteratCnt,
            EncAlgorID,PKCS12_DECRYPT,0,
            pIdata->Base, (int) pIdata->Off,
            pIdata->Len,
            pPlainTextBuf,0,pTmpRet)) != PKCS12_OP_OK)
            break;
         PlainTextLen = pTmpRet[0];

         //--------------------------------------------------------------
         // Extract the Private key from decrypted shrouded bag
         //--------------------------------------------------------------
         if((Retcode = FromASN1_PKCS8Privkey(pPlainTextBuf, 0, PlainTextLen,
            ppTmpDesc, pTmpVal, pTmpLong,
            pTmpFlag, pTmpRet)) != PKCS12_OP_OK)
            break;
         pPrivKeyDesc = ppTmpDesc[0];
         pBagStruc->PrivKeyUsageValid = pTmpFlag[0];
         pBagStruc->PrivKeyUsage      = pTmpLong[0];
         pBagStruc->PrivKeyType       = pTmpVal[0];
         //--------------------------------------------------------
         // Make a Local Copy of the Private key, put to structure
         //--------------------------------------------------------
         if((Retcode = CopyToLocalDatArrayDesc(HMEM_CTX_REF1 pPrivKeyDesc)) != ASN1_OP_OK)
            break;
         pBagStruc->pPrivKeyDesc = pPrivKeyDesc;
         pPrivKeyDesc = NULL;			// avoid freeing
         break;
         //=========================================================
         // CertBag Type
         //=========================================================
      case PKCS12_CERTBAG_SUBID:
         //--------------------------------------------------------
         // Split the CertBag into TypeID and value
         //--------------------------------------------------------
         if((Retcode = FromASN1_PKCS12CertBag(
            pIdata->Base, (int) pIdata->Off,
            pIdata->Len,ppTmpDesc,pTmpRet)) != PKCS12_OP_OK)
            break;
         pCertDesc = ppTmpDesc[0];
         //--------------------------------------------------------
         // Get the Certificate type from OID, check if supported
         //--------------------------------------------------------
         pIdata = pCertDesc->ppArr[PKCS12_CERTBAG_CERT_ID_INDEX];
         if((Retcode = GetPKCS12_CertTypeID(
            pIdata->Base,
            (int) pIdata->Off,
            pIdata->Len, pTmpVal)) != PKCS12_OP_OK)
            break;
         CertTypeID = pTmpVal[0];
         if(CertTypeID != PKCS12_X509_CERT_TYPE_SUBID)
         {
            Retcode = PKCS12_CERTBAG_UNSUPP_CERT_TYPE;
            break;
         }
         //--------------------------------------------------------
         // Unwrap the Certificate from surrounding OCTETSTR
         //--------------------------------------------------------
         pIdata = pCertDesc->ppArr[PKCS12_CERTBAG_VALUE_INDEX];
         if((Retcode = FromASN1_OCTETSTR(
            pIdata->Base,
            (int) pIdata->Off,
            pIdata->Len,
            ppTmpDesc, pTmpRet)) != ASN1_OP_OK)
            break;
         pCertDataDesc = ppTmpDesc[0];
         //--------------------------------------------------------
         // Make a Local Copy of the Certificate, put to structure
         //--------------------------------------------------------
         if((Retcode = CopyToLocalDatArrayDesc(HMEM_CTX_REF1 pCertDataDesc)) != ASN1_OP_OK)
            break;
         pBagStruc->pCertDesc = pCertDataDesc;
         pCertDataDesc = NULL;			// avoid freeing
         break;
         //----------------------------------------------------------
         // Unsupported SafeBag types
         //----------------------------------------------------------
      case PKCS12_CRLBAG_SUBID:
      case PKCS12_SECRBAG_SUBID:
      case PKCS12_SAFECONTBAG_SUBID:
      default:
         Retcode = PKCS12_UNSUPP_SAFEBAG_TYPE;
         break;
      }
      if(Retcode != PKCS12_OP_OK)
         break;
      //------------------------------------------------------------
      // Extract PKCS9 Bag Attributes if present
      //------------------------------------------------------------
      pIdata = pBagArr[BagArrayIndex + PKCS12_SAFEBAG_NAME_ATTS_INDEX];
      if((Retcode = PKCS12_GetPKCS9SelectedAtts(pIdata->Base,
         (int) pIdata->Off, pIdata->Len,
         ppTmpFriendlyName,pTmpRet,
         ppTmpLocalKeyID,pTmpVal)) != PKCS12_OP_OK)
         break;
      pBagStruc->pFriendlyName   = ppTmpFriendlyName[0];
      pBagStruc->FriendlyNameLen = pTmpRet[0];
      pBagStruc->pLocalKeyID     = ppTmpLocalKeyID[0];
      pBagStruc->LocalKeyIDLen   = pTmpVal[0];
      break;
   }
   //-------------------------------------------------------------
   // Free temporary Elements
   //-------------------------------------------------------------
   FreeIDATPARR_Struc(HMEM_CTX_REF1 pShroudedBagDesc);
   FreeIDATPARR_Struc(HMEM_CTX_REF1 pPbeParamsDesc);
   FreeIDATPARR_Struc(HMEM_CTX_REF1 pPrivKeyDesc);
   FreeIDATPARR_Struc(HMEM_CTX_REF1 pCertDesc);
   FreeIDATPARR_Struc(HMEM_CTX_REF1 pCertDataDesc);
   if(pPlainTextBuf != NULL)
   {
      ClearBit8Array(pPlainTextBuf,0,EncDataLen);
      FREE_ARRAY(HMEM_CTX_REF,pPlainTextBuf);
   }
   //--------------------------------------------------------
   // if error occured, clear all sensitive data
   //--------------------------------------------------------
   if(Retcode != PKCS12_OP_OK)
   {
      FreePKCS12BagStruc(pBagStruc);
      return(Retcode);
   }

   ppBagStruc[0] = pBagStruc;
   return(Retcode);
}

/**
* Get PFX LocalKeyID from PKVSupportingData 'Thumbprint'
* from SET OF without ASN.1 SET OF Header (PFX_GetLocalKeyID).
*
* NOTE: No parameters checked !
* -----
*
*  @param pBuf Thumbprint SET OF Base
*  @param Offset Start of Data
*  @param Len Length of Data
*  @param ppLocalKeyID allocated buffer / NULL
*  @param pLocalKeyIDLen size of KeyID (Digest)
*  @param pDigestAlgor Algor used for Digest
*  @return int Status - 0 o.k., else error occured
*/
static  int  PFX_GetLocalKeyID(char* pBuf,
                               int Offset, int Len,
                               char** ppLocalKeyID, int* pLocalKeyIDLen,
                               int* pDigestAlgor)
{
   int Retcode;

   int LocalKeyIDLen = 0;
   int ThumbPrintsCnt;
   int SignatAlgorID = PKCS12_SIGNAT_ALGOR_INVALID;

   int pTmpCnt[1];
   int pTmpRet[1];

   char* pLocalKeyID = NULL;
   char* ppTmpBuf[1];

   IDATA* pIdata;
   IDATA** ppArr;

   IDATPARR* pThumbPrintsDesc = NULL;
   IDATPARR* ppTmpDesc[1];

   ppLocalKeyID[0]     = NULL;
   pLocalKeyIDLen[0]   = 0;
   pDigestAlgor[0]     = INVALID_ALGOR;
   //-----------------------------------------------------------
   // Check if Any data in the SET OF
   //-----------------------------------------------------------
   if((pBuf == NULL) || (Len <= 0))
      return(PKCS12_OP_OK);

   for(;;)		// Error FOR
   {
      //------------------------------------------------------------
      // Split the SET contents into PKCS7 DigestInfos, at least one !
      // NOTE: we only support ONE DigestInfo
      //------------------------------------------------------------
      if((Retcode = FromASN1_UniversalEmbeddedType(pBuf, Offset, Len,
         ASN1_UNIVERSAL_NULL, 0, 0,
         (char *) PKCS7DigestInfoCtl,
         PKCS7_DIGESTINFO_CTL_CNT,
         PKCS7_DIGESTINFO_MAX_DATA_INDEX,
         PKCS7_DIGESTINFO_TO_INT_ERR,
         ppTmpDesc, pTmpCnt, pTmpRet)) != ASN1_OP_OK)
         return(Retcode);
      pThumbPrintsDesc = ppTmpDesc[0];
      ThumbPrintsCnt   = pTmpCnt[0] / PKCS7_DIGESTINFO_MAX_DATA_INDEX;
      if(ThumbPrintsCnt != 1)
      {
         Retcode = PFX_TOO_MANY_THUMBPRINTS;
         break;
      }
      ppArr = pThumbPrintsDesc->ppArr;
      //-----------------------------------------------------
      // Get the Signature Algorithm ID, check if valid
      //-----------------------------------------------------
      pIdata = ppArr[PKCS7_DIGESTINFO_ALGID_INDEX];
      if((Retcode = GetPFX_ThumbPrintAlgorTypeID(pIdata->Base,
         (int) pIdata->Off, pIdata->Len,
         pTmpRet)) != PKCS12_OP_OK)
         break;
      SignatAlgorID = pTmpRet[0];
      //-----------------------------------------------------
      // Check that no Parameters are present
      //-----------------------------------------------------
      pIdata = ppArr[PKCS7_DIGESTINFO_ALGPAR_INDEX];
      if((pBuf = pIdata->Base) != NULL)
      {
         Offset = (int) pIdata->Off;
         Len    = pIdata->Len;
         if((Len != 2) || (pBuf[Offset] != ASN1_UNIVERSAL_NULL) ||
            (pBuf[Offset+1] != 0))
         {
            Retcode = PFX_UNKNOWN_THUMBPRINT_ALGPARS;
            break;
         }
      }
      //-----------------------------------------------------
      // Copy Digest contents to allocated buffer
      //-----------------------------------------------------
      if((Retcode = PKCS12_AllocCopyDatArrayElement(pThumbPrintsDesc,
         PKCS7_DIGESTINFO_DATA_INDEX,
         ppTmpBuf, pTmpRet)) != PKCS12_OP_OK)
         break;
      pLocalKeyID   = ppTmpBuf[0];
      LocalKeyIDLen = pTmpRet[0];
      break;
   } // Error FOR
   //-----------------------------------------------------------
   // Free temporary used structures
   //-----------------------------------------------------------
   FreeIDATPARR_Struc(HMEM_CTX_REF1 pThumbPrintsDesc);
   if(Retcode != PKCS12_OP_OK)
   {
      FREE_ARRAY(HMEM_CTX_REF,pLocalKeyID);
      return(Retcode);
   }
   ppLocalKeyID[0]     = pLocalKeyID;
   pLocalKeyIDLen[0]   = LocalKeyIDLen;
   pDigestAlgor[0]     = SignatAlgorID;
   return(Retcode);
}

/**
* Put a PFX LocalKeyID aka. Digest into PKVSupportingData 'Thumbprint'
* without ASN.1 SET OF Header (PFX_GenLocalKeyID).
* NOTE: 1. may be empty !!
* -----
*
*  @param pLocalKeyID Buffer base
*  @param LocalKeyIDOff Start of Data
*  @param LocalKeyIDLen size of KeyID (Digest)
*  @param DigestAlgor Algor used for Digest
*               IDATPARR_PTR ppDtsDesc[] Descriptor to use
*  @param DstIndex Slot to use
*  @param DstAllocSize required slots for allocate
*  @return int Status - 0 o.k., else error occured
*/
static  int  PFX_GenLocalKeyID(char* pLocalKeyID,
                               int LocalKeyIDOff, int LocalKeyIDLen, int DigestAlgor,
                               IDATPARR** ppDstDesc, int DstIndex, int DstAllocSize)
{
   int Retcode, ActDigestAlgor;
   char TmpBuf[2];
   IDATPARR* ppTmpDesc[1];

   //-----------------------------------------------------------
   // Check if Any data shall be created
   //-----------------------------------------------------------
   if((pLocalKeyID == NULL) || (LocalKeyIDLen <= 0))
      return(PKCS12_OP_OK);

   if((DigestAlgor != PKCS12_SIGNAT_ALGOR_MD2) &&
      (DigestAlgor != PKCS12_SIGNAT_ALGOR_MD5) &&
      (DigestAlgor != PKCS12_SIGNAT_ALGOR_SHA1))
      return(PKCS12_PARAM_ERR);

   for(;;)			// Error FOR
   {
      //------------------------------------------------------------
      // Generate the Signature Algorithm OID either from RSA PKCS-2
      // or X9.57 Signat Algors
      //------------------------------------------------------------
      ppTmpDesc[0] = NULL;
      if((DigestAlgor == PKCS12_SIGNAT_ALGOR_MD2) ||
         (DigestAlgor == PKCS12_SIGNAT_ALGOR_MD5))
      {
         //----------------------------------------------------------
         // Set PKCS-2 Signature AlgorOID, allocate PKCS7 DigestInfo
         //----------------------------------------------------------
         if(DigestAlgor == PKCS12_SIGNAT_ALGOR_MD2)
            ActDigestAlgor = PKCS2_MD2_DIGEST_ALGOR_SUBID;
         else
            ActDigestAlgor = PKCS2_MD5_DIGEST_ALGOR_SUBID;
         if((Retcode = GenPKCS2_DigestAlgorOIDArc(ActDigestAlgor,
            ppTmpDesc, PKCS7_DIGESTINFO_ALGID_INDEX,
            PKCS7_DIGESTINFO_MAX_DATA_INDEX)) != PKCS12_OP_OK)
            break;
      }
      else
      {
         //---------------------------------------------------------
         // Set OIW DSA Signature AlgorOID, allocate PKCS7 DigestInfo
         //---------------------------------------------------------
         if((Retcode = GenOIW_DSA_AlgorOIDArc(OIW_DSA_ALGOR_SUBID,
            ppTmpDesc, PKCS7_DIGESTINFO_ALGID_INDEX,
            PKCS7_DIGESTINFO_MAX_DATA_INDEX)) != PKCS12_OP_OK)
            break;
      }
      //-----------------------------------------------------------
      // Generate NULL Signature AlgorParam element now
      //-----------------------------------------------------------
      TmpBuf[0] = ASN1_UNIVERSAL_NULL;
      TmpBuf[1] = 0;
      if((Retcode = FromBufToDatArray(HMEM_CTX_REF1 ppTmpDesc[0]->ppArr,PKCS7_DIGESTINFO_ALGPAR_INDEX,TmpBuf,0,2,1)) != ASN1_OP_OK)
         break;
      //-----------------------------------------------------------
      // Generate the digest element itself
      //-----------------------------------------------------------
      if((Retcode = FromBufToDescAllocCopy(pLocalKeyID, LocalKeyIDOff,
         LocalKeyIDLen,
         ppTmpDesc, PKCS7_DIGESTINFO_DATA_INDEX,
         0)) != PKCS12_OP_OK)
         break;
      //------------------------------------------------------------
      // Generate ASN.1 encoded PKCS7 DigestInfo now
      // NOTE: There is only one digest info !
      //------------------------------------------------------------
      Retcode = ToASN1_DescToDesc(ppTmpDesc[0], 0,
         (char *) PKCS7DigestInfoCtl,
         PKCS7_DIGESTINFO_CTL_CNT,
         PKCS7_DIGESTINFO_FROM_INT_ERR,
         ppDstDesc, DstIndex, DstAllocSize, NULL);
      break;
   } // Error FOR
   //-----------------------------------------------------------
   // Free temporary used structures
   //-----------------------------------------------------------
   FreeIDATPARR_Struc(HMEM_CTX_REF1 ppTmpDesc[0]);
   return(Retcode);
}

/**
* Process a (presplit) PFX BaggageItem, store result to a new allocated
* PKCS12-Bag structure (as a copy to allow freeing of original buffer) (PFX_FromBaggageItem).
*
*  @param pBaggageDesc Descriptor
*  @param BaggageArrayIndex Start of Baggage Item description
*  @param pPwd Password in PLAIN ASCII !!!
*  @param PwdOff Start of data
*               int Pwdlen Size of password
*  @param ppBagStruc new allocated, filled structure
*  @return int Status - 0 o.k., else error occured
*/
static  int  PFX_FromBaggageItem(IDATPARR* pBaggageDesc,
                                 int BaggageArrayIndex, char* pPwd, int PwdOff, int PwdLen,
                                 P12BAG ** ppBagStruc)
{
   int Retcode;
   int EspvkCnt;

   int EncAlgorID;
   int IteratCnt;
   int EncDataLen = 0;
   int PlainTextLen;

   int pTmpVal[1];
   int pTmpRet[1];
   int pTmpFlag[1];
   int pTmpLong[1];

   char* pPlainTextBuf = NULL;
   char* ppTmpLocalKeyID[1];
   char* ppTmpFriendlyName[1];

   IDATA* pIdata;
   IDATA* pSaltIdata;
   IDATA** ppArr;

   IDATPARR* pEspvkDesc = NULL; 
   IDATPARR* pShroudedBagDesc = NULL; 
   IDATPARR* pPbeParamsDesc = NULL;
   IDATPARR* pPrivKeyDesc = NULL; 
   IDATPARR* pCertDesc = NULL; 
   IDATPARR* pCertDataDesc = NULL; 

   IDATPARR* ppTmpDesc[1];
   P12BAG * pBagStruc;

   ppBagStruc[0] = NULL;
   //------------------------------------------------------------
   // Allocate PKCS12 Bag Structure
   //------------------------------------------------------------
   if((pBagStruc = AllocPKCS12BagStruc()) == NULL)
      return(PKCS12_ALLOC_ERR);

   for(;;)		// error processing FOR
   {
      //--------------------------------------------------------------
      // Subdecode the BaggageItem's Espvk
      // NOTE: we only support ONE Espvk per BaggageItem !!!!
      //--------------------------------------------------------------
      ppArr = pBaggageDesc->ppArr;
      pIdata = ppArr[BaggageArrayIndex + PFX_BAGGAGEITEM_ESPVKS_INDEX];
      if((Retcode = FromASN1_PFXEspvks(
         pIdata->Base, (int) pIdata->Off,
         pIdata->Len,
         ppTmpDesc, pTmpVal, pTmpRet)) != PKCS12_OP_OK)
         break;
      pEspvkDesc = ppTmpDesc[0];
      EspvkCnt   = pTmpVal[0] / PFX_ESPVK_MAX_DATA_INDEX;
      if(EspvkCnt != 1)
      {
         Retcode = PFX_BAGITEM_TOO_MANY_ESPVKS;
         break;
      }
      ppArr = pEspvkDesc->ppArr;
      //------------------------------------------------------------
      // get the type of the ESPVK from the OID, check it
      //------------------------------------------------------------
      pIdata = ppArr[PFX_ESPVK_OID_INDEX];
      if((Retcode =  GetPFX_EspvkTypeID(pIdata->Base,
         (int) pIdata->Off,
         pIdata->Len, pTmpVal)) != PKCS12_OP_OK)
         break;
      if(pTmpVal[0] != PFX_ESPVK_PKCS8_SHROUDING_SUBID)
      {
         Retcode = PFX_INVALID_ESPVK_TYPE;
         break;
      }
      pBagStruc->BagType = PKCS12_PKCS8_SHRBAG_SUBID;
      //-------------------------------------------------------------
      // Get the Encryption Algorithm (PFX-Mode), check if recognized
      //-------------------------------------------------------------
      pIdata = ppArr[PFX_ESPVK_CIPHALG_ID_INDEX];
      if((Retcode = GetPKCS12_PBEAlgorID(pIdata->Base,
         (int) pIdata->Off,
         pIdata->Len,1,
         pTmpVal)) != PKCS12_OP_OK)
         break;
      EncAlgorID = pTmpVal[0];
      //-------------------------------------------------
      // Decode the Iteration count from the ESPVK Params
      //-------------------------------------------------
      pIdata = ppArr[PFX_ESPVK_ITERAT_CNT_INDEX];
      if((Retcode = ByteBufToUnsignedBIT32Num(pIdata->Base,(int) pIdata->Off,pIdata->Len,pTmpLong)) != ASN1_OP_OK)
         break;  
      IteratCnt = (int) pTmpLong[0];
      //-------------------------------------------------------
      // Setup Salt and encoded Data elements, get required size,
      // allocate buffer for decrypt
      //-------------------------------------------------------
      pSaltIdata = ppArr[PFX_ESPVK_SALT_DATA_INDEX];
      pIdata     = ppArr[PFX_ESPVK_ENC_DATA_INDEX];

      EncDataLen = pIdata->Len;

      if((pPlainTextBuf = BIT8_ARRAY_ALLOC(HMEM_CTX_REF,
         EncDataLen)) == NULL)
      {
         Retcode = PKCS12_ALLOC_ERR;
         break;
      }
      //-------------------------------------------------------
      // Decrypt the data now (PFX-Mode)
      //-------------------------------------------------------
      pTmpRet[0] = EncDataLen;
      if((Retcode = PKCS12Crypt(pPwd, PwdOff, PwdLen, NULL, 0, 0,
         pSaltIdata->Base, (int) pSaltIdata->Off,
         pSaltIdata->Len, IteratCnt,
         EncAlgorID,PKCS12_DECRYPT,1,
         pIdata->Base, (int) pIdata->Off,
         pIdata->Len,
         pPlainTextBuf,0,pTmpRet)) != PKCS12_OP_OK)
         break;
      PlainTextLen = pTmpRet[0];

      //--------------------------------------------------------------
      // Extract the Private key from decrypted ESPVK Contents
      //--------------------------------------------------------------
      if((Retcode = FromASN1_PKCS8Privkey(pPlainTextBuf, 0, PlainTextLen,
         ppTmpDesc, pTmpVal, pTmpLong,
         pTmpFlag, pTmpRet)) != PKCS12_OP_OK)
         break;
      pPrivKeyDesc = ppTmpDesc[0];
      pBagStruc->PrivKeyUsageValid = pTmpFlag[0];
      pBagStruc->PrivKeyUsage      = pTmpLong[0];
      pBagStruc->PrivKeyType       = pTmpVal[0];
      //--------------------------------------------------------
      // Make a Local Copy of the Private key, put to structure
      //--------------------------------------------------------
      if((Retcode = CopyToLocalDatArrayDesc(HMEM_CTX_REF1 pPrivKeyDesc)) != ASN1_OP_OK)
         break;
      pBagStruc->pPrivKeyDesc = pPrivKeyDesc;
      pPrivKeyDesc = NULL;			// avoid freeing
      //------------------------------------------------------------
      // Get FriendlyName (PFX: 'Nickname') if present
      //------------------------------------------------------------
      Retcode = PKCS12_AllocCopyDatArrayElement(
         pEspvkDesc,PFX_ESPVK_NICKNAME_INDEX,
         ppTmpFriendlyName, pTmpRet);
      if(Retcode != PKCS12_OP_OK)
         break;
      pBagStruc->pFriendlyName   = ppTmpFriendlyName[0];
      pBagStruc->FriendlyNameLen = pTmpRet[0];
      //------------------------------------------------------------
      // Get LocalKeyID (PFX: 'ThumbPrint') if present
      //------------------------------------------------------------
      pIdata = ppArr[PFX_ESPVK_ASSOC_CERTS_INDEX];
      if((Retcode = PFX_GetLocalKeyID(pIdata->Base,
         (int) pIdata->Off,
         pIdata->Len,
         ppTmpLocalKeyID, pTmpRet, pTmpFlag)) != PKCS12_OP_OK)

         break;

      pBagStruc->pLocalKeyID     = ppTmpLocalKeyID[0];
      pBagStruc->LocalKeyIDLen   = pTmpRet[0];
      pBagStruc->DigestAlgor     = pTmpFlag[0];
      break;
   }
   //-------------------------------------------------------------
   // Free temporary Elements
   //-------------------------------------------------------------
   FreeIDATPARR_Struc(HMEM_CTX_REF1 pShroudedBagDesc);
   FreeIDATPARR_Struc(HMEM_CTX_REF1 pPbeParamsDesc);
   FreeIDATPARR_Struc(HMEM_CTX_REF1 pPrivKeyDesc);
   FreeIDATPARR_Struc(HMEM_CTX_REF1 pCertDesc);
   FreeIDATPARR_Struc(HMEM_CTX_REF1 pCertDataDesc);
   if(pPlainTextBuf != NULL)
   {
      ClearBit8Array(pPlainTextBuf,0,EncDataLen);
      FREE_ARRAY(HMEM_CTX_REF,pPlainTextBuf);
   }
   //--------------------------------------------------------
   // if error occured, clear all sensitive data
   //--------------------------------------------------------
   if(Retcode != PKCS12_OP_OK)
   {
      FreePKCS12BagStruc(pBagStruc);
      return(Retcode);
   }

   ppBagStruc[0] = pBagStruc;
   return(Retcode);
}

/**
* Generate a PFX Baggage Item from a Private key Safebag (PFX_ToBaggageItem).
* NOTE: No params checked !
*
*  @param pPfxStruc Structure
*  @param PrivBagIndex related Private Key Bag
*  @param ppDstDesc Descriptor to use/allocate
*  @param DstIndex Slot to use
*  @param DstAllocSize required slots for allocate
*  @return int Status - 0 o.k., else error occured
*/
static  int  PFX_ToBaggageItem(HMEM_CTX_DEF
                               PK12STRU * pPfxStruc,
                               int PrivBagIndex, IDATPARR** ppDstDesc,
                               int DstIndex, int DstAllocSize)
{
   int Retcode, SaltLen, IteratCnt;

   int PBE_EncAlgorID;
   int EncDataLen = 0;
   int EncBufLen = 0;
   int PlainDataLen;

   char TmpBuf[2] = {(unsigned char) 0x31, (unsigned char) 0x00};

   char* pPlainBuf = NULL;
   char* pSaltBuf = NULL;
   char* pEncBuf = NULL;

   int pTmpLen[1];

   IDATA* pIdata;

   IDATPARR* pPrivKeyDesc     = NULL; 
   IDATPARR* pEspvkDesc       = NULL; 
   IDATPARR* pNickNameDesc    = NULL; 
   IDATPARR* pBaggageItemDesc = NULL; 

   IDATPARR* ppTmpDesc[1];
   P12BAG * pPrivKeyBag;

   //------------------------------------------------------------
   // Get the Private Key Bag to process
   //------------------------------------------------------------
   pPrivKeyBag = pPfxStruc->pPrivKeyBagsArr[PrivBagIndex];
   //--------------------------------------------------------
   // Allocate the Salt buffer
   //--------------------------------------------------------
   SaltLen   = pPfxStruc->PrivSaltLen;
   IteratCnt = pPfxStruc->PrivIteratCnt; 
   if(IteratCnt <= 0)
      IteratCnt = 1;
   if((pSaltBuf = BIT8_ARRAY_ALLOC(HMEM_CTX_REF,
      SaltLen)) == NULL)
      return(PKCS12_ALLOC_ERR);
   // should we seed with data ???
   //  RAND_BYTES(RANDinst, pSaltBuf, 0, SaltLen);
   if((Retcode = SecDrbgRandBytes(HMEM_CTX_REF1 pSaltBuf,0,SaltLen)) != 0)
   {
      FREE_ARRAY(HMEM_CTX_REF,pSaltBuf);
      return(Retcode);
   }

   for(;;)			// Error FOR
   {
      //-------------------------------------------------------
      // Generate ASN.1 encoded Private key data, alloc 
      //-------------------------------------------------------
      ppTmpDesc[0] = NULL;			// Force Allocate
      if((Retcode = ToASN1_PKCS8PrivkeyDesc(
         pPrivKeyBag->pPrivKeyDesc,
         pPrivKeyBag->PrivKeyType,
         pPrivKeyBag->PrivKeyUsageValid,
         pPrivKeyBag->PrivKeyUsage,
         ppTmpDesc, 0, 1)) != PKCS12_OP_OK)
         break;
      pPrivKeyDesc = ppTmpDesc[0];
      //-------------------------------------------------------
      // Allocate Encryption buffer
      //-------------------------------------------------------
      pIdata = pPrivKeyDesc->ppArr[0];
      pPlainBuf = pIdata->Base;
      PlainDataLen = pIdata->Len;
      EncBufLen = PlainDataLen + PKCS12_PBE_ALGOR_MAX_BLKLEN;
      if((pEncBuf = BIT8_ARRAY_ALLOC(HMEM_CTX_REF,
         EncBufLen)) == NULL)
      {
         Retcode = PKCS12_ALLOC_ERR;
         break;
      }
      //-------------------------------------------------------
      // Encrypt the Private key data now (PFX-Mode, ASCII Pwd)
      //-------------------------------------------------------
      pTmpLen[0] = EncBufLen;
      Retcode = PKCS12Crypt(
         pPfxStruc->pPwd,
         pPfxStruc->PwdOff,
         pPfxStruc->PwdLen,
         NULL, 0, 0,
         pSaltBuf, 0, SaltLen,
         IteratCnt,
         pPfxStruc->PrivKeyPBEEncAlgorID,
         PKCS12_ENCRYPT, 1,
         pIdata->Base, (int) pIdata->Off,
         pIdata->Len,
         pEncBuf,0,pTmpLen);
      ClearBit8Array(pPlainBuf, 0, PlainDataLen);
      FreeIDATPARR_Struc(HMEM_CTX_REF1 pPrivKeyDesc);
      pPlainBuf = NULL;
      pPrivKeyDesc = NULL;

      if(Retcode != PKCS12_OP_OK)
         break;

      EncDataLen = pTmpLen[0];
      //-------------------------------------------------------------
      // Set the PFX PKCS8_KeyShrouding OID, alloc all ESPVK elements
      //-------------------------------------------------------------
      ppTmpDesc[0] = NULL;		// Force allocate
      if((Retcode = GenPFX_ESPVK_TypeOIDArc(PFX_ESPVK_PKCS8_SHROUDING_SUBID,
         ppTmpDesc, PFX_ESPVK_OID_INDEX,
         PFX_ESPVK_MAX_DATA_INDEX)) != PKCS12_OP_OK)
         break;
      pEspvkDesc = ppTmpDesc[0];
      //-------------------------------------------------------------
      // Set the PFX SupportingData Local KeyID
      //-------------------------------------------------------------
      if((Retcode = PFX_GenLocalKeyID(
         pPrivKeyBag->pLocalKeyID, 0,
         pPrivKeyBag->LocalKeyIDLen,
         PKCS12_SIGNAT_ALGOR_SHA1,
         ppTmpDesc,PFX_ESPVK_ASSOC_CERTS_INDEX,
         0)) != PKCS12_OP_OK)
         break;
      //---------------------------------------------------------
      // Generate Nickname as BMP-String
      //---------------------------------------------------------
      ppTmpDesc[0] = NULL;		// Force allocate
      if((Retcode = FromBufToDescAllocCopy(
         pPrivKeyBag->pFriendlyName, 0,
         pPrivKeyBag->FriendlyNameLen,
         ppTmpDesc, 0, 1)) != PKCS12_OP_OK)
         break;
      pNickNameDesc = ppTmpDesc[0];

      ppTmpDesc[0] = pEspvkDesc;
      if((Retcode = ToASN1_DescToDesc(pNickNameDesc, 0,
         (char *) ASN1BmpStrCtl,ASN1_BMPSTR_CTL_CNT,
         PKCS12_BMPSTR_FROM_INT_ERR,
         ppTmpDesc, PFX_ESPVK_NICKNAME_INDEX, 0,
         NULL)) != PKCS12_OP_OK)
         break;
      FreeIDATPARR_Struc(HMEM_CTX_REF1 pNickNameDesc);
      pNickNameDesc = NULL;			// avoid freeing
      //--------------------------------------------------------
      // Set the PBE encryption Algor OID, allocate all elements
      // NOTE: The PrivKeyBag Algor ID's are the PKCS12 AlgorIDs
      // ----- and must be mapped to PFX Algor IDs !!
      //--------------------------------------------------------
      PBE_EncAlgorID = pPfxStruc->PrivKeyPBEEncAlgorID;
      if(PBE_EncAlgorID == PKCS12_PBE_SHA_3DESC_CBC_2KEYS)
      {
         Retcode = PFX_INVALID_PRIVBAG_ALGOR_ID;
         break;
      }
      if(PBE_EncAlgorID > PKCS12_PBE_SHA_3DESC_CBC_2KEYS)
         PBE_EncAlgorID--;				// convert to defined Range

      //  ppTmpDesc[0] = pEspvkDesc;
      if((Retcode = GenPFX_EncPBEType_OIDArc(PBE_EncAlgorID,
         ppTmpDesc, PFX_ESPVK_CIPHALG_ID_INDEX,
         0)) != PKCS12_OP_OK)
         break;
      //--------------------------------------------------------
      // Generate the PBE Algor Params, Salt and Iteration count
      //--------------------------------------------------------
      //  ppTmpDesc[0] = pEspvkDesc;
      if((Retcode = FromBufToDescAllocCopy(pSaltBuf, 0, SaltLen,
         ppTmpDesc, PFX_ESPVK_SALT_DATA_INDEX,
         0)) != PKCS12_OP_OK)
         break;

      if((Retcode = GenUnsignedBit32Num(IteratCnt, ppTmpDesc,
         PFX_ESPVK_ITERAT_CNT_INDEX,
         0)) != PKCS12_OP_OK)
         break;
      //--------------------------------------------------------
      // Set the encrypted private key content parameter
      //--------------------------------------------------------
      if((Retcode = FromBufToDescAllocCopy(pEncBuf, 0, EncDataLen,
         ppTmpDesc, PFX_ESPVK_ENC_DATA_INDEX,
         0)) != PKCS12_OP_OK)
         break;
      //--------------------------------------------------------------
      // Generate the BaggageItem's Espvk, allocate all elements
      //--------------------------------------------------------------
      ppTmpDesc[0] = NULL;			// Force allocate
      if((Retcode = ToASN1_PFXEspvksDesc(pEspvkDesc,
         ppTmpDesc, PFX_BAGGAGEITEM_ESPVKS_INDEX,
         PFX_BAGGAGEITEM_MAX_DATA_INDEX, NULL)) != PKCS12_OP_OK)
         break;
      pBaggageItemDesc = ppTmpDesc[0];
      FreeIDATPARR_Struc(HMEM_CTX_REF1 pEspvkDesc);
      pEspvkDesc = NULL;			// avoid freeing	
      //--------------------------------------------------------------
      // Set Dummy buffer for Empty Set
      //--------------------------------------------------------------
      pIdata = pBaggageItemDesc->ppArr[PFX_BAGGAGEITEM_UNENC_SECR_IND];
      pIdata->Base = TmpBuf;
      pIdata->Len  = 2;

      //--------------------------------------------------------------
      // Generate the BaggageItem
      //--------------------------------------------------------------
      ppTmpDesc[0] = NULL;			// Force allocate
      Retcode = ToASN1_PFXBaggageItemDesc(pBaggageItemDesc,
         ppDstDesc, DstIndex, DstAllocSize, NULL);

      pIdata->Base = NULL;
      FreeIDATPARR_Struc(HMEM_CTX_REF1 pBaggageItemDesc);
      return(Retcode);
   }
   //-------------------------------------------------------------
   // Free temporary Elements
   //-------------------------------------------------------------
   FreeIDATPARR_Struc(HMEM_CTX_REF1 pPrivKeyDesc);
   FreeIDATPARR_Struc(HMEM_CTX_REF1 pEspvkDesc);
   FreeIDATPARR_Struc(HMEM_CTX_REF1 pNickNameDesc);
   FreeIDATPARR_Struc(HMEM_CTX_REF1 pBaggageItemDesc);
   return(Retcode);
}

/**
* Process the PFX Safe ContentInfo from (presplit) AuthenticatedSafe:
* Decode the ContentInfo [type EncryptedData], Decrypt it and split to
* PFX SafeBags (PFX_FromSafeContent).
*
*  @param pSafeDesc Descriptor
*  @param pPwd Password in Unicode
*  @param PwdOff Start of data
*               int Pwdlen Size of password
*               IDATPARR_PTR pDatArryDesc[] Resulting Bags
*  @param pSafeBagsCnt Number of Bags
*  @param ppDecryptBufBase Buffer allocated for decryption
*  @param pDecryptBufLen Size of buffer
*  @return int Status - 0 o.k., else error occured
*/
static  int  PFX_FromSafeContent(IDATPARR* pSafeDesc,
                                 char* pPwd, int PwdOff, int PwdLen,
                                 IDATPARR** pDatArrayDesc, int* pSafeBagsCnt,
                                 char** ppDecryptBufBase, int* pDecryptBufLen)
{
   int Retcode;

   int EncAlgorID;
   int IteratCnt;
   int EncDataLen = 0;
   int PlainTextLen;

   int pTmpVal[1];
   int pTmpRet[1];
   int pTmpLong[1];

   char* pPlainTextBuf = NULL;

   IDATA* pIdata;
   IDATA* pSaltIdata;
   IDATA* pPrivSaltIdata;
   IDATA** ppArr;

   IDATPARR* pSafeDataDesc = NULL; 
   IDATPARR* pPbeParamsDesc = NULL;

   IDATPARR* ppTmpDesc[1];

   pDatArrayDesc[0] = NULL;
   pSafeBagsCnt[0]  = 0;
   ppDecryptBufBase[0] = NULL;
   //--------------------------------------------------------------
   // Subdecode the PKCS7 encryptedData ContentInfo
   //--------------------------------------------------------------
   ppArr = pSafeDesc->ppArr;
   pIdata = ppArr[PFX_AUTHSAFE_CONTDATA_INDEX];
   Retcode = FromASN1_PKCS7_EncDataContent(
      pIdata->Base, (int) pIdata->Off,
      pIdata->Len,ppTmpDesc,pTmpRet);
   if(Retcode != PKCS12_OP_OK)
      return(Retcode);

   pSafeDataDesc = ppTmpDesc[0];
   ppArr = pSafeDataDesc->ppArr;

   for(;;)				// Error FOR
   {
      //-------------------------------------------------------------
      // Get the Encryption Algorithm (PFX-Mode), check if recognized
      //-------------------------------------------------------------
      pIdata = ppArr[PKCS7_ENCDATA_ENCALG_ID_INDEX];
      if((Retcode = GetPKCS12_PBEAlgorID(pIdata->Base,
         (int) pIdata->Off,
         pIdata->Len,1,
         pTmpVal)) != PKCS12_OP_OK)
         break;
      EncAlgorID = pTmpVal[0];
      //--------------------------------------------------------------
      // Decode the PBE Algorithm Parameters
      //--------------------------------------------------------------
      pIdata = ppArr[PKCS7_ENCDATA_ENCALG_PAR_INDEX];
      if((Retcode = FromASN1_PKCS12PbeParams(
         pIdata->Base,
         (int) pIdata->Off,
         pIdata->Len,
         ppTmpDesc, pTmpRet)) != ASN1_OP_OK)
         break;
      pPbeParamsDesc = ppTmpDesc[0];
      //-------------------------------------------------
      // Decode the Iteration count from the Params
      //-------------------------------------------------
      pIdata = pPbeParamsDesc->ppArr[PKCS12_PBE_PARAMS_ITERAT_INDEX];
      if((Retcode = ByteBufToUnsignedBIT32Num(pIdata->Base,(int) pIdata->Off,pIdata->Len,pTmpLong)) != ASN1_OP_OK)
         break;  
      IteratCnt = (int) pTmpLong[0];
      //-------------------------------------------------------
      // Setup Salt, PrivacySalt and encoded Data elements,
      //  get required size, allocate buffer for decrypt
      //-------------------------------------------------------
      pSaltIdata = pPbeParamsDesc->ppArr[PKCS12_PBE_PARAMS_SALT_INDEX];
      pIdata     = ppArr[PKCS7_ENCDATA_ENCDATA_INDEX];
      pPrivSaltIdata =
         pSafeDesc->ppArr[PFX_AUTHSAFE_PRIVSALT_INDEX];

      EncDataLen = pIdata->Len;

      if((pPlainTextBuf = BIT8_ARRAY_ALLOC(HMEM_CTX_REF,
         EncDataLen)) == NULL)
      {
         Retcode = PKCS12_ALLOC_ERR;
         break;
      }
      //-------------------------------------------------------
      // Decrypt the data now (PFX-Mode) with privacy salt
      //-------------------------------------------------------
      pTmpRet[0] = EncDataLen;
      if((Retcode = PKCS12Crypt(pPwd, PwdOff, PwdLen,
         pPrivSaltIdata->Base, (int) pPrivSaltIdata->Off,
         pPrivSaltIdata->Len,
         pSaltIdata->Base, (int) pSaltIdata->Off,
         pSaltIdata->Len, IteratCnt,
         EncAlgorID,PKCS12_DECRYPT,1,
         pIdata->Base, (int) pIdata->Off,
         pIdata->Len,
         pPlainTextBuf,0,pTmpRet)) != PKCS12_OP_OK)
         break;
      PlainTextLen = pTmpRet[0];
      //--------------------------------------------------------------
      // Decode Decrypted SafeContents to SafeBags
      //--------------------------------------------------------------
      Retcode =  FromASN1_PFXSafeContents(pPlainTextBuf, 0, PlainTextLen,
         pDatArrayDesc,pSafeBagsCnt,pTmpRet);
      if(Retcode == PKCS12_OP_OK)
         pSafeBagsCnt[0] /= PKCS12_SAFEBAG_MAX_DATA_INDEX;
      break;
   } // Error FOR
   //-------------------------------------------------------------
   // Free temporary Elements
   //-------------------------------------------------------------
   FreeIDATPARR_Struc(HMEM_CTX_REF1 pSafeDataDesc);
   FreeIDATPARR_Struc(HMEM_CTX_REF1 pPbeParamsDesc);
   if(Retcode != PKCS12_OP_OK)
   {
      if(pPlainTextBuf != NULL)
      {
         ClearBit8Array(pPlainTextBuf,0,EncDataLen);
         FREE_ARRAY(HMEM_CTX_REF,pPlainTextBuf);
      }
      return(Retcode);
   }
   ppDecryptBufBase[0] = pPlainTextBuf;
   pDecryptBufLen[0] = EncDataLen;
   return(Retcode);
}

/**
* Build the PFX AuthenticatedSafe (PFX_ToSafeContent).
* - Assemble Safebags to SafeContents SET
* - Encrypt the SafeContent
* - Encode to ContentInfo [type EncryptedData]
*
*  @param pPfxStruc Structure
*  @param pSafeBagsDesc SafeBags
*  @param pPrivSaltBuf Privacy Salt
*  @param PrivSaltOff Start of Data
*  @param PrivSaltLen Size of Data
*  @param ppDstDesc Descripto to load
*  @param DstIndex Slot to use
*  @param DstAllocSize Slots to allocate
*  @return int Status - 0 o.k., else error occured
*/
static  int  PFX_ToSafeContent(PK12STRU * pPfxStruc,
                               IDATPARR* pSafeBagsDesc, char* pPrivSaltBuf, int PrivSaltOff,
                               int PrivSaltLen, IDATPARR** ppDstDesc,
                               int DstIndex, int DstAllocSize)
{
   int Retcode;

   int SaltLen, IteratCnt;
   int PBE_EncAlgorID = -1;
   int PlainOffset = 0;
   int PlainDataLen = 0;
   int EncBufLen;
   int EncDataLen = 0;

   int pTmpRet[1];

   char* pSaltBuf = NULL;
   char* pPlainBuf = NULL;
   char* pEncBuf = NULL;

   IDATA* pIdata;

   IDATPARR* pSafeContentsDesc = NULL; 
   IDATPARR* pEncDataDesc = NULL;

   IDATPARR* ppTmpDesc[1];

   for(;;)				// Error FOR
   {
      //--------------------------------------------------------------
      // Encode Safebags to SafeContents SET
      //--------------------------------------------------------------
      ppTmpDesc[0] = NULL;		// Force alloc
      if((Retcode = ToASN1_PFXSafeContentsDesc(pSafeBagsDesc,
         ppTmpDesc, 0, 1, NULL)) != PKCS12_OP_OK)
         break;
      pSafeContentsDesc = ppTmpDesc[0];
      //--------------------------------------------------------
      // Allocate the Content Salt buffer
      //--------------------------------------------------------
      SaltLen   = pPfxStruc->CertSaltLen;
      IteratCnt = pPfxStruc->CertIteratCnt; 
      if((pSaltBuf = BIT8_ARRAY_ALLOC(HMEM_CTX_REF,
         SaltLen)) == NULL)
      {
         Retcode = PKCS12_ALLOC_ERR;
         break;
      }
      //    RAND_BYTES(RANDinst, pSaltBuf, 0, SaltLen);
      if((Retcode = SecDrbgRandBytes(HMEM_CTX_REF1 pSaltBuf,0,SaltLen)) != 0)
         break;
      //--------------------------------------------------------
      // Allocate the Encryption buffer
      //--------------------------------------------------------
      pIdata = pSafeContentsDesc->ppArr[0];
      pPlainBuf    = pIdata->Base;
      PlainOffset  = (int) pIdata->Off;
      PlainDataLen = pIdata->Len;
      EncBufLen = PlainDataLen + PKCS12_PBE_ALGOR_MAX_BLKLEN;
      if((pEncBuf = BIT8_ARRAY_ALLOC(HMEM_CTX_REF,
         EncBufLen)) == NULL)
      {
         Retcode = PKCS12_ALLOC_ERR;
         break;
      }
      //-------------------------------------------------------
      // Encrypt the data now (PFX-Mode) with privacy salt
      //-------------------------------------------------------
      pTmpRet[0] = EncBufLen;
      if((Retcode = PKCS12Crypt(
         pPfxStruc->pUniPwd,
         pPfxStruc->UniPwdOff,
         pPfxStruc->UniPwdLen,
         pPrivSaltBuf, PrivSaltOff, PrivSaltLen,
         pSaltBuf, 0, SaltLen, IteratCnt,
         pPfxStruc->CertPBEEncAlgorID,
         PKCS12_ENCRYPT,1,
         pPlainBuf, PlainOffset, PlainDataLen,
         pEncBuf,0,pTmpRet)) != PKCS12_OP_OK)
         break;
      EncDataLen = pTmpRet[0];
      ClearBit8Array(pPlainBuf, PlainOffset, PlainDataLen);
      pPlainBuf = NULL;
      FreeIDATPARR_Struc(HMEM_CTX_REF1 pSafeContentsDesc);
      pSafeContentsDesc = NULL;			// avoid freeing
      //---------------------------------------------------------------
      // Generate EncryptedContent Value, Set Version (0), Allocate All
      //---------------------------------------------------------------
      ppTmpDesc[0] = NULL;		// Force allocate
      if((Retcode = GenUnsignedBit32Num(0, ppTmpDesc,
         PKCS7_ENCDATA_VERSION_INDEX,
         PKCS7_ENCDATA_MAX_DATA_INDEX)) != PKCS12_OP_OK)
         break;
      pEncDataDesc = ppTmpDesc[0];
      //-------------------------------------------------------------
      // Set the Embedded Content Type OID (DATA)
      //-------------------------------------------------------------
      if((Retcode = GenPKCS7_ContentTypeOIDArc(PKCS7_CONTENT_DATA_SUBID,
         ppTmpDesc, PKCS7_ENCDATA_TYPE_INDEX,
         0)) != PKCS12_OP_OK)
         break;
      //--------------------------------------------------------
      // Set the PBE encryption Algor OID, allocate all elements
      // NOTE: The PrivKeyBag Algor ID's are the PKCS12 AlgorIDs
      // ----- and must be mapped to PFX Algor IDs !!
      //--------------------------------------------------------
      PBE_EncAlgorID = pPfxStruc->CertPBEEncAlgorID;
      if(PBE_EncAlgorID == PKCS12_PBE_SHA_3DESC_CBC_2KEYS)
      {
         Retcode = PFX_INVALID_CERTBAG_ALGOR_ID;
         break;
      }
      if(PBE_EncAlgorID > PKCS12_PBE_SHA_3DESC_CBC_2KEYS)
         PBE_EncAlgorID--;				// convert to defined Range

      if((Retcode = GenPFX_EncPBEType_OIDArc(PBE_EncAlgorID,
         ppTmpDesc, PKCS7_ENCDATA_ENCALG_ID_INDEX,
         0)) != PKCS12_OP_OK)
         break;
      //--------------------------------------------------------
      // Generate the PBE Algor Params, Salt and Iteration count
      //--------------------------------------------------------
      if((Retcode = ToASN1_PBEParamsToDesc(pSaltBuf, 0, SaltLen, IteratCnt,
         ppTmpDesc, PKCS7_ENCDATA_ENCALG_PAR_INDEX,
         0)) != PKCS12_OP_OK)
         break;
      FREE_ARRAY(HMEM_CTX_REF,pSaltBuf);
      pSaltBuf = NULL;				// Avoid freeing
      //--------------------------------------------------------
      // Set the encrypted Safebags SET content parameter
      //--------------------------------------------------------
      if((Retcode = FromBufToDescAlloc(pEncBuf, 0, EncDataLen,
         ppTmpDesc, PKCS7_ENCDATA_ENCDATA_INDEX,
         0)) != PKCS12_OP_OK)
         break;
      pEncBuf = NULL;				// avoid freeing
      //--------------------------------------------------------------
      // Encode to PKCS7 EncData Content Info
      //--------------------------------------------------------------
      if((Retcode = ToASN1_PKCS7_EncDataContentDesc(pEncDataDesc, 0,
         ppDstDesc, DstIndex, DstAllocSize,
         NULL)) != PKCS12_OP_OK)
         break;
      FreeIDATPARR_Struc(HMEM_CTX_REF1 pEncDataDesc);
      return(PKCS12_OP_OK);
   }
   //-------------------------------------------------------------
   // Free temporary Elements
   //-------------------------------------------------------------
   FREE_ARRAY(HMEM_CTX_REF,pSaltBuf);
   FREE_ARRAY(HMEM_CTX_REF,pEncBuf);
   if(pPlainBuf != NULL)
      ClearBit8Array(pPlainBuf, PlainOffset, PlainDataLen);

   FreeIDATPARR_Struc(HMEM_CTX_REF1 pSafeContentsDesc);
   FreeIDATPARR_Struc(HMEM_CTX_REF1 pEncDataDesc);
   return(Retcode);
}

/**
* Process a PFX CertCRLbag, store result to array of new allocated
* PKCS12-Bag structure (as a copy to allow freeing of original buffer) (PFX_FromCertCRLBag).
*
*  @param pBagArr Array with Bag Idata Elements
*  @param BagArrayIndex Start of Bag description
*  @param ppBagStrucArr new allocated, filled
*  @param pBagStructsCnt number of Elements loaded
*  @return int Status - 0 o.k., else error occured
*/
static  int  PFX_FromCertCRLBag(IDATA** pBagArr,
                                int BagArrayIndex, P12BAG *** ppBagStrucArr,
                                int* pBagStructsCnt)
{
   int Retcode, Index;
   int CertCRLTypeID;
   int CertsCount;
   int BagStrucCnt = 0;

   int pTmpVal[1];
   int pTmpRet[1];

   IDATA* pIdata;
   IDATA** ppArr;

   IDATPARR* pX509CertCRLDesc = NULL; 
   IDATPARR* pX509CertListDesc = NULL; 
   IDATPARR* pX509CertDesc = NULL; 

   IDATPARR* ppTmpDesc[1];
   P12BAG * pBagStruc;
   P12BAG ** pBagStrucArr = NULL;

   ppBagStrucArr[0]  = NULL;
   pBagStructsCnt[0] = 0;

   for(;;)		// error processing FOR
   {
      //------------------------------------------------------------
      // get the CertCRL type from the OID, check if recognized
      //------------------------------------------------------------
      pIdata = pBagArr[BagArrayIndex +  PFX_CERTCRL_BAG_OID_INDEX];
      if((Retcode = GetPFX_CertTypeID(pIdata->Base,
         (int) pIdata->Off,
         pIdata->Len, pTmpRet)) != PKCS12_OP_OK)
         break;
      CertCRLTypeID = pTmpRet[0];
      if(CertCRLTypeID != PKCS12_X509_CERT_TYPE_SUBID)
      {
         Retcode = PFX_UNSUPPORTED_CERTCRL_TYPE;
         break;
      }
      //------------------------------------------------------------
      // Decode the X509 CertCRL
      //------------------------------------------------------------
      pIdata = pBagArr[BagArrayIndex + PFX_CERTCRL_BAG_VALUE_INDEX];
      if((Retcode = FromASN1_PFX_X509CertCRL(
         pIdata->Base,
         (int) pIdata->Off,
         pIdata->Len,
         ppTmpDesc, pTmpRet)) != PKCS12_OP_OK)
         break;
      pX509CertCRLDesc = ppTmpDesc[0];
      //----------------------------------------------------------------
      // Split the X509 CertList into X509 Certificates
      //----------------------------------------------------------------
      pIdata = pX509CertCRLDesc->ppArr[PFX_X509_CERTCRL_CERTS_INDEX];
      if((Retcode = FromASN1_PFX_X509CertList(
         pIdata->Base,
         (int) pIdata->Off,
         pIdata->Len,
         ppTmpDesc, pTmpVal, pTmpRet)) != PKCS12_OP_OK)
         break;
      pX509CertListDesc = ppTmpDesc[0];
      CertsCount        = pTmpVal[0] / PFX_X509_CERTLIST_MAX_DATA_IND;
      //----------------------------------------------------------------
      // Allocate required Bag Structures Array
      //----------------------------------------------------------------
      BagStrucCnt = CertsCount;
      if((pBagStrucArr = AllocInitPKCS12BagStrucArr(BagStrucCnt)) == NULL)
      {
         Retcode = PKCS12_ALLOC_ERR;
         break;
      }      
      //----------------------------------------------------------------
      // Copy the Certificates to the Bag Structures
      //----------------------------------------------------------------
      ppArr = pX509CertListDesc->ppArr;
      Index = 0;
      while(Index < CertsCount)
      {
         //--------------------------------------------------------------
         // Allocate an IDATPARR structure with 1 Element
         //--------------------------------------------------------------
         if((Retcode = AllocIDATPARR_Struc(HMEM_CTX_REF1 ppTmpDesc,1)) != ASN1_OP_OK)
            break;
         pX509CertDesc = ppTmpDesc[0];
         pX509CertDesc->Flags |= FREE_BIT_MASK;
         //--------------------------------------------------------------
         // Copy the data to the Descriptor Element, also copy the buffer
         //--------------------------------------------------------------
         pIdata = ppArr[Index];
         if((Retcode = FromBufToDatArray(HMEM_CTX_REF1 pX509CertDesc->ppArr,0,pIdata->Base,(int) pIdata->Off,pIdata->Len,1)) != ASN1_OP_OK)
            break;
         //--------------------------------------------------------------
         // Fill the structure with the data and supporting information
         //--------------------------------------------------------------
         pBagStruc = pBagStrucArr[Index];
         pBagStruc->BagType   = PKCS12_CERTBAG_SUBID;
         pBagStruc->pCertDesc = pX509CertDesc;
         pX509CertDesc = NULL;				// avoid freeing
         Index++;
      }
      break;
   }
   //---------------------------------------------------------
   // Free temporary elements
   //---------------------------------------------------------
   FreeIDATPARR_Struc(HMEM_CTX_REF1 pX509CertCRLDesc);
   FreeIDATPARR_Struc(HMEM_CTX_REF1 pX509CertListDesc);
   FreeIDATPARR_Struc(HMEM_CTX_REF1 pX509CertDesc);
   if(Retcode != PKCS12_OP_OK)
   {
      if(pBagStrucArr != NULL)
         FreePKCS12BagStrucArr(pBagStrucArr, BagStrucCnt);
      return(Retcode);
   }
   ppBagStrucArr[0]  = pBagStrucArr;
   pBagStructsCnt[0] = BagStrucCnt;
   return(Retcode);
}

/**
* Build a PFX CertCRLbag from Certbag Array (PFX_ToCertCRLBagDesc).
*
*  @param pPfxStruc Structure to process
*  @param ppDstDesc Descriptor to use
*  @param DstIndex Slot to use
*  @param DstAllocSize Slots to allocate
*  @return int Status - 0 o.k., else error occured
*/
static  int  PFX_ToCertCRLBagDesc(PK12STRU * pPfxStruc,
                                  IDATPARR** ppDstDesc, int DstIndex, int DstAllocSize)
{
   int Retcode, Index;
   int BagsCnt;

   char TmpBuf[2] = {(unsigned char) 0x31, (unsigned char) 0x00};

   IDATA* pIdata;
   IDATA* pIdata2;

   IDATPARR* pCertsDesc = NULL; 
   IDATPARR* pCertInfoDesc = NULL; 
   IDATPARR* pX509CertCRLDesc = NULL; 
   IDATPARR* pCertCRLBagDesc = NULL; 

   IDATPARR* ppTmpDesc[1];

   P12BAG * pActCertBag;
   P12BAG ** pBagArr;

   //-------------------------------------------------------------
   // get number of bags to process
   //-------------------------------------------------------------
   pBagArr = pPfxStruc->pCertBagsArr;
   BagsCnt = pPfxStruc->CertsCnt;
   if(BagsCnt <= 0)  
      return(PKCS12_PARAM_ERR);
   //-------------------------------------------------------------
   // Allocate Descriptor for the Certificates List
   //-------------------------------------------------------------
   if((Retcode = AllocIDATPARR_Struc(HMEM_CTX_REF1 ppTmpDesc,BagsCnt)) != ASN1_OP_OK)
      return(Retcode);
   pCertsDesc = ppTmpDesc[0];
   pCertsDesc->Flags |= FREE_BIT_MASK; // mark as freeable
   //-------------------------------------------------------------
   // Copy Certificates to the Descriptor Elements
   //-------------------------------------------------------------
   Index = 0;
   while(Index < BagsCnt)
   {
      pActCertBag = pBagArr[Index];
      pIdata = pActCertBag->pCertDesc->ppArr[0];

      if((Retcode = FromBufToDescAllocCopy(
         pIdata->Base,
         (int) pIdata->Off,
         pIdata->Len,
         ppTmpDesc, Index, 0)) != PKCS12_OP_OK)
      {
         FreeIDATPARR_Struc(HMEM_CTX_REF1 pCertsDesc);
         return(Retcode);
      }
      Index++;
   }
   for(;;)
   {
      //-----------------------------------------------------------------
      // Generate the CertCRL ContentInfo (signedData) OID, allocate all
      //-----------------------------------------------------------------
      ppTmpDesc[0] = NULL;		// Force Allocate
      if((Retcode = GenPKCS7_ContentTypeOIDArc(PKCS7_CONTENT_SIGDATA_SUBID,
         ppTmpDesc, PFX_X509_CERTCRL_CONTTYPE_INDEX,
         PFX_X509_CERTCRL_MAX_DATA_INDEX)) != PKCS12_OP_OK)
         break;
      pCertInfoDesc = ppTmpDesc[0];
      //-----------------------------------------------------------------
      // Generate the CertCRL ContentInfo Version (1)
      //-----------------------------------------------------------------
      if((Retcode = GenUnsignedBit32Num(1, ppTmpDesc,
         PFX_X509_CERTCRL_VERSION_INDEX,
         0)) != PKCS12_OP_OK)
         break;
      //-----------------------------------------------------------------
      // Generate the ContentType (Data) OID
      //-----------------------------------------------------------------
      if((Retcode = GenPKCS7_ContentTypeOIDArc(PKCS7_CONTENT_DATA_SUBID,
         ppTmpDesc, PFX_X509_CERTCRL_CONT_TYPE_IND,
         0)) != PKCS12_OP_OK)
         break;
      //-----------------------------------------------------------------
      // Generate the Certificate 'List' (SET)
      //-----------------------------------------------------------------
      if((Retcode =ToASN1_PFX_X509CertListDesc(pCertsDesc,
         ppTmpDesc, PFX_X509_CERTCRL_CERTS_INDEX,
         0, NULL)) != PKCS12_OP_OK)
         break;
      FreeIDATPARR_Struc(HMEM_CTX_REF1 pCertsDesc);
      pCertsDesc = NULL;				// avoid freeing

      //-----------------------------------------------------------------
      // Generate X509CertCRL, set X509CertCRL Type OID, allocate all
      //-----------------------------------------------------------------
      ppTmpDesc[0] = NULL;		// Force Allocate
      if((Retcode = GenPFX_CertType_OIDArc(PFX_CERTCRL_TYPE_X509_SUBID,
         ppTmpDesc, PFX_CERTCRL_BAG_OID_INDEX,
         PFX_CERTCRL_BAG_MAX_DATA_INDEX)) != PKCS12_OP_OK)
         break;
      pX509CertCRLDesc = ppTmpDesc[0];
      //-----------------------------------------------------------------
      // Set Dummy Buffer for Digest Algors and SignerInfos empty SET
      //-----------------------------------------------------------------
      pIdata  = pCertInfoDesc->ppArr[PFX_X509_CERTCRL_DIGESTALGS_IND];
      pIdata2 = pCertInfoDesc->ppArr[PFX_X509_CERTCRL_SIGINFOS_INDEX];
      pIdata->Base  = TmpBuf;    
      pIdata->Len   = 2;
      pIdata2->Base = TmpBuf;    
      pIdata2->Len  = 2;

      //-----------------------------------------------------------------
      // Generate the X509Certs ContentInfo Encoding
      //-----------------------------------------------------------------
      Retcode = ToASN1_PFX_X509CertCRLDesc(pCertInfoDesc, 0,
         ppTmpDesc, PFX_CERTCRL_BAG_VALUE_INDEX,
         0, NULL);

      pIdata->Base  = NULL;    
      pIdata2->Base = NULL;    
      if(Retcode != PKCS12_OP_OK)
         break;
      FreeIDATPARR_Struc(HMEM_CTX_REF1 pCertInfoDesc);
      pCertInfoDesc = NULL;				// avoid freeing
      //-----------------------------------------------------------------
      // Generate the X509CertCRL Encoding, allocate the CertBag
      //-----------------------------------------------------------------
      ppTmpDesc[0] = NULL;			// Force allocate
      if((Retcode = ToASN1_PFXCertCRLBagDesc(pX509CertCRLDesc,
         ppTmpDesc, PKCS12_SAFEBAG_VALUE_INDEX,
         PKCS12_SAFEBAG_MAX_DATA_INDEX,
         NULL)) != PKCS12_OP_OK)
         break;
      pCertCRLBagDesc = ppTmpDesc[0];
      FreeIDATPARR_Struc(HMEM_CTX_REF1 pX509CertCRLDesc);
      pX509CertCRLDesc = NULL;				// avoid freeing 
      //-----------------------------------------------------------------
      // Generate CertCRL Bag OID
      //-----------------------------------------------------------------
      if((Retcode = GenPFX_BagType_OIDArc(PFX_BAGTYPE_CERTCRLBAG_SUBID,
         ppTmpDesc, PKCS12_SAFEBAG_ID_VALUE_INDEX,
         0)) != PKCS12_OP_OK)
         break;
      //-----------------------------------------------------------------
      // Generate the Safebag Encoding (same as V3)
      //-----------------------------------------------------------------
      if((Retcode = ToASN1_PFXSafeBagDesc(pCertCRLBagDesc, 0,
         ppDstDesc, DstIndex, DstAllocSize,
         NULL)) != PKCS12_OP_OK)
         break;

      FreeIDATPARR_Struc(HMEM_CTX_REF1 pCertCRLBagDesc);
      return(ASN1_OP_OK);
   }
   //--------------------------------------------------
   // Error occured, free Elements
   //--------------------------------------------------
   FreeIDATPARR_Struc(HMEM_CTX_REF1 pX509CertCRLDesc);
   FreeIDATPARR_Struc(HMEM_CTX_REF1 pCertCRLBagDesc);
   FreeIDATPARR_Struc(HMEM_CTX_REF1 pCertInfoDesc);
   FreeIDATPARR_Struc(HMEM_CTX_REF1 pCertsDesc);
   return(Retcode);
}    

/**
* Process a PFX Safebag, store result to array of new allocated
* PKCS12-Bag structure (as a copy to allow freeing of original buffer) (PFX_FromSafebag).
*
*  @param pBagArr Array with Bag Idata Elements
*  @param BagArrayIndex Start of Bag description
*  @param ppBagStrucArr new allocated, filled
*  @param pBagsCnt number of Elements loaded
*  @return int Status - 0 o.k., else error occured
*/
static  int  PFX_FromSafebag(IDATA** pBagArr,
                             int BagArrayIndex, P12BAG *** ppBagStrucArr,
                             int* pBagsCnt)
{
   int Retcode;
   int BagTypeID;
   int CertCRLBagsCnt;

   int pTmpVal[1];
   int pTmpRet[1];

   IDATA* pIdata;

   IDATPARR* pCertCRLBagDesc = NULL; 

   IDATPARR* ppTmpDesc[1];

   ppBagStrucArr[0] = NULL;
   pBagsCnt[0] = 0;
   //------------------------------------------------------------
   // Process the Bag type
   //------------------------------------------------------------
   for(;;)		// error processing FOR
   {
      //------------------------------------------------------------
      // get the type of the Bag from the OID
      //------------------------------------------------------------
      pIdata = pBagArr[BagArrayIndex + PKCS12_SAFEBAG_ID_VALUE_INDEX];
      if((Retcode = GetPFX_BagTypeID(
         pIdata->Base,
         (int) pIdata->Off,
         pIdata->Len,
         pTmpVal)) != PKCS12_OP_OK)
         break;
      BagTypeID = pTmpVal[0];
      pIdata = pBagArr[BagArrayIndex + PKCS12_SAFEBAG_VALUE_INDEX];
      //------------------------------------------------------------
      // Distribute by Bag type:
      //------------------------------------------------------------
      switch(BagTypeID)
      {
         //=========================================================
         // CertCRL Bag Type
         //=========================================================
      case PFX_BAGTYPE_CERTCRLBAG_SUBID:
         //--------------------------------------------------------
         // Decode the CertCRL bag to CertCRLs
         // Note: we support only 1 Item of a CertCRL !
         //--------------------------------------------------------
         if((Retcode = FromASN1_PFXCertCRLBag(
            pIdata->Base, (int) pIdata->Off,
            pIdata->Len,
            ppTmpDesc,pTmpVal,pTmpRet)) != PKCS12_OP_OK)
            break;
         pCertCRLBagDesc = ppTmpDesc[0];
         CertCRLBagsCnt = pTmpVal[0] / PFX_CERTCRL_BAG_MAX_DATA_INDEX;
         if(CertCRLBagsCnt != 1)
         {
            Retcode = PFX_TOO_MANY_CERTCRLS;
            break;
         }
         //--------------------------------------------------------
         // Process the CertCRL contents, make list of structures
         //--------------------------------------------------------
         Retcode = PFX_FromCertCRLBag(pCertCRLBagDesc->ppArr,
            0, ppBagStrucArr, pBagsCnt);
         break;
         //==========================================================
         // Other Bag types, not supported
         //==========================================================
      case PFX_BAGTYPE_KEYBAG_SUBID:
      case PFX_BAGTYPE_SECRETBAG_SUBID:
      default:
         Retcode = PFX_UNSUPP_SAFEBAG_TYPE;
         break;
      }
      break;
   }
   //-------------------------------------------------------------
   // Free temporary Elements
   //-------------------------------------------------------------
   FreeIDATPARR_Struc(HMEM_CTX_REF1 pCertCRLBagDesc);
   return(Retcode);
}

/**
* Build PFX AuthenticatedSafe from Structure (PFX_ToAuthenticatedSafeDesc).
*
*  @param pPfxStruc Structure with Bags
*  @param ppDstDesc Descriptor to load
*  @param DstIndex Slot to use
*  @param DstAllocSize Slots to allocate
*  @return int Status - 0 o.k., else error occured
*/
static  int  PFX_ToAuthenticatedSafeDesc(PK12STRU * pPfxStruc,
                                         IDATPARR** ppDstDesc, int DstIndex, int DstAllocSize)
{
   int Retcode, PrivKeysCnt, Index, PrivSaltLen;

   char* pPrivSaltBuf = NULL;

   IDATPARR* pAuthSafeDesc = NULL;  
   IDATPARR* pBaggageItemsDesc = NULL;  
   IDATPARR* pBagsDesc = NULL;  

   IDATPARR* ppTmpDesc[1];
   //-----------------------------------------------------------------
   // Generate BaggageItems from the Private Keys
   //-----------------------------------------------------------------
   PrivKeysCnt  = pPfxStruc->PrivKeysCnt;
   if((Retcode = AllocIDATPARR_Struc(HMEM_CTX_REF1 ppTmpDesc,PrivKeysCnt)) != ASN1_OP_OK)
      return(Retcode);
   pBaggageItemsDesc = ppTmpDesc[0];
   pBaggageItemsDesc->Flags |= FREE_BIT_MASK;
   Index = 0;
   while(Index < PrivKeysCnt)
   {
      if((Retcode = PFX_ToBaggageItem(HMEM_CTX_REF1 pPfxStruc, Index,
         ppTmpDesc, Index, 0)) != PKCS12_OP_OK)
      {
         FreeIDATPARR_Struc(HMEM_CTX_REF1 pBaggageItemsDesc);
         return(Retcode);
      }
      Index++;
   }
   for(;;)
   {
      //-------------------------------------------------------
      // Generate Privacy Salt
      //-------------------------------------------------------
      PrivSaltLen = pPfxStruc->PFXPrivSaltLen;
      if((pPrivSaltBuf = BIT8_ARRAY_ALLOC(HMEM_CTX_REF,
         PrivSaltLen)) == NULL)
      {
         Retcode = PKCS12_ALLOC_ERR;
         break;
      }
      // should we seed with data ???
      //    RAND_BYTES(RANDinst, pPrivSaltBuf, 0, PrivSaltLen);
      if((Retcode = SecDrbgRandBytes(HMEM_CTX_REF1 pPrivSaltBuf,0,PrivSaltLen)) != 0)
         break;

      //-------------------------------------------------------
      // Set AuthSafe Version, allocate all elements
      //-------------------------------------------------------
      ppTmpDesc[0] = NULL;		// Force Allocate
      if((Retcode = GenUnsignedBit32Num(1, ppTmpDesc,
         PFX_AUTHSAFE_VERSION_INDEX,
         PFX_AUTHSAFE_MAX_DATA_INDEX)) != PKCS12_OP_OK)
         break;
      pAuthSafeDesc = ppTmpDesc[0];
      //-----------------------------------------------------------------
      // Generate the TransportMode (Offline) OID
      //-----------------------------------------------------------------
      if((Retcode = GenPFX_TranspModeOIDArc(PFX_TRANSP_MODE_OFFLINE_SUBID,
         ppTmpDesc, PFX_AUTHSAFE_TRANSP_MODE_INDEX,
         0)) != PKCS12_OP_OK)
         break;
      //-----------------------------------------------------------------
      // Generate the PrivacySalt Bitstring Value
      //-----------------------------------------------------------------
      //  if((Retcode = ToAsn1_BitstrValueToDesc(pPrivSaltBuf, 0, PrivSaltLen, 0,
      //			ppTmpDesc,PFX_AUTHSAFE_PRIVSALT_INDEX,
      //		        0)) != PKCS12_OP_OK)
      if((Retcode = FromBufToDescAllocCopy(pPrivSaltBuf, 0, PrivSaltLen,
         ppTmpDesc,PFX_AUTHSAFE_PRIVSALT_INDEX,
         0)) != PKCS12_OP_OK)
         break;
      //-------------------------------------------------------
      // Encode the Baggage from the BaggageItems
      //-------------------------------------------------------
      if((Retcode = ToASN1_PFXBaggageDesc(pBaggageItemsDesc,
         ppTmpDesc, PFX_AUTHSAFE_BAGGAGE_SET_IND,
         0, NULL)) != PKCS12_OP_OK)
         break;
      //-----------------------------------------------------------------
      // Set SafeContent Type (EncData) OID
      //-----------------------------------------------------------------
      if((Retcode = GenPKCS7_ContentTypeOIDArc(PKCS7_CONTENT_ENCDATA_SUBID,
         ppTmpDesc, PFX_AUTHSAFE_CONTTYPE_INDEX,
         0)) != PKCS12_OP_OK)
         break;
      //-----------------------------------------------------------------
      // Generate the SafeContentInfo from the Certbag
      //-----------------------------------------------------------------
      ppTmpDesc[0] = NULL;		// Force allocate
      if((Retcode = PFX_ToCertCRLBagDesc(pPfxStruc,
         ppTmpDesc, 0, 1)) != PKCS12_OP_OK)
         break;
      pBagsDesc = ppTmpDesc[0];

      ppTmpDesc[0] = pAuthSafeDesc;
      if((Retcode = PFX_ToSafeContent(pPfxStruc, pBagsDesc,
         pPrivSaltBuf, 0, PrivSaltLen,
         ppTmpDesc, PFX_AUTHSAFE_CONTDATA_INDEX,
         0)) != PKCS12_OP_OK)
         break;
      FreeIDATPARR_Struc(HMEM_CTX_REF1 pBagsDesc);
      pBagsDesc = NULL;			// avoid freeing
      FREE_ARRAY(HMEM_CTX_REF,pPrivSaltBuf);
      pPrivSaltBuf = NULL;		// avoid freeing
      //-----------------------------------------------------------------
      // Encode the Authenticated Safe
      //-----------------------------------------------------------------
      if((Retcode = ToASN1_PFX_AuthSafeDesc(pAuthSafeDesc, 0,
         ppDstDesc, DstIndex, DstAllocSize,
         NULL)) != PKCS12_OP_OK)
         break;
      FreeIDATPARR_Struc(HMEM_CTX_REF1 pAuthSafeDesc);
      return(PKCS12_OP_OK);
   }
   //--------------------------------------------------------
   // Free temporary used elements
   //--------------------------------------------------------
   FREE_CARRAY(HMEM_CTX_REF,pPrivSaltBuf);
   FreeIDATPARR_Struc(HMEM_CTX_REF1 pBaggageItemsDesc);
   FreeIDATPARR_Struc(HMEM_CTX_REF1 pAuthSafeDesc);
   FreeIDATPARR_Struc(HMEM_CTX_REF1 pBagsDesc);
   return(Retcode);
}

/**
* Build a PKCS12 V1 (PFX) PDU from Structure (PFX_ToPFXPduDesc).
*
*  @param pPfxStruc Structure
*  @param ppDstDesc Descriptor to load
*  @param DstIndex Slot to use
*               int AllocSize Slots to allocate
*  @return int Status - 0 o.k., else error occured
*/
static  int  PFX_ToPFXPduDesc(HMEM_CTX_DEF PK12STRU * pPfxStruc,
                              IDATPARR** ppDstDesc, int DstIndex, int DstAllocSize)
{
   int Retcode, SaltLen;

   char TmpBuf[2] = {(unsigned char) 0x05, (unsigned char) 0x00};
   char DigestBuf[SHA_DIGEST_LEN];

   char* pSaltBuf = NULL;

   IDATA* pIdata;

   IDATPARR* pAuthentSafeDesc = NULL;  
   IDATPARR* pPFXPduDesc = NULL;  
   IDATPARR* ppTmpDesc[1];

   for(;;)
   {
      //-----------------------------------------------------------------
      // Generate the Authenticated Safe
      //-----------------------------------------------------------------
      ppTmpDesc[0] = NULL;		// Force alloc
      if((Retcode = PFX_ToAuthenticatedSafeDesc(pPfxStruc,
         ppTmpDesc, 0, 1)) != PKCS12_OP_OK)
         break;
      pAuthentSafeDesc = ppTmpDesc[0];
      //-----------------------------------------------------------------
      // Alloc, fill MAC Salt buffer
      //-----------------------------------------------------------------
      SaltLen = pPfxStruc->MACSaltLen;
      if((pSaltBuf = BIT8_ARRAY_ALLOC(HMEM_CTX_REF,
         SaltLen)) == NULL)
      {
         Retcode = PKCS12_ALLOC_ERR;
         break;
      }
      // should we seed with data ???
      //    RAND_BYTES(RANDinst, pSaltBuf, 0, SaltLen);
      if((Retcode = SecDrbgRandBytes(HMEM_CTX_REF1 pSaltBuf,0,SaltLen)) != 0)
         break;

      //----------------------------------------------------------------
      // Generate the HMAC, PFX Mode
      //----------------------------------------------------------------
      pIdata = pAuthentSafeDesc->ppArr[0];
      if((Retcode = PKCS12GenVfyHMAC_SHA1(
         pPfxStruc->pUniPwd,
         pPfxStruc->UniPwdOff,
         pPfxStruc->UniPwdLen,
         pSaltBuf, 0, SaltLen, 1,
         PKCS12_HASH_TYPE_SHA1,
         PKCS12_HMAC_GEN,1,
         pIdata->Base,
         (int) pIdata->Off,
         pIdata->Len,
         DigestBuf, 0, SHA_DIGEST_LEN)) != PKCS12_OP_OK)
         break;
      //-----------------------------------------------------------------
      // Set the HMAC Digest Algor (OIW SHA1) OID, allocate all elements
      //-----------------------------------------------------------------
      ppTmpDesc[0] = NULL;			// Force Allocate
      if((Retcode = GenOIW_DSA_AlgorOIDArc(OIW_DSA_ALGOR_SUBID,
         ppTmpDesc, PKCS12_PFX_PDU_MAC_ALGID_INDEX,
         PKCS12_PFX_PDU_MAX_DATA_INDEX)) != PKCS12_OP_OK)
         break;
      pPFXPduDesc = ppTmpDesc[0];
      //-----------------------------------------------------------------
      // Generate the HMAC Digest AlgorParams (NULL)
      //-----------------------------------------------------------------
      if((Retcode = FromBufToDescAllocCopy(TmpBuf, 0, 2,
         ppTmpDesc, PKCS12_PFX_PDU_MAC_ALGPAR_INDEX,
         0)) != PKCS12_OP_OK)
         break;
      //-----------------------------------------------------------------
      // Set the HMAC Digest
      //-----------------------------------------------------------------
      if((Retcode = FromBufToDescAllocCopy(DigestBuf, 0, SHA_DIGEST_LEN,
         ppTmpDesc, PKCS12_PFX_PDU_MAC_DIGEST_INDEX,
         0)) != PKCS12_OP_OK)
         break;
      //-----------------------------------------------------------------
      // Set the HMAC Salt
      //-----------------------------------------------------------------
      //    if((Retcode = ToAsn1_BitstrValueToDesc(pSaltBuf, 0, SaltLen, 0,
      //			ppTmpDesc,PKCS12_PFX_PDU_MAC_SALT_INDEX,
      //		        0)) != PKCS12_OP_OK)
      if((Retcode = FromBufToDescAllocCopy(pSaltBuf, 0, SaltLen,
         ppTmpDesc,PKCS12_PFX_PDU_MAC_SALT_INDEX,
         0)) != PKCS12_OP_OK)
         break;
      FREE_ARRAY(HMEM_CTX_REF,pSaltBuf);		// also sets pointer to NULL
      //-----------------------------------------------------------------
      // Set the AuthSafe Content Info (DATA) OID
      //-----------------------------------------------------------------
      if((Retcode = GenPKCS7_ContentTypeOIDArc(PKCS7_CONTENT_DATA_SUBID,
         ppTmpDesc, PKCS12_PFX_PDU_CONTTYPE_INDEX,
         0)) != PKCS12_OP_OK)
         break;
      //-----------------------------------------------------------------
      // Embed AuthenticatedSafe in an OCTETSTR
      //-----------------------------------------------------------------
      if((Retcode = ToASN1_BufToDescOCTETSTR(pIdata->Base,
         (int) pIdata->Off, pIdata->Len,
         ppTmpDesc, PKCS12_PFX_PDU_CONTDATA_INDEX,
         0)) != PKCS12_OP_OK)
         break;
      pAuthentSafeDesc->Flags &= (~FREE_BIT_MASK); // Keep buffer!!
      FreeIDATPARR_Struc(HMEM_CTX_REF1 pAuthentSafeDesc);
      pAuthentSafeDesc = NULL;		// avoid freeing
      //-----------------------------------------------------------------
      // Encode the PFX V1 PFX PDU
      //-----------------------------------------------------------------
      if((Retcode = ToASN1_PFX_PFX_Desc(pPFXPduDesc, 0,
         ppDstDesc, DstIndex, DstAllocSize,
         NULL)) != PKCS12_OP_OK)
         break;
      FreeIDATPARR_Struc(HMEM_CTX_REF1 pPFXPduDesc);
      return(PKCS12_OP_OK);
   }
   //--------------------------------------------------------
   // Free temporary used elements
   //--------------------------------------------------------
   FREE_CARRAY(HMEM_CTX_REF,pSaltBuf);
   FreeIDATPARR_Struc(HMEM_CTX_REF1 pAuthentSafeDesc);
   FreeIDATPARR_Struc(HMEM_CTX_REF1 pPFXPduDesc);
   return(Retcode);
}

/**
* Generate  a local KeyID for a DER Certificate
* using given Hash function type (needed for PFX processing) (GenCertLclKeyID).
* The Hash is done from the binary certificate data.
*
*
*  @param pCertData Data buffer to Hash
*  @param CertDataOff Start of Data
*  @param CertDataLen Size of data to Hash
*  @param HashAlgorType Hash to use
*  @param ppLclKeyID Allocated buffer
*  @param pLclKeyIDLen Size of data
*  @param ppLclKeyIDDup Duplicate of ID / NULL
*  @return int Status - 0 o.k., else error occured
*/
static  int  GenCertLclKeyID(char* pCertData, int CertDataOff,
                             int CertDataLen, int HashAlgorType, char** ppLclKeyID,
                             int* pLclKeyIDLen, char** ppLclKeyIDDup)
{
   int DigestLen;
   int TotalLen;
   char* pDstBuf;
   int HashArray[PKCS12_MAX_HASH_ARRAY_SIZE];
   //------------------------------------------------------------
   // Check parameters
   //------------------------------------------------------------
   if((pCertData == NULL) || (ppLclKeyID == NULL) || (pLclKeyIDLen == NULL))
      return(PKCS12_NULL_PTR);
   if((CertDataLen <= 0) ||
      ((HashAlgorType != PKCS12_SIGNAT_ALGOR_MD2) &&
      (HashAlgorType != PKCS12_SIGNAT_ALGOR_MD5) &&
      (HashAlgorType != PKCS12_SIGNAT_ALGOR_SHA1)))
      return(PKCS12_PARAM_ERR);
   //------------------------------------------------------------
   // Generate the Digest
   //------------------------------------------------------------
   DigestLen = SHA_DIGEST_LEN;
   if(HashAlgorType != PKCS12_SIGNAT_ALGOR_SHA1)
      DigestLen = MD5_DIGEST_LEN;		// also for MD2
   TotalLen = DigestLen + 2;		// for ASN.1 Octet string Header!
   //-----------------------------------------------------------
   // Allocate Buffer for KeyID, and if required for duplicate
   //-----------------------------------------------------------
   if((pDstBuf = BIT8_ARRAY_ALLOC(HMEM_CTX_REF, TotalLen)) == NULL)    
      return(PKCS12_ALLOC_ERR);

   if(ppLclKeyIDDup != NULL)
   {
      if((ppLclKeyIDDup[0] = BIT8_ARRAY_ALLOC(HMEM_CTX_REF,
         TotalLen)) == NULL)    
      {
         FREE_ARRAY(HMEM_CTX_REF,pDstBuf);
         return(PKCS12_ALLOC_ERR);
      }
   }
   //-----------------------------------------------------------
   // Generate the Digest
   // NOTE: We hash the cert in total, should we change that ???
   //-----------------------------------------------------------
   HASH_Init(HashArray, HashAlgorType);
   HASH_Update(HashArray, pCertData, CertDataOff, CertDataLen, HashAlgorType);
   HASH_Final(HashArray, pDstBuf, 2, HashAlgorType);
   pDstBuf[0] = ASN1_UNIVERSAL_OCTETSTRING;
   pDstBuf[1] = (char) DigestLen;
   ppLclKeyID[0] = pDstBuf;
   //-----------------------------------------------------------
   // Copy Digest if requested
   //-----------------------------------------------------------
   if(ppLclKeyIDDup != NULL)
      memcpy(ppLclKeyIDDup[0]+0,pDstBuf+0,TotalLen);
   pLclKeyIDLen[0] = TotalLen;
   return(PKCS12_OP_OK);
} 

/**
* Generate 'Pseudo' LocalKeyIDs for Certificate structures
* using given Hash function type (for PFX processing) (PFX_GenCertsLclKeyID).
*
*  @param pBagStrucArr Array of CertBags
*  @param BagsCnt Number of CertBags
*  @param HashAlgorType Hash to use
*  @return int Status - 0 o.k., else error occured
*/
static  int  PFX_GenCertsLclKeyID(P12BAG ** pBagStrucArr,
                                  int BagsCnt, int HashAlgorType)
{
   int Retcode, Index;

   char* ppTmpBuf[1];
   int pTmpLen[1];

   IDATA* pIdata;
   IDATPARR* pCertDesc;

   P12BAG * pBagStruc;
   //------------------------------------------------------------
   // Check parameters
   //------------------------------------------------------------
   if(pBagStrucArr == NULL)
      return(PKCS12_NULL_PTR);
   if((BagsCnt <= 0) ||
      ((HashAlgorType != PKCS12_SIGNAT_ALGOR_MD2) &&
      (HashAlgorType != PKCS12_SIGNAT_ALGOR_MD5) &&
      (HashAlgorType != PKCS12_SIGNAT_ALGOR_SHA1)))
      return(PKCS12_PARAM_ERR);
   //------------------------------------------------------------
   // Process the CertBags
   //------------------------------------------------------------
   Index = 0;
   while(Index < BagsCnt)
   {
      //----------------------------------------------------------
      // Get Structure from Array, check if really a CertBag Struc
      //----------------------------------------------------------
      if((pBagStruc = pBagStrucArr[Index]) == NULL)
         return(PKCS12_NULL_PTR);
      if(pBagStruc->BagType != PKCS12_CERTBAG_SUBID)
         return(PFX_GEN_CERTNAME_INV_BAGTYPE);
      //-----------------------------------------------------------
      // Get the Certificate Descriptor, get Pointer to DER data
      //-----------------------------------------------------------
      if(((pCertDesc = pBagStruc->pCertDesc) == NULL) ||
         ((pIdata = pCertDesc->ppArr[0]) == NULL) ||
         (pIdata->Base == NULL))
         return(PKCS12_NULL_PTR);
      //-----------------------------------------------------------
      // Generate the local Key ID
      //-----------------------------------------------------------
      if((Retcode = GenCertLclKeyID(pIdata->Base,
         (int) pIdata->Off,
         pIdata->Len,
         HashAlgorType,
         ppTmpBuf, pTmpLen, NULL)) != PKCS12_OP_OK)
         return(Retcode);

      pBagStruc->pLocalKeyID   = ppTmpBuf[0];
      pBagStruc->LocalKeyIDLen = pTmpLen[0];
      pBagStruc->DigestAlgor = HashAlgorType;
      Index++;
   }
   return(PKCS12_OP_OK);
}

/**
* Match Certs with Private Key(s) using the LocalKeyID of both (MatchCertsWithPrivKeys).
* NOTE: The final check is done when the internal CertStructures
* ----- are generated !
*
*  @param pPfxStruc Structure
*  @return int Status - 0 o.k., else error occured
*/
static  int  MatchCertsWithPrivKeys(PK12STRU * pPfxStruc)
{
   int CertIndex, CertsCnt;
   int PrivKeyIndex, PrivKeysCnt;
   int PrivKeyLclIDLen, CertLclIDLen;
   int MatchFlag;

   char* pCertLclIDBuf;
   char* pPrivKeyLclIDBuf;

   P12BAG * pPrivBagStruc;
   P12BAG * pCertBagStruc;
   P12BAG ** pCertBagsArr;
   P12BAG ** pPrivKeyBagsArr;

   pPrivKeyBagsArr = pPfxStruc->pPrivKeyBagsArr;
   PrivKeysCnt     = pPfxStruc->PrivKeysCnt;
   pCertBagsArr    = pPfxStruc->pCertBagsArr;
   CertsCnt        = pPfxStruc->CertsCnt;

   if((PrivKeysCnt <= 0) || (CertsCnt <= 0))
   {
      if(PrivKeysCnt <= 0)
         return(PKCS12_KEYMATCH_NO_PRIVKEYS);
      return(PKCS12_KEYMATCH_NO_CERTS);
   }    

   PrivKeyIndex = 0;
   while(PrivKeysCnt != 0)
   {
      CertIndex = 0;
      MatchFlag = 0;
      pPrivBagStruc = pPrivKeyBagsArr[PrivKeyIndex];
      pPrivKeyLclIDBuf = pPrivBagStruc->pLocalKeyID;
      PrivKeyLclIDLen  = pPrivBagStruc->LocalKeyIDLen;
      if((pPrivKeyLclIDBuf == NULL) || (PrivKeyLclIDLen <= 0))
         return(PKCS12_KEYMATCH_NO_PRIVKEYID);
      //--------------------------------------------------------
      // Scan the Certs for a match, check for duplicate
      //--------------------------------------------------------
      while(CertIndex < CertsCnt)
      {
         pCertBagStruc    = pCertBagsArr[CertIndex];
         pCertLclIDBuf    = pCertBagStruc->pLocalKeyID;
         CertLclIDLen     = pCertBagStruc->LocalKeyIDLen;
         if((CertLclIDLen == PrivKeyLclIDLen) &&
            (CmpBit8Arrays(pCertLclIDBuf,0, pPrivKeyLclIDBuf,0,
            CertLclIDLen) == ASN1_SAME))
         {
            //----------------------------------------------------
            // found a match, do duplicate checks
            //----------------------------------------------------
            if(MatchFlag != 0)		// already had a Match
               return(PKCS12_KEYMATCH_DUPL_CERTS);
            if(pCertBagStruc->AssocPrivKeyBagIndex >= 0)
               return(PKCS12_KEYMATCH_DUPL_PRIVKEYID);
            pCertBagStruc->AssocPrivKeyBagIndex = PrivKeyIndex;
            MatchFlag = 1;
         }
         CertIndex++;
      }
      if(MatchFlag == 0)
         return(PKCS12_KEYMATCH_NO_CERT_FOR_KEY);       
      PrivKeyIndex++;
      PrivKeysCnt--;
   }    
   return(PKCS12_OP_OK);
}        

/**
* Frees a PKCS12 structure, releases all subelements (FreePKCS12Struc).
*
*  @param pPfxStruc Pointer to the structure
*/
extern "C"  void  FreePKCS12Struc(PK12STRU * pPfxStruc)
{
   if(pPfxStruc == NULL)
      return;
   //----------------------------------------------------
   // Clear / Free password buffers
   //----------------------------------------------------
   if(pPfxStruc->pPwd != NULL)
   {
      ClearBit8Array(pPfxStruc->pPwd,
         pPfxStruc->PwdOff,
         pPfxStruc->PwdLen);
      FREE_ARRAY(HMEM_CTX_REF,pPfxStruc->pPwd);
   }
   if(pPfxStruc->pUniPwd != NULL)
   {
      ClearBit8Array(pPfxStruc->pUniPwd,
         pPfxStruc->UniPwdOff,
         pPfxStruc->UniPwdLen);
      FREE_ARRAY(HMEM_CTX_REF,pPfxStruc->pUniPwd);
   }
   //----------------------------------------------------
   // Clear / Free the Private Key bags if in use
   //----------------------------------------------------
   if(pPfxStruc->pPrivKeyBagsArr != NULL)
   {
      FreePKCS12BagStrucArr(pPfxStruc->pPrivKeyBagsArr,
         pPfxStruc->PrivKeysCnt);
      pPfxStruc->pPrivKeyBagsArr = NULL;
   }
   //----------------------------------------------------
   // Free the Cert bags if in use
   //----------------------------------------------------
   if(pPfxStruc->pCertBagsArr != NULL)
   {
      FreePKCS12BagStrucArr(pPfxStruc->pCertBagsArr,
         pPfxStruc->CertsCnt);
      pPfxStruc->pCertBagsArr = NULL;
   }
   FREE_CARRAY(HMEM_CTX_REF,pPfxStruc);
}
/**
* Allocate a PKCS12 structure, initialize it (AllocPKCS12Struc).
*
*               none
*  @return PK12_PTR pStruc / NULL
*/
static  PK12STRU *  AllocPKCS12Struc()
{
   PK12STRU * pPfxStruc;
   pPfxStruc = (PK12STRU*)calloc(1,sizeof(PK12STRU));
   return(pPfxStruc);
}

/**
* Allocate, prepare a PKCS12 Structure for decoding (AllocPrepPKCS12SStruc).
*
*  @param pPwd Password (ASCII)
*  @param PwdOff Start of data
*  @param PwdLen size of data
*  @param Pkcs12Type type to set
*  @param ppPfxStruc returned structure
*  @return int Status - 0 o.k., else error occured
*/
static  int  AllocPrepPKCS12SStruc(char* pPwd, int PwdOff,
                                   int PwdLen, int Pkcs12Type, PK12STRU ** ppPfxStruc)
{
   int Retcode;
   int pTmpLen[1];

   char* pBuf;
   char* ppTmpBuf[1];
   PK12STRU * pPfxStruc;
   //-----------------------------------------------------------------
   // Check parameters
   //-----------------------------------------------------------------
   if((pPwd == NULL) || (ppPfxStruc == NULL))
      return(PKCS12_NULL_PTR);
   if((PwdLen < 0) ||
      ((Pkcs12Type != PKCS12_V1_PDU_TYPE) &&
      (Pkcs12Type != PKCS12_V3_PDU_TYPE)))
      return(PKCS12_PARAM_ERR);
   ppPfxStruc[0] = NULL;  
   //-----------------------------------------------------------------
   // Get a PKCS12 Structure, copy password, generate Unicode password
   //-----------------------------------------------------------------
   if((pPfxStruc = AllocPKCS12Struc()) == NULL)
      return(PKCS12_ALLOC_ERR);
   pPfxStruc->PFXType = Pkcs12Type;

   pPfxStruc->pPwd   = NULL;
   pPfxStruc->PwdOff = 0;
   pPfxStruc->PwdLen = PwdLen;
   pPfxStruc->pUniPwd   = NULL;
   pPfxStruc->UniPwdOff = 0;
   pPfxStruc->UniPwdLen = 0;

   if(PwdLen > 0)
   {
      if((pBuf = BIT8_ARRAY_ALLOC(HMEM_CTX_REF,
         PwdLen)) == NULL)
      {
         FreePKCS12Struc(pPfxStruc);
         return(PKCS12_ALLOC_ERR);
      }
      memcpy(pBuf+0,pPwd+PwdOff,PwdLen);

      pPfxStruc->pPwd   = pBuf;
      //  PK12_PwdOff(pPfxStruc) = 0;
      pPfxStruc->PwdLen = PwdLen;
      if((Retcode = PasswdToUnicode(pPwd, PwdOff, PwdLen,
         ppTmpBuf, pTmpLen)) != PKCS12_OP_OK)
      {
         FreePKCS12Struc(pPfxStruc);
         return(Retcode);
      }    
      pPfxStruc->pUniPwd   = ppTmpBuf[0];
      //  PK12_UniPwdOff(pPfxStruc) = 0;
      pPfxStruc->UniPwdLen = pTmpLen[0];
   }
   ppPfxStruc[0] = pPfxStruc;
   return(PKCS12_OP_OK);
}

/**
* Enlarge/Allocate a BagArray to given amount, keep old entries (EnlargeBagArray).
*
*  @param ppBagsArr Array base, is replaced
*  @param pSlotCnt Number of slots
*  @param EnlargeCnt Number of slots to add
*  @return int Status - 0 o.k., else error occured
*/
static  int  EnlargeBagArray(P12BAG *** ppBagsArr,
                             int* pSlotCnt, int EnlargeCnt)
{
   int ActSlotCnt, NewSlotCnt, Index;
   P12BAG ** pActArr;
   P12BAG ** pNewArr;

   if((ppBagsArr == NULL) || (pSlotCnt == NULL))
      return(PKCS12_NULL_PTR);
   if((EnlargeCnt < 0) || ((ActSlotCnt = pSlotCnt[0]) < 0))
      return(PKCS12_PARAM_ERR);
   //-----------------------------------------------------
   // Calculate new slotcount needed, allocate a new Array
   //-----------------------------------------------------
   pActArr = ppBagsArr[0];
   NewSlotCnt = ActSlotCnt + EnlargeCnt;
   if(NewSlotCnt == ActSlotCnt)
      return(PKCS12_OP_OK);
   pNewArr = (P12BAG **)calloc(1,sizeof(P12BAG *) * NewSlotCnt);
   if(pNewArr == NULL)
      return(PKCS12_ALLOC_ERR);
   //--------------------------------------------------------
   // Copy Contents of Old array to new one, free the old one
   //--------------------------------------------------------
   Index = 0;
   while(Index < ActSlotCnt)
   {
      pNewArr[Index] = pActArr[Index];
      Index++;
   }
   FREE_ARRAY(HMEM_CTX_REF,pActArr);
   ppBagsArr[0] = pNewArr;
   pSlotCnt[0] = NewSlotCnt;
   return(PKCS12_OP_OK);
}

/**
* Add a Bag to specific PFX Structure Bag Array. If array not alloced,
* allocate first (AddBagToPfxBagArray).
*
*  @param pPfxStruc Structure
*  @param pNewBag Bag to add
*  @return int Status - 0 o.k., else error occured
*/
static  int  AddBagToPfxBagArray(PK12STRU * pPfxStruc,
                                 P12BAG * pNewBag)
{
   int Retcode;
   int BagType, BagsCnt;

   int pTmpCnt[1];
   P12BAG ** pBagsArr;
   P12BAG ** ppTmpBagsArr[1];

   if(pNewBag == NULL)
      return(PKCS12_NULL_PTR);
   //-----------------------------------------------------------
   // Get the Bag Array to process
   //-----------------------------------------------------------
   BagType = pNewBag->BagType;
   switch(BagType)
   {
   case PKCS12_KEYBAG_SUBID:
   case PKCS12_PKCS8_SHRBAG_SUBID:
      ppTmpBagsArr[0] = pPfxStruc->pPrivKeyBagsArr;
      pTmpCnt[0]      = pPfxStruc->PrivKeysCnt;
      break;

   case PKCS12_CERTBAG_SUBID:
      ppTmpBagsArr[0] = pPfxStruc->pCertBagsArr;
      pTmpCnt[0]      = pPfxStruc->CertsCnt;
      break;

   default:
      return(PKCS12_PARAM_ERR);
   }
   if((Retcode = EnlargeBagArray(ppTmpBagsArr, pTmpCnt, 1)) != PKCS12_OP_OK)
      return(Retcode);
   pBagsArr = ppTmpBagsArr[0];			// (possibly) new Array
   BagsCnt  = pTmpCnt[0];
   pBagsArr[BagsCnt - 1] = pNewBag; 

   if((BagType == PKCS12_PKCS8_SHRBAG_SUBID) ||
      (BagType == PKCS12_KEYBAG_SUBID))
   {
      pPfxStruc->pPrivKeyBagsArr = pBagsArr;
      pPfxStruc->PrivKeysCnt     = BagsCnt;
   }
   else
   {
      pPfxStruc->pCertBagsArr = pBagsArr;
      pPfxStruc->CertsCnt     = BagsCnt;
   }
   return(PKCS12_OP_OK);
}

/**
* Process a PKCS12 V1 (PFX) PDU to internal structure (PKCS12_V1_Decode).
*
*  @param pBuf Data buffer base
*  @param Offset Start of Data
*  @param DataLen Size of Data
*  @param pPwd Password (ASCII)
*  @param PwdOff Start of data
*  @param PwdLen size of data
*  @param ppPfxStruc filled structure
*  @return int Status - 0 o.k., else error occured
*/
static  int  PKCS12_V1_Decode(char* pBuf, int Offset,
                              int DataLen, char* pPwd, int PwdOff, int PwdLen,
                              PK12STRU ** ppPfxStruc)
{
   int Retcode,BaggageItemsCnt, BagsCnt, DigestAlgor, Index;
   int DecryptBufLen = 0;
   int pTmpLen[1];
   int pTmpRet[1];

   char* pDecryptBuf = NULL;
   char* ppTmpBuf[1];

   P12BAG * pPrivKeyBag = NULL;
   P12BAG * ppTmpBagStruc[1];
   P12BAG ** ppTmpBagsArr[1];

   PK12STRU * pPfxStruc;
   PK12STRU * ppTmpStruc[1];

   IDATA* pIdata;
   IDATA* pSaltIdata;
   IDATA* pHmacVfyDataIdata;
   IDATA* pHmacHashDataIdata;
   IDATA** ppArr;

   IDATPARR* pPfxDesc = NULL;  
   IDATPARR* pAuthSafeDesc = NULL;  
   IDATPARR* pAuthentSafeDesc = NULL;  
   IDATPARR* pBaggageItemsDesc = NULL;  
   IDATPARR* pBagsDesc = NULL;  
   IDATPARR* ppTmpDesc[1];
   //-----------------------------------------------------------------
   // Get a PKCS12 Structure, copy password, generate Unicode password
   //-----------------------------------------------------------------
   if((Retcode = AllocPrepPKCS12SStruc(pPwd, PwdOff, PwdLen,
      PKCS12_V1_PDU_TYPE,
      ppTmpStruc)) != PKCS12_OP_OK)
      return(Retcode);
   pPfxStruc = ppTmpStruc[0];
   for(;;)	// Error FOR
   {
      //-----------------------------------------------------------------
      // Split the V1 PDU
      //-----------------------------------------------------------------
      if((Retcode = FromASN1_PFX_PFX(pBuf, Offset, DataLen,
         ppTmpDesc, pTmpRet)) != PKCS12_OP_OK)
         break;
      pPfxDesc = ppTmpDesc[0];
      //-----------------------------------------------------------------
      // Unwrap the V1 Authenticated Safe from data Contents Octet String
      //-----------------------------------------------------------------
      ppArr  = pPfxDesc->ppArr;
      pIdata = ppArr[PKCS12_PFX_PDU_CONTDATA_INDEX];
      if((Retcode = FromASN1_OCTETSTR(
         pIdata->Base, (int) pIdata->Off,
         pIdata->Len, ppTmpDesc,pTmpRet)) != PKCS12_OP_OK)
         break;
      pAuthSafeDesc = ppTmpDesc[0];
      //-------------------------------------------------------------
      // Verify the HMAC, NOTE: No Iteration Count !
      //-------------------------------------------------------------
      pSaltIdata       =  ppArr[PKCS12_PFX_PDU_MAC_SALT_INDEX];
      pHmacVfyDataIdata = ppArr[PKCS12_PFX_PDU_MAC_DIGEST_INDEX];
      pHmacHashDataIdata = pAuthSafeDesc->ppArr[0];
      if((Retcode = PKCS12GenVfyHMAC_SHA1(
         pPfxStruc->pUniPwd,
         pPfxStruc->UniPwdOff,
         pPfxStruc->UniPwdLen,
         pSaltIdata->Base, (int) pSaltIdata->Off,
         pSaltIdata->Len, 1,
         PKCS12_HASH_TYPE_SHA1,
         PKCS12_HMAC_VFY,1,
         pHmacHashDataIdata->Base,
         (int) pHmacHashDataIdata->Off,
         pHmacHashDataIdata->Len,
         pHmacVfyDataIdata->Base,
         (int) pHmacVfyDataIdata->Off,
         pHmacVfyDataIdata->Len)) != PKCS12_OP_OK)
         break;
      //--------------------------------------------------------------
      // Decode AuthenticatedSafe Contents
      //--------------------------------------------------------------
      ppArr  = pAuthSafeDesc->ppArr;
      pIdata = ppArr[PKCS7_DATA_TYPE_VALUE_INDEX];
      if((Retcode = FromASN1_PFX_AuthSafe(
         pIdata->Base, (int) pIdata->Off,
         pIdata->Len,ppTmpDesc,pTmpRet)) != PKCS12_OP_OK)
         break;
      pAuthentSafeDesc = ppTmpDesc[0];
      //--------------------------------------------------------------
      // Subdecode the BaggageItems
      // NOTE: we only support *ONE* Item (with a private key)
      //--------------------------------------------------------------
      ppArr   = pAuthentSafeDesc->ppArr;
      pIdata  = ppArr[PFX_AUTHSAFE_BAGGAGE_SET_IND];
      if((Retcode = FromASN1_PFXBaggage(pIdata->Base,
         (int) pIdata->Off, pIdata->Len,
         ppTmpDesc, pTmpLen,pTmpRet)) != PKCS12_OP_OK)
         break;
      pBaggageItemsDesc = ppTmpDesc[0];
      BaggageItemsCnt = pTmpLen[0] / 2;
      //    if(BaggageItemsCnt != 1)
      //    {
      if(BaggageItemsCnt <= 0)
      {
         Retcode = PFX_NO_BAGGAGE_ITEMS;
         //      else
         //        Retcode = PFX_TOO_MANY_BAGGAGE_ITEMS;
         break;
      }

      Index = 0;
      while(BaggageItemsCnt != 0)
      {
         //--------------------------------------------------------------
         // Subdecode the BaggageItem's Espvk
         //--------------------------------------------------------------
         if((Retcode = PFX_FromBaggageItem(pBaggageItemsDesc,Index,
            pPfxStruc->pPwd,
            pPfxStruc->PwdOff,
            pPfxStruc->PwdLen,
            ppTmpBagStruc)) != PKCS12_OP_OK)
            break;
         pPrivKeyBag = ppTmpBagStruc[0];
         //--------------------------------------------------------------
         // Add the bag to struture's private key bags array
         //--------------------------------------------------------------
         if((Retcode = AddBagToPfxBagArray(pPfxStruc,
            pPrivKeyBag)) != PKCS12_OP_OK)
            break;
         Index += 2;
         BaggageItemsCnt--;
      }
      //--------------------------------------------------------------
      // Decode safe Contents
      //--------------------------------------------------------------
      if((Retcode = PFX_FromSafeContent(pAuthentSafeDesc,
         pPfxStruc->pUniPwd,
         pPfxStruc->UniPwdOff,
         pPfxStruc->UniPwdLen,
         ppTmpDesc, pTmpRet,
         ppTmpBuf, pTmpLen)) != PKCS12_OP_OK)
         break;

      pBagsDesc     = ppTmpDesc[0];
      BagsCnt       = pTmpRet[0];
      pDecryptBuf   = ppTmpBuf[0];
      DecryptBufLen = pTmpLen[0];
      //--------------------------------------------------------------
      // There should be exactly ONE CertCRL Bag, check that!
      //--------------------------------------------------------------
      if(BagsCnt != 1)
      {
         if(BagsCnt <= 0)
            Retcode = PFX_NO_BAGS;
         else
            Retcode = PFX_TOO_MANY_BAGS;
         break;
      }
      //--------------------------------------------------------------
      // Decode the CertCRL Bag, store the CertBags Array
      //--------------------------------------------------------------
      if((Retcode = PFX_FromSafebag(pBagsDesc->ppArr, 0,
         ppTmpBagsArr, pTmpLen)) != PKCS12_OP_OK)
         break;
      pPfxStruc->pCertBagsArr = ppTmpBagsArr[0];
      pPfxStruc->CertsCnt = pTmpLen[0];
      //--------------------------------------------------------------
      // Generate pseudo LocalKeyIDs from the hashes
      //--------------------------------------------------------------
      DigestAlgor = pPrivKeyBag->DigestAlgor;

      if((Retcode = PFX_GenCertsLclKeyID(pPfxStruc->pCertBagsArr,
         pPfxStruc->CertsCnt,
         DigestAlgor)) != PKCS12_OP_OK)
         break;
      //------------------------------------------------------------
      // Match Keys and Certs now, only if private key(s) present
      //------------------------------------------------------------
      if(pPfxStruc->PrivKeysCnt > 0)
         Retcode = MatchCertsWithPrivKeys(pPfxStruc);
      break;
   }
   //--------------------------------------------------------
   // Free temporary used elements
   //--------------------------------------------------------
   FreeIDATPARR_Struc(HMEM_CTX_REF1 pPfxDesc);
   FreeIDATPARR_Struc(HMEM_CTX_REF1 pAuthSafeDesc);
   FreeIDATPARR_Struc(HMEM_CTX_REF1 pAuthentSafeDesc);
   FreeIDATPARR_Struc(HMEM_CTX_REF1 pBaggageItemsDesc);
   FreeIDATPARR_Struc(HMEM_CTX_REF1 pBagsDesc);
   if(pDecryptBuf != NULL)
   {
      ClearBit8Array(pDecryptBuf, 0, DecryptBufLen);
      FREE_CARRAY(HMEM_CTX_REF,pDecryptBuf);
   }
   if(Retcode != PKCS12_OP_OK)
   {
      FreePKCS12Struc(pPfxStruc);
      return(Retcode);
   }
   ppPfxStruc[0] = pPfxStruc;
   return(PKCS12_OP_OK);
}

/**
* Process Collection of Safebags from a PKCS12 V3 Content Info (FromPkcs12Bags).
*
*  @param pPfxStruc Structure
*  @param pBagsDesc Descriptor
*  @param BagsCnt Number of bags
*  @return int Status - 0 o.k., else error occured
*/
static  int  FromPkcs12Bags(PK12STRU * pPfxStruc,
                            IDATPARR* pBagsDesc, int BagsCnt)
{
   int Retcode = 0;
   int ActBagIndex;
   int BagID;

   IDATA** ppArr;
   P12BAG * pBagStruc = NULL;
   P12BAG * ppTmpBagStruc[1];

   ppArr  = pBagsDesc->ppArr;			// Bag(s) Array
   ActBagIndex = 0;
   while(BagsCnt != 0)
   {
      //---------------------------------------------------
      // Process a Bag, convert to Structure
      //---------------------------------------------------
      if((Retcode = PKCS12_FromSafebag(ppArr,ActBagIndex,
         pPfxStruc->pUniPwd,
         pPfxStruc->UniPwdOff,
         pPfxStruc->UniPwdLen,
         ppTmpBagStruc)) != PKCS12_OP_OK)
         break;
      pBagStruc = ppTmpBagStruc[0];
      BagID = pBagStruc->BagType;
      //---------------------------------------------------
      // Add the Bag to the appropriate BagArray
      //---------------------------------------------------
      switch(BagID)
      {
      case PKCS12_KEYBAG_SUBID:
      case PKCS12_PKCS8_SHRBAG_SUBID:
      case PKCS12_CERTBAG_SUBID:
         if((Retcode = AddBagToPfxBagArray(pPfxStruc,
            pBagStruc)) != PKCS12_OP_OK)
            break;
         pBagStruc = NULL;			// avoid freeing
         break;
         //----------------------------------------------------------
         // Unsupported SafeBag types
         //----------------------------------------------------------
      case PKCS12_CRLBAG_SUBID:
      case PKCS12_SECRBAG_SUBID:
      case PKCS12_SAFECONTBAG_SUBID:
      default:
         Retcode = PKCS12_UNSUPP_SAFEBAG_TYPE;
         break;
      }
      if(Retcode != PKCS12_OP_OK)
         break;
      ActBagIndex += PKCS12_SAFEBAG_MAX_DATA_INDEX;
      BagsCnt--;
   }
   //---------------------------------------------------------
   // Free Temporary Elements
   //---------------------------------------------------------
   FreePKCS12BagStruc(pBagStruc);
   return(Retcode);
}

/**
* Process a PKCS12 V3 PDU to internal structure (PKCS12_V3_Decode).
*
*  @param pBuf Data buffer base
*  @param Offset Start of Data
*  @param DataLen Size of Data
*  @param pPwd Password (ASCII)
*  @param PwdOff Start of data
*  @param PwdLen size of data
*  @param ppPfxStruc filled structure
*  @return int Status - 0 o.k., else error occured
*/
static  int  PKCS12_V3_Decode(char* pBuf, int Offset,
                              int DataLen, char* pPwd, int PwdOff, int PwdLen,
                              PK12STRU ** ppPfxStruc)
{
   int Retcode, BagsCnt;
   int IteratCnt, SafeContentsCnt;
   int ActContentIndex;
   int DecryptBufLen = 0;
   int pTmpLen[1];
   int pTmpRet[1];
   int pTmpLong[1];

   char* pDecryptBuf = NULL;
   char* ppTmpBuf[1];

   PK12STRU * pPfxStruc;
   PK12STRU * ppTmpStruc[1];

   IDATA* pIdata;
   IDATA* pSaltIdata;
   IDATA* pHmacVfyDataIdata;
   IDATA* pHmacHashDataIdata;
   IDATA** ppArr;
   IDATA** ppContentsArr;

   IDATPARR* pPfxDesc = NULL;  
   IDATPARR* pAuthSafeDesc = NULL;  
   IDATPARR* pSafeContentsDesc = NULL;  
   IDATPARR* pBagsDesc = NULL;  
   IDATPARR* ppTmpDesc[1];
   //-----------------------------------------------------------------
   // Get a PKCS12 Structure, copy password, generate Unicode password
   //-----------------------------------------------------------------
   if((Retcode = AllocPrepPKCS12SStruc(pPwd, PwdOff, PwdLen,
      PKCS12_V3_PDU_TYPE,
      ppTmpStruc)) != PKCS12_OP_OK)
      return(Retcode);
   pPfxStruc = ppTmpStruc[0];
   for(;;)	// Error FOR
   {
      //-----------------------------------------------------------------
      // Split the V3 PDU
      //-----------------------------------------------------------------
      if((Retcode = FromASN1_PFX_PDU(pBuf, Offset, DataLen,
         ppTmpDesc, pTmpRet)) != PKCS12_OP_OK)
         break;
      pPfxDesc = ppTmpDesc[0];
      //--------------------------------------------------------------
      // Unwrap the Authenticated Safe from data Contents Octet String
      // NOTE: Netscape uses constructed OCTETSTRINGS !!
      // -----  --> Use BER decoding mode !
      //--------------------------------------------------------------
      ppArr  = pPfxDesc->ppArr;
      pIdata = ppArr[PKCS12_PFX_PDU_CONTDATA_INDEX];
      if((Retcode = FromASN1_BER_OCTETSTR(
         pIdata->Base, (int) pIdata->Off,
         pIdata->Len, ppTmpDesc,pTmpRet)) != PKCS12_OP_OK)
         break;
      pAuthSafeDesc = ppTmpDesc[0];
      //-------------------------------------------------------------
      // Verify the HMAC
      //-------------------------------------------------------------
      IteratCnt = 1;
      pIdata = pPfxDesc->ppArr[PKCS12_PFX_PDU_MAC_ITERAT_INDEX];
      if((pIdata != NULL) && (pIdata->Base != NULL))
      {
         if((Retcode = ByteBufToUnsignedBIT32Num(pIdata->Base,(int) pIdata->Off,pIdata->Len,pTmpLong)) != ASN1_OP_OK)
            break;
         IteratCnt = (int) pTmpLong[0];
      }
      pSaltIdata       =  ppArr[PKCS12_PFX_PDU_MAC_SALT_INDEX];
      pHmacVfyDataIdata = ppArr[PKCS12_PFX_PDU_MAC_DIGEST_INDEX];
      pHmacHashDataIdata = pAuthSafeDesc->ppArr[0];
      if((Retcode = PKCS12GenVfyHMAC_SHA1(
         pPfxStruc->pUniPwd,
         pPfxStruc->UniPwdOff,
         pPfxStruc->UniPwdLen,
         pSaltIdata->Base, (int) pSaltIdata->Off,
         pSaltIdata->Len, IteratCnt,
         PKCS12_HASH_TYPE_SHA1,
         PKCS12_HMAC_VFY,0,
         pHmacHashDataIdata->Base,
         (int) pHmacHashDataIdata->Off,
         pHmacHashDataIdata->Len,
         pHmacVfyDataIdata->Base,
         (int) pHmacVfyDataIdata->Off,
         pHmacVfyDataIdata->Len)) != PKCS12_OP_OK)
         break;
      //--------------------------------------------------------------
      // Decode AuthenticatedSafe to Contents
      //--------------------------------------------------------------
      ppArr  = pAuthSafeDesc->ppArr;
      pIdata = ppArr[PKCS7_DATA_TYPE_VALUE_INDEX];
      if((Retcode = FromASN1_PKCS12AuthentSafe(
         pIdata->Base, (int) pIdata->Off,
         pIdata->Len,
         ppTmpDesc,pTmpLen,pTmpRet)) != PKCS12_OP_OK)
         break;
      pSafeContentsDesc = ppTmpDesc[0];
      SafeContentsCnt   = pTmpLen[0] / PKCS7_CONTINFO_MAX_DATA_INDEX;
      if(SafeContentsCnt <= 0)
      {
         Retcode = PKCS12_NO_SAFE_CONTENT_ITEMS;
         break;
      }
      //--------------------------------------------------------------
      // Process all Contents
      //--------------------------------------------------------------
      ppContentsArr = pSafeContentsDesc->ppArr;
      ActContentIndex = 0;
      while(SafeContentsCnt != 0)
      {
         //------------------------------------------------------------
         // Decode Actual ContentItem to SafeBags
         //------------------------------------------------------------
         if((Retcode =  PKCS12_FromContentInfo(
            ppContentsArr[ActContentIndex + PKCS7_CONTINFO_TYPE_INDEX],
            ppContentsArr[ActContentIndex + PKCS7_CONTINFO_DATA_INDEX],
            pPfxStruc->pUniPwd,
            pPfxStruc->UniPwdOff,
            pPfxStruc->UniPwdLen,
            ppTmpDesc, pTmpRet, ppTmpBuf, pTmpLen)) != PKCS12_OP_OK)
            break;
         pBagsDesc     = ppTmpDesc[0];
         BagsCnt       = pTmpRet[0];
         pDecryptBuf   = ppTmpBuf[0];
         DecryptBufLen = pTmpLen[0];
         //----------------------------------------------------------
         // Process the Safe bags from this ContentItem
         //----------------------------------------------------------
         if((Retcode = FromPkcs12Bags(pPfxStruc,
            pBagsDesc, BagsCnt)) != PKCS12_OP_OK)
            break;
         //----------------------------------------------------------
         // Clear / Free temporary used elements
         //----------------------------------------------------------
         if(pDecryptBuf != NULL)
         {
            ClearBit8Array(pDecryptBuf,0,DecryptBufLen);
            FREE_ARRAY(HMEM_CTX_REF,pDecryptBuf);
         }
         FreeIDATPARR_Struc(HMEM_CTX_REF1 pBagsDesc);
         pBagsDesc = NULL;

         ActContentIndex += PKCS7_CONTINFO_MAX_DATA_INDEX;
         SafeContentsCnt--;
      }
      if(Retcode != PKCS12_OP_OK)
         break;
      //------------------------------------------------------------
      // Match Keys and Certs now
      //------------------------------------------------------------
      if(pPfxStruc->PrivKeysCnt > 0)
         Retcode = MatchCertsWithPrivKeys(pPfxStruc);
      break;
   }
   //--------------------------------------------------------
   // Free temporary used elements
   //--------------------------------------------------------
   FreeIDATPARR_Struc(HMEM_CTX_REF1 pPfxDesc);
   FreeIDATPARR_Struc(HMEM_CTX_REF1 pAuthSafeDesc);
   FreeIDATPARR_Struc(HMEM_CTX_REF1 pSafeContentsDesc);
   FreeIDATPARR_Struc(HMEM_CTX_REF1 pBagsDesc);
   if(pDecryptBuf != NULL)
   {
      ClearBit8Array(pDecryptBuf, 0, DecryptBufLen);
      FREE_CARRAY(HMEM_CTX_REF,pDecryptBuf);
   }
   if(Retcode != PKCS12_OP_OK)
   {
      FreePKCS12Struc(pPfxStruc);
      return(Retcode);
   }
   ppPfxStruc[0] = pPfxStruc;
   return(PKCS12_OP_OK);
}

/**
* Subroutine VerifyPrivKey verifies usability of a certificate's private key (VerifyPrivKey).
* RSA: - Public encrypt Testdata
*      - Private decrypt encrypted data
*	- Compare result
* DSS: - Generate Testdata signature with private key
*	- Verify Signature with public key
*
*  @param pCert Certificate structure
*  @return int Status - 0 o.k., else error occured
*/
static  int  VerifyPrivKey(X509CERT * pCert)
{
   int Retcode;
   int BufLen = 0;
   int PrivKeyAlgor, EncSignatLen;

   char* pBuf = NULL;

   int pTmpLen[1];

#define TEST_DATA_LEN	4
   char TestData[TEST_DATA_LEN] =
   {(unsigned char) 'T', (unsigned char) 'e', (unsigned char) 's', (unsigned char) 't'};

   RSA_STRUC* ppTmpRsa[1];
   DSA_STRUC* ppTmpDsa[1];
   //------------------------------------------------------------
   // Check parameters
   //------------------------------------------------------------
   if(pCert == NULL)
      return(PKCS12_NULL_PTR);

   PrivKeyAlgor = pCert->PrivKeyType;
   if((PrivKeyAlgor != RSA_PUBLIC_ALGOR) &&
      (PrivKeyAlgor != DSA_PUBLIC_ALGOR))
      return(PKCS12_INVALID_PRIVKEY_ALGOR);

   ppTmpRsa[0] = NULL;
   ppTmpDsa[0] = NULL;

   for(;;)			// Error FOR
   {
      //-----------------------------------------------------------
      // Distribute by private key algor 
      //-----------------------------------------------------------
      if(PrivKeyAlgor == RSA_PUBLIC_ALGOR)
      {
         //---------------------------------------------------------
         // Get the RSA public key from certificate structure
         //---------------------------------------------------------
         if((Retcode = FromArrayDescToRSAPubParams(HMEM_CTX_REF1 pCert->SubjPubKeyParVal,ppTmpRsa)) != RSA_OP_OK)
            break;
         //---------------------------------------------------------
         // Get size of buffer needed for encrypt
         //---------------------------------------------------------
         if((BufLen = RSA_Size(ppTmpRsa[0])) == 0)
         {
            Retcode = PKCS12_RSA_VFY_INV_BUFLEN;
            break;
         }
         BufLen++;					// for leading zero
         if((pBuf = BIT8_ARRAY_ALLOC(HMEM_CTX_REF,BufLen)) == NULL)
         {
            Retcode = PKCS12_ALLOC_ERR;
            break;
         }
         //----------------------------------------------------------
         // Public Encrypt testdata with RSA Key,
         //----------------------------------------------------------
         pTmpLen[0] = BufLen;
         if((Retcode = RSA_PublicEncrypt(HMEM_CTX_REF1 TestData,0,TEST_DATA_LEN,pBuf,0,pTmpLen,ppTmpRsa[0],0)) != RSA_OP_OK)
            break;
         RSA_Free(HMEM_CTX_REF1 ppTmpRsa[0]);
         ppTmpRsa[0] = NULL;			// avoid freeing
         EncSignatLen = pTmpLen[0];
         //---------------------------------------------------------
         // Get the RSA private key from certificate structure
         //---------------------------------------------------------
         if((Retcode = FromArrayDescToRSAPrivParams(HMEM_CTX_REF1 pCert->PrivKeyData,ppTmpRsa)) != RSA_OP_OK)
            break;
         //----------------------------------------------------------
         // Private Decrypt encrypted testdata with RSA Key
         //----------------------------------------------------------
         pTmpLen[0] = BufLen;
         if((Retcode = RSA_PrivateDecrypt(HMEM_CTX_REF1 pBuf,0,EncSignatLen,pBuf,pTmpLen,ppTmpRsa[0])) != RSA_OP_OK)
            break;
         //----------------------------------------------------------
         // Compare Decrypted data with original data
         //----------------------------------------------------------
         if((pTmpLen[0] != TEST_DATA_LEN) ||
            (CmpBit8Arrays(TestData, 0, pBuf, 0, 
            TEST_DATA_LEN) != ASN1_SAME))

            Retcode = PKCS12_RSA_VFY_FAIL;
      }
      else					// DSA
      {
         //---------------------------------------------------------
         // Get the DSA private key from certificate structure
         //---------------------------------------------------------
         if((Retcode = FromArrayDescToDSAPrivParams(HMEM_CTX_REF1 pCert->PrivKeyData,ppTmpDsa)) != DSA_OP_OK)
            break;
         //---------------------------------------------------------
         // Get buffersize needed for the signature, allocate buffer
         //---------------------------------------------------------
         if((BufLen = DSA_SignatMaxLen(ppTmpDsa[0])) == 0)
         {
            Retcode = PKCS12_DSA_VFY_INV_BUFLEN;
            break;
         }
         if((pBuf = BIT8_ARRAY_ALLOC(HMEM_CTX_REF,BufLen)) == NULL)
         {
            Retcode = PKCS12_ALLOC_ERR;
            break;
         }
         //---------------------------------------------------------
         // Generate Signature of Testdata with the private key
         //---------------------------------------------------------
         pTmpLen[0] = BufLen;
         if((Retcode = DSA_Sign(HMEM_CTX_REF1 TestData,0,TEST_DATA_LEN,pBuf,0,pTmpLen,ppTmpDsa[0],NULL,0)) != DSA_OP_OK)
            break;
         DSA_Free(HMEM_CTX_REF1 ppTmpDsa[0]);
         ppTmpDsa[0] = NULL;			// avoid freeing
         EncSignatLen = pTmpLen[0];
         //---------------------------------------------------------
         // Get the DSA public key from certificate structure
         //---------------------------------------------------------
         if((Retcode = FromArrayDescToDSAPubParams(HMEM_CTX_REF1 pCert->SubjPubKeyParVal,ppTmpDsa)) != DSA_OP_OK)
            break;
         //---------------------------------------------------------
         // Verify Signature of Testdata with the public key
         //---------------------------------------------------------
         Retcode = DSA_Verify(HMEM_CTX_REF1 TestData,0,TEST_DATA_LEN,pBuf,0,pTmpLen[0],ppTmpDsa[0],0);
      }
      break;
   }
   //-------------------------------------------------------
   // Free temporary elements
   //-------------------------------------------------------
   if(pBuf != NULL)
   {
      ClearBit8Array(pBuf, 0, BufLen);
      FREE_CARRAY(HMEM_CTX_REF,pBuf);
   }
   RSA_Free(HMEM_CTX_REF1 ppTmpRsa[0]);
   DSA_Free(HMEM_CTX_REF1 ppTmpDsa[0]);
   return(Retcode);
}

/**
* Put Private Key Parameters to Certificate, check if the
* Public parameters match (PKCS12_ChkInsertCertPrivParams). 
* If DSA, extract the Public Value Y
* from the Certificate and copy to the Private Parameters.
* NOTE: The Private Parameters are a local copy and will be
* ----- moved from the Bag to the Certificate !
*
* TO DO: PERFORM ARITHMETIC CHECKS ON THE PRIVATE KEY
* ------ to avoid unusable private key !
*
*  @param pCert Certificate to process
*  @param pPrivKeyBag Private Key Bag
*  @return int Status 0 - o.k., else error occured
*/
static  int  PKCS12_ChkInsertCertPrivParams(X509CERT * pCert,
                                            P12BAG * pPrivKeyBag)
{
   int Retcode;
   int PrivKeyAlgor;

   IDATA** pCertPubParamArr;
   IDATA** pKeyPrivParamArr;

   PrivKeyAlgor = pPrivKeyBag->PrivKeyType;
   if(pCert->PublicKeyType != PrivKeyAlgor)
      return(PKCS12_TOCERT_PRIV_ALG_MISMATCH);

   if(pPrivKeyBag->pPrivKeyDesc == NULL)
      return(PKCS12_TOCERT_NO_PRIV_PARAMS);  

   pCertPubParamArr = pCert->SubjPubKeyParVal->ppArr;
   pKeyPrivParamArr = pPrivKeyBag->pPrivKeyDesc->ppArr;

   switch(PrivKeyAlgor)
   {
      //---------------------------------------------------------
      // RSA, Compare Modulus n and public exponent e
      //---------------------------------------------------------
   case RSA_PUBLIC_ALGOR:
      if(MatchDatArrays(pCertPubParamArr,
         RSA_ALG_PAR_MAX_INDEX+RSA_PUB_VAL_MOD_INDEX,
         pKeyPrivParamArr,
         PKCS1_PRIVKEY_MODUL_INDEX,
         2) != ASN1_SAME)
         return(PKCS12_TOCERT_PUB_PAR_MISMATCH);
      break;
      //---------------------------------------------------------
      // DSA, Compare Modulus p, Divisor q and Generator g
      //---------------------------------------------------------
   case DSA_PUBLIC_ALGOR:
      if(MatchDatArrays(pCertPubParamArr,DSA_ALG_PAR_P_INDEX,
         pKeyPrivParamArr,X957_PRIVKEY_MODUL_P_INDEX,
         3) != ASN1_SAME)
         return(PKCS12_TOCERT_PUB_PAR_MISMATCH);
      //------------------------------------------------------------
      // Copy the Public Value Y from Certificate to the Private Key
      //------------------------------------------------------------
      if((Retcode = AllocCopyDatArrayElements(HMEM_CTX_REF1 pCertPubParamArr,DSA_ALG_PAR_MAX_INDEX+DSA_PUB_VAL_Y_INDEX,pKeyPrivParamArr,X957_PRIVKEY_PUB_Y_INDEX,1,1)) != ASN1_OP_OK)
         return(Retcode);
      break;

   default:
      return(PKCS12_TOCERT_UNSUPP_PRIV_ALGOR);
   }
   //-----------------------------------------------------------
   // move private parameters to the Certificate structure
   // NOTE: !!!!! CHECK THAT !!! --> must Descriptor be freed first ???
   //-----------------------------------------------------------
   pCert->PrivKeyData = pPrivKeyBag->pPrivKeyDesc;
   pPrivKeyBag->pPrivKeyDesc = NULL;
   pCert->PrivKeyType = PrivKeyAlgor;
   pCert->Flags |= PRIV_KEY_MASK;
   //-----------------------------------------------------------
   // Verify the Certificate's private key now...
   //-----------------------------------------------------------
   Retcode = VerifyPrivKey(pCert);
   return(Retcode);
}

/**
* Generate CertList with inserted Private Key(s) (PKCS12_GenCertList).
*
*  @param pPfxStruc Structure to process
*  @param ppCertList Filled List
*  @param pCertsCnt number of Certs
*  @return int Status 0 - o.k., else error occured
*/
static  int  PKCS12_GenCertList(PK12STRU * pPfxStruc,
                                X509CERT *** ppCertList, int* pCertsCnt)
{
   int Retcode = 0;
   int CertsCnt;
   int CertIndex, PrivBagIndex;

   X509CERT * pActCert;
   X509CERT ** pCertList;
   X509CERT * ppTmpCert[1];

   P12BAG * pActCertBag;
   P12BAG * pActPrivBag;
   P12BAG ** pCertBagsArr;
   P12BAG ** pPrivKeyBagsArr;

   IDATA* pIdata;
   IDATPARR* pCertDesc;

   ppCertList[0] = NULL;
   pCertsCnt[0] = 0;

   //------------------------------------------------------
   // Get Number of Certificates to Process, allocate List
   //------------------------------------------------------
   if((CertsCnt = pPfxStruc->CertsCnt) <= 0)
      return(PKCS12_TO_CERTLIST_NO_CERTS);
   pCertList = (X509CERT **)calloc(1,CertsCnt * sizeof(X509CERT *));
   if(pCertList == NULL)
      return(PKCS12_ALLOC_ERR);
   //------------------------------------------------------
   // Process the Certificates
   //------------------------------------------------------
   pCertBagsArr    = pPfxStruc->pCertBagsArr;
   pPrivKeyBagsArr = pPfxStruc->pPrivKeyBagsArr;

   CertIndex = 0;
   while(CertIndex < CertsCnt)
   {
      //------------------------------------------------------------
      // Generate the Certificate in Internal notation from DER data,
      // (dont sort AVA's), process and check extensions
      //------------------------------------------------------------
      pActCertBag = pCertBagsArr[CertIndex];
      pCertDesc   = pActCertBag->pCertDesc;
      pIdata      = pCertDesc->ppArr[0];

      if((Retcode = FromASN1CertToCertStrucEX(HMEM_CTX_REF1 pIdata->Base,(int) pIdata->Off,pIdata->Len,0,0x03,NULL,0,ppTmpCert)) != ASN1_OP_OK)
         break;
      pActCert = ppTmpCert[0];
      pCertList[CertIndex] = pActCert;
      //------------------------------------------------------------
      // Check if Private Key Data have to be inserted
      //------------------------------------------------------------
      if((PrivBagIndex = pActCertBag->AssocPrivKeyBagIndex) >= 0)
      {
         //----------------------------------------------------------
         // Private Key is present, do sanity check, insert data
         //----------------------------------------------------------
         if((pActPrivBag = pPrivKeyBagsArr[PrivBagIndex]) == NULL)
         {
            Retcode = PKCS12_TO_CERTLIST_NO_PRIVKEY;
            break;
         }
         if((Retcode = PKCS12_ChkInsertCertPrivParams(pActCert,
            pActPrivBag)) != PKCS12_OP_OK)
            break;
         //----------------------------------------------------------
         // Set Private Key usage if present
         //----------------------------------------------------------
         if(pActPrivBag->PrivKeyUsageValid != 0)
         {
            pActCert->PrivKeyUsageFlags =
               pActPrivBag->PrivKeyUsage | X509_KEYUSAGE_VALID_BIT;
         }        
      }
      CertIndex++;
   }
   if(Retcode != PKCS12_OP_OK)
   {
      FreeCertList(HMEM_CTX_REF1 pCertList,CertsCnt);
      return(Retcode);
   }
   ppCertList[0] = pCertList;
   pCertsCnt[0]  = CertsCnt;
   return(PKCS12_OP_OK);
}

extern "C"  int  PKCS12_CheckDecodeFormat(char* pBuf, int Offset,
                                          int DataLen, char* pPwd, int PwdOff, int PwdLen,
                                          int* pPkcs12Type, PK12STRU ** ppPfxStruc,
                                          X509CERT *** ppCertList, int* pCertsCnt)
{
   int Retcode;
   int PKCS12Type = PKCS12_UNKNOWN_PDU_TYPE;

   char DummyPwdBuf[1];
   int pTmpRet[1];
   IDATPARR* pPFXDesc = NULL;
   IDATPARR* ppTmpDesc[1];

   PK12STRU * ppTmpPfxStruc[1];
   //------------------------------------------------------------
   // Check parameters first
   //------------------------------------------------------------
   if(pBuf == NULL)
      return(PKCS12_NULL_PTR);
   //------------------------------------------------------------
   // Process the ASN.1 PDU if possible
   //------------------------------------------------------------
   for(;;)				// Error FOR
   {
      //------------------------------------------------------------
      // Try to split as a PKCS12 V3 PDU first
      // NOTE: also capable of @!?'@ Netscape's ASN.1 BER format !
      //------------------------------------------------------------
      if(FromASN1_PFX_PDU(pBuf, Offset, DataLen,
         ppTmpDesc, pTmpRet) == PKCS12_OP_OK)
      {
         pPFXDesc = ppTmpDesc[0];
         PKCS12Type = PKCS12_V3_PDU_TYPE; 
         break;
      }
      //------------------------------------------------------------
      // Try to split as a PKCS12 V1 PDU next
      //------------------------------------------------------------
      if(FromASN1_PFX_PFX(pBuf, Offset, DataLen,
         ppTmpDesc, pTmpRet) == PKCS12_OP_OK)
      {
         pPFXDesc = ppTmpDesc[0];
         PKCS12Type = PKCS12_V1_PDU_TYPE; 
         break;
      }
      break;
   }
   FreeIDATPARR_Struc(HMEM_CTX_REF1 pPFXDesc);
   if(pPkcs12Type != NULL)
      pPkcs12Type[0] = PKCS12Type;
   //--------------------------------------------------------------
   // Check if a Password is given, and type was recognized
   //--------------------------------------------------------------
   //  if((pPwd == NULL) || (PwdLen <= 0))
   //    return(PKCS12_OP_OK);
   if((PwdLen < 0) ||				// check mode, no valid passwd
      (pPwd == NULL))				// no buffer
      return(PKCS12_OP_OK);
   if(PKCS12Type == PKCS12_UNKNOWN_PDU_TYPE)
      return(PKCS12_UNRECOGNIZED_PDU_ERR);
   //--------------------------------------------------------------
   // Decode the PDU now 
   //--------------------------------------------------------------
   if(PKCS12Type == PKCS12_V1_PDU_TYPE)
   {
      Retcode = PKCS12_V1_Decode(pBuf, Offset, DataLen,
         pPwd,PwdOff,PwdLen, ppTmpPfxStruc);
   }
   else
   {
      Retcode = PKCS12_V3_Decode(pBuf, Offset, DataLen,
         pPwd,PwdOff,PwdLen, ppTmpPfxStruc);
   }
   if(Retcode != PKCS12_OP_OK)
   {
      //------------------------------------------------------------
      // Check for 'empty password' / MAC verify failure
      //------------------------------------------------------------
      if((Retcode != PKCS12_HMAC_VFY_FAILED) || (PwdLen != 0))
         return(Retcode);
      //------------------------------------------------------------
      // Try alternate 'empty' (0x00) password
      //------------------------------------------------------------
      DummyPwdBuf[0] = 0;

      if(PKCS12Type == PKCS12_V1_PDU_TYPE)
      {
         Retcode = PKCS12_V1_Decode(pBuf, Offset, DataLen,
            DummyPwdBuf,0,1, ppTmpPfxStruc);
      }
      else
      {
         Retcode = PKCS12_V3_Decode(pBuf, Offset, DataLen,
            DummyPwdBuf,0,1, ppTmpPfxStruc);
      }
      if(Retcode != PKCS12_OP_OK)
         return(Retcode);
   }
   //--------------------------------------------------------------
   // Check if Structure shall be reported
   //--------------------------------------------------------------
   if(ppPfxStruc != NULL)
      ppPfxStruc[0] = ppTmpPfxStruc[0];
   //--------------------------------------------------------------
   // Check if a CertList is given
   //--------------------------------------------------------------
   if((ppCertList == NULL) || (pCertsCnt == NULL))
      return(PKCS12_OP_OK);
   //--------------------------------------------------------------
   // Convert to internal Cert List
   //--------------------------------------------------------------
   Retcode = PKCS12_GenCertList(ppTmpPfxStruc[0], ppCertList, pCertsCnt);
   if(ppPfxStruc == NULL)
      FreePKCS12Struc(ppTmpPfxStruc[0]);
   return(Retcode);
}
//###############################################################
//
// Assembling routines
//
//###############################################################

/**
* Check if an IDATA Element is Present, buffer given and not empty (CheckGetIdataElementSize).
*
*  @param pIdata Element to check
*  @return int Status - == 0 is not present / Empty
* <br>            > 0 Number of bytes in Element
*/
static  int  CheckGetIdataElementSize(IDATA* pIdata)
{
   if((pIdata == NULL) || (pIdata->Base == NULL) ||
      (pIdata->Len <= 0))
      return(0);
   return(pIdata->Len);
}
/**
* Check if an Internal String Element is present and not empty (GetStringElementContentsSize).
*
*  @param pIdata Element to check
*  @return int Status - == 0 is not present / Empty,
* <br>            > 0 Number of BYTES present (excl. Header)
*/
static  int  GetStringElementContentsSize(IDATA* pIdata)
{
   int TotalLen, Off;
   int ElementCnt;
   char* pBuf;

   if((TotalLen = CheckGetIdataElementSize(pIdata)) <= 0)
      return(0);
   pBuf = pIdata->Base;
   Off  = (int) pIdata->Off;
   BIGchar2word(pBuf,ElementCnt,Off);
   return((int) (ElementCnt * 2));
}

/**
* Generate a 'FriendlyName' from a given DN as BMPString
* contents (GenDNFriendlyName).
* The DN is converted to an array of internal Strings
* and then the components are checked if a usable Element is
* found. Order of check is the following:
* - CommonName (CN)
* - EmailAddress
* - OrgaizationName (ON)
* - OrganizationUnitName (OU)
* - Name
* - SurName
*
*  @param pDNDesc DN Description
*  @param ppFriendlyName Allocated Name buffer
*  @param pFriendlyNameLen Size of Buffer (bytes)
*  @return int Status - 0 o.k., else error occured
*/
static  int  GenDNFriendlyName(X501_DN* pDNDesc,
                               char** ppFriendlyName, int* pFriendlyNameLen)
{
   int Retcode;
   int SrcLen;
   char* pBuf = NULL;

   IDATA* pIdata;
   IDATA** ppArr;
   IDATPARR* pStringsDesc;
   IDATPARR* ppTmpDesc[1];

   if((pDNDesc == NULL) || (ppFriendlyName == NULL) ||
      (pFriendlyNameLen == NULL))
      return(PKCS12_NULL_PTR);

   ppFriendlyName[0]   = NULL;
   pFriendlyNameLen[0] = 0;  
   //--------------------------------------------------------
   // Decode the DN to internal Strings
   //--------------------------------------------------------
   if((Retcode = FromASN1_DN_ToStringArray(HMEM_CTX_REF1 pDNDesc,ppTmpDesc)) != ASN1_OP_OK)
      return(Retcode);
   pStringsDesc = ppTmpDesc[0];
   //--------------------------------------------------------
   // Find Suitable Element to use
   //--------------------------------------------------------
   ppArr = pStringsDesc->ppArr;
   SrcLen = 0;
   for(;;)
   {
      pIdata = ppArr[RDN_COMMON_NAME_INDEX];
      if((SrcLen = GetStringElementContentsSize(pIdata)) > 0)
         break;

      pIdata = ppArr[RDN_PKCS9_EMAIL_ADDRESS_INDEX];
      if((SrcLen = GetStringElementContentsSize(pIdata)) > 0)
         break;

      pIdata = ppArr[RDN_ORGANIZATION_NAME_INDEX];
      if((SrcLen = GetStringElementContentsSize(pIdata)) > 0)
         break;

      pIdata = ppArr[RDN_ORGANIZATION_UNIT_INDEX];
      if((SrcLen = GetStringElementContentsSize(pIdata)) > 0)
         break;

      pIdata = ppArr[RDN_NAME_INDEX];
      if((SrcLen = GetStringElementContentsSize(pIdata)) > 0)
         break;

      pIdata = ppArr[RDN_SURNAME_INDEX];
      if((SrcLen = GetStringElementContentsSize(pIdata)) > 0)
         break;

      pIdata = NULL;
      break;
   }
   //---------------------------------------------------------
   // Check if any usable data found
   //---------------------------------------------------------
   Retcode = PKCS12_OP_OK;
   for(;;)
   {
      if(SrcLen <= 0)			// nothing usable
         break;

      if((pBuf = BIT8_ARRAY_ALLOC(HMEM_CTX_REF,SrcLen)) == NULL)
      {
         Retcode = PKCS12_ALLOC_ERR;
         break;
      }
      memcpy(pBuf+0,pIdata->Base+((int) pIdata->Off + 2),SrcLen);
      break;
   } 
   FreeIDATPARR_Struc(HMEM_CTX_REF1 pStringsDesc);
   ppFriendlyName[0]   = pBuf;
   pFriendlyNameLen[0] = SrcLen;
   return(Retcode);
}  
/**
* Copy an IDATPARR Descriptor to a new, local allocated one
* of same contents (AllocDuplicateDesc).
* NOTE: NULL Descriptors are NOT allocated!
*
*  @param pSrcDesc Source Descriptor
*  @param ppDstDesc Allocated, filled new Desc.
*  @return int Status - 0 o.k., else error occured
*/
static  int  AllocDuplicateDesc(IDATPARR* pSrcDesc,
                                IDATPARR** ppDstDesc)
{
   int Retcode,ElementCnt;

   ppDstDesc[0] = NULL;
   if(pSrcDesc == NULL)
      return(PKCS12_OP_OK);

   //------------------------------------------------------------------
   // Allocate new Descriptor (and the Element Array), mark as freeable
   //------------------------------------------------------------------
   ElementCnt = pSrcDesc->Cnt;
   if((Retcode = AllocIDATPARR_Struc(HMEM_CTX_REF1 ppDstDesc,ElementCnt)) != ASN1_OP_OK)
      return(Retcode);
   ppDstDesc[0]->Flags |= FREE_BIT_MASK;
   //-------------------------------------------------------------
   // Make a copy of all the Elements contents if any
   //-------------------------------------------------------------
   if(ElementCnt > 0)
   {
      if((Retcode = AllocCopyDatArrayToDatArray(HMEM_CTX_REF1 pSrcDesc,0,ppDstDesc[0],0,ElementCnt,1)) != ASN1_OP_OK)
      {
         FreeIDATPARR_Struc(HMEM_CTX_REF1 ppDstDesc[0]);
         ppDstDesc[0] = NULL;
      }
      return(Retcode);
   }
   return(PKCS12_OP_OK);
}

/**
* Generate the Cert- and related PrivkeyBags from given List of
* Certificates in internal notation (CertsListToBags).
*
*  - Certs without a private key generate just a simple CertBag
*    with no additional data.
*
*  - Certs with a private key generate a Certbag with a LocalKeyID
*    that is the SHA1 Hash of the DER encoded Certificate *AND*
*    generate an associated Private key bag with same LocalKeyID
*    and a friendly name derived from the Certificate (if possible)
*
*  @param pPfxStruc Structure
*  @param pCertsArr Array of Certificates
*  @param CertsCnt Number of Certificates
*  @return int Status - 0 o.k., else error occured
*/
static  int  CertsListToBags(PK12STRU * pPfxStruc,
                             X509CERT ** pCertsArr, int CertsCnt)
{
   int Retcode, Index, PrivKeyAlgor;

   int pTmpLen[1];
   char* ppTmpBuf[1];
   char* ppTmpBufDup[1];

   IDATA* pIdata;
   IDATPARR* pCertDERDesc;
   IDATPARR* ppTmpDesc[1];

   X509CERT * pActCert;

   P12BAG * pCertBag = NULL;
   P12BAG * pPrivBag = NULL;

   if((pPfxStruc == NULL) || (pCertsArr == NULL))
      return(PKCS12_NULL_PTR);

   if(CertsCnt <= 0)
      return(PKCS12_PARAM_ERR);
   //--------------------------------------------------------
   // Process the Certificates
   //--------------------------------------------------------
   Retcode = PKCS12_OP_OK;
   Index = 0;
   while(Index < CertsCnt)
   {
      if(((pActCert = pCertsArr[Index]) == NULL) ||
         ((pCertDERDesc = pActCert->Certificate) == NULL))
      {
         Retcode = PKCS12_NULL_PTR;
         break;
      }
      //------------------------------------------------------
      // Allocate a new Certbag Structure
      //------------------------------------------------------
      if((pCertBag = AllocPKCS12BagStruc()) == NULL)
      {
         Retcode = PKCS12_ALLOC_ERR;
         break;
      }
      pCertBag->BagType = PKCS12_CERTBAG_SUBID;
      //---------------------------------------------------
      // Copy the Certificate's DER Data Descriptor to Bag
      //---------------------------------------------------
      if((Retcode = AllocDuplicateDesc(pCertDERDesc,
         ppTmpDesc)) != PKCS12_OP_OK)
         break;
      pCertBag->pCertDesc = ppTmpDesc[0];
      //---------------------------------------------------
      // Check if the Certificate has a private Key
      //---------------------------------------------------
      if((pActCert->Flags & PRIV_KEY_MASK) != 0)
      {
         //---------------------------------------------------
         // There is a private Key, check if of correct type
         //---------------------------------------------------
         PrivKeyAlgor = pActCert->PrivKeyType;
         if((PrivKeyAlgor != RSA_PUBLIC_ALGOR) &&
            (PrivKeyAlgor != DSA_PUBLIC_ALGOR))
         {
            Retcode = PKCS12_INVALID_CERT_PRIV_ALGOR;
            break;
         }
         //---------------------------------------------------
         // Allocate a new Private key Bag
         //---------------------------------------------------
         if((pPrivBag = AllocPKCS12BagStruc()) == NULL)
         {
            Retcode = PKCS12_ALLOC_ERR;
            break;
         }
         pPrivBag->BagType = PKCS12_PKCS8_SHRBAG_SUBID;
         //-----------------------------------------------------
         // Copy the Certificate's Private Key Descriptor to Bag
         //-------------------------------------------------------
         if((Retcode = AllocDuplicateDesc(pActCert->PrivKeyData,
            ppTmpDesc)) != PKCS12_OP_OK)
            break;
         pPrivBag->pPrivKeyDesc = ppTmpDesc[0];
         //-----------------------------------------------------
         // Set the private Key Algor and Private Key Usage
         //-------------------------------------------------------
         pPrivBag->PrivKeyType  = PrivKeyAlgor;
         if((pActCert->PrivKeyUsageFlags & X509_KEYUSAGE_VALID_BIT) != 0)
         {
            pPrivBag->PrivKeyUsage =
               pActCert->PrivKeyUsageFlags &
               (~(X509_KEYUSAGE_VALID_BIT | X509_KEYUSAGE_CRITICAL_BIT));
            pPrivBag->PrivKeyUsageValid = 1;
         }
         //-----------------------------------------------------
         // Generate Friendly Name for the Private Key
         //-------------------------------------------------------
         if((Retcode = GenDNFriendlyName(pActCert->Subject,
            ppTmpBuf, pTmpLen)) != PKCS12_OP_OK)
            break;
         pPrivBag->pFriendlyName   = ppTmpBuf[0];
         pPrivBag->FriendlyNameLen = pTmpLen[0];
         //------------------------------------------------------
         // Generate Local KeyID from Hash of the Certificate's
         // Public Key (same as OCSP)
         //------------------------------------------------------
         //      pIdata = IDATPARR_ppArr(pCertDERDesc)[0];	// earlier...

         pIdata = pActCert->PubKeyValueOcsp->ppArr[0];

         if((Retcode = GenCertLclKeyID(pIdata->Base,
            (int) pIdata->Off,
            pIdata->Len, PKCS12_SIGNAT_ALGOR_SHA1,
            ppTmpBuf, pTmpLen, ppTmpBufDup)) != PKCS12_OP_OK)
            break;

         pCertBag->pLocalKeyID   = ppTmpBuf[0];
         pCertBag->LocalKeyIDLen = pTmpLen[0];
         pCertBag->DigestAlgor   = PKCS12_SIGNAT_ALGOR_SHA1;

         pPrivBag->pLocalKeyID   = ppTmpBufDup[0];
         pPrivBag->LocalKeyIDLen = pTmpLen[0];
         pPrivBag->DigestAlgor   = PKCS12_SIGNAT_ALGOR_SHA1;
         //-------------------------------------------------------
         // Add the PrivateKey Bag to the Structure
         //-------------------------------------------------------
         if((Retcode = AddBagToPfxBagArray(pPfxStruc,
            pPrivBag)) != PKCS12_OP_OK)
            break;
         pPrivBag = NULL;				// avoid freeing
      }
      else // no private key...
      {
         //------------------------------------------------------
         // Generate Local KeyID from Hash of the Certificate's
         // Public Key (same as OCSP)
         //------------------------------------------------------
         //      pIdata = IDATPARR_ppArr(pCertDERDesc)[0];	// earlier...

         pIdata = pActCert->PubKeyValueOcsp->ppArr[0];

         if((Retcode = GenCertLclKeyID(pIdata->Base,
            (int) pIdata->Off,
            pIdata->Len, PKCS12_SIGNAT_ALGOR_SHA1,
            ppTmpBuf, pTmpLen, ppTmpBufDup)) != PKCS12_OP_OK)
            break;

         pCertBag->pLocalKeyID   = ppTmpBuf[0];
         pCertBag->LocalKeyIDLen = pTmpLen[0];
         pCertBag->DigestAlgor   = PKCS12_SIGNAT_ALGOR_SHA1;
      }
      //-----------------------------------------------------
      // Generate Friendly Name for the Certificate
      //-------------------------------------------------------
      if((Retcode = GenDNFriendlyName(pActCert->Subject,
         ppTmpBuf, pTmpLen)) != PKCS12_OP_OK)
         break;
      pCertBag->pFriendlyName   = ppTmpBuf[0];
      pCertBag->FriendlyNameLen = pTmpLen[0];

      //-------------------------------------------------------
      // Add the Cert Bag to the Structure
      //-------------------------------------------------------
      if((Retcode = AddBagToPfxBagArray(pPfxStruc,
         pCertBag)) != PKCS12_OP_OK)
         break;
      pCertBag = NULL;				// avoid freeing
      Index++;
   }
   FreePKCS12BagStruc(pCertBag);
   FreePKCS12BagStruc(pPrivBag);
   return(Retcode);
}

/**
* Assemble an ASN.1 coded PKCS12 Safebag from a Bag Structure (PKCS12_ToSafebag).
*
*  @param pPfxStruc Structure 
*  @param pBagStruc Bag to encode
*  @param ppDstDesc Destination Descriptor
*  @param DstIndex Slot to use
*  @param DstAllocSize Number of slots for alloc
*  @return int Status - 0 o.k., else error occured
*/
static  int  PKCS12_ToSafebag(PK12STRU * pPfxStruc,
                              P12BAG * pBagStruc, IDATPARR** ppDstDesc,
                              int DstIndex, int DstAllocSize)
{
   int Retcode;
   int BagType;
   int IteratCnt;
   int EncBufLen;
   int EncDataLen = 0;
   int PlainDataLen;
   int SaltLen;

   int pTmpLen[1];

   char* pSaltBuf = NULL;
   char* pPlainBuf = NULL;
   char* pEncBuf = NULL;

   IDATA* pIdata;

   IDATPARR* pBagDesc = NULL; 
   IDATPARR* pShroudedBagDesc = NULL; 
   IDATPARR* pPbeParamsDesc = NULL;
   IDATPARR* pPrivKeyDesc = NULL; 
   IDATPARR* pCertDesc = NULL; 
   IDATPARR* pCertDataDesc = NULL; 

   IDATPARR* ppTmpDesc[1];
   //-----------------------------------------------------------
   // Check parameters
   //-----------------------------------------------------------
   if((pPfxStruc == NULL) || (pBagStruc == NULL) || (ppDstDesc == NULL))
      return(PKCS12_NULL_PTR);

   for(;;)		// error processing FOR
   {
      //------------------------------------------------------------
      // Get the Bag Type from Bag structure, check
      //------------------------------------------------------------
      BagType = pBagStruc->BagType;
      if((BagType != PKCS12_KEYBAG_SUBID) &&
         (BagType != PKCS12_PKCS8_SHRBAG_SUBID) &&
         (BagType != PKCS12_CERTBAG_SUBID))
         return(PKCS12_PARAM_ERR);
      //------------------------------------------------------------
      // Set the PKCS12 Bagtype OID, allocate all needed elements
      //------------------------------------------------------------
      ppTmpDesc[0] = NULL;			// Force Allocate
      if((Retcode = GenPKCS12_BagType_OIDArc(BagType,
         ppTmpDesc, PKCS12_SAFEBAG_ID_VALUE_INDEX,
         PKCS12_SAFEBAG_MAX_DATA_INDEX)) != PKCS12_OP_OK)
         break;
      pBagDesc = ppTmpDesc[0];
      //------------------------------------------------------------
      // Distribute by Bag type:
      //------------------------------------------------------------
      switch(BagType)
      {
         //=========================================================
         // Shrouded Key Bag Type
         //=========================================================
      case PKCS12_PKCS8_SHRBAG_SUBID:
         //--------------------------------------------------------
         // Allocate the Salt buffer
         //--------------------------------------------------------
         SaltLen   = pPfxStruc->PrivSaltLen;
         IteratCnt = pPfxStruc->PrivIteratCnt; 
         // NOTE: Check the given parameters !!! TO BE DONE !!!

         if((pSaltBuf = BIT8_ARRAY_ALLOC(HMEM_CTX_REF,
            SaltLen)) == NULL)
         {
            Retcode = PKCS12_ALLOC_ERR;
            break;
         }
         // should we seed with data ???
         //        RAND_BYTES(RANDinst, pSaltBuf, 0, SaltLen);
         if((Retcode = SecDrbgRandBytes(HMEM_CTX_REF1 pSaltBuf,0,SaltLen)) != 0)
            break;
         //-------------------------------------------------------
         // Generate ASN.1 encoded Private key data, alloc 
         //-------------------------------------------------------
         ppTmpDesc[0] = NULL;			// Force Allocate
         if((Retcode = ToASN1_PKCS8PrivkeyDesc(
            pBagStruc->pPrivKeyDesc,
            pBagStruc->PrivKeyType,
            pBagStruc->PrivKeyUsageValid,
            pBagStruc->PrivKeyUsage,
            ppTmpDesc, 0, 1)) != PKCS12_OP_OK)
            break;
         pPrivKeyDesc = ppTmpDesc[0];
         //-------------------------------------------------------
         // Allocate Encryption buffer
         //-------------------------------------------------------
         pIdata = pPrivKeyDesc->ppArr[0];
         pPlainBuf = pIdata->Base;
         PlainDataLen = pIdata->Len;
         EncBufLen = PlainDataLen + PKCS12_PBE_ALGOR_MAX_BLKLEN;
         if((pEncBuf = BIT8_ARRAY_ALLOC(HMEM_CTX_REF,
            EncBufLen)) == NULL)
         {
            Retcode = PKCS12_ALLOC_ERR;
            break;
         }
         //-------------------------------------------------------
         // Encrypt the Private key data now
         //-------------------------------------------------------
         pTmpLen[0] = EncBufLen;
         Retcode = PKCS12Crypt(
            pPfxStruc->pUniPwd,
            pPfxStruc->UniPwdOff,
            pPfxStruc->UniPwdLen,
            NULL, 0, 0,
            pSaltBuf, 0, SaltLen,
            IteratCnt,
            pPfxStruc->PrivKeyPBEEncAlgorID,
            PKCS12_ENCRYPT,0,
            pIdata->Base, (int) pIdata->Off,
            pIdata->Len,
            pEncBuf,0,pTmpLen);
         ClearBit8Array(pPlainBuf, 0, PlainDataLen);
         FreeIDATPARR_Struc(HMEM_CTX_REF1 pPrivKeyDesc);
         pPlainBuf = NULL;
         pPrivKeyDesc = NULL;

         if(Retcode != PKCS12_OP_OK)
            break;

         EncDataLen = pTmpLen[0];
         //--------------------------------------------------------
         // Set the PBE encryption Algor OID, allocate all elements
         //--------------------------------------------------------
         ppTmpDesc[0] = NULL;			// Force Allocate
         if((Retcode = GenPKCS12_PBE_AlgorOIDArc(
            pPfxStruc->PrivKeyPBEEncAlgorID,
            ppTmpDesc, PKCS12_SHRBAG_ENCALG_ID_INDEX,
            PKCS12_SHRBAG_MAX_DATA_INDEX)) != PKCS12_OP_OK)
            break;
         pShroudedBagDesc = ppTmpDesc[0];
         //--------------------------------------------------------
         // Generate the PBE Algor Params
         //--------------------------------------------------------
         //      ppTmpDesc[0] = pShroudedBagDesc;
         if((Retcode = ToASN1_PBEParamsToDesc(pSaltBuf, 0, SaltLen,
            IteratCnt, ppTmpDesc,
            PKCS12_SHRBAG_ENCALG_PAR_INDEX,
            0)) != PKCS12_OP_OK)
            break;
         //--------------------------------------------------------
         // Set the Encrypted Key Parameter
         //--------------------------------------------------------
         //      ppTmpDesc[0] = pShroudedBagDesc;
         Retcode = FromBufToDescAlloc(pEncBuf, 0, EncDataLen,
            ppTmpDesc, PKCS12_SHRBAG_ENC_DATA_INDEX, 0);
         //        FREE_ARRAY(pEncBuf);
         if(Retcode != PKCS12_OP_OK)
            break;
         pEncBuf = NULL;
         //--------------------------------------------------------
         // ASN.1 Encode the Bag now
         //--------------------------------------------------------
         ppTmpDesc[0] = pBagDesc;
         Retcode =ToASN1_PKCS12ShroudedKeyBagDesc(pShroudedBagDesc, 0,
            ppTmpDesc, PKCS12_SAFEBAG_VALUE_INDEX, 0, NULL); 
         break;
         //=========================================================
         // CertBag Type
         //=========================================================
      case PKCS12_CERTBAG_SUBID:
         //----------------------------------------------------------
         // Generate Certificate Type OID, always X509 Cert, allocate
         //----------------------------------------------------------
         ppTmpDesc[0] = NULL;			// Force allocate
         if((Retcode = GenPKCS9_CertTypeOIDArc(PKCS12_X509_CERT_TYPE_SUBID,
            ppTmpDesc, PKCS12_CERTBAG_CERT_ID_INDEX,
            PKCS12_CERTBAG_MAX_DATA_INDEX)) != PKCS12_OP_OK)
            break;
         pCertDesc = ppTmpDesc[0];
         //----------------------------------------------------------
         // Generate Certificate Value (Data embedded in an OCTETSTR)
         //----------------------------------------------------------
         pIdata = pBagStruc->pCertDesc->ppArr[0];
         if((Retcode = ToASN1_BufToDescOCTETSTR(
            pIdata->Base, (int) pIdata->Off,
            pIdata->Len, ppTmpDesc,
            PKCS12_CERTBAG_VALUE_INDEX, 0)) != PKCS12_OP_OK)
            break;
         //--------------------------------------------------------
         // ASN.1 Encode the Bag now
         //--------------------------------------------------------
         ppTmpDesc[0] = pBagDesc;
         Retcode =ToASN1_PKCS12CertBagDesc(pCertDesc, 0,
            ppTmpDesc, PKCS12_SAFEBAG_VALUE_INDEX, 0, NULL);
         break;
      }
      if(Retcode != PKCS12_OP_OK)
         break;
      //------------------------------------------------------------
      // Set Additional PKCS9 Attribute values if present
      //------------------------------------------------------------
      ppTmpDesc[0] = pBagDesc;
      if((Retcode = PKCS12_GenPKCS9SelectedAtts(
         pBagStruc->pFriendlyName, 0,
         pBagStruc->FriendlyNameLen,
         pBagStruc->pLocalKeyID, 0,
         pBagStruc->LocalKeyIDLen,
         ppTmpDesc,
         PKCS12_SAFEBAG_NAME_ATTS_INDEX,
         0)) != PKCS12_OP_OK)
         break;
      //------------------------------------------------------------
      // ASN.1 Encode the SafeBag
      //------------------------------------------------------------
      Retcode = ToASN1_PKCS12BagDesc(pBagDesc, 0,
         ppDstDesc, DstIndex, DstAllocSize, NULL);
      FreeIDATPARR_Struc(HMEM_CTX_REF1 pBagDesc);
      pBagDesc = NULL;
      break;
   }
   //-------------------------------------------------------------
   // Free temporary Elements
   //-------------------------------------------------------------
   FreeIDATPARR_Struc(HMEM_CTX_REF1 pBagDesc);
   FreeIDATPARR_Struc(HMEM_CTX_REF1 pShroudedBagDesc);
   FreeIDATPARR_Struc(HMEM_CTX_REF1 pPbeParamsDesc);
   FreeIDATPARR_Struc(HMEM_CTX_REF1 pPrivKeyDesc);
   FreeIDATPARR_Struc(HMEM_CTX_REF1 pCertDesc);
   FreeIDATPARR_Struc(HMEM_CTX_REF1 pCertDataDesc);
   if(pPlainBuf != NULL)
   {
      ClearBit8Array(pPlainBuf,0,EncDataLen);
      FREE_ARRAY(HMEM_CTX_REF,pPlainBuf);
   }
   //--------------------------------------------------------
   // if error occured, clear all sensitive data
   //--------------------------------------------------------
   if(Retcode != PKCS12_OP_OK)
   {
      FreePKCS12BagStruc(pBagStruc);
      return(Retcode);
   }
   return(Retcode);
}

/**
* Assemble a PKCS12 ContentInfo from given safebags (PKCS12_ToContentInfoDesc). 
* If the content
* is to be encrypted set the encryption parameters and encrypt
* the content.
*
* NOTE: All safebags with Private Keys are assembled into an
* ----- unencrypted content.
*	 All safebags with Certificates are assembled into an
*	 encryptedt content.
*
*  @param pPfxStruc Structure with bags
*  @param ContentTypeID Type of content to build
*  @param ppDstDesc loaded Array Descriptor
*  @param DstIndex 1st Slot to use
*  @param DstAllocSize number of slots for allocate
*  @return int Status - 0 o.k., else error occured
*/
static  int  PKCS12_ToContentInfoDesc(PK12STRU * pPfxStruc,
                                      int ContentTypeID, IDATPARR** ppDstDesc, int DstIndex,
                                      int DstAllocSize)
{
   int Retcode, Index;
   int EncBufLen, EncDataLen;
   int SaltLen;
   int IteratCnt;
   int PlainDataLen = 0;
   int BagsCnt;

   char* pPlainBuf = NULL;
   char* pEncBuf   = NULL;
   char* pSaltBuf  = NULL;

   IDATA* pIdata;

   int pTmpLen[1];

   IDATPARR* pBagsDesc	 = NULL;
   IDATPARR* pDataContentDesc  = NULL;
   IDATPARR* pContentValueDesc = NULL;
   IDATPARR* pEncDataDesc	 = NULL;
   IDATPARR* pEncContInfoDesc  = NULL;
   IDATPARR* pEncContDesc	 = NULL;

   IDATPARR* ppTmpDesc[1];

   P12BAG ** pBagsArr;
   //------------------------------------------------------------
   // Check parameters
   //------------------------------------------------------------
   if((pPfxStruc == NULL) || (ppDstDesc == NULL))
      return(PKCS12_NULL_PTR);

   if((ContentTypeID != PKCS7_CONTENT_DATA_SUBID) &&
      (ContentTypeID != PKCS7_CONTENT_ENCDATA_SUBID))
      return(PKCS12_PARAM_ERR);
   //------------------------------------------------------------
   // Assemble the appropriate Bags into a SET OF Bags first
   //------------------------------------------------------------
   if(ContentTypeID == PKCS7_CONTENT_DATA_SUBID)
   {
      pBagsArr = pPfxStruc->pPrivKeyBagsArr;
      BagsCnt  = pPfxStruc->PrivKeysCnt;
   }
   else
   {
      pBagsArr = pPfxStruc->pCertBagsArr;
      BagsCnt  = pPfxStruc->CertsCnt;
   }
   //---------------------------------------------------------
   // Allocate the descriptor for the Bag Sequences
   //---------------------------------------------------------
   if((Retcode = AllocIDATPARR_Struc(HMEM_CTX_REF1 ppTmpDesc,BagsCnt)) != ASN1_OP_OK)
      return(Retcode);

   pBagsDesc = ppTmpDesc[0];
   pBagsDesc->Flags |= FREE_BIT_MASK;
   //---------------------------------------------------------
   // Generate the Bag Sequences
   //---------------------------------------------------------
   Index = 0;
   while(Index < BagsCnt)
   {
      if((Retcode = PKCS12_ToSafebag(pPfxStruc, pBagsArr[Index],
         ppTmpDesc, Index, 0)) != PKCS12_OP_OK)
      {
         pBagsArr[Index] = NULL;
         break;
      }
      Index++;
   }
   if(Retcode != PKCS12_OP_OK)
   {
      FreeIDATPARR_Struc(HMEM_CTX_REF1 pBagsDesc);
      return(Retcode);
   }
   //---------------------------------------------------------
   // Embed Bag Encodings in the ContentValue Sequence
   //---------------------------------------------------------
   ppTmpDesc[0] = NULL;			// Force Allocate
   Retcode = ToASN1_UniversalEmbeddedType(pBagsDesc,
      ASN1_UNIVERSAL_SEQUENCE, 0,
      (char *) ASN1_AnyCtl, ASN1_ANY_CTL_CNT,
      ASN1_ANY_MAX_DATA_INDEX, PKCS12_ANY_ASN1_FROM_INT_ERROR,
      ppTmpDesc, 0, 1, NULL);
   FreeIDATPARR_Struc(HMEM_CTX_REF1 pBagsDesc);
   if(Retcode != PKCS12_OP_OK)
      return(Retcode);
   pContentValueDesc = ppTmpDesc[0];
   //---------------------------------------------------------
   // Check what type of Content Info shall be generated
   //---------------------------------------------------------
   if(ContentTypeID == PKCS7_CONTENT_DATA_SUBID)
   {
      //-------------------------------------------------------
      // Data-Content shall be generated, set the OID
      //-------------------------------------------------------
      ppTmpDesc[0] = NULL;			// Force Allocate
      if((Retcode = GenPKCS7_ContentTypeOIDArc(PKCS7_CONTENT_DATA_SUBID,
         ppTmpDesc, PKCS7_CONTINFO_TYPE_INDEX,
         PKCS7_CONTINFO_MAX_DATA_INDEX)) != PKCS12_OP_OK)
      {
         FreeIDATPARR_Struc(HMEM_CTX_REF1 pContentValueDesc);
         return(Retcode);
      }
      pDataContentDesc = ppTmpDesc[0];
      //-------------------------------------------------------
      // Embed the ContentValue into an OCTET String
      //-------------------------------------------------------
      pIdata = pContentValueDesc->ppArr[0];
      Retcode = ToASN1_BufToDescOCTETSTR(pIdata->Base,
         (int) pIdata->Off, pIdata->Len,
         ppTmpDesc, PKCS7_CONTINFO_DATA_INDEX, 0);
      if(Retcode != PKCS12_OP_OK)
      {
         FreeIDATPARR_Struc(HMEM_CTX_REF1 pContentValueDesc);
         return(Retcode);
      }
      pContentValueDesc->Flags &= (~FREE_BIT_MASK); // avoid freeeing!
      FreeIDATPARR_Struc(HMEM_CTX_REF1 pContentValueDesc);
      //-------------------------------------------------------
      // Format the Data ContentInfo
      //-------------------------------------------------------
      Retcode = ToASN1_DescToDesc(pDataContentDesc, 0,
         (char *) PKCS7ContInfoCtl,
         PKCS7_CONTINFO_CTL_CNT,
         PKCS7_CONTINFO_FROM_INT_ERR,
         ppDstDesc, DstIndex, DstAllocSize, NULL);
      FreeIDATPARR_Struc(HMEM_CTX_REF1 pDataContentDesc);
      return(Retcode);
   }
   //-------------------------------------------------------
   // Encrypted Content Shall be generated (Certificates)
   //-------------------------------------------------------
   for(;;)
   {
      //------------------------------------------------------------
      // Get the Encryption parameters from Structure, generate Salt
      //------------------------------------------------------------
      SaltLen   = pPfxStruc->CertSaltLen;
      IteratCnt = pPfxStruc->CertIteratCnt; 
      if((pSaltBuf = BIT8_ARRAY_ALLOC(HMEM_CTX_REF,SaltLen)) == NULL)
      {
         Retcode = PKCS12_ALLOC_ERR;
         break;
      }
      // should we seed with data ???
      //    RAND_BYTES(RANDinst, pSaltBuf, 0, SaltLen);
      if((Retcode = SecDrbgRandBytes(HMEM_CTX_REF1 pSaltBuf,0,SaltLen)) != 0)
         break;
      //-------------------------------------------------------
      // Allocate Encryption buffer
      //-------------------------------------------------------
      pIdata = pContentValueDesc->ppArr[0];
      pPlainBuf = pIdata->Base;
      PlainDataLen = pIdata->Len;
      EncBufLen = PlainDataLen + PKCS12_PBE_ALGOR_MAX_BLKLEN;
      if((pEncBuf = BIT8_ARRAY_ALLOC(HMEM_CTX_REF,
         EncBufLen)) == NULL)
      {
         Retcode = PKCS12_ALLOC_ERR;
         break;
      }
      //-------------------------------------------------------
      // Encrypt the Contents Value now
      //-------------------------------------------------------
      pTmpLen[0] = EncBufLen;
      Retcode = PKCS12Crypt(
         pPfxStruc->pUniPwd,
         pPfxStruc->UniPwdOff,
         pPfxStruc->UniPwdLen,
         NULL, 0, 0,
         pSaltBuf, 0, SaltLen,
         IteratCnt,
         pPfxStruc->CertPBEEncAlgorID,
         PKCS12_ENCRYPT,0,
         pIdata->Base, (int) pIdata->Off,
         pIdata->Len,
         pEncBuf,0,pTmpLen);
      ClearBit8Array(pPlainBuf, 0, PlainDataLen);
      FreeIDATPARR_Struc(HMEM_CTX_REF1 pContentValueDesc);
      pPlainBuf = NULL;
      pContentValueDesc = NULL;

      if(Retcode != PKCS12_OP_OK)
         break;

      EncDataLen = pTmpLen[0];
      //-----------------------------------------------------------
      //  Set the Encrypted ContentInfo Version, alloc all elements
      //-----------------------------------------------------------
      ppTmpDesc[0] = NULL;			// Force Allocate
      if((Retcode = GenUnsignedBit32Num(0, ppTmpDesc,
         PKCS7_ENCDATA_VERSION_INDEX,
         PKCS7_ENCDATA_MAX_DATA_INDEX)) != PKCS12_OP_OK)
         break;
      pEncDataDesc = ppTmpDesc[0];
      //---------------------------------------------------------
      // Set the Content Type OID (is DATA !)
      //---------------------------------------------------------
      if((Retcode = GenPKCS7_ContentTypeOIDArc(PKCS7_CONTENT_DATA_SUBID,
         ppTmpDesc, PKCS7_ENCDATA_TYPE_INDEX,
         0)) != PKCS12_OP_OK)
         break;
      //--------------------------------------------------------
      // Set the PBE encryption Algor OID
      //--------------------------------------------------------
      if((Retcode = GenPKCS12_PBE_AlgorOIDArc(
         pPfxStruc->CertPBEEncAlgorID,
         ppTmpDesc, PKCS7_ENCDATA_ENCALG_ID_INDEX,
         0)) != PKCS12_OP_OK)
         break;
      //--------------------------------------------------------
      // Generate the PBE Algor Params
      //--------------------------------------------------------
      if((Retcode = ToASN1_PBEParamsToDesc(pSaltBuf, 0, SaltLen,
         IteratCnt, ppTmpDesc,
         PKCS7_ENCDATA_ENCALG_PAR_INDEX,
         0)) != PKCS12_OP_OK)
         break;
      FREE_ARRAY(HMEM_CTX_REF,pSaltBuf);	// set NULL
      //--------------------------------------------------------
      // Set the Encrypted Data Parameter
      //--------------------------------------------------------
      Retcode = FromBufToDescAlloc(pEncBuf, 0, EncDataLen,
         ppTmpDesc, PKCS7_ENCDATA_ENCDATA_INDEX, 0);
      //    FREE_ARRAY(HMEM_CTX_REF,pEncBuf);
      if(Retcode != PKCS12_OP_OK)
         break;
      pEncBuf = NULL;			// avoid freeing
      //-------------------------------------------------------
      // Format the EncryptedData ContentInfo
      //-------------------------------------------------------
      ppTmpDesc[0] = NULL;			// Force allocate
      if((Retcode = ToASN1_DescToDesc(pEncDataDesc, 0,
         (char *) PKCS7ContEncDataCtl,
         PKCS7_CONT_ENCDATA_CTL_CNT,
         PKCS7_ENCDATA_FROM_INT_ERR,
         ppTmpDesc, 0, 1, NULL)) != PKCS12_OP_OK)
         break;
      FreeIDATPARR_Struc(HMEM_CTX_REF1 pEncDataDesc);
      pEncDataDesc = NULL;		// avoid freeing
      pEncContInfoDesc = ppTmpDesc[0];
      //-------------------------------------------------------------
      // Set the Embedding Content Type OID (is ENCDATA !), alloc all
      //-------------------------------------------------------------
      ppTmpDesc[0] = NULL;			// Force allocate
      if((Retcode = GenPKCS7_ContentTypeOIDArc(PKCS7_CONTENT_ENCDATA_SUBID,
         ppTmpDesc, PKCS7_CONTINFO_TYPE_INDEX,
         PKCS7_CONTINFO_MAX_DATA_INDEX)) != PKCS12_OP_OK)
         break;
      pEncContDesc = ppTmpDesc[0];
      //--------------------------------------------------------
      // Set the EncryptedContentInfo Data Parameter
      //--------------------------------------------------------
      pIdata = pEncContInfoDesc->ppArr[0];
      if((Retcode = FromBufToDescAllocCopy(pIdata->Base,
         (int) pIdata->Off,
         pIdata->Len,
         ppTmpDesc, PKCS7_CONTINFO_DATA_INDEX,
         0)) != PKCS12_OP_OK)
         break;
      FreeIDATPARR_Struc(HMEM_CTX_REF1 pEncContInfoDesc);
      pEncContInfoDesc = NULL;
      //-------------------------------------------------------
      // Format the EncryptedData Content
      //-------------------------------------------------------
      Retcode = ToASN1_DescToDesc(pEncContDesc, 0,
         (char *) PKCS7ContInfoCtl,
         PKCS7_CONTINFO_CTL_CNT,
         PKCS7_CONTINFO_FROM_INT_ERR,
         ppDstDesc, DstIndex, DstAllocSize, NULL);
      FreeIDATPARR_Struc(HMEM_CTX_REF1 pEncContDesc);
      return(Retcode);
   }
   //----------------------------------------------------------
   // Error occured free remaining buffers / Descriptors
   //----------------------------------------------------------
   if(pPlainBuf != NULL)
      ClearBit8Array(pPlainBuf, 0, PlainDataLen);
   FreeIDATPARR_Struc(HMEM_CTX_REF1 pContentValueDesc);
   FreeIDATPARR_Struc(HMEM_CTX_REF1 pEncDataDesc);
   FreeIDATPARR_Struc(HMEM_CTX_REF1 pEncContInfoDesc);
   FreeIDATPARR_Struc(HMEM_CTX_REF1 pEncContDesc);
   FREE_ARRAY(HMEM_CTX_REF,pEncBuf);
   FREE_ARRAY(HMEM_CTX_REF,pSaltBuf);
   return(Retcode);
}

/**
* Assemble a PKCS12 V3 PFX PDU from safebags, generate the HMAC (PKCS12_ToPFX_PDU_Desc).
*
* NOTE: All safebags with Private Keys are assembled into an
* ----- encrypted content.
*	 All safebags with Certificates are assembled into an
*	 unencrypted content.
*
*  @param pPfxStruc Structure with bags
*  @param ppDstDesc loaded Array Descriptor
*  @param DstIndex 1st Slot to use
*  @param DstAllocSize number of slots for allocate
*  @return int Status - 0 o.k., else error occured
*/
static  int  PKCS12_ToPFX_PDU_Desc(HMEM_CTX_DEF
                                   PK12STRU * pPfxStruc,
                                   IDATPARR** ppDstDesc, int DstIndex,
                                   int DstAllocSize)
{
   int Retcode;
   int IteratCnt;

   char SaltBuf[SHA_DIGEST_LEN];
   char HMACBuf[SHA_DIGEST_LEN];
   //  BIT8ARRAY(TmpBuf,2);

   IDATA* pIdata;

   IDATPARR* pPfxPDU_Desc = NULL;
   IDATPARR* pAuthSafeValDesc = NULL;
   IDATPARR* pAuthSafeDesc = NULL;
   IDATPARR* pAuthDesc = NULL;

   IDATPARR* ppTmpDesc[1];

   //------------------------------------------------------------
   // Check parameters
   //------------------------------------------------------------
   if((pPfxStruc == NULL) || (ppDstDesc == NULL))
      return(PKCS12_NULL_PTR);

   for(;;)		// Error FOR
   {
      //------------------------------------------------------------
      // Generate the Version (V3), allocate all Elements
      //------------------------------------------------------------
      ppTmpDesc[0] = NULL;			// Force Allocate
      if((Retcode = GenUnsignedBit32Num(3, ppTmpDesc,
         PKCS12_PFX_PDU_VERSION_INDEX,
         PKCS12_PFX_PDU_MAX_DATA_INDEX)) != PKCS12_OP_OK)
         break;
      pPfxPDU_Desc = ppTmpDesc[0];
      //---------------------------------------------------------
      // Set the Content Type OID
      //---------------------------------------------------------
      if((Retcode = GenPKCS7_ContentTypeOIDArc(PKCS7_CONTENT_DATA_SUBID,
         ppTmpDesc, PKCS12_PFX_PDU_CONTTYPE_INDEX,
         0)) != PKCS12_OP_OK)
         break;
      //---------------------------------------------------------
      // Generate Private Keys and Certs Contents
      //---------------------------------------------------------
      ppTmpDesc[0] = NULL;			//Force Allocate
      if((Retcode = PKCS12_ToContentInfoDesc(pPfxStruc,
         PKCS7_CONTENT_DATA_SUBID, ppTmpDesc,0,2)) != PKCS12_OP_OK)
         break;
      pAuthSafeValDesc = ppTmpDesc[0];

      if((Retcode = PKCS12_ToContentInfoDesc(pPfxStruc,
         PKCS7_CONTENT_ENCDATA_SUBID, ppTmpDesc,1,0)) != PKCS12_OP_OK)
         break;
      //---------------------------------------------------------
      // Embed Contents in the AuthenticatedSafe Sequence
      //---------------------------------------------------------
      ppTmpDesc[0] = NULL;			// Force Allocate
      Retcode = ToASN1_UniversalEmbeddedType(pAuthSafeValDesc,
         ASN1_UNIVERSAL_SEQUENCE, 0,
         (char *) ASN1_AnyCtl, ASN1_ANY_CTL_CNT,
         ASN1_ANY_MAX_DATA_INDEX, PKCS12_ANY_ASN1_FROM_INT_ERROR,
         ppTmpDesc, 0, 1, NULL);
      FreeIDATPARR_Struc(HMEM_CTX_REF1 pAuthSafeValDesc);
      pAuthSafeValDesc = NULL;  			// avoid freeing
      if(Retcode != PKCS12_OP_OK)
         break;
      pAuthSafeDesc = ppTmpDesc[0];
      //---------------------------------------------------------
      // Generate HMAC Salt, Generate the HMAC
      //---------------------------------------------------------
      IteratCnt = pPfxStruc->MACIteratCnt;
      if(IteratCnt <= 0)
         IteratCnt = 1;
      //    RAND_BYTES(RANDinst, SaltBuf, 0, SHA_DIGEST_LEN);
      if((Retcode = SecDrbgRandBytes(HMEM_CTX_REF1 SaltBuf,0,SHA_DIGEST_LEN)) != 0)
         break;

      pIdata = pAuthSafeDesc->ppArr[0];
      if((Retcode = PKCS12GenVfyHMAC_SHA1(
         pPfxStruc->pUniPwd,
         pPfxStruc->UniPwdOff,
         pPfxStruc->UniPwdLen,
         SaltBuf, 0, SHA_DIGEST_LEN, IteratCnt,
         PKCS12_HASH_TYPE_SHA1,
         PKCS12_HMAC_GEN,0,
         pIdata->Base,
         (int) pIdata->Off,
         pIdata->Len,
         HMACBuf, 0, SHA_DIGEST_LEN)) != PKCS12_OP_OK)
         break;
      //---------------------------------------------------------
      // Generate AuthSafe Descriptor
      //---------------------------------------------------------
      ppTmpDesc[0] = NULL;			// Force Allocate
      if((Retcode = FromBufToDescAllocCopy(pIdata->Base,
         (int) pIdata->Off, pIdata->Len,
         ppTmpDesc, 0, 1)) != PKCS12_OP_OK)
         break;
      FreeIDATPARR_Struc(HMEM_CTX_REF1 pAuthSafeDesc);
      pAuthSafeDesc = NULL;
      pAuthDesc = ppTmpDesc[0];
      //---------------------------------------------------------
      // Embed AuthSafe to OCTET String
      //---------------------------------------------------------
      pIdata = pAuthDesc->ppArr[0];
      ppTmpDesc[0] = pPfxPDU_Desc;
      Retcode = ToASN1_BufToDescOCTETSTR(pIdata->Base,
         (int) pIdata->Off, pIdata->Len,
         ppTmpDesc, PKCS12_PFX_PDU_CONTDATA_INDEX, 0);
      if(Retcode != PKCS12_OP_OK)
         break;
      pAuthDesc->Flags &= (~FREE_BIT_MASK); // avoid freeeing!
      FreeIDATPARR_Struc(HMEM_CTX_REF1 pAuthDesc);
      pAuthDesc = NULL;
      //---------------------------------------------------------
      // Geneate the MAC Digest Algor OID
      //---------------------------------------------------------
      //    ppTmpDesc[0] = pPfxPDU_Desc;
      if((Retcode = GenOIW_DSA_AlgorOIDArc(OIW_DSA_ALGOR_SUBID,
         ppTmpDesc, PKCS12_PFX_PDU_MAC_ALGID_INDEX,
         0)) != PKCS12_OP_OK)
         break;
      //---------------------------------------------------------
      // Set the HMAC Digest
      //---------------------------------------------------------
      if((Retcode = FromBufToDescAllocCopy(HMACBuf, 0, SHA_DIGEST_LEN,
         ppTmpDesc, PKCS12_PFX_PDU_MAC_DIGEST_INDEX,
         0)) != PKCS12_OP_OK)
         break;
      //---------------------------------------------------------
      // Set the HMAC Salt
      //---------------------------------------------------------
      if((Retcode = FromBufToDescAllocCopy(SaltBuf, 0, SHA_DIGEST_LEN,
         ppTmpDesc, PKCS12_PFX_PDU_MAC_SALT_INDEX,
         0)) != PKCS12_OP_OK)
         break;
      //---------------------------------------------------------
      // Set the IterationCount
      //---------------------------------------------------------
      if((Retcode = GenUnsignedBit32Num(IteratCnt, ppTmpDesc,
         PKCS12_PFX_PDU_MAC_ITERAT_INDEX,
         0)) != PKCS12_OP_OK)
         break;
      //---------------------------------------------------------
      // Generate the V3 PFX PDU
      //---------------------------------------------------------
      Retcode = ToASN1_PFX_PDU_Desc(pPfxPDU_Desc, 0,
         ppDstDesc, DstIndex, DstAllocSize, NULL);
      FreeIDATPARR_Struc(HMEM_CTX_REF1 pPfxPDU_Desc);
      return(Retcode);
   }
   //------------------------------------------------------------
   // Error occured, free temporary elements
   //------------------------------------------------------------
   FreeIDATPARR_Struc(HMEM_CTX_REF1 pAuthSafeValDesc);
   FreeIDATPARR_Struc(HMEM_CTX_REF1 pAuthSafeDesc);
   FreeIDATPARR_Struc(HMEM_CTX_REF1 pAuthDesc);
   FreeIDATPARR_Struc(HMEM_CTX_REF1 pPfxPDU_Desc);
   return(Retcode);
}
/**
* Generate PKCS12 V3 PFX PDU from given Certificate List (PKCS12_V3_Encode).
*
*  @param pCertList Certificate List
*  @param CertsCnt
*  @param SecurityLevel 0 - low, 1 - medium, 2 - high
*  @param pPwd Password (ASCII)
*  @param PwdOff Start of data
*  @param PwdLen size of data
*  @param ppDstBuf Allocated buffer
*  @param pDstLen Size of Data generated
*  @return int Status - 0 o.k., else error occured
*/
static  int  PKCS12_V3_Encode(X509CERT ** pCertList,
                              int CertsCnt, int SecurityLevel, char* pPwd, int PwdOff, int PwdLen,
                              char** ppDstBuf, int* pDstLen)
{
   int Retcode;
   IDATA* pIdata;
   IDATPARR* ppTmpDesc[1];

   PK12STRU * pPfxStruc;
   PK12STRU * ppTmpStruc[1];
   //---------------------------------------------------------
   // Check parameters
   //---------------------------------------------------------
   if((pCertList == NULL) || (pPwd == NULL) ||
      (ppDstBuf == NULL) || (pDstLen == NULL))
      return(PKCS12_NULL_PTR);
   if((CertsCnt <= 0) || (PwdLen <= 0) ||
      (SecurityLevel < PKCS12_LOW_SECURITY) ||
      (SecurityLevel > PKCS12_HIGH_SECURITY))
      return(PKCS12_PARAM_ERR);
   //---------------------------------------------------------
   // Allocate, initialize PFX Structure
   //---------------------------------------------------------
   if((Retcode = AllocPrepPKCS12SStruc(pPwd, PwdOff, PwdLen,
      PKCS12_V3_PDU_TYPE,
      ppTmpStruc)) != PKCS12_OP_OK)
      return(Retcode);
   pPfxStruc = ppTmpStruc[0];
   //---------------------------------------------------------
   // Set the Appropriate Encryption Algors, Salt length
   //---------------------------------------------------------
   pPfxStruc->PrivIteratCnt = PKCS12_DEFAULT_ITERAT_CNT;
   pPfxStruc->CertIteratCnt = PKCS12_DEFAULT_ITERAT_CNT;
   pPfxStruc->MACIteratCnt  = PKCS12_DEFAULT_ITERAT_CNT;
   pPfxStruc->PrivKeyPBEEncAlgorID = PKCS12_PBE_SHA_3DESC_CBC_3KEYS;
   pPfxStruc->PrivSaltLen          = 8;
   pPfxStruc->CertPBEEncAlgorID    = PKCS12_PBE_SHA_3DESC_CBC_3KEYS;
   pPfxStruc->CertSaltLen          = 8;

   if(SecurityLevel == PKCS12_MEDIUM_SECURITY)
   {
      //  PK12_CertPBEEncAlgorID(pPfxStruc)    = PKCS12_PBE_SHA_RC2_CBC_128;
      pPfxStruc->CertPBEEncAlgorID    = PKCS12_PBE_SHA_RC4_128;
   }
   else if(SecurityLevel == PKCS12_LOW_SECURITY)
   {
      //  PK12_PrivKeyPBEEncAlgorID(pPfxStruc) = PKCS12_PBE_SHA_3DESC_CBC_2KEYS;;
      pPfxStruc->CertPBEEncAlgorID    = PKCS12_PBE_SHA_RC2_CBC_40;
   }
   //---------------------------------------------------------
   // Convert Certificate List to Bags
   //---------------------------------------------------------
   if((Retcode = CertsListToBags(pPfxStruc, pCertList,
      CertsCnt)) != PKCS12_OP_OK)
   {
      FreePKCS12Struc(pPfxStruc);
      return(Retcode);
   }
   //---------------------------------------------------------
   // Generate the PFX PDU
   //---------------------------------------------------------
   ppTmpDesc[0] = NULL;			// Force Allocate
   if((Retcode = PKCS12_ToPFX_PDU_Desc(HMEM_CTX_REF1 pPfxStruc,
      ppTmpDesc, 0, 1)) != PKCS12_OP_OK)
   {
      FreePKCS12Struc(pPfxStruc);
      return(Retcode);
   }
   pIdata = ppTmpDesc[0]->ppArr[0];
   //---------------------------------------------------------
   // Transfer buffer to caller, set Descriptor Buffer NULL
   //---------------------------------------------------------
   ppDstBuf[0] = pIdata->Base;
   pDstLen[0]  = pIdata->Len;
   pIdata->Base = NULL;
   pIdata->Len  = 0;
   FreeIDATPARR_Struc(HMEM_CTX_REF1 ppTmpDesc[0]);
   FreePKCS12Struc(pPfxStruc);
   return(PKCS12_OP_OK);
}

/**
* Generate PKCS12 V1 PFX PDU from given Certificate List (PKCS12_V1_Encode).
*
*  @param pCertList Certificate List
*  @param CertsCnt
*  @param SecurityLevel 0 - low, 1 - medium, 2 - high
*  @param pPwd Password (ASCII)
*  @param PwdOff Start of data
*  @param PwdLen size of data
*  @param ppDstBuf Allocated buffer
*  @param pDstLen Size of Data generated
*  @return int Status - 0 o.k., else error occured
*/
static  int  PKCS12_V1_Encode(X509CERT ** pCertList,
                              int CertsCnt, int SecurityLevel, char* pPwd, int PwdOff, int PwdLen,
                              char** ppDstBuf, int* pDstLen)
{
   int Retcode;
   IDATA* pIdata;
   IDATPARR* ppTmpDesc[1];

   PK12STRU * pPfxStruc;
   PK12STRU * ppTmpStruc[1];
   //---------------------------------------------------------
   // Check parameters
   //---------------------------------------------------------
   if((pCertList == NULL) || (pPwd == NULL) ||
      (ppDstBuf == NULL) || (pDstLen == NULL))
      return(PKCS12_NULL_PTR);
   if((CertsCnt <= 0) || (PwdLen <= 0) ||
      (SecurityLevel < PKCS12_LOW_SECURITY) ||
      (SecurityLevel > PKCS12_HIGH_SECURITY))
      return(PKCS12_PARAM_ERR);
   //---------------------------------------------------------
   // Allocate, initialize PFX Structure
   //---------------------------------------------------------
   if((Retcode = AllocPrepPKCS12SStruc(pPwd, PwdOff, PwdLen,
      PKCS12_V1_PDU_TYPE,
      ppTmpStruc)) != PKCS12_OP_OK)
      return(Retcode);
   pPfxStruc = ppTmpStruc[0];
   //---------------------------------------------------------
   // Set the Appropriate Encryption Algors, Salt length
   //---------------------------------------------------------
   pPfxStruc->PrivIteratCnt = PFX_DEFAULT_ITERAT_CNT;
   pPfxStruc->CertIteratCnt = PFX_DEFAULT_ITERAT_CNT;
   pPfxStruc->PFXPrivSaltLen= PFX_DEFAULT_SALT_LEN;
   pPfxStruc->MACSaltLen    = PFX_DEFAULT_SALT_LEN;
   pPfxStruc->MACIteratCnt  = PFX_DEFAULT_ITERAT_CNT;
   pPfxStruc->PrivKeyPBEEncAlgorID = PKCS12_PBE_SHA_3DESC_CBC_3KEYS;
   pPfxStruc->PrivSaltLen          = 8;
   pPfxStruc->CertPBEEncAlgorID    = PKCS12_PBE_SHA_3DESC_CBC_3KEYS;
   pPfxStruc->CertSaltLen          = 8;

   if(SecurityLevel == PKCS12_MEDIUM_SECURITY)
   {
      //  PK12_CertPBEEncAlgorID(pPfxStruc)    = PKCS12_PBE_SHA_RC2_CBC_128;
      pPfxStruc->CertPBEEncAlgorID    = PKCS12_PBE_SHA_RC4_128;
   }
   else if(SecurityLevel == PKCS12_LOW_SECURITY)
   {
      //  PK12_PrivKeyPBEEncAlgorID(pPfxStruc) = PKCS12_PBE_SHA_3DESC_CBC_3KEYS;;
      pPfxStruc->CertPBEEncAlgorID    = PKCS12_PBE_SHA_RC2_CBC_40;
   }
   //---------------------------------------------------------
   // Convert Certificate List to Bags
   //---------------------------------------------------------
   if((Retcode = CertsListToBags(pPfxStruc, pCertList,
      CertsCnt)) != PKCS12_OP_OK)
   {
      FreePKCS12Struc(pPfxStruc);
      return(Retcode);
   }
   //---------------------------------------------------------
   // Generate the PFX PDU
   //---------------------------------------------------------
   ppTmpDesc[0] = NULL;			// Force Allocate
   if((Retcode = PFX_ToPFXPduDesc(HMEM_CTX_REF1 pPfxStruc,
      ppTmpDesc, 0, 1)) != PKCS12_OP_OK)
   {
      FreePKCS12Struc(pPfxStruc);
      return(Retcode);
   }
   pIdata = ppTmpDesc[0]->ppArr[0];
   //---------------------------------------------------------
   // Transfer buffer to caller, set Descriptor Buffer NULL
   //---------------------------------------------------------
   ppDstBuf[0] = pIdata->Base;
   pDstLen[0]  = pIdata->Len;
   pIdata->Base = NULL;
   pIdata->Len  = 0;
   FreeIDATPARR_Struc(HMEM_CTX_REF1 ppTmpDesc[0]);
   FreePKCS12Struc(pPfxStruc);
   return(PKCS12_OP_OK);
}

extern "C"  int  PKCS12_Encode(X509CERT ** pCertList,
                               int CertsCnt, int PDUType, int SecurityLevel,
                               char* pPwd, int PwdOff, int PwdLen,
                               char** ppDstBuf, int* pDstLen)
{
   //----------------------------------------------------------------
   // Check parameters
   //----------------------------------------------------------------
   switch(PDUType)
   {
   case PKCS12_V1_PDU_TYPE:
      return(PKCS12_V1_Encode(pCertList, CertsCnt, SecurityLevel,
         pPwd, PwdOff, PwdLen, ppDstBuf, pDstLen));

   case PKCS12_V3_PDU_TYPE:
      return(PKCS12_V3_Encode(pCertList, CertsCnt, SecurityLevel,
         pPwd, PwdOff, PwdLen, ppDstBuf, pDstLen));

   default:
      return(PKCS12_PARAM_ERR);
   }
}

#endif // !XH_INTERFACE

#endif //HL_CERT_PKCS12
// end of file ../pkcs12/pkcs12.cpp


#ifdef HL_CERT_PKCS11
#ifdef _WIN32
#include <windows.h>
#include <stdlib.h>
#include <stdio.h>
#if (defined _WIN32) & (_MSC_VER < 1700)
#ifndef _STDINT
#define _STDINT
// MSVC lower than 17.00 does not have stdint.h, assure, all needed types are defined

typedef unsigned __int16 uint16_t;

typedef unsigned __int32 uint32_t;

typedef unsigned __int64 uint64_t;

#endif // !_STDINT
#else
#include <stdint.h>
#endif
#include <stddef.h>
#ifdef _WIN32
#define WIN32_LEAN_AND_MEAN
#include <Windows.h>
#undef WIN32_LEAN_AND_MEAN
#else// Define system-specific HL_* defines here
#ifndef HL_UNIX
#define HL_UNIX

#if (defined __gnu_linux__) || (defined __linux__)
#define HL_LINUX
#endif

#if (defined __APPLE__) && (defined __MACH__)
#define HL_LINUX
#define HL_MACOS
#endif

#ifdef _AIX
#define HL_AIX
#define HL_BIG_ENDIAN
#endif

#ifdef __FreeBSD__
#define HL_FREEBSD
#endif

#if (defined _hpux) || (defined hpux) || (defined __hpux)
#define HL_HPUX
#define HL_BIG_ENDIAN
#endif

#if (defined sun) || (defined __sun)
#define HL_SOLARIS
#endif

#if (defined __arm__) || (defined __aarch64__)
#define HL_LINUX_ARM
#endif

#ifdef __ANDROID__
#define HL_ANDROID
#endif

#endif
#include <hob-unix01.h>
#endif
#ifdef __APPLE__
/* We get target conditionals to keep apart Mac OS, iOS and iOS simulator.
   The conditionals are TARGET_IPHONE_SIMULATOR, TARGET_OS_IPHONE and TARGET_OS_MAC.
   TARGET_IPHONE_SIMULATOR has the highest priority, TARGET_OS_MAC the lowest.
   Always test, if the conditional is 1, as they will be defined as 0, if we 
   are not compiling for the target.
   */
#include <TargetConditionals.h>
#endif

#ifdef HL_ANDROID
#include <netdb.h>
#include <unistd.h>
#include <linux/in.h>
#ifndef SOCKLEN_T
#define SOCKLEN_T      int
#endif
#ifndef SA_FAMILY_T
#define SA_FAMILY_T  short
#endif
#include <sys/endian.h>
#include <asm/ioctls.h>
#include <errno.h>
#endif

#include "hob-encry-1.h"
#include "hob-cert-ext.h"
#ifdef _WIN32
#include <winsock.h>
#endif
#include "hob-cert-err.h"
#include <string.h>
#include "hob-cert-intern.h"

#pragma warning(disable:4996)

#define	DUMP_FILENAME	"hp11cert.dmp"

void DumpString(char * pStr)
{
  FILE * hFile;

  hFile = fopen(DUMP_FILENAME,"a+b");
  fprintf(hFile,"%s\n",pStr);
  fclose(hFile);
}

void DumpStringInt(char * pStr,int i)
{
  FILE * hFile;

  hFile = fopen(DUMP_FILENAME,"a+b");
  fprintf(hFile,"%s %d\n",pStr,i);
  fclose(hFile);
}

//========================================================
// Setup PATH, HOME and WINSCARD_PATH environment
// parameters needed by Kobil mIDentity token for
// PKCS11 access.
//
// Input parameters: char chp_drivechar	Home drive of mIDentity token
// Returns: int Status - 0 o.k., else error occured
//========================================================
int m_setup_midentity_params(char chp_drivechar)
{
  char chl_buf[4096+256];
  int inl_len;

  //--------------------------------------------
  // get current Path, append the kobil elements
  //--------------------------------------------
  inl_len = GetEnvironmentVariableA("PATH",chl_buf,4096);
  if((inl_len != 0) && (chl_buf[inl_len-1] != ';'))
    chl_buf[inl_len++] = ';';			// append delimiter

  chl_buf[inl_len++] = chp_drivechar;		// drive
  memcpy(chl_buf+inl_len,":\\Win32\\pkcs11",14); // first path element
  inl_len += 14;
  chl_buf[inl_len++] = ';';			// append delimiter
  chl_buf[inl_len++] = chp_drivechar;		// drive
  memcpy(chl_buf+inl_len,":\\Win32\\lib",11);	// second path element
  inl_len += 11;
  chl_buf[inl_len++] = ';';			// append delimiter
  chl_buf[inl_len] = 0;				// zero terminate

  if(SetEnvironmentVariableA("PATH",chl_buf) == 0)
    return(-1);
  //---------------------------------------------
  // Set kobil specific environment variables
  //---------------------------------------------
  chl_buf[0] = chp_drivechar;			// drive

  memcpy(chl_buf+1,":\\Win32\\pkcs11",15);
  if(SetEnvironmentVariableA("HOME",chl_buf) == 0)
    return(-2);

  memcpy(chl_buf+1,":\\Win32\\pkcs11\\winscard.dll",28);
  if(SetEnvironmentVariableA("WINSCARD_PATH",chl_buf) == 0)
    return(-3);

  return(0);
}
//=======================================================
// Search for Kobil mIDentity home drive, checks if token
// is present at all.
//
// Input parameters: char * achp_drivechar	Home drive character ptr
// Returns: int Status -  0 token found,
//			> 0 no token found, not present
//=======================================================
int m_scanforkobildrive(char * achp_drivechar)
{
  int i,inl_rc;
  char chl_drvpath[] = "A:\\";
  char chl_volname[256];
  unsigned int unl_drivetype;
  DWORD unl_drivemap;
  DWORD unl_bitmask;
  DWORD unl_maxcomp,unl_flags;
  //----------------------------------------------
  // Get bitmap of drives in system
  //----------------------------------------------
  unl_drivemap = GetLogicalDrives();

  //----------------------------------------------
  // Scan CD-ROM drives for mIDentity volume name
  //----------------------------------------------
  for(i=2;i<26;i++)
  {
    unl_bitmask = 1 << i;
    if((unl_drivemap & unl_bitmask) == 0) // no such drive
      continue;

    chl_drvpath[0] = (char) (i + 'A');		// generate root path for drive

    unl_drivetype = GetDriveTypeA(chl_drvpath);
    if(unl_drivetype != DRIVE_CDROM)	// not a CDROM
      continue;

    inl_rc = GetVolumeInformationA(chl_drvpath,chl_volname,
		sizeof(chl_volname),NULL,&unl_maxcomp,&unl_flags,
		NULL,0);
    if(inl_rc == 0)				// no info, ->not ready
      continue;

    if(_strnicmp(chl_volname,"mIDentity",9) != 0) 
      continue;

    *achp_drivechar = chl_drvpath[0];		// found drive, set return
    return(0);
  }
  *achp_drivechar = 0;				// no drive found
  return(1);
}
//===========================================================
// Load the PKCS11 library DLL, get the function pointers
// and initialize the DLL
//
// Input parameters: ds_pkcs11_struc * adsp_p11struc	Structure to use
//		     char * achp_dllname		Path to the DLL
// Returns: int Status - 0 o.k., else error occured
//===========================================================
static int m_loadpkcs11lib(ds_pkcs11_struc * adsp_p11struc,
		           char * achp_dllname)
{
  int inl_retcode;
  int (*ap_getfunctlist)(void*);
// TEST TEST TEST
//  char chl_buf[4096];
// TEST TEST TEST

  memset(adsp_p11struc,0,sizeof(ds_pkcs11_struc)); // clear structure
  //------------------------------------------------------
  // Load Library DLL, get function list fetch entry point
  //------------------------------------------------------
//  DumpString("Try to load:");
//  DumpString(achp_dllname);

  adsp_p11struc->hlib = LoadLibraryA(achp_dllname);
  if(adsp_p11struc->hlib == NULL)
      return(-1);

  ap_getfunctlist = (int (*)(void*))
     GetProcAddress(adsp_p11struc->hlib,"C_GetFunctionList");
  if(ap_getfunctlist == NULL)
    return(-2);

  //------------------------------------------------------
  // Get functionlist pointer, initialize library
  //------------------------------------------------------
  (*ap_getfunctlist)(&adsp_p11struc->ap_fctlist);
//  printf("Functptr: %08X\n",adsp_p11struc->ap_fctlist);

  inl_retcode =
    (*((CK_FUNCTION_LIST_PTR) adsp_p11struc->ap_fctlist)->C_Initialize)
    (NULL_PTR);					 // Init library
//  printf("RC=%d\n",inl_retcode);
  adsp_p11struc->ul_hsession = 0;		// no session yet

  return(inl_retcode);
}

//=================================================
// Close pkcs11 library, finalize first before close
//
// Input parameters: ds_pkcs11_struc * adsp_p11struc	structure w. handle
// Returns: int Status - 0 o.k., else error
//=================================================
static int m_closepkcs11lib(ds_pkcs11_struc * adsp_p11struc)
{
  if(adsp_p11struc->ap_fctlist != NULL)
    (*((CK_FUNCTION_LIST_PTR) adsp_p11struc->ap_fctlist)->C_Finalize)(NULL);

  if(adsp_p11struc->hlib != NULL)
    FreeLibrary(adsp_p11struc->hlib);
  adsp_p11struc->hlib = NULL;
  return(0);
}
//===================================================
// Check if token has an external authentication path
// Note: Token ID must already be present
//
// Input parameters: ds_pkcs11_struc * adsp_p11struc	PKCS11 structure
// Returns: int Result  > 0 has external authentication path
//		       == 0 no external authentication path
//			< 0 error occured
//===================================================
static int m_checktoken_extauthpath(ds_pkcs11_struc * adsp_p11struc)
{
  int inl_retcode;
  CK_TOKEN_INFO dsl_tokeninfo;
  inl_retcode =
    (*((CK_FUNCTION_LIST_PTR) adsp_p11struc->ap_fctlist)->C_GetTokenInfo)
	          (adsp_p11struc->ul_slotid,&dsl_tokeninfo);
  if(inl_retcode != 0)
  {
//  printf("No TokenInfo available, RC=0x%X\n",inl_retcode);
    return(-1);
  }
  if((dsl_tokeninfo.flags & CKF_PROTECTED_AUTHENTICATION_PATH) != 0)
    return(1);
  return(0);
}

//======================================================
// Ask user for the token PIN, opens a dialog if
// PIN not yet present
//
// Input parameters: ds_pkcs11_struc * adsp_p11struc	PKCS11 structure
//		     char * abyrp_pindll_name		name of pin dll
// Returns: int Status - 0 o.k. else error occured
//==================================================
static int m_get_pkcs11userpin(ds_pkcs11_struc * adsp_p11struc,
			       char * abyrp_pindll_name)
{
  int inl_retcode,inl_length;
  HMODULE hpindll;
  int (*apl_pindlg)(char *, int *);

  if(adsp_p11struc->in_pinlen == 0)
  {
    //-----------------------------------------------
    // Check if PIN given from Environment
    //-----------------------------------------------
    inl_length = GetEnvironmentVariableA("PK11_PIN",
                   adsp_p11struc->by_pinbuffer,
		   sizeof(adsp_p11struc->by_pinbuffer));
    if(inl_length != 0)
    {
      adsp_p11struc->in_pinlen = inl_length;
      return(0);
    }
    //----------------------------------------------
    // Load pin dialog library, execute dialog
    //----------------------------------------------
    hpindll = LoadLibraryA(abyrp_pindll_name);
    if(hpindll == NULL)
      return(-1);

    apl_pindlg = (int (*)(char *, int *))
       GetProcAddress(hpindll,"PinDialog");
    if(apl_pindlg == NULL)
    {
      FreeLibrary(hpindll);
      return(-2);
    }
    inl_length = sizeof(adsp_p11struc->by_pinbuffer);
    inl_retcode = apl_pindlg(adsp_p11struc->by_pinbuffer,&inl_length);
    FreeLibrary(hpindll);

    if(inl_retcode != 0)
      return(-3);
    //-----------------------------------------
    // now we should have the pin in buffer
    //-----------------------------------------
    adsp_p11struc->in_pinlen = inl_length;
    if(inl_length == 0)
      return(-4);
    adsp_p11struc->by_pinbuffer[inl_length] = 0;	// zero terminate

    SetEnvironmentVariableA("PK11_PIN",adsp_p11struc->by_pinbuffer);

  }
  return(0);
}

//==================================================
// Activate token for normal user (login)
// Note: Session must exist, user pin must already be present
//
// Input parameters: ds_pkcs11_struc * adsp_p11struc	PKCS11 structure
//                   char * abyrp_pindll_name		Name of PIN dll
// Returns: int Status - 0 o.k. else error occured
//==================================================
static int m_loginpkcs11session(ds_pkcs11_struc * adsp_p11struc, 
                                char * abyrp_pindll_name)
{
  int inl_retcode;

//    printf("Try to login with PKCS#11-dll internal pin dialog.\n");
  inl_retcode =
      (*((CK_FUNCTION_LIST_PTR) adsp_p11struc->ap_fctlist)->C_Login)
		  (adsp_p11struc->ul_hsession,
		  CKU_USER,
		  (unsigned char *) adsp_p11struc->by_pinbuffer,
		  adsp_p11struc->in_pinlen);
//    printf("Login return-code = %d.\n",inl_retcode);
  if ((inl_retcode == CKR_OK) || (inl_retcode == CKR_USER_ALREADY_LOGGED_IN))
     return(CKR_OK);

  if ((inl_retcode != CKR_FUNCTION_FAILED) && (inl_retcode != CKR_DEVICE_ERROR) &&
      (inl_retcode != CKR_GENERAL_ERROR) && (inl_retcode != CKR_OPERATION_NOT_INITIALIZED))
     return(inl_retcode);

  inl_retcode = m_checktoken_extauthpath(adsp_p11struc);
  if (inl_retcode <= 0)  // has external auth-path
  {
    if (abyrp_pindll_name != NULL)
    {
      inl_retcode = m_get_pkcs11userpin(adsp_p11struc, abyrp_pindll_name);
      if (inl_retcode != 0)
         return(inl_retcode);
    }
  }

//  printf("Try to login with own auth path.\n");
  inl_retcode =
      (*((CK_FUNCTION_LIST_PTR) adsp_p11struc->ap_fctlist)->C_Login)
		  (adsp_p11struc->ul_hsession,
		  CKU_USER,
		  (unsigned char *) adsp_p11struc->by_pinbuffer,
		  adsp_p11struc->in_pinlen);
//    printf("Login return-code = %d.\n",inl_retcode);
  if (inl_retcode == CKR_USER_ALREADY_LOGGED_IN)
     inl_retcode = CKR_OK;
  return(inl_retcode);
}

//===================================================
// Deactivate token for user (logout)
// Note: Session must exist
//
// Input parameters: ds_pkcs11_struc * adsp_p11struc	PKCS11 structure
// Returns: int Status - 0 o.k. else error occured
//==================================================
static int m_logoutpkcs11session(ds_pkcs11_struc * adsp_p11struc)
{
  int inl_retcode;
  inl_retcode = (*((CK_FUNCTION_LIST_PTR) adsp_p11struc->ap_fctlist)->C_Logout)
			(adsp_p11struc->ul_hsession);
//  printf("Logout RC=%d\n",inl_retcode);
  return(inl_retcode);
}

//====================================================
// Open a session with first slot containing a token
//
// Input parameters: ds_pkcs11_struc * adsp_p11struc	PKCS11 structure
// Returns: int Status - 0 o.k., else error occured
//====================================================
static int m_openpkcs11session(ds_pkcs11_struc * adsp_p11struc)
{
  int inl_retcode;
  unsigned long unl_count;

  if(adsp_p11struc->ul_hsession != 0)		// Session already opened
    return(0);

  //------------------------------------------------------
  // Get first Slot-ID with Token present
  //------------------------------------------------------
  unl_count = 1;
  inl_retcode =
    (*((CK_FUNCTION_LIST_PTR) adsp_p11struc->ap_fctlist)->C_GetSlotList)
		  (TRUE,&adsp_p11struc->ul_slotid,&unl_count);

  if(inl_retcode != 0)			// error occured
    return(inl_retcode);

  if(unl_count == 0)			// no slot with token found!
  {
//    printf("No Slot with Token!\n");
    return(-1);
  }
  //------------------------------------------------------
  // Establish session for Slot-ID
  //------------------------------------------------------
  inl_retcode =
    (*((CK_FUNCTION_LIST_PTR) adsp_p11struc->ap_fctlist)->C_OpenSession)
                  (adsp_p11struc->ul_slotid,CKF_SERIAL_SESSION,
                   NULL,NULL,&adsp_p11struc->ul_hsession);
//  printf("RC=%d, hSession=%d\n",inl_retcode,adsp_p11struc->ul_hsession);
  return(inl_retcode);
}

//======================================================
// Close open session with token
//
// Input parameters: ds_pkcs11_struc * adsp_p11struc	PKCS11 structure
// Returns: int Status - 0 o.k., else error occured
//======================================================
extern "C" int m_closepkcs11session(ds_pkcs11_struc * adsp_p11struc)
{
  int inl_retcode = 0;

  if(adsp_p11struc->ul_hsession != 0)
    inl_retcode =
      (*((CK_FUNCTION_LIST_PTR) adsp_p11struc->ap_fctlist)->C_CloseSession)
                    (adsp_p11struc->ul_hsession);
  adsp_p11struc->ul_hsession = 0;
  return(inl_retcode);
}

//============================================================
// Get RSA key ID's for a X509 Certificate object
//
// Input parameters: ds_pkcs11_struc * adsp_p11struc	PKCS11 structure
//		     unsigned long ulp_certid		certificate ID
//		     unsigned long * aulp_pubkeyid	returned public ID / 0
//		     unsigned long * aulp_privkeyid	returned private ID / 0
// Returns: int Status - 0 o.k., else error occured
//============================================================
int m_pkcs11_getcert_keyids(ds_pkcs11_struc * adsp_p11struc,
			    unsigned long ulp_certid,
			    unsigned long * aulp_pubkeyid,
		            unsigned long * aulp_privkeyid)
{
  int inl_retcode;
  unsigned long ull_count;
  char chl_idbuffer[512];

  CK_ATTRIBUTE dsl_attribs[3];
  CK_OBJECT_CLASS inl_objclass;
  CK_OBJECT_HANDLE inl_keyid;
  CK_KEY_TYPE inl_keytype;

  *aulp_pubkeyid = 0;
  *aulp_privkeyid = 0;

  //--------------------------------------------------------
  // Get the Certificate ID as reference for the Key to find
  //--------------------------------------------------------
  dsl_attribs[2].type       = CKA_ID;		// ID for certificate
  dsl_attribs[2].pValue     = chl_idbuffer;	// Destination buffer
  dsl_attribs[2].ulValueLen = sizeof(chl_idbuffer);// size of buffer

  inl_retcode =
    (*((CK_FUNCTION_LIST_PTR) adsp_p11struc->ap_fctlist)->C_GetAttributeValue)
			(adsp_p11struc->ul_hsession,ulp_certid,
			 &dsl_attribs[2],1);
  if(inl_retcode != 0)
    return(inl_retcode);
  //------------------------------------------------------
  // Initialize find attributes for the Public key to find
  //------------------------------------------------------
  inl_objclass = CKO_PUBLIC_KEY;		// search for public key
  inl_keytype  = CKK_RSA;			// key type is RSA

  dsl_attribs[0].type       = CKA_CLASS;
  dsl_attribs[0].pValue     = &inl_objclass;
  dsl_attribs[0].ulValueLen = sizeof(inl_objclass);

  dsl_attribs[1].type       = CKA_KEY_TYPE;
  dsl_attribs[1].pValue     = &inl_keytype;
  dsl_attribs[1].ulValueLen = sizeof(inl_keytype);

  //-----------------------------------------------
  // Initialize object find with attribute template
  //-----------------------------------------------
  inl_retcode =
    (*((CK_FUNCTION_LIST_PTR) adsp_p11struc->ap_fctlist)->C_FindObjectsInit)
			(adsp_p11struc->ul_hsession,dsl_attribs,3);
  if(inl_retcode != 0)
  {
    (*((CK_FUNCTION_LIST_PTR) adsp_p11struc->ap_fctlist)->C_FindObjectsFinal)
		(adsp_p11struc->ul_hsession);
    return(inl_retcode);
  }
  //-------------------------------------
  // Search for associated public RSA key
  //-------------------------------------
  ull_count = 0;
  inl_retcode =
    (*((CK_FUNCTION_LIST_PTR) adsp_p11struc->ap_fctlist)->C_FindObjects)
		(adsp_p11struc->ul_hsession,&inl_keyid,1,&ull_count);
  (*((CK_FUNCTION_LIST_PTR) adsp_p11struc->ap_fctlist)->C_FindObjectsFinal)
		(adsp_p11struc->ul_hsession);
  if((inl_retcode == 0) && (ull_count != 0))
  {
//  printf("Found PUBLIC key, ID=%d\n",inl_keyid);
    *aulp_pubkeyid = inl_keyid;
  }
  //-------------------------------------------------------
  // Initialize find attributes for the private key to find
  //-------------------------------------------------------
  inl_objclass = CKO_PRIVATE_KEY;		// search for private key
  inl_keytype  = CKK_RSA;			// key type is RSA

  dsl_attribs[0].type       = CKA_CLASS;
  dsl_attribs[0].pValue     = &inl_objclass;
  dsl_attribs[0].ulValueLen = sizeof(inl_objclass);

  dsl_attribs[1].type       = CKA_KEY_TYPE;
  dsl_attribs[1].pValue     = &inl_keytype;
  dsl_attribs[1].ulValueLen = sizeof(inl_keytype);

  //-----------------------------------------------
  // Initialize object find with attribute template
  //-----------------------------------------------
  inl_retcode =
    (*((CK_FUNCTION_LIST_PTR) adsp_p11struc->ap_fctlist)->C_FindObjectsInit)
			(adsp_p11struc->ul_hsession,dsl_attribs,3);
  if(inl_retcode != 0)
  {
    (*((CK_FUNCTION_LIST_PTR) adsp_p11struc->ap_fctlist)->C_FindObjectsFinal)
		(adsp_p11struc->ul_hsession);
    return(inl_retcode);
  }
  //--------------------------------------
  // Search for associated private RSA key
  //--------------------------------------
  ull_count = 0;
  inl_retcode =
    (*((CK_FUNCTION_LIST_PTR) adsp_p11struc->ap_fctlist)->C_FindObjects)
		(adsp_p11struc->ul_hsession,&inl_keyid,1,&ull_count);
  (*((CK_FUNCTION_LIST_PTR) adsp_p11struc->ap_fctlist)->C_FindObjectsFinal)
		(adsp_p11struc->ul_hsession);
  if((inl_retcode == 0) && (ull_count != 0))
  {
//  printf("Found PRIVATE key, ID=%d\n",inl_keyid);
    *aulp_privkeyid = inl_keyid;
  }
  return(0);
}
//=============================================================
// Check if a private key can be used for signing
//
// Input parameters: ds_pkcs11_struc * adsp_p11struc	PKCS11 structure
//		     unsigned long   ulp_keyid		key identifier
// Returns: int Result == 0 not usable for signing
//		       <> 0 can be used for signing
//=============================================================
static int m_pkcs11_checkprivkeyforsign(ds_pkcs11_struc * adsp_p11struc,
					unsigned long ulp_keyid)
{
  int inl_retcode;

  CK_MECHANISM dsl_mechanism;

  dsl_mechanism.mechanism      = CKM_RSA_PKCS;
  dsl_mechanism.pParameter     = NULL;
  dsl_mechanism.ulParameterLen = 0;
  //-------------------------------------------------
  // Select RSA SIGN 'Encryption' (with private key!)
  //-------------------------------------------------
  inl_retcode =
    (*((CK_FUNCTION_LIST_PTR) adsp_p11struc->ap_fctlist)->C_SignInit)
			(adsp_p11struc->ul_hsession,
			 &dsl_mechanism,ulp_keyid);
  if(inl_retcode == 0)
    return(1);
  return(0);
}
//=======================================================
// Get ID list of certificates from token
//
// Input parameters: ds_pkcs11_struc * adsp_p11struc	PKCS11 structure
//		     unsigned long * aulrp_certobjidarray Object ID array
//		     int * ainp_arraylen		IN: size of array
//							OUT: found IDs
// Returns: int Status - 0 o.k., else error occured
//======================================================================
int m_get_pkcs11certid_array(ds_pkcs11_struc * adsp_p11struc,
                             unsigned long * aulrp_certobjidarray,
                             int * ainp_arraylen)
{
//  int i;
  int inl_inplen,inl_retcode;
  unsigned long ull_arraylen;
  CK_OBJECT_CLASS inl_objclass;
  CK_ATTRIBUTE dsl_attrib[2];
  CK_CERTIFICATE_TYPE inl_certtype;

  inl_objclass = CKO_CERTIFICATE;		// Class is certificates

  dsl_attrib[0].type       = CKA_CLASS;		// Type of attribute
  dsl_attrib[0].pValue     = &inl_objclass;	// Value of attribute
  dsl_attrib[0].ulValueLen = sizeof(inl_objclass);// Size of value

  inl_certtype   = CKC_X_509;

  dsl_attrib[1].type       = CKA_CERTIFICATE_TYPE; // Type of attribute
  dsl_attrib[1].pValue     = &inl_certtype;	   // Value of attribute
  dsl_attrib[1].ulValueLen = sizeof(inl_certtype); // Size of value

  inl_retcode =
    (*((CK_FUNCTION_LIST_PTR) adsp_p11struc->ap_fctlist)->C_FindObjectsInit)
		  (adsp_p11struc->ul_hsession,dsl_attrib,2);
//printf("Find certtypes init: RC=%d\n",inl_retcode);

  inl_inplen = *ainp_arraylen;
  *ainp_arraylen = 0;
  ull_arraylen = 0;
  inl_retcode =
    (*((CK_FUNCTION_LIST_PTR) adsp_p11struc->ap_fctlist)->C_FindObjects)
		  (adsp_p11struc->ul_hsession,
		   aulrp_certobjidarray,inl_inplen,&ull_arraylen);
//  printf("Find certtypes: RC=%d, Count=%d\n",inl_retcode,ull_arraylen);
  *ainp_arraylen = (int) ull_arraylen;

  (*((CK_FUNCTION_LIST_PTR) adsp_p11struc->ap_fctlist)->C_FindObjectsFinal)
		  (adsp_p11struc->ul_hsession);
  return(inl_retcode);
}

/**
 *  This function returns the ID of a certificate that can be used for client 
 *  authentication, if one exists. The first search criteria is, that there 
 *  is a private key available. Additionally further criteria can be added to 
 *  identify a certain certificate, if more than one certificate exists.
 *
 *  @param  adsp_p11struc    This is the pointer to the current 
 *                           PKCS11 structure in use.
 *  @param  abyrp_label      This pointer to a character array passes a label 
 *                           text to search for as the certificate label of 
 *                           the certificate container used on the Smartcard.
 *  @param  inp_labellen     This integer value contains the size of the label text.
 *  @param  aulp_certid      This pointer to an unsigned long variable is used 
 *                           to return the found certificate ID or the value 0 
 *                           in case that no suitable certificate is found.
 *  @return                  Status of the function processing
 *  <br>                     == 0  o.k.
 *  <br>                     != 0  error condition
 *
 *  @author  L. Schmid, 18.03.2015
 */
extern "C" int m_get_pkcs11_labeledcert_ex(ds_pkcs11_struc * adsp_p11struc,
                                           char * abyrp_label,
                                           int inp_labellen,
                                           unsigned long * aulp_certid)
{
   int inl_index;
   int inl_retcode;
   int inl_certcount;
   unsigned long ull_count;
   unsigned long ull_hkeyid;
   unsigned long ulrl_objidarray[32];
   char chrl_labelbuf[256];
   char chl_idbuffer[512];
   CK_ATTRIBUTE dsl_attribs[4];
   CK_OBJECT_CLASS ull_objclass;
   CK_KEY_TYPE ull_keytype;


   *aulp_certid = 0;
   inl_certcount = 32;
   inl_retcode = m_get_pkcs11certid_array(adsp_p11struc, ulrl_objidarray,
                                          &inl_certcount);
   if (inl_retcode != 0)
      return(inl_retcode);

   // loop through the number of existing certificates
   inl_index = 0;
   while (inl_index < inl_certcount)
   {
     for ( ; ; )  // not a loop
	 {
       // get the label and proof that the certificate can be accessed properly
       dsl_attribs[3].type       = CKA_LABEL;  // label for certificate
       dsl_attribs[3].pValue     = chrl_labelbuf;  // Destination buffer
       dsl_attribs[3].ulValueLen = (sizeof(chrl_labelbuf) - 1);  // size of buffer

       inl_retcode =
         (*((CK_FUNCTION_LIST_PTR) adsp_p11struc->ap_fctlist)->C_GetAttributeValue)
                (adsp_p11struc->ul_hsession, ulrl_objidarray[inl_index],
                 &(dsl_attribs[3]), 1);
       if (inl_retcode != 0)
	      break;
       chrl_labelbuf[dsl_attribs[3].ulValueLen] = '\0';

       // get the Certificate ID as reference for the Key to find
       dsl_attribs[2].type       = CKA_ID;  // ID for certificate
       dsl_attribs[2].pValue     = chl_idbuffer;  // Destination buffer
       dsl_attribs[2].ulValueLen = sizeof(chl_idbuffer);  // size of buffer

       inl_retcode =
         (*((CK_FUNCTION_LIST_PTR) adsp_p11struc->ap_fctlist)->C_GetAttributeValue)
                (adsp_p11struc->ul_hsession, ulrl_objidarray[inl_index],
                 &(dsl_attribs[2]), 1);
       if (inl_retcode != 0)
	      break;

       // initialize find attributes for the key to find
       ull_objclass = CKO_PRIVATE_KEY;  // search for private key
       ull_keytype  = CKK_RSA;  // key type is RSA

       dsl_attribs[0].type       = CKA_CLASS;
       dsl_attribs[0].pValue     = &ull_objclass;
       dsl_attribs[0].ulValueLen = sizeof(ull_objclass);

       dsl_attribs[1].type       = CKA_KEY_TYPE;
       dsl_attribs[1].pValue     = &ull_keytype;
       dsl_attribs[1].ulValueLen = sizeof(ull_keytype);

       // initialize object find with attribute template
       inl_retcode =
         (*((CK_FUNCTION_LIST_PTR) adsp_p11struc->ap_fctlist)->C_FindObjectsInit)
	            (adsp_p11struc->ul_hsession, dsl_attribs, 3);
       if (inl_retcode != 0)
       {
         (*((CK_FUNCTION_LIST_PTR) adsp_p11struc->ap_fctlist)->C_FindObjectsFinal)
                (adsp_p11struc->ul_hsession);
         break;
       }

       // search for associated private RSA key
       ull_count = 0;
       inl_retcode =
         (*((CK_FUNCTION_LIST_PTR) adsp_p11struc->ap_fctlist)->C_FindObjects)
                (adsp_p11struc->ul_hsession, &ull_hkeyid, 1, &ull_count);
         (*((CK_FUNCTION_LIST_PTR) adsp_p11struc->ap_fctlist)->C_FindObjectsFinal)
                (adsp_p11struc->ul_hsession);
       if (inl_retcode != 0)
          break;
       if (ull_count == 0)  // no private key
          break;

       // check for a label to search for
	   if ((inp_labellen > 0) && (abyrp_label != NULL))
	   {
         if ((dsl_attribs[3]).ulValueLen < (unsigned long)inp_labellen)
            break;
         // ToDo note: it would be helpful if the passed string is intended to be a 
		 //            substring of the certificate label, therefore a 'strstr' 
		 //            function has to be used instead of the 'strcmp' function.

         if (strnicmp(chrl_labelbuf, abyrp_label, inp_labellen) != 0)
            break;
       }

       // ToDo note: additional parameters such as the key usage or the extended key 
	   //            usage can be used to identify a suitable client authentication 
	   //            certificate. For this the current certificate has to be retrieved 
	   //            from the card and a certificate structure has to be built from 
	   //            that. The certificate extensions or any other parameters have to 
	   //            be check to find a proper certificate. To do so, additional flags 
	   //            and parameters have to be passed to this function.

	   // fill the return pointer variable
       *aulp_certid = ulrl_objidarray[inl_index];
       break;
	 } // end of for ( ; ; )

     // increment index
     inl_index++;
   } // end of while (inl_index < inl_certcount)
   return(0);
}  // end of int m_get_pkcs11_labeledcert_ex(...)

//======================================================================
// Get ID of a labeled certificate (if it exists)
//
// Input parameters: ds_pkcs11_struc * adsp_p11struc	PKCS11 structure
//		     char * abyrp_label			Label to search for
//		     int    inp_labellen		size of label
//		     unsigned long * aulp_certid	found certificate ID/0
// Returns: int Status - 0 o.k., else error occured
//======================================================================
extern "C" int m_get_pkcs11_labeledcert(ds_pkcs11_struc * adsp_p11struc,
		 	     char * abyrp_label, int inp_labellen,
			     unsigned long * aulp_certid)
{
  char chrl_labelbuf[256];
  int inl_retcode;
  unsigned long ulrl_objidarray[32];
  int inl_certcount;
  int inl_index;

  CK_ATTRIBUTE dsl_attrib;

  *aulp_certid = 0;
  inl_certcount = 32;
  inl_retcode = m_get_pkcs11certid_array(adsp_p11struc,ulrl_objidarray,
			                 &inl_certcount);
  if(inl_retcode != 0)
    return(inl_retcode);

  inl_index = 0;
  while(inl_index < inl_certcount)
  {
    dsl_attrib.type       = CKA_LABEL;		// label for certificate
    dsl_attrib.pValue     = chrl_labelbuf;	// Destination buffer
    dsl_attrib.ulValueLen = sizeof(chrl_labelbuf);// size of buffer

    inl_retcode =
      (*((CK_FUNCTION_LIST_PTR) adsp_p11struc->ap_fctlist)->C_GetAttributeValue)
		    (adsp_p11struc->ul_hsession,ulrl_objidarray[inl_index],
		     &dsl_attrib,1);
    if((inl_retcode == 0) &&
       (dsl_attrib.ulValueLen >= (unsigned long) inp_labellen))
    {
      if(strnicmp(chrl_labelbuf,abyrp_label,inp_labellen) == 0)
      {
        *aulp_certid = ulrl_objidarray[inl_index];
        return(0);    
      }
    }
    inl_index++;
  }
  return(0);
}
//======================================================================
// Get Attribute bits of a public/private key ID
//
// Input parameters: ds_pkcs11_struc * adsp_p11struc	PKCS11 structure
//		     unsigned long ulp_keyid		key identifier
//		     int *  ainp_flags			returned:
//							Bit 0: 1-encrypt
//							Bit 1: 1-decrypt
//							Bit 2: 1-sign
// Returns: int Status - 0 o.k., else error occured
//======================================================================
int m_pkcs11_get_keyflags(ds_pkcs11_struc * adsp_p11struc,
		          unsigned long ulp_keyid, int * ainp_flags)
{
  int inl_retcode;
  int inl_result;
  CK_ATTRIBUTE dsl_attrib;

  *ainp_flags = 0;

  dsl_attrib.type       = CKA_ENCRYPT;		// encryption flag
  dsl_attrib.pValue     = &inl_result;		// variable to set
  dsl_attrib.ulValueLen = sizeof(inl_result);	// size of variable

  inl_retcode =
    (*((CK_FUNCTION_LIST_PTR) adsp_p11struc->ap_fctlist)->C_GetAttributeValue)
		  (adsp_p11struc->ul_hsession,ulp_keyid,
		   &dsl_attrib,1);
  if((inl_retcode == 0) && (dsl_attrib.pValue != 0))
    *ainp_flags |= 0x01;

  dsl_attrib.type       = CKA_DECRYPT;		// decryption flag
  dsl_attrib.pValue     = &inl_result;		// variable to set
  dsl_attrib.ulValueLen = sizeof(inl_result);	// size of variable

  inl_retcode =
    (*((CK_FUNCTION_LIST_PTR) adsp_p11struc->ap_fctlist)->C_GetAttributeValue)
		  (adsp_p11struc->ul_hsession,ulp_keyid,
		   &dsl_attrib,1);
  if((inl_retcode == 0) && (dsl_attrib.pValue != 0))
    *ainp_flags |= 0x02;

  dsl_attrib.type       = CKA_SIGN;		// signature flag
  dsl_attrib.pValue     = &inl_result;		// variable to set
  dsl_attrib.ulValueLen = sizeof(inl_result);	// size of variable

  inl_retcode =
    (*((CK_FUNCTION_LIST_PTR) adsp_p11struc->ap_fctlist)->C_GetAttributeValue)
		  (adsp_p11struc->ul_hsession,ulp_keyid,
		   &dsl_attrib,1);
  if((inl_retcode == 0) && (dsl_attrib.pValue != 0))
    *ainp_flags |= 0x04;
  return(0);
}
//=============================================================
// Get list of certificate IDs that have a private key that can
// be used for signing.
//
// Input parameters: ds_pkcs11_struc * adsp_p11struc	PKCS11 structure
//		     unsigned long *  aulrp_certid_array array for IDs
//		     int *  ainp_arraysize		IN: size of array
//							OUT: number of cert IDs
// Returns: int Status - 0 o.k., else error occured
//======================================================================
int m_pkcs11_get_priv_sign_certlist(ds_pkcs11_struc * adsp_p11struc,
		                    unsigned long * aulrp_certid_array,
				    int * ainp_arraysize)
{
  int inl_retcode;
  int inl_certcount;
  int inl_dstlen;
  int inl_srcindex,inl_dstindex;
  int inl_privcertscount;
  int inl_flags;
  unsigned long ull_pubkeyid,ull_privkeyid;
  unsigned long ull_certid;
  unsigned long ulrl_objidarray[32];

  inl_dstlen = *ainp_arraysize;
  *ainp_arraysize = 0;
  inl_privcertscount = 0;
  //--------------------------------------------------
  // Fetch list of certificates
  //--------------------------------------------------
  inl_certcount = 32;
  inl_retcode = m_get_pkcs11certid_array(adsp_p11struc,ulrl_objidarray,
			                 &inl_certcount);
  if(inl_retcode != 0)
    return(inl_retcode);

  inl_srcindex = 0;
  inl_dstindex = 0;
  while(inl_srcindex < inl_certcount)
  {
    ull_certid = ulrl_objidarray[inl_srcindex];
    inl_retcode = m_pkcs11_getcert_keyids(adsp_p11struc,
			    ull_certid, &ull_pubkeyid, &ull_privkeyid);
    if((inl_retcode == 0) && (ull_privkeyid != 0))
    {
      m_pkcs11_get_keyflags(adsp_p11struc,ull_privkeyid,&inl_flags);
      if((inl_flags & 0x04) != 0)
      {
        inl_retcode = m_pkcs11_checkprivkeyforsign(adsp_p11struc,
					           ull_privkeyid);
        if(inl_retcode != 0)
        {
//        printf("Found cert for signing, ID: %d\n",ull_certid);
          inl_privcertscount++;        
          aulrp_certid_array[inl_dstindex++] = ull_certid;
          if(inl_dstindex >= inl_dstlen)
          {
            *ainp_arraysize = inl_privcertscount;
            return(0);
          }
        }
      }
    }
    inl_srcindex++;
  }
  *ainp_arraysize = inl_privcertscount;
  return(0);
}
//=============================================================
// Get certificate that has a private key that can be used for signing
// for VPN usage.
//
// Input parameters: ds_pkcs11_struc * adsp_p11struc	PKCS11 structure
//		     unsigned long * aulp_certid	ID of certificate/0
// Returns: int Status - 0 o.k., else error occured
//======================================================================
int m_pkcs11_get_vpn_priv_sign_cert(ds_pkcs11_struc * adsp_p11struc,
		                    unsigned long * aulp_certid)
{
  int inl_retcode;
  int inl_arraylen;

  *aulp_certid = 0;

  inl_arraylen = 1;
  inl_retcode = m_pkcs11_get_priv_sign_certlist(adsp_p11struc,
		                                aulp_certid,&inl_arraylen);
  return(inl_retcode);
}

//======================================================================
// Get list of certificate IDs that have NO private key i.e.
// CA and SubCA certificates.
//
// Input parameters: ds_pkcs11_struc * adsp_p11struc	PKCS11 structure
//		     unsigned long * aulrp_certid_array	array for IDs
//		     int *  ainp_arraysize		IN: size of array
//							OUT: number of cert IDs
// Returns: int Status - 0 o.k., else error occured
//======================================================================
int m_pkcs11_get_ca_subca_certlist(ds_pkcs11_struc * adsp_p11struc,
		                   unsigned long * aulrp_certid_array,
				   int * ainp_arraysize)
{
  int inl_retcode;
  int inl_certcount;
  int inl_dstlen;
  int inl_srcindex,inl_dstindex;
  int inl_cacertscount;
  unsigned long ull_certid;
  unsigned long ull_pubkeyid,ull_privkeyid;
  unsigned long ulrl_objidarray[32];

  inl_dstlen = *ainp_arraysize;
  *ainp_arraysize = 0;
  inl_cacertscount = 0;
  //--------------------------------------------------
  // Fetch list of certificates
  //--------------------------------------------------
  inl_certcount = 32;
  inl_retcode = m_get_pkcs11certid_array(adsp_p11struc,ulrl_objidarray,
			                 &inl_certcount);
  if(inl_retcode != 0)
    return(inl_retcode);

  inl_srcindex = 0;
  inl_dstindex = 0;
  while(inl_srcindex < inl_certcount)
  {
    ull_certid = ulrl_objidarray[inl_srcindex];
    inl_retcode = m_pkcs11_getcert_keyids(adsp_p11struc,
			    ull_certid, &ull_pubkeyid, &ull_privkeyid);
    if((inl_retcode == 0) && (ull_privkeyid == 0))
    {
//    printf("Found CA/SubCA cert, ID: %d\n",ull_certid);
      inl_cacertscount++;        
      aulrp_certid_array[inl_dstindex++] = ull_certid;
      if(inl_dstindex >= inl_dstlen)
      {
        *ainp_arraysize = inl_cacertscount;
        return(0);
      }
    }
    inl_srcindex++;
  }
  *ainp_arraysize = inl_cacertscount;
  return(0);
}
//======================================================================
// Check if certificate IDs that have NO private key i.e.
// CA and SubCA certificates are present.
//
// Input parameters: ds_pkcs11_struc * adsp_p11struc	PKCS11 structure
// Returns: int Result -  > 0 CA/SubCA certificates are present
//			 == 0 No CA/SubCA certificates found
//			  < 0 error occured 
//======================================================================
int m_pkcs11_check_ca_subca_certs(ds_pkcs11_struc * adsp_p11struc)
{
  int inl_retcode;
  int inl_certscount;
  unsigned long ulrl_certid_array[32];

  inl_certscount = 32;
  inl_retcode = m_pkcs11_get_ca_subca_certlist(adsp_p11struc,
			                       ulrl_certid_array,
				               &inl_certscount);
  if(inl_retcode != 0)
    return(-1);
  if(inl_certscount == 0)
    return(0);
  return(1);
}

//============================================================
// Get ID of a X509 Certificate object with RSA key to use,
// if requested check for a specific issuer (ASN.1 RDN of issuer)
//
// Input parameters: ds_pkcs11_struc * adsp_p11struc	PKCS11 structure
//		     char * achp_issuer			RDN of issuer / NULL
//		     int inp_issuerlen			size of RDN / 0
//		     unsigned long * aulp_certid	returned ID / 0
// Returns: int Status - 0 o.k., else error occured
//============================================================
static int m_findpkcs11_x509rsacertificate(ds_pkcs11_struc * adsp_p11struc,
				    char * achp_issuer, int inp_issuerlen,
		        	    unsigned long * aulp_certid)
{
  int inl_retcode;
  unsigned long ull_count;
  char chl_idbuffer[512];

  CK_ATTRIBUTE dsl_attribs[3];
  CK_OBJECT_CLASS ull_objclass;
  CK_CERTIFICATE_TYPE ull_certtype;
  CK_OBJECT_HANDLE ull_certid,ull_keyid;
  CK_KEY_TYPE ull_keytype;

  *aulp_certid = 0;
  //------------------------------------------------
  // Setup find attributes template for certificate
  //------------------------------------------------
  ull_objclass = CKO_CERTIFICATE;		// certificate object
  ull_certtype = CKC_X_509; 			// X509 certificate

  dsl_attribs[0].type       = CKA_CLASS;
  dsl_attribs[0].pValue     = &ull_objclass;
  dsl_attribs[0].ulValueLen = sizeof(ull_objclass);

  dsl_attribs[1].type       = CKA_CERTIFICATE_TYPE;
  dsl_attribs[1].pValue     = &ull_certtype;
  dsl_attribs[1].ulValueLen = sizeof(ull_certtype);

  dsl_attribs[2].type       = CKA_ISSUER;
  dsl_attribs[2].pValue     = achp_issuer;
  dsl_attribs[2].ulValueLen = inp_issuerlen;

  ull_count = 2;
  if(achp_issuer != NULL)
    ull_count = 3;
  //------------------------------------------------
  // Initialize object find with attributes template
  //------------------------------------------------
  inl_retcode =
    (*((CK_FUNCTION_LIST_PTR) adsp_p11struc->ap_fctlist)->C_FindObjectsInit)
		   (adsp_p11struc->ul_hsession,dsl_attribs,ull_count);
  if(inl_retcode != 0)
  {
    (*((CK_FUNCTION_LIST_PTR) adsp_p11struc->ap_fctlist)->C_FindObjectsFinal)
	(adsp_p11struc->ul_hsession);
    return(inl_retcode);
  }
  //------------------------------------------------
  // Find matching certificate object
  //------------------------------------------------
  inl_retcode =
    (*((CK_FUNCTION_LIST_PTR) adsp_p11struc->ap_fctlist)->C_FindObjects)
		  (adsp_p11struc->ul_hsession,&ull_certid,1,&ull_count);
  (*((CK_FUNCTION_LIST_PTR) adsp_p11struc->ap_fctlist)->C_FindObjectsFinal)
	(adsp_p11struc->ul_hsession);
  if(inl_retcode != 0)
    return(inl_retcode);
  if(ull_count == 0)
  {
    return(0);
  }
  //--------------------------------------------------------
  // Get the Certificate ID as reference for the Key to find
  //--------------------------------------------------------
  dsl_attribs[2].type       = CKA_ID;		// ID for certificate
  dsl_attribs[2].pValue     = chl_idbuffer;	// Destination buffer
  dsl_attribs[2].ulValueLen = sizeof(chl_idbuffer);// size of buffer

  inl_retcode =
    (*((CK_FUNCTION_LIST_PTR) adsp_p11struc->ap_fctlist)->C_GetAttributeValue)
			(adsp_p11struc->ul_hsession,ull_certid,
			 &dsl_attribs[2],1);
  if(inl_retcode != 0)
    return(inl_retcode);
  //-----------------------------------------------
  // Initialize find attributes for the key to find
  //-----------------------------------------------
  ull_objclass = CKO_PUBLIC_KEY;		// search for public key
  ull_keytype  = CKK_RSA;			// key type is RSA

  dsl_attribs[0].type       = CKA_CLASS;
  dsl_attribs[0].pValue     = &ull_objclass;
  dsl_attribs[0].ulValueLen = sizeof(ull_objclass);

  dsl_attribs[1].type       = CKA_KEY_TYPE;
  dsl_attribs[1].pValue     = &ull_keytype;
  dsl_attribs[1].ulValueLen = sizeof(ull_keytype);

  //-----------------------------------------------
  // Initialize object find with attribute template
  //-----------------------------------------------
  inl_retcode =
    (*((CK_FUNCTION_LIST_PTR) adsp_p11struc->ap_fctlist)->C_FindObjectsInit)
			(adsp_p11struc->ul_hsession,dsl_attribs,3);
  if(inl_retcode != 0)
  {
    (*((CK_FUNCTION_LIST_PTR) adsp_p11struc->ap_fctlist)->C_FindObjectsFinal)
		(adsp_p11struc->ul_hsession);
    return(inl_retcode);
  }
  //-------------------------------------
  // Search for associated public RSA key
  //-------------------------------------
  ull_count = 0;
  inl_retcode =
    (*((CK_FUNCTION_LIST_PTR) adsp_p11struc->ap_fctlist)->C_FindObjects)
		(adsp_p11struc->ul_hsession,&ull_keyid,1,&ull_count);
  (*((CK_FUNCTION_LIST_PTR) adsp_p11struc->ap_fctlist)->C_FindObjectsFinal)
		(adsp_p11struc->ul_hsession);
  if(inl_retcode != 0)
    return(inl_retcode);
  if(ull_count != 0)
    *aulp_certid = ull_certid;
  return(0);
}

//======================================================
// Extract X509 certificate from certificate object
// Note: If destination is NULL, required size will be returned
//
// Input Parameters: ds_pkcs11_struc * adsp_p11struc	PKCS11 structure
//		     unsigned long ulp_hcert		object ID
//		     char * achp_certbuf		allocated buffer
//		     int * ainp_certlen			size of certificate
// Returns: int Status - 0 o.k., else error occured
//======================================================
extern "C" int m_extract_pkcs11cert(ds_pkcs11_struc * adsp_p11struc,
			        unsigned long ulp_hcert, char * achp_certbuf,
			        int * ainp_certlen)
{
  int inl_retcode;

  CK_ATTRIBUTE dsl_attrib;
  //---------------------------------------------
  // Query size of certificate first
  //---------------------------------------------
  dsl_attrib.type       = CKA_VALUE;		// Type of attribute
  dsl_attrib.pValue     = NULL;			// no buffer
  dsl_attrib.ulValueLen = 0;			// Size of value to query

  inl_retcode =
    (*((CK_FUNCTION_LIST_PTR) adsp_p11struc->ap_fctlist)->C_GetAttributeValue)
		  (adsp_p11struc->ul_hsession,
		   ulp_hcert,&dsl_attrib,1);
//  printf("RC=%d, Size=%d\n",inl_retcode,dsl_attrib.ulValueLen);
  if(inl_retcode != 0)
    return(inl_retcode);

  if(dsl_attrib.ulValueLen == 0)
    return(-1);
  //---------------------------------------------
  // Check if buffer was given
  //---------------------------------------------
  if(achp_certbuf == NULL)
  {
    *ainp_certlen = dsl_attrib.ulValueLen;	// report size needed
    return(0);
  }
  //---------------------------------------------
  // Retrieve certificate to buffer
  //---------------------------------------------
  dsl_attrib.type       = CKA_VALUE;		// Type of attribute
  dsl_attrib.pValue     = achp_certbuf;		// given buffer
  dsl_attrib.ulValueLen = *ainp_certlen;	// Size of buffer

  inl_retcode =
    (*((CK_FUNCTION_LIST_PTR) adsp_p11struc->ap_fctlist)->C_GetAttributeValue)
		  (adsp_p11struc->ul_hsession,
		   ulp_hcert,&dsl_attrib,1);
  if(inl_retcode != 0)
    return(inl_retcode);

  *ainp_certlen  = dsl_attrib.ulValueLen;
  return(0);
}

//======================================================
// Extract X509 certificate's subject from certificate object
// Note: If destination is NULL, required size will be returned
//
// Input Parameters: ds_pkcs11_struc * adsp_p11struc	PKCS11 structure
//		     unsigned long ulp_hcert		object ID
//		     char * achp_subjbuf		allocated buffer
//		     int * ainp_subjlen			size of subject
// Returns: int Status - 0 o.k., else error occured
//======================================================
extern "C" int m_extract_pkcs11cert_subj(ds_pkcs11_struc * adsp_p11struc,
			        unsigned long ulp_hcert, char * achp_subjbuf,
			        int * ainp_subjlen)
{
  int inl_retcode;

  CK_ATTRIBUTE dsl_attrib;
  //---------------------------------------------
  // Query size of subject first
  //---------------------------------------------
  dsl_attrib.type       = CKA_SUBJECT;		// Type of attribute
  dsl_attrib.pValue     = NULL;			// no buffer
  dsl_attrib.ulValueLen = 0;			// Size of value to query

  inl_retcode =
    (*((CK_FUNCTION_LIST_PTR) adsp_p11struc->ap_fctlist)->C_GetAttributeValue)
		  (adsp_p11struc->ul_hsession,
		   ulp_hcert,&dsl_attrib,1);
//  printf("RC=%d, Size=%d\n",inl_retcode,dsl_attrib.ulValueLen);
  if(inl_retcode != 0)
    return(inl_retcode);

  if(dsl_attrib.ulValueLen == 0)
    return(-1);
  //---------------------------------------------
  // Check if buffer was given
  //---------------------------------------------
  if(achp_subjbuf == NULL)
  {
    *ainp_subjlen = dsl_attrib.ulValueLen;	// report size needed
    return(0);
  }
  //---------------------------------------------
  // Retrieve certificate to buffer
  //---------------------------------------------
  dsl_attrib.type       = CKA_SUBJECT;		// Type of attribute
  dsl_attrib.pValue     = achp_subjbuf;		// given buffer
  dsl_attrib.ulValueLen = *ainp_subjlen;	// Size of buffer

  inl_retcode =
    (*((CK_FUNCTION_LIST_PTR) adsp_p11struc->ap_fctlist)->C_GetAttributeValue)
		  (adsp_p11struc->ul_hsession,
		   ulp_hcert,&dsl_attrib,1);
  if(inl_retcode != 0)
    return(inl_retcode);

  *ainp_subjlen  = dsl_attrib.ulValueLen;
  return(0);
}

//=====================================================================
// Get rsa public/private key object ID for given certificate object ID
//
// Input parameters: ds_pkcs11_struc * adsp_p11struc	PKCS11 structure
//		     unsigned long ulp_certobjid	Certificate object ID
//		     int inp_keytype			0-public, else private
//		     unsigned long * aulp_keyobjid	returned object ID/0
// Returns: int Status - 0 o.k., else error occured
//=====================================================================
static int m_get_pkcs11rsakeyforcert(ds_pkcs11_struc * adsp_p11struc,
		    	      unsigned long ulp_certobjid, int inp_keytype,
			      unsigned long * aulp_keyobjid)
{
  int inl_retcode;
  unsigned long ull_count;
  char chl_idbuffer[512];

  CK_ATTRIBUTE dsl_attribs[3];
  CK_OBJECT_CLASS ull_objclass;
  CK_OBJECT_HANDLE ull_objhandle;
  CK_KEY_TYPE ull_keytype;

  *aulp_keyobjid = 0;

  //--------------------------------------------------------
  // Get the Certificate ID as reference for the Key to find
  //--------------------------------------------------------
  dsl_attribs[2].type       = CKA_ID;		// ID for certificate
  dsl_attribs[2].pValue     = chl_idbuffer;	// Destination buffer
  dsl_attribs[2].ulValueLen = sizeof(chl_idbuffer);// size of buffer

  inl_retcode =
    (*((CK_FUNCTION_LIST_PTR) adsp_p11struc->ap_fctlist)->C_GetAttributeValue)
			(adsp_p11struc->ul_hsession,ulp_certobjid,
			 &dsl_attribs[2],1);
  if(inl_retcode != 0)
    return(inl_retcode);
  //-----------------------------------------------
  // Initialize find attributes for the key to find
  //-----------------------------------------------
  if(inp_keytype == 0)
    ull_objclass = CKO_PUBLIC_KEY;		// search for public key
  else
    ull_objclass = CKO_PRIVATE_KEY;		// search for private key

  ull_keytype = CKK_RSA;			// key type is RSA

  dsl_attribs[0].type       = CKA_CLASS;
  dsl_attribs[0].pValue     = &ull_objclass;
  dsl_attribs[0].ulValueLen = sizeof(ull_objclass);

  dsl_attribs[1].type       = CKA_KEY_TYPE;
  dsl_attribs[1].pValue     = &ull_keytype;
  dsl_attribs[1].ulValueLen = sizeof(ull_keytype);

  //-----------------------------------------------
  // Initialize object find with attribute template
  //-----------------------------------------------
  inl_retcode =
    (*((CK_FUNCTION_LIST_PTR)adsp_p11struc->ap_fctlist)->C_FindObjectsInit)
			(adsp_p11struc->ul_hsession,dsl_attribs,3);
  if(inl_retcode != 0)
  {
    (*((CK_FUNCTION_LIST_PTR) adsp_p11struc->ap_fctlist)->C_FindObjectsFinal)
		(adsp_p11struc->ul_hsession);
    return(inl_retcode);
  }
  //---------------------------------------------
  // Search for associated public/private RSA key
  //---------------------------------------------
  ull_count = 0;
  inl_retcode =
    (*((CK_FUNCTION_LIST_PTR) adsp_p11struc->ap_fctlist)->C_FindObjects)
		(adsp_p11struc->ul_hsession,&ull_objhandle,1,&ull_count);
  (*((CK_FUNCTION_LIST_PTR) adsp_p11struc->ap_fctlist)->C_FindObjectsFinal)
		(adsp_p11struc->ul_hsession);
  if(inl_retcode != 0)
    return(inl_retcode);
  if(ull_count != 0)
    *aulp_keyobjid = ull_objhandle;
  return(0);
}

//======================================================================
// Get modulus size in bits of a RSA public/private key
//
// Input parameters: ds_pkcs11_struc * adsp_p11struc	PKCS11 structure
//		     unsigned long ulp_keyobjid		Object ID of key
//		     unsigned long * aulp_bitlen	Size returned
// Returns: int Status - 0 o.k., else error occured
//======================================================================
static int m_get_pkcs11rsakeylen(ds_pkcs11_struc * adsp_p11struc,
			          unsigned long ulp_keyobjid,
		                  unsigned long * aulp_bitlen)
{
  int inl_retcode;
  CK_ATTRIBUTE dsl_attrib;
  CK_ULONG ull_modulussize;

  dsl_attrib.type       = CKA_MODULUS_BITS; 
  dsl_attrib.pValue     = &ull_modulussize;
  dsl_attrib.ulValueLen = sizeof(ull_modulussize);

  inl_retcode =
    (*((CK_FUNCTION_LIST_PTR)adsp_p11struc->ap_fctlist)->C_GetAttributeValue)
                    (adsp_p11struc->ul_hsession,ulp_keyobjid,&dsl_attrib,1);
  if(inl_retcode != 0)
    return(inl_retcode);
  *aulp_bitlen = ull_modulussize;
// HACK HACK HACK:
  if((ull_modulussize & 0x01) != 0)	// Wrong length, bytes +1!
  {
    *aulp_bitlen = (ull_modulussize-1) * 8;
  }
  return(0);
}
//======================================================================
// Get modulus size in byte of a RSA public key for given certificate
//
// Input parameters: ds_pkcs11_struc * adsp_p11struc	PKCS11 structure
//		     unsigned long ulp_certobjid	Object ID of cert.
//		     int * ainp_len			Size returned in byte!
// Returns: int Status - 0 o.k., else error occured
//======================================================================
extern "C" int m_get_pkcs11rsakeylenforcert(HMEM_CTX_DEF ds_pkcs11_struc * adsp_p11struc,
			         unsigned long ulp_certobjid, int * ainp_len)
{
  int inl_retcode;
  int iml_certlen;
  char * abyrl_pbuf;
  unsigned long ull_keylen;
  unsigned long ull_hpubkeyobj;
  X509CERT * adsl_pcertstruc;
  RSA_STRUC * adsl_prsastruc;
  DSA_STRUC * adsl_tmpdsastruc;
  //--------------------------------------------
  // 1. Get public key ID for given certificate
  //--------------------------------------------
  inl_retcode = m_get_pkcs11rsakeyforcert(adsp_p11struc,
                      ulp_certobjid,0,&ull_hpubkeyobj);
  if (inl_retcode != 0)
     return(inl_retcode);
  //-----------------------------------------------------
  // 2. Check whether a public key was found on the Token
  //-----------------------------------------------------
  if (ull_hpubkeyobj == 0)
  {
    //------------------------------------------------------
    // 3. Extract the key length from the certificate itself
    //------------------------------------------------------
    // Get length of certificate, allocate buffer
    inl_retcode = m_extract_pkcs11cert(adsp_p11struc,
                    ulp_certobjid, NULL, &iml_certlen);
    if (inl_retcode != 0)
       return(inl_retcode);
    abyrl_pbuf = BIT8_ARRAY_ALLOC(HMEM_CTX_REF, iml_certlen);
    if (abyrl_pbuf == NULL)
    {
      inl_retcode = TO_CERTS_CERTREQ_ALLOC_ERR;
      return(inl_retcode);
    }
    // Fetch certificate and extract key size directly from certificate 
    inl_retcode = m_extract_pkcs11cert(adsp_p11struc,
                    ulp_certobjid, abyrl_pbuf, &iml_certlen);
    if (inl_retcode != 0)
       return(inl_retcode);

    inl_retcode = FromASN1CertToCertStrucEX(HMEM_CTX_REF1 
                      abyrl_pbuf, 0, iml_certlen, 0, 0x03,
                      NULL, 0, &adsl_pcertstruc);
    if (inl_retcode != 0)
       return(inl_retcode);

    if ((adsl_pcertstruc->PublicKeyType) == RSA_PUBLIC_ALGOR)
    {
      inl_retcode = FromArrayDescToRSAPubParams(HMEM_CTX_REF1
                        adsl_pcertstruc->SubjPubKeyParVal, &adsl_prsastruc);
      if (inl_retcode != ASN1_OP_OK)
         return(inl_retcode);

      ull_keylen = RSA_BitSize(adsl_prsastruc);
      if (ull_keylen <= 0)
         return(ASN1_DEC_PUB_KEY_RSA_VAL_ERR);
    }
    else if ((adsl_pcertstruc->PublicKeyType) == DSA_PUBLIC_ALGOR)
    {
      inl_retcode = FromArrayDescToDSAPubParams(HMEM_CTX_REF1
	      	  		adsl_pcertstruc->SubjPubKeyParVal, &adsl_tmpdsastruc);
      if (inl_retcode != ASN1_OP_OK)
         return(inl_retcode);
      ull_keylen = DSA_BitSize(adsl_tmpdsastruc);
      if (ull_keylen <= 0)
         return(ASN1_DEC_PUB_KEY_DSA_VAL_ERR);
    }
    else
       return(ASN1_GET_ALG_PARAM_ERR);
  }
  else
  {
    //---------------------------------------------------
    // 4. Get length of public key for Token ID from cert
    //---------------------------------------------------
    inl_retcode = m_get_pkcs11rsakeylen(adsp_p11struc,ull_hpubkeyobj,
                                        &ull_keylen);
    if (inl_retcode != 0)
       return(inl_retcode);
  }
  *ainp_len = (ull_keylen+7)/8;  // round up if needed.
  return(0);
}
//==========================================================
// Sign given data with RSA private key for a certificate ID
//
// Input parameters: ds_pkcs11_struc * adsp_p11struc	PKCS11 structure
//		     unsigned long ulp_certobjid	Certificate ID
//		     char * achp_inpbuf			Data to sign
//		     int inp_inplen			size of data to sign
//		     char * achp_outpbuf		destination buffer
//		     unsigned long * aulp_outplen	size of buffer/result
// Returns: int Status - 0 o.k., else error occured
//==========================================================
static int m_pkcs11_rsasigndataforcert(ds_pkcs11_struc * adsp_p11struc,
			               unsigned long ulp_certobjid,
			               char * achp_inpbuf, int inp_inplen,
			               char * achp_outpbuf,
				       unsigned long * aulp_outplen)
{
  int inl_retcode;
  unsigned long ull_hkeyid,ull_count;
  char chl_idbuffer[512];

  CK_ATTRIBUTE dsl_attribs[3];
  CK_OBJECT_CLASS ull_objclass;
//  CK_OBJECT_HANDLE ull_objhandle;
  CK_KEY_TYPE ull_keytype;
  CK_MECHANISM dsl_mechanism;

  //--------------------------------------------------------
  // Get the Certificate ID as reference for the Key to find
  //--------------------------------------------------------
  dsl_attribs[2].type       = CKA_ID;		// ID for certificate
  dsl_attribs[2].pValue     = chl_idbuffer;	// Destination buffer
  dsl_attribs[2].ulValueLen = sizeof(chl_idbuffer);// size of buffer

  inl_retcode =
    (*((CK_FUNCTION_LIST_PTR) adsp_p11struc->ap_fctlist)->C_GetAttributeValue)
			(adsp_p11struc->ul_hsession,ulp_certobjid,
			 &dsl_attribs[2],1);
  if(inl_retcode != 0)
    return(inl_retcode);
  //-----------------------------------------------
  // Initialize find attributes for the key to find
  //-----------------------------------------------
  ull_objclass = CKO_PRIVATE_KEY;		// search for private key
  ull_keytype  = CKK_RSA;			// key type is RSA

  dsl_attribs[0].type       = CKA_CLASS;
  dsl_attribs[0].pValue     = &ull_objclass;
  dsl_attribs[0].ulValueLen = sizeof(ull_objclass);

  dsl_attribs[1].type       = CKA_KEY_TYPE;
  dsl_attribs[1].pValue     = &ull_keytype;
  dsl_attribs[1].ulValueLen = sizeof(ull_keytype);

  //-----------------------------------------------
  // Initialize object find with attribute template
  //-----------------------------------------------
  inl_retcode =
    (*((CK_FUNCTION_LIST_PTR) adsp_p11struc->ap_fctlist)->C_FindObjectsInit)
			(adsp_p11struc->ul_hsession,dsl_attribs,3);
  if(inl_retcode != 0)
  {
    (*((CK_FUNCTION_LIST_PTR) adsp_p11struc->ap_fctlist)->C_FindObjectsFinal)
		(adsp_p11struc->ul_hsession);
    return(inl_retcode);
  }
  //--------------------------------------
  // Search for associated private RSA key
  //--------------------------------------
  ull_count = 0;
  inl_retcode =
    (*((CK_FUNCTION_LIST_PTR) adsp_p11struc->ap_fctlist)->C_FindObjects)
		(adsp_p11struc->ul_hsession,&ull_hkeyid,1,&ull_count);
  (*((CK_FUNCTION_LIST_PTR) adsp_p11struc->ap_fctlist)->C_FindObjectsFinal)
		(adsp_p11struc->ul_hsession);
  if(inl_retcode != 0)
    return(inl_retcode);
  if(ull_count == 0)			// no private key, strange!!
    return(-2);
  //------------------------------------------
  // Found RSA private key, initialize signing
  //------------------------------------------
  dsl_mechanism.mechanism      = CKM_RSA_PKCS;
  dsl_mechanism.pParameter     = NULL;
  dsl_mechanism.ulParameterLen = 0;

  //-------------------------------------------------
  // Select RSA SIGN 'Encryption' (with private key!)
  //-------------------------------------------------
  inl_retcode =
    (*((CK_FUNCTION_LIST_PTR) adsp_p11struc->ap_fctlist)->C_SignInit)
			(adsp_p11struc->ul_hsession,
			 &dsl_mechanism,ull_hkeyid);
  if(inl_retcode != 0 && inl_retcode != 0x90)
    return(inl_retcode);

  inl_retcode = (*((CK_FUNCTION_LIST_PTR) adsp_p11struc->ap_fctlist)->C_Sign)
			(adsp_p11struc->ul_hsession,
			 (unsigned char *) achp_inpbuf, inp_inplen,
			 (unsigned char *) achp_outpbuf,aulp_outplen);
  return(inl_retcode);
}

//==================================================
// Generate signature with RSA private key for a given
// certificate ID and data.
// - queries user PIN if not yet present
// - logs in user to token
// - generates signature
// - logs out user from token
//
// Input parameters: ds_pkcs11_struc * adsp_p11struc	PKCS11 structure
//                   char * abyrp_pindll_name		Name of PIN dll
//		     unsigned long ulp_certobjid	Certificate ID
//		     char * achp_inpbuf			Data to sign
//		     int inp_inplen			size of data to sign
//		     char * achp_outpbuf		destination buffer
//		     unsigned long * aulp_outplen	size of buffer/result
// Returns: int Status - 0 o.k., else error occured
//==========================================================
extern "C" int m_pkcs11_rsasigndata(ds_pkcs11_struc * adsp_p11struc,
                                    char * abyrp_pindll_name,
                                    unsigned long ulp_certobjid,
                                    char * achp_inpbuf, int inp_inplen,
                                    char * achp_outpbuf,
                                    unsigned long * aulp_outplen)
{
  int inl_retcode;

  //------------------------------------
  // 1. Login to token with user pin
  //------------------------------------
  inl_retcode = m_loginpkcs11session(adsp_p11struc, abyrp_pindll_name);
  if (inl_retcode != 0)
     return(inl_retcode);
  //---------------------------------------------------------
  // 2. Sign data with the certificate associated private key
  //---------------------------------------------------------
  inl_retcode = m_pkcs11_rsasigndataforcert(adsp_p11struc,
			 		    ulp_certobjid,
					    achp_inpbuf,inp_inplen,
					    achp_outpbuf,aulp_outplen);
  //---------------------------------------------------------
  // 3. Logout from token
  //---------------------------------------------------------
  m_logoutpkcs11session(adsp_p11struc);
  return(inl_retcode);
}

/**
 *  Execute a login to a token independently from any cryptographic 
 *  (private) key operation. Some cards required an authenticated 
 *  access to verify the existance of a private key object. Thus 
 *  this function can be used to login to the token from an 
 *  external application. This function
 *    - queries user PIN if not yet present
 *    - logs in user to token
 *
 *  @param  adsp_p11struc      This is the pointer to the current 
 *                             PKCS11 structure in use.
 *  @param  abyrp_pindll_name  This pointer to a character array contains the 
 *                             name of the HOBLink Secure PKCS#11 internally 
 *                             implemented Pin dialog.
 *  @return                    Status of the function processing
 *  <br>                       == 0  o.k.
 *  <br>                       != 0  error condition
 */
extern "C" int m_pkcs11_prelogin(ds_pkcs11_struc * adsp_p11struc,
                                 char * abyrp_pindll_name)
{
  int inl_retcode;

  //------------------------------------
  // Login to token with user pin
  //------------------------------------
  inl_retcode = m_loginpkcs11session(adsp_p11struc, abyrp_pindll_name);
  return(inl_retcode);
}

//===================================================
// Get a certificate for given Signature type and
// certificate authorities list (from SSL certificate
// request)
// Note: Authority list has a length header!!
//
// Input parameters: ds_pkcs11_struc * adsp_p11struc	PKCS11 structure
//		     char * abyp_certtypeslist		Certificate types
//		     int inp_certtypeslistlen		size of list
//		     char * abyp_authoritieslist	Authorities RDN list
//		     int inp_authoritieslistlen		size of list
//		     unsigned long * aulp_certobjid	Object ID / 0 if none
// Returns: int Status - 0 o.k., else error occured
//===================================================
extern "C" int m_pkcs11_getcertforssl(ds_pkcs11_struc * adsp_p11struc,
			          char * abyp_certtypeslist,
			          int inp_certtypeslistlen,
			          char * abyp_authoritieslist,
			          int inp_authoritieslistlen,
			          unsigned long * aulp_certobjid)
{
  int inl_totallen,inl_singlelen,inl_retcode;
  char * abyl_plist;

  *aulp_certobjid = 0;			// no certificate so far

  //------------------------------------------------
  // check if types list contains RSA signing at all
  //------------------------------------------------
  if(memchr(abyp_certtypeslist,1,inp_certtypeslistlen) == NULL)
    return(0);

  //------------------------------------------------
  // Check if a authority list is given
  //------------------------------------------------
  if(inp_authoritieslistlen != 0)
  {
    inl_totallen = (((int) abyp_authoritieslist[0] & 0x0FF) << 8) |
                    ((int) abyp_authoritieslist[1] & 0x0FF);
    if(inl_totallen == 0)
    {
      inl_retcode = m_findpkcs11_x509rsacertificate(adsp_p11struc,NULL,0,
						    aulp_certobjid);
      return(0);
    }
  }
  //-------------------------------------------------------------
  // There is a list of authorities, check each for a certificate
  //-------------------------------------------------------------
  inp_authoritieslistlen -= 2;			// remove list header
  abyl_plist = abyp_authoritieslist+2;
  while(inp_authoritieslistlen > 2)
  {
    inl_singlelen = (((int) abyl_plist[0] & 0x0FF) << 8) |
                     ((int) abyl_plist[1] & 0x0FF);
    abyl_plist += 2;
    inp_authoritieslistlen -= 2;
    if(inl_singlelen == 0)			// strange case
      continue;

    *aulp_certobjid = 0;
    inl_retcode = m_findpkcs11_x509rsacertificate(adsp_p11struc,
						  abyl_plist,inl_singlelen,
						  aulp_certobjid);
    abyl_plist += inl_singlelen;
    inp_authoritieslistlen -= inl_singlelen;
    if(*aulp_certobjid != 0)			// found a certificate!!
      return(0);
  }
  //-------------------------------------------------------
  // no certificate found for issuer, check if ANY on token
  //-------------------------------------------------------
  inl_retcode = m_findpkcs11_x509rsacertificate(adsp_p11struc,
						NULL,0,aulp_certobjid);
  return(0);
}
//===================================================
// Get a certificate of RSA Signature type
//
// Input parameters: ds_pkcs11_struc * adsp_p11struc	PKCS11 structure
//		     unsigned long * aulp_certobjid	Object ID / 0 if none
// Returns: int Status - 0 o.k., else error occured
//===================================================
extern "C" int m_pkcs11_getcertforvpn(ds_pkcs11_struc * adsp_p11struc,
			          unsigned long * aulp_certobjid)
{
  int inl_retcode;

  *aulp_certobjid = 0;			// no certificate so far

  //-------------------------------------------------------
  // check if ANY certificate on token
  //-------------------------------------------------------
  inl_retcode = m_findpkcs11_x509rsacertificate(adsp_p11struc,
						NULL,0,aulp_certobjid);
//  if(inl_retcode != 0)
//    printf("Find RSA certificate failed, RC=%d\n",inl_retcode);

  return(0);
}

//===========================================================
// Load the PKCS11 dll and initialize the library
//
// Input parameters: ds_pkcs11_struc * adsp_p11struc	PKCS11 structure
//		     char * achp_dllname		path to dll
//		     int  inp_kobilinit			kobil params scan/init
// Returns: int Status - 0 o.k., < 0 error occured,
//			> 0 no Kobil token found
//===========================================================
extern "C" int m_pkcs11_init(ds_pkcs11_struc * adsp_p11struc,
		         char * achp_dllname, int inp_kobilinit)
{
  int inl_retcode;
  char chl_drivechar;
  //-----------------------------------------------------
  // 0. Check if already initialized
  //-----------------------------------------------------
  if(adsp_p11struc->hlib != NULL)		// already initialized
    return(0);

  //-----------------------------------------------------
  // 1. Check if KOBIL mIdentity to use, setup parameters
  //-----------------------------------------------------
  if(inp_kobilinit != 0)
  {
    inl_retcode = m_scanforkobildrive(&chl_drivechar);
    if(inl_retcode != 0)			// not found
      return(inl_retcode);

    inl_retcode = m_setup_midentity_params(chl_drivechar);
    if(inl_retcode != 0)			// error occured
      return(inl_retcode);
  }    
  //-------------------------------------
  // 2. Load the PKCS11 dll, init library
  //-------------------------------------
  inl_retcode = m_loadpkcs11lib(adsp_p11struc,achp_dllname);
  if(inl_retcode != 0)
    return(inl_retcode);
  //-------------------------------------
  // 3. Establish session with token
  //-------------------------------------
  inl_retcode = m_openpkcs11session(adsp_p11struc);
  return(inl_retcode);
}
//===========================================================
// Close session with token and unload the PKCS11 dll
//
// Input parameters: ds_pkcs11_struc * adsp_p11struc	PKCS11 structure
// Returns: nothing
//===========================================================
extern "C" void m_pkcs11_close(ds_pkcs11_struc * adsp_p11struc)
{
  //------------------------------------------
  // 1. close session with token if still open
  //------------------------------------------
  m_closepkcs11session(adsp_p11struc);

  //----------------------------------------
  // 2. unload the dll if still loaded
  //----------------------------------------
  m_closepkcs11lib(adsp_p11struc);
}

#endif //_WIN32





#if 0

// The following code was created to test Crypto-Tokens from different vendors 
// using PKCS#11. When trying the "Gemalto Cryptoflex .NET" Smartcard the 
// root certificate is not visible through PKCS#11 and this code was used to 
// output all information about all objects that are found on the Token.
// The code is stored here to be available in case a request for a new 
// Smartcard or Token requires enhanced research what items are found on the 
// Token and how these look like. - L.S. 26.03.2015


//=======================================================
// Get ID list of certificates from token
//
// Input parameters: ds_pkcs11_struc * adsp_p11struc	PKCS11 structure
//		     unsigned long * aulrp_certobjidarray Object ID array
//		     int * ainp_arraylen		IN: size of array
//							OUT: found IDs
// Returns: int Status - 0 o.k., else error occured
//======================================================================
int m_get_pkcs11certid_array(ds_pkcs11_struc * adsp_p11struc,
                             unsigned long * aulrp_certobjidarray,
                             int * ainp_arraylen)
{
  int inl_inplen;
  int inl_retcode;
  unsigned long ull_arraylen;
  CK_OBJECT_CLASS inl_objclass;
  CK_ATTRIBUTE dsl_attrib[2];
  CK_CERTIFICATE_TYPE inl_certtype;

  CK_OBJECT_HANDLE inl_hdl_object;
  int inl1;
  char chl_buffer[4096];
  CK_BYTE_PTR aby_value;
  CK_ULONG ull_row;
  CK_ULONG ull_j;
  CK_ULONG ull_len;
  int inl_retcode2;


  // List of possible format types for attributes
  #define FT_ULONG (1)
  #define FT_BYTES (2)
  #define FT_BOOL (3)

  // Dull list of all possible Cryptoki attributes
  static const struct
  {
    const char *pszName;
    CK_ULONG ulType;
    int nFormat;
  } dss_attr_types[] =
  {
    // Name, Attrbute ID, Format type
    { "CKA_CLASS", CKA_CLASS, FT_ULONG},
    { "CKA_TOKEN", CKA_TOKEN, FT_BOOL},
    { "CKA_PRIVATE", CKA_PRIVATE, FT_BOOL},
    { "CKA_LABEL", CKA_LABEL, FT_BYTES},
    { "CKA_APPLICATION", CKA_APPLICATION, FT_BYTES},
    { "CKA_VALUE", CKA_VALUE, FT_BYTES},
    { "CKA_CERTIFICATE_TYPE", CKA_CERTIFICATE_TYPE, FT_ULONG},
    { "CKA_ISSUER", CKA_ISSUER, FT_BYTES},
    { "CKA_SERIAL_NUMBER", CKA_SERIAL_NUMBER, FT_BYTES},
    { "CKA_KEY_TYPE", CKA_KEY_TYPE, FT_ULONG},
    { "CKA_SUBJECT", CKA_SUBJECT, FT_BYTES},
    { "CKA_ID", CKA_ID, FT_BYTES},
    { "CKA_SENSITIVE", CKA_SENSITIVE, FT_BOOL},
    { "CKA_ENCRYPT", CKA_ENCRYPT, FT_BOOL},
    { "CKA_DECRYPT", CKA_DECRYPT, FT_BOOL},
    { "CKA_WRAP", CKA_WRAP, FT_BOOL},
    { "CKA_UNWRAP", CKA_UNWRAP, FT_BOOL},
    { "CKA_SIGN", CKA_SIGN, FT_BOOL},
    { "CKA_SIGN_RECOVER", CKA_SIGN_RECOVER, FT_BOOL},
    { "CKA_VERIFY", CKA_VERIFY, FT_BOOL},
    { "CKA_VERIFY_RECOVER", CKA_VERIFY_RECOVER, FT_BOOL},
    { "CKA_DERIVE", CKA_DERIVE, FT_BOOL},
    { "CKA_START_DATE", CKA_START_DATE, FT_BYTES},
    { "CKA_END_DATE", CKA_END_DATE, FT_BYTES},
    { "CKA_MODULUS", CKA_MODULUS, FT_BYTES},
    { "CKA_MODULUS_BITS", CKA_MODULUS_BITS, FT_ULONG},
    { "CKA_PUBLIC_EXPONENT", CKA_PUBLIC_EXPONENT, FT_BYTES},
    { "CKA_PRIVATE_EXPONENT", CKA_PRIVATE_EXPONENT, FT_BYTES},
    { "CKA_PRIME_1", CKA_PRIME_1, FT_BYTES},
    { "CKA_PRIME_2", CKA_PRIME_2, FT_BYTES},
    { "CKA_EXPONENT_1", CKA_EXPONENT_1, FT_BYTES},
    { "CKA_EXPONENT_2", CKA_EXPONENT_2, FT_BYTES},
    { "CKA_COEFFICIENT", CKA_COEFFICIENT, FT_BYTES},
    { "CKA_PRIME", CKA_PRIME, FT_BYTES},
    { "CKA_SUBPRIME", CKA_SUBPRIME, FT_BYTES},
    { "CKA_BASE", CKA_BASE, FT_BYTES},
    { "CKA_VALUE_BITS", CKA_VALUE_BITS, FT_BYTES},
    { "CKA_VALUE_LEN", CKA_VALUE_LEN, FT_ULONG},
    { "CKA_EXTRACTABLE", CKA_EXTRACTABLE, FT_BOOL},
    { "CKA_LOCAL", CKA_LOCAL, FT_BOOL},
    { "CKA_NEVER_EXTRACTABLE", CKA_NEVER_EXTRACTABLE, FT_BOOL},
    { "CKA_ALWAYS_SENSITIVE", CKA_ALWAYS_SENSITIVE, FT_BOOL},
    { "CKA_MODIFIABLE", CKA_MODIFIABLE, FT_BOOL},
    { "CKA_VENDOR_DEFINED", CKA_VENDOR_DEFINED, FT_BYTES},
    { "", 0, 0}
  };


  inl_retcode = m_loginpkcs11session(adsp_p11struc, NULL);


  // Search for all objects
  inl_inplen = 0;
  inl_retcode =
        (*((CK_FUNCTION_LIST_PTR)(adsp_p11struc->ap_fctlist))->C_FindObjectsInit)
		     (adsp_p11struc->ul_hsession, NULL_PTR, 0);
  if (inl_retcode == CKR_OK)
  {
    dsl_attrib[0].pValue = &(chl_buffer[0]);
    do
    {
      // Locate the next object
      ull_arraylen = 0;
      inl_retcode =
          (*((CK_FUNCTION_LIST_PTR)(adsp_p11struc->ap_fctlist))->C_FindObjects)
  		      (adsp_p11struc->ul_hsession,
  		      &inl_hdl_object, 1, &ull_arraylen);
      if (inl_retcode == CKR_OK)
      {
        if (ull_arraylen == 1)
        {
          inl_inplen++;
          // Write out a header
          printf("\n\n\n================== Begin Object %d ===========================\n", inl_inplen);

          // Loop for all possible attributes
          for (inl1 = 0; (dss_attr_types[inl1].nFormat != 0); inl1++)
          {
            *((long *)(&(chl_buffer[0]))) = 0;
            // Load up the attribute which interests us...
            dsl_attrib[0].type = dss_attr_types[inl1].ulType;
            dsl_attrib[0].ulValueLen = sizeof(chl_buffer);
            inl_retcode2 =
                (*((CK_FUNCTION_LIST_PTR)(adsp_p11struc->ap_fctlist))->C_GetAttributeValue)
                  (adsp_p11struc->ul_hsession, inl_hdl_object, dsl_attrib, 1);

            // Print out the attribute
            switch (inl_retcode2)
            {
              case CKR_OK:  // Attribute found
              {
                printf("%-22s", dss_attr_types[inl1].pszName);

                switch (dss_attr_types[inl1].nFormat)
                {
                  case FT_ULONG:
                       printf("%lu\n", ((CK_ULONG_PTR) dsl_attrib[0].pValue)[0]);
                       break;
                  case FT_BYTES:
                       /* print out a byte buffer in 16 byte blocks */
                       /* (ugly code but uninteresting) */
                       printf("(%lu bytes)\n", dsl_attrib[0].ulValueLen);
                       aby_value = (CK_BYTE_PTR) dsl_attrib[0].pValue;
                       for (ull_row = 0; ull_row < dsl_attrib[0].ulValueLen; ull_row += 16)
                       {
                         printf(" > ");
                         ull_len = min(dsl_attrib[0].ulValueLen - ull_row, 16);
                         for (ull_j = ull_row; ull_j < (ull_row + ull_len); ull_j++)
                            printf("%02X ", (int) aby_value[ull_j]);
                         for (ull_j = (ull_row + ull_len); ull_j < ull_row + 16; ull_j++)
                            printf(" ");
                         for (ull_j = ull_row; ull_j < (ull_row + ull_len); ull_j++)
                            printf("%c", (isprint(aby_value[ull_j]) ? aby_value[ull_j] : '.'));
                         printf("\n");
                       }
                       break;
                  case FT_BOOL:
                       printf((((CK_BBOOL *) dsl_attrib[0].pValue)[0]) ?
                              "TRUE\n" : "FALSE\n");
                       break;
                  default:
                       break;
                }
                break;
              }
              case CKR_ATTRIBUTE_SENSITIVE:
              { // Opps! we're not allowed to see it
                printf("%-22s<sensitive>\n", dss_attr_types[inl1].pszName);
                break;
              }
              case CKR_ATTRIBUTE_TYPE_INVALID:
              { // This attribute doesn't exist for this object
                break;
              }
              default:
              { // A real error has occured.
                printf("C_GetAttributeValue failed, return = %x.\n", inl_retcode);
                break;
              }
            } // end of switch (inl_retcode)

            if ((inl_retcode2 != CKR_OK) && (inl_retcode2 != CKR_ATTRIBUTE_SENSITIVE) &&
                (inl_retcode2 != CKR_ATTRIBUTE_TYPE_INVALID))
               break;
          } // end of for (inl1 = 0; (dss_attr_types[inl1].nFormat != 0); inl1++)

          // Write out a footer
          printf("================== End Object %d ===========================\n", inl_inplen);

        } // end of if (ull_arraylen == 1)

      } // end of if (inl_retcode == CKR_OK)
      else
      {
        printf("C_FindObjects(object, 1) failed, return = %x.\n", inl_retcode);
        break;
      }
    } // end of do
    while (ull_arraylen == 1);
    printf("Object search ended; found objects = %d.\n", inl_inplen);
  }

  (*((CK_FUNCTION_LIST_PTR)(adsp_p11struc->ap_fctlist))->C_FindObjectsFinal)
 	  (adsp_p11struc->ul_hsession);



  inl_objclass = CKO_CERTIFICATE;		// Class is certificates

  dsl_attrib[0].type       = CKA_CLASS;		// Type of attribute
  dsl_attrib[0].pValue     = &inl_objclass;	// Value of attribute
  dsl_attrib[0].ulValueLen = sizeof(inl_objclass);// Size of value

  inl_certtype   = CKC_X_509;

  dsl_attrib[1].type       = CKA_CERTIFICATE_TYPE; // Type of attribute
  dsl_attrib[1].pValue     = &inl_certtype;	   // Value of attribute
  dsl_attrib[1].ulValueLen = sizeof(inl_certtype); // Size of value

  inl_retcode =
    (*((CK_FUNCTION_LIST_PTR) adsp_p11struc->ap_fctlist)->C_FindObjectsInit)
		  (adsp_p11struc->ul_hsession,dsl_attrib,2);
//printf("Find certtypes init: RC=%d\n",inl_retcode);

  inl_inplen = *ainp_arraylen;
  *ainp_arraylen = 0;
  ull_arraylen = 0;
  inl_retcode =
    (*((CK_FUNCTION_LIST_PTR) adsp_p11struc->ap_fctlist)->C_FindObjects)
		  (adsp_p11struc->ul_hsession,
		   aulrp_certobjidarray,inl_inplen,&ull_arraylen);
//  printf("Find certtypes: RC=%d, Count=%d\n",inl_retcode,ull_arraylen);
  *ainp_arraylen = (int) ull_arraylen;

  (*((CK_FUNCTION_LIST_PTR) adsp_p11struc->ap_fctlist)->C_FindObjectsFinal)
		  (adsp_p11struc->ul_hsession);
  return(inl_retcode);
}

#endif

#endif //HL_CERT_PKCS11
// end of file ../pkcs11/hpkcs11.cpp


#ifdef HL_SSL_LLIB

#if (defined _WIN32) & (_MSC_VER < 1700)
#ifndef _STDINT
#define _STDINT
// MSVC lower than 17.00 does not have stdint.h, assure, all needed types are defined

typedef unsigned __int16 uint16_t;

typedef unsigned __int32 uint32_t;

typedef unsigned __int64 uint64_t;

#endif // !_STDINT
#else
#include <stdint.h>
#endif
#include <stddef.h>
#ifdef _WIN32
#define WIN32_LEAN_AND_MEAN
#include <Windows.h>
#undef WIN32_LEAN_AND_MEAN
#else// Define system-specific HL_* defines here
#ifndef HL_UNIX
#define HL_UNIX

#if (defined __gnu_linux__) || (defined __linux__)
#define HL_LINUX
#endif

#if (defined __APPLE__) && (defined __MACH__)
#define HL_LINUX
#define HL_MACOS
#endif

#ifdef _AIX
#define HL_AIX
#define HL_BIG_ENDIAN
#endif

#ifdef __FreeBSD__
#define HL_FREEBSD
#endif

#if (defined _hpux) || (defined hpux) || (defined __hpux)
#define HL_HPUX
#define HL_BIG_ENDIAN
#endif

#if (defined sun) || (defined __sun)
#define HL_SOLARIS
#endif

#if (defined __arm__) || (defined __aarch64__)
#define HL_LINUX_ARM
#endif

#ifdef __ANDROID__
#define HL_ANDROID
#endif

#endif
#include <hob-unix01.h>
#endif
#ifdef __APPLE__
/* We get target conditionals to keep apart Mac OS, iOS and iOS simulator.
   The conditionals are TARGET_IPHONE_SIMULATOR, TARGET_OS_IPHONE and TARGET_OS_MAC.
   TARGET_IPHONE_SIMULATOR has the highest priority, TARGET_OS_MAC the lowest.
   Always test, if the conditional is 1, as they will be defined as 0, if we 
   are not compiling for the target.
   */
#include <TargetConditionals.h>
#endif

#ifdef HL_ANDROID
#include <netdb.h>
#include <unistd.h>
#include <linux/in.h>
#ifndef SOCKLEN_T
#define SOCKLEN_T      int
#endif
#ifndef SA_FAMILY_T
#define SA_FAMILY_T  short
#endif
#include <sys/endian.h>
#include <asm/ioctls.h>
#include <errno.h>
#endif

#include "hob-encry-1.h"
#include "hob-cert-ext.h"
#if !(defined __HOB_XSCLIB01__) && !(defined DEF_IFUNC_START)
#define __HOB_XSCLIB01__

#include <hob-xsclib01.h>  
#endif // !__HOB_XSCLIB01__
#include <stdlib.h>
#include <hob-encry-2.h>
#include "hob-ssl-intern.h"
#ifdef _WIN32
#include <winsock.h>
#endif
#include "hob-cert-err.h"
#include <string.h>
#include "hob-cert-intern.h"

extern char* IDStrTab[13];

/**
* Gets the file type from
* the header buffer (max 80 bytes) (GetFileTypeFromHdrId).
*
*  @param HdrBuf Buffer of header
*  @param HdrOff Start of data
*  @param HdrLen Length of header
*
*  @return int Status > 0 type of file
* <br>            0 no data present/Null-Pointer
* <br>            -1 too few data
* <br>            -2 invalid Data (Magic/Vers.)
* <br>            -3 invalid type
*/
extern "C"  int  GetFileTypeFromHdrId(char HdrBuf[], int HdrOff,
		int HdrLen)
{
  char* pIDStr=NULL;

  int i;
  int j;
  //--------------------------------------------------
  // initial checks on parameters
  //--------------------------------------------------
  if((HdrBuf == NULL) || (HdrLen == 0)) return(0);
  if(HdrLen < FILE_HDR_FILE_ID_INDEX+FILE_HDR_ID_LEN) return(-1);
  //--------------------------------------------------
  // Verify header
  //--------------------------------------------------
  BIGchar2wordn(HdrBuf,i,FILE_HDR_MAGIC_INDEX);
  if(i != FILE_MAGIC_NUMBER) return(-2);
  BIGchar2wordn(HdrBuf,i,FILE_HDR_VERSION_INDEX);
  if((i < FILE_VERSION1_REV0) ||
     (i > FILE_VERSION1_REV3))
    return(-2);
  //--------------------------------------------------
  // Check if known File Header ID-String
  //--------------------------------------------------
  j = FILE_TYPE_VPN_CERT_REQ;		// max. ID Index + 1
  do
  {
    pIDStr = IDStrTab[j-1];
    if(CmpBit8Arrays(HdrBuf,HdrOff+FILE_HDR_FILE_ID_INDEX,pIDStr,0,FILE_HDR_ID_LEN) == 0)
      return(j);
    j--;
  }while(j != 0);
  return(-3);
}


/**
* Generates configuration file
* header/databuffer and hashes (GenerateConfigData).
* The length of the lists are included in the first element.
* The Ciphersuite list consists of BIG16 elements,
* the CompressionMethods list consists of bytes.
*
*  @param PwdBuf Password base
*  @param PwdOff Start of password data
*  @param PwdLen Length of password
*  @param ExpireTime UTC time. if 0 never
*  @param ConfigFlags Protocol/Config. flags
*  @param ExtConfigFlags Extended configuration flags
*  @param ExtConf2Flags Additional ext. config. flags
*  @param CertPolicyFlags Policy flags
*  @param CacheAgingTime Timer for cache aging
*  @param RenegotiateTime Timer for renegotiate
*  @param CiphSuiteList Ciphersuite list base
*  @param CiphSuiteListOff Start of ciphersuite data
*  @param ComprMethList Comprssion methods list base
*  @param ComprMethListOff Start of comprssion methods data
*  @param SubjNamesList Auth. subjects name list / NULL
*  @param SubjNamesListOff Start of subjects name list data
*  @param Type 1 - Server <br>
*               2 - Client
*  @param ConnectionCount Number of connections supported
*  @param ConnectTimeout Timeout in seconds
*  @param ppDst Destination buffer pointer
*  @param pDstLen Length of generated file data
*
*  @return int Status 0 - o.k.
* <br>            <> 0 Error occured:
* <br>            -1 Null Pointer
* <br>            -2 invalid Type
* <br>            -3 invalid Data length
* <br>            -4 invalid flags
* <br>            -5 allocate error
*/
extern "C"  int  GenerateConfigData(HMEM_CTX_DEF
		char PwdBuf[], int PwdOff,
		int PwdLen, int ExpireTime,int ConfigFlags,
		int ExtConfigFlags, int ExtConf2Flags,
		int CertPolicyFlags,
		int CacheAgingTime, int RenegotiateTime,
		char CiphSuiteList[], int CiphSuiteListOff,
		char ComprMethList[], int ComprMethListOff,
		char SubjNamesList[], int SubjNamesListOff, int Type,
		int ConnectionCount, int ConnectTimeout,
		char** ppDst, int pDstLen[])
{

  char* pBuf;

  int index;
  int CiphListLen;
  int CmprListLen;
  int SubjNamesCnt;
  int SubjNameLen;

  int DataLen;
  int SubjNamesListLen = 0;
  //------------------------------------------
  // check parameters
  //------------------------------------------
  if((PwdBuf == NULL) || (CiphSuiteList == NULL) || (ComprMethList == NULL) ||
     (ppDst == NULL) || (pDstLen == NULL)) return(-1);
  if((Type < FILE_TYPE_SRVR_CFG) || (Type > FILE_TYPE_CLNT_CFG)) return(-2);

  if((PwdLen == 0) || (PwdLen > MAX_PASSWORD_LEN)) return(-3);
  BIGchar2wordn(CiphSuiteList,CiphListLen,CiphSuiteListOff);
  CmprListLen = (int) ComprMethList[0] & 0xFF;
  if((CiphListLen == 0) || (CmprListLen == 0) ||
     ((CiphListLen & 0x01) != 0)) return(-3);

  if(((ConfigFlags & 0x03) == 0) &&
     ((ExtConfigFlags & (CFG_TLS_V1_BIT_MASK | CFG_TLS_V2_BIT_MASK)) == 0))
    return(-4);

  ppDst[0] = NULL;
  pDstLen[0] = 0;

  //-----------------------------------------------------------
  // get length of buffer for the subject names list if present
  //-----------------------------------------------------------
  if(SubjNamesList != NULL)
  {
    index = SubjNamesListOff;			  // set start offset
    BIGchar2word(SubjNamesList,SubjNamesCnt,index); // get count of names
    if(SubjNamesCnt <= 0)
      return(-3);
    do
    {
      BIGchar2word(SubjNamesList,SubjNameLen,index); // get name elements count
      if(SubjNameLen <= 0)
        return(-3);
      SubjNameLen *= 2;				// get number of bytes
      SubjNamesListLen += (SubjNameLen + 2);	// sum up
      index += SubjNameLen;			// skip that name
      SubjNamesCnt--;
    }while(SubjNamesCnt != 0);
    SubjNamesListLen += 2;			// add counter field
  }
  //------------------------------------------
  // Allocate necessary buffer
  //------------------------------------------
  DataLen = CmprListLen + CiphListLen + SubjNamesListLen;
  pBuf = BIT8_ARRAY_ALLOC(HMEM_CTX_REF,FILE_HEADER_LEN+(int) DataLen);
  if(pBuf == NULL) return(-5);
  ppDst[0] = pBuf;
  pDstLen[0] = (int) DataLen + FILE_HEADER_LEN;
  //-----------------------------------------------------------------
  // Generate the header, set the Flags, list lengths, expire, timers
  //-----------------------------------------------------------------
  GenVfyFixedFileHdrs(pBuf,0,FILE_HEADER_LEN,Type,0);
  BIGlong2charn(ExpireTime,pBuf,FILE_HDR_PWD_EXPIRE_TIME_INDEX);
  pBuf[FILE_HDR_PROTO_INDEX+1] = (char) ConfigFlags;
  pBuf[FILE_HDR_PROTO_INDEX] = (char) ExtConfigFlags;
  
  BIGword2charn(ExtConf2Flags,pBuf,FILE_HDR_EXT_CFG2_FLAGS_INDEX);
  BIGword2charn(CiphListLen,pBuf,FILE_HDR_CIPHSUITES_LEN_INDEX);
  BIGword2charn(CmprListLen,pBuf,FILE_HDR_CMPRMETHODS_LEN_INDEX);
  BIGlong2charn(CacheAgingTime,pBuf,FILE_HDR_CACHE_AGING_TIME_INDEX);
  BIGlong2charn(RenegotiateTime,pBuf,FILE_HDR_RENEGOTIATE_TIME_INDEX);
  BIGword2charn(CertPolicyFlags,pBuf,FILE_HDR_CERT_POLICIES_INDEX);
  BIGlong2charn(SubjNamesListLen,pBuf,FILE_HDR_SUBJ_NAMELST_LEN_INDEX);

  if(ConnectionCount == 0)
  {
    if(Type == FILE_TYPE_SRVR_CFG)
      ConnectionCount = SERVER_DEFAULT_CONNECTIONS;
    else
      ConnectionCount = CLIENT_DEFAULT_CONNECTIONS;
  }
  if(ConnectTimeout == 0)
    ConnectTimeout = DEFAULT_CONNECT_TIMEOUT;

  BIGword2charn(ConnectionCount,pBuf,FILE_HDR_MAX_CONNECTIONS_INDEX);
  BIGword2charn(ConnectTimeout,pBuf,FILE_HDR_CONNECT_TIMEOUT_INDEX);
  //------------------------------------------------------
  // Copy lists to data area
  //------------------------------------------------------
  index = FILE_DATA_START_INDEX;
  memcpy(pBuf+index,CiphSuiteList+CiphSuiteListOff+2,CiphListLen);
  index += CiphListLen;
  memcpy(pBuf+index,ComprMethList+ComprMethListOff+1,CmprListLen);
  if(SubjNamesListLen != 0)
  {
    index += CmprListLen;
    memcpy(pBuf+index,SubjNamesList+SubjNamesListOff,(int) SubjNamesListLen);
  }
  //------------------------------------------------------
  // Generate the data hashes
  //------------------------------------------------------
  GenVfyPwdMD5Hashes(pBuf,0,FILE_HEADER_LEN,pBuf,FILE_DATA_START_INDEX,(int) DataLen,PwdBuf,PwdOff,PwdLen,0);
  return(0);
}

/**
* Generates configuration file
* header/databuffer and hashes (GenerateConfigDataEx).
*
*  @param PwdBuf Password base
*  @param PwdOff Start of password data
*  @param PwdLen Length of password
*  @param ExpireTime UTC time. if 0 never
*  @param pCfgStruc Structure containing data
*  @param ExtCfgBuf Extended config. data. Optional
*  @param ExtCfgOff Start of ext cfg data
*  @param ExtCfgLen Length of ext cfg data. May be 0
*  @param ppDst Destination buffer pointer
*  @param pDstLen Length of generated file data
*
*  @return int Status 0 - o.k.
* <br>            <> 0 Error occured:
* <br>            -1 Null Pointer
* <br>            -2 invalid Type
* <br>            -3 invalid Data length
* <br>            -4 invalid flags
* <br>            -5 allocate error
*/
extern "C"  int  GenerateConfigDataEx(HMEM_CTX_DEF
		char PwdBuf[], int PwdOff,
		int PwdLen, int ExpireTime,
		CFG_STRU * pCfgStruc, char ExtCfgBuf[], int ExtCfgOff,
		int ExtCfgLen, char* ppDst[], int pDstLen[])
{
  char* pBuf;

  int Type;
  int index;
  int CiphListLen;
  int CmprListLen;
  int SubjNamesCnt;
  int SubjNameLen;
  int ConnectionCount;
  int ConnectTimeout;

  char* pSubjNamesList;

  int DataLen;
  int SubjNamesListLen = 0;
  //------------------------------------------
  // check primary parameters
  //------------------------------------------
  if((PwdBuf == NULL) || (pCfgStruc == NULL) ||
     ((ExtCfgLen != 0) && (ExtCfgBuf == NULL)) ||
     (ppDst == NULL) || (pDstLen == NULL))
    return(-1);

  if((PwdLen == 0) || (PwdLen > MAX_PASSWORD_LEN) || (ExtCfgLen < 0))
    return(-3);
  //----------------------------------------------
  // check parameters from configuration structure
  //----------------------------------------------
  switch(pCfgStruc->Entity)
  {
    case SERVER_ENTITY:
      Type = FILE_TYPE_SRVR_CFG;
      break;

    case CLIENT_ENTITY:
      Type = FILE_TYPE_CLNT_CFG;
      break;

    default:
      return(-2);
  }


  BIGchar2wordn(pCfgStruc->CipherSuitesList,CiphListLen,0);
  CmprListLen = (int) pCfgStruc->CmprMethodsList[0] & 0xFF;
  if((CiphListLen == 0) || (CmprListLen == 0) ||
     ((CiphListLen & 0x01) != 0))
    return(-3);

  if(((pCfgStruc->ProtFlags & 0x03) == 0) &&
     ((pCfgStruc->ExtConfigFlags & (CFG_TLS_V1_BIT_MASK | CFG_TLS_V2_BIT_MASK)) == 0))
    return(-4);

  ppDst[0] = NULL;
  pDstLen[0] = 0;
  //-----------------------------------------------------------
  // get length of buffer for the subject names list if present
  //-----------------------------------------------------------
  pSubjNamesList = pCfgStruc->SubjCNamesListPtr;
  if(pSubjNamesList != NULL)
  {
    index = 0;					  // set start offset
    BIGchar2word(pSubjNamesList,SubjNamesCnt,index); // get count of names
    if(SubjNamesCnt <= 0)
      return(-3);
    do
    {
      BIGchar2word(pSubjNamesList,SubjNameLen,index); // get name elements count
      if(SubjNameLen <= 0)
        return(-3);
      SubjNameLen *= 2;				// get number of bytes
      SubjNamesListLen += (SubjNameLen + 2);	// sum up
      index += SubjNameLen;			// skip that name
      SubjNamesCnt--;
    }while(SubjNamesCnt != 0);
    SubjNamesListLen += 2;			// add counter field
  }
  //------------------------------------------
  // Allocate necessary total buffer
  //------------------------------------------
  DataLen = CmprListLen + CiphListLen + SubjNamesListLen + ExtCfgLen;

  pBuf = BIT8_ARRAY_ALLOC(HMEM_CTX_REF,FILE_HEADER_LEN+(int) DataLen);
  if(pBuf == NULL) return(-5);
  ppDst[0] = pBuf;
  pDstLen[0] = (int) DataLen + FILE_HEADER_LEN;
  //-----------------------------------------------------------------
  // Generate the header, set the Flags, list lengths, expire, timers
  //-----------------------------------------------------------------
  GenVfyFixedFileHdrs(pBuf,0,FILE_HEADER_LEN,Type,0);

  BIGlong2charn(ExpireTime,pBuf,FILE_HDR_PWD_EXPIRE_TIME_INDEX);
  pBuf[FILE_HDR_PROTO_INDEX+1] = (char) pCfgStruc->ProtFlags;
  pBuf[FILE_HDR_PROTO_INDEX]   = (char) pCfgStruc->ExtConfigFlags;
  
  BIGword2charn(pCfgStruc->ExtConf2Flags,pBuf,
                FILE_HDR_EXT_CFG2_FLAGS_INDEX);

  BIGword2charn(CiphListLen,pBuf,FILE_HDR_CIPHSUITES_LEN_INDEX);
  BIGword2charn(CmprListLen,pBuf,FILE_HDR_CMPRMETHODS_LEN_INDEX);

  BIGlong2charn(pCfgStruc->CacheAgingTime,pBuf,
		FILE_HDR_CACHE_AGING_TIME_INDEX);
  BIGlong2charn(pCfgStruc->RenegotiateTime,pBuf,
		FILE_HDR_RENEGOTIATE_TIME_INDEX);
  BIGword2charn(pCfgStruc->CertPolicyFlags,pBuf,
		FILE_HDR_CERT_POLICIES_INDEX);

  BIGlong2charn(SubjNamesListLen,pBuf,FILE_HDR_SUBJ_NAMELST_LEN_INDEX);

  ConnectionCount = pCfgStruc->MaxConnCount;
  if(ConnectionCount == 0)
  {
    if(Type == FILE_TYPE_SRVR_CFG)
      ConnectionCount = SERVER_DEFAULT_CONNECTIONS;
    else
      ConnectionCount = CLIENT_DEFAULT_CONNECTIONS;
  }
  ConnectTimeout = pCfgStruc->ConnectTimeout;
  if(ConnectTimeout == 0)
    ConnectTimeout = DEFAULT_CONNECT_TIMEOUT;

  BIGword2charn(ConnectionCount,pBuf,FILE_HDR_MAX_CONNECTIONS_INDEX);
  BIGword2charn(ConnectTimeout,pBuf,FILE_HDR_CONNECT_TIMEOUT_INDEX);


  BIGlong2charn(ExtCfgLen,pBuf,FILE_HDR_EXT_CFG_LEN_INDEX);
  //------------------------------------------------------
  // Copy lists to data area
  //------------------------------------------------------
  index = FILE_DATA_START_INDEX;
  memcpy(pBuf+index,pCfgStruc->CipherSuitesList+2,CiphListLen);
  index += CiphListLen;
  memcpy(pBuf+index,pCfgStruc->CmprMethodsList+1,CmprListLen);
  index += CmprListLen;
  if(SubjNamesListLen != 0)
  {
    memcpy(pBuf+index,pSubjNamesList+0,(int) SubjNamesListLen);
    index += SubjNamesListLen;
  }
  if(ExtCfgLen != 0)
  {
    memcpy(pBuf+index,ExtCfgBuf+ExtCfgOff,(int) ExtCfgLen);
//  index += ExtCfgLen;
  }
  //------------------------------------------------------
  // Generate the data hashes
  //------------------------------------------------------
  GenVfyPwdMD5Hashes(pBuf,0,FILE_HEADER_LEN,pBuf,FILE_DATA_START_INDEX,(int) DataLen,PwdBuf,PwdOff,PwdLen,0);
  return(0);
}


#endif //HL_SSL_LLIB
// end of file ../hssl/hsslllib.cpp


#ifdef HL_BASE64_PEM
#define PEM_REQ_TIME_TYPE	ASN1_TIME_TYPE_UTC
#define PEM_NOT_AFTER_DELTA	365

#define __HSSL_LOCAL_LIB__
#define __B64_TAB_INC__

#if (defined _WIN32) & (_MSC_VER < 1700)
#ifndef _STDINT
#define _STDINT
// MSVC lower than 17.00 does not have stdint.h, assure, all needed types are defined

typedef unsigned __int16 uint16_t;

typedef unsigned __int32 uint32_t;

typedef unsigned __int64 uint64_t;

#endif // !_STDINT
#else
#include <stdint.h>
#endif
#include <stddef.h>
#ifdef _WIN32
#define WIN32_LEAN_AND_MEAN
#include <Windows.h>
#undef WIN32_LEAN_AND_MEAN
#else// Define system-specific HL_* defines here
#ifndef HL_UNIX
#define HL_UNIX

#if (defined __gnu_linux__) || (defined __linux__)
#define HL_LINUX
#endif

#if (defined __APPLE__) && (defined __MACH__)
#define HL_LINUX
#define HL_MACOS
#endif

#ifdef _AIX
#define HL_AIX
#define HL_BIG_ENDIAN
#endif

#ifdef __FreeBSD__
#define HL_FREEBSD
#endif

#if (defined _hpux) || (defined hpux) || (defined __hpux)
#define HL_HPUX
#define HL_BIG_ENDIAN
#endif

#if (defined sun) || (defined __sun)
#define HL_SOLARIS
#endif

#if (defined __arm__) || (defined __aarch64__)
#define HL_LINUX_ARM
#endif

#ifdef __ANDROID__
#define HL_ANDROID
#endif

#endif
#include <hob-unix01.h>
#endif
#ifdef __APPLE__
/* We get target conditionals to keep apart Mac OS, iOS and iOS simulator.
   The conditionals are TARGET_IPHONE_SIMULATOR, TARGET_OS_IPHONE and TARGET_OS_MAC.
   TARGET_IPHONE_SIMULATOR has the highest priority, TARGET_OS_MAC the lowest.
   Always test, if the conditional is 1, as they will be defined as 0, if we 
   are not compiling for the target.
   */
#include <TargetConditionals.h>
#endif

#ifdef HL_ANDROID
#include <netdb.h>
#include <unistd.h>
#include <linux/in.h>
#ifndef SOCKLEN_T
#define SOCKLEN_T      int
#endif
#ifndef SA_FAMILY_T
#define SA_FAMILY_T  short
#endif
#include <sys/endian.h>
#include <asm/ioctls.h>
#include <errno.h>
#endif

#include "hob-encry-1.h"
#include "hob-cert-ext.h"
#ifdef _WIN32
#include <winsock.h>
#endif
#include "hob-cert-err.h"
#include <string.h>
#include "hob-cert-intern.h"

/**
* Compares a byte buffer
* containing Ascii characters against a fixed string either
* case sensitive or insensitive (CmpBit8BufToString).
* NOTE: no check on buffer pointers is done !
*
*  @param Buffer Buffer Base
*  @param BufOff Data Start in Buffer
*  @param DataLen Length of data in buffer
*  @param pStrBuf compare string
*  @param StrOff start of data
*  @param StrLen length of Data
*  @param Mode == 0 : case insensitive
*               != 0 : case sensitive
*  @return int Result == 0 - String found
* <br>            != 0 - String not found
*/
static  int  CmpBit8BufToString(char Buffer[], int BufOff,
			int DataLen, const char* pStrBuf, int StrOff,
			int StrLen, int Mode)
{
  char c1,c2;

  if((DataLen < StrLen) || (StrLen == 0)) // nothing to do
    return(1);
  if(Mode != 0)
    //---------------------------------------------------
    // Compare Case sensitive
    //---------------------------------------------------
    return(memcmp((Buffer+BufOff), ((char*) pStrBuf+StrOff),StrLen));

  else
  {
    //---------------------------------------------------
    // Compare Case insensitive
    //---------------------------------------------------
    do
    {
      c1 = Buffer[BufOff++];
      c2 = pStrBuf[StrOff++];

      if((c1 >= 0x61) && (c1 <= 0x7A))		// convert to lower
        c1 -= 0x20;
      if((c2 >= 0x61) && (c2 <= 0x7A))		// dto.
        c2 -= 0x20;
      if(c1 != c2)				// different
        return(1);
      StrLen--;
    }while(StrLen != 0);
    return(0);
  }
} 
/**
* Subroutine CmpCaseInsensitive compares two byte buffers
* containing Ascii characters in case insensitive manner (CmpCaseInsensitive).
* NOTE: 1. no check on buffer pointers is done !
* ----- 2. the first (Source) may be larger than the comparison buffer
*
*  @param SrcBuf Buffer Base
*  @param SrcOff Data Start in Buffer
*  @param SrcLen Length of data in buffer
*  @param CmpBuf compare string
*  @param CmpOff start of data
*  @param CmpLen length of Data
*  @return int Result == 0 - String found
* <br>            != 0 - String not found
*/
static  int  CmpCaseInsensitive(char SrcBuf[], int SrcOff,
			int SrcLen, char CmpBuf[], int CmpOff, int CmpLen)
{
  char c1,c2;

  if((SrcLen < CmpLen) || (CmpLen == 0)) // nothing to do
    return(1);
  {
    //---------------------------------------------------
    // Compare Case insensitive
    //---------------------------------------------------
    do
    {
      c1 = SrcBuf[SrcOff++];
      c2 = CmpBuf[CmpOff++];

      if((c1 >= 0x61) && (c1 <= 0x7A))		// convert to lower
        c1 -= 0x20;
      if((c2 >= 0x61) && (c2 <= 0x7A))		// dto.
        c2 -= 0x20;
      if(c1 != c2)				// different
        return(1);
      CmpLen--;
    }while(CmpLen != 0);
    return(0);
  }
} 

extern "C"  int ConvStoreHexToB64(char SrcBuf[], int SrcOffset, int SrcLen,
                                  int Mode, char DstBuf[], int pDstOff[], int pDstLen[])
{
  int SrcIndex = SrcOffset;
  int DstIndex = pDstOff[0];

  int LineQuadCount;
  int LineCount;

  int BufLen;

  unsigned char c1,c2;
  //-------------------------------------------------------
  // Calculate required destination buffer size, check
  //-------------------------------------------------------
  BufLen = ((SrcLen + 2) / 3)*4;		// bytes after conversion
  LineCount = (BufLen + MAX_CHARS_PER_LINE-1) / // get required lines
              MAX_CHARS_PER_LINE;
  if(Mode == 0)
    BufLen += (LineCount * (CRLF_LEN+1));	// + times(CR/LF + SPACE (!))
  else
    BufLen += (LineCount * CRLF_LEN);		// + times(CR/LF)
  if(BufLen > pDstLen[0])
    return(-1);
  //-------------------------------------------------------
  // Convert the input bytes
  //-------------------------------------------------------
  if(Mode == 0)
    DstBuf[DstIndex++] = 0x20;			// leading space
  LineQuadCount = 16;				// max. 64 characters per line
  do
  {
    //-----------------------------------------------------
    // Convert 3 Input bytes (or less) to 4 output bytes
    //-----------------------------------------------------
    if(SrcLen >=3)				// full triple present
    {
      c1  = SrcBuf[SrcIndex++];			// get 1st byte
      c2  = (unsigned char) ((c1 & 0x03) << 4);		// save 2 LSB bits at top-2
      DstBuf[DstIndex++] = Base64EncodeTab[(c1 >> 2) & 0x3F]; // convert 6 Bits

      c1  = SrcBuf[SrcIndex++];			// get 2nd byte
      c2 |= (c1 >> 4) & 0x0F;			// extract top 4 bits
      DstBuf[DstIndex++] = Base64EncodeTab[c2];	// convert 6 Bits
      c2  = (unsigned char) ((c1 & 0x0F) << 2);		// save 4 bits at top-2

      c1  = SrcBuf[SrcIndex++];			// get 3rd byte
      c2 |= (c1 >> 6) & 0x03;			// extract top 2 bits
      DstBuf[DstIndex++] = Base64EncodeTab[c2];	// convert 6 bits
      DstBuf[DstIndex++] = Base64EncodeTab[c1 & 0x3F]; // convert remaining bits
      SrcLen -= 3;
    }
    else					// end of data, remaining bytes
    {
      c1  = SrcBuf[SrcIndex++];			// get 1st byte
      c2  = (unsigned char) ((c1 & 0x03) << 4);		// save 2 LSB bits at top-2
      DstBuf[DstIndex++] = Base64EncodeTab[(c1 >> 2) & 0x3F]; // convert 6 bits
      SrcLen--;
      if(SrcLen == 0)				// data exhausted
      {
        DstBuf[DstIndex++] = Base64EncodeTab[c2];// convert 2 + 4 padding bits
        DstBuf[DstIndex++] = EQUAL_CHAR;	// append padding character
        DstBuf[DstIndex++] = EQUAL_CHAR;	// append padding character
      }
      else
      {
        c1  = SrcBuf[SrcIndex++];		// get 2nd byte
        c2 |= (c1 >> 4) & 0x0F;			// extract top 4 bits
        DstBuf[DstIndex++] = Base64EncodeTab[c2]; // convert 6 Bits
        c2  = (unsigned char) ((c1 & 0x0F) << 2);	// save 4 bits at top-2
        DstBuf[DstIndex++] = Base64EncodeTab[c2]; // convert 4 + 2 padding bits
        DstBuf[DstIndex++] = EQUAL_CHAR;	// append padding character
        SrcLen--;
      }
    }
    LineQuadCount--;				
    if((LineQuadCount == 0) || (SrcLen == 0))   // line is full/End of Data
    {
      DstBuf[DstIndex++] = CR_CHAR;		// append CR
      DstBuf[DstIndex++] = LF_CHAR;		// append LF
      LineQuadCount = 16;
      if((SrcLen != 0) && (Mode == 0))		// still more data...
        DstBuf[DstIndex++] = 0x20;		// set continiation SPACE
   }
  }while(SrcLen != 0);
  //-------------------------------------------------------
  // Set return values
  //-------------------------------------------------------
  pDstOff[0] = DstIndex;
  pDstLen[0] -= BufLen;
  return(0);
}
/**
* Subroutine GetRFC822HdrLineChars counts/copies all non comment
* characters from a header line, removes linear whitespace and
* all other whitespaces (GetRFC822HdrLineChars).
* NOTE: Checking for comments, quoted strings and domain literals
* ----- is only allowed in the field body of a header line,
*	 not within the field-name (all non CTL characters excl.
*	 SPC and : are allowed for a field name !)
*
*  @param SrcBuf Base of source data
*  @param SrcOffset Start of data in buffer
*  @param SrcLen Length of source data
*  @param Mode BIT 0 == 0: keep quoted strings
*               BIT 0 != 0: remove quotes/quoted pairs
*               BIT 1 == 0: Start with field name
*               BIT 1 == 1: Assume Fieldname present
*  @param pNextOffset Offset to next line
*  @param pNextLen Remaining data
*  @param DstBuf Destination Buffer / NULL (if count)
*
*  @return int LineLen == 0 -> Empty line
* <br>            > 0 -> Charactercount
*/
static  int GetRFC822HdrLineChars(char SrcBuf[], int SrcOffset,
			int SrcLen, int Mode,
			int pNextOffset[], int pNextLen[], char DstBuf[])
{

  char DelimChar = 0;			// Current Delimiter character
  char LastChar = 0;			// last processed character
  char ActChar = 0;			// actual processed character
  int  QuoteFlag = 0;			// single quote active if != 0
  int  CommentLevel = 0;		// in comment if != 0
  int  DstIndex = 0;			// Linelength Counter/Index
  int  FieldBodyFlag = 0;		// No Fieldbody found yet

  while(SrcLen != 0)
  {
    LastChar = ActChar;			// save last processed character
    ActChar  = SrcBuf[SrcOffset++];	// get character
    SrcLen--;
    if((Mode & 0x02) != 0)		// assume already in field body
      FieldBodyFlag = 1;
    //--------------------------------------------------------------------
    // Check if in special mode (Quoted String / Domain Literal / comment)
    //--------------------------------------------------------------------
    if((DelimChar != 0) || (CommentLevel != 0))
    {
      //---------------------------------------------------
      // Special mode active, single quotes must be obeyed
      //---------------------------------------------------
      if(QuoteFlag != 0)		// had a qoute char (\) before
      {
        QuoteFlag = 0;
        if(CommentLevel == 0)		// not inside comment
        {
          if(DstBuf != NULL) DstBuf[DstIndex] = ActChar;	// save this
          DstIndex++;			// increment count/index
        }
        ActChar = 0;			// discard character
        continue;
      }
      //---------------------------------------------------
      // Check if linear whitespace, if so, remove
      //---------------------------------------------------
      if((ActChar == SPACE_CHAR) || (ActChar == HTAB_CHAR)) // is whitespace
      {
        if((LastChar != CR_CHAR) && (LastChar != LF_CHAR))  // is a normal spc
        {
          if(CommentLevel == 0)				// not in a comment
          {
            if(DstBuf != NULL) DstBuf[DstIndex] = ActChar;    // copy
            DstIndex++;
          }
        }
        continue;
      }
      //---------------------------------------------------
      // Check for LineBreak
      //---------------------------------------------------
      if((ActChar == CR_CHAR) || (ActChar == LF_CHAR))
      {
        if(((ActChar == CR_CHAR) &&			// CR, check past LF/CR
            ((LastChar == CR_CHAR) || (LastChar == LF_CHAR))) |
           ((ActChar == LF_CHAR) && (LastChar == LF_CHAR))) // LF/LF
        {
          SrcOffset--;				// is a linebreak
          SrcLen++;
          break;
        }
        continue;
      }
      if((LastChar == CR_CHAR) || (LastChar == LF_CHAR)) //preceded by CR/LF
      {
          SrcOffset--;				// is a linebreak
          SrcLen++;
          break;
      }
      //---------------------------------------------------
      // Check for Quoting Char
      //---------------------------------------------------
      if(ActChar == BACKSLASH_CHAR)		// is single Quote signal
      {
        QuoteFlag = 1;
        if(CommentLevel == 0)
        {
          if((DelimChar != QUOT_MARK_CHAR) ||	// is not in string
             ((Mode & 0x01) == 0))		// is in string, but keep
          {
            if(DstBuf != NULL) DstBuf[DstIndex] = ActChar;
            DstIndex++;
          }
        }
        continue;
      }
      //---------------------------------------------------
      // Check for Special mode delimiting Char
      //---------------------------------------------------
      if(ActChar != DelimChar)			// is not a delimiter
      {
        if(CommentLevel == 0)
        {
          if(DstBuf != NULL) DstBuf[DstIndex] = ActChar;
          DstIndex++;
          continue;       
        }
        if(ActChar == L_BRACKET_CHAR)		// comment in a comment
          CommentLevel++;
        continue;
      }
      //---------------------------------------------------
      // Found delimiting character
      //---------------------------------------------------
      if((DelimChar == QUOT_MARK_CHAR) ||	// not a comment end
         (DelimChar == RSQ_BRACKET_CHAR))
      {
        if((DelimChar != QUOT_MARK_CHAR) ||	// is not in string
           ((Mode & 0x01) == 0))		// in string, but keep
        {
          if(DstBuf != NULL) DstBuf[DstIndex] = ActChar;
          DstIndex++;
        }
        DelimChar = 0;				// mode ended
        continue;
      }
      CommentLevel--;				// Comment Ended
      if(CommentLevel == 0) DelimChar = 0;	// all comments ended
      continue;
    } // Special processing IF
    //------------------------------------------------------
    // Standard mode processing
    //------------------------------------------------------
    if((ActChar == SPACE_CHAR) || (ActChar == HTAB_CHAR)) // LWSP, skip
      continue;
    //------------------------------------------------------
    // Check for Line End / Line folding
    //------------------------------------------------------
    if((ActChar == CR_CHAR) || (ActChar == LF_CHAR))	// linebreak
    {
      if(((ActChar == CR_CHAR) &&			// is CR after CR,LF
	 ((LastChar == CR_CHAR) || (LastChar == LF_CHAR))) ||      
         ((ActChar == LF_CHAR) && (LastChar == LF_CHAR))) // is LF/LF
      {
        SrcOffset--;
        SrcLen++;
        break;
      }
      continue;
    }
    if((LastChar == CR_CHAR) || (LastChar == LF_CHAR)) //preceded by CR/LF
    {
       SrcOffset--;				// is a linebreak
       SrcLen++;
       break;
    }
    //------------------------------------------------------
    // Distribute according to Standard/Special characters
    //------------------------------------------------------
    if(FieldBodyFlag == 0)			// still parsing field name
    {
      if(ActChar == COLON_CHAR)			// end of fieldname
        FieldBodyFlag = 1;
    }
    else			  		// already in a field body
    {
      switch(ActChar)
      {
        case QUOT_MARK_CHAR:			// start of quoted String
          DelimChar = ActChar;			// "-Char
          if((Mode & 0x01) == 0) break;		// keep quote
          continue;				// ignore
 
        case LSQ_BRACKET_CHAR:			// start of domain literal
          DelimChar = RSQ_BRACKET_CHAR;		// ]-Char
          break;

        case L_BRACKET_CHAR:			// start of comment
          DelimChar = R_BRACKET_CHAR;		// )-Char
          CommentLevel = 1;
          continue;

        default:				// all others
          break;
      }
    }
    if(DstBuf != NULL) DstBuf[DstIndex] = ActChar;
    DstIndex++;
    continue;
  } // outmost While
  if(pNextOffset != NULL) pNextOffset[0] = SrcOffset;
  if(pNextLen != NULL) pNextLen[0] = SrcLen;
  return(DstIndex);
}
/**
* Subroutine UnquoteRFC822QuotedString removes surrounding quotes
* and embedded quoted pairs from given data to a separat buffer (UnquoteRFC822QuotedString).
*
*  @param SrcBuf Base of source data
*  @param SrcOffset Start of data in buffer
*  @param SrcLen Length of source data
*  @param pNextSrcOffset Offset to data past String/NULL
*  @param pNextSrcLen Remaining data length past String/NULL
*  @param pDstBuf NULL, if not quoted or empty String
*
*  @return int DataLen
* <br>         == 0 -> Empty Quoted String or not quoted
* <br>         > 0 -> Charactercount
* <br>         < 0 -> Parameter error
*/
static  int UnquoteRFC822QuotedString(HMEM_CTX_DEF
			char SrcBuf[], int SrcOffset,
			int SrcLen, int pNextSrcOffset[], int pNextSrcLen[],
			char* pDstBuf[])
{
  char ActChar;
  int SrcCount;
  int SrcIndex;
  int DstIndex = 0;
  int QuoteFlag = 0;
  char* pBuf;
  //-------------------------------------------------
  // Check parameters
  //-------------------------------------------------
  if(SrcBuf == NULL) return(-1);
  //-------------------------------------------------
  // Check for empty / not quoted string
  //-------------------------------------------------
  if((SrcLen == 0) || (SrcBuf[SrcOffset] != QUOT_MARK_CHAR))//no data/notquoted
  {
    if(pNextSrcOffset != NULL)
      pNextSrcOffset[0] = SrcOffset;		// no data to skip
    if(pNextSrcLen != NULL)
      pNextSrcLen[0] = SrcLen;
  }
  //-----------------------------------------------------
  // Get required buffer size (i.e. search for end-quote)
  //-----------------------------------------------------
  SrcOffset++;
  SrcLen--;
  SrcIndex = SrcOffset;
  SrcCount = SrcLen;
  while(SrcCount != 0)
  {
    ActChar = SrcBuf[SrcIndex++];		// get next character
    SrcCount--;
    if(QuoteFlag != 0)				// quoting is active
    {
      DstIndex++;
      QuoteFlag = 0;
      continue;
    }
    if(ActChar == BACKSLASH_CHAR)	// found quoting character
    {
      QuoteFlag = 1;
      continue;
    }
    if(ActChar == QUOT_MARK_CHAR)	// end of quoted String
      break;
    DstIndex++;				// count characters !
  }
  //-----------------------------------------------------
  // set next pointers / length
  //-----------------------------------------------------
  if(pNextSrcOffset != NULL) pNextSrcOffset[0] = SrcIndex;
  if(pNextSrcLen != NULL) pNextSrcLen[0] = SrcCount;

  if(DstIndex == 0)			// empty string
    return(0);
  if(pDstBuf == NULL)			// only count, no copy
    return(DstIndex);
  //-----------------------------------------------------
  // Allocate the buffer, copy the data
  //-----------------------------------------------------
  pDstBuf[0] = NULL;			// no pointer
  pBuf = BIT8_ARRAY_ALLOC(HMEM_CTX_REF,DstIndex);
  if(pBuf == NULL) return(-2);		// allocate error

  QuoteFlag = 0;
  DstIndex = 0;
  while(SrcOffset < SrcIndex)		// may be missing delimiter !!
  {
    ActChar = SrcBuf[SrcOffset++];	// get character
    if(QuoteFlag != 0)			// is quoted from last character
    {
      QuoteFlag = 0;
      pBuf[DstIndex++] = ActChar;	// store the character
      continue;
    }
    if(ActChar == BACKSLASH_CHAR)	// is the single quote char.
    {
      QuoteFlag = 1;
      continue;
    }
    if(ActChar == QUOT_MARK_CHAR)	// end of quoted string
      break;
    pBuf[DstIndex++] = ActChar;		// save character
  } // FOR
  pDstBuf[0] = pBuf;
  return(DstIndex);  
}
/**
* Subroutine GetUnfoldedHdrLine unfolds a header line and removes
* all whitespace characters and RFC822 comments (GetUnfoldedHdrLine). If requested,
* removes quotes surrounding quoted strings and quoted pairs
* inside that strings too.
*
*  @param SrcBuf Base of source data
*  @param SrcOffset Start of data in buffer
*  @param SrcLen Length of source data
*  @param Mode BIT 0 == 0: keep quoted strings
*               BIT 0 != 0: remove quotes/quoted pairs
*               BIT 1 == 0: Start with field name
*               BIT 1 == 1: Assume Fieldname present
*  @param pNextOffset Offset to next line
*  @param pNextLen Remaining data
*  @param pDstBuf Allocated Line Buffer
*  @param pDataLen length of data in buffer/0
*
*  @return int Status - BASE64_OP_OK o.k. else error occured
*/
static  int GetUnfoldedHdrLine(HMEM_CTX_DEF
			char SrcBuf[], int SrcOffset,
			int SrcLen, int Mode,
			int pNextOffset[], int pNextLen[],
			char* pDstBuf[], int pDataLen[])
{
  int LineLen;

  char* pBuf = NULL;
  //---------------------------------------------------------------
  // check parameters
  //---------------------------------------------------------------
  if((SrcBuf == NULL) || (pNextOffset == NULL) || (pNextLen == NULL) ||
     (pDstBuf == NULL) || (pDataLen == NULL))
    return(BASE64_NULL_PTR);
  pDstBuf[0] = NULL;
  pDataLen[0] = 0;
  if(SrcLen == 0)
  {
    pNextOffset[0] = SrcOffset;
    pNextLen[0] = 0;
    return(RFC822_HDRLINE_GET_TOO_FEW_DATA);
  }
  //---------------------------------------------------------------------
  // get length of buffer to allocate, skip whitespaces/unquoted comments
  //---------------------------------------------------------------------
  LineLen = GetRFC822HdrLineChars(SrcBuf, SrcOffset, SrcLen, Mode,
			          pNextOffset, pNextLen, NULL);
  pDataLen[0] = LineLen;
  //---------------------------------------------------------------
  // allocate buffer of required length
  //---------------------------------------------------------------
  if(LineLen == 0)				// is an empty line
    return(BASE64_OP_OK);
  pBuf = BIT8_ARRAY_ALLOC(HMEM_CTX_REF,LineLen);
  if(pBuf == NULL)
    return(RFC822_HDRLINE_GET_ALLOC_ERR);
  pDstBuf[0] = pBuf;
  //---------------------------------------------------------------
  // copy the data to the allocated buffer
  //---------------------------------------------------------------
  GetRFC822HdrLineChars(SrcBuf, SrcOffset, SrcLen, Mode, NULL, NULL, pBuf);
  return(BASE64_OP_OK);
}
/**
* Subroutine GetCompactedTextLines copies normally base64 encoded
* lines in the text portion of a message into a buffer until
* end of encapsulation/EOF is reqched (GetCompactedTextLines). Removes all whitespaces and
* CR/LFs.
*
*  @param SrcBuf Base of source data
*  @param SrcOffset Start of data in buffer
*  @param SrcLen Length of source data
*  @param pNextOffset Offset to next line
*  @param pNextLen Remaining data length
*  @param pDstBuf Allocated Line Buffer
*  @param pDataLen length of data in buffer
*
*  @return int Status - BASE64_OP_OK: o.k. else error occured
*/
static  int GetCompactedTextLines(HMEM_CTX_DEF
			char SrcBuf[], int SrcOffset,
			int SrcLen, int pNextOffset[], int pNextLen[],
			char* pDstBuf[], int pDataLen[])
{
  char c;
  int SrcCount = SrcLen;
  int SrcIndex = SrcOffset;
  int DstIndex = 0;
  int LineLen = 0;


  char* pBuf = NULL;

  //---------------------------------------------------------------
  // check parameters
  //---------------------------------------------------------------
  if((SrcBuf == NULL) || (pNextOffset == NULL) || (pNextLen == NULL) ||
     (pDstBuf == NULL) || (pDataLen == NULL))
    return(BASE64_NULL_PTR);
  pDstBuf[0] = NULL;
  pDataLen[0] = 0;
  if(SrcLen == 0)
  {
    pNextOffset[0] = SrcOffset;
    pNextLen[0] = 0;
    return(BASE64_OP_OK);
  }
  //---------------------------------------------------------------
  // get length of buffer to allocate
  //---------------------------------------------------------------
  do
  {
    c = SrcBuf[SrcIndex];
    if(c == MINUS_CHAR) break;			// end found
    if((c != CR_CHAR) && (c != LF_CHAR) &&
       (c != SPACE_CHAR) && (c != HTAB_CHAR))
      LineLen++;
    SrcIndex++;
    SrcCount--;
  }while(SrcCount != 0);
  //---------------------------------------------------------------
  // allocate buffer of required length
  //---------------------------------------------------------------
  pNextOffset[0] = SrcIndex;
  pNextLen[0] = SrcCount;
  pDataLen[0] = LineLen;
  if(LineLen == 0)				// is an empty line
    return(BASE64_OP_OK);
  pBuf = BIT8_ARRAY_ALLOC(HMEM_CTX_REF,LineLen);
  if(pBuf == NULL)
    return(GET_COMPACTED_TXTLINE_ALLOC_ERR);
  pDstBuf[0] = pBuf;
  //---------------------------------------------------------------
  // copy the data to the allocated buffer
  //---------------------------------------------------------------
  SrcIndex = SrcOffset;				// to start of buffer
  SrcCount = SrcLen - SrcCount;			// length of data
  do
  {
    c = SrcBuf[SrcIndex++];
    if((c != CR_CHAR) && (c != LF_CHAR) &&
       (c != SPACE_CHAR) && (c != HTAB_CHAR))
      pBuf[DstIndex++] = c;
    SrcCount--;
  }while(SrcCount != 0);
  return(BASE64_OP_OK);
}
/**
* Subroutine GetEncapsulationBoundaryLine searches in buffer for the
* start of an encapsulation boundary line (a '-' in 1st position and
* 2nd character not a SPACE), searches for line termination and skips
* whitespaces backward from line termination (GetEncapsulationBoundaryLine).
* NOTE: Must start in line position 1 to achieve correct results !
* -----
*
*  @param SrcBuf Base of source data
*  @param SrcOffset Start of data in buffer
*  @param SrcLen Length of source data
*  @param pNextOffset Offset to next line
*  @param pNextLen Remaining data length
*  @param pStartOffset start of line data
*
*  @return int LineLen == 0 - End of Data, not found
* <br>            > 0 - Length of line Data
*/
static  int GetEncapsulationBoundaryLine(char SrcBuf[], int SrcOffset,
		 int SrcLen, int pNextOffset[], int pNextLen[],
		 int pStartOffset[])
{
  int LineLen = 0;

  char c;
  //---------------------------------------------------
  // preset return values
  //---------------------------------------------------
  pNextLen[0] = 0;
  pNextOffset[0] = SrcOffset;
  pStartOffset[0] = SrcOffset;

  if(SrcLen == 0) return(0);
  //---------------------------------------------------
  // check for encapsulation boundary until found
  //---------------------------------------------------
  while(SrcLen != 0)
  {
    //-------------------------------------------------------
    // check 1st character in line for encapsulation boundary
    //-------------------------------------------------------
    c = SrcBuf[SrcOffset++];
    SrcLen--;
    if(SrcLen == 0) break;			// cannot be a valid one
    if((c == MINUS_CHAR) && (SrcBuf[SrcOffset] != SPACE_CHAR)) // boundary
    {
      pStartOffset[0] = SrcOffset-1;    	// save start of data
      LineLen++;				// add count
      break;
    }
    if((c == CR_CHAR) && (SrcBuf[SrcOffset] == LF_CHAR))	// CRLF
    {
      SrcOffset++;				// Skip LF
      SrcLen--;
    }
    else
    {
      if((c != LF_CHAR) &&					// not EOL
         !((c == CR_CHAR) && (SrcBuf[SrcOffset] != LF_CHAR)))	// single CR
      {
        //-------------------------------------------------------
        // skip data until EOL / end of data
        //-------------------------------------------------------
        for(;;)
        {
          c = SrcBuf[SrcOffset++];		// get next
          SrcLen--;
          if(SrcLen == 0) break;		// no more data
          if((c == LF_CHAR) ||					// End Of Line
             ((c == CR_CHAR) && (SrcBuf[SrcOffset] != LF_CHAR))) // single CR
            break;
        }       
      }
    }
  } // while
  if(SrcLen == 0)
  {
    pNextOffset[0] = SrcOffset;
    return(0);
  }
  //-------------------------------------------------------
  // Start found, search for EOL/End of Data
  //-------------------------------------------------------
  for(;;)
  {
    c = SrcBuf[SrcOffset++];			// get character
    SrcLen--;
    if(SrcLen == 0)
    {
      if((c != CR_CHAR) && (c != LF_CHAR))
        LineLen++;
      break;
    }
    else
    {
      if((c == LF_CHAR) || (c == CR_CHAR))
      {
        if((c == CR_CHAR) && (SrcBuf[SrcOffset] == LF_CHAR))
        {
          SrcOffset++;
          SrcLen--;
        }
        break;
      }
      LineLen++;
    }
  } // FOR
  //-------------------------------------------------------
  // Skip backward whitespaces (SPC/TAB)
  //-------------------------------------------------------
  pNextOffset[0] = SrcOffset;			// set next pointer
  pNextLen[0] = SrcLen;				// set remaining length

  SrcOffset = pStartOffset[0] + LineLen -1;	// to last character
  SrcLen = LineLen;
  do
  {
    c = SrcBuf[SrcOffset--];			// get character
    if((c != SPACE_CHAR) && (c != HTAB_CHAR))
      break;
    LineLen--;					// reduce length
  }while(SrcLen != 0);
  return(LineLen);
}
/**
* Subroutine GetEncapsulationBoundaryType compares given encapsulation
* boundary with all the possible types (GetEncapsulationBoundaryType).
*
*  @param SrcBuf Base of source data
*  @param SrcOff Start of data in buffer
*  @param SrcLen Length of source data
*  @param pEncapType Found Type
*
*  @return int LineLen == 0 - End of Data, not found
* <br>            > 0 - Length of line Data,
* <br>            not including starting delimiter
* <br>            and the Start string('BEGIN ')
*/
static  int GetEncapsulationBoundaryType(char SrcBuf[], int SrcOff,
		 int SrcLen, int pEncapType[])
{
  int StartIndex = 0;

  int EntityCount;
  int EncapType;
  int ElementCount;
  int ActStrLen;
  int ActStrIndex;

  int ActOff;
  int ActLen;

  int CtlTabIndex = 0;
  int NextCtlTabIndex;

  char* pActStr;
  //---------------------------------------------------
  // Check if Starting Delimiter and String are present
  //---------------------------------------------------
  if(SrcLen < ((2*ENCAP_DELIM_STR_LEN) + ENCAP_START_STR_LEN + ENCAP_MINIMAL_STR_LEN))
    return(0);
  SrcLen -= (ENCAP_DELIM_STR_LEN + ENCAP_START_STR_LEN);
  if(memcmp((SrcBuf+SrcOff), ((char*) EncapDelimStr+0),ENCAP_DELIM_STR_LEN) != 0)
    return(0);
  SrcOff += ENCAP_DELIM_STR_LEN;		// Skip Delimiter
  if(memcmp((SrcBuf+SrcOff), ((char*) EncapStartStr+0),ENCAP_START_STR_LEN) != 0)
    return(0);
  SrcOff += ENCAP_START_STR_LEN;		// Skip Starting String
  StartIndex = SrcOff;				// save start to data
  //---------------------------------------------------
  // Start Comparing using the control table
  //---------------------------------------------------
  EntityCount = ENCAP_STR_ENTRIES_COUNT;
  do
  {
    ElementCount = EncapStrCtrlTab[CtlTabIndex++] & 0xFF; // get elements
    EncapType = EncapStrCtrlTab[CtlTabIndex++] & 0xFF; // get type in test
    ActOff = SrcOff;
    ActLen = SrcLen;
    NextCtlTabIndex = CtlTabIndex + ElementCount;
    //-----------------------------------------------------
    // Compare with the strings in the element
    //-----------------------------------------------------
    do
    {
      ActStrIndex = EncapStrCtrlTab[CtlTabIndex++] & 0xFF;// get table index
      ActStrLen = EncapStrCmpLenTab[ActStrIndex & 0x7F];
      pActStr = (char*) EncapStrPtrTab[ActStrIndex & 0x7F];
      if((ActLen < ActStrLen) && ((ActStrIndex & 0x80) == 0))
        break;						// shorter than req.
      if(ActLen >= ActStrLen)
      {
        if(memcmp((SrcBuf+ActOff), (pActStr+0),ActStrLen) !=0)
        {
          if((ActStrIndex & 0x80) == 0)			// required, missing
            break;
        }
        else
        {
          ActOff += ActStrLen;
          ActLen -= ActStrLen;
        }
      }
      ElementCount--;
    }while(ElementCount != 0);
    //---------------------------------------------
    // Check if all elements matched
    //---------------------------------------------
    if(ElementCount != 0)			// not matched
      CtlTabIndex = NextCtlTabIndex;		// skip this entry
    //---------------------------------------------
    // Match found, check for Ending Delimiter
    //---------------------------------------------
    else
    {
      SrcOff = ActOff;				// set past string
      SrcLen = ActLen;
      if(SrcLen < ENCAP_DELIM_STR_LEN)		// no Ending ----
        return(0);
      if(memcmp((SrcBuf+SrcOff), ((char*) EncapDelimStr+0),ENCAP_DELIM_STR_LEN) != 0)
        return(0);
      SrcOff += ENCAP_DELIM_STR_LEN;
      //-----------------------------------------------
      // Full line matched (remaining data not checked)
      //-----------------------------------------------
      pEncapType[0] = EncapType;
      return(SrcOff-StartIndex);
    }
    EntityCount--;				// to next element list
  }while(EntityCount != 0);
  return(0);					// list exhausted, not matched
}
/**
* Subroutine SetEncapsulationBoundaryLine constructs encapsulation
* boundary line Text including header and trailer from given type (SetEncapsulationBoundaryLine).
*
*  @param EncapType Encapsulation Type
*  @param Mode == 0 Starting Encapsulation
*               != 0 Ending encapsulation
*  @param DstBuf Destination buffer,
*               if NULL -> report requested length only
*  @param DstOff Start of data to write
*
*  @return int LineLen == 0 - Type not found
* <br>            > 0 - Length of line Data
*/
static  int SetEncapsulationBoundaryLine(int EncapType, int Mode,
		char DstBuf[], int DstOff)
{

  int CtlTabIndex = 0;
  int EntityCount = ENCAP_STR_ENTRIES_COUNT;
  int ElementCount;
  int LineLen;
  int ActStrIndex;
  int DstStartIndex;

  const char* pStr;
  //----------------------------------------------
  // Scan the Control table for the requested type
  //----------------------------------------------
  do
  {
    ElementCount = EncapStrCtrlTab[CtlTabIndex++] & 0xFF;	
    if(EncapType == (EncapStrCtrlTab[CtlTabIndex] & 0xFF))
      break;					// found type
    CtlTabIndex += (ElementCount+1);		// skip this entry
    EntityCount--;
  }while(EntityCount != 0);
  if(EntityCount == 0)
    return(0);					// type not found  
  CtlTabIndex++;				// to start of indices
  //----------------------------------------------
  // Distribute according to count/write mode
  //----------------------------------------------
  if(DstBuf == NULL)				// count Only
  {
    LineLen = 2*ENCAP_DELIM_STR_LEN+		// the delimiters+CRLF
		ENCAP_END_STR_LEN+ CRLF_LEN;	// assume ending + CRLF
    if(Mode == 0)
      LineLen += (ENCAP_START_STR_LEN-ENCAP_END_STR_LEN);

    do
    {
      ActStrIndex = EncapStrCtrlTab[CtlTabIndex++];
      if((ActStrIndex & 0x80) == 0)		// is not optional, add up
        LineLen += EncapStrCmpLenTab[ActStrIndex];
      ElementCount--;
    }while(ElementCount != 0);
    return(LineLen);
  }
  else
  {
    //----------------------------------------------------
    // Output Construct mode,
    // 1. Output the leader "-----BEGIN " or "-----END "
    //----------------------------------------------------
    DstStartIndex = DstOff;
    memcpy(DstBuf+DstOff,EncapDelimStr+0,ENCAP_DELIM_STR_LEN);
    DstOff += ENCAP_DELIM_STR_LEN;

    if(Mode == 0)
    {
      pStr = EncapStartStr;
      LineLen = ENCAP_START_STR_LEN;
    }
    else
    {
      pStr = EncapEndStr;
      LineLen = ENCAP_END_STR_LEN;
    }      
    memcpy(DstBuf+DstOff,pStr+0,LineLen);
    DstOff += LineLen;
    //----------------------------------------------------
    // 2. Output the encapsulation text from table
    //----------------------------------------------------
    do
    {
      ActStrIndex = EncapStrCtrlTab[CtlTabIndex++];
      if((ActStrIndex & 0x80) == 0)		// is not optional, append
      {
        pStr    = EncapStrPtrTab[ActStrIndex];
        LineLen = EncapStrCmpLenTab[ActStrIndex];
        memcpy(DstBuf+DstOff,pStr+0,LineLen);
        DstOff += LineLen;
      }
      ElementCount--;
    }while(ElementCount != 0);
    //----------------------------------------------------
    // 3. Output the trailer "-----" + CR/LF
    //----------------------------------------------------
    memcpy(DstBuf+DstOff,EncapDelimStr+0,ENCAP_DELIM_STR_LEN);
    DstOff += ENCAP_DELIM_STR_LEN;
    DstBuf[DstOff++] = CR_CHAR;
    DstBuf[DstOff++] = LF_CHAR;
    return(DstOff-DstStartIndex);
  }
}

extern "C"  int ToEncapsulatedBase64(HMEM_CTX_DEF
			char SrcBuf[], int SrcOffset,
			int SrcLen, int Type, int Mode,
			char* pDstBuf[], int pDstLen[])
{
  char* pBuf=NULL;

  int pTmpOff[1];
  int pTmpLen[1];

  int i;
  int DstIndex = 0;

  int StartStrLen;
  int EndStrLen;

  int BufLen;
  //-------------------------------------------------------
  // Check Input Parameters
  //-------------------------------------------------------
  if((SrcBuf == NULL) || (pDstBuf == NULL) || (pDstLen == NULL))
    return(BASE64_NULL_PTR);
  if(SrcLen <= 0)
    return(TO_BASE64_PARAM_ERR);
  //-------------------------------------------------------
  // Get pointer and size of Header/Trailer Strings
  //-------------------------------------------------------
  StartStrLen = SetEncapsulationBoundaryLine(Type, 0, NULL, 0);
  if(StartStrLen == 0)
    return(TO_BASE64_PARAM_ERR);
  EndStrLen = StartStrLen -(ENCAP_START_STR_LEN-ENCAP_END_STR_LEN);
  //-------------------------------------------------------
  // Calculate required destination buffer size, allocate
  //-------------------------------------------------------
  BufLen = ((SrcLen + 2) / 3)*4;		// bytes after conversion
  i      = (BufLen + MAX_CHARS_PER_LINE-1) /	// get required lines
              MAX_CHARS_PER_LINE;
  if(Mode == 0)					// with leading spaces
    BufLen += (i * (CRLF_LEN+1));		// + times(CR/LF + SPACE (!))
  else
    BufLen += (i * CRLF_LEN);			// + times(CR/LF)

  BufLen += StartStrLen+EndStrLen;		// + header/Trailer Strings
  pBuf = BIT8_ARRAY_ALLOC(HMEM_CTX_REF,BufLen);
  if(pBuf == NULL) return(TO_BASE64_ALLOC_ERR);
  pDstBuf[0] = pBuf;
  pDstLen[0] = BufLen;
  //-------------------------------------------------------
  // Copy Start String to buffer, append CR/LF
  //-------------------------------------------------------
  SetEncapsulationBoundaryLine(Type, 0, pBuf, 0);
  DstIndex = StartStrLen;
  //-------------------------------------------------------
  // Convert/Store the input bytes
  //-------------------------------------------------------
  pTmpOff[0] = DstIndex;
  pTmpLen[0] = BufLen - StartStrLen - CRLF_LEN;
  ConvStoreHexToB64(SrcBuf, SrcOffset, SrcLen, Mode, pBuf, pTmpOff, pTmpLen);
  DstIndex = pTmpOff[0];
  //-------------------------------------------------------
  // Copy End String to buffer, append CR/LF
  //-------------------------------------------------------
  SetEncapsulationBoundaryLine(Type, 1, pBuf, DstIndex);
  return(BASE64_OP_OK);
}
/**
* Subroutine CheckMimeVersionLine searches in buffer for the
* MIME-Version field and assures that Version is 1,0 (CheckMimeVersionLine).
* NOTE: 1. Should start at a line start position(after CRLF)
* ----- 2. Only if Mime Version is found the next offset and length
*	    will be valid
*
*  @param SrcBuf Base of source data
*  @param SrcOffset Start of data in buffer
*  @param SrcLen Length of source data
*  @param pNextOffset Offset to next line
*  @param pNextLen Remaining data length
*
*  @return int Status == 0 - End of Data, not found
* <br>            != 0 - is MIME V1.0
*/
static  int CheckMimeVersionLine(HMEM_CTX_DEF
		char SrcBuf[], int SrcOffset,
		int SrcLen, int pNextOffset[], int pNextLen[])
{
  char c,cLast;
 
  char * pTmpBuf[1];
  int pTmpLen[1];
  //---------------------------------------------------
  // preset return values
  //---------------------------------------------------
  pNextLen[0] = 0;
  pNextOffset[0] = SrcOffset;

  if(SrcLen == 0) return(0);
  //---------------------------------------------------
  // search for MIME-Version field name
  //---------------------------------------------------
  pTmpBuf[0] = NULL;
  while(SrcLen >= MIME_VERS_STR_TOTAL_LEN)
  {
    //-------------------------------------------------------
    // check 1st character in line for encapsulation boundary
    //-------------------------------------------------------
    c = SrcBuf[SrcOffset];			// get character
    if((c == 'M') || (c == 'm'))		// might be field name
    {
      
      //--------------------------------------------
      // Compare the fieldname, case insensitive
      //--------------------------------------------
      if(CmpBit8BufToString(SrcBuf,SrcOffset,SrcLen,
			MimeVersStr,0,MIME_VERS_FIELD_NAME_LEN,0) == 0)
      {
        //-------------------------------------------------------
        // field found, get compacted rest of line for this field
        //-------------------------------------------------------
        SrcOffset += MIME_VERS_FIELD_NAME_LEN;	// skip
        SrcLen    -= MIME_VERS_FIELD_NAME_LEN;	// dto.
        if(GetUnfoldedHdrLine(HMEM_CTX_REF1
			      SrcBuf,SrcOffset,SrcLen, 1, pNextOffset,
			      pNextLen,pTmpBuf,pTmpLen) != BASE64_OP_OK)
           break;				// error, exit, not found
        if(pTmpLen[0] == (MIME_VERS_STR_TOTAL_LEN-	// correct length
			  MIME_VERS_FIELD_NAME_LEN))
        {
          if(CmpBit8BufToString(pTmpBuf[0],0,pTmpLen[0],MimeVersStr,
			MIME_VERS_FIELD_NAME_LEN,
			MIME_VERS_STR_TOTAL_LEN-MIME_VERS_FIELD_NAME_LEN,
			0) == 0)
          {
            FREE_ARRAY(HMEM_CTX_REF,pTmpBuf[0]);
            return(1);
          }
        }
        FREE_ARRAY(HMEM_CTX_REF,pTmpBuf[0]);	// remove buffer
        SrcOffset = pNextOffset[0];		// to next start of line
        SrcLen = pNextLen[0];
        continue;				// at start of line
      } // Header field compare IF
    } // 1st character compare IF
    //-------------------------------------------------------
    // skip data until EOL / end of data
    //-------------------------------------------------------
    SrcOffset++;				// skip actual char
    SrcLen--;
    if(SrcLen < MIME_VERS_STR_TOTAL_LEN) break;// cannot be a valid one
    for(;;)
    {
      cLast = c;				// save last one
      c = SrcBuf[SrcOffset++];			// get next
      SrcLen--;
      if(SrcLen < MIME_VERS_STR_TOTAL_LEN) break;// cannot be a valid one
      if((cLast == CR_CHAR) || (cLast == LF_CHAR))
      {
        if((c == SPACE_CHAR) || (c == HTAB_CHAR)) // is a folding, ignore
          continue;
        if((cLast == CR_CHAR) && (c == LF_CHAR))  // CR-LF, ignore for now
          continue;

        if(((cLast == CR_CHAR) && (c != LF_CHAR)) || // not CR/LF
            (cLast == LF_CHAR))			     // LF and something
        {
          SrcOffset--;
          SrcLen++;
          break;
        }
      }
    } // skip FOR      
  } // search WHILE
  return(0);
}
/**
* Subroutine GetMimeContentType decodes header lines from given position
* until either end of data or end of header (empty line) is encountered (GetMimeContentType).
*
* NOTE: 1. Must start at a line start position(after CRLF)
* ----- 2. Only Multipart / Application are checked
*
*  @param SrcBuf Base of source data
*  @param SrcOffset Start of data in buffer
*  @param SrcLen Length of source data
*  @param pNextOffset Offset to next line
*  @param pNextLen Remaining data length
*  @param pBoundary Boundary if mixed message / NULL
*  @param pBoundaryLen length of boundary
*  @param pContentType 0 - none found, at end/Start of text
*               1 - Multipart, boundary loaded
*               2 - Application pkcs7/x-pkcs7
*               3 - Application pkcs10/x-pkcs10
*
*  @return int Status BASE64_OP_OK else error occured
*/
static  int GetMimeContentType(HMEM_CTX_DEF
		char SrcBuf[], int SrcOffset,
		int SrcLen, int pNextOffset[], int pNextLen[],
		char* pBoundary[], int pBoundaryLen[],
		int pContentType[])
{
  char c = 0;
  int i;
  int HdrLineOff;
  int HdrLineLen;
  char* pHdrLine;
 
  char * pTmpBuf[1];
  int pTmpLen[1];
  //---------------------------------------------------
  // preset return values
  //---------------------------------------------------
  pNextLen[0] = 0;
  pNextOffset[0] = SrcOffset;
  pBoundaryLen[0] = 0;
  pContentType[0] = 0;
  if(SrcLen == 0) return(BASE64_OP_OK);
  //---------------------------------------------------------
  // search for Content-Type header field
  // NOTE: the boundary parameter of a multipart message
  // ----- may appear on a separat line (ill behaved Mailers)
  //---------------------------------------------------------
  pTmpBuf[0] = NULL;
  while(SrcLen >= CONTENT_TYPE_LEN)
  {
    //-------------------------------------------------------
    // get unfolded header line, do NOT remove quoting
    //-------------------------------------------------------
    if((i = GetUnfoldedHdrLine(HMEM_CTX_REF1
			SrcBuf,SrcOffset,SrcLen, 0, pNextOffset,
			pNextLen,pTmpBuf,pTmpLen)) != BASE64_OP_OK)
      return(i);			// error occured
    pHdrLine = pTmpBuf[0];
    HdrLineOff = 0;
    HdrLineLen = pTmpLen[0];

    if(HdrLineLen == 0)			// empty line, start of Text !!
      return(BASE64_OP_OK);

    SrcOffset = pNextOffset[0];
    SrcLen = pNextLen[0];
    //----------------------------------------------------------
    // Check if line starts with "Content-type:"
    //----------------------------------------------------------
    if(CmpBit8BufToString(pHdrLine,0,HdrLineLen,ContentTypeStr,0,
			CONTENT_TYPE_LEN,0) == 0) // is present
    {
      HdrLineLen -= CONTENT_TYPE_LEN;
      HdrLineOff += CONTENT_TYPE_LEN;
      //---------------------------------------------------------------
      // Content type found, check if recognized(multipart/application)
      //---------------------------------------------------------------
      if(CmpBit8BufToString(pHdrLine,HdrLineOff,HdrLineLen,
			    MultipartStr,0,MULTIPART_TYPE_LEN,0) == 0)
      {
        //-----------------------------------------------------------
        // Multipart contents found, subtype don't care, get boundary
        //-----------------------------------------------------------
        HdrLineLen -= MULTIPART_TYPE_LEN;
        HdrLineOff += MULTIPART_TYPE_LEN;
        while(HdrLineLen != 0)
        {
          c = pHdrLine[HdrLineOff++];
          HdrLineLen--;
          if(c == SEMICOLON_CHAR) break;
        }
        if(c != SEMICOLON_CHAR)		// required parameter missing
        {
          FREE_ARRAY(HMEM_CTX_REF,pHdrLine);
          return(FROM_MIME_FMT_ERROR);
        }
        //------------------------------------------------------------
        // check for boundary placement anomaly (on next line)
        //------------------------------------------------------------
        if(HdrLineLen == 0)
        {
          FREE_ARRAY(HMEM_CTX_REF,pHdrLine);
          if((i = GetUnfoldedHdrLine(HMEM_CTX_REF1
			  SrcBuf,SrcOffset,SrcLen, 2, pNextOffset,
			  pNextLen,pTmpBuf,pTmpLen)) != BASE64_OP_OK)
            return(i);			// error occured
          pHdrLine = pTmpBuf[0];
          HdrLineOff = 0;
          HdrLineLen = pTmpLen[0];

          if(HdrLineLen == 0)		// empty line, start of Text !!
            return(FROM_MIME_FMT_ERROR);
 
          SrcOffset = pNextOffset[0];
          SrcLen = pNextLen[0];
        }
        if(CmpBit8BufToString(pHdrLine,HdrLineOff,HdrLineLen,
			    BoundaryParStr,0,BOUNDARY_PAR_NAME_LEN,0) != 0)
        {
          FREE_ARRAY(HMEM_CTX_REF,pHdrLine);	// no boundary found !!
          return(FROM_MIME_FMT_ERROR);
        }
        HdrLineOff += BOUNDARY_PAR_NAME_LEN;
        HdrLineLen -= BOUNDARY_PAR_NAME_LEN;
        //--------------------------------------------------------------
        // Boundary found, check if valid (must start with two hyphens)
        // NOTE: if boundary is quoted -> convert to unquoted
        //--------------------------------------------------------------
        if(pHdrLine[HdrLineOff] == QUOT_MARK_CHAR)	// is quoted
        {
          i = UnquoteRFC822QuotedString(HMEM_CTX_REF1
			pHdrLine, HdrLineOff, HdrLineLen,
			NULL, NULL, pTmpBuf);
          FREE_ARRAY(HMEM_CTX_REF,pHdrLine);
          if(i <= 0) return(FROM_MIME_FMT_ERROR);	// Format Error
          pHdrLine = pTmpBuf[0];
          HdrLineOff = 0;
          HdrLineLen = i;
        }
        if((HdrLineLen < BOUNDARY_PAR_MIN_LEN) ||
           (HdrLineLen > BOUNDARY_PAR_MAX_LEN))
        {
          FREE_ARRAY(HMEM_CTX_REF,pHdrLine);
          return(FROM_MIME_FMT_ERROR);
        }
        //--------------------------------------------------------------
        // Transfer Boundary data, prepend "--"
        //--------------------------------------------------------------
        pBoundary[0] = BIT8_ARRAY_ALLOC(HMEM_CTX_REF,HdrLineLen+2);
        if(pBoundary[0] == NULL)
        {
          FREE_ARRAY(HMEM_CTX_REF,pHdrLine);
          return(FROM_SMIME_BOUNDARYBUF_ALLOC_ER);
        }
        pBoundary[0][0] = MINUS_CHAR;
        pBoundary[0][1] = MINUS_CHAR;

        memcpy(pBoundary[0]+2,pHdrLine+HdrLineOff,HdrLineLen);
        FREE_ARRAY(HMEM_CTX_REF,pHdrLine);
        pBoundaryLen[0] = HdrLineLen+2;	// set length
        pContentType[0] = 1;
        return(BASE64_OP_OK);
      } // Multipart processing
      //---------------------------------------------------------------
      // Check if Content type application
      //---------------------------------------------------------------
      if(CmpBit8BufToString(pHdrLine,HdrLineOff,HdrLineLen,
			    ApplicationStr,0,APPLICATION_TYPE_LEN,0) == 0)
      {
        //---------------------------------------------------------------
        // Application type found, check subtypes
        //---------------------------------------------------------------
        HdrLineOff += APPLICATION_TYPE_LEN;
        HdrLineLen -= APPLICATION_TYPE_LEN;
        if(HdrLineLen == 0)
        {
          FREE_ARRAY(HMEM_CTX_REF,pHdrLine);
          return(FROM_MIME_FMT_ERROR);
        }
        c = pHdrLine[HdrLineOff];
        i = 2;				// no x- extension
        if((c == 'x') || (c == 'X'))
          i = 0;

        if(CmpBit8BufToString(pHdrLine,HdrLineOff,HdrLineLen,
			      xPkcs7MimeStr,i,xPKCS7_MIME_STR_LEN-i,0) == 0)
            pContentType[0] = 2;
        else            
          if(CmpBit8BufToString(pHdrLine,HdrLineOff,HdrLineLen,
			      xPkcs10MimeStr,i,xPKCS10_MIME_STR_LEN-i,0) == 0)
            pContentType[0] = 3;
        FREE_ARRAY(HMEM_CTX_REF,pHdrLine);
        if(pContentType[0] != 0)
        {          
         //---------------------------------------------------------------
          // found recognized content, skip header til start of body
          //---------------------------------------------------------------
          for(;;)
          {
            if((i = GetUnfoldedHdrLine(HMEM_CTX_REF1
			  SrcBuf,SrcOffset,SrcLen, 0, pNextOffset,
			  pNextLen,pTmpBuf,pTmpLen)) != BASE64_OP_OK)
            return(i);			// error occured
            if(pTmpLen[0] == 0)		// found body start
              return(BASE64_OP_OK);
            SrcOffset = pNextOffset[0];
            SrcLen    = pNextLen[0];
            FREE_ARRAY(HMEM_CTX_REF,pHdrLine);
          }
        } // Application content recognized
      } // Application Content
    } // Content type found
    FREE_ARRAY(HMEM_CTX_REF,pHdrLine);
  } // outer WHILE
  //----------------------------------------------------
  // no appropriate content found
  //----------------------------------------------------
  return(BASE64_OP_OK);
}

extern "C"  int ConvStoreB64ToHex(char SrcBuf[], int SrcOffset, int SrcLen,
                                  char DstBuf[], int DstOffset, int pDstLen[])

{
  unsigned char c1;	// NOTE: M U S T be of type BYTE !!
  char c2;

  int DstStart = DstOffset;
  int ActByteIndex = 0;

  char ActByteBuf[4];
  //-----------------------------------------------------------
  // check for valid length (must be multiple of 4)
  //-----------------------------------------------------------
  pDstLen[0] = 0;
  if((SrcLen & 0x03) != 0)
    return(FROM_BASE64_INVALID_DATALEN);
  if(SrcLen == 0)
    return(BASE64_OP_OK);
  //---------------------------------------------------------
  // Process all data quads
  //---------------------------------------------------------
  ActByteIndex = 0;
  do
  {
    c1 = SrcBuf[SrcOffset++];			// get source character
    if((c1 < SPACE_CHAR) || (c1 > DEL_CHAR))	// check if basically valid
      c1 = (unsigned char) 0xFF;				// set invalid
    else
      c1 = Base64DecodeTab[c1-0x20];		// convert, check
    SrcLen--;
    //--------------------------------------------------
    // check for Invalid Base64 Characters
    //--------------------------------------------------
    if(c1 == (unsigned char) 0xFF)			// invalid character
      return(FROM_BASE64_CHAR_ERR);
    //--------------------------------------------------
    // check for Padding Base64 Character ('=')
    //--------------------------------------------------
    if(c1 == (unsigned char) 0xFE)			// padding character
    {
      if((SrcLen > 1) ||			// (1) must be in last 2 chars
           ((SrcLen == 1) &&			// (2) 2 Characters left:
            ((SrcBuf[SrcOffset] != EQUAL_CHAR) || // (2a)  last must be padding 
             ((ActByteBuf[1] & 0x0F) != 0))) ||	// (2b) low 4 bits must be zero
           ((SrcLen == 0) &&			// (3) 1 Character left: 
             ((ActByteBuf[2] & 0x03) != 0)))	// (3a) low 2 bits must be zero

        return(FROM_BASE64_PAD_ERR);

      c1 = ActByteBuf[1];			// get 2nd byte (always pres.)
      DstBuf[DstOffset++] =
          (unsigned char) ((ActByteBuf[0] << 2) |	// get 1st byte
		  (c1 >> 4));			// insert 2 bits from 2nd

      if(SrcLen == 0)				// 1 byte Padding, 16 Bits out
      {
        c2 = ActByteBuf[2];			// get 3rd byte
        c1 <<= 4;				// get 4 LSB Bits from 2nd
        DstBuf[DstOffset++] =
	    (unsigned char) (c1 | (c2 >> 2));		// insert 4 Bits from 3rd
      }
      break;
    }
    //---------------------------------------------------------
    // Standard Base64 Character, buffer, check if Quad present
    //---------------------------------------------------------
    ActByteBuf[ActByteIndex++] = c1;		// save byte
    if(ActByteIndex == 4)			// Quad present, process !
    {
      c1 = ActByteBuf[1];			// get 2nd byte
      DstBuf[DstOffset++] = 
          (unsigned char) ((ActByteBuf[0] << 2) |	// get 1st byte
		  (c1 >> 4));			// insert 2 bits from 2nd
      c2 = ActByteBuf[2];			// get 3rd byte
      c1 <<= 4;					// get 4 LSB Bits from 2nd
      DstBuf[DstOffset++] = (unsigned char) (c1 | (c2 >> 2)); // insert 4 Bits from 3rd
      c1 = ActByteBuf[3];			// get 4th byte
      DstBuf[DstOffset++] = (unsigned char) (c1 | (c2 << 6));// insert top 2 bits
      ActByteIndex = 0;				// reset index
    }
  }while(SrcLen != 0);				// for all bytes
  //---------------------------------------------------------
  // Report true destination length
  //---------------------------------------------------------
  pDstLen[0] = DstOffset-DstStart;
  return(BASE64_OP_OK);
}

extern "C"  int FromEncapsulatedBase64(HMEM_CTX_DEF
			char SrcBuf[], int SrcOffset,
			int SrcLen, char* pDstBuf[], int pDstLen[],
			int pEncapType[])
{
  int Retcode;
  int LineLen;

  int StartStrLen;
  int EndStrLen;
  int StringStart;

  int pTmpNextOff[1];
  int pTmpNextLen[1];
  int pTmpStartOff[1];
  //---------------------------------------------------------
  // Check parameters
  //---------------------------------------------------------
  if((SrcBuf == NULL) || (pDstBuf == NULL) || (pDstLen == NULL))
    return(BASE64_NULL_PTR);
//  if((SrcLen <= 0) ||((Type != CERT_REQ_TYPE) && (Type != CERT_TYPE)))
//    return(FROM_BASE64_PARAM_ERR);
  if(SrcLen <= 0)
    return(FROM_BASE64_PARAM_ERR);
  //---------------------------------------------------------
  // Search for Starting Encapsulation Boundary String(s)
  //---------------------------------------------------------
  for(;;)
  {
    LineLen = GetEncapsulationBoundaryLine(SrcBuf,SrcOffset,SrcLen,
                    pTmpNextOff,pTmpNextLen,pTmpStartOff);
    if(LineLen == 0)
      return(FROM_BASE64_START_NOT_FOUND);
    SrcOffset   = pTmpNextOff[0];
    SrcLen      = pTmpNextLen[0];

    StringStart = pTmpStartOff[0];

    StartStrLen = GetEncapsulationBoundaryType(SrcBuf,StringStart,
		  LineLen, pEncapType);
    if(StartStrLen != 0)		// Start found, check if decodable
    {
      if(pEncapType[0] == PEM_DATA_TYPE) // PEM needs special processing!!
//        return(FROM_BASE64_START_NOT_FOUND);
        return(BASE64_OP_OK);		// fake o.k. !!
      break;				// is usable
    }
  } // for
  StringStart += ENCAP_DELIM_STR_LEN + ENCAP_START_STR_LEN;
  EndStrLen   =  ENCAP_DELIM_STR_LEN + ENCAP_END_STR_LEN + StartStrLen;
  //-----------------------------------------------------------
  // Start found, generate compacted base64 data line
  //-----------------------------------------------------------
  if(SrcLen == 0)
     return(FROM_BASE64_INVALID_DATALEN);

  Retcode = GetCompactedTextLines(HMEM_CTX_REF1
			SrcBuf, SrcOffset, SrcLen,
			pTmpNextOff,pTmpNextLen,pDstBuf,pDstLen);
  if(Retcode != BASE64_OP_OK)
    return(Retcode);

  Retcode = ConvStoreB64ToHex(pDstBuf[0],0, pDstLen[0],
			      pDstBuf[0],0, pDstLen);
  if(Retcode != BASE64_OP_OK)
  {
    FREE_ARRAY(HMEM_CTX_REF,pDstBuf[0]);
    return(Retcode);
  }
  SrcOffset = pTmpNextOff[0];
  SrcLen    = pTmpNextLen[0];
  //---------------------------------------------------------
  // Search for Ending Encapsulation Boundary String(s)
  //---------------------------------------------------------
  Retcode = FROM_BASE64_INVALID_END;		// preset error
  for(;;)					// error for
  {
    LineLen = GetEncapsulationBoundaryLine(SrcBuf,SrcOffset,SrcLen,
                    pTmpNextOff,pTmpNextLen,pTmpStartOff);

    if(LineLen != EndStrLen) break;		// not expected !!
    SrcOffset = pTmpStartOff[0];		// get start offset

    if(memcmp((SrcBuf+SrcOffset), ((char*)EncapDelimStr+0),ENCAP_DELIM_STR_LEN) != 0)
      break;					// no delimiter
    SrcOffset += ENCAP_DELIM_STR_LEN;
    if(memcmp((SrcBuf+SrcOffset), ((char*) EncapEndStr+0),ENCAP_END_STR_LEN) != 0)
      break;					// no END
    SrcOffset += ENCAP_END_STR_LEN;
    if(memcmp((SrcBuf+SrcOffset), (SrcBuf+StringStart),StartStrLen) != 0)
      break;					// no END

    Retcode = BASE64_OP_OK;
    break;
  } // Error FOR
  if(Retcode != BASE64_OP_OK)
    FREE_ARRAY(HMEM_CTX_REF,pDstBuf[0]);
  return(Retcode);
}

extern "C"  int  FromPrivKeyToOpenSslPEM(HMEM_CTX_DEF
		RSA_STRUC* pRsaStruc,
		DSA_STRUC* pDsaStruc, char* ppDstBuf[], int pDstLen[])
{
  int Retcode;

  int PemType = -1;
  int EncDataLen = 0;

  char* pEncDataBuf = NULL;

  char * ppTmpBuf[1];

  int pTmpLen[1];
  //---------------------------------------------
  // Check parameters
  //---------------------------------------------
  if(((pRsaStruc == NULL) && (pDsaStruc == NULL)) ||
      (ppDstBuf == NULL) || (pDstLen == NULL))
    return(BASE64_NULL_PTR);

  ppDstBuf[0] = NULL;
  pDstLen[0]  = 0;
  //-----------------------------------------------------------------
  // Convert RSA/DSA key to ASN.1 encoded data 
  //-----------------------------------------------------------------
  if(pRsaStruc != NULL)				// RSA key
  {
    PemType = RSA_PRIVKEY_DATA_TYPE;
    if((Retcode = ToOpensslRsaPrivKey(HMEM_CTX_REF1 pRsaStruc,ppTmpBuf,pTmpLen)) != ASN1_OP_OK)
      return(TO_PEM_OPSSL_RSA_PRIVKEY_ERR);
  }
  else						// DSA key
  {
    PemType = DSA_PRIVKEY_DATA_TYPE;
    if((Retcode = ToOpensslDsaPrivKey(HMEM_CTX_REF1 pDsaStruc,ppTmpBuf,pTmpLen)) != ASN1_OP_OK)
      return(TO_PEM_OPSSL_DSA_PRIVKEY_ERR);
  }
  pEncDataBuf = ppTmpBuf[0];
  EncDataLen  = pTmpLen[0];

  //------------------------------------------------------------
  // Wrap data into base64, output with header and trailer lines
  //------------------------------------------------------------
  Retcode = ToEncapsulatedBase64(HMEM_CTX_REF1
				 pEncDataBuf, 0, EncDataLen, PemType, 1,
				 ppDstBuf, pDstLen);
  FREE_CARRAY(HMEM_CTX_REF,pEncDataBuf);
  return(Retcode);
}

extern "C"  int  FromOpenSslPEMToPrivKey(HMEM_CTX_DEF
			char pSrcBuf[], int SrcOff,
			int SrcLen, int pPemType[],
			RSA_STRUC* ppRsaStruc[], DSA_STRUC* ppDsaStruc[])
{
  int Retcode;

  int PemType = -1;
  int DecDataLen = 0;

  char* pDecDataBuf = NULL;

  char * ppTmpBuf[1];

  int pTmpLen[1];
  int pTmpType[1];

  RSA_STRUC* pTmpRsaStruc[1] = {NULL};
  DSA_STRUC* pTmpDsaStruc[1] = {NULL};
  //---------------------------------------------
  // Check parameters
  //---------------------------------------------
  if(pSrcBuf == NULL)
    return(BASE64_NULL_PTR);

  if(pPemType != NULL)
    pPemType[0] = B64_UNKNOWN_DATA_TYPE;

  if(ppRsaStruc != NULL)
    ppRsaStruc[0] = NULL;
  if(ppDsaStruc != NULL)
    ppDsaStruc[0] = NULL;

  //--------------------------------------------
  // Unwrap the data and Base64 decode them
  //--------------------------------------------
  if((Retcode = FromEncapsulatedBase64(HMEM_CTX_REF1
			   pSrcBuf, SrcOff, SrcLen,
			   ppTmpBuf, pTmpLen, pTmpType)) != BASE64_OP_OK)
  {
    if(Retcode == FROM_BASE64_START_NOT_FOUND)	// type not defined...
      return(BASE64_OP_OK);

    return(Retcode);
  }
  //-----------------------------------------------------------
  // Check if type is a RSA / DSA private key in OpenSSL format
  //-----------------------------------------------------------
  PemType = pTmpType[0];
  pDecDataBuf = ppTmpBuf[0];
  DecDataLen  = pTmpLen[0];
  if((PemType != RSA_PRIVKEY_DATA_TYPE) && (PemType != DSA_PRIVKEY_DATA_TYPE))
  {
    FREE_CARRAY(HMEM_CTX_REF,pDecDataBuf);
    return(BASE64_OP_OK);
  }
  if(pPemType != NULL)
    pPemType[0] = PemType;

  //--------------------------------------------------------------
  // Decode the RSA/DSA keys to structure
  //--------------------------------------------------------------
  if(PemType == RSA_PRIVKEY_DATA_TYPE)		// RSA key
  {
    Retcode = FromOpensslRsaPrivKey(HMEM_CTX_REF1 pDecDataBuf,0,DecDataLen,pTmpRsaStruc);
    FREE_CARRAY(HMEM_CTX_REF,pDecDataBuf);
    if(Retcode != ASN1_OP_OK)
      return(Retcode);

    if(ppRsaStruc != NULL)
      ppRsaStruc[0] = pTmpRsaStruc[0];
    else
      RSA_Free(HMEM_CTX_REF1 pTmpRsaStruc[0]);
    return(Retcode);
  }
  else						// DSA key
  {
    Retcode = FromOpensslDsaPrivKey(HMEM_CTX_REF1 pDecDataBuf,0,DecDataLen,pTmpDsaStruc);
    FREE_CARRAY(HMEM_CTX_REF,pDecDataBuf);
    if(Retcode != ASN1_OP_OK)
      return(Retcode);

    if(ppDsaStruc != NULL)
      ppDsaStruc[0] = pTmpDsaStruc[0];
    else
      DSA_Free(HMEM_CTX_REF1 pTmpDsaStruc[0]);
    return(Retcode);
  }
}






/**
* Decodes MIME file and extracts
* PKCS7 / PKCS10 Base64 decoded data (if any) (GetDecodeMimePKCSData).
*
*  @param SrcBuf Base of source data
*  @param SrcOffset Start of data in buffer
*  @param SrcLen Length of source data
*  @param pDstBuf Allocated buffer. Optional
*  @param pDstLen Length of decoded data
*  @param pContentType 0 - none found, at end/Start of text <br>
*               1 - Multipart, boundary loaded <br>
*               2 - Application pkcs7/x-pkcs7 <br>
*               3 - Application pkcs10/x-pkcs10
*
*  @return int Status BASE64_OP_OK else error occured
*/
extern "C"  int GetDecodeMimePKCSData(HMEM_CTX_DEF
		char SrcBuf[], int SrcOffset,
		int SrcLen, char* pDstBuf[], int pDstLen[],
		int pContentType[])
{
  int i;
  int BoundaryLen = 0;
  int LineLen;

  int pNextOffset[1];
  int pNextLen[1];
  int pTmpOff[1];
  int pTmpLen[1];

  char* pBoundary = NULL;
  char* pLineBuf;

  char * pTmpBuf[1];

  //------------------------------------------------------------
  // Check if file is in Mime Format
  //------------------------------------------------------------
  if(CheckMimeVersionLine(HMEM_CTX_REF1
			  SrcBuf,SrcOffset,SrcLen,pNextOffset,pNextLen) == 0)
    return(FROM_MIME_NO_MIME_FILE);
  //------------------------------------------------------------
  // Get Main Header Content-Type, check if MULTI-Part
  //------------------------------------------------------------
  i = GetMimeContentType(HMEM_CTX_REF1
			 SrcBuf,pNextOffset[0],pNextLen[0],
		         pNextOffset,pNextLen, pTmpBuf,
		         pTmpLen,pContentType);
  if(i != BASE64_OP_OK)
    return(i);
  switch(pContentType[0])
  {
    case 0:				// no appropriate content type
      return(FROM_MIME_NO_DATA);
  
    case 1:				// Multi-Part
      pBoundary   = pTmpBuf[0];		// save boundary
      BoundaryLen = pTmpLen[0];		// save length
      break;

    case 2:				// PKCS7
    case 3:				// PKCS10
      //--------------------------------------------------
      // Simple content type, process
      //--------------------------------------------------
      i = GetCompactedTextLines(HMEM_CTX_REF1
				SrcBuf,pNextOffset[0],pNextLen[0],
		                pNextOffset,pNextLen, pTmpBuf, pTmpLen);
      if(i != BASE64_OP_OK) return(i);

      pLineBuf = pTmpBuf[0];
      LineLen  = pTmpLen[0];

      i = ConvStoreB64ToHex(pLineBuf, 0, LineLen, pLineBuf, 0, pTmpLen);
      if(i != BASE64_OP_OK)
      {
        FREE_ARRAY(HMEM_CTX_REF,pLineBuf);
      }
      else
      {
        pDstBuf[0] = pLineBuf;
        pDstLen[0] = pTmpLen[0];
      }
      return(i);
  } // switch
  //------------------------------------------------------------
  // Multipart Processing, search for Encapsulation line
  //------------------------------------------------------------
  for(;;)
  {
    LineLen = GetEncapsulationBoundaryLine(SrcBuf,pNextOffset[0],pNextLen[0],
                    pNextOffset,pNextLen,pTmpOff);
    if(LineLen == 0) break;			// no data found
    if((LineLen < BoundaryLen) ||		// maybe another one !
//       (CmpBit8BufToString(SrcBuf,pTmpOff[0],LineLen,
//			   pBoundary,0,BoundaryLen,0) != 0)) // dto.
       (CmpCaseInsensitive(SrcBuf,pTmpOff[0],LineLen,
			   pBoundary,0,BoundaryLen) != 0))


      continue;					// try next
    //----------------------------------------------------------
    // Found the Boundary, check if last boundary (trailing "--")
    //----------------------------------------------------------
    if(LineLen >= BoundaryLen + 2)
    {
      SrcOffset = pTmpOff[0]+BoundaryLen;
      if((SrcBuf[SrcOffset]   == MINUS_CHAR) &&
         (SrcBuf[SrcOffset+1] == MINUS_CHAR)) break;
    }
    //----------------------------------------------------------
    // Not the last boundary, check content Type of Entity
    //----------------------------------------------------------
    i = GetMimeContentType(HMEM_CTX_REF1
			   SrcBuf,pNextOffset[0],pNextLen[0],
		           pNextOffset,pNextLen, pTmpBuf,
		           pTmpLen,pContentType);
    if(i != BASE64_OP_OK) break;
    i = pContentType[0];
    if(i == 0) continue;		// no recognized content type
    if(i == 1)				// nested multipart, just ignore
    {
      FREE_ARRAY(HMEM_CTX_REF,pTmpBuf[0]);// discard nested boundary data
      continue;
    }
    //--------------------------------------------------
    // Simple content type, process
    //--------------------------------------------------
    i = GetCompactedTextLines(HMEM_CTX_REF1
			      SrcBuf,pNextOffset[0],pNextLen[0],
		              pNextOffset,pNextLen, pTmpBuf, pTmpLen);
    if(i != BASE64_OP_OK) break;

    pLineBuf = pTmpBuf[0];
    LineLen  = pTmpLen[0];

    i = ConvStoreB64ToHex(pLineBuf, 0, LineLen, pLineBuf, 0, pTmpLen);
    if(i != BASE64_OP_OK) break;
    {
      pDstBuf[0] = pLineBuf;
      pDstLen[0] = pTmpLen[0];
      FREE_ARRAY(HMEM_CTX_REF,pBoundary);
      return(BASE64_OP_OK);
    }
  } // outer FOR
  FREE_ARRAY(HMEM_CTX_REF,pBoundary);
  return(FROM_MIME_NO_DATA);
}
/**
* Searches for PEM encapsulation header,
* verifies correct PEM Proc-Type and Content-Domain, fetches first
* relevant dataline (GetPemDataStart).
*
*  @param SrcBuf Base of input buffer
*  @param SrcOffset Start of data
*  @param SrcLen Length of data
*  @param pNextOff Offset to continuation
*  @param pNextLen Remaining size
*
*  @return int Status BASE64_OP_OK - o.k. else error occured
*/
static  int GetPemDataStart(HMEM_CTX_DEF
			char SrcBuf[], int SrcOffset, int SrcLen,
			int pNextOff[], int pNextLen[])
{
  int i;
  int Retcode;
  int LineLen;
  int StringStart;
  int StartStrLen;
  char* LineBuf = NULL;

  char * pTmpBuf[1];
  int pTmpStartOff[1];
  int pTmpDataLen[1];
  int pEncapType[1];  
  //------------------------------------------------
  // 1. Search encapsulated PEM message start
  //------------------------------------------------
  for(;;)						// Error FOR
  {
    LineLen = GetEncapsulationBoundaryLine(SrcBuf,SrcOffset,SrcLen,
                    pNextOff,pNextLen,pTmpStartOff);
    if(LineLen == 0)
      return(PEM_DECODE_START_NOT_FOUND);

    SrcOffset   = pNextOff[0];
    SrcLen      = pNextLen[0];
    StringStart = pTmpStartOff[0];

    StartStrLen = GetEncapsulationBoundaryType(SrcBuf,StringStart,
		  LineLen, pEncapType);
    if((StartStrLen != 0) &&		  // Start found
       (pEncapType[0] == PEM_DATA_TYPE)) // is PEM Starting Encapsulation
      break;
  }
  Retcode = PEM_DECODE_FMT_ERR;
  for(;;)				// Error FOR
  {
    //--------------------------------------------------
    // 2. Get Proc-Type field and values, validate them
    //--------------------------------------------------
    i = GetUnfoldedHdrLine(HMEM_CTX_REF1
			SrcBuf, SrcOffset, SrcLen, 1,
			pNextOff, pNextLen, pTmpBuf, pTmpDataLen);
    if(i != BASE64_OP_OK) break;

    SrcOffset = pNextOff[0];
    SrcLen    = pNextLen[0];
    LineLen   = pTmpDataLen[0];
    LineBuf   = pTmpBuf[0];

    if(LineLen != (PROC_TYPE_NAME_STR_LEN + 2 + MIC_ONLY_STR_LEN)) break;
    i = PROC_TYPE_NAME_STR_LEN;		// skip data
    if(CmpBit8BufToString(LineBuf,0,LineLen,ProcTypeNameStr,0,i,0) != 0)
      break;
    if(LineBuf[i++] != PEM_PROC_ID) break;
    if(LineBuf[i++] != COMMA_CHAR) break;
    if(CmpBit8BufToString(LineBuf,i,LineLen-i,
       MicOnlyStr,0,MIC_ONLY_STR_LEN,0) != 0) break;
    FREE_ARRAY(HMEM_CTX_REF,LineBuf);
    //--------------------------------------------------
    // 3. Get Content-Domain Field and value, verify
    //--------------------------------------------------
    i = GetUnfoldedHdrLine(HMEM_CTX_REF1
		SrcBuf, SrcOffset, SrcLen, 1,
		pNextOff, pNextLen, pTmpBuf, pTmpDataLen);
    if(i != BASE64_OP_OK) break;

    SrcOffset = pNextOff[0];
    SrcLen    = pNextLen[0];
    LineLen   = pTmpDataLen[0];
    LineBuf   = pTmpBuf[0];

    if(LineLen != (CONT_DOMAIN_NAME_STR_LEN + RFC822_STR_LEN)) break;
    i = CONT_DOMAIN_NAME_STR_LEN;
    if(CmpBit8BufToString(LineBuf,0,LineLen,ContentDomainStr,0,i,0) != 0)
      break;
    if(CmpBit8BufToString(LineBuf,i,LineLen-i,
			  RFC822Str,0,RFC822_STR_LEN,0) != 0) break;
    Retcode = BASE64_OP_OK;
    break;
  } // Error FOR
  FREE_ARRAY(HMEM_CTX_REF,LineBuf);
  return(Retcode);
}
/**
* Subroutine GetPemCertData extracts Originator- / Issuer certificate
* data from appropriate PEM header field value if present (GetPemCertData).
*
*  @param SrcBuf Base of Input buffer
*  @param SrcOffset Start of Data
*  @param SrcLen Length of data
*  @param Type == 0 : Originator Certificate
*               != 0 : Issuer Certificate
*  @param pNextOff offset to continuation
*  @param pNextLen remaining size
*  @param pLineBuf allocated, decoded buf.
*  @param pLineLen length of data
*
*  @return int Status BASE64_OP_OK - o.k. else error occured
*/
static  int GetPemCertData(HMEM_CTX_DEF
			char SrcBuf[], int SrcOffset, int SrcLen,
			int Type, int pNextOff[], int pNextLen[],
			char* pLineBuf[], int pLineLen[])
{
  int i;
  int Retcode;
  int LineLen;
  int FieldNameLen;

  const char* pFieldNameStr;

  char* LineBuf = NULL;

  char * pTmpBuf[1];
  int pTmpDataLen[1];

  pNextOff[0] = SrcOffset;
  pNextLen[0] = SrcLen;
  pLineLen[0] = 0;
  //------------------------------------------------
  // 1. Set Compare String
  //------------------------------------------------
  pFieldNameStr = OriginatorCertStr;
  FieldNameLen  = ORIG_CERT_NAME_STR_LEN;
  if(Type != 0)
  {
    pFieldNameStr = IssuerCertStr;
    FieldNameLen  = ISSUER_CERT_NAME_STR_LEN;
  }
  //---------------------------------------------------------------
  // 2. Get Certificate-Type field and values, validate/decode them
  //---------------------------------------------------------------
  Retcode = PEM_DECODE_FMT_ERR;
  for(;;)
  {
    //-------------------------------------------------------------
    // 2a) Get the Field Name, compare
    //-------------------------------------------------------------
    i = GetUnfoldedHdrLine(HMEM_CTX_REF1
			   SrcBuf, SrcOffset, SrcLen, 1,
			   pNextOff, pNextLen, pTmpBuf, pTmpDataLen);
    if(i != BASE64_OP_OK) break;
    LineBuf = pTmpBuf[0];
    LineLen = pTmpDataLen[0];

    if((LineLen < FieldNameLen) ||
       (CmpBit8BufToString(LineBuf,0,LineLen,
			  pFieldNameStr,0,FieldNameLen,0) != 0))
    {
      if(Type != 0)			// try to get issuer cert, no more !
        Retcode = BASE64_OP_OK;		// no such field
      break;
    }
    //--------------------------------------------------
    // 2b) Get Content-Domain Field and value, verify
    //--------------------------------------------------
    Retcode = ConvStoreB64ToHex(LineBuf, FieldNameLen, LineLen-FieldNameLen,
		LineBuf, 0, pTmpDataLen);
    if(Retcode != BASE64_OP_OK) break;
    pLineBuf[0] = LineBuf;
    pLineLen[0] = pTmpDataLen[0];
    break;
  }
  if(Retcode != BASE64_OP_OK)
    FREE_ARRAY(HMEM_CTX_REF,LineBuf);
  return(Retcode);
}
/**
* Subroutine GetPemMicData extracts MIC Data from PEM header field (GetPemMicData).
*
*  @param SrcBuf Base of Input buffer
*  @param SrcOffset Start of Data
*  @param SrcLen Length of data
*  @param pNextOff offset to continuation
*  @param pNextLen remaining size
*               BIT8PTR pDstBuf[] allocated, decoded buf.
*               int pDstLen[] length of data
*  @param pSignatType Type of Signature
*  @param pSignatAlgor Signature Algorithm
*
*  @return int Status BASE64_OP_OK - o.k. else error occured
*/
static  int GetPemMicData(HMEM_CTX_DEF
			char SrcBuf[], int SrcOffset, int SrcLen,
			int pNextOff[], int pNextLen[],
			char* pLineBuf[], int pLineLen[],
			int pSignatType[], int pSignatAlgor[])
{
  char c;
  int i;
  int Retcode;
  int LineLen;

  char* LineBuf = NULL;

  char * pTmpBuf[1];
  int pTmpDataLen[1];

  pNextOff[0] = SrcOffset;
  pNextLen[0] = SrcLen;
  pLineLen[0] = 0;
  //---------------------------------------------------------------
  // Get MIC-Type field and values, validate/decode them
  //---------------------------------------------------------------
  Retcode = PEM_DECODE_FMT_ERR;
  for(;;)
  {
    //-------------------------------------------------------------
    // a) Get the Field Name, compare
    //-------------------------------------------------------------
    i = GetUnfoldedHdrLine(HMEM_CTX_REF1
			   SrcBuf, SrcOffset, SrcLen, 1,
			   pNextOff, pNextLen, pTmpBuf, pTmpDataLen);
    if(i != BASE64_OP_OK) break;
    LineBuf = pTmpBuf[0];
    LineLen = pTmpDataLen[0];

    i = MIC_INFO_NAME_STR_LEN;
    if((LineLen <= (i+RSA_MD_STR_LEN+1+RSA_STR_LEN+2)) ||
       (CmpBit8BufToString(LineBuf,0,LineLen,
			   MicInfoStr,0,i,0) != 0))
      break;
    //-------------------------------------------------------------
    // b) Get the Signature Type, check if valid (MD2 / MD5)
    //-------------------------------------------------------------
    if(CmpBit8BufToString(LineBuf,i,LineLen,
			  RsaMdStr,0,RSA_MD_STR_LEN,0) != 0)
      break;
    i += RSA_MD_STR_LEN;
    c = LineBuf[i++];				// get MD-Type
    if((c != '2') && (c != '5')) break;
    pSignatType[0] = PKCS1_MD2_WITH_RSA_ENC;
    if(c == '5')
      pSignatType[0] = PKCS1_MD5_WITH_RSA_ENC;
    if(LineBuf[i++] != COMMA_CHAR) break;
    //-------------------------------------------------------------
    // c) Get the Signature Algor, check if valid (RSA)
    //-------------------------------------------------------------
    if(CmpBit8BufToString(LineBuf,i,LineLen-i,
			  RsaMdStr,0,RSA_STR_LEN,0) != 0)
      break;
    pSignatAlgor[0] = RSA_PUBLIC_ALGOR;
    i += RSA_STR_LEN;
    if(LineBuf[i++] != COMMA_CHAR) break;
    //--------------------------------------------------
    // d) Get MIC value, decode
    //--------------------------------------------------
    Retcode = ConvStoreB64ToHex(LineBuf, i, LineLen-i,
		LineBuf, 0, pTmpDataLen);
    if(Retcode != BASE64_OP_OK) break;
    pLineBuf[0] = LineBuf;
    pLineLen[0] = pTmpDataLen[0];
    break;
  }
  if(Retcode != BASE64_OP_OK)
    FREE_ARRAY(HMEM_CTX_REF,LineBuf);
  return(Retcode);
}
/**
* Subroutine GetPemTextData extracts the Text Data from PEM text field
* and checks for correct ending encapsulation line (GetPemTextData).
*
*  @param SrcBuf Base of Input buffer
*  @param SrcOffset Start of Data
*  @param SrcLen Length of data
*  @param pNextOff offset to continuation
*  @param pNextLen remaining size
*  @param pLineBuf allocated, decoded buf.
*  @param pLineLen length of data
*
*  @return int Status BASE64_OP_OK - o.k. else error occured
*/
static  int GetPemTextData(HMEM_CTX_DEF
			char SrcBuf[], int SrcOffset, int SrcLen,
			int pNextOff[], int pNextLen[],
			char* pLineBuf[], int pLineLen[])
{
  int i;
  int Retcode;
  int LineLen;

  char* LineBuf = NULL;

  char * pTmpBuf[1];
  int pTmpDataLen[1];
  int pTmpStartOff[1];

  pNextOff[0] = SrcOffset;
  pNextLen[0] = SrcLen;
  pLineLen[0] = 0;
  //---------------------------------------------------------------
  // Get the empty line(s); at least one must be present...
  //---------------------------------------------------------------
  Retcode = PEM_DECODE_FMT_ERR;
  for(;;)
  {
    //-------------------------------------------------------------
    // a) Get next Header line, should be empty
    //-------------------------------------------------------------
    i = GetUnfoldedHdrLine(HMEM_CTX_REF1
			   SrcBuf, SrcOffset, SrcLen, 1,
			   pNextOff, pNextLen, pTmpBuf, pTmpDataLen);
    if(i != BASE64_OP_OK) break;
    LineBuf = pTmpBuf[0];
    LineLen = pTmpDataLen[0];
    if(LineLen != 0) break;

    SrcOffset = pNextOff[0];
    SrcLen    = pNextLen[0];
    //-------------------------------------------------------------
    // b) Skip empty lines till data Start
    //-------------------------------------------------------------
    for(;;)
    {
      i = GetUnfoldedHdrLine(HMEM_CTX_REF1
			     SrcBuf, SrcOffset, SrcLen, 1,
			     pNextOff, pNextLen, pTmpBuf, pTmpDataLen);
      if(i != BASE64_OP_OK) break;
      if(pTmpDataLen[0] != 0)
      {
        FREE_ARRAY(HMEM_CTX_REF,pTmpBuf[0]);
        break;
      }
      SrcOffset = pNextOff[0];
      SrcLen    = pNextLen[0];
    }
    if(i != BASE64_OP_OK) break;
    //--------------------------------------------------
    // c) Get Text, decode
    //--------------------------------------------------
    i = GetCompactedTextLines(HMEM_CTX_REF1
		SrcBuf,SrcOffset,SrcLen,
		pNextOff,pNextLen, pTmpBuf, pTmpDataLen);
    if(i != BASE64_OP_OK) break;

    LineBuf = pTmpBuf[0];
    LineLen = pTmpDataLen[0];

    i = ConvStoreB64ToHex(LineBuf, 0, LineLen,
		                LineBuf, 0, pTmpDataLen);
    if(i != BASE64_OP_OK) break;
    //---------------------------------------------------
    // d) Check for correct ending encapsulation boundary
    //---------------------------------------------------
    SrcOffset = pNextOff[0];
    SrcLen    = pNextLen[0];

    LineLen = GetEncapsulationBoundaryLine(SrcBuf,SrcOffset,SrcLen,
                    pNextOff,pNextLen,pTmpStartOff);
    if(LineLen == 0)
      return(PEM_DECODE_END_NOT_FOUND);

    if((LineLen != END_PEM_STR_LEN) ||
      (memcmp((SrcBuf+pTmpStartOff[0]), ((char*) EndPEMStr+0),END_PEM_STR_LEN) != 0))
        break;
    Retcode = BASE64_OP_OK;

    pLineBuf[0] = LineBuf;
    pLineLen[0] = pTmpDataLen[0];
    break;
  }
  if(Retcode != BASE64_OP_OK)
    FREE_ARRAY(HMEM_CTX_REF,LineBuf);
  return(Retcode);
}
/**
* Extracts the originator certificate,
* issuer certificates (if reply), signature type and algorithm,
* and the signed text from the PEM message (DecodePemCertReqReply).
*
*  @param SrcBuf Base of Input buffer
*  @param SrcOffset Start of input data
*  @param SrcLen Length of input data
*  @param pOrigCertBuf Allocated, decoded originator certificate
*  @param pOrigCertLen Length of decoded originator certificate data
*  @param pIssuerCertsDesc Allocated issuer certs structure
*  @param pSignatType Type of signature
*  @param pSignatAlgor Signature algorithm
*  @param pMicBuf Signed text data base
*  @param pMicLen Length of MIC data
*  @param pTextBuf allocated decoded text buffer
*  @param pTextLen Length of text data
*
*  @return int Status BASE64_OP_OK - o.k. else error occured
*/
extern "C"  int DecodePemCertReqReply(HMEM_CTX_DEF
			char SrcBuf[], int SrcOffset,
			int SrcLen,
			char* pOrigCertBuf[], int pOrigCertLen[],
			IDATPARR** pIssuerCertsDesc,
			int pSignatType[], int pSignatAlgor[],
			char* pMicBuf[], int pMicLen[],
			char* pTextBuf[], int pTextLen[])
{
  int Retcode;
  int IssuerCertsCount;
  int IssuerIndex;
  int pNextOff[1];
  int pNextLen[1];

  int pTmpLen[1];
  char * pTmpBuf[1];

  IDATPARR* pTmpIssuerCertsDesc[1];
  IDATPARR* IssuerCertsDesc = NULL;

  IDATA** IssuerCertsArr;
  IDATA* ActIssuerCertDesc;


  pOrigCertBuf[0] = NULL;
  pMicBuf[0]  = NULL;
  pTextBuf[0] = NULL;
  pSignatAlgor[0] = INVALID_ALGOR;
  pSignatType[0]  = INVALID_ALGOR;

  for(;;)
  {
    //--------------------------------------------------------------
    // 1. Get data Start of encapsulated PEM message, verify headers
    //--------------------------------------------------------------
    Retcode = GetPemDataStart(HMEM_CTX_REF1
			      SrcBuf, SrcOffset, SrcLen, pNextOff, pNextLen);
    if(Retcode != BASE64_OP_OK) break;
    //-----------------------------------------------------------
    // 2. Get Originator certificate
    //-----------------------------------------------------------
    SrcOffset = pNextOff[0];
    SrcLen    = pNextLen[0];
    Retcode = GetPemCertData(HMEM_CTX_REF1
			     SrcBuf,SrcOffset,SrcLen,0,pNextOff,pNextLen,
			     pOrigCertBuf,pOrigCertLen);
    if(Retcode != BASE64_OP_OK) break;

    SrcOffset = pNextOff[0];
    SrcLen    = pNextLen[0];
    //-----------------------------------------------------------
    // 2a. Get the Issuer Certificates if requested
    //-----------------------------------------------------------
    if(pIssuerCertsDesc != NULL)
    {
      //---------------------------------------------------------
      // I. Count the number of Issuer Certificates present...
      //---------------------------------------------------------
      IssuerCertsCount = 0;
      for(;;)
      {
        Retcode = GetPemCertData(HMEM_CTX_REF1
				 SrcBuf,pNextOff[0],pNextLen[0],1,
				 pNextOff,pNextLen,pTmpBuf,pTmpLen);
	FREE_ARRAY(HMEM_CTX_REF,pTmpBuf[0]);	// release the buffer
        if(Retcode != BASE64_OP_OK) break;	// error occured
        if(pTmpLen[0] == 0) break;		// no (more) such fields
        IssuerCertsCount++;
      }
      if(Retcode != BASE64_OP_OK) break;	// Error, exit
      if(IssuerCertsCount == 0)			// no issuer
      {
        Retcode = PEM_DECODE_NO_ISSUER_ERR;	// set error code
	break;
      }
      //-----------------------------------------------------------------
      // II. Allocate the IDATPARR descriptor to be filled, mark freeable
      //-----------------------------------------------------------------
      Retcode = AllocIDATPARR_Struc(HMEM_CTX_REF1 pTmpIssuerCertsDesc,IssuerCertsCount);
      if(Retcode != ASN1_OP_OK)
      {
        Retcode = PEM_DECODE_ALLOC_ERR;
        break;
      }
      IssuerCertsDesc    = pTmpIssuerCertsDesc[0];
      IssuerCertsArr     = IssuerCertsDesc->ppArr;
      IssuerCertsDesc->Flags |= FREE_BIT_MASK; // set freeable
      //---------------------------------------------------------
      // Decode the Issuer Certificates
      //---------------------------------------------------------
      IssuerIndex = 0;
      do
      {
        //-------------------------------------------------------
        // Get the Issuer Certificate and store it
        //-------------------------------------------------------
        GetPemCertData(HMEM_CTX_REF1
		       SrcBuf,SrcOffset,SrcLen,1,pNextOff,pNextLen,
		       pTmpBuf,pTmpLen);
        ActIssuerCertDesc = IssuerCertsArr[IssuerIndex++];
	ActIssuerCertDesc->Base = pTmpBuf[0];
	ActIssuerCertDesc->Off  = 0;
	ActIssuerCertDesc->Len  = pTmpLen[0];
  
        SrcOffset = pNextOff[0];
        SrcLen    = pNextLen[0];
        IssuerCertsCount--;        
      }while(IssuerCertsCount != 0);
      pIssuerCertsDesc[0] = IssuerCertsDesc;
    }
    //-----------------------------------------------------------
    // Get MIC-Info
    //-----------------------------------------------------------
    Retcode = GetPemMicData(HMEM_CTX_REF1
			    SrcBuf, SrcOffset, SrcLen, pNextOff, pNextLen,
			    pMicBuf, pMicLen,pSignatType,pSignatAlgor);
    if(Retcode != BASE64_OP_OK) break;
    //-----------------------------------------------------------
    // Get the text
    //-----------------------------------------------------------
    SrcOffset = pNextOff[0];
    SrcLen    = pNextLen[0];
    Retcode = GetPemTextData(HMEM_CTX_REF1
			     SrcBuf, SrcOffset, SrcLen, pNextOff, pNextLen,
			     pTextBuf, pTextLen);
    break;
  } // Error FOR
  if(Retcode != BASE64_OP_OK)
  {
    FREE_ARRAY(HMEM_CTX_REF,pOrigCertBuf[0]);
    FREE_ARRAY(HMEM_CTX_REF,pMicBuf[0]);
    FREE_ARRAY(HMEM_CTX_REF,pTextBuf[0]);
    FreeIDATPARR_Struc(HMEM_CTX_REF1 IssuerCertsDesc);
  }
  return(Retcode);
}
/**
* Formats a PEM certificate request/
* certification reply message with encapsulation boundaries (EncodePemCertReqReply).
*
*  @param CertBuf Requestor's certif.
*  @param CertOff Offset to cert data
*  @param CertLen Length of cert data
*  @param IssuerCertsDesc Issuer certificates,
*               sorted in appropriate order
*               or NULL in case of request
*  @param MicBuf Public encrypted MIC data
*  @param MicLen Length of MIC-data
*  @param TextBuf The text that was signed
*  @param TextLen Length of text
*  @param SignatType Type of signature
*  @param SignatAlgor Signature algorithm
*  @param pDstBuf Allocated, filled destination buffer
*  @param pDstLen length of generated data
*
*  @return int Status BASE64_OP_OK - o.k. else error occured
*/
extern "C"  int EncodePemCertReqReply(HMEM_CTX_DEF
		char CertBuf[],
		int CertOff, int CertLen,
		IDATPARR* IssuerCertsDesc,
		char MicBuf[], int MicLen, char TextBuf[], int TextLen,
		int SignatType, int SignatAlgor,
		char* pDstBuf[], int pDstLen[])
{
  int i,j;
  int Count;
  int BufLen;
  int TmpLen;
  int DstIndex = 0;

  char* pBuf = NULL;
  char* pTmpBuf = NULL;

  int IssuerCertCount = 0;
  IDATA** pIssuerCertArr = NULL;

  IDATA* pTmpCertDesc;

  int pNextOff[1];
  int pNextLen[1];

  pDstBuf[0] = NULL;
  pDstLen[0] = 0;
  //-----------------------------------------------------------
  // check input parameters
  //-----------------------------------------------------------
  if((CertBuf == NULL) || (MicBuf == NULL) || (TextBuf == NULL) ||
     (pDstBuf == NULL) || (pDstLen == NULL))
    return(PEM_ENCODE_NULL_PTR);
  if((CertLen <= 0) || (MicLen <= 0) || (TextLen <= 0) ||
     (SignatAlgor != RSA_PUBLIC_ALGOR) ||
     ((SignatType != PKCS1_MD2_WITH_RSA_ENC) &&
      (SignatType != PKCS1_MD5_WITH_RSA_ENC)))
    return(PEM_ENCODE_PARAM_ERR);
  //---------------------------------------------------------------
  // Check if a certificate reply should be generated, check params
  //---------------------------------------------------------------
  if(IssuerCertsDesc != NULL)
  {
     IssuerCertCount = IssuerCertsDesc->Cnt;
     pIssuerCertArr  = IssuerCertsDesc->ppArr;
     if((IssuerCertCount == 0) || (pIssuerCertArr == NULL))
       return(PEM_ENCODE_PARAM_ERR);
  }
  //-----------------------------------------------------------
  // calculate required buffer length, allocate the buffer
  //-----------------------------------------------------------
  BufLen = BEGIN_PEM_STR_LEN + CRLF_LEN +	// starting encapsulation
	   END_PEM_STR_LEN + CRLF_LEN +		// ending encapsulation
	   PROC_TYPE_NAME_STR_LEN + 3 +		// proc-type + SPC/Type/Comma
	   MIC_ONLY_STR_LEN + CRLF_LEN +
           CONT_DOMAIN_NAME_STR_LEN + 1 +	// content domain + SPACE
	   RFC822_STR_LEN + CRLF_LEN +
	   ORIG_CERT_NAME_STR_LEN + CRLF_LEN +	// originator certificate
	   MIC_INFO_NAME_STR_LEN + 1 +		// MIC-Info + Comma
	   RSA_MD_STR_LEN + 2 +			// RDA-MDx + Type and Comma
	   RSA_STR_LEN + 1 + CRLF_LEN +		// RSA + Comma
	   CRLF_LEN;				// empty line in front of text

  TmpLen = ((CertLen + 2) / 3)*4;		// base 64 size
  BufLen += TmpLen;
  BufLen += ((TmpLen + MAX_CHARS_PER_LINE-1) / MAX_CHARS_PER_LINE)*
            (CRLF_LEN + 1);

  TmpLen = ((MicLen + 2) / 3)*4;		// base 64 size
  BufLen += TmpLen;
  BufLen += ((TmpLen + MAX_CHARS_PER_LINE-1) / MAX_CHARS_PER_LINE)*
            (CRLF_LEN + 1);

  TmpLen = ((TextLen + 2) / 3)*4;		// base 64 size
  BufLen += TmpLen;
  BufLen += ((TmpLen + MAX_CHARS_PER_LINE-1) / MAX_CHARS_PER_LINE)*
            (CRLF_LEN);
  //-----------------------------------------------------------
  // If certification reply, get additional buffer size
  //-----------------------------------------------------------
  if(IssuerCertCount != 0)
  {
    i = 0;					// Array Index
    Count = IssuerCertCount;
    do
    {
      BufLen += ISSUER_CERT_NAME_STR_LEN + CRLF_LEN; // issuer certificate
      j = pIssuerCertArr[i++]->Len;	// get the Certificate length
      TmpLen = ((j + 2) / 3) * 4;		// to base 64 length
      BufLen += TmpLen;
      BufLen += ((TmpLen + MAX_CHARS_PER_LINE-1) / MAX_CHARS_PER_LINE)*
            (CRLF_LEN+1);
      Count--;
    }while(Count != 0);
  }
  //-----------------------------------------------------------
  // allocate the required buffer
  //-----------------------------------------------------------
  pBuf = BIT8_ARRAY_ALLOC(HMEM_CTX_REF,BufLen);
  if(pBuf == NULL)
    return(PEM_ENCODE_ALLOC_ERR);
  pDstBuf[0] = pBuf;
  //-----------------------------------------------------------
  // Format the destination buffer
  // 1. Output starting encapsulation data
  //-----------------------------------------------------------
  DstIndex = SetEncapsulationBoundaryLine(PEM_DATA_TYPE, 0, pBuf,0);
  //-----------------------------------------------------------
  // 2. Output Proc-Type line
  //-----------------------------------------------------------
  memcpy(pBuf+DstIndex,ProcTypeNameStr+0,PROC_TYPE_NAME_STR_LEN);
  DstIndex += PROC_TYPE_NAME_STR_LEN;
  pBuf[DstIndex++] = SPACE_CHAR;
  pBuf[DstIndex++] = PEM_PROC_ID;
  pBuf[DstIndex++] = COMMA_CHAR;
  memcpy(pBuf+DstIndex,MicOnlyStr+0,MIC_ONLY_STR_LEN);
  DstIndex += MIC_ONLY_STR_LEN;

  pBuf[DstIndex++] = CR_CHAR;
  pBuf[DstIndex++] = LF_CHAR;
  //-----------------------------------------------------------
  // 3. Output Content Domain line
  //-----------------------------------------------------------
  memcpy(pBuf+DstIndex,ContentDomainStr+0,CONT_DOMAIN_NAME_STR_LEN);
  DstIndex += CONT_DOMAIN_NAME_STR_LEN;
  pBuf[DstIndex++] = SPACE_CHAR;
  memcpy(pBuf+DstIndex,RFC822Str+0,RFC822_STR_LEN);
  DstIndex += RFC822_STR_LEN;
  pBuf[DstIndex++] = CR_CHAR;
  pBuf[DstIndex++] = LF_CHAR;
  //-----------------------------------------------------------
  // 4. Output Originator Certificate
  //-----------------------------------------------------------
  memcpy(pBuf+DstIndex,OriginatorCertStr+0,ORIG_CERT_NAME_STR_LEN);
  DstIndex += ORIG_CERT_NAME_STR_LEN;
  pBuf[DstIndex++] = CR_CHAR;
  pBuf[DstIndex++] = LF_CHAR;

  pNextOff[0] = DstIndex;
  pNextLen[0] = BufLen - DstIndex;
  ConvStoreHexToB64(CertBuf,CertOff,CertLen,0,pBuf,pNextOff,pNextLen);
  DstIndex = pNextOff[0];
  //-----------------------------------------------------------
  // 4a. Output Issuer Certificate(s) if required
  //-----------------------------------------------------------
  if(IssuerCertCount != 0)
  {
    i = 0;
    do
    {
      memcpy(pBuf+DstIndex,IssuerCertStr+0,ISSUER_CERT_NAME_STR_LEN);
      DstIndex += ISSUER_CERT_NAME_STR_LEN;
      pBuf[DstIndex++] = CR_CHAR;
      pBuf[DstIndex++] = LF_CHAR;

      pNextOff[0] = DstIndex;
      pNextLen[0] = BufLen - DstIndex;

      pTmpCertDesc = pIssuerCertArr[i++];

      pTmpBuf = pTmpCertDesc->Base;
      j       = (int) pTmpCertDesc->Off;
      TmpLen  = pTmpCertDesc->Len;
      ConvStoreHexToB64(pTmpBuf,j,TmpLen,0,pBuf,pNextOff,pNextLen);
      DstIndex = pNextOff[0];
      IssuerCertCount --;
    }while(IssuerCertCount != 0);
  }
  //-----------------------------------------------------------
  // 5. Output MIC-Info
  //-----------------------------------------------------------
  memcpy(pBuf+DstIndex,MicInfoStr+0,MIC_INFO_NAME_STR_LEN);
  DstIndex += MIC_INFO_NAME_STR_LEN;
  pBuf[DstIndex++] = SPACE_CHAR;
  memcpy(pBuf+DstIndex,RsaMdStr+0,RSA_MD_STR_LEN);
  DstIndex += RSA_MD_STR_LEN;

  if(SignatType != PKCS1_MD5_WITH_RSA_ENC)
    pBuf[DstIndex++] = (unsigned char) '2';
  else
    pBuf[DstIndex++] = (unsigned char) '5';
  pBuf[DstIndex++] = COMMA_CHAR;
  memcpy(pBuf+DstIndex,RsaMdStr+0,RSA_STR_LEN);
  DstIndex += RSA_STR_LEN;

  pBuf[DstIndex++] = COMMA_CHAR;
  pBuf[DstIndex++] = CR_CHAR;
  pBuf[DstIndex++] = LF_CHAR;

  pNextOff[0] = DstIndex;
  pNextLen[0] = BufLen - DstIndex;
  ConvStoreHexToB64(MicBuf,0,MicLen,0,pBuf,pNextOff,pNextLen);
  DstIndex = pNextOff[0];
  //-----------------------------------------------------------
  // 6. Output empty line and encoded text
  //-----------------------------------------------------------
  pBuf[DstIndex++] = CR_CHAR;
  pBuf[DstIndex++] = LF_CHAR;

  pNextOff[0] = DstIndex;
  pNextLen[0] = BufLen - DstIndex;
  ConvStoreHexToB64(TextBuf,0,TextLen,1,pBuf,pNextOff,pNextLen);
  DstIndex = pNextOff[0];
  //-----------------------------------------------------------
  // 7. Output ending encapsulation data
  //-----------------------------------------------------------
  DstIndex += SetEncapsulationBoundaryLine(PEM_DATA_TYPE, 1, pBuf,DstIndex);
  pDstLen[0] = DstIndex;
  return(BASE64_OP_OK);
}

extern "C"  int  FromCertReqStrucToPEMCertReq(HMEM_CTX_DEF
			PKCS10_CERTREQ* CertReq,
		        int TimeType, int DeltaTimeDays,
			char* pDstBuf[], int pDstLen[])
{
  int Retcode;

  int CertDataLen;
  int MicLen;
  int RdnCount;

  int SignatAlgor;
  int SignatType;

  char* pCertData = NULL;
  char* pMicBuf   = NULL;
  char* pTextBuf  = NULL;


  IDATPARR* pTmpDatArrayDesc[1];

  char * pTmpBuf[1];

  int pTmpLen[1];

  RSA_STRUC* pTmpRsaStruc[1] = {NULL};
//  DSA_PTR_ARRAYI(pTmpDsaStruc,1) = {NULL};

  int TimeArray[TIME_ARRAY_SIZE];
  int DeltaTimeArray[TIME_ARRAY_SIZE];

  X509CERT* pCert = NULL;
  X509CERT* pTmpCert[1];

  X501_DN* pTmpDnNameDesc;

  int CurrentUTC;
  //----------------------------------------------
  // 0. Do some checks first
  //----------------------------------------------
  if((CertReq == NULL) || (pDstBuf == NULL) || (pDstLen == NULL))
    return(BASE64_NULL_PTR);

  pDstBuf[0] = NULL;
  //-----------------------------------------------------------------
  // Assure that public algorithm is RSA and a private key is present
  //-----------------------------------------------------------------
  if(CertReq->PublicKeyType != RSA_PUBLIC_ALGOR)
    return(TO_PEM_CRQ_INVALID_ALGOR);

  if(CertReq->PrivKeyData == NULL)
    return(TO_PEM_CRQ_NO_PRIV_KEY);

  pTmpRsaStruc[0] = NULL;
  for(;;) // Error FOR
  {
    //------------------------------------------------------------------
    // 1. Get the RSA-Structure from the Private key data
    //------------------------------------------------------------------
    Retcode = FromArrayDescToRSAPrivParams(HMEM_CTX_REF1 CertReq->PrivKeyData,pTmpRsaStruc);
    if(Retcode != ASN1_OP_OK)
      break;
    //------------------------------------------------------------------
    // 2. Allocate Certificate Structure for Self-Signed Originator Cert
    //------------------------------------------------------------------
    Retcode = AllocCertStruc(HMEM_CTX_REF1 pTmpCert);
    if(Retcode != ASN1_OP_OK) break;
    pCert = pTmpCert[0];
    //------------------------------------------------------------------
    // 3. Set X509 Certificate Parameters:
    //    Version = 0 (Default, nothing to do!),
    //    SerialNumber = UTC-Time,			!!!! must set !!!
    //	  IssuerRDN = CertReqSubjectRDN,
    //    Validity : NotBefore = Current Time,
    //               NotAfter  = Current Time + 60 days,
    //    SubjectRdn = CertReqSubjectRDN,
    //    SubjectPublicKeyInfo = CertReqSubjPubKeyInfo,
    //    PublicAlgor : same as Request
    //    SignatAlgor : same as Request
    //    SignatType  : same as Request
    //------------------------------------------------------------------
    //---------------------------------------------------
    // a) Set the serial number from current UTC
    //---------------------------------------------------
//  CurrentUTC = GET_SYSTEM_TIME_UTC(RANDinst);	// fetch current UTC
    CurrentUTC = SecGetSystemTimeUTC(); // fetch current UTC

    Retcode = UnsignedBIT32NumToByteBuf(HMEM_CTX_REF1 CurrentUTC,pTmpBuf,pTmpLen);
    if(Retcode != ASN1_OP_OK) break;

    pTmpDatArrayDesc[0] = pCert->SerialNumber; 	// get allocated Descriptor
    Retcode = FromBufToDesc(HMEM_CTX_REF1 pTmpBuf[0],0,pTmpLen[0],0,1,pTmpDatArrayDesc);
    if(Retcode != ASN1_OP_OK) break;
    pTmpBuf[0] = NULL;
    //---------------------------------------------------
    // b) Set Subject AND Issuer RDN to same (selfsigned)
    //---------------------------------------------------
    RdnCount = CertReq->Subject->Cnt;
    if((pTmpDnNameDesc = AllocX501DN_Struc(HMEM_CTX_REF1 RdnCount,2,1,0)) == NULL)
    {
      Retcode = ASN1_ALLOC_ERR;
      break;
    }
    pCert->Issuer = pTmpDnNameDesc;

    if((pTmpDnNameDesc = AllocX501DN_Struc(HMEM_CTX_REF1 RdnCount,2,1,0)) == NULL)
    {
      Retcode = ASN1_ALLOC_ERR;
      break;
    }
    pCert->Subject = pTmpDnNameDesc;

    Retcode = AllocCopyX501DnDesc(HMEM_CTX_REF1 CertReq->Subject,pCert->Subject);
    if(Retcode != ASN1_OP_OK) break;

    Retcode = AllocCopyX501DnDesc(HMEM_CTX_REF1 CertReq->Subject,pCert->Issuer);
    if(Retcode != ASN1_OP_OK) break;
    //------------------------------------------------------------
    // c) Generate Validity Not Before from current time
    //------------------------------------------------------------
    Retcode = GetCheckLocalTimeArray(0,0,TimeArray);//get curr.time
    if(Retcode != ASN1_OP_OK) break;

    Retcode = ToASN1_TimeString(HMEM_CTX_REF1 TimeArray,TimeType,pTmpDatArrayDesc);
    if(Retcode != ASN1_OP_OK) break;
    FreeIDATPARR_Struc(HMEM_CTX_REF1 pCert->NotBefore); // remove
    pCert->NotBefore = pTmpDatArrayDesc[0];
    pTmpDatArrayDesc[0] = NULL;		// invalidate
    //--------------------------------------------------------------
    // d) Generate Validity Not After from current time + Delta Days
    //--------------------------------------------------------------
    memset(DeltaTimeArray,0,(TIME_ARRAY_SIZE)*sizeof(int));	// clear
    DeltaTimeArray[TIME_DAY_INDEX] = DeltaTimeDays;
    Retcode = AddTimeArrayDeltaTime(TimeArray,DeltaTimeArray,0);
    if(Retcode != ASN1_OP_OK) break;

    Retcode = ToASN1_TimeString(HMEM_CTX_REF1 TimeArray,TimeType,pTmpDatArrayDesc);
    if(Retcode != ASN1_OP_OK) break;

    FreeIDATPARR_Struc(HMEM_CTX_REF1 pCert->NotAfter); // remove
    pCert->NotAfter = pTmpDatArrayDesc[0];
    pTmpDatArrayDesc[0] = NULL;		// invalidate
    //------------------------------------------------------------
    // e) Set the Subject Public Key Info
    //------------------------------------------------------------
    Retcode = AllocIDATPARR_Struc(HMEM_CTX_REF1 pTmpDatArrayDesc,1);
    if(Retcode != ASN1_OP_OK) break;

    pCert->SubjPubKeyParVal = pTmpDatArrayDesc[0];

    Retcode = AllocCopyDatArrayDesc(HMEM_CTX_REF1 CertReq->SubjPubKeyParVal,pCert->SubjPubKeyParVal);
    if(Retcode != ASN1_OP_OK) break;
    //------------------------------------------------------------
    // f) copy PulicAlgorType and SignatureAlgor and Type, save
    //------------------------------------------------------------
    pCert->PublicKeyType = CertReq->PublicKeyType;
    SignatAlgor = CertReq->SignatAlgor;
    pCert->SignatAlgor   = SignatAlgor;
    SignatType  = CertReq->SignatType;
    pCert->SignatType    = SignatType;
    //------------------------------------------------------------
    // 3. Generate the signed (selfsigned) Certificate
    //------------------------------------------------------------
    Retcode = FromCertStrucToASN1Cert(HMEM_CTX_REF1 pCert,0,0,pTmpRsaStruc[0],NULL,NULL,0,0,0,NULL,0,0,0,pTmpBuf,pTmpLen);
    if(Retcode != ASN1_OP_OK)
      break;
    pCertData   = pTmpBuf[0];
    CertDataLen = pTmpLen[0];
    //------------------------------------------------------------
    // 4. Get the Text field contents
    //------------------------------------------------------------
    pTextBuf = BIT8_ARRAY_ALLOC(HMEM_CTX_REF,PEM_REQ_TEXT_FLD_LEN);
    if(pTextBuf == NULL)
    {
      Retcode = TO_PEM_CRQ_ALLOC_ERR;
      break;
    }
    memcpy(pTextBuf+0,PemReqText+0,PEM_REQ_TEXT_FLD_LEN);
    //------------------------------------------------------------
    // 5. Generate PEM MIC-Info Data
    //------------------------------------------------------------
    MicLen  = RSA_Size(pTmpRsaStruc[0]) + 1;
    pMicBuf = BIT8_ARRAY_ALLOC(HMEM_CTX_REF,MicLen);
    if(pMicBuf == NULL)
    {
      Retcode = TO_PEM_CRQ_ALLOC_ERR;
      break;
    }
    pTmpLen[0] = MicLen;
    Retcode = RSA_sign(HMEM_CTX_REF1 SignatType,pTextBuf,0,PEM_REQ_TEXT_FLD_LEN,pMicBuf,0,pTmpLen,pTmpRsaStruc[0],0);
    if(Retcode != RSA_OP_OK) break;
    MicLen = pTmpLen[0];
    //------------------------------------------------------------
    // 5. Generate the PEM certificate Request
    //------------------------------------------------------------
    Retcode = EncodePemCertReqReply(HMEM_CTX_REF1
		pCertData, 0, CertDataLen,
		NULL,pMicBuf, MicLen, pTextBuf, PEM_REQ_TEXT_FLD_LEN,
		SignatType, SignatAlgor, pDstBuf, pDstLen);
    break;
  } // Error FOR
  //----------------------------------------------------------
  // now we free the temporary allocated descriptors
  //----------------------------------------------------------
  FreeCertStruc(HMEM_CTX_REF1 pCert);

  FREE_ARRAY(HMEM_CTX_REF,pTextBuf);
  FREE_ARRAY(HMEM_CTX_REF,pMicBuf);
  FREE_ARRAY(HMEM_CTX_REF,pCertData);

  RSA_Free(HMEM_CTX_REF1 pTmpRsaStruc[0]);
//  DSA_FREE(DSADHinst,HMEM_CTX_REF,pTmpDsaStruc[0]);
  return(Retcode);
}
/**
* Decodes PEM encoded
* certificate request and loads components to internal certificate
* request structure (FromPEMCertReqToCertReqStrucEX).
* Does some preprocessing on the components: <ol>
* <li>  Fetches the ASN.1 encoded originator certificate, checks
*     validity and signature.
* <li>  Checks signature on test text.
*</ol>
* Only the required parameters for certificate reply generation
* are stored to the CertReq structure: <ul>
*	 <li> Subject RDN, <li> Subject PublicKeyInfo, <li> PublicKeyType,
*	 <li> SignatAlgor, <li> SignatType (both from PEM MIC-Info)
*	 <li> PEM Textdata (from PEM Tesxtfield)
*</ul>
*  @param OrigCertBuf Decoded request data
*  @param OrigCertLen Length of request data
*  @param SignatType Type of MIC signature
*  @param SignatAlgor MIC signature algorithm
*  @param MicBuf Signed text data
*  @param MicLen Length of MIC data
*  @param TextBuf Decoded text buffer
*  @param TextLen Length of text data
*  @param ProcessFlags Bit 0 - 1 : Do NOT sort RDNs <br>
*               Bit 1 - 1 : Process Extensions <br>
*               Bit 2 - 1 : Ignore unknown
*               Critical Extensions <br>
*               Bit 3 - 1 : Ignore all Extens.
*               errors <br>
*               Bit 4-31 - reserved
*  @param pCertReqStruc Pointer to Cert.Req
*
*  @return int Status - ASN1_OP_OK: o.k.
* <br>            - else Error occured
*/
extern "C"  int  FromPEMCertReqToCertReqStrucEX(HMEM_CTX_DEF
		char OrigCertBuf[],
		int OrigCertLen, int SignatType, int SignatAlgor,
		char MicBuf[], int MicLen, char TextBuf[], int TextLen,
		int ProcessFlags, PKCS10_CERTREQ* pCertReqStruc[])
{
  int Retcode;
  int Count;

  int pTmpDat[1];
  int pTmpResult[1];

  char * pTmpBuf[1];

  IDATPARR* pTmpDatArrayDesc[1];

  X509CERT* pCert;
  X509CERT* pTmpCertStruc[1];

  PKCS10_CERTREQ* pCertReq = NULL;
  PKCS10_CERTREQ* pTmpCertReq[1];

  X501_DN* pTmpDnNameDesc;

  RSA_STRUC* pTmpRsaStruc[1];
  //----------------------------------------------
  // 0. Do some checks first
  //----------------------------------------------
  if((OrigCertBuf == NULL) || (MicBuf == NULL) ||
     (TextBuf == NULL) || (pCertReqStruc == NULL))
    return(FROM_PEM_CRQ_TO_STRUC_NULPTR);
  pCertReqStruc[0] = NULL;
  if((OrigCertLen <= 0) || (MicLen <= 0) || (TextLen <= 0))
    return(FROM_PEM_CRQ_TO_STRUC_NO_DATA);
  //---------------------------------------------------------
  // 1. Convert the Selfsigned Certificate to internal format
  //---------------------------------------------------------
  Retcode = FromASN1CertToCertStrucEX(HMEM_CTX_REF1 OrigCertBuf,0,OrigCertLen,0,ProcessFlags,NULL,0,pTmpCertStruc);
  if(Retcode != ASN1_OP_OK)
    return(Retcode);
  pCert = pTmpCertStruc[0];
  for(;;) // Error FOR
  {
    //---------------------------------------------------------
    // 2. Check if Certificate is REALLY a selfsigned one
    //---------------------------------------------------------
    if((pCert->Flags & SELF_SIGNED_MASK) == 0)	// not self signed
    {
      Retcode = FROM_PEM_CRQ_INVALID_ORIG_CERT;
      break;
    }
    //---------------------------------------------------------
    // 3. Verify Signature of the Selfsigned Certificate
    //---------------------------------------------------------
    Retcode = VerifyCertSignat(HMEM_CTX_REF1 pCert,pCert->SubjPubKeyParVal,pCert->PublicKeyType,pTmpResult);
    if(Retcode != ASN1_OP_OK) break;
    if(pTmpResult[0] != ASN1_SIGNAT_VFY_OK)
    {
      Retcode = FROM_PEM_CRQ_INVALID_SIGNAT;
      break;
    }
    //---------------------------------------------------------
    // 4. Verify the RSA (/DSA ?) Textdata Mic Signature
    // NOTE: Is PKCS1 conformant signature
    //---------------------------------------------------------
    if(SignatAlgor != RSA_PUBLIC_ALGOR)
    {
      Retcode = FROM_PEM_CRQ_INVALID_SIGNAT_ALG;
      break;
    }
    Retcode = FromArrayDescToRSAPubParams(HMEM_CTX_REF1 pCert->SubjPubKeyParVal,pTmpRsaStruc);
    if(Retcode != ASN1_OP_OK)
      break;

    pTmpDat[0] = MicLen;
    Retcode = RSA_sign(HMEM_CTX_REF1 SignatType,TextBuf,0,TextLen,MicBuf,0,pTmpDat,pTmpRsaStruc[0],1);

    RSA_Free(HMEM_CTX_REF1 pTmpRsaStruc[0]);
    if(Retcode != RSA_OP_OK)
    {
      Retcode = FROM_PEM_CRQ_MIC_SIGNAT_ERR;
      break;
    }
    //------------------------------------------------------------
    // 5. All tests passed, allocate certificate request structure
    //------------------------------------------------------------
    Retcode = AllocCertReqStruc(HMEM_CTX_REF1 pTmpCertReq);
    if(Retcode != ASN1_OP_OK)
      break;
    pCertReq = pTmpCertReq[0];
    //------------------------------------------------------------
    // 6. Copy Subject RDN, Subject Public Key Info, Public Key Type,
    //    MIC Signature type, MIC  Signature Algor and the MIC-Text
    //    to the Certificate Request structure
    //------------------------------------------------------------
    Count = pCert->Subject->Cnt;
    if((pTmpDnNameDesc = AllocX501DN_Struc(HMEM_CTX_REF1 Count,2,1,0)) == NULL)
    {
      Retcode = ASN1_ALLOC_ERR;
      break;
    }
    pCertReq->Subject = pTmpDnNameDesc;

    Retcode = AllocIDATPARR_Struc(HMEM_CTX_REF1 pTmpDatArrayDesc,1);
    if(Retcode != ASN1_OP_OK) break;
    pCertReq->SubjPubKeyParVal = pTmpDatArrayDesc[0];

    Retcode = AllocCopyX501DnDesc(HMEM_CTX_REF1 pCert->Subject,pCertReq->Subject);
    if(Retcode != ASN1_OP_OK) break;

    Retcode = AllocCopyDatArrayDesc(HMEM_CTX_REF1 pCert->SubjPubKeyParVal,pCertReq->SubjPubKeyParVal);
    if(Retcode != ASN1_OP_OK) break;

    pCertReq->SignatAlgor = SignatAlgor;
    pCertReq->SignatType  = SignatType;

    Retcode = AllocIDATPARR_Struc(HMEM_CTX_REF1 pTmpDatArrayDesc,1);
    if(Retcode != ASN1_OP_OK) break;
    pCertReq->PEMTextData = pTmpDatArrayDesc[0];
    Retcode = FromBufToDesc(HMEM_CTX_REF1 TextBuf,0,TextLen,0,1,pTmpDatArrayDesc);
    if(Retcode != ASN1_OP_OK) break;

    Retcode = AllocIDATPARR_Struc(HMEM_CTX_REF1 pTmpDatArrayDesc,1);
    if(Retcode != ASN1_OP_OK) break;
    pCertReq->PEMMicData = pTmpDatArrayDesc[0];
    Retcode = FromBufToDesc(HMEM_CTX_REF1 MicBuf,0,MicLen,0,1,pTmpDatArrayDesc);
    if(Retcode != ASN1_OP_OK) break;
    //---------------------------------------------------------------------
    // 7. Set Public Algorithm to RSA and insert ASN.1 encoded Version NR.0
    //---------------------------------------------------------------------
    pCertReq->PublicKeyType = RSA_PUBLIC_ALGOR;

    Retcode = UnsignedBIT32NumToByteBuf(HMEM_CTX_REF1 0,pTmpBuf,pTmpDat);
    if(Retcode != ASN1_OP_OK) break;

    pTmpDatArrayDesc[0] = pCertReq->VersionNumber;
    Retcode = FromBufToDesc(HMEM_CTX_REF1 pTmpBuf[0],0,pTmpDat[0],0,1,pTmpDatArrayDesc);
    if(Retcode != ASN1_OP_OK) break;

    pCertReqStruc[0] = pCertReq;
    FreeCertStruc(HMEM_CTX_REF1 pCert);
    return(BASE64_OP_OK);
  }
  //----------------------------------------------------------
  // Error occured, free the temporary allocated descriptors
  //----------------------------------------------------------
  FreeCertStruc(HMEM_CTX_REF1 pCert);
  FreeCertReqStruc(HMEM_CTX_REF1 pCertReq);
  return(Retcode);
}
/**
* Decodes PEM encoded
* certificate request and loads components to internal certificate
* Request structure (FromPEMCertReqToCertReqStruc).
* @see #FromPEMCertReqToCertReqStrucEX
*
*  @param OrigCertBuf Decoded request data
*  @param OrigCertLen Length of request data
*  @param SignatType Type of MIC signature
*  @param SignatAlgor MIC signature algorithm
*  @param MicBuf Signed text data
*  @param MicLen Length of MIC data
*  @param TextBuf Decoded text buffer
*  @param TextLen Length of text data
*  @param pCertReqStruc Pointer to Cert.Req
*
*  @return int Status - ASN1_OP_OK: o.k.
* <br>            - else Error occured
*/
extern "C"  int  FromPEMCertReqToCertReqStruc(HMEM_CTX_DEF
		char OrigCertBuf[],
		int OrigCertLen, int SignatType, int SignatAlgor,
		char MicBuf[], int MicLen, char TextBuf[], int TextLen,
		PKCS10_CERTREQ* pCertReqStruc[])
{
  return(FromPEMCertReqToCertReqStrucEX(HMEM_CTX_REF1
		OrigCertBuf, OrigCertLen,
		SignatType, SignatAlgor, MicBuf, MicLen,
		TextBuf, TextLen, 0,
		pCertReqStruc));
}




/**
* Generates from given,
* loaded certificate array a PEM certificate reply (FromCertsArrayToPEMCerts). The first
* Certificate in the list is the originator certificate, the
* others (at least 2 must be present) are the issuer
* certificates.
*
* Only originator certificates with RSA public algorithm (and
* params) can be converted to a PEM certificate reply.
*
*  Generate the PEM Certificate Reply <ul>
*     <li> PEM encapsulation starting boundary
*     <li> General PEM header fields
*     <li> Originator certificate
*     <li> Issuer certificates
*     <li> MIC-Info [MD2 / MD5 digest of TextInfo, RSA-Encrypted]
*     <li> Empty line, followed by TextInfo
*     <li> PEM encapsulation ending boundary
*</ul>
*  @param CertList List structure
*  @param CertCount Number of certificates
*  @param SignatAlgor Algor to set in MIC-Info
*  @param SignatType Type to set in info
*  @param MicData Signature from request
*  @param MicLen Length of signature 
*  @param TextData Text to set
*  @param TextLen Length of Text
*  @param pDstBuf Allocated destination buffer
*  @param pDstLen Length of generated data
*
*  @return int Status - ASN1_OP_OK: o.k.
* <br>            - else Error occured
*/
extern "C"  int  FromCertsArrayToPEMCerts(HMEM_CTX_DEF
			X509CERT* CertList[],
			int CertCount, int SignatAlgor, int SignatType,
			char MicData[], int MicLen,
			char TextData[], int TextLen,
			char* pDstBuf[], int pDstLen[])
{
  int Retcode;

  IDATA* pIdata;
  IDATA** pIssuerDatArray;

  IDATPARR* pIssuerArrayDesc = NULL;
  IDATPARR* pCertDataArrayDesc;
  IDATPARR* pTmpDatArrayDesc[1];

  X509CERT* pCert = NULL;
  //----------------------------------------------
  // 0. Do some checks first
  //----------------------------------------------
  if((CertList == NULL) || (MicData == NULL) || (TextData == NULL) ||
     (pDstBuf == NULL) || (pDstLen == NULL))
    return(BASE64_NULL_PTR);
  //----------------------------------------------
  // Assure Signat Algor and Type are correct
  //----------------------------------------------
  if((SignatAlgor != RSA_PUBLIC_ALGOR) ||
     ((SignatType != PKCS1_MD2_WITH_RSA_ENC) &&
      (SignatType != PKCS1_MD5_WITH_RSA_ENC)))
    return(TO_PEM_CERTS_INV_SIG_TYPEALG);
  //----------------------------------------------
  // Check if at least 2 Certificates are present
  // and Originator Cert has RSA Public Info
  //----------------------------------------------
  if(CertCount < 2)
    return(TO_PEM_CERTS_TOO_FEW_CERTS);
  pCert = CertList[0];
  if(pCert->PublicKeyType != RSA_PUBLIC_ALGOR)
    return(TO_PEM_CERTS_ORIG_INV_PUB_ALG);

  for(;;) // Error FOR
  {
    //-------------------------------------------------
    // 1. Allocate IDATPARR Structure for raw Issuer Certs 
    //-------------------------------------------------
    Retcode = AllocIDATPARR_Struc(HMEM_CTX_REF1 pTmpDatArrayDesc,CertCount-1);
    if(Retcode != ASN1_OP_OK) break;
    pIssuerArrayDesc = pTmpDatArrayDesc[0];
    pIssuerDatArray = pIssuerArrayDesc->ppArr;
    //-----------------------------------------------
    // 2. Copy the raw certs buffer descriptors
    //-----------------------------------------------
    CertCount--;		// reduce total count, use as index !
    do
    {
       pCertDataArrayDesc = CertList[CertCount--]->Certificate;
       CopyIdataContents(pIssuerDatArray[CertCount],pCertDataArrayDesc->ppArr[0]);   
    }while(CertCount != 0);
    //------------------------------------------------------------
    // 3. Generate the PEM certificate Reply
    //------------------------------------------------------------
    pCertDataArrayDesc = pCert->Certificate;	// Originator Cert
    pIdata = pCertDataArrayDesc->ppArr[0];
    Retcode = EncodePemCertReqReply(HMEM_CTX_REF1
		pIdata->Base,
		(int) pIdata->Off, pIdata->Len,
		pIssuerArrayDesc, MicData, MicLen, TextData, TextLen,
		SignatType, SignatAlgor, pDstBuf, pDstLen);
    break;
  } // Error FOR
  //----------------------------------------------------------
  // now we free the temporary allocated descriptors
  //----------------------------------------------------------
  FreeIDATPARR_Struc(HMEM_CTX_REF1 pIssuerArrayDesc);
  return(Retcode);
}
/**
* Decodes PEM encoded
* certificate reply and loads components to internal certificate
* array (FromPEMCertsToCertsArrayEX). The first element in the array will be the ORIGINATOR
* i.e. subject certificate, the others (if present) are
* issuer certificates etc.
*
* Does simple checks on the originator certificate: <ol>
* <li> Fetches the ASN.1 encoded originator certificate, checks
*     for consistent public key type against MIC header data
* <li> Checks signature on test text against originator certificate
*     public values.
* </ol>
* NOTE: Chain checking is done when inserting the certificates
*
*  @param OrigCertBuf Decoded request data
*  @param OrigCertLen Length of request data
*  @param IssuerCertsDesc Issuer certificates
*  @param SignatType Type of MIC signature
*  @param SignatAlgor MIC signature algorithm
*  @param MicBuf Signed text data
*  @param MicLen Length of MIC data
*  @param TextBuf Decoded text buffer
*  @param TextLen Length of text data
*  @param ProcessFlags Bit 0 - 1 : Do NOT sort RDNs <br>
*               Bit 1 - 1 : Process Extensions <br>
*               Bit 2 - 1 : Ignore unknown
*               Critical Extensions <br>
*               Bit 3 - 1 : Ignore all Extens.
*               errors <br>
*               Bit 4-31 - reserved
*  @param ppCertStrucList Generated certificate array
*  @param pCertCnt Number of certificates
*
*  @return int Status - ASN1_OP_OK: o.k.
* <br>            - else Error occured
*/
extern "C"  int  FromPEMCertsToCertsArrayEX(HMEM_CTX_DEF
		char OrigCertBuf[],
		int OrigCertLen,IDATPARR* IssuerCertsDesc,
		int SignatType, int SignatAlgor,
		char MicBuf[], int MicLen, char TextBuf[], int TextLen,
		int ProcessFlags,
		X509CERT** ppCertStrucList[], int pCertCnt[])
{
  int Retcode;
  int IssuerCertCount = 0;

  int pTmpDat[1];

  X509CERT* pCert;
  X509CERT* pTmpCertStruc[1];

  X509CERT** pIssuerCertList;
  X509CERT** pDstCertList;

  X509CERT** pTmpCertList[1];

  RSA_STRUC* pTmpRsaStruc[1];
  //----------------------------------------------
  // 0. Do some checks first
  //----------------------------------------------
  if((OrigCertBuf == NULL) || (IssuerCertsDesc == NULL) ||
     (MicBuf == NULL) || (TextBuf == NULL) ||
     (ppCertStrucList == NULL) || (pCertCnt == NULL))
    return(BASE64_NULL_PTR);

  ppCertStrucList[0] = NULL;
  if((OrigCertLen <= 0) || (MicLen <= 0) || (TextLen <= 0))
    return(FROM_PEM_CERTS_TO_STRUC_NO_DATA);
  //---------------------------------------------------------
  // 1. Convert the Originator Certificate to internal format
  //---------------------------------------------------------
  Retcode = FromASN1CertToCertStrucEX(HMEM_CTX_REF1 OrigCertBuf,0,OrigCertLen,0,ProcessFlags,NULL,0,pTmpCertStruc);
  if(Retcode != ASN1_OP_OK)
    return(Retcode);
  pCert = pTmpCertStruc[0];
  for(;;) // Error FOR
  {
    //---------------------------------------------------------
    // 2. Check if Certificate Public Algor is RSA
    //---------------------------------------------------------
    if(pCert->PublicKeyType != RSA_PUBLIC_ALGOR)
    {
      Retcode = FROM_PEM_CERTS_INVALID_PUB_ALG;
      break;
    }
    //---------------------------------------------------------
    // 4. Verify the RSA (/DSA ?) Textdata Mic Signature
    // NOTE: Is PKCS1 conformant signature
    //---------------------------------------------------------
    if(SignatAlgor != RSA_PUBLIC_ALGOR)
    {
      Retcode = FROM_PEM_CERTS_INVALID_SIGALG;
      break;
    }
    Retcode = FromArrayDescToRSAPubParams(HMEM_CTX_REF1 pCert->SubjPubKeyParVal,pTmpRsaStruc);
    if(Retcode != ASN1_OP_OK)
      break;

    pTmpDat[0] = MicLen;
    Retcode = RSA_sign(HMEM_CTX_REF1 SignatType,TextBuf,0,TextLen,MicBuf,0,pTmpDat,pTmpRsaStruc[0],1);

    RSA_Free(HMEM_CTX_REF1 pTmpRsaStruc[0]);
    if(Retcode != RSA_OP_OK)
    {
      Retcode = FROM_PEM_CERTS_MIC_SIGNAT_ERR;
      break;
    }
    //------------------------------------------------------------
    // 5. All Originator tests passed, convert the Issuer Certs
    //------------------------------------------------------------
    IssuerCertCount = IssuerCertsDesc->Cnt;
    Retcode = FromCertListToCertStrucListEX(HMEM_CTX_REF1 IssuerCertsDesc, ProcessFlags,pTmpCertList);
    if(Retcode != ASN1_OP_OK) break;
    //------------------------------------------------------------
    // 6. Combine Certificates into single List
    //------------------------------------------------------------
    Retcode = AllocCertStructList(HMEM_CTX_REF1 ppCertStrucList,IssuerCertCount+1);
    if(Retcode != ASN1_OP_OK) break;
    pCertCnt[0] = IssuerCertCount+1;
    pIssuerCertList = pTmpCertList[0];
    pDstCertList = ppCertStrucList[0];

    pDstCertList[0] = pCert;		// insert originator cert
    while(IssuerCertCount != 0)
    {
      IssuerCertCount--;
      pDstCertList[IssuerCertCount+1] =	// is one longer !
      pIssuerCertList[IssuerCertCount];
    }
    FREE_ARRAY(HMEM_CTX_REF,pIssuerCertList);	// no longer needed
    return(BASE64_OP_OK);
  } // Error FOR
  FreeCertStruc(HMEM_CTX_REF1 pCert);// Error occured
  FreeCertList(HMEM_CTX_REF1 pTmpCertList[0],IssuerCertCount);
  return(Retcode);
}

extern "C"  int  FromPEMCertsToCertsArray(HMEM_CTX_DEF
		char OrigCertBuf[],
		int OrigCertLen,IDATPARR* IssuerCertsDesc,
		int SignatType, int SignatAlgor,
		char MicBuf[], int MicLen, char TextBuf[], int TextLen,
		X509CERT** ppCertStrucList[], int pCertCnt[])
{
  return(FromPEMCertsToCertsArrayEX(HMEM_CTX_REF1
		OrigCertBuf, OrigCertLen,
		IssuerCertsDesc, SignatType, SignatAlgor,
		MicBuf, MicLen, TextBuf, TextLen, 0,
		ppCertStrucList, pCertCnt));
}

#ifndef XH_INTERFACE
extern "C"  int  GetDecodeCertOrCertReqDataEX(HMEM_CTX_DEF
			char SrcBuf[],
			int SrcOffset, int SrcLen, int ProcessFlags,
			X509CERT* pCertStruc[], PKCS10_CERTREQ* pCertReqStruc[],
			X509CERT** ppCertList[],
			int pCertListCount[],
			int pDataType[], int pFileType[],
			char* ppDstBuf[], int pDstLen[])
{
  int Retcode;
  int i;
  int BinLen;

  char * pTmpBuf[1];
  char * pOrigCertBuf[1];
  char * pMicBuf[1];
  char * pTextBuf[1];

  int pTmpCnt[1];
  int pTmpLen[1];
  int pOrigCertLen[1];
  int pMicLen[1];
  int pTextLen[1];
  int pSignatType[1];
  int pSignatAlgor[1];

  int pTmpBinLen[1];

  IDATPARR* pIssuerCertsDesc[1];
  //----------------------------------------------------
  // Check paramaters
  //----------------------------------------------------
  if((SrcBuf == NULL) || (pCertStruc == NULL) || (pCertReqStruc == NULL) ||
     (ppCertList == NULL) || (pDataType == NULL))
    return(BASE64_NULL_PTR);
  if(SrcLen <= 0)
    return(FROM_CERTS_CERTREQ_PARAM_ERR);  

  pCertStruc[0]    = NULL;
  pCertReqStruc[0] = NULL;
  ppCertList[0]    = NULL;
  pDataType[0]	   = B64_UNKNOWN_DATA_TYPE;
  //----------------------------------------------------
  // Check if pure DER/BER (1st Byte is 0x30 [Sequence])
  //----------------------------------------------------
  if(SrcBuf[SrcOffset] == (ASN1_UNIVERSAL_SEQUENCE |
			   ASN1_CONSTRUCTED))
  {
    if(pFileType != NULL)				// Assume Binary
      pFileType[0] = BINARY_FILE_TYPE;
    //----------------------------------------------------
    // Could be pure DER/BER data, try to decode
    // NOTE: 1. Get the length needed from the ASN.1 Header
    // -----    first (trailing CR/LFs from Microsoft)
    //----------------------------------------------------
    for(;;)					// to ease break out
    {
      BinLen = SrcLen;				// assume all data needed
      i = DecodeASN1_LenField(SrcBuf,SrcOffset+1,SrcLen-1,pTmpBinLen);
      if((i < 0) && (i != -1))			// not a valid length...
        break; 
      if(i > 0)					// definite length
      {
        BinLen = 1 + i + (int) pTmpBinLen[0];	// length required
        if(BinLen > SrcLen)			// too short
          break;
      }

      Retcode = FromASN1CertToCertStrucEX(HMEM_CTX_REF1 SrcBuf,SrcOffset,BinLen,0,ProcessFlags,NULL,0,pCertStruc);
      if(Retcode == ASN1_OP_OK)
      {
        pDataType[0] = X509_DATA_TYPE;
        return(BASE64_OP_OK);
      }
      Retcode = FromASN1CertReqToCertReqStruc(HMEM_CTX_REF1 SrcBuf,SrcOffset,BinLen,0,(int) (ProcessFlags & 0x01),NULL,0,pCertReqStruc);
      if(Retcode == ASN1_OP_OK)
      {
        pDataType[0] = PKCS10_DATA_TYPE;
        return(BASE64_OP_OK);
      }
      Retcode = FromASN1_PKCS7CertListEX(HMEM_CTX_REF1 SrcBuf,SrcOffset,BinLen,ProcessFlags,ppCertList,pCertListCount);
      if(Retcode == ASN1_OP_OK)
      {
        pDataType[0] = PKCS7_DATA_TYPE;
        return(BASE64_OP_OK);
      }
      Retcode = PKCS12_CheckDecodeFormat(SrcBuf,SrcOffset,BinLen,NULL,0,-1,pTmpLen,NULL,NULL,NULL);
      if((Retcode == PKCS12_OP_OK) && (pTmpLen[0] != PKCS12_UNKNOWN_PDU_TYPE))
      {
        pDataType[0] = PKCS12_DATA_TYPE;
        if(pCertListCount != NULL)
          pCertListCount[0] = pTmpLen[0];
        if(ppDstBuf != NULL)
          ppDstBuf[0] = SrcBuf;
        if(pDstLen != NULL)
          pDstLen[0] = BinLen;
        return(BASE64_OP_OK);
      }
      break;
    } // binary processing FOR
  }
  //-------------------------------------------------------
  // Is not pure DER/BER, check if simple encapsulated type
  //-------------------------------------------------------
  pDataType[0] = -1;
  Retcode = FromEncapsulatedBase64(HMEM_CTX_REF1
				   SrcBuf,SrcOffset,SrcLen,
	 			   pTmpBuf, pTmpLen,pDataType);
  if(Retcode == BASE64_OP_OK)
  {
    if(pFileType != NULL)				// Assume BASE64
      pFileType[0] = BASE64_ENCAP_FILE_TYPE;
    //-----------------------------------------------------
    // process encapsulated types
    //-----------------------------------------------------
    switch(pDataType[0])
    {
      case PKCS10_DATA_TYPE:
        Retcode = FromASN1CertReqToCertReqStruc(HMEM_CTX_REF1 pTmpBuf[0],0,pTmpLen[0],0,(int) (ProcessFlags & 0x01),NULL,0,pCertReqStruc);
        break;

      case X509_DATA_TYPE:
        Retcode = PKCS12_CheckDecodeFormat(pTmpBuf[0],0,pTmpLen[0],NULL,0,-1,pTmpCnt,NULL,NULL,NULL);
        if((Retcode == PKCS12_OP_OK) &&
           (pTmpCnt[0] != PKCS12_UNKNOWN_PDU_TYPE))
        {
          pDataType[0] = PKCS12_DATA_TYPE;
          if(pCertListCount != NULL)
            pCertListCount[0] = pTmpCnt[0];
          if(ppDstBuf != NULL)
          {
            ppDstBuf[0] = pTmpBuf[0];
            pTmpBuf[0] = NULL;
          }
          if(pDstLen != NULL)
            pDstLen[0] = pTmpLen[0];           
          break;
        }

        Retcode = FromASN1CertToCertStrucEX(HMEM_CTX_REF1 pTmpBuf[0],0,pTmpLen[0],0,ProcessFlags,NULL,0,pCertStruc);
//      -----------------------------------------------------------
//      NOTE NOTE NOTE:
//      Microsoft encodes PKCS7-Data also with 'Certificate' header
//      So if not decodable as a certificate, try also PKCS7 !!
//      -----------------------------------------------------------
        if(Retcode == ASN1_OP_OK)
          break;


      case PKCS7_DATA_TYPE:
        Retcode = FromASN1_PKCS7CertListEX(HMEM_CTX_REF1 pTmpBuf[0],0,pTmpLen[0],ProcessFlags,ppCertList,pCertListCount);
        if(Retcode == ASN1_OP_OK)
          pDataType[0] = PKCS7_DATA_TYPE;		// for certificate...
        break;

      case PEM_DATA_TYPE:
        if(pFileType != NULL)				// is PEM
          pFileType[0] = PEM_FILE_TYPE;
        //-------------------------------------------------------
        // Try first Cert. Reply (Issuers Present), then Cert-Req
        //-------------------------------------------------------
        Retcode = DecodePemCertReqReply(HMEM_CTX_REF1
			SrcBuf, SrcOffset, SrcLen,
			pOrigCertBuf,pOrigCertLen, pIssuerCertsDesc,
			pSignatType, pSignatAlgor, pMicBuf, pMicLen,
			pTextBuf, pTextLen);
        if(Retcode != BASE64_OP_OK)
        {
          if(Retcode == PEM_DECODE_NO_ISSUER_ERR)	// might be request!
          {
            Retcode = DecodePemCertReqReply(HMEM_CTX_REF1
			SrcBuf, SrcOffset, SrcLen,
			pOrigCertBuf,pOrigCertLen, NULL,
			pSignatType, pSignatAlgor, pMicBuf, pMicLen,
			pTextBuf, pTextLen);
           if(Retcode != BASE64_OP_OK)			// neither
             break;
           pDataType[0] = PEM_REQ_DATA_TYPE;
          }
        }
        else
          pDataType[0] = PEM_REPLY_DATA_TYPE;

        if(pDataType[0] == PEM_REQ_DATA_TYPE)	// must be request
          Retcode = FromPEMCertReqToCertReqStrucEX(HMEM_CTX_REF1
		pOrigCertBuf[0],
		pOrigCertLen[0],pSignatType[0],pSignatAlgor[0],
		pMicBuf[0], pMicLen[0], pTextBuf[0], pTextLen[0],
		ProcessFlags, pCertReqStruc);
        else					// must be reply
          Retcode = FromPEMCertsToCertsArrayEX(HMEM_CTX_REF1
		pOrigCertBuf[0],
		pOrigCertLen[0],pIssuerCertsDesc[0],
		pSignatType[0], pSignatAlgor[0],
		pMicBuf[0], pMicLen[0], pTextBuf[0], pTextLen[0],
		ProcessFlags, ppCertList, pCertListCount);
        FREE_ARRAY(HMEM_CTX_REF,pOrigCertBuf[0]);
        FREE_ARRAY(HMEM_CTX_REF,pMicBuf[0]);
        FREE_ARRAY(HMEM_CTX_REF,pTextBuf[0]);
        break;
    } // swictch
    FREE_ARRAY(HMEM_CTX_REF,pTmpBuf[0]);
    if(Retcode == ASN1_OP_OK)
      Retcode = BASE64_OP_OK;
    return(Retcode);
  }
  //-------------------------------------------------------
  // Is not a simple encapsulated type, check for S-Mime
  //-------------------------------------------------------
  if(pFileType != NULL)				// assume not recognized
    pFileType[0] = B64_UNKNOWN_FILE_TYPE;
  Retcode = GetDecodeMimePKCSData(HMEM_CTX_REF1
		SrcBuf, SrcOffset, SrcLen,
		pTmpBuf, pTmpLen, pTmpCnt);
  if((Retcode != BASE64_OP_OK) ||		// error occured
     ((pTmpCnt[0] != 2) && (pTmpCnt[0] != 3)))	// invalid type
  {
    FREE_ARRAY(HMEM_CTX_REF,pTmpBuf[0]);
    return(BASE64_OP_OK);			// fake o.k. (filetype is inv.)
  }
  if(pFileType != NULL)				// is SMIME
    pFileType[0] = SMIME_FILE_TYPE;
  if(pTmpCnt[0] == 3)
  {
     pDataType[0] = PKCS10_DATA_TYPE;
     Retcode = FromASN1CertReqToCertReqStruc(HMEM_CTX_REF1 pTmpBuf[0],0,pTmpLen[0],0,(int) (ProcessFlags & 0x0),NULL,0,pCertReqStruc);
  }
  else
  {
    pDataType[0] = PKCS7_DATA_TYPE;
    Retcode = FromASN1_PKCS7CertListEX(HMEM_CTX_REF1 pTmpBuf[0],0,pTmpLen[0],ProcessFlags,ppCertList,pCertListCount);
  }
  FREE_ARRAY(HMEM_CTX_REF,pTmpBuf[0]);
  if(Retcode == ASN1_OP_OK)
    Retcode = BASE64_OP_OK;
  return(Retcode);
}

extern "C"  int  GetDecodeCertOrCertRequestData(HMEM_CTX_DEF
			char SrcBuf[],
			int SrcOffset, int SrcLen,
			X509CERT* pCertStruc[], PKCS10_CERTREQ* pCertReqStruc[],
			X509CERT** ppCertList[],
			int pCertListCount[],
			int pDataType[], int pFileType[])
{
  return(GetDecodeCertOrCertReqDataEX(HMEM_CTX_REF1
		SrcBuf, SrcOffset, SrcLen,
		0, pCertStruc, pCertReqStruc,
		ppCertList, pCertListCount, pDataType, pFileType, NULL, NULL));
}

#endif //!XH_INTERFACE

extern "C"  int  PutEncodeCertOrCertRequestData(HMEM_CTX_DEF
		int DataType,
		int DataFormat, X509CERT* CertStruc, PKCS10_CERTREQ* CertReqStruc,
		X509CERT** CertList, int CertListCount,
		char MicData[], int MicLen, char TextData[], int TextLen,
		int SignatAlgor, int SignatType,
		char* pDstBuf[], int pDstLen[])
{
  int Retcode;
  int SrcLen;
  int SrcOff;

  char* pSrcBuf;

  IDATA* pIdata;
  //-------------------------------------------------
  // Do some checks first
  //-------------------------------------------------
  if((pDstBuf == NULL) || (pDstLen == NULL))
    return(BASE64_NULL_PTR);
  //-------------------------------------------------
  // Distribute according to Format to generate
  //-------------------------------------------------
  switch(DataFormat)
  {
    //-----------------------------------------------------
    // pure DER/BER data requested, distribute...
    //-----------------------------------------------------
    case BINARY_FILE_TYPE:
      switch(DataType)
      {
        case PKCS10_DATA_TYPE:
        case X509_DATA_TYPE:
          if(DataType == PKCS10_DATA_TYPE)	// PKCS10 Cert-Req.
          {
            if(CertReqStruc == NULL)
              return(BASE64_NULL_PTR);
            pIdata  = CertReqStruc->CertificateRequest->ppArr[0];
          }
          else					// X509 Cert
          {
            if(CertStruc == NULL)
              return(BASE64_NULL_PTR);
            pIdata  = CertStruc->Certificate->ppArr[0];
          }
            pSrcBuf = pIdata->Base;
            SrcOff  = (int) pIdata->Off;
            SrcLen  = pIdata->Len;
	    if((pSrcBuf == NULL) || (SrcLen == 0))
              return(TO_CERTS_CERTREQ_NO_DATA_ERR);
            pDstBuf[0] = BIT8_ARRAY_ALLOC(HMEM_CTX_REF,SrcLen);
	    if(pDstBuf[0] == NULL)
              return(TO_CERTS_CERTREQ_ALLOC_ERR);
            pDstLen[0] = SrcLen;
	    memcpy(pDstBuf[0]+0,pSrcBuf+SrcOff,SrcLen);
	    return(BASE64_OP_OK);

        case PKCS7_DATA_TYPE:
          Retcode = ToASN1_PKCS7CertList(HMEM_CTX_REF1 CertList,CertListCount,pDstBuf,pDstLen);
          if(Retcode == ASN1_OP_OK) Retcode = BASE64_OP_OK;
          return(Retcode);

        default:
          return(TO_CERTS_CERTREQ_INV_DATA_FMT);
      }
    //-----------------------------------------------------
    // Base 64 encapsulated data requested, distribute...
    //-----------------------------------------------------
    case BASE64_ENCAP_FILE_TYPE:
      switch(DataType)
      {
        case PKCS10_DATA_TYPE:
	case X509_DATA_TYPE:
          if(DataType == PKCS10_DATA_TYPE)	// PKCS10 Cert-Req.
          {
            if(CertReqStruc == NULL)
              return(BASE64_NULL_PTR);
            pIdata  = CertReqStruc->CertificateRequest->ppArr[0];
          }
          else					// X509 Cert
          {
            if(CertStruc == NULL)
              return(BASE64_NULL_PTR);
            pIdata  = CertStruc->Certificate->ppArr[0];
          }

          pSrcBuf = pIdata->Base;
          SrcOff  = (int) pIdata->Off;
          SrcLen  = pIdata->Len;
          if((pSrcBuf == NULL) || (SrcLen == 0))
            return(TO_CERTS_CERTREQ_NO_DATA_ERR);
          return(ToEncapsulatedBase64(HMEM_CTX_REF1
			pSrcBuf, SrcOff, SrcLen,
			DataType, 1, pDstBuf, pDstLen));

	case PKCS7_DATA_TYPE:
          Retcode = ToASN1_PKCS7CertList(HMEM_CTX_REF1 CertList,CertListCount,pDstBuf,pDstLen);
          if(Retcode != ASN1_OP_OK)
            return(Retcode);			// conversion failed
          pSrcBuf = pDstBuf[0];
          SrcLen  = pDstLen[0];
          Retcode = ToEncapsulatedBase64(HMEM_CTX_REF1
			pSrcBuf, 0, SrcLen,
			DataType, 1, pDstBuf, pDstLen);
          FREE_ARRAY(HMEM_CTX_REF,pSrcBuf);
          return(Retcode);

        default:
          return(TO_CERTS_CERTREQ_INV_DATA_FMT);
      }
    //-----------------------------------------------------
    // PEM Request / Reply requested, distribute...
    //-----------------------------------------------------
    case PEM_FILE_TYPE:
      switch(DataType)
      {
        case PEM_REQ_DATA_TYPE:
          return(FromCertReqStrucToPEMCertReq(HMEM_CTX_REF1
			CertReqStruc,
			PEM_REQ_TIME_TYPE, PEM_NOT_AFTER_DELTA,
			pDstBuf, pDstLen));

        case PEM_REPLY_DATA_TYPE:
          return(FromCertsArrayToPEMCerts(HMEM_CTX_REF1
			CertList,CertListCount,
			SignatAlgor, SignatType, MicData, MicLen,
			TextData, TextLen, pDstBuf, pDstLen));

        default:
          return(TO_CERTS_CERTREQ_INV_DATA_FMT);
     }

    default:
      return(TO_CERTS_CERTREQ_PARAM_ERR);

  } // switch
}









#endif //HL_BASE64_PEM
// end of file ../hssl/pemb64.cpp

