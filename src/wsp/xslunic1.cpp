//#define TRACEHL1
/*+-------------------------------------------------------------------+*/
/*|                                                                   |*/
/*| PROGRAM NAME: xslunic1                                            |*/
/*| -------------                                                     |*/
/*|  Library of Unicode Functions                                     |*/
/*|  KB 06.11.04                                                      |*/
/*|                                                                   |*/
/*| COPYRIGHT:                                                        |*/
/*| ----------                                                        |*/
/*|  Copyright (C) HOB 2004                                           |*/
/*|  Copyright (C) HOB Germany 2005                                   |*/
/*|  Copyright (C) HOB Germany 2006                                   |*/
/*|  Copyright (C) HOB Germany 2007                                   |*/
/*|  Copyright (C) HOB Germany 2008                                   |*/
/*|  Copyright (C) HOB Germany 2009                                   |*/
/*|  Copyright (C) HOB Germany 2010                                   |*/
/*|  Copyright (C) HOB Germany 2011                                   |*/
/*|  Copyright (C) HOB Germany 2012                                   |*/
/*|  Copyright (C) HOB Germany 2013                                   |*/
/*|  Copyright (C) HOB Germany 2017                                   |*/
/*|                                                                   |*/
/*| REQUIRED PROGRAMS:                                                |*/
/*| ------------------                                                |*/
/*|  independant of operating system,                                 |*/
/*|  so any C/C++ compiler may be used.                               |*/
/*|                                                                   |*/
/*+-------------------------------------------------------------------+*/

/** @addtogroup unicode
* @{
* @file
* Main file of the unicode library, with the function definitions.
* Note that generally these functions do not support all encodings; especially
* ied_chs_html_1, ied_chs_uri_1, ied_chs_xml_utf_16, ied_chs_ldap_escaped_utf_8,
* ied_chs_hsf_1 and ied_chs_idna_1 are only supported by a few specialised ones.
* @}
*/

#ifndef PTYPE
#ifdef __cplusplus
#define PTYPE "C"
#else
#define PTYPE
#endif
#endif

#ifndef HL_UNIX
#define _CRT_SECURE_NO_WARNINGS
#endif
#include <stddef.h>
#include <stdlib.h>
#include <wchar.h>
#include <string.h>
#include <stdio.h>
#include <stdarg.h>
#include <assert.h>
#ifdef HL_OPENUNIX
#include <ctype.h>
#endif
#ifndef HL_UNIX
#include <windows.h>
#include <float.h>   /* only for _copysign() against problem with -0.0 */
#else
#include <sys/types.h>
#include <errno.h>
#include <ctype.h>
#include <hob-unix01.h>
#include <math.h>     /* only for floatingpoint-special-value handling */
#endif

#include <hob-xslunic1.h>
#define HL_EXT_TAB_850_TO_819
//#ifndef HL_UNIX
#include <hob-tab-ascii-ansi-1.h>
#define EXT_BASE64
#include <hob-tab-mime-base64.h>
//#else
//#include "hob-tab-ascii-ansi-1.h"
//#endif

/* to get scrs_from_base64 defined, include hob-tab-mime-base64.h      */

#ifdef HL_LINUX
#define isdigit(x) (((x >= '0') && (x <= '9')) ? (1):(0))
#endif

#ifdef  HL_AIX
#define isdigit(x) (((x >= '0') && (x <= '9')) ? (1):(0))
#endif

#ifndef HL_LONGLONG
#ifndef HL_UNIX
#define HL_LONGLONG LONGLONG
#else
#define HL_LONGLONG long long int
#endif
#endif
#ifndef HL_ULONGLONG
#ifndef HL_UNIX
#define HL_ULONGLONG ULONGLONG
#else
#define HL_ULONGLONG unsigned long long int
#endif
#endif

#ifdef __PCC__
#define bool BOOL
#define false FALSE
#define true TRUE
#endif





/** @defgroup unicode Character and string processing in different encodings.
* @{
*/
#define IDNACMP_WORKAROUND20121112
/*define BASE64_IGNORE_LBR*/

#define MAX_NO_WILDCARD 16                  /* maximum number of wildcard characters */

#define ASCII_REP_CHAR (char)0x3F           /* character ?      */
#define UTF16_REP_CHAR ((HL_WCHAR) 0XFFFD)  /* not displayable  */

#define D_DIGGRPLEN ((chl_spec&0xDF)=='X' ? 4 : 3)  /* digit group len of (dec1) */

/* maximum sizeof to regard with numbers to print with %d/ %l/ %ll may be given
   by these symbols to avoid warnings about senselessly wide bitshifts */
#ifndef HL_PRFMAXSO_I
#define HL_PRFMAXSO_I 999
#endif
#ifndef HL_PRFMAXSO_L
#define HL_PRFMAXSO_L 999
#endif
#ifndef HL_PRFMAXSO_LL
#define HL_PRFMAXSO_LL 999
#endif

#define CASE_IED_CHS_U16_ALLENDIAN \
   case ied_chs_utf_16:\
   case ied_chs_be_utf_16:\
   case ied_chs_le_utf_16:\
   /**/
#define CASE_IED_CHS_U32_ALLENDIAN \
   case ied_chs_utf_32:\
   case ied_chs_be_utf_32:\
   case ied_chs_le_utf_32:\
   /**/
#define CASE_IED_CHS_MISCCODEPAGES \
   case ied_chs_oem_437:\
   case ied_chs_wcp_874:\
   case ied_chs_wcp_1250:\
   case ied_chs_wcp_1251:\
   case ied_chs_wcp_1252:\
   case ied_chs_wcp_1253:\
   case ied_chs_wcp_1254:\
   case ied_chs_wcp_1255:\
   case ied_chs_wcp_1256:\
   case ied_chs_wcp_1257:\
   case ied_chs_wcp_1258:\
   /**/
#define CASE_IED_CHS_ALL_CJK \
   case ied_chs_wcp_932:\
   case ied_chs_wcp_936:\
   case ied_chs_wcp_949:\
   case ied_chs_wcp_950:\
   /**/
#define CASE_IED_CHS_ISO8859_2TO16 \
   case ied_chs_iso8859_2:\
   case ied_chs_iso8859_3:\
   case ied_chs_iso8859_4:\
   case ied_chs_iso8859_5:\
   case ied_chs_iso8859_6:\
   case ied_chs_iso8859_7:\
   case ied_chs_iso8859_8:\
   case ied_chs_iso8859_9:\
   case ied_chs_iso8859_10:\
   case ied_chs_iso8859_11:\
   case ied_chs_iso8859_13:\
   case ied_chs_iso8859_14:\
   case ied_chs_iso8859_15:\
   case ied_chs_iso8859_16:\
   /**/
#define CASE_IED_CHS_ESCHEXHEX_U8 \
   case ied_chs_uri_1:\
   case ied_chs_ldap_escaped_utf_8:\
   case ied_chs_hsf_1:\
   /**/

/** sorting of characters (used for codepoint<->HTML-entity-name pairs) */
struct dsd_char_sort {
   unsigned int umc_no;                     /**< Unicode representation */
   char *achc_char;                         /**< character string      */
};
/** used for transforming punycode (using an array of this as a tree)  */
struct dsd_idna_upoint {
   unsigned char utc_n;      /**< number of chars stored here (1 + those in subtrees). */
   unsigned char utc_l;      /**< index of subtree-top with smaller content */
   unsigned char utc_r;      /**< index of subtree-top with bigger content */
   unsigned char utc_u;      /**< index of node of which this is a direct subtree */
   unsigned char utc_p;      /**< number of chars left of this char in the
                                  incomplete string when it is inserted */
   unsigned int umc_cp;      /**< codepoint at this node               */
};
/** @} */
/** used for the compressed CJK-data (initialising CP 932/936/949/950) */
struct dsd_bitstring {
   const unsigned char *abyc_a;  /**< current location of data.        */
   short int isc_phase;      /**< bitscroll index, going 7->0. In reading mode, it means where last read */
   unsigned int inc_pbb;     /**< in reading mode 1 or 0               */
   unsigned int inc_pbv;     /**< if inc_pbb>0: in reading mode: pre-read "partial" bit (0 or 1) */
   unsigned int inc_pbw;     /**< not used in reading mode             */
};
/** info about a status of a single node in a huffman-encoding tree    */
enum ied_huffnodestatus {
   ied_has_subtree = 0,      /**< a subtree with other nodes has its root here */
   ied_is_leaf,              /**< this is a "leaf", no more depth here */
   ied_unused,               /**< mostly for temporary use while the construction function runs */
   ied_has_incomplete_subtree  /**< only for temporary use while the construction function runs */
};
/** used for the huffmann trees for the compressed CJK-data            */
struct dsd_huffnode {
   /** what is coded when the next bit in the code is unset (0) resp. set (1)              */
   union {
     struct dsd_huffnode* adsc_s;           /**< if not leaf, subtree-root                 */
     unsigned int unc_v;                    /**< if leaf, value the code stands for        */
   } urc[2];
   enum ied_huffnodestatus ierc_status[2];  /**< which member of urc[same_index] is valid  */
   struct dsd_huffnode* adsc_up;            /**< points to supertree, NULL if root         */
   /** auxiliary fields not used for constructing the tree (filled by m_note_branchlimit). */
   unsigned short usrc_au[2], usrc_ad[2];
   /* (it would probably have been better to define the struct otherwise,
       so that it would be either a leaf or lead to two subnodes.) */
};

/** which XML-(char- or predefined-entity-)reference char shall follow */
enum ied_xcro_st {
  /* a negative value means: no xml-char-/entity-ref output is running */
  ied_xcro_hex_00000F   =  0,               /**< lowest hexdigit       */
  ied_xcro_hex_start    =  1,               /**< starting '&' (hex)    */
  ied_xcro_hex_carpet   =  2,               /**< '#' for numeric (hex) */
  ied_xcro_hex_x        =  3,               /**< 'x' for hexadecimal   */
  ied_xcro_hex_0000F0   =  4,               /**< hexdigit: bits 4..7   */
  ied_xcro_dec_start    =  5,               /**< starting '&' (dec)    */
  ied_xcro_dec_carpet   =  6,               /**< '#' for numeric (dec) */
  ied_xcro_endchar      =  7,               /**< closing ';'           */
  ied_xcro_hex_000F00   =  8,               /**< hexdigit: bits 8..11  */
  ied_xcro_txt_start_lt =  9,               /**< starting '&' ("&lt;") */
  ied_xcro_txt_start_gt = 10,               /**< starting '&' ("&gt;") */
  ied_xcro_txt          = 11,               /**< char from entity-name */
  ied_xcro_hex_00F000   = 12,               /**< hexdigit: bits 12..15 */
  ied_xcro_after_end    = 13,               /**< nothing, jump back    */
  ied_xcro_dec_01       = 14,               /**< lowest decimal digit  */
  ied_xcro_dec_10       = 15,               /**< tens decimal digit    */
  ied_xcro_hex_0F0000   = 16,               /**< hexdigit: bits 16..19 */
  ied_xcro_hex_F00000   = 20                /**< hexdigit: bits 20..23 */
};

#ifdef HL_DEBUG_VA_ARG
/** for collecting some data when debugging the vararg library         */
unsigned char byr_va_arg_deb_buf[sizeof(long long)+sizeof(long double)+sizeof(void*)];
#define va_arg_debug(ap, type) ( \
  *((type*)byr_va_arg_deb_buf) = va_arg(ap,type), \
  m_va_arg_deb_out( #type, sizeof(type) ), \
  *((type*)byr_va_arg_deb_buf) \
)
#endif

#if defined HL_HPUX // Oed
extern "C" void * memchr(const void *, int, size_t);
extern "C" char * strchr(const char *, int);
#endif

static int m_get_vc_ch( unsigned int *, const char *, const char *, enum ied_charset );
static inline int m_get_html_1_a( unsigned int *, const char *, const char * );
static inline int m_put_html_1_a( char *, char *, unsigned int );
static inline int m_put_uri_1_a( char *, char *, unsigned int, char );
static inline int m_trans_32_to_lc( int );
static int m_sbcl_from_u8l( char*, int, enum ied_charset, const char*, int );
static int m_mbcl_from_u8l( char*, int, const HL_WCHAR*, const char*, int, BOOL* );
static enum ied_charset m_suppress_endian_info_if_native( enum ied_charset );
static int m_u8l_from_sbsl( char*, int, const char*, int, const unsigned short* );
static int m_u8l_from_mbsl( char*, int, const char*, int, const unsigned short*,
                                                          const unsigned short* );
static const char* m_get_limit( const struct dsd_unicode_string *adsp_ucs );

/* routines for using the two-step codepage conversion tables          */
static char m_u32c_to_sb_0step( unsigned int, const unsigned int*, const unsigned char* );
static char m_u32c_to_sb_2or3step( unsigned int, const unsigned int*, const unsigned char* );
static char m_u32c_to_sb_3step( unsigned int, const unsigned int*, const unsigned char* );
static char m_u32c_to_sb_3or4step( unsigned int, const unsigned int*, const unsigned char* );
static char m_u32c_to_sb_4step( unsigned int, const unsigned int*, const unsigned char* );
static char m_u32c_to_sb_5step( unsigned int, const unsigned int*, const unsigned char* );
static inline char m_u32_to_sb_80a0( unsigned int,
                                     char(unsigned int, const unsigned int*, const unsigned char*),
                                     const unsigned int*, const unsigned char* );
static inline char m_u32_to_sb_a1a0( unsigned int,
                                     char(unsigned int, const unsigned int*, const unsigned char*),
                                     const unsigned int*, const unsigned char* );
static inline char m_u32c_to_437( unsigned int );
static inline char m_u32c_to_874( unsigned int );
static inline char m_u32c_to_1250( unsigned int );
static inline char m_u32c_to_1251( unsigned int );
static inline char m_u32c_to_1252( unsigned int );
static inline char m_u32c_to_1253( unsigned int );
static inline char m_u32c_to_1254( unsigned int );
static inline char m_u32c_to_1255( unsigned int );
static inline char m_u32c_to_1256( unsigned int );
static inline char m_u32c_to_1257( unsigned int );
static inline char m_u32c_to_1258( unsigned int );
static inline char m_u32c_to_i02( unsigned int );
static inline char m_u32c_to_i03( unsigned int );
static inline char m_u32c_to_i04( unsigned int );
static inline char m_u32c_to_i05( unsigned int );
static inline char m_u32c_to_i06( unsigned int );
static inline char m_u32c_to_i07( unsigned int );
static inline char m_u32c_to_i08( unsigned int );
static inline char m_u32c_to_i09( unsigned int );
static inline char m_u32c_to_i10( unsigned int );
static inline char m_u32c_to_i11( unsigned int );
static inline char m_u32c_to_i13( unsigned int );
static inline char m_u32c_to_i14( unsigned int );
static inline char m_u32c_to_i15( unsigned int );
static inline char m_u32c_to_i16( unsigned int );

/* routines for reading the compressed CJK codepage data               */
static void m_init_read_bitstring(
       struct dsd_bitstring *adsp_source, const unsigned char *abyp_dataspace );
static BOOL m_get_bit_from_bitstring( struct dsd_bitstring *adsp_source );
static unsigned int m_get_num_from_bitstring( struct dsd_bitstring *adsp_source,
                      unsigned int unp_bound, unsigned short int usp_bitwidth );

/* CJK to/ from unicode conversion tables that are filled if required  */
static HL_WCHAR* m_get_tab_mb_firstbytes( enum ied_charset );
static HL_WCHAR* m_get_tab_mb_to_uni( enum ied_charset );
static HL_WCHAR* m_get_tab_uni_to_mb( enum ied_charset );
extern PTYPE HL_WCHAR *awcg_tab_932_leadbyte;
extern PTYPE HL_WCHAR *awcg_tab_936_leadbyte;
extern PTYPE HL_WCHAR *awcg_tab_949_leadbyte;
extern PTYPE HL_WCHAR *awcg_tab_950_leadbyte;
/** meaning in Codepage 932 of first byte (0xFFFF if DBCS lead byte)   */
HL_WCHAR *awcg_tab_932_leadbyte = NULL;
/** meaning in Codepage 936 of first byte (0xFFFF if DBCS lead byte)   */
HL_WCHAR *awcg_tab_936_leadbyte = NULL;
/** meaning in Codepage 949 of first byte (0xFFFF if DBCS lead byte)   */
HL_WCHAR *awcg_tab_949_leadbyte = NULL;
/** meaning in Codepage 950 of first byte (0xFFFF if DBCS lead byte)   */
HL_WCHAR *awcg_tab_950_leadbyte = NULL;
extern PTYPE HL_WCHAR *awcg_tab_932_to_uni;
extern PTYPE HL_WCHAR *awcg_tab_936_to_uni;
extern PTYPE HL_WCHAR *awcg_tab_949_to_uni;
extern PTYPE HL_WCHAR *awcg_tab_950_to_uni;
/** translation table from CP 932 doublebyte (big endian) to unicode   */
HL_WCHAR *awcg_tab_932_to_uni = NULL;
/** translation table from CP 936 doublebyte (big endian) to unicode   */
HL_WCHAR *awcg_tab_936_to_uni = NULL;
/** translation table from CP 949 doublebyte (big endian) to unicode   */
HL_WCHAR *awcg_tab_949_to_uni = NULL;
/** translation table from CP 950 doublebyte (big endian) to unicode   */
HL_WCHAR *awcg_tab_950_to_uni = NULL;
extern PTYPE HL_WCHAR *awcg_tab_uni_to_932;
extern PTYPE HL_WCHAR *awcg_tab_uni_to_936;
extern PTYPE HL_WCHAR *awcg_tab_uni_to_949;
extern PTYPE HL_WCHAR *awcg_tab_uni_to_950;
/** translation table from unicode below 64K to CP 932 (BE if 2 bytes) */
HL_WCHAR *awcg_tab_uni_to_932 = NULL;
/** translation table from unicode below 64K to CP 936 (BE if 2 bytes) */
HL_WCHAR *awcg_tab_uni_to_936 = NULL;
/** translation table from unicode below 64K to CP 949 (BE if 2 bytes) */
HL_WCHAR *awcg_tab_uni_to_949 = NULL;
/** translation table from unicode below 64K to CP 950 (BE if 2 bytes) */
HL_WCHAR *awcg_tab_uni_to_950 = NULL;

/** @addtogroup unicode
* @{
*/
/** table for URI reserved characters                                  */
static const char chrs_uri_1_tab[128] = {
   1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  /* 0X00 till 0X0F  */
   1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  /* 0X10 till 0X1F  */
   1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1,  /* 0X20 till 0X2F  */
   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1,  /* 0X30 till 0X3F  */
   1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  /* 0X40 till 0X4F  */
   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0,  /* 0X50 till 0X5F  */
   1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  /* 0X60 till 0X6F  */
   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1   /* 0X70 till 0X7F  */
};

/** table for ASCII non-alphanumeric characters                        */
static const char chrs_non09az_tab[128] = {
   1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  /* 0X00 till 0X0F  */
   1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  /* 0X10 till 0X1F  */
   1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  /* 0X20 till 0X2F  */
   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1,  /* 0X30 till 0X3F  */
   1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  /* 0X40 till 0X4F  */
   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1,  /* 0X50 till 0X5F  */
   1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  /* 0X60 till 0X6F  */
   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1   /* 0X70 till 0X7F  */
};

/** table how to escape characters by XML-references. Hex is preferred
    except if dec or name is shorter. Values as in enum ied_xcro_st. */
static const signed char chrs_xmlent_st[160] = {
    5,  5,  5,  5,  5,  5,  5,  5,  5, -1, -1,  1,  1, -1,  1,  1,
    5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,
   -1, -1,  5, -1, -1, -1,  5,  5, -1, -1, -1, -1, -1, -1, -1, -1,
   -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  9, -1, 10, -1,
   -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
   -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
   -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
   -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  1,
    1,  1,  1,  1,  1, -1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,
    1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1
};

/** decode UTF-8 (0 if immediate, 1 if tailbyte, length if startbyte)  */
static const char chrs_decode_utf_1_tab[256] = {
   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  /* 0X00 till 0X0F  */
   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  /* 0X10 till 0X1F  */
   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  /* 0X20 till 0X2F  */
   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  /* 0X30 till 0X3F  */
   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  /* 0X40 till 0X4F  */
   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  /* 0X50 till 0X5F  */
   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  /* 0X60 till 0X6F  */
   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  /* 0X70 till 0X7F  */
   1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  /* 0X80 till 0X8F  */
   1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  /* 0X90 till 0X9F  */
   1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  /* 0XA0 till 0XAF  */
   1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  /* 0XB0 till 0XBF  */
   2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,  /* 0XC0 till 0XCF  */
   2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,  /* 0XD0 till 0XDF  */
   3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,  /* 0XE0 till 0XEF  */
   4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 6, 6, 7, 0   /* 0XF0 till 0XFF  */
};

/** the number of bytes in the UTF8 multibyte sequence starting so - 1 */
static const unsigned char chrs_trail_u8l[256] = {
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5
};

/** categorisation of characters that can appear in printf-like format */
static const unsigned int umrs_format[128] = {
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,           /* 1  specifies              */
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,           /* 2  length modifiers       */
    1,  0,  0,  1,  0,  3,  0,  1,  1,  0,  1,  1,  0,  1,  1,  0,           /* 3  characters and strings */
/* SPC  !   "   #   $   %   &   '   (   )   *   +   ,   -   .   /     */

    1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  0,  0,  0,  0,  0,  0,           /* 4  numeric values         */
/* '0' '1' '2' '3' '4' '5' '6' '7' '8' '9'  :   ;   <   =   >   ?    */      /* 5 specifies for float or double */

    0,  0,  0,  0,  6,  5,  0,  5,  0,  2,  0,  0,  2,  0,  0,  4,
/*  @   A   B   C   D   E   F   G   H   I   J   K   L   M   N   O */

    0,  0,  0,  0,  0,  4,  0,  0,  4,  0,  0,  0,  0,  0,  0,  0,
/*  P   Q   R   S   T   U   V   W   X   Y   Z   [   \   ]   ^   _ */

    0,  0,  0,  3,  6,  5,  5,  5,  2,  6,  0,  0,  2,  0,  4,  4,
/*  `   a   b   c   d   e   f   g   h   i   j   k   l   m   n   o  */

    7,  0,  0,  3,  0,  4,  0,  0,  4,  0,  0,  0,  0,  0,  0,  0
/*  p   q   r   s   t   u   v   w   x   y   z   {   ?   }   ~   \u007F  */

};

/*
* The following part contains data for conversion between character encodings.
*
* The format of the data arrays in this part falls into different types:
* <ul>
* <li> Direct 256-Byte codepoint-to-codepoint lookup-tables
*      (names are like ucrg_tab_*_to_*).
*      (Two more of them can be found in hob-tab-ascii-ansi-1.h)
* <li> Conversions from 8-bit codes to unicode codepoints which have at
*      most 16 bits (lookup-tables with names like usrg_tab_*_to_uni),
*      and vice versa (in a two-step way with arrays named like
*      unrg_tabindex_uni_to_* and ucrg_tabparts_uni_to_*, see format
*      explanation at codepage 437). In the latter direction, all the
*      concerned encoding's existing mappings in the region U+0000..U+00FF
*      are covered by implicit conventions about the codes up to U+009F
*      and one single (the first defined) contiguous mapping region,
*      which begins always with U+00A0. 
* <li> Compressed data (as bitstrings for the helper functions like
*      m_get_num_from_bitstring() etc.) intended for constructing a
*      conversion table from a MBCS (sometimes 1 byte, sometimes 2 bytes)
*      encoding to unicode, as done by m_get_tab_mb_to_uni()
*      (names like ucrg_huff_cp*, ucrg_holes_cp* and ucrg_code_cp*)
* </ul>
*/

/*********************************************************************
***                                                                ***
***                   UNICODE to DOS-CODEPAGE 437                  ***
***                                                                ***
***                   Two-step-conversion tables                   ***
***                                                                ***
*********************************************************************/

/**
* Definition of the segments of table ucrg_tabparts_uni_to_437 below.
* This table is for the first step of a two-step conversion.
* An even-indexed value denotes a starting codepoint for a contiguous
* mapping region in ucrg_tabparts_uni_to_437 beginning at the index
* given by the the following odd-indexed value. This list of pairs is
* sorted by the even-indexed values. The last pair points behind the end.
* When adding more tables of this kind, also note the comment above.
*/
static unsigned int unrg_tabindex_uni_to_437[66] = {
    0x00A0,   0,   0x0192,  96,   0x0393,  97,   0x03A3, 103,
    0x03B1, 110,   0x03C0, 115,   0x2022, 122,   0x203C, 123,
    0x207F, 124,   0x20A7, 125,   0x2190, 126,   0x21A8, 132,
    0x2219, 133,   0x2229, 140,   0x2248, 141,   0x2261, 142,
    0x2302, 147,   0x2310, 148,   0x2320, 149,   0x2500, 151,
    0x250C, 154,   0x2524, 171,   0x252C, 172,   0x2534, 173,
    0x253C, 174,   0x2550, 175,   0x2580, 204,   0x25A0, 224,
    0x25AC, 225,   0x25D8, 257,   0x263A, 259,   0x2660, 268,
    0x266C, 280
};

/**
* Table for the second step, indexable by an unicode-codepoint minus an
* appropriate offset calculated from the table for the first step, such that the
* codepoint that starts the contiguous region (the highest even-indexed entry of
* the first-step-table that is not higher than the one you are looking for) is
* taken from this table at the index given by the first-step-table entry after
* that. If the resulting index is equal or above the index given for the next
* starter-codepoint (one pair further on in the first-step-table), it is
* invalid, that means the codepoint does not occur in the encoding. 
*
* Value 0 means that the mapped codepoint does not occur in the encoding (the
* real 0 codes U+0000, which is < 0x80, so not to be got by this table anyway).
*
* This table is for the encoding meant by the enum-value ied_chs_oem_437 from
* type ied_charset, that is, DOS-Codepage 437 ("DOS-US").
*/
static unsigned char ucrg_tabparts_uni_to_437[280] = {
/*U+00A0*/  0xFF,0xAD,0x9B,0x9C,0   ,0x9D,0   ,0x15,0   ,0   ,0xA6,0xAE,
            0xAA,0   ,0   ,0   ,0xF8,0xF1,0xFD,0   ,0   ,0xE6,0x14,0xFA,
            0   ,0   ,0xA7,0xAF,0xAC,0xAB,0   ,0xA8,0   ,0   ,0   ,0   ,
            0x8E,0x8F,0x92,0x80,0   ,0x90,0   ,0   ,0   ,0   ,0   ,0   ,
            0   ,0xA5,0   ,0   ,0   ,0   ,0x99,0   ,0   ,0   ,0   ,0   ,
            0x9A,0   ,0   ,0xE1,0x85,0xA0,0x83,0   ,0x84,0x86,0x91,0x87,
            0x8A,0x82,0x88,0x89,0x8D,0xA1,0x8C,0x8B,0   ,0xA4,0x95,0xA2,
            0x93,0   ,0x94,0xF6,0   ,0x97,0xA3,0x96,0x81,0   ,0   ,0x98,
/*U+0192*/  0x9F,
/*U+0393*/  0xE2,0   ,0   ,0   ,0   ,0xE9,
/*U+03A3*/  0xE4,0   ,0   ,0xE8,0   ,0   ,0xEA,
/*U+03B1*/  0xE0,0   ,0   ,0xEB,0xEE,
/*U+03C0*/  0xE3,0   ,0   ,0xE5,0xE7,0   ,0xED,
/*U+2022*/  0x07,
/*U+203C*/  0x13,
/*U+207F*/  0xFC,
/*U+20A7*/  0x9E,
/*U+2190*/  0x1B,0x18,0x1A,0x19,0x1D,0x12,
/*U+21A8*/  0x17,
/*U+2219*/  0xF9,0xFB,0   ,0   ,0   ,0xEC,0x1C,
/*U+2229*/  0xEF,
/*U+2248*/  0xF7,
/*U+2261*/  0xF0,0   ,0   ,0xF3,0xF2,
/*U+2302*/  0x7F,
/*U+2310*/  0xA9,
/*U+2320*/  0xF4,0xF5,
/*U+2500*/  0xC4,0   ,0xB3,
/*U+250C*/  0xDA,0   ,0   ,0   ,0xBF,0   ,0   ,0   ,0xC0,0   ,0   ,0   ,
            0xD9,0   ,0   ,0   ,0xC3,
/*U+2524*/  0xB4,
/*U+252C*/  0xC2,
/*U+2534*/  0xC1,
/*U+253C*/  0xC5,
/*U+2550*/  0xCD,0xBA,0xD5,0xD6,0xC9,0xB8,0xB7,0xBB,0xD4,0xD3,0xC8,0xBE,
            0xBD,0xBC,0xC6,0xC7,0xCC,0xB5,0xB6,0xB9,0xD1,0xD2,0xCB,0xCF,
            0xD0,0xCA,0xD8,0xD7,0xCE,
/*U+2580*/  0xDF,0   ,0   ,0   ,0xDC,0   ,0   ,0   ,0xDB,0   ,0   ,0   ,
            0xDD,0   ,0   ,0   ,0xDE,0xB0,0xB1,0xB2,
/*U+25A0*/  0xFE,
/*U+25AC*/  0x16,0   ,0   ,0   ,0   ,0   ,0x1E,0   ,0   ,0   ,0   ,0   ,
            0   ,0   ,0x10,0   ,0x1F,0   ,0   ,0   ,0   ,0   ,0   ,0   ,
            0x11,0   ,0   ,0   ,0   ,0   ,0   ,0x09,
/*U+25D8*/  0x08,0x0A,
/*U+263A*/  0x01,0x02,0x0F,0   ,0   ,0   ,0x0C,0   ,0x0B,
/*U+2660*/  0x06,0   ,0   ,0x05,0   ,0x03,0x04,0   ,0   ,0   ,0x0D,0x0E
};

/*********************************************************************
***                                                                ***
***                  DOS-CODEPAGE 437 to UNICODE                   ***
***                                                                ***
***                      Conversion table                          ***
***                                                                ***
*********************************************************************/
/** DOS-Codepage 437 ("DOS-US") to unicode-codepoints conversion table */

static unsigned short usrg_tab_437_to_uni[256] = {

/*          0      1      2      3      4      5      6      7      */
         0x0000,0x263A,0x263B,0x2665,0x2666,0x2663,0x2660,0x2022,   /* 0 OEM */

/*          8      9      A      B      C      D      E      F      */
         0x25D8, 0x09 , 0x0A ,0x2642,0x2640, 0x0D ,0x266B,0x263C,   /* 0     */
/*              0x25CB,0x25D9,              0x266A,                 */
/*          0      1      2      3      4      5      6      7      */
         0x25BA,0x25C4,0x2195,0x203C,0x00B6,0x00A7,0x25AC,0x21A8,   /* 1     */

/*          8      9      A      B      C      D      E      F      */
         0x2191,0x2193,0x2192, 0x1B ,0x221F,0x2194,0x25B2,0x25BC,   /* 1     */
/*                            0x2190,                               */
/*          0      1      2      3      4      5      6      7      */
         0x0020,0x0021,0x0022,0x0023,0x0024,0x0025,0x0026,0x0027,   /* 2     */

/*          8      9      A      B      C      D      E      F      */
         0x0028,0x0029,0x002A,0x002B,0x002C,0x002D,0x002E,0x002F,   /* 2     */

/*          0      1      2      3      4      5      6      7      */
         0x0030,0x0031,0x0032,0x0033,0x0034,0x0035,0x0036,0x0037,   /* 3     */

/*          8      9      A      B      C      D      E      F      */
         0x0038,0x0039,0x003A,0x003B,0x003C,0x003D,0x003E,0x003F,   /* 3     */

/*          0      1      2      3      4      5      6      7      */
         0x0040,0x0041,0x0042,0x0043,0x0044,0x0045,0x0046,0x0047,   /* 4     */

/*          8      9      A      B      C      D      E      F      */
         0x0048,0x0049,0x004A,0x004B,0x004C,0x004D,0x004E,0x004F,   /* 4     */

/*          0      1      2      3      4      5      6      7      */
         0x0050,0x0051,0x0052,0x0053,0x0054,0x0055,0x0056,0x0057,   /* 5     */

/*          8      9      A      B      C      D      E      F      */
         0x0058,0x0059,0x005A,0x005B,0x005C,0x005D,0x005E,0x005F,   /* 5     */

/*          0      1      2      3      4      5      6      7      */
         0x0060,0x0061,0x0062,0x0063,0x0064,0x0065,0x0066,0x0067,   /* 6 OEM */

/*          8      9      A      B      C      D      E      F      */
         0x0068,0x0069,0x006A,0x006B,0x006C,0x006D,0x006E,0x006F,   /* 6     */

/*          0      1      2      3      4      5      6      7      */
         0x0070,0x0071,0x0072,0x0073,0x0074,0x0075,0x0076,0x0077,   /* 7     */

/*          8      9      A      B      C      D      E      F      */
         0x0078,0x0079,0x007A,0x007B,0x007C,0x007D,0x007E,0x2302,   /* 7     */

/*          0      1      2      3      4      5      6      7      */
         0x00C7,0x00FC,0x00E9,0x00E2,0x00E4,0x00E0,0x00E5,0x00E7,   /* 8     */

/*          8      9      A      B      C      D      E      F      */
         0x00EA,0x00EB,0x00E8,0x00EF,0x00EE,0x00EC,0x00C4,0x00C5,   /* 8     */

/*          0      1      2      3      4      5      6      7      */
         0x00C9,0x00E6,0x00C6,0x00F4,0x00F6,0x00F2,0x00FB,0x00F9,   /* 9     */

/*          8      9      A      B      C      D      E      F      */
         0x00FF,0x00D6,0x00DC,0x00A2,0x00A3,0x00A5,0x20A7,0x0192,   /* 9     */

/*          0      1      2      3      4      5      6      7      */
         0x00E1,0x00ED,0x00F3,0x00FA,0x00F1,0x00D1,0x00AA,0x00BA,   /* A     */

/*          8      9      A      B      C      D      E      F      */
         0x00BF,0x2310,0x00AC,0x00BD,0x00BC,0x00A1,0x00AB,0x00BB,   /* A     */

/*          0      1      2      3      4      5      6      7      */
         0x2591,0x2592,0x2593,0x2502,0x2524,0x2561,0x2562,0x2556,   /* B     */

/*          8      9      A      B      C      D      E      F      */
         0x2555,0x2563,0x2551,0x2557,0x255D,0x255C,0x255B,0x2510,   /* B     */

/*          0      1      2      3      4      5      6      7      */
         0x2514,0x2534,0x252C,0x251C,0x2500,0x253C,0x255E,0x255F,   /* C OEM */

/*          8      9      A      B      C      D      E      F      */
         0x255A,0x2554,0x2569,0x2566,0x2560,0x2550,0x256C,0x2567,   /* C     */

/*          0      1      2      3      4      5      6      7      */
         0x2568,0x2564,0x2565,0x2559,0x2558,0x2552,0x2553,0x256B,   /* D     */

/*          8      9      A      B      C      D      E      F      */
         0x256A,0x2518,0x250C,0x2588,0x2584,0x258C,0x2590,0x2580,   /* D     */

/*          0      1      2      3      4      5      6      7      */
         0x03B1,0x00DF,0x0393,0x03C0,0x03A3,0x03C3,0x00B5,0x03C4,   /* E     */

/*          8      9      A      B      C      D      E      F      */
         0x03A6,0x0398,0x03A9,0x03B4,0x221E,0x03C6,0x03B5,0x2229,   /* E     */

/*          0      1      2      3      4      5      6      7      */
         0x2261,0x00B1,0x2265,0x2264,0x2320,0x2321,0x00F7,0x2248,   /* F     */

/*          8      9      A      B      C      D      E      F      */
         0x00B0,0x2219,0x00B7,0x221A,0x207F,0x00B2,0x25A0,0x00A0    /* F     */
};

/*********************************************************************
***                                                                ***
***                   DOS to DOS-CODEPAGE 437                      ***
***                                                                ***
***                      Conversion table                          ***
***                                                                ***
*********************************************************************/
/** DOS to DOS-CODEPAGE 437 Conversion table. Approximately gives
* Codepage-437-codepoints when indexed by Codepage-850-codepoints. When a
* character does not really exist in both charsets, there is no invalid content,
* but some arbitrarily chosen replacement. This table is not bijective,
* and therefore not an inverse of the table ucrg_tab_437_to_850 below.
*/

static unsigned char ucrg_tab_850_to_437[256] = {

/*         0    1    2    3    4    5    6    7     */
         0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,   /* 0 DOS */

/*         8    9    A    B    C    D    E    F     */
         0x08,0x09,0x0A,0x0B,0x0C,0x0D,0x0E,0x0F,   /* 0     */

/*         0    1    2    3    4    5    6    7     */
         0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,   /* 1     */

/*         8    9    A    B    C    D    E    F     */
         0x18,0x19,0x1A,0x1B,0x1C,0x1D,0x1E,0x1F,   /* 1     */

/*         0    1    2    3    4    5    6    7     */
         0x20,0x21,0x22,0x23,0x24,0x25,0x26,0x27,   /* 2     */

/*         8    9    A    B    C    D    E    F     */
         0x28,0x29,0x2A,0x2B,0x2C,0x2D,0x2E,0x2F,   /* 2     */

/*         0    1    2    3    4    5    6    7     */
         0x30,0x31,0x32,0x33,0x34,0x35,0x36,0x37,   /* 3     */

/*         8    9    A    B    C    D    E    F     */
         0x38,0x39,0x3A,0x3B,0x3C,0x3D,0x3E,0x3F,   /* 3     */

/*         0    1    2    3    4    5    6    7     */
         0x40,0x41,0x42,0x43,0x44,0x45,0x46,0x47,   /* 4     */

/*         8    9    A    B    C    D    E    F     */
         0x48,0x49,0x4A,0x4B,0x4C,0x4D,0x4E,0x4F,   /* 4     */

/*         0    1    2    3    4    5    6    7     */
         0x50,0x51,0x52,0x53,0x54,0x55,0x56,0x57,   /* 5     */

/*         8    9    A    B    C    D    E    F     */
         0x58,0x59,0x5A,0x5B,0x5C,0x5D,0x5E,0x5F,   /* 5     */

/*         0    1    2    3    4    5    6    7     */
         0x60,0x61,0x62,0x63,0x64,0x65,0x66,0x67,   /* 6 DOS */

/*         8    9    A    B    C    D    E    F     */
         0x68,0x69,0x6A,0x6B,0x6C,0x6D,0x6E,0x6F,   /* 6     */

/*         0    1    2    3    4    5    6    7     */
         0x70,0x71,0x72,0x73,0x74,0x75,0x76,0x77,   /* 7     */

/*         8    9    A    B    C    D    E    F     */
         0x78,0x79,0x7A,0x7B,0x7C,0x7D,0x7E,0x7F,   /* 7     */

/*         0    1    2    3    4    5    6    7     */
         0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,   /* 8     */

/*         8    9    A    B    C    D    E    F     */
         0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,   /* 8     */

/*         0    1    2    3    4    5    6    7     */
         0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,   /* 9     */

/*         8    9    A    B    C    D    E    F     */
         0x98,0x99,0x9A,0xED,0x9C,0xE8,0xF9,0x9F,   /* 9     */

/*         0    1    2    3    4    5    6    7     */
         0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,   /* A     */

/*         8    9    A    B    C    D    E    F     */
         0xA8,0x52,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,   /* A     */

/*         0    1    2    3    4    5    6    7     */
         0xB0,0xB1,0xB2,0xB3,0xB4,0x8F,0x8F,0x8F,   /* B     */

/*         8    9    A    B    C    D    E    F     */
         0x63,0xB9,0xBA,0xBB,0xBC,0x9B,0x9D,0xBF,   /* B     */

/*         0    1    2    3    4    5    6    7     */
         0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xE0,0x8E,   /* C DOS */

/*         8    9    A    B    C    D    E    F     */
         0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xE5,   /* C     */

/*         0    1    2    3    4    5    6    7     */
         0xEB,0x44,0xEE,0xDD,0xDE,0xF5,0xF4,0x49,   /* D     */

/*         8    9    A    B    C    D    E    F     */
         0x49,0xD9,0xDA,0xDB,0xDC,0xE3,0x49,0xDF,   /* D     */

/*         0    1    2    3    4    5    6    7     */
         0x4F,0xE1,0xEA,0x4F,0x99,0xE9,0xE6,0xE4,   /* E     */

/*         8    9    A    B    C    D    E    F     */
         0x9E,0xF3,0x9A,0xF2,0x98,0x59,0xF0,0xFB,   /* E     */

/*         0    1    2    3    4    5    6    7     */
         0xB0,0xF1,0xF7,0xA9,0x14,0x15,0xF6,0xEF,   /* F     */

/*         8    9    A    B    C    D    E    F     */
         0xF8,0xEC,0xFA,0x31,0x33,0xFD,0xFE,0xFF    /* F     */
};

/*********************************************************************
***                                                                ***
***                   DOS-CODEPAGE 437 to DOS                      ***
***                                                                ***
***                      Conversion table                          ***
***                                                                ***
*********************************************************************/
/** DOS-CODEPAGE 437 to DOS Conversion table. Approximately gives
* Codepage-850-codepoints when indexed by Codepage-437-codepoints. When a
* character does not really exist in both charsets, there is no invalid content,
* but some arbitrarily chosen replacement. This table is not bijective,
* and therefore not an inverse of the table ucrg_tab_850_to_437 above.
*/

static unsigned char ucrg_tab_437_to_850[256] = {

/*         0    1    2    3    4    5    6    7     */
         0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,   /* 0 OEM */

/*         8    9    A    B    C    D    E    F     */
         0x08,0x09,0x0A,0x0B,0x0C,0x0D,0x0E,0x0F,   /* 0     */

/*         0    1    2    3    4    5    6    7     */
         0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,   /* 1     */

/*         8    9    A    B    C    D    E    F     */
         0x18,0x19,0x1A,0x1B,0x1C,0x1D,0x1E,0x1F,   /* 1     */

/*         0    1    2    3    4    5    6    7     */
         0x20,0x21,0x22,0x23,0x24,0x25,0x26,0x27,   /* 2     */

/*         8    9    A    B    C    D    E    F     */
         0x28,0x29,0x2A,0x2B,0x2C,0x2D,0x2E,0x2F,   /* 2     */

/*         0    1    2    3    4    5    6    7     */
         0x30,0x31,0x32,0x33,0x34,0x35,0x36,0x37,   /* 3     */

/*         8    9    A    B    C    D    E    F     */
         0x38,0x39,0x3A,0x3B,0x3C,0x3D,0x3E,0x3F,   /* 3     */

/*         0    1    2    3    4    5    6    7     */
         0x40,0x41,0x42,0x43,0x44,0x45,0x46,0x47,   /* 4     */

/*         8    9    A    B    C    D    E    F     */
         0x48,0x49,0x4A,0x4B,0x4C,0x4D,0x4E,0x4F,   /* 4     */

/*         0    1    2    3    4    5    6    7     */
         0x50,0x51,0x52,0x53,0x54,0x55,0x56,0x57,   /* 5     */

/*         8    9    A    B    C    D    E    F     */
         0x58,0x59,0x5A,0x5B,0x5C,0x5D,0x5E,0x5F,   /* 5     */

/*         0    1    2    3    4    5    6    7     */
         0x60,0x61,0x62,0x63,0x64,0x65,0x66,0x67,   /* 6 OEM */

/*         8    9    A    B    C    D    E    F     */
         0x68,0x69,0x6A,0x6B,0x6C,0x6D,0x6E,0x6F,   /* 6     */

/*         0    1    2    3    4    5    6    7     */
         0x70,0x71,0x72,0x73,0x74,0x75,0x76,0x77,   /* 7     */

/*         8    9    A    B    C    D    E    F     */
         0x78,0x79,0x7A,0x7B,0x7C,0x7D,0x7E,0x7F,   /* 7     */

/*         0    1    2    3    4    5    6    7     */
         0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,   /* 8     */

/*         8    9    A    B    C    D    E    F     */
         0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,   /* 8     */

/*         0    1    2    3    4    5    6    7     */
         0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,   /* 9     */

/*         8    9    A    B    C    D    E    F     */
         0x98,0x99,0x9A,0xBD,0x9C,0xBE,0xE8,0x9F,   /* 9     */

/*         0    1    2    3    4    5    6    7     */
         0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,   /* A     */

/*         8    9    A    B    C    D    E    F     */
         0xA8,0xF3,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,   /* A     */

/*         0    1    2    3    4    5    6    7     */
         0xB0,0xB1,0xB2,0xB3,0xB4,0xB4,0xB9,0xBB,   /* B     */

/*         8    9    A    B    C    D    E    F     */
         0xBF,0xB9,0xBA,0xBB,0xBC,0xBC,0xD9,0xBF,   /* B     */

/*         0    1    2    3    4    5    6    7     */
         0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC3,0xCC,   /* C OEM */

/*         8    9    A    B    C    D    E    F     */
         0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xC1,   /* C     */

/*         0    1    2    3    4    5    6    7     */
         0xCA,0xC2,0xCB,0xC8,0xC0,0xDA,0xC9,0xCE,   /* D     */

/*         8    9    A    B    C    D    E    F     */
         0xC5,0xD9,0xDA,0xDB,0xDC,0xD3,0xD4,0xDF,   /* D     */

/*         0    1    2    3    4    5    6    7     */
         0xC6,0xE1,0xDA,0xDD,0xE7,0xCF,0xE6,0xC2,   /* E     */

/*         8    9    A    B    C    D    E    F     */
         0x9D,0xE5,0xE2,0xD0,0xF9,0x9B,0xD2,0xF7,   /* E     */

/*         0    1    2    3    4    5    6    7     */
         0xEE,0xF1,0xEB,0xE9,0xD6,0xD5,0xF6,0xF2,   /* F     */

/*         8    9    A    B    C    D    E    F     */
         0xF8,0x9E,0xFA,0xEF,0x6E,0xFD,0xFE,0xFF    /* F     */
};

/*********************************************************************
***                                                                ***
***                UNICODE to WINDOWS-CODEPAGE 1250                ***
***                                                                ***
***                   Two-step-conversion tables                   ***
***                                                                ***
*********************************************************************/

/**
* Definition of the segments of table ucrg_tabparts_uni_to_1250 below.
* Same format as table unrg_tabindex_uni_to_437, see explanation there.
* Identity with unicode can be assumed for the first 128 codepoints (0 to 0x7F);
* no unicode codepoint from U+0080..U+009F can be expressed by this encoding.
*/
static unsigned int unrg_tabindex_uni_to_1250[34] = {
    0x00A0,   0,   0x0102,  94,   0x010C, 100,   0x0118, 106,
    0x0139, 110,   0x0150, 126,   0x016E, 148,   0x0179, 152,
    0x02C7, 158,   0x02D8, 159,   0x2013, 165,   0x2018, 167,
    0x2030, 182,   0x2039, 183,   0x20AC, 185,   0x2122, 186,
    0x2123, 187
};

/**
* Table for the second step, as explained for ucrg_tabparts_uni_to_437,
* for what enum-value ied_chs_wcp_1250 means (Central European).
*/
static unsigned char ucrg_tabparts_uni_to_1250[187] = {
/*U+00A0*/  0xA0,0   ,0   ,0   ,0xA4,0   ,0xA6,0xA7,0xA8,0xA9,0   ,0xAB,
            0xAC,0xAD,0xAE,0   ,0xB0,0xB1,0   ,0   ,0xB4,0xB5,0xB6,0xB7,
            0xB8,0   ,0   ,0xBB,0   ,0   ,0   ,0   ,0   ,0xC1,0xC2,0   ,
            0xC4,0   ,0   ,0xC7,0   ,0xC9,0   ,0xCB,0   ,0xCD,0xCE,0   ,
            0   ,0   ,0   ,0xD3,0xD4,0   ,0xD6,0xD7,0   ,0   ,0xDA,0   ,
            0xDC,0xDD,0   ,0xDF,0   ,0xE1,0xE2,0   ,0xE4,0   ,0   ,0xE7,
            0   ,0xE9,0   ,0xEB,0   ,0xED,0xEE,0   ,0   ,0   ,0   ,0xF3,
            0xF4,0   ,0xF6,0xF7,0   ,0   ,0xFA,0   ,0xFC,0xFD,
/*U+0102*/  0xC3,0xE3,0xA5,0xB9,0xC6,0xE6,
/*U+010C*/  0xC8,0xE8,0xCF,0xEF,0xD0,0xF0,
/*U+0118*/  0xCA,0xEA,0xCC,0xEC,
/*U+0139*/  0xC5,0xE5,0   ,0   ,0xBC,0xBE,0   ,0   ,0xA3,0xB3,0xD1,0xF1,
            0   ,0   ,0xD2,0xF2,
/*U+0150*/  0xD5,0xF5,0   ,0   ,0xC0,0xE0,0   ,0   ,0xD8,0xF8,0x8C,0x9C,
            0   ,0   ,0xAA,0xBA,0x8A,0x9A,0xDE,0xFE,0x8D,0x9D,
/*U+016E*/  0xD9,0xF9,0xDB,0xFB,
/*U+0179*/  0x8F,0x9F,0xAF,0xBF,0x8E,0x9E,
/*U+02C7*/  0xA1,
/*U+02D8*/  0xA2,0xFF,0   ,0xB2,0   ,0xBD,
/*U+2013*/  0x96,0x97,
/*U+2018*/  0x91,0x92,0x82,0   ,0x93,0x94,0x84,0   ,0x86,0x87,0x95,0   ,
            0   ,0   ,0x85,
/*U+2030*/  0x89,
/*U+2039*/  0x8B,0x9B,
/*U+20AC*/  0x80,
/*U+2122*/  0x99
};

/*********************************************************************
***                                                                ***
***                WINDOWS-CODEPAGE 1250 to UNICODE                ***
***                                                                ***
***                      Conversion table                          ***
***                                                                ***
*********************************************************************/
/** Windows-Codepage 1250 (Centr.Eur.) to unicode-codepoints conversion table */

static unsigned short usrg_tab_1250_to_uni[256] = {

/*          0      1      2      3      4      5      6      7     */
         0x0000,0x0001,0x0002,0x0003,0x0004,0x0005,0x0006,0x0007,  /* 0 1250 */

/*          8      9      A      B      C      D      E      F     */
         0x0008,0x0009,0x000A,0x000B,0x000C,0x000D,0x000E,0x000F,  /* 0      */

/*          0      1      2      3      4      5      6      7     */
         0x0010,0x0011,0x0012,0x0013,0x0014,0x0015,0x0016,0x0017,  /* 1      */

/*          8      9      A      B      C      D      E      F     */
         0x0018,0x0019,0x001A,0x001B,0x001C,0x001D,0x001E,0x001F,  /* 1      */

/*          0      1      2      3      4      5      6      7     */
         0x0020,0x0021,0x0022,0x0023,0x0024,0x0025,0x0026,0x0027,  /* 2      */

/*          8      9      A      B      C      D      E      F     */
         0x0028,0x0029,0x002A,0x002B,0x002C,0x002D,0x002E,0x002F,  /* 2      */

/*          0      1      2      3      4      5      6      7     */
         0x0030,0x0031,0x0032,0x0033,0x0034,0x0035,0x0036,0x0037,  /* 3      */

/*          8      9      A      B      C      D      E      F     */
         0x0038,0x0039,0x003A,0x003B,0x003C,0x003D,0x003E,0x003F,  /* 3      */

/*          0      1      2      3      4      5      6      7     */
         0x0040,0x0041,0x0042,0x0043,0x0044,0x0045,0x0046,0x0047,  /* 4      */

/*          8      9      A      B      C      D      E      F     */
         0x0048,0x0049,0x004A,0x004B,0x004C,0x004D,0x004E,0x004F,  /* 4      */

/*          0      1      2      3      4      5      6      7     */
         0x0050,0x0051,0x0052,0x0053,0x0054,0x0055,0x0056,0x0057,  /* 5      */

/*          8      9      A      B      C      D      E      F     */
         0x0058,0x0059,0x005A,0x005B,0x005C,0x005D,0x005E,0x005F,  /* 5      */

/*          0      1      2      3      4      5      6      7     */
         0x0060,0x0061,0x0062,0x0063,0x0064,0x0065,0x0066,0x0067,  /* 6 1250 */

/*          8      9      A      B      C      D      E      F     */
         0x0068,0x0069,0x006A,0x006B,0x006C,0x006D,0x006E,0x006F,  /* 6      */

/*          0      1      2      3      4      5      6      7     */
         0x0070,0x0071,0x0072,0x0073,0x0074,0x0075,0x0076,0x0077,  /* 7      */

/*          8      9      A      B      C      D      E      F     */
         0x0078,0x0079,0x007A,0x007B,0x007C,0x007D,0x007E,0x007F,  /* 7      */

/*          0      1      2      3      4      5      6      7     */
         0x20AC,0x0081,0x201A,0x0083,0x201E,0x2026,0x2020,0x2021,  /* 8      */

/*          8      9      A      B      C      D      E      F     */
         0x0088,0x2030,0x0160,0x2039,0x015A,0x0164,0x017D,0x0179,  /* 8      */

/*          0      1      2      3      4      5      6      7     */
         0x0090,0x2018,0x2019,0x201C,0x201D,0x2022,0x2013,0x2014,  /* 9      */

/*          8      9      A      B      C      D      E      F     */
         0x0098,0x2122,0x0161,0x203A,0x015B,0x0165,0x017E,0x017A,  /* 9      */

/*          0      1      2      3      4      5      6      7     */
         0x00A0,0x02C7,0x02D8,0x0141,0x00A4,0x0104,0x00A6,0x00A7,  /* A      */

/*          8      9      A      B      C      D      E      F     */
         0x00A8,0x00A9,0x015E,0x00AB,0x00AC,0x00AD,0x00AE,0x017B,  /* A      */

/*          0      1      2      3      4      5      6      7     */
         0x00B0,0x00B1,0x02DB,0x0142,0x00B4,0x00B5,0x00B6,0x00B7,  /* B      */

/*          8      9      A      B      C      D      E      F     */
         0x00B8,0x0105,0x015F,0x00BB,0x013D,0x02DD,0x013E,0x017C,  /* B      */

/*          0      1      2      3      4      5      6      7     */
         0x0154,0x00C1,0x00C2,0x0102,0x00C4,0x0139,0x0106,0x00C7,  /* C 1250 */

/*          8      9      A      B      C      D      E      F     */
         0x010C,0x00C9,0x0118,0x00CB,0x011A,0x00CD,0x00CE,0x010E,  /* C      */

/*          0      1      2      3      4      5      6      7     */
         0x0110,0x0143,0x0147,0x00D3,0x00D4,0x0150,0x00D6,0x00D7,  /* D      */

/*          8      9      A      B      C      D      E      F     */
         0x0158,0x016E,0x00DA,0x0170,0x00DC,0x00DD,0x0162,0x00DF,  /* D      */

/*          0      1      2      3      4      5      6      7     */
         0x0155,0x00E1,0x00E2,0x0103,0x00E4,0x013A,0x0107,0x00E7,  /* E      */

/*          8      9      A      B      C      D      E      F     */
         0x010D,0x00E9,0x0119,0x00EB,0x011B,0x00ED,0x00EE,0x010F,  /* E      */

/*          0      1      2      3      4      5      6      7     */
         0x0111,0x0144,0x0148,0x00F3,0x00F4,0x0151,0x00F6,0x00F7,  /* F      */

/*          8      9      A      B      C      D      E      F     */
         0x0159,0x016F,0x00FA,0x0171,0x00FC,0x00FD,0x0163,0x02D9   /* F      */
};

/*********************************************************************
***                                                                ***
***                UNICODE to WINDOWS-CODEPAGE 1251                ***
***                                                                ***
***                   Two-step-conversion tables                   ***
***                                                                ***
*********************************************************************/

/**
* Definition of the segments of table ucrg_tabparts_uni_to_1251 below.
* Same format as table unrg_tabindex_uni_to_437, see explanation there.
* Identity with unicode can be assumed for the first 128 codepoints (0 to 0x7F);
* no unicode codepoint from U+0080..U+009F can be expressed by this encoding.
*/
static unsigned int unrg_tabindex_uni_to_1251[18] = {
    0x00A0,   0,   0x0401,  28,   0x0490, 123,   0x2013, 125,
    0x2030, 145,   0x20AC, 156,   0x2116, 157,   0x2122, 158,
    0x2123, 159
};

/**
* Table for the second step, as explained for ucrg_tabparts_uni_to_437,
* for what enum-value ied_chs_wcp_1251 means (Cyrillic).
*/
static unsigned char ucrg_tabparts_uni_to_1251[159] = {
/*U+00A0*/  0xA0,0   ,0   ,0   ,0xA4,0   ,0xA6,0xA7,0   ,0xA9,0   ,0xAB,
            0xAC,0xAD,0xAE,0   ,0xB0,0xB1,0   ,0   ,0   ,0xB5,0xB6,0xB7,
            0   ,0   ,0   ,0xBB,
/*U+0401*/  0xA8,0x80,0x81,0xAA,0xBD,0xB2,0xAF,0xA3,0x8A,0x8C,0x8E,0x8D,
            0   ,0xA1,0x8F,0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,
            0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,
            0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF,0xE0,
            0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,
            0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,
            0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF,0   ,0xB8,0x90,0x83,0xBA,
            0xBE,0xB3,0xBF,0xBC,0x9A,0x9C,0x9E,0x9D,0   ,0xA2,0x9F,
/*U+0490*/  0xA5,0xB4,
/*U+2013*/  0x96,0x97,0   ,0   ,0   ,0x91,0x92,0x82,0   ,0x93,0x94,0x84,
            0   ,0x86,0x87,0x95,0   ,0   ,0   ,0x85,
/*U+2030*/  0x89,0   ,0   ,0   ,0   ,0   ,0   ,0   ,0   ,0x8B,0x9B,
/*U+20AC*/  0x88,
/*U+2116*/  0xB9,
/*U+2122*/  0x99
};

/*********************************************************************
***                                                                ***
***                WINDOWS-CODEPAGE 1251 to UNICODE                ***
***                                                                ***
***                      Conversion table                          ***
***                                                                ***
*********************************************************************/
/** Windows-Codepage 1251 (Cyrillic) to unicode-codepoints conversion table */

static unsigned short usrg_tab_1251_to_uni[256] = {

/*          0      1      2      3      4      5      6      7     */
         0x0000,0x0001,0x0002,0x0003,0x0004,0x0005,0x0006,0x0007,  /* 0 1251 */

/*          8      9      A      B      C      D      E      F     */
         0x0008,0x0009,0x000A,0x000B,0x000C,0x000D,0x000E,0x000F,  /* 0      */

/*          0      1      2      3      4      5      6      7     */
         0x0010,0x0011,0x0012,0x0013,0x0014,0x0015,0x0016,0x0017,  /* 1      */

/*          8      9      A      B      C      D      E      F     */
         0x0018,0x0019,0x001A,0x001B,0x001C,0x001D,0x001E,0x001F,  /* 1      */

/*          0      1      2      3      4      5      6      7     */
         0x0020,0x0021,0x0022,0x0023,0x0024,0x0025,0x0026,0x0027,  /* 2      */

/*          8      9      A      B      C      D      E      F     */
         0x0028,0x0029,0x002A,0x002B,0x002C,0x002D,0x002E,0x002F,  /* 2      */

/*          0      1      2      3      4      5      6      7     */
         0x0030,0x0031,0x0032,0x0033,0x0034,0x0035,0x0036,0x0037,  /* 3      */

/*          8      9      A      B      C      D      E      F     */
         0x0038,0x0039,0x003A,0x003B,0x003C,0x003D,0x003E,0x003F,  /* 3      */

/*          0      1      2      3      4      5      6      7     */
         0x0040,0x0041,0x0042,0x0043,0x0044,0x0045,0x0046,0x0047,  /* 4      */

/*          8      9      A      B      C      D      E      F     */
         0x0048,0x0049,0x004A,0x004B,0x004C,0x004D,0x004E,0x004F,  /* 4      */

/*          0      1      2      3      4      5      6      7     */
         0x0050,0x0051,0x0052,0x0053,0x0054,0x0055,0x0056,0x0057,  /* 5      */

/*          8      9      A      B      C      D      E      F     */
         0x0058,0x0059,0x005A,0x005B,0x005C,0x005D,0x005E,0x005F,  /* 5      */

/*          0      1      2      3      4      5      6      7     */
         0x0060,0x0061,0x0062,0x0063,0x0064,0x0065,0x0066,0x0067,  /* 6 1251 */

/*          8      9      A      B      C      D      E      F     */
         0x0068,0x0069,0x006A,0x006B,0x006C,0x006D,0x006E,0x006F,  /* 6      */

/*          0      1      2      3      4      5      6      7     */
         0x0070,0x0071,0x0072,0x0073,0x0074,0x0075,0x0076,0x0077,  /* 7      */

/*          8      9      A      B      C      D      E      F     */
         0x0078,0x0079,0x007A,0x007B,0x007C,0x007D,0x007E,0x007F,  /* 7      */

/*          0      1      2      3      4      5      6      7     */
         0x0402,0x0403,0x201A,0x0453,0x201E,0x2026,0x2020,0x2021,  /* 8      */

/*          8      9      A      B      C      D      E      F     */
         0x20AC,0x2030,0x0409,0x2039,0x040A,0x040C,0x040B,0x040F,  /* 8      */

/*          0      1      2      3      4      5      6      7     */
         0x0452,0x2018,0x2019,0x201C,0x201D,0x2022,0x2013,0x2014,  /* 9      */

/*          8      9      A      B      C      D      E      F     */
         0x0098,0x2122,0x0459,0x203A,0x045A,0x045C,0x045B,0x045F,  /* 9      */

/*          0      1      2      3      4      5      6      7     */
         0x00A0,0x040E,0x045E,0x0408,0x00A4,0x0490,0x00A6,0x00A7,  /* A      */

/*          8      9      A      B      C      D      E      F     */
         0x0401,0x00A9,0x0404,0x00AB,0x00AC,0x00AD,0x00AE,0x0407,  /* A      */

/*          0      1      2      3      4      5      6      7     */
         0x00B0,0x00B1,0x0406,0x0456,0x0491,0x00B5,0x00B6,0x00B7,  /* B      */

/*          8      9      A      B      C      D      E      F     */
         0x0451,0x2116,0x0454,0x00BB,0x0458,0x0405,0x0455,0x0457,  /* B      */

/*          0      1      2      3      4      5      6      7     */
         0x0410,0x0411,0x0412,0x0413,0x0414,0x0415,0x0416,0x0417,  /* C 1251 */

/*          8      9      A      B      C      D      E      F     */
         0x0418,0x0419,0x041A,0x041B,0x041C,0x041D,0x041E,0x041F,  /* C      */

/*          0      1      2      3      4      5      6      7     */
         0x0420,0x0421,0x0422,0x0423,0x0424,0x0425,0x0426,0x0427,  /* D      */

/*          8      9      A      B      C      D      E      F     */
         0x0428,0x0429,0x042A,0x042B,0x042C,0x042D,0x042E,0x042F,  /* D      */

/*          0      1      2      3      4      5      6      7     */
         0x0430,0x0431,0x0432,0x0433,0x0434,0x0435,0x0436,0x0437,  /* E      */

/*          8      9      A      B      C      D      E      F     */
         0x0438,0x0439,0x043A,0x043B,0x043C,0x043D,0x043E,0x043F,  /* E      */

/*          0      1      2      3      4      5      6      7     */
         0x0440,0x0441,0x0442,0x0443,0x0444,0x0445,0x0446,0x0447,  /* F      */

/*          8      9      A      B      C      D      E      F     */
         0x0448,0x0449,0x044A,0x044B,0x044C,0x044D,0x044E,0x044F   /* F      */
};

/*********************************************************************
***                                                                ***
***                UNICODE to WINDOWS-CODEPAGE 1252                ***
***                                                                ***
***                   Two-step-conversion tables                   ***
***                                                                ***
*********************************************************************/

/**
* Definition of the segments of table ucrg_tabparts_uni_to_1252 below.
* Same format as table unrg_tabindex_uni_to_437, see explanation there.
* Identity with unicode can be assumed for the first 128 codepoints (0 to 0x7F);
* no unicode codepoint from U+0080..U+009F can be expressed by this encoding.
*/
static unsigned int unrg_tabindex_uni_to_1252[34] = {
    0x00A0,   0,   0x0152,  96,   0x0160,  98,   0x0178, 100,
    0x017D, 101,   0x0192, 103,   0x02C6, 104,   0x02DC, 105,
    0x2013, 106,   0x2018, 108,   0x201C, 111,   0x2026, 118,
    0x2030, 119,   0x2039, 120,   0x20AC, 122,   0x2122, 123,
    0x2123, 124
};

/**
* Table for the second step, as explained for ucrg_tabparts_uni_to_437,
* for what enum-value ied_chs_wcp_1252 means (Western European).
*/
static unsigned char ucrg_tabparts_uni_to_1252[124] = {
/*U+00A0*/  0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,
            0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,
            0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF,0xC0,0xC1,0xC2,0xC3,
            0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,
            0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,
            0xDC,0xDD,0xDE,0xDF,0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,
            0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,
            0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF,
/*U+0152*/  0x8C,0x9C,
/*U+0160*/  0x8A,0x9A,
/*U+0178*/  0x9F,
/*U+017D*/  0x8E,0x9E,
/*U+0192*/  0x83,
/*U+02C6*/  0x88,
/*U+02DC*/  0x98,
/*U+2013*/  0x96,0x97,
/*U+2018*/  0x91,0x92,0x82,
/*U+201C*/  0x93,0x94,0x84,0   ,0x86,0x87,0x95,
/*U+2026*/  0x85,
/*U+2030*/  0x89,
/*U+2039*/  0x8B,0x9B,
/*U+20AC*/  0x80,
/*U+2122*/  0x99
};

/*********************************************************************
***                                                                ***
***                WINDOWS-CODEPAGE 1252 to UNICODE                ***
***                                                                ***
***                      Conversion table                          ***
***                                                                ***
*********************************************************************/
/** Windows-Codepage 1252 (W-European) to unicode-codepoints conversion table */

static unsigned short usrg_tab_1252_to_uni[256] = {

/*          0      1      2      3      4      5      6      7     */
         0x0000,0x0001,0x0002,0x0003,0x0004,0x0005,0x0006,0x0007,  /* 0 1252 */

/*          8      9      A      B      C      D      E      F     */
         0x0008,0x0009,0x000A,0x000B,0x000C,0x000D,0x000E,0x000F,  /* 0      */

/*          0      1      2      3      4      5      6      7     */
         0x0010,0x0011,0x0012,0x0013,0x0014,0x0015,0x0016,0x0017,  /* 1      */

/*          8      9      A      B      C      D      E      F     */
         0x0018,0x0019,0x001A,0x001B,0x001C,0x001D,0x001E,0x001F,  /* 1      */

/*          0      1      2      3      4      5      6      7     */
         0x0020,0x0021,0x0022,0x0023,0x0024,0x0025,0x0026,0x0027,  /* 2      */

/*          8      9      A      B      C      D      E      F     */
         0x0028,0x0029,0x002A,0x002B,0x002C,0x002D,0x002E,0x002F,  /* 2      */

/*          0      1      2      3      4      5      6      7     */
         0x0030,0x0031,0x0032,0x0033,0x0034,0x0035,0x0036,0x0037,  /* 3      */

/*          8      9      A      B      C      D      E      F     */
         0x0038,0x0039,0x003A,0x003B,0x003C,0x003D,0x003E,0x003F,  /* 3      */

/*          0      1      2      3      4      5      6      7     */
         0x0040,0x0041,0x0042,0x0043,0x0044,0x0045,0x0046,0x0047,  /* 4      */

/*          8      9      A      B      C      D      E      F     */
         0x0048,0x0049,0x004A,0x004B,0x004C,0x004D,0x004E,0x004F,  /* 4      */

/*          0      1      2      3      4      5      6      7     */
         0x0050,0x0051,0x0052,0x0053,0x0054,0x0055,0x0056,0x0057,  /* 5      */

/*          8      9      A      B      C      D      E      F     */
         0x0058,0x0059,0x005A,0x005B,0x005C,0x005D,0x005E,0x005F,  /* 5      */

/*          0      1      2      3      4      5      6      7     */
         0x0060,0x0061,0x0062,0x0063,0x0064,0x0065,0x0066,0x0067,  /* 6 1252 */

/*          8      9      A      B      C      D      E      F     */
         0x0068,0x0069,0x006A,0x006B,0x006C,0x006D,0x006E,0x006F,  /* 6      */

/*          0      1      2      3      4      5      6      7     */
         0x0070,0x0071,0x0072,0x0073,0x0074,0x0075,0x0076,0x0077,  /* 7      */

/*          8      9      A      B      C      D      E      F     */
         0x0078,0x0079,0x007A,0x007B,0x007C,0x007D,0x007E,0x007F,  /* 7      */

/*          0      1      2      3      4      5      6      7     */
         0x20AC,0x0081,0x201A,0x0192,0x201E,0x2026,0x2020,0x2021,  /* 8      */

/*          8      9      A      B      C      D      E      F     */
         0x02C6,0x2030,0x0160,0x2039,0x0152,0x008D,0x017D,0x008F,  /* 8      */

/*          0      1      2      3      4      5      6      7     */
         0x0090,0x2018,0x2019,0x201C,0x201D,0x2022,0x2013,0x2014,  /* 9      */

/*          8      9      A      B      C      D      E      F     */
         0x02DC,0x2122,0x0161,0x203A,0x0153,0x009D,0x017E,0x0178,  /* 9      */

/*          0      1      2      3      4      5      6      7     */
         0x00A0,0x00A1,0x00A2,0x00A3,0x00A4,0x00A5,0x00A6,0x00A7,  /* A      */

/*          8      9      A      B      C      D      E      F     */
         0x00A8,0x00A9,0x00AA,0x00AB,0x00AC,0x00AD,0x00AE,0x00AF,  /* A      */

/*          0      1      2      3      4      5      6      7     */
         0x00B0,0x00B1,0x00B2,0x00B3,0x00B4,0x00B5,0x00B6,0x00B7,  /* B      */

/*          8      9      A      B      C      D      E      F     */
         0x00B8,0x00B9,0x00BA,0x00BB,0x00BC,0x00BD,0x00BE,0x00BF,  /* B      */

/*          0      1      2      3      4      5      6      7     */
         0x00C0,0x00C1,0x00C2,0x00C3,0x00C4,0x00C5,0x00C6,0x00C7,  /* C 1252 */

/*          8      9      A      B      C      D      E      F     */
         0x00C8,0x00C9,0x00CA,0x00CB,0x00CC,0x00CD,0x00CE,0x00CF,  /* C      */

/*          0      1      2      3      4      5      6      7     */
         0x00D0,0x00D1,0x00D2,0x00D3,0x00D4,0x00D5,0x00D6,0x00D7,  /* D      */

/*          8      9      A      B      C      D      E      F     */
         0x00D8,0x00D9,0x00DA,0x00DB,0x00DC,0x00DD,0x00DE,0x00DF,  /* D      */

/*          0      1      2      3      4      5      6      7     */
         0x00E0,0x00E1,0x00E2,0x00E3,0x00E4,0x00E5,0x00E6,0x00E7,  /* E      */

/*          8      9      A      B      C      D      E      F     */
         0x00E8,0x00E9,0x00EA,0x00EB,0x00EC,0x00ED,0x00EE,0x00EF,  /* E      */

/*          0      1      2      3      4      5      6      7     */
         0x00F0,0x00F1,0x00F2,0x00F3,0x00F4,0x00F5,0x00F6,0x00F7,  /* F      */

/*          8      9      A      B      C      D      E      F     */
         0x00F8,0x00F9,0x00FA,0x00FB,0x00FC,0x00FD,0x00FE,0x00FF   /* F      */
};

/*********************************************************************
***                                                                ***
***                UNICODE to WINDOWS-CODEPAGE 1253                ***
***                                                                ***
***                   Two-step-conversion tables                   ***
***                                                                ***
*********************************************************************/

/**
* Definition of the segments of table ucrg_tabparts_uni_to_1253 below.
* Same format as table unrg_tabindex_uni_to_437, see explanation there.
* Identity with unicode can be assumed for the first 128 codepoints (0 to 0x7F);
* no unicode codepoint from U+0080..U+009F can be expressed by this encoding.
*/
static unsigned int unrg_tabindex_uni_to_1253[18] = {
    0x00A0,   0,   0x0192,  30,   0x0384,  31,   0x2013, 106,
    0x2030, 126,   0x2039, 127,   0x20AC, 129,   0x2122, 130,
    0x2123, 131
};

/**
* Table for the second step, as explained for ucrg_tabparts_uni_to_437,
* for what enum-value ied_chs_wcp_1253 means (Greek).
*/
static unsigned char ucrg_tabparts_uni_to_1253[131] = {
/*U+00A0*/  0xA0,0   ,0   ,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0   ,0xAB,
            0xAC,0xAD,0xAE,0   ,0xB0,0xB1,0xB2,0xB3,0   ,0xB5,0xB6,0xB7,
            0   ,0   ,0   ,0xBB,0   ,0xBD,
/*U+0192*/  0x83,
/*U+0384*/  0xB4,0xA1,0xA2,0   ,0xB8,0xB9,0xBA,0   ,0xBC,0   ,0xBE,0xBF,
            0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,
            0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0   ,0xD3,0xD4,0xD5,0xD6,0xD7,
            0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF,0xE0,0xE1,0xE2,0xE3,
            0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,
            0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,
            0xFC,0xFD,0xFE,
/*U+2013*/  0x96,0x97,0xAF,0   ,0   ,0x91,0x92,0x82,0   ,0x93,0x94,0x84,
            0   ,0x86,0x87,0x95,0   ,0   ,0   ,0x85,
/*U+2030*/  0x89,
/*U+2039*/  0x8B,0x9B,
/*U+20AC*/  0x80,
/*U+2122*/  0x99
};

/*********************************************************************
***                                                                ***
***                WINDOWS-CODEPAGE 1253 to UNICODE                ***
***                                                                ***
***                      Conversion table                          ***
***                                                                ***
*********************************************************************/
/** Windows-Codepage 1253 (Greek) to unicode-codepoints conversion table */

static unsigned short usrg_tab_1253_to_uni[256] = {

/*          0      1      2      3      4      5      6      7     */
         0x0000,0x0001,0x0002,0x0003,0x0004,0x0005,0x0006,0x0007,  /* 0 1253 */

/*          8      9      A      B      C      D      E      F     */
         0x0008,0x0009,0x000A,0x000B,0x000C,0x000D,0x000E,0x000F,  /* 0      */

/*          0      1      2      3      4      5      6      7     */
         0x0010,0x0011,0x0012,0x0013,0x0014,0x0015,0x0016,0x0017,  /* 1      */

/*          8      9      A      B      C      D      E      F     */
         0x0018,0x0019,0x001A,0x001B,0x001C,0x001D,0x001E,0x001F,  /* 1      */

/*          0      1      2      3      4      5      6      7     */
         0x0020,0x0021,0x0022,0x0023,0x0024,0x0025,0x0026,0x0027,  /* 2      */

/*          8      9      A      B      C      D      E      F     */
         0x0028,0x0029,0x002A,0x002B,0x002C,0x002D,0x002E,0x002F,  /* 2      */

/*          0      1      2      3      4      5      6      7     */
         0x0030,0x0031,0x0032,0x0033,0x0034,0x0035,0x0036,0x0037,  /* 3      */

/*          8      9      A      B      C      D      E      F     */
         0x0038,0x0039,0x003A,0x003B,0x003C,0x003D,0x003E,0x003F,  /* 3      */

/*          0      1      2      3      4      5      6      7     */
         0x0040,0x0041,0x0042,0x0043,0x0044,0x0045,0x0046,0x0047,  /* 4      */

/*          8      9      A      B      C      D      E      F     */
         0x0048,0x0049,0x004A,0x004B,0x004C,0x004D,0x004E,0x004F,  /* 4      */

/*          0      1      2      3      4      5      6      7     */
         0x0050,0x0051,0x0052,0x0053,0x0054,0x0055,0x0056,0x0057,  /* 5      */

/*          8      9      A      B      C      D      E      F     */
         0x0058,0x0059,0x005A,0x005B,0x005C,0x005D,0x005E,0x005F,  /* 5      */

/*          0      1      2      3      4      5      6      7     */
         0x0060,0x0061,0x0062,0x0063,0x0064,0x0065,0x0066,0x0067,  /* 6 1253 */

/*          8      9      A      B      C      D      E      F     */
         0x0068,0x0069,0x006A,0x006B,0x006C,0x006D,0x006E,0x006F,  /* 6      */

/*          0      1      2      3      4      5      6      7     */
         0x0070,0x0071,0x0072,0x0073,0x0074,0x0075,0x0076,0x0077,  /* 7      */

/*          8      9      A      B      C      D      E      F     */
         0x0078,0x0079,0x007A,0x007B,0x007C,0x007D,0x007E,0x007F,  /* 7      */

/*          0      1      2      3      4      5      6      7     */
         0x20AC,0x0081,0x201A,0x0192,0x201E,0x2026,0x2020,0x2021,  /* 8      */

/*          8      9      A      B      C      D      E      F     */
         0x0088,0x2030,0x008A,0x2039,0x008C,0x008D,0x008E,0x008F,  /* 8      */

/*          0      1      2      3      4      5      6      7     */
         0x0090,0x2018,0x2019,0x201C,0x201D,0x2022,0x2013,0x2014,  /* 9      */

/*          8      9      A      B      C      D      E      F     */
         0x0098,0x2122,0x009A,0x203A,0x009C,0x009D,0x009E,0x009F,  /* 9      */

/*          0      1      2      3      4      5      6      7     */
         0x00A0,0x0385,0x0386,0x00A3,0x00A4,0x00A5,0x00A6,0x00A7,  /* A      */

/*          8      9      A      B      C      D      E      F     */
         0x00A8,0x00A9,0x00AA,0x00AB,0x00AC,0x00AD,0x00AE,0x2015,  /* A      */

/*          0      1      2      3      4      5      6      7     */
         0x00B0,0x00B1,0x00B2,0x00B3,0x0384,0x00B5,0x00B6,0x00B7,  /* B      */

/*          8      9      A      B      C      D      E      F     */
         0x0388,0x0389,0x038A,0x00BB,0x038C,0x00BD,0x038E,0x038F,  /* B      */

/*          0      1      2      3      4      5      6      7     */
         0x0390,0x0391,0x0392,0x0393,0x0394,0x0395,0x0396,0x0397,  /* C 1253 */

/*          8      9      A      B      C      D      E      F     */
         0x0398,0x0399,0x039A,0x039B,0x039C,0x039D,0x039E,0x039F,  /* C      */

/*          0      1      2      3      4      5      6      7     */
         0x03A0,0x03A1,0x00D2,0x03A3,0x03A4,0x03A5,0x03A6,0x03A7,  /* D      */

/*          8      9      A      B      C      D      E      F     */
         0x03A8,0x03A9,0x03AA,0x03AB,0x03AC,0x03AD,0x03AE,0x03AF,  /* D      */

/*          0      1      2      3      4      5      6      7     */
         0x03B0,0x03B1,0x03B2,0x03B3,0x03B4,0x03B5,0x03B6,0x03B7,  /* E      */

/*          8      9      A      B      C      D      E      F     */
         0x03B8,0x03B9,0x03BA,0x03BB,0x03BC,0x03BD,0x03BE,0x03BF,  /* E      */

/*          0      1      2      3      4      5      6      7     */
         0x03C0,0x03C1,0x03C2,0x03C3,0x03C4,0x03C5,0x03C6,0x03C7,  /* F      */

/*          8      9      A      B      C      D      E      F     */
         0x03C8,0x03C9,0x03CA,0x03CB,0x03CC,0x03CD,0x03CE,0x00FF   /* F      */
};

/*********************************************************************
***                                                                ***
***                UNICODE to WINDOWS-CODEPAGE 1254                ***
***                                                                ***
***                   Two-step-conversion tables                   ***
***                                                                ***
*********************************************************************/

/**
* Definition of the segments of table ucrg_tabparts_uni_to_1254 below.
* Same format as table unrg_tabindex_uni_to_437, see explanation there.
* Identity with unicode can be assumed for the first 128 codepoints (0 to 0x7F);
* no unicode codepoint from U+0080..U+009F can be expressed by this encoding.
*/
static unsigned int unrg_tabindex_uni_to_1254[34] = {
    0x00A0,   0,   0x011E,  96,   0x0130,  98,   0x0152, 100,
    0x015E, 102,   0x0178, 106,   0x0192, 107,   0x02C6, 108,
    0x02DC, 109,   0x2013, 110,   0x2018, 112,   0x2026, 123,
    0x2030, 124,   0x2039, 125,   0x20AC, 127,   0x2122, 128,
    0x2123, 129
};

/**
* Table for the second step, as explained for ucrg_tabparts_uni_to_437,
* for what enum-value ied_chs_wcp_1254 means (Turkish).
*/
static unsigned char ucrg_tabparts_uni_to_1254[129] = {
/*U+00A0*/  0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,
            0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,
            0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF,0xC0,0xC1,0xC2,0xC3,
            0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,
            0   ,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,
            0xDC,0   ,0   ,0xDF,0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,
            0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0   ,0xF1,0xF2,0xF3,
            0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0   ,0   ,0xFF,
/*U+011E*/  0xD0,0xF0,
/*U+0130*/  0xDD,0xFD,
/*U+0152*/  0x8C,0x9C,
/*U+015E*/  0xDE,0xFE,0x8A,0x9A,
/*U+0178*/  0x9F,
/*U+0192*/  0x83,
/*U+02C6*/  0x88,
/*U+02DC*/  0x98,
/*U+2013*/  0x96,0x97,
/*U+2018*/  0x91,0x92,0x82,0   ,0x93,0x94,0x84,0   ,0x86,0x87,0x95,
/*U+2026*/  0x85,
/*U+2030*/  0x89,
/*U+2039*/  0x8B,0x9B,
/*U+20AC*/  0x80,
/*U+2122*/  0x99
};

/*********************************************************************
***                                                                ***
***                WINDOWS-CODEPAGE 1254 to UNICODE                ***
***                                                                ***
***                      Conversion table                          ***
***                                                                ***
*********************************************************************/
/** Windows-Codepage 1254 (Turkish) to unicode-codepoints conversion table */

static unsigned short usrg_tab_1254_to_uni[256] = {

/*          0      1      2      3      4      5      6      7     */
         0x0000,0x0001,0x0002,0x0003,0x0004,0x0005,0x0006,0x0007,  /* 0 1254 */

/*          8      9      A      B      C      D      E      F     */
         0x0008,0x0009,0x000A,0x000B,0x000C,0x000D,0x000E,0x000F,  /* 0      */

/*          0      1      2      3      4      5      6      7     */
         0x0010,0x0011,0x0012,0x0013,0x0014,0x0015,0x0016,0x0017,  /* 1      */

/*          8      9      A      B      C      D      E      F     */
         0x0018,0x0019,0x001A,0x001B,0x001C,0x001D,0x001E,0x001F,  /* 1      */

/*          0      1      2      3      4      5      6      7     */
         0x0020,0x0021,0x0022,0x0023,0x0024,0x0025,0x0026,0x0027,  /* 2      */

/*          8      9      A      B      C      D      E      F     */
         0x0028,0x0029,0x002A,0x002B,0x002C,0x002D,0x002E,0x002F,  /* 2      */

/*          0      1      2      3      4      5      6      7     */
         0x0030,0x0031,0x0032,0x0033,0x0034,0x0035,0x0036,0x0037,  /* 3      */

/*          8      9      A      B      C      D      E      F     */
         0x0038,0x0039,0x003A,0x003B,0x003C,0x003D,0x003E,0x003F,  /* 3      */

/*          0      1      2      3      4      5      6      7     */
         0x0040,0x0041,0x0042,0x0043,0x0044,0x0045,0x0046,0x0047,  /* 4      */

/*          8      9      A      B      C      D      E      F     */
         0x0048,0x0049,0x004A,0x004B,0x004C,0x004D,0x004E,0x004F,  /* 4      */

/*          0      1      2      3      4      5      6      7     */
         0x0050,0x0051,0x0052,0x0053,0x0054,0x0055,0x0056,0x0057,  /* 5      */

/*          8      9      A      B      C      D      E      F     */
         0x0058,0x0059,0x005A,0x005B,0x005C,0x005D,0x005E,0x005F,  /* 5      */

/*          0      1      2      3      4      5      6      7     */
         0x0060,0x0061,0x0062,0x0063,0x0064,0x0065,0x0066,0x0067,  /* 6 1254 */

/*          8      9      A      B      C      D      E      F     */
         0x0068,0x0069,0x006A,0x006B,0x006C,0x006D,0x006E,0x006F,  /* 6      */

/*          0      1      2      3      4      5      6      7     */
         0x0070,0x0071,0x0072,0x0073,0x0074,0x0075,0x0076,0x0077,  /* 7      */

/*          8      9      A      B      C      D      E      F     */
         0x0078,0x0079,0x007A,0x007B,0x007C,0x007D,0x007E,0x007F,  /* 7      */

/*          0      1      2      3      4      5      6      7     */
         0x20AC,0x0081,0x201A,0x0192,0x201E,0x2026,0x2020,0x2021,  /* 8      */

/*          8      9      A      B      C      D      E      F     */
         0x02C6,0x2030,0x0160,0x2039,0x0152,0x008D,0x008E,0x008F,  /* 8      */

/*          0      1      2      3      4      5      6      7     */
         0x0090,0x2018,0x2019,0x201C,0x201D,0x2022,0x2013,0x2014,  /* 9      */

/*          8      9      A      B      C      D      E      F     */
         0x02DC,0x2122,0x0161,0x203A,0x0153,0x009D,0x009E,0x0178,  /* 9      */

/*          0      1      2      3      4      5      6      7     */
         0x00A0,0x00A1,0x00A2,0x00A3,0x00A4,0x00A5,0x00A6,0x00A7,  /* A      */

/*          8      9      A      B      C      D      E      F     */
         0x00A8,0x00A9,0x00AA,0x00AB,0x00AC,0x00AD,0x00AE,0x00AF,  /* A      */

/*          0      1      2      3      4      5      6      7     */
         0x00B0,0x00B1,0x00B2,0x00B3,0x00B4,0x00B5,0x00B6,0x00B7,  /* B      */

/*          8      9      A      B      C      D      E      F     */
         0x00B8,0x00B9,0x00BA,0x00BB,0x00BC,0x00BD,0x00BE,0x00BF,  /* B      */

/*          0      1      2      3      4      5      6      7     */
         0x00C0,0x00C1,0x00C2,0x00C3,0x00C4,0x00C5,0x00C6,0x00C7,  /* C 1254 */

/*          8      9      A      B      C      D      E      F     */
         0x00C8,0x00C9,0x00CA,0x00CB,0x00CC,0x00CD,0x00CE,0x00CF,  /* C      */

/*          0      1      2      3      4      5      6      7     */
         0x011E,0x00D1,0x00D2,0x00D3,0x00D4,0x00D5,0x00D6,0x00D7,  /* D      */

/*          8      9      A      B      C      D      E      F     */
         0x00D8,0x00D9,0x00DA,0x00DB,0x00DC,0x0130,0x015E,0x00DF,  /* D      */

/*          0      1      2      3      4      5      6      7     */
         0x00E0,0x00E1,0x00E2,0x00E3,0x00E4,0x00E5,0x00E6,0x00E7,  /* E      */

/*          8      9      A      B      C      D      E      F     */
         0x00E8,0x00E9,0x00EA,0x00EB,0x00EC,0x00ED,0x00EE,0x00EF,  /* E      */

/*          0      1      2      3      4      5      6      7     */
         0x011F,0x00F1,0x00F2,0x00F3,0x00F4,0x00F5,0x00F6,0x00F7,  /* F      */

/*          8      9      A      B      C      D      E      F     */
         0x00F8,0x00F9,0x00FA,0x00FB,0x00FC,0x0131,0x015F,0x00FF   /* F      */
};

/*********************************************************************
***                                                                ***
***                UNICODE to WINDOWS-CODEPAGE 1255                ***
***                                                                ***
***                   Two-step-conversion tables                   ***
***                                                                ***
*********************************************************************/

/**
* Definition of the segments of table ucrg_tabparts_uni_to_1255 below.
* Same format as table unrg_tabindex_uni_to_437, see explanation there.
* Identity with unicode can be assumed for the first 128 codepoints (0 to 0x7F);
* no unicode codepoint from U+0080..U+009F can be expressed by this encoding.
*/
static unsigned int unrg_tabindex_uni_to_1255[34] = {
    0x00A0,   0,   0x0192,  88,   0x02C6,  89,   0x02DC,  90,
    0x05B0,  91,   0x05D0, 111,   0x05F0, 138,   0x200E, 143,
    0x2013, 145,   0x2018, 147,   0x2020, 154,   0x2026, 157,
    0x2030, 158,   0x2039, 159,   0x20AA, 161,   0x2122, 164,
    0x2123, 165
};

/**
* Table for the second step, as explained for ucrg_tabparts_uni_to_437,
* for what enum-value ied_chs_wcp_1255 means (Hebrew).
*/
static unsigned char ucrg_tabparts_uni_to_1255[165] = {
/*U+00A0*/  0xA0,0xA1,0xA2,0xA3,0   ,0xA5,0xA6,0xA7,0xA8,0xA9,0   ,0xAB,
            0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,
            0xB8,0xB9,0   ,0xBB,0xBC,0xBD,0xBE,0xBF,0   ,0   ,0   ,0   ,
            0   ,0   ,0   ,0   ,0   ,0   ,0   ,0   ,0   ,0   ,0   ,0   ,
            0   ,0   ,0   ,0   ,0   ,0   ,0   ,0xAA,0   ,0   ,0   ,0   ,
            0   ,0   ,0   ,0   ,0   ,0   ,0   ,0   ,0   ,0   ,0   ,0   ,
            0   ,0   ,0   ,0   ,0   ,0   ,0   ,0   ,0   ,0   ,0   ,0   ,
            0   ,0   ,0   ,0xBA,
/*U+0192*/  0x83,
/*U+02C6*/  0x88,
/*U+02DC*/  0x98,
/*U+05B0*/  0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0   ,0xCB,
            0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,
/*U+05D0*/  0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,
            0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,
            0xF8,0xF9,0xFA,
/*U+05F0*/  0xD4,0xD5,0xD6,0xD7,0xD8,
/*U+200E*/  0xFD,0xFE,
/*U+2013*/  0x96,0x97,
/*U+2018*/  0x91,0x92,0x82,0   ,0x93,0x94,0x84,
/*U+2020*/  0x86,0x87,0x95,
/*U+2026*/  0x85,
/*U+2030*/  0x89,
/*U+2039*/  0x8B,0x9B,
/*U+20AA*/  0xA4,0   ,0x80,
/*U+2122*/  0x99
};

/*********************************************************************
***                                                                ***
***                WINDOWS-CODEPAGE 1255 to UNICODE                ***
***                                                                ***
***                      Conversion table                          ***
***                                                                ***
*********************************************************************/
/** Windows-Codepage 1255 (Hebrew) to unicode-codepoints conversion table */

static unsigned short usrg_tab_1255_to_uni[256] = {

/*          0      1      2      3      4      5      6      7     */
         0x0000,0x0001,0x0002,0x0003,0x0004,0x0005,0x0006,0x0007,  /* 0 1255 */

/*          8      9      A      B      C      D      E      F     */
         0x0008,0x0009,0x000A,0x000B,0x000C,0x000D,0x000E,0x000F,  /* 0      */

/*          0      1      2      3      4      5      6      7     */
         0x0010,0x0011,0x0012,0x0013,0x0014,0x0015,0x0016,0x0017,  /* 1      */

/*          8      9      A      B      C      D      E      F     */
         0x0018,0x0019,0x001A,0x001B,0x001C,0x001D,0x001E,0x001F,  /* 1      */

/*          0      1      2      3      4      5      6      7     */
         0x0020,0x0021,0x0022,0x0023,0x0024,0x0025,0x0026,0x0027,  /* 2      */

/*          8      9      A      B      C      D      E      F     */
         0x0028,0x0029,0x002A,0x002B,0x002C,0x002D,0x002E,0x002F,  /* 2      */

/*          0      1      2      3      4      5      6      7     */
         0x0030,0x0031,0x0032,0x0033,0x0034,0x0035,0x0036,0x0037,  /* 3      */

/*          8      9      A      B      C      D      E      F     */
         0x0038,0x0039,0x003A,0x003B,0x003C,0x003D,0x003E,0x003F,  /* 3      */

/*          0      1      2      3      4      5      6      7     */
         0x0040,0x0041,0x0042,0x0043,0x0044,0x0045,0x0046,0x0047,  /* 4      */

/*          8      9      A      B      C      D      E      F     */
         0x0048,0x0049,0x004A,0x004B,0x004C,0x004D,0x004E,0x004F,  /* 4      */

/*          0      1      2      3      4      5      6      7     */
         0x0050,0x0051,0x0052,0x0053,0x0054,0x0055,0x0056,0x0057,  /* 5      */

/*          8      9      A      B      C      D      E      F     */
         0x0058,0x0059,0x005A,0x005B,0x005C,0x005D,0x005E,0x005F,  /* 5      */

/*          0      1      2      3      4      5      6      7     */
         0x0060,0x0061,0x0062,0x0063,0x0064,0x0065,0x0066,0x0067,  /* 6 1255 */

/*          8      9      A      B      C      D      E      F     */
         0x0068,0x0069,0x006A,0x006B,0x006C,0x006D,0x006E,0x006F,  /* 6      */

/*          0      1      2      3      4      5      6      7     */
         0x0070,0x0071,0x0072,0x0073,0x0074,0x0075,0x0076,0x0077,  /* 7      */

/*          8      9      A      B      C      D      E      F     */
         0x0078,0x0079,0x007A,0x007B,0x007C,0x007D,0x007E,0x007F,  /* 7      */

/*          0      1      2      3      4      5      6      7     */
         0x20AC,0x0081,0x201A,0x0192,0x201E,0x2026,0x2020,0x2021,  /* 8      */

/*          8      9      A      B      C      D      E      F     */
         0x02C6,0x2030,0x008A,0x2039,0x008C,0x008D,0x008E,0x008F,  /* 8      */

/*          0      1      2      3      4      5      6      7     */
         0x0090,0x2018,0x2019,0x201C,0x201D,0x2022,0x2013,0x2014,  /* 9      */

/*          8      9      A      B      C      D      E      F     */
         0x02DC,0x2122,0x009A,0x203A,0x009C,0x009D,0x009E,0x009F,  /* 9      */

/*          0      1      2      3      4      5      6      7     */
         0x00A0,0x00A1,0x00A2,0x00A3,0x20AA,0x00A5,0x00A6,0x00A7,  /* A      */

/*          8      9      A      B      C      D      E      F     */
         0x00A8,0x00A9,0x00D7,0x00AB,0x00AC,0x00AD,0x00AE,0x00AF,  /* A      */

/*          0      1      2      3      4      5      6      7     */
         0x00B0,0x00B1,0x00B2,0x00B3,0x00B4,0x00B5,0x00B6,0x00B7,  /* B      */

/*          8      9      A      B      C      D      E      F     */
         0x00B8,0x00B9,0x00F7,0x00BB,0x00BC,0x00BD,0x00BE,0x00BF,  /* B      */

/*          0      1      2      3      4      5      6      7     */
         0x05B0,0x05B1,0x05B2,0x05B3,0x05B4,0x05B5,0x05B6,0x05B7,  /* C 1255 */

/*          8      9      A      B      C      D      E      F     */
         0x05B8,0x05B9,0x00CA,0x05BB,0x05BC,0x05BD,0x05BE,0x05BF,  /* C      */

/*          0      1      2      3      4      5      6      7     */
         0x05C0,0x05C1,0x05C2,0x05C3,0x05F0,0x05F1,0x05F2,0x05F3,  /* D      */

/*          8      9      A      B      C      D      E      F     */
         0x05F4,0x00D9,0x00DA,0x00DB,0x00DC,0x00DD,0x00DE,0x00DF,  /* D      */

/*          0      1      2      3      4      5      6      7     */
         0x05D0,0x05D1,0x05D2,0x05D3,0x05D4,0x05D5,0x05D6,0x05D7,  /* E      */

/*          8      9      A      B      C      D      E      F     */
         0x05D8,0x05D9,0x05DA,0x05DB,0x05DC,0x05DD,0x05DE,0x05DF,  /* E      */

/*          0      1      2      3      4      5      6      7     */
         0x05E0,0x05E1,0x05E2,0x05E3,0x05E4,0x05E5,0x05E6,0x05E7,  /* F      */

/*          8      9      A      B      C      D      E      F     */
         0x05E8,0x05E9,0x05EA,0x00FB,0x00FC,0x200E,0x200F,0x00FF   /* F      */
};

/*********************************************************************
***                                                                ***
***                UNICODE to WINDOWS-CODEPAGE 1256                ***
***                                                                ***
***                   Two-step-conversion tables                   ***
***                                                                ***
*********************************************************************/

/**
* Definition of the segments of table ucrg_tabparts_uni_to_1256 below.
* Same format as table unrg_tabindex_uni_to_437, see explanation there.
* Identity with unicode can be assumed for the first 128 codepoints (0 to 0x7F);
* no unicode codepoint from U+0080..U+009F can be expressed by this encoding.
*/
static unsigned int unrg_tabindex_uni_to_1256[34] = {
    0x00A0,   0,   0x0152,  93,   0x0192,  95,   0x02C6,  96,
    0x060C,  97,   0x061B,  98,   0x0679, 154,   0x0691, 170,
    0x06A9, 178,   0x06BA, 185,   0x06D2, 193,   0x200C, 194,
    0x2030, 221,   0x2039, 222,   0x20AC, 224,   0x2122, 225,
    0x2123, 226
};

/**
* Table for the second step, as explained for ucrg_tabparts_uni_to_437,
* for what enum-value ied_chs_wcp_1256 means (Arabic).
*/
static unsigned char ucrg_tabparts_uni_to_1256[226] = {
/*U+00A0*/  0xA0,0   ,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0   ,0xAB,
            0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,
            0xB8,0xB9,0   ,0xBB,0xBC,0xBD,0xBE,0   ,0   ,0   ,0   ,0   ,
            0   ,0   ,0   ,0   ,0   ,0   ,0   ,0   ,0   ,0   ,0   ,0   ,
            0   ,0   ,0   ,0   ,0   ,0   ,0   ,0xD7,0   ,0   ,0   ,0   ,
            0   ,0   ,0   ,0   ,0xE0,0   ,0xE2,0   ,0   ,0   ,0   ,0xE7,
            0xE8,0xE9,0xEA,0xEB,0   ,0   ,0xEE,0xEF,0   ,0   ,0   ,0   ,
            0xF4,0   ,0   ,0xF7,0   ,0xF9,0   ,0xFB,0xFC,
/*U+0152*/  0x8C,0x9C,
/*U+0192*/  0x83,
/*U+02C6*/  0x88,
/*U+060C*/  0xA1,
/*U+061B*/  0xBA,0   ,0   ,0   ,0xBF,0   ,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,
            0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,
            0xD3,0xD4,0xD5,0xD6,0xD8,0xD9,0xDA,0xDB,0   ,0   ,0   ,0   ,
            0   ,0xDC,0xDD,0xDE,0xDF,0xE1,0xE3,0xE4,0xE5,0xE6,0xEC,0xED,
            0xF0,0xF1,0xF2,0xF3,0xF5,0xF6,0xF8,0xFA,
/*U+0679*/  0x8A,0   ,0   ,0   ,0   ,0x81,0   ,0   ,0   ,0   ,0   ,0   ,
            0   ,0x8D,0   ,0x8F,
/*U+0691*/  0x9A,0   ,0   ,0   ,0   ,0   ,0   ,0x8E,
/*U+06A9*/  0x98,0   ,0   ,0   ,0   ,0   ,0x90,
/*U+06BA*/  0x9F,0   ,0   ,0   ,0xAA,0   ,0   ,0xC0,
/*U+06D2*/  0xFF,
/*U+200C*/  0x9D,0x9E,0xFD,0xFE,0   ,0   ,0   ,0x96,0x97,0   ,0   ,0   ,
            0x91,0x92,0x82,0   ,0x93,0x94,0x84,0   ,0x86,0x87,0x95,0   ,
            0   ,0   ,0x85,
/*U+2030*/  0x89,
/*U+2039*/  0x8B,0x9B,
/*U+20AC*/  0x80,
/*U+2122*/  0x99
};

/*********************************************************************
***                                                                ***
***                WINDOWS-CODEPAGE 1256 to UNICODE                ***
***                                                                ***
***                      Conversion table                          ***
***                                                                ***
*********************************************************************/
/** Windows-Codepage 1256 (Arabic) to unicode-codepoints conversion table */

static unsigned short usrg_tab_1256_to_uni[256] = {

/*          0      1      2      3      4      5      6      7     */
         0x0000,0x0001,0x0002,0x0003,0x0004,0x0005,0x0006,0x0007,  /* 0 1256 */

/*          8      9      A      B      C      D      E      F     */
         0x0008,0x0009,0x000A,0x000B,0x000C,0x000D,0x000E,0x000F,  /* 0      */

/*          0      1      2      3      4      5      6      7     */
         0x0010,0x0011,0x0012,0x0013,0x0014,0x0015,0x0016,0x0017,  /* 1      */

/*          8      9      A      B      C      D      E      F     */
         0x0018,0x0019,0x001A,0x001B,0x001C,0x001D,0x001E,0x001F,  /* 1      */

/*          0      1      2      3      4      5      6      7     */
         0x0020,0x0021,0x0022,0x0023,0x0024,0x0025,0x0026,0x0027,  /* 2      */

/*          8      9      A      B      C      D      E      F     */
         0x0028,0x0029,0x002A,0x002B,0x002C,0x002D,0x002E,0x002F,  /* 2      */

/*          0      1      2      3      4      5      6      7     */
         0x0030,0x0031,0x0032,0x0033,0x0034,0x0035,0x0036,0x0037,  /* 3      */

/*          8      9      A      B      C      D      E      F     */
         0x0038,0x0039,0x003A,0x003B,0x003C,0x003D,0x003E,0x003F,  /* 3      */

/*          0      1      2      3      4      5      6      7     */
         0x0040,0x0041,0x0042,0x0043,0x0044,0x0045,0x0046,0x0047,  /* 4      */

/*          8      9      A      B      C      D      E      F     */
         0x0048,0x0049,0x004A,0x004B,0x004C,0x004D,0x004E,0x004F,  /* 4      */

/*          0      1      2      3      4      5      6      7     */
         0x0050,0x0051,0x0052,0x0053,0x0054,0x0055,0x0056,0x0057,  /* 5      */

/*          8      9      A      B      C      D      E      F     */
         0x0058,0x0059,0x005A,0x005B,0x005C,0x005D,0x005E,0x005F,  /* 5      */

/*          0      1      2      3      4      5      6      7     */
         0x0060,0x0061,0x0062,0x0063,0x0064,0x0065,0x0066,0x0067,  /* 6 1256 */

/*          8      9      A      B      C      D      E      F     */
         0x0068,0x0069,0x006A,0x006B,0x006C,0x006D,0x006E,0x006F,  /* 6      */

/*          0      1      2      3      4      5      6      7     */
         0x0070,0x0071,0x0072,0x0073,0x0074,0x0075,0x0076,0x0077,  /* 7      */

/*          8      9      A      B      C      D      E      F     */
         0x0078,0x0079,0x007A,0x007B,0x007C,0x007D,0x007E,0x007F,  /* 7      */

/*          0      1      2      3      4      5      6      7     */
         0x20AC,0x067E,0x201A,0x0192,0x201E,0x2026,0x2020,0x2021,  /* 8      */

/*          8      9      A      B      C      D      E      F     */
         0x02C6,0x2030,0x0679,0x2039,0x0152,0x0686,0x0698,0x0688,  /* 8      */

/*          0      1      2      3      4      5      6      7     */
         0x06AF,0x2018,0x2019,0x201C,0x201D,0x2022,0x2013,0x2014,  /* 9      */

/*          8      9      A      B      C      D      E      F     */
         0x06A9,0x2122,0x0691,0x203A,0x0153,0x200C,0x200D,0x06BA,  /* 9      */

/*          0      1      2      3      4      5      6      7     */
         0x00A0,0x060C,0x00A2,0x00A3,0x00A4,0x00A5,0x00A6,0x00A7,  /* A      */

/*          8      9      A      B      C      D      E      F     */
         0x00A8,0x00A9,0x06BE,0x00AB,0x00AC,0x00AD,0x00AE,0x00AF,  /* A      */

/*          0      1      2      3      4      5      6      7     */
         0x00B0,0x00B1,0x00B2,0x00B3,0x00B4,0x00B5,0x00B6,0x00B7,  /* B      */

/*          8      9      A      B      C      D      E      F     */
         0x00B8,0x00B9,0x061B,0x00BB,0x00BC,0x00BD,0x00BE,0x061F,  /* B      */

/*          0      1      2      3      4      5      6      7     */
         0x06C1,0x0621,0x0622,0x0623,0x0624,0x0625,0x0626,0x0627,  /* C 1256 */

/*          8      9      A      B      C      D      E      F     */
         0x0628,0x0629,0x062A,0x062B,0x062C,0x062D,0x062E,0x062F,  /* C      */

/*          0      1      2      3      4      5      6      7     */
         0x0630,0x0631,0x0632,0x0633,0x0634,0x0635,0x0636,0x00D7,  /* D      */

/*          8      9      A      B      C      D      E      F     */
         0x0637,0x0638,0x0639,0x063A,0x0640,0x0641,0x0642,0x0643,  /* D      */

/*          0      1      2      3      4      5      6      7     */
         0x00E0,0x0644,0x00E2,0x0645,0x0646,0x0647,0x0648,0x00E7,  /* E      */

/*          8      9      A      B      C      D      E      F     */
         0x00E8,0x00E9,0x00EA,0x00EB,0x0649,0x064A,0x00EE,0x00EF,  /* E      */

/*          0      1      2      3      4      5      6      7     */
         0x064B,0x064C,0x064D,0x064E,0x00F4,0x064F,0x0650,0x00F7,  /* F      */

/*          8      9      A      B      C      D      E      F     */
         0x0651,0x00F9,0x0652,0x00FB,0x00FC,0x200E,0x200F,0x06D2   /* F      */
};

/*********************************************************************
***                                                                ***
***                UNICODE to WINDOWS-CODEPAGE 1257                ***
***                                                                ***
***                   Two-step-conversion tables                   ***
***                                                                ***
*********************************************************************/

/**
* Definition of the segments of table ucrg_tabparts_uni_to_1257 below.
* Same format as table unrg_tabindex_uni_to_437, see explanation there.
* Identity with unicode can be assumed for the first 128 codepoints (0 to 0x7F);
* no unicode codepoint from U+0080..U+009F can be expressed by this encoding.
*/
static unsigned int unrg_tabindex_uni_to_1257[34] = {
    0x00A0,   0,   0x0122, 122,   0x012A, 124,   0x0136, 130,
    0x014C, 147,   0x0156, 149,   0x016A, 161,   0x0172, 163,
    0x0179, 165,   0x02C7, 171,   0x02D9, 172,   0x2013, 175,
    0x2030, 195,   0x2039, 196,   0x20AC, 198,   0x2122, 199,
    0x2123, 200
};

/**
* Table for the second step, as explained for ucrg_tabparts_uni_to_437,
* for what enum-value ied_chs_wcp_1257 means (Baltic).
*/
static unsigned char ucrg_tabparts_uni_to_1257[200] = {
/*U+00A0*/  0xA0,0   ,0xA2,0xA3,0xA4,0   ,0xA6,0xA7,0x8D,0xA9,0   ,0xAB,
            0xAC,0xAD,0xAE,0x9D,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,
            0x8F,0xB9,0   ,0xBB,0xBC,0xBD,0xBE,0   ,0   ,0   ,0   ,0   ,
            0xC4,0xC5,0xAF,0   ,0   ,0xC9,0   ,0   ,0   ,0   ,0   ,0   ,
            0   ,0   ,0   ,0xD3,0   ,0xD5,0xD6,0xD7,0xA8,0   ,0   ,0   ,
            0xDC,0   ,0   ,0xDF,0   ,0   ,0   ,0   ,0xE4,0xE5,0xBF,0   ,
            0   ,0xE9,0   ,0   ,0   ,0   ,0   ,0   ,0   ,0   ,0   ,0xF3,
            0   ,0xF5,0xF6,0xF7,0xB8,0   ,0   ,0   ,0xFC,0   ,0   ,0   ,
            0xC2,0xE2,0   ,0   ,0xC0,0xE0,0xC3,0xE3,0   ,0   ,0   ,0   ,
            0xC8,0xE8,0   ,0   ,0   ,0   ,0xC7,0xE7,0   ,0   ,0xCB,0xEB,
            0xC6,0xE6,
/*U+0122*/  0xCC,0xEC,
/*U+012A*/  0xCE,0xEE,0   ,0   ,0xC1,0xE1,
/*U+0136*/  0xCD,0xED,0   ,0   ,0   ,0xCF,0xEF,0   ,0   ,0   ,0   ,0xD9,
            0xF9,0xD1,0xF1,0xD2,0xF2,
/*U+014C*/  0xD4,0xF4,
/*U+0156*/  0xAA,0xBA,0   ,0   ,0xDA,0xFA,0   ,0   ,0   ,0   ,0xD0,0xF0,
/*U+016A*/  0xDB,0xFB,
/*U+0172*/  0xD8,0xF8,
/*U+0179*/  0xCA,0xEA,0xDD,0xFD,0xDE,0xFE,
/*U+02C7*/  0x8E,
/*U+02D9*/  0xFF,0   ,0x9E,
/*U+2013*/  0x96,0x97,0   ,0   ,0   ,0x91,0x92,0x82,0   ,0x93,0x94,0x84,
            0   ,0x86,0x87,0x95,0   ,0   ,0   ,0x85,
/*U+2030*/  0x89,
/*U+2039*/  0x8B,0x9B,
/*U+20AC*/  0x80,
/*U+2122*/  0x99
};

/*********************************************************************
***                                                                ***
***                WINDOWS-CODEPAGE 1257 to UNICODE                ***
***                                                                ***
***                      Conversion table                          ***
***                                                                ***
*********************************************************************/
/** Windows-Codepage 1257 (Baltic) to unicode-codepoints conversion table */

static unsigned short usrg_tab_1257_to_uni[256] = {

/*          0      1      2      3      4      5      6      7     */
         0x0000,0x0001,0x0002,0x0003,0x0004,0x0005,0x0006,0x0007,  /* 0 1257 */

/*          8      9      A      B      C      D      E      F     */
         0x0008,0x0009,0x000A,0x000B,0x000C,0x000D,0x000E,0x000F,  /* 0      */

/*          0      1      2      3      4      5      6      7     */
         0x0010,0x0011,0x0012,0x0013,0x0014,0x0015,0x0016,0x0017,  /* 1      */

/*          8      9      A      B      C      D      E      F     */
         0x0018,0x0019,0x001A,0x001B,0x001C,0x001D,0x001E,0x001F,  /* 1      */

/*          0      1      2      3      4      5      6      7     */
         0x0020,0x0021,0x0022,0x0023,0x0024,0x0025,0x0026,0x0027,  /* 2      */

/*          8      9      A      B      C      D      E      F     */
         0x0028,0x0029,0x002A,0x002B,0x002C,0x002D,0x002E,0x002F,  /* 2      */

/*          0      1      2      3      4      5      6      7     */
         0x0030,0x0031,0x0032,0x0033,0x0034,0x0035,0x0036,0x0037,  /* 3      */

/*          8      9      A      B      C      D      E      F     */
         0x0038,0x0039,0x003A,0x003B,0x003C,0x003D,0x003E,0x003F,  /* 3      */

/*          0      1      2      3      4      5      6      7     */
         0x0040,0x0041,0x0042,0x0043,0x0044,0x0045,0x0046,0x0047,  /* 4      */

/*          8      9      A      B      C      D      E      F     */
         0x0048,0x0049,0x004A,0x004B,0x004C,0x004D,0x004E,0x004F,  /* 4      */

/*          0      1      2      3      4      5      6      7     */
         0x0050,0x0051,0x0052,0x0053,0x0054,0x0055,0x0056,0x0057,  /* 5      */

/*          8      9      A      B      C      D      E      F     */
         0x0058,0x0059,0x005A,0x005B,0x005C,0x005D,0x005E,0x005F,  /* 5      */

/*          0      1      2      3      4      5      6      7     */
         0x0060,0x0061,0x0062,0x0063,0x0064,0x0065,0x0066,0x0067,  /* 6 1257 */

/*          8      9      A      B      C      D      E      F     */
         0x0068,0x0069,0x006A,0x006B,0x006C,0x006D,0x006E,0x006F,  /* 6      */

/*          0      1      2      3      4      5      6      7     */
         0x0070,0x0071,0x0072,0x0073,0x0074,0x0075,0x0076,0x0077,  /* 7      */

/*          8      9      A      B      C      D      E      F     */
         0x0078,0x0079,0x007A,0x007B,0x007C,0x007D,0x007E,0x007F,  /* 7      */

/*          0      1      2      3      4      5      6      7     */
         0x20AC,0x0081,0x201A,0x0083,0x201E,0x2026,0x2020,0x2021,  /* 8      */

/*          8      9      A      B      C      D      E      F     */
         0x0088,0x2030,0x008A,0x2039,0x008C,0x00A8,0x02C7,0x00B8,  /* 8      */

/*          0      1      2      3      4      5      6      7     */
         0x0090,0x2018,0x2019,0x201C,0x201D,0x2022,0x2013,0x2014,  /* 9      */

/*          8      9      A      B      C      D      E      F     */
         0x0098,0x2122,0x009A,0x203A,0x009C,0x00AF,0x02DB,0x009F,  /* 9      */

/*          0      1      2      3      4      5      6      7     */
         0x00A0,0x00A1,0x00A2,0x00A3,0x00A4,0x00A5,0x00A6,0x00A7,  /* A      */

/*          8      9      A      B      C      D      E      F     */
         0x00D8,0x00A9,0x0156,0x00AB,0x00AC,0x00AD,0x00AE,0x00C6,  /* A      */

/*          0      1      2      3      4      5      6      7     */
         0x00B0,0x00B1,0x00B2,0x00B3,0x00B4,0x00B5,0x00B6,0x00B7,  /* B      */

/*          8      9      A      B      C      D      E      F     */
         0x00F8,0x00B9,0x0157,0x00BB,0x00BC,0x00BD,0x00BE,0x00E6,  /* B      */

/*          0      1      2      3      4      5      6      7     */
         0x0104,0x012E,0x0100,0x0106,0x00C4,0x00C5,0x0118,0x0112,  /* C 1257 */

/*          8      9      A      B      C      D      E      F     */
         0x010C,0x00C9,0x0179,0x0116,0x0122,0x0136,0x012A,0x013B,  /* C      */

/*          0      1      2      3      4      5      6      7     */
         0x0160,0x0143,0x0145,0x00D3,0x014C,0x00D5,0x00D6,0x00D7,  /* D      */

/*          8      9      A      B      C      D      E      F     */
         0x0172,0x0141,0x015A,0x016A,0x00DC,0x017B,0x017D,0x00DF,  /* D      */

/*          0      1      2      3      4      5      6      7     */
         0x0105,0x012F,0x0101,0x0107,0x00E4,0x00E5,0x0119,0x0113,  /* E      */

/*          8      9      A      B      C      D      E      F     */
         0x010D,0x00E9,0x017A,0x0117,0x0123,0x0137,0x012B,0x013C,  /* E      */

/*          0      1      2      3      4      5      6      7     */
         0x0161,0x0144,0x0146,0x00F3,0x014D,0x00F5,0x00F6,0x00F7,  /* F      */

/*          8      9      A      B      C      D      E      F     */
         0x0173,0x0142,0x015B,0x016B,0x00FC,0x017C,0x017E,0x02D9   /* F      */
};

/*********************************************************************
***                                                                ***
***                UNICODE to WINDOWS-CODEPAGE 1258                ***
***                                                                ***
***                   Two-step-conversion tables                   ***
***                                                                ***
*********************************************************************/

/**
* Definition of the segments of table ucrg_tabparts_uni_to_1258 below.
* Same format as table unrg_tabindex_uni_to_437, see explanation there.
* Identity with unicode can be assumed for the first 128 codepoints (0 to 0x7F);
* no unicode codepoint from U+0080..U+009F can be expressed by this encoding.
*/
static unsigned int unrg_tabindex_uni_to_1258[34] = {
    0x00A0,   0,   0x0110, 100,   0x0152, 102,   0x0178, 104,
    0x0192, 105,   0x01A0, 106,   0x01AF, 108,   0x02C6, 110,
    0x02DC, 111,   0x0300, 112,   0x0323, 122,   0x2013, 123,
    0x2030, 143,   0x2039, 144,   0x20AB, 146,   0x2122, 148,
    0x2123, 149
};

/**
* Table for the second step, as explained for ucrg_tabparts_uni_to_437,
* for what enum-value ied_chs_wcp_1258 means (Vietnamese).
*/
static unsigned char ucrg_tabparts_uni_to_1258[149] = {
/*U+00A0*/  0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,
            0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,
            0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF,0xC0,0xC1,0xC2,0   ,
            0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0   ,0xCD,0xCE,0xCF,
            0   ,0xD1,0   ,0xD3,0xD4,0   ,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,
            0xDC,0   ,0   ,0xDF,0xE0,0xE1,0xE2,0   ,0xE4,0xE5,0xE6,0xE7,
            0xE8,0xE9,0xEA,0xEB,0   ,0xED,0xEE,0xEF,0   ,0xF1,0   ,0xF3,
            0xF4,0   ,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0   ,0   ,0xFF,
            0   ,0   ,0xC3,0xE3,
/*U+0110*/  0xD0,0xF0,
/*U+0152*/  0x8C,0x9C,
/*U+0178*/  0x9F,
/*U+0192*/  0x83,
/*U+01A0*/  0xD5,0xF5,
/*U+01AF*/  0xDD,0xFD,
/*U+02C6*/  0x88,
/*U+02DC*/  0x98,
/*U+0300*/  0xCC,0xEC,0   ,0xDE,0   ,0   ,0   ,0   ,0   ,0xD2,
/*U+0323*/  0xF2,
/*U+2013*/  0x96,0x97,0   ,0   ,0   ,0x91,0x92,0x82,0   ,0x93,0x94,0x84,
            0   ,0x86,0x87,0x95,0   ,0   ,0   ,0x85,
/*U+2030*/  0x89,
/*U+2039*/  0x8B,0x9B,
/*U+20AB*/  0xFE,0x80,
/*U+2122*/  0x99
};

/*********************************************************************
***                                                                ***
***                WINDOWS-CODEPAGE 1258 to UNICODE                ***
***                                                                ***
***                      Conversion table                          ***
***                                                                ***
*********************************************************************/
/** Windows-Codepage 1258 (Vietnamese) to unicode-codepoints conversion table */

static unsigned short usrg_tab_1258_to_uni[256] = {

/*          0      1      2      3      4      5      6      7     */
         0x0000,0x0001,0x0002,0x0003,0x0004,0x0005,0x0006,0x0007,  /* 0 1258 */

/*          8      9      A      B      C      D      E      F     */
         0x0008,0x0009,0x000A,0x000B,0x000C,0x000D,0x000E,0x000F,  /* 0      */

/*          0      1      2      3      4      5      6      7     */
         0x0010,0x0011,0x0012,0x0013,0x0014,0x0015,0x0016,0x0017,  /* 1      */

/*          8      9      A      B      C      D      E      F     */
         0x0018,0x0019,0x001A,0x001B,0x001C,0x001D,0x001E,0x001F,  /* 1      */

/*          0      1      2      3      4      5      6      7     */
         0x0020,0x0021,0x0022,0x0023,0x0024,0x0025,0x0026,0x0027,  /* 2      */

/*          8      9      A      B      C      D      E      F     */
         0x0028,0x0029,0x002A,0x002B,0x002C,0x002D,0x002E,0x002F,  /* 2      */

/*          0      1      2      3      4      5      6      7     */
         0x0030,0x0031,0x0032,0x0033,0x0034,0x0035,0x0036,0x0037,  /* 3      */

/*          8      9      A      B      C      D      E      F     */
         0x0038,0x0039,0x003A,0x003B,0x003C,0x003D,0x003E,0x003F,  /* 3      */

/*          0      1      2      3      4      5      6      7     */
         0x0040,0x0041,0x0042,0x0043,0x0044,0x0045,0x0046,0x0047,  /* 4      */

/*          8      9      A      B      C      D      E      F     */
         0x0048,0x0049,0x004A,0x004B,0x004C,0x004D,0x004E,0x004F,  /* 4      */

/*          0      1      2      3      4      5      6      7     */
         0x0050,0x0051,0x0052,0x0053,0x0054,0x0055,0x0056,0x0057,  /* 5      */

/*          8      9      A      B      C      D      E      F     */
         0x0058,0x0059,0x005A,0x005B,0x005C,0x005D,0x005E,0x005F,  /* 5      */

/*          0      1      2      3      4      5      6      7     */
         0x0060,0x0061,0x0062,0x0063,0x0064,0x0065,0x0066,0x0067,  /* 6 1258 */

/*          8      9      A      B      C      D      E      F     */
         0x0068,0x0069,0x006A,0x006B,0x006C,0x006D,0x006E,0x006F,  /* 6      */

/*          0      1      2      3      4      5      6      7     */
         0x0070,0x0071,0x0072,0x0073,0x0074,0x0075,0x0076,0x0077,  /* 7      */

/*          8      9      A      B      C      D      E      F     */
         0x0078,0x0079,0x007A,0x007B,0x007C,0x007D,0x007E,0x007F,  /* 7      */

/*          0      1      2      3      4      5      6      7     */
         0x20AC,0x0081,0x201A,0x0192,0x201E,0x2026,0x2020,0x2021,  /* 8      */

/*          8      9      A      B      C      D      E      F     */
         0x02C6,0x2030,0x008A,0x2039,0x0152,0x008D,0x008E,0x008F,  /* 8      */

/*          0      1      2      3      4      5      6      7     */
         0x0090,0x2018,0x2019,0x201C,0x201D,0x2022,0x2013,0x2014,  /* 9      */

/*          8      9      A      B      C      D      E      F     */
         0x02DC,0x2122,0x009A,0x203A,0x0153,0x009D,0x009E,0x0178,  /* 9      */

/*          0      1      2      3      4      5      6      7     */
         0x00A0,0x00A1,0x00A2,0x00A3,0x00A4,0x00A5,0x00A6,0x00A7,  /* A      */

/*          8      9      A      B      C      D      E      F     */
         0x00A8,0x00A9,0x00AA,0x00AB,0x00AC,0x00AD,0x00AE,0x00AF,  /* A      */

/*          0      1      2      3      4      5      6      7     */
         0x00B0,0x00B1,0x00B2,0x00B3,0x00B4,0x00B5,0x00B6,0x00B7,  /* B      */

/*          8      9      A      B      C      D      E      F     */
         0x00B8,0x00B9,0x00BA,0x00BB,0x00BC,0x00BD,0x00BE,0x00BF,  /* B      */

/*          0      1      2      3      4      5      6      7     */
         0x00C0,0x00C1,0x00C2,0x0102,0x00C4,0x00C5,0x00C6,0x00C7,  /* C 1258 */

/*          8      9      A      B      C      D      E      F     */
         0x00C8,0x00C9,0x00CA,0x00CB,0x0300,0x00CD,0x00CE,0x00CF,  /* C      */

/*          0      1      2      3      4      5      6      7     */
         0x0110,0x00D1,0x0309,0x00D3,0x00D4,0x01A0,0x00D6,0x00D7,  /* D      */

/*          8      9      A      B      C      D      E      F     */
         0x00D8,0x00D9,0x00DA,0x00DB,0x00DC,0x01AF,0x0303,0x00DF,  /* D      */

/*          0      1      2      3      4      5      6      7     */
         0x00E0,0x00E1,0x00E2,0x0103,0x00E4,0x00E5,0x00E6,0x00E7,  /* E      */

/*          8      9      A      B      C      D      E      F     */
         0x00E8,0x00E9,0x00EA,0x00EB,0x0301,0x00ED,0x00EE,0x00EF,  /* E      */

/*          0      1      2      3      4      5      6      7     */
         0x0111,0x00F1,0x0323,0x00F3,0x00F4,0x01A1,0x00F6,0x00F7,  /* F      */

/*          8      9      A      B      C      D      E      F     */
         0x00F8,0x00F9,0x00FA,0x00FB,0x00FC,0x01B0,0x20AB,0x00FF   /* F      */
};

/*********************************************************************
***                                                                ***
***                UNICODE to WINDOWS-CODEPAGE 874                 ***
***                                                                ***
***                   Two-step-conversion tables                   ***
***                                                                ***
*********************************************************************/

/**
* Definition of the segments of table ucrg_tabparts_uni_to_874 below.
* Same format as table unrg_tabindex_uni_to_437, see explanation there.
* Identity with unicode can be assumed for the first 128 codepoints (0 to 0x7F);
* no unicode codepoint from U+0080..U+009F can be expressed by this encoding.
*/
static unsigned int unrg_tabindex_uni_to_874[18] = {
    0x00A0,   0,   0x0E01,   1,   0x0E3F,  59,   0x2013,  88,
    0x2018,  90,   0x2022,  96,   0x2026,  97,   0x20AC,  98,
    0x20AD,  99
};

/**
* Table for the second step, as explained for ucrg_tabparts_uni_to_437,
* for what enum-value ied_chs_wcp_874 means (Thai).
*/
static unsigned char ucrg_tabparts_uni_to_874[99] = {
/*U+00A0*/  0xA0,
/*U+0E01*/  0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,
            0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,
            0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF,0xC0,0xC1,0xC2,0xC3,0xC4,
            0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,
            0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,
/*U+0E3F*/  0xDF,0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,
            0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,
            0xF7,0xF8,0xF9,0xFA,0xFB,
/*U+2013*/  0x96,0x97,
/*U+2018*/  0x91,0x92,0   ,0   ,0x93,0x94,
/*U+2022*/  0x95,
/*U+2026*/  0x85,
/*U+20AC*/  0x80
};

/*********************************************************************
***                                                                ***
***                WINDOWS-CODEPAGE 874 to UNICODE                 ***
***                                                                ***
***                      Conversion table                          ***
***                                                                ***
*********************************************************************/
/** Windows-Codepage 437 (Thai) to unicode-codepoints conversion table */

static unsigned short usrg_tab_874_to_uni[256] = {

/*          0      1      2      3      4      5      6      7     */
         0x0000,0x0001,0x0002,0x0003,0x0004,0x0005,0x0006,0x0007,  /* 0  874 */

/*          8      9      A      B      C      D      E      F     */
         0x0008,0x0009,0x000A,0x000B,0x000C,0x000D,0x000E,0x000F,  /* 0      */

/*          0      1      2      3      4      5      6      7     */
         0x0010,0x0011,0x0012,0x0013,0x0014,0x0015,0x0016,0x0017,  /* 1      */

/*          8      9      A      B      C      D      E      F     */
         0x0018,0x0019,0x001A,0x001B,0x001C,0x001D,0x001E,0x001F,  /* 1      */

/*          0      1      2      3      4      5      6      7     */
         0x0020,0x0021,0x0022,0x0023,0x0024,0x0025,0x0026,0x0027,  /* 2      */

/*          8      9      A      B      C      D      E      F     */
         0x0028,0x0029,0x002A,0x002B,0x002C,0x002D,0x002E,0x002F,  /* 2      */

/*          0      1      2      3      4      5      6      7     */
         0x0030,0x0031,0x0032,0x0033,0x0034,0x0035,0x0036,0x0037,  /* 3      */

/*          8      9      A      B      C      D      E      F     */
         0x0038,0x0039,0x003A,0x003B,0x003C,0x003D,0x003E,0x003F,  /* 3      */

/*          0      1      2      3      4      5      6      7     */
         0x0040,0x0041,0x0042,0x0043,0x0044,0x0045,0x0046,0x0047,  /* 4      */

/*          8      9      A      B      C      D      E      F     */
         0x0048,0x0049,0x004A,0x004B,0x004C,0x004D,0x004E,0x004F,  /* 4      */

/*          0      1      2      3      4      5      6      7     */
         0x0050,0x0051,0x0052,0x0053,0x0054,0x0055,0x0056,0x0057,  /* 5      */

/*          8      9      A      B      C      D      E      F     */
         0x0058,0x0059,0x005A,0x005B,0x005C,0x005D,0x005E,0x005F,  /* 5      */

/*          0      1      2      3      4      5      6      7     */
         0x0060,0x0061,0x0062,0x0063,0x0064,0x0065,0x0066,0x0067,  /* 6  874 */

/*          8      9      A      B      C      D      E      F     */
         0x0068,0x0069,0x006A,0x006B,0x006C,0x006D,0x006E,0x006F,  /* 6      */

/*          0      1      2      3      4      5      6      7     */
         0x0070,0x0071,0x0072,0x0073,0x0074,0x0075,0x0076,0x0077,  /* 7      */

/*          8      9      A      B      C      D      E      F     */
         0x0078,0x0079,0x007A,0x007B,0x007C,0x007D,0x007E,0x007F,  /* 7      */

/*          0      1      2      3      4      5      6      7     */
         0x20AC,0x0081,0x0082,0x0083,0x0084,0x2026,0x0086,0x0087,  /* 8      */

/*          8      9      A      B      C      D      E      F     */
         0x0088,0x0089,0x008A,0x008B,0x008C,0x008D,0x008E,0x008F,  /* 8      */

/*          0      1      2      3      4      5      6      7     */
         0x0090,0x2018,0x2019,0x201C,0x201D,0x2022,0x2013,0x2014,  /* 9      */

/*          8      9      A      B      C      D      E      F     */
         0x0098,0x0099,0x009A,0x009B,0x009C,0x009D,0x009E,0x009F,  /* 9      */

/*          0      1      2      3      4      5      6      7     */
         0x00A0,0x0E01,0x0E02,0x0E03,0x0E04,0x0E05,0x0E06,0x0E07,  /* A      */

/*          8      9      A      B      C      D      E      F     */
         0x0E08,0x0E09,0x0E0A,0x0E0B,0x0E0C,0x0E0D,0x0E0E,0x0E0F,  /* A      */

/*          0      1      2      3      4      5      6      7     */
         0x0E10,0x0E11,0x0E12,0x0E13,0x0E14,0x0E15,0x0E16,0x0E17,  /* B      */

/*          8      9      A      B      C      D      E      F     */
         0x0E18,0x0E19,0x0E1A,0x0E1B,0x0E1C,0x0E1D,0x0E1E,0x0E1F,  /* B      */

/*          0      1      2      3      4      5      6      7     */
         0x0E20,0x0E21,0x0E22,0x0E23,0x0E24,0x0E25,0x0E26,0x0E27,  /* C  874 */

/*          8      9      A      B      C      D      E      F     */
         0x0E28,0x0E29,0x0E2A,0x0E2B,0x0E2C,0x0E2D,0x0E2E,0x0E2F,  /* C      */

/*          0      1      2      3      4      5      6      7     */
         0x0E30,0x0E31,0x0E32,0x0E33,0x0E34,0x0E35,0x0E36,0x0E37,  /* D      */

/*          8      9      A      B      C      D      E      F     */
         0x0E38,0x0E39,0x0E3A,0x00DB,0x00DC,0x00DD,0x00DE,0x0E3F,  /* D      */

/*          0      1      2      3      4      5      6      7     */
         0x0E40,0x0E41,0x0E42,0x0E43,0x0E44,0x0E45,0x0E46,0x0E47,  /* E      */

/*          8      9      A      B      C      D      E      F     */
         0x0E48,0x0E49,0x0E4A,0x0E4B,0x0E4C,0x0E4D,0x0E4E,0x0E4F,  /* E      */

/*          0      1      2      3      4      5      6      7     */
         0x0E50,0x0E51,0x0E52,0x0E53,0x0E54,0x0E55,0x0E56,0x0E57,  /* F      */

/*          8      9      A      B      C      D      E      F     */
         0x0E58,0x0E59,0x0E5A,0x0E5B,0x00FC,0x00FD,0x00FE,0x00FF   /* F      */
};

/*********************************************************************
***                                                                ***
***                UNICODE to ISO 8859-2 (LATIN-2)                 ***
***                                                                ***
***                   Two-step-conversion tables                   ***
***                                                                ***
*********************************************************************/

/**
* Definition of the segments of table ucrg_tabparts_uni_to_i02 below.
* Same format as table unrg_tabindex_uni_to_437, see explanation there.
* Identity with unicode can be assumed for the first 161 codepoins (0 to 0xA0).
*/
static unsigned int unrg_tabindex_uni_to_i02[18] = {
    0x00A0,   0,   0x0118, 114,   0x0139, 118,   0x0150, 134,
    0x016E, 156,   0x0179, 160,   0x02C7, 166,   0x02D8, 167,
    0x02DE, 173
};

/**
* Table for the second step, as explained for ucrg_tabparts_uni_to_437,
* for what enum-value ied_chs_iso8859_2 means (Latin2, Central European).
*/
static unsigned char ucrg_tabparts_uni_to_i02[173] = {
/*U+00A0*/  0xA0,0   ,0   ,0   ,0xA4,0   ,0   ,0xA7,0xA8,0   ,0   ,0   ,
            0   ,0xAD,0   ,0   ,0xB0,0   ,0   ,0   ,0xB4,0   ,0   ,0   ,
            0xB8,0   ,0   ,0   ,0   ,0   ,0   ,0   ,0   ,0xC1,0xC2,0   ,
            0xC4,0   ,0   ,0xC7,0   ,0xC9,0   ,0xCB,0   ,0xCD,0xCE,0   ,
            0   ,0   ,0   ,0xD3,0xD4,0   ,0xD6,0xD7,0   ,0   ,0xDA,0   ,
            0xDC,0xDD,0   ,0xDF,0   ,0xE1,0xE2,0   ,0xE4,0   ,0   ,0xE7,
            0   ,0xE9,0   ,0xEB,0   ,0xED,0xEE,0   ,0   ,0   ,0   ,0xF3,
            0xF4,0   ,0xF6,0xF7,0   ,0   ,0xFA,0   ,0xFC,0xFD,0   ,0   ,
            0   ,0   ,0xC3,0xE3,0xA1,0xB1,0xC6,0xE6,0   ,0   ,0   ,0   ,
            0xC8,0xE8,0xCF,0xEF,0xD0,0xF0,
/*U+0118*/  0xCA,0xEA,0xCC,0xEC,
/*U+0139*/  0xC5,0xE5,0   ,0   ,0xA5,0xB5,0   ,0   ,0xA3,0xB3,0xD1,0xF1,
            0   ,0   ,0xD2,0xF2,
/*U+0150*/  0xD5,0xF5,0   ,0   ,0xC0,0xE0,0   ,0   ,0xD8,0xF8,0xA6,0xB6,
            0   ,0   ,0xAA,0xBA,0xA9,0xB9,0xDE,0xFE,0xAB,0xBB,
/*U+016E*/  0xD9,0xF9,0xDB,0xFB,
/*U+0179*/  0xAC,0xBC,0xAF,0xBF,0xAE,0xBE,
/*U+02C7*/  0xB7,
/*U+02D8*/  0xA2,0xFF,0   ,0xB2,0   ,0xBD
};

/*********************************************************************
***                                                                ***
***                ISO 8859-2 (LATIN-2) to UNICODE                 ***
***                                                                ***
***                      Conversion table                          ***
***                                                                ***
*********************************************************************/
/** ISO-8859-2 (Latin2) to unicode-codepoints conversion table */

static unsigned short usrg_tab_i02_to_uni[256] = {

/*          0      1      2      3      4      5      6      7     */
         0x0000,0x0001,0x0002,0x0003,0x0004,0x0005,0x0006,0x0007,  /* 0 ISO2 */

/*          8      9      A      B      C      D      E      F     */
         0x0008,0x0009,0x000A,0x000B,0x000C,0x000D,0x000E,0x000F,  /* 0      */

/*          0      1      2      3      4      5      6      7     */
         0x0010,0x0011,0x0012,0x0013,0x0014,0x0015,0x0016,0x0017,  /* 1      */

/*          8      9      A      B      C      D      E      F     */
         0x0018,0x0019,0x001A,0x001B,0x001C,0x001D,0x001E,0x001F,  /* 1      */

/*          0      1      2      3      4      5      6      7     */
         0x0020,0x0021,0x0022,0x0023,0x0024,0x0025,0x0026,0x0027,  /* 2      */

/*          8      9      A      B      C      D      E      F     */
         0x0028,0x0029,0x002A,0x002B,0x002C,0x002D,0x002E,0x002F,  /* 2      */

/*          0      1      2      3      4      5      6      7     */
         0x0030,0x0031,0x0032,0x0033,0x0034,0x0035,0x0036,0x0037,  /* 3      */

/*          8      9      A      B      C      D      E      F     */
         0x0038,0x0039,0x003A,0x003B,0x003C,0x003D,0x003E,0x003F,  /* 3      */

/*          0      1      2      3      4      5      6      7     */
         0x0040,0x0041,0x0042,0x0043,0x0044,0x0045,0x0046,0x0047,  /* 4      */

/*          8      9      A      B      C      D      E      F     */
         0x0048,0x0049,0x004A,0x004B,0x004C,0x004D,0x004E,0x004F,  /* 4      */

/*          0      1      2      3      4      5      6      7     */
         0x0050,0x0051,0x0052,0x0053,0x0054,0x0055,0x0056,0x0057,  /* 5      */

/*          8      9      A      B      C      D      E      F     */
         0x0058,0x0059,0x005A,0x005B,0x005C,0x005D,0x005E,0x005F,  /* 5      */

/*          0      1      2      3      4      5      6      7     */
         0x0060,0x0061,0x0062,0x0063,0x0064,0x0065,0x0066,0x0067,  /* 6 ISO2 */

/*          8      9      A      B      C      D      E      F     */
         0x0068,0x0069,0x006A,0x006B,0x006C,0x006D,0x006E,0x006F,  /* 6      */

/*          0      1      2      3      4      5      6      7     */
         0x0070,0x0071,0x0072,0x0073,0x0074,0x0075,0x0076,0x0077,  /* 7      */

/*          8      9      A      B      C      D      E      F     */
         0x0078,0x0079,0x007A,0x007B,0x007C,0x007D,0x007E,0x007F,  /* 7      */

/*          0      1      2      3      4      5      6      7     */
         0x0080,0x0081,0x0082,0x0083,0x0084,0x0085,0x0086,0x0087,  /* 8      */

/*          8      9      A      B      C      D      E      F     */
         0x0088,0x0089,0x008A,0x008B,0x008C,0x008D,0x008E,0x008F,  /* 8      */

/*          0      1      2      3      4      5      6      7     */
         0x0090,0x0091,0x0092,0x0093,0x0094,0x0095,0x0096,0x0097,  /* 9      */

/*          8      9      A      B      C      D      E      F     */
         0x0098,0x0099,0x009A,0x009B,0x009C,0x009D,0x009E,0x009F,  /* 9      */

/*          0      1      2      3      4      5      6      7     */
         0x00A0,0x0104,0x02D8,0x0141,0x00A4,0x013D,0x015A,0x00A7,  /* A      */

/*          8      9      A      B      C      D      E      F     */
         0x00A8,0x0160,0x015E,0x0164,0x0179,0x00AD,0x017D,0x017B,  /* A      */

/*          0      1      2      3      4      5      6      7     */
         0x00B0,0x0105,0x02DB,0x0142,0x00B4,0x013E,0x015B,0x02C7,  /* B      */

/*          8      9      A      B      C      D      E      F     */
         0x00B8,0x0161,0x015F,0x0165,0x017A,0x02DD,0x017E,0x017C,  /* B      */

/*          0      1      2      3      4      5      6      7     */
         0x0154,0x00C1,0x00C2,0x0102,0x00C4,0x0139,0x0106,0x00C7,  /* C ISO2 */

/*          8      9      A      B      C      D      E      F     */
         0x010C,0x00C9,0x0118,0x00CB,0x011A,0x00CD,0x00CE,0x010E,  /* C      */

/*          0      1      2      3      4      5      6      7     */
         0x0110,0x0143,0x0147,0x00D3,0x00D4,0x0150,0x00D6,0x00D7,  /* D      */

/*          8      9      A      B      C      D      E      F     */
         0x0158,0x016E,0x00DA,0x0170,0x00DC,0x00DD,0x0162,0x00DF,  /* D      */

/*          0      1      2      3      4      5      6      7     */
         0x0155,0x00E1,0x00E2,0x0103,0x00E4,0x013A,0x0107,0x00E7,  /* E      */

/*          8      9      A      B      C      D      E      F     */
         0x010D,0x00E9,0x0119,0x00EB,0x011B,0x00ED,0x00EE,0x010F,  /* E      */

/*          0      1      2      3      4      5      6      7     */
         0x0111,0x0144,0x0148,0x00F3,0x00F4,0x0151,0x00F6,0x00F7,  /* F      */

/*          8      9      A      B      C      D      E      F     */
         0x0159,0x016F,0x00FA,0x0171,0x00FC,0x00FD,0x0163,0x02D9   /* F      */
};

/*********************************************************************
***                                                                ***
***                UNICODE to ISO 8859-3 (LATIN-3)                 ***
***                                                                ***
***                   Two-step-conversion tables                   ***
***                                                                ***
*********************************************************************/

/**
* Definition of the segments of table ucrg_tabparts_uni_to_i03 below.
* Same format as table unrg_tabindex_uni_to_437, see explanation there.
* Identity with unicode can be assumed for the first 161 codepoins (0 to 0xA0).
*/
static unsigned int unrg_tabindex_uni_to_i03[18] = {
    0x00A0,   0,   0x0108,  93,   0x011C,  97,   0x0130, 109,
    0x015C, 115,   0x016C, 119,   0x017B, 121,   0x02D8, 123,
    0x02DA, 125
};

/**
* Table for the second step, as explained for ucrg_tabparts_uni_to_437,
* for what enum-value ied_chs_iso8859_3 means (Latin3, Maltese and Esperanto).
*/
static unsigned char ucrg_tabparts_uni_to_i03[125] = {
/*U+00A0*/  0xA0,0   ,0   ,0xA3,0xA4,0   ,0   ,0xA7,0xA8,0   ,0   ,0   ,
            0   ,0xAD,0   ,0   ,0xB0,0   ,0xB2,0xB3,0xB4,0xB5,0   ,0xB7,
            0xB8,0   ,0   ,0   ,0   ,0xBD,0   ,0   ,0xC0,0xC1,0xC2,0   ,
            0xC4,0   ,0   ,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,
            0   ,0xD1,0xD2,0xD3,0xD4,0   ,0xD6,0xD7,0   ,0xD9,0xDA,0xDB,
            0xDC,0   ,0   ,0xDF,0xE0,0xE1,0xE2,0   ,0xE4,0   ,0   ,0xE7,
            0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0   ,0xF1,0xF2,0xF3,
            0xF4,0   ,0xF6,0xF7,0   ,0xF9,0xFA,0xFB,0xFC,
/*U+0108*/  0xC6,0xE6,0xC5,0xE5,
/*U+011C*/  0xD8,0xF8,0xAB,0xBB,0xD5,0xF5,0   ,0   ,0xA6,0xB6,0xA1,0xB1,
/*U+0130*/  0xA9,0xB9,0   ,0   ,0xAC,0xBC,
/*U+015C*/  0xDE,0xFE,0xAA,0xBA,
/*U+016C*/  0xDD,0xFD,
/*U+017B*/  0xAF,0xBF,
/*U+02D8*/  0xA2,0xFF
};

/*********************************************************************
***                                                                ***
***                ISO 8859-3 (LATIN-3) to UNICODE                 ***
***                                                                ***
***                      Conversion table                          ***
***                                                                ***
*********************************************************************/
/** ISO-8859-3 (Latin3) to unicode-codepoints conversion table */

static unsigned short usrg_tab_i03_to_uni[256] = {

/*          0      1      2      3      4      5      6      7     */
         0x0000,0x0001,0x0002,0x0003,0x0004,0x0005,0x0006,0x0007,  /* 0 ISO3 */

/*          8      9      A      B      C      D      E      F     */
         0x0008,0x0009,0x000A,0x000B,0x000C,0x000D,0x000E,0x000F,  /* 0      */

/*          0      1      2      3      4      5      6      7     */
         0x0010,0x0011,0x0012,0x0013,0x0014,0x0015,0x0016,0x0017,  /* 1      */

/*          8      9      A      B      C      D      E      F     */
         0x0018,0x0019,0x001A,0x001B,0x001C,0x001D,0x001E,0x001F,  /* 1      */

/*          0      1      2      3      4      5      6      7     */
         0x0020,0x0021,0x0022,0x0023,0x0024,0x0025,0x0026,0x0027,  /* 2      */

/*          8      9      A      B      C      D      E      F     */
         0x0028,0x0029,0x002A,0x002B,0x002C,0x002D,0x002E,0x002F,  /* 2      */

/*          0      1      2      3      4      5      6      7     */
         0x0030,0x0031,0x0032,0x0033,0x0034,0x0035,0x0036,0x0037,  /* 3      */

/*          8      9      A      B      C      D      E      F     */
         0x0038,0x0039,0x003A,0x003B,0x003C,0x003D,0x003E,0x003F,  /* 3      */

/*          0      1      2      3      4      5      6      7     */
         0x0040,0x0041,0x0042,0x0043,0x0044,0x0045,0x0046,0x0047,  /* 4      */

/*          8      9      A      B      C      D      E      F     */
         0x0048,0x0049,0x004A,0x004B,0x004C,0x004D,0x004E,0x004F,  /* 4      */

/*          0      1      2      3      4      5      6      7     */
         0x0050,0x0051,0x0052,0x0053,0x0054,0x0055,0x0056,0x0057,  /* 5      */

/*          8      9      A      B      C      D      E      F     */
         0x0058,0x0059,0x005A,0x005B,0x005C,0x005D,0x005E,0x005F,  /* 5      */

/*          0      1      2      3      4      5      6      7     */
         0x0060,0x0061,0x0062,0x0063,0x0064,0x0065,0x0066,0x0067,  /* 6 ISO3 */

/*          8      9      A      B      C      D      E      F     */
         0x0068,0x0069,0x006A,0x006B,0x006C,0x006D,0x006E,0x006F,  /* 6      */

/*          0      1      2      3      4      5      6      7     */
         0x0070,0x0071,0x0072,0x0073,0x0074,0x0075,0x0076,0x0077,  /* 7      */

/*          8      9      A      B      C      D      E      F     */
         0x0078,0x0079,0x007A,0x007B,0x007C,0x007D,0x007E,0x007F,  /* 7      */

/*          0      1      2      3      4      5      6      7     */
         0x0080,0x0081,0x0082,0x0083,0x0084,0x0085,0x0086,0x0087,  /* 8      */

/*          8      9      A      B      C      D      E      F     */
         0x0088,0x0089,0x008A,0x008B,0x008C,0x008D,0x008E,0x008F,  /* 8      */

/*          0      1      2      3      4      5      6      7     */
         0x0090,0x0091,0x0092,0x0093,0x0094,0x0095,0x0096,0x0097,  /* 9      */

/*          8      9      A      B      C      D      E      F     */
         0x0098,0x0099,0x009A,0x009B,0x009C,0x009D,0x009E,0x009F,  /* 9      */

/*          0      1      2      3      4      5      6      7     */
         0x00A0,0x0126,0x02D8,0x00A3,0x00A4,0x00A5,0x0124,0x00A7,  /* A      */

/*          8      9      A      B      C      D      E      F     */
         0x00A8,0x0130,0x015E,0x011E,0x0134,0x00AD,0x00AE,0x017B,  /* A      */

/*          0      1      2      3      4      5      6      7     */
         0x00B0,0x0127,0x00B2,0x00B3,0x00B4,0x00B5,0x0125,0x00B7,  /* B      */

/*          8      9      A      B      C      D      E      F     */
         0x00B8,0x0131,0x015F,0x011F,0x0135,0x00BD,0x00BE,0x017C,  /* B      */

/*          0      1      2      3      4      5      6      7     */
         0x00C0,0x00C1,0x00C2,0x00C3,0x00C4,0x010A,0x0108,0x00C7,  /* C ISO3 */

/*          8      9      A      B      C      D      E      F     */
         0x00C8,0x00C9,0x00CA,0x00CB,0x00CC,0x00CD,0x00CE,0x00CF,  /* C      */

/*          0      1      2      3      4      5      6      7     */
         0x00D0,0x00D1,0x00D2,0x00D3,0x00D4,0x0120,0x00D6,0x00D7,  /* D      */

/*          8      9      A      B      C      D      E      F     */
         0x011C,0x00D9,0x00DA,0x00DB,0x00DC,0x016C,0x015C,0x00DF,  /* D      */

/*          0      1      2      3      4      5      6      7     */
         0x00E0,0x00E1,0x00E2,0x00E3,0x00E4,0x010B,0x0109,0x00E7,  /* E      */

/*          8      9      A      B      C      D      E      F     */
         0x00E8,0x00E9,0x00EA,0x00EB,0x00EC,0x00ED,0x00EE,0x00EF,  /* E      */

/*          0      1      2      3      4      5      6      7     */
         0x00F0,0x00F1,0x00F2,0x00F3,0x00F4,0x0121,0x00F6,0x00F7,  /* F      */

/*          8      9      A      B      C      D      E      F     */
         0x011D,0x00F9,0x00FA,0x00FB,0x00FC,0x016D,0x015D,0x02D9   /* F      */
};

/*********************************************************************
***                                                                ***
***                UNICODE to ISO 8859-4 (LATIN-4)                 ***
***                                                                ***
***                   Two-step-conversion tables                   ***
***                                                                ***
*********************************************************************/

/**
* Definition of the segments of table ucrg_tabparts_uni_to_i04 below.
* Same format as table unrg_tabindex_uni_to_437, see explanation there.
* Identity with unicode can be assumed for the first 161 codepoins (0 to 0xA0).
*/
static unsigned int unrg_tabindex_uni_to_i04[18] = {
    0x00A0,   0,   0x0122, 122,   0x0145, 149,   0x0156, 158,
    0x0160, 160,   0x017D, 180,   0x02C7, 182,   0x02D9, 183,
    0x02DC, 186
};

/**
* Table for the second step, as explained for ucrg_tabparts_uni_to_437,
* for what enum-value ied_chs_iso8859_4 means (Latin4, North European/ Baltic).
*/
static unsigned char ucrg_tabparts_uni_to_i04[186] = {
/*U+00A0*/  0xA0,0   ,0   ,0   ,0xA4,0   ,0   ,0xA7,0xA8,0   ,0   ,0   ,
            0   ,0xAD,0   ,0xAF,0xB0,0   ,0   ,0   ,0xB4,0   ,0   ,0   ,
            0xB8,0   ,0   ,0   ,0   ,0   ,0   ,0   ,0   ,0xC1,0xC2,0xC3,
            0xC4,0xC5,0xC6,0   ,0   ,0xC9,0   ,0xCB,0   ,0xCD,0xCE,0   ,
            0   ,0   ,0   ,0   ,0xD4,0xD5,0xD6,0xD7,0xD8,0   ,0xDA,0xDB,
            0xDC,0   ,0   ,0xDF,0   ,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0   ,
            0   ,0xE9,0   ,0xEB,0   ,0xED,0xEE,0   ,0   ,0   ,0   ,0   ,
            0xF4,0xF5,0xF6,0xF7,0xF8,0   ,0xFA,0xFB,0xFC,0   ,0   ,0   ,
            0xC0,0xE0,0   ,0   ,0xA1,0xB1,0   ,0   ,0   ,0   ,0   ,0   ,
            0xC8,0xE8,0   ,0   ,0xD0,0xF0,0xAA,0xBA,0   ,0   ,0xCC,0xEC,
            0xCA,0xEA,
/*U+0122*/  0xAB,0xBB,0   ,0   ,0   ,0   ,0xA5,0xB5,0xCF,0xEF,0   ,0   ,
            0xC7,0xE7,0   ,0   ,0   ,0   ,0   ,0   ,0xD3,0xF3,0xA2,0   ,
            0   ,0xA6,0xB6,
/*U+0145*/  0xD1,0xF1,0   ,0   ,0   ,0xBD,0xBF,0xD2,0xF2,
/*U+0156*/  0xA3,0xB3,
/*U+0160*/  0xA9,0xB9,0   ,0   ,0   ,0   ,0xAC,0xBC,0xDD,0xFD,0xDE,0xFE,
            0   ,0   ,0   ,0   ,0   ,0   ,0xD9,0xF9,
/*U+017D*/  0xAE,0xBE,
/*U+02C7*/  0xB7,
/*U+02D9*/  0xFF,0   ,0xB2
};

/*********************************************************************
***                                                                ***
***                ISO 8859-4 (LATIN-4) to UNICODE                 ***
***                                                                ***
***                      Conversion table                          ***
***                                                                ***
*********************************************************************/
/** ISO-8859-4 (Latin4) to unicode-codepoints conversion table */

static unsigned short usrg_tab_i04_to_uni[256] = {

/*          0      1      2      3      4      5      6      7     */
         0x0000,0x0001,0x0002,0x0003,0x0004,0x0005,0x0006,0x0007,  /* 0 ISO4 */

/*          8      9      A      B      C      D      E      F     */
         0x0008,0x0009,0x000A,0x000B,0x000C,0x000D,0x000E,0x000F,  /* 0      */

/*          0      1      2      3      4      5      6      7     */
         0x0010,0x0011,0x0012,0x0013,0x0014,0x0015,0x0016,0x0017,  /* 1      */

/*          8      9      A      B      C      D      E      F     */
         0x0018,0x0019,0x001A,0x001B,0x001C,0x001D,0x001E,0x001F,  /* 1      */

/*          0      1      2      3      4      5      6      7     */
         0x0020,0x0021,0x0022,0x0023,0x0024,0x0025,0x0026,0x0027,  /* 2      */

/*          8      9      A      B      C      D      E      F     */
         0x0028,0x0029,0x002A,0x002B,0x002C,0x002D,0x002E,0x002F,  /* 2      */

/*          0      1      2      3      4      5      6      7     */
         0x0030,0x0031,0x0032,0x0033,0x0034,0x0035,0x0036,0x0037,  /* 3      */

/*          8      9      A      B      C      D      E      F     */
         0x0038,0x0039,0x003A,0x003B,0x003C,0x003D,0x003E,0x003F,  /* 3      */

/*          0      1      2      3      4      5      6      7     */
         0x0040,0x0041,0x0042,0x0043,0x0044,0x0045,0x0046,0x0047,  /* 4      */

/*          8      9      A      B      C      D      E      F     */
         0x0048,0x0049,0x004A,0x004B,0x004C,0x004D,0x004E,0x004F,  /* 4      */

/*          0      1      2      3      4      5      6      7     */
         0x0050,0x0051,0x0052,0x0053,0x0054,0x0055,0x0056,0x0057,  /* 5      */

/*          8      9      A      B      C      D      E      F     */
         0x0058,0x0059,0x005A,0x005B,0x005C,0x005D,0x005E,0x005F,  /* 5      */

/*          0      1      2      3      4      5      6      7     */
         0x0060,0x0061,0x0062,0x0063,0x0064,0x0065,0x0066,0x0067,  /* 6 ISO4 */

/*          8      9      A      B      C      D      E      F     */
         0x0068,0x0069,0x006A,0x006B,0x006C,0x006D,0x006E,0x006F,  /* 6      */

/*          0      1      2      3      4      5      6      7     */
         0x0070,0x0071,0x0072,0x0073,0x0074,0x0075,0x0076,0x0077,  /* 7      */

/*          8      9      A      B      C      D      E      F     */
         0x0078,0x0079,0x007A,0x007B,0x007C,0x007D,0x007E,0x007F,  /* 7      */

/*          0      1      2      3      4      5      6      7     */
         0x0080,0x0081,0x0082,0x0083,0x0084,0x0085,0x0086,0x0087,  /* 8      */

/*          8      9      A      B      C      D      E      F     */
         0x0088,0x0089,0x008A,0x008B,0x008C,0x008D,0x008E,0x008F,  /* 8      */

/*          0      1      2      3      4      5      6      7     */
         0x0090,0x0091,0x0092,0x0093,0x0094,0x0095,0x0096,0x0097,  /* 9      */

/*          8      9      A      B      C      D      E      F     */
         0x0098,0x0099,0x009A,0x009B,0x009C,0x009D,0x009E,0x009F,  /* 9      */

/*          0      1      2      3      4      5      6      7     */
         0x00A0,0x0104,0x0138,0x0156,0x00A4,0x0128,0x013B,0x00A7,  /* A      */

/*          8      9      A      B      C      D      E      F     */
         0x00A8,0x0160,0x0112,0x0122,0x0166,0x00AD,0x017D,0x00AF,  /* A      */

/*          0      1      2      3      4      5      6      7     */
         0x00B0,0x0105,0x02DB,0x0157,0x00B4,0x0129,0x013C,0x02C7,  /* B      */

/*          8      9      A      B      C      D      E      F     */
         0x00B8,0x0161,0x0113,0x0123,0x0167,0x014A,0x017E,0x014B,  /* B      */

/*          0      1      2      3      4      5      6      7     */
         0x0100,0x00C1,0x00C2,0x00C3,0x00C4,0x00C5,0x00C6,0x012E,  /* C ISO4 */

/*          8      9      A      B      C      D      E      F     */
         0x010C,0x00C9,0x0118,0x00CB,0x0116,0x00CD,0x00CE,0x012A,  /* C      */

/*          0      1      2      3      4      5      6      7     */
         0x0110,0x0145,0x014C,0x0136,0x00D4,0x00D5,0x00D6,0x00D7,  /* D      */

/*          8      9      A      B      C      D      E      F     */
         0x00D8,0x0172,0x00DA,0x00DB,0x00DC,0x0168,0x016A,0x00DF,  /* D      */

/*          0      1      2      3      4      5      6      7     */
         0x0101,0x00E1,0x00E2,0x00E3,0x00E4,0x00E5,0x00E6,0x012F,  /* E      */

/*          8      9      A      B      C      D      E      F     */
         0x010D,0x00E9,0x0119,0x00EB,0x0117,0x00ED,0x00EE,0x012B,  /* E      */

/*          0      1      2      3      4      5      6      7     */
         0x0111,0x0146,0x014D,0x0137,0x00F4,0x00F5,0x00F6,0x00F7,  /* F      */

/*          8      9      A      B      C      D      E      F     */
         0x00F8,0x0173,0x00FA,0x00FB,0x00FC,0x0169,0x016B,0x02D9   /* F      */
};

/*********************************************************************
***                                                                ***
***                    UNICODE to ISO 8859-5                       ***
***                                                                ***
***                   Two-step-conversion tables                   ***
***                                                                ***
*********************************************************************/

/**
* Definition of the segments of table ucrg_tabparts_uni_to_i05 below.
* Same format as table unrg_tabindex_uni_to_437, see explanation there.
* Identity with unicode can be assumed for the first 161 codepoins (0 to 0xA0).
*/
static unsigned int unrg_tabindex_uni_to_i05[8] = {
    0x00A0,   0,   0x0401,  14,   0x2116, 109,   0x2117, 110
};

/**
* Table for the second step, as explained for ucrg_tabparts_uni_to_437,
* for what enum-value ied_chs_iso8859_5 means (Cyrillic).
*/
static unsigned char ucrg_tabparts_uni_to_i05[110] = {
/*U+00A0*/  0xA0,0   ,0   ,0   ,0   ,0   ,0   ,0xFD,0   ,0   ,0   ,0   ,
            0   ,0xAD,
/*U+0401*/  0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,
            0   ,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,
            0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF,0xC0,0xC1,0xC2,0xC3,0xC4,
            0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,
            0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,
            0xDD,0xDE,0xDF,0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,
            0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0   ,0xF1,0xF2,0xF3,0xF4,
            0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0   ,0xFE,0xFF,
/*U+2116*/  0xF0
};

/*********************************************************************
***                                                                ***
***                    ISO 8859-5 to UNICODE                       ***
***                                                                ***
***                      Conversion table                          ***
***                                                                ***
*********************************************************************/
/** ISO-8859-5 (Cyrillic) to unicode-codepoints conversion table */

static unsigned short usrg_tab_i05_to_uni[256] = {

/*          0      1      2      3      4      5      6      7     */
         0x0000,0x0001,0x0002,0x0003,0x0004,0x0005,0x0006,0x0007,  /* 0 ISO5 */

/*          8      9      A      B      C      D      E      F     */
         0x0008,0x0009,0x000A,0x000B,0x000C,0x000D,0x000E,0x000F,  /* 0      */

/*          0      1      2      3      4      5      6      7     */
         0x0010,0x0011,0x0012,0x0013,0x0014,0x0015,0x0016,0x0017,  /* 1      */

/*          8      9      A      B      C      D      E      F     */
         0x0018,0x0019,0x001A,0x001B,0x001C,0x001D,0x001E,0x001F,  /* 1      */

/*          0      1      2      3      4      5      6      7     */
         0x0020,0x0021,0x0022,0x0023,0x0024,0x0025,0x0026,0x0027,  /* 2      */

/*          8      9      A      B      C      D      E      F     */
         0x0028,0x0029,0x002A,0x002B,0x002C,0x002D,0x002E,0x002F,  /* 2      */

/*          0      1      2      3      4      5      6      7     */
         0x0030,0x0031,0x0032,0x0033,0x0034,0x0035,0x0036,0x0037,  /* 3      */

/*          8      9      A      B      C      D      E      F     */
         0x0038,0x0039,0x003A,0x003B,0x003C,0x003D,0x003E,0x003F,  /* 3      */

/*          0      1      2      3      4      5      6      7     */
         0x0040,0x0041,0x0042,0x0043,0x0044,0x0045,0x0046,0x0047,  /* 4      */

/*          8      9      A      B      C      D      E      F     */
         0x0048,0x0049,0x004A,0x004B,0x004C,0x004D,0x004E,0x004F,  /* 4      */

/*          0      1      2      3      4      5      6      7     */
         0x0050,0x0051,0x0052,0x0053,0x0054,0x0055,0x0056,0x0057,  /* 5      */

/*          8      9      A      B      C      D      E      F     */
         0x0058,0x0059,0x005A,0x005B,0x005C,0x005D,0x005E,0x005F,  /* 5      */

/*          0      1      2      3      4      5      6      7     */
         0x0060,0x0061,0x0062,0x0063,0x0064,0x0065,0x0066,0x0067,  /* 6 ISO5 */

/*          8      9      A      B      C      D      E      F     */
         0x0068,0x0069,0x006A,0x006B,0x006C,0x006D,0x006E,0x006F,  /* 6      */

/*          0      1      2      3      4      5      6      7     */
         0x0070,0x0071,0x0072,0x0073,0x0074,0x0075,0x0076,0x0077,  /* 7      */

/*          8      9      A      B      C      D      E      F     */
         0x0078,0x0079,0x007A,0x007B,0x007C,0x007D,0x007E,0x007F,  /* 7      */

/*          0      1      2      3      4      5      6      7     */
         0x0080,0x0081,0x0082,0x0083,0x0084,0x0085,0x0086,0x0087,  /* 8      */

/*          8      9      A      B      C      D      E      F     */
         0x0088,0x0089,0x008A,0x008B,0x008C,0x008D,0x008E,0x008F,  /* 8      */

/*          0      1      2      3      4      5      6      7     */
         0x0090,0x0091,0x0092,0x0093,0x0094,0x0095,0x0096,0x0097,  /* 9      */

/*          8      9      A      B      C      D      E      F     */
         0x0098,0x0099,0x009A,0x009B,0x009C,0x009D,0x009E,0x009F,  /* 9      */

/*          0      1      2      3      4      5      6      7     */
         0x00A0,0x0401,0x0402,0x0403,0x0404,0x0405,0x0406,0x0407,  /* A      */

/*          8      9      A      B      C      D      E      F     */
         0x0408,0x0409,0x040A,0x040B,0x040C,0x00AD,0x040E,0x040F,  /* A      */

/*          0      1      2      3      4      5      6      7     */
         0x0410,0x0411,0x0412,0x0413,0x0414,0x0415,0x0416,0x0417,  /* B      */

/*          8      9      A      B      C      D      E      F     */
         0x0418,0x0419,0x041A,0x041B,0x041C,0x041D,0x041E,0x041F,  /* B      */

/*          0      1      2      3      4      5      6      7     */
         0x0420,0x0421,0x0422,0x0423,0x0424,0x0425,0x0426,0x0427,  /* C ISO5 */

/*          8      9      A      B      C      D      E      F     */
         0x0428,0x0429,0x042A,0x042B,0x042C,0x042D,0x042E,0x042F,  /* C      */

/*          0      1      2      3      4      5      6      7     */
         0x0430,0x0431,0x0432,0x0433,0x0434,0x0435,0x0436,0x0437,  /* D      */

/*          8      9      A      B      C      D      E      F     */
         0x0438,0x0439,0x043A,0x043B,0x043C,0x043D,0x043E,0x043F,  /* D      */

/*          0      1      2      3      4      5      6      7     */
         0x0440,0x0441,0x0442,0x0443,0x0444,0x0445,0x0446,0x0447,  /* E      */

/*          8      9      A      B      C      D      E      F     */
         0x0448,0x0449,0x044A,0x044B,0x044C,0x044D,0x044E,0x044F,  /* E      */

/*          0      1      2      3      4      5      6      7     */
         0x2116,0x0451,0x0452,0x0453,0x0454,0x0455,0x0456,0x0457,  /* F      */

/*          8      9      A      B      C      D      E      F     */
         0x0458,0x0459,0x045A,0x045B,0x045C,0x00A7,0x045E,0x045F   /* F      */
};

/*********************************************************************
***                                                                ***
***                    UNICODE to ISO 8859-6                       ***
***                                                                ***
***                   Two-step-conversion tables                   ***
***                                                                ***
*********************************************************************/

/**
* Definition of the segments of table ucrg_tabparts_uni_to_i06 below.
* Same format as table unrg_tabindex_uni_to_437, see explanation there.
* Identity with unicode can be assumed for the first 161 codepoins (0 to 0xA0).
*/
static unsigned int unrg_tabindex_uni_to_i06[12] = {
    0x00A0,   0,   0x060C,  14,   0x061B,  15,   0x061F,  16,
    0x0640,  44,   0x0653,  63
};

/**
* Table for the second step, as explained for ucrg_tabparts_uni_to_437,
* for what enum-value ied_chs_iso8859_6 means (Arabic).
*/
static unsigned char ucrg_tabparts_uni_to_i06[63] = {
/*U+00A0*/  0xA0,0   ,0   ,0   ,0xA4,0   ,0   ,0   ,0   ,0   ,0   ,0   ,
            0   ,0xAD,
/*U+060C*/  0xAC,
/*U+061B*/  0xBB,
/*U+061F*/  0xBF,0   ,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,
            0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,
            0xD7,0xD8,0xD9,0xDA,
/*U+0640*/  0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,
            0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2
};

/*********************************************************************
***                                                                ***
***                    ISO 8859-6 to UNICODE                       ***
***                                                                ***
***                      Conversion table                          ***
***                                                                ***
*********************************************************************/
/** ISO-8859-6 (Arabic) to unicode-codepoints conversion table */

static unsigned short usrg_tab_i06_to_uni[256] = {

/*          0      1      2      3      4      5      6      7     */
         0x0000,0x0001,0x0002,0x0003,0x0004,0x0005,0x0006,0x0007,  /* 0 ISO6 */

/*          8      9      A      B      C      D      E      F     */
         0x0008,0x0009,0x000A,0x000B,0x000C,0x000D,0x000E,0x000F,  /* 0      */

/*          0      1      2      3      4      5      6      7     */
         0x0010,0x0011,0x0012,0x0013,0x0014,0x0015,0x0016,0x0017,  /* 1      */

/*          8      9      A      B      C      D      E      F     */
         0x0018,0x0019,0x001A,0x001B,0x001C,0x001D,0x001E,0x001F,  /* 1      */

/*          0      1      2      3      4      5      6      7     */
         0x0020,0x0021,0x0022,0x0023,0x0024,0x0025,0x0026,0x0027,  /* 2      */

/*          8      9      A      B      C      D      E      F     */
         0x0028,0x0029,0x002A,0x002B,0x002C,0x002D,0x002E,0x002F,  /* 2      */

/*          0      1      2      3      4      5      6      7     */
         0x0030,0x0031,0x0032,0x0033,0x0034,0x0035,0x0036,0x0037,  /* 3      */

/*          8      9      A      B      C      D      E      F     */
         0x0038,0x0039,0x003A,0x003B,0x003C,0x003D,0x003E,0x003F,  /* 3      */

/*          0      1      2      3      4      5      6      7     */
         0x0040,0x0041,0x0042,0x0043,0x0044,0x0045,0x0046,0x0047,  /* 4      */

/*          8      9      A      B      C      D      E      F     */
         0x0048,0x0049,0x004A,0x004B,0x004C,0x004D,0x004E,0x004F,  /* 4      */

/*          0      1      2      3      4      5      6      7     */
         0x0050,0x0051,0x0052,0x0053,0x0054,0x0055,0x0056,0x0057,  /* 5      */

/*          8      9      A      B      C      D      E      F     */
         0x0058,0x0059,0x005A,0x005B,0x005C,0x005D,0x005E,0x005F,  /* 5      */

/*          0      1      2      3      4      5      6      7     */
         0x0060,0x0061,0x0062,0x0063,0x0064,0x0065,0x0066,0x0067,  /* 6 ISO6 */

/*          8      9      A      B      C      D      E      F     */
         0x0068,0x0069,0x006A,0x006B,0x006C,0x006D,0x006E,0x006F,  /* 6      */

/*          0      1      2      3      4      5      6      7     */
         0x0070,0x0071,0x0072,0x0073,0x0074,0x0075,0x0076,0x0077,  /* 7      */

/*          8      9      A      B      C      D      E      F     */
         0x0078,0x0079,0x007A,0x007B,0x007C,0x007D,0x007E,0x007F,  /* 7      */

/*          0      1      2      3      4      5      6      7     */
         0x0080,0x0081,0x0082,0x0083,0x0084,0x0085,0x0086,0x0087,  /* 8      */

/*          8      9      A      B      C      D      E      F     */
         0x0088,0x0089,0x008A,0x008B,0x008C,0x008D,0x008E,0x008F,  /* 8      */

/*          0      1      2      3      4      5      6      7     */
         0x0090,0x0091,0x0092,0x0093,0x0094,0x0095,0x0096,0x0097,  /* 9      */

/*          8      9      A      B      C      D      E      F     */
         0x0098,0x0099,0x009A,0x009B,0x009C,0x009D,0x009E,0x009F,  /* 9      */

/*          0      1      2      3      4      5      6      7     */
         0x00A0,0x00A1,0x00A2,0x00A3,0x00A4,0x00A5,0x00A6,0x00A7,  /* A      */

/*          8      9      A      B      C      D      E      F     */
         0x00A8,0x00A9,0x00AA,0x00AB,0x060C,0x00AD,0x00AE,0x00AF,  /* A      */

/*          0      1      2      3      4      5      6      7     */
         0x00B0,0x00B1,0x00B2,0x00B3,0x00B4,0x00B5,0x00B6,0x00B7,  /* B      */

/*          8      9      A      B      C      D      E      F     */
         0x00B8,0x00B9,0x00BA,0x061B,0x00BC,0x00BD,0x00BE,0x061F,  /* B      */

/*          0      1      2      3      4      5      6      7     */
         0x00C0,0x0621,0x0622,0x0623,0x0624,0x0625,0x0626,0x0627,  /* C ISO6 */

/*          8      9      A      B      C      D      E      F     */
         0x0628,0x0629,0x062A,0x062B,0x062C,0x062D,0x062E,0x062F,  /* C      */

/*          0      1      2      3      4      5      6      7     */
         0x0630,0x0631,0x0632,0x0633,0x0634,0x0635,0x0636,0x0637,  /* D      */

/*          8      9      A      B      C      D      E      F     */
         0x0638,0x0639,0x063A,0x00DB,0x00DC,0x00DD,0x00DE,0x00DF,  /* D      */

/*          0      1      2      3      4      5      6      7     */
         0x0640,0x0641,0x0642,0x0643,0x0644,0x0645,0x0646,0x0647,  /* E      */

/*          8      9      A      B      C      D      E      F     */
         0x0648,0x0649,0x064A,0x064B,0x064C,0x064D,0x064E,0x064F,  /* E      */

/*          0      1      2      3      4      5      6      7     */
         0x0650,0x0651,0x0652,0x00F3,0x00F4,0x00F5,0x00F6,0x00F7,  /* F      */

/*          8      9      A      B      C      D      E      F     */
         0x00F8,0x00F9,0x00FA,0x00FB,0x00FC,0x00FD,0x00FE,0x00FF   /* F      */
};

/*********************************************************************
***                                                                ***
***                    UNICODE to ISO 8859-7                       ***
***                                                                ***
***                   Two-step-conversion tables                   ***
***                                                                ***
*********************************************************************/

/**
* Definition of the segments of table ucrg_tabparts_uni_to_i07 below.
* Same format as table unrg_tabindex_uni_to_437, see explanation there.
* Identity with unicode can be assumed for the first 161 codepoins (0 to 0xA0).
*/
static unsigned int unrg_tabindex_uni_to_i07[12] = {
    0x00A0,   0,   0x037A,  30,   0x0384,  31,   0x2015, 106,
    0x20AC, 111,   0x20B0, 115
};

/**
* Table for the second step, as explained for ucrg_tabparts_uni_to_437,
* for what enum-value ied_chs_iso8859_7 means (Greek).
*/
static unsigned char ucrg_tabparts_uni_to_i07[115] = {
/*U+00A0*/  0xA0,0   ,0   ,0xA3,0   ,0   ,0xA6,0xA7,0xA8,0xA9,0   ,0xAB,
            0xAC,0xAD,0   ,0   ,0xB0,0xB1,0xB2,0xB3,0   ,0   ,0   ,0xB7,
            0   ,0   ,0   ,0xBB,0   ,0xBD,
/*U+037A*/  0xAA,
/*U+0384*/  0xB4,0xB5,0xB6,0   ,0xB8,0xB9,0xBA,0   ,0xBC,0   ,0xBE,0xBF,
            0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,
            0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0   ,0xD3,0xD4,0xD5,0xD6,0xD7,
            0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF,0xE0,0xE1,0xE2,0xE3,
            0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,
            0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,
            0xFC,0xFD,0xFE,
/*U+2015*/  0xAF,0   ,0   ,0xA1,0xA2,
/*U+20AC*/  0xA4,0   ,0   ,0xA5
};

/*********************************************************************
***                                                                ***
***                    ISO 8859-7 to UNICODE                       ***
***                                                                ***
***                      Conversion table                          ***
***                                                                ***
*********************************************************************/
/** ISO-8859-7 (Greek) to unicode-codepoints conversion table */

static unsigned short usrg_tab_i07_to_uni[256] = {

/*          0      1      2      3      4      5      6      7     */
         0x0000,0x0001,0x0002,0x0003,0x0004,0x0005,0x0006,0x0007,  /* 0 ISO7 */

/*          8      9      A      B      C      D      E      F     */
         0x0008,0x0009,0x000A,0x000B,0x000C,0x000D,0x000E,0x000F,  /* 0      */

/*          0      1      2      3      4      5      6      7     */
         0x0010,0x0011,0x0012,0x0013,0x0014,0x0015,0x0016,0x0017,  /* 1      */

/*          8      9      A      B      C      D      E      F     */
         0x0018,0x0019,0x001A,0x001B,0x001C,0x001D,0x001E,0x001F,  /* 1      */

/*          0      1      2      3      4      5      6      7     */
         0x0020,0x0021,0x0022,0x0023,0x0024,0x0025,0x0026,0x0027,  /* 2      */

/*          8      9      A      B      C      D      E      F     */
         0x0028,0x0029,0x002A,0x002B,0x002C,0x002D,0x002E,0x002F,  /* 2      */

/*          0      1      2      3      4      5      6      7     */
         0x0030,0x0031,0x0032,0x0033,0x0034,0x0035,0x0036,0x0037,  /* 3      */

/*          8      9      A      B      C      D      E      F     */
         0x0038,0x0039,0x003A,0x003B,0x003C,0x003D,0x003E,0x003F,  /* 3      */

/*          0      1      2      3      4      5      6      7     */
         0x0040,0x0041,0x0042,0x0043,0x0044,0x0045,0x0046,0x0047,  /* 4      */

/*          8      9      A      B      C      D      E      F     */
         0x0048,0x0049,0x004A,0x004B,0x004C,0x004D,0x004E,0x004F,  /* 4      */

/*          0      1      2      3      4      5      6      7     */
         0x0050,0x0051,0x0052,0x0053,0x0054,0x0055,0x0056,0x0057,  /* 5      */

/*          8      9      A      B      C      D      E      F     */
         0x0058,0x0059,0x005A,0x005B,0x005C,0x005D,0x005E,0x005F,  /* 5      */

/*          0      1      2      3      4      5      6      7     */
         0x0060,0x0061,0x0062,0x0063,0x0064,0x0065,0x0066,0x0067,  /* 6 ISO7 */

/*          8      9      A      B      C      D      E      F     */
         0x0068,0x0069,0x006A,0x006B,0x006C,0x006D,0x006E,0x006F,  /* 6      */

/*          0      1      2      3      4      5      6      7     */
         0x0070,0x0071,0x0072,0x0073,0x0074,0x0075,0x0076,0x0077,  /* 7      */

/*          8      9      A      B      C      D      E      F     */
         0x0078,0x0079,0x007A,0x007B,0x007C,0x007D,0x007E,0x007F,  /* 7      */

/*          0      1      2      3      4      5      6      7     */
         0x0080,0x0081,0x0082,0x0083,0x0084,0x0085,0x0086,0x0087,  /* 8      */

/*          8      9      A      B      C      D      E      F     */
         0x0088,0x0089,0x008A,0x008B,0x008C,0x008D,0x008E,0x008F,  /* 8      */

/*          0      1      2      3      4      5      6      7     */
         0x0090,0x0091,0x0092,0x0093,0x0094,0x0095,0x0096,0x0097,  /* 9      */

/*          8      9      A      B      C      D      E      F     */
         0x0098,0x0099,0x009A,0x009B,0x009C,0x009D,0x009E,0x009F,  /* 9      */

/*          0      1      2      3      4      5      6      7     */
         0x00A0,0x2018,0x2019,0x00A3,0x20AC,0x20AF,0x00A6,0x00A7,  /* A      */

/*          8      9      A      B      C      D      E      F     */
         0x00A8,0x00A9,0x037A,0x00AB,0x00AC,0x00AD,0x00AE,0x2015,  /* A      */

/*          0      1      2      3      4      5      6      7     */
         0x00B0,0x00B1,0x00B2,0x00B3,0x0384,0x0385,0x0386,0x00B7,  /* B      */

/*          8      9      A      B      C      D      E      F     */
         0x0388,0x0389,0x038A,0x00BB,0x038C,0x00BD,0x038E,0x038F,  /* B      */

/*          0      1      2      3      4      5      6      7     */
         0x0390,0x0391,0x0392,0x0393,0x0394,0x0395,0x0396,0x0397,  /* C ISO7 */

/*          8      9      A      B      C      D      E      F     */
         0x0398,0x0399,0x039A,0x039B,0x039C,0x039D,0x039E,0x039F,  /* C      */

/*          0      1      2      3      4      5      6      7     */
         0x03A0,0x03A1,0x00D2,0x03A3,0x03A4,0x03A5,0x03A6,0x03A7,  /* D      */

/*          8      9      A      B      C      D      E      F     */
         0x03A8,0x03A9,0x03AA,0x03AB,0x03AC,0x03AD,0x03AE,0x03AF,  /* D      */

/*          0      1      2      3      4      5      6      7     */
         0x03B0,0x03B1,0x03B2,0x03B3,0x03B4,0x03B5,0x03B6,0x03B7,  /* E      */

/*          8      9      A      B      C      D      E      F     */
         0x03B8,0x03B9,0x03BA,0x03BB,0x03BC,0x03BD,0x03BE,0x03BF,  /* E      */

/*          0      1      2      3      4      5      6      7     */
         0x03C0,0x03C1,0x03C2,0x03C3,0x03C4,0x03C5,0x03C6,0x03C7,  /* F      */

/*          8      9      A      B      C      D      E      F     */
         0x03C8,0x03C9,0x03CA,0x03CB,0x03CC,0x03CD,0x03CE,0x00FF   /* F      */
};

/*********************************************************************
***                                                                ***
***                    UNICODE to ISO 8859-8                       ***
***                                                                ***
***                   Two-step-conversion tables                   ***
***                                                                ***
*********************************************************************/

/**
* Definition of the segments of table ucrg_tabparts_uni_to_i08 below.
* Same format as table unrg_tabindex_uni_to_437, see explanation there.
* Identity with unicode can be assumed for the first 161 codepoins (0 to 0xA0).
*
* Note that the last pair was listed twice to be able to use an
* already-existing helper function without going out-of-bounds.
*/
static unsigned int unrg_tabindex_uni_to_i08[12] = {
    0x00A0,   0,   0x05D0,  88,   0x200E, 115,   0x2017, 117,
    0x2018, 118,   0x2018, 118
};

/**
* Table for the second step, as explained for ucrg_tabparts_uni_to_437,
* for what enum-value ied_chs_iso8859_8 means (Hebrew).
*/
static unsigned char ucrg_tabparts_uni_to_i08[118] = {
/*U+00A0*/  0xA0,0   ,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0   ,0xAB,
            0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,
            0xB8,0xB9,0   ,0xBB,0xBC,0xBD,0xBE,0   ,0   ,0   ,0   ,0   ,
            0   ,0   ,0   ,0   ,0   ,0   ,0   ,0   ,0   ,0   ,0   ,0   ,
            0   ,0   ,0   ,0   ,0   ,0   ,0   ,0xAA,0   ,0   ,0   ,0   ,
            0   ,0   ,0   ,0   ,0   ,0   ,0   ,0   ,0   ,0   ,0   ,0   ,
            0   ,0   ,0   ,0   ,0   ,0   ,0   ,0   ,0   ,0   ,0   ,0   ,
            0   ,0   ,0   ,0xBA,
/*U+05D0*/  0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,
            0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,
            0xF8,0xF9,0xFA,
/*U+200E*/  0xFD,0xFE,
/*U+2017*/  0xDF
};

/*********************************************************************
***                                                                ***
***                    ISO 8859-8 to UNICODE                       ***
***                                                                ***
***                      Conversion table                          ***
***                                                                ***
*********************************************************************/
/** ISO-8859-8 (Hebrew) to unicode-codepoints conversion table */

static unsigned short usrg_tab_i08_to_uni[256] = {

/*          0      1      2      3      4      5      6      7     */
         0x0000,0x0001,0x0002,0x0003,0x0004,0x0005,0x0006,0x0007,  /* 0 ISO8 */

/*          8      9      A      B      C      D      E      F     */
         0x0008,0x0009,0x000A,0x000B,0x000C,0x000D,0x000E,0x000F,  /* 0      */

/*          0      1      2      3      4      5      6      7     */
         0x0010,0x0011,0x0012,0x0013,0x0014,0x0015,0x0016,0x0017,  /* 1      */

/*          8      9      A      B      C      D      E      F     */
         0x0018,0x0019,0x001A,0x001B,0x001C,0x001D,0x001E,0x001F,  /* 1      */

/*          0      1      2      3      4      5      6      7     */
         0x0020,0x0021,0x0022,0x0023,0x0024,0x0025,0x0026,0x0027,  /* 2      */

/*          8      9      A      B      C      D      E      F     */
         0x0028,0x0029,0x002A,0x002B,0x002C,0x002D,0x002E,0x002F,  /* 2      */

/*          0      1      2      3      4      5      6      7     */
         0x0030,0x0031,0x0032,0x0033,0x0034,0x0035,0x0036,0x0037,  /* 3      */

/*          8      9      A      B      C      D      E      F     */
         0x0038,0x0039,0x003A,0x003B,0x003C,0x003D,0x003E,0x003F,  /* 3      */

/*          0      1      2      3      4      5      6      7     */
         0x0040,0x0041,0x0042,0x0043,0x0044,0x0045,0x0046,0x0047,  /* 4      */

/*          8      9      A      B      C      D      E      F     */
         0x0048,0x0049,0x004A,0x004B,0x004C,0x004D,0x004E,0x004F,  /* 4      */

/*          0      1      2      3      4      5      6      7     */
         0x0050,0x0051,0x0052,0x0053,0x0054,0x0055,0x0056,0x0057,  /* 5      */

/*          8      9      A      B      C      D      E      F     */
         0x0058,0x0059,0x005A,0x005B,0x005C,0x005D,0x005E,0x005F,  /* 5      */

/*          0      1      2      3      4      5      6      7     */
         0x0060,0x0061,0x0062,0x0063,0x0064,0x0065,0x0066,0x0067,  /* 6 ISO8 */

/*          8      9      A      B      C      D      E      F     */
         0x0068,0x0069,0x006A,0x006B,0x006C,0x006D,0x006E,0x006F,  /* 6      */

/*          0      1      2      3      4      5      6      7     */
         0x0070,0x0071,0x0072,0x0073,0x0074,0x0075,0x0076,0x0077,  /* 7      */

/*          8      9      A      B      C      D      E      F     */
         0x0078,0x0079,0x007A,0x007B,0x007C,0x007D,0x007E,0x007F,  /* 7      */

/*          0      1      2      3      4      5      6      7     */
         0x0080,0x0081,0x0082,0x0083,0x0084,0x0085,0x0086,0x0087,  /* 8      */

/*          8      9      A      B      C      D      E      F     */
         0x0088,0x0089,0x008A,0x008B,0x008C,0x008D,0x008E,0x008F,  /* 8      */

/*          0      1      2      3      4      5      6      7     */
         0x0090,0x0091,0x0092,0x0093,0x0094,0x0095,0x0096,0x0097,  /* 9      */

/*          8      9      A      B      C      D      E      F     */
         0x0098,0x0099,0x009A,0x009B,0x009C,0x009D,0x009E,0x009F,  /* 9      */

/*          0      1      2      3      4      5      6      7     */
         0x00A0,0x00A1,0x00A2,0x00A3,0x00A4,0x00A5,0x00A6,0x00A7,  /* A      */

/*          8      9      A      B      C      D      E      F     */
         0x00A8,0x00A9,0x00D7,0x00AB,0x00AC,0x00AD,0x00AE,0x00AF,  /* A      */

/*          0      1      2      3      4      5      6      7     */
         0x00B0,0x00B1,0x00B2,0x00B3,0x00B4,0x00B5,0x00B6,0x00B7,  /* B      */

/*          8      9      A      B      C      D      E      F     */
         0x00B8,0x00B9,0x00F7,0x00BB,0x00BC,0x00BD,0x00BE,0x00BF,  /* B      */

/*          0      1      2      3      4      5      6      7     */
         0x00C0,0x00C1,0x00C2,0x00C3,0x00C4,0x00C5,0x00C6,0x00C7,  /* C ISO8 */

/*          8      9      A      B      C      D      E      F     */
         0x00C8,0x00C9,0x00CA,0x00CB,0x00CC,0x00CD,0x00CE,0x00CF,  /* C      */

/*          0      1      2      3      4      5      6      7     */
         0x00D0,0x00D1,0x00D2,0x00D3,0x00D4,0x00D5,0x00D6,0x00D7,  /* D      */

/*          8      9      A      B      C      D      E      F     */
         0x00D8,0x00D9,0x00DA,0x00DB,0x00DC,0x00DD,0x00DE,0x2017,  /* D      */

/*          0      1      2      3      4      5      6      7     */
         0x05D0,0x05D1,0x05D2,0x05D3,0x05D4,0x05D5,0x05D6,0x05D7,  /* E      */

/*          8      9      A      B      C      D      E      F     */
         0x05D8,0x05D9,0x05DA,0x05DB,0x05DC,0x05DD,0x05DE,0x05DF,  /* E      */

/*          0      1      2      3      4      5      6      7     */
         0x05E0,0x05E1,0x05E2,0x05E3,0x05E4,0x05E5,0x05E6,0x05E7,  /* F      */

/*          8      9      A      B      C      D      E      F     */
         0x05E8,0x05E9,0x05EA,0x00FB,0x00FC,0x200E,0x200F,0x00FF   /* F      */
};

/*********************************************************************
***                                                                ***
***                UNICODE to ISO 8859-9 (LATIN-5)                 ***
***                                                                ***
***                   Two-step-conversion tables                   ***
***                                                                ***
*********************************************************************/

/**
* Definition of the segments of table ucrg_tabparts_uni_to_i09 below.
* Same format as table unrg_tabindex_uni_to_437, see explanation there.
* Identity with unicode can be assumed for the first 161 codepoins (0 to 0xA0).
*
* Note that the last pair was listed twice to be able to use an
* already-existing helper function without going out-of-bounds.
*/
static unsigned int unrg_tabindex_uni_to_i09[12] = {
    0x00A0,   0,   0x011E,  96,   0x0130,  98,   0x015E, 100,
    0x0160, 102,   0x0160, 102
};

/**
* Table for the second step, as explained for ucrg_tabparts_uni_to_437,
* for what enum-value ied_chs_iso8859_9 means (Latin5, Turkish).
*/
static unsigned char ucrg_tabparts_uni_to_i09[102] = {
/*U+00A0*/  0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,
            0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,
            0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF,0xC0,0xC1,0xC2,0xC3,
            0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,
            0   ,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,
            0xDC,0   ,0   ,0xDF,0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,
            0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0   ,0xF1,0xF2,0xF3,
            0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0   ,0   ,0xFF,
/*U+011E*/  0xD0,0xF0,
/*U+0130*/  0xDD,0xFD,
/*U+015E*/  0xDE,0xFE
};

/*********************************************************************
***                                                                ***
***                ISO 8859-9 (LATIN-5) to UNICODE                 ***
***                                                                ***
***                      Conversion table                          ***
***                                                                ***
*********************************************************************/
/** ISO-8859-9 (Latin5) to unicode-codepoints conversion table */

static unsigned short usrg_tab_i09_to_uni[256] = {

/*          0      1      2      3      4      5      6      7     */
         0x0000,0x0001,0x0002,0x0003,0x0004,0x0005,0x0006,0x0007,  /* 0 ISO9 */

/*          8      9      A      B      C      D      E      F     */
         0x0008,0x0009,0x000A,0x000B,0x000C,0x000D,0x000E,0x000F,  /* 0      */

/*          0      1      2      3      4      5      6      7     */
         0x0010,0x0011,0x0012,0x0013,0x0014,0x0015,0x0016,0x0017,  /* 1      */

/*          8      9      A      B      C      D      E      F     */
         0x0018,0x0019,0x001A,0x001B,0x001C,0x001D,0x001E,0x001F,  /* 1      */

/*          0      1      2      3      4      5      6      7     */
         0x0020,0x0021,0x0022,0x0023,0x0024,0x0025,0x0026,0x0027,  /* 2      */

/*          8      9      A      B      C      D      E      F     */
         0x0028,0x0029,0x002A,0x002B,0x002C,0x002D,0x002E,0x002F,  /* 2      */

/*          0      1      2      3      4      5      6      7     */
         0x0030,0x0031,0x0032,0x0033,0x0034,0x0035,0x0036,0x0037,  /* 3      */

/*          8      9      A      B      C      D      E      F     */
         0x0038,0x0039,0x003A,0x003B,0x003C,0x003D,0x003E,0x003F,  /* 3      */

/*          0      1      2      3      4      5      6      7     */
         0x0040,0x0041,0x0042,0x0043,0x0044,0x0045,0x0046,0x0047,  /* 4      */

/*          8      9      A      B      C      D      E      F     */
         0x0048,0x0049,0x004A,0x004B,0x004C,0x004D,0x004E,0x004F,  /* 4      */

/*          0      1      2      3      4      5      6      7     */
         0x0050,0x0051,0x0052,0x0053,0x0054,0x0055,0x0056,0x0057,  /* 5      */

/*          8      9      A      B      C      D      E      F     */
         0x0058,0x0059,0x005A,0x005B,0x005C,0x005D,0x005E,0x005F,  /* 5      */

/*          0      1      2      3      4      5      6      7     */
         0x0060,0x0061,0x0062,0x0063,0x0064,0x0065,0x0066,0x0067,  /* 6 ISO9 */

/*          8      9      A      B      C      D      E      F     */
         0x0068,0x0069,0x006A,0x006B,0x006C,0x006D,0x006E,0x006F,  /* 6      */

/*          0      1      2      3      4      5      6      7     */
         0x0070,0x0071,0x0072,0x0073,0x0074,0x0075,0x0076,0x0077,  /* 7      */

/*          8      9      A      B      C      D      E      F     */
         0x0078,0x0079,0x007A,0x007B,0x007C,0x007D,0x007E,0x007F,  /* 7      */

/*          0      1      2      3      4      5      6      7     */
         0x0080,0x0081,0x0082,0x0083,0x0084,0x0085,0x0086,0x0087,  /* 8      */

/*          8      9      A      B      C      D      E      F     */
         0x0088,0x0089,0x008A,0x008B,0x008C,0x008D,0x008E,0x008F,  /* 8      */

/*          0      1      2      3      4      5      6      7     */
         0x0090,0x0091,0x0092,0x0093,0x0094,0x0095,0x0096,0x0097,  /* 9      */

/*          8      9      A      B      C      D      E      F     */
         0x0098,0x0099,0x009A,0x009B,0x009C,0x009D,0x009E,0x009F,  /* 9      */

/*          0      1      2      3      4      5      6      7     */
         0x00A0,0x00A1,0x00A2,0x00A3,0x00A4,0x00A5,0x00A6,0x00A7,  /* A      */

/*          8      9      A      B      C      D      E      F     */
         0x00A8,0x00A9,0x00AA,0x00AB,0x00AC,0x00AD,0x00AE,0x00AF,  /* A      */

/*          0      1      2      3      4      5      6      7     */
         0x00B0,0x00B1,0x00B2,0x00B3,0x00B4,0x00B5,0x00B6,0x00B7,  /* B      */

/*          8      9      A      B      C      D      E      F     */
         0x00B8,0x00B9,0x00BA,0x00BB,0x00BC,0x00BD,0x00BE,0x00BF,  /* B      */

/*          0      1      2      3      4      5      6      7     */
         0x00C0,0x00C1,0x00C2,0x00C3,0x00C4,0x00C5,0x00C6,0x00C7,  /* C ISO9 */

/*          8      9      A      B      C      D      E      F     */
         0x00C8,0x00C9,0x00CA,0x00CB,0x00CC,0x00CD,0x00CE,0x00CF,  /* C      */

/*          0      1      2      3      4      5      6      7     */
         0x011E,0x00D1,0x00D2,0x00D3,0x00D4,0x00D5,0x00D6,0x00D7,  /* D      */

/*          8      9      A      B      C      D      E      F     */
         0x00D8,0x00D9,0x00DA,0x00DB,0x00DC,0x0130,0x015E,0x00DF,  /* D      */

/*          0      1      2      3      4      5      6      7     */
         0x00E0,0x00E1,0x00E2,0x00E3,0x00E4,0x00E5,0x00E6,0x00E7,  /* E      */

/*          8      9      A      B      C      D      E      F     */
         0x00E8,0x00E9,0x00EA,0x00EB,0x00EC,0x00ED,0x00EE,0x00EF,  /* E      */

/*          0      1      2      3      4      5      6      7     */
         0x011F,0x00F1,0x00F2,0x00F3,0x00F4,0x00F5,0x00F6,0x00F7,  /* F      */

/*          8      9      A      B      C      D      E      F     */
         0x00F8,0x00F9,0x00FA,0x00FB,0x00FC,0x0131,0x015F,0x00FF   /* F      */
};

/*********************************************************************
***                                                                ***
***                UNICODE to ISO 8859-10 (LATIN-6)                ***
***                                                                ***
***                   Two-step-conversion tables                   ***
***                                                                ***
*********************************************************************/

/**
* Definition of the segments of table ucrg_tabparts_uni_to_i10 below.
* Same format as table unrg_tabindex_uni_to_437, see explanation there.
* Identity with unicode can be assumed for the first 161 codepoins (0 to 0xA0).
*/
static unsigned int unrg_tabindex_uni_to_i10[18] = {
    0x00A0,   0,   0x010C, 102,   0x0122, 116,   0x0136, 130,
    0x0145, 137,   0x0160, 146,   0x017D, 166,   0x2015, 168,
    0x2016, 169
};

/**
* Table for the second step, as explained for ucrg_tabparts_uni_to_437,
* for what enum-value ied_chs_iso8859_10 means (Latin6, Nordic).
*/
static unsigned char ucrg_tabparts_uni_to_i10[169] = {
/*U+00A0*/  0xA0,0   ,0   ,0   ,0   ,0   ,0   ,0xA7,0   ,0   ,0   ,0   ,
            0   ,0xAD,0   ,0   ,0xB0,0   ,0   ,0   ,0   ,0   ,0   ,0xB7,
            0   ,0   ,0   ,0   ,0   ,0   ,0   ,0   ,0   ,0xC1,0xC2,0xC3,
            0xC4,0xC5,0xC6,0   ,0   ,0xC9,0   ,0xCB,0   ,0xCD,0xCE,0xCF,
            0xD0,0   ,0   ,0xD3,0xD4,0xD5,0xD6,0   ,0xD8,0   ,0xDA,0xDB,
            0xDC,0xDD,0xDE,0xDF,0   ,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0   ,
            0   ,0xE9,0   ,0xEB,0   ,0xED,0xEE,0xEF,0xF0,0   ,0   ,0xF3,
            0xF4,0xF5,0xF6,0   ,0xF8,0   ,0xFA,0xFB,0xFC,0xFD,0xFE,0   ,
            0xC0,0xE0,0   ,0   ,0xA1,0xB1,
/*U+010C*/  0xC8,0xE8,0   ,0   ,0xA9,0xB9,0xA2,0xB2,0   ,0   ,0xCC,0xEC,
            0xCA,0xEA,
/*U+0122*/  0xA3,0xB3,0   ,0   ,0   ,0   ,0xA5,0xB5,0xA4,0xB4,0   ,0   ,
            0xC7,0xE7,
/*U+0136*/  0xA6,0xB6,0xFF,0   ,0   ,0xA8,0xB8,
/*U+0145*/  0xD1,0xF1,0   ,0   ,0   ,0xAF,0xBF,0xD2,0xF2,
/*U+0160*/  0xAA,0xBA,0   ,0   ,0   ,0   ,0xAB,0xBB,0xD7,0xF7,0xAE,0xBE,
            0   ,0   ,0   ,0   ,0   ,0   ,0xD9,0xF9,
/*U+017D*/  0xAC,0xBC,
/*U+2015*/  0xBD
};

/*********************************************************************
***                                                                ***
***                ISO 8859-10 (LATIN-6) to UNICODE                ***
***                                                                ***
***                      Conversion table                          ***
***                                                                ***
*********************************************************************/
/** ISO-8859-10 (Latin6) to unicode-codepoints conversion table */

static unsigned short usrg_tab_i10_to_uni[256] = {

/*          0      1      2      3      4      5      6      7     */
         0x0000,0x0001,0x0002,0x0003,0x0004,0x0005,0x0006,0x0007,  /* 0 ISO10 */

/*          8      9      A      B      C      D      E      F     */
         0x0008,0x0009,0x000A,0x000B,0x000C,0x000D,0x000E,0x000F,  /* 0       */

/*          0      1      2      3      4      5      6      7     */
         0x0010,0x0011,0x0012,0x0013,0x0014,0x0015,0x0016,0x0017,  /* 1       */

/*          8      9      A      B      C      D      E      F     */
         0x0018,0x0019,0x001A,0x001B,0x001C,0x001D,0x001E,0x001F,  /* 1       */

/*          0      1      2      3      4      5      6      7     */
         0x0020,0x0021,0x0022,0x0023,0x0024,0x0025,0x0026,0x0027,  /* 2       */

/*          8      9      A      B      C      D      E      F     */
         0x0028,0x0029,0x002A,0x002B,0x002C,0x002D,0x002E,0x002F,  /* 2       */

/*          0      1      2      3      4      5      6      7     */
         0x0030,0x0031,0x0032,0x0033,0x0034,0x0035,0x0036,0x0037,  /* 3       */

/*          8      9      A      B      C      D      E      F     */
         0x0038,0x0039,0x003A,0x003B,0x003C,0x003D,0x003E,0x003F,  /* 3       */

/*          0      1      2      3      4      5      6      7     */
         0x0040,0x0041,0x0042,0x0043,0x0044,0x0045,0x0046,0x0047,  /* 4       */

/*          8      9      A      B      C      D      E      F     */
         0x0048,0x0049,0x004A,0x004B,0x004C,0x004D,0x004E,0x004F,  /* 4       */

/*          0      1      2      3      4      5      6      7     */
         0x0050,0x0051,0x0052,0x0053,0x0054,0x0055,0x0056,0x0057,  /* 5       */

/*          8      9      A      B      C      D      E      F     */
         0x0058,0x0059,0x005A,0x005B,0x005C,0x005D,0x005E,0x005F,  /* 5       */

/*          0      1      2      3      4      5      6      7     */
         0x0060,0x0061,0x0062,0x0063,0x0064,0x0065,0x0066,0x0067,  /* 6 ISO10 */

/*          8      9      A      B      C      D      E      F     */
         0x0068,0x0069,0x006A,0x006B,0x006C,0x006D,0x006E,0x006F,  /* 6       */

/*          0      1      2      3      4      5      6      7     */
         0x0070,0x0071,0x0072,0x0073,0x0074,0x0075,0x0076,0x0077,  /* 7       */

/*          8      9      A      B      C      D      E      F     */
         0x0078,0x0079,0x007A,0x007B,0x007C,0x007D,0x007E,0x007F,  /* 7       */

/*          0      1      2      3      4      5      6      7     */
         0x0080,0x0081,0x0082,0x0083,0x0084,0x0085,0x0086,0x0087,  /* 8       */

/*          8      9      A      B      C      D      E      F     */
         0x0088,0x0089,0x008A,0x008B,0x008C,0x008D,0x008E,0x008F,  /* 8       */

/*          0      1      2      3      4      5      6      7     */
         0x0090,0x0091,0x0092,0x0093,0x0094,0x0095,0x0096,0x0097,  /* 9       */

/*          8      9      A      B      C      D      E      F     */
         0x0098,0x0099,0x009A,0x009B,0x009C,0x009D,0x009E,0x009F,  /* 9       */

/*          0      1      2      3      4      5      6      7     */
         0x00A0,0x0104,0x0112,0x0122,0x012A,0x0128,0x0136,0x00A7,  /* A       */

/*          8      9      A      B      C      D      E      F     */
         0x013B,0x0110,0x0160,0x0166,0x017D,0x00AD,0x016A,0x014A,  /* A       */

/*          0      1      2      3      4      5      6      7     */
         0x00B0,0x0105,0x0113,0x0123,0x012B,0x0129,0x0137,0x00B7,  /* B       */

/*          8      9      A      B      C      D      E      F     */
         0x013C,0x0111,0x0161,0x0167,0x017E,0x2015,0x016B,0x014B,  /* B       */

/*          0      1      2      3      4      5      6      7     */
         0x0100,0x00C1,0x00C2,0x00C3,0x00C4,0x00C5,0x00C6,0x012E,  /* C ISO10 */

/*          8      9      A      B      C      D      E      F     */
         0x010C,0x00C9,0x0118,0x00CB,0x0116,0x00CD,0x00CE,0x00CF,  /* C       */

/*          0      1      2      3      4      5      6      7     */
         0x00D0,0x0145,0x014C,0x00D3,0x00D4,0x00D5,0x00D6,0x0168,  /* D       */

/*          8      9      A      B      C      D      E      F     */
         0x00D8,0x0172,0x00DA,0x00DB,0x00DC,0x00DD,0x00DE,0x00DF,  /* D       */

/*          0      1      2      3      4      5      6      7     */
         0x0101,0x00E1,0x00E2,0x00E3,0x00E4,0x00E5,0x00E6,0x012F,  /* E       */

/*          8      9      A      B      C      D      E      F     */
         0x010D,0x00E9,0x0119,0x00EB,0x0117,0x00ED,0x00EE,0x00EF,  /* E       */

/*          0      1      2      3      4      5      6      7     */
         0x00F0,0x0146,0x014D,0x00F3,0x00F4,0x00F5,0x00F6,0x0169,  /* F       */

/*          8      9      A      B      C      D      E      F     */
         0x00F8,0x0173,0x00FA,0x00FB,0x00FC,0x00FD,0x00FE,0x0138   /* F       */
};

/*********************************************************************
***                                                                ***
***                    UNICODE to ISO 8859-11                      ***
***                                                                ***
***                   Two-step-conversion tables                   ***
***                                                                ***
*********************************************************************/

/**
* Definition of the segments of table ucrg_tabparts_uni_to_i11 below.
* Same format as table unrg_tabindex_uni_to_437, see explanation there.
* Identity with unicode can be assumed for the first 161 codepoins (0 to 0xA0).
*
* Note that the last pair was listed three times to be able to use an
* already-existing helper function without going out-of-bounds.
*/
static unsigned int unrg_tabindex_uni_to_i11[12] = {
    0x00A0,   0,   0x0E01,   1,   0x0E3F,  59,   0x0E5C,  88,
    0x0E5C,  88,   0x0E5C,  88
};

/**
* Table for the second step, as explained for ucrg_tabparts_uni_to_437,
* for what enum-value ied_chs_iso8859_11 means (Thai).
*/
static unsigned char ucrg_tabparts_uni_to_i11[88] = {
/*U+00A0*/  0xA0,
/*U+0E01*/  0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,
            0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,
            0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF,0xC0,0xC1,0xC2,0xC3,0xC4,
            0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,
            0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,
/*U+0E3F*/  0xDF,0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,
            0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,
            0xF7,0xF8,0xF9,0xFA,0xFB
};

/*********************************************************************
***                                                                ***
***                    ISO 8859-11 to UNICODE                      ***
***                                                                ***
***                      Conversion table                          ***
***                                                                ***
*********************************************************************/
/** ISO-8859-11 (Thai) to unicode-codepoints conversion table */

static unsigned short usrg_tab_i11_to_uni[256] = {

/*          0      1      2      3      4      5      6      7     */
         0x0000,0x0001,0x0002,0x0003,0x0004,0x0005,0x0006,0x0007,  /* 0 ISO11 */

/*          8      9      A      B      C      D      E      F     */
         0x0008,0x0009,0x000A,0x000B,0x000C,0x000D,0x000E,0x000F,  /* 0       */

/*          0      1      2      3      4      5      6      7     */
         0x0010,0x0011,0x0012,0x0013,0x0014,0x0015,0x0016,0x0017,  /* 1       */

/*          8      9      A      B      C      D      E      F     */
         0x0018,0x0019,0x001A,0x001B,0x001C,0x001D,0x001E,0x001F,  /* 1       */

/*          0      1      2      3      4      5      6      7     */
         0x0020,0x0021,0x0022,0x0023,0x0024,0x0025,0x0026,0x0027,  /* 2       */

/*          8      9      A      B      C      D      E      F     */
         0x0028,0x0029,0x002A,0x002B,0x002C,0x002D,0x002E,0x002F,  /* 2       */

/*          0      1      2      3      4      5      6      7     */
         0x0030,0x0031,0x0032,0x0033,0x0034,0x0035,0x0036,0x0037,  /* 3       */

/*          8      9      A      B      C      D      E      F     */
         0x0038,0x0039,0x003A,0x003B,0x003C,0x003D,0x003E,0x003F,  /* 3       */

/*          0      1      2      3      4      5      6      7     */
         0x0040,0x0041,0x0042,0x0043,0x0044,0x0045,0x0046,0x0047,  /* 4       */

/*          8      9      A      B      C      D      E      F     */
         0x0048,0x0049,0x004A,0x004B,0x004C,0x004D,0x004E,0x004F,  /* 4       */

/*          0      1      2      3      4      5      6      7     */
         0x0050,0x0051,0x0052,0x0053,0x0054,0x0055,0x0056,0x0057,  /* 5       */

/*          8      9      A      B      C      D      E      F     */
         0x0058,0x0059,0x005A,0x005B,0x005C,0x005D,0x005E,0x005F,  /* 5       */

/*          0      1      2      3      4      5      6      7     */
         0x0060,0x0061,0x0062,0x0063,0x0064,0x0065,0x0066,0x0067,  /* 6 ISO11 */

/*          8      9      A      B      C      D      E      F     */
         0x0068,0x0069,0x006A,0x006B,0x006C,0x006D,0x006E,0x006F,  /* 6       */

/*          0      1      2      3      4      5      6      7     */
         0x0070,0x0071,0x0072,0x0073,0x0074,0x0075,0x0076,0x0077,  /* 7       */

/*          8      9      A      B      C      D      E      F     */
         0x0078,0x0079,0x007A,0x007B,0x007C,0x007D,0x007E,0x007F,  /* 7       */

/*          0      1      2      3      4      5      6      7     */
         0x0080,0x0081,0x0082,0x0083,0x0084,0x0085,0x0086,0x0087,  /* 8       */

/*          8      9      A      B      C      D      E      F     */
         0x0088,0x0089,0x008A,0x008B,0x008C,0x008D,0x008E,0x008F,  /* 8       */

/*          0      1      2      3      4      5      6      7     */
         0x0090,0x0091,0x0092,0x0093,0x0094,0x0095,0x0096,0x0097,  /* 9       */

/*          8      9      A      B      C      D      E      F     */
         0x0098,0x0099,0x009A,0x009B,0x009C,0x009D,0x009E,0x009F,  /* 9       */

/*          0      1      2      3      4      5      6      7     */
         0x00A0,0x0E01,0x0E02,0x0E03,0x0E04,0x0E05,0x0E06,0x0E07,  /* A       */

/*          8      9      A      B      C      D      E      F     */
         0x0E08,0x0E09,0x0E0A,0x0E0B,0x0E0C,0x0E0D,0x0E0E,0x0E0F,  /* A       */

/*          0      1      2      3      4      5      6      7     */
         0x0E10,0x0E11,0x0E12,0x0E13,0x0E14,0x0E15,0x0E16,0x0E17,  /* B       */

/*          8      9      A      B      C      D      E      F     */
         0x0E18,0x0E19,0x0E1A,0x0E1B,0x0E1C,0x0E1D,0x0E1E,0x0E1F,  /* B       */

/*          0      1      2      3      4      5      6      7     */
         0x0E20,0x0E21,0x0E22,0x0E23,0x0E24,0x0E25,0x0E26,0x0E27,  /* C ISO11 */

/*          8      9      A      B      C      D      E      F     */
         0x0E28,0x0E29,0x0E2A,0x0E2B,0x0E2C,0x0E2D,0x0E2E,0x0E2F,  /* C       */

/*          0      1      2      3      4      5      6      7     */
         0x0E30,0x0E31,0x0E32,0x0E33,0x0E34,0x0E35,0x0E36,0x0E37,  /* D       */

/*          8      9      A      B      C      D      E      F     */
         0x0E38,0x0E39,0x0E3A,0x00DB,0x00DC,0x00DD,0x00DE,0x0E3F,  /* D       */

/*          0      1      2      3      4      5      6      7     */
         0x0E40,0x0E41,0x0E42,0x0E43,0x0E44,0x0E45,0x0E46,0x0E47,  /* E       */

/*          8      9      A      B      C      D      E      F     */
         0x0E48,0x0E49,0x0E4A,0x0E4B,0x0E4C,0x0E4D,0x0E4E,0x0E4F,  /* E       */

/*          0      1      2      3      4      5      6      7     */
         0x0E50,0x0E51,0x0E52,0x0E53,0x0E54,0x0E55,0x0E56,0x0E57,  /* F       */

/*          8      9      A      B      C      D      E      F     */
         0x0E58,0x0E59,0x0E5A,0x0E5B,0x00FC,0x00FD,0x00FE,0x00FF   /* F       */
};

/*********************************************************************
***                                                                ***
***                UNICODE to ISO 8859-13 (LATIN-7)                ***
***                                                                ***
***                   Two-step-conversion tables                   ***
***                                                                ***
*********************************************************************/

/**
* Definition of the segments of table ucrg_tabparts_uni_to_i13 below.
* Same format as table unrg_tabindex_uni_to_437, see explanation there.
* Identity with unicode can be assumed for the first 161 codepoins (0 to 0xA0).
*/
static unsigned int unrg_tabindex_uni_to_i13[18] = {
    0x00A0,   0,   0x0122, 122,   0x012A, 124,   0x0136, 130,
    0x0156, 154,   0x016A, 166,   0x0172, 168,   0x2019, 181,
    0x201F, 187
};

/**
* Table for the second step, as explained for ucrg_tabparts_uni_to_437,
* for what enum-value ied_chs_iso8859_13 means (Latin-7, Baltic Rim/ Estonian).
*/
static unsigned char ucrg_tabparts_uni_to_i13[187] = {
/*U+00A0*/  0xA0,0   ,0xA2,0xA3,0xA4,0   ,0xA6,0xA7,0   ,0xA9,0   ,0xAB,
            0xAC,0xAD,0xAE,0   ,0xB0,0xB1,0xB2,0xB3,0   ,0xB5,0xB6,0xB7,
            0   ,0xB9,0   ,0xBB,0xBC,0xBD,0xBE,0   ,0   ,0   ,0   ,0   ,
            0xC4,0xC5,0xAF,0   ,0   ,0xC9,0   ,0   ,0   ,0   ,0   ,0   ,
            0   ,0   ,0   ,0xD3,0   ,0xD5,0xD6,0xD7,0xA8,0   ,0   ,0   ,
            0xDC,0   ,0   ,0xDF,0   ,0   ,0   ,0   ,0xE4,0xE5,0xBF,0   ,
            0   ,0xE9,0   ,0   ,0   ,0   ,0   ,0   ,0   ,0   ,0   ,0xF3,
            0   ,0xF5,0xF6,0xF7,0xB8,0   ,0   ,0   ,0xFC,0   ,0   ,0   ,
            0xC2,0xE2,0   ,0   ,0xC0,0xE0,0xC3,0xE3,0   ,0   ,0   ,0   ,
            0xC8,0xE8,0   ,0   ,0   ,0   ,0xC7,0xE7,0   ,0   ,0xCB,0xEB,
            0xC6,0xE6,
/*U+0122*/  0xCC,0xEC,
/*U+012A*/  0xCE,0xEE,0   ,0   ,0xC1,0xE1,
/*U+0136*/  0xCD,0xED,0   ,0   ,0   ,0xCF,0xEF,0   ,0   ,0   ,0   ,0xD9,
            0xF9,0xD1,0xF1,0xD2,0xF2,0   ,0   ,0   ,0   ,0   ,0xD4,0xF4,
/*U+0156*/  0xAA,0xBA,0   ,0   ,0xDA,0xFA,0   ,0   ,0   ,0   ,0xD0,0xF0,
/*U+016A*/  0xDB,0xFB,
/*U+0172*/  0xD8,0xF8,0   ,0   ,0   ,0   ,0   ,0xCA,0xEA,0xDD,0xFD,0xDE,
            0xFE,
/*U+2019*/  0xFF,0   ,0   ,0xB4,0xA1,0xA5
};

/*********************************************************************
***                                                                ***
***                ISO 8859-13 (LATIN-7) to UNICODE                ***
***                                                                ***
***                      Conversion table                          ***
***                                                                ***
*********************************************************************/
/** ISO-8859-13 (Latin7) to unicode-codepoints conversion table */

static unsigned short usrg_tab_i13_to_uni[256] = {

/*          0      1      2      3      4      5      6      7     */
         0x0000,0x0001,0x0002,0x0003,0x0004,0x0005,0x0006,0x0007,  /* 0 ISO13 */

/*          8      9      A      B      C      D      E      F     */
         0x0008,0x0009,0x000A,0x000B,0x000C,0x000D,0x000E,0x000F,  /* 0       */

/*          0      1      2      3      4      5      6      7     */
         0x0010,0x0011,0x0012,0x0013,0x0014,0x0015,0x0016,0x0017,  /* 1       */

/*          8      9      A      B      C      D      E      F     */
         0x0018,0x0019,0x001A,0x001B,0x001C,0x001D,0x001E,0x001F,  /* 1       */

/*          0      1      2      3      4      5      6      7     */
         0x0020,0x0021,0x0022,0x0023,0x0024,0x0025,0x0026,0x0027,  /* 2       */

/*          8      9      A      B      C      D      E      F     */
         0x0028,0x0029,0x002A,0x002B,0x002C,0x002D,0x002E,0x002F,  /* 2       */

/*          0      1      2      3      4      5      6      7     */
         0x0030,0x0031,0x0032,0x0033,0x0034,0x0035,0x0036,0x0037,  /* 3       */

/*          8      9      A      B      C      D      E      F     */
         0x0038,0x0039,0x003A,0x003B,0x003C,0x003D,0x003E,0x003F,  /* 3       */

/*          0      1      2      3      4      5      6      7     */
         0x0040,0x0041,0x0042,0x0043,0x0044,0x0045,0x0046,0x0047,  /* 4       */

/*          8      9      A      B      C      D      E      F     */
         0x0048,0x0049,0x004A,0x004B,0x004C,0x004D,0x004E,0x004F,  /* 4       */

/*          0      1      2      3      4      5      6      7     */
         0x0050,0x0051,0x0052,0x0053,0x0054,0x0055,0x0056,0x0057,  /* 5       */

/*          8      9      A      B      C      D      E      F     */
         0x0058,0x0059,0x005A,0x005B,0x005C,0x005D,0x005E,0x005F,  /* 5       */

/*          0      1      2      3      4      5      6      7     */
         0x0060,0x0061,0x0062,0x0063,0x0064,0x0065,0x0066,0x0067,  /* 6 ISO13 */

/*          8      9      A      B      C      D      E      F     */
         0x0068,0x0069,0x006A,0x006B,0x006C,0x006D,0x006E,0x006F,  /* 6       */

/*          0      1      2      3      4      5      6      7     */
         0x0070,0x0071,0x0072,0x0073,0x0074,0x0075,0x0076,0x0077,  /* 7       */

/*          8      9      A      B      C      D      E      F     */
         0x0078,0x0079,0x007A,0x007B,0x007C,0x007D,0x007E,0x007F,  /* 7       */

/*          0      1      2      3      4      5      6      7     */
         0x0080,0x0081,0x0082,0x0083,0x0084,0x0085,0x0086,0x0087,  /* 8       */

/*          8      9      A      B      C      D      E      F     */
         0x0088,0x0089,0x008A,0x008B,0x008C,0x008D,0x008E,0x008F,  /* 8       */

/*          0      1      2      3      4      5      6      7     */
         0x0090,0x0091,0x0092,0x0093,0x0094,0x0095,0x0096,0x0097,  /* 9       */

/*          8      9      A      B      C      D      E      F     */
         0x0098,0x0099,0x009A,0x009B,0x009C,0x009D,0x009E,0x009F,  /* 9       */

/*          0      1      2      3      4      5      6      7     */
         0x00A0,0x201D,0x00A2,0x00A3,0x00A4,0x201E,0x00A6,0x00A7,  /* A       */

/*          8      9      A      B      C      D      E      F     */
         0x00D8,0x00A9,0x0156,0x00AB,0x00AC,0x00AD,0x00AE,0x00C6,  /* A       */

/*          0      1      2      3      4      5      6      7     */
         0x00B0,0x00B1,0x00B2,0x00B3,0x201C,0x00B5,0x00B6,0x00B7,  /* B       */

/*          8      9      A      B      C      D      E      F     */
         0x00F8,0x00B9,0x0157,0x00BB,0x00BC,0x00BD,0x00BE,0x00E6,  /* B       */

/*          0      1      2      3      4      5      6      7     */
         0x0104,0x012E,0x0100,0x0106,0x00C4,0x00C5,0x0118,0x0112,  /* C ISO13 */

/*          8      9      A      B      C      D      E      F     */
         0x010C,0x00C9,0x0179,0x0116,0x0122,0x0136,0x012A,0x013B,  /* C       */

/*          0      1      2      3      4      5      6      7     */
         0x0160,0x0143,0x0145,0x00D3,0x014C,0x00D5,0x00D6,0x00D7,  /* D       */

/*          8      9      A      B      C      D      E      F     */
         0x0172,0x0141,0x015A,0x016A,0x00DC,0x017B,0x017D,0x00DF,  /* D       */

/*          0      1      2      3      4      5      6      7     */
         0x0105,0x012F,0x0101,0x0107,0x00E4,0x00E5,0x0119,0x0113,  /* E       */

/*          8      9      A      B      C      D      E      F     */
         0x010D,0x00E9,0x017A,0x0117,0x0123,0x0137,0x012B,0x013C,  /* E       */

/*          0      1      2      3      4      5      6      7     */
         0x0161,0x0144,0x0146,0x00F3,0x014D,0x00F5,0x00F6,0x00F7,  /* F       */

/*          8      9      A      B      C      D      E      F     */
         0x0173,0x0142,0x015B,0x016B,0x00FC,0x017C,0x017E,0x2019   /* F       */
};

/*********************************************************************
***                                                                ***
***                UNICODE to ISO 8859-14 (LATIN-8)                ***
***                                                                ***
***                   Two-step-conversion tables                   ***
***                                                                ***
*********************************************************************/

/**
* Definition of the segments of table ucrg_tabparts_uni_to_i14 below.
* Same format as table unrg_tabindex_uni_to_437, see explanation there.
* Identity with unicode can be assumed for the first 161 codepoins (0 to 0xA0).
*/
static unsigned int unrg_tabindex_uni_to_i14[24] = {
    0x00A0,   0,   0x010A,  96,   0x0120,  98,   0x0174, 100,
    0x1E02, 105,   0x1E1E, 115,   0x1E40, 117,   0x1E56, 119,
    0x1E60, 121,   0x1E80, 133,   0x1EF2, 139,   0x1EF4, 141
};

/**
* Table for the second step, as explained for ucrg_tabparts_uni_to_437,
* for what enum-value ied_chs_iso8859_14 means (Latin8, celtic).
*/
static unsigned char ucrg_tabparts_uni_to_i14[141] = {
/*U+00A0*/  0xA0,0   ,0   ,0xA3,0   ,0   ,0   ,0xA7,0   ,0xA9,0   ,0   ,
            0   ,0xAD,0xAE,0   ,0   ,0   ,0   ,0   ,0   ,0   ,0xB6,0   ,
            0   ,0   ,0   ,0   ,0   ,0   ,0   ,0   ,0xC0,0xC1,0xC2,0xC3,
            0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,
            0   ,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0   ,0xD8,0xD9,0xDA,0xDB,
            0xDC,0xDD,0   ,0xDF,0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,
            0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0   ,0xF1,0xF2,0xF3,
            0xF4,0xF5,0xF6,0   ,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0   ,0xFF,
/*U+010A*/  0xA4,0xA5,
/*U+0120*/  0xB2,0xB3,
/*U+0174*/  0xD0,0xF0,0xDE,0xFE,0xAF,
/*U+1E02*/  0xA1,0xA2,0   ,0   ,0   ,0   ,0   ,0   ,0xA6,0xAB,
/*U+1E1E*/  0xB0,0xB1,
/*U+1E40*/  0xB4,0xB5,
/*U+1E56*/  0xB7,0xB9,
/*U+1E60*/  0xBB,0xBF,0   ,0   ,0   ,0   ,0   ,0   ,0   ,0   ,0xD7,0xF7,
/*U+1E80*/  0xA8,0xB8,0xAA,0xBA,0xBD,0xBE,
/*U+1EF2*/  0xAC,0xBC
};

/*********************************************************************
***                                                                ***
***                ISO 8859-14 (LATIN-8) to UNICODE                ***
***                                                                ***
***                      Conversion table                          ***
***                                                                ***
*********************************************************************/
/** ISO-8859-14 (Latin8) to unicode-codepoints conversion table */

static unsigned short usrg_tab_i14_to_uni[256] = {

/*          0      1      2      3      4      5      6      7     */
         0x0000,0x0001,0x0002,0x0003,0x0004,0x0005,0x0006,0x0007,  /* 0 ISO14 */

/*          8      9      A      B      C      D      E      F     */
         0x0008,0x0009,0x000A,0x000B,0x000C,0x000D,0x000E,0x000F,  /* 0       */

/*          0      1      2      3      4      5      6      7     */
         0x0010,0x0011,0x0012,0x0013,0x0014,0x0015,0x0016,0x0017,  /* 1       */

/*          8      9      A      B      C      D      E      F     */
         0x0018,0x0019,0x001A,0x001B,0x001C,0x001D,0x001E,0x001F,  /* 1       */

/*          0      1      2      3      4      5      6      7     */
         0x0020,0x0021,0x0022,0x0023,0x0024,0x0025,0x0026,0x0027,  /* 2       */

/*          8      9      A      B      C      D      E      F     */
         0x0028,0x0029,0x002A,0x002B,0x002C,0x002D,0x002E,0x002F,  /* 2       */

/*          0      1      2      3      4      5      6      7     */
         0x0030,0x0031,0x0032,0x0033,0x0034,0x0035,0x0036,0x0037,  /* 3       */

/*          8      9      A      B      C      D      E      F     */
         0x0038,0x0039,0x003A,0x003B,0x003C,0x003D,0x003E,0x003F,  /* 3       */

/*          0      1      2      3      4      5      6      7     */
         0x0040,0x0041,0x0042,0x0043,0x0044,0x0045,0x0046,0x0047,  /* 4       */

/*          8      9      A      B      C      D      E      F     */
         0x0048,0x0049,0x004A,0x004B,0x004C,0x004D,0x004E,0x004F,  /* 4       */

/*          0      1      2      3      4      5      6      7     */
         0x0050,0x0051,0x0052,0x0053,0x0054,0x0055,0x0056,0x0057,  /* 5       */

/*          8      9      A      B      C      D      E      F     */
         0x0058,0x0059,0x005A,0x005B,0x005C,0x005D,0x005E,0x005F,  /* 5       */

/*          0      1      2      3      4      5      6      7     */
         0x0060,0x0061,0x0062,0x0063,0x0064,0x0065,0x0066,0x0067,  /* 6 ISO14 */

/*          8      9      A      B      C      D      E      F     */
         0x0068,0x0069,0x006A,0x006B,0x006C,0x006D,0x006E,0x006F,  /* 6       */

/*          0      1      2      3      4      5      6      7     */
         0x0070,0x0071,0x0072,0x0073,0x0074,0x0075,0x0076,0x0077,  /* 7       */

/*          8      9      A      B      C      D      E      F     */
         0x0078,0x0079,0x007A,0x007B,0x007C,0x007D,0x007E,0x007F,  /* 7       */

/*          0      1      2      3      4      5      6      7     */
         0x0080,0x0081,0x0082,0x0083,0x0084,0x0085,0x0086,0x0087,  /* 8       */

/*          8      9      A      B      C      D      E      F     */
         0x0088,0x0089,0x008A,0x008B,0x008C,0x008D,0x008E,0x008F,  /* 8       */

/*          0      1      2      3      4      5      6      7     */
         0x0090,0x0091,0x0092,0x0093,0x0094,0x0095,0x0096,0x0097,  /* 9       */

/*          8      9      A      B      C      D      E      F     */
         0x0098,0x0099,0x009A,0x009B,0x009C,0x009D,0x009E,0x009F,  /* 9       */

/*          0      1      2      3      4      5      6      7     */
         0x00A0,0x1E02,0x1E03,0x00A3,0x010A,0x010B,0x1E0A,0x00A7,  /* A       */

/*          8      9      A      B      C      D      E      F     */
         0x1E80,0x00A9,0x1E82,0x1E0B,0x1EF2,0x00AD,0x00AE,0x0178,  /* A       */

/*          0      1      2      3      4      5      6      7     */
         0x1E1E,0x1E1F,0x0120,0x0121,0x1E40,0x1E41,0x00B6,0x1E56,  /* B       */

/*          8      9      A      B      C      D      E      F     */
         0x1E81,0x1E57,0x1E83,0x1E60,0x1EF3,0x1E84,0x1E85,0x1E61,  /* B       */

/*          0      1      2      3      4      5      6      7     */
         0x00C0,0x00C1,0x00C2,0x00C3,0x00C4,0x00C5,0x00C6,0x00C7,  /* C ISO14 */

/*          8      9      A      B      C      D      E      F     */
         0x00C8,0x00C9,0x00CA,0x00CB,0x00CC,0x00CD,0x00CE,0x00CF,  /* C       */

/*          0      1      2      3      4      5      6      7     */
         0x0174,0x00D1,0x00D2,0x00D3,0x00D4,0x00D5,0x00D6,0x1E6A,  /* D       */

/*          8      9      A      B      C      D      E      F     */
         0x00D8,0x00D9,0x00DA,0x00DB,0x00DC,0x00DD,0x0176,0x00DF,  /* D       */

/*          0      1      2      3      4      5      6      7     */
         0x00E0,0x00E1,0x00E2,0x00E3,0x00E4,0x00E5,0x00E6,0x00E7,  /* E       */

/*          8      9      A      B      C      D      E      F     */
         0x00E8,0x00E9,0x00EA,0x00EB,0x00EC,0x00ED,0x00EE,0x00EF,  /* E       */

/*          0      1      2      3      4      5      6      7     */
         0x0175,0x00F1,0x00F2,0x00F3,0x00F4,0x00F5,0x00F6,0x1E6B,  /* F       */

/*          8      9      A      B      C      D      E      F     */
         0x00F8,0x00F9,0x00FA,0x00FB,0x00FC,0x00FD,0x0177,0x00FF   /* F       */
};

/*********************************************************************
***                                                                ***
***                UNICODE to ISO 8859-15 (LATIN-9)                ***
***                                                                ***
***                   Two-step-conversion tables                   ***
***                                                                ***
*********************************************************************/

/**
* Definition of the segments of table ucrg_tabparts_uni_to_i15 below.
* Same format as table unrg_tabindex_uni_to_437, see explanation there.
* Identity with unicode can be assumed for the first 161 codepoins (0 to 0xA0).
*/
static unsigned int unrg_tabindex_uni_to_i15[12] = {
    0x00A0,   0,   0x0152,  96,   0x0160,  98,   0x0178, 100,
    0x20AC, 107,   0x20AD, 108
};

/**
* Table for the second step, as explained for ucrg_tabparts_uni_to_437,
* for what enum-value ied_chs_iso8859_15 means (Latin-9).
*/
static unsigned char ucrg_tabparts_uni_to_i15[108] = {
/*U+00A0*/  0xA0,0xA1,0xA2,0xA3,0   ,0xA5,0   ,0xA7,0   ,0xA9,0xAA,0xAB,
            0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0   ,0xB5,0xB6,0xB7,
            0   ,0xB9,0xBA,0xBB,0   ,0   ,0   ,0xBF,0xC0,0xC1,0xC2,0xC3,
            0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,
            0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,
            0xDC,0xDD,0xDE,0xDF,0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,
            0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,
            0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF,
/*U+0152*/  0xBC,0xBD,
/*U+0160*/  0xA6,0xA8,
/*U+0178*/  0xBE,0   ,0   ,0   ,0   ,0xB4,0xB8,
/*U+20AC*/  0xA4
};

/*********************************************************************
***                                                                ***
***                ISO 8859-15 (LATIN-9) to UNICODE                ***
***                                                                ***
***                      Conversion table                          ***
***                                                                ***
*********************************************************************/
/** ISO-8859-15 (Latin-9) to unicode-codepoints conversion table */

static unsigned short usrg_tab_i15_to_uni[256] = {

/*          0      1      2      3      4      5      6      7     */
         0x0000,0x0001,0x0002,0x0003,0x0004,0x0005,0x0006,0x0007,  /* 0 ISO15 */

/*          8      9      A      B      C      D      E      F     */
         0x0008,0x0009,0x000A,0x000B,0x000C,0x000D,0x000E,0x000F,  /* 0       */

/*          0      1      2      3      4      5      6      7     */
         0x0010,0x0011,0x0012,0x0013,0x0014,0x0015,0x0016,0x0017,  /* 1       */

/*          8      9      A      B      C      D      E      F     */
         0x0018,0x0019,0x001A,0x001B,0x001C,0x001D,0x001E,0x001F,  /* 1       */

/*          0      1      2      3      4      5      6      7     */
         0x0020,0x0021,0x0022,0x0023,0x0024,0x0025,0x0026,0x0027,  /* 2       */

/*          8      9      A      B      C      D      E      F     */
         0x0028,0x0029,0x002A,0x002B,0x002C,0x002D,0x002E,0x002F,  /* 2       */

/*          0      1      2      3      4      5      6      7     */
         0x0030,0x0031,0x0032,0x0033,0x0034,0x0035,0x0036,0x0037,  /* 3       */

/*          8      9      A      B      C      D      E      F     */
         0x0038,0x0039,0x003A,0x003B,0x003C,0x003D,0x003E,0x003F,  /* 3       */

/*          0      1      2      3      4      5      6      7     */
         0x0040,0x0041,0x0042,0x0043,0x0044,0x0045,0x0046,0x0047,  /* 4       */

/*          8      9      A      B      C      D      E      F     */
         0x0048,0x0049,0x004A,0x004B,0x004C,0x004D,0x004E,0x004F,  /* 4       */

/*          0      1      2      3      4      5      6      7     */
         0x0050,0x0051,0x0052,0x0053,0x0054,0x0055,0x0056,0x0057,  /* 5       */

/*          8      9      A      B      C      D      E      F     */
         0x0058,0x0059,0x005A,0x005B,0x005C,0x005D,0x005E,0x005F,  /* 5       */

/*          0      1      2      3      4      5      6      7     */
         0x0060,0x0061,0x0062,0x0063,0x0064,0x0065,0x0066,0x0067,  /* 6 ISO15 */

/*          8      9      A      B      C      D      E      F     */
         0x0068,0x0069,0x006A,0x006B,0x006C,0x006D,0x006E,0x006F,  /* 6       */

/*          0      1      2      3      4      5      6      7     */
         0x0070,0x0071,0x0072,0x0073,0x0074,0x0075,0x0076,0x0077,  /* 7       */

/*          8      9      A      B      C      D      E      F     */
         0x0078,0x0079,0x007A,0x007B,0x007C,0x007D,0x007E,0x007F,  /* 7       */

/*          0      1      2      3      4      5      6      7     */
         0x0080,0x0081,0x0082,0x0083,0x0084,0x0085,0x0086,0x0087,  /* 8       */

/*          8      9      A      B      C      D      E      F     */
         0x0088,0x0089,0x008A,0x008B,0x008C,0x008D,0x008E,0x008F,  /* 8       */

/*          0      1      2      3      4      5      6      7     */
         0x0090,0x0091,0x0092,0x0093,0x0094,0x0095,0x0096,0x0097,  /* 9       */

/*          8      9      A      B      C      D      E      F     */
         0x0098,0x0099,0x009A,0x009B,0x009C,0x009D,0x009E,0x009F,  /* 9       */

/*          0      1      2      3      4      5      6      7     */
         0x00A0,0x00A1,0x00A2,0x00A3,0x20AC,0x00A5,0x0160,0x00A7,  /* A       */

/*          8      9      A      B      C      D      E      F     */
         0x0161,0x00A9,0x00AA,0x00AB,0x00AC,0x00AD,0x00AE,0x00AF,  /* A       */

/*          0      1      2      3      4      5      6      7     */
         0x00B0,0x00B1,0x00B2,0x00B3,0x017D,0x00B5,0x00B6,0x00B7,  /* B       */

/*          8      9      A      B      C      D      E      F     */
         0x017E,0x00B9,0x00BA,0x00BB,0x0152,0x0153,0x0178,0x00BF,  /* B       */

/*          0      1      2      3      4      5      6      7     */
         0x00C0,0x00C1,0x00C2,0x00C3,0x00C4,0x00C5,0x00C6,0x00C7,  /* C ISO15 */

/*          8      9      A      B      C      D      E      F     */
         0x00C8,0x00C9,0x00CA,0x00CB,0x00CC,0x00CD,0x00CE,0x00CF,  /* C       */

/*          0      1      2      3      4      5      6      7     */
         0x00D0,0x00D1,0x00D2,0x00D3,0x00D4,0x00D5,0x00D6,0x00D7,  /* D       */

/*          8      9      A      B      C      D      E      F     */
         0x00D8,0x00D9,0x00DA,0x00DB,0x00DC,0x00DD,0x00DE,0x00DF,  /* D       */

/*          0      1      2      3      4      5      6      7     */
         0x00E0,0x00E1,0x00E2,0x00E3,0x00E4,0x00E5,0x00E6,0x00E7,  /* E       */

/*          8      9      A      B      C      D      E      F     */
         0x00E8,0x00E9,0x00EA,0x00EB,0x00EC,0x00ED,0x00EE,0x00EF,  /* E       */

/*          0      1      2      3      4      5      6      7     */
         0x00F0,0x00F1,0x00F2,0x00F3,0x00F4,0x00F5,0x00F6,0x00F7,  /* F       */

/*          8      9      A      B      C      D      E      F     */
         0x00F8,0x00F9,0x00FA,0x00FB,0x00FC,0x00FD,0x00FE,0x00FF   /* F       */
};

/*********************************************************************
***                                                                ***
***               UNICODE to ISO 8859-16 (LATIN-10)                ***
***                                                                ***
***                   Two-step-conversion tables                   ***
***                                                                ***
*********************************************************************/

/**
* Definition of the segments of table ucrg_tabparts_uni_to_i16 below.
* Same format as table unrg_tabindex_uni_to_437, see explanation there.
* Identity with unicode can be assumed for the first 161 codepoins (0 to 0xA0).
*/
static unsigned int unrg_tabindex_uni_to_i16[24] = {
    0x00A0,   0,   0x010C, 104,   0x0118, 110,   0x0141, 112,
    0x0150, 116,   0x015A, 120,   0x0170, 128,   0x0178, 130,
    0x0218, 137,   0x201D, 141,   0x20AC, 143,   0x20AD, 144
};

/**
* Table for the second step, as explained for ucrg_tabparts_uni_to_437,
* for what enum-value ied_chs_iso8859_16 means (Latin10, South-Eastern European)
*/
static unsigned char ucrg_tabparts_uni_to_i16[144] = {
/*U+00A0*/  0xA0,0   ,0   ,0   ,0   ,0   ,0   ,0xA7,0   ,0xA9,0   ,0xAB,
            0   ,0xAD,0   ,0   ,0xB0,0xB1,0   ,0   ,0   ,0   ,0xB6,0xB7,
            0   ,0   ,0   ,0xBB,0   ,0   ,0   ,0   ,0xC0,0xC1,0xC2,0   ,
            0xC4,0   ,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,
            0   ,0   ,0xD2,0xD3,0xD4,0   ,0xD6,0   ,0   ,0xD9,0xDA,0xDB,
            0xDC,0   ,0   ,0xDF,0xE0,0xE1,0xE2,0   ,0xE4,0   ,0xE6,0xE7,
            0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0   ,0   ,0xF2,0xF3,
            0xF4,0   ,0xF6,0   ,0   ,0xF9,0xFA,0xFB,0xFC,0   ,0   ,0xFF,
            0   ,0   ,0xC3,0xE3,0xA1,0xA2,0xC5,0xE5,
/*U+010C*/  0xB2,0xB9,0   ,0   ,0xD0,0xF0,
/*U+0118*/  0xDD,0xFD,
/*U+0141*/  0xA3,0xB3,0xD1,0xF1,
/*U+0150*/  0xD5,0xF5,0xBC,0xBD,
/*U+015A*/  0xD7,0xF7,0   ,0   ,0   ,0   ,0xA6,0xA8,
/*U+0170*/  0xD8,0xF8,
/*U+0178*/  0xBE,0xAC,0xAE,0xAF,0xBF,0xB4,0xB8,
/*U+0218*/  0xAA,0xBA,0xDE,0xFE,
/*U+201D*/  0xB5,0xA5,
/*U+20AC*/  0xA4
};

/*********************************************************************
***                                                                ***
***               ISO 8859-16 (LATIN-10) to UNICODE                ***
***                                                                ***
***                      Conversion table                          ***
***                                                                ***
*********************************************************************/
/** ISO-8859-16 (Latin10) to unicode-codepoints conversion table */

static unsigned short usrg_tab_i16_to_uni[256] = {

/*          0      1      2      3      4      5      6      7     */
         0x0000,0x0001,0x0002,0x0003,0x0004,0x0005,0x0006,0x0007,  /* 0 ISO16 */

/*          8      9      A      B      C      D      E      F     */
         0x0008,0x0009,0x000A,0x000B,0x000C,0x000D,0x000E,0x000F,  /* 0       */

/*          0      1      2      3      4      5      6      7     */
         0x0010,0x0011,0x0012,0x0013,0x0014,0x0015,0x0016,0x0017,  /* 1       */

/*          8      9      A      B      C      D      E      F     */
         0x0018,0x0019,0x001A,0x001B,0x001C,0x001D,0x001E,0x001F,  /* 1       */

/*          0      1      2      3      4      5      6      7     */
         0x0020,0x0021,0x0022,0x0023,0x0024,0x0025,0x0026,0x0027,  /* 2       */

/*          8      9      A      B      C      D      E      F     */
         0x0028,0x0029,0x002A,0x002B,0x002C,0x002D,0x002E,0x002F,  /* 2       */

/*          0      1      2      3      4      5      6      7     */
         0x0030,0x0031,0x0032,0x0033,0x0034,0x0035,0x0036,0x0037,  /* 3       */

/*          8      9      A      B      C      D      E      F     */
         0x0038,0x0039,0x003A,0x003B,0x003C,0x003D,0x003E,0x003F,  /* 3       */

/*          0      1      2      3      4      5      6      7     */
         0x0040,0x0041,0x0042,0x0043,0x0044,0x0045,0x0046,0x0047,  /* 4       */

/*          8      9      A      B      C      D      E      F     */
         0x0048,0x0049,0x004A,0x004B,0x004C,0x004D,0x004E,0x004F,  /* 4       */

/*          0      1      2      3      4      5      6      7     */
         0x0050,0x0051,0x0052,0x0053,0x0054,0x0055,0x0056,0x0057,  /* 5       */

/*          8      9      A      B      C      D      E      F     */
         0x0058,0x0059,0x005A,0x005B,0x005C,0x005D,0x005E,0x005F,  /* 5       */

/*          0      1      2      3      4      5      6      7     */
         0x0060,0x0061,0x0062,0x0063,0x0064,0x0065,0x0066,0x0067,  /* 6 ISO16 */

/*          8      9      A      B      C      D      E      F     */
         0x0068,0x0069,0x006A,0x006B,0x006C,0x006D,0x006E,0x006F,  /* 6       */

/*          0      1      2      3      4      5      6      7     */
         0x0070,0x0071,0x0072,0x0073,0x0074,0x0075,0x0076,0x0077,  /* 7       */

/*          8      9      A      B      C      D      E      F     */
         0x0078,0x0079,0x007A,0x007B,0x007C,0x007D,0x007E,0x007F,  /* 7       */

/*          0      1      2      3      4      5      6      7     */
         0x0080,0x0081,0x0082,0x0083,0x0084,0x0085,0x0086,0x0087,  /* 8       */

/*          8      9      A      B      C      D      E      F     */
         0x0088,0x0089,0x008A,0x008B,0x008C,0x008D,0x008E,0x008F,  /* 8       */

/*          0      1      2      3      4      5      6      7     */
         0x0090,0x0091,0x0092,0x0093,0x0094,0x0095,0x0096,0x0097,  /* 9       */

/*          8      9      A      B      C      D      E      F     */
         0x0098,0x0099,0x009A,0x009B,0x009C,0x009D,0x009E,0x009F,  /* 9       */

/*          0      1      2      3      4      5      6      7     */
         0x00A0,0x0104,0x0105,0x0141,0x20AC,0x201E,0x0160,0x00A7,  /* A       */

/*          8      9      A      B      C      D      E      F     */
         0x0161,0x00A9,0x0218,0x00AB,0x0179,0x00AD,0x017A,0x017B,  /* A       */

/*          0      1      2      3      4      5      6      7     */
         0x00B0,0x00B1,0x010C,0x0142,0x017D,0x201D,0x00B6,0x00B7,  /* B       */

/*          8      9      A      B      C      D      E      F     */
         0x017E,0x010D,0x0219,0x00BB,0x0152,0x0153,0x0178,0x017C,  /* B       */

/*          0      1      2      3      4      5      6      7     */
         0x00C0,0x00C1,0x00C2,0x0102,0x00C4,0x0106,0x00C6,0x00C7,  /* C ISO16 */

/*          8      9      A      B      C      D      E      F     */
         0x00C8,0x00C9,0x00CA,0x00CB,0x00CC,0x00CD,0x00CE,0x00CF,  /* C       */

/*          0      1      2      3      4      5      6      7     */
         0x0110,0x0143,0x00D2,0x00D3,0x00D4,0x0150,0x00D6,0x015A,  /* D       */

/*          8      9      A      B      C      D      E      F     */
         0x0170,0x00D9,0x00DA,0x00DB,0x00DC,0x0118,0x021A,0x00DF,  /* D       */

/*          0      1      2      3      4      5      6      7     */
         0x00E0,0x00E1,0x00E2,0x0103,0x00E4,0x0107,0x00E6,0x00E7,  /* E       */

/*          8      9      A      B      C      D      E      F     */
         0x00E8,0x00E9,0x00EA,0x00EB,0x00EC,0x00ED,0x00EE,0x00EF,  /* E       */

/*          0      1      2      3      4      5      6      7     */
         0x0111,0x0144,0x00F2,0x00F3,0x00F4,0x0151,0x00F6,0x015B,  /* F       */

/*          8      9      A      B      C      D      E      F     */
         0x0171,0x00F9,0x00FA,0x00FB,0x00FC,0x0119,0x021B,0x00FF   /* F       */
};


/*********************************************************************
***                                                                ***
***            WINDOWS-CODEPAGE 932 to and from UNICODE            ***
***                                                                ***
***                Compressed conversion table data                ***
***                                                                ***
*********************************************************************/

/**
* binary information about huffman coding used in the array ucrg_code_cp932
*/
static unsigned char ucrg_huff_cp932[181] = {230,12,131,85,85,85,71,154,139,247,
  162,119,213,61,37,176,165,143,232,38,86,36,187,117,85,85,85,85,85,64,93,213,
  85,72,114,234,170,170,170,170,170,101,213,85,82,183,85,85,11,170,183,85,90,
  150,234,221,47,117,85,85,64,101,213,85,80,7,186,170,170,165,93,85,82,231,85,
  26,244,81,123,46,35,183,92,201,170,221,12,226,140,97,84,162,235,120,154,143,
  213,219,169,207,93,205,201,201,13,58,111,93,210,70,169,188,248,119,155,157,
  206,154,197,209,123,230,204,242,246,106,221,204,200,9,71,179,181,171,171,150,
  50,189,191,155,6,91,182,109,245,119,160,10,12,111,142,82,205,92,187,148,207,
  109,239,98,205,122,70,20,3,114,19,115,186,147,122,219,229,245,143,209,144,78,
  139,158,64
};
/**
* data readable by m_decode_presence() about unused areas in the CP-932-encoding
*/
static unsigned char ucrg_holes_cp932[43] = {206,154,121,240,47,30,106,214,93,
  162,183,231,138,77,67,148,57,156,254,155,73,190,112,115,37,213,247,243,4,154,
  105,24,231,45,103,32,27,211,193,107,241,16,160
};
/**
* data about the encoding meant by ied_chs_wcp_932 (Japanese),
* in a format that m_get_tab_mb_to_uni() can use to build a decoding-table
*/
static unsigned char ucrg_code_cp932[10041] = {0,5,13,24,178,73,187,209,233,83,
  54,71,139,48,61,44,253,239,63,216,7,128,119,239,217,212,211,127,235,94,224,
  198,62,107,2,7,113,60,8,53,192,113,58,24,73,147,234,131,1,87,189,1,91,168,8,
  140,77,182,57,137,36,102,92,199,43,132,235,185,61,20,83,230,47,89,2,5,175,59,
  23,178,170,84,135,103,115,128,232,224,19,198,63,127,9,233,45,28,198,6,38,46,
  133,39,200,33,5,102,10,173,110,238,203,53,233,149,225,22,175,1,162,84,40,161,
  238,173,40,177,67,48,29,53,133,58,0,40,1,24,0,0,0,0,0,90,160,8,91,8,81,207,
  72,104,64,40,0,210,25,2,194,41,91,74,194,183,88,6,18,72,43,86,0,149,205,8,161,
  66,61,103,172,173,101,9,86,84,1,20,133,78,144,156,213,2,118,2,150,4,91,2,18,
  222,161,52,110,128,44,157,0,100,64,0,156,176,0,132,60,16,97,198,0,88,202,33,
  179,144,10,158,120,2,0,68,244,0,128,24,117,172,125,87,125,35,127,151,100,64,
  3,226,152,212,129,231,179,10,104,143,104,19,200,33,117,1,40,10,7,240,35,220,
  85,12,64,36,26,0,0,50,0,50,116,117,171,58,80,217,33,208,226,33,86,160,59,8,
  78,157,84,10,25,164,114,84,193,54,102,231,224,110,80,2,209,57,81,66,33,93,148,
  64,2,146,11,71,27,75,96,2,109,52,59,55,39,88,106,137,137,19,44,19,164,89,144,
  100,160,0,7,50,160,64,0,113,48,231,197,244,40,92,137,161,188,224,104,88,131,
  213,141,0,118,129,59,21,96,32,15,90,64,1,13,192,132,38,144,83,152,195,247,1,
  23,56,112,32,18,203,190,7,42,97,72,0,64,69,179,110,120,0,55,146,32,0,6,33,142,
  100,128,150,28,192,129,17,4,29,80,152,157,208,52,34,180,115,66,41,74,213,143,
  17,99,112,48,197,180,17,101,61,170,4,90,184,217,173,128,87,150,153,135,0,11,
  14,98,48,5,17,16,81,1,154,68,130,34,85,39,175,237,84,36,136,4,1,16,8,83,3,184,
  166,148,80,4,156,244,0,0,79,248,52,43,163,146,72,16,72,21,80,133,239,182,2,
  22,96,3,176,6,121,15,178,202,106,6,135,96,8,129,16,0,223,202,86,232,148,64,
  93,160,194,224,42,96,0,208,75,84,16,254,90,224,6,5,76,33,32,11,9,6,59,248,23,
  17,226,102,77,225,64,42,136,243,0,68,108,184,4,17,138,58,225,45,136,32,3,176,
  6,0,86,30,8,4,0,200,10,48,52,176,24,244,33,32,150,3,241,130,86,29,153,0,32,
  30,6,134,122,227,30,104,93,144,83,64,76,188,80,157,128,76,209,162,246,56,19,
  0,24,212,129,131,0,112,33,83,59,17,101,214,168,128,188,160,0,0,59,0,0,26,202,
  13,250,103,123,121,208,132,77,5,13,226,25,81,72,33,108,12,68,193,39,202,64,
  1,180,58,97,59,74,1,133,16,4,16,212,0,192,219,0,20,37,104,11,64,76,26,236,14,
  128,88,20,148,1,200,36,0,65,21,11,196,49,1,194,72,10,20,59,1,194,123,2,130,
  99,172,138,171,165,29,8,135,36,3,218,0,9,207,180,41,98,1,115,122,186,251,35,
  189,111,68,248,18,14,139,195,36,132,245,148,0,51,12,4,13,4,164,99,206,18,138,
  200,6,13,37,76,162,44,7,207,64,252,13,160,144,52,149,88,84,47,1,18,200,194,
  0,192,224,160,16,45,52,68,6,42,101,243,205,161,65,210,4,203,0,2,22,85,112,132,
  194,64,5,178,8,128,0,202,200,67,0,0,178,129,100,0,4,192,172,32,76,192,129,50,
  102,245,114,134,200,72,13,128,177,137,204,30,234,96,183,169,11,86,168,16,0,
  40,208,148,98,92,116,69,228,192,168,64,20,244,60,23,188,128,192,136,45,4,176,
  28,182,51,161,237,39,142,0,32,20,114,96,35,3,111,178,49,160,13,141,14,33,2,
  138,152,19,194,10,64,168,0,1,99,5,44,26,64,129,114,24,83,170,22,162,40,3,114,
  237,192,1,3,12,2,199,188,154,5,69,4,18,0,2,72,130,82,228,15,49,32,210,54,80,
  70,0,4,103,128,18,129,64,25,129,217,122,26,125,82,228,211,156,250,227,24,92,
  220,107,8,155,220,24,20,128,201,154,222,80,15,48,128,183,16,145,147,0,51,200,
  33,65,19,14,193,9,198,200,200,0,30,98,136,8,183,132,17,128,52,15,50,203,81,
  99,192,20,0,3,129,175,3,245,66,144,128,160,115,155,88,52,127,132,128,27,202,
  32,96,158,130,24,15,92,11,0,49,177,0,22,167,166,23,60,48,6,140,92,5,139,9,32,
  184,0,179,237,228,71,9,60,1,38,34,3,17,176,56,176,59,188,6,11,0,65,232,61,100,
  200,31,97,104,28,4,146,135,198,101,118,180,0,208,34,184,44,195,71,130,23,64,
  3,83,80,2,200,130,44,72,78,89,32,145,0,33,171,130,208,9,168,148,16,24,151,66,
  32,218,84,150,80,73,86,189,100,51,9,100,108,0,0,4,0,128,32,12,160,2,69,16,40,
  187,202,40,106,34,135,129,34,237,0,8,0,96,64,49,102,5,120,118,115,0,160,2,211,
  102,1,3,3,1,203,112,141,36,144,6,117,57,4,81,86,64,12,60,52,65,143,16,3,112,
  178,242,0,64,0,81,193,5,1,108,42,0,32,63,68,16,26,9,160,6,130,4,36,192,18,210,
  166,240,64,215,195,176,9,212,2,142,140,64,33,109,47,48,24,177,19,201,64,2,9,
  130,139,44,162,201,156,251,126,224,14,160,71,74,0,0,160,116,96,2,128,242,68,
  25,216,3,75,25,44,146,128,0,8,6,5,94,88,166,21,50,119,104,229,33,200,29,5,0,
  0,241,129,183,8,46,133,172,14,234,53,191,192,32,4,177,56,36,179,31,93,3,32,
  32,16,110,208,25,197,96,33,170,138,57,16,16,225,144,208,32,130,183,195,90,2,
  35,46,51,97,65,84,162,205,244,10,32,38,105,238,16,0,174,64,118,196,52,65,108,
  83,18,192,128,165,70,128,129,65,13,18,142,52,22,32,0,192,138,6,145,226,192,
  9,89,128,3,150,84,3,84,156,14,248,132,66,128,16,1,102,62,32,224,0,166,183,67,
  108,203,33,0,10,26,14,33,137,33,200,7,226,50,114,96,81,29,45,105,144,131,10,
  9,128,80,77,128,2,14,187,65,65,240,0,11,53,133,116,57,128,205,53,208,174,43,
  128,138,105,8,50,50,82,16,148,148,25,242,184,210,70,134,212,19,68,77,36,101,
  64,235,139,157,0,111,76,64,26,160,73,69,129,29,89,80,4,98,0,4,4,32,139,122,
  132,12,16,21,90,0,0,160,160,136,181,68,204,204,116,175,80,130,249,168,27,165,
  0,182,1,3,34,223,95,32,132,236,4,20,91,8,216,3,1,111,38,135,228,90,10,60,87,
  136,64,192,13,35,23,33,65,111,15,172,15,241,0,47,152,23,174,12,48,96,12,105,
  125,149,53,20,105,203,156,88,39,128,27,0,128,138,236,9,33,38,172,80,12,2,52,
  166,96,129,136,249,144,80,217,228,13,200,0,49,88,5,48,96,1,114,1,63,131,193,
  64,136,251,90,51,95,128,17,245,88,16,2,189,28,214,16,252,149,128,0,6,241,230,
  210,128,180,19,4,193,80,254,0,1,135,103,183,58,146,4,148,176,78,197,113,18,
  128,198,43,206,146,2,102,253,53,212,60,75,150,217,111,129,66,103,164,10,136,
  14,237,120,0,38,4,4,210,112,210,160,12,176,13,80,32,16,7,16,4,106,14,8,10,230,
  9,72,73,131,64,6,32,146,67,15,107,160,40,144,177,105,74,240,0,64,89,0,161,64,
  32,134,3,233,100,0,24,176,73,96,95,120,25,197,160,192,32,8,6,70,105,120,12,
  150,152,40,196,17,128,176,45,134,64,0,128,68,200,32,2,112,40,248,126,36,41,
  40,101,0,248,134,17,31,51,1,156,36,172,26,196,0,193,181,144,29,116,38,4,129,
  132,17,150,88,4,232,153,57,18,34,67,97,245,157,35,168,8,4,0,0,75,74,136,111,
  58,210,6,143,56,2,176,4,176,2,156,252,168,39,241,242,109,20,40,130,231,134,
  5,6,105,67,128,7,119,176,148,96,101,4,40,132,106,141,188,168,32,45,103,139,
  44,132,156,83,99,0,116,1,1,161,64,16,0,1,52,24,201,59,11,112,169,15,141,97,
  15,218,191,74,208,16,45,137,64,84,100,2,34,33,0,181,227,187,91,26,4,0,6,152,
  80,2,81,228,17,40,4,0,123,96,32,19,37,36,208,114,218,176,178,96,162,161,128,
  134,50,16,42,102,76,1,152,134,179,162,0,85,160,7,33,116,192,14,202,41,131,144,
  129,53,121,246,166,56,208,12,69,108,187,182,168,160,6,116,80,69,101,124,33,
  12,16,52,0,16,202,23,89,69,6,233,66,217,72,0,240,1,220,98,2,128,48,0,20,24,
  2,87,171,184,18,3,10,24,48,4,252,20,115,150,202,32,46,9,225,8,93,208,204,180,
  229,11,25,96,91,0,75,42,234,136,224,56,47,193,81,64,131,41,18,146,69,88,60,
  14,217,41,142,104,0,16,81,64,86,132,234,119,42,65,160,116,35,136,8,70,152,98,
  24,4,4,208,5,57,217,48,237,1,48,0,0,251,81,130,70,0,180,159,133,68,40,151,20,
  157,70,32,104,58,34,37,64,111,227,105,224,65,73,122,159,32,44,195,190,182,0,
  40,4,175,168,0,175,147,247,193,4,10,215,188,0,98,254,19,11,145,96,208,24,96,
  15,20,105,176,3,252,50,68,37,155,4,92,148,66,163,46,158,185,40,160,0,0,48,141,
  183,194,194,244,41,96,226,136,16,255,12,5,12,20,232,105,5,80,143,200,13,180,
  132,76,0,159,8,128,37,245,255,144,232,28,162,28,182,122,0,0,27,240,17,252,190,
  3,130,0,230,80,197,107,120,100,224,20,66,224,1,255,40,25,8,196,136,8,2,40,128,
  129,36,171,102,141,89,52,168,4,135,248,63,66,131,165,3,132,48,137,64,22,192,
  155,105,111,162,1,225,35,53,225,40,0,112,40,102,80,122,19,32,39,11,130,235,
  1,251,199,218,21,64,59,116,23,87,160,7,63,160,253,0,18,161,155,52,7,130,80,
  118,129,144,58,129,146,48,43,64,152,73,35,154,137,238,64,160,178,0,126,194,
  154,53,12,191,211,80,31,48,10,162,10,100,30,146,76,208,124,13,14,136,215,47,
  5,13,111,229,202,116,167,4,199,182,165,248,240,39,163,41,177,0,40,186,212,19,
  114,228,70,122,113,238,128,1,34,153,244,48,64,55,32,30,193,185,9,224,19,41,
  36,0,132,0,0,152,237,45,210,0,56,0,0,57,9,2,9,162,192,74,50,57,142,212,44,8,
  2,161,196,0,209,53,19,250,104,34,17,54,220,2,0,32,52,0,98,50,32,113,9,0,230,
  176,94,240,2,251,32,72,200,16,65,24,1,1,86,250,25,178,6,70,176,88,184,57,162,
  68,240,8,11,144,160,8,143,16,144,21,231,142,136,140,138,198,8,4,1,195,101,224,
  32,44,166,185,6,208,167,24,28,134,219,134,228,4,2,242,90,231,128,106,1,160,
  11,0,105,0,26,84,116,55,102,192,1,160,70,215,8,195,68,216,78,2,129,123,32,10,
  16,80,73,48,5,1,56,10,33,47,8,187,36,14,16,8,80,129,34,0,224,11,132,32,27,32,
  192,108,18,205,200,130,76,30,160,0,107,160,38,64,160,12,35,62,41,38,91,8,5,
  252,197,236,128,0,0,75,213,136,76,8,34,214,132,23,99,5,0,82,117,123,42,44,129,
  1,65,4,145,82,193,68,164,80,0,106,160,2,32,7,64,131,34,68,45,176,104,7,41,28,
  37,48,0,0,168,71,77,181,135,214,0,118,22,105,152,37,32,48,38,64,48,133,46,112,
  18,194,10,160,55,145,171,203,154,234,90,32,217,217,1,92,23,58,208,213,139,232,
  24,20,33,32,191,67,129,65,97,113,86,53,192,184,123,132,74,40,232,172,116,72,
  26,0,240,65,216,63,92,250,192,16,3,62,223,64,0,119,100,193,238,77,66,58,168,
  201,253,104,162,7,78,0,19,32,136,32,0,21,27,100,24,41,0,1,141,47,77,194,167,
  60,1,42,50,247,0,4,225,72,53,147,201,40,74,154,134,1,161,31,14,200,112,152,
  52,1,57,99,81,35,4,90,113,57,182,212,115,0,32,139,0,8,11,114,172,92,126,164,
  242,128,6,193,178,179,216,136,3,96,33,3,225,248,149,24,2,64,162,1,37,31,4,40,
  3,1,193,66,0,95,131,139,197,20,209,222,146,227,184,88,17,238,101,130,224,168,
  76,1,146,0,6,160,38,225,18,28,6,169,208,155,6,107,192,35,209,92,18,158,58,8,
  106,89,216,101,118,93,86,129,0,153,87,193,172,64,14,101,117,140,96,66,1,208,
  93,8,208,160,13,47,43,194,224,120,178,62,96,157,106,227,42,23,205,211,74,23,
  101,168,5,234,13,227,82,20,35,134,164,16,143,199,66,114,5,95,163,98,24,58,224,
  0,23,247,248,42,141,104,31,4,0,34,132,8,192,0,146,9,37,225,240,16,17,33,128,
  0,3,129,36,9,14,0,2,155,17,12,127,207,154,131,206,12,106,162,67,62,207,246,
  126,96,48,17,254,48,208,2,119,124,134,3,77,17,114,193,66,89,203,185,146,87,
  149,39,163,82,80,11,228,208,184,23,234,4,200,91,232,42,6,101,232,30,64,144,
  194,73,163,193,136,189,88,77,42,11,1,10,31,89,31,96,11,251,2,0,108,150,120,
  160,192,166,42,39,83,68,236,130,109,129,211,78,207,3,169,0,182,235,34,97,16,
  27,120,14,160,120,74,133,130,5,240,130,148,16,131,160,233,144,6,194,126,113,
  140,32,12,249,193,33,102,64,216,215,161,83,132,220,163,95,168,107,115,136,130,
  129,165,146,143,194,24,151,188,108,80,3,148,2,249,128,12,37,150,2,135,98,22,
  21,177,248,0,4,202,232,0,51,160,215,176,168,212,16,88,8,9,132,0,200,101,148,
  60,149,171,65,235,168,116,68,108,249,149,113,132,15,240,24,32,40,5,138,10,212,
  72,144,81,90,129,204,129,118,146,16,137,9,48,6,73,146,138,24,38,12,3,185,12,
  55,212,4,80,36,182,88,17,84,222,83,216,226,77,70,35,17,92,158,44,210,194,182,
  192,98,63,128,189,119,58,242,133,2,180,114,144,136,61,34,0,26,103,160,21,200,
  158,3,71,169,91,187,52,56,73,50,68,243,116,173,219,132,215,47,35,40,156,249,
  247,225,246,16,138,38,83,246,96,211,162,136,45,44,205,74,108,93,134,9,188,90,
  215,208,39,208,110,246,200,177,180,32,246,212,190,101,164,128,11,230,64,3,176,
  0,4,125,2,46,219,135,20,140,229,202,219,79,182,0,213,137,204,145,58,199,120,
  234,135,140,78,174,173,222,145,105,54,12,97,82,208,25,46,154,255,228,106,75,
  7,164,140,37,77,33,228,77,203,29,166,249,209,21,105,192,178,244,80,90,0,1,187,
  104,220,212,47,160,54,14,183,193,238,138,104,163,190,250,56,12,142,121,28,220,
  33,34,227,124,111,198,244,53,241,88,61,49,203,19,148,34,236,175,71,174,141,
  143,171,142,12,4,197,13,236,175,72,176,184,39,154,107,159,176,3,228,50,201,
  3,248,36,216,16,175,146,45,0,91,204,234,128,84,110,39,145,246,87,70,85,151,
  188,46,15,117,5,225,0,171,62,31,68,42,96,229,152,252,176,63,202,98,122,151,
  172,205,184,93,42,152,160,237,184,192,129,2,121,148,0,0,65,30,156,205,110,41,
  88,1,235,9,117,182,28,181,78,197,200,101,198,91,55,249,204,84,162,24,138,135,
  18,233,34,64,0,86,237,157,69,228,75,46,71,69,0,103,92,59,22,0,97,150,201,54,
  121,237,199,203,20,53,52,38,188,149,151,207,95,105,124,209,71,19,64,74,188,
  213,31,18,187,43,125,207,120,9,81,17,148,54,167,178,157,107,2,10,89,202,113,
  104,251,100,166,144,86,153,153,50,63,90,209,157,150,171,77,249,55,109,54,235,
  61,133,42,142,153,253,169,202,202,182,36,73,100,17,110,90,206,96,160,120,192,
  15,131,6,19,35,229,20,82,111,198,190,212,45,37,100,16,150,80,29,67,180,202,
  155,37,180,171,104,133,214,75,11,177,193,227,78,15,254,32,42,53,83,232,17,223,
  97,21,80,79,16,40,172,80,201,7,221,202,145,252,113,2,146,164,125,155,94,111,
  11,132,91,121,171,134,85,85,100,226,247,1,23,194,190,33,80,230,195,168,22,118,
  2,92,84,29,4,209,0,29,43,229,225,135,195,29,35,238,230,6,91,7,43,111,98,72,
  70,84,133,90,152,20,131,17,49,64,123,158,94,84,57,212,59,169,132,77,25,103,
  106,15,167,74,198,134,188,178,205,33,20,39,185,71,67,100,25,222,200,5,84,213,
  70,225,169,78,159,179,205,126,10,7,52,232,216,211,148,181,0,54,58,122,40,108,
  42,0,64,10,104,51,40,160,249,137,188,221,164,246,70,254,79,100,228,137,243,
  157,162,109,130,135,107,42,148,18,9,132,92,227,200,191,39,49,91,172,69,84,42,
  180,241,47,184,6,136,86,90,145,40,253,228,217,16,134,15,137,199,107,89,21,22,
  169,4,125,248,195,3,133,44,61,115,120,39,211,154,5,197,127,22,222,153,87,40,
  129,187,87,63,83,230,158,131,1,121,145,238,101,136,207,47,141,12,114,108,214,
  218,44,6,170,70,158,218,48,172,219,80,210,179,182,119,87,185,36,21,117,219,
  75,253,227,77,140,45,177,63,153,64,47,76,82,52,250,202,180,55,96,150,167,112,
  111,193,215,215,77,170,218,167,153,163,22,175,87,168,220,207,242,92,22,135,
  19,156,109,119,114,198,253,67,208,75,69,29,162,161,131,139,198,17,223,16,226,
  61,3,198,203,116,119,23,69,169,177,155,105,66,46,189,138,180,92,241,215,114,
  153,32,146,99,214,168,120,111,44,119,96,148,185,180,70,64,201,81,42,86,225,
  231,163,118,187,184,75,3,154,61,27,12,27,18,164,101,112,161,178,90,37,21,218,
  96,178,121,220,18,159,68,7,218,103,90,116,109,234,76,31,179,60,202,111,208,
  159,37,243,222,163,249,68,96,228,251,213,144,177,161,97,208,18,112,220,93,75,
  34,211,204,150,25,52,13,87,149,84,196,82,90,29,29,26,53,16,177,39,182,199,219,
  214,220,31,68,162,144,228,167,141,81,182,229,59,104,163,192,124,250,32,44,240,
  225,57,189,90,58,170,25,211,76,70,157,251,143,77,60,195,191,204,64,132,149,
  185,42,213,11,26,26,189,142,108,99,113,204,5,253,168,38,67,165,47,108,183,187,
  30,209,151,153,91,87,11,78,162,63,106,107,160,221,89,137,242,137,235,5,28,112,
  194,126,192,39,125,170,88,141,245,21,200,103,153,116,53,158,41,189,205,86,248,
  198,197,203,52,140,187,81,21,45,194,179,129,104,157,179,112,148,81,47,17,247,
  16,130,224,33,90,71,36,201,53,232,101,10,216,80,55,161,186,234,85,135,100,206,
  5,40,139,12,38,247,64,230,28,109,53,94,130,220,69,158,181,16,101,53,154,169,
  32,40,30,170,125,165,5,216,143,65,57,65,162,160,92,30,150,62,52,44,233,96,24,
  94,145,131,165,134,35,129,193,5,119,242,103,243,91,122,14,80,78,142,34,1,253,
  10,219,16,223,62,107,56,182,100,98,1,177,150,42,99,119,27,235,186,237,197,64,
  44,60,248,201,149,162,150,165,227,95,182,20,147,44,122,58,89,186,41,123,152,
  117,237,155,220,104,10,190,48,27,42,183,231,103,99,169,216,65,44,188,15,12,
  166,11,239,4,229,6,100,90,96,65,152,85,67,24,88,232,183,110,57,107,192,214,
  61,224,110,203,76,168,157,16,179,97,68,83,186,196,114,64,148,37,162,199,141,
  247,122,108,8,181,1,213,173,56,74,184,205,20,214,20,144,147,65,250,198,81,222,
  214,135,0,140,44,138,109,189,52,10,222,213,152,45,3,155,182,245,62,99,38,9,
  219,122,210,193,147,9,195,55,24,52,27,182,121,100,212,83,24,6,207,188,226,95,
  154,70,79,109,120,46,48,79,19,16,245,224,109,133,123,231,64,129,136,101,202,
  117,197,113,120,178,235,24,1,217,198,175,253,1,69,245,188,142,243,105,169,143,
  32,179,98,2,119,60,177,205,119,176,136,135,150,194,67,124,75,75,156,219,108,
  126,26,193,91,130,4,83,75,224,179,193,39,133,131,37,123,231,79,3,200,84,116,
  106,176,161,138,159,239,210,140,146,10,212,88,148,122,121,253,104,200,164,27,
  161,32,219,65,132,70,88,4,131,246,37,248,4,54,179,163,107,106,191,85,105,53,
  178,205,207,244,35,29,140,204,30,220,21,160,129,2,5,208,61,113,244,101,151,
  165,166,111,120,250,96,97,30,180,48,98,170,231,154,235,87,5,81,84,8,108,212,
  164,138,132,166,34,214,99,144,178,211,182,169,165,190,97,137,54,102,200,152,
  227,172,2,124,207,119,233,214,243,137,21,174,170,225,84,53,170,127,165,185,
  194,198,136,137,133,157,117,72,186,96,197,102,145,146,187,180,18,15,182,103,
  18,203,185,186,204,26,27,240,164,135,81,210,73,159,164,24,75,81,211,147,165,
  23,218,158,218,154,194,54,10,117,193,145,132,182,208,213,172,14,139,44,255,
  122,114,57,18,216,12,167,144,12,99,110,106,176,85,128,4,71,75,101,80,223,78,
  77,55,32,190,223,48,48,229,23,232,19,135,89,66,78,255,176,214,16,92,189,185,
  58,240,197,188,30,172,23,26,195,180,101,212,163,119,2,126,17,1,130,60,101,39,
  159,48,89,185,248,11,67,93,27,233,91,198,209,255,198,70,97,35,37,35,6,243,47,
  86,148,240,26,81,215,111,84,24,150,54,27,71,154,190,133,38,244,58,38,35,244,
  223,198,0,96,196,133,192,55,14,227,32,146,198,233,181,59,121,224,198,108,4,
  81,194,213,144,74,229,149,226,228,177,195,200,3,128,105,252,25,21,155,69,67,
  128,45,218,227,13,179,197,112,129,132,12,6,28,119,7,15,14,62,60,220,239,65,
  89,169,214,67,58,16,77,196,33,123,185,189,33,12,19,133,248,237,244,255,124,
  162,225,65,2,225,75,82,9,13,43,167,97,163,81,63,198,14,72,137,103,206,44,234,
  228,155,172,180,143,243,139,56,84,55,49,187,107,5,108,16,23,109,5,168,136,165,
  245,67,161,179,185,149,214,223,180,118,204,146,55,126,73,95,196,94,94,50,229,
  41,166,142,38,173,20,87,121,80,29,113,132,196,69,110,70,211,11,139,12,6,104,
  96,253,80,69,38,57,226,93,47,210,124,13,36,109,115,241,183,21,58,52,232,224,
  3,132,127,197,165,188,180,99,123,118,161,21,44,77,21,196,202,243,0,210,100,
  152,138,226,144,231,219,143,192,227,157,56,89,61,68,27,26,79,172,189,194,224,
  196,181,126,82,141,102,79,23,22,232,53,94,15,193,24,252,159,240,154,169,91,
  196,235,81,149,79,204,116,178,80,82,29,165,139,249,215,186,208,22,233,126,65,
  11,138,117,154,113,184,35,54,38,177,210,30,208,56,154,36,179,18,255,80,156,
  164,221,162,215,119,72,218,57,250,74,179,20,77,153,214,131,169,239,204,231,
  231,251,122,213,123,207,144,72,122,93,88,252,121,210,39,61,184,47,114,246,94,
  78,180,131,239,34,247,121,254,148,27,151,13,90,8,0,112,30,224,26,32,7,241,133,
  128,43,128,7,152,221,111,16,166,132,123,141,98,20,42,130,152,16,109,178,233,
  66,15,58,5,136,78,137,184,88,55,2,58,71,208,115,40,28,0,50,123,119,7,236,203,
  49,65,202,207,115,64,169,151,220,98,6,70,102,146,188,67,206,137,221,130,217,
  167,34,12,41,207,193,12,3,113,186,118,206,76,163,233,143,153,221,19,63,64,35,
  100,165,174,180,126,214,116,232,170,92,95,44,152,240,236,78,199,92,137,34,205,
  37,121,135,203,73,81,139,41,180,175,151,164,223,237,115,103,35,81,110,242,235,
  85,243,175,52,132,246,137,116,136,140,3,17,22,25,105,109,170,170,128,224,181,
  202,18,155,124,230,161,160,228,200,170,118,190,83,150,105,149,204,230,220,189,
  168,120,35,218,208,35,54,58,209,24,26,167,250,57,88,191,196,30,51,6,184,233,
  156,106,210,84,212,248,137,248,120,198,166,231,138,157,113,129,182,80,23,131,
  0,15,136,47,21,153,97,182,125,43,42,53,108,177,128,154,76,10,247,23,211,170,
  243,61,180,8,76,21,17,140,187,227,50,94,212,4,35,24,38,212,194,121,108,204,
  118,80,17,253,4,196,188,255,44,5,167,211,213,115,125,80,92,45,247,118,49,212,
  27,68,164,25,171,240,135,22,105,240,89,118,204,200,97,209,108,45,116,162,114,
  65,163,29,213,184,143,69,69,227,138,52,245,87,45,73,139,243,106,210,52,99,215,
  167,164,235,252,124,119,25,170,113,11,91,86,118,45,105,69,97,163,1,24,120,18,
  24,17,177,80,217,8,232,28,186,7,105,128,99,166,254,36,14,116,58,2,13,128,16,
  89,209,198,84,97,131,154,67,89,248,82,217,0,131,29,91,156,142,116,31,57,155,
  135,30,167,212,169,25,49,31,219,195,201,68,40,28,33,232,126,235,202,69,179,
  131,157,203,88,142,0,30,53,195,19,190,49,211,179,20,142,35,190,10,34,8,100,
  31,165,187,240,55,95,39,127,108,77,69,155,133,95,214,147,70,87,110,177,100,
  26,31,204,142,89,134,98,167,13,11,164,44,164,153,168,20,177,215,102,83,15,235,
  24,118,77,167,50,36,166,158,48,237,148,204,79,39,185,201,52,240,140,168,66,
  114,113,228,204,70,135,159,133,87,40,190,79,19,11,208,121,73,231,26,179,46,
  155,124,184,141,215,42,177,16,193,65,113,173,60,1,63,149,139,147,254,110,49,
  38,73,216,142,227,39,121,9,62,148,103,162,43,40,186,210,217,119,77,197,67,104,
  163,90,208,170,249,234,69,24,126,165,144,148,82,49,97,18,84,97,148,154,137,
  75,65,171,10,184,157,178,163,117,115,39,115,94,67,252,204,141,58,44,25,50,29,
  17,1,15,37,205,255,48,208,178,255,218,95,118,132,208,67,129,32,12,28,240,203,
  223,192,21,17,56,228,51,76,107,116,196,82,87,122,90,46,99,226,108,126,50,204,
  211,83,187,198,17,225,114,183,171,159,226,158,60,28,196,70,179,154,161,103,
  44,53,119,198,18,123,47,46,180,166,237,185,12,229,243,136,123,199,232,9,101,
  57,192,111,28,234,11,151,245,209,55,160,82,137,113,195,184,154,35,145,37,226,
  101,9,71,122,6,96,206,217,0,51,128,153,143,253,170,186,82,185,66,94,86,94,91,
  75,221,66,23,193,188,168,236,227,244,113,48,0,110,117,225,184,0,71,67,66,246,
  248,238,31,168,73,182,234,47,159,10,90,254,216,87,128,58,239,49,115,86,113,
  147,106,102,82,10,194,200,63,3,183,97,224,184,82,106,40,22,86,174,132,144,199,
  194,207,219,73,106,226,211,114,215,145,129,89,175,64,128,100,65,162,187,65,
  206,178,135,244,137,173,106,234,178,116,15,96,168,242,138,102,150,190,162,248,
  130,200,57,224,112,143,116,57,190,91,198,106,162,178,7,83,43,238,11,145,58,
  248,68,219,106,151,162,224,89,204,28,195,169,41,141,151,42,64,247,0,58,52,201,
  94,41,159,100,30,217,125,237,128,100,207,153,130,225,169,8,205,88,158,170,165,
  53,161,181,228,182,248,63,57,73,62,22,50,98,162,116,58,149,189,238,9,185,26,
  253,114,176,154,117,112,56,67,168,167,148,109,152,167,165,249,201,98,121,183,
  215,159,160,35,195,155,74,145,37,145,192,108,85,160,146,95,174,103,163,2,108,
  253,32,32,11,243,80,169,33,122,55,118,83,181,102,91,200,193,109,148,166,28,
  140,169,246,192,102,128,213,204,97,86,108,139,0,35,235,21,134,154,227,195,23,
  150,26,99,51,32,202,29,126,244,155,78,41,174,57,176,198,71,35,118,164,125,79,
  141,90,175,59,51,89,33,152,29,120,159,19,235,58,111,238,52,125,230,141,233,
  132,136,46,30,248,135,245,95,101,213,164,139,52,222,231,89,102,46,204,49,64,
  139,182,72,145,22,91,210,144,245,226,238,195,140,47,223,123,14,18,104,33,198,
  88,205,85,234,36,230,110,39,214,127,3,10,143,225,99,130,150,184,170,142,30,
  116,241,171,107,26,13,44,61,134,127,4,16,61,147,13,247,12,27,94,153,105,237,
  136,126,50,5,69,31,246,54,144,43,28,58,237,185,86,235,19,1,170,163,92,44,147,
  200,91,71,30,34,53,238,50,28,240,154,45,174,110,172,146,203,171,145,163,41,
  184,227,11,76,114,81,121,83,13,107,121,226,39,134,236,158,179,115,177,120,9,
  137,156,175,78,26,14,220,51,226,176,113,64,195,201,172,20,139,125,20,203,127,
  140,130,142,43,135,200,198,230,157,220,100,24,58,111,15,227,150,92,57,29,182,
  115,40,112,145,128,36,118,99,76,237,173,190,5,152,133,44,253,61,28,90,97,108,
  24,40,141,162,11,89,190,58,7,126,154,218,123,100,164,171,73,207,123,46,205,
  70,106,48,139,7,56,88,36,91,7,49,25,59,61,192,175,69,218,67,83,93,12,192,123,
  81,246,169,112,251,19,129,84,221,43,28,3,33,180,93,151,90,65,115,21,206,73,
  51,38,80,73,140,135,0,204,31,22,53,63,8,125,178,54,170,188,142,245,15,118,131,
  128,57,79,54,132,152,74,64,56,165,36,67,3,129,218,13,199,20,216,2,208,150,149,
  13,140,241,81,14,69,240,83,67,169,187,22,210,224,6,219,110,89,42,31,243,201,
  116,145,109,176,68,41,249,191,1,230,192,169,123,135,227,152,176,197,160,156,
  5,91,69,65,74,51,79,47,87,99,109,68,204,249,192,76,181,221,116,61,54,106,149,
  109,23,201,84,245,34,83,177,29,23,105,164,180,189,4,158,224,230,49,120,18,52,
  81,30,235,22,231,92,38,7,214,11,176,130,51,234,84,99,235,106,167,96,129,163,
  87,121,218,140,230,204,173,139,237,91,69,146,85,210,33,121,169,130,156,47,82,
  91,178,190,253,146,228,85,167,32,161,58,21,119,149,10,8,242,171,129,220,155,
  152,32,151,177,87,33,134,202,155,58,180,35,30,158,195,102,1,137,104,121,206,
  1,171,223,137,235,110,151,156,228,166,108,255,126,33,156,25,192,206,125,77,
  244,22,47,202,144,232,40,120,3,229,246,114,23,107,209,65,132,4,129,27,190,178,
  76,200,194,193,200,133,150,202,209,241,80,61,48,159,57,175,162,185,61,66,145,
  30,119,2,136,212,160,161,8,110,215,185,212,14,88,133,234,55,218,87,106,230,
  141,50,187,167,222,69,120,151,233,63,173,192,158,237,191,80,190,50,149,74,39,
  80,241,105,240,107,29,39,122,79,198,70,143,147,64,42,81,174,187,53,132,118,
  241,223,224,108,244,74,246,211,130,237,66,234,42,91,22,45,208,140,44,77,100,
  186,208,63,176,48,64,45,104,210,50,140,125,74,97,197,141,49,42,33,78,180,2,
  219,88,69,187,203,27,150,88,191,12,40,237,206,167,68,114,139,2,18,25,99,241,
  97,143,61,146,203,38,212,208,168,78,199,79,167,58,15,128,72,183,29,196,13,96,
  125,134,68,243,207,53,146,208,44,157,37,54,0,209,10,217,119,46,101,0,20,83,
  101,241,97,68,244,159,64,239,25,7,141,20,93,153,10,50,141,203,246,191,68,81,
  244,193,65,187,110,94,237,135,87,195,193,53,224,232,185,159,203,136,201,20,
  208,56,77,2,186,131,207,216,159,115,169,210,79,223,58,181,210,15,134,181,166,
  244,104,81,89,228,127,210,51,121,184,206,176,198,202,139,156,77,171,38,16,106,
  199,60,86,109,247,70,77,249,204,244,50,63,143,67,169,199,69,103,143,162,250,
  123,27,181,114,252,168,28,88,209,81,177,250,131,196,143,114,132,64,210,152,
  138,49,238,36,23,171,248,82,145,43,214,153,185,168,67,69,141,63,118,41,224,
  228,209,19,20,22,213,177,203,168,58,25,141,150,235,249,5,46,154,73,98,191,174,
  220,6,116,210,197,122,147,18,96,164,115,86,185,30,165,56,76,91,37,179,242,200,
  218,49,238,146,195,21,147,204,49,222,104,27,15,10,144,24,174,161,244,83,254,
  75,166,61,211,176,185,100,35,41,18,218,236,223,162,113,28,247,138,154,44,148,
  229,179,169,145,57,244,32,249,137,239,101,5,232,145,21,186,51,56,137,0,3,36,
  110,112,86,91,27,113,124,193,201,14,18,241,24,242,241,40,252,232,123,26,156,
  201,19,3,217,32,2,173,28,227,47,151,175,20,251,67,156,43,173,162,78,46,50,26,
  85,137,85,233,10,61,104,17,176,49,219,179,244,244,206,106,165,58,39,43,98,153,
  108,123,79,176,157,59,226,46,138,87,35,154,16,202,165,174,172,74,200,2,198,
  213,94,234,6,170,58,138,90,80,134,103,45,18,246,204,59,56,85,93,49,57,173,133,
  46,66,185,155,112,221,141,111,31,113,43,146,37,39,144,19,76,60,73,82,41,153,
  177,44,140,186,57,162,35,223,163,140,81,246,80,135,61,183,104,126,201,7,54,
  96,132,170,210,172,154,42,245,147,240,45,29,229,126,81,199,90,167,200,236,163,
  59,54,247,146,38,246,126,194,80,224,22,172,98,202,13,194,22,26,209,127,180,
  121,211,30,216,210,4,239,153,114,47,56,159,194,227,45,242,240,7,248,227,45,
  166,97,174,24,159,130,103,232,48,9,45,180,226,156,187,5,225,81,209,81,100,230,
  202,49,127,88,226,32,159,123,198,149,72,59,23,29,52,107,68,134,254,113,175,
  111,84,29,174,165,142,18,121,253,50,145,155,36,37,136,134,84,183,26,70,176,
  8,187,56,3,103,52,42,35,132,10,254,101,228,123,59,13,94,139,40,194,145,94,141,
  169,135,254,16,255,78,186,237,69,96,92,95,227,69,33,93,42,223,86,213,40,200,
  242,35,211,35,210,12,149,85,62,210,137,46,69,100,187,176,113,75,14,199,30,26,
  183,35,18,220,241,220,176,169,29,29,78,139,79,55,199,80,199,94,140,110,203,
  196,19,236,49,195,212,191,133,22,29,36,75,158,61,136,130,132,112,177,74,10,
  63,14,191,83,45,217,99,120,11,39,177,51,13,182,119,164,58,127,13,97,35,234,
  193,192,163,12,64,108,69,197,136,61,228,17,31,253,217,250,87,144,183,156,82,
  54,242,135,8,73,104,208,248,192,213,178,202,71,159,100,38,16,249,91,93,128,
  33,250,37,68,83,42,232,19,89,208,242,13,113,64,190,205,116,24,143,138,49,37,
  46,154,116,233,107,84,20,42,29,158,130,26,245,220,13,138,248,186,242,135,9,
  21,219,196,203,1,40,210,234,168,11,27,98,76,249,225,249,16,191,75,152,247,213,
  23,10,6,248,79,191,22,230,21,143,10,100,21,138,182,147,206,7,6,237,57,52,141,
  192,247,71,244,113,184,161,234,111,45,171,29,12,110,167,236,135,75,31,184,223,
  141,228,198,28,9,8,47,179,34,156,130,138,138,124,140,149,67,100,239,58,5,245,
  194,145,113,85,243,9,77,166,36,9,35,114,200,51,65,127,22,120,219,176,4,242,
  165,20,196,163,5,85,115,29,126,108,197,80,158,80,11,107,165,154,108,64,170,
  32,85,28,117,10,63,0,110,47,193,244,77,200,220,96,87,138,19,134,110,59,33,114,
  215,141,58,104,169,202,49,125,19,197,194,188,191,174,192,221,224,107,216,121,
  248,90,25,218,9,208,2,43,87,39,158,213,243,99,69,112,103,214,2,100,17,55,9,
  198,25,70,24,74,212,35,174,144,20,200,234,36,115,232,155,82,99,144,227,144,
  218,89,13,41,201,50,11,33,32,176,73,199,234,136,253,10,224,212,177,177,23,248,
  140,4,166,104,74,184,69,89,18,52,162,52,105,167,59,155,239,167,175,222,203,
  192,173,72,155,88,93,152,112,232,135,44,21,218,166,112,123,239,147,154,189,
  103,208,46,79,108,29,201,126,5,104,174,77,214,123,2,190,245,232,206,83,194,
  155,197,71,138,63,120,93,111,164,192,184,149,83,11,117,62,172,173,243,239,145,
  203,53,30,89,192,81,251,14,221,6,227,69,103,130,8,172,4,200,114,26,34,200,164,
  72,64,148,207,159,241,246,89,164,250,245,167,195,235,62,87,42,249,230,15,88,
  15,97,60,10,95,96,232,17,136,164,57,8,164,75,107,0,188,1,121,112,147,112,137,
  116,14,31,12,68,219,66,252,26,69,102,112,233,251,240,133,245,156,143,150,72,
  14,19,19,34,151,200,104,155,74,51,213,14,212,135,74,105,145,226,241,75,17,45,
  162,216,14,216,110,188,141,97,229,102,27,159,44,228,112,147,225,54,131,108,
  89,174,227,56,23,174,0,124,128,205,88,6,19,225,91,233,184,69,48,18,48,4,137,
  4,145,14,17,7,9,68,95,163,233,18,26,37,239,134,107,54,174,173,53,253,41,166,
  192,48,161,128,145,175,43,48,91,64,59,125,198,227,50,123,151,250,2,5,229,92,
  108,186,226,185,103,45,224,141,206,239,97,97,235,129,244,81,145,219,2,139,43,
  205,13,180,185,162,234,86,74,120,85,26,238,150,234,49,163,212,102,158,38,239,
  55,51,197,0,94,81,110,87,101,171,94,94,56,85,244,88,125,136,61,130,13,14,120,
  148,67,83,22,73,124,132,188,211,149,152,92,161,215,159,247,211,70,137,220,2,
  85,157,194,133,207,175,174,75,179,187,23,151,191,203,185,226,96,94,20,44,250,
  201,247,40,73,218,109,184,161,211,77,164,219,0,213,29,203,214,175,114,114,248,
  124,184,60,235,215,5,200,236,5,32,208,68,132,88,15,160,15,188,17,136,149,11,
  19,14,38,66,95,33,18,105,23,71,232,154,66,209,149,29,114,159,71,195,53,90,179,
  18,5,108,75,253,96,200,211,204,119,18,184,149,26,105,26,104,228,96,41,162,124,
  39,10,6,4,6,220,102,57,89,252,156,238,39,138,122,124,93,102,117,235,240,163,
  50,54,231,52,245,39,133,188,177,15,214,11,67,245,220,46,247,54,27,156,246,87,
  76,109,156,254,113,188,182,87,64,185,250,207,174,168,66,251,215,246,194,157,
  48,191,174,14,148,48,14,24,95,137,75,229,221,175,67,88,234,149,54,99,99,120,
  35,139,191,194,186,8,217,36,35,41,137,79,47,78,209,237,139,254,166,87,124,142,
  172,40,68,200,5,230,136,116,8,51,194,0,12,242,251,227,97,203,32,203,103,26,
  31,26,30,70,170,118,165,58,63,220,100,240,153,17,72,164,75,34,35,16,68,107,
  196,107,196,132,125,24,253,153,127,46,179,56,127,23,84,97,238,148,135,21,155,
  240,230,48,101,200,224,132,0,216,58,6,79,221,46,104,127,179,158,27,5,216,59,
  156,75,41,194,201,143,165,19,202,203,207,244,222,189,78,249,121,204,107,119,
  194,141,211,104,182,205,184,242,98,83,133,31,229,189,85,44,153,106,105,135,
  68,238,190,81,145,145,67,105,200,167,255,162,122,52,167,250,187,155,6,127,47,
  175,242,250,254,168,111,92,57,224,235,156,141,135,104,85,100,124,117,185,140,
  161,223,217,239,246,111,115,159,206,42,189,5,178,235,187,152,151,164,101,101,
  98,200,100,173,146,124,43,34,169,89,1,42,4,180,101,236,9,194,100,160,144,149,
  151,223,241,223,57,96,93,219,253,117,165,52,71,103,255,122,170,121,11,211,251,
  138,213,158,204,208,114,21,43,60,69,140,154,223,3,74,169,62,135,81,66,108,203,
  158,184,84,163,34,206,233,120,84,174,151,174,38,202,232,200,184,146,235,54,
  71,114,185,12,147,7,86,15,85,67,191,145,34,181,106,85,6,86,79,201,73,86,181,
  210,186,211,73,111,96,240,202,169,114,251,191,34,160,202,202,197,239,236,8,
  190,172,35,246,16,253,150,90,146,89,207,78,149,147,132,121,194,30,115,84,101,
  203,5,80,134,19,195,9,231,226,110,61,71,164,59,226,44,190,221,216,189,246,110,
  97,239,149,169,119,56,239,19,163,134,23,180,117,34,185,60,67,68,54,109,124,
  54,14,35,42,138,133,113,36,170,253,165,240,19,99,35,13,168,134,212,72,98,135,
  94,195,89,118,152,137,154,94,125,228,227,197,218,225,79,116,96,214,26,70,238,
  115,129,123,170,138,21,246,136,168,145,207,60,94,27,66,230,159,84,170,12,92,
  61,67,143,195,199,226,170,76,146,178,25,55,72,177,145,80,87,87,241,130,127,
  6,127,22,73,134,76,195,38,9,118,50,89,66,75,21,43,213,8,234,135,244,254,254,
  207,126,182,85,135,235,135,236,24,116,36,86,41,84,98,72,247,220,71,22,16,133,
  74,198,86,76,150,99,59,167,29,15,88,104,239,193,126,191,223,49,50,24,192,253,
  220,239,174,26,108,27,223,124,119,134,248,187,187,184,255,206,225,207,27,39,
  205,243,48,110,107,61,47,189,140,186,128,180,191,255,150,5,255,9,213,227,105,
  141,211,231,119,255,233,18,63,218,96,79,86,1,119,127,201,173,116,170,231,185,
  133,83,172,78,174,211,98,127,143,69,34,233,124,196,43,39,170,88,213,87,154,
  205,47,145,210,234,102,212,79,91,161,119,176,84,167,190,210,249,82,165,50,59,
  198,185,224,87,242,58,23,101,131,207,155,232,44,56,57,42,138,11,76,211,233,
  87,234,198,56,149,146,122,59,195,119,177,234,158,253,34,201,110,217,244,170,
  203,191,137,63,81,34,40,198,74,153,11,117,241,102,190,18,247,240,233,46,230,
  4,90,151,186,93,214,133,203,21,174,3,35,216,60,71,208,73,80,83,93,43,96,172,
  100,133,148,50,82,217,32,176,13,96,53,58,253,43,60,25,36,216,203,13,6,28,255,
  14,82,86,168,43,10,45,72,186,58,94,132,190,251,136,213,17,140,138,131,25,22,
  71,223,144,181,66,179,200,199,66,44,80,80,133,89,29,107,165,124,151,213,120,
  81,27,42,122,127,100,90,215,2,118,0,247,190,198,73,245,128,137,2,2,213,241,
  44,197,10,232,201,124,239,246,137,119,177,179,84,52,63,24,175,119,27,65,108,
  213,93,0,133,197,218,6,219,119,14,134,227,96,207,14,94,47,119,223,254,234,95,
  175,119,35,158,122,5,204,63,30,248,95,173,239,158,221,46,162,205,77,113,105,
  22,77,100,50,168,87,0,138,5,3,25,54,73,116,207,11,34,202,169,124,122,146,60,
  133,212,133,106,229,117,204,143,125,146,85,111,163,245,220,174,48,76,96,152,
  71,201,73,42,18,136,23,80,29,106,83,245,99,198,121,9,179,169,178,67,37,30,253,
  98,200,98,163,164,214,125,37,7,54,86,19,233,10,123,254,34,202,201,71,82,21,
  43,33,6,42,77,114,225,100,175,159,11,63,21,46,134,217,129,190,115,228,253,97,
  215,10,23,223,100,179,190,63,30,205,17,209,163,220,10,17,244,80,189,169,236,
  43,35,180,18,186,51,223,154,202,93,38,169,116,142,176,154,214,67,96,2,130,6,
  91,223,144,197,73,16,74,245,118,181,108,181,14,96,68,128,122,51,200,131,53,
  241,165,59,117,91,70,51,45,17,105,105,72,147,155,35,32,111,226,253,135,249,
  49,176,110,255,0,208,9,62,197,24,255,3,126,66,40,162,16,2,254,191,160,109,125,
  87,231,3,129,191,11,38,47,224,13,142,97,208,178,71,50,85,133,87,3,170,98,165,
  208,224,27,82,53,33,82,21,30,111,240,27,252,223,227,127,183,115,238,0,197,240,
  178,83,218,59,10,103,70,70,176,99,254,223,224,230,176,109,7,160,105,40,149,
  1,111,11,246,222,223,133,184,189,214,214,244,111,243,150,150,228,3,139,35,104,
  89,5,160,224,88,27,0,9,116,150,114,230,150,105,113,150,13,254,198,205,187,248,
  183,251,126,4,56,89,176,156,4,25,190,155,123,158,21,254,29,54,51,42,6,252,115,
  248,4,246,140,147,196,0,159,168,182,126,197,131,127,134,252,71,140,170,182,
  0,173,236,127,116,165,5,78,251,32,237,44,214,48,136,47,58,9,75,113,110,176,
  191,104,151,87,89,244,153,76,176,0,141,15,132,16,20,20,110,167,19,22,17,190,
  135,10,171,156,247,44,57,174,108,160,135,124,34,146,214,135,124,119,204,246,
  33,102,89,7,141,102,243,208,28,220,3,68,90,70,136,217,16,151,212,67,190,117,
  101,150,187,168,217,28,48,17,8,180,193,57,191,177,127,43,158,188,167,166,114,
  62,51,143,239,128,187,189,158,159,234,187,252,138,229,191,69,82,206,213,55,
  178,41,147,170,149,1,30,63,0,17,8,17,223,24,100,98,94,174,129,128,210,148,169,
  152,0,80,154,138,170,79,23,76,183,5,192,108
};

/*********************************************************************
***                                                                ***
***            WINDOWS-CODEPAGE 936 to and from UNICODE            ***
***                                                                ***
***                Compressed conversion table data                ***
***                                                                ***
*********************************************************************/

/**
* binary information about huffman coding used in the array ucrg_code_cp936
*/
static unsigned char ucrg_huff_cp936[218] = {242,100,213,85,85,85,84,51,138,237,
  106,163,105,59,103,94,150,139,20,37,84,231,22,118,234,170,221,91,173,213,85,
  82,21,10,53,79,157,85,85,85,110,170,170,219,46,170,170,152,173,85,81,80,29,
  117,85,85,85,85,85,84,203,170,170,164,206,160,50,234,170,169,243,170,170,170,
  170,170,173,238,133,213,85,85,148,170,234,183,149,110,170,171,151,85,85,85,
  85,110,170,181,45,213,186,96,234,182,45,237,200,84,102,233,74,213,69,176,15,
  117,85,85,76,186,170,170,72,82,139,170,181,171,81,93,138,124,153,53,85,85,85,
  85,85,85,85,81,90,170,46,113,91,123,146,172,41,168,62,64,198,247,85,83,124,
  221,85,59,155,231,78,155,80,206,215,158,162,150,18,118,122,117,55,81,141,221,
  61,218,3,196,244,230,87,122,79,223,85,59,71,251,202,29,186,170,170,170,170,
  170,171,23,85,85,85,85,85,80,51,117,85,85,85,85,85,0
};
/**
* data readable by m_decode_presence() about unused areas in the CP-936-encoding
*/
static unsigned char ucrg_holes_cp936[43] = {172,1,79,252,85,93,84,92,86,125,
  54,140,83,47,103,222,235,191,220,92,194,141,51,120,228,247,141,192,254,206,
  12,169,5,106,232,23,167,144,106,16,44,12,206
};
/**
* data about the encoding meant by ied_chs_wcp_936 (Mainland Chinese),
* in a format that m_get_tab_mb_to_uni() can use to build a decoding-table
*/
static unsigned char ucrg_code_cp936[9746] = {81,165,100,129,92,242,174,183,120,
  244,134,91,76,2,129,158,20,96,219,50,149,187,48,178,229,67,192,134,116,249,
  202,49,92,207,0,0,62,91,89,126,83,222,127,176,15,0,239,223,176,166,89,96,198,
  62,107,2,53,182,193,14,14,84,215,8,37,38,93,212,25,219,88,108,192,0,224,196,
  7,243,9,229,88,65,114,229,38,87,107,238,234,40,142,102,47,39,162,116,151,124,
  30,56,30,226,90,41,241,248,45,218,208,247,74,104,167,214,61,112,102,7,52,16,
  146,86,157,166,21,70,249,56,169,93,48,142,18,145,144,233,113,72,133,106,204,
  46,213,128,143,229,25,229,14,147,55,9,80,48,158,34,203,165,229,120,74,197,173,
  172,215,128,135,53,215,211,219,159,17,243,215,23,179,241,71,56,163,147,229,
  201,212,180,137,45,234,85,219,42,135,9,98,178,16,134,83,27,80,91,50,80,203,
  52,153,208,28,36,245,42,184,64,97,131,99,184,197,57,19,221,138,60,197,52,108,
  80,231,204,113,188,172,58,120,0,176,120,245,229,51,79,10,37,41,164,198,38,21,
  123,43,4,234,110,155,206,88,37,165,35,85,67,191,242,229,158,68,100,137,186,
  151,15,136,20,86,49,126,198,23,119,59,137,190,84,69,121,9,13,136,0,98,117,164,
  60,179,250,108,91,160,62,72,223,141,219,133,143,49,38,140,40,97,5,227,118,251,
  27,194,210,137,149,115,207,141,178,36,176,15,160,100,81,203,6,42,221,200,167,
  53,30,239,137,11,53,23,194,116,150,185,226,121,248,174,194,5,140,119,118,161,
  198,10,205,11,248,169,56,98,196,197,237,77,69,21,143,152,142,175,110,202,198,
  24,149,225,229,221,157,64,35,132,151,1,243,91,18,75,245,66,15,244,102,110,218,
  221,102,162,166,126,175,82,40,39,218,127,150,137,25,136,73,83,45,75,232,175,
  229,252,216,9,69,61,201,62,58,172,164,157,168,230,123,202,246,73,161,190,214,
  10,120,160,155,247,5,86,10,11,144,123,45,252,113,207,164,138,210,24,242,189,
  242,198,213,125,235,95,133,91,133,176,9,35,188,180,199,80,199,123,155,55,23,
  18,179,28,45,110,45,68,155,13,134,68,201,109,216,146,194,192,80,192,26,179,
  28,1,229,43,189,29,196,43,253,154,42,64,89,152,48,149,98,136,69,191,146,67,
  10,79,216,102,11,220,224,33,221,174,120,93,149,44,114,252,247,114,228,81,147,
  118,237,194,234,39,163,8,2,13,111,42,100,85,66,189,228,198,193,135,170,131,
  32,165,194,116,1,192,5,27,48,194,119,64,223,129,64,248,132,0,220,223,122,172,
  227,98,157,106,83,117,71,204,35,203,196,42,191,114,164,61,45,24,44,29,169,121,
  128,104,2,25,232,255,14,63,209,221,43,19,162,77,172,228,207,105,212,126,135,
  40,33,163,16,138,125,123,48,215,234,108,31,94,232,97,93,182,117,189,202,67,
  137,160,223,195,250,132,47,247,155,156,115,248,43,113,223,240,159,7,79,145,
  104,8,88,126,75,225,86,5,59,16,167,1,101,236,216,45,139,167,245,166,83,200,
  24,94,23,4,255,247,108,23,138,169,127,10,222,142,180,18,12,183,88,63,171,92,
  17,147,185,237,45,125,133,237,14,44,125,28,90,127,99,225,115,191,36,144,208,
  141,113,94,188,230,1,139,174,114,22,14,205,43,29,88,180,110,192,157,239,139,
  234,164,111,206,191,121,226,117,206,165,137,141,115,53,15,23,176,96,101,12,
  39,159,122,248,4,113,126,112,156,248,98,225,160,108,199,215,186,169,34,100,
  208,218,131,81,253,193,139,76,75,144,130,82,144,206,235,22,73,83,8,102,98,34,
  168,252,41,191,141,172,205,97,2,17,159,201,32,29,246,137,143,28,197,47,101,
  158,96,239,41,142,242,152,160,179,204,240,241,57,134,127,147,39,101,51,228,
  220,223,49,56,64,240,71,39,6,47,119,67,217,45,165,103,41,97,180,22,66,74,137,
  246,76,92,167,60,34,26,175,80,184,49,61,19,56,28,140,161,249,86,185,48,85,172,
  147,175,218,69,173,205,246,146,224,25,69,53,162,167,234,125,57,60,47,41,125,
  207,235,148,177,142,150,237,162,186,165,14,208,19,81,106,195,130,215,78,108,
  224,84,67,190,145,56,22,249,93,119,120,51,133,208,115,238,147,4,246,62,50,242,
  111,160,18,185,34,94,22,156,238,16,48,255,228,252,141,39,44,166,49,144,163,
  181,219,128,76,84,90,174,54,37,101,191,109,117,75,167,249,53,48,126,134,127,
  190,62,176,185,194,2,151,126,68,182,180,217,153,216,229,128,139,25,92,145,65,
  8,6,206,205,12,232,25,119,28,212,122,40,61,121,107,105,216,43,240,122,101,14,
  41,62,132,46,138,170,90,241,166,216,82,33,83,90,57,157,118,112,223,111,4,60,
  157,136,50,189,57,197,235,152,254,39,60,225,128,247,139,53,103,27,164,95,163,
  82,205,230,172,250,73,10,255,238,17,33,200,16,95,56,123,52,169,52,161,56,207,
  96,24,126,68,51,90,11,123,178,14,152,56,96,237,192,229,159,227,106,167,192,
  51,195,125,170,57,234,118,103,210,184,132,121,30,19,230,167,126,60,201,154,
  167,78,200,11,191,9,59,183,117,28,152,222,253,13,219,48,158,97,246,140,184,
  148,74,32,200,15,201,90,144,187,90,101,202,86,141,140,232,45,15,147,200,21,
  216,153,254,213,113,181,103,186,229,42,13,116,11,201,74,236,157,111,60,25,55,
  152,176,235,252,238,6,7,100,78,236,218,173,27,216,101,104,152,120,148,115,61,
  235,125,57,21,181,44,7,82,105,122,165,56,68,120,71,29,88,126,5,196,137,246,
  36,218,224,99,163,121,11,66,119,191,67,196,190,143,154,123,77,120,51,50,77,
  166,100,2,31,253,224,45,43,34,100,84,201,251,226,32,236,148,238,235,71,115,
  81,242,27,217,4,60,145,145,3,195,142,164,191,103,105,184,184,49,214,94,5,30,
  44,242,194,32,155,218,212,135,203,87,146,131,227,59,104,93,2,162,219,131,95,
  190,245,77,187,48,28,43,84,18,88,51,9,81,121,45,254,11,132,4,141,50,103,197,
  127,196,208,140,251,242,142,234,11,89,140,126,166,140,59,31,70,42,48,19,250,
  29,169,38,108,131,213,54,40,5,203,143,8,160,112,45,191,239,58,130,24,222,189,
  145,210,28,15,226,194,210,92,162,13,196,42,235,12,98,79,206,103,145,29,31,222,
  13,229,250,89,124,122,112,104,147,150,228,145,209,135,32,118,28,70,43,44,103,
  58,184,111,194,206,90,81,75,145,151,89,228,90,207,119,43,8,8,208,72,121,160,
  36,80,178,16,42,109,184,210,26,166,18,235,171,237,45,52,158,234,92,46,41,110,
  50,196,50,176,76,139,175,37,104,72,79,188,169,96,253,17,82,36,4,149,161,198,
  54,52,47,209,45,29,253,83,86,55,94,119,182,146,179,117,206,200,5,40,57,7,246,
  124,177,192,171,57,45,47,229,149,157,252,131,89,18,101,92,132,139,106,49,226,
  201,84,104,87,224,189,214,235,151,5,252,242,69,19,248,41,122,209,185,235,3,
  219,6,129,192,171,206,249,23,147,86,57,182,45,248,6,15,203,98,17,125,112,182,
  57,225,120,184,62,14,231,112,128,60,174,80,147,39,18,102,216,110,229,233,16,
  209,137,197,159,131,254,116,182,226,155,132,118,234,148,76,161,114,68,60,107,
  49,158,204,218,110,191,36,232,119,229,83,2,10,218,140,248,213,76,86,140,148,
  130,27,159,132,74,39,7,211,113,11,83,72,15,234,105,231,154,219,21,210,201,235,
  82,175,114,155,2,12,21,106,42,141,231,88,207,137,250,45,85,37,23,7,7,18,34,
  60,194,181,90,221,181,169,239,247,132,218,47,180,249,80,118,142,145,150,129,
  199,135,185,21,180,193,187,53,250,100,56,26,154,135,182,200,181,6,11,148,113,
  173,138,55,74,178,239,83,238,198,181,53,151,48,192,207,235,242,188,125,65,211,
  96,93,241,108,68,143,60,67,198,105,133,96,240,58,216,218,191,249,183,218,242,
  28,136,202,25,111,89,137,2,29,38,80,62,141,111,111,65,161,33,21,244,213,140,
  99,108,138,211,1,136,28,60,145,226,157,186,200,135,222,10,138,168,167,96,56,
  39,99,123,137,145,171,95,254,210,120,12,173,111,52,105,40,153,172,86,102,76,
  83,181,54,219,209,78,2,147,86,149,207,171,19,86,72,201,214,111,118,224,165,
  213,129,53,220,61,234,254,168,169,71,154,33,163,239,19,71,170,159,202,57,207,
  203,195,16,226,4,148,121,80,109,2,167,153,50,119,31,55,196,149,5,6,246,4,209,
  66,67,59,68,58,7,131,71,74,172,168,241,95,187,180,129,174,236,32,126,39,108,
  227,174,145,100,145,160,217,123,137,94,81,5,166,117,232,89,41,67,197,246,188,
  161,186,61,208,90,222,23,254,68,219,214,182,16,78,109,121,86,159,39,145,186,
  7,2,164,200,121,236,40,202,133,221,188,253,59,80,98,127,235,165,174,150,128,
  161,79,182,23,9,46,27,143,124,127,5,125,143,29,9,19,1,153,175,54,86,231,65,
  94,196,130,211,2,255,27,14,167,138,135,95,108,50,120,134,66,211,16,226,39,92,
  42,21,230,78,130,1,111,64,137,90,198,118,58,80,210,232,108,219,159,83,99,169,
  139,82,246,159,156,0,191,202,15,49,110,96,18,216,155,56,108,195,93,59,24,201,
  212,64,122,110,50,5,30,108,39,77,206,71,22,244,137,226,38,163,57,42,181,29,
  131,233,119,37,15,47,47,110,31,145,141,254,207,200,197,247,58,235,241,229,25,
  210,235,183,36,242,159,15,194,166,236,9,56,217,235,212,92,178,167,7,40,73,208,
  179,128,160,62,127,136,78,105,152,123,44,155,9,95,41,79,222,3,49,136,241,36,
  123,84,206,117,114,45,189,91,232,70,238,94,218,82,222,130,217,216,88,228,82,
  140,224,148,4,223,23,166,5,51,178,224,175,84,47,233,247,84,108,19,189,201,87,
  13,63,92,77,35,96,94,224,219,247,172,46,69,98,83,124,104,136,169,165,165,0,
  246,85,124,68,117,110,94,175,61,130,19,42,128,23,97,122,0,149,1,149,236,203,
  100,222,132,157,164,73,172,1,154,168,223,53,139,185,71,157,194,65,68,181,22,
  102,135,85,18,244,207,33,7,121,19,153,119,9,3,209,8,99,13,241,241,189,167,54,
  78,95,16,102,54,126,107,83,144,43,113,126,74,249,242,66,174,134,218,234,239,
  173,8,162,134,214,13,122,140,21,143,50,16,25,3,5,153,127,222,197,161,155,85,
  106,178,227,84,80,99,210,235,3,165,17,157,14,15,129,83,123,165,141,38,87,209,
  223,29,209,53,205,207,233,229,111,209,208,196,64,159,181,195,168,62,42,77,192,
  119,78,241,166,47,185,87,159,137,124,151,134,236,188,36,0,6,234,24,9,196,6,
  62,42,28,13,149,138,101,128,85,153,51,134,148,89,157,0,122,227,143,119,108,
  186,28,58,239,246,174,223,98,64,221,92,218,67,39,217,80,18,46,25,174,33,171,
  140,175,102,56,234,113,165,170,22,238,88,203,131,195,20,198,120,166,158,46,
  158,16,48,130,23,237,2,167,197,224,88,118,197,145,86,33,232,112,111,34,96,19,
  172,242,113,216,124,4,161,53,159,129,204,154,145,228,222,129,153,156,79,222,
  36,208,22,1,8,35,28,135,171,8,196,4,175,244,16,163,22,75,15,226,154,71,142,
  251,149,82,249,78,6,86,240,93,138,189,113,162,94,150,246,187,106,110,148,25,
  123,93,55,48,4,137,32,250,242,46,112,49,92,239,8,162,213,215,9,108,236,56,65,
  145,76,31,43,214,102,71,67,0,245,251,234,15,253,92,6,31,28,65,80,213,155,84,
  102,136,10,75,119,41,112,90,132,28,38,183,150,32,170,40,152,240,234,105,190,
  104,209,117,84,94,70,254,161,5,10,8,42,186,127,189,68,230,93,12,71,154,103,
  198,123,51,87,158,115,229,213,100,252,135,106,194,67,111,37,0,86,98,204,167,
  46,242,31,234,5,169,48,148,132,248,92,213,186,123,57,94,241,19,222,105,246,
  195,75,42,65,56,151,200,108,6,66,3,44,199,145,103,11,198,249,208,84,118,182,
  155,211,186,79,73,231,165,198,249,156,180,64,1,24,171,72,150,86,190,165,117,
  42,23,237,231,58,70,164,146,127,119,44,235,243,143,172,197,112,116,24,60,150,
  0,66,82,217,100,191,208,111,250,163,18,183,96,139,239,245,114,144,253,131,137,
  136,73,245,15,24,206,153,239,114,122,199,54,24,115,187,95,114,144,88,15,178,
  171,73,3,240,176,104,5,90,79,31,98,222,163,197,95,237,116,98,160,156,18,11,
  11,88,48,67,60,53,108,38,95,56,123,179,246,48,168,61,24,21,2,217,52,236,168,
  112,1,188,210,32,137,136,72,6,87,201,67,10,21,150,77,10,8,160,134,130,133,30,
  113,180,6,45,154,57,245,201,68,9,7,158,40,237,115,2,246,86,8,211,244,24,135,
  188,94,112,84,3,195,208,166,224,75,60,227,27,83,166,66,107,114,118,13,112,153,
  132,230,183,94,221,109,57,115,52,156,0,30,108,4,241,39,6,249,148,23,64,30,190,
  161,4,66,3,3,206,54,13,234,166,229,128,236,232,114,219,194,29,69,221,40,196,
  1,181,121,228,142,151,9,117,106,216,79,67,174,157,49,12,47,22,150,108,4,32,
  121,51,157,21,201,6,74,188,19,160,177,7,224,26,159,164,252,187,190,182,32,126,
  252,19,250,61,27,141,83,43,0,94,114,204,138,199,217,154,208,82,164,19,221,148,
  147,80,207,233,10,79,134,186,190,90,237,208,113,68,156,195,98,180,68,210,2,
  3,119,121,79,132,86,14,176,37,171,124,75,116,224,92,12,142,80,132,99,168,187,
  154,232,137,190,207,154,214,172,248,178,84,210,226,144,102,16,138,240,232,198,
  111,59,162,198,135,167,171,201,113,185,205,215,116,229,48,125,58,212,180,177,
  225,170,240,214,118,99,18,19,129,60,79,81,11,156,93,139,4,127,36,193,89,8,7,
  164,111,135,29,129,57,41,66,9,188,5,55,212,17,134,58,252,100,226,205,44,14,
  55,21,202,87,120,12,202,215,245,235,196,180,191,4,225,151,112,40,203,98,232,
  99,248,193,165,3,251,73,82,12,216,85,129,115,4,66,15,170,83,166,69,140,66,150,
  76,231,87,179,246,238,201,254,114,37,194,177,67,91,116,53,18,148,136,246,10,
  24,163,248,83,22,56,220,166,232,103,45,222,168,216,208,56,227,30,40,242,199,
  53,30,248,153,123,98,2,36,29,125,55,144,87,18,115,25,42,206,104,175,9,149,247,
  219,127,19,97,172,177,157,195,93,109,164,198,111,119,151,24,66,191,148,113,
  168,234,222,60,203,247,156,8,118,5,18,43,249,152,77,197,76,5,194,65,25,190,
  164,162,83,215,125,91,187,142,235,8,110,66,191,137,111,238,155,140,236,35,82,
  170,139,28,214,249,161,200,218,56,26,46,237,2,182,27,180,96,209,192,6,161,112,
  226,9,221,223,2,73,1,122,189,207,253,77,64,28,253,58,246,130,26,68,191,19,38,
  137,30,6,58,186,246,191,167,35,223,76,149,137,207,137,170,195,193,219,249,9,
  77,94,124,233,188,32,26,28,150,199,55,39,67,185,193,2,96,35,45,159,247,161,
  74,80,6,135,224,80,97,203,149,190,167,220,235,137,128,25,189,105,85,56,12,190,
  191,209,25,202,235,119,231,28,53,228,140,126,94,48,90,156,133,213,151,5,175,
  37,22,82,45,75,131,31,42,14,22,234,18,18,168,43,185,57,11,211,25,87,253,230,
  204,254,27,142,136,250,123,80,198,53,209,8,79,216,144,100,96,114,170,220,166,
  192,104,189,178,58,112,170,238,10,146,90,138,84,56,230,104,224,57,69,189,239,
  149,191,198,61,26,177,208,157,212,163,14,174,39,66,67,16,249,83,191,47,125,
  80,156,76,161,104,46,29,145,136,27,8,213,151,111,30,217,29,149,15,75,180,170,
  25,219,34,116,93,159,33,9,54,173,233,167,112,179,14,82,102,51,14,28,91,104,
  199,92,134,63,172,58,52,59,128,74,145,146,64,76,144,77,95,211,12,31,251,86,
  204,246,4,111,0,237,59,246,56,139,232,76,53,147,8,78,52,162,93,228,139,229,
  24,53,121,107,44,172,116,18,71,91,16,132,201,202,166,197,154,209,214,5,97,233,
  202,146,162,223,217,215,176,188,138,92,128,149,11,123,181,235,84,122,78,142,
  174,191,235,84,79,179,140,220,138,147,245,56,2,5,252,193,237,176,122,138,50,
  170,217,152,38,161,92,196,117,3,118,174,195,39,213,208,158,127,86,240,158,233,
  240,11,197,143,212,109,130,106,124,230,113,6,30,74,34,156,186,201,254,153,219,
  3,153,86,20,207,140,218,206,8,60,153,33,224,147,247,146,17,200,104,146,205,
  0,172,58,80,179,15,163,168,79,135,26,84,240,157,122,48,20,70,124,135,226,82,
  109,149,45,56,190,143,71,217,163,117,253,162,39,120,102,69,149,134,6,44,79,
  63,215,147,184,201,9,75,14,105,33,70,211,31,56,144,12,226,200,150,105,186,222,
  70,5,73,179,0,171,134,209,93,29,51,142,9,189,254,79,209,240,81,227,126,79,68,
  132,94,223,149,195,66,138,178,68,132,44,249,57,65,32,6,36,131,235,165,29,52,
  27,149,69,144,5,54,49,204,104,42,71,215,116,60,54,25,235,207,206,6,87,229,29,
  252,127,219,248,143,233,109,251,78,4,201,188,92,132,119,130,82,189,180,121,
  123,214,189,213,57,155,189,132,200,113,36,120,99,252,180,133,215,137,143,157,
  97,142,57,247,78,156,50,234,166,120,164,83,144,34,18,91,25,75,43,132,100,81,
  201,130,245,206,148,63,89,211,106,49,40,87,191,216,100,113,149,161,28,59,62,
  94,157,114,76,220,216,91,237,69,124,41,38,46,10,152,16,194,153,215,182,193,
  241,154,248,187,172,160,248,94,211,84,179,11,49,35,10,50,24,93,150,61,20,120,
  210,12,1,80,171,170,243,115,46,203,79,168,182,199,217,248,224,66,72,167,93,
  50,99,189,247,215,53,121,120,38,44,239,27,92,192,137,109,229,169,4,158,99,57,
  107,195,38,200,228,113,143,141,113,48,31,214,215,19,255,80,240,40,28,201,75,
  62,183,173,135,37,215,214,218,9,202,23,119,191,182,247,233,159,43,16,230,46,
  194,103,178,176,77,148,205,1,167,62,243,87,21,217,65,87,117,175,104,222,152,
  9,28,29,16,220,200,1,75,138,68,105,109,41,3,96,108,30,102,17,92,11,23,4,111,
  153,224,228,183,187,232,41,6,48,132,60,24,175,254,115,193,228,92,215,212,200,
  15,217,77,255,246,6,212,136,226,252,3,247,58,32,42,95,50,4,225,134,99,131,38,
  51,54,203,167,216,172,10,178,239,155,194,4,118,193,8,139,3,100,91,37,50,225,
  34,75,169,160,71,181,113,24,23,168,40,229,49,155,171,92,146,0,26,218,0,219,
  118,197,123,111,206,250,155,7,39,87,153,90,160,144,16,196,171,120,221,175,204,
  56,36,82,85,229,224,221,136,235,42,122,183,228,180,195,135,202,173,87,18,32,
  192,228,80,195,14,178,112,86,13,57,190,223,81,170,247,14,134,217,133,204,235,
  132,253,31,191,109,215,32,132,170,227,158,45,149,10,209,222,44,126,87,248,150,
  212,249,54,25,17,109,255,240,22,137,79,248,163,132,99,249,26,80,239,108,32,
  119,169,72,156,236,28,217,16,237,70,17,149,163,143,81,30,94,172,162,12,64,254,
  219,59,79,70,236,150,145,116,245,38,126,199,192,144,149,251,108,217,9,206,252,
  79,211,126,17,181,42,150,100,245,98,24,38,223,229,119,172,241,110,175,54,68,
  208,73,215,62,68,192,209,172,207,196,191,19,246,85,50,215,6,138,135,23,209,
  3,12,70,62,222,193,219,196,193,42,211,186,13,23,204,20,107,162,175,137,102,
  39,165,120,126,112,57,38,3,213,59,8,148,144,73,69,150,166,44,83,45,13,124,36,
  94,47,187,160,18,53,169,208,253,33,99,11,187,239,8,108,199,134,61,188,103,156,
  91,144,175,157,135,132,42,25,9,65,49,155,227,167,192,41,178,219,141,39,242,
  152,31,38,227,20,54,184,68,195,182,204,4,141,17,223,152,38,118,163,28,11,124,
  233,34,53,163,72,125,210,91,223,213,227,13,28,39,19,174,81,16,137,250,144,42,
  233,214,8,37,35,226,41,254,87,82,27,212,233,198,31,25,174,16,60,124,151,79,
  159,207,176,56,30,80,72,45,126,12,12,118,122,173,111,225,87,28,18,46,157,57,
  175,152,159,73,197,20,193,29,49,202,162,171,213,211,105,119,190,229,22,44,240,
  239,19,208,110,184,52,48,188,190,51,191,22,188,190,159,39,67,116,14,112,189,
  123,250,100,166,129,85,45,33,110,39,79,1,48,113,93,231,32,4,228,96,53,165,88,
  150,196,120,25,42,211,91,79,156,49,252,216,141,160,201,46,113,140,121,157,91,
  188,130,208,48,59,181,245,244,160,130,147,252,217,164,108,113,205,114,122,30,
  194,12,2,35,94,177,117,86,26,36,144,12,12,241,246,26,228,112,40,52,228,15,144,
  159,164,46,151,83,124,161,122,159,211,43,183,203,244,198,33,227,219,233,36,
  135,22,49,95,237,59,209,48,220,238,22,43,176,163,149,217,86,50,119,235,156,
  129,78,120,123,87,245,95,145,106,102,38,110,85,209,225,221,31,96,196,194,172,
  177,176,25,25,59,37,130,200,151,64,12,102,65,62,214,32,134,115,132,228,53,58,
  8,69,109,0,75,20,150,130,88,81,58,215,103,116,185,105,136,132,38,65,20,228,
  217,215,205,168,235,96,195,208,1,95,112,93,99,87,75,199,235,243,142,70,111,
  224,131,235,128,85,135,93,192,70,91,112,100,126,161,236,56,160,231,156,153,
  213,227,45,161,171,6,195,48,232,132,210,0,181,234,48,56,239,229,228,123,223,
  179,8,231,32,94,66,182,67,145,23,113,45,22,89,210,16,171,3,31,107,13,174,126,
  31,50,13,230,161,50,166,28,157,171,8,185,3,22,76,124,77,2,132,232,220,43,121,
  65,231,185,61,96,38,146,7,160,9,6,149,70,146,246,58,236,99,252,131,172,70,246,
  111,5,163,176,35,67,86,202,19,15,10,19,85,184,21,31,177,217,91,75,135,159,45,
  18,177,20,3,216,15,128,91,66,207,31,46,60,252,217,61,204,214,173,6,1,253,39,
  210,9,181,174,3,60,112,121,195,27,169,145,142,28,130,166,58,80,177,41,131,47,
  197,29,72,151,114,75,245,234,241,50,225,200,210,111,221,40,58,176,71,95,156,
  36,75,88,8,11,47,243,12,131,143,189,8,191,78,32,75,162,4,110,179,80,30,125,
  157,185,80,143,228,25,15,254,253,120,50,104,44,253,61,51,160,123,155,205,203,
  206,147,180,134,253,43,34,91,131,144,155,79,32,76,238,188,82,161,158,183,211,
  57,82,72,152,150,48,222,168,27,16,49,123,125,253,137,65,227,86,70,49,71,2,133,
  50,45,146,164,33,117,254,95,79,172,252,67,4,242,60,129,201,255,96,95,83,240,
  238,74,80,150,249,122,49,168,52,88,206,217,238,137,28,230,99,181,85,251,193,
  139,99,102,185,122,244,71,132,232,11,249,188,211,244,62,216,140,5,142,167,97,
  238,191,66,32,235,149,155,63,25,207,224,88,224,134,39,85,242,132,11,130,210,
  73,208,181,153,117,40,177,12,82,161,231,215,153,155,228,55,78,190,254,11,193,
  49,200,125,48,197,63,39,235,60,106,196,73,237,191,11,85,210,141,200,104,179,
  41,22,153,104,119,103,244,152,142,106,27,68,59,174,0,158,233,29,51,122,35,202,
  131,62,6,112,40,34,158,97,97,116,1,241,85,131,55,39,189,72,100,180,139,140,
  1,114,234,16,229,46,209,247,231,211,160,23,108,67,243,135,130,47,186,248,165,
  99,22,155,53,196,56,227,106,93,25,61,4,205,253,173,51,252,248,225,75,233,140,
  68,98,195,126,163,14,82,10,205,221,91,102,190,138,10,45,205,159,226,183,76,
  60,103,230,150,4,248,126,241,236,128,170,21,64,96,39,144,101,148,146,97,11,
  65,36,129,198,27,222,154,6,103,202,233,10,104,60,132,129,110,84,128,91,171,
  53,143,249,45,143,189,49,121,239,179,223,39,164,202,98,133,227,23,141,77,242,
  96,76,137,126,195,83,226,67,58,173,105,85,106,47,201,9,21,168,28,8,126,236,
  75,93,246,158,3,172,169,168,238,37,249,1,181,47,154,66,44,146,247,76,17,108,
  72,8,184,97,30,134,225,158,22,186,236,228,147,151,167,134,207,233,63,28,32,
  59,188,160,108,255,177,227,1,17,138,243,149,120,130,220,162,22,131,93,233,149,
  40,210,190,35,32,103,62,86,171,132,18,118,120,156,166,214,157,50,32,100,38,
  86,138,232,230,17,255,246,154,42,31,237,8,238,34,1,52,32,137,84,167,133,120,
  195,142,59,240,236,6,161,17,177,146,28,69,148,54,91,202,115,36,106,24,97,170,
  228,118,168,154,237,132,1,12,234,126,86,235,41,12,138,88,122,132,230,61,135,
  169,134,100,195,29,152,244,113,178,43,109,164,217,236,26,12,69,93,148,132,117,
  208,25,142,89,62,19,141,36,56,183,243,132,210,178,133,104,63,104,48,118,49,
  21,86,136,234,183,247,14,103,24,83,0,127,242,204,142,60,177,178,26,69,152,201,
  173,191,159,242,152,127,236,163,31,67,193,118,40,27,198,71,75,206,208,164,208,
  208,175,204,225,24,32,6,146,248,240,238,175,11,85,195,51,12,7,22,114,21,146,
  84,42,205,33,21,196,144,118,154,52,234,93,35,254,245,62,168,69,78,250,253,250,
  158,4,139,50,90,65,70,184,74,149,156,98,165,247,79,104,70,139,159,81,190,77,
  174,50,64,145,99,212,9,26,204,228,119,211,10,27,61,193,170,36,134,245,81,23,
  206,112,2,130,29,151,218,117,134,238,202,130,50,101,8,65,2,156,200,133,75,218,
  17,37,17,128,233,115,37,126,31,72,122,81,22,0,180,174,107,51,111,154,18,107,
  64,148,200,74,26,106,247,159,64,82,79,140,113,128,66,157,238,51,64,126,94,181,
  215,213,93,209,143,35,94,135,61,93,18,28,155,33,168,86,170,51,241,122,251,243,
  7,131,198,85,189,171,64,10,206,52,80,77,30,48,100,95,134,236,180,99,124,148,
  26,82,175,250,184,47,30,55,76,119,180,116,163,142,103,142,39,41,93,25,189,67,
  138,70,124,88,170,123,237,138,6,171,90,16,2,44,128,25,212,189,16,193,14,84,
  2,175,199,28,215,109,145,32,158,46,81,132,84,164,254,83,30,133,131,115,163,
  225,158,255,97,254,181,30,170,3,128,216,242,238,96,154,82,63,83,198,60,193,
  159,42,62,41,130,52,162,5,120,147,196,249,152,74,225,38,182,135,222,206,22,
  81,175,122,57,131,91,99,173,87,149,253,217,106,180,79,153,27,31,170,82,72,188,
  75,254,89,244,1,36,242,196,233,38,137,186,19,16,169,246,71,131,17,155,252,142,
  247,217,109,122,9,55,167,102,130,37,16,167,252,128,141,161,13,151,14,58,239,
  93,110,84,105,201,245,119,7,169,53,245,196,111,115,169,162,83,10,64,35,90,5,
  90,161,178,19,140,38,191,248,215,50,58,211,187,50,66,241,197,46,19,70,57,29,
  40,147,11,74,118,148,1,204,191,52,177,13,92,91,207,157,172,195,49,178,78,237,
  105,55,72,215,142,2,100,89,113,152,163,218,28,241,196,22,232,225,193,106,180,
  207,138,248,69,5,70,169,129,143,93,165,15,73,133,38,209,148,117,43,61,68,2,
  40,51,12,98,59,132,142,69,13,34,69,244,181,129,244,30,0,127,139,211,156,32,
  25,33,0,10,252,4,153,62,56,255,152,12,47,58,97,71,101,70,210,131,218,148,212,
  68,234,127,34,24,239,134,216,122,174,119,243,229,10,121,67,53,172,115,35,22,
  220,19,96,104,120,197,118,45,236,104,239,183,63,104,240,30,51,215,77,237,30,
  71,178,166,221,101,61,226,63,95,119,222,73,164,32,206,160,142,244,65,106,17,
  203,176,175,124,232,39,234,153,3,180,239,135,56,72,167,148,125,224,197,209,
  214,16,241,33,231,247,23,68,15,77,80,6,177,46,209,202,142,220,157,218,202,235,
  46,90,152,224,200,160,226,250,70,18,27,154,102,225,75,200,40,226,177,181,239,
  75,25,167,192,24,69,209,111,77,158,112,203,46,52,188,79,2,44,24,182,35,94,154,
  121,207,244,189,52,149,19,105,89,66,74,162,12,111,96,131,129,228,88,70,41,141,
  187,182,40,49,7,72,122,172,82,179,142,122,80,216,89,105,61,255,160,0,180,107,
  219,22,85,234,35,118,169,20,246,209,165,66,14,190,245,56,69,99,197,153,31,99,
  199,200,16,197,220,233,17,93,14,148,152,7,161,69,51,209,178,102,244,126,119,
  165,210,46,191,104,62,141,51,77,74,65,181,150,152,117,174,138,52,161,18,58,
  210,165,45,2,37,246,26,73,36,36,4,225,62,124,241,123,109,114,154,49,139,134,
  137,164,76,121,218,33,192,18,158,154,17,136,211,95,22,81,112,90,142,198,172,
  45,146,254,57,207,21,187,58,254,0,111,186,199,149,15,105,221,154,29,114,37,
  30,167,107,140,139,176,127,209,100,102,22,80,147,136,58,242,39,115,39,214,210,
  69,51,36,38,44,161,208,200,31,135,198,161,204,185,145,119,77,131,8,60,1,55,
  56,156,194,26,104,191,213,78,240,100,8,255,242,44,172,61,164,165,78,34,80,224,
  126,169,84,99,15,224,137,245,254,37,189,82,178,87,154,197,131,127,52,168,230,
  133,136,168,172,21,158,97,237,153,10,117,205,233,140,216,85,115,175,93,172,
  185,193,16,131,110,24,37,207,23,255,155,126,178,166,86,55,145,202,15,148,100,
  167,193,108,152,23,26,138,223,34,100,255,178,179,170,193,174,175,222,173,14,
  57,120,136,150,17,153,191,41,218,199,55,81,45,240,114,239,101,182,93,61,164,
  32,145,150,109,158,207,8,223,103,171,204,100,182,76,113,129,67,183,21,198,120,
  217,235,221,133,118,225,56,13,194,47,211,227,171,34,223,102,237,13,82,217,65,
  9,229,71,250,221,112,1,232,9,235,126,200,66,121,41,73,28,135,48,250,173,64,
  43,63,78,105,242,10,13,233,199,133,184,67,40,41,177,20,3,70,128,99,50,10,101,
  196,117,210,240,43,2,55,5,108,20,140,112,63,232,114,22,226,33,154,208,19,245,
  1,112,65,233,231,4,14,100,55,97,103,26,205,96,112,177,233,41,121,114,27,233,
  212,14,136,95,0,244,47,114,10,147,157,156,143,219,198,3,238,33,64,248,119,71,
  27,156,156,25,229,234,52,2,130,171,243,194,227,224,46,95,183,227,227,23,217,
  246,118,204,191,210,120,104,180,96,109,9,87,30,255,198,29,248,115,76,219,15,
  39,94,40,250,130,82,123,148,67,57,240,195,212,163,246,151,183,130,178,89,169,
  76,77,78,196,99,158,222,61,56,45,42,129,210,3,75,230,38,80,48,108,70,123,2,
  89,193,130,128,127,3,236,245,168,148,161,149,20,124,214,15,164,27,93,246,52,
  65,43,205,210,133,184,73,8,81,35,156,203,228,219,168,142,252,90,99,59,139,120,
  161,73,198,36,212,166,237,214,164,175,105,57,132,47,14,197,187,70,214,74,166,
  96,23,144,191,11,249,238,234,53,224,34,190,43,23,157,227,114,157,235,42,12,
  168,16,112,218,58,31,228,162,181,203,12,212,129,151,214,58,188,243,226,16,41,
  252,13,224,154,17,246,154,42,108,90,100,134,164,202,89,21,167,132,187,73,119,
  213,146,18,138,112,166,119,114,225,26,94,34,169,238,17,86,185,160,164,175,38,
  80,63,149,164,73,22,183,7,98,93,6,189,151,102,216,139,132,13,20,18,68,15,116,
  65,49,65,25,177,151,114,75,37,119,41,207,136,210,167,76,231,179,248,97,125,
  219,171,76,142,247,249,172,119,35,234,199,151,60,90,255,6,14,51,228,119,113,
  51,169,159,14,69,200,52,190,7,12,15,15,24,158,226,49,94,103,55,8,127,144,226,
  180,56,25,90,157,162,201,165,158,231,190,81,17,36,71,216,26,187,243,131,236,
  81,12,54,11,43,11,41,108,14,53,133,251,200,104,207,218,108,221,168,213,169,
  243,6,229,217,175,195,9,118,31,205,221,145,230,136,107,236,157,82,176,9,119,
  67,68,102,151,35,201,193,71,131,238,143,193,247,99,33,92,188,63,19,88,91,181,
  255,156,236,145,82,115,178,115,147,254,92,198,171,241,162,49,236,234,100,237,
  60,73,164,67,56,146,235,155,119,172,191,121,174,59,84,194,134,104,225,148,7,
  46,34,100,249,231,121,35,78,240,49,134,192,220,237,107,103,176,104,68,3,119,
  27,176,218,134,129,67,112,191,114,152,187,98,179,3,210,146,1,197,132,28,47,
  31,140,199,73,211,195,8,94,22,144,40,224,11,147,66,188,104,44,112,32,130,76,
  129,211,118,97,6,244,52,17,60,137,79,78,169,206,125,58,189,137,239,196,83,119,
  104,210,37,244,83,206,121,47,66,101,218,27,187,43,145,68,179,77,121,78,116,
  149,47,58,183,8,73,141,250,4,101,56,139,135,13,239,107,89,106,142,231,213,87,
  161,64,92,44,133,167,41,79,43,35,29,149,84,244,71,16,16,171,174,37,149,34,116,
  98,181,191,157,201,210,99,193,47,230,255,84,238,211,254,122,67,32,171,47,70,
  199,164,194,235,132,241,112,248,201,154,240,30,27,255,18,120,81,109,206,91,
  138,252,203,242,114,214,46,204,43,11,213,67,102,182,86,208,32,185,154,196,39,
  73,169,98,182,92,113,118,140,128,161,126,194,199,236,88,95,169,97,234,241,30,
  30,64,43,119,211,8,44,130,118,20,3,75,209,85,101,69,174,164,173,207,79,188,
  116,50,15,19,64,216,45,239,43,187,133,220,219,119,202,199,129,123,110,5,238,
  204,104,138,107,75,48,8,132,59,146,200,118,213,144,113,227,75,19,91,191,33,
  148,207,195,180,90,200,66,137,248,238,31,148,208,140,141,251,161,24,16,48,122,
  89,161,234,65,57,179,224,229,94,157,213,247,240,161,66,236,178,10,200,153,176,
  102,233,45,51,26,83,99,178,163,170,94,169,170,12,188,213,253,115,244,219,142,
  133,75,69,43,127,26,114,85,215,245,105,93,52,225,206,54,76,77,11,216,158,102,
  241,203,224,231,129,156,204,29,58,100,194,40,35,111,152,243,182,247,164,83,
  85,211,33,170,50,135,77,235,154,200,125,30,66,227,128,22,246,153,214,241,39,
  89,160,84,207,85,214,82,183,103,38,244,195,209,228,179,56,167,26,148,163,46,
  73,89,153,49,33,81,136,1,208,18,51,31,109,178,134,69,43,187,92,146,129,11,51,
  233,185,107,51,52,74,190,182,253,88,29,107,96,119,238,216,238,53,10,173,7,208,
  131,106,247,109,78,39,12,13,21,47,175,207,175,204,208,109,174,94,225,242,130,
  75,9,231,214,205,240,60,204,168,51,104,52,110,221,66,226,167,7,108,118,176,
  151,22,177,141,6,121,187,66,109,159,198,148,124,41,71,40,166,105,90,190,97,
  165,205,134,191,87,148,78,215,36,24,99,148,253,30,38,86,229,145,197,169,219,
  191,79,138,129,62,82,9,101,104,78,106,244,164,14,99,3,140,245,37,225,133,201,
  10,9,159,94,115,196,130,175,248,238,108,141,16,106,234,161,213,104,12,219,153,
  104,123,250,183,94,213,158,7,20,82,167,8,19,5,178,26,181,30,74,62,226,3,37,
  159,123,26,226,112,222,153,30,196,233,76,243,216,192,157,35,48,251,128,59,120,
  40,201,118,137,134,144,2,0,63,3,4,113,59,45,146,46,187,4,138,143,160,33,252,
  87,153,18,178,66,65,4,199,233,0,77,224,23,187,36,25,4,132,175,118,90,39,180,
  141,24,79,66,35,104,191,181,210,33,200,19,196,14,42,226,76,222,144,96,99,193,
  189,194,202,95,39,68,173,26,223,21,207,202,197,194,207,14,109,203,44,30,82,
  252,229,72,42,132,27,174,107,28,205,227,101,68,201,70,7,220,218,104,72,93,246,
  36,40,114,212,183,68,18,231,153,162,128,149,249,123,223,62,35,141,203,69,143,
  197,13,164,108,27,80,216,53,33,142,175,46,51,68,44,198,155,171,150,193,138,
  236,152,172,10,100,80,231,216,216,26,218,33,69,87,40,190,109,79,184,114,241,
  208,2,245,109,56,239,129,126,215,167,37,7,41,101,141,45,130,112,116,53,191,
  105,107,119,63,53,24,237,108,224,113,209,108,126,186,28,98,72,211,237,52,32,
  217,208,182,8,197,201,130,246,159,65,188,214,27,94,177,218,220,213,96,104,59,
  103,111,131,248,97,118,192,229,190,232,85,99,81,192,172,85,202,250,183,113,
  208,108,140,60,152,82,96,40,146,200,112,173,166,225,192,36,114,252,94,62,106,
  80,105,152,71,127,166,173,49,68,51,37,42,164,191,8,223,102,51,173,76,220,37,
  203,201,110,227,50,69,164,207,225,56,83,47,40,193,48,79,160,63,205,195,49,184,
  81,117,226,52,14,43,145,46,240,170,184,23,108,157,228,177,122,220,152,21,22,
  81,58,117,58,126,196,127,99,66,27,215,116,162,4,3,222,197,165,48,203,157,103,
  32,40,226,204,41,221,104,134,250,140,54,142,208,96,133,152,163,1,214,225,159,
  132,211,37,16,180,3,135,234,205,14,143,17,37,92,255,239,165,178,167,234,253,
  196,240,110,155,96,228,138,182,128,83,86,241,185,180,190,131,40,200,71,92,209,
  231,115,43,197,215,124,92,216,130,193,161,61,135,161,181,140,155,169,106,19,
  93,6,216,208,219,245,104,218,198,193,182,32,24,204,101,11,153,71,60,146,143,
  41,17,151,83,36,236,19,228,54,11,74,221,37,66,18,100,29,91,223,67,165,156,184,
  129,151,131,166,239,145,170,223,128,44,6,26,192,100,100,4,25,251,52,247,49,
  114,218,113,184,35,74,221,53,24,23,187,139,47,95,3,160,183,142,173,85,89,249,
  104,110,90,18,153,83,92,232,89,199,115,209,43,111,112,126,227,133,147,135,151,
  223,118,111,149,149,190,104,244,117,155,75,189,83,229,147,180,250,36,148,184,
  169,6,96,47,135,56,170,195,219,112,132,81,170,71,159,58,183,13,22,243,209,172,
  40,219,253,4,51,216,58,12,46,249,234,156,57,225,108,104,238,236,250,131,182,
  114,184,95,247,75,130,225,208,98,248,135,251,34,7,217,208,235,87,179,52,213,
  9,35,205,9,202,135,59,84,142,227,11,84,246,26,142,155,55,136,59,40,241,152,
  32,244,157,150,163,134,133,18,141,61,11,220,117,168,65,104,27,64,216,53,24,
  114,241,168,56,152,224,56,31,47,156,153,149,28,135,162,51,59,252,104,54,115,
  70,50,250,32,106,75,38,44,243,229,36,99,47,194,48,37,112,210,91,59,85,201,29,
  6,157,17,99,187,108,204,186,64,247,208,203,88,208,40,227,23,97,108,109,201,
  68,26,157,138,247,165,71,120,137,230,111,174,208,162,29,199,42,88,197,53,167,
  48,139,67,36,32,121,198,199,24,49,116,231,95,79,102,210,7,27,2,70,119,122,74,
  220,9,128,201,237,37,158,202,207,26,144,39,62,117,182,138,117,193,179,50,90,
  12,173,5,131,136,92,169,69,210,90,76,173,78,108,151,153,30,149,189,82,233,196,
  93,151,129,92,215,50,157,52,38,85,88,137,154,94,237,10,78,106,125,145,68,191,
  46,75,195,149,224,55,114,172,145,151,192,89,63,247,10,94,193,61,94,75,147,34,
  252,209,158,93,73,41,129,220,200,107,242,23,45,128,1,194,115,76,81,57,146,238,
  199,32,177,209,171,192,103,30,181,5,41,161,139,164,220,52,99,145,220,91,180,
  130,27,255,195,68,148,69,24,230,193,240,116,204,184,1,53,74,5,142,225,225,69,
  188,228,157,34,189,101,223,120,156,148,34,8,27,32,36,112,248,49,164,129,29,
  6,194,6,218,71,235,229,190,128,154,192,245,209,167,204,93,5,204,33,65,77,31,
  146,33,234,21,214,197,78,107,158,89,187,228,170,86,54,75,71,118,209,148,230,
  233,24,83,114,237,9,155,229,191,245,217,92,10,233,126,123,136,160,212,190,91,
  198,23,35,95,60,175,73,74,185,211,82,57,162,64,243,77,101,34,127,41,19,49,18,
  192,100,195,9,62,78,66,99,6,200,115,97,60,200,66,200,111,100,41,242,83,201,
  6,44,219,211,96,130,208,39,12,246,129,0,130,226,54,161,176,246,8,6,212,52,32,
  186,13,130,11,144,216,39,160,91,17,176,70,192,141,96,141,164,109,136,208,6,
  236,54,218,201,193,71,151,187,164,218,14,37,27,156,151,1,43,124,7,70,153,225,
  243,190,43,78,99,73,238,113,119,206,51,146,136,160,48,29,253,118,143,104,48,
  4,65,97,198,232,34,97,61,130,225,181,24,35,75,205,68,94,26,5,33,71,101,176,
  16,2,37,122,224,195,48,125,23,160,127,151,29,132,91,245,110,24,143,117,32,250,
  168,29,54,136,132,95,14,13,153,43,137,166,32,145,94,29,182,167,28,81,68,148,
  72,51,230,227,35,185,17,28,156,197,142,67,162,135,244,158,135,13,127,237,52,
  165,148,245,153,237,16,75,69,210,106,114,155,12,167,216,49,140,136,152,24,13,
  28,194,123,4,12,41,244,96,230,119,54,38,15,211,121,205,177,161,19,218,70,166,
  189,135,230,62,4,32,208,96,3,41,106,1,25,67,228,188,91,197,89,146,193,192,234,
  26,71,208,99,131,1,111,30,173,32,172,227,54,68,78,23,14,248,110,65,126,98,10,
  33,22,147,224,189,175,133,52,30,15,251,142,119,93,251,222,106,109,80,209,101,
  23,167,89,177,194,208,170,47,207,129,54,35,1,244,97,79,138,244,60,245,170,122,
  64,213,18,245,253,79,59,242,136,212,77,42,116,208,232,17,73,180,201,86,214,
  173,88,187,227,183,112,24,101,75,66,45,244,123,131,39,245,21,95,129,219,141,
  122,217,187,56,89,45,12,103,228,174,67,208,144,163,102,173,15,246,26,240,68,
  47,217,4,240,40,104,87,207,14,231,7,44,100,72,23,8,84,103,152,76,139,144,158,
  1,156,240,83,227,129,62,49,83,217,161,139,98,154,250,36,254,89,5,29,38,104,
  239,53,4,26,94,79,238,100,176,137,75,10,79,240,131,29,199,139,39,142,182,185,
  152,213,225,148,190,168,68,214,109,63,2,204,217,78,140,234,140,254,84,225,215,
  160,3,36,29,154,44,107,194,24,8,254,211,7,177,224,116,87,26,68,35,53,18,212,
  245,133,31,70,23,100,48,223,245,28,237,233,149,189,153,165,190,82,206,237,248,
  161,72,139,70,82,121,68,61,175,228,210,52,86,107,158,216,254,32,226,18,24,142,
  76,176,71,228,74,171,47,19,204,144,44,56,208,174,50,134,108,69,219,132,8,252,
  131,56,29,142,116,166,35,135,181,199,175,6,124,52,244,193,228,213,121,117,138,
  47,235,63,38,58,186,184,127,178,227,109,214,79,117,196,246,229,14,151,135,81,
  27,6,157,67,118,17,161,181,141,183,219,61,168,246,147,216,121,198,164,17,161,
  238,19,68,198,40,176,7,207,200,98,136,132,92,3,4,205,58,57,32,17,1,143,18,209,
  164,207,211,2,39,48,46,64,143,150,165,227,6,76,209,79,234,147,174,37,232,23,
  81,216,159,197,152,230,142,182,195,128,88,12,51,187,76,137,209,12,212,246,237,
  247,254,64
};

/*********************************************************************
***                                                                ***
***            WINDOWS-CODEPAGE 949 to and from UNICODE            ***
***                                                                ***
***                Compressed conversion table data                ***
***                                                                ***
*********************************************************************/

/**
* binary information about huffman coding used in the array ucrg_code_cp949
*/
static unsigned char ucrg_huff_cp949[211] = {242,100,213,85,85,85,84,51,81,230,
  152,203,84,119,49,109,122,161,101,9,149,133,143,158,181,85,85,85,81,151,171,
  218,213,70,115,168,187,111,223,232,143,231,107,85,85,85,85,186,170,169,87,85,
  84,182,90,170,164,59,117,85,85,85,85,85,83,46,170,170,128,69,238,170,183,84,
  171,161,77,80,250,213,65,166,233,84,92,185,109,133,42,213,81,194,102,181,85,
  67,39,126,216,181,245,43,115,49,72,221,137,110,221,123,123,168,186,123,171,
  181,220,146,146,180,84,72,214,183,85,81,150,122,177,90,183,119,36,164,172,41,
  134,3,46,170,170,160,50,234,170,169,91,170,170,101,219,170,173,75,117,110,142,
  6,65,160,223,221,85,83,158,233,7,96,200,34,119,83,215,114,236,181,246,196,219,
  136,174,198,222,95,72,8,11,56,144,27,117,85,85,85,85,85,88,186,170,170,170,
  170,170,129,123,170,170,170,170,170,128
};
/**
* data readable by m_decode_presence() about unused areas in the CP-949-encoding
*/
static unsigned char ucrg_holes_cp949[36] = {50,167,48,24,185,192,2,137,159,102,
  11,179,151,57,122,75,153,121,235,195,114,144,156,244,186,216,3,239,219,88,64,
  65,253,156,213,192
};
/**
* data about the encoding meant by ied_chs_wcp_949 (Korean),
* in a format that m_get_tab_mb_to_uni() can use to build a decoding-table
*/
static unsigned char ucrg_code_cp949[9886] = {0,2,26,33,100,19,120,67,210,87,
  192,123,80,140,22,5,148,117,93,192,90,240,44,143,15,150,140,37,155,20,45,102,
  171,163,235,42,238,142,177,239,63,216,7,128,119,239,217,213,163,138,83,95,1,
  23,67,236,242,190,130,141,211,180,68,209,208,226,205,196,142,50,160,182,39,
  19,20,181,174,20,241,195,112,10,221,64,68,84,1,54,57,137,36,93,174,52,114,184,
  253,242,247,76,167,136,195,24,168,143,115,59,199,241,43,220,204,174,4,6,55,
  248,120,183,236,69,104,60,82,126,56,48,194,38,56,96,42,167,234,5,87,254,221,
  197,222,242,255,128,132,239,54,40,72,132,16,180,82,0,20,202,85,0,0,5,176,0,
  0,21,193,64,36,20,10,45,174,238,73,68,132,117,41,132,86,150,170,212,94,160,
  168,176,239,66,18,176,172,92,73,248,42,178,152,3,155,32,136,1,18,100,157,55,
  80,64,7,7,96,69,240,160,22,10,112,138,173,0,1,32,185,101,212,138,2,20,37,181,
  83,176,194,22,8,22,0,20,0,34,26,2,12,20,20,92,160,2,182,38,202,177,220,182,
  44,196,141,40,103,97,111,71,243,33,75,4,84,83,96,46,4,81,116,0,9,67,128,32,
  52,128,2,0,97,216,230,8,34,113,200,68,32,141,66,20,33,2,224,144,28,113,179,
  101,194,178,144,27,196,6,128,8,23,53,4,175,1,139,56,53,93,80,213,83,195,12,
  95,65,0,58,72,113,130,148,147,229,93,1,0,0,1,16,48,104,2,6,68,6,193,104,223,
  66,238,144,144,160,13,113,67,25,160,4,33,125,57,16,16,116,5,174,186,55,122,
  50,3,95,152,189,198,53,128,33,18,40,68,32,37,200,5,145,66,238,193,176,0,178,
  232,1,68,168,168,38,26,36,158,149,129,209,32,16,234,1,48,26,42,157,14,182,132,
  176,5,55,129,8,229,156,13,63,20,9,177,65,216,8,188,77,43,122,211,57,71,198,
  218,1,209,22,125,72,77,88,0,165,32,213,87,95,54,1,72,107,197,1,86,13,2,177,
  246,78,78,229,143,14,129,55,36,0,90,173,211,21,174,176,62,54,103,166,212,180,
  130,115,98,160,100,26,67,43,204,7,55,224,149,88,156,238,1,3,64,48,47,93,101,
  82,61,213,167,128,0,37,180,21,60,0,5,52,35,115,135,194,150,104,58,11,208,0,
  224,168,11,106,240,87,183,5,0,240,17,242,2,80,226,17,4,46,238,248,19,1,163,
  10,1,112,121,212,58,6,28,0,75,132,41,102,42,104,128,62,13,128,4,65,80,0,1,2,
  253,61,248,147,244,228,172,123,37,94,76,96,74,0,13,47,60,163,92,159,148,87,
  21,40,60,13,2,181,249,236,4,9,155,112,8,155,0,11,17,208,72,20,117,224,66,48,
  32,2,22,130,35,22,117,44,160,176,64,214,0,93,94,162,129,177,84,2,191,212,183,
  51,24,33,212,37,216,128,11,159,82,90,58,155,64,5,209,130,188,111,141,142,29,
  17,12,103,241,120,14,202,187,76,53,163,43,16,192,42,0,0,50,33,143,129,45,199,
  112,185,74,154,42,49,97,109,131,114,77,131,64,1,134,86,33,81,90,54,70,128,128,
  52,66,238,121,0,2,160,165,166,43,64,146,173,98,47,11,107,136,234,75,190,200,
  44,48,6,183,132,104,108,204,96,86,243,121,164,0,66,22,78,22,162,140,35,16,182,
  27,14,232,21,68,0,17,46,0,22,228,196,12,71,7,136,1,211,21,49,192,94,184,21,
  70,133,203,80,32,38,48,44,124,84,226,59,41,64,1,185,12,180,64,168,192,176,123,
  215,155,5,45,96,68,211,64,5,165,185,134,21,93,101,0,224,3,192,16,48,173,193,
  4,24,68,216,185,100,80,12,104,80,160,64,46,11,49,172,131,194,80,1,75,113,1,
  154,81,31,4,0,72,11,89,17,13,201,240,1,196,48,59,44,67,148,90,33,82,166,138,
  157,22,44,128,123,124,86,40,103,44,68,17,51,128,65,48,232,195,57,193,128,17,
  138,93,206,26,80,28,171,131,92,225,70,98,210,203,237,0,36,2,2,64,155,81,202,
  34,55,88,169,134,132,13,156,197,122,133,29,132,161,149,110,130,28,21,4,203,
  38,192,93,147,130,139,201,74,196,160,32,155,3,59,164,171,74,184,54,38,81,143,
  170,5,64,0,144,79,0,176,1,8,48,149,64,92,0,104,58,125,66,22,90,228,242,150,
  96,168,243,166,200,197,16,74,18,160,6,224,3,42,11,139,24,145,33,48,135,185,
  27,160,38,5,14,13,2,38,112,38,1,28,226,8,26,81,177,94,229,128,10,92,141,128,
  0,0,128,207,146,0,9,142,129,20,69,20,123,73,0,51,129,64,136,1,176,8,254,32,
  37,21,4,8,176,154,36,213,114,160,32,36,186,106,37,141,222,45,56,239,75,173,
  34,4,0,95,249,144,6,102,21,2,67,224,33,166,19,96,136,0,44,1,169,152,55,0,183,
  74,105,147,181,203,29,150,6,136,17,184,176,22,80,60,130,133,52,38,40,149,160,
  212,40,1,98,192,0,128,144,60,5,4,169,92,0,0,154,215,98,203,142,190,25,94,41,
  85,76,191,39,185,6,223,144,62,104,65,24,192,35,108,19,87,155,1,178,24,12,41,
  159,133,192,13,8,135,168,20,33,20,40,5,204,1,36,29,49,28,67,81,114,120,61,1,
  144,0,41,148,120,96,68,96,134,12,6,11,48,129,65,96,32,0,109,60,162,153,92,68,
  1,1,129,33,133,77,128,105,18,96,2,236,8,100,86,145,113,8,149,0,32,2,0,0,124,
  75,122,72,214,153,36,32,13,97,162,101,81,244,239,138,162,64,178,21,32,13,241,
  72,12,131,51,16,216,44,0,22,80,60,72,106,106,129,93,120,128,13,207,66,170,134,
  251,72,67,39,13,146,217,202,32,0,68,243,72,200,77,33,211,162,152,0,115,59,130,
  129,131,196,70,22,171,136,139,43,146,128,4,128,222,83,169,214,232,109,146,132,
  130,213,68,93,131,54,4,156,135,152,54,174,170,208,131,125,224,54,28,3,88,4,
  12,141,150,133,52,169,72,42,0,229,21,112,140,215,135,55,98,190,77,167,180,128,
  16,71,16,4,105,24,48,133,5,174,6,176,99,119,36,110,84,1,162,129,179,205,26,
  115,87,144,146,34,13,67,228,185,168,16,144,42,132,228,163,142,0,8,24,17,92,
  208,185,163,149,64,25,43,15,1,160,55,235,246,83,225,100,180,84,247,192,2,47,
  32,64,8,241,82,3,5,80,30,11,128,132,0,104,11,89,70,17,0,2,45,29,51,96,69,228,
  196,246,90,18,72,0,20,1,190,164,56,10,88,0,196,190,176,4,21,12,192,2,37,194,
  85,0,0,170,0,16,48,0,103,76,100,130,154,88,228,2,62,71,53,170,10,36,133,240,
  68,72,11,128,221,162,192,3,142,104,32,110,221,75,33,28,170,29,128,2,18,136,
  144,124,97,6,242,192,181,85,64,32,0,10,0,170,73,167,4,128,136,41,59,44,202,
  86,90,33,237,98,8,25,174,178,0,12,224,172,50,0,20,1,139,16,136,149,10,17,66,
  18,23,96,16,11,160,18,48,56,6,179,53,90,33,183,98,70,95,54,138,80,33,106,32,
  84,192,162,78,179,35,59,49,1,0,66,136,22,165,124,2,122,163,217,130,25,184,5,
  164,37,193,84,141,47,137,113,229,101,70,10,10,194,144,48,38,58,87,86,95,39,
  20,42,7,154,128,141,196,104,22,80,97,201,0,0,17,50,8,208,82,203,68,167,48,226,
  35,67,166,211,56,37,226,64,2,176,56,10,49,4,66,26,128,150,218,112,79,72,34,
  188,12,30,8,3,14,231,232,25,130,4,17,246,234,128,22,12,3,251,196,29,66,39,188,
  67,37,0,226,64,57,174,227,8,1,213,198,40,21,170,84,74,194,65,228,128,101,92,
  26,186,177,20,44,27,208,68,134,251,200,178,148,109,68,0,200,128,17,75,220,86,
  191,2,66,24,7,114,84,202,76,11,243,53,0,37,37,4,31,49,77,5,136,0,16,208,220,
  150,224,119,236,252,64,71,226,121,199,116,17,16,68,233,32,67,212,32,46,134,
  138,134,164,31,170,9,10,67,12,0,85,8,80,4,232,22,6,4,186,164,0,65,193,62,86,
  56,81,15,196,44,224,4,13,55,15,202,103,13,8,51,98,1,186,161,93,26,132,32,0,
  175,29,94,76,5,64,0,21,42,221,148,86,66,128,32,146,135,39,224,215,33,144,216,
  89,159,36,90,153,77,23,33,108,5,10,136,173,102,192,67,111,66,11,66,135,65,96,
  224,235,192,145,246,78,104,0,17,170,37,248,155,71,72,197,162,101,65,64,74,160,
  16,57,220,1,67,227,247,152,172,160,218,192,17,38,22,98,46,32,33,66,35,151,2,
  164,11,100,130,80,1,39,2,113,145,0,21,192,248,0,50,34,120,248,176,18,133,88,
  92,3,96,49,2,197,249,96,91,213,237,48,88,40,11,44,3,238,32,51,14,3,216,197,
  42,41,77,107,115,108,224,232,86,5,71,8,70,86,128,46,241,73,0,88,150,128,9,2,
  16,9,153,80,234,160,190,226,145,80,1,25,0,33,50,134,122,164,116,164,165,224,
  49,136,3,44,154,170,5,112,160,172,42,9,215,3,218,122,16,226,170,215,197,40,
  26,162,84,99,142,61,224,185,189,29,147,135,59,192,129,159,216,6,13,5,196,192,
  80,12,252,60,8,58,32,4,186,186,234,204,250,146,130,178,177,17,131,144,33,51,
  213,162,156,80,8,64,12,108,0,0,85,174,84,97,37,163,52,49,81,253,109,205,0,43,
  101,102,186,28,109,113,184,66,230,115,85,53,56,20,147,124,27,9,32,26,36,197,
  0,195,87,13,2,152,25,106,125,59,128,1,224,0,192,88,168,41,19,153,144,169,32,
  168,148,64,84,25,36,3,107,32,19,193,4,9,128,96,0,232,33,64,34,128,136,0,21,
  215,68,236,24,192,144,32,32,21,110,145,144,0,175,149,139,63,72,130,246,154,
  143,128,252,136,35,90,142,36,161,68,66,14,0,6,64,96,99,106,140,49,216,132,197,
  128,8,90,85,251,181,74,86,244,232,44,224,0,32,177,64,178,26,37,80,52,204,26,
  200,86,155,45,134,38,78,86,188,170,40,32,104,5,13,184,92,167,246,185,176,84,
  35,94,214,106,28,96,156,20,45,10,147,176,227,241,86,218,21,179,22,168,17,240,
  16,40,182,35,248,167,95,0,55,179,108,139,64,142,102,136,225,226,161,10,11,84,
  26,0,65,42,148,207,32,128,32,116,105,129,21,165,1,27,97,171,32,64,173,36,128,
  82,80,21,56,111,68,24,96,224,17,91,35,83,64,25,56,200,140,149,208,43,87,13,
  134,103,43,33,85,96,150,182,44,10,163,231,130,0,208,50,220,81,146,160,60,169,
  0,130,206,89,138,1,84,171,10,154,168,117,48,158,95,5,87,23,137,64,197,112,17,
  193,72,135,66,8,106,217,22,188,92,200,155,32,16,12,150,224,175,82,140,25,230,
  128,104,2,235,19,186,3,74,95,238,48,112,208,169,45,100,240,202,193,133,219,
  210,202,137,4,159,147,10,19,14,112,186,85,92,61,36,219,177,138,94,192,45,206,
  227,0,226,89,0,154,14,3,162,90,129,50,81,19,146,18,190,135,2,114,168,69,49,
  130,149,0,1,0,16,93,219,47,210,100,197,210,5,48,1,218,34,126,32,50,121,200,
  111,144,77,54,110,9,4,157,69,158,123,134,128,47,6,193,157,154,232,96,26,36,
  106,208,12,82,106,234,0,38,15,164,43,4,33,78,1,176,218,69,32,81,175,9,8,118,
  0,128,125,147,169,63,115,89,143,83,16,45,9,1,129,10,192,154,242,0,145,166,129,
  54,8,66,24,170,16,141,9,142,150,91,96,195,202,8,27,136,7,75,49,249,57,152,64,
  0,234,128,42,87,111,51,90,90,147,105,228,203,26,129,50,214,156,177,207,231,
  52,102,233,193,241,22,130,147,4,49,0,136,1,71,201,36,228,249,111,32,72,227,
  49,246,132,180,93,155,61,58,120,8,129,161,40,186,132,205,154,158,214,115,4,
  118,8,93,50,212,194,205,231,94,214,136,120,161,129,24,178,129,211,80,173,128,
  9,235,24,133,128,189,119,29,143,86,159,114,122,75,251,180,253,206,233,20,92,
  127,192,45,11,82,74,173,174,230,119,17,11,255,190,122,250,99,45,232,171,15,
  33,179,166,32,23,35,11,74,171,179,164,12,171,164,247,128,212,224,130,32,48,
  13,140,8,165,228,255,221,118,203,151,166,107,138,205,42,64,172,115,96,22,104,
  241,153,139,32,32,147,40,129,102,164,185,70,155,241,129,225,252,45,137,26,0,
  68,250,116,126,110,121,151,85,153,44,10,225,226,112,173,210,170,99,50,94,101,
  243,140,6,174,107,233,182,205,116,189,30,206,201,237,185,74,146,47,231,250,
  228,209,82,3,234,136,231,47,189,211,36,151,221,80,198,105,24,138,97,43,61,63,
  150,187,109,58,229,144,80,0,21,142,206,44,223,152,148,193,197,82,128,209,17,
  90,178,51,219,31,75,242,198,238,41,101,123,240,241,80,200,227,65,36,241,193,
  193,7,1,199,49,130,196,64,69,135,134,192,126,138,253,250,93,19,36,11,57,53,
  150,33,93,144,228,89,88,192,60,213,106,29,44,250,73,28,133,51,178,15,144,17,
  88,250,8,169,153,63,222,150,82,168,121,130,116,254,188,181,51,216,76,147,165,
  201,33,204,198,70,109,99,203,53,180,183,194,205,220,14,248,90,39,174,169,157,
  92,194,162,1,130,144,230,91,115,254,237,183,202,83,189,12,54,115,193,104,198,
  230,8,63,131,22,245,98,98,129,19,53,248,3,4,208,181,119,8,16,251,33,70,20,38,
  243,194,204,43,11,3,50,33,11,155,94,96,211,176,52,42,19,172,15,22,226,242,248,
  69,65,81,177,234,40,191,249,90,222,87,112,79,50,25,69,9,184,69,8,183,185,124,
  107,47,231,82,229,112,204,31,69,59,201,182,3,188,219,143,173,61,136,253,183,
  45,246,128,117,182,127,119,32,6,214,28,6,225,153,192,36,114,157,181,176,224,
  173,8,206,97,0,127,107,127,213,180,148,189,200,31,90,129,109,165,100,80,111,
  249,200,170,110,94,57,172,46,41,247,3,18,176,105,182,117,48,221,36,60,114,220,
  145,109,183,93,57,185,210,54,250,162,38,165,228,102,121,38,221,162,119,78,148,
  208,215,113,121,209,201,170,68,145,195,247,3,39,62,35,41,52,136,33,185,242,
  68,82,93,55,114,76,144,47,199,52,105,63,206,209,139,142,0,166,159,113,172,148,
  158,27,162,132,4,255,20,22,255,50,232,89,191,248,155,102,25,17,10,218,99,87,
  12,184,213,74,44,196,39,185,91,238,110,107,87,12,4,126,163,37,247,72,155,177,
  87,254,55,218,51,120,220,26,247,233,252,24,182,84,25,229,71,192,175,200,127,
  169,175,200,132,94,75,122,242,41,120,7,54,101,108,199,119,5,27,175,234,166,
  95,47,116,114,234,10,11,17,218,176,60,164,243,43,56,15,64,115,21,108,83,194,
  30,111,115,20,5,136,37,255,74,150,183,255,234,191,120,199,254,43,63,143,65,
  53,119,109,95,253,6,233,141,5,118,27,122,217,98,251,193,110,212,182,250,97,
  158,165,218,209,109,114,212,141,167,215,215,23,252,76,147,174,185,48,22,217,
  147,46,193,68,238,221,107,36,15,17,229,233,165,20,142,216,23,115,199,249,134,
  173,131,78,147,168,63,213,178,170,226,144,222,19,104,207,225,202,231,99,18,
  8,2,223,241,12,230,83,14,211,198,121,111,215,45,219,223,252,207,46,80,27,48,
  27,107,245,44,198,97,237,27,70,27,188,27,83,33,68,218,253,54,125,154,241,155,
  255,170,185,96,196,115,172,150,178,220,117,253,127,253,45,183,230,27,187,177,
  207,170,92,13,105,24,162,110,51,81,143,148,39,191,20,231,32,113,138,14,19,61,
  176,111,42,188,92,65,101,111,59,73,214,220,122,185,29,0,215,152,243,6,160,240,
  238,65,234,135,236,173,55,66,253,151,24,66,110,219,115,230,215,8,111,46,124,
  231,4,96,89,175,188,38,219,106,216,150,222,35,35,95,43,176,244,223,206,14,119,
  192,148,248,249,254,179,229,255,103,123,140,136,251,243,31,31,80,33,163,100,
  28,218,177,29,70,160,83,159,208,228,26,205,183,220,128,245,76,178,190,37,122,
  236,46,73,178,199,140,154,11,244,95,7,112,6,208,16,95,38,99,46,53,131,202,36,
  30,128,41,138,220,65,255,45,236,252,172,237,137,193,215,87,51,153,127,89,80,
  56,167,55,246,157,188,225,235,245,20,153,182,3,7,214,195,26,47,174,136,148,
  84,77,30,215,245,73,253,225,61,179,101,223,83,63,203,254,192,175,96,11,8,239,
  126,221,245,197,39,3,148,232,212,144,63,56,123,105,125,20,26,70,53,70,106,41,
  208,76,193,42,58,92,126,126,164,98,65,137,96,203,9,183,108,189,226,143,146,
  248,58,200,12,182,24,82,198,230,147,55,165,198,135,153,206,136,63,7,25,157,
  49,91,181,45,161,87,31,61,75,56,62,54,101,177,74,146,190,43,236,37,143,80,47,
  125,70,23,44,14,94,97,211,186,164,144,47,235,76,44,241,157,123,209,118,128,
  251,42,81,88,1,212,238,16,9,6,189,218,108,149,126,113,22,191,226,39,174,24,
  245,33,160,41,221,140,226,7,86,164,84,90,8,28,32,147,170,62,155,33,251,123,
  169,165,226,33,179,165,123,111,255,133,1,165,22,214,144,211,7,52,106,234,51,
  161,234,51,69,217,182,179,91,89,110,197,185,170,220,210,7,81,99,168,177,180,
  51,74,120,122,219,36,173,146,52,101,113,227,35,210,101,168,168,107,109,53,79,
  161,66,73,167,11,186,160,118,83,45,150,221,207,124,59,212,82,22,110,197,43,
  58,149,155,74,10,223,177,47,201,101,83,6,210,30,179,237,197,37,53,35,38,227,
  144,124,44,192,3,69,154,210,107,169,14,26,173,46,142,15,117,66,124,167,17,59,
  54,193,139,96,189,218,168,111,212,241,21,160,5,205,94,244,118,141,157,90,0,
  229,46,157,104,249,180,124,203,183,164,22,203,97,229,165,100,149,41,140,14,
  205,0,186,151,70,180,124,168,166,36,83,36,226,72,97,203,49,239,190,216,152,
  55,115,42,159,109,238,147,250,41,3,175,152,127,4,220,184,129,84,200,11,91,222,
  125,206,11,6,228,164,165,111,220,146,166,111,202,114,27,213,149,40,158,229,
  131,133,87,101,204,40,89,118,100,185,132,194,244,116,69,94,251,246,165,201,
  13,115,143,254,244,172,237,245,188,51,68,127,114,140,131,0,14,172,232,158,168,
  22,220,255,238,36,121,206,233,94,203,122,102,119,1,156,245,14,50,47,168,198,
  58,204,22,24,68,185,164,213,2,131,135,32,231,67,176,40,250,226,104,9,31,93,
  22,241,90,193,8,152,143,64,252,74,140,75,134,133,210,153,93,47,171,160,56,35,
  15,114,37,151,155,134,153,85,239,116,24,100,205,138,45,41,164,153,164,168,97,
  102,227,145,44,246,188,211,232,206,35,171,103,27,179,155,28,224,156,126,222,
  90,240,90,19,169,154,149,193,22,60,188,113,137,250,96,208,31,111,131,183,22,
  243,250,246,251,158,85,85,186,102,100,21,247,175,0,78,207,2,4,180,22,3,12,24,
  126,121,174,174,10,51,83,163,3,208,109,119,150,191,104,64,217,246,213,122,29,
  206,57,202,65,158,189,183,170,91,78,245,85,176,62,147,181,171,100,64,131,173,
  87,81,76,196,101,113,35,151,167,94,172,64,81,141,115,167,38,137,251,214,223,
  99,178,229,178,126,57,244,190,204,46,234,221,90,144,205,17,140,4,220,11,103,
  29,195,202,134,94,211,69,170,43,217,125,85,154,164,148,135,229,4,81,21,17,159,
  109,46,107,144,184,27,171,188,75,56,76,229,218,122,141,19,168,160,206,102,201,
  240,231,133,2,150,114,225,219,30,172,47,75,193,60,83,26,170,245,156,159,25,
  50,47,79,111,3,11,124,99,126,33,112,215,251,133,30,73,15,197,100,131,229,242,
  246,182,187,205,38,124,44,58,92,168,198,246,163,233,81,174,203,241,177,122,
  237,158,168,241,57,194,249,248,242,76,60,229,197,222,81,34,21,34,230,226,175,
  247,41,13,116,82,195,250,247,60,102,240,231,123,151,74,157,211,110,181,191,
  249,140,25,21,230,62,183,75,77,55,84,84,118,235,211,29,95,8,208,135,151,107,
  30,158,243,58,80,31,223,168,98,42,16,115,111,220,49,184,184,124,224,118,188,
  225,50,180,141,149,141,193,238,212,85,95,209,43,190,19,181,238,85,27,191,68,
  164,106,14,38,8,89,239,229,99,15,202,43,121,229,138,171,190,120,134,210,171,
  136,6,21,46,6,81,23,150,92,220,12,217,230,149,18,140,243,167,83,120,158,187,
  222,180,221,6,201,43,248,169,98,189,228,64,2,67,204,65,220,158,140,156,85,192,
  75,230,171,122,219,174,240,173,214,155,137,104,227,136,236,116,181,68,21,124,
  191,240,35,185,236,71,221,193,241,156,157,254,124,145,255,111,27,60,237,95,
  162,251,7,23,135,186,75,95,204,194,33,25,9,31,41,150,217,6,200,140,149,43,225,
  164,180,25,154,47,167,125,145,46,68,25,234,134,171,251,29,55,167,249,85,175,
  229,117,211,177,192,8,132,189,167,14,111,252,58,3,118,166,95,191,205,175,48,
  201,98,233,196,166,15,112,81,135,45,101,93,251,23,58,71,34,194,90,4,22,215,
  186,171,230,21,4,62,249,88,127,122,138,104,147,2,33,198,108,104,212,48,95,175,
  249,228,123,233,40,139,247,30,6,1,38,3,121,189,45,143,189,160,50,137,32,63,
  146,152,112,89,129,248,167,185,25,107,88,167,111,61,255,69,98,38,133,245,208,
  91,249,252,33,164,175,55,179,110,135,143,29,123,131,226,71,211,120,31,87,196,
  215,136,78,92,36,143,180,106,180,225,141,106,239,233,13,54,121,220,143,102,
  41,172,240,243,107,217,42,153,116,164,40,210,115,190,146,212,188,102,237,210,
  50,172,239,240,177,213,88,238,187,216,115,75,190,146,132,124,72,113,218,20,
  137,189,186,132,150,142,224,22,59,63,140,110,89,245,107,13,199,198,95,78,203,
  170,238,0,235,191,131,52,240,53,188,244,43,249,206,97,141,79,125,165,33,179,
  87,200,166,227,171,246,5,211,237,236,164,47,140,5,2,125,143,191,51,193,57,173,
  1,202,94,230,247,36,88,185,38,122,232,84,77,114,60,8,68,87,122,19,42,103,200,
  94,161,55,206,121,0,167,45,241,241,236,132,45,10,237,71,250,97,254,109,156,
  189,127,127,111,133,22,10,112,200,142,220,226,159,143,222,22,173,101,116,27,
  117,66,232,251,158,239,76,105,151,23,218,179,188,77,131,84,125,143,17,183,50,
  91,44,26,253,200,142,134,242,254,149,73,252,79,193,208,102,124,170,236,118,
  6,249,191,243,43,231,10,37,31,141,55,10,255,228,55,242,192,25,79,152,70,9,219,
  189,1,110,251,78,126,115,253,166,14,152,161,249,5,7,135,247,125,206,74,107,
  112,166,106,109,245,146,189,189,1,152,158,199,41,212,82,63,27,227,51,194,211,
  98,191,58,149,84,225,231,193,124,115,12,208,243,237,13,151,72,237,141,27,25,
  227,107,72,246,169,241,233,139,231,208,134,171,75,134,168,102,80,91,17,104,
  205,176,153,41,209,247,5,46,246,130,80,214,74,109,229,253,127,153,69,7,138,
  45,186,117,112,199,179,123,230,127,115,124,236,182,41,123,240,125,110,55,99,
  10,93,162,173,102,205,221,41,38,5,200,137,240,250,111,112,150,139,162,90,179,
  3,219,51,208,211,170,148,207,137,236,26,182,67,68,185,4,129,138,211,113,112,
  12,117,212,25,110,209,123,232,220,249,114,110,167,244,228,247,234,237,136,206,
  85,97,43,8,47,145,82,138,8,127,237,164,121,161,221,250,207,108,85,23,53,177,
  88,188,42,218,18,192,125,179,169,242,57,4,200,143,163,26,176,79,14,199,124,
  154,7,210,245,78,163,124,123,73,45,223,113,121,206,57,151,117,231,79,97,59,
  15,89,219,17,232,211,211,98,113,205,129,125,131,165,12,217,48,248,163,111,197,
  127,30,0,142,99,140,93,7,173,177,248,222,239,146,165,56,14,125,68,5,64,176,
  90,161,159,101,170,233,5,53,225,98,11,63,3,106,129,133,255,51,214,53,47,47,
  106,249,142,255,58,196,222,170,63,195,249,90,162,49,33,181,229,220,96,38,126,
  81,18,95,87,28,20,201,154,144,38,215,249,5,161,209,53,11,151,234,176,170,148,
  125,78,71,145,84,143,250,169,101,107,57,181,18,211,255,216,21,169,195,43,39,
  68,151,201,73,76,200,200,204,65,33,182,26,72,78,200,157,32,94,250,82,212,208,
  157,232,157,168,189,169,187,235,108,231,251,21,70,227,175,212,176,35,205,95,
  8,69,79,71,230,83,175,188,21,166,79,161,50,34,247,51,213,86,174,228,64,33,2,
  73,243,171,190,61,251,6,119,161,50,119,156,80,22,102,50,16,143,54,180,76,230,
  250,16,79,245,40,107,63,214,153,54,245,49,198,173,188,130,144,213,62,201,121,
  122,79,43,124,250,199,179,142,19,233,173,55,163,124,28,137,17,30,177,144,118,
  199,94,135,201,42,179,227,182,22,222,42,140,109,32,203,90,19,95,209,114,207,
  211,249,178,161,239,49,138,245,31,76,25,234,39,0,171,84,107,195,16,1,1,44,151,
  166,106,242,124,207,76,243,73,122,15,108,94,5,124,108,193,212,213,63,16,92,
  162,132,103,31,182,5,87,173,118,158,197,198,51,222,150,107,136,104,244,155,
  69,156,159,185,110,77,222,225,227,239,90,167,229,202,206,119,65,243,152,153,
  121,97,13,101,221,83,106,162,47,43,19,250,166,116,14,44,164,40,176,123,134,
  251,240,193,177,232,108,122,243,167,187,139,42,76,36,182,34,91,198,45,171,18,
  235,170,100,79,251,154,181,119,205,36,213,30,191,123,42,42,105,22,223,225,64,
  1,30,8,184,197,135,204,142,145,93,117,238,73,34,254,147,175,82,32,202,8,187,
  248,111,83,110,68,69,100,181,178,251,51,144,101,176,50,9,2,88,206,216,38,144,
  193,162,88,47,200,228,183,149,20,150,244,8,253,25,63,241,79,180,181,226,247,
  26,166,52,69,189,40,186,48,204,63,150,195,204,196,158,157,235,216,79,179,174,
  253,79,9,21,96,70,118,222,224,163,59,144,223,155,68,82,179,157,120,150,140,
  198,182,100,40,85,136,53,24,244,104,75,214,66,193,222,53,240,100,213,5,166,
  242,156,184,88,189,214,255,57,14,181,64,228,112,127,27,65,103,104,204,56,199,
  172,250,253,159,226,253,165,168,199,184,166,6,207,242,107,150,87,145,25,131,
  46,37,153,131,172,70,59,123,159,143,68,44,206,39,252,228,25,117,17,125,74,51,
  112,249,236,136,63,50,220,55,137,255,223,47,157,194,128,96,3,246,100,30,244,
  144,234,65,27,179,147,43,215,242,130,124,5,104,179,240,165,143,184,133,202,
  87,143,10,80,122,190,122,191,83,250,86,25,248,215,146,4,8,244,61,51,103,121,
  198,178,192,55,185,123,232,246,153,77,111,9,218,23,2,82,217,209,108,228,150,
  74,86,144,228,5,207,19,237,129,74,94,244,8,5,159,93,184,112,153,114,14,130,
  143,58,216,93,33,49,26,193,1,39,135,226,85,189,172,200,160,237,226,160,187,
  14,164,114,164,109,26,93,243,150,52,75,206,113,125,131,112,49,94,35,124,82,
  88,37,199,27,49,63,34,178,23,231,248,248,154,44,141,108,131,69,151,59,46,27,
  136,26,125,166,230,5,183,32,70,90,199,97,76,30,47,59,198,253,125,135,225,124,
  236,33,68,99,47,142,218,161,232,56,78,255,7,219,26,26,20,221,203,178,194,11,
  237,111,13,11,9,149,200,94,205,98,116,67,94,57,171,27,177,44,211,193,210,234,
  205,215,110,66,182,63,200,210,211,114,45,186,79,165,101,9,222,9,108,225,161,
  245,209,245,86,133,162,157,207,125,223,28,69,165,203,64,208,112,172,249,33,
  114,195,168,158,91,177,173,201,246,228,235,107,53,181,150,218,73,208,172,109,
  133,246,190,153,112,108,239,183,213,25,138,130,6,247,33,119,242,254,16,238,
  91,41,156,140,140,238,65,135,204,202,109,13,146,38,242,50,165,133,89,58,69,
  22,189,214,66,223,119,220,124,64,40,50,209,219,221,80,163,105,192,86,129,12,
  86,147,129,189,9,127,110,225,182,253,136,127,161,70,182,100,90,248,237,124,
  87,84,60,138,60,122,21,182,53,131,210,184,45,188,111,21,212,182,209,235,101,
  230,93,45,250,192,154,59,53,52,106,15,109,49,218,208,85,0,37,45,10,5,42,168,
  235,21,79,53,91,253,109,246,99,143,111,166,183,202,214,223,39,110,226,6,221,
  191,110,147,74,183,43,219,146,237,201,86,214,174,86,217,167,117,108,108,182,
  53,218,238,237,119,87,84,25,237,255,72,134,223,31,111,142,173,176,250,90,234,
  156,89,213,2,182,147,33,190,200,146,243,111,25,182,234,91,15,126,165,36,70,
  41,54,91,225,33,82,219,93,90,19,213,52,34,208,123,83,169,109,32,116,58,90,4,
  218,192,212,200,80,232,79,205,180,219,213,251,204,173,230,61,228,136,234,127,
  125,184,207,123,114,248,238,2,217,117,216,173,108,85,236,11,182,5,110,28,42,
  162,153,222,24,18,60,199,191,255,149,183,4,147,133,42,67,182,194,118,169,57,
  103,19,109,7,236,94,182,46,246,5,150,151,116,38,229,226,193,144,2,54,183,29,
  44,229,191,255,69,131,4,197,110,76,146,169,77,250,97,42,211,134,232,149,22,
  236,53,44,47,5,248,144,137,234,198,94,234,208,150,107,174,226,69,211,8,217,
  240,162,27,46,3,1,191,52,152,221,184,87,246,186,63,113,230,169,11,2,195,239,
  225,252,221,201,225,188,95,246,54,48,147,58,28,73,50,65,232,11,23,114,159,225,
  197,163,97,232,184,79,218,81,145,125,1,205,129,65,110,223,220,44,7,252,251,
  131,39,81,40,204,238,12,7,88,228,233,154,20,24,12,148,240,224,7,211,108,222,
  114,162,183,122,247,57,4,182,12,171,37,183,99,181,85,219,127,218,217,35,217,
  15,214,200,135,230,73,144,69,142,241,50,194,37,221,176,255,77,172,19,214,249,
  42,229,225,197,186,164,133,100,234,198,14,199,132,19,108,63,194,215,124,204,
  125,92,8,142,172,217,254,0,143,175,106,150,38,154,192,116,21,98,42,153,82,35,
  181,40,229,218,128,141,75,22,234,206,208,226,143,41,192,161,143,134,150,191,
  165,89,223,174,91,232,139,173,20,40,248,215,200,217,49,93,224,158,91,126,50,
  147,252,150,65,83,52,52,128,12,168,42,251,212,198,171,193,29,53,87,140,179,
  237,97,230,227,31,91,31,251,6,144,16,36,19,98,67,249,203,14,177,24,84,172,83,
  206,54,113,188,63,101,238,65,194,208,149,163,155,124,108,203,111,195,137,67,
  150,171,101,100,61,72,75,6,160,207,184,66,61,71,78,56,53,85,47,83,45,254,61,
  251,149,183,237,119,222,210,97,171,123,127,122,109,189,51,188,109,89,86,236,
  206,234,210,54,233,174,231,235,115,238,246,247,46,80,20,239,78,12,156,11,120,
  0,241,130,46,45,135,91,130,157,79,63,123,188,37,133,109,166,220,30,220,17,62,
  155,5,239,20,242,104,236,146,217,117,216,150,201,108,37,3,187,106,35,212,109,
  109,49,222,219,72,48,80,176,82,217,180,224,58,100,153,97,142,122,106,16,227,
  171,152,73,72,29,225,147,229,145,92,223,51,192,133,25,99,227,4,242,254,21,202,
  127,181,3,52,102,229,19,18,152,78,50,19,224,164,109,13,133,71,183,112,64,202,
  83,36,129,86,198,113,197,6,64,119,117,99,219,116,111,115,41,251,114,199,112,
  213,184,103,182,114,135,71,61,109,81,222,203,192,14,187,182,48,239,94,216,118,
  189,125,238,208,228,58,58,31,3,145,14,170,197,166,155,92,19,182,117,11,2,115,
  157,183,110,250,222,219,223,101,181,63,180,105,38,217,191,215,228,13,175,191,
  112,120,25,2,197,53,6,29,56,85,10,242,71,199,30,54,39,130,161,11,123,127,237,
  191,221,168,188,148,134,106,21,41,94,176,110,86,221,148,87,228,25,214,10,15,
  8,231,193,7,222,227,93,33,149,102,99,34,214,186,65,98,118,240,202,185,239,99,
  35,34,179,90,107,131,249,177,215,216,242,199,61,87,170,228,54,54,19,106,251,
  158,142,161,151,247,217,169,220,7,64,200,206,18,241,249,15,132,97,177,225,210,
  95,5,97,100,33,1,121,148,182,231,62,230,71,159,38,5,144,138,97,50,36,64,204,
  202,181,227,81,121,18,21,155,34,175,149,253,18,31,224,105,159,66,243,73,8,24,
  173,71,183,234,242,206,106,68,108,22,149,162,245,83,239,249,49,28,103,107,243,
  12,147,228,117,226,52,49,52,102,134,87,101,214,107,41,19,7,159,66,61,187,140,
  41,99,110,66,237,249,77,54,81,160,210,135,206,88,225,241,37,1,36,145,33,234,
  59,227,225,146,7,228,17,22,145,153,16,90,56,148,96,215,140,109,197,232,18,202,
  240,129,13,19,155,89,2,146,16,147,236,101,193,59,33,189,173,207,98,189,210,
  152,195,200,195,252,243,189,212,201,128,192,82,41,184,212,71,230,209,32,48,
  124,102,64,85,203,210,236,135,7,36,253,33,136,33,220,211,41,67,102,71,104,24,
  64,236,231,80,14,57,98,62,104,233,135,198,149,107,167,36,86,148,104,64,99,55,
  13,71,81,100,47,142,167,52,45,73,49,170,125,63,254,105,137,126,146,198,194,
  216,154,134,17,211,72,18,26,174,78,18,85,255,143,120,77,146,56,224,0,59,176,
  141,47,71,106,16,59,83,57,48,78,29,60,84,35,165,200,172,68,180,29,105,54,224,
  235,166,67,104,241,134,55,190,90,184,141,0,68,84,244,174,161,141,179,187,80,
  184,39,199,44,126,11,118,112,141,179,244,212,172,17,32,119,202,45,8,121,33,
  14,49,129,177,137,244,83,116,143,150,0,96,106,122,92,143,50,92,208,42,49,157,
  22,116,218,253,112,48,195,39,37,178,14,212,100,233,178,116,253,56,87,195,113,
  237,148,59,236,73,61,214,40,155,220,186,42,164,84,243,190,163,170,54,81,68,
  99,31,152,139,63,9,26,135,127,0,251,221,209,30,131,142,243,1,147,148,168,12,
  122,86,10,167,49,169,87,100,153,171,240,163,162,6,142,19,112,11,72,145,145,
  248,58,61,72,12,226,12,158,9,1,142,216,243,216,172,33,156,82,230,16,144,13,
  198,224,101,223,88,121,146,153,204,21,44,249,98,100,51,135,12,130,49,84,26,
  106,103,98,50,200,80,233,230,146,212,38,53,250,181,110,33,159,185,238,12,179,
  31,84,38,168,196,146,142,18,254,220,51,222,17,184,59,78,241,21,204,123,132,
  12,36,91,193,19,233,77,75,48,113,81,29,219,5,180,15,176,248,98,241,202,207,
  105,54,13,16,113,103,30,71,164,99,103,5,44,251,144,22,43,198,17,83,183,84,103,
  62,39,140,105,209,209,175,182,40,248,10,50,131,166,122,186,140,0,19,2,18,107,
  121,182,52,209,198,48,208,163,58,146,210,208,152,124,145,216,230,253,45,129,
  180,43,52,98,2,140,247,14,28,97,77,129,150,244,209,244,254,203,152,64,142,130,
  222,65,222,11,193,171,79,26,40,115,251,232,95,112,106,160,163,33,36,180,178,
  181,123,188,46,149,234,133,3,34,164,75,162,69,168,140,97,100,97,254,74,158,
  63,151,234,1,110,143,255,199,98,79,60,69,153,107,131,14,51,210,172,107,188,
  25,140,135,88,72,220,98,255,47,7,112,208,155,231,106,181,216,247,98,104,197,
  129,30,99,242,216,50,230,48,72,205,92,185,163,138,32,66,18,181,56,171,14,132,
  134,220,92,113,136,38,30,98,8,24,240,23,187,49,47,242,84,91,3,79,170,2,99,125,
  71,103,73,54,255,73,152,110,247,11,57,2,219,197,112,34,238,224,7,73,24,100,
  143,41,181,65,132,82,199,200,2,16,154,4,171,1,216,252,161,61,193,144,130,54,
  142,168,160,78,138,252,201,198,11,27,207,33,26,60,190,155,137,207,6,12,87,205,
  138,85,75,25,161,231,76,164,114,223,208,71,4,46,93,40,14,199,100,2,136,156,
  183,34,5,48,82,78,41,210,79,48,120,95,21,70,108,14,138,6,68,49,202,49,164,32,
  188,41,28,120,211,108,2,42,50,253,52,167,21,71,129,225,88,73,44,94,117,67,129,
  152,6,208,66,134,139,98,113,199,166,84,229,68,181,26,196,127,172,53,27,115,
  231,69,109,186,157,172,182,214,78,213,50,132,21,65,161,135,196,38,198,22,76,
  242,123,50,205,44,117,234,224,88,222,216,2,233,223,53,46,69,153,252,208,5,142,
  99,172,182,112,118,29,11,65,118,130,152,65,112,49,239,227,178,10,130,141,118,
  188,14,211,111,48,17,1,11,187,215,240,28,41,146,125,180,47,178,28,177,223,136,
  178,174,103,179,65,100,67,140,101,92,26,215,96,40,133,136,115,248,56,179,210,
  36,147,79,2,249,132,116,146,133,223,20,83,162,11,118,68,226,124,14,120,19,166,
  204,139,99,47,195,139,90,42,229,133,16,218,48,77,75,34,162,159,240,196,151,
  224,88,133,68,126,95,131,67,56,37,120,196,76,12,33,91,218,87,29,179,24,174,
  232,36,130,5,31,185,118,170,18,45,40,184,52,108,83,76,69,222,2,13,179,235,178,
  244,117,137,198,1,132,157,4,176,47,205,61,50,43,138,164,21,27,139,99,167,107,
  169,149,201,102,163,141,136,230,212,197,17,64,2,69,136,231,224,76,224,163,162,
  14,42,67,15,22,18,173,249,33,95,21,130,172,212,70,3,32,251,198,44,159,126,139,
  0,58,233,145,242,27,58,169,36,139,147,174,10,138,188,71,52,114,156,42,67,160,
  94,51,188,12,101,88,107,10,8,72,172,251,44,84,211,99,132,15,224,186,228,130,
  121,199,34,178,28,197,82,27,129,161,88,194,76,12,193,34,206,193,34,69,106,24,
  155,96,38,235,184,21,116,227,147,103,14,6,202,200,92,167,160,97,0,144,118,16,
  168,223,97,65,80,166,240,37,5,24,112,111,167,240,154,30,225,71,132,199,204,
  139,229,153,70,187,22,215,82,120,80,190,55,192,68,82,180,129,92,145,122,248,
  181,6,98,136,80,39,139,90,245,186,241,207,24,2,217,206,179,177,1,105,3,242,
  14,15,177,183,53,51,208,150,131,130,135,140,59,167,10,2,2,104,99,167,194,99,
  55,68,67,8,224,23,132,51,65,58,246,151,16,56,23,74,40,110,129,56,33,106,20,
  82,98,134,48,64,131,113,33,129,12,96,206,4,48,67,208,116,49,208,78,13,66,158,
  47,2,44,44,236,96,187,76,21,17,23,66,130,233,8,26,32,192,68,50,226,224,41,180,
  50,165,198,4,200,103,67,12,237,174,175,176,86,148,20,24,162,22,58,48,199,197,
  116,2,71,8,24,50,113,208,244,6,40,132,88,68,10,99,241,129,26,227,180,120,81,
  238,20,248,97,209,209,206,134,16,21,13,157,4,48,195,20,112,142,220,100,81,129,
  24,32,192,221,83,128,208,112,218,6,152,131,153,161,195,22,143,157,51,64,86,
  163,128,131,65,28,4,209,129,9,129,22,142,211,192,194,48,8,12,206,192,248,137,
  131,32,126,27,128,17,161,194,58,64,16,64,105,19,60,49,192,25,188,160,57,6,138,
  24,8,5,130,8,96,23,16,136,64,59,112,10,32,226,208,10,95,193,1,125,233,57,83,
  145,70,72,191,134,244,90,225,205,225,196,193,48,202,114,183,240,222,208,111,
  134,178,218,192,178,38,0,232,18,98,194,96,57,181,134,232,191,128,230,214,5,
  145,57,81,160,73,139,95,118,18,200,191,130,198,240,226,119,160,57,87,19,4,192,
  76,104,97,48,214,98,254,27,215,103,250,31,195,122,43,200,230,215,72,42,184,
  129,240,26,139,151,221,97,243,127,62,85,197,246,129,39,215,221,23,241,246,254,
  92,171,136,1,26,3,87,69,252,7,104,57,83,12,144,26,95,195,122,47,209,153,66,
  98,68,53,58,95,195,122,47,227,22,241,226,194,96,17,173,175,204,219,248,44,139,
  88,7,68,223,1,216,126,171,111,229,215,124,250,47,83,1,48,222,28,88,76,2,6,131,
  146,122,50,79,75,248,111,100,31,65,132,136,0,68,95,195,121,181,247,60,120,152,
  7,0,1,111,15,15,219,248,44,85,197,252,7,97,254,39,54,176,14,111,209,209,48,
  76,7,42,226,111,134,84,197,252,53,58,95,195,114,29,22,36,67,83,165,252,55,176,
  243,56,181,14,252,53,91,200,28,95,72,204,149,109,252,243,40,155,224,177,191,
  151,55,240,29,23,240,202,242,151,240,222,138,144,204,162,254,26,157,47,224,
  58,47,225,188,212,2,200,191,128,231,128,170,246,254,3,155,88,7,69,252,7,97,
  250,174,47,200,232,191,128,232,191,128,140,173,139,248,14,136,201,38,2,35,75,
  248,101,77,202,25,148,88,76,4,141,47,225,189,22,187,66,21,112,152,76,7,53,59,
  50,109,96,28,218,192,179,65,202,152,6,38,214,5,138,182,240,219,242,177,191,
  57,164,76,19,13,0,228,142,73,16,12,197,252,53,152,168,102,209,48,76,4,152,155,
  225,189,22,176,107,47,31,67,248,14,106,127,135,241,127,46,120,241,57,83,0,225,
  235,253,87,22,161,205,249,29,23,240,205,34,194,96,53,17,97,48,212,233,127,13,
  233,75,55,137,188,239,98,116,165,13,204,162,254,121,14,85,226,116,95,145,145,
  235,19,155,251,54,139,248,14,132,114,166,26,204,95,195,122,47,224,57,191,71,
  100,140,36,67,80,34,254,27,209,127,13,230,212,59,67,9,128,102,45,67,155,243,
  123,127,5,145,127,1,209,55,192,1,12,63,139,244,116,95,192,117,222,71,69,221,
  1,153,68,221,160,32,66,127,25,58,95,198,85,230,81,97,49,185,188,129,227,196,
  193,51,232,169,254,31,183,242,229,92,95,207,176,253,86,243,206,139,8,213,205,
  250,248,191,128,232,232,212,104,215,8,191,134,244,89,68,3,19,107,23,70,25,83,
  145,0,17,127,1,218,24,145,147,121,91,248,95,23,160,232,1,17,127,13,232,175,
  35,162,254,3,162,254,3,162,245,48,29,23,241,186,47,231,209,127,1,209,127,0,
  17,22,145,1,145,91,242,178,47,81,163,43,17,26,19,12,169,139,248,111,68,15,71,
  55,135,22,19,1,38,47,224,57,191,141,202,184,176,152,13,123,203,0,236,59,155,
  248,14,142,7,69,234,96,59,15,213,113,127,5,141,250,248,191,128,204,162,96,152,
  8,194,32,20,67,122,47,225,188,240,51,40,191,134,246,39,97,230,113,127,0,17,
  114,255,195,246,254,87,244,95,207,176,236,201,86,171,83,35,50,139,249,200,210,
  7,195,42,98,254,27,204,15,70,101,23,240,222,139,248,14,106,126,240,58,47,224,
  57,181,12,201,191,128,229,53,241,127,1,216,126,241,219,248,14,111,209,209,127,
  1,153,68,239,64,116,95,192,116,95,195,122,195,204,162,111,134,244,95,192,115,
  127,13,229,92,95,192,116,95,163,177,59,240,213,113,127,1,205,168,118,39,69,
  252,7,55,235,226,254,121,148,95,192,116,93,208,222,139,248,111,98,102,81,97,
  48,222,139,248,14,106,126,241,226,254,1,1,227,170,218,144,229,92,95,192,118,
  31,170,226,254,124,223,163,162,96,152,44,111,229,209,127,1,218,24,76,53,152,
  191,134,245,144,104,191,134,244,95,192,115,127,27,189,96,89,23,240,29,137,153,
  60,118,214,5,145,48,76,7,98,102,77,249,88,223,145,205,252,51,72,191,128,232,
  180,24,14,139,248,111,98,102,81,97,48,29,23,240,29,23,240,222,109,98,232,180,
  24,6,98,215,14,138,144,232,181,128,115,107,2,200,180,18,57,191,71,69,168,116,
  95,192,116,95,145,209,25,122,1,150,254,125,23,240,4,225,143,246
};

/*********************************************************************
***                                                                ***
***            WINDOWS-CODEPAGE 950 to and from UNICODE            ***
***                                                                ***
***                Compressed conversion table data                ***
***                                                                ***
*********************************************************************/

/**
* binary information about huffman coding used in the array ucrg_code_cp950
*/
static unsigned char ucrg_huff_cp950[67] = {238,12,133,220,234,171,123,43,84,
  84,237,151,116,147,164,179,78,182,111,65,91,45,10,155,38,153,69,152,221,213,
  91,221,82,1,208,102,247,46,181,65,63,219,174,26,33,53,83,51,27,186,187,183,
  190,64,28,158,94,165,45,194,206,110,223,153,81,17,32
};
/**
* data readable by m_decode_presence() about unused areas in the CP-950-encoding
*/
static unsigned char ucrg_holes_cp950[7] = {141,64,0,7,32,47,93};
/**
* data about the encoding meant by ied_chs_wcp_950 (Traditional Chinese),
* in a format that m_get_tab_mb_to_uni() can use to build a decoding-table
*/
static unsigned char ucrg_code_cp950[12996] = {0,2,26,41,100,83,137,3,74,115,
  158,15,36,192,22,199,237,201,62,210,31,176,15,0,253,127,214,232,253,89,91,140,
  98,144,194,45,240,39,85,87,160,0,61,97,45,215,235,99,100,16,64,112,137,133,
  101,190,196,119,117,16,72,10,217,217,39,0,45,155,64,55,57,151,57,16,243,7,111,
  215,241,160,91,252,40,188,48,91,94,170,84,119,83,49,35,166,90,26,92,82,33,90,
  201,16,201,16,1,185,33,0,252,163,59,3,128,165,10,79,115,193,214,214,112,216,
  78,194,143,100,119,215,1,25,24,22,12,161,130,16,42,232,95,51,140,64,12,157,
  108,54,118,169,230,236,87,14,229,67,196,196,149,235,32,12,13,103,27,21,64,99,
  64,168,104,234,19,38,45,42,45,161,65,82,20,51,145,85,24,4,46,228,1,131,128,
  165,224,0,0,3,196,5,103,160,81,40,13,208,112,15,19,131,10,231,154,18,44,168,
  29,92,83,1,70,224,29,128,94,90,179,47,16,1,170,21,171,215,87,49,129,216,48,
  58,231,174,162,3,111,64,36,16,99,64,13,36,71,24,12,34,133,14,211,2,1,103,128,
  66,90,52,84,0,205,216,162,11,51,139,145,98,203,136,202,40,162,97,48,39,144,
  46,110,135,80,170,235,0,177,128,49,10,3,148,113,116,1,120,9,0,181,178,124,94,
  11,92,140,92,164,152,32,45,7,137,230,6,60,0,21,2,160,40,129,92,72,141,154,128,
  224,88,237,57,28,26,14,18,160,72,98,67,212,66,31,209,5,85,106,0,97,15,89,33,
  200,0,68,49,137,152,61,40,209,246,0,33,181,192,36,132,144,79,93,8,220,246,75,
  1,58,172,144,28,0,76,160,20,128,132,86,128,85,5,200,131,26,3,204,135,120,248,
  232,145,134,94,2,75,74,210,6,114,16,32,95,48,71,11,85,1,161,182,84,196,197,
  8,238,87,161,114,20,21,143,128,179,233,142,4,11,111,16,5,147,36,210,242,184,
  168,152,1,6,101,133,238,84,1,176,168,65,26,192,16,6,185,54,76,32,54,6,128,140,
  151,6,152,32,144,29,101,165,99,101,80,90,203,92,2,172,4,152,110,144,42,138,
  6,33,1,138,169,164,1,163,50,2,129,9,250,1,194,110,177,113,4,1,35,27,67,6,128,
  5,1,1,137,186,167,160,181,245,10,216,194,38,208,13,2,128,0,96,22,48,66,208,
  129,179,32,18,94,0,133,102,24,80,34,128,17,134,17,142,163,98,64,39,130,138,
  212,51,29,136,9,84,128,24,3,198,192,34,224,66,9,232,160,51,59,139,125,224,69,
  155,167,160,65,26,47,80,64,245,8,1,64,2,0,0,1,4,170,45,197,5,15,128,230,118,
  102,107,128,4,33,0,20,110,12,43,245,94,193,32,37,114,144,43,40,36,0,55,40,108,
  72,0,0,68,41,70,0,33,138,136,36,195,24,68,2,103,88,185,222,250,37,65,206,32,
  92,198,0,0,204,22,16,50,0,162,77,183,230,128,89,71,161,180,54,129,129,33,58,
  152,60,21,35,57,227,128,76,248,92,245,4,1,4,131,64,24,84,114,192,59,38,128,
  0,66,2,19,0,192,96,89,180,48,55,145,3,40,29,224,1,148,65,248,32,0,24,23,14,
  0,96,5,11,218,194,112,1,128,11,162,3,200,2,193,176,4,128,211,149,118,0,90,165,
  20,20,162,82,27,16,48,0,207,37,10,221,113,222,13,25,144,152,36,56,165,170,137,
  108,222,76,44,160,226,133,12,49,112,231,152,61,5,199,198,15,82,97,40,5,88,14,
  31,192,54,120,208,40,0,32,198,11,225,21,132,0,13,56,80,33,41,242,214,46,88,
  183,128,249,97,7,210,5,215,112,50,30,110,5,4,142,188,233,218,68,144,22,178,
  27,20,198,241,60,145,114,3,234,208,131,116,10,80,89,70,205,230,0,95,35,6,26,
  229,23,32,5,38,232,136,16,2,14,192,124,64,160,5,16,65,34,80,99,42,193,6,1,198,
  164,77,34,4,128,157,155,107,144,107,110,61,167,7,0,64,113,194,173,7,130,115,
  72,130,12,99,99,80,35,81,58,225,144,0,139,89,156,141,130,236,163,155,129,115,
  96,29,50,116,208,32,93,115,221,50,128,40,10,8,132,66,237,191,42,153,220,2,12,
  50,1,36,177,5,128,79,147,73,192,29,6,229,137,135,46,208,202,131,140,54,3,129,
  130,128,12,40,200,71,36,216,171,196,0,24,118,14,4,193,176,23,195,6,20,116,91,
  141,3,0,126,136,79,101,129,171,130,186,140,65,44,196,234,225,101,200,18,111,
  60,30,138,112,110,72,179,216,0,21,144,1,129,160,13,40,57,0,32,28,75,19,132,
  193,142,34,152,0,59,40,1,192,154,128,3,224,184,20,245,46,128,203,70,0,3,128,
  1,146,128,63,196,32,128,27,18,147,32,201,79,1,180,42,132,26,49,250,138,178,
  53,168,153,54,155,186,1,132,3,200,49,16,2,208,166,170,90,109,228,85,75,52,202,
  46,64,35,165,5,157,112,43,164,52,51,90,28,2,21,228,89,245,184,0,0,16,63,141,
  176,203,155,177,238,151,209,232,32,23,172,11,75,217,118,35,52,19,3,103,167,
  96,107,29,91,234,137,192,104,210,15,18,184,136,2,202,32,96,118,77,19,12,129,
  232,179,84,1,196,33,9,106,8,96,22,41,164,66,210,64,128,9,10,13,208,18,101,147,
  137,128,9,37,11,2,167,146,113,40,172,132,143,5,64,129,0,168,227,20,193,112,
  228,160,60,87,3,146,175,102,214,27,19,6,0,36,19,165,186,37,21,30,69,65,64,88,
  5,64,0,96,86,130,35,64,48,64,194,128,66,9,161,104,40,139,9,151,44,52,68,6,246,
  20,135,38,240,127,110,5,1,178,32,2,2,48,44,200,118,64,50,33,50,100,20,4,99,
  90,152,85,234,234,78,84,37,199,29,30,192,209,37,9,67,89,225,18,205,55,141,60,
  108,109,161,163,114,64,65,214,80,128,0,0,75,87,110,1,79,92,199,13,0,227,125,
  5,134,118,213,28,180,54,40,250,36,65,80,99,23,141,54,99,3,180,80,148,101,212,
  20,173,137,82,213,153,154,67,64,85,142,2,11,174,162,100,64,19,33,157,197,30,
  140,140,26,1,96,64,9,174,54,74,80,249,2,193,58,0,121,8,130,162,216,100,34,107,
  6,44,26,146,8,33,196,0,168,21,182,238,32,1,6,71,20,28,53,150,22,84,140,77,42,
  1,89,170,38,13,57,20,3,114,24,193,183,118,205,75,128,184,24,30,76,33,16,208,
  177,158,79,1,167,156,85,51,40,156,7,120,27,2,68,5,0,0,110,122,211,8,66,161,
  119,118,41,74,30,128,185,74,243,209,141,95,115,206,104,126,40,80,2,155,236,
  137,242,51,33,101,44,54,68,52,24,86,30,135,1,1,64,17,114,192,56,192,29,154,
  32,107,17,1,10,5,200,59,245,33,168,123,48,27,2,240,192,5,67,101,204,143,3,68,
  52,190,184,1,18,177,144,88,212,63,112,8,5,172,120,238,0,3,113,132,247,33,166,
  20,38,167,4,22,180,17,60,170,160,103,14,128,163,8,77,17,246,82,100,88,169,197,
  1,1,102,134,120,25,38,7,136,24,251,246,96,38,137,200,23,0,17,77,82,84,29,224,
  9,131,212,146,17,168,158,112,18,192,25,14,36,0,34,57,2,224,130,132,20,58,0,
  136,222,32,71,190,83,200,53,74,222,239,61,232,80,24,128,80,219,1,27,224,2,21,
  21,216,2,144,32,155,211,16,16,130,56,220,65,0,18,43,225,34,0,15,139,0,180,160,
  1,168,38,143,67,2,0,13,132,107,224,176,193,0,244,196,104,250,21,136,112,68,
  131,0,77,68,128,1,2,36,0,90,152,221,120,76,80,69,1,160,0,143,0,9,9,104,142,
  218,218,14,0,98,21,27,209,101,20,17,67,8,119,176,8,30,35,94,65,92,85,5,29,171,
  16,4,176,148,148,160,65,69,118,14,225,9,248,191,216,76,108,225,100,190,64,10,
  133,108,101,9,29,216,43,150,161,212,166,37,142,101,180,35,3,193,90,150,64,18,
  34,132,1,105,125,107,220,128,133,152,159,107,88,32,32,216,15,2,108,52,50,75,
  84,139,196,71,108,74,43,96,64,44,176,112,14,140,73,118,14,225,65,132,42,78,
  70,205,65,2,228,106,7,146,4,26,128,8,226,134,144,120,0,37,73,129,87,237,227,
  38,56,0,163,92,161,91,14,34,86,231,140,40,152,129,235,65,242,64,47,139,140,
  13,32,114,103,52,72,144,48,14,47,190,138,255,16,166,132,27,200,1,10,158,96,
  1,204,16,10,43,138,34,54,42,164,26,24,64,84,139,40,20,169,29,201,136,1,106,
  96,1,48,77,181,107,192,29,225,5,146,8,144,132,129,8,173,51,62,196,0,64,0,128,
  112,253,31,193,248,130,253,138,8,110,2,20,239,242,244,139,118,152,68,85,0,34,
  68,33,33,62,197,72,3,238,89,210,201,1,58,10,128,224,34,56,1,246,0,17,17,8,251,
  29,131,194,59,80,73,195,204,242,136,4,126,244,5,240,86,241,133,115,105,1,104,
  128,9,110,44,86,19,247,222,192,96,180,22,96,67,160,0,126,5,32,128,65,128,138,
  23,199,196,229,190,145,12,215,185,129,50,65,96,30,186,191,247,238,17,193,193,
  0,72,126,160,179,122,109,53,9,237,41,10,37,6,44,68,216,105,3,126,178,85,1,224,
  132,107,129,60,1,62,196,22,0,1,244,148,5,8,69,33,4,61,44,254,130,224,163,2,
  200,8,14,206,203,16,235,50,154,248,148,227,164,157,21,7,161,145,211,160,132,
  118,57,136,66,51,160,196,204,216,8,30,110,234,176,64,189,87,48,56,11,15,45,
  56,140,95,178,3,2,131,1,110,68,82,66,70,15,103,199,193,61,28,142,171,40,26,
  1,106,163,78,2,26,172,227,53,176,192,209,92,15,34,54,164,85,202,61,144,168,
  146,16,138,80,228,106,157,205,103,65,50,220,22,187,20,30,112,89,81,64,150,105,
  1,192,36,0,0,37,189,181,21,178,144,72,103,11,20,70,15,178,135,130,2,51,183,
  1,196,67,17,66,66,225,244,5,232,254,6,192,127,5,237,176,80,76,168,158,143,120,
  3,151,42,1,0,0,53,208,66,10,17,99,131,32,128,198,104,132,63,146,56,20,16,8,
  16,145,23,238,238,160,224,196,119,192,29,48,195,130,1,60,102,0,31,216,8,207,
  1,156,69,23,21,133,20,34,20,214,68,1,55,128,67,0,117,104,76,228,94,146,136,
  204,108,6,252,66,83,178,40,119,0,117,179,96,234,17,5,40,84,3,6,71,160,9,8,6,
  4,64,182,16,60,49,79,104,17,184,10,174,62,83,195,34,114,40,129,134,0,4,0,165,
  21,148,9,137,246,0,16,174,20,171,142,152,129,85,70,32,134,0,91,160,24,67,136,
  222,134,88,6,114,101,137,211,154,0,29,3,64,176,16,27,245,175,96,8,91,42,56,
  3,85,67,213,241,2,75,161,21,18,144,0,241,183,98,133,41,139,227,87,0,92,4,89,
  8,29,31,130,114,140,120,16,176,64,241,226,96,11,14,197,7,4,192,11,0,45,245,
  79,195,3,2,194,248,26,204,46,169,234,196,136,123,140,96,8,130,31,16,65,6,210,
  234,216,11,74,145,133,73,193,63,0,128,3,48,45,160,17,15,104,131,135,48,19,115,
  78,198,64,238,168,44,64,71,205,220,42,141,72,70,200,192,12,80,17,138,140,8,
  129,191,80,0,1,72,163,61,27,77,52,16,194,37,170,58,212,10,55,73,70,78,226,0,
  36,130,168,84,52,252,84,41,16,194,16,1,214,1,79,105,16,47,0,70,38,192,97,167,
  24,68,161,68,240,65,4,27,88,52,19,201,98,246,227,203,96,161,131,81,27,244,30,
  75,64,23,9,100,8,182,84,141,61,97,14,18,32,192,143,152,153,18,0,102,126,194,
  224,129,173,3,168,9,64,97,216,79,8,188,197,176,104,250,53,197,228,250,21,32,
  52,1,16,162,184,194,68,168,221,89,146,8,228,103,208,1,76,152,58,67,232,18,240,
  23,160,15,161,203,108,240,7,5,100,8,37,52,161,84,30,74,215,160,25,231,133,2,
  0,72,1,113,214,26,24,103,215,211,0,4,212,68,62,179,235,0,1,232,59,0,109,189,
  136,5,136,10,211,151,26,91,26,32,8,129,8,114,115,38,131,84,36,74,10,0,29,101,
  136,0,64,64,104,70,236,74,96,2,0,65,5,2,24,64,138,160,118,78,218,128,6,114,
  165,131,14,66,189,133,218,4,17,34,2,33,43,240,13,114,0,43,224,132,57,128,206,
  115,144,170,101,232,205,220,161,9,117,92,26,4,24,113,106,2,248,0,249,137,192,
  20,16,19,198,1,59,248,0,226,85,38,240,141,64,40,79,243,224,179,192,170,224,
  2,145,113,111,4,105,96,103,162,2,82,2,142,24,23,205,30,0,129,68,9,40,190,134,
  200,141,150,142,228,17,0,156,52,27,64,74,202,202,24,17,107,80,12,110,204,48,
  83,206,2,0,96,66,217,232,209,192,128,200,209,74,231,66,177,112,12,21,202,67,
  77,92,40,14,72,129,0,18,32,8,171,191,52,12,48,164,193,75,144,1,58,228,2,195,
  13,232,21,37,31,210,33,164,8,17,11,119,138,1,113,13,116,213,177,28,60,128,182,
  125,135,230,209,76,3,192,2,64,5,122,54,161,76,255,62,4,4,50,133,4,33,234,140,
  144,148,120,74,197,173,172,215,113,1,165,219,131,56,35,8,8,102,227,168,63,69,
  22,46,239,106,162,49,204,227,153,177,204,100,36,144,188,60,128,36,152,249,132,
  127,254,200,125,33,239,11,131,145,154,62,172,125,81,244,227,128,141,253,172,
  214,145,201,116,166,165,99,78,179,241,177,167,217,248,24,212,236,252,12,106,
  118,125,198,53,27,62,179,26,125,159,64,235,158,62,44,42,101,80,177,31,49,108,
  125,9,98,129,49,155,144,112,113,15,161,248,48,133,84,161,44,145,109,13,144,
  214,63,72,177,57,51,217,1,104,89,81,225,152,199,107,72,220,102,179,239,228,
  177,241,245,87,76,33,145,81,194,134,83,11,62,175,125,98,50,96,193,68,115,115,
  92,120,49,202,249,97,99,141,158,148,176,51,99,173,179,217,246,49,23,46,41,9,
  202,119,254,113,148,25,255,55,228,74,250,238,243,139,253,93,0,0,8,232,0,39,
  169,29,66,41,14,19,19,120,136,155,105,178,196,212,166,31,58,102,221,184,216,
  118,166,91,62,28,22,251,254,254,190,55,189,61,37,162,34,111,232,186,45,111,
  77,173,255,10,139,98,194,204,133,130,173,81,228,59,99,214,183,169,14,198,117,
  233,171,37,125,76,156,107,2,202,216,113,26,72,141,68,41,107,33,215,20,194,174,
  170,231,214,166,223,13,171,168,189,167,90,180,228,81,48,40,43,36,54,204,65,
  2,44,50,185,108,9,22,232,114,34,144,110,120,1,142,156,58,37,132,97,132,180,
  24,116,142,90,144,163,175,24,91,0,91,30,200,87,84,167,100,96,59,177,207,46,
  169,165,190,88,198,57,86,166,203,0,247,252,213,143,112,134,213,245,183,42,253,
  229,179,31,174,94,16,211,154,45,190,168,5,194,156,43,107,14,23,37,109,190,228,
  96,20,217,70,26,244,158,182,219,166,75,96,160,108,215,173,218,1,70,225,172,
  165,139,212,217,236,188,2,160,224,104,177,37,225,129,188,10,152,62,116,80,3,
  181,98,176,93,33,81,232,170,231,155,147,77,193,0,27,168,149,216,225,80,154,
  172,3,214,208,5,147,237,69,233,25,218,179,113,17,234,195,105,192,59,121,102,
  70,57,123,42,238,149,202,106,218,234,229,6,226,187,178,132,190,47,34,61,154,
  33,54,142,110,148,162,170,81,134,219,94,62,42,128,168,56,10,54,6,81,185,119,
  131,10,92,109,249,210,61,70,40,187,87,232,54,107,92,233,12,168,186,243,166,
  4,17,142,196,131,13,96,50,80,25,46,55,77,214,177,53,88,35,65,115,10,219,160,
  168,167,212,2,245,252,68,167,48,138,116,37,222,142,212,1,130,88,235,55,5,169,
  77,94,119,89,49,217,133,214,171,50,234,94,162,211,34,41,31,171,61,23,36,59,
  52,54,113,175,182,42,185,204,39,77,6,167,93,197,166,116,117,123,110,184,215,
  134,203,5,19,86,112,46,190,215,155,197,183,52,107,77,243,99,130,141,245,218,
  238,236,191,205,130,146,32,58,218,101,192,192,184,213,65,113,160,213,209,130,
  149,201,90,32,29,4,80,118,160,155,21,170,241,243,63,30,223,111,49,252,242,78,
  195,88,144,160,96,84,138,163,33,31,114,194,113,62,45,51,73,180,241,88,104,24,
  191,221,136,3,30,145,43,196,125,86,30,82,227,192,117,156,7,28,55,64,26,218,
  19,247,156,164,96,200,162,193,55,163,15,35,134,34,219,56,222,109,11,181,132,
  71,232,56,17,243,203,145,17,188,79,124,121,121,178,24,49,98,117,4,217,40,161,
  191,109,182,158,113,34,46,192,236,203,196,17,34,186,190,102,168,152,58,26,222,
  249,176,243,110,61,244,168,186,243,76,40,81,163,103,0,84,119,31,0,136,14,70,
  92,4,11,87,151,14,148,119,50,0,153,174,251,116,171,207,54,159,16,120,184,238,
  54,42,222,244,222,209,220,165,101,224,145,250,186,185,122,220,240,163,130,0,
  180,115,59,107,222,44,225,156,247,28,150,201,195,194,126,173,53,190,208,157,
  21,14,160,186,111,189,133,255,104,147,120,159,199,239,145,92,31,155,26,119,
  37,10,116,97,88,242,226,48,166,1,202,135,28,60,96,5,21,173,192,173,24,246,57,
  178,126,124,219,85,22,23,224,18,174,118,157,244,203,119,118,132,48,152,62,32,
  241,126,94,14,141,189,121,49,242,161,176,146,132,55,31,224,23,182,47,248,65,
  152,70,35,168,171,201,42,34,228,199,240,110,212,191,25,0,79,66,253,0,201,81,
  31,138,30,182,128,144,81,250,120,173,185,156,189,156,28,42,56,58,74,232,225,
  156,43,111,68,38,14,159,244,223,65,217,166,15,147,216,54,226,35,103,199,255,
  39,79,166,189,131,208,255,58,12,192,203,15,42,146,165,96,146,104,52,187,10,
  119,180,61,0,190,124,189,220,165,221,97,78,12,175,124,68,118,84,53,148,220,
  126,236,200,37,122,219,54,62,146,165,6,239,73,221,62,69,16,113,28,223,54,251,
  225,149,244,190,239,164,71,44,197,190,51,118,252,232,74,248,168,74,141,155,
  242,44,25,104,239,235,94,117,38,52,27,195,147,216,47,8,117,29,4,202,17,29,205,
  238,143,167,8,238,58,76,219,64,166,227,194,188,31,75,205,28,100,247,231,179,
  145,135,159,117,223,141,54,245,151,205,139,70,124,182,191,79,87,78,67,20,146,
  88,111,150,242,90,177,97,200,159,216,17,195,138,244,145,43,182,154,30,181,55,
  244,50,55,183,244,214,227,67,35,191,155,229,192,200,44,251,92,55,244,168,59,
  0,69,193,0,28,34,128,247,246,28,241,230,9,239,143,108,63,253,87,211,239,124,
  242,49,125,33,74,200,41,117,45,125,121,24,98,224,251,126,166,97,80,98,110,115,
  23,31,40,145,107,11,247,185,148,70,21,7,219,160,56,161,137,74,171,76,65,150,
  114,24,85,54,177,144,180,99,8,133,209,137,53,241,109,32,199,1,54,64,31,185,
  100,7,76,154,95,241,113,121,119,129,214,65,102,112,163,119,241,67,86,207,182,
  226,14,21,7,4,244,243,33,122,22,126,114,99,233,12,64,210,115,190,183,46,117,
  59,184,26,241,209,243,56,111,89,57,80,122,12,34,213,67,119,55,144,203,217,226,
  218,250,198,200,233,142,30,77,47,239,9,149,206,95,54,86,87,125,129,27,76,29,
  243,237,152,162,118,42,66,121,77,156,72,163,124,109,248,58,13,83,212,117,35,
  93,181,161,2,15,68,248,42,54,64,178,51,23,132,42,95,8,2,45,166,233,233,140,
  113,0,95,108,80,39,154,51,171,150,193,244,112,70,136,44,145,39,132,120,169,
  223,111,162,176,137,42,246,230,220,131,236,176,222,78,92,101,232,110,122,91,
  157,227,113,226,168,189,148,173,161,133,214,189,222,6,147,74,245,93,190,166,
  128,212,94,32,73,86,30,112,196,7,82,48,108,84,212,17,205,139,241,211,246,178,
  212,80,236,98,86,47,216,168,212,86,153,193,82,107,172,125,15,70,29,205,223,
  201,232,120,30,100,17,27,107,246,114,252,104,63,6,98,127,245,242,242,21,160,
  240,15,11,116,79,10,163,92,94,77,104,139,115,238,255,66,254,162,204,224,236,
  137,156,127,76,246,62,62,173,201,170,34,81,242,106,164,247,171,81,75,130,25,
  191,199,158,134,12,157,230,77,29,68,40,70,20,48,214,108,12,226,149,65,32,16,
  157,98,71,98,8,112,222,137,181,64,17,227,180,153,85,1,187,141,228,10,243,10,
  220,74,0,169,53,127,211,220,224,43,111,167,235,231,202,60,161,117,58,215,229,
  44,16,162,125,211,32,76,254,173,76,222,188,2,156,109,47,220,141,58,143,111,
  57,243,160,106,82,1,253,243,217,22,59,32,97,189,13,45,1,196,208,61,39,192,237,
  248,14,93,87,123,39,31,223,79,100,63,171,113,108,89,33,85,68,18,45,234,238,
  69,100,17,2,63,130,226,226,65,214,47,73,192,48,214,59,95,233,176,35,172,72,
  92,74,218,215,179,78,79,186,132,125,115,98,31,230,146,15,18,169,255,0,203,160,
  245,69,96,50,14,159,142,11,172,194,213,243,199,41,124,12,116,155,197,40,210,
  110,174,47,143,71,164,36,5,66,8,48,14,37,243,251,207,242,172,137,170,241,94,
  98,75,130,138,248,160,168,199,91,161,26,63,241,177,192,24,249,74,124,121,217,
  99,205,145,237,189,158,63,37,229,192,253,212,221,106,158,59,130,178,96,227,
  238,157,18,174,73,164,13,138,153,175,137,65,146,122,219,115,235,108,60,171,
  206,51,51,232,136,40,241,224,143,74,240,142,197,73,130,129,241,137,225,193,
  238,105,48,73,13,216,3,110,218,99,194,82,87,99,249,26,109,44,94,59,101,202,
  21,207,217,213,28,137,111,30,203,154,55,64,155,64,47,52,27,118,195,39,110,165,
  89,67,155,208,248,5,255,51,229,230,218,228,103,47,62,199,42,138,95,192,142,
  38,221,41,59,165,192,238,131,164,14,83,249,138,218,107,40,187,199,178,207,225,
  74,253,179,0,32,180,192,27,39,81,72,21,71,155,75,223,225,180,36,103,108,166,
  99,136,104,0,112,129,251,108,131,242,49,17,192,56,235,23,197,71,179,205,168,
  232,13,32,198,239,99,24,124,247,216,201,242,245,107,52,137,119,164,237,42,46,
  134,158,137,126,141,164,229,127,223,123,73,204,37,156,42,68,68,136,131,119,
  50,125,231,78,220,110,45,219,50,128,105,65,76,79,80,224,132,104,64,252,119,
  110,164,182,194,99,33,180,73,165,159,163,33,169,69,31,125,221,231,187,32,169,
  93,124,127,172,38,139,118,171,69,32,241,64,187,61,7,79,199,147,24,57,211,203,
  199,151,155,65,151,172,117,231,209,91,209,117,158,111,31,87,116,143,114,135,
  221,15,99,45,142,42,211,9,94,46,225,99,48,120,5,21,67,138,248,223,82,66,45,
  89,133,134,136,215,157,154,225,108,83,206,225,139,94,209,191,67,149,28,141,
  74,49,150,37,140,199,17,58,130,164,64,77,222,185,78,63,38,255,89,40,34,252,
  18,223,87,72,46,5,11,123,70,50,234,241,146,57,225,81,192,19,242,31,48,192,114,
  127,203,253,157,214,113,61,196,195,172,120,236,14,157,197,99,45,183,48,237,
  154,12,202,94,62,249,23,17,225,185,22,163,131,55,0,159,57,88,17,75,37,167,13,
  227,29,198,86,130,8,14,130,51,8,41,222,1,100,146,13,130,143,27,34,45,48,211,
  212,19,147,139,197,17,126,95,134,55,94,177,50,56,84,202,192,173,95,215,104,
  66,217,188,5,178,3,245,98,36,159,190,103,54,149,179,4,159,158,89,134,85,181,
  108,62,150,234,207,185,105,253,64,6,147,12,228,230,247,66,91,211,220,24,84,
  248,152,158,219,34,125,3,85,243,195,195,236,57,129,11,205,156,222,111,227,116,
  137,7,63,86,121,179,31,229,28,110,124,61,183,220,61,202,94,119,31,39,168,227,
  43,3,30,139,125,11,80,108,56,104,39,134,187,21,151,78,46,238,94,250,172,69,
  157,67,242,241,121,101,121,69,150,116,79,67,251,67,218,35,162,243,251,194,94,
  235,173,225,108,163,19,245,8,193,123,142,61,91,65,230,38,24,168,153,63,137,
  248,170,151,11,197,232,10,48,27,253,188,44,177,235,181,141,63,195,210,56,247,
  70,110,56,234,11,118,103,133,173,60,187,58,42,11,192,111,55,73,243,170,231,
  232,37,55,245,103,209,116,126,250,107,240,14,145,139,250,30,185,61,199,93,107,
  214,219,62,56,182,8,133,134,52,169,89,83,73,214,18,195,40,71,169,168,196,154,
  250,167,241,120,160,123,235,181,36,235,216,107,216,117,144,16,230,58,80,252,
  173,9,153,53,138,10,249,94,25,189,24,128,104,143,92,183,213,7,79,24,170,240,
  11,28,165,237,62,77,8,147,17,183,86,219,101,182,100,221,104,246,179,197,32,
  139,164,77,210,56,230,41,144,183,179,149,31,125,15,154,11,215,58,49,138,27,
  211,248,112,116,173,10,29,184,111,43,221,157,158,128,165,134,81,75,30,184,156,
  119,226,151,19,129,210,114,73,200,159,101,151,121,203,225,198,89,68,71,234,
  224,249,243,46,138,133,120,72,136,28,122,53,51,214,248,254,187,47,43,242,242,
  72,40,211,74,225,10,65,207,40,250,74,43,28,77,164,166,191,120,72,111,22,195,
  103,222,112,96,113,248,141,39,40,168,185,188,80,181,217,20,134,222,161,204,
  67,17,4,17,192,89,173,17,108,184,4,160,108,149,225,255,141,9,159,18,69,135,
  54,202,7,89,165,219,95,252,241,45,194,162,212,38,69,195,88,63,202,218,145,9,
  186,3,34,191,253,112,44,195,211,180,151,116,73,0,34,178,119,42,20,117,187,182,
  26,93,156,99,146,44,110,114,246,50,241,21,205,17,178,210,79,32,201,48,72,170,
  150,218,30,202,194,85,46,101,89,123,107,154,145,189,45,150,163,148,78,155,69,
  71,161,87,20,228,224,203,192,150,110,177,130,244,60,130,65,12,165,226,19,215,
  40,201,166,5,177,220,29,77,254,210,189,21,93,227,230,75,48,35,177,209,139,157,
  110,200,59,96,115,94,159,227,200,146,228,225,246,199,204,8,200,5,166,197,95,
  9,67,244,142,135,9,250,181,32,199,10,224,247,248,27,113,32,156,170,25,229,246,
  92,85,250,69,193,156,95,18,236,241,211,32,146,212,140,141,21,91,229,61,74,5,
  163,50,160,208,67,106,62,210,117,170,132,151,99,28,211,199,129,37,59,23,246,
  253,57,161,7,163,186,202,17,112,56,155,130,35,148,204,125,183,113,102,58,90,
  112,47,133,231,204,159,35,27,148,90,228,187,128,84,91,145,16,100,0,116,33,223,
  188,74,155,130,32,135,249,176,159,180,80,55,105,1,151,2,31,116,29,207,31,136,
  32,112,124,248,47,195,104,55,78,141,151,66,167,195,105,210,141,7,170,72,232,
  220,69,72,161,173,72,52,146,191,188,145,242,128,83,227,156,133,12,0,136,32,
  57,249,196,35,197,243,218,95,219,19,228,26,246,1,71,196,173,195,58,216,41,156,
  43,213,71,84,54,28,122,97,120,181,26,24,229,61,248,95,68,100,85,44,165,179,
  172,161,225,51,122,189,240,45,13,216,208,134,187,102,79,143,8,113,122,72,99,
  164,189,9,17,37,35,194,65,180,226,236,126,81,248,147,193,210,193,40,202,63,
  193,74,197,91,106,48,91,68,25,61,226,144,131,141,26,74,130,6,45,191,94,114,
  201,55,218,221,224,163,120,48,77,23,227,208,130,15,222,228,201,219,91,155,101,
  105,21,177,144,34,122,122,231,106,126,208,255,218,99,161,100,26,109,97,39,30,
  30,108,28,119,242,41,170,232,29,158,31,125,141,46,30,194,156,41,98,229,79,214,
  203,143,36,130,226,133,245,247,66,242,151,239,119,113,31,229,31,106,100,210,
  138,50,118,68,0,132,113,214,178,35,230,51,118,61,168,169,145,161,42,121,90,
  109,135,167,218,8,148,80,144,218,28,98,138,8,224,113,130,96,230,57,80,90,158,
  81,224,216,174,93,222,0,7,63,122,124,111,96,127,229,225,195,232,33,36,197,12,
  246,179,3,98,162,86,220,116,184,110,100,131,167,208,28,247,195,186,155,158,
  58,78,218,204,88,45,220,216,229,23,142,93,71,26,87,34,93,50,129,126,232,59,
  183,175,192,176,211,85,135,74,65,188,243,149,122,185,3,96,234,13,176,112,41,
  104,99,8,126,189,129,21,241,80,4,210,14,66,6,1,32,91,23,163,227,246,210,189,
  239,55,95,45,16,97,25,12,50,15,98,39,82,25,234,162,10,218,167,14,48,144,149,
  185,9,169,112,51,184,20,96,181,147,74,35,207,8,174,81,33,218,59,69,38,77,100,
  170,88,216,81,150,50,133,102,232,143,85,251,224,15,31,150,33,195,101,186,42,
  126,242,17,128,16,123,117,35,152,139,136,56,66,14,25,79,119,198,51,149,105,
  21,2,99,35,38,222,95,190,248,61,164,235,43,68,247,166,86,242,249,239,59,149,
  159,181,227,239,176,52,27,65,194,204,227,169,184,28,59,189,147,164,97,200,78,
  92,232,189,194,168,255,99,151,65,163,247,87,96,212,59,209,240,126,209,240,254,
  200,206,63,175,179,185,209,122,222,35,68,46,94,160,159,143,247,227,33,72,92,
  108,188,57,198,30,218,5,27,213,7,240,164,90,193,68,73,46,243,13,190,191,197,
  37,113,140,8,56,32,76,35,105,135,104,16,90,71,79,158,159,83,177,229,38,136,
  248,220,239,103,84,178,100,123,186,29,249,226,208,136,118,25,236,243,244,72,
  21,114,159,128,75,187,166,236,10,193,36,71,196,239,132,254,154,77,75,170,140,
  24,106,134,197,224,224,100,156,57,52,93,101,233,243,67,19,31,7,134,81,15,214,
  188,218,55,41,138,121,167,180,217,197,25,118,124,57,195,149,1,156,203,0,49,
  58,20,197,22,58,17,6,220,220,70,27,215,80,223,149,12,158,143,164,232,251,108,
  185,129,61,174,137,116,33,79,67,161,192,182,0,113,75,168,195,118,138,14,71,
  127,23,52,74,71,103,29,202,210,251,13,230,37,48,159,190,230,220,177,200,109,
  174,243,100,113,92,33,5,186,215,157,37,97,190,53,215,250,247,164,192,218,50,
  17,187,235,55,15,93,47,48,101,221,106,230,247,179,192,175,221,47,9,85,56,13,
  252,60,210,117,143,245,25,94,106,153,141,231,177,34,237,49,119,7,199,151,215,
  254,86,178,7,242,33,151,244,153,82,36,176,35,239,6,223,103,63,42,202,62,127,
  30,243,112,85,156,167,221,225,242,224,190,213,226,200,231,24,16,106,241,84,
  204,58,136,14,50,58,44,147,79,193,38,40,125,48,224,64,166,61,111,90,96,69,214,
  137,32,42,124,105,15,77,190,31,221,145,91,218,74,61,137,6,200,64,203,161,171,
  178,42,158,90,237,57,156,136,221,55,32,87,233,39,30,54,153,88,140,66,113,245,
  241,197,187,13,137,97,211,200,20,67,146,85,147,122,72,254,26,204,146,73,34,
  211,250,144,215,0,200,233,205,90,251,213,195,214,58,208,249,221,210,119,240,
  33,237,228,61,253,191,248,170,135,239,104,66,124,164,212,208,246,34,194,140,
  222,42,17,111,150,0,103,28,32,172,200,45,244,52,144,105,48,168,235,227,151,
  224,73,221,170,66,237,1,171,26,223,194,75,48,49,95,33,153,223,139,239,239,106,
  213,148,1,65,5,139,55,47,17,242,172,150,184,119,224,14,9,102,74,36,29,138,42,
  118,59,190,249,79,35,250,78,129,207,237,133,102,109,14,13,139,1,242,112,83,
  205,56,94,187,131,178,234,42,213,249,50,171,192,32,42,26,103,36,93,72,183,25,
  28,160,55,32,241,203,37,50,11,67,55,12,200,164,100,56,92,2,127,115,227,254,
  187,114,17,225,140,14,164,79,182,255,63,235,143,202,94,136,145,84,77,212,34,
  216,241,173,37,0,84,238,68,26,0,55,30,206,174,186,193,142,132,254,194,21,139,
  239,253,142,105,39,46,214,231,204,199,63,144,80,87,144,70,216,28,50,127,80,
  99,251,236,248,155,155,3,98,0,32,32,224,81,168,206,164,51,226,25,34,243,116,
  148,19,44,25,243,189,173,31,89,106,59,185,121,121,32,105,34,170,76,95,37,169,
  156,68,37,55,7,16,110,235,52,250,216,208,47,108,194,164,200,165,198,234,135,
  65,15,82,198,248,188,175,87,164,23,213,118,203,222,211,223,233,182,234,52,113,
  124,205,181,119,119,188,16,133,66,163,151,54,172,67,26,46,161,228,47,122,134,
  73,90,114,23,214,178,105,25,36,117,29,72,216,194,27,65,170,169,26,240,146,112,
  227,121,49,77,25,81,114,9,31,86,144,39,10,217,177,87,181,156,100,229,80,17,
  186,97,143,229,243,251,208,77,43,162,17,244,69,34,149,17,188,132,54,24,56,164,
  130,147,21,150,246,153,109,95,79,128,248,70,114,240,111,150,44,124,131,30,196,
  52,78,104,183,198,116,93,221,117,2,26,104,68,101,188,45,72,4,52,54,59,44,73,
  133,135,120,155,254,236,214,215,79,189,187,87,22,182,157,101,20,141,193,132,
  1,113,133,37,73,216,72,249,157,146,241,54,144,216,21,236,151,99,67,50,212,142,
  107,212,8,35,1,200,105,33,21,67,66,92,83,229,120,183,207,74,167,81,71,80,88,
  240,65,46,172,115,73,95,235,82,215,30,109,175,226,151,0,139,114,255,41,62,249,
  78,159,241,62,142,77,50,186,47,186,115,67,25,32,53,38,137,113,159,171,242,139,
  213,62,239,198,220,125,169,19,6,245,180,77,152,106,218,87,199,179,172,20,107,
  83,132,218,31,75,44,59,138,176,57,56,35,245,101,148,191,181,64,199,121,215,
  205,94,247,37,189,218,7,114,55,139,40,178,88,25,100,231,224,239,46,78,201,73,
  28,59,141,148,97,39,91,145,140,59,16,213,185,233,91,137,104,23,106,58,146,176,
  139,15,207,215,230,202,65,220,110,165,70,155,122,72,17,247,81,106,114,9,50,
  192,142,231,126,46,63,194,244,255,30,201,157,96,101,137,138,233,222,145,46,
  31,185,131,87,160,16,82,244,213,213,130,175,90,227,50,134,237,3,185,0,106,167,
  91,9,156,126,48,177,158,93,65,239,216,228,108,137,177,10,251,142,42,179,107,
  139,130,227,224,7,40,7,161,149,20,228,213,37,4,115,35,183,155,114,194,211,134,
  71,166,8,250,142,56,211,4,75,52,25,14,3,17,28,192,252,167,42,232,76,219,123,
  26,183,101,44,184,93,80,97,97,189,234,132,233,126,23,34,178,139,171,178,8,229,
  211,228,204,2,52,59,170,223,208,93,196,39,94,173,225,195,36,116,211,82,76,113,
  252,155,187,74,213,41,170,16,17,20,65,57,51,168,210,72,142,21,73,44,197,36,
  247,207,13,32,229,152,171,177,92,129,192,146,214,21,219,194,86,79,36,200,85,
  241,8,239,254,200,123,183,10,187,45,129,65,98,249,142,84,205,177,28,223,71,
  189,65,43,132,18,186,33,221,177,207,94,13,188,151,111,57,217,103,169,9,102,
  219,111,171,230,44,23,81,1,117,34,109,189,81,98,13,208,164,227,132,129,195,
  229,140,63,60,233,46,171,118,161,49,239,80,112,91,205,54,76,237,234,250,183,
  190,165,101,133,151,36,186,57,220,38,33,145,58,59,190,221,157,219,60,246,192,
  69,213,99,188,91,237,29,190,145,183,222,175,234,227,247,73,160,178,255,87,239,
  121,145,213,81,234,161,93,143,158,166,237,16,171,170,14,225,247,54,6,83,156,
  214,14,111,157,228,223,27,51,47,155,110,158,110,113,166,12,204,153,140,228,
  144,37,45,241,204,78,53,16,154,90,51,154,79,195,201,128,83,251,153,219,204,
  210,112,135,204,222,166,225,68,241,99,128,39,36,131,56,76,7,179,243,179,146,
  88,95,187,4,249,99,107,19,243,138,232,76,139,124,92,9,156,229,138,73,155,68,
  205,102,111,145,19,121,255,107,246,97,201,195,93,38,224,133,156,19,121,88,203,
  84,120,221,243,145,13,1,103,225,189,142,202,44,225,81,145,232,148,167,187,28,
  88,249,245,97,97,19,146,86,147,147,12,89,135,194,43,144,12,24,19,175,216,40,
  201,142,86,116,222,126,177,181,138,41,245,197,92,232,84,233,52,194,58,229,103,
  87,103,71,38,105,5,33,51,18,50,179,121,148,225,151,238,222,30,160,216,104,145,
  207,189,187,37,15,187,51,167,117,40,91,63,166,78,228,5,156,80,13,149,202,83,
  229,86,138,40,99,72,24,156,30,194,174,149,67,145,129,41,233,189,141,69,22,57,
  61,81,172,7,130,154,76,41,135,33,56,86,231,154,46,10,8,85,42,86,115,120,42,
  224,88,163,171,4,77,42,39,85,97,215,127,231,227,159,224,177,226,214,223,232,
  175,58,69,103,231,27,131,50,22,39,169,81,62,145,167,98,74,96,172,205,239,90,
  148,167,218,24,114,5,102,89,114,97,80,143,142,145,137,152,115,12,77,227,90,
  25,220,180,214,254,60,9,70,124,242,254,131,105,25,10,86,122,242,218,84,202,
  21,157,245,236,53,149,172,188,23,120,59,82,166,32,45,38,39,251,119,59,1,134,
  187,41,82,148,245,155,153,226,57,226,132,87,127,142,153,89,247,213,216,85,214,
  224,204,201,7,249,169,45,12,174,4,241,5,136,214,75,63,0,209,186,37,247,189,
  219,187,215,239,230,228,154,166,0,44,250,241,241,94,51,130,159,231,39,100,167,
  41,135,121,171,243,248,148,25,208,12,68,67,117,57,237,62,214,226,145,255,161,
  30,48,200,169,74,99,220,98,35,56,95,176,144,127,247,108,239,209,239,195,226,
  59,141,73,254,202,61,250,48,128,224,41,14,83,161,70,151,33,34,49,62,136,237,
  42,251,198,72,172,74,19,72,10,39,128,168,93,27,142,40,52,0,177,82,214,24,19,
  198,16,94,12,216,214,122,209,252,193,157,39,39,2,46,99,221,191,241,23,20,187,
  120,250,68,199,50,48,39,83,65,89,155,60,195,178,48,98,199,6,195,19,48,103,2,
  205,157,149,13,229,237,35,105,33,139,42,84,89,231,88,69,208,166,12,105,112,
  113,139,38,236,38,110,195,25,226,94,164,154,70,70,39,1,68,185,53,65,38,70,96,
  79,13,173,200,149,159,52,228,96,191,118,254,102,108,112,39,193,8,209,87,235,
  251,202,63,35,81,80,66,74,138,163,144,177,167,196,37,25,220,155,163,114,197,
  60,148,138,164,32,215,249,155,156,247,43,237,46,24,23,21,40,32,57,214,57,20,
  226,214,24,184,71,21,63,7,14,77,65,209,7,110,132,35,169,254,238,232,79,119,
  50,110,228,23,102,28,116,129,39,136,241,223,158,124,189,66,86,13,20,24,152,
  167,15,186,254,202,21,97,42,98,61,189,169,225,169,209,199,223,217,199,47,58,
  24,43,177,94,114,89,252,164,28,198,175,252,96,35,162,122,207,84,116,70,14,102,
  135,2,33,244,63,83,18,64,66,58,174,201,17,197,157,214,59,182,196,118,166,230,
  77,48,196,77,95,21,82,208,0,177,122,96,8,42,195,162,10,136,103,150,122,197,
  54,35,170,39,233,11,26,177,140,214,80,238,123,62,248,150,156,74,252,212,25,
  210,137,255,99,119,209,99,123,182,116,99,72,14,156,82,197,26,136,136,128,112,
  39,76,133,19,155,173,70,39,179,13,179,152,78,94,40,131,176,12,214,145,76,79,
  28,76,122,100,138,205,150,163,133,53,183,239,134,102,142,21,230,156,169,69,
  83,134,178,107,38,17,209,116,112,246,25,214,211,29,23,102,254,70,127,228,148,
  168,138,134,178,207,74,233,65,8,30,142,42,96,32,102,108,177,110,121,147,214,
  10,37,61,5,24,209,88,241,72,145,136,168,16,151,43,24,12,117,5,45,14,73,247,
  252,185,44,194,26,83,196,192,238,183,87,101,225,228,30,129,71,232,79,254,163,
  2,62,75,71,132,134,149,159,200,140,138,140,148,155,6,110,108,210,254,180,223,
  165,151,44,147,77,68,95,21,121,24,2,97,185,138,122,243,186,226,153,78,24,192,
  25,11,169,169,198,249,223,230,172,1,107,221,229,25,192,233,93,238,54,246,58,
  60,87,59,234,41,165,165,69,152,150,130,87,243,45,143,50,87,201,39,164,76,145,
  139,60,79,64,141,16,78,66,156,64,169,124,25,136,54,124,164,52,20,162,126,189,
  211,59,154,216,224,21,136,125,45,227,247,10,76,216,56,147,95,216,177,45,8,55,
  43,22,53,13,0,65,10,78,3,12,71,134,79,64,213,217,255,191,169,7,69,158,82,217,
  69,17,216,73,40,10,0,159,75,74,129,172,90,160,67,178,26,76,48,214,28,75,122,
  32,177,123,212,133,117,53,57,222,41,124,124,233,47,252,151,222,225,64,154,30,
  252,110,195,157,2,16,199,229,243,251,205,127,95,63,193,135,89,88,229,103,33,
  190,170,146,146,212,52,21,159,84,247,213,191,72,70,246,26,98,47,108,72,33,64,
  140,8,95,169,173,6,138,37,16,69,96,177,137,142,86,17,63,57,249,198,179,101,
  73,135,51,230,26,88,172,59,141,11,99,127,54,182,178,176,54,144,136,245,24,187,
  134,13,133,222,197,31,36,108,62,32,176,71,199,224,75,178,106,46,196,39,100,
  4,219,223,177,92,176,106,85,247,61,220,19,231,206,204,146,174,42,54,21,113,
  18,240,239,153,138,58,101,8,238,192,207,130,209,199,36,125,226,116,122,141,
  67,168,34,66,197,120,104,211,217,250,193,167,223,214,16,164,24,177,48,53,222,
  149,133,92,69,223,66,210,221,148,41,7,255,13,157,158,252,237,76,92,158,198,
  22,167,22,160,155,255,31,15,134,222,207,120,229,195,206,62,252,96,192,158,220,
  59,105,16,148,19,220,181,171,175,97,133,17,112,39,46,171,75,166,52,248,115,
  207,138,79,119,36,183,192,199,67,126,173,0,76,18,18,132,130,162,60,203,139,
  136,141,129,93,9,103,90,23,223,161,215,218,19,199,107,40,87,54,99,121,251,243,
  145,181,141,96,162,96,246,60,246,247,229,217,135,12,191,174,232,32,226,197,
  177,74,52,46,11,52,128,231,4,158,143,3,28,50,78,10,197,56,205,172,42,98,32,
  6,142,239,132,140,59,12,68,74,210,229,74,81,79,52,40,140,218,10,198,230,35,
  117,253,197,95,159,156,154,74,100,216,43,22,230,27,14,83,5,82,67,105,72,9,236,
  233,157,26,50,58,195,16,128,61,23,119,191,223,82,212,82,114,177,23,225,24,16,
  237,47,91,217,201,26,157,76,254,240,251,49,243,185,218,208,233,66,221,53,169,
  114,50,179,24,6,159,12,1,252,156,126,97,175,233,57,89,196,154,172,152,255,39,
  192,198,178,137,48,196,82,107,81,13,42,39,167,114,187,116,35,128,33,110,201,
  69,203,128,37,17,73,58,44,37,142,229,80,116,65,153,21,130,173,42,127,45,20,
  202,204,59,109,142,88,12,105,193,56,132,131,49,236,216,134,0,127,151,249,215,
  75,65,88,63,117,195,110,204,72,250,49,3,2,21,159,55,206,94,49,255,53,37,232,
  138,61,203,237,119,35,70,222,96,53,105,6,0,177,7,15,237,95,71,64,116,52,59,
  246,154,85,222,218,191,175,156,36,214,29,138,14,33,193,92,15,60,119,244,85,
  247,251,1,246,183,223,190,201,12,106,41,77,65,241,5,92,93,204,115,3,119,118,
  45,71,12,120,72,157,180,50,81,65,76,101,137,159,78,39,224,85,116,114,243,183,
  43,30,64,129,238,216,57,122,95,27,128,164,88,184,81,176,24,205,181,213,118,
  252,170,135,101,142,35,200,13,175,213,140,96,1,55,103,95,111,200,247,34,229,
  246,93,29,8,242,5,6,175,30,205,63,185,100,16,176,124,195,201,208,214,83,165,
  57,13,49,162,116,109,242,90,55,86,244,244,181,160,37,110,125,124,15,220,96,
  47,139,20,114,110,75,248,248,150,10,28,18,109,111,248,48,216,236,54,74,114,
  194,243,135,149,148,25,72,69,27,189,2,235,23,137,81,176,192,20,65,50,50,225,
  93,180,129,24,177,7,164,99,119,206,108,144,131,3,127,180,148,138,229,96,193,
  172,235,22,236,144,5,98,108,1,15,114,49,25,105,12,18,103,34,49,22,4,229,24,
  225,242,77,207,255,80,232,166,84,79,2,249,116,202,236,134,149,196,59,184,34,
  50,131,70,115,74,148,46,231,175,186,7,240,141,46,153,100,204,32,98,122,44,233,
  195,59,155,246,222,92,107,227,217,190,242,196,116,118,112,247,141,82,185,46,
  165,72,115,43,48,225,167,250,216,166,59,28,21,41,192,26,60,217,218,26,16,98,
  136,68,0,137,147,26,108,177,128,225,179,158,23,133,90,90,201,79,55,104,209,
  172,49,25,11,24,161,132,167,73,155,12,162,209,70,57,175,239,127,171,65,138,
  32,169,136,92,38,1,160,47,129,152,112,35,179,97,136,253,120,246,226,255,132,
  169,33,165,231,234,160,21,152,74,209,99,86,61,3,105,140,196,104,98,32,99,125,
  9,140,243,152,205,134,138,88,86,242,193,248,44,124,160,198,130,177,243,68,161,
  59,120,187,7,188,252,78,28,148,150,215,34,114,162,35,113,244,190,33,239,193,
  201,200,74,63,214,38,254,73,50,91,176,216,117,148,192,136,41,46,237,75,29,161,
  14,4,19,80,97,141,6,176,198,175,163,29,183,158,8,4,164,53,47,17,51,125,171,
  59,182,169,133,56,93,78,45,195,206,146,46,241,206,165,107,71,140,28,159,212,
  212,3,114,17,47,150,30,59,144,6,4,99,26,51,175,187,213,245,149,183,170,188,
  15,14,133,225,161,210,86,93,29,78,150,222,88,240,193,159,120,150,25,41,148,
  140,140,79,228,1,70,115,115,213,45,213,160,174,164,55,132,3,214,232,38,183,
  198,175,206,111,217,177,12,243,134,31,153,168,114,32,26,77,14,76,49,56,34,203,
  6,118,98,239,72,114,243,227,88,101,41,68,99,135,3,68,200,87,17,145,213,131,
  224,170,25,53,4,218,6,227,19,177,118,102,197,181,31,172,136,45,32,165,28,226,
  175,27,82,102,96,165,30,236,90,3,28,170,146,149,176,217,17,70,4,49,85,14,12,
  168,133,1,187,194,117,37,216,224,19,129,20,84,70,1,10,75,253,231,206,78,100,
  44,93,17,75,104,184,221,61,70,123,197,73,119,153,40,25,148,248,210,165,96,138,
  136,165,23,144,46,55,110,63,11,183,143,56,111,56,7,191,75,180,98,56,68,68,10,
  142,243,102,175,71,127,87,206,67,46,10,78,106,237,80,53,67,224,55,19,32,163,
  72,113,68,192,102,33,104,69,141,160,106,162,32,98,127,95,29,80,12,56,141,61,
  5,2,20,93,63,82,144,238,104,112,86,45,252,13,23,50,185,194,238,9,58,30,149,
  215,224,179,31,52,133,49,98,145,38,14,66,193,6,72,104,176,233,130,177,141,130,
  75,236,86,238,134,228,104,64,85,13,131,138,158,241,240,248,172,216,236,162,
  137,129,69,68,62,139,142,116,8,198,66,15,149,141,55,216,38,98,197,48,136,105,
  224,209,56,4,16,155,221,127,213,171,138,144,236,115,0,67,206,251,84,250,12,
  65,252,163,67,145,56,2,35,127,197,248,16,71,137,118,146,14,131,16,199,247,63,
  184,227,195,18,54,4,41,128,24,143,142,183,105,49,169,106,124,0,129,149,141,
  104,211,75,80,182,82,187,67,79,0,107,89,243,184,6,179,255,126,54,52,132,25,
  20,221,71,153,178,185,125,171,1,119,114,8,51,44,56,168,50,182,12,231,176,8,
  104,186,175,135,83,82,0,236,37,116,29,24,113,195,196,168,203,236,82,252,112,
  71,202,32,164,135,2,207,56,198,18,198,171,53,15,119,245,97,112,11,87,190,17,
  211,171,251,62,206,220,114,132,64,228,183,45,45,103,122,223,14,100,88,165,30,
  176,168,179,217,114,75,131,97,139,16,21,192,216,116,67,84,70,10,199,178,205,
  190,124,110,66,199,123,24,162,67,148,160,154,26,25,255,137,107,28,172,66,241,
  171,0,86,24,210,241,32,13,41,102,220,185,40,82,13,96,179,36,131,50,144,40,137,
  51,2,16,165,114,117,131,229,181,52,234,47,203,73,152,22,39,181,100,55,172,98,
  66,184,17,196,39,2,45,254,35,149,11,39,126,28,49,95,107,175,228,97,127,122,
  23,251,210,104,20,9,195,33,125,141,141,224,31,30,38,131,209,236,196,31,119,
  168,171,229,131,41,162,153,10,39,187,193,84,221,45,42,0,136,23,3,101,26,33,
  6,44,88,249,116,197,133,235,252,94,241,245,45,1,146,137,74,4,29,249,204,129,
  56,16,166,24,136,17,0,180,250,90,95,103,219,138,124,234,236,229,182,51,129,
  207,254,55,155,86,146,122,104,174,0,152,7,116,33,173,35,83,13,142,4,52,106,
  198,119,120,177,192,205,38,12,88,158,223,99,139,157,17,123,41,195,230,227,69,
  210,234,189,97,157,43,169,86,52,137,188,150,224,72,37,216,228,44,121,130,124,
  248,220,1,167,159,235,64,90,90,195,49,99,79,67,126,247,250,210,50,176,228,209,
  50,111,78,221,89,98,249,144,208,9,228,178,244,33,138,38,18,163,35,190,43,146,
  204,136,87,12,113,29,152,184,93,132,199,165,99,131,194,0,229,159,67,232,71,
  103,20,106,94,89,244,70,124,81,173,223,193,170,67,20,77,164,78,66,197,70,32,
  92,192,184,141,102,195,160,9,48,250,28,181,186,58,188,201,125,248,243,7,188,
  119,19,169,211,231,31,82,218,131,22,46,75,158,95,163,215,224,214,24,50,148,
  127,115,10,144,20,11,9,58,68,71,72,70,131,28,73,45,20,140,66,164,55,80,35,175,
  188,35,20,138,80,65,160,81,59,247,204,120,210,49,155,73,10,65,209,17,52,196,
  39,146,130,15,192,150,128,4,71,228,99,50,20,174,219,145,6,56,17,137,180,16,
  176,91,46,175,29,94,228,183,14,123,19,219,165,211,81,241,210,234,101,193,46,
  234,226,48,102,8,111,225,169,193,156,105,138,102,108,148,246,182,99,114,131,
  80,35,58,32,201,105,15,233,112,38,143,9,172,73,146,201,146,139,51,107,177,178,
  75,64,16,84,198,52,105,151,12,68,191,241,52,204,138,156,79,183,13,193,141,100,
  181,133,26,180,195,242,90,80,183,169,39,39,43,16,193,19,69,99,64,10,238,34,
  166,195,211,147,36,35,254,116,183,244,114,223,193,158,240,191,103,209,223,216,
  77,243,247,66,129,178,161,164,83,129,56,148,44,47,26,33,71,68,40,106,131,112,
  66,194,246,137,29,16,75,129,200,49,205,134,34,75,120,112,35,65,146,130,20,1,
  11,22,228,117,139,97,87,2,126,48,168,77,158,193,108,144,221,227,248,150,155,
  4,133,140,198,8,107,24,226,233,211,116,129,125,252,198,174,42,248,176,97,16,
  114,150,202,20,178,20,41,253,163,14,30,145,160,200,163,16,0,33,79,207,227,3,
  11,216,83,70,64,92,223,87,191,119,87,83,165,181,103,250,121,108,236,59,176,
  190,21,96,126,176,10,136,137,21,178,104,104,187,183,117,116,17,130,122,90,5,
  221,191,182,49,129,146,148,146,197,3,229,161,72,49,18,161,140,203,133,105,144,
  164,101,53,13,185,149,118,24,205,117,130,156,43,7,6,166,24,3,85,252,122,4,152,
  98,23,232,191,41,47,34,177,166,38,52,12,133,201,205,8,90,27,135,106,129,25,
  88,55,34,187,177,79,12,111,196,182,29,73,153,83,16,91,202,61,94,33,241,249,
  171,36,152,49,70,153,202,21,199,83,164,254,163,147,231,219,151,39,47,120,43,
  222,120,222,11,102,159,72,136,236,93,24,212,229,227,2,17,237,224,254,240,58,
  212,153,129,19,237,241,149,141,73,131,2,8,108,53,75,134,159,64,154,153,167,
  43,19,116,102,131,23,101,59,130,152,211,76,140,172,17,241,14,78,4,38,78,103,
  45,2,165,96,186,123,118,118,174,60,128,199,204,211,254,146,56,142,205,221,155,
  17,196,109,226,191,252,112,8,6,24,22,123,248,126,202,78,195,208,87,166,33,32,
  70,71,225,88,212,29,134,108,8,13,67,129,17,78,203,147,129,10,209,51,73,145,
  168,4,53,135,21,220,22,72,91,9,217,41,243,149,222,61,187,176,132,76,251,1,81,
  118,108,42,0,67,149,134,130,186,8,95,206,1,140,228,220,198,35,194,190,176,197,
  45,66,99,149,133,134,154,180,87,207,67,183,18,49,193,76,116,250,76,98,131,37,
  4,93,170,25,243,82,60,32,78,201,68,10,136,202,136,192,174,62,33,135,76,174,
  164,130,169,209,179,207,80,110,0,27,148,215,69,37,34,156,40,108,12,162,225,
  45,203,232,120,11,14,88,113,107,144,41,21,49,26,101,225,253,50,51,78,214,86,
  122,195,249,105,114,49,27,120,6,67,197,27,65,81,155,139,170,204,119,118,251,
  207,103,83,79,227,233,53,120,119,17,96,104,55,191,121,241,128,12,88,152,210,
  239,61,14,230,96,134,255,153,7,249,30,84,215,43,135,24,134,7,44,56,216,192,
  194,238,171,2,63,111,191,83,65,128,229,98,4,204,5,5,231,144,48,4,124,33,1,246,
  45,32,204,172,30,239,214,129,143,30,48,142,243,195,164,218,181,101,214,201,
  248,0,23,38,9,162,177,122,199,42,54,81,176,48,198,147,88,99,72,100,163,112,
  4,52,232,88,96,49,164,99,106,82,102,5,58,44,29,204,81,10,195,15,194,208,225,
  134,44,79,121,165,0,17,76,203,194,164,70,39,85,153,145,94,122,160,242,81,237,
  61,160,66,227,38,72,101,118,187,14,136,91,114,167,141,206,182,155,12,21,201,
  216,71,70,163,170,141,204,61,189,160,164,4,108,231,137,214,87,12,165,159,49,
  96,176,39,40,78,77,249,97,15,114,30,155,25,52,182,155,141,230,218,138,99,76,
  47,31,120,56,95,207,74,156,107,243,173,14,76,112,35,64,218,166,209,144,203,
  98,76,112,173,81,7,160,38,170,56,129,216,177,5,160,16,140,1,49,76,253,168,241,
  46,137,99,248,16,89,38,8,232,142,2,61,35,203,177,103,243,26,195,0,232,142,157,
  64,59,129,166,162,72,105,214,3,20,67,230,181,38,178,42,229,26,245,155,163,223,
  126,207,150,124,21,243,30,151,159,45,6,108,177,67,70,20,231,102,244,207,120,
  171,69,213,172,54,25,92,140,175,141,150,237,160,66,136,141,42,12,49,4,253,114,
  186,14,211,27,129,21,73,181,14,86,38,184,19,49,227,227,24,229,92,172,241,134,
  237,193,171,104,3,73,179,23,149,173,54,154,38,183,24,107,101,135,171,82,212,
  69,45,173,7,162,56,182,161,100,26,129,97,52,219,226,89,135,210,54,24,177,208,
  5,119,208,6,224,195,240,242,163,21,147,144,187,21,125,114,23,80,108,6,135,99,
  149,26,65,235,189,119,24,149,210,83,57,169,191,151,174,124,156,216,20,84,172,
  19,99,83,86,225,140,114,49,28,166,177,68,70,55,24,110,108,172,91,147,28,136,
  236,49,197,57,120,70,20,224,165,174,160,82,218,227,209,10,230,212,226,157,191,
  113,87,12,62,118,144,101,18,136,153,120,217,1,145,143,37,128,163,105,11,136,
  27,43,70,31,43,230,131,0,8,219,208,99,118,157,248,57,147,241,53,176,157,134,
  34,23,207,18,222,236,19,225,212,240,109,34,241,38,108,152,34,176,99,187,12,
  111,143,41,214,218,99,53,251,87,91,79,0,6,110,87,18,96,81,21,134,252,134,130,
  195,246,144,48,46,189,201,161,123,1,200,232,91,72,232,190,44,171,180,80,55,
  46,152,209,51,48,169,106,247,153,123,249,25,138,35,116,215,43,11,187,31,197,
  37,172,154,133,54,136,75,40,151,166,61,5,117,125,232,105,240,111,110,198,40,
  39,183,196,173,174,56,53,13,32,100,98,60,48,171,133,246,188,135,183,208,164,
  139,182,134,7,97,209,13,161,166,33,4,147,82,97,29,115,39,2,13,253,143,220,26,
  133,63,205,195,147,145,181,23,67,185,146,137,51,24,131,26,35,65,192,27,231,
  69,7,13,43,184,46,181,170,208,35,43,186,168,169,93,32,49,202,169,102,49,27,
  124,41,11,235,101,230,108,75,160,41,208,12,172,51,226,58,21,181,68,99,37,129,
  45,42,238,53,74,248,84,244,88,196,250,16,232,114,49,24,128,119,198,183,208,
  20,20,106,0,21,212,115,163,211,203,224,180,29,2,61,13,55,53,112,48,25,231,213,
  42,96,105,25,65,187,233,140,138,190,199,27,103,90,104,190,189,80,63,67,150,
  101,114,57,13,149,102,178,48,238,183,121,53,134,48,15,229,55,242,134,29,209,
  33,70,236,5,119,6,6,197,134,160,75,101,125,166,201,48,142,141,108,26,26,119,
  214,212,86,24,49,145,168,204,108,172,52,33,100,8,24,140,190,245,159,213,165,
  126,112,3,67,163,99,230,230,3,124,216,115,141,124,20,222,39,160,95,28,156,57,
  182,143,12,101,224,174,120,143,112,107,80,101,44,40,185,128,166,208,60,51,216,
  46,40,49,117,171,251,113,150,38,73,114,122,86,49,47,184,55,14,120,243,90,20,
  16,110,10,195,38,119,104,21,77,5,98,69,5,87,121,120,101,124,85,54,184,53,169,
  238,0,43,203,236,134,2,168,174,211,21,239,190,187,76,2,187,145,234,28,50,153,
  11,179,218,217,68,133,93,58,41,173,206,156,157,164,98,119,10,98,111,0,244,77,
  129,183,51,30,83,6,60,115,55,112,34,183,207,87,237,105,184,25,100,5,104,242,
  170,69,30,185,138,102,117,115,198,182,170,22,186,221,165,92,27,236,105,153,
  183,21,75,170,140,84,112,135,68,109,30,252,50,195,134,120,241,159,37,241,41,
  228,177,82,238,68,96,8,24
};

static char chrs_html_quot[]        = "quot";      /*<* "quot"     */
static char chrs_html_amp[]         = "amp";       /*<* "amp"      */
static char chrs_html_apos[]        = "apos";      /*<* "apos" (XML only) */
static char chrs_html_lt[]          = "lt";        /*<* "lt"       */
static char chrs_html_gt[]          = "gt";        /*<* "gt"       */
static char chrs_html_lc_auml[]     = "auml";      /*<* "auml"     */
static char chrs_html_lc_ouml[]     = "ouml";      /*<* "ouml"     */
static char chrs_html_lc_uuml[]     = "uuml";      /*<* "uuml"     */
static char chrs_html_uc_auml[]     = "Auml";      /*<* "Auml"     */
static char chrs_html_uc_ouml[]     = "Ouml";      /*<* "Ouml"     */
static char chrs_html_uc_uuml[]     = "Uuml";      /*<* "Uuml"     */
static char chrs_html_nbsp[]        = "nbsp";      /*<* "nbsp"     */
static char chrs_html_iexcl[]       = "iexcl";     /*<* "iexcl"    */
static char chrs_html_cent[]        = "cent";      /*<* "cent"     */
static char chrs_html_pound[]       = "pound";     /*<* "pound"    */
static char chrs_html_curren[]      = "curren";    /*<* "curren"   */
static char chrs_html_yen[]         = "yen";       /*<* "yen"      */
static char chrs_html_brvbar[]      = "brvbar";    /*<* "brvbar"   */
static char chrs_html_sect[]        = "sect";      /*<* "sect"     */
static char chrs_html_uml[]         = "uml";       /*<* "uml"      */
static char chrs_html_copy[]        = "copy";      /*<* "copy"     */
static char chrs_html_ordf[]        = "ordf";      /*<* "ordf"     */
static char chrs_html_laquo[]       = "laquo";     /*<* "laquo"    */
static char chrs_html_not[]         = "not";       /*<* "not"      */
static char chrs_html_shy[]         = "shy";       /*<* "shy"      */
static char chrs_html_reg[]         = "reg";       /*<* "reg"      */
static char chrs_html_macr[]        = "macr";      /*<* "macr"     */
static char chrs_html_deg[]         = "deg";       /*<* "deg"      */
static char chrs_html_plusmn[]      = "plusmn";    /*<* "plusmn"   */
static char chrs_html_sup2[]        = "sup2";      /*<* "sup2"     */
static char chrs_html_sup3[]        = "sup3";      /*<* "sup3"     */
static char chrs_html_acute[]       = "acute";     /*<* "acute"    */
static char chrs_html_micro[]       = "micro";     /*<* "micro"    */
static char chrs_html_para[]        = "para";      /*<* "para"     */
static char chrs_html_middot[]      = "middot";    /*<* "middot"   */
static char chrs_html_cedil[]       = "cedil";     /*<* "cedil"    */
static char chrs_html_sup1[]        = "sup1";      /*<* "sup1"     */
static char chrs_html_ordm[]        = "ordm";      /*<* "ordm"     */
static char chrs_html_raquo[]       = "raquo";     /*<* "raquo"    */
static char chrs_html_frac14[]      = "frac14";    /*<* "frac14"   */
static char chrs_html_frac12[]      = "frac12";    /*<* "frac12"   */
static char chrs_html_frac34[]      = "frac34";    /*<* "frac34"   */
static char chrs_html_iquest[]      = "iquest";    /*<* "iquest"   */
static char chrs_html_uc_agrave[]   = "Agrave";    /*<* "Agrave"   */
static char chrs_html_uc_aacute[]   = "Aacute";    /*<* "Aacute"   */
static char chrs_html_uc_acirc[]    = "Acirc";     /*<* "Acirc"    */
static char chrs_html_uc_atilde[]   = "Atilde";    /*<* "Atilde"   */
static char chrs_html_uc_aring[]    = "Aring";     /*<* "Aring"    */
static char chrs_html_uc_aelig[]    = "AElig";     /*<* "AElig"    */
static char chrs_html_uc_ccedil[]   = "Ccedil";    /*<* "Ccedil"   */
static char chrs_html_uc_egrave[]   = "Egrave";    /*<* "Egrave"   */
static char chrs_html_uc_eacute[]   = "Eacute";    /*<* "Eacute"   */
static char chrs_html_uc_ecirc[]    = "Ecirc";     /*<* "Ecirc"    */
static char chrs_html_uc_euml[]     = "Euml";      /*<* "Euml"     */
static char chrs_html_uc_igrave[]   = "Igrave";    /*<* "Igrave"   */
static char chrs_html_uc_iacute[]   = "Iacute";    /*<* "Iacute"   */
static char chrs_html_uc_icirc[]    = "Icirc";     /*<* "Icirc"    */
static char chrs_html_uc_iuml[]     = "Iuml";      /*<* "Iuml"     */
static char chrs_html_uc_eth[]      = "ETH";       /*<* "ETH"      */
static char chrs_html_uc_ntilde[]   = "Ntilde";    /*<* "Ntilde"   */
static char chrs_html_uc_ograve[]   = "Ograve";    /*<* "Ograve"   */
static char chrs_html_uc_oacute[]   = "Oacute";    /*<* "Oacute"   */
static char chrs_html_uc_ocirc[]    = "Ocirc";     /*<* "Ocirc"    */
static char chrs_html_uc_otilde[]   = "Otilde";    /*<* "Otilde"   */
static char chrs_html_times[]       = "times";     /*<* "times"    */
static char chrs_html_uc_oslash[]   = "Oslash";    /*<* "Oslash"   */
static char chrs_html_uc_ugrave[]   = "Ugrave";    /*<* "Ugrave"   */
static char chrs_html_uc_uacute[]   = "Uacute";    /*<* "Uacute"   */
static char chrs_html_uc_ucirc[]    = "Ucirc";     /*<* "Ucirc"    */
static char chrs_html_uc_yacute[]   = "Yacute";    /*<* "Yacute"   */
static char chrs_html_uc_thorn[]    = "THORN";     /*<* "THORN"    */
static char chrs_html_szlig[]       = "szlig";     /*<* "szlig"    */
static char chrs_html_lc_agrave[]   = "agrave";    /*<* "agrave"   */
static char chrs_html_lc_aacute[]   = "aacute";    /*<* "aacute"   */
static char chrs_html_lc_acirc[]    = "acirc";     /*<* "acirc"    */
static char chrs_html_lc_atilde[]   = "atilde";    /*<* "atilde"   */
static char chrs_html_lc_aring[]    = "aring";     /*<* "aring"    */
static char chrs_html_lc_aelig[]    = "aelig";     /*<* "aelig"    */
static char chrs_html_lc_ccedil[]   = "ccedil";    /*<* "ccedil"   */
static char chrs_html_lc_egrave[]   = "egrave";    /*<* "egrave"   */
static char chrs_html_lc_eacute[]   = "eacute";    /*<* "eacute"   */
static char chrs_html_lc_ecirc[]    = "ecirc";     /*<* "ecirc"    */
static char chrs_html_lc_euml[]     = "euml";      /*<* "euml"     */
static char chrs_html_lc_igrave[]   = "igrave";    /*<* "igrave"   */
static char chrs_html_lc_iacute[]   = "iacute";    /*<* "iacute"   */
static char chrs_html_lc_icirc[]    = "icirc";     /*<* "icirc"    */
static char chrs_html_lc_iuml[]     = "iuml";      /*<* "iuml"     */
static char chrs_html_lc_eth[]      = "eth";       /*<* "eth"      */
static char chrs_html_lc_ntilde[]   = "ntilde";    /*<* "ntilde"   */
static char chrs_html_lc_ograve[]   = "ograve";    /*<* "ograve"   */
static char chrs_html_lc_oacute[]   = "oacute";    /*<* "oacute"   */
static char chrs_html_lc_ocirc[]    = "ocirc";     /*<* "ocirc"    */
static char chrs_html_lc_otilde[]   = "otilde";    /*<* "otilde"   */
static char chrs_html_divide[]      = "divide";    /*<* "divide"   */
static char chrs_html_lc_oslash[]   = "oslash";    /*<* "oslash"   */
static char chrs_html_lc_ugrave[]   = "ugrave";    /*<* "ugrave"   */
static char chrs_html_lc_uacute[]   = "uacute";    /*<* "uacute"   */
static char chrs_html_lc_ucirc[]    = "ucirc";     /*<* "ucirc"    */
static char chrs_html_lc_yacute[]   = "yacute";    /*<* "yacute"   */
static char chrs_html_lc_thorn[]    = "thorn";     /*<* "thorn"    */
static char chrs_html_lc_yuml[]     = "yuml";      /*<* "yuml"     */
static char chrs_html_uc_alpha[]    = "Alpha";     /*<* "Alpha"    */
static char chrs_html_lc_alpha[]    = "alpha";     /*<* "alpha"    */
static char chrs_html_uc_beta[]     = "Beta";      /*<* "Beta"     */
static char chrs_html_lc_beta[]     = "beta";      /*<* "beta"     */
static char chrs_html_uc_gamma[]    = "Gamma";     /*<* "Gamma"    */
static char chrs_html_uc_delta[]    = "Delta";     /*<* "Delta"    */
static char chrs_html_uc_epsilon[]  = "Epsilon";   /*<* "Epsilon"  */
static char chrs_html_uc_zeta[]     = "Zeta";      /*<* "Zeta"     */
static char chrs_html_uc_eta[]      = "Eta";       /*<* "Eta"      */
static char chrs_html_uc_theta[]    = "Theta";     /*<* "Theta"    */
static char chrs_html_uc_iota[]     = "Iota";      /*<* "Iota"     */
static char chrs_html_uc_kappa[]    = "Kappa";     /*<* "Kappa"    */
static char chrs_html_uc_lambda[]   = "Lambda";    /*<* "Lambda"   */
static char chrs_html_uc_mu[]       = "Mu";        /*<* "Mu"       */
static char chrs_html_uc_nu[]       = "Nu";        /*<* "Nu"       */
static char chrs_html_uc_xi[]       = "Xi";        /*<* "Xi"       */
static char chrs_html_uc_omicron[]  = "Omicron";   /*<* "Omicron"  */
static char chrs_html_uc_pi[]       = "Pi";        /*<* "Pi"       */
static char chrs_html_uc_rho[]      = "Rho";       /*<* "Rho"      */
static char chrs_html_uc_sigma[]    = "Sigma";     /*<* "Sigma"    */
static char chrs_html_uc_tau[]      = "Tau";       /*<* "Tau"      */
static char chrs_html_uc_upsi[]     = "Upsi";      /*<* "Upsi"     */
static char chrs_html_uc_phi[]      = "Phi";       /*<* "Phi"      */
static char chrs_html_uc_chi[]      = "Chi";       /*<* "Chi"      */
static char chrs_html_uc_psi[]      = "Psi";       /*<* "Psi"      */
static char chrs_html_uc_omega[]    = "Omega";     /*<* "Omega"    */
static char chrs_html_lc_gamma[]    = "gamma";     /*<* "gamma"    */
static char chrs_html_lc_delta[]    = "delta";     /*<* "delta"    */
static char chrs_html_lc_epsi[]     = "epsi";      /*<* "epsi"     */
static char chrs_html_lc_zeta[]     = "zeta";      /*<* "zeta"     */
static char chrs_html_lc_eta[]      = "eta";       /*<* "eta"      */
static char chrs_html_lc_theta[]    = "theta";     /*<* "theta"    */
static char chrs_html_lc_iota[]     = "iota";      /*<* "iota"     */
static char chrs_html_lc_kappa[]    = "kappa";     /*<* "kappa"    */
static char chrs_html_lc_lambda[]   = "lambda";    /*<* "lambda"   */
static char chrs_html_lc_mu[]       = "mu";        /*<* "mu"       */
static char chrs_html_lc_nu[]       = "nu";        /*<* "nu"       */
static char chrs_html_lc_xi[]       = "xi";        /*<* "xi"       */
static char chrs_html_lc_omicron[]  = "omicron";   /*<* "omicron"  */
static char chrs_html_lc_pi[]       = "pi";        /*<* "pi"       */
static char chrs_html_lc_rho[]      = "rho";       /*<* "rho"      */
static char chrs_html_sigmaf[]      = "sigmaf";    /*<* "sigmaf"   */
static char chrs_html_lc_sigma[]    = "sigma";     /*<* "sigma"    */
static char chrs_html_lc_tau[]      = "tau";       /*<* "tau"      */
static char chrs_html_lc_upsi[]     = "upsi";      /*<* "upsi"     */
static char chrs_html_lc_phi[]      = "phi";       /*<* "phi"      */
static char chrs_html_lc_chi[]      = "chi";       /*<* "chi"      */
static char chrs_html_lc_psi[]      = "psi";       /*<* "psi"      */
static char chrs_html_lc_omega[]    = "omega";     /*<* "omega"    */
static char chrs_html_thetasym[]    = "thetasym";  /*<* "thetasym" */
static char chrs_html_upsih[]       = "upsih";     /*<* "upsih"    */
static char chrs_html_piv[]         = "piv";       /*<* "piv"      */
static char chrs_html_bull[]        = "bull";      /*<* "bull"     */
static char chrs_html_hellip[]      = "hellip";    /*<* "hellip"   */
static char chrs_html_lc_prime[]    = "prime";     /*<* "prime"    */
static char chrs_html_uc_prime[]    = "Prime";     /*<* "Prime"    */
static char chrs_html_oline[]       = "oline";     /*<* "oline"    */
static char chrs_html_frasl[]       = "frasl";     /*<* "frasl"    */
static char chrs_html_weierp[]      = "weierp";    /*<* "weierp"   */
static char chrs_html_image[]       = "image";     /*<* "image"    */
static char chrs_html_real[]        = "real";      /*<* "real"     */
static char chrs_html_trade[]       = "trade";     /*<* "trade"    */
static char chrs_html_alefsym[]     = "alefsym";   /*<* "alefsym"  */
static char chrs_html_lc_larr[]     = "larr";      /*<* "larr"     */
static char chrs_html_lc_uarr[]     = "uarr";      /*<* "uarr"     */
static char chrs_html_lc_rarr[]     = "rarr";      /*<* "rarr"     */
static char chrs_html_lc_darr[]     = "darr";      /*<* "darr"     */
static char chrs_html_lc_harr[]     = "harr";      /*<* "harr"     */
static char chrs_html_crarr[]       = "crarr";     /*<* "crarr"    */
static char chrs_html_uc_larr[]     = "lArr";      /*<* "lArr"     */
static char chrs_html_uc_uarr[]     = "uArr";      /*<* "uArr"     */
static char chrs_html_uc_rarr[]     = "rArr";      /*<* "rArr"     */
static char chrs_html_uc_darr[]     = "dArr";      /*<* "dArr"     */
static char chrs_html_uc_harr[]     = "hArr";      /*<* "hArr"     */
static char chrs_html_forall[]      = "forall";    /*<* "forall"   */
static char chrs_html_part[]        = "part";      /*<* "part"     */
static char chrs_html_exist[]       = "exist";     /*<* "exist"    */
static char chrs_html_empty[]       = "empty";     /*<* "empty"    */
static char chrs_html_nabla[]       = "nabla";     /*<* "nabla"    */
static char chrs_html_isin[]        = "isin";      /*<* "isin"     */
static char chrs_html_notin[]       = "notin";     /*<* "notin"    */
static char chrs_html_ni[]          = "ni";        /*<* "ni"       */
static char chrs_html_prod[]        = "prod";      /*<* "prod"     */
static char chrs_html_sum[]         = "sum";       /*<* "sum"      */
static char chrs_html_minus[]       = "minus";     /*<* "minus"    */
static char chrs_html_lowast[]      = "lowast";    /*<* "lowast"   */
static char chrs_html_radic[]       = "radic";     /*<* "radic"    */
static char chrs_html_prop[]        = "prop";      /*<* "prop"     */
static char chrs_html_infin[]       = "infin";     /*<* "infin"    */
static char chrs_html_ang[]         = "ang";       /*<* "ang"      */
static char chrs_html_and[]         = "and";       /*<* "and"      */
static char chrs_html_or[]          = "or";        /*<* "or"       */
static char chrs_html_cap[]         = "cap";       /*<* "cap"      */
static char chrs_html_cup[]         = "cup";       /*<* "cup"      */
static char chrs_html_int[]         = "int";       /*<* "int"      */
static char chrs_html_there4[]      = "there4";    /*<* "there4"   */
static char chrs_html_sim[]         = "sim";       /*<* "sim"      */
static char chrs_html_cong[]        = "cong";      /*<* "cong"     */
static char chrs_html_asymp[]       = "asymp";     /*<* "asymp"    */
static char chrs_html_ne[]          = "ne";        /*<* "ne"       */
static char chrs_html_equiv[]       = "equiv";     /*<* "equiv"    */
static char chrs_html_le[]          = "le";        /*<* "le"       */
static char chrs_html_ge[]          = "ge";        /*<* "ge"       */
static char chrs_html_sub[]         = "sub";       /*<* "sub"      */
static char chrs_html_sup[]         = "sup";       /*<* "sup"      */
static char chrs_html_nsub[]        = "nsub";      /*<* "nsub"     */
static char chrs_html_sube[]        = "sube";      /*<* "sube"     */
static char chrs_html_supe[]        = "supe";      /*<* "supe"     */
static char chrs_html_oplus[]       = "oplus";     /*<* "oplus"    */
static char chrs_html_otimes[]      = "otimes";    /*<* "otimes"   */
static char chrs_html_perp[]        = "perp";      /*<* "perp"     */
static char chrs_html_sdot[]        = "sdot";      /*<* "sdot"     */
static char chrs_html_lceil[]       = "lceil";     /*<* "lceil"    */
static char chrs_html_rceil[]       = "rceil";     /*<* "rceil"    */
static char chrs_html_lfloor[]      = "lfloor";    /*<* "lfloor"   */
static char chrs_html_rfloor[]      = "rfloor";    /*<* "rfloor"   */
static char chrs_html_lang[]        = "lang";      /*<* "lang"     */
static char chrs_html_rang[]        = "rang";      /*<* "rang"     */
static char chrs_html_loz[]         = "loz";       /*<* "loz"      */
static char chrs_html_spades[]      = "spades";    /*<* "spades"   */
static char chrs_html_clubs[]       = "clubs";     /*<* "clubs"    */
static char chrs_html_hearts[]      = "hearts";    /*<* "hearts"   */
static char chrs_html_diams[]       = "diams";     /*<* "diams"    */
static char chrs_html_fnof[]        = "fnof";      /*<* "fnof"     */
static char chrs_html_uc_oelig[]    = "OElig";     /*<* "OElig"    */
static char chrs_html_lc_oelig[]    = "oelig";     /*<* "oelig"    */
static char chrs_html_uc_scaron[]   = "Scaron";    /*<* "Scaron"   */
static char chrs_html_lc_scaron[]   = "scaron";    /*<* "scaron"   */
static char chrs_html_uc_yuml[]     = "Yuml";      /*<* "Yuml"     */
static char chrs_html_circ[]        = "circ";      /*<* "circ"     */
static char chrs_html_tilde[]       = "tilde";     /*<* "tilde"    */
static char chrs_html_ensp[]        = "ensp";      /*<* "ensp"     */
static char chrs_html_emsp[]        = "emsp";      /*<* "emsp"     */
static char chrs_html_thinsp[]      = "thinsp";    /*<* "thinsp"   */
static char chrs_html_zwnj[]        = "zwnj";      /*<* "zwnj"     */
static char chrs_html_zwj[]         = "zwj";       /*<* "zwj"      */
static char chrs_html_lrm[]         = "lrm";       /*<* "lrm"      */
static char chrs_html_rlm[]         = "rlm";       /*<* "rlm"      */
static char chrs_html_ndash[]       = "ndash";     /*<* "ndash"    */
static char chrs_html_mdash[]       = "mdash";     /*<* "mdash"    */
static char chrs_html_lsquo[]       = "lsquo";     /*<* "lsquo"    */
static char chrs_html_rsquo[]       = "rsquo";     /*<* "rsquo"    */
static char chrs_html_sbquo[]       = "sbquo";     /*<* "sbquo"    */
static char chrs_html_ldquo[]       = "ldquo";     /*<* "ldquo"    */
static char chrs_html_rdquo[]       = "rdquo";     /*<* "rdquo"    */
static char chrs_html_bdquo[]       = "bdquo";     /*<* "bdquo"    */
static char chrs_html_lc_dagger[]   = "dagger";    /*<* "dagger"   */
static char chrs_html_uc_dagger[]   = "Dagger";    /*<* "Dagger"   */
static char chrs_html_permil[]      = "permil";    /*<* "permil"   */
static char chrs_html_lsaquo[]      = "lsaquo";    /*<* "lsaquo"   */
static char chrs_html_rsaquo[]      = "rsaquo";    /*<* "rsaquo"   */
static char chrs_html_euro[]        = "euro";      /*<* "euro"     */

#ifdef XYZ1
struct dsd_char_sort {                      /* sorting of characters   */
   unsigned int imc_no;                     /* Unicode representation  */
   char *achc_char;                         /* character string        */
};
#endif

/** pairs of codepoints and HTML entity names, array sorted by codepoint */
static struct dsd_char_sort dsrs_sort_html_no[] = {
   { 0X22, chrs_html_quot },
   { 0X26, chrs_html_amp },
   { 0X3C, chrs_html_lt },
   { 0X3E, chrs_html_gt },
   { 0XA0, chrs_html_nbsp },
   { 0XA1, chrs_html_iexcl },
   { 0XA2, chrs_html_cent },
   { 0XA3, chrs_html_pound },
   { 0XA4, chrs_html_curren },
   { 0XA5, chrs_html_yen },
   { 0XA6, chrs_html_brvbar },
   { 0XA7, chrs_html_sect },
   { 0XA8, chrs_html_uml },
   { 0XA9, chrs_html_copy },
   { 0XAA, chrs_html_ordf },
   { 0XAB, chrs_html_laquo },
   { 0XAC, chrs_html_not },
   { 0XAD, chrs_html_shy },
   { 0XAE, chrs_html_reg },
   { 0XAF, chrs_html_macr },
   { 0XB0, chrs_html_deg },
   { 0XB1, chrs_html_plusmn },
   { 0XB2, chrs_html_sup2 },
   { 0XB3, chrs_html_sup3 },
   { 0XB4, chrs_html_acute },
   { 0XB5, chrs_html_micro },
   { 0XB6, chrs_html_para },
   { 0XB7, chrs_html_middot },
   { 0XB8, chrs_html_cedil },
   { 0XB9, chrs_html_sup1 },
   { 0XBA, chrs_html_ordm },
   { 0XBB, chrs_html_raquo },
   { 0XBC, chrs_html_frac14 },
   { 0XBD, chrs_html_frac12 },
   { 0XBE, chrs_html_frac34 },
   { 0XBF, chrs_html_iquest },
   { 0XC0, chrs_html_uc_agrave },
   { 0XC1, chrs_html_uc_aacute },
   { 0XC2, chrs_html_uc_acirc },
   { 0XC3, chrs_html_uc_atilde },
   { 0XC4, chrs_html_uc_auml },
   { 0XC5, chrs_html_uc_aring },
   { 0XC6, chrs_html_uc_aelig },
   { 0XC7, chrs_html_uc_ccedil },
   { 0XC8, chrs_html_uc_egrave },
   { 0XC9, chrs_html_uc_eacute },
   { 0XCA, chrs_html_uc_ecirc },
   { 0XCB, chrs_html_uc_euml },
   { 0XCC, chrs_html_uc_igrave },
   { 0XCD, chrs_html_uc_iacute },
   { 0XCE, chrs_html_uc_icirc },
   { 0XCF, chrs_html_uc_iuml },
   { 0XD0, chrs_html_uc_eth },
   { 0XD1, chrs_html_uc_ntilde },
   { 0XD2, chrs_html_uc_ograve },
   { 0XD3, chrs_html_uc_oacute },
   { 0XD4, chrs_html_uc_ocirc },
   { 0XD5, chrs_html_uc_otilde },
   { 0XD6, chrs_html_uc_ouml },
   { 0XD7, chrs_html_times },
   { 0XD8, chrs_html_uc_oslash },
   { 0XD9, chrs_html_uc_ugrave },
   { 0XDA, chrs_html_uc_uacute },
   { 0XDB, chrs_html_uc_ucirc },
   { 0XDC, chrs_html_uc_uuml },
   { 0XDD, chrs_html_uc_yacute },
   { 0XDE, chrs_html_uc_thorn },
   { 0XDF, chrs_html_szlig },
   { 0XE0, chrs_html_lc_agrave },
   { 0XE1, chrs_html_lc_aacute },
   { 0XE2, chrs_html_lc_acirc },
   { 0XE3, chrs_html_lc_atilde },
   { 0XE4, chrs_html_lc_auml },
   { 0XE5, chrs_html_lc_aring },
   { 0XE6, chrs_html_lc_aelig },
   { 0XE7, chrs_html_lc_ccedil },
   { 0XE8, chrs_html_lc_egrave },
   { 0XE9, chrs_html_lc_eacute },
   { 0XEA, chrs_html_lc_ecirc },
   { 0XEB, chrs_html_lc_euml },
   { 0XEC, chrs_html_lc_igrave },
   { 0XED, chrs_html_lc_iacute },
   { 0XEE, chrs_html_lc_icirc },
   { 0XEF, chrs_html_lc_iuml},
   { 0XF0, chrs_html_lc_eth },
   { 0XF1, chrs_html_lc_ntilde },
   { 0XF2, chrs_html_lc_ograve },
   { 0XF3, chrs_html_lc_oacute },
   { 0XF4, chrs_html_lc_ocirc },
   { 0XF5, chrs_html_lc_otilde },
   { 0XF6, chrs_html_lc_ouml },
   { 0XF7, chrs_html_divide },
   { 0XF8, chrs_html_lc_oslash },
   { 0XF9, chrs_html_lc_ugrave },
   { 0XFA, chrs_html_lc_uacute },
   { 0XFB, chrs_html_lc_ucirc },
   { 0XFC, chrs_html_lc_uuml },
   { 0XFD, chrs_html_lc_yacute },
   { 0XFE, chrs_html_lc_thorn },
   { 0XFF, chrs_html_lc_yuml },
   { 0X152, chrs_html_uc_oelig },
   { 0X153, chrs_html_lc_oelig },
   { 0X160, chrs_html_uc_scaron },
   { 0X161, chrs_html_lc_scaron },
   { 0X178, chrs_html_uc_yuml },
   { 0X192, chrs_html_fnof },
   { 0X2C6, chrs_html_circ },
   { 0X2DC, chrs_html_tilde },
   { 0X391, chrs_html_uc_alpha },
   { 0X392, chrs_html_uc_beta },
   { 0X393, chrs_html_uc_gamma },
   { 0X394, chrs_html_uc_delta },
   { 0X395, chrs_html_uc_epsilon },
   { 0X396, chrs_html_uc_zeta },
   { 0X397, chrs_html_uc_eta },
   { 0X398, chrs_html_uc_theta },
   { 0X399, chrs_html_uc_iota },
   { 0X39A, chrs_html_uc_kappa },
   { 0X39B, chrs_html_uc_lambda },
   { 0X39C, chrs_html_uc_mu },
   { 0X39D, chrs_html_uc_nu },
   { 0X39E, chrs_html_uc_xi },
   { 0X39F, chrs_html_uc_omicron },
   { 0X3A0, chrs_html_uc_pi },
   { 0X3A1, chrs_html_uc_rho },
   { 0X3A3, chrs_html_uc_sigma },
   { 0X3A4, chrs_html_uc_tau },
   { 0X3A5, chrs_html_uc_upsi },
   { 0X3A6, chrs_html_uc_phi },
   { 0X3A7, chrs_html_uc_chi },
   { 0X3A8, chrs_html_uc_psi },
   { 0X3A9, chrs_html_uc_omega },
   { 0X3B1, chrs_html_lc_alpha },
   { 0X3B2, chrs_html_lc_beta },
   { 0X3B3, chrs_html_lc_gamma },
   { 0X3B4, chrs_html_lc_delta },
   { 0X3B5, chrs_html_lc_epsi },
   { 0X3B6, chrs_html_lc_zeta },
   { 0X3B7, chrs_html_lc_eta },
   { 0X3B8, chrs_html_lc_theta },
   { 0X3B9, chrs_html_lc_iota },
   { 0X3BA, chrs_html_lc_kappa },
   { 0X3BB, chrs_html_lc_lambda },
   { 0X3BC, chrs_html_lc_mu },
   { 0X3BD, chrs_html_lc_nu },
   { 0X3BE, chrs_html_lc_xi },
   { 0X3BF, chrs_html_lc_omicron },
   { 0X3C0, chrs_html_lc_pi },
   { 0X3C1, chrs_html_lc_rho },
   { 0X3C2, chrs_html_sigmaf },
   { 0X3C3, chrs_html_lc_sigma },
   { 0X3C4, chrs_html_lc_tau },
   { 0X3C5, chrs_html_lc_upsi },
   { 0X3C6, chrs_html_lc_phi },
   { 0X3C7, chrs_html_lc_chi },
   { 0X3C8, chrs_html_lc_psi },
   { 0X3C9, chrs_html_lc_omega },
   { 0X3D1, chrs_html_thetasym },
   { 0X3D2, chrs_html_upsih },
   { 0X3D6, chrs_html_piv },
   { 0X2002, chrs_html_ensp },
   { 0X2003, chrs_html_emsp },
   { 0X2009, chrs_html_thinsp },
   { 0X200C, chrs_html_zwnj },
   { 0X200D, chrs_html_zwj },
   { 0X200E, chrs_html_lrm },
   { 0X200F, chrs_html_rlm },
   { 0X2013, chrs_html_ndash },
   { 0X2014, chrs_html_mdash },
   { 0X2018, chrs_html_lsquo },
   { 0X2019, chrs_html_rsquo },
   { 0X201A, chrs_html_sbquo },
   { 0X201C, chrs_html_ldquo },
   { 0X201D, chrs_html_rdquo },
   { 0X201E, chrs_html_bdquo },
   { 0X2020, chrs_html_lc_dagger },
   { 0X2021, chrs_html_uc_dagger },
   { 0X2022, chrs_html_bull },
   { 0X2026, chrs_html_hellip },
   { 0X2030, chrs_html_permil },
   { 0X2032, chrs_html_lc_prime },
   { 0X2033, chrs_html_uc_prime },
   { 0X2039, chrs_html_lsaquo },
   { 0X203A, chrs_html_rsaquo },
   { 0X203E, chrs_html_oline },
   { 0X2044, chrs_html_frasl },
   { 0X20AC, chrs_html_euro },
   { 0X2111, chrs_html_image },
   { 0X2118, chrs_html_weierp },
   { 0X211C, chrs_html_real },
   { 0X2122, chrs_html_trade },
   { 0X2135, chrs_html_alefsym },
   { 0X2190, chrs_html_lc_larr },
   { 0X2191, chrs_html_lc_uarr },
   { 0X2192, chrs_html_lc_rarr },
   { 0X2193, chrs_html_lc_darr },
   { 0X2194, chrs_html_lc_harr },
   { 0X21B5, chrs_html_crarr },
   { 0X21D0, chrs_html_uc_larr },
   { 0X21D1, chrs_html_uc_uarr },
   { 0X21D2, chrs_html_uc_rarr },
   { 0X21D3, chrs_html_uc_darr },
   { 0X21D4, chrs_html_uc_harr },
   { 0X2200, chrs_html_forall },
   { 0X2202, chrs_html_part },
   { 0X2203, chrs_html_exist },
   { 0X2205, chrs_html_empty },
   { 0X2207, chrs_html_nabla },
   { 0X2208, chrs_html_isin },
   { 0X2209, chrs_html_notin },
   { 0X220B, chrs_html_ni },
   { 0X220F, chrs_html_prod },
   { 0X2211, chrs_html_sum },
   { 0X2212, chrs_html_minus },
   { 0X2217, chrs_html_lowast },
   { 0X221A, chrs_html_radic },
   { 0X221D, chrs_html_prop },
   { 0X221E, chrs_html_infin },
   { 0X2220, chrs_html_ang },
   { 0X2227, chrs_html_and },
   { 0X2228, chrs_html_or },
   { 0X2229, chrs_html_cap },
   { 0X222A, chrs_html_cup },
   { 0X222B, chrs_html_int },
   { 0X2234, chrs_html_there4 },
   { 0X223C, chrs_html_sim },
   { 0X2245, chrs_html_cong },
   { 0X2248, chrs_html_asymp },
   { 0X2260, chrs_html_ne },
   { 0X2261, chrs_html_equiv },
   { 0X2264, chrs_html_le },
   { 0X2265, chrs_html_ge },
   { 0X2282, chrs_html_sub },
   { 0X2283, chrs_html_sup },
   { 0X2284, chrs_html_nsub },
   { 0X2286, chrs_html_sube },
   { 0X2287, chrs_html_supe },
   { 0X2295, chrs_html_oplus },
   { 0X2297, chrs_html_otimes },
   { 0X22A5, chrs_html_perp },
   { 0X22C5, chrs_html_sdot },
   { 0X2308, chrs_html_lceil },
   { 0X2309, chrs_html_rceil },
   { 0X230A, chrs_html_lfloor },
   { 0X230B, chrs_html_rfloor },
   { 0X2329, chrs_html_lang },
   { 0X232A, chrs_html_rang },
   { 0X25CA, chrs_html_loz },
   { 0X2660, chrs_html_spades },
   { 0X2663, chrs_html_clubs },
   { 0X2665, chrs_html_hearts },
   { 0X2666, chrs_html_diams }
};

/** pairs of codepoints and HTML entity names, array sorted by name (UC<lc) */
static struct dsd_char_sort dsrs_sort_html_alpha[] = {
   { 0XC6, chrs_html_uc_aelig },  //AElig
   { 0XC1, chrs_html_uc_aacute },
   { 0XC2, chrs_html_uc_acirc },
   { 0XC0, chrs_html_uc_agrave },
   { 0X391, chrs_html_uc_alpha },
   { 0XC5, chrs_html_uc_aring },
   { 0XC3, chrs_html_uc_atilde },
   { 0XC4, chrs_html_uc_auml },
   { 0X392, chrs_html_uc_beta },
   { 0XC7, chrs_html_uc_ccedil },
   { 0X3A7, chrs_html_uc_chi },
   { 0X2021, chrs_html_uc_dagger },
   { 0X394, chrs_html_uc_delta },
   { 0XD0, chrs_html_uc_eth },  //ETH
   { 0XC9, chrs_html_uc_eacute },
   { 0XCA, chrs_html_uc_ecirc },
   { 0XC8, chrs_html_uc_egrave },
   { 0X395, chrs_html_uc_epsilon },
   { 0X397, chrs_html_uc_eta },
   { 0XCB, chrs_html_uc_euml },
   { 0X393, chrs_html_uc_gamma },
   { 0XCD, chrs_html_uc_iacute },
   { 0XCE, chrs_html_uc_icirc },
   { 0XCC, chrs_html_uc_igrave },
   { 0X399, chrs_html_uc_iota },
   { 0XCF, chrs_html_uc_iuml },
   { 0X39A, chrs_html_uc_kappa },
   { 0X39B, chrs_html_uc_lambda },
   { 0X39C, chrs_html_uc_mu },
   { 0XD1, chrs_html_uc_ntilde },
   { 0X39D, chrs_html_uc_nu },
   { 0X152, chrs_html_uc_oelig },  //OElig
   { 0XD3, chrs_html_uc_oacute },
   { 0XD4, chrs_html_uc_ocirc },
   { 0XD2, chrs_html_uc_ograve },
   { 0X3A9, chrs_html_uc_omega },
   { 0X39F, chrs_html_uc_omicron },
   { 0XD8, chrs_html_uc_oslash },
   { 0XD5, chrs_html_uc_otilde },
   { 0XD6, chrs_html_uc_ouml },
   { 0X3A6, chrs_html_uc_phi },
   { 0X3A0, chrs_html_uc_pi },
   { 0X2033, chrs_html_uc_prime },
   { 0X3A8, chrs_html_uc_psi },
   { 0X3A1, chrs_html_uc_rho },
   { 0X160, chrs_html_uc_scaron },
   { 0X3A3, chrs_html_uc_sigma },
   { 0XDE, chrs_html_uc_thorn },  //THORN
   { 0X3A4, chrs_html_uc_tau },
   { 0X398, chrs_html_uc_theta },
   { 0XDA, chrs_html_uc_uacute },
   { 0XDB, chrs_html_uc_ucirc },
   { 0XD9, chrs_html_uc_ugrave },
   { 0X3A5, chrs_html_uc_upsi },
   { 0XDC, chrs_html_uc_uuml },
   { 0X39E, chrs_html_uc_xi },
   { 0XDD, chrs_html_uc_yacute },
   { 0X178, chrs_html_uc_yuml },
   { 0X396, chrs_html_uc_zeta },
   { 0XE1, chrs_html_lc_aacute },
   { 0XE2, chrs_html_lc_acirc },
   { 0XB4, chrs_html_acute },
   { 0XE6, chrs_html_lc_aelig },
   { 0XE0, chrs_html_lc_agrave },
   { 0X2135, chrs_html_alefsym },
   { 0X3B1, chrs_html_lc_alpha },
   { 0X26, chrs_html_amp },
   { 0X2227, chrs_html_and },
   { 0X2220, chrs_html_ang },
   { 0XE5, chrs_html_lc_aring },
   { 0X2248, chrs_html_asymp },
   { 0XE3, chrs_html_lc_atilde },
   { 0XE4, chrs_html_lc_auml },
   { 0X201E, chrs_html_bdquo },
   { 0X3B2, chrs_html_lc_beta },
   { 0XA6, chrs_html_brvbar },
   { 0X2022, chrs_html_bull },
   { 0X2229, chrs_html_cap },
   { 0XE7, chrs_html_lc_ccedil },
   { 0XB8, chrs_html_cedil },
   { 0XA2, chrs_html_cent },
   { 0X3C7, chrs_html_lc_chi },
   { 0X2C6, chrs_html_circ },
   { 0X2663, chrs_html_clubs },
   { 0X2245, chrs_html_cong },
   { 0XA9, chrs_html_copy },
   { 0X21B5, chrs_html_crarr },
   { 0X222A, chrs_html_cup },
   { 0XA4, chrs_html_curren },
   { 0X21D3, chrs_html_uc_darr },  //dArr
   { 0X2020, chrs_html_lc_dagger },
   { 0X2193, chrs_html_lc_darr },
   { 0XB0, chrs_html_deg },
   { 0X3B4, chrs_html_lc_delta },
   { 0X2666, chrs_html_diams },
   { 0XF7, chrs_html_divide },
   { 0XE9, chrs_html_lc_eacute },
   { 0XEA, chrs_html_lc_ecirc },
   { 0XE8, chrs_html_lc_egrave },
   { 0X2205, chrs_html_empty },
   { 0X2003, chrs_html_emsp },
   { 0X2002, chrs_html_ensp },
   { 0X3B5, chrs_html_lc_epsi },
   { 0X2261, chrs_html_equiv },
   { 0X3B7, chrs_html_lc_eta },
   { 0XF0, chrs_html_lc_eth },
   { 0XEB, chrs_html_lc_euml },
   { 0X20AC, chrs_html_euro },
   { 0X2203, chrs_html_exist },
   { 0X192, chrs_html_fnof },
   { 0X2200, chrs_html_forall },
   { 0XBD, chrs_html_frac12 },
   { 0XBC, chrs_html_frac14 },
   { 0XBE, chrs_html_frac34 },
   { 0X2044, chrs_html_frasl },
   { 0X3B3, chrs_html_lc_gamma },
   { 0X2265, chrs_html_ge },
   { 0X3E, chrs_html_gt },
   { 0X21D4, chrs_html_uc_harr },  //hArr
   { 0X2194, chrs_html_lc_harr },
   { 0X2665, chrs_html_hearts },
   { 0X2026, chrs_html_hellip },
   { 0XED, chrs_html_lc_iacute },
   { 0XEE, chrs_html_lc_icirc },
   { 0XA1, chrs_html_iexcl },
   { 0XEC, chrs_html_lc_igrave },
   { 0X2111, chrs_html_image },
   { 0X221E, chrs_html_infin },
   { 0X222B, chrs_html_int },
   { 0X3B9, chrs_html_lc_iota },
   { 0XBF, chrs_html_iquest },
   { 0X2208, chrs_html_isin },
   { 0XEF, chrs_html_lc_iuml},
   { 0X3BA, chrs_html_lc_kappa },
   { 0X21D0, chrs_html_uc_larr },  // lArr
   { 0X3BB, chrs_html_lc_lambda },
   { 0X2329, chrs_html_lang },
   { 0XAB, chrs_html_laquo },
   { 0X2190, chrs_html_lc_larr },
   { 0X2308, chrs_html_lceil },
   { 0X201C, chrs_html_ldquo },
   { 0X2264, chrs_html_le },
   { 0X230A, chrs_html_lfloor },
   { 0X2217, chrs_html_lowast },
   { 0X25CA, chrs_html_loz },
   { 0X200E, chrs_html_lrm },
   { 0X2039, chrs_html_lsaquo },
   { 0X2018, chrs_html_lsquo },
   { 0X3C, chrs_html_lt },
   { 0XAF, chrs_html_macr },
   { 0X2014, chrs_html_mdash },
   { 0XB5, chrs_html_micro },
   { 0XB7, chrs_html_middot },
   { 0X2212, chrs_html_minus },
   { 0X3BC, chrs_html_lc_mu },
   { 0X2207, chrs_html_nabla },
   { 0XA0, chrs_html_nbsp },
   { 0X2013, chrs_html_ndash },
   { 0X2260, chrs_html_ne },
   { 0X220B, chrs_html_ni },
   { 0XAC, chrs_html_not },
   { 0X2209, chrs_html_notin },
   { 0X2284, chrs_html_nsub },
   { 0XF1, chrs_html_lc_ntilde },
   { 0X3BD, chrs_html_lc_nu },
   { 0XF3, chrs_html_lc_oacute },
   { 0XF4, chrs_html_lc_ocirc },
   { 0X153, chrs_html_lc_oelig },
   { 0XF2, chrs_html_lc_ograve },
   { 0X203E, chrs_html_oline },
   { 0X3C9, chrs_html_lc_omega },
   { 0X3BF, chrs_html_lc_omicron },
   { 0X2295, chrs_html_oplus },
   { 0X2228, chrs_html_or },
   { 0XAA, chrs_html_ordf },
   { 0XBA, chrs_html_ordm },
   { 0XF8, chrs_html_lc_oslash },
   { 0XF5, chrs_html_lc_otilde },
   { 0X2297, chrs_html_otimes },
   { 0XF6, chrs_html_lc_ouml },
   { 0XB6, chrs_html_para },
   { 0X2202, chrs_html_part },
   { 0X2030, chrs_html_permil },
   { 0X22A5, chrs_html_perp },
   { 0X3C6, chrs_html_lc_phi },
   { 0X3C0, chrs_html_lc_pi },
   { 0X3D6, chrs_html_piv },
   { 0XB1, chrs_html_plusmn },
   { 0XA3, chrs_html_pound },
   { 0X2032, chrs_html_lc_prime },
   { 0X220F, chrs_html_prod },
   { 0X221D, chrs_html_prop },
   { 0X3C8, chrs_html_lc_psi },
   { 0X22, chrs_html_quot },
   { 0X21D2, chrs_html_uc_rarr },  //rArr
   { 0X221A, chrs_html_radic },
   { 0X232A, chrs_html_rang },
   { 0XBB, chrs_html_raquo },
   { 0X2192, chrs_html_lc_rarr },
   { 0X2309, chrs_html_rceil },
   { 0X201D, chrs_html_rdquo },
   { 0X211C, chrs_html_real },
   { 0XAE, chrs_html_reg },
   { 0X230B, chrs_html_rfloor },
   { 0X3C1, chrs_html_lc_rho },
   { 0X200F, chrs_html_rlm },
   { 0X203A, chrs_html_rsaquo },
   { 0X2019, chrs_html_rsquo },
   { 0X201A, chrs_html_sbquo },
   { 0X161, chrs_html_lc_scaron },
   { 0X22C5, chrs_html_sdot },
   { 0XA7, chrs_html_sect },
   { 0XAD, chrs_html_shy },
   { 0X3C3, chrs_html_lc_sigma },
   { 0X3C2, chrs_html_sigmaf },
   { 0X223C, chrs_html_sim },
   { 0X2660, chrs_html_spades },
   { 0X2282, chrs_html_sub },
   { 0X2286, chrs_html_sube },
   { 0X2211, chrs_html_sum },
   { 0X2283, chrs_html_sup },
   { 0XB9, chrs_html_sup1 },
   { 0XB2, chrs_html_sup2 },
   { 0XB3, chrs_html_sup3 },
   { 0X2287, chrs_html_supe },
   { 0XDF, chrs_html_szlig },
   { 0X3C4, chrs_html_lc_tau },
   { 0X2234, chrs_html_there4 },
   { 0X3B8, chrs_html_lc_theta },
   { 0X3D1, chrs_html_thetasym },
   { 0X2009, chrs_html_thinsp },
   { 0XFE, chrs_html_lc_thorn },
   { 0X2DC, chrs_html_tilde },
   { 0XD7, chrs_html_times },
   { 0X2122, chrs_html_trade },
   { 0X21D1, chrs_html_uc_uarr },  //uArr
   { 0XFA, chrs_html_lc_uacute },
   { 0X2191, chrs_html_lc_uarr },
   { 0XFB, chrs_html_lc_ucirc },
   { 0XF9, chrs_html_lc_ugrave },
   { 0XA8, chrs_html_uml },
   { 0X3C5, chrs_html_lc_upsi },
   { 0X3D2, chrs_html_upsih },
   { 0XFC, chrs_html_lc_uuml },
   { 0X2118, chrs_html_weierp },
   { 0X3BE, chrs_html_lc_xi },
   { 0XFD, chrs_html_lc_yacute },
   { 0XA5, chrs_html_yen },
   { 0XFF, chrs_html_lc_yuml },
   { 0X3B6, chrs_html_lc_zeta },
   { 0X200D, chrs_html_zwj },
   { 0X200C, chrs_html_zwnj }
};

/** table of hexadecimal-digit characters                              */
static const char chrstrans[]
     = { '0', '1', '2', '3', '4', '5', '6', '7',
         '8', '9', 'A', 'B', 'C', 'D', 'E', 'F' };
static const char chrstrans_lc[]
     = { '0', '1', '2', '3', '4', '5', '6', '7',
         '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' };

#ifdef HL_DEBUG_VA_ARG
/** printing some data for debugging the vararg library                */
void* m_va_arg_deb_out(const char* strp_typename, int inp_typesize) {
  int inl0;
  fprintf(stderr,"va_arg_debug(<list>,%s) =",strp_typename);
  for (inl0=0; inl0<inp_typesize; inl0++)
    fprintf(stderr,"%3.2X",byr_va_arg_deb_buf[inl0]);
  putc('\n',stderr);
  return (void*)byr_va_arg_deb_buf;
}
#endif

/**
* get the name of a character-encoding enum-value. Useful for debugging.
*  @param iep_cs the charset (or encoding)
*  @return the name, as defined in hob-xslunic1.h, in '\0'-terminated ascii
*/
extern PTYPE const char * m_get_name_chs( enum ied_charset iep_cs ) {
   switch (iep_cs) {
     case ied_chs_invalid:                  /* parameter is invalid    */
       return "ied_chs_invalid";
     case ied_chs_ascii_850:                /* ASCII 850               */
       return "ied_chs_ascii_850";
     case ied_chs_ansi_819:                 /* ANSI 819 (ISO 8859-1)   */
       return "ied_chs_ansi_819";
     case ied_chs_utf_8:                    /* Unicode UTF-8           */
       return "ied_chs_utf_8";
     case ied_chs_utf_16:                   /* Unicode UTF-16 = WCHAR  */
       return "ied_chs_utf_16";
     case ied_chs_be_utf_16:                /* Unicode UTF-16 big endian */
       return "ied_chs_be_utf_16";
     case ied_chs_le_utf_16:                /* Unicode UTF-16 little endian */
       return "ied_chs_le_utf_16";
     case ied_chs_utf_32:                   /* Unicode UTF-32          */
       return "ied_chs_utf_32";
     case ied_chs_be_utf_32:                /* Unicode UTF-32 big endian */
       return "ied_chs_be_utf_32";
     case ied_chs_le_utf_32:                /* Unicode UTF-32 little endian */
       return "ied_chs_le_utf_32";
     case ied_chs_html_1:                   /* HTML character set      */
       return "ied_chs_html_1";
     case ied_chs_uri_1:                    /* URI (percent-escaped)   */
       return "ied_chs_uri_1";
     case ied_chs_idna_1:                   /* IDNA RFC 3492 etc; Punycode */
       return "ied_chs_idna_1";
     case ied_chs_oem_437:                  /* DOS-Codepage 437        */
       return "ied_chs_oem_437";
     case ied_chs_wcp_874:                  /* Windows-Codepage  874   */
       return "ied_chs_wcp_874";
     case ied_chs_wcp_1250:                 /* Windows-Codepage 1250   */
       return "ied_chs_wcp_1250";
     case ied_chs_wcp_1251:                 /* Windows-Codepage 1251   */
       return "ied_chs_wcp_1251";
     case ied_chs_wcp_1252:                 /* Windows-Codepage 1252   */
       return "ied_chs_wcp_1252";
     case ied_chs_wcp_1253:                 /* Windows-Codepage 1253   */
       return "ied_chs_wcp_1253";
     case ied_chs_wcp_1254:                 /* Windows-Codepage 1254   */
       return "ied_chs_wcp_1254";
     case ied_chs_wcp_1255:                 /* Windows-Codepage 1255   */
       return "ied_chs_wcp_1255";
     case ied_chs_wcp_1256:                 /* Windows-Codepage 1256   */
       return "ied_chs_wcp_1256";
     case ied_chs_wcp_1257:                 /* Windows-Codepage 1257   */
       return "ied_chs_wcp_1257";
     case ied_chs_wcp_1258:                 /* Windows-Codepage 1258   */
       return "ied_chs_wcp_1258";
     case ied_chs_wcp_932:                  /* Windows-Codepage 932 (MBCS) */
       return "ied_chs_wcp_932";
     case ied_chs_wcp_936:                  /* Windows-Codepage 936 (MBCS) */
       return "ied_chs_wcp_936";
     case ied_chs_wcp_949:                  /* Windows-Codepage 949 (MBCS) */
       return "ied_chs_wcp_949";
     case ied_chs_wcp_950:                  /* Windows-Codepage 950 (MBCS) */
       return "ied_chs_wcp_950";
     case ied_chs_iso8859_2:                /* ISO 8859-2 (Latin 2)    */
       return "ied_chs_iso8859_2";
     case ied_chs_iso8859_3:                /* ISO 8859-3 (Latin 3)    */
       return "ied_chs_iso8859_3";
     case ied_chs_iso8859_4:                /* ISO 8859-4 (Latin 4)    */
       return "ied_chs_iso8859_4";
     case ied_chs_iso8859_5:                /* ISO 8859-5              */
       return "ied_chs_iso8859_5";
     case ied_chs_iso8859_6:                /* ISO 8859-6              */
       return "ied_chs_iso8859_6";
     case ied_chs_iso8859_7:                /* ISO 8859-7              */
       return "ied_chs_iso8859_7";
     case ied_chs_iso8859_8:                /* ISO 8859-8              */
       return "ied_chs_iso8859_8";
     case ied_chs_iso8859_9:                /* ISO 8859-9 (Latin 5)    */
       return "ied_chs_iso8859_9";
     case ied_chs_iso8859_10:               /* ISO 8859-10 (Latin 6)   */
       return "ied_chs_iso8859_10";
     case ied_chs_iso8859_11:               /* ISO 8859-11             */
       return "ied_chs_iso8859_11";
     case ied_chs_iso8859_13:               /* ISO 8859-13 (Latin 7)   */
       return "ied_chs_iso8859_13";
     case ied_chs_iso8859_14:               /* ISO 8859-14 (Latin 8)   */
       return "ied_chs_iso8859_14";
     case ied_chs_iso8859_15:               /* ISO 8859-15 (Latin 9)   */
       return "ied_chs_iso8859_15";
     case ied_chs_iso8859_16:               /* ISO 8859-16 (Latin 10)  */
       return "ied_chs_iso8859_16";
     case ied_chs_xml_utf_8:                /* XML Unicode UTF-8       */
       return "ied_chs_xml_utf_8";
     case ied_chs_xml_wcp_1252:             /* XML Windows-Codepage 1252 */
       return "ied_chs_xml_wcp_1252";
     case ied_chs_xml_utf_16:               /* XML Unicode UTF-16      */
       return "ied_chs_xml_utf_16";
     case ied_chs_ldap_escaped_utf_8:       /* LDAP UTF-8 escaped      */
       return "ied_chs_ldap_escaped_utf_8";
     case ied_chs_hsf_1:                    /* HOB special file system */
       return "ied_chs_hsf_1";
   }
   return "-undef-";
} /* end m_get_name_chs()                                              */

/**
* return element size of an encoding
*  @param iep_cs the encoding
*  @return the size in bytes, that is used by other functions as unit for
*          counting size of strings encoded in iep_cs. 1 for invalid values.
*/
extern PTYPE int m_cs_elem_size( enum ied_charset iep_cs ) {
   switch (iep_cs) {
     CASE_IED_CHS_U16_ALLENDIAN
     case ied_chs_xml_utf_16:
       return sizeof(HL_WCHAR);
     CASE_IED_CHS_U32_ALLENDIAN
       return sizeof(unsigned int);
     default:
       return 1;
   }
}

/*
* methods with UTF-8 input return a boolean value,
* this boolean value will be FALSE if an invalid sequence
* of UTF-8 bytes was entered as input.
*/

/**
* method to return the UTF-8 values of a Unicode-String
*  @param achp_target pointer to output buffer
*  @param inp_max_len_target length of output buffer
*  @param awcp_source input string. May be zero-terminated to stop processing
*                     before the end of output-buffer. Contains 16-bit
*                     characters, but UTF16-surrogates are not supported.
*  @return number of bytes written
*/
extern PTYPE int m_u8l_from_u16z( char *achp_target, int inp_max_len_target,
                                  const HL_WCHAR *awcp_source ) {
   char       *achl_cur;                    /* current position        */
   char       *achl_end;                    /* maximum output position */
   char       *achl_val;                    /* position valid          */

   achl_cur = achp_target;                  /* start here              */
   achl_end = achp_target + inp_max_len_target;  /* maximum output     */
   achl_val = achp_target;                  /* set first valid output  */
   while (achl_cur < achl_end && *awcp_source) {
     if (*awcp_source < 0X80) {
       *achl_cur++ =(char) *awcp_source;
     } else if (*awcp_source < 0X0800) {
       *achl_cur++ = 0XC0 | (*awcp_source >> 6);
       if (achl_cur >= achl_end) break;     /* at maximum output       */
       *achl_cur++ = 0X80 | (*awcp_source & 0X3F);
     } else {
       *achl_cur++ = 0XE0 | (*awcp_source >> 12);
       if (achl_cur >= achl_end) break;     /* at maximum output       */
       *achl_cur++ = 0X80 | ((*awcp_source >> 6) & 0X3F);
       if (achl_cur >= achl_end) break;     /* at maximum output       */
       *achl_cur++ = 0X80 | (*awcp_source & 0X3F);
     }
     awcp_source++;                         /* next character          */
     achl_val = achl_cur;                   /* set valid output        */
   }
   return (achl_val - achp_target);
} /* end m_u8l_from_u16z()                                             */

/**
* method to return the UTF-8 values of a Unicode-String
*  @param achp_target pointer to output buffer
*  @param inp_max_len_target length of output buffer
*  @param awcp_source input string. Contains 16-bit characters, but
*                     UTF16-surrogates are not supported.
*  @param inp_len_source number of characters to convert (unless output space
*                                                         is exhausted earlier)
*  @return number of bytes written
*/
extern PTYPE int m_u8l_from_u16l( char *achp_target, int inp_max_len_target,
                                  const HL_WCHAR *awcp_source, int inp_len_source ) {
   char       *achl_cur;                    /* current position        */
   char       *achl_end;                    /* maximum output position */
   char       *achl_val;                    /* position valid          */
   const HL_WCHAR *awcl_source_end;         /* end of source           */

   awcl_source_end = awcp_source + inp_len_source;  /* end of source   */
   achl_cur = achp_target;                  /* start here              */
   achl_end = achp_target + inp_max_len_target;  /* maximum output     */
   achl_val = achp_target;                  /* set first valid output  */
   while ( achl_cur < achl_end && (awcp_source < awcl_source_end)) {  /* still characters to convert */
     if (*awcp_source < 0X80) {
       *achl_cur++ = *awcp_source;
     } else if (*awcp_source < 0X0800) {
       *achl_cur++ = 0XC0 | (*awcp_source >> 6);
       if (achl_cur >= achl_end) break;     /* at maximum output       */
       *achl_cur++ = ( 0X80 | (*awcp_source & 0X3F));
     } else {
       *achl_cur++ = 0XE0 | (*awcp_source >> 12);
       if (achl_cur >= achl_end) break;     /* at maximum output       */
       *achl_cur++ = (0X80 | ((*awcp_source >> 6) & 0X3F));
       if (achl_cur >= achl_end) break;     /* at maximum output       */
       *achl_cur++ = ( 0X80 | (*awcp_source & 0X3F));
     }
     awcp_source++;                         /* next character          */
     achl_val = achl_cur;                   /* set valid output        */
   }
   return (achl_val - achp_target);
} /* end m_u8l_from_u16l()                                             */

/* macro for m_u8l_from_u32z and m_u8l_from_u32l                     { */
/* } end macro for m_u8l_from_u32z and m_u8l_from_u32l                 */

/**
* method to return the UTF-8 values of a UTF 32 Unicode-String
*  @param achp_target pointer to output buffer
*  @param inp_max_len_target length of output buffer
*  @param aimp_source input string
*  @param aimp_source input string. May be zero-terminated to stop processing
*                     before the end of output-buffer. Unicode codepoints.
*  @return  number of bytes written
*/
extern PTYPE int m_u8l_from_u32z( char *achp_target, int inp_max_len_target,
                                  const int *aimp_source ) {
   /* extern, but does not appear in hob-xslunic1.h  WS 20141017       */
   char       *achl_cur;                    /* current position        */
   char       *achl_end;                    /* maximum output position */
   char       *achl_val;                    /* position valid          */

   achl_cur = achp_target;                  /* start here              */
   achl_end = achp_target + inp_max_len_target;  /* maximum output     */
   achl_val = achp_target;                  /* set first valid output  */
    while (achl_cur < achl_end && *aimp_source) {
     if (*aimp_source < 0X80) {
       *achl_cur++ = *aimp_source;
     } else if (*aimp_source < 0X0800) {
       *achl_cur++ = 0XC0 | (*aimp_source >> 6);
       if (achl_cur >= achl_end) break;     /* at maximum output       */
       *achl_cur++ = 0X80 | (*aimp_source & 0X3F);
     } else if (*aimp_source < 0X010000) {
       *achl_cur++ = 0XE0 | (*aimp_source >> 12);
       if (achl_cur >= achl_end) break;     /* at maximum output       */
       *achl_cur++ = 0X80 | ((*aimp_source >> 6) & 0X3F);
       if (achl_cur >= achl_end) break;     /* at maximum output       */
       *achl_cur++ = 0X80 | (*aimp_source & 0X3F);
     } else if (*aimp_source < 0X200000) {
       *achl_cur++ = 0XF0 | (*aimp_source >> 18);
       if (achl_cur >= achl_end) break;     /* at maximum output       */
       *achl_cur++ = 0X80 | ((*aimp_source >> 12) & 0X3F);
       if (achl_cur >= achl_end) break;     /* at maximum output       */
       *achl_cur++ = 0X80 | ((*aimp_source >> 6) & 0X3F);
       if (achl_cur >= achl_end) break;     /* at maximum output       */
       *achl_cur++ = 0X80 | (*aimp_source & 0X3F);
     } else {                               /* > 4 bytes not supported */
       *achl_cur++ = 0XE0 | (UTF16_REP_CHAR >> 12);
       if (achl_cur >= achl_end) break;     /* at maximum output       */
       *achl_cur++ = 0X80 | ((UTF16_REP_CHAR >> 6) & 0X3F);
       if (achl_cur >= achl_end) break;     /* at maximum output       */
       *achl_cur++ = 0X80 | (UTF16_REP_CHAR & 0X3F);
     }
     aimp_source++;                         /* next character          */
     achl_val = achl_cur;                   /* set valid output        */
   }
   return (achl_val - achp_target);
} /* end m_u8l_from_u32z()                                             */

/**
* method to return the UTF-8 values of a Unicode-String
*  @param achp_target pointer to output buffer
*  @param inp_max_len_target length of output buffer
*  @param aimp_source input string. Unicode codepoints.
*  @param inp_len_source number of characters to convert (unless output space
*                                                         is exhausted earlier)
*  @return  number of bytes written
*/
extern PTYPE int m_u8l_from_u32l( char *achp_target, int inp_max_len_target,
                                  const int *aimp_source, int inp_len_source ) {
   /* extern, but does not appear in hob-xslunic1.h  WS 20141017       */
   char       *achl_cur;                    /* current position        */
   char       *achl_end;                    /* maximum output position */
   char       *achl_val;                    /* position valid          */
   const int  *aiml_source_end;             /* end of source           */

   aiml_source_end = aimp_source + inp_len_source;  /* end of source   */
   achl_cur = achp_target;                  /* start here              */
   achl_end = achp_target + inp_max_len_target;  /* maximum output     */
   achl_val = achp_target;                  /* set first valid output  */
    while (achl_cur < achl_end && (aimp_source < aiml_source_end)) {
     if (*aimp_source < 0X80) {
       *achl_cur++ = *aimp_source;
     } else if (*aimp_source < 0X0800) {
       *achl_cur++ = 0XC0 | (*aimp_source >> 6);
       if (achl_cur >= achl_end) break;     /* at maximum output       */
       *achl_cur++ = 0X80 | (*aimp_source & 0X3F);
     } else if (*aimp_source < 0X010000) {
       *achl_cur++ = 0XE0 | (*aimp_source >> 12);
       if (achl_cur >= achl_end) break;     /* at maximum output       */
       *achl_cur++ = 0X80 | ((*aimp_source >> 6) & 0X3F);
       if (achl_cur >= achl_end) break;     /* at maximum output       */
       *achl_cur++ = 0X80 | (*aimp_source & 0X3F);
     } else if (*aimp_source < 0X200000) {
       *achl_cur++ = 0XF0 | (*aimp_source >> 18);
       if (achl_cur >= achl_end) break;     /* at maximum output       */
       *achl_cur++ = 0X80 | ((*aimp_source >> 12) & 0X3F);
       if (achl_cur >= achl_end) break;     /* at maximum output       */
       *achl_cur++ = 0X80 | ((*aimp_source >> 6) & 0X3F);
       if (achl_cur >= achl_end) break;     /* at maximum output       */
       *achl_cur++ = 0X80 | (*aimp_source & 0X3F);
     } else {                               /* > 4 bytes not supported */
       *achl_cur++ = 0XE0 | (UTF16_REP_CHAR >> 12);
       if (achl_cur >= achl_end) break;     /* at maximum output       */
       *achl_cur++ = 0X80 | ((UTF16_REP_CHAR >> 6) & 0X3F);
       if (achl_cur >= achl_end) break;     /* at maximum output       */
       *achl_cur++ = 0X80 | (UTF16_REP_CHAR & 0X3F);
     }
     aimp_source++;                         /* next character          */
     achl_val = achl_cur;                   /* set valid output        */
   }
   return (achl_val - achp_target);
} /* end m_u8l_from_u32l()                                             */

/**
* method to return the UTF-8 values of a Unicode-String. Note that
* handling of zeroes in the input is inconsistent (depends on iep_cs_source).
*  @param achp_target output buffer
*  @param inp_max_len_target length of output buffer, in bytes
*  @param ap_source input string
*  @param inp_chars_source length of input string, in units of 8, 16 or 32 bit
*                                                  (depending on iep_cs_source)
*  @param iep_cs_source encoding of the input. (UTF16 will not know surrogates)
*  @return -1 on error conditions, else number of bytes written
*/
extern PTYPE int m_u8l_from_ul( char *achp_target, int inp_max_len_target,
                                const void *ap_source, int inp_chars_source,
                                enum ied_charset iep_cs_source ) {
   /* extern, but does not appear in hob-xslunic1.h  WS 20141017       */
   int inl_src_bpc;                         /* bytes per character     */
   unsigned char *ucrl_[4];
   char *achl_cur;
   char *achl_end;
   unsigned int uml_sourcechar;
   int iml_charcount;
   switch (iep_cs_source) {
     case ied_chs_ascii_850:
       return m_u8l_from_a850l(achp_target, inp_max_len_target+1, (const char*)ap_source, inp_chars_source);
     case ied_chs_ansi_819:
       return m_u8l_from_a819l(achp_target, inp_max_len_target+1, (const char*)ap_source, inp_chars_source);
     case ied_chs_oem_437:
       return m_u8l_from_sbsl(achp_target, inp_max_len_target+1, (const char*)ap_source, inp_chars_source, usrg_tab_437_to_uni);
     case ied_chs_wcp_874:
       return m_u8l_from_sbsl(achp_target, inp_max_len_target+1, (const char*)ap_source, inp_chars_source, usrg_tab_874_to_uni);
     case ied_chs_wcp_1250:
       return m_u8l_from_sbsl(achp_target, inp_max_len_target+1, (const char*)ap_source, inp_chars_source, usrg_tab_1250_to_uni);
     case ied_chs_wcp_1251:
       return m_u8l_from_sbsl(achp_target, inp_max_len_target+1, (const char*)ap_source, inp_chars_source, usrg_tab_1251_to_uni);
     case ied_chs_wcp_1252:
       return m_u8l_from_sbsl(achp_target, inp_max_len_target+1, (const char*)ap_source, inp_chars_source, usrg_tab_1252_to_uni);
     case ied_chs_wcp_1253:
       return m_u8l_from_sbsl(achp_target, inp_max_len_target+1, (const char*)ap_source, inp_chars_source, usrg_tab_1253_to_uni);
     case ied_chs_wcp_1254:
       return m_u8l_from_sbsl(achp_target, inp_max_len_target+1, (const char*)ap_source, inp_chars_source, usrg_tab_1254_to_uni);
     case ied_chs_wcp_1255:
       return m_u8l_from_sbsl(achp_target, inp_max_len_target+1, (const char*)ap_source, inp_chars_source, usrg_tab_1255_to_uni);
     case ied_chs_wcp_1256:
       return m_u8l_from_sbsl(achp_target, inp_max_len_target+1, (const char*)ap_source, inp_chars_source, usrg_tab_1256_to_uni);
     case ied_chs_wcp_1257:
       return m_u8l_from_sbsl(achp_target, inp_max_len_target+1, (const char*)ap_source, inp_chars_source, usrg_tab_1257_to_uni);
     case ied_chs_wcp_1258:
       return m_u8l_from_sbsl(achp_target, inp_max_len_target+1, (const char*)ap_source, inp_chars_source, usrg_tab_1258_to_uni);
     case ied_chs_iso8859_2:
       return m_u8l_from_sbsl(achp_target, inp_max_len_target+1, (const char*)ap_source, inp_chars_source, usrg_tab_i02_to_uni);
     case ied_chs_iso8859_3:
       return m_u8l_from_sbsl(achp_target, inp_max_len_target+1, (const char*)ap_source, inp_chars_source, usrg_tab_i03_to_uni);
     case ied_chs_iso8859_4:
       return m_u8l_from_sbsl(achp_target, inp_max_len_target+1, (const char*)ap_source, inp_chars_source, usrg_tab_i04_to_uni);
     case ied_chs_iso8859_5:
       return m_u8l_from_sbsl(achp_target, inp_max_len_target+1, (const char*)ap_source, inp_chars_source, usrg_tab_i05_to_uni);
     case ied_chs_iso8859_6:
       return m_u8l_from_sbsl(achp_target, inp_max_len_target+1, (const char*)ap_source, inp_chars_source, usrg_tab_i06_to_uni);
     case ied_chs_iso8859_7:
       return m_u8l_from_sbsl(achp_target, inp_max_len_target+1, (const char*)ap_source, inp_chars_source, usrg_tab_i07_to_uni);
     case ied_chs_iso8859_8:
       return m_u8l_from_sbsl(achp_target, inp_max_len_target+1, (const char*)ap_source, inp_chars_source, usrg_tab_i08_to_uni);
     case ied_chs_iso8859_9:
       return m_u8l_from_sbsl(achp_target, inp_max_len_target+1, (const char*)ap_source, inp_chars_source, usrg_tab_i09_to_uni);
     case ied_chs_iso8859_10:
       return m_u8l_from_sbsl(achp_target, inp_max_len_target+1, (const char*)ap_source, inp_chars_source, usrg_tab_i10_to_uni);
     case ied_chs_iso8859_11:
       return m_u8l_from_sbsl(achp_target, inp_max_len_target+1, (const char*)ap_source, inp_chars_source, usrg_tab_i11_to_uni);
     case ied_chs_iso8859_13:
       return m_u8l_from_sbsl(achp_target, inp_max_len_target+1, (const char*)ap_source, inp_chars_source, usrg_tab_i13_to_uni);
     case ied_chs_iso8859_14:
       return m_u8l_from_sbsl(achp_target, inp_max_len_target+1, (const char*)ap_source, inp_chars_source, usrg_tab_i14_to_uni);
     case ied_chs_iso8859_15:
       return m_u8l_from_sbsl(achp_target, inp_max_len_target+1, (const char*)ap_source, inp_chars_source, usrg_tab_i15_to_uni);
     case ied_chs_iso8859_16:
       return m_u8l_from_sbsl(achp_target, inp_max_len_target+1, (const char*)ap_source, inp_chars_source, usrg_tab_i16_to_uni);
     CASE_IED_CHS_ALL_CJK
       return m_u8l_from_mbsl(achp_target, inp_max_len_target+1, (const char*)ap_source, inp_chars_source,
                              m_get_tab_mb_firstbytes(iep_cs_source), m_get_tab_mb_to_uni(iep_cs_source) );
     case ied_chs_utf_8:                  /* copy, but count the chars */
       ucrl_[0] = (unsigned char*)ap_source;
       achl_cur = achp_target;
       achl_end = achp_target + inp_max_len_target - 1;
       for (iml_charcount=0; iml_charcount<inp_chars_source; iml_charcount++ ) {
         switch (**ucrl_ & 0xC0) {
           case 0x80:
             return -1;
           case 0xC0:
             if (**ucrl_ & 0x20) {
               if (**ucrl_ & 0x10) {
                 if (**ucrl_ & 0x08) {
                   return -1;
                 } else {
                   if (achl_cur + 2 >= achl_end) return -1;
                   *(achl_cur++) = *(ucrl_[0]++);
                   if ((( *(achl_cur++) = *(ucrl_[0]++) )&0xC0)!=0x80) return -1;
                   if ((( *(achl_cur++) = *(ucrl_[0]++) )&0xC0)!=0x80) return -1;
                   if ((( *(achl_cur++) = *(ucrl_[0]++) )&0xC0)!=0x80) return -1;
                 }
               } else {
                 if (achl_cur + 1 >= achl_end) return -1;
                 *(achl_cur++) = *(ucrl_[0]++);
                 if ((( *(achl_cur++) = *(ucrl_[0]++) )&0xC0)!=0x80) return -1;
                 if ((( *(achl_cur++) = *(ucrl_[0]++) )&0xC0)!=0x80) return -1;
               }
             } else {
               if (achl_cur >= achl_end) return -1;
               *(achl_cur++) = *(ucrl_[0]++);
               if ((( *(achl_cur++) = *(ucrl_[0]++) )&0xC0)!=0x80) return -1;
             }
             break;
           default:
             if (achl_cur > achl_end) return -1;
             *(achl_cur++) = *(ucrl_[0]++);
             break;
         }
       }
       return achl_cur - achp_target;
     case ied_chs_utf_16:
       return m_u8l_from_u16l( achp_target, inp_max_len_target,
                               (const HL_WCHAR*)ap_source, inp_chars_source);
     case ied_chs_be_utf_16:
       if (m_suppress_endian_info_if_native(iep_cs_source) == ied_chs_utf_16) {
         return m_u8l_from_u16l( achp_target, inp_max_len_target,
                                 (const HL_WCHAR*)ap_source, inp_chars_source);
       } else {
         ucrl_[0] = (unsigned char*)ap_source + 1;
         ucrl_[1] = (unsigned char*)ap_source;
         inl_src_bpc = 2;
       }
       break;
     case ied_chs_le_utf_16:
       if (m_suppress_endian_info_if_native(iep_cs_source) == ied_chs_utf_16) {
         return m_u8l_from_u16l( achp_target, inp_max_len_target,
                                 (const HL_WCHAR*)ap_source, inp_chars_source);
       } else {
         ucrl_[0] = (unsigned char*)ap_source;
         ucrl_[1] = (unsigned char*)ap_source + 1;
         inl_src_bpc = 2;
       }
       break;
     case ied_chs_utf_32:
       return m_u8l_from_u32l( achp_target, inp_max_len_target,
                               (const int*)ap_source, inp_chars_source);
     case ied_chs_be_utf_32:
       if (m_suppress_endian_info_if_native(iep_cs_source) == ied_chs_utf_32) {
         return m_u8l_from_u32l( achp_target, inp_max_len_target,
                                 (const int*)ap_source, inp_chars_source);
       } else {
         ucrl_[0] = (unsigned char*)ap_source + 3;
         ucrl_[1] = (unsigned char*)ap_source + 2;
         ucrl_[2] = (unsigned char*)ap_source + 1;
         ucrl_[3] = (unsigned char*)ap_source;
         inl_src_bpc = 4;
       }
       break;
     case ied_chs_le_utf_32:
       if (m_suppress_endian_info_if_native(iep_cs_source) == ied_chs_utf_32) {
         return m_u8l_from_u32l( achp_target, inp_max_len_target,
                                 (const int*)ap_source, inp_chars_source);
       } else {
         ucrl_[0] = (unsigned char*)ap_source;
         ucrl_[1] = (unsigned char*)ap_source + 1;
         ucrl_[2] = (unsigned char*)ap_source + 2;
         ucrl_[3] = (unsigned char*)ap_source + 3;
         inl_src_bpc = 4;
       }
       break;
     default:
       return -1;
   }
   /* we have to read the single bytes (because of endian switch) here */
   achl_cur = achp_target;
   achl_end = achp_target + inp_max_len_target - 1;
   for (iml_charcount=0; iml_charcount<inp_chars_source; iml_charcount++ ) {
     uml_sourcechar = *ucrl_[0] | *ucrl_[1] << 8;
     ucrl_[0] += inl_src_bpc;
     ucrl_[1] += inl_src_bpc;
     if (inl_src_bpc==4) {
       uml_sourcechar |= *ucrl_[2] << 16 | *ucrl_[3] << 24;
       ucrl_[2] += 4;
       ucrl_[3] += 4;
     }
     if (uml_sourcechar & 0xFFFFFF80) {
       if (uml_sourcechar & 0xFFFFF800) {
         if (uml_sourcechar & 0xFFFF0000) {
           if (uml_sourcechar & 0xFFE00000)
             return -1;
           if (achl_cur + 2 >= achl_end) return -1;
           *(achl_cur++) = 0xF0 | uml_sourcechar>>18;
           *(achl_cur++) = 0x80 | ((uml_sourcechar>>12) & 0x3F);
         } else {
           if (achl_cur + 1 >= achl_end) return -1;
           *(achl_cur++) = 0xE0 | uml_sourcechar>>12;
         }
         *(achl_cur++) = 0x80 | ((uml_sourcechar>>6) & 0x3F);
       } else {
         if (achl_cur >= achl_end) return -1;
         *(achl_cur++) = 0xC0 | uml_sourcechar>>6;
       }
       *(achl_cur++) = 0x80 | (uml_sourcechar & 0x3F);
     } else {
       if (achl_cur > achl_end) return -1;
       *(achl_cur++) = uml_sourcechar;
     }
   }
   return achl_cur - achp_target;
} /* end m_u8l_from_ul()                                               */

/* macros used in m_tolowercase_inplace_u32c and m_touppercase_inplace_u32c so their code is easy to reuse */
#define CASECHG_C *aump_c
#define CASECHG_SETTO(INP_X) *aump_c = (unsigned int)(INP_X)
#define CASECHG_SHIFTBY(INP_D) *((signed int *)aump_c) += INP_D

/**
* replace a 32-bit char by its lowercase equivalent, if there is one, else
* leave it unchanged. Uses the "simple" way from the Unicode tables
* (not the "full" one which could also change the number of characters).
*  @param[in,out] aump_c the codepoint
*/
extern PTYPE void m_tolowercase_inplace_u32c(unsigned int *aump_c) {
   if(CASECHG_C < 0x1F38)
     if(CASECHG_C < 0x038E)
       if(CASECHG_C < 0x01AA)
         if(CASECHG_C < 0x0149)
           if(CASECHG_C < 0x00C0) {
             if(0x0041<=CASECHG_C && CASECHG_C < 0x005B)
               CASECHG_SHIFTBY(+32);
           } else /* CASECHG_C >= U+00C0 */
             if(CASECHG_C < 0x0100) {
               if(CASECHG_C < 0x00DF)
                 {if(CASECHG_C!=0x00D7) CASECHG_SHIFTBY(+32);}
             } else /* CASECHG_C >= U+0100 */
               if(CASECHG_C < 0x0138)
                 if(CASECHG_C == 0x0130) CASECHG_SETTO(0x0069);
                 else {if((CASECHG_C&1)==0) CASECHG_SHIFTBY(+1);}
               else /* CASECHG_C >= U+0138 */ {
                 if(CASECHG_C&1) CASECHG_SHIFTBY(+1);
         } else /* CASECHG_C >= U+0149 */
           if(CASECHG_C < 0x0182)
             if(CASECHG_C < 0x0179)
               if(CASECHG_C == 0x0178) CASECHG_SETTO(0x00FF);
               else {if((CASECHG_C&1)==0) CASECHG_SHIFTBY(+1);}
             else /* CASECHG_C >= U+0179 */
               if(CASECHG_C < 0x017E) {
                 if(CASECHG_C&1) CASECHG_SHIFTBY(+1);
               } else /* CASECHG_C >= U+017E */
                 {if(CASECHG_C == 0x0181) CASECHG_SETTO(0x0253);}
           else /* CASECHG_C >= U+0182 */
             if(CASECHG_C < 0x018C)
               if(CASECHG_C < 0x0189)
                 switch(CASECHG_C) {
                   case 0x0186: CASECHG_SETTO(0x0254); break;
                   case 0x0187: CASECHG_SETTO(0x0188); break;
                   case 0x0188: break;
                   default: if((CASECHG_C&1)==0) CASECHG_SHIFTBY(+1);
                 }
               else /* CASECHG_C >= U+0189 */
                 if(CASECHG_C == 0x018B) CASECHG_SETTO(0x018C); else CASECHG_SHIFTBY(+205);
             else /* CASECHG_C >= U+018C */
               if(CASECHG_C < 0x01A0)
                 switch(CASECHG_C) {
                   case 0x018E: CASECHG_SETTO(0x01DD); break;
                   case 0x018F: CASECHG_SETTO(0x0259); break;
                   case 0x0190: CASECHG_SETTO(0x025B); break;
                   case 0x0191: CASECHG_SETTO(0x0192); break;
                   case 0x0193: CASECHG_SETTO(0x0260); break;
                   case 0x0194: CASECHG_SETTO(0x0263); break;
                   case 0x0196: CASECHG_SETTO(0x0269); break;
                   case 0x0197: CASECHG_SETTO(0x0268); break;
                   case 0x0198: CASECHG_SETTO(0x0199); break;
                   case 0x019C: CASECHG_SETTO(0x026F); break;
                   case 0x019D: CASECHG_SETTO(0x0272); break;
                   case 0x019F: CASECHG_SETTO(0x0275); break;
                 }
               else /* CASECHG_C >= U+01A0 */
                 switch(CASECHG_C) {
                   case 0x01A6: CASECHG_SETTO(0x0280); break;
                   case 0x01A7: CASECHG_SETTO(0x01A8); break;
                   case 0x01A8: break;
                   case 0x01A9: CASECHG_SETTO(0x0283); break;
                   default: if((CASECHG_C&1)==0) CASECHG_SHIFTBY(+1);
                 }
       else /* CASECHG_C >= U+01AA */
         if(CASECHG_C < 0x01F2)
           if(CASECHG_C < 0x01B9)
             if(CASECHG_C < 0x01B1)
               switch(CASECHG_C) {
                 case 0x01AC: CASECHG_SETTO(0x01AD); break;
                 case 0x01AE: CASECHG_SETTO(0x0288); break;
                 case 0x01AF: CASECHG_SETTO(0x01B0); break;
               }
             else /* CASECHG_C >= U+01B1 */
               if(CASECHG_C < 0x01B3)
                 CASECHG_SHIFTBY(+217);
               else /* CASECHG_C >= U+01B3 */
                 switch(CASECHG_C) {
                   case 0x01B7: CASECHG_SETTO(0x0292); break;
                   case 0x01B8: CASECHG_SETTO(0x01B9); break;
                   default: if((CASECHG_C&1)==1) CASECHG_SHIFTBY(+1);
                 }
           else /* CASECHG_C >= U+01B9 */
             if(CASECHG_C < 0x01DD)
               if(CASECHG_C < 0x01CB)
                 switch(CASECHG_C) {
                   case 0x01BC: CASECHG_SETTO(0x01BD); break;
                   case 0x01C4: CASECHG_SETTO(0x01C6); break;
                   case 0x01C5: CASECHG_SETTO(0x01C6); break;
                   case 0x01C7: CASECHG_SETTO(0x01C9); break;
                   case 0x01C8: CASECHG_SETTO(0x01C9); break;
                   case 0x01CA: CASECHG_SETTO(0x01CC); break;
                 }
               else /* CASECHG_C >= U+01CB */ {
                 if(CASECHG_C&1) CASECHG_SHIFTBY(+1);
             } else /* CASECHG_C >= U+01DD */
               if(CASECHG_C < 0x01EF) {
                 if((CASECHG_C&1)==0) CASECHG_SHIFTBY(+1);
               } else /* CASECHG_C >= U+01EF */
                 {if(CASECHG_C == 0x01F1) CASECHG_SETTO(0x01F3);}
         else /* CASECHG_C >= U+01F2 */
           if(CASECHG_C < 0x0370)
             if(CASECHG_C < 0x0246)
               if(CASECHG_C < 0x0233)
                 switch(CASECHG_C) {
                   case 0x01F6: CASECHG_SETTO(0x0195); break;
                   case 0x01F7: CASECHG_SETTO(0x01BF); break;
                   case 0x0220: CASECHG_SETTO(0x019E); break;
                   default: if((CASECHG_C&1)==0) CASECHG_SHIFTBY(+1);
                 }
               else /* CASECHG_C >= U+0233 */
                 switch(CASECHG_C) {
                   case 0x023A: CASECHG_SETTO(0x2C65); break;
                   case 0x023B: CASECHG_SETTO(0x023C); break;
                   case 0x023D: CASECHG_SETTO(0x019A); break;
                   case 0x023E: CASECHG_SETTO(0x2C66); break;
                   case 0x0241: CASECHG_SETTO(0x0242); break;
                   case 0x0243: CASECHG_SETTO(0x0180); break;
                   case 0x0244: CASECHG_SETTO(0x0289); break;
                   case 0x0245: CASECHG_SETTO(0x028C); break;
                 }
             else /* CASECHG_C >= U+0246 */ {
               if(CASECHG_C < 0x024F) {
                 if((CASECHG_C&1)==0) CASECHG_SHIFTBY(+1);
           } } else /* CASECHG_C >= U+0370 */
             if(CASECHG_C < 0x0388)
               if(CASECHG_C < 0x0373) {
                 if((CASECHG_C&1)==0) CASECHG_SHIFTBY(+1);
               } else /* CASECHG_C >= U+0373 */
                 switch(CASECHG_C) {
                   case 0x0376: CASECHG_SETTO(0x0377); break;
                   case 0x0386: CASECHG_SETTO(0x03AC); break;
                 }
             else /* CASECHG_C >= U+0388 */
               if(CASECHG_C < 0x038B)
                 CASECHG_SHIFTBY(+37);
               else /* CASECHG_C >= U+038B */
                 {if(CASECHG_C == 0x038C) CASECHG_SETTO(0x03CC);}
     else /* CASECHG_C >= U+038E */
       if(CASECHG_C < 0x0527)
         if(CASECHG_C < 0x0410)
           if(CASECHG_C < 0x03D8)
             if(CASECHG_C < 0x0391)
               {if(CASECHG_C!=0x0390) CASECHG_SHIFTBY(+63);}
             else /* CASECHG_C >= U+0391 */
               if(CASECHG_C < 0x03AC)
                 {if(CASECHG_C!=0x03A2) CASECHG_SHIFTBY(+32);}
               else /* CASECHG_C >= U+03AC */
                 {if(CASECHG_C == 0x03CF) CASECHG_SETTO(0x03D7);}
           else /* CASECHG_C >= U+03D8 */
             if(CASECHG_C < 0x03FD)
               if(CASECHG_C < 0x03EF) {
                 if((CASECHG_C&1)==0) CASECHG_SHIFTBY(+1);
               } else /* CASECHG_C >= U+03EF */
                 switch(CASECHG_C) {
                   case 0x03F4: CASECHG_SETTO(0x03B8); break;
                   case 0x03F7: CASECHG_SETTO(0x03F8); break;
                   case 0x03F9: CASECHG_SETTO(0x03F2); break;
                   case 0x03FA: CASECHG_SETTO(0x03FB); break;
                 }
             else /* CASECHG_C >= U+03FD */
               if(CASECHG_C < 0x0400)
                 CASECHG_SHIFTBY(-130);
               else /* CASECHG_C >= U+0400 */
                 CASECHG_SHIFTBY(+80);
         else /* CASECHG_C >= U+0410 */
           if(CASECHG_C < 0x0481)
             if(CASECHG_C < 0x0430)
               CASECHG_SHIFTBY(+32);
             else /* CASECHG_C >= U+0430 */ {
               if(CASECHG_C >= 0x0460) {
                 if((CASECHG_C&1)==0) CASECHG_SHIFTBY(+1);
           } } else /* CASECHG_C >= U+0481 */
             if(CASECHG_C < 0x04C1) {
               if(CASECHG_C >= 0x048A) {
                 if(CASECHG_C == 0x04C0) CASECHG_SETTO(0x04CF);
                 else {if((CASECHG_C&1)==0) CASECHG_SHIFTBY(+1);}}
             } else /* CASECHG_C >= U+04C1 */
               if(CASECHG_C < 0x04CF) {
                 if(CASECHG_C&1) CASECHG_SHIFTBY(+1);
               } else /* CASECHG_C >= U+04CF */ {
                 if((CASECHG_C&1)==0) CASECHG_SHIFTBY(+1);
       } else /* CASECHG_C >= U+0527 */
         if(CASECHG_C < 0x1E9F)
           if(CASECHG_C < 0x10A0) {
             if(0x0531<=CASECHG_C && CASECHG_C < 0x0557)
               CASECHG_SHIFTBY(+48);
           } else /* CASECHG_C >= U+10A0 */
             if(CASECHG_C < 0x1E00)
               if(CASECHG_C <= 0x10C7 && CASECHG_C != 0x10C6)
                 CASECHG_SHIFTBY(+7264);
               else
                 {if(CASECHG_C == 0x10CD) CASECHG_SHIFTBY(+7264);}
             else /* CASECHG_C >= U+1E00 */
               if(CASECHG_C < 0x1E95) {
                 if((CASECHG_C&1)==0) CASECHG_SHIFTBY(+1);
               } else /* CASECHG_C >= U+1E95 */
                 {if(CASECHG_C == 0x1E9E) CASECHG_SETTO(0x00DF);}
         else /* CASECHG_C >= U+1E9F */
           if(CASECHG_C < 0x1F18)
             if(CASECHG_C < 0x1F08) {
               if(CASECHG_C < 0x1EFF) {
                 if((CASECHG_C&1)==0) CASECHG_SHIFTBY(+1);
             } } else /* CASECHG_C >= U+1F08 */ {
               if(CASECHG_C < 0x1F10)
                 CASECHG_SHIFTBY(-8);
           } else /* CASECHG_C >= U+1F18 */
             if(CASECHG_C < 0x1F28) {
               if(CASECHG_C < 0x1F1E)
                 CASECHG_SHIFTBY(-8);
             } else /* CASECHG_C >= U+1F28 */ {
               if(CASECHG_C < 0x1F30)
                 CASECHG_SHIFTBY(-8);
   } else /* CASECHG_C >= U+1F38 */
     if(CASECHG_C < 0x2170)
       if(CASECHG_C < 0x1FB8)
         if(CASECHG_C < 0x1F70)
           if(CASECHG_C < 0x1F4E)
             if(CASECHG_C < 0x1F40)
               CASECHG_SHIFTBY(-8);
             else /* CASECHG_C >= U+1F40 */ {
               if(CASECHG_C >= 0x1F48)
                 CASECHG_SHIFTBY(-8);
           } else /* CASECHG_C >= U+1F4E */
             if(CASECHG_C < 0x1F60) {
               if(CASECHG_C >= 0x1F59) {
                 if(CASECHG_C&1) CASECHG_SHIFTBY(-8);
             } } else /* CASECHG_C >= U+1F60 */ {
               if(CASECHG_C >= 0x1F68)
                 CASECHG_SHIFTBY(-8);
         } else /* CASECHG_C >= U+1F70 */
           if(CASECHG_C < 0x1F98) {
             if(0x1F88<=CASECHG_C && CASECHG_C < 0x1F90)
               CASECHG_SHIFTBY(-8);
           } else /* CASECHG_C >= U+1F98 */
             if(CASECHG_C < 0x1FA8) {
               if(CASECHG_C < 0x1FA0)
                 CASECHG_SHIFTBY(-8);
             } else /* CASECHG_C >= U+1FA8 */ {
               if(CASECHG_C < 0x1FB0)
                 CASECHG_SHIFTBY(-8);
       } else /* CASECHG_C >= U+1FB8 */
         if(CASECHG_C < 0x1FDC)
           if(CASECHG_C < 0x1FC8) {
             if(CASECHG_C < 0x1FBD) {
               if(CASECHG_C < 0x1FBA)
                 CASECHG_SHIFTBY(-8);
               else /* CASECHG_C >= U+1FBA */
                 if(CASECHG_C == 0x1FBC) CASECHG_SETTO(0x1FB3); else CASECHG_SHIFTBY(-74);}
           } else /* CASECHG_C >= U+1FC8 */
             if(CASECHG_C < 0x1FD8) {
               if(CASECHG_C < 0x1FCD) {
                 if(CASECHG_C == 0x1FCC) CASECHG_SETTO(0x1FC3); else CASECHG_SHIFTBY(-86);}
             } else /* CASECHG_C >= U+1FD8 */
               if(CASECHG_C < 0x1FDA)
                 CASECHG_SHIFTBY(-8);
               else /* CASECHG_C >= U+1FDA */
                 CASECHG_SHIFTBY(-100);
         else /* CASECHG_C >= U+1FDC */
           if(CASECHG_C < 0x1FF8)
             if(CASECHG_C < 0x1FEA) {
               if(CASECHG_C >= 0x1FE8)
                 CASECHG_SHIFTBY(-8);
             } else /* CASECHG_C >= U+1FEA */ {
               if(CASECHG_C < 0x1FED) {
                 if(CASECHG_C == 0x1FEC) CASECHG_SETTO(0x1FE5); else CASECHG_SHIFTBY(-112);}
           } else /* CASECHG_C >= U+1FF8 */
             if(CASECHG_C < 0x1FFD)
               if(CASECHG_C < 0x1FFA)
                 CASECHG_SHIFTBY(-128);
               else /* CASECHG_C >= U+1FFA */
                 if(CASECHG_C == 0x1FFC) CASECHG_SETTO(0x1FF3); else CASECHG_SHIFTBY(-126);
             else /* CASECHG_C >= U+1FFD */
               if(CASECHG_C < 0x2160)
                 switch(CASECHG_C) {
                   case 0x2126: CASECHG_SETTO(0x03C9); break;
                   case 0x212A: CASECHG_SETTO(0x006B); break;
                   case 0x212B: CASECHG_SETTO(0x00E5); break;
                   case 0x2132: CASECHG_SETTO(0x214E); break;
                 }
               else /* CASECHG_C >= U+2160 */
                 CASECHG_SHIFTBY(+16);
     else /* CASECHG_C >= U+2170 */
       if(CASECHG_C < 0xA680)
         if(CASECHG_C < 0x2C7E)
           if(CASECHG_C < 0x2C00) {
             if(CASECHG_C < 0x24D0) {
               if(CASECHG_C < 0x24B6)
                 {if(CASECHG_C == 0x2183) CASECHG_SETTO(0x2184);}
               else /* CASECHG_C >= U+24B6 */
                 CASECHG_SHIFTBY(+26);}
           } else /* CASECHG_C >= U+2C00 */
             if(CASECHG_C < 0x2C67)
               if(CASECHG_C < 0x2C2F)
                 CASECHG_SHIFTBY(+48);
               else /* CASECHG_C >= U+2C2F */
                 switch(CASECHG_C) {
                   case 0x2C60: CASECHG_SETTO(0x2C61); break;
                   case 0x2C62: CASECHG_SETTO(0x026B); break;
                   case 0x2C63: CASECHG_SETTO(0x1D7D); break;
                   case 0x2C64: CASECHG_SETTO(0x027D); break;
                 }
             else /* CASECHG_C >= U+2C67 */
               if(CASECHG_C < 0x2C73)
                 switch(CASECHG_C) {
                   case 0x2C6D: CASECHG_SETTO(0x0251); break;
                   case 0x2C6E: CASECHG_SETTO(0x0271); break;
                   case 0x2C6F: CASECHG_SETTO(0x0250); break;
                   case 0x2C70: CASECHG_SETTO(0x0252); break;
                   case 0x2C71: break;
                   case 0x2C72: CASECHG_SETTO(0x2C73); break;
                   default: if((CASECHG_C&1)==1) CASECHG_SHIFTBY(+1);
                 }
               else /* CASECHG_C >= U+2C73 */
                 {if(CASECHG_C == 0x2C75) CASECHG_SETTO(0x2C76);}
         else /* CASECHG_C >= U+2C7E */
           if(CASECHG_C < 0x2CEB) {
             if(CASECHG_C < 0x2CE3) {
               if(CASECHG_C < 0x2C80)
                 CASECHG_SHIFTBY(-10815);
               else /* CASECHG_C >= U+2C80 */ {
                 if((CASECHG_C&1)==0) CASECHG_SHIFTBY(+1);
           }}} else /* CASECHG_C >= U+2CEB */
             if(CASECHG_C < 0xA640)
               if(CASECHG_C < 0x2CEE)
                 {if(CASECHG_C&1) CASECHG_SHIFTBY(+1);}
               else
                 {if(CASECHG_C == 0x2CF2) CASECHG_SETTO(0x2CF3);}
             else /* CASECHG_C >= U+A640 */ {
               if(CASECHG_C < 0xA66D) {
                 if((CASECHG_C&1)==0) CASECHG_SHIFTBY(+1);
       } } else /* CASECHG_C >= U+A680 */
         if(CASECHG_C < 0xA77E)
           if(CASECHG_C < 0xA72F)
             if(CASECHG_C < 0xA697) {
               if((CASECHG_C&1)==0) CASECHG_SHIFTBY(+1);
             } else /* CASECHG_C >= U+A697 */ {
               if(CASECHG_C >= 0xA722) {
                 if((CASECHG_C&1)==0) CASECHG_SHIFTBY(+1);
           } } else /* CASECHG_C >= U+A72F */
             if(CASECHG_C < 0xA76F) {
               if(CASECHG_C >= 0xA732) {
                 if((CASECHG_C&1)==0) CASECHG_SHIFTBY(+1);
             } } else /* CASECHG_C >= U+A76F */ {
               if(CASECHG_C >= 0xA779) {
                 if(CASECHG_C == 0xA77D) CASECHG_SETTO(0x1D79);
                 else {if((CASECHG_C&1)==1) CASECHG_SHIFTBY(+1);}}
         } else /* CASECHG_C >= U+A77E */
           if(CASECHG_C < 0xFF21)
             if(CASECHG_C < 0xA7A0)
               if(CASECHG_C < 0xA787) {
                 if((CASECHG_C&1)==0) CASECHG_SHIFTBY(+1);
               } else /* CASECHG_C >= U+A787 */
                 switch(CASECHG_C) {
                   case 0xA78B: CASECHG_SETTO(0xA78C); break;
                   case 0xA78D: CASECHG_SETTO(0x0265); break;
                   case 0xA790: CASECHG_SETTO(0xA791); break;
                   case 0xA792: CASECHG_SETTO(0xA793); break;
                 }
             else /* CASECHG_C >= U+A7A0 */
               if(CASECHG_C < 0xA7A9)
                 {if((CASECHG_C&1)==0) CASECHG_SHIFTBY(+1);}
               else
                 {if(CASECHG_C == 0xA7AA) CASECHG_SETTO(0x0266);}
           else /* CASECHG_C >= U+FF21 */
             if(CASECHG_C < 0x10400) {
               if(CASECHG_C < 0xFF3B)
                 CASECHG_SHIFTBY(+32);
             } else /* CASECHG_C >= U+10400 */ {
               if(CASECHG_C < 0x10428)
                 CASECHG_SHIFTBY(+40);
   }
}  /* end m_tolowercase_inplace_u32c()                                 */

/**
* replace a 32-bit char by its uppercase equivalent, if there is one, else
* leave it unchanged. Uses the "simple" way from the Unicode tables
* (not the "full" one which could also change the number of characters).
*  @param[in,out] aump_c the codepoint
*/
extern PTYPE void m_touppercase_inplace_u32c(unsigned int *aump_c) {
   if(CASECHG_C < 0x1F30)
     if(CASECHG_C < 0x0371)
       if(CASECHG_C < 0x01B7)
         if(CASECHG_C < 0x0179)
           if(CASECHG_C < 0x00E0) {
             if(CASECHG_C >= 0x0061) {
               if(CASECHG_C < 0x007B)
                 CASECHG_SHIFTBY(-32);
               else /* CASECHG_C >= U+007B */
                 {if(CASECHG_C == 0x00B5) CASECHG_SETTO(0x039C);}
           }} else /* CASECHG_C >= U+00E0 */
             if(CASECHG_C < 0x0139)
               if(CASECHG_C < 0x0100)
                 switch(CASECHG_C) {
                   case 0x00F7: break;
                   case 0x00FF: CASECHG_SETTO(0x0178); break;
                   default: CASECHG_SHIFTBY(-32);
                 }
               else /* CASECHG_C >= U+0100 */
                 if(CASECHG_C == 0x0131) CASECHG_SETTO(0x0049);
                 else {if((CASECHG_C&1)==1) CASECHG_SHIFTBY(-1);}
             else /* CASECHG_C >= U+0139 */
               if(CASECHG_C < 0x014A) {
                 if((CASECHG_C&1)==0) CASECHG_SHIFTBY(-1);
               } else /* CASECHG_C >= U+014A */ {
                 if(CASECHG_C&1) CASECHG_SHIFTBY(-1);
         } else /* CASECHG_C >= U+0179 */
           if(CASECHG_C < 0x0186)
             if(CASECHG_C < 0x0181)
               switch(CASECHG_C) {
                 case 0x017F: CASECHG_SETTO(0x0053); break;
                 case 0x0180: CASECHG_SETTO(0x0243); break;
                 default: if((CASECHG_C&1)==0) CASECHG_SHIFTBY(-1);
               }
             else /* CASECHG_C >= U+0181 */ {
               if(CASECHG_C >= 0x0183) {
                 if(CASECHG_C&1) CASECHG_SHIFTBY(-1);
           } } else /* CASECHG_C >= U+0186 */
             if(CASECHG_C < 0x01A6)
               if(CASECHG_C < 0x01A1)
                 switch(CASECHG_C) {
                   case 0x0188: CASECHG_SETTO(0x0187); break;
                   case 0x018C: CASECHG_SETTO(0x018B); break;
                   case 0x0192: CASECHG_SETTO(0x0191); break;
                   case 0x0195: CASECHG_SETTO(0x01F6); break;
                   case 0x0199: CASECHG_SETTO(0x0198); break;
                   case 0x019A: CASECHG_SETTO(0x023D); break;
                   case 0x019E: CASECHG_SETTO(0x0220); break;
                 }
               else /* CASECHG_C >= U+01A1 */ {
                 if(CASECHG_C&1) CASECHG_SHIFTBY(-1);
             } else /* CASECHG_C >= U+01A6 */
               if(CASECHG_C < 0x01B4)
                 switch(CASECHG_C) {
                   case 0x01A8: CASECHG_SETTO(0x01A7); break;
                   case 0x01AD: CASECHG_SETTO(0x01AC); break;
                   case 0x01B0: CASECHG_SETTO(0x01AF); break;
                 }
               else /* CASECHG_C >= U+01B4 */ {
                 if((CASECHG_C&1)==0) CASECHG_SHIFTBY(-1);
       } else /* CASECHG_C >= U+01B7 */
         if(CASECHG_C < 0x0234)
           if(CASECHG_C < 0x01F0)
             if(CASECHG_C < 0x01CD)
               switch(CASECHG_C) {
                 case 0x01B9: CASECHG_SETTO(0x01B8); break;
                 case 0x01BD: CASECHG_SETTO(0x01BC); break;
                 case 0x01BF: CASECHG_SETTO(0x01F7); break;
                 case 0x01C5: CASECHG_SETTO(0x01C4); break;
                 case 0x01C6: CASECHG_SETTO(0x01C4); break;
                 case 0x01C8: CASECHG_SETTO(0x01C7); break;
                 case 0x01C9: CASECHG_SETTO(0x01C7); break;
                 case 0x01CB: CASECHG_SETTO(0x01CA); break;
                 case 0x01CC: CASECHG_SETTO(0x01CA); break;
               }
             else /* CASECHG_C >= U+01CD */
               if(CASECHG_C < 0x01DE)
                 if(CASECHG_C == 0x01DD) CASECHG_SETTO(0x018E);
                 else {if((CASECHG_C&1)==0) CASECHG_SHIFTBY(-1);}
               else /* CASECHG_C >= U+01DE */ {
                 if(CASECHG_C&1) CASECHG_SHIFTBY(-1);
           } else /* CASECHG_C >= U+01F0 */
             if(CASECHG_C < 0x0220)
               if(CASECHG_C < 0x01F9)
                 switch(CASECHG_C) {
                   case 0x01F2: CASECHG_SETTO(0x01F1); break;
                   case 0x01F3: CASECHG_SETTO(0x01F1); break;
                   case 0x01F5: CASECHG_SETTO(0x01F4); break;
                 }
               else /* CASECHG_C >= U+01F9 */ {
                 if(CASECHG_C&1) CASECHG_SHIFTBY(-1);
             } else /* CASECHG_C >= U+0220 */ {
               if(CASECHG_C >= 0x0223) {
                 if(CASECHG_C&1) CASECHG_SHIFTBY(-1);
         } } else /* CASECHG_C >= U+0234 */
           if(CASECHG_C < 0x0256)
             if(CASECHG_C < 0x0243)
               if(CASECHG_C < 0x023F)
                 {if(CASECHG_C == 0x023C) CASECHG_SETTO(0x023B);}
               else /* CASECHG_C >= U+023F */
                 switch(CASECHG_C) {
                   case 0x0241: break;
                   case 0x0242: CASECHG_SETTO(0x0241); break;
                   default: CASECHG_SHIFTBY(+10815);
                 }
             else /* CASECHG_C >= U+0243 */ {
               if(CASECHG_C >= 0x0247)
                 switch(CASECHG_C) {
                   case 0x0250: CASECHG_SETTO(0x2C6F); break;
                   case 0x0251: CASECHG_SETTO(0x2C6D); break;
                   case 0x0252: CASECHG_SETTO(0x2C70); break;
                   case 0x0253: CASECHG_SETTO(0x0181); break;
                   case 0x0254: CASECHG_SETTO(0x0186); break;
                   case 0x0255: break;
                   default: if((CASECHG_C&1)==1) CASECHG_SHIFTBY(-1);
                 }
           } else /* CASECHG_C >= U+0256 */
             if(CASECHG_C < 0x028A)
               if(CASECHG_C < 0x025C)
                 switch(CASECHG_C) {
                   case 0x0258: break;
                   case 0x0259: CASECHG_SETTO(0x018F); break;
                   case 0x025A: break;
                   case 0x025B: CASECHG_SETTO(0x0190); break;
                   default: CASECHG_SHIFTBY(-205);
                 }
               else /* CASECHG_C >= U+025C */
                 switch(CASECHG_C) {
                   case 0x0260: CASECHG_SETTO(0x0193); break;
                   case 0x0263: CASECHG_SETTO(0x0194); break;
                   case 0x0265: CASECHG_SETTO(0xA78D); break;
                   case 0x0266: CASECHG_SETTO(0xA7AA); break;
                   case 0x0268: CASECHG_SETTO(0x0197); break;
                   case 0x0269: CASECHG_SETTO(0x0196); break;
                   case 0x026B: CASECHG_SETTO(0x2C62); break;
                   case 0x026F: CASECHG_SETTO(0x019C); break;
                   case 0x0271: CASECHG_SETTO(0x2C6E); break;
                   case 0x0272: CASECHG_SETTO(0x019D); break;
                   case 0x0275: CASECHG_SETTO(0x019F); break;
                   case 0x027D: CASECHG_SETTO(0x2C64); break;
                   case 0x0280: CASECHG_SETTO(0x01A6); break;
                   case 0x0283: CASECHG_SETTO(0x01A9); break;
                   case 0x0288: CASECHG_SETTO(0x01AE); break;
                   case 0x0289: CASECHG_SETTO(0x0244); break;
                 }
             else /* CASECHG_C >= U+028A */
               if(CASECHG_C < 0x028D)
                 if(CASECHG_C == 0x028C) CASECHG_SETTO(0x0245); else CASECHG_SHIFTBY(-217);
               else /* CASECHG_C >= U+028D */
                 switch(CASECHG_C) {
                   case 0x0292: CASECHG_SETTO(0x01B7); break;
                   case 0x0345: CASECHG_SETTO(0x0399); break;
                 }
     else /* CASECHG_C >= U+0371 */
       if(CASECHG_C < 0x048B)
         if(CASECHG_C < 0x03D2)
           if(CASECHG_C < 0x037E)
             if(CASECHG_C < 0x0374) {
               if(CASECHG_C&1) CASECHG_SHIFTBY(-1);
             } else /* CASECHG_C >= U+0374 */
               if(CASECHG_C < 0x037B)
                 {if(CASECHG_C == 0x0377) CASECHG_SETTO(0x0376);}
               else /* CASECHG_C >= U+037B */
                 CASECHG_SHIFTBY(+130);
           else /* CASECHG_C >= U+037E */
             if(CASECHG_C < 0x03B1)
               if(CASECHG_C < 0x03AD)
                 {if(CASECHG_C == 0x03AC) CASECHG_SETTO(0x0386);}
               else /* CASECHG_C >= U+03AD */
                 {if(CASECHG_C!=0x03B0) CASECHG_SHIFTBY(-37);}
             else /* CASECHG_C >= U+03B1 */
               if(CASECHG_C < 0x03CD)
                 switch(CASECHG_C) {
                   case 0x03C2: CASECHG_SETTO(0x03A3); break;
                   case 0x03CC: CASECHG_SETTO(0x038C); break;
                   default: CASECHG_SHIFTBY(-32);
                 }
               else /* CASECHG_C >= U+03CD */
                 switch(CASECHG_C) {
                   case 0x03CF: break;
                   case 0x03D0: CASECHG_SETTO(0x0392); break;
                   case 0x03D1: CASECHG_SETTO(0x0398); break;
                   default: CASECHG_SHIFTBY(-63);
                 }
         else /* CASECHG_C >= U+03D2 */
           if(CASECHG_C < 0x0430)
             if(CASECHG_C < 0x03D8)
               switch(CASECHG_C) {
                 case 0x03D5: CASECHG_SETTO(0x03A6); break;
                 case 0x03D6: CASECHG_SETTO(0x03A0); break;
                 case 0x03D7: CASECHG_SETTO(0x03CF); break;
               }
             else /* CASECHG_C >= U+03D8 */
               if(CASECHG_C < 0x03F3)
                 switch(CASECHG_C) {
                   case 0x03F0: CASECHG_SETTO(0x039A); break;
                   case 0x03F1: CASECHG_SETTO(0x03A1); break;
                   case 0x03F2: CASECHG_SETTO(0x03F9); break;
                   default: if((CASECHG_C&1)==1) CASECHG_SHIFTBY(-1);
                 }
               else /* CASECHG_C >= U+03F3 */
                 switch(CASECHG_C) {
                   case 0x03F5: CASECHG_SETTO(0x0395); break;
                   case 0x03F8: CASECHG_SETTO(0x03F7); break;
                   case 0x03FB: CASECHG_SETTO(0x03FA); break;
                 }
           else /* CASECHG_C >= U+0430 */
             if(CASECHG_C < 0x0460)
               if(CASECHG_C < 0x0450)
                 CASECHG_SHIFTBY(-32);
               else /* CASECHG_C >= U+0450 */
                 CASECHG_SHIFTBY(-80);
             else /* CASECHG_C >= U+0460 */ {
               if(CASECHG_C < 0x0482) {
                 if(CASECHG_C&1) CASECHG_SHIFTBY(-1);
       } } else /* CASECHG_C >= U+048B */
         if(CASECHG_C < 0x1E96)
           if(CASECHG_C < 0x0528)
             if(CASECHG_C < 0x04C1) {
               if(CASECHG_C&1) CASECHG_SHIFTBY(-1);
             } else /* CASECHG_C >= U+04C1 */
               if(CASECHG_C < 0x04D0)
                 if(CASECHG_C == 0x04CF) CASECHG_SETTO(0x04C0);
                 else {if((CASECHG_C&1)==0) CASECHG_SHIFTBY(-1);}
               else /* CASECHG_C >= U+04D0 */ {
                 if(CASECHG_C&1) CASECHG_SHIFTBY(-1);
           } else /* CASECHG_C >= U+0528 */
             if(CASECHG_C < 0x0587) {
               if(CASECHG_C >= 0x0561)
                 CASECHG_SHIFTBY(-48);
             } else /* CASECHG_C >= U+0587 */
               if(CASECHG_C < 0x1E01)
                 switch(CASECHG_C) {
                   case 0x1D79: CASECHG_SETTO(0xA77D); break;
                   case 0x1D7D: CASECHG_SETTO(0x2C63); break;
                 }
               else /* CASECHG_C >= U+1E01 */ {
                 if(CASECHG_C&1) CASECHG_SHIFTBY(-1);
         } else /* CASECHG_C >= U+1E96 */
           if(CASECHG_C < 0x1F10)
             if(CASECHG_C < 0x1F00)
               if(CASECHG_C < 0x1EA1)
                 {if(CASECHG_C == 0x1E9B) CASECHG_SETTO(0x1E60);}
               else /* CASECHG_C >= U+1EA1 */ {
                 if(CASECHG_C&1) CASECHG_SHIFTBY(-1);
             } else /* CASECHG_C >= U+1F00 */ {
               if(CASECHG_C < 0x1F08)
                 CASECHG_SHIFTBY(+8);
           } else /* CASECHG_C >= U+1F10 */
             if(CASECHG_C < 0x1F20) {
               if(CASECHG_C < 0x1F16)
                 CASECHG_SHIFTBY(+8);
             } else /* CASECHG_C >= U+1F20 */ {
               if(CASECHG_C < 0x1F28)
                 CASECHG_SHIFTBY(+8);
   } else /* CASECHG_C >= U+1F30 */
     if(CASECHG_C < 0x24D0)
       if(CASECHG_C < 0x1F7E)
         if(CASECHG_C < 0x1F68)
           if(CASECHG_C < 0x1F46)
             if(CASECHG_C < 0x1F38)
               CASECHG_SHIFTBY(+8);
             else /* CASECHG_C >= U+1F38 */ {
               if(CASECHG_C >= 0x1F40)
                 CASECHG_SHIFTBY(+8);
           } else /* CASECHG_C >= U+1F46 */
             if(CASECHG_C < 0x1F58) {
               if(CASECHG_C >= 0x1F51) {
                 if(CASECHG_C&1) CASECHG_SHIFTBY(+8);
             } } else /* CASECHG_C >= U+1F58 */ {
               if(CASECHG_C >= 0x1F60)
                 CASECHG_SHIFTBY(+8);
         } else /* CASECHG_C >= U+1F68 */
           if(CASECHG_C < 0x1F76) {
             if(CASECHG_C >= 0x1F70) {
               if(CASECHG_C < 0x1F72)
                 CASECHG_SHIFTBY(+74);
               else /* CASECHG_C >= U+1F72 */
                 CASECHG_SHIFTBY(+86);
           }} else /* CASECHG_C >= U+1F76 */
             if(CASECHG_C < 0x1F7A)
               if(CASECHG_C < 0x1F78)
                 CASECHG_SHIFTBY(+100);
               else /* CASECHG_C >= U+1F78 */
                 CASECHG_SHIFTBY(+128);
             else /* CASECHG_C >= U+1F7A */
               if(CASECHG_C < 0x1F7C)
                 CASECHG_SHIFTBY(+112);
               else /* CASECHG_C >= U+1F7C */
                 CASECHG_SHIFTBY(+126);
       else /* CASECHG_C >= U+1F7E */
         if(CASECHG_C < 0x1FB0)
           if(CASECHG_C < 0x1F90) {
             if(0x1F80<=CASECHG_C && CASECHG_C < 0x1F88)
               CASECHG_SHIFTBY(+8);
           } else /* CASECHG_C >= U+1F90 */
             if(CASECHG_C < 0x1FA0) {
               if(CASECHG_C < 0x1F98)
                 CASECHG_SHIFTBY(+8);
             } else /* CASECHG_C >= U+1FA0 */ {
               if(CASECHG_C < 0x1FA8)
                 CASECHG_SHIFTBY(+8);
         } else /* CASECHG_C >= U+1FB0 */
           if(CASECHG_C < 0x1FE0)
             if(CASECHG_C < 0x1FD0)
               if(CASECHG_C < 0x1FB4)
                 switch(CASECHG_C) {
                   case 0x1FB2: break;
                   case 0x1FB3: CASECHG_SETTO(0x1FBC); break;
                   default: CASECHG_SHIFTBY(+8);
                 }
               else /* CASECHG_C >= U+1FB4 */
                 switch(CASECHG_C) {
                   case 0x1FBE: CASECHG_SETTO(0x0399); break;
                   case 0x1FC3: CASECHG_SETTO(0x1FCC); break;
                 }
             else /* CASECHG_C >= U+1FD0 */ {
               if(CASECHG_C < 0x1FD2)
                 CASECHG_SHIFTBY(+8);
           } else /* CASECHG_C >= U+1FE0 */
             if(CASECHG_C < 0x2170)
               if(CASECHG_C < 0x1FE2)
                 CASECHG_SHIFTBY(+8);
               else /* CASECHG_C >= U+1FE2 */
                 switch(CASECHG_C) {
                   case 0x1FE5: CASECHG_SETTO(0x1FEC); break;
                   case 0x1FF3: CASECHG_SETTO(0x1FFC); break;
                   case 0x214E: CASECHG_SETTO(0x2132); break;
                 }
             else /* CASECHG_C >= U+2170 */
               if(CASECHG_C < 0x2180)
                 CASECHG_SHIFTBY(-16);
               else /* CASECHG_C >= U+2180 */
                 {if(CASECHG_C == 0x2184) CASECHG_SETTO(0x2183);}
     else /* CASECHG_C >= U+24D0 */
       if(CASECHG_C < 0xA681)
         if(CASECHG_C < 0x2CE4)
           if(CASECHG_C < 0x2C5F)
             if(CASECHG_C < 0x24EA)
               CASECHG_SHIFTBY(-26);
             else /* CASECHG_C >= U+24EA */ {
               if(CASECHG_C >= 0x2C30)
                 CASECHG_SHIFTBY(-48);
           } else /* CASECHG_C >= U+2C5F */
             if(CASECHG_C < 0x2C6D)
               if(CASECHG_C < 0x2C67)
                 switch(CASECHG_C) {
                   case 0x2C61: CASECHG_SETTO(0x2C60); break;
                   case 0x2C65: CASECHG_SETTO(0x023A); break;
                   case 0x2C66: CASECHG_SETTO(0x023E); break;
                 }
               else /* CASECHG_C >= U+2C67 */ {
                 if((CASECHG_C&1)==0) CASECHG_SHIFTBY(-1);
             } else /* CASECHG_C >= U+2C6D */
               if(CASECHG_C < 0x2C81)
                 switch(CASECHG_C) {
                   case 0x2C73: CASECHG_SETTO(0x2C72); break;
                   case 0x2C76: CASECHG_SETTO(0x2C75); break;
                 }
               else /* CASECHG_C >= U+2C81 */ {
                 if(CASECHG_C&1) CASECHG_SHIFTBY(-1);
         } else /* CASECHG_C >= U+2CE4 */
           if(CASECHG_C < 0x2D00)
             if(0x2CEC<=CASECHG_C && CASECHG_C < 0x2CEF)
               {if((CASECHG_C&1)==0) CASECHG_SHIFTBY(-1);}
             else
               {if(CASECHG_C == 0x2CF3) CASECHG_SETTO(0x2CF2);}
           else /* CASECHG_C >= U+2D00 */
             if(CASECHG_C < 0xA641)
               if(CASECHG_C <= 0x2D27 && CASECHG_C != 0x2D26)
                 CASECHG_SHIFTBY(-7264);
               else
                 {if(CASECHG_C == 0x2D2D) CASECHG_SHIFTBY(-7264);}
             else /* CASECHG_C >= U+A641 */ {
               if(CASECHG_C < 0xA66E) {
                 if(CASECHG_C&1) CASECHG_SHIFTBY(-1);
       } } else /* CASECHG_C >= U+A681 */
         if(CASECHG_C < 0xA77E)
           if(CASECHG_C < 0xA730)
             if(CASECHG_C < 0xA698) {
               if(CASECHG_C&1) CASECHG_SHIFTBY(-1);
             } else /* CASECHG_C >= U+A698 */ {
               if(CASECHG_C >= 0xA723) {
                 if(CASECHG_C&1) CASECHG_SHIFTBY(-1);
           } } else /* CASECHG_C >= U+A730 */
             if(CASECHG_C < 0xA770) {
               if(CASECHG_C >= 0xA733) {
                 if(CASECHG_C&1) CASECHG_SHIFTBY(-1);
             } } else /* CASECHG_C >= U+A770 */ {
               if(CASECHG_C >= 0xA77A) {
                 if((CASECHG_C&1)==0) CASECHG_SHIFTBY(-1);
         } } else /* CASECHG_C >= U+A77E */
           if(CASECHG_C < 0xFF41)
             if(CASECHG_C < 0xA7A1)
               if(CASECHG_C < 0xA788) {
                 if(CASECHG_C&1) CASECHG_SHIFTBY(-1);
               } else /* CASECHG_C >= U+A788 */
                 switch(CASECHG_C) {
                   case 0xA78C:
                   case 0xA791:
                   case 0xA793: CASECHG_SHIFTBY(-1); break;
                 }
             else /* CASECHG_C >= U+A7A1 */ {
               if(CASECHG_C < 0xA7AA) {
                 if(CASECHG_C&1) CASECHG_SHIFTBY(-1);
           } } else /* CASECHG_C >= U+FF41 */
             if(CASECHG_C < 0x10428) {
               if(CASECHG_C < 0xFF5B)
                 CASECHG_SHIFTBY(-32);
             } else /* CASECHG_C >= U+10428 */ {
               if(CASECHG_C < 0x10450)
                 CASECHG_SHIFTBY(-40);
   }
}  /* end m_touppercase_inplace_u32c()                                 */

/* discard macros for use in m_tolowercase_u32c and m_touppercase_u32c */
#undef CASECHG_C
#undef CASECHG_SETTO
#undef CASECHG_SHIFTBY

/**
* translate Unicode character UTF-16 to lowercase (no surrogates!)
*  @param wcp_p the codepoint
*  @return lowercase (or identical to wcp_p, if it has no caseness) codepoint
*/
static inline unsigned short int m_trans_to_lc( unsigned short int wcp_p ) {
   unsigned int iml_c;
   iml_c = wcp_p;
   m_tolowercase_inplace_u32c(&iml_c);
/* Although there are characters that get much more bits (e.g. 023E->2C66),
   there are none that go across the 16-bit limit as of Unicode 6.1 (2/2012) */
   return (unsigned short int)iml_c;
} /* end m_trans_to_lc()                                               */

/**
* translate Unicode character UTF-16 to uppercase (no surrogates!)
*  @param wcp_p the codepoint
*  @return uppercase (or identical to wcp_p, if it has no caseness) codepoint
*/
static inline unsigned short int m_trans_to_uc( unsigned short int wcp_p ) {
   unsigned int iml_c;
   iml_c = wcp_p;
   m_touppercase_inplace_u32c(&iml_c);
/* Although there are characters that get much more bits (e.g. 026B->2C62),
   there are none that go across the 16-bit limit as of Unicode 6.1 (2/2012) */
   return (unsigned short int)iml_c;
} /* end m_trans_to_uc()                                               */

/**
* translate Unicode character UTF-32 to lowercase
*  @param imp_inp the codepoint
*  @return lowercase (or identical to imp_inp, if it has no caseness) codepoint
*/
static inline int m_trans_32_to_lc( int imp_inp ) {
   m_tolowercase_inplace_u32c((unsigned int*)&imp_inp);
   return imp_inp;
} /* end m_trans_32_to_lc()                                            */

/**
* translate Unicode character UTF-32 to uppercase
*  @param imp_inp the codepoint
*  @return uppercase (or identical to imp_inp, if it has no caseness) codepoint
*/
static inline int m_trans_32_to_uc( int imp_inp ) {
   m_touppercase_inplace_u32c((unsigned int*)&imp_inp);
   return imp_inp;
} /* end m_trans_32_to_uc()                                            */

/**
* check whether a Unicode character is unchanged in lowercase-making
*  @param imp_inp the codepoint
*  @return whether imp_inp has no or is identical to its own lowercase
*/
static inline BOOL m_is_own_lowercase( int imp_inp ) {
   unsigned int ump_lc = (unsigned int)imp_inp;
   m_tolowercase_inplace_u32c(&ump_lc);
   return (ump_lc==(unsigned int)imp_inp);
}

#define HL_ENDIANSWAP32(INP_X) (((INP_X)>>24) | (((INP_X)>>8)&0x0FF00) | (((INP_X)<<8)&0xFF0000) | ((INP_X)<<24))

/**
* change string to lowercase in the "simple" way keeping same length
*  @param[in,out] ap_p pointer to the string to convert
*  @param imp_len how many units (8/16/32-bit, depending on iep_cs) to process
*  @param iep_cs encoding used by ap_p
*  @return whether successful
*/
extern PTYPE BOOL m_to_lc_inplace( void *ap_p, int imp_len, enum ied_charset iep_cs ) {
   unsigned char* aucl_cur;
   unsigned char* aucl_end;
   HL_WCHAR*      awcl_cur;
   HL_WCHAR*      awcl_end;
   HL_WCHAR       wcl_tmp;
   unsigned int*  aunl_cur;
   unsigned int*  aunl_end;
   unsigned int   unl_tmp;
   switch(m_suppress_endian_info_if_native(iep_cs)) {
     case ied_chs_utf_8:                    /* Unicode UTF-8           */
     case ied_chs_html_1:                   /* HTML character set      */
     CASE_IED_CHS_ESCHEXHEX_U8              /* masked-hexpair encoded  */
     case ied_chs_idna_1:                   /* IDNA RFC 3490           */
       /* here we cannot make sure that the length in bytes stays same */
       return FALSE;
     case ied_chs_ansi_819:                 /* ANSI 819                */
       aucl_cur = (unsigned char*)ap_p;
       aucl_end = aucl_cur + imp_len;
       while (aucl_cur<aucl_end) {
         if (65<=*aucl_cur && *aucl_cur<=90)
           *aucl_cur += 32;  /* LATIN ... LETTER A to LATIN ... LETTER Z */
         else if (192<=*aucl_cur && *aucl_cur<=214)
           *aucl_cur += 32;  /* LATIN ... LETTER A WITH GRAVE to LATIN ... LETTER O WITH DIAERESIS */
         else if (216<=*aucl_cur && *aucl_cur<=222)
           *aucl_cur += 32;  /* LATIN ... LETTER O WITH STROKE to LATIN ... LETTER THORN (Icelandic) */
         aucl_cur++;
       }
       break;
     case ied_chs_ascii_850:                /* ASCII 850               */
       aucl_cur = (unsigned char*)ap_p;
       aucl_end = aucl_cur + imp_len;
       while (aucl_cur<aucl_end) {
         if (65<=*aucl_cur && *aucl_cur<=90)
           *aucl_cur += 32;  /* LATIN ... LETTER A to LATIN ... LETTER Z */
         else if (210<=*aucl_cur && *aucl_cur<=212)
           *aucl_cur -= 74;  /* LATIN ... LETTER E WITH CIRCUMFLEX to LATIN ... LETTER E WITH GRAVE */
         else if (234<=*aucl_cur && *aucl_cur<=235)
           *aucl_cur -= 84;  /* LATIN ... LETTER U WITH CIRCUMFLEX to LATIN ... LETTER U WITH GRAVE */
         else switch (*aucl_cur) {
           case 128: *aucl_cur=135; break;  /* LATIN ... LETTER C WITH CEDILLA */
           case 142: *aucl_cur=132; break;  /* LATIN ... LETTER A WITH DIAERESIS */
           case 143: *aucl_cur=134; break;  /* LATIN ... LETTER A WITH RING ABOVE */
           case 144: *aucl_cur=130; break;  /* LATIN ... LETTER E WITH ACUTE */
           case 146: *aucl_cur=145; break;  /* LATIN ... LIGATURE AE */
           case 153: *aucl_cur=148; break;  /* LATIN ... LETTER O WITH DIAERESIS */
           case 154: *aucl_cur=129; break;  /* LATIN ... LETTER U WITH DIAERESIS */
           case 157: *aucl_cur=155; break;  /* LATIN ... LETTER O WITH STROKE */
           case 165: *aucl_cur=164; break;  /* LATIN ... LETTER N WITH TILDE */
           case 181: *aucl_cur=160; break;  /* LATIN ... LETTER A WITH ACUTE */
           case 182: *aucl_cur=131; break;  /* LATIN ... LETTER A WITH CIRCUMFLEX */
           case 183: *aucl_cur=133; break;  /* LATIN ... LETTER A WITH GRAVE */
           case 199: *aucl_cur=198; break;  /* LATIN ... LETTER A WITH TILDE */
           case 209: *aucl_cur=208; break;  /* LATIN ... LETTER ETH */
           case 214: *aucl_cur=161; break;  /* LATIN ... LETTER I WITH ACUTE */
           case 215: *aucl_cur=140; break;  /* LATIN ... LETTER I WITH CIRCUMFLEX */
           case 216: *aucl_cur=139; break;  /* LATIN ... LETTER I WITH DIAERESIS */
           case 222: *aucl_cur=141; break;  /* LATIN ... LETTER I WITH GRAVE */
           case 224: *aucl_cur=162; break;  /* LATIN ... LETTER O WITH ACUTE */
           case 226: *aucl_cur=147; break;  /* LATIN ... LETTER O WITH CIRCUMFLEX */
           case 227: *aucl_cur=149; break;  /* LATIN ... LETTER O WITH GRAVE */
           case 229: *aucl_cur=228; break;  /* LATIN ... LETTER O WITH TILDE */
           case 232: *aucl_cur=231; break;  /* LATIN ... LETTER THORN */
           case 233: *aucl_cur=163; break;  /* LATIN ... LETTER U WITH ACUTE */
           case 237: *aucl_cur=236; break;  /* LATIN ... LETTER Y WITH ACUTE */
         }
         aucl_cur++;
       }
       break;
     case ied_chs_oem_437:                  /* DOS-Codepage 437        */
       aucl_cur = (unsigned char*)ap_p;
       aucl_end = aucl_cur + imp_len;
       while (aucl_cur<aucl_end) {
         if (65<=*aucl_cur && *aucl_cur<=90)
           *aucl_cur += 32;  /* LATIN ... LETTER A to LATIN ... LETTER Z */
         else switch (*aucl_cur) {
           case 128: *aucl_cur=135; break;  /* LATIN ... LETTER C WITH CEDILLA */
           case 142: *aucl_cur=132; break;  /* LATIN ... LETTER A WITH DIAERESIS */
           case 143: *aucl_cur=134; break;  /* LATIN ... LETTER A WITH RING ABOVE */
           case 144: *aucl_cur=130; break;  /* LATIN ... LETTER E WITH ACUTE */
           case 146: *aucl_cur=145; break;  /* LATIN ... LIGATURE AE */
           case 153: *aucl_cur=148; break;  /* LATIN ... LETTER O WITH DIAERESIS */
           case 154: *aucl_cur=129; break;  /* LATIN ... LETTER U WITH DIAERESIS */
           case 165: *aucl_cur=164; break;  /* LATIN ... LETTER N WITH TILDE */
           case 228: *aucl_cur=229; break;  /* GREEK ... LETTER SIGMA */
           case 232: *aucl_cur=237; break;  /* GREEK ... LETTER PHI */
         }
         aucl_cur++;
       }
       break;
     case ied_chs_wcp_1250:                 /* Windows-Codepage 1250 (Central European) */
       aucl_cur = (unsigned char*)ap_p;
       aucl_end = aucl_cur + imp_len;
       while (aucl_cur<aucl_end) {
         if (65<=*aucl_cur && *aucl_cur<=90)
           *aucl_cur += 32;  /* LATIN ... LETTER A to LATIN ... LETTER Z */
         else switch (*aucl_cur) {
           case 138: *aucl_cur=154; break;  /* LATIN ... LETTER S WITH CARON (... HACEK) */
           case 140: *aucl_cur=156; break;  /* LATIN ... LETTER S WITH ACUTE */
           case 141: *aucl_cur=157; break;  /* LATIN ... LETTER T WITH CARON (... HACEK) */
           case 142: *aucl_cur=158; break;  /* LATIN ... LETTER Z WITH CARON (... HACEK) */
           case 143: *aucl_cur=159; break;  /* LATIN ... LETTER Z WITH ACUTE */
           case 163: *aucl_cur=179; break;  /* LATIN ... LETTER L WITH STROKE (... SLASH) */
           case 165: *aucl_cur=185; break;  /* LATIN ... LETTER A WITH OGONEK */
           case 170: *aucl_cur=186; break;  /* LATIN ... LETTER S WITH CEDILLA */
           case 175: *aucl_cur=191; break;  /* LATIN ... LETTER Z WITH DOT ABOVE */
           case 188: *aucl_cur=190; break;  /* LATIN ... LETTER L WITH CARON (... HACEK) */
           case 215: break;
           default:
             if (192<=*aucl_cur && *aucl_cur<=222)
               *aucl_cur += 32;
             break;
         }
         aucl_cur++;
       }
       break;
     case ied_chs_wcp_1251:                 /* Windows-Codepage 1251 (Cyrillic) */
       aucl_cur = (unsigned char*)ap_p;
       aucl_end = aucl_cur + imp_len;
       while (aucl_cur<aucl_end) {
         if (65<=*aucl_cur && *aucl_cur<=90)
           *aucl_cur += 32;  /* LATIN ... LETTER A to LATIN ... LETTER Z */
         else switch (*aucl_cur) {
           case 128: *aucl_cur=144; break;  /* CYRILLIC ... LETTER DJE */
           case 129: *aucl_cur=131; break;  /* CYRILLIC ... LETTER GJE */
           case 138: *aucl_cur=154; break;  /* CYRILLIC ... LETTER LJE */
           case 140: *aucl_cur=156; break;  /* CYRILLIC ... LETTER NJE */
           case 141: *aucl_cur=157; break;  /* CYRILLIC ... LETTER KJE */
           case 142: *aucl_cur=158; break;  /* CYRILLIC ... LETTER TSHE */
           case 143: *aucl_cur=159; break;  /* CYRILLIC ... LETTER DZHE */
           case 161: *aucl_cur=162; break;  /* CYRILLIC ... LETTER SHORT U */
           case 163: *aucl_cur=188; break;  /* CYRILLIC ... LETTER JE */
           case 165: *aucl_cur=180; break;  /* CYRILLIC ... LETTER GHE WITH UPTURN (... GE WITH UPTURN) */
           case 168: *aucl_cur=184; break;  /* CYRILLIC ... LETTER IO */
           case 170: *aucl_cur=186; break;  /* CYRILLIC ... LETTER UKRAINIAN IE (... E) */
           case 175: *aucl_cur=191; break;  /* CYRILLIC ... LETTER YI */
           case 178: *aucl_cur=179; break;  /* CYRILLIC ... LETTER BYELORUSSIAN-UKRAINIAN I (... I) */
           case 189: *aucl_cur=190; break;  /* CYRILLIC ... LETTER DZE */
           default:
             if (192<=*aucl_cur && *aucl_cur<=223)
               *aucl_cur += 32;
             break;
         }
         aucl_cur++;
       }
       break;
     case ied_chs_wcp_1252:                 /* Windows-Codepage 1252 (Western European) */
       aucl_cur = (unsigned char*)ap_p;
       aucl_end = aucl_cur + imp_len;
       while (aucl_cur<aucl_end) {
         if (65<=*aucl_cur && *aucl_cur<=90)
           *aucl_cur += 32;  /* LATIN ... LETTER A to LATIN ... LETTER Z */
         else switch (*aucl_cur) {
           case 138: *aucl_cur=154; break;  /* LATIN ... LETTER S WITH CARON (... HACEK) */
           case 140: *aucl_cur=156; break;  /* LATIN ... LIGATURE OE */
           case 142: *aucl_cur=158; break;  /* LATIN ... LETTER Z WITH CARON (... HACEK) */
           case 159: *aucl_cur=255; break;  /* LATIN ... LETTER Y WITH DIAERESIS */
           case 215: break;
           default:
             if (192<=*aucl_cur && *aucl_cur<=222)
               *aucl_cur += 32;
             break;
         }
         aucl_cur++;
       }
       break;
     case ied_chs_wcp_1253:                 /* Windows-Codepage 1253 (Greek) */
       aucl_cur = (unsigned char*)ap_p;
       aucl_end = aucl_cur + imp_len;
       while (aucl_cur<aucl_end) {
         if (65<=*aucl_cur && *aucl_cur<=90)
           *aucl_cur += 32;  /* LATIN ... LETTER A to LATIN ... LETTER Z */
         else switch (*aucl_cur) {
           case 162: *aucl_cur=220; break;  /* GREEK ... LETTER ALPHA WITH TONOS */
           case 184: *aucl_cur=221; break;  /* GREEK ... LETTER EPSILON WITH TONOS */
           case 185: *aucl_cur=222; break;  /* GREEK ... LETTER ETA WITH TONOS */
           case 186: *aucl_cur=223; break;  /* GREEK ... LETTER IOTA WITH TONOS */
           case 188: *aucl_cur=252; break;  /* GREEK ... LETTER OMICRON WITH TONOS */
           case 190: *aucl_cur=253; break;  /* GREEK ... LETTER UPSILON WITH TONOS */
           case 191: *aucl_cur=254; break;  /* GREEK ... LETTER OMEGA WITH TONOS */
           case 210: break;
           default:
             if (193<=*aucl_cur && *aucl_cur<=219)
               *aucl_cur += 32;
             break;
         }
         aucl_cur++;
       }
       break;
     case ied_chs_wcp_1254:                 /* Windows-Codepage 1254 (Turkish) */
       aucl_cur = (unsigned char*)ap_p;
       aucl_end = aucl_cur + imp_len;
       while (aucl_cur<aucl_end) {
         switch (*aucl_cur) {
           case 73: *aucl_cur=253; break;  /* LATIN ... LETTER [DOTLESS] I (Category T in CaseFolding.txt from unicode.org) */
           case 138: *aucl_cur=154; break;  /* LATIN ... LETTER S WITH CARON (... HACEK) */
           case 140: *aucl_cur=156; break;  /* LATIN ... LIGATURE OE */
           case 159: *aucl_cur=255; break;  /* LATIN ... LETTER Y WITH DIAERESIS */
           case 215: break;
           case 221: *aucl_cur=105; break;  /* LATIN ... LETTER I [WITH DOT ABOVE] (Category T in CaseFolding.txt from unicode.org) */
           default:
             if (65<=*aucl_cur && *aucl_cur<=90)
               *aucl_cur += 32;  /* LATIN ... LETTER A to LATIN ... LETTER Z */
             else
             if (192<=*aucl_cur && *aucl_cur<=222)
               *aucl_cur += 32;
             break;
         }
         aucl_cur++;
       }
       break;
     case ied_chs_wcp_1255:                 /* Windows-Codepage 1255 (Hebrew) */
     case ied_chs_wcp_874:                  /* Windows-Codepage 874 (Thai) */
     case ied_chs_iso8859_6:                /* ISO 8859-6 (Arabic)     */
     case ied_chs_iso8859_8:                /* ISO 8859-8 (Hebrew)     */
     case ied_chs_iso8859_11:               /* ISO 8859-11 (Thai)      */
       aucl_cur = (unsigned char*)ap_p;
       aucl_end = aucl_cur + imp_len;
       while (aucl_cur<aucl_end) {
         if (65<=*aucl_cur && *aucl_cur<=90)
           *aucl_cur += 32;  /* LATIN ... LETTER A to LATIN ... LETTER Z */
         aucl_cur++;
       }
       break;
     case ied_chs_wcp_1256:                 /* Windows-Codepage 1256 (Arabic) */
       aucl_cur = (unsigned char*)ap_p;
       aucl_end = aucl_cur + imp_len;
       while (aucl_cur<aucl_end) {
         if (65<=*aucl_cur && *aucl_cur<=90)
           *aucl_cur += 32;  /* LATIN ... LETTER A to LATIN ... LETTER Z */
         else if (*aucl_cur==140) {
           *aucl_cur=156;    /* LATIN ... LIGATURE OE */
         }
         aucl_cur++;
       }
       break;
     case ied_chs_wcp_1257:                 /* Windows-Codepage 1257 (Baltic) */
       aucl_cur = (unsigned char*)ap_p;
       aucl_end = aucl_cur + imp_len;
       while (aucl_cur<aucl_end) {
         if (65<=*aucl_cur && *aucl_cur<=90)
           *aucl_cur += 32;  /* LATIN ... LETTER A to LATIN ... LETTER Z */
         else switch (*aucl_cur) {
           case 168: *aucl_cur=184; break;  /* LATIN ... LETTER O WITH STROKE (... SLASH) */
           case 170: *aucl_cur=186; break;  /* LATIN ... LETTER R WITH CEDILLA */
           case 175: *aucl_cur=191; break;  /* LATIN ... LETTER AE */
           case 215: break;
           default:
             if (192<=*aucl_cur && *aucl_cur<=222)
               *aucl_cur += 32;
             break;
         }
         aucl_cur++;
       }
       break;
     case ied_chs_wcp_1258:                 /* Windows-Codepage 1258 (Vietnamese) */
       aucl_cur = (unsigned char*)ap_p;
       aucl_end = aucl_cur + imp_len;
       while (aucl_cur<aucl_end) {
         if (65<=*aucl_cur && *aucl_cur<=90)
           *aucl_cur += 32;  /* LATIN ... LETTER A to LATIN ... LETTER Z */
         else switch (*aucl_cur) {
           case 140: *aucl_cur=156; break;  /* LATIN ... LIGATURE OE */
           case 159: *aucl_cur=255; break;  /* LATIN ... LETTER Y WITH DIAERESIS */
           case 204: break;
           case 210: break;
           case 215: break;
           default:
             if (192<=*aucl_cur && *aucl_cur<=221)
               *aucl_cur += 32;
             break;
         }
         aucl_cur++;
       }
       break;
     case ied_chs_iso8859_2:                /* ISO 8859-2 (Latin-2)    */
       aucl_cur = (unsigned char*)ap_p;
       aucl_end = aucl_cur + imp_len;
       while (aucl_cur<aucl_end) {
         if (65<=*aucl_cur && *aucl_cur<=90)
           *aucl_cur += 32;  /* LATIN ... LETTER A to LATIN ... LETTER Z */
         else if (169<=*aucl_cur && *aucl_cur<=172)
           *aucl_cur += 16;  /* LATIN ... LETTER S WITH CARON to LATIN ... LETTER Z WITH ACUTE */
         else if (165<=*aucl_cur && *aucl_cur<=166)
           *aucl_cur += 16;  /* LATIN ... LETTER L WITH CARON to LATIN ... LETTER S WITH ACUTE */
         else switch (*aucl_cur) {
           case 161: *aucl_cur=177; break;    /* LATIN ... LETTER A WITH OGONEK */
           case 163: *aucl_cur=179; break;    /* LATIN ... LETTER L WITH STROKE */
           case 174:                          /* LATIN ... LETTER Z WITH CARON */
           case 175: *aucl_cur += 16; break;  /* LATIN ... LETTER Z WITH DOT ABOVE */
           case 215: break;
           default: if (192<=*aucl_cur && *aucl_cur<=222)
             *aucl_cur += 32;  /* LATIN ... LETTER R WITH ACUTE ... LATIN ... LETTER T WITH CEDILLA */
             break;
         }
         aucl_cur++;
       }
       break;
     case ied_chs_iso8859_3:                /* ISO 8859-3 (Latin-3)    */
       aucl_cur = (unsigned char*)ap_p;
       aucl_end = aucl_cur + imp_len;
       while (aucl_cur<aucl_end) {
         if (65<=*aucl_cur && *aucl_cur<=90)
           *aucl_cur += 32;  /* LATIN ... LETTER A to LATIN ... LETTER Z */
         else if (196<=*aucl_cur && *aucl_cur<=207)
           *aucl_cur += 32;  /* LATIN ... LETTER A WITH DIAERESIS to LATIN ... LETTER I WITH DIAERESIS */
         else if (216<=*aucl_cur && *aucl_cur<=222)
           *aucl_cur += 32;  /* LATIN ... LETTER G WITH CIRCUMFLEX to LATIN ... LETTER S WITH CIRCUMFLEX */
         else if (209<=*aucl_cur && *aucl_cur<=214)
           *aucl_cur += 32;  /* LATIN ... LETTER N WITH TILDE to LATIN ... LETTER O WITH DIAERESIS */
         else if (192<=*aucl_cur && *aucl_cur<=194)
           *aucl_cur += 32;  /* LATIN ... LETTER A WITH GRAVE to LATIN ... LETTER A WITH CIRCUMFLEX */
         else switch (*aucl_cur) {
           case 161: *aucl_cur=177; break;  /* LATIN ... LETTER H WITH STROKE */
           case 166: *aucl_cur=182; break;  /* LATIN ... LETTER H WITH CIRCUMFLEX */
           case 175: *aucl_cur=191; break;  /* LATIN ... LETTER Z WITH DOT ABOVE */
           case 169: *aucl_cur=105; break;  /* capital I with dot to 'i' (here like Category T) */
           default: if (170<=*aucl_cur && *aucl_cur<=172)
             *aucl_cur += 16;  /* LATIN ... LETTER S WITH CEDILLA to LATIN ... LETTER J WITH CIRCUMFLEX */
             break;
         }
         aucl_cur++;
       }
       break;
     case ied_chs_iso8859_4:                /* ISO 8859-4 (Latin-4)    */
       aucl_cur = (unsigned char*)ap_p;
       aucl_end = aucl_cur + imp_len;
       while (aucl_cur<aucl_end) {
         if (65<=*aucl_cur && *aucl_cur<=90)
           *aucl_cur += 32;  /* LATIN ... LETTER A to LATIN ... LETTER Z */
         else if (169<=*aucl_cur && *aucl_cur<=172)
           *aucl_cur += 16;  /* LATIN ... LETTER S WITH CARON to LATIN ... LETTER T WITH STROKE */
         else switch (*aucl_cur) {
           case 161: *aucl_cur=177; break;    /* LATIN ... LETTER A WITH OGONEK */
           case 163: *aucl_cur=179; break;    /* LATIN ... LETTER R WITH CEDILLA */
           case 174: *aucl_cur=190; break;    /* LATIN ... LETTER Z WITH CARON */
           case 189: *aucl_cur=191; break;    /* LATIN ... LETTER ENG */
           case 165:                          /* LATIN ... LETTER I WITH TILDE */
           case 166: *aucl_cur += 16; break;  /* LATIN ... LETTER L WITH CEDILLA */
           case 215: break;
           default: if (192<=*aucl_cur && *aucl_cur<=222)
             *aucl_cur += 32;  /* LATIN ... LETTER A WITH MACRON ... LATIN ... LETTER U WITH MACRON */
             break;
         }
         aucl_cur++;
       }
       break;
     case ied_chs_iso8859_5:                /* ISO 8859-5 (Cyrillic)   */
       aucl_cur = (unsigned char*)ap_p;
       aucl_end = aucl_cur + imp_len;
       while (aucl_cur<aucl_end) {
         if (176<=*aucl_cur && *aucl_cur<=207)
           *aucl_cur += 32;  /* CYRILLIC ... LETTER A to CYRILLIC ... LETTER YA */
         else if (65<=*aucl_cur && *aucl_cur<=90)
           *aucl_cur += 32;  /* LATIN ... LETTER A to LATIN ... LETTER Z */
         else if (161<=*aucl_cur && *aucl_cur<=175 && *aucl_cur!=173)
           *aucl_cur += 80;  /* CYRILLIC ... LETTER IO ... CYRILLIC ... LETTER DZHE */
         aucl_cur++;
       }
       break;
     case ied_chs_iso8859_7:                /* ISO 8859-7 (Greek)      */
       aucl_cur = (unsigned char*)ap_p;
       aucl_end = aucl_cur + imp_len;
       while (aucl_cur<aucl_end) {
         if (65<=*aucl_cur && *aucl_cur<=90)
           *aucl_cur += 32;  /* LATIN ... LETTER A to LATIN ... LETTER Z */
         else if (184<=*aucl_cur && *aucl_cur<=186)
           *aucl_cur += 37;  /* GREEK ... LETTER EPSILON WITH TONOS to GREEK ... LETTER IOTA WITH TONOS */
         else switch (*aucl_cur) {
           case 182: *aucl_cur=220; break;   /* GREEK ... LETTER ALPHA WITH TONOS */
           case 188: *aucl_cur=252; break;   /* GREEK ... LETTER OMICRON WITH TONOS */
           case 190:                         /* GREEK ... LETTER UPSILON WITH TONOS */
           case 191: *aucl_cur += 63; break; /* GREEK ... LETTER OMEGA WITH TONOS */
           case 210: break;
           default: if (193<=*aucl_cur && *aucl_cur<=219)
             *aucl_cur += 32;  /* GREEK ... LETTER ALPHA ... LETTER UPSILON WITH DIALYTIKA */
             break;
         }
         aucl_cur++;
       }
       break;
     case ied_chs_iso8859_9:                /* ISO 8859-9 (Latin-5)    */
       aucl_cur = (unsigned char*)ap_p;
       aucl_end = aucl_cur + imp_len;
       while (aucl_cur<aucl_end) {
         switch (*aucl_cur) {
           case 73: *aucl_cur=253; break;  /* LATIN ... LETTER [DOTLESS] I (Category T in CaseFolding.txt from unicode.org) */
           case 222: *aucl_cur=254; break;  /* LATIN ... LETTER S WITH CEDILLA */
           case 215: break;
           case 221: *aucl_cur=105; break;  /* LATIN ... LETTER I [WITH DOT ABOVE] (Category T in CaseFolding.txt from unicode.org) */
           default:
             if (192<=*aucl_cur && *aucl_cur<=220)
               *aucl_cur += 32;  /* LATIN ... LETTER A WITH GRAVE ... LATIN ... LETTER U WITH DIAERESIS */
             else
             if (65<=*aucl_cur && *aucl_cur<=90)
               *aucl_cur += 32;  /* LATIN ... LETTER A to LATIN ... LETTER Z */
         }
         aucl_cur++;
       }
       break;
     case ied_chs_iso8859_10:               /* ISO 8859-10 (Latin-6)   */
       aucl_cur = (unsigned char*)ap_p;
       aucl_end = aucl_cur + imp_len;
       while (aucl_cur<aucl_end) {
         if (192<=*aucl_cur && *aucl_cur<=222)
           *aucl_cur += 32;  /* LATIN ... LETTER A WITH MACRON to LATIN ... LETTER THORN (Icelandic) */
         else if (65<=*aucl_cur && *aucl_cur<=90)
           *aucl_cur += 32;  /* LATIN ... LETTER A to LATIN ... LETTER Z */
         else switch (*aucl_cur) {
           case 167: break;
           case 173: break;
           default: if (161<=*aucl_cur && *aucl_cur<=175)
             *aucl_cur += 16;  /* LATIN ... LETTER A WITH OGONEK ... LATIN ... LETTER ENG */
         }
         aucl_cur++;
       }
       break;
     case ied_chs_iso8859_13:               /* ISO 8859-13 (Latin-7)   */
       aucl_cur = (unsigned char*)ap_p;
       aucl_end = aucl_cur + imp_len;
       while (aucl_cur<aucl_end) {
         if (65<=*aucl_cur && *aucl_cur<=90)
           *aucl_cur += 32;  /* LATIN ... LETTER A to LATIN ... LETTER Z */
         else switch (*aucl_cur) {
           case 168: *aucl_cur=184; break;  /* LATIN ... LETTER O WITH STROKE */
           case 170: *aucl_cur=186; break;  /* LATIN ... LETTER R WITH CEDILLA */
           case 175: *aucl_cur=191; break;  /* LATIN ... LETTER AE */
           case 215: break;
           default: if (192<=*aucl_cur && *aucl_cur<=222)
             *aucl_cur += 32;  /* LATIN ... LETTER A WITH OGONEK ... LATIN ... LETTER Z WITH CARON */
             break;
         }
         aucl_cur++;
       }
       break;
     case ied_chs_iso8859_14:               /* ISO 8859-14 (Latin-8)   */
       aucl_cur = (unsigned char*)ap_p;
       aucl_end = aucl_cur + imp_len;
       while (aucl_cur<aucl_end) {
         if (192<=*aucl_cur && *aucl_cur<=222)
           *aucl_cur += 32;  /* LATIN ... LETTER A WITH GRAVE to LATIN ... LETTER Y WITH CIRCUMFLEX */
         else switch (*aucl_cur) {
           case 161: *aucl_cur=162; break;  /* LATIN ... LETTER B WITH DOT ABOVE */
           case 164: *aucl_cur=165; break;  /* LATIN ... LETTER C WITH DOT ABOVE */
           case 166: *aucl_cur=171; break;  /* LATIN ... LETTER D WITH DOT ABOVE */
           case 168: *aucl_cur=184; break;  /* LATIN ... LETTER W WITH GRAVE */
           case 170: *aucl_cur=186; break;  /* LATIN ... LETTER W WITH ACUTE */
           case 172: *aucl_cur=188; break;  /* LATIN ... LETTER Y WITH GRAVE */
           case 175: *aucl_cur=255; break;  /* LATIN ... LETTER Y WITH DIAERESIS */
           case 176: *aucl_cur=177; break;  /* LATIN ... LETTER F WITH DOT ABOVE */
           case 178: *aucl_cur=179; break;  /* LATIN ... LETTER G WITH DOT ABOVE */
           case 180: *aucl_cur=181; break;  /* LATIN ... LETTER M WITH DOT ABOVE */
           case 183: *aucl_cur=185; break;  /* LATIN ... LETTER P WITH DOT ABOVE */
           case 187: *aucl_cur=191; break;  /* LATIN ... LETTER S WITH DOT ABOVE */
           case 189: *aucl_cur=190; break;  /* LATIN ... LETTER W WITH DIAERESIS */
           default: if (65<=*aucl_cur && *aucl_cur<=90)
             *aucl_cur += 32;  /* LATIN ... LETTER A to LATIN ... LETTER Z */
             break;
         }
         aucl_cur++;
       }
       break;
     case ied_chs_iso8859_15:               /* ISO 8859-15 (Latin-9)   */
       aucl_cur = (unsigned char*)ap_p;
       aucl_end = aucl_cur + imp_len;
       while (aucl_cur<aucl_end) {
         if (65<=*aucl_cur && *aucl_cur<=90)
           *aucl_cur += 32;  /* LATIN ... LETTER A to LATIN ... LETTER Z */
         else switch (*aucl_cur) {
           case 166: *aucl_cur=168; break;  /* LATIN ... LETTER S WITH CARON */
           case 180: *aucl_cur=184; break;  /* LATIN ... LETTER Z WITH CARON */
           case 188: *aucl_cur=189; break;  /* LATIN ... LIGATURE OE */
           case 190: *aucl_cur=255; break;  /* LATIN ... LETTER Y WITH DIAERESIS */
           case 215: break;
           default: if (192<=*aucl_cur && *aucl_cur<=222)
             *aucl_cur += 32;  /* LATIN ... LETTER A WITH GRAVE ... LATIN ... LETTER THORN */
             break;
         }
         aucl_cur++;
       }
       break;
     case ied_chs_iso8859_16:               /* ISO 8859-16 (Latin-10)  */
       aucl_cur = (unsigned char*)ap_p;
       aucl_end = aucl_cur + imp_len;
       while (aucl_cur<aucl_end) {
         if (192<=*aucl_cur && *aucl_cur<=222)
           *aucl_cur += 32;  /* LATIN ... LETTER A WITH GRAVE to LATIN ... LETTER T WITH COMMA BELOW */
         else switch (*aucl_cur) {
           case 161: *aucl_cur=162; break;  /* LATIN ... LETTER A WITH OGONEK */
           case 163: *aucl_cur=179; break;  /* LATIN ... LETTER L WITH STROKE */
           case 166: *aucl_cur=168; break;  /* LATIN ... LETTER S WITH CARON */
           case 170: *aucl_cur=186; break;  /* LATIN ... LETTER S WITH COMMA BELOW */
           case 172: *aucl_cur=174; break;  /* LATIN ... LETTER Z WITH ACUTE */
           case 175: *aucl_cur=191; break;  /* LATIN ... LETTER Z WITH DOT ABOVE */
           case 178: *aucl_cur=185; break;  /* LATIN ... LETTER C WITH CARON */
           case 180: *aucl_cur=184; break;  /* LATIN ... LETTER Z WITH CARON */
           case 188: *aucl_cur=189; break;  /* LATIN ... LIGATURE OE */
           case 190: *aucl_cur=255; break;  /* LATIN ... LETTER Y WITH DIAERESIS */
           default: if (65<=*aucl_cur && *aucl_cur<=90)
             *aucl_cur += 32;  /* LATIN ... LETTER A to LATIN ... LETTER Z */
             break;
         }
         aucl_cur++;
       }
       break;
     case ied_chs_wcp_932:                  /* Windows-Codepage 932 (MBCS, Japanese) */
       aucl_cur = (unsigned char*)ap_p;
       aucl_end = aucl_cur + imp_len;
       m_get_tab_mb_firstbytes(ied_chs_wcp_932);
       while (aucl_cur<aucl_end) {
         if (awcg_tab_932_leadbyte[*aucl_cur]!=0xFFFF) {
           if (0x0041<=*aucl_cur && *aucl_cur<=0x005A)
             *aucl_cur+=32;
         } else {
           if (aucl_cur+1 == aucl_end) return FALSE;
           switch (*aucl_cur++) {
             case 0x82:
               if (0x60<=*aucl_cur && *aucl_cur<=0x79)
                 *aucl_cur+=33;
               break;
             case 0x83:
               if (0x9F<=*aucl_cur && *aucl_cur<=0xB6)
                 *aucl_cur+=32;
               break;
             case 0x84:
               if (0x40<=*aucl_cur && *aucl_cur<=0x60)
                 *aucl_cur += (*aucl_cur<0x4F)?48:49;
               break;
             case 0x87:
               if (0x54<=*aucl_cur && *aucl_cur<=0x5D) {
                 *(aucl_cur-1)=0xFA;
                 *aucl_cur-=0x14;
               }
               break;
             case 0xFA:
               if (0x4A<=*aucl_cur && *aucl_cur<=0x53)
                 *aucl_cur-=10;
               break;
           }
         }
         aucl_cur++;
       }
       break;
     case ied_chs_wcp_936:                  /* Windows-Codepage 936 (MBCS, Mainland Chinese) */
       aucl_cur = (unsigned char*)ap_p;
       aucl_end = aucl_cur + imp_len;
       m_get_tab_mb_firstbytes(ied_chs_wcp_936);
       while (aucl_cur<aucl_end) {
         if (awcg_tab_936_leadbyte[*aucl_cur]!=0xFFFF) {
           if (0x0041<=*aucl_cur && *aucl_cur<=0x005A)
             *aucl_cur+=32;
         } else {
           if (aucl_cur+1 == aucl_end) return FALSE;
           switch (*aucl_cur++) {
             case 0xA2:
               if (0xF1<=*aucl_cur && *aucl_cur<=0xFA)
                 *aucl_cur-=80;
               break;
             case 0xA3:
               if (0xC1<=*aucl_cur && *aucl_cur<=0xDA)
                 *aucl_cur+=32;
               break;
             case 0xA6:
               if (0xA1<=*aucl_cur && *aucl_cur<=0xB8)
                 *aucl_cur+=32;
               break;
             case 0xA7:
               if (0xA1<=*aucl_cur && *aucl_cur<=0xC1)
                 *aucl_cur+=48;
               break;
           default: break;
           }
         }
         aucl_cur++;
       }
       break;
     case ied_chs_wcp_949:                  /* Windows-Codepage 949 (MBCS, Korean) */
       aucl_cur = (unsigned char*)ap_p;
       aucl_end = aucl_cur + imp_len;
       m_get_tab_mb_firstbytes(ied_chs_wcp_949);
       while (aucl_cur<aucl_end) {
         if (awcg_tab_949_leadbyte[*aucl_cur]!=0xFFFF) {
           if (0x0041<=*aucl_cur && *aucl_cur<=0x005A)
             *aucl_cur+=32;
         } else {
           if (aucl_cur+1 == aucl_end) return FALSE;
           switch (*aucl_cur++) {
             case 0xA3:
               if (0xC1<=*aucl_cur && *aucl_cur<=0xDA)
                 *aucl_cur+=32;
               break;
             case 0xA5:
               if (0xB0<=*aucl_cur && *aucl_cur<=0xB9)
                 *aucl_cur-=15;
               else if (0xC1<=*aucl_cur && *aucl_cur<=0xD8)
                 *aucl_cur+=32;
               break;
             case 0xA8:
               if (0xA8<=*aucl_cur && *aucl_cur<=0xAF && *aucl_cur!=0xAC) {
                 aucl_cur[-1]++;
               } else switch (*aucl_cur) {
                   case 0xA1:
                   case 0xA4:
                   case 0xA6: aucl_cur[-1]++; break;
                   case 0xA2: aucl_cur[-1]++; (*aucl_cur)++; break;
               }
               break;
             case 0xAC:
               if (0xA1<=*aucl_cur && *aucl_cur<=0xC1)
                 *aucl_cur+=48;
               break;
             case 0xA7:
               if (*aucl_cur==0xD9) {
                 *(aucl_cur-1)=0xA5;
                 *aucl_cur=0xF8;
               }
               break;
           default: break;
           }
         }
         aucl_cur++;
       }
       break;
     case ied_chs_wcp_950:                  /* Windows-Codepage 950 (MBCS, Taiwan Chinese) */
       aucl_cur = (unsigned char*)ap_p;
       aucl_end = aucl_cur + imp_len;
       m_get_tab_mb_firstbytes(ied_chs_wcp_950);
       while (aucl_cur<aucl_end) {
         if (awcg_tab_950_leadbyte[*aucl_cur]!=0xFFFF) {
           if (0x0041<=*aucl_cur && *aucl_cur<=0x005A)
             *aucl_cur+=32;
         } else {
           if (aucl_cur+1 == aucl_end) return FALSE;
           switch (*aucl_cur++) {
             case 0xA2:
               if (0xCF<=*aucl_cur && *aucl_cur<=0xE4) {
                 *aucl_cur+=26;
               } else if (0xE5<=*aucl_cur && *aucl_cur<=0xE8) {
                 aucl_cur[-1]++;
                 *aucl_cur-=165;
               }
               break;
             case 0xA3:
               if (0x44<=*aucl_cur && *aucl_cur<=0x5B)
                 *aucl_cur+=24;
               break;
             default: break;
           }
         }
         aucl_cur++;
       }
       break;
     case ied_chs_utf_16:                   /* Unicode UTF-16          */
       awcl_cur = (HL_WCHAR*)ap_p;
       awcl_end = awcl_cur + imp_len;
       while (awcl_cur<awcl_end) {
         if ((*awcl_cur&0xF800)==0xD800) {  /* surrogate (high or low) */
           if ((*awcl_cur==0xD801) && (awcl_cur+1<awcl_end)) {
             awcl_cur++;
             if ((*awcl_cur^0xDC00)<0x28)
               *awcl_cur+=40;               /* DESERET ... LETTER ...  */
           }
         } else {                           /* regular case = WCHAR    */
           *awcl_cur = m_trans_to_lc(*awcl_cur);
         }
         awcl_cur++;
       }
       break;
     case ied_chs_be_utf_16:                /* Unicode UTF-16 big (non-native) endian */
     case ied_chs_le_utf_16:                /* Unicode UTF-16 little (non-native) endian */
       awcl_cur = (HL_WCHAR*)ap_p;
       awcl_end = awcl_cur + imp_len;
       while (awcl_cur<awcl_end) {
         if ((*awcl_cur&0x00F8)==0x00D8) {  /* surrogate (high or low) */
           if ((*awcl_cur==0x01D8) && (awcl_cur+1<awcl_end)) {
             awcl_cur++;
             if (((*awcl_cur&0x00FF)==0x00DC) && ((*awcl_cur&0xFF00)<0x2800))
               *awcl_cur+=0x2800;           /* DESERET ... LETTER ...  */
           }
         } else {                           /* regular case            */
           wcl_tmp = ((*awcl_cur<<8)&0xFF00) | (*awcl_cur>>8);
           wcl_tmp = m_trans_to_lc(wcl_tmp);
           *awcl_cur = ((wcl_tmp<<8)&0xFF00) | (wcl_tmp>>8);
         }
         awcl_cur++;
       }
       break;
     case ied_chs_utf_32:                   /* Unicode UTF-32          */
       aunl_cur = (unsigned int*)ap_p;
       aunl_end = aunl_cur + imp_len;
       while (aunl_cur<aunl_end) {
         m_tolowercase_inplace_u32c(aunl_cur);
         aunl_cur++;
       }
       break;
     case ied_chs_be_utf_32:                /* Unicode UTF-32 big (non-native) endian */
     case ied_chs_le_utf_32:                /* Unicode UTF-32 little (non-native) endian */
       aunl_cur = (unsigned int*)ap_p;
       aunl_end = aunl_cur + imp_len;
       while (aunl_cur<aunl_end) {
         unl_tmp = HL_ENDIANSWAP32(*aunl_cur);
         m_tolowercase_inplace_u32c(&unl_tmp);
         *aunl_cur = HL_ENDIANSWAP32(unl_tmp);
         aunl_cur++;
       }
       break;
     default:
       return FALSE;
   }
   return TRUE;
} /* end m_to_lc_inplace()                                             */

/**
* change string to uppercase in the "simple" way keeping same length
*  @param[in,out] ap_p pointer to the string to convert
*  @param imp_len how many units (8/16/32-bit, depending on iep_cs) to process
*  @param iep_cs encoding used by ap_p
*  @return whether successful
*/
extern PTYPE BOOL m_to_uc_inplace( void *ap_p, int imp_len, enum ied_charset iep_cs ) {
   unsigned char* aucl_cur;
   unsigned char* aucl_end;
   HL_WCHAR*      awcl_cur;
   HL_WCHAR*      awcl_end;
   HL_WCHAR       wcl_tmp;
   unsigned int*  aunl_cur;
   unsigned int*  aunl_end;
   unsigned int   unl_tmp;
   switch(m_suppress_endian_info_if_native(iep_cs)) {
     case ied_chs_utf_8:                    /* Unicode UTF-8           */
     case ied_chs_html_1:                   /* HTML character set      */
     CASE_IED_CHS_ESCHEXHEX_U8              /* masked-hexpair encoded  */
     case ied_chs_idna_1:                   /* IDNA RFC 3490           */
       /* here we cannot make sure that the length in bytes stays same */
       return FALSE;
     case ied_chs_ansi_819:                 /* ANSI 819                */
       aucl_cur = (unsigned char*)ap_p;
       aucl_end = aucl_cur + imp_len;
       while (aucl_cur<aucl_end) {
         if (97<=*aucl_cur && *aucl_cur<=122)
           *aucl_cur-=32;  /* LATIN ... LETTER A to LATIN ... LETTER Z */
         else if (224<=*aucl_cur && *aucl_cur<=246)
           *aucl_cur-=32;  /* LATIN ... LETTER A WITH GRAVE to LATIN ... LETTER O WITH DIAERESIS */
         else if (248<=*aucl_cur && *aucl_cur<=254)
           *aucl_cur-=32;  /* LATIN ... LETTER O WITH STROKE to LATIN ... LETTER THORN (Icelandic) */
         aucl_cur++;
       }
       break;
     case ied_chs_ascii_850:                /* ASCII 850               */
       aucl_cur = (unsigned char*)ap_p;
       aucl_end = aucl_cur + imp_len;
       while (aucl_cur<aucl_end) {
         if (97<=*aucl_cur && *aucl_cur<=122)
           *aucl_cur-=32;  /* LATIN ... LETTER A to LATIN ... LETTER Z */
         else if (136<=*aucl_cur && *aucl_cur<=138)
           *aucl_cur+=74;  /* LATIN ... LETTER E WITH CIRCUMFLEX to LATIN ... LETTER E WITH GRAVE */
         else if (150<=*aucl_cur && *aucl_cur<=151)
           *aucl_cur+=84;  /* LATIN ... LETTER U WITH CIRCUMFLEX to LATIN ... LETTER U WITH GRAVE */
         else switch (*aucl_cur) {
           case 129: *aucl_cur=154; break;  /* LATIN ... LETTER U WITH DIAERESIS */
           case 130: *aucl_cur=144; break;  /* LATIN ... LETTER E WITH ACUTE */
           case 131: *aucl_cur=182; break;  /* LATIN ... LETTER A WITH CIRCUMFLEX */
           case 132: *aucl_cur=142; break;  /* LATIN ... LETTER A WITH DIAERESIS */
           case 133: *aucl_cur=183; break;  /* LATIN ... LETTER A WITH GRAVE */
           case 134: *aucl_cur=143; break;  /* LATIN ... LETTER A WITH RING ABOVE */
           case 135: *aucl_cur=128; break;  /* LATIN ... LETTER C WITH CEDILLA */
           case 139: *aucl_cur=216; break;  /* LATIN ... LETTER I WITH DIAERESIS */
           case 140: *aucl_cur=215; break;  /* LATIN ... LETTER I WITH CIRCUMFLEX */
           case 141: *aucl_cur=222; break;  /* LATIN ... LETTER I WITH GRAVE */
           case 145: *aucl_cur=146; break;  /* LATIN ... LIGATURE AE */
           case 147: *aucl_cur=226; break;  /* LATIN ... LETTER O WITH CIRCUMFLEX */
           case 148: *aucl_cur=153; break;  /* LATIN ... LETTER O WITH DIAERESIS */
           case 149: *aucl_cur=227; break;  /* LATIN ... LETTER O WITH GRAVE */
           case 155: *aucl_cur=157; break;  /* LATIN ... LETTER O WITH STROKE */
           case 160: *aucl_cur=181; break;  /* LATIN ... LETTER A WITH ACUTE */
           case 161: *aucl_cur=214; break;  /* LATIN ... LETTER I WITH ACUTE */
           case 162: *aucl_cur=224; break;  /* LATIN ... LETTER O WITH ACUTE */
           case 163: *aucl_cur=233; break;  /* LATIN ... LETTER U WITH ACUTE */
           case 164: *aucl_cur=165; break;  /* LATIN ... LETTER N WITH TILDE */
           case 198: *aucl_cur=199; break;  /* LATIN ... LETTER A WITH TILDE */
           case 208: *aucl_cur=209; break;  /* LATIN ... LETTER ETH */
           case 228: *aucl_cur=229; break;  /* LATIN ... LETTER O WITH TILDE */
           case 231: *aucl_cur=232; break;  /* LATIN ... LETTER THORN */
           case 236: *aucl_cur=237; break;  /* LATIN ... LETTER Y WITH ACUTE */
         }
         aucl_cur++;
       }
       break;
     case ied_chs_oem_437:                  /* DOS-Codepage 437        */
       aucl_cur = (unsigned char*)ap_p;
       aucl_end = aucl_cur + imp_len;
       while (aucl_cur<aucl_end) {
         if (97<=*aucl_cur && *aucl_cur<=122)
           *aucl_cur-=32;  /* LATIN ... LETTER A to LATIN ... LETTER Z */
         else switch (*aucl_cur) {
           case 129: *aucl_cur=154; break;  /* LATIN ... LETTER U WITH DIAERESIS */
           case 130: *aucl_cur=144; break;  /* LATIN ... LETTER E WITH ACUTE */
           case 132: *aucl_cur=142; break;  /* LATIN ... LETTER A WITH DIAERESIS */
           case 134: *aucl_cur=143; break;  /* LATIN ... LETTER A WITH RING ABOVE */
           case 135: *aucl_cur=128; break;  /* LATIN ... LETTER C WITH CEDILLA */
           case 145: *aucl_cur=146; break;  /* LATIN ... LIGATURE AE */
           case 148: *aucl_cur=153; break;  /* LATIN ... LETTER O WITH DIAERESIS */
           case 164: *aucl_cur=165; break;  /* LATIN ... LETTER N WITH TILDE */
           case 229: *aucl_cur=228; break;  /* GREEK ... LETTER SIGMA */
           case 237: *aucl_cur=232; break;  /* GREEK ... LETTER PHI */
         }
         aucl_cur++;
       }
       break;
     case ied_chs_wcp_1250:                 /* Windows-Codepage 1250 (Central European) */
       aucl_cur = (unsigned char*)ap_p;
       aucl_end = aucl_cur + imp_len;
       while (aucl_cur<aucl_end) {
         if (97<=*aucl_cur && *aucl_cur<=122)
           *aucl_cur-=32;  /* LATIN ... LETTER A to LATIN ... LETTER Z */
         else switch (*aucl_cur) {
           case 154: *aucl_cur=138; break;  /* LATIN ... LETTER S WITH CARON (... HACEK) */
           case 156: *aucl_cur=140; break;  /* LATIN ... LETTER S WITH ACUTE */
           case 157: *aucl_cur=141; break;  /* LATIN ... LETTER T WITH CARON (... HACEK) */
           case 158: *aucl_cur=142; break;  /* LATIN ... LETTER Z WITH CARON (... HACEK) */
           case 159: *aucl_cur=143; break;  /* LATIN ... LETTER Z WITH ACUTE */
           case 179: *aucl_cur=163; break;  /* LATIN ... LETTER L WITH STROKE (... SLASH) */
           case 185: *aucl_cur=165; break;  /* LATIN ... LETTER A WITH OGONEK */
           case 186: *aucl_cur=170; break;  /* LATIN ... LETTER S WITH CEDILLA */
           case 190: *aucl_cur=188; break;  /* LATIN ... LETTER L WITH CARON (... HACEK) */
           case 191: *aucl_cur=175; break;  /* LATIN ... LETTER Z WITH DOT ABOVE (... Z DOT) */
           case 247: break;
           default:
             if (224<=*aucl_cur && *aucl_cur<=254)
               *aucl_cur -= 32;  /* LATIN ... LETTER R WITH ACUTE to LATIN ... LETTER T WITH CEDILLA */
             break;
         }
         aucl_cur++;
       }
       break;
     case ied_chs_wcp_1251:                 /* Windows-Codepage 1251 (Cyrillic) */
       aucl_cur = (unsigned char*)ap_p;
       aucl_end = aucl_cur + imp_len;
       while (aucl_cur<aucl_end) {
         if (97<=*aucl_cur && *aucl_cur<=122)
           *aucl_cur-=32;  /* LATIN ... LETTER A to LATIN ... LETTER Z */
         else switch (*aucl_cur) {
           case 131: *aucl_cur=129; break;  /* CYRILLIC ... LETTER GJE */
           case 144: *aucl_cur=128; break;  /* CYRILLIC ... LETTER DJE */
           case 154: *aucl_cur=138; break;  /* CYRILLIC ... LETTER LJE */
           case 156: *aucl_cur=140; break;  /* CYRILLIC ... LETTER NJE */
           case 157: *aucl_cur=141; break;  /* CYRILLIC ... LETTER KJE */
           case 158: *aucl_cur=142; break;  /* CYRILLIC ... LETTER TSHE */
           case 159: *aucl_cur=143; break;  /* CYRILLIC ... LETTER DZHE */
           case 162: *aucl_cur=161; break;  /* CYRILLIC ... LETTER SHORT U */
           case 179: *aucl_cur=178; break;  /* CYRILLIC ... LETTER BYELORUSSIAN-UKRAINIAN I (... I) */
           case 180: *aucl_cur=165; break;  /* CYRILLIC ... LETTER GHE WITH UPTURN (... GE WITH UPTURN) */
           case 184: *aucl_cur=168; break;  /* CYRILLIC ... LETTER IO */
           case 186: *aucl_cur=170; break;  /* CYRILLIC ... LETTER UKRAINIAN IE (... E) */
           case 188: *aucl_cur=163; break;  /* CYRILLIC ... LETTER JE */
           case 190: *aucl_cur=189; break;  /* CYRILLIC ... LETTER DZE */
           case 191: *aucl_cur=175; break;  /* CYRILLIC ... LETTER YI */
           default:
             if (224<=*aucl_cur/* && *aucl_cur<=255*/)
               *aucl_cur -= 32;  /* CYRILLIC ... LETTER A to CYRILLIC ... LETTER YA (... IA) */
             break;
         }
         aucl_cur++;
       }
       break;
     case ied_chs_wcp_1252:                 /* Windows-Codepage 1252 (Western European) */
       aucl_cur = (unsigned char*)ap_p;
       aucl_end = aucl_cur + imp_len;
       while (aucl_cur<aucl_end) {
         if (97<=*aucl_cur && *aucl_cur<=122)
           *aucl_cur-=32;  /* LATIN ... LETTER A to LATIN ... LETTER Z */
         else switch (*aucl_cur) {
           case 154: *aucl_cur=138; break;  /* LATIN ... LETTER S WITH CARON (... S HACEK) */
           case 156: *aucl_cur=140; break;  /* LATIN ... LIGATURE OE */
           case 158: *aucl_cur=142; break;  /* LATIN ... LETTER Z WITH CARON (... Z HACEK) */
           case 247: break;
           case 255: *aucl_cur=159; break;  /* LATIN ... LETTER Y WITH DIAERESIS */
           default:
             if (224<=*aucl_cur && *aucl_cur<=254)
               *aucl_cur -= 32;  /* LATIN ... LETTER A WITH GRAVE to LATIN ... LETTER THORN */
             break;
         }
         aucl_cur++;
       }
       break;
     case ied_chs_wcp_1253:                 /* Windows-Codepage 1253 (Greek) */
       aucl_cur = (unsigned char*)ap_p;
       aucl_end = aucl_cur + imp_len;
       while (aucl_cur<aucl_end) {
         if (97<=*aucl_cur && *aucl_cur<=122)
           *aucl_cur-=32;  /* LATIN ... LETTER A to LATIN ... LETTER Z */
         else switch (*aucl_cur) {
           case 181: *aucl_cur=204; break;  /* MICRO SIGN (also to capital My) */
           case 220: *aucl_cur=162; break;  /* GREEK ... LETTER ALPHA WITH TONOS */
           case 221: *aucl_cur=184; break;  /* GREEK ... LETTER EPSILON WITH TONOS */
           case 222: *aucl_cur=185; break;  /* GREEK ... LETTER ETA WITH TONOS */
           case 223: *aucl_cur=186; break;  /* GREEK ... LETTER IOTA WITH TONOS */
           case 242: *aucl_cur=211; break;  /* GREEK ... LETTER FINAL SIGMA (also to capital Sigma) */
           case 252: *aucl_cur=188; break;  /* GREEK ... LETTER OMICRON WITH TONOS */
           case 253: *aucl_cur=190; break;  /* GREEK ... LETTER UPSILON WITH TONOS */
           case 254: *aucl_cur=191; break;  /* GREEK ... LETTER OMEGA WITH TONOS */
           default:
             if (225<=*aucl_cur && *aucl_cur<=251)
               *aucl_cur -= 32;  /* GREEK ... LETTER ALPHA to GREEK ... LETTER UPSILON WITH DIALYTIKA (... UPSILON DIAERESIS) */
             break;
         }
         aucl_cur++;
       }
       break;
     case ied_chs_wcp_1254:                 /* Windows-Codepage 1254 (Turkish) */
       aucl_cur = (unsigned char*)ap_p;
       aucl_end = aucl_cur + imp_len;
       while (aucl_cur<aucl_end) {
         switch (*aucl_cur) {
           case 105: *aucl_cur=221; break;  /* LATIN ... LETTER I [WITH DOT ABOVE] (Category T in CaseFolding.txt from unicode.org) */
           case 154: *aucl_cur=138; break;  /* LATIN ... LETTER S WITH CARON (... S HACEK) */
           case 156: *aucl_cur=140; break;  /* LATIN ... LIGATURE OE */
           case 247: break;
           case 253: *aucl_cur=73; break;  /* LATIN ... LETTER [DOTLESS] I (Category T in CaseFolding.txt from unicode.org) */
           case 255: *aucl_cur=159; break;  /* LATIN ... LETTER Y WITH DIAERESIS */
           default:
             if (97<=*aucl_cur && *aucl_cur<=122)
               *aucl_cur -= 32;  /* LATIN ... LETTER A to LATIN ... LETTER Z */
             else
             if (224<=*aucl_cur && *aucl_cur<=254)
               *aucl_cur -= 32;  /* LATIN ... LETTER A WITH GRAVE to LATIN ... LETTER S WITH CEDILLA */
             break;
         }
         aucl_cur++;
       }
       break;
     case ied_chs_wcp_1255:                 /* Windows-Codepage 1255 (Hebrew) */
     case ied_chs_wcp_874:                  /* Windows-Codepage 874 (Thai) */
     case ied_chs_iso8859_6:                /* ISO 8859-6 (Arabic)     */
     case ied_chs_iso8859_8:                /* ISO 8859-8 (Hebrew)     */
     case ied_chs_iso8859_11:               /* ISO 8859-11 (Thai)      */
       aucl_cur = (unsigned char*)ap_p;
       aucl_end = aucl_cur + imp_len;
       while (aucl_cur<aucl_end) {
         if (97<=*aucl_cur && *aucl_cur<=122)
           *aucl_cur-=32;  /* LATIN ... LETTER A to LATIN ... LETTER Z */
         aucl_cur++;
       }
       break;
     case ied_chs_wcp_1256:                 /* Windows-Codepage 1256 (Arabic) */
       aucl_cur = (unsigned char*)ap_p;
       aucl_end = aucl_cur + imp_len;
       while (aucl_cur<aucl_end) {
         if (97<=*aucl_cur && *aucl_cur<=122)
           *aucl_cur-=32;  /* LATIN ... LETTER A to LATIN ... LETTER Z */
         else if (*aucl_cur==156) {
           *aucl_cur=140;                   /* LATIN ... LIGATURE OE   */
         }
         aucl_cur++;
       }
       break;
     case ied_chs_wcp_1257:                 /* Windows-Codepage 1257 (Baltic) */
       aucl_cur = (unsigned char*)ap_p;
       aucl_end = aucl_cur + imp_len;
       while (aucl_cur<aucl_end) {
         if (97<=*aucl_cur && *aucl_cur<=122)
           *aucl_cur-=32;  /* LATIN ... LETTER A to LATIN ... LETTER Z */
         else switch (*aucl_cur) {
           case 184: *aucl_cur=168; break;  /* LATIN ... LETTER O WITH STROKE */
           case 186: *aucl_cur=170; break;  /* LATIN ... LETTER R WITH CEDILLA */
           case 191: *aucl_cur=175; break;  /* LATIN ... LETTER AE */
           case 247: break;
           default:
             if (224<=*aucl_cur && *aucl_cur<=254)
               *aucl_cur -= 32;  /* LATIN ... LETTER A WITH OGONEK to LATIN ... LETTER Z WITH CARON (... Z HACEK) */
             break;
         }
         aucl_cur++;
       }
       break;
     case ied_chs_wcp_1258:                 /* Windows-Codepage 1258 (Vietnamese) */
       aucl_cur = (unsigned char*)ap_p;
       aucl_end = aucl_cur + imp_len;
       while (aucl_cur<aucl_end) {
         if (97<=*aucl_cur && *aucl_cur<=122)
           *aucl_cur-=32;  /* LATIN ... LETTER A to LATIN ... LETTER Z */
         else switch (*aucl_cur) {
           case 156: *aucl_cur=140; break;  /* LATIN ... LIGATURE OE */
           case 236: break;
           case 242: break;
           case 247: break;
           case 255: *aucl_cur=159; break;  /* LATIN ... LETTER Y WITH DIAERESIS */
           default:
             if (224<=*aucl_cur && *aucl_cur<=253)
               *aucl_cur -= 32;  /* LATIN ... LETTER A WITH GRAVE to LATIN ... LETTER U WITH HORN */
             break;
         }
         aucl_cur++;
       }
       break;
     case ied_chs_iso8859_2:                /* ISO 8859-2 (Latin-2)    */
       aucl_cur = (unsigned char*)ap_p;
       aucl_end = aucl_cur + imp_len;
       while (aucl_cur<aucl_end) {
         if (97<=*aucl_cur && *aucl_cur<=122)
           *aucl_cur -= 32;  /* LATIN ... LETTER A to LATIN ... LETTER Z */
         else if (185<=*aucl_cur && *aucl_cur<=188)
           *aucl_cur -= 16;  /* LATIN ... LETTER S WITH CARON to LATIN ... LETTER Z WITH ACUTE */
         else if (181<=*aucl_cur && *aucl_cur<=182)
           *aucl_cur -= 16;  /* LATIN ... LETTER L WITH CARON to LATIN ... LETTER S WITH ACUTE */
         else switch (*aucl_cur) {
           case 177: *aucl_cur=161; break;    /* LATIN ... LETTER A WITH OGONEK */
           case 179: *aucl_cur=163; break;    /* LATIN ... LETTER L WITH STROKE */
           case 190:                          /* LATIN ... LETTER Z WITH CARON */
           case 191: *aucl_cur -= 16; break;  /* LATIN ... LETTER Z WITH DOT ABOVE */
           case 247: break;
           default: if (224<=*aucl_cur && *aucl_cur<=254)
             *aucl_cur -= 32;  /* LATIN ... LETTER R WITH ACUTE ... LATIN ... LETTER T WITH CEDILLA */
             break;
         }
         aucl_cur++;
       }
       break;
     case ied_chs_iso8859_3:                /* ISO 8859-3 (Latin-3)    */
       aucl_cur = (unsigned char*)ap_p;
       aucl_end = aucl_cur + imp_len;
       while (aucl_cur<aucl_end) {
         if (97<=*aucl_cur && *aucl_cur<=122)
           *aucl_cur -= 32;  /* LATIN ... LETTER A to LATIN ... LETTER Z */
         else if (228<=*aucl_cur && *aucl_cur<=239)
           *aucl_cur -= 32;  /* LATIN ... LETTER A WITH DIAERESIS to LATIN ... LETTER I WITH DIAERESIS */
         else if (248<=*aucl_cur && *aucl_cur<=254)
           *aucl_cur -= 32;  /* LATIN ... LETTER G WITH CIRCUMFLEX to LATIN ... LETTER S WITH CIRCUMFLEX */
         else if (241<=*aucl_cur && *aucl_cur<=246)
           *aucl_cur -= 32;  /* LATIN ... LETTER N WITH TILDE to LATIN ... LETTER O WITH DIAERESIS */
         else if (224<=*aucl_cur && *aucl_cur<=226)
           *aucl_cur -= 32;  /* LATIN ... LETTER A WITH GRAVE to LATIN ... LETTER A WITH CIRCUMFLEX */
         else switch (*aucl_cur) {
           case 177: *aucl_cur=161; break;  /* LATIN ... LETTER H WITH STROKE */
           case 182: *aucl_cur=166; break;  /* LATIN ... LETTER H WITH CIRCUMFLEX */
           case 191: *aucl_cur=175; break;  /* LATIN ... LETTER Z WITH DOT ABOVE */
           case 185: *aucl_cur=73; break;   /* small dotless i to 'I' (here like Category T) */
           default: if (186<=*aucl_cur && *aucl_cur<=188)
             *aucl_cur -= 16;  /* LATIN ... LETTER S WITH CEDILLA to LATIN ... LETTER J WITH CIRCUMFLEX */
             break;
         }
         aucl_cur++;
       }
       break;
     case ied_chs_iso8859_4:                /* ISO 8859-4 (Latin-4)    */
       aucl_cur = (unsigned char*)ap_p;
       aucl_end = aucl_cur + imp_len;
       while (aucl_cur<aucl_end) {
         if (97<=*aucl_cur && *aucl_cur<=122)
           *aucl_cur -= 32;  /* LATIN ... LETTER A to LATIN ... LETTER Z */
         else if (185<=*aucl_cur && *aucl_cur<=188)
           *aucl_cur -= 16;  /* LATIN ... LETTER S WITH CARON to LATIN ... LETTER T WITH STROKE */
         else switch (*aucl_cur) {
           case 177: *aucl_cur=161; break;    /* LATIN ... LETTER A WITH OGONEK */
           case 179: *aucl_cur=163; break;    /* LATIN ... LETTER R WITH CEDILLA */
           case 190: *aucl_cur=174; break;    /* LATIN ... LETTER Z WITH CARON */
           case 191: *aucl_cur=189; break;    /* LATIN ... LETTER ENG */
           case 181:                          /* LATIN ... LETTER I WITH TILDE */
           case 182: *aucl_cur -= 16; break;  /* LATIN ... LETTER L WITH CEDILLA */
           case 247: break;
           default: if (224<=*aucl_cur && *aucl_cur<=254)
             *aucl_cur -= 32;  /* LATIN ... LETTER A WITH MACRON ... LATIN ... LETTER U WITH MACRON */
             break;
         }
         aucl_cur++;
       }
       break;
     case ied_chs_iso8859_5:                /* ISO 8859-5 (Cyrillic)   */
       aucl_cur = (unsigned char*)ap_p;
       aucl_end = aucl_cur + imp_len;
       while (aucl_cur<aucl_end) {
         if (208<=*aucl_cur && *aucl_cur<=239)
           *aucl_cur -= 32;  /* CYRILLIC ... LETTER A to CYRILLIC ... LETTER YA */
         else if (97<=*aucl_cur && *aucl_cur<=122)
           *aucl_cur -= 32;  /* LATIN ... LETTER A to LATIN ... LETTER Z */
         else if (241<=*aucl_cur && *aucl_cur!=253)
           *aucl_cur -= 80;  /* CYRILLIC ... LETTER IO ... CYRILLIC ... LETTER DZHE */
         aucl_cur++;
       }
       break;
     case ied_chs_iso8859_7:                /* ISO 8859-7 (Greek)      */
       aucl_cur = (unsigned char*)ap_p;
       aucl_end = aucl_cur + imp_len;
       while (aucl_cur<aucl_end) {
         if (97<=*aucl_cur && *aucl_cur<=122)
           *aucl_cur -= 32;  /* LATIN ... LETTER A to LATIN ... LETTER Z */
         else if (221<=*aucl_cur && *aucl_cur<=223)
           *aucl_cur -= 37;  /* GREEK ... LETTER EPSILON WITH TONOS to GREEK ... LETTER IOTA WITH TONOS */
         else switch (*aucl_cur) {
           case 220: *aucl_cur=182; break;   /* GREEK ... LETTER ALPHA WITH TONOS */
           case 252: *aucl_cur=188; break;   /* GREEK ... LETTER OMICRON WITH TONOS */
           case 253:                         /* GREEK ... LETTER UPSILON WITH TONOS */
           case 254: *aucl_cur -= 63; break; /* GREEK ... LETTER OMEGA WITH TONOS */
           case 242: *aucl_cur=211; break;   /* GREEK ... LETTER [FINAL] SIGMA (non-injective) */
           default: if (225<=*aucl_cur && *aucl_cur<=251)
             *aucl_cur -= 32;  /* GREEK ... LETTER ALPHA ... GREEK ... LETTER UPSILON WITH DIALYTIKA */
             break;
         }
         aucl_cur++;
       }
       break;
     case ied_chs_iso8859_9:                /* ISO 8859-9 (Latin-5)    */
       aucl_cur = (unsigned char*)ap_p;
       aucl_end = aucl_cur + imp_len;
       while (aucl_cur<aucl_end) {
         switch (*aucl_cur) {
           case 105: *aucl_cur=221; break;  /* LATIN ... LETTER I [WITH DOT ABOVE] (Category T in CaseFolding.txt from unicode.org) */
           case 254: *aucl_cur=222; break;  /* LATIN ... LETTER S WITH CEDILLA */
           case 247: break;
           case 253: *aucl_cur=73; break;  /* LATIN ... LETTER [DOTLESS] I (Category T in CaseFolding.txt from unicode.org) */
           default:
             if (224<=*aucl_cur && *aucl_cur<=252)
               *aucl_cur -= 32;  /* LATIN ... LETTER A WITH GRAVE ... LATIN ... LETTER U WITH DIAERESIS */
             else
             if (97<=*aucl_cur && *aucl_cur<=122)
               *aucl_cur -= 32;  /* LATIN ... LETTER A to LATIN ... LETTER Z */
         }
         aucl_cur++;
       }
       break;
     case ied_chs_iso8859_10:               /* ISO 8859-10 (Latin-6)   */
       aucl_cur = (unsigned char*)ap_p;
       aucl_end = aucl_cur + imp_len;
       while (aucl_cur<aucl_end) {
         if (224<=*aucl_cur && *aucl_cur<=254)
           *aucl_cur -= 32;  /* LATIN ... LETTER A WITH MACRON to LATIN ... LETTER THORN (Icelandic) */
         else if (97<=*aucl_cur && *aucl_cur<=122)
           *aucl_cur -= 32;  /* LATIN ... LETTER A to LATIN ... LETTER Z */
         else switch (*aucl_cur) {
           case 183: break;
           case 189: break;
           default: if (177<=*aucl_cur && *aucl_cur<=191)
             *aucl_cur -= 16;  /* LATIN ... LETTER A WITH OGONEK ... LATIN ... LETTER ENG */
         }
         aucl_cur++;
       }
       break;
     case ied_chs_iso8859_13:               /* ISO 8859-13 (Latin-7)   */
       aucl_cur = (unsigned char*)ap_p;
       aucl_end = aucl_cur + imp_len;
       while (aucl_cur<aucl_end) {
         if (97<=*aucl_cur && *aucl_cur<=122)
           *aucl_cur -= 32;  /* LATIN ... LETTER A to LATIN ... LETTER Z */
         else switch (*aucl_cur) {
           case 184: *aucl_cur=168; break;  /* LATIN ... LETTER O WITH STROKE */
           case 186: *aucl_cur=170; break;  /* LATIN ... LETTER R WITH CEDILLA */
           case 191: *aucl_cur=175; break;  /* LATIN ... LETTER AE */
           case 247: break;
           default: if (224<=*aucl_cur && *aucl_cur<=254)
             *aucl_cur -= 32;  /* LATIN ... LETTER A WITH OGONEK ... LATIN ... LETTER Z WITH CARON */
             break;
         }
         aucl_cur++;
       }
       break;
     case ied_chs_iso8859_14:               /* ISO 8859-14 (Latin-8)   */
       aucl_cur = (unsigned char*)ap_p;
       aucl_end = aucl_cur + imp_len;
       while (aucl_cur<aucl_end) {
         if (224<=*aucl_cur && *aucl_cur<=254)
           *aucl_cur -= 32;  /* LATIN ... LETTER A WITH GRAVE to LATIN ... LETTER Y WITH CIRCUMFLEX */
         else switch (*aucl_cur) {
           case 162: *aucl_cur=161; break;  /* LATIN ... LETTER B WITH DOT ABOVE */
           case 165: *aucl_cur=164; break;  /* LATIN ... LETTER C WITH DOT ABOVE */
           case 171: *aucl_cur=166; break;  /* LATIN ... LETTER D WITH DOT ABOVE */
           case 177: *aucl_cur=176; break;  /* LATIN ... LETTER F WITH DOT ABOVE */
           case 179: *aucl_cur=178; break;  /* LATIN ... LETTER G WITH DOT ABOVE */
           case 181: *aucl_cur=180; break;  /* LATIN ... LETTER M WITH DOT ABOVE */
           case 184: *aucl_cur=168; break;  /* LATIN ... LETTER W WITH GRAVE */
           case 185: *aucl_cur=183; break;  /* LATIN ... LETTER P WITH DOT ABOVE */
           case 186: *aucl_cur=170; break;  /* LATIN ... LETTER W WITH ACUTE */
           case 188: *aucl_cur=172; break;  /* LATIN ... LETTER Y WITH GRAVE */
           case 190: *aucl_cur=189; break;  /* LATIN ... LETTER W WITH DIAERESIS */
           case 191: *aucl_cur=187; break;  /* LATIN ... LETTER S WITH DOT ABOVE */
           case 255: *aucl_cur=175; break;  /* LATIN ... LETTER Y WITH DIAERESIS */
           default: if (97<=*aucl_cur && *aucl_cur<=122)
             *aucl_cur -= 32;  /* LATIN ... LETTER A to LATIN ... LETTER Z */
             break;
         }
         aucl_cur++;
       }
       break;
     case ied_chs_iso8859_15:               /* ISO 8859-15 (Latin-9)   */
       aucl_cur = (unsigned char*)ap_p;
       aucl_end = aucl_cur + imp_len;
       while (aucl_cur<aucl_end) {
         if (97<=*aucl_cur && *aucl_cur<=122)
           *aucl_cur -= 32;  /* LATIN ... LETTER A to LATIN ... LETTER Z */
         else switch (*aucl_cur) {
           case 168: *aucl_cur=166; break;  /* LATIN ... LETTER S WITH CARON */
           case 184: *aucl_cur=180; break;  /* LATIN ... LETTER Z WITH CARON */
           case 189: *aucl_cur=188; break;  /* LATIN ... LIGATURE OE */
           case 255: *aucl_cur=190; break;  /* LATIN ... LETTER Y WITH DIAERESIS */
           case 247: break;
           default: if (224<=*aucl_cur && *aucl_cur<=254)
             *aucl_cur -= 32;  /* LATIN ... LETTER A WITH GRAVE ... LATIN ... LETTER THORN */
             break;
         }
         aucl_cur++;
       }
       break;
     case ied_chs_iso8859_16:               /* ISO 8859-16 (Latin-10)  */
       aucl_cur = (unsigned char*)ap_p;
       aucl_end = aucl_cur + imp_len;
       while (aucl_cur<aucl_end) {
         if (224<=*aucl_cur && *aucl_cur<=254)
           *aucl_cur -= 32;  /* LATIN ... LETTER A WITH GRAVE to LATIN ... LETTER T WITH COMMA BELOW */
         else switch (*aucl_cur) {
           case 162: *aucl_cur=161; break;  /* LATIN ... LETTER A WITH OGONEK */
           case 168: *aucl_cur=166; break;  /* LATIN ... LETTER S WITH CARON */
           case 174: *aucl_cur=172; break;  /* LATIN ... LETTER Z WITH ACUTE */
           case 179: *aucl_cur=163; break;  /* LATIN ... LETTER L WITH STROKE */
           case 184: *aucl_cur=180; break;  /* LATIN ... LETTER Z WITH CARON */
           case 185: *aucl_cur=178; break;  /* LATIN ... LETTER C WITH CARON */
           case 186: *aucl_cur=170; break;  /* LATIN ... LETTER S WITH COMMA BELOW */
           case 189: *aucl_cur=188; break;  /* LATIN ... LIGATURE OE */
           case 191: *aucl_cur=175; break;  /* LATIN ... LETTER Z WITH DOT ABOVE */
           case 255: *aucl_cur=190; break;  /* LATIN ... LETTER Y WITH DIAERESIS */
           default: if (97<=*aucl_cur && *aucl_cur<=122)
             *aucl_cur -= 32;  /* LATIN ... LETTER A to LATIN ... LETTER Z */
             break;
         }
         aucl_cur++;
       }
       break;
     case ied_chs_wcp_932:                  /* Windows-Codepage 932 (MBCS, Japanese) */
       aucl_cur = (unsigned char*)ap_p;
       aucl_end = aucl_cur + imp_len;
       m_get_tab_mb_firstbytes(ied_chs_wcp_932);
       while (aucl_cur<aucl_end) {
         if (awcg_tab_932_leadbyte[*aucl_cur]!=0xFFFF) {
           if (0x0061<=*aucl_cur && *aucl_cur<=0x007A)
             *aucl_cur-=32;
         } else {
           if (aucl_cur+1 == aucl_end) return FALSE;
           switch (*aucl_cur++) {
             case 0x82:
               if (0x81<=*aucl_cur && *aucl_cur<=0x9A)
                 *aucl_cur-=33;
               break;
             case 0x83:
               if (0xBF<=*aucl_cur && *aucl_cur<=0xD6)
                 *aucl_cur-=32;
               break;
             case 0x84:
               if (0x70<=*aucl_cur && *aucl_cur<=0x7E)
                 *aucl_cur-=48;
               else if (0x80<=*aucl_cur && *aucl_cur<=0x91)
                 *aucl_cur-=49;
               break;
             case 0xEE:
               if (0xEF<=*aucl_cur && *aucl_cur<=0xF8) {
                 *(aucl_cur-1)=0xFA;
                 *aucl_cur-=0xA5;
               }
               break;
             case 0xFA:
               if (0x40<=*aucl_cur && *aucl_cur<=0x49)
                 *aucl_cur+=10;
               break;
             default: break;
           }
         }
         aucl_cur++;
       }
       break;
     case ied_chs_wcp_936:                  /* Windows-Codepage 936 (MBCS, Mainland Chinese) */
       aucl_cur = (unsigned char*)ap_p;
       aucl_end = aucl_cur + imp_len;
       m_get_tab_mb_firstbytes(ied_chs_wcp_936);
       while (aucl_cur<aucl_end) {
         if (awcg_tab_936_leadbyte[*aucl_cur]!=0xFFFF) {
           if (0x0061<=*aucl_cur && *aucl_cur<=0x007A)
             *aucl_cur-=32;
         } else {
           if (aucl_cur+1 == aucl_end) return FALSE;
           switch (*aucl_cur++) {
             case 0xA2:
               if (0xA1<=*aucl_cur && *aucl_cur<=0xAA)
                 *aucl_cur+=80;
               break;
             case 0xA3:
               if (0xE1<=*aucl_cur && *aucl_cur<=0xFA)
                 *aucl_cur-=32;
               break;
             case 0xA6:
               if (0xC1<=*aucl_cur && *aucl_cur<=0xD8)
                 *aucl_cur-=32;
               break;
             case 0xA7:
               if (0xD1<=*aucl_cur && *aucl_cur<=0xF1)
                 *aucl_cur-=48;
               break;
             default: break;
           }
         }
         aucl_cur++;
       }
       break;
     case ied_chs_wcp_949:                  /* Windows-Codepage 949 (MBCS, Korean) */
       aucl_cur = (unsigned char*)ap_p;
       aucl_end = aucl_cur + imp_len;
       m_get_tab_mb_firstbytes(ied_chs_wcp_949);
       while (aucl_cur<aucl_end) {
         if (awcg_tab_949_leadbyte[*aucl_cur]!=0xFFFF) {
           if (0x0061<=*aucl_cur && *aucl_cur<=0x007A)
             *aucl_cur-=32;
         } else {
           if (aucl_cur+1 == aucl_end) return FALSE;
           switch (*aucl_cur++) {
             case 0xA3:
               if (0xE1<=*aucl_cur && *aucl_cur<=0xFA)
                 *aucl_cur-=32;
               break;
             case 0xA5:
               if (0xA1<=*aucl_cur && *aucl_cur<=0xAA)
                 *aucl_cur+=15;
               else if (0xE1<=*aucl_cur && *aucl_cur<=0xF8)
                 *aucl_cur-=32;
               break;
             case 0xA9:
               if (0xA8<=*aucl_cur && *aucl_cur<=0xAF && *aucl_cur!=0xAC) {
                 aucl_cur[-1]--;
               } else switch (*aucl_cur) {
                   case 0xA1:
                   case 0xA4:
                   case 0xA6: aucl_cur[-1]--; break;
                   case 0xA3: aucl_cur[-1]--; (*aucl_cur)--; break;
                   case 0xA5: return FALSE; /* A9 A5 -> 49, the length in bytes would not stay the same */
               }
               break;
             case 0xAC:
               if (0xD1<=*aucl_cur && *aucl_cur<=0xF1)
                 *aucl_cur-=48;
               break;
             default: break;
           }
         }
         aucl_cur++;
       }
       break;
     case ied_chs_wcp_950:                  /* Windows-Codepage 950 (MBCS, Taiwan Chinese) */
       aucl_cur = (unsigned char*)ap_p;
       aucl_end = aucl_cur + imp_len;
       m_get_tab_mb_firstbytes(ied_chs_wcp_950);
       while (aucl_cur<aucl_end) {
         if (awcg_tab_950_leadbyte[*aucl_cur]!=0xFFFF) {
           if (0x0061<=*aucl_cur && *aucl_cur<=0x007A)
             *aucl_cur-=32;
         } else {
           if (aucl_cur+1 == aucl_end) return FALSE;
           switch (*aucl_cur++) {
             case 0xA2:
               if (0xE9<=*aucl_cur && *aucl_cur<=0xFE)
                 *aucl_cur-=26;
               break;
             case 0xA3:
               if (0x40<=*aucl_cur && *aucl_cur<=0x43) {
                 aucl_cur[-1]--;
                 *aucl_cur+=165;
               } else if (0x5C<=*aucl_cur && *aucl_cur<=0x73) {
                 *aucl_cur-=24;
               }
               break;
             default: break;
           }
         }
         aucl_cur++;
       }
       break;
     case ied_chs_utf_16:                   /* Unicode UTF-16          */
       awcl_cur = (HL_WCHAR*)ap_p;
       awcl_end = awcl_cur + imp_len;
       while (awcl_cur<awcl_end) {
         if ((*awcl_cur&0xF800)==0xD800) {  /* surrogate (high or low) */
           if ((*awcl_cur==0xD801) && (awcl_cur+1<awcl_end)) {
             awcl_cur++;
             if ((0xDC28<=*awcl_cur) && (*awcl_cur<0xDC50))
               *awcl_cur-=40;               /* DESERET ... LETTER ...  */
           }
         } else {                           /* regular case = WCHAR    */
           *awcl_cur = m_trans_to_uc(*awcl_cur);
         }
         awcl_cur++;
       }
       break;
     case ied_chs_be_utf_16:                /* Unicode UTF-16 big (non-native) endian */
     case ied_chs_le_utf_16:                /* Unicode UTF-16 little (non-native) endian */
       awcl_cur = (HL_WCHAR*)ap_p;
       awcl_end = awcl_cur + imp_len;
       while (awcl_cur<awcl_end) {
         if ((*awcl_cur&0x00F8)==0x00D8) {  /* surrogate (high or low) */
           if ((*awcl_cur==0x01D8) && (awcl_cur+1<awcl_end)) {
             awcl_cur++;
             if (((*awcl_cur&0x00FF)==0x00DC) && (*awcl_cur<0x5000) && (*awcl_cur>=0x2800))
               *awcl_cur-=0x2800;           /* DESERET ... LETTER ...  */
           }
         } else {                           /* regular case            */
           wcl_tmp = ((*awcl_cur<<8)&0xFF00) | (*awcl_cur>>8);
           wcl_tmp = m_trans_to_uc(wcl_tmp);
           *awcl_cur = ((wcl_tmp<<8)&0xFF00) | (wcl_tmp>>8);
         }
         awcl_cur++;
       }
       break;
     case ied_chs_utf_32:                   /* Unicode UTF-32          */
       aunl_cur = (unsigned int*)ap_p;
       aunl_end = aunl_cur + imp_len;
       while (aunl_cur<aunl_end) {
         m_touppercase_inplace_u32c(aunl_cur);
         aunl_cur++;
       }
       break;
     case ied_chs_be_utf_32:                /* Unicode UTF-32 big (non-native) endian */
     case ied_chs_le_utf_32:                /* Unicode UTF-32 little (non-native) endian */
       aunl_cur = (unsigned int*)ap_p;
       aunl_end = aunl_cur + imp_len;
       while (aunl_cur<aunl_end) {
         unl_tmp = HL_ENDIANSWAP32(*aunl_cur);
         m_touppercase_inplace_u32c(&unl_tmp);
         *aunl_cur = HL_ENDIANSWAP32(unl_tmp);
         aunl_cur++;
       }
       break;
     default:
       return FALSE;
   }
   return TRUE;
} /* end m_to_uc_inplace()                                             */

/**
* Gets the Joining_Type property (as in unicode chapter 8) for a codepoint
*  @param unp_c the codepoint
*  @return the Joining Type of unp_c
*/
enum ied_unicode_joining_type m_get_unicode_joining_type(unsigned int unp_c) {
   if(unp_c < 0x180E)
     if(unp_c < 0x09C5)
       if(unp_c < 0x070F)
         if(unp_c < 0x066E)
           if(unp_c < 0x05C8)
             if(unp_c < 0x0483)
               if(unp_c < 0x0300)
                 return (unp_c==0x00AD)?ied_unijointyp_t:ied_unijointyp_u;
               else
                 return (unp_c<0x0370)?ied_unijointyp_t:ied_unijointyp_u;
             else /* unp_c >= U+0483 */
               if(unp_c < 0x0591)
                 return (unp_c<0x048A)?ied_unijointyp_t:ied_unijointyp_u;
               else
                 switch(unp_c) {
                   case 0x05BE:
                   case 0x05C0:
                   case 0x05C3:
                   case 0x05C6: return ied_unijointyp_u;
                   default: return ied_unijointyp_t;
                 }
           else /* unp_c >= U+05C8 */
             if(unp_c < 0x062A)
               if(unp_c < 0x061B)
                 return (unp_c<0x0610)?ied_unijointyp_u:ied_unijointyp_t;
               else
                   if(unp_c < 0x0622)
                     return (unp_c==0x0620)?ied_unijointyp_d:ied_unijointyp_u;
                   else
                     switch(unp_c) {
                       case 0x0626:
                       case 0x0628: return ied_unijointyp_d;
                       default: return ied_unijointyp_r;
                     }
             else /* unp_c >= U+062A */
               if(unp_c < 0x064B)
                   if(unp_c < 0x0633)
                     return (unp_c<0x062F)?ied_unijointyp_d:ied_unijointyp_r;
                   else
                     switch(unp_c) {
                       case 0x0640: return ied_unijointyp_c;
                       case 0x0648: return ied_unijointyp_r;
                       default: return ied_unijointyp_d;
                     }
               else
                 return (unp_c<0x0660)?ied_unijointyp_t:ied_unijointyp_u;
         else /* unp_c >= U+066E */
           if(unp_c < 0x06D6)
             if(unp_c < 0x069A)
               if(unp_c < 0x0678)
                   if(unp_c < 0x0671)
                     return (unp_c<0x0670)?ied_unijointyp_d:ied_unijointyp_t;
                   else
                     return (unp_c==0x0674)?ied_unijointyp_u:ied_unijointyp_r;
               else
                 return (unp_c<0x0688)?ied_unijointyp_d:ied_unijointyp_r;
             else /* unp_c >= U+069A */
               if(unp_c < 0x06D0)
                   if(unp_c < 0x06C3)
                     return (unp_c==0x06C0)?ied_unijointyp_r:ied_unijointyp_d;
                   else
                     switch(unp_c) {
                       case 0x06CC:
                       case 0x06CE: return ied_unijointyp_d;
                       default: return ied_unijointyp_r;
                     }
               else
                   if(unp_c < 0x06D4)
                     return (unp_c<0x06D2)?ied_unijointyp_d:ied_unijointyp_r;
                   else
                     return (unp_c<0x06D5)?ied_unijointyp_u:ied_unijointyp_r;
           else /* unp_c >= U+06D6 */
             if(unp_c < 0x06EE)
               if(unp_c < 0x06DF)
                 return (unp_c<0x06DD)?ied_unijointyp_t:ied_unijointyp_u;
               else
                   if(unp_c < 0x06E7)
                     return (unp_c<0x06E5)?ied_unijointyp_t:ied_unijointyp_u;
                   else
                     return (unp_c==0x06E9)?ied_unijointyp_u:ied_unijointyp_t;
             else /* unp_c >= U+06EE */
               if(unp_c < 0x06FD)
                   if(unp_c < 0x06FA)
                     return (unp_c<0x06F0)?ied_unijointyp_r:ied_unijointyp_u;
                   else
                     return ied_unijointyp_d;
               else
                 return (unp_c==0x06FF)?ied_unijointyp_d:ied_unijointyp_u;
       else /* unp_c >= U+070F */
         if(unp_c < 0x0841)
           if(unp_c < 0x0771)
             if(unp_c < 0x0730)
               if(unp_c < 0x071A)
                   if(unp_c < 0x0712)
                     return (unp_c==0x0710)?ied_unijointyp_r:ied_unijointyp_t;
                   else
                     return (unp_c<0x0715)?ied_unijointyp_d:ied_unijointyp_r;
               else
                 switch(unp_c) {
                   case 0x071E:
                   case 0x0728:
                   case 0x072A:
                   case 0x072C:
                   case 0x072F: return ied_unijointyp_r;
                   default: return ied_unijointyp_d;
                 }
             else /* unp_c >= U+0730 */
               if(unp_c < 0x0759)
                   if(unp_c < 0x074D)
                     return (unp_c<0x074B)?ied_unijointyp_t:ied_unijointyp_u;
                   else
                     return (unp_c<0x074E)?ied_unijointyp_r:ied_unijointyp_d;
               else
                   if(unp_c < 0x076B)
                     return (unp_c<0x075C)?ied_unijointyp_r:ied_unijointyp_d;
                   else
                     return (unp_c<0x076D)?ied_unijointyp_r:ied_unijointyp_d;
           else /* unp_c >= U+0771 */
             if(unp_c < 0x07CA)
               if(unp_c < 0x077A)
                   if(unp_c < 0x0775)
                     return (unp_c==0x0772)?ied_unijointyp_d:ied_unijointyp_r;
                   else
                     return (unp_c<0x0778)?ied_unijointyp_d:ied_unijointyp_r;
               else
                   if(unp_c < 0x07A6)
                     return (unp_c<0x0780)?ied_unijointyp_d:ied_unijointyp_u;
                   else
                     return (unp_c<0x07B1)?ied_unijointyp_t:ied_unijointyp_u;
             else /* unp_c >= U+07CA */
               if(unp_c < 0x0816)
                   if(unp_c < 0x07F4)
                     return (unp_c<0x07EB)?ied_unijointyp_d:ied_unijointyp_t;
                   else
                     return (unp_c==0x07FA)?ied_unijointyp_c:ied_unijointyp_u;
               else
                   if(unp_c < 0x082E)
                     switch(unp_c) {
                       case 0x081A:
                       case 0x0824:
                       case 0x0828: return ied_unijointyp_u;
                       default: return ied_unijointyp_t;
                     }
                   else
                     return (unp_c<0x0840)?ied_unijointyp_u:ied_unijointyp_r;
         else /* unp_c >= U+0841 */
           if(unp_c < 0x0903)
             if(unp_c < 0x08A1)
               if(unp_c < 0x085C)
                   if(unp_c < 0x0856)
                     switch(unp_c) {
                       case 0x0846:
                       case 0x0849:
                       case 0x084F:
                       case 0x0854: return ied_unijointyp_r;
                       default: return ied_unijointyp_d;
                     }
                   else
                     return (unp_c<0x0859)?ied_unijointyp_u:ied_unijointyp_t;
               else
                 return (unp_c<0x08A0)?ied_unijointyp_u:ied_unijointyp_d;
             else /* unp_c >= U+08A1 */
               if(unp_c < 0x08E4)
                   if(unp_c < 0x08AA)
                     return (unp_c<0x08A2)?ied_unijointyp_u:ied_unijointyp_d;
                   else
                     return (unp_c<0x08AD)?ied_unijointyp_r:ied_unijointyp_u;
               else
                 return (unp_c==0x08FF)?ied_unijointyp_u:ied_unijointyp_t;
           else /* unp_c >= U+0903 */
             if(unp_c < 0x0958)
               if(unp_c < 0x0949)
                   if(unp_c < 0x0941)
                     switch(unp_c) {
                       case 0x093A:
                       case 0x093C: return ied_unijointyp_t;
                       default: return ied_unijointyp_u;
                     }
                   else
                     return ied_unijointyp_t;
               else
                   if(unp_c < 0x0951)
                     return (unp_c==0x094D)?ied_unijointyp_t:ied_unijointyp_u;
                   else
                     return ied_unijointyp_t;
             else /* unp_c >= U+0958 */
               if(unp_c < 0x09C1)
                 switch(unp_c) {
                   case 0x0962:
                   case 0x0963:
                   case 0x0981:
                   case 0x09BC: return ied_unijointyp_t;
                   default: return ied_unijointyp_u;
                 }
               else
                 return ied_unijointyp_t;
     else /* unp_c >= U+09C5 */
       if(unp_c < 0x0E4F)
         if(unp_c < 0x0C3E)
           if(unp_c < 0x0AC1)
             if(unp_c < 0x0A47)
               if(unp_c < 0x0A41)
                 switch(unp_c) {
                   case 0x09CD:
                   case 0x09E2:
                   case 0x09E3:
                   case 0x0A01:
                   case 0x0A02:
                   case 0x0A3C: return ied_unijointyp_t;
                   default: return ied_unijointyp_u;
                 }
               else
                 return (unp_c<0x0A43)?ied_unijointyp_t:ied_unijointyp_u;
             else /* unp_c >= U+0A47 */
               if(unp_c < 0x0A4E)
                   if(unp_c < 0x0A4B)
                     return (unp_c<0x0A49)?ied_unijointyp_t:ied_unijointyp_u;
                   else
                     return ied_unijointyp_t;
               else
                 switch(unp_c) {
                   case 0x0A51:
                   case 0x0A70:
                   case 0x0A71:
                   case 0x0A75:
                   case 0x0A81:
                   case 0x0A82:
                   case 0x0ABC: return ied_unijointyp_t;
                   default: return ied_unijointyp_u;
                 }
           else /* unp_c >= U+0AC1 */
             if(unp_c < 0x0B41)
               if(unp_c < 0x0AC9)
                 return (unp_c==0x0AC6)?ied_unijointyp_u:ied_unijointyp_t;
               else
                 switch(unp_c) {
                   case 0x0ACD:
                   case 0x0AE2:
                   case 0x0AE3:
                   case 0x0B01:
                   case 0x0B3C:
                   case 0x0B3F: return ied_unijointyp_t;
                   default: return ied_unijointyp_u;
                 }
             else /* unp_c >= U+0B41 */
               if(unp_c < 0x0B45)
                 return ied_unijointyp_t;
               else
                 switch(unp_c) {
                   case 0x0B4D:
                   case 0x0B56:
                   case 0x0B62:
                   case 0x0B63:
                   case 0x0B82:
                   case 0x0BC0:
                   case 0x0BCD: return ied_unijointyp_t;
                   default: return ied_unijointyp_u;
                 }
         else /* unp_c >= U+0C3E */
           if(unp_c < 0x0D45)
             if(unp_c < 0x0C64)
               if(unp_c < 0x0C4E)
                   if(unp_c < 0x0C46)
                     return (unp_c<0x0C41)?ied_unijointyp_t:ied_unijointyp_u;
                   else
                     return (unp_c==0x0C49)?ied_unijointyp_u:ied_unijointyp_t;
               else
                   if(unp_c < 0x0C57)
                     return (unp_c<0x0C55)?ied_unijointyp_u:ied_unijointyp_t;
                   else
                     return (unp_c<0x0C62)?ied_unijointyp_u:ied_unijointyp_t;
             else /* unp_c >= U+0C64 */
               if(unp_c < 0x0D41)
                 switch(unp_c) {
                   case 0x0CBC:
                   case 0x0CBF:
                   case 0x0CC6:
                   case 0x0CCC:
                   case 0x0CCD:
                   case 0x0CE2:
                   case 0x0CE3: return ied_unijointyp_t;
                   default: return ied_unijointyp_u;
                 }
               else
                 return ied_unijointyp_t;
           else /* unp_c >= U+0D45 */
             if(unp_c < 0x0DD7)
               if(unp_c < 0x0DD2)
                 switch(unp_c) {
                   case 0x0D4D:
                   case 0x0D62:
                   case 0x0D63:
                   case 0x0DCA: return ied_unijointyp_t;
                   default: return ied_unijointyp_u;
                 }
               else
                 return (unp_c==0x0DD5)?ied_unijointyp_u:ied_unijointyp_t;
             else /* unp_c >= U+0DD7 */
               if(unp_c < 0x0E34)
                 return (unp_c==0x0E31)?ied_unijointyp_t:ied_unijointyp_u;
               else
                   if(unp_c < 0x0E47)
                     return (unp_c<0x0E3B)?ied_unijointyp_t:ied_unijointyp_u;
                   else
                     return ied_unijointyp_t;
       else /* unp_c >= U+0E4F */
         if(unp_c < 0x1075)
           if(unp_c < 0x0F8D)
             if(unp_c < 0x0ECE)
               if(unp_c < 0x0EB4)
                 return (unp_c==0x0EB1)?ied_unijointyp_t:ied_unijointyp_u;
               else
                   if(unp_c < 0x0EBD)
                     return (unp_c==0x0EBA)?ied_unijointyp_u:ied_unijointyp_t;
                   else
                     return (unp_c<0x0EC8)?ied_unijointyp_u:ied_unijointyp_t;
             else /* unp_c >= U+0ECE */
               if(unp_c < 0x0F71)
                 switch(unp_c) {
                   case 0x0F18:
                   case 0x0F19:
                   case 0x0F35:
                   case 0x0F37:
                   case 0x0F39: return ied_unijointyp_t;
                   default: return ied_unijointyp_u;
                 }
               else
                   if(unp_c < 0x0F88)
                     switch(unp_c) {
                       case 0x0F7F:
                       case 0x0F85: return ied_unijointyp_u;
                       default: return ied_unijointyp_t;
                     }
                   else
                     return ied_unijointyp_u;
           else /* unp_c >= U+0F8D */
             if(unp_c < 0x102D)
               if(unp_c < 0x0FBD)
                 return (unp_c==0x0F98)?ied_unijointyp_u:ied_unijointyp_t;
               else
                 return (unp_c==0x0FC6)?ied_unijointyp_t:ied_unijointyp_u;
             else /* unp_c >= U+102D */
               if(unp_c < 0x105A)
                   if(unp_c < 0x103F)
                     switch(unp_c) {
                       case 0x1031:
                       case 0x1038:
                       case 0x103B:
                       case 0x103C: return ied_unijointyp_u;
                       default: return ied_unijointyp_t;
                     }
                   else
                     return (unp_c<0x1058)?ied_unijointyp_u:ied_unijointyp_t;
               else
                   if(unp_c < 0x1061)
                     return (unp_c<0x105E)?ied_unijointyp_u:ied_unijointyp_t;
                   else
                     return (unp_c<0x1071)?ied_unijointyp_u:ied_unijointyp_t;
         else /* unp_c >= U+1075 */
           if(unp_c < 0x1772)
             if(unp_c < 0x1712)
               if(unp_c < 0x135D)
                 switch(unp_c) {
                   case 0x1082:
                   case 0x1085:
                   case 0x1086:
                   case 0x108D:
                   case 0x109D: return ied_unijointyp_t;
                   default: return ied_unijointyp_u;
                 }
               else
                 return (unp_c<0x1360)?ied_unijointyp_t:ied_unijointyp_u;
             else /* unp_c >= U+1712 */
               if(unp_c < 0x1732)
                 return (unp_c<0x1715)?ied_unijointyp_t:ied_unijointyp_u;
               else
                   if(unp_c < 0x1752)
                     return (unp_c<0x1735)?ied_unijointyp_t:ied_unijointyp_u;
                   else
                     return (unp_c<0x1754)?ied_unijointyp_t:ied_unijointyp_u;
           else /* unp_c >= U+1772 */
             if(unp_c < 0x17C9)
               if(unp_c < 0x17B4)
                 return (unp_c<0x1774)?ied_unijointyp_t:ied_unijointyp_u;
               else
                   if(unp_c < 0x17BE)
                     return (unp_c==0x17B6)?ied_unijointyp_u:ied_unijointyp_t;
                   else
                     return (unp_c==0x17C6)?ied_unijointyp_t:ied_unijointyp_u;
             else /* unp_c >= U+17C9 */
               if(unp_c < 0x17DE)
                   if(unp_c < 0x17D4)
                     return ied_unijointyp_t;
                   else
                     return (unp_c<0x17DD)?ied_unijointyp_u:ied_unijointyp_t;
               else
                 return (unp_c<0x180B)?ied_unijointyp_u:ied_unijointyp_t;
   else /* unp_c >= U+180E */
     if(unp_c < 0xA9B4)
       if(unp_c < 0x1CE9)
         if(unp_c < 0x1B00)
           if(unp_c < 0x193C)
             if(unp_c < 0x1923)
               if(unp_c < 0x18AA)
                 return (unp_c<0x18A9)?ied_unijointyp_u:ied_unijointyp_t;
               else
                 return (unp_c<0x1920)?ied_unijointyp_u:ied_unijointyp_t;
             else /* unp_c >= U+1923 */
               if(unp_c < 0x1933)
                   if(unp_c < 0x1929)
                     return (unp_c<0x1927)?ied_unijointyp_u:ied_unijointyp_t;
                   else
                     return (unp_c<0x1932)?ied_unijointyp_u:ied_unijointyp_t;
               else
                 return (unp_c<0x1939)?ied_unijointyp_u:ied_unijointyp_t;
           else /* unp_c >= U+193C */
             if(unp_c < 0x1A58)
               if(unp_c < 0x1A19)
                 return (unp_c<0x1A17)?ied_unijointyp_u:ied_unijointyp_t;
               else
                 return (unp_c==0x1A56)?ied_unijointyp_t:ied_unijointyp_u;
             else /* unp_c >= U+1A58 */
               if(unp_c < 0x1A7D)
                   if(unp_c < 0x1A6D)
                     switch(unp_c) {
                       case 0x1A5F:
                       case 0x1A61:
                       case 0x1A63:
                       case 0x1A64: return ied_unijointyp_u;
                       default: return ied_unijointyp_t;
                     }
                   else
                     return (unp_c<0x1A73)?ied_unijointyp_u:ied_unijointyp_t;
               else
                 return (unp_c==0x1A7F)?ied_unijointyp_t:ied_unijointyp_u;
         else /* unp_c >= U+1B00 */
           if(unp_c < 0x1BAA)
             if(unp_c < 0x1B6B)
               if(unp_c < 0x1B34)
                 return (unp_c<0x1B04)?ied_unijointyp_t:ied_unijointyp_u;
               else
                   if(unp_c < 0x1B3D)
                     switch(unp_c) {
                       case 0x1B35:
                       case 0x1B3B: return ied_unijointyp_u;
                       default: return ied_unijointyp_t;
                     }
                   else
                     return (unp_c==0x1B42)?ied_unijointyp_t:ied_unijointyp_u;
             else /* unp_c >= U+1B6B */
               if(unp_c < 0x1B82)
                   if(unp_c < 0x1B74)
                     return ied_unijointyp_t;
                   else
                     return (unp_c<0x1B80)?ied_unijointyp_u:ied_unijointyp_t;
               else
                   if(unp_c < 0x1BA6)
                     return (unp_c<0x1BA2)?ied_unijointyp_u:ied_unijointyp_t;
                   else
                     return (unp_c<0x1BA8)?ied_unijointyp_u:ied_unijointyp_t;
           else /* unp_c >= U+1BAA */
             if(unp_c < 0x1C36)
               if(unp_c < 0x1BEF)
                 switch(unp_c) {
                   case 0x1BAB:
                   case 0x1BE6:
                   case 0x1BE8:
                   case 0x1BE9:
                   case 0x1BED: return ied_unijointyp_t;
                   default: return ied_unijointyp_u;
                 }
               else
                   if(unp_c < 0x1C2C)
                     return (unp_c<0x1BF2)?ied_unijointyp_t:ied_unijointyp_u;
                   else
                     return (unp_c<0x1C34)?ied_unijointyp_t:ied_unijointyp_u;
             else /* unp_c >= U+1C36 */
               if(unp_c < 0x1CD0)
                 return (unp_c<0x1C38)?ied_unijointyp_t:ied_unijointyp_u;
               else
                 switch(unp_c) {
                   case 0x1CD3:
                   case 0x1CE1: return ied_unijointyp_u;
                   default: return ied_unijointyp_t;
                 }
       else /* unp_c >= U+1CE9 */
         if(unp_c < 0x2DE0)
           if(unp_c < 0x206A)
             if(unp_c < 0x1E00)
               if(unp_c < 0x1DC0)
                 switch(unp_c) {
                   case 0x1CED:
                   case 0x1CF4: return ied_unijointyp_t;
                   default: return ied_unijointyp_u;
                 }
               else
                   if(unp_c < 0x1DE7)
                     return ied_unijointyp_t;
                   else
                     return (unp_c<0x1DFC)?ied_unijointyp_u:ied_unijointyp_t;
             else /* unp_c >= U+1E00 */
               if(unp_c < 0x202A)
                 switch(unp_c) {
                   case 0x200D: return ied_unijointyp_c;
                   case 0x200B:
                   case 0x200E:
                   case 0x200F: return ied_unijointyp_t;
                   default: return ied_unijointyp_u;
                 }
               else
                   if(unp_c < 0x2060)
                     return (unp_c<0x202F)?ied_unijointyp_t:ied_unijointyp_u;
                   else
                     return (unp_c<0x2065)?ied_unijointyp_t:ied_unijointyp_u;
           else /* unp_c >= U+206A */
             if(unp_c < 0x20F1)
               if(unp_c < 0x20D0)
                 return (unp_c<0x2070)?ied_unijointyp_t:ied_unijointyp_u;
               else
                 return ied_unijointyp_t;
             else /* unp_c >= U+20F1 */
               if(unp_c < 0x2CF2)
                 return (unp_c<0x2CEF)?ied_unijointyp_u:ied_unijointyp_t;
               else
                 return (unp_c==0x2D7F)?ied_unijointyp_t:ied_unijointyp_u;
         else /* unp_c >= U+2DE0 */
           if(unp_c < 0xA67E)
             if(unp_c < 0x3099)
               if(unp_c < 0x302A)
                 return (unp_c<0x2E00)?ied_unijointyp_t:ied_unijointyp_u;
               else
                 return (unp_c<0x302E)?ied_unijointyp_t:ied_unijointyp_u;
             else /* unp_c >= U+3099 */
               if(unp_c < 0xA66F)
                 return (unp_c<0x309B)?ied_unijointyp_t:ied_unijointyp_u;
               else
                 return (unp_c==0xA673)?ied_unijointyp_u:ied_unijointyp_t;
           else /* unp_c >= U+A67E */
             if(unp_c < 0xA92E)
               if(unp_c < 0xA8E0)
                 switch(unp_c) {
                   case 0xA69F:
                   case 0xA6F0:
                   case 0xA6F1:
                   case 0xA802:
                   case 0xA806:
                   case 0xA80B:
                   case 0xA825:
                   case 0xA826:
                   case 0xA8C4: return ied_unijointyp_t;
                   default: return ied_unijointyp_u;
                 }
               else
                   if(unp_c < 0xA8F2)
                     return ied_unijointyp_t;
                   else
                     return (unp_c<0xA926)?ied_unijointyp_u:ied_unijointyp_t;
             else /* unp_c >= U+A92E */
               if(unp_c < 0xA983)
                   if(unp_c < 0xA952)
                     return (unp_c<0xA947)?ied_unijointyp_u:ied_unijointyp_t;
                   else
                     return (unp_c<0xA980)?ied_unijointyp_u:ied_unijointyp_t;
               else
                 return (unp_c<0xA9B3)?ied_unijointyp_u:ied_unijointyp_t;
     else /* unp_c >= U+A9B4 */
       if(unp_c < 0x11080)
         if(unp_c < 0xFE00)
           if(unp_c < 0xAAB2)
             if(unp_c < 0xAA2F)
               if(unp_c < 0xA9BD)
                   if(unp_c < 0xA9BA)
                     return (unp_c<0xA9B6)?ied_unijointyp_u:ied_unijointyp_t;
                   else
                     return (unp_c<0xA9BC)?ied_unijointyp_u:ied_unijointyp_t;
               else
                 return (unp_c<0xAA29)?ied_unijointyp_u:ied_unijointyp_t;
             else /* unp_c >= U+AA2F */
               if(unp_c < 0xAA37)
                   if(unp_c < 0xAA33)
                     return (unp_c<0xAA31)?ied_unijointyp_u:ied_unijointyp_t;
                   else
                     return (unp_c<0xAA35)?ied_unijointyp_u:ied_unijointyp_t;
               else
                 switch(unp_c) {
                   case 0xAA43:
                   case 0xAA4C:
                   case 0xAAB0: return ied_unijointyp_t;
                   default: return ied_unijointyp_u;
                 }
           else /* unp_c >= U+AAB2 */
             if(unp_c < 0xAAC2)
               if(unp_c < 0xAAB7)
                 return (unp_c<0xAAB5)?ied_unijointyp_t:ied_unijointyp_u;
               else
                   if(unp_c < 0xAABE)
                     return (unp_c<0xAAB9)?ied_unijointyp_t:ied_unijointyp_u;
                   else
                     return (unp_c==0xAAC0)?ied_unijointyp_u:ied_unijointyp_t;
             else /* unp_c >= U+AAC2 */
               if(unp_c < 0xAAEE)
                 return (unp_c<0xAAEC)?ied_unijointyp_u:ied_unijointyp_t;
               else
                 switch(unp_c) {
                   case 0xAAF6:
                   case 0xABE5:
                   case 0xABE8:
                   case 0xABED:
                   case 0xFB1E: return ied_unijointyp_t;
                   default: return ied_unijointyp_u;
                 }
         else /* unp_c >= U+FE00 */
           if(unp_c < 0x10A01)
             if(unp_c < 0xFF00)
               if(unp_c < 0xFE27)
                   if(unp_c < 0xFE10)
                     return ied_unijointyp_t;
                   else
                     return (unp_c<0xFE20)?ied_unijointyp_u:ied_unijointyp_t;
               else
                 return (unp_c<0xFEFF)?ied_unijointyp_u:ied_unijointyp_t;
             else /* unp_c >= U+FF00 */
               if(unp_c < 0xFFFC)
                 return (unp_c<0xFFF9)?ied_unijointyp_u:ied_unijointyp_t;
               else
                 return (unp_c==0x101FD)?ied_unijointyp_t:ied_unijointyp_u;
           else /* unp_c >= U+10A01 */
             if(unp_c < 0x10A3B)
               if(unp_c < 0x10A10)
                   if(unp_c < 0x10A07)
                     return (unp_c==0x10A04)?ied_unijointyp_u:ied_unijointyp_t;
                   else
                     return (unp_c<0x10A0C)?ied_unijointyp_u:ied_unijointyp_t;
               else
                 return (unp_c<0x10A38)?ied_unijointyp_u:ied_unijointyp_t;
             else /* unp_c >= U+10A3B */
               if(unp_c < 0x11038)
                 switch(unp_c) {
                   case 0x10A3F:
                   case 0x11001: return ied_unijointyp_t;
                   default: return ied_unijointyp_u;
                 }
               else
                 return (unp_c<0x11047)?ied_unijointyp_t:ied_unijointyp_u;
       else /* unp_c >= U+11080 */
         if(unp_c < 0x116B8)
           if(unp_c < 0x11135)
             if(unp_c < 0x110BD)
               if(unp_c < 0x110B3)
                 return (unp_c<0x11082)?ied_unijointyp_t:ied_unijointyp_u;
               else
                   if(unp_c < 0x110B9)
                     return (unp_c<0x110B7)?ied_unijointyp_t:ied_unijointyp_u;
                   else
                     return (unp_c<0x110BB)?ied_unijointyp_t:ied_unijointyp_u;
             else /* unp_c >= U+110BD */
               if(unp_c < 0x11100)
                 return (unp_c<0x110BE)?ied_unijointyp_t:ied_unijointyp_u;
               else
                   if(unp_c < 0x11127)
                     return (unp_c<0x11103)?ied_unijointyp_t:ied_unijointyp_u;
                   else
                     return (unp_c==0x1112C)?ied_unijointyp_u:ied_unijointyp_t;
           else /* unp_c >= U+11135 */
             if(unp_c < 0x111B6)
               if(unp_c < 0x11180)
                 return ied_unijointyp_u;
               else
                 return (unp_c<0x11182)?ied_unijointyp_t:ied_unijointyp_u;
             else /* unp_c >= U+111B6 */
               if(unp_c < 0x116AB)
                 return (unp_c<0x111BF)?ied_unijointyp_t:ied_unijointyp_u;
               else
                 switch(unp_c) {
                   case 0x116AC:
                   case 0x116AE:
                   case 0x116AF:
                   case 0x116B6: return ied_unijointyp_u;
                   default: return ied_unijointyp_t;
                 }
         else /* unp_c >= U+116B8 */
           if(unp_c < 0x1D1AE)
             if(unp_c < 0x1D16A)
               if(unp_c < 0x16F93)
                 return (unp_c<0x16F8F)?ied_unijointyp_u:ied_unijointyp_t;
               else
                 return (unp_c<0x1D167)?ied_unijointyp_u:ied_unijointyp_t;
             else /* unp_c >= U+1D16A */
               if(unp_c < 0x1D18C)
                   if(unp_c < 0x1D183)
                     return (unp_c<0x1D173)?ied_unijointyp_u:ied_unijointyp_t;
                   else
                     return (unp_c<0x1D185)?ied_unijointyp_u:ied_unijointyp_t;
               else
                 return (unp_c<0x1D1AA)?ied_unijointyp_u:ied_unijointyp_t;
           else /* unp_c >= U+1D1AE */
             if(unp_c < 0xE0020)
               if(unp_c < 0x1D245)
                 return (unp_c<0x1D242)?ied_unijointyp_u:ied_unijointyp_t;
               else
                 return (unp_c==0xE0001)?ied_unijointyp_t:ied_unijointyp_u;
             else /* unp_c >= U+E0020 */
               if(unp_c < 0xE0100)
                 return (unp_c<0xE0080)?ied_unijointyp_t:ied_unijointyp_u;
               else
                 return (unp_c<0xE01F0)?ied_unijointyp_t:ied_unijointyp_u;
} /* end m_get_unicode_joining_type()                                  */

/**
* Gets the Canonical_Combining_Class property for a codepoint.
* See chapter 4.2 of the unicode standard, or section 5.7.4 of its UAX #44
*  @param unp_c the codepoint
*  @return the Canonical Combining Class of unp_c
*/
int m_get_unicode_canonical_combining_class(unsigned int unp_c) {
   if(unp_c < 0x1A7D)
     if(unp_c < 0x073D)
       if(unp_c < 0x0488)
         if(unp_c < 0x034D)
           if(unp_c < 0x0339)
             if(unp_c < 0x0315)
               return (unp_c<0x0300)?0:230;
             else /* unp_c >= U+0315 */
               if(unp_c < 0x0334)
                 switch(unp_c) {
                   case 0x0315: case 0x031A: return 232;
                   case 0x031B: return 216;
                   case 0x0321: case 0x0322: case 0x0327: case 0x0328: return 202;
                   default: return 220;
                 }
               else
                 return 1;
           else /* unp_c >= U+0339 */
             if(unp_c < 0x0347)
               if(unp_c < 0x033D)
                 return 220;
               else
                 return (unp_c==0x0345)?240:230;
             else /* unp_c >= U+0347 */
               return (unp_c<0x034A)?220:230;
         else /* unp_c >= U+034D */
           if(unp_c < 0x035C)
             if(unp_c < 0x0350)
               return (unp_c<0x034F)?220:0;
             else /* unp_c >= U+0350 */
               if(unp_c < 0x0353)
                 return 230;
               else
                 switch(unp_c) {
                   case 0x0357: case 0x035B: return 230;
                   case 0x0358: return 232;
                   default: return 220;
                 }
           else /* unp_c >= U+035C */
             if(unp_c < 0x0370)
               if(unp_c < 0x0363)
                 switch(unp_c) {
                   case 0x035C: case 0x035F: case 0x0362: return 233;
                   default: return 234;
                 }
               else
                 return 230;
             else /* unp_c >= U+0370 */
               return (unp_c<0x0483)?0:230;
       else /* unp_c >= U+0488 */
         if(unp_c < 0x0618)
           if(unp_c < 0x05B0)
             if(unp_c < 0x05A2)
               if(unp_c < 0x0591)
                 return 0;
               else
                 switch(unp_c) {
                   case 0x0591: case 0x0596: case 0x059B: return 220;
                   case 0x059A: return 222;
                   default: return 230;
                 }
             else /* unp_c >= U+05A2 */
               if(unp_c < 0x05A8)
                 return 220;
               else
                 switch(unp_c) {
                   case 0x05AA: return 220;
                   case 0x05AD: return 222;
                   case 0x05AE: return 228;
                   default: return 230;
                 }
           else /* unp_c >= U+05B0 */
             if(unp_c < 0x05BE)
               return (int)((unp_c<0x05BA)?(unp_c-0x5A6):(unp_c-0x5A7));
             else /* unp_c >= U+05BE */
               if(unp_c < 0x0610)
                 switch(unp_c) {
                   case 0x05C7: return 18;
                   case 0x05BF: return 23;
                   case 0x05C1: return 24;
                   case 0x05C2: return 25;
                   case 0x05C5: return 220;
                   case 0x05C4: return 230;
                   default: return 0;
                 }
               else
                 return 230;
         else /* unp_c >= U+0618 */
           if(unp_c < 0x0660)
             if(unp_c < 0x064B)
               return (int)((unp_c<0x061B)?(unp_c-0x5FA):0);
             else /* unp_c >= U+064B */
               if(unp_c < 0x0653)
                 return (int)(unp_c-0x630);
               else
                 switch(unp_c) {
                   case 0x0655: case 0x0656: case 0x065C: case 0x065F: return 220;
                   default: return 230;
                 }
           else /* unp_c >= U+0660 */
             if(unp_c < 0x06EE)
               if(unp_c < 0x06D6)
                 return (unp_c==0x0670)?35:0;
               else
                 switch(unp_c) {
                   case 0x06DD: case 0x06DE: case 0x06E5: case 0x06E6: case 0x06E9: return 0;
                   case 0x06E3: case 0x06EA: case 0x06ED: return 220;
                   default: return 230;
                 }
             else /* unp_c >= U+06EE */
               if(unp_c < 0x0730)
                 return (unp_c==0x0711)?36:0;
               else
                 switch(unp_c) {
                   case 0x0730: case 0x0732: case 0x0733: case 0x0735:
                   case 0x0736: case 0x073A: return 230;
                   default: return 220;
                 }
     else /* unp_c >= U+073D */
       if(unp_c < 0x0F18)
         if(unp_c < 0x08E4)
           if(unp_c < 0x0816)
             if(unp_c < 0x07EB)
               if(unp_c < 0x074B)
                 switch(unp_c) {
                   case 0x073E: case 0x0742: case 0x0744: case 0x0746: case 0x0748: return 220;
                   default: return 230;
                 }
               else
                 return 0;
             else /* unp_c >= U+07EB */
               if(unp_c < 0x07F4)
                 return (unp_c==0x07F2)?220:230;
               else
                 return 0;
           else /* unp_c >= U+0816 */
             if(unp_c < 0x0859)
               if(unp_c < 0x082E)
                 switch(unp_c) {
                   case 0x081A: case 0x0824: case 0x0828: return 0;
                   default: return 230;
                 }
               else
                 return 0;
             else /* unp_c >= U+0859 */
               return (unp_c<0x085C)?220:0;
         else /* unp_c >= U+08E4 */
           if(unp_c < 0x0EB8)
             if(unp_c < 0x0E48)
               if(unp_c < 0x08FF)
                 switch(unp_c) {
                   case 0x08F0: return 27;
                   case 0x08F1: return 28;
                   case 0x08F2: return 29;
                   case 0x08E6: case 0x08E9: case 0x08ED: case 0x08EE:
                   case 0x08EF: case 0x08F6: case 0x08F9: case 0x08FA: return 220;
                   default: return 230;
                 }
               else
                 switch(unp_c) {
                   case 0x093C: case 0x09BC: case 0x0A3C: case 0x0ABC:
                   case 0x0B3C: case 0x0CBC: return 7;
                   case 0x094D: case 0x09CD: case 0x0A4D: case 0x0ACD:
                   case 0x0B4D: case 0x0BCD: case 0x0C4D: case 0x0CCD:
                   case 0x0D4D: case 0x0DCA: case 0x0E3A: return 9;
                   case 0x0C55: return 84;
                   case 0x0C56: return 91;
                   case 0x0E38: case 0x0E39: return 103;
                   case 0x0952: return 220;
                   case 0x0951: case 0x0953: case 0x0954: return 230;
                   default: return 0;
                 }
             else /* unp_c >= U+0E48 */
               return (unp_c<0x0E4C)?107:0;
           else /* unp_c >= U+0EB8 */
             if(unp_c < 0x0EC8)
               return (unp_c<0x0EBA)?118:0;
             else /* unp_c >= U+0EC8 */
               return (unp_c<0x0ECC)?122:0;
       else /* unp_c >= U+0F18 */
         if(unp_c < 0x0F85)
           if(unp_c < 0x0F80)
             if(unp_c < 0x0F7A)
               if(unp_c < 0x0F1A)
                 return 220;
               else
                 switch(unp_c) {
                   case 0x0F71: return 129;
                   case 0x0F72: return 130;
                   case 0x0F74: return 132;
                   case 0x0F39: return 216;
                   case 0x0F35: case 0x0F37: return 220;
                   default: return 0;
                 }
             else /* unp_c >= U+0F7A */
               return (unp_c<0x0F7E)?130:0;
           else /* unp_c >= U+0F80 */
             if(unp_c < 0x0F82)
               return (unp_c<0x0F81)?130:0;
             else /* unp_c >= U+0F82 */
               return (unp_c<0x0F84)?230:9;
         else /* unp_c >= U+0F85 */
           if(unp_c < 0x103B)
             if(unp_c < 0x0F88)
               return (unp_c<0x0F86)?0:230;
             else /* unp_c >= U+0F88 */
               if(unp_c < 0x1039)
                 switch(unp_c) {
                   case 0x1037: return 7;
                   case 0x0FC6: return 220;
                   default: return 0;
                 }
               else
                 return 9;
           else /* unp_c >= U+103B */
             if(unp_c < 0x1360)
               if(unp_c < 0x135D)
                 return (unp_c==0x108D)?220:0;
               else
                 return 230;
             else /* unp_c >= U+1360 */
               if(unp_c < 0x1A75)
                 switch(unp_c) {
                   case 0x1714: case 0x1734: case 0x17D2: case 0x1A60: return 9;
                   case 0x193B: case 0x1A18: return 220;
                   case 0x1939: return 222;
                   case 0x18A9: return 228;
                   case 0x17DD: case 0x193A: case 0x1A17: return 230;
                   default: return 0;
                 }
               else
                 return 230;
   else /* unp_c >= U+1A7D */
     if(unp_c < 0xA670)
       if(unp_c < 0x20D2)
         if(unp_c < 0x1CDC)
           if(unp_c < 0x1CD3)
             if(unp_c < 0x1B74)
               if(unp_c < 0x1B6D)
                 switch(unp_c) {
                   case 0x1B34: return 7;
                   case 0x1B44: return 9;
                   case 0x1A7F: case 0x1B6C: return 220;
                   case 0x1B6B: return 230;
                   default: return 0;
                 }
               else
                 return 230;
             else /* unp_c >= U+1B74 */
               if(unp_c < 0x1CD0)
                 switch(unp_c) {
                   case 0x1BE6: case 0x1C37: return 7;
                   case 0x1BAA: case 0x1BAB: case 0x1BF2: case 0x1BF3: return 9;
                   default: return 0;
                 }
               else
                 return 230;
           else /* unp_c >= U+1CD3 */
             if(unp_c < 0x1CD5)
               return (unp_c<0x1CD4)?0:1;
             else /* unp_c >= U+1CD5 */
               return (unp_c<0x1CDA)?220:230;
         else /* unp_c >= U+1CDC */
           if(unp_c < 0x1CE9)
             if(unp_c < 0x1CE1)
               return (unp_c<0x1CE0)?220:230;
             else /* unp_c >= U+1CE1 */
               return (unp_c<0x1CE2)?0:1;
           else /* unp_c >= U+1CE9 */
             if(unp_c < 0x1DE7)
               if(unp_c < 0x1DC0)
                 switch(unp_c) {
                   case 0x1CED: return 220;
                   case 0x1CF4: return 230;
                   default: return 0;
                 }
               else
                 switch(unp_c) {
                   case 0x1DD0: return 202;
                   case 0x1DCE: return 214;
                   case 0x1DC2: case 0x1DCA: case 0x1DCF: return 220;
                   case 0x1DCD: return 234;
                   default: return 230;
                 }
             else /* unp_c >= U+1DE7 */
               if(unp_c < 0x20D0)
                 switch(unp_c) {
                   case 0x1DFD: case 0x1DFF: return 220;
                   case 0x1DFE: return 230;
                   case 0x1DFC: return 233;
                   default: return 0;
                 }
               else
                 return 230;
       else /* unp_c >= U+20D2 */
         if(unp_c < 0x20F1)
           if(unp_c < 0x20DD)
             if(unp_c < 0x20D8)
               return (unp_c<0x20D4)?1:230;
             else /* unp_c >= U+20D8 */
               return (unp_c<0x20DB)?1:230;
           else /* unp_c >= U+20DD */
             if(unp_c < 0x20EC)
               if(unp_c < 0x20E5)
                 return (unp_c==0x20E1)?230:0;
               else
                 switch(unp_c) {
                   case 0x20E8: return 220;
                   case 0x20E7: case 0x20E9: return 230;
                   default: return 1;
                 }
             else /* unp_c >= U+20EC */
               return (unp_c<0x20F0)?220:230;
         else /* unp_c >= U+20F1 */
           if(unp_c < 0x2E00)
             if(unp_c < 0x2CF2)
               return (unp_c<0x2CEF)?0:230;
             else /* unp_c >= U+2CF2 */
               if(unp_c < 0x2DE0)
                 return (unp_c==0x2D7F)?9:0;
               else
                 return 230;
           else /* unp_c >= U+2E00 */
             if(unp_c < 0x309B)
               if(unp_c < 0x3099)
                 switch(unp_c) {
                   case 0x302A: return 218;
                   case 0x302D: return 222;
                   case 0x302E: case 0x302F: return 224;
                   case 0x302B: return 228;
                   case 0x302C: return 232;
                   default: return 0;
                 }
               else
                 return 8;
             else /* unp_c >= U+309B */
               return (unp_c<0xA66F)?0:230;
     else /* unp_c >= U+A670 */
       if(unp_c < 0x116B8)
         if(unp_c < 0xFB1E)
           if(unp_c < 0xA8F2)
             if(unp_c < 0xA67E)
               return (unp_c<0xA674)?0:230;
             else /* unp_c >= U+A67E */
               if(unp_c < 0xA8E0)
                 switch(unp_c) {
                   case 0xA806: case 0xA8C4: return 9;
                   case 0xA69F: case 0xA6F0: case 0xA6F1: return 230;
                   default: return 0;
                 }
               else
                 return 230;
           else /* unp_c >= U+A8F2 */
             if(unp_c < 0xA92E)
               return (unp_c<0xA92B)?0:220;
             else /* unp_c >= U+A92E */
               if(unp_c < 0xABEE)
                 switch(unp_c) {
                   case 0xA9B3: return 7;
                   case 0xA953: case 0xA9C0: case 0xAAF6: case 0xABED: return 9;
                   case 0xAAB4: return 220;
                   case 0xAAB0: case 0xAAB2: case 0xAAB3: case 0xAAB7:
                   case 0xAAB8: case 0xAABE: case 0xAABF: case 0xAAC1: return 230;
                   default: return 0;
                 }
               else
                 return 0;
         else /* unp_c >= U+FB1E */
           if(unp_c < 0x11100)
             if(unp_c < 0xFE20)
               return (unp_c<0xFB1F)?26:0;
             else /* unp_c >= U+FE20 */
               if(unp_c < 0xFE27)
                 return 230;
               else
                 switch(unp_c) {
                   case 0x10A39: return 1;
                   case 0x110BA: return 7;
                   case 0x10A3F: case 0x11046: case 0x110B9: return 9;
                   case 0x101FD: case 0x10A0D: case 0x10A3A: return 220;
                   case 0x10A0F: case 0x10A38: return 230;
                   default: return 0;
                 }
           else /* unp_c >= U+11100 */
             if(unp_c < 0x11133)
               return (unp_c<0x11103)?230:0;
             else /* unp_c >= U+11133 */
               if(unp_c < 0x11135)
                 return 9;
               else
                 switch(unp_c) {
                   case 0x116B7: return 7;
                   case 0x111C0: case 0x116B6: return 9;
                   default: return 0;
                 }
       else /* unp_c >= U+116B8 */
         if(unp_c < 0x1D183)
           if(unp_c < 0x1D16D)
             if(unp_c < 0x1D167)
               return (unp_c<0x1D165)?0:216;
             else /* unp_c >= U+1D167 */
               return (unp_c<0x1D16A)?1:0;
           else /* unp_c >= U+1D16D */
             if(unp_c < 0x1D173)
               return (unp_c<0x1D16E)?226:216;
             else /* unp_c >= U+1D173 */
               return (unp_c<0x1D17B)?0:220;
         else /* unp_c >= U+1D183 */
           if(unp_c < 0x1D1AA)
             if(unp_c < 0x1D18A)
               return (unp_c<0x1D185)?0:230;
             else /* unp_c >= U+1D18A */
               return (unp_c<0x1D18C)?220:0;
           else /* unp_c >= U+1D1AA */
             if(unp_c < 0x1D242)
               return (unp_c<0x1D1AE)?230:0;
             else /* unp_c >= U+1D242 */
               return (unp_c<0x1D245)?230:0;
} /* end m_get_unicode_canonical_combining_class()                     */

/**
* Whether it has general category of combining mark (Mc, Mn or Me).
*  @param unp_c the codepoint
*  @return whether unp_c fulfils the condition
*/
BOOL m_get_unicode_is_combining(unsigned int unp_c) {
   if(unp_c < 0x1735)
     if(unp_c < 0x0C3E)
       if(unp_c < 0x0A43)
         if(unp_c < 0x0964)
           if(unp_c < 0x07B1)
             if(unp_c < 0x048A)
               if(unp_c < 0x0370)
                 return (unp_c>=0x0300);
               else
                 return (unp_c>=0x0483);
             else /* unp_c >= U+048A */
               if(unp_c < 0x07A6)
                 return (m_get_unicode_canonical_combining_class(unp_c)!=0);
               else
                 return TRUE;
           else /* unp_c >= U+07B1 */
             if(unp_c < 0x093A)
               if(unp_c < 0x0900)
                 return (m_get_unicode_canonical_combining_class(unp_c)!=0);
               else
                 return (unp_c<0x0904);
             else /* unp_c >= U+093A */
               if(unp_c < 0x0951)
                   if(unp_c < 0x093E)
                     return (unp_c!=0x093D);
                   else
                     return (unp_c!=0x0950);
               else
                   if(unp_c < 0x0958)
                     return TRUE;
                   else
                     return (unp_c>=0x0962);
         else /* unp_c >= U+0964 */
           if(unp_c < 0x09CE)
             if(unp_c < 0x09BE)
               if(unp_c < 0x0984)
                 return (unp_c>=0x0981);
               else
                 return (m_get_unicode_canonical_combining_class(unp_c)!=0);
             else /* unp_c >= U+09BE */
               if(unp_c < 0x09C5)
                 return TRUE;
               else
                   if(unp_c < 0x09C9)
                     return (unp_c>=0x09C7);
                   else
                     return (unp_c>=0x09CB);
           else /* unp_c >= U+09CE */
             if(unp_c < 0x0A04)
               if(unp_c < 0x09E2)
                 return (unp_c==0x09D7);
               else
                   if(unp_c < 0x0A01)
                     return (unp_c<0x09E4);
                   else
                     return TRUE;
             else /* unp_c >= U+0A04 */
               if(unp_c < 0x0A3E)
                 return (m_get_unicode_canonical_combining_class(unp_c)!=0);
               else
                 return TRUE;
       else /* unp_c >= U+0A43 */
         if(unp_c < 0x0B04)
           if(unp_c < 0x0A84)
             if(unp_c < 0x0A70)
               if(unp_c < 0x0A4E)
                   if(unp_c < 0x0A49)
                     return (unp_c>=0x0A47);
                   else
                     return (unp_c>=0x0A4B);
               else
                 return (unp_c==0x0A51);
             else /* unp_c >= U+0A70 */
               if(unp_c < 0x0A81)
                   if(unp_c < 0x0A72)
                     return TRUE;
                   else
                     return (unp_c==0x0A75);
               else
                 return TRUE;
           else /* unp_c >= U+0A84 */
             if(unp_c < 0x0ACE)
               if(unp_c < 0x0ABE)
                 return (m_get_unicode_canonical_combining_class(unp_c)!=0);
               else
                   if(unp_c < 0x0AC6)
                     return TRUE;
                   else
                     return ((unp_c!=0x0AC6)&&(unp_c!=0x0ACA));
             else /* unp_c >= U+0ACE */
               if(unp_c < 0x0AE4)
                 return (unp_c>=0x0AE2);
               else
                 return (unp_c>=0x0B01);
         else /* unp_c >= U+0B04 */
           if(unp_c < 0x0B64)
             if(unp_c < 0x0B45)
               if(unp_c < 0x0B3E)
                 return (m_get_unicode_canonical_combining_class(unp_c)!=0);
               else
                 return TRUE;
             else /* unp_c >= U+0B45 */
               if(unp_c < 0x0B4E)
                   if(unp_c < 0x0B49)
                     return (unp_c>=0x0B47);
                   else
                     return (unp_c>=0x0B4B);
               else
                   if(unp_c < 0x0B58)
                     return (unp_c>=0x0B56);
                   else
                     return (unp_c>=0x0B62);
           else /* unp_c >= U+0B64 */
             if(unp_c < 0x0BCE)
               if(unp_c < 0x0BBE)
                 return (unp_c==0x0B82);
               else
                   if(unp_c < 0x0BC6)
                     return (unp_c<0x0BC3);
                   else
                     return (unp_c!=0x0BC9);
             else /* unp_c >= U+0BCE */
               if(unp_c < 0x0C01)
                 return (unp_c==0x0BD7);
               else
                 return (unp_c<0x0C04);
     else /* unp_c >= U+0C3E */
       if(unp_c < 0x0E4F)
         if(unp_c < 0x0D3E)
           if(unp_c < 0x0CBC)
             if(unp_c < 0x0C62)
               if(unp_c < 0x0C4E)
                 return ((unp_c!=0x0C45)&&(unp_c!=0x0C49));
               else
                 return (m_get_unicode_canonical_combining_class(unp_c)!=0);
             else /* unp_c >= U+0C62 */
               if(unp_c < 0x0C82)
                 return (unp_c<0x0C64);
               else
                 return (unp_c<0x0C84);
           else /* unp_c >= U+0CBC */
             if(unp_c < 0x0CE4)
               if(unp_c < 0x0CCE)
                 return ((unp_c!=0x0CBD)&&(unp_c!=0x0CC5)&&(unp_c!=0x0CC9));
               else
                   if(unp_c < 0x0CD7)
                     return (unp_c>=0x0CD5);
                   else
                     return (unp_c>=0x0CE2);
             else /* unp_c >= U+0CE4 */
               if(unp_c < 0x0D04)
                 return (unp_c>=0x0D02);
               else
                 return FALSE;
         else /* unp_c >= U+0D3E */
           if(unp_c < 0x0DCF)
             if(unp_c < 0x0D62)
               if(unp_c < 0x0D4E)
                 return ((unp_c!=0x0D45)&&(unp_c!=0x0D49));
               else
                 return (unp_c==0x0D57);
             else /* unp_c >= U+0D62 */
               if(unp_c < 0x0D84)
                   if(unp_c < 0x0D82)
                     return (unp_c<0x0D64);
                   else
                     return TRUE;
               else
                 return (unp_c==0x0DCA);
           else /* unp_c >= U+0DCF */
             if(unp_c < 0x0DF4)
               if(unp_c < 0x0DE0)
                 return ((unp_c!=0x0DD5)&&(unp_c!=0x0DD7));
               else
                 return (unp_c>=0x0DF2);
             else /* unp_c >= U+0DF4 */
               if(unp_c < 0x0E34)
                 return (unp_c==0x0E31);
               else
                   if(unp_c < 0x0E47)
                     return (unp_c<0x0E3B);
                   else
                     return TRUE;
       else /* unp_c >= U+0E4F */
         if(unp_c < 0x1056)
           if(unp_c < 0x0F71)
             if(unp_c < 0x0ECE)
               if(unp_c < 0x0EB4)
                 return (unp_c==0x0EB1);
               else
                   if(unp_c < 0x0EBD)
                     return (unp_c!=0x0EBA);
                   else
                     return (unp_c>=0x0EC8);
             else /* unp_c >= U+0ECE */
               if(unp_c < 0x0F3E)
                 return (m_get_unicode_canonical_combining_class(unp_c)!=0);
               else
                 return (unp_c<0x0F40);
           else /* unp_c >= U+0F71 */
             if(unp_c < 0x0FBD)
               if(unp_c < 0x0F8D)
                   if(unp_c < 0x0F85)
                     return TRUE;
                   else
                     return (m_get_unicode_canonical_combining_class(unp_c)!=0);
               else
                 return (unp_c!=0x0F98);
             else /* unp_c >= U+0FBD */
               if(unp_c < 0x102B)
                 return (m_get_unicode_canonical_combining_class(unp_c)!=0);
               else
                 return (unp_c<0x103F);
         else /* unp_c >= U+1056 */
           if(unp_c < 0x109A)
             if(unp_c < 0x1075)
               if(unp_c < 0x1065)
                   if(unp_c < 0x105E)
                     return (unp_c<0x105A);
                   else
                     return (unp_c!=0x1061);
               else
                   if(unp_c < 0x106E)
                     return (unp_c>=0x1067);
                   else
                     return (unp_c>=0x1071);
             else /* unp_c >= U+1075 */
               if(unp_c < 0x108E)
                 return (unp_c>=0x1082);
               else
                 return (unp_c==0x108F);
           else /* unp_c >= U+109A */
             if(unp_c < 0x1360)
               if(unp_c < 0x135D)
                 return (unp_c<0x109E);
               else
                 return TRUE;
             else /* unp_c >= U+1360 */
               if(unp_c < 0x1715)
                 return (unp_c>=0x1712);
               else
                 return (unp_c>=0x1732);
   else /* unp_c >= U+1735 */
     if(unp_c < 0xA8B4)
       if(unp_c < 0x1B80)
         if(unp_c < 0x19B0)
           if(unp_c < 0x180B)
             if(unp_c < 0x1774)
               if(unp_c < 0x1754)
                 return (unp_c>=0x1752);
               else
                 return (unp_c>=0x1772);
             else /* unp_c >= U+1774 */
               if(unp_c < 0x17D4)
                 return (unp_c>=0x17B4);
               else
                 return (m_get_unicode_canonical_combining_class(unp_c)!=0);
           else /* unp_c >= U+180B */
             if(unp_c < 0x1920)
               if(unp_c < 0x180E)
                 return TRUE;
               else
                 return (m_get_unicode_canonical_combining_class(unp_c)!=0);
             else /* unp_c >= U+1920 */
               if(unp_c < 0x1930)
                 return (unp_c<0x192C);
               else
                 return (unp_c<0x193C);
         else /* unp_c >= U+19B0 */
           if(unp_c < 0x1A7D)
             if(unp_c < 0x1A17)
               if(unp_c < 0x19C8)
                 return (unp_c<0x19C1);
               else
                 return (unp_c<0x19CA);
             else /* unp_c >= U+1A17 */
               if(unp_c < 0x1A55)
                 return (unp_c<0x1A1C);
               else
                 return (unp_c!=0x1A5F);
           else /* unp_c >= U+1A7D */
             if(unp_c < 0x1B34)
               if(unp_c < 0x1B00)
                 return (unp_c==0x1A7F);
               else
                 return (unp_c<0x1B05);
             else /* unp_c >= U+1B34 */
               if(unp_c < 0x1B45)
                 return TRUE;
               else
                 return (m_get_unicode_canonical_combining_class(unp_c)!=0);
       else /* unp_c >= U+1B80 */
         if(unp_c < 0x20F1)
           if(unp_c < 0x1CD0)
             if(unp_c < 0x1BE6)
               if(unp_c < 0x1BA1)
                 return (unp_c<0x1B83);
               else
                 return (unp_c<0x1BAE);
             else /* unp_c >= U+1BE6 */
               if(unp_c < 0x1C24)
                 return (unp_c<0x1BF4);
               else
                 return (unp_c<0x1C38);
           else /* unp_c >= U+1CD0 */
             if(unp_c < 0x1CF5)
               if(unp_c < 0x1CE9)
                 return (unp_c!=0x1CD3);
               else
                   if(unp_c < 0x1CF2)
                     return (unp_c==0x1CED);
                   else
                     return TRUE;
             else /* unp_c >= U+1CF5 */
               if(unp_c < 0x1E00)
                 return (m_get_unicode_canonical_combining_class(unp_c)!=0);
               else
                 return (unp_c>=0x20D0);
         else /* unp_c >= U+20F1 */
           if(unp_c < 0xA67E)
             if(unp_c < 0x309B)
               if(unp_c < 0x2CEF)
                 return FALSE;
               else
                 return (m_get_unicode_canonical_combining_class(unp_c)!=0);
             else /* unp_c >= U+309B */
               if(unp_c < 0xA66F)
                 return FALSE;
               else
                 return (unp_c!=0xA673);
           else /* unp_c >= U+A67E */
             if(unp_c < 0xA823)
               if(unp_c < 0xA6F2)
                 return (m_get_unicode_canonical_combining_class(unp_c)!=0);
               else
                 return ((unp_c==0xA802)||(unp_c==0xA806)||(unp_c==0xA80B));
             else /* unp_c >= U+A823 */
               if(unp_c < 0xA880)
                 return (unp_c<0xA828);
               else
                 return (unp_c<0xA882);
     else /* unp_c >= U+A8B4 */
       if(unp_c < 0x10A01)
         if(unp_c < 0xAA4E)
           if(unp_c < 0xA980)
             if(unp_c < 0xA926)
               if(unp_c < 0xA8C5)
                 return TRUE;
               else
                 return (m_get_unicode_canonical_combining_class(unp_c)!=0);
             else /* unp_c >= U+A926 */
               if(unp_c < 0xA947)
                 return (unp_c<0xA92E);
               else
                 return (unp_c<0xA954);
           else /* unp_c >= U+A980 */
             if(unp_c < 0xAA29)
               if(unp_c < 0xA9B3)
                 return (unp_c<0xA984);
               else
                 return (unp_c<0xA9C1);
             else /* unp_c >= U+AA29 */
               if(unp_c < 0xAA43)
                 return (unp_c<0xAA37);
               else
                   if(unp_c < 0xAA44)
                     return (unp_c==0xAA43);
                   else
                     return (unp_c>=0xAA4C);
         else /* unp_c >= U+AA4E */
           if(unp_c < 0xABE3)
             if(unp_c < 0xAAEB)
               if(unp_c < 0xAAB0)
                 return (unp_c==0xAA7B);
               else
                 return (m_get_unicode_canonical_combining_class(unp_c)!=0);
             else /* unp_c >= U+AAEB */
               if(unp_c < 0xAAF5)
                 return (unp_c<0xAAF0);
               else
                 return (unp_c<0xAAF7);
           else /* unp_c >= U+ABE3 */
             if(unp_c < 0xFE00)
               if(unp_c < 0xABEE)
                 return (unp_c!=0xABEB);
               else
                 return (unp_c==0xFB1E);
             else /* unp_c >= U+FE00 */
               if(unp_c < 0xFE10)
                 return TRUE;
               else
                 return (m_get_unicode_canonical_combining_class(unp_c)!=0);
       else /* unp_c >= U+10A01 */
         if(unp_c < 0x11180)
           if(unp_c < 0x11047)
             if(unp_c < 0x11000)
               if(unp_c < 0x10A10)
                   if(unp_c < 0x10A07)
                     return (unp_c!=0x10A04);
                   else
                     return (unp_c>=0x10A0C);
               else
                 return (m_get_unicode_canonical_combining_class(unp_c)!=0);
             else /* unp_c >= U+11000 */
               if(unp_c < 0x11038)
                 return (unp_c<0x11003);
               else
                 return TRUE;
           else /* unp_c >= U+11047 */
             if(unp_c < 0x110BB)
               if(unp_c < 0x11083)
                 return (unp_c>=0x11080);
               else
                 return (unp_c>=0x110B0);
             else /* unp_c >= U+110BB */
               if(unp_c < 0x11127)
                 return (m_get_unicode_canonical_combining_class(unp_c)!=0);
               else
                 return (unp_c<0x11135);
         else /* unp_c >= U+11180 */
           if(unp_c < 0x16F8F)
             if(unp_c < 0x116AB)
               if(unp_c < 0x111B3)
                 return (unp_c<0x11183);
               else
                 return (unp_c<0x111C1);
             else /* unp_c >= U+116AB */
               if(unp_c < 0x16F51)
                 return (unp_c<0x116B8);
               else
                 return (unp_c<0x16F7F);
           else /* unp_c >= U+16F8F */
             if(unp_c < 0x1D245)
               if(unp_c < 0x1D165)
                 return (unp_c<0x16F93);
               else
                 return (m_get_unicode_canonical_combining_class(unp_c)!=0);
             else /* unp_c >= U+1D245 */
               if(unp_c < 0xE0100)
                 return FALSE;
               else
                 return (unp_c<0xE01F0);
} /* end m_get_unicode_is_combining()                                  */

/**
* Look up whether a codepoint is PVALID or CONTEXTO according to the rules
* of RFC 5892. Note that the two CONTEXTJ cases have to be detected separately.
*  @param unp_c the codepoint
*  @return whether unp_c fulfils the condition
*/
BOOL m_is_idna_allowed(unsigned int unp_c) {
   if(unp_c < 0x18B0)
     if(unp_c < 0x0BAB)
       if(unp_c < 0x08A2)
         if(unp_c < 0x0483)
           if(unp_c < 0x02B0)
             if(unp_c < 0x0132)
               if(unp_c < 0x007B)
                 if(unp_c < 0x003A)
                     if(unp_c < 0x002E)
                       return (unp_c>=0x002D);
                     else
                       return (unp_c>=0x0030);
                 else
                   return (unp_c>=0x0061);
               else /* unp_c >= U+007B */
                 if(unp_c < 0x00D8)
                     if(unp_c < 0x00B8)
                       return (unp_c>=0x00B7);
                     else
                       return FALSE;
                 else
                   return (unp_c==0x00F7)?FALSE:m_is_own_lowercase((int)unp_c);
             else /* unp_c >= U+0132 */
               if(unp_c < 0x0180)
                 if(unp_c < 0x014A)
                     if(unp_c < 0x0138)
                       return (unp_c<0x0134)?FALSE:((unp_c&1)!=0);
                     else
                       return (unp_c==0x0140)?FALSE:((unp_c&1)==0);
                 else
                   return (unp_c<0x0179)?((unp_c&1)!=0):((unp_c&1)==0);
               else /* unp_c >= U+0180 */
                 if(unp_c < 0x01CD)
                   return (unp_c<0x01C4)?m_is_own_lowercase((int)unp_c):FALSE;
                 else
                   return (unp_c==0x01F3)?FALSE:m_is_own_lowercase((int)unp_c);
           else /* unp_c >= U+02B0 */
             if(unp_c < 0x036F)
               if(unp_c < 0x02EF)
                 if(unp_c < 0x02D2)
                     if(unp_c < 0x02C2)
                       return (unp_c>=0x02B9);
                     else
                       return (unp_c>=0x02C6);
                 else
                   return (unp_c<0x02EB)?FALSE:((unp_c&1)==0);
               else /* unp_c >= U+02EF */
                 if(unp_c < 0x033E)
                   return (unp_c>=0x0300);
                 else
                     if(unp_c < 0x0346)
                       return (unp_c<0x0343)?((unp_c&2)!=0):FALSE;
                     else
                       return (unp_c!=0x034F);
             else /* unp_c >= U+036F */
               if(unp_c < 0x03D6)
                 if(unp_c < 0x0390)
                     if(unp_c < 0x037B)
                       return (unp_c<0x0378)?((unp_c&1)!=0):FALSE;
                     else
                       return (unp_c<0x037E);
                 else
                     if(unp_c < 0x03A3)
                       return (unp_c<0x0391);
                     else
                       return (unp_c<0x03CF)?m_is_own_lowercase((int)unp_c):FALSE;
               else /* unp_c >= U+03D6 */
                 if(unp_c < 0x03F7)
                     if(unp_c < 0x03F3)
                       return (unp_c<0x03F0)?((unp_c&1)!=0):FALSE;
                     else
                       return (unp_c<0x03F4);
                 else
                   return (unp_c<0x045F)?m_is_own_lowercase((int)unp_c):((unp_c&1)!=0);
         else /* unp_c >= U+0483 */
           if(unp_c < 0x0679)
             if(unp_c < 0x05D0)
               if(unp_c < 0x0587)
                 if(unp_c < 0x0528)
                   return (unp_c<0x048A)?((unp_c&8)==0):m_is_own_lowercase((int)unp_c);
                 else
                     if(unp_c < 0x055A)
                       return (unp_c>=0x0559);
                     else
                       return (unp_c>=0x0561);
               else /* unp_c >= U+0587 */
                 if(unp_c < 0x05BD)
                   return (unp_c>=0x0591);
                 else
                     if(unp_c < 0x05C5)
                       return (unp_c<0x05C2)?((unp_c&1)!=0):((unp_c&1)==0);
                     else
                       return (unp_c<0x05C8)?((unp_c&1)!=0):FALSE;
             else /* unp_c >= U+05D0 */
               if(unp_c < 0x0620)
                 if(unp_c < 0x05F5)
                   return (unp_c<0x05EB)?TRUE:((unp_c&8)==0);
                 else
                     if(unp_c < 0x061B)
                       return (unp_c>=0x0610);
                     else
                       return FALSE;
               else /* unp_c >= U+0620 */
                 if(unp_c < 0x066A)
                   return (unp_c!=0x0640);
                 else
                     if(unp_c < 0x0675)
                       return (unp_c>=0x066E);
                     else
                       return FALSE;
           else /* unp_c >= U+0679 */
             if(unp_c < 0x07B2)
               if(unp_c < 0x0700)
                 if(unp_c < 0x06DD)
                   return (unp_c!=0x06D4);
                 else
                     if(unp_c < 0x06DF)
                       return FALSE;
                     else
                       return (unp_c!=0x06E9);
               else /* unp_c >= U+0700 */
                 if(unp_c < 0x074B)
                   return (unp_c>=0x0710);
                 else
                   return (unp_c>=0x074D);
             else /* unp_c >= U+07B2 */
               if(unp_c < 0x082E)
                 if(unp_c < 0x07F6)
                   return (unp_c>=0x07C0);
                 else
                   return (unp_c>=0x0800);
               else /* unp_c >= U+082E */
                 if(unp_c < 0x085C)
                   return (unp_c>=0x0840);
                 else
                   return (unp_c<0x089F)?FALSE:((unp_c&1)==0);
       else /* unp_c >= U+08A2 */
         if(unp_c < 0x0A66)
           if(unp_c < 0x09CF)
             if(unp_c < 0x0985)
               if(unp_c < 0x0950)
                 if(unp_c < 0x08E4)
                   return (unp_c<0x08AD);
                 else
                   return (unp_c!=0x08FF);
               else /* unp_c >= U+0950 */
                 if(unp_c < 0x0968)
                   return (unp_c<0x0962)?((unp_c&8)==0):((unp_c&2)!=0);
                 else
                     if(unp_c < 0x0979)
                       return (unp_c<0x0971)?((unp_c&8)!=0):((unp_c&8)==0);
                     else
                       return (unp_c<0x0981)?((unp_c&8)!=0):((unp_c&4)==0);
             else /* unp_c >= U+0985 */
               if(unp_c < 0x09B0)
                 if(unp_c < 0x0993)
                     if(unp_c < 0x098F)
                       return (unp_c<0x098D);
                     else
                       return (unp_c<0x0991);
                 else
                   return (unp_c!=0x09A9);
               else /* unp_c >= U+09B0 */
                 if(unp_c < 0x09C5)
                     if(unp_c < 0x09B8)
                       return (unp_c<0x09B4)?((unp_c&1)==0):((unp_c&2)!=0);
                     else
                       return (unp_c<0x09BC)?((unp_c&2)==0):TRUE;
                 else
                     if(unp_c < 0x09C9)
                       return (unp_c>=0x09C7);
                     else
                       return (unp_c>=0x09CB);
           else /* unp_c >= U+09CF */
             if(unp_c < 0x0A30)
               if(unp_c < 0x0A0B)
                 if(unp_c < 0x09E6)
                     if(unp_c < 0x09D8)
                       return (unp_c>=0x09D7);
                     else
                       return (unp_c<0x09DC)?FALSE:((unp_c&4)==0);
                 else
                     if(unp_c < 0x0A01)
                       return (unp_c<0x09F2);
                     else
                       return (unp_c<0x0A05)?((unp_c&4)==0):TRUE;
               else /* unp_c >= U+0A0B */
                 if(unp_c < 0x0A13)
                     if(unp_c < 0x0A11)
                       return (unp_c>=0x0A0F);
                     else
                       return FALSE;
                 else
                   return (unp_c!=0x0A29);
             else /* unp_c >= U+0A30 */
               if(unp_c < 0x0A47)
                 if(unp_c < 0x0A3E)
                     if(unp_c < 0x0A35)
                       return (unp_c<0x0A33)?((unp_c&1)==0):FALSE;
                     else
                       return (unp_c<0x0A3B)?((unp_c&2)==0):((unp_c&1)==0);
                 else
                   return (unp_c<0x0A43);
               else /* unp_c >= U+0A47 */
                 if(unp_c < 0x0A51)
                     if(unp_c < 0x0A4B)
                       return (unp_c<0x0A49);
                     else
                       return (unp_c<0x0A4E);
                 else
                     if(unp_c < 0x0A5C)
                       return (unp_c<0x0A52);
                     else
                       return (unp_c<0x0A5D);
         else /* unp_c >= U+0A66 */
           if(unp_c < 0x0B13)
             if(unp_c < 0x0ABC)
               if(unp_c < 0x0A93)
                 if(unp_c < 0x0A81)
                   return (unp_c<0x0A76);
                 else
                     if(unp_c < 0x0A8D)
                       return (unp_c<0x0A85)?((unp_c&4)==0):TRUE;
                     else
                       return (unp_c<0x0A90)?((unp_c&1)!=0):((unp_c&2)==0);
               else /* unp_c >= U+0A93 */
                 if(unp_c < 0x0AB1)
                   return (unp_c!=0x0AA9);
                 else
                     if(unp_c < 0x0ABA)
                       return (unp_c<0x0AB5)?((unp_c&2)!=0):TRUE;
                     else
                       return FALSE;
             else /* unp_c >= U+0ABC */
               if(unp_c < 0x0AE6)
                 if(unp_c < 0x0AD1)
                     if(unp_c < 0x0AC9)
                       return (unp_c!=0x0AC6);
                     else
                       return (unp_c<0x0ACC)?((unp_c&1)!=0):((unp_c&2)==0);
                 else
                   return (unp_c<0x0ADC)?FALSE:((unp_c&4)==0);
               else /* unp_c >= U+0AE6 */
                 if(unp_c < 0x0B0D)
                     if(unp_c < 0x0B01)
                       return (unp_c<0x0AF0);
                     else
                       return (unp_c<0x0B05)?((unp_c&4)==0):TRUE;
                 else
                     if(unp_c < 0x0B11)
                       return (unp_c>=0x0B0F);
                     else
                       return FALSE;
           else /* unp_c >= U+0B13 */
             if(unp_c < 0x0B5F)
               if(unp_c < 0x0B45)
                 if(unp_c < 0x0B31)
                   return (unp_c!=0x0B29);
                 else
                     if(unp_c < 0x0B3A)
                       return (unp_c<0x0B35)?((unp_c&2)!=0):TRUE;
                     else
                       return (unp_c>=0x0B3C);
               else /* unp_c >= U+0B45 */
                 if(unp_c < 0x0B4E)
                     if(unp_c < 0x0B49)
                       return (unp_c>=0x0B47);
                     else
                       return (unp_c>=0x0B4B);
                 else
                   return (unp_c<0x0B56)?FALSE:((unp_c&8)==0);
             else /* unp_c >= U+0B5F */
               if(unp_c < 0x0B8E)
                 if(unp_c < 0x0B72)
                     if(unp_c < 0x0B66)
                       return (unp_c<0x0B64);
                     else
                       return (unp_c<0x0B6F)?TRUE:((unp_c&1)!=0);
                 else
                     if(unp_c < 0x0B85)
                       return (unp_c<0x0B80)?FALSE:((unp_c&2)!=0);
                     else
                       return (unp_c<0x0B8B);
               else /* unp_c >= U+0B8E */
                 if(unp_c < 0x0B9A)
                     if(unp_c < 0x0B96)
                       return (unp_c!=0x0B91);
                     else
                       return (unp_c>=0x0B99);
                 else
                     if(unp_c < 0x0BA3)
                       return (unp_c<0x0B9E)?((unp_c&1)==0):((unp_c&4)!=0);
                     else
                       return (unp_c<0x0BA5)?TRUE:((unp_c&4)==0);
     else /* unp_c >= U+0BAB */
       if(unp_c < 0x0F3A)
         if(unp_c < 0x0D66)
           if(unp_c < 0x0C85)
             if(unp_c < 0x0C05)
               if(unp_c < 0x0BCC)
                 if(unp_c < 0x0BC3)
                     if(unp_c < 0x0BBA)
                       return (unp_c>=0x0BAE);
                     else
                       return (unp_c>=0x0BBE);
                 else
                     if(unp_c < 0x0BC6)
                       return FALSE;
                     else
                       return (unp_c!=0x0BC9);
               else /* unp_c >= U+0BCC */
                 if(unp_c < 0x0BE6)
                     if(unp_c < 0x0BD7)
                       return (unp_c<0x0BD1)?((unp_c&2)==0):FALSE;
                     else
                       return (unp_c<0x0BD8);
                 else
                     if(unp_c < 0x0C01)
                       return (unp_c<0x0BF0);
                     else
                       return ((unp_c&4)==0);
             else /* unp_c >= U+0C05 */
               if(unp_c < 0x0C4E)
                 if(unp_c < 0x0C3A)
                   switch(unp_c) {
                     case 0x0C0D:
                     case 0x0C11:
                     case 0x0C29:
                     case 0x0C34: return FALSE;
                     default: return TRUE;
                   }
                 else
                     if(unp_c < 0x0C3D)
                       return FALSE;
                     else
                       switch(unp_c) {
                         case 0x0C45:
                         case 0x0C49: return FALSE;
                         default: return TRUE;
                       }
               else /* unp_c >= U+0C4E */
                 if(unp_c < 0x0C66)
                     if(unp_c < 0x0C57)
                       return (unp_c>=0x0C55);
                     else
                       return (unp_c<0x0C5C)?((unp_c&2)==0):((unp_c&4)==0);
                 else
                     if(unp_c < 0x0C80)
                       return (unp_c<0x0C70);
                     else
                       return ((unp_c&2)!=0);
           else /* unp_c >= U+0C85 */
             if(unp_c < 0x0CE8)
               if(unp_c < 0x0CCE)
                 if(unp_c < 0x0CBA)
                   switch(unp_c) {
                     case 0x0C8D:
                     case 0x0C91:
                     case 0x0CA9:
                     case 0x0CB4: return FALSE;
                     default: return TRUE;
                   }
                 else
                     if(unp_c < 0x0CBC)
                       return FALSE;
                     else
                       switch(unp_c) {
                         case 0x0CC5:
                         case 0x0CC9: return FALSE;
                         default: return TRUE;
                       }
               else /* unp_c >= U+0CCE */
                 if(unp_c < 0x0CD7)
                   return (unp_c>=0x0CD5);
                 else
                     if(unp_c < 0x0CE0)
                       return (unp_c<0x0CDD)?FALSE:((unp_c&1)==0);
                     else
                       return (unp_c<0x0CE2)?TRUE:((unp_c&2)!=0);
             else /* unp_c >= U+0CE8 */
               if(unp_c < 0x0D3B)
                 if(unp_c < 0x0D05)
                     if(unp_c < 0x0CF3)
                       return (unp_c<0x0CF1)?((unp_c&8)!=0):TRUE;
                     else
                       return (unp_c<0x0D00)?FALSE:((unp_c&2)!=0);
                 else
                   switch(unp_c) {
                     case 0x0D0D:
                     case 0x0D11: return FALSE;
                     default: return TRUE;
                   }
               else /* unp_c >= U+0D3B */
                 if(unp_c < 0x0D4F)
                     if(unp_c < 0x0D3D)
                       return FALSE;
                     else
                       switch(unp_c) {
                         case 0x0D45:
                         case 0x0D49: return FALSE;
                         default: return TRUE;
                       }
                 else
                     if(unp_c < 0x0D58)
                       return (unp_c>=0x0D57);
                     else
                       return (unp_c<0x0D5C)?FALSE:((unp_c&4)==0);
         else /* unp_c >= U+0D66 */
           if(unp_c < 0x0E87)
             if(unp_c < 0x0DD4)
               if(unp_c < 0x0D9A)
                 if(unp_c < 0x0D85)
                     if(unp_c < 0x0D7A)
                       return (unp_c<0x0D70);
                     else
                       return (unp_c<0x0D7E)?TRUE:((unp_c&2)!=0);
                 else
                   return (unp_c<0x0D97);
               else /* unp_c >= U+0D9A */
                 if(unp_c < 0x0DC7)
                     if(unp_c < 0x0DBB)
                       return (unp_c!=0x0DB2);
                     else
                       return (unp_c<0x0DBE)?((unp_c&1)!=0):((unp_c&8)==0);
                 else
                     if(unp_c < 0x0DCB)
                       return (unp_c>=0x0DCA);
                     else
                       return (unp_c>=0x0DCF);
             else /* unp_c >= U+0DD4 */
               if(unp_c < 0x0E3B)
                 if(unp_c < 0x0DF4)
                     if(unp_c < 0x0DE0)
                       return (unp_c<0x0DD8)?((unp_c&1)==0):TRUE;
                     else
                       return (unp_c>=0x0DF2);
                 else
                     if(unp_c < 0x0E01)
                       return FALSE;
                     else
                       return (unp_c!=0x0E33);
               else /* unp_c >= U+0E3B */
                 if(unp_c < 0x0E5A)
                     if(unp_c < 0x0E40)
                       return FALSE;
                     else
                       return (unp_c!=0x0E4F);
                 else
                     if(unp_c < 0x0E82)
                       return (unp_c>=0x0E81);
                     else
                       return (unp_c<0x0E85)?((unp_c&1)==0):FALSE;
           else /* unp_c >= U+0E87 */
             if(unp_c < 0x0EC8)
               if(unp_c < 0x0E99)
                 if(unp_c < 0x0E8E)
                     if(unp_c < 0x0E8B)
                       return (unp_c<0x0E88)?TRUE:((unp_c&1)==0);
                     else
                       return (unp_c>=0x0E8D);
                 else
                   return (unp_c<0x0E90)?FALSE:((unp_c&4)!=0);
               else /* unp_c >= U+0E99 */
                 if(unp_c < 0x0EAD)
                     if(unp_c < 0x0EA3)
                       return (unp_c<0x0EA1)?((unp_c&8)!=0):TRUE;
                     else
                       return (unp_c<0x0EA7)?((unp_c&1)!=0):((unp_c&2)!=0);
                 else
                     if(unp_c < 0x0EBE)
                       switch(unp_c) {
                         case 0x0EB3:
                         case 0x0EBA: return FALSE;
                         default: return TRUE;
                       }
                     else
                       return (unp_c<0x0EC4)?((unp_c&4)==0):((unp_c&1)==0);
             else /* unp_c >= U+0EC8 */
               if(unp_c < 0x0F01)
                 if(unp_c < 0x0EE0)
                     if(unp_c < 0x0ED8)
                       return (unp_c<0x0ECE)?TRUE:((unp_c&8)==0);
                     else
                       return (unp_c<0x0EDC)?((unp_c&2)==0):((unp_c&2)!=0);
                 else
                   return (unp_c>=0x0F00);
               else /* unp_c >= U+0F01 */
                 if(unp_c < 0x0F1A)
                     if(unp_c < 0x0F0C)
                       return (unp_c>=0x0F0B);
                     else
                       return (unp_c>=0x0F18);
                 else
                     if(unp_c < 0x0F2A)
                       return (unp_c>=0x0F20);
                     else
                       return (unp_c<0x0F34)?FALSE:((unp_c&1)!=0);
       else /* unp_c >= U+0F3A */
         if(unp_c < 0x12B6)
           if(unp_c < 0x104A)
             if(unp_c < 0x0F7A)
               if(unp_c < 0x0F5D)
                 if(unp_c < 0x0F49)
                     if(unp_c < 0x0F43)
                       return (unp_c>=0x0F3E);
                     else
                       return ((unp_c&4)!=0);
                 else
                     if(unp_c < 0x0F57)
                       switch(unp_c) {
                         case 0x0F4D:
                         case 0x0F52: return FALSE;
                         default: return TRUE;
                       }
                     else
                       return ((unp_c&4)==0);
               else /* unp_c >= U+0F5D */
                 if(unp_c < 0x0F6D)
                   return (unp_c!=0x0F69);
                 else
                     if(unp_c < 0x0F72)
                       return (unp_c>=0x0F71);
                     else
                       return (unp_c<0x0F75)?((unp_c&1)==0):FALSE;
             else /* unp_c >= U+0F7A */
               if(unp_c < 0x0FAD)
                 if(unp_c < 0x0F99)
                     if(unp_c < 0x0F93)
                       switch(unp_c) {
                         case 0x0F81:
                         case 0x0F85: return FALSE;
                         default: return TRUE;
                       }
                     else
                       return ((unp_c&4)!=0);
                 else
                     if(unp_c < 0x0FA7)
                       switch(unp_c) {
                         case 0x0F9D:
                         case 0x0FA2: return FALSE;
                         default: return TRUE;
                       }
                     else
                       return ((unp_c&4)==0);
               else /* unp_c >= U+0FAD */
                 if(unp_c < 0x0FC7)
                     if(unp_c < 0x0FBD)
                       return (unp_c!=0x0FB9);
                     else
                       return (unp_c>=0x0FC6);
                 else
                   return (unp_c>=0x1000);
           else /* unp_c >= U+104A */
             if(unp_c < 0x1200)
               if(unp_c < 0x10FB)
                 if(unp_c < 0x109E)
                   return (unp_c>=0x1050);
                 else
                   return (unp_c>=0x10D0);
               else /* unp_c >= U+10FB */
                 if(unp_c < 0x1100)
                   return (unp_c>=0x10FD);
                 else
                   return FALSE;
             else /* unp_c >= U+1200 */
               if(unp_c < 0x1260)
                 if(unp_c < 0x124E)
                   return (unp_c!=0x1249);
                 else
                     if(unp_c < 0x125A)
                       return (unp_c<0x1256)?((unp_c&8)==0):((unp_c&1)==0);
                     else
                       return (unp_c<0x125E);
               else /* unp_c >= U+1260 */
                 if(unp_c < 0x128E)
                   return (unp_c!=0x1289);
                 else
                     if(unp_c < 0x1290)
                       return FALSE;
                     else
                       return (unp_c!=0x12B1);
         else /* unp_c >= U+12B6 */
           if(unp_c < 0x16EB)
             if(unp_c < 0x1390)
               if(unp_c < 0x1316)
                 if(unp_c < 0x12C8)
                     if(unp_c < 0x12C2)
                       return (unp_c<0x12BE)?((unp_c&8)!=0):((unp_c&1)==0);
                     else
                       return (unp_c<0x12C6);
                 else
                   switch(unp_c) {
                     case 0x12D7:
                     case 0x1311: return FALSE;
                     default: return TRUE;
                   }
               else /* unp_c >= U+1316 */
                 if(unp_c < 0x135B)
                   return (unp_c>=0x1318);
                 else
                     if(unp_c < 0x1360)
                       return (unp_c>=0x135D);
                     else
                       return (unp_c>=0x1380);
             else /* unp_c >= U+1390 */
               if(unp_c < 0x166D)
                 if(unp_c < 0x13F5)
                   return (unp_c>=0x13A0);
                 else
                   return (unp_c>=0x1401);
               else /* unp_c >= U+166D */
                 if(unp_c < 0x169B)
                     if(unp_c < 0x166F)
                       return FALSE;
                     else
                       return (unp_c!=0x1680);
                 else
                   return (unp_c>=0x16A0);
           else /* unp_c >= U+16EB */
             if(unp_c < 0x17D4)
               if(unp_c < 0x1754)
                 if(unp_c < 0x1715)
                     if(unp_c < 0x1700)
                       return FALSE;
                     else
                       return (unp_c!=0x170D);
                 else
                     if(unp_c < 0x1735)
                       return (unp_c>=0x1720);
                     else
                       return (unp_c>=0x1740);
               else /* unp_c >= U+1754 */
                 if(unp_c < 0x1774)
                     if(unp_c < 0x1760)
                       return FALSE;
                     else
                       switch(unp_c) {
                         case 0x176D:
                         case 0x1771: return FALSE;
                         default: return TRUE;
                       }
                 else
                     if(unp_c < 0x17B4)
                       return (unp_c>=0x1780);
                     else
                       return (unp_c>=0x17B6);
             else /* unp_c >= U+17D4 */
               if(unp_c < 0x1820)
                 if(unp_c < 0x17E0)
                     if(unp_c < 0x17D8)
                       return (unp_c>=0x17D7);
                     else
                       return (unp_c<0x17DA)?FALSE:((unp_c&2)==0);
                 else
                     if(unp_c < 0x1810)
                       return (unp_c<0x17EA);
                     else
                       return (unp_c<0x181A);
               else /* unp_c >= U+1820 */
                 if(unp_c < 0x1880)
                   return (unp_c<0x1878);
                 else
                   return (unp_c<0x18AB);
   else /* unp_c >= U+18B0 */
     if(unp_c < 0xA980)
       if(unp_c < 0x2CEB)
         if(unp_c < 0x1D2C)
           if(unp_c < 0x1A9A)
             if(unp_c < 0x19B0)
               if(unp_c < 0x193C)
                 if(unp_c < 0x1900)
                   return (unp_c<0x18F6);
                 else
                     if(unp_c < 0x1928)
                       return (unp_c<0x191D)?TRUE:((unp_c&8)==0);
                     else
                       return (unp_c<0x1930)?((unp_c&4)==0):TRUE;
               else /* unp_c >= U+193C */
                 if(unp_c < 0x196E)
                   return (unp_c>=0x1946);
                 else
                     if(unp_c < 0x1980)
                       return (unp_c<0x1975)?((unp_c&8)==0):FALSE;
                     else
                       return (unp_c<0x19AC);
             else /* unp_c >= U+19B0 */
               if(unp_c < 0x1A20)
                 if(unp_c < 0x19D0)
                   return (unp_c<0x19CA);
                 else
                     if(unp_c < 0x1A00)
                       return (unp_c<0x19DA);
                     else
                       return (unp_c<0x1A1C);
               else /* unp_c >= U+1A20 */
                 if(unp_c < 0x1A7D)
                   return (unp_c!=0x1A5F);
                 else
                     if(unp_c < 0x1A8A)
                       return (unp_c>=0x1A7F);
                     else
                       return (unp_c>=0x1A90);
           else /* unp_c >= U+1A9A */
             if(unp_c < 0x1BF4)
               if(unp_c < 0x1B4C)
                 if(unp_c < 0x1AA8)
                   return (unp_c>=0x1AA7);
                 else
                   return (unp_c>=0x1B00);
               else /* unp_c >= U+1B4C */
                 if(unp_c < 0x1B74)
                     if(unp_c < 0x1B5A)
                       return (unp_c>=0x1B50);
                     else
                       return (unp_c>=0x1B6B);
                 else
                   return (unp_c>=0x1B80);
             else /* unp_c >= U+1BF4 */
               if(unp_c < 0x1C7E)
                 if(unp_c < 0x1C38)
                   return (unp_c>=0x1C00);
                 else
                     if(unp_c < 0x1C4A)
                       return (unp_c>=0x1C40);
                     else
                       return (unp_c>=0x1C4D);
               else /* unp_c >= U+1C7E */
                 if(unp_c < 0x1CD3)
                   return (unp_c>=0x1CD0);
                 else
                     if(unp_c < 0x1CF7)
                       return (unp_c>=0x1CD4);
                     else
                       return (unp_c>=0x1D00);
         else /* unp_c >= U+1D2C */
           if(unp_c < 0x1FAE)
             if(unp_c < 0x1DE7)
               if(unp_c < 0x1D6B)
                 if(unp_c < 0x1D3C)
                     if(unp_c < 0x1D30)
                       return (unp_c>=0x1D2F);
                     else
                       return (unp_c>=0x1D3B);
                 else
                     if(unp_c < 0x1D4F)
                       return (unp_c>=0x1D4E);
                     else
                       return FALSE;
               else /* unp_c >= U+1D6B */
                 if(unp_c < 0x1D9B)
                   return (unp_c!=0x1D78);
                 else
                   return (unp_c>=0x1DC0);
             else /* unp_c >= U+1DE7 */
               if(unp_c < 0x1F14)
                 if(unp_c < 0x1E98)
                   return (unp_c<0x1DFC)?FALSE:m_is_own_lowercase((int)unp_c);
                 else
                   return (unp_c<0x1E9C)?((unp_c&2)==0):m_is_own_lowercase((int)unp_c);
               else /* unp_c >= U+1F14 */
                 if(unp_c < 0x1F6F)
                     if(unp_c < 0x1F44)
                       return (unp_c<0x1F18)?((unp_c&2)==0):((unp_c&8)==0);
                     else
                       return (unp_c<0x1F48)?((unp_c&2)==0):((unp_c&8)==0);
                 else
                   return (unp_c<0x1F7D)?((unp_c&1)==0):FALSE;
           else /* unp_c >= U+1FAE */
             if(unp_c < 0x214E)
               if(unp_c < 0x1FE4)
                 if(unp_c < 0x1FC8)
                     if(unp_c < 0x1FB7)
                       return (unp_c<0x1FB4)?((unp_c&2)==0):((unp_c&2)!=0);
                     else
                       return (unp_c<0x1FC5)?FALSE:((unp_c&1)==0);
                 else
                     if(unp_c < 0x1FD6)
                       return (unp_c<0x1FD3)?((unp_c&8)==0):FALSE;
                     else
                       return (unp_c<0x1FE3)?((unp_c&8)==0):FALSE;
               else /* unp_c >= U+1FE4 */
                 if(unp_c < 0x1FF6)
                   return (unp_c<0x1FE8);
                 else
                   return (unp_c<0x1FF7);
             else /* unp_c >= U+214E */
               if(unp_c < 0x2C30)
                 if(unp_c < 0x2184)
                   return (unp_c<0x214F);
                 else
                   return (unp_c<0x2185);
               else /* unp_c >= U+2C30 */
                 if(unp_c < 0x2C7E)
                     if(unp_c < 0x2C60)
                       return (unp_c<0x2C5F);
                     else
                       return (unp_c<0x2C78)?m_is_own_lowercase((int)unp_c):((unp_c&4)==0);
                 else
                   return (unp_c<0x2CE5)?m_is_own_lowercase((int)unp_c):FALSE;
       else /* unp_c >= U+2CEB */
         if(unp_c < 0x9FCD)
           if(unp_c < 0x303D)
             if(unp_c < 0x2DA7)
               if(unp_c < 0x2D2E)
                 if(unp_c < 0x2D00)
                   return (unp_c<0x2CF4)?m_is_own_lowercase((int)unp_c):FALSE;
                 else
                     if(unp_c < 0x2D28)
                       return (unp_c<0x2D25)?TRUE:((unp_c&1)!=0);
                     else
                       return (unp_c>=0x2D2D);
               else /* unp_c >= U+2D2E */
                 if(unp_c < 0x2D68)
                   return (unp_c>=0x2D30);
                 else
                     if(unp_c < 0x2D97)
                       return (unp_c>=0x2D7F);
                     else
                       return (unp_c>=0x2DA0);
             else /* unp_c >= U+2DA7 */
               if(unp_c < 0x2E30)
                 if(unp_c < 0x2E00)
                   switch(unp_c) {
                     case 0x2DA7:
                     case 0x2DAF:
                     case 0x2DB7:
                     case 0x2DBF:
                     case 0x2DC7:
                     case 0x2DCF:
                     case 0x2DD7:
                     case 0x2DDF: return FALSE;
                     default: return TRUE;
                   }
                 else
                   return (unp_c>=0x2E2F);
               else /* unp_c >= U+2E30 */
                 if(unp_c < 0x3008)
                   return (unp_c>=0x3005);
                 else
                     if(unp_c < 0x302E)
                       return (unp_c>=0x302A);
                     else
                       return (unp_c>=0x303C);
           else /* unp_c >= U+303D */
             if(unp_c < 0x312E)
               if(unp_c < 0x309F)
                 if(unp_c < 0x3097)
                   return (unp_c>=0x3041);
                 else
                     if(unp_c < 0x309B)
                       return (unp_c>=0x3099);
                     else
                       return (unp_c>=0x309D);
               else /* unp_c >= U+309F */
                 if(unp_c < 0x30FF)
                   return (unp_c>=0x30A1);
                 else
                   return (unp_c>=0x3105);
             else /* unp_c >= U+312E */
               if(unp_c < 0x3200)
                 if(unp_c < 0x31BB)
                   return (unp_c>=0x31A0);
                 else
                   return (unp_c>=0x31F0);
               else /* unp_c >= U+3200 */
                 if(unp_c < 0x4DB6)
                   return (unp_c>=0x3400);
                 else
                   return (unp_c>=0x4E00);
         else /* unp_c >= U+9FCD */
           if(unp_c < 0xA789)
             if(unp_c < 0xA66D)
               if(unp_c < 0xA4FE)
                 if(unp_c < 0xA48D)
                   return (unp_c>=0xA000);
                 else
                   return (unp_c>=0xA4D0);
               else /* unp_c >= U+A4FE */
                 if(unp_c < 0xA60D)
                   return (unp_c>=0xA500);
                 else
                     if(unp_c < 0xA62C)
                       return (unp_c>=0xA610);
                     else
                       return (unp_c<0xA640)?FALSE:((unp_c&1)!=0);
             else /* unp_c >= U+A66D */
               if(unp_c < 0xA6E8)
                 if(unp_c < 0xA69F)
                     if(unp_c < 0xA67D)
                       return (unp_c<0xA674)?((unp_c&4)!=0):TRUE;
                     else
                       return (unp_c<0xA698)?((unp_c&1)!=0):FALSE;
                 else
                   return (unp_c<0xA6E6);
               else /* unp_c >= U+A6E8 */
                 if(unp_c < 0xA722)
                     if(unp_c < 0xA717)
                       return (unp_c<0xA6F2)?((unp_c&8)==0):FALSE;
                     else
                       return (unp_c<0xA720);
                 else
                   return (unp_c==0xA770)?FALSE:m_is_own_lowercase((int)unp_c);
           else /* unp_c >= U+A789 */
             if(unp_c < 0xA880)
               if(unp_c < 0xA7FA)
                 if(unp_c < 0xA7A0)
                     if(unp_c < 0xA790)
                       return (unp_c<0xA78B)?FALSE:((unp_c&1)==0);
                     else
                       return (unp_c<0xA794)?((unp_c&1)!=0):FALSE;
                 else
                   return (unp_c<0xA7AA)?((unp_c&1)!=0):FALSE;
               else /* unp_c >= U+A7FA */
                 if(unp_c < 0xA840)
                   return (unp_c<0xA828);
                 else
                   return (unp_c<0xA874);
             else /* unp_c >= U+A880 */
               if(unp_c < 0xA900)
                 if(unp_c < 0xA8E0)
                     if(unp_c < 0xA8D0)
                       return (unp_c<0xA8C5);
                     else
                       return (unp_c<0xA8DA);
                 else
                     if(unp_c < 0xA8FB)
                       return (unp_c<0xA8F8);
                     else
                       return (unp_c<0xA8FC);
               else /* unp_c >= U+A900 */
                 if(unp_c < 0xA930)
                   return (unp_c<0xA92E);
                 else
                   return (unp_c<0xA954);
     else /* unp_c >= U+A980 */
       if(unp_c < 0x1080A)
         if(unp_c < 0xFB1F)
           if(unp_c < 0xAB01)
             if(unp_c < 0xAA60)
               if(unp_c < 0xAA00)
                 if(unp_c < 0xA9CF)
                   return (unp_c<0xA9C1);
                 else
                   return (unp_c<0xA9DA);
               else /* unp_c >= U+AA00 */
                 if(unp_c < 0xAA40)
                   return (unp_c<0xAA37);
                 else
                     if(unp_c < 0xAA50)
                       return (unp_c<0xAA4E);
                     else
                       return (unp_c<0xAA5A);
             else /* unp_c >= U+AA60 */
               if(unp_c < 0xAAC3)
                 if(unp_c < 0xAA7A)
                   return (unp_c<0xAA77);
                 else
                   return (unp_c<0xAA80)?((unp_c&4)==0):TRUE;
               else /* unp_c >= U+AAC3 */
                 if(unp_c < 0xAADE)
                   return (unp_c>=0xAADB);
                 else
                     if(unp_c < 0xAAF2)
                       return (unp_c<0xAAE8)?((unp_c&8)==0):((unp_c&8)!=0);
                     else
                       return (unp_c<0xAAF7);
           else /* unp_c >= U+AB01 */
             if(unp_c < 0xAC00)
               if(unp_c < 0xAB28)
                 if(unp_c < 0xAB11)
                     if(unp_c < 0xAB09)
                       return (unp_c<0xAB07);
                     else
                       return (unp_c<0xAB0F);
                 else
                     if(unp_c < 0xAB20)
                       return (unp_c<0xAB17);
                     else
                       return (unp_c<0xAB27);
               else /* unp_c >= U+AB28 */
                 if(unp_c < 0xABC0)
                   return (unp_c<0xAB2F);
                 else
                     if(unp_c < 0xABF0)
                       return (unp_c<0xABEB)?TRUE:((unp_c&2)==0);
                     else
                       return (unp_c<0xABFA);
             else /* unp_c >= U+AC00 */
               if(unp_c < 0xFA1E)
                 if(unp_c < 0xFA0E)
                   return (unp_c<0xD7A4);
                 else
                     if(unp_c < 0xFA13)
                       return (unp_c<0xFA0F)?TRUE:((unp_c&1)!=0);
                     else
                       return (unp_c<0xFA15);
               else /* unp_c >= U+FA1E */
                 if(unp_c < 0xFA2A)
                     if(unp_c < 0xFA25)
                       return (unp_c<0xFA23)?((unp_c&1)!=0):TRUE;
                     else
                       return (unp_c>=0xFA27);
                 else
                   return (unp_c>=0xFB1E);
         else /* unp_c >= U+FB1F */
           if(unp_c < 0x1029D)
             if(unp_c < 0x1003B)
               if(unp_c < 0xFE74)
                 if(unp_c < 0xFE27)
                   return (unp_c>=0xFE20);
                 else
                   return (unp_c>=0xFE73);
               else /* unp_c >= U+FE74 */
                 if(unp_c < 0x10008)
                   return (unp_c>=0x10000);
                 else
                     if(unp_c < 0x1000D)
                       return ((unp_c&4)==0);
                     else
                       return (unp_c!=0x10027);
             else /* unp_c >= U+1003B */
               if(unp_c < 0x100FB)
                 if(unp_c < 0x1005E)
                     if(unp_c < 0x1004E)
                       return (unp_c<0x1003F)?((unp_c&2)==0):TRUE;
                     else
                       return (unp_c>=0x10050);
                 else
                   return (unp_c>=0x10080);
               else /* unp_c >= U+100FB */
                 if(unp_c < 0x101FE)
                   return (unp_c>=0x101FD);
                 else
                   return (unp_c>=0x10280);
           else /* unp_c >= U+1029D */
             if(unp_c < 0x1039E)
               if(unp_c < 0x1031F)
                 if(unp_c < 0x102D1)
                   return (unp_c>=0x102A0);
                 else
                   return (unp_c>=0x10300);
               else /* unp_c >= U+1031F */
                 if(unp_c < 0x1034A)
                     if(unp_c < 0x10330)
                       return FALSE;
                     else
                       return (unp_c!=0x10341);
                 else
                   return (unp_c>=0x10380);
             else /* unp_c >= U+1039E */
               if(unp_c < 0x104A0)
                 if(unp_c < 0x10400)
                     if(unp_c < 0x103C4)
                       return (unp_c>=0x103A0);
                     else
                       return (unp_c<0x103D0)?((unp_c&8)!=0):FALSE;
                 else
                   return (unp_c<0x1049C)?m_is_own_lowercase((int)unp_c):((unp_c&2)==0);
               else /* unp_c >= U+104A0 */
                 if(unp_c < 0x10800)
                   return (unp_c<0x104AA);
                 else
                     if(unp_c < 0x10807)
                       return (unp_c<0x10804)?TRUE:((unp_c&2)==0);
                     else
                       return ((unp_c&1)==0);
       else /* unp_c >= U+1080A */
         if(unp_c < 0x110E9)
           if(unp_c < 0x10A40)
             if(unp_c < 0x10980)
               if(unp_c < 0x10900)
                 if(unp_c < 0x1083F)
                     if(unp_c < 0x10839)
                       return (unp_c!=0x10836);
                     else
                       return (unp_c<0x1083D)?((unp_c&4)!=0):FALSE;
                 else
                   return (unp_c<0x10856);
               else /* unp_c >= U+10900 */
                 if(unp_c < 0x10920)
                   return (unp_c<0x10916);
                 else
                   return (unp_c<0x1093A);
             else /* unp_c >= U+10980 */
               if(unp_c < 0x10A07)
                 if(unp_c < 0x109BC)
                   return (unp_c<0x109B8);
                 else
                     if(unp_c < 0x109FC)
                       return (unp_c<0x109C0)?((unp_c&2)!=0):FALSE;
                     else
                       return (unp_c<0x10A05)?((unp_c&4)==0):TRUE;
               else /* unp_c >= U+10A07 */
                 if(unp_c < 0x10A19)
                     if(unp_c < 0x10A10)
                       return (unp_c>=0x10A0C);
                     else
                       return (unp_c<0x10A15)?((unp_c&4)==0):((unp_c&4)!=0);
                 else
                     if(unp_c < 0x10A3B)
                       return (unp_c<0x10A30)?TRUE:((unp_c&4)==0);
                     else
                       return (unp_c>=0x10A3F);
           else /* unp_c >= U+10A40 */
             if(unp_c < 0x10C49)
               if(unp_c < 0x10B36)
                 if(unp_c < 0x10A7D)
                   return (unp_c>=0x10A60);
                 else
                   return (unp_c>=0x10B00);
               else /* unp_c >= U+10B36 */
                 if(unp_c < 0x10B73)
                     if(unp_c < 0x10B56)
                       return (unp_c>=0x10B40);
                     else
                       return (unp_c>=0x10B60);
                 else
                   return (unp_c>=0x10C00);
             else /* unp_c >= U+10C49 */
               if(unp_c < 0x11070)
                 if(unp_c < 0x11047)
                   return (unp_c>=0x11000);
                 else
                   return (unp_c>=0x11066);
               else /* unp_c >= U+11070 */
                 if(unp_c < 0x110BB)
                   return (unp_c>=0x11080);
                 else
                   return (unp_c>=0x110D0);
         else /* unp_c >= U+110E9 */
           if(unp_c < 0x1342F)
             if(unp_c < 0x111DA)
               if(unp_c < 0x11140)
                 if(unp_c < 0x11100)
                     if(unp_c < 0x110FA)
                       return (unp_c>=0x110F0);
                     else
                       return FALSE;
                 else
                   return (unp_c!=0x11135);
               else /* unp_c >= U+11140 */
                 if(unp_c < 0x111C5)
                   return (unp_c>=0x11180);
                 else
                   return (unp_c>=0x111D0);
             else /* unp_c >= U+111DA */
               if(unp_c < 0x116CA)
                 if(unp_c < 0x116B8)
                   return (unp_c>=0x11680);
                 else
                   return (unp_c>=0x116C0);
               else /* unp_c >= U+116CA */
                 if(unp_c < 0x1236F)
                   return (unp_c>=0x12000);
                 else
                   return (unp_c>=0x13000);
           else /* unp_c >= U+1342F */
             if(unp_c < 0x1B002)
               if(unp_c < 0x16F45)
                 if(unp_c < 0x16A39)
                   return (unp_c>=0x16800);
                 else
                   return (unp_c>=0x16F00);
               else /* unp_c >= U+16F45 */
                 if(unp_c < 0x16FA0)
                     if(unp_c < 0x16F7F)
                       return (unp_c>=0x16F50);
                     else
                       return (unp_c>=0x16F8F);
                 else
                   return (unp_c>=0x1B000);
             else /* unp_c >= U+1B002 */
               if(unp_c < 0x2B735)
                 if(unp_c < 0x2A6D7)
                   return (unp_c>=0x20000);
                 else
                   return (unp_c>=0x2A700);
               else /* unp_c >= U+2B735 */
                 if(unp_c < 0x2B81E)
                   return (unp_c>=0x2B740);
                 else
                   return FALSE;
} /* end m_is_idna_allowed()                                           */

/**
* Finds combinations that cannot be NFC (see unicode UAX #15 or chapter 3.11).
*  @param unp_s previous "starter" (ccc is 0; cf. D107 in unicode chapter 3.11),
*         assumed to be IDNA-allowed.
*  @param unp_f current char. Starter or not, but assumed IDNA-allowed.
*         Only unp_f values that have NFC_Quick_Check=Maybe in
*         DerivedNormalizationProps.txt may cause the function to return TRUE.
*  @return whether this combination was found to be prohibited in a NFC string.
*/
BOOL m_idna_cannotbe_nfc(unsigned int unp_s, unsigned int unp_f) {
   switch (unp_f) {
     case 0x0301:
       switch (unp_s) {
         case 0x0063: case 0x0067: case 0x006B: case 0x006C: case 0x006D:
         case 0x0070: case 0x0072: case 0x0073: case 0x007A: case 0x00E5:
         case 0x00E6: case 0x00E7: case 0x00EF: case 0x00F5: case 0x00F8:
         case 0x0169: case 0x0433: case 0x043A: return TRUE;
         case 0x0435: case 0x0438: return FALSE;
       }  /* else fall through */
     case 0x0300:
       switch (unp_s) {
         case 0x0061: case 0x0065: case 0x0069: case 0x006E: case 0x006F:
         case 0x0075: case 0x0077: case 0x0079: case 0x00E2: case 0x00EA:
         case 0x00F4: case 0x00FC: case 0x0103: case 0x0113: case 0x014D:
         case 0x01A1: case 0x01B0: case 0x03B1: case 0x03B5: case 0x03B7:
         case 0x03B9: case 0x03BF: case 0x03C5: case 0x03C9: case 0x03CA:
         case 0x03CB: case 0x0435: case 0x0438: case 0x1F00: case 0x1F01:
         case 0x1F10: case 0x1F11: case 0x1F20: case 0x1F21: case 0x1F30:
         case 0x1F31: case 0x1F40: case 0x1F41: case 0x1F50: case 0x1F51:
         case 0x1F60: case 0x1F61: return TRUE;
         default: return FALSE;
       }
     case 0x0302:
       switch (unp_s) {
         case 0x0061: case 0x0063: case 0x0065: case 0x0067: case 0x0068:
         case 0x0069: case 0x006A: case 0x006F: case 0x0073: case 0x0075:
         case 0x0077: case 0x0079: case 0x007A: case 0x1EA1: case 0x1EB9:
         case 0x1ECD: return TRUE;
         default: return FALSE;
       }
     case 0x0303:
       if ((unp_s==0x006E)||(unp_s==0x0076)) return TRUE;  /* else fall through */
     case 0x0309:
       switch (unp_s) {
         case 0x0061: case 0x0065: case 0x0069: case 0x006F: case 0x0075:
         case 0x0079: case 0x00E2: case 0x00EA: case 0x00F4: case 0x0103:
         case 0x01A1: case 0x01B0: return TRUE;
         default: return FALSE;
       }
     case 0x0304:
       switch (unp_s) {
         case 0x0061: case 0x0065: case 0x0067: case 0x0069: case 0x006F:
         case 0x0075: case 0x0079: case 0x00E4: case 0x00E6: case 0x00F5:
         case 0x00F6: case 0x00FC: case 0x01EB: case 0x0227: case 0x022F:
         case 0x03B1: case 0x03B9: case 0x03C5: case 0x0438: case 0x0443:
         case 0x1E37: case 0x1E5B: return TRUE;
         default: return FALSE;
       }
     case 0x0306:
       switch (unp_s) {
         case 0x0061: case 0x0065: case 0x0067: case 0x0069: case 0x006F:
         case 0x0075: case 0x0229: case 0x03B1: case 0x03B9: case 0x03C5:
         case 0x0430: case 0x0435: case 0x0436: case 0x0438: case 0x0443:
         case 0x1EA1: return TRUE;
         default: return FALSE;
       }
     case 0x0307:
       switch (unp_s) {
         case 0x0061: case 0x0062: case 0x0063: case 0x0064: case 0x0065:
         case 0x0066: case 0x0067: case 0x0068: case 0x006D: case 0x006E:
         case 0x006F: case 0x0070: case 0x0072: case 0x0073: case 0x0074:
         case 0x0077: case 0x0078: case 0x0079: case 0x007A: case 0x015B:
         case 0x0161: case 0x1E63: return TRUE;
         default: return FALSE;
       }
     case 0x0308:
       switch (unp_s) {
         case 0x0061: case 0x0065: case 0x0068: case 0x0069: case 0x006F:
         case 0x0074: case 0x0075: case 0x0077: case 0x0078: case 0x0079:
         case 0x00F5: case 0x016B: case 0x03B9: case 0x03C5: case 0x0430:
         case 0x0435: case 0x0436: case 0x0437: case 0x0438: case 0x043E:
         case 0x0443: case 0x0447: case 0x044B: case 0x044D: case 0x0456:
         case 0x04D9: case 0x04E9: return TRUE;
         default: return FALSE;
       }
     case 0x030A:
       switch (unp_s) {
         case 0x0061: case 0x0075: case 0x0077: case 0x0079: return TRUE;
         default: return FALSE;
       }
     case 0x030B: return (unp_s==0x006F)||(unp_s==0x0075)||(unp_s==0x0443);
     case 0x030C:
       switch (unp_s) {
         case 0x0061: case 0x0063: case 0x0064: case 0x0065: case 0x0067:
         case 0x0068: case 0x0069: case 0x006A: case 0x006B: case 0x006C:
         case 0x006E: case 0x006F: case 0x0072: case 0x0073: case 0x0074:
         case 0x0075: case 0x007A: case 0x00FC: case 0x0292: return TRUE;
         default: return FALSE;
       }
     case 0x030F:
       if (unp_s==0x0475) return TRUE;  /* else fall through */
     case 0x0311:
       switch (unp_s) {
         case 0x0061: case 0x0065: case 0x0069: case 0x006F: case 0x0072:
         case 0x0075: return TRUE;
         default: return FALSE;
       }
     case 0x0313:  /* fall through */
     case 0x0314:
       switch (unp_s) {
         case 0x03B1: case 0x03B5: case 0x03B7: case 0x03B9: case 0x03BF:
         case 0x03C1: case 0x03C5: case 0x03C9: return TRUE;
         default: return FALSE;
       }
     case 0x031B:
       switch (unp_s) {
         case 0x006F: case 0x0075: case 0x00F2: case 0x00F3: case 0x00F4:
         case 0x00F5: case 0x00F6: case 0x00F9: case 0x00FA: case 0x00FB:
         case 0x00FC: case 0x014D: case 0x014F: case 0x0151: case 0x0169:
         case 0x016B: case 0x016D: case 0x016F: case 0x0171: case 0x01D2:
         case 0x01D4: case 0x01D6: case 0x01D8: case 0x01DA: case 0x01DC:
         case 0x020D: case 0x020F: case 0x0215: case 0x0217: case 0x022B:
         case 0x022D: case 0x022F: case 0x0231: case 0x1E4D: case 0x1E4F:
         case 0x1E51: case 0x1E53: case 0x1E73: case 0x1E75: case 0x1E77:
         case 0x1E79: case 0x1E7B: case 0x1ECD: case 0x1ECF: case 0x1ED1:
         case 0x1ED3: case 0x1ED5: case 0x1ED7: case 0x1ED9: case 0x1EE5:
         case 0x1EE7: return TRUE;
         default: return FALSE;
       }
     case 0x0323:
       switch (unp_s) {
         case 0x0062: case 0x0064: case 0x0068: case 0x006B: case 0x006C:
         case 0x006D: case 0x006E: case 0x0072: case 0x0073: case 0x0074:
         case 0x0076: case 0x0077: case 0x0079: case 0x007A: case 0x00F1:
         case 0x00FD: case 0x00FF: case 0x010F: case 0x0125: case 0x013A:
         case 0x013E: case 0x0144: case 0x0148: case 0x0155: case 0x0159:
         case 0x015B: case 0x015D: case 0x0161: case 0x0165: case 0x0175:
         case 0x0177: case 0x017A: case 0x017C: case 0x017E: case 0x01E9:
         case 0x01F9: case 0x0211: case 0x0213: case 0x021F: case 0x0233:
         case 0x1E03: case 0x1E0B: case 0x1E23: case 0x1E27: case 0x1E31:
         case 0x1E3F: case 0x1E41: case 0x1E45: case 0x1E59: case 0x1E61:
         case 0x1E65: case 0x1E67: case 0x1E6B: case 0x1E7D: case 0x1E81:
         case 0x1E83: case 0x1E85: case 0x1E87: case 0x1E8F: case 0x1E91:
         case 0x1E97: case 0x1E98: case 0x1E99: case 0x1EF3: case 0x1EF7:
         case 0x1EF9: return TRUE;
         case 0x1E01: case 0x1E19: case 0x1E1B: case 0x1E2D: case 0x1E73:
         case 0x1E75: case 0x1E77: case 0x1EA1: case 0x1EAD: case 0x1EB7:
         case 0x1EB9: case 0x1EC7: case 0x1ECB: case 0x1ECD: case 0x1ED9:
         case 0x1EE3: case 0x1EE5: case 0x1EF1: return FALSE;
       }  /* else fall through */
     case 0x0328:
       switch (unp_s) {
         case 0x0061: case 0x0065: case 0x0069: case 0x006F: case 0x0075:
         case 0x00E0: case 0x00E1: case 0x00E2: case 0x00E3: case 0x00E4:
         case 0x00E5: case 0x00E8: case 0x00E9: case 0x00EA: case 0x00EB:
         case 0x00EC: case 0x00ED: case 0x00EE: case 0x00EF: case 0x00F2:
         case 0x00F3: case 0x00F4: case 0x00F5: case 0x00F6: case 0x00F9:
         case 0x00FA: case 0x00FB: case 0x00FC: case 0x0101: case 0x0103:
         case 0x0113: case 0x0115: case 0x0117: case 0x011B: case 0x0129:
         case 0x012B: case 0x012D: case 0x014D: case 0x014F: case 0x0151:
         case 0x0169: case 0x016B: case 0x016D: case 0x016F: case 0x0171:
         case 0x01A1: case 0x01B0: case 0x01CE: case 0x01D0: case 0x01D2:
         case 0x01D4: case 0x01D6: case 0x01D8: case 0x01DA: case 0x01DC:
         case 0x01DF: case 0x01E1: case 0x01FB: case 0x0201: case 0x0203:
         case 0x0205: case 0x0207: case 0x0209: case 0x020B: case 0x020D:
         case 0x020F: case 0x0215: case 0x0217: case 0x0227: case 0x022B:
         case 0x022D: case 0x022F: case 0x0231: case 0x1E01: case 0x1E15:
         case 0x1E17: case 0x1E19: case 0x1E1B: case 0x1E2D: case 0x1E2F:
         case 0x1E4D: case 0x1E4F: case 0x1E51: case 0x1E53: case 0x1E73:
         case 0x1E75: case 0x1E77: case 0x1E79: case 0x1E7B: case 0x1EA1:
         case 0x1EA3: case 0x1EA5: case 0x1EA7: case 0x1EA9: case 0x1EAB:
         case 0x1EAD: case 0x1EAF: case 0x1EB1: case 0x1EB3: case 0x1EB5:
         case 0x1EB7: case 0x1EB9: case 0x1EBB: case 0x1EBD: case 0x1EBF:
         case 0x1EC1: case 0x1EC3: case 0x1EC5: case 0x1EC7: case 0x1EC9:
         case 0x1ECB: case 0x1ECD: case 0x1ECF: case 0x1ED1: case 0x1ED3:
         case 0x1ED5: case 0x1ED7: case 0x1ED9: case 0x1EDB: case 0x1EDD:
         case 0x1EDF: case 0x1EE1: case 0x1EE3: case 0x1EE5: case 0x1EE7:
         case 0x1EE9: case 0x1EEB: case 0x1EED: case 0x1EEF: case 0x1EF1:
         return TRUE;
         default: return FALSE;
       }
     case 0x0324:
       switch (unp_s) {
         case 0x0075: case 0x00F9: case 0x00FA: case 0x00FB: case 0x00FC:
         case 0x0169: case 0x016B: case 0x016D: case 0x016F: case 0x0171:
         case 0x01D4: case 0x01D6: case 0x01D8: case 0x01DA: case 0x01DC:
         case 0x0215: case 0x0217: case 0x1E79: case 0x1E7B: case 0x1EE7:
         return TRUE;
         default: return FALSE;
       }
     case 0x0325:
       switch (unp_s) {
         case 0x0061: case 0x00E0: case 0x00E1: case 0x00E2: case 0x00E3:
         case 0x00E4: case 0x00E5: case 0x0101: case 0x0103: case 0x01CE:
         case 0x01DF: case 0x01E1: case 0x01FB: case 0x0201: case 0x0203:
         case 0x0227: case 0x1EA3: case 0x1EA5: case 0x1EA7: case 0x1EA9:
         case 0x1EAB: case 0x1EAF: case 0x1EB1: case 0x1EB3: case 0x1EB5:
         return TRUE;
         default: return FALSE;
       }
     case 0x0326:
       switch (unp_s) {
         case 0x0073: case 0x0074: case 0x015B: case 0x015D: case 0x0161:
         case 0x0165: case 0x1E61: case 0x1E65: case 0x1E67: case 0x1E6B:
         case 0x1E97: return TRUE;
         default: return FALSE;
       }
     case 0x0327:
       switch (unp_s) {
         case 0x0063: case 0x0064: case 0x0065: case 0x0067: case 0x0068:
         case 0x006B: case 0x006C: case 0x006E: case 0x0072: case 0x0073:
         case 0x0074: case 0x00E8: case 0x00E9: case 0x00EA: case 0x00EB:
         case 0x00F1: case 0x0107: case 0x0109: case 0x010B: case 0x010D:
         case 0x010F: case 0x0113: case 0x0115: case 0x0117: case 0x011B:
         case 0x011D: case 0x011F: case 0x0121: case 0x0125: case 0x013A:
         case 0x013E: case 0x0144: case 0x0148: case 0x0155: case 0x0159:
         case 0x015B: case 0x015D: case 0x0161: case 0x0165: case 0x01E7:
         case 0x01E9: case 0x01F5: case 0x01F9: case 0x0205: case 0x0207:
         case 0x0211: case 0x0213: case 0x0219: case 0x021B: case 0x021F:
         case 0x1E0B: case 0x1E0D: case 0x1E0F: case 0x1E13: case 0x1E15:
         case 0x1E17: case 0x1E19: case 0x1E1B: case 0x1E21: case 0x1E23:
         case 0x1E25: case 0x1E27: case 0x1E2B: case 0x1E31: case 0x1E33:
         case 0x1E35: case 0x1E37: case 0x1E39: case 0x1E3B: case 0x1E3D:
         case 0x1E45: case 0x1E47: case 0x1E49: case 0x1E4B: case 0x1E59:
         case 0x1E5B: case 0x1E5D: case 0x1E5F: case 0x1E61: case 0x1E63:
         case 0x1E65: case 0x1E67: case 0x1E69: case 0x1E6B: case 0x1E6D:
         case 0x1E6F: case 0x1E71: case 0x1E96: case 0x1E97: case 0x1EB9:
         case 0x1EBB: case 0x1EBD: case 0x1EBF: case 0x1EC1: case 0x1EC3:
         case 0x1EC5: case 0x1EC7: return TRUE;
         default: return FALSE;
       }
     case 0x032D:
       switch (unp_s) {
         case 0x0064: case 0x006C: case 0x006E: case 0x0074: case 0x00F1:
         case 0x010F: case 0x013A: case 0x013E: case 0x0144: case 0x0148:
         case 0x0165: case 0x01F9: case 0x1E0B: case 0x1E45: case 0x1E6B:
         case 0x1E97: return TRUE;
         case 0x0069: case 0x00EC: case 0x00ED: case 0x00EE: case 0x00EF:
         case 0x0129: case 0x012B: case 0x012D: case 0x01D0: case 0x0209:
         case 0x020B: case 0x1E2F: case 0x1EC9: return FALSE;
       }  /* else fall through */
     case 0x0330:
       switch (unp_s) {
         case 0x0065: case 0x0069: case 0x0075: case 0x00E8: case 0x00E9:
         case 0x00EA: case 0x00EB: case 0x00EC: case 0x00ED: case 0x00EE:
         case 0x00EF: case 0x00F9: case 0x00FA: case 0x00FB: case 0x00FC:
         case 0x0113: case 0x0115: case 0x0117: case 0x011B: case 0x0129:
         case 0x012B: case 0x012D: case 0x0169: case 0x016B: case 0x016D:
         case 0x016F: case 0x0171: case 0x01D0: case 0x01D4: case 0x01D6:
         case 0x01D8: case 0x01DA: case 0x01DC: case 0x0205: case 0x0207:
         case 0x0209: case 0x020B: case 0x0215: case 0x0217: case 0x1E15:
         case 0x1E17: case 0x1E2F: case 0x1E79: case 0x1E7B: case 0x1EBB:
         case 0x1EBD: case 0x1EBF: case 0x1EC1: case 0x1EC3: case 0x1EC5:
         case 0x1EC9: case 0x1EE7: return TRUE;
         default: return FALSE;
       }
     case 0x032E:
       switch (unp_s) {
         case 0x0068: case 0x0125: case 0x021F: case 0x1E23: case 0x1E27:
         return TRUE;
         default: return FALSE;
       }
     case 0x0331:
       switch (unp_s) {
         case 0x0062: case 0x0064: case 0x0068: case 0x006B: case 0x006C:
         case 0x006E: case 0x0072: case 0x0074: case 0x007A: case 0x00F1:
         case 0x010F: case 0x0125: case 0x013A: case 0x013E: case 0x0144:
         case 0x0148: case 0x0155: case 0x0159: case 0x0165: case 0x017A:
         case 0x017C: case 0x017E: case 0x01E9: case 0x01F9: case 0x0211:
         case 0x0213: case 0x021F: case 0x1E03: case 0x1E0B: case 0x1E23:
         case 0x1E27: case 0x1E31: case 0x1E45: case 0x1E59: case 0x1E6B:
         case 0x1E91: case 0x1E97: return TRUE;
         default: return FALSE;
       }
     case 0x0338: return FALSE;  /* ?? why is this listed as as maybe-character? */
     case 0x0342:
       switch (unp_s) {
         case 0x03B1: case 0x03B7: case 0x03B9: case 0x03C5: case 0x03C9:
         case 0x03CA: case 0x03CB: case 0x1F00: case 0x1F01: case 0x1F20:
         case 0x1F21: case 0x1F30: case 0x1F31: case 0x1F50: case 0x1F51:
         case 0x1F60: case 0x1F61: return TRUE;
         default: return FALSE;
       }
     case 0x0653: return (unp_s==0x0627);
     case 0x0654:
       switch (unp_s) {
         case 0x0627: case 0x0648: case 0x064A: case 0x06C1: case 0x06D2:
         case 0x06D5: return TRUE;
         default: return FALSE;
       }
     case 0x0655: return (unp_s==0x0622)||(unp_s==0x0623)||(unp_s==0x0627);
     case 0x093C: return (unp_s==0x0928)||(unp_s==0x0930)||(unp_s==0x0933);
     case 0x09BE:  /* fall through */
     case 0x09D7: return (unp_s==0x09C7);
     case 0x0B3E:  /* fall through */
     case 0x0B56:  /* fall through */
     case 0x0B57: return (unp_s==0x0B47);
     case 0x0BBE: return (unp_s==0x0BC6)||(unp_s==0x0BC7);
     case 0x0BD7: return (unp_s==0x0B92)||(unp_s==0x0BC6);
     case 0x0C56: return (unp_s==0x0C46);
     case 0x0CC2:  /* fall through */
     case 0x0CD6: return (unp_s==0x0CC6);
     case 0x0CD5: return (unp_s==0x0CBF)||(unp_s==0x0CC6)||(unp_s==0x0CCA);
     case 0x0D3E: return (unp_s==0x0D46)||(unp_s==0x0D47);
     case 0x0D57: return (unp_s==0x0D46);
     case 0x0DCA: return (unp_s==0x0DD9)||(unp_s==0x0DDC);
     case 0x0DCF:  /* fall through */
     case 0x0DDF: return (unp_s==0x0DD9)||(unp_s==0x0DDA);
     case 0x102E: return (unp_s==0x1025);
     case 0x1B35:
       switch (unp_s) {
         case 0x1B05: case 0x1B07: case 0x1B09: case 0x1B0B: case 0x1B0D:
         case 0x1B11: case 0x1B3A: case 0x1B3C: case 0x1B3E: case 0x1B3F:
         case 0x1B42: return TRUE;
         default: return FALSE;
       }
     case 0x3099:
       switch (unp_s) {
         case 0x3046: case 0x304B: case 0x304D: case 0x304F: case 0x3051:
         case 0x3053: case 0x3055: case 0x3057: case 0x3059: case 0x305B:
         case 0x305D: case 0x305F: case 0x3061: case 0x3064: case 0x3066:
         case 0x3068: case 0x306F: case 0x3072: case 0x3075: case 0x3078:
         case 0x307B: case 0x309D: case 0x30A6: case 0x30AB: case 0x30AD:
         case 0x30AF: case 0x30B1: case 0x30B3: case 0x30B5: case 0x30B7:
         case 0x30B9: case 0x30BB: case 0x30BD: case 0x30BF: case 0x30C1:
         case 0x30C4: case 0x30C6: case 0x30C8: case 0x30CF: case 0x30D2:
         case 0x30D5: case 0x30D8: case 0x30DB: case 0x30EF: case 0x30F0:
         case 0x30F1: case 0x30F2: case 0x30FD: return TRUE;
         default: return FALSE;
       }
     case 0x309A:
       switch (unp_s) {
         case 0x306F: case 0x3072: case 0x3075: case 0x3078: case 0x307B:
         case 0x30CF: case 0x30D2: case 0x30D5: case 0x30D8: case 0x30DB:
         return TRUE;
         default: return FALSE;
       }
     case 0x110BA: return (unp_s==0x11099)||(unp_s==0x1109B)||(unp_s==0x110A5);
     case 0x11127: return (unp_s==0x11131)||(unp_s==0x11132);
     default: return FALSE;
   }
} /* end m_idna_cannotbe_nfc()                                         */

/**
* perform a lowercase comparison of strings, UTF-8 with UTF-8
*  @param[out] aimp_result 0 if lowercase of achp_p1 and lowercase of achp_p2
*                          are equal; else the absolute value is a 1-based
*                          byte-index where the (first) difference is,
*                          and the sign is negative if the lowercase of achp_p2
*                          is higher (sorts below) than the lowercase of achp_p1
*  @param achp_p1 string to compare with achp_p2
*  @param inl_len_p1 length of achp_p1 in bytes
*  @param achp_p2 string to compare with achp_p1
*  @param inl_len_p2 length of achp_p2 in bytes
*  @return whether successful
*/
extern PTYPE BOOL m_cmpi_u8l_u8l( int *aimp_result,
                                  const char *achp_p1, int inl_len_p1,
                                  const char *achp_p2, int inl_len_p2 ) {
   int        inl_cmp;                      /* compare values          */
   int        inl_bc;                       /* byte count in character */
   const char *achl_p1_cur;                 /* string 1 current        */
   const char *achl_p1_last;                /* string 1 last pos       */
   const char *achl_p1_end;                 /* string 1 end            */
   const char *achl_p2_cur;                 /* string 2 current        */
// char       *achl_p2_last;                /* string 2 last pos       */
   const char *achl_p2_end;                 /* string 2 end            */
   unsigned int uml_ch_p1, uml_ch_p2;
   achl_p1_cur = achp_p1;                   /* get string 1 UTF-8      */
   achl_p1_end = achp_p1 + inl_len_p1;
   achl_p2_cur = achp_p2;                   /* get string 2 UTF-8      */
   achl_p2_end = achp_p2 + inl_len_p2;
   while (TRUE) {                           /* loop over all characters */
     if (achl_p1_cur >= achl_p1_end) {      /* end of string 1         */
       if (achl_p2_cur >= achl_p2_end) {    /* also end of string 2    */
         *aimp_result = 0;                  /* both are equal          */
         return TRUE;                       /* all valid               */
       }
       *aimp_result = -1 - (achl_p2_cur - achp_p2);  /* string 2 higher */
       return TRUE;                         /* all valid               */
     }
     if (achl_p2_cur >= achl_p2_end) {
       *aimp_result = 1 + achl_p1_cur - achp_p1;  /* string 1 higher   */
       return TRUE;                         /* all valid               */
     }
     /* get Unicode Character from String 1                            */
     achl_p1_last = achl_p1_cur;            /* save parameter 1 last pos */
     if (((signed char) *achl_p1_cur) >= 0) {
       uml_ch_p1 = (unsigned int) *achl_p1_cur++;
     } else {
       uml_ch_p1 = (unsigned int) *achl_p1_cur++;
       inl_bc = chrs_decode_utf_1_tab[uml_ch_p1] - 1;
       uml_ch_p1 &= (0x3F>>inl_bc);
       while(inl_bc-- >= 0) {
         if (achl_p1_cur >= achl_p1_end) {
           return FALSE;
         }
         if (chrs_decode_utf_1_tab[(unsigned char)(*achl_p1_cur)] != 1) {
           return FALSE;
         }
         uml_ch_p1 <<= 6;
         uml_ch_p1 |= *achl_p1_cur++ & 0X3F;
       }
     }
     /* get Unicode Character from String 2                            */
//   achl_p2_last = achl_p2_cur;            /* save parameter 2 last pos */
     if (((signed char) *achl_p2_cur) >= 0) {
       uml_ch_p2 = (unsigned int) *achl_p2_cur++;
     } else {
       uml_ch_p2 = (unsigned int) *achl_p2_cur++;
       inl_bc = chrs_decode_utf_1_tab[uml_ch_p2] - 1;
       uml_ch_p2 &= (0x3F>>inl_bc);
       while(inl_bc-- >= 0) {
         if (achl_p2_cur >= achl_p2_end) {
           return FALSE;
         }
         if (chrs_decode_utf_1_tab[(unsigned char)(*achl_p2_cur)] != 1) {
           return FALSE;
         }
         uml_ch_p2 <<= 6;
         uml_ch_p2 |= *achl_p2_cur++ & 0X3F;
       }
     }
     inl_cmp = m_trans_32_to_lc( uml_ch_p1 ) - m_trans_32_to_lc( uml_ch_p2 );
     if (inl_cmp == 0) continue;
     if (inl_cmp < 0) {                     /* String 2 higher         */
/* modified 16.01.11 - return always position in first string          */
//     *aimp_result = -1 - (achl_p2_last - achp_p2);  /* string 2 higher */
       *aimp_result = -1 - (achl_p1_last - achp_p1);  /* string 2 higher */
       return TRUE;                         /* all valid               */
     }
     *aimp_result = 1 + achl_p1_last - achp_p1;  /* string 1 higher    */
     return TRUE;                           /* all valid               */
   }
} /* end m_cmpi_u8l_u8l()                                              */

/**
* perform a lowercase comparison of strings, UTF-16 with UTF-8
*  @param[out] aimp_result 0 if lowercase of awcp_p1 and lowercase of achp_p2
*                          are equal; else the absolute value is a 1-based index
*                          of bytes in awcp_p1 where the (first) difference is,
*                          and the sign is negative if the lowercase of achp_p2
*                          is higher (sorts below) than the lowercase of awcp_p1
*  @param awcp_p1 string to compare with achp_p2, zero-terminated, no surrogates
*  @param achp_p2 string to compare with awcp_p1, UTF-8 containing only
*                 characters below codepoint U+10000
*  @param inl_len_p2 length of achp_p2 in bytes
*  @return whether successful
*/
extern PTYPE BOOL m_cmpi_u16z_u8l( int *aimp_result,
                                   const HL_WCHAR *awcp_p1,
                                   const char *achp_p2, int inl_len_p2 ) {
   int            inl_cmp;                  /* compare values          */
   const HL_WCHAR *awcl_p1_cur;             /* string 1 current        */
   const char     *achl_p2_cur;             /* string 2 current        */
// const char     *achl_p2_last;            /* string 2 last pos       */
   const char     *achl_p2_end;             /* string 2 end            */
   HL_WCHAR       wcl_p2;
   awcl_p1_cur = awcp_p1;                   /* get string 1 UTF-16     */
   achl_p2_cur = achp_p2;                   /* get string 2 UTF-8      */
   achl_p2_end = achp_p2 + inl_len_p2;
   while (TRUE) {
     if (*awcl_p1_cur == 0) {               /* end of string 1         */
       if (achl_p2_cur >= achl_p2_end) {    /* also end of string 2    */
         *aimp_result = 0;                  /* both are equal          */
         return TRUE;                       /* all valid               */
       }
/* modified 16.01.11 - return always position in first string          */
//     *aimp_result = -1 - (achl_p2_cur - achp_p2);  /* string 2 higher */
       *aimp_result = -1 - (awcl_p1_cur - awcp_p1);  /* string 2 higher */
       return TRUE;                         /* all valid               */
     }
     if (achl_p2_cur >= achl_p2_end) {
       *aimp_result = 1 + awcl_p1_cur - awcp_p1;  /* string 1 higher   */
       return TRUE;                         /* all valid               */
     }
     /* get Unicode Character from String 2                            */
//   achl_p2_last = achl_p2_cur;            /* save parameter 2 last pos */
     if (((signed char) *achl_p2_cur) >= 0) {
       wcl_p2 = (unsigned short int) *achl_p2_cur++;
     } else {
       wcl_p2 = (WCHAR) *achl_p2_cur++;
       if (achl_p2_cur >= achl_p2_end) {
         return FALSE;
       }
       if (((signed char) *achl_p2_cur) >= 0) {
         return FALSE;
       }
       if ((*achl_p2_cur & 0X40) != 0) {
         return FALSE;
       }
       if ((wcl_p2 & 0X20) == 0) {
         wcl_p2 &= 0X1F;
         wcl_p2 <<= 6;
         wcl_p2 |= *achl_p2_cur++ & 0X3F;
       } else {
         wcl_p2 &= 0X0F;
         wcl_p2 <<= 6;
         wcl_p2 |= *achl_p2_cur++ & 0X3F;
         if (achl_p2_cur >= achl_p2_end) {
           return FALSE;
         }
         if (((signed char) *achl_p2_cur) >= 0) {
           return FALSE;
         }
         if ((*achl_p2_cur & 0X40) != 0) {
           return FALSE;
         }
         wcl_p2 <<= 6;
         wcl_p2 |= *achl_p2_cur++ & 0X3F;
       }
     }
     inl_cmp = m_trans_to_lc( *awcl_p1_cur++ ) - m_trans_to_lc( wcl_p2 );
     if (inl_cmp == 0) continue;
     if (inl_cmp < 0) {                     /* String 2 higher         */
/* modified 16.01.11 - return always position in first string          */
//     *aimp_result = -1 - (achl_p2_last - achp_p2);  /* string 2 higher */
       *aimp_result = 0 - (awcl_p1_cur - awcp_p1);  /* string 2 higher */
       return TRUE;                         /* all valid               */
     }
     *aimp_result = awcl_p1_cur - awcp_p1;  /* string 1 higher         */
     return TRUE;                           /* all valid               */
   }
} /* end m_cmpi_u16z_u8l()                                             */

/**
* Perform a lowercase comparison of two zero-terminated 16-bit strings
*  @param awcp_p1 zero-terminated string in UTF16-like format with no surrogates
*  @param awcp_p2 zero-terminated string in UTF16-like format with no surrogates
*  @return 0 if lowercase of awcp_p1 and lowercase of awcp_p2 are equal; else
*          the absolute value is 1-based index where the (first) difference is,
*          and the sign is negative if the lc of awcp_p2 is higher (sorts below)
*/
extern PTYPE int m_cmpi_u16z_u16z( const HL_WCHAR *awcp_p1, const HL_WCHAR *awcp_p2 ) {
   int        inl_cmp;                      /* compare values          */
   const HL_WCHAR *awcl_p1_cur;             /* string 1 current        */
   const HL_WCHAR *awcl_p2_cur;             /* string 2 current        */

   awcl_p1_cur = awcp_p1;                   /* get string 1 UTF-16     */
   awcl_p2_cur = awcp_p2;                   /* get string 2 UTF-16     */
   while (TRUE) {
     inl_cmp = m_trans_to_lc( *awcl_p1_cur ) - m_trans_to_lc( *awcl_p2_cur );
     if (inl_cmp) {                         /* characters not equal    */
       if (inl_cmp < 0) {                   /* String 2 higher         */
/* modified 16.01.11 - return always position in first string          */
//       return -1 - (awcl_p2_cur - awcp_p2 );  /* string 2 higher     */
         return -1 - (awcl_p1_cur - awcp_p1 );  /* string 2 higher     */
       }
       return 1 + awcl_p1_cur - awcp_p1;    /* string 1 higher         */
     }
     if (*awcl_p1_cur == 0) {               /* end of string 1         */
       return 0;                            /* strings are equal       */
     }
     awcl_p1_cur++;                         /* next input character    */
     awcl_p2_cur++;                         /* next input character    */
   }
} /* end m_cmpi_u16z_u16z()                                            */

/**
* perform a comparison of strings, UTF-16 with UTF-8
*  @param[out] aimp_result 0 if awcp_p1 and achp_p2 are equal; else the absolute
*                          value indicates (1-based) where the (first)
*                          difference is, and the sign is negative if achp_p2 is
*                          higher (sorts below) than awcp_p1.
*  @param awcp_p1 string to compare with achp_p2, zero-terminated, surrogates
*                 are not supported (except if achp_p2 is really in CESU-8)
*  @param achp_p2 string to compare with awcp_p1, zero-terminated UTF-8,
*                 containing only characters below codepoint U+10000
*  @return whether successful
*/
extern PTYPE BOOL m_cmp_u16z_u8z( int *aimp_result, const HL_WCHAR *awcp_p1, const char *achp_p2 ) {
   int            inl_cmp;                  /* compare values          */
   const HL_WCHAR *awcl_p1_cur;             /* string 1 current        */
   const char     *achl_p2_cur;             /* string 2 current        */
// char           *achl_p2_last;            /* string 2 last pos       */
   const char     *achl_p2_end;             /* string 2 end            */
   HL_WCHAR       wcl_p2;
   awcl_p1_cur = awcp_p1;                   /* get string 1 UTF-16     */
   achl_p2_cur = achp_p2;                   /* get string 2 UTF-8      */
   achl_p2_end = achp_p2 + strlen( achp_p2 );  /* get of string UTF-8  */
   while (TRUE) {
     if (*awcl_p1_cur == 0) {               /* end of string 1         */
       if (achl_p2_cur >= achl_p2_end) {    /* also end of string 2    */
         *aimp_result = 0;                  /* both are equal          */
         return TRUE;                       /* all valid               */
       }
       *aimp_result = -1 - (achl_p2_cur - achp_p2);  /* string 2 higher */
       /*XXX exception to the "modified 16.01.11"-places - intentional? */
       return TRUE;                         /* all valid               */
     }
     if (achl_p2_cur >= achl_p2_end) {
       *aimp_result = 1 + awcl_p1_cur - awcp_p1;  /* string 1 higher   */
       return TRUE;                         /* all valid               */
     }
     /* get Unicode Character from String 2                            */
//   achl_p2_last = achl_p2_cur;            /* save parameter 2 last pos */
     if (((signed char) *achl_p2_cur) >= 0) {
       wcl_p2 = (HL_WCHAR) *achl_p2_cur++;
     } else {
       wcl_p2 = (HL_WCHAR) *achl_p2_cur++;
       if (achl_p2_cur >= achl_p2_end) {
         return FALSE;
       }
       if (((signed char) *achl_p2_cur) >= 0) {
         return FALSE;
       }
       if ((*achl_p2_cur & 0X40) != 0) {
         return FALSE;
       }
       if ((wcl_p2 & 0X20) == 0) {
         wcl_p2 &= 0X1F;
         wcl_p2 <<= 6;
         wcl_p2 |= *achl_p2_cur++ & 0X3F;
       } else {
         wcl_p2 &= 0X0F;
         wcl_p2 <<= 6;
         wcl_p2 |= *achl_p2_cur++ & 0X3F;
         if (achl_p2_cur >= achl_p2_end) {
           return FALSE;
         }
         if (((signed char) *achl_p2_cur) >= 0) {
           return FALSE;
         }
         if ((*achl_p2_cur & 0X40) != 0) {
           return FALSE;
         }
         wcl_p2 <<= 6;
         wcl_p2 |= *achl_p2_cur++ & 0X3F;
       }
     }
     inl_cmp = *awcl_p1_cur++ - wcl_p2;     /* compare the two values  */
     if (inl_cmp == 0) continue;
     if (inl_cmp < 0) {                     /* String 2 higher         */
/* modified 16.01.11 - return always position in first string          */
//     *aimp_result = -1 - (achl_p2_last - achp_p2);  /* string 2 higher */
       *aimp_result = 0 - (awcl_p1_cur - awcp_p1);  /* string 2 higher */
       return TRUE;                         /* all valid               */
     }
     *aimp_result = awcl_p1_cur - awcp_p1;  /* string 1 higher         */
     return TRUE;                           /* all valid               */
   }
} /* end m_cmp_u16z_u8z()                                              */

#ifdef HL_UNIX
/**
* Perform a comparison of two zero-terminated 16-bit strings
*  @param awcp_p1 zero-terminated string in UTF16-like format
*  @param awcp_p2 zero-terminated string in UTF16-like format
*  @return 0 if awcp_p1 and awcp_p2 are equal; else the absolute value is
*          1-based index where the (first) difference is, and the sign is
*          negative if awcp_p2 is higher (sorts below) than awcp_p1.
*          Note that UTF-16 surrogates are not fully supported, but the
*          return value as a boolean (0 or !=0) should be OK even with them.
*/
extern PTYPE int m_cmp_u16z_u16z( const HL_WCHAR *awcp_p1, const HL_WCHAR *awcp_p2 ) {
   int            inl_cmp;                  /* compare values          */
   const HL_WCHAR *awcl_p1_cur;             /* string 1 current        */
   const HL_WCHAR *awcl_p2_cur;             /* string 2 current        */
//   HL_WCHAR   wcl_p2;

   awcl_p1_cur = awcp_p1;                   /* get string 1 UTF-16     */
   awcl_p2_cur = awcp_p2;                   /* get string 2 UTF-16     */
   while (TRUE) {
     inl_cmp = *awcl_p1_cur - *awcl_p2_cur;
     if (inl_cmp) {                         /* characters not equal    */
       if (inl_cmp < 0) {                   /* String 2 higher         */
/* modified 16.01.11 - return always position in first string          */
//       return -1 - (awcl_p2_cur - awcp_p2 );  /* string 2 higher     */
         return -1 - (awcl_p1_cur - awcp_p1 );  /* string 2 higher     */
       }
       return 1 + awcl_p1_cur - awcp_p1;    /* string 1 higher         */
     }
     if (*awcl_p1_cur == 0) {               /* end of string 1         */
       return 0;                            /* strings are equal       */
     }
     awcl_p1_cur++;                         /* next input character    */
     awcl_p2_cur++;                         /* next input character    */
   }
} /* end m_cmp_u16z_u16z()                                             */

/**
* Get length of a zero-terminated 16-bit string (UTF-16)
*  @param awcp_source the string
*  @return the length (without the terminating 0) counted in 16-bit-units.
*          Note that with surrogates present this is not the length in chars.
*/
extern PTYPE int m_len_u16z( const HL_WCHAR *awcp_source ) {
   int        inl_len;                      /* count characters        */

   inl_len = 0;                             /* clear count characters  */
   while (*awcp_source) {                   /* loop over input characters */
     inl_len++;                             /* count this characters   */
     awcp_source++;                         /* then check next character */
   }
   return inl_len;                          /* return what counted     */
} /* end m_len_u16z()                                                  */
#endif

/* TODO (from KB 2030524): compare IDNA where currently IDNACMP_WORKAROUND20121112 */

/* macros for m_cmp_vx_vx and m_cmpi_vx_vx                           { */
/* } end macros for m_cmp_vx_vx and m_cmpi_vx_vx                       */

/**
* perform a comparison of strings, give type of string
*  @param[out] aimp_result 0 if ap_p1 and ap_p2 are equal; else the absolute
*                          value is 1-based index (into ap_p1, in 8-, 16- or
*                          32-byte units depending on iep_cs_p1) where the
*                          (first) difference is, and the sign is negative
*                          if ap_p2 is higher (sorts below) than ap_p1.
*  @param ap_p1 string to compare with ap_p2
*  @param imp_len_p1 negative to mean string ap_p1 is 0-terminated, else its
*                    length in units (8-, 16, or 32-byte depending on iep_cs_p1)
*  @param iep_cs_p1 encoding used by ap_p1
*  @param ap_p2 string to compare with ap_p1
*  @param imp_len_p2 negative to mean string ap_p2 is 0-terminated, else its
*                    length in units (8-, 16, or 32-byte depending on iep_cs_p2)
*  @param iep_cs_p2 encoding used by ap_p2
*  @return whether successful
*/
extern PTYPE BOOL m_cmp_vx_vx( int *aimp_result,
                               const void *ap_p1, int imp_len_p1, enum ied_charset iep_cs_p1,
                               const void *ap_p2, int imp_len_p2, enum ied_charset iep_cs_p2 ) {
   const char *achl_cur_p1, *achl_cur_p2;   /* current position parameters */
   const char *achl_end_p1, *achl_end_p2;   /* end of parameters       */
   unsigned int uml_ch_p1, uml_ch_p2;       /* characters decoded      */
   int        iml_len_ch_p1, iml_len_ch_p2;  /* length of parameters   */

   /* calculate end of parameter 1                                     */
   achl_cur_p1 = (const char *) ap_p1;
   achl_end_p1 = NULL;                      /* still zero-terminated   */
   if (imp_len_p1 >= 0) {                   /* length p1 given         */
     switch (iep_cs_p1) {
#ifdef IDNACMP_WORKAROUND20121112
       case ied_chs_idna_1:                 /* IDNA RFC 3490 - Punycode */
         iep_cs_p1 = ied_chs_ascii_850;     /* and fall through        */
#endif
       case ied_chs_ascii_850:              /* ASCII 850               */
       case ied_chs_ansi_819:               /* ANSI 819                */
       CASE_IED_CHS_MISCCODEPAGES
       CASE_IED_CHS_ALL_CJK
       CASE_IED_CHS_ISO8859_2TO16
       case ied_chs_utf_8:                  /* Unicode UTF-8           */
       case ied_chs_xml_utf_8:              /* UTF-8 with XML-CharRef  */
       case ied_chs_xml_wcp_1252:           /* Windows-1252 with XML-CharRef */
       case ied_chs_html_1:                 /* HTML character set      */
       case ied_chs_uri_1:                  /* URI (percent-escaped)   */
       case ied_chs_ldap_escaped_utf_8:     /* LDAP UTF-8 escaped      */
       case ied_chs_hsf_1:                  /* HOB special file system */
         achl_end_p1 = ((const char *) ap_p1) + imp_len_p1;
         break;
       CASE_IED_CHS_U16_ALLENDIAN
       case ied_chs_xml_utf_16:             /* UTF-16 with XML-CharRef */
         achl_end_p1 = ((const char *) ap_p1) + imp_len_p1 * sizeof(HL_WCHAR);
         break;
       CASE_IED_CHS_U32_ALLENDIAN
         achl_end_p1 = ((const char *) ap_p1) + imp_len_p1 * sizeof(unsigned int);
         break;
       default:
         return FALSE;                      /* cannot compare          */
     }
#ifdef IDNACMP_WORKAROUND20121112
   } else {
     if (iep_cs_p1 == ied_chs_idna_1)       /* IDNA RFC 3490 - Punycode */
         iep_cs_p1 = ied_chs_ascii_850;
#endif
   }
   /* calculate end of parameter 2                                     */
   achl_cur_p2 = (const char *) ap_p2;
   achl_end_p2 = NULL;                      /* still zero-terminated   */
   if (imp_len_p2 >= 0) {                   /* length p2 given         */
     switch (iep_cs_p2) {
#ifdef IDNACMP_WORKAROUND20121112
       case ied_chs_idna_1:                 /* IDNA RFC 3490 - Punycode */
         iep_cs_p2 = ied_chs_ascii_850;     /* and fall through        */
#endif
       case ied_chs_ascii_850:              /* ASCII 850               */
       case ied_chs_ansi_819:               /* ANSI 819                */
       CASE_IED_CHS_MISCCODEPAGES
       CASE_IED_CHS_ALL_CJK
       CASE_IED_CHS_ISO8859_2TO16
       case ied_chs_utf_8:                  /* Unicode UTF-8           */
       case ied_chs_xml_utf_8:              /* UTF-8 with XML-CharRef  */
       case ied_chs_xml_wcp_1252:           /* Windows-1252 with XML-CharRef */
       case ied_chs_html_1:                 /* HTML character set      */
       case ied_chs_uri_1:                  /* URI (percent-escaped)   */
       case ied_chs_ldap_escaped_utf_8:     /* LDAP UTF-8 escaped      */
       case ied_chs_hsf_1:                  /* HOB special file system */
         achl_end_p2 = ((const char *) ap_p2) + imp_len_p2;
         break;
       CASE_IED_CHS_U16_ALLENDIAN
       case ied_chs_xml_utf_16:             /* UTF-16 with XML-CharRef */
         achl_end_p2 = ((const char *) ap_p2) + imp_len_p2 * sizeof(HL_WCHAR);
         break;
       CASE_IED_CHS_U32_ALLENDIAN
         achl_end_p2 = ((const char *) ap_p2) + imp_len_p2 * sizeof(unsigned int);
         break;
       default:
         return FALSE;                      /* cannot compare          */
     }
#ifdef IDNACMP_WORKAROUND20121112
   } else {
     if (iep_cs_p2 == ied_chs_idna_1)       /* IDNA RFC 3490 - Punycode */
         iep_cs_p2 = ied_chs_ascii_850;
#endif
   }

   pcmp_00:                                 /* compare characters      */
   iml_len_ch_p1 = m_get_vc_ch( &uml_ch_p1, achl_cur_p1, achl_end_p1, iep_cs_p1 );
   if (iml_len_ch_p1 < 0) {                 /* subroutine reported error */
     return FALSE;
   }
   iml_len_ch_p2 = m_get_vc_ch( &uml_ch_p2, achl_cur_p2, achl_end_p2, iep_cs_p2 );
   if (iml_len_ch_p2 < 0) {                 /* subroutine reported error */
     return FALSE;
   }
   if (iml_len_ch_p1 == 0) {                /* end of string one       */
     if (iml_len_ch_p2 == 0) {              /* also end of string two  */
       *aimp_result = 0;                    /* strings are equal       */
       return TRUE;                         /* all o.k.                */
     }
     goto pcmp_p1_less;                     /* parameter 1 is smaller  */
   }
   if (iml_len_ch_p2 == 0) {                /* end of string two       */
     goto pcmp_p1_greater;                  /* parameter 1 is greater  */
   }
   if (uml_ch_p1 == uml_ch_p2) {            /* characters are equal    */
     achl_cur_p1 += iml_len_ch_p1;          /* next position parameter 1 */
     achl_cur_p2 += iml_len_ch_p2;          /* next position parameter 2 */
     goto pcmp_00;                          /* compare characters      */
   }
   if (uml_ch_p1 > uml_ch_p2) {             /* compare characters      */
     goto pcmp_p1_greater;                  /* parameter 1 is greater  */
   }

   pcmp_p1_less:                            /* parameter 1 is smaller  */
/* modified 16.01.11 - return always position in first string, from    */
// *aimp_result = ((char *) ap_p2) - achl_cur_p2;  /* difference is minus position parameter 2 */
// to
// *aimp_result = ((char *) ap_p1) - achl_cur_p1;  /* difference is minus position parameter 1 */
   switch (iep_cs_p1) {
     CASE_IED_CHS_U32_ALLENDIAN
       *aimp_result = ((const unsigned int*)ap_p1) - ((const unsigned int*)achl_cur_p1);
       break;
     CASE_IED_CHS_U16_ALLENDIAN
     case ied_chs_xml_utf_16:               /* UTF-16 with XML-CharRef */
       *aimp_result = ((const HL_WCHAR*)ap_p1) - ((const HL_WCHAR*)achl_cur_p1);
       break;
     default:
       *aimp_result = ((const char *) ap_p1) - achl_cur_p1;
       break;
   }
   *aimp_result -= 1;                       /* subtract one, zero not possible */
   return TRUE;                             /* all o.k.                */

   pcmp_p1_greater:                         /* parameter 1 is greater  */
   switch (iep_cs_p1) {
     CASE_IED_CHS_U32_ALLENDIAN
       *aimp_result = (const unsigned int*)achl_cur_p1 - (const unsigned int*)ap_p1;
       break;
     CASE_IED_CHS_U16_ALLENDIAN
     case ied_chs_xml_utf_16:               /* UTF-16 with XML-CharRef */
       *aimp_result = (const HL_WCHAR*)achl_cur_p1 - (const HL_WCHAR*)ap_p1;
       break;
     default:
       *aimp_result = achl_cur_p1 - (const char *) ap_p1;
       break;
   }
   *aimp_result += 1;                       /* add one, zero not possible */
   return TRUE;                             /* all o.k.                */
} /* end m_cmp_vx_vx()                                                 */

/**
* perform a comparison of strings, give type of string.
*  The comparison is not case-sensitive
*  @param[out] aimp_result 0 if lowercase of ap_p1 and lowercase of ap_p2 are
*                          equal; else the absolute value is 1-based index (into
*                          ap_p1, in 8/16/32-byte units depending on iep_cs_p1)
*                          where the (first) difference is, and the sign is
*                          negative if the lowercase of ap_p2 is higher (sorts
*                          below) than the lowercase of ap_p1.
*  @param ap_p1 string to compare with ap_p2
*  @param imp_len_p1 negative to mean string ap_p1 is 0-terminated, else its
*                    length in units (8-, 16, or 32-byte depending on iep_cs_p1)
*  @param iep_cs_p1 encoding used by ap_p1
*  @param ap_p2 string to compare with ap_p1
*  @param imp_len_p2 negative to mean string ap_p2 is 0-terminated, else its
*                    length in units (8-, 16, or 32-byte depending on iep_cs_p2)
*  @param iep_cs_p2 encoding used by ap_p2
*  @return whether successful
*/
extern PTYPE BOOL m_cmpi_vx_vx( int *aimp_result,
                                const void *ap_p1, int imp_len_p1, enum ied_charset iep_cs_p1,
                                const void *ap_p2, int imp_len_p2, enum ied_charset iep_cs_p2 ) {
   const char *achl_cur_p1, *achl_cur_p2;   /* current position parameters */
   const char *achl_end_p1, *achl_end_p2;   /* end of parameters       */
   unsigned int uml_ch_p1, uml_ch_p2;       /* characters decoded      */
   int        iml_len_ch_p1, iml_len_ch_p2;  /* length of parameters   */

   /* calculate end of parameter 1                                     */
   achl_cur_p1 = (const char *) ap_p1;
   achl_end_p1 = NULL;                      /* still zero-terminated   */
   if (imp_len_p1 >= 0) {                   /* length p1 given         */
     switch (iep_cs_p1) {
#ifdef IDNACMP_WORKAROUND20121112
       case ied_chs_idna_1:                 /* IDNA RFC 3490 - Punycode */
         iep_cs_p1 = ied_chs_ascii_850;     /* and fall through        */
#endif
       case ied_chs_ascii_850:              /* ASCII 850               */
       case ied_chs_ansi_819:               /* ANSI 819                */
       CASE_IED_CHS_MISCCODEPAGES
       CASE_IED_CHS_ALL_CJK
       CASE_IED_CHS_ISO8859_2TO16
       case ied_chs_utf_8:                  /* Unicode UTF-8           */
       case ied_chs_xml_utf_8:              /* UTF-8 with XML-CharRef  */
       case ied_chs_xml_wcp_1252:           /* Windows-1252 with XML-CharRef */
       case ied_chs_html_1:                 /* HTML character set      */
       case ied_chs_uri_1:                  /* URI (percent-escaped)   */
       case ied_chs_ldap_escaped_utf_8:     /* LDAP UTF-8 escaped      */
       case ied_chs_hsf_1:                  /* HOB special file system */
         achl_end_p1 = ((const char *) ap_p1) + imp_len_p1;
         break;
       CASE_IED_CHS_U16_ALLENDIAN
       case ied_chs_xml_utf_16:             /* UTF-16 with XML-CharRef */
         achl_end_p1 = ((const char *) ap_p1) + imp_len_p1 * sizeof(HL_WCHAR);
         break;
       CASE_IED_CHS_U32_ALLENDIAN
         achl_end_p1 = ((const char *) ap_p1) + imp_len_p1 * sizeof(unsigned int);
         break;
       default:
         return FALSE;                      /* cannot compare          */
     }
#ifdef IDNACMP_WORKAROUND20121112
   } else {
     if (iep_cs_p1 == ied_chs_idna_1)       /* IDNA RFC 3490 - Punycode */
         iep_cs_p1 = ied_chs_ascii_850;
#endif
   }
   /* calculate end of parameter 2                                     */
   achl_cur_p2 = (const char *) ap_p2;
   achl_end_p2 = NULL;                      /* still zero-terminated   */
   if (imp_len_p2 >= 0) {                   /* length p2 given         */
     switch (iep_cs_p2) {
#ifdef IDNACMP_WORKAROUND20121112
       case ied_chs_idna_1:                 /* IDNA RFC 3490 - Punycode */
         iep_cs_p2 = ied_chs_ascii_850;     /* and fall through        */
#endif
       case ied_chs_ascii_850:              /* ASCII 850               */
       case ied_chs_ansi_819:               /* ANSI 819                */
       CASE_IED_CHS_MISCCODEPAGES
       CASE_IED_CHS_ALL_CJK
       CASE_IED_CHS_ISO8859_2TO16
       case ied_chs_utf_8:                  /* Unicode UTF-8           */
       case ied_chs_xml_utf_8:              /* UTF-8 with XML-CharRef  */
       case ied_chs_xml_wcp_1252:           /* Windows-1252 with XML-CharRef */
       case ied_chs_html_1:                 /* HTML character set      */
       case ied_chs_uri_1:                  /* URI (percent-escaped)   */
       case ied_chs_ldap_escaped_utf_8:     /* LDAP UTF-8 escaped      */
       case ied_chs_hsf_1:                  /* HOB special file system */
         achl_end_p2 = ((const char *) ap_p2) + imp_len_p2;
         break;
       CASE_IED_CHS_U16_ALLENDIAN
       case ied_chs_xml_utf_16:             /* UTF-16 with XML-CharRef */
         achl_end_p2 = ((const char *) ap_p2) + imp_len_p2 * sizeof(HL_WCHAR);
         break;
       CASE_IED_CHS_U32_ALLENDIAN
         achl_end_p2 = ((const char *) ap_p2) + imp_len_p2 * sizeof(unsigned int);
         break;
       default:
         return FALSE;                      /* cannot compare          */
     }
#ifdef IDNACMP_WORKAROUND20121112
   } else {
     if (iep_cs_p2 == ied_chs_idna_1)       /* IDNA RFC 3490 - Punycode */
         iep_cs_p2 = ied_chs_ascii_850;
#endif
   }

   pcmp_00:                                 /* compare characters      */
   iml_len_ch_p1 = m_get_vc_ch( &uml_ch_p1, achl_cur_p1, achl_end_p1, iep_cs_p1 );
   if (iml_len_ch_p1 < 0) {                 /* subroutine reported error */
     return FALSE;
   }
   iml_len_ch_p2 = m_get_vc_ch( &uml_ch_p2, achl_cur_p2, achl_end_p2, iep_cs_p2 );
   if (iml_len_ch_p2 < 0) {                 /* subroutine reported error */
     return FALSE;
   }
   if (iml_len_ch_p1 == 0) {                /* end of string one       */
     if (iml_len_ch_p2 == 0) {              /* also end of string two  */
       *aimp_result = 0;                    /* strings are equal       */
       return TRUE;                         /* all o.k.                */
     }
     goto pcmp_p1_less;                     /* parameter 1 is smaller  */
   }
   if (iml_len_ch_p2 == 0) {                /* end of string two       */
     goto pcmp_p1_greater;                  /* parameter 1 is greater  */
   }
   uml_ch_p1 = m_trans_32_to_lc( uml_ch_p1 );  /* translate to lower case */
   uml_ch_p2 = m_trans_32_to_lc( uml_ch_p2 );  /* translate to lower case */
   if (uml_ch_p1 == uml_ch_p2) {            /* characters are equal    */
     achl_cur_p1 += iml_len_ch_p1;          /* next position parameter 1 */
     achl_cur_p2 += iml_len_ch_p2;          /* next position parameter 2 */
     goto pcmp_00;                          /* compare characters      */
   }
   if (uml_ch_p1 > uml_ch_p2) {             /* compare characters      */
     goto pcmp_p1_greater;                  /* parameter 1 is greater  */
   }

   pcmp_p1_less:                            /* parameter 1 is smaller  */
/* modified 16.01.11 - return always position in first string, from    */
// *aimp_result = ((char *) ap_p2) - achl_cur_p2;  /* difference is minus position parameter 2 */
// to
// *aimp_result = ((char *) ap_p1) - achl_cur_p1;  /* difference is minus position parameter 1 */
   switch (iep_cs_p1) {
     CASE_IED_CHS_U32_ALLENDIAN
       *aimp_result = ((const unsigned int*)ap_p1) - ((const unsigned int*)achl_cur_p1);
       break;
     CASE_IED_CHS_U16_ALLENDIAN
     case ied_chs_xml_utf_16:               /* UTF-16 with XML-CharRef */
       *aimp_result = ((const HL_WCHAR*)ap_p1) - ((const HL_WCHAR*)achl_cur_p1);
       break;
     default:
       *aimp_result = ((const char *) ap_p1) - achl_cur_p1;
       break;
   }
   *aimp_result -= 1;                       /* subtract one, zero not possible */
   return TRUE;                             /* all o.k.                */

   pcmp_p1_greater:                         /* parameter 1 is greater  */
   switch (iep_cs_p1) {
     CASE_IED_CHS_U32_ALLENDIAN
       *aimp_result = (const unsigned int*)achl_cur_p1 - (const unsigned int*)ap_p1;
       break;
     CASE_IED_CHS_U16_ALLENDIAN
     case ied_chs_xml_utf_16:               /* UTF-16 with XML-CharRef */
       *aimp_result = (const HL_WCHAR*)achl_cur_p1 - (const HL_WCHAR*)ap_p1;
       break;
     default:
       *aimp_result = achl_cur_p1 - (const char *) ap_p1;
       break;
   }
   *aimp_result += 1;                       /* add one, zero not possible */
   return TRUE;                             /* all o.k.                */
} /* end m_cmpi_vx_vx()                                                */

/**
* perform a comparison of strings, give type of string.
   The comparison is not case-sensitive
   The second string may contain wildcard characters * or ?
*  @param[out] aimp_result 0 if lowercase of ap_p1 matches the pattern given by
*                          lowercase of ap_p2 (where a '?' matches 1 character
*                          of ap_p1, and a '*' anything);
*                          else the offset (in bytes) to the mismatch in ap_p1.
*  @param ap_p1 string to compare/match with the pattern
*  @param imp_len_p1 negative to mean string ap_p1 is 0-terminated, else its
*                    length in units (8-, 16, or 32-byte depending on iep_cs_p1)
*  @param iep_cs_p1 encoding used by ap_p1
*  @param ap_p2 pattern string
*  @param imp_len_p2 negative to mean string ap_p2 is 0-terminated, else its
*                    length in units (8-, 16, or 32-byte depending on iep_cs_p2)
*  @param iep_cs_p2 encoding used by ap_p2
*  @return whether successful
*/
extern PTYPE BOOL m_cmp_wc_i_vx_vx( int *aimp_result,
                                    const void *ap_p1, int imp_len_p1, enum ied_charset iep_cs_p1,
                                    const void *ap_p2, int imp_len_p2, enum ied_charset iep_cs_p2) {
   const char *achl_cur_p1, *achl_cur_p2;   /* current position parameters */
   const char *achl_end_p1, *achl_end_p2;   /* end of parameters       */
   const char *achl_max_p1;                 /* maximum reached equal string 1 */
   unsigned int uml_ch_p1, uml_ch_p2;       /* characters decoded      */
   int        iml_len_ch_p1, iml_len_ch_p2;  /* length of parameters   */
   int        iml_nested;                   /* nested for wildcard     */
   const char *achrl_tab_p1[ MAX_NO_WILDCARD ];  /* maximum number of wildcard characters */
   const char *achrl_tab_p2[ MAX_NO_WILDCARD ];  /* maximum number of wildcard characters */

   /* calculate end of parameter 1                                     */
   achl_cur_p1 = (const char *) ap_p1;
   achl_end_p1 = NULL;                      /* still zero-terminated   */
   if (imp_len_p1 >= 0) {                   /* length p1 given         */
     switch (iep_cs_p1) {
#ifdef IDNACMP_WORKAROUND20121112
       case ied_chs_idna_1:                 /* IDNA RFC 3490 - Punycode */
         iep_cs_p1 = ied_chs_ascii_850;     /* and fall through        */
#endif
       case ied_chs_ascii_850:              /* ASCII 850               */
       case ied_chs_ansi_819:               /* ANSI 819                */
       CASE_IED_CHS_MISCCODEPAGES
       CASE_IED_CHS_ALL_CJK
       CASE_IED_CHS_ISO8859_2TO16
       case ied_chs_utf_8:                  /* Unicode UTF-8           */
       case ied_chs_xml_utf_8:              /* UTF-8 with XML-CharRef  */
       case ied_chs_xml_wcp_1252:           /* Windows-1252 with XML-CharRef */
       case ied_chs_html_1:                 /* HTML character set      */
       case ied_chs_uri_1:                  /* URI (percent-escaped)   */
       case ied_chs_ldap_escaped_utf_8:     /* LDAP UTF-8 escaped      */
       case ied_chs_hsf_1:                  /* HOB special file system */
         achl_end_p1 = ((const char *) ap_p1) + imp_len_p1;
         break;
       CASE_IED_CHS_U16_ALLENDIAN
       case ied_chs_xml_utf_16:             /* UTF-16 with XML-CharRef */
         achl_end_p1 = ((const char *) ap_p1) + imp_len_p1 * sizeof(HL_WCHAR);
         break;
       CASE_IED_CHS_U32_ALLENDIAN
         achl_end_p1 = ((const char *) ap_p1) + imp_len_p1 * sizeof(unsigned int);
         break;
       default:
         return FALSE;                      /* cannot compare          */
     }
#ifdef IDNACMP_WORKAROUND20121112
   } else {
     if (iep_cs_p1 == ied_chs_idna_1)       /* IDNA RFC 3490 - Punycode */
         iep_cs_p1 = ied_chs_ascii_850;
#endif
   }
   /* calculate end of parameter 2                                     */
   achl_cur_p2 = (const char *) ap_p2;
   achl_end_p2 = NULL;                      /* still zero-terminated   */
   if (imp_len_p2 >= 0) {                   /* length p2 given         */
     switch (iep_cs_p2) {
       case ied_chs_ascii_850:              /* ASCII 850               */
       case ied_chs_ansi_819:               /* ANSI 819                */
       CASE_IED_CHS_MISCCODEPAGES
       CASE_IED_CHS_ALL_CJK
       CASE_IED_CHS_ISO8859_2TO16
       case ied_chs_utf_8:                  /* Unicode UTF-8           */
       case ied_chs_xml_utf_8:              /* UTF-8 with XML-CharRef  */
       case ied_chs_xml_wcp_1252:           /* Windows-1252 with XML-CharRef */
       case ied_chs_html_1:                 /* HTML character set      */
       case ied_chs_uri_1:                  /* URI (percent-escaped)   */
       case ied_chs_ldap_escaped_utf_8:     /* LDAP UTF-8 escaped      */
       case ied_chs_hsf_1:                  /* HOB special file system */
         achl_end_p2 = ((const char *) ap_p2) + imp_len_p2;
         break;
       CASE_IED_CHS_U16_ALLENDIAN
       case ied_chs_xml_utf_16:             /* UTF-16 with XML-CharRef */
         achl_end_p2 = ((const char *) ap_p2) + imp_len_p2 * sizeof(HL_WCHAR);
         break;
       CASE_IED_CHS_U32_ALLENDIAN
         achl_end_p2 = ((const char *) ap_p2) + imp_len_p2 * sizeof(unsigned int);
         break;
       default:
         return FALSE;                      /* cannot compare          */
     }
   }
   iml_nested = 0;                          /* clear nested for wildcard */
   achl_max_p1 = achl_cur_p1;               /* maximum reached equal string 1 */

   pcmp_00:                                 /* compare characters      */
   iml_len_ch_p1 = m_get_vc_ch( &uml_ch_p1, achl_cur_p1, achl_end_p1, iep_cs_p1 );
   if (iml_len_ch_p1 < 0) {                 /* subroutine reported error */
     return FALSE;
   }
   iml_len_ch_p2 = m_get_vc_ch( &uml_ch_p2, achl_cur_p2, achl_end_p2, iep_cs_p2 );
   if (iml_len_ch_p2 < 0) {                 /* subroutine reported error */
     return FALSE;
   }
   if (iml_len_ch_p2 == 0) {                /* end of string two       */
     if (iml_len_ch_p1 == 0) {              /* also end of string one  */
       *aimp_result = 0;                    /* strings are equal       */
       return TRUE;                         /* all o.k.                */
     }
     goto pcmp_not_equal;                   /* parameter 2 is smaller  */
   }
   switch (uml_ch_p2) {                     /* check wildcard          */
     case '?':                              /* ignore single character */
       if (iml_len_ch_p1 == 0) {            /* end of string one       */
         goto pcmp_not_equal;               /* parameter 2 is greater  */
       }
       achl_cur_p1 += iml_len_ch_p1;        /* next position parameter 1 */
       achl_cur_p2 += iml_len_ch_p2;        /* next position parameter 2 */
       goto pcmp_00;                        /* compare characters      */
     case '*':                              /* zero or n characters    */
       goto pcmp_aster_00;                  /* asterix wildcard        */
   }

   pcmp_20:                                 /* continue compare characters */
   if (iml_len_ch_p1 == 0) {                /* end of string one       */
     goto pcmp_not_equal;                   /* parameter 2 is greater  */
   }
   uml_ch_p1 = m_trans_32_to_lc( uml_ch_p1 );  /* translate to lower case */
   uml_ch_p2 = m_trans_32_to_lc( uml_ch_p2 );  /* translate to lower case */
   if (uml_ch_p1 == uml_ch_p2) {            /* characters are equal    */
     achl_cur_p1 += iml_len_ch_p1;          /* next position parameter 1 */
     achl_cur_p2 += iml_len_ch_p2;          /* next position parameter 2 */
     goto pcmp_00;                          /* compare characters      */
   }

   pcmp_not_equal:                          /* character is not equal  */
   if (achl_max_p1 < achl_cur_p1) achl_max_p1 = achl_cur_p1;
   if (iml_nested > 0) {                    /* still nested            */
     goto pcmp_nested_00;                   /* take characters from stack */
   }
   *aimp_result = achl_max_p1 - (const char *) ap_p1;  /* difference is position parameter 1 */
   *aimp_result += 1;                       /* add one, zero not possible */
   return TRUE;                             /* all o.k.                */

   pcmp_nested_00:                          /* take characters from stack */
   achl_cur_p1 = achrl_tab_p1[ iml_nested - 1 ];  /* take from stack   */
   achl_cur_p2 = achrl_tab_p2[ iml_nested - 1 ];  /* take from stack   */
   /* has to ignore one character in string 1                          */
   iml_len_ch_p1 = m_get_vc_ch( &uml_ch_p1, achl_cur_p1, achl_end_p1, iep_cs_p1 );
   if (iml_len_ch_p1 > 0) {                 /* valid character found   */
     achl_cur_p1 += iml_len_ch_p1;          /* after this character    */
     achrl_tab_p1[ iml_nested - 1 ] = achl_cur_p1;  /* put in stack    */
     goto pcmp_00;                          /* compare characters      */
   }
   if (iml_len_ch_p1 < 0) {                 /* subroutine reported error */
     return FALSE;
   }
   /* end of string 1                                                  */
   iml_len_ch_p2 = m_get_vc_ch( &uml_ch_p2, achl_cur_p2, achl_end_p2, iep_cs_p2 );
   if (iml_len_ch_p2 < 0) {                 /* subroutine reported error */
     return FALSE;
   }
   if (iml_len_ch_p2 == 0) {                /* end of string two       */
     *aimp_result = 0;                      /* strings are equal       */
     return TRUE;                           /* all o.k.                */
   }
   iml_nested--;                            /* put out of stack        */
   if (iml_nested > 0) {                    /* still nested            */
     goto pcmp_nested_00;                   /* take characters from stack */
   }
   *aimp_result = achl_max_p1 - (const char *) ap_p1;  /* difference is position parameter 1 */
   *aimp_result += 1;                       /* add one, zero not possible */
   return TRUE;                             /* all o.k.                */

   pcmp_aster_00:                           /* asterix wildcard        */
   achl_cur_p2 += iml_len_ch_p2;            /* next position parameter 2 */
   iml_len_ch_p2 = m_get_vc_ch( &uml_ch_p2, achl_cur_p2, achl_end_p2, iep_cs_p2 );
   if (iml_len_ch_p2 < 0) {                 /* subroutine reported error */
     return FALSE;
   }
   if (iml_len_ch_p2 == 0) {                /* end of string two       */
     *aimp_result = 0;                      /* strings are equal       */
     return TRUE;                           /* characters compare      */
   }
   switch (uml_ch_p2) {                     /* check wildcard          */
     case '?':                              /* ignore single character */
       if (iml_len_ch_p1 == 0) {            /* end of string 1         */
         goto pcmp_not_equal;               /* character is not equal  */
       }
       achl_cur_p1 += iml_len_ch_p1;        /* next position parameter 1 */
       iml_len_ch_p1 = m_get_vc_ch( &uml_ch_p1, achl_cur_p1, achl_end_p1, iep_cs_p1 );
       if (iml_len_ch_p1 < 0) {             /* subroutine reported error */
         return FALSE;
       }
       goto pcmp_aster_00;                  /* asterix wildcard        */
     case '*':                              /* zero or n characters    */
       goto pcmp_aster_00;                  /* asterix wildcard        */
   }
   if (iml_nested >= MAX_NO_WILDCARD) return FALSE;  /* maximum number of wildcard characters */
   achrl_tab_p1[ iml_nested ] = achl_cur_p1;  /* put in stack          */
   achrl_tab_p2[ iml_nested ] = achl_cur_p2;  /* put in stack          */
   iml_nested++;                            /* increment number of wildcard characters */
   goto pcmp_20;                            /* continue compare characters */
} /* end m_cmp_wc_i_vx_vx()                                            */


/*XXX test again with and without DIV!*/
#if __STDC_VERSION__ >= 199901
#define HL_USE_DIV
#else
#ifdef WIN32
#define HL_USE_DIV
#else
#if _DARWIN_FEATURE_UNIX_CONFORMANCE        /* XXX is that the correct test on mac? */
#define HL_USE_DIV
#endif
#endif
#endif
#ifdef HL_USE_DIV
#define HL_USE_LDIV /* XXX can this be assumed? */
#endif
#undef HL_USE_LLDIV
#undef HL_USE_LDIV
#undef HL_USE_DIV
/**
* Encodes some prepared piece of text into punycode. Processes a single "label"
* (typically part between dots). The ASCII-chars that will go unchanged have
* to be separated already from the others, the output will fit after them.
* Does not check for IDNA-rules-conformance, that should be checked already.
*  @param dsp_tree The array of entrys about unicode chars that cannot go into
*                  the output unchanged. Has to contain correct data (e.g. the
*                  internal pointings to form a tree sorted by codepoint number)
*  @param inp_acn count of unchanged chars (legal ASCII-chars, not in dsp_tree)
*  @param achp_target where to write the output to, which will not include the
*                     "xn--" nor the copied ASCII-chars, but start after them
*                     (with a '-' if needed) and will not be zero-terminated.
*  @param achp_end_target pointer behind the end of the output buffer
*  @return NULL if an error occurred (i.e. the output buffer is too short),
*          else a pointer behind the end of the produced punycode-text.
*/
static char* m_idna_encode_utree( struct dsd_idna_upoint* dsp_tree, int inp_acn,
                                  char* achp_target, char* achp_end_target ) {
   int inl0;
   int inl_bias = 72;                       /* parameter, see punycode RFC */
   int inl_fnbc_damp = 700;                 /* nonzero when first non-basic character */
   int inl_lec = 0x080;                     /* last encoded codepoint (unicodenumber) */
   unsigned char utl_ti=0;                  /* treelist traversing index */
   unsigned char utl_lii1 = 0;              /* last insert-index plus 1 */
   int inl_dd;                              /* delta modified for punycode bias adaptation */
#ifdef HL_USE_DIV
   /* using a variant that may utilise the hardware better             */
/*
#ifndef WIN32
   struct
#endif
*/ div_t ds__divmod;
#define IDN_DIVMOD_DELTA(INP_X) ds__divmod=div(inl_delta,INP_X)
#define inl_delta ds__divmod.quot
#define inl_delta_mod ds__divmod.rem
#else
   int inl_delta;                           /* punycode delta          */
   int inl_delta_mod;                       /* divisionremainder for punycode digit */
#define IDN_DIVMOD_DELTA(INP_X) inl_delta_mod=inl_delta%(INP_X), inl_delta/=(INP_X)
#endif
   if (inp_acn) {
     if (achp_target>=achp_end_target)
       return NULL;
     *(achp_target++) = '-';                /* separator for preceding */
   }
   while(TRUE) {
     if(dsp_tree[utl_ti].utc_l) {           /* descend to left subtree */
       unsigned char utl_down=dsp_tree[utl_ti].utc_l;
       dsp_tree[utl_ti].utc_l=0;  /* so we will not descend again here */
       utl_ti=utl_down;
       continue;
     }
     if (dsp_tree[utl_ti].umc_cp) {
       /* encode a character                                           */
       inp_acn ++;                    /* counter of handled characters */
       inl_delta = ((int)(dsp_tree[utl_ti].umc_cp)-inl_lec)*inp_acn + (int)(dsp_tree[utl_ti].utc_p)-utl_lii1;
       if (inl_fnbc_damp) {
         inl_dd=inl_delta/inl_fnbc_damp;
         inl_fnbc_damp=0;
       } else {
         inl_dd=inl_delta>>1;
       }
       inl0 = (inl_bias+1)/36;     /* count for iterations with t=tmin */
       while (inl0--) {
         /* work with t = 1 (= tmin from RFC3492 chapter 5.)           */
         if (achp_target>=achp_end_target)
           return NULL;
         if(inl_delta) {
           --inl_delta;
           IDN_DIVMOD_DELTA(35);
           *(achp_target++) = (char)(((inl_delta_mod>24)?23:'b')+inl_delta_mod);
         } else {
           *(achp_target++) = 'a';          /* value is 0, so code 'a' */
           goto p_punyseq_ready;
         }
       }
       inl0 = inl_bias%36;                  /* now inl0 := 36-t        */
       if (inl0>10) {          /* work once with an nonclamped t value */
         if (achp_target>=achp_end_target)
           return NULL;
         if(inl_delta>=36-inl0) {
           inl_delta-=(36-inl0);
           IDN_DIVMOD_DELTA(inl0);
           *(achp_target++) = (char)(((inl_delta_mod-inl0>-11)?58:133)+inl_delta_mod-inl0);
         } else {
           *(achp_target++) = (char)(((inl_delta>25)?22:'a')+inl_delta);
           goto p_punyseq_ready;
         }
       }
       while(TRUE) {
         /* work with t = 26 (= tmax from RFC3492 chapter 5.)          */
         if (achp_target>=achp_end_target)
           return NULL;
         inl_delta-=26;
         if(inl_delta<0) {
           *(achp_target++) = (char)(123+inl_delta);
           break;                           /* go to p_punyseq_ready   */
         } else {
           IDN_DIVMOD_DELTA(10);
           *(achp_target++) = (char)('0'+inl_delta_mod);
         }
       }
       p_punyseq_ready:
       inl_dd += inl_dd/inp_acn;
       for (inl0=0; inl_dd>455; inl0+=36)
         inl_dd /= 35;
       inl_bias = inl0 + ((36*inl_dd) / (inl_dd+38));  /* adapt, see RFC 3492 6.1 and 5 */
       utl_lii1 = dsp_tree[utl_ti].utc_p + (unsigned char)1;
       inl_lec = (int)(dsp_tree[utl_ti].umc_cp);
       dsp_tree[utl_ti].umc_cp = 0;   /* as U+0000 is not an allowed char,
         we can use it as marker to avoid encoding it (and then looking for the
         right subtree) a second time when we come up from a right subtree   */
       if(dsp_tree[utl_ti].utc_r) {         /* descend to right subtree */
         utl_ti=dsp_tree[utl_ti].utc_r;
         continue;
       }
     }
     if(utl_ti)
       utl_ti=dsp_tree[utl_ti].utc_u;       /* go up                   */
     else
       return achp_target;                  /* traversal complete      */
   }
} /* end m_idna_encode_utree()                                         */
#undef IDN_DIVMOD_DELTA
#ifdef HL_USE_DIV
#undef inl_delta
#undef inl_delta_mod
#endif

/**
* Increases a count by how many characters m_idna_encode_utree() would produce
*  @param dsp_tree The array of entrys about unicode chars of a single "label"
*                  (i.e. typically a part between dots) that could not go into
*                  the output unchanged. Has to contain correct data (e.g. the
*                  internal pointings to form a tree sorted by codepoint number)
*  @param inp_acn count of (ASCII) chars that would be copied (not in dsp_tree).
*  @param inp_l an addend for the return value
*  @return number of characters that the punycode text would contain after (not
*          including) the sequence of copied ASCII-chars (including a heading
*          '-' if the latter was non-empty, but not a tailing zero), plus inp_l
*/
static int m_idna_suffixlen( struct dsd_idna_upoint* dsp_tree, int inp_acn, int inp_l ) {
   int inl0;
   int inl_bias = 72;                       /* parameter, see punycode RFC */
   int inl_fnbc_damp = 700;                 /* nonzero when first non-basic character */
   int inl_lec = 0x080;                     /* last encoded codepoint (unicodenumber) */
   unsigned char utl_ti=0;                  /* treelist traversing index */
   unsigned char utl_lii1 = 0;              /* last insert-index plus 1 */
   int inl_dd;                              /* delta modified for punycode bias adaptation */
   int inl_delta;                           /* punycode delta          */
   if (inp_acn)
     inp_l ++;                              /* separator '-' for preceding */
   while(TRUE) {
     if(dsp_tree[utl_ti].utc_l)
       {                                    /* descend to left subtree */
       unsigned char utl_down=dsp_tree[utl_ti].utc_l;
       dsp_tree[utl_ti].utc_l=0;  /* so we will not descend again here */
       utl_ti=utl_down;
       continue;
       }
     if (dsp_tree[utl_ti].umc_cp) {
       /* measure length to encode a character                         */
       inp_acn ++;                    /* counter of handled characters */
       inl_delta = ((int)(dsp_tree[utl_ti].umc_cp)-inl_lec)*inp_acn + (int)(dsp_tree[utl_ti].utc_p)-utl_lii1;
       if (inl_fnbc_damp) {
         inl_dd=inl_delta/inl_fnbc_damp;
         inl_fnbc_damp=0;
       } else {
         inl_dd=inl_delta>>1;
       }
       inl0 = (inl_bias+1)/36;     /* count for iterations with t=tmin */
       while (inl0--) {
         /* work with t = 1 (= tmin from RFC3492 chapter 5.)           */
         inp_l ++;
         if(inl_delta) {
           --inl_delta;
           inl_delta/=35;
         } else {
           goto p_punyseq_ready;
         }
       }
       inl0 = inl_bias%36;                  /* now inl0 := 36-t        */
       if (inl0>10) {          /* work once with an nonclamped t value */
         inp_l ++;
         if(inl_delta>=36-inl0) {
           inl_delta-=(36-inl0);
           inl_delta/=inl0;
         } else {
           goto p_punyseq_ready;
         }
       }
       while(TRUE) {
         /* work with t = 26 (= tmax from RFC3492 chapter 5.)          */
         inp_l ++;
         inl_delta-=26;
         if(inl_delta<0) {
           break;                           /* go to p_punyseq_ready   */
         } else {
           inl_delta/=10;
         }
       }
       p_punyseq_ready:
       inl_dd += inl_dd/inp_acn;
       for (inl0=0; inl_dd>455; inl0+=36)
         inl_dd /= 35;
       inl_bias = inl0 + ((36*inl_dd) / (inl_dd+38));  /* adapt, see RFC 3492 6.1 and 5 */
       utl_lii1 = dsp_tree[utl_ti].utc_p + (unsigned int)1;
       inl_lec = (int)(dsp_tree[utl_ti].umc_cp);
       dsp_tree[utl_ti].umc_cp = 0;   /* as U+0000 is not an allowed char,
         we can use it as marker to avoid encoding it (and then looking for the
         right subtree) a second time when we come up from a right subtree   */
       if(dsp_tree[utl_ti].utc_r) {         /* descend to right subtree */
         utl_ti=dsp_tree[utl_ti].utc_r;
         continue;
       }
     }
     if(utl_ti)
       utl_ti=dsp_tree[utl_ti].utc_u;       /* go up                   */
     else
       return inp_l;                        /* traversal complete      */
   }
} /* end m_idna_suffixlen()                                            */

/**
* Test the last (regex) rule from Appendix A.1 of RFC 5892 if a ZWNJ was there
*  @param adsp_tl data from a textpiece like built by m_idna_add_to_treelist()
*  @param utp_z index in the list adsp_tl where the zwnj is
*  @param utp_n count of entrys in adsp_tl
*  @return whether the rule is fulfilled
*/
BOOL m_idna_zwnj_jtrule_ok( const struct dsd_idna_upoint *adsp_tl,
                            unsigned char utp_z, unsigned char utp_n ) {
   int inl0;
   int inl1;
   int inl_d;   /* positional distance in the complete original string */
   unsigned int uml_cp0;
   unsigned int uml_cp1;
   for (inl0=(int)utp_z-1; inl0>=0; inl0--) {
     uml_cp0 = adsp_tl[inl0].umc_cp;
     uml_cp1 = adsp_tl[inl0+1].umc_cp;
     inl_d = (int)(adsp_tl[inl0+1].utc_p) - (int)(adsp_tl[inl0].utc_p);
     if (uml_cp0<=uml_cp1) {
       for (inl1=0; inl1<inl0; inl1++)
         if ((uml_cp0 < adsp_tl[inl1].umc_cp) && (adsp_tl[inl1].umc_cp <= uml_cp1))
           inl_d--;
       inl_d--;
     } else {
       for (inl1=0; inl1<inl0; inl1++)
         if ((uml_cp1 < adsp_tl[inl1].umc_cp) && (adsp_tl[inl1].umc_cp <= uml_cp0))
           inl_d++;
     }
     if (inl_d)
       return FALSE;                        /* ASCII in between, has ied_unijointyp_u */
     switch(m_get_unicode_joining_type(adsp_tl[inl0].umc_cp)) {
       case ied_unijointyp_t:
         continue;                          /* keep checking           */
       case ied_unijointyp_l:
       case ied_unijointyp_d:
         /* left part of joiningtype rule fulfilled, check right part  */
         for (inl0=utp_z+1; inl0<utp_n; inl0++) {
           uml_cp0 = adsp_tl[inl0-1].umc_cp;
           uml_cp1 = adsp_tl[inl0].umc_cp;
           inl_d = (int)(adsp_tl[inl0].utc_p) - (int)(adsp_tl[inl0-1].utc_p);
           if (uml_cp0<=uml_cp1) {
             for (inl1=inl0-2; inl1>=0; inl1--)
               if ((uml_cp0 < adsp_tl[inl1].umc_cp) && (adsp_tl[inl1].umc_cp <= uml_cp1))
                  inl_d--;
             inl_d--;
           } else {
             for (inl1=inl0-2; inl1>=0; inl1--)
               if ((uml_cp1 < adsp_tl[inl1].umc_cp) && (adsp_tl[inl1].umc_cp <= uml_cp0))
                 inl_d++;
           }
           if (inl_d)
             return FALSE;                  /* ASCII in between, has ied_unijointyp_u */
           switch(m_get_unicode_joining_type(adsp_tl[inl0].umc_cp)) {
             case ied_unijointyp_t:
               continue;                    /* keep checking           */
             case ied_unijointyp_d:
             case ied_unijointyp_r:
               return TRUE;                 /* both parts of rule fulfilled */
             default:
               return FALSE;                /* right part of rule failed */
           }
         }
         return FALSE;                      /* right part of rule failed */
       default:
         return FALSE;                      /* left part of rule failed */
     }
   }
   return FALSE;                            /* left part of rule failed */
} /* end m_idna_zwnj_jtrule_ok()                                       */

/**
* Adds an entry to an array with information about non-ASCII characters in a
* "label" (piece of string, typically between dots), keeping the data (internal
* pointings etc) consistent, so that it can be used for punycode-encoding later.
*  @param adsp_tl the array that has to be updated
*  @param unl_c the new character, as a unicode codepoint number
*  @param utp_tli old count of characters registered in the array
*  @param inl_ln index where the character occurrs in the label
*/
void m_idna_add_to_treelist( struct dsd_idna_upoint *adsp_tl, unsigned int unl_c,
                             unsigned char utp_tli, int inl_ln ) {
   if (!utp_tli) {                     /* first non-ASCII in this part */
     /* initialise the tree root                                       */
     adsp_tl[0].utc_n = 1;
     adsp_tl[0].utc_l = 0;  /* 0 cannot be a true index for a subtree, because
       the first element contains always the root (the tree is not balanced, in the worst case
       it would degenerate to a list). So we can use 0 as the NULL-value for those (utc_l and
       utc_r); the supertreepointer (utc_u) is to be assumed NULL at node 0 and nowhere else. */
     adsp_tl[0].utc_r = 0;
     adsp_tl[0].utc_u = 0;
     adsp_tl[0].utc_p = (unsigned char)inl_ln;
     adsp_tl[0].umc_cp = unl_c;
   } else {                                 /* extend existing tree    */
     unsigned char utl_ngcl = (unsigned char)inl_ln;
     unsigned char utl_ti = 0;
     while(TRUE) {
       adsp_tl[utl_ti].utc_n++;
       if (unl_c<adsp_tl[utl_ti].umc_cp) {
         if (adsp_tl[utl_ti].utc_r)
           utl_ngcl-=adsp_tl[adsp_tl[utl_ti].utc_r].utc_n;
         utl_ngcl--;                        /* char at the node itself */
         if (adsp_tl[utl_ti].utc_l) {
           utl_ti=adsp_tl[utl_ti].utc_l;
         } else {
           adsp_tl[utl_ti].utc_l=utp_tli;
           break;
         }
       } else {
         if (adsp_tl[utl_ti].utc_r) {
           utl_ti=adsp_tl[utl_ti].utc_r;
         } else {
           adsp_tl[utl_ti].utc_r=utp_tli;
           break;
         }
       }
     }
     adsp_tl[utp_tli].utc_n = 1;
     adsp_tl[utp_tli].utc_l = 0;
     adsp_tl[utp_tli].utc_r = 0;
     adsp_tl[utp_tli].utc_u = utl_ti;
     adsp_tl[utp_tli].utc_p = utl_ngcl;
     adsp_tl[utp_tli].umc_cp = unl_c;
   }
} /* end m_idna_add_to_treelist()                                      */

/* macros for m_cpy_vx_vx_fl, m_cpy_lc_vx_vx_fl, m_cpy_uc_vx_vx_fl  {  */
/* } end macros for m_cpy_vx_vx_fl, m_cpy_lc_vx_vx_fl, m_cpy_uc_vx_vx_fl */

/* When giving ied_chs_idna_1 as target charset to m_cpy_vx_vx, m_cpy_lc_vx_vx,
   m_cpy_uc_vx_vx or m_len_vx_vx, as a special feature it will accept any string
   (e.g. an IPv6 address) that does not contain any character above 'z' like
   simple 819 input, if an IDNA-prohibited character (e.g. ':') is among the
   first MAX_IDNAPART_LENGTH characters.
*/
#define IED_CHS_COPY7A ied_chs_invalid

/**
* copy source string to target
*  @param ap_target destination (output) pointer
*  @param imp_len_target length of output buffer, in 8/16/32-bit units
*  @param iep_cs_target encoding to use for output
*  @param ap_source pointer to original string (input)
*  @param imp_len_source anything negative means the input is zero-terminated,
*                        else length of original string in 8/16/32-bit units
*  @param iep_cs_source encoding used by original string
*  @param ibp_flags special flags (use the wrapper macro m_cpy_vx_vx instead
*                   of this function to ignore this param and use the defaults).
*                   If flag D_CPYVXVX_FL_NOTAIL0 is set, will not zero-terminate
*  @return -1 on error, else length of output (in 8/16/32-bit units depending on
*          iep_cs_target), excluding the terminating zero
*/
extern PTYPE int m_cpy_vx_vx_fl( void *ap_target,
                               int imp_len_target,
                               enum ied_charset iep_cs_target,
                               const void *ap_source,
                               int imp_len_source,
                               enum ied_charset iep_cs_source,
                               unsigned int ibp_flags ) {
   BOOL          bol1;                      /* working-variable        */
   int           iml1;                      /* working-variable        */
   const char    *achl_cur_source;          /* current position parameter */
   char          *achl_cur_target;          /* current position parameter */
   const char    *achl_end_source;          /* end of parameter        */
   char          *achl_end_target;          /* end of parameter        */
   unsigned int  uml_ch_source;             /* character decoded       */
   int           iml_len_ch_source;         /* length of parameter     */
   HL_WCHAR      *awcl_dbcsenc;             /* dbcs encoding table     */
   struct dsd_idna_upoint dslr_idna_treelist[MAX_IDNAPART_LENGTH];  /* non-ascii data */
   unsigned char utl_idna_tn;               /* length for dsd_idna_upoint */
   char          *achl_idna_ps;             /* target start of current label */
   int           iml_idna_labelspace;       /* rest of RFC 1034 maxlen */
   unsigned char utl_idna_openzwnj;         /* U+200C yet to be accepted (RFC 5892 A.1.) */
   /* variables for tests required for IDNA target by RFC 5891 5.4.    */
   int           iel_idna_minuspair;        /* detect labels starting with "..--" */
   BOOL          bol_idna_nohighyet;        /* only <='z' in all labels so far */
   int           inl_idna_prevccc;          /* canonical combining class */
   unsigned int  unl_prevstrt;              /* last char with ccc == 0 */
   /* variables for multi-char XML-reference instead of copying source */
   int           iel_xcro_st;               /* state, -1 or enum ied_xcro_st */
   unsigned int  uml_read_ch_source;        /* original character decoded */
   char          *achl_xenm;                /* next entity-name char   */

#ifdef CHECK_HTML
   int        iml2;                         /* working variable        */
   iml1 = sizeof(dsrs_sort_html_alpha) / sizeof(dsrs_sort_html_alpha[0]) - 1;
   do {
     iml1--;
     iml2 = strcmp( dsrs_sort_html_alpha[ iml1 ].achc_char,
                    dsrs_sort_html_alpha[ iml1 + 1 ].achc_char );
     if (iml2 >= 0) {
       printf( "xslunic1-l%05d-E invalid sort sequence dsrs_sort_html_alpha element %d.\n",
               __LINE__, iml1 );
       return -1;
     }
   } while (iml1 > 0);
#endif
   if (imp_len_target <= 0) return -1;
   /* calculate end of parameter target                                */
   achl_cur_target = (char *) ap_target;
   switch (iep_cs_target) {
     case ied_chs_ascii_850:                /* ASCII 850               */
     case ied_chs_ansi_819:                 /* ANSI 819                */
     case ied_chs_wcp_1256:                 /* Windows-Codepage 1256   */
     case ied_chs_iso8859_2:                /* ISO 8859-2              */
     case ied_chs_iso8859_4:                /* ISO 8859-4              */
     case ied_chs_iso8859_5:                /* ISO 8859-5              */
     case ied_chs_iso8859_9:                /* ISO 8859-9              */
     case ied_chs_iso8859_10:               /* ISO 8859-10             */
     case ied_chs_iso8859_13:               /* ISO 8859-13             */
     case ied_chs_iso8859_14:               /* ISO 8859-14             */
     case ied_chs_iso8859_15:               /* ISO 8859-15             */
     case ied_chs_iso8859_16:               /* ISO 8859-16             */
       if (iep_cs_source == iep_cs_target) goto p_identcpy;
       /* else fall through                                            */
     case ied_chs_oem_437:                  /* DOS-Codepage 437        */
     case ied_chs_wcp_874:                  /* Windows-Codepage  874   */
     case ied_chs_wcp_1250:                 /* Windows-Codepage 1250   */
     case ied_chs_wcp_1251:                 /* Windows-Codepage 1251   */
     case ied_chs_wcp_1252:                 /* Windows-Codepage 1252   */
     case ied_chs_wcp_1253:                 /* Windows-Codepage 1253   */
     case ied_chs_wcp_1254:                 /* Windows-Codepage 1254   */
     case ied_chs_wcp_1255:                 /* Windows-Codepage 1255   */
     case ied_chs_wcp_1257:                 /* Windows-Codepage 1257   */
     case ied_chs_wcp_1258:                 /* Windows-Codepage 1258   */
     case ied_chs_iso8859_3:                /* ISO 8859-3              */
     case ied_chs_iso8859_6:                /* ISO 8859-6              */
     case ied_chs_iso8859_7:                /* ISO 8859-7              */
     case ied_chs_iso8859_8:                /* ISO 8859-8              */
     case ied_chs_iso8859_11:               /* ISO 8859-11             */
     case ied_chs_utf_8:                    /* Unicode UTF-8           */
     case ied_chs_html_1:                   /* HTML character set      */
     case ied_chs_uri_1:                    /* URI, percent-encoded    */
     case ied_chs_hsf_1:                    /* HOB special file system */
       achl_end_target = ((char *) ap_target) + imp_len_target;
       break;
     case ied_chs_ldap_escaped_utf_8:       /* LDAP UTF-8 escaped      */
       bol1 = TRUE;                         /* yet awaiting first '='  */
       achl_end_target = ((char *) ap_target) + imp_len_target;
       break;
     case ied_chs_xml_utf_8:                /* UTF-8 with XML-CharRef  */
     case ied_chs_xml_wcp_1252:             /* Windows-1252 with XML-CharRef */
       iel_xcro_st = -1;
       achl_end_target = ((char *) ap_target) + imp_len_target;
       break;
     case ied_chs_idna_1:                   /* IDNA RFC 3490 - Punycode */
       if (iep_cs_source == ied_chs_idna_1) goto p_identcpy;  /* #34092, we cant decode idna yet */
       achl_idna_ps = achl_cur_target;
       iml_idna_labelspace = 1+MAX_IDNAPART_LENGTH;
       utl_idna_openzwnj = 0;        /* =none, at 0 would not be legal */
       iel_idna_minuspair = 0;
       bol_idna_nohighyet = TRUE;
       inl_idna_prevccc = 255;
       unl_prevstrt = 0;
       utl_idna_tn = 0;
       achl_end_target = ((char *) ap_target) + imp_len_target;
       break;
     CASE_IED_CHS_ALL_CJK
       awcl_dbcsenc = m_get_tab_uni_to_mb(iep_cs_target);
       achl_end_target = ((char *) ap_target) + imp_len_target;
       break;
     case ied_chs_xml_utf_16:               /* UTF-16 with XML-CharRef */
       iel_xcro_st = -1;                    /* and fall through        */
     CASE_IED_CHS_U16_ALLENDIAN
       achl_end_target = ((char *) ap_target) + imp_len_target * sizeof(HL_WCHAR);
       break;
     CASE_IED_CHS_U32_ALLENDIAN
       achl_end_target = ((char *) ap_target) + imp_len_target * sizeof(unsigned int);
       break;
     default:
       return -1;                           /* cannot copy             */
   }
   /* calculate end of parameter source                                */
   achl_cur_source = (const char *) ap_source;
   achl_end_source = NULL;                  /* still zero-terminated   */
   if (imp_len_source >= 0) {               /* length source given     */
     switch (iep_cs_source) {
       case ied_chs_ascii_850:              /* ASCII 850               */
       case ied_chs_ansi_819:               /* ANSI 819                */
       CASE_IED_CHS_MISCCODEPAGES
       CASE_IED_CHS_ALL_CJK
       CASE_IED_CHS_ISO8859_2TO16
       CASE_IED_CHS_ESCHEXHEX_U8
       case ied_chs_utf_8:                  /* Unicode UTF-8           */
       case ied_chs_xml_utf_8:              /* UTF-8 with XML-CharRef  */
       case ied_chs_xml_wcp_1252:           /* Windows-1252 with XML-CharRef */
       case ied_chs_html_1:                 /* HTML character set      */
         achl_end_source = ((const char *) ap_source) + imp_len_source;
         break;
       CASE_IED_CHS_U16_ALLENDIAN
       case ied_chs_xml_utf_16:             /* UTF-16 with XML-CharRef */
         achl_end_source = ((const char *) ap_source) + imp_len_source * sizeof(HL_WCHAR);
         break;
       CASE_IED_CHS_U32_ALLENDIAN
         achl_end_source = ((const char *) ap_source) + imp_len_source * sizeof(unsigned int);
         break;
       /* ied_chs_idna_1 is done at p_identcpy if ==iep_cs_target      */
       default:
         return -1;                         /* cannot copy             */
     }
   }

   pcpy_00:                                 /* copy characters         */
   iml_len_ch_source = m_get_vc_ch( &uml_ch_source, achl_cur_source, achl_end_source, iep_cs_source );
   if (iml_len_ch_source <= 0) {            /* subroutine reported end or error */
     if (iml_len_ch_source == 0) {          /* end of input found      */
       switch (iep_cs_target) {
         case ied_chs_idna_1:               /* IDNA RFC 3490 - Punycode */
           if (utl_idna_tn) {               /* last part had non-ASCII */
             if (utl_idna_openzwnj &&
                 !m_idna_zwnj_jtrule_ok( dslr_idna_treelist, utl_idna_openzwnj, utl_idna_tn ))
               return -1;                   /* earlier U+200C not conforming */
             /* encode the non-ascii chars of the last part            */
             achl_cur_target = m_idna_encode_utree( dslr_idna_treelist,
                               achl_cur_target-(achl_idna_ps+4),
                               achl_cur_target,
                               achl_end_target<=achl_idna_ps+MAX_IDNAPART_LENGTH
                                              ? achl_end_target
                                              : achl_idna_ps+MAX_IDNAPART_LENGTH
                               );
             if ((achl_cur_target == NULL) || (achl_cur_target >= achl_end_target))
               return -1;                   /* target overflow         */
           }                                /* fall through            */
         case IED_CHS_COPY7A:               /* idna-prohibited ascii   */
         case ied_chs_ascii_850:            /* ASCII 850               */
         case ied_chs_ansi_819:             /* ANSI 819                */
         CASE_IED_CHS_MISCCODEPAGES
         CASE_IED_CHS_ALL_CJK
         CASE_IED_CHS_ISO8859_2TO16
         CASE_IED_CHS_ESCHEXHEX_U8
         case ied_chs_utf_8:                /* Unicode UTF-8           */
         case ied_chs_xml_utf_8:            /* UTF-8 with XML-CharRef  */
         case ied_chs_xml_wcp_1252:         /* Windows-1252 with XML-CharRef */
         case ied_chs_html_1:               /* HTML character set      */
           if ((ibp_flags & D_CPYVXVX_FL_NOTAIL0) == 0) {
             if (achl_cur_target >= achl_end_target) return -1;  /* output area too short */
             *achl_cur_target = 0;          /* make zero-terminated    */
           }
           return achl_cur_target - (char *) ap_target;
         case ied_chs_utf_16:               /* Unicode UTF-16 = WCHAR  */
         case ied_chs_xml_utf_16:           /* UTF-16 with XML-CharRef */
           if ((ibp_flags & D_CPYVXVX_FL_NOTAIL0) == 0) {
             if (achl_cur_target+sizeof(HL_WCHAR) > achl_end_target) return -1;  /* too short */
             *((HL_WCHAR *) achl_cur_target) = 0;  /* make zero-terminated */
           }
           return (achl_cur_target - (char *) ap_target) / sizeof(HL_WCHAR);
         case ied_chs_be_utf_16:            /* Unicode UTF-16 big endian */
         case ied_chs_le_utf_16:            /* Unicode UTF-16 little endian */
           if ((ibp_flags & D_CPYVXVX_FL_NOTAIL0) == 0) {
             if (achl_cur_target+2 > achl_end_target) return -1;  /* output area too short */
             *((char  *) achl_cur_target + 0) = 0;  /* make zero-terminated */
             *((char  *) achl_cur_target + 1) = 0;  /* make zero-terminated */
           }
           return (achl_cur_target - (char *) ap_target) / sizeof(HL_WCHAR);
         case ied_chs_utf_32:               /* Unicode UTF-32          */
           if ((ibp_flags & D_CPYVXVX_FL_NOTAIL0) == 0) {
             if (achl_cur_target+sizeof(unsigned int) > achl_end_target) return -1;  /* too short */
             *((unsigned int *) achl_cur_target) = 0;  /* make zero-terminated */
           }
           return (achl_cur_target - (char *) ap_target) / sizeof(unsigned int);
         case ied_chs_be_utf_32:            /* Unicode UTF-32 big endian */
         case ied_chs_le_utf_32:            /* Unicode UTF-32 little endian */
           if ((ibp_flags & D_CPYVXVX_FL_NOTAIL0) == 0) {
             if (achl_cur_target+4 > achl_end_target) return -1;  /* output area too short */
             *((char  *) achl_cur_target + 0) = 0;  /* make zero-terminated */
             *((char  *) achl_cur_target + 1) = 0;  /* make zero-terminated */
             *((char  *) achl_cur_target + 2) = 0;  /* make zero-terminated */
             *((char  *) achl_cur_target + 3) = 0;  /* make zero-terminated */
           }
           return (achl_cur_target - (char *) ap_target) / sizeof(unsigned int);
         default:
           return -1;                       /* error                   */
       }
     }
     return -1;                             /* return error            */
   }
   pcpy_20:                                 /* output characters       */
   if (achl_cur_target >= achl_end_target) return -1;  /* output area too short */
   switch (iep_cs_target) {
     case ied_chs_ascii_850:                /* ASCII 850               */
       if (uml_ch_source < 0X0100) {
         *((unsigned char *) achl_cur_target) = (unsigned char) ucrg_tab_819_to_850[ uml_ch_source ];
       } else {
         *achl_cur_target = '?';
       }
       achl_cur_target++;                   /* output one character    */
       break;
     case ied_chs_ansi_819:                 /* ANSI 819                */
       if (uml_ch_source < 0X0100) {
         *((unsigned char *) achl_cur_target) = (unsigned char) uml_ch_source;
       } else {
         *achl_cur_target = '?';
       }
       achl_cur_target++;                   /* output one character    */
       break;
     case ied_chs_oem_437:                  /* DOS-Codepage 437        */
       *((unsigned char *) achl_cur_target) = (unsigned char) m_u32c_to_437( uml_ch_source );
       achl_cur_target++;                   /* output one character    */
       break;
     case ied_chs_wcp_874:                  /* Windows-Codepage  874   */
       *((unsigned char *) achl_cur_target) = (unsigned char) m_u32c_to_874( uml_ch_source );
       achl_cur_target++;                   /* output one character    */
       break;
     case ied_chs_wcp_1250:                 /* Windows-Codepage 1250   */
       *((unsigned char *) achl_cur_target) = (unsigned char) m_u32c_to_1250( uml_ch_source );
       achl_cur_target++;                   /* output one character    */
       break;
     case ied_chs_wcp_1251:                 /* Windows-Codepage 1251   */
       *((unsigned char *) achl_cur_target) = (unsigned char) m_u32c_to_1251( uml_ch_source );
       achl_cur_target++;                   /* output one character    */
       break;
     case ied_chs_xml_wcp_1252:             /* Windows-1252 with XML-CharRef */
       if (iel_xcro_st < 0) {               /* no entity-encode runs   */
         /* shortest encoding is preferred, hex (no div ops) if equal  */
         /* over 0x7F either ASCII_REP_CHAR or no need to XML-encode   */
         if (uml_ch_source < 0x80)
           iel_xcro_st = chrs_xmlent_st[uml_ch_source];
       }
       if (iel_xcro_st >= 0) {              /* entity-encode runs now  */
         switch ((enum ied_xcro_st)iel_xcro_st) {
           case ied_xcro_hex_start:
           case ied_xcro_dec_start:
             uml_read_ch_source = uml_ch_source;
             uml_ch_source = 0x26;          /* '&', next: '#'          */
             iel_xcro_st ++;
             break;
           case ied_xcro_dec_carpet:
             uml_ch_source = 0x23;          /* '#', next: the number   */
             iel_xcro_st = (int)ied_xcro_dec_10;
             break;
           case ied_xcro_hex_carpet:
             uml_ch_source = 0x23;          /* '#', next: 'x'          */
             iel_xcro_st ++;
             break;
           case ied_xcro_hex_x:
             uml_ch_source = 0x78;          /* 'x', next: the number   */                 
             iel_xcro_st = (int)ied_xcro_hex_F00000;
             while (uml_read_ch_source >> iel_xcro_st == 0)
               iel_xcro_st -= 4;    /* will hang if called with U+0000 */
             break;
           case ied_xcro_txt_start_lt:
             achl_xenm = chrs_html_lt;      /* use entity name "lt"    */
             uml_ch_source = 0x26;          /* '&', next: name chars   */
             iel_xcro_st = (int)ied_xcro_txt;
             break;
           case ied_xcro_txt_start_gt:
             achl_xenm = chrs_html_gt;      /* use entity name "gt"    */
             uml_ch_source = 0x26;          /* '&', next: name chars   */
             iel_xcro_st = (int)ied_xcro_txt;
             break;
           case ied_xcro_txt:               /* char from achl_xenm     */
             uml_ch_source = *achl_xenm++;
             if (*achl_xenm == 0)
               iel_xcro_st = (int)ied_xcro_endchar;
             break;
           case ied_xcro_endchar:
             uml_ch_source = 0x3B;          /* ';'                     */
             iel_xcro_st = ied_xcro_after_end;
             break;
           case ied_xcro_after_end:
             iel_xcro_st = -1;              /* copy from source again  */
             achl_cur_source += iml_len_ch_source;
             goto pcpy_00;                  /* leave this codepart     */
           case ied_xcro_dec_10:
             uml_ch_source = uml_read_ch_source / 10;          
             if (uml_ch_source != 0) {
               uml_read_ch_source -= 10 * uml_ch_source;          
               uml_ch_source += 0x30;       /* '0'-based decimal char  */
               iel_xcro_st --;              /* next: ied_xcro_dec_01   */
               break;
             }                              /* else fall through       */
           case ied_xcro_dec_01:
             uml_ch_source = uml_read_ch_source + 0x30;
             iel_xcro_st = (int)ied_xcro_endchar;
             break;
           case ied_xcro_hex_00000F:
             uml_ch_source = uml_read_ch_source & 0xF;
             uml_ch_source += (uml_ch_source<10 ? 0x30 : 0x37);
             iel_xcro_st = (int)ied_xcro_endchar;
             break;
           default:    /* ied_xcro_hex_0000F0, ... ied_xcro_hex_F00000 */
             uml_ch_source = (uml_read_ch_source >> iel_xcro_st) & 0xF;
             uml_ch_source += (uml_ch_source<10 ? 0x30 : 0x37);
             iel_xcro_st -= 4;
             break;
         }
         *achl_cur_target++ = (unsigned char) uml_ch_source;
         goto pcpy_20;
       }                                    /* else case-fall-through  */
     case ied_chs_wcp_1252:                 /* Windows-Codepage 1252   */
       *((unsigned char *) achl_cur_target) = (unsigned char) m_u32c_to_1252( uml_ch_source );
       achl_cur_target++;                   /* output one character    */
       break;
     case ied_chs_wcp_1253:                 /* Windows-Codepage 1253   */
       *((unsigned char *) achl_cur_target) = (unsigned char) m_u32c_to_1253( uml_ch_source );
       achl_cur_target++;                   /* output one character    */
       break;
     case ied_chs_wcp_1254:                 /* Windows-Codepage 1254   */
       *((unsigned char *) achl_cur_target) = (unsigned char) m_u32c_to_1254( uml_ch_source );
       achl_cur_target++;                   /* output one character    */
       break;
     case ied_chs_wcp_1255:                 /* Windows-Codepage 1255   */
       *((unsigned char *) achl_cur_target) = (unsigned char) m_u32c_to_1255( uml_ch_source );
       achl_cur_target++;                   /* output one character    */
       break;
     case ied_chs_wcp_1256:                 /* Windows-Codepage 1256   */
       *((unsigned char *) achl_cur_target) = (unsigned char) m_u32c_to_1256( uml_ch_source );
       achl_cur_target++;                   /* output one character    */
       break;
     case ied_chs_wcp_1257:                 /* Windows-Codepage 1257   */
       *((unsigned char *) achl_cur_target) = (unsigned char) m_u32c_to_1257( uml_ch_source );
       achl_cur_target++;                   /* output one character    */
       break;
     case ied_chs_wcp_1258:                 /* Windows-Codepage 1258   */
       *((unsigned char *) achl_cur_target) = (unsigned char) m_u32c_to_1258( uml_ch_source );
       achl_cur_target++;                   /* output one character    */
       break;
     case ied_chs_iso8859_2:                /* ISO 8859-2 (Latin-2)    */
       *((unsigned char *) achl_cur_target) = (unsigned char) m_u32c_to_i02( uml_ch_source );
       achl_cur_target++;                   /* output one character    */
       break;
     case ied_chs_iso8859_3:                /* ISO 8859-3 (Latin-3)    */
       *((unsigned char *) achl_cur_target) = (unsigned char) m_u32c_to_i03( uml_ch_source );
       achl_cur_target++;                   /* output one character    */
       break;
     case ied_chs_iso8859_4:                /* ISO 8859-4 (Latin-4)    */
       *((unsigned char *) achl_cur_target) = (unsigned char) m_u32c_to_i04( uml_ch_source );
       achl_cur_target++;                   /* output one character    */
       break;
     case ied_chs_iso8859_5:                /* ISO 8859-5              */
       *((unsigned char *) achl_cur_target) = (unsigned char) m_u32c_to_i05( uml_ch_source );
       achl_cur_target++;                   /* output one character    */
       break;
     case ied_chs_iso8859_6:                /* ISO 8859-6              */
       *((unsigned char *) achl_cur_target) = (unsigned char) m_u32c_to_i06( uml_ch_source );
       achl_cur_target++;                   /* output one character    */
       break;
     case ied_chs_iso8859_7:                /* ISO 8859-7              */
       *((unsigned char *) achl_cur_target) = (unsigned char) m_u32c_to_i07( uml_ch_source );
       achl_cur_target++;                   /* output one character    */
       break;
     case ied_chs_iso8859_8:                /* ISO 8859-8              */
       *((unsigned char *) achl_cur_target) = (unsigned char) m_u32c_to_i08( uml_ch_source );
       achl_cur_target++;                   /* output one character    */
       break;
     case ied_chs_iso8859_9:                /* ISO 8859-9 (Latin-5)    */
       *((unsigned char *) achl_cur_target) = (unsigned char) m_u32c_to_i09( uml_ch_source );
       achl_cur_target++;                   /* output one character    */
       break;
     case ied_chs_iso8859_10:               /* ISO 8859-10 (Latin-6)   */
       *((unsigned char *) achl_cur_target) = (unsigned char) m_u32c_to_i10( uml_ch_source );
       achl_cur_target++;                   /* output one character    */
       break;
     case ied_chs_iso8859_11:               /* ISO 8859-11             */
       *((unsigned char *) achl_cur_target) = (unsigned char) m_u32c_to_i11( uml_ch_source );
       achl_cur_target++;                   /* output one character    */
       break;
     case ied_chs_iso8859_13:               /* ISO 8859-13 (Latin-7)   */
       *((unsigned char *) achl_cur_target) = (unsigned char) m_u32c_to_i13( uml_ch_source );
       achl_cur_target++;                   /* output one character    */
       break;
     case ied_chs_iso8859_14:               /* ISO 8859-14 (Latin-8)   */
       *((unsigned char *) achl_cur_target) = (unsigned char) m_u32c_to_i14( uml_ch_source );
       achl_cur_target++;                   /* output one character    */
       break;
     case ied_chs_iso8859_15:               /* ISO 8859-15 (Latin-9)   */
       *((unsigned char *) achl_cur_target) = (unsigned char) m_u32c_to_i15( uml_ch_source );
       achl_cur_target++;                   /* output one character    */
       break;
     case ied_chs_iso8859_16:               /* ISO 8859-16 (Latin-10)  */
       *((unsigned char *) achl_cur_target) = (unsigned char) m_u32c_to_i16( uml_ch_source );
       achl_cur_target++;                   /* output one character    */
       break;
     CASE_IED_CHS_ALL_CJK
       if (uml_ch_source >= 0x10000) {
         *achl_cur_target++ = ASCII_REP_CHAR;
       } else {
         iml1 = awcl_dbcsenc[uml_ch_source];
         if (iml1 & 0xFF00)
           *achl_cur_target++ = (char)(iml1>>8);  /* dbcs lead byte    */
         *achl_cur_target++ = (char)iml1;   /* bits for second byte    */
       }
       /* UUU instead of ASCII_REP_CHAR use "Katakana middle dot for 932", says
   ftp://unicode.org/Public/MAPPINGS/VENDORS/MICSFT/WindowsBestFit/readme.txt 
   KATAKANA MIDDLE DOT is U+30FB, coded by 0x81 0x45 (so 2-byte in len_vx_vx) */
       break;
     case ied_chs_ldap_escaped_utf_8:       /* LDAP UTF-8 escaped      */
       switch (uml_ch_source >> 5) {
         case 0:
           if (uml_ch_source == 0x00) {     /* mask hexadecimally      */
             iml1 = m_put_uri_1_a( achl_cur_target, achl_end_target, uml_ch_source, '\\' );
             if (iml1 < 0) return -1;       /* output area too short   */
             achl_cur_target += iml1;       /* increment pointer output */
             break;                         /* all done                */
           }
           *achl_cur_target++ = (unsigned char) uml_ch_source;
           break;
         case 1:
           if (((unsigned int)1<<(uml_ch_source-0x20)) & 0x7800180D) {
             if (bol1 && (char)uml_ch_source=='=') {  /* the first '=' */
               bol1 = FALSE;
             } else {
               *achl_cur_target++ = '\\';   /* mask by prepending '\\' */
               if (achl_cur_target >= achl_end_target)
                 return -1;                 /* output area too short   */
             }
           }
           *achl_cur_target++ = (unsigned char) uml_ch_source;
           break;
         case 2:
           if (uml_ch_source == 0x5C) {
             *achl_cur_target++ = '\\';     /* mask by prepending '\\' */
             if (achl_cur_target >= achl_end_target)
               return -1;                   /* output area too short   */
           }
           /* fall through */
         case 3:
           *achl_cur_target++ = (unsigned char) uml_ch_source;
           break;
         default:
         /* to escape all non-ASCII-bytes, instead of the goto do here what is
            done to char 0x00 in case 0. However, the RFC does not demand it. */
           goto p_enc_utf8_over7bit;
       }
       break;
     case ied_chs_xml_utf_8:                /* UTF-8 with XML-CharRef  */
       if (iel_xcro_st < 0) {               /* no entity-encode runs   */
         /* shortest encoding is preferred, hex (no div ops) if equal  */
         if (uml_ch_source < 0xE000)
           if (uml_ch_source < 0xA0)
             iel_xcro_st = chrs_xmlent_st[uml_ch_source];
           else                             /* 00A0                    */
             { if (uml_ch_source >= 0xD800) iel_xcro_st = 1; }
         else                               /* E000                    */
           if (uml_ch_source < 0xFDF0)
             { if (uml_ch_source >= 0xFDD0) iel_xcro_st = 1; }
           else                             /* FDF0                    */
             { if ((uml_ch_source&0xFFFE)==0xFFFE) iel_xcro_st = 1; }
       }
       if (iel_xcro_st >= 0) {              /* entity-encode runs now  */
         switch ((enum ied_xcro_st)iel_xcro_st) {
           case ied_xcro_hex_start:
           case ied_xcro_dec_start:
             uml_read_ch_source = uml_ch_source;
             uml_ch_source = 0x26;          /* '&', next: '#'          */
             iel_xcro_st ++;
             break;
           case ied_xcro_dec_carpet:
             uml_ch_source = 0x23;          /* '#', next: the number   */
             iel_xcro_st = (int)ied_xcro_dec_10;
             break;
           case ied_xcro_hex_carpet:
             uml_ch_source = 0x23;          /* '#', next: 'x'          */
             iel_xcro_st ++;
             break;
           case ied_xcro_hex_x:
             uml_ch_source = 0x78;          /* 'x', next: the number   */                 
             iel_xcro_st = (int)ied_xcro_hex_F00000;
             while (uml_read_ch_source >> iel_xcro_st == 0)
               iel_xcro_st -= 4;    /* will hang if called with U+0000 */
             break;
           case ied_xcro_txt_start_lt:
             achl_xenm = chrs_html_lt;      /* use entity name "lt"    */
             uml_ch_source = 0x26;          /* '&', next: name chars   */
             iel_xcro_st = (int)ied_xcro_txt;
             break;
           case ied_xcro_txt_start_gt:
             achl_xenm = chrs_html_gt;      /* use entity name "gt"    */
             uml_ch_source = 0x26;          /* '&', next: name chars   */
             iel_xcro_st = (int)ied_xcro_txt;
             break;
           case ied_xcro_txt:               /* char from achl_xenm     */
             uml_ch_source = *achl_xenm++;
             if (*achl_xenm == 0)
               iel_xcro_st = (int)ied_xcro_endchar;
             break;
           case ied_xcro_endchar:
             uml_ch_source = 0x3B;          /* ';'                     */
             iel_xcro_st = ied_xcro_after_end;
             break;
           case ied_xcro_after_end:
             iel_xcro_st = -1;              /* copy from source again  */
             achl_cur_source += iml_len_ch_source;
             goto pcpy_00;                  /* leave this codepart     */
           case ied_xcro_dec_10:
             uml_ch_source = uml_read_ch_source / 10;          
             if (uml_ch_source != 0) {
               uml_read_ch_source -= 10 * uml_ch_source;          
               uml_ch_source += 0x30;       /* '0'-based decimal char  */
               iel_xcro_st --;              /* next: ied_xcro_dec_01   */
               break;
             }                              /* else fall through       */
           case ied_xcro_dec_01:
             uml_ch_source = uml_read_ch_source + 0x30;
             iel_xcro_st = (int)ied_xcro_endchar;
             break;
           case ied_xcro_hex_00000F:
             uml_ch_source = uml_read_ch_source & 0xF;
             uml_ch_source += (uml_ch_source<10 ? 0x30 : 0x37);
             iel_xcro_st = (int)ied_xcro_endchar;
             break;
           default:    /* ied_xcro_hex_0000F0, ... ied_xcro_hex_F00000 */
             uml_ch_source = (uml_read_ch_source >> iel_xcro_st) & 0xF;
             uml_ch_source += (uml_ch_source<10 ? 0x30 : 0x37);
             iel_xcro_st -= 4;
             break;
         }
         *achl_cur_target++ = (unsigned char) uml_ch_source;
         goto pcpy_20;
       }                                    /* else case-fall-through  */
     case ied_chs_utf_8:                    /* Unicode UTF-8           */
       if ((uml_ch_source != 0) && ((uml_ch_source >> 7) == 0)) {  /* not zero or 0X80 (Why not zero? This way it encodes U+0000 with a superfluous extra byte WS 8.12.2011) */
         *achl_cur_target++ = (unsigned char) uml_ch_source;
         break;
       }
       p_enc_utf8_over7bit:
       if ((uml_ch_source >> 11) == 0) {
         *achl_cur_target++ = 0XC0 | (uml_ch_source >> 6);
         /* check at maximum output                                      */
         if (achl_cur_target >= achl_end_target) return -1;  /* output area too short */
         *achl_cur_target++ = 0X80 | (uml_ch_source & 0X3F);
         break;
       }
       if ((uml_ch_source >> 16) == 0) {
         *achl_cur_target++ = 0XE0 | (uml_ch_source >> 12);
         if (achl_cur_target >= achl_end_target) return -1;  /* output area too short */
         *achl_cur_target++ = (0X80 | ((uml_ch_source >> 6) & 0X3F));
         if (achl_cur_target >= achl_end_target) return -1;  /* output area too short */
         *achl_cur_target++ = (0X80 | (uml_ch_source & 0X3F));
         break;
       }
       if ((uml_ch_source >> 21) == 0) {
         *achl_cur_target++ = 0XF0 | (uml_ch_source >> 18);
         if (achl_cur_target >= achl_end_target) return -1;  /* output area too short */
         *achl_cur_target++ = (0X80 | ((uml_ch_source >> 12) & 0X3F));
         if (achl_cur_target >= achl_end_target) return -1;  /* output area too short */
         *achl_cur_target++ = (0X80 | ((uml_ch_source >> 6) & 0X3F));
         if (achl_cur_target >= achl_end_target) return -1;  /* output area too short */
         *achl_cur_target++ = (0X80 | (uml_ch_source & 0X3F));
         break;
       }
       if ((uml_ch_source >> 26) == 0) {
         *achl_cur_target++ = 0XF8 | (uml_ch_source >> 24);
         if (achl_cur_target >= achl_end_target) return -1;  /* output area too short */
         *achl_cur_target++ = (0X80 | ((uml_ch_source >> 18) & 0X3F));
         if (achl_cur_target >= achl_end_target) return -1;  /* output area too short */
         *achl_cur_target++ = (0X80 | ((uml_ch_source >> 12) & 0X3F));
         if (achl_cur_target >= achl_end_target) return -1;  /* output area too short */
         *achl_cur_target++ = (0X80 | ((uml_ch_source >> 6) & 0X3F));
         if (achl_cur_target >= achl_end_target) return -1;  /* output area too short */
         *achl_cur_target++ = (0X80 | (uml_ch_source & 0X3F));
         break;
       }
       if ((uml_ch_source >> 31) == 0) {
         *achl_cur_target++ = 0XFC | (uml_ch_source >> 30);
         if (achl_cur_target >= achl_end_target) return -1;  /* output area too short */
         *achl_cur_target++ = (0X80 | ((uml_ch_source >> 24) & 0X3F));
         if (achl_cur_target >= achl_end_target) return -1;  /* output area too short */
         *achl_cur_target++ = (0X80 | ((uml_ch_source >> 18) & 0X3F));
         if (achl_cur_target >= achl_end_target) return -1;  /* output area too short */
         *achl_cur_target++ = (0X80 | ((uml_ch_source >> 12) & 0X3F));
         if (achl_cur_target >= achl_end_target) return -1;  /* output area too short */
         *achl_cur_target++ = (0X80 | ((uml_ch_source >> 6) & 0X3F));
         if (achl_cur_target >= achl_end_target) return -1;  /* output area too short */
         *achl_cur_target++ = (0X80 | (uml_ch_source & 0X3F));
         break;
       }
       return -1;                           /* character undefined     */
     case ied_chs_html_1:                   /* HTML character set      */
       bol1 = FALSE;                        /* character not copied    */
       if (uml_ch_source < 0X80) {          /* may be a single character */
         switch (uml_ch_source) {           /* check special values    */
           case 0X22:                       /* chrs_html_quote         */
             break;                         /* set in string           */
           case 0X26:                       /* chrs_html_amp           */
             break;                         /* set in string           */
           case 0X3C:                       /* chrs_html_lt            */
             break;                         /* set in string           */
           case 0X3E:                       /* chrs_html_gt            */
             break;                         /* set in string           */
           default:
             *achl_cur_target++ = (unsigned char) uml_ch_source;
             bol1 = TRUE;                   /* character has been copied */
             break;
         }
       }
       if (bol1) break;                     /* all done                */
       iml1 = m_put_html_1_a( achl_cur_target, achl_end_target, uml_ch_source );
       if (iml1 < 0) return -1;             /* output area too small   */
       achl_cur_target += iml1;             /* increment pointer output */
       break;                               /* all done                */
     case ied_chs_uri_1:                    /* URI RFC 3986            */
       if (   ((uml_ch_source >> 7) == 0)   /* only 7 bits - < 0X80    */
           && (chrs_uri_1_tab[ uml_ch_source ] == 0)) {  /* not reserved */
         *achl_cur_target++ = (unsigned char) uml_ch_source;
         break;
       }
       iml1 = m_put_uri_1_a( achl_cur_target, achl_end_target, uml_ch_source, '%' );
       if (iml1 < 0) return -1;             /* output area too small   */
       achl_cur_target += iml1;             /* increment pointer output */
       break;                               /* all done                */
     case ied_chs_hsf_1:                    /* HOB special file system */
       if (   ((uml_ch_source >> 7) == 0)   /* only 7 bits - < 0X80    */
           && (chrs_non09az_tab[ uml_ch_source ] == 0)) {  /* not reserved */
         *achl_cur_target++ = (unsigned char) uml_ch_source;
         break;
       }
       iml1 = m_put_uri_1_a( achl_cur_target, achl_end_target, uml_ch_source, '_' );
       if (iml1 < 0) return -1;             /* output area too small   */
       achl_cur_target += iml1;             /* increment pointer output */
       break;                               /* all done                */
     case ied_chs_idna_1:                   /* IDNA RFC 3490 - Punycode */
       if (uml_ch_source < 0x7B) {          /* maybe unchanged char    */
         if (--iml_idna_labelspace == 0) {  /* over RFC 1034 maxlength */
           if (uml_ch_source != 0x2E)       /* last-chance part-end?   */
             return -1;
         }                   /* (limiting also precludes int overflow) */
         inl_idna_prevccc = 0;              /* all these have ccc of 0 */
         unl_prevstrt = uml_ch_source;      /* no test, as NFC_QC is Y */
         if (uml_ch_source > 0x60) {        /* lcase ASCII, unchanged  */
           *achl_cur_target++ = (unsigned char) uml_ch_source;
           break;
         }
         if (uml_ch_source >= 0x30) {       /* maybe ASCII digit       */
           if (uml_ch_source < 0x3A) {      /* ASCII digit, unchanged  */
             *achl_cur_target++ = (unsigned char) uml_ch_source;
             break;
           }
           if (bol_idna_nohighyet) {        /* permit IPv6 addresses etc. */
             *achl_cur_target++ = (unsigned char) uml_ch_source;
             iep_cs_target = IED_CHS_COPY7A;
             break;
           }
           return -1;                       /* prohibited ASCII char   */
         } else {
           if (uml_ch_source == 0x2D) {     /* hyphen-minus, unchanged */
             switch (MAX_IDNAPART_LENGTH-iml_idna_labelspace) {
               case 2:
                 iel_idna_minuspair = 1;
                 break;
               case 3:
                 if (iel_idna_minuspair) {
                   if (utl_idna_tn)
                     return -1;             /* already non-ASCII at [0] or [1] */
                   iel_idna_minuspair = 2;
                 }
                 break;
               default:                     /* ignore at /^..--/-detection */
                 break;
             }
             *achl_cur_target++ = (unsigned char) uml_ch_source;
             break;
           }
           if (uml_ch_source == 0x2E) {     /* dot, begin new part     */
             goto p_next_idnlbl;
           }
           if (bol_idna_nohighyet) {        /* permit IPv6 addresses etc. */
             *achl_cur_target++ = (unsigned char) uml_ch_source;
             iep_cs_target = IED_CHS_COPY7A;
             break;
           }
           return -1;                       /* prohibited ASCII char   */
         }
       } else {                             /* not an unchanged char   */
         if (iel_idna_minuspair) {
           if (iel_idna_minuspair == 1)
             iel_idna_minuspair = 0;        /* '-' only at [2], not at [3] */
            else
             return -1;                     /* label must be ASCII, "--"-rule */
         }
         switch (uml_ch_source) {           /* check for part end end CONTEXTJ cases */
           case 0x200C:                     /* ZERO WIDTH NON-JOINER   */
             if (utl_idna_tn==0)
               return -1;                   /* cannot fulfil either rule */
             if (utl_idna_openzwnj) {       /* still earlier one unclear, check that first */
               if (!m_idna_zwnj_jtrule_ok( dslr_idna_treelist, utl_idna_openzwnj, utl_idna_tn ))
                 return -1;                 /* earlier zwnj not conforming */
             }
             if (inl_idna_prevccc == 9) {   /* previous char is virama */
               utl_idna_openzwnj = 0;
               /* virama rule fulfilled, joiningtype not checked       */
             } else {                       /* must fulfil joiningtype rule */
               /* the rule would be complicated to test now, so it is tested on label end or
                  next zwnj, as this is probably too rare to check utl_idna_openzwnj often */
               utl_idna_openzwnj = utl_idna_tn;
             }
             inl_idna_prevccc = 0;          /* U+200C has ccc of 0     */
             break;
           case 0x200D:                     /* ZERO WIDTH JOINER       */
             if (inl_idna_prevccc != 9)     /* previous char no virama */
               return -1;                   /* failed CONTEXTJ rule    */
             inl_idna_prevccc = 0;          /* U+200D has ccc of 0     */
             break;                         /* virama rule fulfilled   */
           case 0x3002:   /* dots, see RFC 3490, section 3.1, number 1 */
           case 0xFF0E:
           case 0xFF61:                     /* begin new part          */
             goto p_next_idnlbl;
           default:
             if (!m_is_idna_allowed(uml_ch_source))
               return -1;                   /* prohibited non-ASCII char */
             iml1 = m_get_unicode_canonical_combining_class(uml_ch_source);
             if (iml1 && (iml1 < inl_idna_prevccc))
               return -1;                   /* cannot be in NFC form   */
             inl_idna_prevccc = iml1;
             if (m_idna_cannotbe_nfc(unl_prevstrt, uml_ch_source))
               return -1;                   /* cannot be in NFC form   */
             if (!iml1)                     /* remember "starter"      */
               unl_prevstrt = uml_ch_source;
             break;
         }
       }
       /* store character in tree for later punycode representation    */
       if (--iml_idna_labelspace == 0)      /* over RFC 1034 maxlength */
         return -1;                         /* (limiting also precludes int overflow) */
       if ((iml_idna_labelspace==MAX_IDNAPART_LENGTH) && m_get_unicode_is_combining(uml_ch_source))
         return -1;                         /* combining mark as first in label */
       if (!utl_idna_tn) {                  /* first non-ASCII in this part*/
         bol_idna_nohighyet = FALSE;
         if (achl_cur_target+5 >= achl_end_target)
           return -1;                       /* output area too small   */
         /* prepend prefix to what we already have translated to ASCII */
         memmove( achl_idna_ps+4, achl_idna_ps, achl_cur_target-achl_idna_ps );
         memcpy( achl_idna_ps, "xn--", 4 );
         achl_cur_target += 4;
       }
       m_idna_add_to_treelist( dslr_idna_treelist, uml_ch_source, utl_idna_tn ++,
                               MAX_IDNAPART_LENGTH-iml_idna_labelspace );
       break;
       p_next_idnlbl:                       /* next dot-separated part */
       if (utl_idna_tn) {                   /* last part had non-ASCII */
         if (utl_idna_openzwnj &&
             !m_idna_zwnj_jtrule_ok( dslr_idna_treelist, utl_idna_openzwnj, utl_idna_tn ))
           return -1;                       /* earlier U+200C not conforming */
         achl_cur_target = m_idna_encode_utree( dslr_idna_treelist,
                           achl_cur_target-(achl_idna_ps+4),
                           achl_cur_target,
                           achl_end_target<=achl_idna_ps+MAX_IDNAPART_LENGTH
                                          ? achl_end_target
                                          : achl_idna_ps+MAX_IDNAPART_LENGTH
                           );
         if ((achl_cur_target == NULL) || (achl_cur_target >= achl_end_target))
           return -1;                       /* target overflow         */
       }
       *achl_cur_target++ = (unsigned char) '.';
       achl_idna_ps = achl_cur_target;
       iml_idna_labelspace = 1+MAX_IDNAPART_LENGTH;
       utl_idna_openzwnj = 0;
       iel_idna_minuspair = 0;
       inl_idna_prevccc = 255;
       unl_prevstrt = 0;
       utl_idna_tn = 0;
       break;
     case IED_CHS_COPY7A:                   /* idna-prohibited ascii   */
       if (uml_ch_source > 'z')
         return -1;  /* neither IDNA nor something like a IPv6-address */
       *((unsigned char *) achl_cur_target) = (unsigned char) uml_ch_source;
       achl_cur_target++;                   /* output one character    */
       break;
     case ied_chs_xml_utf_16:               /* UTF-16 with XML-CharRef */
       if (iel_xcro_st < 0) {               /* no entity-encode runs   */
         /* shortest encoding is preferred, hex (no div ops) if equal  */
         if (uml_ch_source < 0xE000)
           if (uml_ch_source < 0xA0)
             iel_xcro_st = chrs_xmlent_st[uml_ch_source];
           else                             /* 00A0                    */
             { if (uml_ch_source >= 0xD800) iel_xcro_st = 1; }
         else                               /* E000                    */
           if (uml_ch_source < 0xFDF0)
             { if (uml_ch_source >= 0xFDD0) iel_xcro_st = 1; }
           else                             /* FDF0                    */
             { if (((uml_ch_source&0xFFFE)==0xFFFE) && (uml_ch_source<0x110000)) iel_xcro_st = 1; }
       }
       if (iel_xcro_st >= 0) {              /* entity-encode runs now  */
         switch ((enum ied_xcro_st)iel_xcro_st) {
           case ied_xcro_hex_start:
           case ied_xcro_dec_start:
             uml_read_ch_source = uml_ch_source;
             uml_ch_source = 0x26;          /* '&', next: '#'          */
             iel_xcro_st ++;
             break;
           case ied_xcro_dec_carpet:
             uml_ch_source = 0x23;          /* '#', next: the number   */
             iel_xcro_st = (int)ied_xcro_dec_10;
             break;
           case ied_xcro_hex_carpet:
             uml_ch_source = 0x23;          /* '#', next: 'x'          */
             iel_xcro_st ++;
             break;
           case ied_xcro_hex_x:
             uml_ch_source = 0x78;          /* 'x', next: the number   */                 
             iel_xcro_st = (int)ied_xcro_hex_F00000;
             while (uml_read_ch_source >> iel_xcro_st == 0)
               iel_xcro_st -= 4;    /* will hang if called with U+0000 */
             break;
           case ied_xcro_txt_start_lt:
             achl_xenm = chrs_html_lt;      /* use entity name "lt"    */
             uml_ch_source = 0x26;          /* '&', next: name chars   */
             iel_xcro_st = (int)ied_xcro_txt;
             break;
           case ied_xcro_txt_start_gt:
             achl_xenm = chrs_html_gt;      /* use entity name "gt"    */
             uml_ch_source = 0x26;          /* '&', next: name chars   */
             iel_xcro_st = (int)ied_xcro_txt;
             break;
           case ied_xcro_txt:               /* char from achl_xenm     */
             uml_ch_source = *achl_xenm++;
             if (*achl_xenm == 0)
               iel_xcro_st = (int)ied_xcro_endchar;
             break;
           case ied_xcro_endchar:
             uml_ch_source = 0x3B;          /* ';'                     */
             iel_xcro_st = ied_xcro_after_end;
             break;
           case ied_xcro_after_end:
             iel_xcro_st = -1;              /* copy from source again  */
             achl_cur_source += iml_len_ch_source;
             goto pcpy_00;                  /* leave this codepart     */
           case ied_xcro_dec_10:
             uml_ch_source = uml_read_ch_source / 10;          
             if (uml_ch_source != 0) {
               uml_read_ch_source -= 10 * uml_ch_source;          
               uml_ch_source += 0x30;       /* '0'-based decimal char  */
               iel_xcro_st --;              /* next: ied_xcro_dec_01   */
               break;
             }                              /* else fall through       */
           case ied_xcro_dec_01:
             uml_ch_source = uml_read_ch_source + 0x30;
             iel_xcro_st = (int)ied_xcro_endchar;
             break;
           case ied_xcro_hex_00000F:
             uml_ch_source = uml_read_ch_source & 0xF;
             uml_ch_source += (uml_ch_source<10 ? 0x30 : 0x37);
             iel_xcro_st = (int)ied_xcro_endchar;
             break;
           default:    /* ied_xcro_hex_0000F0, ... ied_xcro_hex_F00000 */
             uml_ch_source = (uml_read_ch_source >> iel_xcro_st) & 0xF;
             uml_ch_source += (uml_ch_source<10 ? 0x30 : 0x37);
             iel_xcro_st -= 4;
             break;
         }
         *((HL_WCHAR *) achl_cur_target) = (HL_WCHAR) uml_ch_source;
         achl_cur_target += sizeof(HL_WCHAR);
         goto pcpy_20;
       }                                    /* else case-fall-through  */
     case ied_chs_utf_16:                   /* Unicode UTF-16 = WCHAR  */
       if (uml_ch_source >= 0X10000) {      /* over 16-bit, needs surrogates */
         uml_ch_source -= 0X10000;
         if (uml_ch_source & ~0xFFFFF) {    /* over 0x10FFFF, not possible */
           *((HL_WCHAR *) achl_cur_target) = UTF16_REP_CHAR;
         } else {
           *((HL_WCHAR *) achl_cur_target) = (HL_WCHAR)(0xD800 | (uml_ch_source >> 10));
           achl_cur_target += sizeof(HL_WCHAR);
           if (achl_cur_target >= achl_end_target)
             return -1;                     /* target overflow         */
           *((HL_WCHAR *) achl_cur_target) = (HL_WCHAR)(0xDC00 | (uml_ch_source & 0x03FF));
         }
       } else {                             /* 16-bit is enough        */
         *((HL_WCHAR *) achl_cur_target) = (HL_WCHAR) uml_ch_source;
       }
       achl_cur_target += sizeof(HL_WCHAR);
       break;
     case ied_chs_be_utf_16:                /* Unicode UTF-16 big endian */
       if (uml_ch_source >= 0X10000) {      /* over 16-bit, needs surrogates */
         uml_ch_source -= 0X10000;
         if (uml_ch_source & ~0xFFFFF) {    /* over 0x10FFFF, not possible */
           *((unsigned char *) achl_cur_target + 0) = (unsigned char) (UTF16_REP_CHAR >> 8);
           *((unsigned char *) achl_cur_target + 1) = (unsigned char) UTF16_REP_CHAR;
           achl_cur_target += sizeof(HL_WCHAR);
           break;
         }
         if (achl_cur_target+4 > achl_end_target)
           return -1;                       /* target overflow         */
         *((unsigned char *) achl_cur_target + 0) = (unsigned char) (0xD8 | (3 & (uml_ch_source >> 18)));
         *((unsigned char *) achl_cur_target + 1) = (unsigned char) (uml_ch_source >> 10);
         *((unsigned char *) achl_cur_target + 2) = (unsigned char) (0xDC | (3 & (uml_ch_source >> 8)));
         *((unsigned char *) achl_cur_target + 3) = (unsigned char) uml_ch_source;
         achl_cur_target += 2 * sizeof(HL_WCHAR);
       } else {                             /* 16-bit is enough        */
         *((unsigned char *) achl_cur_target + 0) = (unsigned char) (uml_ch_source >> 8);
         *((unsigned char *) achl_cur_target + 1) = (unsigned char) uml_ch_source;
         achl_cur_target += sizeof(HL_WCHAR);
       }
       break;
     case ied_chs_le_utf_16:                /* Unicode UTF-16 little endian */
       if (uml_ch_source >= 0X10000) {      /* over 16-bit, needs surrogates */
         uml_ch_source -= 0X10000;
         if (uml_ch_source & ~0xFFFFF) {    /* over 0x10FFFF, not possible */
           *((unsigned char *) achl_cur_target + 0) = (unsigned char) UTF16_REP_CHAR;
           *((unsigned char *) achl_cur_target + 1) = (unsigned char) (UTF16_REP_CHAR >> 8);
           achl_cur_target += sizeof(HL_WCHAR);
           break;
         }
         if (achl_cur_target+4 > achl_end_target)
           return -1;                       /* target overflow         */
         *((unsigned char *) achl_cur_target + 0) = (unsigned char) (uml_ch_source >> 10);
         *((unsigned char *) achl_cur_target + 1) = (unsigned char) (0xD8 | (3 & (uml_ch_source >> 18)));
         *((unsigned char *) achl_cur_target + 2) = (unsigned char) uml_ch_source;
         *((unsigned char *) achl_cur_target + 3) = (unsigned char) (0xDC | (3 & (uml_ch_source >> 8)));
         achl_cur_target += 2 * sizeof(HL_WCHAR);
       } else {                             /* 16-bit is enough        */
         *((unsigned char *) achl_cur_target + 0) = (unsigned char) uml_ch_source;
         *((unsigned char *) achl_cur_target + 1) = (unsigned char) (uml_ch_source >> 8);
         achl_cur_target += sizeof(HL_WCHAR);
       }
       break;
     case ied_chs_utf_32:                   /* Unicode UTF-32          */
       *((unsigned int *) achl_cur_target) = (unsigned int) uml_ch_source;
       achl_cur_target += sizeof(unsigned int);
       break;
     case ied_chs_be_utf_32:                /* Unicode UTF-32 big endian */
       *((unsigned char *) achl_cur_target + 0) = (unsigned char) (uml_ch_source >> 24);
       *((unsigned char *) achl_cur_target + 1) = (unsigned char) (uml_ch_source >> 16);
       *((unsigned char *) achl_cur_target + 2) = (unsigned char) (uml_ch_source >> 8);
       *((unsigned char *) achl_cur_target + 3) = (unsigned char) uml_ch_source;
       achl_cur_target += sizeof(unsigned int);
       break;
     case ied_chs_le_utf_32:                /* Unicode UTF-32 little endian */
       *((unsigned char *) achl_cur_target + 0) = (unsigned char) uml_ch_source;
       *((unsigned char *) achl_cur_target + 1) = (unsigned char) (uml_ch_source >> 8);
       *((unsigned char *) achl_cur_target + 2) = (unsigned char) (uml_ch_source >> 16);
       *((unsigned char *) achl_cur_target + 3) = (unsigned char) (uml_ch_source >> 24);
       achl_cur_target += sizeof(unsigned int);
       break;
     default:
       return -1;                           /* cannot copy             */
   }
   achl_cur_source += iml_len_ch_source;
   goto pcpy_00;                            /* copy characters         */

   p_identcpy:                              /* copy bytes unchanged    */
   if (imp_len_source >= 0) {               /* length source given     */
     if (imp_len_source >= imp_len_target) {  /* output area too short */
       memcpy( ap_target, ap_source, imp_len_target );
       if ((ibp_flags & D_CPYVXVX_FL_NOTAIL0) && (imp_len_source == imp_len_target))
         return imp_len_target;
       return -1;
     }
     memcpy( ap_target, ap_source, imp_len_source );
     if ((ibp_flags & D_CPYVXVX_FL_NOTAIL0) == 0)
       achl_cur_target[imp_len_source] = 0;
     return imp_len_source;
   }
   /* length source not given                                          */
   achl_end_target = achl_cur_target + imp_len_target;
   achl_cur_source = (const char *) ap_source;
   while (TRUE) {
     if( *achl_cur_source == 0 ) {          /* terminating zero reached */
       if ((ibp_flags & D_CPYVXVX_FL_NOTAIL0) == 0) {  /* copy the zero */
         if (achl_cur_target >= achl_end_target) return -1;  /* output area too short */
         *achl_cur_target = 0;
       }
       return achl_cur_source - (const char *) ap_source;
     }
     if (achl_cur_target >= achl_end_target) return -1;  /* output area too short */
     *achl_cur_target++ = *achl_cur_source++;
   }
} /* end m_cpy_vx_vx()                                                 */

/**
* copy source string to target with translation to lower case
*  @param ap_target destination (output) pointer
*  @param imp_len_target length of output buffer, in 8/16/32-bit units
*  @param iep_cs_target encoding to use for output
*  @param ap_source pointer to original string (input)
*  @param imp_len_source anything negative means the input is zero-terminated,
*                        else length of original string in 8/16/32-bit units
*  @param iep_cs_source encoding used by original string
*  @param ibp_flags special flags (use the wrapper macro m_cpy_lc_vx_vx instead
*                   of this function to ignore this param and use the defaults).
*                   If flag D_CPYVXVX_FL_NOTAIL0 is set, will not zero-terminate
*  @return -1 on error, else length of output (in 8/16/32-bit units depending on
*          iep_cs_target), excluding the terminating zero
*/
extern PTYPE int m_cpy_lc_vx_vx_fl( void *ap_target,
                                  int imp_len_target,
                                  enum ied_charset iep_cs_target,
                                  const void *ap_source,
                                  int imp_len_source,
                                  enum ied_charset iep_cs_source,
                                  unsigned int ibp_flags ) {
   BOOL          bol1;                      /* working-variable        */
   int           iml1;                      /* working-variable        */
   const char    *achl_cur_source;          /* current position parameter */
   char          *achl_cur_target;          /* current position parameter */
   const char    *achl_end_source;          /* end of parameter        */
   char          *achl_end_target;          /* end of parameter        */
   unsigned int  uml_ch_source;             /* character decoded       */
   int           iml_len_ch_source;         /* length of parameter     */
   HL_WCHAR      *awcl_dbcsenc;             /* dbcs encoding table     */
   struct dsd_idna_upoint dslr_idna_treelist[MAX_IDNAPART_LENGTH];  /* non-ascii data */
   unsigned char utl_idna_tn;               /* length for dsd_idna_upoint */
   char          *achl_idna_ps;             /* target start of current label */
   int           iml_idna_labelspace;       /* rest of RFC 1034 maxlen */
   unsigned char utl_idna_openzwnj;         /* U+200C yet to be accepted (RFC 5892 A.1.) */
   /* variables for tests required for IDNA target by RFC 5891 5.4.    */
   int           iel_idna_minuspair;        /* detect labels starting with "..--" */
   BOOL          bol_idna_nohighyet;        /* only <='z' in all labels so far */
   int           inl_idna_prevccc;          /* canonical combining class */
   unsigned int  unl_prevstrt;              /* last char with ccc == 0 */
   /* variables for multi-char XML-reference instead of copying source */
   int           iel_xcro_st;               /* state, -1 or enum ied_xcro_st */
   unsigned int  uml_read_ch_source;        /* original character decoded */
   char          *achl_xenm;                /* next entity-name char   */

#ifdef CHECK_HTML
   int        iml2;                         /* working variable        */
   iml1 = sizeof(dsrs_sort_html_alpha) / sizeof(dsrs_sort_html_alpha[0]) - 1;
   do {
     iml1--;
     iml2 = strcmp( dsrs_sort_html_alpha[ iml1 ].achc_char,
                    dsrs_sort_html_alpha[ iml1 + 1 ].achc_char );
     if (iml2 >= 0) {
       printf( "xslunic1-l%05d-E invalid sort sequence dsrs_sort_html_alpha element %d.\n",
               __LINE__, iml1 );
       return -1;
     }
   } while (iml1 > 0);
#endif
   if (imp_len_target <= 0) return -1;
   /* calculate end of parameter target                                */
   achl_cur_target = (char *) ap_target;
   switch (iep_cs_target) {
     case ied_chs_ascii_850:                /* ASCII 850               */
     case ied_chs_ansi_819:                 /* ANSI 819                */
     case ied_chs_wcp_1256:                 /* Windows-Codepage 1256   */
     case ied_chs_iso8859_2:                /* ISO 8859-2              */
     case ied_chs_iso8859_4:                /* ISO 8859-4              */
     case ied_chs_iso8859_5:                /* ISO 8859-5              */
     case ied_chs_iso8859_9:                /* ISO 8859-9              */
     case ied_chs_iso8859_10:               /* ISO 8859-10             */
     case ied_chs_iso8859_13:               /* ISO 8859-13             */
     case ied_chs_iso8859_14:               /* ISO 8859-14             */
     case ied_chs_iso8859_15:               /* ISO 8859-15             */
     case ied_chs_iso8859_16:               /* ISO 8859-16             */
     case ied_chs_oem_437:                  /* DOS-Codepage 437        */
     case ied_chs_wcp_874:                  /* Windows-Codepage  874   */
     case ied_chs_wcp_1250:                 /* Windows-Codepage 1250   */
     case ied_chs_wcp_1251:                 /* Windows-Codepage 1251   */
     case ied_chs_wcp_1252:                 /* Windows-Codepage 1252   */
     case ied_chs_wcp_1253:                 /* Windows-Codepage 1253   */
     case ied_chs_wcp_1254:                 /* Windows-Codepage 1254   */
     case ied_chs_wcp_1255:                 /* Windows-Codepage 1255   */
     case ied_chs_wcp_1257:                 /* Windows-Codepage 1257   */
     case ied_chs_wcp_1258:                 /* Windows-Codepage 1258   */
     case ied_chs_iso8859_3:                /* ISO 8859-3              */
     case ied_chs_iso8859_6:                /* ISO 8859-6              */
     case ied_chs_iso8859_7:                /* ISO 8859-7              */
     case ied_chs_iso8859_8:                /* ISO 8859-8              */
     case ied_chs_iso8859_11:               /* ISO 8859-11             */
     case ied_chs_utf_8:                    /* Unicode UTF-8           */
     case ied_chs_html_1:                   /* HTML character set      */
     case ied_chs_uri_1:                    /* URI, percent-encoded    */
     case ied_chs_hsf_1:                    /* HOB special file system */
       achl_end_target = ((char *) ap_target) + imp_len_target;
       break;
     case ied_chs_ldap_escaped_utf_8:       /* LDAP UTF-8 escaped      */
       bol1 = TRUE;                         /* yet awaiting first '='  */
       achl_end_target = ((char *) ap_target) + imp_len_target;
       break;
     case ied_chs_xml_utf_8:                /* UTF-8 with XML-CharRef  */
     case ied_chs_xml_wcp_1252:             /* Windows-1252 with XML-CharRef */
       iel_xcro_st = -1;
       achl_end_target = ((char *) ap_target) + imp_len_target;
       break;
     case ied_chs_idna_1:                   /* IDNA RFC 3490 - Punycode */
       achl_idna_ps = achl_cur_target;
       iml_idna_labelspace = 1+MAX_IDNAPART_LENGTH;
       utl_idna_openzwnj = 0;        /* =none, at 0 would not be legal */
       iel_idna_minuspair = 0;
       bol_idna_nohighyet = TRUE;
       inl_idna_prevccc = 255;
       unl_prevstrt = 0;
       utl_idna_tn = 0;
       achl_end_target = ((char *) ap_target) + imp_len_target;
       break;
     CASE_IED_CHS_ALL_CJK
       awcl_dbcsenc = m_get_tab_uni_to_mb(iep_cs_target);
       achl_end_target = ((char *) ap_target) + imp_len_target;
       break;
     case ied_chs_xml_utf_16:               /* UTF-16 with XML-CharRef */
       iel_xcro_st = -1;                    /* and fall through        */
     CASE_IED_CHS_U16_ALLENDIAN
       achl_end_target = ((char *) ap_target) + imp_len_target * sizeof(HL_WCHAR);
       break;
     CASE_IED_CHS_U32_ALLENDIAN
       achl_end_target = ((char *) ap_target) + imp_len_target * sizeof(unsigned int);
       break;
     default:
       return -1;                           /* cannot copy             */
   }
   /* calculate end of parameter source                                */
   achl_cur_source = (const char *) ap_source;
   achl_end_source = NULL;                  /* still zero-terminated   */
   if (imp_len_source >= 0) {               /* length source given     */
     switch (iep_cs_source) {
       case ied_chs_ascii_850:              /* ASCII 850               */
       case ied_chs_ansi_819:               /* ANSI 819                */
       CASE_IED_CHS_MISCCODEPAGES
       CASE_IED_CHS_ALL_CJK
       CASE_IED_CHS_ISO8859_2TO16
       CASE_IED_CHS_ESCHEXHEX_U8
       case ied_chs_utf_8:                  /* Unicode UTF-8           */
       case ied_chs_xml_utf_8:              /* UTF-8 with XML-CharRef  */
       case ied_chs_xml_wcp_1252:           /* Windows-1252 with XML-CharRef */
       case ied_chs_html_1:                 /* HTML character set      */
         achl_end_source = ((const char *) ap_source) + imp_len_source;
         break;
       CASE_IED_CHS_U16_ALLENDIAN
       case ied_chs_xml_utf_16:             /* UTF-16 with XML-CharRef */
         achl_end_source = ((const char *) ap_source) + imp_len_source * sizeof(HL_WCHAR);
         break;
       CASE_IED_CHS_U32_ALLENDIAN
         achl_end_source = ((const char *) ap_source) + imp_len_source * sizeof(unsigned int);
         break;
       default:
         return -1;                         /* cannot copy             */
     }
   }

   pcpy_00:                                 /* copy characters         */
   iml_len_ch_source = m_get_vc_ch( &uml_ch_source, achl_cur_source, achl_end_source, iep_cs_source );
   if (iml_len_ch_source <= 0) {            /* subroutine reported end or error */
     if (iml_len_ch_source == 0) {          /* end of input found      */
       switch (iep_cs_target) {
         case ied_chs_idna_1:               /* IDNA RFC 3490 - Punycode */
           if (utl_idna_tn) {               /* last part had non-ASCII */
             if (utl_idna_openzwnj &&
                 !m_idna_zwnj_jtrule_ok( dslr_idna_treelist, utl_idna_openzwnj, utl_idna_tn ))
               return -1;                   /* earlier U+200C not conforming */
             /* encode the non-ascii chars of the last part            */
             achl_cur_target = m_idna_encode_utree( dslr_idna_treelist,
                               achl_cur_target-(achl_idna_ps+4),
                               achl_cur_target,
                               achl_end_target<=achl_idna_ps+MAX_IDNAPART_LENGTH
                                              ? achl_end_target
                                              : achl_idna_ps+MAX_IDNAPART_LENGTH
                               );
             if ((achl_cur_target == NULL) || (achl_cur_target >= achl_end_target))
               return -1;                   /* target overflow         */
           }                                /* fall through            */
         case IED_CHS_COPY7A:               /* idna-prohibited ascii   */
         case ied_chs_ascii_850:            /* ASCII 850               */
         case ied_chs_ansi_819:             /* ANSI 819                */
         CASE_IED_CHS_MISCCODEPAGES
         CASE_IED_CHS_ALL_CJK
         CASE_IED_CHS_ISO8859_2TO16
         CASE_IED_CHS_ESCHEXHEX_U8
         case ied_chs_utf_8:                /* Unicode UTF-8           */
         case ied_chs_xml_utf_8:            /* UTF-8 with XML-CharRef  */
         case ied_chs_xml_wcp_1252:         /* Windows-1252 with XML-CharRef */
         case ied_chs_html_1:               /* HTML character set      */
           if ((ibp_flags & D_CPYVXVX_FL_NOTAIL0) == 0) {
             if (achl_cur_target >= achl_end_target) return -1;  /* output area too short */
             *achl_cur_target = 0;          /* make zero-terminated    */
           }
           return achl_cur_target - (char *) ap_target;
         case ied_chs_utf_16:               /* Unicode UTF-16 = WCHAR  */
         case ied_chs_xml_utf_16:           /* UTF-16 with XML-CharRef */
           if ((ibp_flags & D_CPYVXVX_FL_NOTAIL0) == 0) {
             if (achl_cur_target+sizeof(HL_WCHAR) > achl_end_target) return -1;  /* too short */
             *((HL_WCHAR *) achl_cur_target) = 0;  /* make zero-terminated */
           }
           return (achl_cur_target - (char *) ap_target) / sizeof(HL_WCHAR);
         case ied_chs_be_utf_16:            /* Unicode UTF-16 big endian */
         case ied_chs_le_utf_16:            /* Unicode UTF-16 little endian */
           if ((ibp_flags & D_CPYVXVX_FL_NOTAIL0) == 0) {
             if (achl_cur_target+2 > achl_end_target) return -1;  /* output area too short */
             *((char  *) achl_cur_target + 0) = 0;  /* make zero-terminated */
             *((char  *) achl_cur_target + 1) = 0;  /* make zero-terminated */
           }
           return (achl_cur_target - (char *) ap_target) / sizeof(HL_WCHAR);
         case ied_chs_utf_32:               /* Unicode UTF-32          */
           if ((ibp_flags & D_CPYVXVX_FL_NOTAIL0) == 0) {
             if (achl_cur_target+sizeof(unsigned int) > achl_end_target) return -1;  /* too short */
             *((unsigned int *) achl_cur_target) = 0;  /* make zero-terminated */
           }
           return (achl_cur_target - (char *) ap_target) / sizeof(unsigned int);
         case ied_chs_be_utf_32:            /* Unicode UTF-32 big endian */
         case ied_chs_le_utf_32:            /* Unicode UTF-32 little endian */
           if ((ibp_flags & D_CPYVXVX_FL_NOTAIL0) == 0) {
             if (achl_cur_target+4 > achl_end_target) return -1;  /* output area too short */
             *((char  *) achl_cur_target + 0) = 0;  /* make zero-terminated */
             *((char  *) achl_cur_target + 1) = 0;  /* make zero-terminated */
             *((char  *) achl_cur_target + 2) = 0;  /* make zero-terminated */
             *((char  *) achl_cur_target + 3) = 0;  /* make zero-terminated */
           }
           return (achl_cur_target - (char *) ap_target) / sizeof(unsigned int);
         default:
           return -1;                       /* error                   */
       }
     }
     return -1;                             /* return error            */
   }
   pcpy_20:                                 /* output characters       */
   if (achl_cur_target >= achl_end_target) return -1;  /* output area too short */
   uml_ch_source = m_trans_32_to_lc( uml_ch_source );  /* translate to lower case */
   switch (iep_cs_target) {
     case ied_chs_ascii_850:                /* ASCII 850               */
       if (uml_ch_source < 0X0100) {
         *((unsigned char *) achl_cur_target) = (unsigned char) ucrg_tab_819_to_850[ uml_ch_source ];
       } else {
         *achl_cur_target = '?';
       }
       achl_cur_target++;                   /* output one character    */
       break;
     case ied_chs_ansi_819:                 /* ANSI 819                */
       if (uml_ch_source < 0X0100) {
         *((unsigned char *) achl_cur_target) = (unsigned char) uml_ch_source;
       } else {
         *achl_cur_target = '?';
       }
       achl_cur_target++;                   /* output one character    */
       break;
     case ied_chs_oem_437:                  /* DOS-Codepage 437        */
       *((unsigned char *) achl_cur_target) = (unsigned char) m_u32c_to_437( uml_ch_source );
       achl_cur_target++;                   /* output one character    */
       break;
     case ied_chs_wcp_874:                  /* Windows-Codepage  874   */
       *((unsigned char *) achl_cur_target) = (unsigned char) m_u32c_to_874( uml_ch_source );
       achl_cur_target++;                   /* output one character    */
       break;
     case ied_chs_wcp_1250:                 /* Windows-Codepage 1250   */
       *((unsigned char *) achl_cur_target) = (unsigned char) m_u32c_to_1250( uml_ch_source );
       achl_cur_target++;                   /* output one character    */
       break;
     case ied_chs_wcp_1251:                 /* Windows-Codepage 1251   */
       *((unsigned char *) achl_cur_target) = (unsigned char) m_u32c_to_1251( uml_ch_source );
       achl_cur_target++;                   /* output one character    */
       break;
     case ied_chs_xml_wcp_1252:             /* Windows-1252 with XML-CharRef */
       if (iel_xcro_st < 0) {               /* no entity-encode runs   */
         /* shortest encoding is preferred, hex (no div ops) if equal  */
         /* over 0x7F either ASCII_REP_CHAR or no need to XML-encode   */
         if (uml_ch_source < 0x80)
           iel_xcro_st = chrs_xmlent_st[uml_ch_source];
       }
       if (iel_xcro_st >= 0) {              /* entity-encode runs now  */
         switch ((enum ied_xcro_st)iel_xcro_st) {
           case ied_xcro_hex_start:
           case ied_xcro_dec_start:
             uml_read_ch_source = uml_ch_source;
             uml_ch_source = 0x26;          /* '&', next: '#'          */
             iel_xcro_st ++;
             break;
           case ied_xcro_dec_carpet:
             uml_ch_source = 0x23;          /* '#', next: the number   */
             iel_xcro_st = (int)ied_xcro_dec_10;
             break;
           case ied_xcro_hex_carpet:
             uml_ch_source = 0x23;          /* '#', next: 'x'          */
             iel_xcro_st ++;
             break;
           case ied_xcro_hex_x:
             uml_ch_source = 0x78;          /* 'x', next: the number   */                 
             iel_xcro_st = (int)ied_xcro_hex_F00000;
             while (uml_read_ch_source >> iel_xcro_st == 0)
               iel_xcro_st -= 4;    /* will hang if called with U+0000 */
             break;
           case ied_xcro_txt_start_lt:
             achl_xenm = chrs_html_lt;      /* use entity name "lt"    */
             uml_ch_source = 0x26;          /* '&', next: name chars   */
             iel_xcro_st = (int)ied_xcro_txt;
             break;
           case ied_xcro_txt_start_gt:
             achl_xenm = chrs_html_gt;      /* use entity name "gt"    */
             uml_ch_source = 0x26;          /* '&', next: name chars   */
             iel_xcro_st = (int)ied_xcro_txt;
             break;
           case ied_xcro_txt:               /* char from achl_xenm     */
             uml_ch_source = *achl_xenm++;
             if (*achl_xenm == 0)
               iel_xcro_st = (int)ied_xcro_endchar;
             break;
           case ied_xcro_endchar:
             uml_ch_source = 0x3B;          /* ';'                     */
             iel_xcro_st = ied_xcro_after_end;
             break;
           case ied_xcro_after_end:
             iel_xcro_st = -1;              /* copy from source again  */
             achl_cur_source += iml_len_ch_source;
             goto pcpy_00;                  /* leave this codepart     */
           case ied_xcro_dec_10:
             uml_ch_source = uml_read_ch_source / 10;          
             if (uml_ch_source != 0) {
               uml_read_ch_source -= 10 * uml_ch_source;          
               uml_ch_source += 0x30;       /* '0'-based decimal char  */
               iel_xcro_st --;              /* next: ied_xcro_dec_01   */
               break;
             }                              /* else fall through       */
           case ied_xcro_dec_01:
             uml_ch_source = uml_read_ch_source + 0x30;
             iel_xcro_st = (int)ied_xcro_endchar;
             break;
           case ied_xcro_hex_00000F:
             uml_ch_source = uml_read_ch_source & 0xF;
             uml_ch_source += (uml_ch_source<10 ? 0x30 : 0x37);
             iel_xcro_st = (int)ied_xcro_endchar;
             break;
           default:    /* ied_xcro_hex_0000F0, ... ied_xcro_hex_F00000 */
             uml_ch_source = (uml_read_ch_source >> iel_xcro_st) & 0xF;
             uml_ch_source += (uml_ch_source<10 ? 0x30 : 0x37);
             iel_xcro_st -= 4;
             break;
         }
         *achl_cur_target++ = (unsigned char) uml_ch_source;
         goto pcpy_20;
       }                                    /* else case-fall-through  */
     case ied_chs_wcp_1252:                 /* Windows-Codepage 1252   */
       *((unsigned char *) achl_cur_target) = (unsigned char) m_u32c_to_1252( uml_ch_source );
       achl_cur_target++;                   /* output one character    */
       break;
     case ied_chs_wcp_1253:                 /* Windows-Codepage 1253   */
       *((unsigned char *) achl_cur_target) = (unsigned char) m_u32c_to_1253( uml_ch_source );
       achl_cur_target++;                   /* output one character    */
       break;
     case ied_chs_wcp_1254:                 /* Windows-Codepage 1254   */
       *((unsigned char *) achl_cur_target) = (unsigned char) m_u32c_to_1254( uml_ch_source );
       achl_cur_target++;                   /* output one character    */
       break;
     case ied_chs_wcp_1255:                 /* Windows-Codepage 1255   */
       *((unsigned char *) achl_cur_target) = (unsigned char) m_u32c_to_1255( uml_ch_source );
       achl_cur_target++;                   /* output one character    */
       break;
     case ied_chs_wcp_1256:                 /* Windows-Codepage 1256   */
       *((unsigned char *) achl_cur_target) = (unsigned char) m_u32c_to_1256( uml_ch_source );
       achl_cur_target++;                   /* output one character    */
       break;
     case ied_chs_wcp_1257:                 /* Windows-Codepage 1257   */
       *((unsigned char *) achl_cur_target) = (unsigned char) m_u32c_to_1257( uml_ch_source );
       achl_cur_target++;                   /* output one character    */
       break;
     case ied_chs_wcp_1258:                 /* Windows-Codepage 1258   */
       *((unsigned char *) achl_cur_target) = (unsigned char) m_u32c_to_1258( uml_ch_source );
       achl_cur_target++;                   /* output one character    */
       break;
     case ied_chs_iso8859_2:                /* ISO 8859-2 (Latin-2)    */
       *((unsigned char *) achl_cur_target) = (unsigned char) m_u32c_to_i02( uml_ch_source );
       achl_cur_target++;                   /* output one character    */
       break;
     case ied_chs_iso8859_3:                /* ISO 8859-3 (Latin-3)    */
       *((unsigned char *) achl_cur_target) = (unsigned char) m_u32c_to_i03( uml_ch_source );
       achl_cur_target++;                   /* output one character    */
       break;
     case ied_chs_iso8859_4:                /* ISO 8859-4 (Latin-4)    */
       *((unsigned char *) achl_cur_target) = (unsigned char) m_u32c_to_i04( uml_ch_source );
       achl_cur_target++;                   /* output one character    */
       break;
     case ied_chs_iso8859_5:                /* ISO 8859-5              */
       *((unsigned char *) achl_cur_target) = (unsigned char) m_u32c_to_i05( uml_ch_source );
       achl_cur_target++;                   /* output one character    */
       break;
     case ied_chs_iso8859_6:                /* ISO 8859-6              */
       *((unsigned char *) achl_cur_target) = (unsigned char) m_u32c_to_i06( uml_ch_source );
       achl_cur_target++;                   /* output one character    */
       break;
     case ied_chs_iso8859_7:                /* ISO 8859-7              */
       *((unsigned char *) achl_cur_target) = (unsigned char) m_u32c_to_i07( uml_ch_source );
       achl_cur_target++;                   /* output one character    */
       break;
     case ied_chs_iso8859_8:                /* ISO 8859-8              */
       *((unsigned char *) achl_cur_target) = (unsigned char) m_u32c_to_i08( uml_ch_source );
       achl_cur_target++;                   /* output one character    */
       break;
     case ied_chs_iso8859_9:                /* ISO 8859-9 (Latin-5)    */
       *((unsigned char *) achl_cur_target) = (unsigned char) m_u32c_to_i09( uml_ch_source );
       achl_cur_target++;                   /* output one character    */
       break;
     case ied_chs_iso8859_10:               /* ISO 8859-10 (Latin-6)   */
       *((unsigned char *) achl_cur_target) = (unsigned char) m_u32c_to_i10( uml_ch_source );
       achl_cur_target++;                   /* output one character    */
       break;
     case ied_chs_iso8859_11:               /* ISO 8859-11             */
       *((unsigned char *) achl_cur_target) = (unsigned char) m_u32c_to_i11( uml_ch_source );
       achl_cur_target++;                   /* output one character    */
       break;
     case ied_chs_iso8859_13:               /* ISO 8859-13 (Latin-7)   */
       *((unsigned char *) achl_cur_target) = (unsigned char) m_u32c_to_i13( uml_ch_source );
       achl_cur_target++;                   /* output one character    */
       break;
     case ied_chs_iso8859_14:               /* ISO 8859-14 (Latin-8)   */
       *((unsigned char *) achl_cur_target) = (unsigned char) m_u32c_to_i14( uml_ch_source );
       achl_cur_target++;                   /* output one character    */
       break;
     case ied_chs_iso8859_15:               /* ISO 8859-15 (Latin-9)   */
       *((unsigned char *) achl_cur_target) = (unsigned char) m_u32c_to_i15( uml_ch_source );
       achl_cur_target++;                   /* output one character    */
       break;
     case ied_chs_iso8859_16:               /* ISO 8859-16 (Latin-10)  */
       *((unsigned char *) achl_cur_target) = (unsigned char) m_u32c_to_i16( uml_ch_source );
       achl_cur_target++;                   /* output one character    */
       break;
     CASE_IED_CHS_ALL_CJK
       if (uml_ch_source >= 0x10000) {
         *achl_cur_target++ = ASCII_REP_CHAR;
       } else {
         iml1 = awcl_dbcsenc[uml_ch_source];
         if (iml1 & 0xFF00)
           *achl_cur_target++ = (char)(iml1>>8);  /* dbcs lead byte    */
         *achl_cur_target++ = (char)iml1;   /* bits for second byte    */
       }
       /* UUU instead of ASCII_REP_CHAR use "Katakana middle dot for 932", says
   ftp://unicode.org/Public/MAPPINGS/VENDORS/MICSFT/WindowsBestFit/readme.txt 
   KATAKANA MIDDLE DOT is U+30FB, coded by 0x81 0x45 (so 2-byte in len_vx_vx) */
       break;
     case ied_chs_ldap_escaped_utf_8:       /* LDAP UTF-8 escaped      */
       switch (uml_ch_source >> 5) {
         case 0:
           if (uml_ch_source == 0x00) {     /* mask hexadecimally      */
             iml1 = m_put_uri_1_a( achl_cur_target, achl_end_target, uml_ch_source, '\\' );
             if (iml1 < 0) return -1;       /* output area too short   */
             achl_cur_target += iml1;       /* increment pointer output */
             break;                         /* all done                */
           }
           *achl_cur_target++ = (unsigned char) uml_ch_source;
           break;
         case 1:
           if (((unsigned int)1<<(uml_ch_source-0x20)) & 0x7800180D) {
             if (bol1 && (char)uml_ch_source=='=') {  /* the first '=' */
               bol1 = FALSE;
             } else {
               *achl_cur_target++ = '\\';   /* mask by prepending '\\' */
               if (achl_cur_target >= achl_end_target)
                 return -1;                 /* output area too short   */
             }
           }
           *achl_cur_target++ = (unsigned char) uml_ch_source;
           break;
         case 2:
           if (uml_ch_source == 0x5C) {
             *achl_cur_target++ = '\\';     /* mask by prepending '\\' */
             if (achl_cur_target >= achl_end_target)
               return -1;                   /* output area too short   */
           }
           /* fall through */
         case 3:
           *achl_cur_target++ = (unsigned char) uml_ch_source;
           break;
         default:
         /* to escape all non-ASCII-bytes, instead of the goto do here what is
            done to char 0x00 in case 0. However, the RFC does not demand it. */
           goto p_enc_utf8_over7bit;
       }
       break;
     case ied_chs_xml_utf_8:                /* UTF-8 with XML-CharRef  */
       if (iel_xcro_st < 0) {               /* no entity-encode runs   */
         /* shortest encoding is preferred, hex (no div ops) if equal  */
         if (uml_ch_source < 0xE000)
           if (uml_ch_source < 0xA0)
             iel_xcro_st = chrs_xmlent_st[uml_ch_source];
           else                             /* 00A0                    */
             { if (uml_ch_source >= 0xD800) iel_xcro_st = 1; }
         else                               /* E000                    */
           if (uml_ch_source < 0xFDF0)
             { if (uml_ch_source >= 0xFDD0) iel_xcro_st = 1; }
           else                             /* FDF0                    */
             { if ((uml_ch_source&0xFFFE)==0xFFFE) iel_xcro_st = 1; }
       }
       if (iel_xcro_st >= 0) {              /* entity-encode runs now  */
         switch ((enum ied_xcro_st)iel_xcro_st) {
           case ied_xcro_hex_start:
           case ied_xcro_dec_start:
             uml_read_ch_source = uml_ch_source;
             uml_ch_source = 0x26;          /* '&', next: '#'          */
             iel_xcro_st ++;
             break;
           case ied_xcro_dec_carpet:
             uml_ch_source = 0x23;          /* '#', next: the number   */
             iel_xcro_st = (int)ied_xcro_dec_10;
             break;
           case ied_xcro_hex_carpet:
             uml_ch_source = 0x23;          /* '#', next: 'x'          */
             iel_xcro_st ++;
             break;
           case ied_xcro_hex_x:
             uml_ch_source = 0x78;          /* 'x', next: the number   */                 
             iel_xcro_st = (int)ied_xcro_hex_F00000;
             while (uml_read_ch_source >> iel_xcro_st == 0)
               iel_xcro_st -= 4;    /* will hang if called with U+0000 */
             break;
           case ied_xcro_txt_start_lt:
             achl_xenm = chrs_html_lt;      /* use entity name "lt"    */
             uml_ch_source = 0x26;          /* '&', next: name chars   */
             iel_xcro_st = (int)ied_xcro_txt;
             break;
           case ied_xcro_txt_start_gt:
             achl_xenm = chrs_html_gt;      /* use entity name "gt"    */
             uml_ch_source = 0x26;          /* '&', next: name chars   */
             iel_xcro_st = (int)ied_xcro_txt;
             break;
           case ied_xcro_txt:               /* char from achl_xenm     */
             uml_ch_source = *achl_xenm++;
             if (*achl_xenm == 0)
               iel_xcro_st = (int)ied_xcro_endchar;
             break;
           case ied_xcro_endchar:
             uml_ch_source = 0x3B;          /* ';'                     */
             iel_xcro_st = ied_xcro_after_end;
             break;
           case ied_xcro_after_end:
             iel_xcro_st = -1;              /* copy from source again  */
             achl_cur_source += iml_len_ch_source;
             goto pcpy_00;                  /* leave this codepart     */
           case ied_xcro_dec_10:
             uml_ch_source = uml_read_ch_source / 10;          
             if (uml_ch_source != 0) {
               uml_read_ch_source -= 10 * uml_ch_source;          
               uml_ch_source += 0x30;       /* '0'-based decimal char  */
               iel_xcro_st --;              /* next: ied_xcro_dec_01   */
               break;
             }                              /* else fall through       */
           case ied_xcro_dec_01:
             uml_ch_source = uml_read_ch_source + 0x30;
             iel_xcro_st = (int)ied_xcro_endchar;
             break;
           case ied_xcro_hex_00000F:
             uml_ch_source = uml_read_ch_source & 0xF;
             uml_ch_source += (uml_ch_source<10 ? 0x30 : 0x37);
             iel_xcro_st = (int)ied_xcro_endchar;
             break;
           default:    /* ied_xcro_hex_0000F0, ... ied_xcro_hex_F00000 */
             uml_ch_source = (uml_read_ch_source >> iel_xcro_st) & 0xF;
             uml_ch_source += (uml_ch_source<10 ? 0x30 : 0x37);
             iel_xcro_st -= 4;
             break;
         }
         *achl_cur_target++ = (unsigned char) uml_ch_source;
         goto pcpy_20;
       }                                    /* else case-fall-through  */
     case ied_chs_utf_8:                    /* Unicode UTF-8           */
       if ((uml_ch_source != 0) && ((uml_ch_source >> 7) == 0)) {  /* not zero or 0X80 (Why not zero? This way it encodes U+0000 with a superfluous extra byte WS 8.12.2011) */
         *achl_cur_target++ = (unsigned char) uml_ch_source;
         break;
       }
       p_enc_utf8_over7bit:
       if ((uml_ch_source >> 11) == 0) {
         *achl_cur_target++ = 0XC0 | (uml_ch_source >> 6);
         /* check at maximum output                                      */
         if (achl_cur_target >= achl_end_target) return -1;  /* output area too short */
         *achl_cur_target++ = 0X80 | (uml_ch_source & 0X3F);
         break;
       }
       if ((uml_ch_source >> 16) == 0) {
         *achl_cur_target++ = 0XE0 | (uml_ch_source >> 12);
         if (achl_cur_target >= achl_end_target) return -1;  /* output area too short */
         *achl_cur_target++ = (0X80 | ((uml_ch_source >> 6) & 0X3F));
         if (achl_cur_target >= achl_end_target) return -1;  /* output area too short */
         *achl_cur_target++ = (0X80 | (uml_ch_source & 0X3F));
         break;
       }
       if ((uml_ch_source >> 21) == 0) {
         *achl_cur_target++ = 0XF0 | (uml_ch_source >> 18);
         if (achl_cur_target >= achl_end_target) return -1;  /* output area too short */
         *achl_cur_target++ = (0X80 | ((uml_ch_source >> 12) & 0X3F));
         if (achl_cur_target >= achl_end_target) return -1;  /* output area too short */
         *achl_cur_target++ = (0X80 | ((uml_ch_source >> 6) & 0X3F));
         if (achl_cur_target >= achl_end_target) return -1;  /* output area too short */
         *achl_cur_target++ = (0X80 | (uml_ch_source & 0X3F));
         break;
       }
       if ((uml_ch_source >> 26) == 0) {
         *achl_cur_target++ = 0XF8 | (uml_ch_source >> 24);
         if (achl_cur_target >= achl_end_target) return -1;  /* output area too short */
         *achl_cur_target++ = (0X80 | ((uml_ch_source >> 18) & 0X3F));
         if (achl_cur_target >= achl_end_target) return -1;  /* output area too short */
         *achl_cur_target++ = (0X80 | ((uml_ch_source >> 12) & 0X3F));
         if (achl_cur_target >= achl_end_target) return -1;  /* output area too short */
         *achl_cur_target++ = (0X80 | ((uml_ch_source >> 6) & 0X3F));
         if (achl_cur_target >= achl_end_target) return -1;  /* output area too short */
         *achl_cur_target++ = (0X80 | (uml_ch_source & 0X3F));
         break;
       }
       if ((uml_ch_source >> 31) == 0) {
         *achl_cur_target++ = 0XFC | (uml_ch_source >> 30);
         if (achl_cur_target >= achl_end_target) return -1;  /* output area too short */
         *achl_cur_target++ = (0X80 | ((uml_ch_source >> 24) & 0X3F));
         if (achl_cur_target >= achl_end_target) return -1;  /* output area too short */
         *achl_cur_target++ = (0X80 | ((uml_ch_source >> 18) & 0X3F));
         if (achl_cur_target >= achl_end_target) return -1;  /* output area too short */
         *achl_cur_target++ = (0X80 | ((uml_ch_source >> 12) & 0X3F));
         if (achl_cur_target >= achl_end_target) return -1;  /* output area too short */
         *achl_cur_target++ = (0X80 | ((uml_ch_source >> 6) & 0X3F));
         if (achl_cur_target >= achl_end_target) return -1;  /* output area too short */
         *achl_cur_target++ = (0X80 | (uml_ch_source & 0X3F));
         break;
       }
       return -1;                           /* character undefined     */
     case ied_chs_html_1:                   /* HTML character set      */
       bol1 = FALSE;                        /* character not copied    */
       if (uml_ch_source < 0X80) {          /* may be a single character */
         switch (uml_ch_source) {           /* check special values    */
           case 0X22:                       /* chrs_html_quote         */
             break;                         /* set in string           */
           case 0X26:                       /* chrs_html_amp           */
             break;                         /* set in string           */
           case 0X3C:                       /* chrs_html_lt            */
             break;                         /* set in string           */
           case 0X3E:                       /* chrs_html_gt            */
             break;                         /* set in string           */
           default:
             *achl_cur_target++ = (unsigned char) uml_ch_source;
             bol1 = TRUE;                   /* character has been copied */
             break;
         }
       }
       if (bol1) break;                     /* all done                */
       iml1 = m_put_html_1_a( achl_cur_target, achl_end_target, uml_ch_source );
       if (iml1 < 0) return -1;             /* output area too small   */
       achl_cur_target += iml1;             /* increment pointer output */
       break;                               /* all done                */
     case ied_chs_uri_1:                    /* URI RFC 3986            */
       if (   ((uml_ch_source >> 7) == 0)   /* only 7 bits - < 0X80    */
           && (chrs_uri_1_tab[ uml_ch_source ] == 0)) {  /* not reserved */
         *achl_cur_target++ = (unsigned char) uml_ch_source;
         break;
       }
       iml1 = m_put_uri_1_a( achl_cur_target, achl_end_target, uml_ch_source, '%' );
       if (iml1 < 0) return -1;             /* output area too small   */
       achl_cur_target += iml1;             /* increment pointer output */
       break;                               /* all done                */
     case ied_chs_hsf_1:                    /* HOB special file system */
       if (   ((uml_ch_source >> 7) == 0)   /* only 7 bits - < 0X80    */
           && (chrs_non09az_tab[ uml_ch_source ] == 0)) {  /* not reserved */
         *achl_cur_target++ = (unsigned char) uml_ch_source;
         break;
       }
       iml1 = m_put_uri_1_a( achl_cur_target, achl_end_target, uml_ch_source, '_' );
       if (iml1 < 0) return -1;             /* output area too small   */
       achl_cur_target += iml1;             /* increment pointer output */
       break;                               /* all done                */
     case ied_chs_idna_1:                   /* IDNA RFC 3490 - Punycode */
       if (uml_ch_source < 0x7B) {          /* maybe unchanged char    */
         if (--iml_idna_labelspace == 0) {  /* over RFC 1034 maxlength */
           if (uml_ch_source != 0x2E)       /* last-chance part-end?   */
             return -1;
         }                   /* (limiting also precludes int overflow) */
         inl_idna_prevccc = 0;              /* all these have ccc of 0 */
         unl_prevstrt = uml_ch_source;      /* no test, as NFC_QC is Y */
         if (uml_ch_source > 0x60) {        /* lcase ASCII, unchanged  */
           *achl_cur_target++ = (unsigned char) uml_ch_source;
           break;
         }
         if (uml_ch_source >= 0x30) {       /* maybe ASCII digit       */
           if (uml_ch_source < 0x3A) {      /* ASCII digit, unchanged  */
             *achl_cur_target++ = (unsigned char) uml_ch_source;
             break;
           }
           if (bol_idna_nohighyet) {        /* permit IPv6 addresses etc. */
             *achl_cur_target++ = (unsigned char) uml_ch_source;
             iep_cs_target = IED_CHS_COPY7A;
             break;
           }
           return -1;                       /* prohibited ASCII char   */
         } else {
           if (uml_ch_source == 0x2D) {     /* hyphen-minus, unchanged */
             switch (MAX_IDNAPART_LENGTH-iml_idna_labelspace) {
               case 2:
                 iel_idna_minuspair = 1;
                 break;
               case 3:
                 if (iel_idna_minuspair) {
                   if (utl_idna_tn)
                     return -1;             /* already non-ASCII at [0] or [1] */
                   iel_idna_minuspair = 2;
                 }
                 break;
               default:                     /* ignore at /^..--/-detection */
                 break;
             }
             *achl_cur_target++ = (unsigned char) uml_ch_source;
             break;
           }
           if (uml_ch_source == 0x2E) {     /* dot, begin new part     */
             goto p_next_idnlbl;
           }
           if (bol_idna_nohighyet) {        /* permit IPv6 addresses etc. */
             *achl_cur_target++ = (unsigned char) uml_ch_source;
             iep_cs_target = IED_CHS_COPY7A;
             break;
           }
           return -1;                       /* prohibited ASCII char   */
         }
       } else {                             /* not an unchanged char   */
         if (iel_idna_minuspair) {
           if (iel_idna_minuspair == 1)
             iel_idna_minuspair = 0;        /* '-' only at [2], not at [3] */
            else
             return -1;                     /* label must be ASCII, "--"-rule */
         }
         switch (uml_ch_source) {           /* check for part end end CONTEXTJ cases */
           case 0x200C:                     /* ZERO WIDTH NON-JOINER   */
             if (utl_idna_tn==0)
               return -1;                   /* cannot fulfil either rule */
             if (utl_idna_openzwnj) {       /* still earlier one unclear, check that first */
               if (!m_idna_zwnj_jtrule_ok( dslr_idna_treelist, utl_idna_openzwnj, utl_idna_tn ))
                 return -1;                 /* earlier zwnj not conforming */
             }
             if (inl_idna_prevccc == 9) {   /* previous char is virama */
               utl_idna_openzwnj = 0;
               /* virama rule fulfilled, joiningtype not checked       */
             } else {                       /* must fulfil joiningtype rule */
               /* the rule would be complicated to test now, so it is tested on label end or
                  next zwnj, as this is probably too rare to check utl_idna_openzwnj often */
               utl_idna_openzwnj = utl_idna_tn;
             }
             inl_idna_prevccc = 0;          /* U+200C has ccc of 0     */
             break;
           case 0x200D:                     /* ZERO WIDTH JOINER       */
             if (inl_idna_prevccc != 9)     /* previous char no virama */
               return -1;                   /* failed CONTEXTJ rule    */
             inl_idna_prevccc = 0;          /* U+200D has ccc of 0     */
             break;                         /* virama rule fulfilled   */
           case 0x3002:   /* dots, see RFC 3490, section 3.1, number 1 */
           case 0xFF0E:
           case 0xFF61:                     /* begin new part          */
             goto p_next_idnlbl;
           default:
             if (!m_is_idna_allowed(uml_ch_source))
               return -1;                   /* prohibited non-ASCII char */
             iml1 = m_get_unicode_canonical_combining_class(uml_ch_source);
             if (iml1 && (iml1 < inl_idna_prevccc))
               return -1;                   /* cannot be in NFC form   */
             inl_idna_prevccc = iml1;
             if (m_idna_cannotbe_nfc(unl_prevstrt, uml_ch_source))
               return -1;                   /* cannot be in NFC form   */
             if (!iml1)                     /* remember "starter"      */
               unl_prevstrt = uml_ch_source;
             break;
         }
       }
       /* store character in tree for later punycode representation    */
       if (--iml_idna_labelspace == 0)      /* over RFC 1034 maxlength */
         return -1;                         /* (limiting also precludes int overflow) */
       if ((iml_idna_labelspace==MAX_IDNAPART_LENGTH) && m_get_unicode_is_combining(uml_ch_source))
         return -1;                         /* combining mark as first in label */
       if (!utl_idna_tn) {                  /* first non-ASCII in this part*/
         bol_idna_nohighyet = FALSE;
         if (achl_cur_target+5 >= achl_end_target)
           return -1;                       /* output area too small   */
         /* prepend prefix to what we already have translated to ASCII */
         memmove( achl_idna_ps+4, achl_idna_ps, achl_cur_target-achl_idna_ps );
         memcpy( achl_idna_ps, "xn--", 4 );
         achl_cur_target += 4;
       }
       m_idna_add_to_treelist( dslr_idna_treelist, uml_ch_source, utl_idna_tn ++,
                               MAX_IDNAPART_LENGTH-iml_idna_labelspace );
       break;
       p_next_idnlbl:                       /* next dot-separated part */
       if (utl_idna_tn) {                   /* last part had non-ASCII */
         if (utl_idna_openzwnj &&
             !m_idna_zwnj_jtrule_ok( dslr_idna_treelist, utl_idna_openzwnj, utl_idna_tn ))
           return -1;                       /* earlier U+200C not conforming */
         achl_cur_target = m_idna_encode_utree( dslr_idna_treelist,
                           achl_cur_target-(achl_idna_ps+4),
                           achl_cur_target,
                           achl_end_target<=achl_idna_ps+MAX_IDNAPART_LENGTH
                                          ? achl_end_target
                                          : achl_idna_ps+MAX_IDNAPART_LENGTH
                           );
         if ((achl_cur_target == NULL) || (achl_cur_target >= achl_end_target))
           return -1;                       /* target overflow         */
       }
       *achl_cur_target++ = (unsigned char) '.';
       achl_idna_ps = achl_cur_target;
       iml_idna_labelspace = 1+MAX_IDNAPART_LENGTH;
       utl_idna_openzwnj = 0;
       iel_idna_minuspair = 0;
       inl_idna_prevccc = 255;
       unl_prevstrt = 0;
       utl_idna_tn = 0;
       break;
     case IED_CHS_COPY7A:                   /* idna-prohibited ascii   */
       if (uml_ch_source > 'z')
         return -1;  /* neither IDNA nor something like a IPv6-address */
       *((unsigned char *) achl_cur_target) = (unsigned char) uml_ch_source;
       achl_cur_target++;                   /* output one character    */
       break;
     case ied_chs_xml_utf_16:               /* UTF-16 with XML-CharRef */
       if (iel_xcro_st < 0) {               /* no entity-encode runs   */
         /* shortest encoding is preferred, hex (no div ops) if equal  */
         if (uml_ch_source < 0xE000)
           if (uml_ch_source < 0xA0)
             iel_xcro_st = chrs_xmlent_st[uml_ch_source];
           else                             /* 00A0                    */
             { if (uml_ch_source >= 0xD800) iel_xcro_st = 1; }
         else                               /* E000                    */
           if (uml_ch_source < 0xFDF0)
             { if (uml_ch_source >= 0xFDD0) iel_xcro_st = 1; }
           else                             /* FDF0                    */
             { if (((uml_ch_source&0xFFFE)==0xFFFE) && (uml_ch_source<0x110000)) iel_xcro_st = 1; }
       }
       if (iel_xcro_st >= 0) {              /* entity-encode runs now  */
         switch ((enum ied_xcro_st)iel_xcro_st) {
           case ied_xcro_hex_start:
           case ied_xcro_dec_start:
             uml_read_ch_source = uml_ch_source;
             uml_ch_source = 0x26;          /* '&', next: '#'          */
             iel_xcro_st ++;
             break;
           case ied_xcro_dec_carpet:
             uml_ch_source = 0x23;          /* '#', next: the number   */
             iel_xcro_st = (int)ied_xcro_dec_10;
             break;
           case ied_xcro_hex_carpet:
             uml_ch_source = 0x23;          /* '#', next: 'x'          */
             iel_xcro_st ++;
             break;
           case ied_xcro_hex_x:
             uml_ch_source = 0x78;          /* 'x', next: the number   */                 
             iel_xcro_st = (int)ied_xcro_hex_F00000;
             while (uml_read_ch_source >> iel_xcro_st == 0)
               iel_xcro_st -= 4;    /* will hang if called with U+0000 */
             break;
           case ied_xcro_txt_start_lt:
             achl_xenm = chrs_html_lt;      /* use entity name "lt"    */
             uml_ch_source = 0x26;          /* '&', next: name chars   */
             iel_xcro_st = (int)ied_xcro_txt;
             break;
           case ied_xcro_txt_start_gt:
             achl_xenm = chrs_html_gt;      /* use entity name "gt"    */
             uml_ch_source = 0x26;          /* '&', next: name chars   */
             iel_xcro_st = (int)ied_xcro_txt;
             break;
           case ied_xcro_txt:               /* char from achl_xenm     */
             uml_ch_source = *achl_xenm++;
             if (*achl_xenm == 0)
               iel_xcro_st = (int)ied_xcro_endchar;
             break;
           case ied_xcro_endchar:
             uml_ch_source = 0x3B;          /* ';'                     */
             iel_xcro_st = ied_xcro_after_end;
             break;
           case ied_xcro_after_end:
             iel_xcro_st = -1;              /* copy from source again  */
             achl_cur_source += iml_len_ch_source;
             goto pcpy_00;                  /* leave this codepart     */
           case ied_xcro_dec_10:
             uml_ch_source = uml_read_ch_source / 10;          
             if (uml_ch_source != 0) {
               uml_read_ch_source -= 10 * uml_ch_source;          
               uml_ch_source += 0x30;       /* '0'-based decimal char  */
               iel_xcro_st --;              /* next: ied_xcro_dec_01   */
               break;
             }                              /* else fall through       */
           case ied_xcro_dec_01:
             uml_ch_source = uml_read_ch_source + 0x30;
             iel_xcro_st = (int)ied_xcro_endchar;
             break;
           case ied_xcro_hex_00000F:
             uml_ch_source = uml_read_ch_source & 0xF;
             uml_ch_source += (uml_ch_source<10 ? 0x30 : 0x37);
             iel_xcro_st = (int)ied_xcro_endchar;
             break;
           default:    /* ied_xcro_hex_0000F0, ... ied_xcro_hex_F00000 */
             uml_ch_source = (uml_read_ch_source >> iel_xcro_st) & 0xF;
             uml_ch_source += (uml_ch_source<10 ? 0x30 : 0x37);
             iel_xcro_st -= 4;
             break;
         }
         *((HL_WCHAR *) achl_cur_target) = (HL_WCHAR) uml_ch_source;
         achl_cur_target += sizeof(HL_WCHAR);
         goto pcpy_20;
       }                                    /* else case-fall-through  */
     case ied_chs_utf_16:                   /* Unicode UTF-16 = WCHAR  */
       if (uml_ch_source >= 0X10000) {      /* over 16-bit, needs surrogates */
         uml_ch_source -= 0X10000;
         if (uml_ch_source & ~0xFFFFF) {    /* over 0x10FFFF, not possible */
           *((HL_WCHAR *) achl_cur_target) = UTF16_REP_CHAR;
         } else {
           *((HL_WCHAR *) achl_cur_target) = (HL_WCHAR)(0xD800 | (uml_ch_source >> 10));
           achl_cur_target += sizeof(HL_WCHAR);
           if (achl_cur_target >= achl_end_target)
             return -1;                     /* target overflow         */
           *((HL_WCHAR *) achl_cur_target) = (HL_WCHAR)(0xDC00 | (uml_ch_source & 0x03FF));
         }
       } else {                             /* 16-bit is enough        */
         *((HL_WCHAR *) achl_cur_target) = (HL_WCHAR) uml_ch_source;
       }
       achl_cur_target += sizeof(HL_WCHAR);
       break;
     case ied_chs_be_utf_16:                /* Unicode UTF-16 big endian */
       if (uml_ch_source >= 0X10000) {      /* over 16-bit, needs surrogates */
         uml_ch_source -= 0X10000;
         if (uml_ch_source & ~0xFFFFF) {    /* over 0x10FFFF, not possible */
           *((unsigned char *) achl_cur_target + 0) = (unsigned char) (UTF16_REP_CHAR >> 8);
           *((unsigned char *) achl_cur_target + 1) = (unsigned char) UTF16_REP_CHAR;
           achl_cur_target += sizeof(HL_WCHAR);
           break;
         }
         if (achl_cur_target+4 > achl_end_target)
           return -1;                       /* target overflow         */
         *((unsigned char *) achl_cur_target + 0) = (unsigned char) (0xD8 | (3 & (uml_ch_source >> 18)));
         *((unsigned char *) achl_cur_target + 1) = (unsigned char) (uml_ch_source >> 10);
         *((unsigned char *) achl_cur_target + 2) = (unsigned char) (0xDC | (3 & (uml_ch_source >> 8)));
         *((unsigned char *) achl_cur_target + 3) = (unsigned char) uml_ch_source;
         achl_cur_target += 2 * sizeof(HL_WCHAR);
       } else {                             /* 16-bit is enough        */
         *((unsigned char *) achl_cur_target + 0) = (unsigned char) (uml_ch_source >> 8);
         *((unsigned char *) achl_cur_target + 1) = (unsigned char) uml_ch_source;
         achl_cur_target += sizeof(HL_WCHAR);
       }
       break;
     case ied_chs_le_utf_16:                /* Unicode UTF-16 little endian */
       if (uml_ch_source >= 0X10000) {      /* over 16-bit, needs surrogates */
         uml_ch_source -= 0X10000;
         if (uml_ch_source & ~0xFFFFF) {    /* over 0x10FFFF, not possible */
           *((unsigned char *) achl_cur_target + 0) = (unsigned char) UTF16_REP_CHAR;
           *((unsigned char *) achl_cur_target + 1) = (unsigned char) (UTF16_REP_CHAR >> 8);
           achl_cur_target += sizeof(HL_WCHAR);
           break;
         }
         if (achl_cur_target+4 > achl_end_target)
           return -1;                       /* target overflow         */
         *((unsigned char *) achl_cur_target + 0) = (unsigned char) (uml_ch_source >> 10);
         *((unsigned char *) achl_cur_target + 1) = (unsigned char) (0xD8 | (3 & (uml_ch_source >> 18)));
         *((unsigned char *) achl_cur_target + 2) = (unsigned char) uml_ch_source;
         *((unsigned char *) achl_cur_target + 3) = (unsigned char) (0xDC | (3 & (uml_ch_source >> 8)));
         achl_cur_target += 2 * sizeof(HL_WCHAR);
       } else {                             /* 16-bit is enough        */
         *((unsigned char *) achl_cur_target + 0) = (unsigned char) uml_ch_source;
         *((unsigned char *) achl_cur_target + 1) = (unsigned char) (uml_ch_source >> 8);
         achl_cur_target += sizeof(HL_WCHAR);
       }
       break;
     case ied_chs_utf_32:                   /* Unicode UTF-32          */
       *((unsigned int *) achl_cur_target) = (unsigned int) uml_ch_source;
       achl_cur_target += sizeof(unsigned int);
       break;
     case ied_chs_be_utf_32:                /* Unicode UTF-32 big endian */
       *((unsigned char *) achl_cur_target + 0) = (unsigned char) (uml_ch_source >> 24);
       *((unsigned char *) achl_cur_target + 1) = (unsigned char) (uml_ch_source >> 16);
       *((unsigned char *) achl_cur_target + 2) = (unsigned char) (uml_ch_source >> 8);
       *((unsigned char *) achl_cur_target + 3) = (unsigned char) uml_ch_source;
       achl_cur_target += sizeof(unsigned int);
       break;
     case ied_chs_le_utf_32:                /* Unicode UTF-32 little endian */
       *((unsigned char *) achl_cur_target + 0) = (unsigned char) uml_ch_source;
       *((unsigned char *) achl_cur_target + 1) = (unsigned char) (uml_ch_source >> 8);
       *((unsigned char *) achl_cur_target + 2) = (unsigned char) (uml_ch_source >> 16);
       *((unsigned char *) achl_cur_target + 3) = (unsigned char) (uml_ch_source >> 24);
       achl_cur_target += sizeof(unsigned int);
       break;
     default:
       return -1;                           /* cannot copy             */
   }
   achl_cur_source += iml_len_ch_source;
   goto pcpy_00;                            /* copy characters         */
} /* end m_cpy_lc_vx_vx()                                              */

/** copy string to uppercase
*  @param ap_target destination (output) pointer
*  @param imp_len_target length of output buffer, in 8/16/32-bit units
*  @param iep_cs_target encoding to use for output
*  @param ap_source pointer to original string (input)
*  @param imp_len_source anything negative means the input is zero-terminated,
*                        else length of original string in 8/16/32-bit units
*  @param iep_cs_source encoding used by original string
*  @param ibp_flags special flags (use the wrapper macro m_cpy_uc_vx_vx instead
*                   of this function to ignore this param and use the defaults).
*                   If flag D_CPYVXVX_FL_NOTAIL0 is set, will not zero-terminate
*  @return -1 on error, else length of output (in 8/16/32-bit units depending on
*          iep_cs_target), excluding the terminating zero
*/
extern PTYPE int m_cpy_uc_vx_vx_fl( void *ap_target,
                                  int imp_len_target,
                                  enum ied_charset iep_cs_target,
                                  const void *ap_source,
                                  int imp_len_source,
                                  enum ied_charset iep_cs_source,
                                  unsigned int ibp_flags ) {
   BOOL          bol1;                      /* working-variable        */
   int           iml1;                      /* working-variable        */
   const char    *achl_cur_source;          /* current position parameter */
   char          *achl_cur_target;          /* current position parameter */
   const char    *achl_end_source;          /* end of parameter        */
   char          *achl_end_target;          /* end of parameter        */
   unsigned int  uml_ch_source;             /* character decoded       */
   int           iml_len_ch_source;         /* length of parameter     */
   HL_WCHAR      *awcl_dbcsenc;             /* dbcs encoding table     */
   struct dsd_idna_upoint dslr_idna_treelist[MAX_IDNAPART_LENGTH];  /* non-ascii data */
   unsigned char utl_idna_tn;               /* length for dsd_idna_upoint */
   char          *achl_idna_ps;             /* target start of current label */
   int           iml_idna_labelspace;       /* rest of RFC 1034 maxlen */
   unsigned char utl_idna_openzwnj;         /* U+200C yet to be accepted (RFC 5892 A.1.) */
   /* variables for tests required for IDNA target by RFC 5891 5.4.    */
   int           iel_idna_minuspair;        /* detect labels starting with "..--" */
   BOOL          bol_idna_nohighyet;        /* only <='z' in all labels so far */
   int           inl_idna_prevccc;          /* canonical combining class */
   unsigned int  unl_prevstrt;              /* last char with ccc == 0 */
   /* variables for multi-char XML-reference instead of copying source */
   int           iel_xcro_st;               /* state, -1 or enum ied_xcro_st */
   unsigned int  uml_read_ch_source;        /* original character decoded */
   char          *achl_xenm;                /* next entity-name char   */

#ifdef CHECK_HTML
   int        iml2;                         /* working variable        */
   iml1 = sizeof(dsrs_sort_html_alpha) / sizeof(dsrs_sort_html_alpha[0]) - 1;
   do {
     iml1--;
     iml2 = strcmp( dsrs_sort_html_alpha[ iml1 ].achc_char,
                    dsrs_sort_html_alpha[ iml1 + 1 ].achc_char );
     if (iml2 >= 0) {
       printf( "xslunic1-l%05d-E invalid sort sequence dsrs_sort_html_alpha element %d.\n",
               __LINE__, iml1 );
       return -1;
     }
   } while (iml1 > 0);
#endif
   if (imp_len_target <= 0) return -1;
   /* calculate end of parameter target                                */
   achl_cur_target = (char *) ap_target;
   switch (iep_cs_target) {
     case ied_chs_ascii_850:                /* ASCII 850               */
     case ied_chs_ansi_819:                 /* ANSI 819                */
     case ied_chs_wcp_1256:                 /* Windows-Codepage 1256   */
     case ied_chs_iso8859_2:                /* ISO 8859-2              */
     case ied_chs_iso8859_4:                /* ISO 8859-4              */
     case ied_chs_iso8859_5:                /* ISO 8859-5              */
     case ied_chs_iso8859_9:                /* ISO 8859-9              */
     case ied_chs_iso8859_10:               /* ISO 8859-10             */
     case ied_chs_iso8859_13:               /* ISO 8859-13             */
     case ied_chs_iso8859_14:               /* ISO 8859-14             */
     case ied_chs_iso8859_15:               /* ISO 8859-15             */
     case ied_chs_iso8859_16:               /* ISO 8859-16             */
     case ied_chs_oem_437:                  /* DOS-Codepage 437        */
     case ied_chs_wcp_874:                  /* Windows-Codepage  874   */
     case ied_chs_wcp_1250:                 /* Windows-Codepage 1250   */
     case ied_chs_wcp_1251:                 /* Windows-Codepage 1251   */
     case ied_chs_wcp_1252:                 /* Windows-Codepage 1252   */
     case ied_chs_wcp_1253:                 /* Windows-Codepage 1253   */
     case ied_chs_wcp_1254:                 /* Windows-Codepage 1254   */
     case ied_chs_wcp_1255:                 /* Windows-Codepage 1255   */
     case ied_chs_wcp_1257:                 /* Windows-Codepage 1257   */
     case ied_chs_wcp_1258:                 /* Windows-Codepage 1258   */
     case ied_chs_iso8859_3:                /* ISO 8859-3              */
     case ied_chs_iso8859_6:                /* ISO 8859-6              */
     case ied_chs_iso8859_7:                /* ISO 8859-7              */
     case ied_chs_iso8859_8:                /* ISO 8859-8              */
     case ied_chs_iso8859_11:               /* ISO 8859-11             */
     case ied_chs_utf_8:                    /* Unicode UTF-8           */
     case ied_chs_html_1:                   /* HTML character set      */
     case ied_chs_uri_1:                    /* URI, percent-encoded    */
     case ied_chs_hsf_1:                    /* HOB special file system */
       achl_end_target = ((char *) ap_target) + imp_len_target;
       break;
     case ied_chs_ldap_escaped_utf_8:       /* LDAP UTF-8 escaped      */
       bol1 = TRUE;                         /* yet awaiting first '='  */
       achl_end_target = ((char *) ap_target) + imp_len_target;
       break;
     case ied_chs_xml_utf_8:                /* UTF-8 with XML-CharRef  */
     case ied_chs_xml_wcp_1252:             /* Windows-1252 with XML-CharRef */
       iel_xcro_st = -1;
       achl_end_target = ((char *) ap_target) + imp_len_target;
       break;
     case ied_chs_idna_1:                   /* IDNA RFC 3490 - Punycode */
       achl_idna_ps = achl_cur_target;
       iml_idna_labelspace = 1+MAX_IDNAPART_LENGTH;
       utl_idna_openzwnj = 0;        /* =none, at 0 would not be legal */
       iel_idna_minuspair = 0;
       bol_idna_nohighyet = TRUE;
       inl_idna_prevccc = 255;
       unl_prevstrt = 0;
       utl_idna_tn = 0;
       achl_end_target = ((char *) ap_target) + imp_len_target;
       break;
     CASE_IED_CHS_ALL_CJK
       awcl_dbcsenc = m_get_tab_uni_to_mb(iep_cs_target);
       achl_end_target = ((char *) ap_target) + imp_len_target;
       break;
     case ied_chs_xml_utf_16:               /* UTF-16 with XML-CharRef */
       iel_xcro_st = -1;                    /* and fall through        */
     CASE_IED_CHS_U16_ALLENDIAN
       achl_end_target = ((char *) ap_target) + imp_len_target * sizeof(HL_WCHAR);
       break;
     CASE_IED_CHS_U32_ALLENDIAN
       achl_end_target = ((char *) ap_target) + imp_len_target * sizeof(unsigned int);
       break;
     default:
       return -1;                           /* cannot copy             */
   }
   /* calculate end of parameter source                                */
   achl_cur_source = (const char *) ap_source;
   achl_end_source = NULL;                  /* still zero-terminated   */
   if (imp_len_source >= 0) {               /* length source given     */
     switch (iep_cs_source) {
       case ied_chs_ascii_850:              /* ASCII 850               */
       case ied_chs_ansi_819:               /* ANSI 819                */
       CASE_IED_CHS_MISCCODEPAGES
       CASE_IED_CHS_ALL_CJK
       CASE_IED_CHS_ISO8859_2TO16
       CASE_IED_CHS_ESCHEXHEX_U8
       case ied_chs_utf_8:                  /* Unicode UTF-8           */
       case ied_chs_xml_utf_8:              /* UTF-8 with XML-CharRef  */
       case ied_chs_xml_wcp_1252:           /* Windows-1252 with XML-CharRef */
       case ied_chs_html_1:                 /* HTML character set      */
         achl_end_source = ((const char *) ap_source) + imp_len_source;
         break;
       CASE_IED_CHS_U16_ALLENDIAN
       case ied_chs_xml_utf_16:             /* UTF-16 with XML-CharRef */
         achl_end_source = ((const char *) ap_source) + imp_len_source * sizeof(HL_WCHAR);
         break;
       CASE_IED_CHS_U32_ALLENDIAN
         achl_end_source = ((const char *) ap_source) + imp_len_source * sizeof(unsigned int);
         break;
       default:
         return -1;                         /* cannot copy             */
     }
   }

   pcpy_00:                                 /* copy characters         */
   iml_len_ch_source = m_get_vc_ch( &uml_ch_source, achl_cur_source, achl_end_source, iep_cs_source );
   if (iml_len_ch_source <= 0) {            /* subroutine reported end or error */
     if (iml_len_ch_source == 0) {          /* end of input found      */
       switch (iep_cs_target) {
         case ied_chs_idna_1:               /* IDNA RFC 3490 - Punycode */
           if (utl_idna_tn) {               /* last part had non-ASCII */
             if (utl_idna_openzwnj &&
                 !m_idna_zwnj_jtrule_ok( dslr_idna_treelist, utl_idna_openzwnj, utl_idna_tn ))
               return -1;                   /* earlier U+200C not conforming */
             /* encode the non-ascii chars of the last part            */
             achl_cur_target = m_idna_encode_utree( dslr_idna_treelist,
                               achl_cur_target-(achl_idna_ps+4),
                               achl_cur_target,
                               achl_end_target<=achl_idna_ps+MAX_IDNAPART_LENGTH
                                              ? achl_end_target
                                              : achl_idna_ps+MAX_IDNAPART_LENGTH
                               );
             if ((achl_cur_target == NULL) || (achl_cur_target >= achl_end_target))
               return -1;                   /* target overflow         */
           }                                /* fall through            */
         case IED_CHS_COPY7A:               /* idna-prohibited ascii   */
         case ied_chs_ascii_850:            /* ASCII 850               */
         case ied_chs_ansi_819:             /* ANSI 819                */
         CASE_IED_CHS_MISCCODEPAGES
         CASE_IED_CHS_ALL_CJK
         CASE_IED_CHS_ISO8859_2TO16
         CASE_IED_CHS_ESCHEXHEX_U8
         case ied_chs_utf_8:                /* Unicode UTF-8           */
         case ied_chs_xml_utf_8:            /* UTF-8 with XML-CharRef  */
         case ied_chs_xml_wcp_1252:         /* Windows-1252 with XML-CharRef */
         case ied_chs_html_1:               /* HTML character set      */
           if ((ibp_flags & D_CPYVXVX_FL_NOTAIL0) == 0) {
             if (achl_cur_target >= achl_end_target) return -1;  /* output area too short */
             *achl_cur_target = 0;          /* make zero-terminated    */
           }
           return achl_cur_target - (char *) ap_target;
         case ied_chs_utf_16:               /* Unicode UTF-16 = WCHAR  */
         case ied_chs_xml_utf_16:           /* UTF-16 with XML-CharRef */
           if ((ibp_flags & D_CPYVXVX_FL_NOTAIL0) == 0) {
             if (achl_cur_target+sizeof(HL_WCHAR) > achl_end_target) return -1;  /* too short */
             *((HL_WCHAR *) achl_cur_target) = 0;  /* make zero-terminated */
           }
           return (achl_cur_target - (char *) ap_target) / sizeof(HL_WCHAR);
         case ied_chs_be_utf_16:            /* Unicode UTF-16 big endian */
         case ied_chs_le_utf_16:            /* Unicode UTF-16 little endian */
           if ((ibp_flags & D_CPYVXVX_FL_NOTAIL0) == 0) {
             if (achl_cur_target+2 > achl_end_target) return -1;  /* output area too short */
             *((char  *) achl_cur_target + 0) = 0;  /* make zero-terminated */
             *((char  *) achl_cur_target + 1) = 0;  /* make zero-terminated */
           }
           return (achl_cur_target - (char *) ap_target) / sizeof(HL_WCHAR);
         case ied_chs_utf_32:               /* Unicode UTF-32          */
           if ((ibp_flags & D_CPYVXVX_FL_NOTAIL0) == 0) {
             if (achl_cur_target+sizeof(unsigned int) > achl_end_target) return -1;  /* too short */
             *((unsigned int *) achl_cur_target) = 0;  /* make zero-terminated */
           }
           return (achl_cur_target - (char *) ap_target) / sizeof(unsigned int);
         case ied_chs_be_utf_32:            /* Unicode UTF-32 big endian */
         case ied_chs_le_utf_32:            /* Unicode UTF-32 little endian */
           if ((ibp_flags & D_CPYVXVX_FL_NOTAIL0) == 0) {
             if (achl_cur_target+4 > achl_end_target) return -1;  /* output area too short */
             *((char  *) achl_cur_target + 0) = 0;  /* make zero-terminated */
             *((char  *) achl_cur_target + 1) = 0;  /* make zero-terminated */
             *((char  *) achl_cur_target + 2) = 0;  /* make zero-terminated */
             *((char  *) achl_cur_target + 3) = 0;  /* make zero-terminated */
           }
           return (achl_cur_target - (char *) ap_target) / sizeof(unsigned int);
         default:
           return -1;                       /* error                   */
       }
     }
     return -1;                             /* return error            */
   }
   pcpy_20:                                 /* output characters       */
   if (achl_cur_target >= achl_end_target) return -1;  /* output area too short */
   uml_ch_source = m_trans_32_to_uc( uml_ch_source );  /* translate to upper case */
   switch (iep_cs_target) {
     case ied_chs_ascii_850:                /* ASCII 850               */
       if (uml_ch_source < 0X0100) {
         *((unsigned char *) achl_cur_target) = (unsigned char) ucrg_tab_819_to_850[ uml_ch_source ];
       } else {
         *achl_cur_target = '?';
       }
       achl_cur_target++;                   /* output one character    */
       break;
     case ied_chs_ansi_819:                 /* ANSI 819                */
       if (uml_ch_source < 0X0100) {
         *((unsigned char *) achl_cur_target) = (unsigned char) uml_ch_source;
       } else {
         *achl_cur_target = '?';
       }
       achl_cur_target++;                   /* output one character    */
       break;
     case ied_chs_oem_437:                  /* DOS-Codepage 437        */
       *((unsigned char *) achl_cur_target) = (unsigned char) m_u32c_to_437( uml_ch_source );
       achl_cur_target++;                   /* output one character    */
       break;
     case ied_chs_wcp_874:                  /* Windows-Codepage  874   */
       *((unsigned char *) achl_cur_target) = (unsigned char) m_u32c_to_874( uml_ch_source );
       achl_cur_target++;                   /* output one character    */
       break;
     case ied_chs_wcp_1250:                 /* Windows-Codepage 1250   */
       *((unsigned char *) achl_cur_target) = (unsigned char) m_u32c_to_1250( uml_ch_source );
       achl_cur_target++;                   /* output one character    */
       break;
     case ied_chs_wcp_1251:                 /* Windows-Codepage 1251   */
       *((unsigned char *) achl_cur_target) = (unsigned char) m_u32c_to_1251( uml_ch_source );
       achl_cur_target++;                   /* output one character    */
       break;
     case ied_chs_xml_wcp_1252:             /* Windows-1252 with XML-CharRef */
       if (iel_xcro_st < 0) {               /* no entity-encode runs   */
         /* shortest encoding is preferred, hex (no div ops) if equal  */
         /* over 0x7F either ASCII_REP_CHAR or no need to XML-encode   */
         if (uml_ch_source < 0x80)
           iel_xcro_st = chrs_xmlent_st[uml_ch_source];
       }
       if (iel_xcro_st >= 0) {              /* entity-encode runs now  */
         switch ((enum ied_xcro_st)iel_xcro_st) {
           case ied_xcro_hex_start:
           case ied_xcro_dec_start:
             uml_read_ch_source = uml_ch_source;
             uml_ch_source = 0x26;          /* '&', next: '#'          */
             iel_xcro_st ++;
             break;
           case ied_xcro_dec_carpet:
             uml_ch_source = 0x23;          /* '#', next: the number   */
             iel_xcro_st = (int)ied_xcro_dec_10;
             break;
           case ied_xcro_hex_carpet:
             uml_ch_source = 0x23;          /* '#', next: 'x'          */
             iel_xcro_st ++;
             break;
           case ied_xcro_hex_x:
             uml_ch_source = 0x78;          /* 'x', next: the number   */                 
             iel_xcro_st = (int)ied_xcro_hex_F00000;
             while (uml_read_ch_source >> iel_xcro_st == 0)
               iel_xcro_st -= 4;    /* will hang if called with U+0000 */
             break;
           case ied_xcro_txt_start_lt:
             achl_xenm = chrs_html_lt;      /* use entity name "lt"    */
             uml_ch_source = 0x26;          /* '&', next: name chars   */
             iel_xcro_st = (int)ied_xcro_txt;
             break;
           case ied_xcro_txt_start_gt:
             achl_xenm = chrs_html_gt;      /* use entity name "gt"    */
             uml_ch_source = 0x26;          /* '&', next: name chars   */
             iel_xcro_st = (int)ied_xcro_txt;
             break;
           case ied_xcro_txt:               /* char from achl_xenm     */
             uml_ch_source = *achl_xenm++;
             if (*achl_xenm == 0)
               iel_xcro_st = (int)ied_xcro_endchar;
             break;
           case ied_xcro_endchar:
             uml_ch_source = 0x3B;          /* ';'                     */
             iel_xcro_st = ied_xcro_after_end;
             break;
           case ied_xcro_after_end:
             iel_xcro_st = -1;              /* copy from source again  */
             achl_cur_source += iml_len_ch_source;
             goto pcpy_00;                  /* leave this codepart     */
           case ied_xcro_dec_10:
             uml_ch_source = uml_read_ch_source / 10;          
             if (uml_ch_source != 0) {
               uml_read_ch_source -= 10 * uml_ch_source;          
               uml_ch_source += 0x30;       /* '0'-based decimal char  */
               iel_xcro_st --;              /* next: ied_xcro_dec_01   */
               break;
             }                              /* else fall through       */
           case ied_xcro_dec_01:
             uml_ch_source = uml_read_ch_source + 0x30;
             iel_xcro_st = (int)ied_xcro_endchar;
             break;
           case ied_xcro_hex_00000F:
             uml_ch_source = uml_read_ch_source & 0xF;
             uml_ch_source += (uml_ch_source<10 ? 0x30 : 0x37);
             iel_xcro_st = (int)ied_xcro_endchar;
             break;
           default:    /* ied_xcro_hex_0000F0, ... ied_xcro_hex_F00000 */
             uml_ch_source = (uml_read_ch_source >> iel_xcro_st) & 0xF;
             uml_ch_source += (uml_ch_source<10 ? 0x30 : 0x37);
             iel_xcro_st -= 4;
             break;
         }
         *achl_cur_target++ = (unsigned char) uml_ch_source;
         goto pcpy_20;
       }                                    /* else case-fall-through  */
     case ied_chs_wcp_1252:                 /* Windows-Codepage 1252   */
       *((unsigned char *) achl_cur_target) = (unsigned char) m_u32c_to_1252( uml_ch_source );
       achl_cur_target++;                   /* output one character    */
       break;
     case ied_chs_wcp_1253:                 /* Windows-Codepage 1253   */
       *((unsigned char *) achl_cur_target) = (unsigned char) m_u32c_to_1253( uml_ch_source );
       achl_cur_target++;                   /* output one character    */
       break;
     case ied_chs_wcp_1254:                 /* Windows-Codepage 1254   */
       *((unsigned char *) achl_cur_target) = (unsigned char) m_u32c_to_1254( uml_ch_source );
       achl_cur_target++;                   /* output one character    */
       break;
     case ied_chs_wcp_1255:                 /* Windows-Codepage 1255   */
       *((unsigned char *) achl_cur_target) = (unsigned char) m_u32c_to_1255( uml_ch_source );
       achl_cur_target++;                   /* output one character    */
       break;
     case ied_chs_wcp_1256:                 /* Windows-Codepage 1256   */
       *((unsigned char *) achl_cur_target) = (unsigned char) m_u32c_to_1256( uml_ch_source );
       achl_cur_target++;                   /* output one character    */
       break;
     case ied_chs_wcp_1257:                 /* Windows-Codepage 1257   */
       *((unsigned char *) achl_cur_target) = (unsigned char) m_u32c_to_1257( uml_ch_source );
       achl_cur_target++;                   /* output one character    */
       break;
     case ied_chs_wcp_1258:                 /* Windows-Codepage 1258   */
       *((unsigned char *) achl_cur_target) = (unsigned char) m_u32c_to_1258( uml_ch_source );
       achl_cur_target++;                   /* output one character    */
       break;
     case ied_chs_iso8859_2:                /* ISO 8859-2 (Latin-2)    */
       *((unsigned char *) achl_cur_target) = (unsigned char) m_u32c_to_i02( uml_ch_source );
       achl_cur_target++;                   /* output one character    */
       break;
     case ied_chs_iso8859_3:                /* ISO 8859-3 (Latin-3)    */
       *((unsigned char *) achl_cur_target) = (unsigned char) m_u32c_to_i03( uml_ch_source );
       achl_cur_target++;                   /* output one character    */
       break;
     case ied_chs_iso8859_4:                /* ISO 8859-4 (Latin-4)    */
       *((unsigned char *) achl_cur_target) = (unsigned char) m_u32c_to_i04( uml_ch_source );
       achl_cur_target++;                   /* output one character    */
       break;
     case ied_chs_iso8859_5:                /* ISO 8859-5              */
       *((unsigned char *) achl_cur_target) = (unsigned char) m_u32c_to_i05( uml_ch_source );
       achl_cur_target++;                   /* output one character    */
       break;
     case ied_chs_iso8859_6:                /* ISO 8859-6              */
       *((unsigned char *) achl_cur_target) = (unsigned char) m_u32c_to_i06( uml_ch_source );
       achl_cur_target++;                   /* output one character    */
       break;
     case ied_chs_iso8859_7:                /* ISO 8859-7              */
       *((unsigned char *) achl_cur_target) = (unsigned char) m_u32c_to_i07( uml_ch_source );
       achl_cur_target++;                   /* output one character    */
       break;
     case ied_chs_iso8859_8:                /* ISO 8859-8              */
       *((unsigned char *) achl_cur_target) = (unsigned char) m_u32c_to_i08( uml_ch_source );
       achl_cur_target++;                   /* output one character    */
       break;
     case ied_chs_iso8859_9:                /* ISO 8859-9 (Latin-5)    */
       *((unsigned char *) achl_cur_target) = (unsigned char) m_u32c_to_i09( uml_ch_source );
       achl_cur_target++;                   /* output one character    */
       break;
     case ied_chs_iso8859_10:               /* ISO 8859-10 (Latin-6)   */
       *((unsigned char *) achl_cur_target) = (unsigned char) m_u32c_to_i10( uml_ch_source );
       achl_cur_target++;                   /* output one character    */
       break;
     case ied_chs_iso8859_11:               /* ISO 8859-11             */
       *((unsigned char *) achl_cur_target) = (unsigned char) m_u32c_to_i11( uml_ch_source );
       achl_cur_target++;                   /* output one character    */
       break;
     case ied_chs_iso8859_13:               /* ISO 8859-13 (Latin-7)   */
       *((unsigned char *) achl_cur_target) = (unsigned char) m_u32c_to_i13( uml_ch_source );
       achl_cur_target++;                   /* output one character    */
       break;
     case ied_chs_iso8859_14:               /* ISO 8859-14 (Latin-8)   */
       *((unsigned char *) achl_cur_target) = (unsigned char) m_u32c_to_i14( uml_ch_source );
       achl_cur_target++;                   /* output one character    */
       break;
     case ied_chs_iso8859_15:               /* ISO 8859-15 (Latin-9)   */
       *((unsigned char *) achl_cur_target) = (unsigned char) m_u32c_to_i15( uml_ch_source );
       achl_cur_target++;                   /* output one character    */
       break;
     case ied_chs_iso8859_16:               /* ISO 8859-16 (Latin-10)  */
       *((unsigned char *) achl_cur_target) = (unsigned char) m_u32c_to_i16( uml_ch_source );
       achl_cur_target++;                   /* output one character    */
       break;
     CASE_IED_CHS_ALL_CJK
       if (uml_ch_source >= 0x10000) {
         *achl_cur_target++ = ASCII_REP_CHAR;
       } else {
         iml1 = awcl_dbcsenc[uml_ch_source];
         if (iml1 & 0xFF00)
           *achl_cur_target++ = (char)(iml1>>8);  /* dbcs lead byte    */
         *achl_cur_target++ = (char)iml1;   /* bits for second byte    */
       }
       /* UUU instead of ASCII_REP_CHAR use "Katakana middle dot for 932", says
   ftp://unicode.org/Public/MAPPINGS/VENDORS/MICSFT/WindowsBestFit/readme.txt 
   KATAKANA MIDDLE DOT is U+30FB, coded by 0x81 0x45 (so 2-byte in len_vx_vx) */
       break;
     case ied_chs_ldap_escaped_utf_8:       /* LDAP UTF-8 escaped      */
       switch (uml_ch_source >> 5) {
         case 0:
           if (uml_ch_source == 0x00) {     /* mask hexadecimally      */
             iml1 = m_put_uri_1_a( achl_cur_target, achl_end_target, uml_ch_source, '\\' );
             if (iml1 < 0) return -1;       /* output area too short   */
             achl_cur_target += iml1;       /* increment pointer output */
             break;                         /* all done                */
           }
           *achl_cur_target++ = (unsigned char) uml_ch_source;
           break;
         case 1:
           if (((unsigned int)1<<(uml_ch_source-0x20)) & 0x7800180D) {
             if (bol1 && (char)uml_ch_source=='=') {  /* the first '=' */
               bol1 = FALSE;
             } else {
               *achl_cur_target++ = '\\';   /* mask by prepending '\\' */
               if (achl_cur_target >= achl_end_target)
                 return -1;                 /* output area too short   */
             }
           }
           *achl_cur_target++ = (unsigned char) uml_ch_source;
           break;
         case 2:
           if (uml_ch_source == 0x5C) {
             *achl_cur_target++ = '\\';     /* mask by prepending '\\' */
             if (achl_cur_target >= achl_end_target)
               return -1;                   /* output area too short   */
           }
           /* fall through */
         case 3:
           *achl_cur_target++ = (unsigned char) uml_ch_source;
           break;
         default:
         /* to escape all non-ASCII-bytes, instead of the goto do here what is
            done to char 0x00 in case 0. However, the RFC does not demand it. */
           goto p_enc_utf8_over7bit;
       }
       break;
     case ied_chs_xml_utf_8:                /* UTF-8 with XML-CharRef  */
       if (iel_xcro_st < 0) {               /* no entity-encode runs   */
         /* shortest encoding is preferred, hex (no div ops) if equal  */
         if (uml_ch_source < 0xE000)
           if (uml_ch_source < 0xA0)
             iel_xcro_st = chrs_xmlent_st[uml_ch_source];
           else                             /* 00A0                    */
             { if (uml_ch_source >= 0xD800) iel_xcro_st = 1; }
         else                               /* E000                    */
           if (uml_ch_source < 0xFDF0)
             { if (uml_ch_source >= 0xFDD0) iel_xcro_st = 1; }
           else                             /* FDF0                    */
             { if ((uml_ch_source&0xFFFE)==0xFFFE) iel_xcro_st = 1; }
       }
       if (iel_xcro_st >= 0) {              /* entity-encode runs now  */
         switch ((enum ied_xcro_st)iel_xcro_st) {
           case ied_xcro_hex_start:
           case ied_xcro_dec_start:
             uml_read_ch_source = uml_ch_source;
             uml_ch_source = 0x26;          /* '&', next: '#'          */
             iel_xcro_st ++;
             break;
           case ied_xcro_dec_carpet:
             uml_ch_source = 0x23;          /* '#', next: the number   */
             iel_xcro_st = (int)ied_xcro_dec_10;
             break;
           case ied_xcro_hex_carpet:
             uml_ch_source = 0x23;          /* '#', next: 'x'          */
             iel_xcro_st ++;
             break;
           case ied_xcro_hex_x:
             uml_ch_source = 0x78;          /* 'x', next: the number   */                 
             iel_xcro_st = (int)ied_xcro_hex_F00000;
             while (uml_read_ch_source >> iel_xcro_st == 0)
               iel_xcro_st -= 4;    /* will hang if called with U+0000 */
             break;
           case ied_xcro_txt_start_lt:
             achl_xenm = chrs_html_lt;      /* use entity name "lt"    */
             uml_ch_source = 0x26;          /* '&', next: name chars   */
             iel_xcro_st = (int)ied_xcro_txt;
             break;
           case ied_xcro_txt_start_gt:
             achl_xenm = chrs_html_gt;      /* use entity name "gt"    */
             uml_ch_source = 0x26;          /* '&', next: name chars   */
             iel_xcro_st = (int)ied_xcro_txt;
             break;
           case ied_xcro_txt:               /* char from achl_xenm     */
             uml_ch_source = *achl_xenm++;
             if (*achl_xenm == 0)
               iel_xcro_st = (int)ied_xcro_endchar;
             break;
           case ied_xcro_endchar:
             uml_ch_source = 0x3B;          /* ';'                     */
             iel_xcro_st = ied_xcro_after_end;
             break;
           case ied_xcro_after_end:
             iel_xcro_st = -1;              /* copy from source again  */
             achl_cur_source += iml_len_ch_source;
             goto pcpy_00;                  /* leave this codepart     */
           case ied_xcro_dec_10:
             uml_ch_source = uml_read_ch_source / 10;          
             if (uml_ch_source != 0) {
               uml_read_ch_source -= 10 * uml_ch_source;          
               uml_ch_source += 0x30;       /* '0'-based decimal char  */
               iel_xcro_st --;              /* next: ied_xcro_dec_01   */
               break;
             }                              /* else fall through       */
           case ied_xcro_dec_01:
             uml_ch_source = uml_read_ch_source + 0x30;
             iel_xcro_st = (int)ied_xcro_endchar;
             break;
           case ied_xcro_hex_00000F:
             uml_ch_source = uml_read_ch_source & 0xF;
             uml_ch_source += (uml_ch_source<10 ? 0x30 : 0x37);
             iel_xcro_st = (int)ied_xcro_endchar;
             break;
           default:    /* ied_xcro_hex_0000F0, ... ied_xcro_hex_F00000 */
             uml_ch_source = (uml_read_ch_source >> iel_xcro_st) & 0xF;
             uml_ch_source += (uml_ch_source<10 ? 0x30 : 0x37);
             iel_xcro_st -= 4;
             break;
         }
         *achl_cur_target++ = (unsigned char) uml_ch_source;
         goto pcpy_20;
       }                                    /* else case-fall-through  */
     case ied_chs_utf_8:                    /* Unicode UTF-8           */
       if ((uml_ch_source != 0) && ((uml_ch_source >> 7) == 0)) {  /* not zero or 0X80 (Why not zero? This way it encodes U+0000 with a superfluous extra byte WS 8.12.2011) */
         *achl_cur_target++ = (unsigned char) uml_ch_source;
         break;
       }
       p_enc_utf8_over7bit:
       if ((uml_ch_source >> 11) == 0) {
         *achl_cur_target++ = 0XC0 | (uml_ch_source >> 6);
         /* check at maximum output                                      */
         if (achl_cur_target >= achl_end_target) return -1;  /* output area too short */
         *achl_cur_target++ = 0X80 | (uml_ch_source & 0X3F);
         break;
       }
       if ((uml_ch_source >> 16) == 0) {
         *achl_cur_target++ = 0XE0 | (uml_ch_source >> 12);
         if (achl_cur_target >= achl_end_target) return -1;  /* output area too short */
         *achl_cur_target++ = (0X80 | ((uml_ch_source >> 6) & 0X3F));
         if (achl_cur_target >= achl_end_target) return -1;  /* output area too short */
         *achl_cur_target++ = (0X80 | (uml_ch_source & 0X3F));
         break;
       }
       if ((uml_ch_source >> 21) == 0) {
         *achl_cur_target++ = 0XF0 | (uml_ch_source >> 18);
         if (achl_cur_target >= achl_end_target) return -1;  /* output area too short */
         *achl_cur_target++ = (0X80 | ((uml_ch_source >> 12) & 0X3F));
         if (achl_cur_target >= achl_end_target) return -1;  /* output area too short */
         *achl_cur_target++ = (0X80 | ((uml_ch_source >> 6) & 0X3F));
         if (achl_cur_target >= achl_end_target) return -1;  /* output area too short */
         *achl_cur_target++ = (0X80 | (uml_ch_source & 0X3F));
         break;
       }
       if ((uml_ch_source >> 26) == 0) {
         *achl_cur_target++ = 0XF8 | (uml_ch_source >> 24);
         if (achl_cur_target >= achl_end_target) return -1;  /* output area too short */
         *achl_cur_target++ = (0X80 | ((uml_ch_source >> 18) & 0X3F));
         if (achl_cur_target >= achl_end_target) return -1;  /* output area too short */
         *achl_cur_target++ = (0X80 | ((uml_ch_source >> 12) & 0X3F));
         if (achl_cur_target >= achl_end_target) return -1;  /* output area too short */
         *achl_cur_target++ = (0X80 | ((uml_ch_source >> 6) & 0X3F));
         if (achl_cur_target >= achl_end_target) return -1;  /* output area too short */
         *achl_cur_target++ = (0X80 | (uml_ch_source & 0X3F));
         break;
       }
       if ((uml_ch_source >> 31) == 0) {
         *achl_cur_target++ = 0XFC | (uml_ch_source >> 30);
         if (achl_cur_target >= achl_end_target) return -1;  /* output area too short */
         *achl_cur_target++ = (0X80 | ((uml_ch_source >> 24) & 0X3F));
         if (achl_cur_target >= achl_end_target) return -1;  /* output area too short */
         *achl_cur_target++ = (0X80 | ((uml_ch_source >> 18) & 0X3F));
         if (achl_cur_target >= achl_end_target) return -1;  /* output area too short */
         *achl_cur_target++ = (0X80 | ((uml_ch_source >> 12) & 0X3F));
         if (achl_cur_target >= achl_end_target) return -1;  /* output area too short */
         *achl_cur_target++ = (0X80 | ((uml_ch_source >> 6) & 0X3F));
         if (achl_cur_target >= achl_end_target) return -1;  /* output area too short */
         *achl_cur_target++ = (0X80 | (uml_ch_source & 0X3F));
         break;
       }
       return -1;                           /* character undefined     */
     case ied_chs_html_1:                   /* HTML character set      */
       bol1 = FALSE;                        /* character not copied    */
       if (uml_ch_source < 0X80) {          /* may be a single character */
         switch (uml_ch_source) {           /* check special values    */
           case 0X22:                       /* chrs_html_quote         */
             break;                         /* set in string           */
           case 0X26:                       /* chrs_html_amp           */
             break;                         /* set in string           */
           case 0X3C:                       /* chrs_html_lt            */
             break;                         /* set in string           */
           case 0X3E:                       /* chrs_html_gt            */
             break;                         /* set in string           */
           default:
             *achl_cur_target++ = (unsigned char) uml_ch_source;
             bol1 = TRUE;                   /* character has been copied */
             break;
         }
       }
       if (bol1) break;                     /* all done                */
       iml1 = m_put_html_1_a( achl_cur_target, achl_end_target, uml_ch_source );
       if (iml1 < 0) return -1;             /* output area too small   */
       achl_cur_target += iml1;             /* increment pointer output */
       break;                               /* all done                */
     case ied_chs_uri_1:                    /* URI RFC 3986            */
       if (   ((uml_ch_source >> 7) == 0)   /* only 7 bits - < 0X80    */
           && (chrs_uri_1_tab[ uml_ch_source ] == 0)) {  /* not reserved */
         *achl_cur_target++ = (unsigned char) uml_ch_source;
         break;
       }
       iml1 = m_put_uri_1_a( achl_cur_target, achl_end_target, uml_ch_source, '%' );
       if (iml1 < 0) return -1;             /* output area too small   */
       achl_cur_target += iml1;             /* increment pointer output */
       break;                               /* all done                */
     case ied_chs_hsf_1:                    /* HOB special file system */
       if (   ((uml_ch_source >> 7) == 0)   /* only 7 bits - < 0X80    */
           && (chrs_non09az_tab[ uml_ch_source ] == 0)) {  /* not reserved */
         *achl_cur_target++ = (unsigned char) uml_ch_source;
         break;
       }
       iml1 = m_put_uri_1_a( achl_cur_target, achl_end_target, uml_ch_source, '_' );
       if (iml1 < 0) return -1;             /* output area too small   */
       achl_cur_target += iml1;             /* increment pointer output */
       break;                               /* all done                */
     case ied_chs_idna_1:                   /* IDNA RFC 3490 - Punycode */
       if (uml_ch_source < 0x7B) {          /* maybe unchanged char    */
         if (--iml_idna_labelspace == 0) {  /* over RFC 1034 maxlength */
           if (uml_ch_source != 0x2E)       /* last-chance part-end?   */
             return -1;
         }                   /* (limiting also precludes int overflow) */
         inl_idna_prevccc = 0;              /* all these have ccc of 0 */
         unl_prevstrt = uml_ch_source;      /* no test, as NFC_QC is Y */
         if (uml_ch_source > 0x60) {        /* lcase ASCII, unchanged  */
           *achl_cur_target++ = (unsigned char) uml_ch_source;
           break;
         }
         if (uml_ch_source >= 0x30) {       /* maybe ASCII digit       */
           if (uml_ch_source < 0x3A) {      /* ASCII digit, unchanged  */
             *achl_cur_target++ = (unsigned char) uml_ch_source;
             break;
           }
           if (bol_idna_nohighyet) {        /* permit IPv6 addresses etc. */
             *achl_cur_target++ = (unsigned char) uml_ch_source;
             iep_cs_target = IED_CHS_COPY7A;
             break;
           }
           return -1;                       /* prohibited ASCII char   */
         } else {
           if (uml_ch_source == 0x2D) {     /* hyphen-minus, unchanged */
             switch (MAX_IDNAPART_LENGTH-iml_idna_labelspace) {
               case 2:
                 iel_idna_minuspair = 1;
                 break;
               case 3:
                 if (iel_idna_minuspair) {
                   if (utl_idna_tn)
                     return -1;             /* already non-ASCII at [0] or [1] */
                   iel_idna_minuspair = 2;
                 }
                 break;
               default:                     /* ignore at /^..--/-detection */
                 break;
             }
             *achl_cur_target++ = (unsigned char) uml_ch_source;
             break;
           }
           if (uml_ch_source == 0x2E) {     /* dot, begin new part     */
             goto p_next_idnlbl;
           }
           if (bol_idna_nohighyet) {        /* permit IPv6 addresses etc. */
             *achl_cur_target++ = (unsigned char) uml_ch_source;
             iep_cs_target = IED_CHS_COPY7A;
             break;
           }
           return -1;                       /* prohibited ASCII char   */
         }
       } else {                             /* not an unchanged char   */
         if (iel_idna_minuspair) {
           if (iel_idna_minuspair == 1)
             iel_idna_minuspair = 0;        /* '-' only at [2], not at [3] */
            else
             return -1;                     /* label must be ASCII, "--"-rule */
         }
         switch (uml_ch_source) {           /* check for part end end CONTEXTJ cases */
           case 0x200C:                     /* ZERO WIDTH NON-JOINER   */
             if (utl_idna_tn==0)
               return -1;                   /* cannot fulfil either rule */
             if (utl_idna_openzwnj) {       /* still earlier one unclear, check that first */
               if (!m_idna_zwnj_jtrule_ok( dslr_idna_treelist, utl_idna_openzwnj, utl_idna_tn ))
                 return -1;                 /* earlier zwnj not conforming */
             }
             if (inl_idna_prevccc == 9) {   /* previous char is virama */
               utl_idna_openzwnj = 0;
               /* virama rule fulfilled, joiningtype not checked       */
             } else {                       /* must fulfil joiningtype rule */
               /* the rule would be complicated to test now, so it is tested on label end or
                  next zwnj, as this is probably too rare to check utl_idna_openzwnj often */
               utl_idna_openzwnj = utl_idna_tn;
             }
             inl_idna_prevccc = 0;          /* U+200C has ccc of 0     */
             break;
           case 0x200D:                     /* ZERO WIDTH JOINER       */
             if (inl_idna_prevccc != 9)     /* previous char no virama */
               return -1;                   /* failed CONTEXTJ rule    */
             inl_idna_prevccc = 0;          /* U+200D has ccc of 0     */
             break;                         /* virama rule fulfilled   */
           case 0x3002:   /* dots, see RFC 3490, section 3.1, number 1 */
           case 0xFF0E:
           case 0xFF61:                     /* begin new part          */
             goto p_next_idnlbl;
           default:
             if (!m_is_idna_allowed(uml_ch_source))
               return -1;                   /* prohibited non-ASCII char */
             iml1 = m_get_unicode_canonical_combining_class(uml_ch_source);
             if (iml1 && (iml1 < inl_idna_prevccc))
               return -1;                   /* cannot be in NFC form   */
             inl_idna_prevccc = iml1;
             if (m_idna_cannotbe_nfc(unl_prevstrt, uml_ch_source))
               return -1;                   /* cannot be in NFC form   */
             if (!iml1)                     /* remember "starter"      */
               unl_prevstrt = uml_ch_source;
             break;
         }
       }
       /* store character in tree for later punycode representation    */
       if (--iml_idna_labelspace == 0)      /* over RFC 1034 maxlength */
         return -1;                         /* (limiting also precludes int overflow) */
       if ((iml_idna_labelspace==MAX_IDNAPART_LENGTH) && m_get_unicode_is_combining(uml_ch_source))
         return -1;                         /* combining mark as first in label */
       if (!utl_idna_tn) {                  /* first non-ASCII in this part*/
         bol_idna_nohighyet = FALSE;
         if (achl_cur_target+5 >= achl_end_target)
           return -1;                       /* output area too small   */
         /* prepend prefix to what we already have translated to ASCII */
         memmove( achl_idna_ps+4, achl_idna_ps, achl_cur_target-achl_idna_ps );
         memcpy( achl_idna_ps, "xn--", 4 );
         achl_cur_target += 4;
       }
       m_idna_add_to_treelist( dslr_idna_treelist, uml_ch_source, utl_idna_tn ++,
                               MAX_IDNAPART_LENGTH-iml_idna_labelspace );
       break;
       p_next_idnlbl:                       /* next dot-separated part */
       if (utl_idna_tn) {                   /* last part had non-ASCII */
         if (utl_idna_openzwnj &&
             !m_idna_zwnj_jtrule_ok( dslr_idna_treelist, utl_idna_openzwnj, utl_idna_tn ))
           return -1;                       /* earlier U+200C not conforming */
         achl_cur_target = m_idna_encode_utree( dslr_idna_treelist,
                           achl_cur_target-(achl_idna_ps+4),
                           achl_cur_target,
                           achl_end_target<=achl_idna_ps+MAX_IDNAPART_LENGTH
                                          ? achl_end_target
                                          : achl_idna_ps+MAX_IDNAPART_LENGTH
                           );
         if ((achl_cur_target == NULL) || (achl_cur_target >= achl_end_target))
           return -1;                       /* target overflow         */
       }
       *achl_cur_target++ = (unsigned char) '.';
       achl_idna_ps = achl_cur_target;
       iml_idna_labelspace = 1+MAX_IDNAPART_LENGTH;
       utl_idna_openzwnj = 0;
       iel_idna_minuspair = 0;
       inl_idna_prevccc = 255;
       unl_prevstrt = 0;
       utl_idna_tn = 0;
       break;
     case IED_CHS_COPY7A:                   /* idna-prohibited ascii   */
       if (uml_ch_source > 'z')
         return -1;  /* neither IDNA nor something like a IPv6-address */
       *((unsigned char *) achl_cur_target) = (unsigned char) uml_ch_source;
       achl_cur_target++;                   /* output one character    */
       break;
     case ied_chs_xml_utf_16:               /* UTF-16 with XML-CharRef */
       if (iel_xcro_st < 0) {               /* no entity-encode runs   */
         /* shortest encoding is preferred, hex (no div ops) if equal  */
         if (uml_ch_source < 0xE000)
           if (uml_ch_source < 0xA0)
             iel_xcro_st = chrs_xmlent_st[uml_ch_source];
           else                             /* 00A0                    */
             { if (uml_ch_source >= 0xD800) iel_xcro_st = 1; }
         else                               /* E000                    */
           if (uml_ch_source < 0xFDF0)
             { if (uml_ch_source >= 0xFDD0) iel_xcro_st = 1; }
           else                             /* FDF0                    */
             { if (((uml_ch_source&0xFFFE)==0xFFFE) && (uml_ch_source<0x110000)) iel_xcro_st = 1; }
       }
       if (iel_xcro_st >= 0) {              /* entity-encode runs now  */
         switch ((enum ied_xcro_st)iel_xcro_st) {
           case ied_xcro_hex_start:
           case ied_xcro_dec_start:
             uml_read_ch_source = uml_ch_source;
             uml_ch_source = 0x26;          /* '&', next: '#'          */
             iel_xcro_st ++;
             break;
           case ied_xcro_dec_carpet:
             uml_ch_source = 0x23;          /* '#', next: the number   */
             iel_xcro_st = (int)ied_xcro_dec_10;
             break;
           case ied_xcro_hex_carpet:
             uml_ch_source = 0x23;          /* '#', next: 'x'          */
             iel_xcro_st ++;
             break;
           case ied_xcro_hex_x:
             uml_ch_source = 0x78;          /* 'x', next: the number   */                 
             iel_xcro_st = (int)ied_xcro_hex_F00000;
             while (uml_read_ch_source >> iel_xcro_st == 0)
               iel_xcro_st -= 4;    /* will hang if called with U+0000 */
             break;
           case ied_xcro_txt_start_lt:
             achl_xenm = chrs_html_lt;      /* use entity name "lt"    */
             uml_ch_source = 0x26;          /* '&', next: name chars   */
             iel_xcro_st = (int)ied_xcro_txt;
             break;
           case ied_xcro_txt_start_gt:
             achl_xenm = chrs_html_gt;      /* use entity name "gt"    */
             uml_ch_source = 0x26;          /* '&', next: name chars   */
             iel_xcro_st = (int)ied_xcro_txt;
             break;
           case ied_xcro_txt:               /* char from achl_xenm     */
             uml_ch_source = *achl_xenm++;
             if (*achl_xenm == 0)
               iel_xcro_st = (int)ied_xcro_endchar;
             break;
           case ied_xcro_endchar:
             uml_ch_source = 0x3B;          /* ';'                     */
             iel_xcro_st = ied_xcro_after_end;
             break;
           case ied_xcro_after_end:
             iel_xcro_st = -1;              /* copy from source again  */
             achl_cur_source += iml_len_ch_source;
             goto pcpy_00;                  /* leave this codepart     */
           case ied_xcro_dec_10:
             uml_ch_source = uml_read_ch_source / 10;          
             if (uml_ch_source != 0) {
               uml_read_ch_source -= 10 * uml_ch_source;          
               uml_ch_source += 0x30;       /* '0'-based decimal char  */
               iel_xcro_st --;              /* next: ied_xcro_dec_01   */
               break;
             }                              /* else fall through       */
           case ied_xcro_dec_01:
             uml_ch_source = uml_read_ch_source + 0x30;
             iel_xcro_st = (int)ied_xcro_endchar;
             break;
           case ied_xcro_hex_00000F:
             uml_ch_source = uml_read_ch_source & 0xF;
             uml_ch_source += (uml_ch_source<10 ? 0x30 : 0x37);
             iel_xcro_st = (int)ied_xcro_endchar;
             break;
           default:    /* ied_xcro_hex_0000F0, ... ied_xcro_hex_F00000 */
             uml_ch_source = (uml_read_ch_source >> iel_xcro_st) & 0xF;
             uml_ch_source += (uml_ch_source<10 ? 0x30 : 0x37);
             iel_xcro_st -= 4;
             break;
         }
         *((HL_WCHAR *) achl_cur_target) = (HL_WCHAR) uml_ch_source;
         achl_cur_target += sizeof(HL_WCHAR);
         goto pcpy_20;
       }                                    /* else case-fall-through  */
     case ied_chs_utf_16:                   /* Unicode UTF-16 = WCHAR  */
       if (uml_ch_source >= 0X10000) {      /* over 16-bit, needs surrogates */
         uml_ch_source -= 0X10000;
         if (uml_ch_source & ~0xFFFFF) {    /* over 0x10FFFF, not possible */
           *((HL_WCHAR *) achl_cur_target) = UTF16_REP_CHAR;
         } else {
           *((HL_WCHAR *) achl_cur_target) = (HL_WCHAR)(0xD800 | (uml_ch_source >> 10));
           achl_cur_target += sizeof(HL_WCHAR);
           if (achl_cur_target >= achl_end_target)
             return -1;                     /* target overflow         */
           *((HL_WCHAR *) achl_cur_target) = (HL_WCHAR)(0xDC00 | (uml_ch_source & 0x03FF));
         }
       } else {                             /* 16-bit is enough        */
         *((HL_WCHAR *) achl_cur_target) = (HL_WCHAR) uml_ch_source;
       }
       achl_cur_target += sizeof(HL_WCHAR);
       break;
     case ied_chs_be_utf_16:                /* Unicode UTF-16 big endian */
       if (uml_ch_source >= 0X10000) {      /* over 16-bit, needs surrogates */
         uml_ch_source -= 0X10000;
         if (uml_ch_source & ~0xFFFFF) {    /* over 0x10FFFF, not possible */
           *((unsigned char *) achl_cur_target + 0) = (unsigned char) (UTF16_REP_CHAR >> 8);
           *((unsigned char *) achl_cur_target + 1) = (unsigned char) UTF16_REP_CHAR;
           achl_cur_target += sizeof(HL_WCHAR);
           break;
         }
         if (achl_cur_target+4 > achl_end_target)
           return -1;                       /* target overflow         */
         *((unsigned char *) achl_cur_target + 0) = (unsigned char) (0xD8 | (3 & (uml_ch_source >> 18)));
         *((unsigned char *) achl_cur_target + 1) = (unsigned char) (uml_ch_source >> 10);
         *((unsigned char *) achl_cur_target + 2) = (unsigned char) (0xDC | (3 & (uml_ch_source >> 8)));
         *((unsigned char *) achl_cur_target + 3) = (unsigned char) uml_ch_source;
         achl_cur_target += 2 * sizeof(HL_WCHAR);
       } else {                             /* 16-bit is enough        */
         *((unsigned char *) achl_cur_target + 0) = (unsigned char) (uml_ch_source >> 8);
         *((unsigned char *) achl_cur_target + 1) = (unsigned char) uml_ch_source;
         achl_cur_target += sizeof(HL_WCHAR);
       }
       break;
     case ied_chs_le_utf_16:                /* Unicode UTF-16 little endian */
       if (uml_ch_source >= 0X10000) {      /* over 16-bit, needs surrogates */
         uml_ch_source -= 0X10000;
         if (uml_ch_source & ~0xFFFFF) {    /* over 0x10FFFF, not possible */
           *((unsigned char *) achl_cur_target + 0) = (unsigned char) UTF16_REP_CHAR;
           *((unsigned char *) achl_cur_target + 1) = (unsigned char) (UTF16_REP_CHAR >> 8);
           achl_cur_target += sizeof(HL_WCHAR);
           break;
         }
         if (achl_cur_target+4 > achl_end_target)
           return -1;                       /* target overflow         */
         *((unsigned char *) achl_cur_target + 0) = (unsigned char) (uml_ch_source >> 10);
         *((unsigned char *) achl_cur_target + 1) = (unsigned char) (0xD8 | (3 & (uml_ch_source >> 18)));
         *((unsigned char *) achl_cur_target + 2) = (unsigned char) uml_ch_source;
         *((unsigned char *) achl_cur_target + 3) = (unsigned char) (0xDC | (3 & (uml_ch_source >> 8)));
         achl_cur_target += 2 * sizeof(HL_WCHAR);
       } else {                             /* 16-bit is enough        */
         *((unsigned char *) achl_cur_target + 0) = (unsigned char) uml_ch_source;
         *((unsigned char *) achl_cur_target + 1) = (unsigned char) (uml_ch_source >> 8);
         achl_cur_target += sizeof(HL_WCHAR);
       }
       break;
     case ied_chs_utf_32:                   /* Unicode UTF-32          */
       *((unsigned int *) achl_cur_target) = (unsigned int) uml_ch_source;
       achl_cur_target += sizeof(unsigned int);
       break;
     case ied_chs_be_utf_32:                /* Unicode UTF-32 big endian */
       *((unsigned char *) achl_cur_target + 0) = (unsigned char) (uml_ch_source >> 24);
       *((unsigned char *) achl_cur_target + 1) = (unsigned char) (uml_ch_source >> 16);
       *((unsigned char *) achl_cur_target + 2) = (unsigned char) (uml_ch_source >> 8);
       *((unsigned char *) achl_cur_target + 3) = (unsigned char) uml_ch_source;
       achl_cur_target += sizeof(unsigned int);
       break;
     case ied_chs_le_utf_32:                /* Unicode UTF-32 little endian */
       *((unsigned char *) achl_cur_target + 0) = (unsigned char) uml_ch_source;
       *((unsigned char *) achl_cur_target + 1) = (unsigned char) (uml_ch_source >> 8);
       *((unsigned char *) achl_cur_target + 2) = (unsigned char) (uml_ch_source >> 16);
       *((unsigned char *) achl_cur_target + 3) = (unsigned char) (uml_ch_source >> 24);
       achl_cur_target += sizeof(unsigned int);
       break;
     default:
       return -1;                           /* cannot copy             */
   }
   achl_cur_source += iml_len_ch_source;
   goto pcpy_00;                            /* copy characters         */
} /* end m_cpy_uc_vx_vx()                                              */

/**
* compute length of space needed for target, in elements
*  @param iep_cs_target encoding for the hypothetical output string
*  @param ap_source the input string
*  @param imp_len_source a negative value to mean that ap_source is zero-
*                        terminated, or a nonnegative value giving the length
*                        (in units of 8, 16 or 32 bits depending on charset).
*  @param iep_cs_source encoding used by ap_source
*  @return -1 on error, else length in units of 8, 16 or 32 bits (depending on
*          iep_cs_target) that would be needed to express the contents of
*          ap_source in iep_cs_target, not including any space for termination.
*/
extern PTYPE int m_len_vx_vx( enum ied_charset iep_cs_target, const void *ap_source,
                              int imp_len_source, enum ied_charset iep_cs_source ) {
   BOOL          bol1;                      /* working-variable        */
   const char    *achl_cur_source;          /* current position parameter */
   const char    *achl_end_source;          /* end of parameter        */
   unsigned int  uml_ch_source;             /* character decoded       */
   int           iml_len_ch_source;         /* length of parameter     */
   int           iml_len_return;            /* length to return        */
   char          chrl_work1[ 16 ];          /* work area               */
   /*HL_WCHAR      *awcl_dbcsfbd;            * dbcs 1st byte decoding  */
   HL_WCHAR      *awcl_dbcsenc;             /* dbcs encoding table     */
   struct dsd_idna_upoint dslr_idna_treelist[MAX_IDNAPART_LENGTH];  /* non-ascii data */
   unsigned char utl_idna_tn;               /* length for dsd_idna_upoint */
   int           iml_idna_ps;               /* target start of current label */
   int           iml_idna_labelspace;       /* rest of RFC 1034 maxlen */
   unsigned char utl_idna_openzwnj;         /* U+200C yet to be accepted (RFC 5892 A.1.) */
   /* variables for tests required for IDNA target by RFC 5891 5.4.    */
   int           iel_idna_minuspair;        /* detect labels starting with "..--" */
   BOOL          bol_idna_nohighyet;        /* only <='z' in all labels so far */
   int           inl_idna_prevccc;          /* canonical combining class */
   unsigned int  unl_prevstrt;              /* last char with ccc == 0 */

   /* calculate end of parameter source                                */
   achl_cur_source = (const char *) ap_source;
   achl_end_source = NULL;                  /* still zero-terminated   */
   if (imp_len_source >= 0) {               /* length source given     */
     switch (iep_cs_source) {
       case ied_chs_ascii_850:              /* ASCII 850               */
       case ied_chs_ansi_819:               /* ANSI 819                */
       CASE_IED_CHS_MISCCODEPAGES
       CASE_IED_CHS_ALL_CJK
       CASE_IED_CHS_ISO8859_2TO16
       case ied_chs_utf_8:                  /* Unicode UTF-8           */
       case ied_chs_xml_utf_8:              /* UTF-8 with XML-CharRef  */
       case ied_chs_xml_wcp_1252:           /* Windows-1252 with XML-CharRef */
       case ied_chs_html_1:                 /* HTML character set      */
       case ied_chs_uri_1:                  /* URI, percent-encoded    */
       case ied_chs_ldap_escaped_utf_8:     /* LDAP UTF-8 escaped      */
       case ied_chs_hsf_1:                  /* HOB special file system */
         achl_end_source = ((const char *) ap_source) + imp_len_source;
         break;
       CASE_IED_CHS_U16_ALLENDIAN
       case ied_chs_xml_utf_16:             /* UTF-16 with XML-CharRef */
         achl_end_source = ((const char *) ap_source) + imp_len_source * sizeof(HL_WCHAR);
         break;
       CASE_IED_CHS_U32_ALLENDIAN
         achl_end_source = ((const char *) ap_source) + imp_len_source * sizeof(unsigned int);
         break;
       default:
#ifndef B150303
         if (imp_len_source == 0) {         /* empty, whatever it is   */
           achl_end_source = achl_cur_source;  /* already at end       */
           break;
         }
#endif
         return -1;                         /* cannot count            */
     }
   }
   switch (iep_cs_target) {
     CASE_IED_CHS_ALL_CJK
       awcl_dbcsenc = m_get_tab_uni_to_mb(iep_cs_target);
       break;
     case ied_chs_idna_1:                  /* IDNA RFC 3490 - Punycode */
       iml_idna_ps = 0;
       iml_idna_labelspace = 1+MAX_IDNAPART_LENGTH;
       utl_idna_openzwnj = 0;        /* =none, at 0 would not be legal */
       iel_idna_minuspair = 0;
       bol_idna_nohighyet = TRUE;
       inl_idna_prevccc = 255;
       unl_prevstrt = 0;
       utl_idna_tn = 0;
       break;
     case ied_chs_ldap_escaped_utf_8:       /* LDAP UTF-8 escaped      */
       bol1 = TRUE;                         /* yet awaiting first '='  */
       break;
   }
   iml_len_return = 0;                      /* clear length to return  */

   pcheck_00:                               /* check characters        */
   iml_len_ch_source = m_get_vc_ch( &uml_ch_source, achl_cur_source, achl_end_source, iep_cs_source );
   if (iml_len_ch_source <= 0) {            /* subroutine reported end or error */
     if (iml_len_ch_source == 0) {          /* end of input found      */
       if (iep_cs_target==ied_chs_idna_1 && utl_idna_tn) {  /* last part had non-ASCII */
         if (utl_idna_openzwnj &&
             !m_idna_zwnj_jtrule_ok( dslr_idna_treelist, utl_idna_openzwnj, utl_idna_tn ))
           return -1;                       /* earlier U+200C not conforming */
         /* count space for the non-ascii chars of the last part       */
         iml_len_return = m_idna_suffixlen( dslr_idna_treelist,
                                            iml_len_return-(iml_idna_ps+4),
                                            iml_len_return );
         if (iml_len_return > iml_idna_ps+MAX_IDNAPART_LENGTH)
           iml_len_return = -1;             /* last part too long      */
       }
       return iml_len_return;               /* return length calculated */
     }
     return -1;                             /* return error            */
   }
   switch (iep_cs_target) {
     case ied_chs_ascii_850:                /* ASCII 850               */
     case ied_chs_ansi_819:                 /* ANSI 819                */
     CASE_IED_CHS_MISCCODEPAGES
     CASE_IED_CHS_ISO8859_2TO16
       iml_len_return++;                    /* increment length to return */
       break;
     CASE_IED_CHS_ALL_CJK
       if ((uml_ch_source&0xFFFF0000) || !(awcl_dbcsenc[uml_ch_source]&0xFF00))
         iml_len_return++;                  /* increment length to return */
       else
         iml_len_return+=2;                 /* increment length to return */
       /* if KATAKANA MIDDLE DOT instead of ASCII_REP_CHAR is ever implemented
          for 932, re-use something like in the without-bigtable part above */
       break;
     case ied_chs_html_1:                   /* HTML character set      */
       bol1 = FALSE;                        /* character not copied    */
       if (uml_ch_source < 0X80) {          /* may be a single character */
         switch (uml_ch_source) {           /* check special values    */
           case 0X22:                       /* chrs_html_quote         */
             break;                         /* set in string           */
           case 0X26:                       /* chrs_html_amp           */
             break;                         /* set in string           */
           case 0X3C:                       /* chrs_html_lt            */
             break;                         /* set in string           */
           case 0X3E:                       /* chrs_html_gt            */
             break;                         /* set in string           */
           default:
             iml_len_return++;              /* increment length to return */
             bol1 = TRUE;                   /* character has been copied */
             break;
         }
       }
       if (bol1) break;                     /* all done                */
       iml_len_return += m_put_html_1_a( chrl_work1, chrl_work1 + sizeof(chrl_work1), uml_ch_source );
       break;                               /* all done                */
     case ied_chs_uri_1:                    /* URI RFC 3986            */
     case ied_chs_hsf_1:                    /* HOB special file system */
       if ((uml_ch_source >> 7) == 0) {     /* 7-bit, <0X80, UTF-8 1 byte */
         if ((iep_cs_target==ied_chs_uri_1?chrs_uri_1_tab:chrs_non09az_tab)[ uml_ch_source ] == 0) {
           iml_len_return++;                /* increment length to return */
         } else                             /* reserved value, escape it  */
           iml_len_return += 1 * 3;         /* increment length to return */
         break;
       }
       if ((uml_ch_source >> 11) == 0) {
         iml_len_return += 2 * 3;           /* increment length to return */
         break;
       }
       if ((uml_ch_source >> 16) == 0) {
         iml_len_return += 3 * 3;           /* increment length to return */
         break;
       }
       if ((uml_ch_source >> 21) == 0) {
         iml_len_return += 4 * 3;           /* increment length to return */
         break;
       }
       if ((uml_ch_source >> 26) == 0) {
         iml_len_return += 5 * 3;           /* increment length to return */
         break;
       }
       if ((uml_ch_source >> 31) == 0) {
         iml_len_return += 6 * 3;           /* increment length to return */
         break;
       }
       iml_len_return += 7 * 3;             /* increment length to return */
       break;                               /* all done                */
     case ied_chs_idna_1:                   /* IDNA RFC 3490 - Punycode */
       if (uml_ch_source < 0x7B) {          /* maybe unchanged char    */
         if (--iml_idna_labelspace == 0) {  /* over RFC 1034 maxlength */
           if (uml_ch_source != 0x2E)       /* last-chance part-end?   */
             return -1;
         }                   /* (limiting also precludes int overflow) */
         inl_idna_prevccc = 0;              /* all these have ccc of 0 */
         unl_prevstrt = uml_ch_source;      /* no test, as NFC_QC is Y */
         if (uml_ch_source > 0x60) {        /* lcase ASCII, unchanged  */
           iml_len_return++;                /* increment length to return */
           break;
         }
         if (uml_ch_source >= 0x30) {       /* maybe ASCII digit       */
           if (uml_ch_source < 0x3A) {      /* ASCII digit, unchanged  */
             iml_len_return++;              /* increment length to return */
             break;
           }
           if (bol_idna_nohighyet) {        /* permit IPv6 addresses etc. */
             iml_len_return++;              /* increment length to return */
             iep_cs_target = IED_CHS_COPY7A;
             break;
           }
           return -1;                       /* prohibited ASCII char   */
         } else {
           if (uml_ch_source == 0x2D) {     /* hyphen-minus, unchanged */
             switch (MAX_IDNAPART_LENGTH-iml_idna_labelspace) {
               case 2:
                 iel_idna_minuspair = 1;
                 break;
               case 3:
                 if (iel_idna_minuspair) {
                   if (utl_idna_tn)
                     return -1;             /* already non-ASCII at [0] or [1] */
                   iel_idna_minuspair = 2;
                 }
                 break;
               default:                     /* ignore at /^..--/-detection */
                 break;
             }
             iml_len_return++;              /* increment length to return */
             break;
           }
           if (uml_ch_source == 0x2E) {     /* dot, begin new part     */
             goto p_next_idnlbl;
           }
           if (bol_idna_nohighyet) {        /* permit IPv6 addresses etc. */
             iml_len_return++;              /* increment length to return */
             iep_cs_target = IED_CHS_COPY7A;
             break;
           }
           return -1;                       /* prohibited ASCII char   */
         }
       } else {                             /* not an unchanged char   */
         if (iel_idna_minuspair) {
           if (iel_idna_minuspair == 1)
             iel_idna_minuspair = 0;        /* '-' only at [2], not at [3] */
            else
             return -1;                     /* label must be ASCII, "--"-rule */
         }
         switch (uml_ch_source) {           /* check for part end end CONTEXTJ cases */
           case 0x200C:                     /* ZERO WIDTH NON-JOINER   */
             if (utl_idna_tn==0)
               return -1;                   /* cannot fulfil either rule */
             if (utl_idna_openzwnj) {       /* still earlier one unclear, check that first */
               if (!m_idna_zwnj_jtrule_ok( dslr_idna_treelist, utl_idna_openzwnj, utl_idna_tn ))
                 return -1;                 /* earlier zwnj not conforming */
             }
             if (inl_idna_prevccc == 9) {   /* previous char is virama */
               utl_idna_openzwnj = 0;
               /* virama rule fulfilled, joiningtype not checked       */
             } else {                       /* must fulfil joiningtype rule */
               /* the rule would be complicated to test now, so it is tested on label end or
                  next zwnj, as this is probably too rare to check utl_idna_openzwnj often */
               utl_idna_openzwnj = utl_idna_tn;
             }
             inl_idna_prevccc = 0;          /* U+200C has ccc of 0     */
             break;
           case 0x200D:                     /* ZERO WIDTH JOINER       */
             if (inl_idna_prevccc != 9)     /* previous char no virama */
               return -1;                   /* failed CONTEXTJ rule    */
             inl_idna_prevccc = 0;          /* U+200D has ccc of 0     */
             break;                         /* virama rule fulfilled   */
           case 0x3002:   /* dots, see RFC 3490, section 3.1, number 1 */
           case 0xFF0E:
           case 0xFF61:                     /* begin new part          */
             goto p_next_idnlbl;
           default: {
             int inl_ccc = m_get_unicode_canonical_combining_class(uml_ch_source);
             if (inl_ccc && (inl_ccc < inl_idna_prevccc))
               return -1;                   /* cannot be in NFC form   */
             inl_idna_prevccc = inl_ccc;
             if (!m_is_idna_allowed(uml_ch_source))
               return -1;                   /* prohibited non-ASCII char */
             if (m_idna_cannotbe_nfc(unl_prevstrt, uml_ch_source))
               return -1;                   /* cannot be in NFC form   */
             if (!inl_ccc)                  /* remember "starter"      */
               unl_prevstrt = uml_ch_source;
           } break;
         }
       }
       /* store character in tree for later punycode representation    */
       if (--iml_idna_labelspace == 0)      /* over RFC 1034 maxlength */
         return -1;                         /* (limiting also precludes int overflow) */
       if ((iml_idna_labelspace==MAX_IDNAPART_LENGTH) && m_get_unicode_is_combining(uml_ch_source))
         return -1;                         /* combining mark as first in label */
       if (!utl_idna_tn) {                  /* first non-ASCII in this part */
         bol_idna_nohighyet = FALSE;
         iml_len_return += 4;               /* increment length to return, for "xn--" */
       }
       m_idna_add_to_treelist( dslr_idna_treelist, uml_ch_source, utl_idna_tn ++,
                               MAX_IDNAPART_LENGTH-iml_idna_labelspace );
       break;
       p_next_idnlbl:                       /* next dot-separated part */
       if (utl_idna_tn) {                   /* last part had non-ASCII */
         if (utl_idna_openzwnj &&
             !m_idna_zwnj_jtrule_ok( dslr_idna_treelist, utl_idna_openzwnj, utl_idna_tn ))
           return -1;                       /* earlier U+200C not conforming */
         iml_len_return = m_idna_suffixlen( dslr_idna_treelist,
                          iml_len_return-(iml_idna_ps+4), iml_len_return );
         if (iml_len_return > iml_idna_ps+MAX_IDNAPART_LENGTH)
           return -1;                       /* part ("label") too long */
       }
       iml_len_return++;                    /* increment length to return, for '.' */
       iml_idna_ps = iml_len_return;
       iml_idna_labelspace = 1+MAX_IDNAPART_LENGTH;
       utl_idna_openzwnj = 0;
       iel_idna_minuspair = 0;
       inl_idna_prevccc = 255;
       unl_prevstrt = 0;
       utl_idna_tn = 0;
       break;
     case IED_CHS_COPY7A:                   /* idna-prohibited ascii   */
       if (uml_ch_source > 'z')
         return -1;  /* neither IDNA nor something like a IPv6-address */
       iml_len_return++;                    /* increment length to return */
       break;
     case ied_chs_ldap_escaped_utf_8:       /* LDAP UTF-8 escaped      */
       switch (uml_ch_source >> 5) {
         case 0:
           iml_len_return += uml_ch_source==0x00 ? 3 : 1;  /* increment length to return */
           break;
         case 1:
           if (((unsigned int)1<<(uml_ch_source-0x20)) & 0x7800180D) {
             if (bol1 && (char)uml_ch_source=='=') {  /* the first '=' */
               bol1 = FALSE;
               iml_len_return ++;        /* increment length to return */
             } else {
               iml_len_return += 2;      /* increment length to return */
             }
           } else {
             iml_len_return ++;          /* increment length to return */
           }
           break;
         case 2:
           iml_len_return += uml_ch_source==0x5C ? 2 : 1;  /* increment length to return */
           break;
         case 3:
           iml_len_return++;                /* increment length to return */
           break;
         default:
           goto p_enc_utf8_over7bit;
       }
       break;
     case ied_chs_xml_utf_8:                /* UTF-8 with XML-CharRef  */
       if (uml_ch_source < 0xE000) {
         if (uml_ch_source < 0xA0) {
           switch (chrs_xmlent_st[uml_ch_source]) {
             case -1:                       /* no XML-encoding         */
               iml_len_return += (uml_ch_source<0x80 ? 1 : 2);
               break;
             case (int)ied_xcro_txt_start_lt:  /* "&lt;"               */
             case (int)ied_xcro_txt_start_gt:  /* "&gt;"               */
               iml_len_return += 4;
               break;
             case (int)ied_xcro_dec_start:  /* 1 or 2 decimal digits   */
               iml_len_return += (uml_ch_source>=10 ? 5 : 4);
               break;
             case (int)ied_xcro_hex_start:  /* 1 or 2 hexdigits        */
               iml_len_return += (uml_ch_source>=0x10 ? 6 : 5);
               break;
           }
         } else {                           /* 00A0                    */
           if (uml_ch_source < 0xD800)
             iml_len_return += (uml_ch_source<0x0800 ? 2 : 3);
           else                             /* D800                    */
             iml_len_return += 8;           /* "&#xD800;" etc.         */
         }
       } else {                             /* E000                    */
         if (uml_ch_source < 0xFDF0) {
           iml_len_return += (uml_ch_source<0xFDD0 ? 3 : 8 );
         } else {                           /* FDF0                    */
           if ((uml_ch_source&0xFFFE)==0xFFFE) {
             iml_len_return += 8;
             uml_ch_source >>= 16;
             while (uml_ch_source) {
               uml_ch_source >>= 4;
               iml_len_return++;
             }
           } else {
             uml_ch_source >>= 16;
             iml_len_return += 3;
             while (uml_ch_source) {
               uml_ch_source >>= 5;
               iml_len_return++;
             }
           }
         }
       }
       break;
     case ied_chs_utf_8:                    /* Unicode UTF-8           */
       if (   ((uml_ch_source >> 7) == 0)   /* only 7 bits - < 0X80    */
           && (uml_ch_source != 0)) {       /* not zero (Why not zero? Fits to other places in code where U+0000 is encoded with a superfluous extra byte WS 22.5.2012) */
         iml_len_return++;                  /* increment length to return */
         break;
       }
       p_enc_utf8_over7bit:
       if ((uml_ch_source >> 11) == 0) {
         iml_len_return += 2;               /* increment length to return */
         break;
       }
       if ((uml_ch_source >> 16) == 0) {
         iml_len_return += 3;               /* increment length to return */
         break;
       }
       if ((uml_ch_source >> 21) == 0) {
         iml_len_return += 4;               /* increment length to return */
         break;
       }
       if ((uml_ch_source >> 26) == 0) {
         iml_len_return += 5;               /* increment length to return */
         break;
       }
       if ((uml_ch_source >> 31) == 0) {
         iml_len_return += 6;               /* increment length to return */
         break;
       }
       iml_len_return += 7;                 /* increment length to return */
       break;                               /* all done                */
     case ied_chs_xml_wcp_1252:             /* Windows-1252 with XML-CharRef */
       if (uml_ch_source < 0x80) {
         switch (chrs_xmlent_st[uml_ch_source]) {
           case -1:                         /* no XML-encoding         */
             iml_len_return++;
             break;
           case (int)ied_xcro_txt_start_lt:  /* "&lt;"                 */
           case (int)ied_xcro_txt_start_gt:  /* "&gt;"                 */
             iml_len_return += 4;
             break;
           case (int)ied_xcro_dec_start:    /* 1 or 2 decimal digits   */
             iml_len_return += (uml_ch_source>=10 ? 5 : 4);
             break;
           case (int)ied_xcro_hex_start:    /* 1 or 2 hexdigits        */
             iml_len_return += (uml_ch_source>=0x10 ? 6 : 5);
             break;
         }
       } else {                             /* 0080                    */
         iml_len_return ++;                 /* ASCII_REP_CHAR or not XML-enc. */
       }
       break;                               /* all done                */
     case ied_chs_xml_utf_16:               /* UTF-16 with XML-CharRef */
       if (uml_ch_source < 0xE000) {
         if (uml_ch_source < 0xA0) {
           switch (chrs_xmlent_st[uml_ch_source]) {
             case -1:                       /* no XML-encoding         */
               iml_len_return++;
               break;
             case (int)ied_xcro_txt_start_lt:  /* "&lt;"               */
             case (int)ied_xcro_txt_start_gt:  /* "&gt;"               */
               iml_len_return += 4;
               break;
             case (int)ied_xcro_dec_start:  /* 1 or 2 decimal digits   */
               iml_len_return += (uml_ch_source>=10 ? 5 : 4);
               break;
             case (int)ied_xcro_hex_start:  /* 1 or 2 hexdigits        */
               iml_len_return += (uml_ch_source>=0x10 ? 6 : 5);
               break;
           }
         } else {                           /* 00A0                    */
           iml_len_return += (uml_ch_source >= 0xD800 ? 8 : 1);
         }
       } else {                             /* E000                    */
         if (uml_ch_source < 0x10000) {
           if (uml_ch_source < 0xFDF0)
             iml_len_return += (uml_ch_source >= 0xFDD0 ? 8 : 1);
           else                             /* FDF0                    */
             iml_len_return += ((uml_ch_source&0xFFFE)==0xFFFE ? 8 : 1);
         } else {                           /* 10000, "surrogate"      */
           if (uml_ch_source < 0x110000) {
             if ((uml_ch_source&0xFFFE)==0xFFFE)
               iml_len_return += (uml_ch_source>0xFFFFF ? 10 : 9);
             else
               iml_len_return += 2;
           } else {                         /* 0x110000, surrogates not possible */
#if 0
             iml_len_return += 10;
             uml_ch_source >>= 24;
             while (uml_ch_source) {
               iml_len_return++;
               uml_ch_source >>= 4;
             }
#else
             iml_len_return++;              /* one UTF16_REP_CHAR      */
#endif
           }
         }
       }
       break;                               /* all done                */
     CASE_IED_CHS_U16_ALLENDIAN
       if ((uml_ch_source > 0xFFFF) && (uml_ch_source < 0x110000)) {  /* "surrogate" */
         iml_len_return += 2;               /* increment length to return */
       } else {
         iml_len_return++;                  /* increment length to return */
       }
       break;
     CASE_IED_CHS_U32_ALLENDIAN
       iml_len_return++;                    /* increment length to return */
       break;
     default:
       return -1;                           /* cannot copy             */
   }
   achl_cur_source += iml_len_ch_source;
   goto pcheck_00;                          /* check characters        */
} /* end m_len_vx_vx()                                                 */

#undef IED_CHS_COPY7A

/**
* return storage needed for the variable
*  @param ap_source pointer to a string
*  @param imp_len_source a negative value to mean that ap_source is zero-
*                        terminated, or a nonnegative value giving the length
*                        in units (of 1, 2 or 4 bytes depending on charset).
*  @param iep_cs_source encoding in which ap_source is to be interpreted
*  @return the length in bytes (including space for the terminating zero, if
*                               imp_len_source was negative).
*/
extern PTYPE int m_stor_vx( const void *ap_source, int imp_len_source,
                            enum ied_charset iep_cs_source ) {
   int        iml_len;                      /* compute length          */
   const char *achl_inp;                    /* input                   */

   if (imp_len_source == 0) return 0;       /* variable is empty       */
   if (imp_len_source > 0) {                /* not zero-terminated     */
     switch (iep_cs_source) {
       case ied_chs_ascii_850:              /* ASCII 850               */
       case ied_chs_ansi_819:               /* ANSI 819                */
       CASE_IED_CHS_MISCCODEPAGES
       CASE_IED_CHS_ALL_CJK
       CASE_IED_CHS_ISO8859_2TO16
       case ied_chs_utf_8:                  /* Unicode UTF-8           */
       case ied_chs_xml_utf_8:              /* UTF-8 with XML-CharRef  */
       case ied_chs_xml_wcp_1252:           /* Windows-1252 with XML-CharRef */
       case ied_chs_html_1:                 /* HTML character set      */
       case ied_chs_uri_1:                  /* URI, percent-encoded    */
       case ied_chs_idna_1:                 /* IDNA, Punycode          */
       case ied_chs_ldap_escaped_utf_8:     /* LDAP UTF-8 escaped      */
       case ied_chs_hsf_1:                  /* HOB special file system */
         return imp_len_source;             /* single characters       */
       CASE_IED_CHS_U16_ALLENDIAN
       case ied_chs_xml_utf_16:             /* UTF-16 with XML-CharRef */
         return imp_len_source * sizeof(HL_WCHAR);  /* short int       */
       CASE_IED_CHS_U32_ALLENDIAN
         return imp_len_source * sizeof(int);  /* int                  */
       default:
         return -1;                         /* invalid data            */
     }
   }
   iml_len = 0;                             /* reset length            */
   achl_inp = (char *) ap_source;           /* get input               */
   switch (iep_cs_source) {
     case ied_chs_ascii_850:                /* ASCII 850               */
     case ied_chs_ansi_819:                 /* ANSI 819                */
     CASE_IED_CHS_MISCCODEPAGES
     /* the second byte of these wcp_9..-DBCS-sequences is never <0x40 */
     CASE_IED_CHS_ALL_CJK
     CASE_IED_CHS_ISO8859_2TO16
     case ied_chs_utf_8:                    /* Unicode UTF-8           */
     case ied_chs_xml_utf_8:                /* UTF-8 with XML-CharRef  */
     case ied_chs_xml_wcp_1252:             /* Windows-1252 with XML-CharRef */
     case ied_chs_html_1:                   /* HTML character set      */
     case ied_chs_uri_1:                    /* URI, percent-encoded    */
     case ied_chs_idna_1:                   /* IDNA, Punycode          */
     case ied_chs_ldap_escaped_utf_8:       /* LDAP UTF-8 escaped      */
     case ied_chs_hsf_1:                    /* HOB special file system */
       while (*achl_inp) {                  /* search terminating zero */
         achl_inp++;                        /* next character          */
         iml_len++;                         /* increment length        */
       }
       iml_len++;                           /* add length zero         */
       return iml_len;                      /* single characters       */
     CASE_IED_CHS_U16_ALLENDIAN
     case ied_chs_xml_utf_16:               /* UTF-16 with XML-CharRef */
       while (*(achl_inp + 0) || *(achl_inp + 1)) {  /* search terminating zero */
         achl_inp += sizeof(HL_WCHAR);      /* next character          */
         iml_len++;                         /* increment length        */
       }
       iml_len++;                           /* add length zero         */
       return iml_len * sizeof(HL_WCHAR);   /* short int               */
     CASE_IED_CHS_U32_ALLENDIAN
       while (*(achl_inp + 0) || *(achl_inp + 1) || *(achl_inp + 2) || *(achl_inp + 3)) {  /* search terminating zero */
         achl_inp += sizeof(int);           /* next character          */
         iml_len++;                         /* increment length        */
       }
       iml_len++;                           /* add length zero         */
       return iml_len * sizeof(int);        /* int                     */
     default:
       return -1;                           /* invalid data            */
   }
} /* end m_stor_vx()                                                   */

/**
* return storage needed for the variable. The same as m_stor_vx().
*  @param ap_source pointer to a string
*  @param imp_len_source a negative value to mean that ap_source is zero-
*                        terminated, or a nonnegative value giving the length
*                        in units (of 1, 2 or 4 bytes depending on charset).
*  @param iep_cs_source encoding in which ap_source is to be interpreted
*  @return the length in bytes (including space for the terminating zero, if
*                               imp_len_source was negative).
*/
extern PTYPE int m_len_bytes_vx( const void *ap_source, int imp_len_source,
                                 enum ied_charset iep_cs_source ) {
   return m_stor_vx( ap_source, imp_len_source, iep_cs_source );
} /* end m_len_bytes_vx()                                              */

/**
* check if a string is valid
*  @param ap_source input string
*  @param imp_len_source a negative value to mean that ap_source is zero-
*                        terminated, or a nonnegative value giving the length
*  @param iep_cs_source encoding used by ap_source
*  @return whether ap_source is formally ok, however at the moment the
*          detection of formal errors is only implemented for UTF-8 format.
*/
extern PTYPE BOOL m_check_vx( const void *ap_source, int imp_len_source,
                              enum ied_charset iep_cs_source ) {
   int        iml_bc;                       /* byte count in character */
   const char *achl_cur_source;             /* current position parameter */
   const char *achl_end_source;             /* end of parameter        */

   if (imp_len_source == 0) return TRUE;
   if (iep_cs_source == ied_chs_invalid) return FALSE;
   /*UUU for all the non-UTF8 cases, provisionally m_get_vc_ch() in a loop*/
   if (iep_cs_source != ied_chs_utf_8) return TRUE;  /* not Unicode UTF-8 */
   /* Unicode UTF-8                                                    */

   /* calculate end of parameter source                                */
   achl_cur_source = (char *) ap_source;
   achl_end_source = NULL;                  /* still zero-terminated   */
   if (imp_len_source > 0) {                /* length source given     */
     achl_end_source = achl_cur_source + imp_len_source;  /* set end of source */
   }

   p_u8_check_first:                        /* check first byte in sequence */
   if (imp_len_source >= 0) {               /* length source given     */
     if (achl_cur_source >= achl_end_source) return TRUE;
   } else {                                 /* zero-terminated         */
     if (*achl_cur_source == 0) return TRUE;
   }
   iml_bc = chrs_decode_utf_1_tab[ (unsigned char) *achl_cur_source++ ] - 1;
   if (iml_bc < 0) {                        /* only one byte           */
     goto p_u8_check_first;                 /* check first byte in sequence */
   }
   if (iml_bc == 0) {                       /* not allowed as first byte */
     return FALSE;                          /* return error            */
   }
   do {
     if (imp_len_source >= 0) {             /* length source given     */
       if (achl_cur_source >= achl_end_source) return FALSE;
     } else {                               /* zero-terminated         */
       if (*achl_cur_source == 0) return FALSE;
     }
     if ((*((const unsigned char *) achl_cur_source) & 0XC0) != 0X80) return FALSE;
     achl_cur_source++;                     /* next character input    */
     iml_bc--;                              /* decrement count characters */
   } while (iml_bc > 0);
   goto p_u8_check_first;                   /* check first byte in sequence */
} /* end m_check_vx()                                                  */

/**
* perform a comparison of strings, give type of string.
*  The comparison is case-sensitive
*  @param[out] aimp_result 0 if adsp_us_p1 and adsp_us_p2 are equal; else the
*                          absolute value is 1-based index (for adsp_us_p1, in
*                          8/16/32-byte units depending on its encoding) where
*                          the (first) difference is, and the sign is negative
*                          if adsp_us_p2 is higher (sorts below) than adsp_us_p1
*  @param adsp_us_p1 string to compare with adsp_us_p2
*  @param adsp_us_p2 string to compare with adsp_us_p1
*  @return whether successful
*/
extern PTYPE BOOL m_cmp_ucs_ucs( int *aimp_result,
                                 const struct dsd_unicode_string *adsp_us_p1,
                                 const struct dsd_unicode_string *adsp_us_p2 ) {
   return m_cmp_vx_vx( aimp_result,
                       adsp_us_p1->ac_str,  /* address of string       */
                       adsp_us_p1->imc_len_str,  /* length string in elements */
                       adsp_us_p1->iec_chs_str,  /* character set string */
                       adsp_us_p2->ac_str,  /* address of string       */
                       adsp_us_p2->imc_len_str,  /* length string in elements */
                       adsp_us_p2->iec_chs_str );  /* character set string */
} /* end m_cmp_ucs_ucs()                                               */

/**
* perform a comparison of strings, give type of string.
*  The comparison is not case-sensitive
*  @param[out] aimp_result 0 if lowercase of adsp_us_p1 and lowercase of
*                          adsp_us_p2 are equal; else the absolute value is
*                          1-based index (for adsp_us_p1, in 8-, 16- or 32-byte
*                          units depending on its encoding) where the (first)
*                          difference is, and the sign is negative if the
*                          lowercase of adsp_us_p2 is higher (sorts below) than
*                          the lowercase of adsp_us_p1.
*  @param adsp_us_p1 string to compare with adsp_us_p2
*  @param adsp_us_p2 string to compare with adsp_us_p1
*  @return whether successful
*/
extern PTYPE BOOL m_cmpi_ucs_ucs( int *aimp_result,
                                  const struct dsd_unicode_string *adsp_us_p1,
                                  const struct dsd_unicode_string *adsp_us_p2 ) {
   return m_cmpi_vx_vx( aimp_result,
                        adsp_us_p1->ac_str,  /* address of string      */
                        adsp_us_p1->imc_len_str,  /* length string in elements */
                        adsp_us_p1->iec_chs_str,  /* character set string */
                        adsp_us_p2->ac_str,  /* address of string      */
                        adsp_us_p2->imc_len_str,  /* length string in elements */
                        adsp_us_p2->iec_chs_str );  /* character set string */
} /* end m_cmpi_ucs_ucs()                                              */

/**
* copy source string to target
*  @param ap_target destination (output) pointer
*  @param imp_len_target length of output buffer, in 8/16/32-bit units
*  @param iep_cs_target encoding to use for output
*  @param adsp_usc_source input string
*  @return -1 on error, else length of output in 8/16/32-bit units
*/
extern PTYPE int m_cpy_vx_ucs( void *ap_target, int imp_len_target, enum ied_charset iep_cs_target,
                               const struct dsd_unicode_string *adsp_usc_source ) {
   return m_cpy_vx_vx( ap_target,
                       imp_len_target,
                       iep_cs_target,
                       adsp_usc_source->ac_str,  /* address of string  */
                       adsp_usc_source->imc_len_str,  /* length string in elements */
                       adsp_usc_source->iec_chs_str );  /* character set string */
} /* end m_cpy_vx_ucs()                                                */

/** copy to uppercase
*  @param ap_target destination (output) pointer
*  @param imp_len_target length of output buffer, in 8/16/32-bit units
*  @param iep_cs_target encoding to use for output
*  @param adsp_usc_source input string
*  @return -1 on error, else length of output in 8/16/32-bit units
*/
extern PTYPE int m_cpy_uc_vx_ucs( void *ap_target, int imp_len_target,
                                  enum ied_charset iep_cs_target,
                                  const struct dsd_unicode_string *adsp_usc_source ) {
   return m_cpy_uc_vx_vx( ap_target,
                          imp_len_target,
                          iep_cs_target,
                          adsp_usc_source->ac_str,  /* address of string  */
                          adsp_usc_source->imc_len_str,  /* length string in elements */
                          adsp_usc_source->iec_chs_str );  /* character set string */
} /* end m_cpy_uc_vx_ucs()                                             */

/**
* compute length of space needed for target, in elements
*  @param iep_cs_target encoding for the hypothetical output string
*  @param adsp_usc_source input string
*  @return -1 or error, else length in units of 8, 16 or 32 bits (depending on
*          iep_cs_target) that would be needed to express the adsp_usc_source
*          content in iep_cs_target, not including any space for termination.
*/
extern PTYPE int m_len_vx_ucs( enum ied_charset iep_cs_target,
                               const struct dsd_unicode_string *adsp_usc_source ) {
   return m_len_vx_vx( iep_cs_target,
                       adsp_usc_source->ac_str,  /* address of string  */
                       adsp_usc_source->imc_len_str,  /* length string in elements */
                       adsp_usc_source->iec_chs_str );  /* character set string */
} /* end m_len_vx_ucs()                                                */

/**
* return storage needed for the variable
*  @param adsp_usc_source input string
*  @return the length in bytes (including space for the terminating zero, if
*                               adsp_usc_source is of the zero-terminated type).
*/
extern PTYPE int m_len_bytes_ucs( const struct dsd_unicode_string *adsp_usc_source ) {
   return m_len_bytes_vx( adsp_usc_source->ac_str,  /* address of string  */
                          adsp_usc_source->imc_len_str,  /* length string in elements */
                          adsp_usc_source->iec_chs_str );  /* character set string */
} /* end m_len_bytes_ucs()                                             */

/**
* check if a string is valid
*  @param adsp_usc_source input string
*  @return see m_check_vx
*/
extern PTYPE BOOL m_check_ucs( const struct dsd_unicode_string *adsp_usc_source ) {
   /* extern, but does not appear in hob-xslunic1.h  WS 20141017       */
   return m_check_vx( adsp_usc_source->ac_str,  /* address of string   */
                      adsp_usc_source->imc_len_str,  /* length string in elements */
                      adsp_usc_source->iec_chs_str );  /* character set string */
} /* end m_check_ucs()                                                 */

/**
* Decodes a Base64-string.
*  @param[out] aimp_error if defined, is set to one of the HL_ERR_BASE64_*
*                         macros defined in hob-xslunic1.h indicating an error
*                         condition, or to 0 if no error condition was detected
*  @param[out] aimp_pos_error if defined, is set to count of input characters
*                             before an error was detected, or 0 if none.
*  @param achp_target pointer to output area
*  @param[in] imp_len_target length of output buffer, in bytes
*  @param[in] adsp_usc_source input string
*  @return -1 on error, else number of bytes decoded
*/
extern PTYPE int m_get_ucs_base64( int *aimp_error, int *aimp_pos_error,
                                   char *achp_target, int imp_len_target,
                                   const struct dsd_unicode_string *adsp_usc_source ) {
   int        iml1, iml2, iml3, iml4, iml5;  /* working variables      */
   int        iml_inp;                      /* count input             */
   unsigned int uml_ch_int;                 /* character decoded       */
   const char *achl_inp_cur;                /* current position parameter */
   const char *achl_inp_end;                /* end of parameter        */
   char       *achl_out_cur;                /* current position output */
   char       *achl_out_end;                /* end of output           */

   if (aimp_error) *aimp_error = 0;
   if (aimp_pos_error) *aimp_pos_error = 0;

   /* calculate end of parameter                                       */
   achl_inp_cur = (char *) adsp_usc_source->ac_str;
   achl_inp_end = NULL;                     /* still zero-terminated   */
   if (adsp_usc_source->imc_len_str >= 0) {  /* length parameter given */
     switch (adsp_usc_source->iec_chs_str) {
       case ied_chs_ascii_850:              /* ASCII 850               */
       case ied_chs_ansi_819:               /* ANSI 819                */
       CASE_IED_CHS_MISCCODEPAGES           /* various Windows-/DOS-CP */
       CASE_IED_CHS_ALL_CJK                 /* Windows 932/936/949/950 */
       CASE_IED_CHS_ISO8859_2TO16           /* Latin-2..10 and similar */
       CASE_IED_CHS_ESCHEXHEX_U8            /* masked-hexpair encoded  */
       case ied_chs_html_1:                 /* HTML character set      */
       case ied_chs_xml_wcp_1252:     /* Windows-1252 with XML-CharRef */
       case ied_chs_xml_utf_8:              /* UTF-8 with XML-CharRef  */
       case ied_chs_utf_8:                  /* Unicode UTF-8           */
         achl_inp_end = achl_inp_cur + adsp_usc_source->imc_len_str;
         break;
       case ied_chs_xml_utf_16:             /* XML Unicode UTF-16      */
       CASE_IED_CHS_U16_ALLENDIAN           /* UTF-16, both endianness */
         achl_inp_end = achl_inp_cur + adsp_usc_source->imc_len_str * sizeof(HL_WCHAR);
         break;
       CASE_IED_CHS_U32_ALLENDIAN           /* UTF-32, both endianness */
         achl_inp_end = achl_inp_cur + adsp_usc_source->imc_len_str * sizeof(unsigned int);
         break;
       default:                     /* ied_chs_invalid, ied_chs_idna_1 */
         if (aimp_error) *aimp_error = HL_ERR_BASE64_INVCHS;
         return -1;                         /* return error            */
     }
   }

   achl_out_cur = achp_target;              /* current position output */
   achl_out_end = achp_target + imp_len_target;  /* end of output      */

   iml_inp = 0;                             /* count input             */
   iml1 = 4;                                /* set number of characters */
   iml2 = 0;                                /* clear akkumulator       */
   iml3 = 0;                                /* delimiting equals       */
   while (TRUE) {                           /* loop to decode input mime base64 */
     iml4 = m_get_vc_ch( &uml_ch_int, achl_inp_cur, achl_inp_end, adsp_usc_source->iec_chs_str );
     if (iml4 > 0) {                        /* not end of input        */
       if (uml_ch_int >= 0X0100) {
         if (aimp_error) *aimp_error = HL_ERR_BASE64_INVCHAR;
         if (aimp_pos_error) *aimp_pos_error = iml_inp;
         return -1;                         /* return error            */
       }
       iml5 = scrs_from_base64[ uml_ch_int ];  /* get translation      */
       if (iml5 < 0) {                      /* invalid character found */
         if (iml5 == -2) {                  /* delimiting equals found */
           iml3++;                          /* count delimiting equals */
#ifdef BASE64_IGNORE_LBR
         } else if ((uml_ch_int!=10)&&(uml_ch_int!=13)) {  /* ignore linebreak */
#else
         } else {
#endif
           if (aimp_error) *aimp_error = HL_ERR_BASE64_INVCHAR;
           if (aimp_pos_error) *aimp_pos_error = iml_inp;
           return -1;                       /* return error            */
         }
       } else {
         if (iml3 != 0) {                   /* delimiting equals       */
           if (aimp_error) *aimp_error = HL_ERR_BASE64_CHARADEL;
           if (aimp_pos_error) *aimp_pos_error = iml_inp;
           return -1;                       /* return error            */
         }
         iml2 <<= 6;                        /* shift old bits          */
         iml2 |= iml5;                      /* apply new bits          */
         iml1--;                            /* decrement number of characters */
       }
       if (iml1 <= 0) {                     /* output of characters possible */
         iml5 = 3;                          /* set number of output characters */
         do {                               /* loop output characters  */
           if (achl_out_cur >= achl_out_end) {  /* output area exhausted */
             if (aimp_error) *aimp_error = HL_ERR_BASE64_OUTOF;
             if (aimp_pos_error) *aimp_pos_error = iml_inp;
             return -1;                     /* return error            */
           }
           *achl_out_cur++ = (unsigned char) (iml2 >> 16);
           iml2 <<= 8;                      /* shift bits              */
           iml5--;                          /* decrement index         */
         } while (iml5 > 0);
         iml1 = 4;                          /* set number of characters */
         iml2 = 0;                          /* clear akkumulator       */
       }
       achl_inp_cur += iml4;
       iml_inp++;                           /* count input             */
     } else {                               /* something else reported */
       if (iml4 < 0) {                      /* subroutine reported error */
         if (aimp_error) *aimp_error = HL_ERR_BASE64_MISC;
         if (aimp_pos_error) *aimp_pos_error = iml_inp;
         return -1;                         /* return error            */
       }
       /* end of input                                                 */
       iml5 = 0;                            /* set number of output characters */
       if (iml1 < 4) {                      /* not complete sequence   */
         if (iml1 >= 3) {                   /* last bundle one a single input character */
           if (aimp_error) *aimp_error = HL_ERR_BASE64_INPSH;
           if (aimp_pos_error) *aimp_pos_error = iml_inp;
           return -1;                       /* return error            */
         }
         iml2 <<= iml1 * 6;                 /* shift akkumulator to correct position */
//       iml5 = 3 - iml1 - 1;               /* number of remaining output characters  */
         iml5 = 3 - iml1;                   /* number of remaining output characters  */
         iml3 -= iml1;                      /* control delimiting characters */
       }
       if (iml3 != 0) {                     /* wrong number of delimiting characters */
         if (aimp_error) *aimp_error = HL_ERR_BASE64_INVDEL;
         if (aimp_pos_error) *aimp_pos_error = iml_inp;
         return -1;                         /* return error            */
       }
       while (iml5 > 0) {                   /* loop output characters  */
         if (achl_out_cur >= achl_out_end) {  /* output area exhausted */
           if (aimp_error) *aimp_error = HL_ERR_BASE64_OUTOF;
           if (aimp_pos_error) *aimp_pos_error = iml_inp;
           return -1;                       /* return error            */
         }
         *achl_out_cur++ = (unsigned char) (iml2 >> 16);
         iml2 <<= 8;                        /* shift bits              */
         iml5--;                            /* decrement index         */
       }
       return achl_out_cur - achp_target;   /* return number of characters */
     }
   }
} /* end m_get_ucs_base64()                                            */

/**
* Length information in a way like m_get_vc_ch() expects achp_end to be given.
*  @param adsp_ucs a struct with string data
*  @return pointer after the end if the struct has the length stored explicitly,
*          NULL else (zero-terminated variant).
*/
static const char* m_get_limit( const struct dsd_unicode_string *adsp_ucs ) {
   if (adsp_ucs->imc_len_str == -1)
     return NULL;
   switch (adsp_ucs->iec_chs_str) {
     CASE_IED_CHS_U32_ALLENDIAN
         return (const char*)((const int*)(adsp_ucs->ac_str) + adsp_ucs->imc_len_str);
     CASE_IED_CHS_U16_ALLENDIAN
     case ied_chs_xml_utf_16:
         return (const char*)((const HL_WCHAR*)(adsp_ucs->ac_str) + adsp_ucs->imc_len_str);
     default:
         return (const char*)(adsp_ucs->ac_str) + adsp_ucs->imc_len_str;
   }
}

/**
* retrieve a single character, that may be present as an XML-type reference
* (predefined entity by name, or unicode-character by number) in the source
*  @param[out] ump_res pointer to the character as unicode codepoint number
*  @param[in] achp_start from where to start reading the input
*  @param[in] achp_end pointer behind the end of input-buffer,
*                      or NULL if input is from a zero-terminated string
*  @param[in] iep_cs the underlying character encoding used by the input data,
*                      without the XML-reference-encoding level
*  @return negative on error as got from m_get_vc_ch, 0 if end of input reached,
                                                      else read-bytes count
*/
static int m_get_xe_vc_ch( unsigned int *ump_res, const char *achp_start,
                           const char *achp_end, enum ied_charset iep_cs ) {
   int          inl_firstlen, inl_len;      /* bytecounts by underlying call */
   const char   *achl_cur_source;           /* where to read next char */
   unsigned int uml_ch;                     /* char read by underlying call */
   const char   *achl_expect;               /* expected rest of entity name */
   inl_firstlen = m_get_vc_ch( ump_res, achp_start, achp_end, iep_cs );
   if (*ump_res != 0x26 || inl_firstlen <= 0)
     return inl_firstlen;                   /* no '&', not an entity   */
   achl_cur_source = achp_start + inl_firstlen;
           inl_len = m_get_vc_ch( &uml_ch, achl_cur_source, achp_end, iep_cs );
           if (inl_len <= 0) {
             if (inl_len == 0)
               return HL_ERR_UCGETC_INPSH;
              else
               {                            /* no entity recognised    */
               *ump_res = 0x26;             /* pass-through the '&'    */
               return inl_firstlen;
               }
           }
           achl_cur_source += inl_len;
   switch (uml_ch) {
     case 0x61:                             /* 'a' -> "amp" or "apos"  */
           inl_len = m_get_vc_ch( &uml_ch, achl_cur_source, achp_end, iep_cs );
           if (inl_len <= 0) {
             if (inl_len == 0)
               return HL_ERR_UCGETC_INPSH;
              else
               {                            /* no entity recognised    */
               *ump_res = 0x26;             /* pass-through the '&'    */
               return inl_firstlen;
               }
           }
           achl_cur_source += inl_len;
       switch (uml_ch) {
         case 0x6D:                         /* 'm' -> "amp"            */
           *ump_res = 0X26;                 /* expect entity for '&'   */
           achl_expect = chrs_html_amp + 1;
           break;
         case 0x70:                         /* 'p' -> "apos"           */
           *ump_res = 0X27;                 /* expect entity for '\''  */
           achl_expect = chrs_html_apos + 1;
           break;
         default:
               {                            /* no entity recognised    */
               *ump_res = 0x26;             /* pass-through the '&'    */
               return inl_firstlen;
               }
       }
       break;
     case 0x67:                             /* 'g' -> "gt"             */
       *ump_res = 0X3E;                     /* expect entity for '>'   */
       achl_expect = chrs_html_gt;
       break;
     case 0x6C:                             /* 'l' -> "lt"             */
       *ump_res = 0X3C;                     /* expect entity for '<'   */
       achl_expect = chrs_html_lt;
       break;
     case 0x71:                             /* 'q' -> "quot"           */
       *ump_res = 0X22;                     /* expect entity for '"'   */
       achl_expect = chrs_html_quot;
       break;
     case 0x23:                             /* '#' -> unicode number   */
           inl_len = m_get_vc_ch( &uml_ch, achl_cur_source, achp_end, iep_cs );
           if (inl_len <= 0) {
             if (inl_len == 0)
               return HL_ERR_UCGETC_INPSH;
              else
               return HL_ERR_UCGETC_INV;
           }
           achl_cur_source += inl_len;
       if (uml_ch == 0x78) {                /* 'x' -> hexadecimal      */
           inl_len = m_get_vc_ch( &uml_ch, achl_cur_source, achp_end, iep_cs );
           if (inl_len <= 0) {
             if (inl_len == 0)
               return HL_ERR_UCGETC_INPSH;
              else
               return HL_ERR_UCGETC_INV;
           }
           achl_cur_source += inl_len;
         if (uml_ch > 0x39) {               /* greater than digit 9    */
           uml_ch |= 0x20;                  /* folding A..F to a..f    */
           if ((uml_ch < 0x61) || (0x66 < uml_ch))
               return HL_ERR_UCGETC_INV;
           *ump_res = uml_ch-0x57;          /* hexdigit over 9         */
         } else {
           if (uml_ch < 0x30)
               return HL_ERR_UCGETC_INV;
           *ump_res = uml_ch-0x30;          /* hexdigit from 0..9      */
         }
         while (TRUE) {
           inl_len = m_get_vc_ch( &uml_ch, achl_cur_source, achp_end, iep_cs );
           if (inl_len <= 0) {
             if (inl_len == 0)
               return HL_ERR_UCGETC_INPSH;
              else
               return HL_ERR_UCGETC_INV;
           }
           achl_cur_source += inl_len;
           if (uml_ch > 0x39) {             /* greater than digit 9    */
             if (uml_ch == 0x3B)            /* closing ';' found       */
               break;
             uml_ch |= 0x20;                /* folding A..F to a..f    */
             if ((uml_ch < 0x61) || (0x66 < uml_ch))
               return HL_ERR_UCGETC_INV;
             *ump_res = (*ump_res<<4) + uml_ch-0x57;  /* hexdigit over 9 */
           } else {
             if (uml_ch < 0x30)
               return HL_ERR_UCGETC_INV;
             *ump_res = (*ump_res<<4) + uml_ch-0x30;  /* hexdigit from 0..9 */
           }
         }
       } else {                             /* decimal unicode number  */
         uml_ch ^= 0x30;
         if (uml_ch > 9)
               return HL_ERR_UCGETC_INV;
         *ump_res = uml_ch;
         while (TRUE) {
           inl_len = m_get_vc_ch( &uml_ch, achl_cur_source, achp_end, iep_cs );
           if (inl_len <= 0) {
             if (inl_len == 0)
               return HL_ERR_UCGETC_INPSH;
              else
               return HL_ERR_UCGETC_INV;
           }
           achl_cur_source += inl_len;
           uml_ch ^= 0x30;
           if (uml_ch > 9) {
             if (uml_ch == 11)              /* closing ';' found       */
               break;
               return HL_ERR_UCGETC_INV;
           }
           *ump_res = *ump_res * 10 + uml_ch;
         }
       }
       if (*ump_res > 0x10FFFF)             /* too big for unicode     */
         *ump_res = UTF16_REP_CHAR;
       return achl_cur_source - achp_start;  /* character reference found */
     default:
               {                            /* no entity recognised    */
               *ump_res = 0x26;             /* pass-through the '&'    */
               return inl_firstlen;
               }
   }
   while (TRUE) {                           /* look for expected name  */
           inl_len = m_get_vc_ch( &uml_ch, achl_cur_source, achp_end, iep_cs );
           if (inl_len <= 0) {
             if (inl_len == 0)
               return HL_ERR_UCGETC_INPSH;
              else
               {                            /* no entity recognised    */
               *ump_res = 0x26;             /* pass-through the '&'    */
               return inl_firstlen;
               }
           }
           achl_cur_source += inl_len;
     if (*++achl_expect == 0) {             /* at end of expected name */
       if (uml_ch != 0x3B)                  /* test for closing ';'    */
               {                            /* no entity recognised    */
               *ump_res = 0x26;             /* pass-through the '&'    */
               return inl_firstlen;
               }
       return achl_cur_source - achp_start; /* entity was found        */
     }
     if ((unsigned char)(*achl_expect) != uml_ch)  /* compare with expected   */
               {                            /* no entity recognised    */
               *ump_res = 0x26;             /* pass-through the '&'    */
               return inl_firstlen;
               }
   }
} /* end m_get_xe_vc_ch()                                              */

/**
* retrieve a single character
*  @param[out] ump_res pointer to the character as unicode codepoint number
*  @param[in] achp_start from where to start reading the input
*  @param[in] achp_end pointer behind the end of input-buffer,
*                      or NULL if input is from a zero-terminated string
*  @param[in] iep_cs the character encoding used by the input data
*  @return negative on error, namely 
*            HL_ERR_UCGETC_INPSH  if it would be fixable by more data after end
*            HL_ERR_UCGETC_META   reached "outside"-part (used only by ldap yet)
*            HL_ERR_UCGETC_INV    on any other error in *achp_start content
*            HL_ERR_UCGETC_INVCHS if iep_cs is not implemented by this function;
*          0 if end of input reached; else count of bytes that were read
*/
extern PTYPE int m_get_vc_ch_ex( unsigned int *ump_res, const char *achp_start,
                                 const char *achp_end, enum ied_charset iep_cs )
{
    /* 20161028 SM */
    return m_get_vc_ch(ump_res, achp_start, achp_end, iep_cs);
}

/**
* retrieve a single character
*  @param[out] ump_res pointer to the character as unicode codepoint number
*  @param[in] achp_start from where to start reading the input
*  @param[in] achp_end pointer behind the end of input-buffer,
*                      or NULL if input is from a zero-terminated string
*  @param[in] iep_cs the character encoding used by the input data
*  @return negative on error, namely 
*            HL_ERR_UCGETC_INPSH  if it would be fixable by more data after end
*            HL_ERR_UCGETC_META   reached "outside"-part (used only by ldap yet)
*            HL_ERR_UCGETC_INV    on any other error in *achp_start content
*            HL_ERR_UCGETC_INVCHS if iep_cs is not implemented by this function;
*          0 if end of input reached; else count of bytes that were read
*/
static int m_get_vc_ch( unsigned int *ump_res, const char *achp_start,
                        const char *achp_end, enum ied_charset iep_cs ) {
   int         iml1, iml2, iml3;            /* working-variables       */
   char        chl1;                        /* working-variable        */
   const char *achl1;                       /* working-variable        */

   if (achp_end) {                          /* not zero-terminated     */
     if (achp_start >= achp_end) return 0;  /* end of string found     */
#ifndef B120326
   } else {                                 /* maybe all parameters NULL */
     if (achp_start == NULL) return 0;      /* end of string found     */
#endif
   }
   switch (iep_cs) {
     case ied_chs_ascii_850:                /* ASCII 850               */
       if (achp_end == NULL) {              /* is zero-terminated      */
         if (*achp_start == 0) {            /* zero at end             */
           return 0;                        /* end of string found     */
         }
       }
       *ump_res = (unsigned char) ucrg_tab_850_to_819[ *((unsigned char *) achp_start) ];
       return 1;                            /* length of character is one */
     case ied_chs_ansi_819:                 /* ANSI 819                */
       if (achp_end == NULL) {              /* is zero-terminated      */
         if (*achp_start == 0) {            /* zero at end             */
           return 0;                        /* end of string found     */
         }
       }
       *ump_res = (unsigned char) *achp_start;  /* character not translated */
       return 1;                            /* length of character is one */
     case ied_chs_oem_437:                  /* DOS-Codepage 437        */
       if (achp_end == NULL) {              /* is zero-terminated      */
         if (*achp_start == 0) {            /* zero at end             */
           return 0;                        /* end of string found     */
         }
       }
       *ump_res = usrg_tab_437_to_uni[ *((unsigned char *) achp_start) ];
       return 1;                            /* length of character is one */
     case ied_chs_wcp_874:                  /* Windows-Codepage  874   */
       if (achp_end == NULL) {              /* is zero-terminated      */
         if (*achp_start == 0) {            /* zero at end             */
           return 0;                        /* end of string found     */
         }
       }
       *ump_res = usrg_tab_874_to_uni[ *((unsigned char *) achp_start) ];
       return 1;                            /* length of character is one */
     case ied_chs_wcp_1250:                 /* Windows-Codepage 1250   */
       if (achp_end == NULL) {              /* is zero-terminated      */
         if (*achp_start == 0) {            /* zero at end             */
           return 0;                        /* end of string found     */
         }
       }
       *ump_res = usrg_tab_1250_to_uni[ *((unsigned char *) achp_start) ];
       return 1;                            /* length of character is one */
     case ied_chs_wcp_1251:                 /* Windows-Codepage 1251   */
       if (achp_end == NULL) {              /* is zero-terminated      */
         if (*achp_start == 0) {            /* zero at end             */
           return 0;                        /* end of string found     */
         }
       }
       *ump_res = usrg_tab_1251_to_uni[ *((unsigned char *) achp_start) ];
       return 1;                            /* length of character is one */
     case ied_chs_xml_wcp_1252:             /* Windows-1252 with XML-CharRef */
       return m_get_xe_vc_ch( ump_res, achp_start, achp_end, ied_chs_wcp_1252 );
     case ied_chs_wcp_1252:                 /* Windows-Codepage 1252   */
       if (achp_end == NULL) {              /* is zero-terminated      */
         if (*achp_start == 0) {            /* zero at end             */
           return 0;                        /* end of string found     */
         }
       }
       *ump_res = usrg_tab_1252_to_uni[ *((unsigned char *) achp_start) ];
       return 1;                            /* length of character is one */
     case ied_chs_wcp_1253:                 /* Windows-Codepage 1253   */
       if (achp_end == NULL) {              /* is zero-terminated      */
         if (*achp_start == 0) {            /* zero at end             */
           return 0;                        /* end of string found     */
         }
       }
       *ump_res = usrg_tab_1253_to_uni[ *((unsigned char *) achp_start) ];
       return 1;                            /* length of character is one */
     case ied_chs_wcp_1254:                 /* Windows-Codepage 1254   */
       if (achp_end == NULL) {              /* is zero-terminated      */
         if (*achp_start == 0) {            /* zero at end             */
           return 0;                        /* end of string found     */
         }
       }
       *ump_res = usrg_tab_1254_to_uni[ *((unsigned char *) achp_start) ];
       return 1;                            /* length of character is one */
     case ied_chs_wcp_1255:                 /* Windows-Codepage 1255   */
       if (achp_end == NULL) {              /* is zero-terminated      */
         if (*achp_start == 0) {            /* zero at end             */
           return 0;                        /* end of string found     */
         }
       }
       *ump_res = usrg_tab_1255_to_uni[ *((unsigned char *) achp_start) ];
       return 1;                            /* length of character is one */
     case ied_chs_wcp_1256:                 /* Windows-Codepage 1256   */
       if (achp_end == NULL) {              /* is zero-terminated      */
         if (*achp_start == 0) {            /* zero at end             */
           return 0;                        /* end of string found     */
         }
       }
       *ump_res = usrg_tab_1256_to_uni[ *((unsigned char *) achp_start) ];
       return 1;                            /* length of character is one */
     case ied_chs_wcp_1257:                 /* Windows-Codepage 1257   */
       if (achp_end == NULL) {              /* is zero-terminated      */
         if (*achp_start == 0) {            /* zero at end             */
           return 0;                        /* end of string found     */
         }
       }
       *ump_res = usrg_tab_1257_to_uni[ *((unsigned char *) achp_start) ];
       return 1;                            /* length of character is one */
     case ied_chs_wcp_1258:                 /* Windows-Codepage 1258   */
       if (achp_end == NULL) {              /* is zero-terminated      */
         if (*achp_start == 0) {            /* zero at end             */
           return 0;                        /* end of string found     */
         }
       }
       *ump_res = usrg_tab_1258_to_uni[ *((unsigned char *) achp_start) ];
       return 1;                            /* length of character is one */
     case ied_chs_iso8859_2:                /* ISO 8859-2              */
       if (achp_end == NULL) {              /* is zero-terminated      */
         if (*achp_start == 0) {            /* zero at end             */
           return 0;                        /* end of string found     */
         }
       }
       *ump_res = usrg_tab_i02_to_uni[ *((unsigned char *) achp_start) ];
       return 1;                            /* length of character is one */
     case ied_chs_iso8859_3:                /* ISO 8859-3              */
       if (achp_end == NULL) {              /* is zero-terminated      */
         if (*achp_start == 0) {            /* zero at end             */
           return 0;                        /* end of string found     */
         }
       }
       *ump_res = usrg_tab_i03_to_uni[ *((unsigned char *) achp_start) ];
       return 1;                            /* length of character is one */
     case ied_chs_iso8859_4:                /* ISO 8859-4              */
       if (achp_end == NULL) {              /* is zero-terminated      */
         if (*achp_start == 0) {            /* zero at end             */
           return 0;                        /* end of string found     */
         }
       }
       *ump_res = usrg_tab_i04_to_uni[ *((unsigned char *) achp_start) ];
       return 1;                            /* length of character is one */
     case ied_chs_iso8859_5:                /* ISO 8859-5              */
       if (achp_end == NULL) {              /* is zero-terminated      */
         if (*achp_start == 0) {            /* zero at end             */
           return 0;                        /* end of string found     */
         }
       }
       *ump_res = usrg_tab_i05_to_uni[ *((unsigned char *) achp_start) ];
       return 1;                            /* length of character is one */
     case ied_chs_iso8859_6:                /* ISO 8859-6              */
       if (achp_end == NULL) {              /* is zero-terminated      */
         if (*achp_start == 0) {            /* zero at end             */
           return 0;                        /* end of string found     */
         }
       }
       *ump_res = usrg_tab_i06_to_uni[ *((unsigned char *) achp_start) ];
       return 1;                            /* length of character is one */
     case ied_chs_iso8859_7:                /* ISO 8859-7              */
       if (achp_end == NULL) {              /* is zero-terminated      */
         if (*achp_start == 0) {            /* zero at end             */
           return 0;                        /* end of string found     */
         }
       }
       *ump_res = usrg_tab_i07_to_uni[ *((unsigned char *) achp_start) ];
       return 1;                            /* length of character is one */
     case ied_chs_iso8859_8:                /* ISO 8859-8              */
       if (achp_end == NULL) {              /* is zero-terminated      */
         if (*achp_start == 0) {            /* zero at end             */
           return 0;                        /* end of string found     */
         }
       }
       *ump_res = usrg_tab_i08_to_uni[ *((unsigned char *) achp_start) ];
       return 1;                            /* length of character is one */
     case ied_chs_iso8859_9:                /* ISO 8859-9              */
       if (achp_end == NULL) {              /* is zero-terminated      */
         if (*achp_start == 0) {            /* zero at end             */
           return 0;                        /* end of string found     */
         }
       }
       *ump_res = usrg_tab_i09_to_uni[ *((unsigned char *) achp_start) ];
       return 1;                            /* length of character is one */
     case ied_chs_iso8859_10:               /* ISO 8859-10             */
       if (achp_end == NULL) {              /* is zero-terminated      */
         if (*achp_start == 0) {            /* zero at end             */
           return 0;                        /* end of string found     */
         }
       }
       *ump_res = usrg_tab_i10_to_uni[ *((unsigned char *) achp_start) ];
       return 1;                            /* length of character is one */
     case ied_chs_iso8859_11:               /* ISO 8859-11             */
       if (achp_end == NULL) {              /* is zero-terminated      */
         if (*achp_start == 0) {            /* zero at end             */
           return 0;                        /* end of string found     */
         }
       }
       *ump_res = usrg_tab_i11_to_uni[ *((unsigned char *) achp_start) ];
       return 1;                            /* length of character is one */
     case ied_chs_iso8859_13:               /* ISO 8859-13             */
       if (achp_end == NULL) {              /* is zero-terminated      */
         if (*achp_start == 0) {            /* zero at end             */
           return 0;                        /* end of string found     */
         }
       }
       *ump_res = usrg_tab_i13_to_uni[ *((unsigned char *) achp_start) ];
       return 1;                            /* length of character is one */
     case ied_chs_iso8859_14:               /* ISO 8859-14             */
       if (achp_end == NULL) {              /* is zero-terminated      */
         if (*achp_start == 0) {            /* zero at end             */
           return 0;                        /* end of string found     */
         }
       }
       *ump_res = usrg_tab_i14_to_uni[ *((unsigned char *) achp_start) ];
       return 1;                            /* length of character is one */
     case ied_chs_iso8859_15:               /* ISO 8859-15             */
       if (achp_end == NULL) {              /* is zero-terminated      */
         if (*achp_start == 0) {            /* zero at end             */
           return 0;                        /* end of string found     */
         }
       }
       *ump_res = usrg_tab_i15_to_uni[ *((unsigned char *) achp_start) ];
       return 1;                            /* length of character is one */
     case ied_chs_iso8859_16:               /* ISO 8859-16             */
       if (achp_end == NULL) {              /* is zero-terminated      */
         if (*achp_start == 0) {            /* zero at end             */
           return 0;                        /* end of string found     */
         }
       }
       *ump_res = usrg_tab_i16_to_uni[ *((unsigned char *) achp_start) ];
       return 1;                            /* length of character is one */
     CASE_IED_CHS_ALL_CJK
       iml1 = m_get_tab_mb_firstbytes(iep_cs)[ *((unsigned char *) achp_start) ];
       if (iml1==0xFFFF) {                  /* two-byte code           */
         if (achp_start+1 >= achp_end)
           return -1; 
         *ump_res = m_get_tab_mb_to_uni(iep_cs)[ *((unsigned char *) achp_start) << 8
                                               | *((unsigned char *) achp_start + 1) ];
         if (*ump_res==0) {                 /* not a defined byte pair */
           *ump_res = UTF16_REP_CHAR;
           return 1;
         }
         return 2;                          /* length of character is two */
       } else {                             /* one-byte code           */
         if (achp_end == NULL) {            /* is zero-terminated      */
           if (iml1 == 0) {                 /* zero at end             */
             return 0;                      /* end of string found     */
           }
         }
         *ump_res = iml1;
         return 1;                          /* length of character is one */
       }
     case ied_chs_xml_utf_8:                /* UTF-8 with XML-CharRef  */
       return m_get_xe_vc_ch( ump_res, achp_start, achp_end, ied_chs_utf_8 );
     case ied_chs_utf_8:                    /* Unicode UTF-8           */
       if (((signed char) *achp_start) >= 0) {  /* MSB not set         */
         if (achp_end == NULL) {            /* is zero-terminated      */
           if (*achp_start == 0) {          /* zero at end             */
             return 0;                      /* end of string found     */
           }
         }
         *ump_res = (unsigned char) *achp_start;  /* character seven bits */
         return 1;                          /* return length one       */
       }
       *ump_res = (unsigned char) *achp_start++;
       iml1 = chrs_decode_utf_1_tab[ *ump_res ] - 1;  /* get number of UTF-8 characters */
       if (iml1 <= 0) return HL_ERR_UCGETC_INV;  /* the character is invalid */
       iml2 = iml1 + 1;                     /* save length to return   */
       *ump_res &= 0XFF >> (iml1 + 1);      /* valid bits              */
       do {                                 /* loop to find additional UTF-8 characters */
         if ((achp_end) && (achp_start >= achp_end))
           return HL_ERR_UCGETC_INPSH;      /* additional UTF-8 character does not follow */
         if ((((unsigned char) *achp_start) & 0XC0) != 0X80)
           return HL_ERR_UCGETC_INV;        /* not valid UTF-8 digit   */
         *ump_res <<= 6;                    /* shift old bits          */
         *ump_res |= ((unsigned char) *achp_start) & 0X3F;  /* apply new bits */
         achp_start++;
         iml1--;                            /* decrement index         */
       } while (iml1 > 0);
       return iml2;                         /* length of character     */
     case ied_chs_html_1:                   /* HTML character set      */
       if (*((signed char *) achp_start) < 0) {  /* invalid character  */
         return HL_ERR_UCGETC_INV;          /* invalid                 */
       }
       if (achp_end == NULL) {              /* is zero-terminated      */
         if (*achp_start == 0) {            /* zero at end             */
           return 0;                        /* end of string found     */
         }
       }
       if (*achp_start != '&') {            /* not control character   */
         *ump_res = *achp_start;            /* return this character   */
         return 1;                          /* length of character is one */
       }
       return m_get_html_1_a( ump_res, achp_start + 1, achp_end );
     case ied_chs_ldap_escaped_utf_8:
       if (*achp_start == '\\') {           /* is control character    */
         achl1 = achp_start;                /* save start for return   */
         achp_start++;
         if ((achp_end) && (achp_start >= achp_end))
           return HL_ERR_UCGETC_INPSH;      /* content does not follow */
         if (((*achp_start & 0xE0) == 0x20)
             ? (((unsigned int)1<<(*achp_start-0x20)) & 0x7800180D)
             : (*achp_start=='\\')) {       /* valid 2-byte sequence   */
           *ump_res = *achp_start;          /* return this character   */
           return 2;                        /* a '\' and the character */
         } else {
           if ((*achp_start >= '0') && (*achp_start <= '9')) {
             *ump_res = *achp_start - '0';
           } else if ((*achp_start >= 'A') && (*achp_start <= 'F')) {
             *ump_res = *achp_start - 'A' + 10;
           } else if ((*achp_start >= 'a') && (*achp_start <= 'f')) {
             *ump_res = *achp_start - 'a' + 10;
           } else {                           /* invalid hexa digit      */
             return (achp_end||*achp_start) ? HL_ERR_UCGETC_INV  /* invalid */
                                            : HL_ERR_UCGETC_INPSH;
           }
           achp_start++;
           if ((achp_end) && (achp_start >= achp_end))
             return HL_ERR_UCGETC_INPSH;    /* hex digits do not follow */
           *ump_res <<= 4;                  /* shift old value         */
           if ((*achp_start >= '0') && (*achp_start <= '9')) {
             *ump_res |= *achp_start - '0';
           } else if ((*achp_start >= 'A') && (*achp_start <= 'F')) {
             *ump_res |= *achp_start - 'A' + 10;
           } else if ((*achp_start >= 'a') && (*achp_start <= 'f')) {
             *ump_res |= *achp_start - 'a' + 10;
           } else {                           /* invalid hexa digit      */
             return (achp_end||*achp_start) ? HL_ERR_UCGETC_INV  /* invalid */
                                            : HL_ERR_UCGETC_INPSH;
           }
         }
       } else {                             /* not control character   */
         if (*achp_start == 0) {            /* zero byte found         */
           if (achp_end == NULL) {          /* is zero-terminated      */
             return 0;                      /* end of string found     */
           } else {
             return HL_ERR_UCGETC_INV;      /* may not occur unescaped */
           }
         }
         if ( ((*achp_start&0xE0) == 0x20) &&
              (((unsigned int)1<<(*achp_start-0x20)) & 0x58001804) ) {
           if (((unsigned int)1<<(*achp_start-0x20)) & 0x1800) {  /* 0x08001800 with ';' */
             return HL_ERR_UCGETC_META;     /* unescaped ',' or '+'    */
           } else {
             return HL_ERR_UCGETC_INV;      /* may not occur unescaped */
           }
         }
         achl1 = achp_start;                /* save start for return   */
         *ump_res = *(unsigned char*)achp_start;
       }
       if ((*ump_res >> 7) == 0) return 1+achp_start-achl1;  /* is single character */
       iml1 = chrs_decode_utf_1_tab[ *ump_res ] - 1;  /* get number of UTF-8 characters */
       if (iml1 <= 0) return HL_ERR_UCGETC_INV;  /* the character is invalid */
       *ump_res &= 0XFF >> (iml1 + 1);      /* valid bits              */
       do {                                 /* loop to find additional UTF-8 characters */
         achp_start++;
         if ((achp_end) && (achp_start >= achp_end))
           return HL_ERR_UCGETC_INPSH;      /* UTF-8 character does not follow */
         *ump_res <<= 6;                    /* shift old bits          */
         if (*achp_start == '\\') {         /* is control character    */
           achp_start++;
           if ((achp_end) && ((achp_start + 1) >= achp_end))
             return HL_ERR_UCGETC_INPSH;    /* UTF-8 character does not follow */
           if ((*achp_start >= '0') && (*achp_start <= '9')) {
             iml3 = *achp_start - '0';
           } else if ((*achp_start >= 'A') && (*achp_start <= 'F')) {
             iml3 = *achp_start - 'A' + 10;
           } else if ((*achp_start >= 'a') && (*achp_start <= 'f')) {
             iml3 = *achp_start - 'a' + 10;
           } else {                           /* invalid hexa digit      */
             return (achp_end||*achp_start) ? HL_ERR_UCGETC_INV  /* invalid */
                                            : HL_ERR_UCGETC_INPSH;
           }
           if ((iml3 >> 2) != 2) return HL_ERR_UCGETC_INV;  /* not valid UTF-8 digit */
           achp_start++;
           iml3 <<= 4;                      /* shift bits found        */
           if ((*achp_start >= '0') && (*achp_start <= '9')) {
             iml3 |= *achp_start - '0';
           } else if ((*achp_start >= 'A') && (*achp_start <= 'F')) {
             iml3 |= *achp_start - 'A' + 10;
           } else if ((*achp_start >= 'a') && (*achp_start <= 'f')) {
             iml3 |= *achp_start - 'a' + 10;
           } else {                           /* invalid hexa digit      */
             return (achp_end||*achp_start) ? HL_ERR_UCGETC_INV  /* invalid */
                                            : HL_ERR_UCGETC_INPSH;
           }
           *ump_res |= iml3 & 0X3F;         /* apply new bits          */
         } else {                           /* not control character   */
           if ((*achp_start & 0xC0) != 0x80)  /* not valid UTF-8 digit */
             return (achp_end||*achp_start) ? HL_ERR_UCGETC_INV  /* invalid */
                                            : HL_ERR_UCGETC_INPSH;
           *ump_res |= *achp_start & 0X3F;  /* apply new bits          */
         }
         iml1--;                            /* decrement index         */
       } while (iml1 > 0);
       return 1 + achp_start - achl1;       /* length of character     */
       break;
     do {  /* variant of Duffs device, the "break" go to the end of this pseudoloop */
     case ied_chs_uri_1:
       chl1 = '%';
       break;
     case ied_chs_hsf_1:
       chl1 = '_';
       break;
     } while (FALSE);       /* end of the pseudoloop   */
       if (*((signed char *) achp_start) < 0) {  /* invalid character  */
         return HL_ERR_UCGETC_INV;          /* invalid                 */
       }
       if (achp_end == NULL) {              /* is zero-terminated      */
         if (*achp_start == 0) {            /* zero at end             */
           return 0;                        /* end of string found     */
         }
       }
       if (*achp_start != chl1) {           /* not control character   */
         *ump_res = *achp_start;            /* return this character   */
         return 1;                          /* length of character is one */
       }
       achp_start++;
       if ((achp_end) && (achp_start >= achp_end))
         return HL_ERR_UCGETC_INPSH;        /* hex digits do not follow */
       if ((*achp_start >= '0') && (*achp_start <= '9')) {
         *ump_res = *achp_start - '0';
       } else if ((*achp_start >= 'A') && (*achp_start <= 'F')) {
         *ump_res = *achp_start - 'A' + 10;
       } else if ((*achp_start >= 'a') && (*achp_start <= 'f')) {
         *ump_res = *achp_start - 'a' + 10;
       } else {                           /* invalid hexa digit      */
         return (achp_end||*achp_start) ? HL_ERR_UCGETC_INV  /* invalid */
                                        : HL_ERR_UCGETC_INPSH;
       }
       achp_start++;
       if ((achp_end) && (achp_start >= achp_end))
         return HL_ERR_UCGETC_INPSH;        /* hex digits do not follow */
       *ump_res <<= 4;                      /* shift old value         */
       if ((*achp_start >= '0') && (*achp_start <= '9')) {
         *ump_res |= *achp_start - '0';
       } else if ((*achp_start >= 'A') && (*achp_start <= 'F')) {
         *ump_res |= *achp_start - 'A' + 10;
       } else if ((*achp_start >= 'a') && (*achp_start <= 'f')) {
         *ump_res |= *achp_start - 'a' + 10;
       } else {                           /* invalid hexa digit      */
         return (achp_end||*achp_start) ? HL_ERR_UCGETC_INV  /* invalid */
                                        : HL_ERR_UCGETC_INPSH;
       }
       if ((*ump_res >> 7) == 0) return 3;  /* is single character     */
       iml1 = chrs_decode_utf_1_tab[ *ump_res ] - 1;  /* get number of UTF-8 characters */
       if (iml1 <= 0) return HL_ERR_UCGETC_INV;  /* the character is invalid */
       iml2 = 3 * (iml1 + 1);               /* save length to return   */
       *ump_res &= 0XFF >> (iml1 + 1);      /* valid bits              */
       if ((achp_end) && ((achp_start + iml2 - 3) >= achp_end))
         return HL_ERR_UCGETC_INPSH;  /* enough additional UTF-8 characters do not follow */
       do {                                 /* loop to find additional UTF-8 characters */
         achp_start++;
         if (*achp_start != chl1) return HL_ERR_UCGETC_INV;  /* not control character */
         achp_start++;
         if ((*achp_start >= '0') && (*achp_start <= '9')) {
           iml3 = *achp_start - '0';
         } else if ((*achp_start >= 'A') && (*achp_start <= 'F')) {
           iml3 = *achp_start - 'A' + 10;
         } else if ((*achp_start >= 'a') && (*achp_start <= 'f')) {
           iml3 = *achp_start - 'a' + 10;
         } else {                           /* invalid hexa digit      */
           return (achp_end||*achp_start) ? HL_ERR_UCGETC_INV  /* invalid */
                                          : HL_ERR_UCGETC_INPSH;
         }
         if ((iml3 >> 2) != 2) return HL_ERR_UCGETC_INV;  /* not valid UTF-8 digit */
         achp_start++;
         iml3 <<= 4;                        /* shift bits found        */
         if ((*achp_start >= '0') && (*achp_start <= '9')) {
           iml3 |= *achp_start - '0';
         } else if ((*achp_start >= 'A') && (*achp_start <= 'F')) {
           iml3 |= *achp_start - 'A' + 10;
         } else if ((*achp_start >= 'a') && (*achp_start <= 'f')) {
           iml3 |= *achp_start - 'a' + 10;
         } else {                           /* invalid hexa digit      */
           return (achp_end||*achp_start) ? HL_ERR_UCGETC_INV  /* invalid */
                                          : HL_ERR_UCGETC_INPSH;
         }
         *ump_res <<= 6;                    /* shift old bits          */
         *ump_res |= iml3 & 0X3F;           /* apply new bits          */
         iml1--;                            /* decrement index         */
       } while (iml1 > 0);
       return iml2;                         /* length of character     */
     case ied_chs_xml_utf_16:               /* UTF-16 with XML-CharRef */
       return m_get_xe_vc_ch( ump_res, achp_start, achp_end, ied_chs_utf_16 );
     case ied_chs_utf_16:                   /* Unicode UTF-16 = WCHAR  */
       if (achp_end == NULL) {              /* is zero-terminated      */
         if (*((HL_WCHAR *) achp_start) == 0) {  /* zero at end        */
           return 0;                        /* end of string found     */
         }
       }
       *ump_res = *((HL_WCHAR *) achp_start);  /* character not translated */
       if ((*ump_res^0xD800) < 1024) {      /* got high surrogate      */
         achp_start+=2;
         if (achp_end == NULL) {            /* is zero-terminated      */
           if (*((HL_WCHAR *) achp_start) == 0)  /* zero at end        */
             return HL_ERR_UCGETC_INPSH;    /* low surrogate does not follow */
         } else {
           if (achp_start+1 >= achp_end)
             return HL_ERR_UCGETC_INPSH;    /* low surrogate does not follow */
         }
         if ((*((HL_WCHAR *) achp_start) & 0xFC00) != 0xDC00)
           return HL_ERR_UCGETC_INV;        /* invalid: no low surrogate */
         *ump_res = ((*ump_res & 0x03FF) + 0x40) << 10  /* high 10 bits */
                  | (*((HL_WCHAR *) achp_start) & 0x03FF);  /* low 10 bits */
         return 2*sizeof(HL_WCHAR);         /* length of surrogate pair */
       } else {
         return sizeof(HL_WCHAR);           /* length of character UTF-16 */
       }
     case ied_chs_be_utf_16:                /* Unicode UTF-16 big endian */
       if (achp_end == NULL) {              /* is zero-terminated      */
         if (   (*((char *) achp_start + 0) == 0)  /* zero at end first byte */
             && (*((char *) achp_start + 1) == 0)) {  /* zero at end second byte */
           return 0;                        /* end of string found     */
         }
       }
       *ump_res = (*((unsigned char *) achp_start + 0) << 8)
                    | *((unsigned char *) achp_start + 1);
       if ((*ump_res^0xD800) < 1024) {      /* got high surrogate      */
         achp_start+=3;
         if (achp_end == NULL) {            /* is zero-terminated      */
           if (   (*((char *) achp_start - 1) == 0)  /* zero at end first byte */
               && (*((char *) achp_start + 0) == 0)) /* zero at end second byte */
             return HL_ERR_UCGETC_INPSH;    /* low surrogate does not follow */
         } else {
           if (achp_start >= achp_end)
             return HL_ERR_UCGETC_INPSH;    /* low surrogate does not follow */
         }
         if ((*((char *) achp_start - 1) & 0xFC) != 0xDC)
           return HL_ERR_UCGETC_INV;        /* invalid: no low surrogate */
         *ump_res = ((*ump_res & 0x03FF) + 0x40) << 10  /* high 10 bits */
                  | ((*((unsigned char *) achp_start - 1) & 3) << 8)  /* bit 8..9 */
                  | *((unsigned char *) achp_start);  /* low 10 bits   */
         return 2*sizeof(HL_WCHAR);         /* length of surrogate pair */
       } else {
         return sizeof(HL_WCHAR);           /* length of character UTF-16 */
       }
     case ied_chs_le_utf_16:                /* Unicode UTF-16 little endian */
       if (achp_end == NULL) {              /* is zero-terminated      */
         if (   (*((char *) achp_start + 0) == 0)  /* zero at end first byte */
             && (*((char *) achp_start + 1) == 0)) {  /* zero at end second byte */
           return 0;                        /* end of string found     */
         }
       }
       *ump_res = *((unsigned char *) achp_start + 0)
                    | (*((unsigned char *) achp_start + 1) << 8);
       if ((*ump_res^0xD800) < 1024) {      /* got high surrogate      */
         achp_start+=3;
         if (achp_end == NULL) {            /* is zero-terminated      */
           if (   (*((char *) achp_start - 1) == 0)  /* zero at end first byte */
               && (*((char *) achp_start + 0) == 0)) /* zero at end second byte */
             return HL_ERR_UCGETC_INPSH;    /* low surrogate does not follow */
         } else {
           if (achp_start >= achp_end)
             return HL_ERR_UCGETC_INPSH;    /* low surrogate does not follow */
         }
         if ((*((char *) achp_start) & 0xFC) != 0xDC)
           return HL_ERR_UCGETC_INV;        /* invalid: no low surrogate */
         *ump_res = ((*ump_res & 0x03FF) + 0x40) << 10  /* high 10 bits */
                  | ((*((unsigned char *) achp_start) & 3) << 8)  /* bit 8..9 */
                  | *((unsigned char *) achp_start - 1);  /* low 8 bits */
         return 2*sizeof(HL_WCHAR);         /* length of surrogate pair */
       } else {
         return sizeof(HL_WCHAR);           /* length of character UTF-16 */
       }
     case ied_chs_utf_32:                   /* Unicode UTF-32          */
       if (achp_end == NULL) {              /* is zero-terminated      */
         if (*((unsigned int *) achp_start) == 0) {  /* zero at end    */
           return 0;                        /* end of string found     */
         }
       }
       *ump_res = *((unsigned int *) achp_start);  /* character not translated */
       return sizeof(unsigned int);         /* length of character UTF-32 */
     case ied_chs_be_utf_32:                /* Unicode UTF-32 big endian */
       if (achp_end == NULL) {              /* is zero-terminated      */
         if (   (*((char *) achp_start + 0) == 0)  /* zero at end first byte */
             && (*((char *) achp_start + 1) == 0)  /* zero at end second byte */
             && (*((char *) achp_start + 2) == 0)  /* zero at end third byte */
             && (*((char *) achp_start + 3) == 0)) {  /* zero at end fourth byte */
           return 0;                        /* end of string found     */
         }
       }
       *ump_res = (*((unsigned char *) achp_start + 0) << 24)
                    | (*((unsigned char *) achp_start + 1) << 16)
                    | (*((unsigned char *) achp_start + 2) << 8)
                    | *((unsigned char *) achp_start + 3);
       return sizeof(unsigned int);         /* length of character UTF-32 */
     case ied_chs_le_utf_32:                /* Unicode UTF-32 little endian */
       if (achp_end == NULL) {              /* is zero-terminated      */
         if (   (*((char *) achp_start + 0) == 0)  /* zero at end first byte */
             && (*((char *) achp_start + 1) == 0)  /* zero at end second byte */
             && (*((char *) achp_start + 2) == 0)  /* zero at end third byte */
             && (*((char *) achp_start + 3) == 0)) {  /* zero at end fourth byte */
           return 0;                        /* end of string found     */
         }
       }
       *ump_res = *((unsigned char *) achp_start + 0)
                    | (*((unsigned char *) achp_start + 1) << 8)
                    | (*((unsigned char *) achp_start + 2) << 16)
                    | (*((unsigned char *) achp_start + 3) << 24);
       return sizeof(unsigned int);      /* length of character UTF-32 */
     default:                       /* ied_chs_idna_1, ied_chs_invalid */
       return HL_ERR_UCGETC_INVCHS;         /* invalid character set   */
   }
} /* end m_get_vc_ch()                                                 */

/**
* retrieve a single HMTL character, the control character is already discarded
*  @param[out] ump_res unicode codepoint number corresponding to the entity
*  @param achp_start pointer to the char after the char starting an entity
*  @param achp_end NULL to mean zero-terminated input, else
*                  pointer to (the byte after) the end of the input buffer
*  @return negative on error (following returncode rules for m_get_vc_ch_ex),
*          else length of the entity (bytes read + 1 for the '&')
*/
static inline int m_get_html_1_a( unsigned int *ump_res, const char *achp_start,
                                  const char *achp_end ) {
   unsigned int uml_res;                    /* result                  */
   int          iml1, iml2, iml3, iml4;     /* working variables       */
   const char   *achl1, *achl2, *achl3;     /* working variables       */

   achl1 = achp_start;
   if (achp_end) {
     if (achl1 >= achp_end) return HL_ERR_UCGETC_INPSH;  /* not complete sequence */
   } else {
     if (*achl1 == 0) return HL_ERR_UCGETC_INPSH;  /* not complete sequence */
   }
   if (*achl1 == ';') return HL_ERR_UCGETC_INV;  /* already end of sequence */
   if (*achl1 != '#') goto p_table_00;      /* search in table         */
   achl1++;                                 /* after hash for number   */
   if (achp_end) {
     if (achl1 >= achp_end) return HL_ERR_UCGETC_INPSH;  /* not complete sequence */
   } else {
     if (*achl1 == 0) return HL_ERR_UCGETC_INPSH;  /* not complete sequence */
   }
   if (*achl1 == ';') return HL_ERR_UCGETC_INV;  /* already end of sequence */
   uml_res = 0;                             /* clear result            */
   iml1 = 10;                               /* base 10                 */
   iml2 = 8;                                /* maximum number of digits */
   if (*achl1 != 'x') goto p_number_00;     /* retrieve number         */
   iml1 = 16;                               /* base 10                 */
   achl1++;                                 /* after hash for number   */
   if (achp_end) {
     if (achl1 >= achp_end) return HL_ERR_UCGETC_INPSH;  /* not complete sequence */
   } else {
     if (*achl1 == 0) return HL_ERR_UCGETC_INPSH;  /* not complete sequence */
   }
   if (*achl1 == ';') return HL_ERR_UCGETC_INV;  /* already end of sequence */

   p_number_00:                             /* retrieve number         */
   iml2--;                                  /* decrement number of digits */
   if (iml2 <= 0) return HL_ERR_UCGETC_INV;  /* too many digits        */
   if ((*achl1 >= '0') && (*achl1 <= '9')) {
     iml3 = *achl1 - '0';
   } else if ((*achl1 >= 'A') && (*achl1 <= 'F')) {
     if (iml1 != 16) return HL_ERR_UCGETC_INV;  /* hexa character found in decimal number */
     iml3 = *achl1 - 'A' + 10;
   } else if ((*achl1 >= 'a') && (*achl1 <= 'f')) {
     if (iml1 != 16) return HL_ERR_UCGETC_INV;  /* hexa character found in decimal number */
     iml3 = *achl1 - 'a' + 10;
   } else return HL_ERR_UCGETC_INV;         /* invalid character found */
   uml_res *= iml1;                         /* shift previous number   */
   uml_res += iml3;                         /* add new digit           */
   achl1++;                                 /* after hash for number   */
   if (achp_end) {
     if (achl1 >= achp_end) return HL_ERR_UCGETC_INPSH;  /* not complete sequence */
   } else {
     if (*achl1 == 0) return HL_ERR_UCGETC_INPSH;  /* not complete sequence */
   }
   if (*achl1 != ';') goto p_number_00;     /* continue retrieve number */
   *ump_res = uml_res;                      /* return result           */
   return 1 + (achl1 - achp_start) + 1;     /* return number of characters read */

   p_table_00:                              /* search in table         */
   iml1 = 12;                               /* maximum number of characters */
   while (TRUE) {                           /* search end of sequence  */
     achl1++;                               /* next character          */
     if (achp_end) {
       if (achl1 >= achp_end) return HL_ERR_UCGETC_INPSH;  /* not complete sequence */
     } else {
       if (*achl1 == 0) return HL_ERR_UCGETC_INPSH;  /* not complete sequence */
     }
     if (*achl1 == ';') break;              /* end of sequence found   */
     iml1--;                                /* decrement number of characters */
     if (iml1 < 0) return HL_ERR_UCGETC_INV;  /* too many characters in symbol */
   }
   iml1 = iml2 = sizeof(dsrs_sort_html_alpha) / sizeof(dsrs_sort_html_alpha[0]);

   p_table_20:                              /* binary search           */
   iml3 = iml2;                             /* save old value          */
   iml2++;                                  /* add one                 */
   iml2 >>= 1;                              /* divide by two           */
   if (iml2 == iml3) return HL_ERR_UCGETC_INV;  /* element not found   */
   iml3 = iml1 - iml2;                      /* check this element      */
   if (iml3 < 0) iml3 = 0;                  /* boundary of table       */
   achl2 = dsrs_sort_html_alpha[ iml3 ].achc_char;  /* pointer on string */
   achl3 = achp_start;                      /* second string to compare */

   p_table_40:                              /* compare character       */
   iml4 = *((const unsigned char *) achl2) - *((const unsigned char *) achl3);
   if (iml4 == 0) {                         /* elements are equal      */
     achl2++;                               /* increment addr string one */
     achl3++;                               /* increment addr string two */
     if (*achl2 == 0) {                     /* end of string to compare */
       if (achl3 >= achl1) {                /* end of string input     */
         *ump_res = dsrs_sort_html_alpha[ iml3 ].umc_no;  /* Unicode representation */
         return 1 + (achl1 - achp_start) + 1;  /* return number of characters read */
       }
#ifdef B080811
       return -1;                           /* string input is too long */
#else
       /* string input is longer, and so it is greater                 */
       goto p_table_20;                     /* continue binary search  */
#endif
     } else {
#ifdef B080811
       if (achl3 >= achl1) {                /* end of string input     */
         return -1;                         /* string input is too short */
       }
#else
       if (achl3 >= achl1) {                /* end of string input     */
         iml1 = iml3;                       /* string input is less    */
         goto p_table_20;                   /* continue binary search  */
       }
#endif
     }
     goto p_table_40;                       /* compare next character  */
   }
   if (iml4 > 0) {                          /* string input is less    */
     iml1 = iml3;
   }
   goto p_table_20;                         /* continue binary search  */
} /* end m_get_html_1_a()                                              */

/**
* output of a single Unicode character, special value
*  @param achp_target output buffer to write a "&...;" entity code to
*  @param achp_end pointer to (the byte after) the end of the output buffer
*  @param ump_ch_source the codepoint to encode
*  @return -1 if output overflow, else number of bytes written
*/
static inline int m_put_html_1_a( char *achp_target, char *achp_end, unsigned int ump_ch_source ) {
   int        iml1, iml2, iml3, iml4;       /* working variables       */
   char       *achl1, *achl2;               /* working variable        */

   achl2 = achp_target;                     /* save start output       */
   *achp_target++ = '&';                    /* output control character */
   if (achp_target >= achp_end) return -1;  /* end of output area      */

   /* search Unicode character in table                                */
   iml1 = iml2 = sizeof(dsrs_sort_html_no) / sizeof(dsrs_sort_html_no[0]);

   p_table_20:                              /* binary search           */
   iml3 = iml2;                             /* save old value          */
   iml2++;                                  /* add one                 */
   iml2 >>= 1;                              /* divide by two           */
   if (iml2 == iml3) {                      /* element not found       */
     *achp_target++ = '#';                  /* output control character number */
     if (achp_target >= achp_end) return -1;  /* end of output area      */
     *achp_target++ = 'x';                  /* output control character hexa */
     if (achp_target >= achp_end) return -1;  /* end of output area      */
     iml1 = ump_ch_source;                  /* get source              */
     iml2 = 0;                              /* count hex digits        */
     do {
       iml1 >>= 4;                          /* remove one digit        */
       iml2++;                              /* count digit             */
     } while (iml1);
     do {                                   /* output of hex characters */
       iml2--;                              /* output one character    */
       *achp_target++ = chrstrans[ (ump_ch_source >> (iml2 * 4)) & 0X0F ];  /* output hex digit */
       if (achp_target >= achp_end) return -1;  /* end of output area      */
     } while (iml2);
     *achp_target++ = ';';                  /* output control character end of string */
     return achp_target - achl2;            /* so many characters in output */
   }
   iml3 = iml1 - iml2;                      /* check this element      */
   if (iml3 < 0) iml3 = 0;                  /* boundary of table       */
   iml4 = (int)(dsrs_sort_html_no[ iml3 ].umc_no) - ump_ch_source;  /* difference Unicode character */
   if (iml4 == 0) {                         /* elements are equal      */
     achl1 = dsrs_sort_html_no[ iml3 ].achc_char;  /* pointer on string */
     do {                                   /* loop output characters  */
       *achp_target++ = *achl1++;           /* output character of string */
       if (achp_target >= achp_end) return -1;  /* end of output area  */
     } while (*achl1);
     *achp_target++ = ';';                  /* output control character end of string */
     return achp_target - achl2;            /* so many characters in output */
   }
   if (iml4 > 0) {                          /* Unicode input is less   */
     iml1 = iml3;
   }
   goto p_table_20;                         /* continue binary search  */
} /* end m_put_html_1_a()                                              */

/**
* output of a single Unicode character, in hexadecimal
*  @param achp_target the output buffer to write a "%C3%BC"-like code to
*  @param achp_end pointer to (the byte after) the end of the output buffer
*  @param ump_ch_source the codepoint to encode
*  @param chp_cc the escape char, like '%' for URI or '=' for quoted-printable
*  @return -1 on error, else number of bytes written
*/
static inline int m_put_uri_1_a( char *achp_target, char *achp_end,
                                 unsigned int ump_ch_source, char chp_cc ) {
   int        iml1;                         /* working variable        */
   char       *achl1;                       /* working variable        */

   achl1 = achp_target;                     /* save start output       */
   *achp_target++ = chp_cc;                 /* output control character */
   if (achp_target >= achp_end) return -1;  /* end of output area      */
   if ((ump_ch_source >> 7) == 0) {         /* UTF-8 one byte          */
     *achp_target++ = chrstrans[ ump_ch_source >> 4 ];  /* output first hex char */
     if (achp_target >= achp_end) return -1;  /* output area too short */
     *achp_target++ = chrstrans[ ump_ch_source & 0X0F ];  /* output second hex char */
     return achp_target - achl1;            /* so many characters in output */
   }
   if ((ump_ch_source >> 11) == 0) {
     if ((achp_target + (2 + 3)) > achp_end) return -1;  /* output area too short */
     iml1 = 0XC0 | (ump_ch_source >> 6);
     *achp_target++ = chrstrans[ (iml1 >> 4) & 0X0F ];  /* output first hex char */
     *achp_target++ = chrstrans[ iml1 & 0X0F ];  /* output second hex char */
     iml1 = 0X80 | (ump_ch_source & 0X3F);
     *achp_target++ = chp_cc;                /* output control character */
     *achp_target++ = chrstrans[ (iml1 >> 4) & 0X0F ];  /* output first hex char */
     *achp_target++ = chrstrans[ iml1 & 0X0F ];  /* output second hex char */
     return achp_target - achl1;            /* so many characters in output */
   }
   if ((ump_ch_source >> 16) == 0) {
     if ((achp_target + (2 + 2 * 3)) > achp_end) return -1;  /* output area too short */
     iml1 = 0XE0 | (ump_ch_source >> 12);
     *achp_target++ = chrstrans[ iml1 >> 4 ];  /* output first hex char */
     *achp_target++ = chrstrans[ iml1 & 0X0F ];  /* output second hex char */
     iml1 = 0X80 | ((ump_ch_source >> 6) & 0X3F);
     *achp_target++ = chp_cc;                /* output control character */
     *achp_target++ = chrstrans[ (iml1 >> 4) & 0X0F ];  /* output first hex char */
     *achp_target++ = chrstrans[ iml1 & 0X0F ];  /* output second hex char */
     iml1 = 0X80 | (ump_ch_source & 0X3F);
     *achp_target++ = chp_cc;                /* output control character */
     *achp_target++ = chrstrans[ (iml1 >> 4) & 0X0F ];  /* output first hex char */
     *achp_target++ = chrstrans[ iml1 & 0X0F ];  /* output second hex char */
     return achp_target - achl1;            /* so many characters in output */
   }
   if ((ump_ch_source >> 21) == 0) {
     if ((achp_target + (2 + 3 * 3)) > achp_end) return -1;  /* output area too short */
     iml1 = 0XF0 | (ump_ch_source >> 18);
     *achp_target++ = chrstrans[ iml1 >> 4 ];  /* output first hex char */
     *achp_target++ = chrstrans[ iml1 & 0X0F ];  /* output second hex char */
     iml1 = 0X80 | ((ump_ch_source >> 12) & 0X3F);
     *achp_target++ = chp_cc;                /* output control character */
     *achp_target++ = chrstrans[ (iml1 >> 4) & 0X0F ];  /* output first hex char */
     *achp_target++ = chrstrans[ iml1 & 0X0F ];  /* output second hex char */
     iml1 = 0X80 | ((ump_ch_source >> 6) & 0X3F);
     *achp_target++ = chp_cc;                /* output control character */
     *achp_target++ = chrstrans[ (iml1 >> 4) & 0X0F ];  /* output first hex char */
     *achp_target++ = chrstrans[ iml1 & 0X0F ];  /* output second hex char */
     iml1 = 0X80 | (ump_ch_source & 0X3F);
     *achp_target++ = chp_cc;                /* output control character */
     *achp_target++ = chrstrans[ (iml1 >> 4) & 0X0F ];  /* output first hex char */
     *achp_target++ = chrstrans[ iml1 & 0X0F ];  /* output second hex char */
     return achp_target - achl1;            /* so many characters in output */
   }
   if ((ump_ch_source >> 26) == 0) {
     if ((achp_target + (2 + 4 * 3)) > achp_end) return -1;  /* output area too short */
     iml1 = 0XF8 | (ump_ch_source >> 24);
     *achp_target++ = chrstrans[ iml1 >> 4 ];  /* output first hex char */
     *achp_target++ = chrstrans[ iml1 & 0X0F ];  /* output second hex char */
     iml1 = 0X80 | ((ump_ch_source >> 18) & 0X3F);
     *achp_target++ = chp_cc;                /* output control character */
     *achp_target++ = chrstrans[ (iml1 >> 4) & 0X0F ];  /* output first hex char */
     *achp_target++ = chrstrans[ iml1 & 0X0F ];  /* output second hex char */
     iml1 = 0X80 | ((ump_ch_source >> 12) & 0X3F);
     *achp_target++ = chp_cc;                /* output control character */
     *achp_target++ = chrstrans[ (iml1 >> 4) & 0X0F ];  /* output first hex char */
     *achp_target++ = chrstrans[ iml1 & 0X0F ];  /* output second hex char */
     iml1 = 0X80 | ((ump_ch_source >> 6) & 0X3F);
     *achp_target++ = chp_cc;                /* output control character */
     *achp_target++ = chrstrans[ (iml1 >> 4) & 0X0F ];  /* output first hex char */
     *achp_target++ = chrstrans[ iml1 & 0X0F ];  /* output second hex char */
     iml1 = 0X80 | (ump_ch_source & 0X3F);
     *achp_target++ = chp_cc;                /* output control character */
     *achp_target++ = chrstrans[ (iml1 >> 4) & 0X0F ];  /* output first hex char */
     *achp_target++ = chrstrans[ iml1 & 0X0F ];  /* output second hex char */
     return achp_target - achl1;            /* so many characters in output */
   }
   if ((ump_ch_source >> 31) == 0) {
     if ((achp_target + (2 + 5 * 3)) > achp_end) return -1;  /* output area too short */
     iml1 = 0XFC | (ump_ch_source >> 30);
     *achp_target++ = chrstrans[ iml1 >> 4 ];  /* output first hex char */
     *achp_target++ = chrstrans[ iml1 & 0X0F ];  /* output second hex char */
     iml1 = 0X80 | ((ump_ch_source >> 24) & 0X3F);
     *achp_target++ = chp_cc;                /* output control character */
     *achp_target++ = chrstrans[ (iml1 >> 4) & 0X0F ];  /* output first hex char */
     *achp_target++ = chrstrans[ iml1 & 0X0F ];  /* output second hex char */
     iml1 = 0X80 | ((ump_ch_source >> 18) & 0X3F);
     *achp_target++ = chp_cc;                /* output control character */
     *achp_target++ = chrstrans[ (iml1 >> 4) & 0X0F ];  /* output first hex char */
     *achp_target++ = chrstrans[ iml1 & 0X0F ];  /* output second hex char */
     iml1 = 0X80 | ((ump_ch_source >> 12) & 0X3F);
     *achp_target++ = chp_cc;                /* output control character */
     *achp_target++ = chrstrans[ (iml1 >> 4) & 0X0F ];  /* output first hex char */
     *achp_target++ = chrstrans[ iml1 & 0X0F ];  /* output second hex char */
     iml1 = 0X80 | ((ump_ch_source >> 6) & 0X3F);
     *achp_target++ = chp_cc;                /* output control character */
     *achp_target++ = chrstrans[ (iml1 >> 4) & 0X0F ];  /* output first hex char */
     *achp_target++ = chrstrans[ iml1 & 0X0F ];  /* output second hex char */
     iml1 = 0X80 | (ump_ch_source & 0X3F);
     *achp_target++ = chp_cc;                /* output control character */
     *achp_target++ = chrstrans[ (iml1 >> 4) & 0X0F ];  /* output first hex char */
     *achp_target++ = chrstrans[ iml1 & 0X0F ];  /* output second hex char */
     return achp_target - achl1;            /* so many characters in output */
   }
   return -1;                               /* character undefined     */
} /* end m_put_uri_1_a()                                               */

/**
* make Unicode UTF-16 from UTF-8 (no terminator is used at in- or output)
*  @param awcp_target pointer to output buffer
*  @param inp_max_len_target length of the output buffer, in 16-bit units
*  @param achp_source input string, no chars above codepoint U+FFFF
*                                      (they will go to U+FFFD)
*  @param inp_len_source length of input string, in bytes
*  @return -1 on error conditions, else count of 16-bit-units written
*/
extern PTYPE int m_u16l_from_u8l( HL_WCHAR *awcp_target,   int inp_max_len_target,
                                  const char *achp_source, int inp_len_source ) {
   const char *achl1, *achl2;               /* working variables       */
   HL_WCHAR   *awcl_out_cur;                /* current output          */
   HL_WCHAR   *awcl_out_end;                /* end of output           */
   HL_WCHAR   wcl1;                         /* temporary output character */
   BOOL       bolerror;                     /* invalid input character found */

   achl1 = achp_source;                     /* get start input         */
   achl2 = achp_source + inp_len_source;    /* end of input            */
   awcl_out_cur = awcp_target;              /* current output          */
// awcl_out_end = awcp_target + inp_max_len_target - 1;  /* end of output  */
   awcl_out_end = awcp_target + inp_max_len_target;  /* end of output  */
   bolerror = FALSE;                        /* clear error indicator   */
   while (achl1 < achl2) {                  /* loop over all input characters */
     if (awcl_out_cur >= awcl_out_end) {
       return awcl_out_cur - awcp_target;
     }
     if (((signed char) *achl1) >= 0) {
       *awcl_out_cur++ = (HL_WCHAR) *achl1++;
     } else {
       wcl1 = (HL_WCHAR) *achl1++;          /* get first byte input    */
       if (achl1 >= achl2) {
         bolerror = TRUE;
         break;
       }
       if (((signed char) *achl1) >= 0) {
         bolerror = TRUE;
         break;
       }
       if ((*achl1 & 0X40) != 0) {
         bolerror = TRUE;
         break;
       }
       if ((wcl1 & 0X20) == 0) {
         wcl1 &= 0X1F;
         wcl1 <<= 6;
         wcl1 |= *achl1++ & 0X3F;
       } else if ((wcl1 & 0X10) == 0) {
         wcl1 &= 0X0F;
         wcl1 <<= 6;
         wcl1 |= *achl1++ & 0X3F;
         if (((signed char) *achl1) >= 0) {
           bolerror = TRUE;
           break;
         }
         if ((*achl1 & 0X40) != 0) {
           bolerror = TRUE;
           break;
         }
         wcl1 <<= 6;
         wcl1 |= *achl1++ & 0X3F;
       } else { /* format for chars > 0xFFFF, only check byte range    */
         /* bolerror = TRUE; invalid input character found ( ??? ) */
         while (TRUE) {
           if (((unsigned char)(*achl1++) & 0XC0) != 0X80) {
             bolerror = TRUE;
             break;
           }
           wcl1<<=1;
           if ((wcl1 & 0X40) == 0)
             break;
           if (achl1 >= achl2) {
             bolerror = TRUE;
             break;
           }
         }
         wcl1 = UTF16_REP_CHAR;
         if (bolerror)
           break;
       }
       *awcl_out_cur++ = wcl1;
     }
   }
   if (bolerror) return -1;                 /* error occured           */
   return awcl_out_cur - awcp_target;
} /* end m_u16l_from_u8l()                                             */

/**
* make Unicode UTF-16 zero-terminated from UTF-8
*  @param awcp_target pointer to output buffer
*  @param inp_max_len_target length of the output buffer, in 16-bit units
*  @param achp_source input string (no terminator characters recognised),
*                     no chars above codepoint U+FFFF (they will go to U+FFFD)
*  @param inp_len_source length of input string, in bytes
*  @return count of 16-bit-units written, excluding the terminating zero
*          (so it will be < inp_max_len_target to have room for the terminator)
*/
extern PTYPE int m_u16z_from_u8l( HL_WCHAR *awcp_target,   int inp_max_len_target,
                                  const char *achp_source, int inp_len_source ) {
   const char *achl1, *achl2;               /* working variables       */
   HL_WCHAR   *awcl_out_cur;                /* current output          */
   HL_WCHAR   *awcl_out_end;                /* end of output           */
   HL_WCHAR   wcl1;                         /* temporary output character */
   BOOL       bolerror;                     /* invalid input character found */

   achl1 = achp_source;                     /* get start input         */
   achl2 = achp_source + inp_len_source;    /* end of input            */
   awcl_out_cur = awcp_target;              /* current output          */
   awcl_out_end = awcp_target + inp_max_len_target - 1;  /* end of output */
   bolerror = FALSE;
   while (achl1 < achl2) {
     if (awcl_out_cur >= awcl_out_end) {
       *awcl_out_cur = 0;                   /* make zero-terminated    */
       return awcl_out_cur - awcp_target;
     }
     if (((signed char) *achl1) >= 0) {
       *awcl_out_cur++ = (HL_WCHAR) *achl1++;
     } else {
       wcl1 = (HL_WCHAR) *achl1++;
       if (achl1 >= achl2) {
         bolerror = TRUE;
         break;
       }
       if (((signed char) *achl1) >= 0) {
         bolerror = TRUE;
         break;
       }
       if ((*achl1 & 0X40) != 0) {
         bolerror = TRUE;
         break;
       }
       if ((wcl1 & 0X20) == 0) {
         wcl1 &= 0X1F;
         wcl1 <<= 6;
         wcl1 |= *achl1++ & 0X3F;
       } else if ((wcl1 & 0X10) == 0) {
         wcl1 &= 0X0F;
         wcl1 <<= 6;
         wcl1 |= *achl1++ & 0X3F;
         if (((signed char) *achl1) >= 0) {
           bolerror = TRUE;
           break;
         }
         if ((*achl1 & 0X40) != 0) {
           bolerror = TRUE;
           break;
         }
         wcl1 <<= 6;
         wcl1 |= *achl1++ & 0X3F;
       } else { /* format for chars > 0xFFFF, only check byte range    */
         /* XXX bolerror = TRUE; ?? that value is not used anyway */
         while (TRUE) {
           if (((unsigned char)(*achl1++) & 0XC0) != 0X80) {
             bolerror = TRUE;
             break;
           }
           wcl1<<=1;
           if ((wcl1 & 0X40) == 0)
             break;
           if (achl1 >= achl2) {
             bolerror = TRUE;
             break;
           }
         }
         wcl1 = UTF16_REP_CHAR;
         if (bolerror)
           break;
       }
       *awcl_out_cur++ = wcl1;
     }
   }
   *awcl_out_cur = 0;                       /* make zero-terminated    */
   return awcl_out_cur - awcp_target;
} /* end m_u16z_from_u8l()                                             */

/**
* make Unicode UTF-16 with reversed endian from UTF-8 with targetlen
*  @param ap_target pointer to output buffer
*  @param inp_max_chars_target length of the output buffer, in 16-bit units
*  @param achp_source input string (no terminator characters recognised),
*                     no chars above codepoint U+FFFF (they will go to U+FFFD)
*  @param inp_max_bytes_source length of input string, in bytes
*  @return count of 16-bit-units written, excluding the terminating zero
*          (so it will be < inp_max_chars_target to have room for the terminator)
*/
extern PTYPE int m_u16r_from_u8l( void *ap_target, int inp_max_chars_target,
                                  const char *achp_source, int inp_max_bytes_source ) {
   /* extern, but does not appear in hob-xslunic1.h  WS 20141017       */
   const bool bol_platform_is_le
       = m_suppress_endian_info_if_native(ied_chs_le_utf_16) == ied_chs_utf_16;
   unsigned char *achl1;                    /* working variables       */
   unsigned char *aucl_out_cur_0;           /* current output for LSB  */
   unsigned char *aucl_out_cur_1;           /* current output for MSB  */
   unsigned char *aucl_out_cur_0_orig;
   unsigned char *aucl_out_end;             /* end of output           */
   unsigned char *aucl_in_end;              /* end of input            */

   achl1 = (unsigned char *)achp_source;    /* get start input         */
   aucl_in_end = achl1 + inp_max_bytes_source;
   if (bol_platform_is_le)
   { /* this machine uses little endian, use big endian                */
     aucl_out_cur_1 = (unsigned char*)ap_target;
     aucl_out_cur_0 = (unsigned char*)ap_target + 1;
   } else { /* this machine uses big endian, use little endian         */
     aucl_out_cur_0 = (unsigned char*)ap_target;
     aucl_out_cur_1 = (unsigned char*)ap_target + 1;
   }
   aucl_out_end = aucl_out_cur_0 + 2 * (inp_max_chars_target - 1); /* f. '0' */
   aucl_out_cur_0_orig = aucl_out_cur_0;
   while( (aucl_out_cur_0 < aucl_out_end) && (achl1 < aucl_in_end) ) {
     if (*achl1 & 0x80) {
       int inl_utf8tail = chrs_trail_u8l[*achl1];
       if (inl_utf8tail == 0) {
         break; /* error */
       }
       else if (inl_utf8tail <= 2) {
         if (inl_utf8tail == 2) {
           *aucl_out_cur_1 = *achl1 << 4;
           if (++achl1 + 2 > aucl_in_end)
             break; /* error */
           if ((*achl1 & 0xC0) != 0x80)
             break; /* error */
           *aucl_out_cur_1 |= (*achl1&0x3C) >> 2;
           *aucl_out_cur_0 = *achl1 << 6;
           ++achl1;
         } else {
           *aucl_out_cur_1 = (*achl1 >> 2 & 0x07);
           *aucl_out_cur_0 = *achl1 << 6;
           if (++achl1 >= aucl_in_end)
             break; /* error */
         }
         if ((*achl1 & 0xC0) != 0x80)
           break; /* error */
         *aucl_out_cur_0 |= (*achl1 & 0x3F);
       }
       else {
         /* format for chars > 0xFFFF, only check byte range */
         if (achl1 + inl_utf8tail > aucl_in_end)
           break; /* error */
         *aucl_out_cur_1 = (unsigned char)(UTF16_REP_CHAR >> 8);
         *aucl_out_cur_0 = (unsigned char)UTF16_REP_CHAR;
         do {
           if ((*(++achl1) & 0xC0) != 0x80)
             break; /* error */
         } while (--inl_utf8tail);
         if (inl_utf8tail)
           break; /* propagate error */
       }
     } else {
       *aucl_out_cur_0 = *achl1;
       *aucl_out_cur_1 = 0;
     }
     achl1++;
     aucl_out_cur_0 += 2;
     aucl_out_cur_1 += 2;
   }
   *aucl_out_cur_0 = 0;                     /* make zero-terminated    */
   *aucl_out_cur_1 = 0;                     /* make zero-terminated    */
   return (aucl_out_cur_0 - aucl_out_cur_0_orig) / 2;
} /* end m_u16r_from_u8l()                                             */

/* macro for m_a819l_from_u8l and m_a850l_from_u8l                   { */
/* } end macro for m_a819l_from_u8l and m_a850l_from_u8l               */

/**
* make ANSI 819 (single byte per character) from UTF-8
* (by length, no terminator is used at in- or output)
*  @param achp_target pointer to output buffer
*  @param inp_max_len_target length of output buffer
*  @param achp_source input string
*  @param inp_len_source length of input string, in bytes
*  @return count of bytes written
*/
extern PTYPE int m_a819l_from_u8l( char *achp_target, int inp_max_len_target,
                                   const char *achp_source, int inp_len_source ) {
   const char *achl1, *achl2;               /* working variables       */
   char       *achl_out_cur;                /* current output          */
   char       *achl_out_end;                /* end of output           */
   HL_WCHAR   wcl1;                         /* temporary output character */
   BOOL       bolerror;                     /* invalid input character found */

   achl1 = achp_source;                     /* get start input         */
   achl2 = achp_source + inp_len_source;    /* end of input            */
   achl_out_cur = achp_target;              /* current output          */
   achl_out_end = achp_target + inp_max_len_target - 1;  /* end of output  */
   bolerror = FALSE;
   while (achl1 < achl2) {
     if (achl_out_cur >= achl_out_end) {
       return achl_out_cur - achp_target;
     }
     if (((signed char) *achl1) >= 0) {
       *achl_out_cur++ = *achl1++;
     } else {
       wcl1 = (WCHAR) *achl1++;
       if (achl1 >= achl2) {
         bolerror = TRUE;
         break;
       }
       if (((signed char) *achl1) >= 0) {
         bolerror = TRUE;
         break;
       }
       if ((*achl1 & 0X40) != 0) {
         bolerror = TRUE;
         break;
       }
       if ((wcl1 & 0X20) == 0) {
         wcl1 &= 0X1F;
         wcl1 <<= 6;
         wcl1 |= *achl1++ & 0X3F;
       } else {
         wcl1 &= 0X0F;
         wcl1 <<= 6;
         wcl1 |= *achl1++ & 0X3F;
         if (((signed char) *achl1) >= 0) {
           bolerror = TRUE;
           break;
         }
         if ((*achl1 & 0X40) != 0) {
           bolerror = TRUE;
           break;
         }
         wcl1 <<= 6;
         wcl1 |= *achl1++ & 0X3F;
       }
       *achl_out_cur = '?';
       if (wcl1 < 0X0100) {
         *achl_out_cur = (char) wcl1;
       }
       achl_out_cur++;
     }
   }
   /* XXX bolerror is never used (except being set) */
   return achl_out_cur - achp_target;
} /* end m_a819l_from_u8l()                                            */

/**
* make ASCII 850 (single byte per character) from UTF-8
* (by length, no terminator is used at in- or output)
*  @param achp_target pointer to output buffer
*  @param inp_max_len_target length of output buffer
*  @param achp_source input string
*  @param inp_len_source length of input string, in bytes
*  @return count of bytes written
*/
extern PTYPE int m_a850l_from_u8l( char *achp_target, int inp_max_len_target,
                                   const char *achp_source, int inp_len_source ) {
   const char *achl1, *achl2;               /* working variables       */
   char       *achl_out_cur;                /* current output          */
   char       *achl_out_end;                /* end of output           */
   HL_WCHAR   wcl1;                         /* temporary output character */
   BOOL       bolerror;                     /* invalid input character found */

   achl1 = achp_source;                     /* get start input         */
   achl2 = achp_source + inp_len_source;    /* end of input            */
   achl_out_cur = achp_target;              /* current output          */
   achl_out_end = achp_target + inp_max_len_target - 1;  /* end of output  */
   bolerror = FALSE;
   while (achl1 < achl2) {
     if (achl_out_cur >= achl_out_end) {
       return achl_out_cur - achp_target;
     }
     if (((signed char) *achl1) >= 0) {
       *achl_out_cur++ = ucrg_tab_819_to_850[ (unsigned char) (*achl1++) ];
     } else {
       wcl1 = (WCHAR) *achl1++;
       if (achl1 >= achl2) {
         bolerror = TRUE;
         break;
       }
       if (((signed char) *achl1) >= 0) {
         bolerror = TRUE;
         break;
       }
       if ((*achl1 & 0X40) != 0) {
         bolerror = TRUE;
         break;
       }
       if ((wcl1 & 0X20) == 0) {
         wcl1 &= 0X1F;
         wcl1 <<= 6;
         wcl1 |= *achl1++ & 0X3F;
       } else {
         wcl1 &= 0X0F;
         wcl1 <<= 6;
         wcl1 |= *achl1++ & 0X3F;
         if (((signed char) *achl1) >= 0) {
           bolerror = TRUE;
           break;
         }
         if ((*achl1 & 0X40) != 0) {
           bolerror = TRUE;
           break;
         }
         wcl1 <<= 6;
         wcl1 |= *achl1++ & 0X3F;
       }
       *achl_out_cur = '?';
       if (wcl1 < 0X0100) {
         *achl_out_cur = ucrg_tab_819_to_850[ wcl1 ];
       }
       achl_out_cur++;
     }
   }
   /* XXX bolerror is never used (except being set) */
   return achl_out_cur - achp_target;
} /* end m_a850l_from_u8l()                                            */

/**
* Converts a unicode codepoint into some 8-bit-encoding, using the rule that the
* result will be the same number if below 0x80 and undefined if in 0x80..0x9F,
* and using a function and a pair of two-step-conversion-tables if above 0x9F.
*  @param ump_ch_source input character as unicode codepoint number
*  @param amp_tf function for two-step-conversion like the m_u32c_to_sb_*step()
*  @param aunp_ti a first-step conversion table like the unrg_tabindex_uni_to_*
*  @param aucp_tp a second-step conversion table like the ucrg_tabparts_uni_to_*
*  @return the encoded character (ASCII_REP_CHAR if 0x7F < ump_ch_source < 0xA0)
*/
static inline char m_u32_to_sb_80a0( unsigned int ump_ch_source,
                                   char amp_tf(unsigned int, const unsigned int*, const unsigned char*),
                                   const unsigned int* aunp_ti, const unsigned char* aucp_tp ) {
   /* unicode.org defines the lower 128 bytes in CP437 and all the Windows Codepages we implement
      here (874,125?) as meaning the same as in Unicode (although for CP437 table also handles the
      mapping of the graphical glyphs (shown on wikipedia), which makes it non-injective),
      and none of them encodes any character in U+0080..U+009F. */
   if (ump_ch_source < 0xA0) {
     if (ump_ch_source & 0x80)
       return ASCII_REP_CHAR;  /* denotes the same char ('?') in all these codepages
                                  as in those it was defined for */
     return (char)ump_ch_source;
   }
   /* else use table. */
   return amp_tf( ump_ch_source, aunp_ti, aucp_tp );
}

/**
* Converts a unicode codepoint into some 8-bit-encoding, using the rule that the
* result will be the same number if below 0xA0, and using a function and a
* pair of two-step-conversion-tables if not.
*  @param ump_ch_source input character as unicode codepoint number
*  @param amp_tf function for two-step-conversion like the m_u32c_to_sb_*step()
*  @param aunp_ti a first-step conversion table like the unrg_tabindex_uni_to_*
*  @param aucp_tp a second-step conversion table like the ucrg_tabparts_uni_to_*
*  @return the encoded character
*/
static inline char m_u32_to_sb_a1a0( unsigned int ump_ch_source,
                                   char amp_tf(unsigned int, const unsigned int*, const unsigned char*),
                                   const unsigned int* aunp_ti, const unsigned char* aucp_tp ) {
   /* unicode.org defines the lower 0xA1 bytes in all the ISO-8859-encodings
      (1 .. 16 except the non-existing 12) as meaning the same as in Unicode. */
   if (ump_ch_source < 0xA1)
     return (char)ump_ch_source;
   /* else use table. */
   return amp_tf( ump_ch_source, aunp_ti, aucp_tp );
}

/**
* convert one character to ied_chs_oem_437
*  @param ump_ch_source unicode-codepoint of the character to translate
*  @return the character in DOS-codepage 437 encoding
*/
static inline char m_u32c_to_437(  unsigned int ump_ch_source ) {
   return m_u32_to_sb_80a0( ump_ch_source, m_u32c_to_sb_5step,
                            unrg_tabindex_uni_to_437,  ucrg_tabparts_uni_to_437  );
}
/**
* convert one character to ied_chs_wcp_874
*  @param ump_ch_source unicode-codepoint of the character to translate
*  @return the character in Windows-codepage 874 encoding
*/
static inline char m_u32c_to_874(  unsigned int ump_ch_source ) {
   return m_u32_to_sb_80a0( ump_ch_source, m_u32c_to_sb_3step,
                            unrg_tabindex_uni_to_874,  ucrg_tabparts_uni_to_874  );
}
/**
* convert one character to ied_chs_wcp_1250
*  @param ump_ch_source unicode-codepoint of the character to translate
*  @return the character in Windows-codepage 1250 encoding
*/
static inline char m_u32c_to_1250( unsigned int ump_ch_source ) {
   return m_u32_to_sb_80a0( ump_ch_source, m_u32c_to_sb_4step,
                            unrg_tabindex_uni_to_1250, ucrg_tabparts_uni_to_1250 );
}
/**
* convert one character to ied_chs_wcp_1251
*  @param ump_ch_source unicode-codepoint of the character to translate
*  @return the character in Windows-codepage 1251 encoding
*/
static inline char m_u32c_to_1251( unsigned int ump_ch_source ) {
   return m_u32_to_sb_80a0( ump_ch_source, m_u32c_to_sb_3step,
                            unrg_tabindex_uni_to_1251, ucrg_tabparts_uni_to_1251 );
}
/**
* convert one character to ied_chs_wcp_1252
*  @param ump_ch_source unicode-codepoint of the character to translate
*  @return the character in Windows-codepage 1252 encoding
*/
static inline char m_u32c_to_1252( unsigned int ump_ch_source ) {
   return m_u32_to_sb_80a0( ump_ch_source, m_u32c_to_sb_4step,
                            unrg_tabindex_uni_to_1252, ucrg_tabparts_uni_to_1252 );
}
/**
* convert one character to ied_chs_wcp_1253
*  @param ump_ch_source unicode-codepoint of the character to translate
*  @return the character in Windows-codepage 1253 encoding
*/
static inline char m_u32c_to_1253( unsigned int ump_ch_source ) {
   return m_u32_to_sb_80a0( ump_ch_source, m_u32c_to_sb_3step,
                            unrg_tabindex_uni_to_1253, ucrg_tabparts_uni_to_1253 );
}
/**
* convert one character to ied_chs_wcp_1254
*  @param ump_ch_source unicode-codepoint of the character to translate
*  @return the character in Windows-codepage 1254 encoding
*/
static inline char m_u32c_to_1254( unsigned int ump_ch_source ) {
   return m_u32_to_sb_80a0( ump_ch_source, m_u32c_to_sb_4step,
                            unrg_tabindex_uni_to_1254, ucrg_tabparts_uni_to_1254 );
}
/**
* convert one character to ied_chs_wcp_1255
*  @param ump_ch_source unicode-codepoint of the character to translate
*  @return the character in Windows-codepage 1255 encoding
*/
static inline char m_u32c_to_1255( unsigned int ump_ch_source ) {
   return m_u32_to_sb_80a0( ump_ch_source, m_u32c_to_sb_4step,
                            unrg_tabindex_uni_to_1255, ucrg_tabparts_uni_to_1255 );
}
/**
* convert one character to ied_chs_wcp_1256
*  @param ump_ch_source unicode-codepoint of the character to translate
*  @return the character in Windows-codepage 1256 encoding
*/
static inline char m_u32c_to_1256( unsigned int ump_ch_source ) {
   if (ump_ch_source==0x6CC)
     ump_ch_source=0x64A;
     /* UUU This handles a shortcoming of the Arab encodings pointed out by
     Mr. Hosseini. The *_uni_to_1256 tables would be the ideal place to fix it,
     but for now it was done here where it was easier to implement and test */
   return m_u32_to_sb_80a0( ump_ch_source, m_u32c_to_sb_4step,
                            unrg_tabindex_uni_to_1256, ucrg_tabparts_uni_to_1256 );
}
/**
* convert one character to ied_chs_wcp_1257
*  @param ump_ch_source unicode-codepoint of the character to translate
*  @return the character in Windows-codepage 1257 encoding
*/
static inline char m_u32c_to_1257( unsigned int ump_ch_source ) {
   return m_u32_to_sb_80a0( ump_ch_source, m_u32c_to_sb_4step,
                            unrg_tabindex_uni_to_1257, ucrg_tabparts_uni_to_1257 );
}
/**
* convert one character to ied_chs_wcp_1258
*  @param ump_ch_source unicode-codepoint of the character to translate
*  @return the character in Windows-codepage 1258 encoding
*/
static inline char m_u32c_to_1258( unsigned int ump_ch_source ) {
   return m_u32_to_sb_80a0( ump_ch_source, m_u32c_to_sb_4step,
                            unrg_tabindex_uni_to_1258, ucrg_tabparts_uni_to_1258 );
}
/**
* convert one character to ied_chs_iso8859_2
*  @param ump_ch_source unicode-codepoint of the character to translate
*  @return the character in ISO-8859-2 enco ing
*/
static inline char m_u32c_to_i02( unsigned int ump_ch_source ) {
   return m_u32_to_sb_a1a0( ump_ch_source, m_u32c_to_sb_3step,
                            unrg_tabindex_uni_to_i02, ucrg_tabparts_uni_to_i02 );
}
/**
* convert one character to ied_chs_iso8859_3
*  @param ump_ch_source unicode-codepoint of the character to translate
*  @return the character in ISO-8859-3 encoding
*/
static inline char m_u32c_to_i03( unsigned int ump_ch_source ) {
   return m_u32_to_sb_a1a0( ump_ch_source, m_u32c_to_sb_3step,
                            unrg_tabindex_uni_to_i03, ucrg_tabparts_uni_to_i03 );
}
/**
* convert one character to ied_chs_iso8859_4
*  @param ump_ch_source unicode-codepoint of the character to translate
*  @return the character in ISO-8859-4 encoding
*/
static inline char m_u32c_to_i04( unsigned int ump_ch_source ) {
   return m_u32_to_sb_a1a0( ump_ch_source, m_u32c_to_sb_3step,
                            unrg_tabindex_uni_to_i04, ucrg_tabparts_uni_to_i04 );
}
/**
* convert one character to ied_chs_iso8859_5
*  @param ump_ch_source unicode-codepoint of the character to translate
*  @return the character in ISO-8859-5 encoding
*/
static inline char m_u32c_to_i05( unsigned int ump_ch_source ) {
   return m_u32_to_sb_a1a0( ump_ch_source, m_u32c_to_sb_2or3step,
                            unrg_tabindex_uni_to_i05-4, ucrg_tabparts_uni_to_i05 );
}
/**
* convert one character to ied_chs_iso8859_6
*  @param ump_ch_source unicode-codepoint of the character to translate
*  @return the character in ISO-8859-6 encoding
*/
static inline char m_u32c_to_i06( unsigned int ump_ch_source ) {
   if (ump_ch_source==0x6CC)
     ump_ch_source=0x64A;  /* see comment in m_u32c_to_1256() */ 
   return m_u32_to_sb_a1a0( ump_ch_source, m_u32c_to_sb_2or3step,
                            unrg_tabindex_uni_to_i06, ucrg_tabparts_uni_to_i06 );
}
/**
* convert one character to ied_chs_iso8859_7
*  @param ump_ch_source unicode-codepoint of the character to translate
*  @return the character in ISO-8859-7 encoding
*/
static inline char m_u32c_to_i07( unsigned int ump_ch_source ) {
   return m_u32_to_sb_a1a0( ump_ch_source, m_u32c_to_sb_2or3step,
                            unrg_tabindex_uni_to_i07, ucrg_tabparts_uni_to_i07 );
}
/**
* convert one character to ied_chs_iso8859_8
*  @param ump_ch_source unicode-codepoint of the character to translate
*  @return the character in ISO-8859-8 encoding
*/
static inline char m_u32c_to_i08( unsigned int ump_ch_source ) {
   return m_u32_to_sb_a1a0( ump_ch_source, m_u32c_to_sb_2or3step,
                            unrg_tabindex_uni_to_i08-2, ucrg_tabparts_uni_to_i08 );
}
/**
* convert one character to ied_chs_iso8859_9
*  @param ump_ch_source unicode-codepoint of the character to translate
*  @return the character in ISO-8859-9 encoding
*/
static inline char m_u32c_to_i09( unsigned int ump_ch_source ) {
   return m_u32_to_sb_a1a0( ump_ch_source, m_u32c_to_sb_2or3step,
                            unrg_tabindex_uni_to_i09-2, ucrg_tabparts_uni_to_i09 );
}
/**
* convert one character to ied_chs_iso8859_10
*  @param ump_ch_source unicode-codepoint of the character to translate
*  @return the character in ISO-8859-10 encoding
*/
static inline char m_u32c_to_i10( unsigned int ump_ch_source ) {
   return m_u32_to_sb_a1a0( ump_ch_source, m_u32c_to_sb_3step,
                            unrg_tabindex_uni_to_i10, ucrg_tabparts_uni_to_i10 );
}
/**
* convert one character to ied_chs_iso8859_11
*  @param ump_ch_source unicode-codepoint of the character to translate
*  @return the character in ISO-8859-11 encoding
*/
static inline char m_u32c_to_i11( unsigned int ump_ch_source ) {
   return m_u32_to_sb_a1a0( ump_ch_source, m_u32c_to_sb_2or3step,
                            unrg_tabindex_uni_to_i11-4, ucrg_tabparts_uni_to_i11 );
}
/**
* convert one character to ied_chs_iso8859_13
*  @param ump_ch_source unicode-codepoint of the character to translate
*  @return the character in ISO-8859-13 encoding
*/
static inline char m_u32c_to_i13( unsigned int ump_ch_source ) {
   return m_u32_to_sb_a1a0( ump_ch_source, m_u32c_to_sb_3step,
                            unrg_tabindex_uni_to_i13, ucrg_tabparts_uni_to_i13 );
}
/**
* convert one character to ied_chs_iso8859_14
*  @param ump_ch_source unicode-codepoint of the character to translate
*  @return the character in ISO-8859-14 encoding
*/
static inline char m_u32c_to_i14( unsigned int ump_ch_source ) {
   return m_u32_to_sb_a1a0( ump_ch_source, m_u32c_to_sb_3or4step,
                            unrg_tabindex_uni_to_i14, ucrg_tabparts_uni_to_i14 );
}
/**
* convert one character to ied_chs_iso8859_15
*  @param ump_ch_source unicode-codepoint of the character to translate
*  @return the character in ISO-8859-15 encoding
*/
static inline char m_u32c_to_i15( unsigned int ump_ch_source ) {
   return m_u32_to_sb_a1a0( ump_ch_source, m_u32c_to_sb_2or3step,
                            unrg_tabindex_uni_to_i15, ucrg_tabparts_uni_to_i15 );
}
/**
* convert one character to ied_chs_iso8859_16
*  @param ump_ch_source unicode-codepoint of the character to translate
*  @return the character in ISO-8859-16 encoding
*/
static inline char m_u32c_to_i16( unsigned int ump_ch_source ) {
   return m_u32_to_sb_a1a0( ump_ch_source, m_u32c_to_sb_3or4step,
                            unrg_tabindex_uni_to_i16, ucrg_tabparts_uni_to_i16 );
}

#ifdef XSLUNIC_OBSOLETE_EXTERNS
/**
* make OEM 437 (single byte per character) from UTF-8
* @deprecated just calls m_sbcl_from_u8l(...,ied_chs_oem_437,...)
*  @param achp_target pointer to output buffer
*  @param inp_max_len_target length of output buffer, 1 byte will be kept free
*  @param achp_source input string (no terminator characters recognised)
*  @param inp_len_source length of input string, in bytes
*  @return count of chars (=bytes) written
*/
extern PTYPE int m_a437l_from_u8l( char *achp_target, int inp_max_len_target,
                                   const char *achp_source, int inp_len_source ) {
   /* extern, but does not appear in hob-xslunic1.h (not even as obsolete)  WS 20141017 */
   return m_sbcl_from_u8l( achp_target, inp_max_len_target, ied_chs_oem_437,
                           achp_source, inp_len_source );
} /* end m_a437l_from_u8l()                                            */
#endif

/**
* make codepage (single byte per character) string from UTF-8
*  @param achp_target pointer to output buffer
*  @param inp_max_len_target length of output buffer, 1 byte will be kept free
*  @param iep_cs_target encoding to use for output
*  @param achp_source input string (no terminator characters recognised)
*  @param inp_len_source length of input string, in bytes
*  @return -1 on unsuitable iep_cs_target, else count of chars (=bytes) written
*/
static int m_sbcl_from_u8l( char *achp_target, int inp_max_len_target,
                            enum ied_charset iep_cs_target,
                            const char *achp_source, int inp_len_source ) {
   const char *achl1, *achl2;               /* working variables       */
   char       *achl_out_cur;                /* current output          */
   char       *achl_out_end;                /* end of output           */
   HL_WCHAR   wcl1;                         /* temporary output character */
   BOOL       bolerror;                     /* invalid input character found */
   unsigned char *aucl_tt;                  /* partitioned table for conversion */
   char       (*aml_f2b)(unsigned int, const unsigned int*, const unsigned char*);  /* function for "[CD]? ??"-bytesequence conversion */
   const unsigned int  *aunl_ti_2b;         /* index table (or front part) for first step of "[CD]? ??"-conversion */
   char       (*aml_f3b)(unsigned int, const unsigned int*, const unsigned char*);  /* function for "E? ?? ??"-bytesequence conversion */
   const unsigned int  *aunl_ti_3b;         /* index table (or last part) for first step of "E? ?? ??"-conversion */
   unsigned char ucl_err809f = 0;           /* what to do with codepoints in 0x80..0x9F */
   const static unsigned int uns_toohigh = 1<<16;  /* used when "E? ?? ??" is surely invalid */

   achl1 = achp_source;                     /* get start input         */
   achl2 = achp_source + inp_len_source;    /* end of input            */
   achl_out_cur = achp_target;              /* current output          */
   achl_out_end = achp_target + inp_max_len_target - 1;  /* end of output  */
   bolerror = FALSE;
   switch (iep_cs_target) {
     case ied_chs_oem_437:
       aucl_tt = ucrg_tabparts_uni_to_437;
       aml_f2b = m_u32c_to_sb_3step;
       aunl_ti_2b = unrg_tabindex_uni_to_437;
       aml_f3b = m_u32c_to_sb_5step;
       aunl_ti_3b = unrg_tabindex_uni_to_437;
       ucl_err809f = ASCII_REP_CHAR;
       break;
     case ied_chs_wcp_1250:
       aucl_tt = ucrg_tabparts_uni_to_1250;
       aml_f2b = m_u32c_to_sb_3or4step;
       aunl_ti_2b = unrg_tabindex_uni_to_1250;
       aml_f3b = m_u32c_to_sb_3step;
       aunl_ti_3b = unrg_tabindex_uni_to_1250+16;
       ucl_err809f = ASCII_REP_CHAR;
       break;
     case ied_chs_wcp_1251:
       aucl_tt = ucrg_tabparts_uni_to_1251;
       aml_f2b = m_u32c_to_sb_2or3step;
       aunl_ti_2b = unrg_tabindex_uni_to_1251;
       aml_f3b = m_u32c_to_sb_2or3step;
       aunl_ti_3b = unrg_tabindex_uni_to_1251+6;
       ucl_err809f = ASCII_REP_CHAR;
       break;
     case ied_chs_wcp_1252:
       aucl_tt = ucrg_tabparts_uni_to_1252;
       aml_f2b = m_u32c_to_sb_3step;
       aunl_ti_2b = unrg_tabindex_uni_to_1252;
       aml_f3b = m_u32c_to_sb_3step;
       aunl_ti_3b = unrg_tabindex_uni_to_1252+16;
       ucl_err809f = ASCII_REP_CHAR;
       break;
     case ied_chs_wcp_1253:
       aucl_tt = ucrg_tabparts_uni_to_1253;
       aml_f2b = m_u32c_to_sb_2or3step;
       aunl_ti_2b = unrg_tabindex_uni_to_1253;
       aml_f3b = m_u32c_to_sb_2or3step;
       aunl_ti_3b = unrg_tabindex_uni_to_1253+6;
       ucl_err809f = ASCII_REP_CHAR;
       break;
     case ied_chs_wcp_1254:
       aucl_tt = ucrg_tabparts_uni_to_1254;
       aml_f2b = m_u32c_to_sb_3or4step;
       aunl_ti_2b = unrg_tabindex_uni_to_1254;
       aml_f3b = m_u32c_to_sb_3step;
       aunl_ti_3b = unrg_tabindex_uni_to_1254+16;
       ucl_err809f = ASCII_REP_CHAR;
       break;
     case ied_chs_wcp_1255:
       aucl_tt = ucrg_tabparts_uni_to_1255;
       aml_f2b = m_u32c_to_sb_3step;
       aunl_ti_2b = unrg_tabindex_uni_to_1255;
       aml_f3b = m_u32c_to_sb_3or4step;
       aunl_ti_3b = unrg_tabindex_uni_to_1255+10;
       ucl_err809f = ASCII_REP_CHAR;
       break;
     case ied_chs_wcp_1256:
       aucl_tt = ucrg_tabparts_uni_to_1256;
       aml_f2b = m_u32c_to_sb_3or4step;
       aunl_ti_2b = unrg_tabindex_uni_to_1256;
       aml_f3b = m_u32c_to_sb_2or3step;
       aunl_ti_3b = unrg_tabindex_uni_to_1256+22;
       ucl_err809f = ASCII_REP_CHAR;
       break;
     case ied_chs_wcp_1257:
       aucl_tt = ucrg_tabparts_uni_to_1257;
       aml_f2b = m_u32c_to_sb_3or4step;
       aunl_ti_2b = unrg_tabindex_uni_to_1257;
       aml_f3b = m_u32c_to_sb_2or3step;
       aunl_ti_3b = unrg_tabindex_uni_to_1257+22;
       ucl_err809f = ASCII_REP_CHAR;
       break;
     case ied_chs_wcp_1258:
       aucl_tt = ucrg_tabparts_uni_to_1258;
       aml_f2b = m_u32c_to_sb_3or4step;
       aunl_ti_2b = unrg_tabindex_uni_to_1258;
       aml_f3b = m_u32c_to_sb_2or3step;
       aunl_ti_3b = unrg_tabindex_uni_to_1258+22;
       ucl_err809f = ASCII_REP_CHAR;
       break;
     case ied_chs_wcp_874:
       aucl_tt = ucrg_tabparts_uni_to_874;
       aml_f2b = m_u32c_to_sb_2or3step;
       aunl_ti_2b = unrg_tabindex_uni_to_874;
       aml_f3b = m_u32c_to_sb_3step;
       aunl_ti_3b = unrg_tabindex_uni_to_874;
       ucl_err809f = ASCII_REP_CHAR;
       break;
     case ied_chs_iso8859_2:
       aucl_tt = ucrg_tabparts_uni_to_i02;
       aml_f2b = m_u32c_to_sb_3step;
       aunl_ti_2b = unrg_tabindex_uni_to_i02;
       aml_f3b = NULL;                      /* avoid compiler warning  */
       aunl_ti_3b = &uns_toohigh;           /* no codes that high here */
       break;
     case ied_chs_iso8859_3:
       aucl_tt = ucrg_tabparts_uni_to_i03;
       aml_f2b = m_u32c_to_sb_3step;
       aunl_ti_2b = unrg_tabindex_uni_to_i03;
       aml_f3b = NULL;                      /* avoid compiler warning  */
       aunl_ti_3b = &uns_toohigh;           /* no codes that high here */
       break;
     case ied_chs_iso8859_4:
       aucl_tt = ucrg_tabparts_uni_to_i04;
       aml_f2b = m_u32c_to_sb_3step;
       aunl_ti_2b = unrg_tabindex_uni_to_i04;
       aml_f3b = NULL;                      /* avoid compiler warning  */
       aunl_ti_3b = &uns_toohigh;           /* no codes that high here */
       break;
     case ied_chs_iso8859_5:
       aucl_tt = ucrg_tabparts_uni_to_i05;
       aml_f2b = m_u32c_to_sb_2or3step;
       aunl_ti_2b = unrg_tabindex_uni_to_i05;
       aml_f3b = m_u32c_to_sb_0step;
       aunl_ti_3b = unrg_tabindex_uni_to_i05+4;
       break;
     case ied_chs_iso8859_6:
       aucl_tt = ucrg_tabparts_uni_to_i06;
       aml_f2b = m_u32c_to_sb_2or3step;
       aunl_ti_2b = unrg_tabindex_uni_to_i06;
       aml_f3b = NULL;                      /* avoid compiler warning  */
       aunl_ti_3b = &uns_toohigh;           /* no codes that high here */
       break;
     case ied_chs_iso8859_7:
       aucl_tt = ucrg_tabparts_uni_to_i07;
       aml_f2b = m_u32c_to_sb_2or3step;
       aunl_ti_2b = unrg_tabindex_uni_to_i07;
       aml_f3b = m_u32c_to_sb_2or3step;
       aunl_ti_3b = unrg_tabindex_uni_to_i07;
       break;
     case ied_chs_iso8859_8:
       aucl_tt = ucrg_tabparts_uni_to_i08;
       aml_f2b = m_u32c_to_sb_2or3step;
       aunl_ti_2b = unrg_tabindex_uni_to_i08;
       aml_f3b = m_u32c_to_sb_2or3step;
       aunl_ti_3b = unrg_tabindex_uni_to_i08;
       break;
     case ied_chs_iso8859_9:
       aucl_tt = ucrg_tabparts_uni_to_i09;
       aml_f2b = m_u32c_to_sb_2or3step;
       aunl_ti_2b = unrg_tabindex_uni_to_i09;
       aml_f3b = NULL;                      /* avoid compiler warning  */
       aunl_ti_3b = &uns_toohigh;           /* no codes that high here */
       break;
     case ied_chs_iso8859_10:
       aucl_tt = ucrg_tabparts_uni_to_i10;
       aml_f2b = m_u32c_to_sb_3step;
       aunl_ti_2b = unrg_tabindex_uni_to_i10;
       aml_f3b = m_u32c_to_sb_0step;
       aunl_ti_3b = unrg_tabindex_uni_to_i10+14;
       break;
     case ied_chs_iso8859_11:
       aucl_tt = ucrg_tabparts_uni_to_i11;
       aml_f2b = m_u32c_to_sb_0step;
       aunl_ti_2b = unrg_tabindex_uni_to_i11;
       aml_f3b = m_u32c_to_sb_2or3step;
       aunl_ti_3b = unrg_tabindex_uni_to_i11;
       break;
     case ied_chs_iso8859_13:
       aucl_tt = ucrg_tabparts_uni_to_i13;
       aml_f2b = m_u32c_to_sb_3step;
       aunl_ti_2b = unrg_tabindex_uni_to_i13;
       aml_f3b = m_u32c_to_sb_0step;
       aunl_ti_3b = unrg_tabindex_uni_to_i13+14;
       break;
     case ied_chs_iso8859_14:
       aucl_tt = ucrg_tabparts_uni_to_i14;
       aml_f2b = m_u32c_to_sb_2or3step;
       aunl_ti_2b = unrg_tabindex_uni_to_i14;
       aml_f3b = m_u32c_to_sb_3step;
       aunl_ti_3b = unrg_tabindex_uni_to_i14+6;
       break;
     case ied_chs_iso8859_15:
       aucl_tt = ucrg_tabparts_uni_to_i15;
       aml_f2b = m_u32c_to_sb_2or3step;
       aunl_ti_2b = unrg_tabindex_uni_to_i15;
       aml_f3b = m_u32c_to_sb_0step;
       aunl_ti_3b = unrg_tabindex_uni_to_i15+8;
       break;
     case ied_chs_iso8859_16:
       aucl_tt = ucrg_tabparts_uni_to_i16;
       aml_f2b = m_u32c_to_sb_3or4step;
       aunl_ti_2b = unrg_tabindex_uni_to_i16;
       aml_f3b = m_u32c_to_sb_2or3step;
       aunl_ti_3b = unrg_tabindex_uni_to_i16+12;
       break;
     default:
       /*bolerror = TRUE;?*/
       return -1;
   }
   while (achl1 < achl2) {
     if (achl_out_cur >= achl_out_end) {
       return achl_out_cur - achp_target;
     }
     if (((signed char) *achl1) >= 0) {
       *achl_out_cur++ = *achl1++;          /* below U+0080, identity  */
     } else {
       wcl1 = (WCHAR) *achl1++;
       if (achl1 >= achl2) {
         bolerror = TRUE;
         break;
       }
       if ((*achl1 & 0XC0) != 0x80) {
         bolerror = TRUE;
         break;
       }
       if ((wcl1 & 0xE0) == 0xC0) {         /* below U+0800            */
         wcl1 = ((wcl1 & 0X1F) << 6) | (*achl1 & 0X3F);
         if (wcl1<*aunl_ti_2b) {
           *achl_out_cur = (ucl_err809f ? ucl_err809f : wcl1);
         } else {
           *achl_out_cur = aml_f2b(wcl1, aunl_ti_2b, aucl_tt);
         }
         achl1++;
       } else if((wcl1 & 0xF0) == 0xE0) {   /* in 0800..2FFF range     */
         wcl1 = 0x2000 | ((*achl1++ & 0X3F) << 6);
         if ((achl1 >= achl2) || ((*achl1 & 0XC0) != 0x80)) {
           bolerror = TRUE;
           break;
         }
         wcl1 |= (*achl1++ & 0X3F);
         if (wcl1<*aunl_ti_3b) {
           *achl_out_cur = ASCII_REP_CHAR;
         } else {
           *achl_out_cur = aml_f3b(wcl1, aunl_ti_3b, aucl_tt);
         }
       } else {
         bolerror = TRUE;
         break;
       }
       achl_out_cur++;
     }
   }
   /* XXX bolerror is never used (except being set) */
   return achl_out_cur - achp_target;
} /* end m_sbcl_from_u8l()                                             */

/**
* make CJK-codepage (1 or 2 byte per character) string from UTF-8
*  @param achp_target output buffer
*  @param inp_max_len_target length of output buffer, 1 byte will be kept free
*  @param awcp_ttfu conversion table as described at m_get_tab_uni_to_mb
*  @param achp_source input string (no terminator characters recognised)
*  @param inp_len_source length of input string, in bytes
*  @param[out] abop_mlt_cut if non-NULL, whether a 2-byte char would hit the end
*  @return count of bytes written
*/
static int m_mbcl_from_u8l( char *achp_target, int inp_max_len_target,
                            const HL_WCHAR* awcp_ttfu, const char *achp_source,
                            int inp_len_source, BOOL* abop_mlt_cut ) {
   unsigned char *achl1, *achl2;            /* working variables       */
   char          *achl_out_cur;             /* current output          */
   char          *achl_out_end;             /* end of output           */
   HL_WCHAR   wcl1;                         /* temporary output character */

   achl1 = (unsigned char*) achp_source;    /* get start input         */
   achl2 = achl1 + inp_len_source;          /* end of input            */
   if (abop_mlt_cut != NULL)
     *abop_mlt_cut = FALSE;                 /* no byte cut off yet     */
   achl_out_cur = achp_target;              /* current output          */
   achl_out_end = achp_target + inp_max_len_target - 1;  /* end of output */
   while (achl1 < achl2) {
     if (achl_out_cur >= achl_out_end) {
       return achl_out_cur - achp_target;   /* end of output reached   */
     }
     wcl1 = *achl1++;
     switch (chrs_decode_utf_1_tab[wcl1]) {
       case 0:
         *achl_out_cur++ = (char)wcl1;      /* below U+0080, identity  */
         continue;                          /* look for next character */
       case 1:                              /* stray continuation char */
         return achl_out_cur - achp_target;  /* abort                  */
       case 2:                              /* below U+0800            */
         if ((achl1 >= achl2) || ((*achl1 & 0XC0) != 0x80)) /* invalid */
           return achl_out_cur - achp_target;  /* abort                */
         wcl1 = awcp_ttfu[ ((wcl1 & 0X1F) << 6) | (*achl1++ & 0X3F) ];
         break;
       case 3:                              /* in 0800..FFFF range     */
         if ((achl1+1 >= achl2) || ((*achl1 & 0XC0) != 0x80)) /* invalid */
           return achl_out_cur - achp_target;  /* abort                */
         wcl1 = (0xF000 & (wcl1 << 12)) | ((*achl1++ & 0X3F) << 6);
         if ((*achl1 & 0XC0) != 0x80)       /* invalid input character */
           return achl_out_cur - achp_target;  /* abort                */
         wcl1 = awcp_ttfu[ wcl1 | (*achl1++ & 0X3F) ];
         break;
       default:      /* these CJK-codepages encode nothing over U+FFFF */
         achl1 += chrs_decode_utf_1_tab[wcl1] - 1;
         *achl_out_cur++ = ASCII_REP_CHAR;  /* unknown character       */
         continue;                          /* look for next character */
     }
     if (wcl1 > 0xFF) {                     /* two-byte output char    */
       *achl_out_cur++ = (char)(wcl1>>8);
       if (achl_out_cur >= achl_out_end) {  /* check end of output     */
         if (abop_mlt_cut != NULL)
           *abop_mlt_cut = TRUE;            /* maxlen would cut a char */
         return (achl_out_cur-achp_target) - 1;  /* discard char part  */
       }
     }
     *achl_out_cur++ = (char)wcl1;
   }
   return achl_out_cur - achp_target;       /* source end reached      */
} /* end m_mbcl_from_u8l()                                             */

/**
* method to convert an UTF8-String to single-byte character
*  @param achp_target output buffer. Output will be zero-terminated.
*  @param imp_max_len_target maximum count of characters to copy; the output
*                            buffer must have 1 byte more for terminating zero
*  @param achp_source input string. May be zero-terminated to stop processing
*                                   before the end of output-buffer.
*  @param iep_cs_target encoding to use for output
*  @return -1 if iep_cs_target is not a supported single-byte encoding, else
*          the number of chars (bytes) written, excluding the terminating zero
*/
extern PTYPE int m_sbc_from_u8l(char *achp_target, int imp_max_len_target,
                                const char *achp_source, enum ied_charset iep_cs_target){
   char           *achl_cur;                /* current position        */
   /*char           *achl_end;               * maximum output position */
   const char     *achl_source;   /* pointer to an UTF8-string to read */
   unsigned short us_bytestored;            /* bytes from UTF8 to read */
   HL_WCHAR       wcl1;                     /* temporary character     */
   unsigned char      *aucl_tt;     /* partitioned table for conversion */
   char               (*aml_f2b)(unsigned int, const unsigned int*, const unsigned char*);  /* function for "[CD]? ??"-bytesequence conversion */
   const unsigned int *aunl_ti_2b;  /* index table (or front part) for first step of "[CD]? ??"-conversion */
   char               (*aml_f3b)(unsigned int, const unsigned int*, const unsigned char*);  /* function for "E? ?? ??"-bytesequence conversion */
   const unsigned int *aunl_ti_3b;  /* index table (or last part) for first step of "E? ?? ??"-conversion */
   const static unsigned int uns_toohigh = 1<<16;  /* used when "E? ?? ??" is surely invalid */
   int iml_count = 0;

   achl_cur = achp_target;                  /* start here              */
   /*achl_end = achp_target + imp_max_len_target;     * maximum output */
   achl_source = achp_source;
   switch (iep_cs_target) {
     case ied_chs_ascii_850:
       while (iml_count < imp_max_len_target && (*achl_source)) {
         us_bytestored = chrs_trail_u8l[(unsigned char)*achl_source];
      //   if(achl_source + us_bytestored > ?? )  /* and 10...... is also not checked! */
        //    break;                              /* at maximum output       */
         if((signed char) *achl_source >= 0) {  /* ASCII               */
           *achl_cur++ = ucrg_tab_819_to_850[(unsigned)*achl_source];
           iml_count++;
         } else {
           if((unsigned char)*achl_source <= 0xC3)  /* Latin-1         */
             *achl_cur++ = (char) ucrg_tab_819_to_850[(int) (*achl_source & 0x03) << 6 | (*(achl_source + 1) & 0x3F)];
           else
             *achl_cur++ = ASCII_REP_CHAR;  /* reprensent unknown characters as character ? */
           iml_count++;
         }
         achl_source += us_bytestored + 1;  /* next character          */
       }
       break;
     case ied_chs_ansi_819:
       while (iml_count < imp_max_len_target && (*achl_source)) {
         us_bytestored = chrs_trail_u8l[(unsigned char)*achl_source];
      //   if(achl_source + us_bytestored > ?? )  /* and 10...... is also not checked! */
        //    break;                              /* at maximum output       */
         if((signed char) *achl_source >= 0) {  /* ASCII               */
           *achl_cur++ = *achl_source;          /* identity in 819     */
           iml_count++;
         } else {
           if((unsigned char)*achl_source <= 0xC3)  /* Latin-1         */
             *achl_cur++ = (*achl_source & 0x03) << 6 | (*(achl_source + 1) & 0x3F);
           else
             *achl_cur++ = ASCII_REP_CHAR;  /* reprensent unknown characters as character ? */
           iml_count++;
         }
         achl_source += us_bytestored + 1;  /* next character          */
       }
       break;
     do {  /* variant of Duffs device, the "break" go to the end of this pseudoloop */
     case ied_chs_oem_437:
       aucl_tt = ucrg_tabparts_uni_to_437;
       aml_f2b = m_u32c_to_sb_3step;
       aunl_ti_2b = unrg_tabindex_uni_to_437;
       aml_f3b = m_u32c_to_sb_5step;
       aunl_ti_3b = unrg_tabindex_uni_to_437;
       break;
     case ied_chs_wcp_874:  /* this CP (Thai) is the only of them that codes
       chars in the region U+0800..U+1FFF (namely U+0E01..U+0E5B, that are
       coded (with an undefined hole) by the value minus 3424).
       So one could implement it somewhat more efficient. */
       aucl_tt = ucrg_tabparts_uni_to_874;
       aml_f2b = m_u32c_to_sb_0step;
       aunl_ti_2b = unrg_tabindex_uni_to_874;
       aml_f3b = m_u32c_to_sb_3step;
       aunl_ti_3b = unrg_tabindex_uni_to_874;
       break;
     case ied_chs_wcp_1250:
       aucl_tt = ucrg_tabparts_uni_to_1250;
       aml_f2b = m_u32c_to_sb_3or4step;
       aunl_ti_2b = unrg_tabindex_uni_to_1250;
       aml_f3b = m_u32c_to_sb_3step;
       aunl_ti_3b = unrg_tabindex_uni_to_1250+16;
       break;
     case ied_chs_wcp_1251:
       aucl_tt = ucrg_tabparts_uni_to_1251;
       aml_f2b = m_u32c_to_sb_2or3step;
       aunl_ti_2b = unrg_tabindex_uni_to_1251;
       aml_f3b = m_u32c_to_sb_2or3step;
       aunl_ti_3b = unrg_tabindex_uni_to_1251+6;
       break;
     case ied_chs_wcp_1252:
       aucl_tt = ucrg_tabparts_uni_to_1252;
       aml_f2b = m_u32c_to_sb_3step;
       aunl_ti_2b = unrg_tabindex_uni_to_1252;
       aml_f3b = m_u32c_to_sb_3step;
       aunl_ti_3b = unrg_tabindex_uni_to_1252+16;
       break;
     case ied_chs_wcp_1253:
       aucl_tt = ucrg_tabparts_uni_to_1253;
       aml_f2b = m_u32c_to_sb_2or3step;
       aunl_ti_2b = unrg_tabindex_uni_to_1253;
       aml_f3b = m_u32c_to_sb_2or3step;
       aunl_ti_3b = unrg_tabindex_uni_to_1253+6;
       break;
     case ied_chs_wcp_1254:
       aucl_tt = ucrg_tabparts_uni_to_1254;
       aml_f2b = m_u32c_to_sb_3or4step;
       aunl_ti_2b = unrg_tabindex_uni_to_1254;
       aml_f3b = m_u32c_to_sb_3step;
       aunl_ti_3b = unrg_tabindex_uni_to_1254+16;
       break;
     case ied_chs_wcp_1255:
       aucl_tt = ucrg_tabparts_uni_to_1255;
       aml_f2b = m_u32c_to_sb_3step;
       aunl_ti_2b = unrg_tabindex_uni_to_1255;
       aml_f3b = m_u32c_to_sb_3or4step;
       aunl_ti_3b = unrg_tabindex_uni_to_1255+10;
       break;
     case ied_chs_wcp_1256:
       aucl_tt = ucrg_tabparts_uni_to_1256;
       aml_f2b = m_u32c_to_sb_3or4step;
       aunl_ti_2b = unrg_tabindex_uni_to_1256;
       aml_f3b = m_u32c_to_sb_2or3step;
       aunl_ti_3b = unrg_tabindex_uni_to_1256+22;
       break;
     case ied_chs_wcp_1257:
       aucl_tt = ucrg_tabparts_uni_to_1257;
       aml_f2b = m_u32c_to_sb_3or4step;
       aunl_ti_2b = unrg_tabindex_uni_to_1257;
       aml_f3b = m_u32c_to_sb_2or3step;
       aunl_ti_3b = unrg_tabindex_uni_to_1257+22;
       break;
     case ied_chs_wcp_1258:
       aucl_tt = ucrg_tabparts_uni_to_1258;
       aml_f2b = m_u32c_to_sb_3or4step;
       aunl_ti_2b = unrg_tabindex_uni_to_1258;
       aml_f3b = m_u32c_to_sb_2or3step;
       aunl_ti_3b = unrg_tabindex_uni_to_1258+22;
       break;
     } while (FALSE);                       /* end of the pseudoloop   */
       while (iml_count < imp_max_len_target && (*achl_source)) {
         us_bytestored = chrs_trail_u8l[(unsigned char)*achl_source];
      //   if(achl_source + us_bytestored > ?? )  /* and 10...... is also not checked! */
        //    break;                              /* at maximum output       */
         if((signed char) *achl_source >= 0) {  /* ASCII               */
           *achl_cur++ = *achl_source;    /* identity in all these CPs */
         } else {
           if(((unsigned char)*achl_source & 0xF0) == 0xE0) {  /* in 0800..2FFF range */
             wcl1 = ((achl_source[0] & 0X0F) << 12) | ((achl_source[1] & 0X3F) << 6) | (achl_source[2] & 0X3F);
             if (wcl1<*aunl_ti_3b) {
               *achl_cur++ = ASCII_REP_CHAR;
             } else {
               *achl_cur++ = aml_f3b(wcl1, aunl_ti_3b, aucl_tt);
             }
           } else if (((unsigned char)*achl_source & 0xE0) == 0xC0) {
             wcl1 = ((achl_source[0] & 0X1F) << 6) | (achl_source[1] & 0X3F);
             if (wcl1<*aunl_ti_2b) {
               *achl_cur++ = ASCII_REP_CHAR;
             } else {
               *achl_cur++ = aml_f2b(wcl1, aunl_ti_2b, aucl_tt);
             }
           } else {
             *achl_cur++ = ASCII_REP_CHAR;  /* unknown character       */
           }
         }
         iml_count++;
         achl_source += us_bytestored + 1;  /* next character          */
       }
       break;
     do {  /* variant of Duffs device, the "break" go to the end of this pseudoloop */
     case ied_chs_iso8859_2:
       aucl_tt = ucrg_tabparts_uni_to_i02;
       aml_f2b = m_u32c_to_sb_3step;
       aunl_ti_2b = unrg_tabindex_uni_to_i02;
       aml_f3b = NULL;                      /* avoid compiler warning  */
       aunl_ti_3b = &uns_toohigh;           /* no codes that high here */
       break;
     case ied_chs_iso8859_3:
       aucl_tt = ucrg_tabparts_uni_to_i03;
       aml_f2b = m_u32c_to_sb_3step;
       aunl_ti_2b = unrg_tabindex_uni_to_i03;
       aml_f3b = NULL;                      /* avoid compiler warning  */
       aunl_ti_3b = &uns_toohigh;           /* no codes that high here */
       break;
     case ied_chs_iso8859_4:
       aucl_tt = ucrg_tabparts_uni_to_i04;
       aml_f2b = m_u32c_to_sb_3step;
       aunl_ti_2b = unrg_tabindex_uni_to_i04;
       aml_f3b = NULL;                      /* avoid compiler warning  */
       aunl_ti_3b = &uns_toohigh;           /* no codes that high here */
       break;
     case ied_chs_iso8859_5:
       aucl_tt = ucrg_tabparts_uni_to_i05;
       aml_f2b = m_u32c_to_sb_2or3step;
       aunl_ti_2b = unrg_tabindex_uni_to_i05;
       aml_f3b = m_u32c_to_sb_0step;
       aunl_ti_3b = unrg_tabindex_uni_to_i05+4;
       break;
     case ied_chs_iso8859_6:
       aucl_tt = ucrg_tabparts_uni_to_i06;
       aml_f2b = m_u32c_to_sb_2or3step;
       aunl_ti_2b = unrg_tabindex_uni_to_i06;
       aml_f3b = NULL;                      /* avoid compiler warning  */
       aunl_ti_3b = &uns_toohigh;           /* no codes that high here */
       break;
     case ied_chs_iso8859_7:
       aucl_tt = ucrg_tabparts_uni_to_i07;
       aml_f2b = m_u32c_to_sb_2or3step;
       aunl_ti_2b = unrg_tabindex_uni_to_i07;
       aml_f3b = m_u32c_to_sb_2or3step;
       aunl_ti_3b = unrg_tabindex_uni_to_i07;
       break;
     case ied_chs_iso8859_8:
       aucl_tt = ucrg_tabparts_uni_to_i08;
       aml_f2b = m_u32c_to_sb_2or3step;
       aunl_ti_2b = unrg_tabindex_uni_to_i08;
       aml_f3b = m_u32c_to_sb_2or3step;
       aunl_ti_3b = unrg_tabindex_uni_to_i08;
       break;
     case ied_chs_iso8859_9:
       aucl_tt = ucrg_tabparts_uni_to_i09;
       aml_f2b = m_u32c_to_sb_2or3step;
       aunl_ti_2b = unrg_tabindex_uni_to_i09;
       aml_f3b = NULL;                      /* avoid compiler warning  */
       aunl_ti_3b = &uns_toohigh;           /* no codes that high here */
       break;
     case ied_chs_iso8859_10:
       aucl_tt = ucrg_tabparts_uni_to_i10;
       aml_f2b = m_u32c_to_sb_3step;
       aunl_ti_2b = unrg_tabindex_uni_to_i10;
       aml_f3b = m_u32c_to_sb_0step;
       aunl_ti_3b = unrg_tabindex_uni_to_i10+14;
       break;
     case ied_chs_iso8859_11:
       aucl_tt = ucrg_tabparts_uni_to_i11;
       aml_f2b = m_u32c_to_sb_0step;
       aunl_ti_2b = unrg_tabindex_uni_to_i11;
       aml_f3b = m_u32c_to_sb_2or3step;
       aunl_ti_3b = unrg_tabindex_uni_to_i11;
       break;
     case ied_chs_iso8859_13:
       aucl_tt = ucrg_tabparts_uni_to_i13;
       aml_f2b = m_u32c_to_sb_3step;
       aunl_ti_2b = unrg_tabindex_uni_to_i13;
       aml_f3b = m_u32c_to_sb_0step;
       aunl_ti_3b = unrg_tabindex_uni_to_i13+14;
       break;
     case ied_chs_iso8859_14:
       aucl_tt = ucrg_tabparts_uni_to_i14;
       aml_f2b = m_u32c_to_sb_2or3step;
       aunl_ti_2b = unrg_tabindex_uni_to_i14;
       aml_f3b = m_u32c_to_sb_3step;
       aunl_ti_3b = unrg_tabindex_uni_to_i14+6;
       break;
     case ied_chs_iso8859_15:
       aucl_tt = ucrg_tabparts_uni_to_i15;
       aml_f2b = m_u32c_to_sb_2or3step;
       aunl_ti_2b = unrg_tabindex_uni_to_i15;
       aml_f3b = m_u32c_to_sb_0step;
       aunl_ti_3b = unrg_tabindex_uni_to_i15+8;
       break;
     case ied_chs_iso8859_16:
       aucl_tt = ucrg_tabparts_uni_to_i16;
       aml_f2b = m_u32c_to_sb_3or4step;
       aunl_ti_2b = unrg_tabindex_uni_to_i16;
       aml_f3b = m_u32c_to_sb_2or3step;
       aunl_ti_3b = unrg_tabindex_uni_to_i16+12;
       break;
     } while (FALSE);                       /* end of the pseudoloop   */
       while (iml_count < imp_max_len_target && (*achl_source)) {
         us_bytestored = chrs_trail_u8l[(unsigned char)*achl_source];
      //   if(achl_source + us_bytestored > ?? )  /* and 10...... is also not checked! */
        //    break;                              /* at maximum output       */
         if((signed char) *achl_source >= 0) {  /* ASCII               */
           *achl_cur++ = *achl_source;    /* identity in all these CPs */
         } else {
           if(((unsigned char)*achl_source & 0xF0) == 0xE0) {  /* in 0800..2FFF range */
             wcl1 = ((achl_source[0] & 0X0F) << 12) | ((achl_source[1] & 0X3F) << 6) | (achl_source[2] & 0X3F);
             if (wcl1<*aunl_ti_3b) {
               *achl_cur++ = ASCII_REP_CHAR;
             } else {
               *achl_cur++ = aml_f3b(wcl1, aunl_ti_3b, aucl_tt);
             }
           } else if (((unsigned char)*achl_source & 0xE0) == 0xC0) {
             wcl1 = ((achl_source[0] & 0X1F) << 6) | (achl_source[1] & 0X3F);
             if (wcl1<*aunl_ti_2b) {
               *achl_cur++ = (char)wcl1;  /* the ISO8859s have identity up to 0xA0 */
             } else {
               *achl_cur++ = aml_f2b(wcl1, aunl_ti_2b, aucl_tt);
             }
           } else {
             *achl_cur++ = ASCII_REP_CHAR;  /* unknown character       */
           }
         }
         iml_count++;
         achl_source += us_bytestored + 1;  /* next character          */
       }
       break;
     default:
       return -1;
   }
   *achl_cur = '\0';
   return (achl_cur - achp_target);
}/* end m_sbc_from_u8l */

/**
* Two-step-conversion from unicode to a 8-bit code using tables.
* This function can distinguish 32 regions and is used by 1 case that needs all 32,
*  and 1 case that needs the last 24.
*  @param ump_ch_source The unicode codepoint to convert. Must be >= aunp_ti[0].
*  @param aunp_ti first-step table; format like in unrg_tabindex_uni_to_437
*  @param aucp_tp second-step table; format like in ucrg_tabparts_uni_to_437
*  @return The encoded character. 0x00 cannot be reached.
*/
static char m_u32c_to_sb_5step( unsigned int ump_ch_source, const unsigned int* aunp_ti, const unsigned char* aucp_tp ) {
   int inl_idx;  /* index into directory of table parts */
   int inl_cidx;  /* index into translation table */
   unsigned char ucl_found;
   /* five-step binary search to find the table part */
   inl_idx = ump_ch_source<aunp_ti[32] ? 16 : 48;
   inl_idx += ump_ch_source<aunp_ti[inl_idx] ? -8 : 8;
   inl_idx += ump_ch_source<aunp_ti[inl_idx] ? -4 : 4;
   inl_idx += ump_ch_source<aunp_ti[inl_idx] ? -2 : 2;
   inl_cidx = ump_ch_source-aunp_ti[inl_idx];
   if (inl_cidx<0) {
     inl_idx -= 2;
     /* get index for translation table proper */
     inl_cidx = aunp_ti[inl_idx+1]+ump_ch_source-aunp_ti[inl_idx];
   } else {
     /* get index for translation table proper */
     inl_cidx += aunp_ti[inl_idx+1];
   }
   /* check if input char is in a defined region (for this check the array has its cell 65) */
   if (inl_cidx >= (int)aunp_ti[inl_idx+3])
     return ASCII_REP_CHAR;                 /* after end of region     */
   ucl_found = aucp_tp[inl_cidx];
   if (ucl_found == 0)     /* test for hitting a gap within the region */
     return ASCII_REP_CHAR;
   return (char)ucl_found;
}/* end m_u32c_to_sb_5step */

/**
* Two-step-conversion from unicode to a 8-bit code using tables.
* This function can distinguish 16 regions and is used by 7 cases that all need all 16
*  @param ump_ch_source
*  @param aunp_ti first-step table; format like in unrg_tabindex_uni_to_437
*  @param aucp_tp second-step table; format like in ucrg_tabparts_uni_to_437
*  @return The encoded character. 0x00 cannot be reached.
*/
static char m_u32c_to_sb_4step( unsigned int ump_ch_source, const unsigned int* aunp_ti, const unsigned char* aucp_tp ) {
   int inl_idx;  /* index into directory of table parts */
   int inl_cidx;  /* index into translation table */
   unsigned char ucl_found;
   /* four-step binary search to find the table part */
   inl_idx = ump_ch_source<aunp_ti[16] ? 8 : 24;
   inl_idx += ump_ch_source<aunp_ti[inl_idx] ? -4 : 4;
   inl_idx += ump_ch_source<aunp_ti[inl_idx] ? -2 : 2;
   inl_cidx = ump_ch_source-aunp_ti[inl_idx];
   if (inl_cidx<0) {
     inl_idx -= 2;
     /* get index for translation table proper */
     inl_cidx = aunp_ti[inl_idx+1]+ump_ch_source-aunp_ti[inl_idx];
   } else {
     /* get index for translation table proper */
     inl_cidx += aunp_ti[inl_idx+1];
   }
   /* check if input char is in a defined region (for this check the array has its cell 33) */
   if (inl_cidx >= (int)aunp_ti[inl_idx+3])
     return ASCII_REP_CHAR;                 /* after end of region     */
   ucl_found = aucp_tp[inl_cidx];
   if (ucl_found == 0)     /* test for hitting a gap within the region */
     return ASCII_REP_CHAR;
   return (char)ucl_found;
}/* end m_u32c_to_sb_4step */

/**
* Two-step-conversion from unicode to a 8-bit code using tables.
* This function can distinguish 11 regions and is used by 5 cases that need all 11,
*  1 case that needs 10, and 3 cases that need 9.
*  @param ump_ch_source
*  @param aunp_ti first-step table; format like in unrg_tabindex_uni_to_437
*  @param aucp_tp second-step table; format like in ucrg_tabparts_uni_to_437
*  @return The encoded character. 0x00 cannot be reached.
*/
static char m_u32c_to_sb_3or4step( unsigned int ump_ch_source, const unsigned int* aunp_ti, const unsigned char* aucp_tp ) {
   int inl_idx;                          /* index into directory-table */
   unsigned char ucl_found;
   /* binary search in 11-entry part of the directory table            */
   if (ump_ch_source<aunp_ti[10]) {
     if (ump_ch_source<aunp_ti[6]) {
       inl_idx = ((ump_ch_source<aunp_ti[4])
           ? ((ump_ch_source<aunp_ti[2])?0:2)
           : 4
         );
     } else {
       inl_idx = ((ump_ch_source<aunp_ti[8]) ? 6 : 8);
     }
   } else {
     if (ump_ch_source<aunp_ti[14]) {
       inl_idx = ((ump_ch_source<aunp_ti[12]) ? 10 : 12);
     } else {
       inl_idx = ((ump_ch_source<aunp_ti[18])
           ? ((ump_ch_source<aunp_ti[16])?14:16)
           : ((ump_ch_source<aunp_ti[20])?18:20)
         );
     }
   }
   /* now look it up in the right table region                         */
   ump_ch_source -= (aunp_ti[inl_idx] - aunp_ti[inl_idx+1]);
   /* check if input char is in a defined region (for this check the array has its cell 23) */
   if (ump_ch_source >= aunp_ti[inl_idx+3])
     return ASCII_REP_CHAR;                 /* after end of region     */
   ucl_found = aucp_tp[ ump_ch_source ];
   if (ucl_found == 0)     /* test for hitting a gap within the region */
     return ASCII_REP_CHAR;
   return (char)ucl_found;
}/* end m_u32c_to_sb_3or4step */

/**
* Two-step-conversion from unicode to a 8-bit code using tables.
* This function can distinguish 8 regions and is used by 13 cases that need all 8,
*  6 cases that needs 7 and 2 cases that need 6.
*  @param ump_ch_source
*  @param aunp_ti first-step table; format like in unrg_tabindex_uni_to_437
*  @param aucp_tp second-step table; format like in ucrg_tabparts_uni_to_437
*  @return The encoded character. 0x00 cannot be reached.
*/
static char m_u32c_to_sb_3step( unsigned int ump_ch_source, const unsigned int* aunp_ti, const unsigned char* aucp_tp ) {
   int inl_idx;  /* index into directory of table parts */
   int inl_cidx;  /* index into translation table */
   unsigned char ucl_found;
   /* three-step binary search to find the table part */
   inl_idx = ump_ch_source<aunp_ti[8] ? 4 : 12;
   inl_idx += ump_ch_source<aunp_ti[inl_idx] ? -2 : 2;
   inl_cidx = ump_ch_source-aunp_ti[inl_idx];
   if (inl_cidx<0) {
     inl_idx -= 2;
     /* get index for translation table proper */
     inl_cidx = aunp_ti[inl_idx+1]+ump_ch_source-aunp_ti[inl_idx];
   } else {
     /* get index for translation table proper */
     inl_cidx += aunp_ti[inl_idx+1];
   }
   /* check if input char is in a defined region (for this check the array has its cell 17) */
   if (inl_cidx >= (int)aunp_ti[inl_idx+3])
     return ASCII_REP_CHAR;                 /* after end of region     */
   ucl_found = aucp_tp[inl_cidx];
   if (ucl_found == 0)     /* test for hitting a gap within the region */
     return ASCII_REP_CHAR;
   return (char)ucl_found;
}/* end m_u32c_to_sb_3step */

/**
* Two-step-conversion from unicode to a 8-bit code using tables.
* This function can distinguish 5 regions and is used by 9 cases that need all 5,
*  5 cases that needs 4, 6 cases that need 3 and 6 cases that need 2.
*  @param ump_ch_source
*  @param aunp_ti first-step table; format like in unrg_tabindex_uni_to_437
*  @param aucp_tp second-step table; format like in ucrg_tabparts_uni_to_437
*  @return The encoded character. 0x00 cannot be reached.
*/
static char m_u32c_to_sb_2or3step( unsigned int ump_ch_source, const unsigned int* aunp_ti, const unsigned char* aucp_tp ) {
   int inl_idx;                          /* index into directory-table */
   unsigned char ucl_found;
   /* binary search in 5-entry part of the directory table             */
   if (ump_ch_source<aunp_ti[4]) {
     inl_idx = ((ump_ch_source<aunp_ti[2]) ? 0 : 2);
   } else {
     inl_idx = ((ump_ch_source<aunp_ti[6])
         ? 4
         : ((ump_ch_source<aunp_ti[8])?6:8)
       );
   }
   /* now look it up in the right table region                         */
   ump_ch_source -= (aunp_ti[inl_idx] - aunp_ti[inl_idx+1]);
   /* check if input char is in a defined region (for this check the array has its cell 11) */
   if (ump_ch_source >= aunp_ti[inl_idx+3])
     return ASCII_REP_CHAR;                 /* after end of region     */
   ucl_found = aucp_tp[ ump_ch_source ];
   if (ucl_found == 0)     /* test for hitting a gap within the region */
     return ASCII_REP_CHAR;
   return (char)ucl_found;
}/* end m_u32c_to_sb_2or3step */

/**
* Two-step-conversion from unicode to a 8-bit code using tables.
* This function can "distinguish" 1 region and is used by 6 cases (it is a
* degenerate variant of the two-step-conversion-functions because there is no
* first-step decision).
*  @param ump_ch_source
*  @param aunp_ti first-step table; one pair like in unrg_tabindex_uni_to_437
*  @param aucp_tp second-step table; format like in ucrg_tabparts_uni_to_437
*  @return The encoded character. 0x00 cannot be reached.
*/
static char m_u32c_to_sb_0step( unsigned int ump_ch_source, const unsigned int* aunp_ti, const unsigned char* aucp_tp ) {
   unsigned char ucl_found;
   /* look it up in the given table region                             */
   ump_ch_source -= (aunp_ti[0] - aunp_ti[1]);
   if (ump_ch_source >= aunp_ti[3])
     return ASCII_REP_CHAR;                 /* after end of region     */
   ucl_found = aucp_tp[ ump_ch_source ];
   if (ucl_found == 0)     /* test for hitting a gap within the region */
     return ASCII_REP_CHAR;
   return (char)ucl_found;
}/* end m_u32c_to_sb_0step */

/** method to return the UTF-8 values of a ANSI-819-String              */
/* return count characters of target field
*  @param achp_target output buffer (will get no terminator if not copied from
*                     source, but one byte of the space is kept reserved)
*  @param inp_max_len_target length of output buffer, in bytes
*  @param achp_source input string
*  @param inp_len_source length of input string
*  @return -1 if output overflow, else count characters (bytes) of target field
*/
extern PTYPE int m_u8l_from_a819l( char *achp_target,       int inp_max_len_target,
                                   const char *achp_source, int inp_len_source ) {
   signed char *achl_cur;                   /* current position        */
   signed char *achl_end;                   /* maximum output position */
   signed char *achl_out_cur;               /* current position output */
   signed char *achl_out_end;               /* maximum output position */

   achl_cur = (signed char *) achp_source;  /* current position        */
   achl_end = (signed char *) achp_source + inp_len_source;
   achl_out_cur = (signed char *) achp_target;
   achl_out_end = (signed char *) achp_target + inp_max_len_target - 1;
   while (achl_cur < achl_end) {
     if (achl_out_cur >= achl_out_end) return -1;
     if (((signed char) *achl_cur) >= 0) {  /* not 0X80 set            */
       *achl_out_cur++ = *achl_cur;
     } else {                               /* zero or X80             */
       *achl_out_cur++ = 0XC0 | ((unsigned char)(*achl_cur) >> 6);
       /* check at maximum output                                      */
       if (achl_out_cur >= achl_out_end) return -1;
       *achl_out_cur++ = 0X80 | (*achl_cur & 0X3F);
     }
     achl_cur++;                            /* increment input         */
   }
   return ((char *) achl_out_cur - achp_target);  /* return count characters */
} /* end m_u8l_from_a819l()                                            */

/** method to return the UTF-8 values of a ASCII-850-String             */
/* return count characters of target field
*  @param achp_target output buffer (will get no terminator if not copied from
*                     source, but one byte of the space is kept reserved)
*  @param inp_max_len_target length of output buffer, in bytes
*  @param achp_source input string
*  @param inp_len_source length of input string
*  @return -1 if output overflow, else count characters (bytes) of target field
*/
extern PTYPE int m_u8l_from_a850l( char *achp_target,       int inp_max_len_target,
                                   const char *achp_source, int inp_len_source ) {
   char        chl_w1;                      /* working-variable        */
   signed char *achl_cur;                   /* current position        */
   signed char *achl_end;                   /* maximum output position */
   signed char *achl_out_cur;               /* current position output */
   signed char *achl_out_end;               /* maximum output position */

   achl_cur = (signed char *) achp_source;  /* current position        */
   achl_end = (signed char *) achp_source + inp_len_source;
   achl_out_cur = (signed char *) achp_target;
   achl_out_end = (signed char *) achp_target + inp_max_len_target -1;
   while (achl_cur < achl_end) {
     if (achl_out_cur >= achl_out_end) return -1;
     chl_w1 = ucrg_tab_850_to_819[ *((unsigned char *) achl_cur) ];
     if (((signed char) chl_w1) >= 0) {     /* not 0X80 set            */
       *achl_out_cur++ = chl_w1;
     } else {                               /* zero or X80             */
       *achl_out_cur++ = 0XC0 | ((unsigned char)chl_w1 >> 6);
       /* check at maximum output                                      */
       if (achl_out_cur >= achl_out_end) return -1;
       *achl_out_cur++ = 0X80 | (chl_w1 & 0X3F);
     }
     achl_cur++;                            /* increment input         */
   }
   return ((char *) achl_out_cur - achp_target);  /* return count characters */
} /* end m_u8l_from_a850l()                                            */

/**
* method to return the UTF-8 values of a single-byte-per-char-String
*  @param achp_target output buffer (will get no terminator if not copied from
*                     source, but one byte of the space is kept reserved)
*  @param inp_max_len_target length of output buffer, in bytes
*  @param achp_source input string
*  @param inp_len_source length of input string
*  @param ausp_tabletouni conversion table to codepoints (for the input)
*  @return -1 if output overflow, else count characters (bytes) of target field
*/
static int m_u8l_from_sbsl( char *achp_target,       int inp_max_len_target,
                            const char *achp_source, int inp_len_source,
                            const unsigned short* ausp_tabletouni ) {
   unsigned short usl_w1;                   /* working-variable        */
   signed char *achl_cur;                   /* current position        */
   signed char *achl_end;                   /* maximum output position */
   signed char *achl_out_cur;               /* current position output */
   signed char *achl_out_end;               /* maximum output position */

   achl_cur = (signed char *) achp_source;  /* current position        */
   achl_end = (signed char *) achp_source + inp_len_source;
   achl_out_cur = (signed char *) achp_target;
   achl_out_end = (signed char *) achp_target + inp_max_len_target -1;
   while (achl_cur < achl_end) {
     if (achl_out_cur >= achl_out_end) return -1;
     usl_w1 = ausp_tabletouni[ *((unsigned char *) achl_cur) ];
     if (usl_w1 & 0xFF80) {
       if (usl_w1 & 0xF800) {               /* U+0800 or above         */
         *achl_out_cur++ = 0XE0 | (usl_w1 >> 12);
         /* check at maximum output                                    */
         if (achl_out_cur >= achl_out_end) return -1;
           *achl_out_cur++ = 0X80 | ((usl_w1 >> 6) & 0XBF);
         /* check at maximum output                                    */
         if (achl_out_cur >= achl_out_end) return -1;
         *achl_out_cur++ = 0X80 | (usl_w1 & 0X3F);
       } else {                             /* encode in 2 bytes UTF-8 */
         *achl_out_cur++ = 0XC0 | (usl_w1 >> 6);
         /* check at maximum output                                    */
         if (achl_out_cur >= achl_out_end) return -1;
         *achl_out_cur++ = 0X80 | (usl_w1 & 0X3F);
       }
     } else {                               /* below U+0080            */
       *achl_out_cur++ = (char)usl_w1;
     }
     achl_cur++;                            /* increment input         */
   }
   return ((char *) achl_out_cur - achp_target);  /* return count characters */
} /* end m_u8l_from_sbsl()                                             */

/**
* method to return the UTF-8 values of a single-or-double-byte-per-char-String.
*  @param achp_target output buffer (will get no terminator if not copied from
*                     source, but one byte of the space is kept reserved)
*  @param inp_max_len_target length of output buffer, in bytes
*  @param achp_source input string
*  @param inp_len_source length of input string, in bytes
*  @param ausp_fbtouni first-byte-table as described at m_get_tab_mb_firstbytes
*  @param ausp_dbtouni conversion table as described at m_get_tab_mb_to_uni
*  @return -1 if output overflow, else count characters (bytes) of target field
*/
static int m_u8l_from_mbsl( char *achp_target,       int inp_max_len_target,
                            const char *achp_source, int inp_len_source,
                            const unsigned short* ausp_fbtouni,
                            const unsigned short* ausp_dbtouni ) {
   unsigned short usl_w1;                   /* working-variable        */
   signed char *achl_cur;                   /* current position        */
   signed char *achl_end;                   /* maximum output position */
   signed char *achl_out_cur;               /* current position output */
   signed char *achl_out_end;               /* maximum output position */

   achl_cur = (signed char *) achp_source;  /* current position        */
   achl_end = (signed char *) achp_source + inp_len_source;
   achl_out_cur = (signed char *) achp_target;
   achl_out_end = (signed char *) achp_target + inp_max_len_target -1;
   while (achl_cur < achl_end) {
     if (achl_out_cur >= achl_out_end) return -1;
     usl_w1 = ausp_fbtouni[ *((unsigned char *) achl_cur) ];
     if (usl_w1 == 0xFFFF) {                /* two-byte sequence       */
       usl_w1 = *((unsigned char *) achl_cur) << 8;
       achl_cur++;                          /* increment input, 2.byte */
       if (achl_out_cur >= achl_out_end) return -1;
       usl_w1 = ausp_dbtouni[ usl_w1 | *((unsigned char *) achl_cur) ];
     }
     if (usl_w1 & 0xFF80) {
       if (usl_w1 & 0xF800) {               /* U+0800 or above         */
         *achl_out_cur++ = 0XE0 | (usl_w1 >> 12);
         /* check at maximum output                                    */
         if (achl_out_cur >= achl_out_end) return -1;
           *achl_out_cur++ = 0X80 | ((usl_w1 >> 6) & 0XBF);
         /* check at maximum output                                    */
         if (achl_out_cur >= achl_out_end) return -1;
         *achl_out_cur++ = 0X80 | (usl_w1 & 0X3F);
       } else {                             /* encode in 2 bytes UTF-8 */
         *achl_out_cur++ = 0XC0 | (usl_w1 >> 6);
         /* check at maximum output                                    */
         if (achl_out_cur >= achl_out_end) return -1;
         *achl_out_cur++ = 0X80 | (usl_w1 & 0X3F);
       }
     } else {                               /* below U+0080            */
       *achl_out_cur++ = (char)usl_w1;
     }
     achl_cur++;                            /* increment input         */
   }
   return ((char *) achl_out_cur - achp_target);  /* return count characters */
} /* end m_u8l_from_mbsl()                                             */

#ifdef XSLUNIC_OBSOLETE_EXTERNS
/**
* method to return the UTF-8 values of a OEM-437-String
* @deprecated just calls m_u8l_from_sbsl(...,usrg_tab_437_to_uni)
*  @param achp_target output buffer
*  @param inp_max_len_target length of output buffer, in bytes
*  @param achp_source input string
*  @param inp_len_source length of input string
*  @return -1 if output overflow, else count characters (bytes) of target field
*/
extern PTYPE int m_u8l_from_a437l( char *achp_target,       int inp_max_len_target,
                                   const char *achp_source, int inp_len_source ) {
   return m_u8l_from_sbsl( achp_target, inp_max_len_target, achp_source, inp_len_source, usrg_tab_437_to_uni );
} /* end m_u8l_from_a437l()                                            */
#endif

/** @} */
/* Bitstring methods used to read binary compressed table data.        */
/* There are no checks for overflow, use only trusted data!            */

/**
* Initialise a bitstring state struct with a byte array for reading data later.
*  @param adsp_source pointer to the struct to prepare
*  @param abyp_dataspace the array with the raw crushed data
*/
static void m_init_read_bitstring( struct dsd_bitstring *adsp_source,
                                   const unsigned char *abyp_dataspace ) {
   adsp_source->abyc_a=abyp_dataspace;
   adsp_source->isc_phase=8;
   adsp_source->inc_pbb=0;
}

/**
* Read a bit from a bitstring, advancing the read position.
*  @param adsp_source the state struct about the bitstring with the data
*  @return the bit that has been read
*/
static BOOL m_get_bit_from_bitstring( struct dsd_bitstring *adsp_source ) {
   if(adsp_source->inc_pbb) {  /* already read as "partial" bit of bounded number */
     adsp_source->inc_pbb=0;
     return (BOOL)(adsp_source->inc_pbv);
   }
   if(--adsp_source->isc_phase < 0) {
     adsp_source->isc_phase = 7;
     adsp_source->abyc_a ++;
   }
   return (*(adsp_source->abyc_a) & 1<<adsp_source->isc_phase);
}

/**
* Read a number from a bitstring, advancing the read position.
*  @param adsp_source the state struct about the bitstring with the data
*  @param unp_bound a number that is larger than the largest possible result of
*                   reading, or 0 if no such limit <2**usp_bitwidth is known.
*                   This limit must be the same as used at writing the bitstring
*  @param usp_bitwidth maximum number of binary digits of the number to read.
*                      Has to be the same as used when writing the bitstring.
*  @return the number that has been read
*/
static unsigned int m_get_num_from_bitstring( struct dsd_bitstring *adsp_source,
                                              unsigned int unp_bound,
                                              unsigned short usp_bitwidth ) {
   /* Internal number format is big endian (because speed was assumed to matter
      more on decoding than on encoding). When a number is coded having an upper
      bounds (which is also pre-known at decoding) which is not a power-of-2,
      the remaining partial bit can be utilised by the algorithm. E.g. where a
      number from 0..699 is expected, for an x from 0..323 there may be coded x
      or x+700, and the information which of these possibilities was used,
      serves as bit for the next coded element (LSB if that is a number).
      The inc_pb? members in the struct are for this feature. */
   unsigned int unl_result;
   unsigned short usl_obw;
   if(unp_bound)  /* store original bitwidth for later tests */
     usl_obw=usp_bitwidth;
   if(adsp_source->inc_pbb) {  /* "partial" bit available, read only the rest */
     if (usp_bitwidth==0)
       return 0;  /* this special case could be checked before the greater if(),
                     but is harmless when inc_pbb is off */
     usp_bitwidth--;
     }
   if (usp_bitwidth <= adsp_source->isc_phase) {
     unl_result = (1<<usp_bitwidth)-1;
     adsp_source->isc_phase -= usp_bitwidth;
     unl_result &= *(adsp_source->abyc_a)>>adsp_source->isc_phase;
   } else {
     unl_result = *(adsp_source->abyc_a) & ((1<<adsp_source->isc_phase)-1);
     usp_bitwidth-=adsp_source->isc_phase;
     while (usp_bitwidth>8) {
       unl_result<<=8;
       unl_result|=*(++adsp_source->abyc_a);
       usp_bitwidth-=8;
     }
     unl_result<<=usp_bitwidth;
     adsp_source->isc_phase=8-usp_bitwidth;
     unl_result|=*(++adsp_source->abyc_a)>>adsp_source->isc_phase;
   }
   if(unp_bound) {
     if(adsp_source->inc_pbb) {
       unp_bound+=(unp_bound&1);
       unl_result=(unl_result<<1)|adsp_source->inc_pbv;
       if(unl_result >= unp_bound) {
         unl_result-=unp_bound;
         adsp_source->inc_pbv=1;
       } else if(unp_bound+unl_result < 1<<usl_obw) {
         adsp_source->inc_pbv=0;
       } else {
         adsp_source->inc_pbb=0;
       }
     } else {
       if(unl_result >= unp_bound) {
         unl_result-=unp_bound;
         adsp_source->inc_pbb=1;
         adsp_source->inc_pbv=1;
       } else if(unp_bound+unl_result < 1<<usl_obw) {
         adsp_source->inc_pbb=1;
         adsp_source->inc_pbv=0;
       }
     }
     return unl_result;
   }
   if(adsp_source->inc_pbb) {
     adsp_source->inc_pbb=0;
     return (unl_result<<1)|adsp_source->inc_pbv;
   }
   return unl_result;
}

/**
* decompress helper function filling the target with alternate runs of
* 0x0000 and UTF16_REP_CHAR. Uses recursion.
*  @param adsp_source bitstring with data about partitioning the target
*  @param awcp_target output buffer
*  @param inp_trglen how many cells of awcp_target to fill
*  @param inp_rwbw initial bitwidth for lengths, used at producing adsp_source
*/
static void m_decode_presence( struct dsd_bitstring* adsp_source,  HL_WCHAR* awcp_target,
                               int inp_trglen, int inp_rwbw ) {
   const int inl_center=inp_trglen>>1;
   int inl_r;
   int inl_bw; /* one less than maximum possible bitwidth of number to encode */
   int inl0;
   int inl_rstart;  /* start of the contiguous (codes present everywhere or
                       nowhere in it) region around the center of the
                       region given by adsp_target and inp_trglen      */
   HL_WCHAR wcl_fillchar;
   inl_r = 1+m_get_num_from_bitstring( adsp_source, inp_trglen, inp_rwbw );
   if (inl_r>inl_center) {
     inl0=inp_trglen-inl_r;
     if (inl0>0) {
       inl_bw=inp_rwbw; do inl_bw--; while(((~0<<inl_bw)&inl0)==0);
       inl_rstart=m_get_num_from_bitstring( adsp_source, inl0+1, inl_bw+1 );
     } else {
       inl_rstart=0;
     }
   } else {
     inl_bw=inp_rwbw; do inl_bw--; while(((~0<<inl_bw)&inl_r)==0);
     inl_rstart = inl_center-m_get_num_from_bitstring( adsp_source, inl_r+1, inl_bw+1 );
   }
   if (inl_rstart>0) {
     inl_bw=inp_rwbw; do inl_bw--; while(((~0<<inl_bw)&inl_rstart)==0);
     m_decode_presence( adsp_source, awcp_target, inl_rstart,
                        (inl_rstart==1<<inl_bw)?inl_bw:inl_bw+1 );
   }
   wcl_fillchar = UTF16_REP_CHAR-awcp_target[inl_rstart-1];
   inl_r+=inl_rstart;
   for (inl0=inl_rstart; inl0<inl_r; inl0++)
     awcp_target[inl0]=wcl_fillchar;
   if (inl_r<inp_trglen) {
     inl0=inp_trglen-inl_r;
     inl_bw=inp_rwbw; do inl_bw--; while(((~0<<inl_bw)&inl0)==0);
     m_decode_presence( adsp_source, awcp_target+inl_r, inl0,
                        (inl0==1<<inl_bw)?inl_bw:inl_bw+1 );
   }
}

/**
* decompress helper function reading a category-incidence-count curve
*  @param adsp_source bitstring with data representing a discrete function graph
*  @param inp_step target step (>1 to write a run of interlaced filling)
*  @param inp_maxcount maximum possible number of domain values in the data
*  @param aunp_target output buffer
*  @return count of entrys filled (at most inp_maxcount; taken from the data)
*/
static int m_decode_skyline( struct dsd_bitstring* adsp_source, int inp_step,
                             int inp_maxcount, unsigned int* aunp_target ) {
   int inl_non0len, inl0, inl1;
   unsigned int unp_val=1;
   /* determine bitwidth                                               */
   for (inl0=1,inl1=0; inl0<=inp_maxcount; inl1++,inl0<<=1)
     ;
   /* get information where the border is                              */
   inl_non0len=m_get_num_from_bitstring(adsp_source,inp_maxcount+1,inl1);
   /* decode, following the graph step by step (inc. value/ dec. value/ inc. index) */
   if (inl_non0len>0) {
     inl0=(inl_non0len-1)*inp_step;
     /* outermost index, value has to be 1 or bigger                   */
     while (!m_get_bit_from_bitstring(adsp_source))
       unp_val++;
     aunp_target[inl0]=unp_val;
     /* now iterate through the other indices downto 0                 */
     while ((inl0-=inp_step) >= 0) {
       switch (m_get_num_from_bitstring(adsp_source,3,2)) {
         case 0:
           unp_val++;
           while (!m_get_bit_from_bitstring(adsp_source))
             unp_val++;
           break;
         case 1:
           unp_val--;
           while (!m_get_bit_from_bitstring(adsp_source))
             unp_val--;
           break;
         case 2:
           break;
       }
       aunp_target[inl0]=unp_val;
     }
   }
   return inl_non0len;
}

/**
* helper function putting ignorability information in huffmanntree-branches,
* that may be later used to avoid unnecessary traversals looking for a value
* outside an interval that contains all values under a node. Uses recursion.
*  @param adsp_s node of which one subtree has to be processed
*  @param inp_lri index (0 or 1) whether to process left or right subtree
*/
static void m_note_branchlimit (struct dsd_huffnode* adsp_s, int inp_lri) {
   int inl0;
   unsigned int unl_v;
   switch (adsp_s->ierc_status[inp_lri]) {
     case ied_is_leaf:
       unl_v = adsp_s->urc[inp_lri].unc_v;
       if (unl_v>62) {          /* zerorun-length, needs space forward */
         if (unl_v>66) {
           adsp_s->usrc_au[inp_lri]=((2+(unl_v&1))<<((unl_v-64)>>1))-1;
         } else {
           adsp_s->usrc_au[inp_lri]=unl_v-63;
         }
         adsp_s->usrc_ad[inp_lri]=~0;
       } else if (unl_v&1) {  /* negative jump length, needs space backward */
         inl0=1<<((unl_v+1)>>2);
         if ((unl_v&2)==0)
           inl0+=inl0>>1;
         adsp_s->usrc_au[inp_lri]=~0;
         adsp_s->usrc_ad[inp_lri]=inl0;
       } else {           /* positive jump length, needs space forward */
         inl0=1<<(unl_v>>2);
         if (unl_v&2)
           inl0+=inl0>>1;
         adsp_s->usrc_au[inp_lri]=inl0;
         adsp_s->usrc_ad[inp_lri]=~0;
       }
       break;
     case ied_has_subtree:
     case ied_has_incomplete_subtree:
       /* handle subnode recursively                                   */
       m_note_branchlimit(adsp_s->urc[inp_lri].adsc_s, 0);
       m_note_branchlimit(adsp_s->urc[inp_lri].adsc_s, 1);
       adsp_s->usrc_au[inp_lri] = (adsp_s->urc[inp_lri].adsc_s->usrc_au[0] < adsp_s->urc[inp_lri].adsc_s->usrc_au[1])
                      /* min */ ?  adsp_s->urc[inp_lri].adsc_s->usrc_au[0] : adsp_s->urc[inp_lri].adsc_s->usrc_au[1];
       adsp_s->usrc_ad[inp_lri] = (adsp_s->urc[inp_lri].adsc_s->usrc_ad[0] < adsp_s->urc[inp_lri].adsc_s->usrc_ad[1])
                      /* min */ ?  adsp_s->urc[inp_lri].adsc_s->usrc_ad[0] : adsp_s->urc[inp_lri].adsc_s->usrc_ad[1];
       break;
     default:
       adsp_s->usrc_au[inp_lri]=~0;
       adsp_s->usrc_ad[inp_lri]=~0;
       break;
   }
}

/**
* helper function for m_choose_huffnode. Marks a node and, if necessary, also
* supernodes of it as having (complete) subtrees.
*  @param adsp_x the node just completely filled
*/
void m_mark_subtree_fullness (struct dsd_huffnode* adsp_x) {
   struct dsd_huffnode* adsp_u = adsp_x->adsc_up;
   int inl_lr;
   while (adsp_u!=NULL) {
     inl_lr = ((adsp_u->ierc_status[0]==ied_has_incomplete_subtree && adsp_u->urc[0].adsc_s==adsp_x) ? 0 : 1);
     adsp_u->ierc_status[inl_lr]=ied_has_subtree;
     switch (adsp_u->ierc_status[inl_lr^1]) {
       case ied_has_subtree:
       case ied_is_leaf:
         adsp_x = adsp_u;
         adsp_u = adsp_x->adsc_up;
         break;
       default:
         return;
     }
   }
}

/**
* helper function for m_huffstat_to_tree. Uses recursion.
*  @param unp_rareness levels to descend
*  @param unp_extra_rareness levels to descend into yet totally unused subtree
*  @param unp_val the value to choose a huffmancode for
*  @param adsp_t the (sub)tree root to start search for a suitable place
*  @param adsp_space pointer to array in which fresh empty elements can be found
*  @param[in,out] ainp_spaceind index where in adsp_space the empty entrys start
*  @return pointer to chosen entry, or NULL if nothing was chosen
*/
struct dsd_huffnode* m_choose_huffnode (unsigned int unp_rareness,
     unsigned int unp_extra_rareness, unsigned int unp_val,
     struct dsd_huffnode* adsp_t, struct dsd_huffnode* adsp_space, int* ainp_spaceind) {
   struct dsd_huffnode* adsl_o;
   if (unp_rareness>1) {  /* code not long enough in this place of the tree, descend further */
     switch (adsp_t->ierc_status[0]) {
       case ied_has_subtree:                /* already full            */
       case ied_is_leaf:                    /* already used as leaf    */
       case ied_unused:                     /* no subtree here yet     */
         break;
       case ied_has_incomplete_subtree:
         adsl_o = m_choose_huffnode(unp_rareness-1, unp_extra_rareness, unp_val, adsp_t->urc[0].adsc_s, adsp_space, ainp_spaceind);
         if (adsl_o)
           return adsl_o;
         break;
     }
     switch (adsp_t->ierc_status[1]) {
       case ied_has_subtree:                /* already full            */
       case ied_is_leaf:                    /* already used as leaf    */
       case ied_unused:                     /* no subtree here yet     */
         return NULL;
       case ied_has_incomplete_subtree:
         return m_choose_huffnode(unp_rareness-1, unp_extra_rareness, unp_val, adsp_t->urc[1].adsc_s, adsp_space, ainp_spaceind);
     }
   }
   if ((adsp_t->ierc_status[0]==ied_unused) && (adsp_t->ierc_status[1]!=ied_unused)) {
     if (unp_extra_rareness) {
       do {
         adsp_t->ierc_status[0] = ied_has_incomplete_subtree;
         adsl_o = adsp_space+(++(*ainp_spaceind));
         adsl_o->ierc_status[1] = ied_unused;
         adsl_o->adsc_up = adsp_t;
         adsp_t->urc[0].adsc_s = adsl_o;
         adsp_t = adsl_o;
       } while (--unp_extra_rareness>0);
     } else {
       if (adsp_t->ierc_status[1]!=ied_has_incomplete_subtree)
         m_mark_subtree_fullness(adsp_t);
     }
     adsp_t->ierc_status[0]=ied_is_leaf;
     adsp_t->urc[0].unc_v=unp_val;
     return adsp_t;
   }
   if ((adsp_t->ierc_status[1]==ied_unused) && (adsp_t->ierc_status[0]!=ied_unused)) {
     if (unp_extra_rareness) {
       do {
         adsp_t->ierc_status[1] = ied_has_incomplete_subtree;
         adsl_o = adsp_space+(++(*ainp_spaceind));
         adsl_o->ierc_status[0] = ied_unused;
         adsl_o->adsc_up = adsp_t;
         adsp_t->urc[1].adsc_s = adsl_o;
         adsp_t = adsl_o;
       } while (--unp_extra_rareness>0);
     } else {
       if (adsp_t->ierc_status[0]!=ied_has_incomplete_subtree)
         m_mark_subtree_fullness(adsp_t);
     }
     adsp_t->ierc_status[1]=ied_is_leaf;
     adsp_t->urc[1].unc_v=unp_val;
     return adsp_t;
   }
   return NULL;
}

/**
* decompress helper function making a huffmann-tree from incidence counts.
*  @param aunp_huffstat list of occurrence frequency base-2-logarithm values
*  @param inp_maxlistlen length of aunp_huffstat (in elements)
*  @param adsp_target output buffer
*  @return used length of adsp_target (in elements)
*/
int m_huffstat_to_tree( const unsigned int* aunp_huffstat, int inp_maxlistlen,
                        struct dsd_huffnode* adsp_target ) {
   unsigned int unl_sum;
   int inl_sc;                              /* codelength category     */
   int inl_ln;  /* index of current element in target list adsp_target (largest used index) */
   int inl_h;   /* required tree heigth/ code bitlength for current element                 */
   int inl_m;   /* measure for the relation of the unit in aunp_huffstat and the total      */
   int inl0;
   struct dsd_huffnode* adsl_found;
   adsp_target[0].adsc_up=NULL;  /* rootnode */
   while (aunp_huffstat[inp_maxlistlen-1]==0)
     inp_maxlistlen--;
   unl_sum=0;
   inl0=-1;
   for (inl_sc=0; inl_sc<inp_maxlistlen; inl_sc++) {
     if (aunp_huffstat[inl_sc]) {
       unl_sum += 1 << (aunp_huffstat[inl_sc]-1);
       inl0++;
     }
   }
   if (inl0<=0) {      /* empty or non-treelike (1-sign alphabet) tree */
     if (inl0==0) {
       for (inl_sc=0; inl_sc<inp_maxlistlen; inl_sc++) {
         if (aunp_huffstat[inl_sc]) {  /* store what that one value is */
           adsp_target[0].urc[0].unc_v = inl_sc;
           break;
         }
       }
       adsp_target[0].ierc_status[0] = ied_is_leaf;
       m_note_branchlimit(adsp_target,0);
     } else {
       adsp_target[0].ierc_status[0] = ied_unused;
     }
     adsp_target[0].ierc_status[1] = ied_unused;
     return inl0;
   }
   for (inl_m=0; !(unl_sum&1); inl_m++)
     unl_sum>>=1;
   if (unl_sum!=1) {
     printf("Warning: the weights used for huffmann code length have not a power-of-two as sum, but 0x%X\n",unl_sum<<inl_m);
     do {
       inl_m++;
       unl_sum>>=1;
     } while (unl_sum!=1);
   }
   inl_m++;
   inl_ln=0;
   for (inl_sc=0; !aunp_huffstat[inl_sc]; inl_sc++)
     ;
   inl_h=inl_m-aunp_huffstat[inl_sc];
   adsp_target->adsc_up = NULL;          /* adsp_target[0] is rootnode */
   while (--inl_h) {
     adsp_target[inl_ln].ierc_status[1] = ied_unused;
     adsp_target[inl_ln].ierc_status[0] = ied_has_incomplete_subtree;
     adsp_target[inl_ln].urc[0].adsc_s = adsp_target+inl_ln+1;
     adsp_target[inl_ln+1].adsc_up = adsp_target+inl_ln;
     inl_ln++;
   }
   adsp_target[inl_ln].ierc_status[1] = ied_unused;
   adsp_target[inl_ln].ierc_status[0] = ied_is_leaf;
   adsp_target[inl_ln].urc[0].unc_v = inl_sc;
   while (++inl_sc < inp_maxlistlen) {
     if (aunp_huffstat[inl_sc]) {
       inl_h=inl_m-aunp_huffstat[inl_sc];
       inl0=0;
       while ((adsl_found=m_choose_huffnode(inl_h-inl0, inl0, inl_sc, adsp_target, adsp_target, &inl_ln))==FALSE)
         inl0++;
     }
   }
   m_note_branchlimit(adsp_target,0);
   m_note_branchlimit(adsp_target,1);
   return inl_ln+2;
}
/** @addtogroup unicode
* @{
*/

#define CJKDECODE_NEXTCHAR(INP0) if(wcrl_holes[INP0]) {  \
         if (inl_rep>0) { /* still unrolling a 0-run */  \
           inl_s=inl_prev;  \
           inl_rep--;  \
         } else {  \
           if (adsl_curnode->ierc_status[1]!=ied_unused) {  \
             while (TRUE) {  \
               inl_hb = ((adsl_curnode->usrc_ad[0]<=inl_prev) || (adsl_curnode->usrc_au[0]+inl_prev<=inl_nyrest))  \
                      ? (((adsl_curnode->usrc_ad[1]<=inl_prev) || (adsl_curnode->usrc_au[1]+inl_prev<=inl_nyrest))  \
                          ? (m_get_bit_from_bitstring(&dsl_cjkcompr)?1:0)  \
                          : 0  \
                        )  \
                      : 1;  \
               if (adsl_curnode->ierc_status[inl_hb]==ied_is_leaf) break;  \
               adsl_curnode=adsl_curnode->urc[inl_hb].adsc_s;  \
             }  \
             unl_sc=adsl_curnode->urc[inl_hb].unc_v;  \
             adsl_curnode=dsrl_huffnodes;  /* for next time */  \
           }  \
           if (unl_sc<7) {  \
             inl_s=inl_prev+(unl_sc&1 ? (-1)-(unl_sc>>1) : unl_sc>>1);  \
           } else if (unl_sc<63) {  \
             inl1=(unl_sc-3)>>2;  \
             if (unl_sc==(unsigned)inl_nyrc) {  \
               int inl_bound=(unl_sc&1)+inl_nyrest-inl_nnyrstep, inl_bw=inl1-1;  \
               while (inl_bound<=(1<<inl_bw)) inl_bw--;  \
               inl_s=m_get_num_from_bitstring( &dsl_cjkcompr, inl_bound, inl_bw+1); \
             } else {  \
               inl_s=m_get_num_from_bitstring( &dsl_cjkcompr, 0, inl1 ); \
             }  \
             inl_s+=((2+(((unl_sc+1)>>1)&1))<<inl1);  \
             if (unl_sc&1)  \
               inl_s=inl_prev-inl_s;  \
              else  \
               inl_s+=inl_prev;  \
           } else { /*repeat-run of 0s has been encoded*/  \
             inl_s=inl_prev;  \
             if (unl_sc<66) {  \
               inl_rep = unl_sc-63;  \
             } else {  \
               int inl_rl = (2+(unl_sc&1)) << (inl_rep = (unl_sc-64)>>1);  \
               int inl_rb = 1+(inl_nyrest-inl_s)-inl_rl;  \
               if (inl_rb < 1<<inl_rep) {  \
                 do inl_rep--; while (inl_rb <= 1<<inl_rep);  \
                 inl_rep = m_get_num_from_bitstring( &dsl_cjkcompr, inl_rb, inl_rep+1) + inl_rl - 1; \
               } else {  \
                 inl_rep = m_get_num_from_bitstring( &dsl_cjkcompr, 0, inl_rep) + inl_rl - 1; \
               }  \
             }  \
           }  \
         }  \
         if (--inl_nyrest==inl_nnyrstep) { /* remaining count takes next step downward */  \
           if ((inl_nyrc-=2)<4) {  \
             inl_nnyrstep--;  \
           } else if(inl_nyrc&2) { /*100...->11...*/  \
             inl_nnyrstep-=inl_nnyrstep>>2;  \
           } else { /*11...->10...*/  \
             inl_nnyrstep&=inl_nnyrstep<<1;  \
           }  \
         }  \
         inl_prev=inl_s;  \
         inl1=inl_nyn; \
         inl2=inl_nyn>>1; \
         do { \
           if (inl_s>=wcrl_nye[inl1-inl2]) { \
             inl_s-=wcrl_nye[inl1-inl2]; \
             inl1+=inl2; \
           } else { \
             inl1-=inl2; \
           } \
           inl2>>=1; \
           wcrl_nye[inl1]--; \
         } while(inl2>1); \
         if(inl_s||!wcrl_nye[inl1-1]) { \
           awcl_res[INP0]=wcrl_nye[inl1+1];  \
         } else { \
           awcl_res[INP0]=wcrl_nye[--inl1];  \
           wcrl_nye[inl1]=0; \
         } \
       }

#define CJKDECODE_BLOCKSTART {  \
         memset(unrl_huffstat,0,sizeof(unrl_huffstat));  \
         if (m_get_bit_from_bitstring(&dsl_huffcompr)) {  \
           m_decode_skyline( &dsl_huffcompr, 1, 63, unrl_huffstat );  \
         } else {  \
           m_decode_skyline( &dsl_huffcompr, 2, 32, unrl_huffstat );  \
           m_decode_skyline( &dsl_huffcompr, 2, 31, unrl_huffstat+1 );  \
         }  \
         unl_sc=62+m_decode_skyline( &dsl_huffcompr, 1, 27, unrl_huffstat+63 );  \
         inl0=0;  \
         if (!m_huffstat_to_tree(unrl_huffstat,63+27,dsrl_huffnodes))  \
           unl_sc=dsrl_huffnodes->urc[0].unc_v;  \
         adsl_curnode=dsrl_huffnodes;  \
       }

#define CJKDECODE_MSE(INP_START,INP_END,INP_A0,INP_A1,INP_B1,INP_B0,JUMPS)  \
   CJKDECODE_BLOCKSTART  \
   for (inl0=INP_START; inl0<=INP_END;) {  \
     CJKDECODE_NEXTCHAR(inl0)  \
     switch (inl0&0xFF) {  \
       case INP_B1: inl0+=0x100+INP_B0-INP_B1; break;  \
       JUMPS  \
       default: inl0++;  \
     }  \
   }

#define CJKDECODE_ME(INP_END,INP_A0,INP_A1,INP_B1,INP_B0,JUMPS)  \
   CJKDECODE_MSE(((INP_A0<<8)|INP_B0),INP_END,INP_A0,INP_A1,INP_B1,INP_B0,JUMPS)

#define CJKDECODE_M(INP_A0,INP_A1,INP_B1,INP_B0,JUMPS)  \
   CJKDECODE_ME(((INP_A1<<8)|INP_B1),INP_A0,INP_A1,INP_B1,INP_B0,JUMPS)

#define CJKDECODE_D(INP_A0,INP_A1,INP_B1,INP_B0,JUMPS)  \
   for (inl3=INP_A0<<8; inl3<=INP_A1<<8; inl3+=0x100) {  \
     CJKDECODE_BLOCKSTART  \
     for (inl0=INP_B0; inl0<=INP_B1;) {  \
       CJKDECODE_NEXTCHAR(inl0+inl3)  \
       switch (inl0) {  \
         JUMPS  \
         default: inl0++;  \
       }  \
     }  \
   }

#define CJKDCJ(INP_FROM,INP_TO)  \
         case INP_FROM: inl0+=INP_TO-INP_FROM; break;

/**
* Gets a table with meanings of the first byte for one of the MBCS encodings
* (Windows-CP 932, 936, 949 or 950), which can be a certain character or the
* fact that it is lead-byte for double-byte codes to be looked up elsewhere
* (expressed by the value 0xFFFF), or undefined (expressed by UTF16_REP_CHAR).
* When first called for one of these encodings, it will fill the corresponding
* awcg_tab_*_leadbyte with an array it can just return on later calls.
*  @param iep_cs the MBCS encoding
*  @return pointer to the table
*/
static HL_WCHAR* m_get_tab_mb_firstbytes( enum ied_charset iep_cs ) {
   int inl0;
   switch (iep_cs) {
     case ied_chs_wcp_932:    /* Windows-Codepage 932 (MBCS, Japanese) */
       if (!awcg_tab_932_leadbyte) {        /* allocate and fill table */
         awcg_tab_932_leadbyte = (HL_WCHAR*)malloc(0x100*sizeof(HL_WCHAR));
         for(inl0=0x00;inl0<0x80;inl0++)
           awcg_tab_932_leadbyte[inl0]=inl0;  /* single bytes identity */
         awcg_tab_932_leadbyte[inl0++]=UTF16_REP_CHAR; /* 80 undefined */
         do awcg_tab_932_leadbyte[inl0++]=0xFFFF;  /* DBCS lead bytes  */
           while (inl0<0xA0);
         awcg_tab_932_leadbyte[inl0++]=UTF16_REP_CHAR; /* A0 undefined */
         do awcg_tab_932_leadbyte[inl0]=inl0+0xFEC0;  /* single bytes  */
           while (++inl0<0xE0);
         do awcg_tab_932_leadbyte[inl0++]=0xFFFF;  /* DBCS lead bytes  */
           while (inl0<0xFD);
         awcg_tab_932_leadbyte[inl0++]=UTF16_REP_CHAR; /* FD undefined */
         awcg_tab_932_leadbyte[inl0++]=UTF16_REP_CHAR; /* FE undefined */
         awcg_tab_932_leadbyte[inl0]=UTF16_REP_CHAR;  /* FF undefined  */
       }
       return awcg_tab_932_leadbyte;
     case ied_chs_wcp_936:  /* Windows-Codepage 936 (MBCS, Mainland Chinese) */
       if (!awcg_tab_936_leadbyte) {
         awcg_tab_936_leadbyte = (HL_WCHAR*)malloc(0x100*sizeof(HL_WCHAR));
         for(inl0=0x00;inl0<0x80;inl0++)
           awcg_tab_936_leadbyte[inl0]=inl0;  /* single bytes identity */
         awcg_tab_936_leadbyte[inl0++]=0x20AC;  /* 80 is single byte   */
         do awcg_tab_936_leadbyte[inl0++]=0xFFFF;  /* DBCS lead bytes  */
           while (inl0<0xFF);
         awcg_tab_936_leadbyte[inl0]=UTF16_REP_CHAR;  /* FF undefined  */
       }
       return awcg_tab_936_leadbyte;
     case ied_chs_wcp_949:      /* Windows-Codepage 949 (MBCS, Korean) */
       if (!awcg_tab_949_leadbyte) {
         awcg_tab_949_leadbyte = (HL_WCHAR*)malloc(0x100*sizeof(HL_WCHAR));
         for(inl0=0x00;inl0<0x80;inl0++)
           awcg_tab_949_leadbyte[inl0]=inl0;  /* single bytes identity */
         awcg_tab_949_leadbyte[inl0++]=UTF16_REP_CHAR; /* 80 undefined */
         do awcg_tab_949_leadbyte[inl0++]=0xFFFF;  /* DBCS lead bytes  */
           while (inl0<0xFF);
         awcg_tab_949_leadbyte[inl0]=UTF16_REP_CHAR;  /* FF undefined  */
       }
       return awcg_tab_949_leadbyte;
     case ied_chs_wcp_950:  /* Windows-Codepage 950 (MBCS, Taiwan Chinese) */
       if (!awcg_tab_950_leadbyte) {
         awcg_tab_950_leadbyte = (HL_WCHAR*)malloc(0x100*sizeof(HL_WCHAR));
         for(inl0=0x00;inl0<0x80;inl0++)
           awcg_tab_950_leadbyte[inl0]=inl0;  /* single bytes identity */
         awcg_tab_950_leadbyte[inl0++]=UTF16_REP_CHAR; /* 80 undefined */
         do awcg_tab_950_leadbyte[inl0++]=0xFFFF;  /* DBCS lead bytes  */
           while (inl0<0xFF);
         awcg_tab_950_leadbyte[inl0]=UTF16_REP_CHAR;  /* FF undefined  */
       }
       return awcg_tab_950_leadbyte;
     default:
       return NULL;
   }
} /* m_get_tab_mb_firstbytes()                                         */

/**
* Gets a conversion table to unicode for one of the MBCS encodings (Windows-CP
* 932, 936, 949 or 950) using some constant tables.
* Two-byte-codes have to be used as an index interpreting them as Big-Endian
* 16-bit number, one-byte codes have to be used as an index directly (this does
* not conflict, because 0x00 is no DBCS-lead-byte in any of these encodings).
* When first called for one of these encodings, it will fill the corresponding
* awcg_tab_*_to_uni with an array it can just return on later calls, and will
* also make sure the corresponding awcg_tab_*_leadbyte is filled.
*  @param iep_cs the MBCS encoding
*  @return pointer to the table
*/
static HL_WCHAR* m_get_tab_mb_to_uni( enum ied_charset iep_cs ) {
   HL_WCHAR *awcl_res;                /* resulting array to fill */
   int inl0, inl1, inl2, inl3;
   int inl_s, inl_nyn;
   struct dsd_bitstring dsl_huffcompr, dsl_holescompr, dsl_cjkcompr;
   HL_WCHAR wcrl_nye[0x10000];        /* odd places: codepoints yet to encode
         (so max. 32768 fit in here), even places: count information (tree-like) */
   unsigned short wcrl_holes[0x10000];
   int inl_prev, inl_nyrest, inl_nnyrstep, inl_nyrc;
   unsigned int unl_sc, unrl_huffstat[63+27];
   struct dsd_huffnode dsrl_huffnodes[63+27];
   struct dsd_huffnode *adsl_curnode;
   int inl_rep;                             /* repeatcount for 0s      */
   int inl_hb;  /* in the decoding phase: 0 or 1, going through the huffmanntree */
   switch (iep_cs) {
     case ied_chs_wcp_932:                  /* Windows-Codepage 932 (MBCS, Japanese) */
       if (awcg_tab_932_to_uni)
         return awcg_tab_932_to_uni;
       awcl_res = (HL_WCHAR*)malloc(0x10000*sizeof(HL_WCHAR));
       awcg_tab_932_to_uni = awcl_res;
       m_init_read_bitstring( &dsl_huffcompr, ucrg_huff_cp932 );
       m_init_read_bitstring( &dsl_holescompr, ucrg_holes_cp932 );
       m_init_read_bitstring( &dsl_cjkcompr, ucrg_code_cp932 );
       break;
     case ied_chs_wcp_936:                  /* Windows-Codepage 936 (MBCS, Mainland Chinese) */
       if (awcg_tab_936_to_uni)
         return awcg_tab_936_to_uni;
       awcl_res = (HL_WCHAR*)malloc(0x10000*sizeof(HL_WCHAR));
       awcg_tab_936_to_uni = awcl_res;
       m_init_read_bitstring( &dsl_huffcompr, ucrg_huff_cp936 );
       m_init_read_bitstring( &dsl_holescompr, ucrg_holes_cp936 );
       m_init_read_bitstring( &dsl_cjkcompr, ucrg_code_cp936 );
       break;
     case ied_chs_wcp_949:                  /* Windows-Codepage 949 (MBCS, Korean) */
       if (awcg_tab_949_to_uni)
         return awcg_tab_949_to_uni;
       awcl_res = (HL_WCHAR*)malloc(0x10000*sizeof(HL_WCHAR));
       awcg_tab_949_to_uni = awcl_res;
       m_init_read_bitstring( &dsl_huffcompr, ucrg_huff_cp949 );
       m_init_read_bitstring( &dsl_holescompr, ucrg_holes_cp949 );
       m_init_read_bitstring( &dsl_cjkcompr, ucrg_code_cp949 );
       break;
     case ied_chs_wcp_950:                  /* Windows-Codepage 950 (MBCS, Taiwan Chinese) */
       if (awcg_tab_950_to_uni)
         return awcg_tab_950_to_uni;
       awcl_res = (HL_WCHAR*)malloc(0x10000*sizeof(HL_WCHAR));
       awcg_tab_950_to_uni = awcl_res;
       m_init_read_bitstring( &dsl_huffcompr, ucrg_huff_cp950 );
       m_init_read_bitstring( &dsl_holescompr, ucrg_holes_cp950 );
       m_init_read_bitstring( &dsl_cjkcompr, ucrg_code_cp950 );
       break;
     default:
       return NULL;
   }
   wcrl_holes[0x7FFF]=0;
   m_decode_presence( &dsl_holescompr, wcrl_holes+0x8000, 0x8000, 15 );
   awcl_res[0x7F]=0;  /* so the decoding will start a region of non-presence (non-zeroed) */
   m_decode_presence( &dsl_cjkcompr, awcl_res+0x80, 0xFF80, 16 );
   switch (iep_cs) {  /* heed the cases where a codepoint has more than one representations */
     case ied_chs_wcp_932:
     case ied_chs_wcp_950:
       inl1=0;
       for (inl0=0x80; inl0<0x10000; inl0++)
         if (!awcl_res[inl0])
           inl1++;
       for (inl0=0; (1<<inl0)<=inl1; inl0++)
         ;
       *wcrl_nye=0;   /* so the decoding will start a region of non-presence (non-zeroed) */
       m_decode_presence( &dsl_cjkcompr, wcrl_nye+1, inl1, inl0 );
       inl1=1;
       for (inl0=0x80;inl0<0x10000;inl0++) {
         if (awcl_res[inl0]!=UTF16_REP_CHAR) {
           if (wcrl_nye[inl1]!=UTF16_REP_CHAR)
             awcl_res[inl0]=1;
           inl1++;
         }
       }
       if (iep_cs==ied_chs_wcp_932) {  /* where two unicode-characters are even encoded in three places each */
         awcl_res[0x2235]=2;  /* #BECAUSE, represented by 0x81E6, 0x879A and 0xFA5B */
         awcl_res[0xFFE2]=2;  /* #FULLWIDTH NOT SIGN, represented by 0x81CA, 0xEEF9 and 0xFA54 */
       }
       inl_nyn=1;
       for (inl0=0x80;inl0<0x10000;inl0++) {
         if (awcl_res[inl0]!=UTF16_REP_CHAR) {
           while (TRUE) {
             wcrl_nye[inl_nyn]=inl0;
             inl_nyn+=2;
             if(!awcl_res[inl0])
               break;
             awcl_res[inl0]--;
           }
         }
       }
       break;
     case ied_chs_wcp_936:
     case ied_chs_wcp_949:
       inl_nyn=1;
       for (inl0=0x80;inl0<0x10000;inl0++) {
         if (!awcl_res[inl0]) {
           wcrl_nye[inl_nyn]=inl0;
           inl_nyn+=2;
         }
       }
       break;
     default:                               /* cannot happen           */
       inl_nyn=0;                           /* avoid compiler warning  */
   }
   for (inl2=2;inl2<inl_nyn;inl2<<=1) {
     for (inl0=inl2;inl0<inl_nyn;inl0+=inl2<<1)
       wcrl_nye[inl0]=inl2;
     while (inl0<0x10000) {
       wcrl_nye[inl0]=0;
       inl0+=inl2<<1;
     }
     wcrl_nye[(inl_nyn&(-inl2<<1))|inl2]=(inl_nyn>>1)&(inl2-1);
   }
   inl_nyrest=inl_nyn>>1;
   /*printf("DEC: inl_nyn 0x%X\n",inl_nyn);*/
   if (inl_nyrest>4) {
     inl_nnyrstep=0x8;
     for (inl_nyrc=8; inl_nnyrstep<inl_nyrest; inl_nyrc+=4)
       inl_nnyrstep<<=1;
     inl_nnyrstep>>=1;
     if (inl_nnyrstep+(inl_nnyrstep>>1)<inl_nyrest) {
       inl_nnyrstep+=(inl_nnyrstep>>1);
       inl_nyrc+=2;
     }
   } else {
     inl_nnyrstep=inl_nyrest-1;
     inl_nyrc=inl_nnyrstep<<1;
   }
   inl2=1;
   while(inl2<inl_nyn)
     inl2<<=1;
   inl_nyn=inl2>>1;


   /* preparing for first CJKDECODE_NEXTCHAR */
   memset(awcl_res,0,0x10000*sizeof(HL_WCHAR));
   inl_prev=0;
   inl_rep=0;

   m_get_tab_mb_firstbytes(iep_cs);       /* let them be filled, too */
   switch (iep_cs) {
     case ied_chs_wcp_932:
       CJKDECODE_D(0x81, 0x81, 0xFC,0x40, CJKDCJ(0x7E,0x80))
       CJKDECODE_D(0x82, 0x84, 0x9E,0x40, CJKDCJ(0x7E,0x80))
       CJKDECODE_D(0x82, 0x84, 0xFC,0x9F,)
       CJKDECODE_D(0x87, 0x87, 0x9E,0x40, CJKDCJ(0x7E,0x80))
       CJKDECODE_MSE(0x889F,0x9872,
         0x88, 0x98, 0xFC,0x40, CJKDCJ(0x7E,0x80))
       CJKDECODE_MSE(0x989F,0x9FFC,  /* CJKDECODE_MS(...) */
         0x88, 0x9F, 0xFC,0x40, CJKDCJ(0x7E,0x80))
       CJKDECODE_ME(0xEAA4,
         0xE0, 0xEA, 0xFC,0x40, CJKDCJ(0x7E,0x80))
       CJKDECODE_M(0xED, 0xEE, 0xFC,0x40, CJKDCJ(0x7E,0x80))
       CJKDECODE_ME(0xFC4B,
         0xFA, 0xFC, 0xFC,0x40, CJKDCJ(0x7E,0x80));
       break;
     case ied_chs_wcp_936:
       CJKDECODE_D(0xA1, 0xA9, 0xFE,0xA1,)
       CJKDECODE_D(0xA8, 0xA9, 0xA0,0x40, CJKDCJ(0x7E,0x80))
       CJKDECODE_ME(0xD7F9,
         0xB0, 0xD7, 0xFE,0xA1,)
       CJKDECODE_M(0xD8, 0xF7, 0xFE,0xA1,)
       CJKDECODE_M(0x81, 0xA0, 0xFE,0x40, CJKDCJ(0x7E,0x80))
       CJKDECODE_ME(0xFE4F,
         0xAA, 0xFE, 0xA0,0x40, CJKDCJ(0x7E,0x80));
       break;
     case ied_chs_wcp_949:
       CJKDECODE_D(0xA1, 0xAC, 0xFE,0xA1,)
       CJKDECODE_M(0xCA, 0xFD, 0xFE,0xA1,)
       CJKDECODE_M(0xB0, 0xC8, 0xFE,0xA1,)
       CJKDECODE_M(0x81, 0xA0, 0xFE,0x41, CJKDCJ(0x5A,0x61) CJKDCJ(0x7A,0x81) CJKDCJ(0xA0,0xA1))
       CJKDECODE_ME(0xC653,
         0xA1, 0xC6, 0xA0,0x41, CJKDCJ(0x5A,0x61) CJKDCJ(0x7A,0x81));
       break;
     case ied_chs_wcp_950:
       awcl_res[0xA3E1]=0x20AC;
       CJKDECODE_ME(0xA3BF,
         0xA1, 0xA3, 0xFE,0x40, CJKDCJ(0x7E,0xA1))
       CJKDECODE_M(0xA4, 0xC6, 0xFE,0x40, CJKDCJ(0x7E,0xA1))
       CJKDECODE_M(0xC9, 0xF9, 0xFE,0x40, CJKDCJ(0x7E,0xA1));
       break;
     default:                               /* cannot happen           */
       inl_nyn=0;                           /* avoid compiler warning  */
   }
   return awcl_res;
} /* m_get_tab_mb_to_uni()                                             */
#undef CJKDCJ
#undef CJKDECODE_D
#undef CJKDECODE_M
#undef CJKDECODE_ME
#undef CJKDECODE_MSE
#undef CJKDECODE_BLOCKSTART
#undef CJKDECODE_NEXTCHAR

/**
* Gets a conversion table from the first 64k codepoints of unicode to one of the
* MBCS encodings (Windows-CP * 932, 936, 949 or 950) using some constant tables
* (the 16-bit range is enough, because none of them encodes any character above
* U+FFE6).
* A table value of below 256 denotes a one-byte code, a higher one denotes a
* two-byte code in Big Endian (this does not conflict, because 0x00 is no DBCS-
* lead-byte in any of these encodings).
* When first called for one of these encodings, it will fill the corresponding
* awcg_tab_uni_to_* with an array it can just return on later calls, and will
* also make sure the corresponding awcg_tab_*_leadbyte and awcg_tab_*_to_uni
* are filled.
*  @param iep_cs the MBCS encoding
*  @return pointer to the table
*/
static HL_WCHAR* m_get_tab_uni_to_mb( enum ied_charset iep_cs ) {
   HL_WCHAR *awcl_res;                      /* resulting array to fill */
   HL_WCHAR *awcl_od;                       /* other directions array  */
   int inl_c;
   switch (iep_cs) {
     case ied_chs_wcp_932:                  /* Windows-Codepage 932 (MBCS, Japanese) */
       if (awcg_tab_uni_to_932)
         return awcg_tab_uni_to_932;
       awcl_res = (HL_WCHAR*)malloc(0x10000*sizeof(HL_WCHAR));
       awcg_tab_uni_to_932 = awcl_res;
       break;
     case ied_chs_wcp_936:                  /* Windows-Codepage 936 (MBCS, Mainland Chinese) */
       if (awcg_tab_uni_to_936)
         return awcg_tab_uni_to_936;
       awcl_res = (HL_WCHAR*)malloc(0x10000*sizeof(HL_WCHAR));
       awcg_tab_uni_to_936 = awcl_res;
       break;
     case ied_chs_wcp_949:                  /* Windows-Codepage 949 (MBCS, Korean) */
       if (awcg_tab_uni_to_949)
         return awcg_tab_uni_to_949;
       awcl_res = (HL_WCHAR*)malloc(0x10000*sizeof(HL_WCHAR));
       awcg_tab_uni_to_949 = awcl_res;
       break;
     case ied_chs_wcp_950:                  /* Windows-Codepage 950 (MBCS, Taiwan Chinese) */
       if (awcg_tab_uni_to_950)
         return awcg_tab_uni_to_950;
       awcl_res = (HL_WCHAR*)malloc(0x10000*sizeof(HL_WCHAR));
       awcg_tab_uni_to_950 = awcl_res;
       break;
     default:
       return NULL;
   }
   for (inl_c=0; inl_c<0x10000; inl_c++)
     awcl_res[inl_c] = ASCII_REP_CHAR;
   awcl_od = m_get_tab_mb_firstbytes(iep_cs);  /* single byte codes    */
   for (inl_c=0; inl_c<0x100; inl_c++)
     if (awcl_od[inl_c]!=0xFFFF)
       awcl_res[awcl_od[inl_c]] = inl_c;
   awcl_od = m_get_tab_mb_to_uni(iep_cs);   /* double-byte-codes       */
   for (inl_c=0xFFFF; inl_c>=0; inl_c--)    /* backward so that [0]=0; */
     awcl_res[awcl_od[inl_c]] = inl_c;      /*  if ambiguous, smallest */
   awcl_res[UTF16_REP_CHAR] = ASCII_REP_CHAR;  /* instead of check in loop */
   return awcl_res;
} /* m_get_tab_uni_to_mb()                                             */

/**
* method to return the number of bytes in UTF-8 of a ANSI 819 String
*  @param achp_source input string expressed in ISO-8859-1
*  @param inp_len_source length of the input string, in bytes
*  @return length the string would need expressed in UTF8, in bytes
*/
extern PTYPE int m_count_utf8_from_a819l( const char *achp_source, int inp_len_source ) {
   int        inl_c;                        /* count characters        */
   const signed char *achl_cur;             /* current position        */
   const signed char *achl_end;             /* maximum input position  */

   achl_cur = (const signed char *) achp_source;  /* current position  */
   achl_end = (const signed char *) achp_source + inp_len_source;
   inl_c = 0;                               /* clear count characters  */
   while (achl_cur < achl_end) {
     inl_c++;                               /* increment count characters */
     if (*achl_cur <= 0) {                  /* zero or 0X80            */
       inl_c++;                             /* sequence of two bytes in UTF-8 */
     }
     achl_cur++;                            /* increment input         */
   }
   return inl_c;                            /* return count characters */
} /* end m_count_utf8_from_a819l()                                     */

/**
* Count the number of characters in an UTF8-string that contains only characters
* whose unicode number needs no more than 16 bits.
*  @param[out] aimp_result
*  @param achp_source the string that shall be measured
*  @param inp_len_source length of the string in bytes
*  @return whether successful
*/
extern PTYPE BOOL m_count_u16_from_u8l( int *aimp_result,
                                        const char *achp_source, int inp_len_source ) {
   const char *achl1, *achl2;               /* working variables       */
   HL_WCHAR   wcl1;                         /* temporary output character */
   /*BOOL       bolerror;                    * invalid input character found */

   achl1 = achp_source;                     /* get start input         */
   achl2 = achp_source + inp_len_source;    /* end of input            */
   /*bolerror = FALSE;*/
   *aimp_result = 0;                        /* return number of characters */
   while (achl1 < achl2) {
     if (((signed char) *achl1) < 0) {      /* more than one character input */
       wcl1 = (HL_WCHAR) *achl1++;
       if (achl1 >= achl2) {
         return FALSE;
       }
       if (((signed char) *achl1) >= 0) {
         return FALSE;
       }
       if ((*achl1 & 0X40) != 0) {
         return FALSE;
       }
       if ((wcl1 & 0X20) == 0) {
         wcl1 &= 0X1F;
         wcl1 <<= 6;
         wcl1 |= *achl1++ & 0X3F;
       } else {
         wcl1 &= 0X0F;
         wcl1 <<= 6;
         wcl1 |= *achl1++ & 0X3F;  /* XXX achl2-check for 3rd byte? */
         if (((signed char) *achl1) >= 0) {
           return FALSE;
         }
         if ((*achl1 & 0X40) != 0) {
           return FALSE;
         }
         wcl1 <<= 6;  /* XXX has this decoding any sense while this function returns only the count? */
         wcl1 |= *achl1++ & 0X3F;
       }
     } else {                               /* one character only      */
       achl1++;                             /* increase input pointer  */
     }
     (*aimp_result)++;                      /* return number of characters */
   }
   return TRUE;
} /* end m_count_u16_from_u8l()                                        */

/**
* get number of bytes before '\0' or limit of utf8 chars is reached
*  @param achp_source input string to measure
*  @param inp_max_chars_source length limit in (encoded, logical) characters
*  @return -1 if malformed UTF8 was found; else
*          length in bytes of the first inp_max_chars_source encoded characters
*          or bytes before the terminating zero, whatever is smaller
*/
static int m_strlen_with_u8l( const char *achp_source, int inp_max_chars_source ) {
   int inl_result;
   int inl_utf8tail;                        /* no. of additional bytes */

   if (achp_source == 0)
     return 0;
   for (inl_result = 0; (inp_max_chars_source > 0) && *(achp_source+inl_result); inl_result ++) {
     inl_utf8tail = chrs_trail_u8l[*((unsigned char*)achp_source+inl_result)];
     if (inl_utf8tail) {
       do {
         if ((*(achp_source + ++inl_result) & 0xC0) != 0x80)
           return -1;                       /* non-10... in sequence   */
       } while (--inl_utf8tail);
     } else {
       if (*(achp_source+inl_result) & 0x80)
         return -1;                         /* 10... outside sequence  */
     }
     inp_max_chars_source --;
   }
   return inl_result;
} /* end m_strlen_with_u8l()                                           */

/**
* get number of bytes before limiting bytecount or limit of utf8 chars reached
*  @param achp_source input string to measure
*  @param inp_max_chars_source length limit in (encoded, logical) characters
*  @param inp_max_bytes length limit in bytes. If the limit will fall in a
*                       non-completed byte-sequence for a character (before the
*                       other limit is reached), less will be returned (only
*                       bytes before that sequence starts will count).
*  @return -1 if malformed UTF8 was found, else length in bytes until one of the
*                                               limitations was reached
*/
static int m_count_with_u8l( const char *achp_source, int inp_max_chars_source,
                             int inp_max_bytes ) {
   int inl_result;
   int inl_utf8tail;                        /* no. of additional bytes */

   if (achp_source == 0)
     return 0;
   for (inl_result = 0; (inp_max_chars_source > 0) && (inp_max_bytes > 0); inl_result ++) {
     inl_utf8tail = chrs_trail_u8l[*((unsigned char*)achp_source+inl_result)];
     if (inl_utf8tail) {
       inp_max_bytes -= (1 + inl_utf8tail);
       if (inp_max_bytes < 0)
         break;                   /* limit hit in the middle of a char */
       do {
         if ((*(achp_source + ++inl_result) & 0xC0) != 0x80)
           return -1;                       /* non-10... in sequence   */
       } while (--inl_utf8tail);
     } else {
       if (*(achp_source+inl_result) & 0x80)
         return -1;                         /* 10... outside sequence  */
       inp_max_bytes --;
     }
     inp_max_chars_source --;
   }
   return inl_result;
} /* end m_count_with_u8l()                                            */

/**
* get number of bytes before '\0' or limit of CJK chars is reached
*  @param achp_source input string to measure
*  @param iep_cs encoding of input string (one of the MBCS-Windows-CPs)
*  @param inp_max_chars_source length limit in (encoded, logical) characters
*  @return -1 if iep_cs was not known by m_get_tab_mb_firstbytes; else
*          length in bytes of the first inp_max_chars_source encoded characters
*          or bytes before the terminating zero, whatever is smaller
*/
static int m_strlen_with_cjkl( const char *achp_source, enum ied_charset iep_cs,
                               int inp_max_chars_source ) {
   int inl_result;
   HL_WCHAR* awcl_lb;

   if (achp_source == 0)
     return 0;
   awcl_lb = m_get_tab_mb_firstbytes(iep_cs);
   if (awcl_lb == 0)
     return -1;
   for (inl_result = 0; (inp_max_chars_source > 0) && *(achp_source+inl_result); inl_result ++) {
     if (awcl_lb[*((unsigned char*)achp_source+inl_result)] == 0xFFFF) {
       inl_result ++;
       if (!(*(achp_source + inl_result)))  /* to be on the safe side  */
         return -1;                         /* cannot be correct       */
     }
     inp_max_chars_source --;
   }
   return inl_result;
} /* end m_strlen_with_cjkl()                                          */

/**
* get number of bytes before limiting bytecount or limit of CJK chars reached
*  @param achp_source input string to measure
*  @param iep_cs encoding of input string, must be one of the MBCS-Windows-CPs!
*  @param inp_max_chars_source length limit in (encoded, logical) characters
*  @param inp_max_bytes length limit in bytes. If the limit will fall in the
*                       middle of a double-byte encoded character (before the
*                       other limit is reached), one less will be returned.
*  @return length in bytes until one of the limitations was reached
*/
static int m_count_with_cjkl( const char *achp_source, enum ied_charset iep_cs,
                              int inp_max_chars_source, int inp_max_bytes ) {
   int inl_result;
   HL_WCHAR* awcl_lb;

   if (achp_source == 0)
     return 0;
   awcl_lb = m_get_tab_mb_firstbytes(iep_cs);
   for (inl_result = 0; (inp_max_chars_source > 0) && (inl_result < inp_max_bytes); inl_result ++) {
     if (awcl_lb[*((unsigned char*)achp_source+inl_result)] == 0xFFFF) {
       inl_result ++;
       if (inl_result == inp_max_bytes) {
         inl_result --;
         break;                   /* limit hit in the middle of a char */
       }
     }
     inp_max_chars_source --;
   }
   return inl_result;
} /* end m_count_with_cjkl()                                           */

/**
* get number of bytes with whole chars before limiting bytecount is reached
*  @param achp_source input string fragment to measure
*  @param iep_cs encoding of the input string fragment
*  @param inp_max_bytes length in bytes of the string fragment.
*  @return -1 on error, else a length in byte either equal to inp_max_bytes or
*                       less, if that limit will fall in the middle of a char
*                       that is there as more than 1 byte (only bytes before the
*                       sequence starts will count). Note that for the types
*                       ied_chs_html_1 and ied_chs_xml_* an ampersand is assumed
*                       to start a character-encoding sequence till the next ';'
*                       (which may be wrong if content of CDATA, comments or
*                       Processing Instructions occur in the string fragment)
*                       not longer than 10 units, all in ASCII-range, in the
*                       encoded form (which may be wrong if self-defined
*                       entities or hex-encoded codepoints far above the
*                       official limit occur in the string fragment).
*/
extern PTYPE int m_count_with_mb( const char *achp_source, enum ied_charset iep_cs,
                                  int inp_max_bytes ) {
   /*int inl_result;*/
   const char *achl_s;                      /* for search              */
   const char *achl_b;                      /* beginning searched part */
   HL_WCHAR   *awcl_s;                      /* for search (in 16-Bit)  */
   HL_WCHAR   *awcl_b;                      /* beginning searched part */
   unsigned char ucl0, ucl1;

   if ((achp_source == 0) || (inp_max_bytes <= 0))
     return 0;
   switch(iep_cs) {
     case ied_chs_ascii_850:
     case ied_chs_ansi_819:
     CASE_IED_CHS_MISCCODEPAGES
     CASE_IED_CHS_ISO8859_2TO16
       return inp_max_bytes;
     case ied_chs_utf_16:
       inp_max_bytes -= inp_max_bytes % sizeof(HL_WCHAR);
       if (inp_max_bytes && ((*((HL_WCHAR*)(achp_source+inp_max_bytes-2)) & 0xFC00) == 0xD800))
         return inp_max_bytes - 2;          /* high surrogate at end   */
       return inp_max_bytes;
     case ied_chs_be_utf_16:
       inp_max_bytes -= inp_max_bytes % sizeof(HL_WCHAR);
       if (inp_max_bytes && ((*(achp_source+inp_max_bytes-2) & 0xFC) == 0xD8))
         return inp_max_bytes - 2;          /* high surrogate at end   */
       return inp_max_bytes;
     case ied_chs_le_utf_16:
       inp_max_bytes -= inp_max_bytes % sizeof(HL_WCHAR);
       if (inp_max_bytes && ((*(achp_source+inp_max_bytes-1) & 0xFC) == 0xD8))
         return inp_max_bytes - 2;          /* high surrogate at end   */
       return inp_max_bytes;
     CASE_IED_CHS_U32_ALLENDIAN
       return inp_max_bytes - (inp_max_bytes % sizeof(unsigned int));
     case ied_chs_wcp_932:
       achl_s = achp_source + inp_max_bytes - 1;
       ucl1 = *achl_s;
       if (m_get_tab_mb_firstbytes(iep_cs)[ucl1]!=0xFFFF)
         return inp_max_bytes;
       while (achl_s != achp_source) {
         ucl0 = *(--achl_s);
       /* 57662 no, 150 false-positive, 7724 recognised */
       if (0x40<=ucl1 && ucl1!=0x7F && ucl1<=0xFC && (ucl0<=0x9F
           ? 0x81<=ucl0 && (ucl1<=0x9E
              ? 0x89<=ucl0 || (ucl0<=0x84 && ucl1+5*ucl0<=805) || ucl0==0x87
              : 0x88<=ucl0 || (ucl0<=0x84 && 51*ucl0+2*ucl1<=7112)
             )
           : 0xE0<=ucl0 && ((ucl0<=0xEA && (ucl0!=0xEA || ucl1<=0xA4)) ||
                            (1<<(ucl0-0xEB)&0x3800C && (ucl0!=0xFC||ucl1<=0x4B))
                           )
          ))
          ucl1 = ucl0;
        else  /* no pair starts here, so answer with the other scenario */
          return inp_max_bytes + (inp_max_bytes-(achl_s-achp_source) & 1) - 1;
       }
       return inp_max_bytes - (inp_max_bytes & 1);
     case ied_chs_wcp_936:
       achl_s = achp_source + inp_max_bytes - 1;
       ucl1 = *achl_s;
       if (m_get_tab_mb_firstbytes(iep_cs)[ucl1]!=0xFFFF)
         return inp_max_bytes;
       while (achl_s != achp_source) {
         ucl0 = *(--achl_s);
       /* 43570 no, 175 false-positive, 21791 recognised */
       if (0x81<=ucl0 && (ucl1<=0xA0
           ? 0x40<=ucl1 && ucl1!=0x7F && (ucl0<=0xA0 || 0xA8<=ucl0)
             && (ucl0<=0xFD || (ucl0==0xFE && ucl1<=0x4F))
           : (ucl0<=0xA9 || 0xB0<=ucl0) && ucl0<=0xF7 && ucl1<=0xFE
          ))
          ucl1 = ucl0;
        else  /* no pair starts here, so answer with the other scenario */
          return inp_max_bytes + (inp_max_bytes-(achl_s-achp_source) & 1) - 1;
       }
       return inp_max_bytes - (inp_max_bytes & 1);
     case ied_chs_wcp_949:
       achl_s = achp_source + inp_max_bytes - 1;
       ucl1 = *achl_s;
       if (m_get_tab_mb_firstbytes(iep_cs)[ucl1]!=0xFFFF)
         return inp_max_bytes;
       while (achl_s != achp_source) {
         ucl0 = *(--achl_s);
       /* 48340 no, 148 false-positive, 17048 recognised */
       if (0x81<=ucl0 && (ucl1<=0xA0
           ? (0x61<=ucl1 ? ucl0<=0xC5 && (ucl1<=0x7A || 0x81<=ucl1)
                         : 0x41<=ucl1 && ucl1<=0x5A && ucl0<=0xC6)
           : (ucl0<=0xAC || (0xB0<=ucl0 && ucl0<=0xFD && ucl0!=0xC9))
             && ucl1<=0xFE
          ))
          ucl1 = ucl0;
        else  /* no pair starts here, so answer with the other scenario */
          return inp_max_bytes + (inp_max_bytes-(achl_s-achp_source) & 1) - 1;
       }
       return inp_max_bytes - (inp_max_bytes & 1);
     case ied_chs_wcp_950:
       achl_s = achp_source + inp_max_bytes - 1;
       ucl1 = *achl_s;
       if (m_get_tab_mb_firstbytes(iep_cs)[ucl1]!=0xFFFF)
         return inp_max_bytes;
       while (achl_s != achp_source) {
         ucl0 = *(--achl_s);
       /* 51971 no, 62 false-positive, 13503 recognised */
       if (ucl1<=0x7E
           ? 0x40<=ucl1 && (ucl0<=0xC6 ? 0xA1<=ucl0 : 0xC9<=ucl0 && ucl0<=0xF9)
           : 0xA1<=ucl1 && (ucl0<=0xC5 ? 0xA1<=ucl0 : 0xC9<=ucl0 && ucl0<=0xF9)
             && ucl1<=0xFE
          )
          ucl1 = ucl0;
        else  /* no pair starts here, so answer with the other scenario */
          return inp_max_bytes + (inp_max_bytes-(achl_s-achp_source) & 1) - 1;
       }
       return inp_max_bytes - (inp_max_bytes & 1);
     do {  /* variant of Duffs device, the "break" go to the end of this pseudoloop */
     case ied_chs_uri_1:
       ucl0 = '%';
       break;
     case ied_chs_ldap_escaped_utf_8:
       ucl0 = '\\';
       break;
     case ied_chs_hsf_1:
       ucl0 = '_';
       break;
     } while (FALSE);       /* end of the pseudoloop   */
       achl_s = achp_source + inp_max_bytes - 1;
       if (inp_max_bytes > 3) {
         achl_b = achl_s - 2;
       } else {
         /* if (inp_max_bytes==0)
           return 0; */
         achl_b = achp_source;
       }
       if (*(achl_s) == ucl0) {             /* ends with escape char   */
         if (iep_cs == ied_chs_ldap_escaped_utf_8) {
           if (inp_max_bytes==1)
             return 0;
           achl_s --;
           if (*(achl_s) == ucl0) {         /* 2 consecutive esc-chars */
             while ((--achl_s)-achp_source>=0) {
               if (*achl_s != ucl0)         /* before \\\\\...-tail    */
                 return inp_max_bytes - (achp_source+inp_max_bytes+1-achl_s & 1);
             }
             return inp_max_bytes - (inp_max_bytes & 1);
           }
           inp_max_bytes --;          /* in any case discard last char */
         } else {                      /* ied_chs_uri_1, ied_chs_hsf_1 */
           achl_s --;
           inp_max_bytes --;          /* in any case discard last char */
           if (inp_max_bytes==0)
             return 0;
         }
       }
       do {
         if (*achl_s == ucl0) {
           int iml_tltse;              /* total length to sequence end */
           if (iep_cs == ied_chs_ldap_escaped_utf_8) {
             if (achl_s-achp_source>0 && *(achl_s-1)==ucl0)
               return inp_max_bytes;        /* double-'\\' last escape */
             if (((*(achl_s+1) & 0xE0) == 0x20) &&
                 (((unsigned int)1<<(*(achl_s+1)-0x20)) & 0x7800180D))
               return inp_max_bytes;        /* last escape is 2-byte   */
           }
           while (achl_s >= achp_source) {  /* search sequence-start   */
             switch (*(achl_s+1)) {
               case 'F': case 'f':
                 iml_tltse = (achl_s-achp_source) + 12;
                 break;
               case 'E': case 'e':
                 iml_tltse = (achl_s-achp_source) + 9;
                 break;
               case 'D': case 'd': case 'C': case 'c':
                 iml_tltse = (achl_s-achp_source) + 6;
                 break;
               default:
                 if (*(achl_s+1) < '8') {
                   iml_tltse = (achl_s-achp_source) + 3;
                   break;
                 }
                 achl_s -= 3;
                 continue;                  /* sequence began earlier  */
             }
             if (iml_tltse <= inp_max_bytes)  /* found sequence-start  */
               return iml_tltse;            /* end within the input    */
             return achl_s - achp_source;   /* end after input-end     */
           }
           return 0;  /* sequence began before start of input (note that
                         in general this function may return nonsense in
                         such a case, but not more than inp_max_bytes) */
         }
       } while (achl_s-- != achl_b);
       return inp_max_bytes;
     case ied_chs_utf_8:
       /*return m_count_with_u8l( achp_source, inp_max_bytes, inp_max_bytes );*/
       /* if (inp_max_bytes==0)
         return 0; */
       achl_s = achp_source + inp_max_bytes - 1;
       if ((signed char)*achl_s < 0) {      /* utf8-sequence found     */
         while ((achl_s > achp_source) && (((unsigned char)*achl_s&0xC0) == 0x80))
           achl_s --;
         if (achl_s + chrs_decode_utf_1_tab[(unsigned char)*achl_s] != achp_source + inp_max_bytes)
           return achl_s - achp_source;     /* end not at input-end    */
       }
       return inp_max_bytes;
     case ied_chs_html_1:
       achl_s = achp_source + inp_max_bytes - 1;
       achl_b = achl_s - 8;
       if (achl_b < achp_source)
         achl_b = achp_source;
       while (achl_s >= achl_b) {           /* look for &...;-sequence */
         if (*achl_s == 0x3B)               /* preceding closed by ';' */
           break;
         if (*achl_s == 0x26)               /* '&' found, ref is open  */
           return achl_s - achp_source;
         achl_s --;
       }
       return inp_max_bytes;
     case ied_chs_xml_utf_8:
       /* if (inp_max_bytes==0)
         return 0; */
       achl_s = achp_source + inp_max_bytes - 1;
       if ((signed char)*achl_s < 0) {      /* utf8-sequence found     */
         while ((achl_s > achp_source) && (((unsigned char)*achl_s&0xC0) == 0x80))
           achl_s --;
         if (achl_s + chrs_decode_utf_1_tab[(unsigned char)*achl_s] != achp_source + inp_max_bytes)
           return achl_s - achp_source;     /* end not at input-end    */
       } else {
         achl_b = (inp_max_bytes < 9) ? achp_source : achl_s - 8;
         while (TRUE) {                     /* look for &...;-sequence */
           if (*achl_s == 0x3B)             /* preceding closed by ';' */
             break;
           if (*achl_s == 0x26)             /* '&' found, ref is open  */
             return achl_s - achp_source;
           if (achl_s <= achl_b)             /* loop condition          */
             break;                         /* search complete, no '&' */
           achl_s --;
           if ((signed char)*achl_s < 0)    /* part of utf-8 sequence  */
             break;                         /* not expected in a &...; */
         }
       }
       return inp_max_bytes;
     case ied_chs_xml_wcp_1252:
       achl_s = achp_source + inp_max_bytes - 1;
       achl_b = (inp_max_bytes < 9) ? achp_source : achl_s - 8;
       while (achl_s >= achl_b) {           /* look for &...;-sequence */
         if (*achl_s == 0x3B)               /* preceding closed by ';' */
           break;
         if (*achl_s == 0x26)               /* '&' found, ref is open  */
           return achl_s - achp_source;
         achl_s --;
       }
       return inp_max_bytes;
     case ied_chs_xml_utf_16:
       inp_max_bytes -= inp_max_bytes % sizeof(HL_WCHAR);
       awcl_s = (HL_WCHAR*)(achp_source+inp_max_bytes) - 1;
       if (inp_max_bytes < (int)(8*sizeof(HL_WCHAR))) {
         if (!inp_max_bytes)
           return 0;
         awcl_b = (HL_WCHAR*)achp_source;
       } else {
         awcl_b = awcl_s - 8;
       }
       if ((*awcl_s & 0xFC00) == 0xD800)
         return inp_max_bytes - 2;          /* high surrogate at end   */
       do {                                 /* look for &...;-sequence */
         if (*awcl_s == 0x3B)               /* preceding closed by ';' */
           break;
         if (*awcl_s == 0x26)               /* '&' found, ref is open  */
           return (char*)awcl_s - achp_source;
         awcl_s --;
       } while (awcl_s >= awcl_b);
       return inp_max_bytes;
     default:                       /* ied_chs_invalid, ied_chs_idna_1 */ 
       return -1;
   }
} /* end m_count_with_mb()                                             */

/**
* method to convert an UTF16-String to single-byte-character- or CJK-string.
* Surrogates are not supported.
*  @param achp_target output buffer
*  @param imp_max_chars maximum count of characters to write; a terminating
*                       zero will be written if it will not transgress this.
*  @param ausp_source input string. May be zero-terminated to stop processing
*                                   before the end of output-buffer.
*  @param iep_cs_target encoding to use for output
*  @return -1 if iep_cs_target is not a supported single-byte or Windows-MBCS
*          encoding, else the number of bytes written excluding the possible
*          terminating zero (so if == imp_max_chars, output is not terminated)
*/
extern PTYPE int m_sbc_from_u16z(char *achp_target, int imp_max_chars, const HL_WCHAR *ausp_source,
                                 enum ied_charset iep_cs_target) {
   char           *achl_cur;                /* current position        */
   char           *achl_end;                /* maximum output position */
   const HL_WCHAR *ausl_source;             /* pointer to an HL_WCHAR-string to read */
   HL_WCHAR       *ausl_ttfu;               /* translation table CJK from unicode */
   HL_WCHAR       usl_lb;                   /* translated 1- or 2-byte value */

   achl_cur = achp_target;                  /* start here              */
   achl_end = achp_target + imp_max_chars;  /* maximum output if sbcs  */
   ausl_source = ausp_source;
   switch(iep_cs_target) {
     case ied_chs_ascii_850:
       while( achl_cur < achl_end && *ausl_source) {
         if(*ausl_source <= 0xFF) {         /* ASCII and Latin-1       */
           *achl_cur++ = ucrg_tab_819_to_850[*ausl_source];
         }
         else {
           *achl_cur++ = ASCII_REP_CHAR;
         }
         ausl_source++;
       }
       break;
     case ied_chs_ansi_819:
       while( achl_cur < achl_end && *ausl_source) {
         if(*ausl_source <= 0xFF) {         /* ASCII and Latin-1       */
           *achl_cur++ = (char) *ausl_source;
         }
         else {
           *achl_cur++ = ASCII_REP_CHAR;
         }
         ausl_source++;
       }
       break;
     case ied_chs_oem_437:
       while( achl_cur < achl_end && *ausl_source)
         *achl_cur++ = m_u32c_to_437((int)(*ausl_source++));
       break;
     case ied_chs_wcp_874:
       while( achl_cur < achl_end && *ausl_source)
         *achl_cur++ = m_u32c_to_874((int)(*ausl_source++));
       break;
     case ied_chs_wcp_1250:
       while( achl_cur < achl_end && *ausl_source)
         *achl_cur++ = m_u32c_to_1250((int)(*ausl_source++));
       break;
     case ied_chs_wcp_1251:
       while( achl_cur < achl_end && *ausl_source)
         *achl_cur++ = m_u32c_to_1251((int)(*ausl_source++));
       break;
     case ied_chs_wcp_1252:
       while( achl_cur < achl_end && *ausl_source)
         *achl_cur++ = m_u32c_to_1252((int)(*ausl_source++));
       break;
     case ied_chs_wcp_1253:
       while( achl_cur < achl_end && *ausl_source)
         *achl_cur++ = m_u32c_to_1253((int)(*ausl_source++));
       break;
     case ied_chs_wcp_1254:
       while( achl_cur < achl_end && *ausl_source)
         *achl_cur++ = m_u32c_to_1254((int)(*ausl_source++));
       break;
     case ied_chs_wcp_1255:
       while( achl_cur < achl_end && *ausl_source)
         *achl_cur++ = m_u32c_to_1255((int)(*ausl_source++));
       break;
     case ied_chs_wcp_1256:
       while( achl_cur < achl_end && *ausl_source)
         *achl_cur++ = m_u32c_to_1256((int)(*ausl_source++));
       break;
     case ied_chs_wcp_1257:
       while( achl_cur < achl_end && *ausl_source)
         *achl_cur++ = m_u32c_to_1257((int)(*ausl_source++));
       break;
     case ied_chs_wcp_1258:
       while( achl_cur < achl_end && *ausl_source)
         *achl_cur++ = m_u32c_to_1258((int)(*ausl_source++));
       break;
     case ied_chs_iso8859_2:
       while( achl_cur < achl_end && *ausl_source)
         *achl_cur++ = m_u32c_to_i02((int)(*ausl_source++));
       break;
     case ied_chs_iso8859_3:
       while( achl_cur < achl_end && *ausl_source)
         *achl_cur++ = m_u32c_to_i03((int)(*ausl_source++));
       break;
     case ied_chs_iso8859_4:
       while( achl_cur < achl_end && *ausl_source)
         *achl_cur++ = m_u32c_to_i04((int)(*ausl_source++));
       break;
     case ied_chs_iso8859_5:
       while( achl_cur < achl_end && *ausl_source)
         *achl_cur++ = m_u32c_to_i05((int)(*ausl_source++));
       break;
     case ied_chs_iso8859_6:
       while( achl_cur < achl_end && *ausl_source)
         *achl_cur++ = m_u32c_to_i06((int)(*ausl_source++));
       break;
     case ied_chs_iso8859_7:
       while( achl_cur < achl_end && *ausl_source)
         *achl_cur++ = m_u32c_to_i07((int)(*ausl_source++));
       break;
     case ied_chs_iso8859_8:
       while( achl_cur < achl_end && *ausl_source)
         *achl_cur++ = m_u32c_to_i08((int)(*ausl_source++));
       break;
     case ied_chs_iso8859_9:
       while( achl_cur < achl_end && *ausl_source)
         *achl_cur++ = m_u32c_to_i09((int)(*ausl_source++));
       break;
     case ied_chs_iso8859_10:
       while( achl_cur < achl_end && *ausl_source)
         *achl_cur++ = m_u32c_to_i10((int)(*ausl_source++));
       break;
     case ied_chs_iso8859_11:
       while( achl_cur < achl_end && *ausl_source)
         *achl_cur++ = m_u32c_to_i11((int)(*ausl_source++));
       break;
     case ied_chs_iso8859_13:
       while( achl_cur < achl_end && *ausl_source)
         *achl_cur++ = m_u32c_to_i13((int)(*ausl_source++));
       break;
     case ied_chs_iso8859_14:
       while( achl_cur < achl_end && *ausl_source)
         *achl_cur++ = m_u32c_to_i14((int)(*ausl_source++));
       break;
     case ied_chs_iso8859_15:
       while( achl_cur < achl_end && *ausl_source)
         *achl_cur++ = m_u32c_to_i15((int)(*ausl_source++));
       break;
     case ied_chs_iso8859_16:
       while( achl_cur < achl_end && *ausl_source)
         *achl_cur++ = m_u32c_to_i16((int)(*ausl_source++));
       break;
     CASE_IED_CHS_ALL_CJK
       ausl_ttfu = m_get_tab_uni_to_mb(iep_cs_target);
       while( achl_cur < achl_end && *ausl_source) {
         usl_lb = ausl_ttfu[ *ausl_source++ ];
         if (usl_lb > 0xFF) {               /* two-byte code           */
           *achl_cur++ = usl_lb>>8;
           *achl_cur++ = (unsigned char)usl_lb;
           achl_end++;                      /* extend space by one     */
         } else {                           /* one-byte code           */
           *achl_cur++ = (unsigned char)usl_lb;
         }
       }
       break;
     default:
       return -1;
   }
   if (achl_cur != achl_end)
     *achl_cur = '\0';
   return (achl_cur - achp_target);
} /* end m_sbc_from_u16z */

/**
* method to convert a reverse-endian UTF16-String to single-byte-character- or
* CJK string. Surrogates are not supported.
*  @param achp_target output buffer
*  @param imp_max_chars maximum count of characters to write; a terminating
*                       zero will be written if it will not transgress this.
*  @param ausp_source input string. May be zero-terminated to stop processing
*                                   before the end of output-buffer.
*  @param iep_cs_target encoding to use for output
*  @return -1 if iep_cs_target is not a supported single-byte or Windows-MBCS
*          encoding, else the number of bytes written excluding the possible
*          terminating zero (so if == imp_max_chars, output is not terminated)
*/
extern PTYPE int m_sbc_from_u16r(char *achp_target, int imp_max_chars,
                                 const  HL_WCHAR *ausp_source, enum ied_charset iep_cs_target) {
   /* extern, but does not appear in hob-xslunic1.h  WS 20141017       */
   char           *achl_cur;                /* current position        */
   char           *achl_end;                /* maximum output position */
   const HL_WCHAR *ausl_source;             /* pointer to an HL_WCHAR-string to read */
   HL_WCHAR       *ausl_ttfu;               /* translation table CJK from unicode */
   HL_WCHAR       usl_lb;                   /* translated 1- or 2-byte value */

   achl_cur = achp_target;                  /* start here              */
   achl_end = achp_target + imp_max_chars;  /* maximum output if sbcs  */
   ausl_source = ausp_source;
   switch (iep_cs_target) {
     case ied_chs_ascii_850:
       while( achl_cur < achl_end && *ausl_source) {
         if(*ausl_source & 0xFF)            /* ASCII and Latin-1       */
           *achl_cur++ = ASCII_REP_CHAR;    /* input lies outside      */
         else
           *achl_cur++ = ucrg_tab_819_to_850[*ausl_source>>8];
         ausl_source++;
       }
       break;
     case ied_chs_ansi_819:
       while( achl_cur < achl_end && *ausl_source) {
         if(*ausl_source & 0xFF)            /* ASCII and Latin-1       */
           *achl_cur++ = ASCII_REP_CHAR;    /* input lies outside      */
         else
           *achl_cur++ = (char) (*ausl_source>>8);
         ausl_source++;
       }
       break;
     case ied_chs_oem_437:
       while( achl_cur < achl_end && *ausl_source) {
         *achl_cur++ = m_u32c_to_437(((*ausl_source<<8)&0xFF00) | (*ausl_source>>8));
         ausl_source++;
       }
       break;
     case ied_chs_wcp_874:
       while( achl_cur < achl_end && *ausl_source) {
         *achl_cur++ = m_u32c_to_874(((*ausl_source<<8)&0xFF00) | (*ausl_source>>8));
         ausl_source++;
       }
       break;
     case ied_chs_wcp_1250:
       while( achl_cur < achl_end && *ausl_source) {
         *achl_cur++ = m_u32c_to_1250(((*ausl_source<<8)&0xFF00) | (*ausl_source>>8));
         ausl_source++;
       }
       break;
     case ied_chs_wcp_1251:
       while( achl_cur < achl_end && *ausl_source) {
         *achl_cur++ = m_u32c_to_1251(((*ausl_source<<8)&0xFF00) | (*ausl_source>>8));
         ausl_source++;
       }
       break;
     case ied_chs_wcp_1252:
       while( achl_cur < achl_end && *ausl_source) {
         *achl_cur++ = m_u32c_to_1252(((*ausl_source<<8)&0xFF00) | (*ausl_source>>8));
         ausl_source++;
       }
       break;
     case ied_chs_wcp_1253:
       while( achl_cur < achl_end && *ausl_source) {
         *achl_cur++ = m_u32c_to_1253(((*ausl_source<<8)&0xFF00) | (*ausl_source>>8));
         ausl_source++;
       }
       break;
     case ied_chs_wcp_1254:
       while( achl_cur < achl_end && *ausl_source) {
         *achl_cur++ = m_u32c_to_1254(((*ausl_source<<8)&0xFF00) | (*ausl_source>>8));
         ausl_source++;
       }
       break;
     case ied_chs_wcp_1255:
       while( achl_cur < achl_end && *ausl_source) {
         *achl_cur++ = m_u32c_to_1255(((*ausl_source<<8)&0xFF00) | (*ausl_source>>8));
         ausl_source++;
       }
       break;
     case ied_chs_wcp_1256:
       while( achl_cur < achl_end && *ausl_source) {
         *achl_cur++ = m_u32c_to_1256(((*ausl_source<<8)&0xFF00) | (*ausl_source>>8));
         ausl_source++;
       }
       break;
     case ied_chs_wcp_1257:
       while( achl_cur < achl_end && *ausl_source) {
         *achl_cur++ = m_u32c_to_1257(((*ausl_source<<8)&0xFF00) | (*ausl_source>>8));
         ausl_source++;
       }
       break;
     case ied_chs_wcp_1258:
       while( achl_cur < achl_end && *ausl_source) {
         *achl_cur++ = m_u32c_to_1258(((*ausl_source<<8)&0xFF00) | (*ausl_source>>8));
         ausl_source++;
       }
       break;
     case ied_chs_iso8859_2:
       while( achl_cur < achl_end && *ausl_source) {
         *achl_cur++ = m_u32c_to_i02(((*ausl_source<<8)&0xFF00) | (*ausl_source>>8));
         ausl_source++;
       }
       break;
     case ied_chs_iso8859_3:
       while( achl_cur < achl_end && *ausl_source) {
         *achl_cur++ = m_u32c_to_i03(((*ausl_source<<8)&0xFF00) | (*ausl_source>>8));
         ausl_source++;
       }
       break;
     case ied_chs_iso8859_4:
       while( achl_cur < achl_end && *ausl_source) {
         *achl_cur++ = m_u32c_to_i04(((*ausl_source<<8)&0xFF00) | (*ausl_source>>8));
         ausl_source++;
       }
       break;
     case ied_chs_iso8859_5:
       while( achl_cur < achl_end && *ausl_source) {
         *achl_cur++ = m_u32c_to_i05(((*ausl_source<<8)&0xFF00) | (*ausl_source>>8));
         ausl_source++;
       }
       break;
     case ied_chs_iso8859_6:
       while( achl_cur < achl_end && *ausl_source) {
         *achl_cur++ = m_u32c_to_i06(((*ausl_source<<8)&0xFF00) | (*ausl_source>>8));
         ausl_source++;
       }
       break;
     case ied_chs_iso8859_7:
       while( achl_cur < achl_end && *ausl_source) {
         *achl_cur++ = m_u32c_to_i07(((*ausl_source<<8)&0xFF00) | (*ausl_source>>8));
         ausl_source++;
       }
       break;
     case ied_chs_iso8859_8:
       while( achl_cur < achl_end && *ausl_source) {
         *achl_cur++ = m_u32c_to_i08(((*ausl_source<<8)&0xFF00) | (*ausl_source>>8));
         ausl_source++;
       }
       break;
     case ied_chs_iso8859_9:
       while( achl_cur < achl_end && *ausl_source) {
         *achl_cur++ = m_u32c_to_i09(((*ausl_source<<8)&0xFF00) | (*ausl_source>>8));
         ausl_source++;
       }
       break;
     case ied_chs_iso8859_10:
       while( achl_cur < achl_end && *ausl_source) {
         *achl_cur++ = m_u32c_to_i10(((*ausl_source<<8)&0xFF00) | (*ausl_source>>8));
         ausl_source++;
       }
       break;
     case ied_chs_iso8859_11:
       while( achl_cur < achl_end && *ausl_source) {
         *achl_cur++ = m_u32c_to_i11(((*ausl_source<<8)&0xFF00) | (*ausl_source>>8));
         ausl_source++;
       }
       break;
     case ied_chs_iso8859_13:
       while( achl_cur < achl_end && *ausl_source) {
         *achl_cur++ = m_u32c_to_i13(((*ausl_source<<8)&0xFF00) | (*ausl_source>>8));
         ausl_source++;
       }
       break;
     case ied_chs_iso8859_14:
       while( achl_cur < achl_end && *ausl_source) {
         *achl_cur++ = m_u32c_to_i14(((*ausl_source<<8)&0xFF00) | (*ausl_source>>8));
         ausl_source++;
       }
       break;
     case ied_chs_iso8859_15:
       while( achl_cur < achl_end && *ausl_source) {
         *achl_cur++ = m_u32c_to_i15(((*ausl_source<<8)&0xFF00) | (*ausl_source>>8));
         ausl_source++;
       }
       break;
     case ied_chs_iso8859_16:
       while( achl_cur < achl_end && *ausl_source) {
         *achl_cur++ = m_u32c_to_i16(((*ausl_source<<8)&0xFF00) | (*ausl_source>>8));
         ausl_source++;
       }
       break;
     CASE_IED_CHS_ALL_CJK
       ausl_ttfu = m_get_tab_uni_to_mb(iep_cs_target);
       while( achl_cur < achl_end && *ausl_source) {
         usl_lb = ausl_ttfu[((*ausl_source<<8)&0xFF00) | (*ausl_source>>8)];
         ausl_source++;
         if (usl_lb > 0xFF) {               /* two-byte code           */
           *achl_cur++ = usl_lb>>8;
           *achl_cur++ = (unsigned char)usl_lb;
           achl_end++;                      /* extend space by one     */
         } else {                           /* one-byte code           */
           *achl_cur++ = (unsigned char)usl_lb;
         }
       }
       break;
     default:
       return -1;
   }
   if (achl_cur != achl_end)
     *achl_cur = '\0';
   return (achl_cur - achp_target);
} /* end m_sbc_from_u16r */

/**
* method to convert an UTF32-String  to single-byte character
*  @param achp_target output buffer
*  @param imp_max_chars maximum count of characters to write; a terminating
*                       zero will be written if it will not transgress this.
*  @param aulp_source input string. May be zero-terminated to stop processing
*                                   before the end of output-buffer.
*  @param iep_cs_target encoding to use for output
*  @return -1 if iep_cs_target is not a supported single-byte or Windows-MBCS
*          encoding, else the number of bytes written excluding the possible
*          terminating zero (so if == imp_max_chars, output is not terminated)
*/
extern PTYPE int m_sbc_from_u32z(char *achp_target, int imp_max_chars,
                                 const int *aulp_source,
                                 enum ied_charset iep_cs_target){
   char               *achl_cur;            /* current position        */
   char               *achl_end;            /* maximum output position */
   const unsigned int *auml_source;         /* pointer to an UTF32-string to read */ /*TODO?*/
   HL_WCHAR           *ausl_ttfu;           /* translation table CJK from unicode */
   HL_WCHAR           usl_lb;               /* translated 1- or 2-byte value */

   achl_cur = achp_target;                  /* start here              */
   achl_end = achp_target + imp_max_chars;  /* maximum output if sbcs  */
   auml_source = (const unsigned int*)aulp_source;
   switch(iep_cs_target) {
     case ied_chs_ascii_850:
       while( achl_cur < achl_end && *auml_source ) {
         if(*auml_source <= 0xFF) {         /* ASCII and Latin-1       */
             *achl_cur++ = ucrg_tab_819_to_850[*auml_source];
         }
         else {
           *achl_cur++ = ASCII_REP_CHAR;
         }
         auml_source++;
       }
       break;
     case ied_chs_ansi_819:
       while( achl_cur < achl_end && *auml_source ) {
         if(*auml_source <= 0xFF) {         /* ASCII and Latin-1       */
             *achl_cur++ = (char) *auml_source;
         }
         else {
           *achl_cur++ = ASCII_REP_CHAR;
         }
         auml_source++;
       }
       break;
     case ied_chs_oem_437:
       while( achl_cur < achl_end && *auml_source )
         *achl_cur++ = m_u32c_to_437(*auml_source++);
       break;
     case ied_chs_wcp_874:
       while( achl_cur < achl_end && *auml_source )
         *achl_cur++ = m_u32c_to_874(*auml_source++);
       break;
     case ied_chs_wcp_1250:
       while( achl_cur < achl_end && *auml_source )
         *achl_cur++ = m_u32c_to_1250(*auml_source++);
       break;
     case ied_chs_wcp_1251:
       while( achl_cur < achl_end && *auml_source )
         *achl_cur++ = m_u32c_to_1251(*auml_source++);
       break;
     case ied_chs_wcp_1252:
       while( achl_cur < achl_end && *auml_source )
         *achl_cur++ = m_u32c_to_1252(*auml_source++);
       break;
     case ied_chs_wcp_1253:
       while( achl_cur < achl_end && *auml_source )
         *achl_cur++ = m_u32c_to_1253(*auml_source++);
       break;
     case ied_chs_wcp_1254:
       while( achl_cur < achl_end && *auml_source )
         *achl_cur++ = m_u32c_to_1254(*auml_source++);
       break;
     case ied_chs_wcp_1255:
       while( achl_cur < achl_end && *auml_source )
         *achl_cur++ = m_u32c_to_1255(*auml_source++);
       break;
     case ied_chs_wcp_1256:
       while( achl_cur < achl_end && *auml_source )
         *achl_cur++ = m_u32c_to_1256(*auml_source++);
       break;
     case ied_chs_wcp_1257:
       while( achl_cur < achl_end && *auml_source )
         *achl_cur++ = m_u32c_to_1257(*auml_source++);
       break;
     case ied_chs_wcp_1258:
       while( achl_cur < achl_end && *auml_source )
         *achl_cur++ = m_u32c_to_1258(*auml_source++);
       break;
     case ied_chs_iso8859_2:
       while( achl_cur < achl_end && *auml_source )
         *achl_cur++ = m_u32c_to_i02(*auml_source++);
       break;
     case ied_chs_iso8859_3:
       while( achl_cur < achl_end && *auml_source )
         *achl_cur++ = m_u32c_to_i03(*auml_source++);
       break;
     case ied_chs_iso8859_4:
       while( achl_cur < achl_end && *auml_source )
         *achl_cur++ = m_u32c_to_i04(*auml_source++);
       break;
     case ied_chs_iso8859_5:
       while( achl_cur < achl_end && *auml_source )
         *achl_cur++ = m_u32c_to_i05(*auml_source++);
       break;
     case ied_chs_iso8859_6:
       while( achl_cur < achl_end && *auml_source )
         *achl_cur++ = m_u32c_to_i06(*auml_source++);
       break;
     case ied_chs_iso8859_7:
       while( achl_cur < achl_end && *auml_source )
         *achl_cur++ = m_u32c_to_i07(*auml_source++);
       break;
     case ied_chs_iso8859_8:
       while( achl_cur < achl_end && *auml_source )
         *achl_cur++ = m_u32c_to_i08(*auml_source++);
       break;
     case ied_chs_iso8859_9:
       while( achl_cur < achl_end && *auml_source )
         *achl_cur++ = m_u32c_to_i09(*auml_source++);
       break;
     case ied_chs_iso8859_10:
       while( achl_cur < achl_end && *auml_source )
         *achl_cur++ = m_u32c_to_i10(*auml_source++);
       break;
     case ied_chs_iso8859_11:
       while( achl_cur < achl_end && *auml_source )
         *achl_cur++ = m_u32c_to_i11(*auml_source++);
       break;
     case ied_chs_iso8859_13:
       while( achl_cur < achl_end && *auml_source )
         *achl_cur++ = m_u32c_to_i13(*auml_source++);
       break;
     case ied_chs_iso8859_14:
       while( achl_cur < achl_end && *auml_source )
         *achl_cur++ = m_u32c_to_i14(*auml_source++);
       break;
     case ied_chs_iso8859_15:
       while( achl_cur < achl_end && *auml_source )
         *achl_cur++ = m_u32c_to_i15(*auml_source++);
       break;
     case ied_chs_iso8859_16:
       while( achl_cur < achl_end && *auml_source )
         *achl_cur++ = m_u32c_to_i16(*auml_source++);
       break;
     CASE_IED_CHS_ALL_CJK
       ausl_ttfu = m_get_tab_uni_to_mb(iep_cs_target);
       while( achl_cur < achl_end && *auml_source) {
         if (*auml_source > 0xFFFF) {       /* check for max. U+FFFF */
           *achl_cur++ = ASCII_REP_CHAR;
           auml_source++;
           continue;
         }
         usl_lb = ausl_ttfu[ *auml_source++ ];
         if (usl_lb > 0xFF) {               /* two-byte code           */
           *achl_cur++ = usl_lb>>8;
           *achl_cur++ = (unsigned char)usl_lb;
           achl_end++;                      /* extend space by one     */
         } else {                           /* one-byte code           */
           *achl_cur++ = (unsigned char)usl_lb;
         }
       }
       break;
     default:
       return -1;
   }
   if (achl_cur != achl_end)
     *achl_cur = '\0';
   return (achl_cur - achp_target);
}/* end m_sbc_from_u32z */

/**
* method to convert a reverse-endian UTF32-String to single-byte character
*  @param achp_target output buffer
*  @param imp_max_chars maximum count of characters to write; a terminating
*                       zero will be written if it will not transgress this.
*  @param aulp_source input string. May be zero-terminated to stop processing
*                                   before the end of output-buffer.
*  @param iep_cs_target encoding to use for output
*  @return -1 if iep_cs_target is not a supported single-byte or Windows-MBCS
*          encoding, else the number of bytes written excluding the possible
*          terminating zero (so if == imp_max_chars, output is not terminated)
*/
extern PTYPE int m_sbc_from_u32r(char *achp_target, int imp_max_chars,
                                 const int *aulp_source, enum ied_charset iep_cs_target) {
   /* extern, but does not appear in hob-xslunic1.h  WS 20141017       */
   char               *achl_cur;            /* current position        */
   char               *achl_end;            /* maximum output position */
   const unsigned int *auml_source;         /* pointer to an UTF32-string to read */
   HL_WCHAR           *ausl_ttfu;           /* translation table CJK from unicode */
   HL_WCHAR           usl_lb;               /* translated 1- or 2-byte value */

   achl_cur = achp_target;                  /* start here              */
   achl_end = achp_target + imp_max_chars;  /* maximum output if sbcs  */
   auml_source = (const unsigned int*)aulp_source;
   switch (iep_cs_target) {
     case ied_chs_ascii_850:
       while( achl_cur < achl_end && *auml_source ) {
         if(*auml_source & 0xFFFFFF)        /* ASCII and Latin-1       */
           *achl_cur++ = ASCII_REP_CHAR;    /* input lies outside      */
         else
           *achl_cur++ = ucrg_tab_819_to_850[*auml_source>>24];
         auml_source++;
       }
       break;
     case ied_chs_ansi_819:
       while( achl_cur < achl_end && *auml_source ) {
         if(*auml_source & 0xFFFFFF)        /* ASCII and Latin-1       */
           *achl_cur++ = ASCII_REP_CHAR;    /* input lies outside      */
         else
           *achl_cur++ = (char) (*auml_source>>24);
         auml_source++;
       }
       break;
     case ied_chs_oem_437:
       while( achl_cur < achl_end && *auml_source ) {
         *achl_cur++ = (*auml_source & 0xC0FFFF) ? ASCII_REP_CHAR  /* check for max. U+3FFF */
                     : m_u32c_to_437(((*auml_source>>8)&0xFF00) | (*auml_source>>24));
         auml_source++;
       }
       break;
     case ied_chs_wcp_874:
       while( achl_cur < achl_end && *auml_source ) {
         *achl_cur++ = (*auml_source & 0xC0FFFF) ? ASCII_REP_CHAR  /* check for max. U+3FFF */
                     : m_u32c_to_874(((*auml_source>>8)&0xFF00) | (*auml_source>>24));
         auml_source++;
       }
       break;
     case ied_chs_wcp_1250:
       while( achl_cur < achl_end && *auml_source ) {
         *achl_cur++ = (*auml_source & 0xC0FFFF) ? ASCII_REP_CHAR  /* check for max. U+3FFF */
                     : m_u32c_to_1250(((*auml_source>>8)&0xFF00) | (*auml_source>>24));
         auml_source++;
       }
       break;
     case ied_chs_wcp_1251:
       while( achl_cur < achl_end && *auml_source ) {
         *achl_cur++ = (*auml_source & 0xC0FFFF) ? ASCII_REP_CHAR  /* check for max. U+3FFF */
                     : m_u32c_to_1251(((*auml_source>>8)&0xFF00) | (*auml_source>>24));
         auml_source++;
       }
       break;
     case ied_chs_wcp_1252:
       while( achl_cur < achl_end && *auml_source ) {
         *achl_cur++ = (*auml_source & 0xC0FFFF) ? ASCII_REP_CHAR  /* check for max. U+3FFF */
                     : m_u32c_to_1252(((*auml_source>>8)&0xFF00) | (*auml_source>>24));
         auml_source++;
       }
       break;
     case ied_chs_wcp_1253:
       while( achl_cur < achl_end && *auml_source ) {
         *achl_cur++ = (*auml_source & 0xC0FFFF) ? ASCII_REP_CHAR  /* check for max. U+3FFF */
                     : m_u32c_to_1253(((*auml_source>>8)&0xFF00) | (*auml_source>>24));
         auml_source++;
       }
       break;
     case ied_chs_wcp_1254:
       while( achl_cur < achl_end && *auml_source ) {
         *achl_cur++ = (*auml_source & 0xC0FFFF) ? ASCII_REP_CHAR  /* check for max. U+3FFF */
                     : m_u32c_to_1254(((*auml_source>>8)&0xFF00) | (*auml_source>>24));
         auml_source++;
       }
       break;
     case ied_chs_wcp_1255:
       while( achl_cur < achl_end && *auml_source ) {
         *achl_cur++ = (*auml_source & 0xC0FFFF) ? ASCII_REP_CHAR  /* check for max. U+3FFF */
                     : m_u32c_to_1255(((*auml_source>>8)&0xFF00) | (*auml_source>>24));
         auml_source++;
       }
       break;
     case ied_chs_wcp_1256:
       while( achl_cur < achl_end && *auml_source ) {
         *achl_cur++ = (*auml_source & 0xC0FFFF) ? ASCII_REP_CHAR  /* check for max. U+3FFF */
                     : m_u32c_to_1256(((*auml_source>>8)&0xFF00) | (*auml_source>>24));
         auml_source++;
       }
       break;
     case ied_chs_wcp_1257:
       while( achl_cur < achl_end && *auml_source ) {
         *achl_cur++ = (*auml_source & 0xC0FFFF) ? ASCII_REP_CHAR  /* check for max. U+3FFF */
                     : m_u32c_to_1257(((*auml_source>>8)&0xFF00) | (*auml_source>>24));
         auml_source++;
       }
       break;
     case ied_chs_wcp_1258:
       while( achl_cur < achl_end && *auml_source ) {
         *achl_cur++ = (*auml_source & 0xC0FFFF) ? ASCII_REP_CHAR  /* check for max. U+3FFF */
                     : m_u32c_to_1258(((*auml_source>>8)&0xFF00) | (*auml_source>>24));
         auml_source++;
       }
       break;
     case ied_chs_iso8859_2:
       while( achl_cur < achl_end && *auml_source ) {
         *achl_cur++ = (*auml_source & 0xFCFFFF) ? ASCII_REP_CHAR  /* check for max. U+03FF */
                     : m_u32c_to_i02(((*auml_source>>8)&0xFF00) | (*auml_source>>24));
         auml_source++;
       }
       break;
     case ied_chs_iso8859_3:
       while( achl_cur < achl_end && *auml_source ) {
         *achl_cur++ = (*auml_source & 0xFCFFFF) ? ASCII_REP_CHAR  /* check for max. U+03FF */
                     : m_u32c_to_i03(((*auml_source>>8)&0xFF00) | (*auml_source>>24));
         auml_source++;
       }
       break;
     case ied_chs_iso8859_4:
       while( achl_cur < achl_end && *auml_source ) {
         *achl_cur++ = (*auml_source & 0xFCFFFF) ? ASCII_REP_CHAR  /* check for max. U+03FF */
                     : m_u32c_to_i04(((*auml_source>>8)&0xFF00) | (*auml_source>>24));
         auml_source++;
       }
       break;
     case ied_chs_iso8859_5:
       while( achl_cur < achl_end && *auml_source ) {
         *achl_cur++ = (*auml_source & 0xC0FFFF) ? ASCII_REP_CHAR  /* check for max. U+3FFF */
                     : m_u32c_to_i05(((*auml_source>>8)&0xFF00) | (*auml_source>>24));
         auml_source++;
       }
       break;
     case ied_chs_iso8859_6:
       while( achl_cur < achl_end && *auml_source ) {
         *achl_cur++ = (*auml_source & 0xF8FFFF) ? ASCII_REP_CHAR  /* check for max. U+07FF */
                     : m_u32c_to_i06(((*auml_source>>8)&0xFF00) | (*auml_source>>24));
         auml_source++;
       }
       break;
     case ied_chs_iso8859_7:
       while( achl_cur < achl_end && *auml_source ) {
         *achl_cur++ = (*auml_source & 0xC0FFFF) ? ASCII_REP_CHAR  /* check for max. U+3FFF */
                     : m_u32c_to_i07(((*auml_source>>8)&0xFF00) | (*auml_source>>24));
         auml_source++;
       }
       break;
     case ied_chs_iso8859_8:
       while( achl_cur < achl_end && *auml_source ) {
         *achl_cur++ = (*auml_source & 0xC0FFFF) ? ASCII_REP_CHAR  /* check for max. U+3FFF */
                     : m_u32c_to_i08(((*auml_source>>8)&0xFF00) | (*auml_source>>24));
         auml_source++;
       }
       break;
     case ied_chs_iso8859_9:
       while( achl_cur < achl_end && *auml_source ) {
         *achl_cur++ = (*auml_source & 0xFEFFFF) ? ASCII_REP_CHAR  /* check for max. U+01FF */
                     : m_u32c_to_i09(((*auml_source>>8)&0xFF00) | (*auml_source>>24));
         auml_source++;
       }
       break;
     case ied_chs_iso8859_10:
       while( achl_cur < achl_end && *auml_source ) {
         *achl_cur++ = (*auml_source & 0xC0FFFF) ? ASCII_REP_CHAR  /* check for max. U+3FFF */
                     : m_u32c_to_i10(((*auml_source>>8)&0xFF00) | (*auml_source>>24));
         auml_source++;
       }
       break;
     case ied_chs_iso8859_11:
       while( achl_cur < achl_end && *auml_source ) {
         *achl_cur++ = (*auml_source & 0xF0FFFF) ? ASCII_REP_CHAR  /* check for max. U+0FFF */
                     : m_u32c_to_i11(((*auml_source>>8)&0xFF00) | (*auml_source>>24));
         auml_source++;
       }
       break;
     case ied_chs_iso8859_13:
       while( achl_cur < achl_end && *auml_source ) {
         *achl_cur++ = (*auml_source & 0xC0FFFF) ? ASCII_REP_CHAR  /* check for max. U+3FFF */
                     : m_u32c_to_i13(((*auml_source>>8)&0xFF00) | (*auml_source>>24));
         auml_source++;
       }
       break;
     case ied_chs_iso8859_14:
       while( achl_cur < achl_end && *auml_source ) {
         *achl_cur++ = (*auml_source & 0xE0FFFF) ? ASCII_REP_CHAR  /* check for max. U+1FFF */
                     : m_u32c_to_i14(((*auml_source>>8)&0xFF00) | (*auml_source>>24));
         auml_source++;
       }
       break;
     case ied_chs_iso8859_15:
       while( achl_cur < achl_end && *auml_source ) {
         *achl_cur++ = (*auml_source & 0xC0FFFF) ? ASCII_REP_CHAR  /* check for max. U+3FFF */
                     : m_u32c_to_i15(((*auml_source>>8)&0xFF00) | (*auml_source>>24));
         auml_source++;
       }
       break;
     case ied_chs_iso8859_16:
       while( achl_cur < achl_end && *auml_source ) {
         *achl_cur++ = (*auml_source & 0xC0FFFF) ? ASCII_REP_CHAR  /* check for max. U+3FFF */
                     : m_u32c_to_i16(((*auml_source>>8)&0xFF00) | (*auml_source>>24));
         auml_source++;
       }
       break;
     CASE_IED_CHS_ALL_CJK
       ausl_ttfu = m_get_tab_uni_to_mb(iep_cs_target);
       while( achl_cur < achl_end && *auml_source) {
         if (*auml_source & 0xFFFF) {       /* check for max. U+FFFF */
           *achl_cur++ = ASCII_REP_CHAR;
           auml_source++;
           continue;
         }
         usl_lb = ausl_ttfu[((*auml_source>>8)&0xFF00) | (*auml_source>>24)];
         auml_source++;
         if (usl_lb > 0xFF) {               /* two-byte code           */
           *achl_cur++ = usl_lb>>8;
           *achl_cur++ = (unsigned char)usl_lb;
           achl_end++;                      /* extend space by one     */
         } else {                           /* one-byte code           */
           *achl_cur++ = (unsigned char)usl_lb;
         }
       }
       break;
     default:
       return -1;
   }
   if (achl_cur != achl_end)
     *achl_cur = '\0';
   return (achl_cur - achp_target);
}/* end m_sbc_from_u32r */

/**
* method to return the number of bytes in UTF-8 of a Unicode-String.
* Note that if there are any UTF16-surrogates in the input string, the result
* will correspond not to the length of the UTF-8, but of the CESU-8 encoding.
*  @param awcp1 zero-terminated input string
*  @return how many bytes would be needed after conversion, without terminator.
*/
extern PTYPE int m_count_wchar_z_to_utf8( const HL_WCHAR * awcp1 ) {
   int        inl1;                         /* working variable        */

   inl1 = 0;
   while (*awcp1) {
     if (*awcp1 < 0X80) {
       inl1++;                              /* target one byte         */
     } else if (*awcp1 < 0X0800) {
       inl1 += 2;                           /* target plus two bytes   */
     } else {
       inl1 += 3;                           /* target plus three bytes */
     }
     awcp1++;                               /* next character          */
   }
   return inl1;
} /* end m_count_wchar_z_to_utf8                                       */

/**
* method to return the UTF-8 values of a Unicode-String.
* (If the input is UTF-16 with surrogates, the result will rather be CESU-8.)
*  @param achptarget pointer to output buffer. Output will not be terminated.
*  @param awcp1 zero-terminated input string
*  @return count of bytes written
*/
extern PTYPE int m_trans_wchar_z_to_utf8( char * achptarget, const HL_WCHAR * awcp1 ) {
   char       *achl1;

   achl1 = achptarget;                      /* start here              */
   while (*awcp1) {
     if (*awcp1 < 0X80) {
       *achl1++ = (char) *awcp1;
     } else if (*awcp1 < 0X0800) {
       *achl1++ = 0XC0 | (*awcp1 >> 6);
       *achl1++ = 0X80 | (*awcp1 & 0X3F);
     } else {
       *achl1++ = 0XE0 | (*awcp1 >> 12);
       *achl1++ = 0X80 | ((*awcp1 >> 6) & 0X3F);
       *achl1++ = 0X80 | (*awcp1 & 0X3F);
     }
     awcp1++;                               /* next character          */
   }
   return (achl1 - achptarget);
} /* end m_trans_wchar_z_to_utf8                                       */

/** @} */
/**
* reads an unsigned decimal integer number
*  @param awcp1 zero-terminated wide-char input string
*  @return -1 if awcp1 contains anything else than ASCII digits or is empty,
*          else its value parsed as decimal number
*/
extern PTYPE int m_get_wc_number( const HL_WCHAR * awcp1 ) {
   int            inl1;                     /* working variable        */
   const HL_WCHAR *awcl1;                   /* working variable        */
   if ((awcp1 == NULL) || (*awcp1 == 0))
     return -1;
   awcl1 = awcp1;                           /* get parameter           */
   inl1 = 0;
   do {
     if (*awcl1 < L'0') return -1;
     if (*awcl1 > L'9') return -1;
     inl1 *= 10;
     inl1 += *awcl1 - L'0';
     awcl1++;
   } while (*awcl1);
   return inl1;
} /* end m_get_wc_number()                                             */

/**
* reads a nonnegative decimal integer number
*  @param adsp_ucs input string
*  @return if adsp_ucs matches /^[0-9]+$/, its value parsed as decimal;
*          else -1
*/
extern PTYPE int m_get_ucs_number( const struct dsd_unicode_string *adsp_ucs ) {
   unsigned int unl_sum;                    /* accumulating the result */
   unsigned int unl_digit;                  /* retrieved from one char */
   int          inl_nread;                /* bytes read by m_get_vc_ch */
   const char*  achl_source;                /* where we read currently */
   const char*  achl_end;                   /* end if known, else NULL */

   achl_source = (char*)adsp_ucs->ac_str;
   achl_end = m_get_limit(adsp_ucs);

   inl_nread = m_get_vc_ch(&unl_digit, achl_source, achl_end, adsp_ucs->iec_chs_str);
   if (inl_nread<=0) return -1;             /* error or unexpected end */
   achl_source += inl_nread;
   unl_sum = unl_digit^0x30;
   if (unl_sum>9)
     return -1;                         /* outside range 0..9      */
   while (TRUE) {
     inl_nread = m_get_vc_ch(&unl_digit, achl_source, achl_end, adsp_ucs->iec_chs_str);
     if (inl_nread<=0) {
       if (inl_nread<0) return -1;      /* error                   */
       break;                               /* regular end of string   */
     }
     unl_digit ^= 0x30;
     if (unl_digit>9)
       return -1;                       /* outside range 0..9      */
     unl_sum *= 10;
     unl_sum += unl_digit;
     achl_source += inl_nread;
   }
   return (int)unl_sum;
/*XXX evtl. overflow-prüfung*/
} /* end m_get_ucs_number()                                            */

#ifdef XXX_NEW_GETNUMBER_FUNC

/**
* reads a decimal or 0[xX]-marked hexadecimal integer number
*  @param[out] a
*  @param adsp_ucs input string
*  @return usw
XXX und evtl. overflow-prüfung
kb: minus nicht in m_get_ucs_bytes_no einbauen, also hier extra funktion mit minus (mail 20141208)




if adsp_ucs matches /^[+-]?[0-9]+$/, its value parsed as decimal
*          number; else if it matches /^[+-]?0[xX][0-9a-fA-F]+$/, its value
*          parsed as hexadecimal number; else -1
*/
extern PTYPE BOOL m_get_ucs_number( int*         , const struct dsd_unicode_string *adsp_ucs ) {
XXX entsprechend abwandeln
   unsigned int unl_sum;                    /* accumulating the result */
   unsigned int unl_digit;                  /* retrieved from one char */
   int          inl_nread;                /* bytes read by m_get_vc_ch */
   BOOL         bol_minus;                  /* negative sign found     */
   const char*  achl_source;                /* where we read currently */
   const char*  achl_end;                   /* end if known, else NULL */

   achl_source = (char*)adsp_ucs->ac_str;
   achl_end = m_get_limit(adsp_ucs);
   bol_minus = FALSE;

   inl_nread = m_get_vc_ch(&unl_digit, achl_source, achl_end, adsp_ucs->iec_chs_str);
   if (inl_nread<=0) return -1;             /* error or unexpected end */
   achl_source += inl_nread;

   switch (unl_digit) {
     case 0x2D:                             /* minus sign              */
       bol_minus = TRUE;                    /* set flag & fall through */
     case 0x2B:                             /* plus sign, fetch next   */
       inl_nread = m_get_vc_ch(&unl_digit, achl_source, achl_end, adsp_ucs->iec_chs_str);
       if (inl_nread<=0) return -1;         /* error or unexpected end */
       achl_source += inl_nread;
       if (unl_digit != 0x30)
         break;                             /* else fall through       */
     case 0x30:                             /* digit zero              */
       inl_nread = m_get_vc_ch(&unl_digit, achl_source, achl_end, adsp_ucs->iec_chs_str);
       if (inl_nread<=0)
         return((inl_nread==0) ? 0 : -1);   /* string was "0" or error */
       achl_source += inl_nread;
       if ((unl_digit|0x20)==0x78) {        /* 'X' or 'x': hex number  */
         inl_nread = m_get_vc_ch(&unl_digit, achl_source, achl_end, adsp_ucs->iec_chs_str);
         if (inl_nread<=0) return -1;       /* error or unexpected end */
         unl_sum = 0;
         do {
           unl_sum <<= 4;
           if (unl_digit > 0x39) {          /* greater than digit 9    */
             unl_digit |= 0x20;             /* folding A..F to a..f    */
             if ((unl_digit < 0x61) || (0x66 < unl_digit))
               return -1;                   /* no hexdigit             */
             unl_sum += unl_digit-0x57;     /* hexdigit over 9         */
           } else {
             if (unl_digit < 0x30)
               return -1;                   /* no hexdigit             */
             unl_sum += unl_digit-0x30;     /* hexdigit from 0..9      */
           }
           achl_source += inl_nread;
           inl_nread = m_get_vc_ch(&unl_digit, achl_source, achl_end, adsp_ucs->iec_chs_str);
           if (inl_nread<0) return -1;      /* error                   */
         } while (inl_nread>0);              /* repeat to end of string */
         return(bol_minus ? -(signed int)unl_sum : (int)unl_sum);
       }
       break;                               /* (else) continue decimal */
     default:
       break;
   }
   unl_sum = unl_digit^0x30;
   if (unl_sum>9)
     return FALSE;                         /* outside range 0..9      */
   while (TRUE) {
     inl_nread = m_get_vc_ch(&unl_digit, achl_source, achl_end, adsp_ucs->iec_chs_str);
     if (inl_nread<=0) {
       if (inl_nread<0) return FALSE;      /* error                   */
       break;                               /* regular end of string   */
     }
     unl_digit ^= 0x30;
     if (unl_digit>9)
       return FALSE;                       /* outside range 0..9      */
     unl_sum *= 10;
     unl_sum += unl_digit;
     achl_source += inl_nread;
   }
   return(bol_minus ? -(signed int)unl_sum : (int)unl_sum);
   return TRUE;
} /* end m_get_ucs_number()                                            */

#endif

/** @addtogroup unicode
* @{
*/
/**
* Method to fold ied_charset values (to permit simpler switches in the code).
*  @param iep_cs any charset value
*  @return if endianness was explicit in iep_cs, and the same as the endianness
*          this module was compiled for (probably the native one on this
*          architecture), then the corresponding charset value without explicit
*          endianness. In all other cases, equals to iep_cs.
*/
static enum ied_charset m_suppress_endian_info_if_native( enum ied_charset iep_cs ) {
   static const int inrls_machine_endian_checker[1] = { 1 };
   if (*((char*)(inrls_machine_endian_checker)))
   { /* this machine uses little endian                                */
     switch (iep_cs) {
       case ied_chs_le_utf_16:
         return ied_chs_utf_16;
       case ied_chs_le_utf_32:
         return ied_chs_utf_32;
       default:
         return iep_cs;
     }
   }
   else
   { /* this machine uses big endian                                   */
     switch (iep_cs) {
       case ied_chs_be_utf_16:
         return ied_chs_utf_16;
       case ied_chs_be_utf_32:
         return ied_chs_utf_32;
       default:
         return iep_cs;
     }
   }
}
/** @} */

/**
* make a number from a Unicode String given bytes (MB / GB)
*  @param awcp1 zero-terminated wide-char input string
*  @return -1 if awcp1 did not match /^[ 0-9]*[1-9][ 0-9]*[KkMmGg]? *[Bb]? *$/,
*          else its value parsed as decimal number, with 'K', 'M' or 'G' case-
*          insensitively interpreted as power-of-2 prefixes and 'B'/'b' ignored
*/
extern PTYPE HL_LONGLONG m_get_bytes_no( const HL_WCHAR * awcp1 ) {
   HL_LONGLONG    ill1;                     /* working-variable        */
   BOOL           bol1;                     /* working-variable        */
   const HL_WCHAR *awcl1;                   /* working-variable        */

   ill1 = 0;                                /* inizialize variable     */
   bol1 = FALSE;                            /* no digit found yet      */
   awcl1 = awcp1;                           /* here is input           */
   while (TRUE) {                           /* loop over input         */
     if (*awcl1 == 0) {
       if (bol1) return ill1;               /* all valid               */
       return -1;                           /* error occured           */
     }
     if ((*awcl1 >= L'0') && (*awcl1 <= L'9')) {
       ill1 *= 10;                          /* multiply old value      */
       ill1 += *awcl1 - L'0';               /* add new digit           */
       if (*awcl1 != L'0') bol1 = TRUE;     /* valid digit found       */
     } else if (*awcl1 != L' ') {
       break;
     }
     awcl1++;                               /* next character input    */
   }
   if (bol1 == FALSE) return -1;            /* no valid digit found    */
   /* there are more characters                                        */
   bol1 = FALSE;                            /* no b for byte found     */
   switch (*awcl1) {
     case L'K':
     case L'k':
       ill1 *= 1024;                        /* kilo                    */
       break;
     case L'M':
     case L'm':
       ill1 *= 1024 * 1024;                 /* mega                    */
       break;
     case L'G':
     case L'g':
       ill1 *= 1024 * 1024 * 1024;          /* giga                    */
       break;
     case L'B':
     case L'b':
       bol1 = TRUE;                         /* b for byte found        */
       break;
     default:
       return -1;                           /* invalid character       */
   }
   awcl1++;                                 /* next character          */
   while (*awcl1) {                         /* loop over remaining part */
     if ((*awcl1 == L'B') || (*awcl1 == L'b')) {
       if (bol1) return -1;                 /* more than one b         */
       bol1 = TRUE;                         /* b for byte found        */
     } else if (*awcl1 != L' ') {
       return -1;                           /* invalid character       */
     }
     awcl1++;                               /* next character input    */
   }
   return ill1;                             /* return value            */
} /* end m_get_bytes_no()                                              */

/**
* make a number from a Unicode String given bytes (MB / GB / ...)
*  @param    input string
*  @return -1 if awcp1 did not match /^[ 0-9]*[1-9][ 0-9]*[KkMmGgTtPpEeZzYy]? *[Bb]? *$/
           or if the result would overflow (or use the MSB of) HL_LONGLONG,
*          else its value parsed as decimal number, with 'K', 'M', 'G' etc. case-
*          insensitively interpreted as power-of-2 prefixes and 'B'/'b' ignored
*/
extern PTYPE HL_LONGLONG m_get_ucs_bytes_no( const struct dsd_unicode_string *adsp_usc_source ) {
#define ILD_HLL_3FFF ((((HL_LONGLONG)1)<<(sizeof(HL_LONGLONG)*8-2))-1)
   static const HL_LONGLONG ild_limit01 = ILD_HLL_3FFF/5;
   static const unsigned int chd_lldd = (ILD_HLL_3FFF-5*(ILD_HLL_3FFF/5))*2+1;
#undef ILD_HLL_3FFF
   HL_LONGLONG  ill1;                       /* accumulating the result */
   BOOL         bol1;                       /* working-variable        */
   unsigned int unl0;                       /* working-variable        */
   unsigned int unl_digit;                  /* retrieved from one char */
   int          inl_nread;                  /* bytes read by m_get_vc_ch */
   const char*  achl_source;                /* where we read currently */
   const char*  achl_end;                   /* end if known, else NULL */

   achl_source = (char*)adsp_usc_source->ac_str;
   achl_end = m_get_limit(adsp_usc_source);

   ill1 = 0;                                /* inizialize variable     */
   bol1 = FALSE;                            /* no digit found yet      */
   while (TRUE) {                           /* loop over input         */
     inl_nread = m_get_vc_ch(&unl_digit, achl_source, achl_end, adsp_usc_source->iec_chs_str);
     if (inl_nread <= 0) {                  /* end of input            */
       if (bol1 && (inl_nread == 0)) return ill1;  /* all valid        */
       return -1;                           /* error or unexpected end */
     }
     achl_source += inl_nread;
     unl0 = unl_digit ^ 0x30;
     if (unl0 < 10) {
       if (ill1 >= ild_limit01) {
         if ((ill1 > ild_limit01) || (unl0 > chd_lldd)) {  /* check for narrow escape */
           return -1;                       /* overflow (if signed)    */
         }
       }
       ill1 *= 10;                          /* multiply old value      */
       ill1 += unl0;                        /* add new digit           */
       if (unl_digit != (unsigned int)'0') bol1 = TRUE;     /* valid digit found       */
     } else if (unl_digit != (unsigned int)' ') {
       break;
     }
   }
   if (bol1 == FALSE) return -1;            /* no valid digit found    */
   /* there are more characters                                        */
   switch (unl_digit) {
     case (unsigned int)'K': case (unsigned int)'k': unl0 = 10; break;  /* kilo  */
     case (unsigned int)'M': case (unsigned int)'m': unl0 = 20; break;  /* mega  */
     case (unsigned int)'G': case (unsigned int)'g': unl0 = 30; break;  /* giga  */
     case (unsigned int)'T': case (unsigned int)'t': unl0 = 40; break;  /* tera  */
     case (unsigned int)'P': case (unsigned int)'p': unl0 = 50; break;  /* peta  */
     case (unsigned int)'E': case (unsigned int)'e': unl0 = 60; break;  /* exa   */
     case (unsigned int)'Z': case (unsigned int)'z': unl0 = 70; break;  /* zetta */
     case (unsigned int)'Y': case (unsigned int)'y': unl0 = 80; break;  /* yotta */
     case (unsigned int)'B': case (unsigned int)'b':  /* b for byte    */
       goto p_after_b;
       break;
     default:
       return -1;                           /* invalid character       */
   }
   if (ill1) {
     if (((sizeof(ill1)<<3) <= unl0) || (ill1 >> ((sizeof(ill1)<<3)-(1+unl0))))
       return -1;                           /* overflow (if signed)    */
     ill1 <<= unl0;
   }
   while (TRUE) {                           /* loop over remaining part */
     inl_nread = m_get_vc_ch(&unl_digit, achl_source, achl_end, adsp_usc_source->iec_chs_str);
     if (inl_nread <= 0) {                  /* end of input            */
       if (inl_nread == 0) return ill1;     /* all valid, without [Bb] */
       return -1;                           /* error getting character */
     }
     achl_source += inl_nread;
     if ((unl_digit == (unsigned int)'B') || (unl_digit == (unsigned int)'b')) {
       goto p_after_b;
     } else if (unl_digit != (unsigned int)' ') {
       return -1;                           /* invalid character       */
     }
   }
   p_after_b:
   while (TRUE) {                           /* loop over remaining part */
     inl_nread = m_get_vc_ch(&unl_digit, achl_source, achl_end, adsp_usc_source->iec_chs_str);
     if ((inl_nread <= 0) || (unl_digit != (unsigned int)' ')) {
       if (inl_nread == 0) return ill1;     /* end of input, all valid */
       return -1;                           /* error                   */
     }
     achl_source += inl_nread;
   }
} /* end m_get_ucs_bytes_no()                                          */

/**
* Translates part of a "Distinguished Name" UTF-8-based string representation
* into a "Relative Distinguished Name" UTF-8 string in-place.
* The encoding of the returned struct will be ied_chs_utf_8, except if a value
* from a hexstring had ASN1-type OCTET STRING, in which case it will be set to
* ied_chs_ansi_819. Note that this results in an inconsistency if the RDN has
* more than one attributeTypeAndValue (separated by '+') including at least one
* OCTET STRING and at least one non-ASCII character somewehere else, because
* that will be encoded as UTF8-byte-sequence in the output; however, this case
* is taxed by Mr. Lauenstein as very improbable in practice (WS 20170216).
*  @param[in,out] achp_buf pointer to a writable buffer containing UTF8-encoded
*                          zero-terminated DN string whose attribute-values are
*                          escaped as described by RFC 4514. On return with a
*                          return value > 0, there will start a unescaped
*                          UTF8-encoded zero-terminated form of its leading RDN.
*  @param[in] achp_end_buf pointer after the end of the input/output-buffer,
*                          also limits DN input if that has no terminating zero.
*  @param[in,out] adsp_usc_rdn pointer to a struct which will be filled with a
*                              pointer to the decoded RDN content within the
*                              buffer, the decoded length and the encoding which
*                              will be ied_chs_utf_8 unless hexstring was found.
*  @return negative on error, namely
*                  HL_ERR_UCGETC_META  something was found that may be allowed
*                                      by some rule, but is not implemented yet
*                  HL_ERR_UCGETC_INPSH on unexpected end of the input string
*                  HL_ERR_UCGETC_INV   if any other error occurs;
*          0 if start is already at end;
*          else count of bytes after achp_buf where to start decoding next RDN.
*/
extern PTYPE int m_rfc4514unmask( char *achp_buf, char *achp_end_buf,
                                  struct dsd_unicode_string *adsp_usc_rdn ) {
   unsigned int  uml_ch_source;             /* character decoded       */
   unsigned char *aucl_cur_target = NULL;   /* NULL = not used yet, just keep */

#define MR4UM_CHECK_KEPT(AP_END) {  /* to consistently have all content checked */ \
   if (!m_check_vx(adsp_usc_rdn->ac_str, (char*)(AP_END)-(char*)adsp_usc_rdn->ac_str, ied_chs_utf_8)) \
     return HL_ERR_UCGETC_INV;}
#define MR4UM_RETURN_BOTH_LEN \
   adsp_usc_rdn->imc_len_str = aucl_cur_target-(unsigned char*)adsp_usc_rdn->ac_str; \
   return achp_buf-(char*)adsp_usc_rdn->ac_str;

   if (achp_buf==NULL || achp_end_buf==NULL)
     return HL_ERR_UCGETC_INV;
   if (achp_buf>=achp_end_buf || !*achp_buf)
     return adsp_usc_rdn->imc_len_str = 0;  /* embty input             */
   adsp_usc_rdn->ac_str = achp_buf;
   adsp_usc_rdn->iec_chs_str = ied_chs_utf_8;
   p_pass_attrtype:              /* copy up to and including first '=' */
   if (aucl_cur_target==NULL) {
     while (*achp_buf != '=') {
       ++ achp_buf;
       if (achp_buf==achp_end_buf || !*achp_buf)  /*UUU never been tested for _INV */
         return HL_ERR_UCGETC_INPSH;       /* expected '=' not reached */
     }
   } else {
     unsigned char* aucl_nmst=aucl_cur_target;  /* check if copied too */
     while (*achp_buf != '=') {
       *aucl_cur_target = *achp_buf;
       ++ achp_buf;
       if (achp_buf==achp_end_buf || !*achp_buf)
         return HL_ERR_UCGETC_INPSH;       /* expected '=' not reached */
       aucl_cur_target++;
     }
     *aucl_cur_target++ = '=';
     if (!m_check_vx(aucl_nmst, aucl_cur_target-aucl_nmst, ied_chs_utf_8))
       return HL_ERR_UCGETC_INV;
   }
   ++ achp_buf;
   if (achp_buf==achp_end_buf || !*achp_buf) {  /* empty value         */
     if (aucl_cur_target == NULL) {
       MR4UM_CHECK_KEPT(achp_buf)          /* validate utf8 from start */
       return adsp_usc_rdn->imc_len_str = achp_buf-(char*)adsp_usc_rdn->ac_str;
     } else {
       MR4UM_RETURN_BOTH_LEN
     }
   }
   if (*achp_buf == '#') {         /* hexstring encoded ASN.1 as value */
     unsigned int inl_d;                    /* for hex char decoding   */
     int inl_len;
     int inl_iipl = 0;           /* input (part) length for inner loop */
     int inl_cirl;               /* current rest length for inner loop */
     if (aucl_cur_target == NULL) {
       MR4UM_CHECK_KEPT(achp_buf)          /* validate utf8 from start */
       aucl_cur_target = (unsigned char*)achp_buf;
     }
     if (achp_end_buf-achp_buf < 4)  /* need 2 bytes for ASN.1 type and length */
       return HL_ERR_UCGETC_INPSH;
     achp_buf ++;
     switch (*achp_buf) {  /*XXX ASN.1-codes NOT TESTED, taken from a not completely understood document */
       case '0':
         achp_buf ++;
         switch (*achp_buf) {
           case '4':                        /* OCTET STRING            */
             adsp_usc_rdn->iec_chs_str=ied_chs_ansi_819;
             break;
           case 'C': case 'c':              /* UTF8String              */
             /* expect hexstring-encoded ied_chs_utf_8                 */
             break;
           default:            /* some ASN.1-type not implemented here */
             return HL_ERR_UCGETC_META;
         }
         break;
       case '1':
         achp_buf ++;
         switch (*achp_buf)  {
           /* various probably ASCII-subset-like string types          */
           case '2': case '3': case '6': case '7': case '8': case 'A': case 'a':
             /* expect hexstring-encoded UTF8-conformant bytes         */
             break;
           case 'C': case 'c':              /* UniversalString         */
             /* expect hexstring-encoded ied_chs_be_utf_32             */
             inl_iipl=4;
             break;
           case 'E': case 'e':              /* BMPString               */
             /* expect hexstring-encoded ied_chs_be_utf_16             */
             inl_iipl=2;
             break;
           default:            /* some ASN.1-type not implemented here */
             return HL_ERR_UCGETC_META;
         }
         break;
       default:                /* some ASN.1-type not implemented here */
         return HL_ERR_UCGETC_META;
     }
     /* get length as hexpair                                          */
     inl_d=*++achp_buf^0x30;
     if (inl_d>9) {
       inl_d=(*achp_buf|0x20)-87;
       if (inl_d<10||15<inl_d) return HL_ERR_UCGETC_INV;
       if (inl_d>7)                         /* multi-byte length       */
         return HL_ERR_UCGETC_META;  /* Lauenstein: do not implement yet */
     }
     inl_len=inl_d<<4;
     inl_d=*++achp_buf^0x30;
     if (inl_d>9) {
       inl_d=(*achp_buf|0x20)-87;
       if (inl_d<10||15<inl_d) return HL_ERR_UCGETC_INV;
     }
     inl_len|=inl_d;
     if (achp_end_buf-achp_buf < 2*inl_len)
       return HL_ERR_UCGETC_INPSH;
     if (inl_iipl) {                 /* two-step character translation */
       if(inl_len%inl_iipl)
         return HL_ERR_UCGETC_INV;          /* non-integer char count  */
       inl_len /= inl_iipl;
       inl_cirl = inl_iipl;
     } else {                        /* one-step character translation */
       inl_cirl = inl_len;
       inl_len=1;                   /* go only once through outer loop */
     }
     while (inl_len>0) {
       while (inl_cirl-- != 0) {            /* get hexpairs            */
         inl_d=*++achp_buf^0x30;
         if (inl_d>9) {
           inl_d=(*achp_buf|0x20)-87;
           if (inl_d<10||15<inl_d) return HL_ERR_UCGETC_INV;
         }
         *aucl_cur_target=inl_d<<4;
         inl_d=*++achp_buf^0x30;
         if (inl_d>9) {
           inl_d=(*achp_buf|0x20)-87;
           if (inl_d<10||15<inl_d) return HL_ERR_UCGETC_INV;
         }
         *aucl_cur_target++|=inl_d;
       }
       if (inl_iipl) {            /* character translation second step */
         inl_d = aucl_cur_target[-1] + (aucl_cur_target[-2]<<8);
         if(inl_iipl==4)
           inl_d += (aucl_cur_target[-3]<<16) + (aucl_cur_target[-4]<<24);
         /*UUU else we should check for surrogates */
         aucl_cur_target -= inl_iipl;
         if (inl_d<0x80) {
           *aucl_cur_target++ = inl_d;
         } else {
           int inl_usl=2;                   /* length of utf8 sequence */
           while ((unsigned)inl_d >> (inl_usl*5+1))
             inl_usl++;
           if ((unsigned char*)achp_buf-aucl_cur_target<inl_usl)
             return HL_ERR_UCGETC_META;  /* output overtakes input in buffer */
           *aucl_cur_target++ = (inl_d>>(6*--inl_usl)) - (0x100>>inl_d);
           do {
             *aucl_cur_target++ = ((inl_d>>(6*--inl_usl)) & 0x3F) | 0x80;
           } while (inl_usl>=0);
         }
         inl_cirl=inl_iipl;
       }
       inl_len--;
     }
     adsp_usc_rdn->imc_len_str = aucl_cur_target-(unsigned char*)adsp_usc_rdn->ac_str;
     if ((++ achp_buf == achp_end_buf) || (*achp_buf == '\0'))
       return achp_buf-(char*)adsp_usc_rdn->ac_str;
     if (*achp_buf == ',')
       return 1+achp_buf-(char*)adsp_usc_rdn->ac_str;
     if (*achp_buf == '+')
       goto p_pass_attrtype;
     return HL_ERR_UCGETC_INV;     /* unexpected stuff after hexstring */
   } /* end hexstring-part                                             */
   if (aucl_cur_target) {
     while (*achp_buf == ' ') {        /* skip leading unquoted blanks */
       ++ achp_buf;
       if (achp_buf==achp_end_buf || !*achp_buf) {  /* empty value     */
         MR4UM_RETURN_BOTH_LEN
       }
     }
     goto p_cease_simplekeep;
   }
   if (*achp_buf == ' ') {             /* skip leading unquoted blanks */
     aucl_cur_target = (unsigned char*)achp_buf;  /* achp_buf will leave target behind soon */
     do {
       ++ achp_buf;
       if (achp_buf==achp_end_buf || !*achp_buf) {  /* empty value     */
         MR4UM_RETURN_BOTH_LEN
       }
     } while (*achp_buf == ' ');
     MR4UM_CHECK_KEPT(aucl_cur_target)
     goto p_cease_simplekeep;
   }
   /* first try simply keeping the bytes, until an escaped one comes   */
   while (*achp_buf != '\\') {
     if ((*achp_buf&0xE0)==0x20 && ((1<<(*achp_buf-0x20)) & 0x58001804)) {
       switch (*achp_buf) {
         case '+':
           if (achp_buf[-1]==' ') {     /* skip trailing unquoted blanks */
             aucl_cur_target = (unsigned char*)achp_buf-1;
             while (aucl_cur_target[-1]==' ')
               aucl_cur_target--;
             MR4UM_CHECK_KEPT(aucl_cur_target)  /* validate utf8 from start */
           }
           goto p_pass_attrtype;
         case ',':
           aucl_cur_target = (unsigned char*)achp_buf;
           while (aucl_cur_target[-1]==' ')  /* remove trailing unquoted blanks */
             aucl_cur_target--;
           MR4UM_CHECK_KEPT(aucl_cur_target)  /* validate utf8 from start */
           achp_buf++;              /* next RDN will start after the ',' */
           MR4UM_RETURN_BOTH_LEN
         default:
           return HL_ERR_UCGETC_INV;        /* may not occur unescaped */
       }
     } else {
       if (*achp_buf) {
         ++ achp_buf;
         if (achp_buf!=achp_end_buf)
           break;
       }
     /* case '\0': */
       while (achp_buf[-1]==' ')  /* remove trailing unquoted blanks */
         achp_buf--;
       MR4UM_CHECK_KEPT(achp_buf)        /* validate utf8 from start */
       return adsp_usc_rdn->imc_len_str = achp_buf-(char*)adsp_usc_rdn->ac_str;
     }
   }
   achp_buf = (char*)adsp_usc_rdn->ac_str +  /* do not start parsing in the middle of a UTF8-sequence */
              m_count_with_mb( (char*)adsp_usc_rdn->ac_str, ied_chs_utf_8, achp_buf-(char*)adsp_usc_rdn->ac_str );
   aucl_cur_target = (unsigned char*)achp_buf;  /* achp_buf will leave target behind soon */
   MR4UM_CHECK_KEPT(achp_buf)
   p_cease_simplekeep:        /* we will have to move data from now on */
   do {
     int iml_len_ch_source = m_get_vc_ch( &uml_ch_source, achp_buf, achp_end_buf, ied_chs_ldap_escaped_utf_8 );
     if (iml_len_ch_source <= 0) {
       if (aucl_cur_target[-1]==' ' && achp_buf[-1]==' ' && achp_buf[-2]!='\\') {
         char* achl_oldsrc = achp_buf-1;
         do {                         /* skip trailing unquoted blanks */
           aucl_cur_target--;
           achl_oldsrc--;
         } while (aucl_cur_target[-1]==' ' && *achl_oldsrc==' ' && achl_oldsrc[-1]!='\\');
       }
       switch (iml_len_ch_source) {
         case HL_ERR_UCGETC_META:
           if (*achp_buf == '+') {       /* next attributeTypeAndValue */
             *aucl_cur_target++ = *achp_buf++;
             if (achp_buf >= achp_end_buf)
               return HL_ERR_UCGETC_INPSH;  /* new part not present    */
             goto p_pass_attrtype;
           }                        /* else it is a ',' ending the RDN */
           achp_buf++;            /* next RDN will start after the ',' */
           MR4UM_RETURN_BOTH_LEN
         case 0:                            /* end of DN input reached */
           MR4UM_RETURN_BOTH_LEN
         case HL_ERR_UCGETC_INV:
           if (!*achp_buf)
             {  /* terminating zero seen as error because end-argument */
             MR4UM_RETURN_BOTH_LEN
             }
           /* else fall through */
         default:                           /* error                   */
           return iml_len_ch_source;
       }
     } else {
       if (uml_ch_source>>7) {  /* reassemble UTF8 sequence without any byte escaped */
         int inl_bc = 11;
         *aucl_cur_target = 0xC0;
         while (uml_ch_source>>inl_bc) {
           *aucl_cur_target |= *aucl_cur_target>>1;
           inl_bc += 5;
         }
         inl_bc -= inl_bc%6;
         *aucl_cur_target++ |= uml_ch_source>>inl_bc;
         do {
           inl_bc -= 6;
           *aucl_cur_target++ = 0x80 | (0x3F & (uml_ch_source>>inl_bc));
         } while (inl_bc);
       } else {
         *aucl_cur_target++ = uml_ch_source;
         if (!uml_ch_source) {              /* end of DN input reached */
           MR4UM_RETURN_BOTH_LEN
         }
       }
       achp_buf += iml_len_ch_source;
     }
   } while (TRUE);
#undef MR4UM_RETURN_BOTH_LEN
#undef MR4UM_CHECK_KEPT
} /* end m_rfc4514unmask()                                             */

/** @addtogroup unicode
* @{
*/
/**
* Compute length of space needed for copying array content plus repeated
* separators to target encoding, in elements. If the encoding of the separator
* is the same as iep_cs_target, its length will be blindly used (not checking
* its content except, if necessary, running it through m_stor_vx to look for the
* terminating zero), to coincide with m_cpy_vx_ucsarray().
*  @param iep_cs_target encoding for the hypothetical output string
*  @param adsp_sep      separator string that would go between adjacent parts
*  @param inp_count     length of the array of input strings
*  @param dsrp_srcparts array of input strings
*  @return negative on error; else length in units of 8, 16 or 32 bits
*          (depending on iep_cs_target) that would be needed to concatenate the
*          contents of ap_source with the adsp_sep text between them, all
*          expressed in iep_cs_target, not including any space for termination.
*/
extern PTYPE int m_len_vx_ucsarray( enum ied_charset iep_cs_target,
                       const struct dsd_unicode_string *adsp_sep, int inp_count,
                       const struct dsd_unicode_string *dsrp_srcparts ) {
   int inl_res;                             /* result from subroutine  */
   int inl_len_return;                      /* total units used so far */

   if (inp_count<=0)
     return 0;
   inp_count --;
   if (inp_count) {
     if (adsp_sep->iec_chs_str == iep_cs_target) {
       if (adsp_sep->imc_len_str>=0) {
         inl_len_return = adsp_sep->imc_len_str;
       } else {                             /* get separator length    */
         inl_res = m_stor_vx( adsp_sep->ac_str, adsp_sep->imc_len_str, adsp_sep->iec_chs_str );
         if (inl_res<0) return inl_res;   /* subroutine reported error */
         inl_len_return = (inl_res-1) * m_cs_elem_size(adsp_sep->iec_chs_str);
       }
     } else {
       inl_len_return = m_len_vx_ucs( iep_cs_target, dsrp_srcparts+inp_count );
       if (inl_len_return<0) return inl_len_return;  /* subroutine reported error */
     }
     inl_len_return *= inp_count;
   } else {
     inl_len_return = 0;
   }
   do {
     inl_res = m_len_vx_ucs( iep_cs_target, dsrp_srcparts+inp_count );
     if (inl_res<0) return inl_res;       /* subroutine reported error */
     inl_len_return += inl_res;
     inp_count--;
   } while (inp_count>=0);
   return inl_len_return;
} /* end m_len_vx_ucsarray()                                           */

/**
* Puts the texts of array member strings together with separator text between
* them (similar to join() in Ruby, Perl and Javascript or implode() in PHP),
* transferring all into a common target encoding.
* If the encoding of the separator is the same as iep_cs_target, its content
* will be bytewise copied to the target without checking its validity. That way
* arbitrary data can be inserted as separator, so this function could e.g.
* translate the elements into HTML with unquoted "</TD><TD>" between them; or
* using ied_chs_ldap_escaped_utf_8 as target encoding and a "," as separator, it
* can assemble an array of RDNs (with no more than one attributeTypeAndValue
* each, as any '+' will be escaped, like every ' ' and '#' as well) to a DN with
* the separating commas unescaped; etc.
*  @param achp_target        destination (output) pointer
*  @param inp_max_len_target length of output buffer, in 8/16/32-bit units
*  @param iep_cs_target      encoding to use for output
*  @param adsp_sep           separator string to put between adjacent parts
*  @param int inp_count      length of the array of input strings
*  @param dsrp_srcparts      array of input strings
*  @return negative on error, else length of output (in 8/16/32-bit units
*                    depending on iep_cs_target), excluding the terminating zero
*/
extern PTYPE int m_cpy_vx_ucsarray( char *achp_target, int inp_max_len_target,
                       enum ied_charset iep_cs_target,
                       const struct dsd_unicode_string *adsp_sep, int inp_count,
                       const struct dsd_unicode_string *dsrp_srcparts ) {
   int inl_arrind;                          /* index for source array  */
   int inl_ttbyt = 0;          /* total bytes already filled in target */
   int inl_unitszsh;                   /* shift for unit size to bytes */
   void* al_sep_targcs;                /* separator in target encoding */
   int inl_sepbytes;           /* size of separator in target encoding */
   int inl_res;                             /* result from subroutine  */

   if (inp_count<=0)
     return 0;
   switch (iep_cs_target) {
     CASE_IED_CHS_U16_ALLENDIAN
     case ied_chs_xml_utf_16:
       inl_unitszsh = 1;
       break;
     CASE_IED_CHS_U32_ALLENDIAN
       inl_unitszsh = 2;
       break;
     default:
       inl_unitszsh = 0;
   }

   /* first element                                                    */
   inl_res = m_cpy_vx_ucs( achp_target, inp_max_len_target, iep_cs_target, dsrp_srcparts );
   if (inl_res<0) return inl_res;         /* subroutine reported error */
   if (--inp_count==0)      /* inp_count will be reduced by 1 from now */
     return inl_res;                    /* called with 1 element, done */
   inp_max_len_target -= inl_res;
   inl_ttbyt = inl_res<<inl_unitszsh;

   /* first separation                                                 */
   if (adsp_sep->iec_chs_str == iep_cs_target) {  /* get separator length for copy */
     al_sep_targcs = adsp_sep->ac_str;
     inl_sepbytes = m_stor_vx( al_sep_targcs, adsp_sep->imc_len_str, adsp_sep->iec_chs_str );
     if (adsp_sep->imc_len_str<0)  /* contains terminator we will not copy */
       inl_sepbytes -= 1<<inl_unitszsh;
     inp_max_len_target -= (inp_count*inl_sepbytes+(1<<inl_unitszsh)-1)
                           >> inl_unitszsh;  /* subtract in advance to check only once */
     if (inp_max_len_target<0) return -1;   /* too little output space */
     memcpy( achp_target+inl_ttbyt, al_sep_targcs, inl_sepbytes );  /* copy separator first time */
   } else {  /* translate separator once, later copy from first place in target */
     al_sep_targcs = achp_target+inl_ttbyt;
     inl_res = m_cpy_vx_ucs( al_sep_targcs, inp_max_len_target, iep_cs_target, adsp_sep );
     if (inl_res<0) return inl_res;       /* subroutine reported error */
     inl_sepbytes = inl_res << inl_unitszsh;
     inp_max_len_target -= inp_count*inl_res;  /* subtract in advance to check only once */
     if (inp_max_len_target<0) return -1;   /* too little output space */
   }
   inl_ttbyt += inl_sepbytes;

   /* loop for all following elements and separators                   */
   inl_arrind=1;
   while (TRUE) {
     inl_res = m_cpy_vx_ucs( achp_target+inl_ttbyt, inp_max_len_target, iep_cs_target, dsrp_srcparts+inl_arrind );
     if (inl_res<0) return inl_res;       /* subroutine reported error */
     inp_max_len_target -= inl_res;
     inl_ttbyt += inl_res<<inl_unitszsh;
     if (inl_arrind==inp_count)
       return inl_ttbyt>>inl_unitszsh;     /* regular exit point      */
     inl_arrind ++;
     memcpy( achp_target+inl_ttbyt, al_sep_targcs, inl_sepbytes );  /* copy separator */
     inl_ttbyt += inl_sepbytes;
   }
} /* end m_cpy_vx_ucsarray()                                           */

/**
* Processes a dsd_get_unicode_char-struct by converting one character.
* Note that UTF16-surrogates are supported for input, but not for output.
*  @param adsp_gunicch the struct with all necessary data
*/
extern PTYPE void m_get_unicode_char( struct dsd_get_unicode_char *adsp_gunicch ) {
   BOOL       bol1;                         /* working-variable        */
   int        iml_len_ch;                   /* length of parameter     */
   unsigned int uml_ch_source;              /* character retrieved     */

   adsp_gunicch->imc_len_out_bytes = 0;     /* length of output data in bytes */
   while (adsp_gunicch->achc_next_char == NULL) {  /* next character, set to NULL when first called */
     adsp_gunicch->achc_next_char = (char *) adsp_gunicch->adsc_unicode_string->ac_str;
     if (adsp_gunicch->adsc_unicode_string->imc_len_str < 0) {
       adsp_gunicch->achc_last_char = NULL;
       break;
     }
     switch (adsp_gunicch->adsc_unicode_string->iec_chs_str) {
       case ied_chs_ascii_850:              /* ASCII 850               */
       case ied_chs_ansi_819:               /* ANSI 819                */
       CASE_IED_CHS_MISCCODEPAGES
       CASE_IED_CHS_ALL_CJK
       CASE_IED_CHS_ISO8859_2TO16
       case ied_chs_utf_8:                  /* Unicode UTF-8           */
         adsp_gunicch->achc_last_char
           = ((char *) adsp_gunicch->adsc_unicode_string->ac_str)
               + adsp_gunicch->adsc_unicode_string->imc_len_str;
         break;
       CASE_IED_CHS_U16_ALLENDIAN
         adsp_gunicch->achc_last_char
           = ((char *) adsp_gunicch->adsc_unicode_string->ac_str)
               + adsp_gunicch->adsc_unicode_string->imc_len_str * sizeof(HL_WCHAR);
         break;
       CASE_IED_CHS_U32_ALLENDIAN
         adsp_gunicch->achc_last_char
           = ((char *) adsp_gunicch->adsc_unicode_string->ac_str)
               + adsp_gunicch->adsc_unicode_string->imc_len_str * sizeof(unsigned int);
         break;
       default:
         adsp_gunicch->boc_error = TRUE;    /* error occured           */
         return;                            /* cannot extract          */
     }
     break;
   }
   iml_len_ch = m_get_vc_ch( &uml_ch_source,
                             adsp_gunicch->achc_next_char,
                             adsp_gunicch->achc_last_char,
                             adsp_gunicch->adsc_unicode_string->iec_chs_str );
   if (iml_len_ch < 0) {                    /* reported error          */
     adsp_gunicch->boc_error = TRUE;        /* error occured           */
     return;                                /* cannot extract          */
   }
   if (iml_len_ch == 0) {                   /* reported eof            */
     adsp_gunicch->boc_eof = TRUE;          /* last unicode character retrieved */
     return;                                /* all done                */
   }
   adsp_gunicch->achc_next_char += iml_len_ch;  /* next character      */
   switch (adsp_gunicch->iec_chs_out) {     /* character set output    */
     case ied_chs_ascii_850:                /* ASCII 850               */
       if (uml_ch_source < 0X0100) {
         *((unsigned char *) adsp_gunicch->ac_out) = (unsigned char) ucrg_tab_819_to_850[ uml_ch_source ];
       } else {
         *((unsigned char *) adsp_gunicch->ac_out) = '?';
       }
       adsp_gunicch->imc_len_out_bytes = 1;  /* length of output data in bytes */
       break;
     case ied_chs_ansi_819:                 /* ANSI 819                */
       if (uml_ch_source < 0X0100) {
         *((unsigned char *) adsp_gunicch->ac_out) = (unsigned char) uml_ch_source;
       } else {
         *((unsigned char *) adsp_gunicch->ac_out) = '?';
       }
       adsp_gunicch->imc_len_out_bytes = 1; /* length of output data in bytes */
       break;
     case ied_chs_oem_437:                  /* DOS-Codepage 437        */
       *((unsigned char *) adsp_gunicch->ac_out) = (unsigned char) m_u32c_to_437( uml_ch_source );
       adsp_gunicch->imc_len_out_bytes = 1;  /* length of output data in bytes */
       break;
     case ied_chs_wcp_874:                  /* Windows-Codepage  874   */
       *((unsigned char *) adsp_gunicch->ac_out) = (unsigned char) m_u32c_to_874( uml_ch_source );
       adsp_gunicch->imc_len_out_bytes = 1;  /* length of output data in bytes */
       break;
     case ied_chs_wcp_1250:                 /* Windows-Codepage 1250   */
       *((unsigned char *) adsp_gunicch->ac_out) = (unsigned char) m_u32c_to_1250( uml_ch_source );
       adsp_gunicch->imc_len_out_bytes = 1;  /* length of output data in bytes */
       break;
     case ied_chs_wcp_1251:                 /* Windows-Codepage 1251   */
       *((unsigned char *) adsp_gunicch->ac_out) = (unsigned char) m_u32c_to_1251( uml_ch_source );
       adsp_gunicch->imc_len_out_bytes = 1;  /* length of output data in bytes */
       break;
     case ied_chs_wcp_1252:                 /* Windows-Codepage 1252   */
       *((unsigned char *) adsp_gunicch->ac_out) = (unsigned char) m_u32c_to_1252( uml_ch_source );
       adsp_gunicch->imc_len_out_bytes = 1;  /* length of output data in bytes */
       break;
     case ied_chs_wcp_1253:                 /* Windows-Codepage 1253   */
       *((unsigned char *) adsp_gunicch->ac_out) = (unsigned char) m_u32c_to_1253( uml_ch_source );
       adsp_gunicch->imc_len_out_bytes = 1;  /* length of output data in bytes */
       break;
     case ied_chs_wcp_1254:                 /* Windows-Codepage 1254   */
       *((unsigned char *) adsp_gunicch->ac_out) = (unsigned char) m_u32c_to_1254( uml_ch_source );
       adsp_gunicch->imc_len_out_bytes = 1;  /* length of output data in bytes */
       break;
     case ied_chs_wcp_1255:                 /* Windows-Codepage 1255   */
       *((unsigned char *) adsp_gunicch->ac_out) = (unsigned char) m_u32c_to_1255( uml_ch_source );
       adsp_gunicch->imc_len_out_bytes = 1;  /* length of output data in bytes */
       break;
     case ied_chs_wcp_1256:                 /* Windows-Codepage 1256   */
       *((unsigned char *) adsp_gunicch->ac_out) = (unsigned char) m_u32c_to_1256( uml_ch_source );
       adsp_gunicch->imc_len_out_bytes = 1;  /* length of output data in bytes */
       break;
     case ied_chs_wcp_1257:                 /* Windows-Codepage 1257   */
       *((unsigned char *) adsp_gunicch->ac_out) = (unsigned char) m_u32c_to_1257( uml_ch_source );
       adsp_gunicch->imc_len_out_bytes = 1;  /* length of output data in bytes */
       break;
     case ied_chs_wcp_1258:                 /* Windows-Codepage 1258   */
       *((unsigned char *) adsp_gunicch->ac_out) = (unsigned char) m_u32c_to_1258( uml_ch_source );
       adsp_gunicch->imc_len_out_bytes = 1;  /* length of output data in bytes */
       break;
     case ied_chs_iso8859_2:                /* ISO 8859-2              */
       *((unsigned char *) adsp_gunicch->ac_out) = (unsigned char) m_u32c_to_i02( uml_ch_source );
       adsp_gunicch->imc_len_out_bytes = 1;  /* length of output data in bytes */
       break;
     case ied_chs_iso8859_3:                /* ISO 8859-3              */
       *((unsigned char *) adsp_gunicch->ac_out) = (unsigned char) m_u32c_to_i03( uml_ch_source );
       adsp_gunicch->imc_len_out_bytes = 1;  /* length of output data in bytes */
       break;
     case ied_chs_iso8859_4:                /* ISO 8859-4              */
       *((unsigned char *) adsp_gunicch->ac_out) = (unsigned char) m_u32c_to_i04( uml_ch_source );
       adsp_gunicch->imc_len_out_bytes = 1;  /* length of output data in bytes */
       break;
     case ied_chs_iso8859_5:                /* ISO 8859-5              */
       *((unsigned char *) adsp_gunicch->ac_out) = (unsigned char) m_u32c_to_i05( uml_ch_source );
       adsp_gunicch->imc_len_out_bytes = 1;  /* length of output data in bytes */
       break;
     case ied_chs_iso8859_6:                /* ISO 8859-6              */
       *((unsigned char *) adsp_gunicch->ac_out) = (unsigned char) m_u32c_to_i06( uml_ch_source );
       adsp_gunicch->imc_len_out_bytes = 1;  /* length of output data in bytes */
       break;
     case ied_chs_iso8859_7:                /* ISO 8859-7              */
       *((unsigned char *) adsp_gunicch->ac_out) = (unsigned char) m_u32c_to_i07( uml_ch_source );
       adsp_gunicch->imc_len_out_bytes = 1;  /* length of output data in bytes */
       break;
     case ied_chs_iso8859_8:                /* ISO 8859-8              */
       *((unsigned char *) adsp_gunicch->ac_out) = (unsigned char) m_u32c_to_i08( uml_ch_source );
       adsp_gunicch->imc_len_out_bytes = 1;  /* length of output data in bytes */
       break;
     case ied_chs_iso8859_9:                /* ISO 8859-9              */
       *((unsigned char *) adsp_gunicch->ac_out) = (unsigned char) m_u32c_to_i09( uml_ch_source );
       adsp_gunicch->imc_len_out_bytes = 1;  /* length of output data in bytes */
       break;
     case ied_chs_iso8859_10:               /* ISO 8859-10             */
       *((unsigned char *) adsp_gunicch->ac_out) = (unsigned char) m_u32c_to_i10( uml_ch_source );
       adsp_gunicch->imc_len_out_bytes = 1;  /* length of output data in bytes */
       break;
     case ied_chs_iso8859_11:               /* ISO 8859-11             */
       *((unsigned char *) adsp_gunicch->ac_out) = (unsigned char) m_u32c_to_i11( uml_ch_source );
       adsp_gunicch->imc_len_out_bytes = 1;  /* length of output data in bytes */
       break;
     case ied_chs_iso8859_13:               /* ISO 8859-13             */
       *((unsigned char *) adsp_gunicch->ac_out) = (unsigned char) m_u32c_to_i13( uml_ch_source );
       adsp_gunicch->imc_len_out_bytes = 1;  /* length of output data in bytes */
       break;
     case ied_chs_iso8859_14:               /* ISO 8859-14             */
       *((unsigned char *) adsp_gunicch->ac_out) = (unsigned char) m_u32c_to_i14( uml_ch_source );
       adsp_gunicch->imc_len_out_bytes = 1;  /* length of output data in bytes */
       break;
     case ied_chs_iso8859_15:               /* ISO 8859-15             */
       *((unsigned char *) adsp_gunicch->ac_out) = (unsigned char) m_u32c_to_i15( uml_ch_source );
       adsp_gunicch->imc_len_out_bytes = 1;  /* length of output data in bytes */
       break;
     case ied_chs_iso8859_16:               /* ISO 8859-16             */
       *((unsigned char *) adsp_gunicch->ac_out) = (unsigned char) m_u32c_to_i16( uml_ch_source );
       adsp_gunicch->imc_len_out_bytes = 1;  /* length of output data in bytes */
       break;
     CASE_IED_CHS_ALL_CJK
       if (uml_ch_source >= 0x10000) {
         *((unsigned char *) adsp_gunicch->ac_out) = '?';
         adsp_gunicch->imc_len_out_bytes = 1;  /* length of output data in bytes */
         break;
       }
       uml_ch_source = m_get_tab_uni_to_mb(adsp_gunicch->iec_chs_out)[uml_ch_source];
       if (uml_ch_source & 0xFF00) {
         *((unsigned char *) adsp_gunicch->ac_out + 0) = (unsigned char)(uml_ch_source>>8);
         *((unsigned char *) adsp_gunicch->ac_out + 1) = (unsigned char)uml_ch_source;
         adsp_gunicch->imc_len_out_bytes = 2;  /* length of output data in bytes */
       } else {
         *((unsigned char *) adsp_gunicch->ac_out) = (unsigned char)uml_ch_source;
         adsp_gunicch->imc_len_out_bytes = 1;  /* length of output data in bytes */
       }
       break;
     case ied_chs_utf_8:                    /* Unicode UTF-8           */
       if ((uml_ch_source != 0) && (uml_ch_source < 0X80)) {  /* not zero or 0X80 (Why not zero? This way it encodes U+0000 with a superfluous extra byte WS 8.12.2011) */
         *((unsigned char *) adsp_gunicch->ac_out) = (unsigned char) uml_ch_source;
         adsp_gunicch->imc_len_out_bytes = 1;  /* length of output data in bytes */
         break;
       }
       if (uml_ch_source < 0X0800) {
         *((unsigned char *) adsp_gunicch->ac_out + 0) = 0XC0 | (uml_ch_source >> 6);
         *((unsigned char *) adsp_gunicch->ac_out + 1) = 0X80 | (uml_ch_source & 0X3F);
         adsp_gunicch->imc_len_out_bytes = 2;  /* length of output data in bytes */
         break;
       }
       *((unsigned char *) adsp_gunicch->ac_out + 0) = 0XE0 | (uml_ch_source >> 12);
       *((unsigned char *) adsp_gunicch->ac_out + 1) = (0X80 | ((uml_ch_source >> 6) & 0X3F));
       *((unsigned char *) adsp_gunicch->ac_out + 2) = (0X80 | (uml_ch_source & 0X3F));
       adsp_gunicch->imc_len_out_bytes = 3;  /* length of output data in bytes */
       break;
     case ied_chs_html_1:                   /* HTML character set      */
       bol1 = FALSE;                        /* character not copied    */
       if (uml_ch_source < 0X80) {          /* may be a single character */
         switch (uml_ch_source) {           /* check special values    */
           case 0X22:                       /* chrs_html_quote         */
             break;                         /* set in string           */
           case 0X26:                       /* chrs_html_amp           */
             break;                         /* set in string           */
           case 0X3C:                       /* chrs_html_lt            */
             break;                         /* set in string           */
           case 0X3E:                       /* chrs_html_gt            */
             break;                         /* set in string           */
           default:
             *((unsigned char *) adsp_gunicch->ac_out) = (unsigned char) uml_ch_source;
             adsp_gunicch->imc_len_out_bytes = 1;  /* length of output data in bytes */
             bol1 = TRUE;                   /* character has been copied */
             break;
         }
       }
       if (bol1) break;                     /* all done                */
       adsp_gunicch->imc_len_out_bytes
         = m_put_html_1_a( (char *) adsp_gunicch->ac_out, (char *) adsp_gunicch->ac_out + 16, uml_ch_source );
       break;                               /* all done                */
     case ied_chs_uri_1:  /* UUU ?? */      /* URI RFC 3986            YYY??; */
     case ied_chs_utf_16:                   /* Unicode UTF-16 = WCHAR  */
       *((HL_WCHAR *) adsp_gunicch->ac_out) = (HL_WCHAR) uml_ch_source;
       adsp_gunicch->imc_len_out_bytes = sizeof(HL_WCHAR);  /* length of output data in bytes */
       break;
     case ied_chs_be_utf_16:                /* Unicode UTF-16 big endian */
       *((unsigned char *) adsp_gunicch->ac_out + 0) = (unsigned char) (uml_ch_source >> 8);
       *((unsigned char *) adsp_gunicch->ac_out + 1) = (unsigned char) uml_ch_source;
       adsp_gunicch->imc_len_out_bytes = sizeof(HL_WCHAR);  /* length of output data in bytes */
       break;
     case ied_chs_le_utf_16:                /* Unicode UTF-16 little endian */
       *((unsigned char *) adsp_gunicch->ac_out + 0) = (unsigned char) uml_ch_source;
       *((unsigned char *) adsp_gunicch->ac_out + 1) = (unsigned char) (uml_ch_source >> 8);
       adsp_gunicch->imc_len_out_bytes = sizeof(HL_WCHAR);  /* length of output data in bytes */
       break;
     case ied_chs_utf_32:                   /* Unicode UTF-32          */
       *((unsigned int *) adsp_gunicch->ac_out) = (unsigned int) uml_ch_source;
       adsp_gunicch->imc_len_out_bytes = sizeof(unsigned int);  /* length of output data in bytes */
       break;
     case ied_chs_be_utf_32:                /* Unicode UTF-32 big endian */
       *((unsigned char *) adsp_gunicch->ac_out + 0) = (unsigned char) (uml_ch_source >> 24);
       *((unsigned char *) adsp_gunicch->ac_out + 1) = (unsigned char) (uml_ch_source >> 16);
       *((unsigned char *) adsp_gunicch->ac_out + 2) = (unsigned char) (uml_ch_source >> 8);
       *((unsigned char *) adsp_gunicch->ac_out + 3) = (unsigned char) uml_ch_source;
       adsp_gunicch->imc_len_out_bytes = sizeof(unsigned int);  /* length of output data in bytes */
       break;
     case ied_chs_le_utf_32:                /* Unicode UTF-32 little endian */
       *((unsigned char *) adsp_gunicch->ac_out + 0) = (unsigned char) uml_ch_source;
       *((unsigned char *) adsp_gunicch->ac_out + 1) = (unsigned char) (uml_ch_source >> 8);
       *((unsigned char *) adsp_gunicch->ac_out + 2) = (unsigned char) (uml_ch_source >> 16);
       *((unsigned char *) adsp_gunicch->ac_out + 3) = (unsigned char) (uml_ch_source >> 24);
       adsp_gunicch->imc_len_out_bytes = sizeof(unsigned int);  /* length of output data in bytes */
       break;
     default:
       adsp_gunicch->boc_error = TRUE;      /* error occured           */
   }
} /* end m_get_unicode_char()                                          */

/**
* Gets the length in bytes of a string before either a zerobyte or a given
* maximum length is reached.
*  @param achp_arg the string
*  @param ulp_precision the maximum at which the counting has to stop
*  @return the bytecount
*/
static int m_strlen_upto_precision( const char* achp_arg, int ulp_precision ) {
  const char *achl_tmp = (const char *) memchr(achp_arg, '\0',
  ulp_precision <= 0x7fffffff ? ulp_precision : 0x7fffffff);
  return !achl_tmp ? ulp_precision : (achl_tmp-achp_arg);
}

/**
* write formatted output using a pointer with a list of arguments
*  @param achp_target pointer to output buffer
*  @param imp_max_len_target maximum number of bytes to write,
*                                              including terminating zero
*  @param iep_cs_target charset for output (if 16-bit, just calls m_hlvsnwprintf
*                       and returns count of 16-bit units written)
*  @param achp_format formatspecification, in the style of printf() etc.
*  @param dsp_list pointer to list of arguments
*  @return the number of bytes written, excluding the terminating zero,
*          or -1 on unsupported encoding
*/
extern PTYPE int m_hlvsnprintf( void *achp_target, int imp_max_len_target,
                              enum ied_charset iep_cs_target,
                              const char *achp_format, va_list dsp_list ) {
   char             *achl_cur;                 /* current position        */
   char             *achl_end;                 /* maximum output position */
   const char       *achl_format;
   const char       *achl_arg = NULL;          /* string address in case of string argument */
   struct dsd_unicode_string *adsl_arginfs;    /* contains string argument for %(ucs)s format */
   unsigned char    uchl_arg;                  /* only defined for c conversion */
   char             chrl_tmp[256];             /* temporary buffer for numeric->string conversion */
   char             chrl_arg_temp[MAX_STR_LENGTH];
   char             *achl_arg_temp;
   enum ied_charset iel_cs_target;
   va_list          dsl_list;
   bool             bol_adjustleft;
   const char       *achl_signed;
   bool             bol_precision;
   bool             bol_padding_zero;
   bool             bol_alternate_form;
   bool             bol_dot_period;
   bool             bol_longlong;
   size_t           ull_field_width;
   size_t           ull_precision;
   size_t           ull_bitwidth;
   char             chl_length_modifier;
   enum ied_charset iel_cs_source;              /* format of current giving string */
   size_t           ull_utftype;                /* Unicode format of giving string */
   size_t           ull_str_arg_l;              /* string length            */
   bool             bol_str_arg_l_known;
   char             *achl_arg_u8;
   HL_WCHAR         *achl_arg_u16;
   int              *ainl_arg_u32;
   int              iml_str_len;                /* string length for HL_WCHAR or UTF32 */
   int              iml_arg;
   char             chl_spec = '\0';            /* current conversion specifier character */
   unsigned int     *aunl_back_ti=NULL;         /* index table for first step of singlebyte-from-unicode conversion */
   unsigned char    *aucl_back_tt=NULL;         /* partitioned table for singlebyte-from-unicode conversion */
   char (*am_backtrans)(unsigned int, const unsigned int*, const unsigned char*)=NULL;  /* function for singlebyte-from-unicode conversion */
   HL_WCHAR         *awcl_back_t=NULL;          /* table for 1-or-2-byte-from-unicode conversion */
   enum { ied_scaling_none=0, ied_scaling_1000, ied_scaling_1024 } iel_scaling;  /* k/M/G ... */
   const char       *achl_dgsp;                 /* digits-separator    */
   int              inl_dgsp_lb;                /* length of digits-separator in original bytes */
   int              inl_dgsp_lc;                /* length of digits-separator in characters */

   achl_format = achp_format;
   iel_cs_target = m_suppress_endian_info_if_native(iep_cs_target);
#if defined HL_UNIX && !defined HL_HPUX
   va_copy(dsl_list, dsp_list);
#else
   dsl_list = dsp_list;
#endif
   switch( iel_cs_target ) {
     case ied_chs_ascii_850:                /* ASCII 850               */
     case ied_chs_ansi_819:                 /* ANSI 819                */
     case ied_chs_utf_8:                    /* Unicode UTF-8           */
       break;                               /* argument is valid       */
     case ied_chs_oem_437:                  /* DOS-Codepage 437        */
       aucl_back_tt = ucrg_tabparts_uni_to_437;
       aunl_back_ti = unrg_tabindex_uni_to_437;
       am_backtrans = m_u32c_to_sb_5step;
       break;                               /* argument is valid       */
     case ied_chs_wcp_874:                  /* Windows-Codepage  874   */
       aucl_back_tt = ucrg_tabparts_uni_to_874;
       aunl_back_ti = unrg_tabindex_uni_to_874;
       am_backtrans = m_u32c_to_sb_3step;
       break;                               /* argument is valid       */
     case ied_chs_wcp_1250:                 /* Windows-Codepage 1250   */
       aucl_back_tt = ucrg_tabparts_uni_to_1250;
       aunl_back_ti = unrg_tabindex_uni_to_1250;
       am_backtrans = m_u32c_to_sb_4step;
       break;                               /* argument is valid       */
     case ied_chs_wcp_1251:                 /* Windows-Codepage 1251   */
       aucl_back_tt = ucrg_tabparts_uni_to_1251;
       aunl_back_ti = unrg_tabindex_uni_to_1251;
       am_backtrans = m_u32c_to_sb_3step;
       break;                               /* argument is valid       */
     case ied_chs_wcp_1252:                 /* Windows-Codepage 1252   */
       aucl_back_tt = ucrg_tabparts_uni_to_1252;
       aunl_back_ti = unrg_tabindex_uni_to_1252;
       am_backtrans = m_u32c_to_sb_4step;
       break;                               /* argument is valid       */
     case ied_chs_wcp_1253:                 /* Windows-Codepage 1253   */
       aucl_back_tt = ucrg_tabparts_uni_to_1253;
       aunl_back_ti = unrg_tabindex_uni_to_1253;
       am_backtrans = m_u32c_to_sb_3step;
       break;                               /* argument is valid       */
     case ied_chs_wcp_1254:                 /* Windows-Codepage 1254   */
       aucl_back_tt = ucrg_tabparts_uni_to_1254;
       aunl_back_ti = unrg_tabindex_uni_to_1254;
       am_backtrans = m_u32c_to_sb_4step;
       break;                               /* argument is valid       */
     case ied_chs_wcp_1255:                 /* Windows-Codepage 1255   */
       aucl_back_tt = ucrg_tabparts_uni_to_1255;
       aunl_back_ti = unrg_tabindex_uni_to_1255;
       am_backtrans = m_u32c_to_sb_4step;
       break;                               /* argument is valid       */
     case ied_chs_wcp_1256:                 /* Windows-Codepage 1256   */
       aucl_back_tt = ucrg_tabparts_uni_to_1256;
       aunl_back_ti = unrg_tabindex_uni_to_1256;
       am_backtrans = m_u32c_to_sb_4step;
       break;                               /* argument is valid       */
     case ied_chs_wcp_1257:                 /* Windows-Codepage 1257   */
       aucl_back_tt = ucrg_tabparts_uni_to_1257;
       aunl_back_ti = unrg_tabindex_uni_to_1257;
       am_backtrans = m_u32c_to_sb_4step;
       break;                               /* argument is valid       */
     case ied_chs_wcp_1258:                 /* Windows-Codepage 1258   */
       aucl_back_tt = ucrg_tabparts_uni_to_1258;
       aunl_back_ti = unrg_tabindex_uni_to_1258;
       am_backtrans = m_u32c_to_sb_4step;
       break;                               /* argument is valid       */
     case ied_chs_iso8859_2:                /* ISO 8859-2              */
       aucl_back_tt = ucrg_tabparts_uni_to_i02;
       aunl_back_ti = unrg_tabindex_uni_to_i02;
       am_backtrans = m_u32c_to_sb_3step;
       break;                               /* argument is valid       */
     case ied_chs_iso8859_3:                /* ISO 8859-3              */
       aucl_back_tt = ucrg_tabparts_uni_to_i03;
       aunl_back_ti = unrg_tabindex_uni_to_i03;
       am_backtrans = m_u32c_to_sb_3step;
       break;                               /* argument is valid       */
     case ied_chs_iso8859_4:                /* ISO 8859-4              */
       aucl_back_tt = ucrg_tabparts_uni_to_i04;
       aunl_back_ti = unrg_tabindex_uni_to_i04;
       am_backtrans = m_u32c_to_sb_3step;
       break;                               /* argument is valid       */
     case ied_chs_iso8859_5:                /* ISO 8859-5              */
       aucl_back_tt = ucrg_tabparts_uni_to_i05;
       aunl_back_ti = unrg_tabindex_uni_to_i05;
       am_backtrans = m_u32c_to_sb_2or3step;
       break;                               /* argument is valid       */
     case ied_chs_iso8859_6:                /* ISO 8859-6              */
       aucl_back_tt = ucrg_tabparts_uni_to_i06;
       aunl_back_ti = unrg_tabindex_uni_to_i06;
       am_backtrans = m_u32c_to_sb_2or3step;
       break;                               /* argument is valid       */
     case ied_chs_iso8859_7:                /* ISO 8859-7              */
       aucl_back_tt = ucrg_tabparts_uni_to_i07;
       aunl_back_ti = unrg_tabindex_uni_to_i07;
       am_backtrans = m_u32c_to_sb_2or3step;
       break;                               /* argument is valid       */
     case ied_chs_iso8859_8:                /* ISO 8859-8              */
       aucl_back_tt = ucrg_tabparts_uni_to_i08;
       aunl_back_ti = unrg_tabindex_uni_to_i08;
       am_backtrans = m_u32c_to_sb_2or3step;
       break;                               /* argument is valid       */
     case ied_chs_iso8859_9:                /* ISO 8859-9              */
       aucl_back_tt = ucrg_tabparts_uni_to_i09;
       aunl_back_ti = unrg_tabindex_uni_to_i09;
       am_backtrans = m_u32c_to_sb_2or3step;
       break;                               /* argument is valid       */
     case ied_chs_iso8859_10:               /* ISO 8859-10             */
       aucl_back_tt = ucrg_tabparts_uni_to_i10;
       aunl_back_ti = unrg_tabindex_uni_to_i10;
       am_backtrans = m_u32c_to_sb_3step;
       break;                               /* argument is valid       */
     case ied_chs_iso8859_11:               /* ISO 8859-11             */
       aucl_back_tt = ucrg_tabparts_uni_to_i11;
       aunl_back_ti = unrg_tabindex_uni_to_i11;
       am_backtrans = m_u32c_to_sb_2or3step;
       break;                               /* argument is valid       */
     case ied_chs_iso8859_13:               /* ISO 8859-13             */
       aucl_back_tt = ucrg_tabparts_uni_to_i13;
       aunl_back_ti = unrg_tabindex_uni_to_i13;
       am_backtrans = m_u32c_to_sb_3step;
       break;                               /* argument is valid       */
     case ied_chs_iso8859_14:               /* ISO 8859-14             */
       aucl_back_tt = ucrg_tabparts_uni_to_i14;
       aunl_back_ti = unrg_tabindex_uni_to_i14;
       am_backtrans = m_u32c_to_sb_3or4step;
       break;                               /* argument is valid       */
     case ied_chs_iso8859_15:               /* ISO 8859-15             */
       aucl_back_tt = ucrg_tabparts_uni_to_i15;
       aunl_back_ti = unrg_tabindex_uni_to_i15;
       am_backtrans = m_u32c_to_sb_2or3step;
       break;                               /* argument is valid       */
     case ied_chs_iso8859_16:               /* ISO 8859-16             */
       aucl_back_tt = ucrg_tabparts_uni_to_i16;
       aunl_back_ti = unrg_tabindex_uni_to_i16;
       am_backtrans = m_u32c_to_sb_3or4step;
       break;                               /* argument is valid       */
     CASE_IED_CHS_ALL_CJK
       awcl_back_t = m_get_tab_uni_to_mb(iel_cs_target);
       break;                               /* argument is valid       */
     CASE_IED_CHS_U16_ALLENDIAN
       return m_hlvsnwprintf( achp_target, imp_max_len_target, iep_cs_target,
                            achp_format, dsp_list );  /* use the other */
     default:
       return -1;                           /* not implemented         */
   }

   achl_arg_temp = chrl_arg_temp;

#define achl_target ((char *) achp_target)

   achl_cur = achl_target;                  /* start here              */
   achl_end = achl_target + imp_max_len_target - 1;  /* maximum output before terminating NUL */
   if (!achl_format) {                      /* achl_target can be NULL and buffer_length can be 0(ISO c99 says) */
     achl_format = "";
   }
   while (achl_cur < achl_end && *achl_format) {
     if (*achl_format != '%' || (*achl_format == '%' && *(achl_format+1) == '%' )) {
       const char *achp_normal = NULL;
       if(*achl_format == '%' ){
         achp_normal =  strchr(achl_format+2, '%');
         achl_format++; /* skip '%'                */
       } else {
         achp_normal = strchr(achl_format+1, '%');
       }
       size_t ui_n = !achp_normal ? strlen(achl_format) : (achp_normal-achl_format);
       switch( iel_cs_target) {
         case ied_chs_ascii_850:
           achl_cur += m_a850l_from_u8l( achl_cur, 1+achl_end-achl_cur, (char *) achl_format, ui_n );
           achl_format += ui_n;
           break;
         case ied_chs_ansi_819:
           achl_cur += m_a819l_from_u8l( achl_cur, 1+achl_end-achl_cur, (char *) achl_format, ui_n );
           achl_format += ui_n;
           break;
         CASE_IED_CHS_MISCCODEPAGES
         CASE_IED_CHS_ISO8859_2TO16
           achl_cur += m_sbcl_from_u8l( achl_cur, 1+achl_end-achl_cur, iel_cs_target, (char *) achl_format, ui_n );
           achl_format += ui_n;
           break;
         CASE_IED_CHS_ALL_CJK {
           BOOL bol_hit_end;
           achl_cur += m_mbcl_from_u8l( achl_cur, 1+achl_end-achl_cur, awcl_back_t, (char *) achl_format, ui_n, &bol_hit_end );
           if( bol_hit_end )
             achl_end = achl_cur;            /* to break the big loop   */
           achl_format += ui_n;
         } break;
         case ied_chs_utf_8:
           while( ui_n-- > 0 ) {
             if( achl_cur >= achl_end ) {
               if( (*achl_format & 0xC0) == 0x80 ) { /* stopped within a character sequence */
                 while( (*(--achl_cur) & 0xC0) == 0x80 )
                   ;
                 achl_end = achl_cur;        /* to break the big loop   */
               }
               break;
             }
             *achl_cur++ = *achl_format++;
           }
           break;
         default:
           break;
       }
     } else {
       bol_adjustleft = false;
       achl_signed = "-\0\0\0";
       bol_precision = false;
       bol_padding_zero = false;
       bol_alternate_form = false;
       bol_dot_period = false;
       bol_longlong = false;
       ull_field_width = 0;
       ull_precision = 0;
       ull_bitwidth = 0;
       chl_length_modifier = '\0';
       iel_scaling = ied_scaling_none;
       adsl_arginfs = NULL;
       achl_dgsp = NULL;
       inl_dgsp_lc = 0;
       ull_utftype = 0;
       iel_cs_source = ied_chs_ansi_819;
       achl_format++;                       /* skip '%'                */

       /* parse flags */
       while (umrs_format[(UINT) *achl_format] == 1) { /* - + 0 # \' . ( *    */
         if (isdigit((int) *achl_format)) {
           if (bol_padding_zero == false && *achl_format == '0' && !ull_field_width  ) {
             bol_padding_zero = true;
           }
           else if (ull_field_width == 0) {
             ull_field_width = *achl_format++ - '0';
           } else {
             while (isdigit((int) *achl_format)) {
               ull_field_width = 10 * ull_field_width + (unsigned int) (*achl_format++ - '0');
             }
           }
         }
         switch (*achl_format++) {
           case '-':
             bol_adjustleft = true;
             break;
           case '+':
             achl_signed = "-++";
             break;
           case '#':
             bol_alternate_form = true;
             break;
           case ' ':
             achl_signed = "-  ";
             break;
           case '\'':
             break;
           case '.':
             bol_dot_period = true;
             bol_precision = true;
             if (*achl_format == '*') {
               iml_arg = va_arg(dsl_list, int);
               if (iml_arg >= 0)
                 ull_precision = iml_arg;
               else {
                 ull_precision = 0;
                 bol_precision = false;
               }
               achl_format++;
             } else if (isdigit((int)(*achl_format))) {
               /* size_t could be wider than unsigned int;                     */
               /* make sure we treat argument like common implementations do   */
               unsigned int uml_digit;
               uml_digit = *achl_format++ - '0';
               while( isdigit((int) *achl_format) ) {
                 uml_digit = 10 * uml_digit + (unsigned int) (*achl_format++ - '0');
               }
               ull_precision =  uml_digit;
             } else {
               while( *achl_format){
                 if( *achl_format != '%' && achl_cur < achl_end ) {
                 *achl_cur++ = *achl_format++;
                 } else {
                   break;
                 }
               }
             }
             break;
           case '(':
             switch (*achl_format) {
               case 'u':
               case 'U': {
                 achl_format++;
                 if(isdigit((int)(*achl_format))) {
                   /* size_t could be wider than unsigned int;                   */
                   /* make sure we treat argument like common implementations do */
                   unsigned int uml_utfdigit = *achl_format++ - '0';
                   while (isdigit((int)(*achl_format)))
                     uml_utfdigit = 10*uml_utfdigit + (unsigned int)(*achl_format++ - '0');
                   ull_utftype = uml_utfdigit;
                 }
                 else if ( *achl_format == 's') {
#if defined(WIN32)|| defined(WIN64)
                   ull_utftype = 16;
#elif defined(HL_UNIX)
                   ull_utftype = 32;
#endif
                   achl_format++;
                 }
                 else if ( *achl_format == 'x') {
#if defined(XCERCES32)                    /* set 32 bit unicode for Xerces   */
                   ull_utftype = 32;
#else
                   ull_utftype = 16;
#endif
                   achl_format++;
                 }
                 else if ( (*achl_format == 'c') && (*(achl_format+1) == 's') ) {
                   adsl_arginfs = va_arg(dsl_list, struct dsd_unicode_string *);
                   achl_format+=2;
                 }
                 else {
                   printf("Error: unknown conversion specification");
                 }
                 switch( ull_utftype ) {
                   case 8:
                     iel_cs_source = ied_chs_utf_8;
                     break;
                   case 16:
                     switch (*achl_format) {
                       case 'l': case 'L':
                         iel_cs_source = m_suppress_endian_info_if_native(ied_chs_le_utf_16); break;
                       case 'b': case 'B':
                         iel_cs_source = m_suppress_endian_info_if_native(ied_chs_be_utf_16); break;
                       default:
                         iel_cs_source = ied_chs_utf_16; break;
                     }
                     break;
                   case 32:
                     switch (*achl_format) {
                       case 'l': case 'L':
                         iel_cs_source = m_suppress_endian_info_if_native(ied_chs_le_utf_32); break;
                       case 'b': case 'B':
                         iel_cs_source = m_suppress_endian_info_if_native(ied_chs_be_utf_32); break;
                       default:
                         iel_cs_source = ied_chs_utf_32; break;
                     }
                     break;
                   default:
                     if( adsl_arginfs ) {
                       //iel_cs_source = adsl_arginfs->iec_chs_str;  /* correct, but not used */
                     } else {
                       iel_cs_source = ied_chs_invalid;
                     }
                     break;
                 }
               } break;
               case '.':
                 if (*(achl_format+1) == '*') {
                   achl_format+=2;
                   iel_cs_source = (enum ied_charset)va_arg(dsl_list, int);
                   switch( iel_cs_source ) {
                     case ied_chs_ascii_850:   /* ASCII 850            */
                     case ied_chs_ansi_819:    /* ANSI 819             */
                     CASE_IED_CHS_MISCCODEPAGES
                     /*? case ied_chs_html_1:   * HTML character set   */
                     CASE_IED_CHS_ALL_CJK
                     CASE_IED_CHS_ISO8859_2TO16
                       // ull_utftype = 0;
                       break;
                     case ied_chs_utf_8:        /* Unicode UTF-8           */
                       ull_utftype = 8;
                       break;
                     CASE_IED_CHS_U16_ALLENDIAN
                       ull_utftype = 16;
                       iel_cs_source = m_suppress_endian_info_if_native(iel_cs_source);
                       break;
                     CASE_IED_CHS_U32_ALLENDIAN
                       ull_utftype = 32;
                       iel_cs_source = m_suppress_endian_info_if_native(iel_cs_source);
                       break;
                     default:
                       iel_cs_source = ied_chs_invalid;
                       break;
                   }
                 }
                 break;
               case 'd':
                 if(!strncmp(achl_format+1,"ec1",3)) {
                   inl_dgsp_lc = 0;
                   achl_format += 4;
                   achl_dgsp = achl_format;
                   inl_dgsp_lb=0;           /* temporarly used for UTF8-check */
                   while (*achl_format && *achl_format!=')') {  /* UTF8-check */
                     if (*((signed char*)(achl_format)) < 0) {  /* MSB set */
                       if (((*achl_format&0x40)!=0) != (inl_dgsp_lb==0)) {
                         do ++achl_format;  /* UTF8-error              */
                           while (*achl_format && *achl_format!=')');
                         achl_dgsp=achl_format;  /* use the default    */
                         break;
                       }
                       if (inl_dgsp_lb) {   /* within sequence, 10...  */
                         inl_dgsp_lb--;
                       } else {             /* sequence start, 11...   */
                         inl_dgsp_lb = chrs_trail_u8l[(unsigned char)*achl_format];
                         inl_dgsp_lc ++;
                       }
                     } else {               /* in ASCII-range          */
                       if (inl_dgsp_lb) {   /* UTF8-error              */
                         do ++achl_format;
                           while (*achl_format && *achl_format!=')');
                         achl_dgsp=achl_format;  /* use the default    */
                         break;
                       }
                       inl_dgsp_lc ++;
                     }
                     achl_format++;
                   }
                   if (achl_format==achl_dgsp) {
                     achl_dgsp = "'";       /* default of thousands-separator */
                     inl_dgsp_lc = 1;       /* length 1 char           */
                     inl_dgsp_lb = 1;       /* length 1 Byte in UTF8   */
                   } else {
                     inl_dgsp_lb = achl_format-achl_dgsp;  /* length in Byte */
                   }
                 }
                 break;
               case 's':
                 if(!strncmp(achl_format+1,"ci-d",4)) {
                   if(!strncmp(achl_format+5,"ata",3)) {
                     iel_scaling = ied_scaling_1024;
                     achl_format += 8;
                   } else if(!strncmp(achl_format+5,"ec",2)) {
                     iel_scaling = ied_scaling_1000;
                     achl_format += 7;
                   }
                 }
                 break;
               default:
                 break;
             }
             while (*achl_format) {
               if (*achl_format==')') {
                 achl_format++;             /* skip ')'                */
                 break;                     /* regular loop exit       */
               }
               achl_format++;
             }
             break;                         /* end of case '('         */
           case '*':                        /* field width by argument */
             if (!bol_dot_period) {
               iml_arg = va_arg(dsl_list, int);
               if (iml_arg >= 0)
                 ull_field_width = iml_arg;
               else {
                 ull_field_width = -iml_arg;
                 bol_adjustleft = true;
               }
             }
             break;
           default:
             achl_format--;
             break;
         }
        if(*achl_format == '%') break;

       }

      /*parse field width */
       if( *achl_format == '*') {
         iml_arg = va_arg(dsl_list, int);
         if( iml_arg >= 0)
           ull_field_width = iml_arg;
         else {
           ull_field_width = -iml_arg;
           bol_adjustleft = true;
         }
         achl_format++;
       }

       /* parse 'h', 'l', 'L' and 'I'<number> length modifier */
       if( umrs_format[(UINT) *achl_format] == 2 ) { /* h l L I */
         if (*achl_format == 'I')
         {
           ++achl_format;
           while (isdigit((int) *achl_format)) {
             ull_bitwidth = 10 * ull_bitwidth + (unsigned int) (*achl_format++ - '0');
           }
           if (ull_bitwidth == sizeof(long long int)<<3) {
             chl_length_modifier = 'L';
             bol_longlong = true;
           } else if (ull_bitwidth == sizeof(long int)<<3) {
             chl_length_modifier = 'l';
           } else if (ull_bitwidth == sizeof(int)<<3) {
             chl_length_modifier = '\0';
           } else if (ull_bitwidth == sizeof(short)<<3) {
             chl_length_modifier = 'h';
           } else {
             printf("Error: unsupported 'I' width specification %d", (int)ull_bitwidth);
           }
         }
         else
         {
           chl_length_modifier = *achl_format;
           if(((*achl_format == 'l') || (*achl_format == 'L'))
             && ((*(achl_format+1) == 'l') ||(*(achl_format+1) == 'L'))){
             bol_longlong = true;
             achl_format++;
           }
           achl_format++;
         }
       }
       if(*achl_format != '%'){
        chl_spec = *achl_format;
        /* get parameter value, do initial processing */
        switch ( umrs_format[(UINT) chl_spec]){
         case 3: {                          /* %  c   s                */
           chl_length_modifier = '\0';
           /*bol_padding_zero = false;       * turn zero padding off for string conversions */
           ull_str_arg_l = 1;
           switch(chl_spec){
             unsigned int u_tmp;
             unsigned short* ausl_tt;       /* translation table       */
             unsigned short* ausl_fbtt;     /* first-byte trans. table */
             case '%':
               achl_arg = achl_format;
               break;
             case 'c':case 'C':
               if (ull_utftype == 8) {
           //      free(achl_arg_temp);
                 return -1;
               }
               else if(adsl_arginfs!=NULL) {
                 printf("Error: (ucs) with other type than s not yet implemented");
                 ull_str_arg_l -= (ull_str_arg_l+1); /* "negative", as error condition */
                 break;
               }
               else if (ull_utftype == 16) {
                 u_tmp = va_arg(dsl_list, unsigned int);
                 switch( iel_cs_target) {
                   case ied_chs_invalid:
                     break;
                   case ied_chs_ascii_850:
                     if (iel_cs_source != ied_chs_utf_16) {
                       if(u_tmp & 0xFFFF00FF)
                         *achl_arg_temp = ASCII_REP_CHAR;
                       else
                         *achl_arg_temp = ucrg_tab_819_to_850[u_tmp>>8];
                     }
                     else {
                       if(u_tmp <= 0xFF)
                         *achl_arg_temp = ucrg_tab_819_to_850[u_tmp];
                       else
                         *achl_arg_temp = ASCII_REP_CHAR;
                     }
                     break;
                   case ied_chs_ansi_819:
                     if (iel_cs_source != ied_chs_utf_16) {
                       if(u_tmp & 0xFFFF00FF)
                         *achl_arg_temp = ASCII_REP_CHAR;
                       else
                         *achl_arg_temp = u_tmp>>8;
                     }
                     else {
                       if(u_tmp <= 0xFF)
                         *achl_arg_temp = u_tmp;
                       else
                         *achl_arg_temp = ASCII_REP_CHAR;
                     }
                     break;
                   CASE_IED_CHS_MISCCODEPAGES
                     if (iel_cs_source != ied_chs_utf_16)
                       u_tmp = ((u_tmp<<8) & 0xFF00) | (u_tmp>>8);
                     *achl_arg_temp = m_u32_to_sb_80a0(u_tmp, am_backtrans, aunl_back_ti, aucl_back_tt);
                     break;
                   CASE_IED_CHS_ISO8859_2TO16
                     if (iel_cs_source != ied_chs_utf_16)
                       u_tmp = ((u_tmp<<8) & 0xFF00) | (u_tmp>>8);
                     *achl_arg_temp = m_u32_to_sb_a1a0(u_tmp, am_backtrans, aunl_back_ti, aucl_back_tt);
                     break;
                   CASE_IED_CHS_ALL_CJK
                     if (iel_cs_source != ied_chs_utf_16)
                       u_tmp = ((u_tmp<<8) & 0xFF00) | (u_tmp>>8);
                     u_tmp = awcl_back_t[u_tmp];
                     if (u_tmp & 0xFF00) {
                       *achl_arg_temp = (u_tmp >> 8);
                       *(achl_arg_temp+1) = u_tmp;
                       ull_str_arg_l = 2;
                     } else {
                       *achl_arg_temp = u_tmp;
                     }
                     break;
                   case ied_chs_utf_8:
                     if (iel_cs_source != ied_chs_utf_16)
                        u_tmp = ((u_tmp>>8) | (u_tmp<<8)) & 0xFFFF;
                     if (u_tmp < 0X80) {
                        *achl_arg_temp = u_tmp;
                      } else if (u_tmp < 0X0800) {
                        *achl_arg_temp = 0XC0 | (u_tmp >> 6);
                        *(achl_arg_temp+1) = ( 0X80 | (u_tmp & 0X3F));
                        ull_str_arg_l = 2;
                      } else {
                        *achl_arg_temp = 0XE0 | (u_tmp >> 12);
                        *(achl_arg_temp+1) = (0X80 | ((u_tmp >> 6) & 0X3F));
                        *(achl_arg_temp+2) = ( 0X80 | (u_tmp & 0X3F));
                        ull_str_arg_l = 3;
                      }
                     break;
                   default:
                     break;
                 }
                 achl_arg = achl_arg_temp;
               }
               else if(ull_utftype == 32) {
                 u_tmp = va_arg(dsl_list, unsigned int);
                 switch( iel_cs_target) {
                   case ied_chs_invalid:
                     break;
                   case ied_chs_ascii_850:
                     if (iel_cs_source != ied_chs_utf_32) {
                       if(u_tmp & 0x00FFFFFF)
                         *achl_arg_temp = ASCII_REP_CHAR;
                       else
                         *achl_arg_temp = ucrg_tab_819_to_850[u_tmp>>24];
                     }
                     else {
                       if(u_tmp <= 0xFF)
                         *achl_arg_temp = ucrg_tab_819_to_850[u_tmp];
                       else
                         *achl_arg_temp = ASCII_REP_CHAR;
                     }
                     break;
                   case ied_chs_ansi_819:
                     if (iel_cs_source != ied_chs_utf_32) {
                       if(u_tmp & 0x00FFFFFF)
                         *achl_arg_temp = ASCII_REP_CHAR;
                       else
                         *achl_arg_temp = u_tmp>>24;
                     }
                     else {
                       if(u_tmp <= 0xFF)
                         *achl_arg_temp = u_tmp;
                       else
                         *achl_arg_temp = ASCII_REP_CHAR;
                     }
                     break;
                   CASE_IED_CHS_MISCCODEPAGES
                     if (iel_cs_source != ied_chs_utf_32) {
                       if(u_tmp & 0x00C0FFFF) {
                         *achl_arg_temp = ASCII_REP_CHAR;  /* above U+3FFF */
                       } else {
                         u_tmp = ((u_tmp>>8)&0xFF00) | (u_tmp>>24);
                         *achl_arg_temp = m_u32_to_sb_80a0(u_tmp, am_backtrans, aunl_back_ti, aucl_back_tt);
                       }
                     }
                     else {                 /* native endian           */
                       *achl_arg_temp = m_u32_to_sb_80a0(u_tmp, am_backtrans, aunl_back_ti, aucl_back_tt);
                     }
                     break;
                   CASE_IED_CHS_ISO8859_2TO16
                     if (iel_cs_source != ied_chs_utf_32) {
                       if(u_tmp & 0x00C0FFFF) {
                         *achl_arg_temp = ASCII_REP_CHAR;  /* above U+3FFF */
                       } else {
                         u_tmp = ((u_tmp>>8)&0xFF00) | (u_tmp>>24);
                         *achl_arg_temp = m_u32_to_sb_a1a0(u_tmp, am_backtrans, aunl_back_ti, aucl_back_tt);
                       }
                     }
                     else {                 /* native endian           */
                       *achl_arg_temp = m_u32_to_sb_a1a0(u_tmp, am_backtrans, aunl_back_ti, aucl_back_tt);
                     }
                     break;
                   CASE_IED_CHS_ALL_CJK
                     if (iel_cs_source != ied_chs_utf_32) {
                       if(u_tmp & 0x0000FFFF) {
                         *achl_arg_temp = ASCII_REP_CHAR;  /* above U+FFFF */
                         break;
                       }
                       u_tmp = ((u_tmp>>8)&0xFF00) | (u_tmp>>24);
                     } else {               /* already native endian   */
                       if(u_tmp & 0xFFFF0000) {
                         *achl_arg_temp = ASCII_REP_CHAR;  /* above U+FFFF */
                         break;
                       }
                     }
                     u_tmp = awcl_back_t[u_tmp];
                     if (u_tmp & 0xFF00) {
                       *achl_arg_temp = (u_tmp >> 8);
                       *(achl_arg_temp+1) = u_tmp;
                       ull_str_arg_l = 2;
                     } else {
                       *achl_arg_temp = u_tmp;
                     }
                     break;
                   case ied_chs_utf_8:
                     if (iel_cs_source != ied_chs_utf_32)
                       u_tmp = HL_ENDIANSWAP32(u_tmp);
                     if (u_tmp < 0X80) {
                       *achl_arg_temp = u_tmp;
                     } else if (u_tmp < 0X0800) {
                       *achl_arg_temp = 0XC0 | (u_tmp >> 6);
                       *(achl_arg_temp+1) = ( 0X80 | (u_tmp & 0X3F));
                       ull_str_arg_l = 2;
                     } else {
                       if (u_tmp >= 0X200000)
                         u_tmp = UTF16_REP_CHAR;
                       if (u_tmp < 0X010000) {
                         *achl_arg_temp = 0XE0 | (u_tmp >> 12);
                         *(achl_arg_temp+1) = (0X80 | ((u_tmp >> 6) & 0X3F));
                         *(achl_arg_temp+2) = ( 0X80 | (u_tmp & 0X3F));
                         ull_str_arg_l = 3;
                       } else {
                         *achl_arg_temp = 0XF0 | (u_tmp >> 18);
                         *(achl_arg_temp+1) = (0X80 | ((u_tmp >> 12) & 0X3F));
                         *(achl_arg_temp+2) = (0X80 | ((u_tmp >> 6) & 0X3F));
                         *(achl_arg_temp+3) = ( 0X80 | (u_tmp & 0X3F));
                         ull_str_arg_l = 4;
                       }
                     }
                     break;
                   default:
                     break;
                 }
                 achl_arg = achl_arg_temp;
               }
               else {
                 u_tmp = va_arg(dsl_list, unsigned int);
                 if ((signed int)u_tmp<0) {  /* topmost bit set        */
                   if (~u_tmp<0x100) {  /* assume char literal type problem */
                     u_tmp += 0x100;         /* wrapping to positive   */
                   } else {             /* out of range (no utf8 here) */
                     uchl_arg = ASCII_REP_CHAR;
                     achl_arg = (char*) &uchl_arg;
                     break;
                   }
                 }
                 if (iel_cs_target == iel_cs_source) {
                   switch (iel_cs_source) {
                     CASE_IED_CHS_ALL_CJK
                       if (u_tmp>0xFF) {
                         *achl_arg_temp = (unsigned char)(u_tmp >> 8);
                         *(achl_arg_temp+1) = (unsigned char)u_tmp;
                         ull_str_arg_l = 2;
                         achl_arg = achl_arg_temp;
                         break;
                       }                    /* else fall through       */
                     default:
                       uchl_arg = (unsigned char) u_tmp;
                       achl_arg = (char*) &uchl_arg;
                       break;
                    }
                 } else {
                   switch (iel_cs_source) {
                     case ied_chs_ascii_850:
                       switch (iel_cs_target) {
                         case ied_chs_ansi_819:
                           uchl_arg = ucrg_tab_850_to_819[u_tmp];
                           achl_arg = (char*) &uchl_arg;
                           break;
                         case ied_chs_oem_437:
                           uchl_arg = ucrg_tab_850_to_437[u_tmp];
                           achl_arg = (char*) &uchl_arg;
                           break;
                         case ied_chs_utf_8:
                           uchl_arg = ucrg_tab_850_to_819[u_tmp];
                           if (uchl_arg & 0x80) {
                             *achl_arg_temp = 0XC0 | (uchl_arg >> 6);
                             *(achl_arg_temp+1) = ( 0X80 | (uchl_arg & 0X3F));
                             ull_str_arg_l = 2;
                             achl_arg = achl_arg_temp;
                           } else {
                             achl_arg = (char*) &uchl_arg;
                           }
                           break;
                         CASE_IED_CHS_ALL_CJK
                           switch (u_tmp) {
                             /* some cases ucrg_tab_850_to_819 would miss are hardcoded */
                             case 0xD5:  /* LATIN SMALL LETTER DOTLESS I */
                               u_tmp = 0x0131; break;
                             case 0xB1:  /* MEDIUM SHADE */
                               u_tmp = 0x2592; break;
                             case 0xB2:  /* DARK SHADE */
                               u_tmp = 0x2593; break;
                             case 0xB3:  /* BOX DRAWINGS LIGHT VERTICAL */
                               u_tmp = 0x2502; break;
                             case 0xB4:  /* BOX DRAWINGS LIGHT VERTICAL AND LEFT */
                               u_tmp = 0x2524; break;
                             case 0xB9:  /* BOX DRAWINGS DOUBLE VERTICAL AND LEFT */
                               u_tmp = 0x2563; break;
                             case 0xBA:  /* BOX DRAWINGS DOUBLE VERTICAL */
                               u_tmp = 0x2551; break;
                             case 0xBB:  /* BOX DRAWINGS DOUBLE DOWN AND LEFT */
                               u_tmp = 0x2557; break;
                             case 0xBC:  /* BOX DRAWINGS DOUBLE UP AND LEFT */
                               u_tmp = 0x255D; break;
                             case 0xBF:  /* BOX DRAWINGS LIGHT DOWN AND LEFT */
                               u_tmp = 0x2510; break;
                             case 0xC0:  /* BOX DRAWINGS LIGHT UP AND RIGHT */
                               u_tmp = 0x2514; break;
                             case 0xC1:  /* BOX DRAWINGS LIGHT UP AND HORIZONTAL */
                               u_tmp = 0x2534; break;
                             case 0xC2:  /* BOX DRAWINGS LIGHT DOWN AND HORIZONTAL */
                               u_tmp = 0x252C; break;
                             case 0xC3:  /* BOX DRAWINGS LIGHT VERTICAL AND RIGHT */
                               u_tmp = 0x251C; break;
                             case 0xC4:  /* BOX DRAWINGS LIGHT HORIZONTAL */
                               u_tmp = 0x2500; break;
                             case 0xC5:  /* BOX DRAWINGS LIGHT VERTICAL AND HORIZONTAL */
                               u_tmp = 0x253C; break;
                             case 0xC8:  /* BOX DRAWINGS DOUBLE UP AND RIGHT */
                               u_tmp = 0x255A; break;
                             case 0xC9:  /* BOX DRAWINGS DOUBLE DOWN AND RIGHT */
                               u_tmp = 0x2554; break;
                             case 0xCA:  /* BOX DRAWINGS DOUBLE UP AND HORIZONTAL */
                               u_tmp = 0x2569; break;
                             case 0xCB:  /* BOX DRAWINGS DOUBLE DOWN AND HORIZONTAL */
                               u_tmp = 0x2566; break;
                             case 0xCC:  /* BOX DRAWINGS DOUBLE VERTICAL AND RIGHT */
                               u_tmp = 0x2560; break;
                             case 0xCD:  /* BOX DRAWINGS DOUBLE HORIZONTAL */
                               u_tmp = 0x2550; break;
                             case 0xCE:  /* BOX DRAWINGS DOUBLE VERTICAL AND HORIZONTAL */
                               u_tmp = 0x256C; break;
                             case 0xD9:  /* BOX DRAWINGS LIGHT UP AND LEFT */
                               u_tmp = 0x2518; break;
                             case 0xDA:  /* BOX DRAWINGS LIGHT DOWN AND RIGHT */
                               u_tmp = 0x250C; break;
                             case 0xDB:  /* FULL BLOCK */
                               u_tmp = 0x2588; break;
                             case 0xDC:  /* LOWER HALF BLOCK */
                               u_tmp = 0x2584; break;
                             case 0xFE:  /* BLACK SQUARE */
                               u_tmp = 0x25A0; break;
                             default:
                               u_tmp = ucrg_tab_850_to_819[u_tmp]; break;
                           }
                           u_tmp = awcl_back_t[u_tmp];
                           if(u_tmp >= 0x100) {
                             *achl_arg_temp = (unsigned char)(u_tmp >> 8);
                             *(achl_arg_temp+1) = (unsigned char) u_tmp;
                             ull_str_arg_l = 2;
                             achl_arg = achl_arg_temp;
                           } else {
                             uchl_arg = (unsigned char) u_tmp;
                             achl_arg = (char*) &uchl_arg;
                           }
                           break;
                         case ied_chs_iso8859_2:
                         case ied_chs_iso8859_3:  /* U+0131 not used  */
                         case ied_chs_iso8859_4:
                         case ied_chs_iso8859_5:
                         case ied_chs_iso8859_6:
                         case ied_chs_iso8859_7:
                         case ied_chs_iso8859_8:  /* U+2017 not used  */
                         case ied_chs_iso8859_10:
                         case ied_chs_iso8859_11:
                         case ied_chs_iso8859_13:
                           if(u_tmp == 0xFF) {  /* U+00FF not available, decode as U+00A0 */
                             uchl_arg = 0xA0;  /* a case ucrg_tab_850_to_819 would miss */
                             achl_arg = (char*) &uchl_arg;
                             break;
                           }                /* else fall through       */
                         case ied_chs_iso8859_9:  /* U+0131 not used  */
                         case ied_chs_iso8859_14:
                         case ied_chs_iso8859_15:
                         case ied_chs_iso8859_16:
                           uchl_arg = m_u32_to_sb_a1a0( ucrg_tab_850_to_819[u_tmp],
                                         m_u32c_to_sb_0step, aunl_back_ti, aucl_back_tt );
                           achl_arg = (char*) &uchl_arg;
                           break;
                         case ied_chs_wcp_1254:
                           if(u_tmp == 0xD5) {  /* U+0131, LATIN SMALL LETTER DOTLESS I */
                             uchl_arg = 0xFD;  /* a case ucrg_tab_850_to_819 would miss */
                             achl_arg = (char*) &uchl_arg;
                             break;
                           }                /* else fall through       */
                         case ied_chs_wcp_1252:
                         case ied_chs_wcp_1253:
                         case ied_chs_wcp_1255:
                         case ied_chs_wcp_1256:
                         case ied_chs_wcp_1258:
                           if(u_tmp == 0x9F) {  /* U+0192, LATIN SMALL LETTER F WITH HOOK */
                             uchl_arg = 0x83;  /* a case ucrg_tab_850_to_819 would miss */
                             achl_arg = (char*) &uchl_arg;
                             break;
                           }                /* else fall through       */
                         default:           /* codepages 874/125[017]/fall-through-125? */
                           uchl_arg = m_u32_to_sb_80a0( ucrg_tab_850_to_819[u_tmp],
                                         m_u32c_to_sb_0step, aunl_back_ti, aucl_back_tt );
                           achl_arg = (char*) &uchl_arg;
                           break;
                       }
                       break;
                     case ied_chs_ansi_819:
                       switch (iel_cs_target) {
                         case ied_chs_ascii_850:
                           uchl_arg = ucrg_tab_819_to_850[u_tmp];
                           achl_arg = (char*) &uchl_arg;
                           break;
                         case ied_chs_utf_8:
                           uchl_arg = (unsigned char) u_tmp;
                           if (uchl_arg & 0x80) {
                             *achl_arg_temp = 0XC0 | (uchl_arg >> 6);
                             *(achl_arg_temp+1) = ( 0X80 | (uchl_arg & 0X3F));
                             ull_str_arg_l = 2;
                             achl_arg = achl_arg_temp;
                           } else {
                             achl_arg = (char*) &uchl_arg;
                           }
                           break;
                         CASE_IED_CHS_ALL_CJK
                           u_tmp = awcl_back_t[u_tmp];
                           if(u_tmp >= 0x100) {
                             *achl_arg_temp = (unsigned char)(u_tmp >> 8);
                             *(achl_arg_temp+1) = (unsigned char) u_tmp;
                             ull_str_arg_l = 2;
                             achl_arg = achl_arg_temp;
                           } else {
                             uchl_arg = (unsigned char) u_tmp;
                             achl_arg = (char*) &uchl_arg;
                           }
                           break;
                         CASE_IED_CHS_ISO8859_2TO16
                           uchl_arg = m_u32_to_sb_a1a0( u_tmp, m_u32c_to_sb_0step,
                                                        aunl_back_ti, aucl_back_tt );
                           achl_arg = (char*) &uchl_arg;
                           break;
                         default:           /* codepages 437/874/125?  */
                           uchl_arg = m_u32_to_sb_80a0( u_tmp, m_u32c_to_sb_0step,
                                                        aunl_back_ti, aucl_back_tt );
                           achl_arg = (char*) &uchl_arg;
                           break;
                       }
                       break;
                     case ied_chs_oem_437:
                       switch (iel_cs_target) {
                         case ied_chs_ascii_850:
                           uchl_arg = ucrg_tab_437_to_850[u_tmp];
                           achl_arg = (char*) &uchl_arg;
                           break;
                         case ied_chs_ansi_819:
                           if (usrg_tab_437_to_uni[u_tmp] > 0xFF) {
                             if (u_tmp > 0x7F) {
                               uchl_arg = ASCII_REP_CHAR;
                             } else {
                               uchl_arg = u_tmp;  /* fall back to the official identity */
                             }
                           } else {
                             uchl_arg = usrg_tab_437_to_uni[u_tmp];
                           }
                           achl_arg = (char*) &uchl_arg;
                           break;
                         case ied_chs_utf_8:
                           u_tmp = usrg_tab_437_to_uni[u_tmp];
                           if (u_tmp >= 0x80) {
                             if (u_tmp & 0x2000) {  /* are all in U+2xxx range */
                               *achl_arg_temp = (char)0xE2;
                               *(achl_arg_temp+1) = (u_tmp >> 6);  /* set bit 13 fits in well */
                               *(achl_arg_temp+2) = 0x80 | (u_tmp & 0x3F);
                               ull_str_arg_l = 3;
                             } else {
                               *achl_arg_temp = 0XC0 | (u_tmp >> 6);
                               *(achl_arg_temp+1) = ( 0X80 | (u_tmp & 0X3F));
                               ull_str_arg_l = 2;
                             }
                             achl_arg = achl_arg_temp;
                           } else {
                             uchl_arg = (unsigned char) u_tmp;
                             achl_arg = (char*) &uchl_arg;
                           }
                           break;
                         CASE_IED_CHS_ALL_CJK
                           if ((u_tmp>=0x80) || (awcl_back_t[usrg_tab_437_to_uni[u_tmp]]!=ASCII_REP_CHAR))
                             u_tmp = awcl_back_t[usrg_tab_437_to_uni[u_tmp]];
                           if(u_tmp >= 0x100) {
                             *achl_arg_temp = (unsigned char)(u_tmp >> 8);
                             *(achl_arg_temp+1) = (unsigned char) u_tmp;
                             ull_str_arg_l = 2;
                             achl_arg = achl_arg_temp;
                           } else {
                             uchl_arg = (unsigned char) u_tmp;
                             achl_arg = (char*) &uchl_arg;
                           }
                           break;
                         CASE_IED_CHS_ISO8859_2TO16
                           uchl_arg = m_u32_to_sb_a1a0(usrg_tab_437_to_uni[u_tmp], am_backtrans, aunl_back_ti, aucl_back_tt);
                           if ((uchl_arg == ASCII_REP_CHAR) && (u_tmp<0x80))
                             uchl_arg = u_tmp;  /* fall back to the official identity (that also exists in the target) */
                           achl_arg = (char*) &uchl_arg;
                           break;
                         default:           /* codepages 874/125?      */
                           uchl_arg = m_u32_to_sb_80a0(usrg_tab_437_to_uni[u_tmp], am_backtrans, aunl_back_ti, aucl_back_tt);
                           if ((uchl_arg == ASCII_REP_CHAR) && (u_tmp<0x80))
                             uchl_arg = u_tmp;  /* fall back to the official identity (that also exists in the target) */
                           achl_arg = (char*) &uchl_arg;
                           break;
                       }
                       break;
                     do {  /* variant of Duffs device, the "break" go to the end of this pseudoloop */
                     case ied_chs_wcp_874:
                       u_tmp = usrg_tab_874_to_uni[u_tmp]; break;
                     case ied_chs_wcp_1250:
                       u_tmp = usrg_tab_1250_to_uni[u_tmp]; break;
                     case ied_chs_wcp_1251:
                       u_tmp = usrg_tab_1251_to_uni[u_tmp]; break;
                     case ied_chs_wcp_1252:
                       u_tmp = usrg_tab_1252_to_uni[u_tmp]; break;
                     case ied_chs_wcp_1253:
                       u_tmp = usrg_tab_1253_to_uni[u_tmp]; break;
                     case ied_chs_wcp_1254:
                       u_tmp = usrg_tab_1254_to_uni[u_tmp]; break;
                     case ied_chs_wcp_1255:
                       u_tmp = usrg_tab_1255_to_uni[u_tmp]; break;
                     case ied_chs_wcp_1256:
                       u_tmp = usrg_tab_1256_to_uni[u_tmp]; break;
                     case ied_chs_wcp_1257:
                       u_tmp = usrg_tab_1257_to_uni[u_tmp]; break;
                     case ied_chs_wcp_1258:
                       u_tmp = usrg_tab_1258_to_uni[u_tmp]; break;
                     case ied_chs_iso8859_2:
                       u_tmp = usrg_tab_i02_to_uni[u_tmp]; break;
                     case ied_chs_iso8859_3:
                       u_tmp = usrg_tab_i03_to_uni[u_tmp]; break;
                     case ied_chs_iso8859_4:
                       u_tmp = usrg_tab_i04_to_uni[u_tmp]; break;
                     case ied_chs_iso8859_5:
                       u_tmp = usrg_tab_i05_to_uni[u_tmp]; break;
                     case ied_chs_iso8859_6:
                       u_tmp = usrg_tab_i06_to_uni[u_tmp]; break;
                     case ied_chs_iso8859_7:
                       u_tmp = usrg_tab_i07_to_uni[u_tmp]; break;
                     case ied_chs_iso8859_8:
                       u_tmp = usrg_tab_i08_to_uni[u_tmp]; break;
                     case ied_chs_iso8859_9:
                       u_tmp = usrg_tab_i09_to_uni[u_tmp]; break;
                     case ied_chs_iso8859_10:
                       u_tmp = usrg_tab_i10_to_uni[u_tmp]; break;
                     case ied_chs_iso8859_11:
                       u_tmp = usrg_tab_i11_to_uni[u_tmp]; break;
                     case ied_chs_iso8859_13:
                       u_tmp = usrg_tab_i13_to_uni[u_tmp]; break;
                     case ied_chs_iso8859_14:
                       u_tmp = usrg_tab_i14_to_uni[u_tmp]; break;
                     case ied_chs_iso8859_15:
                       u_tmp = usrg_tab_i15_to_uni[u_tmp]; break;
                     case ied_chs_iso8859_16:
                       u_tmp = usrg_tab_i16_to_uni[u_tmp]; break;
                     CASE_IED_CHS_ALL_CJK
                       if ((*((HL_WCHAR*)achl_arg_temp) =
                             m_get_tab_mb_firstbytes(iel_cs_source)[(u_tmp>0xFF)?(u_tmp>>8):u_tmp]
                           ) == 0xFFFF) {
                         u_tmp = m_get_tab_mb_to_uni(iel_cs_source)[u_tmp];
                       } else {
                         u_tmp = *((HL_WCHAR*)achl_arg_temp);
                       }
                       break;
                     } while (FALSE);       /* end of the pseudoloop   */
                       switch (iel_cs_target) {
                         case ied_chs_ascii_850:
                           switch (u_tmp) {
                             /* some cases ucrg_tab_819_to_850 would miss are hardcoded */
                             case 0x0131:  /* LATIN SMALL LETTER DOTLESS I */
                               uchl_arg = 0xD5; break;
                             case 0x0192:  /* LATIN SMALL LETTER F WITH HOOK */
                               uchl_arg = 0x9F; break;
                             /* symbols common with some or all CJK charsets */
                             case 0x2592:  /* MEDIUM SHADE */
                               uchl_arg = 0xB1; break;
                             case 0x2593:  /* DARK SHADE */
                               uchl_arg = 0xB2; break;
                             case 0x2502:  /* BOX DRAWINGS LIGHT VERTICAL */
                               uchl_arg = 0xB3; break;
                             case 0x2524:  /* BOX DRAWINGS LIGHT VERTICAL AND LEFT */
                               uchl_arg = 0xB4; break;
                             case 0x2563:  /* BOX DRAWINGS DOUBLE VERTICAL AND LEFT */
                               uchl_arg = 0xB9; break;
                             case 0x2551:  /* BOX DRAWINGS DOUBLE VERTICAL */
                               uchl_arg = 0xBA; break;
                             case 0x2557:  /* BOX DRAWINGS DOUBLE DOWN AND LEFT */
                               uchl_arg = 0xBB; break;
                             case 0x255D:  /* BOX DRAWINGS DOUBLE UP AND LEFT */
                               uchl_arg = 0xBC; break;
                             case 0x2510:  /* BOX DRAWINGS LIGHT DOWN AND LEFT */
                               uchl_arg = 0xBF; break;
                             case 0x2514:  /* BOX DRAWINGS LIGHT UP AND RIGHT */
                               uchl_arg = 0xC0; break;
                             case 0x2534:  /* BOX DRAWINGS LIGHT UP AND HORIZONTAL */
                               uchl_arg = 0xC1; break;
                             case 0x252C:  /* BOX DRAWINGS LIGHT DOWN AND HORIZONTAL */
                               uchl_arg = 0xC2; break;
                             case 0x251C:  /* BOX DRAWINGS LIGHT VERTICAL AND RIGHT */
                               uchl_arg = 0xC3; break;
                             case 0x2500:  /* BOX DRAWINGS LIGHT HORIZONTAL */
                               uchl_arg = 0xC4; break;
                             case 0x253C:  /* BOX DRAWINGS LIGHT VERTICAL AND HORIZONTAL */
                               uchl_arg = 0xC5; break;
                             case 0x255A:  /* BOX DRAWINGS DOUBLE UP AND RIGHT */
                               uchl_arg = 0xC8; break;
                             case 0x2554:  /* BOX DRAWINGS DOUBLE DOWN AND RIGHT */
                               uchl_arg = 0xC9; break;
                             case 0x2569:  /* BOX DRAWINGS DOUBLE UP AND HORIZONTAL */
                               uchl_arg = 0xCA; break;
                             case 0x2566:  /* BOX DRAWINGS DOUBLE DOWN AND HORIZONTAL */
                               uchl_arg = 0xCB; break;
                             case 0x2560:  /* BOX DRAWINGS DOUBLE VERTICAL AND RIGHT */
                               uchl_arg = 0xCC; break;
                             case 0x2550:  /* BOX DRAWINGS DOUBLE HORIZONTAL */
                               uchl_arg = 0xCD; break;
                             case 0x256C:  /* BOX DRAWINGS DOUBLE VERTICAL AND HORIZONTAL */
                               uchl_arg = 0xCE; break;
                             case 0x2518:  /* BOX DRAWINGS LIGHT UP AND LEFT */
                               uchl_arg = 0xD9; break;
                             case 0x250C:  /* BOX DRAWINGS LIGHT DOWN AND RIGHT */
                               uchl_arg = 0xDA; break;
                             case 0x2588:  /* FULL BLOCK */
                               uchl_arg = 0xDB; break;
                             case 0x2584:  /* LOWER HALF BLOCK */
                               uchl_arg = 0xDC; break;
                             case 0x25A0:  /* BLACK SQUARE */
                               uchl_arg = 0xFE; break;
                             default:
                               if (u_tmp >= 0x100) {
                                 uchl_arg = ASCII_REP_CHAR;
                               } else {
                                 uchl_arg = ucrg_tab_819_to_850[u_tmp];
                               }
                           }
                           achl_arg = (char*) &uchl_arg;
                           break;
                         case ied_chs_ansi_819:
                           if (u_tmp >= 0x100)
                             uchl_arg = ASCII_REP_CHAR;
                           else
                             uchl_arg = (unsigned char) u_tmp;
                           achl_arg = (char*) &uchl_arg;
                           break;
                         case ied_chs_utf_8:
                           if (u_tmp >= 0x80) {
                             if (u_tmp >= 0x800) {
                               *achl_arg_temp = 0xE0 | (u_tmp >> 12);
                               *(achl_arg_temp+1) = 0x80 | ((u_tmp >> 6) & 0x3F);
                               *(achl_arg_temp+2) = 0x80 | (u_tmp & 0x3F);
                               ull_str_arg_l = 3;
                             } else {
                               *achl_arg_temp = 0XC0 | (u_tmp >> 6);
                               *(achl_arg_temp+1) = ( 0X80 | (u_tmp & 0X3F));
                               ull_str_arg_l = 2;
                             }
                             achl_arg = achl_arg_temp;
                           } else {
                             uchl_arg = (unsigned char) u_tmp;
                             achl_arg = (char*) &uchl_arg;
                           }
                           break;
                         CASE_IED_CHS_ALL_CJK
                           u_tmp = awcl_back_t[u_tmp];
                           if(u_tmp >= 0x100) {
                             *achl_arg_temp = (unsigned char)(u_tmp >> 8);
                             *(achl_arg_temp+1) = (unsigned char) u_tmp;
                             ull_str_arg_l = 2;
                             achl_arg = achl_arg_temp;
                           } else {
                             uchl_arg = (unsigned char) u_tmp;
                             achl_arg = (char*) &uchl_arg;
                           }
                           break;
                         CASE_IED_CHS_ISO8859_2TO16
                           uchl_arg = m_u32_to_sb_a1a0(u_tmp, am_backtrans, aunl_back_ti, aucl_back_tt);
                           achl_arg = (char*) &uchl_arg;
                           break;
                         default:           /* codepages 437/874/125?  */
                           uchl_arg = m_u32_to_sb_80a0(u_tmp, am_backtrans, aunl_back_ti, aucl_back_tt);
                           achl_arg = (char*) &uchl_arg;
                           break;
                       }
                       break;
                     case ied_chs_invalid:  /* faulty format           */
                       break;
                     default:               /* cannot happen           */
                       return -1;           /* avoid compiler warning  */
                   }
                 }
               }
               break;
             case 's':
               bol_str_arg_l_known = false;
               if (ull_utftype == 8){       /* UTF8-String type        */
                 achl_arg_u8 = va_arg(dsl_list, char *);
#ifdef TRACEHL1
#if _RWDEBUG
                 printf("UTF8 string to converting: %s\n", achl_arg_u8);
#endif
#endif
                 switch( iel_cs_target) {
                   case ied_chs_ascii_850:
                      //   m_a850l_from_u8l(achl_arg_temp, iml_str_len, achl_arg_u8, iml_str_len );
                   case ied_chs_ansi_819:
                   //     m_a819l_from_u8l(achl_arg_temp, iml_str_len, achl_arg_u8, iml_str_len );
                   case ied_chs_oem_437:
                   //     m_a437l_from_u8l(achl_arg_temp, iml_str_len, achl_arg_u8, iml_str_len );
                   case ied_chs_wcp_874:    /* Windows-Codepage  874   */
                   case ied_chs_wcp_1250:   /* Windows-Codepage 1250   */
                   case ied_chs_wcp_1251:   /* Windows-Codepage 1251   */
                   case ied_chs_wcp_1252:   /* Windows-Codepage 1252   */
                   case ied_chs_wcp_1253:   /* Windows-Codepage 1253   */
                   case ied_chs_wcp_1254:   /* Windows-Codepage 1254   */
                   case ied_chs_wcp_1255:   /* Windows-Codepage 1255   */
                   case ied_chs_wcp_1256:   /* Windows-Codepage 1256   */
                   case ied_chs_wcp_1257:   /* Windows-Codepage 1257   */
                   case ied_chs_wcp_1258:   /* Windows-Codepage 1258   */
                   CASE_IED_CHS_ISO8859_2TO16
                     if(ull_precision > 0){
                       iml_str_len = ull_precision;
                     } else {
                       iml_str_len = strlen((char*) achl_arg_u8);  /* upper est. for targetlen */
                     }
                     ull_str_arg_l = m_sbc_from_u8l( achl_arg_temp, iml_str_len, achl_arg_u8, iel_cs_target);
                     bol_str_arg_l_known = true;
                     achl_arg = achl_arg_temp;
                     break;
                   CASE_IED_CHS_ALL_CJK
                     if(ull_precision > 0){
                       iml_str_len = m_strlen_with_u8l(achl_arg_u8, ull_precision);
                     } else {
                       iml_str_len = strlen((char*) achl_arg_u8);  /* sourcelen in bytes */
                     }
                     ull_str_arg_l = m_mbcl_from_u8l( achl_arg_temp, MAX_STR_LENGTH, awcl_back_t,
                                                      achl_arg_u8, iml_str_len, NULL );
                     bol_str_arg_l_known = true;
                     achl_arg = achl_arg_temp;
                     break;
                   case ied_chs_utf_8:
                     if (bol_precision) {
                       /*ull_str_arg_l = m_u8l_from_ul( achl_arg_temp, strlen(achl_arg_u8), achl_arg_u8,
                                                        ull_precision, ied_chs_utf_8 );*/
                       ull_str_arg_l = m_strlen_with_u8l( achl_arg_u8, ull_precision );
                       bol_str_arg_l_known = true;
                     } else {
                       /*strcpy(achl_arg_temp, (char *)achl_arg_u8);*/
                       ull_str_arg_l = strlen(achl_arg_u8);
                       bol_str_arg_l_known = true;
                     }
                     achl_arg = achl_arg_u8;
                     break;
                   case ied_chs_invalid:
                   default:
                     achl_arg = NULL;
                     break;
                 }
#ifdef TRACEHL1
#if _RWDEBUG
                 printf("UTF8 string after converting: %s\n", achl_arg);
#endif
#endif
               }
               else if (ull_utftype == 16){
                 achl_arg_u16 = va_arg(dsl_list, HL_WCHAR *);

                 /* find out string length */
                 if(ull_precision > 0) {
                     iml_str_len = ull_precision;
                 } else {
                   for(iml_str_len = 0; *(achl_arg_u16 + iml_str_len) != '\0'; iml_str_len++);
                 }

                 switch( iel_cs_target) {
                   case ied_chs_ascii_850:
                   case ied_chs_ansi_819:
                   CASE_IED_CHS_MISCCODEPAGES
                   CASE_IED_CHS_ALL_CJK
                   CASE_IED_CHS_ISO8859_2TO16
                     if (iel_cs_source == ied_chs_utf_16)
                       ull_str_arg_l = m_sbc_from_u16z( achl_arg_temp, iml_str_len, achl_arg_u16, iel_cs_target);
                     else
                       ull_str_arg_l = m_sbc_from_u16r( achl_arg_temp, iml_str_len, achl_arg_u16, iel_cs_target);
                     bol_str_arg_l_known = true;
                     break;
                   case ied_chs_utf_8:
                     if (iel_cs_source == ied_chs_utf_16)
                       ull_str_arg_l = m_u8l_from_u16l( achl_arg_temp, MAX_STR_LENGTH, achl_arg_u16, iml_str_len);
                     else
                       ull_str_arg_l = m_u8l_from_ul( achl_arg_temp, MAX_STR_LENGTH, achl_arg_u16, iml_str_len, iel_cs_source);
                     bol_str_arg_l_known = true;
                     break;
                   case ied_chs_invalid:
                   default:
                     break;
                 }
#ifdef TRACEHL1
#ifdef _RWDEBUG
                 printf("HL_WCHAR string after converting: %s\n", (char *) achl_arg_temp);
#endif
#endif
                 achl_arg = achl_arg_temp;

               }
               else if(ull_utftype == 32){
                 ainl_arg_u32 = (int *) va_arg(dsl_list, int *);

                 /* find out string length */
                  if(ull_precision > 0){
                   iml_str_len = ull_precision;
                 } else {
                   for(iml_str_len = 0; *(ainl_arg_u32 + iml_str_len) != '\0'; iml_str_len++);
                 }

                 switch( iel_cs_target) {
                   case ied_chs_ascii_850:
                   case ied_chs_ansi_819:
                   CASE_IED_CHS_MISCCODEPAGES
                   CASE_IED_CHS_ALL_CJK
                   CASE_IED_CHS_ISO8859_2TO16
                     if (iel_cs_source == ied_chs_utf_32)
                       ull_str_arg_l = m_sbc_from_u32z( achl_arg_temp, iml_str_len, ainl_arg_u32, iel_cs_target);
                     else
                       ull_str_arg_l = m_sbc_from_u32r( achl_arg_temp, iml_str_len, ainl_arg_u32, iel_cs_target);
                     bol_str_arg_l_known = true;
                     break;
                   case ied_chs_utf_8:
                     if (iel_cs_source == ied_chs_utf_32)
                       ull_str_arg_l = m_u8l_from_u32l( achl_arg_temp, MAX_STR_LENGTH, ainl_arg_u32, iml_str_len);
                     else
                       ull_str_arg_l = m_u8l_from_ul( achl_arg_temp, MAX_STR_LENGTH, ainl_arg_u32, iml_str_len, iel_cs_source);
                     bol_str_arg_l_known = true;
                     break;
                   case ied_chs_invalid:
                   default:
                     break;
                 }
#ifdef TRACEHL1
#if _RWDEBUG
                 printf("UTF32 string after converting: %s\n", achl_arg_temp);
#endif
#endif
                 achl_arg = achl_arg_temp;
               }
               else if(adsl_arginfs == NULL) {  /* the "else" is of ull_utftype check, it should be 0 here */
                 achl_arg = va_arg(dsl_list, char *);
                 if (iel_cs_source!=iel_cs_target) {
                   switch (iel_cs_source) {
                     CASE_IED_CHS_ALL_CJK
                       ausl_fbtt = m_get_tab_mb_firstbytes(iel_cs_source);
                       ausl_tt = m_get_tab_mb_to_uni(iel_cs_source);
                       break;
                     case ied_chs_oem_437:    ausl_tt = usrg_tab_437_to_uni; break;
                     case ied_chs_wcp_874:    ausl_tt = usrg_tab_874_to_uni; break;
                     case ied_chs_wcp_1250:   ausl_tt = usrg_tab_1250_to_uni; break;
                     case ied_chs_wcp_1251:   ausl_tt = usrg_tab_1251_to_uni; break;
                     case ied_chs_wcp_1252:   ausl_tt = usrg_tab_1252_to_uni; break;
                     case ied_chs_wcp_1253:   ausl_tt = usrg_tab_1253_to_uni; break;
                     case ied_chs_wcp_1254:   ausl_tt = usrg_tab_1254_to_uni; break;
                     case ied_chs_wcp_1255:   ausl_tt = usrg_tab_1255_to_uni; break;
                     case ied_chs_wcp_1256:   ausl_tt = usrg_tab_1256_to_uni; break;
                     case ied_chs_wcp_1257:   ausl_tt = usrg_tab_1257_to_uni; break;
                     case ied_chs_wcp_1258:   ausl_tt = usrg_tab_1258_to_uni; break;
                     case ied_chs_iso8859_2:  ausl_tt = usrg_tab_i02_to_uni; break;
                     case ied_chs_iso8859_3:  ausl_tt = usrg_tab_i03_to_uni; break;
                     case ied_chs_iso8859_4:  ausl_tt = usrg_tab_i04_to_uni; break;
                     case ied_chs_iso8859_5:  ausl_tt = usrg_tab_i05_to_uni; break;
                     case ied_chs_iso8859_6:  ausl_tt = usrg_tab_i06_to_uni; break;
                     case ied_chs_iso8859_7:  ausl_tt = usrg_tab_i07_to_uni; break;
                     case ied_chs_iso8859_8:  ausl_tt = usrg_tab_i08_to_uni; break;
                     case ied_chs_iso8859_9:  ausl_tt = usrg_tab_i09_to_uni; break;
                     case ied_chs_iso8859_10: ausl_tt = usrg_tab_i10_to_uni; break;
                     case ied_chs_iso8859_11: ausl_tt = usrg_tab_i11_to_uni; break;
                     case ied_chs_iso8859_13: ausl_tt = usrg_tab_i13_to_uni; break;
                     case ied_chs_iso8859_14: ausl_tt = usrg_tab_i14_to_uni; break;
                     case ied_chs_iso8859_15: ausl_tt = usrg_tab_i15_to_uni; break;
                     case ied_chs_iso8859_16: ausl_tt = usrg_tab_i16_to_uni; break;
                     default: break;
                   }
                 }
                 switch( iel_cs_target) {
                   case ied_chs_invalid:
                     break;
                   case ied_chs_ascii_850:
                     switch (iel_cs_source) {
                       case ied_chs_ansi_819:
                         for (ull_str_arg_l=0; ull_str_arg_l<MAX_STR_LENGTH; ull_str_arg_l++) {
                           if ((
                                 *(achl_arg_temp+ull_str_arg_l) = ucrg_tab_819_to_850[*((unsigned char*)achl_arg+ull_str_arg_l)]
                               ) == 0)
                             break;
                         }
                         bol_str_arg_l_known = true;
                         achl_arg = achl_arg_temp;
                         break;
                       case ied_chs_ascii_850:  /* no change           */
                       case ied_chs_invalid:  /* faulty format         */
                         break;
                       case ied_chs_oem_437:
                         for (ull_str_arg_l=0; ull_str_arg_l<MAX_STR_LENGTH; ull_str_arg_l++) {
                           if ((
                                 *(achl_arg_temp+ull_str_arg_l) = ucrg_tab_437_to_850[*((unsigned char*)achl_arg+ull_str_arg_l)]
                               ) == 0)
                             break;
                         }
                         bol_str_arg_l_known = true;
                         achl_arg = achl_arg_temp;
                         break;
                       CASE_IED_CHS_ALL_CJK
                         for (ull_str_arg_l=0; ull_str_arg_l<MAX_STR_LENGTH; ull_str_arg_l++) {
                           u_tmp = ausl_fbtt[*((unsigned char*)achl_arg)];
                           if (u_tmp==0)
                             break;
                           if (u_tmp==0xFFFF) {  /* two-byte source char */
                             u_tmp = ausl_tt[ *((unsigned char*)achl_arg)<<8
                                             |*((unsigned char*)achl_arg+1) ];
                             achl_arg++;
                           }
                           achl_arg++;
                           if (u_tmp > 0xFF)
                             *(achl_arg_temp+ull_str_arg_l) = ASCII_REP_CHAR;
                             else
                             *(achl_arg_temp+ull_str_arg_l) = ucrg_tab_819_to_850[(unsigned char)u_tmp];
                         }
                         bol_str_arg_l_known = true;
                         achl_arg = achl_arg_temp;
                         break;
                       default:             /* codepages 874/125?/8859 */
                         for (ull_str_arg_l=0; ull_str_arg_l<MAX_STR_LENGTH; ull_str_arg_l++) {
                           u_tmp = ausl_tt[*((unsigned char*)achl_arg+ull_str_arg_l)];
                           if (u_tmp > 0xFF) {
                             /* XXX ucrg_tab_819_to_850 limited to 8 bit, cf. the hardcoded cases in the 'c' part */
                             *(achl_arg_temp+ull_str_arg_l) = ASCII_REP_CHAR;
                           } else {
                             *(achl_arg_temp+ull_str_arg_l) = ucrg_tab_819_to_850[(unsigned char)u_tmp];
                             if (u_tmp == 0)
                               break;
                           }
                         }
                         bol_str_arg_l_known = true;
                         achl_arg = achl_arg_temp;
                         break;
                     }
                     break;    /* end of ied_chs_ascii_850 target case */
                   case ied_chs_ansi_819:
                     switch (iel_cs_source) {
                       case ied_chs_ansi_819:  /* no change            */
                       case ied_chs_invalid:  /* faulty format         */
                         break;
                       case ied_chs_ascii_850:
                         for (ull_str_arg_l=0; ull_str_arg_l<MAX_STR_LENGTH; ull_str_arg_l++) {
                           if ((
                                 *(achl_arg_temp+ull_str_arg_l) = ucrg_tab_850_to_819[*((unsigned char*)achl_arg+ull_str_arg_l)]
                               ) == 0)
                             break;
                         }
                         bol_str_arg_l_known = true;
                         achl_arg = achl_arg_temp;
                         break;
                       case ied_chs_oem_437:
                         for (ull_str_arg_l=0; ull_str_arg_l<MAX_STR_LENGTH; ull_str_arg_l++) {
                           u_tmp = usrg_tab_437_to_uni[*((unsigned char*)achl_arg+ull_str_arg_l)];
                           if(u_tmp > 0xFF) {
                             /* try to fall back to the official identity  till 0x80 */
                             u_tmp = *((unsigned char*)achl_arg+ull_str_arg_l);
                             if(u_tmp > 0x7F) {
                               *(achl_arg_temp+ull_str_arg_l) = ASCII_REP_CHAR;
                             } else {
                               *(achl_arg_temp+ull_str_arg_l) = (char)u_tmp;
                             }
                           } else {
                             *(achl_arg_temp+ull_str_arg_l) = (char)u_tmp;
                             if (u_tmp == 0)
                               break;
                           }
                         }
                         bol_str_arg_l_known = true;
                         achl_arg = achl_arg_temp;
                         break;
                       CASE_IED_CHS_ALL_CJK
                         for (ull_str_arg_l=0; ull_str_arg_l<MAX_STR_LENGTH; ull_str_arg_l++) {
                           u_tmp = ausl_fbtt[*((unsigned char*)achl_arg)];
                           if (u_tmp==0)
                             break;
                           if (u_tmp==0xFFFF) {  /* two-byte source char */
                             u_tmp = ausl_tt[ *((unsigned char*)achl_arg)<<8
                                             |*((unsigned char*)achl_arg+1) ];
                             achl_arg++;
                           }
                           achl_arg++;
                           if (u_tmp > 0xFF)
                             *(achl_arg_temp+ull_str_arg_l) = ASCII_REP_CHAR;
                             else
                             *(achl_arg_temp+ull_str_arg_l) = (unsigned char)u_tmp;
                         }
                         bol_str_arg_l_known = true;
                         achl_arg = achl_arg_temp;
                         break;
                       default:             /* codepages 874/125?/8859 */
                         for (ull_str_arg_l=0; ull_str_arg_l<MAX_STR_LENGTH; ull_str_arg_l++) {
                           u_tmp = ausl_tt[*((unsigned char*)achl_arg+ull_str_arg_l)];
                           if(u_tmp > 0xFF) {
                             *(achl_arg_temp+ull_str_arg_l) = ASCII_REP_CHAR;
                           } else {
                             *(achl_arg_temp+ull_str_arg_l) = (char)u_tmp;
                             if (u_tmp == 0)
                               break;
                           }
                         }
                         bol_str_arg_l_known = true;
                         achl_arg = achl_arg_temp;
                         break;
                     }
                     break;     /* end of ied_chs_ansi_819 target case */
                   case ied_chs_oem_437:
                     if (iel_cs_source == ied_chs_ascii_850) {
                       for (ull_str_arg_l=0; ull_str_arg_l<MAX_STR_LENGTH; ull_str_arg_l++) {
                         if ((
                               *(achl_arg_temp+ull_str_arg_l) =
                                 ucrg_tab_850_to_437[*((unsigned char*)achl_arg+ull_str_arg_l)]
                             ) == 0)
                           break;
                         }
                         bol_str_arg_l_known = true;
                         achl_arg = achl_arg_temp;
                       break;
                     }                      /* else fall through       */
                   case ied_chs_wcp_874:
                   case ied_chs_wcp_1250:
                   case ied_chs_wcp_1251:
                   case ied_chs_wcp_1252:
                   case ied_chs_wcp_1253:
                   case ied_chs_wcp_1254:
                   case ied_chs_wcp_1255:
                   case ied_chs_wcp_1256:
                   case ied_chs_wcp_1257:
                   case ied_chs_wcp_1258:
                   {
                     unsigned long ill_maxtarglen =  (bol_precision ? ull_precision : MAX_STR_LENGTH);
                     if (iel_cs_source == iel_cs_target)
                       break;               /* no change               */
                     switch (iel_cs_source) {
                       case ied_chs_invalid:  /* faulty format         */
                         break;
                       case ied_chs_ansi_819:
                         for (ull_str_arg_l=0; ull_str_arg_l<ill_maxtarglen; ull_str_arg_l++) {
                           if (*((signed char*)achl_arg+ull_str_arg_l) < 0) {
                             /* first tablepart runs upto U+00FF, and unrg_tabindex_uni_to_*[0] is always 0xA0 */
                             u_tmp = *((unsigned char*)achl_arg+ull_str_arg_l)-0xA0;
                             if ((
                                   *(achl_arg_temp+ull_str_arg_l) =
                                     ((u_tmp>=aunl_back_ti[3])  /* <0xA0 would be wrapped */
                                       ? ASCII_REP_CHAR
                                       : aucl_back_tt[u_tmp]
                                     )
                                 ) == 0)
                               *(achl_arg_temp+ull_str_arg_l) = ASCII_REP_CHAR;
                           } else {         /* lower 128 bytes, equal  */
                             if ((*(achl_arg_temp+ull_str_arg_l) = *(achl_arg+ull_str_arg_l)) == 0)
                               break;
                           }
                         }
                         bol_str_arg_l_known = true;
                         achl_arg = achl_arg_temp;
                         break;
                       case ied_chs_ascii_850:
                         for (ull_str_arg_l=0; ull_str_arg_l<ill_maxtarglen; ull_str_arg_l++) {
                           u_tmp = ucrg_tab_850_to_819[*((unsigned char*)achl_arg+ull_str_arg_l)];
                           if (u_tmp & 0x80) {
                             /* first tablepart runs upto U+00FF, and unrg_tabindex_uni_to_*[0] is always 0xA0 */
                             u_tmp -= 0xA0;  /* <0xA0 would be wrapped */
                             if ((
                                   *(achl_arg_temp+ull_str_arg_l) =
                                     ((u_tmp>=aunl_back_ti[3])
                                       ? ASCII_REP_CHAR
                                       : aucl_back_tt[u_tmp]
                                     )
                                 ) == 0)
                               *(achl_arg_temp+ull_str_arg_l) = ASCII_REP_CHAR;
                           } else {         /* lower 128 bytes, equal  */
                             if ((*(achl_arg_temp+ull_str_arg_l) = u_tmp) == 0)
                               break;
                           }
                         }
                         bol_str_arg_l_known = true;
                         achl_arg = achl_arg_temp;
                         break;
                       case ied_chs_oem_437:
                         for (ull_str_arg_l=0; ull_str_arg_l<ill_maxtarglen; ull_str_arg_l++) {
                           u_tmp = m_u32_to_sb_80a0(
                                     ausl_tt[*((unsigned char*)achl_arg+ull_str_arg_l)],
                                     am_backtrans,
                                     aunl_back_ti,
                                     aucl_back_tt
                                   );
                           if (u_tmp==ASCII_REP_CHAR) {
                             if (*((unsigned char*)achl_arg+ull_str_arg_l) < 0x80) {
                               /* fall back to the official identity (that also exists in the target) */
                               u_tmp = *((unsigned char*)achl_arg+ull_str_arg_l);
                             }
                           }
                           if ((*(achl_arg_temp+ull_str_arg_l) = u_tmp) == 0)
                             break;
                         }
                         bol_str_arg_l_known = true;
                         achl_arg = achl_arg_temp;
                         break;
                       CASE_IED_CHS_ALL_CJK
                         iml_str_len=0;     /* source index            */
                         ull_str_arg_l=0;   /* target index            */
                         do {
                           u_tmp = ausl_fbtt[*((unsigned char*)achl_arg+iml_str_len)];
                           if (u_tmp == 0xFFFF) {  /* two-byte code    */
                             u_tmp = ausl_tt[((unsigned char*)achl_arg)[iml_str_len]<<8 | ((unsigned char*)achl_arg)[iml_str_len+1]];
                             if (!achl_arg[iml_str_len+1])  /* inconsistence */
                               break;
                             iml_str_len+=2;
                           } else {
                             iml_str_len++;
                           }
                           if ((
                                 *(achl_arg_temp+ull_str_arg_l) =
                                   m_u32_to_sb_80a0(
                                     u_tmp,
                                     am_backtrans,
                                     aunl_back_ti,
                                     aucl_back_tt
                                   )
                               ) == 0)
                             break;
                         } while (++ull_str_arg_l < ill_maxtarglen);
                         bol_str_arg_l_known = true;
                         achl_arg = achl_arg_temp;
                         break;
                       default:             /* codepages 874/125?/8859 */
                         for (ull_str_arg_l=0; ull_str_arg_l<ill_maxtarglen; ull_str_arg_l++) {
                           if ((
                                 *(achl_arg_temp+ull_str_arg_l) =
                                   m_u32_to_sb_80a0(
                                     ausl_tt[*((unsigned char*)achl_arg+ull_str_arg_l)],
                                     am_backtrans,
                                     aunl_back_ti,
                                     aucl_back_tt
                                   )
                               ) == 0)
                             break;
                         }
                         bol_str_arg_l_known = true;
                         achl_arg = achl_arg_temp;
                         break;
                     }
                   } break;  /* end of misc. singlebyte-codepage target cases */
                   CASE_IED_CHS_ISO8859_2TO16 {
                     unsigned long ill_maxtarglen =  (bol_precision ? ull_precision : MAX_STR_LENGTH);
                     if (iel_cs_source == iel_cs_target)
                       break;               /* no change               */
                     switch (iel_cs_source) {
                       case ied_chs_invalid:  /* faulty format         */
                         break;
                       case ied_chs_ansi_819:
                         for (ull_str_arg_l=0; ull_str_arg_l<ill_maxtarglen; ull_str_arg_l++) {
                           u_tmp = *((unsigned char*)achl_arg+ull_str_arg_l);
                           if (u_tmp >= 0xA1) {
                             /* first tablepart runs upto U+00FF, and unrg_tabindex_uni_to_*[0] is always 0xA0 */
                             u_tmp -= 0xA0;
                             if ((
                                   *(achl_arg_temp+ull_str_arg_l) =
                                     ((u_tmp>=aunl_back_ti[3])
                                       ? ASCII_REP_CHAR
                                       : aucl_back_tt[u_tmp]
                                     )
                                 ) == 0)
                               *(achl_arg_temp+ull_str_arg_l) = ASCII_REP_CHAR;
                           } else {         /* lower 161 bytes, equal  */
                             if ((*(achl_arg_temp+ull_str_arg_l) = u_tmp) == 0)
                               break;
                           }
                         }
                         bol_str_arg_l_known = true;
                         achl_arg = achl_arg_temp;
                         break;
                       case ied_chs_ascii_850:
                         for (ull_str_arg_l=0; ull_str_arg_l<ill_maxtarglen; ull_str_arg_l++) {
                           u_tmp = ucrg_tab_850_to_819[*((unsigned char*)achl_arg+ull_str_arg_l)];
                           if (u_tmp >= 0xA1) {
                             /* first tablepart runs upto U+00FF, and unrg_tabindex_uni_to_*[0] is always 0xA0 */
                             u_tmp -= 0xA0;
                             if ((
                                   *(achl_arg_temp+ull_str_arg_l) =
                                     ((u_tmp>=aunl_back_ti[3])
                                       ? ASCII_REP_CHAR
                                       : aucl_back_tt[u_tmp]
                                     )
                                 ) == 0)
                               *(achl_arg_temp+ull_str_arg_l) = ASCII_REP_CHAR;
                           } else {         /* lower 161 bytes, equal  */
                             if ((*(achl_arg_temp+ull_str_arg_l) = u_tmp) == 0)
                               break;
                           }
                         }
                         bol_str_arg_l_known = true;
                         achl_arg = achl_arg_temp;
                         break;
                       case ied_chs_oem_437:
                         for (ull_str_arg_l=0; ull_str_arg_l<ill_maxtarglen; ull_str_arg_l++) {
                           u_tmp = m_u32_to_sb_a1a0(
                                     ausl_tt[*((unsigned char*)achl_arg+ull_str_arg_l)],
                                     am_backtrans,
                                     aunl_back_ti,
                                     aucl_back_tt
                                   );
                           if (u_tmp==ASCII_REP_CHAR) {
                             if (*((unsigned char*)achl_arg+ull_str_arg_l) < 0x80) {
                               /* fall back to the official identity (that also exists in the target) */
                               u_tmp = *((unsigned char*)achl_arg+ull_str_arg_l);
                             }
                           }
                           if ((*(achl_arg_temp+ull_str_arg_l) = u_tmp) == 0)
                             break;
                         }
                         bol_str_arg_l_known = true;
                         achl_arg = achl_arg_temp;
                         break;
                       CASE_IED_CHS_ALL_CJK
                         iml_str_len=0;     /* source index            */
                         ull_str_arg_l=0;   /* target index            */
                         do {
                           u_tmp = ausl_fbtt[*((unsigned char*)achl_arg+iml_str_len)];
                           if (u_tmp == 0xFFFF) {  /* two-byte code    */
                             u_tmp = ausl_tt[((unsigned char*)achl_arg)[iml_str_len]<<8 | ((unsigned char*)achl_arg)[iml_str_len+1]];
                             if (!achl_arg[iml_str_len+1])  /* inconsistence */
                               break;
                             iml_str_len+=2;
                           } else {
                             iml_str_len++;
                           }
                           if ((
                                 *(achl_arg_temp+ull_str_arg_l) =
                                   m_u32_to_sb_a1a0(
                                     u_tmp,
                                     am_backtrans,
                                     aunl_back_ti,
                                     aucl_back_tt
                                   )
                               ) == 0)
                             break;
                         } while (++ull_str_arg_l < ill_maxtarglen);
                         bol_str_arg_l_known = true;
                         achl_arg = achl_arg_temp;
                         break;
                       default:             /* codepages 874/125?/8859 */
                         for (ull_str_arg_l=0; ull_str_arg_l<ill_maxtarglen; ull_str_arg_l++) {
                           if ((
                                 *(achl_arg_temp+ull_str_arg_l) =
                                   m_u32_to_sb_a1a0(
                                     ausl_tt[*((unsigned char*)achl_arg+ull_str_arg_l)],
                                     am_backtrans,
                                     aunl_back_ti,
                                     aucl_back_tt
                                   )
                               ) == 0)
                             break;
                         }
                         bol_str_arg_l_known = true;
                         achl_arg = achl_arg_temp;
                         break;
                     }
                   } break;  /* end of ISO-8859-codepage target cases */
                   CASE_IED_CHS_ALL_CJK
                     bol_str_arg_l_known = true;
                     iml_str_len = 0;
                     switch (iel_cs_source) {
                       case ied_chs_ascii_850:
                         for (ull_str_arg_l=0; (ull_str_arg_l<MAX_STR_LENGTH) && achl_arg[iml_str_len]; ull_str_arg_l++) {
                           u_tmp = awcl_back_t[ucrg_tab_850_to_819[(unsigned char)achl_arg[iml_str_len]]];
                           if (u_tmp >= 0x100) {  /* two-byte code     */
                             achl_arg_temp[ull_str_arg_l++] = (unsigned char)(u_tmp>>8);
                             if (ull_str_arg_l==MAX_STR_LENGTH) {
                               achl_arg_temp[--ull_str_arg_l] = '\0';
                               break;
                             }
                           }
                           achl_arg_temp[ull_str_arg_l] = (unsigned char)(u_tmp);
                           if ((size_t)(++iml_str_len) == ull_precision) {
                             ull_str_arg_l++;
                             break;
                           }
                         }
                         achl_arg = achl_arg_temp;
                         break;
                       case ied_chs_ansi_819:
                         for (ull_str_arg_l=0; (ull_str_arg_l<MAX_STR_LENGTH) && achl_arg[iml_str_len]; ull_str_arg_l++) {
                           u_tmp = awcl_back_t[(unsigned char)achl_arg[iml_str_len]];
                           if (u_tmp >= 0x100) {  /* two-byte code     */
                             achl_arg_temp[ull_str_arg_l++] = (unsigned char)(u_tmp>>8);
                             if (ull_str_arg_l==MAX_STR_LENGTH) {
                               achl_arg_temp[--ull_str_arg_l] = '\0';
                               break;
                             }
                           }
                           achl_arg_temp[ull_str_arg_l] = (unsigned char)(u_tmp);
                           if ((size_t)(++iml_str_len) == ull_precision) {
                             ull_str_arg_l++;
                             break;
                           }
                         }
                         achl_arg = achl_arg_temp;
                         break;
                       CASE_IED_CHS_ALL_CJK
                         if (iel_cs_source == iel_cs_target) {
                           if(ull_precision > 0){
                             ull_str_arg_l = m_strlen_with_cjkl( achl_arg, iel_cs_source, ull_precision );
                           } else {
                             ull_str_arg_l = strlen(achl_arg);
                           }
                           break;           /* no change               */
                         }
                         iml_str_len = (signed int)ull_precision;
                         for (ull_str_arg_l=0; (ull_str_arg_l<MAX_STR_LENGTH) && *achl_arg; ull_str_arg_l++) {
                           u_tmp = ausl_fbtt[*((unsigned char*)achl_arg)];
                           if (u_tmp==0xFFFF) {
                             u_tmp = ausl_tt[*((unsigned char*)achl_arg)<<8 | ((unsigned char*)achl_arg)[1]];
                             achl_arg+=2;
                           } else {
                             achl_arg++;
                           }
                           u_tmp = awcl_back_t[u_tmp];
                           if (u_tmp >= 0x100) {  /* two-byte code     */
                             achl_arg_temp[ull_str_arg_l++] = (unsigned char)(u_tmp>>8);
                             if (ull_str_arg_l==MAX_STR_LENGTH) {
                               achl_arg_temp[--ull_str_arg_l] = '\0';
                               break;
                             }
                           }
                           achl_arg_temp[ull_str_arg_l] = (unsigned char)(u_tmp);
                           if (--iml_str_len == 0) {
                             ull_str_arg_l++;
                             break;
                           }
                         }
                         achl_arg = achl_arg_temp;
                         break;
                       case ied_chs_invalid:  /* faulty format         */
                         bol_str_arg_l_known = false;
                         break;
                       default:             /* codepages 437/874/125?/8859 */
                         for (ull_str_arg_l=0; (ull_str_arg_l<MAX_STR_LENGTH) && achl_arg[iml_str_len]; ull_str_arg_l++) {
                           u_tmp = awcl_back_t[ausl_tt[(unsigned char)achl_arg[iml_str_len]]];
                           if (u_tmp >= 0x100) {  /* two-byte code     */
                             achl_arg_temp[ull_str_arg_l++] = (unsigned char)(u_tmp>>8);
                             if (ull_str_arg_l==MAX_STR_LENGTH) {
                               achl_arg_temp[--ull_str_arg_l] = '\0';
                               break;
                             }
                           }
                           achl_arg_temp[ull_str_arg_l] = (unsigned char)(u_tmp);
                           if ((size_t)(++iml_str_len) == ull_precision) {
                             ull_str_arg_l++;
                             break;
                           }
                         }
                         achl_arg = achl_arg_temp;
                         break;
                     }
                     break;   /* end of CJK MBCS codepage target cases */
                   case ied_chs_utf_8:
                     switch (iel_cs_source) {
                       case ied_chs_invalid:  /* faulty format         */
                         break;
                       CASE_IED_CHS_ALL_CJK
                         ull_str_arg_l =
                           m_u8l_from_mbsl(
                             achl_arg_temp,
                             MAX_STR_LENGTH,
                             (char *) achl_arg,
                             bol_precision ? m_strlen_with_cjkl(achl_arg, iel_cs_source,
                                                                ull_precision)
                                           : strlen(achl_arg),
                             ausl_fbtt,
                             ausl_tt
                           );
                         break;
                       case ied_chs_ascii_850:
                         ull_str_arg_l =
                           m_u8l_from_a850l(
                             achl_arg_temp,
                             MAX_STR_LENGTH,
                             (char *) achl_arg,
                             bol_precision ? m_strlen_upto_precision(achl_arg, ull_precision)
                                           : strlen(achl_arg)
                           );
                         break;
                       case ied_chs_ansi_819:
                         ull_str_arg_l =
                           m_u8l_from_a819l(
                             achl_arg_temp,
                             MAX_STR_LENGTH,
                             (char *) achl_arg,
                             bol_precision ? m_strlen_upto_precision(achl_arg, ull_precision)
                                           : strlen(achl_arg)
                           );
                         break;
                       default:             /* codepages 437/874/125?/8859 */
                         ull_str_arg_l =
                           m_u8l_from_sbsl(
                             achl_arg_temp,
                             MAX_STR_LENGTH,
                             (char *) achl_arg,
                             bol_precision ? m_strlen_upto_precision(achl_arg, ull_precision)
                                           : strlen(achl_arg),
                             ausl_tt
                           );
                         break;
                     }
                     bol_str_arg_l_known = true;
                     achl_arg = achl_arg_temp;
                     break;        /* end of ied_chs_utf_8 target case */
                   default:
                     break;
                 }
               }
               else {  /* adsl_arginfs is set, (ucs) format with struct */
                 /* an argument for max. length, that does not trigger a return(-1)-error,
                    could avoid superfluous copying if(bol_precision)
                    (maybe for some formats with an imprecise upper bound).
                    This could also save the if (adsl_arginfs && ...) (the if and the
                    then-part) below that sets ull_str_arg_l. */
                 ull_str_arg_l = m_cpy_vx_ucs( achl_arg_temp, MAX_STR_LENGTH, iel_cs_target, adsl_arginfs );
                 bol_str_arg_l_known = true;
                 achl_arg = achl_arg_temp;
               }
               if (!achl_arg) {
                 ull_str_arg_l = 0;
               }
               else if(!bol_precision || bol_dot_period == false ){
                 if (!bol_str_arg_l_known)
                   ull_str_arg_l = strlen(achl_arg);
               }
               else if (ull_precision == 0) {
                 ull_str_arg_l = 0;
               }
               else {
                 if (bol_str_arg_l_known) {
                   switch (iel_cs_target) {
                     case ied_chs_utf_8:
                       if (adsl_arginfs) {
                         if (adsl_arginfs->imc_len_str == -1)  /* zero-terminated */
                           ull_str_arg_l = m_strlen_with_u8l( achl_arg_temp,
                                                              ull_precision );
                         else
                           ull_str_arg_l = m_count_with_u8l( achl_arg_temp,
                                                             ull_precision, ull_str_arg_l );
                       }
                       break;
                     CASE_IED_CHS_ALL_CJK
                       if (adsl_arginfs) {
                         if (adsl_arginfs->imc_len_str == -1)  /* zero-terminated */
                           ull_str_arg_l = m_strlen_with_cjkl( achl_arg_temp, iel_cs_target,
                                                               ull_precision );
                         else
                           ull_str_arg_l = m_count_with_cjkl( achl_arg_temp, iel_cs_target,
                                                              ull_precision, ull_str_arg_l );
                       }
                       break;
                     default:
                       if (ull_precision < ull_str_arg_l)
                         ull_str_arg_l = ull_precision;
                       break;
                   }
                 }
                 else {
                   ull_str_arg_l = m_strlen_upto_precision( achl_arg, ull_precision );
                 }
               }
#ifdef TRACEHL1
#if _RWDEBUG
               if( ull_utftype) {
                 printf("converted string length: %d\n\n", ull_str_arg_l );
               }
#endif
#endif
               break;
             default:
               break;
           }
           achl_format++;
           if ((signed)ull_str_arg_l < 0)           /* error                   */
             break;
           bool bol_check_mb_abort = false;
           char* achl_pad_end = NULL;       /* end of right-padding    */
           if (ull_field_width > 0) {
             /* adjust ull_field_width to bytes, like ull_str_arg_l is */
             unsigned int unl1;
             HL_WCHAR* awcl_fb;
             switch (iel_cs_target) {
               case ied_chs_utf_8:
                 if (bol_precision) {
                   int inl_checklimit = ull_precision + 1;
                   for (unl1=0; unl1<ull_str_arg_l && inl_checklimit>0; unl1++) {
                     if ((*(achl_arg+unl1) & 0xC0) == 0x80) {
                       ull_field_width ++;
                     } else {
                       inl_checklimit --;
                     }
                   }
                 } else {
                   for (unl1=0; unl1<ull_str_arg_l; unl1++) {
                     if ((*(achl_arg+unl1) & 0xC0) == 0x80)
                       ull_field_width ++;
                     /* if ull_field_width is too narrow, this is not precise, but ok */
                   }
                 }
                 break;
               CASE_IED_CHS_ALL_CJK
                 awcl_fb = m_get_tab_mb_firstbytes(iel_cs_target);
                 if (bol_precision) {
                   int inl_checklimit = ull_precision;
                   for (unl1=0; unl1<ull_str_arg_l && inl_checklimit>0; unl1++) {
                     if (awcl_fb[*(unsigned char*)(achl_arg+unl1)] == 0xFFFF) {
                       ull_field_width ++;
                       unl1 ++;
                     }
                     inl_checklimit --;
                   }
                 } else {
                   for (unl1=0; unl1+1<ull_str_arg_l; unl1++) {
                     if (awcl_fb[*(unsigned char*)(achl_arg+unl1)] == 0xFFFF) {
                       ull_field_width ++;
                       unl1 ++;
                     } /* if ull_field_width is too narrow - see above */
                   }
                 }
                 break;
               default:                     /* is already in bytes     */
                 break;
             }
           }
           if (ull_field_width > ull_str_arg_l) {
             int iml_padcounter;
             if (achl_cur + ull_field_width > achl_end) {
               if (bol_adjustleft) {
                 if (achl_cur + ull_str_arg_l > achl_end) {
                   iml_padcounter = 0;
                   ull_str_arg_l = achl_end - achl_cur;
                   bol_check_mb_abort = TRUE;
                 } else {
                   iml_padcounter = (achl_end - achl_cur) - ull_str_arg_l;
                 }
               } else {                     /* adjust right, padd left */
                 iml_padcounter = (int)ull_field_width - ull_str_arg_l;
                 if (achl_cur + iml_padcounter > achl_end) {
                   ull_str_arg_l = 0;
                   iml_padcounter = achl_end - achl_cur;
                 } else {
                   ull_str_arg_l = (achl_end - achl_cur) - iml_padcounter;
                   bol_check_mb_abort = TRUE;
                 }
               }
             } else {
               iml_padcounter = (int)ull_field_width - ull_str_arg_l;
             }
             if (bol_adjustleft) {
               char* achl_pad_cur = achl_cur + ull_str_arg_l;
               if (iml_padcounter > 0) {
                 achl_pad_end = achl_pad_cur + iml_padcounter;
                 do
                   *achl_pad_cur++ = ' ';
                 while (achl_pad_cur < achl_pad_end);
               }
             } else {
               while (iml_padcounter--)
                 *achl_cur++ = ' ';
             }
           } else {
             if (achl_cur + ull_str_arg_l > achl_end) {
               ull_str_arg_l = achl_end - achl_cur;
               bol_check_mb_abort = TRUE;
             }
           }
           if (bol_check_mb_abort) {
             /* if target ends within one character, discard its beginning */
             bool bol_max_len_target_reached;
             HL_WCHAR* awcl_fb;
             unsigned char* aucl_t;
             unsigned char* aucl_t_stop;
             switch(iel_cs_target) {
               case ied_chs_utf_8:
                 bol_max_len_target_reached = (achl_cur + ull_str_arg_l >= achl_end);
                 while ( ((achl_arg[ull_str_arg_l]&0xC0) == 0x80) && (ull_str_arg_l > 0) )
                   ull_str_arg_l --;
                 if (bol_max_len_target_reached)
                   achl_end = achl_cur + ull_str_arg_l;  /* to break the big loop */
                 break;
               CASE_IED_CHS_ALL_CJK
                 aucl_t = (unsigned char*)achl_arg;
                 aucl_t_stop = aucl_t+ull_str_arg_l;
                 awcl_fb = m_get_tab_mb_firstbytes(iel_cs_target);
                 while (aucl_t < aucl_t_stop) {
                   if ( awcl_fb[*(aucl_t++)]==0xFFFF ) {
                     if (aucl_t == aucl_t_stop) {
                       if (achl_cur + ull_str_arg_l >= achl_end)
                         achl_end --;       /* to break the big loop   */
                       ull_str_arg_l --;
                       break;
                     }
                     aucl_t++;
                   }
                 }
                 break;
               default:                     /* problem will not occurr */
                 break;
             }
           }
           while(ull_str_arg_l-- > 0) {
               *achl_cur = *achl_arg;
                achl_cur++;
                achl_arg++;
           }
           if (achl_pad_end != NULL)
             achl_cur = achl_pad_end;
           break;
         }
         case 5: case 7: {  /* p  f e E g G; use builtin sprintf */
           int         iml_arg1 = 0;
           int         inl_sign = 0;
           unsigned int uml_arg = 0;
           HL_LONGLONG  ill_arg = 0;
           HL_ULONGLONG ull_arg = 0;
           void        *avo_arg = NULL;
           double       dbl_arg = 0;
           long double  ldl_arg = 0;
           int ull_prefixlen = 0;
           if(adsl_arginfs!=NULL) {
             printf("Error: (ucs) with numeric type in format");
             break;
           }
#ifdef TRACEHL1
#if _RWDEBUG
           printf("numeric values: %c\n", *achl_format );
#endif
#endif
           ull_str_arg_l = 0;
           if(umrs_format[(UINT) chl_spec] == 7) {  /* p               */
             avo_arg = va_arg(dsl_list, void *);
             inl_sign = 2;  /* avoid the zero-suppression if precision 0 */
#ifdef HL_HPUX
             if (bol_alternate_form) {
               chrl_tmp[ull_str_arg_l++] = '0';
               chrl_tmp[ull_str_arg_l++] = 'x';
             }
#endif
           }
           else { /* signed: f  E  e  G g */
             if(chl_length_modifier == 'L'){
               ldl_arg = va_arg(dsl_list, long double);
               if (ldl_arg > 0) inl_sign = 1;
               else
#ifdef signbit
                 if(signbit(ldl_arg)) inl_sign = -1;
#else
#if defined(WIN32)|| defined(WIN64)
                 if(_copysign(1.0,(double)ldl_arg) < 0) inl_sign = -1;
#else
                 /* this fallback will not catch negative zero, so formatting that with "%04g" will print "00-0"! */
                 if(ldl_arg < 0) inl_sign = -1;
#endif
#endif
             }
             else {
               dbl_arg = va_arg(dsl_list, double);
               if (dbl_arg > 0) inl_sign = 1;
               else
#ifdef signbit
                 if(signbit(dbl_arg)) inl_sign = -1;
#else
#if defined(WIN32)|| defined(WIN64)
                 if(_copysign(1.0,dbl_arg) < 0) inl_sign = -1;
#else
                 /* this fallback will not catch negative zero, so formatting that with "%04g" will print "00-0"! */
                 if(dbl_arg < 0) inl_sign = -1;
#endif
#endif
             }
             if(achl_signed[1+inl_sign]) {
               chrl_tmp[ull_str_arg_l++] = achl_signed[1+inl_sign];
             }
           }
           achl_arg = chrl_tmp;

           ull_prefixlen = inl_sign<0 ? ull_str_arg_l+1 : ull_str_arg_l;
           if(!bol_precision) ull_precision = 6; /* default precision UUU which is different for %g,
             but this should only have an effect with .* with negative arg, which seems to have
             always been handled not like the spec says. Why there are two bol_ flags for this? */
           if(ull_precision != 0 || inl_sign != 0 || umrs_format[(UINT) chl_spec] == 5) {
             char ach_f[10];
             int ach_f_l = 0;
             ach_f[ach_f_l++] = '%';
             if ( bol_alternate_form && (umrs_format[(UINT) chl_spec] == 5) ) {
               ach_f[ach_f_l++] = '#';
             }
             if( bol_dot_period)
             {
               ach_f[ach_f_l++] = '.';
               ach_f_l += sprintf(ach_f + ach_f_l, "%d", (int) ull_precision);
             }
             if( chl_length_modifier )
             {
               if(bol_longlong) {
#ifdef HL_UNIX
                memcpy(&ach_f[ach_f_l], "ll", 2);
                ach_f_l += 2;
#else
                memcpy(&ach_f[ach_f_l], "I64", 3);
                ach_f_l += 3;
#endif
               }
               else {
                 ach_f[ach_f_l++] = chl_length_modifier;
               }
             }
             ach_f[ach_f_l++] = chl_spec;
             if(umrs_format[(UINT) chl_spec] == 7) {  /* pointer       */
               ach_f[ach_f_l] = '\0';
               ull_str_arg_l += sprintf(chrl_tmp + ull_str_arg_l, ach_f, avo_arg);
             }
             else {                         /* float                   */
               ach_f[ach_f_l] = '\0';
               if( chl_length_modifier == 'L')
                 ull_str_arg_l += sprintf(chrl_tmp + ull_str_arg_l, ach_f, ldl_arg);
               else
                 ull_str_arg_l += sprintf(chrl_tmp + ull_str_arg_l, ach_f, dbl_arg);
             }
           }
           int inl_auxcount = ull_str_arg_l;
           if (bol_adjustleft == false && ull_field_width > ull_str_arg_l) {
             char chl_pad;
             int n = (int)ull_field_width - ull_str_arg_l;
             if (bol_padding_zero == true) {
               if (ull_prefixlen) {
                 char* achl_digitstart;
                 if (achl_end - ull_prefixlen < achl_cur) {
                   achl_digitstart = achl_end;
                   inl_auxcount = 0;
                 } else {
                   achl_digitstart = achl_cur + ull_prefixlen;
                   inl_auxcount -= ull_prefixlen;
                 }
                 do {
                   *achl_cur++ = *achl_arg++;
                 } while (achl_cur<achl_digitstart);
               }
               chl_pad = '0';
             } else {
               chl_pad = ' ';
             }
             if (achl_end - n < achl_cur)
               n = achl_end - achl_cur;
             while(n-- > 0) {
                 *achl_cur++ = chl_pad;
             }
           }
           achl_format++;
           if (achl_end - inl_auxcount < achl_cur)
             inl_auxcount = achl_end - achl_cur;
           while(inl_auxcount-- > 0) {
             *achl_cur++ = *achl_arg++;
           }
           if( bol_adjustleft == true && ull_field_width > ull_str_arg_l) {
             inl_auxcount = (int)ull_field_width - ull_str_arg_l;
             if (achl_end - inl_auxcount < achl_cur)
               inl_auxcount = achl_end - achl_cur;
             while(inl_auxcount-- > 0) {
                 *achl_cur++ = ' ';
             }
           }
           break;
         }
         case 4: case 6: {  /* D  d  i  O  o  X  x  U  u */
#define D_L1000RD 9999 /* UUU keeps more info, 9500 would be more consistent */
#define D_L1024RD 9999 /* UUU keeps more info, 9728 would be more consistent */
#define DECBASE 10
#define HL_WCHAR_CAST(X) (HL_WCHAR)(X)
           char *achl_m;                    /* marker in output string */
           char *achl0;
           char *achl_dg;                   /* digitgroup separator, output encoded */
           char *achl_after = achl_cur;
/* macro for padding etc in integer output                           { */
/* } end macro for padding etc in integer output                       */
/* macro for hexadecimal or octal integer output                     { */
/* } end macro for hexadecimal or octal integer output                 */
/* macro for decimal integer digitgroups output with div-variant     { */
/* } end macro for decimal integer digitgroups output with div-variant */
/* macro for decimal integer output                                  { */
/* } end macro for decimal integer output                              */
/* macro defining variables for integer output                       { */
/* } end macro defining variables for integer output                   */
/* macro for integer output                                          { */
/* } end macro for integer output                                      */
           static const HL_ULONGLONG ullrs_decpowbuf[(sizeof(HL_ULONGLONG)*240824)/100000+1]
               = {1uLL, 10uLL, 100uLL, 1000uLL, 10000uLL, 100000uLL, 1000000uLL, 10000000uLL,
                  100000000uLL, 1000000000uLL, 10000000000uLL, 100000000000uLL, 1000000000000uLL,
                  10000000000000uLL, 100000000000000uLL, 1000000000000000uLL, 10000000000000000uLL,
                  100000000000000000uLL, 1000000000000000000uLL, 10000000000000000000uLL};
           static const unsigned int unrs_decpowbuf[(sizeof(unsigned int)*240824)/100000+1]
               = {1, 10, 100, 1000, 10000, 100000, 1000000, 10000000, 100000000, 1000000000};
           /* assuming int always 32-bit and long long int always 64-bit (KB to WS 29.1.2015) */
           int         iml_arg1 = 0;
           int         inl_sign = 0;
           unsigned int uml_arg = 0;
           HL_LONGLONG  ill_arg = 0;
           HL_ULONGLONG ull_arg = 0;
           void        *avo_arg = NULL;
           double       dbl_arg = 0;
           long double  ldl_arg = 0;
           int    ull_prefixlen = 0;
           int inl_s;                       /* auxiliary variable      */
           int inl_emax;  /* number of pure digits needed, exponent of most significant non-0 digit plus 1 */
           int inl_needed;  /* number of output chars, without fieldwidth-padding */
           const char *achl_digits;         /* number-to-hexchar table */
           int inl_dgsp_lo;  /* length of digits-separator in output units */
#ifdef HL_USE_DIV
           div_t dsl_diggrp_dm;
#define    inl_dgsp_ph dsl_diggrp_dm.rem    /* phase within digitgroup */
#define    inl_dgsp_tm dsl_diggrp_dm.quot
#else
           int inl_dgsp_ph;                 /* phase within digitgroup */
           int inl_dgsp_tm;                 /* digitgroup separators to come */
#endif
           int inl_precpad;
           char chl_postfix;
           int inl_postfixlen = 0;
           int inl_pfdgph = 0;
           int inl_padsp; 
           char chl_sign;
           if(adsl_arginfs!=NULL) {
             printf("Error: (ucs) with numeric type in format");
             break;
           }
#ifdef TRACEHL1
#if _RWDEBUG
           printf("numeric values: %c\n", *achl_format );
#endif
#endif
           ull_str_arg_l = 0;
           if(umrs_format[(UINT) chl_spec] == 6) { /* Signed: d D i    */
             chl_spec = 'd';
             switch(chl_length_modifier) {
               case '\0': case 'h':
                 iml_arg1 = va_arg(dsl_list, int);
                       /* determine sign and go on with non-negative X */
                       if (iml_arg1 > 0) {
                         chl_sign = achl_signed[2];
                       } else {
                         if (iml_arg1 != 0)
                         {
                           chl_sign = achl_signed[0];
                           iml_arg1=0-iml_arg1; /* replace negative X by its abs-value */
                           if ((signed int)iml_arg1<0) {  /* special case: X was the extreme negative value */
                             /*inl_emax = (((sizeof(signed int)*8-1)*30103)/100000)+1;*/
                             iml_arg1=(signed int)(-1)-iml_arg1; /* 7fff... */
                             if (iel_scaling==ied_scaling_none) {
                               chl_postfix = '1'+iml_arg1%DECBASE;  /* decimal carry cannot happen here */
                               inl_postfixlen = 1;
                               inl_pfdgph = 1;
                               ull_precision--;
                               iml_arg1/=DECBASE;
                             }
                           }
                         } else {
                           chl_sign = achl_signed[1];
                         }
                       }
                       inl_needed = chl_sign?1:0;

                       /* prepare %(sci-dec)- or %(sci-dec)-type of rendering */
                       if (iel_scaling!=ied_scaling_none) {
                         if (iel_scaling == ied_scaling_1000) {  /* power-of-1000-scaled */
#if HL_PRFMAXSO_I > 4
                           if ((sizeof(signed int) > 4) && (iml_arg1 >= D_L1000RD * unrs_decpowbuf[9])) {
#if HL_PRFMAXSO_I > 8
                             if (
                                 (sizeof(signed int) > 8) &&
                                 (iml_arg1 >= D_L1000RD * unrs_decpowbuf[15])
                                ) {
                               if (
                                   (iml_arg1 >= D_L1000RD * unrs_decpowbuf[18])
                                  ) {
                                 if (iml_arg1 >= D_L1000RD * unrs_decpowbuf[21]) {
                                   iml_arg1 =  (iml_arg1 + 500 * unrs_decpowbuf[21]) / (unrs_decpowbuf[24]);
                                   chl_postfix = 'Y';
                                 } else {
                                   iml_arg1 =  (iml_arg1 + 500 * unrs_decpowbuf[18]) / (unrs_decpowbuf[21]);
                                   chl_postfix = 'Z';
                                 }
                               } else {
                                 iml_arg1 =  (iml_arg1 + 500 * unrs_decpowbuf[15]) / (unrs_decpowbuf[18]);
                                 chl_postfix = 'E';
                               }
                             } else {
#endif
                               if (iml_arg1 >= D_L1000RD * unrs_decpowbuf[12]) {
                                 iml_arg1 =  (iml_arg1 + 500 * unrs_decpowbuf[12]) / (unrs_decpowbuf[15]);
                                 chl_postfix = 'P';
                               } else {
                                 iml_arg1 =  (iml_arg1 + 500 * unrs_decpowbuf[9]) / (unrs_decpowbuf[12]);
                                 chl_postfix = 'T';
                               }
#if HL_PRFMAXSO_I > 8
                             }
#endif
                             inl_postfixlen = 1;
                           } else {
#endif
#if HL_PRFMAXSO_I > 2
                             if ((sizeof(signed int) > 2) && (iml_arg1 >= D_L1000RD * unrs_decpowbuf[3])) {
#if HL_PRFMAXSO_I > 4
                               if ((sizeof(signed int) > 4) && (iml_arg1 >= D_L1000RD * unrs_decpowbuf[6])) {
                                 iml_arg1 =  (iml_arg1 + 500 * unrs_decpowbuf[6]) / (unrs_decpowbuf[9]);
                                 chl_postfix = 'G';
                               } else {
#endif
                                 iml_arg1 =  (iml_arg1 + 500 * unrs_decpowbuf[3]) / (unrs_decpowbuf[6]);
                                 chl_postfix = 'M';
#if HL_PRFMAXSO_I > 4
                               }
#endif
                               inl_postfixlen = 1;
                             } else {
#endif
                               if (iml_arg1 >= D_L1000RD) {
                                 iml_arg1 = (iml_arg1 + 500) / 1000;
                                 chl_postfix = 'k';
                                 inl_postfixlen = 1;
                               }
#if HL_PRFMAXSO_I > 2
                             }
#endif
#if HL_PRFMAXSO_I > 4
                           }
#endif
                         }
                         else {               /* power-of-1024-scaled    */
#if HL_PRFMAXSO_I > 4
                           if ((sizeof(signed int) > 4) && (iml_arg1>>30 >= D_L1024RD)) {
#if HL_PRFMAXSO_I > 8
                             if (
                                 (sizeof(signed int) > 8) &&
                                 (iml_arg1>>50 >= D_L1024RD)
                                ) {
                               if (
                                   (iml_arg1>>60 >= D_L1024RD)
                                  ) {
                                 if (iml_arg1>>70 >= D_L1024RD) {
                                   iml_arg1 = (iml_arg1+((signed int)1<<79)) >> 80;
                                   chl_postfix = 'Y';
                                 } else {
                                   iml_arg1 = (iml_arg1+((signed int)1<<69)) >> 70;
                                   chl_postfix = 'Z';
                                 }
                               } else {
                                 iml_arg1 = (iml_arg1+((signed int)1<<59)) >> 60;
                                 chl_postfix = 'E';
                               }
                             } else {
#endif
                               if (iml_arg1>>40 >= D_L1024RD) {
                                 iml_arg1 = (iml_arg1+((signed int)1<<49)) >> 50;
                                 chl_postfix = 'P';
                               } else {
                                 iml_arg1 = (iml_arg1+((signed int)1<<39)) >> 40;
                                 chl_postfix = 'T';
                               }
#if HL_PRFMAXSO_I > 8
                             }
#endif
                             inl_postfixlen = bol_alternate_form ? 2 : 1;
                           } else {
#endif
#if HL_PRFMAXSO_I > 2
                             if ((sizeof(signed int) > 2) && (iml_arg1>>10 >= D_L1024RD)) {
#if HL_PRFMAXSO_I > 4
                               if ((sizeof(signed int) > 4) && (iml_arg1>>20 >= D_L1024RD)) {
                                 iml_arg1 = (iml_arg1+((signed int)1<<29)) >> 30;
                                 chl_postfix = 'G';
                               } else {
#endif
                                 iml_arg1 = (iml_arg1+((signed int)1<<19)) >> 20;
                                 chl_postfix = 'M';
#if HL_PRFMAXSO_I > 4
                               }
#endif
                               inl_postfixlen = bol_alternate_form ? 2 : 1;
                             } else {
#endif
                               if (iml_arg1 >= D_L1024RD) {
                                 iml_arg1 = (iml_arg1+0x200) >> 10;
                                 chl_postfix = 'K';
                                 inl_postfixlen = bol_alternate_form ? 2 : 1;
                               }
#if HL_PRFMAXSO_I > 2
                             }
#endif
#if HL_PRFMAXSO_I > 4
                           }
#endif
                         }
                       }

                       /* detect the order of magnitude of X           */
                       inl_emax = 0;
                       if (iml_arg1) {
                         int inl_e = (((sizeof(signed int)*8-1)*30103)/100000)+1;
                         do {
                           inl_s = inl_e>>1;
                           if (iml_arg1 >= unrs_decpowbuf[inl_emax+inl_s]) {
                             inl_emax += inl_s;
                             inl_e -= inl_s;
                           } else {
                             inl_e = inl_s;
                           }
                         } while (inl_e>1);
                         inl_emax ++;
                       }
                       inl_needed += inl_emax + inl_postfixlen;
                       if (inl_dgsp_lc) {   /* use digit group separation */
                         if (inl_emax<=D_DIGGRPLEN) {  /* digit grouping not in effect */
                           inl_dgsp_lc = 0;
                         } else {
                           const int inl_emax_1 = inl_emax+inl_pfdgph-1;
#ifdef HL_USE_DIV
                           dsl_diggrp_dm = div(inl_emax_1, D_DIGGRPLEN);
                           inl_dgsp_ph++;
#else
                           inl_dgsp_tm = (inl_emax_1)/D_DIGGRPLEN;
                           inl_dgsp_ph = (inl_emax_1)%D_DIGGRPLEN+1;
#endif
                           if (inl_needed>=ull_field_width || inl_needed+inl_dgsp_tm*inl_dgsp_lc<=ull_field_width) {
                             inl_s = inl_dgsp_tm*inl_dgsp_lc;
                             inl_needed += inl_s;
                           } else {  /* prefer staying within fieldwidth over using the separator */
                             inl_dgsp_lc = 0;
                           }
                         }
                       }
                       if (!bol_precision) {
                         ull_precision = 1;  /* default precision      */
                         if (bol_padding_zero) {
                           if (ull_field_width>inl_needed && !bol_adjustleft) {
                             /* fake padding with '0' by ull_precision */
                             ull_precision = ull_field_width+(inl_dgsp_lc?inl_emax+inl_s:inl_emax)-inl_needed;
                           }
                         }
                       }
                       if (inl_dgsp_lc) {   /* using digit group separation */
                         inl_precpad = ull_precision-(inl_emax+inl_s);
                         if (inl_precpad>0) {
#ifdef HL_USE_DIV
                           div_t dsl_d = div(inl_dgsp_ph+inl_precpad, D_DIGGRPLEN+inl_dgsp_lc);
                           inl_dgsp_tm += dsl_d.quot;
                           inl_needed += inl_precpad;
                           inl_dgsp_ph = dsl_d.rem;
#else
                           inl_needed += inl_precpad;
                           inl_dgsp_tm += (inl_dgsp_ph+inl_precpad)/(D_DIGGRPLEN+inl_dgsp_lc);
                           inl_dgsp_ph = (inl_dgsp_ph+inl_precpad)%(D_DIGGRPLEN+inl_dgsp_lc);
#endif
                           if (inl_dgsp_ph>D_DIGGRPLEN) {
                             inl_needed -= inl_dgsp_ph-D_DIGGRPLEN;
                             inl_dgsp_ph = D_DIGGRPLEN;
                           }
                           inl_precpad = ull_precision-(inl_emax+inl_dgsp_tm*inl_dgsp_lc);
                         } else {
                           inl_precpad=0;
                         }
                       } else {    /* not using digit group separation */
                         inl_precpad = ull_precision-inl_emax;
                         if (inl_precpad>0) {
                           inl_needed += inl_precpad;
                         } else {
                           inl_precpad=0;
                         }
                       }
                       if (ull_field_width > inl_needed) {
                         achl_after = achl_cur+ull_field_width;
                         inl_padsp = ull_field_width-inl_needed;
                         if (!bol_adjustleft) {  /* padding left with spaces */
                           if (inl_padsp > achl_end-achl_cur)
                             {achl_after = achl_cur; break;}  /* overflow */
                           do
                             *achl_cur++ = (' ');
                           while (--inl_padsp);
                         }
                       } else {
                         achl_after = achl_cur+inl_needed;
                         inl_padsp = 0;
                       }
                       if (inl_dgsp_lc) {   /* set digit group separators */
                         if (chl_sign) {    /* write sign prefix       */
                           if (1 > achl_end-achl_cur)
                             {achl_after = achl_cur; break;}  /* overflow */
                           *achl_cur++ = (chl_sign);
                         }
                         /* produce the first separator                                     */
                         achl_dg = achl_cur+inl_dgsp_ph;
                         switch (iel_cs_target) {
                           case ied_chs_ascii_850:
                             inl_dgsp_lo = m_a850l_from_u8l( achl_dg, 1+achl_end-achl_dg, achl_dgsp, inl_dgsp_lb );
                             break;
                           case ied_chs_ansi_819:
                             inl_dgsp_lo = m_a819l_from_u8l( achl_dg, 1+achl_end-achl_dg, achl_dgsp, inl_dgsp_lb );
                             break;
                           CASE_IED_CHS_MISCCODEPAGES
                           CASE_IED_CHS_ISO8859_2TO16
                             inl_dgsp_lo = m_sbcl_from_u8l( achl_dg, 1+achl_end-achl_dg, iel_cs_target, achl_dgsp, inl_dgsp_lb );
                             break;
                           CASE_IED_CHS_ALL_CJK
                             inl_dgsp_lo = m_mbcl_from_u8l( achl_dg, 1+achl_end-achl_dg, awcl_back_t, achl_dgsp, inl_dgsp_lb, NULL );
                             break;
                           case ied_chs_utf_8:
                             memcpy( achl_dg, achl_dgsp, achl_end-achl_dg<inl_dgsp_lb?achl_end-achl_dg:inl_dgsp_lb );
                             inl_dgsp_lo = inl_dgsp_lb;
                             break;
                           default:
                             break;
                         }
                         /* now the complete physical output length can be determined      */
                         inl_s = inl_dgsp_tm*(inl_dgsp_lo-inl_dgsp_lc);  /* adjustment from logical to physical */
                         achl_after += inl_s;
                         if (inl_dgsp_lo<0 || achl_after-achl_cur>achl_end-achl_cur)
                           {achl_after = achl_cur; break;}  /* overflow */
                         /* copy the other separators from the first one                   */
                         inl_s = inl_dgsp_tm-1;
                         if (inl_s) {
                           achl0 = achl_dg+inl_dgsp_lo;
                           do {
                             achl0 += D_DIGGRPLEN;
                             int inl2 = 0;
                             do
                               *achl0++ = achl_dg[inl2++];
                             while (inl2<inl_dgsp_lo);
                           } while (--inl_s);
                         }
                         /* padding left with zeroes to "precision"                        */
                         while (inl_precpad) {
                           if (inl_dgsp_ph == 0) {  /* skip digits-separator */
                             achl_cur += inl_dgsp_lo;
                             inl_dgsp_ph = D_DIGGRPLEN-1;
                             inl_dgsp_tm--;
                             if (!inl_dgsp_tm)
                               break;
                           } else {
                             inl_dgsp_ph--;
                           }
                           *achl_cur++ = ('0');
                           inl_precpad --;
                         }
                       } else {             /* not using digit group separation */
                         if (achl_after-achl_cur>achl_end-achl_cur)
                           {achl_after = achl_cur; break;}  /* overflow */
                         if (chl_sign)      /* write sign prefix       */
                           *achl_cur++ = (chl_sign);
                         /* padding left with zeroes to "precision"    */
                         while (inl_precpad) {
                           *achl_cur++ = ('0');
                           inl_precpad --;
                         }
                       }
                       /* postfix                                      */
                       if (inl_postfixlen) {
                         if (inl_postfixlen==2) {
                           *(achl_after-(inl_padsp+2)) = (chl_postfix);
                           *(achl_after-(inl_padsp+1)) = ('i');
                         } else {
                           *(achl_after-(inl_padsp+1)) = (chl_postfix);
                         }
                       }
                       /* padding right with spaces                    */
                       if (inl_padsp) {
                         achl0 = achl_after-1;
                         do
                           *achl0-- = (' ');
                         while (--inl_padsp);
                       }
                       /* produce the digits                           */
                       if (inl_emax > 0) {
#ifdef HL_USE_DIV
                         if (sizeof(signed int)<=sizeof(int)) {
                           div_t dsl_d;
                           dsl_d = div(iml_arg1,DECBASE);
                           if (inl_dgsp_lc) {  /* using digit group separation */
                             achl_cur += inl_emax+inl_dgsp_tm*inl_dgsp_lo-1;
                             if (inl_dgsp_tm) {  /* write all digit groups that follow a separator */
                               inl_s=D_DIGGRPLEN-inl_pfdgph;
                               while (TRUE) {
                                 do {
                                   *(achl_cur)-- = ('0'+dsl_d.rem);
                                   dsl_d = div(dsl_d.quot,DECBASE);
                                 } while (--inl_s);
                                 achl_cur -= inl_dgsp_lo;  /* skip digits-separator */
                                 if (--inl_dgsp_tm==0)
                                   break;
                                 inl_s=D_DIGGRPLEN;
                               }
                             }
                             if (inl_dgsp_ph) {  /* precision may provoke leading separator */
                               while (TRUE) {   /* write leading (maybe partial) digit group */
                                 *achl_cur = ('0'+dsl_d.rem);
                                 if (--inl_dgsp_ph == 0) break;
                                 achl_cur--;
                                 dsl_d = div(dsl_d.quot,DECBASE);
                               }
                             }
                           } else {  /* not using digit group separation */
                             while (TRUE) {
                               *(achl_cur + --inl_emax) = ('0'+dsl_d.rem);
                               if (inl_emax <= 0) break;
                               dsl_d = div(dsl_d.quot,DECBASE);
                             }
                           }
#ifdef HL_USE_LDIV
                         } else if (sizeof(signed int)<=sizeof(long int)) {
                           ldiv_t dsl_d;
                           dsl_d = ldiv(iml_arg1,DECBASE);
                           if (inl_dgsp_lc) {  /* using digit group separation */
                             achl_cur += inl_emax+inl_dgsp_tm*inl_dgsp_lo-1;
                             if (inl_dgsp_tm) {  /* write all digit groups that follow a separator */
                               inl_s=D_DIGGRPLEN-inl_pfdgph;
                               while (TRUE) {
                                 do {
                                   *(achl_cur)-- = ('0'+dsl_d.rem);
                                   dsl_d = ldiv(dsl_d.quot,DECBASE);
                                 } while (--inl_s);
                                 achl_cur -= inl_dgsp_lo;  /* skip digits-separator */
                                 if (--inl_dgsp_tm==0)
                                   break;
                                 inl_s=D_DIGGRPLEN;
                               }
                             }
                             if (inl_dgsp_ph) {  /* precision may provoke leading separator */
                               while (TRUE) {   /* write leading (maybe partial) digit group */
                                 *achl_cur = ('0'+dsl_d.rem);
                                 if (--inl_dgsp_ph == 0) break;
                                 achl_cur--;
                                 dsl_d = ldiv(dsl_d.quot,DECBASE);
                               }
                             }
                           } else {  /* not using digit group separation */
                             while (TRUE) {
                               *(achl_cur + --inl_emax) = ('0'+dsl_d.rem);
                               if (inl_emax <= 0) break;
                               dsl_d = ldiv(dsl_d.quot,DECBASE);
                             }
                           }
#endif
#ifdef HL_USE_LLDIV
                         } else if (sizeof(signed int)<=sizeof(long long int)) {
                           lldiv_t dsl_d;
                           dsl_d = lldiv(iml_arg1,DECBASE);
                           if (inl_dgsp_lc) {  /* using digit group separation */
                             achl_cur += inl_emax+inl_dgsp_tm*inl_dgsp_lo-1;
                             if (inl_dgsp_tm) {  /* write all digit groups that follow a separator */
                               inl_s=D_DIGGRPLEN-inl_pfdgph;
                               while (TRUE) {
                                 do {
                                   *(achl_cur)-- = ('0'+dsl_d.rem);
                                   dsl_d = lldiv(dsl_d.quot,DECBASE);
                                 } while (--inl_s);
                                 achl_cur -= inl_dgsp_lo;  /* skip digits-separator */
                                 if (--inl_dgsp_tm==0)
                                   break;
                                 inl_s=D_DIGGRPLEN;
                               }
                             }
                             if (inl_dgsp_ph) {  /* precision may provoke leading separator */
                               while (TRUE) {   /* write leading (maybe partial) digit group */
                                 *achl_cur = ('0'+dsl_d.rem);
                                 if (--inl_dgsp_ph == 0) break;
                                 achl_cur--;
                                 dsl_d = lldiv(dsl_d.quot,DECBASE);
                               }
                             }
                           } else {  /* not using digit group separation */
                             while (TRUE) {
                               *(achl_cur + --inl_emax) = ('0'+dsl_d.rem);
                               if (inl_emax <= 0) break;
                               dsl_d = lldiv(dsl_d.quot,DECBASE);
                             }
                           }
#endif
                         } else {
#endif
                           if (inl_dgsp_lc) {  /* using digit group separation */
                             achl_cur += inl_emax+inl_dgsp_tm*inl_dgsp_lo-1;
                             if (inl_dgsp_tm) {  /* write all digit groups that follow a separator */
                               inl_s=D_DIGGRPLEN-inl_pfdgph;
                               while (TRUE) {
                                 do {
                                   *(achl_cur)-- = ('0'+iml_arg1%(signed int)DECBASE);
                                   iml_arg1/=(signed int)DECBASE;
                                 } while (--inl_s);
                                 achl_cur -= inl_dgsp_lo;  /* skip digits-separator */
                                 if (--inl_dgsp_tm==0)
                                   break;
                                 inl_s=D_DIGGRPLEN;
                               }
                             }
                             if (inl_dgsp_ph) {  /* precision may provoke leading separator */
                               while (TRUE) {   /* write leading (maybe partial) digit group */
                                 *achl_cur = ('0'+iml_arg1%(signed int)DECBASE);
                                 if (--inl_dgsp_ph == 0) break;
                                 achl_cur--;
                                 iml_arg1/=(signed int)DECBASE;
                               }
                             }
                           } else {  /* not using digit group separation */
                             while (--inl_emax > 0) {
                               *(achl_cur+inl_emax) = ('0'+iml_arg1%(signed int)DECBASE);
                               iml_arg1/=(signed int)DECBASE;
                             }
                             *achl_cur = ('0'+iml_arg1);
                           }
#ifdef HL_USE_DIV
                         }
#endif
                         achl_cur += inl_emax;
                       }
                 break;
               case 'l': case 'L':
                 if(bol_longlong){
                   ill_arg = va_arg(dsl_list, HL_LONGLONG);
                       /* determine sign and go on with non-negative X */
                       if (ill_arg > 0) {
                         chl_sign = achl_signed[2];
                       } else {
                         if (ill_arg != 0)
                         {
                           chl_sign = achl_signed[0];
                           ill_arg=0-ill_arg; /* replace negative X by its abs-value */
                           if ((HL_LONGLONG)ill_arg<0) {  /* special case: X was the extreme negative value */
                             /*inl_emax = (((sizeof(HL_LONGLONG)*8-1)*30103)/100000)+1;*/
                             ill_arg=(HL_LONGLONG)(-1)-ill_arg; /* 7fff... */
                             if (iel_scaling==ied_scaling_none) {
                               chl_postfix = '1'+ill_arg%DECBASE;  /* decimal carry cannot happen here */
                               inl_postfixlen = 1;
                               inl_pfdgph = 1;
                               ull_precision--;
                               ill_arg/=DECBASE;
                             }
                           }
                         } else {
                           chl_sign = achl_signed[1];
                         }
                       }
                       inl_needed = chl_sign?1:0;

                       /* prepare %(sci-dec)- or %(sci-dec)-type of rendering */
                       if (iel_scaling!=ied_scaling_none) {
                         if (iel_scaling == ied_scaling_1000) {  /* power-of-1000-scaled */
#if HL_PRFMAXSO_LL > 4
                           if ((sizeof(HL_LONGLONG) > 4) && (ill_arg >= D_L1000RD * ullrs_decpowbuf[9])) {
#if HL_PRFMAXSO_LL > 8
                             if (
                                 (sizeof(HL_LONGLONG) > 8) &&
                                 (ill_arg >= D_L1000RD * ullrs_decpowbuf[15])
                                ) {
                               if (
                                   (ill_arg >= D_L1000RD * ullrs_decpowbuf[18])
                                  ) {
                                 if (ill_arg >= D_L1000RD * ullrs_decpowbuf[21]) {
                                   ill_arg =  (ill_arg + 500 * ullrs_decpowbuf[21]) / (ullrs_decpowbuf[24]);
                                   chl_postfix = 'Y';
                                 } else {
                                   ill_arg =  (ill_arg + 500 * ullrs_decpowbuf[18]) / (ullrs_decpowbuf[21]);
                                   chl_postfix = 'Z';
                                 }
                               } else {
                                 ill_arg =  (ill_arg + 500 * ullrs_decpowbuf[15]) / (ullrs_decpowbuf[18]);
                                 chl_postfix = 'E';
                               }
                             } else {
#endif
                               if (ill_arg >= D_L1000RD * ullrs_decpowbuf[12]) {
                                 ill_arg =  (ill_arg + 500 * ullrs_decpowbuf[12]) / (ullrs_decpowbuf[15]);
                                 chl_postfix = 'P';
                               } else {
                                 ill_arg =  (ill_arg + 500 * ullrs_decpowbuf[9]) / (ullrs_decpowbuf[12]);
                                 chl_postfix = 'T';
                               }
#if HL_PRFMAXSO_LL > 8
                             }
#endif
                             inl_postfixlen = 1;
                           } else {
#endif
#if HL_PRFMAXSO_LL > 2
                             if ((sizeof(HL_LONGLONG) > 2) && (ill_arg >= D_L1000RD * ullrs_decpowbuf[3])) {
#if HL_PRFMAXSO_LL > 4
                               if ((sizeof(HL_LONGLONG) > 4) && (ill_arg >= D_L1000RD * ullrs_decpowbuf[6])) {
                                 ill_arg =  (ill_arg + 500 * ullrs_decpowbuf[6]) / (ullrs_decpowbuf[9]);
                                 chl_postfix = 'G';
                               } else {
#endif
                                 ill_arg =  (ill_arg + 500 * ullrs_decpowbuf[3]) / (ullrs_decpowbuf[6]);
                                 chl_postfix = 'M';
#if HL_PRFMAXSO_LL > 4
                               }
#endif
                               inl_postfixlen = 1;
                             } else {
#endif
                               if (ill_arg >= D_L1000RD) {
                                 ill_arg = (ill_arg + 500) / 1000;
                                 chl_postfix = 'k';
                                 inl_postfixlen = 1;
                               }
#if HL_PRFMAXSO_LL > 2
                             }
#endif
#if HL_PRFMAXSO_LL > 4
                           }
#endif
                         }
                         else {               /* power-of-1024-scaled    */
#if HL_PRFMAXSO_LL > 4
                           if ((sizeof(HL_LONGLONG) > 4) && (ill_arg>>30 >= D_L1024RD)) {
#if HL_PRFMAXSO_LL > 8
                             if (
                                 (sizeof(HL_LONGLONG) > 8) &&
                                 (ill_arg>>50 >= D_L1024RD)
                                ) {
                               if (
                                   (ill_arg>>60 >= D_L1024RD)
                                  ) {
                                 if (ill_arg>>70 >= D_L1024RD) {
                                   ill_arg = (ill_arg+((HL_LONGLONG)1<<79)) >> 80;
                                   chl_postfix = 'Y';
                                 } else {
                                   ill_arg = (ill_arg+((HL_LONGLONG)1<<69)) >> 70;
                                   chl_postfix = 'Z';
                                 }
                               } else {
                                 ill_arg = (ill_arg+((HL_LONGLONG)1<<59)) >> 60;
                                 chl_postfix = 'E';
                               }
                             } else {
#endif
                               if (ill_arg>>40 >= D_L1024RD) {
                                 ill_arg = (ill_arg+((HL_LONGLONG)1<<49)) >> 50;
                                 chl_postfix = 'P';
                               } else {
                                 ill_arg = (ill_arg+((HL_LONGLONG)1<<39)) >> 40;
                                 chl_postfix = 'T';
                               }
#if HL_PRFMAXSO_LL > 8
                             }
#endif
                             inl_postfixlen = bol_alternate_form ? 2 : 1;
                           } else {
#endif
#if HL_PRFMAXSO_LL > 2
                             if ((sizeof(HL_LONGLONG) > 2) && (ill_arg>>10 >= D_L1024RD)) {
#if HL_PRFMAXSO_LL > 4
                               if ((sizeof(HL_LONGLONG) > 4) && (ill_arg>>20 >= D_L1024RD)) {
                                 ill_arg = (ill_arg+((HL_LONGLONG)1<<29)) >> 30;
                                 chl_postfix = 'G';
                               } else {
#endif
                                 ill_arg = (ill_arg+((HL_LONGLONG)1<<19)) >> 20;
                                 chl_postfix = 'M';
#if HL_PRFMAXSO_LL > 4
                               }
#endif
                               inl_postfixlen = bol_alternate_form ? 2 : 1;
                             } else {
#endif
                               if (ill_arg >= D_L1024RD) {
                                 ill_arg = (ill_arg+0x200) >> 10;
                                 chl_postfix = 'K';
                                 inl_postfixlen = bol_alternate_form ? 2 : 1;
                               }
#if HL_PRFMAXSO_LL > 2
                             }
#endif
#if HL_PRFMAXSO_LL > 4
                           }
#endif
                         }
                       }

                       /* detect the order of magnitude of X           */
                       inl_emax = 0;
                       if (ill_arg) {
                         int inl_e = (((sizeof(HL_LONGLONG)*8-1)*30103)/100000)+1;
                         do {
                           inl_s = inl_e>>1;
                           if (ill_arg >= ullrs_decpowbuf[inl_emax+inl_s]) {
                             inl_emax += inl_s;
                             inl_e -= inl_s;
                           } else {
                             inl_e = inl_s;
                           }
                         } while (inl_e>1);
                         inl_emax ++;
                       }
                       inl_needed += inl_emax + inl_postfixlen;
                       if (inl_dgsp_lc) {   /* use digit group separation */
                         if (inl_emax<=D_DIGGRPLEN) {  /* digit grouping not in effect */
                           inl_dgsp_lc = 0;
                         } else {
                           const int inl_emax_1 = inl_emax+inl_pfdgph-1;
#ifdef HL_USE_DIV
                           dsl_diggrp_dm = div(inl_emax_1, D_DIGGRPLEN);
                           inl_dgsp_ph++;
#else
                           inl_dgsp_tm = (inl_emax_1)/D_DIGGRPLEN;
                           inl_dgsp_ph = (inl_emax_1)%D_DIGGRPLEN+1;
#endif
                           if (inl_needed>=ull_field_width || inl_needed+inl_dgsp_tm*inl_dgsp_lc<=ull_field_width) {
                             inl_s = inl_dgsp_tm*inl_dgsp_lc;
                             inl_needed += inl_s;
                           } else {  /* prefer staying within fieldwidth over using the separator */
                             inl_dgsp_lc = 0;
                           }
                         }
                       }
                       if (!bol_precision) {
                         ull_precision = 1;  /* default precision      */
                         if (bol_padding_zero) {
                           if (ull_field_width>inl_needed && !bol_adjustleft) {
                             /* fake padding with '0' by ull_precision */
                             ull_precision = ull_field_width+(inl_dgsp_lc?inl_emax+inl_s:inl_emax)-inl_needed;
                           }
                         }
                       }
                       if (inl_dgsp_lc) {   /* using digit group separation */
                         inl_precpad = ull_precision-(inl_emax+inl_s);
                         if (inl_precpad>0) {
#ifdef HL_USE_DIV
                           div_t dsl_d = div(inl_dgsp_ph+inl_precpad, D_DIGGRPLEN+inl_dgsp_lc);
                           inl_dgsp_tm += dsl_d.quot;
                           inl_needed += inl_precpad;
                           inl_dgsp_ph = dsl_d.rem;
#else
                           inl_needed += inl_precpad;
                           inl_dgsp_tm += (inl_dgsp_ph+inl_precpad)/(D_DIGGRPLEN+inl_dgsp_lc);
                           inl_dgsp_ph = (inl_dgsp_ph+inl_precpad)%(D_DIGGRPLEN+inl_dgsp_lc);
#endif
                           if (inl_dgsp_ph>D_DIGGRPLEN) {
                             inl_needed -= inl_dgsp_ph-D_DIGGRPLEN;
                             inl_dgsp_ph = D_DIGGRPLEN;
                           }
                           inl_precpad = ull_precision-(inl_emax+inl_dgsp_tm*inl_dgsp_lc);
                         } else {
                           inl_precpad=0;
                         }
                       } else {    /* not using digit group separation */
                         inl_precpad = ull_precision-inl_emax;
                         if (inl_precpad>0) {
                           inl_needed += inl_precpad;
                         } else {
                           inl_precpad=0;
                         }
                       }
                       if (ull_field_width > inl_needed) {
                         achl_after = achl_cur+ull_field_width;
                         inl_padsp = ull_field_width-inl_needed;
                         if (!bol_adjustleft) {  /* padding left with spaces */
                           if (inl_padsp > achl_end-achl_cur)
                             {achl_after = achl_cur; break;}  /* overflow */
                           do
                             *achl_cur++ = (' ');
                           while (--inl_padsp);
                         }
                       } else {
                         achl_after = achl_cur+inl_needed;
                         inl_padsp = 0;
                       }
                       if (inl_dgsp_lc) {   /* set digit group separators */
                         if (chl_sign) {    /* write sign prefix       */
                           if (1 > achl_end-achl_cur)
                             {achl_after = achl_cur; break;}  /* overflow */
                           *achl_cur++ = (chl_sign);
                         }
                         /* produce the first separator                                     */
                         achl_dg = achl_cur+inl_dgsp_ph;
                         switch (iel_cs_target) {
                           case ied_chs_ascii_850:
                             inl_dgsp_lo = m_a850l_from_u8l( achl_dg, 1+achl_end-achl_dg, achl_dgsp, inl_dgsp_lb );
                             break;
                           case ied_chs_ansi_819:
                             inl_dgsp_lo = m_a819l_from_u8l( achl_dg, 1+achl_end-achl_dg, achl_dgsp, inl_dgsp_lb );
                             break;
                           CASE_IED_CHS_MISCCODEPAGES
                           CASE_IED_CHS_ISO8859_2TO16
                             inl_dgsp_lo = m_sbcl_from_u8l( achl_dg, 1+achl_end-achl_dg, iel_cs_target, achl_dgsp, inl_dgsp_lb );
                             break;
                           CASE_IED_CHS_ALL_CJK
                             inl_dgsp_lo = m_mbcl_from_u8l( achl_dg, 1+achl_end-achl_dg, awcl_back_t, achl_dgsp, inl_dgsp_lb, NULL );
                             break;
                           case ied_chs_utf_8:
                             memcpy( achl_dg, achl_dgsp, achl_end-achl_dg<inl_dgsp_lb?achl_end-achl_dg:inl_dgsp_lb );
                             inl_dgsp_lo = inl_dgsp_lb;
                             break;
                           default:
                             break;
                         }
                         /* now the complete physical output length can be determined      */
                         inl_s = inl_dgsp_tm*(inl_dgsp_lo-inl_dgsp_lc);  /* adjustment from logical to physical */
                         achl_after += inl_s;
                         if (inl_dgsp_lo<0 || achl_after-achl_cur>achl_end-achl_cur)
                           {achl_after = achl_cur; break;}  /* overflow */
                         /* copy the other separators from the first one                   */
                         inl_s = inl_dgsp_tm-1;
                         if (inl_s) {
                           achl0 = achl_dg+inl_dgsp_lo;
                           do {
                             achl0 += D_DIGGRPLEN;
                             int inl2 = 0;
                             do
                               *achl0++ = achl_dg[inl2++];
                             while (inl2<inl_dgsp_lo);
                           } while (--inl_s);
                         }
                         /* padding left with zeroes to "precision"                        */
                         while (inl_precpad) {
                           if (inl_dgsp_ph == 0) {  /* skip digits-separator */
                             achl_cur += inl_dgsp_lo;
                             inl_dgsp_ph = D_DIGGRPLEN-1;
                             inl_dgsp_tm--;
                             if (!inl_dgsp_tm)
                               break;
                           } else {
                             inl_dgsp_ph--;
                           }
                           *achl_cur++ = ('0');
                           inl_precpad --;
                         }
                       } else {             /* not using digit group separation */
                         if (achl_after-achl_cur>achl_end-achl_cur)
                           {achl_after = achl_cur; break;}  /* overflow */
                         if (chl_sign)      /* write sign prefix       */
                           *achl_cur++ = (chl_sign);
                         /* padding left with zeroes to "precision"    */
                         while (inl_precpad) {
                           *achl_cur++ = ('0');
                           inl_precpad --;
                         }
                       }
                       /* postfix                                      */
                       if (inl_postfixlen) {
                         if (inl_postfixlen==2) {
                           *(achl_after-(inl_padsp+2)) = (chl_postfix);
                           *(achl_after-(inl_padsp+1)) = ('i');
                         } else {
                           *(achl_after-(inl_padsp+1)) = (chl_postfix);
                         }
                       }
                       /* padding right with spaces                    */
                       if (inl_padsp) {
                         achl0 = achl_after-1;
                         do
                           *achl0-- = (' ');
                         while (--inl_padsp);
                       }
                       /* produce the digits                           */
                       if (inl_emax > 0) {
#ifdef HL_USE_DIV
                         if (sizeof(HL_LONGLONG)<=sizeof(int)) {
                           div_t dsl_d;
                           dsl_d = div(ill_arg,DECBASE);
                           if (inl_dgsp_lc) {  /* using digit group separation */
                             achl_cur += inl_emax+inl_dgsp_tm*inl_dgsp_lo-1;
                             if (inl_dgsp_tm) {  /* write all digit groups that follow a separator */
                               inl_s=D_DIGGRPLEN-inl_pfdgph;
                               while (TRUE) {
                                 do {
                                   *(achl_cur)-- = ('0'+dsl_d.rem);
                                   dsl_d = div(dsl_d.quot,DECBASE);
                                 } while (--inl_s);
                                 achl_cur -= inl_dgsp_lo;  /* skip digits-separator */
                                 if (--inl_dgsp_tm==0)
                                   break;
                                 inl_s=D_DIGGRPLEN;
                               }
                             }
                             if (inl_dgsp_ph) {  /* precision may provoke leading separator */
                               while (TRUE) {   /* write leading (maybe partial) digit group */
                                 *achl_cur = ('0'+dsl_d.rem);
                                 if (--inl_dgsp_ph == 0) break;
                                 achl_cur--;
                                 dsl_d = div(dsl_d.quot,DECBASE);
                               }
                             }
                           } else {  /* not using digit group separation */
                             while (TRUE) {
                               *(achl_cur + --inl_emax) = ('0'+dsl_d.rem);
                               if (inl_emax <= 0) break;
                               dsl_d = div(dsl_d.quot,DECBASE);
                             }
                           }
#ifdef HL_USE_LDIV
                         } else if (sizeof(HL_LONGLONG)<=sizeof(long int)) {
                           ldiv_t dsl_d;
                           dsl_d = ldiv(ill_arg,DECBASE);
                           if (inl_dgsp_lc) {  /* using digit group separation */
                             achl_cur += inl_emax+inl_dgsp_tm*inl_dgsp_lo-1;
                             if (inl_dgsp_tm) {  /* write all digit groups that follow a separator */
                               inl_s=D_DIGGRPLEN-inl_pfdgph;
                               while (TRUE) {
                                 do {
                                   *(achl_cur)-- = ('0'+dsl_d.rem);
                                   dsl_d = ldiv(dsl_d.quot,DECBASE);
                                 } while (--inl_s);
                                 achl_cur -= inl_dgsp_lo;  /* skip digits-separator */
                                 if (--inl_dgsp_tm==0)
                                   break;
                                 inl_s=D_DIGGRPLEN;
                               }
                             }
                             if (inl_dgsp_ph) {  /* precision may provoke leading separator */
                               while (TRUE) {   /* write leading (maybe partial) digit group */
                                 *achl_cur = ('0'+dsl_d.rem);
                                 if (--inl_dgsp_ph == 0) break;
                                 achl_cur--;
                                 dsl_d = ldiv(dsl_d.quot,DECBASE);
                               }
                             }
                           } else {  /* not using digit group separation */
                             while (TRUE) {
                               *(achl_cur + --inl_emax) = ('0'+dsl_d.rem);
                               if (inl_emax <= 0) break;
                               dsl_d = ldiv(dsl_d.quot,DECBASE);
                             }
                           }
#endif
#ifdef HL_USE_LLDIV
                         } else if (sizeof(HL_LONGLONG)<=sizeof(long long int)) {
                           lldiv_t dsl_d;
                           dsl_d = lldiv(ill_arg,DECBASE);
                           if (inl_dgsp_lc) {  /* using digit group separation */
                             achl_cur += inl_emax+inl_dgsp_tm*inl_dgsp_lo-1;
                             if (inl_dgsp_tm) {  /* write all digit groups that follow a separator */
                               inl_s=D_DIGGRPLEN-inl_pfdgph;
                               while (TRUE) {
                                 do {
                                   *(achl_cur)-- = ('0'+dsl_d.rem);
                                   dsl_d = lldiv(dsl_d.quot,DECBASE);
                                 } while (--inl_s);
                                 achl_cur -= inl_dgsp_lo;  /* skip digits-separator */
                                 if (--inl_dgsp_tm==0)
                                   break;
                                 inl_s=D_DIGGRPLEN;
                               }
                             }
                             if (inl_dgsp_ph) {  /* precision may provoke leading separator */
                               while (TRUE) {   /* write leading (maybe partial) digit group */
                                 *achl_cur = ('0'+dsl_d.rem);
                                 if (--inl_dgsp_ph == 0) break;
                                 achl_cur--;
                                 dsl_d = lldiv(dsl_d.quot,DECBASE);
                               }
                             }
                           } else {  /* not using digit group separation */
                             while (TRUE) {
                               *(achl_cur + --inl_emax) = ('0'+dsl_d.rem);
                               if (inl_emax <= 0) break;
                               dsl_d = lldiv(dsl_d.quot,DECBASE);
                             }
                           }
#endif
                         } else {
#endif
                           if (inl_dgsp_lc) {  /* using digit group separation */
                             achl_cur += inl_emax+inl_dgsp_tm*inl_dgsp_lo-1;
                             if (inl_dgsp_tm) {  /* write all digit groups that follow a separator */
                               inl_s=D_DIGGRPLEN-inl_pfdgph;
                               while (TRUE) {
                                 do {
                                   *(achl_cur)-- = ('0'+ill_arg%(HL_LONGLONG)DECBASE);
                                   ill_arg/=(HL_LONGLONG)DECBASE;
                                 } while (--inl_s);
                                 achl_cur -= inl_dgsp_lo;  /* skip digits-separator */
                                 if (--inl_dgsp_tm==0)
                                   break;
                                 inl_s=D_DIGGRPLEN;
                               }
                             }
                             if (inl_dgsp_ph) {  /* precision may provoke leading separator */
                               while (TRUE) {   /* write leading (maybe partial) digit group */
                                 *achl_cur = ('0'+ill_arg%(HL_LONGLONG)DECBASE);
                                 if (--inl_dgsp_ph == 0) break;
                                 achl_cur--;
                                 ill_arg/=(HL_LONGLONG)DECBASE;
                               }
                             }
                           } else {  /* not using digit group separation */
                             while (--inl_emax > 0) {
                               *(achl_cur+inl_emax) = ('0'+ill_arg%(HL_LONGLONG)DECBASE);
                               ill_arg/=(HL_LONGLONG)DECBASE;
                             }
                             *achl_cur = ('0'+ill_arg);
                           }
#ifdef HL_USE_DIV
                         }
#endif
                         achl_cur += inl_emax;
                       }
                 }
                 else {
                   ill_arg = va_arg(dsl_list, long int);
                       /* determine sign and go on with non-negative X */
                       if (ill_arg > 0) {
                         chl_sign = achl_signed[2];
                       } else {
                         if (ill_arg != 0)
                         {
                           chl_sign = achl_signed[0];
                           ill_arg=0-ill_arg; /* replace negative X by its abs-value */
                           if ((signed long int)ill_arg<0) {  /* special case: X was the extreme negative value */
                             /*inl_emax = (((sizeof(signed long int)*8-1)*30103)/100000)+1;*/
                             ill_arg=(signed long int)(-1)-ill_arg; /* 7fff... */
                             if (iel_scaling==ied_scaling_none) {
                               chl_postfix = '1'+ill_arg%DECBASE;  /* decimal carry cannot happen here */
                               inl_postfixlen = 1;
                               inl_pfdgph = 1;
                               ull_precision--;
                               ill_arg/=DECBASE;
                             }
                           }
                         } else {
                           chl_sign = achl_signed[1];
                         }
                       }
                       inl_needed = chl_sign?1:0;

                       /* prepare %(sci-dec)- or %(sci-dec)-type of rendering */
                       if (iel_scaling!=ied_scaling_none) {
                         if (iel_scaling == ied_scaling_1000) {  /* power-of-1000-scaled */
#if HL_PRFMAXSO_L > 4
                           if ((sizeof(signed long int) > 4) && (ill_arg >= D_L1000RD * ullrs_decpowbuf[9])) {
#if HL_PRFMAXSO_L > 8
                             if (
                                 (sizeof(signed long int) > 8) &&
                                 (ill_arg >= D_L1000RD * ullrs_decpowbuf[15])
                                ) {
                               if (
                                   (ill_arg >= D_L1000RD * ullrs_decpowbuf[18])
                                  ) {
                                 if (ill_arg >= D_L1000RD * ullrs_decpowbuf[21]) {
                                   ill_arg =  (ill_arg + 500 * ullrs_decpowbuf[21]) / (ullrs_decpowbuf[24]);
                                   chl_postfix = 'Y';
                                 } else {
                                   ill_arg =  (ill_arg + 500 * ullrs_decpowbuf[18]) / (ullrs_decpowbuf[21]);
                                   chl_postfix = 'Z';
                                 }
                               } else {
                                 ill_arg =  (ill_arg + 500 * ullrs_decpowbuf[15]) / (ullrs_decpowbuf[18]);
                                 chl_postfix = 'E';
                               }
                             } else {
#endif
                               if (ill_arg >= D_L1000RD * ullrs_decpowbuf[12]) {
                                 ill_arg =  (ill_arg + 500 * ullrs_decpowbuf[12]) / (ullrs_decpowbuf[15]);
                                 chl_postfix = 'P';
                               } else {
                                 ill_arg =  (ill_arg + 500 * ullrs_decpowbuf[9]) / (ullrs_decpowbuf[12]);
                                 chl_postfix = 'T';
                               }
#if HL_PRFMAXSO_L > 8
                             }
#endif
                             inl_postfixlen = 1;
                           } else {
#endif
#if HL_PRFMAXSO_L > 2
                             if ((sizeof(signed long int) > 2) && (ill_arg >= D_L1000RD * ullrs_decpowbuf[3])) {
#if HL_PRFMAXSO_L > 4
                               if ((sizeof(signed long int) > 4) && (ill_arg >= D_L1000RD * ullrs_decpowbuf[6])) {
                                 ill_arg =  (ill_arg + 500 * ullrs_decpowbuf[6]) / (ullrs_decpowbuf[9]);
                                 chl_postfix = 'G';
                               } else {
#endif
                                 ill_arg =  (ill_arg + 500 * ullrs_decpowbuf[3]) / (ullrs_decpowbuf[6]);
                                 chl_postfix = 'M';
#if HL_PRFMAXSO_L > 4
                               }
#endif
                               inl_postfixlen = 1;
                             } else {
#endif
                               if (ill_arg >= D_L1000RD) {
                                 ill_arg = (ill_arg + 500) / 1000;
                                 chl_postfix = 'k';
                                 inl_postfixlen = 1;
                               }
#if HL_PRFMAXSO_L > 2
                             }
#endif
#if HL_PRFMAXSO_L > 4
                           }
#endif
                         }
                         else {               /* power-of-1024-scaled    */
#if HL_PRFMAXSO_L > 4
                           if ((sizeof(signed long int) > 4) && (ill_arg>>30 >= D_L1024RD)) {
#if HL_PRFMAXSO_L > 8
                             if (
                                 (sizeof(signed long int) > 8) &&
                                 (ill_arg>>50 >= D_L1024RD)
                                ) {
                               if (
                                   (ill_arg>>60 >= D_L1024RD)
                                  ) {
                                 if (ill_arg>>70 >= D_L1024RD) {
                                   ill_arg = (ill_arg+((signed long int)1<<79)) >> 80;
                                   chl_postfix = 'Y';
                                 } else {
                                   ill_arg = (ill_arg+((signed long int)1<<69)) >> 70;
                                   chl_postfix = 'Z';
                                 }
                               } else {
                                 ill_arg = (ill_arg+((signed long int)1<<59)) >> 60;
                                 chl_postfix = 'E';
                               }
                             } else {
#endif
                               if (ill_arg>>40 >= D_L1024RD) {
                                 ill_arg = (ill_arg+((signed long int)1<<49)) >> 50;
                                 chl_postfix = 'P';
                               } else {
                                 ill_arg = (ill_arg+((signed long int)1<<39)) >> 40;
                                 chl_postfix = 'T';
                               }
#if HL_PRFMAXSO_L > 8
                             }
#endif
                             inl_postfixlen = bol_alternate_form ? 2 : 1;
                           } else {
#endif
#if HL_PRFMAXSO_L > 2
                             if ((sizeof(signed long int) > 2) && (ill_arg>>10 >= D_L1024RD)) {
#if HL_PRFMAXSO_L > 4
                               if ((sizeof(signed long int) > 4) && (ill_arg>>20 >= D_L1024RD)) {
                                 ill_arg = (ill_arg+((signed long int)1<<29)) >> 30;
                                 chl_postfix = 'G';
                               } else {
#endif
                                 ill_arg = (ill_arg+((signed long int)1<<19)) >> 20;
                                 chl_postfix = 'M';
#if HL_PRFMAXSO_L > 4
                               }
#endif
                               inl_postfixlen = bol_alternate_form ? 2 : 1;
                             } else {
#endif
                               if (ill_arg >= D_L1024RD) {
                                 ill_arg = (ill_arg+0x200) >> 10;
                                 chl_postfix = 'K';
                                 inl_postfixlen = bol_alternate_form ? 2 : 1;
                               }
#if HL_PRFMAXSO_L > 2
                             }
#endif
#if HL_PRFMAXSO_L > 4
                           }
#endif
                         }
                       }

                       /* detect the order of magnitude of X           */
                       inl_emax = 0;
                       if (ill_arg) {
                         int inl_e = (((sizeof(signed long int)*8-1)*30103)/100000)+1;
                         do {
                           inl_s = inl_e>>1;
                           if (ill_arg >= ullrs_decpowbuf[inl_emax+inl_s]) {
                             inl_emax += inl_s;
                             inl_e -= inl_s;
                           } else {
                             inl_e = inl_s;
                           }
                         } while (inl_e>1);
                         inl_emax ++;
                       }
                       inl_needed += inl_emax + inl_postfixlen;
                       if (inl_dgsp_lc) {   /* use digit group separation */
                         if (inl_emax<=D_DIGGRPLEN) {  /* digit grouping not in effect */
                           inl_dgsp_lc = 0;
                         } else {
                           const int inl_emax_1 = inl_emax+inl_pfdgph-1;
#ifdef HL_USE_DIV
                           dsl_diggrp_dm = div(inl_emax_1, D_DIGGRPLEN);
                           inl_dgsp_ph++;
#else
                           inl_dgsp_tm = (inl_emax_1)/D_DIGGRPLEN;
                           inl_dgsp_ph = (inl_emax_1)%D_DIGGRPLEN+1;
#endif
                           if (inl_needed>=ull_field_width || inl_needed+inl_dgsp_tm*inl_dgsp_lc<=ull_field_width) {
                             inl_s = inl_dgsp_tm*inl_dgsp_lc;
                             inl_needed += inl_s;
                           } else {  /* prefer staying within fieldwidth over using the separator */
                             inl_dgsp_lc = 0;
                           }
                         }
                       }
                       if (!bol_precision) {
                         ull_precision = 1;  /* default precision      */
                         if (bol_padding_zero) {
                           if (ull_field_width>inl_needed && !bol_adjustleft) {
                             /* fake padding with '0' by ull_precision */
                             ull_precision = ull_field_width+(inl_dgsp_lc?inl_emax+inl_s:inl_emax)-inl_needed;
                           }
                         }
                       }
                       if (inl_dgsp_lc) {   /* using digit group separation */
                         inl_precpad = ull_precision-(inl_emax+inl_s);
                         if (inl_precpad>0) {
#ifdef HL_USE_DIV
                           div_t dsl_d = div(inl_dgsp_ph+inl_precpad, D_DIGGRPLEN+inl_dgsp_lc);
                           inl_dgsp_tm += dsl_d.quot;
                           inl_needed += inl_precpad;
                           inl_dgsp_ph = dsl_d.rem;
#else
                           inl_needed += inl_precpad;
                           inl_dgsp_tm += (inl_dgsp_ph+inl_precpad)/(D_DIGGRPLEN+inl_dgsp_lc);
                           inl_dgsp_ph = (inl_dgsp_ph+inl_precpad)%(D_DIGGRPLEN+inl_dgsp_lc);
#endif
                           if (inl_dgsp_ph>D_DIGGRPLEN) {
                             inl_needed -= inl_dgsp_ph-D_DIGGRPLEN;
                             inl_dgsp_ph = D_DIGGRPLEN;
                           }
                           inl_precpad = ull_precision-(inl_emax+inl_dgsp_tm*inl_dgsp_lc);
                         } else {
                           inl_precpad=0;
                         }
                       } else {    /* not using digit group separation */
                         inl_precpad = ull_precision-inl_emax;
                         if (inl_precpad>0) {
                           inl_needed += inl_precpad;
                         } else {
                           inl_precpad=0;
                         }
                       }
                       if (ull_field_width > inl_needed) {
                         achl_after = achl_cur+ull_field_width;
                         inl_padsp = ull_field_width-inl_needed;
                         if (!bol_adjustleft) {  /* padding left with spaces */
                           if (inl_padsp > achl_end-achl_cur)
                             {achl_after = achl_cur; break;}  /* overflow */
                           do
                             *achl_cur++ = (' ');
                           while (--inl_padsp);
                         }
                       } else {
                         achl_after = achl_cur+inl_needed;
                         inl_padsp = 0;
                       }
                       if (inl_dgsp_lc) {   /* set digit group separators */
                         if (chl_sign) {    /* write sign prefix       */
                           if (1 > achl_end-achl_cur)
                             {achl_after = achl_cur; break;}  /* overflow */
                           *achl_cur++ = (chl_sign);
                         }
                         /* produce the first separator                                     */
                         achl_dg = achl_cur+inl_dgsp_ph;
                         switch (iel_cs_target) {
                           case ied_chs_ascii_850:
                             inl_dgsp_lo = m_a850l_from_u8l( achl_dg, 1+achl_end-achl_dg, achl_dgsp, inl_dgsp_lb );
                             break;
                           case ied_chs_ansi_819:
                             inl_dgsp_lo = m_a819l_from_u8l( achl_dg, 1+achl_end-achl_dg, achl_dgsp, inl_dgsp_lb );
                             break;
                           CASE_IED_CHS_MISCCODEPAGES
                           CASE_IED_CHS_ISO8859_2TO16
                             inl_dgsp_lo = m_sbcl_from_u8l( achl_dg, 1+achl_end-achl_dg, iel_cs_target, achl_dgsp, inl_dgsp_lb );
                             break;
                           CASE_IED_CHS_ALL_CJK
                             inl_dgsp_lo = m_mbcl_from_u8l( achl_dg, 1+achl_end-achl_dg, awcl_back_t, achl_dgsp, inl_dgsp_lb, NULL );
                             break;
                           case ied_chs_utf_8:
                             memcpy( achl_dg, achl_dgsp, achl_end-achl_dg<inl_dgsp_lb?achl_end-achl_dg:inl_dgsp_lb );
                             inl_dgsp_lo = inl_dgsp_lb;
                             break;
                           default:
                             break;
                         }
                         /* now the complete physical output length can be determined      */
                         inl_s = inl_dgsp_tm*(inl_dgsp_lo-inl_dgsp_lc);  /* adjustment from logical to physical */
                         achl_after += inl_s;
                         if (inl_dgsp_lo<0 || achl_after-achl_cur>achl_end-achl_cur)
                           {achl_after = achl_cur; break;}  /* overflow */
                         /* copy the other separators from the first one                   */
                         inl_s = inl_dgsp_tm-1;
                         if (inl_s) {
                           achl0 = achl_dg+inl_dgsp_lo;
                           do {
                             achl0 += D_DIGGRPLEN;
                             int inl2 = 0;
                             do
                               *achl0++ = achl_dg[inl2++];
                             while (inl2<inl_dgsp_lo);
                           } while (--inl_s);
                         }
                         /* padding left with zeroes to "precision"                        */
                         while (inl_precpad) {
                           if (inl_dgsp_ph == 0) {  /* skip digits-separator */
                             achl_cur += inl_dgsp_lo;
                             inl_dgsp_ph = D_DIGGRPLEN-1;
                             inl_dgsp_tm--;
                             if (!inl_dgsp_tm)
                               break;
                           } else {
                             inl_dgsp_ph--;
                           }
                           *achl_cur++ = ('0');
                           inl_precpad --;
                         }
                       } else {             /* not using digit group separation */
                         if (achl_after-achl_cur>achl_end-achl_cur)
                           {achl_after = achl_cur; break;}  /* overflow */
                         if (chl_sign)      /* write sign prefix       */
                           *achl_cur++ = (chl_sign);
                         /* padding left with zeroes to "precision"    */
                         while (inl_precpad) {
                           *achl_cur++ = ('0');
                           inl_precpad --;
                         }
                       }
                       /* postfix                                      */
                       if (inl_postfixlen) {
                         if (inl_postfixlen==2) {
                           *(achl_after-(inl_padsp+2)) = (chl_postfix);
                           *(achl_after-(inl_padsp+1)) = ('i');
                         } else {
                           *(achl_after-(inl_padsp+1)) = (chl_postfix);
                         }
                       }
                       /* padding right with spaces                    */
                       if (inl_padsp) {
                         achl0 = achl_after-1;
                         do
                           *achl0-- = (' ');
                         while (--inl_padsp);
                       }
                       /* produce the digits                           */
                       if (inl_emax > 0) {
#ifdef HL_USE_DIV
                         if (sizeof(signed long int)<=sizeof(int)) {
                           div_t dsl_d;
                           dsl_d = div(ill_arg,DECBASE);
                           if (inl_dgsp_lc) {  /* using digit group separation */
                             achl_cur += inl_emax+inl_dgsp_tm*inl_dgsp_lo-1;
                             if (inl_dgsp_tm) {  /* write all digit groups that follow a separator */
                               inl_s=D_DIGGRPLEN-inl_pfdgph;
                               while (TRUE) {
                                 do {
                                   *(achl_cur)-- = ('0'+dsl_d.rem);
                                   dsl_d = div(dsl_d.quot,DECBASE);
                                 } while (--inl_s);
                                 achl_cur -= inl_dgsp_lo;  /* skip digits-separator */
                                 if (--inl_dgsp_tm==0)
                                   break;
                                 inl_s=D_DIGGRPLEN;
                               }
                             }
                             if (inl_dgsp_ph) {  /* precision may provoke leading separator */
                               while (TRUE) {   /* write leading (maybe partial) digit group */
                                 *achl_cur = ('0'+dsl_d.rem);
                                 if (--inl_dgsp_ph == 0) break;
                                 achl_cur--;
                                 dsl_d = div(dsl_d.quot,DECBASE);
                               }
                             }
                           } else {  /* not using digit group separation */
                             while (TRUE) {
                               *(achl_cur + --inl_emax) = ('0'+dsl_d.rem);
                               if (inl_emax <= 0) break;
                               dsl_d = div(dsl_d.quot,DECBASE);
                             }
                           }
#ifdef HL_USE_LDIV
                         } else if (sizeof(signed long int)<=sizeof(long int)) {
                           ldiv_t dsl_d;
                           dsl_d = ldiv(ill_arg,DECBASE);
                           if (inl_dgsp_lc) {  /* using digit group separation */
                             achl_cur += inl_emax+inl_dgsp_tm*inl_dgsp_lo-1;
                             if (inl_dgsp_tm) {  /* write all digit groups that follow a separator */
                               inl_s=D_DIGGRPLEN-inl_pfdgph;
                               while (TRUE) {
                                 do {
                                   *(achl_cur)-- = ('0'+dsl_d.rem);
                                   dsl_d = ldiv(dsl_d.quot,DECBASE);
                                 } while (--inl_s);
                                 achl_cur -= inl_dgsp_lo;  /* skip digits-separator */
                                 if (--inl_dgsp_tm==0)
                                   break;
                                 inl_s=D_DIGGRPLEN;
                               }
                             }
                             if (inl_dgsp_ph) {  /* precision may provoke leading separator */
                               while (TRUE) {   /* write leading (maybe partial) digit group */
                                 *achl_cur = ('0'+dsl_d.rem);
                                 if (--inl_dgsp_ph == 0) break;
                                 achl_cur--;
                                 dsl_d = ldiv(dsl_d.quot,DECBASE);
                               }
                             }
                           } else {  /* not using digit group separation */
                             while (TRUE) {
                               *(achl_cur + --inl_emax) = ('0'+dsl_d.rem);
                               if (inl_emax <= 0) break;
                               dsl_d = ldiv(dsl_d.quot,DECBASE);
                             }
                           }
#endif
#ifdef HL_USE_LLDIV
                         } else if (sizeof(signed long int)<=sizeof(long long int)) {
                           lldiv_t dsl_d;
                           dsl_d = lldiv(ill_arg,DECBASE);
                           if (inl_dgsp_lc) {  /* using digit group separation */
                             achl_cur += inl_emax+inl_dgsp_tm*inl_dgsp_lo-1;
                             if (inl_dgsp_tm) {  /* write all digit groups that follow a separator */
                               inl_s=D_DIGGRPLEN-inl_pfdgph;
                               while (TRUE) {
                                 do {
                                   *(achl_cur)-- = ('0'+dsl_d.rem);
                                   dsl_d = lldiv(dsl_d.quot,DECBASE);
                                 } while (--inl_s);
                                 achl_cur -= inl_dgsp_lo;  /* skip digits-separator */
                                 if (--inl_dgsp_tm==0)
                                   break;
                                 inl_s=D_DIGGRPLEN;
                               }
                             }
                             if (inl_dgsp_ph) {  /* precision may provoke leading separator */
                               while (TRUE) {   /* write leading (maybe partial) digit group */
                                 *achl_cur = ('0'+dsl_d.rem);
                                 if (--inl_dgsp_ph == 0) break;
                                 achl_cur--;
                                 dsl_d = lldiv(dsl_d.quot,DECBASE);
                               }
                             }
                           } else {  /* not using digit group separation */
                             while (TRUE) {
                               *(achl_cur + --inl_emax) = ('0'+dsl_d.rem);
                               if (inl_emax <= 0) break;
                               dsl_d = lldiv(dsl_d.quot,DECBASE);
                             }
                           }
#endif
                         } else {
#endif
                           if (inl_dgsp_lc) {  /* using digit group separation */
                             achl_cur += inl_emax+inl_dgsp_tm*inl_dgsp_lo-1;
                             if (inl_dgsp_tm) {  /* write all digit groups that follow a separator */
                               inl_s=D_DIGGRPLEN-inl_pfdgph;
                               while (TRUE) {
                                 do {
                                   *(achl_cur)-- = ('0'+ill_arg%(signed long int)DECBASE);
                                   ill_arg/=(signed long int)DECBASE;
                                 } while (--inl_s);
                                 achl_cur -= inl_dgsp_lo;  /* skip digits-separator */
                                 if (--inl_dgsp_tm==0)
                                   break;
                                 inl_s=D_DIGGRPLEN;
                               }
                             }
                             if (inl_dgsp_ph) {  /* precision may provoke leading separator */
                               while (TRUE) {   /* write leading (maybe partial) digit group */
                                 *achl_cur = ('0'+ill_arg%(signed long int)DECBASE);
                                 if (--inl_dgsp_ph == 0) break;
                                 achl_cur--;
                                 ill_arg/=(signed long int)DECBASE;
                               }
                             }
                           } else {  /* not using digit group separation */
                             while (--inl_emax > 0) {
                               *(achl_cur+inl_emax) = ('0'+ill_arg%(signed long int)DECBASE);
                               ill_arg/=(signed long int)DECBASE;
                             }
                             *achl_cur = ('0'+ill_arg);
                           }
#ifdef HL_USE_DIV
                         }
#endif
                         achl_cur += inl_emax;
                       }
                 }
                 break;
             }
           }
           else {                           /* unsigned: o O x X u U   */ /*UUU non-implemented 'n' has also 4 in umrs_format*/
             switch(chl_length_modifier) {
               case '\0': case 'h':
                 uml_arg = va_arg(dsl_list, unsigned int);
                 switch (chl_spec&0xDF) {
                   case 'U':

                       /* prepare %(sci-dec)- or %(sci-dec)-type of rendering */
                       if (iel_scaling!=ied_scaling_none) {
                         if (iel_scaling == ied_scaling_1000) {  /* power-of-1000-scaled */
#if HL_PRFMAXSO_I > 4
                           if ((sizeof(unsigned int) > 4) && (uml_arg >= D_L1000RD * unrs_decpowbuf[9])) {
                             if (
                                 (uml_arg >= D_L1000RD * unrs_decpowbuf[15])
                                ) {
#if HL_PRFMAXSO_I > 8
                               if (
                                   (sizeof(unsigned int) > 8) &&
                                   (uml_arg >= D_L1000RD * unrs_decpowbuf[18])
                                  ) {
                                 if (uml_arg >= D_L1000RD * unrs_decpowbuf[21]) {
                                   uml_arg =  (uml_arg + 500 * unrs_decpowbuf[21]) / (unrs_decpowbuf[24]);
                                   chl_postfix = 'Y';
                                 } else {
                                   uml_arg =  (uml_arg + 500 * unrs_decpowbuf[18]) / (unrs_decpowbuf[21]);
                                   chl_postfix = 'Z';
                                 }
                               } else {
#endif
                                 uml_arg =  (uml_arg + 500 * unrs_decpowbuf[15]) / (unrs_decpowbuf[18]);
                                 chl_postfix = 'E';
#if HL_PRFMAXSO_I > 8
                               }
#endif
                             } else {
                               if (uml_arg >= D_L1000RD * unrs_decpowbuf[12]) {
                                 uml_arg =  (uml_arg + 500 * unrs_decpowbuf[12]) / (unrs_decpowbuf[15]);
                                 chl_postfix = 'P';
                               } else {
                                 uml_arg =  (uml_arg + 500 * unrs_decpowbuf[9]) / (unrs_decpowbuf[12]);
                                 chl_postfix = 'T';
                               }
                             }
                             inl_postfixlen = 1;
                           } else {
#endif
#if HL_PRFMAXSO_I > 2
                             if ((sizeof(unsigned int) > 2) && (uml_arg >= D_L1000RD * unrs_decpowbuf[3])) {
#if HL_PRFMAXSO_I > 4
                               if ((sizeof(unsigned int) > 4) && (uml_arg >= D_L1000RD * unrs_decpowbuf[6])) {
                                 uml_arg =  (uml_arg + 500 * unrs_decpowbuf[6]) / (unrs_decpowbuf[9]);
                                 chl_postfix = 'G';
                               } else {
#endif
                                 uml_arg =  (uml_arg + 500 * unrs_decpowbuf[3]) / (unrs_decpowbuf[6]);
                                 chl_postfix = 'M';
#if HL_PRFMAXSO_I > 4
                               }
#endif
                               inl_postfixlen = 1;
                             } else {
#endif
                               if (uml_arg >= D_L1000RD) {
                                 uml_arg = (uml_arg + 500) / 1000;
                                 chl_postfix = 'k';
                                 inl_postfixlen = 1;
                               }
#if HL_PRFMAXSO_I > 2
                             }
#endif
#if HL_PRFMAXSO_I > 4
                           }
#endif
                         }
                         else {               /* power-of-1024-scaled    */
#if HL_PRFMAXSO_I > 4
                           if ((sizeof(unsigned int) > 4) && (uml_arg>>30 >= D_L1024RD)) {
                             if (
                                 (uml_arg>>50 >= D_L1024RD)
                                ) {
#if HL_PRFMAXSO_I > 8
                               if (
                                   (sizeof(unsigned int) > 8) &&
                                   (uml_arg>>60 >= D_L1024RD)
                                  ) {
                                 if (uml_arg>>70 >= D_L1024RD) {
                                   uml_arg = (uml_arg+((unsigned int)1<<79)) >> 80;
                                   chl_postfix = 'Y';
                                 } else {
                                   uml_arg = (uml_arg+((unsigned int)1<<69)) >> 70;
                                   chl_postfix = 'Z';
                                 }
                               } else {
#endif
                                 uml_arg = (uml_arg+((unsigned int)1<<59)) >> 60;
                                 chl_postfix = 'E';
#if HL_PRFMAXSO_I > 8
                               }
#endif
                             } else {
                               if (uml_arg>>40 >= D_L1024RD) {
                                 uml_arg = (uml_arg+((unsigned int)1<<49)) >> 50;
                                 chl_postfix = 'P';
                               } else {
                                 uml_arg = (uml_arg+((unsigned int)1<<39)) >> 40;
                                 chl_postfix = 'T';
                               }
                             }
                             inl_postfixlen = bol_alternate_form ? 2 : 1;
                           } else {
#endif
#if HL_PRFMAXSO_I > 2
                             if ((sizeof(unsigned int) > 2) && (uml_arg>>10 >= D_L1024RD)) {
#if HL_PRFMAXSO_I > 4
                               if ((sizeof(unsigned int) > 4) && (uml_arg>>20 >= D_L1024RD)) {
                                 uml_arg = (uml_arg+((unsigned int)1<<29)) >> 30;
                                 chl_postfix = 'G';
                               } else {
#endif
                                 uml_arg = (uml_arg+((unsigned int)1<<19)) >> 20;
                                 chl_postfix = 'M';
#if HL_PRFMAXSO_I > 4
                               }
#endif
                               inl_postfixlen = bol_alternate_form ? 2 : 1;
                             } else {
#endif
                               if (uml_arg >= D_L1024RD) {
                                 uml_arg = (uml_arg+0x200) >> 10;
                                 chl_postfix = 'K';
                                 inl_postfixlen = bol_alternate_form ? 2 : 1;
                               }
#if HL_PRFMAXSO_I > 2
                             }
#endif
#if HL_PRFMAXSO_I > 4
                           }
#endif
                         }
                       }

                       /* detect the order of magnitude of X           */
                       inl_emax = 0;
                       if (uml_arg) {
                         int inl_e = ((sizeof(unsigned int)*240824)/100000)+1;
                         do {
                           inl_s = inl_e>>1;
                           if (uml_arg >= unrs_decpowbuf[inl_emax+inl_s]) {
                             inl_emax += inl_s;
                             inl_e -= inl_s;
                           } else {
                             inl_e = inl_s;
                           }
                         } while (inl_e>1);
                         inl_emax ++;
                       }
                       inl_needed = inl_emax + inl_postfixlen;
                       if (inl_dgsp_lc) {   /* use digit group separation */
                         if (inl_emax<=D_DIGGRPLEN) {  /* digit grouping not in effect */
                           inl_dgsp_lc = 0;
                         } else {
                           const int inl_emax_1 = inl_emax-1;
#ifdef HL_USE_DIV
                           dsl_diggrp_dm = div(inl_emax_1, D_DIGGRPLEN);
                           inl_dgsp_ph++;
#else
                           inl_dgsp_tm = (inl_emax_1)/D_DIGGRPLEN;
                           inl_dgsp_ph = (inl_emax_1)%D_DIGGRPLEN+1;
#endif
                           if (inl_needed>=ull_field_width || inl_needed+inl_dgsp_tm*inl_dgsp_lc<=ull_field_width) {
                             inl_s = inl_dgsp_tm*inl_dgsp_lc;
                             inl_needed += inl_s;
                           } else {  /* prefer staying within fieldwidth over using the separator */
                             inl_dgsp_lc = 0;
                           }
                         }
                       }
                       if (!bol_precision) {
                         ull_precision = 1;  /* default precision      */
                         if (bol_padding_zero) {
                           if (ull_field_width>inl_needed && !bol_adjustleft) {
                             /* fake padding with '0' by ull_precision */
                             ull_precision = ull_field_width+(inl_dgsp_lc?inl_emax+inl_s:inl_emax)-inl_needed;
                           }
                         }
                       }
                       if (inl_dgsp_lc) {   /* using digit group separation */
                         inl_precpad = ull_precision-(inl_emax+inl_s);
                         if (inl_precpad>0) {
#ifdef HL_USE_DIV
                           div_t dsl_d = div(inl_dgsp_ph+inl_precpad, D_DIGGRPLEN+inl_dgsp_lc);
                           inl_dgsp_tm += dsl_d.quot;
                           inl_needed += inl_precpad;
                           inl_dgsp_ph = dsl_d.rem;
#else
                           inl_needed += inl_precpad;
                           inl_dgsp_tm += (inl_dgsp_ph+inl_precpad)/(D_DIGGRPLEN+inl_dgsp_lc);
                           inl_dgsp_ph = (inl_dgsp_ph+inl_precpad)%(D_DIGGRPLEN+inl_dgsp_lc);
#endif
                           if (inl_dgsp_ph>D_DIGGRPLEN) {
                             inl_needed -= inl_dgsp_ph-D_DIGGRPLEN;
                             inl_dgsp_ph = D_DIGGRPLEN;
                           }
                           inl_precpad = ull_precision-(inl_emax+inl_dgsp_tm*inl_dgsp_lc);
                         } else {
                           inl_precpad=0;
                         }
                       } else {    /* not using digit group separation */
                         inl_precpad = ull_precision-inl_emax;
                         if (inl_precpad>0) {
                           inl_needed += inl_precpad;
                         } else {
                           inl_precpad=0;
                         }
                       }
                       if (ull_field_width > inl_needed) {
                         achl_after = achl_cur+ull_field_width;
                         inl_padsp = ull_field_width-inl_needed;
                         if (!bol_adjustleft) {  /* padding left with spaces */
                           if (inl_padsp > achl_end-achl_cur)
                             {achl_after = achl_cur; break;}  /* overflow */
                           do
                             *achl_cur++ = (' ');
                           while (--inl_padsp);
                         }
                       } else {
                         achl_after = achl_cur+inl_needed;
                         inl_padsp = 0;
                       }
                       if (inl_dgsp_lc) {   /* set digit group separators */
                         /* produce the first separator                                     */
                         achl_dg = achl_cur+inl_dgsp_ph;
                         switch (iel_cs_target) {
                           case ied_chs_ascii_850:
                             inl_dgsp_lo = m_a850l_from_u8l( achl_dg, 1+achl_end-achl_dg, achl_dgsp, inl_dgsp_lb );
                             break;
                           case ied_chs_ansi_819:
                             inl_dgsp_lo = m_a819l_from_u8l( achl_dg, 1+achl_end-achl_dg, achl_dgsp, inl_dgsp_lb );
                             break;
                           CASE_IED_CHS_MISCCODEPAGES
                           CASE_IED_CHS_ISO8859_2TO16
                             inl_dgsp_lo = m_sbcl_from_u8l( achl_dg, 1+achl_end-achl_dg, iel_cs_target, achl_dgsp, inl_dgsp_lb );
                             break;
                           CASE_IED_CHS_ALL_CJK
                             inl_dgsp_lo = m_mbcl_from_u8l( achl_dg, 1+achl_end-achl_dg, awcl_back_t, achl_dgsp, inl_dgsp_lb, NULL );
                             break;
                           case ied_chs_utf_8:
                             memcpy( achl_dg, achl_dgsp, achl_end-achl_dg<inl_dgsp_lb?achl_end-achl_dg:inl_dgsp_lb );
                             inl_dgsp_lo = inl_dgsp_lb;
                             break;
                           default:
                             break;
                         }
                         /* now the complete physical output length can be determined      */
                         inl_s = inl_dgsp_tm*(inl_dgsp_lo-inl_dgsp_lc);  /* adjustment from logical to physical */
                         achl_after += inl_s;
                         if (inl_dgsp_lo<0 || achl_after-achl_cur>achl_end-achl_cur)
                           {achl_after = achl_cur; break;}  /* overflow */
                         /* copy the other separators from the first one                   */
                         inl_s = inl_dgsp_tm-1;
                         if (inl_s) {
                           achl0 = achl_dg+inl_dgsp_lo;
                           do {
                             achl0 += D_DIGGRPLEN;
                             int inl2 = 0;
                             do
                               *achl0++ = achl_dg[inl2++];
                             while (inl2<inl_dgsp_lo);
                           } while (--inl_s);
                         }
                         /* padding left with zeroes to "precision"                        */
                         while (inl_precpad) {
                           if (inl_dgsp_ph == 0) {  /* skip digits-separator */
                             achl_cur += inl_dgsp_lo;
                             inl_dgsp_ph = D_DIGGRPLEN-1;
                             inl_dgsp_tm--;
                             if (!inl_dgsp_tm)
                               break;
                           } else {
                             inl_dgsp_ph--;
                           }
                           *achl_cur++ = ('0');
                           inl_precpad --;
                         }
                       } else {             /* not using digit group separation */
                         if (achl_after-achl_cur>achl_end-achl_cur)
                           {achl_after = achl_cur; break;}  /* overflow */
                         /* padding left with zeroes to "precision"    */
                         while (inl_precpad) {
                           *achl_cur++ = ('0');
                           inl_precpad --;
                         }
                       }
                       /* postfix                                      */
                       if (inl_postfixlen) {
                         if (inl_postfixlen==2) {
                           *(achl_after-(inl_padsp+2)) = (chl_postfix);
                           *(achl_after-(inl_padsp+1)) = ('i');
                         } else {
                           *(achl_after-(inl_padsp+1)) = (chl_postfix);
                         }
                       }
                       /* padding right with spaces                    */
                       if (inl_padsp) {
                         achl0 = achl_after-1;
                         do
                           *achl0-- = (' ');
                         while (--inl_padsp);
                       }
                       /* produce the digits                           */
                       if (inl_emax > 0) {
#ifdef HL_USE_DIV
                         if (sizeof(unsigned int)<=sizeof(int)) {
                           div_t dsl_d;
                           dsl_d.quot = uml_arg/(unsigned int)DECBASE;
                           dsl_d.rem = uml_arg%(unsigned int)DECBASE;
                           if (inl_dgsp_lc) {  /* using digit group separation */
                             achl_cur += inl_emax+inl_dgsp_tm*inl_dgsp_lo-1;
                             if (inl_dgsp_tm) {  /* write all digit groups that follow a separator */
                               inl_s=D_DIGGRPLEN;
                               while (TRUE) {
                                 do {
                                   *(achl_cur)-- = ('0'+dsl_d.rem);
                                   dsl_d = div(dsl_d.quot,DECBASE);
                                 } while (--inl_s);
                                 achl_cur -= inl_dgsp_lo;  /* skip digits-separator */
                                 if (--inl_dgsp_tm==0)
                                   break;
                                 inl_s=D_DIGGRPLEN;
                               }
                             }
                             if (inl_dgsp_ph) {  /* precision may provoke leading separator */
                               while (TRUE) {   /* write leading (maybe partial) digit group */
                                 *achl_cur = ('0'+dsl_d.rem);
                                 if (--inl_dgsp_ph == 0) break;
                                 achl_cur--;
                                 dsl_d = div(dsl_d.quot,DECBASE);
                               }
                             }
                           } else {  /* not using digit group separation */
                             while (TRUE) {
                               *(achl_cur + --inl_emax) = ('0'+dsl_d.rem);
                               if (inl_emax <= 0) break;
                               dsl_d = div(dsl_d.quot,DECBASE);
                             }
                           }
#ifdef HL_USE_LDIV
                         } else if (sizeof(unsigned int)<=sizeof(long int)) {
                           ldiv_t dsl_d;
                           dsl_d.quot = uml_arg/(unsigned int)DECBASE;
                           dsl_d.rem = uml_arg%(unsigned int)DECBASE;
                           if (inl_dgsp_lc) {  /* using digit group separation */
                             achl_cur += inl_emax+inl_dgsp_tm*inl_dgsp_lo-1;
                             if (inl_dgsp_tm) {  /* write all digit groups that follow a separator */
                               inl_s=D_DIGGRPLEN;
                               while (TRUE) {
                                 do {
                                   *(achl_cur)-- = ('0'+dsl_d.rem);
                                   dsl_d = ldiv(dsl_d.quot,DECBASE);
                                 } while (--inl_s);
                                 achl_cur -= inl_dgsp_lo;  /* skip digits-separator */
                                 if (--inl_dgsp_tm==0)
                                   break;
                                 inl_s=D_DIGGRPLEN;
                               }
                             }
                             if (inl_dgsp_ph) {  /* precision may provoke leading separator */
                               while (TRUE) {   /* write leading (maybe partial) digit group */
                                 *achl_cur = ('0'+dsl_d.rem);
                                 if (--inl_dgsp_ph == 0) break;
                                 achl_cur--;
                                 dsl_d = ldiv(dsl_d.quot,DECBASE);
                               }
                             }
                           } else {  /* not using digit group separation */
                             while (TRUE) {
                               *(achl_cur + --inl_emax) = ('0'+dsl_d.rem);
                               if (inl_emax <= 0) break;
                               dsl_d = ldiv(dsl_d.quot,DECBASE);
                             }
                           }
#endif
#ifdef HL_USE_LLDIV
                         } else if (sizeof(unsigned int)<=sizeof(long long int)) {
                           lldiv_t dsl_d;
                           dsl_d.quot = uml_arg/(unsigned int)DECBASE;
                           dsl_d.rem = uml_arg%(unsigned int)DECBASE;
                           if (inl_dgsp_lc) {  /* using digit group separation */
                             achl_cur += inl_emax+inl_dgsp_tm*inl_dgsp_lo-1;
                             if (inl_dgsp_tm) {  /* write all digit groups that follow a separator */
                               inl_s=D_DIGGRPLEN;
                               while (TRUE) {
                                 do {
                                   *(achl_cur)-- = ('0'+dsl_d.rem);
                                   dsl_d = lldiv(dsl_d.quot,DECBASE);
                                 } while (--inl_s);
                                 achl_cur -= inl_dgsp_lo;  /* skip digits-separator */
                                 if (--inl_dgsp_tm==0)
                                   break;
                                 inl_s=D_DIGGRPLEN;
                               }
                             }
                             if (inl_dgsp_ph) {  /* precision may provoke leading separator */
                               while (TRUE) {   /* write leading (maybe partial) digit group */
                                 *achl_cur = ('0'+dsl_d.rem);
                                 if (--inl_dgsp_ph == 0) break;
                                 achl_cur--;
                                 dsl_d = lldiv(dsl_d.quot,DECBASE);
                               }
                             }
                           } else {  /* not using digit group separation */
                             while (TRUE) {
                               *(achl_cur + --inl_emax) = ('0'+dsl_d.rem);
                               if (inl_emax <= 0) break;
                               dsl_d = lldiv(dsl_d.quot,DECBASE);
                             }
                           }
#endif
                         } else {
#endif
                           if (inl_dgsp_lc) {  /* using digit group separation */
                             achl_cur += inl_emax+inl_dgsp_tm*inl_dgsp_lo-1;
                             if (inl_dgsp_tm) {  /* write all digit groups that follow a separator */
                               inl_s=D_DIGGRPLEN;
                               while (TRUE) {
                                 do {
                                   *(achl_cur)-- = ('0'+uml_arg%(unsigned int)DECBASE);
                                   uml_arg/=(unsigned int)DECBASE;
                                 } while (--inl_s);
                                 achl_cur -= inl_dgsp_lo;  /* skip digits-separator */
                                 if (--inl_dgsp_tm==0)
                                   break;
                                 inl_s=D_DIGGRPLEN;
                               }
                             }
                             if (inl_dgsp_ph) {  /* precision may provoke leading separator */
                               while (TRUE) {   /* write leading (maybe partial) digit group */
                                 *achl_cur = ('0'+uml_arg%(unsigned int)DECBASE);
                                 if (--inl_dgsp_ph == 0) break;
                                 achl_cur--;
                                 uml_arg/=(unsigned int)DECBASE;
                               }
                             }
                           } else {  /* not using digit group separation */
                             while (--inl_emax > 0) {
                               *(achl_cur+inl_emax) = ('0'+uml_arg%(unsigned int)DECBASE);
                               uml_arg/=(unsigned int)DECBASE;
                             }
                             *achl_cur = ('0'+uml_arg);
                           }
#ifdef HL_USE_DIV
                         }
#endif
                         achl_cur += inl_emax;
                       }
                     break;
                   case 'O':
                       inl_emax = 0;
                       achl_digits = chl_spec&'\040' ? chrstrans_lc : chrstrans;  /* choose upper- or lowercase */
                       if (uml_arg!=0) {
                         int inl_e = (sizeof(unsigned int)<<3)/3;
                         if (inl_e*3 < sizeof(unsigned int)<<3)
                           inl_e++;
                         do {
                           inl_s = inl_e>>1;
                           if (uml_arg >= (unsigned int)1<<((inl_emax+inl_s)*3)) {
                             inl_emax += inl_s;
                             inl_e -= inl_s;
                           } else {
                             inl_e = inl_s;
                           }
                         } while (inl_e>1);
                         inl_emax ++;
                         /* now inl_emax is number of digits needed    */
                       }
                       inl_needed = inl_emax + inl_postfixlen;
                       if (inl_dgsp_lc) {   /* use digit group separation */
                         if (inl_emax<=D_DIGGRPLEN) {  /* digit grouping not in effect */
                           inl_dgsp_lc = 0;
                         } else {
                           const int inl_emax_1 = inl_emax-1;
#ifdef HL_USE_DIV
                           dsl_diggrp_dm = div(inl_emax_1, D_DIGGRPLEN);
                           inl_dgsp_ph++;
#else
                           inl_dgsp_tm = (inl_emax_1)/D_DIGGRPLEN;
                           inl_dgsp_ph = (inl_emax_1)%D_DIGGRPLEN+1;
#endif
                           if (inl_needed>=ull_field_width || inl_needed+inl_dgsp_tm*inl_dgsp_lc<=ull_field_width) {
                             inl_s = inl_dgsp_tm*inl_dgsp_lc;
                             inl_needed += inl_s;
                           } else {  /* prefer staying within fieldwidth over using the separator */
                             inl_dgsp_lc = 0;
                           }
                         }
                       }
                       if (!bol_precision) {
                         ull_precision = 1;  /* default precision      */
                         if (bol_padding_zero) {
                           if (ull_field_width>inl_needed && !bol_adjustleft) {
                             /* fake padding with '0' by ull_precision */
                             ull_precision = ull_field_width+(inl_dgsp_lc?inl_emax+inl_s:inl_emax)-inl_needed;
                           } else {
                             bol_padding_zero = false;  /* according to spec, zeroflag is ignored in
                                               integer conversion if left-justify-flag is present */
                           }
                         }
                       } else {
                         bol_padding_zero = false;  /* according to spec, zeroflag is ignored in
                                                       integer conversion if a precision is given */
                       }
                       if (inl_dgsp_lc) {   /* using digit group separation */
                         inl_precpad = ull_precision-(inl_emax+inl_s);
                         if (inl_precpad>0) {
#ifdef HL_USE_DIV
                           div_t dsl_d = div(inl_dgsp_ph+inl_precpad, D_DIGGRPLEN+inl_dgsp_lc);
                           inl_dgsp_tm += dsl_d.quot;
                           inl_needed += inl_precpad;
                           inl_dgsp_ph = dsl_d.rem;
#else
                           inl_needed += inl_precpad;
                           inl_dgsp_tm += (inl_dgsp_ph+inl_precpad)/(D_DIGGRPLEN+inl_dgsp_lc);
                           inl_dgsp_ph = (inl_dgsp_ph+inl_precpad)%(D_DIGGRPLEN+inl_dgsp_lc);
#endif
                           if (inl_dgsp_ph>D_DIGGRPLEN) {
                            if (bol_alternate_form && (uml_arg!=0) &&
                                !(bol_padding_zero && (ull_precision>inl_emax+inl_dgsp_tm*D_DIGGRPLEN)))
                            {               /* ensure octal prefix     */
                             inl_dgsp_tm++;
                             ull_precision += 1+inl_dgsp_lc+D_DIGGRPLEN-inl_dgsp_ph;
                             inl_needed += 1+inl_dgsp_lc+D_DIGGRPLEN-inl_dgsp_ph;
                             inl_dgsp_ph = 1;
                            } else {
                             inl_needed -= inl_dgsp_ph-D_DIGGRPLEN;
                             inl_dgsp_ph = D_DIGGRPLEN;
                            }
                           } else if (bol_alternate_form && (inl_dgsp_ph==0) && (uml_arg!=0)) {
                             if (bol_padding_zero && (ull_precision-inl_dgsp_lc>inl_emax+(inl_dgsp_tm-1)*D_DIGGRPLEN)) {
                               /* prefer staying within fieldwidth over avoiding all spacepadding */
                               inl_dgsp_tm--;
                               ull_precision -= inl_dgsp_lc;
                               inl_needed -= inl_dgsp_lc;
                               inl_dgsp_ph = D_DIGGRPLEN;
                             } else {
                               ull_precision++;
                               inl_needed++;
                               inl_dgsp_ph=1;
                             }
                           }
                           inl_precpad = ull_precision-(inl_emax+inl_dgsp_tm*inl_dgsp_lc);
                         } else {
                          if (bol_alternate_form && (uml_arg!=0)) {  /* ensure octal prefix */
                            if (inl_dgsp_ph>=D_DIGGRPLEN) {
                              inl_dgsp_tm++;
                              ull_precision += 1+inl_dgsp_lc+D_DIGGRPLEN-inl_dgsp_ph;
                              inl_needed += 1+inl_dgsp_lc+D_DIGGRPLEN-inl_dgsp_ph;
                              inl_dgsp_ph = 1;
                            } else {
                              ull_precision++;
                              inl_needed++;
                              inl_dgsp_ph++;
                            }
                            inl_precpad++;
                          } else {
                           inl_precpad=0;
                          }
                         }
                       } else {    /* not using digit group separation */
                         if (bol_alternate_form && (uml_arg!=0) && (ull_precision<=inl_emax))
                           ull_precision = inl_emax+1;  /* cause octal prefix */
                         inl_precpad = ull_precision-inl_emax;
                         if (inl_precpad>0) {
                           inl_needed += inl_precpad;
                         } else {
                           inl_precpad=0;
                         }
                       }
                       if (ull_field_width > inl_needed) {
                         achl_after = achl_cur+ull_field_width;
                         inl_padsp = ull_field_width-inl_needed;
                         if (!bol_adjustleft) {  /* padding left with spaces */
                           if (inl_padsp > achl_end-achl_cur)
                             {achl_after = achl_cur; break;}  /* overflow */
                           do
                             *achl_cur++ = (' ');
                           while (--inl_padsp);
                         }
                       } else {
                         achl_after = achl_cur+inl_needed;
                         inl_padsp = 0;
                       }
                       if (inl_dgsp_lc) {   /* set digit group separators */
                         /* produce the first separator                                     */
                         achl_dg = achl_cur+inl_dgsp_ph;
                         switch (iel_cs_target) {
                           case ied_chs_ascii_850:
                             inl_dgsp_lo = m_a850l_from_u8l( achl_dg, 1+achl_end-achl_dg, achl_dgsp, inl_dgsp_lb );
                             break;
                           case ied_chs_ansi_819:
                             inl_dgsp_lo = m_a819l_from_u8l( achl_dg, 1+achl_end-achl_dg, achl_dgsp, inl_dgsp_lb );
                             break;
                           CASE_IED_CHS_MISCCODEPAGES
                           CASE_IED_CHS_ISO8859_2TO16
                             inl_dgsp_lo = m_sbcl_from_u8l( achl_dg, 1+achl_end-achl_dg, iel_cs_target, achl_dgsp, inl_dgsp_lb );
                             break;
                           CASE_IED_CHS_ALL_CJK
                             inl_dgsp_lo = m_mbcl_from_u8l( achl_dg, 1+achl_end-achl_dg, awcl_back_t, achl_dgsp, inl_dgsp_lb, NULL );
                             break;
                           case ied_chs_utf_8:
                             memcpy( achl_dg, achl_dgsp, achl_end-achl_dg<inl_dgsp_lb?achl_end-achl_dg:inl_dgsp_lb );
                             inl_dgsp_lo = inl_dgsp_lb;
                             break;
                           default:
                             break;
                         }
                         /* now the complete physical output length can be determined      */
                         inl_s = inl_dgsp_tm*(inl_dgsp_lo-inl_dgsp_lc);  /* adjustment from logical to physical */
                         achl_after += inl_s;
                         if (inl_dgsp_lo<0 || achl_after-achl_cur>achl_end-achl_cur)
                           {achl_after = achl_cur; break;}  /* overflow */
                         /* copy the other separators from the first one                   */
                         inl_s = inl_dgsp_tm-1;
                         if (inl_s) {
                           achl0 = achl_dg+inl_dgsp_lo;
                           do {
                             achl0 += D_DIGGRPLEN;
                             int inl2 = 0;
                             do
                               *achl0++ = achl_dg[inl2++];
                             while (inl2<inl_dgsp_lo);
                           } while (--inl_s);
                         }
                         /* padding left with zeroes to "precision"                        */
                         while (inl_precpad) {
                           if (inl_dgsp_ph == 0) {  /* skip digits-separator */
                             achl_cur += inl_dgsp_lo;
                             inl_dgsp_ph = D_DIGGRPLEN-1;
                             inl_dgsp_tm--;
                             if (!inl_dgsp_tm)
                               break;
                           } else {
                             inl_dgsp_ph--;
                           }
                           *achl_cur++ = ('0');
                           inl_precpad --;
                         }
                       } else {             /* not using digit group separation */
                         if (achl_after-achl_cur>achl_end-achl_cur)
                           {achl_after = achl_cur; break;}  /* overflow */
                         /* padding left with zeroes to "precision"    */
                         while (inl_precpad) {
                           *achl_cur++ = ('0');
                           inl_precpad --;
                         }
                       }
                       /* postfix                                      */
                       if (inl_postfixlen) {
                         if (inl_postfixlen==2) {
                           *(achl_after-(inl_padsp+2)) = (chl_postfix);
                           *(achl_after-(inl_padsp+1)) = ('i');
                         } else {
                           *(achl_after-(inl_padsp+1)) = (chl_postfix);
                         }
                       }
                       /* padding right with spaces                    */
                       if (inl_padsp) {
                         achl0 = achl_after-1;
                         do
                           *achl0-- = (' ');
                         while (--inl_padsp);
                       }
                       if (inl_emax!=0) {  /* done if zero-"precision" zero */
                         inl_emax --;
                         inl_emax *= 3;
                         if (inl_dgsp_lc) {  /* using digit group separation */
                           while (TRUE) {
                             while (inl_dgsp_ph) {
                               *(achl_cur)++ = (achl_digits[(uml_arg>>inl_emax) & (1<<3)-1]);
                               inl_dgsp_ph--;
                               inl_emax -= 3;
                             }
                             inl_dgsp_tm--;
                             if (!inl_dgsp_tm)
                               break;       /* all digitgroups done    */
                             achl_cur += inl_dgsp_lo;  /* skip digits-separator */
                             inl_dgsp_ph = D_DIGGRPLEN-1;
                           }
                         } else {  /* not using digit group separation */
                           while(TRUE) {
                             *(achl_cur) = (achl_digits[(uml_arg>>inl_emax) & (1<<3)-1]);
                             if (inl_emax==0)
                               break;
                             (achl_cur)++;
                             inl_emax -= 3;
                           }
                         }
                       }
                     break;
                   case 'X':
                       inl_emax = 0;
                       achl_digits = chl_spec&'\040' ? chrstrans_lc : chrstrans;  /* choose upper- or lowercase */
                       if (uml_arg!=0) {
                         int inl_e = (sizeof(unsigned int)<<3)/4;
                         if (inl_e*4 < sizeof(unsigned int)<<3)
                           inl_e++;
                         do {
                           inl_s = inl_e>>1;
                           if (uml_arg >= (unsigned int)1<<((inl_emax+inl_s)*4)) {
                             inl_emax += inl_s;
                             inl_e -= inl_s;
                           } else {
                             inl_e = inl_s;
                           }
                         } while (inl_e>1);
                         inl_emax ++;
                         /* now inl_emax is number of digits needed    */
                       }
                       inl_needed = inl_emax + inl_postfixlen;
                       if (bol_alternate_form && (uml_arg!=0))
                         inl_needed += 2;   /* for hex prefix          */
                       if (inl_dgsp_lc) {   /* use digit group separation */
                         if (inl_emax<=D_DIGGRPLEN) {  /* digit grouping not in effect */
                           inl_dgsp_lc = 0;
                         } else {
                           const int inl_emax_1 = inl_emax-1;
#ifdef HL_USE_DIV
                           dsl_diggrp_dm = div(inl_emax_1, D_DIGGRPLEN);
                           inl_dgsp_ph++;
#else
                           inl_dgsp_tm = (inl_emax_1)/D_DIGGRPLEN;
                           inl_dgsp_ph = (inl_emax_1)%D_DIGGRPLEN+1;
#endif
                           if (inl_needed>=ull_field_width || inl_needed+inl_dgsp_tm*inl_dgsp_lc<=ull_field_width) {
                             inl_s = inl_dgsp_tm*inl_dgsp_lc;
                             inl_needed += inl_s;
                           } else {  /* prefer staying within fieldwidth over using the separator */
                             inl_dgsp_lc = 0;
                           }
                         }
                       }
                       if (!bol_precision) {
                         ull_precision = 1;  /* default precision      */
                         if (bol_padding_zero) {
                           if (ull_field_width>inl_needed && !bol_adjustleft) {
                             /* fake padding with '0' by ull_precision */
                             ull_precision = ull_field_width+(inl_dgsp_lc?inl_emax+inl_s:inl_emax)-inl_needed;
                           }
                         }
                       }
                       if (inl_dgsp_lc) {   /* using digit group separation */
                         inl_precpad = ull_precision-(inl_emax+inl_s);
                         if (inl_precpad>0) {
#ifdef HL_USE_DIV
                           div_t dsl_d = div(inl_dgsp_ph+inl_precpad, D_DIGGRPLEN+inl_dgsp_lc);
                           inl_dgsp_tm += dsl_d.quot;
                           inl_needed += inl_precpad;
                           inl_dgsp_ph = dsl_d.rem;
#else
                           inl_needed += inl_precpad;
                           inl_dgsp_tm += (inl_dgsp_ph+inl_precpad)/(D_DIGGRPLEN+inl_dgsp_lc);
                           inl_dgsp_ph = (inl_dgsp_ph+inl_precpad)%(D_DIGGRPLEN+inl_dgsp_lc);
#endif
                           if (inl_dgsp_ph>D_DIGGRPLEN) {
                             inl_needed -= inl_dgsp_ph-D_DIGGRPLEN;
                             inl_dgsp_ph = D_DIGGRPLEN;
                           }
                           inl_precpad = ull_precision-(inl_emax+inl_dgsp_tm*inl_dgsp_lc);
                         } else {
                           inl_precpad=0;
                         }
                       } else {    /* not using digit group separation */
                         inl_precpad = ull_precision-inl_emax;
                         if (inl_precpad>0) {
                           inl_needed += inl_precpad;
                         } else {
                           inl_precpad=0;
                         }
                       }
                       if (ull_field_width > inl_needed) {
                         achl_after = achl_cur+ull_field_width;
                         inl_padsp = ull_field_width-inl_needed;
                         if (!bol_adjustleft) {  /* padding left with spaces */
                           if (inl_padsp > achl_end-achl_cur)
                             {achl_after = achl_cur; break;}  /* overflow */
                           do
                             *achl_cur++ = (' ');
                           while (--inl_padsp);
                         }
                       } else {
                         achl_after = achl_cur+inl_needed;
                         inl_padsp = 0;
                       }
                       if (inl_dgsp_lc) {   /* set digit group separators */
                         if (bol_alternate_form && (uml_arg!=0)) {  /* write hex prefix    */
                           if (2 > achl_end-achl_cur)
                             {achl_after = achl_cur; break;}  /* overflow */
                           *achl_cur++ = ('0');
                           *achl_cur++ = ('X'|(chl_spec&'\040'));
                         }
                         /* produce the first separator                                     */
                         achl_dg = achl_cur+inl_dgsp_ph;
                         switch (iel_cs_target) {
                           case ied_chs_ascii_850:
                             inl_dgsp_lo = m_a850l_from_u8l( achl_dg, 1+achl_end-achl_dg, achl_dgsp, inl_dgsp_lb );
                             break;
                           case ied_chs_ansi_819:
                             inl_dgsp_lo = m_a819l_from_u8l( achl_dg, 1+achl_end-achl_dg, achl_dgsp, inl_dgsp_lb );
                             break;
                           CASE_IED_CHS_MISCCODEPAGES
                           CASE_IED_CHS_ISO8859_2TO16
                             inl_dgsp_lo = m_sbcl_from_u8l( achl_dg, 1+achl_end-achl_dg, iel_cs_target, achl_dgsp, inl_dgsp_lb );
                             break;
                           CASE_IED_CHS_ALL_CJK
                             inl_dgsp_lo = m_mbcl_from_u8l( achl_dg, 1+achl_end-achl_dg, awcl_back_t, achl_dgsp, inl_dgsp_lb, NULL );
                             break;
                           case ied_chs_utf_8:
                             memcpy( achl_dg, achl_dgsp, achl_end-achl_dg<inl_dgsp_lb?achl_end-achl_dg:inl_dgsp_lb );
                             inl_dgsp_lo = inl_dgsp_lb;
                             break;
                           default:
                             break;
                         }
                         /* now the complete physical output length can be determined      */
                         inl_s = inl_dgsp_tm*(inl_dgsp_lo-inl_dgsp_lc);  /* adjustment from logical to physical */
                         achl_after += inl_s;
                         if (inl_dgsp_lo<0 || achl_after-achl_cur>achl_end-achl_cur)
                           {achl_after = achl_cur; break;}  /* overflow */
                         /* copy the other separators from the first one                   */
                         inl_s = inl_dgsp_tm-1;
                         if (inl_s) {
                           achl0 = achl_dg+inl_dgsp_lo;
                           do {
                             achl0 += D_DIGGRPLEN;
                             int inl2 = 0;
                             do
                               *achl0++ = achl_dg[inl2++];
                             while (inl2<inl_dgsp_lo);
                           } while (--inl_s);
                         }
                         /* padding left with zeroes to "precision"                        */
                         while (inl_precpad) {
                           if (inl_dgsp_ph == 0) {  /* skip digits-separator */
                             achl_cur += inl_dgsp_lo;
                             inl_dgsp_ph = D_DIGGRPLEN-1;
                             inl_dgsp_tm--;
                             if (!inl_dgsp_tm)
                               break;
                           } else {
                             inl_dgsp_ph--;
                           }
                           *achl_cur++ = ('0');
                           inl_precpad --;
                         }
                       } else {             /* not using digit group separation */
                         if (achl_after-achl_cur>achl_end-achl_cur)
                           {achl_after = achl_cur; break;}  /* overflow */
                         if (bol_alternate_form && (uml_arg!=0)) {  /* write hex prefix */
                           *achl_cur++ = ('0');
                           *achl_cur++ = ('X'|(chl_spec&'\040'));
                         }
                         /* padding left with zeroes to "precision"    */
                         while (inl_precpad) {
                           *achl_cur++ = ('0');
                           inl_precpad --;
                         }
                       }
                       /* postfix                                      */
                       if (inl_postfixlen) {
                         if (inl_postfixlen==2) {
                           *(achl_after-(inl_padsp+2)) = (chl_postfix);
                           *(achl_after-(inl_padsp+1)) = ('i');
                         } else {
                           *(achl_after-(inl_padsp+1)) = (chl_postfix);
                         }
                       }
                       /* padding right with spaces                    */
                       if (inl_padsp) {
                         achl0 = achl_after-1;
                         do
                           *achl0-- = (' ');
                         while (--inl_padsp);
                       }
                       if (inl_emax!=0) {  /* done if zero-"precision" zero */
                         inl_emax --;
                         inl_emax *= 4;
                         if (inl_dgsp_lc) {  /* using digit group separation */
                           while (TRUE) {
                             while (inl_dgsp_ph) {
                               *(achl_cur)++ = (achl_digits[(uml_arg>>inl_emax) & (1<<4)-1]);
                               inl_dgsp_ph--;
                               inl_emax -= 4;
                             }
                             inl_dgsp_tm--;
                             if (!inl_dgsp_tm)
                               break;       /* all digitgroups done    */
                             achl_cur += inl_dgsp_lo;  /* skip digits-separator */
                             inl_dgsp_ph = D_DIGGRPLEN-1;
                           }
                         } else {  /* not using digit group separation */
                           while(TRUE) {
                             *(achl_cur) = (achl_digits[(uml_arg>>inl_emax) & (1<<4)-1]);
                             if (inl_emax==0)
                               break;
                             (achl_cur)++;
                             inl_emax -= 4;
                           }
                         }
                       }
                     break;
                 }
                 break;
               case 'l': case 'L':
                 if(bol_longlong){
                   ull_arg = va_arg(dsl_list, HL_ULONGLONG);
                   switch (chl_spec&0xDF) {
                     case 'U':

                       /* prepare %(sci-dec)- or %(sci-dec)-type of rendering */
                       if (iel_scaling!=ied_scaling_none) {
                         if (iel_scaling == ied_scaling_1000) {  /* power-of-1000-scaled */
#if HL_PRFMAXSO_LL > 4
                           if ((sizeof(HL_ULONGLONG) > 4) && (ull_arg >= D_L1000RD * ullrs_decpowbuf[9])) {
                             if (
                                 (ull_arg >= D_L1000RD * ullrs_decpowbuf[15])
                                ) {
#if HL_PRFMAXSO_LL > 8
                               if (
                                   (sizeof(HL_ULONGLONG) > 8) &&
                                   (ull_arg >= D_L1000RD * ullrs_decpowbuf[18])
                                  ) {
                                 if (ull_arg >= D_L1000RD * ullrs_decpowbuf[21]) {
                                   ull_arg =  (ull_arg + 500 * ullrs_decpowbuf[21]) / (ullrs_decpowbuf[24]);
                                   chl_postfix = 'Y';
                                 } else {
                                   ull_arg =  (ull_arg + 500 * ullrs_decpowbuf[18]) / (ullrs_decpowbuf[21]);
                                   chl_postfix = 'Z';
                                 }
                               } else {
#endif
                                 ull_arg =  (ull_arg + 500 * ullrs_decpowbuf[15]) / (ullrs_decpowbuf[18]);
                                 chl_postfix = 'E';
#if HL_PRFMAXSO_LL > 8
                               }
#endif
                             } else {
                               if (ull_arg >= D_L1000RD * ullrs_decpowbuf[12]) {
                                 ull_arg =  (ull_arg + 500 * ullrs_decpowbuf[12]) / (ullrs_decpowbuf[15]);
                                 chl_postfix = 'P';
                               } else {
                                 ull_arg =  (ull_arg + 500 * ullrs_decpowbuf[9]) / (ullrs_decpowbuf[12]);
                                 chl_postfix = 'T';
                               }
                             }
                             inl_postfixlen = 1;
                           } else {
#endif
#if HL_PRFMAXSO_LL > 2
                             if ((sizeof(HL_ULONGLONG) > 2) && (ull_arg >= D_L1000RD * ullrs_decpowbuf[3])) {
#if HL_PRFMAXSO_LL > 4
                               if ((sizeof(HL_ULONGLONG) > 4) && (ull_arg >= D_L1000RD * ullrs_decpowbuf[6])) {
                                 ull_arg =  (ull_arg + 500 * ullrs_decpowbuf[6]) / (ullrs_decpowbuf[9]);
                                 chl_postfix = 'G';
                               } else {
#endif
                                 ull_arg =  (ull_arg + 500 * ullrs_decpowbuf[3]) / (ullrs_decpowbuf[6]);
                                 chl_postfix = 'M';
#if HL_PRFMAXSO_LL > 4
                               }
#endif
                               inl_postfixlen = 1;
                             } else {
#endif
                               if (ull_arg >= D_L1000RD) {
                                 ull_arg = (ull_arg + 500) / 1000;
                                 chl_postfix = 'k';
                                 inl_postfixlen = 1;
                               }
#if HL_PRFMAXSO_LL > 2
                             }
#endif
#if HL_PRFMAXSO_LL > 4
                           }
#endif
                         }
                         else {               /* power-of-1024-scaled    */
#if HL_PRFMAXSO_LL > 4
                           if ((sizeof(HL_ULONGLONG) > 4) && (ull_arg>>30 >= D_L1024RD)) {
                             if (
                                 (ull_arg>>50 >= D_L1024RD)
                                ) {
#if HL_PRFMAXSO_LL > 8
                               if (
                                   (sizeof(HL_ULONGLONG) > 8) &&
                                   (ull_arg>>60 >= D_L1024RD)
                                  ) {
                                 if (ull_arg>>70 >= D_L1024RD) {
                                   ull_arg = (ull_arg+((HL_ULONGLONG)1<<79)) >> 80;
                                   chl_postfix = 'Y';
                                 } else {
                                   ull_arg = (ull_arg+((HL_ULONGLONG)1<<69)) >> 70;
                                   chl_postfix = 'Z';
                                 }
                               } else {
#endif
                                 ull_arg = (ull_arg+((HL_ULONGLONG)1<<59)) >> 60;
                                 chl_postfix = 'E';
#if HL_PRFMAXSO_LL > 8
                               }
#endif
                             } else {
                               if (ull_arg>>40 >= D_L1024RD) {
                                 ull_arg = (ull_arg+((HL_ULONGLONG)1<<49)) >> 50;
                                 chl_postfix = 'P';
                               } else {
                                 ull_arg = (ull_arg+((HL_ULONGLONG)1<<39)) >> 40;
                                 chl_postfix = 'T';
                               }
                             }
                             inl_postfixlen = bol_alternate_form ? 2 : 1;
                           } else {
#endif
#if HL_PRFMAXSO_LL > 2
                             if ((sizeof(HL_ULONGLONG) > 2) && (ull_arg>>10 >= D_L1024RD)) {
#if HL_PRFMAXSO_LL > 4
                               if ((sizeof(HL_ULONGLONG) > 4) && (ull_arg>>20 >= D_L1024RD)) {
                                 ull_arg = (ull_arg+((HL_ULONGLONG)1<<29)) >> 30;
                                 chl_postfix = 'G';
                               } else {
#endif
                                 ull_arg = (ull_arg+((HL_ULONGLONG)1<<19)) >> 20;
                                 chl_postfix = 'M';
#if HL_PRFMAXSO_LL > 4
                               }
#endif
                               inl_postfixlen = bol_alternate_form ? 2 : 1;
                             } else {
#endif
                               if (ull_arg >= D_L1024RD) {
                                 ull_arg = (ull_arg+0x200) >> 10;
                                 chl_postfix = 'K';
                                 inl_postfixlen = bol_alternate_form ? 2 : 1;
                               }
#if HL_PRFMAXSO_LL > 2
                             }
#endif
#if HL_PRFMAXSO_LL > 4
                           }
#endif
                         }
                       }

                       /* detect the order of magnitude of X           */
                       inl_emax = 0;
                       if (ull_arg) {
                         int inl_e = ((sizeof(HL_ULONGLONG)*240824)/100000)+1;
                         do {
                           inl_s = inl_e>>1;
                           if (ull_arg >= ullrs_decpowbuf[inl_emax+inl_s]) {
                             inl_emax += inl_s;
                             inl_e -= inl_s;
                           } else {
                             inl_e = inl_s;
                           }
                         } while (inl_e>1);
                         inl_emax ++;
                       }
                       inl_needed = inl_emax + inl_postfixlen;
                       if (inl_dgsp_lc) {   /* use digit group separation */
                         if (inl_emax<=D_DIGGRPLEN) {  /* digit grouping not in effect */
                           inl_dgsp_lc = 0;
                         } else {
                           const int inl_emax_1 = inl_emax-1;
#ifdef HL_USE_DIV
                           dsl_diggrp_dm = div(inl_emax_1, D_DIGGRPLEN);
                           inl_dgsp_ph++;
#else
                           inl_dgsp_tm = (inl_emax_1)/D_DIGGRPLEN;
                           inl_dgsp_ph = (inl_emax_1)%D_DIGGRPLEN+1;
#endif
                           if (inl_needed>=ull_field_width || inl_needed+inl_dgsp_tm*inl_dgsp_lc<=ull_field_width) {
                             inl_s = inl_dgsp_tm*inl_dgsp_lc;
                             inl_needed += inl_s;
                           } else {  /* prefer staying within fieldwidth over using the separator */
                             inl_dgsp_lc = 0;
                           }
                         }
                       }
                       if (!bol_precision) {
                         ull_precision = 1;  /* default precision      */
                         if (bol_padding_zero) {
                           if (ull_field_width>inl_needed && !bol_adjustleft) {
                             /* fake padding with '0' by ull_precision */
                             ull_precision = ull_field_width+(inl_dgsp_lc?inl_emax+inl_s:inl_emax)-inl_needed;
                           }
                         }
                       }
                       if (inl_dgsp_lc) {   /* using digit group separation */
                         inl_precpad = ull_precision-(inl_emax+inl_s);
                         if (inl_precpad>0) {
#ifdef HL_USE_DIV
                           div_t dsl_d = div(inl_dgsp_ph+inl_precpad, D_DIGGRPLEN+inl_dgsp_lc);
                           inl_dgsp_tm += dsl_d.quot;
                           inl_needed += inl_precpad;
                           inl_dgsp_ph = dsl_d.rem;
#else
                           inl_needed += inl_precpad;
                           inl_dgsp_tm += (inl_dgsp_ph+inl_precpad)/(D_DIGGRPLEN+inl_dgsp_lc);
                           inl_dgsp_ph = (inl_dgsp_ph+inl_precpad)%(D_DIGGRPLEN+inl_dgsp_lc);
#endif
                           if (inl_dgsp_ph>D_DIGGRPLEN) {
                             inl_needed -= inl_dgsp_ph-D_DIGGRPLEN;
                             inl_dgsp_ph = D_DIGGRPLEN;
                           }
                           inl_precpad = ull_precision-(inl_emax+inl_dgsp_tm*inl_dgsp_lc);
                         } else {
                           inl_precpad=0;
                         }
                       } else {    /* not using digit group separation */
                         inl_precpad = ull_precision-inl_emax;
                         if (inl_precpad>0) {
                           inl_needed += inl_precpad;
                         } else {
                           inl_precpad=0;
                         }
                       }
                       if (ull_field_width > inl_needed) {
                         achl_after = achl_cur+ull_field_width;
                         inl_padsp = ull_field_width-inl_needed;
                         if (!bol_adjustleft) {  /* padding left with spaces */
                           if (inl_padsp > achl_end-achl_cur)
                             {achl_after = achl_cur; break;}  /* overflow */
                           do
                             *achl_cur++ = (' ');
                           while (--inl_padsp);
                         }
                       } else {
                         achl_after = achl_cur+inl_needed;
                         inl_padsp = 0;
                       }
                       if (inl_dgsp_lc) {   /* set digit group separators */
                         /* produce the first separator                                     */
                         achl_dg = achl_cur+inl_dgsp_ph;
                         switch (iel_cs_target) {
                           case ied_chs_ascii_850:
                             inl_dgsp_lo = m_a850l_from_u8l( achl_dg, 1+achl_end-achl_dg, achl_dgsp, inl_dgsp_lb );
                             break;
                           case ied_chs_ansi_819:
                             inl_dgsp_lo = m_a819l_from_u8l( achl_dg, 1+achl_end-achl_dg, achl_dgsp, inl_dgsp_lb );
                             break;
                           CASE_IED_CHS_MISCCODEPAGES
                           CASE_IED_CHS_ISO8859_2TO16
                             inl_dgsp_lo = m_sbcl_from_u8l( achl_dg, 1+achl_end-achl_dg, iel_cs_target, achl_dgsp, inl_dgsp_lb );
                             break;
                           CASE_IED_CHS_ALL_CJK
                             inl_dgsp_lo = m_mbcl_from_u8l( achl_dg, 1+achl_end-achl_dg, awcl_back_t, achl_dgsp, inl_dgsp_lb, NULL );
                             break;
                           case ied_chs_utf_8:
                             memcpy( achl_dg, achl_dgsp, achl_end-achl_dg<inl_dgsp_lb?achl_end-achl_dg:inl_dgsp_lb );
                             inl_dgsp_lo = inl_dgsp_lb;
                             break;
                           default:
                             break;
                         }
                         /* now the complete physical output length can be determined      */
                         inl_s = inl_dgsp_tm*(inl_dgsp_lo-inl_dgsp_lc);  /* adjustment from logical to physical */
                         achl_after += inl_s;
                         if (inl_dgsp_lo<0 || achl_after-achl_cur>achl_end-achl_cur)
                           {achl_after = achl_cur; break;}  /* overflow */
                         /* copy the other separators from the first one                   */
                         inl_s = inl_dgsp_tm-1;
                         if (inl_s) {
                           achl0 = achl_dg+inl_dgsp_lo;
                           do {
                             achl0 += D_DIGGRPLEN;
                             int inl2 = 0;
                             do
                               *achl0++ = achl_dg[inl2++];
                             while (inl2<inl_dgsp_lo);
                           } while (--inl_s);
                         }
                         /* padding left with zeroes to "precision"                        */
                         while (inl_precpad) {
                           if (inl_dgsp_ph == 0) {  /* skip digits-separator */
                             achl_cur += inl_dgsp_lo;
                             inl_dgsp_ph = D_DIGGRPLEN-1;
                             inl_dgsp_tm--;
                             if (!inl_dgsp_tm)
                               break;
                           } else {
                             inl_dgsp_ph--;
                           }
                           *achl_cur++ = ('0');
                           inl_precpad --;
                         }
                       } else {             /* not using digit group separation */
                         if (achl_after-achl_cur>achl_end-achl_cur)
                           {achl_after = achl_cur; break;}  /* overflow */
                         /* padding left with zeroes to "precision"    */
                         while (inl_precpad) {
                           *achl_cur++ = ('0');
                           inl_precpad --;
                         }
                       }
                       /* postfix                                      */
                       if (inl_postfixlen) {
                         if (inl_postfixlen==2) {
                           *(achl_after-(inl_padsp+2)) = (chl_postfix);
                           *(achl_after-(inl_padsp+1)) = ('i');
                         } else {
                           *(achl_after-(inl_padsp+1)) = (chl_postfix);
                         }
                       }
                       /* padding right with spaces                    */
                       if (inl_padsp) {
                         achl0 = achl_after-1;
                         do
                           *achl0-- = (' ');
                         while (--inl_padsp);
                       }
                       /* produce the digits                           */
                       if (inl_emax > 0) {
#ifdef HL_USE_DIV
                         if (sizeof(HL_ULONGLONG)<=sizeof(int)) {
                           div_t dsl_d;
                           dsl_d.quot = ull_arg/(HL_ULONGLONG)DECBASE;
                           dsl_d.rem = ull_arg%(HL_ULONGLONG)DECBASE;
                           if (inl_dgsp_lc) {  /* using digit group separation */
                             achl_cur += inl_emax+inl_dgsp_tm*inl_dgsp_lo-1;
                             if (inl_dgsp_tm) {  /* write all digit groups that follow a separator */
                               inl_s=D_DIGGRPLEN;
                               while (TRUE) {
                                 do {
                                   *(achl_cur)-- = ('0'+dsl_d.rem);
                                   dsl_d = div(dsl_d.quot,DECBASE);
                                 } while (--inl_s);
                                 achl_cur -= inl_dgsp_lo;  /* skip digits-separator */
                                 if (--inl_dgsp_tm==0)
                                   break;
                                 inl_s=D_DIGGRPLEN;
                               }
                             }
                             if (inl_dgsp_ph) {  /* precision may provoke leading separator */
                               while (TRUE) {   /* write leading (maybe partial) digit group */
                                 *achl_cur = ('0'+dsl_d.rem);
                                 if (--inl_dgsp_ph == 0) break;
                                 achl_cur--;
                                 dsl_d = div(dsl_d.quot,DECBASE);
                               }
                             }
                           } else {  /* not using digit group separation */
                             while (TRUE) {
                               *(achl_cur + --inl_emax) = ('0'+dsl_d.rem);
                               if (inl_emax <= 0) break;
                               dsl_d = div(dsl_d.quot,DECBASE);
                             }
                           }
#ifdef HL_USE_LDIV
                         } else if (sizeof(HL_ULONGLONG)<=sizeof(long int)) {
                           ldiv_t dsl_d;
                           dsl_d.quot = ull_arg/(HL_ULONGLONG)DECBASE;
                           dsl_d.rem = ull_arg%(HL_ULONGLONG)DECBASE;
                           if (inl_dgsp_lc) {  /* using digit group separation */
                             achl_cur += inl_emax+inl_dgsp_tm*inl_dgsp_lo-1;
                             if (inl_dgsp_tm) {  /* write all digit groups that follow a separator */
                               inl_s=D_DIGGRPLEN;
                               while (TRUE) {
                                 do {
                                   *(achl_cur)-- = ('0'+dsl_d.rem);
                                   dsl_d = ldiv(dsl_d.quot,DECBASE);
                                 } while (--inl_s);
                                 achl_cur -= inl_dgsp_lo;  /* skip digits-separator */
                                 if (--inl_dgsp_tm==0)
                                   break;
                                 inl_s=D_DIGGRPLEN;
                               }
                             }
                             if (inl_dgsp_ph) {  /* precision may provoke leading separator */
                               while (TRUE) {   /* write leading (maybe partial) digit group */
                                 *achl_cur = ('0'+dsl_d.rem);
                                 if (--inl_dgsp_ph == 0) break;
                                 achl_cur--;
                                 dsl_d = ldiv(dsl_d.quot,DECBASE);
                               }
                             }
                           } else {  /* not using digit group separation */
                             while (TRUE) {
                               *(achl_cur + --inl_emax) = ('0'+dsl_d.rem);
                               if (inl_emax <= 0) break;
                               dsl_d = ldiv(dsl_d.quot,DECBASE);
                             }
                           }
#endif
#ifdef HL_USE_LLDIV
                         } else if (sizeof(HL_ULONGLONG)<=sizeof(long long int)) {
                           lldiv_t dsl_d;
                           dsl_d.quot = ull_arg/(HL_ULONGLONG)DECBASE;
                           dsl_d.rem = ull_arg%(HL_ULONGLONG)DECBASE;
                           if (inl_dgsp_lc) {  /* using digit group separation */
                             achl_cur += inl_emax+inl_dgsp_tm*inl_dgsp_lo-1;
                             if (inl_dgsp_tm) {  /* write all digit groups that follow a separator */
                               inl_s=D_DIGGRPLEN;
                               while (TRUE) {
                                 do {
                                   *(achl_cur)-- = ('0'+dsl_d.rem);
                                   dsl_d = lldiv(dsl_d.quot,DECBASE);
                                 } while (--inl_s);
                                 achl_cur -= inl_dgsp_lo;  /* skip digits-separator */
                                 if (--inl_dgsp_tm==0)
                                   break;
                                 inl_s=D_DIGGRPLEN;
                               }
                             }
                             if (inl_dgsp_ph) {  /* precision may provoke leading separator */
                               while (TRUE) {   /* write leading (maybe partial) digit group */
                                 *achl_cur = ('0'+dsl_d.rem);
                                 if (--inl_dgsp_ph == 0) break;
                                 achl_cur--;
                                 dsl_d = lldiv(dsl_d.quot,DECBASE);
                               }
                             }
                           } else {  /* not using digit group separation */
                             while (TRUE) {
                               *(achl_cur + --inl_emax) = ('0'+dsl_d.rem);
                               if (inl_emax <= 0) break;
                               dsl_d = lldiv(dsl_d.quot,DECBASE);
                             }
                           }
#endif
                         } else {
#endif
                           if (inl_dgsp_lc) {  /* using digit group separation */
                             achl_cur += inl_emax+inl_dgsp_tm*inl_dgsp_lo-1;
                             if (inl_dgsp_tm) {  /* write all digit groups that follow a separator */
                               inl_s=D_DIGGRPLEN;
                               while (TRUE) {
                                 do {
                                   *(achl_cur)-- = ('0'+ull_arg%(HL_ULONGLONG)DECBASE);
                                   ull_arg/=(HL_ULONGLONG)DECBASE;
                                 } while (--inl_s);
                                 achl_cur -= inl_dgsp_lo;  /* skip digits-separator */
                                 if (--inl_dgsp_tm==0)
                                   break;
                                 inl_s=D_DIGGRPLEN;
                               }
                             }
                             if (inl_dgsp_ph) {  /* precision may provoke leading separator */
                               while (TRUE) {   /* write leading (maybe partial) digit group */
                                 *achl_cur = ('0'+ull_arg%(HL_ULONGLONG)DECBASE);
                                 if (--inl_dgsp_ph == 0) break;
                                 achl_cur--;
                                 ull_arg/=(HL_ULONGLONG)DECBASE;
                               }
                             }
                           } else {  /* not using digit group separation */
                             while (--inl_emax > 0) {
                               *(achl_cur+inl_emax) = ('0'+ull_arg%(HL_ULONGLONG)DECBASE);
                               ull_arg/=(HL_ULONGLONG)DECBASE;
                             }
                             *achl_cur = ('0'+ull_arg);
                           }
#ifdef HL_USE_DIV
                         }
#endif
                         achl_cur += inl_emax;
                       }
                       break;
                     case 'O':
                       inl_emax = 0;
                       achl_digits = chl_spec&'\040' ? chrstrans_lc : chrstrans;  /* choose upper- or lowercase */
                       if (ull_arg!=0) {
                         int inl_e = (sizeof(HL_ULONGLONG)<<3)/3;
                         if (inl_e*3 < sizeof(HL_ULONGLONG)<<3)
                           inl_e++;
                         do {
                           inl_s = inl_e>>1;
                           if (ull_arg >= (HL_ULONGLONG)1<<((inl_emax+inl_s)*3)) {
                             inl_emax += inl_s;
                             inl_e -= inl_s;
                           } else {
                             inl_e = inl_s;
                           }
                         } while (inl_e>1);
                         inl_emax ++;
                         /* now inl_emax is number of digits needed    */
                       }
                       inl_needed = inl_emax + inl_postfixlen;
                       if (inl_dgsp_lc) {   /* use digit group separation */
                         if (inl_emax<=D_DIGGRPLEN) {  /* digit grouping not in effect */
                           inl_dgsp_lc = 0;
                         } else {
                           const int inl_emax_1 = inl_emax-1;
#ifdef HL_USE_DIV
                           dsl_diggrp_dm = div(inl_emax_1, D_DIGGRPLEN);
                           inl_dgsp_ph++;
#else
                           inl_dgsp_tm = (inl_emax_1)/D_DIGGRPLEN;
                           inl_dgsp_ph = (inl_emax_1)%D_DIGGRPLEN+1;
#endif
                           if (inl_needed>=ull_field_width || inl_needed+inl_dgsp_tm*inl_dgsp_lc<=ull_field_width) {
                             inl_s = inl_dgsp_tm*inl_dgsp_lc;
                             inl_needed += inl_s;
                           } else {  /* prefer staying within fieldwidth over using the separator */
                             inl_dgsp_lc = 0;
                           }
                         }
                       }
                       if (!bol_precision) {
                         ull_precision = 1;  /* default precision      */
                         if (bol_padding_zero) {
                           if (ull_field_width>inl_needed && !bol_adjustleft) {
                             /* fake padding with '0' by ull_precision */
                             ull_precision = ull_field_width+(inl_dgsp_lc?inl_emax+inl_s:inl_emax)-inl_needed;
                           } else {
                             bol_padding_zero = false;  /* according to spec, zeroflag is ignored in
                                               integer conversion if left-justify-flag is present */
                           }
                         }
                       } else {
                         bol_padding_zero = false;  /* according to spec, zeroflag is ignored in
                                                       integer conversion if a precision is given */
                       }
                       if (inl_dgsp_lc) {   /* using digit group separation */
                         inl_precpad = ull_precision-(inl_emax+inl_s);
                         if (inl_precpad>0) {
#ifdef HL_USE_DIV
                           div_t dsl_d = div(inl_dgsp_ph+inl_precpad, D_DIGGRPLEN+inl_dgsp_lc);
                           inl_dgsp_tm += dsl_d.quot;
                           inl_needed += inl_precpad;
                           inl_dgsp_ph = dsl_d.rem;
#else
                           inl_needed += inl_precpad;
                           inl_dgsp_tm += (inl_dgsp_ph+inl_precpad)/(D_DIGGRPLEN+inl_dgsp_lc);
                           inl_dgsp_ph = (inl_dgsp_ph+inl_precpad)%(D_DIGGRPLEN+inl_dgsp_lc);
#endif
                           if (inl_dgsp_ph>D_DIGGRPLEN) {
                            if (bol_alternate_form && (ull_arg!=0) &&
                                !(bol_padding_zero && (ull_precision>inl_emax+inl_dgsp_tm*D_DIGGRPLEN)))
                            {               /* ensure octal prefix     */
                             inl_dgsp_tm++;
                             ull_precision += 1+inl_dgsp_lc+D_DIGGRPLEN-inl_dgsp_ph;
                             inl_needed += 1+inl_dgsp_lc+D_DIGGRPLEN-inl_dgsp_ph;
                             inl_dgsp_ph = 1;
                            } else {
                             inl_needed -= inl_dgsp_ph-D_DIGGRPLEN;
                             inl_dgsp_ph = D_DIGGRPLEN;
                            }
                           } else if (bol_alternate_form && (inl_dgsp_ph==0) && (ull_arg!=0)) {
                             if (bol_padding_zero && (ull_precision-inl_dgsp_lc>inl_emax+(inl_dgsp_tm-1)*D_DIGGRPLEN)) {
                               /* prefer staying within fieldwidth over avoiding all spacepadding */
                               inl_dgsp_tm--;
                               ull_precision -= inl_dgsp_lc;
                               inl_needed -= inl_dgsp_lc;
                               inl_dgsp_ph = D_DIGGRPLEN;
                             } else {
                               ull_precision++;
                               inl_needed++;
                               inl_dgsp_ph=1;
                             }
                           }
                           inl_precpad = ull_precision-(inl_emax+inl_dgsp_tm*inl_dgsp_lc);
                         } else {
                          if (bol_alternate_form && (ull_arg!=0)) {  /* ensure octal prefix */
                            if (inl_dgsp_ph>=D_DIGGRPLEN) {
                              inl_dgsp_tm++;
                              ull_precision += 1+inl_dgsp_lc+D_DIGGRPLEN-inl_dgsp_ph;
                              inl_needed += 1+inl_dgsp_lc+D_DIGGRPLEN-inl_dgsp_ph;
                              inl_dgsp_ph = 1;
                            } else {
                              ull_precision++;
                              inl_needed++;
                              inl_dgsp_ph++;
                            }
                            inl_precpad++;
                          } else {
                           inl_precpad=0;
                          }
                         }
                       } else {    /* not using digit group separation */
                         if (bol_alternate_form && (ull_arg!=0) && (ull_precision<=inl_emax))
                           ull_precision = inl_emax+1;  /* cause octal prefix */
                         inl_precpad = ull_precision-inl_emax;
                         if (inl_precpad>0) {
                           inl_needed += inl_precpad;
                         } else {
                           inl_precpad=0;
                         }
                       }
                       if (ull_field_width > inl_needed) {
                         achl_after = achl_cur+ull_field_width;
                         inl_padsp = ull_field_width-inl_needed;
                         if (!bol_adjustleft) {  /* padding left with spaces */
                           if (inl_padsp > achl_end-achl_cur)
                             {achl_after = achl_cur; break;}  /* overflow */
                           do
                             *achl_cur++ = (' ');
                           while (--inl_padsp);
                         }
                       } else {
                         achl_after = achl_cur+inl_needed;
                         inl_padsp = 0;
                       }
                       if (inl_dgsp_lc) {   /* set digit group separators */
                         /* produce the first separator                                     */
                         achl_dg = achl_cur+inl_dgsp_ph;
                         switch (iel_cs_target) {
                           case ied_chs_ascii_850:
                             inl_dgsp_lo = m_a850l_from_u8l( achl_dg, 1+achl_end-achl_dg, achl_dgsp, inl_dgsp_lb );
                             break;
                           case ied_chs_ansi_819:
                             inl_dgsp_lo = m_a819l_from_u8l( achl_dg, 1+achl_end-achl_dg, achl_dgsp, inl_dgsp_lb );
                             break;
                           CASE_IED_CHS_MISCCODEPAGES
                           CASE_IED_CHS_ISO8859_2TO16
                             inl_dgsp_lo = m_sbcl_from_u8l( achl_dg, 1+achl_end-achl_dg, iel_cs_target, achl_dgsp, inl_dgsp_lb );
                             break;
                           CASE_IED_CHS_ALL_CJK
                             inl_dgsp_lo = m_mbcl_from_u8l( achl_dg, 1+achl_end-achl_dg, awcl_back_t, achl_dgsp, inl_dgsp_lb, NULL );
                             break;
                           case ied_chs_utf_8:
                             memcpy( achl_dg, achl_dgsp, achl_end-achl_dg<inl_dgsp_lb?achl_end-achl_dg:inl_dgsp_lb );
                             inl_dgsp_lo = inl_dgsp_lb;
                             break;
                           default:
                             break;
                         }
                         /* now the complete physical output length can be determined      */
                         inl_s = inl_dgsp_tm*(inl_dgsp_lo-inl_dgsp_lc);  /* adjustment from logical to physical */
                         achl_after += inl_s;
                         if (inl_dgsp_lo<0 || achl_after-achl_cur>achl_end-achl_cur)
                           {achl_after = achl_cur; break;}  /* overflow */
                         /* copy the other separators from the first one                   */
                         inl_s = inl_dgsp_tm-1;
                         if (inl_s) {
                           achl0 = achl_dg+inl_dgsp_lo;
                           do {
                             achl0 += D_DIGGRPLEN;
                             int inl2 = 0;
                             do
                               *achl0++ = achl_dg[inl2++];
                             while (inl2<inl_dgsp_lo);
                           } while (--inl_s);
                         }
                         /* padding left with zeroes to "precision"                        */
                         while (inl_precpad) {
                           if (inl_dgsp_ph == 0) {  /* skip digits-separator */
                             achl_cur += inl_dgsp_lo;
                             inl_dgsp_ph = D_DIGGRPLEN-1;
                             inl_dgsp_tm--;
                             if (!inl_dgsp_tm)
                               break;
                           } else {
                             inl_dgsp_ph--;
                           }
                           *achl_cur++ = ('0');
                           inl_precpad --;
                         }
                       } else {             /* not using digit group separation */
                         if (achl_after-achl_cur>achl_end-achl_cur)
                           {achl_after = achl_cur; break;}  /* overflow */
                         /* padding left with zeroes to "precision"    */
                         while (inl_precpad) {
                           *achl_cur++ = ('0');
                           inl_precpad --;
                         }
                       }
                       /* postfix                                      */
                       if (inl_postfixlen) {
                         if (inl_postfixlen==2) {
                           *(achl_after-(inl_padsp+2)) = (chl_postfix);
                           *(achl_after-(inl_padsp+1)) = ('i');
                         } else {
                           *(achl_after-(inl_padsp+1)) = (chl_postfix);
                         }
                       }
                       /* padding right with spaces                    */
                       if (inl_padsp) {
                         achl0 = achl_after-1;
                         do
                           *achl0-- = (' ');
                         while (--inl_padsp);
                       }
                       if (inl_emax!=0) {  /* done if zero-"precision" zero */
                         inl_emax --;
                         inl_emax *= 3;
                         if (inl_dgsp_lc) {  /* using digit group separation */
                           while (TRUE) {
                             while (inl_dgsp_ph) {
                               *(achl_cur)++ = (achl_digits[(ull_arg>>inl_emax) & (1<<3)-1]);
                               inl_dgsp_ph--;
                               inl_emax -= 3;
                             }
                             inl_dgsp_tm--;
                             if (!inl_dgsp_tm)
                               break;       /* all digitgroups done    */
                             achl_cur += inl_dgsp_lo;  /* skip digits-separator */
                             inl_dgsp_ph = D_DIGGRPLEN-1;
                           }
                         } else {  /* not using digit group separation */
                           while(TRUE) {
                             *(achl_cur) = (achl_digits[(ull_arg>>inl_emax) & (1<<3)-1]);
                             if (inl_emax==0)
                               break;
                             (achl_cur)++;
                             inl_emax -= 3;
                           }
                         }
                       }
                       break;
                     case 'X':
                       inl_emax = 0;
                       achl_digits = chl_spec&'\040' ? chrstrans_lc : chrstrans;  /* choose upper- or lowercase */
                       if (ull_arg!=0) {
                         int inl_e = (sizeof(HL_ULONGLONG)<<3)/4;
                         if (inl_e*4 < sizeof(HL_ULONGLONG)<<3)
                           inl_e++;
                         do {
                           inl_s = inl_e>>1;
                           if (ull_arg >= (HL_ULONGLONG)1<<((inl_emax+inl_s)*4)) {
                             inl_emax += inl_s;
                             inl_e -= inl_s;
                           } else {
                             inl_e = inl_s;
                           }
                         } while (inl_e>1);
                         inl_emax ++;
                         /* now inl_emax is number of digits needed    */
                       }
                       inl_needed = inl_emax + inl_postfixlen;
                       if (bol_alternate_form && (ull_arg!=0))
                         inl_needed += 2;   /* for hex prefix          */
                       if (inl_dgsp_lc) {   /* use digit group separation */
                         if (inl_emax<=D_DIGGRPLEN) {  /* digit grouping not in effect */
                           inl_dgsp_lc = 0;
                         } else {
                           const int inl_emax_1 = inl_emax-1;
#ifdef HL_USE_DIV
                           dsl_diggrp_dm = div(inl_emax_1, D_DIGGRPLEN);
                           inl_dgsp_ph++;
#else
                           inl_dgsp_tm = (inl_emax_1)/D_DIGGRPLEN;
                           inl_dgsp_ph = (inl_emax_1)%D_DIGGRPLEN+1;
#endif
                           if (inl_needed>=ull_field_width || inl_needed+inl_dgsp_tm*inl_dgsp_lc<=ull_field_width) {
                             inl_s = inl_dgsp_tm*inl_dgsp_lc;
                             inl_needed += inl_s;
                           } else {  /* prefer staying within fieldwidth over using the separator */
                             inl_dgsp_lc = 0;
                           }
                         }
                       }
                       if (!bol_precision) {
                         ull_precision = 1;  /* default precision      */
                         if (bol_padding_zero) {
                           if (ull_field_width>inl_needed && !bol_adjustleft) {
                             /* fake padding with '0' by ull_precision */
                             ull_precision = ull_field_width+(inl_dgsp_lc?inl_emax+inl_s:inl_emax)-inl_needed;
                           }
                         }
                       }
                       if (inl_dgsp_lc) {   /* using digit group separation */
                         inl_precpad = ull_precision-(inl_emax+inl_s);
                         if (inl_precpad>0) {
#ifdef HL_USE_DIV
                           div_t dsl_d = div(inl_dgsp_ph+inl_precpad, D_DIGGRPLEN+inl_dgsp_lc);
                           inl_dgsp_tm += dsl_d.quot;
                           inl_needed += inl_precpad;
                           inl_dgsp_ph = dsl_d.rem;
#else
                           inl_needed += inl_precpad;
                           inl_dgsp_tm += (inl_dgsp_ph+inl_precpad)/(D_DIGGRPLEN+inl_dgsp_lc);
                           inl_dgsp_ph = (inl_dgsp_ph+inl_precpad)%(D_DIGGRPLEN+inl_dgsp_lc);
#endif
                           if (inl_dgsp_ph>D_DIGGRPLEN) {
                             inl_needed -= inl_dgsp_ph-D_DIGGRPLEN;
                             inl_dgsp_ph = D_DIGGRPLEN;
                           }
                           inl_precpad = ull_precision-(inl_emax+inl_dgsp_tm*inl_dgsp_lc);
                         } else {
                           inl_precpad=0;
                         }
                       } else {    /* not using digit group separation */
                         inl_precpad = ull_precision-inl_emax;
                         if (inl_precpad>0) {
                           inl_needed += inl_precpad;
                         } else {
                           inl_precpad=0;
                         }
                       }
                       if (ull_field_width > inl_needed) {
                         achl_after = achl_cur+ull_field_width;
                         inl_padsp = ull_field_width-inl_needed;
                         if (!bol_adjustleft) {  /* padding left with spaces */
                           if (inl_padsp > achl_end-achl_cur)
                             {achl_after = achl_cur; break;}  /* overflow */
                           do
                             *achl_cur++ = (' ');
                           while (--inl_padsp);
                         }
                       } else {
                         achl_after = achl_cur+inl_needed;
                         inl_padsp = 0;
                       }
                       if (inl_dgsp_lc) {   /* set digit group separators */
                         if (bol_alternate_form && (ull_arg!=0)) {  /* write hex prefix    */
                           if (2 > achl_end-achl_cur)
                             {achl_after = achl_cur; break;}  /* overflow */
                           *achl_cur++ = ('0');
                           *achl_cur++ = ('X'|(chl_spec&'\040'));
                         }
                         /* produce the first separator                                     */
                         achl_dg = achl_cur+inl_dgsp_ph;
                         switch (iel_cs_target) {
                           case ied_chs_ascii_850:
                             inl_dgsp_lo = m_a850l_from_u8l( achl_dg, 1+achl_end-achl_dg, achl_dgsp, inl_dgsp_lb );
                             break;
                           case ied_chs_ansi_819:
                             inl_dgsp_lo = m_a819l_from_u8l( achl_dg, 1+achl_end-achl_dg, achl_dgsp, inl_dgsp_lb );
                             break;
                           CASE_IED_CHS_MISCCODEPAGES
                           CASE_IED_CHS_ISO8859_2TO16
                             inl_dgsp_lo = m_sbcl_from_u8l( achl_dg, 1+achl_end-achl_dg, iel_cs_target, achl_dgsp, inl_dgsp_lb );
                             break;
                           CASE_IED_CHS_ALL_CJK
                             inl_dgsp_lo = m_mbcl_from_u8l( achl_dg, 1+achl_end-achl_dg, awcl_back_t, achl_dgsp, inl_dgsp_lb, NULL );
                             break;
                           case ied_chs_utf_8:
                             memcpy( achl_dg, achl_dgsp, achl_end-achl_dg<inl_dgsp_lb?achl_end-achl_dg:inl_dgsp_lb );
                             inl_dgsp_lo = inl_dgsp_lb;
                             break;
                           default:
                             break;
                         }
                         /* now the complete physical output length can be determined      */
                         inl_s = inl_dgsp_tm*(inl_dgsp_lo-inl_dgsp_lc);  /* adjustment from logical to physical */
                         achl_after += inl_s;
                         if (inl_dgsp_lo<0 || achl_after-achl_cur>achl_end-achl_cur)
                           {achl_after = achl_cur; break;}  /* overflow */
                         /* copy the other separators from the first one                   */
                         inl_s = inl_dgsp_tm-1;
                         if (inl_s) {
                           achl0 = achl_dg+inl_dgsp_lo;
                           do {
                             achl0 += D_DIGGRPLEN;
                             int inl2 = 0;
                             do
                               *achl0++ = achl_dg[inl2++];
                             while (inl2<inl_dgsp_lo);
                           } while (--inl_s);
                         }
                         /* padding left with zeroes to "precision"                        */
                         while (inl_precpad) {
                           if (inl_dgsp_ph == 0) {  /* skip digits-separator */
                             achl_cur += inl_dgsp_lo;
                             inl_dgsp_ph = D_DIGGRPLEN-1;
                             inl_dgsp_tm--;
                             if (!inl_dgsp_tm)
                               break;
                           } else {
                             inl_dgsp_ph--;
                           }
                           *achl_cur++ = ('0');
                           inl_precpad --;
                         }
                       } else {             /* not using digit group separation */
                         if (achl_after-achl_cur>achl_end-achl_cur)
                           {achl_after = achl_cur; break;}  /* overflow */
                         if (bol_alternate_form && (ull_arg!=0)) {  /* write hex prefix */
                           *achl_cur++ = ('0');
                           *achl_cur++ = ('X'|(chl_spec&'\040'));
                         }
                         /* padding left with zeroes to "precision"    */
                         while (inl_precpad) {
                           *achl_cur++ = ('0');
                           inl_precpad --;
                         }
                       }
                       /* postfix                                      */
                       if (inl_postfixlen) {
                         if (inl_postfixlen==2) {
                           *(achl_after-(inl_padsp+2)) = (chl_postfix);
                           *(achl_after-(inl_padsp+1)) = ('i');
                         } else {
                           *(achl_after-(inl_padsp+1)) = (chl_postfix);
                         }
                       }
                       /* padding right with spaces                    */
                       if (inl_padsp) {
                         achl0 = achl_after-1;
                         do
                           *achl0-- = (' ');
                         while (--inl_padsp);
                       }
                       if (inl_emax!=0) {  /* done if zero-"precision" zero */
                         inl_emax --;
                         inl_emax *= 4;
                         if (inl_dgsp_lc) {  /* using digit group separation */
                           while (TRUE) {
                             while (inl_dgsp_ph) {
                               *(achl_cur)++ = (achl_digits[(ull_arg>>inl_emax) & (1<<4)-1]);
                               inl_dgsp_ph--;
                               inl_emax -= 4;
                             }
                             inl_dgsp_tm--;
                             if (!inl_dgsp_tm)
                               break;       /* all digitgroups done    */
                             achl_cur += inl_dgsp_lo;  /* skip digits-separator */
                             inl_dgsp_ph = D_DIGGRPLEN-1;
                           }
                         } else {  /* not using digit group separation */
                           while(TRUE) {
                             *(achl_cur) = (achl_digits[(ull_arg>>inl_emax) & (1<<4)-1]);
                             if (inl_emax==0)
                               break;
                             (achl_cur)++;
                             inl_emax -= 4;
                           }
                         }
                       }
                       break;
                   }
                 }
                 else {
                   ull_arg = va_arg(dsl_list, unsigned long int);
                   switch (chl_spec&0xDF) {
                     case 'U':

                       /* prepare %(sci-dec)- or %(sci-dec)-type of rendering */
                       if (iel_scaling!=ied_scaling_none) {
                         if (iel_scaling == ied_scaling_1000) {  /* power-of-1000-scaled */
#if HL_PRFMAXSO_L > 4
                           if ((sizeof(unsigned long int) > 4) && (ull_arg >= D_L1000RD * ullrs_decpowbuf[9])) {
                             if (
                                 (ull_arg >= D_L1000RD * ullrs_decpowbuf[15])
                                ) {
#if HL_PRFMAXSO_L > 8
                               if (
                                   (sizeof(unsigned long int) > 8) &&
                                   (ull_arg >= D_L1000RD * ullrs_decpowbuf[18])
                                  ) {
                                 if (ull_arg >= D_L1000RD * ullrs_decpowbuf[21]) {
                                   ull_arg =  (ull_arg + 500 * ullrs_decpowbuf[21]) / (ullrs_decpowbuf[24]);
                                   chl_postfix = 'Y';
                                 } else {
                                   ull_arg =  (ull_arg + 500 * ullrs_decpowbuf[18]) / (ullrs_decpowbuf[21]);
                                   chl_postfix = 'Z';
                                 }
                               } else {
#endif
                                 ull_arg =  (ull_arg + 500 * ullrs_decpowbuf[15]) / (ullrs_decpowbuf[18]);
                                 chl_postfix = 'E';
#if HL_PRFMAXSO_L > 8
                               }
#endif
                             } else {
                               if (ull_arg >= D_L1000RD * ullrs_decpowbuf[12]) {
                                 ull_arg =  (ull_arg + 500 * ullrs_decpowbuf[12]) / (ullrs_decpowbuf[15]);
                                 chl_postfix = 'P';
                               } else {
                                 ull_arg =  (ull_arg + 500 * ullrs_decpowbuf[9]) / (ullrs_decpowbuf[12]);
                                 chl_postfix = 'T';
                               }
                             }
                             inl_postfixlen = 1;
                           } else {
#endif
#if HL_PRFMAXSO_L > 2
                             if ((sizeof(unsigned long int) > 2) && (ull_arg >= D_L1000RD * ullrs_decpowbuf[3])) {
#if HL_PRFMAXSO_L > 4
                               if ((sizeof(unsigned long int) > 4) && (ull_arg >= D_L1000RD * ullrs_decpowbuf[6])) {
                                 ull_arg =  (ull_arg + 500 * ullrs_decpowbuf[6]) / (ullrs_decpowbuf[9]);
                                 chl_postfix = 'G';
                               } else {
#endif
                                 ull_arg =  (ull_arg + 500 * ullrs_decpowbuf[3]) / (ullrs_decpowbuf[6]);
                                 chl_postfix = 'M';
#if HL_PRFMAXSO_L > 4
                               }
#endif
                               inl_postfixlen = 1;
                             } else {
#endif
                               if (ull_arg >= D_L1000RD) {
                                 ull_arg = (ull_arg + 500) / 1000;
                                 chl_postfix = 'k';
                                 inl_postfixlen = 1;
                               }
#if HL_PRFMAXSO_L > 2
                             }
#endif
#if HL_PRFMAXSO_L > 4
                           }
#endif
                         }
                         else {               /* power-of-1024-scaled    */
#if HL_PRFMAXSO_L > 4
                           if ((sizeof(unsigned long int) > 4) && (ull_arg>>30 >= D_L1024RD)) {
                             if (
                                 (ull_arg>>50 >= D_L1024RD)
                                ) {
#if HL_PRFMAXSO_L > 8
                               if (
                                   (sizeof(unsigned long int) > 8) &&
                                   (ull_arg>>60 >= D_L1024RD)
                                  ) {
                                 if (ull_arg>>70 >= D_L1024RD) {
                                   ull_arg = (ull_arg+((unsigned long int)1<<79)) >> 80;
                                   chl_postfix = 'Y';
                                 } else {
                                   ull_arg = (ull_arg+((unsigned long int)1<<69)) >> 70;
                                   chl_postfix = 'Z';
                                 }
                               } else {
#endif
                                 ull_arg = (ull_arg+((unsigned long int)1<<59)) >> 60;
                                 chl_postfix = 'E';
#if HL_PRFMAXSO_L > 8
                               }
#endif
                             } else {
                               if (ull_arg>>40 >= D_L1024RD) {
                                 ull_arg = (ull_arg+((unsigned long int)1<<49)) >> 50;
                                 chl_postfix = 'P';
                               } else {
                                 ull_arg = (ull_arg+((unsigned long int)1<<39)) >> 40;
                                 chl_postfix = 'T';
                               }
                             }
                             inl_postfixlen = bol_alternate_form ? 2 : 1;
                           } else {
#endif
#if HL_PRFMAXSO_L > 2
                             if ((sizeof(unsigned long int) > 2) && (ull_arg>>10 >= D_L1024RD)) {
#if HL_PRFMAXSO_L > 4
                               if ((sizeof(unsigned long int) > 4) && (ull_arg>>20 >= D_L1024RD)) {
                                 ull_arg = (ull_arg+((unsigned long int)1<<29)) >> 30;
                                 chl_postfix = 'G';
                               } else {
#endif
                                 ull_arg = (ull_arg+((unsigned long int)1<<19)) >> 20;
                                 chl_postfix = 'M';
#if HL_PRFMAXSO_L > 4
                               }
#endif
                               inl_postfixlen = bol_alternate_form ? 2 : 1;
                             } else {
#endif
                               if (ull_arg >= D_L1024RD) {
                                 ull_arg = (ull_arg+0x200) >> 10;
                                 chl_postfix = 'K';
                                 inl_postfixlen = bol_alternate_form ? 2 : 1;
                               }
#if HL_PRFMAXSO_L > 2
                             }
#endif
#if HL_PRFMAXSO_L > 4
                           }
#endif
                         }
                       }

                       /* detect the order of magnitude of X           */
                       inl_emax = 0;
                       if (ull_arg) {
                         int inl_e = ((sizeof(unsigned long int)*240824)/100000)+1;
                         do {
                           inl_s = inl_e>>1;
                           if (ull_arg >= ullrs_decpowbuf[inl_emax+inl_s]) {
                             inl_emax += inl_s;
                             inl_e -= inl_s;
                           } else {
                             inl_e = inl_s;
                           }
                         } while (inl_e>1);
                         inl_emax ++;
                       }
                       inl_needed = inl_emax + inl_postfixlen;
                       if (inl_dgsp_lc) {   /* use digit group separation */
                         if (inl_emax<=D_DIGGRPLEN) {  /* digit grouping not in effect */
                           inl_dgsp_lc = 0;
                         } else {
                           const int inl_emax_1 = inl_emax-1;
#ifdef HL_USE_DIV
                           dsl_diggrp_dm = div(inl_emax_1, D_DIGGRPLEN);
                           inl_dgsp_ph++;
#else
                           inl_dgsp_tm = (inl_emax_1)/D_DIGGRPLEN;
                           inl_dgsp_ph = (inl_emax_1)%D_DIGGRPLEN+1;
#endif
                           if (inl_needed>=ull_field_width || inl_needed+inl_dgsp_tm*inl_dgsp_lc<=ull_field_width) {
                             inl_s = inl_dgsp_tm*inl_dgsp_lc;
                             inl_needed += inl_s;
                           } else {  /* prefer staying within fieldwidth over using the separator */
                             inl_dgsp_lc = 0;
                           }
                         }
                       }
                       if (!bol_precision) {
                         ull_precision = 1;  /* default precision      */
                         if (bol_padding_zero) {
                           if (ull_field_width>inl_needed && !bol_adjustleft) {
                             /* fake padding with '0' by ull_precision */
                             ull_precision = ull_field_width+(inl_dgsp_lc?inl_emax+inl_s:inl_emax)-inl_needed;
                           }
                         }
                       }
                       if (inl_dgsp_lc) {   /* using digit group separation */
                         inl_precpad = ull_precision-(inl_emax+inl_s);
                         if (inl_precpad>0) {
#ifdef HL_USE_DIV
                           div_t dsl_d = div(inl_dgsp_ph+inl_precpad, D_DIGGRPLEN+inl_dgsp_lc);
                           inl_dgsp_tm += dsl_d.quot;
                           inl_needed += inl_precpad;
                           inl_dgsp_ph = dsl_d.rem;
#else
                           inl_needed += inl_precpad;
                           inl_dgsp_tm += (inl_dgsp_ph+inl_precpad)/(D_DIGGRPLEN+inl_dgsp_lc);
                           inl_dgsp_ph = (inl_dgsp_ph+inl_precpad)%(D_DIGGRPLEN+inl_dgsp_lc);
#endif
                           if (inl_dgsp_ph>D_DIGGRPLEN) {
                             inl_needed -= inl_dgsp_ph-D_DIGGRPLEN;
                             inl_dgsp_ph = D_DIGGRPLEN;
                           }
                           inl_precpad = ull_precision-(inl_emax+inl_dgsp_tm*inl_dgsp_lc);
                         } else {
                           inl_precpad=0;
                         }
                       } else {    /* not using digit group separation */
                         inl_precpad = ull_precision-inl_emax;
                         if (inl_precpad>0) {
                           inl_needed += inl_precpad;
                         } else {
                           inl_precpad=0;
                         }
                       }
                       if (ull_field_width > inl_needed) {
                         achl_after = achl_cur+ull_field_width;
                         inl_padsp = ull_field_width-inl_needed;
                         if (!bol_adjustleft) {  /* padding left with spaces */
                           if (inl_padsp > achl_end-achl_cur)
                             {achl_after = achl_cur; break;}  /* overflow */
                           do
                             *achl_cur++ = (' ');
                           while (--inl_padsp);
                         }
                       } else {
                         achl_after = achl_cur+inl_needed;
                         inl_padsp = 0;
                       }
                       if (inl_dgsp_lc) {   /* set digit group separators */
                         /* produce the first separator                                     */
                         achl_dg = achl_cur+inl_dgsp_ph;
                         switch (iel_cs_target) {
                           case ied_chs_ascii_850:
                             inl_dgsp_lo = m_a850l_from_u8l( achl_dg, 1+achl_end-achl_dg, achl_dgsp, inl_dgsp_lb );
                             break;
                           case ied_chs_ansi_819:
                             inl_dgsp_lo = m_a819l_from_u8l( achl_dg, 1+achl_end-achl_dg, achl_dgsp, inl_dgsp_lb );
                             break;
                           CASE_IED_CHS_MISCCODEPAGES
                           CASE_IED_CHS_ISO8859_2TO16
                             inl_dgsp_lo = m_sbcl_from_u8l( achl_dg, 1+achl_end-achl_dg, iel_cs_target, achl_dgsp, inl_dgsp_lb );
                             break;
                           CASE_IED_CHS_ALL_CJK
                             inl_dgsp_lo = m_mbcl_from_u8l( achl_dg, 1+achl_end-achl_dg, awcl_back_t, achl_dgsp, inl_dgsp_lb, NULL );
                             break;
                           case ied_chs_utf_8:
                             memcpy( achl_dg, achl_dgsp, achl_end-achl_dg<inl_dgsp_lb?achl_end-achl_dg:inl_dgsp_lb );
                             inl_dgsp_lo = inl_dgsp_lb;
                             break;
                           default:
                             break;
                         }
                         /* now the complete physical output length can be determined      */
                         inl_s = inl_dgsp_tm*(inl_dgsp_lo-inl_dgsp_lc);  /* adjustment from logical to physical */
                         achl_after += inl_s;
                         if (inl_dgsp_lo<0 || achl_after-achl_cur>achl_end-achl_cur)
                           {achl_after = achl_cur; break;}  /* overflow */
                         /* copy the other separators from the first one                   */
                         inl_s = inl_dgsp_tm-1;
                         if (inl_s) {
                           achl0 = achl_dg+inl_dgsp_lo;
                           do {
                             achl0 += D_DIGGRPLEN;
                             int inl2 = 0;
                             do
                               *achl0++ = achl_dg[inl2++];
                             while (inl2<inl_dgsp_lo);
                           } while (--inl_s);
                         }
                         /* padding left with zeroes to "precision"                        */
                         while (inl_precpad) {
                           if (inl_dgsp_ph == 0) {  /* skip digits-separator */
                             achl_cur += inl_dgsp_lo;
                             inl_dgsp_ph = D_DIGGRPLEN-1;
                             inl_dgsp_tm--;
                             if (!inl_dgsp_tm)
                               break;
                           } else {
                             inl_dgsp_ph--;
                           }
                           *achl_cur++ = ('0');
                           inl_precpad --;
                         }
                       } else {             /* not using digit group separation */
                         if (achl_after-achl_cur>achl_end-achl_cur)
                           {achl_after = achl_cur; break;}  /* overflow */
                         /* padding left with zeroes to "precision"    */
                         while (inl_precpad) {
                           *achl_cur++ = ('0');
                           inl_precpad --;
                         }
                       }
                       /* postfix                                      */
                       if (inl_postfixlen) {
                         if (inl_postfixlen==2) {
                           *(achl_after-(inl_padsp+2)) = (chl_postfix);
                           *(achl_after-(inl_padsp+1)) = ('i');
                         } else {
                           *(achl_after-(inl_padsp+1)) = (chl_postfix);
                         }
                       }
                       /* padding right with spaces                    */
                       if (inl_padsp) {
                         achl0 = achl_after-1;
                         do
                           *achl0-- = (' ');
                         while (--inl_padsp);
                       }
                       /* produce the digits                           */
                       if (inl_emax > 0) {
#ifdef HL_USE_DIV
                         if (sizeof(unsigned long int)<=sizeof(int)) {
                           div_t dsl_d;
                           dsl_d.quot = ull_arg/(unsigned long int)DECBASE;
                           dsl_d.rem = ull_arg%(unsigned long int)DECBASE;
                           if (inl_dgsp_lc) {  /* using digit group separation */
                             achl_cur += inl_emax+inl_dgsp_tm*inl_dgsp_lo-1;
                             if (inl_dgsp_tm) {  /* write all digit groups that follow a separator */
                               inl_s=D_DIGGRPLEN;
                               while (TRUE) {
                                 do {
                                   *(achl_cur)-- = ('0'+dsl_d.rem);
                                   dsl_d = div(dsl_d.quot,DECBASE);
                                 } while (--inl_s);
                                 achl_cur -= inl_dgsp_lo;  /* skip digits-separator */
                                 if (--inl_dgsp_tm==0)
                                   break;
                                 inl_s=D_DIGGRPLEN;
                               }
                             }
                             if (inl_dgsp_ph) {  /* precision may provoke leading separator */
                               while (TRUE) {   /* write leading (maybe partial) digit group */
                                 *achl_cur = ('0'+dsl_d.rem);
                                 if (--inl_dgsp_ph == 0) break;
                                 achl_cur--;
                                 dsl_d = div(dsl_d.quot,DECBASE);
                               }
                             }
                           } else {  /* not using digit group separation */
                             while (TRUE) {
                               *(achl_cur + --inl_emax) = ('0'+dsl_d.rem);
                               if (inl_emax <= 0) break;
                               dsl_d = div(dsl_d.quot,DECBASE);
                             }
                           }
#ifdef HL_USE_LDIV
                         } else if (sizeof(unsigned long int)<=sizeof(long int)) {
                           ldiv_t dsl_d;
                           dsl_d.quot = ull_arg/(unsigned long int)DECBASE;
                           dsl_d.rem = ull_arg%(unsigned long int)DECBASE;
                           if (inl_dgsp_lc) {  /* using digit group separation */
                             achl_cur += inl_emax+inl_dgsp_tm*inl_dgsp_lo-1;
                             if (inl_dgsp_tm) {  /* write all digit groups that follow a separator */
                               inl_s=D_DIGGRPLEN;
                               while (TRUE) {
                                 do {
                                   *(achl_cur)-- = ('0'+dsl_d.rem);
                                   dsl_d = ldiv(dsl_d.quot,DECBASE);
                                 } while (--inl_s);
                                 achl_cur -= inl_dgsp_lo;  /* skip digits-separator */
                                 if (--inl_dgsp_tm==0)
                                   break;
                                 inl_s=D_DIGGRPLEN;
                               }
                             }
                             if (inl_dgsp_ph) {  /* precision may provoke leading separator */
                               while (TRUE) {   /* write leading (maybe partial) digit group */
                                 *achl_cur = ('0'+dsl_d.rem);
                                 if (--inl_dgsp_ph == 0) break;
                                 achl_cur--;
                                 dsl_d = ldiv(dsl_d.quot,DECBASE);
                               }
                             }
                           } else {  /* not using digit group separation */
                             while (TRUE) {
                               *(achl_cur + --inl_emax) = ('0'+dsl_d.rem);
                               if (inl_emax <= 0) break;
                               dsl_d = ldiv(dsl_d.quot,DECBASE);
                             }
                           }
#endif
#ifdef HL_USE_LLDIV
                         } else if (sizeof(unsigned long int)<=sizeof(long long int)) {
                           lldiv_t dsl_d;
                           dsl_d.quot = ull_arg/(unsigned long int)DECBASE;
                           dsl_d.rem = ull_arg%(unsigned long int)DECBASE;
                           if (inl_dgsp_lc) {  /* using digit group separation */
                             achl_cur += inl_emax+inl_dgsp_tm*inl_dgsp_lo-1;
                             if (inl_dgsp_tm) {  /* write all digit groups that follow a separator */
                               inl_s=D_DIGGRPLEN;
                               while (TRUE) {
                                 do {
                                   *(achl_cur)-- = ('0'+dsl_d.rem);
                                   dsl_d = lldiv(dsl_d.quot,DECBASE);
                                 } while (--inl_s);
                                 achl_cur -= inl_dgsp_lo;  /* skip digits-separator */
                                 if (--inl_dgsp_tm==0)
                                   break;
                                 inl_s=D_DIGGRPLEN;
                               }
                             }
                             if (inl_dgsp_ph) {  /* precision may provoke leading separator */
                               while (TRUE) {   /* write leading (maybe partial) digit group */
                                 *achl_cur = ('0'+dsl_d.rem);
                                 if (--inl_dgsp_ph == 0) break;
                                 achl_cur--;
                                 dsl_d = lldiv(dsl_d.quot,DECBASE);
                               }
                             }
                           } else {  /* not using digit group separation */
                             while (TRUE) {
                               *(achl_cur + --inl_emax) = ('0'+dsl_d.rem);
                               if (inl_emax <= 0) break;
                               dsl_d = lldiv(dsl_d.quot,DECBASE);
                             }
                           }
#endif
                         } else {
#endif
                           if (inl_dgsp_lc) {  /* using digit group separation */
                             achl_cur += inl_emax+inl_dgsp_tm*inl_dgsp_lo-1;
                             if (inl_dgsp_tm) {  /* write all digit groups that follow a separator */
                               inl_s=D_DIGGRPLEN;
                               while (TRUE) {
                                 do {
                                   *(achl_cur)-- = ('0'+ull_arg%(unsigned long int)DECBASE);
                                   ull_arg/=(unsigned long int)DECBASE;
                                 } while (--inl_s);
                                 achl_cur -= inl_dgsp_lo;  /* skip digits-separator */
                                 if (--inl_dgsp_tm==0)
                                   break;
                                 inl_s=D_DIGGRPLEN;
                               }
                             }
                             if (inl_dgsp_ph) {  /* precision may provoke leading separator */
                               while (TRUE) {   /* write leading (maybe partial) digit group */
                                 *achl_cur = ('0'+ull_arg%(unsigned long int)DECBASE);
                                 if (--inl_dgsp_ph == 0) break;
                                 achl_cur--;
                                 ull_arg/=(unsigned long int)DECBASE;
                               }
                             }
                           } else {  /* not using digit group separation */
                             while (--inl_emax > 0) {
                               *(achl_cur+inl_emax) = ('0'+ull_arg%(unsigned long int)DECBASE);
                               ull_arg/=(unsigned long int)DECBASE;
                             }
                             *achl_cur = ('0'+ull_arg);
                           }
#ifdef HL_USE_DIV
                         }
#endif
                         achl_cur += inl_emax;
                       }
                       break;
                     case 'O':
                       inl_emax = 0;
                       achl_digits = chl_spec&'\040' ? chrstrans_lc : chrstrans;  /* choose upper- or lowercase */
                       if (ull_arg!=0) {
                         int inl_e = (sizeof(unsigned long int)<<3)/3;
                         if (inl_e*3 < sizeof(unsigned long int)<<3)
                           inl_e++;
                         do {
                           inl_s = inl_e>>1;
                           if (ull_arg >= (unsigned long int)1<<((inl_emax+inl_s)*3)) {
                             inl_emax += inl_s;
                             inl_e -= inl_s;
                           } else {
                             inl_e = inl_s;
                           }
                         } while (inl_e>1);
                         inl_emax ++;
                         /* now inl_emax is number of digits needed    */
                       }
                       inl_needed = inl_emax + inl_postfixlen;
                       if (inl_dgsp_lc) {   /* use digit group separation */
                         if (inl_emax<=D_DIGGRPLEN) {  /* digit grouping not in effect */
                           inl_dgsp_lc = 0;
                         } else {
                           const int inl_emax_1 = inl_emax-1;
#ifdef HL_USE_DIV
                           dsl_diggrp_dm = div(inl_emax_1, D_DIGGRPLEN);
                           inl_dgsp_ph++;
#else
                           inl_dgsp_tm = (inl_emax_1)/D_DIGGRPLEN;
                           inl_dgsp_ph = (inl_emax_1)%D_DIGGRPLEN+1;
#endif
                           if (inl_needed>=ull_field_width || inl_needed+inl_dgsp_tm*inl_dgsp_lc<=ull_field_width) {
                             inl_s = inl_dgsp_tm*inl_dgsp_lc;
                             inl_needed += inl_s;
                           } else {  /* prefer staying within fieldwidth over using the separator */
                             inl_dgsp_lc = 0;
                           }
                         }
                       }
                       if (!bol_precision) {
                         ull_precision = 1;  /* default precision      */
                         if (bol_padding_zero) {
                           if (ull_field_width>inl_needed && !bol_adjustleft) {
                             /* fake padding with '0' by ull_precision */
                             ull_precision = ull_field_width+(inl_dgsp_lc?inl_emax+inl_s:inl_emax)-inl_needed;
                           } else {
                             bol_padding_zero = false;  /* according to spec, zeroflag is ignored in
                                               integer conversion if left-justify-flag is present */
                           }
                         }
                       } else {
                         bol_padding_zero = false;  /* according to spec, zeroflag is ignored in
                                                       integer conversion if a precision is given */
                       }
                       if (inl_dgsp_lc) {   /* using digit group separation */
                         inl_precpad = ull_precision-(inl_emax+inl_s);
                         if (inl_precpad>0) {
#ifdef HL_USE_DIV
                           div_t dsl_d = div(inl_dgsp_ph+inl_precpad, D_DIGGRPLEN+inl_dgsp_lc);
                           inl_dgsp_tm += dsl_d.quot;
                           inl_needed += inl_precpad;
                           inl_dgsp_ph = dsl_d.rem;
#else
                           inl_needed += inl_precpad;
                           inl_dgsp_tm += (inl_dgsp_ph+inl_precpad)/(D_DIGGRPLEN+inl_dgsp_lc);
                           inl_dgsp_ph = (inl_dgsp_ph+inl_precpad)%(D_DIGGRPLEN+inl_dgsp_lc);
#endif
                           if (inl_dgsp_ph>D_DIGGRPLEN) {
                            if (bol_alternate_form && (ull_arg!=0) &&
                                !(bol_padding_zero && (ull_precision>inl_emax+inl_dgsp_tm*D_DIGGRPLEN)))
                            {               /* ensure octal prefix     */
                             inl_dgsp_tm++;
                             ull_precision += 1+inl_dgsp_lc+D_DIGGRPLEN-inl_dgsp_ph;
                             inl_needed += 1+inl_dgsp_lc+D_DIGGRPLEN-inl_dgsp_ph;
                             inl_dgsp_ph = 1;
                            } else {
                             inl_needed -= inl_dgsp_ph-D_DIGGRPLEN;
                             inl_dgsp_ph = D_DIGGRPLEN;
                            }
                           } else if (bol_alternate_form && (inl_dgsp_ph==0) && (ull_arg!=0)) {
                             if (bol_padding_zero && (ull_precision-inl_dgsp_lc>inl_emax+(inl_dgsp_tm-1)*D_DIGGRPLEN)) {
                               /* prefer staying within fieldwidth over avoiding all spacepadding */
                               inl_dgsp_tm--;
                               ull_precision -= inl_dgsp_lc;
                               inl_needed -= inl_dgsp_lc;
                               inl_dgsp_ph = D_DIGGRPLEN;
                             } else {
                               ull_precision++;
                               inl_needed++;
                               inl_dgsp_ph=1;
                             }
                           }
                           inl_precpad = ull_precision-(inl_emax+inl_dgsp_tm*inl_dgsp_lc);
                         } else {
                          if (bol_alternate_form && (ull_arg!=0)) {  /* ensure octal prefix */
                            if (inl_dgsp_ph>=D_DIGGRPLEN) {
                              inl_dgsp_tm++;
                              ull_precision += 1+inl_dgsp_lc+D_DIGGRPLEN-inl_dgsp_ph;
                              inl_needed += 1+inl_dgsp_lc+D_DIGGRPLEN-inl_dgsp_ph;
                              inl_dgsp_ph = 1;
                            } else {
                              ull_precision++;
                              inl_needed++;
                              inl_dgsp_ph++;
                            }
                            inl_precpad++;
                          } else {
                           inl_precpad=0;
                          }
                         }
                       } else {    /* not using digit group separation */
                         if (bol_alternate_form && (ull_arg!=0) && (ull_precision<=inl_emax))
                           ull_precision = inl_emax+1;  /* cause octal prefix */
                         inl_precpad = ull_precision-inl_emax;
                         if (inl_precpad>0) {
                           inl_needed += inl_precpad;
                         } else {
                           inl_precpad=0;
                         }
                       }
                       if (ull_field_width > inl_needed) {
                         achl_after = achl_cur+ull_field_width;
                         inl_padsp = ull_field_width-inl_needed;
                         if (!bol_adjustleft) {  /* padding left with spaces */
                           if (inl_padsp > achl_end-achl_cur)
                             {achl_after = achl_cur; break;}  /* overflow */
                           do
                             *achl_cur++ = (' ');
                           while (--inl_padsp);
                         }
                       } else {
                         achl_after = achl_cur+inl_needed;
                         inl_padsp = 0;
                       }
                       if (inl_dgsp_lc) {   /* set digit group separators */
                         /* produce the first separator                                     */
                         achl_dg = achl_cur+inl_dgsp_ph;
                         switch (iel_cs_target) {
                           case ied_chs_ascii_850:
                             inl_dgsp_lo = m_a850l_from_u8l( achl_dg, 1+achl_end-achl_dg, achl_dgsp, inl_dgsp_lb );
                             break;
                           case ied_chs_ansi_819:
                             inl_dgsp_lo = m_a819l_from_u8l( achl_dg, 1+achl_end-achl_dg, achl_dgsp, inl_dgsp_lb );
                             break;
                           CASE_IED_CHS_MISCCODEPAGES
                           CASE_IED_CHS_ISO8859_2TO16
                             inl_dgsp_lo = m_sbcl_from_u8l( achl_dg, 1+achl_end-achl_dg, iel_cs_target, achl_dgsp, inl_dgsp_lb );
                             break;
                           CASE_IED_CHS_ALL_CJK
                             inl_dgsp_lo = m_mbcl_from_u8l( achl_dg, 1+achl_end-achl_dg, awcl_back_t, achl_dgsp, inl_dgsp_lb, NULL );
                             break;
                           case ied_chs_utf_8:
                             memcpy( achl_dg, achl_dgsp, achl_end-achl_dg<inl_dgsp_lb?achl_end-achl_dg:inl_dgsp_lb );
                             inl_dgsp_lo = inl_dgsp_lb;
                             break;
                           default:
                             break;
                         }
                         /* now the complete physical output length can be determined      */
                         inl_s = inl_dgsp_tm*(inl_dgsp_lo-inl_dgsp_lc);  /* adjustment from logical to physical */
                         achl_after += inl_s;
                         if (inl_dgsp_lo<0 || achl_after-achl_cur>achl_end-achl_cur)
                           {achl_after = achl_cur; break;}  /* overflow */
                         /* copy the other separators from the first one                   */
                         inl_s = inl_dgsp_tm-1;
                         if (inl_s) {
                           achl0 = achl_dg+inl_dgsp_lo;
                           do {
                             achl0 += D_DIGGRPLEN;
                             int inl2 = 0;
                             do
                               *achl0++ = achl_dg[inl2++];
                             while (inl2<inl_dgsp_lo);
                           } while (--inl_s);
                         }
                         /* padding left with zeroes to "precision"                        */
                         while (inl_precpad) {
                           if (inl_dgsp_ph == 0) {  /* skip digits-separator */
                             achl_cur += inl_dgsp_lo;
                             inl_dgsp_ph = D_DIGGRPLEN-1;
                             inl_dgsp_tm--;
                             if (!inl_dgsp_tm)
                               break;
                           } else {
                             inl_dgsp_ph--;
                           }
                           *achl_cur++ = ('0');
                           inl_precpad --;
                         }
                       } else {             /* not using digit group separation */
                         if (achl_after-achl_cur>achl_end-achl_cur)
                           {achl_after = achl_cur; break;}  /* overflow */
                         /* padding left with zeroes to "precision"    */
                         while (inl_precpad) {
                           *achl_cur++ = ('0');
                           inl_precpad --;
                         }
                       }
                       /* postfix                                      */
                       if (inl_postfixlen) {
                         if (inl_postfixlen==2) {
                           *(achl_after-(inl_padsp+2)) = (chl_postfix);
                           *(achl_after-(inl_padsp+1)) = ('i');
                         } else {
                           *(achl_after-(inl_padsp+1)) = (chl_postfix);
                         }
                       }
                       /* padding right with spaces                    */
                       if (inl_padsp) {
                         achl0 = achl_after-1;
                         do
                           *achl0-- = (' ');
                         while (--inl_padsp);
                       }
                       if (inl_emax!=0) {  /* done if zero-"precision" zero */
                         inl_emax --;
                         inl_emax *= 3;
                         if (inl_dgsp_lc) {  /* using digit group separation */
                           while (TRUE) {
                             while (inl_dgsp_ph) {
                               *(achl_cur)++ = (achl_digits[(ull_arg>>inl_emax) & (1<<3)-1]);
                               inl_dgsp_ph--;
                               inl_emax -= 3;
                             }
                             inl_dgsp_tm--;
                             if (!inl_dgsp_tm)
                               break;       /* all digitgroups done    */
                             achl_cur += inl_dgsp_lo;  /* skip digits-separator */
                             inl_dgsp_ph = D_DIGGRPLEN-1;
                           }
                         } else {  /* not using digit group separation */
                           while(TRUE) {
                             *(achl_cur) = (achl_digits[(ull_arg>>inl_emax) & (1<<3)-1]);
                             if (inl_emax==0)
                               break;
                             (achl_cur)++;
                             inl_emax -= 3;
                           }
                         }
                       }
                       break;
                     case 'X':
                       inl_emax = 0;
                       achl_digits = chl_spec&'\040' ? chrstrans_lc : chrstrans;  /* choose upper- or lowercase */
                       if (ull_arg!=0) {
                         int inl_e = (sizeof(unsigned long int)<<3)/4;
                         if (inl_e*4 < sizeof(unsigned long int)<<3)
                           inl_e++;
                         do {
                           inl_s = inl_e>>1;
                           if (ull_arg >= (unsigned long int)1<<((inl_emax+inl_s)*4)) {
                             inl_emax += inl_s;
                             inl_e -= inl_s;
                           } else {
                             inl_e = inl_s;
                           }
                         } while (inl_e>1);
                         inl_emax ++;
                         /* now inl_emax is number of digits needed    */
                       }
                       inl_needed = inl_emax + inl_postfixlen;
                       if (bol_alternate_form && (ull_arg!=0))
                         inl_needed += 2;   /* for hex prefix          */
                       if (inl_dgsp_lc) {   /* use digit group separation */
                         if (inl_emax<=D_DIGGRPLEN) {  /* digit grouping not in effect */
                           inl_dgsp_lc = 0;
                         } else {
                           const int inl_emax_1 = inl_emax-1;
#ifdef HL_USE_DIV
                           dsl_diggrp_dm = div(inl_emax_1, D_DIGGRPLEN);
                           inl_dgsp_ph++;
#else
                           inl_dgsp_tm = (inl_emax_1)/D_DIGGRPLEN;
                           inl_dgsp_ph = (inl_emax_1)%D_DIGGRPLEN+1;
#endif
                           if (inl_needed>=ull_field_width || inl_needed+inl_dgsp_tm*inl_dgsp_lc<=ull_field_width) {
                             inl_s = inl_dgsp_tm*inl_dgsp_lc;
                             inl_needed += inl_s;
                           } else {  /* prefer staying within fieldwidth over using the separator */
                             inl_dgsp_lc = 0;
                           }
                         }
                       }
                       if (!bol_precision) {
                         ull_precision = 1;  /* default precision      */
                         if (bol_padding_zero) {
                           if (ull_field_width>inl_needed && !bol_adjustleft) {
                             /* fake padding with '0' by ull_precision */
                             ull_precision = ull_field_width+(inl_dgsp_lc?inl_emax+inl_s:inl_emax)-inl_needed;
                           }
                         }
                       }
                       if (inl_dgsp_lc) {   /* using digit group separation */
                         inl_precpad = ull_precision-(inl_emax+inl_s);
                         if (inl_precpad>0) {
#ifdef HL_USE_DIV
                           div_t dsl_d = div(inl_dgsp_ph+inl_precpad, D_DIGGRPLEN+inl_dgsp_lc);
                           inl_dgsp_tm += dsl_d.quot;
                           inl_needed += inl_precpad;
                           inl_dgsp_ph = dsl_d.rem;
#else
                           inl_needed += inl_precpad;
                           inl_dgsp_tm += (inl_dgsp_ph+inl_precpad)/(D_DIGGRPLEN+inl_dgsp_lc);
                           inl_dgsp_ph = (inl_dgsp_ph+inl_precpad)%(D_DIGGRPLEN+inl_dgsp_lc);
#endif
                           if (inl_dgsp_ph>D_DIGGRPLEN) {
                             inl_needed -= inl_dgsp_ph-D_DIGGRPLEN;
                             inl_dgsp_ph = D_DIGGRPLEN;
                           }
                           inl_precpad = ull_precision-(inl_emax+inl_dgsp_tm*inl_dgsp_lc);
                         } else {
                           inl_precpad=0;
                         }
                       } else {    /* not using digit group separation */
                         inl_precpad = ull_precision-inl_emax;
                         if (inl_precpad>0) {
                           inl_needed += inl_precpad;
                         } else {
                           inl_precpad=0;
                         }
                       }
                       if (ull_field_width > inl_needed) {
                         achl_after = achl_cur+ull_field_width;
                         inl_padsp = ull_field_width-inl_needed;
                         if (!bol_adjustleft) {  /* padding left with spaces */
                           if (inl_padsp > achl_end-achl_cur)
                             {achl_after = achl_cur; break;}  /* overflow */
                           do
                             *achl_cur++ = (' ');
                           while (--inl_padsp);
                         }
                       } else {
                         achl_after = achl_cur+inl_needed;
                         inl_padsp = 0;
                       }
                       if (inl_dgsp_lc) {   /* set digit group separators */
                         if (bol_alternate_form && (ull_arg!=0)) {  /* write hex prefix    */
                           if (2 > achl_end-achl_cur)
                             {achl_after = achl_cur; break;}  /* overflow */
                           *achl_cur++ = ('0');
                           *achl_cur++ = ('X'|(chl_spec&'\040'));
                         }
                         /* produce the first separator                                     */
                         achl_dg = achl_cur+inl_dgsp_ph;
                         switch (iel_cs_target) {
                           case ied_chs_ascii_850:
                             inl_dgsp_lo = m_a850l_from_u8l( achl_dg, 1+achl_end-achl_dg, achl_dgsp, inl_dgsp_lb );
                             break;
                           case ied_chs_ansi_819:
                             inl_dgsp_lo = m_a819l_from_u8l( achl_dg, 1+achl_end-achl_dg, achl_dgsp, inl_dgsp_lb );
                             break;
                           CASE_IED_CHS_MISCCODEPAGES
                           CASE_IED_CHS_ISO8859_2TO16
                             inl_dgsp_lo = m_sbcl_from_u8l( achl_dg, 1+achl_end-achl_dg, iel_cs_target, achl_dgsp, inl_dgsp_lb );
                             break;
                           CASE_IED_CHS_ALL_CJK
                             inl_dgsp_lo = m_mbcl_from_u8l( achl_dg, 1+achl_end-achl_dg, awcl_back_t, achl_dgsp, inl_dgsp_lb, NULL );
                             break;
                           case ied_chs_utf_8:
                             memcpy( achl_dg, achl_dgsp, achl_end-achl_dg<inl_dgsp_lb?achl_end-achl_dg:inl_dgsp_lb );
                             inl_dgsp_lo = inl_dgsp_lb;
                             break;
                           default:
                             break;
                         }
                         /* now the complete physical output length can be determined      */
                         inl_s = inl_dgsp_tm*(inl_dgsp_lo-inl_dgsp_lc);  /* adjustment from logical to physical */
                         achl_after += inl_s;
                         if (inl_dgsp_lo<0 || achl_after-achl_cur>achl_end-achl_cur)
                           {achl_after = achl_cur; break;}  /* overflow */
                         /* copy the other separators from the first one                   */
                         inl_s = inl_dgsp_tm-1;
                         if (inl_s) {
                           achl0 = achl_dg+inl_dgsp_lo;
                           do {
                             achl0 += D_DIGGRPLEN;
                             int inl2 = 0;
                             do
                               *achl0++ = achl_dg[inl2++];
                             while (inl2<inl_dgsp_lo);
                           } while (--inl_s);
                         }
                         /* padding left with zeroes to "precision"                        */
                         while (inl_precpad) {
                           if (inl_dgsp_ph == 0) {  /* skip digits-separator */
                             achl_cur += inl_dgsp_lo;
                             inl_dgsp_ph = D_DIGGRPLEN-1;
                             inl_dgsp_tm--;
                             if (!inl_dgsp_tm)
                               break;
                           } else {
                             inl_dgsp_ph--;
                           }
                           *achl_cur++ = ('0');
                           inl_precpad --;
                         }
                       } else {             /* not using digit group separation */
                         if (achl_after-achl_cur>achl_end-achl_cur)
                           {achl_after = achl_cur; break;}  /* overflow */
                         if (bol_alternate_form && (ull_arg!=0)) {  /* write hex prefix */
                           *achl_cur++ = ('0');
                           *achl_cur++ = ('X'|(chl_spec&'\040'));
                         }
                         /* padding left with zeroes to "precision"    */
                         while (inl_precpad) {
                           *achl_cur++ = ('0');
                           inl_precpad --;
                         }
                       }
                       /* postfix                                      */
                       if (inl_postfixlen) {
                         if (inl_postfixlen==2) {
                           *(achl_after-(inl_padsp+2)) = (chl_postfix);
                           *(achl_after-(inl_padsp+1)) = ('i');
                         } else {
                           *(achl_after-(inl_padsp+1)) = (chl_postfix);
                         }
                       }
                       /* padding right with spaces                    */
                       if (inl_padsp) {
                         achl0 = achl_after-1;
                         do
                           *achl0-- = (' ');
                         while (--inl_padsp);
                       }
                       if (inl_emax!=0) {  /* done if zero-"precision" zero */
                         inl_emax --;
                         inl_emax *= 4;
                         if (inl_dgsp_lc) {  /* using digit group separation */
                           while (TRUE) {
                             while (inl_dgsp_ph) {
                               *(achl_cur)++ = (achl_digits[(ull_arg>>inl_emax) & (1<<4)-1]);
                               inl_dgsp_ph--;
                               inl_emax -= 4;
                             }
                             inl_dgsp_tm--;
                             if (!inl_dgsp_tm)
                               break;       /* all digitgroups done    */
                             achl_cur += inl_dgsp_lo;  /* skip digits-separator */
                             inl_dgsp_ph = D_DIGGRPLEN-1;
                           }
                         } else {  /* not using digit group separation */
                           while(TRUE) {
                             *(achl_cur) = (achl_digits[(ull_arg>>inl_emax) & (1<<4)-1]);
                             if (inl_emax==0)
                               break;
                             (achl_cur)++;
                             inl_emax -= 4;
                           }
                         }
                       }
                       break;
                   }
                 }
                 break;
             }
           }
           achl_cur = achl_after;
           achl_format++;
           /* On Mac OS 10.6.8, printf(">%#.0X<\n", 0) results in >0<, which seems like a bug in
              the builtin function. On a SUSE machine with gcc version 4.3.2 and a debian machine
              with gcc version 4.6.3 it resulted in ><. */
           break;
         }
         default:
           break;
        }
       }
     }
   }
   *achl_cur = '\0';
 //  free(achl_arg_temp);
//#if defined HL_UNIX && !defined HL_HPUX
//   va_end( dsl_list );
//#endif
   return achl_cur - achl_target;
} /* end m_hlvsnprintf()                                               */
#undef HL_ENDIANSWAP32

/**
* write formatted output using a pointer with a list of arguments
*  @param achp_target pointer to output buffer
*  @param imp_max_len_target maximum number of characters to write,
*                                              including terminating zero
*  @param iep_cs_target charset for output (16-bit, no surrogates supported)
*  @param achp_format formatspecification, in the style of printf() etc.
*  @param dsp_list pointer to list of arguments
*  @return the number of characters written, excluding the terminating zero,
*          or -1 on unsupported encoding
*/
extern PTYPE int m_hlvsnwprintf( void *achp_target, int imp_max_len_target,
                                 enum ied_charset iep_cs_target,
                                 const char *achp_format, va_list dsp_list ) {
   HL_WCHAR       *awcl_cur;                    /* current position        */
   HL_WCHAR       *awcl_end;                    /* maximum output position */
   const char *achl_format;
//   HL_WCHAR awcl_arg[1024];                 /* string address in case of string argument */
   char chrl_tmp[256];                     /* temporary buffer for numeric->string conversion */
   HL_WCHAR wcl_arg[MAX_STR_LENGTH];
   HL_WCHAR *awcl_arg;
   struct dsd_unicode_string *adsl_arginfs;  /* contains string argument for %(ucs)s format */
   char *achl_arg_temp;
   enum ied_charset iel_cs_target;
   va_list dsl_list;
   bool bol_adjustleft;
   const char *achl_signed;
   bool bol_precision;
   bool bol_padding_zero;
   bool bol_alternate_form;
   bool bol_dot_period;
   bool bol_longlong;
   size_t ull_field_width;
   size_t ull_precision;
   size_t ull_bitwidth;
   char chl_length_modifier;
   enum ied_charset iel_cs_source;          /* format of current giving string */
   size_t ull_utftype;
   size_t ull_str_arg_l;                    /* string length           */
   char *achl_arg_u8;
   HL_WCHAR *achl_arg_u16;
   int *ainl_arg_u32;
   enum { ied_scaling_none=0, ied_scaling_1000, ied_scaling_1024 } iel_scaling;  /* k/M/G ... */
   const char *achl_dgsp;                   /* digits-separator        */
   int inl_dgsp_lb;                         /* length of digits-separator in original bytes */
   int inl_dgsp_lc;                         /* length of digits-separator in characters */

   char chl_spec = '\0';                 /* current conversion specifier character */
   int iml_counter = 0;
   int iml_arg;
   HL_WCHAR wcl_pad;
#define  HL_ENDIANSWAP_FROM_BYTE(CHP1) ((HL_WCHAR) (((HL_WCHAR)(CHP1)) << 8))

#if defined HL_UNIX && !defined HL_HPUX
   va_copy(dsl_list, dsp_list);
#else
   dsl_list = dsp_list;
#endif
   achl_format = achp_format;
   switch (iep_cs_target) {
     case ied_chs_utf_16:
       iel_cs_target = iep_cs_target;
       break;
     case ied_chs_be_utf_16:
     case ied_chs_le_utf_16:
       iel_cs_target = m_suppress_endian_info_if_native(iep_cs_target);
       break;
     default:
       return -1;
   }
     awcl_arg = wcl_arg;

#define awcl_target ((HL_WCHAR *) achp_target)

   awcl_cur = awcl_target;                  /* start here              */
   awcl_end = awcl_target + imp_max_len_target - 1;  /* maximum output before terminating NUL */
   if (!achl_format) {                      /* awcl_target can be NULL and buffer_length can be 0(ISO c99 says) */
     achl_format = "";
   }
   while ( awcl_cur < awcl_end && *achl_format) {
     if (*achl_format != '%' || (*achl_format == '%' && *(achl_format+1) == '%' )) {
       const char *achp_normal = NULL;
       if(*achl_format == '%' ){
         achp_normal =  strchr(achl_format+2, '%');
         achl_format++; /* skip '%'                */
       } else {
       achp_normal = strchr(achl_format+1, '%');
       }
       size_t ui_n = !achp_normal ? strlen(achl_format) : (achp_normal-achl_format);
       if ( iel_cs_target == ied_chs_utf_16) { /* natural endian       */
         awcl_cur += m_u16l_from_u8l(awcl_cur, 1+awcl_end-awcl_cur, (char *) achl_format, ui_n);
       } else {                             /* swapped endian          */
         awcl_cur += m_u16r_from_u8l(awcl_cur, 1+awcl_end-awcl_cur, achl_format, ui_n);
       }
       achl_format += ui_n;
     } else {
       bol_adjustleft = false;
       achl_signed = "-\0\0\0";
       bol_precision = false;
       bol_padding_zero = false;
       bol_alternate_form = false;
       bol_dot_period = false;
       bol_longlong = false;
       ull_field_width = 0;
       ull_precision = 0;
       ull_bitwidth = 0;
       chl_length_modifier = '\0';
       iel_scaling = ied_scaling_none;
       adsl_arginfs = NULL;
       achl_dgsp = NULL;
       inl_dgsp_lc = 0;
       ull_utftype = 0;
       iel_cs_source = ied_chs_ansi_819;
       achl_format++;                       /* skip '%'                */

       /* parse flags */
       while (umrs_format[(UINT) *achl_format] == 1) { /* - + 0 # \' . ( *    */
         if (isdigit((int) *achl_format)) {
           if (bol_padding_zero == false && *achl_format == '0' && !ull_field_width  ) {
             bol_padding_zero = true;
           }
           else if (ull_field_width == 0) {
             ull_field_width = *achl_format++ - '0';
           } else {
             while (isdigit((int) *achl_format)) {
               ull_field_width = 10 * ull_field_width + (unsigned int) (*achl_format++ - '0');
             }
           }
         }
         switch (*achl_format++) {
           case '-':
             bol_adjustleft = true;
             break;
           case '+':
             achl_signed = "-++";
             break;
           case '#':
             bol_alternate_form = true;
             break;
           case ' ':
             achl_signed = "-  ";
             break;
           case '\'':
             break;
           case '.':
             bol_dot_period = true;
             bol_precision = true;
             if (*achl_format == '*') {
               iml_arg = va_arg(dsl_list, int);
               if (iml_arg >= 0)
                 ull_precision = iml_arg;
               else {
                 ull_precision = 0;
                 bol_precision = false;
               }
               achl_format++;
             } else if (isdigit((int)(*achl_format))) {
               /* size_t could be wider than unsigned int;                     */
               /* make sure we treat argument like common implementations do   */
               unsigned int uml_digit;
               uml_digit = *achl_format++ - '0';
               while( isdigit((int) *achl_format) ) {
                 uml_digit = 10 * uml_digit + (unsigned int) (*achl_format++ - '0');
               }
               ull_precision =  uml_digit;
             } else {
               while( *achl_format){
                 if( *achl_format != '%' && awcl_cur < awcl_end ) {
                 *awcl_cur++ =(HL_WCHAR) *((unsigned char*)achl_format++);
                 } else {
                   break;
                 }
               }
             }
             break;
           case '(':
             switch (*achl_format) {
               case 'u':
               case 'U': {
                 achl_format++;
                 if(isdigit((int)(*achl_format))) {
                   /* size_t could be wider than unsigned int;                   */
                   /* make sure we treat argument like common implementations do */
                   unsigned int uml_utfdigit = *achl_format++ - '0';
                   while (isdigit((int)(*achl_format)))
                     uml_utfdigit = 10*uml_utfdigit + (unsigned int)(*achl_format++ - '0');
                   ull_utftype = uml_utfdigit;
                 }
                 else if ( *achl_format == 's') {
#if defined(WIN32)|| defined(WIN64)
                   ull_utftype = 16;
#elif defined(HL_UNIX)
                   ull_utftype = 32;
#endif
                   achl_format++;
                 }
                 else if ( *achl_format == 'x') {
#if defined(XCERCES32)                    /* set 32 bit unicode for Xerces   */
                   ull_utftype = 32;
#else
                   ull_utftype = 16;
#endif
                   achl_format++;
                 }
                 else if ( (*achl_format == 'c') && (*(achl_format+1) == 's') ) {
                   adsl_arginfs = va_arg(dsl_list, struct dsd_unicode_string *);
                   achl_format+=2;
                 }
                 else {
                   printf("Error: unknown conversion specification");
                 }
                 switch( ull_utftype ) {
                   case 8:
                     iel_cs_source = ied_chs_utf_8;
                     break;
                   case 16:
                     switch (*achl_format) {
                       case 'l': case 'L':
                         iel_cs_source = m_suppress_endian_info_if_native(ied_chs_le_utf_16); break;
                       case 'b': case 'B':
                         iel_cs_source = m_suppress_endian_info_if_native(ied_chs_be_utf_16); break;
                       default:
                         iel_cs_source = ied_chs_utf_16; break;
                     }
                     break;
                   case 32:
                     switch (*achl_format) {
                       case 'l': case 'L':
                         iel_cs_source = m_suppress_endian_info_if_native(ied_chs_le_utf_32); break;
                       case 'b': case 'B':
                         iel_cs_source = m_suppress_endian_info_if_native(ied_chs_be_utf_32); break;
                       default:
                         iel_cs_source = ied_chs_utf_32; break;
                     }
                     break;
                   default:
                     if( adsl_arginfs ) {
                       //iel_cs_source = adsl_arginfs->iec_chs_str;  /* correct, but not used */
                     } else {
                       iel_cs_source = ied_chs_invalid;
                     }
                     break;
                 }
               } break;
               case '.':
                 if (*(achl_format+1) == '*') {
                   achl_format+=2;
                   iel_cs_source = (enum ied_charset)va_arg(dsl_list, int);
                   switch( iel_cs_source ) {
                     case ied_chs_ascii_850:   /* ASCII 850            */
                     case ied_chs_ansi_819:    /* ANSI 819             */
                     CASE_IED_CHS_MISCCODEPAGES
                     /*? case ied_chs_html_1:   * HTML character set   */
                     CASE_IED_CHS_ALL_CJK
                     CASE_IED_CHS_ISO8859_2TO16
                       // ull_utftype = 0;
                       break;
                     case ied_chs_utf_8:        /* Unicode UTF-8           */
                       ull_utftype = 8;
                       break;
                     CASE_IED_CHS_U16_ALLENDIAN
                       ull_utftype = 16;
                       iel_cs_source = m_suppress_endian_info_if_native(iel_cs_source);
                       break;
                     CASE_IED_CHS_U32_ALLENDIAN
                       ull_utftype = 32;
                       iel_cs_source = m_suppress_endian_info_if_native(iel_cs_source);
                       break;
                     default:
                       iel_cs_source = ied_chs_invalid;
                       break;
                   }
                 }
                 break;
               case 'd':
                 if(!strncmp(achl_format+1,"ec1",3)) {
                   inl_dgsp_lc = 0;
                   achl_format += 4;
                   achl_dgsp = achl_format;
                   inl_dgsp_lb=0;           /* temporarly used for UTF8-check */
                   while (*achl_format && *achl_format!=')') {  /* UTF8-check */
                     if (*((signed char*)(achl_format)) < 0) {  /* MSB set */
                       if (((*achl_format&0x40)!=0) != (inl_dgsp_lb==0)) {
                         do ++achl_format;  /* UTF8-error              */
                           while (*achl_format && *achl_format!=')');
                         achl_dgsp=achl_format;  /* use the default    */
                         break;
                       }
                       if (inl_dgsp_lb) {   /* within sequence, 10...  */
                         inl_dgsp_lb--;
                       } else {             /* sequence start, 11...   */
                         inl_dgsp_lb = chrs_trail_u8l[(unsigned char)*achl_format];
                         inl_dgsp_lc ++;
                       }
                     } else {               /* in ASCII-range          */
                       if (inl_dgsp_lb) {   /* UTF8-error              */
                         do ++achl_format;
                           while (*achl_format && *achl_format!=')');
                         achl_dgsp=achl_format;  /* use the default    */
                         break;
                       }
                       inl_dgsp_lc ++;
                     }
                     achl_format++;
                   }
                   if (achl_format==achl_dgsp) {
                     achl_dgsp = "'";       /* default of thousands-separator */
                     inl_dgsp_lc = 1;       /* length 1 char           */
                     inl_dgsp_lb = 1;       /* length 1 Byte in UTF8   */
                   } else {
                     inl_dgsp_lb = achl_format-achl_dgsp;  /* length in Byte */
                   }
                 }
                 break;
               case 's':
                 if(!strncmp(achl_format+1,"ci-d",4)) {
                   if(!strncmp(achl_format+5,"ata",3)) {
                     iel_scaling = ied_scaling_1024;
                     achl_format += 8;
                   } else if(!strncmp(achl_format+5,"ec",2)) {
                     iel_scaling = ied_scaling_1000;
                     achl_format += 7;
                   }
                 }
                 break;
               default:
                 break;
             }
             while (*achl_format) {
               if (*achl_format==')') {
                 achl_format++;             /* skip ')'                */
                 break;                     /* regular loop exit       */
               }
               achl_format++;
             }
             break;                         /* end of case '('         */
           case '*':                        /* field width by argument */
             if (!bol_dot_period) {
               iml_arg = va_arg(dsl_list, int);
               if (iml_arg >= 0)
                 ull_field_width = iml_arg;
               else {
                 ull_field_width = -iml_arg;
                 bol_adjustleft = true;
               }
             }
             break;
           default:
             achl_format--;
             break;
         }
       }

      /*parse field width */
       if( *achl_format == '*') {
         iml_arg = va_arg(dsl_list, int);
         if( iml_arg >= 0)
           ull_field_width = iml_arg;
         else {
           ull_field_width = -iml_arg;
           bol_adjustleft = true;
         }
         achl_format++;
       }

       /* parse 'h', 'l', 'L' and 'I'<number> length modifier */
       if( umrs_format[(UINT) *achl_format] == 2 ) { /* h l L I */
         if (*achl_format == 'I')
         {
           ++achl_format;
           while (isdigit((int) *achl_format)) {
             ull_bitwidth = 10 * ull_bitwidth + (unsigned int) (*achl_format++ - '0');
           }
           if (ull_bitwidth == sizeof(long long int)<<3) {
             chl_length_modifier = 'L';
             bol_longlong = true;
           } else if (ull_bitwidth == sizeof(long int)<<3) {
             chl_length_modifier = 'l';
           } else if (ull_bitwidth == sizeof(int)<<3) {
             chl_length_modifier = '\0';
           } else if (ull_bitwidth == sizeof(short)<<3) {
             chl_length_modifier = 'h';
           } else {
             printf("Error: unsupported 'I' width specification %d", (int)ull_bitwidth);
           }
         }
         else
         {
           chl_length_modifier = *achl_format;
           if(((*achl_format == 'l') || (*achl_format == 'L'))
             && ((*(achl_format+1) == 'l') ||(*(achl_format+1) == 'L'))){
             bol_longlong = true;
             achl_format++;
           }
           achl_format++;
         }
       }

       if(*achl_format != '%'){
        chl_spec = *achl_format;

        /* get parameter value, do initial processing */
        switch ( umrs_format[(UINT) chl_spec]){
         case 3: {                          /* %  c   s                */
           unsigned int u_tmp;
           chl_length_modifier = '\0';
           /*bol_padding_zero = false;       * turn zero padding off for string conversions */
           ull_str_arg_l = 1;

           switch(chl_spec){
             case '%':
               if (iel_cs_target==ied_chs_utf_16)
                 *awcl_arg = (const HL_WCHAR) *achl_format;
               else
                 *awcl_arg = (const HL_WCHAR) *achl_format << 8;
               break;
             case 'c': case 'C':
               if (ull_utftype == 8) {
        //         free(awcl_arg);
                 return -1;
               }
               else if(adsl_arginfs!=NULL) {
                 printf("Error: (ucs) with other type than s not yet implemented");
                 ull_str_arg_l -= (ull_str_arg_l+1); /* "negative", as error condition */
                 break;
               }
               else  if (ull_utftype == 16) {
                 u_tmp = va_arg(dsl_list, unsigned int);
                 if (iel_cs_source != iel_cs_target)
                   u_tmp = ((u_tmp>>8) | (u_tmp<<8)) & 0xFFFF; /* endian */
                 *awcl_arg = (HL_WCHAR) u_tmp;
               }
               else if(ull_utftype == 32) {
                 u_tmp = va_arg(dsl_list, unsigned int);
                 if (iel_cs_source == ied_chs_utf_32) { /* endian checks */
                   if (u_tmp & 0xFFFF0000)
                     u_tmp = UTF16_REP_CHAR; /* out of 16-bit range      */
                   if (iel_cs_target != ied_chs_utf_16)
                     u_tmp = ((u_tmp&0x0000FF00)>>8) | (u_tmp<<8);
                 } else {
                   if (u_tmp & 0x0000FFFF) { /* out of 16-bit range      */
                     if (iel_cs_target == ied_chs_utf_16)
                       u_tmp = UTF16_REP_CHAR;
                     else
                       u_tmp = 0x0000FFFF & ((UTF16_REP_CHAR<<8) | ((unsigned)UTF16_REP_CHAR>>8));
                   } else {
                     if (iel_cs_target == ied_chs_utf_16)
                       u_tmp = (u_tmp>>24) | ((u_tmp&0x00FF0000)>>8);
                     else
                       u_tmp = u_tmp >> 16;
                   }
                 }
                 *awcl_arg = (HL_WCHAR) u_tmp;
               }
               else {
                 u_tmp = va_arg(dsl_list, unsigned int);
                 if ((signed int)u_tmp<0) {  /* topmost bit set        */
                   if (~u_tmp<0x100) {  /* assume char literal type problem */
                     u_tmp += 0x100;         /* wrapping to positive   */
                   } else {             /* out of range (no utf8 here) */
                     *awcl_arg = UTF16_REP_CHAR;
                     break;
                   }
                 }
                 switch (iel_cs_source) {
                   case ied_chs_oem_437:
                     u_tmp = usrg_tab_437_to_uni[u_tmp];
                     if (iel_cs_target != ied_chs_utf_16)
                       u_tmp = (u_tmp>>8) | ((u_tmp&0xFF)<<8);  /* switch endianness */
                     break;
                   case ied_chs_wcp_874:
                     u_tmp = usrg_tab_874_to_uni[u_tmp];
                     if (iel_cs_target != ied_chs_utf_16)
                       u_tmp = (u_tmp>>8) | ((u_tmp&0xFF)<<8);  /* switch endianness */
                     break;
                   case ied_chs_wcp_1250:
                     u_tmp = usrg_tab_1250_to_uni[u_tmp];
                     if (iel_cs_target != ied_chs_utf_16)
                       u_tmp = (u_tmp>>8) | ((u_tmp&0xFF)<<8);  /* switch endianness */
                     break;
                   case ied_chs_wcp_1251:
                     u_tmp = usrg_tab_1251_to_uni[u_tmp];
                     if (iel_cs_target != ied_chs_utf_16)
                       u_tmp = (u_tmp>>8) | ((u_tmp&0xFF)<<8);  /* switch endianness */
                     break;
                   case ied_chs_wcp_1252:
                     u_tmp = usrg_tab_1252_to_uni[u_tmp];
                     if (iel_cs_target != ied_chs_utf_16)
                       u_tmp = (u_tmp>>8) | ((u_tmp&0xFF)<<8);  /* switch endianness */
                     break;
                   case ied_chs_wcp_1253:
                     u_tmp = usrg_tab_1253_to_uni[u_tmp];
                     if (iel_cs_target != ied_chs_utf_16)
                       u_tmp = (u_tmp>>8) | ((u_tmp&0xFF)<<8);  /* switch endianness */
                     break;
                   case ied_chs_wcp_1254:
                     u_tmp = usrg_tab_1254_to_uni[u_tmp];
                     if (iel_cs_target != ied_chs_utf_16)
                       u_tmp = (u_tmp>>8) | ((u_tmp&0xFF)<<8);  /* switch endianness */
                     break;
                   case ied_chs_wcp_1255:
                     u_tmp = usrg_tab_1255_to_uni[u_tmp];
                     if (iel_cs_target != ied_chs_utf_16)
                       u_tmp = (u_tmp>>8) | ((u_tmp&0xFF)<<8);  /* switch endianness */
                     break;
                   case ied_chs_wcp_1256:
                     u_tmp = usrg_tab_1256_to_uni[u_tmp];
                     if (iel_cs_target != ied_chs_utf_16)
                       u_tmp = (u_tmp>>8) | ((u_tmp&0xFF)<<8);  /* switch endianness */
                     break;
                   case ied_chs_wcp_1257:
                     u_tmp = usrg_tab_1257_to_uni[u_tmp];
                     if (iel_cs_target != ied_chs_utf_16)
                       u_tmp = (u_tmp>>8) | ((u_tmp&0xFF)<<8);  /* switch endianness */
                     break;
                   case ied_chs_wcp_1258:
                     u_tmp = usrg_tab_1258_to_uni[u_tmp];
                     if (iel_cs_target != ied_chs_utf_16)
                       u_tmp = (u_tmp>>8) | ((u_tmp&0xFF)<<8);  /* switch endianness */
                     break;
                   case ied_chs_iso8859_2:
                     u_tmp = usrg_tab_i02_to_uni[u_tmp];
                     if (iel_cs_target != ied_chs_utf_16)
                       u_tmp = (u_tmp>>8) | ((u_tmp&0xFF)<<8);  /* switch endianness */
                     break;
                   case ied_chs_iso8859_3:
                     u_tmp = usrg_tab_i03_to_uni[u_tmp];
                     if (iel_cs_target != ied_chs_utf_16)
                       u_tmp = (u_tmp>>8) | ((u_tmp&0xFF)<<8);  /* switch endianness */
                     break;
                   case ied_chs_iso8859_4:
                     u_tmp = usrg_tab_i04_to_uni[u_tmp];
                     if (iel_cs_target != ied_chs_utf_16)
                       u_tmp = (u_tmp>>8) | ((u_tmp&0xFF)<<8);  /* switch endianness */
                     break;
                   case ied_chs_iso8859_5:
                     u_tmp = usrg_tab_i05_to_uni[u_tmp];
                     if (iel_cs_target != ied_chs_utf_16)
                       u_tmp = (u_tmp>>8) | ((u_tmp&0xFF)<<8);  /* switch endianness */
                     break;
                   case ied_chs_iso8859_6:
                     u_tmp = usrg_tab_i06_to_uni[u_tmp];
                     if (iel_cs_target != ied_chs_utf_16)
                       u_tmp = (u_tmp>>8) | ((u_tmp&0xFF)<<8);  /* switch endianness */
                     break;
                   case ied_chs_iso8859_7:
                     u_tmp = usrg_tab_i07_to_uni[u_tmp];
                     if (iel_cs_target != ied_chs_utf_16)
                       u_tmp = (u_tmp>>8) | ((u_tmp&0xFF)<<8);  /* switch endianness */
                     break;
                   case ied_chs_iso8859_8:
                     u_tmp = usrg_tab_i08_to_uni[u_tmp];
                     if (iel_cs_target != ied_chs_utf_16)
                       u_tmp = (u_tmp>>8) | ((u_tmp&0xFF)<<8);  /* switch endianness */
                     break;
                   case ied_chs_iso8859_9:
                     u_tmp = usrg_tab_i09_to_uni[u_tmp];
                     if (iel_cs_target != ied_chs_utf_16)
                       u_tmp = (u_tmp>>8) | ((u_tmp&0xFF)<<8);  /* switch endianness */
                     break;
                   case ied_chs_iso8859_10:
                     u_tmp = usrg_tab_i10_to_uni[u_tmp];
                     if (iel_cs_target != ied_chs_utf_16)
                       u_tmp = (u_tmp>>8) | ((u_tmp&0xFF)<<8);  /* switch endianness */
                     break;
                   case ied_chs_iso8859_11:
                     u_tmp = usrg_tab_i11_to_uni[u_tmp];
                     if (iel_cs_target != ied_chs_utf_16)
                       u_tmp = (u_tmp>>8) | ((u_tmp&0xFF)<<8);  /* switch endianness */
                     break;
                   case ied_chs_iso8859_13:
                     u_tmp = usrg_tab_i13_to_uni[u_tmp];
                     if (iel_cs_target != ied_chs_utf_16)
                       u_tmp = (u_tmp>>8) | ((u_tmp&0xFF)<<8);  /* switch endianness */
                     break;
                   case ied_chs_iso8859_14:
                     u_tmp = usrg_tab_i14_to_uni[u_tmp];
                     if (iel_cs_target != ied_chs_utf_16)
                       u_tmp = (u_tmp>>8) | ((u_tmp&0xFF)<<8);  /* switch endianness */
                     break;
                   case ied_chs_iso8859_15:
                     u_tmp = usrg_tab_i15_to_uni[u_tmp];
                     if (iel_cs_target != ied_chs_utf_16)
                       u_tmp = (u_tmp>>8) | ((u_tmp&0xFF)<<8);  /* switch endianness */
                     break;
                   case ied_chs_iso8859_16:
                     u_tmp = usrg_tab_i16_to_uni[u_tmp];
                     if (iel_cs_target != ied_chs_utf_16)
                       u_tmp = (u_tmp>>8) | ((u_tmp&0xFF)<<8);  /* switch endianness */
                     break;
                   CASE_IED_CHS_ALL_CJK {
                     if (u_tmp > 0xFF) {    /* two-byte code           */
                       if (u_tmp > 0xFFFF)
                         u_tmp = UTF16_REP_CHAR;  /* argument too big  */
                       else
                         u_tmp = m_get_tab_mb_to_uni(iel_cs_source)[u_tmp];
                     } else {               /* one-byte code           */
                       u_tmp = m_get_tab_mb_firstbytes(iel_cs_source)[u_tmp];
                       if (u_tmp == 0xFFFF)
                         u_tmp = UTF16_REP_CHAR;  /* got only a leadbyte */
                     }
                     if (iel_cs_target != ied_chs_utf_16)
                       u_tmp = (u_tmp>>8) | ((u_tmp&0xFF)<<8);  /* switch endianness */
                   } break;
                   case ied_chs_ascii_850:
                     u_tmp = ucrg_tab_850_to_819[u_tmp];
                     /* fall through */
                   default:
                     if (iel_cs_target != ied_chs_utf_16)
                       u_tmp <<= 8;              /* switch endianness        */
                     break;
                 }
                 *awcl_arg = (HL_WCHAR) u_tmp;
               }
               break;
             case 's':
               if (ull_utftype == 8){        /* UTF8-String type         */
                 achl_arg_u8 = va_arg(dsl_list, char *);
#ifdef TRACEHL1
#if _RWDEBUG
                 printf("UTF8 string to converting: %s\n", achl_arg_u8);
#endif
#endif
                 if(ull_precision > 0 ){
                   if (iel_cs_target==ied_chs_utf_16)
                     m_u16l_from_u8l(awcl_arg, ull_precision, (char *) achl_arg_u8, MAX_STR_LENGTH);
                   else
                     m_u16r_from_u8l(awcl_arg, ull_precision+1, (char *) achl_arg_u8, MAX_STR_LENGTH);
                   iml_counter = ull_precision;
                   *(awcl_arg+iml_counter) = '\0';
                 } else {
                   if (iel_cs_target==ied_chs_utf_16)
                     iml_counter = m_u16l_from_u8l(awcl_arg, MAX_STR_LENGTH, (char *) achl_arg_u8, strlen((char *) achl_arg_u8));
                   else
                     iml_counter = m_u16r_from_u8l(awcl_arg, MAX_STR_LENGTH, (char *) achl_arg_u8, strlen((char *) achl_arg_u8));
                 }

#ifdef TRACEHL1
#if _RWDEBUG
                 wprintf(L"UTF8 string after converting: %s\n", awcl_arg);
#endif
#endif
               }
               else if (ull_utftype == 16){
                 achl_arg_u16 = (HL_WCHAR *) va_arg(dsl_list, HL_WCHAR *);
                 if(ull_precision > 0 ){     /* length given             */
                   if (iel_cs_source != iel_cs_target)
                   {                         /* switch endianness        */
                     for(iml_counter = 0; iml_counter < (signed int)ull_precision ; iml_counter++)
                     {
                       *(awcl_arg+iml_counter) = ((*achl_arg_u16) << 8) | ((unsigned short)(*achl_arg_u16) >> 8);
                       achl_arg_u16++;
                     }
                   } else {                  /* keep endianness          */
                     for(iml_counter = 0; iml_counter < (signed int)ull_precision ; iml_counter++)
                     {
                       *(awcl_arg+iml_counter) = *(achl_arg_u16++);
                     }
                   }
                 }
                 else{                       /* zero-terminated          */
                   if (iel_cs_source != iel_cs_target)
                   {                         /* switch endianness        */
                     for(iml_counter = 0; *achl_arg_u16 != '\0'; iml_counter++) {
                       *(awcl_arg+iml_counter) = ((*achl_arg_u16) << 8) | ((unsigned short)(*achl_arg_u16) >> 8);
                       achl_arg_u16++;
                     }
                   } else {                  /* keep endianness          */
                     for(iml_counter = 0; *achl_arg_u16 != '\0'; iml_counter++) {
                       *(awcl_arg+iml_counter) = *(achl_arg_u16++);
                     }
                   }
                 }
                 *(awcl_arg+iml_counter) = '\0';
#ifdef TRACEHL1
#ifdef _RWDEBUG
                 wprintf(L"HL_WCHAR string after converting: %s\n", awcl_arg);
#endif
#endif
               }
               else if(ull_utftype == 32){
                 ainl_arg_u32 = (int *) va_arg(dsl_list, int *);
/* macros for loops that switch or keep native and reversed endiannesses */
#define HL_32TO16_LOOP_LENGTH for(iml_counter = 0 ; iml_counter < (signed int)ull_precision ; iml_counter++, ainl_arg_u32++)
#define HL_32TO16_LOOP_ZERO for(iml_counter = 0; *ainl_arg_u32 != '\0'; iml_counter++,ainl_arg_u32++)
#define HL_32TO16_DO_NTON { *(awcl_arg+iml_counter) = ( (*ainl_arg_u32 & 0xFFFF0000) \
    ? UTF16_REP_CHAR \
    : (HL_WCHAR) *ainl_arg_u32 ); }
#define HL_32TO16_DO_NTOR { *(awcl_arg+iml_counter) = ( (*ainl_arg_u32 & 0xFFFF0000) \
    ? UTF16_REP_CHAR << 8 | UTF16_REP_CHAR >> 8 \
    : (HL_WCHAR) ((((*ainl_arg_u32)&0x0000FF00)>>8) | ((*ainl_arg_u32) << 8)) ); }
#define HL_32TO16_DO_RTON { *(awcl_arg+iml_counter) = ( (*ainl_arg_u32 & 0x0000FFFF) \
    ? UTF16_REP_CHAR \
    : (HL_WCHAR) (((unsigned)(*ainl_arg_u32)>>24) | (((*ainl_arg_u32)&0x00FF0000) >> 8)) ); }
#define HL_32TO16_DO_RTOR { *(awcl_arg+iml_counter) = ( (*ainl_arg_u32 & 0x0000FFFF) \
    ? UTF16_REP_CHAR << 8 | UTF16_REP_CHAR >> 8 \
    : (HL_WCHAR) ((unsigned)(*ainl_arg_u32)>>16) ); }
                 if(ull_precision > 0 ){     /* length given             */
                   if (iel_cs_source==ied_chs_utf_32) { /* endian checks */
                     if (iel_cs_target==ied_chs_utf_16) {
                       HL_32TO16_LOOP_LENGTH
                         HL_32TO16_DO_NTON
                     } else {
                       HL_32TO16_LOOP_LENGTH
                         HL_32TO16_DO_NTOR
                     }
                   } else {
                     if (iel_cs_target==ied_chs_utf_16) {
                       HL_32TO16_LOOP_LENGTH
                         HL_32TO16_DO_RTON
                     } else {
                       HL_32TO16_LOOP_LENGTH
                         HL_32TO16_DO_RTOR
                     }
                   }
                 }
                 else{                       /* zero-terminated          */
                   if (iel_cs_source==ied_chs_utf_32) { /* endian checks */
                     if (iel_cs_target==ied_chs_utf_16) {
                       HL_32TO16_LOOP_ZERO
                         HL_32TO16_DO_NTON
                     } else {
                       HL_32TO16_LOOP_ZERO
                         HL_32TO16_DO_NTOR
                     }
                   } else {
                     if (iel_cs_target==ied_chs_utf_16) {
                       HL_32TO16_LOOP_ZERO
                         HL_32TO16_DO_RTON
                     } else {
                       HL_32TO16_LOOP_ZERO
                         HL_32TO16_DO_RTOR
                     }
                   }
                 }
                 *(awcl_arg+iml_counter) = '\0';
#undef HL_32TO16_LOOP_LENGTH
#undef HL_32TO16_LOOP_ZERO
#undef HL_32TO16_DO_NTON
#undef HL_32TO16_DO_NTOR
#undef HL_32TO16_DO_RTON
#undef HL_32TO16_DO_RTOR
#ifdef TRACEHL1
#if _RWDEBUG
                 wprintf(L"UTF32 string after converting: %s\n", awcl_arg);
#endif
#endif
               }
               else if(adsl_arginfs == NULL) {  /* the "else" is of ull_utftype check, it should be 0 here */
                 unsigned short* ausl_tt;   /* translation table       */
                 unsigned short* ausl_fbtt; /* first-byte trans. table */
                 achl_arg_temp = va_arg(dsl_list, char *);
                 if(iel_cs_target!=ied_chs_utf_16){
                   switch(iel_cs_source){
                     case ied_chs_ascii_850:
                       if(ull_precision > 0) {
                         for(iml_counter = 0; (ull_precision != (size_t)iml_counter) && (*achl_arg_temp != '\0'); iml_counter++ )
                           *(awcl_arg+iml_counter) = HL_ENDIANSWAP_FROM_BYTE(ucrg_tab_850_to_819[*(unsigned char*)achl_arg_temp++]);
                       } else {
                         for(iml_counter = 0; *achl_arg_temp != '\0'; iml_counter++ )
                           *(awcl_arg+iml_counter) = HL_ENDIANSWAP_FROM_BYTE(ucrg_tab_850_to_819[*(unsigned char*)achl_arg_temp++]);
                       }
                       break;
                     do {  /* variant of Duffs device, the "break" go to the end of this pseudoloop */
                     case ied_chs_oem_437:
                       ausl_tt = usrg_tab_437_to_uni; break;
                     case ied_chs_wcp_874:
                       ausl_tt = usrg_tab_874_to_uni; break;
                     case ied_chs_wcp_1250:
                       ausl_tt = usrg_tab_1250_to_uni; break;
                     case ied_chs_wcp_1251:
                       ausl_tt = usrg_tab_1251_to_uni; break;
                     case ied_chs_wcp_1252:
                       ausl_tt = usrg_tab_1252_to_uni; break;
                     case ied_chs_wcp_1253:
                       ausl_tt = usrg_tab_1253_to_uni; break;
                     case ied_chs_wcp_1254:
                       ausl_tt = usrg_tab_1254_to_uni; break;
                     case ied_chs_wcp_1255:
                       ausl_tt = usrg_tab_1255_to_uni; break;
                     case ied_chs_wcp_1256:
                       ausl_tt = usrg_tab_1256_to_uni; break;
                     case ied_chs_wcp_1257:
                       ausl_tt = usrg_tab_1257_to_uni; break;
                     case ied_chs_wcp_1258:
                       ausl_tt = usrg_tab_1258_to_uni; break;
                     case ied_chs_iso8859_2:
                       ausl_tt = usrg_tab_i02_to_uni; break;
                     case ied_chs_iso8859_3:
                       ausl_tt = usrg_tab_i03_to_uni; break;
                     case ied_chs_iso8859_4:
                       ausl_tt = usrg_tab_i04_to_uni; break;
                     case ied_chs_iso8859_5:
                       ausl_tt = usrg_tab_i05_to_uni; break;
                     case ied_chs_iso8859_6:
                       ausl_tt = usrg_tab_i06_to_uni; break;
                     case ied_chs_iso8859_7:
                       ausl_tt = usrg_tab_i07_to_uni; break;
                     case ied_chs_iso8859_8:
                       ausl_tt = usrg_tab_i08_to_uni; break;
                     case ied_chs_iso8859_9:
                       ausl_tt = usrg_tab_i09_to_uni; break;
                     case ied_chs_iso8859_10:
                       ausl_tt = usrg_tab_i10_to_uni; break;
                     case ied_chs_iso8859_11:
                       ausl_tt = usrg_tab_i11_to_uni; break;
                     case ied_chs_iso8859_13:
                       ausl_tt = usrg_tab_i13_to_uni; break;
                     case ied_chs_iso8859_14:
                       ausl_tt = usrg_tab_i14_to_uni; break;
                     case ied_chs_iso8859_15:
                       ausl_tt = usrg_tab_i15_to_uni; break;
                     case ied_chs_iso8859_16:
                       ausl_tt = usrg_tab_i16_to_uni; break;
                     } while (FALSE);       /* end of the pseudoloop   */
                       if(ull_precision > 0) {
                         for(iml_counter = 0; (ull_precision != (size_t)iml_counter) && (*achl_arg_temp != '\0'); iml_counter++ ) {
                           u_tmp = (ausl_tt[*(unsigned char*)achl_arg_temp++]);
                           *(awcl_arg+iml_counter) = (((u_tmp<<8)&0xFFFF) | (u_tmp>>8));
                         }
                       } else {
                         for(iml_counter = 0; *achl_arg_temp != '\0'; iml_counter++ ) {
                           u_tmp = (ausl_tt[*(unsigned char*)achl_arg_temp++]);
                           *(awcl_arg+iml_counter) = (((u_tmp<<8)&0xFFFF) | (u_tmp>>8));
                         }
                       }
                       break;
                     CASE_IED_CHS_ALL_CJK
                       ausl_fbtt = m_get_tab_mb_firstbytes(iel_cs_source);
                       ausl_tt = m_get_tab_mb_to_uni(iel_cs_source);
                       if(ull_precision > 0) {
                         for(iml_counter = 0; (ull_precision != (size_t)iml_counter) && (*achl_arg_temp != '\0'); iml_counter++ ) {
                           u_tmp = ausl_fbtt[*(unsigned char*)achl_arg_temp];
                           if (u_tmp==0xFFFF) {  /* two-byte code      */
                             u_tmp = ausl_tt[*(unsigned char*)achl_arg_temp<<8 | ((unsigned char*)achl_arg_temp)[1]];
                             achl_arg_temp+=2;
                           } else {         /* one-byte code           */
                             achl_arg_temp++;
                           }
                           *(awcl_arg+iml_counter) = (((u_tmp<<8)&0xFFFF) | (u_tmp>>8));
                         }
                       } else {
                         for(iml_counter = 0; *achl_arg_temp != '\0'; iml_counter++ ) {
                           u_tmp = ausl_fbtt[*(unsigned char*)achl_arg_temp];
                           if (u_tmp==0xFFFF) {  /* two-byte code      */
                             u_tmp = ausl_tt[*(unsigned char*)achl_arg_temp<<8 | ((unsigned char*)achl_arg_temp)[1]];
                             achl_arg_temp+=2;
                           } else {         /* one-byte code           */
                             achl_arg_temp++;
                           }
                           *(awcl_arg+iml_counter) = (((u_tmp<<8)&0xFFFF) | (u_tmp>>8));
                         }
                       }
                       break;
                     default:
                       if(ull_precision > 0) {
                         for(iml_counter = 0; (ull_precision != (size_t)iml_counter) && (*achl_arg_temp != '\0'); iml_counter++ )
                           *(awcl_arg+iml_counter) = HL_ENDIANSWAP_FROM_BYTE(*achl_arg_temp++);
                       } else {
                         for(iml_counter = 0; *achl_arg_temp != '\0'; iml_counter++ )
                           *(awcl_arg+iml_counter) = HL_ENDIANSWAP_FROM_BYTE(*achl_arg_temp++);
                       }
                   }
                 }
                 else {
                   switch(iel_cs_source){
                     case ied_chs_ascii_850:
                       if(ull_precision > 0) {
                         for(iml_counter = 0; (ull_precision != (size_t)iml_counter) && (*achl_arg_temp != '\0'); iml_counter++ )
                           *(awcl_arg+iml_counter) = (HL_WCHAR) ucrg_tab_850_to_819[*(unsigned char*)achl_arg_temp++];
                       } else {
                         for(iml_counter = 0; *achl_arg_temp != '\0'; iml_counter++ )
                           *(awcl_arg+iml_counter) = (HL_WCHAR) ucrg_tab_850_to_819[*(unsigned char*)achl_arg_temp++];
                       }
                       break;
                     do {  /* variant of Duffs device, the "break" go to the end of this pseudoloop */
                     case ied_chs_oem_437:
                       ausl_tt = usrg_tab_437_to_uni; break;
                     case ied_chs_wcp_874:
                       ausl_tt = usrg_tab_874_to_uni; break;
                     case ied_chs_wcp_1250:
                       ausl_tt = usrg_tab_1250_to_uni; break;
                     case ied_chs_wcp_1251:
                       ausl_tt = usrg_tab_1251_to_uni; break;
                     case ied_chs_wcp_1252:
                       ausl_tt = usrg_tab_1252_to_uni; break;
                     case ied_chs_wcp_1253:
                       ausl_tt = usrg_tab_1253_to_uni; break;
                     case ied_chs_wcp_1254:
                       ausl_tt = usrg_tab_1254_to_uni; break;
                     case ied_chs_wcp_1255:
                       ausl_tt = usrg_tab_1255_to_uni; break;
                     case ied_chs_wcp_1256:
                       ausl_tt = usrg_tab_1256_to_uni; break;
                     case ied_chs_wcp_1257:
                       ausl_tt = usrg_tab_1257_to_uni; break;
                     case ied_chs_wcp_1258:
                       ausl_tt = usrg_tab_1258_to_uni; break;
                     case ied_chs_iso8859_2:
                       ausl_tt = usrg_tab_i02_to_uni; break;
                     case ied_chs_iso8859_3:
                       ausl_tt = usrg_tab_i03_to_uni; break;
                     case ied_chs_iso8859_4:
                       ausl_tt = usrg_tab_i04_to_uni; break;
                     case ied_chs_iso8859_5:
                       ausl_tt = usrg_tab_i05_to_uni; break;
                     case ied_chs_iso8859_6:
                       ausl_tt = usrg_tab_i06_to_uni; break;
                     case ied_chs_iso8859_7:
                       ausl_tt = usrg_tab_i07_to_uni; break;
                     case ied_chs_iso8859_8:
                       ausl_tt = usrg_tab_i08_to_uni; break;
                     case ied_chs_iso8859_9:
                       ausl_tt = usrg_tab_i09_to_uni; break;
                     case ied_chs_iso8859_10:
                       ausl_tt = usrg_tab_i10_to_uni; break;
                     case ied_chs_iso8859_11:
                       ausl_tt = usrg_tab_i11_to_uni; break;
                     case ied_chs_iso8859_13:
                       ausl_tt = usrg_tab_i13_to_uni; break;
                     case ied_chs_iso8859_14:
                       ausl_tt = usrg_tab_i14_to_uni; break;
                     case ied_chs_iso8859_15:
                       ausl_tt = usrg_tab_i15_to_uni; break;
                     case ied_chs_iso8859_16:
                       ausl_tt = usrg_tab_i16_to_uni; break;
                     } while (FALSE);       /* end of the pseudoloop   */
                       if(ull_precision > 0) {
                         for(iml_counter = 0; (ull_precision != (size_t)iml_counter) && (*achl_arg_temp != '\0'); iml_counter++ )
                           *(awcl_arg+iml_counter) = (HL_WCHAR) ausl_tt[*(unsigned char*)achl_arg_temp++];
                       } else {
                         for(iml_counter = 0; *achl_arg_temp != '\0'; iml_counter++ )
                           *(awcl_arg+iml_counter) = (HL_WCHAR) ausl_tt[*(unsigned char*)achl_arg_temp++];
                       }
                       break;
                     CASE_IED_CHS_ALL_CJK
                       ausl_fbtt = m_get_tab_mb_firstbytes(iel_cs_source);
                       ausl_tt = m_get_tab_mb_to_uni(iel_cs_source);
                       if(ull_precision > 0) {
                         for(iml_counter = 0; (ull_precision != (size_t)iml_counter) && (*achl_arg_temp != '\0'); iml_counter++ ) {
                           u_tmp = ausl_fbtt[*(unsigned char*)achl_arg_temp];
                           if (u_tmp==0xFFFF) {  /* two-byte code      */
                             *(awcl_arg+iml_counter) = (HL_WCHAR) (ausl_tt[*(unsigned char*)achl_arg_temp<<8 | ((unsigned char*)achl_arg_temp)[1]]);
                             achl_arg_temp+=2;
                           } else {         /* one-byte code           */
                             *(awcl_arg+iml_counter) = (HL_WCHAR) u_tmp;
                             achl_arg_temp++;
                           }
                         }
                       } else {
                         for(iml_counter = 0; *achl_arg_temp != '\0'; iml_counter++ ) {
                           u_tmp = ausl_fbtt[*(unsigned char*)achl_arg_temp];
                           if (u_tmp==0xFFFF) {  /* two-byte code      */
                             *(awcl_arg+iml_counter) = (HL_WCHAR) (ausl_tt[*(unsigned char*)achl_arg_temp<<8 | ((unsigned char*)achl_arg_temp)[1]]);
                             achl_arg_temp+=2;
                           } else {         /* one-byte code           */
                             *(awcl_arg+iml_counter) = (HL_WCHAR) u_tmp;
                             achl_arg_temp++;
                           }
                         }
                       }
                       break;
                     default:
                       if(ull_precision > 0) {
                         for(iml_counter = 0; (ull_precision != (size_t)iml_counter) && (*achl_arg_temp != '\0'); iml_counter++ )
                           *(awcl_arg+iml_counter) = (HL_WCHAR) *((unsigned char*)achl_arg_temp++);
                       } else {
                         for(iml_counter = 0; *achl_arg_temp != '\0'; iml_counter++ )
                           *(awcl_arg+iml_counter) = (HL_WCHAR) *((unsigned char*)achl_arg_temp++);
                       }
                   }
                 }
             //    *(awcl_arg+iml_counter) = '\0';
               }
               else {  /* adsl_arginfs is set, (ucs) format with struct */
                 iml_counter = m_cpy_vx_ucs( awcl_arg,
                                             MAX_STR_LENGTH,
                                             iel_cs_target,
                                             adsl_arginfs );
                 if (bol_precision && (ull_precision<iml_counter))
                   iml_counter = ull_precision;  /* UUU it would be better to limit the copying instead of cutting the superfluous data off here afterwards (trying to use the second argument of m_cpy_vx_usc for this triggers a return(-1)-error) */
               }
               if (!awcl_arg) {
                 ull_str_arg_l = 0;
               }
               else if(!bol_precision || bol_dot_period == false ){
                 ull_str_arg_l = iml_counter;
                // ull_str_arg_l = wcslen((wchar_t *)awcl_arg);
               }
               else if (ull_precision == 0) {
                 ull_str_arg_l = 0;
               }
               else {
                 //const HL_WCHAR *awcl_tmp = (const HL_WCHAR *) wmemchr((wchar_t *)awcl_arg, L'\0',
                 //ull_precision <= 0x7fffffff ? ull_precision : 0x7fffffff);
                 //ull_str_arg_l = !awcl_tmp ? ull_precision : (awcl_tmp-awcl_arg);
                 ull_str_arg_l = iml_counter;
               }
#ifdef TRACEHL1
#if _RWDEBUG
               if( ull_utftype) {
                 printf("converted string length: %d\n", ull_str_arg_l );
               }
#endif
#endif
               break;
             default:
               break;
           }
           achl_format++;
           if ((signed)ull_str_arg_l < 0)           /* error                   */
             break;
           HL_WCHAR* awcl_pad_end = NULL;   /* end of right-padding    */
           if (ull_field_width > ull_str_arg_l) {
             if (awcl_cur + ull_field_width > awcl_end) {
               if (bol_adjustleft) {
                 if (awcl_cur + ull_str_arg_l > awcl_end) {
                   iml_counter = 0;
                   ull_str_arg_l = awcl_end - awcl_cur;
                 } else {
                   iml_counter = (awcl_end - awcl_cur) - ull_str_arg_l;
                 }
               } else {                     /* adjust right, padd left */
                 iml_counter = (int)ull_field_width - ull_str_arg_l;
                 if (awcl_cur + iml_counter > awcl_end) {
                   ull_str_arg_l = 0;
                   iml_counter = awcl_end - awcl_cur;
                 } else {
                   ull_str_arg_l = (awcl_end - awcl_cur) - iml_counter;
                 }
               }
             } else {
               iml_counter = (int)ull_field_width - ull_str_arg_l;
             }
             if (iel_cs_target == ied_chs_utf_16)
               wcl_pad = (HL_WCHAR) ' ';
             else
               wcl_pad = HL_ENDIANSWAP_FROM_BYTE(' ');
             if (bol_adjustleft) {
               HL_WCHAR* awcl_pad_cur = awcl_cur + ull_str_arg_l;
               awcl_pad_end = awcl_pad_cur + iml_counter;
               while (awcl_pad_cur < awcl_pad_end)
                 *awcl_pad_cur++ = wcl_pad;
             } else {
               while (iml_counter--)
                 *awcl_cur++ = wcl_pad;
             }
           } else {
             if (awcl_cur + ull_str_arg_l > awcl_end)
               ull_str_arg_l = awcl_end - awcl_cur;
           }
           for(iml_counter = 0; iml_counter < (int) ull_str_arg_l; iml_counter++ ){
             *awcl_cur++ = *(awcl_arg+iml_counter);
           }
           if (awcl_pad_end != NULL)
             awcl_cur = awcl_pad_end;
           break;
         }
         case 5: case 7: {  /* p  f e E g G; use builtin sprintf */
           int         iml_arg1 = 0;
           int         inl_sign = 0;
           unsigned int uml_arg = 0;
           HL_LONGLONG  ill_arg = 0;
           HL_ULONGLONG ull_arg = 0;
           void        *avo_arg = NULL;
           double       dbl_arg = 0;
           long double  ldl_arg = 0;
           int ull_prefixlen = 0;
           if(adsl_arginfs!=NULL) {
             printf("Error: (ucs) with numeric type in format");
             break;
           }
#ifdef TRACEHL1
#if _RWDEBUG
           printf("numeric values: %c\n", *achl_format );
#endif
#endif
           ull_str_arg_l = 0;
           if(umrs_format[(UINT) chl_spec] == 7) {  /* p               */
             avo_arg = va_arg(dsl_list, void *);
             inl_sign = 2;  /* avoid the zero-suppression if precision 0 */
#ifdef HL_HPUX
             if (bol_alternate_form) {
               chrl_tmp[ull_str_arg_l++] = '0';
               chrl_tmp[ull_str_arg_l++] = 'x';
             }
#endif
           }
           else { /* signed: f  E  e  G g */
             if(chl_length_modifier == 'L'){
               ldl_arg = va_arg(dsl_list, long double);
               if (ldl_arg > 0) inl_sign = 1;
               else
#ifdef signbit
                 if(signbit(ldl_arg)) inl_sign = -1;
#else
#if defined(WIN32)|| defined(WIN64)
                 if(_copysign(1.0,(double)ldl_arg) < 0) inl_sign = -1;
#else
                 /* this fallback will not catch negative zero, so formatting that with "%04g" will print "00-0"! */
                 if(ldl_arg < 0) inl_sign = -1;
#endif
#endif
             }
             else {
               dbl_arg = va_arg(dsl_list, double);
               if (dbl_arg > 0) inl_sign = 1;
               else
#ifdef signbit
                 if(signbit(dbl_arg)) inl_sign = -1;
#else
#if defined(WIN32)|| defined(WIN64)
                 if(_copysign(1.0,dbl_arg) < 0) inl_sign = -1;
#else
                 /* this fallback will not catch negative zero, so formatting that with "%04g" will print "00-0"! */
                 if(dbl_arg < 0) inl_sign = -1;
#endif
#endif
             }
             if(achl_signed[1+inl_sign]) {
               chrl_tmp[ull_str_arg_l++] = achl_signed[1+inl_sign];
             }
           }
           /* */

           ull_prefixlen = inl_sign<0 ? ull_str_arg_l+1 : ull_str_arg_l;
           if(!bol_precision) ull_precision = 6; /* default precision UUU which is different for %g,
             but this should only have an effect with .* with negative arg, which seems to have
             always been handled not like the spec says. Why there are two bol_ flags for this? */
           if(ull_precision != 0 || inl_sign != 0 || umrs_format[(UINT) chl_spec] == 5) {
             char ach_f[10];
             int ach_f_l = 0;
             ach_f[ach_f_l++] = '%';
             if ( bol_alternate_form && (umrs_format[(UINT) chl_spec] == 5) ) {
               ach_f[ach_f_l++] = '#';
             }
             if( bol_dot_period)
             {
               ach_f[ach_f_l++] = '.';
               ach_f_l += sprintf(ach_f + ach_f_l, "%d", (int) ull_precision);
             }
             if( chl_length_modifier )
             {
               if(bol_longlong) {
#ifdef HL_UNIX
                memcpy(&ach_f[ach_f_l], "ll", 2);
                ach_f_l += 2;
#else
                memcpy(&ach_f[ach_f_l], "I64", 3);
                ach_f_l += 3;
#endif
               }
               else {
                 ach_f[ach_f_l++] = chl_length_modifier;
               }
             }
             ach_f[ach_f_l++] = chl_spec;
             if(umrs_format[(UINT) chl_spec] == 7) {  /* pointer       */
               ach_f[ach_f_l] = '\0';
               ull_str_arg_l += sprintf(chrl_tmp + ull_str_arg_l, ach_f, avo_arg);
             }
             else {                         /* float                   */
               ach_f[ach_f_l] = '\0';
               if( chl_length_modifier == 'L')
                 ull_str_arg_l += sprintf(chrl_tmp + ull_str_arg_l, ach_f, ldl_arg);
               else
                 ull_str_arg_l += sprintf(chrl_tmp + ull_str_arg_l, ach_f, dbl_arg);
             }
           }
           iml_counter = 0;
           if (iel_cs_target == ied_chs_utf_16) { /* natural endian    */
             if (bol_adjustleft == false && ull_field_width > ull_str_arg_l) {
               int n = (int)ull_field_width - ull_str_arg_l;
               if (bol_padding_zero == true) {
                 while(iml_counter < ull_prefixlen && awcl_cur < awcl_end)
                   *awcl_cur++ = (HL_WCHAR)(chrl_tmp[iml_counter++]);
                 wcl_pad = (HL_WCHAR)('0');
               } else {
                 wcl_pad = (HL_WCHAR)(' ');
               }
               while(n-- > 0 && ( awcl_cur < awcl_end) ) {
                   *awcl_cur++ = wcl_pad;
               }
             }
             achl_format++;
             for(; iml_counter < (int) ull_str_arg_l && awcl_cur < awcl_end; iml_counter++ ){
               *awcl_cur++ =(HL_WCHAR)(chrl_tmp[iml_counter]);
             }
             if( bol_adjustleft == true && ull_field_width > ull_str_arg_l) {
               iml_counter = (int)ull_field_width - ull_str_arg_l;
               wcl_pad = (HL_WCHAR)(' ');
               while(iml_counter-- > 0 && awcl_cur < awcl_end) {
                   *awcl_cur++ = wcl_pad;
               }
             }
           } else {                         /* swapped endian          */
             if (bol_adjustleft == false && ull_field_width > ull_str_arg_l) {
               int n = (int)ull_field_width - ull_str_arg_l;
               if (bol_padding_zero == true) {
                 while(iml_counter < ull_prefixlen && awcl_cur < awcl_end)
                   *awcl_cur++ = HL_ENDIANSWAP_FROM_BYTE(chrl_tmp[iml_counter++]);
                 wcl_pad = HL_ENDIANSWAP_FROM_BYTE('0');
               } else {
                 wcl_pad = HL_ENDIANSWAP_FROM_BYTE(' ');
               }
               while(n-- > 0 && ( awcl_cur < awcl_end) ) {
                   *awcl_cur++ = wcl_pad;
               }
             }
             achl_format++;
             for(; iml_counter < (int) ull_str_arg_l && awcl_cur < awcl_end; iml_counter++ ){
               *awcl_cur++ =HL_ENDIANSWAP_FROM_BYTE(chrl_tmp[iml_counter]);
             }
             if( bol_adjustleft == true && ull_field_width > ull_str_arg_l) {
               iml_counter = (int)ull_field_width - ull_str_arg_l;
               wcl_pad = HL_ENDIANSWAP_FROM_BYTE(' ');
               while(iml_counter-- > 0 && awcl_cur < awcl_end) {
                   *awcl_cur++ = wcl_pad;
               }
             }
           }
           break;
         }
         case 4: case 6: {  /* D  d  i  O  o  X  x  U  u */
           HL_WCHAR *awcl_m;                /* marker in output string */
           HL_WCHAR *awcl0;
           HL_WCHAR *awcl_dg;               /* digitgroup separator, output encoded */
           HL_WCHAR *awcl_after = awcl_cur;
           static const HL_ULONGLONG ullrs_decpowbuf[(sizeof(HL_ULONGLONG)*240824)/100000+1]
               = {1uLL, 10uLL, 100uLL, 1000uLL, 10000uLL, 100000uLL, 1000000uLL, 10000000uLL,
                  100000000uLL, 1000000000uLL, 10000000000uLL, 100000000000uLL, 1000000000000uLL,
                  10000000000000uLL, 100000000000000uLL, 1000000000000000uLL, 10000000000000000uLL,
                  100000000000000000uLL, 1000000000000000000uLL, 10000000000000000000uLL};
           static const unsigned int unrs_decpowbuf[(sizeof(unsigned int)*240824)/100000+1]
               = {1, 10, 100, 1000, 10000, 100000, 1000000, 10000000, 100000000, 1000000000};
           /* assuming int always 32-bit and long long int always 64-bit (KB to WS 29.1.2015) */
           int         iml_arg1 = 0;
           int         inl_sign = 0;
           unsigned int uml_arg = 0;
           HL_LONGLONG  ill_arg = 0;
           HL_ULONGLONG ull_arg = 0;
           void        *avo_arg = NULL;
           double       dbl_arg = 0;
           long double  ldl_arg = 0;
           int    ull_prefixlen = 0;
           int inl_s;                       /* auxiliary variable      */
           int inl_emax;  /* number of pure digits needed, exponent of most significant non-0 digit plus 1 */
           int inl_needed;  /* number of output chars, without fieldwidth-padding */
           const char *achl_digits;         /* number-to-hexchar table */
           int inl_dgsp_lo;  /* length of digits-separator in output units */
#ifdef HL_USE_DIV
           div_t dsl_diggrp_dm;
#define    inl_dgsp_ph dsl_diggrp_dm.rem    /* phase within digitgroup */
#define    inl_dgsp_tm dsl_diggrp_dm.quot
#else
           int inl_dgsp_ph;                 /* phase within digitgroup */
           int inl_dgsp_tm;                 /* digitgroup separators to come */
#endif
           int inl_precpad;
           char chl_postfix;
           int inl_postfixlen = 0;
           int inl_pfdgph = 0;
           int inl_padsp; 
           char chl_sign;
           if (iel_cs_target == ied_chs_utf_16) { /* natural endian    */
           if(adsl_arginfs!=NULL) {
             printf("Error: (ucs) with numeric type in format");
             break;
           }
#ifdef TRACEHL1
#if _RWDEBUG
           printf("numeric values: %c\n", *achl_format );
#endif
#endif
           ull_str_arg_l = 0;
           if(umrs_format[(UINT) chl_spec] == 6) { /* Signed: d D i    */
             chl_spec = 'd';
             switch(chl_length_modifier) {
               case '\0': case 'h':
                 iml_arg1 = va_arg(dsl_list, int);
                       /* determine sign and go on with non-negative X */
                       if (iml_arg1 > 0) {
                         chl_sign = achl_signed[2];
                       } else {
                         if (iml_arg1 != 0)
                         {
                           chl_sign = achl_signed[0];
                           iml_arg1=0-iml_arg1; /* replace negative X by its abs-value */
                           if ((signed int)iml_arg1<0) {  /* special case: X was the extreme negative value */
                             /*inl_emax = (((sizeof(signed int)*8-1)*30103)/100000)+1;*/
                             iml_arg1=(signed int)(-1)-iml_arg1; /* 7fff... */
                             if (iel_scaling==ied_scaling_none) {
                               chl_postfix = '1'+iml_arg1%DECBASE;  /* decimal carry cannot happen here */
                               inl_postfixlen = 1;
                               inl_pfdgph = 1;
                               ull_precision--;
                               iml_arg1/=DECBASE;
                             }
                           }
                         } else {
                           chl_sign = achl_signed[1];
                         }
                       }
                       inl_needed = chl_sign?1:0;

                       /* prepare %(sci-dec)- or %(sci-dec)-type of rendering */
                       if (iel_scaling!=ied_scaling_none) {
                         if (iel_scaling == ied_scaling_1000) {  /* power-of-1000-scaled */
#if HL_PRFMAXSO_I > 4
                           if ((sizeof(signed int) > 4) && (iml_arg1 >= D_L1000RD * unrs_decpowbuf[9])) {
#if HL_PRFMAXSO_I > 8
                             if (
                                 (sizeof(signed int) > 8) &&
                                 (iml_arg1 >= D_L1000RD * unrs_decpowbuf[15])
                                ) {
                               if (
                                   (iml_arg1 >= D_L1000RD * unrs_decpowbuf[18])
                                  ) {
                                 if (iml_arg1 >= D_L1000RD * unrs_decpowbuf[21]) {
                                   iml_arg1 =  (iml_arg1 + 500 * unrs_decpowbuf[21]) / (unrs_decpowbuf[24]);
                                   chl_postfix = 'Y';
                                 } else {
                                   iml_arg1 =  (iml_arg1 + 500 * unrs_decpowbuf[18]) / (unrs_decpowbuf[21]);
                                   chl_postfix = 'Z';
                                 }
                               } else {
                                 iml_arg1 =  (iml_arg1 + 500 * unrs_decpowbuf[15]) / (unrs_decpowbuf[18]);
                                 chl_postfix = 'E';
                               }
                             } else {
#endif
                               if (iml_arg1 >= D_L1000RD * unrs_decpowbuf[12]) {
                                 iml_arg1 =  (iml_arg1 + 500 * unrs_decpowbuf[12]) / (unrs_decpowbuf[15]);
                                 chl_postfix = 'P';
                               } else {
                                 iml_arg1 =  (iml_arg1 + 500 * unrs_decpowbuf[9]) / (unrs_decpowbuf[12]);
                                 chl_postfix = 'T';
                               }
#if HL_PRFMAXSO_I > 8
                             }
#endif
                             inl_postfixlen = 1;
                           } else {
#endif
#if HL_PRFMAXSO_I > 2
                             if ((sizeof(signed int) > 2) && (iml_arg1 >= D_L1000RD * unrs_decpowbuf[3])) {
#if HL_PRFMAXSO_I > 4
                               if ((sizeof(signed int) > 4) && (iml_arg1 >= D_L1000RD * unrs_decpowbuf[6])) {
                                 iml_arg1 =  (iml_arg1 + 500 * unrs_decpowbuf[6]) / (unrs_decpowbuf[9]);
                                 chl_postfix = 'G';
                               } else {
#endif
                                 iml_arg1 =  (iml_arg1 + 500 * unrs_decpowbuf[3]) / (unrs_decpowbuf[6]);
                                 chl_postfix = 'M';
#if HL_PRFMAXSO_I > 4
                               }
#endif
                               inl_postfixlen = 1;
                             } else {
#endif
                               if (iml_arg1 >= D_L1000RD) {
                                 iml_arg1 = (iml_arg1 + 500) / 1000;
                                 chl_postfix = 'k';
                                 inl_postfixlen = 1;
                               }
#if HL_PRFMAXSO_I > 2
                             }
#endif
#if HL_PRFMAXSO_I > 4
                           }
#endif
                         }
                         else {               /* power-of-1024-scaled    */
#if HL_PRFMAXSO_I > 4
                           if ((sizeof(signed int) > 4) && (iml_arg1>>30 >= D_L1024RD)) {
#if HL_PRFMAXSO_I > 8
                             if (
                                 (sizeof(signed int) > 8) &&
                                 (iml_arg1>>50 >= D_L1024RD)
                                ) {
                               if (
                                   (iml_arg1>>60 >= D_L1024RD)
                                  ) {
                                 if (iml_arg1>>70 >= D_L1024RD) {
                                   iml_arg1 = (iml_arg1+((signed int)1<<79)) >> 80;
                                   chl_postfix = 'Y';
                                 } else {
                                   iml_arg1 = (iml_arg1+((signed int)1<<69)) >> 70;
                                   chl_postfix = 'Z';
                                 }
                               } else {
                                 iml_arg1 = (iml_arg1+((signed int)1<<59)) >> 60;
                                 chl_postfix = 'E';
                               }
                             } else {
#endif
                               if (iml_arg1>>40 >= D_L1024RD) {
                                 iml_arg1 = (iml_arg1+((signed int)1<<49)) >> 50;
                                 chl_postfix = 'P';
                               } else {
                                 iml_arg1 = (iml_arg1+((signed int)1<<39)) >> 40;
                                 chl_postfix = 'T';
                               }
#if HL_PRFMAXSO_I > 8
                             }
#endif
                             inl_postfixlen = bol_alternate_form ? 2 : 1;
                           } else {
#endif
#if HL_PRFMAXSO_I > 2
                             if ((sizeof(signed int) > 2) && (iml_arg1>>10 >= D_L1024RD)) {
#if HL_PRFMAXSO_I > 4
                               if ((sizeof(signed int) > 4) && (iml_arg1>>20 >= D_L1024RD)) {
                                 iml_arg1 = (iml_arg1+((signed int)1<<29)) >> 30;
                                 chl_postfix = 'G';
                               } else {
#endif
                                 iml_arg1 = (iml_arg1+((signed int)1<<19)) >> 20;
                                 chl_postfix = 'M';
#if HL_PRFMAXSO_I > 4
                               }
#endif
                               inl_postfixlen = bol_alternate_form ? 2 : 1;
                             } else {
#endif
                               if (iml_arg1 >= D_L1024RD) {
                                 iml_arg1 = (iml_arg1+0x200) >> 10;
                                 chl_postfix = 'K';
                                 inl_postfixlen = bol_alternate_form ? 2 : 1;
                               }
#if HL_PRFMAXSO_I > 2
                             }
#endif
#if HL_PRFMAXSO_I > 4
                           }
#endif
                         }
                       }

                       /* detect the order of magnitude of X           */
                       inl_emax = 0;
                       if (iml_arg1) {
                         int inl_e = (((sizeof(signed int)*8-1)*30103)/100000)+1;
                         do {
                           inl_s = inl_e>>1;
                           if (iml_arg1 >= unrs_decpowbuf[inl_emax+inl_s]) {
                             inl_emax += inl_s;
                             inl_e -= inl_s;
                           } else {
                             inl_e = inl_s;
                           }
                         } while (inl_e>1);
                         inl_emax ++;
                       }
                       inl_needed += inl_emax + inl_postfixlen;
                       if (inl_dgsp_lc) {   /* use digit group separation */
                         if (inl_emax<=D_DIGGRPLEN) {  /* digit grouping not in effect */
                           inl_dgsp_lc = 0;
                         } else {
                           const int inl_emax_1 = inl_emax+inl_pfdgph-1;
#ifdef HL_USE_DIV
                           dsl_diggrp_dm = div(inl_emax_1, D_DIGGRPLEN);
                           inl_dgsp_ph++;
#else
                           inl_dgsp_tm = (inl_emax_1)/D_DIGGRPLEN;
                           inl_dgsp_ph = (inl_emax_1)%D_DIGGRPLEN+1;
#endif
                           if (inl_needed>=ull_field_width || inl_needed+inl_dgsp_tm*inl_dgsp_lc<=ull_field_width) {
                             inl_s = inl_dgsp_tm*inl_dgsp_lc;
                             inl_needed += inl_s;
                           } else {  /* prefer staying within fieldwidth over using the separator */
                             inl_dgsp_lc = 0;
                           }
                         }
                       }
                       if (!bol_precision) {
                         ull_precision = 1;  /* default precision      */
                         if (bol_padding_zero) {
                           if (ull_field_width>inl_needed && !bol_adjustleft) {
                             /* fake padding with '0' by ull_precision */
                             ull_precision = ull_field_width+(inl_dgsp_lc?inl_emax+inl_s:inl_emax)-inl_needed;
                           }
                         }
                       }
                       if (inl_dgsp_lc) {   /* using digit group separation */
                         inl_precpad = ull_precision-(inl_emax+inl_s);
                         if (inl_precpad>0) {
#ifdef HL_USE_DIV
                           div_t dsl_d = div(inl_dgsp_ph+inl_precpad, D_DIGGRPLEN+inl_dgsp_lc);
                           inl_dgsp_tm += dsl_d.quot;
                           inl_needed += inl_precpad;
                           inl_dgsp_ph = dsl_d.rem;
#else
                           inl_needed += inl_precpad;
                           inl_dgsp_tm += (inl_dgsp_ph+inl_precpad)/(D_DIGGRPLEN+inl_dgsp_lc);
                           inl_dgsp_ph = (inl_dgsp_ph+inl_precpad)%(D_DIGGRPLEN+inl_dgsp_lc);
#endif
                           if (inl_dgsp_ph>D_DIGGRPLEN) {
                             inl_needed -= inl_dgsp_ph-D_DIGGRPLEN;
                             inl_dgsp_ph = D_DIGGRPLEN;
                           }
                           inl_precpad = ull_precision-(inl_emax+inl_dgsp_tm*inl_dgsp_lc);
                         } else {
                           inl_precpad=0;
                         }
                       } else {    /* not using digit group separation */
                         inl_precpad = ull_precision-inl_emax;
                         if (inl_precpad>0) {
                           inl_needed += inl_precpad;
                         } else {
                           inl_precpad=0;
                         }
                       }
                       if (ull_field_width > inl_needed) {
                         awcl_after = awcl_cur+ull_field_width;
                         inl_padsp = ull_field_width-inl_needed;
                         if (!bol_adjustleft) {  /* padding left with spaces */
                           if (inl_padsp > awcl_end-awcl_cur)
                             {awcl_after = awcl_cur; break;}  /* overflow */
                           do
                             *awcl_cur++ = HL_WCHAR_CAST(' ');
                           while (--inl_padsp);
                         }
                       } else {
                         awcl_after = awcl_cur+inl_needed;
                         inl_padsp = 0;
                       }
                       if (inl_dgsp_lc) {   /* set digit group separators */
                         if (chl_sign) {    /* write sign prefix       */
                           if (1 > awcl_end-awcl_cur)
                             {awcl_after = awcl_cur; break;}  /* overflow */
                           *awcl_cur++ = HL_WCHAR_CAST(chl_sign);
                         }
                         /* produce the first separator                                     */
                         awcl_dg = awcl_cur+inl_dgsp_ph;
                         if (iel_cs_target == ied_chs_utf_16) {  /* natural endian */
                           inl_dgsp_lo = m_u16l_from_u8l(awcl_dg, awcl_end-awcl_dg, achl_dgsp, inl_dgsp_lb);
                         } else {           /* swapped endian          */
                           inl_dgsp_lo = m_u16r_from_u8l(awcl_dg, 1+awcl_end-awcl_dg, achl_dgsp, inl_dgsp_lb);
                         }
                         /* now the complete physical output length can be determined      */
                         inl_s = inl_dgsp_tm*(inl_dgsp_lo-inl_dgsp_lc);  /* adjustment from logical to physical */
                         awcl_after += inl_s;
                         if (inl_dgsp_lo<0 || awcl_after-awcl_cur>awcl_end-awcl_cur)
                           {awcl_after = awcl_cur; break;}  /* overflow */
                         /* copy the other separators from the first one                   */
                         inl_s = inl_dgsp_tm-1;
                         if (inl_s) {
                           awcl0 = awcl_dg+inl_dgsp_lo;
                           do {
                             awcl0 += D_DIGGRPLEN;
                             int inl2 = 0;
                             do
                               *awcl0++ = awcl_dg[inl2++];
                             while (inl2<inl_dgsp_lo);
                           } while (--inl_s);
                         }
                         /* padding left with zeroes to "precision"                        */
                         while (inl_precpad) {
                           if (inl_dgsp_ph == 0) {  /* skip digits-separator */
                             awcl_cur += inl_dgsp_lo;
                             inl_dgsp_ph = D_DIGGRPLEN-1;
                             inl_dgsp_tm--;
                             if (!inl_dgsp_tm)
                               break;
                           } else {
                             inl_dgsp_ph--;
                           }
                           *awcl_cur++ = HL_WCHAR_CAST('0');
                           inl_precpad --;
                         }
                       } else {             /* not using digit group separation */
                         if (awcl_after-awcl_cur>awcl_end-awcl_cur)
                           {awcl_after = awcl_cur; break;}  /* overflow */
                         if (chl_sign)      /* write sign prefix       */
                           *awcl_cur++ = HL_WCHAR_CAST(chl_sign);
                         /* padding left with zeroes to "precision"    */
                         while (inl_precpad) {
                           *awcl_cur++ = HL_WCHAR_CAST('0');
                           inl_precpad --;
                         }
                       }
                       /* postfix                                      */
                       if (inl_postfixlen) {
                         if (inl_postfixlen==2) {
                           *(awcl_after-(inl_padsp+2)) = HL_WCHAR_CAST(chl_postfix);
                           *(awcl_after-(inl_padsp+1)) = HL_WCHAR_CAST('i');
                         } else {
                           *(awcl_after-(inl_padsp+1)) = HL_WCHAR_CAST(chl_postfix);
                         }
                       }
                       /* padding right with spaces                    */
                       if (inl_padsp) {
                         awcl0 = awcl_after-1;
                         do
                           *awcl0-- = HL_WCHAR_CAST(' ');
                         while (--inl_padsp);
                       }
                       /* produce the digits                           */
                       if (inl_emax > 0) {
#ifdef HL_USE_DIV
                         if (sizeof(signed int)<=sizeof(int)) {
                           div_t dsl_d;
                           dsl_d = div(iml_arg1,DECBASE);
                           if (inl_dgsp_lc) {  /* using digit group separation */
                             awcl_cur += inl_emax+inl_dgsp_tm*inl_dgsp_lo-1;
                             if (inl_dgsp_tm) {  /* write all digit groups that follow a separator */
                               inl_s=D_DIGGRPLEN-inl_pfdgph;
                               while (TRUE) {
                                 do {
                                   *(awcl_cur)-- = HL_WCHAR_CAST('0'+dsl_d.rem);
                                   dsl_d = div(dsl_d.quot,DECBASE);
                                 } while (--inl_s);
                                 awcl_cur -= inl_dgsp_lo;  /* skip digits-separator */
                                 if (--inl_dgsp_tm==0)
                                   break;
                                 inl_s=D_DIGGRPLEN;
                               }
                             }
                             if (inl_dgsp_ph) {  /* precision may provoke leading separator */
                               while (TRUE) {   /* write leading (maybe partial) digit group */
                                 *awcl_cur = HL_WCHAR_CAST('0'+dsl_d.rem);
                                 if (--inl_dgsp_ph == 0) break;
                                 awcl_cur--;
                                 dsl_d = div(dsl_d.quot,DECBASE);
                               }
                             }
                           } else {  /* not using digit group separation */
                             while (TRUE) {
                               *(awcl_cur + --inl_emax) = HL_WCHAR_CAST('0'+dsl_d.rem);
                               if (inl_emax <= 0) break;
                               dsl_d = div(dsl_d.quot,DECBASE);
                             }
                           }
#ifdef HL_USE_LDIV
                         } else if (sizeof(signed int)<=sizeof(long int)) {
                           ldiv_t dsl_d;
                           dsl_d = ldiv(iml_arg1,DECBASE);
                           if (inl_dgsp_lc) {  /* using digit group separation */
                             awcl_cur += inl_emax+inl_dgsp_tm*inl_dgsp_lo-1;
                             if (inl_dgsp_tm) {  /* write all digit groups that follow a separator */
                               inl_s=D_DIGGRPLEN-inl_pfdgph;
                               while (TRUE) {
                                 do {
                                   *(awcl_cur)-- = HL_WCHAR_CAST('0'+dsl_d.rem);
                                   dsl_d = ldiv(dsl_d.quot,DECBASE);
                                 } while (--inl_s);
                                 awcl_cur -= inl_dgsp_lo;  /* skip digits-separator */
                                 if (--inl_dgsp_tm==0)
                                   break;
                                 inl_s=D_DIGGRPLEN;
                               }
                             }
                             if (inl_dgsp_ph) {  /* precision may provoke leading separator */
                               while (TRUE) {   /* write leading (maybe partial) digit group */
                                 *awcl_cur = HL_WCHAR_CAST('0'+dsl_d.rem);
                                 if (--inl_dgsp_ph == 0) break;
                                 awcl_cur--;
                                 dsl_d = ldiv(dsl_d.quot,DECBASE);
                               }
                             }
                           } else {  /* not using digit group separation */
                             while (TRUE) {
                               *(awcl_cur + --inl_emax) = HL_WCHAR_CAST('0'+dsl_d.rem);
                               if (inl_emax <= 0) break;
                               dsl_d = ldiv(dsl_d.quot,DECBASE);
                             }
                           }
#endif
#ifdef HL_USE_LLDIV
                         } else if (sizeof(signed int)<=sizeof(long long int)) {
                           lldiv_t dsl_d;
                           dsl_d = lldiv(iml_arg1,DECBASE);
                           if (inl_dgsp_lc) {  /* using digit group separation */
                             awcl_cur += inl_emax+inl_dgsp_tm*inl_dgsp_lo-1;
                             if (inl_dgsp_tm) {  /* write all digit groups that follow a separator */
                               inl_s=D_DIGGRPLEN-inl_pfdgph;
                               while (TRUE) {
                                 do {
                                   *(awcl_cur)-- = HL_WCHAR_CAST('0'+dsl_d.rem);
                                   dsl_d = lldiv(dsl_d.quot,DECBASE);
                                 } while (--inl_s);
                                 awcl_cur -= inl_dgsp_lo;  /* skip digits-separator */
                                 if (--inl_dgsp_tm==0)
                                   break;
                                 inl_s=D_DIGGRPLEN;
                               }
                             }
                             if (inl_dgsp_ph) {  /* precision may provoke leading separator */
                               while (TRUE) {   /* write leading (maybe partial) digit group */
                                 *awcl_cur = HL_WCHAR_CAST('0'+dsl_d.rem);
                                 if (--inl_dgsp_ph == 0) break;
                                 awcl_cur--;
                                 dsl_d = lldiv(dsl_d.quot,DECBASE);
                               }
                             }
                           } else {  /* not using digit group separation */
                             while (TRUE) {
                               *(awcl_cur + --inl_emax) = HL_WCHAR_CAST('0'+dsl_d.rem);
                               if (inl_emax <= 0) break;
                               dsl_d = lldiv(dsl_d.quot,DECBASE);
                             }
                           }
#endif
                         } else {
#endif
                           if (inl_dgsp_lc) {  /* using digit group separation */
                             awcl_cur += inl_emax+inl_dgsp_tm*inl_dgsp_lo-1;
                             if (inl_dgsp_tm) {  /* write all digit groups that follow a separator */
                               inl_s=D_DIGGRPLEN-inl_pfdgph;
                               while (TRUE) {
                                 do {
                                   *(awcl_cur)-- = HL_WCHAR_CAST('0'+iml_arg1%(signed int)DECBASE);
                                   iml_arg1/=(signed int)DECBASE;
                                 } while (--inl_s);
                                 awcl_cur -= inl_dgsp_lo;  /* skip digits-separator */
                                 if (--inl_dgsp_tm==0)
                                   break;
                                 inl_s=D_DIGGRPLEN;
                               }
                             }
                             if (inl_dgsp_ph) {  /* precision may provoke leading separator */
                               while (TRUE) {   /* write leading (maybe partial) digit group */
                                 *awcl_cur = HL_WCHAR_CAST('0'+iml_arg1%(signed int)DECBASE);
                                 if (--inl_dgsp_ph == 0) break;
                                 awcl_cur--;
                                 iml_arg1/=(signed int)DECBASE;
                               }
                             }
                           } else {  /* not using digit group separation */
                             while (--inl_emax > 0) {
                               *(awcl_cur+inl_emax) = HL_WCHAR_CAST('0'+iml_arg1%(signed int)DECBASE);
                               iml_arg1/=(signed int)DECBASE;
                             }
                             *awcl_cur = HL_WCHAR_CAST('0'+iml_arg1);
                           }
#ifdef HL_USE_DIV
                         }
#endif
                         awcl_cur += inl_emax;
                       }
                 break;
               case 'l': case 'L':
                 if(bol_longlong){
                   ill_arg = va_arg(dsl_list, HL_LONGLONG);
                       /* determine sign and go on with non-negative X */
                       if (ill_arg > 0) {
                         chl_sign = achl_signed[2];
                       } else {
                         if (ill_arg != 0)
                         {
                           chl_sign = achl_signed[0];
                           ill_arg=0-ill_arg; /* replace negative X by its abs-value */
                           if ((HL_LONGLONG)ill_arg<0) {  /* special case: X was the extreme negative value */
                             /*inl_emax = (((sizeof(HL_LONGLONG)*8-1)*30103)/100000)+1;*/
                             ill_arg=(HL_LONGLONG)(-1)-ill_arg; /* 7fff... */
                             if (iel_scaling==ied_scaling_none) {
                               chl_postfix = '1'+ill_arg%DECBASE;  /* decimal carry cannot happen here */
                               inl_postfixlen = 1;
                               inl_pfdgph = 1;
                               ull_precision--;
                               ill_arg/=DECBASE;
                             }
                           }
                         } else {
                           chl_sign = achl_signed[1];
                         }
                       }
                       inl_needed = chl_sign?1:0;

                       /* prepare %(sci-dec)- or %(sci-dec)-type of rendering */
                       if (iel_scaling!=ied_scaling_none) {
                         if (iel_scaling == ied_scaling_1000) {  /* power-of-1000-scaled */
#if HL_PRFMAXSO_LL > 4
                           if ((sizeof(HL_LONGLONG) > 4) && (ill_arg >= D_L1000RD * ullrs_decpowbuf[9])) {
#if HL_PRFMAXSO_LL > 8
                             if (
                                 (sizeof(HL_LONGLONG) > 8) &&
                                 (ill_arg >= D_L1000RD * ullrs_decpowbuf[15])
                                ) {
                               if (
                                   (ill_arg >= D_L1000RD * ullrs_decpowbuf[18])
                                  ) {
                                 if (ill_arg >= D_L1000RD * ullrs_decpowbuf[21]) {
                                   ill_arg =  (ill_arg + 500 * ullrs_decpowbuf[21]) / (ullrs_decpowbuf[24]);
                                   chl_postfix = 'Y';
                                 } else {
                                   ill_arg =  (ill_arg + 500 * ullrs_decpowbuf[18]) / (ullrs_decpowbuf[21]);
                                   chl_postfix = 'Z';
                                 }
                               } else {
                                 ill_arg =  (ill_arg + 500 * ullrs_decpowbuf[15]) / (ullrs_decpowbuf[18]);
                                 chl_postfix = 'E';
                               }
                             } else {
#endif
                               if (ill_arg >= D_L1000RD * ullrs_decpowbuf[12]) {
                                 ill_arg =  (ill_arg + 500 * ullrs_decpowbuf[12]) / (ullrs_decpowbuf[15]);
                                 chl_postfix = 'P';
                               } else {
                                 ill_arg =  (ill_arg + 500 * ullrs_decpowbuf[9]) / (ullrs_decpowbuf[12]);
                                 chl_postfix = 'T';
                               }
#if HL_PRFMAXSO_LL > 8
                             }
#endif
                             inl_postfixlen = 1;
                           } else {
#endif
#if HL_PRFMAXSO_LL > 2
                             if ((sizeof(HL_LONGLONG) > 2) && (ill_arg >= D_L1000RD * ullrs_decpowbuf[3])) {
#if HL_PRFMAXSO_LL > 4
                               if ((sizeof(HL_LONGLONG) > 4) && (ill_arg >= D_L1000RD * ullrs_decpowbuf[6])) {
                                 ill_arg =  (ill_arg + 500 * ullrs_decpowbuf[6]) / (ullrs_decpowbuf[9]);
                                 chl_postfix = 'G';
                               } else {
#endif
                                 ill_arg =  (ill_arg + 500 * ullrs_decpowbuf[3]) / (ullrs_decpowbuf[6]);
                                 chl_postfix = 'M';
#if HL_PRFMAXSO_LL > 4
                               }
#endif
                               inl_postfixlen = 1;
                             } else {
#endif
                               if (ill_arg >= D_L1000RD) {
                                 ill_arg = (ill_arg + 500) / 1000;
                                 chl_postfix = 'k';
                                 inl_postfixlen = 1;
                               }
#if HL_PRFMAXSO_LL > 2
                             }
#endif
#if HL_PRFMAXSO_LL > 4
                           }
#endif
                         }
                         else {               /* power-of-1024-scaled    */
#if HL_PRFMAXSO_LL > 4
                           if ((sizeof(HL_LONGLONG) > 4) && (ill_arg>>30 >= D_L1024RD)) {
#if HL_PRFMAXSO_LL > 8
                             if (
                                 (sizeof(HL_LONGLONG) > 8) &&
                                 (ill_arg>>50 >= D_L1024RD)
                                ) {
                               if (
                                   (ill_arg>>60 >= D_L1024RD)
                                  ) {
                                 if (ill_arg>>70 >= D_L1024RD) {
                                   ill_arg = (ill_arg+((HL_LONGLONG)1<<79)) >> 80;
                                   chl_postfix = 'Y';
                                 } else {
                                   ill_arg = (ill_arg+((HL_LONGLONG)1<<69)) >> 70;
                                   chl_postfix = 'Z';
                                 }
                               } else {
                                 ill_arg = (ill_arg+((HL_LONGLONG)1<<59)) >> 60;
                                 chl_postfix = 'E';
                               }
                             } else {
#endif
                               if (ill_arg>>40 >= D_L1024RD) {
                                 ill_arg = (ill_arg+((HL_LONGLONG)1<<49)) >> 50;
                                 chl_postfix = 'P';
                               } else {
                                 ill_arg = (ill_arg+((HL_LONGLONG)1<<39)) >> 40;
                                 chl_postfix = 'T';
                               }
#if HL_PRFMAXSO_LL > 8
                             }
#endif
                             inl_postfixlen = bol_alternate_form ? 2 : 1;
                           } else {
#endif
#if HL_PRFMAXSO_LL > 2
                             if ((sizeof(HL_LONGLONG) > 2) && (ill_arg>>10 >= D_L1024RD)) {
#if HL_PRFMAXSO_LL > 4
                               if ((sizeof(HL_LONGLONG) > 4) && (ill_arg>>20 >= D_L1024RD)) {
                                 ill_arg = (ill_arg+((HL_LONGLONG)1<<29)) >> 30;
                                 chl_postfix = 'G';
                               } else {
#endif
                                 ill_arg = (ill_arg+((HL_LONGLONG)1<<19)) >> 20;
                                 chl_postfix = 'M';
#if HL_PRFMAXSO_LL > 4
                               }
#endif
                               inl_postfixlen = bol_alternate_form ? 2 : 1;
                             } else {
#endif
                               if (ill_arg >= D_L1024RD) {
                                 ill_arg = (ill_arg+0x200) >> 10;
                                 chl_postfix = 'K';
                                 inl_postfixlen = bol_alternate_form ? 2 : 1;
                               }
#if HL_PRFMAXSO_LL > 2
                             }
#endif
#if HL_PRFMAXSO_LL > 4
                           }
#endif
                         }
                       }

                       /* detect the order of magnitude of X           */
                       inl_emax = 0;
                       if (ill_arg) {
                         int inl_e = (((sizeof(HL_LONGLONG)*8-1)*30103)/100000)+1;
                         do {
                           inl_s = inl_e>>1;
                           if (ill_arg >= ullrs_decpowbuf[inl_emax+inl_s]) {
                             inl_emax += inl_s;
                             inl_e -= inl_s;
                           } else {
                             inl_e = inl_s;
                           }
                         } while (inl_e>1);
                         inl_emax ++;
                       }
                       inl_needed += inl_emax + inl_postfixlen;
                       if (inl_dgsp_lc) {   /* use digit group separation */
                         if (inl_emax<=D_DIGGRPLEN) {  /* digit grouping not in effect */
                           inl_dgsp_lc = 0;
                         } else {
                           const int inl_emax_1 = inl_emax+inl_pfdgph-1;
#ifdef HL_USE_DIV
                           dsl_diggrp_dm = div(inl_emax_1, D_DIGGRPLEN);
                           inl_dgsp_ph++;
#else
                           inl_dgsp_tm = (inl_emax_1)/D_DIGGRPLEN;
                           inl_dgsp_ph = (inl_emax_1)%D_DIGGRPLEN+1;
#endif
                           if (inl_needed>=ull_field_width || inl_needed+inl_dgsp_tm*inl_dgsp_lc<=ull_field_width) {
                             inl_s = inl_dgsp_tm*inl_dgsp_lc;
                             inl_needed += inl_s;
                           } else {  /* prefer staying within fieldwidth over using the separator */
                             inl_dgsp_lc = 0;
                           }
                         }
                       }
                       if (!bol_precision) {
                         ull_precision = 1;  /* default precision      */
                         if (bol_padding_zero) {
                           if (ull_field_width>inl_needed && !bol_adjustleft) {
                             /* fake padding with '0' by ull_precision */
                             ull_precision = ull_field_width+(inl_dgsp_lc?inl_emax+inl_s:inl_emax)-inl_needed;
                           }
                         }
                       }
                       if (inl_dgsp_lc) {   /* using digit group separation */
                         inl_precpad = ull_precision-(inl_emax+inl_s);
                         if (inl_precpad>0) {
#ifdef HL_USE_DIV
                           div_t dsl_d = div(inl_dgsp_ph+inl_precpad, D_DIGGRPLEN+inl_dgsp_lc);
                           inl_dgsp_tm += dsl_d.quot;
                           inl_needed += inl_precpad;
                           inl_dgsp_ph = dsl_d.rem;
#else
                           inl_needed += inl_precpad;
                           inl_dgsp_tm += (inl_dgsp_ph+inl_precpad)/(D_DIGGRPLEN+inl_dgsp_lc);
                           inl_dgsp_ph = (inl_dgsp_ph+inl_precpad)%(D_DIGGRPLEN+inl_dgsp_lc);
#endif
                           if (inl_dgsp_ph>D_DIGGRPLEN) {
                             inl_needed -= inl_dgsp_ph-D_DIGGRPLEN;
                             inl_dgsp_ph = D_DIGGRPLEN;
                           }
                           inl_precpad = ull_precision-(inl_emax+inl_dgsp_tm*inl_dgsp_lc);
                         } else {
                           inl_precpad=0;
                         }
                       } else {    /* not using digit group separation */
                         inl_precpad = ull_precision-inl_emax;
                         if (inl_precpad>0) {
                           inl_needed += inl_precpad;
                         } else {
                           inl_precpad=0;
                         }
                       }
                       if (ull_field_width > inl_needed) {
                         awcl_after = awcl_cur+ull_field_width;
                         inl_padsp = ull_field_width-inl_needed;
                         if (!bol_adjustleft) {  /* padding left with spaces */
                           if (inl_padsp > awcl_end-awcl_cur)
                             {awcl_after = awcl_cur; break;}  /* overflow */
                           do
                             *awcl_cur++ = HL_WCHAR_CAST(' ');
                           while (--inl_padsp);
                         }
                       } else {
                         awcl_after = awcl_cur+inl_needed;
                         inl_padsp = 0;
                       }
                       if (inl_dgsp_lc) {   /* set digit group separators */
                         if (chl_sign) {    /* write sign prefix       */
                           if (1 > awcl_end-awcl_cur)
                             {awcl_after = awcl_cur; break;}  /* overflow */
                           *awcl_cur++ = HL_WCHAR_CAST(chl_sign);
                         }
                         /* produce the first separator                                     */
                         awcl_dg = awcl_cur+inl_dgsp_ph;
                         if (iel_cs_target == ied_chs_utf_16) {  /* natural endian */
                           inl_dgsp_lo = m_u16l_from_u8l(awcl_dg, awcl_end-awcl_dg, achl_dgsp, inl_dgsp_lb);
                         } else {           /* swapped endian          */
                           inl_dgsp_lo = m_u16r_from_u8l(awcl_dg, 1+awcl_end-awcl_dg, achl_dgsp, inl_dgsp_lb);
                         }
                         /* now the complete physical output length can be determined      */
                         inl_s = inl_dgsp_tm*(inl_dgsp_lo-inl_dgsp_lc);  /* adjustment from logical to physical */
                         awcl_after += inl_s;
                         if (inl_dgsp_lo<0 || awcl_after-awcl_cur>awcl_end-awcl_cur)
                           {awcl_after = awcl_cur; break;}  /* overflow */
                         /* copy the other separators from the first one                   */
                         inl_s = inl_dgsp_tm-1;
                         if (inl_s) {
                           awcl0 = awcl_dg+inl_dgsp_lo;
                           do {
                             awcl0 += D_DIGGRPLEN;
                             int inl2 = 0;
                             do
                               *awcl0++ = awcl_dg[inl2++];
                             while (inl2<inl_dgsp_lo);
                           } while (--inl_s);
                         }
                         /* padding left with zeroes to "precision"                        */
                         while (inl_precpad) {
                           if (inl_dgsp_ph == 0) {  /* skip digits-separator */
                             awcl_cur += inl_dgsp_lo;
                             inl_dgsp_ph = D_DIGGRPLEN-1;
                             inl_dgsp_tm--;
                             if (!inl_dgsp_tm)
                               break;
                           } else {
                             inl_dgsp_ph--;
                           }
                           *awcl_cur++ = HL_WCHAR_CAST('0');
                           inl_precpad --;
                         }
                       } else {             /* not using digit group separation */
                         if (awcl_after-awcl_cur>awcl_end-awcl_cur)
                           {awcl_after = awcl_cur; break;}  /* overflow */
                         if (chl_sign)      /* write sign prefix       */
                           *awcl_cur++ = HL_WCHAR_CAST(chl_sign);
                         /* padding left with zeroes to "precision"    */
                         while (inl_precpad) {
                           *awcl_cur++ = HL_WCHAR_CAST('0');
                           inl_precpad --;
                         }
                       }
                       /* postfix                                      */
                       if (inl_postfixlen) {
                         if (inl_postfixlen==2) {
                           *(awcl_after-(inl_padsp+2)) = HL_WCHAR_CAST(chl_postfix);
                           *(awcl_after-(inl_padsp+1)) = HL_WCHAR_CAST('i');
                         } else {
                           *(awcl_after-(inl_padsp+1)) = HL_WCHAR_CAST(chl_postfix);
                         }
                       }
                       /* padding right with spaces                    */
                       if (inl_padsp) {
                         awcl0 = awcl_after-1;
                         do
                           *awcl0-- = HL_WCHAR_CAST(' ');
                         while (--inl_padsp);
                       }
                       /* produce the digits                           */
                       if (inl_emax > 0) {
#ifdef HL_USE_DIV
                         if (sizeof(HL_LONGLONG)<=sizeof(int)) {
                           div_t dsl_d;
                           dsl_d = div(ill_arg,DECBASE);
                           if (inl_dgsp_lc) {  /* using digit group separation */
                             awcl_cur += inl_emax+inl_dgsp_tm*inl_dgsp_lo-1;
                             if (inl_dgsp_tm) {  /* write all digit groups that follow a separator */
                               inl_s=D_DIGGRPLEN-inl_pfdgph;
                               while (TRUE) {
                                 do {
                                   *(awcl_cur)-- = HL_WCHAR_CAST('0'+dsl_d.rem);
                                   dsl_d = div(dsl_d.quot,DECBASE);
                                 } while (--inl_s);
                                 awcl_cur -= inl_dgsp_lo;  /* skip digits-separator */
                                 if (--inl_dgsp_tm==0)
                                   break;
                                 inl_s=D_DIGGRPLEN;
                               }
                             }
                             if (inl_dgsp_ph) {  /* precision may provoke leading separator */
                               while (TRUE) {   /* write leading (maybe partial) digit group */
                                 *awcl_cur = HL_WCHAR_CAST('0'+dsl_d.rem);
                                 if (--inl_dgsp_ph == 0) break;
                                 awcl_cur--;
                                 dsl_d = div(dsl_d.quot,DECBASE);
                               }
                             }
                           } else {  /* not using digit group separation */
                             while (TRUE) {
                               *(awcl_cur + --inl_emax) = HL_WCHAR_CAST('0'+dsl_d.rem);
                               if (inl_emax <= 0) break;
                               dsl_d = div(dsl_d.quot,DECBASE);
                             }
                           }
#ifdef HL_USE_LDIV
                         } else if (sizeof(HL_LONGLONG)<=sizeof(long int)) {
                           ldiv_t dsl_d;
                           dsl_d = ldiv(ill_arg,DECBASE);
                           if (inl_dgsp_lc) {  /* using digit group separation */
                             awcl_cur += inl_emax+inl_dgsp_tm*inl_dgsp_lo-1;
                             if (inl_dgsp_tm) {  /* write all digit groups that follow a separator */
                               inl_s=D_DIGGRPLEN-inl_pfdgph;
                               while (TRUE) {
                                 do {
                                   *(awcl_cur)-- = HL_WCHAR_CAST('0'+dsl_d.rem);
                                   dsl_d = ldiv(dsl_d.quot,DECBASE);
                                 } while (--inl_s);
                                 awcl_cur -= inl_dgsp_lo;  /* skip digits-separator */
                                 if (--inl_dgsp_tm==0)
                                   break;
                                 inl_s=D_DIGGRPLEN;
                               }
                             }
                             if (inl_dgsp_ph) {  /* precision may provoke leading separator */
                               while (TRUE) {   /* write leading (maybe partial) digit group */
                                 *awcl_cur = HL_WCHAR_CAST('0'+dsl_d.rem);
                                 if (--inl_dgsp_ph == 0) break;
                                 awcl_cur--;
                                 dsl_d = ldiv(dsl_d.quot,DECBASE);
                               }
                             }
                           } else {  /* not using digit group separation */
                             while (TRUE) {
                               *(awcl_cur + --inl_emax) = HL_WCHAR_CAST('0'+dsl_d.rem);
                               if (inl_emax <= 0) break;
                               dsl_d = ldiv(dsl_d.quot,DECBASE);
                             }
                           }
#endif
#ifdef HL_USE_LLDIV
                         } else if (sizeof(HL_LONGLONG)<=sizeof(long long int)) {
                           lldiv_t dsl_d;
                           dsl_d = lldiv(ill_arg,DECBASE);
                           if (inl_dgsp_lc) {  /* using digit group separation */
                             awcl_cur += inl_emax+inl_dgsp_tm*inl_dgsp_lo-1;
                             if (inl_dgsp_tm) {  /* write all digit groups that follow a separator */
                               inl_s=D_DIGGRPLEN-inl_pfdgph;
                               while (TRUE) {
                                 do {
                                   *(awcl_cur)-- = HL_WCHAR_CAST('0'+dsl_d.rem);
                                   dsl_d = lldiv(dsl_d.quot,DECBASE);
                                 } while (--inl_s);
                                 awcl_cur -= inl_dgsp_lo;  /* skip digits-separator */
                                 if (--inl_dgsp_tm==0)
                                   break;
                                 inl_s=D_DIGGRPLEN;
                               }
                             }
                             if (inl_dgsp_ph) {  /* precision may provoke leading separator */
                               while (TRUE) {   /* write leading (maybe partial) digit group */
                                 *awcl_cur = HL_WCHAR_CAST('0'+dsl_d.rem);
                                 if (--inl_dgsp_ph == 0) break;
                                 awcl_cur--;
                                 dsl_d = lldiv(dsl_d.quot,DECBASE);
                               }
                             }
                           } else {  /* not using digit group separation */
                             while (TRUE) {
                               *(awcl_cur + --inl_emax) = HL_WCHAR_CAST('0'+dsl_d.rem);
                               if (inl_emax <= 0) break;
                               dsl_d = lldiv(dsl_d.quot,DECBASE);
                             }
                           }
#endif
                         } else {
#endif
                           if (inl_dgsp_lc) {  /* using digit group separation */
                             awcl_cur += inl_emax+inl_dgsp_tm*inl_dgsp_lo-1;
                             if (inl_dgsp_tm) {  /* write all digit groups that follow a separator */
                               inl_s=D_DIGGRPLEN-inl_pfdgph;
                               while (TRUE) {
                                 do {
                                   *(awcl_cur)-- = HL_WCHAR_CAST('0'+ill_arg%(HL_LONGLONG)DECBASE);
                                   ill_arg/=(HL_LONGLONG)DECBASE;
                                 } while (--inl_s);
                                 awcl_cur -= inl_dgsp_lo;  /* skip digits-separator */
                                 if (--inl_dgsp_tm==0)
                                   break;
                                 inl_s=D_DIGGRPLEN;
                               }
                             }
                             if (inl_dgsp_ph) {  /* precision may provoke leading separator */
                               while (TRUE) {   /* write leading (maybe partial) digit group */
                                 *awcl_cur = HL_WCHAR_CAST('0'+ill_arg%(HL_LONGLONG)DECBASE);
                                 if (--inl_dgsp_ph == 0) break;
                                 awcl_cur--;
                                 ill_arg/=(HL_LONGLONG)DECBASE;
                               }
                             }
                           } else {  /* not using digit group separation */
                             while (--inl_emax > 0) {
                               *(awcl_cur+inl_emax) = HL_WCHAR_CAST('0'+ill_arg%(HL_LONGLONG)DECBASE);
                               ill_arg/=(HL_LONGLONG)DECBASE;
                             }
                             *awcl_cur = HL_WCHAR_CAST('0'+ill_arg);
                           }
#ifdef HL_USE_DIV
                         }
#endif
                         awcl_cur += inl_emax;
                       }
                 }
                 else {
                   ill_arg = va_arg(dsl_list, long int);
                       /* determine sign and go on with non-negative X */
                       if (ill_arg > 0) {
                         chl_sign = achl_signed[2];
                       } else {
                         if (ill_arg != 0)
                         {
                           chl_sign = achl_signed[0];
                           ill_arg=0-ill_arg; /* replace negative X by its abs-value */
                           if ((signed long int)ill_arg<0) {  /* special case: X was the extreme negative value */
                             /*inl_emax = (((sizeof(signed long int)*8-1)*30103)/100000)+1;*/
                             ill_arg=(signed long int)(-1)-ill_arg; /* 7fff... */
                             if (iel_scaling==ied_scaling_none) {
                               chl_postfix = '1'+ill_arg%DECBASE;  /* decimal carry cannot happen here */
                               inl_postfixlen = 1;
                               inl_pfdgph = 1;
                               ull_precision--;
                               ill_arg/=DECBASE;
                             }
                           }
                         } else {
                           chl_sign = achl_signed[1];
                         }
                       }
                       inl_needed = chl_sign?1:0;

                       /* prepare %(sci-dec)- or %(sci-dec)-type of rendering */
                       if (iel_scaling!=ied_scaling_none) {
                         if (iel_scaling == ied_scaling_1000) {  /* power-of-1000-scaled */
#if HL_PRFMAXSO_L > 4
                           if ((sizeof(signed long int) > 4) && (ill_arg >= D_L1000RD * ullrs_decpowbuf[9])) {
#if HL_PRFMAXSO_L > 8
                             if (
                                 (sizeof(signed long int) > 8) &&
                                 (ill_arg >= D_L1000RD * ullrs_decpowbuf[15])
                                ) {
                               if (
                                   (ill_arg >= D_L1000RD * ullrs_decpowbuf[18])
                                  ) {
                                 if (ill_arg >= D_L1000RD * ullrs_decpowbuf[21]) {
                                   ill_arg =  (ill_arg + 500 * ullrs_decpowbuf[21]) / (ullrs_decpowbuf[24]);
                                   chl_postfix = 'Y';
                                 } else {
                                   ill_arg =  (ill_arg + 500 * ullrs_decpowbuf[18]) / (ullrs_decpowbuf[21]);
                                   chl_postfix = 'Z';
                                 }
                               } else {
                                 ill_arg =  (ill_arg + 500 * ullrs_decpowbuf[15]) / (ullrs_decpowbuf[18]);
                                 chl_postfix = 'E';
                               }
                             } else {
#endif
                               if (ill_arg >= D_L1000RD * ullrs_decpowbuf[12]) {
                                 ill_arg =  (ill_arg + 500 * ullrs_decpowbuf[12]) / (ullrs_decpowbuf[15]);
                                 chl_postfix = 'P';
                               } else {
                                 ill_arg =  (ill_arg + 500 * ullrs_decpowbuf[9]) / (ullrs_decpowbuf[12]);
                                 chl_postfix = 'T';
                               }
#if HL_PRFMAXSO_L > 8
                             }
#endif
                             inl_postfixlen = 1;
                           } else {
#endif
#if HL_PRFMAXSO_L > 2
                             if ((sizeof(signed long int) > 2) && (ill_arg >= D_L1000RD * ullrs_decpowbuf[3])) {
#if HL_PRFMAXSO_L > 4
                               if ((sizeof(signed long int) > 4) && (ill_arg >= D_L1000RD * ullrs_decpowbuf[6])) {
                                 ill_arg =  (ill_arg + 500 * ullrs_decpowbuf[6]) / (ullrs_decpowbuf[9]);
                                 chl_postfix = 'G';
                               } else {
#endif
                                 ill_arg =  (ill_arg + 500 * ullrs_decpowbuf[3]) / (ullrs_decpowbuf[6]);
                                 chl_postfix = 'M';
#if HL_PRFMAXSO_L > 4
                               }
#endif
                               inl_postfixlen = 1;
                             } else {
#endif
                               if (ill_arg >= D_L1000RD) {
                                 ill_arg = (ill_arg + 500) / 1000;
                                 chl_postfix = 'k';
                                 inl_postfixlen = 1;
                               }
#if HL_PRFMAXSO_L > 2
                             }
#endif
#if HL_PRFMAXSO_L > 4
                           }
#endif
                         }
                         else {               /* power-of-1024-scaled    */
#if HL_PRFMAXSO_L > 4
                           if ((sizeof(signed long int) > 4) && (ill_arg>>30 >= D_L1024RD)) {
#if HL_PRFMAXSO_L > 8
                             if (
                                 (sizeof(signed long int) > 8) &&
                                 (ill_arg>>50 >= D_L1024RD)
                                ) {
                               if (
                                   (ill_arg>>60 >= D_L1024RD)
                                  ) {
                                 if (ill_arg>>70 >= D_L1024RD) {
                                   ill_arg = (ill_arg+((signed long int)1<<79)) >> 80;
                                   chl_postfix = 'Y';
                                 } else {
                                   ill_arg = (ill_arg+((signed long int)1<<69)) >> 70;
                                   chl_postfix = 'Z';
                                 }
                               } else {
                                 ill_arg = (ill_arg+((signed long int)1<<59)) >> 60;
                                 chl_postfix = 'E';
                               }
                             } else {
#endif
                               if (ill_arg>>40 >= D_L1024RD) {
                                 ill_arg = (ill_arg+((signed long int)1<<49)) >> 50;
                                 chl_postfix = 'P';
                               } else {
                                 ill_arg = (ill_arg+((signed long int)1<<39)) >> 40;
                                 chl_postfix = 'T';
                               }
#if HL_PRFMAXSO_L > 8
                             }
#endif
                             inl_postfixlen = bol_alternate_form ? 2 : 1;
                           } else {
#endif
#if HL_PRFMAXSO_L > 2
                             if ((sizeof(signed long int) > 2) && (ill_arg>>10 >= D_L1024RD)) {
#if HL_PRFMAXSO_L > 4
                               if ((sizeof(signed long int) > 4) && (ill_arg>>20 >= D_L1024RD)) {
                                 ill_arg = (ill_arg+((signed long int)1<<29)) >> 30;
                                 chl_postfix = 'G';
                               } else {
#endif
                                 ill_arg = (ill_arg+((signed long int)1<<19)) >> 20;
                                 chl_postfix = 'M';
#if HL_PRFMAXSO_L > 4
                               }
#endif
                               inl_postfixlen = bol_alternate_form ? 2 : 1;
                             } else {
#endif
                               if (ill_arg >= D_L1024RD) {
                                 ill_arg = (ill_arg+0x200) >> 10;
                                 chl_postfix = 'K';
                                 inl_postfixlen = bol_alternate_form ? 2 : 1;
                               }
#if HL_PRFMAXSO_L > 2
                             }
#endif
#if HL_PRFMAXSO_L > 4
                           }
#endif
                         }
                       }

                       /* detect the order of magnitude of X           */
                       inl_emax = 0;
                       if (ill_arg) {
                         int inl_e = (((sizeof(signed long int)*8-1)*30103)/100000)+1;
                         do {
                           inl_s = inl_e>>1;
                           if (ill_arg >= ullrs_decpowbuf[inl_emax+inl_s]) {
                             inl_emax += inl_s;
                             inl_e -= inl_s;
                           } else {
                             inl_e = inl_s;
                           }
                         } while (inl_e>1);
                         inl_emax ++;
                       }
                       inl_needed += inl_emax + inl_postfixlen;
                       if (inl_dgsp_lc) {   /* use digit group separation */
                         if (inl_emax<=D_DIGGRPLEN) {  /* digit grouping not in effect */
                           inl_dgsp_lc = 0;
                         } else {
                           const int inl_emax_1 = inl_emax+inl_pfdgph-1;
#ifdef HL_USE_DIV
                           dsl_diggrp_dm = div(inl_emax_1, D_DIGGRPLEN);
                           inl_dgsp_ph++;
#else
                           inl_dgsp_tm = (inl_emax_1)/D_DIGGRPLEN;
                           inl_dgsp_ph = (inl_emax_1)%D_DIGGRPLEN+1;
#endif
                           if (inl_needed>=ull_field_width || inl_needed+inl_dgsp_tm*inl_dgsp_lc<=ull_field_width) {
                             inl_s = inl_dgsp_tm*inl_dgsp_lc;
                             inl_needed += inl_s;
                           } else {  /* prefer staying within fieldwidth over using the separator */
                             inl_dgsp_lc = 0;
                           }
                         }
                       }
                       if (!bol_precision) {
                         ull_precision = 1;  /* default precision      */
                         if (bol_padding_zero) {
                           if (ull_field_width>inl_needed && !bol_adjustleft) {
                             /* fake padding with '0' by ull_precision */
                             ull_precision = ull_field_width+(inl_dgsp_lc?inl_emax+inl_s:inl_emax)-inl_needed;
                           }
                         }
                       }
                       if (inl_dgsp_lc) {   /* using digit group separation */
                         inl_precpad = ull_precision-(inl_emax+inl_s);
                         if (inl_precpad>0) {
#ifdef HL_USE_DIV
                           div_t dsl_d = div(inl_dgsp_ph+inl_precpad, D_DIGGRPLEN+inl_dgsp_lc);
                           inl_dgsp_tm += dsl_d.quot;
                           inl_needed += inl_precpad;
                           inl_dgsp_ph = dsl_d.rem;
#else
                           inl_needed += inl_precpad;
                           inl_dgsp_tm += (inl_dgsp_ph+inl_precpad)/(D_DIGGRPLEN+inl_dgsp_lc);
                           inl_dgsp_ph = (inl_dgsp_ph+inl_precpad)%(D_DIGGRPLEN+inl_dgsp_lc);
#endif
                           if (inl_dgsp_ph>D_DIGGRPLEN) {
                             inl_needed -= inl_dgsp_ph-D_DIGGRPLEN;
                             inl_dgsp_ph = D_DIGGRPLEN;
                           }
                           inl_precpad = ull_precision-(inl_emax+inl_dgsp_tm*inl_dgsp_lc);
                         } else {
                           inl_precpad=0;
                         }
                       } else {    /* not using digit group separation */
                         inl_precpad = ull_precision-inl_emax;
                         if (inl_precpad>0) {
                           inl_needed += inl_precpad;
                         } else {
                           inl_precpad=0;
                         }
                       }
                       if (ull_field_width > inl_needed) {
                         awcl_after = awcl_cur+ull_field_width;
                         inl_padsp = ull_field_width-inl_needed;
                         if (!bol_adjustleft) {  /* padding left with spaces */
                           if (inl_padsp > awcl_end-awcl_cur)
                             {awcl_after = awcl_cur; break;}  /* overflow */
                           do
                             *awcl_cur++ = HL_WCHAR_CAST(' ');
                           while (--inl_padsp);
                         }
                       } else {
                         awcl_after = awcl_cur+inl_needed;
                         inl_padsp = 0;
                       }
                       if (inl_dgsp_lc) {   /* set digit group separators */
                         if (chl_sign) {    /* write sign prefix       */
                           if (1 > awcl_end-awcl_cur)
                             {awcl_after = awcl_cur; break;}  /* overflow */
                           *awcl_cur++ = HL_WCHAR_CAST(chl_sign);
                         }
                         /* produce the first separator                                     */
                         awcl_dg = awcl_cur+inl_dgsp_ph;
                         if (iel_cs_target == ied_chs_utf_16) {  /* natural endian */
                           inl_dgsp_lo = m_u16l_from_u8l(awcl_dg, awcl_end-awcl_dg, achl_dgsp, inl_dgsp_lb);
                         } else {           /* swapped endian          */
                           inl_dgsp_lo = m_u16r_from_u8l(awcl_dg, 1+awcl_end-awcl_dg, achl_dgsp, inl_dgsp_lb);
                         }
                         /* now the complete physical output length can be determined      */
                         inl_s = inl_dgsp_tm*(inl_dgsp_lo-inl_dgsp_lc);  /* adjustment from logical to physical */
                         awcl_after += inl_s;
                         if (inl_dgsp_lo<0 || awcl_after-awcl_cur>awcl_end-awcl_cur)
                           {awcl_after = awcl_cur; break;}  /* overflow */
                         /* copy the other separators from the first one                   */
                         inl_s = inl_dgsp_tm-1;
                         if (inl_s) {
                           awcl0 = awcl_dg+inl_dgsp_lo;
                           do {
                             awcl0 += D_DIGGRPLEN;
                             int inl2 = 0;
                             do
                               *awcl0++ = awcl_dg[inl2++];
                             while (inl2<inl_dgsp_lo);
                           } while (--inl_s);
                         }
                         /* padding left with zeroes to "precision"                        */
                         while (inl_precpad) {
                           if (inl_dgsp_ph == 0) {  /* skip digits-separator */
                             awcl_cur += inl_dgsp_lo;
                             inl_dgsp_ph = D_DIGGRPLEN-1;
                             inl_dgsp_tm--;
                             if (!inl_dgsp_tm)
                               break;
                           } else {
                             inl_dgsp_ph--;
                           }
                           *awcl_cur++ = HL_WCHAR_CAST('0');
                           inl_precpad --;
                         }
                       } else {             /* not using digit group separation */
                         if (awcl_after-awcl_cur>awcl_end-awcl_cur)
                           {awcl_after = awcl_cur; break;}  /* overflow */
                         if (chl_sign)      /* write sign prefix       */
                           *awcl_cur++ = HL_WCHAR_CAST(chl_sign);
                         /* padding left with zeroes to "precision"    */
                         while (inl_precpad) {
                           *awcl_cur++ = HL_WCHAR_CAST('0');
                           inl_precpad --;
                         }
                       }
                       /* postfix                                      */
                       if (inl_postfixlen) {
                         if (inl_postfixlen==2) {
                           *(awcl_after-(inl_padsp+2)) = HL_WCHAR_CAST(chl_postfix);
                           *(awcl_after-(inl_padsp+1)) = HL_WCHAR_CAST('i');
                         } else {
                           *(awcl_after-(inl_padsp+1)) = HL_WCHAR_CAST(chl_postfix);
                         }
                       }
                       /* padding right with spaces                    */
                       if (inl_padsp) {
                         awcl0 = awcl_after-1;
                         do
                           *awcl0-- = HL_WCHAR_CAST(' ');
                         while (--inl_padsp);
                       }
                       /* produce the digits                           */
                       if (inl_emax > 0) {
#ifdef HL_USE_DIV
                         if (sizeof(signed long int)<=sizeof(int)) {
                           div_t dsl_d;
                           dsl_d = div(ill_arg,DECBASE);
                           if (inl_dgsp_lc) {  /* using digit group separation */
                             awcl_cur += inl_emax+inl_dgsp_tm*inl_dgsp_lo-1;
                             if (inl_dgsp_tm) {  /* write all digit groups that follow a separator */
                               inl_s=D_DIGGRPLEN-inl_pfdgph;
                               while (TRUE) {
                                 do {
                                   *(awcl_cur)-- = HL_WCHAR_CAST('0'+dsl_d.rem);
                                   dsl_d = div(dsl_d.quot,DECBASE);
                                 } while (--inl_s);
                                 awcl_cur -= inl_dgsp_lo;  /* skip digits-separator */
                                 if (--inl_dgsp_tm==0)
                                   break;
                                 inl_s=D_DIGGRPLEN;
                               }
                             }
                             if (inl_dgsp_ph) {  /* precision may provoke leading separator */
                               while (TRUE) {   /* write leading (maybe partial) digit group */
                                 *awcl_cur = HL_WCHAR_CAST('0'+dsl_d.rem);
                                 if (--inl_dgsp_ph == 0) break;
                                 awcl_cur--;
                                 dsl_d = div(dsl_d.quot,DECBASE);
                               }
                             }
                           } else {  /* not using digit group separation */
                             while (TRUE) {
                               *(awcl_cur + --inl_emax) = HL_WCHAR_CAST('0'+dsl_d.rem);
                               if (inl_emax <= 0) break;
                               dsl_d = div(dsl_d.quot,DECBASE);
                             }
                           }
#ifdef HL_USE_LDIV
                         } else if (sizeof(signed long int)<=sizeof(long int)) {
                           ldiv_t dsl_d;
                           dsl_d = ldiv(ill_arg,DECBASE);
                           if (inl_dgsp_lc) {  /* using digit group separation */
                             awcl_cur += inl_emax+inl_dgsp_tm*inl_dgsp_lo-1;
                             if (inl_dgsp_tm) {  /* write all digit groups that follow a separator */
                               inl_s=D_DIGGRPLEN-inl_pfdgph;
                               while (TRUE) {
                                 do {
                                   *(awcl_cur)-- = HL_WCHAR_CAST('0'+dsl_d.rem);
                                   dsl_d = ldiv(dsl_d.quot,DECBASE);
                                 } while (--inl_s);
                                 awcl_cur -= inl_dgsp_lo;  /* skip digits-separator */
                                 if (--inl_dgsp_tm==0)
                                   break;
                                 inl_s=D_DIGGRPLEN;
                               }
                             }
                             if (inl_dgsp_ph) {  /* precision may provoke leading separator */
                               while (TRUE) {   /* write leading (maybe partial) digit group */
                                 *awcl_cur = HL_WCHAR_CAST('0'+dsl_d.rem);
                                 if (--inl_dgsp_ph == 0) break;
                                 awcl_cur--;
                                 dsl_d = ldiv(dsl_d.quot,DECBASE);
                               }
                             }
                           } else {  /* not using digit group separation */
                             while (TRUE) {
                               *(awcl_cur + --inl_emax) = HL_WCHAR_CAST('0'+dsl_d.rem);
                               if (inl_emax <= 0) break;
                               dsl_d = ldiv(dsl_d.quot,DECBASE);
                             }
                           }
#endif
#ifdef HL_USE_LLDIV
                         } else if (sizeof(signed long int)<=sizeof(long long int)) {
                           lldiv_t dsl_d;
                           dsl_d = lldiv(ill_arg,DECBASE);
                           if (inl_dgsp_lc) {  /* using digit group separation */
                             awcl_cur += inl_emax+inl_dgsp_tm*inl_dgsp_lo-1;
                             if (inl_dgsp_tm) {  /* write all digit groups that follow a separator */
                               inl_s=D_DIGGRPLEN-inl_pfdgph;
                               while (TRUE) {
                                 do {
                                   *(awcl_cur)-- = HL_WCHAR_CAST('0'+dsl_d.rem);
                                   dsl_d = lldiv(dsl_d.quot,DECBASE);
                                 } while (--inl_s);
                                 awcl_cur -= inl_dgsp_lo;  /* skip digits-separator */
                                 if (--inl_dgsp_tm==0)
                                   break;
                                 inl_s=D_DIGGRPLEN;
                               }
                             }
                             if (inl_dgsp_ph) {  /* precision may provoke leading separator */
                               while (TRUE) {   /* write leading (maybe partial) digit group */
                                 *awcl_cur = HL_WCHAR_CAST('0'+dsl_d.rem);
                                 if (--inl_dgsp_ph == 0) break;
                                 awcl_cur--;
                                 dsl_d = lldiv(dsl_d.quot,DECBASE);
                               }
                             }
                           } else {  /* not using digit group separation */
                             while (TRUE) {
                               *(awcl_cur + --inl_emax) = HL_WCHAR_CAST('0'+dsl_d.rem);
                               if (inl_emax <= 0) break;
                               dsl_d = lldiv(dsl_d.quot,DECBASE);
                             }
                           }
#endif
                         } else {
#endif
                           if (inl_dgsp_lc) {  /* using digit group separation */
                             awcl_cur += inl_emax+inl_dgsp_tm*inl_dgsp_lo-1;
                             if (inl_dgsp_tm) {  /* write all digit groups that follow a separator */
                               inl_s=D_DIGGRPLEN-inl_pfdgph;
                               while (TRUE) {
                                 do {
                                   *(awcl_cur)-- = HL_WCHAR_CAST('0'+ill_arg%(signed long int)DECBASE);
                                   ill_arg/=(signed long int)DECBASE;
                                 } while (--inl_s);
                                 awcl_cur -= inl_dgsp_lo;  /* skip digits-separator */
                                 if (--inl_dgsp_tm==0)
                                   break;
                                 inl_s=D_DIGGRPLEN;
                               }
                             }
                             if (inl_dgsp_ph) {  /* precision may provoke leading separator */
                               while (TRUE) {   /* write leading (maybe partial) digit group */
                                 *awcl_cur = HL_WCHAR_CAST('0'+ill_arg%(signed long int)DECBASE);
                                 if (--inl_dgsp_ph == 0) break;
                                 awcl_cur--;
                                 ill_arg/=(signed long int)DECBASE;
                               }
                             }
                           } else {  /* not using digit group separation */
                             while (--inl_emax > 0) {
                               *(awcl_cur+inl_emax) = HL_WCHAR_CAST('0'+ill_arg%(signed long int)DECBASE);
                               ill_arg/=(signed long int)DECBASE;
                             }
                             *awcl_cur = HL_WCHAR_CAST('0'+ill_arg);
                           }
#ifdef HL_USE_DIV
                         }
#endif
                         awcl_cur += inl_emax;
                       }
                 }
                 break;
             }
           }
           else {                           /* unsigned: o O x X u U   */ /*UUU non-implemented 'n' has also 4 in umrs_format*/
             switch(chl_length_modifier) {
               case '\0': case 'h':
                 uml_arg = va_arg(dsl_list, unsigned int);
                 switch (chl_spec&0xDF) {
                   case 'U':

                       /* prepare %(sci-dec)- or %(sci-dec)-type of rendering */
                       if (iel_scaling!=ied_scaling_none) {
                         if (iel_scaling == ied_scaling_1000) {  /* power-of-1000-scaled */
#if HL_PRFMAXSO_I > 4
                           if ((sizeof(unsigned int) > 4) && (uml_arg >= D_L1000RD * unrs_decpowbuf[9])) {
                             if (
                                 (uml_arg >= D_L1000RD * unrs_decpowbuf[15])
                                ) {
#if HL_PRFMAXSO_I > 8
                               if (
                                   (sizeof(unsigned int) > 8) &&
                                   (uml_arg >= D_L1000RD * unrs_decpowbuf[18])
                                  ) {
                                 if (uml_arg >= D_L1000RD * unrs_decpowbuf[21]) {
                                   uml_arg =  (uml_arg + 500 * unrs_decpowbuf[21]) / (unrs_decpowbuf[24]);
                                   chl_postfix = 'Y';
                                 } else {
                                   uml_arg =  (uml_arg + 500 * unrs_decpowbuf[18]) / (unrs_decpowbuf[21]);
                                   chl_postfix = 'Z';
                                 }
                               } else {
#endif
                                 uml_arg =  (uml_arg + 500 * unrs_decpowbuf[15]) / (unrs_decpowbuf[18]);
                                 chl_postfix = 'E';
#if HL_PRFMAXSO_I > 8
                               }
#endif
                             } else {
                               if (uml_arg >= D_L1000RD * unrs_decpowbuf[12]) {
                                 uml_arg =  (uml_arg + 500 * unrs_decpowbuf[12]) / (unrs_decpowbuf[15]);
                                 chl_postfix = 'P';
                               } else {
                                 uml_arg =  (uml_arg + 500 * unrs_decpowbuf[9]) / (unrs_decpowbuf[12]);
                                 chl_postfix = 'T';
                               }
                             }
                             inl_postfixlen = 1;
                           } else {
#endif
#if HL_PRFMAXSO_I > 2
                             if ((sizeof(unsigned int) > 2) && (uml_arg >= D_L1000RD * unrs_decpowbuf[3])) {
#if HL_PRFMAXSO_I > 4
                               if ((sizeof(unsigned int) > 4) && (uml_arg >= D_L1000RD * unrs_decpowbuf[6])) {
                                 uml_arg =  (uml_arg + 500 * unrs_decpowbuf[6]) / (unrs_decpowbuf[9]);
                                 chl_postfix = 'G';
                               } else {
#endif
                                 uml_arg =  (uml_arg + 500 * unrs_decpowbuf[3]) / (unrs_decpowbuf[6]);
                                 chl_postfix = 'M';
#if HL_PRFMAXSO_I > 4
                               }
#endif
                               inl_postfixlen = 1;
                             } else {
#endif
                               if (uml_arg >= D_L1000RD) {
                                 uml_arg = (uml_arg + 500) / 1000;
                                 chl_postfix = 'k';
                                 inl_postfixlen = 1;
                               }
#if HL_PRFMAXSO_I > 2
                             }
#endif
#if HL_PRFMAXSO_I > 4
                           }
#endif
                         }
                         else {               /* power-of-1024-scaled    */
#if HL_PRFMAXSO_I > 4
                           if ((sizeof(unsigned int) > 4) && (uml_arg>>30 >= D_L1024RD)) {
                             if (
                                 (uml_arg>>50 >= D_L1024RD)
                                ) {
#if HL_PRFMAXSO_I > 8
                               if (
                                   (sizeof(unsigned int) > 8) &&
                                   (uml_arg>>60 >= D_L1024RD)
                                  ) {
                                 if (uml_arg>>70 >= D_L1024RD) {
                                   uml_arg = (uml_arg+((unsigned int)1<<79)) >> 80;
                                   chl_postfix = 'Y';
                                 } else {
                                   uml_arg = (uml_arg+((unsigned int)1<<69)) >> 70;
                                   chl_postfix = 'Z';
                                 }
                               } else {
#endif
                                 uml_arg = (uml_arg+((unsigned int)1<<59)) >> 60;
                                 chl_postfix = 'E';
#if HL_PRFMAXSO_I > 8
                               }
#endif
                             } else {
                               if (uml_arg>>40 >= D_L1024RD) {
                                 uml_arg = (uml_arg+((unsigned int)1<<49)) >> 50;
                                 chl_postfix = 'P';
                               } else {
                                 uml_arg = (uml_arg+((unsigned int)1<<39)) >> 40;
                                 chl_postfix = 'T';
                               }
                             }
                             inl_postfixlen = bol_alternate_form ? 2 : 1;
                           } else {
#endif
#if HL_PRFMAXSO_I > 2
                             if ((sizeof(unsigned int) > 2) && (uml_arg>>10 >= D_L1024RD)) {
#if HL_PRFMAXSO_I > 4
                               if ((sizeof(unsigned int) > 4) && (uml_arg>>20 >= D_L1024RD)) {
                                 uml_arg = (uml_arg+((unsigned int)1<<29)) >> 30;
                                 chl_postfix = 'G';
                               } else {
#endif
                                 uml_arg = (uml_arg+((unsigned int)1<<19)) >> 20;
                                 chl_postfix = 'M';
#if HL_PRFMAXSO_I > 4
                               }
#endif
                               inl_postfixlen = bol_alternate_form ? 2 : 1;
                             } else {
#endif
                               if (uml_arg >= D_L1024RD) {
                                 uml_arg = (uml_arg+0x200) >> 10;
                                 chl_postfix = 'K';
                                 inl_postfixlen = bol_alternate_form ? 2 : 1;
                               }
#if HL_PRFMAXSO_I > 2
                             }
#endif
#if HL_PRFMAXSO_I > 4
                           }
#endif
                         }
                       }

                       /* detect the order of magnitude of X           */
                       inl_emax = 0;
                       if (uml_arg) {
                         int inl_e = ((sizeof(unsigned int)*240824)/100000)+1;
                         do {
                           inl_s = inl_e>>1;
                           if (uml_arg >= unrs_decpowbuf[inl_emax+inl_s]) {
                             inl_emax += inl_s;
                             inl_e -= inl_s;
                           } else {
                             inl_e = inl_s;
                           }
                         } while (inl_e>1);
                         inl_emax ++;
                       }
                       inl_needed = inl_emax + inl_postfixlen;
                       if (inl_dgsp_lc) {   /* use digit group separation */
                         if (inl_emax<=D_DIGGRPLEN) {  /* digit grouping not in effect */
                           inl_dgsp_lc = 0;
                         } else {
                           const int inl_emax_1 = inl_emax-1;
#ifdef HL_USE_DIV
                           dsl_diggrp_dm = div(inl_emax_1, D_DIGGRPLEN);
                           inl_dgsp_ph++;
#else
                           inl_dgsp_tm = (inl_emax_1)/D_DIGGRPLEN;
                           inl_dgsp_ph = (inl_emax_1)%D_DIGGRPLEN+1;
#endif
                           if (inl_needed>=ull_field_width || inl_needed+inl_dgsp_tm*inl_dgsp_lc<=ull_field_width) {
                             inl_s = inl_dgsp_tm*inl_dgsp_lc;
                             inl_needed += inl_s;
                           } else {  /* prefer staying within fieldwidth over using the separator */
                             inl_dgsp_lc = 0;
                           }
                         }
                       }
                       if (!bol_precision) {
                         ull_precision = 1;  /* default precision      */
                         if (bol_padding_zero) {
                           if (ull_field_width>inl_needed && !bol_adjustleft) {
                             /* fake padding with '0' by ull_precision */
                             ull_precision = ull_field_width+(inl_dgsp_lc?inl_emax+inl_s:inl_emax)-inl_needed;
                           }
                         }
                       }
                       if (inl_dgsp_lc) {   /* using digit group separation */
                         inl_precpad = ull_precision-(inl_emax+inl_s);
                         if (inl_precpad>0) {
#ifdef HL_USE_DIV
                           div_t dsl_d = div(inl_dgsp_ph+inl_precpad, D_DIGGRPLEN+inl_dgsp_lc);
                           inl_dgsp_tm += dsl_d.quot;
                           inl_needed += inl_precpad;
                           inl_dgsp_ph = dsl_d.rem;
#else
                           inl_needed += inl_precpad;
                           inl_dgsp_tm += (inl_dgsp_ph+inl_precpad)/(D_DIGGRPLEN+inl_dgsp_lc);
                           inl_dgsp_ph = (inl_dgsp_ph+inl_precpad)%(D_DIGGRPLEN+inl_dgsp_lc);
#endif
                           if (inl_dgsp_ph>D_DIGGRPLEN) {
                             inl_needed -= inl_dgsp_ph-D_DIGGRPLEN;
                             inl_dgsp_ph = D_DIGGRPLEN;
                           }
                           inl_precpad = ull_precision-(inl_emax+inl_dgsp_tm*inl_dgsp_lc);
                         } else {
                           inl_precpad=0;
                         }
                       } else {    /* not using digit group separation */
                         inl_precpad = ull_precision-inl_emax;
                         if (inl_precpad>0) {
                           inl_needed += inl_precpad;
                         } else {
                           inl_precpad=0;
                         }
                       }
                       if (ull_field_width > inl_needed) {
                         awcl_after = awcl_cur+ull_field_width;
                         inl_padsp = ull_field_width-inl_needed;
                         if (!bol_adjustleft) {  /* padding left with spaces */
                           if (inl_padsp > awcl_end-awcl_cur)
                             {awcl_after = awcl_cur; break;}  /* overflow */
                           do
                             *awcl_cur++ = HL_WCHAR_CAST(' ');
                           while (--inl_padsp);
                         }
                       } else {
                         awcl_after = awcl_cur+inl_needed;
                         inl_padsp = 0;
                       }
                       if (inl_dgsp_lc) {   /* set digit group separators */
                         /* produce the first separator                                     */
                         awcl_dg = awcl_cur+inl_dgsp_ph;
                         if (iel_cs_target == ied_chs_utf_16) {  /* natural endian */
                           inl_dgsp_lo = m_u16l_from_u8l(awcl_dg, awcl_end-awcl_dg, achl_dgsp, inl_dgsp_lb);
                         } else {           /* swapped endian          */
                           inl_dgsp_lo = m_u16r_from_u8l(awcl_dg, 1+awcl_end-awcl_dg, achl_dgsp, inl_dgsp_lb);
                         }
                         /* now the complete physical output length can be determined      */
                         inl_s = inl_dgsp_tm*(inl_dgsp_lo-inl_dgsp_lc);  /* adjustment from logical to physical */
                         awcl_after += inl_s;
                         if (inl_dgsp_lo<0 || awcl_after-awcl_cur>awcl_end-awcl_cur)
                           {awcl_after = awcl_cur; break;}  /* overflow */
                         /* copy the other separators from the first one                   */
                         inl_s = inl_dgsp_tm-1;
                         if (inl_s) {
                           awcl0 = awcl_dg+inl_dgsp_lo;
                           do {
                             awcl0 += D_DIGGRPLEN;
                             int inl2 = 0;
                             do
                               *awcl0++ = awcl_dg[inl2++];
                             while (inl2<inl_dgsp_lo);
                           } while (--inl_s);
                         }
                         /* padding left with zeroes to "precision"                        */
                         while (inl_precpad) {
                           if (inl_dgsp_ph == 0) {  /* skip digits-separator */
                             awcl_cur += inl_dgsp_lo;
                             inl_dgsp_ph = D_DIGGRPLEN-1;
                             inl_dgsp_tm--;
                             if (!inl_dgsp_tm)
                               break;
                           } else {
                             inl_dgsp_ph--;
                           }
                           *awcl_cur++ = HL_WCHAR_CAST('0');
                           inl_precpad --;
                         }
                       } else {             /* not using digit group separation */
                         if (awcl_after-awcl_cur>awcl_end-awcl_cur)
                           {awcl_after = awcl_cur; break;}  /* overflow */
                         /* padding left with zeroes to "precision"    */
                         while (inl_precpad) {
                           *awcl_cur++ = HL_WCHAR_CAST('0');
                           inl_precpad --;
                         }
                       }
                       /* postfix                                      */
                       if (inl_postfixlen) {
                         if (inl_postfixlen==2) {
                           *(awcl_after-(inl_padsp+2)) = HL_WCHAR_CAST(chl_postfix);
                           *(awcl_after-(inl_padsp+1)) = HL_WCHAR_CAST('i');
                         } else {
                           *(awcl_after-(inl_padsp+1)) = HL_WCHAR_CAST(chl_postfix);
                         }
                       }
                       /* padding right with spaces                    */
                       if (inl_padsp) {
                         awcl0 = awcl_after-1;
                         do
                           *awcl0-- = HL_WCHAR_CAST(' ');
                         while (--inl_padsp);
                       }
                       /* produce the digits                           */
                       if (inl_emax > 0) {
#ifdef HL_USE_DIV
                         if (sizeof(unsigned int)<=sizeof(int)) {
                           div_t dsl_d;
                           dsl_d.quot = uml_arg/(unsigned int)DECBASE;
                           dsl_d.rem = uml_arg%(unsigned int)DECBASE;
                           if (inl_dgsp_lc) {  /* using digit group separation */
                             awcl_cur += inl_emax+inl_dgsp_tm*inl_dgsp_lo-1;
                             if (inl_dgsp_tm) {  /* write all digit groups that follow a separator */
                               inl_s=D_DIGGRPLEN;
                               while (TRUE) {
                                 do {
                                   *(awcl_cur)-- = HL_WCHAR_CAST('0'+dsl_d.rem);
                                   dsl_d = div(dsl_d.quot,DECBASE);
                                 } while (--inl_s);
                                 awcl_cur -= inl_dgsp_lo;  /* skip digits-separator */
                                 if (--inl_dgsp_tm==0)
                                   break;
                                 inl_s=D_DIGGRPLEN;
                               }
                             }
                             if (inl_dgsp_ph) {  /* precision may provoke leading separator */
                               while (TRUE) {   /* write leading (maybe partial) digit group */
                                 *awcl_cur = HL_WCHAR_CAST('0'+dsl_d.rem);
                                 if (--inl_dgsp_ph == 0) break;
                                 awcl_cur--;
                                 dsl_d = div(dsl_d.quot,DECBASE);
                               }
                             }
                           } else {  /* not using digit group separation */
                             while (TRUE) {
                               *(awcl_cur + --inl_emax) = HL_WCHAR_CAST('0'+dsl_d.rem);
                               if (inl_emax <= 0) break;
                               dsl_d = div(dsl_d.quot,DECBASE);
                             }
                           }
#ifdef HL_USE_LDIV
                         } else if (sizeof(unsigned int)<=sizeof(long int)) {
                           ldiv_t dsl_d;
                           dsl_d.quot = uml_arg/(unsigned int)DECBASE;
                           dsl_d.rem = uml_arg%(unsigned int)DECBASE;
                           if (inl_dgsp_lc) {  /* using digit group separation */
                             awcl_cur += inl_emax+inl_dgsp_tm*inl_dgsp_lo-1;
                             if (inl_dgsp_tm) {  /* write all digit groups that follow a separator */
                               inl_s=D_DIGGRPLEN;
                               while (TRUE) {
                                 do {
                                   *(awcl_cur)-- = HL_WCHAR_CAST('0'+dsl_d.rem);
                                   dsl_d = ldiv(dsl_d.quot,DECBASE);
                                 } while (--inl_s);
                                 awcl_cur -= inl_dgsp_lo;  /* skip digits-separator */
                                 if (--inl_dgsp_tm==0)
                                   break;
                                 inl_s=D_DIGGRPLEN;
                               }
                             }
                             if (inl_dgsp_ph) {  /* precision may provoke leading separator */
                               while (TRUE) {   /* write leading (maybe partial) digit group */
                                 *awcl_cur = HL_WCHAR_CAST('0'+dsl_d.rem);
                                 if (--inl_dgsp_ph == 0) break;
                                 awcl_cur--;
                                 dsl_d = ldiv(dsl_d.quot,DECBASE);
                               }
                             }
                           } else {  /* not using digit group separation */
                             while (TRUE) {
                               *(awcl_cur + --inl_emax) = HL_WCHAR_CAST('0'+dsl_d.rem);
                               if (inl_emax <= 0) break;
                               dsl_d = ldiv(dsl_d.quot,DECBASE);
                             }
                           }
#endif
#ifdef HL_USE_LLDIV
                         } else if (sizeof(unsigned int)<=sizeof(long long int)) {
                           lldiv_t dsl_d;
                           dsl_d.quot = uml_arg/(unsigned int)DECBASE;
                           dsl_d.rem = uml_arg%(unsigned int)DECBASE;
                           if (inl_dgsp_lc) {  /* using digit group separation */
                             awcl_cur += inl_emax+inl_dgsp_tm*inl_dgsp_lo-1;
                             if (inl_dgsp_tm) {  /* write all digit groups that follow a separator */
                               inl_s=D_DIGGRPLEN;
                               while (TRUE) {
                                 do {
                                   *(awcl_cur)-- = HL_WCHAR_CAST('0'+dsl_d.rem);
                                   dsl_d = lldiv(dsl_d.quot,DECBASE);
                                 } while (--inl_s);
                                 awcl_cur -= inl_dgsp_lo;  /* skip digits-separator */
                                 if (--inl_dgsp_tm==0)
                                   break;
                                 inl_s=D_DIGGRPLEN;
                               }
                             }
                             if (inl_dgsp_ph) {  /* precision may provoke leading separator */
                               while (TRUE) {   /* write leading (maybe partial) digit group */
                                 *awcl_cur = HL_WCHAR_CAST('0'+dsl_d.rem);
                                 if (--inl_dgsp_ph == 0) break;
                                 awcl_cur--;
                                 dsl_d = lldiv(dsl_d.quot,DECBASE);
                               }
                             }
                           } else {  /* not using digit group separation */
                             while (TRUE) {
                               *(awcl_cur + --inl_emax) = HL_WCHAR_CAST('0'+dsl_d.rem);
                               if (inl_emax <= 0) break;
                               dsl_d = lldiv(dsl_d.quot,DECBASE);
                             }
                           }
#endif
                         } else {
#endif
                           if (inl_dgsp_lc) {  /* using digit group separation */
                             awcl_cur += inl_emax+inl_dgsp_tm*inl_dgsp_lo-1;
                             if (inl_dgsp_tm) {  /* write all digit groups that follow a separator */
                               inl_s=D_DIGGRPLEN;
                               while (TRUE) {
                                 do {
                                   *(awcl_cur)-- = HL_WCHAR_CAST('0'+uml_arg%(unsigned int)DECBASE);
                                   uml_arg/=(unsigned int)DECBASE;
                                 } while (--inl_s);
                                 awcl_cur -= inl_dgsp_lo;  /* skip digits-separator */
                                 if (--inl_dgsp_tm==0)
                                   break;
                                 inl_s=D_DIGGRPLEN;
                               }
                             }
                             if (inl_dgsp_ph) {  /* precision may provoke leading separator */
                               while (TRUE) {   /* write leading (maybe partial) digit group */
                                 *awcl_cur = HL_WCHAR_CAST('0'+uml_arg%(unsigned int)DECBASE);
                                 if (--inl_dgsp_ph == 0) break;
                                 awcl_cur--;
                                 uml_arg/=(unsigned int)DECBASE;
                               }
                             }
                           } else {  /* not using digit group separation */
                             while (--inl_emax > 0) {
                               *(awcl_cur+inl_emax) = HL_WCHAR_CAST('0'+uml_arg%(unsigned int)DECBASE);
                               uml_arg/=(unsigned int)DECBASE;
                             }
                             *awcl_cur = HL_WCHAR_CAST('0'+uml_arg);
                           }
#ifdef HL_USE_DIV
                         }
#endif
                         awcl_cur += inl_emax;
                       }
                     break;
                   case 'O':
                       inl_emax = 0;
                       achl_digits = chl_spec&'\040' ? chrstrans_lc : chrstrans;  /* choose upper- or lowercase */
                       if (uml_arg!=0) {
                         int inl_e = (sizeof(unsigned int)<<3)/3;
                         if (inl_e*3 < sizeof(unsigned int)<<3)
                           inl_e++;
                         do {
                           inl_s = inl_e>>1;
                           if (uml_arg >= (unsigned int)1<<((inl_emax+inl_s)*3)) {
                             inl_emax += inl_s;
                             inl_e -= inl_s;
                           } else {
                             inl_e = inl_s;
                           }
                         } while (inl_e>1);
                         inl_emax ++;
                         /* now inl_emax is number of digits needed    */
                       }
                       inl_needed = inl_emax + inl_postfixlen;
                       if (inl_dgsp_lc) {   /* use digit group separation */
                         if (inl_emax<=D_DIGGRPLEN) {  /* digit grouping not in effect */
                           inl_dgsp_lc = 0;
                         } else {
                           const int inl_emax_1 = inl_emax-1;
#ifdef HL_USE_DIV
                           dsl_diggrp_dm = div(inl_emax_1, D_DIGGRPLEN);
                           inl_dgsp_ph++;
#else
                           inl_dgsp_tm = (inl_emax_1)/D_DIGGRPLEN;
                           inl_dgsp_ph = (inl_emax_1)%D_DIGGRPLEN+1;
#endif
                           if (inl_needed>=ull_field_width || inl_needed+inl_dgsp_tm*inl_dgsp_lc<=ull_field_width) {
                             inl_s = inl_dgsp_tm*inl_dgsp_lc;
                             inl_needed += inl_s;
                           } else {  /* prefer staying within fieldwidth over using the separator */
                             inl_dgsp_lc = 0;
                           }
                         }
                       }
                       if (!bol_precision) {
                         ull_precision = 1;  /* default precision      */
                         if (bol_padding_zero) {
                           if (ull_field_width>inl_needed && !bol_adjustleft) {
                             /* fake padding with '0' by ull_precision */
                             ull_precision = ull_field_width+(inl_dgsp_lc?inl_emax+inl_s:inl_emax)-inl_needed;
                           } else {
                             bol_padding_zero = false;  /* according to spec, zeroflag is ignored in
                                               integer conversion if left-justify-flag is present */
                           }
                         }
                       } else {
                         bol_padding_zero = false;  /* according to spec, zeroflag is ignored in
                                                       integer conversion if a precision is given */
                       }
                       if (inl_dgsp_lc) {   /* using digit group separation */
                         inl_precpad = ull_precision-(inl_emax+inl_s);
                         if (inl_precpad>0) {
#ifdef HL_USE_DIV
                           div_t dsl_d = div(inl_dgsp_ph+inl_precpad, D_DIGGRPLEN+inl_dgsp_lc);
                           inl_dgsp_tm += dsl_d.quot;
                           inl_needed += inl_precpad;
                           inl_dgsp_ph = dsl_d.rem;
#else
                           inl_needed += inl_precpad;
                           inl_dgsp_tm += (inl_dgsp_ph+inl_precpad)/(D_DIGGRPLEN+inl_dgsp_lc);
                           inl_dgsp_ph = (inl_dgsp_ph+inl_precpad)%(D_DIGGRPLEN+inl_dgsp_lc);
#endif
                           if (inl_dgsp_ph>D_DIGGRPLEN) {
                            if (bol_alternate_form && (uml_arg!=0) &&
                                !(bol_padding_zero && (ull_precision>inl_emax+inl_dgsp_tm*D_DIGGRPLEN)))
                            {               /* ensure octal prefix     */
                             inl_dgsp_tm++;
                             ull_precision += 1+inl_dgsp_lc+D_DIGGRPLEN-inl_dgsp_ph;
                             inl_needed += 1+inl_dgsp_lc+D_DIGGRPLEN-inl_dgsp_ph;
                             inl_dgsp_ph = 1;
                            } else {
                             inl_needed -= inl_dgsp_ph-D_DIGGRPLEN;
                             inl_dgsp_ph = D_DIGGRPLEN;
                            }
                           } else if (bol_alternate_form && (inl_dgsp_ph==0) && (uml_arg!=0)) {
                             if (bol_padding_zero && (ull_precision-inl_dgsp_lc>inl_emax+(inl_dgsp_tm-1)*D_DIGGRPLEN)) {
                               /* prefer staying within fieldwidth over avoiding all spacepadding */
                               inl_dgsp_tm--;
                               ull_precision -= inl_dgsp_lc;
                               inl_needed -= inl_dgsp_lc;
                               inl_dgsp_ph = D_DIGGRPLEN;
                             } else {
                               ull_precision++;
                               inl_needed++;
                               inl_dgsp_ph=1;
                             }
                           }
                           inl_precpad = ull_precision-(inl_emax+inl_dgsp_tm*inl_dgsp_lc);
                         } else {
                          if (bol_alternate_form && (uml_arg!=0)) {  /* ensure octal prefix */
                            if (inl_dgsp_ph>=D_DIGGRPLEN) {
                              inl_dgsp_tm++;
                              ull_precision += 1+inl_dgsp_lc+D_DIGGRPLEN-inl_dgsp_ph;
                              inl_needed += 1+inl_dgsp_lc+D_DIGGRPLEN-inl_dgsp_ph;
                              inl_dgsp_ph = 1;
                            } else {
                              ull_precision++;
                              inl_needed++;
                              inl_dgsp_ph++;
                            }
                            inl_precpad++;
                          } else {
                           inl_precpad=0;
                          }
                         }
                       } else {    /* not using digit group separation */
                         if (bol_alternate_form && (uml_arg!=0) && (ull_precision<=inl_emax))
                           ull_precision = inl_emax+1;  /* cause octal prefix */
                         inl_precpad = ull_precision-inl_emax;
                         if (inl_precpad>0) {
                           inl_needed += inl_precpad;
                         } else {
                           inl_precpad=0;
                         }
                       }
                       if (ull_field_width > inl_needed) {
                         awcl_after = awcl_cur+ull_field_width;
                         inl_padsp = ull_field_width-inl_needed;
                         if (!bol_adjustleft) {  /* padding left with spaces */
                           if (inl_padsp > awcl_end-awcl_cur)
                             {awcl_after = awcl_cur; break;}  /* overflow */
                           do
                             *awcl_cur++ = HL_WCHAR_CAST(' ');
                           while (--inl_padsp);
                         }
                       } else {
                         awcl_after = awcl_cur+inl_needed;
                         inl_padsp = 0;
                       }
                       if (inl_dgsp_lc) {   /* set digit group separators */
                         /* produce the first separator                                     */
                         awcl_dg = awcl_cur+inl_dgsp_ph;
                         if (iel_cs_target == ied_chs_utf_16) {  /* natural endian */
                           inl_dgsp_lo = m_u16l_from_u8l(awcl_dg, awcl_end-awcl_dg, achl_dgsp, inl_dgsp_lb);
                         } else {           /* swapped endian          */
                           inl_dgsp_lo = m_u16r_from_u8l(awcl_dg, 1+awcl_end-awcl_dg, achl_dgsp, inl_dgsp_lb);
                         }
                         /* now the complete physical output length can be determined      */
                         inl_s = inl_dgsp_tm*(inl_dgsp_lo-inl_dgsp_lc);  /* adjustment from logical to physical */
                         awcl_after += inl_s;
                         if (inl_dgsp_lo<0 || awcl_after-awcl_cur>awcl_end-awcl_cur)
                           {awcl_after = awcl_cur; break;}  /* overflow */
                         /* copy the other separators from the first one                   */
                         inl_s = inl_dgsp_tm-1;
                         if (inl_s) {
                           awcl0 = awcl_dg+inl_dgsp_lo;
                           do {
                             awcl0 += D_DIGGRPLEN;
                             int inl2 = 0;
                             do
                               *awcl0++ = awcl_dg[inl2++];
                             while (inl2<inl_dgsp_lo);
                           } while (--inl_s);
                         }
                         /* padding left with zeroes to "precision"                        */
                         while (inl_precpad) {
                           if (inl_dgsp_ph == 0) {  /* skip digits-separator */
                             awcl_cur += inl_dgsp_lo;
                             inl_dgsp_ph = D_DIGGRPLEN-1;
                             inl_dgsp_tm--;
                             if (!inl_dgsp_tm)
                               break;
                           } else {
                             inl_dgsp_ph--;
                           }
                           *awcl_cur++ = HL_WCHAR_CAST('0');
                           inl_precpad --;
                         }
                       } else {             /* not using digit group separation */
                         if (awcl_after-awcl_cur>awcl_end-awcl_cur)
                           {awcl_after = awcl_cur; break;}  /* overflow */
                         /* padding left with zeroes to "precision"    */
                         while (inl_precpad) {
                           *awcl_cur++ = HL_WCHAR_CAST('0');
                           inl_precpad --;
                         }
                       }
                       /* postfix                                      */
                       if (inl_postfixlen) {
                         if (inl_postfixlen==2) {
                           *(awcl_after-(inl_padsp+2)) = HL_WCHAR_CAST(chl_postfix);
                           *(awcl_after-(inl_padsp+1)) = HL_WCHAR_CAST('i');
                         } else {
                           *(awcl_after-(inl_padsp+1)) = HL_WCHAR_CAST(chl_postfix);
                         }
                       }
                       /* padding right with spaces                    */
                       if (inl_padsp) {
                         awcl0 = awcl_after-1;
                         do
                           *awcl0-- = HL_WCHAR_CAST(' ');
                         while (--inl_padsp);
                       }
                       if (inl_emax!=0) {  /* done if zero-"precision" zero */
                         inl_emax --;
                         inl_emax *= 3;
                         if (inl_dgsp_lc) {  /* using digit group separation */
                           while (TRUE) {
                             while (inl_dgsp_ph) {
                               *(awcl_cur)++ = HL_WCHAR_CAST(achl_digits[(uml_arg>>inl_emax) & (1<<3)-1]);
                               inl_dgsp_ph--;
                               inl_emax -= 3;
                             }
                             inl_dgsp_tm--;
                             if (!inl_dgsp_tm)
                               break;       /* all digitgroups done    */
                             awcl_cur += inl_dgsp_lo;  /* skip digits-separator */
                             inl_dgsp_ph = D_DIGGRPLEN-1;
                           }
                         } else {  /* not using digit group separation */
                           while(TRUE) {
                             *(awcl_cur) = HL_WCHAR_CAST(achl_digits[(uml_arg>>inl_emax) & (1<<3)-1]);
                             if (inl_emax==0)
                               break;
                             (awcl_cur)++;
                             inl_emax -= 3;
                           }
                         }
                       }
                     break;
                   case 'X':
                       inl_emax = 0;
                       achl_digits = chl_spec&'\040' ? chrstrans_lc : chrstrans;  /* choose upper- or lowercase */
                       if (uml_arg!=0) {
                         int inl_e = (sizeof(unsigned int)<<3)/4;
                         if (inl_e*4 < sizeof(unsigned int)<<3)
                           inl_e++;
                         do {
                           inl_s = inl_e>>1;
                           if (uml_arg >= (unsigned int)1<<((inl_emax+inl_s)*4)) {
                             inl_emax += inl_s;
                             inl_e -= inl_s;
                           } else {
                             inl_e = inl_s;
                           }
                         } while (inl_e>1);
                         inl_emax ++;
                         /* now inl_emax is number of digits needed    */
                       }
                       inl_needed = inl_emax + inl_postfixlen;
                       if (bol_alternate_form && (uml_arg!=0))
                         inl_needed += 2;   /* for hex prefix          */
                       if (inl_dgsp_lc) {   /* use digit group separation */
                         if (inl_emax<=D_DIGGRPLEN) {  /* digit grouping not in effect */
                           inl_dgsp_lc = 0;
                         } else {
                           const int inl_emax_1 = inl_emax-1;
#ifdef HL_USE_DIV
                           dsl_diggrp_dm = div(inl_emax_1, D_DIGGRPLEN);
                           inl_dgsp_ph++;
#else
                           inl_dgsp_tm = (inl_emax_1)/D_DIGGRPLEN;
                           inl_dgsp_ph = (inl_emax_1)%D_DIGGRPLEN+1;
#endif
                           if (inl_needed>=ull_field_width || inl_needed+inl_dgsp_tm*inl_dgsp_lc<=ull_field_width) {
                             inl_s = inl_dgsp_tm*inl_dgsp_lc;
                             inl_needed += inl_s;
                           } else {  /* prefer staying within fieldwidth over using the separator */
                             inl_dgsp_lc = 0;
                           }
                         }
                       }
                       if (!bol_precision) {
                         ull_precision = 1;  /* default precision      */
                         if (bol_padding_zero) {
                           if (ull_field_width>inl_needed && !bol_adjustleft) {
                             /* fake padding with '0' by ull_precision */
                             ull_precision = ull_field_width+(inl_dgsp_lc?inl_emax+inl_s:inl_emax)-inl_needed;
                           }
                         }
                       }
                       if (inl_dgsp_lc) {   /* using digit group separation */
                         inl_precpad = ull_precision-(inl_emax+inl_s);
                         if (inl_precpad>0) {
#ifdef HL_USE_DIV
                           div_t dsl_d = div(inl_dgsp_ph+inl_precpad, D_DIGGRPLEN+inl_dgsp_lc);
                           inl_dgsp_tm += dsl_d.quot;
                           inl_needed += inl_precpad;
                           inl_dgsp_ph = dsl_d.rem;
#else
                           inl_needed += inl_precpad;
                           inl_dgsp_tm += (inl_dgsp_ph+inl_precpad)/(D_DIGGRPLEN+inl_dgsp_lc);
                           inl_dgsp_ph = (inl_dgsp_ph+inl_precpad)%(D_DIGGRPLEN+inl_dgsp_lc);
#endif
                           if (inl_dgsp_ph>D_DIGGRPLEN) {
                             inl_needed -= inl_dgsp_ph-D_DIGGRPLEN;
                             inl_dgsp_ph = D_DIGGRPLEN;
                           }
                           inl_precpad = ull_precision-(inl_emax+inl_dgsp_tm*inl_dgsp_lc);
                         } else {
                           inl_precpad=0;
                         }
                       } else {    /* not using digit group separation */
                         inl_precpad = ull_precision-inl_emax;
                         if (inl_precpad>0) {
                           inl_needed += inl_precpad;
                         } else {
                           inl_precpad=0;
                         }
                       }
                       if (ull_field_width > inl_needed) {
                         awcl_after = awcl_cur+ull_field_width;
                         inl_padsp = ull_field_width-inl_needed;
                         if (!bol_adjustleft) {  /* padding left with spaces */
                           if (inl_padsp > awcl_end-awcl_cur)
                             {awcl_after = awcl_cur; break;}  /* overflow */
                           do
                             *awcl_cur++ = HL_WCHAR_CAST(' ');
                           while (--inl_padsp);
                         }
                       } else {
                         awcl_after = awcl_cur+inl_needed;
                         inl_padsp = 0;
                       }
                       if (inl_dgsp_lc) {   /* set digit group separators */
                         if (bol_alternate_form && (uml_arg!=0)) {  /* write hex prefix    */
                           if (2 > awcl_end-awcl_cur)
                             {awcl_after = awcl_cur; break;}  /* overflow */
                           *awcl_cur++ = HL_WCHAR_CAST('0');
                           *awcl_cur++ = HL_WCHAR_CAST('X'|(chl_spec&'\040'));
                         }
                         /* produce the first separator                                     */
                         awcl_dg = awcl_cur+inl_dgsp_ph;
                         if (iel_cs_target == ied_chs_utf_16) {  /* natural endian */
                           inl_dgsp_lo = m_u16l_from_u8l(awcl_dg, awcl_end-awcl_dg, achl_dgsp, inl_dgsp_lb);
                         } else {           /* swapped endian          */
                           inl_dgsp_lo = m_u16r_from_u8l(awcl_dg, 1+awcl_end-awcl_dg, achl_dgsp, inl_dgsp_lb);
                         }
                         /* now the complete physical output length can be determined      */
                         inl_s = inl_dgsp_tm*(inl_dgsp_lo-inl_dgsp_lc);  /* adjustment from logical to physical */
                         awcl_after += inl_s;
                         if (inl_dgsp_lo<0 || awcl_after-awcl_cur>awcl_end-awcl_cur)
                           {awcl_after = awcl_cur; break;}  /* overflow */
                         /* copy the other separators from the first one                   */
                         inl_s = inl_dgsp_tm-1;
                         if (inl_s) {
                           awcl0 = awcl_dg+inl_dgsp_lo;
                           do {
                             awcl0 += D_DIGGRPLEN;
                             int inl2 = 0;
                             do
                               *awcl0++ = awcl_dg[inl2++];
                             while (inl2<inl_dgsp_lo);
                           } while (--inl_s);
                         }
                         /* padding left with zeroes to "precision"                        */
                         while (inl_precpad) {
                           if (inl_dgsp_ph == 0) {  /* skip digits-separator */
                             awcl_cur += inl_dgsp_lo;
                             inl_dgsp_ph = D_DIGGRPLEN-1;
                             inl_dgsp_tm--;
                             if (!inl_dgsp_tm)
                               break;
                           } else {
                             inl_dgsp_ph--;
                           }
                           *awcl_cur++ = HL_WCHAR_CAST('0');
                           inl_precpad --;
                         }
                       } else {             /* not using digit group separation */
                         if (awcl_after-awcl_cur>awcl_end-awcl_cur)
                           {awcl_after = awcl_cur; break;}  /* overflow */
                         if (bol_alternate_form && (uml_arg!=0)) {  /* write hex prefix */
                           *awcl_cur++ = HL_WCHAR_CAST('0');
                           *awcl_cur++ = HL_WCHAR_CAST('X'|(chl_spec&'\040'));
                         }
                         /* padding left with zeroes to "precision"    */
                         while (inl_precpad) {
                           *awcl_cur++ = HL_WCHAR_CAST('0');
                           inl_precpad --;
                         }
                       }
                       /* postfix                                      */
                       if (inl_postfixlen) {
                         if (inl_postfixlen==2) {
                           *(awcl_after-(inl_padsp+2)) = HL_WCHAR_CAST(chl_postfix);
                           *(awcl_after-(inl_padsp+1)) = HL_WCHAR_CAST('i');
                         } else {
                           *(awcl_after-(inl_padsp+1)) = HL_WCHAR_CAST(chl_postfix);
                         }
                       }
                       /* padding right with spaces                    */
                       if (inl_padsp) {
                         awcl0 = awcl_after-1;
                         do
                           *awcl0-- = HL_WCHAR_CAST(' ');
                         while (--inl_padsp);
                       }
                       if (inl_emax!=0) {  /* done if zero-"precision" zero */
                         inl_emax --;
                         inl_emax *= 4;
                         if (inl_dgsp_lc) {  /* using digit group separation */
                           while (TRUE) {
                             while (inl_dgsp_ph) {
                               *(awcl_cur)++ = HL_WCHAR_CAST(achl_digits[(uml_arg>>inl_emax) & (1<<4)-1]);
                               inl_dgsp_ph--;
                               inl_emax -= 4;
                             }
                             inl_dgsp_tm--;
                             if (!inl_dgsp_tm)
                               break;       /* all digitgroups done    */
                             awcl_cur += inl_dgsp_lo;  /* skip digits-separator */
                             inl_dgsp_ph = D_DIGGRPLEN-1;
                           }
                         } else {  /* not using digit group separation */
                           while(TRUE) {
                             *(awcl_cur) = HL_WCHAR_CAST(achl_digits[(uml_arg>>inl_emax) & (1<<4)-1]);
                             if (inl_emax==0)
                               break;
                             (awcl_cur)++;
                             inl_emax -= 4;
                           }
                         }
                       }
                     break;
                 }
                 break;
               case 'l': case 'L':
                 if(bol_longlong){
                   ull_arg = va_arg(dsl_list, HL_ULONGLONG);
                   switch (chl_spec&0xDF) {
                     case 'U':

                       /* prepare %(sci-dec)- or %(sci-dec)-type of rendering */
                       if (iel_scaling!=ied_scaling_none) {
                         if (iel_scaling == ied_scaling_1000) {  /* power-of-1000-scaled */
#if HL_PRFMAXSO_LL > 4
                           if ((sizeof(HL_ULONGLONG) > 4) && (ull_arg >= D_L1000RD * ullrs_decpowbuf[9])) {
                             if (
                                 (ull_arg >= D_L1000RD * ullrs_decpowbuf[15])
                                ) {
#if HL_PRFMAXSO_LL > 8
                               if (
                                   (sizeof(HL_ULONGLONG) > 8) &&
                                   (ull_arg >= D_L1000RD * ullrs_decpowbuf[18])
                                  ) {
                                 if (ull_arg >= D_L1000RD * ullrs_decpowbuf[21]) {
                                   ull_arg =  (ull_arg + 500 * ullrs_decpowbuf[21]) / (ullrs_decpowbuf[24]);
                                   chl_postfix = 'Y';
                                 } else {
                                   ull_arg =  (ull_arg + 500 * ullrs_decpowbuf[18]) / (ullrs_decpowbuf[21]);
                                   chl_postfix = 'Z';
                                 }
                               } else {
#endif
                                 ull_arg =  (ull_arg + 500 * ullrs_decpowbuf[15]) / (ullrs_decpowbuf[18]);
                                 chl_postfix = 'E';
#if HL_PRFMAXSO_LL > 8
                               }
#endif
                             } else {
                               if (ull_arg >= D_L1000RD * ullrs_decpowbuf[12]) {
                                 ull_arg =  (ull_arg + 500 * ullrs_decpowbuf[12]) / (ullrs_decpowbuf[15]);
                                 chl_postfix = 'P';
                               } else {
                                 ull_arg =  (ull_arg + 500 * ullrs_decpowbuf[9]) / (ullrs_decpowbuf[12]);
                                 chl_postfix = 'T';
                               }
                             }
                             inl_postfixlen = 1;
                           } else {
#endif
#if HL_PRFMAXSO_LL > 2
                             if ((sizeof(HL_ULONGLONG) > 2) && (ull_arg >= D_L1000RD * ullrs_decpowbuf[3])) {
#if HL_PRFMAXSO_LL > 4
                               if ((sizeof(HL_ULONGLONG) > 4) && (ull_arg >= D_L1000RD * ullrs_decpowbuf[6])) {
                                 ull_arg =  (ull_arg + 500 * ullrs_decpowbuf[6]) / (ullrs_decpowbuf[9]);
                                 chl_postfix = 'G';
                               } else {
#endif
                                 ull_arg =  (ull_arg + 500 * ullrs_decpowbuf[3]) / (ullrs_decpowbuf[6]);
                                 chl_postfix = 'M';
#if HL_PRFMAXSO_LL > 4
                               }
#endif
                               inl_postfixlen = 1;
                             } else {
#endif
                               if (ull_arg >= D_L1000RD) {
                                 ull_arg = (ull_arg + 500) / 1000;
                                 chl_postfix = 'k';
                                 inl_postfixlen = 1;
                               }
#if HL_PRFMAXSO_LL > 2
                             }
#endif
#if HL_PRFMAXSO_LL > 4
                           }
#endif
                         }
                         else {               /* power-of-1024-scaled    */
#if HL_PRFMAXSO_LL > 4
                           if ((sizeof(HL_ULONGLONG) > 4) && (ull_arg>>30 >= D_L1024RD)) {
                             if (
                                 (ull_arg>>50 >= D_L1024RD)
                                ) {
#if HL_PRFMAXSO_LL > 8
                               if (
                                   (sizeof(HL_ULONGLONG) > 8) &&
                                   (ull_arg>>60 >= D_L1024RD)
                                  ) {
                                 if (ull_arg>>70 >= D_L1024RD) {
                                   ull_arg = (ull_arg+((HL_ULONGLONG)1<<79)) >> 80;
                                   chl_postfix = 'Y';
                                 } else {
                                   ull_arg = (ull_arg+((HL_ULONGLONG)1<<69)) >> 70;
                                   chl_postfix = 'Z';
                                 }
                               } else {
#endif
                                 ull_arg = (ull_arg+((HL_ULONGLONG)1<<59)) >> 60;
                                 chl_postfix = 'E';
#if HL_PRFMAXSO_LL > 8
                               }
#endif
                             } else {
                               if (ull_arg>>40 >= D_L1024RD) {
                                 ull_arg = (ull_arg+((HL_ULONGLONG)1<<49)) >> 50;
                                 chl_postfix = 'P';
                               } else {
                                 ull_arg = (ull_arg+((HL_ULONGLONG)1<<39)) >> 40;
                                 chl_postfix = 'T';
                               }
                             }
                             inl_postfixlen = bol_alternate_form ? 2 : 1;
                           } else {
#endif
#if HL_PRFMAXSO_LL > 2
                             if ((sizeof(HL_ULONGLONG) > 2) && (ull_arg>>10 >= D_L1024RD)) {
#if HL_PRFMAXSO_LL > 4
                               if ((sizeof(HL_ULONGLONG) > 4) && (ull_arg>>20 >= D_L1024RD)) {
                                 ull_arg = (ull_arg+((HL_ULONGLONG)1<<29)) >> 30;
                                 chl_postfix = 'G';
                               } else {
#endif
                                 ull_arg = (ull_arg+((HL_ULONGLONG)1<<19)) >> 20;
                                 chl_postfix = 'M';
#if HL_PRFMAXSO_LL > 4
                               }
#endif
                               inl_postfixlen = bol_alternate_form ? 2 : 1;
                             } else {
#endif
                               if (ull_arg >= D_L1024RD) {
                                 ull_arg = (ull_arg+0x200) >> 10;
                                 chl_postfix = 'K';
                                 inl_postfixlen = bol_alternate_form ? 2 : 1;
                               }
#if HL_PRFMAXSO_LL > 2
                             }
#endif
#if HL_PRFMAXSO_LL > 4
                           }
#endif
                         }
                       }

                       /* detect the order of magnitude of X           */
                       inl_emax = 0;
                       if (ull_arg) {
                         int inl_e = ((sizeof(HL_ULONGLONG)*240824)/100000)+1;
                         do {
                           inl_s = inl_e>>1;
                           if (ull_arg >= ullrs_decpowbuf[inl_emax+inl_s]) {
                             inl_emax += inl_s;
                             inl_e -= inl_s;
                           } else {
                             inl_e = inl_s;
                           }
                         } while (inl_e>1);
                         inl_emax ++;
                       }
                       inl_needed = inl_emax + inl_postfixlen;
                       if (inl_dgsp_lc) {   /* use digit group separation */
                         if (inl_emax<=D_DIGGRPLEN) {  /* digit grouping not in effect */
                           inl_dgsp_lc = 0;
                         } else {
                           const int inl_emax_1 = inl_emax-1;
#ifdef HL_USE_DIV
                           dsl_diggrp_dm = div(inl_emax_1, D_DIGGRPLEN);
                           inl_dgsp_ph++;
#else
                           inl_dgsp_tm = (inl_emax_1)/D_DIGGRPLEN;
                           inl_dgsp_ph = (inl_emax_1)%D_DIGGRPLEN+1;
#endif
                           if (inl_needed>=ull_field_width || inl_needed+inl_dgsp_tm*inl_dgsp_lc<=ull_field_width) {
                             inl_s = inl_dgsp_tm*inl_dgsp_lc;
                             inl_needed += inl_s;
                           } else {  /* prefer staying within fieldwidth over using the separator */
                             inl_dgsp_lc = 0;
                           }
                         }
                       }
                       if (!bol_precision) {
                         ull_precision = 1;  /* default precision      */
                         if (bol_padding_zero) {
                           if (ull_field_width>inl_needed && !bol_adjustleft) {
                             /* fake padding with '0' by ull_precision */
                             ull_precision = ull_field_width+(inl_dgsp_lc?inl_emax+inl_s:inl_emax)-inl_needed;
                           }
                         }
                       }
                       if (inl_dgsp_lc) {   /* using digit group separation */
                         inl_precpad = ull_precision-(inl_emax+inl_s);
                         if (inl_precpad>0) {
#ifdef HL_USE_DIV
                           div_t dsl_d = div(inl_dgsp_ph+inl_precpad, D_DIGGRPLEN+inl_dgsp_lc);
                           inl_dgsp_tm += dsl_d.quot;
                           inl_needed += inl_precpad;
                           inl_dgsp_ph = dsl_d.rem;
#else
                           inl_needed += inl_precpad;
                           inl_dgsp_tm += (inl_dgsp_ph+inl_precpad)/(D_DIGGRPLEN+inl_dgsp_lc);
                           inl_dgsp_ph = (inl_dgsp_ph+inl_precpad)%(D_DIGGRPLEN+inl_dgsp_lc);
#endif
                           if (inl_dgsp_ph>D_DIGGRPLEN) {
                             inl_needed -= inl_dgsp_ph-D_DIGGRPLEN;
                             inl_dgsp_ph = D_DIGGRPLEN;
                           }
                           inl_precpad = ull_precision-(inl_emax+inl_dgsp_tm*inl_dgsp_lc);
                         } else {
                           inl_precpad=0;
                         }
                       } else {    /* not using digit group separation */
                         inl_precpad = ull_precision-inl_emax;
                         if (inl_precpad>0) {
                           inl_needed += inl_precpad;
                         } else {
                           inl_precpad=0;
                         }
                       }
                       if (ull_field_width > inl_needed) {
                         awcl_after = awcl_cur+ull_field_width;
                         inl_padsp = ull_field_width-inl_needed;
                         if (!bol_adjustleft) {  /* padding left with spaces */
                           if (inl_padsp > awcl_end-awcl_cur)
                             {awcl_after = awcl_cur; break;}  /* overflow */
                           do
                             *awcl_cur++ = HL_WCHAR_CAST(' ');
                           while (--inl_padsp);
                         }
                       } else {
                         awcl_after = awcl_cur+inl_needed;
                         inl_padsp = 0;
                       }
                       if (inl_dgsp_lc) {   /* set digit group separators */
                         /* produce the first separator                                     */
                         awcl_dg = awcl_cur+inl_dgsp_ph;
                         if (iel_cs_target == ied_chs_utf_16) {  /* natural endian */
                           inl_dgsp_lo = m_u16l_from_u8l(awcl_dg, awcl_end-awcl_dg, achl_dgsp, inl_dgsp_lb);
                         } else {           /* swapped endian          */
                           inl_dgsp_lo = m_u16r_from_u8l(awcl_dg, 1+awcl_end-awcl_dg, achl_dgsp, inl_dgsp_lb);
                         }
                         /* now the complete physical output length can be determined      */
                         inl_s = inl_dgsp_tm*(inl_dgsp_lo-inl_dgsp_lc);  /* adjustment from logical to physical */
                         awcl_after += inl_s;
                         if (inl_dgsp_lo<0 || awcl_after-awcl_cur>awcl_end-awcl_cur)
                           {awcl_after = awcl_cur; break;}  /* overflow */
                         /* copy the other separators from the first one                   */
                         inl_s = inl_dgsp_tm-1;
                         if (inl_s) {
                           awcl0 = awcl_dg+inl_dgsp_lo;
                           do {
                             awcl0 += D_DIGGRPLEN;
                             int inl2 = 0;
                             do
                               *awcl0++ = awcl_dg[inl2++];
                             while (inl2<inl_dgsp_lo);
                           } while (--inl_s);
                         }
                         /* padding left with zeroes to "precision"                        */
                         while (inl_precpad) {
                           if (inl_dgsp_ph == 0) {  /* skip digits-separator */
                             awcl_cur += inl_dgsp_lo;
                             inl_dgsp_ph = D_DIGGRPLEN-1;
                             inl_dgsp_tm--;
                             if (!inl_dgsp_tm)
                               break;
                           } else {
                             inl_dgsp_ph--;
                           }
                           *awcl_cur++ = HL_WCHAR_CAST('0');
                           inl_precpad --;
                         }
                       } else {             /* not using digit group separation */
                         if (awcl_after-awcl_cur>awcl_end-awcl_cur)
                           {awcl_after = awcl_cur; break;}  /* overflow */
                         /* padding left with zeroes to "precision"    */
                         while (inl_precpad) {
                           *awcl_cur++ = HL_WCHAR_CAST('0');
                           inl_precpad --;
                         }
                       }
                       /* postfix                                      */
                       if (inl_postfixlen) {
                         if (inl_postfixlen==2) {
                           *(awcl_after-(inl_padsp+2)) = HL_WCHAR_CAST(chl_postfix);
                           *(awcl_after-(inl_padsp+1)) = HL_WCHAR_CAST('i');
                         } else {
                           *(awcl_after-(inl_padsp+1)) = HL_WCHAR_CAST(chl_postfix);
                         }
                       }
                       /* padding right with spaces                    */
                       if (inl_padsp) {
                         awcl0 = awcl_after-1;
                         do
                           *awcl0-- = HL_WCHAR_CAST(' ');
                         while (--inl_padsp);
                       }
                       /* produce the digits                           */
                       if (inl_emax > 0) {
#ifdef HL_USE_DIV
                         if (sizeof(HL_ULONGLONG)<=sizeof(int)) {
                           div_t dsl_d;
                           dsl_d.quot = ull_arg/(HL_ULONGLONG)DECBASE;
                           dsl_d.rem = ull_arg%(HL_ULONGLONG)DECBASE;
                           if (inl_dgsp_lc) {  /* using digit group separation */
                             awcl_cur += inl_emax+inl_dgsp_tm*inl_dgsp_lo-1;
                             if (inl_dgsp_tm) {  /* write all digit groups that follow a separator */
                               inl_s=D_DIGGRPLEN;
                               while (TRUE) {
                                 do {
                                   *(awcl_cur)-- = HL_WCHAR_CAST('0'+dsl_d.rem);
                                   dsl_d = div(dsl_d.quot,DECBASE);
                                 } while (--inl_s);
                                 awcl_cur -= inl_dgsp_lo;  /* skip digits-separator */
                                 if (--inl_dgsp_tm==0)
                                   break;
                                 inl_s=D_DIGGRPLEN;
                               }
                             }
                             if (inl_dgsp_ph) {  /* precision may provoke leading separator */
                               while (TRUE) {   /* write leading (maybe partial) digit group */
                                 *awcl_cur = HL_WCHAR_CAST('0'+dsl_d.rem);
                                 if (--inl_dgsp_ph == 0) break;
                                 awcl_cur--;
                                 dsl_d = div(dsl_d.quot,DECBASE);
                               }
                             }
                           } else {  /* not using digit group separation */
                             while (TRUE) {
                               *(awcl_cur + --inl_emax) = HL_WCHAR_CAST('0'+dsl_d.rem);
                               if (inl_emax <= 0) break;
                               dsl_d = div(dsl_d.quot,DECBASE);
                             }
                           }
#ifdef HL_USE_LDIV
                         } else if (sizeof(HL_ULONGLONG)<=sizeof(long int)) {
                           ldiv_t dsl_d;
                           dsl_d.quot = ull_arg/(HL_ULONGLONG)DECBASE;
                           dsl_d.rem = ull_arg%(HL_ULONGLONG)DECBASE;
                           if (inl_dgsp_lc) {  /* using digit group separation */
                             awcl_cur += inl_emax+inl_dgsp_tm*inl_dgsp_lo-1;
                             if (inl_dgsp_tm) {  /* write all digit groups that follow a separator */
                               inl_s=D_DIGGRPLEN;
                               while (TRUE) {
                                 do {
                                   *(awcl_cur)-- = HL_WCHAR_CAST('0'+dsl_d.rem);
                                   dsl_d = ldiv(dsl_d.quot,DECBASE);
                                 } while (--inl_s);
                                 awcl_cur -= inl_dgsp_lo;  /* skip digits-separator */
                                 if (--inl_dgsp_tm==0)
                                   break;
                                 inl_s=D_DIGGRPLEN;
                               }
                             }
                             if (inl_dgsp_ph) {  /* precision may provoke leading separator */
                               while (TRUE) {   /* write leading (maybe partial) digit group */
                                 *awcl_cur = HL_WCHAR_CAST('0'+dsl_d.rem);
                                 if (--inl_dgsp_ph == 0) break;
                                 awcl_cur--;
                                 dsl_d = ldiv(dsl_d.quot,DECBASE);
                               }
                             }
                           } else {  /* not using digit group separation */
                             while (TRUE) {
                               *(awcl_cur + --inl_emax) = HL_WCHAR_CAST('0'+dsl_d.rem);
                               if (inl_emax <= 0) break;
                               dsl_d = ldiv(dsl_d.quot,DECBASE);
                             }
                           }
#endif
#ifdef HL_USE_LLDIV
                         } else if (sizeof(HL_ULONGLONG)<=sizeof(long long int)) {
                           lldiv_t dsl_d;
                           dsl_d.quot = ull_arg/(HL_ULONGLONG)DECBASE;
                           dsl_d.rem = ull_arg%(HL_ULONGLONG)DECBASE;
                           if (inl_dgsp_lc) {  /* using digit group separation */
                             awcl_cur += inl_emax+inl_dgsp_tm*inl_dgsp_lo-1;
                             if (inl_dgsp_tm) {  /* write all digit groups that follow a separator */
                               inl_s=D_DIGGRPLEN;
                               while (TRUE) {
                                 do {
                                   *(awcl_cur)-- = HL_WCHAR_CAST('0'+dsl_d.rem);
                                   dsl_d = lldiv(dsl_d.quot,DECBASE);
                                 } while (--inl_s);
                                 awcl_cur -= inl_dgsp_lo;  /* skip digits-separator */
                                 if (--inl_dgsp_tm==0)
                                   break;
                                 inl_s=D_DIGGRPLEN;
                               }
                             }
                             if (inl_dgsp_ph) {  /* precision may provoke leading separator */
                               while (TRUE) {   /* write leading (maybe partial) digit group */
                                 *awcl_cur = HL_WCHAR_CAST('0'+dsl_d.rem);
                                 if (--inl_dgsp_ph == 0) break;
                                 awcl_cur--;
                                 dsl_d = lldiv(dsl_d.quot,DECBASE);
                               }
                             }
                           } else {  /* not using digit group separation */
                             while (TRUE) {
                               *(awcl_cur + --inl_emax) = HL_WCHAR_CAST('0'+dsl_d.rem);
                               if (inl_emax <= 0) break;
                               dsl_d = lldiv(dsl_d.quot,DECBASE);
                             }
                           }
#endif
                         } else {
#endif
                           if (inl_dgsp_lc) {  /* using digit group separation */
                             awcl_cur += inl_emax+inl_dgsp_tm*inl_dgsp_lo-1;
                             if (inl_dgsp_tm) {  /* write all digit groups that follow a separator */
                               inl_s=D_DIGGRPLEN;
                               while (TRUE) {
                                 do {
                                   *(awcl_cur)-- = HL_WCHAR_CAST('0'+ull_arg%(HL_ULONGLONG)DECBASE);
                                   ull_arg/=(HL_ULONGLONG)DECBASE;
                                 } while (--inl_s);
                                 awcl_cur -= inl_dgsp_lo;  /* skip digits-separator */
                                 if (--inl_dgsp_tm==0)
                                   break;
                                 inl_s=D_DIGGRPLEN;
                               }
                             }
                             if (inl_dgsp_ph) {  /* precision may provoke leading separator */
                               while (TRUE) {   /* write leading (maybe partial) digit group */
                                 *awcl_cur = HL_WCHAR_CAST('0'+ull_arg%(HL_ULONGLONG)DECBASE);
                                 if (--inl_dgsp_ph == 0) break;
                                 awcl_cur--;
                                 ull_arg/=(HL_ULONGLONG)DECBASE;
                               }
                             }
                           } else {  /* not using digit group separation */
                             while (--inl_emax > 0) {
                               *(awcl_cur+inl_emax) = HL_WCHAR_CAST('0'+ull_arg%(HL_ULONGLONG)DECBASE);
                               ull_arg/=(HL_ULONGLONG)DECBASE;
                             }
                             *awcl_cur = HL_WCHAR_CAST('0'+ull_arg);
                           }
#ifdef HL_USE_DIV
                         }
#endif
                         awcl_cur += inl_emax;
                       }
                       break;
                     case 'O':
                       inl_emax = 0;
                       achl_digits = chl_spec&'\040' ? chrstrans_lc : chrstrans;  /* choose upper- or lowercase */
                       if (ull_arg!=0) {
                         int inl_e = (sizeof(HL_ULONGLONG)<<3)/3;
                         if (inl_e*3 < sizeof(HL_ULONGLONG)<<3)
                           inl_e++;
                         do {
                           inl_s = inl_e>>1;
                           if (ull_arg >= (HL_ULONGLONG)1<<((inl_emax+inl_s)*3)) {
                             inl_emax += inl_s;
                             inl_e -= inl_s;
                           } else {
                             inl_e = inl_s;
                           }
                         } while (inl_e>1);
                         inl_emax ++;
                         /* now inl_emax is number of digits needed    */
                       }
                       inl_needed = inl_emax + inl_postfixlen;
                       if (inl_dgsp_lc) {   /* use digit group separation */
                         if (inl_emax<=D_DIGGRPLEN) {  /* digit grouping not in effect */
                           inl_dgsp_lc = 0;
                         } else {
                           const int inl_emax_1 = inl_emax-1;
#ifdef HL_USE_DIV
                           dsl_diggrp_dm = div(inl_emax_1, D_DIGGRPLEN);
                           inl_dgsp_ph++;
#else
                           inl_dgsp_tm = (inl_emax_1)/D_DIGGRPLEN;
                           inl_dgsp_ph = (inl_emax_1)%D_DIGGRPLEN+1;
#endif
                           if (inl_needed>=ull_field_width || inl_needed+inl_dgsp_tm*inl_dgsp_lc<=ull_field_width) {
                             inl_s = inl_dgsp_tm*inl_dgsp_lc;
                             inl_needed += inl_s;
                           } else {  /* prefer staying within fieldwidth over using the separator */
                             inl_dgsp_lc = 0;
                           }
                         }
                       }
                       if (!bol_precision) {
                         ull_precision = 1;  /* default precision      */
                         if (bol_padding_zero) {
                           if (ull_field_width>inl_needed && !bol_adjustleft) {
                             /* fake padding with '0' by ull_precision */
                             ull_precision = ull_field_width+(inl_dgsp_lc?inl_emax+inl_s:inl_emax)-inl_needed;
                           } else {
                             bol_padding_zero = false;  /* according to spec, zeroflag is ignored in
                                               integer conversion if left-justify-flag is present */
                           }
                         }
                       } else {
                         bol_padding_zero = false;  /* according to spec, zeroflag is ignored in
                                                       integer conversion if a precision is given */
                       }
                       if (inl_dgsp_lc) {   /* using digit group separation */
                         inl_precpad = ull_precision-(inl_emax+inl_s);
                         if (inl_precpad>0) {
#ifdef HL_USE_DIV
                           div_t dsl_d = div(inl_dgsp_ph+inl_precpad, D_DIGGRPLEN+inl_dgsp_lc);
                           inl_dgsp_tm += dsl_d.quot;
                           inl_needed += inl_precpad;
                           inl_dgsp_ph = dsl_d.rem;
#else
                           inl_needed += inl_precpad;
                           inl_dgsp_tm += (inl_dgsp_ph+inl_precpad)/(D_DIGGRPLEN+inl_dgsp_lc);
                           inl_dgsp_ph = (inl_dgsp_ph+inl_precpad)%(D_DIGGRPLEN+inl_dgsp_lc);
#endif
                           if (inl_dgsp_ph>D_DIGGRPLEN) {
                            if (bol_alternate_form && (ull_arg!=0) &&
                                !(bol_padding_zero && (ull_precision>inl_emax+inl_dgsp_tm*D_DIGGRPLEN)))
                            {               /* ensure octal prefix     */
                             inl_dgsp_tm++;
                             ull_precision += 1+inl_dgsp_lc+D_DIGGRPLEN-inl_dgsp_ph;
                             inl_needed += 1+inl_dgsp_lc+D_DIGGRPLEN-inl_dgsp_ph;
                             inl_dgsp_ph = 1;
                            } else {
                             inl_needed -= inl_dgsp_ph-D_DIGGRPLEN;
                             inl_dgsp_ph = D_DIGGRPLEN;
                            }
                           } else if (bol_alternate_form && (inl_dgsp_ph==0) && (ull_arg!=0)) {
                             if (bol_padding_zero && (ull_precision-inl_dgsp_lc>inl_emax+(inl_dgsp_tm-1)*D_DIGGRPLEN)) {
                               /* prefer staying within fieldwidth over avoiding all spacepadding */
                               inl_dgsp_tm--;
                               ull_precision -= inl_dgsp_lc;
                               inl_needed -= inl_dgsp_lc;
                               inl_dgsp_ph = D_DIGGRPLEN;
                             } else {
                               ull_precision++;
                               inl_needed++;
                               inl_dgsp_ph=1;
                             }
                           }
                           inl_precpad = ull_precision-(inl_emax+inl_dgsp_tm*inl_dgsp_lc);
                         } else {
                          if (bol_alternate_form && (ull_arg!=0)) {  /* ensure octal prefix */
                            if (inl_dgsp_ph>=D_DIGGRPLEN) {
                              inl_dgsp_tm++;
                              ull_precision += 1+inl_dgsp_lc+D_DIGGRPLEN-inl_dgsp_ph;
                              inl_needed += 1+inl_dgsp_lc+D_DIGGRPLEN-inl_dgsp_ph;
                              inl_dgsp_ph = 1;
                            } else {
                              ull_precision++;
                              inl_needed++;
                              inl_dgsp_ph++;
                            }
                            inl_precpad++;
                          } else {
                           inl_precpad=0;
                          }
                         }
                       } else {    /* not using digit group separation */
                         if (bol_alternate_form && (ull_arg!=0) && (ull_precision<=inl_emax))
                           ull_precision = inl_emax+1;  /* cause octal prefix */
                         inl_precpad = ull_precision-inl_emax;
                         if (inl_precpad>0) {
                           inl_needed += inl_precpad;
                         } else {
                           inl_precpad=0;
                         }
                       }
                       if (ull_field_width > inl_needed) {
                         awcl_after = awcl_cur+ull_field_width;
                         inl_padsp = ull_field_width-inl_needed;
                         if (!bol_adjustleft) {  /* padding left with spaces */
                           if (inl_padsp > awcl_end-awcl_cur)
                             {awcl_after = awcl_cur; break;}  /* overflow */
                           do
                             *awcl_cur++ = HL_WCHAR_CAST(' ');
                           while (--inl_padsp);
                         }
                       } else {
                         awcl_after = awcl_cur+inl_needed;
                         inl_padsp = 0;
                       }
                       if (inl_dgsp_lc) {   /* set digit group separators */
                         /* produce the first separator                                     */
                         awcl_dg = awcl_cur+inl_dgsp_ph;
                         if (iel_cs_target == ied_chs_utf_16) {  /* natural endian */
                           inl_dgsp_lo = m_u16l_from_u8l(awcl_dg, awcl_end-awcl_dg, achl_dgsp, inl_dgsp_lb);
                         } else {           /* swapped endian          */
                           inl_dgsp_lo = m_u16r_from_u8l(awcl_dg, 1+awcl_end-awcl_dg, achl_dgsp, inl_dgsp_lb);
                         }
                         /* now the complete physical output length can be determined      */
                         inl_s = inl_dgsp_tm*(inl_dgsp_lo-inl_dgsp_lc);  /* adjustment from logical to physical */
                         awcl_after += inl_s;
                         if (inl_dgsp_lo<0 || awcl_after-awcl_cur>awcl_end-awcl_cur)
                           {awcl_after = awcl_cur; break;}  /* overflow */
                         /* copy the other separators from the first one                   */
                         inl_s = inl_dgsp_tm-1;
                         if (inl_s) {
                           awcl0 = awcl_dg+inl_dgsp_lo;
                           do {
                             awcl0 += D_DIGGRPLEN;
                             int inl2 = 0;
                             do
                               *awcl0++ = awcl_dg[inl2++];
                             while (inl2<inl_dgsp_lo);
                           } while (--inl_s);
                         }
                         /* padding left with zeroes to "precision"                        */
                         while (inl_precpad) {
                           if (inl_dgsp_ph == 0) {  /* skip digits-separator */
                             awcl_cur += inl_dgsp_lo;
                             inl_dgsp_ph = D_DIGGRPLEN-1;
                             inl_dgsp_tm--;
                             if (!inl_dgsp_tm)
                               break;
                           } else {
                             inl_dgsp_ph--;
                           }
                           *awcl_cur++ = HL_WCHAR_CAST('0');
                           inl_precpad --;
                         }
                       } else {             /* not using digit group separation */
                         if (awcl_after-awcl_cur>awcl_end-awcl_cur)
                           {awcl_after = awcl_cur; break;}  /* overflow */
                         /* padding left with zeroes to "precision"    */
                         while (inl_precpad) {
                           *awcl_cur++ = HL_WCHAR_CAST('0');
                           inl_precpad --;
                         }
                       }
                       /* postfix                                      */
                       if (inl_postfixlen) {
                         if (inl_postfixlen==2) {
                           *(awcl_after-(inl_padsp+2)) = HL_WCHAR_CAST(chl_postfix);
                           *(awcl_after-(inl_padsp+1)) = HL_WCHAR_CAST('i');
                         } else {
                           *(awcl_after-(inl_padsp+1)) = HL_WCHAR_CAST(chl_postfix);
                         }
                       }
                       /* padding right with spaces                    */
                       if (inl_padsp) {
                         awcl0 = awcl_after-1;
                         do
                           *awcl0-- = HL_WCHAR_CAST(' ');
                         while (--inl_padsp);
                       }
                       if (inl_emax!=0) {  /* done if zero-"precision" zero */
                         inl_emax --;
                         inl_emax *= 3;
                         if (inl_dgsp_lc) {  /* using digit group separation */
                           while (TRUE) {
                             while (inl_dgsp_ph) {
                               *(awcl_cur)++ = HL_WCHAR_CAST(achl_digits[(ull_arg>>inl_emax) & (1<<3)-1]);
                               inl_dgsp_ph--;
                               inl_emax -= 3;
                             }
                             inl_dgsp_tm--;
                             if (!inl_dgsp_tm)
                               break;       /* all digitgroups done    */
                             awcl_cur += inl_dgsp_lo;  /* skip digits-separator */
                             inl_dgsp_ph = D_DIGGRPLEN-1;
                           }
                         } else {  /* not using digit group separation */
                           while(TRUE) {
                             *(awcl_cur) = HL_WCHAR_CAST(achl_digits[(ull_arg>>inl_emax) & (1<<3)-1]);
                             if (inl_emax==0)
                               break;
                             (awcl_cur)++;
                             inl_emax -= 3;
                           }
                         }
                       }
                       break;
                     case 'X':
                       inl_emax = 0;
                       achl_digits = chl_spec&'\040' ? chrstrans_lc : chrstrans;  /* choose upper- or lowercase */
                       if (ull_arg!=0) {
                         int inl_e = (sizeof(HL_ULONGLONG)<<3)/4;
                         if (inl_e*4 < sizeof(HL_ULONGLONG)<<3)
                           inl_e++;
                         do {
                           inl_s = inl_e>>1;
                           if (ull_arg >= (HL_ULONGLONG)1<<((inl_emax+inl_s)*4)) {
                             inl_emax += inl_s;
                             inl_e -= inl_s;
                           } else {
                             inl_e = inl_s;
                           }
                         } while (inl_e>1);
                         inl_emax ++;
                         /* now inl_emax is number of digits needed    */
                       }
                       inl_needed = inl_emax + inl_postfixlen;
                       if (bol_alternate_form && (ull_arg!=0))
                         inl_needed += 2;   /* for hex prefix          */
                       if (inl_dgsp_lc) {   /* use digit group separation */
                         if (inl_emax<=D_DIGGRPLEN) {  /* digit grouping not in effect */
                           inl_dgsp_lc = 0;
                         } else {
                           const int inl_emax_1 = inl_emax-1;
#ifdef HL_USE_DIV
                           dsl_diggrp_dm = div(inl_emax_1, D_DIGGRPLEN);
                           inl_dgsp_ph++;
#else
                           inl_dgsp_tm = (inl_emax_1)/D_DIGGRPLEN;
                           inl_dgsp_ph = (inl_emax_1)%D_DIGGRPLEN+1;
#endif
                           if (inl_needed>=ull_field_width || inl_needed+inl_dgsp_tm*inl_dgsp_lc<=ull_field_width) {
                             inl_s = inl_dgsp_tm*inl_dgsp_lc;
                             inl_needed += inl_s;
                           } else {  /* prefer staying within fieldwidth over using the separator */
                             inl_dgsp_lc = 0;
                           }
                         }
                       }
                       if (!bol_precision) {
                         ull_precision = 1;  /* default precision      */
                         if (bol_padding_zero) {
                           if (ull_field_width>inl_needed && !bol_adjustleft) {
                             /* fake padding with '0' by ull_precision */
                             ull_precision = ull_field_width+(inl_dgsp_lc?inl_emax+inl_s:inl_emax)-inl_needed;
                           }
                         }
                       }
                       if (inl_dgsp_lc) {   /* using digit group separation */
                         inl_precpad = ull_precision-(inl_emax+inl_s);
                         if (inl_precpad>0) {
#ifdef HL_USE_DIV
                           div_t dsl_d = div(inl_dgsp_ph+inl_precpad, D_DIGGRPLEN+inl_dgsp_lc);
                           inl_dgsp_tm += dsl_d.quot;
                           inl_needed += inl_precpad;
                           inl_dgsp_ph = dsl_d.rem;
#else
                           inl_needed += inl_precpad;
                           inl_dgsp_tm += (inl_dgsp_ph+inl_precpad)/(D_DIGGRPLEN+inl_dgsp_lc);
                           inl_dgsp_ph = (inl_dgsp_ph+inl_precpad)%(D_DIGGRPLEN+inl_dgsp_lc);
#endif
                           if (inl_dgsp_ph>D_DIGGRPLEN) {
                             inl_needed -= inl_dgsp_ph-D_DIGGRPLEN;
                             inl_dgsp_ph = D_DIGGRPLEN;
                           }
                           inl_precpad = ull_precision-(inl_emax+inl_dgsp_tm*inl_dgsp_lc);
                         } else {
                           inl_precpad=0;
                         }
                       } else {    /* not using digit group separation */
                         inl_precpad = ull_precision-inl_emax;
                         if (inl_precpad>0) {
                           inl_needed += inl_precpad;
                         } else {
                           inl_precpad=0;
                         }
                       }
                       if (ull_field_width > inl_needed) {
                         awcl_after = awcl_cur+ull_field_width;
                         inl_padsp = ull_field_width-inl_needed;
                         if (!bol_adjustleft) {  /* padding left with spaces */
                           if (inl_padsp > awcl_end-awcl_cur)
                             {awcl_after = awcl_cur; break;}  /* overflow */
                           do
                             *awcl_cur++ = HL_WCHAR_CAST(' ');
                           while (--inl_padsp);
                         }
                       } else {
                         awcl_after = awcl_cur+inl_needed;
                         inl_padsp = 0;
                       }
                       if (inl_dgsp_lc) {   /* set digit group separators */
                         if (bol_alternate_form && (ull_arg!=0)) {  /* write hex prefix    */
                           if (2 > awcl_end-awcl_cur)
                             {awcl_after = awcl_cur; break;}  /* overflow */
                           *awcl_cur++ = HL_WCHAR_CAST('0');
                           *awcl_cur++ = HL_WCHAR_CAST('X'|(chl_spec&'\040'));
                         }
                         /* produce the first separator                                     */
                         awcl_dg = awcl_cur+inl_dgsp_ph;
                         if (iel_cs_target == ied_chs_utf_16) {  /* natural endian */
                           inl_dgsp_lo = m_u16l_from_u8l(awcl_dg, awcl_end-awcl_dg, achl_dgsp, inl_dgsp_lb);
                         } else {           /* swapped endian          */
                           inl_dgsp_lo = m_u16r_from_u8l(awcl_dg, 1+awcl_end-awcl_dg, achl_dgsp, inl_dgsp_lb);
                         }
                         /* now the complete physical output length can be determined      */
                         inl_s = inl_dgsp_tm*(inl_dgsp_lo-inl_dgsp_lc);  /* adjustment from logical to physical */
                         awcl_after += inl_s;
                         if (inl_dgsp_lo<0 || awcl_after-awcl_cur>awcl_end-awcl_cur)
                           {awcl_after = awcl_cur; break;}  /* overflow */
                         /* copy the other separators from the first one                   */
                         inl_s = inl_dgsp_tm-1;
                         if (inl_s) {
                           awcl0 = awcl_dg+inl_dgsp_lo;
                           do {
                             awcl0 += D_DIGGRPLEN;
                             int inl2 = 0;
                             do
                               *awcl0++ = awcl_dg[inl2++];
                             while (inl2<inl_dgsp_lo);
                           } while (--inl_s);
                         }
                         /* padding left with zeroes to "precision"                        */
                         while (inl_precpad) {
                           if (inl_dgsp_ph == 0) {  /* skip digits-separator */
                             awcl_cur += inl_dgsp_lo;
                             inl_dgsp_ph = D_DIGGRPLEN-1;
                             inl_dgsp_tm--;
                             if (!inl_dgsp_tm)
                               break;
                           } else {
                             inl_dgsp_ph--;
                           }
                           *awcl_cur++ = HL_WCHAR_CAST('0');
                           inl_precpad --;
                         }
                       } else {             /* not using digit group separation */
                         if (awcl_after-awcl_cur>awcl_end-awcl_cur)
                           {awcl_after = awcl_cur; break;}  /* overflow */
                         if (bol_alternate_form && (ull_arg!=0)) {  /* write hex prefix */
                           *awcl_cur++ = HL_WCHAR_CAST('0');
                           *awcl_cur++ = HL_WCHAR_CAST('X'|(chl_spec&'\040'));
                         }
                         /* padding left with zeroes to "precision"    */
                         while (inl_precpad) {
                           *awcl_cur++ = HL_WCHAR_CAST('0');
                           inl_precpad --;
                         }
                       }
                       /* postfix                                      */
                       if (inl_postfixlen) {
                         if (inl_postfixlen==2) {
                           *(awcl_after-(inl_padsp+2)) = HL_WCHAR_CAST(chl_postfix);
                           *(awcl_after-(inl_padsp+1)) = HL_WCHAR_CAST('i');
                         } else {
                           *(awcl_after-(inl_padsp+1)) = HL_WCHAR_CAST(chl_postfix);
                         }
                       }
                       /* padding right with spaces                    */
                       if (inl_padsp) {
                         awcl0 = awcl_after-1;
                         do
                           *awcl0-- = HL_WCHAR_CAST(' ');
                         while (--inl_padsp);
                       }
                       if (inl_emax!=0) {  /* done if zero-"precision" zero */
                         inl_emax --;
                         inl_emax *= 4;
                         if (inl_dgsp_lc) {  /* using digit group separation */
                           while (TRUE) {
                             while (inl_dgsp_ph) {
                               *(awcl_cur)++ = HL_WCHAR_CAST(achl_digits[(ull_arg>>inl_emax) & (1<<4)-1]);
                               inl_dgsp_ph--;
                               inl_emax -= 4;
                             }
                             inl_dgsp_tm--;
                             if (!inl_dgsp_tm)
                               break;       /* all digitgroups done    */
                             awcl_cur += inl_dgsp_lo;  /* skip digits-separator */
                             inl_dgsp_ph = D_DIGGRPLEN-1;
                           }
                         } else {  /* not using digit group separation */
                           while(TRUE) {
                             *(awcl_cur) = HL_WCHAR_CAST(achl_digits[(ull_arg>>inl_emax) & (1<<4)-1]);
                             if (inl_emax==0)
                               break;
                             (awcl_cur)++;
                             inl_emax -= 4;
                           }
                         }
                       }
                       break;
                   }
                 }
                 else {
                   ull_arg = va_arg(dsl_list, unsigned long int);
                   switch (chl_spec&0xDF) {
                     case 'U':

                       /* prepare %(sci-dec)- or %(sci-dec)-type of rendering */
                       if (iel_scaling!=ied_scaling_none) {
                         if (iel_scaling == ied_scaling_1000) {  /* power-of-1000-scaled */
#if HL_PRFMAXSO_L > 4
                           if ((sizeof(unsigned long int) > 4) && (ull_arg >= D_L1000RD * ullrs_decpowbuf[9])) {
                             if (
                                 (ull_arg >= D_L1000RD * ullrs_decpowbuf[15])
                                ) {
#if HL_PRFMAXSO_L > 8
                               if (
                                   (sizeof(unsigned long int) > 8) &&
                                   (ull_arg >= D_L1000RD * ullrs_decpowbuf[18])
                                  ) {
                                 if (ull_arg >= D_L1000RD * ullrs_decpowbuf[21]) {
                                   ull_arg =  (ull_arg + 500 * ullrs_decpowbuf[21]) / (ullrs_decpowbuf[24]);
                                   chl_postfix = 'Y';
                                 } else {
                                   ull_arg =  (ull_arg + 500 * ullrs_decpowbuf[18]) / (ullrs_decpowbuf[21]);
                                   chl_postfix = 'Z';
                                 }
                               } else {
#endif
                                 ull_arg =  (ull_arg + 500 * ullrs_decpowbuf[15]) / (ullrs_decpowbuf[18]);
                                 chl_postfix = 'E';
#if HL_PRFMAXSO_L > 8
                               }
#endif
                             } else {
                               if (ull_arg >= D_L1000RD * ullrs_decpowbuf[12]) {
                                 ull_arg =  (ull_arg + 500 * ullrs_decpowbuf[12]) / (ullrs_decpowbuf[15]);
                                 chl_postfix = 'P';
                               } else {
                                 ull_arg =  (ull_arg + 500 * ullrs_decpowbuf[9]) / (ullrs_decpowbuf[12]);
                                 chl_postfix = 'T';
                               }
                             }
                             inl_postfixlen = 1;
                           } else {
#endif
#if HL_PRFMAXSO_L > 2
                             if ((sizeof(unsigned long int) > 2) && (ull_arg >= D_L1000RD * ullrs_decpowbuf[3])) {
#if HL_PRFMAXSO_L > 4
                               if ((sizeof(unsigned long int) > 4) && (ull_arg >= D_L1000RD * ullrs_decpowbuf[6])) {
                                 ull_arg =  (ull_arg + 500 * ullrs_decpowbuf[6]) / (ullrs_decpowbuf[9]);
                                 chl_postfix = 'G';
                               } else {
#endif
                                 ull_arg =  (ull_arg + 500 * ullrs_decpowbuf[3]) / (ullrs_decpowbuf[6]);
                                 chl_postfix = 'M';
#if HL_PRFMAXSO_L > 4
                               }
#endif
                               inl_postfixlen = 1;
                             } else {
#endif
                               if (ull_arg >= D_L1000RD) {
                                 ull_arg = (ull_arg + 500) / 1000;
                                 chl_postfix = 'k';
                                 inl_postfixlen = 1;
                               }
#if HL_PRFMAXSO_L > 2
                             }
#endif
#if HL_PRFMAXSO_L > 4
                           }
#endif
                         }
                         else {               /* power-of-1024-scaled    */
#if HL_PRFMAXSO_L > 4
                           if ((sizeof(unsigned long int) > 4) && (ull_arg>>30 >= D_L1024RD)) {
                             if (
                                 (ull_arg>>50 >= D_L1024RD)
                                ) {
#if HL_PRFMAXSO_L > 8
                               if (
                                   (sizeof(unsigned long int) > 8) &&
                                   (ull_arg>>60 >= D_L1024RD)
                                  ) {
                                 if (ull_arg>>70 >= D_L1024RD) {
                                   ull_arg = (ull_arg+((unsigned long int)1<<79)) >> 80;
                                   chl_postfix = 'Y';
                                 } else {
                                   ull_arg = (ull_arg+((unsigned long int)1<<69)) >> 70;
                                   chl_postfix = 'Z';
                                 }
                               } else {
#endif
                                 ull_arg = (ull_arg+((unsigned long int)1<<59)) >> 60;
                                 chl_postfix = 'E';
#if HL_PRFMAXSO_L > 8
                               }
#endif
                             } else {
                               if (ull_arg>>40 >= D_L1024RD) {
                                 ull_arg = (ull_arg+((unsigned long int)1<<49)) >> 50;
                                 chl_postfix = 'P';
                               } else {
                                 ull_arg = (ull_arg+((unsigned long int)1<<39)) >> 40;
                                 chl_postfix = 'T';
                               }
                             }
                             inl_postfixlen = bol_alternate_form ? 2 : 1;
                           } else {
#endif
#if HL_PRFMAXSO_L > 2
                             if ((sizeof(unsigned long int) > 2) && (ull_arg>>10 >= D_L1024RD)) {
#if HL_PRFMAXSO_L > 4
                               if ((sizeof(unsigned long int) > 4) && (ull_arg>>20 >= D_L1024RD)) {
                                 ull_arg = (ull_arg+((unsigned long int)1<<29)) >> 30;
                                 chl_postfix = 'G';
                               } else {
#endif
                                 ull_arg = (ull_arg+((unsigned long int)1<<19)) >> 20;
                                 chl_postfix = 'M';
#if HL_PRFMAXSO_L > 4
                               }
#endif
                               inl_postfixlen = bol_alternate_form ? 2 : 1;
                             } else {
#endif
                               if (ull_arg >= D_L1024RD) {
                                 ull_arg = (ull_arg+0x200) >> 10;
                                 chl_postfix = 'K';
                                 inl_postfixlen = bol_alternate_form ? 2 : 1;
                               }
#if HL_PRFMAXSO_L > 2
                             }
#endif
#if HL_PRFMAXSO_L > 4
                           }
#endif
                         }
                       }

                       /* detect the order of magnitude of X           */
                       inl_emax = 0;
                       if (ull_arg) {
                         int inl_e = ((sizeof(unsigned long int)*240824)/100000)+1;
                         do {
                           inl_s = inl_e>>1;
                           if (ull_arg >= ullrs_decpowbuf[inl_emax+inl_s]) {
                             inl_emax += inl_s;
                             inl_e -= inl_s;
                           } else {
                             inl_e = inl_s;
                           }
                         } while (inl_e>1);
                         inl_emax ++;
                       }
                       inl_needed = inl_emax + inl_postfixlen;
                       if (inl_dgsp_lc) {   /* use digit group separation */
                         if (inl_emax<=D_DIGGRPLEN) {  /* digit grouping not in effect */
                           inl_dgsp_lc = 0;
                         } else {
                           const int inl_emax_1 = inl_emax-1;
#ifdef HL_USE_DIV
                           dsl_diggrp_dm = div(inl_emax_1, D_DIGGRPLEN);
                           inl_dgsp_ph++;
#else
                           inl_dgsp_tm = (inl_emax_1)/D_DIGGRPLEN;
                           inl_dgsp_ph = (inl_emax_1)%D_DIGGRPLEN+1;
#endif
                           if (inl_needed>=ull_field_width || inl_needed+inl_dgsp_tm*inl_dgsp_lc<=ull_field_width) {
                             inl_s = inl_dgsp_tm*inl_dgsp_lc;
                             inl_needed += inl_s;
                           } else {  /* prefer staying within fieldwidth over using the separator */
                             inl_dgsp_lc = 0;
                           }
                         }
                       }
                       if (!bol_precision) {
                         ull_precision = 1;  /* default precision      */
                         if (bol_padding_zero) {
                           if (ull_field_width>inl_needed && !bol_adjustleft) {
                             /* fake padding with '0' by ull_precision */
                             ull_precision = ull_field_width+(inl_dgsp_lc?inl_emax+inl_s:inl_emax)-inl_needed;
                           }
                         }
                       }
                       if (inl_dgsp_lc) {   /* using digit group separation */
                         inl_precpad = ull_precision-(inl_emax+inl_s);
                         if (inl_precpad>0) {
#ifdef HL_USE_DIV
                           div_t dsl_d = div(inl_dgsp_ph+inl_precpad, D_DIGGRPLEN+inl_dgsp_lc);
                           inl_dgsp_tm += dsl_d.quot;
                           inl_needed += inl_precpad;
                           inl_dgsp_ph = dsl_d.rem;
#else
                           inl_needed += inl_precpad;
                           inl_dgsp_tm += (inl_dgsp_ph+inl_precpad)/(D_DIGGRPLEN+inl_dgsp_lc);
                           inl_dgsp_ph = (inl_dgsp_ph+inl_precpad)%(D_DIGGRPLEN+inl_dgsp_lc);
#endif
                           if (inl_dgsp_ph>D_DIGGRPLEN) {
                             inl_needed -= inl_dgsp_ph-D_DIGGRPLEN;
                             inl_dgsp_ph = D_DIGGRPLEN;
                           }
                           inl_precpad = ull_precision-(inl_emax+inl_dgsp_tm*inl_dgsp_lc);
                         } else {
                           inl_precpad=0;
                         }
                       } else {    /* not using digit group separation */
                         inl_precpad = ull_precision-inl_emax;
                         if (inl_precpad>0) {
                           inl_needed += inl_precpad;
                         } else {
                           inl_precpad=0;
                         }
                       }
                       if (ull_field_width > inl_needed) {
                         awcl_after = awcl_cur+ull_field_width;
                         inl_padsp = ull_field_width-inl_needed;
                         if (!bol_adjustleft) {  /* padding left with spaces */
                           if (inl_padsp > awcl_end-awcl_cur)
                             {awcl_after = awcl_cur; break;}  /* overflow */
                           do
                             *awcl_cur++ = HL_WCHAR_CAST(' ');
                           while (--inl_padsp);
                         }
                       } else {
                         awcl_after = awcl_cur+inl_needed;
                         inl_padsp = 0;
                       }
                       if (inl_dgsp_lc) {   /* set digit group separators */
                         /* produce the first separator                                     */
                         awcl_dg = awcl_cur+inl_dgsp_ph;
                         if (iel_cs_target == ied_chs_utf_16) {  /* natural endian */
                           inl_dgsp_lo = m_u16l_from_u8l(awcl_dg, awcl_end-awcl_dg, achl_dgsp, inl_dgsp_lb);
                         } else {           /* swapped endian          */
                           inl_dgsp_lo = m_u16r_from_u8l(awcl_dg, 1+awcl_end-awcl_dg, achl_dgsp, inl_dgsp_lb);
                         }
                         /* now the complete physical output length can be determined      */
                         inl_s = inl_dgsp_tm*(inl_dgsp_lo-inl_dgsp_lc);  /* adjustment from logical to physical */
                         awcl_after += inl_s;
                         if (inl_dgsp_lo<0 || awcl_after-awcl_cur>awcl_end-awcl_cur)
                           {awcl_after = awcl_cur; break;}  /* overflow */
                         /* copy the other separators from the first one                   */
                         inl_s = inl_dgsp_tm-1;
                         if (inl_s) {
                           awcl0 = awcl_dg+inl_dgsp_lo;
                           do {
                             awcl0 += D_DIGGRPLEN;
                             int inl2 = 0;
                             do
                               *awcl0++ = awcl_dg[inl2++];
                             while (inl2<inl_dgsp_lo);
                           } while (--inl_s);
                         }
                         /* padding left with zeroes to "precision"                        */
                         while (inl_precpad) {
                           if (inl_dgsp_ph == 0) {  /* skip digits-separator */
                             awcl_cur += inl_dgsp_lo;
                             inl_dgsp_ph = D_DIGGRPLEN-1;
                             inl_dgsp_tm--;
                             if (!inl_dgsp_tm)
                               break;
                           } else {
                             inl_dgsp_ph--;
                           }
                           *awcl_cur++ = HL_WCHAR_CAST('0');
                           inl_precpad --;
                         }
                       } else {             /* not using digit group separation */
                         if (awcl_after-awcl_cur>awcl_end-awcl_cur)
                           {awcl_after = awcl_cur; break;}  /* overflow */
                         /* padding left with zeroes to "precision"    */
                         while (inl_precpad) {
                           *awcl_cur++ = HL_WCHAR_CAST('0');
                           inl_precpad --;
                         }
                       }
                       /* postfix                                      */
                       if (inl_postfixlen) {
                         if (inl_postfixlen==2) {
                           *(awcl_after-(inl_padsp+2)) = HL_WCHAR_CAST(chl_postfix);
                           *(awcl_after-(inl_padsp+1)) = HL_WCHAR_CAST('i');
                         } else {
                           *(awcl_after-(inl_padsp+1)) = HL_WCHAR_CAST(chl_postfix);
                         }
                       }
                       /* padding right with spaces                    */
                       if (inl_padsp) {
                         awcl0 = awcl_after-1;
                         do
                           *awcl0-- = HL_WCHAR_CAST(' ');
                         while (--inl_padsp);
                       }
                       /* produce the digits                           */
                       if (inl_emax > 0) {
#ifdef HL_USE_DIV
                         if (sizeof(unsigned long int)<=sizeof(int)) {
                           div_t dsl_d;
                           dsl_d.quot = ull_arg/(unsigned long int)DECBASE;
                           dsl_d.rem = ull_arg%(unsigned long int)DECBASE;
                           if (inl_dgsp_lc) {  /* using digit group separation */
                             awcl_cur += inl_emax+inl_dgsp_tm*inl_dgsp_lo-1;
                             if (inl_dgsp_tm) {  /* write all digit groups that follow a separator */
                               inl_s=D_DIGGRPLEN;
                               while (TRUE) {
                                 do {
                                   *(awcl_cur)-- = HL_WCHAR_CAST('0'+dsl_d.rem);
                                   dsl_d = div(dsl_d.quot,DECBASE);
                                 } while (--inl_s);
                                 awcl_cur -= inl_dgsp_lo;  /* skip digits-separator */
                                 if (--inl_dgsp_tm==0)
                                   break;
                                 inl_s=D_DIGGRPLEN;
                               }
                             }
                             if (inl_dgsp_ph) {  /* precision may provoke leading separator */
                               while (TRUE) {   /* write leading (maybe partial) digit group */
                                 *awcl_cur = HL_WCHAR_CAST('0'+dsl_d.rem);
                                 if (--inl_dgsp_ph == 0) break;
                                 awcl_cur--;
                                 dsl_d = div(dsl_d.quot,DECBASE);
                               }
                             }
                           } else {  /* not using digit group separation */
                             while (TRUE) {
                               *(awcl_cur + --inl_emax) = HL_WCHAR_CAST('0'+dsl_d.rem);
                               if (inl_emax <= 0) break;
                               dsl_d = div(dsl_d.quot,DECBASE);
                             }
                           }
#ifdef HL_USE_LDIV
                         } else if (sizeof(unsigned long int)<=sizeof(long int)) {
                           ldiv_t dsl_d;
                           dsl_d.quot = ull_arg/(unsigned long int)DECBASE;
                           dsl_d.rem = ull_arg%(unsigned long int)DECBASE;
                           if (inl_dgsp_lc) {  /* using digit group separation */
                             awcl_cur += inl_emax+inl_dgsp_tm*inl_dgsp_lo-1;
                             if (inl_dgsp_tm) {  /* write all digit groups that follow a separator */
                               inl_s=D_DIGGRPLEN;
                               while (TRUE) {
                                 do {
                                   *(awcl_cur)-- = HL_WCHAR_CAST('0'+dsl_d.rem);
                                   dsl_d = ldiv(dsl_d.quot,DECBASE);
                                 } while (--inl_s);
                                 awcl_cur -= inl_dgsp_lo;  /* skip digits-separator */
                                 if (--inl_dgsp_tm==0)
                                   break;
                                 inl_s=D_DIGGRPLEN;
                               }
                             }
                             if (inl_dgsp_ph) {  /* precision may provoke leading separator */
                               while (TRUE) {   /* write leading (maybe partial) digit group */
                                 *awcl_cur = HL_WCHAR_CAST('0'+dsl_d.rem);
                                 if (--inl_dgsp_ph == 0) break;
                                 awcl_cur--;
                                 dsl_d = ldiv(dsl_d.quot,DECBASE);
                               }
                             }
                           } else {  /* not using digit group separation */
                             while (TRUE) {
                               *(awcl_cur + --inl_emax) = HL_WCHAR_CAST('0'+dsl_d.rem);
                               if (inl_emax <= 0) break;
                               dsl_d = ldiv(dsl_d.quot,DECBASE);
                             }
                           }
#endif
#ifdef HL_USE_LLDIV
                         } else if (sizeof(unsigned long int)<=sizeof(long long int)) {
                           lldiv_t dsl_d;
                           dsl_d.quot = ull_arg/(unsigned long int)DECBASE;
                           dsl_d.rem = ull_arg%(unsigned long int)DECBASE;
                           if (inl_dgsp_lc) {  /* using digit group separation */
                             awcl_cur += inl_emax+inl_dgsp_tm*inl_dgsp_lo-1;
                             if (inl_dgsp_tm) {  /* write all digit groups that follow a separator */
                               inl_s=D_DIGGRPLEN;
                               while (TRUE) {
                                 do {
                                   *(awcl_cur)-- = HL_WCHAR_CAST('0'+dsl_d.rem);
                                   dsl_d = lldiv(dsl_d.quot,DECBASE);
                                 } while (--inl_s);
                                 awcl_cur -= inl_dgsp_lo;  /* skip digits-separator */
                                 if (--inl_dgsp_tm==0)
                                   break;
                                 inl_s=D_DIGGRPLEN;
                               }
                             }
                             if (inl_dgsp_ph) {  /* precision may provoke leading separator */
                               while (TRUE) {   /* write leading (maybe partial) digit group */
                                 *awcl_cur = HL_WCHAR_CAST('0'+dsl_d.rem);
                                 if (--inl_dgsp_ph == 0) break;
                                 awcl_cur--;
                                 dsl_d = lldiv(dsl_d.quot,DECBASE);
                               }
                             }
                           } else {  /* not using digit group separation */
                             while (TRUE) {
                               *(awcl_cur + --inl_emax) = HL_WCHAR_CAST('0'+dsl_d.rem);
                               if (inl_emax <= 0) break;
                               dsl_d = lldiv(dsl_d.quot,DECBASE);
                             }
                           }
#endif
                         } else {
#endif
                           if (inl_dgsp_lc) {  /* using digit group separation */
                             awcl_cur += inl_emax+inl_dgsp_tm*inl_dgsp_lo-1;
                             if (inl_dgsp_tm) {  /* write all digit groups that follow a separator */
                               inl_s=D_DIGGRPLEN;
                               while (TRUE) {
                                 do {
                                   *(awcl_cur)-- = HL_WCHAR_CAST('0'+ull_arg%(unsigned long int)DECBASE);
                                   ull_arg/=(unsigned long int)DECBASE;
                                 } while (--inl_s);
                                 awcl_cur -= inl_dgsp_lo;  /* skip digits-separator */
                                 if (--inl_dgsp_tm==0)
                                   break;
                                 inl_s=D_DIGGRPLEN;
                               }
                             }
                             if (inl_dgsp_ph) {  /* precision may provoke leading separator */
                               while (TRUE) {   /* write leading (maybe partial) digit group */
                                 *awcl_cur = HL_WCHAR_CAST('0'+ull_arg%(unsigned long int)DECBASE);
                                 if (--inl_dgsp_ph == 0) break;
                                 awcl_cur--;
                                 ull_arg/=(unsigned long int)DECBASE;
                               }
                             }
                           } else {  /* not using digit group separation */
                             while (--inl_emax > 0) {
                               *(awcl_cur+inl_emax) = HL_WCHAR_CAST('0'+ull_arg%(unsigned long int)DECBASE);
                               ull_arg/=(unsigned long int)DECBASE;
                             }
                             *awcl_cur = HL_WCHAR_CAST('0'+ull_arg);
                           }
#ifdef HL_USE_DIV
                         }
#endif
                         awcl_cur += inl_emax;
                       }
                       break;
                     case 'O':
                       inl_emax = 0;
                       achl_digits = chl_spec&'\040' ? chrstrans_lc : chrstrans;  /* choose upper- or lowercase */
                       if (ull_arg!=0) {
                         int inl_e = (sizeof(unsigned long int)<<3)/3;
                         if (inl_e*3 < sizeof(unsigned long int)<<3)
                           inl_e++;
                         do {
                           inl_s = inl_e>>1;
                           if (ull_arg >= (unsigned long int)1<<((inl_emax+inl_s)*3)) {
                             inl_emax += inl_s;
                             inl_e -= inl_s;
                           } else {
                             inl_e = inl_s;
                           }
                         } while (inl_e>1);
                         inl_emax ++;
                         /* now inl_emax is number of digits needed    */
                       }
                       inl_needed = inl_emax + inl_postfixlen;
                       if (inl_dgsp_lc) {   /* use digit group separation */
                         if (inl_emax<=D_DIGGRPLEN) {  /* digit grouping not in effect */
                           inl_dgsp_lc = 0;
                         } else {
                           const int inl_emax_1 = inl_emax-1;
#ifdef HL_USE_DIV
                           dsl_diggrp_dm = div(inl_emax_1, D_DIGGRPLEN);
                           inl_dgsp_ph++;
#else
                           inl_dgsp_tm = (inl_emax_1)/D_DIGGRPLEN;
                           inl_dgsp_ph = (inl_emax_1)%D_DIGGRPLEN+1;
#endif
                           if (inl_needed>=ull_field_width || inl_needed+inl_dgsp_tm*inl_dgsp_lc<=ull_field_width) {
                             inl_s = inl_dgsp_tm*inl_dgsp_lc;
                             inl_needed += inl_s;
                           } else {  /* prefer staying within fieldwidth over using the separator */
                             inl_dgsp_lc = 0;
                           }
                         }
                       }
                       if (!bol_precision) {
                         ull_precision = 1;  /* default precision      */
                         if (bol_padding_zero) {
                           if (ull_field_width>inl_needed && !bol_adjustleft) {
                             /* fake padding with '0' by ull_precision */
                             ull_precision = ull_field_width+(inl_dgsp_lc?inl_emax+inl_s:inl_emax)-inl_needed;
                           } else {
                             bol_padding_zero = false;  /* according to spec, zeroflag is ignored in
                                               integer conversion if left-justify-flag is present */
                           }
                         }
                       } else {
                         bol_padding_zero = false;  /* according to spec, zeroflag is ignored in
                                                       integer conversion if a precision is given */
                       }
                       if (inl_dgsp_lc) {   /* using digit group separation */
                         inl_precpad = ull_precision-(inl_emax+inl_s);
                         if (inl_precpad>0) {
#ifdef HL_USE_DIV
                           div_t dsl_d = div(inl_dgsp_ph+inl_precpad, D_DIGGRPLEN+inl_dgsp_lc);
                           inl_dgsp_tm += dsl_d.quot;
                           inl_needed += inl_precpad;
                           inl_dgsp_ph = dsl_d.rem;
#else
                           inl_needed += inl_precpad;
                           inl_dgsp_tm += (inl_dgsp_ph+inl_precpad)/(D_DIGGRPLEN+inl_dgsp_lc);
                           inl_dgsp_ph = (inl_dgsp_ph+inl_precpad)%(D_DIGGRPLEN+inl_dgsp_lc);
#endif
                           if (inl_dgsp_ph>D_DIGGRPLEN) {
                            if (bol_alternate_form && (ull_arg!=0) &&
                                !(bol_padding_zero && (ull_precision>inl_emax+inl_dgsp_tm*D_DIGGRPLEN)))
                            {               /* ensure octal prefix     */
                             inl_dgsp_tm++;
                             ull_precision += 1+inl_dgsp_lc+D_DIGGRPLEN-inl_dgsp_ph;
                             inl_needed += 1+inl_dgsp_lc+D_DIGGRPLEN-inl_dgsp_ph;
                             inl_dgsp_ph = 1;
                            } else {
                             inl_needed -= inl_dgsp_ph-D_DIGGRPLEN;
                             inl_dgsp_ph = D_DIGGRPLEN;
                            }
                           } else if (bol_alternate_form && (inl_dgsp_ph==0) && (ull_arg!=0)) {
                             if (bol_padding_zero && (ull_precision-inl_dgsp_lc>inl_emax+(inl_dgsp_tm-1)*D_DIGGRPLEN)) {
                               /* prefer staying within fieldwidth over avoiding all spacepadding */
                               inl_dgsp_tm--;
                               ull_precision -= inl_dgsp_lc;
                               inl_needed -= inl_dgsp_lc;
                               inl_dgsp_ph = D_DIGGRPLEN;
                             } else {
                               ull_precision++;
                               inl_needed++;
                               inl_dgsp_ph=1;
                             }
                           }
                           inl_precpad = ull_precision-(inl_emax+inl_dgsp_tm*inl_dgsp_lc);
                         } else {
                          if (bol_alternate_form && (ull_arg!=0)) {  /* ensure octal prefix */
                            if (inl_dgsp_ph>=D_DIGGRPLEN) {
                              inl_dgsp_tm++;
                              ull_precision += 1+inl_dgsp_lc+D_DIGGRPLEN-inl_dgsp_ph;
                              inl_needed += 1+inl_dgsp_lc+D_DIGGRPLEN-inl_dgsp_ph;
                              inl_dgsp_ph = 1;
                            } else {
                              ull_precision++;
                              inl_needed++;
                              inl_dgsp_ph++;
                            }
                            inl_precpad++;
                          } else {
                           inl_precpad=0;
                          }
                         }
                       } else {    /* not using digit group separation */
                         if (bol_alternate_form && (ull_arg!=0) && (ull_precision<=inl_emax))
                           ull_precision = inl_emax+1;  /* cause octal prefix */
                         inl_precpad = ull_precision-inl_emax;
                         if (inl_precpad>0) {
                           inl_needed += inl_precpad;
                         } else {
                           inl_precpad=0;
                         }
                       }
                       if (ull_field_width > inl_needed) {
                         awcl_after = awcl_cur+ull_field_width;
                         inl_padsp = ull_field_width-inl_needed;
                         if (!bol_adjustleft) {  /* padding left with spaces */
                           if (inl_padsp > awcl_end-awcl_cur)
                             {awcl_after = awcl_cur; break;}  /* overflow */
                           do
                             *awcl_cur++ = HL_WCHAR_CAST(' ');
                           while (--inl_padsp);
                         }
                       } else {
                         awcl_after = awcl_cur+inl_needed;
                         inl_padsp = 0;
                       }
                       if (inl_dgsp_lc) {   /* set digit group separators */
                         /* produce the first separator                                     */
                         awcl_dg = awcl_cur+inl_dgsp_ph;
                         if (iel_cs_target == ied_chs_utf_16) {  /* natural endian */
                           inl_dgsp_lo = m_u16l_from_u8l(awcl_dg, awcl_end-awcl_dg, achl_dgsp, inl_dgsp_lb);
                         } else {           /* swapped endian          */
                           inl_dgsp_lo = m_u16r_from_u8l(awcl_dg, 1+awcl_end-awcl_dg, achl_dgsp, inl_dgsp_lb);
                         }
                         /* now the complete physical output length can be determined      */
                         inl_s = inl_dgsp_tm*(inl_dgsp_lo-inl_dgsp_lc);  /* adjustment from logical to physical */
                         awcl_after += inl_s;
                         if (inl_dgsp_lo<0 || awcl_after-awcl_cur>awcl_end-awcl_cur)
                           {awcl_after = awcl_cur; break;}  /* overflow */
                         /* copy the other separators from the first one                   */
                         inl_s = inl_dgsp_tm-1;
                         if (inl_s) {
                           awcl0 = awcl_dg+inl_dgsp_lo;
                           do {
                             awcl0 += D_DIGGRPLEN;
                             int inl2 = 0;
                             do
                               *awcl0++ = awcl_dg[inl2++];
                             while (inl2<inl_dgsp_lo);
                           } while (--inl_s);
                         }
                         /* padding left with zeroes to "precision"                        */
                         while (inl_precpad) {
                           if (inl_dgsp_ph == 0) {  /* skip digits-separator */
                             awcl_cur += inl_dgsp_lo;
                             inl_dgsp_ph = D_DIGGRPLEN-1;
                             inl_dgsp_tm--;
                             if (!inl_dgsp_tm)
                               break;
                           } else {
                             inl_dgsp_ph--;
                           }
                           *awcl_cur++ = HL_WCHAR_CAST('0');
                           inl_precpad --;
                         }
                       } else {             /* not using digit group separation */
                         if (awcl_after-awcl_cur>awcl_end-awcl_cur)
                           {awcl_after = awcl_cur; break;}  /* overflow */
                         /* padding left with zeroes to "precision"    */
                         while (inl_precpad) {
                           *awcl_cur++ = HL_WCHAR_CAST('0');
                           inl_precpad --;
                         }
                       }
                       /* postfix                                      */
                       if (inl_postfixlen) {
                         if (inl_postfixlen==2) {
                           *(awcl_after-(inl_padsp+2)) = HL_WCHAR_CAST(chl_postfix);
                           *(awcl_after-(inl_padsp+1)) = HL_WCHAR_CAST('i');
                         } else {
                           *(awcl_after-(inl_padsp+1)) = HL_WCHAR_CAST(chl_postfix);
                         }
                       }
                       /* padding right with spaces                    */
                       if (inl_padsp) {
                         awcl0 = awcl_after-1;
                         do
                           *awcl0-- = HL_WCHAR_CAST(' ');
                         while (--inl_padsp);
                       }
                       if (inl_emax!=0) {  /* done if zero-"precision" zero */
                         inl_emax --;
                         inl_emax *= 3;
                         if (inl_dgsp_lc) {  /* using digit group separation */
                           while (TRUE) {
                             while (inl_dgsp_ph) {
                               *(awcl_cur)++ = HL_WCHAR_CAST(achl_digits[(ull_arg>>inl_emax) & (1<<3)-1]);
                               inl_dgsp_ph--;
                               inl_emax -= 3;
                             }
                             inl_dgsp_tm--;
                             if (!inl_dgsp_tm)
                               break;       /* all digitgroups done    */
                             awcl_cur += inl_dgsp_lo;  /* skip digits-separator */
                             inl_dgsp_ph = D_DIGGRPLEN-1;
                           }
                         } else {  /* not using digit group separation */
                           while(TRUE) {
                             *(awcl_cur) = HL_WCHAR_CAST(achl_digits[(ull_arg>>inl_emax) & (1<<3)-1]);
                             if (inl_emax==0)
                               break;
                             (awcl_cur)++;
                             inl_emax -= 3;
                           }
                         }
                       }
                       break;
                     case 'X':
                       inl_emax = 0;
                       achl_digits = chl_spec&'\040' ? chrstrans_lc : chrstrans;  /* choose upper- or lowercase */
                       if (ull_arg!=0) {
                         int inl_e = (sizeof(unsigned long int)<<3)/4;
                         if (inl_e*4 < sizeof(unsigned long int)<<3)
                           inl_e++;
                         do {
                           inl_s = inl_e>>1;
                           if (ull_arg >= (unsigned long int)1<<((inl_emax+inl_s)*4)) {
                             inl_emax += inl_s;
                             inl_e -= inl_s;
                           } else {
                             inl_e = inl_s;
                           }
                         } while (inl_e>1);
                         inl_emax ++;
                         /* now inl_emax is number of digits needed    */
                       }
                       inl_needed = inl_emax + inl_postfixlen;
                       if (bol_alternate_form && (ull_arg!=0))
                         inl_needed += 2;   /* for hex prefix          */
                       if (inl_dgsp_lc) {   /* use digit group separation */
                         if (inl_emax<=D_DIGGRPLEN) {  /* digit grouping not in effect */
                           inl_dgsp_lc = 0;
                         } else {
                           const int inl_emax_1 = inl_emax-1;
#ifdef HL_USE_DIV
                           dsl_diggrp_dm = div(inl_emax_1, D_DIGGRPLEN);
                           inl_dgsp_ph++;
#else
                           inl_dgsp_tm = (inl_emax_1)/D_DIGGRPLEN;
                           inl_dgsp_ph = (inl_emax_1)%D_DIGGRPLEN+1;
#endif
                           if (inl_needed>=ull_field_width || inl_needed+inl_dgsp_tm*inl_dgsp_lc<=ull_field_width) {
                             inl_s = inl_dgsp_tm*inl_dgsp_lc;
                             inl_needed += inl_s;
                           } else {  /* prefer staying within fieldwidth over using the separator */
                             inl_dgsp_lc = 0;
                           }
                         }
                       }
                       if (!bol_precision) {
                         ull_precision = 1;  /* default precision      */
                         if (bol_padding_zero) {
                           if (ull_field_width>inl_needed && !bol_adjustleft) {
                             /* fake padding with '0' by ull_precision */
                             ull_precision = ull_field_width+(inl_dgsp_lc?inl_emax+inl_s:inl_emax)-inl_needed;
                           }
                         }
                       }
                       if (inl_dgsp_lc) {   /* using digit group separation */
                         inl_precpad = ull_precision-(inl_emax+inl_s);
                         if (inl_precpad>0) {
#ifdef HL_USE_DIV
                           div_t dsl_d = div(inl_dgsp_ph+inl_precpad, D_DIGGRPLEN+inl_dgsp_lc);
                           inl_dgsp_tm += dsl_d.quot;
                           inl_needed += inl_precpad;
                           inl_dgsp_ph = dsl_d.rem;
#else
                           inl_needed += inl_precpad;
                           inl_dgsp_tm += (inl_dgsp_ph+inl_precpad)/(D_DIGGRPLEN+inl_dgsp_lc);
                           inl_dgsp_ph = (inl_dgsp_ph+inl_precpad)%(D_DIGGRPLEN+inl_dgsp_lc);
#endif
                           if (inl_dgsp_ph>D_DIGGRPLEN) {
                             inl_needed -= inl_dgsp_ph-D_DIGGRPLEN;
                             inl_dgsp_ph = D_DIGGRPLEN;
                           }
                           inl_precpad = ull_precision-(inl_emax+inl_dgsp_tm*inl_dgsp_lc);
                         } else {
                           inl_precpad=0;
                         }
                       } else {    /* not using digit group separation */
                         inl_precpad = ull_precision-inl_emax;
                         if (inl_precpad>0) {
                           inl_needed += inl_precpad;
                         } else {
                           inl_precpad=0;
                         }
                       }
                       if (ull_field_width > inl_needed) {
                         awcl_after = awcl_cur+ull_field_width;
                         inl_padsp = ull_field_width-inl_needed;
                         if (!bol_adjustleft) {  /* padding left with spaces */
                           if (inl_padsp > awcl_end-awcl_cur)
                             {awcl_after = awcl_cur; break;}  /* overflow */
                           do
                             *awcl_cur++ = HL_WCHAR_CAST(' ');
                           while (--inl_padsp);
                         }
                       } else {
                         awcl_after = awcl_cur+inl_needed;
                         inl_padsp = 0;
                       }
                       if (inl_dgsp_lc) {   /* set digit group separators */
                         if (bol_alternate_form && (ull_arg!=0)) {  /* write hex prefix    */
                           if (2 > awcl_end-awcl_cur)
                             {awcl_after = awcl_cur; break;}  /* overflow */
                           *awcl_cur++ = HL_WCHAR_CAST('0');
                           *awcl_cur++ = HL_WCHAR_CAST('X'|(chl_spec&'\040'));
                         }
                         /* produce the first separator                                     */
                         awcl_dg = awcl_cur+inl_dgsp_ph;
                         if (iel_cs_target == ied_chs_utf_16) {  /* natural endian */
                           inl_dgsp_lo = m_u16l_from_u8l(awcl_dg, awcl_end-awcl_dg, achl_dgsp, inl_dgsp_lb);
                         } else {           /* swapped endian          */
                           inl_dgsp_lo = m_u16r_from_u8l(awcl_dg, 1+awcl_end-awcl_dg, achl_dgsp, inl_dgsp_lb);
                         }
                         /* now the complete physical output length can be determined      */
                         inl_s = inl_dgsp_tm*(inl_dgsp_lo-inl_dgsp_lc);  /* adjustment from logical to physical */
                         awcl_after += inl_s;
                         if (inl_dgsp_lo<0 || awcl_after-awcl_cur>awcl_end-awcl_cur)
                           {awcl_after = awcl_cur; break;}  /* overflow */
                         /* copy the other separators from the first one                   */
                         inl_s = inl_dgsp_tm-1;
                         if (inl_s) {
                           awcl0 = awcl_dg+inl_dgsp_lo;
                           do {
                             awcl0 += D_DIGGRPLEN;
                             int inl2 = 0;
                             do
                               *awcl0++ = awcl_dg[inl2++];
                             while (inl2<inl_dgsp_lo);
                           } while (--inl_s);
                         }
                         /* padding left with zeroes to "precision"                        */
                         while (inl_precpad) {
                           if (inl_dgsp_ph == 0) {  /* skip digits-separator */
                             awcl_cur += inl_dgsp_lo;
                             inl_dgsp_ph = D_DIGGRPLEN-1;
                             inl_dgsp_tm--;
                             if (!inl_dgsp_tm)
                               break;
                           } else {
                             inl_dgsp_ph--;
                           }
                           *awcl_cur++ = HL_WCHAR_CAST('0');
                           inl_precpad --;
                         }
                       } else {             /* not using digit group separation */
                         if (awcl_after-awcl_cur>awcl_end-awcl_cur)
                           {awcl_after = awcl_cur; break;}  /* overflow */
                         if (bol_alternate_form && (ull_arg!=0)) {  /* write hex prefix */
                           *awcl_cur++ = HL_WCHAR_CAST('0');
                           *awcl_cur++ = HL_WCHAR_CAST('X'|(chl_spec&'\040'));
                         }
                         /* padding left with zeroes to "precision"    */
                         while (inl_precpad) {
                           *awcl_cur++ = HL_WCHAR_CAST('0');
                           inl_precpad --;
                         }
                       }
                       /* postfix                                      */
                       if (inl_postfixlen) {
                         if (inl_postfixlen==2) {
                           *(awcl_after-(inl_padsp+2)) = HL_WCHAR_CAST(chl_postfix);
                           *(awcl_after-(inl_padsp+1)) = HL_WCHAR_CAST('i');
                         } else {
                           *(awcl_after-(inl_padsp+1)) = HL_WCHAR_CAST(chl_postfix);
                         }
                       }
                       /* padding right with spaces                    */
                       if (inl_padsp) {
                         awcl0 = awcl_after-1;
                         do
                           *awcl0-- = HL_WCHAR_CAST(' ');
                         while (--inl_padsp);
                       }
                       if (inl_emax!=0) {  /* done if zero-"precision" zero */
                         inl_emax --;
                         inl_emax *= 4;
                         if (inl_dgsp_lc) {  /* using digit group separation */
                           while (TRUE) {
                             while (inl_dgsp_ph) {
                               *(awcl_cur)++ = HL_WCHAR_CAST(achl_digits[(ull_arg>>inl_emax) & (1<<4)-1]);
                               inl_dgsp_ph--;
                               inl_emax -= 4;
                             }
                             inl_dgsp_tm--;
                             if (!inl_dgsp_tm)
                               break;       /* all digitgroups done    */
                             awcl_cur += inl_dgsp_lo;  /* skip digits-separator */
                             inl_dgsp_ph = D_DIGGRPLEN-1;
                           }
                         } else {  /* not using digit group separation */
                           while(TRUE) {
                             *(awcl_cur) = HL_WCHAR_CAST(achl_digits[(ull_arg>>inl_emax) & (1<<4)-1]);
                             if (inl_emax==0)
                               break;
                             (awcl_cur)++;
                             inl_emax -= 4;
                           }
                         }
                       }
                       break;
                   }
                 }
                 break;
             }
           }
           } else {                         /* swapped endian          */
           if(adsl_arginfs!=NULL) {
             printf("Error: (ucs) with numeric type in format");
             break;
           }
#ifdef TRACEHL1
#if _RWDEBUG
           printf("numeric values: %c\n", *achl_format );
#endif
#endif
           ull_str_arg_l = 0;
           if(umrs_format[(UINT) chl_spec] == 6) { /* Signed: d D i    */
             chl_spec = 'd';
             switch(chl_length_modifier) {
               case '\0': case 'h':
                 iml_arg1 = va_arg(dsl_list, int);
                       /* determine sign and go on with non-negative X */
                       if (iml_arg1 > 0) {
                         chl_sign = achl_signed[2];
                       } else {
                         if (iml_arg1 != 0)
                         {
                           chl_sign = achl_signed[0];
                           iml_arg1=0-iml_arg1; /* replace negative X by its abs-value */
                           if ((signed int)iml_arg1<0) {  /* special case: X was the extreme negative value */
                             /*inl_emax = (((sizeof(signed int)*8-1)*30103)/100000)+1;*/
                             iml_arg1=(signed int)(-1)-iml_arg1; /* 7fff... */
                             if (iel_scaling==ied_scaling_none) {
                               chl_postfix = '1'+iml_arg1%DECBASE;  /* decimal carry cannot happen here */
                               inl_postfixlen = 1;
                               inl_pfdgph = 1;
                               ull_precision--;
                               iml_arg1/=DECBASE;
                             }
                           }
                         } else {
                           chl_sign = achl_signed[1];
                         }
                       }
                       inl_needed = chl_sign?1:0;

                       /* prepare %(sci-dec)- or %(sci-dec)-type of rendering */
                       if (iel_scaling!=ied_scaling_none) {
                         if (iel_scaling == ied_scaling_1000) {  /* power-of-1000-scaled */
#if HL_PRFMAXSO_I > 4
                           if ((sizeof(signed int) > 4) && (iml_arg1 >= D_L1000RD * unrs_decpowbuf[9])) {
#if HL_PRFMAXSO_I > 8
                             if (
                                 (sizeof(signed int) > 8) &&
                                 (iml_arg1 >= D_L1000RD * unrs_decpowbuf[15])
                                ) {
                               if (
                                   (iml_arg1 >= D_L1000RD * unrs_decpowbuf[18])
                                  ) {
                                 if (iml_arg1 >= D_L1000RD * unrs_decpowbuf[21]) {
                                   iml_arg1 =  (iml_arg1 + 500 * unrs_decpowbuf[21]) / (unrs_decpowbuf[24]);
                                   chl_postfix = 'Y';
                                 } else {
                                   iml_arg1 =  (iml_arg1 + 500 * unrs_decpowbuf[18]) / (unrs_decpowbuf[21]);
                                   chl_postfix = 'Z';
                                 }
                               } else {
                                 iml_arg1 =  (iml_arg1 + 500 * unrs_decpowbuf[15]) / (unrs_decpowbuf[18]);
                                 chl_postfix = 'E';
                               }
                             } else {
#endif
                               if (iml_arg1 >= D_L1000RD * unrs_decpowbuf[12]) {
                                 iml_arg1 =  (iml_arg1 + 500 * unrs_decpowbuf[12]) / (unrs_decpowbuf[15]);
                                 chl_postfix = 'P';
                               } else {
                                 iml_arg1 =  (iml_arg1 + 500 * unrs_decpowbuf[9]) / (unrs_decpowbuf[12]);
                                 chl_postfix = 'T';
                               }
#if HL_PRFMAXSO_I > 8
                             }
#endif
                             inl_postfixlen = 1;
                           } else {
#endif
#if HL_PRFMAXSO_I > 2
                             if ((sizeof(signed int) > 2) && (iml_arg1 >= D_L1000RD * unrs_decpowbuf[3])) {
#if HL_PRFMAXSO_I > 4
                               if ((sizeof(signed int) > 4) && (iml_arg1 >= D_L1000RD * unrs_decpowbuf[6])) {
                                 iml_arg1 =  (iml_arg1 + 500 * unrs_decpowbuf[6]) / (unrs_decpowbuf[9]);
                                 chl_postfix = 'G';
                               } else {
#endif
                                 iml_arg1 =  (iml_arg1 + 500 * unrs_decpowbuf[3]) / (unrs_decpowbuf[6]);
                                 chl_postfix = 'M';
#if HL_PRFMAXSO_I > 4
                               }
#endif
                               inl_postfixlen = 1;
                             } else {
#endif
                               if (iml_arg1 >= D_L1000RD) {
                                 iml_arg1 = (iml_arg1 + 500) / 1000;
                                 chl_postfix = 'k';
                                 inl_postfixlen = 1;
                               }
#if HL_PRFMAXSO_I > 2
                             }
#endif
#if HL_PRFMAXSO_I > 4
                           }
#endif
                         }
                         else {               /* power-of-1024-scaled    */
#if HL_PRFMAXSO_I > 4
                           if ((sizeof(signed int) > 4) && (iml_arg1>>30 >= D_L1024RD)) {
#if HL_PRFMAXSO_I > 8
                             if (
                                 (sizeof(signed int) > 8) &&
                                 (iml_arg1>>50 >= D_L1024RD)
                                ) {
                               if (
                                   (iml_arg1>>60 >= D_L1024RD)
                                  ) {
                                 if (iml_arg1>>70 >= D_L1024RD) {
                                   iml_arg1 = (iml_arg1+((signed int)1<<79)) >> 80;
                                   chl_postfix = 'Y';
                                 } else {
                                   iml_arg1 = (iml_arg1+((signed int)1<<69)) >> 70;
                                   chl_postfix = 'Z';
                                 }
                               } else {
                                 iml_arg1 = (iml_arg1+((signed int)1<<59)) >> 60;
                                 chl_postfix = 'E';
                               }
                             } else {
#endif
                               if (iml_arg1>>40 >= D_L1024RD) {
                                 iml_arg1 = (iml_arg1+((signed int)1<<49)) >> 50;
                                 chl_postfix = 'P';
                               } else {
                                 iml_arg1 = (iml_arg1+((signed int)1<<39)) >> 40;
                                 chl_postfix = 'T';
                               }
#if HL_PRFMAXSO_I > 8
                             }
#endif
                             inl_postfixlen = bol_alternate_form ? 2 : 1;
                           } else {
#endif
#if HL_PRFMAXSO_I > 2
                             if ((sizeof(signed int) > 2) && (iml_arg1>>10 >= D_L1024RD)) {
#if HL_PRFMAXSO_I > 4
                               if ((sizeof(signed int) > 4) && (iml_arg1>>20 >= D_L1024RD)) {
                                 iml_arg1 = (iml_arg1+((signed int)1<<29)) >> 30;
                                 chl_postfix = 'G';
                               } else {
#endif
                                 iml_arg1 = (iml_arg1+((signed int)1<<19)) >> 20;
                                 chl_postfix = 'M';
#if HL_PRFMAXSO_I > 4
                               }
#endif
                               inl_postfixlen = bol_alternate_form ? 2 : 1;
                             } else {
#endif
                               if (iml_arg1 >= D_L1024RD) {
                                 iml_arg1 = (iml_arg1+0x200) >> 10;
                                 chl_postfix = 'K';
                                 inl_postfixlen = bol_alternate_form ? 2 : 1;
                               }
#if HL_PRFMAXSO_I > 2
                             }
#endif
#if HL_PRFMAXSO_I > 4
                           }
#endif
                         }
                       }

                       /* detect the order of magnitude of X           */
                       inl_emax = 0;
                       if (iml_arg1) {
                         int inl_e = (((sizeof(signed int)*8-1)*30103)/100000)+1;
                         do {
                           inl_s = inl_e>>1;
                           if (iml_arg1 >= unrs_decpowbuf[inl_emax+inl_s]) {
                             inl_emax += inl_s;
                             inl_e -= inl_s;
                           } else {
                             inl_e = inl_s;
                           }
                         } while (inl_e>1);
                         inl_emax ++;
                       }
                       inl_needed += inl_emax + inl_postfixlen;
                       if (inl_dgsp_lc) {   /* use digit group separation */
                         if (inl_emax<=D_DIGGRPLEN) {  /* digit grouping not in effect */
                           inl_dgsp_lc = 0;
                         } else {
                           const int inl_emax_1 = inl_emax+inl_pfdgph-1;
#ifdef HL_USE_DIV
                           dsl_diggrp_dm = div(inl_emax_1, D_DIGGRPLEN);
                           inl_dgsp_ph++;
#else
                           inl_dgsp_tm = (inl_emax_1)/D_DIGGRPLEN;
                           inl_dgsp_ph = (inl_emax_1)%D_DIGGRPLEN+1;
#endif
                           if (inl_needed>=ull_field_width || inl_needed+inl_dgsp_tm*inl_dgsp_lc<=ull_field_width) {
                             inl_s = inl_dgsp_tm*inl_dgsp_lc;
                             inl_needed += inl_s;
                           } else {  /* prefer staying within fieldwidth over using the separator */
                             inl_dgsp_lc = 0;
                           }
                         }
                       }
                       if (!bol_precision) {
                         ull_precision = 1;  /* default precision      */
                         if (bol_padding_zero) {
                           if (ull_field_width>inl_needed && !bol_adjustleft) {
                             /* fake padding with '0' by ull_precision */
                             ull_precision = ull_field_width+(inl_dgsp_lc?inl_emax+inl_s:inl_emax)-inl_needed;
                           }
                         }
                       }
                       if (inl_dgsp_lc) {   /* using digit group separation */
                         inl_precpad = ull_precision-(inl_emax+inl_s);
                         if (inl_precpad>0) {
#ifdef HL_USE_DIV
                           div_t dsl_d = div(inl_dgsp_ph+inl_precpad, D_DIGGRPLEN+inl_dgsp_lc);
                           inl_dgsp_tm += dsl_d.quot;
                           inl_needed += inl_precpad;
                           inl_dgsp_ph = dsl_d.rem;
#else
                           inl_needed += inl_precpad;
                           inl_dgsp_tm += (inl_dgsp_ph+inl_precpad)/(D_DIGGRPLEN+inl_dgsp_lc);
                           inl_dgsp_ph = (inl_dgsp_ph+inl_precpad)%(D_DIGGRPLEN+inl_dgsp_lc);
#endif
                           if (inl_dgsp_ph>D_DIGGRPLEN) {
                             inl_needed -= inl_dgsp_ph-D_DIGGRPLEN;
                             inl_dgsp_ph = D_DIGGRPLEN;
                           }
                           inl_precpad = ull_precision-(inl_emax+inl_dgsp_tm*inl_dgsp_lc);
                         } else {
                           inl_precpad=0;
                         }
                       } else {    /* not using digit group separation */
                         inl_precpad = ull_precision-inl_emax;
                         if (inl_precpad>0) {
                           inl_needed += inl_precpad;
                         } else {
                           inl_precpad=0;
                         }
                       }
                       if (ull_field_width > inl_needed) {
                         awcl_after = awcl_cur+ull_field_width;
                         inl_padsp = ull_field_width-inl_needed;
                         if (!bol_adjustleft) {  /* padding left with spaces */
                           if (inl_padsp > awcl_end-awcl_cur)
                             {awcl_after = awcl_cur; break;}  /* overflow */
                           do
                             *awcl_cur++ = HL_ENDIANSWAP_FROM_BYTE(' ');
                           while (--inl_padsp);
                         }
                       } else {
                         awcl_after = awcl_cur+inl_needed;
                         inl_padsp = 0;
                       }
                       if (inl_dgsp_lc) {   /* set digit group separators */
                         if (chl_sign) {    /* write sign prefix       */
                           if (1 > awcl_end-awcl_cur)
                             {awcl_after = awcl_cur; break;}  /* overflow */
                           *awcl_cur++ = HL_ENDIANSWAP_FROM_BYTE(chl_sign);
                         }
                         /* produce the first separator                                     */
                         awcl_dg = awcl_cur+inl_dgsp_ph;
                         if (iel_cs_target == ied_chs_utf_16) {  /* natural endian */
                           inl_dgsp_lo = m_u16l_from_u8l(awcl_dg, awcl_end-awcl_dg, achl_dgsp, inl_dgsp_lb);
                         } else {           /* swapped endian          */
                           inl_dgsp_lo = m_u16r_from_u8l(awcl_dg, 1+awcl_end-awcl_dg, achl_dgsp, inl_dgsp_lb);
                         }
                         /* now the complete physical output length can be determined      */
                         inl_s = inl_dgsp_tm*(inl_dgsp_lo-inl_dgsp_lc);  /* adjustment from logical to physical */
                         awcl_after += inl_s;
                         if (inl_dgsp_lo<0 || awcl_after-awcl_cur>awcl_end-awcl_cur)
                           {awcl_after = awcl_cur; break;}  /* overflow */
                         /* copy the other separators from the first one                   */
                         inl_s = inl_dgsp_tm-1;
                         if (inl_s) {
                           awcl0 = awcl_dg+inl_dgsp_lo;
                           do {
                             awcl0 += D_DIGGRPLEN;
                             int inl2 = 0;
                             do
                               *awcl0++ = awcl_dg[inl2++];
                             while (inl2<inl_dgsp_lo);
                           } while (--inl_s);
                         }
                         /* padding left with zeroes to "precision"                        */
                         while (inl_precpad) {
                           if (inl_dgsp_ph == 0) {  /* skip digits-separator */
                             awcl_cur += inl_dgsp_lo;
                             inl_dgsp_ph = D_DIGGRPLEN-1;
                             inl_dgsp_tm--;
                             if (!inl_dgsp_tm)
                               break;
                           } else {
                             inl_dgsp_ph--;
                           }
                           *awcl_cur++ = HL_ENDIANSWAP_FROM_BYTE('0');
                           inl_precpad --;
                         }
                       } else {             /* not using digit group separation */
                         if (awcl_after-awcl_cur>awcl_end-awcl_cur)
                           {awcl_after = awcl_cur; break;}  /* overflow */
                         if (chl_sign)      /* write sign prefix       */
                           *awcl_cur++ = HL_ENDIANSWAP_FROM_BYTE(chl_sign);
                         /* padding left with zeroes to "precision"    */
                         while (inl_precpad) {
                           *awcl_cur++ = HL_ENDIANSWAP_FROM_BYTE('0');
                           inl_precpad --;
                         }
                       }
                       /* postfix                                      */
                       if (inl_postfixlen) {
                         if (inl_postfixlen==2) {
                           *(awcl_after-(inl_padsp+2)) = HL_ENDIANSWAP_FROM_BYTE(chl_postfix);
                           *(awcl_after-(inl_padsp+1)) = HL_ENDIANSWAP_FROM_BYTE('i');
                         } else {
                           *(awcl_after-(inl_padsp+1)) = HL_ENDIANSWAP_FROM_BYTE(chl_postfix);
                         }
                       }
                       /* padding right with spaces                    */
                       if (inl_padsp) {
                         awcl0 = awcl_after-1;
                         do
                           *awcl0-- = HL_ENDIANSWAP_FROM_BYTE(' ');
                         while (--inl_padsp);
                       }
                       /* produce the digits                           */
                       if (inl_emax > 0) {
#ifdef HL_USE_DIV
                         if (sizeof(signed int)<=sizeof(int)) {
                           div_t dsl_d;
                           dsl_d = div(iml_arg1,DECBASE);
                           if (inl_dgsp_lc) {  /* using digit group separation */
                             awcl_cur += inl_emax+inl_dgsp_tm*inl_dgsp_lo-1;
                             if (inl_dgsp_tm) {  /* write all digit groups that follow a separator */
                               inl_s=D_DIGGRPLEN-inl_pfdgph;
                               while (TRUE) {
                                 do {
                                   *(awcl_cur)-- = HL_ENDIANSWAP_FROM_BYTE('0'+dsl_d.rem);
                                   dsl_d = div(dsl_d.quot,DECBASE);
                                 } while (--inl_s);
                                 awcl_cur -= inl_dgsp_lo;  /* skip digits-separator */
                                 if (--inl_dgsp_tm==0)
                                   break;
                                 inl_s=D_DIGGRPLEN;
                               }
                             }
                             if (inl_dgsp_ph) {  /* precision may provoke leading separator */
                               while (TRUE) {   /* write leading (maybe partial) digit group */
                                 *awcl_cur = HL_ENDIANSWAP_FROM_BYTE('0'+dsl_d.rem);
                                 if (--inl_dgsp_ph == 0) break;
                                 awcl_cur--;
                                 dsl_d = div(dsl_d.quot,DECBASE);
                               }
                             }
                           } else {  /* not using digit group separation */
                             while (TRUE) {
                               *(awcl_cur + --inl_emax) = HL_ENDIANSWAP_FROM_BYTE('0'+dsl_d.rem);
                               if (inl_emax <= 0) break;
                               dsl_d = div(dsl_d.quot,DECBASE);
                             }
                           }
#ifdef HL_USE_LDIV
                         } else if (sizeof(signed int)<=sizeof(long int)) {
                           ldiv_t dsl_d;
                           dsl_d = ldiv(iml_arg1,DECBASE);
                           if (inl_dgsp_lc) {  /* using digit group separation */
                             awcl_cur += inl_emax+inl_dgsp_tm*inl_dgsp_lo-1;
                             if (inl_dgsp_tm) {  /* write all digit groups that follow a separator */
                               inl_s=D_DIGGRPLEN-inl_pfdgph;
                               while (TRUE) {
                                 do {
                                   *(awcl_cur)-- = HL_ENDIANSWAP_FROM_BYTE('0'+dsl_d.rem);
                                   dsl_d = ldiv(dsl_d.quot,DECBASE);
                                 } while (--inl_s);
                                 awcl_cur -= inl_dgsp_lo;  /* skip digits-separator */
                                 if (--inl_dgsp_tm==0)
                                   break;
                                 inl_s=D_DIGGRPLEN;
                               }
                             }
                             if (inl_dgsp_ph) {  /* precision may provoke leading separator */
                               while (TRUE) {   /* write leading (maybe partial) digit group */
                                 *awcl_cur = HL_ENDIANSWAP_FROM_BYTE('0'+dsl_d.rem);
                                 if (--inl_dgsp_ph == 0) break;
                                 awcl_cur--;
                                 dsl_d = ldiv(dsl_d.quot,DECBASE);
                               }
                             }
                           } else {  /* not using digit group separation */
                             while (TRUE) {
                               *(awcl_cur + --inl_emax) = HL_ENDIANSWAP_FROM_BYTE('0'+dsl_d.rem);
                               if (inl_emax <= 0) break;
                               dsl_d = ldiv(dsl_d.quot,DECBASE);
                             }
                           }
#endif
#ifdef HL_USE_LLDIV
                         } else if (sizeof(signed int)<=sizeof(long long int)) {
                           lldiv_t dsl_d;
                           dsl_d = lldiv(iml_arg1,DECBASE);
                           if (inl_dgsp_lc) {  /* using digit group separation */
                             awcl_cur += inl_emax+inl_dgsp_tm*inl_dgsp_lo-1;
                             if (inl_dgsp_tm) {  /* write all digit groups that follow a separator */
                               inl_s=D_DIGGRPLEN-inl_pfdgph;
                               while (TRUE) {
                                 do {
                                   *(awcl_cur)-- = HL_ENDIANSWAP_FROM_BYTE('0'+dsl_d.rem);
                                   dsl_d = lldiv(dsl_d.quot,DECBASE);
                                 } while (--inl_s);
                                 awcl_cur -= inl_dgsp_lo;  /* skip digits-separator */
                                 if (--inl_dgsp_tm==0)
                                   break;
                                 inl_s=D_DIGGRPLEN;
                               }
                             }
                             if (inl_dgsp_ph) {  /* precision may provoke leading separator */
                               while (TRUE) {   /* write leading (maybe partial) digit group */
                                 *awcl_cur = HL_ENDIANSWAP_FROM_BYTE('0'+dsl_d.rem);
                                 if (--inl_dgsp_ph == 0) break;
                                 awcl_cur--;
                                 dsl_d = lldiv(dsl_d.quot,DECBASE);
                               }
                             }
                           } else {  /* not using digit group separation */
                             while (TRUE) {
                               *(awcl_cur + --inl_emax) = HL_ENDIANSWAP_FROM_BYTE('0'+dsl_d.rem);
                               if (inl_emax <= 0) break;
                               dsl_d = lldiv(dsl_d.quot,DECBASE);
                             }
                           }
#endif
                         } else {
#endif
                           if (inl_dgsp_lc) {  /* using digit group separation */
                             awcl_cur += inl_emax+inl_dgsp_tm*inl_dgsp_lo-1;
                             if (inl_dgsp_tm) {  /* write all digit groups that follow a separator */
                               inl_s=D_DIGGRPLEN-inl_pfdgph;
                               while (TRUE) {
                                 do {
                                   *(awcl_cur)-- = HL_ENDIANSWAP_FROM_BYTE('0'+iml_arg1%(signed int)DECBASE);
                                   iml_arg1/=(signed int)DECBASE;
                                 } while (--inl_s);
                                 awcl_cur -= inl_dgsp_lo;  /* skip digits-separator */
                                 if (--inl_dgsp_tm==0)
                                   break;
                                 inl_s=D_DIGGRPLEN;
                               }
                             }
                             if (inl_dgsp_ph) {  /* precision may provoke leading separator */
                               while (TRUE) {   /* write leading (maybe partial) digit group */
                                 *awcl_cur = HL_ENDIANSWAP_FROM_BYTE('0'+iml_arg1%(signed int)DECBASE);
                                 if (--inl_dgsp_ph == 0) break;
                                 awcl_cur--;
                                 iml_arg1/=(signed int)DECBASE;
                               }
                             }
                           } else {  /* not using digit group separation */
                             while (--inl_emax > 0) {
                               *(awcl_cur+inl_emax) = HL_ENDIANSWAP_FROM_BYTE('0'+iml_arg1%(signed int)DECBASE);
                               iml_arg1/=(signed int)DECBASE;
                             }
                             *awcl_cur = HL_ENDIANSWAP_FROM_BYTE('0'+iml_arg1);
                           }
#ifdef HL_USE_DIV
                         }
#endif
                         awcl_cur += inl_emax;
                       }
                 break;
               case 'l': case 'L':
                 if(bol_longlong){
                   ill_arg = va_arg(dsl_list, HL_LONGLONG);
                       /* determine sign and go on with non-negative X */
                       if (ill_arg > 0) {
                         chl_sign = achl_signed[2];
                       } else {
                         if (ill_arg != 0)
                         {
                           chl_sign = achl_signed[0];
                           ill_arg=0-ill_arg; /* replace negative X by its abs-value */
                           if ((HL_LONGLONG)ill_arg<0) {  /* special case: X was the extreme negative value */
                             /*inl_emax = (((sizeof(HL_LONGLONG)*8-1)*30103)/100000)+1;*/
                             ill_arg=(HL_LONGLONG)(-1)-ill_arg; /* 7fff... */
                             if (iel_scaling==ied_scaling_none) {
                               chl_postfix = '1'+ill_arg%DECBASE;  /* decimal carry cannot happen here */
                               inl_postfixlen = 1;
                               inl_pfdgph = 1;
                               ull_precision--;
                               ill_arg/=DECBASE;
                             }
                           }
                         } else {
                           chl_sign = achl_signed[1];
                         }
                       }
                       inl_needed = chl_sign?1:0;

                       /* prepare %(sci-dec)- or %(sci-dec)-type of rendering */
                       if (iel_scaling!=ied_scaling_none) {
                         if (iel_scaling == ied_scaling_1000) {  /* power-of-1000-scaled */
#if HL_PRFMAXSO_LL > 4
                           if ((sizeof(HL_LONGLONG) > 4) && (ill_arg >= D_L1000RD * ullrs_decpowbuf[9])) {
#if HL_PRFMAXSO_LL > 8
                             if (
                                 (sizeof(HL_LONGLONG) > 8) &&
                                 (ill_arg >= D_L1000RD * ullrs_decpowbuf[15])
                                ) {
                               if (
                                   (ill_arg >= D_L1000RD * ullrs_decpowbuf[18])
                                  ) {
                                 if (ill_arg >= D_L1000RD * ullrs_decpowbuf[21]) {
                                   ill_arg =  (ill_arg + 500 * ullrs_decpowbuf[21]) / (ullrs_decpowbuf[24]);
                                   chl_postfix = 'Y';
                                 } else {
                                   ill_arg =  (ill_arg + 500 * ullrs_decpowbuf[18]) / (ullrs_decpowbuf[21]);
                                   chl_postfix = 'Z';
                                 }
                               } else {
                                 ill_arg =  (ill_arg + 500 * ullrs_decpowbuf[15]) / (ullrs_decpowbuf[18]);
                                 chl_postfix = 'E';
                               }
                             } else {
#endif
                               if (ill_arg >= D_L1000RD * ullrs_decpowbuf[12]) {
                                 ill_arg =  (ill_arg + 500 * ullrs_decpowbuf[12]) / (ullrs_decpowbuf[15]);
                                 chl_postfix = 'P';
                               } else {
                                 ill_arg =  (ill_arg + 500 * ullrs_decpowbuf[9]) / (ullrs_decpowbuf[12]);
                                 chl_postfix = 'T';
                               }
#if HL_PRFMAXSO_LL > 8
                             }
#endif
                             inl_postfixlen = 1;
                           } else {
#endif
#if HL_PRFMAXSO_LL > 2
                             if ((sizeof(HL_LONGLONG) > 2) && (ill_arg >= D_L1000RD * ullrs_decpowbuf[3])) {
#if HL_PRFMAXSO_LL > 4
                               if ((sizeof(HL_LONGLONG) > 4) && (ill_arg >= D_L1000RD * ullrs_decpowbuf[6])) {
                                 ill_arg =  (ill_arg + 500 * ullrs_decpowbuf[6]) / (ullrs_decpowbuf[9]);
                                 chl_postfix = 'G';
                               } else {
#endif
                                 ill_arg =  (ill_arg + 500 * ullrs_decpowbuf[3]) / (ullrs_decpowbuf[6]);
                                 chl_postfix = 'M';
#if HL_PRFMAXSO_LL > 4
                               }
#endif
                               inl_postfixlen = 1;
                             } else {
#endif
                               if (ill_arg >= D_L1000RD) {
                                 ill_arg = (ill_arg + 500) / 1000;
                                 chl_postfix = 'k';
                                 inl_postfixlen = 1;
                               }
#if HL_PRFMAXSO_LL > 2
                             }
#endif
#if HL_PRFMAXSO_LL > 4
                           }
#endif
                         }
                         else {               /* power-of-1024-scaled    */
#if HL_PRFMAXSO_LL > 4
                           if ((sizeof(HL_LONGLONG) > 4) && (ill_arg>>30 >= D_L1024RD)) {
#if HL_PRFMAXSO_LL > 8
                             if (
                                 (sizeof(HL_LONGLONG) > 8) &&
                                 (ill_arg>>50 >= D_L1024RD)
                                ) {
                               if (
                                   (ill_arg>>60 >= D_L1024RD)
                                  ) {
                                 if (ill_arg>>70 >= D_L1024RD) {
                                   ill_arg = (ill_arg+((HL_LONGLONG)1<<79)) >> 80;
                                   chl_postfix = 'Y';
                                 } else {
                                   ill_arg = (ill_arg+((HL_LONGLONG)1<<69)) >> 70;
                                   chl_postfix = 'Z';
                                 }
                               } else {
                                 ill_arg = (ill_arg+((HL_LONGLONG)1<<59)) >> 60;
                                 chl_postfix = 'E';
                               }
                             } else {
#endif
                               if (ill_arg>>40 >= D_L1024RD) {
                                 ill_arg = (ill_arg+((HL_LONGLONG)1<<49)) >> 50;
                                 chl_postfix = 'P';
                               } else {
                                 ill_arg = (ill_arg+((HL_LONGLONG)1<<39)) >> 40;
                                 chl_postfix = 'T';
                               }
#if HL_PRFMAXSO_LL > 8
                             }
#endif
                             inl_postfixlen = bol_alternate_form ? 2 : 1;
                           } else {
#endif
#if HL_PRFMAXSO_LL > 2
                             if ((sizeof(HL_LONGLONG) > 2) && (ill_arg>>10 >= D_L1024RD)) {
#if HL_PRFMAXSO_LL > 4
                               if ((sizeof(HL_LONGLONG) > 4) && (ill_arg>>20 >= D_L1024RD)) {
                                 ill_arg = (ill_arg+((HL_LONGLONG)1<<29)) >> 30;
                                 chl_postfix = 'G';
                               } else {
#endif
                                 ill_arg = (ill_arg+((HL_LONGLONG)1<<19)) >> 20;
                                 chl_postfix = 'M';
#if HL_PRFMAXSO_LL > 4
                               }
#endif
                               inl_postfixlen = bol_alternate_form ? 2 : 1;
                             } else {
#endif
                               if (ill_arg >= D_L1024RD) {
                                 ill_arg = (ill_arg+0x200) >> 10;
                                 chl_postfix = 'K';
                                 inl_postfixlen = bol_alternate_form ? 2 : 1;
                               }
#if HL_PRFMAXSO_LL > 2
                             }
#endif
#if HL_PRFMAXSO_LL > 4
                           }
#endif
                         }
                       }

                       /* detect the order of magnitude of X           */
                       inl_emax = 0;
                       if (ill_arg) {
                         int inl_e = (((sizeof(HL_LONGLONG)*8-1)*30103)/100000)+1;
                         do {
                           inl_s = inl_e>>1;
                           if (ill_arg >= ullrs_decpowbuf[inl_emax+inl_s]) {
                             inl_emax += inl_s;
                             inl_e -= inl_s;
                           } else {
                             inl_e = inl_s;
                           }
                         } while (inl_e>1);
                         inl_emax ++;
                       }
                       inl_needed += inl_emax + inl_postfixlen;
                       if (inl_dgsp_lc) {   /* use digit group separation */
                         if (inl_emax<=D_DIGGRPLEN) {  /* digit grouping not in effect */
                           inl_dgsp_lc = 0;
                         } else {
                           const int inl_emax_1 = inl_emax+inl_pfdgph-1;
#ifdef HL_USE_DIV
                           dsl_diggrp_dm = div(inl_emax_1, D_DIGGRPLEN);
                           inl_dgsp_ph++;
#else
                           inl_dgsp_tm = (inl_emax_1)/D_DIGGRPLEN;
                           inl_dgsp_ph = (inl_emax_1)%D_DIGGRPLEN+1;
#endif
                           if (inl_needed>=ull_field_width || inl_needed+inl_dgsp_tm*inl_dgsp_lc<=ull_field_width) {
                             inl_s = inl_dgsp_tm*inl_dgsp_lc;
                             inl_needed += inl_s;
                           } else {  /* prefer staying within fieldwidth over using the separator */
                             inl_dgsp_lc = 0;
                           }
                         }
                       }
                       if (!bol_precision) {
                         ull_precision = 1;  /* default precision      */
                         if (bol_padding_zero) {
                           if (ull_field_width>inl_needed && !bol_adjustleft) {
                             /* fake padding with '0' by ull_precision */
                             ull_precision = ull_field_width+(inl_dgsp_lc?inl_emax+inl_s:inl_emax)-inl_needed;
                           }
                         }
                       }
                       if (inl_dgsp_lc) {   /* using digit group separation */
                         inl_precpad = ull_precision-(inl_emax+inl_s);
                         if (inl_precpad>0) {
#ifdef HL_USE_DIV
                           div_t dsl_d = div(inl_dgsp_ph+inl_precpad, D_DIGGRPLEN+inl_dgsp_lc);
                           inl_dgsp_tm += dsl_d.quot;
                           inl_needed += inl_precpad;
                           inl_dgsp_ph = dsl_d.rem;
#else
                           inl_needed += inl_precpad;
                           inl_dgsp_tm += (inl_dgsp_ph+inl_precpad)/(D_DIGGRPLEN+inl_dgsp_lc);
                           inl_dgsp_ph = (inl_dgsp_ph+inl_precpad)%(D_DIGGRPLEN+inl_dgsp_lc);
#endif
                           if (inl_dgsp_ph>D_DIGGRPLEN) {
                             inl_needed -= inl_dgsp_ph-D_DIGGRPLEN;
                             inl_dgsp_ph = D_DIGGRPLEN;
                           }
                           inl_precpad = ull_precision-(inl_emax+inl_dgsp_tm*inl_dgsp_lc);
                         } else {
                           inl_precpad=0;
                         }
                       } else {    /* not using digit group separation */
                         inl_precpad = ull_precision-inl_emax;
                         if (inl_precpad>0) {
                           inl_needed += inl_precpad;
                         } else {
                           inl_precpad=0;
                         }
                       }
                       if (ull_field_width > inl_needed) {
                         awcl_after = awcl_cur+ull_field_width;
                         inl_padsp = ull_field_width-inl_needed;
                         if (!bol_adjustleft) {  /* padding left with spaces */
                           if (inl_padsp > awcl_end-awcl_cur)
                             {awcl_after = awcl_cur; break;}  /* overflow */
                           do
                             *awcl_cur++ = HL_ENDIANSWAP_FROM_BYTE(' ');
                           while (--inl_padsp);
                         }
                       } else {
                         awcl_after = awcl_cur+inl_needed;
                         inl_padsp = 0;
                       }
                       if (inl_dgsp_lc) {   /* set digit group separators */
                         if (chl_sign) {    /* write sign prefix       */
                           if (1 > awcl_end-awcl_cur)
                             {awcl_after = awcl_cur; break;}  /* overflow */
                           *awcl_cur++ = HL_ENDIANSWAP_FROM_BYTE(chl_sign);
                         }
                         /* produce the first separator                                     */
                         awcl_dg = awcl_cur+inl_dgsp_ph;
                         if (iel_cs_target == ied_chs_utf_16) {  /* natural endian */
                           inl_dgsp_lo = m_u16l_from_u8l(awcl_dg, awcl_end-awcl_dg, achl_dgsp, inl_dgsp_lb);
                         } else {           /* swapped endian          */
                           inl_dgsp_lo = m_u16r_from_u8l(awcl_dg, 1+awcl_end-awcl_dg, achl_dgsp, inl_dgsp_lb);
                         }
                         /* now the complete physical output length can be determined      */
                         inl_s = inl_dgsp_tm*(inl_dgsp_lo-inl_dgsp_lc);  /* adjustment from logical to physical */
                         awcl_after += inl_s;
                         if (inl_dgsp_lo<0 || awcl_after-awcl_cur>awcl_end-awcl_cur)
                           {awcl_after = awcl_cur; break;}  /* overflow */
                         /* copy the other separators from the first one                   */
                         inl_s = inl_dgsp_tm-1;
                         if (inl_s) {
                           awcl0 = awcl_dg+inl_dgsp_lo;
                           do {
                             awcl0 += D_DIGGRPLEN;
                             int inl2 = 0;
                             do
                               *awcl0++ = awcl_dg[inl2++];
                             while (inl2<inl_dgsp_lo);
                           } while (--inl_s);
                         }
                         /* padding left with zeroes to "precision"                        */
                         while (inl_precpad) {
                           if (inl_dgsp_ph == 0) {  /* skip digits-separator */
                             awcl_cur += inl_dgsp_lo;
                             inl_dgsp_ph = D_DIGGRPLEN-1;
                             inl_dgsp_tm--;
                             if (!inl_dgsp_tm)
                               break;
                           } else {
                             inl_dgsp_ph--;
                           }
                           *awcl_cur++ = HL_ENDIANSWAP_FROM_BYTE('0');
                           inl_precpad --;
                         }
                       } else {             /* not using digit group separation */
                         if (awcl_after-awcl_cur>awcl_end-awcl_cur)
                           {awcl_after = awcl_cur; break;}  /* overflow */
                         if (chl_sign)      /* write sign prefix       */
                           *awcl_cur++ = HL_ENDIANSWAP_FROM_BYTE(chl_sign);
                         /* padding left with zeroes to "precision"    */
                         while (inl_precpad) {
                           *awcl_cur++ = HL_ENDIANSWAP_FROM_BYTE('0');
                           inl_precpad --;
                         }
                       }
                       /* postfix                                      */
                       if (inl_postfixlen) {
                         if (inl_postfixlen==2) {
                           *(awcl_after-(inl_padsp+2)) = HL_ENDIANSWAP_FROM_BYTE(chl_postfix);
                           *(awcl_after-(inl_padsp+1)) = HL_ENDIANSWAP_FROM_BYTE('i');
                         } else {
                           *(awcl_after-(inl_padsp+1)) = HL_ENDIANSWAP_FROM_BYTE(chl_postfix);
                         }
                       }
                       /* padding right with spaces                    */
                       if (inl_padsp) {
                         awcl0 = awcl_after-1;
                         do
                           *awcl0-- = HL_ENDIANSWAP_FROM_BYTE(' ');
                         while (--inl_padsp);
                       }
                       /* produce the digits                           */
                       if (inl_emax > 0) {
#ifdef HL_USE_DIV
                         if (sizeof(HL_LONGLONG)<=sizeof(int)) {
                           div_t dsl_d;
                           dsl_d = div(ill_arg,DECBASE);
                           if (inl_dgsp_lc) {  /* using digit group separation */
                             awcl_cur += inl_emax+inl_dgsp_tm*inl_dgsp_lo-1;
                             if (inl_dgsp_tm) {  /* write all digit groups that follow a separator */
                               inl_s=D_DIGGRPLEN-inl_pfdgph;
                               while (TRUE) {
                                 do {
                                   *(awcl_cur)-- = HL_ENDIANSWAP_FROM_BYTE('0'+dsl_d.rem);
                                   dsl_d = div(dsl_d.quot,DECBASE);
                                 } while (--inl_s);
                                 awcl_cur -= inl_dgsp_lo;  /* skip digits-separator */
                                 if (--inl_dgsp_tm==0)
                                   break;
                                 inl_s=D_DIGGRPLEN;
                               }
                             }
                             if (inl_dgsp_ph) {  /* precision may provoke leading separator */
                               while (TRUE) {   /* write leading (maybe partial) digit group */
                                 *awcl_cur = HL_ENDIANSWAP_FROM_BYTE('0'+dsl_d.rem);
                                 if (--inl_dgsp_ph == 0) break;
                                 awcl_cur--;
                                 dsl_d = div(dsl_d.quot,DECBASE);
                               }
                             }
                           } else {  /* not using digit group separation */
                             while (TRUE) {
                               *(awcl_cur + --inl_emax) = HL_ENDIANSWAP_FROM_BYTE('0'+dsl_d.rem);
                               if (inl_emax <= 0) break;
                               dsl_d = div(dsl_d.quot,DECBASE);
                             }
                           }
#ifdef HL_USE_LDIV
                         } else if (sizeof(HL_LONGLONG)<=sizeof(long int)) {
                           ldiv_t dsl_d;
                           dsl_d = ldiv(ill_arg,DECBASE);
                           if (inl_dgsp_lc) {  /* using digit group separation */
                             awcl_cur += inl_emax+inl_dgsp_tm*inl_dgsp_lo-1;
                             if (inl_dgsp_tm) {  /* write all digit groups that follow a separator */
                               inl_s=D_DIGGRPLEN-inl_pfdgph;
                               while (TRUE) {
                                 do {
                                   *(awcl_cur)-- = HL_ENDIANSWAP_FROM_BYTE('0'+dsl_d.rem);
                                   dsl_d = ldiv(dsl_d.quot,DECBASE);
                                 } while (--inl_s);
                                 awcl_cur -= inl_dgsp_lo;  /* skip digits-separator */
                                 if (--inl_dgsp_tm==0)
                                   break;
                                 inl_s=D_DIGGRPLEN;
                               }
                             }
                             if (inl_dgsp_ph) {  /* precision may provoke leading separator */
                               while (TRUE) {   /* write leading (maybe partial) digit group */
                                 *awcl_cur = HL_ENDIANSWAP_FROM_BYTE('0'+dsl_d.rem);
                                 if (--inl_dgsp_ph == 0) break;
                                 awcl_cur--;
                                 dsl_d = ldiv(dsl_d.quot,DECBASE);
                               }
                             }
                           } else {  /* not using digit group separation */
                             while (TRUE) {
                               *(awcl_cur + --inl_emax) = HL_ENDIANSWAP_FROM_BYTE('0'+dsl_d.rem);
                               if (inl_emax <= 0) break;
                               dsl_d = ldiv(dsl_d.quot,DECBASE);
                             }
                           }
#endif
#ifdef HL_USE_LLDIV
                         } else if (sizeof(HL_LONGLONG)<=sizeof(long long int)) {
                           lldiv_t dsl_d;
                           dsl_d = lldiv(ill_arg,DECBASE);
                           if (inl_dgsp_lc) {  /* using digit group separation */
                             awcl_cur += inl_emax+inl_dgsp_tm*inl_dgsp_lo-1;
                             if (inl_dgsp_tm) {  /* write all digit groups that follow a separator */
                               inl_s=D_DIGGRPLEN-inl_pfdgph;
                               while (TRUE) {
                                 do {
                                   *(awcl_cur)-- = HL_ENDIANSWAP_FROM_BYTE('0'+dsl_d.rem);
                                   dsl_d = lldiv(dsl_d.quot,DECBASE);
                                 } while (--inl_s);
                                 awcl_cur -= inl_dgsp_lo;  /* skip digits-separator */
                                 if (--inl_dgsp_tm==0)
                                   break;
                                 inl_s=D_DIGGRPLEN;
                               }
                             }
                             if (inl_dgsp_ph) {  /* precision may provoke leading separator */
                               while (TRUE) {   /* write leading (maybe partial) digit group */
                                 *awcl_cur = HL_ENDIANSWAP_FROM_BYTE('0'+dsl_d.rem);
                                 if (--inl_dgsp_ph == 0) break;
                                 awcl_cur--;
                                 dsl_d = lldiv(dsl_d.quot,DECBASE);
                               }
                             }
                           } else {  /* not using digit group separation */
                             while (TRUE) {
                               *(awcl_cur + --inl_emax) = HL_ENDIANSWAP_FROM_BYTE('0'+dsl_d.rem);
                               if (inl_emax <= 0) break;
                               dsl_d = lldiv(dsl_d.quot,DECBASE);
                             }
                           }
#endif
                         } else {
#endif
                           if (inl_dgsp_lc) {  /* using digit group separation */
                             awcl_cur += inl_emax+inl_dgsp_tm*inl_dgsp_lo-1;
                             if (inl_dgsp_tm) {  /* write all digit groups that follow a separator */
                               inl_s=D_DIGGRPLEN-inl_pfdgph;
                               while (TRUE) {
                                 do {
                                   *(awcl_cur)-- = HL_ENDIANSWAP_FROM_BYTE('0'+ill_arg%(HL_LONGLONG)DECBASE);
                                   ill_arg/=(HL_LONGLONG)DECBASE;
                                 } while (--inl_s);
                                 awcl_cur -= inl_dgsp_lo;  /* skip digits-separator */
                                 if (--inl_dgsp_tm==0)
                                   break;
                                 inl_s=D_DIGGRPLEN;
                               }
                             }
                             if (inl_dgsp_ph) {  /* precision may provoke leading separator */
                               while (TRUE) {   /* write leading (maybe partial) digit group */
                                 *awcl_cur = HL_ENDIANSWAP_FROM_BYTE('0'+ill_arg%(HL_LONGLONG)DECBASE);
                                 if (--inl_dgsp_ph == 0) break;
                                 awcl_cur--;
                                 ill_arg/=(HL_LONGLONG)DECBASE;
                               }
                             }
                           } else {  /* not using digit group separation */
                             while (--inl_emax > 0) {
                               *(awcl_cur+inl_emax) = HL_ENDIANSWAP_FROM_BYTE('0'+ill_arg%(HL_LONGLONG)DECBASE);
                               ill_arg/=(HL_LONGLONG)DECBASE;
                             }
                             *awcl_cur = HL_ENDIANSWAP_FROM_BYTE('0'+ill_arg);
                           }
#ifdef HL_USE_DIV
                         }
#endif
                         awcl_cur += inl_emax;
                       }
                 }
                 else {
                   ill_arg = va_arg(dsl_list, long int);
                       /* determine sign and go on with non-negative X */
                       if (ill_arg > 0) {
                         chl_sign = achl_signed[2];
                       } else {
                         if (ill_arg != 0)
                         {
                           chl_sign = achl_signed[0];
                           ill_arg=0-ill_arg; /* replace negative X by its abs-value */
                           if ((signed long int)ill_arg<0) {  /* special case: X was the extreme negative value */
                             /*inl_emax = (((sizeof(signed long int)*8-1)*30103)/100000)+1;*/
                             ill_arg=(signed long int)(-1)-ill_arg; /* 7fff... */
                             if (iel_scaling==ied_scaling_none) {
                               chl_postfix = '1'+ill_arg%DECBASE;  /* decimal carry cannot happen here */
                               inl_postfixlen = 1;
                               inl_pfdgph = 1;
                               ull_precision--;
                               ill_arg/=DECBASE;
                             }
                           }
                         } else {
                           chl_sign = achl_signed[1];
                         }
                       }
                       inl_needed = chl_sign?1:0;

                       /* prepare %(sci-dec)- or %(sci-dec)-type of rendering */
                       if (iel_scaling!=ied_scaling_none) {
                         if (iel_scaling == ied_scaling_1000) {  /* power-of-1000-scaled */
#if HL_PRFMAXSO_L > 4
                           if ((sizeof(signed long int) > 4) && (ill_arg >= D_L1000RD * ullrs_decpowbuf[9])) {
#if HL_PRFMAXSO_L > 8
                             if (
                                 (sizeof(signed long int) > 8) &&
                                 (ill_arg >= D_L1000RD * ullrs_decpowbuf[15])
                                ) {
                               if (
                                   (ill_arg >= D_L1000RD * ullrs_decpowbuf[18])
                                  ) {
                                 if (ill_arg >= D_L1000RD * ullrs_decpowbuf[21]) {
                                   ill_arg =  (ill_arg + 500 * ullrs_decpowbuf[21]) / (ullrs_decpowbuf[24]);
                                   chl_postfix = 'Y';
                                 } else {
                                   ill_arg =  (ill_arg + 500 * ullrs_decpowbuf[18]) / (ullrs_decpowbuf[21]);
                                   chl_postfix = 'Z';
                                 }
                               } else {
                                 ill_arg =  (ill_arg + 500 * ullrs_decpowbuf[15]) / (ullrs_decpowbuf[18]);
                                 chl_postfix = 'E';
                               }
                             } else {
#endif
                               if (ill_arg >= D_L1000RD * ullrs_decpowbuf[12]) {
                                 ill_arg =  (ill_arg + 500 * ullrs_decpowbuf[12]) / (ullrs_decpowbuf[15]);
                                 chl_postfix = 'P';
                               } else {
                                 ill_arg =  (ill_arg + 500 * ullrs_decpowbuf[9]) / (ullrs_decpowbuf[12]);
                                 chl_postfix = 'T';
                               }
#if HL_PRFMAXSO_L > 8
                             }
#endif
                             inl_postfixlen = 1;
                           } else {
#endif
#if HL_PRFMAXSO_L > 2
                             if ((sizeof(signed long int) > 2) && (ill_arg >= D_L1000RD * ullrs_decpowbuf[3])) {
#if HL_PRFMAXSO_L > 4
                               if ((sizeof(signed long int) > 4) && (ill_arg >= D_L1000RD * ullrs_decpowbuf[6])) {
                                 ill_arg =  (ill_arg + 500 * ullrs_decpowbuf[6]) / (ullrs_decpowbuf[9]);
                                 chl_postfix = 'G';
                               } else {
#endif
                                 ill_arg =  (ill_arg + 500 * ullrs_decpowbuf[3]) / (ullrs_decpowbuf[6]);
                                 chl_postfix = 'M';
#if HL_PRFMAXSO_L > 4
                               }
#endif
                               inl_postfixlen = 1;
                             } else {
#endif
                               if (ill_arg >= D_L1000RD) {
                                 ill_arg = (ill_arg + 500) / 1000;
                                 chl_postfix = 'k';
                                 inl_postfixlen = 1;
                               }
#if HL_PRFMAXSO_L > 2
                             }
#endif
#if HL_PRFMAXSO_L > 4
                           }
#endif
                         }
                         else {               /* power-of-1024-scaled    */
#if HL_PRFMAXSO_L > 4
                           if ((sizeof(signed long int) > 4) && (ill_arg>>30 >= D_L1024RD)) {
#if HL_PRFMAXSO_L > 8
                             if (
                                 (sizeof(signed long int) > 8) &&
                                 (ill_arg>>50 >= D_L1024RD)
                                ) {
                               if (
                                   (ill_arg>>60 >= D_L1024RD)
                                  ) {
                                 if (ill_arg>>70 >= D_L1024RD) {
                                   ill_arg = (ill_arg+((signed long int)1<<79)) >> 80;
                                   chl_postfix = 'Y';
                                 } else {
                                   ill_arg = (ill_arg+((signed long int)1<<69)) >> 70;
                                   chl_postfix = 'Z';
                                 }
                               } else {
                                 ill_arg = (ill_arg+((signed long int)1<<59)) >> 60;
                                 chl_postfix = 'E';
                               }
                             } else {
#endif
                               if (ill_arg>>40 >= D_L1024RD) {
                                 ill_arg = (ill_arg+((signed long int)1<<49)) >> 50;
                                 chl_postfix = 'P';
                               } else {
                                 ill_arg = (ill_arg+((signed long int)1<<39)) >> 40;
                                 chl_postfix = 'T';
                               }
#if HL_PRFMAXSO_L > 8
                             }
#endif
                             inl_postfixlen = bol_alternate_form ? 2 : 1;
                           } else {
#endif
#if HL_PRFMAXSO_L > 2
                             if ((sizeof(signed long int) > 2) && (ill_arg>>10 >= D_L1024RD)) {
#if HL_PRFMAXSO_L > 4
                               if ((sizeof(signed long int) > 4) && (ill_arg>>20 >= D_L1024RD)) {
                                 ill_arg = (ill_arg+((signed long int)1<<29)) >> 30;
                                 chl_postfix = 'G';
                               } else {
#endif
                                 ill_arg = (ill_arg+((signed long int)1<<19)) >> 20;
                                 chl_postfix = 'M';
#if HL_PRFMAXSO_L > 4
                               }
#endif
                               inl_postfixlen = bol_alternate_form ? 2 : 1;
                             } else {
#endif
                               if (ill_arg >= D_L1024RD) {
                                 ill_arg = (ill_arg+0x200) >> 10;
                                 chl_postfix = 'K';
                                 inl_postfixlen = bol_alternate_form ? 2 : 1;
                               }
#if HL_PRFMAXSO_L > 2
                             }
#endif
#if HL_PRFMAXSO_L > 4
                           }
#endif
                         }
                       }

                       /* detect the order of magnitude of X           */
                       inl_emax = 0;
                       if (ill_arg) {
                         int inl_e = (((sizeof(signed long int)*8-1)*30103)/100000)+1;
                         do {
                           inl_s = inl_e>>1;
                           if (ill_arg >= ullrs_decpowbuf[inl_emax+inl_s]) {
                             inl_emax += inl_s;
                             inl_e -= inl_s;
                           } else {
                             inl_e = inl_s;
                           }
                         } while (inl_e>1);
                         inl_emax ++;
                       }
                       inl_needed += inl_emax + inl_postfixlen;
                       if (inl_dgsp_lc) {   /* use digit group separation */
                         if (inl_emax<=D_DIGGRPLEN) {  /* digit grouping not in effect */
                           inl_dgsp_lc = 0;
                         } else {
                           const int inl_emax_1 = inl_emax+inl_pfdgph-1;
#ifdef HL_USE_DIV
                           dsl_diggrp_dm = div(inl_emax_1, D_DIGGRPLEN);
                           inl_dgsp_ph++;
#else
                           inl_dgsp_tm = (inl_emax_1)/D_DIGGRPLEN;
                           inl_dgsp_ph = (inl_emax_1)%D_DIGGRPLEN+1;
#endif
                           if (inl_needed>=ull_field_width || inl_needed+inl_dgsp_tm*inl_dgsp_lc<=ull_field_width) {
                             inl_s = inl_dgsp_tm*inl_dgsp_lc;
                             inl_needed += inl_s;
                           } else {  /* prefer staying within fieldwidth over using the separator */
                             inl_dgsp_lc = 0;
                           }
                         }
                       }
                       if (!bol_precision) {
                         ull_precision = 1;  /* default precision      */
                         if (bol_padding_zero) {
                           if (ull_field_width>inl_needed && !bol_adjustleft) {
                             /* fake padding with '0' by ull_precision */
                             ull_precision = ull_field_width+(inl_dgsp_lc?inl_emax+inl_s:inl_emax)-inl_needed;
                           }
                         }
                       }
                       if (inl_dgsp_lc) {   /* using digit group separation */
                         inl_precpad = ull_precision-(inl_emax+inl_s);
                         if (inl_precpad>0) {
#ifdef HL_USE_DIV
                           div_t dsl_d = div(inl_dgsp_ph+inl_precpad, D_DIGGRPLEN+inl_dgsp_lc);
                           inl_dgsp_tm += dsl_d.quot;
                           inl_needed += inl_precpad;
                           inl_dgsp_ph = dsl_d.rem;
#else
                           inl_needed += inl_precpad;
                           inl_dgsp_tm += (inl_dgsp_ph+inl_precpad)/(D_DIGGRPLEN+inl_dgsp_lc);
                           inl_dgsp_ph = (inl_dgsp_ph+inl_precpad)%(D_DIGGRPLEN+inl_dgsp_lc);
#endif
                           if (inl_dgsp_ph>D_DIGGRPLEN) {
                             inl_needed -= inl_dgsp_ph-D_DIGGRPLEN;
                             inl_dgsp_ph = D_DIGGRPLEN;
                           }
                           inl_precpad = ull_precision-(inl_emax+inl_dgsp_tm*inl_dgsp_lc);
                         } else {
                           inl_precpad=0;
                         }
                       } else {    /* not using digit group separation */
                         inl_precpad = ull_precision-inl_emax;
                         if (inl_precpad>0) {
                           inl_needed += inl_precpad;
                         } else {
                           inl_precpad=0;
                         }
                       }
                       if (ull_field_width > inl_needed) {
                         awcl_after = awcl_cur+ull_field_width;
                         inl_padsp = ull_field_width-inl_needed;
                         if (!bol_adjustleft) {  /* padding left with spaces */
                           if (inl_padsp > awcl_end-awcl_cur)
                             {awcl_after = awcl_cur; break;}  /* overflow */
                           do
                             *awcl_cur++ = HL_ENDIANSWAP_FROM_BYTE(' ');
                           while (--inl_padsp);
                         }
                       } else {
                         awcl_after = awcl_cur+inl_needed;
                         inl_padsp = 0;
                       }
                       if (inl_dgsp_lc) {   /* set digit group separators */
                         if (chl_sign) {    /* write sign prefix       */
                           if (1 > awcl_end-awcl_cur)
                             {awcl_after = awcl_cur; break;}  /* overflow */
                           *awcl_cur++ = HL_ENDIANSWAP_FROM_BYTE(chl_sign);
                         }
                         /* produce the first separator                                     */
                         awcl_dg = awcl_cur+inl_dgsp_ph;
                         if (iel_cs_target == ied_chs_utf_16) {  /* natural endian */
                           inl_dgsp_lo = m_u16l_from_u8l(awcl_dg, awcl_end-awcl_dg, achl_dgsp, inl_dgsp_lb);
                         } else {           /* swapped endian          */
                           inl_dgsp_lo = m_u16r_from_u8l(awcl_dg, 1+awcl_end-awcl_dg, achl_dgsp, inl_dgsp_lb);
                         }
                         /* now the complete physical output length can be determined      */
                         inl_s = inl_dgsp_tm*(inl_dgsp_lo-inl_dgsp_lc);  /* adjustment from logical to physical */
                         awcl_after += inl_s;
                         if (inl_dgsp_lo<0 || awcl_after-awcl_cur>awcl_end-awcl_cur)
                           {awcl_after = awcl_cur; break;}  /* overflow */
                         /* copy the other separators from the first one                   */
                         inl_s = inl_dgsp_tm-1;
                         if (inl_s) {
                           awcl0 = awcl_dg+inl_dgsp_lo;
                           do {
                             awcl0 += D_DIGGRPLEN;
                             int inl2 = 0;
                             do
                               *awcl0++ = awcl_dg[inl2++];
                             while (inl2<inl_dgsp_lo);
                           } while (--inl_s);
                         }
                         /* padding left with zeroes to "precision"                        */
                         while (inl_precpad) {
                           if (inl_dgsp_ph == 0) {  /* skip digits-separator */
                             awcl_cur += inl_dgsp_lo;
                             inl_dgsp_ph = D_DIGGRPLEN-1;
                             inl_dgsp_tm--;
                             if (!inl_dgsp_tm)
                               break;
                           } else {
                             inl_dgsp_ph--;
                           }
                           *awcl_cur++ = HL_ENDIANSWAP_FROM_BYTE('0');
                           inl_precpad --;
                         }
                       } else {             /* not using digit group separation */
                         if (awcl_after-awcl_cur>awcl_end-awcl_cur)
                           {awcl_after = awcl_cur; break;}  /* overflow */
                         if (chl_sign)      /* write sign prefix       */
                           *awcl_cur++ = HL_ENDIANSWAP_FROM_BYTE(chl_sign);
                         /* padding left with zeroes to "precision"    */
                         while (inl_precpad) {
                           *awcl_cur++ = HL_ENDIANSWAP_FROM_BYTE('0');
                           inl_precpad --;
                         }
                       }
                       /* postfix                                      */
                       if (inl_postfixlen) {
                         if (inl_postfixlen==2) {
                           *(awcl_after-(inl_padsp+2)) = HL_ENDIANSWAP_FROM_BYTE(chl_postfix);
                           *(awcl_after-(inl_padsp+1)) = HL_ENDIANSWAP_FROM_BYTE('i');
                         } else {
                           *(awcl_after-(inl_padsp+1)) = HL_ENDIANSWAP_FROM_BYTE(chl_postfix);
                         }
                       }
                       /* padding right with spaces                    */
                       if (inl_padsp) {
                         awcl0 = awcl_after-1;
                         do
                           *awcl0-- = HL_ENDIANSWAP_FROM_BYTE(' ');
                         while (--inl_padsp);
                       }
                       /* produce the digits                           */
                       if (inl_emax > 0) {
#ifdef HL_USE_DIV
                         if (sizeof(signed long int)<=sizeof(int)) {
                           div_t dsl_d;
                           dsl_d = div(ill_arg,DECBASE);
                           if (inl_dgsp_lc) {  /* using digit group separation */
                             awcl_cur += inl_emax+inl_dgsp_tm*inl_dgsp_lo-1;
                             if (inl_dgsp_tm) {  /* write all digit groups that follow a separator */
                               inl_s=D_DIGGRPLEN-inl_pfdgph;
                               while (TRUE) {
                                 do {
                                   *(awcl_cur)-- = HL_ENDIANSWAP_FROM_BYTE('0'+dsl_d.rem);
                                   dsl_d = div(dsl_d.quot,DECBASE);
                                 } while (--inl_s);
                                 awcl_cur -= inl_dgsp_lo;  /* skip digits-separator */
                                 if (--inl_dgsp_tm==0)
                                   break;
                                 inl_s=D_DIGGRPLEN;
                               }
                             }
                             if (inl_dgsp_ph) {  /* precision may provoke leading separator */
                               while (TRUE) {   /* write leading (maybe partial) digit group */
                                 *awcl_cur = HL_ENDIANSWAP_FROM_BYTE('0'+dsl_d.rem);
                                 if (--inl_dgsp_ph == 0) break;
                                 awcl_cur--;
                                 dsl_d = div(dsl_d.quot,DECBASE);
                               }
                             }
                           } else {  /* not using digit group separation */
                             while (TRUE) {
                               *(awcl_cur + --inl_emax) = HL_ENDIANSWAP_FROM_BYTE('0'+dsl_d.rem);
                               if (inl_emax <= 0) break;
                               dsl_d = div(dsl_d.quot,DECBASE);
                             }
                           }
#ifdef HL_USE_LDIV
                         } else if (sizeof(signed long int)<=sizeof(long int)) {
                           ldiv_t dsl_d;
                           dsl_d = ldiv(ill_arg,DECBASE);
                           if (inl_dgsp_lc) {  /* using digit group separation */
                             awcl_cur += inl_emax+inl_dgsp_tm*inl_dgsp_lo-1;
                             if (inl_dgsp_tm) {  /* write all digit groups that follow a separator */
                               inl_s=D_DIGGRPLEN-inl_pfdgph;
                               while (TRUE) {
                                 do {
                                   *(awcl_cur)-- = HL_ENDIANSWAP_FROM_BYTE('0'+dsl_d.rem);
                                   dsl_d = ldiv(dsl_d.quot,DECBASE);
                                 } while (--inl_s);
                                 awcl_cur -= inl_dgsp_lo;  /* skip digits-separator */
                                 if (--inl_dgsp_tm==0)
                                   break;
                                 inl_s=D_DIGGRPLEN;
                               }
                             }
                             if (inl_dgsp_ph) {  /* precision may provoke leading separator */
                               while (TRUE) {   /* write leading (maybe partial) digit group */
                                 *awcl_cur = HL_ENDIANSWAP_FROM_BYTE('0'+dsl_d.rem);
                                 if (--inl_dgsp_ph == 0) break;
                                 awcl_cur--;
                                 dsl_d = ldiv(dsl_d.quot,DECBASE);
                               }
                             }
                           } else {  /* not using digit group separation */
                             while (TRUE) {
                               *(awcl_cur + --inl_emax) = HL_ENDIANSWAP_FROM_BYTE('0'+dsl_d.rem);
                               if (inl_emax <= 0) break;
                               dsl_d = ldiv(dsl_d.quot,DECBASE);
                             }
                           }
#endif
#ifdef HL_USE_LLDIV
                         } else if (sizeof(signed long int)<=sizeof(long long int)) {
                           lldiv_t dsl_d;
                           dsl_d = lldiv(ill_arg,DECBASE);
                           if (inl_dgsp_lc) {  /* using digit group separation */
                             awcl_cur += inl_emax+inl_dgsp_tm*inl_dgsp_lo-1;
                             if (inl_dgsp_tm) {  /* write all digit groups that follow a separator */
                               inl_s=D_DIGGRPLEN-inl_pfdgph;
                               while (TRUE) {
                                 do {
                                   *(awcl_cur)-- = HL_ENDIANSWAP_FROM_BYTE('0'+dsl_d.rem);
                                   dsl_d = lldiv(dsl_d.quot,DECBASE);
                                 } while (--inl_s);
                                 awcl_cur -= inl_dgsp_lo;  /* skip digits-separator */
                                 if (--inl_dgsp_tm==0)
                                   break;
                                 inl_s=D_DIGGRPLEN;
                               }
                             }
                             if (inl_dgsp_ph) {  /* precision may provoke leading separator */
                               while (TRUE) {   /* write leading (maybe partial) digit group */
                                 *awcl_cur = HL_ENDIANSWAP_FROM_BYTE('0'+dsl_d.rem);
                                 if (--inl_dgsp_ph == 0) break;
                                 awcl_cur--;
                                 dsl_d = lldiv(dsl_d.quot,DECBASE);
                               }
                             }
                           } else {  /* not using digit group separation */
                             while (TRUE) {
                               *(awcl_cur + --inl_emax) = HL_ENDIANSWAP_FROM_BYTE('0'+dsl_d.rem);
                               if (inl_emax <= 0) break;
                               dsl_d = lldiv(dsl_d.quot,DECBASE);
                             }
                           }
#endif
                         } else {
#endif
                           if (inl_dgsp_lc) {  /* using digit group separation */
                             awcl_cur += inl_emax+inl_dgsp_tm*inl_dgsp_lo-1;
                             if (inl_dgsp_tm) {  /* write all digit groups that follow a separator */
                               inl_s=D_DIGGRPLEN-inl_pfdgph;
                               while (TRUE) {
                                 do {
                                   *(awcl_cur)-- = HL_ENDIANSWAP_FROM_BYTE('0'+ill_arg%(signed long int)DECBASE);
                                   ill_arg/=(signed long int)DECBASE;
                                 } while (--inl_s);
                                 awcl_cur -= inl_dgsp_lo;  /* skip digits-separator */
                                 if (--inl_dgsp_tm==0)
                                   break;
                                 inl_s=D_DIGGRPLEN;
                               }
                             }
                             if (inl_dgsp_ph) {  /* precision may provoke leading separator */
                               while (TRUE) {   /* write leading (maybe partial) digit group */
                                 *awcl_cur = HL_ENDIANSWAP_FROM_BYTE('0'+ill_arg%(signed long int)DECBASE);
                                 if (--inl_dgsp_ph == 0) break;
                                 awcl_cur--;
                                 ill_arg/=(signed long int)DECBASE;
                               }
                             }
                           } else {  /* not using digit group separation */
                             while (--inl_emax > 0) {
                               *(awcl_cur+inl_emax) = HL_ENDIANSWAP_FROM_BYTE('0'+ill_arg%(signed long int)DECBASE);
                               ill_arg/=(signed long int)DECBASE;
                             }
                             *awcl_cur = HL_ENDIANSWAP_FROM_BYTE('0'+ill_arg);
                           }
#ifdef HL_USE_DIV
                         }
#endif
                         awcl_cur += inl_emax;
                       }
                 }
                 break;
             }
           }
           else {                           /* unsigned: o O x X u U   */ /*UUU non-implemented 'n' has also 4 in umrs_format*/
             switch(chl_length_modifier) {
               case '\0': case 'h':
                 uml_arg = va_arg(dsl_list, unsigned int);
                 switch (chl_spec&0xDF) {
                   case 'U':

                       /* prepare %(sci-dec)- or %(sci-dec)-type of rendering */
                       if (iel_scaling!=ied_scaling_none) {
                         if (iel_scaling == ied_scaling_1000) {  /* power-of-1000-scaled */
#if HL_PRFMAXSO_I > 4
                           if ((sizeof(unsigned int) > 4) && (uml_arg >= D_L1000RD * unrs_decpowbuf[9])) {
                             if (
                                 (uml_arg >= D_L1000RD * unrs_decpowbuf[15])
                                ) {
#if HL_PRFMAXSO_I > 8
                               if (
                                   (sizeof(unsigned int) > 8) &&
                                   (uml_arg >= D_L1000RD * unrs_decpowbuf[18])
                                  ) {
                                 if (uml_arg >= D_L1000RD * unrs_decpowbuf[21]) {
                                   uml_arg =  (uml_arg + 500 * unrs_decpowbuf[21]) / (unrs_decpowbuf[24]);
                                   chl_postfix = 'Y';
                                 } else {
                                   uml_arg =  (uml_arg + 500 * unrs_decpowbuf[18]) / (unrs_decpowbuf[21]);
                                   chl_postfix = 'Z';
                                 }
                               } else {
#endif
                                 uml_arg =  (uml_arg + 500 * unrs_decpowbuf[15]) / (unrs_decpowbuf[18]);
                                 chl_postfix = 'E';
#if HL_PRFMAXSO_I > 8
                               }
#endif
                             } else {
                               if (uml_arg >= D_L1000RD * unrs_decpowbuf[12]) {
                                 uml_arg =  (uml_arg + 500 * unrs_decpowbuf[12]) / (unrs_decpowbuf[15]);
                                 chl_postfix = 'P';
                               } else {
                                 uml_arg =  (uml_arg + 500 * unrs_decpowbuf[9]) / (unrs_decpowbuf[12]);
                                 chl_postfix = 'T';
                               }
                             }
                             inl_postfixlen = 1;
                           } else {
#endif
#if HL_PRFMAXSO_I > 2
                             if ((sizeof(unsigned int) > 2) && (uml_arg >= D_L1000RD * unrs_decpowbuf[3])) {
#if HL_PRFMAXSO_I > 4
                               if ((sizeof(unsigned int) > 4) && (uml_arg >= D_L1000RD * unrs_decpowbuf[6])) {
                                 uml_arg =  (uml_arg + 500 * unrs_decpowbuf[6]) / (unrs_decpowbuf[9]);
                                 chl_postfix = 'G';
                               } else {
#endif
                                 uml_arg =  (uml_arg + 500 * unrs_decpowbuf[3]) / (unrs_decpowbuf[6]);
                                 chl_postfix = 'M';
#if HL_PRFMAXSO_I > 4
                               }
#endif
                               inl_postfixlen = 1;
                             } else {
#endif
                               if (uml_arg >= D_L1000RD) {
                                 uml_arg = (uml_arg + 500) / 1000;
                                 chl_postfix = 'k';
                                 inl_postfixlen = 1;
                               }
#if HL_PRFMAXSO_I > 2
                             }
#endif
#if HL_PRFMAXSO_I > 4
                           }
#endif
                         }
                         else {               /* power-of-1024-scaled    */
#if HL_PRFMAXSO_I > 4
                           if ((sizeof(unsigned int) > 4) && (uml_arg>>30 >= D_L1024RD)) {
                             if (
                                 (uml_arg>>50 >= D_L1024RD)
                                ) {
#if HL_PRFMAXSO_I > 8
                               if (
                                   (sizeof(unsigned int) > 8) &&
                                   (uml_arg>>60 >= D_L1024RD)
                                  ) {
                                 if (uml_arg>>70 >= D_L1024RD) {
                                   uml_arg = (uml_arg+((unsigned int)1<<79)) >> 80;
                                   chl_postfix = 'Y';
                                 } else {
                                   uml_arg = (uml_arg+((unsigned int)1<<69)) >> 70;
                                   chl_postfix = 'Z';
                                 }
                               } else {
#endif
                                 uml_arg = (uml_arg+((unsigned int)1<<59)) >> 60;
                                 chl_postfix = 'E';
#if HL_PRFMAXSO_I > 8
                               }
#endif
                             } else {
                               if (uml_arg>>40 >= D_L1024RD) {
                                 uml_arg = (uml_arg+((unsigned int)1<<49)) >> 50;
                                 chl_postfix = 'P';
                               } else {
                                 uml_arg = (uml_arg+((unsigned int)1<<39)) >> 40;
                                 chl_postfix = 'T';
                               }
                             }
                             inl_postfixlen = bol_alternate_form ? 2 : 1;
                           } else {
#endif
#if HL_PRFMAXSO_I > 2
                             if ((sizeof(unsigned int) > 2) && (uml_arg>>10 >= D_L1024RD)) {
#if HL_PRFMAXSO_I > 4
                               if ((sizeof(unsigned int) > 4) && (uml_arg>>20 >= D_L1024RD)) {
                                 uml_arg = (uml_arg+((unsigned int)1<<29)) >> 30;
                                 chl_postfix = 'G';
                               } else {
#endif
                                 uml_arg = (uml_arg+((unsigned int)1<<19)) >> 20;
                                 chl_postfix = 'M';
#if HL_PRFMAXSO_I > 4
                               }
#endif
                               inl_postfixlen = bol_alternate_form ? 2 : 1;
                             } else {
#endif
                               if (uml_arg >= D_L1024RD) {
                                 uml_arg = (uml_arg+0x200) >> 10;
                                 chl_postfix = 'K';
                                 inl_postfixlen = bol_alternate_form ? 2 : 1;
                               }
#if HL_PRFMAXSO_I > 2
                             }
#endif
#if HL_PRFMAXSO_I > 4
                           }
#endif
                         }
                       }

                       /* detect the order of magnitude of X           */
                       inl_emax = 0;
                       if (uml_arg) {
                         int inl_e = ((sizeof(unsigned int)*240824)/100000)+1;
                         do {
                           inl_s = inl_e>>1;
                           if (uml_arg >= unrs_decpowbuf[inl_emax+inl_s]) {
                             inl_emax += inl_s;
                             inl_e -= inl_s;
                           } else {
                             inl_e = inl_s;
                           }
                         } while (inl_e>1);
                         inl_emax ++;
                       }
                       inl_needed = inl_emax + inl_postfixlen;
                       if (inl_dgsp_lc) {   /* use digit group separation */
                         if (inl_emax<=D_DIGGRPLEN) {  /* digit grouping not in effect */
                           inl_dgsp_lc = 0;
                         } else {
                           const int inl_emax_1 = inl_emax-1;
#ifdef HL_USE_DIV
                           dsl_diggrp_dm = div(inl_emax_1, D_DIGGRPLEN);
                           inl_dgsp_ph++;
#else
                           inl_dgsp_tm = (inl_emax_1)/D_DIGGRPLEN;
                           inl_dgsp_ph = (inl_emax_1)%D_DIGGRPLEN+1;
#endif
                           if (inl_needed>=ull_field_width || inl_needed+inl_dgsp_tm*inl_dgsp_lc<=ull_field_width) {
                             inl_s = inl_dgsp_tm*inl_dgsp_lc;
                             inl_needed += inl_s;
                           } else {  /* prefer staying within fieldwidth over using the separator */
                             inl_dgsp_lc = 0;
                           }
                         }
                       }
                       if (!bol_precision) {
                         ull_precision = 1;  /* default precision      */
                         if (bol_padding_zero) {
                           if (ull_field_width>inl_needed && !bol_adjustleft) {
                             /* fake padding with '0' by ull_precision */
                             ull_precision = ull_field_width+(inl_dgsp_lc?inl_emax+inl_s:inl_emax)-inl_needed;
                           }
                         }
                       }
                       if (inl_dgsp_lc) {   /* using digit group separation */
                         inl_precpad = ull_precision-(inl_emax+inl_s);
                         if (inl_precpad>0) {
#ifdef HL_USE_DIV
                           div_t dsl_d = div(inl_dgsp_ph+inl_precpad, D_DIGGRPLEN+inl_dgsp_lc);
                           inl_dgsp_tm += dsl_d.quot;
                           inl_needed += inl_precpad;
                           inl_dgsp_ph = dsl_d.rem;
#else
                           inl_needed += inl_precpad;
                           inl_dgsp_tm += (inl_dgsp_ph+inl_precpad)/(D_DIGGRPLEN+inl_dgsp_lc);
                           inl_dgsp_ph = (inl_dgsp_ph+inl_precpad)%(D_DIGGRPLEN+inl_dgsp_lc);
#endif
                           if (inl_dgsp_ph>D_DIGGRPLEN) {
                             inl_needed -= inl_dgsp_ph-D_DIGGRPLEN;
                             inl_dgsp_ph = D_DIGGRPLEN;
                           }
                           inl_precpad = ull_precision-(inl_emax+inl_dgsp_tm*inl_dgsp_lc);
                         } else {
                           inl_precpad=0;
                         }
                       } else {    /* not using digit group separation */
                         inl_precpad = ull_precision-inl_emax;
                         if (inl_precpad>0) {
                           inl_needed += inl_precpad;
                         } else {
                           inl_precpad=0;
                         }
                       }
                       if (ull_field_width > inl_needed) {
                         awcl_after = awcl_cur+ull_field_width;
                         inl_padsp = ull_field_width-inl_needed;
                         if (!bol_adjustleft) {  /* padding left with spaces */
                           if (inl_padsp > awcl_end-awcl_cur)
                             {awcl_after = awcl_cur; break;}  /* overflow */
                           do
                             *awcl_cur++ = HL_ENDIANSWAP_FROM_BYTE(' ');
                           while (--inl_padsp);
                         }
                       } else {
                         awcl_after = awcl_cur+inl_needed;
                         inl_padsp = 0;
                       }
                       if (inl_dgsp_lc) {   /* set digit group separators */
                         /* produce the first separator                                     */
                         awcl_dg = awcl_cur+inl_dgsp_ph;
                         if (iel_cs_target == ied_chs_utf_16) {  /* natural endian */
                           inl_dgsp_lo = m_u16l_from_u8l(awcl_dg, awcl_end-awcl_dg, achl_dgsp, inl_dgsp_lb);
                         } else {           /* swapped endian          */
                           inl_dgsp_lo = m_u16r_from_u8l(awcl_dg, 1+awcl_end-awcl_dg, achl_dgsp, inl_dgsp_lb);
                         }
                         /* now the complete physical output length can be determined      */
                         inl_s = inl_dgsp_tm*(inl_dgsp_lo-inl_dgsp_lc);  /* adjustment from logical to physical */
                         awcl_after += inl_s;
                         if (inl_dgsp_lo<0 || awcl_after-awcl_cur>awcl_end-awcl_cur)
                           {awcl_after = awcl_cur; break;}  /* overflow */
                         /* copy the other separators from the first one                   */
                         inl_s = inl_dgsp_tm-1;
                         if (inl_s) {
                           awcl0 = awcl_dg+inl_dgsp_lo;
                           do {
                             awcl0 += D_DIGGRPLEN;
                             int inl2 = 0;
                             do
                               *awcl0++ = awcl_dg[inl2++];
                             while (inl2<inl_dgsp_lo);
                           } while (--inl_s);
                         }
                         /* padding left with zeroes to "precision"                        */
                         while (inl_precpad) {
                           if (inl_dgsp_ph == 0) {  /* skip digits-separator */
                             awcl_cur += inl_dgsp_lo;
                             inl_dgsp_ph = D_DIGGRPLEN-1;
                             inl_dgsp_tm--;
                             if (!inl_dgsp_tm)
                               break;
                           } else {
                             inl_dgsp_ph--;
                           }
                           *awcl_cur++ = HL_ENDIANSWAP_FROM_BYTE('0');
                           inl_precpad --;
                         }
                       } else {             /* not using digit group separation */
                         if (awcl_after-awcl_cur>awcl_end-awcl_cur)
                           {awcl_after = awcl_cur; break;}  /* overflow */
                         /* padding left with zeroes to "precision"    */
                         while (inl_precpad) {
                           *awcl_cur++ = HL_ENDIANSWAP_FROM_BYTE('0');
                           inl_precpad --;
                         }
                       }
                       /* postfix                                      */
                       if (inl_postfixlen) {
                         if (inl_postfixlen==2) {
                           *(awcl_after-(inl_padsp+2)) = HL_ENDIANSWAP_FROM_BYTE(chl_postfix);
                           *(awcl_after-(inl_padsp+1)) = HL_ENDIANSWAP_FROM_BYTE('i');
                         } else {
                           *(awcl_after-(inl_padsp+1)) = HL_ENDIANSWAP_FROM_BYTE(chl_postfix);
                         }
                       }
                       /* padding right with spaces                    */
                       if (inl_padsp) {
                         awcl0 = awcl_after-1;
                         do
                           *awcl0-- = HL_ENDIANSWAP_FROM_BYTE(' ');
                         while (--inl_padsp);
                       }
                       /* produce the digits                           */
                       if (inl_emax > 0) {
#ifdef HL_USE_DIV
                         if (sizeof(unsigned int)<=sizeof(int)) {
                           div_t dsl_d;
                           dsl_d.quot = uml_arg/(unsigned int)DECBASE;
                           dsl_d.rem = uml_arg%(unsigned int)DECBASE;
                           if (inl_dgsp_lc) {  /* using digit group separation */
                             awcl_cur += inl_emax+inl_dgsp_tm*inl_dgsp_lo-1;
                             if (inl_dgsp_tm) {  /* write all digit groups that follow a separator */
                               inl_s=D_DIGGRPLEN;
                               while (TRUE) {
                                 do {
                                   *(awcl_cur)-- = HL_ENDIANSWAP_FROM_BYTE('0'+dsl_d.rem);
                                   dsl_d = div(dsl_d.quot,DECBASE);
                                 } while (--inl_s);
                                 awcl_cur -= inl_dgsp_lo;  /* skip digits-separator */
                                 if (--inl_dgsp_tm==0)
                                   break;
                                 inl_s=D_DIGGRPLEN;
                               }
                             }
                             if (inl_dgsp_ph) {  /* precision may provoke leading separator */
                               while (TRUE) {   /* write leading (maybe partial) digit group */
                                 *awcl_cur = HL_ENDIANSWAP_FROM_BYTE('0'+dsl_d.rem);
                                 if (--inl_dgsp_ph == 0) break;
                                 awcl_cur--;
                                 dsl_d = div(dsl_d.quot,DECBASE);
                               }
                             }
                           } else {  /* not using digit group separation */
                             while (TRUE) {
                               *(awcl_cur + --inl_emax) = HL_ENDIANSWAP_FROM_BYTE('0'+dsl_d.rem);
                               if (inl_emax <= 0) break;
                               dsl_d = div(dsl_d.quot,DECBASE);
                             }
                           }
#ifdef HL_USE_LDIV
                         } else if (sizeof(unsigned int)<=sizeof(long int)) {
                           ldiv_t dsl_d;
                           dsl_d.quot = uml_arg/(unsigned int)DECBASE;
                           dsl_d.rem = uml_arg%(unsigned int)DECBASE;
                           if (inl_dgsp_lc) {  /* using digit group separation */
                             awcl_cur += inl_emax+inl_dgsp_tm*inl_dgsp_lo-1;
                             if (inl_dgsp_tm) {  /* write all digit groups that follow a separator */
                               inl_s=D_DIGGRPLEN;
                               while (TRUE) {
                                 do {
                                   *(awcl_cur)-- = HL_ENDIANSWAP_FROM_BYTE('0'+dsl_d.rem);
                                   dsl_d = ldiv(dsl_d.quot,DECBASE);
                                 } while (--inl_s);
                                 awcl_cur -= inl_dgsp_lo;  /* skip digits-separator */
                                 if (--inl_dgsp_tm==0)
                                   break;
                                 inl_s=D_DIGGRPLEN;
                               }
                             }
                             if (inl_dgsp_ph) {  /* precision may provoke leading separator */
                               while (TRUE) {   /* write leading (maybe partial) digit group */
                                 *awcl_cur = HL_ENDIANSWAP_FROM_BYTE('0'+dsl_d.rem);
                                 if (--inl_dgsp_ph == 0) break;
                                 awcl_cur--;
                                 dsl_d = ldiv(dsl_d.quot,DECBASE);
                               }
                             }
                           } else {  /* not using digit group separation */
                             while (TRUE) {
                               *(awcl_cur + --inl_emax) = HL_ENDIANSWAP_FROM_BYTE('0'+dsl_d.rem);
                               if (inl_emax <= 0) break;
                               dsl_d = ldiv(dsl_d.quot,DECBASE);
                             }
                           }
#endif
#ifdef HL_USE_LLDIV
                         } else if (sizeof(unsigned int)<=sizeof(long long int)) {
                           lldiv_t dsl_d;
                           dsl_d.quot = uml_arg/(unsigned int)DECBASE;
                           dsl_d.rem = uml_arg%(unsigned int)DECBASE;
                           if (inl_dgsp_lc) {  /* using digit group separation */
                             awcl_cur += inl_emax+inl_dgsp_tm*inl_dgsp_lo-1;
                             if (inl_dgsp_tm) {  /* write all digit groups that follow a separator */
                               inl_s=D_DIGGRPLEN;
                               while (TRUE) {
                                 do {
                                   *(awcl_cur)-- = HL_ENDIANSWAP_FROM_BYTE('0'+dsl_d.rem);
                                   dsl_d = lldiv(dsl_d.quot,DECBASE);
                                 } while (--inl_s);
                                 awcl_cur -= inl_dgsp_lo;  /* skip digits-separator */
                                 if (--inl_dgsp_tm==0)
                                   break;
                                 inl_s=D_DIGGRPLEN;
                               }
                             }
                             if (inl_dgsp_ph) {  /* precision may provoke leading separator */
                               while (TRUE) {   /* write leading (maybe partial) digit group */
                                 *awcl_cur = HL_ENDIANSWAP_FROM_BYTE('0'+dsl_d.rem);
                                 if (--inl_dgsp_ph == 0) break;
                                 awcl_cur--;
                                 dsl_d = lldiv(dsl_d.quot,DECBASE);
                               }
                             }
                           } else {  /* not using digit group separation */
                             while (TRUE) {
                               *(awcl_cur + --inl_emax) = HL_ENDIANSWAP_FROM_BYTE('0'+dsl_d.rem);
                               if (inl_emax <= 0) break;
                               dsl_d = lldiv(dsl_d.quot,DECBASE);
                             }
                           }
#endif
                         } else {
#endif
                           if (inl_dgsp_lc) {  /* using digit group separation */
                             awcl_cur += inl_emax+inl_dgsp_tm*inl_dgsp_lo-1;
                             if (inl_dgsp_tm) {  /* write all digit groups that follow a separator */
                               inl_s=D_DIGGRPLEN;
                               while (TRUE) {
                                 do {
                                   *(awcl_cur)-- = HL_ENDIANSWAP_FROM_BYTE('0'+uml_arg%(unsigned int)DECBASE);
                                   uml_arg/=(unsigned int)DECBASE;
                                 } while (--inl_s);
                                 awcl_cur -= inl_dgsp_lo;  /* skip digits-separator */
                                 if (--inl_dgsp_tm==0)
                                   break;
                                 inl_s=D_DIGGRPLEN;
                               }
                             }
                             if (inl_dgsp_ph) {  /* precision may provoke leading separator */
                               while (TRUE) {   /* write leading (maybe partial) digit group */
                                 *awcl_cur = HL_ENDIANSWAP_FROM_BYTE('0'+uml_arg%(unsigned int)DECBASE);
                                 if (--inl_dgsp_ph == 0) break;
                                 awcl_cur--;
                                 uml_arg/=(unsigned int)DECBASE;
                               }
                             }
                           } else {  /* not using digit group separation */
                             while (--inl_emax > 0) {
                               *(awcl_cur+inl_emax) = HL_ENDIANSWAP_FROM_BYTE('0'+uml_arg%(unsigned int)DECBASE);
                               uml_arg/=(unsigned int)DECBASE;
                             }
                             *awcl_cur = HL_ENDIANSWAP_FROM_BYTE('0'+uml_arg);
                           }
#ifdef HL_USE_DIV
                         }
#endif
                         awcl_cur += inl_emax;
                       }
                     break;
                   case 'O':
                       inl_emax = 0;
                       achl_digits = chl_spec&'\040' ? chrstrans_lc : chrstrans;  /* choose upper- or lowercase */
                       if (uml_arg!=0) {
                         int inl_e = (sizeof(unsigned int)<<3)/3;
                         if (inl_e*3 < sizeof(unsigned int)<<3)
                           inl_e++;
                         do {
                           inl_s = inl_e>>1;
                           if (uml_arg >= (unsigned int)1<<((inl_emax+inl_s)*3)) {
                             inl_emax += inl_s;
                             inl_e -= inl_s;
                           } else {
                             inl_e = inl_s;
                           }
                         } while (inl_e>1);
                         inl_emax ++;
                         /* now inl_emax is number of digits needed    */
                       }
                       inl_needed = inl_emax + inl_postfixlen;
                       if (inl_dgsp_lc) {   /* use digit group separation */
                         if (inl_emax<=D_DIGGRPLEN) {  /* digit grouping not in effect */
                           inl_dgsp_lc = 0;
                         } else {
                           const int inl_emax_1 = inl_emax-1;
#ifdef HL_USE_DIV
                           dsl_diggrp_dm = div(inl_emax_1, D_DIGGRPLEN);
                           inl_dgsp_ph++;
#else
                           inl_dgsp_tm = (inl_emax_1)/D_DIGGRPLEN;
                           inl_dgsp_ph = (inl_emax_1)%D_DIGGRPLEN+1;
#endif
                           if (inl_needed>=ull_field_width || inl_needed+inl_dgsp_tm*inl_dgsp_lc<=ull_field_width) {
                             inl_s = inl_dgsp_tm*inl_dgsp_lc;
                             inl_needed += inl_s;
                           } else {  /* prefer staying within fieldwidth over using the separator */
                             inl_dgsp_lc = 0;
                           }
                         }
                       }
                       if (!bol_precision) {
                         ull_precision = 1;  /* default precision      */
                         if (bol_padding_zero) {
                           if (ull_field_width>inl_needed && !bol_adjustleft) {
                             /* fake padding with '0' by ull_precision */
                             ull_precision = ull_field_width+(inl_dgsp_lc?inl_emax+inl_s:inl_emax)-inl_needed;
                           } else {
                             bol_padding_zero = false;  /* according to spec, zeroflag is ignored in
                                               integer conversion if left-justify-flag is present */
                           }
                         }
                       } else {
                         bol_padding_zero = false;  /* according to spec, zeroflag is ignored in
                                                       integer conversion if a precision is given */
                       }
                       if (inl_dgsp_lc) {   /* using digit group separation */
                         inl_precpad = ull_precision-(inl_emax+inl_s);
                         if (inl_precpad>0) {
#ifdef HL_USE_DIV
                           div_t dsl_d = div(inl_dgsp_ph+inl_precpad, D_DIGGRPLEN+inl_dgsp_lc);
                           inl_dgsp_tm += dsl_d.quot;
                           inl_needed += inl_precpad;
                           inl_dgsp_ph = dsl_d.rem;
#else
                           inl_needed += inl_precpad;
                           inl_dgsp_tm += (inl_dgsp_ph+inl_precpad)/(D_DIGGRPLEN+inl_dgsp_lc);
                           inl_dgsp_ph = (inl_dgsp_ph+inl_precpad)%(D_DIGGRPLEN+inl_dgsp_lc);
#endif
                           if (inl_dgsp_ph>D_DIGGRPLEN) {
                            if (bol_alternate_form && (uml_arg!=0) &&
                                !(bol_padding_zero && (ull_precision>inl_emax+inl_dgsp_tm*D_DIGGRPLEN)))
                            {               /* ensure octal prefix     */
                             inl_dgsp_tm++;
                             ull_precision += 1+inl_dgsp_lc+D_DIGGRPLEN-inl_dgsp_ph;
                             inl_needed += 1+inl_dgsp_lc+D_DIGGRPLEN-inl_dgsp_ph;
                             inl_dgsp_ph = 1;
                            } else {
                             inl_needed -= inl_dgsp_ph-D_DIGGRPLEN;
                             inl_dgsp_ph = D_DIGGRPLEN;
                            }
                           } else if (bol_alternate_form && (inl_dgsp_ph==0) && (uml_arg!=0)) {
                             if (bol_padding_zero && (ull_precision-inl_dgsp_lc>inl_emax+(inl_dgsp_tm-1)*D_DIGGRPLEN)) {
                               /* prefer staying within fieldwidth over avoiding all spacepadding */
                               inl_dgsp_tm--;
                               ull_precision -= inl_dgsp_lc;
                               inl_needed -= inl_dgsp_lc;
                               inl_dgsp_ph = D_DIGGRPLEN;
                             } else {
                               ull_precision++;
                               inl_needed++;
                               inl_dgsp_ph=1;
                             }
                           }
                           inl_precpad = ull_precision-(inl_emax+inl_dgsp_tm*inl_dgsp_lc);
                         } else {
                          if (bol_alternate_form && (uml_arg!=0)) {  /* ensure octal prefix */
                            if (inl_dgsp_ph>=D_DIGGRPLEN) {
                              inl_dgsp_tm++;
                              ull_precision += 1+inl_dgsp_lc+D_DIGGRPLEN-inl_dgsp_ph;
                              inl_needed += 1+inl_dgsp_lc+D_DIGGRPLEN-inl_dgsp_ph;
                              inl_dgsp_ph = 1;
                            } else {
                              ull_precision++;
                              inl_needed++;
                              inl_dgsp_ph++;
                            }
                            inl_precpad++;
                          } else {
                           inl_precpad=0;
                          }
                         }
                       } else {    /* not using digit group separation */
                         if (bol_alternate_form && (uml_arg!=0) && (ull_precision<=inl_emax))
                           ull_precision = inl_emax+1;  /* cause octal prefix */
                         inl_precpad = ull_precision-inl_emax;
                         if (inl_precpad>0) {
                           inl_needed += inl_precpad;
                         } else {
                           inl_precpad=0;
                         }
                       }
                       if (ull_field_width > inl_needed) {
                         awcl_after = awcl_cur+ull_field_width;
                         inl_padsp = ull_field_width-inl_needed;
                         if (!bol_adjustleft) {  /* padding left with spaces */
                           if (inl_padsp > awcl_end-awcl_cur)
                             {awcl_after = awcl_cur; break;}  /* overflow */
                           do
                             *awcl_cur++ = HL_ENDIANSWAP_FROM_BYTE(' ');
                           while (--inl_padsp);
                         }
                       } else {
                         awcl_after = awcl_cur+inl_needed;
                         inl_padsp = 0;
                       }
                       if (inl_dgsp_lc) {   /* set digit group separators */
                         /* produce the first separator                                     */
                         awcl_dg = awcl_cur+inl_dgsp_ph;
                         if (iel_cs_target == ied_chs_utf_16) {  /* natural endian */
                           inl_dgsp_lo = m_u16l_from_u8l(awcl_dg, awcl_end-awcl_dg, achl_dgsp, inl_dgsp_lb);
                         } else {           /* swapped endian          */
                           inl_dgsp_lo = m_u16r_from_u8l(awcl_dg, 1+awcl_end-awcl_dg, achl_dgsp, inl_dgsp_lb);
                         }
                         /* now the complete physical output length can be determined      */
                         inl_s = inl_dgsp_tm*(inl_dgsp_lo-inl_dgsp_lc);  /* adjustment from logical to physical */
                         awcl_after += inl_s;
                         if (inl_dgsp_lo<0 || awcl_after-awcl_cur>awcl_end-awcl_cur)
                           {awcl_after = awcl_cur; break;}  /* overflow */
                         /* copy the other separators from the first one                   */
                         inl_s = inl_dgsp_tm-1;
                         if (inl_s) {
                           awcl0 = awcl_dg+inl_dgsp_lo;
                           do {
                             awcl0 += D_DIGGRPLEN;
                             int inl2 = 0;
                             do
                               *awcl0++ = awcl_dg[inl2++];
                             while (inl2<inl_dgsp_lo);
                           } while (--inl_s);
                         }
                         /* padding left with zeroes to "precision"                        */
                         while (inl_precpad) {
                           if (inl_dgsp_ph == 0) {  /* skip digits-separator */
                             awcl_cur += inl_dgsp_lo;
                             inl_dgsp_ph = D_DIGGRPLEN-1;
                             inl_dgsp_tm--;
                             if (!inl_dgsp_tm)
                               break;
                           } else {
                             inl_dgsp_ph--;
                           }
                           *awcl_cur++ = HL_ENDIANSWAP_FROM_BYTE('0');
                           inl_precpad --;
                         }
                       } else {             /* not using digit group separation */
                         if (awcl_after-awcl_cur>awcl_end-awcl_cur)
                           {awcl_after = awcl_cur; break;}  /* overflow */
                         /* padding left with zeroes to "precision"    */
                         while (inl_precpad) {
                           *awcl_cur++ = HL_ENDIANSWAP_FROM_BYTE('0');
                           inl_precpad --;
                         }
                       }
                       /* postfix                                      */
                       if (inl_postfixlen) {
                         if (inl_postfixlen==2) {
                           *(awcl_after-(inl_padsp+2)) = HL_ENDIANSWAP_FROM_BYTE(chl_postfix);
                           *(awcl_after-(inl_padsp+1)) = HL_ENDIANSWAP_FROM_BYTE('i');
                         } else {
                           *(awcl_after-(inl_padsp+1)) = HL_ENDIANSWAP_FROM_BYTE(chl_postfix);
                         }
                       }
                       /* padding right with spaces                    */
                       if (inl_padsp) {
                         awcl0 = awcl_after-1;
                         do
                           *awcl0-- = HL_ENDIANSWAP_FROM_BYTE(' ');
                         while (--inl_padsp);
                       }
                       if (inl_emax!=0) {  /* done if zero-"precision" zero */
                         inl_emax --;
                         inl_emax *= 3;
                         if (inl_dgsp_lc) {  /* using digit group separation */
                           while (TRUE) {
                             while (inl_dgsp_ph) {
                               *(awcl_cur)++ = HL_ENDIANSWAP_FROM_BYTE(achl_digits[(uml_arg>>inl_emax) & (1<<3)-1]);
                               inl_dgsp_ph--;
                               inl_emax -= 3;
                             }
                             inl_dgsp_tm--;
                             if (!inl_dgsp_tm)
                               break;       /* all digitgroups done    */
                             awcl_cur += inl_dgsp_lo;  /* skip digits-separator */
                             inl_dgsp_ph = D_DIGGRPLEN-1;
                           }
                         } else {  /* not using digit group separation */
                           while(TRUE) {
                             *(awcl_cur) = HL_ENDIANSWAP_FROM_BYTE(achl_digits[(uml_arg>>inl_emax) & (1<<3)-1]);
                             if (inl_emax==0)
                               break;
                             (awcl_cur)++;
                             inl_emax -= 3;
                           }
                         }
                       }
                     break;
                   case 'X':
                       inl_emax = 0;
                       achl_digits = chl_spec&'\040' ? chrstrans_lc : chrstrans;  /* choose upper- or lowercase */
                       if (uml_arg!=0) {
                         int inl_e = (sizeof(unsigned int)<<3)/4;
                         if (inl_e*4 < sizeof(unsigned int)<<3)
                           inl_e++;
                         do {
                           inl_s = inl_e>>1;
                           if (uml_arg >= (unsigned int)1<<((inl_emax+inl_s)*4)) {
                             inl_emax += inl_s;
                             inl_e -= inl_s;
                           } else {
                             inl_e = inl_s;
                           }
                         } while (inl_e>1);
                         inl_emax ++;
                         /* now inl_emax is number of digits needed    */
                       }
                       inl_needed = inl_emax + inl_postfixlen;
                       if (bol_alternate_form && (uml_arg!=0))
                         inl_needed += 2;   /* for hex prefix          */
                       if (inl_dgsp_lc) {   /* use digit group separation */
                         if (inl_emax<=D_DIGGRPLEN) {  /* digit grouping not in effect */
                           inl_dgsp_lc = 0;
                         } else {
                           const int inl_emax_1 = inl_emax-1;
#ifdef HL_USE_DIV
                           dsl_diggrp_dm = div(inl_emax_1, D_DIGGRPLEN);
                           inl_dgsp_ph++;
#else
                           inl_dgsp_tm = (inl_emax_1)/D_DIGGRPLEN;
                           inl_dgsp_ph = (inl_emax_1)%D_DIGGRPLEN+1;
#endif
                           if (inl_needed>=ull_field_width || inl_needed+inl_dgsp_tm*inl_dgsp_lc<=ull_field_width) {
                             inl_s = inl_dgsp_tm*inl_dgsp_lc;
                             inl_needed += inl_s;
                           } else {  /* prefer staying within fieldwidth over using the separator */
                             inl_dgsp_lc = 0;
                           }
                         }
                       }
                       if (!bol_precision) {
                         ull_precision = 1;  /* default precision      */
                         if (bol_padding_zero) {
                           if (ull_field_width>inl_needed && !bol_adjustleft) {
                             /* fake padding with '0' by ull_precision */
                             ull_precision = ull_field_width+(inl_dgsp_lc?inl_emax+inl_s:inl_emax)-inl_needed;
                           }
                         }
                       }
                       if (inl_dgsp_lc) {   /* using digit group separation */
                         inl_precpad = ull_precision-(inl_emax+inl_s);
                         if (inl_precpad>0) {
#ifdef HL_USE_DIV
                           div_t dsl_d = div(inl_dgsp_ph+inl_precpad, D_DIGGRPLEN+inl_dgsp_lc);
                           inl_dgsp_tm += dsl_d.quot;
                           inl_needed += inl_precpad;
                           inl_dgsp_ph = dsl_d.rem;
#else
                           inl_needed += inl_precpad;
                           inl_dgsp_tm += (inl_dgsp_ph+inl_precpad)/(D_DIGGRPLEN+inl_dgsp_lc);
                           inl_dgsp_ph = (inl_dgsp_ph+inl_precpad)%(D_DIGGRPLEN+inl_dgsp_lc);
#endif
                           if (inl_dgsp_ph>D_DIGGRPLEN) {
                             inl_needed -= inl_dgsp_ph-D_DIGGRPLEN;
                             inl_dgsp_ph = D_DIGGRPLEN;
                           }
                           inl_precpad = ull_precision-(inl_emax+inl_dgsp_tm*inl_dgsp_lc);
                         } else {
                           inl_precpad=0;
                         }
                       } else {    /* not using digit group separation */
                         inl_precpad = ull_precision-inl_emax;
                         if (inl_precpad>0) {
                           inl_needed += inl_precpad;
                         } else {
                           inl_precpad=0;
                         }
                       }
                       if (ull_field_width > inl_needed) {
                         awcl_after = awcl_cur+ull_field_width;
                         inl_padsp = ull_field_width-inl_needed;
                         if (!bol_adjustleft) {  /* padding left with spaces */
                           if (inl_padsp > awcl_end-awcl_cur)
                             {awcl_after = awcl_cur; break;}  /* overflow */
                           do
                             *awcl_cur++ = HL_ENDIANSWAP_FROM_BYTE(' ');
                           while (--inl_padsp);
                         }
                       } else {
                         awcl_after = awcl_cur+inl_needed;
                         inl_padsp = 0;
                       }
                       if (inl_dgsp_lc) {   /* set digit group separators */
                         if (bol_alternate_form && (uml_arg!=0)) {  /* write hex prefix    */
                           if (2 > awcl_end-awcl_cur)
                             {awcl_after = awcl_cur; break;}  /* overflow */
                           *awcl_cur++ = HL_ENDIANSWAP_FROM_BYTE('0');
                           *awcl_cur++ = HL_ENDIANSWAP_FROM_BYTE('X'|(chl_spec&'\040'));
                         }
                         /* produce the first separator                                     */
                         awcl_dg = awcl_cur+inl_dgsp_ph;
                         if (iel_cs_target == ied_chs_utf_16) {  /* natural endian */
                           inl_dgsp_lo = m_u16l_from_u8l(awcl_dg, awcl_end-awcl_dg, achl_dgsp, inl_dgsp_lb);
                         } else {           /* swapped endian          */
                           inl_dgsp_lo = m_u16r_from_u8l(awcl_dg, 1+awcl_end-awcl_dg, achl_dgsp, inl_dgsp_lb);
                         }
                         /* now the complete physical output length can be determined      */
                         inl_s = inl_dgsp_tm*(inl_dgsp_lo-inl_dgsp_lc);  /* adjustment from logical to physical */
                         awcl_after += inl_s;
                         if (inl_dgsp_lo<0 || awcl_after-awcl_cur>awcl_end-awcl_cur)
                           {awcl_after = awcl_cur; break;}  /* overflow */
                         /* copy the other separators from the first one                   */
                         inl_s = inl_dgsp_tm-1;
                         if (inl_s) {
                           awcl0 = awcl_dg+inl_dgsp_lo;
                           do {
                             awcl0 += D_DIGGRPLEN;
                             int inl2 = 0;
                             do
                               *awcl0++ = awcl_dg[inl2++];
                             while (inl2<inl_dgsp_lo);
                           } while (--inl_s);
                         }
                         /* padding left with zeroes to "precision"                        */
                         while (inl_precpad) {
                           if (inl_dgsp_ph == 0) {  /* skip digits-separator */
                             awcl_cur += inl_dgsp_lo;
                             inl_dgsp_ph = D_DIGGRPLEN-1;
                             inl_dgsp_tm--;
                             if (!inl_dgsp_tm)
                               break;
                           } else {
                             inl_dgsp_ph--;
                           }
                           *awcl_cur++ = HL_ENDIANSWAP_FROM_BYTE('0');
                           inl_precpad --;
                         }
                       } else {             /* not using digit group separation */
                         if (awcl_after-awcl_cur>awcl_end-awcl_cur)
                           {awcl_after = awcl_cur; break;}  /* overflow */
                         if (bol_alternate_form && (uml_arg!=0)) {  /* write hex prefix */
                           *awcl_cur++ = HL_ENDIANSWAP_FROM_BYTE('0');
                           *awcl_cur++ = HL_ENDIANSWAP_FROM_BYTE('X'|(chl_spec&'\040'));
                         }
                         /* padding left with zeroes to "precision"    */
                         while (inl_precpad) {
                           *awcl_cur++ = HL_ENDIANSWAP_FROM_BYTE('0');
                           inl_precpad --;
                         }
                       }
                       /* postfix                                      */
                       if (inl_postfixlen) {
                         if (inl_postfixlen==2) {
                           *(awcl_after-(inl_padsp+2)) = HL_ENDIANSWAP_FROM_BYTE(chl_postfix);
                           *(awcl_after-(inl_padsp+1)) = HL_ENDIANSWAP_FROM_BYTE('i');
                         } else {
                           *(awcl_after-(inl_padsp+1)) = HL_ENDIANSWAP_FROM_BYTE(chl_postfix);
                         }
                       }
                       /* padding right with spaces                    */
                       if (inl_padsp) {
                         awcl0 = awcl_after-1;
                         do
                           *awcl0-- = HL_ENDIANSWAP_FROM_BYTE(' ');
                         while (--inl_padsp);
                       }
                       if (inl_emax!=0) {  /* done if zero-"precision" zero */
                         inl_emax --;
                         inl_emax *= 4;
                         if (inl_dgsp_lc) {  /* using digit group separation */
                           while (TRUE) {
                             while (inl_dgsp_ph) {
                               *(awcl_cur)++ = HL_ENDIANSWAP_FROM_BYTE(achl_digits[(uml_arg>>inl_emax) & (1<<4)-1]);
                               inl_dgsp_ph--;
                               inl_emax -= 4;
                             }
                             inl_dgsp_tm--;
                             if (!inl_dgsp_tm)
                               break;       /* all digitgroups done    */
                             awcl_cur += inl_dgsp_lo;  /* skip digits-separator */
                             inl_dgsp_ph = D_DIGGRPLEN-1;
                           }
                         } else {  /* not using digit group separation */
                           while(TRUE) {
                             *(awcl_cur) = HL_ENDIANSWAP_FROM_BYTE(achl_digits[(uml_arg>>inl_emax) & (1<<4)-1]);
                             if (inl_emax==0)
                               break;
                             (awcl_cur)++;
                             inl_emax -= 4;
                           }
                         }
                       }
                     break;
                 }
                 break;
               case 'l': case 'L':
                 if(bol_longlong){
                   ull_arg = va_arg(dsl_list, HL_ULONGLONG);
                   switch (chl_spec&0xDF) {
                     case 'U':

                       /* prepare %(sci-dec)- or %(sci-dec)-type of rendering */
                       if (iel_scaling!=ied_scaling_none) {
                         if (iel_scaling == ied_scaling_1000) {  /* power-of-1000-scaled */
#if HL_PRFMAXSO_LL > 4
                           if ((sizeof(HL_ULONGLONG) > 4) && (ull_arg >= D_L1000RD * ullrs_decpowbuf[9])) {
                             if (
                                 (ull_arg >= D_L1000RD * ullrs_decpowbuf[15])
                                ) {
#if HL_PRFMAXSO_LL > 8
                               if (
                                   (sizeof(HL_ULONGLONG) > 8) &&
                                   (ull_arg >= D_L1000RD * ullrs_decpowbuf[18])
                                  ) {
                                 if (ull_arg >= D_L1000RD * ullrs_decpowbuf[21]) {
                                   ull_arg =  (ull_arg + 500 * ullrs_decpowbuf[21]) / (ullrs_decpowbuf[24]);
                                   chl_postfix = 'Y';
                                 } else {
                                   ull_arg =  (ull_arg + 500 * ullrs_decpowbuf[18]) / (ullrs_decpowbuf[21]);
                                   chl_postfix = 'Z';
                                 }
                               } else {
#endif
                                 ull_arg =  (ull_arg + 500 * ullrs_decpowbuf[15]) / (ullrs_decpowbuf[18]);
                                 chl_postfix = 'E';
#if HL_PRFMAXSO_LL > 8
                               }
#endif
                             } else {
                               if (ull_arg >= D_L1000RD * ullrs_decpowbuf[12]) {
                                 ull_arg =  (ull_arg + 500 * ullrs_decpowbuf[12]) / (ullrs_decpowbuf[15]);
                                 chl_postfix = 'P';
                               } else {
                                 ull_arg =  (ull_arg + 500 * ullrs_decpowbuf[9]) / (ullrs_decpowbuf[12]);
                                 chl_postfix = 'T';
                               }
                             }
                             inl_postfixlen = 1;
                           } else {
#endif
#if HL_PRFMAXSO_LL > 2
                             if ((sizeof(HL_ULONGLONG) > 2) && (ull_arg >= D_L1000RD * ullrs_decpowbuf[3])) {
#if HL_PRFMAXSO_LL > 4
                               if ((sizeof(HL_ULONGLONG) > 4) && (ull_arg >= D_L1000RD * ullrs_decpowbuf[6])) {
                                 ull_arg =  (ull_arg + 500 * ullrs_decpowbuf[6]) / (ullrs_decpowbuf[9]);
                                 chl_postfix = 'G';
                               } else {
#endif
                                 ull_arg =  (ull_arg + 500 * ullrs_decpowbuf[3]) / (ullrs_decpowbuf[6]);
                                 chl_postfix = 'M';
#if HL_PRFMAXSO_LL > 4
                               }
#endif
                               inl_postfixlen = 1;
                             } else {
#endif
                               if (ull_arg >= D_L1000RD) {
                                 ull_arg = (ull_arg + 500) / 1000;
                                 chl_postfix = 'k';
                                 inl_postfixlen = 1;
                               }
#if HL_PRFMAXSO_LL > 2
                             }
#endif
#if HL_PRFMAXSO_LL > 4
                           }
#endif
                         }
                         else {               /* power-of-1024-scaled    */
#if HL_PRFMAXSO_LL > 4
                           if ((sizeof(HL_ULONGLONG) > 4) && (ull_arg>>30 >= D_L1024RD)) {
                             if (
                                 (ull_arg>>50 >= D_L1024RD)
                                ) {
#if HL_PRFMAXSO_LL > 8
                               if (
                                   (sizeof(HL_ULONGLONG) > 8) &&
                                   (ull_arg>>60 >= D_L1024RD)
                                  ) {
                                 if (ull_arg>>70 >= D_L1024RD) {
                                   ull_arg = (ull_arg+((HL_ULONGLONG)1<<79)) >> 80;
                                   chl_postfix = 'Y';
                                 } else {
                                   ull_arg = (ull_arg+((HL_ULONGLONG)1<<69)) >> 70;
                                   chl_postfix = 'Z';
                                 }
                               } else {
#endif
                                 ull_arg = (ull_arg+((HL_ULONGLONG)1<<59)) >> 60;
                                 chl_postfix = 'E';
#if HL_PRFMAXSO_LL > 8
                               }
#endif
                             } else {
                               if (ull_arg>>40 >= D_L1024RD) {
                                 ull_arg = (ull_arg+((HL_ULONGLONG)1<<49)) >> 50;
                                 chl_postfix = 'P';
                               } else {
                                 ull_arg = (ull_arg+((HL_ULONGLONG)1<<39)) >> 40;
                                 chl_postfix = 'T';
                               }
                             }
                             inl_postfixlen = bol_alternate_form ? 2 : 1;
                           } else {
#endif
#if HL_PRFMAXSO_LL > 2
                             if ((sizeof(HL_ULONGLONG) > 2) && (ull_arg>>10 >= D_L1024RD)) {
#if HL_PRFMAXSO_LL > 4
                               if ((sizeof(HL_ULONGLONG) > 4) && (ull_arg>>20 >= D_L1024RD)) {
                                 ull_arg = (ull_arg+((HL_ULONGLONG)1<<29)) >> 30;
                                 chl_postfix = 'G';
                               } else {
#endif
                                 ull_arg = (ull_arg+((HL_ULONGLONG)1<<19)) >> 20;
                                 chl_postfix = 'M';
#if HL_PRFMAXSO_LL > 4
                               }
#endif
                               inl_postfixlen = bol_alternate_form ? 2 : 1;
                             } else {
#endif
                               if (ull_arg >= D_L1024RD) {
                                 ull_arg = (ull_arg+0x200) >> 10;
                                 chl_postfix = 'K';
                                 inl_postfixlen = bol_alternate_form ? 2 : 1;
                               }
#if HL_PRFMAXSO_LL > 2
                             }
#endif
#if HL_PRFMAXSO_LL > 4
                           }
#endif
                         }
                       }

                       /* detect the order of magnitude of X           */
                       inl_emax = 0;
                       if (ull_arg) {
                         int inl_e = ((sizeof(HL_ULONGLONG)*240824)/100000)+1;
                         do {
                           inl_s = inl_e>>1;
                           if (ull_arg >= ullrs_decpowbuf[inl_emax+inl_s]) {
                             inl_emax += inl_s;
                             inl_e -= inl_s;
                           } else {
                             inl_e = inl_s;
                           }
                         } while (inl_e>1);
                         inl_emax ++;
                       }
                       inl_needed = inl_emax + inl_postfixlen;
                       if (inl_dgsp_lc) {   /* use digit group separation */
                         if (inl_emax<=D_DIGGRPLEN) {  /* digit grouping not in effect */
                           inl_dgsp_lc = 0;
                         } else {
                           const int inl_emax_1 = inl_emax-1;
#ifdef HL_USE_DIV
                           dsl_diggrp_dm = div(inl_emax_1, D_DIGGRPLEN);
                           inl_dgsp_ph++;
#else
                           inl_dgsp_tm = (inl_emax_1)/D_DIGGRPLEN;
                           inl_dgsp_ph = (inl_emax_1)%D_DIGGRPLEN+1;
#endif
                           if (inl_needed>=ull_field_width || inl_needed+inl_dgsp_tm*inl_dgsp_lc<=ull_field_width) {
                             inl_s = inl_dgsp_tm*inl_dgsp_lc;
                             inl_needed += inl_s;
                           } else {  /* prefer staying within fieldwidth over using the separator */
                             inl_dgsp_lc = 0;
                           }
                         }
                       }
                       if (!bol_precision) {
                         ull_precision = 1;  /* default precision      */
                         if (bol_padding_zero) {
                           if (ull_field_width>inl_needed && !bol_adjustleft) {
                             /* fake padding with '0' by ull_precision */
                             ull_precision = ull_field_width+(inl_dgsp_lc?inl_emax+inl_s:inl_emax)-inl_needed;
                           }
                         }
                       }
                       if (inl_dgsp_lc) {   /* using digit group separation */
                         inl_precpad = ull_precision-(inl_emax+inl_s);
                         if (inl_precpad>0) {
#ifdef HL_USE_DIV
                           div_t dsl_d = div(inl_dgsp_ph+inl_precpad, D_DIGGRPLEN+inl_dgsp_lc);
                           inl_dgsp_tm += dsl_d.quot;
                           inl_needed += inl_precpad;
                           inl_dgsp_ph = dsl_d.rem;
#else
                           inl_needed += inl_precpad;
                           inl_dgsp_tm += (inl_dgsp_ph+inl_precpad)/(D_DIGGRPLEN+inl_dgsp_lc);
                           inl_dgsp_ph = (inl_dgsp_ph+inl_precpad)%(D_DIGGRPLEN+inl_dgsp_lc);
#endif
                           if (inl_dgsp_ph>D_DIGGRPLEN) {
                             inl_needed -= inl_dgsp_ph-D_DIGGRPLEN;
                             inl_dgsp_ph = D_DIGGRPLEN;
                           }
                           inl_precpad = ull_precision-(inl_emax+inl_dgsp_tm*inl_dgsp_lc);
                         } else {
                           inl_precpad=0;
                         }
                       } else {    /* not using digit group separation */
                         inl_precpad = ull_precision-inl_emax;
                         if (inl_precpad>0) {
                           inl_needed += inl_precpad;
                         } else {
                           inl_precpad=0;
                         }
                       }
                       if (ull_field_width > inl_needed) {
                         awcl_after = awcl_cur+ull_field_width;
                         inl_padsp = ull_field_width-inl_needed;
                         if (!bol_adjustleft) {  /* padding left with spaces */
                           if (inl_padsp > awcl_end-awcl_cur)
                             {awcl_after = awcl_cur; break;}  /* overflow */
                           do
                             *awcl_cur++ = HL_ENDIANSWAP_FROM_BYTE(' ');
                           while (--inl_padsp);
                         }
                       } else {
                         awcl_after = awcl_cur+inl_needed;
                         inl_padsp = 0;
                       }
                       if (inl_dgsp_lc) {   /* set digit group separators */
                         /* produce the first separator                                     */
                         awcl_dg = awcl_cur+inl_dgsp_ph;
                         if (iel_cs_target == ied_chs_utf_16) {  /* natural endian */
                           inl_dgsp_lo = m_u16l_from_u8l(awcl_dg, awcl_end-awcl_dg, achl_dgsp, inl_dgsp_lb);
                         } else {           /* swapped endian          */
                           inl_dgsp_lo = m_u16r_from_u8l(awcl_dg, 1+awcl_end-awcl_dg, achl_dgsp, inl_dgsp_lb);
                         }
                         /* now the complete physical output length can be determined      */
                         inl_s = inl_dgsp_tm*(inl_dgsp_lo-inl_dgsp_lc);  /* adjustment from logical to physical */
                         awcl_after += inl_s;
                         if (inl_dgsp_lo<0 || awcl_after-awcl_cur>awcl_end-awcl_cur)
                           {awcl_after = awcl_cur; break;}  /* overflow */
                         /* copy the other separators from the first one                   */
                         inl_s = inl_dgsp_tm-1;
                         if (inl_s) {
                           awcl0 = awcl_dg+inl_dgsp_lo;
                           do {
                             awcl0 += D_DIGGRPLEN;
                             int inl2 = 0;
                             do
                               *awcl0++ = awcl_dg[inl2++];
                             while (inl2<inl_dgsp_lo);
                           } while (--inl_s);
                         }
                         /* padding left with zeroes to "precision"                        */
                         while (inl_precpad) {
                           if (inl_dgsp_ph == 0) {  /* skip digits-separator */
                             awcl_cur += inl_dgsp_lo;
                             inl_dgsp_ph = D_DIGGRPLEN-1;
                             inl_dgsp_tm--;
                             if (!inl_dgsp_tm)
                               break;
                           } else {
                             inl_dgsp_ph--;
                           }
                           *awcl_cur++ = HL_ENDIANSWAP_FROM_BYTE('0');
                           inl_precpad --;
                         }
                       } else {             /* not using digit group separation */
                         if (awcl_after-awcl_cur>awcl_end-awcl_cur)
                           {awcl_after = awcl_cur; break;}  /* overflow */
                         /* padding left with zeroes to "precision"    */
                         while (inl_precpad) {
                           *awcl_cur++ = HL_ENDIANSWAP_FROM_BYTE('0');
                           inl_precpad --;
                         }
                       }
                       /* postfix                                      */
                       if (inl_postfixlen) {
                         if (inl_postfixlen==2) {
                           *(awcl_after-(inl_padsp+2)) = HL_ENDIANSWAP_FROM_BYTE(chl_postfix);
                           *(awcl_after-(inl_padsp+1)) = HL_ENDIANSWAP_FROM_BYTE('i');
                         } else {
                           *(awcl_after-(inl_padsp+1)) = HL_ENDIANSWAP_FROM_BYTE(chl_postfix);
                         }
                       }
                       /* padding right with spaces                    */
                       if (inl_padsp) {
                         awcl0 = awcl_after-1;
                         do
                           *awcl0-- = HL_ENDIANSWAP_FROM_BYTE(' ');
                         while (--inl_padsp);
                       }
                       /* produce the digits                           */
                       if (inl_emax > 0) {
#ifdef HL_USE_DIV
                         if (sizeof(HL_ULONGLONG)<=sizeof(int)) {
                           div_t dsl_d;
                           dsl_d.quot = ull_arg/(HL_ULONGLONG)DECBASE;
                           dsl_d.rem = ull_arg%(HL_ULONGLONG)DECBASE;
                           if (inl_dgsp_lc) {  /* using digit group separation */
                             awcl_cur += inl_emax+inl_dgsp_tm*inl_dgsp_lo-1;
                             if (inl_dgsp_tm) {  /* write all digit groups that follow a separator */
                               inl_s=D_DIGGRPLEN;
                               while (TRUE) {
                                 do {
                                   *(awcl_cur)-- = HL_ENDIANSWAP_FROM_BYTE('0'+dsl_d.rem);
                                   dsl_d = div(dsl_d.quot,DECBASE);
                                 } while (--inl_s);
                                 awcl_cur -= inl_dgsp_lo;  /* skip digits-separator */
                                 if (--inl_dgsp_tm==0)
                                   break;
                                 inl_s=D_DIGGRPLEN;
                               }
                             }
                             if (inl_dgsp_ph) {  /* precision may provoke leading separator */
                               while (TRUE) {   /* write leading (maybe partial) digit group */
                                 *awcl_cur = HL_ENDIANSWAP_FROM_BYTE('0'+dsl_d.rem);
                                 if (--inl_dgsp_ph == 0) break;
                                 awcl_cur--;
                                 dsl_d = div(dsl_d.quot,DECBASE);
                               }
                             }
                           } else {  /* not using digit group separation */
                             while (TRUE) {
                               *(awcl_cur + --inl_emax) = HL_ENDIANSWAP_FROM_BYTE('0'+dsl_d.rem);
                               if (inl_emax <= 0) break;
                               dsl_d = div(dsl_d.quot,DECBASE);
                             }
                           }
#ifdef HL_USE_LDIV
                         } else if (sizeof(HL_ULONGLONG)<=sizeof(long int)) {
                           ldiv_t dsl_d;
                           dsl_d.quot = ull_arg/(HL_ULONGLONG)DECBASE;
                           dsl_d.rem = ull_arg%(HL_ULONGLONG)DECBASE;
                           if (inl_dgsp_lc) {  /* using digit group separation */
                             awcl_cur += inl_emax+inl_dgsp_tm*inl_dgsp_lo-1;
                             if (inl_dgsp_tm) {  /* write all digit groups that follow a separator */
                               inl_s=D_DIGGRPLEN;
                               while (TRUE) {
                                 do {
                                   *(awcl_cur)-- = HL_ENDIANSWAP_FROM_BYTE('0'+dsl_d.rem);
                                   dsl_d = ldiv(dsl_d.quot,DECBASE);
                                 } while (--inl_s);
                                 awcl_cur -= inl_dgsp_lo;  /* skip digits-separator */
                                 if (--inl_dgsp_tm==0)
                                   break;
                                 inl_s=D_DIGGRPLEN;
                               }
                             }
                             if (inl_dgsp_ph) {  /* precision may provoke leading separator */
                               while (TRUE) {   /* write leading (maybe partial) digit group */
                                 *awcl_cur = HL_ENDIANSWAP_FROM_BYTE('0'+dsl_d.rem);
                                 if (--inl_dgsp_ph == 0) break;
                                 awcl_cur--;
                                 dsl_d = ldiv(dsl_d.quot,DECBASE);
                               }
                             }
                           } else {  /* not using digit group separation */
                             while (TRUE) {
                               *(awcl_cur + --inl_emax) = HL_ENDIANSWAP_FROM_BYTE('0'+dsl_d.rem);
                               if (inl_emax <= 0) break;
                               dsl_d = ldiv(dsl_d.quot,DECBASE);
                             }
                           }
#endif
#ifdef HL_USE_LLDIV
                         } else if (sizeof(HL_ULONGLONG)<=sizeof(long long int)) {
                           lldiv_t dsl_d;
                           dsl_d.quot = ull_arg/(HL_ULONGLONG)DECBASE;
                           dsl_d.rem = ull_arg%(HL_ULONGLONG)DECBASE;
                           if (inl_dgsp_lc) {  /* using digit group separation */
                             awcl_cur += inl_emax+inl_dgsp_tm*inl_dgsp_lo-1;
                             if (inl_dgsp_tm) {  /* write all digit groups that follow a separator */
                               inl_s=D_DIGGRPLEN;
                               while (TRUE) {
                                 do {
                                   *(awcl_cur)-- = HL_ENDIANSWAP_FROM_BYTE('0'+dsl_d.rem);
                                   dsl_d = lldiv(dsl_d.quot,DECBASE);
                                 } while (--inl_s);
                                 awcl_cur -= inl_dgsp_lo;  /* skip digits-separator */
                                 if (--inl_dgsp_tm==0)
                                   break;
                                 inl_s=D_DIGGRPLEN;
                               }
                             }
                             if (inl_dgsp_ph) {  /* precision may provoke leading separator */
                               while (TRUE) {   /* write leading (maybe partial) digit group */
                                 *awcl_cur = HL_ENDIANSWAP_FROM_BYTE('0'+dsl_d.rem);
                                 if (--inl_dgsp_ph == 0) break;
                                 awcl_cur--;
                                 dsl_d = lldiv(dsl_d.quot,DECBASE);
                               }
                             }
                           } else {  /* not using digit group separation */
                             while (TRUE) {
                               *(awcl_cur + --inl_emax) = HL_ENDIANSWAP_FROM_BYTE('0'+dsl_d.rem);
                               if (inl_emax <= 0) break;
                               dsl_d = lldiv(dsl_d.quot,DECBASE);
                             }
                           }
#endif
                         } else {
#endif
                           if (inl_dgsp_lc) {  /* using digit group separation */
                             awcl_cur += inl_emax+inl_dgsp_tm*inl_dgsp_lo-1;
                             if (inl_dgsp_tm) {  /* write all digit groups that follow a separator */
                               inl_s=D_DIGGRPLEN;
                               while (TRUE) {
                                 do {
                                   *(awcl_cur)-- = HL_ENDIANSWAP_FROM_BYTE('0'+ull_arg%(HL_ULONGLONG)DECBASE);
                                   ull_arg/=(HL_ULONGLONG)DECBASE;
                                 } while (--inl_s);
                                 awcl_cur -= inl_dgsp_lo;  /* skip digits-separator */
                                 if (--inl_dgsp_tm==0)
                                   break;
                                 inl_s=D_DIGGRPLEN;
                               }
                             }
                             if (inl_dgsp_ph) {  /* precision may provoke leading separator */
                               while (TRUE) {   /* write leading (maybe partial) digit group */
                                 *awcl_cur = HL_ENDIANSWAP_FROM_BYTE('0'+ull_arg%(HL_ULONGLONG)DECBASE);
                                 if (--inl_dgsp_ph == 0) break;
                                 awcl_cur--;
                                 ull_arg/=(HL_ULONGLONG)DECBASE;
                               }
                             }
                           } else {  /* not using digit group separation */
                             while (--inl_emax > 0) {
                               *(awcl_cur+inl_emax) = HL_ENDIANSWAP_FROM_BYTE('0'+ull_arg%(HL_ULONGLONG)DECBASE);
                               ull_arg/=(HL_ULONGLONG)DECBASE;
                             }
                             *awcl_cur = HL_ENDIANSWAP_FROM_BYTE('0'+ull_arg);
                           }
#ifdef HL_USE_DIV
                         }
#endif
                         awcl_cur += inl_emax;
                       }
                       break;
                     case 'O':
                       inl_emax = 0;
                       achl_digits = chl_spec&'\040' ? chrstrans_lc : chrstrans;  /* choose upper- or lowercase */
                       if (ull_arg!=0) {
                         int inl_e = (sizeof(HL_ULONGLONG)<<3)/3;
                         if (inl_e*3 < sizeof(HL_ULONGLONG)<<3)
                           inl_e++;
                         do {
                           inl_s = inl_e>>1;
                           if (ull_arg >= (HL_ULONGLONG)1<<((inl_emax+inl_s)*3)) {
                             inl_emax += inl_s;
                             inl_e -= inl_s;
                           } else {
                             inl_e = inl_s;
                           }
                         } while (inl_e>1);
                         inl_emax ++;
                         /* now inl_emax is number of digits needed    */
                       }
                       inl_needed = inl_emax + inl_postfixlen;
                       if (inl_dgsp_lc) {   /* use digit group separation */
                         if (inl_emax<=D_DIGGRPLEN) {  /* digit grouping not in effect */
                           inl_dgsp_lc = 0;
                         } else {
                           const int inl_emax_1 = inl_emax-1;
#ifdef HL_USE_DIV
                           dsl_diggrp_dm = div(inl_emax_1, D_DIGGRPLEN);
                           inl_dgsp_ph++;
#else
                           inl_dgsp_tm = (inl_emax_1)/D_DIGGRPLEN;
                           inl_dgsp_ph = (inl_emax_1)%D_DIGGRPLEN+1;
#endif
                           if (inl_needed>=ull_field_width || inl_needed+inl_dgsp_tm*inl_dgsp_lc<=ull_field_width) {
                             inl_s = inl_dgsp_tm*inl_dgsp_lc;
                             inl_needed += inl_s;
                           } else {  /* prefer staying within fieldwidth over using the separator */
                             inl_dgsp_lc = 0;
                           }
                         }
                       }
                       if (!bol_precision) {
                         ull_precision = 1;  /* default precision      */
                         if (bol_padding_zero) {
                           if (ull_field_width>inl_needed && !bol_adjustleft) {
                             /* fake padding with '0' by ull_precision */
                             ull_precision = ull_field_width+(inl_dgsp_lc?inl_emax+inl_s:inl_emax)-inl_needed;
                           } else {
                             bol_padding_zero = false;  /* according to spec, zeroflag is ignored in
                                               integer conversion if left-justify-flag is present */
                           }
                         }
                       } else {
                         bol_padding_zero = false;  /* according to spec, zeroflag is ignored in
                                                       integer conversion if a precision is given */
                       }
                       if (inl_dgsp_lc) {   /* using digit group separation */
                         inl_precpad = ull_precision-(inl_emax+inl_s);
                         if (inl_precpad>0) {
#ifdef HL_USE_DIV
                           div_t dsl_d = div(inl_dgsp_ph+inl_precpad, D_DIGGRPLEN+inl_dgsp_lc);
                           inl_dgsp_tm += dsl_d.quot;
                           inl_needed += inl_precpad;
                           inl_dgsp_ph = dsl_d.rem;
#else
                           inl_needed += inl_precpad;
                           inl_dgsp_tm += (inl_dgsp_ph+inl_precpad)/(D_DIGGRPLEN+inl_dgsp_lc);
                           inl_dgsp_ph = (inl_dgsp_ph+inl_precpad)%(D_DIGGRPLEN+inl_dgsp_lc);
#endif
                           if (inl_dgsp_ph>D_DIGGRPLEN) {
                            if (bol_alternate_form && (ull_arg!=0) &&
                                !(bol_padding_zero && (ull_precision>inl_emax+inl_dgsp_tm*D_DIGGRPLEN)))
                            {               /* ensure octal prefix     */
                             inl_dgsp_tm++;
                             ull_precision += 1+inl_dgsp_lc+D_DIGGRPLEN-inl_dgsp_ph;
                             inl_needed += 1+inl_dgsp_lc+D_DIGGRPLEN-inl_dgsp_ph;
                             inl_dgsp_ph = 1;
                            } else {
                             inl_needed -= inl_dgsp_ph-D_DIGGRPLEN;
                             inl_dgsp_ph = D_DIGGRPLEN;
                            }
                           } else if (bol_alternate_form && (inl_dgsp_ph==0) && (ull_arg!=0)) {
                             if (bol_padding_zero && (ull_precision-inl_dgsp_lc>inl_emax+(inl_dgsp_tm-1)*D_DIGGRPLEN)) {
                               /* prefer staying within fieldwidth over avoiding all spacepadding */
                               inl_dgsp_tm--;
                               ull_precision -= inl_dgsp_lc;
                               inl_needed -= inl_dgsp_lc;
                               inl_dgsp_ph = D_DIGGRPLEN;
                             } else {
                               ull_precision++;
                               inl_needed++;
                               inl_dgsp_ph=1;
                             }
                           }
                           inl_precpad = ull_precision-(inl_emax+inl_dgsp_tm*inl_dgsp_lc);
                         } else {
                          if (bol_alternate_form && (ull_arg!=0)) {  /* ensure octal prefix */
                            if (inl_dgsp_ph>=D_DIGGRPLEN) {
                              inl_dgsp_tm++;
                              ull_precision += 1+inl_dgsp_lc+D_DIGGRPLEN-inl_dgsp_ph;
                              inl_needed += 1+inl_dgsp_lc+D_DIGGRPLEN-inl_dgsp_ph;
                              inl_dgsp_ph = 1;
                            } else {
                              ull_precision++;
                              inl_needed++;
                              inl_dgsp_ph++;
                            }
                            inl_precpad++;
                          } else {
                           inl_precpad=0;
                          }
                         }
                       } else {    /* not using digit group separation */
                         if (bol_alternate_form && (ull_arg!=0) && (ull_precision<=inl_emax))
                           ull_precision = inl_emax+1;  /* cause octal prefix */
                         inl_precpad = ull_precision-inl_emax;
                         if (inl_precpad>0) {
                           inl_needed += inl_precpad;
                         } else {
                           inl_precpad=0;
                         }
                       }
                       if (ull_field_width > inl_needed) {
                         awcl_after = awcl_cur+ull_field_width;
                         inl_padsp = ull_field_width-inl_needed;
                         if (!bol_adjustleft) {  /* padding left with spaces */
                           if (inl_padsp > awcl_end-awcl_cur)
                             {awcl_after = awcl_cur; break;}  /* overflow */
                           do
                             *awcl_cur++ = HL_ENDIANSWAP_FROM_BYTE(' ');
                           while (--inl_padsp);
                         }
                       } else {
                         awcl_after = awcl_cur+inl_needed;
                         inl_padsp = 0;
                       }
                       if (inl_dgsp_lc) {   /* set digit group separators */
                         /* produce the first separator                                     */
                         awcl_dg = awcl_cur+inl_dgsp_ph;
                         if (iel_cs_target == ied_chs_utf_16) {  /* natural endian */
                           inl_dgsp_lo = m_u16l_from_u8l(awcl_dg, awcl_end-awcl_dg, achl_dgsp, inl_dgsp_lb);
                         } else {           /* swapped endian          */
                           inl_dgsp_lo = m_u16r_from_u8l(awcl_dg, 1+awcl_end-awcl_dg, achl_dgsp, inl_dgsp_lb);
                         }
                         /* now the complete physical output length can be determined      */
                         inl_s = inl_dgsp_tm*(inl_dgsp_lo-inl_dgsp_lc);  /* adjustment from logical to physical */
                         awcl_after += inl_s;
                         if (inl_dgsp_lo<0 || awcl_after-awcl_cur>awcl_end-awcl_cur)
                           {awcl_after = awcl_cur; break;}  /* overflow */
                         /* copy the other separators from the first one                   */
                         inl_s = inl_dgsp_tm-1;
                         if (inl_s) {
                           awcl0 = awcl_dg+inl_dgsp_lo;
                           do {
                             awcl0 += D_DIGGRPLEN;
                             int inl2 = 0;
                             do
                               *awcl0++ = awcl_dg[inl2++];
                             while (inl2<inl_dgsp_lo);
                           } while (--inl_s);
                         }
                         /* padding left with zeroes to "precision"                        */
                         while (inl_precpad) {
                           if (inl_dgsp_ph == 0) {  /* skip digits-separator */
                             awcl_cur += inl_dgsp_lo;
                             inl_dgsp_ph = D_DIGGRPLEN-1;
                             inl_dgsp_tm--;
                             if (!inl_dgsp_tm)
                               break;
                           } else {
                             inl_dgsp_ph--;
                           }
                           *awcl_cur++ = HL_ENDIANSWAP_FROM_BYTE('0');
                           inl_precpad --;
                         }
                       } else {             /* not using digit group separation */
                         if (awcl_after-awcl_cur>awcl_end-awcl_cur)
                           {awcl_after = awcl_cur; break;}  /* overflow */
                         /* padding left with zeroes to "precision"    */
                         while (inl_precpad) {
                           *awcl_cur++ = HL_ENDIANSWAP_FROM_BYTE('0');
                           inl_precpad --;
                         }
                       }
                       /* postfix                                      */
                       if (inl_postfixlen) {
                         if (inl_postfixlen==2) {
                           *(awcl_after-(inl_padsp+2)) = HL_ENDIANSWAP_FROM_BYTE(chl_postfix);
                           *(awcl_after-(inl_padsp+1)) = HL_ENDIANSWAP_FROM_BYTE('i');
                         } else {
                           *(awcl_after-(inl_padsp+1)) = HL_ENDIANSWAP_FROM_BYTE(chl_postfix);
                         }
                       }
                       /* padding right with spaces                    */
                       if (inl_padsp) {
                         awcl0 = awcl_after-1;
                         do
                           *awcl0-- = HL_ENDIANSWAP_FROM_BYTE(' ');
                         while (--inl_padsp);
                       }
                       if (inl_emax!=0) {  /* done if zero-"precision" zero */
                         inl_emax --;
                         inl_emax *= 3;
                         if (inl_dgsp_lc) {  /* using digit group separation */
                           while (TRUE) {
                             while (inl_dgsp_ph) {
                               *(awcl_cur)++ = HL_ENDIANSWAP_FROM_BYTE(achl_digits[(ull_arg>>inl_emax) & (1<<3)-1]);
                               inl_dgsp_ph--;
                               inl_emax -= 3;
                             }
                             inl_dgsp_tm--;
                             if (!inl_dgsp_tm)
                               break;       /* all digitgroups done    */
                             awcl_cur += inl_dgsp_lo;  /* skip digits-separator */
                             inl_dgsp_ph = D_DIGGRPLEN-1;
                           }
                         } else {  /* not using digit group separation */
                           while(TRUE) {
                             *(awcl_cur) = HL_ENDIANSWAP_FROM_BYTE(achl_digits[(ull_arg>>inl_emax) & (1<<3)-1]);
                             if (inl_emax==0)
                               break;
                             (awcl_cur)++;
                             inl_emax -= 3;
                           }
                         }
                       }
                       break;
                     case 'X':
                       inl_emax = 0;
                       achl_digits = chl_spec&'\040' ? chrstrans_lc : chrstrans;  /* choose upper- or lowercase */
                       if (ull_arg!=0) {
                         int inl_e = (sizeof(HL_ULONGLONG)<<3)/4;
                         if (inl_e*4 < sizeof(HL_ULONGLONG)<<3)
                           inl_e++;
                         do {
                           inl_s = inl_e>>1;
                           if (ull_arg >= (HL_ULONGLONG)1<<((inl_emax+inl_s)*4)) {
                             inl_emax += inl_s;
                             inl_e -= inl_s;
                           } else {
                             inl_e = inl_s;
                           }
                         } while (inl_e>1);
                         inl_emax ++;
                         /* now inl_emax is number of digits needed    */
                       }
                       inl_needed = inl_emax + inl_postfixlen;
                       if (bol_alternate_form && (ull_arg!=0))
                         inl_needed += 2;   /* for hex prefix          */
                       if (inl_dgsp_lc) {   /* use digit group separation */
                         if (inl_emax<=D_DIGGRPLEN) {  /* digit grouping not in effect */
                           inl_dgsp_lc = 0;
                         } else {
                           const int inl_emax_1 = inl_emax-1;
#ifdef HL_USE_DIV
                           dsl_diggrp_dm = div(inl_emax_1, D_DIGGRPLEN);
                           inl_dgsp_ph++;
#else
                           inl_dgsp_tm = (inl_emax_1)/D_DIGGRPLEN;
                           inl_dgsp_ph = (inl_emax_1)%D_DIGGRPLEN+1;
#endif
                           if (inl_needed>=ull_field_width || inl_needed+inl_dgsp_tm*inl_dgsp_lc<=ull_field_width) {
                             inl_s = inl_dgsp_tm*inl_dgsp_lc;
                             inl_needed += inl_s;
                           } else {  /* prefer staying within fieldwidth over using the separator */
                             inl_dgsp_lc = 0;
                           }
                         }
                       }
                       if (!bol_precision) {
                         ull_precision = 1;  /* default precision      */
                         if (bol_padding_zero) {
                           if (ull_field_width>inl_needed && !bol_adjustleft) {
                             /* fake padding with '0' by ull_precision */
                             ull_precision = ull_field_width+(inl_dgsp_lc?inl_emax+inl_s:inl_emax)-inl_needed;
                           }
                         }
                       }
                       if (inl_dgsp_lc) {   /* using digit group separation */
                         inl_precpad = ull_precision-(inl_emax+inl_s);
                         if (inl_precpad>0) {
#ifdef HL_USE_DIV
                           div_t dsl_d = div(inl_dgsp_ph+inl_precpad, D_DIGGRPLEN+inl_dgsp_lc);
                           inl_dgsp_tm += dsl_d.quot;
                           inl_needed += inl_precpad;
                           inl_dgsp_ph = dsl_d.rem;
#else
                           inl_needed += inl_precpad;
                           inl_dgsp_tm += (inl_dgsp_ph+inl_precpad)/(D_DIGGRPLEN+inl_dgsp_lc);
                           inl_dgsp_ph = (inl_dgsp_ph+inl_precpad)%(D_DIGGRPLEN+inl_dgsp_lc);
#endif
                           if (inl_dgsp_ph>D_DIGGRPLEN) {
                             inl_needed -= inl_dgsp_ph-D_DIGGRPLEN;
                             inl_dgsp_ph = D_DIGGRPLEN;
                           }
                           inl_precpad = ull_precision-(inl_emax+inl_dgsp_tm*inl_dgsp_lc);
                         } else {
                           inl_precpad=0;
                         }
                       } else {    /* not using digit group separation */
                         inl_precpad = ull_precision-inl_emax;
                         if (inl_precpad>0) {
                           inl_needed += inl_precpad;
                         } else {
                           inl_precpad=0;
                         }
                       }
                       if (ull_field_width > inl_needed) {
                         awcl_after = awcl_cur+ull_field_width;
                         inl_padsp = ull_field_width-inl_needed;
                         if (!bol_adjustleft) {  /* padding left with spaces */
                           if (inl_padsp > awcl_end-awcl_cur)
                             {awcl_after = awcl_cur; break;}  /* overflow */
                           do
                             *awcl_cur++ = HL_ENDIANSWAP_FROM_BYTE(' ');
                           while (--inl_padsp);
                         }
                       } else {
                         awcl_after = awcl_cur+inl_needed;
                         inl_padsp = 0;
                       }
                       if (inl_dgsp_lc) {   /* set digit group separators */
                         if (bol_alternate_form && (ull_arg!=0)) {  /* write hex prefix    */
                           if (2 > awcl_end-awcl_cur)
                             {awcl_after = awcl_cur; break;}  /* overflow */
                           *awcl_cur++ = HL_ENDIANSWAP_FROM_BYTE('0');
                           *awcl_cur++ = HL_ENDIANSWAP_FROM_BYTE('X'|(chl_spec&'\040'));
                         }
                         /* produce the first separator                                     */
                         awcl_dg = awcl_cur+inl_dgsp_ph;
                         if (iel_cs_target == ied_chs_utf_16) {  /* natural endian */
                           inl_dgsp_lo = m_u16l_from_u8l(awcl_dg, awcl_end-awcl_dg, achl_dgsp, inl_dgsp_lb);
                         } else {           /* swapped endian          */
                           inl_dgsp_lo = m_u16r_from_u8l(awcl_dg, 1+awcl_end-awcl_dg, achl_dgsp, inl_dgsp_lb);
                         }
                         /* now the complete physical output length can be determined      */
                         inl_s = inl_dgsp_tm*(inl_dgsp_lo-inl_dgsp_lc);  /* adjustment from logical to physical */
                         awcl_after += inl_s;
                         if (inl_dgsp_lo<0 || awcl_after-awcl_cur>awcl_end-awcl_cur)
                           {awcl_after = awcl_cur; break;}  /* overflow */
                         /* copy the other separators from the first one                   */
                         inl_s = inl_dgsp_tm-1;
                         if (inl_s) {
                           awcl0 = awcl_dg+inl_dgsp_lo;
                           do {
                             awcl0 += D_DIGGRPLEN;
                             int inl2 = 0;
                             do
                               *awcl0++ = awcl_dg[inl2++];
                             while (inl2<inl_dgsp_lo);
                           } while (--inl_s);
                         }
                         /* padding left with zeroes to "precision"                        */
                         while (inl_precpad) {
                           if (inl_dgsp_ph == 0) {  /* skip digits-separator */
                             awcl_cur += inl_dgsp_lo;
                             inl_dgsp_ph = D_DIGGRPLEN-1;
                             inl_dgsp_tm--;
                             if (!inl_dgsp_tm)
                               break;
                           } else {
                             inl_dgsp_ph--;
                           }
                           *awcl_cur++ = HL_ENDIANSWAP_FROM_BYTE('0');
                           inl_precpad --;
                         }
                       } else {             /* not using digit group separation */
                         if (awcl_after-awcl_cur>awcl_end-awcl_cur)
                           {awcl_after = awcl_cur; break;}  /* overflow */
                         if (bol_alternate_form && (ull_arg!=0)) {  /* write hex prefix */
                           *awcl_cur++ = HL_ENDIANSWAP_FROM_BYTE('0');
                           *awcl_cur++ = HL_ENDIANSWAP_FROM_BYTE('X'|(chl_spec&'\040'));
                         }
                         /* padding left with zeroes to "precision"    */
                         while (inl_precpad) {
                           *awcl_cur++ = HL_ENDIANSWAP_FROM_BYTE('0');
                           inl_precpad --;
                         }
                       }
                       /* postfix                                      */
                       if (inl_postfixlen) {
                         if (inl_postfixlen==2) {
                           *(awcl_after-(inl_padsp+2)) = HL_ENDIANSWAP_FROM_BYTE(chl_postfix);
                           *(awcl_after-(inl_padsp+1)) = HL_ENDIANSWAP_FROM_BYTE('i');
                         } else {
                           *(awcl_after-(inl_padsp+1)) = HL_ENDIANSWAP_FROM_BYTE(chl_postfix);
                         }
                       }
                       /* padding right with spaces                    */
                       if (inl_padsp) {
                         awcl0 = awcl_after-1;
                         do
                           *awcl0-- = HL_ENDIANSWAP_FROM_BYTE(' ');
                         while (--inl_padsp);
                       }
                       if (inl_emax!=0) {  /* done if zero-"precision" zero */
                         inl_emax --;
                         inl_emax *= 4;
                         if (inl_dgsp_lc) {  /* using digit group separation */
                           while (TRUE) {
                             while (inl_dgsp_ph) {
                               *(awcl_cur)++ = HL_ENDIANSWAP_FROM_BYTE(achl_digits[(ull_arg>>inl_emax) & (1<<4)-1]);
                               inl_dgsp_ph--;
                               inl_emax -= 4;
                             }
                             inl_dgsp_tm--;
                             if (!inl_dgsp_tm)
                               break;       /* all digitgroups done    */
                             awcl_cur += inl_dgsp_lo;  /* skip digits-separator */
                             inl_dgsp_ph = D_DIGGRPLEN-1;
                           }
                         } else {  /* not using digit group separation */
                           while(TRUE) {
                             *(awcl_cur) = HL_ENDIANSWAP_FROM_BYTE(achl_digits[(ull_arg>>inl_emax) & (1<<4)-1]);
                             if (inl_emax==0)
                               break;
                             (awcl_cur)++;
                             inl_emax -= 4;
                           }
                         }
                       }
                       break;
                   }
                 }
                 else {
                   ull_arg = va_arg(dsl_list, unsigned long int);
                   switch (chl_spec&0xDF) {
                     case 'U':

                       /* prepare %(sci-dec)- or %(sci-dec)-type of rendering */
                       if (iel_scaling!=ied_scaling_none) {
                         if (iel_scaling == ied_scaling_1000) {  /* power-of-1000-scaled */
#if HL_PRFMAXSO_L > 4
                           if ((sizeof(unsigned long int) > 4) && (ull_arg >= D_L1000RD * ullrs_decpowbuf[9])) {
                             if (
                                 (ull_arg >= D_L1000RD * ullrs_decpowbuf[15])
                                ) {
#if HL_PRFMAXSO_L > 8
                               if (
                                   (sizeof(unsigned long int) > 8) &&
                                   (ull_arg >= D_L1000RD * ullrs_decpowbuf[18])
                                  ) {
                                 if (ull_arg >= D_L1000RD * ullrs_decpowbuf[21]) {
                                   ull_arg =  (ull_arg + 500 * ullrs_decpowbuf[21]) / (ullrs_decpowbuf[24]);
                                   chl_postfix = 'Y';
                                 } else {
                                   ull_arg =  (ull_arg + 500 * ullrs_decpowbuf[18]) / (ullrs_decpowbuf[21]);
                                   chl_postfix = 'Z';
                                 }
                               } else {
#endif
                                 ull_arg =  (ull_arg + 500 * ullrs_decpowbuf[15]) / (ullrs_decpowbuf[18]);
                                 chl_postfix = 'E';
#if HL_PRFMAXSO_L > 8
                               }
#endif
                             } else {
                               if (ull_arg >= D_L1000RD * ullrs_decpowbuf[12]) {
                                 ull_arg =  (ull_arg + 500 * ullrs_decpowbuf[12]) / (ullrs_decpowbuf[15]);
                                 chl_postfix = 'P';
                               } else {
                                 ull_arg =  (ull_arg + 500 * ullrs_decpowbuf[9]) / (ullrs_decpowbuf[12]);
                                 chl_postfix = 'T';
                               }
                             }
                             inl_postfixlen = 1;
                           } else {
#endif
#if HL_PRFMAXSO_L > 2
                             if ((sizeof(unsigned long int) > 2) && (ull_arg >= D_L1000RD * ullrs_decpowbuf[3])) {
#if HL_PRFMAXSO_L > 4
                               if ((sizeof(unsigned long int) > 4) && (ull_arg >= D_L1000RD * ullrs_decpowbuf[6])) {
                                 ull_arg =  (ull_arg + 500 * ullrs_decpowbuf[6]) / (ullrs_decpowbuf[9]);
                                 chl_postfix = 'G';
                               } else {
#endif
                                 ull_arg =  (ull_arg + 500 * ullrs_decpowbuf[3]) / (ullrs_decpowbuf[6]);
                                 chl_postfix = 'M';
#if HL_PRFMAXSO_L > 4
                               }
#endif
                               inl_postfixlen = 1;
                             } else {
#endif
                               if (ull_arg >= D_L1000RD) {
                                 ull_arg = (ull_arg + 500) / 1000;
                                 chl_postfix = 'k';
                                 inl_postfixlen = 1;
                               }
#if HL_PRFMAXSO_L > 2
                             }
#endif
#if HL_PRFMAXSO_L > 4
                           }
#endif
                         }
                         else {               /* power-of-1024-scaled    */
#if HL_PRFMAXSO_L > 4
                           if ((sizeof(unsigned long int) > 4) && (ull_arg>>30 >= D_L1024RD)) {
                             if (
                                 (ull_arg>>50 >= D_L1024RD)
                                ) {
#if HL_PRFMAXSO_L > 8
                               if (
                                   (sizeof(unsigned long int) > 8) &&
                                   (ull_arg>>60 >= D_L1024RD)
                                  ) {
                                 if (ull_arg>>70 >= D_L1024RD) {
                                   ull_arg = (ull_arg+((unsigned long int)1<<79)) >> 80;
                                   chl_postfix = 'Y';
                                 } else {
                                   ull_arg = (ull_arg+((unsigned long int)1<<69)) >> 70;
                                   chl_postfix = 'Z';
                                 }
                               } else {
#endif
                                 ull_arg = (ull_arg+((unsigned long int)1<<59)) >> 60;
                                 chl_postfix = 'E';
#if HL_PRFMAXSO_L > 8
                               }
#endif
                             } else {
                               if (ull_arg>>40 >= D_L1024RD) {
                                 ull_arg = (ull_arg+((unsigned long int)1<<49)) >> 50;
                                 chl_postfix = 'P';
                               } else {
                                 ull_arg = (ull_arg+((unsigned long int)1<<39)) >> 40;
                                 chl_postfix = 'T';
                               }
                             }
                             inl_postfixlen = bol_alternate_form ? 2 : 1;
                           } else {
#endif
#if HL_PRFMAXSO_L > 2
                             if ((sizeof(unsigned long int) > 2) && (ull_arg>>10 >= D_L1024RD)) {
#if HL_PRFMAXSO_L > 4
                               if ((sizeof(unsigned long int) > 4) && (ull_arg>>20 >= D_L1024RD)) {
                                 ull_arg = (ull_arg+((unsigned long int)1<<29)) >> 30;
                                 chl_postfix = 'G';
                               } else {
#endif
                                 ull_arg = (ull_arg+((unsigned long int)1<<19)) >> 20;
                                 chl_postfix = 'M';
#if HL_PRFMAXSO_L > 4
                               }
#endif
                               inl_postfixlen = bol_alternate_form ? 2 : 1;
                             } else {
#endif
                               if (ull_arg >= D_L1024RD) {
                                 ull_arg = (ull_arg+0x200) >> 10;
                                 chl_postfix = 'K';
                                 inl_postfixlen = bol_alternate_form ? 2 : 1;
                               }
#if HL_PRFMAXSO_L > 2
                             }
#endif
#if HL_PRFMAXSO_L > 4
                           }
#endif
                         }
                       }

                       /* detect the order of magnitude of X           */
                       inl_emax = 0;
                       if (ull_arg) {
                         int inl_e = ((sizeof(unsigned long int)*240824)/100000)+1;
                         do {
                           inl_s = inl_e>>1;
                           if (ull_arg >= ullrs_decpowbuf[inl_emax+inl_s]) {
                             inl_emax += inl_s;
                             inl_e -= inl_s;
                           } else {
                             inl_e = inl_s;
                           }
                         } while (inl_e>1);
                         inl_emax ++;
                       }
                       inl_needed = inl_emax + inl_postfixlen;
                       if (inl_dgsp_lc) {   /* use digit group separation */
                         if (inl_emax<=D_DIGGRPLEN) {  /* digit grouping not in effect */
                           inl_dgsp_lc = 0;
                         } else {
                           const int inl_emax_1 = inl_emax-1;
#ifdef HL_USE_DIV
                           dsl_diggrp_dm = div(inl_emax_1, D_DIGGRPLEN);
                           inl_dgsp_ph++;
#else
                           inl_dgsp_tm = (inl_emax_1)/D_DIGGRPLEN;
                           inl_dgsp_ph = (inl_emax_1)%D_DIGGRPLEN+1;
#endif
                           if (inl_needed>=ull_field_width || inl_needed+inl_dgsp_tm*inl_dgsp_lc<=ull_field_width) {
                             inl_s = inl_dgsp_tm*inl_dgsp_lc;
                             inl_needed += inl_s;
                           } else {  /* prefer staying within fieldwidth over using the separator */
                             inl_dgsp_lc = 0;
                           }
                         }
                       }
                       if (!bol_precision) {
                         ull_precision = 1;  /* default precision      */
                         if (bol_padding_zero) {
                           if (ull_field_width>inl_needed && !bol_adjustleft) {
                             /* fake padding with '0' by ull_precision */
                             ull_precision = ull_field_width+(inl_dgsp_lc?inl_emax+inl_s:inl_emax)-inl_needed;
                           }
                         }
                       }
                       if (inl_dgsp_lc) {   /* using digit group separation */
                         inl_precpad = ull_precision-(inl_emax+inl_s);
                         if (inl_precpad>0) {
#ifdef HL_USE_DIV
                           div_t dsl_d = div(inl_dgsp_ph+inl_precpad, D_DIGGRPLEN+inl_dgsp_lc);
                           inl_dgsp_tm += dsl_d.quot;
                           inl_needed += inl_precpad;
                           inl_dgsp_ph = dsl_d.rem;
#else
                           inl_needed += inl_precpad;
                           inl_dgsp_tm += (inl_dgsp_ph+inl_precpad)/(D_DIGGRPLEN+inl_dgsp_lc);
                           inl_dgsp_ph = (inl_dgsp_ph+inl_precpad)%(D_DIGGRPLEN+inl_dgsp_lc);
#endif
                           if (inl_dgsp_ph>D_DIGGRPLEN) {
                             inl_needed -= inl_dgsp_ph-D_DIGGRPLEN;
                             inl_dgsp_ph = D_DIGGRPLEN;
                           }
                           inl_precpad = ull_precision-(inl_emax+inl_dgsp_tm*inl_dgsp_lc);
                         } else {
                           inl_precpad=0;
                         }
                       } else {    /* not using digit group separation */
                         inl_precpad = ull_precision-inl_emax;
                         if (inl_precpad>0) {
                           inl_needed += inl_precpad;
                         } else {
                           inl_precpad=0;
                         }
                       }
                       if (ull_field_width > inl_needed) {
                         awcl_after = awcl_cur+ull_field_width;
                         inl_padsp = ull_field_width-inl_needed;
                         if (!bol_adjustleft) {  /* padding left with spaces */
                           if (inl_padsp > awcl_end-awcl_cur)
                             {awcl_after = awcl_cur; break;}  /* overflow */
                           do
                             *awcl_cur++ = HL_ENDIANSWAP_FROM_BYTE(' ');
                           while (--inl_padsp);
                         }
                       } else {
                         awcl_after = awcl_cur+inl_needed;
                         inl_padsp = 0;
                       }
                       if (inl_dgsp_lc) {   /* set digit group separators */
                         /* produce the first separator                                     */
                         awcl_dg = awcl_cur+inl_dgsp_ph;
                         if (iel_cs_target == ied_chs_utf_16) {  /* natural endian */
                           inl_dgsp_lo = m_u16l_from_u8l(awcl_dg, awcl_end-awcl_dg, achl_dgsp, inl_dgsp_lb);
                         } else {           /* swapped endian          */
                           inl_dgsp_lo = m_u16r_from_u8l(awcl_dg, 1+awcl_end-awcl_dg, achl_dgsp, inl_dgsp_lb);
                         }
                         /* now the complete physical output length can be determined      */
                         inl_s = inl_dgsp_tm*(inl_dgsp_lo-inl_dgsp_lc);  /* adjustment from logical to physical */
                         awcl_after += inl_s;
                         if (inl_dgsp_lo<0 || awcl_after-awcl_cur>awcl_end-awcl_cur)
                           {awcl_after = awcl_cur; break;}  /* overflow */
                         /* copy the other separators from the first one                   */
                         inl_s = inl_dgsp_tm-1;
                         if (inl_s) {
                           awcl0 = awcl_dg+inl_dgsp_lo;
                           do {
                             awcl0 += D_DIGGRPLEN;
                             int inl2 = 0;
                             do
                               *awcl0++ = awcl_dg[inl2++];
                             while (inl2<inl_dgsp_lo);
                           } while (--inl_s);
                         }
                         /* padding left with zeroes to "precision"                        */
                         while (inl_precpad) {
                           if (inl_dgsp_ph == 0) {  /* skip digits-separator */
                             awcl_cur += inl_dgsp_lo;
                             inl_dgsp_ph = D_DIGGRPLEN-1;
                             inl_dgsp_tm--;
                             if (!inl_dgsp_tm)
                               break;
                           } else {
                             inl_dgsp_ph--;
                           }
                           *awcl_cur++ = HL_ENDIANSWAP_FROM_BYTE('0');
                           inl_precpad --;
                         }
                       } else {             /* not using digit group separation */
                         if (awcl_after-awcl_cur>awcl_end-awcl_cur)
                           {awcl_after = awcl_cur; break;}  /* overflow */
                         /* padding left with zeroes to "precision"    */
                         while (inl_precpad) {
                           *awcl_cur++ = HL_ENDIANSWAP_FROM_BYTE('0');
                           inl_precpad --;
                         }
                       }
                       /* postfix                                      */
                       if (inl_postfixlen) {
                         if (inl_postfixlen==2) {
                           *(awcl_after-(inl_padsp+2)) = HL_ENDIANSWAP_FROM_BYTE(chl_postfix);
                           *(awcl_after-(inl_padsp+1)) = HL_ENDIANSWAP_FROM_BYTE('i');
                         } else {
                           *(awcl_after-(inl_padsp+1)) = HL_ENDIANSWAP_FROM_BYTE(chl_postfix);
                         }
                       }
                       /* padding right with spaces                    */
                       if (inl_padsp) {
                         awcl0 = awcl_after-1;
                         do
                           *awcl0-- = HL_ENDIANSWAP_FROM_BYTE(' ');
                         while (--inl_padsp);
                       }
                       /* produce the digits                           */
                       if (inl_emax > 0) {
#ifdef HL_USE_DIV
                         if (sizeof(unsigned long int)<=sizeof(int)) {
                           div_t dsl_d;
                           dsl_d.quot = ull_arg/(unsigned long int)DECBASE;
                           dsl_d.rem = ull_arg%(unsigned long int)DECBASE;
                           if (inl_dgsp_lc) {  /* using digit group separation */
                             awcl_cur += inl_emax+inl_dgsp_tm*inl_dgsp_lo-1;
                             if (inl_dgsp_tm) {  /* write all digit groups that follow a separator */
                               inl_s=D_DIGGRPLEN;
                               while (TRUE) {
                                 do {
                                   *(awcl_cur)-- = HL_ENDIANSWAP_FROM_BYTE('0'+dsl_d.rem);
                                   dsl_d = div(dsl_d.quot,DECBASE);
                                 } while (--inl_s);
                                 awcl_cur -= inl_dgsp_lo;  /* skip digits-separator */
                                 if (--inl_dgsp_tm==0)
                                   break;
                                 inl_s=D_DIGGRPLEN;
                               }
                             }
                             if (inl_dgsp_ph) {  /* precision may provoke leading separator */
                               while (TRUE) {   /* write leading (maybe partial) digit group */
                                 *awcl_cur = HL_ENDIANSWAP_FROM_BYTE('0'+dsl_d.rem);
                                 if (--inl_dgsp_ph == 0) break;
                                 awcl_cur--;
                                 dsl_d = div(dsl_d.quot,DECBASE);
                               }
                             }
                           } else {  /* not using digit group separation */
                             while (TRUE) {
                               *(awcl_cur + --inl_emax) = HL_ENDIANSWAP_FROM_BYTE('0'+dsl_d.rem);
                               if (inl_emax <= 0) break;
                               dsl_d = div(dsl_d.quot,DECBASE);
                             }
                           }
#ifdef HL_USE_LDIV
                         } else if (sizeof(unsigned long int)<=sizeof(long int)) {
                           ldiv_t dsl_d;
                           dsl_d.quot = ull_arg/(unsigned long int)DECBASE;
                           dsl_d.rem = ull_arg%(unsigned long int)DECBASE;
                           if (inl_dgsp_lc) {  /* using digit group separation */
                             awcl_cur += inl_emax+inl_dgsp_tm*inl_dgsp_lo-1;
                             if (inl_dgsp_tm) {  /* write all digit groups that follow a separator */
                               inl_s=D_DIGGRPLEN;
                               while (TRUE) {
                                 do {
                                   *(awcl_cur)-- = HL_ENDIANSWAP_FROM_BYTE('0'+dsl_d.rem);
                                   dsl_d = ldiv(dsl_d.quot,DECBASE);
                                 } while (--inl_s);
                                 awcl_cur -= inl_dgsp_lo;  /* skip digits-separator */
                                 if (--inl_dgsp_tm==0)
                                   break;
                                 inl_s=D_DIGGRPLEN;
                               }
                             }
                             if (inl_dgsp_ph) {  /* precision may provoke leading separator */
                               while (TRUE) {   /* write leading (maybe partial) digit group */
                                 *awcl_cur = HL_ENDIANSWAP_FROM_BYTE('0'+dsl_d.rem);
                                 if (--inl_dgsp_ph == 0) break;
                                 awcl_cur--;
                                 dsl_d = ldiv(dsl_d.quot,DECBASE);
                               }
                             }
                           } else {  /* not using digit group separation */
                             while (TRUE) {
                               *(awcl_cur + --inl_emax) = HL_ENDIANSWAP_FROM_BYTE('0'+dsl_d.rem);
                               if (inl_emax <= 0) break;
                               dsl_d = ldiv(dsl_d.quot,DECBASE);
                             }
                           }
#endif
#ifdef HL_USE_LLDIV
                         } else if (sizeof(unsigned long int)<=sizeof(long long int)) {
                           lldiv_t dsl_d;
                           dsl_d.quot = ull_arg/(unsigned long int)DECBASE;
                           dsl_d.rem = ull_arg%(unsigned long int)DECBASE;
                           if (inl_dgsp_lc) {  /* using digit group separation */
                             awcl_cur += inl_emax+inl_dgsp_tm*inl_dgsp_lo-1;
                             if (inl_dgsp_tm) {  /* write all digit groups that follow a separator */
                               inl_s=D_DIGGRPLEN;
                               while (TRUE) {
                                 do {
                                   *(awcl_cur)-- = HL_ENDIANSWAP_FROM_BYTE('0'+dsl_d.rem);
                                   dsl_d = lldiv(dsl_d.quot,DECBASE);
                                 } while (--inl_s);
                                 awcl_cur -= inl_dgsp_lo;  /* skip digits-separator */
                                 if (--inl_dgsp_tm==0)
                                   break;
                                 inl_s=D_DIGGRPLEN;
                               }
                             }
                             if (inl_dgsp_ph) {  /* precision may provoke leading separator */
                               while (TRUE) {   /* write leading (maybe partial) digit group */
                                 *awcl_cur = HL_ENDIANSWAP_FROM_BYTE('0'+dsl_d.rem);
                                 if (--inl_dgsp_ph == 0) break;
                                 awcl_cur--;
                                 dsl_d = lldiv(dsl_d.quot,DECBASE);
                               }
                             }
                           } else {  /* not using digit group separation */
                             while (TRUE) {
                               *(awcl_cur + --inl_emax) = HL_ENDIANSWAP_FROM_BYTE('0'+dsl_d.rem);
                               if (inl_emax <= 0) break;
                               dsl_d = lldiv(dsl_d.quot,DECBASE);
                             }
                           }
#endif
                         } else {
#endif
                           if (inl_dgsp_lc) {  /* using digit group separation */
                             awcl_cur += inl_emax+inl_dgsp_tm*inl_dgsp_lo-1;
                             if (inl_dgsp_tm) {  /* write all digit groups that follow a separator */
                               inl_s=D_DIGGRPLEN;
                               while (TRUE) {
                                 do {
                                   *(awcl_cur)-- = HL_ENDIANSWAP_FROM_BYTE('0'+ull_arg%(unsigned long int)DECBASE);
                                   ull_arg/=(unsigned long int)DECBASE;
                                 } while (--inl_s);
                                 awcl_cur -= inl_dgsp_lo;  /* skip digits-separator */
                                 if (--inl_dgsp_tm==0)
                                   break;
                                 inl_s=D_DIGGRPLEN;
                               }
                             }
                             if (inl_dgsp_ph) {  /* precision may provoke leading separator */
                               while (TRUE) {   /* write leading (maybe partial) digit group */
                                 *awcl_cur = HL_ENDIANSWAP_FROM_BYTE('0'+ull_arg%(unsigned long int)DECBASE);
                                 if (--inl_dgsp_ph == 0) break;
                                 awcl_cur--;
                                 ull_arg/=(unsigned long int)DECBASE;
                               }
                             }
                           } else {  /* not using digit group separation */
                             while (--inl_emax > 0) {
                               *(awcl_cur+inl_emax) = HL_ENDIANSWAP_FROM_BYTE('0'+ull_arg%(unsigned long int)DECBASE);
                               ull_arg/=(unsigned long int)DECBASE;
                             }
                             *awcl_cur = HL_ENDIANSWAP_FROM_BYTE('0'+ull_arg);
                           }
#ifdef HL_USE_DIV
                         }
#endif
                         awcl_cur += inl_emax;
                       }
                       break;
                     case 'O':
                       inl_emax = 0;
                       achl_digits = chl_spec&'\040' ? chrstrans_lc : chrstrans;  /* choose upper- or lowercase */
                       if (ull_arg!=0) {
                         int inl_e = (sizeof(unsigned long int)<<3)/3;
                         if (inl_e*3 < sizeof(unsigned long int)<<3)
                           inl_e++;
                         do {
                           inl_s = inl_e>>1;
                           if (ull_arg >= (unsigned long int)1<<((inl_emax+inl_s)*3)) {
                             inl_emax += inl_s;
                             inl_e -= inl_s;
                           } else {
                             inl_e = inl_s;
                           }
                         } while (inl_e>1);
                         inl_emax ++;
                         /* now inl_emax is number of digits needed    */
                       }
                       inl_needed = inl_emax + inl_postfixlen;
                       if (inl_dgsp_lc) {   /* use digit group separation */
                         if (inl_emax<=D_DIGGRPLEN) {  /* digit grouping not in effect */
                           inl_dgsp_lc = 0;
                         } else {
                           const int inl_emax_1 = inl_emax-1;
#ifdef HL_USE_DIV
                           dsl_diggrp_dm = div(inl_emax_1, D_DIGGRPLEN);
                           inl_dgsp_ph++;
#else
                           inl_dgsp_tm = (inl_emax_1)/D_DIGGRPLEN;
                           inl_dgsp_ph = (inl_emax_1)%D_DIGGRPLEN+1;
#endif
                           if (inl_needed>=ull_field_width || inl_needed+inl_dgsp_tm*inl_dgsp_lc<=ull_field_width) {
                             inl_s = inl_dgsp_tm*inl_dgsp_lc;
                             inl_needed += inl_s;
                           } else {  /* prefer staying within fieldwidth over using the separator */
                             inl_dgsp_lc = 0;
                           }
                         }
                       }
                       if (!bol_precision) {
                         ull_precision = 1;  /* default precision      */
                         if (bol_padding_zero) {
                           if (ull_field_width>inl_needed && !bol_adjustleft) {
                             /* fake padding with '0' by ull_precision */
                             ull_precision = ull_field_width+(inl_dgsp_lc?inl_emax+inl_s:inl_emax)-inl_needed;
                           } else {
                             bol_padding_zero = false;  /* according to spec, zeroflag is ignored in
                                               integer conversion if left-justify-flag is present */
                           }
                         }
                       } else {
                         bol_padding_zero = false;  /* according to spec, zeroflag is ignored in
                                                       integer conversion if a precision is given */
                       }
                       if (inl_dgsp_lc) {   /* using digit group separation */
                         inl_precpad = ull_precision-(inl_emax+inl_s);
                         if (inl_precpad>0) {
#ifdef HL_USE_DIV
                           div_t dsl_d = div(inl_dgsp_ph+inl_precpad, D_DIGGRPLEN+inl_dgsp_lc);
                           inl_dgsp_tm += dsl_d.quot;
                           inl_needed += inl_precpad;
                           inl_dgsp_ph = dsl_d.rem;
#else
                           inl_needed += inl_precpad;
                           inl_dgsp_tm += (inl_dgsp_ph+inl_precpad)/(D_DIGGRPLEN+inl_dgsp_lc);
                           inl_dgsp_ph = (inl_dgsp_ph+inl_precpad)%(D_DIGGRPLEN+inl_dgsp_lc);
#endif
                           if (inl_dgsp_ph>D_DIGGRPLEN) {
                            if (bol_alternate_form && (ull_arg!=0) &&
                                !(bol_padding_zero && (ull_precision>inl_emax+inl_dgsp_tm*D_DIGGRPLEN)))
                            {               /* ensure octal prefix     */
                             inl_dgsp_tm++;
                             ull_precision += 1+inl_dgsp_lc+D_DIGGRPLEN-inl_dgsp_ph;
                             inl_needed += 1+inl_dgsp_lc+D_DIGGRPLEN-inl_dgsp_ph;
                             inl_dgsp_ph = 1;
                            } else {
                             inl_needed -= inl_dgsp_ph-D_DIGGRPLEN;
                             inl_dgsp_ph = D_DIGGRPLEN;
                            }
                           } else if (bol_alternate_form && (inl_dgsp_ph==0) && (ull_arg!=0)) {
                             if (bol_padding_zero && (ull_precision-inl_dgsp_lc>inl_emax+(inl_dgsp_tm-1)*D_DIGGRPLEN)) {
                               /* prefer staying within fieldwidth over avoiding all spacepadding */
                               inl_dgsp_tm--;
                               ull_precision -= inl_dgsp_lc;
                               inl_needed -= inl_dgsp_lc;
                               inl_dgsp_ph = D_DIGGRPLEN;
                             } else {
                               ull_precision++;
                               inl_needed++;
                               inl_dgsp_ph=1;
                             }
                           }
                           inl_precpad = ull_precision-(inl_emax+inl_dgsp_tm*inl_dgsp_lc);
                         } else {
                          if (bol_alternate_form && (ull_arg!=0)) {  /* ensure octal prefix */
                            if (inl_dgsp_ph>=D_DIGGRPLEN) {
                              inl_dgsp_tm++;
                              ull_precision += 1+inl_dgsp_lc+D_DIGGRPLEN-inl_dgsp_ph;
                              inl_needed += 1+inl_dgsp_lc+D_DIGGRPLEN-inl_dgsp_ph;
                              inl_dgsp_ph = 1;
                            } else {
                              ull_precision++;
                              inl_needed++;
                              inl_dgsp_ph++;
                            }
                            inl_precpad++;
                          } else {
                           inl_precpad=0;
                          }
                         }
                       } else {    /* not using digit group separation */
                         if (bol_alternate_form && (ull_arg!=0) && (ull_precision<=inl_emax))
                           ull_precision = inl_emax+1;  /* cause octal prefix */
                         inl_precpad = ull_precision-inl_emax;
                         if (inl_precpad>0) {
                           inl_needed += inl_precpad;
                         } else {
                           inl_precpad=0;
                         }
                       }
                       if (ull_field_width > inl_needed) {
                         awcl_after = awcl_cur+ull_field_width;
                         inl_padsp = ull_field_width-inl_needed;
                         if (!bol_adjustleft) {  /* padding left with spaces */
                           if (inl_padsp > awcl_end-awcl_cur)
                             {awcl_after = awcl_cur; break;}  /* overflow */
                           do
                             *awcl_cur++ = HL_ENDIANSWAP_FROM_BYTE(' ');
                           while (--inl_padsp);
                         }
                       } else {
                         awcl_after = awcl_cur+inl_needed;
                         inl_padsp = 0;
                       }
                       if (inl_dgsp_lc) {   /* set digit group separators */
                         /* produce the first separator                                     */
                         awcl_dg = awcl_cur+inl_dgsp_ph;
                         if (iel_cs_target == ied_chs_utf_16) {  /* natural endian */
                           inl_dgsp_lo = m_u16l_from_u8l(awcl_dg, awcl_end-awcl_dg, achl_dgsp, inl_dgsp_lb);
                         } else {           /* swapped endian          */
                           inl_dgsp_lo = m_u16r_from_u8l(awcl_dg, 1+awcl_end-awcl_dg, achl_dgsp, inl_dgsp_lb);
                         }
                         /* now the complete physical output length can be determined      */
                         inl_s = inl_dgsp_tm*(inl_dgsp_lo-inl_dgsp_lc);  /* adjustment from logical to physical */
                         awcl_after += inl_s;
                         if (inl_dgsp_lo<0 || awcl_after-awcl_cur>awcl_end-awcl_cur)
                           {awcl_after = awcl_cur; break;}  /* overflow */
                         /* copy the other separators from the first one                   */
                         inl_s = inl_dgsp_tm-1;
                         if (inl_s) {
                           awcl0 = awcl_dg+inl_dgsp_lo;
                           do {
                             awcl0 += D_DIGGRPLEN;
                             int inl2 = 0;
                             do
                               *awcl0++ = awcl_dg[inl2++];
                             while (inl2<inl_dgsp_lo);
                           } while (--inl_s);
                         }
                         /* padding left with zeroes to "precision"                        */
                         while (inl_precpad) {
                           if (inl_dgsp_ph == 0) {  /* skip digits-separator */
                             awcl_cur += inl_dgsp_lo;
                             inl_dgsp_ph = D_DIGGRPLEN-1;
                             inl_dgsp_tm--;
                             if (!inl_dgsp_tm)
                               break;
                           } else {
                             inl_dgsp_ph--;
                           }
                           *awcl_cur++ = HL_ENDIANSWAP_FROM_BYTE('0');
                           inl_precpad --;
                         }
                       } else {             /* not using digit group separation */
                         if (awcl_after-awcl_cur>awcl_end-awcl_cur)
                           {awcl_after = awcl_cur; break;}  /* overflow */
                         /* padding left with zeroes to "precision"    */
                         while (inl_precpad) {
                           *awcl_cur++ = HL_ENDIANSWAP_FROM_BYTE('0');
                           inl_precpad --;
                         }
                       }
                       /* postfix                                      */
                       if (inl_postfixlen) {
                         if (inl_postfixlen==2) {
                           *(awcl_after-(inl_padsp+2)) = HL_ENDIANSWAP_FROM_BYTE(chl_postfix);
                           *(awcl_after-(inl_padsp+1)) = HL_ENDIANSWAP_FROM_BYTE('i');
                         } else {
                           *(awcl_after-(inl_padsp+1)) = HL_ENDIANSWAP_FROM_BYTE(chl_postfix);
                         }
                       }
                       /* padding right with spaces                    */
                       if (inl_padsp) {
                         awcl0 = awcl_after-1;
                         do
                           *awcl0-- = HL_ENDIANSWAP_FROM_BYTE(' ');
                         while (--inl_padsp);
                       }
                       if (inl_emax!=0) {  /* done if zero-"precision" zero */
                         inl_emax --;
                         inl_emax *= 3;
                         if (inl_dgsp_lc) {  /* using digit group separation */
                           while (TRUE) {
                             while (inl_dgsp_ph) {
                               *(awcl_cur)++ = HL_ENDIANSWAP_FROM_BYTE(achl_digits[(ull_arg>>inl_emax) & (1<<3)-1]);
                               inl_dgsp_ph--;
                               inl_emax -= 3;
                             }
                             inl_dgsp_tm--;
                             if (!inl_dgsp_tm)
                               break;       /* all digitgroups done    */
                             awcl_cur += inl_dgsp_lo;  /* skip digits-separator */
                             inl_dgsp_ph = D_DIGGRPLEN-1;
                           }
                         } else {  /* not using digit group separation */
                           while(TRUE) {
                             *(awcl_cur) = HL_ENDIANSWAP_FROM_BYTE(achl_digits[(ull_arg>>inl_emax) & (1<<3)-1]);
                             if (inl_emax==0)
                               break;
                             (awcl_cur)++;
                             inl_emax -= 3;
                           }
                         }
                       }
                       break;
                     case 'X':
                       inl_emax = 0;
                       achl_digits = chl_spec&'\040' ? chrstrans_lc : chrstrans;  /* choose upper- or lowercase */
                       if (ull_arg!=0) {
                         int inl_e = (sizeof(unsigned long int)<<3)/4;
                         if (inl_e*4 < sizeof(unsigned long int)<<3)
                           inl_e++;
                         do {
                           inl_s = inl_e>>1;
                           if (ull_arg >= (unsigned long int)1<<((inl_emax+inl_s)*4)) {
                             inl_emax += inl_s;
                             inl_e -= inl_s;
                           } else {
                             inl_e = inl_s;
                           }
                         } while (inl_e>1);
                         inl_emax ++;
                         /* now inl_emax is number of digits needed    */
                       }
                       inl_needed = inl_emax + inl_postfixlen;
                       if (bol_alternate_form && (ull_arg!=0))
                         inl_needed += 2;   /* for hex prefix          */
                       if (inl_dgsp_lc) {   /* use digit group separation */
                         if (inl_emax<=D_DIGGRPLEN) {  /* digit grouping not in effect */
                           inl_dgsp_lc = 0;
                         } else {
                           const int inl_emax_1 = inl_emax-1;
#ifdef HL_USE_DIV
                           dsl_diggrp_dm = div(inl_emax_1, D_DIGGRPLEN);
                           inl_dgsp_ph++;
#else
                           inl_dgsp_tm = (inl_emax_1)/D_DIGGRPLEN;
                           inl_dgsp_ph = (inl_emax_1)%D_DIGGRPLEN+1;
#endif
                           if (inl_needed>=ull_field_width || inl_needed+inl_dgsp_tm*inl_dgsp_lc<=ull_field_width) {
                             inl_s = inl_dgsp_tm*inl_dgsp_lc;
                             inl_needed += inl_s;
                           } else {  /* prefer staying within fieldwidth over using the separator */
                             inl_dgsp_lc = 0;
                           }
                         }
                       }
                       if (!bol_precision) {
                         ull_precision = 1;  /* default precision      */
                         if (bol_padding_zero) {
                           if (ull_field_width>inl_needed && !bol_adjustleft) {
                             /* fake padding with '0' by ull_precision */
                             ull_precision = ull_field_width+(inl_dgsp_lc?inl_emax+inl_s:inl_emax)-inl_needed;
                           }
                         }
                       }
                       if (inl_dgsp_lc) {   /* using digit group separation */
                         inl_precpad = ull_precision-(inl_emax+inl_s);
                         if (inl_precpad>0) {
#ifdef HL_USE_DIV
                           div_t dsl_d = div(inl_dgsp_ph+inl_precpad, D_DIGGRPLEN+inl_dgsp_lc);
                           inl_dgsp_tm += dsl_d.quot;
                           inl_needed += inl_precpad;
                           inl_dgsp_ph = dsl_d.rem;
#else
                           inl_needed += inl_precpad;
                           inl_dgsp_tm += (inl_dgsp_ph+inl_precpad)/(D_DIGGRPLEN+inl_dgsp_lc);
                           inl_dgsp_ph = (inl_dgsp_ph+inl_precpad)%(D_DIGGRPLEN+inl_dgsp_lc);
#endif
                           if (inl_dgsp_ph>D_DIGGRPLEN) {
                             inl_needed -= inl_dgsp_ph-D_DIGGRPLEN;
                             inl_dgsp_ph = D_DIGGRPLEN;
                           }
                           inl_precpad = ull_precision-(inl_emax+inl_dgsp_tm*inl_dgsp_lc);
                         } else {
                           inl_precpad=0;
                         }
                       } else {    /* not using digit group separation */
                         inl_precpad = ull_precision-inl_emax;
                         if (inl_precpad>0) {
                           inl_needed += inl_precpad;
                         } else {
                           inl_precpad=0;
                         }
                       }
                       if (ull_field_width > inl_needed) {
                         awcl_after = awcl_cur+ull_field_width;
                         inl_padsp = ull_field_width-inl_needed;
                         if (!bol_adjustleft) {  /* padding left with spaces */
                           if (inl_padsp > awcl_end-awcl_cur)
                             {awcl_after = awcl_cur; break;}  /* overflow */
                           do
                             *awcl_cur++ = HL_ENDIANSWAP_FROM_BYTE(' ');
                           while (--inl_padsp);
                         }
                       } else {
                         awcl_after = awcl_cur+inl_needed;
                         inl_padsp = 0;
                       }
                       if (inl_dgsp_lc) {   /* set digit group separators */
                         if (bol_alternate_form && (ull_arg!=0)) {  /* write hex prefix    */
                           if (2 > awcl_end-awcl_cur)
                             {awcl_after = awcl_cur; break;}  /* overflow */
                           *awcl_cur++ = HL_ENDIANSWAP_FROM_BYTE('0');
                           *awcl_cur++ = HL_ENDIANSWAP_FROM_BYTE('X'|(chl_spec&'\040'));
                         }
                         /* produce the first separator                                     */
                         awcl_dg = awcl_cur+inl_dgsp_ph;
                         if (iel_cs_target == ied_chs_utf_16) {  /* natural endian */
                           inl_dgsp_lo = m_u16l_from_u8l(awcl_dg, awcl_end-awcl_dg, achl_dgsp, inl_dgsp_lb);
                         } else {           /* swapped endian          */
                           inl_dgsp_lo = m_u16r_from_u8l(awcl_dg, 1+awcl_end-awcl_dg, achl_dgsp, inl_dgsp_lb);
                         }
                         /* now the complete physical output length can be determined      */
                         inl_s = inl_dgsp_tm*(inl_dgsp_lo-inl_dgsp_lc);  /* adjustment from logical to physical */
                         awcl_after += inl_s;
                         if (inl_dgsp_lo<0 || awcl_after-awcl_cur>awcl_end-awcl_cur)
                           {awcl_after = awcl_cur; break;}  /* overflow */
                         /* copy the other separators from the first one                   */
                         inl_s = inl_dgsp_tm-1;
                         if (inl_s) {
                           awcl0 = awcl_dg+inl_dgsp_lo;
                           do {
                             awcl0 += D_DIGGRPLEN;
                             int inl2 = 0;
                             do
                               *awcl0++ = awcl_dg[inl2++];
                             while (inl2<inl_dgsp_lo);
                           } while (--inl_s);
                         }
                         /* padding left with zeroes to "precision"                        */
                         while (inl_precpad) {
                           if (inl_dgsp_ph == 0) {  /* skip digits-separator */
                             awcl_cur += inl_dgsp_lo;
                             inl_dgsp_ph = D_DIGGRPLEN-1;
                             inl_dgsp_tm--;
                             if (!inl_dgsp_tm)
                               break;
                           } else {
                             inl_dgsp_ph--;
                           }
                           *awcl_cur++ = HL_ENDIANSWAP_FROM_BYTE('0');
                           inl_precpad --;
                         }
                       } else {             /* not using digit group separation */
                         if (awcl_after-awcl_cur>awcl_end-awcl_cur)
                           {awcl_after = awcl_cur; break;}  /* overflow */
                         if (bol_alternate_form && (ull_arg!=0)) {  /* write hex prefix */
                           *awcl_cur++ = HL_ENDIANSWAP_FROM_BYTE('0');
                           *awcl_cur++ = HL_ENDIANSWAP_FROM_BYTE('X'|(chl_spec&'\040'));
                         }
                         /* padding left with zeroes to "precision"    */
                         while (inl_precpad) {
                           *awcl_cur++ = HL_ENDIANSWAP_FROM_BYTE('0');
                           inl_precpad --;
                         }
                       }
                       /* postfix                                      */
                       if (inl_postfixlen) {
                         if (inl_postfixlen==2) {
                           *(awcl_after-(inl_padsp+2)) = HL_ENDIANSWAP_FROM_BYTE(chl_postfix);
                           *(awcl_after-(inl_padsp+1)) = HL_ENDIANSWAP_FROM_BYTE('i');
                         } else {
                           *(awcl_after-(inl_padsp+1)) = HL_ENDIANSWAP_FROM_BYTE(chl_postfix);
                         }
                       }
                       /* padding right with spaces                    */
                       if (inl_padsp) {
                         awcl0 = awcl_after-1;
                         do
                           *awcl0-- = HL_ENDIANSWAP_FROM_BYTE(' ');
                         while (--inl_padsp);
                       }
                       if (inl_emax!=0) {  /* done if zero-"precision" zero */
                         inl_emax --;
                         inl_emax *= 4;
                         if (inl_dgsp_lc) {  /* using digit group separation */
                           while (TRUE) {
                             while (inl_dgsp_ph) {
                               *(awcl_cur)++ = HL_ENDIANSWAP_FROM_BYTE(achl_digits[(ull_arg>>inl_emax) & (1<<4)-1]);
                               inl_dgsp_ph--;
                               inl_emax -= 4;
                             }
                             inl_dgsp_tm--;
                             if (!inl_dgsp_tm)
                               break;       /* all digitgroups done    */
                             awcl_cur += inl_dgsp_lo;  /* skip digits-separator */
                             inl_dgsp_ph = D_DIGGRPLEN-1;
                           }
                         } else {  /* not using digit group separation */
                           while(TRUE) {
                             *(awcl_cur) = HL_ENDIANSWAP_FROM_BYTE(achl_digits[(ull_arg>>inl_emax) & (1<<4)-1]);
                             if (inl_emax==0)
                               break;
                             (awcl_cur)++;
                             inl_emax -= 4;
                           }
                         }
                       }
                       break;
                   }
                 }
                 break;
             }
           }
           }
           awcl_cur = awcl_after;
           achl_format++;
#undef D_L1000RD
#undef D_L1024RD
           break;
         }
         default:
           break;
        }
       }
     }
   }
   if (imp_max_len_target > 0) {
     if (awcl_cur>awcl_end)
       awcl_cur = awcl_end;
     *awcl_cur = '\0';
   }
   //free(awcl_arg);
//#if defined HL_UNIX && !defined HL_HPUX
//   va_end( dsl_list );
//#endif
   return awcl_cur - awcl_target;
#undef HL_ENDIANSWAP_FROM_BYTE
} /* end m_hlvsnwprintf()                                              */

/**
* write formatted output using a list of arguments
*  @param achp_target pointer to output buffer
*  @param imp_max_len_target maximum number of characters to write
*  @param iep_cs_target charset for output
*  @param achp_format formatspecification, in the style of printf() etc.
*  @param ... further arguments, corresponding to the format string
*  @return the number of units (8- or 16-bit depending on iep_cs_target; 32-bit
*          output is not supported) written, excluding the terminating zero,
*          or -1 on unsupported encoding
*/
extern PTYPE int m_hlsnprintf( void *achp_target, int imp_max_len_target,
                               enum ied_charset iep_cs_target,
                               const char *achp_format, ... ) {
   int        iml_ret;                      /* return value            */
   va_list    dsl_list;                     /* list of arguments       */

   va_start( dsl_list, achp_format );       /* build dsl_list of variable arguments */
   switch ( iep_cs_target ) {
     CASE_IED_CHS_U16_ALLENDIAN
       iml_ret = m_hlvsnwprintf( achp_target, imp_max_len_target, iep_cs_target,
                                 achp_format, dsl_list );
       break;
     case ied_chs_ascii_850:                /* ASCII 850               */
     case ied_chs_ansi_819:                 /* ANSI 819                */
     CASE_IED_CHS_MISCCODEPAGES
     CASE_IED_CHS_ALL_CJK
     CASE_IED_CHS_ISO8859_2TO16
     case ied_chs_utf_8:                    /* Unicode UTF-8           */
       iml_ret = m_hlvsnprintf( achp_target, imp_max_len_target, iep_cs_target,
                                achp_format, dsl_list );
       break;
     default:
       return -1;
   }
   va_end( dsl_list );                      /* destroy list            */
   return iml_ret;
} /* end m_hlsnprintf()                                                */

/** @} */
