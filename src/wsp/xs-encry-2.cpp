/**
 * @file
 * This is the combined source for the HOB encryption v2 module
 * The v2 module supplements the previous encryption module and will eventually supplant it.
 *
 * This file is automatically generated from the individual source files and provides the same content in a single file
 *
 * Header files:
 *   hob-encry-2.h          - Main header
 *   hob-encry-intern-2.h   - Header for internal use
 *
 * Some of the functions defined in this file are implemented in Assembler to achieve better performance.
 * Please select and link the file appropriate for the current architecture.
 *   is-encry-2-x64.asm    - Intel x86 (64 bit) Assembler source file for Microsoft Assembler
 *   is-encry-2-x64.s      - Intel x86 (64 bit) Assembler source file for NASM Assembler (for Linux/FreeBSD/MacOS)
 *   is-encry-2-arm64.s    - ARM Aarch64 Assembler source file for GCC and Clang/LLVM Assembler
 *   is-encry-2-s390x.s    - S390X Assembler source file
 * All Assembler source files implement the same set of functions. For architectures where no such source exists,
 * a C implementation is provided.
 *
 * Copyright (C) HOB Germany 2016 - 2017
 *
 */


//------------------------------------------------------------------------------
// Start of original file ./xs-sha3.cpp
//------------------------------------------------------------------------------

#include <stdlib.h>
#include <string.h>

#ifdef _WIN32
#include <Windows.h>
#else
#include "hob-unix01.h"
#ifndef HL_UNIX
#define HL_UNIX
#if (defined __APPLE__) && (defined __MACH__)
#define HL_LINUX
#define HL_MACOS
#endif
#endif // !HL_UNIX
#endif

#include "hob-xslhcla1.hpp"
#include "hob-encry-2.h"
#include "hob-encry-intern-2.h"

// -----------------------------------------
//  Static declarations
// ------------------------------------------

/**
 * Initializes the SHA3 state array for all SHA3 hashing.
 *
 * @param adsp_sha_state SHA3 state array
 * @param inp_hashsize One of the values 224, 256, 384 and 512
 */
static void ms_sha3_init(struct dsd_sha_3_state* adsp_sha_state,
                         unsigned int unp_hashsize);

static void m_sha3_permute_state(struct dsd_sha_3_state* adsp_sha_state);
// ------------------------------------------
//  SHA-3 Initialization
// ------------------------------------------

void m_sha_3_224_init(void* avop_state)
{
    ms_sha3_init((struct dsd_sha_3_state *)avop_state, 224);
}

void m_sha_3_256_init(void* avop_state)
{
    ms_sha3_init((struct dsd_sha_3_state *)avop_state, 256);
}

void m_sha_3_384_init(void* avop_state)
{
    ms_sha3_init((struct dsd_sha_3_state *)avop_state, 384);
}

void m_sha_3_512_init(void* avop_state)
{
    ms_sha3_init((struct dsd_sha_3_state *)avop_state, 512);
}

// ------------------------------------------
//  SHA-3 Update
// ------------------------------------------

void m_sha_3_update(void* avop_state,
                    const unsigned char* abyp_input,
                    size_t szp_input_len)
{
    struct dsd_sha_3_state *adsl_sha3_state = (struct dsd_sha_3_state *)avop_state;
    const unsigned char *abyl_data_cur = abyp_input;
    const unsigned char *abyl_data_end = abyp_input + szp_input_len;
    unsigned char *abyl_state_cur = &adsl_sha3_state->byrc_array[adsl_sha3_state->imc_current_pos];
    while(abyl_data_cur < abyl_data_end) {
        // copy input bytewise onto rate, until either end of rate or end of input is reached
        while ((adsl_sha3_state->imc_current_pos < adsl_sha3_state->imc_rate_size) &&
               (abyl_data_cur < abyl_data_end))
        {
            *abyl_state_cur++ ^= *abyl_data_cur++;
            adsl_sha3_state->imc_current_pos++;
        }
        // if end of rate has been reached, perform state permutations and reset cur pointer to start
        if(adsl_sha3_state->imc_current_pos == adsl_sha3_state->imc_rate_size) {
            m_sha3_permute_state(adsl_sha3_state);
            adsl_sha3_state->imc_current_pos = 0;
            abyl_state_cur = adsl_sha3_state->byrc_array;
        }
    }
} // m_sha_3_update

void m_sha_3_gather_update(void* avop_state,
                           struct dsd_gather_i_1* adsp_input,
                           size_t szp_input_len)
{
    while ((szp_input_len > 0) && !(adsp_input == NULL)) {
        size_t szl_elm_len = adsp_input->achc_ginp_end - adsp_input->achc_ginp_cur;
        if (szl_elm_len > szp_input_len) {
            szl_elm_len = szp_input_len;
        }
        m_sha_3_update((struct dsd_sha_3_state *)avop_state,
                       (const unsigned char *)adsp_input->achc_ginp_cur,
                       szl_elm_len);
        szp_input_len -= szl_elm_len;
        adsp_input = adsp_input->adsc_next;
    }
}

// ------------------------------------------
//  SHA-3 Final
// ------------------------------------------

void m_sha_3_final(void* avop_state,
                   unsigned char* abyp_digest)
{
    struct dsd_sha_3_state *adsl_sha3_state = (struct dsd_sha_3_state *)avop_state;
    //apply padding
    adsl_sha3_state->byrc_array[adsl_sha3_state->imc_current_pos] ^= 0x06;
    adsl_sha3_state->byrc_array[adsl_sha3_state->imc_rate_size-1] ^= 0x80;
    //perform last state permutation step
    m_sha3_permute_state(adsl_sha3_state);
    //squeeze digest
    memcpy(abyp_digest, adsl_sha3_state->byrc_array, adsl_sha3_state->imc_hash_size);

    m_sec_memzero(adsl_sha3_state, sizeof(struct dsd_sha_3_state));
}

// ------------------------------------------
//  Static definitions copied from hssl-1
// ------------------------------------------

static void ms_sha3_init(struct dsd_sha_3_state* adsp_sha_state,
                         unsigned int unp_hashsize)
{
    unsigned int unl_array_size = sizeof(adsp_sha_state->byrc_array);
    memset(adsp_sha_state->byrc_array,0,unl_array_size);
    adsp_sha_state->imc_current_pos = 0;
    adsp_sha_state->imc_hash_size = unp_hashsize/8;
    adsp_sha_state->imc_rate_size = unl_array_size - (adsp_sha_state->imc_hash_size*2);
    //rate size in bytes
    //SHA3-224(28): 144
    //SHA3-256(32): 136
    //SHA3-384(48): 104
    //SHA3-512(64): 72
} // end of void ms_sha3_init(struct dsd_sha_3_state*, int)

/** List of Keccack round constants. */
static const unsigned long long ulrs_sha_3_round_constants[24] = {
    0x0000000000000001ULL, 0x0000000000008082ULL, 0x800000000000808AULL, 0x8000000080008000ULL,
    0x000000000000808BULL, 0x0000000080000001ULL, 0x8000000080008081ULL, 0x8000000000008009ULL,
    0x000000000000008AULL, 0x0000000000000088ULL, 0x0000000080008009ULL, 0x000000008000000AULL,
    0x000000008000808BULL, 0x800000000000008BULL, 0x8000000000008089ULL, 0x8000000000008003ULL,
    0x8000000000008002ULL, 0x8000000000000080ULL, 0x000000000000800AULL, 0x800000008000000AULL,
    0x8000000080008081ULL, 0x8000000000008080ULL, 0x0000000080000001ULL, 0x8000000080008008ULL
};

static inline unsigned long long m_rotl64(unsigned long long ulp_input,
                                          unsigned int unp_rot_cnt)
{
#ifdef _WIN32
    return _rotl64(ulp_input, (int)unp_rot_cnt);
#else
    unp_rot_cnt %= 64;
    return ((ulp_input << unp_rot_cnt)|(ulp_input >> (64 - unp_rot_cnt)));
#endif
}

inline unsigned long long m_endianswap(unsigned long long ulp_x)
{
#if defined(__GNUC__)  && (__GNUC_VERSION__ >= 40300) && !defined(HL_LINUX_ARM)
    return __builtin_bswap64(ulp_x); //unknown before 4.3.0
#elif defined(__GNUC__) && (__GNUC_VERSION__ >= 40500)
    return __builtin_bswap64(ulp_x); // low-quality builtin for ARM before 4.5.0
#elif defined(__clang__)
    return __builtin_bswap64(ulp_x);
#elif defined _WIN32
    return _byteswap_uint64(ulp_x);
#else
    ulp_x = ((ulp_x <<  8) & 0xFF00FF00FF00FF00ULL ) | ((ulp_x >>  8) & 0x00FF00FF00FF00FFULL );
    ulp_x = ((ulp_x << 16) & 0xFFFF0000FFFF0000ULL ) | ((ulp_x >> 16) & 0x0000FFFF0000FFFFULL );
    return (ulp_x << 32) | (ulp_x >> 32);
#endif
}

static void m_sha3_single_round(unsigned int unp_round_nr,
                                unsigned long long * aulp_src_state,
                                unsigned long long * aulp_dest_state,
                                unsigned long long * aulp_parity)
{
    unsigned long long ull_theta;
    unsigned long long ulrl_temp_array_b[5];
    //Theta
    ull_theta=aulp_parity[4]^m_rotl64(aulp_parity[1],1);
    aulp_src_state[0] ^= ull_theta;
    aulp_src_state[5] ^= ull_theta;
    aulp_src_state[10] ^= ull_theta;
    aulp_src_state[15] ^= ull_theta;
    aulp_src_state[20] ^= ull_theta;

    ull_theta=aulp_parity[0]^m_rotl64(aulp_parity[2],1);
    aulp_src_state[1] ^= ull_theta;
    aulp_src_state[6] ^= ull_theta;
    aulp_src_state[11] ^= ull_theta;
    aulp_src_state[16] ^= ull_theta;
    aulp_src_state[21] ^= ull_theta;

    ull_theta=aulp_parity[1]^m_rotl64(aulp_parity[3],1);
    aulp_src_state[2] ^= ull_theta;
    aulp_src_state[7] ^= ull_theta;
    aulp_src_state[12] ^= ull_theta;
    aulp_src_state[17] ^= ull_theta;
    aulp_src_state[22] ^= ull_theta;

    ull_theta=aulp_parity[2]^m_rotl64(aulp_parity[4],1);
    aulp_src_state[3] ^= ull_theta;
    aulp_src_state[8] ^= ull_theta;
    aulp_src_state[13] ^= ull_theta;
    aulp_src_state[18] ^= ull_theta;
    aulp_src_state[23] ^= ull_theta;

    ull_theta=aulp_parity[3]^m_rotl64(aulp_parity[0],1);
    aulp_src_state[4] ^= ull_theta;
    aulp_src_state[9] ^= ull_theta;
    aulp_src_state[14] ^= ull_theta;
    aulp_src_state[19] ^= ull_theta;
    aulp_src_state[24] ^= ull_theta;

    memset(aulp_parity, 0, 5*sizeof(unsigned long long));

    // plane 0
    // Rho and Pi
    ulrl_temp_array_b[0] = aulp_src_state[0];
    ulrl_temp_array_b[1] = m_rotl64(aulp_src_state[6],44);
    ulrl_temp_array_b[2] = m_rotl64(aulp_src_state[12],43);
    ulrl_temp_array_b[3] = m_rotl64(aulp_src_state[18],21);
    ulrl_temp_array_b[4] = m_rotl64(aulp_src_state[24],14);

    // Chi, and precalc parity for next round
    aulp_dest_state[0] = ulrl_temp_array_b[0]^
                         ((~ulrl_temp_array_b[1])&ulrl_temp_array_b[2]);
    // Iota: add round const to word [0][0]
    aulp_dest_state[0] ^= ulrs_sha_3_round_constants[unp_round_nr];
    aulp_parity[0] ^= aulp_dest_state[0];
    aulp_dest_state[1] = ulrl_temp_array_b[1]^
                         ((~ulrl_temp_array_b[2])&ulrl_temp_array_b[3]);
    aulp_parity[1] ^= aulp_dest_state[1];
    aulp_dest_state[2] = ulrl_temp_array_b[2]^
                         ((~ulrl_temp_array_b[3])&ulrl_temp_array_b[4]);
    aulp_parity[2] ^= aulp_dest_state[2];
    aulp_dest_state[3] = ulrl_temp_array_b[3]^
                         ((~ulrl_temp_array_b[4])&ulrl_temp_array_b[0]);
    aulp_parity[3] ^= aulp_dest_state[3];
    aulp_dest_state[4] = ulrl_temp_array_b[4]^
                         ((~ulrl_temp_array_b[0])&ulrl_temp_array_b[1]);
    aulp_parity[4] ^= aulp_dest_state[4];

    // plane 1
    // Rho and Pi
    ulrl_temp_array_b[0] = m_rotl64(aulp_src_state[3],28);
    ulrl_temp_array_b[1] = m_rotl64(aulp_src_state[9],20);
    ulrl_temp_array_b[2] = m_rotl64(aulp_src_state[10],3);
    ulrl_temp_array_b[3] = m_rotl64(aulp_src_state[16],45);
    ulrl_temp_array_b[4] = m_rotl64(aulp_src_state[22],61);

    // Chi, and precalc parity for next round
    aulp_dest_state[5] = ulrl_temp_array_b[0]^
                         ((~ulrl_temp_array_b[1])&ulrl_temp_array_b[2]);
    aulp_parity[0] ^= aulp_dest_state[5];
    aulp_dest_state[6] = ulrl_temp_array_b[1]^
                         ((~ulrl_temp_array_b[2])&ulrl_temp_array_b[3]);
    aulp_parity[1] ^= aulp_dest_state[6];
    aulp_dest_state[7] = ulrl_temp_array_b[2]^
                         ((~ulrl_temp_array_b[3])&ulrl_temp_array_b[4]);
    aulp_parity[2] ^= aulp_dest_state[7];
    aulp_dest_state[8] = ulrl_temp_array_b[3]^
                         ((~ulrl_temp_array_b[4])&ulrl_temp_array_b[0]);
    aulp_parity[3] ^= aulp_dest_state[8];
    aulp_dest_state[9] = ulrl_temp_array_b[4]^
                         ((~ulrl_temp_array_b[0])&ulrl_temp_array_b[1]);
    aulp_parity[4] ^= aulp_dest_state[9];

    // plane 2
    // Rho and Pi
    ulrl_temp_array_b[0] = m_rotl64(aulp_src_state[1],1);
    ulrl_temp_array_b[1] = m_rotl64(aulp_src_state[7],6);
    ulrl_temp_array_b[2] = m_rotl64(aulp_src_state[13],25);
    ulrl_temp_array_b[3] = m_rotl64(aulp_src_state[19],8);
    ulrl_temp_array_b[4] = m_rotl64(aulp_src_state[20],18);

    // Chi, and precalc parity for next round
    aulp_dest_state[10] = ulrl_temp_array_b[0]^
                          ((~ulrl_temp_array_b[1])&ulrl_temp_array_b[2]);
    aulp_parity[0] ^= aulp_dest_state[10];
    aulp_dest_state[11] = ulrl_temp_array_b[1]^
                          ((~ulrl_temp_array_b[2])&ulrl_temp_array_b[3]);
    aulp_parity[1] ^= aulp_dest_state[11];
    aulp_dest_state[12] = ulrl_temp_array_b[2]^
                          ((~ulrl_temp_array_b[3])&ulrl_temp_array_b[4]);
    aulp_parity[2] ^= aulp_dest_state[12];
    aulp_dest_state[13] = ulrl_temp_array_b[3]^
                          ((~ulrl_temp_array_b[4])&ulrl_temp_array_b[0]);
    aulp_parity[3] ^= aulp_dest_state[13];
    aulp_dest_state[14] = ulrl_temp_array_b[4]^
                          ((~ulrl_temp_array_b[0])&ulrl_temp_array_b[1]);
    aulp_parity[4] ^= aulp_dest_state[14];

    // plane 3
    // Rho and Pi
    ulrl_temp_array_b[0] = m_rotl64(aulp_src_state[4],27);
    ulrl_temp_array_b[1] = m_rotl64(aulp_src_state[5],36);
    ulrl_temp_array_b[2] = m_rotl64(aulp_src_state[11],10);
    ulrl_temp_array_b[3] = m_rotl64(aulp_src_state[17],15);
    ulrl_temp_array_b[4] = m_rotl64(aulp_src_state[23],56);

    // Chi, and precalc parity for next round
    aulp_dest_state[15] = ulrl_temp_array_b[0]^
                          ((~ulrl_temp_array_b[1])&ulrl_temp_array_b[2]);
    aulp_parity[0] ^= aulp_dest_state[15];
    aulp_dest_state[16] = ulrl_temp_array_b[1]^
                          ((~ulrl_temp_array_b[2])&ulrl_temp_array_b[3]);
    aulp_parity[1] ^= aulp_dest_state[16];
    aulp_dest_state[17] = ulrl_temp_array_b[2]^
                          ((~ulrl_temp_array_b[3])&ulrl_temp_array_b[4]);
    aulp_parity[2] ^= aulp_dest_state[17];
    aulp_dest_state[18] = ulrl_temp_array_b[3]^
                          ((~ulrl_temp_array_b[4])&ulrl_temp_array_b[0]);
    aulp_parity[3] ^= aulp_dest_state[18];
    aulp_dest_state[19] = ulrl_temp_array_b[4]^
                          ((~ulrl_temp_array_b[0])&ulrl_temp_array_b[1]);
    aulp_parity[4] ^= aulp_dest_state[19];

    // plane 4
    // Rho and Pi
    ulrl_temp_array_b[0] = m_rotl64(aulp_src_state[2],62);
    ulrl_temp_array_b[1] = m_rotl64(aulp_src_state[8],55);
    ulrl_temp_array_b[2] = m_rotl64(aulp_src_state[14],39);
    ulrl_temp_array_b[3] = m_rotl64(aulp_src_state[15],41);
    ulrl_temp_array_b[4] = m_rotl64(aulp_src_state[21],2);

    // Chi, and precalc parity for next round
    aulp_dest_state[20] = ulrl_temp_array_b[0]^
                          ((~ulrl_temp_array_b[1])&ulrl_temp_array_b[2]);
    aulp_parity[0] ^= aulp_dest_state[20];
    aulp_dest_state[21] = ulrl_temp_array_b[1]^
                          ((~ulrl_temp_array_b[2])&ulrl_temp_array_b[3]);
    aulp_parity[1] ^= aulp_dest_state[21];
    aulp_dest_state[22] = ulrl_temp_array_b[2]^
                          ((~ulrl_temp_array_b[3])&ulrl_temp_array_b[4]);
    aulp_parity[2] ^= aulp_dest_state[22];
    aulp_dest_state[23] = ulrl_temp_array_b[3]^
                          ((~ulrl_temp_array_b[4])&ulrl_temp_array_b[0]);
    aulp_parity[3] ^= aulp_dest_state[23];
    aulp_dest_state[24] = ulrl_temp_array_b[4]^
                          ((~ulrl_temp_array_b[0])&ulrl_temp_array_b[1]);
    aulp_parity[4] ^= aulp_dest_state[24];

} // end of void m_sha3_single_round(unsigned int, unsigned long long *, unsigned long long *, unsigned long long *)

static void m_sha3_permute_state(struct dsd_sha_3_state* adsp_sha_state)
{
    unsigned long long ulrl_parities[5];      // Array for state parrities
#ifndef HL_BIG_ENDIAN
    unsigned long long* aull_temp_state_1 = adsp_sha_state->ulrc_array;
    unsigned long long ulrl_temp_state_2[25];  // Temporary state array
#else
    unsigned long long aull_temp_state_1[25];  // Temporary state array
    unsigned long long ulrl_temp_state_2[25];  // Temporary state array
    // Fill temp state array
    for (unsigned int unl1 = 0; unl1 <25; unl1++) {
        aull_temp_state_1[unl1] = m_endianswap(adsp_sha_state->ulrc_array[unl1]);
    }
#endif
    // precalculate state parities
    ulrl_parities[0] = aull_temp_state_1[0]^aull_temp_state_1[5]^
                       aull_temp_state_1[10]^aull_temp_state_1[15]^aull_temp_state_1[20];
    ulrl_parities[1] = aull_temp_state_1[1]^aull_temp_state_1[6]^
                       aull_temp_state_1[11]^aull_temp_state_1[16]^aull_temp_state_1[21];
    ulrl_parities[2] = aull_temp_state_1[2]^aull_temp_state_1[7]^
                       aull_temp_state_1[12]^aull_temp_state_1[17]^aull_temp_state_1[22];
    ulrl_parities[3] = aull_temp_state_1[3]^aull_temp_state_1[8]^
                       aull_temp_state_1[13]^aull_temp_state_1[18]^aull_temp_state_1[23];
    ulrl_parities[4] = aull_temp_state_1[4]^aull_temp_state_1[9]^
                       aull_temp_state_1[14]^aull_temp_state_1[19]^aull_temp_state_1[24];

    // Do 12*2 permutation rounds
    for (unsigned int unl_round_count = 0; unl_round_count < 24; unl_round_count+=2) {
        m_sha3_single_round(unl_round_count, aull_temp_state_1,
                            ulrl_temp_state_2, ulrl_parities);
        m_sha3_single_round(unl_round_count+1, ulrl_temp_state_2,
                            aull_temp_state_1, ulrl_parities);
    }
    // write back state array
#ifdef HL_BIG_ENDIAN
    for (unsigned int unl1 = 0; unl1 < 25; unl1++) {
        adsp_sha_state->ulrc_array[unl1] = m_endianswap(aull_temp_state_1[unl1]);
    }
#endif
} //end of void ms_sha3_permute_state(struct dsd_sha_3_state*)

//------------------------------------------------------------------------------
// Start of original file ./xs-sha1.cpp
//------------------------------------------------------------------------------

#include <stdlib.h>
#include <string.h>

#ifdef _WIN32
#include <Windows.h>
#else
#include "hob-unix01.h"
#ifndef HL_UNIX
#define HL_UNIX
#if (defined __APPLE__) && (defined __MACH__)
#define HL_LINUX
#define HL_MACOS
#endif
#endif // !HL_UNIX
#endif

#include "hob-xslhcla1.hpp"
#include "hob-encry-2.h"
#include "hob-encry-intern-2.h"

// ------------------------------------------
//  Macros
// ------------------------------------------
#ifndef BIGchar2longcn
#define BIGchar2longcn(c,l,n) \
    { \
        switch (n) \
        { \
        case 0: \
            l = ((unsigned int)  ((unsigned short) c[3] & 0xFF)         & 0xFFFF) | \
                ((unsigned int) (((unsigned short) c[2] & 0xFF) <<  8) & 0xFFFF) | \
                ((unsigned int)  ((unsigned short) c[1] & 0xFF) << 16) | \
                ((unsigned int) (((unsigned short) c[0]   & 0xFF) <<  8) << 16); \
            break; \
        case 1: \
            l |=((unsigned int)  ((unsigned short) c[2] & 0xFF)         & 0xFFFF) | \
                 ((unsigned int) (((unsigned short) c[1] & 0xFF) <<  8) & 0xFFFF) | \
                 ((unsigned int)  ((unsigned short) c[0] & 0xFF) << 16); \
            break; \
        case 2: \
            l |=((unsigned int)  ((unsigned short) c[1] & 0xFF)         & 0xFFFF) | \
                 ((unsigned int) (((unsigned short) c[0] & 0xFF) <<  8) & 0xFFFF); \
            break; \
        case 3: \
            l |=((unsigned int)  ((unsigned short) c[0] & 0xFF)         & 0xFFFF); \
            break; \
        } \
    }
#endif

#ifndef BIGchar2long3n
#define BIGchar2long3n(c,l,n,i)\
{ \
  l = 0; \
  switch (n)\
  { \
    case 3: \
      l  = (unsigned int) (((unsigned short) c[i+2] & 0xFF)  <<  8) & 0xFFFF; \
    case 2: \
      l |= ((unsigned int)  ((unsigned short) c[i+1] & 0xFF)  << 16); \
    case 1: \
      l |= ((unsigned int) (((unsigned short) c[i]   & 0xFF)  <<  8) << 16); \
      break;\
  } \
}
#endif

//-----------------------------------------------------------------------------
// Constants, static functions
//-----------------------------------------------------------------------------
#define SHA_CBLOCK  64
#define SHA_LBLOCK  16
#define SHA_BLOCK   16
#define SHA_LAST_BLOCK  56

#define SHA_h0      SHA_BLOCK   // n
#define SHA_h1      SHA_BLOCK+1 // n+1
#define SHA_h2      SHA_BLOCK+2 // n+2
#define SHA_h3      SHA_BLOCK+3 // n+3
#define SHA_h4      SHA_BLOCK+4 // n+4
#define SHA_Nl      SHA_BLOCK+5 // n+5
#define SHA_Nh      SHA_BLOCK+6 // n+6
#define SHA_num     SHA_BLOCK+7 // n+7

static const unsigned int uns_init_data_h0 = 0x67452301;
static const unsigned int uns_init_data_h1 = 0xefcdab89;
static const unsigned int uns_init_data_h2 = 0x98badcfe;
static const unsigned int uns_init_data_h3 = 0x10325476;
static const unsigned int uns_init_data_h4 = 0xc3d2e1f0;

static void ms_sha1_block(unsigned int unrp_array[]);

// ------------------------------------------
// SHA-1 Initialization
// ------------------------------------------

void m_sha_1_init(void* avop_state)
{
    unsigned int *aunl_array = (unsigned int *)avop_state;

    aunl_array[SHA_h0]  = uns_init_data_h0;
    aunl_array[SHA_h1]  = uns_init_data_h1;
    aunl_array[SHA_h2]  = uns_init_data_h2;
    aunl_array[SHA_h3]  = uns_init_data_h3;
    aunl_array[SHA_h4]  = uns_init_data_h4;
    aunl_array[SHA_Nl]  = 0;
    aunl_array[SHA_Nh]  = 0;
    aunl_array[SHA_num] = 0;
}

// ------------------------------------------
// SHA-1 Update
// ------------------------------------------

void m_sha_1_update(void* avop_state,
                    const unsigned char* abyp_input,
                    size_t szp_input_len)
{
    unsigned int *aunl_array = (unsigned int *)avop_state;
    unsigned int unl_i, unl_j, unl_ew, unl_ec, unl_sw, unl_sc;
    unsigned int unl_l;

    if (szp_input_len == 0) {
        return;                             // check zero length

    }
    //----------------------------------------------------------------
    // calulate new total B I T - length
    //----------------------------------------------------------------
    unl_l = aunl_array[SHA_Nl];             // Save for Carry check
    aunl_array[SHA_Nl] =                    // add new length bit count
                         aunl_array[SHA_Nl] + (unsigned int) (szp_input_len << 3);

    if(unl_l > aunl_array[SHA_Nl]) {
        aunl_array[SHA_Nh]++;               // had a Carry out
    }

    unl_i = 0;                              // Data-Array StartIndex
    if (aunl_array[SHA_num] != 0) {
        // check for saved data in array
        //=================================================================
        // stored data in array, fill up until SHA-Block complete (16 longs)
        // or data exhausted
        //=================================================================
        unl_sw = aunl_array[SHA_num] >> 2;   // full 4Byte longs
        unl_sc = aunl_array[SHA_num] & 0x03; // remaining bytes

        // NOTE: overflow will occur above 4 GByte - 64 Byte !! (> (2**31-1) - 64)

        if ((aunl_array[SHA_num] + szp_input_len) >= SHA_CBLOCK) {
            //---------------------------------------------------------------
            // enough data to complete array, do copy data to array,
            // generate Digest
            //---------------------------------------------------------------
            unl_l = aunl_array[unl_sw];                     // get address of next or incomplete
            BIGchar2longcn(abyp_input,unl_l,unl_sc);        // get required bytes
            unl_i += (4 - unl_sc);

            aunl_array[unl_sw] = unl_l;                     // save to array
            unl_sw++;                                       // to next location
            for (; unl_sw < SHA_LBLOCK; unl_sw++) {
                ms_read_big_endian(unl_l, abyp_input + unl_i);      // continue copying full longs
                unl_i += 4;
                aunl_array[unl_sw] = unl_l;
            }
            szp_input_len -= (SHA_CBLOCK - aunl_array[SHA_num]);    // reduce length

            ms_sha1_block(aunl_array);                      // get digest
            aunl_array[SHA_num] = 0;                        // no data in array
        } else {
            //---------------------------------------------------------------
            // not enough data to complete array, do copy data to array only
            // and exit
            //---------------------------------------------------------------
            aunl_array[SHA_num] += (unsigned int)szp_input_len;     // remaining bytes, always < 64
            if ((unl_sc + szp_input_len) < 4) {             // cannot fill a full long
                unl_l = aunl_array[unl_sw];                 // get saved bytes (if any)
                switch(unl_sc) {
                case 0: // no bytes saved
                    unl_l = (abyp_input[unl_i++] & 0xFF) << 24;     // save byte
                    szp_input_len--;
                    if(szp_input_len == 0) {
                        break;
                    }
                case 1: // 1 byte saved
                    unl_l |= ((abyp_input[unl_i++] & 0xFF) << 16);  // insert next
                    szp_input_len--;
                    if(szp_input_len == 0) {
                        break;
                    }
                case 2: // 2 byte saved
                    unl_l |= ((abyp_input[unl_i++] & 0xFF) << 8);   // insert next
                    szp_input_len--;
                    if(szp_input_len == 0) {
                        break;
                    }
                case 3: // 3 byte saved
                    unl_l |= ( abyp_input[unl_i++] & 0xFF);         // insert next
                    break;
                }
                aunl_array[unl_sw] = unl_l;         // save incomplete long
            } else {
                unl_ew =aunl_array[SHA_num];        // get ending byte count
                unl_ec = unl_ew & 0x03;             // incomplete ending byte count
                unl_ew >>= 2;                       // full longs for copy

                unl_l = aunl_array[unl_sw];         // get saved bytes (if any)
                BIGchar2longcn(abyp_input,unl_l,unl_sc);   // insert bytes or copy full long
                unl_i += (4 - unl_sc);

                aunl_array[unl_sw] = unl_l;         // save full long
                unl_sw++;                           // to next long

                for (; unl_sw < unl_ew; unl_sw++) { // copy full longs
                    ms_read_big_endian(unl_l, abyp_input + unl_i);
                    unl_i += 4;
                    aunl_array[unl_sw] = unl_l;
                }
                if(unl_ec != 0) {                   // remaining bytes to copy into a long
                    BIGchar2long3n(abyp_input,unl_l,unl_ec,unl_i);
                    aunl_array[unl_sw] = unl_l;
                }
            }
            return; // exit, wait for more data
        }
    } // end of stored data preprocessing
      //=================================================================
      // no stored data in array, start storing data until filled up
      //=================================================================
    while (szp_input_len >= SHA_CBLOCK) {   // only for full blocks
        unl_j = 0;                          // index to Stored data
        for (unl_sw=(SHA_BLOCK/4); unl_sw != 0; unl_sw--) { // full long copy loop
            ms_read_big_endian(aunl_array[unl_j], abyp_input + unl_i);
            ms_read_big_endian(aunl_array[unl_j + 1], abyp_input + unl_i + 4);
            ms_read_big_endian(aunl_array[unl_j + 2], abyp_input + unl_i + 8);
            ms_read_big_endian(aunl_array[unl_j + 3], abyp_input + unl_i + 12);
            unl_i += 16;
            unl_j += 4;
        }
        ms_sha1_block(aunl_array);              // process Digest
        szp_input_len -= SHA_CBLOCK;        // subtract blocklength
    }
    //
    // calculate remaining longs and rest bytes/long
    //
    unl_ec = (unsigned int) szp_input_len;  // is always < SHA_BLOCK !!
    aunl_array[SHA_num] = unl_ec;           // save remaining data bytes
    unl_ew = unl_ec >> 2;                   // calculate full long count
    unl_ec &= 0x03;                         // get last remaining bytes
    unl_sw = 0;                             // index data field start
    for (; unl_sw < unl_ew; unl_sw++) {     // copy full longs if any
        ms_read_big_endian(unl_l, abyp_input + unl_i);
        unl_i += 4;
        aunl_array[unl_sw] = unl_l;
    }
    if (unl_ec != 0) {                      // copy remaining bytes if any
        BIGchar2long3n(abyp_input, unl_l, unl_ec, unl_i);
        aunl_array[unl_sw] = unl_l;
    }
} // m_sha_1_update

void m_sha_1_gather_update(void* avop_state,
                           struct dsd_gather_i_1* adsp_input,
                           size_t szp_input_len)
{
    while ((szp_input_len > 0) && !(adsp_input == NULL)) {
        size_t szl_elm_len = adsp_input->achc_ginp_end - adsp_input->achc_ginp_cur;
        if (szl_elm_len > szp_input_len) {
            szl_elm_len = szp_input_len;
        }
        m_sha_1_update(avop_state,
                       (const unsigned char *)adsp_input->achc_ginp_cur,
                       szl_elm_len);
        szp_input_len -= szl_elm_len;

        adsp_input = adsp_input->adsc_next;
    }
}

// ------------------------------------------
// SHA-1 Final
// ------------------------------------------

void m_sha_1_final(void* avop_state,
                   unsigned char* abyp_digest)
{
    unsigned int* aunl_array = (unsigned int *)avop_state;
    unsigned int unl_i, unl_j;
    unsigned int unl_l;
    unsigned char byrl_end[4] = {
        0x80, 0x00, 0x00, 0x00
    };                                                      // padding bytes array

    /* Array data should definitly have room for at least one more byte. */

    //---------------------------------------------------------------
    // Get stored long and remaining byte counts, append padding bits
    //---------------------------------------------------------------
    unl_j = aunl_array[SHA_num];                        // get stored long count
    unl_i = unl_j >> 2;                                 // get remaining byte count

    unl_l = aunl_array[unl_i];                          // get last stored long
    BIGchar2longcn(byrl_end,unl_l,(unl_j & 0x03));      // insert 1..4 padding bytes
    aunl_array[unl_i] = unl_l;                          // save full long
    unl_i++;                                            // to next long (not yet loaded)
    //---------------------------------------------------------------
    // check if this block has room for length data (8 bytes)
    // if not fill with zeroes and generate Digest
    //---------------------------------------------------------------
    if (aunl_array[SHA_num] >= SHA_LAST_BLOCK) {        // not enough room
        for (; unl_i<SHA_LBLOCK; unl_i++) {
            aunl_array[unl_i] = 0;                      // zero data
        }
        ms_sha1_block(aunl_array);                      // generate digest
        unl_i = 0;                                      // set index back
    }
    //---------------------------------------------------------------
    // fill block with zeroes until position for length reached,
    // insert bitlength, generate final Digest
    //---------------------------------------------------------------
    for (; unl_i < (SHA_LBLOCK-2); unl_i++) {
        aunl_array[unl_i]=0;                            // clear
    }
    aunl_array[SHA_LBLOCK-2] = aunl_array[SHA_Nh];      // set length high
    aunl_array[SHA_LBLOCK-1] = aunl_array[SHA_Nl];      // dto. low
    ms_sha1_block(aunl_array);                          // generate final digest
    //---------------------------------------------------------------
    // copy final digest to user buffer, clear SHA Array (safety)
    //---------------------------------------------------------------
    ms_write_big_endian(abyp_digest, aunl_array[SHA_h0]);
    ms_write_big_endian(abyp_digest + 4, aunl_array[SHA_h1]);
    ms_write_big_endian(abyp_digest + 8, aunl_array[SHA_h2]);
    ms_write_big_endian(abyp_digest + 12, aunl_array[SHA_h3]);
    ms_write_big_endian(abyp_digest + 16, aunl_array[SHA_h4]);
    m_sec_memzero(aunl_array, cind_state_size_sha_1);
} // m_sha_1_final


// ------------------------------------------
// Static definitions
// ------------------------------------------

#if defined _WIN32  // only faster on older Pentiums ???
#define ULROT1(l)   _lrotl(l,1)
#define ULROT5(l)   _lrotl(l,5)
#define URROT2(l)   _lrotl(l,30)
#else
#define ULROT1(l) (l << 1) | ((l >> 31) & 0x01)
#define ULROT5(l) (l << 5) + ((l >> 27) & 0x1F)
#define URROT2(l) ((l >> 2) & 0x3FFFFFFF) | (l << 30)
#endif

#define K_00_19 0x5a827999
#define K_20_39 0x6ed9eba1
#define K_40_59 0x8f1bbcdc
#define K_60_79 0xca62c1d6

#define Xupdate(a,i) \
    a = (unrp_array[i      & 0x0F]^unrp_array[(i+2)  & 0x0F]^ \
         unrp_array[(i+8)  & 0x0F]^unrp_array[(i+13) & 0x0F]); \
    unrp_array[i & 0x0F] = a = ULROT1(a);

#define BODY_00_15(i,a,b,c,d,e,f) \
    f = unrp_array[i] + e + K_00_19 + ULROT5(a) + (((c ^ d) & b) ^ d); \
    b = URROT2(b);

#define BODY_16_19(i,a,b,c,d,e,f) \
    Xupdate(f,i); \
    f += e + K_00_19 + ULROT5(a) + (((c ^ d) & b) ^ d); \
    b = URROT2(b);

#define BODY_20_39(i,a,b,c,d,e,f) \
    Xupdate(f,i); \
    f += e + K_20_39 + ULROT5(a) + (b^c^d); \
    b = URROT2(b);

#define BODY_40_59(i,a,b,c,d,e,f) \
    Xupdate(f,i); \
    f += e + K_40_59 + ULROT5(a) + ((b & c) | ((b | c) & d)); \
    b = URROT2(b);

#define BODY_60_79(i,a,b,c,d,e,f) \
    Xupdate(f,i); \
    f = unrp_array[i & 0x0F]+e+ K_60_79 + ULROT5(a) + (b^c^d); \
    b = URROT2((b));

static void ms_sha1_block(unsigned int unrp_array[])
{
    unsigned int unl_t;
    unsigned int unl_a = unrp_array[SHA_h0];
    unsigned int unl_b = unrp_array[SHA_h1];
    unsigned int unl_c = unrp_array[SHA_h2];
    unsigned int unl_d = unrp_array[SHA_h3];
    unsigned int unl_e = unrp_array[SHA_h4];

    BODY_00_15( 0,unl_a,unl_b,unl_c,unl_d,unl_e,unl_t);
    BODY_00_15( 1,unl_t,unl_a,unl_b,unl_c,unl_d,unl_e);
    BODY_00_15( 2,unl_e,unl_t,unl_a,unl_b,unl_c,unl_d);
    BODY_00_15( 3,unl_d,unl_e,unl_t,unl_a,unl_b,unl_c);
    BODY_00_15( 4,unl_c,unl_d,unl_e,unl_t,unl_a,unl_b);
    BODY_00_15( 5,unl_b,unl_c,unl_d,unl_e,unl_t,unl_a);
    BODY_00_15( 6,unl_a,unl_b,unl_c,unl_d,unl_e,unl_t);
    BODY_00_15( 7,unl_t,unl_a,unl_b,unl_c,unl_d,unl_e);
    BODY_00_15( 8,unl_e,unl_t,unl_a,unl_b,unl_c,unl_d);
    BODY_00_15( 9,unl_d,unl_e,unl_t,unl_a,unl_b,unl_c);
    BODY_00_15(10,unl_c,unl_d,unl_e,unl_t,unl_a,unl_b);
    BODY_00_15(11,unl_b,unl_c,unl_d,unl_e,unl_t,unl_a);
    BODY_00_15(12,unl_a,unl_b,unl_c,unl_d,unl_e,unl_t);
    BODY_00_15(13,unl_t,unl_a,unl_b,unl_c,unl_d,unl_e);
    BODY_00_15(14,unl_e,unl_t,unl_a,unl_b,unl_c,unl_d);
    BODY_00_15(15,unl_d,unl_e,unl_t,unl_a,unl_b,unl_c);
    BODY_16_19(16,unl_c,unl_d,unl_e,unl_t,unl_a,unl_b);
    BODY_16_19(17,unl_b,unl_c,unl_d,unl_e,unl_t,unl_a);
    BODY_16_19(18,unl_a,unl_b,unl_c,unl_d,unl_e,unl_t);
    BODY_16_19(19,unl_t,unl_a,unl_b,unl_c,unl_d,unl_e);

    BODY_20_39(20,unl_e,unl_t,unl_a,unl_b,unl_c,unl_d);
    BODY_20_39(21,unl_d,unl_e,unl_t,unl_a,unl_b,unl_c);
    BODY_20_39(22,unl_c,unl_d,unl_e,unl_t,unl_a,unl_b);
    BODY_20_39(23,unl_b,unl_c,unl_d,unl_e,unl_t,unl_a);
    BODY_20_39(24,unl_a,unl_b,unl_c,unl_d,unl_e,unl_t);
    BODY_20_39(25,unl_t,unl_a,unl_b,unl_c,unl_d,unl_e);
    BODY_20_39(26,unl_e,unl_t,unl_a,unl_b,unl_c,unl_d);
    BODY_20_39(27,unl_d,unl_e,unl_t,unl_a,unl_b,unl_c);
    BODY_20_39(28,unl_c,unl_d,unl_e,unl_t,unl_a,unl_b);
    BODY_20_39(29,unl_b,unl_c,unl_d,unl_e,unl_t,unl_a);
    BODY_20_39(30,unl_a,unl_b,unl_c,unl_d,unl_e,unl_t);
    BODY_20_39(31,unl_t,unl_a,unl_b,unl_c,unl_d,unl_e);
    BODY_20_39(32,unl_e,unl_t,unl_a,unl_b,unl_c,unl_d);
    BODY_20_39(33,unl_d,unl_e,unl_t,unl_a,unl_b,unl_c);
    BODY_20_39(34,unl_c,unl_d,unl_e,unl_t,unl_a,unl_b);
    BODY_20_39(35,unl_b,unl_c,unl_d,unl_e,unl_t,unl_a);
    BODY_20_39(36,unl_a,unl_b,unl_c,unl_d,unl_e,unl_t);
    BODY_20_39(37,unl_t,unl_a,unl_b,unl_c,unl_d,unl_e);
    BODY_20_39(38,unl_e,unl_t,unl_a,unl_b,unl_c,unl_d);
    BODY_20_39(39,unl_d,unl_e,unl_t,unl_a,unl_b,unl_c);

    BODY_40_59(40,unl_c,unl_d,unl_e,unl_t,unl_a,unl_b);
    BODY_40_59(41,unl_b,unl_c,unl_d,unl_e,unl_t,unl_a);
    BODY_40_59(42,unl_a,unl_b,unl_c,unl_d,unl_e,unl_t);
    BODY_40_59(43,unl_t,unl_a,unl_b,unl_c,unl_d,unl_e);
    BODY_40_59(44,unl_e,unl_t,unl_a,unl_b,unl_c,unl_d);
    BODY_40_59(45,unl_d,unl_e,unl_t,unl_a,unl_b,unl_c);
    BODY_40_59(46,unl_c,unl_d,unl_e,unl_t,unl_a,unl_b);
    BODY_40_59(47,unl_b,unl_c,unl_d,unl_e,unl_t,unl_a);
    BODY_40_59(48,unl_a,unl_b,unl_c,unl_d,unl_e,unl_t);
    BODY_40_59(49,unl_t,unl_a,unl_b,unl_c,unl_d,unl_e);
    BODY_40_59(50,unl_e,unl_t,unl_a,unl_b,unl_c,unl_d);
    BODY_40_59(51,unl_d,unl_e,unl_t,unl_a,unl_b,unl_c);
    BODY_40_59(52,unl_c,unl_d,unl_e,unl_t,unl_a,unl_b);
    BODY_40_59(53,unl_b,unl_c,unl_d,unl_e,unl_t,unl_a);
    BODY_40_59(54,unl_a,unl_b,unl_c,unl_d,unl_e,unl_t);
    BODY_40_59(55,unl_t,unl_a,unl_b,unl_c,unl_d,unl_e);
    BODY_40_59(56,unl_e,unl_t,unl_a,unl_b,unl_c,unl_d);
    BODY_40_59(57,unl_d,unl_e,unl_t,unl_a,unl_b,unl_c);
    BODY_40_59(58,unl_c,unl_d,unl_e,unl_t,unl_a,unl_b);
    BODY_40_59(59,unl_b,unl_c,unl_d,unl_e,unl_t,unl_a);

    BODY_60_79(60,unl_a,unl_b,unl_c,unl_d,unl_e,unl_t);
    BODY_60_79(61,unl_t,unl_a,unl_b,unl_c,unl_d,unl_e);
    BODY_60_79(62,unl_e,unl_t,unl_a,unl_b,unl_c,unl_d);
    BODY_60_79(63,unl_d,unl_e,unl_t,unl_a,unl_b,unl_c);
    BODY_60_79(64,unl_c,unl_d,unl_e,unl_t,unl_a,unl_b);
    BODY_60_79(65,unl_b,unl_c,unl_d,unl_e,unl_t,unl_a);
    BODY_60_79(66,unl_a,unl_b,unl_c,unl_d,unl_e,unl_t);
    BODY_60_79(67,unl_t,unl_a,unl_b,unl_c,unl_d,unl_e);
    BODY_60_79(68,unl_e,unl_t,unl_a,unl_b,unl_c,unl_d);
    BODY_60_79(69,unl_d,unl_e,unl_t,unl_a,unl_b,unl_c);
    BODY_60_79(70,unl_c,unl_d,unl_e,unl_t,unl_a,unl_b);
    BODY_60_79(71,unl_b,unl_c,unl_d,unl_e,unl_t,unl_a);
    BODY_60_79(72,unl_a,unl_b,unl_c,unl_d,unl_e,unl_t);
    BODY_60_79(73,unl_t,unl_a,unl_b,unl_c,unl_d,unl_e);
    BODY_60_79(74,unl_e,unl_t,unl_a,unl_b,unl_c,unl_d);
    BODY_60_79(75,unl_d,unl_e,unl_t,unl_a,unl_b,unl_c);
    BODY_60_79(76,unl_c,unl_d,unl_e,unl_t,unl_a,unl_b);
    BODY_60_79(77,unl_b,unl_c,unl_d,unl_e,unl_t,unl_a);
    BODY_60_79(78,unl_a,unl_b,unl_c,unl_d,unl_e,unl_t);
    BODY_60_79(79,unl_t,unl_a,unl_b,unl_c,unl_d,unl_e);

    unrp_array[SHA_h0] += unl_e;
    unrp_array[SHA_h1] += unl_t;
    unrp_array[SHA_h2] += unl_a;
    unrp_array[SHA_h3] += unl_b;
    unrp_array[SHA_h4] += unl_c;
} // ms_sha1_block

//------------------------------------------------------------------------------
// Start of original file ./xs-hmac.cpp
//------------------------------------------------------------------------------

#include <stdlib.h>
#include <string.h>

#ifdef _WIN32
#include <Windows.h>
#else
#include "hob-unix01.h"
#ifndef HL_UNIX
#define HL_UNIX
#if (defined __APPLE__) && (defined __MACH__)
#define HL_LINUX
#define HL_MACOS
#endif
#endif // !HL_UNIX

#endif

#include "hob-xslhcla1.hpp"
#include "hob-encry-2.h"
#include "hob-encry-intern-2.h"

#define HMAC_IPAD   0x36
#define HMAC_OPAD   0x5C

/*
 * Xors array content with given value (ms_xor_bit_8_array).
 *
 *  @param abyp_buf  Array Base
 *  @param szl_len   Size of Data
 *  @param unl_val   Value for XOR (Low Byte)
 */
static void ms_xor_bit_8_array(unsigned char *abyp_buf,
                               size_t szp_len,
                               unsigned int unp_val)
{
    size_t szl_index = 0;
    if (abyp_buf != NULL) {
        for (; szl_index < szp_len; szl_index++) {
            abyp_buf[szl_index] ^= (unsigned char)unp_val;
        }
    }
}

/**
   Generates a HMAC tag for a data buffer.

   The hash type is as specified by enum ied_hash_function. Any of these enums
   can be used as inp_hash_type. The tag is always as long as the digest of the
   chosen hash. Key and data can be of any length.

   All pointers must be non-null.

   @param[out]     abyp_dest       Output buffer for the generated tag
   @param[in,out]  aszp_dest_len   IN: Length of the output buffer
                                OUT: Length of the generated tag
   @param[in]      abyp_data       Data of which the HMAC will be generated
   @param[in]      szp_data_len    Length of the data
   @param[in]      avop_key        Key used for generating the HMAC
   @param[in]      szp_key_len     Length of the key in bytes
   @param[in]      inp_hash_type   Hash type to be used by the HMAC

   @return ied_encry_success or error code
 */
ied_encry_return m_hmac_gen(unsigned char* abyp_dest,
                            size_t* aszp_dest_len,
                            const unsigned char* abyp_data,
                            size_t szp_data_len,
                            const void* avop_key,
                            size_t szp_key_len,
                            int inp_hash_type)
{
    struct dsd_gather_i_1 dsl_wrapper_gather;
    if ((abyp_dest == NULL) || (aszp_dest_len == NULL) || (abyp_data == NULL) || (avop_key == NULL)) {
        return ied_encry_null_pointer;
    }
    dsl_wrapper_gather.achc_ginp_cur = (char *)abyp_data;
    dsl_wrapper_gather.achc_ginp_end = dsl_wrapper_gather.achc_ginp_cur + szp_data_len;
    dsl_wrapper_gather.adsc_next = NULL;

    return m_hmac_gather_gen(abyp_dest,
                             aszp_dest_len,
                             &dsl_wrapper_gather,
                             szp_data_len,
                             avop_key,
                             szp_key_len,
                             inp_hash_type);
} // m_hmac_gen

/**
   Generates a HMAC tag for a data buffer.

   The hash type is as specified by enum ied_hash_function. Any of these enums
   can be used as inp_hash_type. The tag is always as long as the digest of the
   chosen hash. Key and data can be of any length.

   All pointers must be non-null.

   @param[out]     abyp_dest       Output buffer for the generated tag
   @param[in,out]  aszp_dest_len   IN: Length of the output buffer
                                   OUT: Length of the generated tag
   @param[in]      adsp_data       Data of which the HMAC will be generated
   @param[in]      szp_data_len    Length of the data
   @param[in]      avop_key        Key used for generating the HMAC
   @param[in]      szp_key_len     Length of the key in bytes
   @param[in]      inp_hash_type   Hash type to be used by the HMAC

   @return ied_encry_success or error code
 */
ied_encry_return m_hmac_gather_gen(unsigned char* abyp_dest,
                                   size_t* aszp_dest_len,
                                   struct dsd_gather_i_1* adsp_data,
                                   size_t szp_data_len,
                                   const void* avop_key,
                                   size_t szp_key_len,
                                   int inp_hash_type)
{
    unsigned char byrl_hash_state[cind_hash_max_state_size];
    unsigned char byrl_key_buf[cind_hash_max_block_size] = { 0 };
    unsigned char byrl_digest_buf[cind_hash_max_digest_size];
    struct dsd_hash_profile dsl_hash_prof;


    if ((abyp_dest == NULL) || (aszp_dest_len == NULL) || (adsp_data == NULL) || (avop_key == NULL)) {
        return ied_encry_null_pointer;
    }
    if ((inp_hash_type < 0) || (inp_hash_type > ied_hash_count)) {
        return ied_encry_invalid_input;
    }
    dsl_hash_prof = dsrg_hash_profiles[inp_hash_type];

    if (*aszp_dest_len < dsl_hash_prof.szc_digest_size) {
        return ied_encry_insufficient_buffer;
    }

    //-------------------------------------------------------
    // Generate the Key buffer from Key
    //-------------------------------------------------------
    if(szp_key_len > dsl_hash_prof.szc_block_size) {
        //-----------------------------------------------------
        // Must shrink the Key down
        //-----------------------------------------------------
        dsl_hash_prof.amc_hash_init (byrl_hash_state);
        dsl_hash_prof.amc_hash_update(byrl_hash_state, (const unsigned char *)avop_key, szp_key_len);
        dsl_hash_prof.amc_hash_final(byrl_hash_state, byrl_key_buf);
    } else {
        //--------------------------------------------------------
        // Pad the Key with 0x00 till Blocksize is reached
        //--------------------------------------------------------
        memcpy(byrl_key_buf, avop_key, szp_key_len);
    }
    //--------------------------------------------------------
    // XOR the Key buffer with IPAD (0x36)
    //--------------------------------------------------------
    ms_xor_bit_8_array(byrl_key_buf, dsl_hash_prof.szc_block_size, HMAC_IPAD);

    //--------------------------------------------------------
    // Build hash from concatenation of Xored Key and Data
    //--------------------------------------------------------
    dsl_hash_prof.amc_hash_init(byrl_hash_state);
    dsl_hash_prof.amc_hash_update(byrl_hash_state, byrl_key_buf, dsl_hash_prof.szc_block_size);
    dsl_hash_prof.amc_hash_gather_update(byrl_hash_state, adsp_data, szp_data_len);
    dsl_hash_prof.amc_hash_final(byrl_hash_state, byrl_digest_buf);

    //--------------------------------------------------------
    // Remove IPAD and XOR with OPAD (0x5C)
    //--------------------------------------------------------
    ms_xor_bit_8_array(byrl_key_buf, dsl_hash_prof.szc_block_size, HMAC_IPAD ^ HMAC_OPAD);

    //-----------------------------------------------------------
    // Build hash from concatenation of padded key and Inner Hash
    //-----------------------------------------------------------
    dsl_hash_prof.amc_hash_init(byrl_hash_state);
    dsl_hash_prof.amc_hash_update(byrl_hash_state, byrl_key_buf, dsl_hash_prof.szc_block_size);
    dsl_hash_prof.amc_hash_update(byrl_hash_state, byrl_digest_buf, dsl_hash_prof.szc_digest_size);
    dsl_hash_prof.amc_hash_final(byrl_hash_state, abyp_dest);
    *aszp_dest_len = dsl_hash_prof.szc_digest_size;

    m_sec_memzero(byrl_key_buf, sizeof(byrl_key_buf));
    m_sec_memzero(byrl_digest_buf, sizeof(byrl_digest_buf));

    return ied_encry_success;
} // m_hmac_gather_gen

/**
   Verifies a HMAC tag for a data buffer.

   The hash type is as specified by enum ied_hash_function. Any of these enums
   can be used as inp_hash_type. Verification is done in a side-channel resistant
   manner.

   All pointers must be non-null.

   @param[in]  abyp_dest       Tag to be checked
   @param[in]  aszp_dest_len   Length of the tag
   @param[in]  abyp_data       Data to be checked
   @param[in]  szp_data_len    Length of the data
   @param[in]  avop_key        Key used for generating the HMAC
   @param[in]  szp_key_len     Length of the key in bytes
   @param[in]  inp_hash_type   Hash type to be used by the HMAC

   @return ied_encry_success on success, ied_encry_verify_failed on verification failure or error code
 */
ied_encry_return m_hmac_verify(const unsigned char* abyp_tag,
                               size_t szp_tag_len,
                               const unsigned char* abyp_data,
                               size_t szp_data_len,
                               const void* avop_key,
                               size_t szp_key_len,
                               int inp_hash_type)
{
    unsigned char byrl_digest_buf[cind_hash_max_digest_size];
    size_t szl_digest_len = cind_hash_max_digest_size;
    ied_encry_return iel_ret;

    if (abyp_tag == NULL) {
        return ied_encry_null_pointer;
    }

    iel_ret = m_hmac_gen(byrl_digest_buf,
                         &szl_digest_len,
                         abyp_data,
                         szp_data_len,
                         avop_key,
                         szp_key_len,
                         inp_hash_type);
    if (iel_ret != ied_encry_success) {
        return iel_ret;
    }

    if ((szp_tag_len != szl_digest_len) ||
        (m_sec_memcmp(abyp_tag, byrl_digest_buf, szp_tag_len) != 0))
    {
        m_sec_memzero(byrl_digest_buf, sizeof(byrl_digest_buf));
        return ied_encry_verify_failed;
    }
    return ied_encry_success;
} // m_hmac_verify

/**
   Verifies a HMAC tag for a data buffer.

   The hash type is as specified by enum ied_hash_function. Any of these enums
   can be used as inp_hash_type. Verification is done in a side-channel resistant
   manner.

   All pointers must be non-null.

   @param[in]  abyp_dest       Tag to be checked
   @param[in]  aszp_dest_len   Length of the tag
   @param[in]  adsp_data       Data to be checked
   @param[in]  szp_data_len    Length of the data
   @param[in]  avop_key        Key used for generating the HMAC
   @param[in]  szp_key_len     Length of the key in bytes
   @param[in]  inp_hash_type   Hash type to be used by the HMAC

   @return ied_encry_success on success, ied_encry_verify_failed on verification failure or error code
 */
ied_encry_return m_hmac_gather_verify(const unsigned char* abyp_tag,
                                      size_t szp_tag_len,
                                      struct dsd_gather_i_1* adsp_data,
                                      size_t szp_data_len,
                                      const void* avop_key,
                                      size_t szp_key_len,
                                      int inp_hash_type)
{
    unsigned char byrl_digest_buf[cind_hash_max_digest_size];
    size_t szl_digest_len = cind_hash_max_digest_size;
    ied_encry_return iel_ret;

    if (abyp_tag == NULL) {
        return ied_encry_null_pointer;
    }

    iel_ret = m_hmac_gather_gen(byrl_digest_buf,
                                &szl_digest_len,
                                adsp_data,
                                szp_data_len,
                                avop_key,
                                szp_key_len,
                                inp_hash_type);
    if (iel_ret != ied_encry_success) {
        return iel_ret;
    }

    if ((szp_tag_len != szl_digest_len) ||
        (m_sec_memcmp(abyp_tag, byrl_digest_buf, szp_tag_len) != 0))
    {
        m_sec_memzero(byrl_digest_buf, sizeof(byrl_digest_buf));
        return ied_encry_verify_failed;
    }
    return ied_encry_success;
} // m_hmac_gather_verify

//------------------------------------------------------------------------------
// Start of original file ./xs-memory.cpp
//------------------------------------------------------------------------------

#include <stdlib.h>
#include <string.h>

#ifdef _WIN32
#include <Windows.h>
#else
#include "hob-unix01.h"
#endif

#include "hob-encry-2.h"

#ifndef _WIN32
#include <limits.h>
#include <stdint.h>
#endif

#ifndef HL_OPTIMIZE_OFF
#if defined __APPLE__ // TODO: Alternative implementation is needed because of the current compiler error with "optimize off"
#define HL_OPTIMIZE_OFF
#define HL_OPTIMIZE_ON
#elif defined __clang__
#define HL_OPTIMIZE_OFF _Pragma("clang optimize off")
#define HL_OPTIMIZE_ON _Pragma("clang optimize on")
#elif defined __GNUC__
#define HL_OPTIMIZE_OFF _Pragma("GCC push_options") \
    _Pragma("GCC optimize (\"O0\")")
#define HL_OPTIMIZE_ON _Pragma("GCC pop_options")
#elif defined _WIN32
#define HL_OPTIMIZE_OFF __pragma(optimize("", off))
#define HL_OPTIMIZE_ON __pragma(optimize("", on ))
#else
#define HL_OPTIMIZE_OFF
#define HL_OPTIMIZE_ON
#endif
#endif

#define UINTDIVROUNDUP(n,d) (((n) + (d) - (1))/(d))
#define UINTROUNDUPSTRICT(n,d) (((n) | ((d) - 1)) + 1)
#define UINTROUNDUP(n,d) ((((n) - 1) | ((d) - 1)) + 1)
#define ALIGN(type,a) (a)=(type)((((size_t)a)+HL_ALIGNMENT-1)& (~(HL_ALIGNMENT-1)))

// ------------------------------------------
//  Standard memory provider implementation
// ------------------------------------------

inline void* m_std_malloc(struct dsd_memory*,
                          size_t szp_size)
{
    return malloc(szp_size);
}

inline void m_std_free(struct dsd_memory*,
                       void* avop_ptr)
{
    free(avop_ptr);
}

struct dsd_memory dsg_std_memory = {
    m_std_malloc, m_std_free, NULL
};


// ------------------------------------------
//  Memory pool functions
// ------------------------------------------

extern "C" dsd_mem_pool_ele* m_mem_pool_create(struct dsd_memory* adsp_memory,
                                               size_t szp_block_size,
                                               unsigned int unp_block_count)
{
#ifndef HL_OMIT_PARAM_CHECKS
    if( (adsp_memory == NULL) || (szp_block_size == 0)) {
        return NULL;
    }
#endif

    dsd_mem_pool_ele* adsl_ret = NULL;
    dsd_mem_pool_ele* adsl_last_ele = NULL;

    // Main allocation loop
    while(unp_block_count != 0) {
        // Allocate element
        dsd_mem_pool_ele* adsl_new_ele = (dsd_mem_pool_ele*)adsp_memory->amc_malloc(adsp_memory,
                                                                                    sizeof(dsd_mem_pool_ele));
        if(adsl_new_ele == NULL) {
            break;
        }

        // This builds up the linked list
        if(adsl_ret == NULL) {
            adsl_ret = adsl_new_ele;
        } else {
            adsl_last_ele->adsc_next = adsl_new_ele;
        }

        // Initialize element
        adsl_new_ele->adsc_next = NULL;
        adsl_new_ele->achc_base = (char*)adsp_memory->amc_malloc(adsp_memory, szp_block_size);

        if(adsl_new_ele->achc_base == NULL) {
            break;
        }

        adsl_new_ele->achc_current = adsl_new_ele->achc_base;
        adsl_new_ele->achc_max_used = adsl_new_ele->achc_base;
        adsl_new_ele->achc_end = adsl_new_ele->achc_base + szp_block_size;

        adsl_last_ele = adsl_new_ele;
        unp_block_count--;
    }

    if(unp_block_count != 0) {
        // some alloc fail happened, free all allocated things
        while( adsl_ret != NULL ) {
            dsd_mem_pool_ele* adsl_next = adsl_ret->adsc_next;
            adsp_memory->amc_free(adsp_memory, adsl_ret->achc_base);
            adsp_memory->amc_free(adsp_memory, adsl_ret);
            adsl_ret = adsl_next;
        }
    }

    return adsl_ret;
} // m_mem_pool_create

extern "C" ied_encry_return m_mem_pool_init_ele(struct dsd_mem_pool_ele* adsp_element,
                                                struct dsd_memory* adsp_memory,
                                                size_t szp_block_size)
{
#ifndef HL_OMIT_PARAM_CHECKS
    if( (adsp_element == NULL) || (adsp_memory == NULL) ) {
        return ied_encry_null_pointer;
    }

    if( szp_block_size == 0 ) {
        return ied_encry_invalid_input;
    }
#endif
    adsp_element->adsc_next = NULL;
    adsp_element->achc_base = (char*)adsp_memory->amc_malloc(adsp_memory, szp_block_size);

    if(adsp_element->achc_base == NULL) {
        return ied_encry_alloc_failure;
    }
    adsp_element->achc_current = adsp_element->achc_base;
    adsp_element->achc_max_used = adsp_element->achc_base;
    adsp_element->achc_end = adsp_element->achc_base + szp_block_size;

    return ied_encry_success;
} // m_mem_pool_init_ele


extern "C" dsd_mem_pool_frame m_mem_pool_get_frame(const struct dsd_mem_pool_ele* adsp_pool)
{
#ifndef HL_OMIT_PARAM_CHECKS
    if(adsp_pool == NULL) {
        dsd_mem_pool_frame dsl_frame = {
            NULL, NULL
        };
        return dsl_frame;
    }
#endif
    dsd_mem_pool_frame dsl_frame = {
        (dsd_mem_pool_ele*)adsp_pool, adsp_pool->achc_current
    };
    return dsl_frame;
}

extern "C" ied_encry_return m_mem_pool_restore_frame(struct dsd_mem_pool_ele** aadsp_pool,
                                                     struct dsd_mem_pool_frame dsp_frame)
{
#ifndef HL_OMIT_PARAM_CHECKS
    if((dsp_frame.adsc_target == NULL) || (dsp_frame.achc_cur_mem == NULL)) {
        return ied_encry_invalid_input;
    }
    if( aadsp_pool == NULL) {
        return ied_encry_null_pointer;
    }
#endif
    dsd_mem_pool_ele* adsl_current = dsp_frame.adsc_target;
    adsl_current->achc_current = dsp_frame.achc_cur_mem;
    adsl_current = adsl_current->adsc_next;

    // iterate over the following elements to reset the used ones
    // Assume, that no used element can follow an unused one
    while((adsl_current != NULL) &&
          (adsl_current->achc_base != adsl_current->achc_current))
    {
        adsl_current->achc_current = adsl_current->achc_base;
        adsl_current = adsl_current->adsc_next;
    }

    *aadsp_pool = dsp_frame.adsc_target;
    return ied_encry_success;
} // m_mem_pool_restore_frame

extern "C" void m_mem_pool_free(struct dsd_memory* adsp_memory,
                                struct dsd_mem_pool_ele* adsp_pool)
{
#ifndef HL_OMIT_PARAM_CHECKS
    if( adsp_memory == NULL ) {
        return;
    }
#endif
    while( adsp_pool != NULL ) {
        dsd_mem_pool_ele* adsl_next = adsp_pool->adsc_next;
        adsp_memory->amc_free(adsp_memory, adsp_pool->achc_base);
        adsp_memory->amc_free(adsp_memory, adsp_pool);
        adsp_pool = adsl_next;
    }
} // m_mem_pool_free

//----------------------------------------------------------------------
// Secure memory functions
//----------------------------------------------------------------------

#ifdef _WIN32
void m_sec_memzero(void* avop_memory,
                   size_t szp_len)
{
    SecureZeroMemory(avop_memory, szp_len);
}
#else
HL_OPTIMIZE_OFF
void m_sec_memzero(void* avop_memory,
                   size_t szp_len)
{
    // Causes false warnings in string.h on GCC 4.x
    // See https://gcc.gnu.org/bugzilla/show_bug.cgi?id=51744
    memset(avop_memory, 0, szp_len);
}
HL_OPTIMIZE_ON
#endif

HL_OPTIMIZE_OFF
int m_sec_memcmp(const void* avop_mem_1,
                   const void* avop_mem_2,
                   size_t szp_len)
{
    unsigned long long ull_result = 0;
    const unsigned char* abyl_mem_1 = (unsigned char*)avop_mem_1;
    const unsigned char* abyl_mem_2 = (unsigned char*)avop_mem_2;

    // First work on 64 bit words as much as possible
    while(szp_len > 8) {
        szp_len-=8;
        ull_result |= ((const unsigned long long*)(abyl_mem_1+szp_len))[0] ^
                      ((const unsigned long long*)(abyl_mem_2+szp_len))[0];
    }

    // Finish using bytes
    while(szp_len > 0) {
        szp_len--;
        ull_result |= abyl_mem_1[szp_len] ^ abyl_mem_2[szp_len];
    }

    // this makes the low 32 bit contain all needed information
    ull_result |= ull_result >> 32;

    return (int) ull_result;
} // m_sec_memcmp
HL_OPTIMIZE_ON

//------------------------------------------------------------------------------
// Start of original file ./xs-md5.cpp
//------------------------------------------------------------------------------

#include <stdlib.h>
#include <string.h>

#ifdef _WIN32
#include <Windows.h>
#else
#include "hob-unix01.h"
#ifndef HL_UNIX
#define HL_UNIX
#if (defined __APPLE__) && (defined __MACH__)
#define HL_LINUX
#define HL_MACOS
#endif
#endif // !HL_UNIX
#endif

#include "hob-xslhcla1.hpp"
#include "hob-encry-2.h"
#include "hob-encry-intern-2.h"

#define char2longcx(c,l,n,i) \
    { \
        l = 0; \
        switch (n) \
        { \
        case 0: l = (unsigned int)(((unsigned short) c[i+3] & 0xFF)<< 8) << 16; \
        case 3: l|= ((unsigned int) ((unsigned short) c[i+2] & 0xFF)<< 16); \
        case 2: l|= ((unsigned int)(((unsigned short) c[i+1] & 0xFF)<< 8) & 0xFFFF); \
        case 1: l|= ((unsigned int) ((unsigned short) c[i  ] & 0xFF)      & 0xFFFF); \
        } \
        if(n == 0) { i += 4; } \
        else{ i += n; } \
    }

/*--------------------------------------------------------------*/
/* Rotation functions (32 Bit)					                */
/*--------------------------------------------------------------*/
//
// unspecific rotates.
// NOTE: n must not be 32 !!!
// ----
//
#if defined _WIN32
#define LROTATE(a,n)     _lrotl(a,n)
#define RROTATE(a,n)     _lrotr(a,n)
#else
#define LROTATE(a,n)      (((a) << (n)) | \
                           ((((a) >> (32-(n)))) & (0x7FFFFFFF >>(31-n))))
#define RROTATE(a,n)     ((((a) >> (n)) & (0x7FFFFFFF >> (n-1))) | \
                          (((a) << (32-(n))))
#endif

/*--------------------------------------------------------------*/
/* long long Addition (32/32 Bit + 32 Bit)				*/
/*--------------------------------------------------------------*/
#define ADD_64(SumMsw, SumLsw, Summand) \
    if((unsigned int) SumLsw > \
       ((unsigned int) SumLsw + (unsigned int) Summand)) { SumMsw++; } \
    SumLsw += Summand;

#define MD5_CBLOCK  (512 / 8)   // Blocklength in bytes (64)
#define MD5_LBLOCK  16          // Blocklength in longs (16)
#define MD5_LAST_BLOCK  (448 / 8)   // Last Block length in bytes (56)

#define MD5_A       (MD5_LBLOCK)    // Array offset n
#define MD5_B       (MD5_LBLOCK+1)  // Array offset n+1
#define MD5_C       (MD5_LBLOCK+2)  // Array offset n+2
#define MD5_D       (MD5_LBLOCK+3)  // Array offset n+3
#define MD5_LenL    (MD5_LBLOCK+4)  // Array offset n+4
#define MD5_LenH    (MD5_LBLOCK+5)  // Array offset n+5
#define MD5_DatInd  (MD5_LBLOCK+6)  // Array offset n+6
#define MD5_DatCnt  (MD5_LBLOCK+7)  // Array offset n+7

#define F_MD5(X,Y,Z)    ((((Y) ^ (Z)) & (X)) ^ (Z))
#define G_MD5(X,Y,Z)    ((((X) ^ (Y)) & (Z)) ^ (Y))
#define H_MD5(X,Y,Z)    ((X) ^ (Y) ^ (Z))
#define I_MD5(X,Y,Z)    (((X) | (~(Z))) ^ (Y))

#define R1_MD5(a,b,c,d,k,s,t) { \
        a += ((k)+(t)+F_MD5((b),(c),(d))); \
        a =LROTATE(a,s); \
        a += (b); }; \

#define R2_MD5(a,b,c,d,k,s,t) { \
        a+=((k)+(t)+G_MD5((b),(c),(d))); \
        a =LROTATE(a,s); \
        a+=b; };

#define R3_MD5(a,b,c,d,k,s,t) { \
        a+=((k)+(t)+H_MD5((b),(c),(d))); \
        a =LROTATE(a,s); \
        a+=b; };

#define R4_MD5(a,b,c,d,k,s,t) { \
        a+=((k)+(t)+I_MD5((b),(c),(d))); \
        a =LROTATE(a,s); \
        a+=b; };

static const unsigned int unsc_init_A_md5 = 0x67452301;
static const unsigned int unsc_init_B_md5 = 0xefcdab89;
static const unsigned int unsc_init_C_md5 = 0x98badcfe;
static const unsigned int unsc_init_D_md5 = 0x10325476;

/* Implemented from RFC1321: MD5 Message-Digest Algorithm	*/
/* Note: All Long values are treated as beeing stored in    */
/* ----- BIG ENDIAN Format according to RFC1321			*/

/**
 * Processes one complete, saved MD5 datablock and update the state array (ms_md_5_block_service).
 *
 * @param aunp_array MD5 state array
 */
static void ms_md_5_block_service(unsigned int* aunp_array)
{
    unsigned int unl_A, unl_B, unl_C, unl_D;
    /*--------------------------------------------------------------------*/
    /* Get saved 'Register values'					                      */
    /*--------------------------------------------------------------------*/
    unl_A = aunp_array[MD5_A];
    unl_B = aunp_array[MD5_B];
    unl_C = aunp_array[MD5_C];
    unl_D = aunp_array[MD5_D];
    /*--------------------------------------------------------------------*/
    /* Process round 1							                          */
    /*--------------------------------------------------------------------*/
    R1_MD5(unl_A,unl_B,unl_C,unl_D,aunp_array[ 0], 7, 0xd76aa478);
    R1_MD5(unl_D,unl_A,unl_B,unl_C,aunp_array[ 1],12, 0xe8c7b756);
    R1_MD5(unl_C,unl_D,unl_A,unl_B,aunp_array[ 2],17, 0x242070db);
    R1_MD5(unl_B,unl_C,unl_D,unl_A,aunp_array[ 3],22, 0xc1bdceee);
    R1_MD5(unl_A,unl_B,unl_C,unl_D,aunp_array[ 4], 7, 0xf57c0faf);
    R1_MD5(unl_D,unl_A,unl_B,unl_C,aunp_array[ 5],12, 0x4787c62a);
    R1_MD5(unl_C,unl_D,unl_A,unl_B,aunp_array[ 6],17, 0xa8304613);
    R1_MD5(unl_B,unl_C,unl_D,unl_A,aunp_array[ 7],22, 0xfd469501);
    R1_MD5(unl_A,unl_B,unl_C,unl_D,aunp_array[ 8], 7, 0x698098d8);
    R1_MD5(unl_D,unl_A,unl_B,unl_C,aunp_array[ 9],12, 0x8b44f7af);
    R1_MD5(unl_C,unl_D,unl_A,unl_B,aunp_array[10],17, 0xffff5bb1);
    R1_MD5(unl_B,unl_C,unl_D,unl_A,aunp_array[11],22, 0x895cd7be);
    R1_MD5(unl_A,unl_B,unl_C,unl_D,aunp_array[12], 7, 0x6b901122);
    R1_MD5(unl_D,unl_A,unl_B,unl_C,aunp_array[13],12, 0xfd987193);
    R1_MD5(unl_C,unl_D,unl_A,unl_B,aunp_array[14],17, 0xa679438e);
    R1_MD5(unl_B,unl_C,unl_D,unl_A,aunp_array[15],22, 0x49b40821);
    /*--------------------------------------------------------------------*/
    /* Process round 2							                          */
    /*--------------------------------------------------------------------*/
    R2_MD5(unl_A,unl_B,unl_C,unl_D,aunp_array[ 1], 5, 0xf61e2562);
    R2_MD5(unl_D,unl_A,unl_B,unl_C,aunp_array[ 6], 9, 0xc040b340);
    R2_MD5(unl_C,unl_D,unl_A,unl_B,aunp_array[11],14, 0x265e5a51);
    R2_MD5(unl_B,unl_C,unl_D,unl_A,aunp_array[ 0],20, 0xe9b6c7aa);
    R2_MD5(unl_A,unl_B,unl_C,unl_D,aunp_array[ 5], 5, 0xd62f105d);
    R2_MD5(unl_D,unl_A,unl_B,unl_C,aunp_array[10], 9, 0x02441453);
    R2_MD5(unl_C,unl_D,unl_A,unl_B,aunp_array[15],14, 0xd8a1e681);
    R2_MD5(unl_B,unl_C,unl_D,unl_A,aunp_array[ 4],20, 0xe7d3fbc8);
    R2_MD5(unl_A,unl_B,unl_C,unl_D,aunp_array[ 9], 5, 0x21e1cde6);
    R2_MD5(unl_D,unl_A,unl_B,unl_C,aunp_array[14], 9, 0xc33707d6);
    R2_MD5(unl_C,unl_D,unl_A,unl_B,aunp_array[ 3],14, 0xf4d50d87);
    R2_MD5(unl_B,unl_C,unl_D,unl_A,aunp_array[ 8],20, 0x455a14ed);
    R2_MD5(unl_A,unl_B,unl_C,unl_D,aunp_array[13], 5, 0xa9e3e905);
    R2_MD5(unl_D,unl_A,unl_B,unl_C,aunp_array[ 2], 9, 0xfcefa3f8);
    R2_MD5(unl_C,unl_D,unl_A,unl_B,aunp_array[ 7],14, 0x676f02d9);
    R2_MD5(unl_B,unl_C,unl_D,unl_A,aunp_array[12],20, 0x8d2a4c8a);
    /*--------------------------------------------------------------------*/
    /* Process round 3							                          */
    /*--------------------------------------------------------------------*/
    R3_MD5(unl_A,unl_B,unl_C,unl_D,aunp_array[ 5], 4, 0xfffa3942);
    R3_MD5(unl_D,unl_A,unl_B,unl_C,aunp_array[ 8],11, 0x8771f681);
    R3_MD5(unl_C,unl_D,unl_A,unl_B,aunp_array[11],16, 0x6d9d6122);
    R3_MD5(unl_B,unl_C,unl_D,unl_A,aunp_array[14],23, 0xfde5380c);
    R3_MD5(unl_A,unl_B,unl_C,unl_D,aunp_array[ 1], 4, 0xa4beea44);
    R3_MD5(unl_D,unl_A,unl_B,unl_C,aunp_array[ 4],11, 0x4bdecfa9);
    R3_MD5(unl_C,unl_D,unl_A,unl_B,aunp_array[ 7],16, 0xf6bb4b60);
    R3_MD5(unl_B,unl_C,unl_D,unl_A,aunp_array[10],23, 0xbebfbc70);
    R3_MD5(unl_A,unl_B,unl_C,unl_D,aunp_array[13], 4, 0x289b7ec6);
    R3_MD5(unl_D,unl_A,unl_B,unl_C,aunp_array[ 0],11, 0xeaa127fa);
    R3_MD5(unl_C,unl_D,unl_A,unl_B,aunp_array[ 3],16, 0xd4ef3085);
    R3_MD5(unl_B,unl_C,unl_D,unl_A,aunp_array[ 6],23, 0x04881d05);
    R3_MD5(unl_A,unl_B,unl_C,unl_D,aunp_array[ 9], 4, 0xd9d4d039);
    R3_MD5(unl_D,unl_A,unl_B,unl_C,aunp_array[12],11, 0xe6db99e5);
    R3_MD5(unl_C,unl_D,unl_A,unl_B,aunp_array[15],16, 0x1fa27cf8);
    R3_MD5(unl_B,unl_C,unl_D,unl_A,aunp_array[ 2],23, 0xc4ac5665);
    /*--------------------------------------------------------------------*/
    /* Process round 4							                          */
    /*--------------------------------------------------------------------*/
    R4_MD5(unl_A,unl_B,unl_C,unl_D,aunp_array[ 0], 6, 0xf4292244);
    R4_MD5(unl_D,unl_A,unl_B,unl_C,aunp_array[ 7],10, 0x432aff97);
    R4_MD5(unl_C,unl_D,unl_A,unl_B,aunp_array[14],15, 0xab9423a7);
    R4_MD5(unl_B,unl_C,unl_D,unl_A,aunp_array[ 5],21, 0xfc93a039);
    R4_MD5(unl_A,unl_B,unl_C,unl_D,aunp_array[12], 6, 0x655b59c3);
    R4_MD5(unl_D,unl_A,unl_B,unl_C,aunp_array[ 3],10, 0x8f0ccc92);
    R4_MD5(unl_C,unl_D,unl_A,unl_B,aunp_array[10],15, 0xffeff47d);
    R4_MD5(unl_B,unl_C,unl_D,unl_A,aunp_array[ 1],21, 0x85845dd1);
    R4_MD5(unl_A,unl_B,unl_C,unl_D,aunp_array[ 8], 6, 0x6fa87e4f);
    R4_MD5(unl_D,unl_A,unl_B,unl_C,aunp_array[15],10, 0xfe2ce6e0);
    R4_MD5(unl_C,unl_D,unl_A,unl_B,aunp_array[ 6],15, 0xa3014314);
    R4_MD5(unl_B,unl_C,unl_D,unl_A,aunp_array[13],21, 0x4e0811a1);
    R4_MD5(unl_A,unl_B,unl_C,unl_D,aunp_array[ 4], 6, 0xf7537e82);
    R4_MD5(unl_D,unl_A,unl_B,unl_C,aunp_array[11],10, 0xbd3af235);
    R4_MD5(unl_C,unl_D,unl_A,unl_B,aunp_array[ 2],15, 0x2ad7d2bb);
    R4_MD5(unl_B,unl_C,unl_D,unl_A,aunp_array[ 9],21, 0xeb86d391);
    /*--------------------------------------------------------------------*/
    /* Calculate effective new digest 'register' values			          */
    /*--------------------------------------------------------------------*/
    aunp_array[MD5_A] += unl_A;
    aunp_array[MD5_B] += unl_B;
    aunp_array[MD5_C] += unl_C;
    aunp_array[MD5_D] += unl_D;
} // ms_md_5_block_service

// ------------------------------------------
// MD-5 Initialization
// ------------------------------------------

void m_md_5_init(void* avop_state)
{
    unsigned int *aunl_array = (unsigned int *)avop_state;
    aunl_array[MD5_A] = unsc_init_A_md5;            // initialize 'Register' values
    aunl_array[MD5_B] = unsc_init_B_md5;
    aunl_array[MD5_C] = unsc_init_C_md5;
    aunl_array[MD5_D] = unsc_init_D_md5;
    aunl_array[MD5_LenL] = 0;               // Total byte length low = 0
    aunl_array[MD5_LenH] = 0;               // dto. high = 0
    aunl_array[MD5_DatCnt] = 0;             // no data in block buffer
    aunl_array[MD5_DatInd] = 0;             // index
}

// ------------------------------------------
// MD-5 Update
// ------------------------------------------

void m_md_5_update(void* avop_state,
                   const unsigned char* abyp_input,
                   size_t szp_input_len)
{
    unsigned int *aunl_array = (unsigned int *)avop_state;
    unsigned int unl_i, unl_j;
    unsigned int unl_n_index, unl_nl_cnt, unl_nc_cnt, unl_n_char_index;
    unsigned int unl_l, unl_l1, unl_n_fill, unl_n_copy;

    if (szp_input_len == 0) {
        return;
    }
    /*------------------------------------------------------------*/
    /* Add up byte length to get new total byte length		      */
    /*------------------------------------------------------------*/

    unl_l1 = (unsigned int) (szp_input_len << 3);                       // get the BIT-Count
    ADD_64(aunl_array[MD5_LenH],aunl_array[MD5_LenL],unl_l1);           // sum up
    /*------------------------------------------------------------*/
    /* get bufferpointers and indices				              */
    /*------------------------------------------------------------*/
    unl_n_char_index = 0;
    /*------------------------------------------------------------*/
    /* process input data using block buffer			          */
    /*------------------------------------------------------------*/
    do {
        /*----------------------------------------------------------*/
        /* Fill Block buffer if possible				            */
        /*----------------------------------------------------------*/
        unl_n_index = aunl_array[MD5_DatInd];                           // get current Field index
        /*----------------------------------------------------------*/
        /* copy data to blockbuffer until filled or data exhausted	*/
        /*----------------------------------------------------------*/
        unl_j = aunl_array[MD5_DatCnt] & 0x03;                          // get fill boundary
        if (unl_j != 0) {                                               // not on a long boundary
            /*--------------------------------------------------------*/
            /* must fill up last long value from new data		      */
            /*--------------------------------------------------------*/
            unl_i = (4-unl_j) & 0x03;                                   // get fill byte count
            if ( unl_i > szp_input_len) {
                unl_i = (unsigned int)szp_input_len;                    // check for data end
            }
            aunl_array[MD5_DatCnt] += unl_i;                            // new Byte count
            szp_input_len -= unl_i;                                     // reduce data count
            char2longcx(abyp_input,unl_l1,unl_i,unl_n_char_index)       // convert bytes to long
            aunl_array[unl_n_index] |= (unl_l1 << (unl_j * 8));         // save new long
            if ((aunl_array[MD5_DatCnt] & 0x03) == 0) {                 // check if long filled
                unl_n_index++;                                          // increment index
                aunl_array[MD5_DatInd]++;                               // dto.
            }
            if (szp_input_len == 0) {
                /*------------------------------------------------------*/
                /* Data exhausted, check if last byte has been filled	*/
                /*------------------------------------------------------*/
                if(unl_n_index < MD5_LBLOCK) {
                    return;                                             // data exhausted, not filled
                }
                aunl_array[MD5_DatInd] = 0;                             // buffer filled !
                aunl_array[MD5_DatCnt] = 0;
                /*-------------------------------------------------------*/
                /* process blockbuffer to generate new portion of digest */
                /*-------------------------------------------------------*/
                ms_md_5_block_service(aunl_array);                      // generate digest portion
                return;
            }
        }
        /*----------------------------------------------------------*/
        /* caclulate remaining elements to fill			            */
        /*----------------------------------------------------------*/
        unl_n_fill = MD5_CBLOCK - aunl_array[MD5_DatCnt];               // number of bytes required
        unl_n_copy = unl_n_fill;                                        // preset bytes to copy
        if (unl_n_fill > szp_input_len) {
            unl_n_copy = (unsigned int) szp_input_len;                  // reduce copy count
        }
        unl_nl_cnt = unl_n_copy /4;                                     // get long elements count
        unl_nc_cnt = unl_n_copy & 0x03;                                 // get remaining bytes
        for (unl_i=unl_nl_cnt; unl_i>0; unl_i--) {                        // long elements copy loop
            ms_read_little_endian(unl_l, abyp_input + unl_n_char_index); // get long
            unl_n_char_index += 4;
            aunl_array[unl_n_index] = unl_l;                            // byte order dep. copy
            unl_n_index++;
        }
        if (unl_nc_cnt != 0) {
            char2longcx(abyp_input,unl_l1,unl_nc_cnt,unl_n_char_index)  // byte order dependent copy
            aunl_array[unl_n_index] = unl_l1;
        }
        if(unl_n_copy < unl_n_fill) {                                   // not enough data, exit
            aunl_array[MD5_DatInd] = unl_n_index &  0xFFFF;             // save index
            aunl_array[MD5_DatCnt] += unl_n_copy;                       // save byte count
            return;
        }
        unl_n_index = 0;                                                // Buffer is now filled ...
        aunl_array[MD5_DatInd] = 0;
        aunl_array[MD5_DatCnt] = 0;
        /*----------------------------------------------------------*/
        /* process blockbuffer to generate new portion of digest	*/
        /*----------------------------------------------------------*/
        ms_md_5_block_service(aunl_array);                              // generate digest portion
        szp_input_len -= unl_n_fill;                                    // reduce remaining data count
    } while (szp_input_len != 0);
} // m_md_5_update

void m_md_5_gather_update(void* avop_state,
                          struct dsd_gather_i_1* adsp_input,
                          size_t szp_input_len)
{
    while ((szp_input_len > 0) && !(adsp_input == NULL)) {
        size_t szl_elm_len = adsp_input->achc_ginp_end - adsp_input->achc_ginp_cur;
        if (szl_elm_len > szp_input_len) {
            szl_elm_len = szp_input_len;
        }
        m_md_5_update(avop_state, (const unsigned char *)adsp_input->achc_ginp_cur, szl_elm_len);
        szp_input_len -= szl_elm_len;
        adsp_input = adsp_input->adsc_next;
    }
}

void m_md_5_final(void* avop_state,
                  unsigned char* abyp_digest)
{
    unsigned int* aunl_array = (unsigned int *)avop_state;
    unsigned int unl_i, unl_n_padding;
    unsigned int unl_n_index=aunl_array[MD5_DatInd];
    /*----------------------------------------------------*/
    /* pad with 1st Element				                  */
    /*----------------------------------------------------*/
    unl_i =  aunl_array[MD5_DatCnt] & 0x03;                             // get start byte pos.
    if (unl_i != 0) {
        aunl_array[unl_n_index] |=  (0x80 << (unl_i * 8));              // append 1st pad. value
    } else {
        aunl_array[unl_n_index] = 0x80;                                 // dto.
    }
    unl_n_index++;
    /*----------------------------------------------------*/
    /* calculate remaining padding length			      */
    /*----------------------------------------------------*/
    if (MD5_LAST_BLOCK <= aunl_array[MD5_DatCnt]) {                     // last block too large
        unl_n_padding = MD5_CBLOCK - aunl_array[MD5_DatCnt];            // true size to pad
        unl_n_padding -= (4-unl_i);                                     // reduce padding length
        for (unl_i=unl_n_padding/4; unl_i != 0; unl_i--) {                // clear rest
            aunl_array[unl_n_index] = 0;
            unl_n_index++;
        }
        ms_md_5_block_service(aunl_array);                              // generate digest portion
        unl_n_index = 0;                                                // set buffer bottom
        unl_n_padding = MD5_LAST_BLOCK;                                 // set remaining padding count
    } else {                                                            // enough space in last
        unl_n_padding = MD5_LAST_BLOCK - aunl_array[MD5_DatCnt];        // req. padding len
        unl_n_padding -= (4 - unl_i);                                   // reduce padding length
    }
    /*----------------------------------------------------*/
    /* pad rest with zeroes, process block		          */
    /*----------------------------------------------------*/
    for (unl_i = unl_n_padding / 4; unl_i > 0; unl_i--) {               // clear rest of buffer
        aunl_array[unl_n_index] = 0;
        unl_n_index++;
    }
    aunl_array[unl_n_index] = aunl_array[MD5_LenL];                     // append length low
    aunl_array[unl_n_index + 1] = aunl_array[MD5_LenH];                 // append length high
    ms_md_5_block_service(aunl_array);                                  // generate digest
    /*----------------------------------------------------*/
    /* store message digest				                  */
    /*----------------------------------------------------*/
    ms_write_little_endian(abyp_digest, aunl_array[MD5_A]);             // get 1st part
    ms_write_little_endian(abyp_digest + 4, aunl_array[MD5_B]);         // get 2nd part
    ms_write_little_endian(abyp_digest + 8, aunl_array[MD5_C]);         // get 3rd part
    ms_write_little_endian(abyp_digest + 12, aunl_array[MD5_D]);        // get 4th part

    m_sec_memzero(avop_state, cind_state_size_md_5);
} // m_md_5_final

//------------------------------------------------------------------------------
// Start of original file ./xs-lnum-ec-1.cpp
//------------------------------------------------------------------------------

#include <stdlib.h>
#include <string.h>

#ifdef _WIN32
#include <Windows.h>
#else
#include "hob-unix01.h"
#ifndef HL_UNIX
#define HL_UNIX

#if (defined __APPLE__) && (defined __MACH__)
#define HL_LINUX
#define HL_MACOS
#endif

#endif // !HL_UNIX

#endif

#include "hob-xslhcla1.hpp"

#include "hob-encry-2.h"
#include "hob-encry-intern-2.h"

#ifndef _WIN32
#include <limits.h>
#include <stdint.h>
#endif

#ifdef HL_LNUM_64_BIT
static LNUM_WORD urrs_P192_p[4] = { 0xffffffffffffffff, 0xfffffffffffffffe, 0xffffffffffffffff, 0x0 };
static struct dsd_lnum dss_P192_p = {(unsigned char*)urrs_P192_p, 4 * sizeof(LNUM_WORD), 3 * sizeof(LNUM_WORD), FALSE};

static LNUM_WORD urrs_P192_a[4] = { 0xfffffffffffffffc, 0xfffffffffffffffe, 0xffffffffffffffff, 0x0 };
static struct dsd_lnum dss_P192_a = {(unsigned char*)urrs_P192_a, 4 * sizeof(LNUM_WORD), 3 * sizeof(LNUM_WORD), FALSE};

static LNUM_WORD urrs_P192_b[4] = { 0xfeb8deecc146b9b1, 0x0fa7e9ab72243049, 0x64210519e59c80e7, 0x0 };
static struct dsd_lnum dss_P192_b = {(unsigned char*)urrs_P192_b, 4 * sizeof(LNUM_WORD), 3 * sizeof(LNUM_WORD), FALSE};

static LNUM_WORD urrs_P192_Gx[4] = { 0xf4ff0afd82ff1012, 0x7cbf20eb43a18800, 0x188da80eb03090f6, 0x0 };
static struct dsd_lnum dss_P192_Gx = {(unsigned char*)urrs_P192_Gx, 4 * sizeof(LNUM_WORD), 3 * sizeof(LNUM_WORD), FALSE};

static LNUM_WORD urrs_P192_Gy[4] = { 0x73f977a11e794811, 0x631011ed6b24cdd5, 0x07192b95ffc8da78, 0x0 };
static struct dsd_lnum dss_P192_Gy = {(unsigned char*)urrs_P192_Gy, 4 * sizeof(LNUM_WORD), 3 * sizeof(LNUM_WORD), FALSE};

static LNUM_WORD urrs_P192_n[4] = { 0x146bc9b1b4d22831, 0xffffffff99def836, 0xffffffffffffffff, 0x0 };
static struct dsd_lnum dss_P192_n = {(unsigned char*)urrs_P192_n, 4 * sizeof(LNUM_WORD), 3 * sizeof(LNUM_WORD), FALSE};


static LNUM_WORD urrs_P224_p[4] = { 0x0000000000000001, 0xffffffff00000000, 0xffffffffffffffff, 0xffffffff };
static struct dsd_lnum dss_P224_p = {(unsigned char*)urrs_P224_p, 4 * sizeof(LNUM_WORD), 4 * sizeof(LNUM_WORD), FALSE};

static LNUM_WORD urrs_P224_a[4] = { 0xfffffffffffffffe, 0xfffffffeffffffff, 0xffffffffffffffff, 0xffffffff };
static struct dsd_lnum dss_P224_a = {(unsigned char*)urrs_P224_a, 4 * sizeof(LNUM_WORD), 4 * sizeof(LNUM_WORD), FALSE};

static LNUM_WORD urrs_P224_b[4] = { 0x270b39432355ffb4, 0x5044b0b7d7bfd8ba, 0x0c04b3abf5413256, 0xb4050a85 };
static struct dsd_lnum dss_P224_b = {(unsigned char*)urrs_P224_b, 4 * sizeof(LNUM_WORD), 4 * sizeof(LNUM_WORD), FALSE};

static LNUM_WORD urrs_P224_Gx[4] = { 0x343280d6115c1d21, 0x4a03c1d356c21122, 0x6bb4bf7f321390b9, 0xb70e0cbd };
static struct dsd_lnum dss_P224_Gx = {(unsigned char*)urrs_P224_Gx, 4 * sizeof(LNUM_WORD), 4 * sizeof(LNUM_WORD), FALSE};

static LNUM_WORD urrs_P224_Gy[4] = { 0x44d5819985007e34, 0xcd4375a05a074764, 0xb5f723fb4c22dfe6, 0xbd376388 };
static struct dsd_lnum dss_P224_Gy = {(unsigned char*)urrs_P224_Gy, 4 * sizeof(LNUM_WORD), 4 * sizeof(LNUM_WORD), FALSE};

static LNUM_WORD urrs_P224_n[4] = { 0x13dd29455c5c2a3d, 0xffff16a2e0b8f03e, 0xffffffffffffffff, 0xffffffff };
static struct dsd_lnum dss_P224_n = {(unsigned char*)urrs_P224_n, 4 * sizeof(LNUM_WORD), 4 * sizeof(LNUM_WORD), FALSE};


static LNUM_WORD urrs_P256_p[4] = { 0xffffffffffffffff, 0x00000000ffffffff, 0x0000000000000000, 0xffffffff00000001 };
static struct dsd_lnum dss_P256_p = {(unsigned char*)urrs_P256_p, 4 * sizeof(LNUM_WORD), 4 * sizeof(LNUM_WORD), FALSE};

static LNUM_WORD urrs_P256_a[4] = { 0xfffffffffffffffc, 0x00000000ffffffff, 0x0000000000000000, 0xffffffff00000001 };
static struct dsd_lnum dss_P256_a = {(unsigned char*)urrs_P256_a, 4 * sizeof(LNUM_WORD), 4 * sizeof(LNUM_WORD), FALSE};

static LNUM_WORD urrs_P256_b[4] = { 0x3bce3c3e27d2604b, 0x651d06b0cc53b0f6, 0xb3ebbd55769886bc, 0x5ac635d8aa3a93e7 };
static struct dsd_lnum dss_P256_b = {(unsigned char*)urrs_P256_b, 4 * sizeof(LNUM_WORD), 4 * sizeof(LNUM_WORD), FALSE};

static LNUM_WORD urrs_P256_Gx[4] = { 0xf4a13945d898c296, 0x77037d812deb33a0, 0xf8bce6e563a440f2, 0x6b17d1f2e12c4247 };
static struct dsd_lnum dss_P256_Gx = {(unsigned char*)urrs_P256_Gx, 4 * sizeof(LNUM_WORD), 4 * sizeof(LNUM_WORD), FALSE};

static LNUM_WORD urrs_P256_Gy[4] = { 0xcbb6406837bf51f5, 0x2bce33576b315ece, 0x8ee7eb4a7c0f9e16, 0x4fe342e2fe1a7f9b };
static struct dsd_lnum dss_P256_Gy = {(unsigned char*)urrs_P256_Gy, 4 * sizeof(LNUM_WORD), 4 * sizeof(LNUM_WORD), FALSE};

static LNUM_WORD urrs_P256_n[4] = { 0xf3b9cac2fc632551, 0xbce6faada7179e84, 0xffffffffffffffff, 0xffffffff00000000 };
static struct dsd_lnum dss_P256_n = {(unsigned char*)urrs_P256_n, 4 * sizeof(LNUM_WORD), 4 * sizeof(LNUM_WORD), FALSE};


static LNUM_WORD urrs_P384_p[6] = { 0x00000000ffffffff, 0xffffffff00000000, 0xfffffffffffffffe, 0xffffffffffffffff, 0xffffffffffffffff, 0xffffffffffffffff };
static struct dsd_lnum dss_P384_p = {(unsigned char*)urrs_P384_p, 6 * sizeof(LNUM_WORD), 6 * sizeof(LNUM_WORD), FALSE};

static LNUM_WORD urrs_P384_a[6] = { 0x00000000fffffffc, 0xffffffff00000000, 0xfffffffffffffffe, 0xffffffffffffffff, 0xffffffffffffffff, 0xffffffffffffffff };
static struct dsd_lnum dss_P384_a = {(unsigned char*)urrs_P384_a, 6 * sizeof(LNUM_WORD), 6 * sizeof(LNUM_WORD), FALSE};

static LNUM_WORD urrs_P384_b[6] = { 0x2a85c8edd3ec2aef, 0xc656398d8a2ed19d, 0x0314088f5013875a, 0x181d9c6efe814112, 0x988e056be3f82d19, 0xb3312fa7e23ee7e4 };
static struct dsd_lnum dss_P384_b = {(unsigned char*)urrs_P384_b, 6 * sizeof(LNUM_WORD), 6 * sizeof(LNUM_WORD), FALSE};

static LNUM_WORD urrs_P384_Gx[6] = { 0x3a545e3872760ab7, 0x5502f25dbf55296c, 0x59f741e082542a38, 0x6e1d3b628ba79b98, 0x8eb1c71ef320ad74, 0xaa87ca22be8b0537 };
static struct dsd_lnum dss_P384_Gx = {(unsigned char*)urrs_P384_Gx, 6 * sizeof(LNUM_WORD), 6 * sizeof(LNUM_WORD), FALSE};

static LNUM_WORD urrs_P384_Gy[6] = { 0x7a431d7c90ea0e5f, 0x0a60b1ce1d7e819d, 0xe9da3113b5f0b8c0, 0xf8f41dbd289a147c, 0x5d9e98bf9292dc29, 0x3617de4a96262c6f };
static struct dsd_lnum dss_P384_Gy = {(unsigned char*)urrs_P384_Gy, 6 * sizeof(LNUM_WORD), 6 * sizeof(LNUM_WORD), FALSE};

static LNUM_WORD urrs_P384_n[6] = { 0xecec196accc52973, 0x581a0db248b0a77a, 0xc7634d81f4372ddf, 0xffffffffffffffff, 0xffffffffffffffff, 0xffffffffffffffff };
static struct dsd_lnum dss_P384_n = {(unsigned char*)urrs_P384_n, 6 * sizeof(LNUM_WORD), 6 * sizeof(LNUM_WORD), FALSE};


static LNUM_WORD urrs_P521_p[10] = { 0xffffffffffffffff, 0xffffffffffffffff, 0xffffffffffffffff, 0xffffffffffffffff, 0xffffffffffffffff, 0xffffffffffffffff, 0xffffffffffffffff, 0xffffffffffffffff, 0x01ff, 0x0 };
static struct dsd_lnum dss_P521_p = {(unsigned char*)urrs_P521_p, 10 * sizeof(LNUM_WORD), 9 * sizeof(LNUM_WORD), FALSE};

static LNUM_WORD urrs_P521_a[10] = { 0xfffffffffffffffc, 0xffffffffffffffff, 0xffffffffffffffff, 0xffffffffffffffff, 0xffffffffffffffff, 0xffffffffffffffff, 0xffffffffffffffff, 0xffffffffffffffff, 0x01ff, 0x0 };
static struct dsd_lnum dss_P521_a = {(unsigned char*)urrs_P521_a, 10 * sizeof(LNUM_WORD), 9 * sizeof(LNUM_WORD), FALSE};

static LNUM_WORD urrs_P521_b[10] = { 0xef451fd46b503f00, 0x3573df883d2c34f1, 0x1652c0bd3bb1bf07, 0x56193951ec7e937b, 0xb8b489918ef109e1, 0xa2da725b99b315f3, 0x929a21a0b68540ee, 0x953eb9618e1c9a1f, 0x51, 0x0 };
static struct dsd_lnum dss_P521_b = {(unsigned char*)urrs_P521_b, 10 * sizeof(LNUM_WORD), 9 * sizeof(LNUM_WORD), FALSE};

static LNUM_WORD urrs_P521_Gx[10] = { 0xf97e7e31c2e5bd66, 0x3348b3c1856a429b, 0xfe1dc127a2ffa8de, 0xa14b5e77efe75928, 0xf828af606b4d3dba, 0x9c648139053fb521, 0x9e3ecb662395b442, 0x858e06b70404e9cd, 0xc6, 0x0 };
static struct dsd_lnum dss_P521_Gx = {(unsigned char*)urrs_P521_Gx, 10 * sizeof(LNUM_WORD), 9 * sizeof(LNUM_WORD), FALSE};

static LNUM_WORD urrs_P521_Gy[10] = { 0x88be94769fd16650, 0x353c7086a272c240, 0xc550b9013fad0761, 0x97ee72995ef42640, 0x17afbd17273e662c, 0x98f54449579b4468, 0x5c8a5fb42c7d1bd9, 0x39296a789a3bc004, 0x0118, 0x0 };
static struct dsd_lnum dss_P521_Gy = {(unsigned char*)urrs_P521_Gy, 10 * sizeof(LNUM_WORD), 9 * sizeof(LNUM_WORD), FALSE};

static LNUM_WORD urrs_P521_n[10] = { 0xbb6fb71e91386409, 0x3bb5c9b8899c47ae, 0x7fcc0148f709a5d0, 0x51868783bf2f966b, 0xfffffffffffffffa, 0xffffffffffffffff, 0xffffffffffffffff, 0xffffffffffffffff, 0x01ff, 0x0 };
static struct dsd_lnum dss_P521_n = {(unsigned char*)urrs_P521_n, 10 * sizeof(LNUM_WORD), 9 * sizeof(LNUM_WORD), FALSE};


static LNUM_WORD urrs_SECP192K1_p[4] = { 0xFFFFFFFEFFFFEE37, 0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF, 0x0 };
static struct dsd_lnum dss_SECP192K1_p = {(unsigned char*)urrs_SECP192K1_p, 4 * sizeof(LNUM_WORD), 3 * sizeof(LNUM_WORD), FALSE};

static LNUM_WORD urrs_SECP192K1_a[2] = { 0x00, 0x0 };
static struct dsd_lnum dss_SECP192K1_a = {(unsigned char*)urrs_SECP192K1_a, 2 * sizeof(LNUM_WORD), 1 * sizeof(LNUM_WORD), FALSE};

static LNUM_WORD urrs_SECP192K1_b[2] = { 0x03, 0x0 };
static struct dsd_lnum dss_SECP192K1_b = {(unsigned char*)urrs_SECP192K1_b, 2 * sizeof(LNUM_WORD), 1 * sizeof(LNUM_WORD), FALSE};

static LNUM_WORD urrs_SECP192K1_Gx[4] = { 0x1DA5D1B1EAE06C7D, 0x26B07D0280B7F434, 0xDB4FF10EC057E9AE, 0x0 };
static struct dsd_lnum dss_SECP192K1_Gx = {(unsigned char*)urrs_SECP192K1_Gx, 4 * sizeof(LNUM_WORD), 3 * sizeof(LNUM_WORD), FALSE};

static LNUM_WORD urrs_SECP192K1_Gy[4] = { 0x4082AA88D95E2F9D, 0x844163D015BE8634, 0x9B2F2F6D9C5628A7, 0x0 };
static struct dsd_lnum dss_SECP192K1_Gy = {(unsigned char*)urrs_SECP192K1_Gy, 4 * sizeof(LNUM_WORD), 3 * sizeof(LNUM_WORD), FALSE};

static LNUM_WORD urrs_SECP192K1_n[4] = { 0x0F69466A74DEFD8D, 0xFFFFFFFE26F2FC17, 0xFFFFFFFFFFFFFFFF, 0x0 };
static struct dsd_lnum dss_SECP192K1_n = {(unsigned char*)urrs_SECP192K1_n, 4 * sizeof(LNUM_WORD), 3 * sizeof(LNUM_WORD), FALSE};


static LNUM_WORD urrs_SECP224K1_p[4] = { 0xFFFFFFFEFFFFE56D, 0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF, 0xFFFFFFFF };
static struct dsd_lnum dss_SECP224K1_p = {(unsigned char*)urrs_SECP224K1_p, 4 * sizeof(LNUM_WORD), 4 * sizeof(LNUM_WORD), FALSE};

static LNUM_WORD urrs_SECP224K1_a[2] = { 0x00, 0x0 };
static struct dsd_lnum dss_SECP224K1_a = {(unsigned char*)urrs_SECP224K1_a, 2 * sizeof(LNUM_WORD), 1 * sizeof(LNUM_WORD), FALSE};

static LNUM_WORD urrs_SECP224K1_b[2] = { 0x05, 0x0 };
static struct dsd_lnum dss_SECP224K1_b = {(unsigned char*)urrs_SECP224K1_b, 2 * sizeof(LNUM_WORD), 1 * sizeof(LNUM_WORD), FALSE};

static LNUM_WORD urrs_SECP224K1_Gx[4] = { 0x0F7E650EB6B7A45C, 0x69A467E9E47075A9, 0x4DF099DF30FC28A1, 0xA1455B33 };
static struct dsd_lnum dss_SECP224K1_Gx = {(unsigned char*)urrs_SECP224K1_Gx, 4 * sizeof(LNUM_WORD), 4 * sizeof(LNUM_WORD), FALSE};

static LNUM_WORD urrs_SECP224K1_Gy[4] = { 0xE2CA4BDB556D61A5, 0xF7E319F7C0B0BD59, 0x7FBA344282CAFBD6, 0x7E089FED };
static struct dsd_lnum dss_SECP224K1_Gy = {(unsigned char*)urrs_SECP224K1_Gy, 4 * sizeof(LNUM_WORD), 4 * sizeof(LNUM_WORD), FALSE};

static LNUM_WORD urrs_SECP224K1_n[4] = { 0xCAF0A971769FB1F7, 0x0001DCE8D2EC6184, 0x0000000000000000, 0x0100000000 };
static struct dsd_lnum dss_SECP224K1_n = {(unsigned char*)urrs_SECP224K1_n, 4 * sizeof(LNUM_WORD), 4 * sizeof(LNUM_WORD), FALSE};


static LNUM_WORD urrs_SECP256K1_p[4] = { 0xFFFFFFFEFFFFFC2F, 0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF };
static struct dsd_lnum dss_SECP256K1_p = {(unsigned char*)urrs_SECP256K1_p, 4 * sizeof(LNUM_WORD), 4 * sizeof(LNUM_WORD), FALSE};

static LNUM_WORD urrs_SECP256K1_a[2] = { 0x00, 0x0 };
static struct dsd_lnum dss_SECP256K1_a = {(unsigned char*)urrs_SECP256K1_a, 2 * sizeof(LNUM_WORD), 1 * sizeof(LNUM_WORD), FALSE};

static LNUM_WORD urrs_SECP256K1_b[2] = { 0x07, 0x0 };
static struct dsd_lnum dss_SECP256K1_b = {(unsigned char*)urrs_SECP256K1_b, 2 * sizeof(LNUM_WORD), 1 * sizeof(LNUM_WORD), FALSE};

static LNUM_WORD urrs_SECP256K1_Gx[4] = { 0x59F2815B16F81798, 0x029BFCDB2DCE28D9, 0x55A06295CE870B07, 0x79BE667EF9DCBBAC };
static struct dsd_lnum dss_SECP256K1_Gx = {(unsigned char*)urrs_SECP256K1_Gx, 4 * sizeof(LNUM_WORD), 4 * sizeof(LNUM_WORD), FALSE};

static LNUM_WORD urrs_SECP256K1_Gy[4] = { 0x9C47D08FFB10D4B8, 0xFD17B448A6855419, 0x5DA4FBFC0E1108A8, 0x483ADA7726A3C465 };
static struct dsd_lnum dss_SECP256K1_Gy = {(unsigned char*)urrs_SECP256K1_Gy, 4 * sizeof(LNUM_WORD), 4 * sizeof(LNUM_WORD), FALSE};

static LNUM_WORD urrs_SECP256K1_n[4] = { 0xBFD25E8CD0364141, 0xBAAEDCE6AF48A03B, 0xFFFFFFFFFFFFFFFE, 0xFFFFFFFFFFFFFFFF };
static struct dsd_lnum dss_SECP256K1_n = {(unsigned char*)urrs_SECP256K1_n, 4 * sizeof(LNUM_WORD), 4 * sizeof(LNUM_WORD), FALSE};


static LNUM_WORD urrs_brainpoolP256r1_p[4] = { 0x2013481D1F6E5377, 0x6E3BF623D5262028, 0x3E660A909D838D72, 0xA9FB57DBA1EEA9BC };
static struct dsd_lnum dss_brainpoolP256r1_p = {(unsigned char*)urrs_brainpoolP256r1_p, 4 * sizeof(LNUM_WORD), 4 * sizeof(LNUM_WORD), FALSE};

static LNUM_WORD urrs_brainpoolP256r1_a[4] = { 0xE94A4B44F330B5D9, 0xFB8055C126DC5C6C, 0xEEF67530417AFFE7, 0x7D5A0975FC2C3057 };
static struct dsd_lnum dss_brainpoolP256r1_a = {(unsigned char*)urrs_brainpoolP256r1_a, 4 * sizeof(LNUM_WORD), 4 * sizeof(LNUM_WORD), FALSE};

static LNUM_WORD urrs_brainpoolP256r1_b[4] = { 0x6BCCDC18FF8C07B6, 0x958416295CF7E1CE, 0xF330B5D9BBD77CBF, 0x26DC5C6CE94A4B44 };
static struct dsd_lnum dss_brainpoolP256r1_b = {(unsigned char*)urrs_brainpoolP256r1_b, 4 * sizeof(LNUM_WORD), 4 * sizeof(LNUM_WORD), FALSE};

static LNUM_WORD urrs_brainpoolP256r1_Gx[4] = { 0x3A4453BD9ACE3262, 0xB9DE27E1E3BD23C2, 0x2C4B482FFC81B7AF, 0x8BD2AEB9CB7E57CB };
static struct dsd_lnum dss_brainpoolP256r1_Gx = {(unsigned char*)urrs_brainpoolP256r1_Gx, 4 * sizeof(LNUM_WORD), 4 * sizeof(LNUM_WORD), FALSE};

static LNUM_WORD urrs_brainpoolP256r1_Gy[4] = { 0x5C1D54C72F046997, 0xC27745132DED8E54, 0x97F8461A14611DC9, 0x547EF835C3DAC4FD };
static struct dsd_lnum dss_brainpoolP256r1_Gy = {(unsigned char*)urrs_brainpoolP256r1_Gy, 4 * sizeof(LNUM_WORD), 4 * sizeof(LNUM_WORD), FALSE};

static LNUM_WORD urrs_brainpoolP256r1_n[4] = { 0x901E0E82974856A7, 0x8C397AA3B561A6F7, 0x3E660A909D838D71, 0xA9FB57DBA1EEA9BC };
static struct dsd_lnum dss_brainpoolP256r1_n = {(unsigned char*)urrs_brainpoolP256r1_n, 4 * sizeof(LNUM_WORD), 4 * sizeof(LNUM_WORD), FALSE};


static LNUM_WORD urrs_brainpoolP384r1_p[6] = { 0x874700133107EC53, 0xACD3A729901D1A71, 0x12B1DA197FB71123, 0x152F7109ED5456B4, 0x0F5D6F7E50E641DF, 0x8CB91E82A3386D28 };
static struct dsd_lnum dss_brainpoolP384r1_p = {(unsigned char*)urrs_brainpoolP384r1_p, 6 * sizeof(LNUM_WORD), 6 * sizeof(LNUM_WORD), FALSE};

static LNUM_WORD urrs_brainpoolP384r1_a[6] = { 0x04A8C7DD22CE2826, 0x8AA5814A503AD4EB, 0x139165EFBA91F90F, 0xC2BEA28E4FB22787, 0x3C72080ACE05AFA0, 0x7BC382C63D8C150C };
static struct dsd_lnum dss_brainpoolP384r1_a = {(unsigned char*)urrs_brainpoolP384r1_a, 6 * sizeof(LNUM_WORD), 6 * sizeof(LNUM_WORD), FALSE};

static LNUM_WORD urrs_brainpoolP384r1_b[6] = { 0x3AB78696FA504C11, 0x7CB4390295DBC994, 0x2E880EA53EEB62D5, 0x2FB77DE107DCD2A6, 0x8B39B55416F0447C, 0x04A8C7DD22CE2826 };
static struct dsd_lnum dss_brainpoolP384r1_b = {(unsigned char*)urrs_brainpoolP384r1_b, 6 * sizeof(LNUM_WORD), 6 * sizeof(LNUM_WORD), FALSE};

static LNUM_WORD urrs_brainpoolP384r1_Gx[6] = { 0xEF87B2E247D4AF1E, 0xE826E03436D646AA, 0xDB7FCAFE0CBD10E8, 0x8847A3E77EF14FE3, 0xA2A63A81B7C13F6B, 0x1D1C64F068CF45FF };
static struct dsd_lnum dss_brainpoolP384r1_Gx = {(unsigned char*)urrs_brainpoolP384r1_Gx, 6 * sizeof(LNUM_WORD), 6 * sizeof(LNUM_WORD), FALSE};

static LNUM_WORD urrs_brainpoolP384r1_Gy[6] = { 0x42820341263C5315, 0x0E46462177918111, 0xE19C054FF9912928, 0x62B70B29FEEC5864, 0x5CB1EB8E95CFD552, 0x8ABE1D7520F9C2A4 };
static struct dsd_lnum dss_brainpoolP384r1_Gy = {(unsigned char*)urrs_brainpoolP384r1_Gy, 6 * sizeof(LNUM_WORD), 6 * sizeof(LNUM_WORD), FALSE};

static LNUM_WORD urrs_brainpoolP384r1_n[6] = { 0x3B883202E9046565, 0xCF3AB6AF6B7FC310, 0x1F166E6CAC0425A7, 0x152F7109ED5456B3, 0x0F5D6F7E50E641DF, 0x8CB91E82A3386D28 };
static struct dsd_lnum dss_brainpoolP384r1_n = {(unsigned char*)urrs_brainpoolP384r1_n, 6 * sizeof(LNUM_WORD), 6 * sizeof(LNUM_WORD), FALSE};


static LNUM_WORD urrs_brainpoolP512r1_p[8] = { 0x28AA6056583A48F3, 0x2881FF2F2D82C685, 0xAECDA12AE6A380E6, 0x7D4D9B009BC66842, 0xD6639CCA70330871, 0xCB308DB3B3C9D20E, 0x3FD4E6AE33C9FC07, 0xAADD9DB8DBE9C48B };
static struct dsd_lnum dss_brainpoolP512r1_p = {(unsigned char*)urrs_brainpoolP512r1_p, 8 * sizeof(LNUM_WORD), 8 * sizeof(LNUM_WORD), FALSE};

static LNUM_WORD urrs_brainpoolP512r1_a[8] = { 0xE7C1AC4D77FC94CA, 0x7F1117A72BF2C7B9, 0x0A2EF1C98B9AC8B5, 0x2DED5D5AA8253AA1, 0xA83441CAEA9863BC, 0x94CBDD8D3DF91610, 0xE2327145AC234CC5, 0x7830A3318B603B89 };
static struct dsd_lnum dss_brainpoolP512r1_a = {(unsigned char*)urrs_brainpoolP512r1_a, 8 * sizeof(LNUM_WORD), 8 * sizeof(LNUM_WORD), FALSE};

static LNUM_WORD urrs_brainpoolP512r1_b[8] = { 0x2809BD638016F723, 0x984050B75EBAE5DD, 0x77FC94CADC083E67, 0x2BF2C7B9E7C1AC4D, 0x8B9AC8B57F1117A7, 0xA8253AA10A2EF1C9, 0xEA9863BC2DED5D5A, 0x3DF91610A83441CA };
static struct dsd_lnum dss_brainpoolP512r1_b = {(unsigned char*)urrs_brainpoolP512r1_b, 8 * sizeof(LNUM_WORD), 8 * sizeof(LNUM_WORD), FALSE};

static LNUM_WORD urrs_brainpoolP512r1_Gx[8] = { 0x8B352209BCB9F822, 0x7C6D5047406A5E68, 0x50D1687B93B97D5F, 0xFF3B1F78E2D0D48D, 0xB43B62EEF4D0098E, 0x85ED9F70B5D916C1, 0x5A21322E9C4C6A93, 0x81AEE4BDD82ED964 };
static struct dsd_lnum dss_brainpoolP512r1_Gx = {(unsigned char*)urrs_brainpoolP512r1_Gx, 8 * sizeof(LNUM_WORD), 8 * sizeof(LNUM_WORD), FALSE};

static LNUM_WORD urrs_brainpoolP512r1_Gy[8] = { 0x78CD1E0F3AD80892, 0xD1CA2B2FA8F05406, 0x5BCA4BD88A2763AE, 0xB2DCDE494A5F485E, 0xA000C55B881F8111, 0xF209F70024A57B1A, 0xC0EABFA9CF7822FD, 0x7DDE385D566332EC };
static struct dsd_lnum dss_brainpoolP512r1_Gy = {(unsigned char*)urrs_brainpoolP512r1_Gy, 8 * sizeof(LNUM_WORD), 8 * sizeof(LNUM_WORD), FALSE};

static LNUM_WORD urrs_brainpoolP512r1_n[8] = { 0xB58796829CA90069, 0x1DB1D381085DDADD, 0x418661197FAC1047, 0x553E5C414CA92619, 0xD6639CCA70330870, 0xCB308DB3B3C9D20E, 0x3FD4E6AE33C9FC07, 0xAADD9DB8DBE9C48B };
static struct dsd_lnum dss_brainpoolP512r1_n = {(unsigned char*)urrs_brainpoolP512r1_n, 8 * sizeof(LNUM_WORD), 8 * sizeof(LNUM_WORD), FALSE};


static LNUM_WORD urrs_X25519_p[4] = { 0xffffffffffffffed, 0xffffffffffffffff, 0xffffffffffffffff, 0x7fffffffffffffff };
static struct dsd_lnum dss_X25519_p = {(unsigned char*)urrs_X25519_p, 4 * sizeof(LNUM_WORD), 4 * sizeof(LNUM_WORD), FALSE};

static LNUM_WORD urrs_X25519_a[2] = { 0x076d06, 0x0 };
static struct dsd_lnum dss_X25519_a = {(unsigned char*)urrs_X25519_a, 2 * sizeof(LNUM_WORD), 1 * sizeof(LNUM_WORD), FALSE};

static LNUM_WORD urrs_X25519_a24[2] = { 0x01db42, 0x0 };
static struct dsd_lnum dss_X25519_a24 = {(unsigned char*)urrs_X25519_a24, 2 * sizeof(LNUM_WORD), 1 * sizeof(LNUM_WORD), FALSE};

static LNUM_WORD urrs_X25519_Gx[2] = { 0x09, 0x0 };
static struct dsd_lnum dss_X25519_Gx = {(unsigned char*)urrs_X25519_Gx, 2 * sizeof(LNUM_WORD), 1 * sizeof(LNUM_WORD), FALSE};

static LNUM_WORD urrs_X25519_Gy[4] = { 0x29e9c5a27eced3d9, 0x923d4d7e6d7c61b2, 0xe01edd2c7748d14c, 0x20ae19a1b8a086b4 };
static struct dsd_lnum dss_X25519_Gy = {(unsigned char*)urrs_X25519_Gy, 4 * sizeof(LNUM_WORD), 4 * sizeof(LNUM_WORD), FALSE};

static LNUM_WORD urrs_X25519_n[4] = { 0x5812631a5cf5d3ed, 0x14def9dea2f79cd6, 0x0000000000000000, 0x1000000000000000 };
static struct dsd_lnum dss_X25519_n = {(unsigned char*)urrs_X25519_n, 4 * sizeof(LNUM_WORD), 4 * sizeof(LNUM_WORD), FALSE};


static LNUM_WORD urrs_X448_p[8] = { 0xffffffffffffffff, 0xffffffffffffffff, 0xffffffffffffffff, 0xfffffffeffffffff, 0xffffffffffffffff, 0xffffffffffffffff, 0xffffffffffffffff, 0x0 };
static struct dsd_lnum dss_X448_p = {(unsigned char*)urrs_X448_p, 8 * sizeof(LNUM_WORD), 7 * sizeof(LNUM_WORD), FALSE};

static LNUM_WORD urrs_X448_a[2] = { 0x0262a6, 0x0 };
static struct dsd_lnum dss_X448_a = {(unsigned char*)urrs_X448_a, 2 * sizeof(LNUM_WORD), 1 * sizeof(LNUM_WORD), FALSE};

static LNUM_WORD urrs_X448_a24[2] = { 0x98aa, 0x0 };
static struct dsd_lnum dss_X448_a24 = {(unsigned char*)urrs_X448_a24, 2 * sizeof(LNUM_WORD), 1 * sizeof(LNUM_WORD), FALSE};

static LNUM_WORD urrs_X448_Gx[2] = { 0x05, 0x0 };
static struct dsd_lnum dss_X448_Gx = {(unsigned char*)urrs_X448_Gx, 2 * sizeof(LNUM_WORD), 1 * sizeof(LNUM_WORD), FALSE};

static LNUM_WORD urrs_X448_Gy[8] = { 0x6fd7223d457b5b1a, 0x1312c4b150677af7, 0xb8027e2346430d21, 0x60f75dc28df3f6ed, 0xcbae5d34f55545d0, 0x6c98ab6e58326fce, 0x7d235d1295f5b1f6, 0x0 };
static struct dsd_lnum dss_X448_Gy = {(unsigned char*)urrs_X448_Gy, 8 * sizeof(LNUM_WORD), 7 * sizeof(LNUM_WORD), FALSE};

static LNUM_WORD urrs_X448_n[8] = { 0x2378c292ab5844f3, 0x216cc2728dc58f55, 0xc44edb49aed63690, 0xffffffff7cca23e9, 0xffffffffffffffff, 0xffffffffffffffff, 0x3fffffffffffffff, 0x0 };
static struct dsd_lnum dss_X448_n = {(unsigned char*)urrs_X448_n, 8 * sizeof(LNUM_WORD), 7 * sizeof(LNUM_WORD), FALSE};


#else
static LNUM_WORD urrs_P192_p[6] = { 0xffffffff, 0xffffffff, 0xfffffffe, 0xffffffff, 0xffffffff, 0xffffffff };
static struct dsd_lnum dss_P192_p = {(unsigned char*)urrs_P192_p, 6 * sizeof(LNUM_WORD), 6 * sizeof(LNUM_WORD), FALSE};

static LNUM_WORD urrs_P192_a[6] = { 0xfffffffc, 0xffffffff, 0xfffffffe, 0xffffffff, 0xffffffff, 0xffffffff };
static struct dsd_lnum dss_P192_a = {(unsigned char*)urrs_P192_a, 6 * sizeof(LNUM_WORD), 6 * sizeof(LNUM_WORD), FALSE};

static LNUM_WORD urrs_P192_b[6] = { 0xc146b9b1, 0xfeb8deec, 0x72243049, 0x0fa7e9ab, 0xe59c80e7, 0x64210519 };
static struct dsd_lnum dss_P192_b = {(unsigned char*)urrs_P192_b, 6 * sizeof(LNUM_WORD), 6 * sizeof(LNUM_WORD), FALSE};

static LNUM_WORD urrs_P192_Gx[6] = { 0x82ff1012, 0xf4ff0afd, 0x43a18800, 0x7cbf20eb, 0xb03090f6, 0x188da80e };
static struct dsd_lnum dss_P192_Gx = {(unsigned char*)urrs_P192_Gx, 6 * sizeof(LNUM_WORD), 6 * sizeof(LNUM_WORD), FALSE};

static LNUM_WORD urrs_P192_Gy[6] = { 0x1e794811, 0x73f977a1, 0x6b24cdd5, 0x631011ed, 0xffc8da78, 0x07192b95 };
static struct dsd_lnum dss_P192_Gy = {(unsigned char*)urrs_P192_Gy, 6 * sizeof(LNUM_WORD), 6 * sizeof(LNUM_WORD), FALSE};

static LNUM_WORD urrs_P192_n[6] = { 0xb4d22831, 0x146bc9b1, 0x99def836, 0xffffffff, 0xffffffff, 0xffffffff };
static struct dsd_lnum dss_P192_n = {(unsigned char*)urrs_P192_n, 6 * sizeof(LNUM_WORD), 6 * sizeof(LNUM_WORD), FALSE};


static LNUM_WORD urrs_P224_p[8] = { 0x00000001, 0x00000000, 0x00000000, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0x0 };
static struct dsd_lnum dss_P224_p = {(unsigned char*)urrs_P224_p, 8 * sizeof(LNUM_WORD), 7 * sizeof(LNUM_WORD), FALSE};

static LNUM_WORD urrs_P224_a[8] = { 0xfffffffe, 0xffffffff, 0xffffffff, 0xfffffffe, 0xffffffff, 0xffffffff, 0xffffffff, 0x0 };
static struct dsd_lnum dss_P224_a = {(unsigned char*)urrs_P224_a, 8 * sizeof(LNUM_WORD), 7 * sizeof(LNUM_WORD), FALSE};

static LNUM_WORD urrs_P224_b[8] = { 0x2355ffb4, 0x270b3943, 0xd7bfd8ba, 0x5044b0b7, 0xf5413256, 0x0c04b3ab, 0xb4050a85, 0x0 };
static struct dsd_lnum dss_P224_b = {(unsigned char*)urrs_P224_b, 8 * sizeof(LNUM_WORD), 7 * sizeof(LNUM_WORD), FALSE};

static LNUM_WORD urrs_P224_Gx[8] = { 0x115c1d21, 0x343280d6, 0x56c21122, 0x4a03c1d3, 0x321390b9, 0x6bb4bf7f, 0xb70e0cbd, 0x0 };
static struct dsd_lnum dss_P224_Gx = {(unsigned char*)urrs_P224_Gx, 8 * sizeof(LNUM_WORD), 7 * sizeof(LNUM_WORD), FALSE};

static LNUM_WORD urrs_P224_Gy[8] = { 0x85007e34, 0x44d58199, 0x5a074764, 0xcd4375a0, 0x4c22dfe6, 0xb5f723fb, 0xbd376388, 0x0 };
static struct dsd_lnum dss_P224_Gy = {(unsigned char*)urrs_P224_Gy, 8 * sizeof(LNUM_WORD), 7 * sizeof(LNUM_WORD), FALSE};

static LNUM_WORD urrs_P224_n[8] = { 0x5c5c2a3d, 0x13dd2945, 0xe0b8f03e, 0xffff16a2, 0xffffffff, 0xffffffff, 0xffffffff, 0x0 };
static struct dsd_lnum dss_P224_n = {(unsigned char*)urrs_P224_n, 8 * sizeof(LNUM_WORD), 7 * sizeof(LNUM_WORD), FALSE};


static LNUM_WORD urrs_P256_p[8] = { 0xffffffff, 0xffffffff, 0xffffffff, 0x00000000, 0x00000000, 0x00000000, 0x00000001, 0xffffffff };
static struct dsd_lnum dss_P256_p = {(unsigned char*)urrs_P256_p, 8 * sizeof(LNUM_WORD), 8 * sizeof(LNUM_WORD), FALSE};

static LNUM_WORD urrs_P256_a[8] = { 0xfffffffc, 0xffffffff, 0xffffffff, 0x00000000, 0x00000000, 0x00000000, 0x00000001, 0xffffffff };
static struct dsd_lnum dss_P256_a = {(unsigned char*)urrs_P256_a, 8 * sizeof(LNUM_WORD), 8 * sizeof(LNUM_WORD), FALSE};

static LNUM_WORD urrs_P256_b[8] = { 0x27d2604b, 0x3bce3c3e, 0xcc53b0f6, 0x651d06b0, 0x769886bc, 0xb3ebbd55, 0xaa3a93e7, 0x5ac635d8 };
static struct dsd_lnum dss_P256_b = {(unsigned char*)urrs_P256_b, 8 * sizeof(LNUM_WORD), 8 * sizeof(LNUM_WORD), FALSE};

static LNUM_WORD urrs_P256_Gx[8] = { 0xd898c296, 0xf4a13945, 0x2deb33a0, 0x77037d81, 0x63a440f2, 0xf8bce6e5, 0xe12c4247, 0x6b17d1f2 };
static struct dsd_lnum dss_P256_Gx = {(unsigned char*)urrs_P256_Gx, 8 * sizeof(LNUM_WORD), 8 * sizeof(LNUM_WORD), FALSE};

static LNUM_WORD urrs_P256_Gy[8] = { 0x37bf51f5, 0xcbb64068, 0x6b315ece, 0x2bce3357, 0x7c0f9e16, 0x8ee7eb4a, 0xfe1a7f9b, 0x4fe342e2 };
static struct dsd_lnum dss_P256_Gy = {(unsigned char*)urrs_P256_Gy, 8 * sizeof(LNUM_WORD), 8 * sizeof(LNUM_WORD), FALSE};

static LNUM_WORD urrs_P256_n[8] = { 0xfc632551, 0xf3b9cac2, 0xa7179e84, 0xbce6faad, 0xffffffff, 0xffffffff, 0x00000000, 0xffffffff };
static struct dsd_lnum dss_P256_n = {(unsigned char*)urrs_P256_n, 8 * sizeof(LNUM_WORD), 8 * sizeof(LNUM_WORD), FALSE};


static LNUM_WORD urrs_P384_p[12] = { 0xffffffff, 0x00000000, 0x00000000, 0xffffffff, 0xfffffffe, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff };
static struct dsd_lnum dss_P384_p = {(unsigned char*)urrs_P384_p, 12 * sizeof(LNUM_WORD), 12 * sizeof(LNUM_WORD), FALSE};

static LNUM_WORD urrs_P384_a[12] = { 0xfffffffc, 0x00000000, 0x00000000, 0xffffffff, 0xfffffffe, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff };
static struct dsd_lnum dss_P384_a = {(unsigned char*)urrs_P384_a, 12 * sizeof(LNUM_WORD), 12 * sizeof(LNUM_WORD), FALSE};

static LNUM_WORD urrs_P384_b[12] = { 0xd3ec2aef, 0x2a85c8ed, 0x8a2ed19d, 0xc656398d, 0x5013875a, 0x0314088f, 0xfe814112, 0x181d9c6e, 0xe3f82d19, 0x988e056b, 0xe23ee7e4, 0xb3312fa7 };
static struct dsd_lnum dss_P384_b = {(unsigned char*)urrs_P384_b, 12 * sizeof(LNUM_WORD), 12 * sizeof(LNUM_WORD), FALSE};

static LNUM_WORD urrs_P384_Gx[12] = { 0x72760ab7, 0x3a545e38, 0xbf55296c, 0x5502f25d, 0x82542a38, 0x59f741e0, 0x8ba79b98, 0x6e1d3b62, 0xf320ad74, 0x8eb1c71e, 0xbe8b0537, 0xaa87ca22 };
static struct dsd_lnum dss_P384_Gx = {(unsigned char*)urrs_P384_Gx, 12 * sizeof(LNUM_WORD), 12 * sizeof(LNUM_WORD), FALSE};

static LNUM_WORD urrs_P384_Gy[12] = { 0x90ea0e5f, 0x7a431d7c, 0x1d7e819d, 0x0a60b1ce, 0xb5f0b8c0, 0xe9da3113, 0x289a147c, 0xf8f41dbd, 0x9292dc29, 0x5d9e98bf, 0x96262c6f, 0x3617de4a };
static struct dsd_lnum dss_P384_Gy = {(unsigned char*)urrs_P384_Gy, 12 * sizeof(LNUM_WORD), 12 * sizeof(LNUM_WORD), FALSE};

static LNUM_WORD urrs_P384_n[12] = { 0xccc52973, 0xecec196a, 0x48b0a77a, 0x581a0db2, 0xf4372ddf, 0xc7634d81, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff };
static struct dsd_lnum dss_P384_n = {(unsigned char*)urrs_P384_n, 12 * sizeof(LNUM_WORD), 12 * sizeof(LNUM_WORD), FALSE};


static LNUM_WORD urrs_P521_p[18] = { 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0x01ff, 0x0 };
static struct dsd_lnum dss_P521_p = {(unsigned char*)urrs_P521_p, 18 * sizeof(LNUM_WORD), 17 * sizeof(LNUM_WORD), FALSE};

static LNUM_WORD urrs_P521_a[18] = { 0xfffffffc, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0x01ff, 0x0 };
static struct dsd_lnum dss_P521_a = {(unsigned char*)urrs_P521_a, 18 * sizeof(LNUM_WORD), 17 * sizeof(LNUM_WORD), FALSE};

static LNUM_WORD urrs_P521_b[18] = { 0x6b503f00, 0xef451fd4, 0x3d2c34f1, 0x3573df88, 0x3bb1bf07, 0x1652c0bd, 0xec7e937b, 0x56193951, 0x8ef109e1, 0xb8b48991, 0x99b315f3, 0xa2da725b, 0xb68540ee, 0x929a21a0, 0x8e1c9a1f, 0x953eb961, 0x51, 0x0 };
static struct dsd_lnum dss_P521_b = {(unsigned char*)urrs_P521_b, 18 * sizeof(LNUM_WORD), 17 * sizeof(LNUM_WORD), FALSE};

static LNUM_WORD urrs_P521_Gx[18] = { 0xc2e5bd66, 0xf97e7e31, 0x856a429b, 0x3348b3c1, 0xa2ffa8de, 0xfe1dc127, 0xefe75928, 0xa14b5e77, 0x6b4d3dba, 0xf828af60, 0x053fb521, 0x9c648139, 0x2395b442, 0x9e3ecb66, 0x0404e9cd, 0x858e06b7, 0xc6, 0x0 };
static struct dsd_lnum dss_P521_Gx = {(unsigned char*)urrs_P521_Gx, 18 * sizeof(LNUM_WORD), 17 * sizeof(LNUM_WORD), FALSE};

static LNUM_WORD urrs_P521_Gy[18] = { 0x9fd16650, 0x88be9476, 0xa272c240, 0x353c7086, 0x3fad0761, 0xc550b901, 0x5ef42640, 0x97ee7299, 0x273e662c, 0x17afbd17, 0x579b4468, 0x98f54449, 0x2c7d1bd9, 0x5c8a5fb4, 0x9a3bc004, 0x39296a78, 0x0118, 0x0 };
static struct dsd_lnum dss_P521_Gy = {(unsigned char*)urrs_P521_Gy, 18 * sizeof(LNUM_WORD), 17 * sizeof(LNUM_WORD), FALSE};

static LNUM_WORD urrs_P521_n[18] = { 0x91386409, 0xbb6fb71e, 0x899c47ae, 0x3bb5c9b8, 0xf709a5d0, 0x7fcc0148, 0xbf2f966b, 0x51868783, 0xfffffffa, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0x01ff, 0x0 };
static struct dsd_lnum dss_P521_n = {(unsigned char*)urrs_P521_n, 18 * sizeof(LNUM_WORD), 17 * sizeof(LNUM_WORD), FALSE};


static LNUM_WORD urrs_SECP192K1_p[6] = { 0xFFFFEE37, 0xFFFFFFFE, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF };
static struct dsd_lnum dss_SECP192K1_p = {(unsigned char*)urrs_SECP192K1_p, 6 * sizeof(LNUM_WORD), 6 * sizeof(LNUM_WORD), FALSE};

static LNUM_WORD urrs_SECP192K1_a[2] = { 0x00, 0x0 };
static struct dsd_lnum dss_SECP192K1_a = {(unsigned char*)urrs_SECP192K1_a, 2 * sizeof(LNUM_WORD), 1 * sizeof(LNUM_WORD), FALSE};

static LNUM_WORD urrs_SECP192K1_b[2] = { 0x03, 0x0 };
static struct dsd_lnum dss_SECP192K1_b = {(unsigned char*)urrs_SECP192K1_b, 2 * sizeof(LNUM_WORD), 1 * sizeof(LNUM_WORD), FALSE};

static LNUM_WORD urrs_SECP192K1_Gx[6] = { 0xEAE06C7D, 0x1DA5D1B1, 0x80B7F434, 0x26B07D02, 0xC057E9AE, 0xDB4FF10E };
static struct dsd_lnum dss_SECP192K1_Gx = {(unsigned char*)urrs_SECP192K1_Gx, 6 * sizeof(LNUM_WORD), 6 * sizeof(LNUM_WORD), FALSE};

static LNUM_WORD urrs_SECP192K1_Gy[6] = { 0xD95E2F9D, 0x4082AA88, 0x15BE8634, 0x844163D0, 0x9C5628A7, 0x9B2F2F6D };
static struct dsd_lnum dss_SECP192K1_Gy = {(unsigned char*)urrs_SECP192K1_Gy, 6 * sizeof(LNUM_WORD), 6 * sizeof(LNUM_WORD), FALSE};

static LNUM_WORD urrs_SECP192K1_n[6] = { 0x74DEFD8D, 0x0F69466A, 0x26F2FC17, 0xFFFFFFFE, 0xFFFFFFFF, 0xFFFFFFFF };
static struct dsd_lnum dss_SECP192K1_n = {(unsigned char*)urrs_SECP192K1_n, 6 * sizeof(LNUM_WORD), 6 * sizeof(LNUM_WORD), FALSE};


static LNUM_WORD urrs_SECP224K1_p[8] = { 0xFFFFE56D, 0xFFFFFFFE, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x0 };
static struct dsd_lnum dss_SECP224K1_p = {(unsigned char*)urrs_SECP224K1_p, 8 * sizeof(LNUM_WORD), 7 * sizeof(LNUM_WORD), FALSE};

static LNUM_WORD urrs_SECP224K1_a[2] = { 0x00, 0x0 };
static struct dsd_lnum dss_SECP224K1_a = {(unsigned char*)urrs_SECP224K1_a, 2 * sizeof(LNUM_WORD), 1 * sizeof(LNUM_WORD), FALSE};

static LNUM_WORD urrs_SECP224K1_b[2] = { 0x05, 0x0 };
static struct dsd_lnum dss_SECP224K1_b = {(unsigned char*)urrs_SECP224K1_b, 2 * sizeof(LNUM_WORD), 1 * sizeof(LNUM_WORD), FALSE};

static LNUM_WORD urrs_SECP224K1_Gx[8] = { 0xB6B7A45C, 0x0F7E650E, 0xE47075A9, 0x69A467E9, 0x30FC28A1, 0x4DF099DF, 0xA1455B33, 0x0 };
static struct dsd_lnum dss_SECP224K1_Gx = {(unsigned char*)urrs_SECP224K1_Gx, 8 * sizeof(LNUM_WORD), 7 * sizeof(LNUM_WORD), FALSE};

static LNUM_WORD urrs_SECP224K1_Gy[8] = { 0x556D61A5, 0xE2CA4BDB, 0xC0B0BD59, 0xF7E319F7, 0x82CAFBD6, 0x7FBA3442, 0x7E089FED, 0x0 };
static struct dsd_lnum dss_SECP224K1_Gy = {(unsigned char*)urrs_SECP224K1_Gy, 8 * sizeof(LNUM_WORD), 7 * sizeof(LNUM_WORD), FALSE};

static LNUM_WORD urrs_SECP224K1_n[8] = { 0x769FB1F7, 0xCAF0A971, 0xD2EC6184, 0x0001DCE8, 0x00000000, 0x00000000, 0x00000000, 0x01 };
static struct dsd_lnum dss_SECP224K1_n = {(unsigned char*)urrs_SECP224K1_n, 8 * sizeof(LNUM_WORD), 8 * sizeof(LNUM_WORD), FALSE};


static LNUM_WORD urrs_SECP256K1_p[8] = { 0xFFFFFC2F, 0xFFFFFFFE, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF };
static struct dsd_lnum dss_SECP256K1_p = {(unsigned char*)urrs_SECP256K1_p, 8 * sizeof(LNUM_WORD), 8 * sizeof(LNUM_WORD), FALSE};

static LNUM_WORD urrs_SECP256K1_a[2] = { 0x00, 0x0 };
static struct dsd_lnum dss_SECP256K1_a = {(unsigned char*)urrs_SECP256K1_a, 2 * sizeof(LNUM_WORD), 1 * sizeof(LNUM_WORD), FALSE};

static LNUM_WORD urrs_SECP256K1_b[2] = { 0x07, 0x0 };
static struct dsd_lnum dss_SECP256K1_b = {(unsigned char*)urrs_SECP256K1_b, 2 * sizeof(LNUM_WORD), 1 * sizeof(LNUM_WORD), FALSE};

static LNUM_WORD urrs_SECP256K1_Gx[8] = { 0x16F81798, 0x59F2815B, 0x2DCE28D9, 0x029BFCDB, 0xCE870B07, 0x55A06295, 0xF9DCBBAC, 0x79BE667E };
static struct dsd_lnum dss_SECP256K1_Gx = {(unsigned char*)urrs_SECP256K1_Gx, 8 * sizeof(LNUM_WORD), 8 * sizeof(LNUM_WORD), FALSE};

static LNUM_WORD urrs_SECP256K1_Gy[8] = { 0xFB10D4B8, 0x9C47D08F, 0xA6855419, 0xFD17B448, 0x0E1108A8, 0x5DA4FBFC, 0x26A3C465, 0x483ADA77 };
static struct dsd_lnum dss_SECP256K1_Gy = {(unsigned char*)urrs_SECP256K1_Gy, 8 * sizeof(LNUM_WORD), 8 * sizeof(LNUM_WORD), FALSE};

static LNUM_WORD urrs_SECP256K1_n[8] = { 0xD0364141, 0xBFD25E8C, 0xAF48A03B, 0xBAAEDCE6, 0xFFFFFFFE, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF };
static struct dsd_lnum dss_SECP256K1_n = {(unsigned char*)urrs_SECP256K1_n, 8 * sizeof(LNUM_WORD), 8 * sizeof(LNUM_WORD), FALSE};


static LNUM_WORD urrs_brainpoolP256r1_p[8] = { 0x1F6E5377, 0x2013481D, 0xD5262028, 0x6E3BF623, 0x9D838D72, 0x3E660A90, 0xA1EEA9BC, 0xA9FB57DB };
static struct dsd_lnum dss_brainpoolP256r1_p = {(unsigned char*)urrs_brainpoolP256r1_p, 8 * sizeof(LNUM_WORD), 8 * sizeof(LNUM_WORD), FALSE};

static LNUM_WORD urrs_brainpoolP256r1_a[8] = { 0xF330B5D9, 0xE94A4B44, 0x26DC5C6C, 0xFB8055C1, 0x417AFFE7, 0xEEF67530, 0xFC2C3057, 0x7D5A0975 };
static struct dsd_lnum dss_brainpoolP256r1_a = {(unsigned char*)urrs_brainpoolP256r1_a, 8 * sizeof(LNUM_WORD), 8 * sizeof(LNUM_WORD), FALSE};

static LNUM_WORD urrs_brainpoolP256r1_b[8] = { 0xFF8C07B6, 0x6BCCDC18, 0x5CF7E1CE, 0x95841629, 0xBBD77CBF, 0xF330B5D9, 0xE94A4B44, 0x26DC5C6C };
static struct dsd_lnum dss_brainpoolP256r1_b = {(unsigned char*)urrs_brainpoolP256r1_b, 8 * sizeof(LNUM_WORD), 8 * sizeof(LNUM_WORD), FALSE};

static LNUM_WORD urrs_brainpoolP256r1_Gx[8] = { 0x9ACE3262, 0x3A4453BD, 0xE3BD23C2, 0xB9DE27E1, 0xFC81B7AF, 0x2C4B482F, 0xCB7E57CB, 0x8BD2AEB9 };
static struct dsd_lnum dss_brainpoolP256r1_Gx = {(unsigned char*)urrs_brainpoolP256r1_Gx, 8 * sizeof(LNUM_WORD), 8 * sizeof(LNUM_WORD), FALSE};

static LNUM_WORD urrs_brainpoolP256r1_Gy[8] = { 0x2F046997, 0x5C1D54C7, 0x2DED8E54, 0xC2774513, 0x14611DC9, 0x97F8461A, 0xC3DAC4FD, 0x547EF835 };
static struct dsd_lnum dss_brainpoolP256r1_Gy = {(unsigned char*)urrs_brainpoolP256r1_Gy, 8 * sizeof(LNUM_WORD), 8 * sizeof(LNUM_WORD), FALSE};

static LNUM_WORD urrs_brainpoolP256r1_n[8] = { 0x974856A7, 0x901E0E82, 0xB561A6F7, 0x8C397AA3, 0x9D838D71, 0x3E660A90, 0xA1EEA9BC, 0xA9FB57DB };
static struct dsd_lnum dss_brainpoolP256r1_n = {(unsigned char*)urrs_brainpoolP256r1_n, 8 * sizeof(LNUM_WORD), 8 * sizeof(LNUM_WORD), FALSE};


static LNUM_WORD urrs_brainpoolP384r1_p[12] = { 0x3107EC53, 0x87470013, 0x901D1A71, 0xACD3A729, 0x7FB71123, 0x12B1DA19, 0xED5456B4, 0x152F7109, 0x50E641DF, 0x0F5D6F7E, 0xA3386D28, 0x8CB91E82 };
static struct dsd_lnum dss_brainpoolP384r1_p = {(unsigned char*)urrs_brainpoolP384r1_p, 12 * sizeof(LNUM_WORD), 12 * sizeof(LNUM_WORD), FALSE};

static LNUM_WORD urrs_brainpoolP384r1_a[12] = { 0x22CE2826, 0x04A8C7DD, 0x503AD4EB, 0x8AA5814A, 0xBA91F90F, 0x139165EF, 0x4FB22787, 0xC2BEA28E, 0xCE05AFA0, 0x3C72080A, 0x3D8C150C, 0x7BC382C6 };
static struct dsd_lnum dss_brainpoolP384r1_a = {(unsigned char*)urrs_brainpoolP384r1_a, 12 * sizeof(LNUM_WORD), 12 * sizeof(LNUM_WORD), FALSE};

static LNUM_WORD urrs_brainpoolP384r1_b[12] = { 0xFA504C11, 0x3AB78696, 0x95DBC994, 0x7CB43902, 0x3EEB62D5, 0x2E880EA5, 0x07DCD2A6, 0x2FB77DE1, 0x16F0447C, 0x8B39B554, 0x22CE2826, 0x04A8C7DD };
static struct dsd_lnum dss_brainpoolP384r1_b = {(unsigned char*)urrs_brainpoolP384r1_b, 12 * sizeof(LNUM_WORD), 12 * sizeof(LNUM_WORD), FALSE};

static LNUM_WORD urrs_brainpoolP384r1_Gx[12] = { 0x47D4AF1E, 0xEF87B2E2, 0x36D646AA, 0xE826E034, 0x0CBD10E8, 0xDB7FCAFE, 0x7EF14FE3, 0x8847A3E7, 0xB7C13F6B, 0xA2A63A81, 0x68CF45FF, 0x1D1C64F0 };
static struct dsd_lnum dss_brainpoolP384r1_Gx = {(unsigned char*)urrs_brainpoolP384r1_Gx, 12 * sizeof(LNUM_WORD), 12 * sizeof(LNUM_WORD), FALSE};

static LNUM_WORD urrs_brainpoolP384r1_Gy[12] = { 0x263C5315, 0x42820341, 0x77918111, 0x0E464621, 0xF9912928, 0xE19C054F, 0xFEEC5864, 0x62B70B29, 0x95CFD552, 0x5CB1EB8E, 0x20F9C2A4, 0x8ABE1D75 };
static struct dsd_lnum dss_brainpoolP384r1_Gy = {(unsigned char*)urrs_brainpoolP384r1_Gy, 12 * sizeof(LNUM_WORD), 12 * sizeof(LNUM_WORD), FALSE};

static LNUM_WORD urrs_brainpoolP384r1_n[12] = { 0xE9046565, 0x3B883202, 0x6B7FC310, 0xCF3AB6AF, 0xAC0425A7, 0x1F166E6C, 0xED5456B3, 0x152F7109, 0x50E641DF, 0x0F5D6F7E, 0xA3386D28, 0x8CB91E82 };
static struct dsd_lnum dss_brainpoolP384r1_n = {(unsigned char*)urrs_brainpoolP384r1_n, 12 * sizeof(LNUM_WORD), 12 * sizeof(LNUM_WORD), FALSE};


static LNUM_WORD urrs_brainpoolP512r1_p[16] = { 0x583A48F3, 0x28AA6056, 0x2D82C685, 0x2881FF2F, 0xE6A380E6, 0xAECDA12A, 0x9BC66842, 0x7D4D9B00, 0x70330871, 0xD6639CCA, 0xB3C9D20E, 0xCB308DB3, 0x33C9FC07, 0x3FD4E6AE, 0xDBE9C48B, 0xAADD9DB8 };
static struct dsd_lnum dss_brainpoolP512r1_p = {(unsigned char*)urrs_brainpoolP512r1_p, 16 * sizeof(LNUM_WORD), 16 * sizeof(LNUM_WORD), FALSE};

static LNUM_WORD urrs_brainpoolP512r1_a[16] = { 0x77FC94CA, 0xE7C1AC4D, 0x2BF2C7B9, 0x7F1117A7, 0x8B9AC8B5, 0x0A2EF1C9, 0xA8253AA1, 0x2DED5D5A, 0xEA9863BC, 0xA83441CA, 0x3DF91610, 0x94CBDD8D, 0xAC234CC5, 0xE2327145, 0x8B603B89, 0x7830A331 };
static struct dsd_lnum dss_brainpoolP512r1_a = {(unsigned char*)urrs_brainpoolP512r1_a, 16 * sizeof(LNUM_WORD), 16 * sizeof(LNUM_WORD), FALSE};

static LNUM_WORD urrs_brainpoolP512r1_b[16] = { 0x8016F723, 0x2809BD63, 0x5EBAE5DD, 0x984050B7, 0xDC083E67, 0x77FC94CA, 0xE7C1AC4D, 0x2BF2C7B9, 0x7F1117A7, 0x8B9AC8B5, 0x0A2EF1C9, 0xA8253AA1, 0x2DED5D5A, 0xEA9863BC, 0xA83441CA, 0x3DF91610 };
static struct dsd_lnum dss_brainpoolP512r1_b = {(unsigned char*)urrs_brainpoolP512r1_b, 16 * sizeof(LNUM_WORD), 16 * sizeof(LNUM_WORD), FALSE};

static LNUM_WORD urrs_brainpoolP512r1_Gx[16] = { 0xBCB9F822, 0x8B352209, 0x406A5E68, 0x7C6D5047, 0x93B97D5F, 0x50D1687B, 0xE2D0D48D, 0xFF3B1F78, 0xF4D0098E, 0xB43B62EE, 0xB5D916C1, 0x85ED9F70, 0x9C4C6A93, 0x5A21322E, 0xD82ED964, 0x81AEE4BD };
static struct dsd_lnum dss_brainpoolP512r1_Gx = {(unsigned char*)urrs_brainpoolP512r1_Gx, 16 * sizeof(LNUM_WORD), 16 * sizeof(LNUM_WORD), FALSE};

static LNUM_WORD urrs_brainpoolP512r1_Gy[16] = { 0x3AD80892, 0x78CD1E0F, 0xA8F05406, 0xD1CA2B2F, 0x8A2763AE, 0x5BCA4BD8, 0x4A5F485E, 0xB2DCDE49, 0x881F8111, 0xA000C55B, 0x24A57B1A, 0xF209F700, 0xCF7822FD, 0xC0EABFA9, 0x566332EC, 0x7DDE385D };
static struct dsd_lnum dss_brainpoolP512r1_Gy = {(unsigned char*)urrs_brainpoolP512r1_Gy, 16 * sizeof(LNUM_WORD), 16 * sizeof(LNUM_WORD), FALSE};

static LNUM_WORD urrs_brainpoolP512r1_n[16] = { 0x9CA90069, 0xB5879682, 0x085DDADD, 0x1DB1D381, 0x7FAC1047, 0x41866119, 0x4CA92619, 0x553E5C41, 0x70330870, 0xD6639CCA, 0xB3C9D20E, 0xCB308DB3, 0x33C9FC07, 0x3FD4E6AE, 0xDBE9C48B, 0xAADD9DB8 };
static struct dsd_lnum dss_brainpoolP512r1_n = {(unsigned char*)urrs_brainpoolP512r1_n, 16 * sizeof(LNUM_WORD), 16 * sizeof(LNUM_WORD), FALSE};


static LNUM_WORD urrs_X25519_p[8] = { 0xffffffed, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0x7fffffff };
static struct dsd_lnum dss_X25519_p = {(unsigned char*)urrs_X25519_p, 8 * sizeof(LNUM_WORD), 8 * sizeof(LNUM_WORD), FALSE};

static LNUM_WORD urrs_X25519_a[2] = { 0x076d06, 0x0 };
static struct dsd_lnum dss_X25519_a = {(unsigned char*)urrs_X25519_a, 2 * sizeof(LNUM_WORD), 1 * sizeof(LNUM_WORD), FALSE};

static LNUM_WORD urrs_X25519_a24[2] = { 0x01db42, 0x0 };
static struct dsd_lnum dss_X25519_a24 = {(unsigned char*)urrs_X25519_a24, 2 * sizeof(LNUM_WORD), 1 * sizeof(LNUM_WORD), FALSE};

static LNUM_WORD urrs_X25519_Gx[2] = { 0x09, 0x0 };
static struct dsd_lnum dss_X25519_Gx = {(unsigned char*)urrs_X25519_Gx, 2 * sizeof(LNUM_WORD), 1 * sizeof(LNUM_WORD), FALSE};

static LNUM_WORD urrs_X25519_Gy[8] = { 0x7eced3d9, 0x29e9c5a2, 0x6d7c61b2, 0x923d4d7e, 0x7748d14c, 0xe01edd2c, 0xb8a086b4, 0x20ae19a1 };
static struct dsd_lnum dss_X25519_Gy = {(unsigned char*)urrs_X25519_Gy, 8 * sizeof(LNUM_WORD), 8 * sizeof(LNUM_WORD), FALSE};

static LNUM_WORD urrs_X25519_n[8] = { 0x5cf5d3ed, 0x5812631a, 0xa2f79cd6, 0x14def9de, 0x00000000, 0x00000000, 0x00000000, 0x10000000 };
static struct dsd_lnum dss_X25519_n = {(unsigned char*)urrs_X25519_n, 8 * sizeof(LNUM_WORD), 8 * sizeof(LNUM_WORD), FALSE};


static LNUM_WORD urrs_X448_p[14] = { 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xfffffffe, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff };
static struct dsd_lnum dss_X448_p = {(unsigned char*)urrs_X448_p, 14 * sizeof(LNUM_WORD), 14 * sizeof(LNUM_WORD), FALSE};

static LNUM_WORD urrs_X448_a[2] = { 0xa6, 0x0 };
static struct dsd_lnum dss_X448_a = {(unsigned char*)urrs_X448_a, 2 * sizeof(LNUM_WORD), 1 * sizeof(LNUM_WORD), FALSE};

static LNUM_WORD urrs_X448_a24[2] = { 0x98aa, 0x0 };
static struct dsd_lnum dss_X448_a24 = {(unsigned char*)urrs_X448_a24, 2 * sizeof(LNUM_WORD), 1 * sizeof(LNUM_WORD), FALSE};

static LNUM_WORD urrs_X448_Gx[2] = { 0x05, 0x0 };
static struct dsd_lnum dss_X448_Gx = {(unsigned char*)urrs_X448_Gx, 2 * sizeof(LNUM_WORD), 1 * sizeof(LNUM_WORD), FALSE};

static LNUM_WORD urrs_X448_Gy[14] = { 0x457b5b1a, 0x6fd7223d, 0x50677af7, 0x1312c4b1, 0x46430d21, 0xb8027e23, 0x8df3f6ed, 0x60f75dc2, 0xf55545d0, 0xcbae5d34, 0x58326fce, 0x6c98ab6e, 0x95f5b1f6, 0x7d235d12 };
static struct dsd_lnum dss_X448_Gy = {(unsigned char*)urrs_X448_Gy, 14 * sizeof(LNUM_WORD), 14 * sizeof(LNUM_WORD), FALSE};

static LNUM_WORD urrs_X448_n[14] = { 0xab5844f3, 0x2378c292, 0x8dc58f55, 0x216cc272, 0xaed63690, 0xc44edb49, 0x7cca23e9, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0x3fffffff };
static struct dsd_lnum dss_X448_n = {(unsigned char*)urrs_X448_n, 14 * sizeof(LNUM_WORD), 14 * sizeof(LNUM_WORD), FALSE};

#endif

static dsd_hcla_critsect_1 m_get_lock()
{
    dsd_hcla_critsect_1 dsl_critsect;
    dsl_critsect.m_create();
    return dsl_critsect;
}

struct dsd_ec_curve_params dsg_P192_params = {
    &dss_P192_a, &dss_P192_b, &dss_P192_Gx,
    &dss_P192_Gy, &dss_P192_p, &dss_P192_n,
    m_get_lock(), FALSE,
        NULL, NULL, ied_P192, ied_weierstr_cofactor_one };
struct dsd_ec_curve_params dsg_P224_params = {
    &dss_P224_a, &dss_P224_b, &dss_P224_Gx,
    &dss_P224_Gy, &dss_P224_p, &dss_P224_n,
    m_get_lock(), FALSE,
        NULL, NULL, ied_P224, ied_weierstr_cofactor_one };
struct dsd_ec_curve_params dsg_P256_params = {
    &dss_P256_a, &dss_P256_b, &dss_P256_Gx,
    &dss_P256_Gy, &dss_P256_p, &dss_P256_n,
    m_get_lock(), FALSE,
        NULL, NULL, ied_P256, ied_weierstr_cofactor_one };
struct dsd_ec_curve_params dsg_P384_params = {
    &dss_P384_a, &dss_P384_b, &dss_P384_Gx,
    &dss_P384_Gy, &dss_P384_p, &dss_P384_n,
    m_get_lock(), FALSE,
        NULL, NULL, ied_P384, ied_weierstr_cofactor_one };
struct dsd_ec_curve_params dsg_P521_params = {
    &dss_P521_a, &dss_P521_b, &dss_P521_Gx,
    &dss_P521_Gy, &dss_P521_p, &dss_P521_n,
    m_get_lock(), FALSE,
        NULL, NULL, ied_P521, ied_weierstr_cofactor_one };
struct dsd_ec_curve_params dsg_SECP192K1_params = {
    &dss_SECP192K1_a, &dss_SECP192K1_b, &dss_SECP192K1_Gx,
    &dss_SECP192K1_Gy, &dss_SECP192K1_p, &dss_SECP192K1_n,
    m_get_lock(), FALSE,
        NULL, NULL, ied_SECP192K1, ied_weierstr_cofactor_one };
struct dsd_ec_curve_params dsg_SECP224K1_params = {
    &dss_SECP224K1_a, &dss_SECP224K1_b, &dss_SECP224K1_Gx,
    &dss_SECP224K1_Gy, &dss_SECP224K1_p, &dss_SECP224K1_n,
    m_get_lock(), FALSE,
        NULL, NULL, ied_SECP224K1, ied_weierstr_cofactor_one };
struct dsd_ec_curve_params dsg_SECP256K1_params = {
    &dss_SECP256K1_a, &dss_SECP256K1_b, &dss_SECP256K1_Gx,
    &dss_SECP256K1_Gy, &dss_SECP256K1_p, &dss_SECP256K1_n,
    m_get_lock(), FALSE,
        NULL, NULL, ied_SECP256K1, ied_weierstr_cofactor_one };
struct dsd_ec_curve_params dsg_brainpoolP256r1_params = {
    &dss_brainpoolP256r1_a, &dss_brainpoolP256r1_b, &dss_brainpoolP256r1_Gx,
    &dss_brainpoolP256r1_Gy, &dss_brainpoolP256r1_p, &dss_brainpoolP256r1_n,
    m_get_lock(), FALSE,
        NULL, NULL, ied_brainpoolP256r1, ied_weierstr_cofactor_one };
struct dsd_ec_curve_params dsg_brainpoolP384r1_params = {
    &dss_brainpoolP384r1_a, &dss_brainpoolP384r1_b, &dss_brainpoolP384r1_Gx,
    &dss_brainpoolP384r1_Gy, &dss_brainpoolP384r1_p, &dss_brainpoolP384r1_n,
    m_get_lock(), FALSE,
        NULL, NULL, ied_brainpoolP384r1, ied_weierstr_cofactor_one };
struct dsd_ec_curve_params dsg_brainpoolP512r1_params = {
    &dss_brainpoolP512r1_a, &dss_brainpoolP512r1_b, &dss_brainpoolP512r1_Gx,
    &dss_brainpoolP512r1_Gy, &dss_brainpoolP512r1_p, &dss_brainpoolP512r1_n,
    m_get_lock(), FALSE,
        NULL, NULL, ied_brainpoolP512r1, ied_weierstr_cofactor_one };
struct dsd_ec_curve_params dsg_X25519_params = {
    &dss_X25519_a, &dss_X25519_a24, &dss_X25519_Gx,
    &dss_X25519_Gy, &dss_X25519_p, &dss_X25519_n,
    m_get_lock(), FALSE,
        NULL, NULL, ied_X25519, ied_montgomery };
struct dsd_ec_curve_params dsg_X448_params = {
    &dss_X448_a, &dss_X448_a24, &dss_X448_Gx,
    &dss_X448_Gy, &dss_X448_p, &dss_X448_n,
    m_get_lock(), FALSE,
        NULL, NULL, ied_X448, ied_montgomery };

extern "C" ied_encry_return m_ecpt_alloc(struct dsd_memory *adsp_memory,
                                         struct dsd_ec_point *adsp_ec_point,
                                         const size_t szp_words_prime)
{
    if (!adsp_memory || !adsp_ec_point) {
        return ied_encry_null_pointer;
    }
    adsp_ec_point->adsc_x = m_lnum_create(adsp_memory, szp_words_prime * sizeof(LNUM_WORD));
    adsp_ec_point->adsc_y = m_lnum_create(adsp_memory, szp_words_prime * sizeof(LNUM_WORD));
    adsp_ec_point->adsc_z = m_lnum_create(adsp_memory, szp_words_prime * sizeof(LNUM_WORD));
    if (!adsp_ec_point->adsc_x || !adsp_ec_point->adsc_y || !adsp_ec_point->adsc_z) {
        m_lnum_destroy(adsp_memory, adsp_ec_point->adsc_x);
        adsp_ec_point->adsc_x = NULL;
        m_lnum_destroy(adsp_memory, adsp_ec_point->adsc_y);
        adsp_ec_point->adsc_y = NULL;
        m_lnum_destroy(adsp_memory, adsp_ec_point->adsc_z);
        adsp_ec_point->adsc_z = NULL;
        return ied_encry_alloc_failure;
    }
    return ied_encry_success;
} // m_ecpt_alloc

extern "C" void m_ecpt_free(struct dsd_memory *adsp_memory,
                            struct dsd_ec_point *adsp_ec_point)
{
    if (!adsp_memory || !adsp_ec_point) {
        return;
    }
    m_lnum_destroy(adsp_memory, adsp_ec_point->adsc_x);
    adsp_ec_point->adsc_x = NULL;
    m_lnum_destroy(adsp_memory, adsp_ec_point->adsc_y);
    adsp_ec_point->adsc_y = NULL;
    m_lnum_destroy(adsp_memory, adsp_ec_point->adsc_z);
    adsp_ec_point->adsc_z = NULL;
}

/**
   Adds two lnums modulu adsp_mod. Inplace possible.
   Caller must assure that dst_alloc_words >= mod_used_words and that
   a and b are filled with zeros up to the index mod_used_words -1.

   @param[in,out] adsp_result          Destination
   @param[in]     adsp_a               Summand 1
   @param[in]     adsp_b               Summand 2
   @param[in]     adsp_mod             Modulus

   @return 0 on success, error code otherwise
 */
static void ms_lnum_add_mod(struct dsd_lnum* adsp_dest,
                            const struct dsd_lnum* adsp_a,
                            const struct dsd_lnum* adsp_b,
                            const struct dsd_lnum* adsp_mod)
{
    size_t szl_len = adsp_mod->szc_used_size_bytes;
    int inl_ret_add = m_impl_add_karatsuba(adsp_dest->aucc_data, adsp_a->aucc_data,  adsp_b->aucc_data, szl_len);
    if (inl_ret_add > 0) {
        m_impl_sub_karatsuba(adsp_dest->aucc_data, adsp_dest->aucc_data, adsp_mod->aucc_data, szl_len);
    } else if (m_impl_cmp(adsp_dest->aucc_data, adsp_mod->aucc_data, szl_len) >= 0) {
        m_impl_sub_karatsuba(adsp_dest->aucc_data, adsp_dest->aucc_data, adsp_mod->aucc_data, szl_len);
    }
}

/**
   Calulates adsp_a-adsp_b mod adsp_mod. Inplace possible if
   destination buffer is big enoght (used_words of modulo).
   adsp_a and adsp_b also have to be allocated with used words of mod.
   Summands a and b has to be filled with zeros to size of mod such
   that words with an index used in mod that are not used are set to 0.

   @param[in,out] adsp_dest            Destination
   @param[in]     adsp_a               Minuend
   @param[in]     adsp_b               Subtrahend
   @param[in]     adsp_mod             Modulus

   @return 0 on success, error code otherwise
 */
static void ms_lnum_sub_mod(struct dsd_lnum* adsp_dest,
                            const struct dsd_lnum* adsp_a,
                            const struct dsd_lnum* adsp_b,
                            const struct dsd_lnum* adsp_mod)
{
    size_t szl_len = adsp_mod->szc_used_size_bytes;
    int inl_ret_sub = m_impl_sub_karatsuba(adsp_dest->aucc_data, adsp_a->aucc_data, adsp_b->aucc_data, szl_len);
    if (inl_ret_sub) {
        m_impl_add_karatsuba(adsp_dest->aucc_data, adsp_dest->aucc_data, adsp_mod->aucc_data, szl_len);
    }
}

/**
   Fills lnums in adsp_point with 0s if used words is smaller than used words of prime.
   Ensure that alloc size of x, y, and z is not smaller than used size of prime when calling this function.

   @param[in,out] adsp_point     EC point
   @param[in]     adsp_prime     prime
 */
extern "C" void m_ecpt_zero_fill(struct dsd_ec_point *adsp_point,
                                 const struct dsd_lnum *adsp_prime)
{
    ms_lnum_zero_fill(adsp_point->adsc_x, adsp_prime->szc_used_size_bytes);
    ms_lnum_zero_fill(adsp_point->adsc_y, adsp_prime->szc_used_size_bytes);
    if (adsp_point->iec_representation == ied_jacobian) {
        ms_lnum_zero_fill(adsp_point->adsc_z, adsp_prime->szc_used_size_bytes);
    }
}

/**
   Copies EC point src to dst. Dst lnums must be allocated big enough, no error checking!

   @param[in,out] adsp_dst             Destination
   @param[in]     adsp_src             Source
 */
inline static void ms_ecpt_cpy(dsd_ec_point *adsp_dst,
                               const dsd_ec_point *adsp_src,
                               const dsd_lnum *adsp_prime)
{
    m_lnum_copy(adsp_dst->adsc_x, adsp_src->adsc_x);
    m_lnum_copy(adsp_dst->adsc_y, adsp_src->adsc_y);
    if (adsp_src->iec_representation == ied_jacobian) {
        m_lnum_copy(adsp_dst->adsc_z, adsp_src->adsc_z);
    }
    adsp_dst->iec_representation = adsp_src->iec_representation;
    m_ecpt_zero_fill(adsp_dst, adsp_prime);
}


/**
   sets member szc_used_size_bytes for x, y, and z that are filled with 0s of an EC point.

   @param[in,out] adsp_point            EC point
 */
extern "C" void m_ecpt_set_used_words(struct dsd_ec_point* adsp_point)
{
    ms_lnum_set_used_words(adsp_point->adsc_x);
    ms_lnum_set_used_words(adsp_point->adsc_y);
    ms_lnum_set_used_words(adsp_point->adsc_z);
}

/**
   Algorithm for doubling an jacobian EC point in montgomery form. Inplace possible.
   adsp_result must be allocated with used_words of prime, point_to_double has
   to be filled with 0s to the size of prime.

   @param[in,out] adsp_result          Result
   @param[in]     adsp_point_to_double Source
   @param[in]     adsp_mont_ctx        Montgomery-context
   @param[in]     adsp_ec_params       elliptic curve parameters (in montgomery form)
   @param[in]     adsp_tmp_1           temp lnums for
   @param[in]     adsp_tmp_2           computations with
   @param[in]     adsp_tmp_3           alloc size double
   @param[in]     adsp_tmp_4           the size of modulus
   @param[in]     adsp_tmp_5           + 1 in words
   @param[in]     adsp_tmp_6
   @param[in]     adsp_tmp_7
   @param[in]     adsp_tmp_8
   @param[in]     adsp_tmp_impl_1
   @param[in]     adsp_tmp_impl_2
 */
static void ms_ecpt_weier_dbl_jac(struct dsd_ec_point* adsp_result,
                                  const struct dsd_ec_point* adsp_point_to_double,
                                  const struct dsd_lnum_montgomery_ctx* adsp_mont_ctx,
                                  const struct dsd_ec_curve_params* adsp_ec_params,
                                  struct dsd_lnum *adsp_tmp_1,
                                  struct dsd_lnum *adsp_tmp_2,
                                  struct dsd_lnum *adsp_tmp_3,
                                  struct dsd_lnum *adsp_tmp_4,
                                  struct dsd_lnum *adsp_tmp_5,
                                  struct dsd_lnum *adsp_tmp_6,
                                  struct dsd_lnum *adsp_tmp_7,
                                  struct dsd_lnum *adsp_tmp_8,
                                  struct dsd_lnum *adsp_tmp_impl_1,
                                  struct dsd_lnum *adsp_tmp_impl_2)
{
    adsp_result->iec_representation = ied_jacobian;
    m_square_mont(adsp_tmp_1, adsp_point_to_double->adsc_x, adsp_mont_ctx, adsp_tmp_impl_1, adsp_tmp_impl_2);
    m_square_mont(adsp_tmp_2, adsp_point_to_double->adsc_y, adsp_mont_ctx, adsp_tmp_impl_1, adsp_tmp_impl_2);
    m_square_mont(adsp_tmp_3, adsp_tmp_2, adsp_mont_ctx, adsp_tmp_impl_1, adsp_tmp_impl_2);
    m_square_mont(adsp_tmp_4, adsp_point_to_double->adsc_z, adsp_mont_ctx, adsp_tmp_impl_1, adsp_tmp_impl_2);
    ms_lnum_add_mod(adsp_tmp_5, adsp_point_to_double->adsc_x, adsp_tmp_2, adsp_ec_params->adsc_prime);
    m_square_mont(adsp_tmp_6, adsp_tmp_5, adsp_mont_ctx, adsp_tmp_impl_1, adsp_tmp_impl_2);
    ms_lnum_sub_mod(adsp_tmp_6, adsp_tmp_6, adsp_tmp_1, adsp_ec_params->adsc_prime);
    ms_lnum_sub_mod(adsp_tmp_6, adsp_tmp_6, adsp_tmp_3, adsp_ec_params->adsc_prime);
    ms_lnum_add_mod(adsp_tmp_6, adsp_tmp_6, adsp_tmp_6, adsp_ec_params->adsc_prime);
    m_square_mont(adsp_tmp_5, adsp_tmp_4, adsp_mont_ctx, adsp_tmp_impl_1, adsp_tmp_impl_2);
    m_mul_mont(adsp_tmp_7, adsp_ec_params->adsc_a, adsp_tmp_5, adsp_mont_ctx, adsp_tmp_impl_1, adsp_tmp_impl_2);
    ms_lnum_add_mod(adsp_tmp_7, adsp_tmp_7, adsp_tmp_1, adsp_ec_params->adsc_prime);
    ms_lnum_add_mod(adsp_tmp_7, adsp_tmp_7, adsp_tmp_1, adsp_ec_params->adsc_prime);
    ms_lnum_add_mod(adsp_tmp_7, adsp_tmp_7, adsp_tmp_1, adsp_ec_params->adsc_prime);
    m_square_mont(adsp_tmp_8, adsp_tmp_7, adsp_mont_ctx, adsp_tmp_impl_1, adsp_tmp_impl_2);
    ms_lnum_sub_mod(adsp_tmp_8, adsp_tmp_8, adsp_tmp_6, adsp_ec_params->adsc_prime);

    ms_lnum_sub_mod(adsp_result->adsc_x, adsp_tmp_8, adsp_tmp_6, adsp_ec_params->adsc_prime);
    // to ensure that used_size_words and boc_is_negative do not contain old or uninitialized values
    adsp_result->adsc_x->szc_used_size_bytes = adsp_ec_params->adsc_prime->szc_used_size_bytes;
    adsp_result->adsc_x->boc_is_negative = FALSE;

    ms_lnum_sub_mod(adsp_tmp_8, adsp_tmp_6, adsp_result->adsc_x, adsp_ec_params->adsc_prime);
    m_mul_mont(adsp_tmp_5, adsp_tmp_7, adsp_tmp_8, adsp_mont_ctx, adsp_tmp_impl_1, adsp_tmp_impl_2);
    ms_lnum_add_mod(adsp_tmp_3, adsp_tmp_3, adsp_tmp_3, adsp_ec_params->adsc_prime);
    ms_lnum_add_mod(adsp_tmp_3, adsp_tmp_3, adsp_tmp_3, adsp_ec_params->adsc_prime);
    ms_lnum_add_mod(adsp_tmp_3, adsp_tmp_3, adsp_tmp_3, adsp_ec_params->adsc_prime);
    ms_lnum_add_mod(adsp_tmp_8, adsp_point_to_double->adsc_y, adsp_point_to_double->adsc_z, adsp_ec_params->adsc_prime);

    ms_lnum_sub_mod(adsp_result->adsc_y, adsp_tmp_5, adsp_tmp_3, adsp_ec_params->adsc_prime);
    // to ensure that used_size_words and boc_is_negative do not contain old or uninitialized values
    adsp_result->adsc_y->szc_used_size_bytes = adsp_ec_params->adsc_prime->szc_used_size_bytes;
    adsp_result->adsc_y->boc_is_negative = FALSE;

    m_square_mont(adsp_tmp_1, adsp_tmp_8, adsp_mont_ctx, adsp_tmp_impl_1, adsp_tmp_impl_2);
    ms_lnum_sub_mod(adsp_tmp_1, adsp_tmp_1, adsp_tmp_2, adsp_ec_params->adsc_prime);

    ms_lnum_sub_mod(adsp_result->adsc_z, adsp_tmp_1, adsp_tmp_4, adsp_ec_params->adsc_prime);
    // to ensure that used_size_words and boc_is_negative do not contain old or uninitialized values
    adsp_result->adsc_z->szc_used_size_bytes = adsp_ec_params->adsc_prime->szc_used_size_bytes;
    adsp_result->adsc_z->boc_is_negative = FALSE;
} // ms_ecpt_weier_dbl_jac

/**
   Algorithm for doubling an affine EC point in montgomery form.
   Inplace possible.
   adsp_result must be allocated with used_words of prime, point_to_double has
   to be filled with 0s to the size of prime.

   @param[in,out] adsp_result          Result
   @param[in]     adsp_point_to_double Source
   @param[in]     adsp_mont_ctx        Montgomery-context
   @param[in]     adsp_ec_params       elliptic curve parameters (in montgomery form)
   @param[in]     adsp_tmp_1           temp lnums for
   @param[in]     adsp_tmp_2           computations with
   @param[in]     adsp_tmp_3           alloc size double
   @param[in]     adsp_tmp_4           the size of modulus
   @param[in]     adsp_tmp_5           + 1 in words
   @param[in]     adsp_tmp_impl_1
   @param[in]     adsp_tmp_impl_2
 */
static void ms_ecpt_weier_dbl_aff(struct dsd_ec_point* adsp_result,
                                  const struct dsd_ec_point* adsp_point_to_double,
                                  const struct dsd_lnum_montgomery_ctx* adsp_mont_ctx,
                                  const struct dsd_ec_curve_params* adsp_ec_params,
                                  struct dsd_lnum *adsp_tmp_1,
                                  struct dsd_lnum *adsp_tmp_2,
                                  struct dsd_lnum *adsp_tmp_3,
                                  struct dsd_lnum *adsp_tmp_4,
                                  struct dsd_lnum *adsp_tmp_5,
                                  struct dsd_lnum *adsp_tmp_impl_1,
                                  struct dsd_lnum *adsp_tmp_impl_2)
{
    adsp_result->iec_representation = ied_jacobian;
    m_square_mont(adsp_tmp_1, adsp_point_to_double->adsc_x, adsp_mont_ctx, adsp_tmp_impl_1, adsp_tmp_impl_2);
    m_square_mont(adsp_tmp_2, adsp_point_to_double->adsc_y, adsp_mont_ctx, adsp_tmp_impl_1, adsp_tmp_impl_2);
    m_square_mont(adsp_tmp_3, adsp_tmp_2, adsp_mont_ctx, adsp_tmp_impl_1, adsp_tmp_impl_2);
    ms_lnum_add_mod(adsp_tmp_2, adsp_point_to_double->adsc_x, adsp_tmp_2, adsp_ec_params->adsc_prime);
    m_square_mont(adsp_tmp_4, adsp_tmp_2, adsp_mont_ctx, adsp_tmp_impl_1, adsp_tmp_impl_2);
    ms_lnum_sub_mod(adsp_tmp_4, adsp_tmp_4, adsp_tmp_1, adsp_ec_params->adsc_prime);
    ms_lnum_sub_mod(adsp_tmp_4, adsp_tmp_4, adsp_tmp_3, adsp_ec_params->adsc_prime);
    ms_lnum_add_mod(adsp_tmp_4, adsp_tmp_4, adsp_tmp_4, adsp_ec_params->adsc_prime);
    ms_lnum_add_mod(adsp_tmp_5, adsp_tmp_1, adsp_tmp_1, adsp_ec_params->adsc_prime);
    ms_lnum_add_mod(adsp_tmp_5, adsp_tmp_5, adsp_tmp_1, adsp_ec_params->adsc_prime);
    ms_lnum_add_mod(adsp_tmp_5, adsp_tmp_5, adsp_ec_params->adsc_a, adsp_ec_params->adsc_prime);
    m_square_mont(adsp_tmp_2, adsp_tmp_5, adsp_mont_ctx, adsp_tmp_impl_1, adsp_tmp_impl_2);
    ms_lnum_sub_mod(adsp_tmp_2, adsp_tmp_2, adsp_tmp_4, adsp_ec_params->adsc_prime);

    ms_lnum_sub_mod(adsp_result->adsc_x, adsp_tmp_2, adsp_tmp_4, adsp_ec_params->adsc_prime);
    // to ensure that used_size_words and boc_is_negative do not contain old or uninitialized values
    adsp_result->adsc_x->szc_used_size_bytes = adsp_ec_params->adsc_prime->szc_used_size_bytes;
    adsp_result->adsc_x->boc_is_negative = FALSE;

    ms_lnum_sub_mod(adsp_tmp_4, adsp_tmp_4, adsp_result->adsc_x, adsp_ec_params->adsc_prime);
    m_mul_mont(adsp_tmp_2, adsp_tmp_5, adsp_tmp_4, adsp_mont_ctx, adsp_tmp_impl_1, adsp_tmp_impl_2);
    ms_lnum_add_mod(adsp_tmp_3, adsp_tmp_3, adsp_tmp_3, adsp_ec_params->adsc_prime);
    ms_lnum_add_mod(adsp_tmp_3, adsp_tmp_3, adsp_tmp_3, adsp_ec_params->adsc_prime);
    ms_lnum_add_mod(adsp_tmp_3, adsp_tmp_3, adsp_tmp_3, adsp_ec_params->adsc_prime);

    ms_lnum_add_mod(adsp_result->adsc_z,
                    adsp_point_to_double->adsc_y,
                    adsp_point_to_double->adsc_y,
                    adsp_ec_params->adsc_prime);
    // to ensure that used_size_words and boc_is_negative do not contain old or uninitialized values
    adsp_result->adsc_z->szc_used_size_bytes = adsp_ec_params->adsc_prime->szc_used_size_bytes;
    adsp_result->adsc_z->boc_is_negative = FALSE;

    ms_lnum_sub_mod(adsp_result->adsc_y, adsp_tmp_2, adsp_tmp_3, adsp_ec_params->adsc_prime);
    // to ensure that used_size_words and boc_is_negative do not contain old or uninitialized values
    adsp_result->adsc_y->szc_used_size_bytes = adsp_ec_params->adsc_prime->szc_used_size_bytes;
    adsp_result->adsc_y->boc_is_negative = FALSE;
} // ms_ecpt_weier_dbl_aff

/**
   function for doubling an EC point without the checks that are done in the extern
   functions and without pool gets. Inplace possible.
   point to doulbe must be filled with 0s to the size of prime.
   Result is filled with zeros.

   @param[in,out] adsp_result          Result
   @param[in]     adsp_tmp_1           temp lnums for
   @param[in]     adsp_tmp_2           computations with
   @param[in]     adsp_tmp_3           alloc size double
   @param[in]     adsp_tmp_4           the size of modulus
   @param[in]     adsp_tmp_5           + 1 in words
   @param[in]     adsp_tmp_6
   @param[in]     adsp_tmp_7
   @param[in]     adsp_tmp_8
   @param[in]     adsp_tmp_impl_1
   @param[in]     adsp_tmp_impl_2
   @param[in]     adsp_mont_ctx        Montgomery-context
   @param[in]     adsp_point_to_double Source
   @param[in]     adsp_ec_params       elliptic curve parameters (in montgomery form)
 */
extern "C" void m_ecpt_weier_dbl(struct dsd_ec_point* adsp_result,
                                 struct dsd_lnum *adsp_tmp_1,
                                 struct dsd_lnum *adsp_tmp_2,
                                 struct dsd_lnum *adsp_tmp_3,
                                 struct dsd_lnum *adsp_tmp_4,
                                 struct dsd_lnum *adsp_tmp_5,
                                 struct dsd_lnum *adsp_tmp_6,
                                 struct dsd_lnum *adsp_tmp_7,
                                 struct dsd_lnum *adsp_tmp_8,
                                 struct dsd_lnum *adsp_tmp_impl_1,
                                 struct dsd_lnum *adsp_tmp_impl_2,
                                 const struct dsd_lnum_montgomery_ctx* adsp_mont_ctx,
                                 const struct dsd_ec_point* adsp_point_to_double,
                                 const struct dsd_ec_curve_params* adsp_ec_params)
{
    if (adsp_point_to_double->iec_representation == ied_neutral) {
        adsp_result->iec_representation = ied_neutral;
        return;
    }
    if (adsp_point_to_double->iec_representation == ied_affine) {
        return ms_ecpt_weier_dbl_aff(adsp_result,
                                     adsp_point_to_double,
                                     adsp_mont_ctx,
                                     adsp_ec_params,
                                     adsp_tmp_1,
                                     adsp_tmp_2,
                                     adsp_tmp_3,
                                     adsp_tmp_4,
                                     adsp_tmp_5,
                                     adsp_tmp_impl_1,
                                     adsp_tmp_impl_2);
    } else {
        return ms_ecpt_weier_dbl_jac(adsp_result,
                                     adsp_point_to_double,
                                     adsp_mont_ctx,
                                     adsp_ec_params,
                                     adsp_tmp_1,
                                     adsp_tmp_2,
                                     adsp_tmp_3,
                                     adsp_tmp_4,
                                     adsp_tmp_5,
                                     adsp_tmp_6,
                                     adsp_tmp_7,
                                     adsp_tmp_8,
                                     adsp_tmp_impl_1,
                                     adsp_tmp_impl_2);
    }
} // m_ecpt_weier_dbl

/**
   Checks if the value of an lnum is zero if used words member is not set to zero
   (e.g., when using impl functions)

   @param[in]      adsp_lnum           lnum
   @param[in]      inp_words_to_check  number of words that will be checked
                                    ensure that lnum is allocated big enought

   @returns TRUE if zero, FALSE if not.
 */
static bool ms_lnum_is_value_zero(struct dsd_lnum* adsp_lnum,
                                  size_t szp_words_to_check)
{
    for (size_t szl_i = 0; szl_i < szp_words_to_check; szl_i++) {
        if (((LNUM_WORD*)(adsp_lnum->aucc_data))[ szl_i]) {
            return FALSE;
        }
    }
    return TRUE;
}


/**
   Algorithm for adding two jacobian EC points in montgomery form. Inplace possible.
   adsp_result must be allocated with used_words of prime, both summands have
   to be filled with 0s to the size of prime. Both summands must not be the neutral element.

   @param[in,out] adsp_result          Result
   @param[in]     adsp_summand_1       Summand 1
   @param[in]     adsp_summand_2       Summand 2
   @param[in]     adsp_mont_ctx        Montgomery-context
   @param[in]     adsp_ec_params       elliptic curve parameters (in montgomery form)
   @param[in]     adsp_tmp_1           temp lnums for
   @param[in]     adsp_tmp_2           computations with
   @param[in]     adsp_tmp_3           alloc size double
   @param[in]     adsp_tmp_4           the size of modulus
   @param[in]     adsp_tmp_5           + 1 in words
   @param[in]     adsp_tmp_6
   @param[in]     adsp_tmp_7
   @param[in]     adsp_tmp_8
   @param[in]     adsp_tmp_9
   @param[in]     adsp_tmp_10
   @param[in]     adsp_tmp_impl_1
   @param[in]     adsp_tmp_impl_2
 */
static void ms_ecpt_weier_add_jac_jac(struct dsd_ec_point* adsp_result,
                                      const struct dsd_ec_point* adsp_summand_1,
                                      const struct dsd_ec_point* adsp_summand_2,
                                      const struct dsd_lnum_montgomery_ctx* adsp_mont_ctx,
                                      const struct dsd_ec_curve_params* adsp_ec_params,
                                      dsd_lnum *adsp_tmp_1,
                                      dsd_lnum *adsp_tmp_2,
                                      dsd_lnum *adsp_tmp_3,
                                      dsd_lnum *adsp_tmp_4,
                                      dsd_lnum *adsp_tmp_5,
                                      dsd_lnum *adsp_tmp_6,
                                      dsd_lnum *adsp_tmp_7,
                                      dsd_lnum *adsp_tmp_8,
                                      dsd_lnum *adsp_tmp_9,
                                      dsd_lnum *adsp_tmp_10,
                                      dsd_lnum *adsp_tmp_impl_1,
                                      dsd_lnum *adsp_tmp_impl_2)
{
    adsp_result->iec_representation = ied_jacobian;
    m_square_mont(adsp_tmp_1, adsp_summand_1->adsc_z, adsp_mont_ctx, adsp_tmp_impl_1, adsp_tmp_impl_2);
    m_square_mont(adsp_tmp_2, adsp_summand_2->adsc_z, adsp_mont_ctx, adsp_tmp_impl_1, adsp_tmp_impl_2);
    m_mul_mont(adsp_tmp_3, adsp_summand_1->adsc_x, adsp_tmp_2, adsp_mont_ctx, adsp_tmp_impl_1, adsp_tmp_impl_2);
    m_mul_mont(adsp_tmp_4, adsp_summand_2->adsc_x, adsp_tmp_1, adsp_mont_ctx, adsp_tmp_impl_1, adsp_tmp_impl_2);
    m_mul_mont(adsp_tmp_5, adsp_summand_2->adsc_z, adsp_tmp_2, adsp_mont_ctx, adsp_tmp_impl_1, adsp_tmp_impl_2);
    m_mul_mont(adsp_tmp_6, adsp_summand_1->adsc_y, adsp_tmp_5, adsp_mont_ctx, adsp_tmp_impl_1, adsp_tmp_impl_2);
    m_mul_mont(adsp_tmp_5, adsp_summand_1->adsc_z, adsp_tmp_1, adsp_mont_ctx, adsp_tmp_impl_1, adsp_tmp_impl_2);
    m_mul_mont(adsp_tmp_7, adsp_summand_2->adsc_y, adsp_tmp_5, adsp_mont_ctx, adsp_tmp_impl_1, adsp_tmp_impl_2);
    ms_lnum_sub_mod(adsp_tmp_8, adsp_tmp_4, adsp_tmp_3, adsp_ec_params->adsc_prime);

    // same or inverse point?
    if (ms_lnum_is_value_zero(adsp_tmp_8, adsp_ec_params->adsc_prime->szc_used_size_bytes / sizeof(LNUM_WORD))) {
        ms_lnum_sub_mod(adsp_tmp_5, adsp_tmp_7, adsp_tmp_6, adsp_ec_params->adsc_prime);
        if (ms_lnum_is_value_zero(adsp_tmp_5, adsp_ec_params->adsc_prime->szc_used_size_bytes / sizeof(LNUM_WORD))) {
            ms_ecpt_weier_dbl_jac(adsp_result,
                                  adsp_summand_2,
                                  adsp_mont_ctx,
                                  adsp_ec_params,
                                  adsp_tmp_1,
                                  adsp_tmp_2,
                                  adsp_tmp_3,
                                  adsp_tmp_4,
                                  adsp_tmp_5,
                                  adsp_tmp_6,
                                  adsp_tmp_7,
                                  adsp_tmp_8,
                                  adsp_tmp_impl_1,
                                  adsp_tmp_impl_2);
            return;
        } else {
            adsp_result->iec_representation = ied_neutral;
            return;
        }
    }

    ms_lnum_add_mod(adsp_tmp_5, adsp_tmp_8, adsp_tmp_8, adsp_ec_params->adsc_prime);
    m_square_mont(adsp_tmp_9, adsp_tmp_5, adsp_mont_ctx, adsp_tmp_impl_1, adsp_tmp_impl_2);
    m_mul_mont(adsp_tmp_10, adsp_tmp_8, adsp_tmp_9, adsp_mont_ctx, adsp_tmp_impl_1, adsp_tmp_impl_2);
    ms_lnum_sub_mod(adsp_tmp_7, adsp_tmp_7, adsp_tmp_6, adsp_ec_params->adsc_prime);
    ms_lnum_add_mod(adsp_tmp_7, adsp_tmp_7, adsp_tmp_7, adsp_ec_params->adsc_prime);
    m_mul_mont(adsp_tmp_4, adsp_tmp_3, adsp_tmp_9, adsp_mont_ctx, adsp_tmp_impl_1, adsp_tmp_impl_2);
    m_square_mont(adsp_tmp_5, adsp_tmp_7, adsp_mont_ctx, adsp_tmp_impl_1, adsp_tmp_impl_2);
    ms_lnum_sub_mod(adsp_tmp_5, adsp_tmp_5, adsp_tmp_10, adsp_ec_params->adsc_prime);
    ms_lnum_sub_mod(adsp_tmp_5, adsp_tmp_5, adsp_tmp_4, adsp_ec_params->adsc_prime);

    ms_lnum_sub_mod(adsp_result->adsc_x, adsp_tmp_5, adsp_tmp_4, adsp_ec_params->adsc_prime);
    // to ensure that used_size_words and boc_is_negative do not contain old or uninitialized values
    adsp_result->adsc_x->szc_used_size_bytes = adsp_ec_params->adsc_prime->szc_used_size_bytes;
    adsp_result->adsc_x->boc_is_negative = FALSE;

    m_mul_mont(adsp_tmp_9, adsp_tmp_6, adsp_tmp_10, adsp_mont_ctx, adsp_tmp_impl_1, adsp_tmp_impl_2);
    ms_lnum_add_mod(adsp_tmp_9, adsp_tmp_9, adsp_tmp_9, adsp_ec_params->adsc_prime);
    ms_lnum_sub_mod(adsp_tmp_10, adsp_tmp_4, adsp_result->adsc_x, adsp_ec_params->adsc_prime);
    m_mul_mont(adsp_tmp_4, adsp_tmp_7, adsp_tmp_10, adsp_mont_ctx, adsp_tmp_impl_1, adsp_tmp_impl_2);

    ms_lnum_sub_mod(adsp_result->adsc_y, adsp_tmp_4, adsp_tmp_9, adsp_ec_params->adsc_prime);
    // to ensure that used_size_words and boc_is_negative do not contain old or uninitialized values
    adsp_result->adsc_y->szc_used_size_bytes = adsp_ec_params->adsc_prime->szc_used_size_bytes;
    adsp_result->adsc_y->boc_is_negative = FALSE;

    ms_lnum_add_mod(adsp_tmp_3, adsp_summand_1->adsc_z, adsp_summand_2->adsc_z, adsp_ec_params->adsc_prime);
    m_square_mont(adsp_tmp_4, adsp_tmp_3, adsp_mont_ctx, adsp_tmp_impl_1, adsp_tmp_impl_2);
    ms_lnum_sub_mod(adsp_tmp_4, adsp_tmp_4, adsp_tmp_1, adsp_ec_params->adsc_prime);
    ms_lnum_sub_mod(adsp_tmp_4, adsp_tmp_4, adsp_tmp_2, adsp_ec_params->adsc_prime);

    m_mul_mont(adsp_result->adsc_z, adsp_tmp_4, adsp_tmp_8, adsp_mont_ctx, adsp_tmp_impl_1, adsp_tmp_impl_2);
    // to ensure that used_size_words and boc_is_negative do not contain old or uninitialized values
    adsp_result->adsc_z->szc_used_size_bytes = adsp_ec_params->adsc_prime->szc_used_size_bytes;
    adsp_result->adsc_z->boc_is_negative = FALSE;
} // ms_ecpt_weier_add_jac_jac

/**
   Algorithm for adding two affine EC points in montgomery form. Inplace possible.
   adsp_result must be allocated with used_words of prime, both summands have
   to be filled with 0s to the size of prime. Both summands must not be the neutral element.

   @param[in,out] adsp_result          Result
   @param[in]     adsp_summand_1       Summand 1
   @param[in]     adsp_summand_2       Summand 2
   @param[in]     adsp_mont_ctx        Montgomery-context
   @param[in]     adsp_ec_params       elliptic curve parameters (in montgomery form)
   @param[in]     adsp_tmp_1           temp lnums for
   @param[in]     adsp_tmp_2           computations with
   @param[in]     adsp_tmp_3           alloc size double
   @param[in]     adsp_tmp_4           the size of modulus
   @param[in]     adsp_tmp_5           + 1 in words
   @param[in]     adsp_tmp_impl_1
   @param[in]     adsp_tmp_impl_2
 */
static void ms_ecpt_weier_add_aff_aff(struct dsd_ec_point* adsp_result,
                                      const struct dsd_ec_point* adsp_summand_1,
                                      const struct dsd_ec_point* adsp_summand_2,
                                      const struct dsd_lnum_montgomery_ctx* adsp_mont_ctx,
                                      const struct dsd_ec_curve_params* adsp_ec_params,
                                      dsd_lnum *adsp_tmp_1,
                                      dsd_lnum *adsp_tmp_2,
                                      dsd_lnum *adsp_tmp_3,
                                      dsd_lnum *adsp_tmp_4,
                                      dsd_lnum *adsp_tmp_5,
                                      dsd_lnum *adsp_tmp_impl_1,
                                      dsd_lnum *adsp_tmp_impl_2)
{
    adsp_result->iec_representation = ied_jacobian;
    ms_lnum_sub_mod(adsp_tmp_1, adsp_summand_2->adsc_x, adsp_summand_1->adsc_x, adsp_ec_params->adsc_prime);
    // same or inverse point?
    if (ms_lnum_is_value_zero(adsp_tmp_1, adsp_ec_params->adsc_prime->szc_used_size_bytes / sizeof(LNUM_WORD))) {
        ms_lnum_sub_mod(adsp_tmp_1, adsp_summand_2->adsc_y, adsp_summand_1->adsc_y, adsp_ec_params->adsc_prime);
        if (ms_lnum_is_value_zero(adsp_tmp_1, adsp_ec_params->adsc_prime->szc_used_size_bytes / sizeof(LNUM_WORD))) {
            ms_ecpt_weier_dbl_aff(adsp_result,
                                  adsp_summand_2,
                                  adsp_mont_ctx,
                                  adsp_ec_params,
                                  adsp_tmp_1,
                                  adsp_tmp_2,
                                  adsp_tmp_3,
                                  adsp_tmp_4,
                                  adsp_tmp_5,
                                  adsp_tmp_impl_1,
                                  adsp_tmp_impl_2);
            return;
        } else {
            adsp_result->iec_representation = ied_neutral;
            return;
        }
    }

    ms_lnum_add_mod(adsp_result->adsc_z, adsp_tmp_1, adsp_tmp_1, adsp_ec_params->adsc_prime);
    // to ensure that used_size_words and boc_is_negative do not contain old or uninitialized values
    adsp_result->adsc_z->szc_used_size_bytes = adsp_ec_params->adsc_prime->szc_used_size_bytes;
    adsp_result->adsc_z->boc_is_negative = FALSE;

    m_square_mont(adsp_tmp_2, adsp_tmp_1, adsp_mont_ctx, adsp_tmp_impl_1, adsp_tmp_impl_2);
    ms_lnum_add_mod(adsp_tmp_2, adsp_tmp_2, adsp_tmp_2, adsp_ec_params->adsc_prime);
    ms_lnum_add_mod(adsp_tmp_2, adsp_tmp_2, adsp_tmp_2, adsp_ec_params->adsc_prime);
    m_mul_mont(adsp_tmp_3, adsp_tmp_1, adsp_tmp_2, adsp_mont_ctx, adsp_tmp_impl_1, adsp_tmp_impl_2);
    m_mul_mont(adsp_tmp_4, adsp_summand_1->adsc_x, adsp_tmp_2, adsp_mont_ctx, adsp_tmp_impl_1, adsp_tmp_impl_2);
    ms_lnum_sub_mod(adsp_tmp_2, adsp_summand_2->adsc_y, adsp_summand_1->adsc_y, adsp_ec_params->adsc_prime);
    ms_lnum_add_mod(adsp_tmp_2, adsp_tmp_2, adsp_tmp_2, adsp_ec_params->adsc_prime);
    m_square_mont(adsp_result->adsc_x, adsp_tmp_2, adsp_mont_ctx, adsp_tmp_impl_1, adsp_tmp_impl_2);
    ms_lnum_sub_mod(adsp_result->adsc_x, adsp_result->adsc_x, adsp_tmp_3, adsp_ec_params->adsc_prime);
    ms_lnum_sub_mod(adsp_result->adsc_x, adsp_result->adsc_x, adsp_tmp_4, adsp_ec_params->adsc_prime);

    ms_lnum_sub_mod(adsp_result->adsc_x, adsp_result->adsc_x, adsp_tmp_4, adsp_ec_params->adsc_prime);
    // to ensure that used_size_words and boc_is_negative do not contain old or uninitialized values
    adsp_result->adsc_x->szc_used_size_bytes = adsp_ec_params->adsc_prime->szc_used_size_bytes;
    adsp_result->adsc_x->boc_is_negative = FALSE;

    ms_lnum_sub_mod(adsp_tmp_4, adsp_tmp_4, adsp_result->adsc_x, adsp_ec_params->adsc_prime);
    m_mul_mont(adsp_tmp_1, adsp_tmp_2, adsp_tmp_4, adsp_mont_ctx, adsp_tmp_impl_1, adsp_tmp_impl_2);
    m_mul_mont(adsp_tmp_4, adsp_summand_1->adsc_y, adsp_tmp_3, adsp_mont_ctx, adsp_tmp_impl_1, adsp_tmp_impl_2);
    ms_lnum_add_mod(adsp_tmp_4, adsp_tmp_4, adsp_tmp_4, adsp_ec_params->adsc_prime);

    ms_lnum_sub_mod(adsp_result->adsc_y, adsp_tmp_1, adsp_tmp_4, adsp_ec_params->adsc_prime);
    // to ensure that used_size_words and boc_is_negative do not contain old or uninitialized values
    adsp_result->adsc_y->szc_used_size_bytes = adsp_ec_params->adsc_prime->szc_used_size_bytes;
    adsp_result->adsc_y->boc_is_negative = FALSE;
} // ms_ecpt_weier_add_aff_aff

/**
   Algorithm for adding a jacobian and an affine EC point in montgomery. Inplace possible.
   adsp_result must be allocated with used_words of prime, both summands have
   to be filled with 0s to the size of prime. Both summands must not be the neutral element.

   @param[in,out] adsp_result          Result
   @param[in]     adsp_summand_1       Summand 1
   @param[in]     adsp_summand_2       Summand 2
   @param[in]     adsp_mont_ctx        Montgomery-context
   @param[in]     adsp_ec_params       elliptic curve parameters (in montgomery form)
   @param[in]     adsp_tmp_1           temp lnums for
   @param[in]     adsp_tmp_2           computations with
   @param[in]     adsp_tmp_3           alloc size double
   @param[in]     adsp_tmp_4           the size of modulus
   @param[in]     adsp_tmp_5           + 1 in words
   @param[in]     adsp_tmp_6
   @param[in]     adsp_tmp_7
   @param[in]     adsp_tmp_8
   @param[in]     adsp_tmp_impl_1
   @param[in]     adsp_tmp_impl_2
 */
static void ms_ecpt_weier_add_jac_aff(struct dsd_ec_point* adsp_result,
                                      const struct dsd_ec_point* adsp_summand_1,
                                      const struct dsd_ec_point* adsp_summand_2,
                                      const struct dsd_lnum_montgomery_ctx* adsp_mont_ctx,
                                      const struct dsd_ec_curve_params* adsp_ec_params,
                                      dsd_lnum *adsp_tmp_1,
                                      dsd_lnum *adsp_tmp_2,
                                      dsd_lnum *adsp_tmp_3,
                                      dsd_lnum *adsp_tmp_4,
                                      dsd_lnum *adsp_tmp_5,
                                      dsd_lnum *adsp_tmp_6,
                                      dsd_lnum *adsp_tmp_7,
                                      dsd_lnum *adsp_tmp_8,
                                      dsd_lnum *adsp_tmp_impl_1,
                                      dsd_lnum *adsp_tmp_impl_2)
{
    adsp_result->iec_representation = ied_jacobian;
    m_square_mont(adsp_tmp_1, adsp_summand_1->adsc_z, adsp_mont_ctx, adsp_tmp_impl_1, adsp_tmp_impl_2);
    m_mul_mont(adsp_tmp_2, adsp_summand_2->adsc_x, adsp_tmp_1, adsp_mont_ctx, adsp_tmp_impl_1, adsp_tmp_impl_2);
    m_mul_mont(adsp_tmp_3, adsp_summand_1->adsc_z, adsp_tmp_1, adsp_mont_ctx, adsp_tmp_impl_1, adsp_tmp_impl_2);
    m_mul_mont(adsp_tmp_4, adsp_summand_2->adsc_y, adsp_tmp_3, adsp_mont_ctx, adsp_tmp_impl_1, adsp_tmp_impl_2);
    ms_lnum_sub_mod(adsp_tmp_2, adsp_tmp_2, adsp_summand_1->adsc_x, adsp_ec_params->adsc_prime);

    // same or inverse point?
    if (ms_lnum_is_value_zero(adsp_tmp_2, adsp_ec_params->adsc_prime->szc_used_size_bytes / sizeof(LNUM_WORD))) {
        ms_lnum_sub_mod(adsp_tmp_3, adsp_tmp_4, adsp_summand_1->adsc_y, adsp_ec_params->adsc_prime);
        if (ms_lnum_is_value_zero(adsp_tmp_3, adsp_ec_params->adsc_prime->szc_used_size_bytes / sizeof(LNUM_WORD))) {
            ms_ecpt_weier_dbl_aff(adsp_result,
                                  adsp_summand_2,
                                  adsp_mont_ctx,
                                  adsp_ec_params,
                                  adsp_tmp_1,
                                  adsp_tmp_2,
                                  adsp_tmp_3,
                                  adsp_tmp_4,
                                  adsp_tmp_5,
                                  adsp_tmp_impl_1,
                                  adsp_tmp_impl_2);
            return;
        } else {
            adsp_result->iec_representation = ied_neutral;
            return;
        }
    }

    m_square_mont(adsp_tmp_3, adsp_tmp_2, adsp_mont_ctx, adsp_tmp_impl_1, adsp_tmp_impl_2);
    ms_lnum_add_mod(adsp_tmp_5, adsp_tmp_3, adsp_tmp_3, adsp_ec_params->adsc_prime);
    ms_lnum_add_mod(adsp_tmp_5, adsp_tmp_5, adsp_tmp_5, adsp_ec_params->adsc_prime);
    m_mul_mont(adsp_tmp_6, adsp_tmp_2, adsp_tmp_5, adsp_mont_ctx, adsp_tmp_impl_1, adsp_tmp_impl_2);
    ms_lnum_sub_mod(adsp_tmp_7, adsp_tmp_4, adsp_summand_1->adsc_y, adsp_ec_params->adsc_prime);
    ms_lnum_add_mod(adsp_tmp_7, adsp_tmp_7, adsp_tmp_7, adsp_ec_params->adsc_prime);
    m_mul_mont(adsp_tmp_8, adsp_summand_1->adsc_x, adsp_tmp_5, adsp_mont_ctx, adsp_tmp_impl_1, adsp_tmp_impl_2);
    m_square_mont(adsp_tmp_5, adsp_tmp_7, adsp_mont_ctx, adsp_tmp_impl_1, adsp_tmp_impl_2);
    ms_lnum_sub_mod(adsp_tmp_5, adsp_tmp_5, adsp_tmp_6, adsp_ec_params->adsc_prime);
    ms_lnum_sub_mod(adsp_tmp_5, adsp_tmp_5, adsp_tmp_8, adsp_ec_params->adsc_prime);

    ms_lnum_sub_mod(adsp_result->adsc_x, adsp_tmp_5, adsp_tmp_8, adsp_ec_params->adsc_prime);
    // to ensure that used_size_words and boc_is_negative do not contain old or uninitialized values
    adsp_result->adsc_x->szc_used_size_bytes = adsp_ec_params->adsc_prime->szc_used_size_bytes;
    adsp_result->adsc_x->boc_is_negative = FALSE;

    ms_lnum_sub_mod(adsp_tmp_5, adsp_tmp_8, adsp_result->adsc_x, adsp_ec_params->adsc_prime);
    m_mul_mont(adsp_tmp_4, adsp_tmp_7, adsp_tmp_5, adsp_mont_ctx, adsp_tmp_impl_1, adsp_tmp_impl_2);
    m_mul_mont(adsp_tmp_5, adsp_summand_1->adsc_y, adsp_tmp_6, adsp_mont_ctx, adsp_tmp_impl_1, adsp_tmp_impl_2);
    ms_lnum_add_mod(adsp_tmp_5, adsp_tmp_5, adsp_tmp_5, adsp_ec_params->adsc_prime);

    ms_lnum_sub_mod(adsp_result->adsc_y, adsp_tmp_4, adsp_tmp_5, adsp_ec_params->adsc_prime);
    // to ensure that used_size_words and boc_is_negative do not contain old or uninitialized values
    adsp_result->adsc_y->szc_used_size_bytes = adsp_ec_params->adsc_prime->szc_used_size_bytes;
    adsp_result->adsc_y->boc_is_negative = FALSE;

    ms_lnum_add_mod(adsp_tmp_4, adsp_summand_1->adsc_z, adsp_tmp_2, adsp_ec_params->adsc_prime);
    m_square_mont(adsp_tmp_5, adsp_tmp_4, adsp_mont_ctx, adsp_tmp_impl_1, adsp_tmp_impl_2);
    ms_lnum_sub_mod(adsp_tmp_5, adsp_tmp_5, adsp_tmp_1, adsp_ec_params->adsc_prime);

    ms_lnum_sub_mod(adsp_result->adsc_z, adsp_tmp_5, adsp_tmp_3, adsp_ec_params->adsc_prime);
    // to ensure that used_size_words and boc_is_negative do not contain old or uninitialized values
    adsp_result->adsc_z->szc_used_size_bytes = adsp_ec_params->adsc_prime->szc_used_size_bytes;
    adsp_result->adsc_z->boc_is_negative = FALSE;
} // ms_ecpt_weier_add_jac_aff

/**
   function for adding two EC points without the checks that are done in the extern
   functions and without pool gets. Inplace possible.
   adsp_result must be allocated with used_words of prime, both summands have
   to be filled with 0s to the size of prime. Result is filled with 0s.

   @param[in,out] adsp_result          Result
   @param[in]     adsp_tmp_1           temp lnums for
   @param[in]     adsp_tmp_2           computations with
   @param[in]     adsp_tmp_3           alloc size double
   @param[in]     adsp_tmp_4           the size of modulus
   @param[in]     adsp_tmp_5           + 1 in words
   @param[in]     adsp_tmp_6
   @param[in]     adsp_tmp_7
   @param[in]     adsp_tmp_8
   @param[in]     adsp_tmp_9
   @param[in]     adsp_tmp_10
   @param[in]     adsp_tmp_impl_1
   @param[in]     adsp_tmp_impl_2
   @param[in]     adsp_mont_ctx        Montgomery-context
   @param[in]     adsp_summand_1       Summand 1
   @param[in]     adsp_summand_2       Summand 2
   @param[in]     adsp_ec_params       elliptic curve parameters (in montgomery form)
 */
extern "C" void m_ecpt_weier_add(struct dsd_ec_point* adsp_result,
                                 struct dsd_lnum *adsp_tmp_1,
                                 struct dsd_lnum *adsp_tmp_2,
                                 struct dsd_lnum *adsp_tmp_3,
                                 struct dsd_lnum *adsp_tmp_4,
                                 struct dsd_lnum *adsp_tmp_5,
                                 struct dsd_lnum *adsp_tmp_6,
                                 struct dsd_lnum *adsp_tmp_7,
                                 struct dsd_lnum *adsp_tmp_8,
                                 struct dsd_lnum *adsp_tmp_9,
                                 struct dsd_lnum *adsp_tmp_10,
                                 struct dsd_lnum *adsp_tmp_impl_1,
                                 struct dsd_lnum *adsp_tmp_impl_2,
                                 const struct dsd_lnum_montgomery_ctx* adsp_mont_ctx,
                                 const struct dsd_ec_point* adsp_summand_1,
                                 const struct dsd_ec_point* adsp_summand_2,
                                 const struct dsd_ec_curve_params* adsp_ec_params)
{
    if (adsp_summand_1->iec_representation == ied_neutral) {
        return ms_ecpt_cpy(adsp_result, adsp_summand_2, adsp_ec_params->adsc_prime);
    }
    if (adsp_summand_2->iec_representation == ied_neutral) {
        return ms_ecpt_cpy(adsp_result, adsp_summand_1, adsp_ec_params->adsc_prime);
    }
    if ((adsp_summand_1->iec_representation == ied_affine)
        && (adsp_summand_2->iec_representation == ied_affine))
    {
        return ms_ecpt_weier_add_aff_aff(adsp_result,
                                         adsp_summand_1,
                                         adsp_summand_2,
                                         adsp_mont_ctx,
                                         adsp_ec_params,
                                         adsp_tmp_1,
                                         adsp_tmp_2,
                                         adsp_tmp_3,
                                         adsp_tmp_4,
                                         adsp_tmp_5,
                                         adsp_tmp_impl_1,
                                         adsp_tmp_impl_2);
    } else if (adsp_summand_2->iec_representation == ied_affine) {
        return ms_ecpt_weier_add_jac_aff(adsp_result,
                                         adsp_summand_1,
                                         adsp_summand_2,
                                         adsp_mont_ctx,
                                         adsp_ec_params,
                                         adsp_tmp_1,
                                         adsp_tmp_2,
                                         adsp_tmp_3,
                                         adsp_tmp_4,
                                         adsp_tmp_5,
                                         adsp_tmp_6,
                                         adsp_tmp_7,
                                         adsp_tmp_8,
                                         adsp_tmp_impl_1,
                                         adsp_tmp_impl_2);
    } else if (adsp_summand_1->iec_representation == ied_affine) {
        return ms_ecpt_weier_add_jac_aff(adsp_result,
                                         adsp_summand_2,
                                         adsp_summand_1,
                                         adsp_mont_ctx,
                                         adsp_ec_params,
                                         adsp_tmp_1,
                                         adsp_tmp_2,
                                         adsp_tmp_3,
                                         adsp_tmp_4,
                                         adsp_tmp_5,
                                         adsp_tmp_6,
                                         adsp_tmp_7,
                                         adsp_tmp_8,
                                         adsp_tmp_impl_1,
                                         adsp_tmp_impl_2);
    } else {
        return ms_ecpt_weier_add_jac_jac(adsp_result,
                                         adsp_summand_1,
                                         adsp_summand_2,
                                         adsp_mont_ctx,
                                         adsp_ec_params,
                                         adsp_tmp_1,
                                         adsp_tmp_2,
                                         adsp_tmp_3,
                                         adsp_tmp_4,
                                         adsp_tmp_5,
                                         adsp_tmp_6,
                                         adsp_tmp_7,
                                         adsp_tmp_8,
                                         adsp_tmp_9,
                                         adsp_tmp_10,
                                         adsp_tmp_impl_1,
                                         adsp_tmp_impl_2);
    }
} // m_ecpt_weier_add

/**
   Check if affine-represented EC point is on curve given by adsp_ec_params

   @param[in,out] adsp_pool            lnum pool
   @param[in]     adsp_point           Point to be checkedScalar
   @param[in]     adsp_ec_params       Curve-parameters
   @param[in]     adsp_tmp_1           tmp lnums with alloc size
   @param[in]     adsp_tmp_2           double the size of modulus

   @return ied_encry_success if on curve, ied_ecc_point_not_on_curve if not, errorcode otherwise
 */
static ied_encry_return ms_ecpt_weier_on_curve_aff(struct dsd_mem_pool_ele* adsp_pool,
                                                   const struct dsd_ec_point* adsp_point,
                                                   const struct dsd_ec_curve_params* adsp_ec_params,
                                                   dsd_lnum *adsp_tmp_1,
                                                   dsd_lnum *adsp_tmp_2)
{
    ied_encry_return iel_return = m_lnum_square(adsp_tmp_1, adsp_pool, adsp_point->adsc_x);
    if (iel_return != ied_encry_success) return iel_return;
    iel_return = m_lnum_add(adsp_tmp_1, adsp_tmp_1, adsp_ec_params->adsc_a);
    if (iel_return != ied_encry_success) return iel_return;
    iel_return = m_lnum_divide(NULL, adsp_tmp_1, adsp_pool, adsp_tmp_1, adsp_ec_params->adsc_prime);
    if (iel_return != ied_encry_success) return iel_return;
    iel_return = m_lnum_mult(adsp_tmp_2, adsp_pool, adsp_point->adsc_x, adsp_tmp_1);
    if (iel_return != ied_encry_success) return iel_return;
    iel_return = m_lnum_add(adsp_tmp_2, adsp_tmp_2, adsp_ec_params->adsc_b_a24);
    if (iel_return != ied_encry_success) return iel_return;
    iel_return = m_lnum_square(adsp_tmp_1, adsp_pool, adsp_point->adsc_y);
    if (iel_return != ied_encry_success) return iel_return;
    iel_return = m_lnum_sub(adsp_tmp_1, adsp_tmp_1, adsp_tmp_2);
    if (iel_return != ied_encry_success) return iel_return;
    iel_return = m_lnum_divide(NULL, adsp_tmp_1, adsp_pool, adsp_tmp_1, adsp_ec_params->adsc_prime);
    if (iel_return != ied_encry_success) return iel_return;
    if (m_lnum_is_zero(adsp_tmp_1)) {
        return ied_encry_success;
    }
    return ied_ecc_point_not_on_curve;
} // ms_ecpt_weier_on_curve_aff

/**
   Check if jacobian-represented EC point is on curve given by adsp_ec_params

   @param[in,out] adsp_pool            lnum pool
   @param[in]     adsp_point           Point to be checked
   @param[in]     adsp_ec_params       Curve-parameters
   @param[in]     adsp_tmp_1           tmp lnums with alloc size
   @param[in]     adsp_tmp_2           double the size of modulus
   @param[in]     adsp_tmp_3
   @param[in]     adsp_tmp_4
   @param[in]     adsp_tmp_5

   @return ied_encry_success if on curve, ied_ecc_point_not_on_curve if not, errorcode otherwise
 */
static ied_encry_return ms_ecpt_weier_on_curve_jac(struct dsd_mem_pool_ele* adsp_pool,
                                                   const struct dsd_ec_point* adsp_point,
                                                   const struct dsd_ec_curve_params* adsp_ec_params,
                                                   dsd_lnum *adsp_tmp_1,
                                                   dsd_lnum *adsp_tmp_2,
                                                   dsd_lnum *adsp_tmp_3)
{
    ied_encry_return iel_return = m_lnum_square(adsp_tmp_1, adsp_pool, adsp_point->adsc_z);
    if (iel_return != ied_encry_success) return iel_return;
    iel_return = m_lnum_divide(NULL, adsp_tmp_1, adsp_pool, adsp_tmp_1, adsp_ec_params->adsc_prime);
    if (iel_return != ied_encry_success) return iel_return;
    iel_return = m_lnum_square(adsp_tmp_2, adsp_pool, adsp_tmp_1);
    if (iel_return != ied_encry_success) return iel_return;
    iel_return = m_lnum_divide(NULL, adsp_tmp_2, adsp_pool, adsp_tmp_2, adsp_ec_params->adsc_prime);
    if (iel_return != ied_encry_success) return iel_return;
    iel_return = m_lnum_mult(adsp_tmp_3, adsp_pool, adsp_tmp_1, adsp_tmp_2);
    if (iel_return != ied_encry_success) return iel_return;
    iel_return = m_lnum_divide(NULL, adsp_tmp_3, adsp_pool, adsp_tmp_3, adsp_ec_params->adsc_prime);
    if (iel_return != ied_encry_success) return iel_return;
    iel_return = m_lnum_mult(adsp_tmp_1, adsp_pool, adsp_ec_params->adsc_a, adsp_tmp_2);
    if (iel_return != ied_encry_success) return iel_return;
    iel_return = m_lnum_square(adsp_tmp_2, adsp_pool, adsp_point->adsc_x);
    if (iel_return != ied_encry_success) return iel_return;
    iel_return = m_lnum_add(adsp_tmp_2, adsp_tmp_2, adsp_tmp_1);
    if (iel_return != ied_encry_success) return iel_return;
    iel_return = m_lnum_divide(NULL, adsp_tmp_2, adsp_pool, adsp_tmp_2, adsp_ec_params->adsc_prime);
    if (iel_return != ied_encry_success) return iel_return;
    iel_return = m_lnum_mult(adsp_tmp_1, adsp_pool, adsp_tmp_2, adsp_point->adsc_x);
    if (iel_return != ied_encry_success) return iel_return;
    iel_return = m_lnum_mult(adsp_tmp_2, adsp_pool, adsp_ec_params->adsc_b_a24, adsp_tmp_3);
    if (iel_return != ied_encry_success) return iel_return;
    iel_return = m_lnum_add(adsp_tmp_1, adsp_tmp_1, adsp_tmp_2);
    if (iel_return != ied_encry_success) return iel_return;
    iel_return = m_lnum_square(adsp_tmp_2, adsp_pool, adsp_point->adsc_y);
    if (iel_return != ied_encry_success) return iel_return;
    iel_return = m_lnum_sub(adsp_tmp_1, adsp_tmp_1, adsp_tmp_2);
    if (iel_return != ied_encry_success) return iel_return;
    iel_return = m_lnum_divide(NULL, adsp_tmp_1, adsp_pool, adsp_tmp_1, adsp_ec_params->adsc_prime);
    if (iel_return != ied_encry_success) return iel_return;
    if (m_lnum_is_zero(adsp_tmp_1)) {
        return ied_encry_success;
    }
    return ied_ecc_point_not_on_curve;
} // ms_ecpt_weier_on_curve_jac

extern "C" ied_encry_return m_ecpt_weier_on_curve(const struct dsd_ec_point* adsp_point,
                                                  struct dsd_mem_pool_ele* adsp_pool,
                                                  const struct dsd_ec_curve_params* adsp_ec_params)
{
    if (!adsp_point || !adsp_pool || !adsp_ec_params) {
        return ied_encry_null_pointer;
    }
    if (adsp_point->iec_representation == ied_neutral) {
        return ied_encry_success;
    }
    int inl_bytes_count_prime = m_lnum_get_byte_count(adsp_ec_params->adsc_prime);
    if (inl_bytes_count_prime <= 0) {
        return ied_encry_invalid_input;
    }
    size_t szl_bytes_for_tmps = 2*adsp_ec_params->adsc_prime->szc_used_size_bytes + sizeof(LNUM_WORD);

    // get stack frame
    dsd_mem_pool_frame dsl_frame = m_mem_pool_get_frame(adsp_pool);
    dsd_lnum *adsl_tmp_1 = m_mem_pool_get_lnum_byte_size(&adsp_pool, szl_bytes_for_tmps);
    dsd_lnum *adsl_tmp_2 = m_mem_pool_get_lnum_byte_size(&adsp_pool, szl_bytes_for_tmps);
    dsd_lnum *adsl_tmp_3 = m_mem_pool_get_lnum_byte_size(&adsp_pool, szl_bytes_for_tmps);
    // same size, so only last tmp has to be checked
    if (!adsl_tmp_3) {
        m_mem_pool_restore_frame(&adsp_pool, dsl_frame);
        return ied_encry_pool_empty;
    }
    ied_encry_return iel_return;
    // TODO: jacobian z=0? working but could be much faster
    if (adsp_point->iec_representation == ied_affine) {
        iel_return = ms_ecpt_weier_on_curve_aff(adsp_pool, adsp_point, adsp_ec_params, adsl_tmp_1, adsl_tmp_2);
    } else if (adsp_point->iec_representation == ied_jacobian) {
        iel_return = ms_ecpt_weier_on_curve_jac(adsp_pool, adsp_point, adsp_ec_params, adsl_tmp_1, adsl_tmp_2, adsl_tmp_3);
    } else {
        iel_return = ied_ecc_representation_error;
    }
    // restore stack frame
    m_mem_pool_restore_frame(&adsp_pool, dsl_frame);
    return iel_return;
} // m_ecpt_weier_on_curve

/**
   Function that generates the wNAF form of a scalar.
   szp_alloc_len is not calculated in the function because
   double scalar multiplication needs both wNAF buffers to be
   allocated with the size of the bigger scalar. szp_alloc_len
   must be at least bytes_scalar + 1. Buffer is initialized with 0s.

   @param[in,out] aachp_wNAF_out       Result pointer
   @param[in,out] ainp_len_out         pointer to result length
   @param[in,out] adsp_pool            lnum pool
   @param[in]     adsp_scalar          scalar to be processed
   @param[in]     adsp_ec_params       Curve-parameters
   @param[in]     inp_width            width w (window)
   @param[in]     szp_alloc_len        for allocating result

   @return 0 on success, errorcode otherwise
 */
static ied_encry_return ms_ec_gen_wNAF(char **aachp_wNAF_out,
                                       int *ainp_len_out,
                                       struct dsd_mem_pool_ele** aadsp_pool,
                                       const struct dsd_lnum* adsp_scalar,
                                       const int inp_width,
                                       const size_t szp_alloc_len)
{
    if (!adsp_scalar || !aadsp_pool || !aachp_wNAF_out || !ainp_len_out || !(*aadsp_pool)) {
        return ied_encry_null_pointer;
    }
    if (inp_width < 1 || inp_width > 8) {
        return ied_encry_invalid_input;
    }
    if (m_lnum_sign(adsp_scalar) != ied_positive) {
        return ied_encry_invalid_input;
    }

    dsd_mem_pool_frame dsl_frame_error = m_mem_pool_get_frame(*aadsp_pool);
    *aachp_wNAF_out = (char*)m_mem_pool_get_chunk(aadsp_pool, szp_alloc_len);

    dsd_mem_pool_frame dsl_frame = m_mem_pool_get_frame(*aadsp_pool);
    dsd_lnum *adsl_scalar_copy = m_mem_pool_get_lnum_byte_size(aadsp_pool,
                                                               adsp_scalar->szc_used_size_bytes + sizeof(LNUM_WORD));
    dsd_lnum *adsl_tmp_1 = m_mem_pool_get_lnum_byte_size(aadsp_pool, 1);
    if (!*aachp_wNAF_out || !adsl_scalar_copy || !adsl_tmp_1) {
        m_mem_pool_restore_frame(aadsp_pool, dsl_frame_error);
        return ied_encry_pool_empty;
    }
    memset(*aachp_wNAF_out, 0, szp_alloc_len);
    m_lnum_copy(adsl_scalar_copy, adsp_scalar);

    int inl_2_pow_w = 1<<inp_width;
    LNUM_WORD url_modulo_bitmask = inl_2_pow_w - 1;
    int inl_2_pow_w_minus_1 = 1<<(inp_width - 1);
    int inl_tmp;
    *ainp_len_out = 0;
    while(m_lnum_sign(adsl_scalar_copy) == ied_positive) {
        // this prevents seg faults and endless loops
        if ((size_t)(*ainp_len_out) >= szp_alloc_len) {
            m_mem_pool_restore_frame(aadsp_pool, dsl_frame_error);
            return ied_encry_internal_error;
        }
        if (m_lnum_is_odd(adsl_scalar_copy)) {
            // modulo 2^w
            inl_tmp = (int)(((LNUM_WORD*)(adsl_scalar_copy->aucc_data))[0] & url_modulo_bitmask);
            if (inl_tmp > inl_2_pow_w_minus_1) {
                inl_tmp -= inl_2_pow_w;
            }
            // this checks if current wNAF byte is in the allowed range.
            // when this fail, algorithm implementation contains an error.
            if ((inl_tmp > inl_2_pow_w_minus_1) || (inl_tmp < (-1)*inl_2_pow_w_minus_1)) {
                m_mem_pool_restore_frame(aadsp_pool, dsl_frame_error);
                return ied_encry_internal_error;
            }
            (*aachp_wNAF_out)[*ainp_len_out] = (char)inl_tmp;
            m_lnum_set(adsl_tmp_1, inl_tmp);
            // buffer is always big enough, see developer docu
            m_lnum_sub(adsl_scalar_copy, adsl_scalar_copy, adsl_tmp_1);
        }
        m_lnum_rshift(adsl_scalar_copy, adsl_scalar_copy, 1);
        ++(*ainp_len_out);
    }

    m_mem_pool_restore_frame(aadsp_pool, dsl_frame);
    return ied_encry_success;
} // ms_ec_gen_wNAF

/**
   Negates an EC point with modulus, so result is non-negativ. Inplace possible.
   No buffer checks, adsp_out must be allocated big enough.
   all members in adsp_in must be non-negativ and smaller than prime.

   @param[in,out] adsp_out             Destination
   @param[in,out] adsp_pool            lnum pool
   @param[in]     adsp_in              Source
   @param[in]     adsp_tmp             tmp with size adsp_in->used_words + 1
   @param[in]     adsp_ec_params       Curve-parameters
 */
inline static void ms_ecpt_negate(dsd_ec_point *adsp_out,
                                  dsd_ec_point *adsp_in,
                                  dsd_lnum *adsp_tmp,
                                  const dsd_ec_curve_params *adsp_ec_params)
{
    m_lnum_copy(adsp_out->adsc_x, adsp_in->adsc_x);
    if (adsp_in->iec_representation == ied_jacobian) {
        m_lnum_copy(adsp_out->adsc_z, adsp_in->adsc_z);
    }

    m_lnum_sub(adsp_tmp, adsp_ec_params->adsc_prime, adsp_in->adsc_y);
    m_lnum_copy(adsp_out->adsc_y, adsp_tmp);

    adsp_out->iec_representation = adsp_in->iec_representation;
    m_ecpt_zero_fill(adsp_out, adsp_ec_params->adsc_prime);
}

/**
   Scales an EC point in montgomery form such that z=1 (mont one).
   Point that should be scaled must be filled with 0s to size of prime.

   @param[in,out] adsp_point_to_scale  Point to scale
   @param[in,out] adsp_pool            lnum pool
   @param[in]     adsp_tmp_1           tmp lnums with
   @param[in]     adsp_tmp_2           alloc size 2*
   @param[in]     adsp_tmp_3           used_words_prime
   @param[in]     adsp_tmpint_1        + 1 in words
   @param[in]     adsp_tmpint_2
   @param[in]     adsp_mont_ctx        Montgomery context
   @param[in]     adsp_ec_params       Curve-parameters

   @return 0 on success, errorcode otherwise
 */
extern "C" ied_encry_return ms_ecpt_conv_to_aff(struct dsd_ec_point *adsp_point_to_scale,
                                                struct dsd_mem_pool_ele *adsp_pool,
                                                struct dsd_lnum *adsp_tmp_1,
                                                struct dsd_lnum *adsp_tmp_2,
                                                struct dsd_lnum *adsp_tmp_3,
                                                struct dsd_lnum *adsp_tmpint_1,
                                                struct dsd_lnum *adsp_tmpint_2,
                                                const struct dsd_lnum_montgomery_ctx *adsp_mont_ctx,
                                                const struct dsd_ec_curve_params *adsp_ec_params)
{
    // modular inverse to z in montgomery form (=R*z^{-1}), i.e. modular inverse to R^{-1}*z
    ied_encry_return iel_return = m_lnum_mont_red(adsp_tmp_2, adsp_pool, adsp_point_to_scale->adsc_z, adsp_mont_ctx); // z
    if (iel_return != ied_encry_success) return iel_return;
    iel_return = m_lnum_mont_red(adsp_tmp_2, adsp_pool, adsp_tmp_2, adsp_mont_ctx); // R^{-1}*z
    if (iel_return != ied_encry_success) return iel_return;
    iel_return = m_lnum_inverse(adsp_tmp_1, adsp_pool, adsp_tmp_2, adsp_ec_params->adsc_prime);
    if (iel_return != ied_encry_success) return iel_return;
    ms_lnum_zero_fill(adsp_tmp_1, adsp_mont_ctx->adsc_mod->szc_used_size_bytes);

    // scale
    m_square_mont(adsp_tmp_2, adsp_tmp_1, adsp_mont_ctx, adsp_tmpint_1, adsp_tmpint_2);
    m_mul_mont(adsp_tmp_3, adsp_point_to_scale->adsc_x, adsp_tmp_2, adsp_mont_ctx, adsp_tmpint_1, adsp_tmpint_2); // cpy

    adsp_tmp_3->boc_is_negative = FALSE;
    adsp_tmp_3->szc_used_size_bytes = adsp_ec_params->adsc_prime->szc_used_size_bytes;
    m_lnum_copy(adsp_point_to_scale->adsc_x, adsp_tmp_3);

    m_mul_mont(adsp_tmp_3, adsp_tmp_1, adsp_tmp_2, adsp_mont_ctx, adsp_tmpint_1, adsp_tmpint_2);
    m_mul_mont(adsp_tmp_1, adsp_point_to_scale->adsc_y, adsp_tmp_3, adsp_mont_ctx, adsp_tmpint_1, adsp_tmpint_2);

    adsp_tmp_1->boc_is_negative = FALSE;
    adsp_tmp_1->szc_used_size_bytes = adsp_ec_params->adsc_prime->szc_used_size_bytes;
    m_lnum_copy(adsp_point_to_scale->adsc_y, adsp_tmp_1);

    ms_lnum_set_used_words(adsp_point_to_scale->adsc_x);
    ms_lnum_set_used_words(adsp_point_to_scale->adsc_y);

    adsp_point_to_scale->iec_representation = ied_affine;

    return ied_encry_success;
} // ms_ecpt_conv_to_aff

/**
   Scales an EC point int montgomery form such that z=1 (mont one).
   adsp_lnum_x and adsp_lnum_y must non-negativ and smaller than the prime

   wNAF algorithm uses precomputed values for -2^(w-1)*G to 2^(w-1)*G. This values are precomputed
   in this function. Output is in jacobian representation in montgomery form and stored in the pool.
   Example: w=3 => {-7*G, -5*G, -3*G, -G, G, 3*G, 5*G, 7*G} (because only odd numbers needed, see wNAF).
   x and y has to be in F_p

   @param[in,out] adsp_pres            vector of size 2^w to store precomps
   @param[in,out] adsp_pool            lnum pool
   @param[in]     adsp_mont_ctx        Montgomery context
   @param[in]     adsp_lnum_x          Gx in mont
   @param[in]     adsp_lnum_y          Gy in mont
   @param[in]     adsp_ec_params_mont  EC params with each member except prime in mont
   @param[in]     szp_bytes_prime      bytes len of prime
   @param[in]     inp_size             size of vector (2^w)
   @param[in]     boc_scale            if true, precomputations are scaled to z=1

   @return 0 on success, errorcode otherwise
 */
static ied_encry_return ms_ecpt_weier_scamult_precomp(struct dsd_ec_point *adsp_pres,
                                                      struct dsd_mem_pool_ele* adsp_pool,
                                                      const struct dsd_lnum_montgomery_ctx* adsp_mont_ctx,
                                                      const struct dsd_lnum *adsp_lnum_x,
                                                      const struct dsd_lnum *adsp_lnum_y,
                                                      const struct dsd_ec_curve_params *adsp_ec_params_mont,
                                                      size_t szp_bytes_prime,
                                                      int inp_size,
                                                      bool boc_scale)
{
    dsd_mem_pool_frame dsl_frame = m_mem_pool_get_frame(adsp_pool);

    size_t szl_bytes_for_tmps = 2*adsp_ec_params_mont->adsc_prime->szc_used_size_bytes + sizeof(LNUM_WORD);
    // get tmps from pool
    dsd_lnum *adsl_tmp_1 = m_mem_pool_get_lnum_byte_size(&adsp_pool, szl_bytes_for_tmps);
    dsd_lnum *adsl_tmp_2 = m_mem_pool_get_lnum_byte_size(&adsp_pool, szl_bytes_for_tmps);
    dsd_lnum *adsl_tmp_3 = m_mem_pool_get_lnum_byte_size(&adsp_pool, szl_bytes_for_tmps);
    dsd_lnum *adsl_tmp_4 = m_mem_pool_get_lnum_byte_size(&adsp_pool, szl_bytes_for_tmps);
    dsd_lnum *adsl_tmp_5 = m_mem_pool_get_lnum_byte_size(&adsp_pool, szl_bytes_for_tmps);
    dsd_lnum *adsl_tmp_6 = m_mem_pool_get_lnum_byte_size(&adsp_pool, szl_bytes_for_tmps);
    dsd_lnum *adsl_tmp_7 = m_mem_pool_get_lnum_byte_size(&adsp_pool, szl_bytes_for_tmps);
    dsd_lnum *adsl_tmp_8 = m_mem_pool_get_lnum_byte_size(&adsp_pool, szl_bytes_for_tmps);
    dsd_lnum *adsl_tmp_9 = m_mem_pool_get_lnum_byte_size(&adsp_pool, szl_bytes_for_tmps);
    dsd_lnum *adsl_tmp_10 = m_mem_pool_get_lnum_byte_size(&adsp_pool, szl_bytes_for_tmps);
    dsd_lnum *adsl_tmp_11 = m_mem_pool_get_lnum_byte_size(&adsp_pool, szl_bytes_for_tmps);
    dsd_lnum *adsl_tmp_12 = m_mem_pool_get_lnum_byte_size(&adsp_pool, szl_bytes_for_tmps);

    // tmp ec point
    dsd_ec_point dsl_ec_tmp_1 = {0};
    dsl_ec_tmp_1.adsc_x = m_mem_pool_get_lnum_byte_size(&adsp_pool, szp_bytes_prime);
    dsl_ec_tmp_1.adsc_y = m_mem_pool_get_lnum_byte_size(&adsp_pool, szp_bytes_prime);
    dsl_ec_tmp_1.adsc_z = m_mem_pool_get_lnum_byte_size(&adsp_pool, szp_bytes_prime);
    // tmp 1..12 has same size and x, y, and z have same size, so only tmp 12 and z has to be checked
    if (!adsl_tmp_12 || !dsl_ec_tmp_1.adsc_z) {
        m_mem_pool_restore_frame(&adsp_pool, dsl_frame);
        return ied_encry_pool_empty;
    }

    // 1*G at inl_size/2
    m_lnum_copy(adsp_pres[inp_size>>1].adsc_x, adsp_lnum_x);
    m_lnum_copy(adsp_pres[inp_size>>1].adsc_y, adsp_lnum_y);
    adsp_pres[inp_size>>1].iec_representation = ied_affine;
    // fill with zeros
    m_ecpt_zero_fill(&adsp_pres[inp_size>>1], adsp_ec_params_mont->adsc_prime);

    // tmp1 = 2*G
    ied_encry_return iel_return;
    m_ecpt_weier_dbl(&dsl_ec_tmp_1,
                     adsl_tmp_1,
                     adsl_tmp_2,
                     adsl_tmp_3,
                     adsl_tmp_4,
                     adsl_tmp_5,
                     adsl_tmp_6,
                     adsl_tmp_7,
                     adsl_tmp_8,
                     adsl_tmp_9,
                     adsl_tmp_10,
                     adsp_mont_ctx,
                     &adsp_pres[inp_size>>1],
                     adsp_ec_params_mont);

    // positive factors:
    for (int inl_i = (inp_size>>1) + 1; inl_i < inp_size; ++inl_i)
    {
        m_ecpt_weier_add(&adsp_pres[inl_i],
                         adsl_tmp_1,
                         adsl_tmp_2,
                         adsl_tmp_3,
                         adsl_tmp_4,
                         adsl_tmp_5,
                         adsl_tmp_6,
                         adsl_tmp_7,
                         adsl_tmp_8,
                         adsl_tmp_9,
                         adsl_tmp_10,
                         adsl_tmp_11,
                         adsl_tmp_12,
                         adsp_mont_ctx,
                         &dsl_ec_tmp_1,
                         &adsp_pres[inl_i - 1],
                         adsp_ec_params_mont);

        // scale that z=1 to improve performance for later use in scalar multiplication
        if (boc_scale) {
            iel_return = ms_ecpt_conv_to_aff(&adsp_pres[inl_i],
                                             adsp_pool,
                                             adsl_tmp_1,
                                             adsl_tmp_2,
                                             adsl_tmp_3,
                                             adsl_tmp_4,
                                             adsl_tmp_5,
                                             adsp_mont_ctx,
                                             adsp_ec_params_mont);
            if (iel_return != ied_encry_success) {
                m_mem_pool_restore_frame(&adsp_pool, dsl_frame);
                return iel_return;
            }
        }
    }

    // negative factors
    for (int inl_i = 0; inl_i < (inp_size >> 1); inl_i++)
    {
        ms_ecpt_negate(&adsp_pres[inl_i], &adsp_pres[inp_size - inl_i - 1], adsl_tmp_1, adsp_ec_params_mont);
    }
    m_mem_pool_restore_frame(&adsp_pool, dsl_frame);
    return ied_encry_success;
} // ms_ecpt_weier_scamult_precomp

/**

   @param[in,out] aadsp_output         output
   @param[in,out] adsp_pool            lnum pool
   @param[in]     adsp_ec_params       Curve parameters
   @param[in]     inp_width            w for wNAF for 2^(w-1)

   @return 0 on success, errorcode otherwise
 */
static ied_encry_return ms_mem_pool_get_scamult_precomp(dsd_ec_point **aadsp_output,
                                                        struct dsd_mem_pool_ele** aadsp_pool,
                                                        const struct dsd_ec_curve_params *adsp_ec_params,
                                                        const int inp_width)
{
    int inl_size = 1<<inp_width;
    int inl_bytes_prime = m_lnum_get_byte_count(adsp_ec_params->adsc_prime);
    if (inl_bytes_prime <= 0) {
        return ied_encry_invalid_input;
    }

    // get stackframe used if an error occurs
    dsd_mem_pool_frame dsl_frame_error = m_mem_pool_get_frame(*aadsp_pool);

    *aadsp_output = NULL;
    *aadsp_output = (dsd_ec_point*)m_mem_pool_get_chunk(aadsp_pool, inl_size * sizeof(dsd_ec_point));
    if (!*aadsp_output) {
        return ied_encry_pool_empty;
    }
    memset(*aadsp_output, 0, inl_size * sizeof(dsd_ec_point));

    for (int inl_i = 0; inl_i < inl_size; ++inl_i)
    {
        (*aadsp_output)[inl_i].adsc_x = m_mem_pool_get_lnum_byte_size(aadsp_pool, inl_bytes_prime);
        (*aadsp_output)[inl_i].adsc_y = m_mem_pool_get_lnum_byte_size(aadsp_pool, inl_bytes_prime);
        (*aadsp_output)[inl_i].adsc_z = m_mem_pool_get_lnum_byte_size(aadsp_pool, inl_bytes_prime);
        // same size, enought to check last one
        if (!(*aadsp_output)[inl_i].adsc_z) {
            m_mem_pool_restore_frame(aadsp_pool, dsl_frame_error);
            return ied_encry_pool_empty;
        }
    }

    return ied_encry_success;
} // ms_mem_pool_get_scamult_precomp

/**
   Copies the curve parameters to a parameter structure. adsp_ec_params_out is filled from the pool.
   prime is copied, the other members are converted into montgomery form. This form is used for the
   calculations.

   @param[in,out] adsp_ec_params_out       params out
   @param[in,out] adsp_pool                lnum pool
   @param[in]     adsp_mont_ctx            montgomery context
   @param[in]     adsp_ec_params           params source
   @param[in]     inp_bytes_count_prime    for getting params from pool

   @returns 0 on success, error-code otherwise.
 */
static ied_encry_return ms_ec_montgomerize_params(dsd_ec_curve_params *adsp_ec_params_out,
                                                  struct dsd_mem_pool_ele **aadsp_pool,
                                                  const dsd_lnum_montgomery_ctx *adsp_mont_ctx,
                                                  const dsd_ec_curve_params *adsp_ec_params,
                                                  const dsd_lnum *adsp_Qx,
                                                  const dsd_lnum *adsp_Qy,
                                                  const size_t szp_bytes_count_prime)
{
    adsp_ec_params_out->adsc_a = m_mem_pool_get_lnum_byte_size(aadsp_pool, szp_bytes_count_prime);
    adsp_ec_params_out->adsc_b_a24 = m_mem_pool_get_lnum_byte_size(aadsp_pool, szp_bytes_count_prime);
    adsp_ec_params_out->adsc_Gx = m_mem_pool_get_lnum_byte_size(aadsp_pool, szp_bytes_count_prime);
    adsp_ec_params_out->adsc_Gy = m_mem_pool_get_lnum_byte_size(aadsp_pool, szp_bytes_count_prime);
    adsp_ec_params_out->adsc_prime = m_mem_pool_get_lnum_byte_size(aadsp_pool, szp_bytes_count_prime);
    // same size, so it is enough to check the last pool_get
    if (!adsp_ec_params_out->adsc_prime) {
        return ied_encry_pool_empty;
    }
    ied_encry_return iel_return = m_lnum_mont_conv(adsp_ec_params_out->adsc_a,
                                                   *aadsp_pool,
                                                   adsp_ec_params->adsc_a,
                                                   adsp_mont_ctx);
    if (iel_return != ied_encry_success) {
        return iel_return;
    }
    iel_return = m_lnum_mont_conv(adsp_ec_params_out->adsc_b_a24,
                                  *aadsp_pool,
                                  adsp_ec_params->adsc_b_a24,
                                  adsp_mont_ctx);
    if (iel_return != ied_encry_success) {
        return iel_return;
    }
    if (!adsp_Qx && adsp_Qy) {
        return ied_encry_invalid_input;
    }
    if (!adsp_Qy && adsp_Qx) {
        return ied_encry_invalid_input;
    }
    if (adsp_Qy && adsp_Qy) {
        if (adsp_Qx->boc_is_negative || adsp_Qy->boc_is_negative) {
            return ied_encry_invalid_input;
        }
        if ((m_lnum_compare_absolute(adsp_Qx, adsp_ec_params->adsc_prime) != ied_smaller)
            || (m_lnum_compare_absolute(adsp_Qy, adsp_ec_params->adsc_prime) != ied_smaller))
        {
            return ied_encry_invalid_input;
        }

        iel_return = m_lnum_mont_conv(adsp_ec_params_out->adsc_Gx, *aadsp_pool, adsp_Qx, adsp_mont_ctx);
        if (iel_return != ied_encry_success) return iel_return;
        iel_return = m_lnum_mont_conv(adsp_ec_params_out->adsc_Gy, *aadsp_pool, adsp_Qy, adsp_mont_ctx);
        if (iel_return != ied_encry_success) return iel_return;
    } else {
        iel_return = m_lnum_mont_conv(adsp_ec_params_out->adsc_Gx, *aadsp_pool, adsp_ec_params->adsc_Gx, adsp_mont_ctx);
        if (iel_return != ied_encry_success) return iel_return;
        iel_return = m_lnum_mont_conv(adsp_ec_params_out->adsc_Gy, *aadsp_pool, adsp_ec_params->adsc_Gy, adsp_mont_ctx);
        if (iel_return != ied_encry_success) return iel_return;
    }
    iel_return = m_lnum_copy(adsp_ec_params_out->adsc_prime, adsp_ec_params->adsc_prime);
    if (iel_return != ied_encry_success) return iel_return;

    // a,b,Gx, and Gy must be filled with 0s. Not done explicitely because m_lnum_mont_conv does this job
    return ied_encry_success;
} // ms_ec_montgomerize_params


/**
   For weierstrass curves:
   wNAF algorithm uses precomputed values for -2^(w-1)*G to 2^(w-1)*G. This values are precomputed
   for w=8 in this function. Output is in jacobian representation in montgomery form and allocated
   using the given memory provider. It is used for global precomputations for common named curves.
   Since only odd a*G for odd a are needed (see wNAF algorithm), this produces prcomputations like:
   {-255*G, -253*G, ..., -3*G, -G, G, 3*G, 5*G, ..., 253*G, 255*G}. Functions also initializes the
   montgomery context for this parameters structure.
   For montgomery curves:
   Only montgomery context is produced.

   @param[in,out] adsp_ec_params       Curve parameters
   @param[in,out] adsp_memory          Memroyprovider
   @param[in,out] adsp_pool            lnum pool

   @returns 0 on success, error-code otherwise
 */
static ied_encry_return ms_ecc_precomp_curve(struct dsd_ec_curve_params *adsp_ec_params,
                                             struct dsd_memory *adsp_memory,
                                             struct dsd_mem_pool_ele* adsp_pool)
{
    if (!adsp_pool || !adsp_memory || !adsp_ec_params) {
        return ied_encry_null_pointer;
    }

    if (adsp_ec_params->adsc_precomps != NULL) {
        return ied_ecc_context_not_clean;
    }

    int inl_size = 1<<8;
    int inl_bytes_prime = m_lnum_get_byte_count(adsp_ec_params->adsc_prime);
    if (inl_bytes_prime <= 0) {
        return ied_encry_invalid_input;
    }

    // alloc precomputations (only for weierstrass curves)
    if (adsp_ec_params->iec_type != ied_montgomery) {
        adsp_ec_params->adsc_precomps =
            (dsd_ec_point*)adsp_memory->amc_malloc(adsp_memory, inl_size * sizeof(dsd_ec_point));
        if (!adsp_ec_params->adsc_precomps) {
            return ied_encry_alloc_failure;
        }
        memset(adsp_ec_params->adsc_precomps, 0, inl_size * sizeof(dsd_ec_point));
    }
    dsd_ec_curve_params dsl_params_tmp = {0};
    ied_encry_return iel_return = ied_encry_success;
    dsd_mem_pool_frame dsl_frame = m_mem_pool_get_frame(adsp_pool);

    // alloc ec points for precomputations (only for weierstrass curves)
    if (adsp_ec_params->iec_type != ied_montgomery) {
        for (int inl_i = 0; inl_i < inl_size; ++inl_i)
        {
            iel_return = m_ecpt_alloc(adsp_memory,
                                      &adsp_ec_params->adsc_precomps[inl_i],
                                      adsp_ec_params->adsc_prime->szc_used_size_bytes / sizeof(LNUM_WORD));
            if (iel_return != ied_encry_success) {
                goto p_ec_pre_error;
            }
        }
    }

    // montgomery context
    adsp_ec_params->adsc_mont_ctx =
        (dsd_lnum_montgomery_ctx*)adsp_memory->amc_malloc(adsp_memory, sizeof(dsd_lnum_montgomery_ctx));
    if (!adsp_ec_params->adsc_mont_ctx) {
        iel_return = ied_encry_alloc_failure;
        goto p_ec_pre_error;
    }
    memset(adsp_ec_params->adsc_mont_ctx, 0, sizeof(dsd_lnum_montgomery_ctx));
    iel_return = m_lnum_mont_init(adsp_ec_params->adsc_mont_ctx, adsp_memory, adsp_pool, adsp_ec_params->adsc_prime);
    if (iel_return != ied_encry_success) {
        goto p_ec_pre_error;
    }

    // curve parameters in montgomery form and precomputations (only needed for weierstrass curves).
    if (adsp_ec_params->iec_type != ied_montgomery) {
        iel_return = ms_ec_montgomerize_params(&dsl_params_tmp,
                                               &adsp_pool,
                                               adsp_ec_params->adsc_mont_ctx,
                                               adsp_ec_params,
                                               NULL,
                                               NULL,
                                               inl_bytes_prime);
        if (iel_return != ied_encry_success) {
            goto p_ec_pre_error;
        }

        // precomputations
        iel_return = ms_ecpt_weier_scamult_precomp(adsp_ec_params->adsc_precomps,
                                                   adsp_pool,
                                                   adsp_ec_params->adsc_mont_ctx,
                                                   dsl_params_tmp.adsc_Gx,
                                                   dsl_params_tmp.adsc_Gy,
                                                   &dsl_params_tmp,
                                                   inl_bytes_prime,
                                                   inl_size,
                                                   TRUE);
        if (iel_return != ied_encry_success) {
            goto p_ec_pre_error;
        }
    }
    m_mem_pool_restore_frame(&adsp_pool, dsl_frame);
    return ied_encry_success;

p_ec_pre_error:
    m_mem_pool_restore_frame(&adsp_pool, dsl_frame);
    if (adsp_ec_params->adsc_mont_ctx) {
        m_lnum_mont_free(adsp_ec_params->adsc_mont_ctx, adsp_memory);
        adsp_memory->amc_free(adsp_memory, adsp_ec_params->adsc_mont_ctx);
        adsp_ec_params->adsc_mont_ctx = NULL;
    }
    if (adsp_ec_params->adsc_precomps) {
        for (int inl_i = 0; inl_i < inl_size; inl_i++) {
            m_ecpt_free(adsp_memory, &adsp_ec_params->adsc_precomps[inl_i]);
        }
        adsp_memory->amc_free(adsp_memory, adsp_ec_params->adsc_precomps);
        adsp_ec_params->adsc_precomps = NULL;
    }
    return iel_return;
} // ms_ecc_precomp_curve

/**
   Prepares a scalar-multiplication or a double-scalar-multiplication for k*Q.
   This includes:
   - set pointer for montgomery context and if necessary, init the struct (kept in pool!)
   - prepare temporary ec params with montgomery params from ec_params    (kept in pool!)
   - init result with the neutral element in montgomery form


   @param[in,out] adsp_result           result out (will be initialized with neutral element)
   @param[in,out] adsp_pool             lnum pool
   @param[in,out] adsp_mont_ctx_struct  pointer to struct on stack
   @param[in,out] aadsp_mont_ctx_ptr    the pointer behind it is used for later computaions
                                     and is set to struct or context in params if not NULL
   @param[in,out] adsp_ec_params_tmp    pointer to temporary ec params (will be filled with mont form of params)
   @param[in]     adsp_ec_params        original ec params
   @param[in]     adsp_Qx               Qx
   @param[in]     adsp_Qy               Qy
   @param[in]     inp_bytes_count_prime bytes of prime

   @returns 0 on success, error-code otherwise.
 */
static ied_encry_return ms_ecpt_weier_scamult_init(struct dsd_ec_point *adsp_result,
                                                   dsd_mem_pool_ele **aadsp_pool,
                                                   dsd_lnum_montgomery_ctx *adsp_mont_ctx_struct,
                                                   dsd_lnum_montgomery_ctx **aadsp_mont_ctx_ptr,
                                                   dsd_ec_curve_params *adsp_ec_params_tmp,
                                                   const dsd_ec_curve_params *adsp_ec_params,
                                                   const struct dsd_lnum *adsp_Qx,
                                                   const struct dsd_lnum *adsp_Qy,
                                                   const size_t szp_bytes_count_prime)
{
    if (!adsp_ec_params->adsc_mont_ctx) {
        *aadsp_mont_ctx_ptr = adsp_mont_ctx_struct;
        adsp_mont_ctx_struct->adsc_mod = adsp_ec_params->adsc_prime;
        adsp_mont_ctx_struct->adsc_r_sqr = m_mem_pool_get_lnum_same_size(aadsp_pool, adsp_ec_params->adsc_prime);
        adsp_mont_ctx_struct->adsc_mont_one = m_mem_pool_get_lnum_same_size(aadsp_pool, adsp_ec_params->adsc_prime);
        if (!adsp_mont_ctx_struct->adsc_mod ||
            !adsp_mont_ctx_struct->adsc_r_sqr ||
            !adsp_mont_ctx_struct->adsc_mont_one)
        {
            return ied_encry_pool_empty;
        }
        ied_encry_return iel_return = m_mont_init_impl(adsp_mont_ctx_struct, *aadsp_pool);
        if (iel_return != ied_encry_success) {
            return iel_return;
        }
    } else {
        *aadsp_mont_ctx_ptr = adsp_ec_params->adsc_mont_ctx;
    }


    // temp params with some members in montgomery
    ied_encry_return iel_ec_return = ms_ec_montgomerize_params(adsp_ec_params_tmp,
                                                               aadsp_pool,
                                                               *aadsp_mont_ctx_ptr,
                                                               adsp_ec_params,
                                                               adsp_Qx,
                                                               adsp_Qy,
                                                               szp_bytes_count_prime);
    if (iel_ec_return != ied_encry_success) {
        return iel_ec_return;
    }

    // init result with O
    adsp_result->iec_representation = ied_neutral;
    return ied_encry_success;
} // ms_ecpt_weier_scamult_init

/**
   Algorithm for scalar multiplication.

   @param[in,out] adsp_result          result out
   @param[in,out] adsp_pool            lnum pool
   @param[in]     adsp_mont_ctx        montgomery context
   @param[in]     adsp_scalar          scalar in
   @param[in]     adsp_ec_params       ec parameters
   @param[in]     adsp_precomputations precomputations
   @param[in]     inp_width            w for wNAF

   @returns 0 on success, error-code otherwise.
 */
static ied_encry_return ms_ecpt_weier_scamult_algo(struct dsd_ec_point *adsp_result,
                                                   struct dsd_mem_pool_ele *adsp_pool,
                                                   const struct dsd_lnum_montgomery_ctx *adsp_mont_ctx,
                                                   const struct dsd_lnum *adsp_scalar,
                                                   const struct dsd_ec_curve_params *adsp_ec_params,
                                                   const struct dsd_ec_point *adsp_precomputations,
                                                   const int inp_width)
{
    char *achl_wNAF = NULL;
    int inl_len_wNAF = 0;
    int inl_index;
    size_t szl_bytes_for_tmps = (2*adsp_ec_params->adsc_prime->szc_used_size_bytes) + sizeof(LNUM_WORD);
    int inl_alloc_len = m_lnum_get_byte_count(adsp_scalar) * 8 + 1;
    ied_encry_return iel_ret;

    dsd_mem_pool_frame dsl_frame = m_mem_pool_get_frame(adsp_pool);

    // get tmps from pool
    dsd_lnum *adsl_tmp_1 = m_mem_pool_get_lnum_byte_size(&adsp_pool, szl_bytes_for_tmps);
    dsd_lnum *adsl_tmp_2 = m_mem_pool_get_lnum_byte_size(&adsp_pool, szl_bytes_for_tmps);
    dsd_lnum *adsl_tmp_3 = m_mem_pool_get_lnum_byte_size(&adsp_pool, szl_bytes_for_tmps);
    dsd_lnum *adsl_tmp_4 = m_mem_pool_get_lnum_byte_size(&adsp_pool, szl_bytes_for_tmps);
    dsd_lnum *adsl_tmp_5 = m_mem_pool_get_lnum_byte_size(&adsp_pool, szl_bytes_for_tmps);
    dsd_lnum *adsl_tmp_6 = m_mem_pool_get_lnum_byte_size(&adsp_pool, szl_bytes_for_tmps);
    dsd_lnum *adsl_tmp_7 = m_mem_pool_get_lnum_byte_size(&adsp_pool, szl_bytes_for_tmps);
    dsd_lnum *adsl_tmp_8 = m_mem_pool_get_lnum_byte_size(&adsp_pool, szl_bytes_for_tmps);
    dsd_lnum *adsl_tmp_9 = m_mem_pool_get_lnum_byte_size(&adsp_pool, szl_bytes_for_tmps);
    dsd_lnum *adsl_tmp_10 = m_mem_pool_get_lnum_byte_size(&adsp_pool, szl_bytes_for_tmps);
    dsd_lnum *adsl_tmp_11 = m_mem_pool_get_lnum_byte_size(&adsp_pool, szl_bytes_for_tmps);
    dsd_lnum *adsl_tmp_12 = m_mem_pool_get_lnum_byte_size(&adsp_pool, szl_bytes_for_tmps);
    // same size, so only last tmp has to be checked if failed
    if (!adsl_tmp_12) {
        m_mem_pool_restore_frame(&adsp_pool, dsl_frame);
        return ied_encry_pool_empty;
    }

    iel_ret = ms_ec_gen_wNAF(&achl_wNAF, &inl_len_wNAF, &adsp_pool, adsp_scalar, inp_width, inl_alloc_len);
    if (iel_ret != ied_encry_success) {
        m_mem_pool_restore_frame(&adsp_pool, dsl_frame);
        return iel_ret;
    }

    inl_index = inl_len_wNAF - 1;

    // count: 10d + mult + square
    while(inl_index >= 0) {
        m_ecpt_weier_dbl(adsp_result,
                         adsl_tmp_1,
                         adsl_tmp_2,
                         adsl_tmp_3,
                         adsl_tmp_4,
                         adsl_tmp_5,
                         adsl_tmp_6,
                         adsl_tmp_7,
                         adsl_tmp_8,
                         adsl_tmp_9,
                         adsl_tmp_10,
                         adsp_mont_ctx,
                         adsp_result,
                         adsp_ec_params);
        if (achl_wNAF[inl_index]) {
            m_ecpt_weier_add(adsp_result,
                             adsl_tmp_1,
                             adsl_tmp_2,
                             adsl_tmp_3,
                             adsl_tmp_4,
                             adsl_tmp_5,
                             adsl_tmp_6,
                             adsl_tmp_7,
                             adsl_tmp_8,
                             adsl_tmp_9,
                             adsl_tmp_10,
                             adsl_tmp_11,
                             adsl_tmp_12,
                             adsp_mont_ctx,
                             adsp_result,
                             &adsp_precomputations[(achl_wNAF[inl_index] + (1<<inp_width) - 1)/2],
                             adsp_ec_params);
        }
        inl_index--;
    }

    if (adsp_result->iec_representation == ied_jacobian){
        // scale point
        iel_ret = ms_ecpt_conv_to_aff(adsp_result, 
                                      adsp_pool, 
                                      adsl_tmp_1, 
                                      adsl_tmp_2, 
                                      adsl_tmp_3, 
                                      adsl_tmp_4, 
                                      adsl_tmp_5, 
                                      adsp_mont_ctx, 
                                      adsp_ec_params);
        if (iel_ret != ied_encry_success) {
            m_mem_pool_restore_frame(&adsp_pool, dsl_frame);
            return iel_ret;
        }
    }

    // restore frame
    m_mem_pool_restore_frame(&adsp_pool, dsl_frame);
    // mont red x and y
    iel_ret = m_lnum_mont_red(adsp_result->adsc_x, adsp_pool, adsp_result->adsc_x, adsp_mont_ctx);
    if (iel_ret != ied_encry_success) return iel_ret;
    iel_ret = m_lnum_mont_red(adsp_result->adsc_y, adsp_pool, adsp_result->adsc_y, adsp_mont_ctx);
    return iel_ret;
} // ms_ecpt_weier_scamult_algo

// TODO: check correct handling of neutral element in all relevant functions.
extern "C" ied_encry_return m_ecpt_weier_scamult(struct dsd_ec_point *adsp_result,
                                                 struct dsd_mem_pool_ele *adsp_pool,
                                                 const struct dsd_lnum *adsp_scalar,
                                                 const struct dsd_ec_curve_params *adsp_ec_params,
                                                 const struct dsd_lnum *adsp_Qx,
                                                 const struct dsd_lnum *adsp_Qy,
                                                 const int inp_width)
{
    if (!adsp_result || !adsp_pool || !adsp_scalar || !adsp_ec_params) {
        return ied_encry_null_pointer;
    }
    if ((inp_width <= 0) || (inp_width > 8)) {
        return ied_encry_invalid_input;
    }
    int inl_bytes_count_prime = m_lnum_get_byte_count(adsp_ec_params->adsc_prime);
    if (inl_bytes_count_prime <= 0) {
        return ied_encry_invalid_input;
    }
    if (!adsp_result->adsc_x || !adsp_result->adsc_y || !adsp_result->adsc_z) {
        return ied_encry_insufficient_buffer;
    }
    if (((int)adsp_result->adsc_x->szc_alloc_size_bytes < inl_bytes_count_prime)
        || ((int)adsp_result->adsc_y->szc_alloc_size_bytes < inl_bytes_count_prime)
        || ((int)adsp_result->adsc_z->szc_alloc_size_bytes < inl_bytes_count_prime))
    {
        return ied_encry_insufficient_buffer;
    }

    dsd_ec_point* adsrl_precomputations = NULL;
    dsd_lnum_montgomery_ctx dsl_mont_ctx = {0};
    dsd_lnum_montgomery_ctx *adsl_mont_ctx = NULL;
    dsd_ec_curve_params dsl_ec_params_tmp = {0};
    ied_encry_return iel_ec_return;
    int inl_width = inp_width;
    size_t szl_bytes_prime = adsp_ec_params->adsc_prime->szc_used_size_bytes;

    // get stack frame
    dsd_mem_pool_frame dsl_frame = m_mem_pool_get_frame(adsp_pool);

    // prepare montgomery context, mont one, temp params, and init result
    iel_ec_return = ms_ecpt_weier_scamult_init(adsp_result,
                                               &adsp_pool,
                                               &dsl_mont_ctx,
                                               &adsl_mont_ctx,
                                               &dsl_ec_params_tmp,
                                               adsp_ec_params,
                                               adsp_Qx,
                                               adsp_Qy,
                                               szl_bytes_prime);
    if (iel_ec_return != ied_encry_success) {
        m_mem_pool_restore_frame(&adsp_pool, dsl_frame);
        return iel_ec_return;
    }

    // precomputations
    if (!adsp_Qx && !adsp_Qy && adsp_ec_params->adsc_precomps) {
        adsrl_precomputations = adsp_ec_params->adsc_precomps;
        inl_width = 8;
    } else {
        iel_ec_return = ms_mem_pool_get_scamult_precomp(&adsrl_precomputations,
                                                        &adsp_pool,
                                                        &dsl_ec_params_tmp,
                                                        inp_width);
        if (iel_ec_return != ied_encry_success) {
            m_mem_pool_restore_frame(&adsp_pool, dsl_frame);
            return iel_ec_return;
        }
        iel_ec_return = ms_ecpt_weier_scamult_precomp(adsrl_precomputations,
                                                      adsp_pool,
                                                      adsl_mont_ctx,
                                                      dsl_ec_params_tmp.adsc_Gx,
                                                      dsl_ec_params_tmp.adsc_Gy,
                                                      &dsl_ec_params_tmp,
                                                      szl_bytes_prime,
                                                      1<<inp_width,
                                                      FALSE);
        if (iel_ec_return != ied_encry_success) {
            m_mem_pool_restore_frame(&adsp_pool, dsl_frame);
            return iel_ec_return;
        }
    }


    iel_ec_return = ms_ecpt_weier_scamult_algo(adsp_result,
                                               adsp_pool,
                                               adsl_mont_ctx,
                                               adsp_scalar,
                                               &dsl_ec_params_tmp,
                                               adsrl_precomputations,
                                               inl_width);
    
    // restore stack frame
    m_mem_pool_restore_frame(&adsp_pool, dsl_frame);
    return iel_ec_return;
} // m_ecpt_weier_scamult

/**
   Produces a copy of adsp_in in adsp_out in montgomery form. adsp_out is filled from pool!

   @param[in,out] adsp_out                 output ec point
   @param[in,out] adsp_pool                lnum pool
   @param[in]     adsp_mont_ctx            montgomery context
   @param[in]     adsp_in                  input ec point

   @returns 0 on success, error-code otherwise.
 */
inline static ied_encry_return ms_ecpt_montgomerize(dsd_ec_point *adsp_out,
                                                    struct dsd_mem_pool_ele **aadsp_pool,
                                                    dsd_lnum_montgomery_ctx *adsp_mont_ctx,
                                                    const dsd_ec_point *adsp_in)
{
    adsp_out->adsc_x = m_mem_pool_get_lnum_same_size(aadsp_pool, adsp_mont_ctx->adsc_mod);
    adsp_out->adsc_y = m_mem_pool_get_lnum_same_size(aadsp_pool, adsp_mont_ctx->adsc_mod);
    if (!adsp_out->adsc_x || !adsp_out->adsc_y) {
        return ied_encry_pool_empty;
    }
    ied_encry_return iel_return = m_lnum_mont_conv(adsp_out->adsc_x, *aadsp_pool, adsp_in->adsc_x, adsp_mont_ctx);
    if (iel_return != ied_encry_success) {
        return iel_return;
    }
    iel_return = m_lnum_mont_conv(adsp_out->adsc_y, *aadsp_pool, adsp_in->adsc_y, adsp_mont_ctx);
    if (iel_return != ied_encry_success) {
        return iel_return;
    }
    // adsp_q_out x and y must be filled, are filled because m_lnum_mont_conv does it
    return ied_encry_success;
} // ms_ecpt_montgomerize

/**
   Algorithm for double scalar multiplication. Computes a*G+b*Q.

   @param[in,out] adsp_result          result out
   @param[in,out] adsp_pool            lnum pool
   @param[in]     adsp_mont_ctx        montgomery context
   @param[in]     adsp_scalar_q        scalar for Q in
   @param[in]     adsp_q               Q
   @param[in]     adsp_scalar          scalar in
   @param[in]     adsp_ec_params       ec parameters
   @param[in]     adsp_pres            precomputations for curve
   @param[in]     adsp_pres_q          precomps for Q
   @param[in]     inp_width            w for wNAF
   @param[in]     inp_width_q          w for wNAF for Q

   @returns 0 on success, error-code otherwise.
 */
static ied_encry_return ms_ecpt_weier_dblscamult_algo(struct dsd_ec_point *adsp_result,
                                                      struct dsd_mem_pool_ele *adsp_pool,
                                                      const dsd_lnum_montgomery_ctx *adsp_mont_ctx,
                                                      const struct dsd_lnum *adsp_scalar_q,
                                                      const struct dsd_lnum *adsp_scalar,
                                                      const struct dsd_ec_curve_params *adsp_ec_params,
                                                      const struct dsd_ec_point *adsp_pres,
                                                      const struct dsd_ec_point *adsp_pres_q,
                                                      const int inp_width,
                                                      const int inp_width_q)
{
    char *achl_wNAF = NULL;
    char *achl_wNAF_q = NULL;
    int inl_len_wNAF;
    int inl_len_wNAF_q;
    int inl_index;
    size_t szl_alloc_len = ms_u_max((size_t)m_lnum_get_byte_count(adsp_scalar),(size_t)m_lnum_get_byte_count(adsp_scalar_q));  // TODO: issues in error case?
    szl_alloc_len = szl_alloc_len * 8 + 1; // number of bits + 1
    ied_encry_return iel_ret;
    size_t szl_bytes_for_tmps = 2*adsp_ec_params->adsc_prime->szc_used_size_bytes + sizeof(LNUM_WORD);

    // get stackframe
    dsd_mem_pool_frame dsl_frame = m_mem_pool_get_frame(adsp_pool);

    iel_ret = ms_ec_gen_wNAF(&achl_wNAF, &inl_len_wNAF, &adsp_pool, adsp_scalar, inp_width, szl_alloc_len);
    if (iel_ret != ied_encry_success) {
        m_mem_pool_restore_frame(&adsp_pool, dsl_frame);
        return iel_ret;
    }
    iel_ret = ms_ec_gen_wNAF(&achl_wNAF_q, &inl_len_wNAF_q, &adsp_pool, adsp_scalar_q, inp_width_q, szl_alloc_len);
    if (iel_ret != ied_encry_success) {
        m_mem_pool_restore_frame(&adsp_pool, dsl_frame);
        return iel_ret;
    }

    // get tmps from pool
    dsd_lnum *adsl_tmp_1 = m_mem_pool_get_lnum_byte_size(&adsp_pool, szl_bytes_for_tmps);
    dsd_lnum *adsl_tmp_2 = m_mem_pool_get_lnum_byte_size(&adsp_pool, szl_bytes_for_tmps);
    dsd_lnum *adsl_tmp_3 = m_mem_pool_get_lnum_byte_size(&adsp_pool, szl_bytes_for_tmps);
    dsd_lnum *adsl_tmp_4 = m_mem_pool_get_lnum_byte_size(&adsp_pool, szl_bytes_for_tmps);
    dsd_lnum *adsl_tmp_5 = m_mem_pool_get_lnum_byte_size(&adsp_pool, szl_bytes_for_tmps);
    dsd_lnum *adsl_tmp_6 = m_mem_pool_get_lnum_byte_size(&adsp_pool, szl_bytes_for_tmps);
    dsd_lnum *adsl_tmp_7 = m_mem_pool_get_lnum_byte_size(&adsp_pool, szl_bytes_for_tmps);
    dsd_lnum *adsl_tmp_8 = m_mem_pool_get_lnum_byte_size(&adsp_pool, szl_bytes_for_tmps);
    dsd_lnum *adsl_tmp_9 = m_mem_pool_get_lnum_byte_size(&adsp_pool, szl_bytes_for_tmps);
    dsd_lnum *adsl_tmp_10 = m_mem_pool_get_lnum_byte_size(&adsp_pool, szl_bytes_for_tmps);
    dsd_lnum *adsl_tmp_11 = m_mem_pool_get_lnum_byte_size(&adsp_pool, szl_bytes_for_tmps);
    dsd_lnum *adsl_tmp_12 = m_mem_pool_get_lnum_byte_size(&adsp_pool, szl_bytes_for_tmps);
    // same size, so only last tmp has to be checked if failed
    if (!adsl_tmp_12) {
        m_mem_pool_restore_frame(&adsp_pool, dsl_frame);
        return ied_encry_pool_empty;
    }

    inl_index = inl_len_wNAF;
    if (inl_len_wNAF_q > inl_index) {
        inl_index = inl_len_wNAF_q;
    }
    inl_index--;

    // count: 10d + mult + square
    while(inl_index >= 0) {
        m_ecpt_weier_dbl(adsp_result,
                         adsl_tmp_1,
                         adsl_tmp_2,
                         adsl_tmp_3,
                         adsl_tmp_4,
                         adsl_tmp_5,
                         adsl_tmp_6,
                         adsl_tmp_7,
                         adsl_tmp_8,
                         adsl_tmp_9,
                         adsl_tmp_10,
                         adsp_mont_ctx,
                         adsp_result,
                         adsp_ec_params);
        if (achl_wNAF[inl_index]) {
            m_ecpt_weier_add(adsp_result,
                             adsl_tmp_1,
                             adsl_tmp_2,
                             adsl_tmp_3,
                             adsl_tmp_4,
                             adsl_tmp_5,
                             adsl_tmp_6,
                             adsl_tmp_7,
                             adsl_tmp_8,
                             adsl_tmp_9,
                             adsl_tmp_10,
                             adsl_tmp_11,
                             adsl_tmp_12,
                             adsp_mont_ctx,
                             adsp_result,
                             &adsp_pres[(achl_wNAF[inl_index] + (1<<inp_width) - 1)/2],
                             adsp_ec_params);
        }
        if (achl_wNAF_q[inl_index]) {
            m_ecpt_weier_add(adsp_result,
                             adsl_tmp_1,
                             adsl_tmp_2,
                             adsl_tmp_3,
                             adsl_tmp_4,
                             adsl_tmp_5,
                             adsl_tmp_6,
                             adsl_tmp_7,
                             adsl_tmp_8,
                             adsl_tmp_9,
                             adsl_tmp_10,
                             adsl_tmp_11,
                             adsl_tmp_12,
                             adsp_mont_ctx,
                             adsp_result,
                             &adsp_pres_q[(achl_wNAF_q[inl_index] + (1<<inp_width_q) - 1)/2],
                             adsp_ec_params);
        }
        inl_index--;
    }

    if (adsp_result->iec_representation == ied_jacobian){
        // scale point
        iel_ret = ms_ecpt_conv_to_aff(adsp_result, 
                                      adsp_pool, 
                                      adsl_tmp_1, 
                                      adsl_tmp_2, 
                                      adsl_tmp_3, 
                                      adsl_tmp_4, 
                                      adsl_tmp_5, 
                                      adsp_mont_ctx, 
                                      adsp_ec_params);
        if (iel_ret != ied_encry_success) {
            m_mem_pool_restore_frame(&adsp_pool, dsl_frame);
            return iel_ret;
        }
    }

    // restore frame
    m_mem_pool_restore_frame(&adsp_pool, dsl_frame);
    // mont red x and y
    iel_ret = m_lnum_mont_red(adsp_result->adsc_x, adsp_pool, adsp_result->adsc_x, adsp_mont_ctx);
    if (iel_ret != ied_encry_success) return iel_ret;
    iel_ret = m_lnum_mont_red(adsp_result->adsc_y, adsp_pool, adsp_result->adsc_y, adsp_mont_ctx);
    return iel_ret;
} // ms_ecpt_weier_dblscamult_algo

extern "C" ied_encry_return m_ecpt_weier_dblscamult(struct dsd_ec_point *adsp_result,
                                                    struct dsd_mem_pool_ele *adsp_pool,
                                                    const struct dsd_lnum *adsp_scalar_q,
                                                    const struct dsd_ec_point *adsp_q,
                                                    const struct dsd_lnum *adsp_scalar,
                                                    const struct dsd_ec_curve_params *adsp_ec_params,
                                                    const int inp_width)
{
    if ( !adsp_result || !adsp_pool || !adsp_scalar_q || !adsp_q || !adsp_scalar || !adsp_ec_params) {
        return ied_encry_null_pointer;
    }
    if ((inp_width <= 0) || (inp_width > 8)) {
        return ied_encry_invalid_input;
    }
    int inl_bytes_count_prime = m_lnum_get_byte_count(adsp_ec_params->adsc_prime);
    if (inl_bytes_count_prime <= 0) {
        return ied_encry_invalid_input;
    }
    if (!adsp_result->adsc_x || !adsp_result->adsc_y || !adsp_result->adsc_z) {
        return ied_encry_insufficient_buffer;
    }
    if (((int)adsp_result->adsc_x->szc_alloc_size_bytes < inl_bytes_count_prime)
        || ((int)adsp_result->adsc_y->szc_alloc_size_bytes < inl_bytes_count_prime)
        || ((int)adsp_result->adsc_z->szc_alloc_size_bytes < inl_bytes_count_prime))
    {
        return ied_encry_insufficient_buffer;
    }
    if (adsp_q->iec_representation != ied_affine) {
        return ied_ecc_representation_error;
    }
    if (adsp_q->adsc_x->boc_is_negative || adsp_q->adsc_y->boc_is_negative) {
        return ied_encry_invalid_input;
    }
    if ((m_lnum_compare_absolute(adsp_q->adsc_x, adsp_ec_params->adsc_prime) != ied_smaller)
        || (m_lnum_compare_absolute(adsp_q->adsc_y, adsp_ec_params->adsc_prime) != ied_smaller))
    {
        return ied_encry_invalid_input;
    }

    dsd_ec_point* adsrl_precomputations = NULL;
    dsd_ec_point* adsrl_precomp_q = NULL;
    dsd_ec_point dsl_ec_q_tmp = {0};
    dsd_ec_curve_params dsl_ec_params_tmp = {0};
    dsd_lnum_montgomery_ctx dsl_mont_ctx = {0};
    dsd_lnum_montgomery_ctx *adsl_mont_ctx = NULL;
    ied_encry_return iel_ec_return;
    int inl_width = inp_width;

    // get stackframe
    dsd_mem_pool_frame dsl_frame = m_mem_pool_get_frame(adsp_pool);

    // prepare montgomery context, mont one, temp params, and init result
    iel_ec_return = ms_ecpt_weier_scamult_init(adsp_result,
                                               &adsp_pool,
                                               &dsl_mont_ctx,
                                               &adsl_mont_ctx,
                                               &dsl_ec_params_tmp,
                                               adsp_ec_params,
                                               adsp_ec_params->adsc_Gx,
                                               adsp_ec_params->adsc_Gy,
                                               inl_bytes_count_prime);
    if (iel_ec_return != ied_encry_success) {
        m_mem_pool_restore_frame(&adsp_pool, dsl_frame);
        return iel_ec_return;
    }

    // precomputations G
    if (adsp_ec_params->adsc_precomps) {
        adsrl_precomputations = adsp_ec_params->adsc_precomps;
        inl_width = 8;
    } else {
        iel_ec_return = ms_mem_pool_get_scamult_precomp(&adsrl_precomputations,
                                                        &adsp_pool,
                                                        &dsl_ec_params_tmp,
                                                        inp_width);
        if (iel_ec_return != ied_encry_success) {
            m_mem_pool_restore_frame(&adsp_pool, dsl_frame);
            return iel_ec_return;
        }
        iel_ec_return = ms_ecpt_weier_scamult_precomp(adsrl_precomputations,
                                                      adsp_pool,
                                                      adsl_mont_ctx,
                                                      dsl_ec_params_tmp.adsc_Gx,
                                                      dsl_ec_params_tmp.adsc_Gy,
                                                      &dsl_ec_params_tmp,
                                                      inl_bytes_count_prime,
                                                      1<<inp_width,
                                                      FALSE);
        if (iel_ec_return != ied_encry_success) {
            m_mem_pool_restore_frame(&adsp_pool, dsl_frame);
            return iel_ec_return;
        }
    }

    // copy of Q in montgomery form
    iel_ec_return = ms_ecpt_montgomerize(&dsl_ec_q_tmp, &adsp_pool, adsl_mont_ctx, adsp_q);
    if (iel_ec_return != ied_encry_success) {
        m_mem_pool_restore_frame(&adsp_pool, dsl_frame);
        return iel_ec_return;
    }

    // precomputations Q
    iel_ec_return = ms_mem_pool_get_scamult_precomp(&adsrl_precomp_q,
                                                    &adsp_pool,
                                                    &dsl_ec_params_tmp,
                                                    inp_width);
    if (iel_ec_return != ied_encry_success) {
        m_mem_pool_restore_frame(&adsp_pool, dsl_frame);
        return iel_ec_return;
    }
    iel_ec_return = ms_ecpt_weier_scamult_precomp(adsrl_precomp_q,
                                                  adsp_pool,
                                                  adsl_mont_ctx,
                                                  dsl_ec_q_tmp.adsc_x,
                                                  dsl_ec_q_tmp.adsc_y,
                                                  &dsl_ec_params_tmp,
                                                  inl_bytes_count_prime,
                                                  1<<inp_width,
                                                  FALSE);
    if (iel_ec_return != ied_encry_success) {
        m_mem_pool_restore_frame(&adsp_pool, dsl_frame);
        return iel_ec_return;
    }

    // algorithm
    iel_ec_return = ms_ecpt_weier_dblscamult_algo(adsp_result,
                                                  adsp_pool,
                                                  adsl_mont_ctx,
                                                  adsp_scalar_q,
                                                  adsp_scalar,
                                                  &dsl_ec_params_tmp,
                                                  adsrl_precomputations,
                                                  adsrl_precomp_q,
                                                  inl_width,
                                                  inp_width);
    // restore stackframe
    m_mem_pool_restore_frame(&adsp_pool, dsl_frame);
    return iel_ec_return;
} // m_ecpt_weier_dblscamult

extern "C" const dsd_ec_curve_params* m_ecc_init_named_curve(enum ied_ecc_named_curves iep_curve_name,
                                                             struct dsd_memory *adsp_memory,
                                                             struct dsd_mem_pool_ele *adsp_pool)
{
    struct dsd_ec_curve_params* adsl_select_params = NULL;
    switch(iep_curve_name) {
    case ied_P192:
        adsl_select_params = &dsg_P192_params;
        break;
    case ied_P224:
        adsl_select_params = &dsg_P224_params;
        break;
    case ied_P256:
        adsl_select_params = &dsg_P256_params;
        break;
    case ied_P384:
        adsl_select_params = &dsg_P384_params;
        break;
    case ied_P521:
        adsl_select_params = &dsg_P521_params;
        break;
    case ied_SECP192K1:
        adsl_select_params = &dsg_SECP192K1_params;
        break;
    case ied_SECP224K1:
        adsl_select_params = &dsg_SECP224K1_params;
        break;
    case ied_SECP256K1:
        adsl_select_params = &dsg_SECP256K1_params;
        break;
    case ied_brainpoolP256r1:
        adsl_select_params = &dsg_brainpoolP256r1_params;
        break;
    case ied_brainpoolP384r1:
        adsl_select_params = &dsg_brainpoolP384r1_params;
        break;
    case ied_brainpoolP512r1:
        adsl_select_params = &dsg_brainpoolP512r1_params;
        break;
    case ied_X25519:
        adsl_select_params = &dsg_X25519_params;
        break;
    case ied_X448:
        adsl_select_params = &dsg_X448_params;
        break;
    default: // named curve not implemented
        return NULL;
    }

    if (adsl_select_params->boc_precomps_set != FALSE) {  // unsynchronized check first
        return (const struct dsd_ec_curve_params*)adsl_select_params;
    }
    adsl_select_params->dsc_precomp_lock.m_enter();
    {
        if (adsl_select_params->boc_precomps_set != FALSE) { // synchronized check again
            adsl_select_params->dsc_precomp_lock.m_leave();
            return (const struct dsd_ec_curve_params*)adsl_select_params;
        }
        //if no memory is provided, fail
        if (adsp_memory == NULL) {
            adsl_select_params->dsc_precomp_lock.m_leave();
            return NULL;
        }
        //if no pool is provided, allocate one (failure will be detected by ms_ecc_precomp_curve)
        BOOL bol_pool_alloc = FALSE;
        if (adsp_pool == NULL) {
            bol_pool_alloc = TRUE;
            adsp_pool = m_mem_pool_create(adsp_memory,
                                          m_mem_pool_ecc_size(ied_m_ecc_init_named_curve, adsl_select_params->iec_name),
                                          1);
        }
        //launch precomputations
        enum ied_encry_return iel_ret;
        iel_ret = ms_ecc_precomp_curve(adsl_select_params,adsp_memory,adsp_pool);

        //free pool if necessary (in both success and failure case)
        if (bol_pool_alloc) {
            m_mem_pool_free(adsp_memory,adsp_pool);
        }

        if (iel_ret != ied_encry_success) {
            adsl_select_params->dsc_precomp_lock.m_leave();
            return NULL;
        }

        //set flag
        //MUST be last statement; must not be reordered by the optimizer
        adsl_select_params->boc_precomps_set = TRUE;
    }
    adsl_select_params->dsc_precomp_lock.m_leave();
    return (const struct dsd_ec_curve_params*)adsl_select_params;


} // m_ecc_init_named_curve


static void ms_precomp_free(struct dsd_memory *adsp_memory,
                            struct dsd_ec_curve_params* adsp_ec_params)
{
    adsp_ec_params->dsc_precomp_lock.m_enter();
    {
        if (adsp_ec_params->boc_precomps_set == FALSE) {
            adsp_ec_params->dsc_precomp_lock.m_leave();
            return;
        }
        adsp_ec_params->boc_precomps_set = FALSE;
        if (adsp_ec_params->iec_type != ied_montgomery) {
            for (int inl_i = 0; inl_i < 1<<8; ++inl_i)
            {
                m_ecpt_free(adsp_memory, &adsp_ec_params->adsc_precomps[inl_i]);
            }
            adsp_memory->amc_free(adsp_memory, adsp_ec_params->adsc_precomps);
        }
        adsp_ec_params->adsc_precomps = NULL;
        m_lnum_mont_free(adsp_ec_params->adsc_mont_ctx, adsp_memory);
        adsp_memory->amc_free(adsp_memory, adsp_ec_params->adsc_mont_ctx);
        adsp_ec_params->adsc_mont_ctx = NULL;

    }
    adsp_ec_params->dsc_precomp_lock.m_leave();
} // ms_precomp_free

extern "C" void m_ecc_precomp_free(struct dsd_memory *adsp_memory)
{
    if (!adsp_memory) {
        return;
    }
    ms_precomp_free(adsp_memory,&dsg_P192_params);
    ms_precomp_free(adsp_memory,&dsg_P224_params);
    ms_precomp_free(adsp_memory,&dsg_P256_params);
    ms_precomp_free(adsp_memory,&dsg_P384_params);
    ms_precomp_free(adsp_memory,&dsg_P521_params);
    ms_precomp_free(adsp_memory,&dsg_SECP192K1_params);
    ms_precomp_free(adsp_memory,&dsg_SECP224K1_params);
    ms_precomp_free(adsp_memory,&dsg_SECP256K1_params);
    ms_precomp_free(adsp_memory,&dsg_brainpoolP256r1_params);
    ms_precomp_free(adsp_memory,&dsg_brainpoolP384r1_params);
    ms_precomp_free(adsp_memory,&dsg_brainpoolP512r1_params);
    ms_precomp_free(adsp_memory,&dsg_X25519_params);
    ms_precomp_free(adsp_memory,&dsg_X448_params);
} // m_ecc_precomp_free

static void ms_ecpt_montgo_scamult_ladder(dsd_lnum *adsp_x4,
                                          dsd_lnum *adsp_z4,
                                          dsd_lnum *adsp_x5,
                                          dsd_lnum *adsp_z5,
                                          dsd_lnum *adsp_x1,
                                          dsd_lnum *adsp_x2,
                                          dsd_lnum *adsp_z2,
                                          dsd_lnum *adsp_x3,
                                          dsd_lnum *adsp_z3,
                                          dsd_lnum *adsp_tmp_1,
                                          dsd_lnum *adsp_tmp_2,
                                          dsd_lnum *adsp_tmp_3,
                                          dsd_lnum *adsp_tmp_4,
                                          dsd_lnum *adsp_tmp_5,
                                          dsd_lnum *adsp_tmp_6,
                                          dsd_lnum *adsp_tmpint_1,
                                          dsd_lnum *adsp_tmpint_2,
                                          dsd_lnum *adsp_a24,
                                          const dsd_ec_curve_params *adsp_params)
{
    ms_lnum_add_mod(adsp_tmp_1, adsp_x2, adsp_z2, adsp_params->adsc_prime);
    m_square_mont(adsp_tmp_2, adsp_tmp_1, adsp_params->adsc_mont_ctx, adsp_tmpint_1, adsp_tmpint_2);
    ms_lnum_sub_mod(adsp_tmp_3, adsp_x3, adsp_z3, adsp_params->adsc_prime);
    m_mul_mont(adsp_tmp_4, adsp_tmp_3, adsp_tmp_1, adsp_params->adsc_mont_ctx, adsp_tmpint_1, adsp_tmpint_2);
    ms_lnum_sub_mod(adsp_tmp_1, adsp_x2, adsp_z2, adsp_params->adsc_prime);
    m_square_mont(adsp_tmp_3, adsp_tmp_1, adsp_params->adsc_mont_ctx, adsp_tmpint_1, adsp_tmpint_2);
    ms_lnum_add_mod(adsp_tmp_5, adsp_x3, adsp_z3, adsp_params->adsc_prime);
    m_mul_mont(adsp_tmp_6, adsp_tmp_1, adsp_tmp_5, adsp_params->adsc_mont_ctx, adsp_tmpint_1, adsp_tmpint_2);
    ms_lnum_add_mod(adsp_tmp_1, adsp_tmp_4, adsp_tmp_6, adsp_params->adsc_prime);
    m_square_mont(adsp_x5, adsp_tmp_1, adsp_params->adsc_mont_ctx, adsp_tmpint_1, adsp_tmpint_2);
    ms_lnum_sub_mod(adsp_tmp_1, adsp_tmp_4, adsp_tmp_6, adsp_params->adsc_prime);
    m_square_mont(adsp_tmp_4, adsp_tmp_1, adsp_params->adsc_mont_ctx, adsp_tmpint_1, adsp_tmpint_2);
    m_mul_mont(adsp_z5, adsp_x1, adsp_tmp_4, adsp_params->adsc_mont_ctx, adsp_tmpint_1, adsp_tmpint_2);
    m_mul_mont(adsp_x4, adsp_tmp_2, adsp_tmp_3, adsp_params->adsc_mont_ctx, adsp_tmpint_1, adsp_tmpint_2);
    ms_lnum_sub_mod(adsp_tmp_1, adsp_tmp_2, adsp_tmp_3, adsp_params->adsc_prime);
    m_mul_mont(adsp_tmp_2, adsp_a24, adsp_tmp_1, adsp_params->adsc_mont_ctx, adsp_tmpint_1, adsp_tmpint_2);
    ms_lnum_add_mod(adsp_tmp_2, adsp_tmp_3, adsp_tmp_2, adsp_params->adsc_prime);
    m_mul_mont(adsp_z4, adsp_tmp_1, adsp_tmp_2, adsp_params->adsc_mont_ctx, adsp_tmpint_1, adsp_tmpint_2);
} // ms_ecpt_montgo_scamult_ladder

// inplace possible
extern "C" ied_encry_return m_ecpt_montgo_scamult(struct dsd_lnum *adsp_x_out,
                                                  struct dsd_mem_pool_ele *adsp_pool,
                                                  const struct dsd_lnum *adsp_k,
                                                  const struct dsd_lnum *adsp_x_in,
                                                  const struct dsd_ec_curve_params *adsp_params)
{
    if (!adsp_x_out || !adsp_pool || !adsp_k || !adsp_x_in || !adsp_params) {
        return ied_encry_null_pointer;
    }
    // TODO: size checked, value greater than prime allowed?
    if ((adsp_x_in->szc_used_size_bytes > adsp_params->adsc_prime->szc_used_size_bytes)
        || adsp_x_in->boc_is_negative
        || (adsp_k->szc_used_size_bytes == 0))
    {
        return ied_encry_invalid_input;
    }
    if (adsp_x_out->szc_alloc_size_bytes < adsp_params->adsc_prime->szc_used_size_bytes) {
        return ied_encry_insufficient_buffer;
    }
    // pool gets tmp and x,z
    dsd_mem_pool_frame dsl_frame = m_mem_pool_get_frame(adsp_pool);
    dsd_lnum *adsl_x1 = m_mem_pool_get_lnum_same_size(&adsp_pool, adsp_params->adsc_prime);
    dsd_lnum *adsl_x2 = m_mem_pool_get_lnum_same_size(&adsp_pool, adsp_params->adsc_prime);
    dsd_lnum *adsl_z2 = m_mem_pool_get_lnum_same_size(&adsp_pool, adsp_params->adsc_prime);
    dsd_lnum *adsl_x3 = m_mem_pool_get_lnum_same_size(&adsp_pool, adsp_params->adsc_prime);
    dsd_lnum *adsl_z3 = m_mem_pool_get_lnum_same_size(&adsp_pool, adsp_params->adsc_prime);
    dsd_lnum *adsl_a24 = m_mem_pool_get_lnum_same_size(&adsp_pool, adsp_params->adsc_prime);
    dsd_lnum *adsl_tmp_1 = m_mem_pool_get_lnum_byte_size(&adsp_pool, 2 * adsp_params->adsc_prime->szc_used_size_bytes + sizeof(LNUM_WORD));
    dsd_lnum *adsl_tmp_2 = m_mem_pool_get_lnum_byte_size(&adsp_pool, 2 * adsp_params->adsc_prime->szc_used_size_bytes + sizeof(LNUM_WORD));
    dsd_lnum *adsl_tmp_3 = m_mem_pool_get_lnum_byte_size(&adsp_pool, 2 * adsp_params->adsc_prime->szc_used_size_bytes + sizeof(LNUM_WORD));
    dsd_lnum *adsl_tmp_4 = m_mem_pool_get_lnum_byte_size(&adsp_pool, 2 * adsp_params->adsc_prime->szc_used_size_bytes + sizeof(LNUM_WORD));
    dsd_lnum *adsl_tmp_5 = m_mem_pool_get_lnum_byte_size(&adsp_pool, 2 * adsp_params->adsc_prime->szc_used_size_bytes + sizeof(LNUM_WORD));
    dsd_lnum *adsl_tmp_6 = m_mem_pool_get_lnum_byte_size(&adsp_pool, 2 * adsp_params->adsc_prime->szc_used_size_bytes + sizeof(LNUM_WORD));
    dsd_lnum *adsl_tmp_7 = m_mem_pool_get_lnum_byte_size(&adsp_pool, 2 * adsp_params->adsc_prime->szc_used_size_bytes + sizeof(LNUM_WORD));
    dsd_lnum *adsl_tmp_8 = m_mem_pool_get_lnum_byte_size(&adsp_pool, 2 * adsp_params->adsc_prime->szc_used_size_bytes + sizeof(LNUM_WORD));
    // x,z have same size and tmps have same size
    if (!adsl_a24 || !adsl_tmp_8) {
        m_mem_pool_restore_frame(&adsp_pool, dsl_frame);
        return ied_encry_pool_empty;
    }
    // init algorithm (set x,z, and a_24)
    ied_encry_return iel_ret = m_lnum_mont_conv(adsl_x1, adsp_pool, adsp_x_in, adsp_params->adsc_mont_ctx);
    if (iel_ret != ied_encry_success) {
        m_mem_pool_restore_frame(&adsp_pool, dsl_frame);
        return iel_ret;
    }
    // no error will occur (if params structure is ok)
    m_lnum_copy(adsl_x3, adsl_x1);
    m_lnum_copy(adsl_x2, adsp_params->adsc_mont_ctx->adsc_mont_one);
    m_lnum_copy(adsl_z3, adsp_params->adsc_mont_ctx->adsc_mont_one);
    m_lnum_set(adsl_z2, 0);
    // TODO: can to mont fail if previously succeeded?
    iel_ret = m_lnum_mont_conv(adsl_a24, adsp_pool, adsp_params->adsc_b_a24, adsp_params->adsc_mont_ctx);
    if (iel_ret != ied_encry_success) {
        m_mem_pool_restore_frame(&adsp_pool, dsl_frame);
        return iel_ret;
    }

    // fill x,z
    ms_lnum_zero_fill(adsl_x1, adsp_params->adsc_prime->szc_used_size_bytes);
    ms_lnum_zero_fill(adsl_x2, adsp_params->adsc_prime->szc_used_size_bytes);
    ms_lnum_zero_fill(adsl_z2, adsp_params->adsc_prime->szc_used_size_bytes);
    ms_lnum_zero_fill(adsl_x3, adsp_params->adsc_prime->szc_used_size_bytes);
    ms_lnum_zero_fill(adsl_z3, adsp_params->adsc_prime->szc_used_size_bytes);
    ms_lnum_zero_fill(adsl_a24, adsp_params->adsc_prime->szc_used_size_bytes);


    // montgomery ladder

    // used bits of most significant word
    int inl_bits = m_lnum_get_bit_count(adsp_k);
    int inl_bits_highest_word = inl_bits - ((int)adsp_k->szc_used_size_bytes / sizeof(LNUM_WORD) - 1) * (int)sizeof(LNUM_WORD) * CHAR_BIT;
    LNUM_WORD url_hightest_word = TOP_WORD(adsp_k);
    LNUM_WORD url_mask = (LNUM_WORD)1<<(sizeof(LNUM_WORD) * CHAR_BIT -1);
    url_hightest_word <<= sizeof(LNUM_WORD)*CHAR_BIT-inl_bits_highest_word;
    for (int inl_j = 0; inl_j < inl_bits_highest_word; inl_j++)
    {
        // TODO: move to inline function?
        if (url_hightest_word & url_mask) { // least significant bit set
            // ladderstep
            ms_ecpt_montgo_scamult_ladder(adsl_x3,
                                          adsl_z3,
                                          adsl_x2,
                                          adsl_z2,
                                          adsl_x1,
                                          adsl_x3,
                                          adsl_z3,
                                          adsl_x2,
                                          adsl_z2,
                                          adsl_tmp_1,
                                          adsl_tmp_2,
                                          adsl_tmp_3,
                                          adsl_tmp_4,
                                          adsl_tmp_5,
                                          adsl_tmp_6,
                                          adsl_tmp_7,
                                          adsl_tmp_8,
                                          adsl_a24,
                                          adsp_params);
        } else {
            // other ladderstep
            ms_ecpt_montgo_scamult_ladder(adsl_x2,
                                          adsl_z2,
                                          adsl_x3,
                                          adsl_z3,
                                          adsl_x1,
                                          adsl_x2,
                                          adsl_z2,
                                          adsl_x3,
                                          adsl_z3,
                                          adsl_tmp_1,
                                          adsl_tmp_2,
                                          adsl_tmp_3,
                                          adsl_tmp_4,
                                          adsl_tmp_5,
                                          adsl_tmp_6,
                                          adsl_tmp_7,
                                          adsl_tmp_8,
                                          adsl_a24,
                                          adsp_params);
        }
        url_hightest_word <<= 1;
    }

    // least significant used_words-1 words
    for (int inl_i = (int)adsp_k->szc_used_size_bytes / sizeof(LNUM_WORD) - 2; inl_i >= 0; inl_i--)
    {
        LNUM_WORD url_current_word = ((LNUM_WORD*)(adsp_k->aucc_data))[ inl_i];
        for (unsigned int unl_j = 0; unl_j < sizeof(LNUM_WORD) * CHAR_BIT; unl_j++)
        {
            if (url_current_word & url_mask) { // least significant bit set
                ms_ecpt_montgo_scamult_ladder(adsl_x3,
                                              adsl_z3,
                                              adsl_x2,
                                              adsl_z2,
                                              adsl_x1,
                                              adsl_x3,
                                              adsl_z3,
                                              adsl_x2,
                                              adsl_z2,
                                              adsl_tmp_1,
                                              adsl_tmp_2,
                                              adsl_tmp_3,
                                              adsl_tmp_4,
                                              adsl_tmp_5,
                                              adsl_tmp_6,
                                              adsl_tmp_7,
                                              adsl_tmp_8,
                                              adsl_a24,
                                              adsp_params);

                // ladderstep
            } else {
                // other ladderstep
                ms_ecpt_montgo_scamult_ladder(adsl_x2,
                                              adsl_z2,
                                              adsl_x3,
                                              adsl_z3,
                                              adsl_x1,
                                              adsl_x2,
                                              adsl_z2,
                                              adsl_x3,
                                              adsl_z3,
                                              adsl_tmp_1,
                                              adsl_tmp_2,
                                              adsl_tmp_3,
                                              adsl_tmp_4,
                                              adsl_tmp_5,
                                              adsl_tmp_6,
                                              adsl_tmp_7,
                                              adsl_tmp_8,
                                              adsl_a24,
                                              adsp_params);
            }
            url_current_word <<= 1;
        }
    }

    // set used words
    adsl_x2->boc_is_negative = FALSE;
    adsl_x2->szc_used_size_bytes = adsp_params->adsc_prime->szc_used_size_bytes;
    ms_lnum_set_used_words(adsl_x2);
    adsl_z2->boc_is_negative = FALSE;
    adsl_z2->szc_used_size_bytes = adsp_params->adsc_prime->szc_used_size_bytes;
    ms_lnum_set_used_words(adsl_z2);

    // TODO: neutral element?

    // convert x,z to x
    iel_ret = m_lnum_mont_red(adsl_z2, adsp_pool, adsl_z2, adsp_params->adsc_mont_ctx);
    if (iel_ret != ied_encry_success) {
        m_mem_pool_restore_frame(&adsp_pool, dsl_frame);
        return iel_ret;
    }
    // TODO: find data for neutral element
    iel_ret = m_lnum_inverse(adsl_tmp_1, adsp_pool, adsl_z2, adsp_params->adsc_prime);
    if (iel_ret != ied_encry_success) {
        m_mem_pool_restore_frame(&adsp_pool, dsl_frame);
        return iel_ret;
    }
    iel_ret = m_lnum_mont_red(adsl_x2, adsp_pool, adsl_x2, adsp_params->adsc_mont_ctx);
    if (iel_ret != ied_encry_success) {
        m_mem_pool_restore_frame(&adsp_pool, dsl_frame);
        return iel_ret;
    }
    iel_ret = m_lnum_mult(adsl_tmp_2, adsp_pool, adsl_x2, adsl_tmp_1);
    if (iel_ret != ied_encry_success) {
        m_mem_pool_restore_frame(&adsp_pool, dsl_frame);
        return iel_ret;
    }
    iel_ret = m_lnum_divide(NULL, adsp_x_out, adsp_pool, adsl_tmp_2, adsp_params->adsc_prime);

    m_mem_pool_restore_frame(&adsp_pool, dsl_frame);
    return iel_ret;

} // m_ecpt_montgo_scamult

//------------------------------------------------------------------------------
// Start of original file ./xs-3des.cpp
//------------------------------------------------------------------------------

#include <stdlib.h>
#include <string.h>

#ifdef _WIN32
#include <Windows.h>
#else
#include "hob-unix01.h"
#ifndef HL_UNIX
#define HL_UNIX
#if (defined __APPLE__) && (defined __MACH__)
#define HL_LINUX
#define HL_MACOS
#endif
#endif // !HL_UNIX
#endif

#include "hob-xslhcla1.hpp"
#include "hob-encry-2.h"
#include "hob-encry-intern-2.h"

#ifndef _WIN32
#include <limits.h>
#include <stdint.h>
#endif

// ------------------------------------------
//  Static declarations
// ------------------------------------------

/**
 * Generates 16 * 2 subkeys C''/ D'' required for encryption/decryption
 * from a given DES key.
 *
 *  @param abyp_des_key 64 Bit (8*8 Byte) DES key in FIPS46 bit order
 *  @param aunp_sub_key_tab Subkey table for storing 16 * 2 * 4 byte C''/D'' SubKeys
 */
static void ms_gen_des_subkeys(const unsigned char * abyp_des_key,
                               unsigned int * aunp_sub_key_tab);

/**
 * Encrypts a single DES block (64 bit) in 3DES EDE mode.
 *
 *  @param data Pointer to input data (2 unsigned int values)
 *  @param aunp_sub_key_tab1 Pointer to precomputed DES subkeys from key 1
 *  @param aunp_sub_key_tab2 Pointer to precomputed DES subkeys from key 2
 *  @param aunp_sub_key_tab3 Pointer to precomputed DES subkeys from key 3
 */

static void ms_3des_encrypt(unsigned int * aunp_data,
                            const unsigned int * aunp_sub_key_tab1,
                            const unsigned int * aunp_sub_key_tab2,
                            const unsigned int * aunp_sub_key_tab3);

/**
 * Decrypts a single DES block (64 bit) in 3DES EDE mode.
 *
 *  @param aunp_data Pointer to input data (2 unsigned int values)
 *  @param aunp_sub_key_tab1 Pointer to precomputed DES subkeys from key 1
 *  @param aunp_sub_key_tab2 Pointer to precomputed DES subkeys from key 2
 *  @param aunp_sub_key_tab3 Pointer to precomputed DES subkeys from key 3
 */
static void ms_3des_decrypt(unsigned int * aunp_data,
                            const unsigned int * aunp_sub_key_tab1,
                            const unsigned int * aunp_sub_key_tab2,
                            const unsigned int * aunp_sub_key_tab3);

// ------------------------------------------
//  Initialization
// ------------------------------------------

void m_3des_init_key(struct dsd_cipher_key* adsp_key,
                     const unsigned char* abyp_key,
                     size_t)
{
    adsp_key->unc_key_size = 24;
    ms_gen_des_subkeys(abyp_key, adsp_key->dsc_3des_subkey.unrc_subkey1);
    ms_gen_des_subkeys(abyp_key + 8, adsp_key->dsc_3des_subkey.unrc_subkey2);
    ms_gen_des_subkeys(abyp_key + 16, adsp_key->dsc_3des_subkey.unrc_subkey3);
}

// ------------------------------------------
//  Encryption / Decryption
// ------------------------------------------

void m_3des_cbc_encrypt(unsigned char* abyp_output,
                        const unsigned char* abyp_input,
                        size_t szp_len,
                        const struct dsd_cipher_key* adsp_key,
                        const unsigned char* abyp_iv)
{
    unsigned int unl_tout0, unl_tout1;
    unsigned int unrl_tin[2];
    unsigned int unl_i = 0;

    if (szp_len == 0) {
        return;
    }

    ms_read_little_endian(unl_tout0, abyp_iv);
    ms_read_little_endian(unl_tout1, abyp_iv + 4);      // dto. high

    for (unl_i = 0; unl_i < szp_len; unl_i += 8) {
        ms_read_little_endian(unrl_tin[0], abyp_input + unl_i);        // get low  4 data bytes
        ms_read_little_endian(unrl_tin[1], abyp_input + unl_i + 4);    // get high 4 data bytes
        unrl_tin[0] ^= unl_tout0;
        unrl_tin[1] ^= unl_tout1;
        ms_3des_encrypt(unrl_tin,
                        adsp_key->dsc_3des_subkey.unrc_subkey1,
                        adsp_key->dsc_3des_subkey.unrc_subkey2,
                        adsp_key->dsc_3des_subkey.unrc_subkey3);
        unl_tout0 = unrl_tin[0];
        ms_write_little_endian(abyp_output + unl_i, unrl_tin[0]);
        unl_tout1 = unrl_tin[1];
        ms_write_little_endian(abyp_output + unl_i + 4, unrl_tin[1]);
    }
    m_sec_memzero(unrl_tin,2);
    //other temporary variables are in registers
} // m_3des_cbc_encrypt

void m_3des_cbc_decrypt(unsigned char* abyp_output,
                        const unsigned char* abyp_input,
                        size_t szp_len,
                        const struct dsd_cipher_key* adsp_key,
                        const unsigned char* abyp_iv)
{
    unsigned int unl_tin0, unl_tin1;
    unsigned int unl_xor0, unl_xor1;
    unsigned int unrl_tin[2];
    size_t szl_i;

    if (szp_len == 0) {
        return;
    }

    ms_read_little_endian(unl_xor0, abyp_iv);
    ms_read_little_endian(unl_xor1, abyp_iv + 4);

    for (szl_i = 0; szl_i < szp_len; szl_i += 8) {
        ms_read_little_endian(unl_tin0, abyp_input + szl_i);
        unrl_tin[0] = unl_tin0;
        ms_read_little_endian(unl_tin1, abyp_input + szl_i + 4);
        unrl_tin[1] = unl_tin1;
        ms_3des_decrypt(unrl_tin,
                        adsp_key->dsc_3des_subkey.unrc_subkey1,
                        adsp_key->dsc_3des_subkey.unrc_subkey2,
                        adsp_key->dsc_3des_subkey.unrc_subkey3);
        ms_write_little_endian(abyp_output + szl_i, unrl_tin[0] ^ unl_xor0);
        ms_write_little_endian(abyp_output + szl_i + 4, unrl_tin[1] ^ unl_xor1);
        unl_xor0 = unl_tin0;
        unl_xor1 = unl_tin1;
    }
    m_sec_memzero(unrl_tin,2);
    //other temporary variables are in registers
} // m_3des_cbc_decrypt

// ------------------------------------------
//  Static definitions
// ------------------------------------------
#define SP_BOX_LEN  64          // 64 longs a 32 Bit

// specific rotates.
#define LROT1(l) ((( l << 1) | ((l >> 31) &   1)) & (unsigned int)(0xFFFFFFFF))
#define LROT4(l) ((( l << 4) | ((l >> 28) & 0x0F)) & (unsigned int)(0xFFFFFFFF))
#define RROT1(l) ((((l >> 1) & 0x7FFFFFFF) | ((l & 1) << 31)) & (unsigned int)(0xFFFFFFFF))
#define RROT4(l) ((((l >> 4) & 0x0FFFFFFF) | ((l & 0x0F)<< 28)) & (unsigned int)(0xFFFFFFFF))
#define RROT1MOD28BIT(l) \
    ((((l >> 1) & 0x07FFFFFF) | ((l & 1) << 27)) & (unsigned int)(0x0FFFFFFF))
#define RROT2MOD28BIT(l) \
    ((((l >> 2) & 0x03FFFFFF) | ((l & 3) << 26)) & (unsigned int)(0x0FFFFFFF))

/*--------------------------------------------------------------*/
/* Permutation functions (taken from EAY)			            */
/*--------------------------------------------------------------*/
// Bit-Permutation between 2 long words, see documentation
// DESSWAP.TXT for specification of operation

#define PERMUTE2(x,y,tmp,bitcnt,bitmask) { \
        tmp = ((x >> bitcnt) ^ y) & bitmask; \
        x ^= (tmp << bitcnt); \
        y ^= tmp; }

// Bit-Permutation within 1 long words, works similar
// as Bit-Permutation between 2 long words, but does not work
// for bitcnt <= 0 !!!
// (due to sign extension problem when using right shift !!!)

#define PERMUTE1(x,tmp,bitcnt,bitmask) { \
        tmp = (x ^ (x >> (16+bitcnt))) & bitmask; \
        x = x ^ tmp ^ (tmp << (16+bitcnt)); }

/*--------------------------------------------------------------*/
/* DES functions (adapted from EAY)				*/
/*--------------------------------------------------------------*/
//
// DES Encryption/Decryption Round Function
//
//
// NOTE: the primary l,r rotate that is needed to generate correct
//       Bit order for the S-Box inputs (Expansion Permutation) has
//	 been changed so that the bit order for l and r is now:
//       31,20,29,......,1,32 in FIPS order (was before:
//       29,28,27,......,1,32,31,30).
//	 This eases and unifies access via a single Index into SP-Tables.
//       Therefore the SP-Boxes had to be modified (changed Output
//       Permutation) see SBOXGEN1.C. Further the Subkey-Generation
//	 routine is modified for reduced left rotate by 2 Bits.
//
// Operations:
// XOR with S1,S3,S5,S7 Subkey i   (C'')
// XOR with S2,S4,S6,S8 Subkey i+1 (D'')
// align for S-Box Access (E-Box Function helper function RROT4)
// XOR with S1 Output,
// XOR with S3 Output,
// XOR with S5 Output,
// XOR with S7 Output,
// XOR with S2 Output,
// XOR with S4 Output,
// XOR with S6 Output,
// XOR with S8 Output

#define DES_ROUND(L,R,K,SK_TAB) { \
        unl_u=R^SK_TAB[K  ]; \
        unl_v=R^SK_TAB[K+1]; \
        unl_v=RROT4(unl_v); \
        L^= \
            unrs_des_sp_box[unl_u & 0x3F]^ \
            unrs_des_sp_box[2*SP_BOX_LEN + ((unl_u>> 8) & 0x3F)]^ \
            unrs_des_sp_box[4*SP_BOX_LEN + ((unl_u>>16) & 0x3F)]^ \
            unrs_des_sp_box[6*SP_BOX_LEN + ((unl_u>>24) & 0x3F)]^ \
            unrs_des_sp_box[1*SP_BOX_LEN + (unl_v & 0x3F)]^ \
            unrs_des_sp_box[3*SP_BOX_LEN + ((unl_v>> 8) & 0x3F)]^ \
            unrs_des_sp_box[5*SP_BOX_LEN + ((unl_v>>16) & 0x3F)]^ \
            unrs_des_sp_box[7*SP_BOX_LEN + ((unl_v>>24) & 0x3F)]; }

//----------------------------------------------------------------------
// DES Initial permutation (IP)
//
// Note: the Output is in reversed bit-Order with l and r values
// ----- exchanged !!
//
// Description of Operation:
//	 exch. low/high nibbles
//	 exch. low/high 16 Bit Words
//	 exch. low/high 2 bits/nib.
//	 exch. low/high bytes
//	 exch. even/odd bits
//

#define DES_IP(l,r) { \
        unsigned int unl_tmp; \
        PERMUTE2(r,l,unl_tmp, 4,0x0F0F0F0F) \
        PERMUTE2(l,r,unl_tmp,16,0x0000FFFF) \
        PERMUTE2(r,l,unl_tmp, 2,0x33333333) \
        PERMUTE2(l,r,unl_tmp, 8,0x00FF00FF) \
        PERMUTE2(r,l,unl_tmp, 1,0x55555555)}

//----------------------------------------------------------------------
// DES Final permutation (FP)
//
// Note: the Input is in reversed bit-Order with l and r values
// ----- exchanged !!
//
// Description of Operation:
//	 exch. odd/even bits
//	 exch. low/high bytes
//	 exch. low/high 2 bits/nib.
//	 exch. low/high 16 Bit Words
//	 exch. low/high nibbles
//

#define DES_FP(l,r) { \
        unsigned int unl_tmp; \
        PERMUTE2(l,r,unl_tmp, 1,0x55555555) \
        PERMUTE2(r,l,unl_tmp, 8,0x00FF00FF) \
        PERMUTE2(l,r,unl_tmp, 2,0x33333333) \
        PERMUTE2(r,l,unl_tmp,16,0x0000FFFF) \
        PERMUTE2(l,r,unl_tmp, 4,0x0F0F0F0F)}

//----------------------------------------------------------------------
// DES Initial Key permutation (PC-1)
//
// Note: the Output is in reversed bit-Order !
// ----
//
// Description of Operation:
//	 exch. low/high Nibbles
//	 exch. low/high upmost bits C
//	 dto.			    D
//	 exch. odd/even bits
//	 exch. low/high bytes
//	 exch. odd/even bits
//	 assemble D-Bits, note c is used for upmost bits !!
//	 remove D-Bits from C

#define PC1(d,c) { \
        unsigned int unl_pc1_tmp; \
        PERMUTE2(d,c,unl_pc1_tmp, 4,0x0F0F0F0F) \
        PERMUTE1(c,unl_pc1_tmp,2,0x00003333) \
        PERMUTE1(d,unl_pc1_tmp,2,0x00003333) \
        PERMUTE2(d,c,unl_pc1_tmp, 1,0x55555555) \
        PERMUTE2(c,d,unl_pc1_tmp, 8,0x00FF00FF) \
        PERMUTE2(d,c,unl_pc1_tmp, 1,0x55555555) \
        d= (((d & 0x000000FF) << 16) | \
            (d & 0x0000FF00) | \
            ((d & 0x00FF0000) >> 16) | \
            ((c & 0xF0000000) >>  4)); \
        c &= 0x0FFFFFFF; }

//----------------------------------------------------
// constant values
//----------------------------------------------------

static const unsigned int cunrrs_des_kp_box[8][64]={
// CP-Box 1 :
    {
        0x00000000,0x00000010,0x20000000,0x20000010,
        0x00010000,0x00010010,0x20010000,0x20010010,
        0x00000800,0x00000810,0x20000800,0x20000810,
        0x00010800,0x00010810,0x20010800,0x20010810,
        0x00000020,0x00000030,0x20000020,0x20000030,
        0x00010020,0x00010030,0x20010020,0x20010030,
        0x00000820,0x00000830,0x20000820,0x20000830,
        0x00010820,0x00010830,0x20010820,0x20010830,
        0x00080000,0x00080010,0x20080000,0x20080010,
        0x00090000,0x00090010,0x20090000,0x20090010,
        0x00080800,0x00080810,0x20080800,0x20080810,
        0x00090800,0x00090810,0x20090800,0x20090810,
        0x00080020,0x00080030,0x20080020,0x20080030,
        0x00090020,0x00090030,0x20090020,0x20090030,
        0x00080820,0x00080830,0x20080820,0x20080830,
        0x00090820,0x00090830,0x20090820,0x20090830,
    },

// CP-Box 2 :
    {
        0x00000000,0x02000000,0x00002000,0x02002000,
        0x00200000,0x02200000,0x00202000,0x02202000,
        0x00000004,0x02000004,0x00002004,0x02002004,
        0x00200004,0x02200004,0x00202004,0x02202004,
        0x00000400,0x02000400,0x00002400,0x02002400,
        0x00200400,0x02200400,0x00202400,0x02202400,
        0x00000404,0x02000404,0x00002404,0x02002404,
        0x00200404,0x02200404,0x00202404,0x02202404,
        0x10000000,0x12000000,0x10002000,0x12002000,
        0x10200000,0x12200000,0x10202000,0x12202000,
        0x10000004,0x12000004,0x10002004,0x12002004,
        0x10200004,0x12200004,0x10202004,0x12202004,
        0x10000400,0x12000400,0x10002400,0x12002400,
        0x10200400,0x12200400,0x10202400,0x12202400,
        0x10000404,0x12000404,0x10002404,0x12002404,
        0x10200404,0x12200404,0x10202404,0x12202404,
    },

// CP-Box 3 :
    {
        0x00000000,0x00000001,0x00040000,0x00040001,
        0x01000000,0x01000001,0x01040000,0x01040001,
        0x00000002,0x00000003,0x00040002,0x00040003,
        0x01000002,0x01000003,0x01040002,0x01040003,
        0x00000200,0x00000201,0x00040200,0x00040201,
        0x01000200,0x01000201,0x01040200,0x01040201,
        0x00000202,0x00000203,0x00040202,0x00040203,
        0x01000202,0x01000203,0x01040202,0x01040203,
        0x08000000,0x08000001,0x08040000,0x08040001,
        0x09000000,0x09000001,0x09040000,0x09040001,
        0x08000002,0x08000003,0x08040002,0x08040003,
        0x09000002,0x09000003,0x09040002,0x09040003,
        0x08000200,0x08000201,0x08040200,0x08040201,
        0x09000200,0x09000201,0x09040200,0x09040201,
        0x08000202,0x08000203,0x08040202,0x08040203,
        0x09000202,0x09000203,0x09040202,0x09040203,
    },

// CP-Box 4 :
    {
        0x00000000,0x00100000,0x00000100,0x00100100,
        0x00000008,0x00100008,0x00000108,0x00100108,
        0x00001000,0x00101000,0x00001100,0x00101100,
        0x00001008,0x00101008,0x00001108,0x00101108,
        0x04000000,0x04100000,0x04000100,0x04100100,
        0x04000008,0x04100008,0x04000108,0x04100108,
        0x04001000,0x04101000,0x04001100,0x04101100,
        0x04001008,0x04101008,0x04001108,0x04101108,
        0x00020000,0x00120000,0x00020100,0x00120100,
        0x00020008,0x00120008,0x00020108,0x00120108,
        0x00021000,0x00121000,0x00021100,0x00121100,
        0x00021008,0x00121008,0x00021108,0x00121108,
        0x04020000,0x04120000,0x04020100,0x04120100,
        0x04020008,0x04120008,0x04020108,0x04120108,
        0x04021000,0x04121000,0x04021100,0x04121100,
        0x04021008,0x04121008,0x04021108,0x04121108,
    },

// DP-Box 1 :
    {
        0x00000000,0x10000000,0x00010000,0x10010000,
        0x00000004,0x10000004,0x00010004,0x10010004,
        0x20000000,0x30000000,0x20010000,0x30010000,
        0x20000004,0x30000004,0x20010004,0x30010004,
        0x00100000,0x10100000,0x00110000,0x10110000,
        0x00100004,0x10100004,0x00110004,0x10110004,
        0x20100000,0x30100000,0x20110000,0x30110000,
        0x20100004,0x30100004,0x20110004,0x30110004,
        0x00001000,0x10001000,0x00011000,0x10011000,
        0x00001004,0x10001004,0x00011004,0x10011004,
        0x20001000,0x30001000,0x20011000,0x30011000,
        0x20001004,0x30001004,0x20011004,0x30011004,
        0x00101000,0x10101000,0x00111000,0x10111000,
        0x00101004,0x10101004,0x00111004,0x10111004,
        0x20101000,0x30101000,0x20111000,0x30111000,
        0x20101004,0x30101004,0x20111004,0x30111004,
    },

// DP-Box 2 :
    {
        0x00000000,0x08000000,0x00000008,0x08000008,
        0x00000400,0x08000400,0x00000408,0x08000408,
        0x00020000,0x08020000,0x00020008,0x08020008,
        0x00020400,0x08020400,0x00020408,0x08020408,
        0x00000001,0x08000001,0x00000009,0x08000009,
        0x00000401,0x08000401,0x00000409,0x08000409,
        0x00020001,0x08020001,0x00020009,0x08020009,
        0x00020401,0x08020401,0x00020409,0x08020409,
        0x02000000,0x0a000000,0x02000008,0x0a000008,
        0x02000400,0x0a000400,0x02000408,0x0a000408,
        0x02020000,0x0a020000,0x02020008,0x0a020008,
        0x02020400,0x0a020400,0x02020408,0x0a020408,
        0x02000001,0x0a000001,0x02000009,0x0a000009,
        0x02000401,0x0a000401,0x02000409,0x0a000409,
        0x02020001,0x0a020001,0x02020009,0x0a020009,
        0x02020401,0x0a020401,0x02020409,0x0a020409,
    },

// DP-Box 3 :
    {
        0x00000000,0x00000100,0x00080000,0x00080100,
        0x01000000,0x01000100,0x01080000,0x01080100,
        0x00000010,0x00000110,0x00080010,0x00080110,
        0x01000010,0x01000110,0x01080010,0x01080110,
        0x00200000,0x00200100,0x00280000,0x00280100,
        0x01200000,0x01200100,0x01280000,0x01280100,
        0x00200010,0x00200110,0x00280010,0x00280110,
        0x01200010,0x01200110,0x01280010,0x01280110,
        0x00000200,0x00000300,0x00080200,0x00080300,
        0x01000200,0x01000300,0x01080200,0x01080300,
        0x00000210,0x00000310,0x00080210,0x00080310,
        0x01000210,0x01000310,0x01080210,0x01080310,
        0x00200200,0x00200300,0x00280200,0x00280300,
        0x01200200,0x01200300,0x01280200,0x01280300,
        0x00200210,0x00200310,0x00280210,0x00280310,
        0x01200210,0x01200310,0x01280210,0x01280310,
    },

// DP-Box 4 :
    {
        0x00000000,0x04000000,0x00040000,0x04040000,
        0x00000002,0x04000002,0x00040002,0x04040002,
        0x00002000,0x04002000,0x00042000,0x04042000,
        0x00002002,0x04002002,0x00042002,0x04042002,
        0x00000020,0x04000020,0x00040020,0x04040020,
        0x00000022,0x04000022,0x00040022,0x04040022,
        0x00002020,0x04002020,0x00042020,0x04042020,
        0x00002022,0x04002022,0x00042022,0x04042022,
        0x00000800,0x04000800,0x00040800,0x04040800,
        0x00000802,0x04000802,0x00040802,0x04040802,
        0x00002800,0x04002800,0x00042800,0x04042800,
        0x00002802,0x04002802,0x00042802,0x04042802,
        0x00000820,0x04000820,0x00040820,0x04040820,
        0x00000822,0x04000822,0x00040822,0x04040822,
        0x00002820,0x04002820,0x00042820,0x04042820,
        0x00002822,0x04002822,0x00042822,0x04042822,
    },
};

static const unsigned int unrs_des_sp_box[8*64]={

// SP-Box 1 :
    0x00820200, 0x00020000, 0x80800000, 0x80820200,
    0x00800000, 0x80020200, 0x80020000, 0x80800000,
    0x80020200, 0x00820200, 0x00820000, 0x80000200,
    0x80800200, 0x00800000, 0x00000000, 0x80020000,
    0x00020000, 0x80000000, 0x00800200, 0x00020200,
    0x80820200, 0x00820000, 0x80000200, 0x00800200,
    0x80000000, 0x00000200, 0x00020200, 0x80820000,
    0x00000200, 0x80800200, 0x80820000, 0x00000000,
    0x00000000, 0x80820200, 0x00800200, 0x80020000,
    0x00820200, 0x00020000, 0x80000200, 0x00800200,
    0x80820000, 0x00000200, 0x00020200, 0x80800000,
    0x80020200, 0x80000000, 0x80800000, 0x00820000,
    0x80820200, 0x00020200, 0x00820000, 0x80800200,
    0x00800000, 0x80000200, 0x80020000, 0x00000000,
    0x00020000, 0x00800000, 0x80800200, 0x00820200,
    0x80000000, 0x80820000, 0x00000200, 0x80020200,

// SP-Box 2 :
    0x10042004, 0x00000000, 0x00042000, 0x10040000,
    0x10000004, 0x00002004, 0x10002000, 0x00042000,
    0x00002000, 0x10040004, 0x00000004, 0x10002000,
    0x00040004, 0x10042000, 0x10040000, 0x00000004,
    0x00040000, 0x10002004, 0x10040004, 0x00002000,
    0x00042004, 0x10000000, 0x00000000, 0x00040004,
    0x10002004, 0x00042004, 0x10042000, 0x10000004,
    0x10000000, 0x00040000, 0x00002004, 0x10042004,
    0x00040004, 0x10042000, 0x10002000, 0x00042004,
    0x10042004, 0x00040004, 0x10000004, 0x00000000,
    0x10000000, 0x00002004, 0x00040000, 0x10040004,
    0x00002000, 0x10000000, 0x00042004, 0x10002004,
    0x10042000, 0x00002000, 0x00000000, 0x10000004,
    0x00000004, 0x10042004, 0x00042000, 0x10040000,
    0x10040004, 0x00040000, 0x00002004, 0x10002000,
    0x10002004, 0x00000004, 0x10040000, 0x00042000,

// SP-Box 3 :
    0x41000000, 0x01010040, 0x00000040, 0x41000040,
    0x40010000, 0x01000000, 0x41000040, 0x00010040,
    0x01000040, 0x00010000, 0x01010000, 0x40000000,
    0x41010040, 0x40000040, 0x40000000, 0x41010000,
    0x00000000, 0x40010000, 0x01010040, 0x00000040,
    0x40000040, 0x41010040, 0x00010000, 0x41000000,
    0x41010000, 0x01000040, 0x40010040, 0x01010000,
    0x00010040, 0x00000000, 0x01000000, 0x40010040,
    0x01010040, 0x00000040, 0x40000000, 0x00010000,
    0x40000040, 0x40010000, 0x01010000, 0x41000040,
    0x00000000, 0x01010040, 0x00010040, 0x41010000,
    0x40010000, 0x01000000, 0x41010040, 0x40000000,
    0x40010040, 0x41000000, 0x01000000, 0x41010040,
    0x00010000, 0x01000040, 0x41000040, 0x00010040,
    0x01000040, 0x00000000, 0x41010000, 0x40000040,
    0x41000000, 0x40010040, 0x00000040, 0x01010000,

// SP-Box 4 :
    0x00100402, 0x04000400, 0x00000002, 0x04100402,
    0x00000000, 0x04100000, 0x04000402, 0x00100002,
    0x04100400, 0x04000002, 0x04000000, 0x00000402,
    0x04000002, 0x00100402, 0x00100000, 0x04000000,
    0x04100002, 0x00100400, 0x00000400, 0x00000002,
    0x00100400, 0x04000402, 0x04100000, 0x00000400,
    0x00000402, 0x00000000, 0x00100002, 0x04100400,
    0x04000400, 0x04100002, 0x04100402, 0x00100000,
    0x04100002, 0x00000402, 0x00100000, 0x04000002,
    0x00100400, 0x04000400, 0x00000002, 0x04100000,
    0x04000402, 0x00000000, 0x00000400, 0x00100002,
    0x00000000, 0x04100002, 0x04100400, 0x00000400,
    0x04000000, 0x04100402, 0x00100402, 0x00100000,
    0x04100402, 0x00000002, 0x04000400, 0x00100402,
    0x00100002, 0x00100400, 0x04100000, 0x04000402,
    0x00000402, 0x04000000, 0x04000002, 0x04100400,

// SP-Box 5 :
    0x02000000, 0x00004000, 0x00000100, 0x02004108,
    0x02004008, 0x02000100, 0x00004108, 0x02004000,
    0x00004000, 0x00000008, 0x02000008, 0x00004100,
    0x02000108, 0x02004008, 0x02004100, 0x00000000,
    0x00004100, 0x02000000, 0x00004008, 0x00000108,
    0x02000100, 0x00004108, 0x00000000, 0x02000008,
    0x00000008, 0x02000108, 0x02004108, 0x00004008,
    0x02004000, 0x00000100, 0x00000108, 0x02004100,
    0x02004100, 0x02000108, 0x00004008, 0x02004000,
    0x00004000, 0x00000008, 0x02000008, 0x02000100,
    0x02000000, 0x00004100, 0x02004108, 0x00000000,
    0x00004108, 0x02000000, 0x00000100, 0x00004008,
    0x02000108, 0x00000100, 0x00000000, 0x02004108,
    0x02004008, 0x02004100, 0x00000108, 0x00004000,
    0x00004100, 0x02004008, 0x02000100, 0x00000108,
    0x00000008, 0x00004108, 0x02004000, 0x02000008,

// SP-Box 6 :
    0x20000010, 0x00080010, 0x00000000, 0x20080800,
    0x00080010, 0x00000800, 0x20000810, 0x00080000,
    0x00000810, 0x20080810, 0x00080800, 0x20000000,
    0x20000800, 0x20000010, 0x20080000, 0x00080810,
    0x00080000, 0x20000810, 0x20080010, 0x00000000,
    0x00000800, 0x00000010, 0x20080800, 0x20080010,
    0x20080810, 0x20080000, 0x20000000, 0x00000810,
    0x00000010, 0x00080800, 0x00080810, 0x20000800,
    0x00000810, 0x20000000, 0x20000800, 0x00080810,
    0x20080800, 0x00080010, 0x00000000, 0x20000800,
    0x20000000, 0x00000800, 0x20080010, 0x00080000,
    0x00080010, 0x20080810, 0x00080800, 0x00000010,
    0x20080810, 0x00080800, 0x00080000, 0x20000810,
    0x20000010, 0x20080000, 0x00080810, 0x00000000,
    0x00000800, 0x20000010, 0x20000810, 0x20080800,
    0x20080000, 0x00000810, 0x00000010, 0x20080010,

// SP-Box 7 :
    0x00001000, 0x00000080, 0x00400080, 0x00400001,
    0x00401081, 0x00001001, 0x00001080, 0x00000000,
    0x00400000, 0x00400081, 0x00000081, 0x00401000,
    0x00000001, 0x00401080, 0x00401000, 0x00000081,
    0x00400081, 0x00001000, 0x00001001, 0x00401081,
    0x00000000, 0x00400080, 0x00400001, 0x00001080,
    0x00401001, 0x00001081, 0x00401080, 0x00000001,
    0x00001081, 0x00401001, 0x00000080, 0x00400000,
    0x00001081, 0x00401000, 0x00401001, 0x00000081,
    0x00001000, 0x00000080, 0x00400000, 0x00401001,
    0x00400081, 0x00001081, 0x00001080, 0x00000000,
    0x00000080, 0x00400001, 0x00000001, 0x00400080,
    0x00000000, 0x00400081, 0x00400080, 0x00001080,
    0x00000081, 0x00001000, 0x00401081, 0x00400000,
    0x00401080, 0x00000001, 0x00001001, 0x00401081,
    0x00400001, 0x00401080, 0x00401000, 0x00001001,

// SP-Box 8 :
    0x08200020, 0x08208000, 0x00008020, 0x00000000,
    0x08008000, 0x00200020, 0x08200000, 0x08208020,
    0x00000020, 0x08000000, 0x00208000, 0x00008020,
    0x00208020, 0x08008020, 0x08000020, 0x08200000,
    0x00008000, 0x00208020, 0x00200020, 0x08008000,
    0x08208020, 0x08000020, 0x00000000, 0x00208000,
    0x08000000, 0x00200000, 0x08008020, 0x08200020,
    0x00200000, 0x00008000, 0x08208000, 0x00000020,
    0x00200000, 0x00008000, 0x08000020, 0x08208020,
    0x00008020, 0x08000000, 0x00000000, 0x00208000,
    0x08200020, 0x08008020, 0x08008000, 0x00200020,
    0x08208000, 0x00000020, 0x00200020, 0x08008000,
    0x08208020, 0x00200000, 0x08200000, 0x08000020,
    0x00208000, 0x00008020, 0x08008020, 0x08200000,
    0x00000020, 0x08208000, 0x00208020, 0x00000000,
    0x08000000, 0x08200020, 0x00008000, 0x00208020,
};

static void ms_3des_encrypt(unsigned int * aunp_data,
                            const unsigned int * aunp_sub_key_tab1,
                            const unsigned int * aunp_sub_key_tab2,
                            const unsigned int * aunp_sub_key_tab3)
{
    int inl_i;
    unsigned int unl_l, unl_r, unl_u, unl_v;

    unl_r = aunp_data[0];               // get DATA low
    unl_l = aunp_data[1];               // get DATA high
    //------------------------------------------------------------
    // Do initial permutation and prepare for E-Box Access
    //------------------------------------------------------------
    DES_IP(unl_r, unl_l);               // do Initial Permutation
    unl_r = LROT1(unl_r);               // prepare for S-Box access
    unl_l = LROT1(unl_l);               // dto.
    //------------------------------------------------------------
    // Do 1st Encryption
    //------------------------------------------------------------
    inl_i = 0;
    do {
        DES_ROUND(unl_l, unl_r, inl_i, aunp_sub_key_tab1); // use subkey 1/5/ 9/13, C'',D''
        DES_ROUND(unl_r, unl_l, inl_i + 2, aunp_sub_key_tab1); // use subkey 2/6/10/14, C'',D''
        inl_i += 4;
    } while (inl_i < 32);
    //------------------------------------------------------------
    // Do 2nd Encryption (is a DECRYPTION!!)
    //------------------------------------------------------------
    inl_i = 30;
    do {
        DES_ROUND(unl_r, unl_l, inl_i, aunp_sub_key_tab2); // use subkey 16/12/8/4, C'',D''
        DES_ROUND(unl_l, unl_r, inl_i - 2, aunp_sub_key_tab2); // use subkey 15/11/7/3, C'',D''
        inl_i -= 4;
    } while (inl_i > 0);
    //------------------------------------------------------------
    // Do 3rd Encryption
    //------------------------------------------------------------
    inl_i = 0;
    do {
        DES_ROUND(unl_l, unl_r, inl_i, aunp_sub_key_tab3); // use subkey 1/5/ 9/13, C'',D''
        DES_ROUND(unl_r, unl_l, inl_i + 2, aunp_sub_key_tab3); // use subkey 2/6/10/14, C'',D''
        inl_i += 4;
    } while (inl_i < 32);
    //----------- -------------------------------------------------
    // rearrange bits before final permutation, do final permutation
    //------------------------------------------------------------
    unl_l = RROT1(unl_l);               // convert back to original bit order
    unl_r = RROT1(unl_r);               // dto.

    DES_FP(unl_r, unl_l);               // Do Final Permutation
    //------------------------------------------------------------
    //Store new data words, clear used temporary variables (safety)
    //------------------------------------------------------------
    aunp_data[0] = unl_l;               // save new low
    aunp_data[1] = unl_r;               // save new high
    //temporary variables are in registers
} // ms_3des_encrypt

static void ms_3des_decrypt(unsigned int * aunp_data,
                            const unsigned int * aunp_sub_key_tab1,
                            const unsigned int * aunp_sub_key_tab2,
                            const unsigned int * aunp_sub_key_tab3)
{
    int inl_i;
    unsigned int unl_l, unl_r, unl_u, unl_v;
    unl_r = aunp_data[0];               // get DATA low
    unl_l = aunp_data[1];               // get DATA high
    //------------------------------------------------------------
    // Do initial permutation and prepare for E-Box Access
    //------------------------------------------------------------
    DES_IP(unl_r, unl_l);               // do Initial Permutation
    unl_r = LROT1(unl_r);               // prepare for S-Box access
    unl_l = LROT1(unl_l);               // dto.
    //------------------------------------------------------------
    // Do 1st Decryption
    //------------------------------------------------------------
    inl_i = 30;
    do {
        DES_ROUND(unl_l, unl_r, inl_i, aunp_sub_key_tab3);     // use subkey 16/12/8/4, C'',D''
        DES_ROUND(unl_r, unl_l, inl_i - 2, aunp_sub_key_tab3); // use subkey 15/11/7/3, C'',D''
        inl_i -= 4;
    } while (inl_i > 0);
    //------------------------------------------------------------
    // Do 2nd Decryption (is an Encryption)
    //------------------------------------------------------------
    inl_i = 0;
    do {
        DES_ROUND(unl_r, unl_l, inl_i, aunp_sub_key_tab2);     // use subkey 1/5/ 9/13, C'',D''
        DES_ROUND(unl_l, unl_r, inl_i + 2, aunp_sub_key_tab2); // use subkey 2/6/10/14, C'',D''
        inl_i += 4;
    } while (inl_i < 32);
    //------------------------------------------------------------
    // Do 3rd Decryption
    //------------------------------------------------------------
    inl_i = 30;
    do {
        DES_ROUND(unl_l, unl_r, inl_i, aunp_sub_key_tab1);     // use subkey 16/12/8/4, C'',D''
        DES_ROUND(unl_r, unl_l, inl_i - 2, aunp_sub_key_tab1); // use subkey 15/11/7/3, C'',D''
        inl_i -= 4;
    } while (inl_i > 0);
    //------------------------------------------------------------
    // rearrange bits before final permutation, do final permutation
    //------------------------------------------------------------
    unl_l = RROT1(unl_l);               // convert back to original bit order
    unl_r = RROT1(unl_r);               // dto.
    DES_FP(unl_r, unl_l);               // Do Final Permutation
    //------------------------------------------------------------
    //Store new data words, clear used temporary variables (safety)
    //------------------------------------------------------------
    aunp_data[0] = unl_l;               // save new low
    aunp_data[1] = unl_r;               // save new high
    //temporary variables are in registers
} // ms_3des_decrypt

/**
 * Splits a given DES into 'registers' C and D doing initial
 * key permutation (PC1)
 *
 *  @param DesKey 64 Bit (8*8 Byte) DES Key
 *               in FIPS46 bit order
 *  @param CDRegs C/D-registers (bit-reversed!!)
 *               Element 0: C-register
 *               Element 1: D-register
 */
static void ms_SplitDESKey(const unsigned char * abyp_des_key,
                           unsigned int * aunp_CDRegs)
{
    unsigned int unl_c, unl_d;
    //
    // 1. Pre-Load DES Key Registers C,D
    //
    ms_read_little_endian(unl_c, abyp_des_key);
    ms_read_little_endian(unl_d, abyp_des_key + 4);
    //
    // 2. Perform Initial Permutation on C,D Registers (PC-1)
    //    this leaves C and D loaded with the appropriate
    //	starting Subkeys in Bitreversed order !!
    //
    PC1(unl_d, unl_c)               // do Key Permutation
    //
    // 3. Store DES Key Registers C,D
    //
    aunp_CDRegs[0] = unl_c;
    aunp_CDRegs[1] = unl_d;
} // ms_SplitDESKey

static void ms_gen_des_subkeys(const unsigned char * abyp_des_key,
                               unsigned int *aunp_sub_key_tab)
{
    unsigned int unl_c, unl_d, unl_s, unl_t;
    unsigned int unrl_CDRegs[2];
    unsigned int unl_i, unl_j;
    //
    // Get DES C,D Registers
    //
    ms_SplitDESKey(abyp_des_key, unrl_CDRegs);
    unl_c = unrl_CDRegs[0];
    unl_d = unrl_CDRegs[1];
    //
    // 3. Generate Subkeys for direct Exoring to the data before
    //    entering the S-Box Permutation
    //
    unl_i = unl_j = 0;
    do {
        //
        // 3.1 rotate C,D registers 1 or 2 bit right (note the mentioned
        // reversed bit order in C and D !!)
        //
        if((unl_i != 0) && (unl_i != 1) && (unl_i != 8) && (unl_i != 15)) {
            unl_c=RROT2MOD28BIT(unl_c);         // 2 Bits to the right
            unl_d=RROT2MOD28BIT(unl_d);         // dto.
        } else {
            unl_c=RROT1MOD28BIT(unl_c);         // 1 Bit to the right
            unl_d=RROT1MOD28BIT(unl_d);         // dto.
        }
        //
        // 3.2 Perform Key Compression Permutation PC-2 and
        // reorder output bits / bytes to be suited for XOR
        //
        unl_s= cunrrs_des_kp_box[0][ unl_c  & 0x3F                ]|         // Bit 1,2,3,4,5,6
               cunrrs_des_kp_box[1][((unl_c>> 7)& 0x3C)|((unl_c>> 6)&0x03)]| // Bit 7,8,10,11,12,13
               cunrrs_des_kp_box[2][((unl_c>>14)& 0x30)|((unl_c>>13)&0x0F)]| // Bit14,15,16,17,19,20
               cunrrs_des_kp_box[3][((unl_c>>22)& 0x38)|((unl_c>>21)&0x06)|  // Bit21,23,24,26,27,28
                                    ((unl_c>>20)& 0x01)];
        unl_t= cunrrs_des_kp_box[4][  unl_d     &0x3F                 ]|     // Bit29,30,31,32,33,34
               cunrrs_des_kp_box[5][((unl_d>> 8)& 0x3C)|((unl_d>> 7)&0x03)]| // Bit36,37,39,40,41,42
               cunrrs_des_kp_box[6][((unl_d>>15)& 0x3F)               ]|     // Bit44,45,46,47,48,49
               cunrrs_des_kp_box[7][((unl_d>>22)& 0x30)|((unl_d>>21)&0x0F)]; // Bit50,51,53,54,55,56
        aunp_sub_key_tab[unl_j] =                                           // generate,save C''
                                  ((unl_t<<16) | (unl_s & 0xFFFF)) & 0xFFFFFFFF;
        unl_t = ((unl_t & 0xFFFF0000)|((unl_s>>16) & 0xFFFF)) &             // generate D''
                0xFFFFFFFF;
        aunp_sub_key_tab[unl_j + 1] = LROT4(unl_t);                             // do pre-rotate, save
        unl_j +=2;
        unl_i++;
    } while(unl_i < 16);
    //temporary variables are in registers
} // ms_gen_des_subkeys

//------------------------------------------------------------------------------
// Start of original file ./xs-cipher-1.cpp
//------------------------------------------------------------------------------

#include <stdlib.h>
#include <string.h>

#ifdef _WIN32
#include <Windows.h>
#pragma warning(push)
#ifndef _WIN64
#pragma warning( disable : 4127 )   // Constant conditional expression in AES auto functions
#endif
#else
#include "hob-unix01.h"
#ifndef HL_UNIX
#define HL_UNIX

#if (defined __APPLE__) && (defined __MACH__)
#define HL_LINUX
#define HL_MACOS
#endif

#endif // !HL_UNIX

#endif

#include "hob-xslhcla1.hpp"
#include "hob-encry-2.h"
#include "hob-encry-intern-2.h"

#ifndef _WIN32
#include <limits.h>
#include <stdint.h>
#endif

#if (defined __aarch64__) && ((defined __linux__) || (defined __FreeBSD__))
#include <stdio.h>
#include <ctype.h>
#endif

#ifdef __APPLE__
#include <TargetConditionals.h>
#endif

// ------------------------------------------
//  Static declarations
// ------------------------------------------

inline int ms_hardware_capabilities();

static void ms_abstract_cbc_encrypt_gather(unsigned char* abyp_output,
                                           const struct dsd_gather_i_1* adsp_input,
                                           size_t szp_len,
                                           const struct dsd_cipher_key* adsp_key,
                                           const unsigned char* abyp_iv,
                                           amd_block_crypt amp_cbc_enc,
                                           size_t szp_block_size);

static void ms_abstract_cbc_decrypt_gather(unsigned char* abyp_output,
                                           const struct dsd_gather_i_1* adsp_input,
                                           size_t szp_len,
                                           const struct dsd_cipher_key* adsp_key,
                                           const unsigned char* abyp_iv,
                                           amd_block_crypt amp_cbc_dec,
                                           size_t szp_block_size);

// ------------------------------------------
//  Definition of global variables
// ------------------------------------------

#ifdef HL_AES_ASM
const int ing_hardware_capabilities = ms_hardware_capabilities();
#else
//The absence of HL_AES_ASM easily indicates a total lack of any support capabilites.
//Forgoing the function call allows many compilers to assume a constant and optimize away queries of capability flags.
const int ing_hardware_capabilities = 0;
#endif

const struct dsd_hash_profile dsrg_hash_profiles[] = {
    {
        cind_digest_size_sha_1,
        cind_state_size_sha_1,
        cind_block_size_sha_1,
        m_sha_1_init,
        m_sha_1_update,
        m_sha_1_gather_update,
        m_sha_1_final
    },
    {
        cind_digest_size_sha_2_224,
        cind_state_size_sha_2_224,
        cind_block_size_sha_2_224,
        m_sha_2_224_init,
        m_sha_2_224_256_update,
        m_sha_2_224_256_gather_update,
        m_sha_2_224_final
    },
    {
        cind_digest_size_sha_2_256,
        cind_state_size_sha_2_256,
        cind_block_size_sha_2_256,
        m_sha_2_256_init,
        m_sha_2_224_256_update,
        m_sha_2_224_256_gather_update,
        m_sha_2_256_final
    },
    {
        cind_digest_size_sha_2_384,
        cind_state_size_sha_2_384,
        cind_block_size_sha_2_384,
        m_sha_2_384_init,
        m_sha_2_384_512_update,
        m_sha_2_384_512_gather_update,
        m_sha_2_384_final
    },
    {
        cind_digest_size_sha_2_512,
        cind_state_size_sha_2_512,
        cind_block_size_sha_2_512,
        m_sha_2_512_init,
        m_sha_2_384_512_update,
        m_sha_2_384_512_gather_update,
        m_sha_2_512_final
    },
    {
        cind_digest_size_sha_3_224,
        cind_state_size_sha_3_224,
        cind_block_size_sha_3_224,
        m_sha_3_224_init,
        m_sha_3_update,
        m_sha_3_gather_update,
        m_sha_3_final
    },
    {
        cind_digest_size_sha_3_256,
        cind_state_size_sha_3_256,
        cind_block_size_sha_3_256,
        m_sha_3_256_init,
        m_sha_3_update,
        m_sha_3_gather_update,
        m_sha_3_final
    },
    {
        cind_digest_size_sha_3_384,
        cind_state_size_sha_3_384,
        cind_block_size_sha_3_384,
        m_sha_3_384_init,
        m_sha_3_update,
        m_sha_3_gather_update,
        m_sha_3_final
    },
    {
        cind_digest_size_sha_3_512,
        cind_state_size_sha_3_512,
        cind_block_size_sha_3_512,
        m_sha_3_512_init,
        m_sha_3_update,
        m_sha_3_gather_update,
        m_sha_3_final
    },
    {
        cind_digest_size_md_5,
        cind_state_size_md_5,
        cind_block_size_md_5,
        m_md_5_init,
        m_md_5_update,
        m_md_5_gather_update,
        m_md_5_final
    }
};

extern const struct dsd_hash_profile dsrg_hash_profiles[ied_hash_count];

// ------------------------------------------
//  Public functions
// ------------------------------------------

void m_aes_init_enc_key_auto(struct dsd_cipher_key* adsp_key,
                             const unsigned char* abyp_key,
                             size_t szp_key_len)
{
    if (HL_HARDWARE_SUPPORT_AES &&
        !adsp_key->boc_disallow_hardware_acceleration)
    {
        m_aes_init_enc_key_hw(adsp_key, abyp_key, szp_key_len);
    } else {
        m_aes_init_enc_key_sw(adsp_key, abyp_key, szp_key_len);
    }
}

void m_aes_init_dec_key_auto(struct dsd_cipher_key* adsp_key,
                             const unsigned char* abyp_key,
                             size_t szp_key_len)
{
    if (HL_HARDWARE_SUPPORT_AES &&
        !adsp_key->boc_disallow_hardware_acceleration)
    {
        m_aes_init_dec_key_hw(adsp_key, abyp_key, szp_key_len);
    } else {
        m_aes_init_dec_key_sw(adsp_key, abyp_key, szp_key_len);
    }
}

void m_aes_cbc_encrypt_auto(unsigned char* abyp_output,
                            const unsigned char* abyp_input,
                            size_t szp_len,
                            const struct dsd_cipher_key* adsp_key,
                            const unsigned char* abyp_iv)

{
    if (HL_HARDWARE_SUPPORT_AES &&
        !adsp_key->boc_disallow_hardware_acceleration)
    {
        m_aes_cbc_encrypt_hw(abyp_output, abyp_input, szp_len, adsp_key, abyp_iv);
    } else {
        m_aes_cbc_encrypt_sw(abyp_output, abyp_input, szp_len, adsp_key, abyp_iv);
    }
}

void m_aes_cbc_decrypt_auto(unsigned char* abyp_output,
                            const unsigned char* abyp_input,
                            size_t szp_len,
                            const struct dsd_cipher_key* adsp_key,
                            const unsigned char* abyp_iv)
{
    if (HL_HARDWARE_SUPPORT_AES &&
        !adsp_key->boc_disallow_hardware_acceleration)
    {
        m_aes_cbc_decrypt_hw(abyp_output, abyp_input, szp_len, adsp_key, abyp_iv);
    } else {
        m_aes_cbc_decrypt_sw(abyp_output, abyp_input, szp_len, adsp_key, abyp_iv);
    }
}

void m_aes_ctr_crypt_auto(unsigned char* abyp_output,
                          const unsigned char* abyp_input,
                          size_t szp_len,
                          const struct dsd_cipher_key* adsp_key,
                          const unsigned char* abyp_iv)
{
    if (HL_HARDWARE_SUPPORT_AES &&
        !adsp_key->boc_disallow_hardware_acceleration)
    {
        m_aes_ctr_crypt_hw(abyp_output, abyp_input, szp_len, adsp_key, abyp_iv);
    } else {
        m_aes_ctr_crypt_sw(abyp_output, abyp_input, szp_len, adsp_key, abyp_iv);
    }
}

void m_aes_gcm_encrypt_auto(unsigned char* abyp_cipher,
                            const unsigned char* abyp_plain,
                            size_t szp_len,
                            const struct dsd_cipher_key* adsp_key,
                            const unsigned char* abyp_iv,
                            size_t szp_iv_len,
                            const unsigned char* abyp_adddata,
                            size_t szp_adddata_len,
                            unsigned char* abyp_tag,
                            size_t szp_tag_len)
{
    if (HL_HARDWARE_SUPPORT_AES &&
        !adsp_key->boc_disallow_hardware_acceleration)
    {
        if (!HL_HARDWARE_SUPPORT_PMUL) {
            m_aes_gcm_encrypt_hw1(abyp_cipher,
                                  abyp_plain,
                                  szp_len,
                                  adsp_key,
                                  abyp_iv,
                                  szp_iv_len,
                                  abyp_adddata,
                                  szp_adddata_len,
                                  abyp_tag,
                                  szp_tag_len);
        } else {
            m_aes_gcm_encrypt_hw2(abyp_cipher,
                                  abyp_plain,
                                  szp_len,
                                  adsp_key,
                                  abyp_iv,
                                  szp_iv_len,
                                  abyp_adddata,
                                  szp_adddata_len,
                                  abyp_tag,
                                  szp_tag_len);
        }
    } else {
        m_aes_gcm_encrypt_sw(abyp_cipher,
                             abyp_plain,
                             szp_len,
                             adsp_key,
                             abyp_iv,
                             szp_iv_len,
                             abyp_adddata,
                             szp_adddata_len,
                             abyp_tag,
                             szp_tag_len);
    }
} // m_aes_gcm_encrypt_auto

BOOL m_aes_gcm_decrypt_auto(unsigned char* abyp_plain,
                            const unsigned char* abyp_cipher,
                            size_t szp_len,
                            const struct dsd_cipher_key* adsp_key,
                            const unsigned char* abyp_iv,
                            size_t szp_iv_len,
                            const unsigned char* abyp_adddata,
                            size_t szp_adddata_len,
                            const unsigned char* abyp_tag,
                            size_t szp_tag_len)
{
    if (HL_HARDWARE_SUPPORT_AES &&
        !adsp_key->boc_disallow_hardware_acceleration)
    {
        if (!HL_HARDWARE_SUPPORT_PMUL) {
            return m_aes_gcm_decrypt_hw1(abyp_plain,
                                         abyp_cipher,
                                         szp_len,
                                         adsp_key,
                                         abyp_iv,
                                         szp_iv_len,
                                         abyp_adddata,
                                         szp_adddata_len,
                                         abyp_tag,
                                         szp_tag_len);
        } else {
            return m_aes_gcm_decrypt_hw2(abyp_plain,
                                         abyp_cipher,
                                         szp_len,
                                         adsp_key,
                                         abyp_iv,
                                         szp_iv_len,
                                         abyp_adddata,
                                         szp_adddata_len,
                                         abyp_tag,
                                         szp_tag_len);
        }
    } else {
        return m_aes_gcm_decrypt_sw(abyp_plain,
                                    abyp_cipher,
                                    szp_len,
                                    adsp_key,
                                    abyp_iv,
                                    szp_iv_len,
                                    abyp_adddata,
                                    szp_adddata_len,
                                    abyp_tag,
                                    szp_tag_len);
    }
} // m_aes_gcm_decrypt_auto



void m_aes_cbc_encrypt_gather(unsigned char* abyp_output,
                              const struct dsd_gather_i_1* adsp_input,
                              size_t szp_len,
                              const struct dsd_cipher_key* adsp_key,
                              const unsigned char* abyp_iv)
{
    amd_block_crypt aml_cbc_enc;
    if (HL_HARDWARE_SUPPORT_AES &&
        !adsp_key->boc_disallow_hardware_acceleration)
    {
        aml_cbc_enc = m_aes_cbc_encrypt_hw;
    } else {
        aml_cbc_enc = m_aes_cbc_encrypt_sw;
    }
    ms_abstract_cbc_encrypt_gather(abyp_output,
                                   adsp_input,
                                   szp_len,
                                   adsp_key,
                                   abyp_iv,
                                   aml_cbc_enc,
                                   16);
} // m_aes_cbc_encrypt_gather

void m_aes_cbc_decrypt_gather(unsigned char* abyp_output,
                              const struct dsd_gather_i_1* adsp_input,
                              size_t szp_len,
                              const struct dsd_cipher_key* adsp_key,
                              const unsigned char* abyp_iv)
{
    amd_block_crypt aml_cbc_dec;
    if (HL_HARDWARE_SUPPORT_AES &&
        !adsp_key->boc_disallow_hardware_acceleration)
    {
        aml_cbc_dec = m_aes_cbc_decrypt_hw;
    } else {
        aml_cbc_dec = m_aes_cbc_decrypt_sw;
    }
    ms_abstract_cbc_decrypt_gather(abyp_output,
                                   adsp_input,
                                   szp_len,
                                   adsp_key,
                                   abyp_iv,
                                   aml_cbc_dec,
                                   16);
} // m_aes_cbc_decrypt_gather

void m_3des_cbc_encrypt_gather(unsigned char* abyp_output,
                               const struct dsd_gather_i_1* adsp_input,
                               size_t szp_len,
                               const struct dsd_cipher_key* adsp_key,
                               const unsigned char* abyp_iv)
{
    ms_abstract_cbc_encrypt_gather(abyp_output,
                                   adsp_input,
                                   szp_len,
                                   adsp_key,
                                   abyp_iv,
                                   m_3des_cbc_encrypt,
                                   8);
}

void m_3des_cbc_decrypt_gather(unsigned char* abyp_output,
                               const struct dsd_gather_i_1* adsp_input,
                               size_t szp_len,
                               const struct dsd_cipher_key* adsp_key,
                               const unsigned char* abyp_iv)
{
    ms_abstract_cbc_decrypt_gather(abyp_output,
                                   adsp_input,
                                   szp_len,
                                   adsp_key,
                                   abyp_iv,
                                   m_3des_cbc_decrypt,
                                   8);
}



#if (defined __x86_64__) || (defined _WIN64)
#ifndef HL_ENCRY2_NO_ASSEMBLER
// Function is implemented in is-encry-x64.s resp. is-encry-x64.asm. Declaration only.
extern "C" int m_x86_capabilities();
#else
// Returning zero if is-encry-x64.s is not available
extern "C" int m_x86_capabilities()
{
    return 0;
}
#endif
#endif

#if (defined __aarch64__) && ((defined __linux__) || (defined __FreeBSD__))

#define DEF_CPUINFO_FILE_LINE_BUFFER_LENGTH     1024

#ifndef _GNU_SOURCE
char *strcasestr(const char *achp_haystack,
                 const char *achp_needle)
{
    for (const char* achl_scan = achp_haystack; *achl_scan != '\0'; achl_scan++) {
        if ((*achl_scan == achp_needle[0]) || (*achl_scan == toupper(achp_needle[0]))) {
            for (int inl1 = 1; achl_scan[inl1]; inl1++) {
                if (achp_needle[inl1] == '\0') {
                    return (char*)achl_scan;
                }
                if ((achl_scan[inl1] != achp_needle[inl1]) && (achl_scan[inl1] != toupper(achp_needle[inl1]))) {
                    break;
                }
            }
        }
    }
    return NULL;
}
#endif

#if defined __linux__

static int ms_arm_linux_capabilities()
{
    // *nix has no cpuinfo API available
    // Instead, we open "/proc/cpuinfo" file and search it for relevant strings
    // The format of that file is not standardized between platforms, thus simple strstr search

    // Note for future developers: A best effort has been made to prevent false positives. 
    // If the code mispredicts in certain environments, amend the code so it will cover all known situations.
    // If a reliable cpuinfo API appears in future OS versions, include it.
    int inl_flags = 0;
    FILE* adsl_procinfo;
    adsl_procinfo = fopen("/proc/cpuinfo","r");
    if (adsl_procinfo == NULL) {
        return 0;
    }
    char achl_line_buffer[DEF_CPUINFO_FILE_LINE_BUFFER_LENGTH];
    while ((!ferror(adsl_procinfo)) && (!feof(adsl_procinfo))) {
        // read linewise, continue; on error
        if (fgets(achl_line_buffer,DEF_CPUINFO_FILE_LINE_BUFFER_LENGTH,adsl_procinfo) == NULL) {
            continue;
        }
        //search for string (case insensitive)
        char* achl_pos_aes = strcasestr(achl_line_buffer,"aes");
        if (achl_pos_aes != NULL) {
            //Check if the preceding character is whitespace, punctuation, or start of line. If no, it is likely part of a larger word.
            if ((achl_pos_aes == achl_line_buffer) || isspace(achl_pos_aes[-1]) || ispunct(achl_pos_aes[-1])) {
                inl_flags |= HL_HARDWARE_SUPPORT_FLAG_AES;
            }
        }

        char* achl_pos_pmul = strcasestr(achl_line_buffer,"pmul");

        if (achl_pos_pmul != NULL) {
            //Check if the preceding character is whitespace, punctuation, or start of line. If no, it is likely part of a larger word.
            if ((achl_pos_pmul == achl_line_buffer) || isspace(achl_pos_pmul[-1]) || ispunct(achl_pos_pmul[-1])) {
                inl_flags |= HL_HARDWARE_SUPPORT_FLAG_PMUL;
            }
        }

        // SHA1 and SHA256 are probably in the same line, need to search occurences in the line beyond the first
        for (char* achl_line_adv = achl_line_buffer, *achl_pos_sha = strcasestr(achl_line_adv,"sha");
             achl_pos_sha != NULL;
             achl_line_adv = achl_pos_sha + 3, achl_pos_sha = strcasestr(achl_line_adv,"sha"))
        {
            //Check if the preceding character is whitespace, punctuation, or start of line. If no, it is likely part of a larger word.
            if ((achl_pos_sha == achl_line_buffer) || isspace(achl_pos_sha[-1]) || ispunct(achl_pos_sha[-1])) {
                if ((achl_pos_sha[+3] == '1') || isspace(achl_pos_sha[+3]) || ispunct(achl_pos_sha[-1])) {
                    inl_flags |= HL_HARDWARE_SUPPORT_FLAG_SHA1;
                }
                if (achl_pos_sha[+3] == '2') {
                    inl_flags |= HL_HARDWARE_SUPPORT_FLAG_SHA256;
                }
            }
        }

    }
    fclose(adsl_procinfo);
    return inl_flags;
} // ms_arm_linux_capabilities
#endif

#if defined __FreeBSD__
static int ms_arm_freebsd_capabilities()
{
    // Like Linux, FreeBSD has no cpuid API. It also doesn't have Linux's /proc/cpuinfo.
    // sysctl -a is more concise, but doesn't give as many infos as /var/run/dmesg.boot
    // The basic idea is the same, but since dmesg.boot contains the entire startup log,
    // not just CPU info, but also periphery and network connectictivity logs,
    // we need to be more careful. The relevant strings are thus only considered if they
    // follow a "feature" or "instruction".
    // Example lines:
    // Processor Features 0 = <AdvSIMD,Float,EL3 32,EL2 32,EL1 32,EL0 32>
    // Instruction Set Attributes 0 = <AES+PMULL,SHA1,SHA2,CRC32>
 
    // Note for future developers: A best effort has been made to prevent false positives. 
    // If the code mispredicts in certain environments, amend the code so it will cover all known situations.
    // If a reliable cpuinfo API appears in future OS versions, include it.
   int inl_flags = 0;
    FILE* adsl_procinfo;
    adsl_procinfo = fopen("/var/run/dmesg.boot","r");
    if (adsl_procinfo == NULL) {
        return 0;
    }
    char achl_line_buffer[DEF_CPUINFO_FILE_LINE_BUFFER_LENGTH];
    while ((!ferror(adsl_procinfo)) && (!feof(adsl_procinfo))) {
        // read linewise, continue; on error
        if (fgets(achl_line_buffer,DEF_CPUINFO_FILE_LINE_BUFFER_LENGTH,adsl_procinfo) == NULL) {
            continue;
        }
        //search for string (case insensitive)
        char* achl_featurelist = strcasestr(achl_line_buffer,"feature");
        if (achl_featurelist == NULL) {
            achl_featurelist = strcasestr(achl_line_buffer,"instruction");
            if (achl_featurelist == NULL) {
                continue;
            }
        }
        achl_featurelist += 7;

        if (strcasestr(achl_featurelist,"aes") != NULL) {
            inl_flags |= HL_HARDWARE_SUPPORT_FLAG_AES;
        }

        if (strcasestr(achl_featurelist,"pmul") != NULL) {
            inl_flags |= HL_HARDWARE_SUPPORT_FLAG_PMUL;
        }

        // for SHA1 and SHA256, need to keep searching after first occurence
        for (char* achl_line_adv = achl_featurelist, *achl_pos_sha = strcasestr(achl_line_adv,"sha");
             achl_pos_sha != NULL;
             achl_line_adv = achl_pos_sha + 3, achl_pos_sha = strcasestr(achl_line_adv,"sha"))
        {
            if ((achl_pos_sha[+3] == '1') || (isspace(achl_pos_sha[+3]))) {
                inl_flags |= HL_HARDWARE_SUPPORT_FLAG_SHA1;
            }
            if (achl_pos_sha[+3] == '2') {
                inl_flags |= HL_HARDWARE_SUPPORT_FLAG_SHA256;
            }
        }

    }
    fclose(adsl_procinfo);
    return inl_flags;
} // ms_arm_freebsd_capabilities
#endif
#endif

#if (defined __aarch64__) && (defined __APPLE__) && (TARGET_OS_IPHONE==1)
//All Apple A7+ chips (i.e. all Apple ARM AArch64 chips) have AES, PMUL and SHA capability
//Non-Iphone MacOS on other ARMv8 is excluded via Apple's TARGET_OS checks
//IPhone Simulators and older, non-v8 ARM is excluded via __aarch64__ check

static int ms_iphone_capabilities()
{
    return HL_HARDWARE_SUPPORT_FLAG_AES | HL_HARDWARE_SUPPORT_FLAG_PMUL | HL_HARDWARE_SUPPORT_FLAG_SHA1 |
           HL_HARDWARE_SUPPORT_FLAG_SHA256;
}
#endif


inline int ms_hardware_capabilities()
{
#if (defined __x86_64__) || (defined _WIN64)
    //Architecture: Intel x86/64        OS: all             Compiler: all
    return m_x86_capabilities();
#elif (defined __aarch64__) && (defined __linux__)
    //Architecture: ARMv8 AArch64       OS: Linux, Android  Compiler: all
    return ms_arm_linux_capabilities();
#elif (defined __aarch64__) && (defined __FreeBSD__)
    //Architecture: ARMv8 AArch64       OS: FreeBSD         Compiler: all
    return ms_arm_freebsd_capabilities();
#elif (defined __aarch64__) && (defined __APPLE__) && (TARGET_OS_IPHONE==1)
    //Architecture: Apple A7 (AArch64)  OS: iOS             Compiler: all
    return ms_iphone_capabilities();
#else
    //All other environments default to no capabilities
    return 0;
#endif
}


#define MAX_CBC_BLOCK_SIZE 16

static void ms_abstract_cbc_encrypt_gather(unsigned char* abyp_output,
                                           const struct dsd_gather_i_1* adsp_input,
                                           size_t szp_len,
                                           const struct dsd_cipher_key* adsp_key,
                                           const unsigned char* abyp_iv,
                                           amd_block_crypt amp_cbc_enc,
                                           size_t szp_block_size)
{
    unsigned char byrl_buf[MAX_CBC_BLOCK_SIZE];
    size_t szl_buf_filled_size = 0;
    size_t szl_partial_len, szl_offset;
    size_t szl_mask = szp_block_size - 1;

    while ((szp_len > 0) && !(adsp_input == NULL)) {
        szl_partial_len = adsp_input->achc_ginp_end - adsp_input->achc_ginp_cur;
        szl_offset = 0;
        if (szl_buf_filled_size > 0) {
            if (szl_partial_len + szl_buf_filled_size < szp_block_size) {
                memcpy(byrl_buf + szl_buf_filled_size, adsp_input->achc_ginp_cur, szl_partial_len);
                szl_buf_filled_size += szl_partial_len;
                adsp_input = adsp_input->adsc_next;
                continue; // Repeated until buffer becomes full
            } else {
                // Fill the rest of buffer
                szl_offset = szp_block_size - szl_buf_filled_size;
                szl_partial_len -= szl_offset;
                memcpy(byrl_buf + szl_buf_filled_size, adsp_input->achc_ginp_cur, szl_offset);
                // Flush buffer
                amp_cbc_enc(abyp_output,
                            byrl_buf,
                            szp_block_size,
                            adsp_key,
                            abyp_iv);
                abyp_iv = abyp_output; // Set the last cipher block as IV
                abyp_output += szp_block_size;
                szp_len -= szp_block_size;
            }
        }
        szl_buf_filled_size = (szl_partial_len & szl_mask); // mod block_size
        szl_partial_len -= szl_buf_filled_size;
        // Encrypt full blocks
        if (szl_partial_len > 0) {
            amp_cbc_enc(abyp_output,
                        (unsigned char *)adsp_input->achc_ginp_cur + szl_offset,
                        szl_partial_len,
                        adsp_key,
                        abyp_iv);
            abyp_output += szl_partial_len;
            szp_len -= szl_partial_len;
            szl_offset += szl_partial_len;
            abyp_iv = abyp_output - szp_block_size; // Set the last cipher block as IV
        }
        if (szp_len > 0) {
            // Store the reminder into buffer
            memcpy(byrl_buf, adsp_input->achc_ginp_cur + szl_offset, szl_buf_filled_size);
            adsp_input = adsp_input->adsc_next;
        }
    }
    memset(byrl_buf, 0, MAX_CBC_BLOCK_SIZE); // TODO secure zero
} // ms_abstract_cbc_encrypt_gather

static void ms_abstract_cbc_decrypt_gather(unsigned char* abyp_output,
                                           const struct dsd_gather_i_1* adsp_input,
                                           size_t szp_len,
                                           const struct dsd_cipher_key* adsp_key,
                                           const unsigned char* abyp_iv,
                                           amd_block_crypt amp_cbc_dec,
                                           size_t szp_block_size)
{
    unsigned char byrl_tmp[2 * MAX_CBC_BLOCK_SIZE]; // used as buf1, buf2
    unsigned char *abyl_buf = byrl_tmp; // current used buffer
    unsigned char *abyl_nxt_buf = byrl_tmp + MAX_CBC_BLOCK_SIZE; // alternative buffer

    size_t szl_buf_filled_size = 0;
    size_t szl_partial_len, szl_offset;
    size_t szl_mask = szp_block_size - 1;

    while ((szp_len > 0) && !(adsp_input == NULL)) {
        szl_partial_len = adsp_input->achc_ginp_end - adsp_input->achc_ginp_cur;
        szl_offset = 0;
        if (szl_buf_filled_size > 0) {
            if (szl_partial_len + szl_buf_filled_size < szp_block_size) {
                memcpy(abyl_buf + szl_buf_filled_size, adsp_input->achc_ginp_cur, szl_partial_len);
                szl_buf_filled_size += szl_partial_len;
                adsp_input = adsp_input->adsc_next;
                continue; // Repeated until buffer becomes full
            } else {
                // Fill the rest of buffer
                szl_offset = szp_block_size - szl_buf_filled_size;
                szl_partial_len -= szl_offset;
                memcpy(abyl_buf + szl_buf_filled_size, adsp_input->achc_ginp_cur, szl_offset);
                // Flush buffer
                amp_cbc_dec(abyp_output,
                            abyl_buf,
                            szp_block_size,
                            adsp_key,
                            abyp_iv);
                abyp_output += szp_block_size;
                szp_len -= szp_block_size;
                abyp_iv = abyl_buf; // Set the last cipher block as IV
                // Use another buffer to avoid overwriting the last cipher block
                abyl_buf = abyl_nxt_buf;
                abyl_nxt_buf = (unsigned char *)abyp_iv;
            }
        }
        szl_buf_filled_size = (szl_partial_len & szl_mask); // mod block_size
        szl_partial_len -= szl_buf_filled_size;
        // Encrypt full blocks
        if (szl_partial_len > 0) {
            amp_cbc_dec(abyp_output,
                        (unsigned char *)adsp_input->achc_ginp_cur + szl_offset,
                        szl_partial_len,
                        adsp_key,
                        abyp_iv);
            abyp_output += szl_partial_len;
            szp_len -= szl_partial_len;
            szl_offset += szl_partial_len;
            // Set the last cipher block as IV
            abyp_iv = (unsigned char *)adsp_input->achc_ginp_cur + szl_offset - szp_block_size;
        }
        if (szp_len > 0) {
            // Store the reminder into buffer
            memcpy(abyl_buf, adsp_input->achc_ginp_cur + szl_offset, szl_buf_filled_size);
            adsp_input = adsp_input->adsc_next;
        }
    }
    memset(abyl_buf, 0, MAX_CBC_BLOCK_SIZE); // TODO secure zero
} // ms_abstract_cbc_decrypt_gather

#ifdef _WIN32
#pragma warning(pop)
#endif

//------------------------------------------------------------------------------
// Start of original file ./xs-sha2.cpp
//------------------------------------------------------------------------------

#ifdef _WIN32
#include <Windows.h>
#else
#include "hob-unix01.h"
#ifndef HL_UNIX
#define HL_UNIX
#if (defined __APPLE__) && (defined __MACH__)
#define HL_LINUX
#define HL_MACOS
#endif
#endif // !HL_UNIX
#endif

#include <stdlib.h>
#include <string.h>

#include "hob-xslhcla1.hpp"
#include "hob-encry-2.h"
#include "hob-encry-intern-2.h"

// ------------------------------------------
//  Static definitions copied from hssl-1
// ------------------------------------------
#ifndef BIGchar2longcn
#define BIGchar2longcn(c,l,n) \
    { \
        switch (n) \
        { \
        case 0: \
            l = ((unsigned int)  ((unsigned short) c[3] & 0xFF)         & 0xFFFF) | \
                ((unsigned int) (((unsigned short) c[2] & 0xFF) <<  8) & 0xFFFF) | \
                ((unsigned int)  ((unsigned short) c[1] & 0xFF) << 16) | \
                ((unsigned int) (((unsigned short) c[0]   & 0xFF) <<  8) << 16); \
            break; \
        case 1: \
            l |=((unsigned int)  ((unsigned short) c[2] & 0xFF)         & 0xFFFF) | \
                 ((unsigned int) (((unsigned short) c[1] & 0xFF) <<  8) & 0xFFFF) | \
                 ((unsigned int)  ((unsigned short) c[0] & 0xFF) << 16); \
            break; \
        case 2: \
            l |=((unsigned int)  ((unsigned short) c[1] & 0xFF)         & 0xFFFF) | \
                 ((unsigned int) (((unsigned short) c[0] & 0xFF) <<  8) & 0xFFFF); \
            break; \
        case 3: \
            l |=((unsigned int)  ((unsigned short) c[0] & 0xFF)         & 0xFFFF); \
            break; \
        } \
    }
#endif

#define BIGchar2longlongcn(c,l,n) \
    { \
        switch (n) \
        { \
        case 0: \
            l = ((unsigned long long) c[7] & 0x0FF) | \
                (((unsigned long long) c[6] & 0x0FF) <<  8) | \
                (((unsigned long long) c[5] & 0x0FF) << 16) | \
                (((unsigned long long) c[4] & 0x0FF) << 24) | \
                (((unsigned long long) c[3] & 0x0FF) << 32) | \
                (((unsigned long long) c[2] & 0x0FF) << 40) | \
                (((unsigned long long) c[1] & 0x0FF) << 48) | \
                (((unsigned long long) c[0] & 0x0FF) << 56); \
            break; \
        case 1: \
            l |=((unsigned long long) c[6] & 0x0FF) | \
                 (((unsigned long long) c[5] & 0x0FF) <<  8) | \
                 (((unsigned long long) c[4] & 0x0FF) << 16) | \
                 (((unsigned long long) c[3] & 0x0FF) << 24) | \
                 (((unsigned long long) c[2] & 0x0FF) << 32) | \
                 (((unsigned long long) c[1] & 0x0FF) << 40) | \
                 (((unsigned long long) c[0] & 0x0FF) << 48); \
            break; \
        case 2: \
            l |=((unsigned long long) c[5] & 0x0FF) | \
                 (((unsigned long long) c[4] & 0x0FF) <<  8) | \
                 (((unsigned long long) c[3] & 0x0FF) << 16) | \
                 (((unsigned long long) c[2] & 0x0FF) << 24) | \
                 (((unsigned long long) c[1] & 0x0FF) << 32) | \
                 (((unsigned long long) c[0] & 0x0FF) << 40); \
            break; \
        case 3: \
            l |=((unsigned long long) c[4] & 0x0FF) | \
                 (((unsigned long long) c[3] & 0x0FF) <<  8) | \
                 (((unsigned long long) c[2] & 0x0FF) << 16) | \
                 (((unsigned long long) c[1] & 0x0FF) << 24) | \
                 (((unsigned long long) c[0] & 0x0FF) << 32); \
            break; \
        case 4: \
            l |=((unsigned long long) c[3] & 0x0FF) | \
                 (((unsigned long long) c[2] & 0x0FF) <<  8) | \
                 (((unsigned long long) c[1] & 0x0FF) << 16) | \
                 (((unsigned long long) c[0] & 0x0FF) << 24); \
            break; \
        case 5: \
            l |=((unsigned long long) c[2] & 0x0FF) | \
                 (((unsigned long long) c[1] & 0x0FF) <<  8) | \
                 (((unsigned long long) c[0] & 0x0FF) << 16); \
            break; \
        case 6: \
            l |=((unsigned long long) c[1] & 0x0FF) | \
                 (((unsigned long long) c[0] & 0x0FF) <<  8); \
            break; \
        case 7: \
            l |=((unsigned long long) c[0] & 0x0FF); \
            break; \
        } \
    }

#define BIGchar2long3n(c,l,n,i) \
    { \
        l = 0; \
        switch (n) \
        { \
        case 3: \
            l  = (unsigned int) (((unsigned short) c[i+2] & 0xFF) <<  8) & 0xFFFF; \
        case 2: \
            l |= ((unsigned int)  ((unsigned short) c[i+1] & 0xFF) << 16); \
        case 1: \
            l |= ((unsigned int) (((unsigned short) c[i]   & 0xFF) <<  8) << 16); \
            break; \
        } \
    }

#define BIGchar2longlong7n(c,l,n,i) \
    { \
        l = 0; \
        switch (n) \
        { \
        case 7: \
            l  = ((unsigned long long) c[i+6] & 0x0FF) <<  8; \
        case 6: \
            l |= ((unsigned long long) c[i+5] & 0x0FF) << 16; \
        case 5: \
            l |= ((unsigned long long) c[i+4] & 0x0FF) << 24; \
        case 4: \
            l |= ((unsigned long long) c[i+3] & 0x0FF) << 32; \
        case 3: \
            l |= ((unsigned long long) c[i+2] & 0x0FF) << 40; \
        case 2: \
            l |= ((unsigned long long) c[i+1] & 0x0FF) << 48; \
        case 1: \
            l |= ((unsigned long long) c[i]   & 0x0FF) << 56; \
            break; \
        } \
    }

//=======================================
// Padding bytes array for SHA256/384/512
//=======================================
static const unsigned char byrs_end8[8] = {
    0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

//-------------------------------------------
// Initializer Values for SHA-224/256/384/512
//-------------------------------------------

static const unsigned int uns_h0_sha224 = 0xc1059ed8;
static const unsigned int uns_h1_sha224 = 0x367cd507;
static const unsigned int uns_h2_sha224 = 0x3070dd17;
static const unsigned int uns_h3_sha224 = 0xf70e5939;
static const unsigned int uns_h4_sha224 = 0xffc00b31;
static const unsigned int uns_h5_sha224 = 0x68581511;
static const unsigned int uns_h6_sha224 = 0x64f98fa7;
static const unsigned int uns_h7_sha224 = 0xbefa4fa4;

static const unsigned int uns_h0_sha256 = 0x6a09e667;
static const unsigned int uns_h1_sha256 = 0xbb67ae85;
static const unsigned int uns_h2_sha256 = 0x3c6ef372;
static const unsigned int uns_h3_sha256 = 0xa54ff53a;
static const unsigned int uns_h4_sha256 = 0x510e527f;
static const unsigned int uns_h5_sha256 = 0x9b05688c;
static const unsigned int uns_h6_sha256 = 0x1f83d9ab;
static const unsigned int uns_h7_sha256 = 0x5be0cd19;

static const unsigned long long uls_h0_sha384 = 0xcbbb9d5dc1059ed8;
static const unsigned long long uls_h1_sha384 = 0x629a292a367cd507;
static const unsigned long long uls_h2_sha384 = 0x9159015a3070dd17;
static const unsigned long long uls_h3_sha384 = 0x152fecd8f70e5939;
static const unsigned long long uls_h4_sha384 = 0x67332667ffc00b31;
static const unsigned long long uls_h5_sha384 = 0x8eb44a8768581511;
static const unsigned long long uls_h6_sha384 = 0xdb0c2e0d64f98fa7;
static const unsigned long long uls_h7_sha384 = 0x47b5481dbefa4fa4;

static const unsigned long long uls_h0_sha512 = 0x6a09e667f3bcc908;
static const unsigned long long uls_h1_sha512 = 0xbb67ae8584caa73b;
static const unsigned long long uls_h2_sha512 = 0x3c6ef372fe94f82b;
static const unsigned long long uls_h3_sha512 = 0xa54ff53a5f1d36f1;
static const unsigned long long uls_h4_sha512 = 0x510e527fade682d1;
static const unsigned long long uls_h5_sha512 = 0x9b05688c2b3e6c1f;
static const unsigned long long uls_h6_sha512 = 0x1f83d9abfb41bd6b;
static const unsigned long long uls_h7_sha512 = 0x5be0cd19137e2179;

// ------------------------------------------
// Static functions
// ------------------------------------------

static void ms_sha_256_block (unsigned int* aunp_array);
static void ms_sha_512_block (unsigned long long* aulp_array);

// ------------------------------------------
// SHA-2 Initialization
// ------------------------------------------

void m_sha_2_224_init(void* avop_state)
{
    unsigned int* aunl_array = (unsigned int *)avop_state;

    aunl_array[16+0] = uns_h0_sha224;
    aunl_array[16+1] = uns_h1_sha224;
    aunl_array[16+2] = uns_h2_sha224;
    aunl_array[16+3] = uns_h3_sha224;
    aunl_array[16+4] = uns_h4_sha224;
    aunl_array[16+5] = uns_h5_sha224;
    aunl_array[16+6] = uns_h6_sha224;
    aunl_array[16+7] = uns_h7_sha224;

    aunl_array[16+8+0] = 0;     // clear total length high word
    aunl_array[16+8+1] = 0;     // clear total length low word
    aunl_array[16+8+2] = 0;     // clear saved byte counter
}

void m_sha_2_256_init(void* avop_state)
{
    unsigned int* aunl_array = (unsigned int *)avop_state;

    aunl_array[16+0] = uns_h0_sha256;
    aunl_array[16+1] = uns_h1_sha256;
    aunl_array[16+2] = uns_h2_sha256;
    aunl_array[16+3] = uns_h3_sha256;
    aunl_array[16+4] = uns_h4_sha256;
    aunl_array[16+5] = uns_h5_sha256;
    aunl_array[16+6] = uns_h6_sha256;
    aunl_array[16+7] = uns_h7_sha256;

    aunl_array[16+8+0] = 0;     // clear total length high word
    aunl_array[16+8+1] = 0;     // clear total length low word
    aunl_array[16+8+2] = 0;     // clear saved byte counter
}


void m_sha_2_384_init(void* avop_state)
{
    unsigned long long* aull_array = (unsigned long long *)avop_state;

    aull_array[16+0] = uls_h0_sha384;
    aull_array[16+1] = uls_h1_sha384;
    aull_array[16+2] = uls_h2_sha384;
    aull_array[16+3] = uls_h3_sha384;
    aull_array[16+4] = uls_h4_sha384;
    aull_array[16+5] = uls_h5_sha384;
    aull_array[16+6] = uls_h6_sha384;
    aull_array[16+7] = uls_h7_sha384;

    aull_array[16+8+0] = 0;     // clear total length high long word
    aull_array[16+8+1] = 0;     // clear total length low long word
    aull_array[16+8+2] = 0;     // clear saved byte counter
}

void m_sha_2_512_init(void* avop_state)
{
    unsigned long long* aull_array = (unsigned long long *)avop_state;

    aull_array[16+0] = uls_h0_sha512;
    aull_array[16+1] = uls_h1_sha512;
    aull_array[16+2] = uls_h2_sha512;
    aull_array[16+3] = uls_h3_sha512;
    aull_array[16+4] = uls_h4_sha512;
    aull_array[16+5] = uls_h5_sha512;
    aull_array[16+6] = uls_h6_sha512;
    aull_array[16+7] = uls_h7_sha512;

    aull_array[16+8+0] = 0;     // clear total length high long word
    aull_array[16+8+1] = 0;     // clear total length low long word
    aull_array[16+8+2] = 0;     // clear saved byte count
}

// ------------------------------------------
// SHA-2 Update
// ------------------------------------------

void m_sha_2_224_256_update(void* avop_state,
                            const unsigned char* abyp_input,
                            size_t szp_input_len)
{
    unsigned int* aunl_array = (unsigned int *)avop_state;
    unsigned int unl_i, unl_j, unl_ew, unl_ec, unl_sw, unl_sc;
    unsigned int unl_l;

    if (szp_input_len == 0) {
        return;                                     // check zero length
    }
    //----------------------------------------------------------------
    // calulate new total B I T - length
    //----------------------------------------------------------------
    unl_l = aunl_array[25];                         // Save for Carry check
    aunl_array[25] += (unsigned int)(szp_input_len << 3);   // add new length bit count

    if (unl_l > aunl_array[25]) {
        aunl_array[24]++;                            // had a Carry out

    }
    unl_i = 0;                                      // Data-Array StartIndex
    if (aunl_array[26] != 0) {                      // check for saved data in array
        //=================================================================
        // stored data in array, fill up until SHA-Block complete (16 DWORDS)
        // or data exhausted
        //=================================================================
        unl_sw = aunl_array[26] >> 2;               // number of full 4Byte DWORDS
        unl_sc = aunl_array[26] & 0x03;             // remaining bytes
        // NOTE: overflow will occur above 4 GByte - 64 Byte !! (> (2**31-1) - 64)

        if ((aunl_array[26] + szp_input_len) >= 64) {
            //---------------------------------------------------------------
            // enough data to complete array, do copy data to array,
            // generate Digest
            //---------------------------------------------------------------
            unl_l = aunl_array[unl_sw];                 // get address of next or incomplete
            BIGchar2longcn(abyp_input,unl_l,unl_sc); // get required bytes
            unl_i += (4 - unl_sc);
            aunl_array[unl_sw] = unl_l;                 // save to array
            unl_sw++;                                   // to next location
            for (; unl_sw < 16; unl_sw++) {             // continue copying full longs
                ms_read_big_endian(unl_l, abyp_input + unl_i);
                unl_i += 4;
                aunl_array[unl_sw] = unl_l;
            }
            szp_input_len -= (64 - aunl_array[26]);     // reduce szp_input_length

            ms_sha_256_block(aunl_array);                   // get digest
            aunl_array[26] = 0;                         // no abyp_inpu in array
        } else {
            //---------------------------------------------------------------
            // not enough data to complete array, do copy data to array only
            // and exit
            //---------------------------------------------------------------
            aunl_array[26] += (unsigned int)szp_input_len;      // remaining bytes, always < 64
            if ((unl_sc + (unsigned int)szp_input_len) < 4) {   // cannot fill a full DWORD
                unl_l = aunl_array[unl_sw];                     // get saved bytes (if any)
                switch (unl_sc) {
                case 0: // no bytes saved
                    unl_l = (abyp_input[unl_i++] & 0x0FF) << 24;    // save byte
                    szp_input_len--;
                    if(szp_input_len == 0) {
                        break;
                    }
                case 1: // 1 byte saved
                    unl_l |= (((unsigned int)abyp_input[unl_i++] & 0x0FF) << 16);   // insert next
                    szp_input_len--;
                    if(szp_input_len == 0) {
                        break;
                    }
                case 2: // 2 byte saved
                    unl_l |= (((unsigned int)abyp_input[unl_i++] & 0x0FF) << 8);    // insert next
                    szp_input_len--;
                    if(szp_input_len == 0) {
                        break;
                    }
                case 3: // 3 byte saved
                    unl_l |= ((unsigned int)abyp_input[unl_i++] & 0x0FF);           // insert next
                    break;
                }
                aunl_array[unl_sw] = unl_l;                     // save incomplete DWORD
            } else {
                unl_ew = aunl_array[26];                        // get ending byte count
                unl_ec = unl_ew & 0x03;                         // incomplete ending byte count
                unl_ew >>= 2;                                   // full DWORDS for copy
                unl_l = aunl_array[unl_sw];                     // get saved bytes (if any)
                BIGchar2longcn(abyp_input,unl_l,unl_sc);        // insert bytes or copy full long
                unl_i += (4 - unl_sc);
                aunl_array[unl_sw] = unl_l;                     // save full long
                unl_sw++;                                       // to next long
                for (; unl_sw < unl_ew; unl_sw++) {             // copy full longs
                    ms_read_big_endian(unl_l, abyp_input + unl_i);
                    unl_i += 4;
                    aunl_array[unl_sw] = unl_l;
                }
                if (unl_ec != 0) {                              // remaining bytes to copy into a long
                    BIGchar2long3n(abyp_input,unl_l,unl_ec,unl_i);
                    aunl_array[unl_sw] = unl_l;
                }
            }
            return;                                             // exit, wait for more data
        }
    } // end of stored data preprocessing
      //=================================================================
      // no stored data in array, start storing data until filled up
      //=================================================================
    while (szp_input_len >= 64) {       // only for full blocks
        unl_j = 0;                      // index to Stored data
        for (unl_sw=4; unl_sw != 0; unl_sw--) {     // full DWORD copy loop
            ms_read_big_endian(aunl_array[unl_j], abyp_input + unl_i);
            ms_read_big_endian(aunl_array[unl_j + 1], abyp_input + unl_i + 4);
            ms_read_big_endian(aunl_array[unl_j + 2], abyp_input + unl_i + 8);
            ms_read_big_endian(aunl_array[unl_j + 3], abyp_input + unl_i + 12);
            unl_i += 16;
            unl_j += 4;
        }
        ms_sha_256_block(aunl_array);       // process Digest
        szp_input_len -= 64;                // subtract blocklength
    }
    //
    // calculate remaining longs and rest bytes/long
    //
    unl_ec = (unsigned int)szp_input_len;       // is always < SHA_BLOCK !!
    aunl_array[26] = unl_ec;                    // save remaining data byte count
    unl_ew = unl_ec >> 2;                       // calculate full long count
    unl_ec &= 0x03;                             // get last remaining bytes
    unl_sw = 0;                                 // index data field start
    for (; unl_sw < unl_ew; unl_sw++) {         // copy full longs if any
        ms_read_big_endian(unl_l, abyp_input + unl_i);
        unl_i += 4;
        aunl_array[unl_sw] = unl_l;
    }
    if (unl_ec != 0) {                          // copy remaining bytes if any
        BIGchar2long3n(abyp_input,unl_l,unl_ec,unl_i);
        aunl_array[unl_sw] = unl_l;
    }
} // m_sha_2_224_256_update

void m_sha_2_224_256_gather_update(void* avop_state,
                                   struct dsd_gather_i_1* adsp_input,
                                   size_t szp_input_len)
{
    while ((szp_input_len > 0) && !(adsp_input == NULL)) {
        size_t szl_elm_len = adsp_input->achc_ginp_end - adsp_input->achc_ginp_cur;
        if (szl_elm_len > szp_input_len) {
            szl_elm_len = szp_input_len;
        }
        m_sha_2_224_256_update(avop_state,
                               (const unsigned char *)adsp_input->achc_ginp_cur,
                               szl_elm_len);
        szp_input_len -= szl_elm_len;
        adsp_input = adsp_input->adsc_next;
    }
}

void m_sha_2_384_512_update(void* avop_state,
                            const unsigned char* abyp_input,
                            size_t szp_input_len)
{
    unsigned long long* aull_array = (unsigned long long *)avop_state;
    unsigned long long ull_i, ull_j, ull_ew, ull_ec, ull_sc;
    unsigned long long ull_l, ull_sw;

    if (szp_input_len == 0) {
        return;                                 // check zero length
    }
    //----------------------------------------------------------------
    // calulate new total B I T - length
    // NOTE: only LOW count is calculated, limits size to 2**61 Bytes !!
    //----------------------------------------------------------------
    aull_array[25] += szp_input_len << 3;       // add new length bit count
    ull_i = 0;                                  // Data-Array StartIndex
    if (aull_array[26] != 0) {                  // check for saved data in array
        //=================================================================
        // stored data in array, fill up until SHA-Block complete (16 QWORDS)
        // or data exhausted
        //=================================================================
        ull_sw = aull_array[26] >> 3;           // number of full 8Byte QWORDS
        ull_sc = aull_array[26] & 0x07;         // remaining bytes
        if ((aull_array[26] + szp_input_len) >= 128) {
            //---------------------------------------------------------------
            // enough data to complete array, do copy data to array,
            // generate Digest
            //---------------------------------------------------------------
            ull_l = aull_array[ull_sw];         // get address of next or incomplete
            BIGchar2longlongcn(abyp_input,ull_l,ull_sc);    // get required bytes
            ull_i += (8 - ull_sc);
            aull_array[ull_sw] = ull_l;         // save to array
            ull_sw++;                           // to next location
            for (; ull_sw < 16; ull_sw++) {     // continue copying full longlongs
                ms_read_big_endian(ull_l, abyp_input + ull_i);
                ull_i += 8;
                aull_array[ull_sw] = ull_l;
            }
            szp_input_len -= (size_t)(128 - aull_array[26]);    // reduce length
            ms_sha_512_block(aull_array);           // get digest
            aull_array[26] = 0;                 // no data in array
        } else {
            //---------------------------------------------------------------
            // not enough data to complete array, do copy data to array only
            // and exit
            //---------------------------------------------------------------
            aull_array[26] += szp_input_len;    // remaining bytes, always < 64
            if ((ull_sc + (unsigned int)szp_input_len) < 8) {   // cannot fill a full QWORD
                ull_l = aull_array[ull_sw];     // get saved bytes (if any)
                switch (ull_sc) {
                case 0: // no bytes saved
                    ull_l = ((unsigned long long)abyp_input[ull_i++] & 0x0FF) << 56;    // save byte
                    szp_input_len--;
                    if (szp_input_len == 0) {
                        break;
                    }
                case 1: // 1 byte saved
                    ull_l |= (((unsigned long long)abyp_input[ull_i++] & 0x0FF) << 48); // insert next
                    szp_input_len--;
                    if (szp_input_len == 0) {
                        break;
                    }
                case 2: // 2 byte saved
                    ull_l |= (((unsigned long long)abyp_input[ull_i++] & 0x0FF) << 40); // insert next
                    szp_input_len--;
                    if (szp_input_len == 0) {
                        break;
                    }
                case 3: // 3 byte saved
                    ull_l |= (((unsigned long long)abyp_input[ull_i++] & 0x0FF) << 32); // insert next
                    szp_input_len--;
                    if (szp_input_len == 0) {
                        break;
                    }
                case 4: // 4 byte saved
                    ull_l |= (((unsigned long long)abyp_input[ull_i++] & 0x0FF) << 24); // insert next
                    szp_input_len--;
                    if (szp_input_len == 0) {
                        break;
                    }
                case 5: // 5 byte saved
                    ull_l |= (((unsigned long long)abyp_input[ull_i++] & 0x0FF) << 16); // insert next
                    szp_input_len--;
                    if (szp_input_len == 0) {
                        break;
                    }
                case 6: // 6 byte saved
                    ull_l |= (((unsigned long long)abyp_input[ull_i++] & 0x0FF) << 8);  // insert next
                    szp_input_len--;
                    if (szp_input_len == 0) {
                        break;
                    }
                case 7: // 7 byte saved
                    ull_l |= ((unsigned long long)abyp_input[ull_i++] & 0x0FF);         // insert next
                    break;
                }
                aull_array[ull_sw] = ull_l;     // save incomplete DWORD
            } else {
                ull_ew = aull_array[26];        // get ending byte count
                ull_ec = ull_ew & 0x07;         // incomplete ending byte count
                ull_ew >>= 3;                   // full QWORDS for copy
                ull_l = aull_array[ull_sw];     // get saved bytes (if any)
                BIGchar2longlongcn(abyp_input,ull_l,ull_sc);    // insert bytes or copy full longlong
                ull_i += (8 - ull_sc);
                aull_array[ull_sw] = ull_l;     // save full long
                ull_sw++;                       // to next long
                for(; ull_sw < ull_ew; ull_sw++) {  // copy full longs
                    ms_read_big_endian(ull_l, abyp_input + ull_i);
                    ull_i += 8;
                    aull_array[ull_sw] = ull_l;
                }
                if(ull_ec != 0) {               // remaining bytes to copy into longlong
                    BIGchar2longlong7n(abyp_input,ull_l,ull_ec,ull_i);
                    aull_array[ull_sw] = ull_l;
                }
            }
            return;                             // exit, wait for more data
        }
    } // end of stored data preprocessing
      //=================================================================
      // no stored data in array, start storing data until filled up
      //=================================================================
    while (szp_input_len >= 128) {                  // only for full blocks
        ull_j = 0;                                  // index to Stored data
        for(ull_sw = 4; ull_sw != 0; ull_sw--) {    // full DWORD copy loop
            ms_read_big_endian(aull_array[ull_j], abyp_input + ull_i);
            ms_read_big_endian(aull_array[ull_j + 1], abyp_input + ull_i + 8);
            ms_read_big_endian(aull_array[ull_j + 2], abyp_input + ull_i + 16);
            ms_read_big_endian(aull_array[ull_j + 3], abyp_input + ull_i + 24);
            ull_i += 32;
            ull_j += 4;
        }
        ms_sha_512_block(aull_array);               // process Digest
        szp_input_len -= 128;                   // subtract blockszp_input_length
    }
    //
    // calculate remaining longs and rest bytes/long
    //
    ull_ec = (unsigned int)szp_input_len;       // is always < SHA_BLOCK !!
    aull_array[26] = ull_ec;                    // save remaining data byte count
    ull_ew = ull_ec >> 3;                       // calculate full longlong count
    ull_ec &= 0x07;                             // get last remaining bytes
    ull_sw = 0;                                 // index data field start
    for (; ull_sw < ull_ew; ull_sw++) {         // copy full longs if any
        ms_read_big_endian(ull_l, abyp_input + ull_i);
        ull_i += 8;
        aull_array[ull_sw] = ull_l;
    }
    if(ull_ec != 0) {                           // copy remaining bytes if any
        BIGchar2longlong7n(abyp_input,ull_l,ull_ec,ull_i);
        aull_array[ull_sw] = ull_l;
    }
} // m_sha_2_384_512_update

void m_sha_2_384_512_gather_update(void* avop_state,
                                   struct dsd_gather_i_1* adsp_input,
                                   size_t szp_input_len)
{
    while ((szp_input_len > 0) && !(adsp_input == NULL)) {
        size_t szl_elm_len = adsp_input->achc_ginp_end - adsp_input->achc_ginp_cur;
        if (szl_elm_len > szp_input_len) {
            szl_elm_len = szp_input_len;
        }
        m_sha_2_384_512_update(avop_state,
                               (const unsigned char *)adsp_input->achc_ginp_cur,
                               szl_elm_len);
        szp_input_len -= szl_elm_len;
        adsp_input = adsp_input->adsc_next;
    }
}

// ------------------------------------------
// SHA-2 Final
// ------------------------------------------

void m_sha_2_224_final(void* avop_state,
                       unsigned char* abyp_digest)
{
    unsigned int *aunl_array = (unsigned int *)avop_state;
    unsigned int unl_i, unl_j;
    unsigned int unl_l;
    //---------------------------------------------------------------
    // Get stored long and remaining byte counts, append padding bits
    //---------------------------------------------------------------
    unl_j = aunl_array[26];             // get stored byte count
    unl_i = unl_j >> 2;                 // get remaining byte count
    unl_l = aunl_array[unl_i];          // get last stored DWORD
    BIGchar2longcn(byrs_end8,unl_l,(unl_j & 0x03));    // insert 1..4 padding bytes
    aunl_array[unl_i] = unl_l;          // save full long
    unl_i++;                            // to next long (not yet loaded)
    //---------------------------------------------------------------
    // check if this block has room for length data (8 bytes)
    // if not fill with zeroes and generate Digest
    //---------------------------------------------------------------
    if (aunl_array[26] >= 56) {         // not enough room
        for (; unl_i<16; unl_i++) {     // zero data
            aunl_array[unl_i] = 0;
        }
        ms_sha_256_block(aunl_array);       // generate digest
        unl_i = 0;                      // set index back
    }
    //---------------------------------------------------------------
    // fill block with zeroes until position for length reached,
    // insert bitlength, generate final Digest
    //---------------------------------------------------------------
    for (; unl_i<14; unl_i++) {         // clear
        aunl_array[unl_i] = 0;
    }
    aunl_array[14] = aunl_array[24];    // set length high
    aunl_array[15] = aunl_array[25];    // dto. low
    ms_sha_256_block(aunl_array);           // generate final digest
    //---------------------------------------------------------------
    // copy final digest to user buffer, clear SHA Array (safety)
    //---------------------------------------------------------------
    ms_write_big_endian(abyp_digest + 0, aunl_array[16]);
    ms_write_big_endian(abyp_digest + 4, aunl_array[17]);
    ms_write_big_endian(abyp_digest + 8, aunl_array[18]);
    ms_write_big_endian(abyp_digest + 12, aunl_array[19]);
    ms_write_big_endian(abyp_digest + 16, aunl_array[20]);
    ms_write_big_endian(abyp_digest + 20, aunl_array[21]);
    ms_write_big_endian(abyp_digest + 24, aunl_array[22]);

    m_sec_memzero(aunl_array, cind_digest_size_sha_2_224);
} // m_sha_2_224_final

void m_sha_2_256_final(void* avop_state,
                       unsigned char* abyp_digest)
{
    unsigned int *aunl_array = (unsigned int *)avop_state;
    unsigned int unl_i, unl_j;
    unsigned int unl_l;
    //---------------------------------------------------------------
    // Get stored long and remaining byte counts, append padding bits
    //---------------------------------------------------------------
    unl_j = aunl_array[26];                 // get stored byte count
    unl_i = unl_j >> 2;                     // get remaining byte count
    unl_l = aunl_array[unl_i];              // get last stored DWORD
    BIGchar2longcn(byrs_end8,unl_l,(unl_j & 0x03));    // insert 1..4 padding bytes
    aunl_array[unl_i] = unl_l;              // save full long
    unl_i++;                                // to next long (not yet loaded)
    //---------------------------------------------------------------
    // check if this block has room for length data (8 bytes)
    // if not fill with zeroes and generate Digest
    //---------------------------------------------------------------
    if (aunl_array[26] >= 56) {             // not enough room
        for (; unl_i < 16; unl_i++) {       // zero data
            aunl_array[unl_i] = 0;
        }
        ms_sha_256_block(aunl_array);           // generate digest
        unl_i = 0;                          // set index back
    }
    //---------------------------------------------------------------
    // fill block with zeroes until position for length reached,
    // insert bitlength, generate final Digest
    //---------------------------------------------------------------
    for (; unl_i < 14; unl_i++) {           // clear
        aunl_array[unl_i]=0;
    }
    aunl_array[14] = aunl_array[24];        // set length high
    aunl_array[15] = aunl_array[25];        // dto. low
    ms_sha_256_block(aunl_array);               // generate final digest
    //---------------------------------------------------------------
    // copy final digest to user buffer, clear SHA Array (safety)
    //---------------------------------------------------------------
    ms_write_big_endian(abyp_digest + 0, aunl_array[16]);
    ms_write_big_endian(abyp_digest + 4, aunl_array[17]);
    ms_write_big_endian(abyp_digest + 8, aunl_array[18]);
    ms_write_big_endian(abyp_digest + 12, aunl_array[19]);
    ms_write_big_endian(abyp_digest + 16, aunl_array[20]);
    ms_write_big_endian(abyp_digest + 20, aunl_array[21]);
    ms_write_big_endian(abyp_digest + 24, aunl_array[22]);
    ms_write_big_endian(abyp_digest + 28, aunl_array[23]);

    m_sec_memzero(aunl_array, cind_state_size_sha_2_256);
} // m_sha_2_256_final

void m_sha_2_384_final(void* avop_state,
                       unsigned char* abyp_digest)
{
    unsigned long long *aull_array = (unsigned long long *)avop_state;
    unsigned long long ull_i, ull_j;
    unsigned long long ull_l;
    //---------------------------------------------------------------
    // Get stored long and remaining byte counts, append padding bits
    //---------------------------------------------------------------
    ull_j = aull_array[26];             // get stored byte count
    ull_i = ull_j >> 3;                 // get remaining byte count
    ull_l = aull_array[ull_i];          // get last stored QWORD
    BIGchar2longlongcn(byrs_end8,ull_l,(ull_j & 0x07));  // insert 1..7 padding bytes
    aull_array[ull_i] = ull_l;          // save full longlong
    ull_i++;                            // to next longlong (not yet loaded)
    //---------------------------------------------------------------
    // check if this block has room for length data (16 bytes)
    // if not fill with zeroes and generate Digest
    //---------------------------------------------------------------
    if (aull_array[26] >= 112) {        // not enough room
        memset(&aull_array[ull_i],0, (16 - (size_t)ull_i)*sizeof(unsigned long long));
        ms_sha_512_block(aull_array);       // generate digest
        ull_i = 0;                      // set index back
    }
    //---------------------------------------------------------------
    // fill block with zeroes until position for length reached,
    // insert bitlength, generate final Digest
    //---------------------------------------------------------------
    memset(&aull_array[ull_i],0, (14 - (size_t)ull_i)*sizeof(unsigned long long));
    aull_array[14] = aull_array[24];    // set length high
    aull_array[15] = aull_array[25];    // dto. low

    ms_sha_512_block(aull_array);           // generate final digest
    //---------------------------------------------------------------
    // copy final digest to user buffer, clear SHA Array (safety)
    //---------------------------------------------------------------
    ms_write_big_endian(abyp_digest + 0, aull_array[16]);
    ms_write_big_endian(abyp_digest + 8, aull_array[17]);
    ms_write_big_endian(abyp_digest + 16, aull_array[18]);
    ms_write_big_endian(abyp_digest + 24, aull_array[19]);
    ms_write_big_endian(abyp_digest + 32, aull_array[20]);
    ms_write_big_endian(abyp_digest + 40, aull_array[21]);

    m_sec_memzero(aull_array, cind_digest_size_sha_2_384);
} // m_sha_2_384_final

void m_sha_2_512_final(void* avop_state,
                       unsigned char* abyp_digest)
{
    unsigned long long *aull_array = (unsigned long long *)avop_state;
    unsigned long long ull_i, ull_j;
    unsigned long long ull_l;
    //---------------------------------------------------------------
    // Get stored long and remaining byte counts, append padding bits
    //---------------------------------------------------------------
    ull_j = aull_array[26];             // get stored byte count
    ull_i = ull_j >> 3;                 // get remaining byte count
    ull_l = aull_array[ull_i];          // get last stored QWORD
    BIGchar2longlongcn(byrs_end8,ull_l,(ull_j & 0x07));  // insert 1..7 padding bytes
    aull_array[ull_i] = ull_l;          // save full longlong
    ull_i++;                            // to next longlong (not yet loaded)
    //---------------------------------------------------------------
    // check if this block has room for length data (16 bytes)
    // if not fill with zeroes and generate Digest
    //---------------------------------------------------------------
    if (aull_array[26] >= 112) {        // not enough room
        memset(&aull_array[ull_i],0, (16 - (size_t)ull_i)*sizeof(unsigned long long));
        ms_sha_512_block(aull_array);       // generate digest
        ull_i = 0;                      // set index back
    }
    //---------------------------------------------------------------
    // fill block with zeroes until position for length reached,
    // insert bitlength, generate final Digest
    //---------------------------------------------------------------
    memset(&aull_array[ull_i],0, (14 - (size_t)ull_i)*sizeof(unsigned long long));
    aull_array[14] = aull_array[24];    // set length high
    aull_array[15] = aull_array[25];    // dto. low
    ms_sha_512_block(aull_array);           // generate final digest
    //---------------------------------------------------------------
    // copy final digest to user buffer, clear SHA Array (safety)
    //---------------------------------------------------------------
    ms_write_big_endian(abyp_digest + 0, aull_array[16]);
    ms_write_big_endian(abyp_digest + 8, aull_array[17]);
    ms_write_big_endian(abyp_digest + 16, aull_array[18]);
    ms_write_big_endian(abyp_digest + 24, aull_array[19]);
    ms_write_big_endian(abyp_digest + 32, aull_array[20]);
    ms_write_big_endian(abyp_digest + 40, aull_array[21]);
    ms_write_big_endian(abyp_digest + 48, aull_array[22]);
    ms_write_big_endian(abyp_digest + 56, aull_array[23]);

    m_sec_memzero(aull_array, cind_state_size_sha_2_512);
} // m_sha_2_512_final


// ------------------------------------------
// Static definitions
// ------------------------------------------

//---------------------------------------
// Constants for SHA-256, 64 32-Bit words
//---------------------------------------

static const unsigned int uns_k0_sha256 = 0x428a2f98;
static const unsigned int uns_k1_sha256 = 0x71374491;
static const unsigned int uns_k2_sha256 = 0xb5c0fbcf;
static const unsigned int uns_k3_sha256 = 0xe9b5dba5;
static const unsigned int uns_k4_sha256 = 0x3956c25b;
static const unsigned int uns_k5_sha256 = 0x59f111f1;
static const unsigned int uns_k6_sha256 = 0x923f82a4;
static const unsigned int uns_k7_sha256 = 0xab1c5ed5;
static const unsigned int uns_k8_sha256 = 0xd807aa98;
static const unsigned int uns_k9_sha256 = 0x12835b01;
static const unsigned int uns_k10_sha256 = 0x243185be;
static const unsigned int uns_k11_sha256 = 0x550c7dc3;
static const unsigned int uns_k12_sha256 = 0x72be5d74;
static const unsigned int uns_k13_sha256 = 0x80deb1fe;
static const unsigned int uns_k14_sha256 = 0x9bdc06a7;
static const unsigned int uns_k15_sha256 = 0xc19bf174;
static const unsigned int uns_k16_sha256 = 0xe49b69c1;
static const unsigned int uns_k17_sha256 = 0xefbe4786;
static const unsigned int uns_k18_sha256 = 0x0fc19dc6;
static const unsigned int uns_k19_sha256 = 0x240ca1cc;
static const unsigned int uns_k20_sha256 = 0x2de92c6f;
static const unsigned int uns_k21_sha256 = 0x4a7484aa;
static const unsigned int uns_k22_sha256 = 0x5cb0a9dc;
static const unsigned int uns_k23_sha256 = 0x76f988da;
static const unsigned int uns_k24_sha256 = 0x983e5152;
static const unsigned int uns_k25_sha256 = 0xa831c66d;
static const unsigned int uns_k26_sha256 = 0xb00327c8;
static const unsigned int uns_k27_sha256 = 0xbf597fc7;
static const unsigned int uns_k28_sha256 = 0xc6e00bf3;
static const unsigned int uns_k29_sha256 = 0xd5a79147;
static const unsigned int uns_k30_sha256 = 0x06ca6351;
static const unsigned int uns_k31_sha256 = 0x14292967;
static const unsigned int uns_k32_sha256 = 0x27b70a85;
static const unsigned int uns_k33_sha256 = 0x2e1b2138;
static const unsigned int uns_k34_sha256 = 0x4d2c6dfc;
static const unsigned int uns_k35_sha256 = 0x53380d13;
static const unsigned int uns_k36_sha256 = 0x650a7354;
static const unsigned int uns_k37_sha256 = 0x766a0abb;
static const unsigned int uns_k38_sha256 = 0x81c2c92e;
static const unsigned int uns_k39_sha256 = 0x92722c85;
static const unsigned int uns_k40_sha256 = 0xa2bfe8a1;
static const unsigned int uns_k41_sha256 = 0xa81a664b;
static const unsigned int uns_k42_sha256 = 0xc24b8b70;
static const unsigned int uns_k43_sha256 = 0xc76c51a3;
static const unsigned int uns_k44_sha256 = 0xd192e819;
static const unsigned int uns_k45_sha256 = 0xd6990624;
static const unsigned int uns_k46_sha256 = 0xf40e3585;
static const unsigned int uns_k47_sha256 = 0x106aa070;
static const unsigned int uns_k48_sha256 = 0x19a4c116;
static const unsigned int uns_k49_sha256 = 0x1e376c08;
static const unsigned int uns_k50_sha256 = 0x2748774c;
static const unsigned int uns_k51_sha256 = 0x34b0bcb5;
static const unsigned int uns_k52_sha256 = 0x391c0cb3;
static const unsigned int uns_k53_sha256 = 0x4ed8aa4a;
static const unsigned int uns_k54_sha256 = 0x5b9cca4f;
static const unsigned int uns_k55_sha256 = 0x682e6ff3;
static const unsigned int uns_k56_sha256 = 0x748f82ee;
static const unsigned int uns_k57_sha256 = 0x78a5636f;
static const unsigned int uns_k58_sha256 = 0x84c87814;
static const unsigned int uns_k59_sha256 = 0x8cc70208;
static const unsigned int uns_k60_sha256 = 0x90befffa;
static const unsigned int uns_k61_sha256 = 0xa4506ceb;
static const unsigned int uns_k62_sha256 = 0xbef9a3f7;
static const unsigned int uns_k63_sha256 = 0xc67178f2;

//-------------------------------------------
// Constants for SHA-384/512, 80 64-Bit words
//-------------------------------------------

static const unsigned long long uls_k0_sha512 = 0x428a2f98d728ae22;
static const unsigned long long uls_k1_sha512 = 0x7137449123ef65cd;
static const unsigned long long uls_k2_sha512 = 0xb5c0fbcfec4d3b2f;
static const unsigned long long uls_k3_sha512 = 0xe9b5dba58189dbbc;
static const unsigned long long uls_k4_sha512 = 0x3956c25bf348b538;
static const unsigned long long uls_k5_sha512 = 0x59f111f1b605d019;
static const unsigned long long uls_k6_sha512 = 0x923f82a4af194f9b;
static const unsigned long long uls_k7_sha512 = 0xab1c5ed5da6d8118;
static const unsigned long long uls_k8_sha512 = 0xd807aa98a3030242;
static const unsigned long long uls_k9_sha512 = 0x12835b0145706fbe;
static const unsigned long long uls_k10_sha512 = 0x243185be4ee4b28c;
static const unsigned long long uls_k11_sha512 = 0x550c7dc3d5ffb4e2;
static const unsigned long long uls_k12_sha512 = 0x72be5d74f27b896f;
static const unsigned long long uls_k13_sha512 = 0x80deb1fe3b1696b1;
static const unsigned long long uls_k14_sha512 = 0x9bdc06a725c71235;
static const unsigned long long uls_k15_sha512 = 0xc19bf174cf692694;
static const unsigned long long uls_k16_sha512 = 0xe49b69c19ef14ad2;
static const unsigned long long uls_k17_sha512 = 0xefbe4786384f25e3;
static const unsigned long long uls_k18_sha512 = 0x0fc19dc68b8cd5b5;
static const unsigned long long uls_k19_sha512 = 0x240ca1cc77ac9c65;
static const unsigned long long uls_k20_sha512 = 0x2de92c6f592b0275;
static const unsigned long long uls_k21_sha512 = 0x4a7484aa6ea6e483;
static const unsigned long long uls_k22_sha512 = 0x5cb0a9dcbd41fbd4;
static const unsigned long long uls_k23_sha512 = 0x76f988da831153b5;
static const unsigned long long uls_k24_sha512 = 0x983e5152ee66dfab;
static const unsigned long long uls_k25_sha512 = 0xa831c66d2db43210;
static const unsigned long long uls_k26_sha512 = 0xb00327c898fb213f;
static const unsigned long long uls_k27_sha512 = 0xbf597fc7beef0ee4;
static const unsigned long long uls_k28_sha512 = 0xc6e00bf33da88fc2;
static const unsigned long long uls_k29_sha512 = 0xd5a79147930aa725;
static const unsigned long long uls_k30_sha512 = 0x06ca6351e003826f;
static const unsigned long long uls_k31_sha512 = 0x142929670a0e6e70;
static const unsigned long long uls_k32_sha512 = 0x27b70a8546d22ffc;
static const unsigned long long uls_k33_sha512 = 0x2e1b21385c26c926;
static const unsigned long long uls_k34_sha512 = 0x4d2c6dfc5ac42aed;
static const unsigned long long uls_k35_sha512 = 0x53380d139d95b3df;
static const unsigned long long uls_k36_sha512 = 0x650a73548baf63de;
static const unsigned long long uls_k37_sha512 = 0x766a0abb3c77b2a8;
static const unsigned long long uls_k38_sha512 = 0x81c2c92e47edaee6;
static const unsigned long long uls_k39_sha512 = 0x92722c851482353b;
static const unsigned long long uls_k40_sha512 = 0xa2bfe8a14cf10364;
static const unsigned long long uls_k41_sha512 = 0xa81a664bbc423001;
static const unsigned long long uls_k42_sha512 = 0xc24b8b70d0f89791;
static const unsigned long long uls_k43_sha512 = 0xc76c51a30654be30;
static const unsigned long long uls_k44_sha512 = 0xd192e819d6ef5218;
static const unsigned long long uls_k45_sha512 = 0xd69906245565a910;
static const unsigned long long uls_k46_sha512 = 0xf40e35855771202a;
static const unsigned long long uls_k47_sha512 = 0x106aa07032bbd1b8;
static const unsigned long long uls_k48_sha512 = 0x19a4c116b8d2d0c8;
static const unsigned long long uls_k49_sha512 = 0x1e376c085141ab53;
static const unsigned long long uls_k50_sha512 = 0x2748774cdf8eeb99;
static const unsigned long long uls_k51_sha512 = 0x34b0bcb5e19b48a8;
static const unsigned long long uls_k52_sha512 = 0x391c0cb3c5c95a63;
static const unsigned long long uls_k53_sha512 = 0x4ed8aa4ae3418acb;
static const unsigned long long uls_k54_sha512 = 0x5b9cca4f7763e373;
static const unsigned long long uls_k55_sha512 = 0x682e6ff3d6b2b8a3;
static const unsigned long long uls_k56_sha512 = 0x748f82ee5defb2fc;
static const unsigned long long uls_k57_sha512 = 0x78a5636f43172f60;
static const unsigned long long uls_k58_sha512 = 0x84c87814a1f0ab72;
static const unsigned long long uls_k59_sha512 = 0x8cc702081a6439ec;
static const unsigned long long uls_k60_sha512 = 0x90befffa23631e28;
static const unsigned long long uls_k61_sha512 = 0xa4506cebde82bde9;
static const unsigned long long uls_k62_sha512 = 0xbef9a3f7b2c67915;
static const unsigned long long uls_k63_sha512 = 0xc67178f2e372532b;
static const unsigned long long uls_k64_sha512 = 0xca273eceea26619c;
static const unsigned long long uls_k65_sha512 = 0xd186b8c721c0c207;
static const unsigned long long uls_k66_sha512 = 0xeada7dd6cde0eb1e;
static const unsigned long long uls_k67_sha512 = 0xf57d4f7fee6ed178;
static const unsigned long long uls_k68_sha512 = 0x06f067aa72176fba;
static const unsigned long long uls_k69_sha512 = 0x0a637dc5a2c898a6;
static const unsigned long long uls_k70_sha512 = 0x113f9804bef90dae;
static const unsigned long long uls_k71_sha512 = 0x1b710b35131c471b;
static const unsigned long long uls_k72_sha512 = 0x28db77f523047d84;
static const unsigned long long uls_k73_sha512 = 0x32caab7b40c72493;
static const unsigned long long uls_k74_sha512 = 0x3c9ebe0a15c9bebc;
static const unsigned long long uls_k75_sha512 = 0x431d67c49c100d4c;
static const unsigned long long uls_k76_sha512 = 0x4cc5d4becb3e42b6;
static const unsigned long long uls_k77_sha512 = 0x597f299cfc657e2a;
static const unsigned long long uls_k78_sha512 = 0x5fcb6fab3ad6faec;
static const unsigned long long uls_k79_sha512 = 0x6c44198c4a475817;

//--------------------------------------------------
// Macros for SHA-256/384/512
//--------------------------------------------------

#define Ch_SHA(x,y,z)   ((x & y)^((~x) & z))
#define Maj_SHA(x,y,z)  ((x & y)^(x & z)^(y & z))

#define S0_256(x)   ((((x>> 2) & 0x3FFFFFFF)|(x<<30))^ \
                     (((x>>13) & 0x0007FFFF)|(x<<19))^ \
                     (((x>>22) & 0x000003FF)|(x<<10)))
#define S1_256(x)   ((((x>> 6) & 0x03FFFFFF)|(x<<26))^ \
                     (((x>>11) & 0x001FFFFF)|(x<<21))^ \
                     (((x>>25) & 0x0000007F)|(x<<7)))
#define s0_256(x)   ((((x>> 7) & 0x01FFFFFF)|(x<<25))^ \
                     (((x>>18) & 0x00003FFF)|(x<<14))^ \
                     (((x>> 3) & 0x1FFFFFFF)))
#define s1_256(x)   ((((x>>17) & 0x00007FFF)|(x<<15))^ \
                     (((x>>19) & 0x00001FFF)|(x<<13))^ \
                     (((x>>10) & 0x003FFFFF)))

#define S0_512(x)   ((((x>>28) & (0x0000000FFFFFFFFFLL))|(x<<36))^ \
                     (((x>>34) & (0x000000003FFFFFFFLL))|(x<<30))^ \
                     (((x>>39) & (0x0000000001FFFFFFLL))|(x<<25)))
#define S1_512(x)   ((((x>>14) & (0x0003FFFFFFFFFFFFLL))|(x<<50))^ \
                     (((x>>18) & (0x00003FFFFFFFFFFFLL))|(x<<46))^ \
                     (((x>>41) & (0x00000000007FFFFFLL))|(x<<23)))
#define s0_512(x)   ((((x>> 1) & (0x7FFFFFFFFFFFFFFFLL))|(x<<63))^ \
                     (((x>> 8) & (0x00FFFFFFFFFFFFFFLL))|(x<<56))^ \
                     (((x>> 7) & (0x01FFFFFFFFFFFFFFLL))))
#define s1_512(x)   ((((x>>19) & (0x00001FFFFFFFFFFFLL))|(x<<45))^ \
                     (((x>>61) & (0x0000000000000007LL))|(x<<3))^ \
                     (((x>> 6) & (0x03FFFFFFFFFFFFFFLL))))

//===============================================================
// Constant arrays for SHA256 and SHA384/512 for Block operations
//===============================================================
//BIT32ARRAYI
static const unsigned int unrs_sha_256_const[64] = {
    uns_k0_sha256,  uns_k1_sha256,  uns_k2_sha256,  uns_k3_sha256,
    uns_k4_sha256,  uns_k5_sha256,  uns_k6_sha256,  uns_k7_sha256,
    uns_k8_sha256,  uns_k9_sha256,  uns_k10_sha256, uns_k11_sha256,
    uns_k12_sha256, uns_k13_sha256, uns_k14_sha256, uns_k15_sha256,
    uns_k16_sha256, uns_k17_sha256, uns_k18_sha256, uns_k19_sha256,
    uns_k20_sha256, uns_k21_sha256, uns_k22_sha256, uns_k23_sha256,
    uns_k24_sha256, uns_k25_sha256, uns_k26_sha256, uns_k27_sha256,
    uns_k28_sha256, uns_k29_sha256, uns_k30_sha256, uns_k31_sha256,
    uns_k32_sha256, uns_k33_sha256, uns_k34_sha256, uns_k35_sha256,
    uns_k36_sha256, uns_k37_sha256, uns_k38_sha256, uns_k39_sha256,
    uns_k40_sha256, uns_k41_sha256, uns_k42_sha256, uns_k43_sha256,
    uns_k44_sha256, uns_k45_sha256, uns_k46_sha256, uns_k47_sha256,
    uns_k48_sha256, uns_k49_sha256, uns_k50_sha256, uns_k51_sha256,
    uns_k52_sha256, uns_k53_sha256, uns_k54_sha256, uns_k55_sha256,
    uns_k56_sha256, uns_k57_sha256, uns_k58_sha256, uns_k59_sha256,
    uns_k60_sha256, uns_k61_sha256, uns_k62_sha256, uns_k63_sha256,
};

//BIT64ARRAYI
static const unsigned long long ulrs_sha_512_const[80] = {
    uls_k0_sha512,  uls_k1_sha512,  uls_k2_sha512,  uls_k3_sha512,
    uls_k4_sha512,  uls_k5_sha512,  uls_k6_sha512,  uls_k7_sha512,
    uls_k8_sha512,  uls_k9_sha512,  uls_k10_sha512, uls_k11_sha512,
    uls_k12_sha512, uls_k13_sha512, uls_k14_sha512, uls_k15_sha512,
    uls_k16_sha512, uls_k17_sha512, uls_k18_sha512, uls_k19_sha512,
    uls_k20_sha512, uls_k21_sha512, uls_k22_sha512, uls_k23_sha512,
    uls_k24_sha512, uls_k25_sha512, uls_k26_sha512, uls_k27_sha512,
    uls_k28_sha512, uls_k29_sha512, uls_k30_sha512, uls_k31_sha512,
    uls_k32_sha512, uls_k33_sha512, uls_k34_sha512, uls_k35_sha512,
    uls_k36_sha512, uls_k37_sha512, uls_k38_sha512, uls_k39_sha512,
    uls_k40_sha512, uls_k41_sha512, uls_k42_sha512, uls_k43_sha512,
    uls_k44_sha512, uls_k45_sha512, uls_k46_sha512, uls_k47_sha512,
    uls_k48_sha512, uls_k49_sha512, uls_k50_sha512, uls_k51_sha512,
    uls_k52_sha512, uls_k53_sha512, uls_k54_sha512, uls_k55_sha512,
    uls_k56_sha512, uls_k57_sha512, uls_k58_sha512, uls_k59_sha512,
    uls_k60_sha512, uls_k61_sha512, uls_k62_sha512, uls_k63_sha512,
    uls_k64_sha512, uls_k65_sha512, uls_k66_sha512, uls_k67_sha512,
    uls_k68_sha512, uls_k69_sha512, uls_k70_sha512, uls_k71_sha512,
    uls_k72_sha512, uls_k73_sha512, uls_k74_sha512, uls_k75_sha512,
    uls_k76_sha512, uls_k77_sha512, uls_k78_sha512, uls_k79_sha512,
};

/**
 * Subroutine ms_sha_256_block performs SHA-256 block operation
 * on a filled SHA block, updates H0..H7 (ms_sha_256_block).
 * NOTE: Can be unfolded if needed (much code!)
 *
 * @param aunp_array SHA State structure
 */
static void ms_sha_256_block (unsigned int* aunp_array)
{
    unsigned int unl_a = aunp_array[16+0];      // H0
    unsigned int unl_b = aunp_array[16+1];      // H1
    unsigned int unl_c = aunp_array[16+2];      // H2
    unsigned int unl_d = aunp_array[16+3];      // H3
    unsigned int unl_e = aunp_array[16+4];      // H4
    unsigned int unl_f = aunp_array[16+5];      // H5
    unsigned int unl_g = aunp_array[16+6];      // H6
    unsigned int unl_h = aunp_array[16+7];      // H7
    unsigned int unl_i;
    unsigned int unl_T1, unl_T2, unl_W1, unl_W2;
    //----------------------------------------------------------
    // Generate the SHA-256 Hash for the given Block for 0<=t<64
    //----------------------------------------------------------
    for (unl_i = 0; unl_i < 16; unl_i++) {      // 0<= t <16
        unl_T1 = unl_h + S1_256(unl_e) + Ch_SHA(unl_e,unl_f,unl_g)
                 + unrs_sha_256_const[unl_i] + aunp_array[unl_i];
        unl_T2 = S0_256(unl_a) + Maj_SHA(unl_a,unl_b,unl_c);
        unl_h = unl_g;
        unl_g = unl_f;
        unl_f = unl_e;
        unl_e = unl_d + unl_T1;
        unl_d = unl_c;
        unl_c = unl_b;
        unl_b = unl_a;
        unl_a = unl_T1 + unl_T2;
    }
    for (unl_i=0; unl_i<16; unl_i++) {          // 16<= t <32
        unl_W1 = aunp_array[(unl_i+14) & 0x0F];
        unl_W2 = aunp_array[(unl_i+1) & 0x0F];
        aunp_array[unl_i] = s1_256(unl_W1) + aunp_array[(unl_i+9) & 0x0F]
                            + s0_256(unl_W2) + aunp_array[unl_i];
        unl_T1 = unl_h + S1_256(unl_e) + Ch_SHA(unl_e,unl_f,unl_g)
                 + unrs_sha_256_const[unl_i+16] + aunp_array[unl_i];
        unl_T2 = S0_256(unl_a) + Maj_SHA(unl_a,unl_b,unl_c);
        unl_h = unl_g;
        unl_g = unl_f;
        unl_f = unl_e;
        unl_e = unl_d + unl_T1;
        unl_d = unl_c;
        unl_c = unl_b;
        unl_b = unl_a;
        unl_a = unl_T1 + unl_T2;
    }
    for (unl_i = 0; unl_i < 16; unl_i++) {      // 32<= t <48
        unl_W1 = aunp_array[(unl_i+14) & 0x0F];
        unl_W2 = aunp_array[(unl_i+1) & 0x0F];
        aunp_array[unl_i] = s1_256(unl_W1) + aunp_array[(unl_i+9) & 0x0F]
                            + s0_256(unl_W2) + aunp_array[unl_i];
        unl_T1 = unl_h + S1_256(unl_e) + Ch_SHA(unl_e,unl_f,unl_g)
                 + unrs_sha_256_const[unl_i+32] + aunp_array[unl_i];
        unl_T2 = S0_256(unl_a) + Maj_SHA(unl_a,unl_b,unl_c);
        unl_h = unl_g;
        unl_g = unl_f;
        unl_f = unl_e;
        unl_e = unl_d + unl_T1;
        unl_d = unl_c;
        unl_c = unl_b;
        unl_b = unl_a;
        unl_a = unl_T1 + unl_T2;
    }
    for (unl_i = 0; unl_i < 16; unl_i++)    {       // 48<= t <64
        unl_W1 = aunp_array[(unl_i+14) & 0x0F];
        unl_W2 = aunp_array[(unl_i+1) & 0x0F];
        aunp_array[unl_i] = s1_256(unl_W1) + aunp_array[(unl_i+9) & 0x0F]
                            + s0_256(unl_W2) + aunp_array[unl_i];
        unl_T1 = unl_h + S1_256(unl_e) + Ch_SHA(unl_e,unl_f,unl_g)
                 + unrs_sha_256_const[unl_i+48] + aunp_array[unl_i];
        unl_T2 = S0_256(unl_a) + Maj_SHA(unl_a,unl_b,unl_c);
        unl_h = unl_g;
        unl_g = unl_f;
        unl_f = unl_e;
        unl_e = unl_d + unl_T1;
        unl_d = unl_c;
        unl_c = unl_b;
        unl_b = unl_a;
        unl_a = unl_T1 + unl_T2;
    }
    aunp_array[16+0] += unl_a;      // H0
    aunp_array[16+1] += unl_b;      // H1
    aunp_array[16+2] += unl_c;      // H2
    aunp_array[16+3] += unl_d;      // H3
    aunp_array[16+4] += unl_e;      // H4
    aunp_array[16+5] += unl_f;      // H5
    aunp_array[16+6] += unl_g;      // H6
    aunp_array[16+7] += unl_h;      // H7
} // ms_sha_256_block

/**
 * Subroutine ms_sha_512_block performs SHA-384/512 block operation
 * on a filled SHA block, updates H0..H7 (ms_sha_512_block).
 * NOTE: Can be unfolded if needed (much code!)
 *
 * @param aulp_array SHA State structure
 */
static void ms_sha_512_block(unsigned long long* aulp_array)
{
    unsigned long long ull_a = aulp_array[16+0];        // H0
    unsigned long long ull_b = aulp_array[16+1];        // H1
    unsigned long long ull_c = aulp_array[16+2];        // H2
    unsigned long long ull_d = aulp_array[16+3];        // H3
    unsigned long long ull_e = aulp_array[16+4];        // H4
    unsigned long long ull_f = aulp_array[16+5];        // H5
    unsigned long long ull_g = aulp_array[16+6];        // H6
    unsigned long long ull_h = aulp_array[16+7];        // H7
    unsigned int unl_i;
    unsigned long long ull_T1, ull_T2, ull_W1, ull_W2;
    // Generate the SHA-384/512 Hash for the given Block
    for (unl_i = 0; unl_i < 16; unl_i++) {          // 0<= t <16
        ull_T1 = ull_h + S1_512(ull_e) + Ch_SHA(ull_e,ull_f,ull_g)
                 + ulrs_sha_512_const[unl_i] + aulp_array[unl_i];
        ull_T2 = S0_512(ull_a) + Maj_SHA(ull_a,ull_b,ull_c);
        ull_h = ull_g;
        ull_g = ull_f;
        ull_f = ull_e;
        ull_e = ull_d + ull_T1;
        ull_d = ull_c;
        ull_c = ull_b;
        ull_b = ull_a;
        ull_a = ull_T1 + ull_T2;
    }
    for (unl_i = 0; unl_i < 16; unl_i++) {          // 16<= t <32
        ull_W1 = aulp_array[(unl_i+14) & 0x0F];
        ull_W2 = aulp_array[(unl_i+1) & 0x0F];
        aulp_array[unl_i] = s1_512(ull_W1) + aulp_array[(unl_i+9) & 0x0F]
                            + s0_512(ull_W2) + aulp_array[unl_i];
        ull_T1 = ull_h + S1_512(ull_e) + Ch_SHA(ull_e,ull_f,ull_g)
                 + ulrs_sha_512_const[unl_i+16] + aulp_array[unl_i];
        ull_T2 = S0_512(ull_a) + Maj_SHA(ull_a,ull_b,ull_c);
        ull_h = ull_g;
        ull_g = ull_f;
        ull_f = ull_e;
        ull_e = ull_d + ull_T1;
        ull_d = ull_c;
        ull_c = ull_b;
        ull_b = ull_a;
        ull_a = ull_T1 + ull_T2;
    }
    for (unl_i = 0; unl_i < 16; unl_i++) {          // 32<= t <48
        ull_W1 = aulp_array[(unl_i+14) & 0x0F];
        ull_W2 = aulp_array[(unl_i+1) & 0x0F];
        aulp_array[unl_i] = s1_512(ull_W1) + aulp_array[(unl_i+9) & 0x0F]
                            + s0_512(ull_W2) + aulp_array[unl_i];
        ull_T1 = ull_h + S1_512(ull_e) + Ch_SHA(ull_e,ull_f,ull_g)
                 + ulrs_sha_512_const[unl_i+32] + aulp_array[unl_i];
        ull_T2 = S0_512(ull_a) + Maj_SHA(ull_a,ull_b,ull_c);
        ull_h = ull_g;
        ull_g = ull_f;
        ull_f = ull_e;
        ull_e = ull_d + ull_T1;
        ull_d = ull_c;
        ull_c = ull_b;
        ull_b = ull_a;
        ull_a = ull_T1 + ull_T2;
    }
    for (unl_i = 0; unl_i < 16; unl_i++) {      // 48<= t <64
        ull_W1 = aulp_array[(unl_i+14) & 0x0F];
        ull_W2 = aulp_array[(unl_i+1) & 0x0F];
        aulp_array[unl_i] = s1_512(ull_W1) + aulp_array[(unl_i+9) & 0x0F]
                            + s0_512(ull_W2) + aulp_array[unl_i];
        ull_T1 = ull_h + S1_512(ull_e) + Ch_SHA(ull_e,ull_f,ull_g)
                 + ulrs_sha_512_const[unl_i+48] + aulp_array[unl_i];
        ull_T2 = S0_512(ull_a) + Maj_SHA(ull_a,ull_b,ull_c);
        ull_h = ull_g;
        ull_g = ull_f;
        ull_f = ull_e;
        ull_e = ull_d + ull_T1;
        ull_d = ull_c;
        ull_c = ull_b;
        ull_b = ull_a;
        ull_a = ull_T1 + ull_T2;
    }
    for (unl_i = 0; unl_i < 16; unl_i++) {          // 64<= t <79
        ull_W1 = aulp_array[(unl_i+14) & 0x0F];
        ull_W2 = aulp_array[(unl_i+1) & 0x0F];
        aulp_array[unl_i] = s1_512(ull_W1) + aulp_array[(unl_i+9) & 0x0F]
                            + s0_512(ull_W2) + aulp_array[unl_i];
        ull_T1 = ull_h + S1_512(ull_e) + Ch_SHA(ull_e,ull_f,ull_g)
                 + ulrs_sha_512_const[unl_i+64] + aulp_array[unl_i];
        ull_T2 = S0_512(ull_a) + Maj_SHA(ull_a,ull_b,ull_c);
        ull_h = ull_g;
        ull_g = ull_f;
        ull_f = ull_e;
        ull_e = ull_d + ull_T1;
        ull_d = ull_c;
        ull_c = ull_b;
        ull_b = ull_a;
        ull_a = ull_T1 + ull_T2;
    }
    aulp_array[16+0] += ull_a;      // H0
    aulp_array[16+1] += ull_b;      // H1
    aulp_array[16+2] += ull_c;      // H2
    aulp_array[16+3] += ull_d;      // H3
    aulp_array[16+4] += ull_e;      // H4
    aulp_array[16+5] += ull_f;      // H5
    aulp_array[16+6] += ull_g;      // H6
    aulp_array[16+7] += ull_h;      // H7
} // ms_sha_512_block

//------------------------------------------------------------------------------
// Start of original file ./xs-ecc-1.cpp
//------------------------------------------------------------------------------

#include <string.h>

#ifdef _WIN32
#include <Windows.h>
#else
#include "hob-unix01.h"
#ifndef HL_UNIX
#define HL_UNIX

#if (defined __APPLE__) && (defined __MACH__)
#define HL_LINUX
#define HL_MACOS
#endif

#endif // !HL_UNIX
#endif
#include "hob-xslhcla1.hpp"

#include "hob-encry-2.h"
#include "hob-encry-intern-2.h"

#ifndef min
#define min(a,b)            (((a) < (b)) ? (a) : (b))
#endif

#define UINTROUNDUP(n,d) ((((n) - 1) | ((d) - 1)) + 1)

#ifdef HL_LNUM_64_BIT
#define X25519_PRIV_KEY_MASK_1 0xFFFFFFFFFFFFFFF8
#define X25519_PRIV_KEY_MASK_2 0x7FFFFFFFFFFFFFFF
#define X25519_PRIV_KEY_MASK_3 0x4000000000000000
#define X448_PRIV_KEY_MASK_1 0xFFFFFFFFFFFFFFFC
#define X448_PRIV_KEY_MASK_2 0x8000000000000000
#define X25519_PUB_KEY_MASK 0x7FFFFFFFFFFFFFFF
#else
#define X25519_PRIV_KEY_MASK_1 0xFFFFFFF8
#define X25519_PRIV_KEY_MASK_2 0x7FFFFFFF
#define X25519_PRIV_KEY_MASK_3 0x40000000
#define X448_PRIV_KEY_MASK_1 0xFFFFFFFC
#define X448_PRIV_KEY_MASK_2 0x80000000
#define X25519_PUB_KEY_MASK 0x7FFFFFFF
#endif


const size_t cszrg_ecdh_public_key_len[] = {
    2*24 + 1,                                // P192
    2*28 + 1,                                // P224
    2*32 + 1,                                // P256
    2*48 + 1,                                // P384
    2*66 + 1,                                // P521
    2*24 + 1,                                // SECP192K1
    2*28 + 1,                                // SECP224K1
    2*32 + 1,                                // SECP256K1
    2*32 + 1,                                // brainpool256
    2*48 + 1,                                // brainpool384
    2*64 + 1,                                // brainpool512
    32 + 1,                                  // X25519
    56 + 1,                                  // X448
};
extern const size_t cszrg_ecdh_public_key_len[ied_size_curves];

const size_t cszrg_ecdh_secret_len[] = {
    24,                                // P192
    28,                                // P224
    32,                                // P256
    48,                                // P384
    66,                                // P521
    24,                                // SECP192K1
    28,                                // SECP224K1
    32,                                // SECP256K1
    32,                                // brainpool256
    48,                                // brainpool384
    64,                                // brainpool512
    32,                                // X25519
    56,                                // X448
};
extern const size_t cszrg_ecdh_secret_len[ied_size_curves];

const size_t cszrg_prime_len[] = {
    24, // P192
    28, // P224
    32, // P256
    48, // P384
    66, // P521
    24, // SECP192K1
    28, // SECP224K1
    32, // SECP256K1
    32, // brainpool256
    48, // brainpool384
    64, // brainpool512
    32, // X25519
    56, // X448
};
extern const size_t cszrg_prime_len[ied_size_curves];

const size_t cszrg_subgroup_len[] = {
    24, // P192
    28, // P224
    32, // P256
    48, // P384
    66, // P521
    24, // SECP192K1
    29, // SECP224K1
    32, // SECP256K1
    32, // brainpool256
    48, // brainpool384
    64, // brainpool512
    32, // X25519
    56, // X448
};
extern const size_t cszrg_subgroup_len[ied_size_curves];

const char chg_uncompressed_format = 0x04;

extern "C" size_t m_mem_pool_ecc_size(enum ied_ecc_function iep_function,
                                      enum ied_ecc_named_curves iep_curve)
{
    switch (iep_function){
    case ied_m_ecc_init_named_curve:
        return REQSIZE_m_ecc_init_named_curve(UINTROUNDUP(cszrg_prime_len[iep_curve], sizeof(LNUM_WORD))) + REQSIZE_ALIGNMENT;
    case ied_m_ecc_gen_rand_keypair:
        switch(iep_curve){
        case ied_X25519:
        case ied_X448:
            return REQSIZE_ms_gen_rand_keypair_montgomery(UINTROUNDUP(cszrg_prime_len[iep_curve], sizeof(LNUM_WORD))) + REQSIZE_ALIGNMENT;
        default:
            return REQSIZE_ms_gen_rand_keypair_weierstrass(UINTROUNDUP(cszrg_prime_len[iep_curve], sizeof(LNUM_WORD)), UINTROUNDUP(cszrg_subgroup_len[iep_curve], sizeof(LNUM_WORD))) + REQSIZE_ALIGNMENT;
        }
    case ied_m_ecc_gen_static_keypair:
        switch(iep_curve){
        case ied_X25519:
        case ied_X448:
            return REQSIZE_ms_gen_static_keypair_montgomery(UINTROUNDUP(cszrg_prime_len[iep_curve], sizeof(LNUM_WORD))) + REQSIZE_ALIGNMENT;
        default:
            return REQSIZE_ms_gen_static_keypair_weierstrass(UINTROUNDUP(cszrg_prime_len[iep_curve], sizeof(LNUM_WORD)), UINTROUNDUP(cszrg_subgroup_len[iep_curve], sizeof(LNUM_WORD))) + REQSIZE_ALIGNMENT;
        }
    case ied_m_ecc_gen_secret:
        switch(iep_curve){
        case ied_X25519:
        case ied_X448:
            return REQSIZE_ms_gen_secret_montgomery(UINTROUNDUP(cszrg_prime_len[iep_curve], sizeof(LNUM_WORD))) + REQSIZE_ALIGNMENT;
        default:
            return REQSIZE_ms_gen_secret_weierstrass(UINTROUNDUP(cszrg_prime_len[iep_curve], sizeof(LNUM_WORD)), UINTROUNDUP(cszrg_subgroup_len[iep_curve], sizeof(LNUM_WORD))) + REQSIZE_ALIGNMENT;
        }
    case ied_m_ecc_gen_signature:
        switch(iep_curve){
        case ied_X25519:
        case ied_X448:
            return 0;
        default:
            return REQSIZE_m_ecc_gen_signature(UINTROUNDUP(cszrg_prime_len[iep_curve], sizeof(LNUM_WORD)), UINTROUNDUP(cszrg_subgroup_len[iep_curve], sizeof(LNUM_WORD))) + REQSIZE_ALIGNMENT;
        }
    case ied_m_ecc_verify_sig:
        switch(iep_curve){
        case ied_X25519:
        case ied_X448:
            return 0;
        default:
            return REQSIZE_m_ecc_verify_sig(UINTROUNDUP(cszrg_prime_len[iep_curve], sizeof(LNUM_WORD)), UINTROUNDUP(cszrg_subgroup_len[iep_curve], sizeof(LNUM_WORD))) + REQSIZE_ALIGNMENT;
        }
    default:
        return 0;
    }
}


// TODO: set to 0 after allocation?
extern "C" ied_encry_return m_ecc_init_keypair(struct dsd_memory *adsp_memory,
                                               struct dsd_ecc_keypair *adsp_ecc_keypair)
{
    if (!adsp_ecc_keypair || !adsp_memory) {
        return ied_encry_null_pointer;
    }
    if (!adsp_ecc_keypair->adsc_params) {
        return ied_ecc_curve_empty;
    }
    if (adsp_ecc_keypair->adsc_priv_key || adsp_ecc_keypair->adsc_pub_key) {
        return ied_ecc_context_not_clean;
    }

    // alloc size
    size_t szl_bytes_prime = adsp_ecc_keypair->adsc_params->adsc_prime->szc_used_size_bytes;
    size_t szl_alloc_bytes = sizeof(struct dsd_ec_point) + 4 * (sizeof(struct dsd_lnum) + szl_bytes_prime);

    // allocate all in one block
    char* achl_base = (char*)adsp_memory->amc_malloc(adsp_memory, szl_alloc_bytes);
    char* achl_memory = achl_base;

    if (achl_base == NULL) {
        return ied_encry_alloc_failure;
    }

    //perform pointer arithmetic to set members
#define INIT_AS_LNUM(lnum, pointer, size) \
    lnum = (struct dsd_lnum*)pointer; \
    pointer += sizeof(struct dsd_lnum); \
    lnum->szc_alloc_size_bytes = (size); \
    lnum->szc_used_size_bytes = 0; \
    lnum->aucc_data = (unsigned char*)pointer; \
    pointer += size;

    //private key (in first position, will be used in m_ecc_free_keypair)
    INIT_AS_LNUM(adsp_ecc_keypair->adsc_priv_key,achl_memory, szl_bytes_prime)

    //Own public key
    adsp_ecc_keypair->adsc_pub_key = (struct dsd_ec_point*)achl_memory;
    achl_memory += sizeof(struct dsd_ec_point);
    INIT_AS_LNUM(adsp_ecc_keypair->adsc_pub_key->adsc_x, achl_memory, szl_bytes_prime)
    INIT_AS_LNUM(adsp_ecc_keypair->adsc_pub_key->adsc_y, achl_memory, szl_bytes_prime)
    INIT_AS_LNUM(adsp_ecc_keypair->adsc_pub_key->adsc_z, achl_memory, szl_bytes_prime)
    adsp_ecc_keypair->adsc_pub_key->iec_representation = ied_affine;

    return ied_encry_success;
} // m_ecc_init_keypair

// TODO: use lnum instaed of eec_keypar? then usable for ffc too.                                                    
inline static ied_encry_return ms_export_public_key(char *achp_public_key_out,
                                                         size_t *aszp_pub_buffer_len,
                                                         struct dsd_ecc_keypair *adsp_ecc_keypair)
{
    size_t szl_secret_len = cszrg_ecdh_secret_len[adsp_ecc_keypair->adsc_params->iec_name];
    size_t szl_len = szl_secret_len;
    ied_encry_return iel_ret;
    achp_public_key_out[0] = chg_uncompressed_format;
    if (adsp_ecc_keypair->adsc_params->iec_type != ied_montgomery) {
        iel_ret = m_lnum_store_bytes_be(achp_public_key_out + 1, &szl_len, adsp_ecc_keypair->adsc_pub_key->adsc_x, TRUE);
        if (iel_ret != ied_encry_success) {
            return iel_ret;
        }
        iel_ret = m_lnum_store_bytes_be(achp_public_key_out + 1 + szl_secret_len,
                                        &szl_len,
                                        adsp_ecc_keypair->adsc_pub_key->adsc_y,
                                        TRUE);
    } else {
        iel_ret = m_lnum_store_bytes_le(achp_public_key_out + 1, &szl_len, adsp_ecc_keypair->adsc_pub_key->adsc_x, TRUE);
    }
    *aszp_pub_buffer_len = cszrg_ecdh_public_key_len[adsp_ecc_keypair->adsc_params->iec_name];
    return iel_ret;  
}

/**
   generates keypair for montgomery curve with a given private key

   @param[out]     dsd_ecc_keypair         keypair structure
   @param[out]     achp_public_key_out     buffer for public key
   @param[in,out]  aszp_pub_buffer_len     [in] allocated len of buffer [out] len of public key
   @param[in,out]  adsp_pool               pool
   @param[in]      szp_secret_len          len of private key and secret buffer
   @param[in]      szp_public_len          len of public key buffer
   @param[in]      achp_private_key        given private key

   @return 0 on success, errorcode otherwise
 */
inline static ied_encry_return ms_gen_static_keypair_montgomery(struct dsd_ecc_keypair *adsp_ecc_keypair,
                                                                struct dsd_mem_pool_ele *adsp_pool,
                                                                const size_t szp_secret_len,
                                                                const char *achp_private_key)
{
    // load little endian
    m_lnum_load_bytes_le(adsp_ecc_keypair->adsc_priv_key, achp_private_key, (unsigned int)szp_secret_len); // won't fail
    // must be of prime size for bitmasks
    ms_lnum_zero_fill(adsp_ecc_keypair->adsc_priv_key, adsp_ecc_keypair->adsc_params->adsc_prime->szc_used_size_bytes);
    adsp_ecc_keypair->adsc_priv_key->szc_used_size_bytes =
        adsp_ecc_keypair->adsc_params->adsc_prime->szc_used_size_bytes;

    // bitmasks as explained in RFC 7748
    if (adsp_ecc_keypair->adsc_params->iec_name==ied_X25519) {
        ((LNUM_WORD*)(adsp_ecc_keypair->adsc_priv_key->aucc_data))[ 0] &= X25519_PRIV_KEY_MASK_1;
        TOP_WORD(adsp_ecc_keypair->adsc_priv_key) &= X25519_PRIV_KEY_MASK_2;
        TOP_WORD(adsp_ecc_keypair->adsc_priv_key) |= X25519_PRIV_KEY_MASK_3;
    } else {
        ((LNUM_WORD*)(adsp_ecc_keypair->adsc_priv_key->aucc_data))[ 0] &= X448_PRIV_KEY_MASK_1;
        TOP_WORD(adsp_ecc_keypair->adsc_priv_key) |= X448_PRIV_KEY_MASK_2;
    }

    //generate public key = key * G
    return m_ecpt_montgo_scamult(adsp_ecc_keypair->adsc_pub_key->adsc_x,
                                 adsp_pool,
                                 adsp_ecc_keypair->adsc_priv_key,
                                 adsp_ecc_keypair->adsc_params->adsc_Gx,
                                 adsp_ecc_keypair->adsc_params);
} // ms_gen_static_keypair_montgomery

/**
   generates keypair for montgomery curve with a random private key

   @param[out]     dsd_ecc_keypair         keypair structure
   @param[out]     achp_public_key_out     buffer for public key
   @param[in,out]  aszp_pub_buffer_len     [in] allocated len of buffer [out] len of public key
   @param[in,out]  adsp_pool               pool
   @param[in]      szp_secret_len          len of private key and secret buffer
   @param[in]      szp_public_len          len of public key buffer
   @param[in]      amp_random              random function
   @param[in]      avop_userfld            userfield

   @return 0 on success, errorcode otherwise
 */
inline static ied_encry_return ms_gen_rand_keypair_montgomery(struct dsd_ecc_keypair *adsp_ecc_keypair,
                                                              struct dsd_mem_pool_ele *adsp_pool,
                                                              const size_t szp_secret_len,
                                                              int (* amp_random)(void* avop_userfld,
                                                                                 void* avop_dest,
                                                                                 size_t szp_size),
                                                              void* avop_userfld)
{
    // get chunk for random
    dsd_mem_pool_frame dsl_frame = m_mem_pool_get_frame(adsp_pool);
    char *achl_random = (char*)m_mem_pool_get_chunk(&adsp_pool, (int)szp_secret_len);
    if (!achl_random) {
        m_mem_pool_restore_frame(&adsp_pool, dsl_frame);
        return ied_encry_pool_empty;
    }

    // generate random to chunk
    if (amp_random(avop_userfld, achl_random, szp_secret_len) != 0) {
        m_mem_pool_restore_frame(&adsp_pool, dsl_frame);
        return ied_encry_rng_error;
    }

    // generate keypair with random
    ied_encry_return iel_ret = ms_gen_static_keypair_montgomery(adsp_ecc_keypair,
                                                                adsp_pool,
                                                                szp_secret_len,
                                                                achl_random);
    m_mem_pool_restore_frame(&adsp_pool, dsl_frame);
    return iel_ret;
} // ms_gen_rand_keypair_montgomery

/**
   generates keypair for weierstrass curve with a random private key

   @param[out]     dsd_ecc_keypair         keypair structure
   @param[out]     achp_public_key_out     buffer for public key
   @param[in,out]  aszp_pub_buffer_len     [in] allocated len of buffer [out] len of public key
   @param[in,out]  adsp_pool               pool
   @param[in]      szp_secret_len          len of private key and secret buffer
   @param[in]      szp_public_len          len of public key buffer
   @param[in]      amp_random              random function
   @param[in]      avop_userfld            userfield

   @return 0 on success, errorcode otherwise
 */
inline static ied_encry_return ms_gen_rand_keypair_weierstrass(struct dsd_ecc_keypair *adsp_ecc_keypair,
                                                               struct dsd_mem_pool_ele *adsp_pool,
                                                               int (* amp_random)(void* avop_userfld,
                                                                                  void* avop_dest,
                                                                                  size_t szp_size),
                                                               void* avop_userfld)
{
    // generate random private key
    ied_encry_return iel_ret = m_lnum_random_less_than(adsp_ecc_keypair->adsc_priv_key,
                                                       adsp_ecc_keypair->adsc_params->adsc_n,
                                                       amp_random,
                                                       avop_userfld);
    if (iel_ret != ied_encry_success) {
        return iel_ret;
    }

    //generate public key = key * G
    return m_ecpt_weier_scamult(adsp_ecc_keypair->adsc_pub_key,
                                adsp_pool,
                                adsp_ecc_keypair->adsc_priv_key,
                                adsp_ecc_keypair->adsc_params,
                                NULL,
                                NULL,
                                DEFAULT_WNAF_WIDTH);
} // ms_gen_rand_keypair_weierstrass

extern "C" ied_encry_return m_ecc_gen_rand_keypair(struct dsd_ecc_keypair *adsp_ecc_keypair,
                                                   char *achp_public_key_out,
                                                   size_t *aszp_pub_buffer_len,
                                                   struct dsd_mem_pool_ele *adsp_pool,
                                                   int (* amp_random)(void* avop_userfld,
                                                                      void* avop_dest,
                                                                      size_t szp_size),
                                                   void* avop_userfld)
{
    if (!adsp_ecc_keypair || !adsp_pool || !amp_random) {
        return ied_encry_null_pointer;
    }
    if (!adsp_ecc_keypair->adsc_params || !adsp_ecc_keypair->adsc_priv_key || !adsp_ecc_keypair->adsc_pub_key) {
        return ied_ecc_keypair_uninitialized;
    }

    // validate buffer size
    size_t szl_public_len = cszrg_ecdh_public_key_len[adsp_ecc_keypair->adsc_params->iec_name];
    size_t szl_secret_len = cszrg_ecdh_secret_len[adsp_ecc_keypair->adsc_params->iec_name];
    if (achp_public_key_out && aszp_pub_buffer_len) {
        if (*aszp_pub_buffer_len < szl_public_len) {
            return ied_encry_insufficient_buffer;
        }
    }
    ied_encry_return iel_ret;
    if (adsp_ecc_keypair->adsc_params->iec_type != ied_montgomery) { // weierstrass
        iel_ret = ms_gen_rand_keypair_weierstrass(adsp_ecc_keypair,
                                                  adsp_pool,
                                                  amp_random,
                                                  avop_userfld);
    } else { // montgomery
        iel_ret = ms_gen_rand_keypair_montgomery(adsp_ecc_keypair,
                                                 adsp_pool,
                                                 szl_secret_len,
                                                 amp_random,
                                                 avop_userfld);
    }
    if (iel_ret != ied_encry_success) {
        return iel_ret;
    }
    // copy public key to buffer
    if (achp_public_key_out && aszp_pub_buffer_len) {
        iel_ret = ms_export_public_key(achp_public_key_out, aszp_pub_buffer_len, adsp_ecc_keypair);
    }
    return iel_ret;
} // m_ecc_gen_rand_keypair

/**
   generates keypair for weierstrass curve with a given private key

   @param[out]     dsd_ecc_keypair         keypair structure
   @param[out]     achp_public_key_out     buffer for public key
   @param[in,out]  aszp_pub_buffer_len     [in] allocated len of buffer [out] len of public key
   @param[in,out]  adsp_pool               pool
   @param[in]      szp_secret_len          len of private key and secret buffer
   @param[in]      szp_public_len          len of public key buffer
   @param[in]      achp_private_key        given private key

   @return 0 on success, errorcode otherwise
 */
inline static ied_encry_return ms_gen_static_keypair_weierstrass(struct dsd_ecc_keypair *adsp_ecc_keypair,
                                                                 struct dsd_mem_pool_ele *adsp_pool,
                                                                 const size_t szp_secret_len,
                                                                 const char *achp_private_key)
{
    // copy private key buffer to structure
    m_lnum_load_bytes_be(adsp_ecc_keypair->adsc_priv_key, achp_private_key, (unsigned int)szp_secret_len); // can't fail if allocated with init function

    //generate public key = key * G
    return m_ecpt_weier_scamult(adsp_ecc_keypair->adsc_pub_key,
                                adsp_pool,
                                adsp_ecc_keypair->adsc_priv_key,
                                adsp_ecc_keypair->adsc_params,
                                NULL,
                                NULL,
                                DEFAULT_WNAF_WIDTH);
} // ms_gen_static_keypair_weierstrass

extern "C" ied_encry_return m_ecc_gen_static_keypair(struct dsd_ecc_keypair *adsp_ecc_keypair,
                                                     char *achp_public_key_out,
                                                     size_t *aszp_pub_buffer_len,
                                                     struct dsd_mem_pool_ele *adsp_pool,
                                                     const char *achp_private_key,
                                                     const size_t szp_priv_key_len)
{
    if (!adsp_ecc_keypair || !adsp_pool || !achp_private_key) {
        return ied_encry_null_pointer;
    }
    if (!adsp_ecc_keypair->adsc_params || !adsp_ecc_keypair->adsc_priv_key || !adsp_ecc_keypair->adsc_pub_key) {
        return ied_ecc_keypair_uninitialized;
    }

    // validate buffer size
    size_t szl_public_len = cszrg_ecdh_public_key_len[adsp_ecc_keypair->adsc_params->iec_name];
    size_t szl_secret_len = cszrg_ecdh_secret_len[adsp_ecc_keypair->adsc_params->iec_name];
    if (*aszp_pub_buffer_len < szl_public_len) {
        return ied_encry_insufficient_buffer;
    }
    if (szp_priv_key_len != szl_secret_len) {
        return ied_ecc_input_len_invalid;
    }

    // generate keypair
    ied_encry_return iel_ret;
    if (adsp_ecc_keypair->adsc_params->iec_type != ied_montgomery) { // weierstrass
        iel_ret = ms_gen_static_keypair_weierstrass(adsp_ecc_keypair,
                                                    adsp_pool,
                                                    szl_secret_len,
                                                    achp_private_key);
    } else { // montgomery
        iel_ret = ms_gen_static_keypair_montgomery(adsp_ecc_keypair,
                                                   adsp_pool,
                                                   szl_secret_len,
                                                   achp_private_key);
    }
    if (iel_ret != ied_encry_success) {
        return iel_ret;
    }
    // copy public key to buffer
    if (achp_public_key_out && aszp_pub_buffer_len) {
        iel_ret = ms_export_public_key(achp_public_key_out, aszp_pub_buffer_len, adsp_ecc_keypair);
    }
    return iel_ret;
} // m_ecc_gen_static_keypair

extern "C" ied_encry_return m_ecc_export_pub_key(char *achp_public_key_out,
                                                 size_t *aszp_pub_buffer_len,
                                                 struct dsd_ecc_keypair *adsp_ecc_keypair)
{
    if (!achp_public_key_out || !aszp_pub_buffer_len || !adsp_ecc_keypair) {
        return ied_encry_null_pointer;
    }
    if (!adsp_ecc_keypair->adsc_pub_key) {
        return ied_ecc_keypair_uninitialized;
    }
    // TODO: how to check if key is already generated? if public key contains trash, store bytes could make problems. set to zero during allocation?

    return ms_export_public_key(achp_public_key_out, aszp_pub_buffer_len, adsp_ecc_keypair);  
}

/**
   generates ECDH secret for montgomery curve using private key in keypair and given peers key

   @param[out]     dsd_ecc_keypair         keypair structure
   @param[out]     achp_secret_out         buffer for shared secret
   @param[in,out]  aszp_secret_len         [in] allocated len of buffer [out] len of secret
   @param[in,out]  adsp_pool               pool
   @param[in]      achp_public_key         peers public key buffer

   @return 0 on success, errorcode otherwise
 */
inline static ied_encry_return ms_gen_secret_montgomery(struct dsd_ecc_keypair *adsp_ecc_keypair,
                                                        char *achp_secret_out,
                                                        size_t *aszp_secret_len,
                                                        struct dsd_mem_pool_ele *adsp_pool,
                                                        const char *achp_public_key)
{
    // tmp from pool
    dsd_mem_pool_frame dsl_frame = m_mem_pool_get_frame(adsp_pool);
    dsd_lnum *adsl_tmp = m_mem_pool_get_lnum_byte_size(
        &adsp_pool,
        adsp_ecc_keypair->adsc_params->adsc_prime->szc_used_size_bytes + sizeof(LNUM_WORD));
    if (!adsl_tmp) {
        m_mem_pool_restore_frame(&adsp_pool, dsl_frame);
        return ied_encry_pool_empty;
    }

    // load public key from buffer to lnum
    m_lnum_load_bytes_le(
        adsl_tmp,
        achp_public_key + 1,
        (unsigned int)cszrg_ecdh_secret_len[adsp_ecc_keypair->adsc_params->iec_name]);
    // must have full (prime) size
    ms_lnum_zero_fill(adsl_tmp, adsp_ecc_keypair->adsc_params->adsc_prime->szc_used_size_bytes);
    adsl_tmp->szc_used_size_bytes = adsp_ecc_keypair->adsc_params->adsc_prime->szc_used_size_bytes;

    // bitmask (RFC 7748)
    if (adsp_ecc_keypair->adsc_params->iec_name==ied_X25519) {
        TOP_WORD(adsl_tmp) &= X25519_PUB_KEY_MASK;
    }

    // modulo (RFC 7748)
    if (m_lnum_compare_absolute(adsl_tmp, adsp_ecc_keypair->adsc_params->adsc_prime) == ied_larger) {
        // TODO: find test case
        m_lnum_sub(adsl_tmp, adsl_tmp, adsp_ecc_keypair->adsc_params->adsc_prime); // won't fail
    }

    // generate secret
    ied_encry_return iel_ret = m_ecpt_montgo_scamult(adsl_tmp,
                                                     adsp_pool,
                                                     adsp_ecc_keypair->adsc_priv_key,
                                                     adsl_tmp,
                                                     adsp_ecc_keypair->adsc_params);
    if (iel_ret != ied_encry_success) {
        m_mem_pool_restore_frame(&adsp_pool, dsl_frame);
        return iel_ret;
    }

    // copy secret to output buffer
    size_t szl_len = cszrg_ecdh_secret_len[adsp_ecc_keypair->adsc_params->iec_name];
    iel_ret = m_lnum_store_bytes_le(achp_secret_out, &szl_len, adsl_tmp, TRUE);
    if (iel_ret != ied_encry_success) {
        m_mem_pool_restore_frame(&adsp_pool, dsl_frame);
        return iel_ret;
    }
    *aszp_secret_len = szl_len;

    // secret must not be zero
    if (m_lnum_is_zero(adsl_tmp)) {
        iel_ret = ied_ecc_secret_zero;
    }

    m_mem_pool_restore_frame(&adsp_pool, dsl_frame);
    return iel_ret;
} // ms_gen_secret_montgomery

/**
   generates ECDH secret for weierstrass curve using private key in keypair and given peers key

   @param[out]     dsd_ecc_keypair         keypair structure
   @param[out]     achp_secret_out         buffer for shared secret
   @param[in,out]  aszp_secret_len         [in] allocated len of buffer [out] len of secret
   @param[in,out]  adsp_pool               pool
   @param[in]      achp_public_key         peers public key buffer

   @return 0 on success, errorcode otherwise
 */
inline static ied_encry_return ms_gen_secret_weierstrass(struct dsd_ecc_keypair *adsp_ecc_keypair,
                                                         char *achp_secret_out,
                                                         size_t *aszp_secret_len,
                                                         struct dsd_mem_pool_ele *adsp_pool,
                                                         const char *achp_public_key)
{
    // get result and peers public key ec point from pool
    dsd_ec_point dsl_result = {0};
    dsd_ec_point dsl_peers_key = {0};
    dsd_mem_pool_frame dsl_frame = m_mem_pool_get_frame(adsp_pool);
    dsl_result.adsc_x = m_mem_pool_get_lnum_same_size(&adsp_pool, adsp_ecc_keypair->adsc_params->adsc_prime);
    dsl_result.adsc_y = m_mem_pool_get_lnum_same_size(&adsp_pool, adsp_ecc_keypair->adsc_params->adsc_prime);
    dsl_result.adsc_z = m_mem_pool_get_lnum_same_size(&adsp_pool, adsp_ecc_keypair->adsc_params->adsc_prime);
    dsl_peers_key.adsc_x = m_mem_pool_get_lnum_same_size(&adsp_pool, adsp_ecc_keypair->adsc_params->adsc_prime);
    dsl_peers_key.adsc_y = m_mem_pool_get_lnum_same_size(&adsp_pool, adsp_ecc_keypair->adsc_params->adsc_prime);
    // same size, enough to check last one.
    if (!dsl_peers_key.adsc_y) {
        m_mem_pool_restore_frame(&adsp_pool, dsl_frame);
        return ied_encry_pool_empty;
    }

    // load peers key
    ied_encry_return iel_ret = m_lnum_load_bytes_be(
        dsl_peers_key.adsc_x,
        achp_public_key + 1,
        (unsigned int)cszrg_ecdh_secret_len[adsp_ecc_keypair->adsc_params->iec_name]);
    if (iel_ret != ied_encry_success) {
        m_mem_pool_restore_frame(&adsp_pool, dsl_frame);
        return iel_ret;
    }
    iel_ret =  m_lnum_load_bytes_be(dsl_peers_key.adsc_y,
                                    achp_public_key + 1 + cszrg_ecdh_secret_len[adsp_ecc_keypair->adsc_params->iec_name],
                                    (unsigned int)cszrg_ecdh_secret_len[adsp_ecc_keypair->adsc_params->iec_name]);
    if (iel_ret != ied_encry_success) {
        m_mem_pool_restore_frame(&adsp_pool, dsl_frame);
        return iel_ret;
    }
    dsl_peers_key.iec_representation = ied_affine;

    // check if point is on curve
    iel_ret = m_ecpt_weier_on_curve(&dsl_peers_key, adsp_pool, adsp_ecc_keypair->adsc_params);
    if (iel_ret != ied_encry_success) {
        m_mem_pool_restore_frame(&adsp_pool, dsl_frame);
        //pass upwards both critical errors (ied_ecc_point_not_on_curve) and internal errors
        return iel_ret;
    }

    // ECDH scalar multiplication key*public_peer (generate secret)
    // TODO: neutral element??? not possible because n prime? is n prime for brainpool curves?
    iel_ret = m_ecpt_weier_scamult(&dsl_result,
                                   adsp_pool,
                                   adsp_ecc_keypair->adsc_priv_key,
                                   adsp_ecc_keypair->adsc_params,
                                   dsl_peers_key.adsc_x,
                                   dsl_peers_key.adsc_y,
                                   DEFAULT_WNAF_WIDTH);
    if (iel_ret != ied_encry_success) {
        m_mem_pool_restore_frame(&adsp_pool, dsl_frame);
        return iel_ret;
    }
    if (dsl_result.iec_representation == ied_neutral) {
        m_mem_pool_restore_frame(&adsp_pool, dsl_frame);
        return ied_encry_miscellaneous;
    }

    // copy secret to output buffer
    // buffer is big enought, checked before calling this function
    size_t szl_len = cszrg_ecdh_secret_len[adsp_ecc_keypair->adsc_params->iec_name];

    m_lnum_store_bytes_be(achp_secret_out, &szl_len, dsl_result.adsc_x, TRUE); // won't fail if scamult contains no error
    *aszp_secret_len = szl_len;

    m_mem_pool_restore_frame(&adsp_pool, dsl_frame);
    return iel_ret;
} // ms_gen_secret_weierstrass

extern "C" ied_encry_return m_ecc_gen_secret(char *achp_secret_out,
                                             size_t *aszp_secret_len,
                                             struct dsd_ecc_keypair *adsp_ecc_keypair,
                                             struct dsd_mem_pool_ele *adsp_pool,
                                             const char *achp_public_key,
                                             const size_t szp_len_pub_key)
{
    if (!achp_secret_out || !aszp_secret_len || !adsp_ecc_keypair || !adsp_pool || !achp_public_key) {
        return ied_encry_null_pointer;
    }
    if (!adsp_ecc_keypair->adsc_params || !adsp_ecc_keypair->adsc_priv_key) {
        return ied_ecc_keypair_uninitialized;
    }

    // validate inputlength and output buffer length
    size_t szl_expected_input_len = cszrg_ecdh_public_key_len[adsp_ecc_keypair->adsc_params->iec_name];
    size_t szl_expected_buffer_len = cszrg_ecdh_secret_len[adsp_ecc_keypair->adsc_params->iec_name];
    if (szp_len_pub_key != szl_expected_input_len) {
        return ied_ecc_input_len_invalid;
    }
    if (*aszp_secret_len < szl_expected_buffer_len) {
        return ied_encry_insufficient_buffer;
    }

    // load public key of peer from buffer to ecdh context
    if (achp_public_key[0] != chg_uncompressed_format) {
        return ied_ecc_point_format_error;
    }

    if (adsp_ecc_keypair->adsc_params->iec_type == ied_montgomery) {
        return ms_gen_secret_montgomery(adsp_ecc_keypair, achp_secret_out, aszp_secret_len, adsp_pool, achp_public_key);
    } else {
        return ms_gen_secret_weierstrass(adsp_ecc_keypair, achp_secret_out, aszp_secret_len, adsp_pool, achp_public_key);
    }
} // m_ecc_gen_secret

/**
   This function computes the ECDSA signature r and s.

   @param[out]     adsp_r_out              lnum for r out
   @param[out]     adsp_s_out              lnum for s out
   @param[in,out]  adsp_pool               lnum pool
   @param[in]      adsp_ecpnt_tmp          ec pnt tmpt
   @param[in]      adsp_k                  tmp k
   @param[in]      adsp_z                  tmp z
   @param[in]      adsp_small_tmp_1        small tmp 1
   @param[in]      adsp_small_tmp_2        small tmp 2
   @param[in]      adsp_big_tmp            big tmp
   @param[in]      adsp_ecc_keypair        keypair
   @param[in]      amp_random              random buffer generator
   @param[in]      avop_userfld            userfield (optional)

   @return 0 on success, errorcode otherwise
 */
inline static ied_encry_return ms_ecdsa_compute_signature(struct dsd_lnum *adsp_r_out,
                                                          struct dsd_lnum *adsp_s_out,
                                                          struct dsd_mem_pool_ele *adsp_pool,
                                                          dsd_ec_point *adsp_ecpnt_tmp,
                                                          dsd_lnum *adsp_k,
                                                          dsd_lnum *adsp_z,
                                                          dsd_lnum *adsp_small_tmp_1,
                                                          dsd_lnum *adsp_small_tmp_2,
                                                          dsd_lnum *adsp_big_tmp,
                                                          struct dsd_ecc_keypair *adsp_ecc_keypair,
                                                          int (* amp_random)(void* avop_userfld,
                                                                             void* avop_dest,
                                                                             size_t szp_size),
                                                          void* avop_userfld)
{
    // generate random
    ied_encry_return iel_ret = m_lnum_random_less_than(adsp_k,
                                                       adsp_ecc_keypair->adsc_params->adsc_n,
                                                       amp_random,
                                                       avop_userfld);
    if (iel_ret != ied_encry_success) {
        return iel_ret;
    }

    // compute r
    iel_ret = m_ecpt_weier_scamult(adsp_ecpnt_tmp,
                                   adsp_pool,
                                   adsp_k,
                                   adsp_ecc_keypair->adsc_params,
                                   NULL,
                                   NULL,
                                   DEFAULT_WNAF_WIDTH);
    if (iel_ret != ied_encry_success) {
        return iel_ret;
    }
    // TODO: check this
    if (adsp_ecpnt_tmp->iec_representation == ied_neutral) {
        return ied_encry_miscellaneous;
    }
    iel_ret = m_lnum_divide(NULL, adsp_r_out, adsp_pool, adsp_ecpnt_tmp->adsc_x, adsp_ecc_keypair->adsc_params->adsc_n);
    if (iel_ret != ied_encry_success) {
        return iel_ret;
    }

    // if r is zero, start again
    if (m_lnum_is_zero(adsp_r_out)) {
        // TODO: find test case
        return ied_ecc_ecdsa_again;
    }

    // compute s
    // TODO: reduce error checking, maybe use impls?
    iel_ret = m_lnum_mult(adsp_big_tmp, adsp_pool, adsp_r_out, adsp_ecc_keypair->adsc_priv_key);
    if (iel_ret != ied_encry_success) return iel_ret;
    iel_ret = m_lnum_add(adsp_big_tmp, adsp_big_tmp, adsp_z);
    if (iel_ret != ied_encry_success) return iel_ret;
    iel_ret = m_lnum_inverse(adsp_small_tmp_1, adsp_pool, adsp_k, adsp_ecc_keypair->adsc_params->adsc_n);
    if (iel_ret != ied_encry_success) return iel_ret;
    iel_ret = m_lnum_divide(NULL, adsp_small_tmp_2, adsp_pool, adsp_big_tmp, adsp_ecc_keypair->adsc_params->adsc_n);
    if (iel_ret != ied_encry_success) return iel_ret;
    iel_ret = m_lnum_mult(adsp_big_tmp, adsp_pool, adsp_small_tmp_1, adsp_small_tmp_2);
    if (iel_ret != ied_encry_success) return iel_ret;
    iel_ret = m_lnum_divide(NULL, adsp_s_out, adsp_pool, adsp_big_tmp, adsp_ecc_keypair->adsc_params->adsc_n);
    if (iel_ret != ied_encry_success) return iel_ret;

    // if s is 0, start again.
    if (m_lnum_is_zero(adsp_s_out)) {
        // TODO: find test case
        return ied_ecc_ecdsa_again;
    }

    return ied_encry_success;
} // ms_ecdsa_compute_signature
/**
   Loads the first k bits of a hash buffer into z where k is the bitsize of n.
   If hash size is smaller, complete hash is loaded.

   @param[out]     adsp_z              lnum where hash should be loaded to
   @param[in]      achp_hash_buffer        hash buffer
   @param[in]      inp_hash_len            hash length
   @param[in]      adsp_n                  n
 */
inline static void ms_hash_to_lnum(dsd_lnum *adsp_z,
                                   const char *achp_hash_buffer,
                                   const size_t szp_hash_len,
                                   const dsd_lnum *adsp_n)
{
    size_t szl_bytes_n = (size_t)m_lnum_get_byte_count(adsp_n);
    size_t szl_bits_n = (size_t)m_lnum_get_bit_count(adsp_n);
    // hash to lnum
    // fill z
    m_lnum_load_bytes_be(adsp_z, achp_hash_buffer, min(szl_bytes_n, szp_hash_len)); // won't fail

    // if needed, shift z
    if (szl_bytes_n <= szp_hash_len) {
        size_t szl_shift_bits = 8 * szl_bytes_n - szl_bits_n;
        if (szl_shift_bits > 0) {
            m_lnum_rshift(adsp_z, adsp_z, szl_shift_bits); // won't fail
        }
    }
}

extern "C" ied_encry_return m_ecc_gen_signature(struct dsd_lnum *adsp_r_out,
                                                struct dsd_lnum *adsp_s_out,
                                                struct dsd_mem_pool_ele *adsp_pool,
                                                char *achp_hash_buffer,
                                                size_t szp_hash_len,
                                                struct dsd_ecc_keypair *adsp_ecc_keypair,
                                                int (* amp_random)(void* avop_userfld,
                                                                   void* avop_dest,
                                                                   size_t szp_size),
                                                void* avop_userfld)
{
    if (!adsp_r_out || !adsp_s_out || !adsp_pool || !achp_hash_buffer || !adsp_ecc_keypair || !amp_random) {
        return ied_encry_null_pointer;
    }
    // TODO: this ensures allocation, not that keys are set... how to check? set to 0 after alloc?
    if (!adsp_ecc_keypair->adsc_params || !adsp_ecc_keypair->adsc_priv_key || !adsp_ecc_keypair->adsc_pub_key) {
        return ied_ecc_keypair_uninitialized;
    }
    // check alloc size of r and s
    if ((adsp_r_out->szc_alloc_size_bytes < adsp_ecc_keypair->adsc_params->adsc_n->szc_used_size_bytes)
        || (adsp_s_out->szc_alloc_size_bytes < adsp_ecc_keypair->adsc_params->adsc_n->szc_used_size_bytes))
    {
        return ied_encry_insufficient_buffer;
    }

    // stack frame
    dsd_mem_pool_frame dsl_frame = m_mem_pool_get_frame(adsp_pool);

    // get z from pool
    // get k from pool
    dsd_lnum *adsl_z = m_mem_pool_get_lnum_same_size(&adsp_pool, adsp_ecc_keypair->adsc_params->adsc_n);
    dsd_lnum *adsl_k = m_mem_pool_get_lnum_same_size(&adsp_pool, adsp_ecc_keypair->adsc_params->adsc_n);
    dsd_lnum *adsl_tmp_small_1 = m_mem_pool_get_lnum_byte_size(
        &adsp_pool,
        adsp_ecc_keypair->adsc_params->adsc_n->szc_used_size_bytes + 2 * sizeof(LNUM_WORD));
    dsd_lnum *adsl_tmp_small_2 = m_mem_pool_get_lnum_byte_size(
        &adsp_pool,
        adsp_ecc_keypair->adsc_params->adsc_n->szc_used_size_bytes + 2 * sizeof(LNUM_WORD));
    dsd_ec_point dsl_ec_pnt_tmp = {0};
    dsl_ec_pnt_tmp.adsc_x = m_mem_pool_get_lnum_same_size(&adsp_pool, adsp_ecc_keypair->adsc_params->adsc_prime);
    dsl_ec_pnt_tmp.adsc_y = m_mem_pool_get_lnum_same_size(&adsp_pool, adsp_ecc_keypair->adsc_params->adsc_prime);
    dsl_ec_pnt_tmp.adsc_z = m_mem_pool_get_lnum_same_size(&adsp_pool, adsp_ecc_keypair->adsc_params->adsc_prime);
    dsd_lnum *adsl_tmp_big = m_mem_pool_get_lnum_byte_size(
        &adsp_pool,
        adsp_ecc_keypair->adsc_params->adsc_prime->szc_used_size_bytes + adsp_ecc_keypair->adsc_params->adsc_n->szc_used_size_bytes + 2 * sizeof(LNUM_WORD));
    // z and k have same size, small tmps 1 and 2 have same size, and x,y, and z have same size
    if (!adsl_k || !adsl_tmp_small_2 || !dsl_ec_pnt_tmp.adsc_z || !adsl_tmp_big) {
        m_mem_pool_restore_frame(&adsp_pool, dsl_frame);
        return ied_encry_pool_empty;
    }

    // load hash into z
    ms_hash_to_lnum(adsl_z, achp_hash_buffer, szp_hash_len, adsp_ecc_keypair->adsc_params->adsc_n);

    ied_encry_return iel_ret;
    // create signature
    do {
        iel_ret = ms_ecdsa_compute_signature(adsp_r_out,
                                             adsp_s_out,
                                             adsp_pool,
                                             &dsl_ec_pnt_tmp,
                                             adsl_k,
                                             adsl_z,
                                             adsl_tmp_small_1,
                                             adsl_tmp_small_2,
                                             adsl_tmp_big,
                                             adsp_ecc_keypair,
                                             amp_random,
                                             avop_userfld);
    } while(iel_ret == ied_ecc_ecdsa_again);

    m_mem_pool_restore_frame(&adsp_pool, dsl_frame);
    return iel_ret;
} // m_ecc_gen_signature

/**
   Computations to verify an ECDSA signature.

   @param[in,out]  adsp_pool               lnum pool
   @param[in]      adsp_ec_tmp             ec point tmp
   @param[in]      adsp_z                  tmp z
   @param[in]      adsp_w                  tmp w
   @param[in]      adsp_u1                 tmp u1
   @param[in]      adsp_u2                 tmp u2
   @param[in]      adsp_public_key         public key of signer
   @param[in]      adsp_r                  r
   @param[in]      adsp_s                  s
   @param[in]      adsp_curve              curve parameters

   @return 0 on success, errorcode otherwise
 */
inline static ied_encry_return ms_validate_signature(dsd_mem_pool_ele *adsp_pool,
                                                     dsd_ec_point *adsp_ec_tmp,
                                                     dsd_lnum *adsp_z,
                                                     dsd_lnum *adsp_w,
                                                     dsd_lnum *adsp_u1,
                                                     dsd_lnum *adsp_u2,
                                                     const dsd_ec_point *adsp_public_key,
                                                     const dsd_lnum *adsp_r,
                                                     const dsd_lnum *adsp_s,
                                                     const dsd_ec_curve_params *adsp_curve)
{

    // check if r,s in [1,n-1]
    if ((m_lnum_compare_signed(adsp_r, adsp_curve->adsc_n) != ied_smaller)
        || (m_lnum_compare_signed(adsp_s, adsp_curve->adsc_n) != ied_smaller)
        || (adsp_r->boc_is_negative) || (adsp_s->boc_is_negative)
        || (adsp_r->szc_used_size_bytes == 0)
        || (adsp_s->szc_used_size_bytes == 0))
    {
        return ied_ecc_signature_invalid;
    }

    // computations
    ied_encry_return iel_ret = m_lnum_inverse(adsp_w, adsp_pool, adsp_s, adsp_curve->adsc_n);
    if (iel_ret != ied_encry_success) return iel_ret;
    iel_ret = m_lnum_mult(adsp_u1, adsp_pool, adsp_z, adsp_w);
    if (iel_ret != ied_encry_success) return iel_ret;
    iel_ret = m_lnum_divide(NULL, adsp_u1, adsp_pool, adsp_u1, adsp_curve->adsc_n);
    if (iel_ret != ied_encry_success) return iel_ret;
    iel_ret = m_lnum_mult(adsp_u2, adsp_pool, adsp_r, adsp_w);
    if (iel_ret != ied_encry_success) return iel_ret;
    iel_ret = m_lnum_divide(NULL, adsp_u2, adsp_pool, adsp_u2, adsp_curve->adsc_n);
    if (iel_ret != ied_encry_success) return iel_ret;

    iel_ret = m_ecpt_weier_dblscamult(adsp_ec_tmp,
                                     adsp_pool,
                                     adsp_u2,
                                     adsp_public_key,
                                     adsp_u1,
                                     adsp_curve,
                                     DEFAULT_WNAF_WIDTH);
    if (iel_ret != ied_encry_success) {
        return iel_ret;
    }

    // x can only be compared if point is affine, so neutral element is not a valid result
    if (adsp_ec_tmp->iec_representation == ied_neutral) {
        return ied_ecc_signature_invalid;
    }

    // x mod n
    iel_ret = m_lnum_divide(NULL, adsp_ec_tmp->adsc_x, adsp_pool, adsp_ec_tmp->adsc_x, adsp_curve->adsc_n);
    if (iel_ret != ied_encry_success) return iel_ret;

    // if r=x mod n, signature is valid, invalid otherwise.
    if (m_lnum_compare_signed(adsp_r, adsp_ec_tmp->adsc_x) == ied_equal) {
        return ied_encry_success;
    } else {
        return ied_ecc_signature_invalid; // no null pointer given so if not equal, it's greater or smaller hence invalid signature
    }
} // ms_validate_signature

extern "C" ied_encry_return m_ecc_verify_sig(struct dsd_mem_pool_ele *adsp_pool,
                                             char *achp_hash_buffer,
                                             size_t szp_hash_len,
                                             struct dsd_ec_point *adsp_public_key,
                                             struct dsd_lnum *adsp_r,
                                             struct dsd_lnum *adsp_s,
                                             const struct dsd_ec_curve_params *adsp_curve)
{
    if (!adsp_pool || !achp_hash_buffer || !adsp_public_key || !adsp_r || !adsp_s || !adsp_curve) {
        return ied_encry_null_pointer;
    }
    // Q can't be neutral element in affine representation
    // check if Q is valid
    if (adsp_public_key->iec_representation != ied_affine) {
        return ied_encry_invalid_input;
    }

    // check if Q is on curve
    ied_encry_return iel_ret = m_ecpt_weier_on_curve(adsp_public_key, adsp_pool, adsp_curve);
    if (iel_ret != ied_encry_success) {
        return iel_ret;
    }

    // stack frame
    dsd_mem_pool_frame dsl_frame = m_mem_pool_get_frame(adsp_pool);

    // get temporary result ec point and tmp lnums from pool
    dsd_ec_point dsl_ec_tmp = {0};
    dsl_ec_tmp.adsc_x = m_mem_pool_get_lnum_same_size(&adsp_pool, adsp_curve->adsc_prime);
    dsl_ec_tmp.adsc_y = m_mem_pool_get_lnum_same_size(&adsp_pool, adsp_curve->adsc_prime);
    dsl_ec_tmp.adsc_z = m_mem_pool_get_lnum_same_size(&adsp_pool, adsp_curve->adsc_prime);
    dsd_lnum *adsl_z = m_mem_pool_get_lnum_same_size(&adsp_pool, adsp_curve->adsc_n);
    dsd_lnum *adsl_w = m_mem_pool_get_lnum_byte_size(&adsp_pool, adsp_curve->adsc_n->szc_used_size_bytes + 2 * sizeof(LNUM_WORD));
    dsd_lnum *adsl_u1 = m_mem_pool_get_lnum_byte_size(&adsp_pool, 2* adsp_curve->adsc_n->szc_used_size_bytes);
    dsd_lnum *adsl_u2 = m_mem_pool_get_lnum_byte_size(&adsp_pool, 2* adsp_curve->adsc_n->szc_used_size_bytes);
    // same size, enough to check last one
    if (!dsl_ec_tmp.adsc_z || !adsl_z || !adsl_w || !adsl_u2) {
        m_mem_pool_restore_frame(&adsp_pool, dsl_frame);
        return ied_encry_pool_empty;
    }

    // if cofactor not one, check if n*Q == 0
    if (adsp_curve->iec_type == ied_weierstr_cofactor_non_one) {
        iel_ret = m_ecpt_weier_scamult(&dsl_ec_tmp,
                                       adsp_pool,
                                       adsp_curve->adsc_n,
                                       adsp_curve,
                                       adsp_public_key->adsc_x,
                                       adsp_public_key->adsc_y,
                                       DEFAULT_WNAF_WIDTH);
        if (iel_ret != ied_encry_success) {
            m_mem_pool_restore_frame(&adsp_pool, dsl_frame);
            return iel_ret;
        }
        if (dsl_ec_tmp.iec_representation != ied_neutral) {
            // TODO: find a test case for this...
            m_mem_pool_restore_frame(&adsp_pool, dsl_frame);
            return ied_ecc_public_key_invalid;
        }
    }

    ms_hash_to_lnum(adsl_z, achp_hash_buffer, szp_hash_len, adsp_curve->adsc_n);

    // check signature
    iel_ret = ms_validate_signature(adsp_pool,
                                    &dsl_ec_tmp,
                                    adsl_z,
                                    adsl_w,
                                    adsl_u1,
                                    adsl_u2,
                                    adsp_public_key,
                                    adsp_r,
                                    adsp_s,
                                    adsp_curve);

    // restore frame
    m_mem_pool_restore_frame(&adsp_pool, dsl_frame);
    return iel_ret;
} // m_ecc_verify_sig


extern "C" void m_ecc_free_keypair(struct dsd_memory *adsp_memory,
                                   struct dsd_ecc_keypair *adsp_ecc_keypair)
{
    if (!adsp_ecc_keypair || !adsp_ecc_keypair->adsc_priv_key || !adsp_memory) {
        return;
    }
    //private key is the first member in the allocation block (see m_ecc_init_keypair)
    adsp_memory->amc_free(adsp_memory, adsp_ecc_keypair->adsc_priv_key);
    adsp_ecc_keypair->adsc_priv_key = NULL;
    adsp_ecc_keypair->adsc_pub_key = NULL;
}

//------------------------------------------------------------------------------
// Start of original file ./xs-lnum-impl.cpp
//------------------------------------------------------------------------------

#include <stdlib.h>
#include <string.h>

#ifdef _WIN32
#include <Windows.h>
#else
#include "hob-unix01.h"
#ifndef HL_UNIX
#define HL_UNIX

#if (defined __APPLE__) && (defined __MACH__)
#define HL_LINUX
#define HL_MACOS
#endif

#endif // !HL_UNIX
#endif
#include "hob-xslhcla1.hpp"

#include "hob-encry-2.h"
#include "hob-encry-intern-2.h"

#ifndef HL_LNUM_ASM
// Only compile this if there is no Assembler implementation!
#include <string.h>

#ifndef max
#define max(a,b)            (((a) > (b)) ? (a) : (b))
#endif
#ifndef min
#define min(a,b)            (((a) < (b)) ? (a) : (b))
#endif

static void ms_impl_mont_mul_add_8(unsigned int* aunp_dest,
                                   unsigned int unp_n_0_inv,
                                   const unsigned int* aunp_mod,
                                   size_t szp_mod_len,
                                   const unsigned int* aunp_src);

#ifdef _WIN32

size_t m_impl_add(unsigned char* abyp_dest,
                  const unsigned char* abyp_a,
                  size_t szp_a_len,
                  const unsigned char* abyp_b,
                  size_t szp_b_len)
{
    unsigned int unl_index = 0;
    unsigned long long ull_sum = 0;
    if(szp_b_len > szp_a_len) {
        // Set a to be the longer number
        unsigned int unl_tmp = szp_a_len;
        szp_a_len = szp_b_len;
        szp_b_len = unl_tmp;
        const unsigned char* aurl_tmp = abyp_a;
        abyp_a = abyp_b;
        abyp_b = aurl_tmp;
    }

    // Add up both numbers with propagating carry
    while(unl_index < szp_b_len / sizeof(unsigned int)) {
        ull_sum += (unsigned long long)((unsigned int*)abyp_a)[unl_index] + (unsigned long long)((unsigned int*)abyp_b)[unl_index];
        ((unsigned int*)abyp_dest)[unl_index] = (unsigned int)ull_sum;
        ull_sum >>= sizeof(unsigned int) * 8;
        unl_index++;
    }

    // Propagate carry through the rest of a
    while (unl_index < szp_a_len / sizeof(unsigned int)) {
        ull_sum += (unsigned long long)((unsigned int*)abyp_a)[unl_index];
        ((unsigned int*)abyp_dest)[unl_index] = (unsigned int)ull_sum;
        ull_sum >>= sizeof(unsigned int) * 8;
        unl_index++;
    }

    // ull_sum will now hold the carry out
    ((unsigned int*)abyp_dest)[unl_index] = (unsigned int)ull_sum;

    return (unl_index + (unsigned int)ull_sum) * sizeof(unsigned int);
} // m_impl_add

size_t m_impl_sub(unsigned char* abyp_dest,
                  const unsigned char* abyp_a,
                  size_t szp_a_len,
                  const unsigned char* abyp_b,
                  size_t szp_b_len)
{
    unsigned int unl_index = 0;
    unsigned long long ull_diff = 0;
    while (unl_index < szp_b_len / sizeof(unsigned int)) {
        ull_diff += (unsigned long long)((unsigned int*)abyp_a)[unl_index] - (unsigned long long)((unsigned int*)abyp_b)[unl_index];
        ((unsigned int*)abyp_dest)[unl_index] = (unsigned int)ull_diff;
        ull_diff = (ull_diff & 0xffffffff00000000) | (ull_diff >> sizeof(unsigned int)*8);
        unl_index++;
    }
    while( unl_index < szp_a_len / sizeof(unsigned int)) {
        ull_diff += (unsigned long long)((unsigned int*)abyp_a)[unl_index];
        ((unsigned int*)abyp_dest)[unl_index] = (unsigned int)ull_diff;
        ull_diff = (ull_diff & 0xffffffff00000000) | (ull_diff >> sizeof(unsigned int)*8);
        unl_index++;
    }
    while ((unl_index > 0) && (((unsigned int*)abyp_dest)[unl_index-1] == (unsigned int)0)) {
        unl_index--;
    }
    return unl_index * sizeof(unsigned int);
} // m_impl_sub

#else

// GCC is doing a better job at optimizing this, than the implementation above

size_t m_impl_add(unsigned char* abyp_dest,
                  const unsigned char* abyp_a,
                  size_t szp_a_len,
                  const unsigned char* abyp_b,
                  size_t szp_b_len)
{
    unsigned int url_carry = 0;
    unsigned int unl_index = 0;
    for (; unl_index < min(szp_a_len,szp_b_len) / sizeof(unsigned int); unl_index++) {
        unsigned int url_a = ((unsigned int*)abyp_a)[unl_index];
        unsigned int url_b = ((unsigned int*)abyp_b)[unl_index];
        if (url_carry) {
            ((unsigned int*)abyp_dest)[unl_index] = url_a + url_b + 1;
            url_carry = (((unsigned int*)abyp_dest)[unl_index] <= url_a);
        } else {
            ((unsigned int*)abyp_dest)[unl_index] = url_a + url_b;
            url_carry = (((unsigned int*)abyp_dest)[unl_index] < url_a);
        }
    }
    if (szp_a_len > szp_b_len) {
        for (; unl_index < szp_a_len / sizeof(unsigned int); unl_index++) {
            ((unsigned int*)abyp_dest)[unl_index] = ((unsigned int*)abyp_a)[unl_index] + url_carry;
            if (((unsigned int*)abyp_dest)[unl_index] != 0) {
                url_carry = 0;
            }
        }
    }
    if (szp_a_len < szp_b_len) {
        for (; unl_index < szp_b_len / sizeof(unsigned int); unl_index++) {
            ((unsigned int*)abyp_dest)[unl_index] = ((unsigned int*)abyp_b)[unl_index] + url_carry;
            if (((unsigned int*)abyp_dest)[unl_index] != 0) {
                url_carry = 0;
            }
        }
    }
    if (url_carry) {
        ((unsigned int*)abyp_dest)[unl_index] = (LNUM_WORD)1;
    }
    return (unl_index + url_carry) * sizeof(unsigned int);
} // m_impl_add

size_t m_impl_sub(unsigned char* abyp_dest,
                  const unsigned char* abyp_a,
                  size_t szp_a_len,
                  const unsigned char* abyp_b,
                  size_t szp_b_len)
{
    unsigned int url_borrow = 0;
    unsigned int unl_index = 0;
    //Assumes szp_a_len >= szp_b_len
    for (; unl_index < min(szp_a_len,szp_b_len) / sizeof(unsigned int); unl_index++) {
        unsigned int url_a = ((unsigned int*)abyp_a)[unl_index];
        unsigned int url_b = ((unsigned int*)abyp_b)[unl_index];
        if (url_borrow) {
            url_borrow = (url_a <= url_b);
            ((unsigned int*)abyp_dest)[unl_index] = (url_a - url_b - 1);
        } else {
            url_borrow = (url_a < url_b);
            ((unsigned int*)abyp_dest)[unl_index] = (url_a - url_b);
        }
    }
    if (szp_a_len > szp_b_len) {
        for (; unl_index < szp_a_len / sizeof(unsigned int); unl_index++) {
            if (url_borrow) {
                url_borrow = (((unsigned int*)abyp_a)[unl_index] == 0);
                ((unsigned int*)abyp_dest)[unl_index] = ((unsigned int*)abyp_a)[unl_index] - 1;
            } else {
                ((unsigned int*)abyp_dest)[unl_index] = ((unsigned int*)abyp_a)[unl_index];
            }
        }
    }
    while ((unl_index > 0) && (((unsigned int*)abyp_dest)[unl_index-1] == (LNUM_WORD)0)) {
        unl_index--;
    }
    return unl_index * sizeof(unsigned int);
} // m_impl_sub

#endif

int m_impl_add_karatsuba(unsigned char* abyp_dest,
                         const unsigned char* abyp_a,
                         const unsigned char* abyp_b,
                         size_t szp_len)
{
    unsigned int url_carry = 0;
    unsigned int unl_index = 0;
    for (; unl_index < szp_len / sizeof(unsigned int); unl_index++) {
        unsigned int url_a = ((unsigned int*)abyp_a)[unl_index];
        unsigned int url_b = ((unsigned int*)abyp_b)[unl_index];
        if (url_carry) {
            ((unsigned int*)abyp_dest)[unl_index] = url_a + url_b + 1;
            url_carry = (((unsigned int*)abyp_dest)[unl_index] <= url_a);
        } else {
            ((unsigned int*)abyp_dest)[unl_index] = url_a + url_b;
            url_carry = (((unsigned int*)abyp_dest)[unl_index] < url_a);
        }
    }
    return url_carry;
}


int m_impl_sub_karatsuba(unsigned char* abyp_dest,
                         const unsigned char* abyp_a,
                         const unsigned char* abyp_b,
                         size_t szp_len)
{
    unsigned int url_borrow = 0;
    unsigned int unl_index = 0;
    for (; unl_index < szp_len / sizeof(unsigned int); unl_index++) {
        unsigned int url_a = ((unsigned int*)abyp_a)[unl_index];
        unsigned int url_b = ((unsigned int*)abyp_b)[unl_index];
        if (url_borrow) {
            url_borrow = (url_a <= url_b);
            ((unsigned int*)abyp_dest)[unl_index] = (url_a - url_b - 1);
        } else {
            url_borrow = (url_a < url_b);
            ((unsigned int*)abyp_dest)[unl_index] = (url_a - url_b);
        }
    }
    return url_borrow;
}


int m_impl_cmp(const unsigned char* abyp_a,
               const unsigned char* abyp_b,
               size_t szp_len)
{
    if (szp_len == 0) {
        return 0;
    }
    for (long long ill_index = (szp_len / sizeof(unsigned int))-1; ill_index >= 0; --ill_index) {
        if (((unsigned int*)abyp_a)[ill_index] > ((unsigned int*)abyp_b)[ill_index]) {
            return 1;
        }
        if (((unsigned int*)abyp_a)[ill_index] < ((unsigned int*)abyp_b)[ill_index]) {
            return -1;
        }
    }
    return 0;
}


void m_impl_add_word(unsigned char* abyp_dest_a,
                     unsigned int unp_b)
{
    unsigned int unl_index = 0;
    for(;; ) {
        unsigned int url_original = ((unsigned int*)abyp_dest_a)[unl_index];
        ((unsigned int*)abyp_dest_a)[unl_index] += unp_b;
        if (((unsigned int*)abyp_dest_a)[unl_index] < url_original) {
            unp_b = 1;
        } else {
            return;
        }
        unl_index++;
    }
}


void m_impl_mult_basic(unsigned char* abyp_dest,
                       const unsigned char* abyp_a,
                       size_t szp_a_len,
                       const unsigned char* abyp_b,
                       size_t szp_b_len)
{
    //This code is specific to 32-bit integers
    memset(abyp_dest,0,szp_b_len);
    for (unsigned int unl_index = 0; unl_index < szp_a_len / sizeof(unsigned int); unl_index++) {
        unsigned long long ull_carry = 0;
        for (unsigned int unl_index_2 = 0; unl_index_2 < szp_b_len / sizeof(unsigned int); unl_index_2++) {
            unsigned long long ull_product = (unsigned long long)((unsigned int*)abyp_a)[unl_index] *
                                             (unsigned long long)((unsigned int*)abyp_b)[unl_index_2];
            ull_product += ull_carry;
            ull_product += ((unsigned int*)abyp_dest)[unl_index+unl_index_2];
            ((unsigned int*)abyp_dest)[unl_index+unl_index_2] = (ull_product & 0xFFFFFFFF);
            ull_carry = ull_product >> 32;
        }
        ((unsigned int*)abyp_dest)[unl_index+(szp_b_len / sizeof(unsigned int))] = (unsigned int)ull_carry;
    }
}

void m_impl_square(unsigned char* abyp_dest,
                   const unsigned char* abyp_a,
                   size_t szp_a_len)
{
    //This code is specific to 32-bit integers
    memset(abyp_dest,0, 2 * szp_a_len);
    for (unsigned int unl_index = 0; unl_index < szp_a_len / sizeof(unsigned int); unl_index++) {
        // Each step of this outer loop does:
        // dest[index] += a[index]*(a[index] + 2*a[index +1] + 2*a[index +2] +...+ 2*a[a_len -1])
        unsigned long long ull_product = (unsigned long long)((unsigned int*)abyp_a)[unl_index] * (unsigned long long)((unsigned int*)abyp_a)[unl_index];
        ull_product += (unsigned long long) ((unsigned int*)abyp_dest)[2 * unl_index];
        ((unsigned int*)abyp_dest)[2 * unl_index] = (ull_product & 0xFFFFFFFF);
        unsigned long long ull_carry = ull_product >> 32;
        for (unsigned int unl_index_2 = unl_index + 1; unl_index_2 < szp_a_len / sizeof(unsigned int); unl_index_2++) {
            ull_product =  (unsigned long long)((unsigned int*)abyp_a)[unl_index] * (unsigned long long)((unsigned int*)abyp_a)[unl_index_2];
            ull_carry += (unsigned long long)((unsigned int*)abyp_dest)[unl_index+unl_index_2];
            unsigned long long ull_temp = ((2 * ull_product) & 0xFFFFFFFF) + (ull_carry & 0xFFFFFFFF);
            ((unsigned int*)abyp_dest)[unl_index+unl_index_2] = (ull_temp & 0xFFFFFFFF);
            //This carry is 64-bit
            ull_carry = (ull_carry >> 32) + (ull_temp >> 32) + (ull_product >> 31);
        }
        // Add the last carry (64-bit)
        if (unl_index < (szp_a_len / sizeof(unsigned int)) - 1) {
            ull_carry += ((unsigned int*)abyp_dest)[unl_index + (szp_a_len / sizeof(unsigned int))];
            ((unsigned int*)abyp_dest)[unl_index + (szp_a_len / sizeof(unsigned int))] = (unsigned int)ull_carry;
            ((unsigned int*)abyp_dest)[unl_index + (szp_a_len / sizeof(unsigned int))+1] = (unsigned int)(ull_carry >> 32);
        } else {
            // The very last carry is always 32-bit
            // Extra handling is required to avoid possible memory access violation
            ((unsigned int*)abyp_dest)[2 * (szp_a_len / sizeof(unsigned int)) - 1] += (unsigned int) ull_carry;
        }
    }
} // m_impl_square


extern "C"
void m_impl_mont_mul_add(unsigned char* abyp_dest,
                         unsigned int unp_n_0_inv,
                         const unsigned char* abyp_mod,
                         size_t szp_mod_len,
                         const unsigned char* abyp_src)
{
    ((unsigned int *)abyp_dest)[szp_mod_len / sizeof(unsigned int)*2] = 0; // Insert 0 into the last position

    if((szp_mod_len % (8*sizeof(unsigned int))) == 0) {
        ms_impl_mont_mul_add_8((unsigned int*)abyp_dest, unp_n_0_inv, (unsigned int*)abyp_mod, szp_mod_len / sizeof(unsigned int), (unsigned int*)abyp_src);
        return;
    }
    memcpy(abyp_dest, abyp_src, szp_mod_len*2);
    for (unsigned int unl_out_count = 0; unl_out_count < szp_mod_len / sizeof(unsigned int); unl_out_count++) {
        // Initialize C and calculate m
        unsigned long long ull_tmp_prod = 0;
        unsigned int unl_m = unp_n_0_inv*((unsigned int*)abyp_dest)[0];
        unsigned int unl_index;
        for (unl_index = 0; unl_index < szp_mod_len / sizeof(unsigned int); unl_index++) {
            // (C,S) := t[i+j] + m*n[j] + C
            ull_tmp_prod += ((unsigned long long)unl_m)*
                            ((unsigned long long)((unsigned int*)abyp_mod)[unl_index]);
            ull_tmp_prod += ((unsigned int*)abyp_dest)[unl_index];

            // t[i+j] := S
            ((unsigned int*)abyp_dest)[unl_index] = (unsigned int)ull_tmp_prod;

            // Store C in the low 32 bit for next round
            ull_tmp_prod >>= 32;
        }
        // ADD(t[i+s], C)
        ull_tmp_prod += ((unsigned int*)abyp_dest)[szp_mod_len / sizeof(unsigned int)];
        ((unsigned int*)abyp_dest)[szp_mod_len / sizeof(unsigned int)] = (unsigned int)ull_tmp_prod;
        ull_tmp_prod >>= 32;
        while(ull_tmp_prod != 0) {
            // This loop propagates the carry from ADD
            unl_index++;
            ull_tmp_prod += ((unsigned int*)abyp_dest)[unl_index];
            ((unsigned int*)abyp_dest)[unl_index] = (unsigned int)ull_tmp_prod;
            ull_tmp_prod >>= 32;
        }
        // set next t[i]
        abyp_dest+=sizeof(unsigned int);
    }
} // m_impl_mont_mul_add

extern "C"
size_t m_impl_first_bit(unsigned int unp_word)
{
    size_t szl_counter = 0;
    while (szl_counter < 32) {
        if ((unp_word << (31 - szl_counter)) != 0) break;
        szl_counter++;
    }
    return szl_counter;
}

extern "C"
size_t m_impl_last_bit(unsigned int unp_word)
{
    // Using binary search with table for last 4 bits
    size_t szrl_table[16] = {4,3,2,2,1,1,1,1,0,0,0,0,0,0,0,0};
    size_t szl_counter = 0;
    size_t szl_shift = 16;
    while (szl_shift >= 4) {
        if ((unp_word >> szl_shift) == 0) {
            szl_counter += szl_shift;
        } else {
            unp_word >>= szl_shift;
        }
        szl_shift /= 2;
    }
    szl_counter += szrl_table[unp_word];
    return 31 - szl_counter;
}



inline unsigned int ms_add_8(unsigned long long* aulp_dest,
                             const unsigned int* aunp_src,
                             unsigned int unp_carry_in)
{
    aulp_dest[0] += aunp_src[0] + unp_carry_in;
    aulp_dest[1] += aunp_src[1] + (aulp_dest[0] >> 32);
    aulp_dest[2] += aunp_src[2] + (aulp_dest[1] >> 32);
    aulp_dest[3] += aunp_src[3] + (aulp_dest[2] >> 32);
    aulp_dest[4] += aunp_src[4] + (aulp_dest[3] >> 32);
    aulp_dest[5] += aunp_src[5] + (aulp_dest[4] >> 32);
    aulp_dest[6] += aunp_src[6] + (aulp_dest[5] >> 32);
    aulp_dest[7] += aunp_src[7] + (aulp_dest[6] >> 32);
    unsigned int unl_carry_out = aulp_dest[7] >> 32;
    aulp_dest[0] &= 0xffffffff;
    aulp_dest[1] &= 0xffffffff;
    aulp_dest[2] &= 0xffffffff;
    aulp_dest[3] &= 0xffffffff;
    aulp_dest[4] &= 0xffffffff;
    aulp_dest[5] &= 0xffffffff;
    aulp_dest[6] &= 0xffffffff;
    aulp_dest[7] &= 0xffffffff;
    return unl_carry_out;
} // ms_add_8

static const unsigned int unss_zero_array[8] = { 0,0,0,0,0,0,0,0 };

/**
   This function performs the Montgomery reduction when szp_mod_len is a multiple of 8.

   The algorithm is taken from OpenSSL 1.0.2j (x86_64-mont5.pl, __bn_sqr8x_reduction).
   It is based on Algorithm 2 from "New Speed Records for Montgomery Modular
   Multiplication on 8-bit AVR Microcontrollers" (Zhe Liu and Johann Grossschaedl).

   In this implementation, 8 words are treated as a single word. This is denoted by capital letters,
   for example Q is equivalent to q, but 8 words, P[i] is p_(8*i=-p_(8*i+8).

   Each inner loop step is using the same algorithm, but this time word by word.

 */
static void ms_impl_mont_mul_add_8(unsigned int* aunp_dest,
                                   unsigned int unp_n_0_inv,
                                   const unsigned int* aunp_mod,
                                   size_t szp_mod_len,
                                   const unsigned int* aunp_src)
{
    memcpy(aunp_dest, aunp_src, szp_mod_len*2*sizeof(unsigned int));
    unsigned int* aunl_carry = aunp_dest+(2*szp_mod_len);

    // Outer reduction loop
    for (unsigned int unl_out_count = 0; unl_out_count < szp_mod_len; unl_out_count+=8) {
        unsigned long long ulrl_cached_values[8];                       //<! Variable to store P[i]
        unsigned long long unrl_q[8];                                   //<! Variable to store Q
        unsigned long long ull_temp;                                    //<! For calculations

        // Read current block of 8 words P[i]=p_0-p_7
        ulrl_cached_values[0] = aunp_dest[0];
        ulrl_cached_values[1] = aunp_dest[1];
        ulrl_cached_values[2] = aunp_dest[2];
        ulrl_cached_values[3] = aunp_dest[3];
        ulrl_cached_values[4] = aunp_dest[4];
        ulrl_cached_values[5] = aunp_dest[5];
        ulrl_cached_values[6] = aunp_dest[6];
        ulrl_cached_values[7] = aunp_dest[7];

        aunp_dest += 8;

        // First block processing. This calculates Q and (U|V) = N[0]*Q, discarding V, which will not be needed
        for(unsigned int unl_inner_cnt = 0; unl_inner_cnt < 8; unl_inner_cnt++) {

            // Calculate and store Q = q[n] = p_n * n_0_inv for current 8 words
            unrl_q[unl_inner_cnt] = (unsigned int)(unp_n_0_inv*ulrl_cached_values[0]);

            // (p_i|p_(i-1)) = q*n[i]+p_i+p(i-1)

            // p_0 handling can be simplified
            ull_temp = unrl_q[unl_inner_cnt]*aunp_mod[0];
            ull_temp >>= 32;
            if(ulrl_cached_values[0] != 0) {
                ull_temp++;
            }
            ulrl_cached_values[0] = ull_temp;

            ull_temp = unrl_q[unl_inner_cnt]*aunp_mod[1];
            ull_temp += ulrl_cached_values[1];
            ull_temp += ulrl_cached_values[0];
            ulrl_cached_values[0] = (unsigned int)ull_temp;
            ulrl_cached_values[1] = ull_temp >> 32;

            ull_temp = unrl_q[unl_inner_cnt]*aunp_mod[2];
            ull_temp += ulrl_cached_values[2];
            ull_temp += ulrl_cached_values[1];
            ulrl_cached_values[1] = (unsigned int)ull_temp;
            ulrl_cached_values[2] = ull_temp >> 32;

            ull_temp = unrl_q[unl_inner_cnt]*aunp_mod[3];
            ull_temp += ulrl_cached_values[3];
            ull_temp += ulrl_cached_values[2];
            ulrl_cached_values[2] = (unsigned int)ull_temp;
            ulrl_cached_values[3] = ull_temp >> 32;

            ull_temp = unrl_q[unl_inner_cnt]*aunp_mod[4];
            ull_temp += ulrl_cached_values[4];
            ull_temp += ulrl_cached_values[3];
            ulrl_cached_values[3] = (unsigned int)ull_temp;
            ulrl_cached_values[4] = ull_temp >> 32;

            ull_temp = unrl_q[unl_inner_cnt]*aunp_mod[5];
            ull_temp += ulrl_cached_values[5];
            ull_temp += ulrl_cached_values[4];
            ulrl_cached_values[4] = (unsigned int)ull_temp;
            ulrl_cached_values[5] = ull_temp >> 32;

            ull_temp = unrl_q[unl_inner_cnt]*aunp_mod[6];
            ull_temp += ulrl_cached_values[6];
            ull_temp += ulrl_cached_values[5];
            ulrl_cached_values[5] = (unsigned int)ull_temp;
            ulrl_cached_values[6] = ull_temp >> 32;

            ull_temp = unrl_q[unl_inner_cnt]*aunp_mod[7];
            ull_temp += ulrl_cached_values[7];
            ull_temp += ulrl_cached_values[6];
            ulrl_cached_values[6] = (unsigned int)ull_temp;
            ulrl_cached_values[7] = ull_temp >> 32;
        }

        unsigned int unl_carry = 0;

        aunp_mod += 8;

        // Main inner loop
        // Calculates (U|V) = N[j]*Q + P[i+j] + U. V is written back word by word
        for(unsigned int unl_tail_index = 8; unl_tail_index < szp_mod_len; unl_tail_index+= 8) {

            // Add in last rounds P[i+j] with carry
            unl_carry = ms_add_8(ulrl_cached_values, aunp_dest, unl_carry);

            // Calculates N[j]*Q + U
            for(unsigned int unl_inner_cnt = 0; unl_inner_cnt < 8; unl_inner_cnt++) {
                // (p_i|p_(i-1)) = q[n]*n[i]+p_i+p(i-1)

                // p_0 handling can be simplified
                ull_temp = unrl_q[unl_inner_cnt]*aunp_mod[0];
                ulrl_cached_values[0] += ull_temp;

                // Write back current word of V
                aunp_dest[0] = (unsigned int)(ulrl_cached_values[0]);
                aunp_dest++;

                ulrl_cached_values[0] >>= 32;

                ull_temp = unrl_q[unl_inner_cnt]*aunp_mod[1];
                ull_temp += ulrl_cached_values[1];
                ull_temp += ulrl_cached_values[0];
                ulrl_cached_values[0] = (unsigned int)ull_temp;
                ulrl_cached_values[1] = ull_temp >> 32;

                ull_temp = unrl_q[unl_inner_cnt]*aunp_mod[2];
                ull_temp += ulrl_cached_values[2];
                ull_temp += ulrl_cached_values[1];
                ulrl_cached_values[1] = (unsigned int)ull_temp;
                ulrl_cached_values[2] = ull_temp >> 32;

                ull_temp = unrl_q[unl_inner_cnt]*aunp_mod[3];
                ull_temp += ulrl_cached_values[3];
                ull_temp += ulrl_cached_values[2];
                ulrl_cached_values[2] = (unsigned int)ull_temp;
                ulrl_cached_values[3] = ull_temp >> 32;

                ull_temp = unrl_q[unl_inner_cnt]*aunp_mod[4];
                ull_temp += ulrl_cached_values[4];
                ull_temp += ulrl_cached_values[3];
                ulrl_cached_values[3] = (unsigned int)ull_temp;
                ulrl_cached_values[4] = ull_temp >> 32;

                ull_temp = unrl_q[unl_inner_cnt]*aunp_mod[5];
                ull_temp += ulrl_cached_values[5];
                ull_temp += ulrl_cached_values[4];
                ulrl_cached_values[4] = (unsigned int)ull_temp;
                ulrl_cached_values[5] = ull_temp >> 32;

                ull_temp = unrl_q[unl_inner_cnt]*aunp_mod[6];
                ull_temp += ulrl_cached_values[6];
                ull_temp += ulrl_cached_values[5];
                ulrl_cached_values[5] = (unsigned int)ull_temp;
                ulrl_cached_values[6] = ull_temp >> 32;

                ull_temp = unrl_q[unl_inner_cnt]*aunp_mod[7];
                ull_temp += ulrl_cached_values[7];
                ull_temp += ulrl_cached_values[6];
                ulrl_cached_values[6] = (unsigned int)ull_temp;
                ulrl_cached_values[7] = ull_temp >> 32;
            }

            // Next [j]
            aunp_mod += 8;
            if (unl_tail_index+8 ==  szp_mod_len) {
                // Add in carry out t of last outer loop
                ms_add_8(ulrl_cached_values, unss_zero_array, aunl_carry[0]);
                aunp_mod -= szp_mod_len;
            }
        }

        // (U|V) = P[i+j]+U, store carry out t
        aunl_carry[0] = ms_add_8(ulrl_cached_values, aunp_dest, unl_carry);

        // P[i+j] = V
        aunp_dest[0] = (unsigned int)(ulrl_cached_values[0]);
        aunp_dest[1] = (unsigned int)(ulrl_cached_values[1]);
        aunp_dest[2] = (unsigned int)(ulrl_cached_values[2]);
        aunp_dest[3] = (unsigned int)(ulrl_cached_values[3]);
        aunp_dest[4] = (unsigned int)(ulrl_cached_values[4]);
        aunp_dest[5] = (unsigned int)(ulrl_cached_values[5]);
        aunp_dest[6] = (unsigned int)(ulrl_cached_values[6]);
        aunp_dest[7] = (unsigned int)(ulrl_cached_values[7]);

        // next P[i]
        aunp_dest-= (szp_mod_len-8);
    }
} // ms_impl_mont_mul_add_8

#endif // !HL_LNUM_ASM

//------------------------------------------------------------------------------
// Start of original file ./xs-aes.cpp
//------------------------------------------------------------------------------

#include <stdlib.h>
#include <string.h>

#ifdef _WIN32
#include <Windows.h>
#else
#include "hob-unix01.h"
#ifndef HL_UNIX
#define HL_UNIX
#if (defined __APPLE__) && (defined __MACH__)
#define HL_LINUX
#define HL_MACOS
#endif
#endif // !HL_UNIX
#endif

#include "hob-xslhcla1.hpp"
#include "hob-encry-2.h"
#include "hob-encry-intern-2.h"

#ifndef _WIN32
#include <limits.h>
#include <stdint.h>
#endif

#ifdef _WIN32
#define HL_OPTIMIZE_OFF __pragma(optimize("", off))
#define HL_OPTIMIZE_ON __pragma(optimize("", on ))
#endif

#ifdef _WIN32
HL_OPTIMIZE_OFF
inline void ms_kill_proc(void)
{
    *((unsigned int*)0) = 0xDEAD;
}
HL_OPTIMIZE_ON
#else

inline void ms_kill_proc(void)
{
    __builtin_trap();
}
#endif

#ifndef min
#define min(a,b)            (((a) < (b)) ? (a) : (b))
#endif


// ------------------------------------------
//  Static declarations
// ------------------------------------------


static void ms_aes_ecb_fast_encrypt(const unsigned char * abyp_input,
                                    unsigned char * abyp_output,
                                    const unsigned char * abyp_key,
                                    size_t szp_blk_cnt,
                                    size_t szp_rounds);

static void ms_fast_ghash_stream(unsigned char* abyp_hash_state,
                                 const unsigned char* abyp_hash_key,
                                 const unsigned char* abyp_data,
                                 size_t szp_data_len);

static void ms_aes_gcm_encrypt_base(unsigned char* abyp_cipher,
                                    const struct dsd_gather_i_1* adsp_plain,
                                    size_t szp_len,
                                    const struct dsd_cipher_key* adsp_key,
                                    const unsigned char* abyp_iv,
                                    size_t szp_iv_len,
                                    const unsigned char* abyp_adddata,
                                    size_t szp_adddata_len,
                                    unsigned char* abyp_tag,
                                    size_t szp_tag_len,
                                    void (* amp_ecb_encrypt)(const unsigned char * abyp_input,
                                                             unsigned char * abyp_output,
                                                             const unsigned char * abyp_key,
                                                             size_t szl_blk_cnt,
                                                             size_t szp_rounds),
                                    void (* amp_ghash_stream)(unsigned char* abyp_hash_state,
                                                              const unsigned char* abyp_hash_key,
                                                              const unsigned char* abyp_data,
                                                              size_t szp_data_len),
                                    amd_block_crypt amp_ctr);

static BOOL ms_aes_gcm_decrypt_base(unsigned char* abyp_plain,
                                    const struct dsd_gather_i_1* adsp_cipher,
                                    size_t szp_len,
                                    const struct dsd_cipher_key* adsp_key,
                                    const unsigned char* abyp_iv,
                                    size_t szp_iv_len,
                                    const unsigned char* abyp_adddata,
                                    size_t szp_adddata_len,
                                    const unsigned char* abyp_tag,
                                    size_t szp_tag_len,
                                    void (* amp_ecb_encrypt)(const unsigned char * abyp_input,
                                                             unsigned char * abyp_output,
                                                             const unsigned char * abyp_key,
                                                             size_t szl_blk_cnt,
                                                             size_t szp_rounds),
                                    void (* amp_ghash_stream)(unsigned char* abyp_hash_state,
                                                              const unsigned char* abyp_hash_key,
                                                              const unsigned char* abyp_data,
                                                              size_t szp_data_len),
                                    amd_block_crypt amp_ctr);

// ------------------------------------------
//  AES Initialization
// ------------------------------------------

void m_aes_init_enc_key_hw(struct dsd_cipher_key* adsp_key,
                           const unsigned char* abyp_key,
                           size_t szp_key_len)
{

    adsp_key->unc_key_size = (unsigned int) szp_key_len;
    if(szp_key_len == 16) {
        m_impl_aes_128_key_expansion(abyp_key, adsp_key->byrc_aes_expkey);
    } else if(szp_key_len == 24) {
        m_impl_aes_192_key_expansion(abyp_key, adsp_key->byrc_aes_expkey);
    } else{
        m_impl_aes_256_key_expansion(abyp_key, adsp_key->byrc_aes_expkey);
    }
}

void m_aes_init_dec_key_hw(struct dsd_cipher_key* adsp_key,
                           const unsigned char* abyp_key,
                           size_t szp_key_len)
{
    size_t szl_nr;
    struct dsd_cipher_key dsl_temp_key;
    m_aes_init_enc_key_hw(&dsl_temp_key, abyp_key, szp_key_len);
    szl_nr = (szp_key_len >> 2) + 6;    // number of rounds

    adsp_key->unc_key_size = (unsigned int) szp_key_len;
    m_impl_aes_revert_key(dsl_temp_key.byrc_aes_expkey,
                          adsp_key->byrc_aes_expkey,
                          szl_nr);
}

// ------------------------------------------
//  AES CBC Encryptions and Decryptions
// ------------------------------------------

void m_aes_cbc_encrypt_hw(unsigned char* abyp_output,
                          const unsigned char* abyp_input,
                          size_t szp_len,
                          const struct dsd_cipher_key* adsp_key,
                          const unsigned char* abyp_iv)
{
    size_t szl_block_cnt = szp_len >> 4;
    size_t szl_rounds = (adsp_key->unc_key_size >> 2) + 6;
    m_impl_aes_cbc_encrypt(abyp_input,
                           abyp_output,
                           adsp_key->byrc_aes_expkey,
                           szl_block_cnt,
                           szl_rounds,
                           abyp_iv);

}

void m_aes_cbc_decrypt_hw(unsigned char* abyp_output,
                          const unsigned char* abyp_input,
                          size_t szp_len,
                          const struct dsd_cipher_key* adsp_key,
                          const unsigned char* abyp_iv)
{
    size_t szl_block_cnt = szp_len >> 4;
    size_t szl_rounds = (adsp_key->unc_key_size >> 2) + 6;
    m_impl_aes_cbc_decrypt(abyp_input,
                           abyp_output,
                           adsp_key->byrc_aes_expkey,
                           szl_block_cnt,
                           szl_rounds,
                           abyp_iv);
}


// ------------------------------------------
//  AES CTR Encryptions and Decryptions
// ------------------------------------------

void m_aes_ctr_crypt_hw(unsigned char* abyp_output,
                        const unsigned char* abyp_input,
                        size_t szp_len,
                        const struct dsd_cipher_key* adsp_key,
                        const unsigned char* abyp_iv)
{
    size_t szl_block_cnt = szp_len >> 4;
    size_t szl_rounds = (adsp_key->unc_key_size >> 2) + 6;
    size_t szl_single_bytes = szp_len % 16;
    // We store the IV, as it is overwritten by m_impl_aes_ctr
    unsigned char byrl_temp_iv[16];
    memcpy(byrl_temp_iv, abyp_iv, 16);

    m_impl_aes_ctr(abyp_input,
                   abyp_output,
                   adsp_key->byrc_aes_expkey,
                   szl_block_cnt,
                   szl_rounds,
                   byrl_temp_iv);
    // Incomplete block
    if(szl_single_bytes != 0) {
        size_t szl_offset = (szp_len - szl_single_bytes);
        while(szl_single_bytes > 0) {
            szl_single_bytes--;
            abyp_output[szl_single_bytes+szl_offset] = abyp_input[szl_single_bytes+szl_offset] ^
							                           byrl_temp_iv[szl_single_bytes];
        }
        m_sec_memzero(byrl_temp_iv, 16);
    }
} // m_aes_ctr_crypt_hw

// ------------------------------------------
//  AES GCM Encryptions and Decryptions
// ------------------------------------------
void m_aes_gcm_encrypt_sw(unsigned char* abyp_cipher,
                          const unsigned char* abyp_plain,
                          size_t szp_len,
                          const struct dsd_cipher_key* adsp_key,
                          const unsigned char* abyp_iv,
                          size_t szp_iv_len,
                          const unsigned char* abyp_adddata,
                          size_t szp_adddata_len,
                          unsigned char* abyp_tag,
                          size_t szp_tag_len)
{
    dsd_gather_i_1 dsl_wrapper_gather;
    dsl_wrapper_gather.achc_ginp_cur = (char *)abyp_plain;
    dsl_wrapper_gather.achc_ginp_end = dsl_wrapper_gather.achc_ginp_cur + szp_len;
    dsl_wrapper_gather.adsc_next = NULL;

    ms_aes_gcm_encrypt_base(abyp_cipher,
                            &dsl_wrapper_gather,
                            szp_len,
                            adsp_key,
                            abyp_iv,
                            szp_iv_len,
                            abyp_adddata,
                            szp_adddata_len,
                            abyp_tag,
                            szp_tag_len,
                            ms_aes_ecb_fast_encrypt,
                            ms_fast_ghash_stream,
                            m_aes_ctr_crypt_sw);
} // m_aes_gcm_encrypt_sw


void m_aes_gcm_encrypt_hw1(unsigned char* abyp_cipher,
                           const unsigned char* abyp_plain,
                           size_t szp_len,
                           const struct dsd_cipher_key* adsp_key,
                           const unsigned char* abyp_iv,
                           size_t szp_iv_len,
                           const unsigned char* abyp_adddata,
                           size_t szp_adddata_len,
                           unsigned char* abyp_tag,
                           size_t szp_tag_len)
{
    dsd_gather_i_1 dsl_wrapper_gather;
    dsl_wrapper_gather.achc_ginp_cur = (char *)abyp_plain;
    dsl_wrapper_gather.achc_ginp_end = dsl_wrapper_gather.achc_ginp_cur + szp_len;
    dsl_wrapper_gather.adsc_next = NULL;

    ms_aes_gcm_encrypt_base(abyp_cipher,
                            &dsl_wrapper_gather,
                            szp_len,
                            adsp_key,
                            abyp_iv,
                            szp_iv_len,
                            abyp_adddata,
                            szp_adddata_len,
                            abyp_tag,
                            szp_tag_len,
                            m_impl_aes_ecb_encrypt,
                            ms_fast_ghash_stream,
                            m_aes_ctr_crypt_hw);
} // m_aes_gcm_encrypt_hw1

void m_aes_gcm_encrypt_hw2(unsigned char* abyp_cipher,
                           const unsigned char* abyp_plain,
                           size_t szp_len,
                           const struct dsd_cipher_key* adsp_key,
                           const unsigned char* abyp_iv,
                           size_t szp_iv_len,
                           const unsigned char* abyp_adddata,
                           size_t szp_adddata_len,
                           unsigned char* abyp_tag,
                           size_t szp_tag_len)
{
    dsd_gather_i_1 dsl_wrapper_gather;
    dsl_wrapper_gather.achc_ginp_cur = (char *)abyp_plain;
    dsl_wrapper_gather.achc_ginp_end = dsl_wrapper_gather.achc_ginp_cur + szp_len;
    dsl_wrapper_gather.adsc_next = NULL;

    ms_aes_gcm_encrypt_base(abyp_cipher,
                            &dsl_wrapper_gather,
                            szp_len,
                            adsp_key,
                            abyp_iv,
                            szp_iv_len,
                            abyp_adddata,
                            szp_adddata_len,
                            abyp_tag,
                            szp_tag_len,
                            m_impl_aes_ecb_encrypt,
                            m_impl_ghash_stream,
                            m_aes_ctr_crypt_hw);
} // m_aes_gcm_encrypt_hw2

BOOL m_aes_gcm_decrypt_sw(unsigned char* abyp_plain,
                          const unsigned char* abyp_cipher,
                          size_t szp_len,
                          const struct dsd_cipher_key* adsp_key,
                          const unsigned char* abyp_iv,
                          size_t szp_iv_len,
                          const unsigned char* abyp_adddata,
                          size_t szp_adddata_len,
                          const unsigned char* abyp_tag,
                          size_t szp_tag_len)
{
    dsd_gather_i_1 dsl_wrapper_gather;
    dsl_wrapper_gather.achc_ginp_cur = (char *)abyp_cipher;
    dsl_wrapper_gather.achc_ginp_end = dsl_wrapper_gather.achc_ginp_cur + szp_len;
    dsl_wrapper_gather.adsc_next = NULL;

    return ms_aes_gcm_decrypt_base(abyp_plain,
                                   &dsl_wrapper_gather,
                                   szp_len,
                                   adsp_key,
                                   abyp_iv,
                                   szp_iv_len,
                                   abyp_adddata,
                                   szp_adddata_len,
                                   abyp_tag,
                                   szp_tag_len,
                                   ms_aes_ecb_fast_encrypt,
                                   ms_fast_ghash_stream,
                                   m_aes_ctr_crypt_sw);
} // m_aes_gcm_decrypt_sw

BOOL m_aes_gcm_decrypt_hw1(unsigned char* abyp_plain,
                           const unsigned char* abyp_cipher,
                           size_t szp_len,
                           const struct dsd_cipher_key* adsp_key,
                           const unsigned char* abyp_iv,
                           size_t szp_iv_len,
                           const unsigned char* abyp_adddata,
                           size_t szp_adddata_len,
                           const unsigned char* abyp_tag,
                           size_t szp_tag_len)
{
    dsd_gather_i_1 dsl_wrapper_gather;
    dsl_wrapper_gather.achc_ginp_cur = (char *)abyp_cipher;
    dsl_wrapper_gather.achc_ginp_end = dsl_wrapper_gather.achc_ginp_cur + szp_len;
    dsl_wrapper_gather.adsc_next = NULL;

    return ms_aes_gcm_decrypt_base(abyp_plain,
                                   &dsl_wrapper_gather,
                                   szp_len,
                                   adsp_key,
                                   abyp_iv,
                                   szp_iv_len,
                                   abyp_adddata,
                                   szp_adddata_len,
                                   abyp_tag,
                                   szp_tag_len,
                                   m_impl_aes_ecb_encrypt,
                                   ms_fast_ghash_stream,
                                   m_aes_ctr_crypt_hw);
} // m_aes_gcm_decrypt_hw1

BOOL m_aes_gcm_decrypt_hw2(unsigned char* abyp_plain,
                           const unsigned char* abyp_cipher,
                           size_t szp_len,
                           const struct dsd_cipher_key* adsp_key,
                           const unsigned char* abyp_iv,
                           size_t szp_iv_len,
                           const unsigned char* abyp_adddata,
                           size_t szp_adddata_len,
                           const unsigned char* abyp_tag,
                           size_t szp_tag_len)
{
    dsd_gather_i_1 dsl_wrapper_gather;
    dsl_wrapper_gather.achc_ginp_cur = (char *)abyp_cipher;
    dsl_wrapper_gather.achc_ginp_end = dsl_wrapper_gather.achc_ginp_cur + szp_len;
    dsl_wrapper_gather.adsc_next = NULL;

    return ms_aes_gcm_decrypt_base(abyp_plain,
                                   &dsl_wrapper_gather,
                                   szp_len,
                                   adsp_key,
                                   abyp_iv,
                                   szp_iv_len,
                                   abyp_adddata,
                                   szp_adddata_len,
                                   abyp_tag,
                                   szp_tag_len,
                                   m_impl_aes_ecb_encrypt,
                                   m_impl_ghash_stream,
                                   m_aes_ctr_crypt_hw);
} // m_aes_gcm_decrypt_hw2

void m_aes_gcm_encrypt_gather(unsigned char* abyp_cipher,
                              const struct dsd_gather_i_1* adsp_plain,
                              size_t szp_len,
                              const struct dsd_cipher_key* adsp_key,
                              const unsigned char* abyp_iv,
                              size_t szp_iv_len,
                              const unsigned char* abyp_adddata,
                              size_t szp_adddata_len,
                              unsigned char* abyp_tag,
                              size_t szp_tag_len)
{
    void (* aml_ecb_encrypt)(const unsigned char * abyp_input,
                             unsigned char * abyp_output,
                             const unsigned char * abyp_key,
                             size_t szl_blk_cnt,
                             size_t szl_rounds);
    void (* aml_ghash_stream)(unsigned char* abyp_hash_state,
                              const unsigned char* abyp_hash_key,
                              const unsigned char* abyp_data,
                              size_t szp_data_len);
    amd_block_crypt aml_ctr;

    if (HL_HARDWARE_SUPPORT_AES &&
        !adsp_key->boc_disallow_hardware_acceleration)
    {
        aml_ecb_encrypt = m_impl_aes_ecb_encrypt;
        aml_ctr = m_aes_ctr_crypt_hw;
        if (!HL_HARDWARE_SUPPORT_PMUL) {
            aml_ghash_stream = ms_fast_ghash_stream;
        } else {
            aml_ghash_stream = m_impl_ghash_stream;
        }
    } else {
        aml_ecb_encrypt = ms_aes_ecb_fast_encrypt;
        aml_ghash_stream = ms_fast_ghash_stream;
        aml_ctr = m_aes_ctr_crypt_sw;
    }

    ms_aes_gcm_encrypt_base(abyp_cipher,
                            adsp_plain,
                            szp_len,
                            adsp_key,
                            abyp_iv,
                            szp_iv_len,
                            abyp_adddata,
                            szp_adddata_len,
                            abyp_tag,
                            szp_tag_len,
                            aml_ecb_encrypt,
                            aml_ghash_stream,
                            aml_ctr);
} // m_aes_gcm_encrypt_gather

BOOL m_aes_gcm_decrypt_gather(unsigned char* abyp_plain,
                              const struct dsd_gather_i_1* adsp_cipher,
                              size_t szp_len,
                              const struct dsd_cipher_key* adsp_key,
                              const unsigned char* abyp_iv,
                              size_t szp_iv_len,
                              const unsigned char* abyp_adddata,
                              size_t szp_adddata_len,
                              const unsigned char* abyp_tag,
                              size_t szp_tag_len)
{
    void (* aml_ecb_encrypt)(const unsigned char * abyp_input,
                             unsigned char * abyp_output,
                             const unsigned char * abyp_key,
                             size_t szl_blk_cnt,
                             size_t szl_rounds);
    void (* aml_ghash_stream)(unsigned char* abyp_hash_state,
                              const unsigned char* abyp_hash_key,
                              const unsigned char* abyp_data,
                              size_t szp_data_len);
    amd_block_crypt aml_ctr;

    if (HL_HARDWARE_SUPPORT_AES &&
        !adsp_key->boc_disallow_hardware_acceleration)
    {
        aml_ecb_encrypt = m_impl_aes_ecb_encrypt;
        aml_ctr = m_aes_ctr_crypt_hw;
        if (!HL_HARDWARE_SUPPORT_PMUL) {
            aml_ghash_stream = ms_fast_ghash_stream;
        } else {
            aml_ghash_stream = m_impl_ghash_stream;
        }
    } else {
        aml_ecb_encrypt = ms_aes_ecb_fast_encrypt;
        aml_ghash_stream = ms_fast_ghash_stream;
        aml_ctr = m_aes_ctr_crypt_sw;
    }

    return ms_aes_gcm_decrypt_base(abyp_plain,
                                   adsp_cipher,
                                   szp_len,
                                   adsp_key,
                                   abyp_iv,
                                   szp_iv_len,
                                   abyp_adddata,
                                   szp_adddata_len,
                                   abyp_tag,
                                   szp_tag_len,
                                   aml_ecb_encrypt,
                                   aml_ghash_stream,
                                   aml_ctr);
} // m_aes_gcm_decrypt_gather

//===================================================================
// Macros for the AES Round Functions. These are faster, than using inline functions
//===================================================================
#define AES_ENC_ROUND(U,V,W,X,A,B,C,D,KeyTab,N) \
    U = unrs_tab_enc_unl_t0[(unsigned char) A] ^ \
        unrs_tab_enc_unl_t1[(unsigned char) (B >> 8)] ^ \
        unrs_tab_enc_unl_t2[(unsigned char) (C >> 16)] ^ \
        unrs_tab_enc_unl_t3[(unsigned char) (D >> 24)] ^ \
        KeyTab[4+(N*4)]; \
    V = unrs_tab_enc_unl_t0[(unsigned char) B] ^ \
        unrs_tab_enc_unl_t1[(unsigned char) (C >> 8)] ^ \
        unrs_tab_enc_unl_t2[(unsigned char) (D >> 16)] ^ \
        unrs_tab_enc_unl_t3[(unsigned char) (A >> 24)] ^ \
        KeyTab[4+(N*4)+1]; \
    W = unrs_tab_enc_unl_t0[(unsigned char) C] ^ \
        unrs_tab_enc_unl_t1[(unsigned char) (D >> 8)] ^ \
        unrs_tab_enc_unl_t2[(unsigned char) (A >> 16)] ^ \
        unrs_tab_enc_unl_t3[(unsigned char) (B >> 24)] ^ \
        KeyTab[4+(N*4)+2]; \
    X = unrs_tab_enc_unl_t0[(unsigned char) D] ^ \
        unrs_tab_enc_unl_t1[(unsigned char) (A >> 8)] ^ \
        unrs_tab_enc_unl_t2[(unsigned char) (B >> 16)] ^ \
        unrs_tab_enc_unl_t3[(unsigned char) (C >> 24)] ^ \
        KeyTab[4+(N*4)+3];

#define AES_ENC_LAST_ROUND(U,V,W,X,A,B,C,D,KeyTab,N) \
    U = ((unsigned int) byrs_s_box[(unsigned char) A] | \
         ((unsigned int) byrs_s_box[(unsigned char) (B >> 8)] <<  8) | \
         ((unsigned int) byrs_s_box[(unsigned char) (C >> 16)] << 16) | \
         ((unsigned int) byrs_s_box[(unsigned char) (D >> 24)] << 24)) ^ \
        KeyTab[4+(N*4)]; \
    V = ((unsigned int) byrs_s_box[(unsigned char) B] | \
         ((unsigned int) byrs_s_box[(unsigned char) (C >> 8)] <<  8) | \
         ((unsigned int) byrs_s_box[(unsigned char) (D >> 16)] << 16) | \
         ((unsigned int) byrs_s_box[(unsigned char) (A >> 24)] << 24)) ^ \
        KeyTab[4+(N*4)+1]; \
    W = ((unsigned int) byrs_s_box[(unsigned char) C] | \
         ((unsigned int) byrs_s_box[(unsigned char) (D >> 8)] <<  8) | \
         ((unsigned int) byrs_s_box[(unsigned char) (A >> 16)] << 16) | \
         ((unsigned int) byrs_s_box[(unsigned char) (B >> 24)] << 24)) ^ \
        KeyTab[4+(N*4)+2]; \
    X = ((unsigned int) byrs_s_box[(unsigned char) D] | \
         ((unsigned int) byrs_s_box[(unsigned char) (A >> 8)] <<  8) | \
         ((unsigned int) byrs_s_box[(unsigned char) (B >> 16)] << 16) | \
         ((unsigned int) byrs_s_box[(unsigned char) (C >> 24)] << 24)) ^ \
        KeyTab[4+(N*4)+3];

#define AES_DEC_ROUND(U,V,W,X,A,B,C,D,KeyTab,N) \
    U = unrs_tab_dec_unl_t0[(unsigned char) A] ^ \
        unrs_tab_dec_unl_t1[(unsigned char) (D >> 8)] ^ \
        unrs_tab_dec_unl_t2[(unsigned char) (C >> 16)] ^ \
        unrs_tab_dec_unl_t3[(unsigned char) (B >> 24)] ^ \
        KeyTab[4+(N*4)]; \
    V = unrs_tab_dec_unl_t0[(unsigned char) B] ^ \
        unrs_tab_dec_unl_t1[(unsigned char) (A >> 8)] ^ \
        unrs_tab_dec_unl_t2[(unsigned char) (D >> 16)] ^ \
        unrs_tab_dec_unl_t3[(unsigned char) (C >> 24)] ^ \
        KeyTab[4+(N*4)+1]; \
    W = unrs_tab_dec_unl_t0[(unsigned char) C] ^ \
        unrs_tab_dec_unl_t1[(unsigned char) (B >> 8)] ^ \
        unrs_tab_dec_unl_t2[(unsigned char) (A >> 16)] ^ \
        unrs_tab_dec_unl_t3[(unsigned char) (D >> 24)] ^ \
        KeyTab[4+(N*4)+2]; \
    X = unrs_tab_dec_unl_t0[(unsigned char) D] ^ \
        unrs_tab_dec_unl_t1[(unsigned char) (C >> 8)] ^ \
        unrs_tab_dec_unl_t2[(unsigned char) (B >> 16)] ^ \
        unrs_tab_dec_unl_t3[(unsigned char) (A >> 24)] ^ \
        KeyTab[4+(N*4)+3];

#define AES_DEC_LAST_ROUND(U,V,W,X,A,B,C,D,KeyTab,N) \
    U = ((unsigned int) byrs_inv_s_box[(unsigned char) A] | \
         ((unsigned int) byrs_inv_s_box[(unsigned char) (D >>  8)] <<  8) | \
         ((unsigned int) byrs_inv_s_box[(unsigned char) (C >> 16)] << 16) | \
         ((unsigned int) byrs_inv_s_box[(unsigned char) (B >> 24)] << 24)) ^ \
        KeyTab[4+(N*4)]; \
    V = ((unsigned int) byrs_inv_s_box[(unsigned char) B] | \
         ((unsigned int) byrs_inv_s_box[(unsigned char) (A >>  8)] <<  8) | \
         ((unsigned int) byrs_inv_s_box[(unsigned char) (D >> 16)] << 16) | \
         ((unsigned int) byrs_inv_s_box[(unsigned char) (C >> 24)] << 24)) ^ \
        KeyTab[4+(N*4)+1]; \
    W = ((unsigned int) byrs_inv_s_box[(unsigned char) C] | \
         ((unsigned int) byrs_inv_s_box[(unsigned char) (B >>  8)] <<  8) | \
         ((unsigned int) byrs_inv_s_box[(unsigned char) (A >> 16)] << 16) | \
         ((unsigned int) byrs_inv_s_box[(unsigned char) (D >> 24)] << 24)) ^ \
        KeyTab[4+(N*4)+2]; \
    X = ((unsigned int) byrs_inv_s_box[(unsigned char) D] | \
         ((unsigned int) byrs_inv_s_box[(unsigned char) (C >>  8)] <<  8) | \
         ((unsigned int) byrs_inv_s_box[(unsigned char) (B >> 16)] << 16) | \
         ((unsigned int) byrs_inv_s_box[(unsigned char) (A >> 24)] << 24)) ^ \
        KeyTab[4+(N*4)+3];

//--------------------------------------------------------------
// AES S-Box used for Encryption
//--------------------------------------------------------------
static unsigned char byrs_s_box[256] = {
    0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5,     // 00-07
    0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,     // 08-0F
    0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0,     // 10-17
    0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0, // 18-1F
    0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC,     // 20-27
    0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,     // 28-2F
    0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A,     // 30-37
    0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,     // 38-3F
    0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0,     // 40-47
    0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,     // 48-4F
    0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B,     // 50-57
    0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,     // 58-5F
    0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85,     // 60-67
    0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,     // 68-6F
    0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5,     // 70-77
    0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,     // 78-7F
    0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17,     // 80-87
    0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,     // 88-8F
    0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88,     // 90-97
    0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,     // 98-9F
    0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C,     // A0-A7
    0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,     // A8-AF
    0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9,     // B0-B7
    0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,     // B8-BF
    0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6,     // C0-C7
    0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,     // C8-CF
    0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E,     // D0-D7
    0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,     // D8-DF
    0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94,     // E0-E7
    0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,     // E8-EF
    0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68,     // F0-F7
    0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16,     // F8-FF
};
//--------------------------------------------------------------
// AES S-Box used for Decryption
//--------------------------------------------------------------
static unsigned char byrs_inv_s_box[256] = {
    0x52, 0x09, 0x6A, 0xD5, 0x30, 0x36, 0xA5, 0x38, // 00-07
    0xBF, 0x40, 0xA3, 0x9E, 0x81, 0xF3, 0xD7, 0xFB,     // 08-0F
    0x7C, 0xE3, 0x39, 0x82, 0x9B, 0x2F, 0xFF, 0x87,     // 10-17
    0x34, 0x8E, 0x43, 0x44, 0xC4, 0xDE, 0xE9, 0xCB,     // 18-1F
    0x54, 0x7B, 0x94, 0x32, 0xA6, 0xC2, 0x23, 0x3D,     // 20-27
    0xEE, 0x4C, 0x95, 0x0B, 0x42, 0xFA, 0xC3, 0x4E,     // 28-2F
    0x08, 0x2E, 0xA1, 0x66, 0x28, 0xD9, 0x24, 0xB2,     // 30-37
    0x76, 0x5B, 0xA2, 0x49, 0x6D, 0x8B, 0xD1, 0x25,     // 38-3F
    0x72, 0xF8, 0xF6, 0x64, 0x86, 0x68, 0x98, 0x16,     // 40-47
    0xD4, 0xA4, 0x5C, 0xCC, 0x5D, 0x65, 0xB6, 0x92,     // 48-4F
    0x6C, 0x70, 0x48, 0x50, 0xFD, 0xED, 0xB9, 0xDA,     // 50-57
    0x5E, 0x15, 0x46, 0x57, 0xA7, 0x8D, 0x9D, 0x84,     // 58-5F
    0x90, 0xD8, 0xAB, 0x00, 0x8C, 0xBC, 0xD3, 0x0A,     // 60-67
    0xF7, 0xE4, 0x58, 0x05, 0xB8, 0xB3, 0x45, 0x06,     // 68-6F
    0xD0, 0x2C, 0x1E, 0x8F, 0xCA, 0x3F, 0x0F, 0x02,     // 70-77
    0xC1, 0xAF, 0xBD, 0x03, 0x01, 0x13, 0x8A, 0x6B,     // 78-7F
    0x3A, 0x91, 0x11, 0x41, 0x4F, 0x67, 0xDC, 0xEA,     // 80-87
    0x97, 0xF2, 0xCF, 0xCE, 0xF0, 0xB4, 0xE6, 0x73,     // 88-8F
    0x96, 0xAC, 0x74, 0x22, 0xE7, 0xAD, 0x35, 0x85,     // 90-97
    0xE2, 0xF9, 0x37, 0xE8, 0x1C, 0x75, 0xDF, 0x6E,     // 98-9F
    0x47, 0xF1, 0x1A, 0x71, 0x1D, 0x29, 0xC5, 0x89,     // A0-A7
    0x6F, 0xB7, 0x62, 0x0E, 0xAA, 0x18, 0xBE, 0x1B,     // A8-AF
    0xFC, 0x56, 0x3E, 0x4B, 0xC6, 0xD2, 0x79, 0x20,     // B0-B7
    0x9A, 0xDB, 0xC0, 0xFE, 0x78, 0xCD, 0x5A, 0xF4,     // B8-BF
    0x1F, 0xDD, 0xA8, 0x33, 0x88, 0x07, 0xC7, 0x31,     // C0-C7
    0xB1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xEC, 0x5F,     // C8-CF
    0x60, 0x51, 0x7F, 0xA9, 0x19, 0xB5, 0x4A, 0x0D,     // D0-D7
    0x2D, 0xE5, 0x7A, 0x9F, 0x93, 0xC9, 0x9C, 0xEF,     // D8-DF
    0xA0, 0xE0, 0x3B, 0x4D, 0xAE, 0x2A, 0xF5, 0xB0,     // E0-E7
    0xC8, 0xEB, 0xBB, 0x3C, 0x83, 0x53, 0x99, 0x61,     // E8-EF
    0x17, 0x2B, 0x04, 0x7E, 0xBA, 0x77, 0xD6, 0x26,     // F0-F7
    0xE1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0C, 0x7D,     // F8-FF
};
//------------------------------------------------------
// Encryption Table T0
//------------------------------------------------------
static unsigned int unrs_tab_enc_unl_t0[256] = {
    0xA56363C6, 0x847C7CF8, 0x997777EE, 0x8D7B7BF6,     // 00-03
    0x0DF2F2FF, 0xBD6B6BD6, 0xB16F6FDE, 0x54C5C591,     // 04-07
    0x50303060, 0x03010102, 0xA96767CE, 0x7D2B2B56,     // 08-0B
    0x19FEFEE7, 0x62D7D7B5, 0xE6ABAB4D, 0x9A7676EC,     // 0C-0F

    0x45CACA8F, 0x9D82821F, 0x40C9C989, 0x877D7DFA,     // 10-13
    0x15FAFAEF, 0xEB5959B2, 0xC947478E, 0x0BF0F0FB,     // 14-17
    0xECADAD41, 0x67D4D4B3, 0xFDA2A25F, 0xEAAFAF45,     // 18-1B
    0xBF9C9C23, 0xF7A4A453, 0x967272E4, 0x5BC0C09B,     // 1C-1F

    0xC2B7B775, 0x1CFDFDE1, 0xAE93933D, 0x6A26264C,     // 20-23
    0x5A36366C, 0x413F3F7E, 0x02F7F7F5, 0x4FCCCC83,     // 24-27
    0x5C343468, 0xF4A5A551, 0x34E5E5D1, 0x08F1F1F9,     // 28-2B
    0x937171E2, 0x73D8D8AB, 0x53313162, 0x3F15152A,     // 2C-2F

    0x0C040408, 0x52C7C795, 0x65232346, 0x5EC3C39D,     // 30-33
    0x28181830, 0xA1969637, 0x0F05050A, 0xB59A9A2F,     // 34-37
    0x0907070E, 0x36121224, 0x9B80801B, 0x3DE2E2DF,     // 38-3B
    0x26EBEBCD, 0x6927274E, 0xCDB2B27F, 0x9F7575EA,     // 3C-3F

    0x1B090912, 0x9E83831D, 0x742C2C58, 0x2E1A1A34,     // 40-43
    0x2D1B1B36, 0xB26E6EDC, 0xEE5A5AB4, 0xFBA0A05B,     // 44-47
    0xF65252A4, 0x4D3B3B76, 0x61D6D6B7, 0xCEB3B37D,     // 48-4B
    0x7B292952, 0x3EE3E3DD, 0x712F2F5E, 0x97848413,     // 4C-4F

    0xF55353A6, 0x68D1D1B9, 0x00000000, 0x2CEDEDC1,     // 50-53
    0x60202040, 0x1FFCFCE3, 0xC8B1B179, 0xED5B5BB6,     // 54-57
    0xBE6A6AD4, 0x46CBCB8D, 0xD9BEBE67, 0x4B393972,     // 58-5B
    0xDE4A4A94, 0xD44C4C98, 0xE85858B0, 0x4ACFCF85,     // 5C-5F

    0x6BD0D0BB, 0x2AEFEFC5, 0xE5AAAA4F, 0x16FBFBED,     // 60-63
    0xC5434386, 0xD74D4D9A, 0x55333366, 0x94858511,     // 64-67
    0xCF45458A, 0x10F9F9E9, 0x06020204, 0x817F7FFE,     // 68-6B
    0xF05050A0, 0x443C3C78, 0xBA9F9F25, 0xE3A8A84B,     // 6C-6F

    0xF35151A2, 0xFEA3A35D, 0xC0404080, 0x8A8F8F05,     // 70-73
    0xAD92923F, 0xBC9D9D21, 0x48383870, 0x04F5F5F1,     // 74-77
    0xDFBCBC63, 0xC1B6B677, 0x75DADAAF, 0x63212142,     // 78-7B
    0x30101020, 0x1AFFFFE5, 0x0EF3F3FD, 0x6DD2D2BF,     // 7C-7F

    0x4CCDCD81, 0x140C0C18, 0x35131326, 0x2FECECC3,     // 80-83
    0xE15F5FBE, 0xA2979735, 0xCC444488, 0x3917172E,     // 84-87
    0x57C4C493, 0xF2A7A755, 0x827E7EFC, 0x473D3D7A,     // 88-8B
    0xAC6464C8, 0xE75D5DBA, 0x2B191932, 0x957373E6,     // 8C-8F

    0xA06060C0, 0x98818119, 0xD14F4F9E, 0x7FDCDCA3,     // 90-93
    0x66222244, 0x7E2A2A54, 0xAB90903B, 0x8388880B,     // 94-97
    0xCA46468C, 0x29EEEEC7, 0xD3B8B86B, 0x3C141428,     // 98-9B
    0x79DEDEA7, 0xE25E5EBC, 0x1D0B0B16, 0x76DBDBAD,     // 9C-9F

    0x3BE0E0DB, 0x56323264, 0x4E3A3A74, 0x1E0A0A14,     // A0-A3
    0xDB494992, 0x0A06060C, 0x6C242448, 0xE45C5CB8,     // A4-A7
    0x5DC2C29F, 0x6ED3D3BD, 0xEFACAC43, 0xA66262C4,     // A8-AB
    0xA8919139, 0xA4959531, 0x37E4E4D3, 0x8B7979F2,     // AC-AF

    0x32E7E7D5, 0x43C8C88B, 0x5937376E, 0xB76D6DDA,     // B0-B3
    0x8C8D8D01, 0x64D5D5B1, 0xD24E4E9C, 0xE0A9A949,     // B4-B7
    0xB46C6CD8, 0xFA5656AC, 0x07F4F4F3, 0x25EAEACF,     // B8-BB
    0xAF6565CA, 0x8E7A7AF4, 0xE9AEAE47, 0x18080810,     // BC-BF

    0xD5BABA6F, 0x887878F0, 0x6F25254A, 0x722E2E5C,     // C0-C3
    0x241C1C38, 0xF1A6A657, 0xC7B4B473, 0x51C6C697,     // C4-C7
    0x23E8E8CB, 0x7CDDDDA1, 0x9C7474E8, 0x211F1F3E,     // C8-CB
    0xDD4B4B96, 0xDCBDBD61, 0x868B8B0D, 0x858A8A0F,     // CC-CF

    0x907070E0, 0x423E3E7C, 0xC4B5B571, 0xAA6666CC,     // D0-D3
    0xD8484890, 0x05030306, 0x01F6F6F7, 0x120E0E1C,     // D4-D7
    0xA36161C2, 0x5F35356A, 0xF95757AE, 0xD0B9B969,     // D8-DB
    0x91868617, 0x58C1C199, 0x271D1D3A, 0xB99E9E27,     // DC-DF

    0x38E1E1D9, 0x13F8F8EB, 0xB398982B, 0x33111122,     // E0-E3
    0xBB6969D2, 0x70D9D9A9, 0x898E8E07, 0xA7949433,     // E4-E7
    0xB69B9B2D, 0x221E1E3C, 0x92878715, 0x20E9E9C9,     // E8-EB
    0x49CECE87, 0xFF5555AA, 0x78282850, 0x7ADFDFA5,     // EC-EF

    0x8F8C8C03, 0xF8A1A159, 0x80898909, 0x170D0D1A,     // F0-F3
    0xDABFBF65, 0x31E6E6D7, 0xC6424284, 0xB86868D0,     // F4-F7
    0xC3414182, 0xB0999929, 0x772D2D5A, 0x110F0F1E,     // F8-FB
    0xCBB0B07B, 0xFC5454A8, 0xD6BBBB6D, 0x3A16162C,     // FC-FF
};
//------------------------------------------------------
// Encryption Table T1
//------------------------------------------------------
static unsigned int unrs_tab_enc_unl_t1[256] = {
    0x6363C6A5, 0x7C7CF884, 0x7777EE99, 0x7B7BF68D,     // 00-03
    0xF2F2FF0D, 0x6B6BD6BD, 0x6F6FDEB1, 0xC5C59154,     // 04-07
    0x30306050, 0x01010203, 0x6767CEA9, 0x2B2B567D,     // 08-0B
    0xFEFEE719, 0xD7D7B562, 0xABAB4DE6, 0x7676EC9A,     // 0C-0F

    0xCACA8F45, 0x82821F9D, 0xC9C98940, 0x7D7DFA87,     // 10-13
    0xFAFAEF15, 0x5959B2EB, 0x47478EC9, 0xF0F0FB0B,     // 14-17
    0xADAD41EC, 0xD4D4B367, 0xA2A25FFD, 0xAFAF45EA,     // 18-1B
    0x9C9C23BF, 0xA4A453F7, 0x7272E496, 0xC0C09B5B,     // 1C-1F

    0xB7B775C2, 0xFDFDE11C, 0x93933DAE, 0x26264C6A,     // 20-23
    0x36366C5A, 0x3F3F7E41, 0xF7F7F502, 0xCCCC834F,     // 24-27
    0x3434685C, 0xA5A551F4, 0xE5E5D134, 0xF1F1F908,     // 28-2B
    0x7171E293, 0xD8D8AB73, 0x31316253, 0x15152A3F,     // 2C-2F

    0x0404080C, 0xC7C79552, 0x23234665, 0xC3C39D5E,     // 30-33
    0x18183028, 0x969637A1, 0x05050A0F, 0x9A9A2FB5,     // 34-37
    0x07070E09, 0x12122436, 0x80801B9B, 0xE2E2DF3D,     // 38-3B
    0xEBEBCD26, 0x27274E69, 0xB2B27FCD, 0x7575EA9F,     // 3C-3F

    0x0909121B, 0x83831D9E, 0x2C2C5874, 0x1A1A342E,     // 40-43
    0x1B1B362D, 0x6E6EDCB2, 0x5A5AB4EE, 0xA0A05BFB,     // 44-47
    0x5252A4F6, 0x3B3B764D, 0xD6D6B761, 0xB3B37DCE,     // 48-4B
    0x2929527B, 0xE3E3DD3E, 0x2F2F5E71, 0x84841397,     // 4C-4F

    0x5353A6F5, 0xD1D1B968, 0x00000000, 0xEDEDC12C,     // 50-53
    0x20204060, 0xFCFCE31F, 0xB1B179C8, 0x5B5BB6ED,     // 54-57
    0x6A6AD4BE, 0xCBCB8D46, 0xBEBE67D9, 0x3939724B,     // 58-5B
    0x4A4A94DE, 0x4C4C98D4, 0x5858B0E8, 0xCFCF854A,     // 5C-5F

    0xD0D0BB6B, 0xEFEFC52A, 0xAAAA4FE5, 0xFBFBED16,     // 60-63
    0x434386C5, 0x4D4D9AD7, 0x33336655, 0x85851194,     // 64-67
    0x45458ACF, 0xF9F9E910, 0x02020406, 0x7F7FFE81,     // 68-6B
    0x5050A0F0, 0x3C3C7844, 0x9F9F25BA, 0xA8A84BE3,     // 6C-6F

    0x5151A2F3, 0xA3A35DFE, 0x404080C0, 0x8F8F058A,     // 70-73
    0x92923FAD, 0x9D9D21BC, 0x38387048, 0xF5F5F104,     // 74-77
    0xBCBC63DF, 0xB6B677C1, 0xDADAAF75, 0x21214263,     // 78-7B
    0x10102030, 0xFFFFE51A, 0xF3F3FD0E, 0xD2D2BF6D,     // 7C-7F

    0xCDCD814C, 0x0C0C1814, 0x13132635, 0xECECC32F,     // 80-83
    0x5F5FBEE1, 0x979735A2, 0x444488CC, 0x17172E39,     // 84-87
    0xC4C49357, 0xA7A755F2, 0x7E7EFC82, 0x3D3D7A47,     // 88-8B
    0x6464C8AC, 0x5D5DBAE7, 0x1919322B, 0x7373E695,     // 8C-8F

    0x6060C0A0, 0x81811998, 0x4F4F9ED1, 0xDCDCA37F,     // 90-93
    0x22224466, 0x2A2A547E, 0x90903BAB, 0x88880B83,     // 94-97
    0x46468CCA, 0xEEEEC729, 0xB8B86BD3, 0x1414283C,     // 98-9B
    0xDEDEA779, 0x5E5EBCE2, 0x0B0B161D, 0xDBDBAD76,     // 9C-9F

    0xE0E0DB3B, 0x32326456, 0x3A3A744E, 0x0A0A141E,     // A0-A3
    0x494992DB, 0x06060C0A, 0x2424486C, 0x5C5CB8E4,     // A4-A7
    0xC2C29F5D, 0xD3D3BD6E, 0xACAC43EF, 0x6262C4A6,     // A8-AB
    0x919139A8, 0x959531A4, 0xE4E4D337, 0x7979F28B,     // AC-AF

    0xE7E7D532, 0xC8C88B43, 0x37376E59, 0x6D6DDAB7,     // B0-B3
    0x8D8D018C, 0xD5D5B164, 0x4E4E9CD2, 0xA9A949E0,     // B4-B7
    0x6C6CD8B4, 0x5656ACFA, 0xF4F4F307, 0xEAEACF25,     // B8-BB
    0x6565CAAF, 0x7A7AF48E, 0xAEAE47E9, 0x08081018,     // BC-BF

    0xBABA6FD5, 0x7878F088, 0x25254A6F, 0x2E2E5C72,     // C0-C3
    0x1C1C3824, 0xA6A657F1, 0xB4B473C7, 0xC6C69751,     // C4-C7
    0xE8E8CB23, 0xDDDDA17C, 0x7474E89C, 0x1F1F3E21,     // C8-CB
    0x4B4B96DD, 0xBDBD61DC, 0x8B8B0D86, 0x8A8A0F85,     // CC-CF

    0x7070E090, 0x3E3E7C42, 0xB5B571C4, 0x6666CCAA,     // D0-D3
    0x484890D8, 0x03030605, 0xF6F6F701, 0x0E0E1C12,     // D4-D7
    0x6161C2A3, 0x35356A5F, 0x5757AEF9, 0xB9B969D0,     // D8-DB
    0x86861791, 0xC1C19958, 0x1D1D3A27, 0x9E9E27B9,     // DC-DF

    0xE1E1D938, 0xF8F8EB13, 0x98982BB3, 0x11112233,     // E0-E3
    0x6969D2BB, 0xD9D9A970, 0x8E8E0789, 0x949433A7,     // E4-E7
    0x9B9B2DB6, 0x1E1E3C22, 0x87871592, 0xE9E9C920,     // E8-EB
    0xCECE8749, 0x5555AAFF, 0x28285078, 0xDFDFA57A,     // EC-EF

    0x8C8C038F, 0xA1A159F8, 0x89890980, 0x0D0D1A17,     // F0-F3
    0xBFBF65DA, 0xE6E6D731, 0x424284C6, 0x6868D0B8,     // F4-F7
    0x414182C3, 0x999929B0, 0x2D2D5A77, 0x0F0F1E11,     // F8-FB
    0xB0B07BCB, 0x5454A8FC, 0xBBBB6DD6, 0x16162C3A,     // FC-FF
};
//------------------------------------------------------
// Encryption Table T2
//------------------------------------------------------
static unsigned int unrs_tab_enc_unl_t2[256] = {
    0x63C6A563, 0x7CF8847C, 0x77EE9977, 0x7BF68D7B,     // 00-03
    0xF2FF0DF2, 0x6BD6BD6B, 0x6FDEB16F, 0xC59154C5,     // 04-07
    0x30605030, 0x01020301, 0x67CEA967, 0x2B567D2B,     // 08-0B
    0xFEE719FE, 0xD7B562D7, 0xAB4DE6AB, 0x76EC9A76,     // 0C-0F

    0xCA8F45CA, 0x821F9D82, 0xC98940C9, 0x7DFA877D,     // 10-13
    0xFAEF15FA, 0x59B2EB59, 0x478EC947, 0xF0FB0BF0,     // 14-17
    0xAD41ECAD, 0xD4B367D4, 0xA25FFDA2, 0xAF45EAAF,     // 18-1B
    0x9C23BF9C, 0xA453F7A4, 0x72E49672, 0xC09B5BC0,     // 1C-1F

    0xB775C2B7, 0xFDE11CFD, 0x933DAE93, 0x264C6A26,     // 20-23
    0x366C5A36, 0x3F7E413F, 0xF7F502F7, 0xCC834FCC,     // 24-27
    0x34685C34, 0xA551F4A5, 0xE5D134E5, 0xF1F908F1,     // 28-2B
    0x71E29371, 0xD8AB73D8, 0x31625331, 0x152A3F15,     // 2C-2F

    0x04080C04, 0xC79552C7, 0x23466523, 0xC39D5EC3,     // 30-33
    0x18302818, 0x9637A196, 0x050A0F05, 0x9A2FB59A,     // 34-37
    0x070E0907, 0x12243612, 0x801B9B80, 0xE2DF3DE2,     // 38-3B
    0xEBCD26EB, 0x274E6927, 0xB27FCDB2, 0x75EA9F75,     // 3C-3F

    0x09121B09, 0x831D9E83, 0x2C58742C, 0x1A342E1A,     // 40-43
    0x1B362D1B, 0x6EDCB26E, 0x5AB4EE5A, 0xA05BFBA0,     // 44-47
    0x52A4F652, 0x3B764D3B, 0xD6B761D6, 0xB37DCEB3,     // 48-4B
    0x29527B29, 0xE3DD3EE3, 0x2F5E712F, 0x84139784,     // 4C-4F

    0x53A6F553, 0xD1B968D1, 0x00000000, 0xEDC12CED,     // 50-53
    0x20406020, 0xFCE31FFC, 0xB179C8B1, 0x5BB6ED5B,     // 54-57
    0x6AD4BE6A, 0xCB8D46CB, 0xBE67D9BE, 0x39724B39,     // 58-5B
    0x4A94DE4A, 0x4C98D44C, 0x58B0E858, 0xCF854ACF,     // 5C-5F

    0xD0BB6BD0, 0xEFC52AEF, 0xAA4FE5AA, 0xFBED16FB,     // 60-63
    0x4386C543, 0x4D9AD74D, 0x33665533, 0x85119485,     // 64-67
    0x458ACF45, 0xF9E910F9, 0x02040602, 0x7FFE817F,     // 68-6B
    0x50A0F050, 0x3C78443C, 0x9F25BA9F, 0xA84BE3A8,     // 6C-6F

    0x51A2F351, 0xA35DFEA3, 0x4080C040, 0x8F058A8F,     // 70-73
    0x923FAD92, 0x9D21BC9D, 0x38704838, 0xF5F104F5,     // 74-77
    0xBC63DFBC, 0xB677C1B6, 0xDAAF75DA, 0x21426321,     // 78-7B
    0x10203010, 0xFFE51AFF, 0xF3FD0EF3, 0xD2BF6DD2,     // 7C-7F

    0xCD814CCD, 0x0C18140C, 0x13263513, 0xECC32FEC,     // 80-83
    0x5FBEE15F, 0x9735A297, 0x4488CC44, 0x172E3917,     // 84-87
    0xC49357C4, 0xA755F2A7, 0x7EFC827E, 0x3D7A473D,     // 88-8B
    0x64C8AC64, 0x5DBAE75D, 0x19322B19, 0x73E69573,     // 8C-8F

    0x60C0A060, 0x81199881, 0x4F9ED14F, 0xDCA37FDC,     // 90-93
    0x22446622, 0x2A547E2A, 0x903BAB90, 0x880B8388,     // 94-97
    0x468CCA46, 0xEEC729EE, 0xB86BD3B8, 0x14283C14,     // 98-9B
    0xDEA779DE, 0x5EBCE25E, 0x0B161D0B, 0xDBAD76DB,     // 9C-9F

    0xE0DB3BE0, 0x32645632, 0x3A744E3A, 0x0A141E0A,     // A0-A3
    0x4992DB49, 0x060C0A06, 0x24486C24, 0x5CB8E45C,     // A4-A7
    0xC29F5DC2, 0xD3BD6ED3, 0xAC43EFAC, 0x62C4A662,     // A8-AB
    0x9139A891, 0x9531A495, 0xE4D337E4, 0x79F28B79,     // AC-AF

    0xE7D532E7, 0xC88B43C8, 0x376E5937, 0x6DDAB76D,     // B0-B3
    0x8D018C8D, 0xD5B164D5, 0x4E9CD24E, 0xA949E0A9,     // B4-B7
    0x6CD8B46C, 0x56ACFA56, 0xF4F307F4, 0xEACF25EA,     // B8-BB
    0x65CAAF65, 0x7AF48E7A, 0xAE47E9AE, 0x08101808,     // BC-BF

    0xBA6FD5BA, 0x78F08878, 0x254A6F25, 0x2E5C722E,     // C0-C3
    0x1C38241C, 0xA657F1A6, 0xB473C7B4, 0xC69751C6,     // C4-C7
    0xE8CB23E8, 0xDDA17CDD, 0x74E89C74, 0x1F3E211F,     // C8-CB
    0x4B96DD4B, 0xBD61DCBD, 0x8B0D868B, 0x8A0F858A,     // CC-CF

    0x70E09070, 0x3E7C423E, 0xB571C4B5, 0x66CCAA66,     // D0-D3
    0x4890D848, 0x03060503, 0xF6F701F6, 0x0E1C120E,     // D4-D7
    0x61C2A361, 0x356A5F35, 0x57AEF957, 0xB969D0B9,     // D8-DB
    0x86179186, 0xC19958C1, 0x1D3A271D, 0x9E27B99E,     // DC-DF

    0xE1D938E1, 0xF8EB13F8, 0x982BB398, 0x11223311,     // E0-E3
    0x69D2BB69, 0xD9A970D9, 0x8E07898E, 0x9433A794,     // E4-E7
    0x9B2DB69B, 0x1E3C221E, 0x87159287, 0xE9C920E9,     // E8-EB
    0xCE8749CE, 0x55AAFF55, 0x28507828, 0xDFA57ADF,     // EC-EF

    0x8C038F8C, 0xA159F8A1, 0x89098089, 0x0D1A170D,     // F0-F3
    0xBF65DABF, 0xE6D731E6, 0x4284C642, 0x68D0B868,     // F4-F7
    0x4182C341, 0x9929B099, 0x2D5A772D, 0x0F1E110F,     // F8-FB
    0xB07BCBB0, 0x54A8FC54, 0xBB6DD6BB, 0x162C3A16,     // FC-FF
};
//------------------------------------------------------
// Encryption Table T3
//------------------------------------------------------
static unsigned int unrs_tab_enc_unl_t3[256] = {
    0xC6A56363, 0xF8847C7C, 0xEE997777, 0xF68D7B7B,     // 00-03
    0xFF0DF2F2, 0xD6BD6B6B, 0xDEB16F6F, 0x9154C5C5,     // 04-07
    0x60503030, 0x02030101, 0xCEA96767, 0x567D2B2B,     // 08-0B
    0xE719FEFE, 0xB562D7D7, 0x4DE6ABAB, 0xEC9A7676,     // 0C-0F

    0x8F45CACA, 0x1F9D8282, 0x8940C9C9, 0xFA877D7D,     // 10-13
    0xEF15FAFA, 0xB2EB5959, 0x8EC94747, 0xFB0BF0F0,     // 14-17
    0x41ECADAD, 0xB367D4D4, 0x5FFDA2A2, 0x45EAAFAF,     // 18-1B
    0x23BF9C9C, 0x53F7A4A4, 0xE4967272, 0x9B5BC0C0,     // 1C-1F

    0x75C2B7B7, 0xE11CFDFD, 0x3DAE9393, 0x4C6A2626,     // 20-23
    0x6C5A3636, 0x7E413F3F, 0xF502F7F7, 0x834FCCCC,     // 24-27
    0x685C3434, 0x51F4A5A5, 0xD134E5E5, 0xF908F1F1,     // 28-2B
    0xE2937171, 0xAB73D8D8, 0x62533131, 0x2A3F1515,     // 2C-2F

    0x080C0404, 0x9552C7C7, 0x46652323, 0x9D5EC3C3,     // 30-33
    0x30281818, 0x37A19696, 0x0A0F0505, 0x2FB59A9A,     // 34-37
    0x0E090707, 0x24361212, 0x1B9B8080, 0xDF3DE2E2,     // 38-3B
    0xCD26EBEB, 0x4E692727, 0x7FCDB2B2, 0xEA9F7575,     // 3C-3F

    0x121B0909, 0x1D9E8383, 0x58742C2C, 0x342E1A1A,     // 40-43
    0x362D1B1B, 0xDCB26E6E, 0xB4EE5A5A, 0x5BFBA0A0,     // 44-47
    0xA4F65252, 0x764D3B3B, 0xB761D6D6, 0x7DCEB3B3,     // 48-4B
    0x527B2929, 0xDD3EE3E3, 0x5E712F2F, 0x13978484,     // 4C-4F

    0xA6F55353, 0xB968D1D1, 0x00000000, 0xC12CEDED,     // 50-53
    0x40602020, 0xE31FFCFC, 0x79C8B1B1, 0xB6ED5B5B,     // 54-57
    0xD4BE6A6A, 0x8D46CBCB, 0x67D9BEBE, 0x724B3939,     // 58-5B
    0x94DE4A4A, 0x98D44C4C, 0xB0E85858, 0x854ACFCF,     // 5C-5F

    0xBB6BD0D0, 0xC52AEFEF, 0x4FE5AAAA, 0xED16FBFB,     // 60-63
    0x86C54343, 0x9AD74D4D, 0x66553333, 0x11948585,     // 64-67
    0x8ACF4545, 0xE910F9F9, 0x04060202, 0xFE817F7F,     // 68-6B
    0xA0F05050, 0x78443C3C, 0x25BA9F9F, 0x4BE3A8A8,     // 6C-6F

    0xA2F35151, 0x5DFEA3A3, 0x80C04040, 0x058A8F8F,     // 70-73
    0x3FAD9292, 0x21BC9D9D, 0x70483838, 0xF104F5F5,     // 74-77
    0x63DFBCBC, 0x77C1B6B6, 0xAF75DADA, 0x42632121,     // 78-7B
    0x20301010, 0xE51AFFFF, 0xFD0EF3F3, 0xBF6DD2D2,     // 7C-7F

    0x814CCDCD, 0x18140C0C, 0x26351313, 0xC32FECEC,     // 80-83
    0xBEE15F5F, 0x35A29797, 0x88CC4444, 0x2E391717,     // 84-87
    0x9357C4C4, 0x55F2A7A7, 0xFC827E7E, 0x7A473D3D,     // 88-8B
    0xC8AC6464, 0xBAE75D5D, 0x322B1919, 0xE6957373,     // 8C-8F

    0xC0A06060, 0x19988181, 0x9ED14F4F, 0xA37FDCDC,     // 90-93
    0x44662222, 0x547E2A2A, 0x3BAB9090, 0x0B838888,     // 94-97
    0x8CCA4646, 0xC729EEEE, 0x6BD3B8B8, 0x283C1414,     // 98-9B
    0xA779DEDE, 0xBCE25E5E, 0x161D0B0B, 0xAD76DBDB,     // 9C-9F

    0xDB3BE0E0, 0x64563232, 0x744E3A3A, 0x141E0A0A,     // A0-A3
    0x92DB4949, 0x0C0A0606, 0x486C2424, 0xB8E45C5C,     // A4-A7
    0x9F5DC2C2, 0xBD6ED3D3, 0x43EFACAC, 0xC4A66262,     // A8-AB
    0x39A89191, 0x31A49595, 0xD337E4E4, 0xF28B7979,     // AC-AF

    0xD532E7E7, 0x8B43C8C8, 0x6E593737, 0xDAB76D6D,     // B0-B3
    0x018C8D8D, 0xB164D5D5, 0x9CD24E4E, 0x49E0A9A9,     // B4-B7
    0xD8B46C6C, 0xACFA5656, 0xF307F4F4, 0xCF25EAEA,     // B8-BB
    0xCAAF6565, 0xF48E7A7A, 0x47E9AEAE, 0x10180808,     // BC-BF

    0x6FD5BABA, 0xF0887878, 0x4A6F2525, 0x5C722E2E,     // C0-C3
    0x38241C1C, 0x57F1A6A6, 0x73C7B4B4, 0x9751C6C6,     // C4-C7
    0xCB23E8E8, 0xA17CDDDD, 0xE89C7474, 0x3E211F1F,     // C8-CB
    0x96DD4B4B, 0x61DCBDBD, 0x0D868B8B, 0x0F858A8A,     // CC-CF

    0xE0907070, 0x7C423E3E, 0x71C4B5B5, 0xCCAA6666,     // D0-D3
    0x90D84848, 0x06050303, 0xF701F6F6, 0x1C120E0E,     // D4-D7
    0xC2A36161, 0x6A5F3535, 0xAEF95757, 0x69D0B9B9,     // D8-DB
    0x17918686, 0x9958C1C1, 0x3A271D1D, 0x27B99E9E,     // DC-DF

    0xD938E1E1, 0xEB13F8F8, 0x2BB39898, 0x22331111,     // E0-E3
    0xD2BB6969, 0xA970D9D9, 0x07898E8E, 0x33A79494,     // E4-E7
    0x2DB69B9B, 0x3C221E1E, 0x15928787, 0xC920E9E9,     // E8-EB
    0x8749CECE, 0xAAFF5555, 0x50782828, 0xA57ADFDF,     // EC-EF

    0x038F8C8C, 0x59F8A1A1, 0x09808989, 0x1A170D0D,     // F0-F3
    0x65DABFBF, 0xD731E6E6, 0x84C64242, 0xD0B86868,     // F4-F7
    0x82C34141, 0x29B09999, 0x5A772D2D, 0x1E110F0F,     // F8-FB
    0x7BCBB0B0, 0xA8FC5454, 0x6DD6BBBB, 0x2C3A1616,     // FC-FF
};
//------------------------------------------------------
// Decryption Table T0
//------------------------------------------------------
static unsigned int unrs_tab_dec_unl_t0[256] = {
    0x50A7F451, 0x5365417E, 0xC3A4171A, 0x965E273A,     // 00-03
    0xCB6BAB3B, 0xF1459D1F, 0xAB58FAAC, 0x9303E34B,     // 04-07
    0x55FA3020, 0xF66D76AD, 0x9176CC88, 0x254C02F5,     // 08-0B
    0xFCD7E54F, 0xD7CB2AC5, 0x80443526, 0x8FA362B5,     // 0C-0F

    0x495AB1DE, 0x671BBA25, 0x980EEA45, 0xE1C0FE5D,     // 10-13
    0x02752FC3, 0x12F04C81, 0xA397468D, 0xC6F9D36B,     // 14-17
    0xE75F8F03, 0x959C9215, 0xEB7A6DBF, 0xDA595295,     // 18-1B
    0x2D83BED4, 0xD3217458, 0x2969E049, 0x44C8C98E,     // 1C-1F

    0x6A89C275, 0x78798EF4, 0x6B3E5899, 0xDD71B927,     // 20-23
    0xB64FE1BE, 0x17AD88F0, 0x66AC20C9, 0xB43ACE7D,     // 24-27
    0x184ADF63, 0x82311AE5, 0x60335197, 0x457F5362,     // 28-2B
    0xE07764B1, 0x84AE6BBB, 0x1CA081FE, 0x942B08F9,     // 2C-2F

    0x58684870, 0x19FD458F, 0x876CDE94, 0xB7F87B52,     // 30-33
    0x23D373AB, 0xE2024B72, 0x578F1FE3, 0x2AAB5566,     // 34-37
    0x0728EBB2, 0x03C2B52F, 0x9A7BC586, 0xA50837D3,     // 38-3B
    0xF2872830, 0xB2A5BF23, 0xBA6A0302, 0x5C8216ED,     // 3C-3F

    0x2B1CCF8A, 0x92B479A7, 0xF0F207F3, 0xA1E2694E,     // 40-43
    0xCDF4DA65, 0xD5BE0506, 0x1F6234D1, 0x8AFEA6C4,     // 44-47
    0x9D532E34, 0xA055F3A2, 0x32E18A05, 0x75EBF6A4,     // 48-4B
    0x39EC830B, 0xAAEF6040, 0x069F715E, 0x51106EBD,     // 4C-4F

    0xF98A213E, 0x3D06DD96, 0xAE053EDD, 0x46BDE64D,     // 50-53
    0xB58D5491, 0x055DC471, 0x6FD40604, 0xFF155060,     // 54-57
    0x24FB9819, 0x97E9BDD6, 0xCC434089, 0x779ED967,     // 58-5B
    0xBD42E8B0, 0x888B8907, 0x385B19E7, 0xDBEEC879,     // 5C-5F

    0x470A7CA1, 0xE90F427C, 0xC91E84F8, 0x00000000,     // 60-63
    0x83868009, 0x48ED2B32, 0xAC70111E, 0x4E725A6C,     // 64-67
    0xFBFF0EFD, 0x5638850F, 0x1ED5AE3D, 0x27392D36,     // 68-6B
    0x64D90F0A, 0x21A65C68, 0xD1545B9B, 0x3A2E3624,     // 6C-6F

    0xB1670A0C, 0x0FE75793, 0xD296EEB4, 0x9E919B1B,     // 70-73
    0x4FC5C080, 0xA220DC61, 0x694B775A, 0x161A121C,     // 74-77
    0x0ABA93E2, 0xE52AA0C0, 0x43E0223C, 0x1D171B12,     // 78-7B
    0x0B0D090E, 0xADC78BF2, 0xB9A8B62D, 0xC8A91E14,     // 7C-7F

    0x8519F157, 0x4C0775AF, 0xBBDD99EE, 0xFD607FA3,     // 80-83
    0x9F2601F7, 0xBCF5725C, 0xC53B6644, 0x347EFB5B,     // 84-87
    0x7629438B, 0xDCC623CB, 0x68FCEDB6, 0x63F1E4B8,     // 88-8B
    0xCADC31D7, 0x10856342, 0x40229713, 0x2011C684,     // 8C-8F

    0x7D244A85, 0xF83DBBD2, 0x1132F9AE, 0x6DA129C7,     // 90-93
    0x4B2F9E1D, 0xF330B2DC, 0xEC52860D, 0xD0E3C177,     // 94-97
    0x6C16B32B, 0x99B970A9, 0xFA489411, 0x2264E947,     // 98-9B
    0xC48CFCA8, 0x1A3FF0A0, 0xD82C7D56, 0xEF903322,     // 9C-9F

    0xC74E4987, 0xC1D138D9, 0xFEA2CA8C, 0x360BD498,     // A0-A3
    0xCF81F5A6, 0x28DE7AA5, 0x268EB7DA, 0xA4BFAD3F,     // A4-A7
    0xE49D3A2C, 0x0D927850, 0x9BCC5F6A, 0x62467E54,     // A8-AB
    0xC2138DF6, 0xE8B8D890, 0x5EF7392E, 0xF5AFC382,     // AC-AF

    0xBE805D9F, 0x7C93D069, 0xA92DD56F, 0xB31225CF,     // B0-B3
    0x3B99ACC8, 0xA77D1810, 0x6E639CE8, 0x7BBB3BDB,     // B4-B7
    0x097826CD, 0xF418596E, 0x01B79AEC, 0xA89A4F83,     // B8-BB
    0x656E95E6, 0x7EE6FFAA, 0x08CFBC21, 0xE6E815EF,     // BC-BF

    0xD99BE7BA, 0xCE366F4A, 0xD4099FEA, 0xD67CB029,     // C0-C3
    0xAFB2A431, 0x31233F2A, 0x3094A5C6, 0xC066A235,     // C4-C7
    0x37BC4E74, 0xA6CA82FC, 0xB0D090E0, 0x15D8A733,     // C8-CB
    0x4A9804F1, 0xF7DAEC41, 0x0E50CD7F, 0x2FF69117,     // CC-CF

    0x8DD64D76, 0x4DB0EF43, 0x544DAACC, 0xDF0496E4,     // D0-D3
    0xE3B5D19E, 0x1B886A4C, 0xB81F2CC1, 0x7F516546,     // D4-D7
    0x04EA5E9D, 0x5D358C01, 0x737487FA, 0x2E410BFB,     // D8-DB
    0x5A1D67B3, 0x52D2DB92, 0x335610E9, 0x1347D66D,     // DC-DF

    0x8C61D79A, 0x7A0CA137, 0x8E14F859, 0x893C13EB,     // E0-E3
    0xEE27A9CE, 0x35C961B7, 0xEDE51CE1, 0x3CB1477A,     // E4-E7
    0x59DFD29C, 0x3F73F255, 0x79CE1418, 0xBF37C773,     // E8-EB
    0xEACDF753, 0x5BAAFD5F, 0x146F3DDF, 0x86DB4478,     // EC-EF

    0x81F3AFCA, 0x3EC468B9, 0x2C342438, 0x5F40A3C2,     // F0-F3
    0x72C31D16, 0x0C25E2BC, 0x8B493C28, 0x41950DFF,     // F4-F7
    0x7101A839, 0xDEB30C08, 0x9CE4B4D8, 0x90C15664,     // F8-FB
    0x6184CB7B, 0x70B632D5, 0x745C6C48, 0x4257B8D0,     // FC-FF
};
//------------------------------------------------------
// Decryption Table T1
//------------------------------------------------------
static unsigned int unrs_tab_dec_unl_t1[256] = {
    0xA7F45150, 0x65417E53, 0xA4171AC3, 0x5E273A96,     // 00-03
    0x6BAB3BCB, 0x459D1FF1, 0x58FAACAB, 0x03E34B93,     // 04-07
    0xFA302055, 0x6D76ADF6, 0x76CC8891, 0x4C02F525,     // 08-0B
    0xD7E54FFC, 0xCB2AC5D7, 0x44352680, 0xA362B58F,     // 0C-0F

    0x5AB1DE49, 0x1BBA2567, 0x0EEA4598, 0xC0FE5DE1,     // 10-13
    0x752FC302, 0xF04C8112, 0x97468DA3, 0xF9D36BC6,     // 14-17
    0x5F8F03E7, 0x9C921595, 0x7A6DBFEB, 0x595295DA,     // 18-1B
    0x83BED42D, 0x217458D3, 0x69E04929, 0xC8C98E44,     // 1C-1F

    0x89C2756A, 0x798EF478, 0x3E58996B, 0x71B927DD,     // 20-23
    0x4FE1BEB6, 0xAD88F017, 0xAC20C966, 0x3ACE7DB4,     // 24-27
    0x4ADF6318, 0x311AE582, 0x33519760, 0x7F536245,     // 28-2B
    0x7764B1E0, 0xAE6BBB84, 0xA081FE1C, 0x2B08F994,     // 2C-2F

    0x68487058, 0xFD458F19, 0x6CDE9487, 0xF87B52B7,     // 30-33
    0xD373AB23, 0x024B72E2, 0x8F1FE357, 0xAB55662A,     // 34-37
    0x28EBB207, 0xC2B52F03, 0x7BC5869A, 0x0837D3A5,     // 38-3B
    0x872830F2, 0xA5BF23B2, 0x6A0302BA, 0x8216ED5C,     // 3C-3F

    0x1CCF8A2B, 0xB479A792, 0xF207F3F0, 0xE2694EA1,     // 40-43
    0xF4DA65CD, 0xBE0506D5, 0x6234D11F, 0xFEA6C48A,     // 44-47
    0x532E349D, 0x55F3A2A0, 0xE18A0532, 0xEBF6A475,     // 48-4B
    0xEC830B39, 0xEF6040AA, 0x9F715E06, 0x106EBD51,     // 4C-4F

    0x8A213EF9, 0x06DD963D, 0x053EDDAE, 0xBDE64D46,     // 50-53
    0x8D5491B5, 0x5DC47105, 0xD406046F, 0x155060FF,     // 54-57
    0xFB981924, 0xE9BDD697, 0x434089CC, 0x9ED96777,     // 58-5B
    0x42E8B0BD, 0x8B890788, 0x5B19E738, 0xEEC879DB,     // 5C-5F

    0x0A7CA147, 0x0F427CE9, 0x1E84F8C9, 0x00000000,     // 60-63
    0x86800983, 0xED2B3248, 0x70111EAC, 0x725A6C4E,     // 64-67
    0xFF0EFDFB, 0x38850F56, 0xD5AE3D1E, 0x392D3627,     // 68-6B
    0xD90F0A64, 0xA65C6821, 0x545B9BD1, 0x2E36243A,     // 6C-6F

    0x670A0CB1, 0xE757930F, 0x96EEB4D2, 0x919B1B9E,     // 70-73
    0xC5C0804F, 0x20DC61A2, 0x4B775A69, 0x1A121C16,     // 74-77
    0xBA93E20A, 0x2AA0C0E5, 0xE0223C43, 0x171B121D,     // 78-7B
    0x0D090E0B, 0xC78BF2AD, 0xA8B62DB9, 0xA91E14C8,     // 7C-7F

    0x19F15785, 0x0775AF4C, 0xDD99EEBB, 0x607FA3FD,     // 80-83
    0x2601F79F, 0xF5725CBC, 0x3B6644C5, 0x7EFB5B34,     // 84-87
    0x29438B76, 0xC623CBDC, 0xFCEDB668, 0xF1E4B863,     // 88-8B
    0xDC31D7CA, 0x85634210, 0x22971340, 0x11C68420,     // 8C-8F

    0x244A857D, 0x3DBBD2F8, 0x32F9AE11, 0xA129C76D,     // 90-93
    0x2F9E1D4B, 0x30B2DCF3, 0x52860DEC, 0xE3C177D0,     // 94-97
    0x16B32B6C, 0xB970A999, 0x489411FA, 0x64E94722,     // 98-9B
    0x8CFCA8C4, 0x3FF0A01A, 0x2C7D56D8, 0x903322EF,     // 9C-9F

    0x4E4987C7, 0xD138D9C1, 0xA2CA8CFE, 0x0BD49836,     // A0-A3
    0x81F5A6CF, 0xDE7AA528, 0x8EB7DA26, 0xBFAD3FA4,     // A4-A7
    0x9D3A2CE4, 0x9278500D, 0xCC5F6A9B, 0x467E5462,     // A8-AB
    0x138DF6C2, 0xB8D890E8, 0xF7392E5E, 0xAFC382F5,     // AC-AF

    0x805D9FBE, 0x93D0697C, 0x2DD56FA9, 0x1225CFB3,     // B0-B3
    0x99ACC83B, 0x7D1810A7, 0x639CE86E, 0xBB3BDB7B,     // B4-B7
    0x7826CD09, 0x18596EF4, 0xB79AEC01, 0x9A4F83A8,     // B8-BB
    0x6E95E665, 0xE6FFAA7E, 0xCFBC2108, 0xE815EFE6,     // BC-BF

    0x9BE7BAD9, 0x366F4ACE, 0x099FEAD4, 0x7CB029D6,     // C0-C3
    0xB2A431AF, 0x233F2A31, 0x94A5C630, 0x66A235C0,     // C4-C7
    0xBC4E7437, 0xCA82FCA6, 0xD090E0B0, 0xD8A73315,     // C8-CB
    0x9804F14A, 0xDAEC41F7, 0x50CD7F0E, 0xF691172F,     // CC-CF

    0xD64D768D, 0xB0EF434D, 0x4DAACC54, 0x0496E4DF,     // D0-D3
    0xB5D19EE3, 0x886A4C1B, 0x1F2CC1B8, 0x5165467F,     // D4-D7
    0xEA5E9D04, 0x358C015D, 0x7487FA73, 0x410BFB2E,     // D8-DB
    0x1D67B35A, 0xD2DB9252, 0x5610E933, 0x47D66D13,     // DC-DF

    0x61D79A8C, 0x0CA1377A, 0x14F8598E, 0x3C13EB89,     // E0-E3
    0x27A9CEEE, 0xC961B735, 0xE51CE1ED, 0xB1477A3C,     // E4-E7
    0xDFD29C59, 0x73F2553F, 0xCE141879, 0x37C773BF,     // E8-EB
    0xCDF753EA, 0xAAFD5F5B, 0x6F3DDF14, 0xDB447886,     // EC-EF

    0xF3AFCA81, 0xC468B93E, 0x3424382C, 0x40A3C25F,     // F0-F3
    0xC31D1672, 0x25E2BC0C, 0x493C288B, 0x950DFF41,     // F4-F7
    0x01A83971, 0xB30C08DE, 0xE4B4D89C, 0xC1566490,     // F8-FB
    0x84CB7B61, 0xB632D570, 0x5C6C4874, 0x57B8D042,     // FC-FF
};
//------------------------------------------------------
// Decryption Table T2
//------------------------------------------------------
static unsigned int unrs_tab_dec_unl_t2[256] = {
    0xF45150A7, 0x417E5365, 0x171AC3A4, 0x273A965E,     // 00-03
    0xAB3BCB6B, 0x9D1FF145, 0xFAACAB58, 0xE34B9303,     // 04-07
    0x302055FA, 0x76ADF66D, 0xCC889176, 0x02F5254C,     // 08-0B
    0xE54FFCD7, 0x2AC5D7CB, 0x35268044, 0x62B58FA3,     // 0C-0F

    0xB1DE495A, 0xBA25671B, 0xEA45980E, 0xFE5DE1C0,     // 10-13
    0x2FC30275, 0x4C8112F0, 0x468DA397, 0xD36BC6F9,     // 14-17
    0x8F03E75F, 0x9215959C, 0x6DBFEB7A, 0x5295DA59,     // 18-1B
    0xBED42D83, 0x7458D321, 0xE0492969, 0xC98E44C8,     // 1C-1F

    0xC2756A89, 0x8EF47879, 0x58996B3E, 0xB927DD71,     // 20-23
    0xE1BEB64F, 0x88F017AD, 0x20C966AC, 0xCE7DB43A,     // 24-27
    0xDF63184A, 0x1AE58231, 0x51976033, 0x5362457F,     // 28-2B
    0x64B1E077, 0x6BBB84AE, 0x81FE1CA0, 0x08F9942B,     // 2C-2F

    0x48705868, 0x458F19FD, 0xDE94876C, 0x7B52B7F8,     // 30-33
    0x73AB23D3, 0x4B72E202, 0x1FE3578F, 0x55662AAB,     // 34-37
    0xEBB20728, 0xB52F03C2, 0xC5869A7B, 0x37D3A508,     // 38-3B
    0x2830F287, 0xBF23B2A5, 0x0302BA6A, 0x16ED5C82,     // 3C-3F

    0xCF8A2B1C, 0x79A792B4, 0x07F3F0F2, 0x694EA1E2,     // 40-43
    0xDA65CDF4, 0x0506D5BE, 0x34D11F62, 0xA6C48AFE,     // 44-47
    0x2E349D53, 0xF3A2A055, 0x8A0532E1, 0xF6A475EB,     // 48-4B
    0x830B39EC, 0x6040AAEF, 0x715E069F, 0x6EBD5110,     // 4C-4F

    0x213EF98A, 0xDD963D06, 0x3EDDAE05, 0xE64D46BD,     // 50-53
    0x5491B58D, 0xC471055D, 0x06046FD4, 0x5060FF15,     // 54-57
    0x981924FB, 0xBDD697E9, 0x4089CC43, 0xD967779E,     // 58-5B
    0xE8B0BD42, 0x8907888B, 0x19E7385B, 0xC879DBEE,     // 5C-5F

    0x7CA1470A, 0x427CE90F, 0x84F8C91E, 0x00000000,     // 60-63
    0x80098386, 0x2B3248ED, 0x111EAC70, 0x5A6C4E72,     // 64-67
    0x0EFDFBFF, 0x850F5638, 0xAE3D1ED5, 0x2D362739,     // 68-6B
    0x0F0A64D9, 0x5C6821A6, 0x5B9BD154, 0x36243A2E,     // 6C-6F

    0x0A0CB167, 0x57930FE7, 0xEEB4D296, 0x9B1B9E91,     // 70-73
    0xC0804FC5, 0xDC61A220, 0x775A694B, 0x121C161A,     // 74-77
    0x93E20ABA, 0xA0C0E52A, 0x223C43E0, 0x1B121D17,     // 78-7B
    0x090E0B0D, 0x8BF2ADC7, 0xB62DB9A8, 0x1E14C8A9,     // 7C-7F

    0xF1578519, 0x75AF4C07, 0x99EEBBDD, 0x7FA3FD60,     // 80-83
    0x01F79F26, 0x725CBCF5, 0x6644C53B, 0xFB5B347E,     // 84-87
    0x438B7629, 0x23CBDCC6, 0xEDB668FC, 0xE4B863F1,     // 88-8B
    0x31D7CADC, 0x63421085, 0x97134022, 0xC6842011,     // 8C-8F

    0x4A857D24, 0xBBD2F83D, 0xF9AE1132, 0x29C76DA1,     // 90-93
    0x9E1D4B2F, 0xB2DCF330, 0x860DEC52, 0xC177D0E3,     // 94-97
    0xB32B6C16, 0x70A999B9, 0x9411FA48, 0xE9472264,     // 98-9B
    0xFCA8C48C, 0xF0A01A3F, 0x7D56D82C, 0x3322EF90,     // 9C-9F

    0x4987C74E, 0x38D9C1D1, 0xCA8CFEA2, 0xD498360B,     // A0-A3
    0xF5A6CF81, 0x7AA528DE, 0xB7DA268E, 0xAD3FA4BF,     // A4-A7
    0x3A2CE49D, 0x78500D92, 0x5F6A9BCC, 0x7E546246,     // A8-AB
    0x8DF6C213, 0xD890E8B8, 0x392E5EF7, 0xC382F5AF,     // AC-AF

    0x5D9FBE80, 0xD0697C93, 0xD56FA92D, 0x25CFB312,     // B0-B3
    0xACC83B99, 0x1810A77D, 0x9CE86E63, 0x3BDB7BBB,     // B4-B7
    0x26CD0978, 0x596EF418, 0x9AEC01B7, 0x4F83A89A,     // B8-BB
    0x95E6656E, 0xFFAA7EE6, 0xBC2108CF, 0x15EFE6E8,     // BC-BF

    0xE7BAD99B, 0x6F4ACE36, 0x9FEAD409, 0xB029D67C,     // C0-C3
    0xA431AFB2, 0x3F2A3123, 0xA5C63094, 0xA235C066,     // C4-C7
    0x4E7437BC, 0x82FCA6CA, 0x90E0B0D0, 0xA73315D8,     // C8-CB
    0x04F14A98, 0xEC41F7DA, 0xCD7F0E50, 0x91172FF6,     // CC-CF

    0x4D768DD6, 0xEF434DB0, 0xAACC544D, 0x96E4DF04,     // D0-D3
    0xD19EE3B5, 0x6A4C1B88, 0x2CC1B81F, 0x65467F51,     // D4-D7
    0x5E9D04EA, 0x8C015D35, 0x87FA7374, 0x0BFB2E41,     // D8-DB
    0x67B35A1D, 0xDB9252D2, 0x10E93356, 0xD66D1347,     // DC-DF

    0xD79A8C61, 0xA1377A0C, 0xF8598E14, 0x13EB893C,     // E0-E3
    0xA9CEEE27, 0x61B735C9, 0x1CE1EDE5, 0x477A3CB1,     // E4-E7
    0xD29C59DF, 0xF2553F73, 0x141879CE, 0xC773BF37,     // E8-EB
    0xF753EACD, 0xFD5F5BAA, 0x3DDF146F, 0x447886DB,     // EC-EF

    0xAFCA81F3, 0x68B93EC4, 0x24382C34, 0xA3C25F40,     // F0-F3
    0x1D1672C3, 0xE2BC0C25, 0x3C288B49, 0x0DFF4195,     // F4-F7
    0xA8397101, 0x0C08DEB3, 0xB4D89CE4, 0x566490C1,     // F8-FB
    0xCB7B6184, 0x32D570B6, 0x6C48745C, 0xB8D04257,     // FC-FF
};
//------------------------------------------------------
// Decryption Table T3
//------------------------------------------------------
static unsigned int unrs_tab_dec_unl_t3[256] = {
    0x5150A7F4, 0x7E536541, 0x1AC3A417, 0x3A965E27,     // 00-03
    0x3BCB6BAB, 0x1FF1459D, 0xACAB58FA, 0x4B9303E3,     // 04-07
    0x2055FA30, 0xADF66D76, 0x889176CC, 0xF5254C02,     // 08-0B
    0x4FFCD7E5, 0xC5D7CB2A, 0x26804435, 0xB58FA362,     // 0C-0F

    0xDE495AB1, 0x25671BBA, 0x45980EEA, 0x5DE1C0FE,     // 10-13
    0xC302752F, 0x8112F04C, 0x8DA39746, 0x6BC6F9D3,     // 14-17
    0x03E75F8F, 0x15959C92, 0xBFEB7A6D, 0x95DA5952,     // 18-1B
    0xD42D83BE, 0x58D32174, 0x492969E0, 0x8E44C8C9,     // 1C-1F

    0x756A89C2, 0xF478798E, 0x996B3E58, 0x27DD71B9,     // 20-23
    0xBEB64FE1, 0xF017AD88, 0xC966AC20, 0x7DB43ACE,     // 24-27
    0x63184ADF, 0xE582311A, 0x97603351, 0x62457F53,     // 28-2B
    0xB1E07764, 0xBB84AE6B, 0xFE1CA081, 0xF9942B08,     // 2C-2F

    0x70586848, 0x8F19FD45, 0x94876CDE, 0x52B7F87B,     // 30-33
    0xAB23D373, 0x72E2024B, 0xE3578F1F, 0x662AAB55,     // 34-37
    0xB20728EB, 0x2F03C2B5, 0x869A7BC5, 0xD3A50837,     // 38-3B
    0x30F28728, 0x23B2A5BF, 0x02BA6A03, 0xED5C8216,     // 3C-3F

    0x8A2B1CCF, 0xA792B479, 0xF3F0F207, 0x4EA1E269,     // 40-43
    0x65CDF4DA, 0x06D5BE05, 0xD11F6234, 0xC48AFEA6,     // 44-47
    0x349D532E, 0xA2A055F3, 0x0532E18A, 0xA475EBF6,     // 48-4B
    0x0B39EC83, 0x40AAEF60, 0x5E069F71, 0xBD51106E,     // 4C-4F

    0x3EF98A21, 0x963D06DD, 0xDDAE053E, 0x4D46BDE6,     // 50-53
    0x91B58D54, 0x71055DC4, 0x046FD406, 0x60FF1550,     // 54-57
    0x1924FB98, 0xD697E9BD, 0x89CC4340, 0x67779ED9,     // 58-5B
    0xB0BD42E8, 0x07888B89, 0xE7385B19, 0x79DBEEC8,     // 5C-5F

    0xA1470A7C, 0x7CE90F42, 0xF8C91E84, 0x00000000,     // 60-63
    0x09838680, 0x3248ED2B, 0x1EAC7011, 0x6C4E725A,     // 64-67
    0xFDFBFF0E, 0x0F563885, 0x3D1ED5AE, 0x3627392D,     // 68-6B
    0x0A64D90F, 0x6821A65C, 0x9BD1545B, 0x243A2E36,     // 6C-6F

    0x0CB1670A, 0x930FE757, 0xB4D296EE, 0x1B9E919B,     // 70-73
    0x804FC5C0, 0x61A220DC, 0x5A694B77, 0x1C161A12,     // 74-77
    0xE20ABA93, 0xC0E52AA0, 0x3C43E022, 0x121D171B,     // 78-7B
    0x0E0B0D09, 0xF2ADC78B, 0x2DB9A8B6, 0x14C8A91E,     // 7C-7F

    0x578519F1, 0xAF4C0775, 0xEEBBDD99, 0xA3FD607F,     // 80-83
    0xF79F2601, 0x5CBCF572, 0x44C53B66, 0x5B347EFB,     // 84-87
    0x8B762943, 0xCBDCC623, 0xB668FCED, 0xB863F1E4,     // 88-8B
    0xD7CADC31, 0x42108563, 0x13402297, 0x842011C6,     // 8C-8F

    0x857D244A, 0xD2F83DBB, 0xAE1132F9, 0xC76DA129,     // 90-93
    0x1D4B2F9E, 0xDCF330B2, 0x0DEC5286, 0x77D0E3C1,     // 94-97
    0x2B6C16B3, 0xA999B970, 0x11FA4894, 0x472264E9,     // 98-9B
    0xA8C48CFC, 0xA01A3FF0, 0x56D82C7D, 0x22EF9033,     // 9C-9F

    0x87C74E49, 0xD9C1D138, 0x8CFEA2CA, 0x98360BD4,     // A0-A3
    0xA6CF81F5, 0xA528DE7A, 0xDA268EB7, 0x3FA4BFAD,     // A4-A7
    0x2CE49D3A, 0x500D9278, 0x6A9BCC5F, 0x5462467E,     // A8-AB
    0xF6C2138D, 0x90E8B8D8, 0x2E5EF739, 0x82F5AFC3,     // AC-AF

    0x9FBE805D, 0x697C93D0, 0x6FA92DD5, 0xCFB31225,     // B0-B3
    0xC83B99AC, 0x10A77D18, 0xE86E639C, 0xDB7BBB3B,     // B4-B7
    0xCD097826, 0x6EF41859, 0xEC01B79A, 0x83A89A4F,     // B8-BB
    0xE6656E95, 0xAA7EE6FF, 0x2108CFBC, 0xEFE6E815,     // BC-BF

    0xBAD99BE7, 0x4ACE366F, 0xEAD4099F, 0x29D67CB0,     // C0-C3
    0x31AFB2A4, 0x2A31233F, 0xC63094A5, 0x35C066A2,     // C4-C7
    0x7437BC4E, 0xFCA6CA82, 0xE0B0D090, 0x3315D8A7,     // C8-CB
    0xF14A9804, 0x41F7DAEC, 0x7F0E50CD, 0x172FF691,     // CC-CF

    0x768DD64D, 0x434DB0EF, 0xCC544DAA, 0xE4DF0496,     // D0-D3
    0x9EE3B5D1, 0x4C1B886A, 0xC1B81F2C, 0x467F5165,     // D4-D7
    0x9D04EA5E, 0x015D358C, 0xFA737487, 0xFB2E410B,     // D8-DB
    0xB35A1D67, 0x9252D2DB, 0xE9335610, 0x6D1347D6,     // DC-DF

    0x9A8C61D7, 0x377A0CA1, 0x598E14F8, 0xEB893C13,     // E0-E3
    0xCEEE27A9, 0xB735C961, 0xE1EDE51C, 0x7A3CB147,     // E4-E7
    0x9C59DFD2, 0x553F73F2, 0x1879CE14, 0x73BF37C7,     // E8-EB
    0x53EACDF7, 0x5F5BAAFD, 0xDF146F3D, 0x7886DB44,     // EC-EF

    0xCA81F3AF, 0xB93EC468, 0x382C3424, 0xC25F40A3,     // F0-F3
    0x1672C31D, 0xBC0C25E2, 0x288B493C, 0xFF41950D,     // F4-F7
    0x397101A8, 0x08DEB30C, 0xD89CE4B4, 0x6490C156,     // F8-FB
    0x7B6184CB, 0xD570B632, 0x48745C6C, 0xD04257B8,     // FC-FF
};

// constants for AES GCM
static const unsigned int uns_aes_128_key_size = 16;
static const unsigned int uns_aes_192_key_size = 24;
static const unsigned int uns_aes_256_key_size = 32;
static const unsigned int uns_aes_128_rounds = 10;
static const unsigned int uns_aes_192_rounds = 12;
static const unsigned int uns_aes_256_rounds = 14;
static const unsigned int uns_gcm_iv_default_len = 12;
static const long long ulcs_gf128_mod_u64 = 0xE100000000000000LL;

// Faster than inline function
#define IS_SET_BIT(byte,num) ( (byte) & (1<<(num)) )


//***********************************************************
//
// Processing Routines with special 32 Bit Table support (9 kB),
// all tested
//
// VERY IMPORTANT NOTE:
// --------------------
// The Tables and associated processing routines are BYTE REVERSED
// compared to the original RIJNDAEL fast mode reference code.
// This reduces Byte to DWord/DWord to Byte conversion overhead on
// Little Endian machines [INTEL]
//
//***********************************************************

void m_aes_init_enc_key_sw(struct dsd_cipher_key* adsp_key,
                           const unsigned char* abyp_key,
                           size_t szp_key_len)
{
    unsigned int * aunl_enc_keytab = (unsigned int *)adsp_key->byrc_aes_expkey;
    size_t szl_aes_key_len = (szp_key_len >> 2);
    size_t szl_max_round_index = szp_key_len + 28 - 1;  // ((nk+6) + 1) * nb (-1)
    size_t szl_index = szl_aes_key_len - 1;
    unsigned char byl_remainder;
    unsigned int unl_r_con = 0x01;
    unsigned int unl_s;

    adsp_key->unc_key_size = (unsigned int)szp_key_len;
    //---------------------------------------------------------
    // Copy the key data to the array
    //---------------------------------------------------------
    ms_read_little_endian(aunl_enc_keytab[0], abyp_key + 0);
    ms_read_little_endian(aunl_enc_keytab[1], abyp_key + 4);
    ms_read_little_endian(aunl_enc_keytab[2], abyp_key + 8);
    ms_read_little_endian(aunl_enc_keytab[3], abyp_key + 12);

    if (szp_key_len == 16) {}else if (szp_key_len == 24) {
        ms_read_little_endian(aunl_enc_keytab[4], abyp_key + 16);
        ms_read_little_endian(aunl_enc_keytab[5], abyp_key + 20);
    }else {  // szp_key_len == 32
        ms_read_little_endian(aunl_enc_keytab[4], abyp_key + 16);
        ms_read_little_endian(aunl_enc_keytab[5], abyp_key + 20);
        ms_read_little_endian(aunl_enc_keytab[6], abyp_key + 24);
        ms_read_little_endian(aunl_enc_keytab[7], abyp_key + 28);
    }
    //--------------------------------------------------------
    // Expand the key for the number of rounds required
    //--------------------------------------------------------
    do {
        unl_s = aunl_enc_keytab[szl_index++];           // get last key, advance
        byl_remainder = (unsigned char)(szl_index % szl_aes_key_len); // get modulus remainder
        if (byl_remainder == 0) {           // at a specific index
            unl_s = ((( byrs_s_box[unl_s         & 0xFF] & 0xFF) << 24) |
                     (( byrs_s_box[(unl_s >> 24) & 0xFF] & 0xFF) << 16) |
                     (( byrs_s_box[(unl_s >> 16) & 0xFF] & 0xFF) << 8) |
                     (( byrs_s_box[(unl_s >>  8) & 0xFF] & 0xFF))) ^ unl_r_con;
            unl_r_con <<= 1;                // times 2
            if((unl_r_con & 0x100) != 0) {          // was 1 00
                unl_r_con = 0x1B;               // reduce modulo 1 1B
            }
        }else if ((szp_key_len == 32) && (byl_remainder == 4)) {
            unl_s = (  byrs_s_box[unl_s         & 0xFF] & 0xFF) |
                    (( byrs_s_box[(unl_s >>  8) & 0xFF] & 0xFF) <<  8) |
                    (( byrs_s_box[(unl_s >> 16) & 0xFF] & 0xFF) << 16) |
                    (( byrs_s_box[(unl_s >> 24) & 0xFF] & 0xFF) << 24);
        }
        aunl_enc_keytab[szl_index] = aunl_enc_keytab[szl_index - szl_aes_key_len] ^ unl_s;
    } while (szl_index < szl_max_round_index);
} // m_aes_init_enc_key_sw


void m_aes_init_dec_key_sw(struct dsd_cipher_key* adsp_key,
                           const unsigned char* abyp_key,
                           size_t szp_key_len)
{
    size_t szl_aes_key_len = (szp_key_len >> 2);
    unsigned int * aunl_dec_keytab = (unsigned int *) adsp_key->byrc_aes_expkey;
    size_t szl_src_index;
    size_t szl_dst_index;
    size_t szl_rounds = szl_aes_key_len + 6 - 2;    // not for first/last
    unsigned int unl_s0, unl_s1, unl_s2, unl_s3;

    adsp_key->unc_key_size = (unsigned int) szp_key_len;
    //---------------------------------------------------------------
    // 1. Expand the key same as for encryption mode
    //---------------------------------------------------------------
    m_aes_init_enc_key_sw(adsp_key, abyp_key, szp_key_len);
    //---------------------------------------------------------------
    // 2. Change order of keys in Blocks of 4
    //---------------------------------------------------------------
    szl_src_index = 0;
    szl_dst_index = (szl_aes_key_len + 6) * 4;      // last quadruple
    do {
        unl_s0 = aunl_dec_keytab[szl_dst_index+0];
        unl_s1 = aunl_dec_keytab[szl_dst_index+1];
        unl_s2 = aunl_dec_keytab[szl_dst_index+2];
        unl_s3 = aunl_dec_keytab[szl_dst_index+3];

        aunl_dec_keytab[szl_dst_index+0] = aunl_dec_keytab[szl_src_index+0];
        aunl_dec_keytab[szl_dst_index+1] = aunl_dec_keytab[szl_src_index+1];
        aunl_dec_keytab[szl_dst_index+2] = aunl_dec_keytab[szl_src_index+2];
        aunl_dec_keytab[szl_dst_index+3] = aunl_dec_keytab[szl_src_index+3];

        aunl_dec_keytab[szl_src_index+0] = unl_s0;
        aunl_dec_keytab[szl_src_index+1] = unl_s1;
        aunl_dec_keytab[szl_src_index+2] = unl_s2;
        aunl_dec_keytab[szl_src_index+3] = unl_s3;

        szl_src_index += 4;
        szl_dst_index -= 4;
    } while (szl_src_index < szl_dst_index);
    //---------------------------------------------------------------
    // 2. Inverse Mix Columns for Element Indices 1 ... KeyLen-2
    //---------------------------------------------------------------
    szl_rounds = szl_aes_key_len + 6 - 1;   // not for first/last
    szl_src_index = 4;
    do {
        //-------------------------------------------------------------
        // fetch 4 contiguous keys, process through tables
        // NOTE: watch for the Indirect szl_index processing via S-Box !!!
        //-------------------------------------------------------------
        unl_s0 = aunl_dec_keytab[szl_src_index+0];
        unl_s1 = aunl_dec_keytab[szl_src_index+1];
        unl_s2 = aunl_dec_keytab[szl_src_index+2];
        unl_s3 = aunl_dec_keytab[szl_src_index+3];

        aunl_dec_keytab[szl_src_index+0] =
            unrs_tab_dec_unl_t0[byrs_s_box[ unl_s0        & 0xFF] & 0xFF] ^
            unrs_tab_dec_unl_t1[byrs_s_box[(unl_s0 >>  8) & 0xFF] & 0xFF] ^
            unrs_tab_dec_unl_t2[byrs_s_box[(unl_s0 >> 16) & 0xFF] & 0xFF] ^
            unrs_tab_dec_unl_t3[byrs_s_box[(unl_s0 >> 24) & 0xFF] & 0xFF];

        aunl_dec_keytab[szl_src_index+1] =
            unrs_tab_dec_unl_t0[byrs_s_box[unl_s1         & 0xFF] & 0xFF] ^
            unrs_tab_dec_unl_t1[byrs_s_box[(unl_s1 >>  8) & 0xFF] & 0xFF] ^
            unrs_tab_dec_unl_t2[byrs_s_box[(unl_s1 >> 16) & 0xFF] & 0xFF] ^
            unrs_tab_dec_unl_t3[byrs_s_box[(unl_s1 >> 24) & 0xFF] & 0xFF];

        aunl_dec_keytab[szl_src_index+2] =
            unrs_tab_dec_unl_t0[byrs_s_box[unl_s2         & 0xFF] & 0xFF] ^
            unrs_tab_dec_unl_t1[byrs_s_box[(unl_s2 >>  8) & 0xFF] & 0xFF] ^
            unrs_tab_dec_unl_t2[byrs_s_box[(unl_s2 >> 16) & 0xFF] & 0xFF] ^
            unrs_tab_dec_unl_t3[byrs_s_box[(unl_s2 >> 24) & 0xFF] & 0xFF];

        aunl_dec_keytab[szl_src_index+3] =
            unrs_tab_dec_unl_t0[byrs_s_box[unl_s3         & 0xFF] & 0xFF] ^
            unrs_tab_dec_unl_t1[byrs_s_box[(unl_s3 >>  8) & 0xFF] & 0xFF] ^
            unrs_tab_dec_unl_t2[byrs_s_box[(unl_s3 >> 16) & 0xFF] & 0xFF] ^
            unrs_tab_dec_unl_t3[byrs_s_box[(unl_s3 >> 24) & 0xFF] & 0xFF];

        szl_src_index += 4;
        szl_rounds--;
    } while (szl_rounds != 0);
} // m_aes_init_dec_key_sw


void m_aes_cbc_encrypt_sw(unsigned char* abyp_output,
                          const unsigned char* abyp_input,
                          size_t szp_len,
                          const struct dsd_cipher_key* adsp_key,
                          const unsigned char* abyp_iv)
{
    size_t szl_blk_cnt = szp_len >> 4;
    const unsigned int * aunl_enc_keytab = (const unsigned int *)adsp_key->byrc_aes_expkey;
    unsigned int unl_s0, unl_s1, unl_s2, unl_s3;
    unsigned int unl_t0, unl_t1, unl_t2, unl_t3;
    unsigned int unrl_xor[4];
    unsigned int unrl_s[4];
    //-----------------------------------------------------------
    // load IV Vector
    //-----------------------------------------------------------
    ms_read_little_endian(unrl_xor[0], abyp_iv + 0);        // get bytes 0-3
    ms_read_little_endian(unrl_xor[1], abyp_iv + 4);        // get bytes 4-7
    ms_read_little_endian(unrl_xor[2], abyp_iv + 8);        // get bytes 8-11
    ms_read_little_endian(unrl_xor[3], abyp_iv + 12);       // get bytes 12-15
    //-----------------------------------------------------------
    // Encrypt Blocks, full unrolled loops
    //-----------------------------------------------------------
    for(; szl_blk_cnt > 0; szl_blk_cnt--) {
        ms_read_little_endian(unrl_s[0], abyp_input + 0);       // get bytes 0-3
        ms_read_little_endian(unrl_s[1], abyp_input + 4);       // get bytes 4-7
        ms_read_little_endian(unrl_s[2], abyp_input + 8);       // get bytes 8-11
        ms_read_little_endian(unrl_s[3], abyp_input + 12);  // get bytes 12-15

        unl_s0 = unrl_s[0] ^ unrl_xor[0] ^ aunl_enc_keytab[0];
        unl_s1 = unrl_s[1] ^ unrl_xor[1] ^ aunl_enc_keytab[1];
        unl_s2 = unrl_s[2] ^ unrl_xor[2] ^ aunl_enc_keytab[2];
        unl_s3 = unrl_s[3] ^ unrl_xor[3] ^ aunl_enc_keytab[3];
        //-------------------------------------------------
        // Perform Table processing for all 10/12/14 rounds
        //-------------------------------------------------
        AES_ENC_ROUND(unl_t0,unl_t1,unl_t2,unl_t3,unl_s0,unl_s1,unl_s2,unl_s3,aunl_enc_keytab,0);   // Round 1
        AES_ENC_ROUND(unl_s0,unl_s1,unl_s2,unl_s3,unl_t0,unl_t1,unl_t2,unl_t3,aunl_enc_keytab,1);   // Round 2
        AES_ENC_ROUND(unl_t0,unl_t1,unl_t2,unl_t3,unl_s0,unl_s1,unl_s2,unl_s3,aunl_enc_keytab,2);   // Round 3
        AES_ENC_ROUND(unl_s0,unl_s1,unl_s2,unl_s3,unl_t0,unl_t1,unl_t2,unl_t3,aunl_enc_keytab,3);   // Round 4
        AES_ENC_ROUND(unl_t0,unl_t1,unl_t2,unl_t3,unl_s0,unl_s1,unl_s2,unl_s3,aunl_enc_keytab,4);   // Round 5
        AES_ENC_ROUND(unl_s0,unl_s1,unl_s2,unl_s3,unl_t0,unl_t1,unl_t2,unl_t3,aunl_enc_keytab,5);   // Round 6
        AES_ENC_ROUND(unl_t0,unl_t1,unl_t2,unl_t3,unl_s0,unl_s1,unl_s2,unl_s3,aunl_enc_keytab,6);   // Round 7
        AES_ENC_ROUND(unl_s0,unl_s1,unl_s2,unl_s3,unl_t0,unl_t1,unl_t2,unl_t3,aunl_enc_keytab,7);   // Round 8
        AES_ENC_ROUND(unl_t0,unl_t1,unl_t2,unl_t3,unl_s0,unl_s1,unl_s2,unl_s3,aunl_enc_keytab,8);   // Round 9

        if (adsp_key->unc_key_size == 32) {                 // AES-256
            AES_ENC_ROUND(unl_s0,unl_s1,unl_s2,unl_s3,unl_t0,unl_t1,unl_t2,unl_t3,aunl_enc_keytab,9);  // Round 10
            AES_ENC_ROUND(unl_t0,unl_t1,unl_t2,unl_t3,unl_s0,unl_s1,unl_s2,unl_s3,aunl_enc_keytab,10); // Round 11
            AES_ENC_ROUND(unl_s0,unl_s1,unl_s2,unl_s3,unl_t0,unl_t1,unl_t2,unl_t3,aunl_enc_keytab,11); // Round 12
            AES_ENC_ROUND(unl_t0,unl_t1,unl_t2,unl_t3,unl_s0,unl_s1,unl_s2,unl_s3,aunl_enc_keytab,12); // Round 13
            AES_ENC_LAST_ROUND(unrl_xor[0],
                               unrl_xor[1],
                               unrl_xor[2],
                               unrl_xor[3],
                               unl_t0,
                               unl_t1,
                               unl_t2,
                               unl_t3,
                               aunl_enc_keytab,
                               13);                                                                                            //Round 14
        } else if (adsp_key->unc_key_size == 24) {              // AES-192
            AES_ENC_ROUND(unl_s0,unl_s1,unl_s2,unl_s3,unl_t0,unl_t1,unl_t2,unl_t3,aunl_enc_keytab,9);   // Round 10
            AES_ENC_ROUND(unl_t0,unl_t1,unl_t2,unl_t3,unl_s0,unl_s1,unl_s2,unl_s3,aunl_enc_keytab,10);  // Round 11
            AES_ENC_LAST_ROUND(unrl_xor[0],
                               unrl_xor[1],
                               unrl_xor[2],
                               unrl_xor[3],
                               unl_t0,
                               unl_t1,
                               unl_t2,
                               unl_t3,
                               aunl_enc_keytab,
                               11);                                                                                            //Round 12
        } else {
            AES_ENC_LAST_ROUND(unrl_xor[0],
                               unrl_xor[1],
                               unrl_xor[2],
                               unrl_xor[3],
                               unl_t0,
                               unl_t1,
                               unl_t2,
                               unl_t3,
                               aunl_enc_keytab,
                               9);                                                                                            // Round 10
        }

        ms_write_little_endian(abyp_output + 0, unrl_xor[0]);
        ms_write_little_endian(abyp_output + 4, unrl_xor[1]);
        ms_write_little_endian(abyp_output + 8, unrl_xor[2]);
        ms_write_little_endian(abyp_output + 12, unrl_xor[3]);

        abyp_input  += 16;
        abyp_output += 16;
    }
} // m_aes_cbc_encrypt_sw


void m_aes_cbc_decrypt_sw(unsigned char* abyp_output,
                          const unsigned char* abyp_input,
                          size_t szp_len,
                          const struct dsd_cipher_key* adsp_key,
                          const unsigned char* abyp_iv)
{
    size_t szl_blk_cnt = (szp_len >> 4);
    const unsigned int * aunl_dec_keytab = (const unsigned int *)adsp_key->byrc_aes_expkey;
    unsigned int unl_s0, unl_s1, unl_s2, unl_s3;
    unsigned int unl_t0,unl_t1, unl_t2, unl_t3;
    unsigned int unrl_xor[4];
    unsigned int unrl_s[4];
    //-----------------------------------------------------------
    // load IV Vector, prepare input/output pointers
    //-----------------------------------------------------------
    ms_read_little_endian(unrl_xor[0], abyp_iv + 0);            // get bytes 0-3
    ms_read_little_endian(unrl_xor[1], abyp_iv + 4);            // get bytes 4-7
    ms_read_little_endian(unrl_xor[2], abyp_iv + 8);            // get bytes 8-11
    ms_read_little_endian(unrl_xor[3], abyp_iv + 12);           // get bytes 12-15
    //-----------------------------------------------------------
    // Decrypt Blocks
    //-----------------------------------------------------------
    for (; szl_blk_cnt > 0; szl_blk_cnt--) {
        ms_read_little_endian(unrl_s[0], abyp_input + 0);
        ms_read_little_endian(unrl_s[1], abyp_input + 4);
        ms_read_little_endian(unrl_s[2], abyp_input + 8);
        ms_read_little_endian(unrl_s[3], abyp_input + 12);

        unl_s0 = unrl_s[0] ^ aunl_dec_keytab[0];
        unl_s1 = unrl_s[1] ^ aunl_dec_keytab[1];
        unl_s2 = unrl_s[2] ^ aunl_dec_keytab[2];
        unl_s3 = unrl_s[3] ^ aunl_dec_keytab[3];

        //-------------------------------------------------
        // Perform Table processing for all 10 rounds
        //-------------------------------------------------
        AES_DEC_ROUND(unl_t0,unl_t1,unl_t2,unl_t3,unl_s0,unl_s1,unl_s2,unl_s3,aunl_dec_keytab,0);   // Round 1
        AES_DEC_ROUND(unl_s0,unl_s1,unl_s2,unl_s3,unl_t0,unl_t1,unl_t2,unl_t3,aunl_dec_keytab,1);   // Round 2
        AES_DEC_ROUND(unl_t0,unl_t1,unl_t2,unl_t3,unl_s0,unl_s1,unl_s2,unl_s3,aunl_dec_keytab,2);   // Round 3
        AES_DEC_ROUND(unl_s0,unl_s1,unl_s2,unl_s3,unl_t0,unl_t1,unl_t2,unl_t3,aunl_dec_keytab,3);   // Round 4
        AES_DEC_ROUND(unl_t0,unl_t1,unl_t2,unl_t3,unl_s0,unl_s1,unl_s2,unl_s3,aunl_dec_keytab,4);   // Round 5
        AES_DEC_ROUND(unl_s0,unl_s1,unl_s2,unl_s3,unl_t0,unl_t1,unl_t2,unl_t3,aunl_dec_keytab,5);   // Round 6
        AES_DEC_ROUND(unl_t0,unl_t1,unl_t2,unl_t3,unl_s0,unl_s1,unl_s2,unl_s3,aunl_dec_keytab,6);   // Round 7
        AES_DEC_ROUND(unl_s0,unl_s1,unl_s2,unl_s3,unl_t0,unl_t1,unl_t2,unl_t3,aunl_dec_keytab,7);   // Round 8
        AES_DEC_ROUND(unl_t0,unl_t1,unl_t2,unl_t3,unl_s0,unl_s1,unl_s2,unl_s3,aunl_dec_keytab,8);   // Round 9
        if (adsp_key->unc_key_size == 32) {                 // AES-256
            AES_DEC_ROUND(unl_s0,unl_s1,unl_s2,unl_s3,unl_t0,unl_t1,unl_t2,unl_t3,aunl_dec_keytab,9);  // Round 10
            AES_DEC_ROUND(unl_t0,unl_t1,unl_t2,unl_t3,unl_s0,unl_s1,unl_s2,unl_s3,aunl_dec_keytab,10); // Round 11
            AES_DEC_ROUND(unl_s0,unl_s1,unl_s2,unl_s3,unl_t0,unl_t1,unl_t2,unl_t3,aunl_dec_keytab,11); // Round 12
            AES_DEC_ROUND(unl_t0,unl_t1,unl_t2,unl_t3,unl_s0,unl_s1,unl_s2,unl_s3,aunl_dec_keytab,12); // Round 13
            AES_DEC_LAST_ROUND(unl_s0,unl_s1,unl_s2,unl_s3,unl_t0,unl_t1,unl_t2,unl_t3,aunl_dec_keytab,13); //Round 14
        } else if(adsp_key->unc_key_size == 24) {               // AES-192
            AES_DEC_ROUND(unl_s0,unl_s1,unl_s2,unl_s3,unl_t0,unl_t1,unl_t2,unl_t3,aunl_dec_keytab,9); // Round 10
            AES_DEC_ROUND(unl_t0,unl_t1,unl_t2,unl_t3,unl_s0,unl_s1,unl_s2,unl_s3,aunl_dec_keytab,10); // Round 11
            AES_DEC_LAST_ROUND(unl_s0,unl_s1,unl_s2,unl_s3,unl_t0,unl_t1,unl_t2,unl_t3,aunl_dec_keytab,11); //Round 12
        } else {                        // AES-128
            AES_DEC_LAST_ROUND(unl_s0,unl_s1,unl_s2,unl_s3,unl_t0,unl_t1,unl_t2,unl_t3,aunl_dec_keytab,9); // Round 10
        }

        unrl_xor[0] ^= unl_s0;          // unrl_xor with IV
        unrl_xor[1] ^= unl_s1;
        unrl_xor[2] ^= unl_s2;
        unrl_xor[3] ^= unl_s3;

        ms_write_little_endian(abyp_output + 0, unrl_xor[0]);
        ms_write_little_endian(abyp_output + 4, unrl_xor[1]);
        ms_write_little_endian(abyp_output + 8, unrl_xor[2]);
        ms_write_little_endian(abyp_output + 12, unrl_xor[3]);
        memcpy(unrl_xor,unrl_s,16);

        abyp_input  += 16;
        abyp_output += 16;
    }
} // m_aes_cbc_decrypt_sw

static void ms_aes_ecb_fast_encrypt(const unsigned char * abyp_input,
                                    unsigned char * abyp_output,
                                    const unsigned char * abyp_key,
                                    size_t szp_blk_cnt,
                                    size_t szp_rounds)
{
    const unsigned int *aunl_key = (unsigned int *)abyp_key;
    unsigned int unl_s0,unl_s1,unl_s2,unl_s3;
    unsigned int unl_t0,unl_t1,unl_t2,unl_t3;
    unsigned int unrl_s[4];

    //-----------------------------------------------------------
    // Encrypt Blocks, full unrolled loops
    //-----------------------------------------------------------
    for(; szp_blk_cnt > 0; szp_blk_cnt--) {
        ms_read_little_endian(unrl_s[0], abyp_input + 0);       // get bytes 0-3
        ms_read_little_endian(unrl_s[1], abyp_input + 4);       // get bytes 4-7
        ms_read_little_endian(unrl_s[2], abyp_input + 8);       // get bytes 8-11
        ms_read_little_endian(unrl_s[3], abyp_input + 12);      // get bytes 12-15

        unl_s0 = unrl_s[0] ^ aunl_key[0];
        unl_s1 = unrl_s[1] ^ aunl_key[1];
        unl_s2 = unrl_s[2] ^ aunl_key[2];
        unl_s3 = unrl_s[3] ^ aunl_key[3];
        //-------------------------------------------------
        // Perform Table processing for all 10/12/14 rounds
        //-------------------------------------------------
        AES_ENC_ROUND(unl_t0,unl_t1,unl_t2,unl_t3,unl_s0,unl_s1,unl_s2,unl_s3,aunl_key,0);  // Round 1
        AES_ENC_ROUND(unl_s0,unl_s1,unl_s2,unl_s3,unl_t0,unl_t1,unl_t2,unl_t3,aunl_key,1);  // Round 2
        AES_ENC_ROUND(unl_t0,unl_t1,unl_t2,unl_t3,unl_s0,unl_s1,unl_s2,unl_s3,aunl_key,2);  // Round 3
        AES_ENC_ROUND(unl_s0,unl_s1,unl_s2,unl_s3,unl_t0,unl_t1,unl_t2,unl_t3,aunl_key,3);  // Round 4
        AES_ENC_ROUND(unl_t0,unl_t1,unl_t2,unl_t3,unl_s0,unl_s1,unl_s2,unl_s3,aunl_key,4);  // Round 5
        AES_ENC_ROUND(unl_s0,unl_s1,unl_s2,unl_s3,unl_t0,unl_t1,unl_t2,unl_t3,aunl_key,5);  // Round 6
        AES_ENC_ROUND(unl_t0,unl_t1,unl_t2,unl_t3,unl_s0,unl_s1,unl_s2,unl_s3,aunl_key,6);  // Round 7
        AES_ENC_ROUND(unl_s0,unl_s1,unl_s2,unl_s3,unl_t0,unl_t1,unl_t2,unl_t3,aunl_key,7);  // Round 8
        AES_ENC_ROUND(unl_t0,unl_t1,unl_t2,unl_t3,unl_s0,unl_s1,unl_s2,unl_s3,aunl_key,8);  // Round 9

        if(szp_rounds == 14) {                  // AES-256
            AES_ENC_ROUND(unl_s0,unl_s1,unl_s2,unl_s3,unl_t0,unl_t1,unl_t2,unl_t3,aunl_key,9);  // Round 10
            AES_ENC_ROUND(unl_t0,unl_t1,unl_t2,unl_t3,unl_s0,unl_s1,unl_s2,unl_s3,aunl_key,10); // Round 11
            AES_ENC_ROUND(unl_s0,unl_s1,unl_s2,unl_s3,unl_t0,unl_t1,unl_t2,unl_t3,aunl_key,11); // Round 12
            AES_ENC_ROUND(unl_t0,unl_t1,unl_t2,unl_t3,unl_s0,unl_s1,unl_s2,unl_s3,aunl_key,12); // Round 13
            AES_ENC_LAST_ROUND(unl_s0,unl_s1,unl_s2,unl_s3,unl_t0,unl_t1,unl_t2,unl_t3,aunl_key,13); //Round 14
        } else if(szp_rounds == 12) {               // AES-192
            AES_ENC_ROUND(unl_s0,unl_s1,unl_s2,unl_s3,unl_t0,unl_t1,unl_t2,unl_t3,aunl_key,9); // Round 10
            AES_ENC_ROUND(unl_t0,unl_t1,unl_t2,unl_t3,unl_s0,unl_s1,unl_s2,unl_s3,aunl_key,10); // Round 11
            AES_ENC_LAST_ROUND(unl_s0,unl_s1,unl_s2,unl_s3,unl_t0,unl_t1,unl_t2,unl_t3,aunl_key,11); //Round 12
        } else {
            AES_ENC_LAST_ROUND(unl_s0,unl_s1,unl_s2,unl_s3,unl_t0,unl_t1,unl_t2,unl_t3,aunl_key,9); // Round 10
        }

        ms_write_little_endian(abyp_output + 0, unl_s0);
        ms_write_little_endian(abyp_output + 4, unl_s1);
        ms_write_little_endian(abyp_output + 8, unl_s2);
        ms_write_little_endian(abyp_output + 12, unl_s3);

        abyp_input  += 16;
        abyp_output += 16;
    }
} // ms_aes_ecb_fast_encrypt

void m_aes_ctr_crypt_sw(unsigned char* abyp_output,
                        const unsigned char* abyp_input,
                        size_t szp_len,
                        const struct dsd_cipher_key* adsp_key,
                        const unsigned char* abyp_iv)
{
    const unsigned int * aunl_enc_keytab = (const unsigned int *)adsp_key->byrc_aes_expkey; //special settings
    unsigned int unrl_sn[4];                        //array holding the aes state
    unsigned int unl_t0, unl_t1, unl_t2, unl_t3;    //for round calculations
    unsigned int unrl_s[4];                         //holds intermediate values for output
    unsigned int unrl_cb[4];                        //contains the counter block
    unsigned char byrl_last[16];                    //holds the last partial block
    unsigned int unl_cnt;
    size_t szl_i;                                   //counter

    //-----------------------------------------------------------
    // Calculate number of Blocks
    //-----------------------------------------------------------
    size_t szl_blk_cnt = szp_len / cind_aes_block_size;  //get number of complete 128bit blocks
    size_t szl_reminder = szp_len % cind_aes_block_size; //BYTEs of the partial block

    //-----------------------------------------------------------
    // load IV Vector ; Initial Counter Block ICB
    //-----------------------------------------------------------

    //reverse input endianness if needed
    ms_read_little_endian(unrl_cb[0], abyp_iv + 0);     // get bytes 0-3
    ms_read_little_endian(unrl_cb[1], abyp_iv + 4);     // get bytes 4-7
    ms_read_little_endian(unrl_cb[2], abyp_iv + 8);     // get bytes 8-11
    ms_read_little_endian(unrl_cb[3], abyp_iv + 12);        // get bytes 12-15

    // Read the counter as big endian number
    ms_read_big_endian(unl_cnt, abyp_iv + 12);
    //-----------------------------------------------------------
    // Encrypt Blocks, full unrolled loops
    //-----------------------------------------------------------
    for(; szl_blk_cnt > 0; szl_blk_cnt--) {
        unrl_sn[0] = unrl_cb[0]  ^ aunl_enc_keytab[0];
        unrl_sn[1] = unrl_cb[1]  ^ aunl_enc_keytab[1];
        unrl_sn[2] = unrl_cb[2]  ^ aunl_enc_keytab[2];
        unrl_sn[3] = unrl_cb[3]  ^ aunl_enc_keytab[3];

        //-------------------------------------------------
        // Perform Table processing for all 10/12/14 rounds
        //-------------------------------------------------
        AES_ENC_ROUND(unl_t0,unl_t1,unl_t2,unl_t3,unrl_sn[0],unrl_sn[1],unrl_sn[2],unrl_sn[3],aunl_enc_keytab,0);   // Round 1
        AES_ENC_ROUND(unrl_sn[0],unrl_sn[1],unrl_sn[2],unrl_sn[3],unl_t0,unl_t1,unl_t2,unl_t3,aunl_enc_keytab,1);   // Round 2
        AES_ENC_ROUND(unl_t0,unl_t1,unl_t2,unl_t3,unrl_sn[0],unrl_sn[1],unrl_sn[2],unrl_sn[3],aunl_enc_keytab,2);   // Round 3
        AES_ENC_ROUND(unrl_sn[0],unrl_sn[1],unrl_sn[2],unrl_sn[3],unl_t0,unl_t1,unl_t2,unl_t3,aunl_enc_keytab,3);   // Round 4
        AES_ENC_ROUND(unl_t0,unl_t1,unl_t2,unl_t3,unrl_sn[0],unrl_sn[1],unrl_sn[2],unrl_sn[3],aunl_enc_keytab,4);   // Round 5
        AES_ENC_ROUND(unrl_sn[0],unrl_sn[1],unrl_sn[2],unrl_sn[3],unl_t0,unl_t1,unl_t2,unl_t3,aunl_enc_keytab,5);   // Round 6
        AES_ENC_ROUND(unl_t0,unl_t1,unl_t2,unl_t3,unrl_sn[0],unrl_sn[1],unrl_sn[2],unrl_sn[3],aunl_enc_keytab,6);   // Round 7
        AES_ENC_ROUND(unrl_sn[0],unrl_sn[1],unrl_sn[2],unrl_sn[3],unl_t0,unl_t1,unl_t2,unl_t3,aunl_enc_keytab,7);   // Round 8
        AES_ENC_ROUND(unl_t0,unl_t1,unl_t2,unl_t3,unrl_sn[0],unrl_sn[1],unrl_sn[2],unrl_sn[3],aunl_enc_keytab,8);   // Round 9

        if (adsp_key->unc_key_size == 32) {                 // AES-256
            AES_ENC_ROUND(unrl_sn[0],unrl_sn[1],unrl_sn[2],unrl_sn[3],unl_t0,unl_t1,unl_t2,unl_t3,aunl_enc_keytab,9);  // Round 10
            AES_ENC_ROUND(unl_t0,unl_t1,unl_t2,unl_t3,unrl_sn[0],unrl_sn[1],unrl_sn[2],unrl_sn[3],aunl_enc_keytab,10); // Round 11
            AES_ENC_ROUND(unrl_sn[0],unrl_sn[1],unrl_sn[2],unrl_sn[3],unl_t0,unl_t1,unl_t2,unl_t3,aunl_enc_keytab,11); // Round 12
            AES_ENC_ROUND(unl_t0,unl_t1,unl_t2,unl_t3,unrl_sn[0],unrl_sn[1],unrl_sn[2],unrl_sn[3],aunl_enc_keytab,12); // Round 13
            AES_ENC_LAST_ROUND(unrl_sn[0],
                               unrl_sn[1],
                               unrl_sn[2],
                               unrl_sn[3],
                               unl_t0,
                               unl_t1,
                               unl_t2,
                               unl_t3,
                               aunl_enc_keytab,
                               13);                                                                                        //Round 14
        } else if(adsp_key->unc_key_size == 24) {               // AES-192
            AES_ENC_ROUND(unrl_sn[0],unrl_sn[1],unrl_sn[2],unrl_sn[3],unl_t0,unl_t1,unl_t2,unl_t3,aunl_enc_keytab,9); // Round 10
            AES_ENC_ROUND(unl_t0,unl_t1,unl_t2,unl_t3,unrl_sn[0],unrl_sn[1],unrl_sn[2],unrl_sn[3],aunl_enc_keytab,10); // Round 11
            AES_ENC_LAST_ROUND(unrl_sn[0],
                               unrl_sn[1],
                               unrl_sn[2],
                               unrl_sn[3],
                               unl_t0,
                               unl_t1,
                               unl_t2,
                               unl_t3,
                               aunl_enc_keytab,
                               11);                                                                                        //Round 12
        } else {
            AES_ENC_LAST_ROUND(unrl_sn[0],
                               unrl_sn[1],
                               unrl_sn[2],
                               unrl_sn[3],
                               unl_t0,
                               unl_t1,
                               unl_t2,
                               unl_t3,
                               aunl_enc_keytab,
                               9);                                                                                        // Round 10
        }

        //reverse input endianness if needed
        ms_read_little_endian(unrl_s[0], abyp_input + 0);       // get bytes 0-3
        ms_read_little_endian(unrl_s[1], abyp_input + 4);       // get bytes 4-7
        ms_read_little_endian(unrl_s[2], abyp_input + 8);       // get bytes 8-11
        ms_read_little_endian(unrl_s[3], abyp_input + 12);      // get bytes 12-15

        //unrl_xoring output block with plaintext
        unrl_sn[0] ^= unrl_s[0];
        unrl_sn[1] ^= unrl_s[1];
        unrl_sn[2] ^= unrl_s[2];
        unrl_sn[3] ^= unrl_s[3];

        ms_write_little_endian(abyp_output + 0, unrl_sn[0]);
        ms_write_little_endian(abyp_output + 4, unrl_sn[1]);
        ms_write_little_endian(abyp_output + 8, unrl_sn[2]);
        ms_write_little_endian(abyp_output + 12, unrl_sn[3]);

        //increase function 32bit
        unl_cnt++;

        // Here, we have to distinguish between BE and LE machines
        // The byte order has to be flipped in both cases!
#ifndef HL_BIG_ENDIAN
        ms_write_big_endian(((unsigned char *)&unrl_cb[3]) + 0, unl_cnt);
#else
        ms_write_little_endian(((unsigned char *)&unrl_cb[3]) + 0, unl_cnt);
#endif
        //for loop
        abyp_input  += 16;
        abyp_output += 16;
    }

    /*******************************************************************************************/
    //  FULL BLOCKS DONE!
    /*******************************************************************************************/

    //-----------------------------------------------------------
    // Last Block is partial?
    //-----------------------------------------------------------
    if (szl_reminder != 0) {
        //do remaining opertaions with the uncompleted block left
        unrl_sn[0] = unrl_cb[0]  ^ aunl_enc_keytab[0];
        unrl_sn[1] = unrl_cb[1]  ^ aunl_enc_keytab[1];
        unrl_sn[2] = unrl_cb[2]  ^ aunl_enc_keytab[2];
        unrl_sn[3] = unrl_cb[3]  ^ aunl_enc_keytab[3];

        //-------------------------------------------------
        // Perform Table processing for all 10/12/14 rounds
        //-------------------------------------------------
        AES_ENC_ROUND(unl_t0,unl_t1,unl_t2,unl_t3,unrl_sn[0],unrl_sn[1],unrl_sn[2],unrl_sn[3],aunl_enc_keytab,0);   // Round 1
        AES_ENC_ROUND(unrl_sn[0],unrl_sn[1],unrl_sn[2],unrl_sn[3],unl_t0,unl_t1,unl_t2,unl_t3,aunl_enc_keytab,1);   // Round 2
        AES_ENC_ROUND(unl_t0,unl_t1,unl_t2,unl_t3,unrl_sn[0],unrl_sn[1],unrl_sn[2],unrl_sn[3],aunl_enc_keytab,2);   // Round 3
        AES_ENC_ROUND(unrl_sn[0],unrl_sn[1],unrl_sn[2],unrl_sn[3],unl_t0,unl_t1,unl_t2,unl_t3,aunl_enc_keytab,3);   // Round 4
        AES_ENC_ROUND(unl_t0,unl_t1,unl_t2,unl_t3,unrl_sn[0],unrl_sn[1],unrl_sn[2],unrl_sn[3],aunl_enc_keytab,4);   // Round 5
        AES_ENC_ROUND(unrl_sn[0],unrl_sn[1],unrl_sn[2],unrl_sn[3],unl_t0,unl_t1,unl_t2,unl_t3,aunl_enc_keytab,5);   // Round 6
        AES_ENC_ROUND(unl_t0,unl_t1,unl_t2,unl_t3,unrl_sn[0],unrl_sn[1],unrl_sn[2],unrl_sn[3],aunl_enc_keytab,6);   // Round 7
        AES_ENC_ROUND(unrl_sn[0],unrl_sn[1],unrl_sn[2],unrl_sn[3],unl_t0,unl_t1,unl_t2,unl_t3,aunl_enc_keytab,7);   // Round 8
        AES_ENC_ROUND(unl_t0,unl_t1,unl_t2,unl_t3,unrl_sn[0],unrl_sn[1],unrl_sn[2],unrl_sn[3],aunl_enc_keytab,8);   // Round 9

        if (adsp_key->unc_key_size == 32) {                 // AES-256
            AES_ENC_ROUND(unrl_sn[0],unrl_sn[1],unrl_sn[2],unrl_sn[3],unl_t0,unl_t1,unl_t2,unl_t3,aunl_enc_keytab,9);  // Round 10
            AES_ENC_ROUND(unl_t0,unl_t1,unl_t2,unl_t3,unrl_sn[0],unrl_sn[1],unrl_sn[2],unrl_sn[3],aunl_enc_keytab,10); // Round 11
            AES_ENC_ROUND(unrl_sn[0],unrl_sn[1],unrl_sn[2],unrl_sn[3],unl_t0,unl_t1,unl_t2,unl_t3,aunl_enc_keytab,11); // Round 12
            AES_ENC_ROUND(unl_t0,unl_t1,unl_t2,unl_t3,unrl_sn[0],unrl_sn[1],unrl_sn[2],unrl_sn[3],aunl_enc_keytab,12); // Round 13
            AES_ENC_LAST_ROUND(unrl_sn[0],
                               unrl_sn[1],
                               unrl_sn[2],
                               unrl_sn[3],
                               unl_t0,
                               unl_t1,
                               unl_t2,
                               unl_t3,
                               aunl_enc_keytab,
                               13);                                                                                        //Round 14
        } else if(adsp_key->unc_key_size == 24) {           // AES-192
            AES_ENC_ROUND(unrl_sn[0],unrl_sn[1],unrl_sn[2],unrl_sn[3],unl_t0,unl_t1,unl_t2,unl_t3,aunl_enc_keytab,9); // Round 10
            AES_ENC_ROUND(unl_t0,unl_t1,unl_t2,unl_t3,unrl_sn[0],unrl_sn[1],unrl_sn[2],unrl_sn[3],aunl_enc_keytab,10); // Round 11
            AES_ENC_LAST_ROUND(unrl_sn[0],
                               unrl_sn[1],
                               unrl_sn[2],
                               unrl_sn[3],
                               unl_t0,
                               unl_t1,
                               unl_t2,
                               unl_t3,
                               aunl_enc_keytab,
                               11);                                                                                        //Round 12
        } else {
            AES_ENC_LAST_ROUND(unrl_sn[0],
                               unrl_sn[1],
                               unrl_sn[2],
                               unrl_sn[3],
                               unl_t0,
                               unl_t1,
                               unl_t2,
                               unl_t3,
                               aunl_enc_keytab,
                               9);                                                                                        // Round 10
        }

        //reverse input endianness if needed
        ms_write_little_endian(byrl_last + 0, unrl_sn[0]);
        ms_write_little_endian(byrl_last + 4, unrl_sn[1]);
        ms_write_little_endian(byrl_last + 8, unrl_sn[2]);
        ms_write_little_endian(byrl_last + 12, unrl_sn[3]);

        for (szl_i = 0; szl_i < szl_reminder; szl_i++) {
            *abyp_output = *abyp_input^byrl_last[szl_i];
            abyp_output++;
            abyp_input++;
        }
    }
} // m_aes_ctr_crypt_sw

// Faster, than an inline function
#define AES_GCM_GHASH_INNER_ROUND(BIT) \
    /* xi = 1? */ \
    if ( IS_SET_BIT(abyp_h[unl_byte_cntr],BIT) ) { \
        /* Zi+1 = Zi xor Vi */ \
        ull_z_low ^= ull_v_low; \
        ull_z_high ^= ull_v_high; \
    } \
    /* This mask R, using bit V_127. Makes it 0, if the bit is not set. */ \
    ull_r_masked = ulcs_gf128_mod_u64 & (((unsigned long long)0)-(ull_v_high & 0x01)); \
    /*Vi+1 = (Vi>>1) xor R */ \
    ull_v_high >>= 1; \
    ull_v_high |= ull_v_low << 63; \
    ull_v_low >>= 1; \
    ull_v_low ^= ull_r_masked;

static inline void ms_ghash(const unsigned char* abyp_h,
                            const unsigned char* abyp_x,
                            unsigned char* abyp_y)
{
    unsigned int unl_byte_cntr;
    unsigned long long ulrl_x[2]; /*data to hash in 64u[2]*/
    unsigned long long ulrl_y[2]; /*output/state in u64[2]*/
    unsigned long long ull_z_high,ull_z_low;
    unsigned long long ull_v_high,ull_v_low;
    //copy input
    ms_read_big_endian(ulrl_x[0], abyp_x + 0);
    ms_read_big_endian(ulrl_x[1], abyp_x + 8);
    ms_read_big_endian(ulrl_y[0], abyp_y + 0);
    ms_read_big_endian(ulrl_y[1], abyp_y + 8);
    //update state
    ulrl_y[0] ^= ulrl_x[0];
    ulrl_y[1] ^= ulrl_x[1];
    //Z0 = 0^128
    ull_z_low = 0;
    ull_z_high = 0;
    //V0 = Y
    ull_v_low = ulrl_y[0];
    ull_v_high = ulrl_y[1];
    //x0,x1.. to x128
    for (unl_byte_cntr = 0; unl_byte_cntr < cind_aes_block_size; unl_byte_cntr++) {
        unsigned long long ull_r_masked;
        AES_GCM_GHASH_INNER_ROUND(7);
        AES_GCM_GHASH_INNER_ROUND(6);
        AES_GCM_GHASH_INNER_ROUND(5);
        AES_GCM_GHASH_INNER_ROUND(4);
        AES_GCM_GHASH_INNER_ROUND(3);
        AES_GCM_GHASH_INNER_ROUND(2);
        AES_GCM_GHASH_INNER_ROUND(1);
        AES_GCM_GHASH_INNER_ROUND(0);
    }

    //output
    ulrl_y[0] = ull_z_low;
    ulrl_y[1] = ull_z_high;
    ms_write_big_endian(abyp_y, ulrl_y[0]);
    ms_write_big_endian(abyp_y + cind_aes_block_size/2, ulrl_y[1]);

} /*END OF function m_ghash(...)*/

/**
   Auxiliary GHASH function for byte-stream

   This function updates the current hash state by input data
   If the last block of input is incomplete (i.e. if unp_data_len % 16 > 0), zeros are appended

   @param[in,out]	abyp_hash_state		Current GHASH state
   @param[in]		abyp_hash_key		GHASH key
   @param[in]		abyp_data			Input data
   @param[in]		unp_data_len		Data length
 */
static void ms_fast_ghash_stream(unsigned char* abyp_hash_state,
                                 const unsigned char* abyp_hash_key,
                                 const unsigned char* abyp_data,
                                 size_t szp_data_len)
{
    size_t szl_len_blocks = szp_data_len / cind_aes_block_size;
    size_t szl_len_remain = szp_data_len % cind_aes_block_size;
    unsigned char byrl_aux[cind_aes_block_size]; /*auxiliary 16byte array*/
    // Complete blocks
    while(szl_len_blocks > 0) {
        ms_ghash( abyp_hash_key,  abyp_data,  abyp_hash_state);
        abyp_data += cind_aes_block_size;
        szl_len_blocks--;
    }
    // Partial block, extended with zeros
    if (szl_len_remain != 0) {
        memcpy(byrl_aux, abyp_data,szl_len_remain);
        memset(byrl_aux + szl_len_remain, 0, cind_aes_block_size - szl_len_remain);
        ms_ghash(abyp_hash_key, byrl_aux, abyp_hash_state);
    }
} /*END m_ghash_stream*/

/**
   This struct serves as state for the AES GCM multistep processing functions.
   Attention: Only for intermediate use related to static *_gcm_2 functions.
 */
struct dsd_aes_gcm_state_intern {
    unsigned char byrc_ghash_state[16];    // State array of the GHASH
    unsigned char byrc_ghash_key[16];      // Hash key for the GHASH
    unsigned char byrc_counter_block[16];  // Current counter block
    unsigned char byrc_partial_block[16];  // Buffer for storing partial CTR blocks between two Update calls.
                                           //If the message length is not a multiple of 16, contains:
                                           // -by encryption: (encrypted counter) xor (partial message||0...0)
                                           // -by decryption: (partial ciper||0..0) and (LSBs of encrypted counter)
                                           //If message length is multiple of 16, does not contain meaningful data.
    unsigned char byrc_ctr_0_block[16];    // Encrypted first CTR block, needed for final step
    struct dsd_cipher_key dsc_key;         // Key in use
    unsigned int unc_rounds;               // Number of rounds (direct relation to key length)
    unsigned int unc_counter;              // last word of current counter block
    unsigned long long ulc_add_data_len;   // Length of additional data
    unsigned long long ulc_message_len;    // (Accumulated) length of plaintext/ciphertext
    unsigned int unc_partial_bytes;        // Number of bytes used in byrc_partial_block. May be 0-15.
};

static void ms_init_aes_gcm_2(struct dsd_aes_gcm_state_intern* adsp_state,
                              const unsigned char* abyp_additional_data,
                              unsigned int unp_data_len,
                              const unsigned char* abyp_iv,
                              unsigned int unp_iv_len,
                              const struct dsd_cipher_key* adsp_key,
                              void (* amp_ecb_encrypt)(const unsigned char * abyp_input,
                                                       unsigned char * abyp_output,
                                                       const unsigned char * abyp_key,
                                                       size_t szl_blk_cnt,
                                                       size_t szp_rounds),
                              void (* amp_ghash_stream)(unsigned char* abyp_hash_state,
                                                        const unsigned char* abyp_hash_key,
                                                        const unsigned char* abyp_data,
                                                        size_t szp_data_len))
{
    //-----------------------------------------------------------
    // NO PARAMETER VALIDATION
    //-----------------------------------------------------------
    //-----------------------------------------------------------
    // STATE INITIALITATION
    //-----------------------------------------------------------
    memset(adsp_state,0,sizeof(struct dsd_aes_gcm_state_intern));
    adsp_state->ulc_add_data_len = unp_data_len;
    adsp_state->dsc_key = *adsp_key;
    if (adsp_key->unc_key_size == uns_aes_128_key_size) {
        adsp_state->unc_rounds = uns_aes_128_rounds;
    } else if (adsp_key->unc_key_size == uns_aes_192_key_size) {
        adsp_state->unc_rounds = uns_aes_192_rounds;
    } else if (adsp_key->unc_key_size == uns_aes_256_key_size) {
        adsp_state->unc_rounds = uns_aes_256_rounds;
    } else{
        return;
    }
    //-----------------------------------------------------------
    // VARIABLES INITIALITATION
    //-----------------------------------------------------------
    unsigned char byrl_aux[cind_aes_block_size] = {0};    /*auxiliary 16byte array*/

    //-----------------------------------------------------------
    // GHASH KEY INITIALITATION
    //-----------------------------------------------------------
    amp_ecb_encrypt(adsp_state->byrc_ghash_key,
                    adsp_state->byrc_ghash_key,
                    (adsp_state->dsc_key).byrc_aes_expkey,
                    1,
                    adsp_state->unc_rounds);

    //-----------------------------------------------------------
    // COUNTER INITIALIZATION
    //-----------------------------------------------------------
    if (unp_iv_len == uns_gcm_iv_default_len) {
        // J = ( IV || 0^(31) || 1 )
        memcpy(adsp_state->byrc_counter_block, abyp_iv, unp_iv_len);
        adsp_state->byrc_counter_block[16 - 1] |= 0x01;
    } else {
        // J = GHASH( IV || 0^(s+64) || [length(IV)]64bits )
        //[length(IV)]64bits = represent length of IV in 64bit little endian format
        amp_ghash_stream(adsp_state->byrc_counter_block,
                         adsp_state->byrc_ghash_key,
                         abyp_iv,
                         unp_iv_len);
        unsigned long long ull_iv_bit_len = unp_iv_len*CHAR_BIT;
        memset(byrl_aux,0,cind_aes_block_size);
        ms_write_big_endian(byrl_aux + cind_aes_block_size/2, ull_iv_bit_len);
        amp_ghash_stream(adsp_state->byrc_counter_block,
                         adsp_state->byrc_ghash_key,
                         byrl_aux,
                         cind_aes_block_size);
    }

    //-----------------------------------------------------------
    // AUTHDATA INITIALIZATION
    //-----------------------------------------------------------
    //GHASH(A || 0^v...
    amp_ghash_stream(adsp_state->byrc_ghash_state,
                     adsp_state->byrc_ghash_key,
                     abyp_additional_data,
                     unp_data_len);

    //-----------------------------------------------------------
    // 0TH BLOCK INITIALITATION
    //-----------------------------------------------------------
    amp_ecb_encrypt(adsp_state->byrc_counter_block,
                    adsp_state->byrc_ctr_0_block,
                    (adsp_state->dsc_key).byrc_aes_expkey,
                    1,
                    adsp_state->unc_rounds);

    //-----------------------------------------------------------
    // COUNTER INCREMENT
    //-----------------------------------------------------------
    unsigned int unl_counter;
    ms_read_big_endian(unl_counter, adsp_state->byrc_counter_block + 12);
    unl_counter++;
    ms_write_big_endian(adsp_state->byrc_counter_block + 12, unl_counter);
    adsp_state->unc_counter = unl_counter;
} // ms_init_aes_gcm_2

static void ms_enc_update_aes_gcm_2(struct dsd_aes_gcm_state_intern* adsp_state,
                                    unsigned char* abyp_ciphertext,
                                    const unsigned char* abyp_plaintext,
                                    unsigned int unp_data_len,
                                    void (* amp_ecb_encrypt)(const unsigned char * abyp_input,
                                                             unsigned char * abyp_output,
                                                             const unsigned char * abyp_key,
                                                             size_t szl_blk_cnt,
                                                             size_t szp_rounds),
                                    void (* amp_ghash_stream)(unsigned char* abyp_hash_state,
                                                              const unsigned char* abyp_hash_key,
                                                              const unsigned char* abyp_data,
                                                              size_t szp_data_len),
                                    amd_block_crypt amp_ctr)

{
    //-----------------------------------------------------------
    // USE UP STORED PARTIAL BLOCK
    //-----------------------------------------------------------
    unsigned int unl_partial_size = adsp_state->unc_partial_bytes;
    if (unl_partial_size != 0) {
        unsigned int unl_partial_limit = min(cind_aes_block_size - unl_partial_size, unp_data_len);
        for (unsigned int unl1 = 0; unl1 < unl_partial_limit; unl1++) {
            adsp_state->byrc_partial_block[unl_partial_size + unl1] ^= abyp_plaintext[unl1];
            abyp_ciphertext[unl1] = adsp_state->byrc_partial_block[unl_partial_size + unl1];
        }
        abyp_ciphertext +=unl_partial_limit;
        abyp_plaintext  +=unl_partial_limit;
        unp_data_len    -=unl_partial_limit;
        adsp_state->ulc_message_len +=unl_partial_limit;
        adsp_state->unc_partial_bytes += unl_partial_limit;

        if (adsp_state->unc_partial_bytes == cind_aes_block_size) {
            amp_ghash_stream(adsp_state->byrc_ghash_state,
                             adsp_state->byrc_ghash_key,
                             adsp_state->byrc_partial_block,
                             cind_aes_block_size);
            adsp_state->unc_partial_bytes = 0;
        }
    }

    //-----------------------------------------------------------
    // COMPLETE BLOCKS
    //-----------------------------------------------------------
    unsigned int unl_len_blocks = unp_data_len / cind_aes_block_size;
    unsigned int unl_len_remain = unp_data_len % cind_aes_block_size;
    if (unl_len_blocks > 0) {
        amp_ctr(abyp_ciphertext,
                abyp_plaintext,
                (size_t)unl_len_blocks*cind_aes_block_size,
                &adsp_state->dsc_key,
                adsp_state->byrc_counter_block);
        adsp_state->unc_counter+=unl_len_blocks;
        ms_write_big_endian(adsp_state->byrc_counter_block + 12, adsp_state->unc_counter);

        amp_ghash_stream(adsp_state->byrc_ghash_state,
                         adsp_state->byrc_ghash_key,
                         abyp_ciphertext,
                         unl_len_blocks*cind_aes_block_size);

        abyp_ciphertext += unl_len_blocks*cind_aes_block_size;
    }

    //-----------------------------------------------------------
    // STORE REMAINDER TO PARTIAL
    //-----------------------------------------------------------
    if (unl_len_remain > 0) {
        abyp_plaintext += unl_len_blocks*cind_aes_block_size;

        amp_ecb_encrypt(adsp_state->byrc_counter_block,
                        adsp_state->byrc_partial_block,
                        (adsp_state->dsc_key).byrc_aes_expkey,
                        1,
                        adsp_state->unc_rounds);

        for (unsigned int unl1 = 0; unl1 < unl_len_remain; unl1++) {
            adsp_state->byrc_partial_block[unl1] ^= abyp_plaintext[unl1];
            abyp_ciphertext[unl1] = adsp_state->byrc_partial_block[unl1];
        }
        adsp_state->unc_partial_bytes = unl_len_remain;
        adsp_state->unc_counter++;
        ms_write_big_endian(adsp_state->byrc_counter_block + 12, adsp_state->unc_counter);
    }
    adsp_state->ulc_message_len+=unp_data_len;
} // ms_enc_update_aes_gcm_2

static void ms_dec_update_aes_gcm_2(struct dsd_aes_gcm_state_intern* adsp_state,
                                    unsigned char* abyp_plaintext,
                                    const unsigned char* abyp_ciphertext,
                                    unsigned int unp_data_len,
                                    void (* amp_ecb_encrypt)(const unsigned char * abyp_input,
                                                             unsigned char * abyp_output,
                                                             const unsigned char * abyp_key,
                                                             size_t szl_blk_cnt,
                                                             size_t szp_rounds),
                                    void (* amp_ghash_stream)(unsigned char* abyp_hash_state,
                                                              const unsigned char* abyp_hash_key,
                                                              const unsigned char* abyp_data,
                                                              size_t szp_data_len),
                                    amd_block_crypt amp_ctr)
{
    //-----------------------------------------------------------
    // USE UP STORED PARTIAL BLOCK
    //-----------------------------------------------------------
    unsigned int unl_partial_size = adsp_state->unc_partial_bytes;
    if (unl_partial_size != 0) {
        unsigned int unl_partial_limit = min(cind_aes_block_size - unl_partial_size, unp_data_len);
        for (unsigned int unl1 = 0; unl1 < unl_partial_limit; unl1++) {
            abyp_plaintext[unl1] = adsp_state->byrc_partial_block[unl_partial_size+unl1]^abyp_ciphertext[unl1];
            adsp_state->byrc_partial_block[unl_partial_size+unl1] = abyp_ciphertext[unl1];
        }
        abyp_ciphertext +=unl_partial_limit;
        abyp_plaintext  +=unl_partial_limit;
        unp_data_len    -=unl_partial_limit;
        adsp_state->ulc_message_len +=unl_partial_limit;
        adsp_state->unc_partial_bytes +=unl_partial_limit;
        if (adsp_state->unc_partial_bytes == cind_aes_block_size) {
            amp_ghash_stream(adsp_state->byrc_ghash_state,
                             adsp_state->byrc_ghash_key,
                             adsp_state->byrc_partial_block,
                             cind_aes_block_size);
            adsp_state->unc_partial_bytes = 0;
        }
    }

    //-----------------------------------------------------------
    // COMPLETE BLOCKS
    //-----------------------------------------------------------
    unsigned int unl_len_blocks = unp_data_len / cind_aes_block_size;
    unsigned int unl_len_remain = unp_data_len % cind_aes_block_size;
    if (unl_len_blocks > 0) {
        amp_ctr(abyp_plaintext,
                abyp_ciphertext,
                (size_t)unl_len_blocks*cind_aes_block_size,
                &adsp_state->dsc_key,
                adsp_state->byrc_counter_block);
        adsp_state->unc_counter+=unl_len_blocks;
        ms_write_big_endian(adsp_state->byrc_counter_block + 12, adsp_state->unc_counter);
        amp_ghash_stream(adsp_state->byrc_ghash_state,
                         adsp_state->byrc_ghash_key,
                         abyp_ciphertext,
                         unl_len_blocks*cind_aes_block_size);
        abyp_ciphertext += unl_len_blocks*cind_aes_block_size;
    }

    //-----------------------------------------------------------
    // STORE REMAINDER TO PARTIAL
    //-----------------------------------------------------------
    if (unl_len_remain > 0) {
        abyp_plaintext += unl_len_blocks*cind_aes_block_size;
        amp_ecb_encrypt(adsp_state->byrc_counter_block,
                        adsp_state->byrc_partial_block,
                        (adsp_state->dsc_key).byrc_aes_expkey,
                        1,
                        adsp_state->unc_rounds);
        for (unsigned int unl1 = 0; unl1 < unl_len_remain; unl1++) {
            abyp_plaintext[unl1] = adsp_state->byrc_partial_block[unl1]^abyp_ciphertext[unl1];
            adsp_state->byrc_partial_block[unl1] = abyp_ciphertext[unl1];
        }
        adsp_state->unc_partial_bytes = unl_len_remain;
        adsp_state->unc_counter++;
        ms_write_big_endian(adsp_state->byrc_counter_block + 12, adsp_state->unc_counter);
    }
    adsp_state->ulc_message_len+=unp_data_len;
} // ms_dec_update_aes_gcm_2

static void ms_enc_final_aes_gcm_2(struct dsd_aes_gcm_state_intern* adsp_state,
                                   unsigned char* abyp_tag,
                                   size_t szp_tag_len,
                                   void (* amp_ghash_stream)(unsigned char* abyp_hash_state,
                                                             const unsigned char* abyp_hash_key,
                                                             const unsigned char* abyp_data,
                                                             size_t szp_data_len))
{
    //-----------------------------------------------------------
    // USE UP STORED PARTIAL BLOCK
    //-----------------------------------------------------------
    if (adsp_state->unc_partial_bytes != 0) {
        memset(&adsp_state->byrc_partial_block[adsp_state->unc_partial_bytes],
               0,
               cind_aes_block_size-adsp_state->unc_partial_bytes);
        amp_ghash_stream(adsp_state->byrc_ghash_state,
                         adsp_state->byrc_ghash_key,
                         adsp_state->byrc_partial_block,
                         cind_aes_block_size);
    }

    //-----------------------------------------------------------
    // DATA LENGTHS
    //-----------------------------------------------------------
    unsigned char byrl_aux[cind_aes_block_size];
    unsigned long long ull_ad_bit_len = adsp_state->ulc_add_data_len *CHAR_BIT;
    unsigned long long ull_msg_bit_len = adsp_state->ulc_message_len *CHAR_BIT;
    ms_write_big_endian(byrl_aux, ull_ad_bit_len);
    ms_write_big_endian(byrl_aux + cind_aes_block_size/2, ull_msg_bit_len);

    amp_ghash_stream(adsp_state->byrc_ghash_state,
                     adsp_state->byrc_ghash_key,
                     byrl_aux,
                     cind_aes_block_size);

    //-----------------------------------------------------------
    // XOR WITH 0TH BLOCK
    //-----------------------------------------------------------
    for (unsigned int unl1 = 0; unl1 < szp_tag_len; unl1++) {
        abyp_tag[unl1] = adsp_state->byrc_ghash_state[unl1] ^ adsp_state->byrc_ctr_0_block[unl1];
    }
    //-----------------------------------------------------------
    // SCRUB STATE
    //-----------------------------------------------------------
    m_sec_memzero(adsp_state, sizeof(struct dsd_aes_gcm_state_intern));
} // ms_enc_final_aes_gcm_2

static BOOL ms_dec_final_aes_gcm_2(struct dsd_aes_gcm_state_intern* adsp_state,
                                   const unsigned char* abyp_tag,
                                   unsigned int unp_tag_len,
                                   void (* amp_ghash_stream)(unsigned char* abyp_hash_state,
                                                             const unsigned char* abyp_hash_key,
                                                             const unsigned char* abyp_data,
                                                             size_t szp_data_len))
{
    //-----------------------------------------------------------
    // USE UP STORED PARTIAL BLOCK
    //-----------------------------------------------------------
    if (adsp_state->unc_partial_bytes != 0) {
        memset(&adsp_state->byrc_partial_block[adsp_state->unc_partial_bytes],
               0,
               cind_aes_block_size-adsp_state->unc_partial_bytes);
        amp_ghash_stream(adsp_state->byrc_ghash_state,
                         adsp_state->byrc_ghash_key,
                         adsp_state->byrc_partial_block,
                         cind_aes_block_size);
    }

    //-----------------------------------------------------------
    // DATA LENGTHS
    //-----------------------------------------------------------
    unsigned char byrl_aux[cind_aes_block_size];
    unsigned long long ull_ad_bit_len = adsp_state->ulc_add_data_len *CHAR_BIT;
    unsigned long long ull_msg_bit_len = adsp_state->ulc_message_len *CHAR_BIT;
    ms_write_big_endian(byrl_aux, ull_ad_bit_len);
    ms_write_big_endian(byrl_aux + cind_aes_block_size/2, ull_msg_bit_len);
    amp_ghash_stream(adsp_state->byrc_ghash_state,
                     adsp_state->byrc_ghash_key,
                     byrl_aux,
                     cind_aes_block_size);
    //-----------------------------------------------------------
    // XOR WITH 0TH BLOCK
    //-----------------------------------------------------------
    for (unsigned int unl1 = 0; unl1 < unp_tag_len; unl1++) {
        adsp_state->byrc_ghash_state[unl1] ^= adsp_state->byrc_ctr_0_block[unl1];
    }
    //-----------------------------------------------------------
    // Authentication
    //-----------------------------------------------------------
    BOOL bol_auth;
    if (m_sec_memcmp(abyp_tag,adsp_state->byrc_ghash_state, unp_tag_len) == 0) {
        bol_auth = TRUE;
    } else {
        bol_auth = FALSE;
    }
    //-----------------------------------------------------------
    // SCRUB STATE
    //-----------------------------------------------------------
    m_sec_memzero(adsp_state, sizeof(struct dsd_aes_gcm_state_intern));
    return bol_auth;
} // ms_dec_final_aes_gcm_2

static void ms_aes_gcm_encrypt_base(unsigned char* abyp_cipher,
                                    const struct dsd_gather_i_1* adsp_plain,
                                    size_t szp_len,
                                    const struct dsd_cipher_key* adsp_key,
                                    const unsigned char* abyp_iv,
                                    size_t szp_iv_len,
                                    const unsigned char* abyp_adddata,
                                    size_t szp_adddata_len,
                                    unsigned char* abyp_tag,
                                    size_t szp_tag_len,
                                    void (* amp_ecb_encrypt)(const unsigned char * abyp_input,
                                                             unsigned char * abyp_output,
                                                             const unsigned char * abyp_key,
                                                             size_t szl_blk_cnt,
                                                             size_t szl_rounds),
                                    void (* amp_ghash_stream)(unsigned char* abyp_hash_state,
                                                              const unsigned char* abyp_hash_key,
                                                              const unsigned char* abyp_data,
                                                              size_t szp_data_len),
                                    amd_block_crypt amp_ctr)
{
    //-----------------------------------------------------------
    // VARIABLES INITIALITATION
    //-----------------------------------------------------------
    dsd_aes_gcm_state_intern dsl_state;
    //-----------------------------------------------------------
    // SINGLE STEP ENCRYPTION
    //-----------------------------------------------------------
    ms_init_aes_gcm_2(&dsl_state,
                      abyp_adddata,
                      (unsigned int)szp_adddata_len,
                      abyp_iv,
                      (unsigned int)szp_iv_len,
                      adsp_key,
                      amp_ecb_encrypt,
                      amp_ghash_stream);
    while ((adsp_plain != NULL) && (szp_len > 0)) {
        size_t szl_partial_len = min((size_t)(adsp_plain->achc_ginp_end - adsp_plain->achc_ginp_cur), szp_len);
        szp_len -= szl_partial_len;
        ms_enc_update_aes_gcm_2(&dsl_state,
                                abyp_cipher,
                                (unsigned char *)adsp_plain->achc_ginp_cur,
                                (unsigned int)szl_partial_len,
                                amp_ecb_encrypt,
                                amp_ghash_stream,
                                amp_ctr);
        abyp_cipher += szl_partial_len;
        adsp_plain = adsp_plain->adsc_next;
    }
    ms_enc_final_aes_gcm_2(&dsl_state,
                           abyp_tag,
                           szp_tag_len,
                           amp_ghash_stream);
    m_sec_memzero(&dsl_state, sizeof(struct dsd_aes_gcm_state_intern));
} // ms_aes_gcm_encrypt_base

static BOOL ms_aes_gcm_decrypt_base(unsigned char* abyp_plain,
                                    const struct dsd_gather_i_1* adsp_cipher,
                                    size_t szp_len,
                                    const struct dsd_cipher_key* adsp_key,
                                    const unsigned char* abyp_iv,
                                    size_t szp_iv_len,
                                    const unsigned char* abyp_adddata,
                                    size_t szp_adddata_len,
                                    const unsigned char* abyp_tag,
                                    size_t szp_tag_len,
                                    void (* amp_ecb_encrypt)(const unsigned char * abyp_input,
                                                             unsigned char * abyp_output,
                                                             const unsigned char * abyp_key,
                                                             size_t szl_blk_cnt,
                                                             size_t szl_rounds),
                                    void (* amp_ghash_stream)(unsigned char* abyp_hash_state,
                                                              const unsigned char* abyp_hash_key,
                                                              const unsigned char* abyp_data,
                                                              size_t szp_data_len),
                                    amd_block_crypt amp_ctr)
{
    size_t szl_offset = 0;
    //-----------------------------------------------------------
    // VARIABLES INITIALITATION
    //-----------------------------------------------------------
    struct dsd_aes_gcm_state_intern dsl_state;
    BOOL iel_auth_success;
    //-----------------------------------------------------------
    // SINGLE STEP DECREPTION
    //-----------------------------------------------------------
    ms_init_aes_gcm_2(&dsl_state,
                      abyp_adddata,
                      (unsigned int)szp_adddata_len,
                      abyp_iv,
                      (unsigned int)szp_iv_len,
                      adsp_key,
                      amp_ecb_encrypt,
                      amp_ghash_stream);
    while ((adsp_cipher != NULL) && (szp_len > 0)) {
        size_t szl_partial_len = min((size_t)(adsp_cipher->achc_ginp_end - adsp_cipher->achc_ginp_cur), szp_len);
        szp_len -= szl_partial_len;
        ms_dec_update_aes_gcm_2(&dsl_state,
                                abyp_plain + szl_offset,
                                (unsigned char *)adsp_cipher->achc_ginp_cur,
                                (unsigned int)szl_partial_len,
                                amp_ecb_encrypt,
                                amp_ghash_stream,
                                amp_ctr);
        szl_offset += szl_partial_len;
        adsp_cipher = adsp_cipher->adsc_next;
    }
    iel_auth_success = ms_dec_final_aes_gcm_2(&dsl_state,
                                              abyp_tag,
                                              (unsigned int)szp_tag_len,
                                              amp_ghash_stream);
    //-----------------------------------------------------------
    // AUTHENTICATION
    //-----------------------------------------------------------
    m_sec_memzero(&dsl_state, sizeof(struct dsd_aes_gcm_state_intern));
    if (iel_auth_success == FALSE) {
        m_sec_memzero(abyp_plain, szl_offset);
        return FALSE;
    }
    return TRUE;
} // ms_aes_gcm_decrypt_base

#ifndef HL_AES_ASM
void m_impl_aes_128_key_expansion(const unsigned char *,
                                  unsigned char * )
{
    ms_kill_proc();
}

void m_impl_aes_192_key_expansion(const unsigned char *,
                                  unsigned char * )
{
    ms_kill_proc();
}

void m_impl_aes_256_key_expansion(const unsigned char *,
                                  unsigned char * )
{
    ms_kill_proc();
}

void m_impl_aes_revert_key(unsigned char *,
                           unsigned char *,
                           size_t )
{
    ms_kill_proc();
}

void m_impl_aes_cbc_encrypt(const unsigned char *,
                            unsigned char *,
                            const unsigned char *,
                            size_t,
                            size_t,
                            const unsigned char * )
{
    ms_kill_proc();
}

void m_impl_aes_cbc_decrypt(const unsigned char *,
                            unsigned char *,
                            const unsigned char *,
                            size_t,
                            size_t,
                            const unsigned char * )
{
    ms_kill_proc();
}

void m_impl_aes_ctr(const unsigned char *,
                    unsigned char *,
                    const unsigned char *,
                    size_t,
                    size_t,
                    unsigned char * )
{
    ms_kill_proc();
}

void m_impl_aes_ecb_encrypt(const unsigned char *,
                            unsigned char *,
                            const unsigned char *,
                            size_t,
                            size_t )
{
    ms_kill_proc();
}

void m_impl_ghash_stream(unsigned char*,
                         const unsigned char*,
                         const unsigned char*,
                         size_t )
{
    ms_kill_proc();
}
#endif

//------------------------------------------------------------------------------
// Start of original file ./xs-encry-info.cpp
//------------------------------------------------------------------------------

#include <stdlib.h>
#include <string.h>

#ifdef _WIN32
#include <Windows.h>
#else
#include "hob-unix01.h"
#endif

#include "hob-encry-2.h"

#ifndef _WIN32
#include <limits.h>
#include <stdint.h>
#endif

#define HL_ENCRY2_VERSION_MAJOR     4
#define HL_ENCRY2_VERSION_MINOR     1
// Current revision. Updated by automated Release process and thus only accurate in released code, not during development
#define HL_ENCRY2_VERSION_REVISION  3245

#define HL_STRINGIFY2(arg) #arg
#define HL_STRINGIFY(arg) HL_STRINGIFY2(arg)


/** Version numbers */
const int ing_encry2_version_major = HL_ENCRY2_VERSION_MAJOR;
const int ing_encry2_version_minor = HL_ENCRY2_VERSION_MINOR;
const int ing_encry2_version_revision = HL_ENCRY2_VERSION_REVISION;
const char chrg_encry2_version_string[] = HL_STRINGIFY(HL_ENCRY2_VERSION_MAJOR) "." HL_STRINGIFY(HL_ENCRY2_VERSION_MINOR) "." HL_STRINGIFY(HL_ENCRY2_VERSION_REVISION);
const size_t szg_encry2_version_string_len = sizeof(chrg_encry2_version_string) - 1;

/** Error message strings */
const char* achrg_encry_error_message[] = {
    "Operation successful",                                                     //!< ied_encry_success = 0,
    "A non-optional parameter was NULL",                                        //!< ied_encry_null_pointer,
    "Memory allocation failes",                                                 //!< ied_encry_alloc_failure,
    "The output buffer or Lnum is too small",                                   //!< ied_encry_insufficient_buffer,
    "An input parameter has an invalid value",                                  //!< ied_encry_invalid_input,
    "The memory pool has insufficient capacity left",                           //!< ied_encry_pool_empty,
    "Deprecated error code ied_encry_insufficient_input_buffer",                //!< ied_encry_insufficient_input_buffer
    "The Random number generator has reported an error",                        //!< ied_encry_rng_error,
    "The Lnum is in an invalid state",                                          //!< ied_lnum_uninitialized,
    "An Input value illegally also serves as output value",                     //!< ied_lnum_invalid_inplace,
    "Division by zero",                                                         //!< ied_lnum_divide_by_zero,
    "The modulus has an invalid value",                                         //!< ied_lnum_invalid_modulus,
    "The given Lnum is not a prime number",                                     //!< ied_lnum_no_prime,
    "The given ECC point is in an invalid representation",                      //!< ied_ecc_representation_error,
    "The given ECC key pair is not associated with a valid curve",              //!< ied_ecc_curve_empty,
    "Deprecated error code ied_ecc_public_key_missing",                         //!< ied_ecc_public_key_missing,
    "The length of the key does not match the elliptic curve",                  //!< ied_ecc_input_len_invalid,
    "Deprecated error code ied_ecc_input_unknown_curve",                        //!< ied_ecc_input_unknown_curve,
    "The given key pair is uninitialized",                                      //!< ied_ecc_keypair_uninitialized,
    "The key pair already contains values",                                     //!< ied_ecc_context_not_clean,
    "The ECC point is not part of the curve",                                   //!< ied_ecc_point_not_on_curve,
    "The key is in an unsupported format",                                      //!< ied_ecc_point_format_error,
    "The public key is invalid",                                                //!< ied_ecc_public_key_invalid,
    "The signature is invalid",                                                 //!< ied_ecc_signature_invalid,
    "The ECDH secret is zero",                                                  //!< ied_ecc_secret_zero,
    "ECDSA needs to be invoked again",                                          //!< ied_ecc_ecdsa_again,
    "Function was aborted",                                                     //!< ied_encry_aborted,
    "Miscellaneous error",                                                      //!< ied_encry_miscellaneous,
    "Internal error",                                                           //!< ied_encry_internal_error,
    "Function is not implemented",                                              //!< ied_encry_not_implemented,
    "Verification failed"                                                       //!< ied_encry_verify_failed
};                                                                              
extern const char* achrg_encry_error_message[ied_encry_error_count];

//------------------------------------------------------------------------------
// Start of original file ./xs-lnum-1.cpp
//------------------------------------------------------------------------------

#include <stdlib.h>
#include <string.h>

#ifdef _WIN32
#include <Windows.h>
#else
#include "hob-unix01.h"
#ifndef HL_UNIX
#define HL_UNIX

#if (defined __APPLE__) && (defined __MACH__)
#define HL_LINUX
#define HL_MACOS
#endif

#endif // !HL_UNIX
#endif
#include "hob-xslhcla1.hpp"

#include "hob-encry-2.h"
#include "hob-encry-intern-2.h"

#ifndef _WIN32
#include <limits.h>
#include <stdint.h>
#endif

#ifndef max
#define max(a,b)            (((a) > (b)) ? (a) : (b))
#endif

#ifndef min
#define min(a,b)            (((a) < (b)) ? (a) : (b))
#endif

#define LNUM_BIT (CHAR_BIT * sizeof(LNUM_WORD))
#define UINTDIVROUNDUP(n,d) (((n) + (d) - (1))/(d))
#define UINTROUNDUPSTRICT(n,d) (((n) | ((d) - 1)) + 1)
#define UINTROUNDUP(n,d) ((((n) - 1) | ((d) - 1)) + 1)
#define ALIGN(type,a) (a)=(type)((((size_t)a)+HL_ALIGNMENT-1)& (~(HL_ALIGNMENT-1)))

// ------------------------------------------
//  Constants
// ------------------------------------------

/** Highest word count, at which a recursion step is still done. */
static const unsigned int uns_karatsuba_limit = 16 * sizeof(LNUM_WORD);

// ------------------------------------------
//  Static declarations
// ------------------------------------------

static size_t ms_count_bytes(const unsigned char* abyp_data,
                             size_t szp_len);
static size_t ms_count_bits(const unsigned char* abyp_data,
                            size_t szp_len);
static size_t ms_count_trailing_zeroes(const unsigned char* abyp_data,
                                       size_t szp_len);
static void ms_rec_mult(unsigned char* abyp_dest,
                        unsigned char* abyp_temp,
                        const unsigned char* abyp_a,
                        const unsigned char* abyp_b,
                        size_t szp_len);
static void ms_rec_sqr(unsigned char* abyp_dest,
                       unsigned char* abyp_temp,
                       const unsigned char* abyp_a,
                       size_t szp_len);

static LNUM_WORD ms_div_word(const LNUM_WORD* urp_num,
                             LNUM_WORD urp_div);
static LNUM_WORD ms_mod_word(const LNUM_WORD* urp_num,
                             LNUM_WORD urp_div);

static void ms_write_partial_big(char* achp_dest,
                                 LNUM_WORD urp_word,
                                 size_t szp_bytes);

static void ms_write_partial_little(char* achp_dest,
                                    LNUM_WORD urp_word,
                                    size_t szp_bytes);

static LNUM_WORD ms_inv_n_0(LNUM_WORD urp_n_0);
static void ms_mont_red_impl(unsigned char* abyp_dest,
                             const unsigned char* abyp_src,
                             const dsd_lnum_montgomery_ctx* adsp_ctx,
                             unsigned char* abyp_tmp);

static ied_encry_return ms_decrement(struct dsd_lnum* dsp_lnum);

static ied_encry_return ms_exp_mod_std(struct dsd_lnum* adsp_dest,
                                       struct dsd_mem_pool_ele* adsp_pool,
                                       const struct dsd_lnum* adsp_base,
                                       const struct dsd_lnum* adsp_exp,
                                       const struct dsd_lnum* adsp_mod);

static ied_encry_return ms_exp_mod_mont(struct dsd_lnum* adsp_dest,
                                        struct dsd_mem_pool_ele* adsp_pool,
                                        const struct dsd_lnum* adsp_base,
                                        const struct dsd_lnum* adsp_exp,
                                        const dsd_lnum_montgomery_ctx* adsp_mont_ctx);

static LNUM_WORD ms_get_window_val(size_t* aszp_cur_shift,
                                   const LNUM_WORD* aurp_exponent,
                                   size_t* aszp_exp_index,
                                   unsigned int unp_window_bits,
                                   LNUM_WORD urp_mask);
// ------------------------------------------
//  Lnum allocation functions
// ------------------------------------------

extern "C" dsd_lnum* m_lnum_create(struct dsd_memory* adsp_memory,
                                   size_t szp_size_bytes)
{
    size_t szl_safe_size;
    unsigned char* abyl_buffer;
    struct dsd_lnum* adsl_new_lnum;

#ifndef HL_OMIT_PARAM_CHECKS
    if (adsp_memory == NULL) {
        return NULL;
    }

    // round up to a nonzero multiple of LNUM_SIZE_ALIGN
    if (szp_size_bytes == 0) {
        szp_size_bytes++;
    }
#endif
    szl_safe_size = UINTROUNDUP(szp_size_bytes,LNUM_SIZE_ALIGN);

    abyl_buffer = (unsigned char*) adsp_memory->amc_malloc(adsp_memory, szl_safe_size);
    if (abyl_buffer == NULL) {
        return NULL;
    }

    adsl_new_lnum = (struct dsd_lnum*) adsp_memory->amc_malloc(adsp_memory, sizeof(struct dsd_lnum));
    if (adsl_new_lnum == NULL) {
        adsp_memory->amc_free(adsp_memory, abyl_buffer);
        return NULL;
    }

    adsl_new_lnum->aucc_data = abyl_buffer;
    adsl_new_lnum->szc_alloc_size_bytes = szl_safe_size;
    adsl_new_lnum->szc_used_size_bytes = 0;
    adsl_new_lnum->boc_is_negative = FALSE;

    return adsl_new_lnum;
} // m_lnum_create



extern "C" ied_encry_return m_lnum_alloc(struct dsd_memory* adsp_memory,
                                         struct dsd_lnum* adsp_lnum,
                                         size_t szp_size_bytes)
{
    size_t szl_safe_size;
    unsigned char* abyl_buffer;
#ifndef HL_OMIT_PARAM_CHECKS
    if (adsp_lnum == NULL) {
        return ied_encry_null_pointer;
    }
    if (adsp_memory == NULL) {
        adsp_lnum->aucc_data = NULL;
        adsp_lnum->szc_alloc_size_bytes = 0;
        adsp_lnum->szc_used_size_bytes = 0;
        adsp_lnum->boc_is_negative = FALSE;
        return ied_encry_null_pointer;
    }

    // round up to a nonzero multiple of LNUM_SIZE_ALIGN
    if (szp_size_bytes == 0) {
        szp_size_bytes++;
    }
#endif
    szl_safe_size = UINTROUNDUP(szp_size_bytes,LNUM_SIZE_ALIGN);

    abyl_buffer = (unsigned char*) adsp_memory->amc_malloc(adsp_memory, szl_safe_size);
    if (abyl_buffer == NULL) {
        adsp_lnum->aucc_data = NULL;
        adsp_lnum->szc_alloc_size_bytes = 0;
        adsp_lnum->szc_used_size_bytes = 0;
        adsp_lnum->boc_is_negative = FALSE;
        return ied_encry_alloc_failure;
    }
    adsp_lnum->aucc_data = abyl_buffer;
    adsp_lnum->szc_alloc_size_bytes = szl_safe_size;
    adsp_lnum->szc_used_size_bytes = 0;
    adsp_lnum->boc_is_negative = FALSE;

    return ied_encry_success;
} // m_lnum_alloc



extern "C" void m_lnum_free(struct dsd_memory* adsp_memory,
                            struct dsd_lnum* adsp_lnum)
{
#ifndef HL_OMIT_PARAM_CHECKS
    if ((adsp_memory == NULL) || (adsp_lnum == NULL)) {
        return;
    }
#endif
    adsp_memory->amc_free(adsp_memory, adsp_lnum->aucc_data);
    adsp_lnum->aucc_data = NULL;
    adsp_lnum->szc_alloc_size_bytes = 0;
    adsp_lnum->szc_used_size_bytes = 0;
}



extern "C" void m_lnum_destroy(struct dsd_memory* adsp_memory,
                               struct dsd_lnum* adsp_lnum)
{
#ifndef HL_OMIT_PARAM_CHECKS
    if ((adsp_memory == NULL) || (adsp_lnum == NULL)) {
        return;
    }
#endif
    adsp_memory->amc_free(adsp_memory, adsp_lnum->aucc_data);
    adsp_lnum->aucc_data = NULL;
    adsp_lnum->szc_alloc_size_bytes = 0;
    adsp_lnum->szc_used_size_bytes = 0;
    adsp_memory->amc_free(adsp_memory, adsp_lnum);
}

extern "C" dsd_lnum* m_mem_pool_get_lnum_byte_size(struct dsd_mem_pool_ele** aadsp_pool,
                                                   size_t szp_size_bytes)
{
#ifndef HL_OMIT_PARAM_CHECKS
    if(aadsp_pool == NULL) {
        return NULL;
    }
#endif
    return m_pool_get_lnum(aadsp_pool, szp_size_bytes);
}

extern "C"  dsd_lnum* m_mem_pool_get_lnum_same_size(struct dsd_mem_pool_ele** aadsp_pool,
                                                    const struct dsd_lnum* adsp_match)
{
#ifndef HL_OMIT_PARAM_CHECKS
    if((aadsp_pool == NULL) || (adsp_match == NULL)) {
        return NULL;
    }
#endif
    return m_pool_get_lnum(aadsp_pool,
                           adsp_match->szc_used_size_bytes);
}

extern "C" dsd_lnum* m_mem_pool_get_lnum_copy(struct dsd_mem_pool_ele** aadsp_pool,
                                              const struct dsd_lnum* adsp_src)
{
#ifndef HL_OMIT_PARAM_CHECKS
    if((aadsp_pool == NULL) || (adsp_src == NULL)) {
        return NULL;
    }
#endif
    dsd_lnum* adsl_temp = m_pool_get_lnum(aadsp_pool,
                                          adsp_src->szc_used_size_bytes);

    if(adsl_temp == NULL) {
        return NULL;
    }

    if(m_lnum_copy(adsl_temp, adsp_src) != ied_encry_success) {
        return NULL;
    }

    return adsl_temp;
} // m_mem_pool_get_lnum_copy


extern "C" dsd_lnum* m_lnum_clone(struct dsd_memory* adsp_memory,
                                  const struct dsd_lnum* adsp_source)
{
    unsigned char* abyl_buffer;
    struct dsd_lnum* adsl_new_lnum;
#ifndef HL_OMIT_PARAM_CHECKS
    if (adsp_memory == NULL) {
        return NULL;
    }
    if ((adsp_source == NULL) || (adsp_source->aucc_data == NULL)) {
        return NULL;
    }
#endif
    size_t szl_data_size = adsp_source->szc_used_size_bytes;
    if (szl_data_size == 0) {
        szl_data_size++;
    }
    szl_data_size = UINTROUNDUP(szl_data_size, LNUM_SIZE_ALIGN);

    abyl_buffer = (unsigned char*) adsp_memory->amc_malloc(adsp_memory, szl_data_size);
    if (abyl_buffer == NULL) {
        return NULL;
    }
    adsl_new_lnum = (struct dsd_lnum*) adsp_memory->amc_malloc(adsp_memory, sizeof(struct dsd_lnum));
    if (adsl_new_lnum == NULL) {
        adsp_memory->amc_free(adsp_memory, abyl_buffer);
        return NULL;
    }
    //copy data (up to used_size)
    memcpy(abyl_buffer, adsp_source->aucc_data, adsp_source->szc_used_size_bytes);

    adsl_new_lnum->aucc_data = abyl_buffer;
    adsl_new_lnum->szc_alloc_size_bytes = adsp_source->szc_alloc_size_bytes;
    adsl_new_lnum->szc_used_size_bytes = adsp_source->szc_used_size_bytes;
    adsl_new_lnum->boc_is_negative = adsp_source->boc_is_negative;

    return adsl_new_lnum;
} // m_lnum_clone

extern "C" size_t m_mem_pool_size(enum ied_encry_function iep_function,
                                  size_t szp_input_size,
                                  size_t szp_input2_size)
{

    szp_input_size = UINTROUNDUP(szp_input_size, sizeof(LNUM_WORD));
    szp_input2_size = UINTROUNDUP(szp_input2_size, sizeof(LNUM_WORD));

    switch (iep_function) {
    case ied_m_lnum_barret_init:
        return REQSIZE_m_lnum_barret_init(szp_input_size) + REQSIZE_m_lnum_barret_init_KEEP(szp_input_size) +
               REQSIZE_ALIGNMENT;
    case ied_m_lnum_barret_reduce:
        return REQSIZE_m_lnum_barret_reduce(szp_input_size) + REQSIZE_ALIGNMENT;
    case ied_m_lnum_divide:
    {
        if (szp_input2_size == 0) {
            szp_input2_size = szp_input_size;
        }
        return REQSIZE_m_lnum_divide(szp_input_size,szp_input2_size) + REQSIZE_ALIGNMENT;
    }
    case ied_m_lnum_exp_mod:
    {
        if (szp_input2_size == 0) {
            szp_input2_size = szp_input_size;
        }
        return REQSIZE_m_lnum_exp_mod(szp_input_size,szp_input2_size) + REQSIZE_ALIGNMENT;
    }
    case ied_m_lnum_gcd:
        return REQSIZE_m_lnum_gcd(max(szp_input_size, szp_input2_size)) + REQSIZE_ALIGNMENT;
    case ied_m_lnum_inverse:
        return REQSIZE_m_lnum_inverse(szp_input_size) + REQSIZE_ALIGNMENT;
    case ied_m_lnum_lcm:
        return REQSIZE_m_lnum_lcm(max(szp_input_size, szp_input2_size)) + REQSIZE_ALIGNMENT;
    case ied_m_lnum_mont_init:
        return REQSIZE_m_lnum_mont_init(szp_input_size) + REQSIZE_m_lnum_mont_init_KEEP(szp_input_size) +
               REQSIZE_ALIGNMENT;
    case ied_m_lnum_mont_red:
        return REQSIZE_m_lnum_mont_red(szp_input_size) + REQSIZE_ALIGNMENT;
    case ied_m_lnum_mult:
        return REQSIZE_m_lnum_mult(szp_input_size) + REQSIZE_ALIGNMENT;
    case ied_m_lnum_square:
        return REQSIZE_m_lnum_square(szp_input_size) + REQSIZE_ALIGNMENT;
    case ied_m_lnum_test_prime:
        return REQSIZE_m_lnum_test_prime(szp_input_size) + REQSIZE_ALIGNMENT;
    case ied_m_lnum_mont_conv:
        return REQSIZE_m_lnum_mont_conv(szp_input_size,szp_input_size) + REQSIZE_ALIGNMENT;
    default:
        return 0;
    }
} // m_mem_pool_size

// ------------------------------------------
//  Lnum basic number manipulation functions
// ------------------------------------------

extern "C" ied_encry_return m_lnum_copy(struct dsd_lnum* adsp_dest,
                                        const struct dsd_lnum* adsp_src)
{
#ifndef HL_OMIT_PARAM_CHECKS
    if (adsp_dest == NULL) {
        return ied_encry_null_pointer;
    }
    if (adsp_src == NULL) {
        return ied_encry_null_pointer;
    }
    if (adsp_src->aucc_data == NULL) {
        return ied_lnum_uninitialized;
    }
    if ((adsp_dest->aucc_data == NULL) ||
        (adsp_src->szc_used_size_bytes > adsp_dest->szc_alloc_size_bytes))
    {
        return ied_encry_insufficient_buffer;
    }
#endif
    if (adsp_dest == adsp_src) {
        return ied_encry_success;
    }
    memcpy(adsp_dest->aucc_data,adsp_src->aucc_data,adsp_src->szc_used_size_bytes);

    adsp_dest->szc_used_size_bytes = adsp_src->szc_used_size_bytes;
    adsp_dest->boc_is_negative = adsp_src->boc_is_negative;

    return ied_encry_success;
} // m_lnum_copy


extern "C" ied_encry_return m_lnum_set(struct dsd_lnum* adsp_dest,
                                       const int inp_value)
{
#ifndef HL_OMIT_PARAM_CHECKS
    if (adsp_dest == NULL) {
        return ied_encry_null_pointer;
    }
#endif
    //no check for alloc_size: is always nonzero and an int always fits
    if (inp_value == 0) {
        adsp_dest->szc_used_size_bytes = 0;
        adsp_dest->boc_is_negative = FALSE;
        return ied_encry_success;
    }
    LNUM_WORD url_value = (inp_value < 0) ? (-inp_value) : (inp_value);
    ((LNUM_WORD*)(adsp_dest->aucc_data))[0] = url_value;
    adsp_dest->szc_used_size_bytes = 1 * sizeof(LNUM_WORD);
    adsp_dest->boc_is_negative = (inp_value < 0);
    return ied_encry_success;
} // m_lnum_set

extern "C" ied_encry_return m_lnum_random_value(struct dsd_lnum* adsp_dest,
                                                size_t szp_size_bits,
                                                int (* amp_random)(void* avop_userfld,
                                                                   void* avop_dest,
                                                                   size_t szp_size),
                                                void* avop_userfld)
{
#ifndef HL_OMIT_PARAM_CHECKS
    if ((adsp_dest == NULL) || (amp_random == NULL)) {
        return ied_encry_null_pointer;
    }
    if (szp_size_bits > adsp_dest->szc_alloc_size_bytes * CHAR_BIT) {
        return ied_encry_insufficient_buffer;
    }
#endif
    if (szp_size_bits == 0) {
        return m_lnum_set(adsp_dest,0);
    }
    adsp_dest->szc_used_size_bytes = ( UINTROUNDUP(szp_size_bits,LNUM_BIT)) / CHAR_BIT;
    TOP_WORD(adsp_dest) = (LNUM_WORD)(0);
    int inl_rng_retcode = amp_random(avop_userfld, adsp_dest->aucc_data, UINTDIVROUNDUP(szp_size_bits,CHAR_BIT));
    if (inl_rng_retcode != 0) {
        return ied_encry_rng_error;
    }
    LNUM_WORD url_highest_word = TOP_WORD(adsp_dest);
#ifdef HL_BIG_ENDIAN
    //The RNG callback function operates bytewise, from low to high addresses. This means that on big-endian platforms,
    //it will place the last few bytes onto the high-order positions and leave the low-order positions empty.
    //Shift the word in question so the non-zero bytes are moved to the lower-order positions at the higher addresses.
    if (UINTROUNDUP(szp_size_bits,CHAR_BIT) % LNUM_BIT != 0) {
        url_highest_word >>= (LNUM_BIT - (UINTROUNDUP(szp_size_bits,CHAR_BIT) % LNUM_BIT));
    }
#endif
    //bitmask: zero out all bits above the threshold
    //bitmask is constructed by initializing as 11111111, then shifting right to clear the appropriate amount of high-order bits
    if (szp_size_bits % CHAR_BIT != 0) {
        LNUM_WORD url_bitmask = (LNUM_WORD)(-1);
        url_bitmask >>= (LNUM_BIT - (szp_size_bits % LNUM_BIT));
        url_highest_word &= url_bitmask;
    }
    TOP_WORD(adsp_dest) = url_highest_word;
    while ((adsp_dest->szc_used_size_bytes > 0) &&
           (TOP_WORD(adsp_dest) == (LNUM_WORD)(0)))
    {
        adsp_dest->szc_used_size_bytes-=sizeof(LNUM_WORD);
    }
    adsp_dest->boc_is_negative = FALSE;
    return ied_encry_success;
} // m_lnum_random_value

extern "C" ied_encry_return m_lnum_random_less_than(struct dsd_lnum* adsp_dest,
                                                    const struct dsd_lnum* adsp_limit,
                                                    int (* amp_random)(void* avop_userfld,
                                                                       void* avop_dest,
                                                                       size_t szp_size),
                                                    void* avop_userfld)
{
#ifndef HL_OMIT_PARAM_CHECKS
    if ((adsp_dest == NULL) || (adsp_limit == NULL) || (amp_random == NULL)) {
        return ied_encry_null_pointer;
    }
    if (adsp_limit->szc_used_size_bytes > adsp_dest->szc_alloc_size_bytes) {
        return ied_encry_insufficient_buffer;
    }
#endif
    size_t szl_size_bits = ms_count_bits(adsp_limit->aucc_data,adsp_limit->szc_used_size_bytes);
    if (szl_size_bits < 2) {
        return ied_encry_invalid_input;
    }
    //bitmask is constructed by initializing as 11111111, then shifting right to clear the appropriate amount of high-order bits
    LNUM_WORD url_bitmask = (LNUM_WORD)(-1);
    if (szl_size_bits % CHAR_BIT != 0) {
        url_bitmask >>= (LNUM_BIT - (szl_size_bits % LNUM_BIT));
    }
    size_t szl_size_words = 0;
    int inl_cmp = 0;
    do {
        szl_size_words = adsp_limit->szc_used_size_bytes / sizeof(LNUM_WORD);
        ((LNUM_WORD*)(adsp_dest->aucc_data))[szl_size_words-1] = (LNUM_WORD)(0);
        int inl_rng_retcode = amp_random(avop_userfld, adsp_dest->aucc_data, UINTDIVROUNDUP(szl_size_bits,CHAR_BIT));
        if (inl_rng_retcode != 0) {
            return ied_encry_rng_error;
        }
        LNUM_WORD url_highest_word = ((LNUM_WORD*)(adsp_dest->aucc_data))[szl_size_words-1];
#ifdef HL_BIG_ENDIAN
        //The RNG callback function operates bytewise, from low to high addresses. This means that on big-endian platforms,
        //it will place the last few bytes onto the high-order positions and leave the low-order positions empty.
        //Shift the word in question so the non-zero bytes are moved to the lower-order positions at the higher addresses.
        if (UINTROUNDUP(szl_size_bits,CHAR_BIT) % LNUM_BIT != 0) {
            url_highest_word >>= (LNUM_BIT - (UINTROUNDUP(szl_size_bits,CHAR_BIT) % LNUM_BIT));
        }
#endif
        //apply bitmask
        url_highest_word &= url_bitmask;
        ((LNUM_WORD*)(adsp_dest->aucc_data))[szl_size_words-1] = url_highest_word;

        //compare to limit, redo if equal or larger
        inl_cmp = m_impl_cmp(adsp_dest->aucc_data,adsp_limit->aucc_data,szl_size_words * sizeof(LNUM_WORD));
        if (inl_cmp >= 0) {
            continue;
        }
        //determine correct size
        while ((szl_size_words>0) && (((LNUM_WORD*)(adsp_dest->aucc_data))[szl_size_words-1] == (LNUM_WORD)(0))) {
            szl_size_words--;
        }
        //redo if the number is 0
    } while ((inl_cmp >= 0) || (szl_size_words==0));
    adsp_dest->szc_used_size_bytes = szl_size_words * sizeof(LNUM_WORD);
    adsp_dest->boc_is_negative = FALSE;
    return ied_encry_success;
} // m_lnum_random_less_than


extern "C" int m_lnum_get_byte_count(const struct dsd_lnum* adsp_src)
{
#ifndef HL_OMIT_PARAM_CHECKS
    if( adsp_src == NULL ) {
        return -1;
    }
#endif
    return (int)ms_count_bytes(adsp_src->aucc_data, adsp_src->szc_used_size_bytes);
}

extern "C" int m_lnum_get_bit_count(const struct dsd_lnum* adsp_src)
{
#ifndef HL_OMIT_PARAM_CHECKS
    if( adsp_src == NULL ) {
        return -1;
    }
#endif
    return (int)ms_count_bits(adsp_src->aucc_data, adsp_src->szc_used_size_bytes);
}

extern "C" ied_encry_return m_lnum_load_bytes_le(struct dsd_lnum* adsp_dest,
                                                 const char* achp_src,
                                                 size_t szp_length)
{
#ifndef HL_OMIT_PARAM_CHECKS
    if (adsp_dest == NULL) {
        return ied_encry_null_pointer;
    }
    if (achp_src == NULL) {
        return ied_encry_null_pointer;
    }
#endif
    const unsigned char* aucl_src = (const unsigned char*)achp_src;
    size_t szl_size_words = UINTDIVROUNDUP(szp_length,sizeof(LNUM_WORD));
    size_t szl_full_words = szp_length / sizeof(LNUM_WORD);

#ifndef HL_OMIT_PARAM_CHECKS
    if ((adsp_dest->aucc_data == NULL) ||
        (szl_size_words > adsp_dest->szc_alloc_size_bytes / sizeof(LNUM_WORD)))
    {
        return ied_encry_insufficient_buffer;
    }
#endif
    for (unsigned int unl_index = 0; unl_index < szl_full_words; ++unl_index) {
        LNUM_WORD url_word = 0;
        ms_read_little_endian(url_word, aucl_src);
        aucl_src += sizeof(LNUM_WORD);
        ((LNUM_WORD*)(adsp_dest->aucc_data))[unl_index] = url_word;
    }

    unsigned int unl_partial_word_length = szp_length % sizeof(LNUM_WORD);

    if (unl_partial_word_length != 0) {
        LNUM_WORD url_word = 0;
        for (unsigned int unl2 = 0; unl2 < unl_partial_word_length; ++unl2) {
            LNUM_WORD url_byte = *aucl_src++;
            url_byte <<= (unl2 * CHAR_BIT);
            url_word += url_byte;
        }
        ((LNUM_WORD*)(adsp_dest->aucc_data))[szl_size_words-1] = url_word;
    }

    adsp_dest->szc_used_size_bytes = szl_size_words * sizeof(LNUM_WORD);
    adsp_dest->boc_is_negative = FALSE;

    //trim leading zeroes
    while ((adsp_dest->szc_used_size_bytes>0) &&
           (TOP_WORD(adsp_dest) == (LNUM_WORD)(0)))
    {
        adsp_dest->szc_used_size_bytes-=sizeof(LNUM_WORD);
    }

    return ied_encry_success;
} // m_lnum_load_bytes_le

extern "C" ied_encry_return m_lnum_load_bytes_be(struct dsd_lnum* adsp_dest,
                                                 const char* achp_src,
                                                 size_t szp_length)
{
#ifndef HL_OMIT_PARAM_CHECKS
    if (adsp_dest == NULL) {
        return ied_encry_null_pointer;
    }
    if (achp_src == NULL) {
        return ied_encry_null_pointer;
    }
#endif
    const unsigned char* aucl_src = (const unsigned char*)achp_src;
    size_t szl_size_words = UINTDIVROUNDUP(szp_length,sizeof(LNUM_WORD));
    size_t szl_full_words = szp_length / sizeof(LNUM_WORD);

#ifndef HL_OMIT_PARAM_CHECKS
    if  (( adsp_dest->aucc_data == NULL ) ||
         (szl_size_words > adsp_dest->szc_alloc_size_bytes / sizeof(LNUM_WORD)))
    {
        return ied_encry_insufficient_buffer;
    }
#endif
    unsigned int unl_partial_word_length = szp_length % sizeof(LNUM_WORD);
    if (unl_partial_word_length != 0) {
        LNUM_WORD url_word = 0;
        for (unsigned int unl2 = 0; unl2 < unl_partial_word_length; ++unl2) {
            LNUM_WORD url_byte = *aucl_src++;
            url_byte <<= ((unl_partial_word_length-unl2-1) * CHAR_BIT);
            url_word += url_byte;
        }
        ((LNUM_WORD*)(adsp_dest->aucc_data))[szl_size_words-1] = url_word;
    }
    for (size_t szl_index = szl_size_words - szl_full_words; szl_index < szl_size_words; ++szl_index) {
        LNUM_WORD url_word;
        ms_read_big_endian(url_word, aucl_src);
        aucl_src += sizeof(LNUM_WORD);
        ((LNUM_WORD*)(adsp_dest->aucc_data))[szl_size_words-szl_index-1] = url_word;
    }

    adsp_dest->szc_used_size_bytes = szl_size_words * sizeof(LNUM_WORD);
    adsp_dest->boc_is_negative = FALSE;

    //trim leading zeroes
    while ((adsp_dest->szc_used_size_bytes>0) &&
           (TOP_WORD(adsp_dest) == (LNUM_WORD)(0)))
    {
        adsp_dest->szc_used_size_bytes-=sizeof(LNUM_WORD);
    }

    return ied_encry_success;
} // m_lnum_load_bytes_be



extern "C" ied_encry_return m_lnum_store_bytes_le(char* achp_dst,
                                                  size_t* aszp_length,
                                                  const struct dsd_lnum* adsp_src,
                                                  BOOL bop_zero_fill)
{
#ifndef HL_OMIT_PARAM_CHECKS
    if ((achp_dst == NULL) || (adsp_src == NULL) || (aszp_length == NULL)) {
        return ied_encry_null_pointer;
    }
    if (adsp_src->aucc_data == NULL) {
        return ied_lnum_uninitialized;
    }
#endif
    LNUM_WORD* al_data = (LNUM_WORD*) adsp_src->aucc_data;
    size_t szl_total_bytes = ms_count_bytes(adsp_src->aucc_data,
                                            adsp_src->szc_used_size_bytes);

#ifndef HL_OMIT_PARAM_CHECKS
    if (szl_total_bytes > *aszp_length) {
        return ied_encry_insufficient_buffer;
    }
#endif

    // For Little Endian, we write from the low order word to the high order word

    unsigned int unl_index = 0;
    size_t szl_single_bytes = szl_total_bytes % sizeof(LNUM_WORD);
    size_t szl_full_words = szl_total_bytes / sizeof(LNUM_WORD);

    while(unl_index < szl_full_words) {
        ms_write_little_endian((unsigned char*)achp_dst, al_data[unl_index]);
        achp_dst += sizeof(LNUM_WORD);
        unl_index++;
    }

    if(szl_single_bytes != 0) {
        // The highest order word was a partial word, write it here
        ms_write_partial_little(achp_dst, al_data[unl_index], szl_single_bytes);
    }

    if( bop_zero_fill && (*aszp_length > szl_total_bytes)) {
        // Fill with trailing 0s
        size_t szl_fill_bytes = *aszp_length - szl_total_bytes;

        achp_dst += szl_single_bytes;
        memset(achp_dst, 0, szl_fill_bytes);

        return ied_encry_success;
    }

    // Set length, might be lower, than output len
    *aszp_length = szl_total_bytes;
    return ied_encry_success;
} // m_lnum_store_bytes_le




extern "C" ied_encry_return m_lnum_store_bytes_be(char* achp_dst,
                                                  size_t* aszp_length,
                                                  const struct dsd_lnum* adsp_src,
                                                  BOOL bop_zero_fill)
{
#ifndef HL_OMIT_PARAM_CHECKS
    if((achp_dst == NULL) || (adsp_src == NULL) || (aszp_length == NULL)) {
        return ied_encry_null_pointer;
    }
    if (adsp_src->aucc_data == NULL) {
        return ied_lnum_uninitialized;
    }
#endif
    LNUM_WORD* al_data = (LNUM_WORD*) adsp_src->aucc_data;
    size_t szl_total_bytes = ms_count_bytes(adsp_src->aucc_data,
                                            adsp_src->szc_used_size_bytes);

#ifndef HL_OMIT_PARAM_CHECKS
    if (szl_total_bytes > *aszp_length) {
        return ied_encry_insufficient_buffer;
    }
#endif

    if(bop_zero_fill && (*aszp_length > szl_total_bytes)) {
        // Set the requested leading 0s
        size_t szl_fill_len = *aszp_length - szl_total_bytes;
        memset(achp_dst, 0, szl_fill_len);
        achp_dst += szl_fill_len;
    } else {
        // Set result length, smaller than output length
        *aszp_length = szl_total_bytes;
    }

    size_t szl_full_words = adsp_src->szc_used_size_bytes / sizeof(LNUM_WORD);
    size_t szl_single_bytes = szl_total_bytes % sizeof(LNUM_WORD);

    // We write from most to least significant word.

    // Highest word may be only partially set
    if(szl_single_bytes != 0) {
        szl_full_words--;
        ms_write_partial_big(achp_dst,
                             al_data[szl_full_words],
                             szl_single_bytes);
        achp_dst += szl_single_bytes;
    }

    // Write all remaining words
    while (szl_full_words != 0) {
        szl_full_words--;
        ms_write_big_endian((unsigned char*)achp_dst, al_data[szl_full_words]);
        achp_dst += sizeof(LNUM_WORD);
    }

    return ied_encry_success;
} // m_lnum_store_bytes_be




extern "C" ied_lnum_comparison m_lnum_compare_signed(const struct dsd_lnum* adsp_a,
                                                     const struct dsd_lnum* adsp_b)
{
#ifndef HL_OMIT_PARAM_CHECKS
    if (adsp_a == NULL) {
        return ied_encry_null_pointer_cmp;
    }
    if (adsp_b == NULL) {
        return ied_encry_null_pointer_cmp;
    }
#endif
    if (adsp_a->szc_used_size_bytes == 0 && adsp_b->szc_used_size_bytes == 0) {
        // Both numbers are 0
        return ied_equal;
    }

    // At least one number is not 0

    if (adsp_a->boc_is_negative != adsp_b->boc_is_negative) {
        // Different signs
        if (adsp_a->boc_is_negative) {
            return ied_smaller;
        } else {
            return ied_larger;
        }
    }

    // Long long is used to avoid problems with signed underflow
    long long ill_a_b_abs_cmp = (long long)adsp_a->szc_used_size_bytes -
                                (long long)adsp_b->szc_used_size_bytes;

    if (ill_a_b_abs_cmp == 0) {
        // Equal length, make explicit compare
        ill_a_b_abs_cmp = m_impl_cmp(adsp_a->aucc_data,
                                     adsp_b->aucc_data,
                                     adsp_a->szc_used_size_bytes);

        if (ill_a_b_abs_cmp == 0) {
            return ied_equal;
        }
    }

    if (adsp_a->boc_is_negative) {
        // Comparing negative numbers, swap sign
        ill_a_b_abs_cmp = -ill_a_b_abs_cmp;
    }

    if (ill_a_b_abs_cmp > 0) {
        return ied_larger;
    } else {
        return ied_smaller;
    }
} // m_lnum_compare_signed


extern "C" ied_lnum_comparison m_lnum_compare_absolute(const struct dsd_lnum* adsp_a,
                                                       const struct dsd_lnum* adsp_b)
{
#ifndef HL_OMIT_PARAM_CHECKS
    if (adsp_a == NULL) {
        return ied_encry_null_pointer_cmp;
    }
    if (adsp_b == NULL) {
        return ied_encry_null_pointer_cmp;
    }
#endif
    //Compare magnitudes
    //Leading zeroes are illegal, used_size is a reliable indicator of magnitude
    if (adsp_a->szc_used_size_bytes > adsp_b->szc_used_size_bytes) {
        return ied_larger;
    }
    if (adsp_a->szc_used_size_bytes < adsp_b->szc_used_size_bytes) {
        return ied_smaller;
    }

    //equal magnitude: call implementation (loop down and compare values)
    int inl_ret = m_impl_cmp(adsp_a->aucc_data, adsp_b->aucc_data, adsp_a->szc_used_size_bytes);

    //map -1|0|1 to enum
    if (inl_ret > 0) {
        return ied_larger;
    } else if (inl_ret < 0) {
        return ied_smaller;
    } else {
        return ied_equal;
    }
} // m_lnum_compare_absolute



extern "C" ied_lnum_comparison m_lnum_sign(const struct dsd_lnum* adsp_val)
{
#ifndef HL_OMIT_PARAM_CHECKS
    if (adsp_val == NULL) {
        return ied_encry_null_pointer_cmp;
    }
#endif
    if (adsp_val->szc_used_size_bytes == 0) {
        return ied_zero;
    }
    if (adsp_val->boc_is_negative == FALSE) {
        return ied_positive;
    } else {
        return ied_negative;
    }
}



extern "C" BOOL m_lnum_is_odd(const struct dsd_lnum* adsp_val)
{
#ifndef HL_OMIT_PARAM_CHECKS
    if (adsp_val == NULL) {
        return FALSE;
    }
#endif
    return ((adsp_val->szc_used_size_bytes > 0) && ((((LNUM_WORD*)(adsp_val->aucc_data))[0] & 0x01) == 1));
}



extern "C" BOOL m_lnum_is_even(const struct dsd_lnum* adsp_val)
{
#ifndef HL_OMIT_PARAM_CHECKS
    if (adsp_val == NULL) {
        return FALSE;
    }
#endif
    return ((adsp_val->szc_used_size_bytes == 0) || ((((LNUM_WORD*)(adsp_val->aucc_data))[0] & 0x01) == 0));
}



extern "C" BOOL m_lnum_is_zero(const struct dsd_lnum* adsp_val)
{
#ifndef HL_OMIT_PARAM_CHECKS
    if (adsp_val == NULL) {
        return FALSE;
    }
#endif
    return (adsp_val->szc_used_size_bytes == 0);
}



extern "C" BOOL m_lnum_is_one(const struct dsd_lnum* adsp_val)
{
#ifndef HL_OMIT_PARAM_CHECKS
    if (adsp_val == NULL) {
        return FALSE;
    }
#endif
    return ((adsp_val->szc_used_size_bytes == sizeof(LNUM_WORD)) && (((LNUM_WORD*)(adsp_val->aucc_data))[0] == (LNUM_WORD)(1)) &&
            (adsp_val->boc_is_negative == FALSE));
}



extern "C" ied_encry_return m_lnum_negate(struct dsd_lnum* adsp_val)
{
#ifndef HL_OMIT_PARAM_CHECKS
    if (adsp_val == NULL) {
        return ied_encry_null_pointer;
    }
#endif
    adsp_val->boc_is_negative = !(adsp_val->boc_is_negative);
    return ied_encry_success;
}



extern "C" ied_encry_return m_lnum_add(struct dsd_lnum* adsp_dest,
                                       const struct dsd_lnum* adsp_a,
                                       const struct dsd_lnum* adsp_b)
{
#ifndef HL_OMIT_PARAM_CHECKS
    if (adsp_dest == NULL) {
        return ied_encry_null_pointer;
    }
    if (adsp_a == NULL) {
        return ied_encry_null_pointer;
    }
    if (adsp_b == NULL) {
        return ied_encry_null_pointer;
    }
#endif
    size_t szl_a_len = adsp_a->szc_used_size_bytes;
    size_t szl_b_len = adsp_b->szc_used_size_bytes;
#ifndef HL_OMIT_PARAM_CHECKS
    if (adsp_dest->szc_alloc_size_bytes < (max(szl_a_len, szl_b_len) + 1)) {
        return ied_encry_insufficient_buffer;
    }
#endif

    if (adsp_a->boc_is_negative == adsp_b->boc_is_negative) {
        adsp_dest->szc_used_size_bytes = m_impl_add(adsp_dest->aucc_data,
                                                    adsp_a->aucc_data,
                                                    szl_a_len,
                                                    adsp_b->aucc_data,
                                                    szl_b_len);
        adsp_dest->boc_is_negative = adsp_a->boc_is_negative;
        return ied_encry_success;
    } else {
        switch (m_lnum_compare_absolute(adsp_a,adsp_b)) {
        case ied_equal:
            adsp_dest->szc_used_size_bytes = 0;
            break;
        case ied_larger:
            adsp_dest->szc_used_size_bytes = m_impl_sub(adsp_dest->aucc_data,
                                                        adsp_a->aucc_data,
                                                        szl_a_len,
                                                        adsp_b->aucc_data,
                                                        szl_b_len);
            adsp_dest->boc_is_negative = adsp_a->boc_is_negative;
            break;
        case ied_smaller:
            adsp_dest->szc_used_size_bytes = m_impl_sub(adsp_dest->aucc_data,
                                                        adsp_b->aucc_data,
                                                        szl_b_len,
                                                        adsp_a->aucc_data,
                                                        szl_a_len);
            adsp_dest->boc_is_negative = adsp_b->boc_is_negative;
            break;
        case ied_encry_null_pointer_cmp:
            // Won't happen, just prevents a warning
            return ied_encry_miscellaneous;
        }
        return ied_encry_success;
    }
} // m_lnum_add



extern "C" ied_encry_return m_lnum_sub(struct dsd_lnum* adsp_dest,
                                       const struct dsd_lnum* adsp_a,
                                       const struct dsd_lnum* adsp_b)
{
#ifndef HL_OMIT_PARAM_CHECKS
    if (adsp_dest == NULL) {
        return ied_encry_null_pointer;
    }
    if (adsp_a == NULL) {
        return ied_encry_null_pointer;
    }
    if (adsp_b == NULL) {
        return ied_encry_null_pointer;
    }
#endif
    size_t szl_dest_len = adsp_dest->szc_alloc_size_bytes;
    size_t szl_a_len = adsp_a->szc_used_size_bytes;
    size_t szl_b_len = adsp_b->szc_used_size_bytes;

#ifndef HL_OMIT_PARAM_CHECKS
    if (szl_dest_len < (max(szl_a_len, szl_b_len) + 1)) {
        return ied_encry_insufficient_buffer;
    }
#endif
    if (adsp_a->boc_is_negative == adsp_b->boc_is_negative) {
        switch (m_lnum_compare_absolute(adsp_a,adsp_b)) {
        case ied_equal:
            adsp_dest->szc_used_size_bytes = 0;
            break;
        case ied_larger:
            adsp_dest->szc_used_size_bytes = m_impl_sub(adsp_dest->aucc_data,
                                                        adsp_a->aucc_data,
                                                        szl_a_len,
                                                        adsp_b->aucc_data,
                                                        szl_b_len);
            adsp_dest->boc_is_negative = adsp_a->boc_is_negative;
            break;
        case ied_smaller:
            adsp_dest->szc_used_size_bytes = m_impl_sub(adsp_dest->aucc_data,
                                                        adsp_b->aucc_data,
                                                        szl_b_len,
                                                        adsp_a->aucc_data,
                                                        szl_a_len);
            adsp_dest->boc_is_negative = !(adsp_a->boc_is_negative);
            break;
        case ied_encry_null_pointer_cmp:
            // Won't happen, just prevents a warning
            return ied_encry_miscellaneous;
        }
        return ied_encry_success;
    } else {
        adsp_dest->szc_used_size_bytes = m_impl_add(adsp_dest->aucc_data,
                                                    adsp_a->aucc_data,
                                                    szl_a_len,
                                                    adsp_b->aucc_data,
                                                    szl_b_len);
        adsp_dest->boc_is_negative = adsp_a->boc_is_negative;
        return ied_encry_success;
    }
} // m_lnum_sub


extern "C" ied_encry_return m_lnum_mult(struct dsd_lnum* adsp_dest,
                                        struct dsd_mem_pool_ele* adsp_pool,
                                        const struct dsd_lnum* adsp_a,
                                        const struct dsd_lnum* adsp_b)
{
#ifndef HL_OMIT_PARAM_CHECKS
    if ((adsp_dest == NULL) ||
        (adsp_pool == NULL) ||
        (adsp_a == NULL) ||
        (adsp_b == NULL))
    {
        return ied_encry_null_pointer;
    }
    if((adsp_dest == adsp_a) || (adsp_dest == adsp_b)) {
        return ied_lnum_invalid_inplace;
    }
#endif
    if ((adsp_a->szc_used_size_bytes == 0) || (adsp_b->szc_used_size_bytes == 0)) {
        adsp_dest->szc_used_size_bytes = 0;
        return ied_encry_success;
    }
#ifndef HL_OMIT_PARAM_CHECKS
    if (adsp_dest->szc_alloc_size_bytes < (adsp_a->szc_used_size_bytes + adsp_b->szc_used_size_bytes)) {
        return ied_encry_insufficient_buffer;
    }
#endif
    if((adsp_a->szc_used_size_bytes == adsp_b->szc_used_size_bytes) &&
       (adsp_a->szc_used_size_bytes >= uns_karatsuba_limit))
    {
        dsd_mem_pool_frame dsl_frame = m_mem_pool_get_frame(adsp_pool);
        struct dsd_lnum* adsl_temp = m_mem_pool_get_lnum_byte_size(&adsp_pool,
                                                                   adsp_a->szc_used_size_bytes * 2);
        if (adsl_temp == NULL) {
            m_mem_pool_restore_frame(&adsp_pool, dsl_frame);
            return ied_encry_pool_empty;
        }
        ms_rec_mult(adsp_dest->aucc_data,
                    adsl_temp->aucc_data,
                    adsp_a->aucc_data,
                    adsp_b->aucc_data,
                    adsp_b->szc_used_size_bytes);
        m_mem_pool_restore_frame(&adsp_pool, dsl_frame);
    } else {
        m_impl_mult_basic(adsp_dest->aucc_data,
                          adsp_a->aucc_data,
                          adsp_a->szc_used_size_bytes,
                          adsp_b->aucc_data,
                          adsp_b->szc_used_size_bytes);
    }
    adsp_dest->szc_used_size_bytes = (adsp_a->szc_used_size_bytes + adsp_b->szc_used_size_bytes);
    if (TOP_WORD(adsp_dest) == 0) {
        adsp_dest->szc_used_size_bytes-=sizeof(LNUM_WORD);
    }
    adsp_dest->boc_is_negative = (adsp_a->boc_is_negative ^ adsp_b->boc_is_negative);
    return ied_encry_success;
} // m_lnum_mult

extern "C" ied_encry_return m_lnum_lshift(struct dsd_lnum* adsp_dest,
                                          const struct dsd_lnum* adsp_a,
                                          size_t szp_shift)
{
#ifndef HL_OMIT_PARAM_CHECKS
    if (adsp_dest == NULL) {
        return ied_encry_null_pointer;
    }
    if (adsp_a == NULL) {
        return ied_encry_null_pointer;
    }
#endif
    if (adsp_a->szc_used_size_bytes == 0) {
        m_lnum_set(adsp_dest,0);
        return ied_encry_success;
    }

    size_t szl_shift_words = szp_shift / LNUM_BIT;
    size_t szl_shift_bits = szp_shift % LNUM_BIT;

#ifndef HL_OMIT_PARAM_CHECKS
    if (adsp_dest->szc_alloc_size_bytes < adsp_a->szc_used_size_bytes + szl_shift_words*sizeof(LNUM_WORD) + sizeof(LNUM_WORD) ) {
        return ied_encry_insufficient_buffer;
    }
#endif
    if (szl_shift_bits == 0) {
        memmove(adsp_dest->aucc_data+(szl_shift_words*sizeof(LNUM_WORD)),adsp_a->aucc_data,adsp_a->szc_used_size_bytes);
        memset(adsp_dest->aucc_data,0,szl_shift_words*sizeof(LNUM_WORD));
        adsp_dest->szc_used_size_bytes = adsp_a->szc_used_size_bytes + szl_shift_words * sizeof(LNUM_WORD);
    } else {
        //Shifting by LNUM_BIT is undefined behaviour, may or may not modulo to 0
        ((LNUM_WORD*)(adsp_dest->aucc_data))[adsp_a->szc_used_size_bytes / sizeof(LNUM_WORD) + szl_shift_words] = 0;
        for (signed long long ill_index = (signed long long)adsp_a->szc_used_size_bytes / sizeof(LNUM_WORD)-1; ill_index >= 0; ill_index--) {
            LNUM_WORD url_word = ((LNUM_WORD*)(adsp_a->aucc_data))[ill_index];
            ((LNUM_WORD*)(adsp_dest->aucc_data))[ ill_index+(long long)szl_shift_words] = url_word << szl_shift_bits;
            ((LNUM_WORD*)(adsp_dest->aucc_data))[ ill_index+(long long)szl_shift_words+1] |= url_word >> (LNUM_BIT - szl_shift_bits);
        }
        memset(adsp_dest->aucc_data, 0, (szl_shift_words) * sizeof(LNUM_WORD));


        adsp_dest->szc_used_size_bytes = adsp_a->szc_used_size_bytes + szl_shift_words * sizeof(LNUM_WORD);
        if (((LNUM_WORD*)(adsp_dest->aucc_data))[adsp_dest->szc_used_size_bytes / sizeof(LNUM_WORD)] != (LNUM_WORD)(0)) {
            adsp_dest->szc_used_size_bytes+=sizeof(LNUM_WORD);
        }
    }

    adsp_dest->boc_is_negative = adsp_a->boc_is_negative;
    return ied_encry_success;
} // m_lnum_lshift


extern "C" ied_encry_return m_lnum_rshift(struct dsd_lnum* adsp_dest,
                                          const struct dsd_lnum* adsp_a,
                                          size_t szp_shift)
{
#ifndef HL_OMIT_PARAM_CHECKS
    if (adsp_dest == NULL) {
        return ied_encry_null_pointer;
    }
    if (adsp_a == NULL) {
        return ied_encry_null_pointer;
    }
#endif
    size_t szl_shift_words = szp_shift / LNUM_BIT;
    size_t szl_shift_bits = szp_shift % LNUM_BIT;

    if (szl_shift_words >= adsp_a->szc_used_size_bytes / sizeof(LNUM_WORD)) {
        m_lnum_set(adsp_dest,0);
        return ied_encry_success;
    }
#ifndef HL_OMIT_PARAM_CHECKS
    if (adsp_dest->szc_alloc_size_bytes < adsp_a->szc_used_size_bytes - szl_shift_words * sizeof(LNUM_WORD) ) {
        return ied_encry_insufficient_buffer;
    }
#endif
    if (szl_shift_bits == 0) {
        memmove(adsp_dest->aucc_data, adsp_a->aucc_data + szl_shift_words * sizeof(LNUM_WORD),
                adsp_a->szc_used_size_bytes - szl_shift_words * sizeof(LNUM_WORD));
        adsp_dest->szc_used_size_bytes = adsp_a->szc_used_size_bytes - szl_shift_words * sizeof(LNUM_WORD);
    } else {
        //Shifting by LNUM_BIT is undefined behaviour, may or may not modulo to 0
        ((LNUM_WORD*)(adsp_dest->aucc_data))[0] = ((LNUM_WORD*)(adsp_a->aucc_data))[szl_shift_words] >> szl_shift_bits;
        for (size_t szl_index = szl_shift_words+1; szl_index < adsp_a->szc_used_size_bytes / sizeof(LNUM_WORD); szl_index++) {
            LNUM_WORD url_word = ((LNUM_WORD*)(adsp_a->aucc_data))[szl_index];
            ((LNUM_WORD*)(adsp_dest->aucc_data))[ szl_index-szl_shift_words-1] |= url_word << (LNUM_BIT - szl_shift_bits);
            ((LNUM_WORD*)(adsp_dest->aucc_data))[ szl_index-szl_shift_words] = url_word >> szl_shift_bits;
        }

        adsp_dest->szc_used_size_bytes = adsp_a->szc_used_size_bytes - szl_shift_words * sizeof(LNUM_WORD);
        if (TOP_WORD(adsp_dest) == (LNUM_WORD)(0)) {
            adsp_dest->szc_used_size_bytes-=sizeof(LNUM_WORD);
        }
    }
    adsp_dest->boc_is_negative = adsp_a->boc_is_negative;
    return ied_encry_success;

} // m_lnum_rshift




extern "C" ied_encry_return m_lnum_square(struct dsd_lnum* adsp_dest,
                                          struct dsd_mem_pool_ele* adsp_pool,
                                          const struct dsd_lnum* adsp_val)
{
#ifndef HL_OMIT_PARAM_CHECKS
    if ((adsp_dest == NULL) || (adsp_pool == NULL) || (adsp_val == NULL)) {
        return ied_encry_null_pointer;
    }
    if(adsp_dest == adsp_val) {
        return ied_lnum_invalid_inplace;
    }
    if (adsp_dest->szc_alloc_size_bytes < 2 * adsp_val->szc_used_size_bytes) {
        return ied_encry_insufficient_buffer;
    }
#endif
    if (adsp_val->szc_used_size_bytes == 0) {
        adsp_dest->szc_used_size_bytes = 0;
        return ied_encry_success;
    }

    if( (adsp_pool != NULL) &&  (adsp_val->szc_used_size_bytes >= uns_karatsuba_limit) ) {
        dsd_mem_pool_frame dsl_frame = m_mem_pool_get_frame(adsp_pool);
        struct dsd_lnum* adsl_temp = m_mem_pool_get_lnum_byte_size(&adsp_pool,
                                                                   adsp_val->szc_used_size_bytes * 2);
        if(adsl_temp == NULL) {
            m_mem_pool_restore_frame(&adsp_pool, dsl_frame);
            return ied_encry_pool_empty;
        }
        ms_rec_sqr(adsp_dest->aucc_data,
                   adsl_temp->aucc_data,
                   adsp_val->aucc_data,
                   adsp_val->szc_used_size_bytes);
        m_mem_pool_restore_frame(&adsp_pool, dsl_frame);
    } else {
        m_impl_square(adsp_dest->aucc_data, adsp_val->aucc_data, adsp_val->szc_used_size_bytes);
    }
    adsp_dest->szc_used_size_bytes = 2 * adsp_val->szc_used_size_bytes;
    if (TOP_WORD(adsp_dest) == 0) {
        adsp_dest->szc_used_size_bytes-=sizeof(LNUM_WORD);
    }
    adsp_dest->boc_is_negative = FALSE;
    return ied_encry_success;
} // m_lnum_square


// Essentially, absolute division will be done i.e. |diviend| = |quot|*|divisor| + |mod|
// Resulting signs are only trivially propagated so that (diviend) = (quot)*(divisor) + (mod) is satisfied
extern "C" ied_encry_return m_lnum_divide(struct dsd_lnum* adsp_quot,
                                          struct dsd_lnum* adsp_mod,
                                          struct dsd_mem_pool_ele* adsp_pool,
                                          const struct dsd_lnum* adsp_dividend,
                                          const struct dsd_lnum* adsp_divisor)
{
    BOOL bol_want_quot = (adsp_quot != NULL);
    BOOL bol_want_mod = (adsp_mod != NULL);
#ifndef HL_OMIT_PARAM_CHECKS
    if (adsp_dividend == NULL) {
        return ied_encry_null_pointer;
    }
    if (adsp_divisor == NULL) {
        return ied_encry_null_pointer;
    }
    if (!bol_want_quot && !bol_want_mod) {
        return ied_encry_null_pointer;
    }
    if ((bol_want_mod) && (adsp_mod->szc_alloc_size_bytes < adsp_divisor->szc_used_size_bytes)) {
        return ied_encry_insufficient_buffer;
    }
    //sufficient buffer check for quotient is after trivial cases; to filter cases where the desired size would be negative. Any valid Lnum is large enough to contain a 0 or 1.
#endif
    if (adsp_divisor->szc_used_size_bytes ==0) {
        return ied_lnum_divide_by_zero;
    }

    // output pointers may be identical to input pointers; store certain data locally to prevent corruption
    size_t szl_dividend_len_words = adsp_dividend->szc_used_size_bytes / sizeof(LNUM_WORD);
    BOOL bol_divident_sign = adsp_dividend->boc_is_negative;
    BOOL bol_divisor_sign = adsp_divisor->boc_is_negative;

    //trivial cases
    enum ied_lnum_comparison iel_cmp = m_lnum_compare_absolute(adsp_dividend,adsp_divisor);
    if (iel_cmp == ied_equal) {
        if (bol_want_mod) {
            m_lnum_set(adsp_mod,0);
        }
        if (bol_want_quot) {
            m_lnum_set(adsp_quot,1);
            adsp_quot->boc_is_negative = bol_divident_sign ^ bol_divisor_sign;
        }
        return ied_encry_success;
    }
    if (iel_cmp == ied_smaller) {
        if (bol_want_mod) {
            m_lnum_copy(adsp_mod,adsp_dividend);
        }
        if (bol_want_quot) {
            m_lnum_set(adsp_quot,0);
        }
        return ied_encry_success;
    }
#ifndef HL_OMIT_PARAM_CHECKS
    if ((bol_want_quot) &&
        (adsp_quot->szc_alloc_size_bytes < adsp_dividend->szc_used_size_bytes - adsp_divisor->szc_used_size_bytes + sizeof(LNUM_WORD)))
    {
        //this check is after trivial cases; to filter cases where the desired size would be negative
        return ied_encry_insufficient_buffer;
    }
#endif
    if (adsp_divisor->szc_used_size_bytes == sizeof(LNUM_WORD)) {
        /* Division by a single word
           'The art of computer programming' vol.2 (Knuth),
           4.3.1. exercise 16, p. 582
         */
        LNUM_WORD url_divisor = ((LNUM_WORD*)(adsp_divisor->aucc_data))[0];
        LNUM_WORD url_quotient_word;
        LNUM_WORD urrl_remainder[2] = {0,0};

        for (signed long long ill_j = szl_dividend_len_words - 1;
             ill_j >= 0; ill_j--)
        {
            urrl_remainder[0] = ((LNUM_WORD*)(adsp_dividend->aucc_data))[ill_j];
            url_quotient_word = ms_div_word(urrl_remainder,url_divisor);
            if (bol_want_quot) {
                ((LNUM_WORD*)(adsp_quot->aucc_data))[ill_j] = url_quotient_word;
                //note: written to at the same pace as adsp_dividend is read; no corruption if dividend===quot
            }
            urrl_remainder[1] = ms_mod_word(urrl_remainder,url_divisor);
        }
        if (bol_want_mod) {
            ((LNUM_WORD*)(adsp_mod->aucc_data))[0] = urrl_remainder[1];
            adsp_mod->szc_used_size_bytes = ((urrl_remainder[1] != 0) ? sizeof(LNUM_WORD) : 0);
            adsp_mod->boc_is_negative = bol_divident_sign;
        }
        if (bol_want_quot) {
            adsp_quot->szc_used_size_bytes = (szl_dividend_len_words) * sizeof(LNUM_WORD);
            if (TOP_WORD(adsp_quot) == (LNUM_WORD)0) {
                adsp_quot->szc_used_size_bytes-=sizeof(LNUM_WORD);
            }
            adsp_quot->boc_is_negative = bol_divident_sign ^ bol_divisor_sign;
        }
        return ied_encry_success;
    }


    /* Division by a multi-word divisor
       'The art of computer programming' vol.2 (Knuth),
       4.3.1., Algorithm D, p. 257 ff.,
       Note: Knuth's indices start at the MSW
     */

    //get temporaries
    dsd_mem_pool_frame dsl_frame = m_mem_pool_get_frame(adsp_pool);
    struct dsd_lnum* adsl_n_dividend = m_mem_pool_get_lnum_byte_size(&adsp_pool, adsp_dividend->szc_used_size_bytes + sizeof(LNUM_WORD));
    struct dsd_lnum* adsl_n_divisor = m_mem_pool_get_lnum_byte_size(&adsp_pool, adsp_divisor->szc_used_size_bytes + 2 * sizeof(LNUM_WORD));
    struct dsd_lnum* adsl_tmp = m_mem_pool_get_lnum_byte_size(&adsp_pool, adsp_dividend->szc_used_size_bytes + sizeof(LNUM_WORD));
    if ((adsl_n_dividend == NULL) || (adsl_n_divisor == NULL) || (adsl_tmp == NULL)) {
        m_mem_pool_restore_frame(&adsp_pool, dsl_frame);
        return ied_encry_pool_empty;
    }

    //Knuth: Step D1
    //normalize so the divisor has MSbit set
    unsigned int unl_normalization = ms_count_bits(adsp_divisor->aucc_data,adsp_divisor->szc_used_size_bytes) % LNUM_BIT;
    if (unl_normalization != 0) {
        unl_normalization = LNUM_BIT - unl_normalization;
    }
    m_lnum_lshift(adsl_n_dividend,adsp_dividend,unl_normalization);
    m_lnum_lshift(adsl_n_divisor,adsp_divisor,unl_normalization);

    size_t szl_divisor_len_words = adsl_n_divisor->szc_used_size_bytes / sizeof(LNUM_WORD);
    ((LNUM_WORD*)(adsl_n_divisor->aucc_data))[szl_divisor_len_words] = (LNUM_WORD)0;

    LNUM_WORD url_divisor_msw = ((LNUM_WORD*)(adsl_n_divisor->aucc_data))[szl_divisor_len_words-1];
    LNUM_WORD url_divisor_2msw = ((LNUM_WORD*)(adsl_n_divisor->aucc_data))[szl_divisor_len_words-2];


    int inl_lemma_inequality;
    size_t szl_j;
    //Knuth: Step D2
    //if the normalized dividend has MSbit set, include a leading zero word
    if (TOP_WORD(adsl_n_dividend) >> (LNUM_BIT-1) == 1) {
        szl_j = adsl_n_dividend->szc_used_size_bytes / sizeof(LNUM_WORD);
        ((LNUM_WORD*)(adsl_n_dividend->aucc_data))[adsl_n_dividend->szc_used_size_bytes / sizeof(LNUM_WORD)] = (LNUM_WORD)0;
        if (bol_want_quot) {
            adsp_quot->szc_used_size_bytes = adsl_n_dividend->szc_used_size_bytes - szl_divisor_len_words * sizeof(LNUM_WORD) + sizeof(LNUM_WORD);
        }
    } else {
        szl_j = adsl_n_dividend->szc_used_size_bytes / sizeof(LNUM_WORD) - 1;
        if (bol_want_quot) {
            adsp_quot->szc_used_size_bytes = adsl_n_dividend->szc_used_size_bytes - szl_divisor_len_words * sizeof(LNUM_WORD);
        }
    }

    for (; szl_j >= szl_divisor_len_words; szl_j--) {
        //Knuth: Step D3

        LNUM_WORD* aurl_dividend_msw = &((LNUM_WORD*)(adsl_n_dividend->aucc_data))[szl_j];
        LNUM_WORD* aurl_dividend_ms2w = &((LNUM_WORD*)(adsl_n_dividend->aucc_data))[szl_j-1];

        //if u_j = v_1, estimate = 0xFFFFFF
        LNUM_WORD url_estimate;
        if (m_impl_cmp((unsigned char*)aurl_dividend_msw,(unsigned char*)&url_divisor_msw,sizeof(LNUM_WORD)) == 0) {
            url_estimate = (LNUM_WORD)(-1);
        } else {
            url_estimate = ms_div_word(aurl_dividend_ms2w,url_divisor_msw);
        }

        do {
            //calculate terms for inequality:
            //v_2*q^ > (u_j*b + u_j+1 - q^*v1)*b + u_j+2
            LNUM_WORD ulr_est_x_msw[2];
            LNUM_WORD ulr_est_x_2msw[2];
            m_impl_mult_basic((unsigned char*)ulr_est_x_msw, (unsigned char*)&url_estimate, sizeof(LNUM_WORD), (unsigned char*)&url_divisor_msw, sizeof(LNUM_WORD));   //q^ * v1
            m_impl_mult_basic((unsigned char*)ulr_est_x_2msw, (unsigned char*)&url_estimate, sizeof(LNUM_WORD), (unsigned char*)&url_divisor_2msw, sizeof(LNUM_WORD));  //q^ * v2

            LNUM_WORD ulr_lemma_term[3];  //right-hand side of the inequality: 3 words
            ulr_lemma_term[0] = ((LNUM_WORD*)(adsl_n_dividend->aucc_data))[ szl_j-2];                                // lowest word = u_j+2
            m_impl_sub_karatsuba((unsigned char*)&ulr_lemma_term[1],(unsigned char*)aurl_dividend_ms2w,(unsigned char*)ulr_est_x_msw,2*sizeof(LNUM_WORD));  // high 2 words = (u_j*b + u_j+1 - q^*v1)

            //comparing 3-word value with 2-word value: check for superior length first
            if (ulr_lemma_term[2] != 0) {
                inl_lemma_inequality = 1;
            } else {
                inl_lemma_inequality = m_impl_cmp((unsigned char*)ulr_lemma_term,(unsigned char*)ulr_est_x_2msw,2*sizeof(LNUM_WORD));
            }

            //if inequality holds true, decrease by 1 and repeat test
            if (inl_lemma_inequality == -1) {
                url_estimate--;
                continue;
            }

        } while (inl_lemma_inequality == -1);

        //Knuth: Step D4


        m_impl_mult_basic(adsl_tmp->aucc_data, (unsigned char*)&url_estimate, sizeof(LNUM_WORD), adsl_n_divisor->aucc_data, szl_divisor_len_words * sizeof(LNUM_WORD));

        BOOL bol_negative = m_impl_sub_karatsuba(
            (unsigned char*)&(((LNUM_WORD*)(adsl_n_dividend->aucc_data))[ szl_j - szl_divisor_len_words]),
            (unsigned char*)&(((LNUM_WORD*)(adsl_n_dividend->aucc_data))[ szl_j - szl_divisor_len_words]),
            adsl_tmp->aucc_data,
            (szl_divisor_len_words + 1) * sizeof(LNUM_WORD));

        // D5 and D6 reversed compared to Knuth, adjustment is performed on the temporary variable
        //Knuth: Step D6
        if (bol_negative) {
            url_estimate--;
            m_impl_add_karatsuba(
                (unsigned char*)&(((LNUM_WORD*)(adsl_n_dividend->aucc_data))[ szl_j - szl_divisor_len_words]),
                (unsigned char*)&(((LNUM_WORD*)(adsl_n_dividend->aucc_data))[ szl_j - szl_divisor_len_words]),
                adsl_n_divisor->aucc_data,
                (szl_divisor_len_words + 1) * sizeof(LNUM_WORD));
        }

        //Knuth: Step D5
        if (bol_want_quot) {
            ((LNUM_WORD*)(adsp_quot->aucc_data))[ szl_j - szl_divisor_len_words] = url_estimate;
        }

    }

    //Knuth: Step D8
    if (bol_want_mod) {
        while ((adsl_n_dividend->szc_used_size_bytes > 0) &&
               (TOP_WORD(adsl_n_dividend)==(LNUM_WORD)0))
        {
            adsl_n_dividend->szc_used_size_bytes-=sizeof(LNUM_WORD);
        }
        m_lnum_rshift(adsp_mod,adsl_n_dividend,unl_normalization);
        adsp_mod->boc_is_negative = bol_divident_sign;
    }
    if (bol_want_quot) {
        if (TOP_WORD(adsp_quot) == (LNUM_WORD)0) {
            adsp_quot->szc_used_size_bytes-=sizeof(LNUM_WORD);
        }
        adsp_quot->boc_is_negative = bol_divident_sign ^ bol_divisor_sign;
    }
    m_mem_pool_restore_frame(&adsp_pool, dsl_frame);
    return ied_encry_success;
} // m_lnum_divide


extern "C" ied_encry_return m_lnum_lcm(struct dsd_lnum* adsp_lcm,
                                       struct dsd_mem_pool_ele* adsp_pool,
                                       const struct dsd_lnum* adsp_a,
                                       const struct dsd_lnum* adsp_b)
{
#ifndef HL_OMIT_PARAM_CHECKS
    if( (adsp_lcm == NULL) ||
        (adsp_pool == NULL) ||
        (adsp_a == NULL) ||
        (adsp_b == NULL))
    {
        return ied_encry_null_pointer;
    }
    if( (adsp_lcm == adsp_a) || (adsp_lcm == adsp_b)) {
        return ied_lnum_invalid_inplace;
    }
    if( adsp_lcm->szc_alloc_size_bytes < (adsp_a->szc_used_size_bytes +
                                          adsp_b->szc_used_size_bytes))
    {
        return ied_encry_insufficient_buffer;
    }
#endif
    if( m_lnum_is_zero(adsp_a) || m_lnum_is_zero(adsp_b) ) {
        return ied_encry_invalid_input;
    }

    if( adsp_a->szc_used_size_bytes > adsp_b->szc_used_size_bytes ) {
        // A is larger, swap it with B to improve performance of division
        const dsd_lnum* adsl_swap = adsp_a;
        adsp_a = adsp_b;
        adsp_b = adsl_swap;
    }

    // GCD cannot be larger, than either factor
    dsd_mem_pool_frame dsl_frame = m_mem_pool_get_frame(adsp_pool);
    dsd_lnum* adsl_temp = m_mem_pool_get_lnum_same_size(&adsp_pool, adsp_a);
    if(adsl_temp == NULL) {
        m_mem_pool_restore_frame(&adsp_pool, dsl_frame);
        return ied_encry_pool_empty;
    }
    ied_encry_return iel_ret = m_lnum_gcd(adsl_temp, adsp_pool, adsp_a, adsp_b);

    if(iel_ret != ied_encry_success) {
        m_mem_pool_restore_frame(&adsp_pool, dsl_frame);
        return iel_ret;
    }

    // Divide A by GCD
    iel_ret = m_lnum_divide(adsl_temp, NULL, adsp_pool, adsp_a, adsl_temp);

    if(iel_ret != ied_encry_success) {
        m_mem_pool_restore_frame(&adsp_pool, dsl_frame);
        return iel_ret;
    }

    // Calculate the LCM
    iel_ret = m_lnum_mult(adsp_lcm, adsp_pool, adsl_temp, adsp_b);
    adsp_lcm->boc_is_negative= FALSE;

    m_mem_pool_restore_frame(&adsp_pool, dsl_frame);
    return iel_ret;
} // m_lnum_lcm

extern "C" ied_encry_return m_lnum_gcd(struct dsd_lnum* adsp_gcd,
                                       struct dsd_mem_pool_ele* adsp_pool,
                                       const struct dsd_lnum* adsp_a,
                                       const struct dsd_lnum* adsp_b)
{
#ifndef HL_OMIT_PARAM_CHECKS
    if ((adsp_gcd == NULL) || (adsp_a == NULL) || (adsp_b == NULL) || (adsp_pool == NULL)) {
        return ied_encry_null_pointer;
    }
    if((adsp_gcd == adsp_a) || (adsp_gcd == adsp_b)) {
        return ied_lnum_invalid_inplace;
    }
#endif
    if ((adsp_a->szc_used_size_bytes == 0) || (adsp_b->szc_used_size_bytes == 0)) {
        adsp_gcd->szc_used_size_bytes = 0;
        return ied_lnum_divide_by_zero;
    }

    dsd_mem_pool_frame dsl_frame = m_mem_pool_get_frame(adsp_pool);

    //input parameters are const, establish local copies. Assure they have at least an extra word
    size_t szl_temp_bytes = (max(adsp_a->szc_used_size_bytes,
                                 adsp_b->szc_used_size_bytes)
                             + sizeof(LNUM_WORD));
    struct dsd_lnum* adsl_a = m_mem_pool_get_lnum_byte_size(&adsp_pool,szl_temp_bytes);
    struct dsd_lnum* adsl_b = m_mem_pool_get_lnum_byte_size(&adsp_pool,szl_temp_bytes);
    if ((adsl_b == NULL) || (adsl_a == NULL)) {
        m_mem_pool_restore_frame(&adsp_pool, dsl_frame);
        return ied_encry_pool_empty;
    }

    size_t szl_common_shift = 0;

    //If A or B or both are even, rshift to oddness. In case of both, remember the common shift factor
    //Instead of a loop of 1-shifts, count trailing zeroes and shift in one operation
    //[1]
    size_t szl_a_even = ms_count_trailing_zeroes(adsp_a->aucc_data,adsp_a->szc_used_size_bytes);
    size_t szl_b_even = ms_count_trailing_zeroes(adsp_b->aucc_data,adsp_b->szc_used_size_bytes);
    m_lnum_rshift(adsl_a,adsp_a,szl_a_even);
    m_lnum_rshift(adsl_b,adsp_b,szl_b_even);
    szl_common_shift = min(szl_a_even, szl_b_even);

    //From now on, B will always be odd.
    //It is NOT assumed that A >= B.
    for(;; ) {
        szl_a_even = ms_count_trailing_zeroes(adsl_a->aucc_data,adsp_a->szc_used_size_bytes);
        //[2]
        if (szl_a_even) {
            m_lnum_rshift(adsl_a,adsl_a,szl_a_even);
        }
        ied_lnum_comparison iel_cmp = m_lnum_compare_absolute(adsl_a,adsl_b);
        if (iel_cmp == ied_equal) {
            break;
        }
        if (iel_cmp == ied_smaller) {
            m_lnum_sub(adsl_b,adsl_b,adsl_a);
            {
                //[3]
                struct dsd_lnum* adsl_tmp = adsl_a;
                adsl_a = adsl_b;
                adsl_b = adsl_tmp;
            }
        }
        if (iel_cmp == ied_larger) {
            m_lnum_sub(adsl_a,adsl_a,adsl_b);
        }
    }

    //Insufficient buffer error case detected by m_lnum_lshift and passed on
    ied_encry_return iel_ret = m_lnum_lshift(adsp_gcd,adsl_a,szl_common_shift);
    m_mem_pool_restore_frame(&adsp_pool, dsl_frame);

    // Force sign to be positive
    adsp_gcd->boc_is_negative = FALSE;
    return iel_ret;
} // m_lnum_gcd




/*
   Helper function used for m_lnum_inverse, odd mod case
   Suppose s * val + a * mod = u.
   The function updates s, in case the trailing zeros of u (reduced_bitlen bits) are cut off.
 */
static void m_update_coeff_odd_mod(struct dsd_lnum* adsp_s,
                                   struct dsd_lnum* adsp_mod,
                                   size_t szp_reduced_bitlen)
{
    size_t szl_shift_count = 0;                           // Counter for trailing zeros of s
    for (size_t szl_i = 0; szl_i < szp_reduced_bitlen; szl_i++) {
        size_t szl_index = szl_shift_count / (sizeof(LNUM_WORD)*8);
        size_t szl_bit_position = szl_shift_count % (sizeof(LNUM_WORD)*8);
        if ((((LNUM_WORD*)(adsp_s->aucc_data))[ szl_index] & ((LNUM_WORD) 1 << szl_bit_position)) != 0) {
            m_lnum_rshift(adsp_s, adsp_s, szl_shift_count);     // Shift out all trailing zeros
            m_lnum_add(adsp_s, adsp_s, adsp_mod);               // After addition, MLB becomes zero
            szl_shift_count = 0;                                // Reset shift_count
        }
        szl_shift_count++;
    }
    m_lnum_rshift(adsp_s, adsp_s, szl_shift_count);
}
/*
   Helper function used for m_lnum_inverse, even mod case
   Similar to odd case but more parameters are needed
 */
static void m_update_coeff_even_mod(struct dsd_lnum* adsp_s,
                                    struct dsd_lnum* adsp_a,
                                    struct dsd_lnum* adsp_val,
                                    struct dsd_lnum* adsp_mod,
                                    size_t szp_reduced_bitlen)
{
    size_t szl_shift_count = 0;                           // Counter for trailing zeros of a
    for (size_t szl_i = 0; szl_i < szp_reduced_bitlen; szl_i++) {
        size_t szl_index = szl_shift_count / (sizeof(LNUM_WORD)*8);
        size_t szl_bit_position = szl_shift_count % (sizeof(LNUM_WORD)*8);
        if ((((LNUM_WORD*)(adsp_a->aucc_data))[ szl_index] & ((LNUM_WORD) 1 << szl_bit_position)) != 0) {
            m_lnum_rshift(adsp_a, adsp_a, szl_shift_count);     // Shift out all trailing zeros of a
            m_lnum_rshift(adsp_s, adsp_s, szl_shift_count);     // Shift out as many zeros of s
            m_lnum_sub(adsp_a, adsp_a, adsp_val);               // After subtraction, MLB becomes zero
            m_lnum_add(adsp_s, adsp_s, adsp_mod);
            szl_shift_count = 0;                                // Reset shift_count
        }
        szl_shift_count++;
    }
    m_lnum_rshift(adsp_a, adsp_a, szl_shift_count);
    m_lnum_rshift(adsp_s, adsp_s, szl_shift_count);
} // m_update_coeff_even_mod

extern "C" ied_encry_return m_lnum_inverse(struct dsd_lnum* adsp_inv,
                                           struct dsd_mem_pool_ele* adsp_pool,
                                           const struct dsd_lnum* adsp_val,
                                           const struct dsd_lnum* adsp_mod)
{
#ifndef HL_OMIT_PARAM_CHECKS
    if ((adsp_inv == NULL) || (adsp_pool == NULL) || (adsp_val == NULL) || (adsp_mod == NULL)) {
        return ied_encry_null_pointer;
    }
    if((adsp_inv == adsp_val) || (adsp_inv == adsp_mod)) {
        return ied_lnum_invalid_inplace;
    }
    if (adsp_inv->szc_alloc_size_bytes < adsp_mod->szc_used_size_bytes + 2*sizeof(LNUM_WORD)) {
        return ied_encry_insufficient_buffer;
    }
#endif
    if ((adsp_val->szc_used_size_bytes == 0) || (adsp_mod->szc_used_size_bytes == 0)) {
        adsp_inv->szc_used_size_bytes = 0;
        return ied_lnum_divide_by_zero;
    }
    if (m_lnum_is_even(adsp_mod) && m_lnum_is_even(adsp_val)) {
        // GCD != 1
        return ied_lnum_invalid_modulus;
    }
    dsd_mem_pool_frame dsl_frame = m_mem_pool_get_frame(adsp_pool);
    // Input parameters are const, establish local copies
    size_t szl_temp_size = adsp_mod->szc_used_size_bytes + 2 * sizeof(LNUM_WORD);
    struct dsd_lnum* adsl_u = m_mem_pool_get_lnum_byte_size(&adsp_pool,szl_temp_size);
    struct dsd_lnum* adsl_v = m_mem_pool_get_lnum_byte_size(&adsp_pool,szl_temp_size);
    struct dsd_lnum* adsl_s = m_mem_pool_get_lnum_byte_size(&adsp_pool,szl_temp_size);
    if ((adsl_u == NULL) || (adsl_v == NULL) || (adsl_s == NULL)) {
        m_mem_pool_restore_frame(&adsp_pool, dsl_frame);
        return ied_encry_pool_empty;
    }
    struct dsd_lnum* adsl_t = adsp_inv;
    // Define absolute values of adsp_mod and adsp_val
    // Caution: These are wappers of the input values, so shallowly copied
    struct  dsd_lnum dsl_mod_abs = *adsp_mod;
    struct  dsd_lnum dsl_val_abs = *adsp_val;
    dsl_mod_abs.boc_is_negative = FALSE;
    dsl_val_abs.boc_is_negative = FALSE;
    BOOL bol_val_out_of_bounds = FALSE;
    // Check if the adsp_val is in a correct range
    if (m_lnum_compare_absolute(&dsl_val_abs,&dsl_mod_abs)!=ied_smaller) {
        bol_val_out_of_bounds = TRUE;
    }

    if (!bol_val_out_of_bounds) {
        m_lnum_copy(adsl_u, &dsl_val_abs);
    } else {
        m_lnum_divide(NULL,adsl_u,adsp_pool,&dsl_val_abs,&dsl_mod_abs);
    }
    m_lnum_copy(adsl_v,&dsl_mod_abs);
    // Extended binary GCD algorithm
    // See e.g. Handbook of Applied cryptography (s,a,t,b are called A,B,C,D there)
    m_lnum_set(adsl_s,1);
    m_lnum_set(adsl_t,0);
    if (m_lnum_is_odd(adsp_mod)) {
        // Usual extended binary algorithm, but adsl_s and adsl_t are chosen in the range [0,mod-1]
        // Everything is non-negative
        while ((!m_lnum_is_zero(adsl_u)) && (!m_lnum_is_zero(adsl_v))) {
            // Cut trailing zeros of u off
            size_t szl_u_zero_count = ms_count_trailing_zeroes(adsl_u->aucc_data, adsl_u->szc_used_size_bytes);
            m_lnum_rshift(adsl_u,adsl_u,szl_u_zero_count);
            m_update_coeff_odd_mod(adsl_s, &dsl_mod_abs, szl_u_zero_count);
            // Cut trailing zeros of v off
            size_t szl_v_zero_count = ms_count_trailing_zeroes(adsl_v->aucc_data, adsl_v->szc_used_size_bytes);
            m_lnum_rshift(adsl_v,adsl_v,szl_v_zero_count);
            m_update_coeff_odd_mod(adsl_t, &dsl_mod_abs, szl_v_zero_count);

            switch (m_lnum_compare_absolute(adsl_u,adsl_v)) {
            case ied_equal:
                if(!m_lnum_is_one(adsl_u)) {
                    // GCD != 1
                    m_mem_pool_restore_frame(&adsp_pool,dsl_frame);
                    return ied_lnum_invalid_modulus;
                }
            // Intentional fall-through for GCD == 1
            case ied_larger:
                m_lnum_sub(adsl_u,adsl_u,adsl_v);
                if (m_lnum_compare_absolute(adsl_s,adsl_t)==ied_smaller) {
                    m_lnum_add(adsl_s,adsl_s,&dsl_mod_abs);
                }
                m_lnum_sub(adsl_s,adsl_s,adsl_t);
                break;
            case ied_smaller:
                m_lnum_sub(adsl_v,adsl_v,adsl_u);
                if (m_lnum_compare_absolute(adsl_t,adsl_s)==ied_smaller) {
                    m_lnum_add(adsl_t,adsl_t,&dsl_mod_abs);
                }
                m_lnum_sub(adsl_t,adsl_t,adsl_s);
                break;
            case ied_encry_null_pointer_cmp:
                // Will not happen
                m_mem_pool_restore_frame(&adsp_pool,dsl_frame);
                return ied_encry_miscellaneous;
            }
        }
    } else {
        // Analogous to the odd case above but further temps adsl_a, adsl_b are needed here
        // Note that adsl_a and adsl_b may be negative and may moderately exceed mod
        struct dsd_lnum* adsl_a = m_mem_pool_get_lnum_byte_size(&adsp_pool,szl_temp_size);
        struct dsd_lnum* adsl_b = m_mem_pool_get_lnum_byte_size(&adsp_pool,szl_temp_size);
        if ((adsl_a == NULL) || (adsl_b == NULL)) {
            m_mem_pool_restore_frame(&adsp_pool, dsl_frame);
            return ied_encry_pool_empty;
        }
        m_lnum_set(adsl_a,0);
        m_lnum_set(adsl_b,1);
        while ((!m_lnum_is_zero(adsl_u)) && (!m_lnum_is_zero(adsl_v))) {
            size_t szl_u_zero_count = ms_count_trailing_zeroes(adsl_u->aucc_data, adsl_u->szc_used_size_bytes);
            m_lnum_rshift(adsl_u,adsl_u,szl_u_zero_count);
            m_update_coeff_even_mod(adsl_s, adsl_a, &dsl_val_abs, &dsl_mod_abs, szl_u_zero_count);
            size_t szl_v_zero_count = ms_count_trailing_zeroes(adsl_v->aucc_data, adsl_v->szc_used_size_bytes);
            m_lnum_rshift(adsl_v,adsl_v,szl_v_zero_count);
            m_update_coeff_even_mod(adsl_t, adsl_b, &dsl_val_abs, &dsl_mod_abs, szl_v_zero_count);
            switch (m_lnum_compare_absolute(adsl_u,adsl_v)) {
            case ied_equal:
                if(!m_lnum_is_one(adsl_u)) {
                    // GCD != 1
                    m_mem_pool_restore_frame(&adsp_pool,dsl_frame);
                    return ied_lnum_invalid_modulus;
                }
            // Intentional fall-through for GCD == 1
            case ied_larger:
                m_lnum_sub(adsl_u,adsl_u,adsl_v);
                if (m_lnum_compare_absolute(adsl_s,adsl_t)==ied_smaller) {
                    m_lnum_add(adsl_s,adsl_s,&dsl_mod_abs);
                    m_lnum_sub(adsl_a,adsl_a,&dsl_val_abs);
                }
                m_lnum_sub(adsl_s,adsl_s,adsl_t);
                m_lnum_sub(adsl_a,adsl_a,adsl_b);
                break;
            case ied_smaller:
                m_lnum_sub(adsl_v,adsl_v,adsl_u);
                if (m_lnum_compare_absolute(adsl_t,adsl_s)==ied_smaller) {
                    m_lnum_add(adsl_t,adsl_t,&dsl_mod_abs);
                    m_lnum_sub(adsl_b,adsl_b,&dsl_val_abs);
                }
                m_lnum_sub(adsl_t,adsl_t,adsl_s);
                m_lnum_sub(adsl_b,adsl_b,adsl_a);
                break;
            case ied_encry_null_pointer_cmp:
                // Will not happen
                m_mem_pool_restore_frame(&adsp_pool,dsl_frame);
                return ied_encry_miscellaneous;
            }
        }
    }
    if (!m_lnum_is_zero(adsl_u)) {
        m_lnum_copy(adsp_inv,adsl_s);
    } // Otherwise, adsl_t = adsp_inv
    m_mem_pool_restore_frame(&adsp_pool,dsl_frame);
    return ied_encry_success;
} // m_lnum_inverse


extern "C" ied_encry_return m_lnum_barret_init(struct dsd_lnum_barret* adsp_barret,
                                               struct dsd_memory* adsp_memory,
                                               struct dsd_mem_pool_ele* adsp_pool,
                                               const struct dsd_lnum* adsp_modulus)
{
#ifndef HL_OMIT_PARAM_CHECKS
    if ((adsp_barret == NULL) || (adsp_pool == NULL) || (adsp_modulus == NULL)) {
        return ied_encry_null_pointer;
    }
#endif
    int inl_n = m_lnum_get_bit_count(adsp_modulus);
    int inl_k = inl_n * 2;
    adsp_barret->adsc_modulus = m_lnum_clone(adsp_memory, adsp_modulus);
    if (adsp_barret->adsc_modulus == NULL) {
        return ied_encry_alloc_failure;
    }
    adsp_barret->adsc_mu = m_lnum_create(adsp_memory, inl_n / CHAR_BIT + 2*sizeof(LNUM_WORD));
    if (adsp_barret->adsc_modulus == NULL) {
        m_lnum_destroy(adsp_memory,adsp_barret->adsc_modulus);
        return ied_encry_alloc_failure;
    }
    adsp_barret->unc_n = inl_n;

    dsd_mem_pool_frame dsl_frame = m_mem_pool_get_frame(adsp_pool);
    struct dsd_lnum* adsl_a = m_mem_pool_get_lnum_byte_size(&adsp_pool, (size_t)inl_k / CHAR_BIT + 2*sizeof(LNUM_WORD));
    if (adsl_a == NULL) {
        m_lnum_free(adsp_memory,adsp_barret->adsc_mu);
        m_lnum_free(adsp_memory,adsp_barret->adsc_modulus);
        return ied_encry_pool_empty;
    }
    m_lnum_set(adsl_a,1);
    m_lnum_lshift(adsl_a,adsl_a,(size_t)inl_k);

    ied_encry_return iel_div_ret = m_lnum_divide(adsp_barret->adsc_mu, NULL, adsp_pool, adsl_a, adsp_modulus);
    if (iel_div_ret != ied_encry_success) {
        m_lnum_free(adsp_memory,adsp_barret->adsc_mu);
        m_lnum_free(adsp_memory,adsp_barret->adsc_modulus);
    }
    m_mem_pool_restore_frame(&adsp_pool, dsl_frame);
    return iel_div_ret;
} // m_lnum_barret_init

extern "C" ied_encry_return m_lnum_barret_reduce(struct dsd_lnum* adsp_dest,
                                                 struct dsd_mem_pool_ele* adsp_pool,
                                                 const struct dsd_lnum* adsp_val,
                                                 const struct dsd_lnum_barret* adsp_modulus)
{
#ifndef HL_OMIT_PARAM_CHECKS
    if ((adsp_dest == NULL) || (adsp_pool == NULL)|| (adsp_val == NULL) || (adsp_modulus == NULL)) {
        return ied_encry_null_pointer;
    }

    if (adsp_dest->szc_alloc_size_bytes < adsp_modulus->adsc_modulus->szc_used_size_bytes) {
        return ied_encry_insufficient_buffer;
    }

#endif
    if (adsp_val->szc_used_size_bytes > (adsp_modulus->adsc_modulus->szc_used_size_bytes*2)) {
        return ied_encry_invalid_input;
    }
    if (m_lnum_sign(adsp_val) == ied_negative) {
        return ied_encry_invalid_input;
    }

    dsd_mem_pool_frame dsl_frame = m_mem_pool_get_frame(adsp_pool);
    struct dsd_lnum* adsl_temp1, *adsl_temp2;

    adsl_temp1 = m_mem_pool_get_lnum_byte_size(&adsp_pool,
                                               2 * adsp_modulus->adsc_modulus->szc_used_size_bytes + sizeof(LNUM_WORD));
    adsl_temp2 = m_mem_pool_get_lnum_byte_size(&adsp_pool,
                                               2 * adsp_modulus->adsc_modulus->szc_used_size_bytes + sizeof(LNUM_WORD));
    if (adsl_temp2 == NULL) {
        m_mem_pool_restore_frame(&adsp_pool, dsl_frame);
        return ied_encry_pool_empty;
    }

    m_lnum_rshift(adsl_temp1,adsp_val,adsp_modulus->unc_n);

    m_lnum_mult(adsl_temp2, adsp_pool, adsl_temp1, adsp_modulus->adsc_mu);

    m_lnum_rshift(adsl_temp2, adsl_temp2, adsp_modulus->unc_n);

    m_lnum_mult(adsl_temp1, adsp_pool, adsl_temp2, adsp_modulus->adsc_modulus);
    m_lnum_sub(adsl_temp1, adsp_val, adsl_temp1);

    if (m_lnum_compare_absolute(adsl_temp1,adsp_modulus->adsc_modulus) != ied_smaller) {
        m_lnum_sub(adsl_temp1, adsl_temp1, adsp_modulus->adsc_modulus);
    }
    if (m_lnum_compare_absolute(adsl_temp1,adsp_modulus->adsc_modulus) != ied_smaller) {
        m_lnum_sub(adsl_temp1, adsl_temp1, adsp_modulus->adsc_modulus);
    }
    m_lnum_copy(adsp_dest, adsl_temp1);
    m_mem_pool_restore_frame(&adsp_pool, dsl_frame);
    return ied_encry_success;
} // m_lnum_barret_reduce

extern "C" void m_lnum_barret_free(struct dsd_memory* adsp_memory,
                                   struct dsd_lnum_barret* adsp_barret)
{
    m_lnum_destroy(adsp_memory,adsp_barret->adsc_mu);
    m_lnum_destroy(adsp_memory,adsp_barret->adsc_modulus);
    return;
}

extern "C" ied_encry_return m_lnum_exp_mod(struct dsd_lnum* adsp_dest,
                                           struct dsd_mem_pool_ele* adsp_pool,
                                           const struct dsd_lnum* adsp_base,
                                           const struct dsd_lnum* adsp_exp,
                                           const struct dsd_lnum* adsp_mod)
{
#ifndef HL_OMIT_PARAM_CHECKS
    if((adsp_dest == NULL) ||
       (adsp_pool == NULL) ||
       (adsp_base == NULL) ||
       (adsp_exp == NULL) ||
       (adsp_mod == NULL))
    {
        return ied_encry_null_pointer;
    }
    if((adsp_dest == adsp_base) || (adsp_dest == adsp_exp) || (adsp_dest == adsp_mod)) {
        return ied_lnum_invalid_inplace;
    }
    if(adsp_dest->szc_alloc_size_bytes < adsp_mod->szc_used_size_bytes) {
        return ied_encry_insufficient_buffer;
    }
#endif
    if((adsp_base->szc_used_size_bytes > adsp_mod->szc_used_size_bytes) ||
       adsp_base->boc_is_negative ||
       adsp_exp->boc_is_negative)
    {
        return ied_encry_invalid_input;
    }

    if(adsp_mod->boc_is_negative) {
        return ied_lnum_invalid_modulus;
    }

    // Process trivial cases
    adsp_dest->boc_is_negative = FALSE;
    if( adsp_exp->szc_used_size_bytes == 0) {
        m_lnum_set(adsp_dest, 1);
        return ied_encry_success;
    }

    if( adsp_base->szc_used_size_bytes == 0) {
        adsp_dest->szc_used_size_bytes = 0;
        return ied_encry_success;
    }

    if( m_lnum_is_one(adsp_exp) ) {
        m_lnum_copy(adsp_dest, adsp_base);
        return ied_encry_success;
    }

    // Split to Montgomery and non-Montgomery cases
    if( m_lnum_is_odd(adsp_mod) ) {
        dsd_mem_pool_frame dsl_frame = m_mem_pool_get_frame(adsp_pool);
        dsd_lnum_montgomery_ctx dsl_context;
        dsl_context.adsc_r_sqr = m_mem_pool_get_lnum_same_size(&adsp_pool, adsp_mod);
        dsl_context.adsc_mont_one = m_mem_pool_get_lnum_same_size(&adsp_pool, adsp_mod);
        if((dsl_context.adsc_r_sqr == NULL) || (dsl_context.adsc_mont_one == NULL)) {
            m_mem_pool_restore_frame(&adsp_pool, dsl_frame);
            return ied_encry_pool_empty;
        }

        // Safe to cast const away!
        dsl_context.adsc_mod = (dsd_lnum*)adsp_mod;

        ied_encry_return iel_ret = m_mont_init_impl(&dsl_context, adsp_pool);
        if(iel_ret != ied_encry_success) {
            m_mem_pool_restore_frame(&adsp_pool, dsl_frame);
            return iel_ret;
        }

        iel_ret = ms_exp_mod_mont(adsp_dest, adsp_pool, adsp_base, adsp_exp, &dsl_context);

        m_mem_pool_restore_frame(&adsp_pool, dsl_frame);
        return iel_ret;
    } else {
        return ms_exp_mod_std(adsp_dest, adsp_pool, adsp_base, adsp_exp, adsp_mod);
    }
} // m_lnum_exp_mod

extern "C" ied_encry_return m_lnum_mont_init(struct dsd_lnum_montgomery_ctx* adsp_new_ctx,
                                             struct dsd_memory* adsp_mem,
                                             struct dsd_mem_pool_ele* adsp_pool,
                                             const struct dsd_lnum* adsp_mod)
{
#ifndef HL_OMIT_PARAM_CHECKS
    if( (adsp_new_ctx == NULL) ||
        (adsp_mod == NULL) ||
        (adsp_pool == NULL) ||
        (adsp_mem == NULL))
    {
        return ied_encry_null_pointer;
    }
#endif
    if( m_lnum_is_even( adsp_mod) || adsp_mod->boc_is_negative || m_lnum_is_one(adsp_mod) ) {
        return ied_lnum_invalid_modulus;
    }

    size_t szl_alloc_bytes = adsp_mod->szc_used_size_bytes;

    // Allocate lnums for modulo and r^2 mod n
    adsp_new_ctx->adsc_mod = m_lnum_clone(adsp_mem, adsp_mod);
    adsp_new_ctx->adsc_r_sqr = m_lnum_create(adsp_mem, szl_alloc_bytes);
    adsp_new_ctx->adsc_mont_one = m_lnum_create(adsp_mem, szl_alloc_bytes);

    ied_encry_return iel_ret;
    if( (adsp_new_ctx->adsc_mod == NULL) ||
        (adsp_new_ctx->adsc_r_sqr == NULL) ||
        (adsp_new_ctx->adsc_mont_one == NULL))
    {
        iel_ret = ied_encry_alloc_failure;
        goto error;
    }

    iel_ret = m_mont_init_impl(adsp_new_ctx, adsp_pool);

    if (iel_ret != ied_encry_success) {
        goto error;
    }

    return ied_encry_success;
error:
    m_lnum_destroy(adsp_mem, adsp_new_ctx->adsc_mod);
    adsp_new_ctx->adsc_mod = NULL;
    m_lnum_destroy(adsp_mem, adsp_new_ctx->adsc_r_sqr);
    adsp_new_ctx->adsc_r_sqr = NULL;
    m_lnum_destroy(adsp_mem, adsp_new_ctx->adsc_mont_one);
    adsp_new_ctx->adsc_mont_one = NULL;

    return iel_ret;
} // m_lnum_mont_init

extern "C" void m_lnum_mont_free(struct dsd_lnum_montgomery_ctx* adsp_context,
                                 struct dsd_memory* adsp_mem)
{
#ifndef HL_OMIT_PARAM_CHECKS
    if((adsp_context == NULL) || (adsp_mem == NULL)) {
        return;
    }
#endif
    m_lnum_destroy(adsp_mem, adsp_context->adsc_mod);
    m_lnum_destroy(adsp_mem, adsp_context->adsc_r_sqr);
    m_lnum_destroy(adsp_mem, adsp_context->adsc_mont_one);
    memset(adsp_context, 0, sizeof(dsd_lnum_montgomery_ctx));
}

extern "C" ied_encry_return m_lnum_mont_red(struct dsd_lnum* adsp_dest,
                                            struct dsd_mem_pool_ele* adsp_pool,
                                            const struct dsd_lnum* adsp_a,
                                            const struct dsd_lnum_montgomery_ctx* adsp_context)
{
#ifndef HL_OMIT_PARAM_CHECKS
    if( (adsp_dest == NULL) ||
        (adsp_a == NULL) ||
        (adsp_context == NULL) ||
        (adsp_pool == NULL))
    {
        return ied_encry_null_pointer;
    }
#endif
#ifndef HL_OMIT_PARAM_CHECKS
    if( adsp_dest->szc_alloc_size_bytes < adsp_context->adsc_mod->szc_used_size_bytes ) {
        return ied_encry_insufficient_buffer;
    }
#endif
    if( (adsp_a->szc_used_size_bytes > (adsp_context->adsc_mod->szc_used_size_bytes*2)) || adsp_a->boc_is_negative ) {
        return ied_encry_invalid_input;
    }

    dsd_mem_pool_frame dsl_frame = m_mem_pool_get_frame(adsp_pool);
    dsd_lnum* adsl_temp_1 = m_mem_pool_get_lnum_byte_size(&adsp_pool,
                                                          adsp_context->adsc_mod->szc_used_size_bytes*2+sizeof(LNUM_WORD));
    dsd_lnum* adsl_temp_2 = m_mem_pool_get_lnum_byte_size(&adsp_pool,
                                                          adsp_context->adsc_mod->szc_used_size_bytes*2+sizeof(LNUM_WORD));

    if((adsl_temp_1 == NULL) || (adsl_temp_2 == NULL)) {
        m_mem_pool_restore_frame(&adsp_pool, dsl_frame);
        return ied_encry_pool_empty;
    }

    memset(adsl_temp_2->aucc_data, 0, adsp_context->adsc_mod->szc_used_size_bytes*2);
    memcpy(adsl_temp_2->aucc_data, adsp_a->aucc_data, adsp_a->szc_used_size_bytes);

    ms_mont_red_impl(adsp_dest->aucc_data,
                     adsl_temp_2->aucc_data,
                     adsp_context,
                     adsl_temp_1->aucc_data);

    adsp_dest->szc_used_size_bytes = adsp_context->adsc_mod->szc_used_size_bytes;
    while((adsp_dest->szc_used_size_bytes != 0) &&
          (TOP_WORD(adsp_dest) == 0))
    {
        adsp_dest->szc_used_size_bytes-=sizeof(LNUM_WORD);
    }

    m_mem_pool_restore_frame(&adsp_pool, dsl_frame);
    adsp_dest->boc_is_negative = FALSE;
    return ied_encry_success;
} // m_lnum_mont_red

extern "C" ied_encry_return m_lnum_mont_conv(struct dsd_lnum* adsp_dest,
                                             struct dsd_mem_pool_ele* adsp_pool,
                                             const struct dsd_lnum* adsp_a,
                                             const struct dsd_lnum_montgomery_ctx* adsp_context)
{
#ifndef HL_OMIT_PARAM_CHECKS
    if((adsp_dest == NULL) ||
       (adsp_pool == NULL) ||
       (adsp_a == NULL) ||
       (adsp_context == NULL))
    {
        return ied_encry_null_pointer;
    }
#endif

#ifndef HL_OMIT_PARAM_CHECKS
    if(adsp_dest->szc_alloc_size_bytes < adsp_context->adsc_mod->szc_used_size_bytes) {
        return ied_encry_insufficient_buffer;
    }
#endif
    if((adsp_a->szc_used_size_bytes > adsp_context->adsc_mod->szc_used_size_bytes) || adsp_a->boc_is_negative) {
        return ied_encry_invalid_input;
    }

    dsd_mem_pool_frame dsl_frame = m_mem_pool_get_frame(adsp_pool);
    size_t szl_tmp_len = adsp_context->adsc_mod->szc_used_size_bytes*2+sizeof(LNUM_WORD);
    dsd_lnum* adsl_prod = m_mem_pool_get_lnum_byte_size(&adsp_pool, szl_tmp_len);

    if(adsl_prod== NULL) {
        m_mem_pool_restore_frame(&adsp_pool, dsl_frame);
        return ied_encry_pool_empty;
    }

    memset(adsl_prod->aucc_data, 0, szl_tmp_len);

    ied_encry_return iel_ret = m_lnum_mult(adsl_prod,
                                           adsp_pool,
                                           adsp_a,
                                           adsp_context->adsc_r_sqr);

    if(iel_ret != ied_encry_success) {
        m_mem_pool_restore_frame(&adsp_pool, dsl_frame);
        return iel_ret;
    }

    dsd_lnum* adsl_temp_1 = m_mem_pool_get_lnum_byte_size(&adsp_pool, szl_tmp_len);

    if(adsl_temp_1 == NULL) {
        m_mem_pool_restore_frame(&adsp_pool, dsl_frame);
        return ied_encry_pool_empty;
    }

    ms_mont_red_impl(adsp_dest->aucc_data,
                     adsl_prod->aucc_data,
                     adsp_context,
                     adsl_temp_1->aucc_data);

    adsp_dest->szc_used_size_bytes = adsp_context->adsc_mod->szc_used_size_bytes;
    while((adsp_dest->szc_used_size_bytes != 0) && (TOP_WORD(adsp_dest) == 0)) {
        adsp_dest->szc_used_size_bytes-=sizeof(LNUM_WORD);
    }

    adsp_dest->boc_is_negative = FALSE;
    m_mem_pool_restore_frame(&adsp_pool, dsl_frame);

    return ied_encry_success;
} // m_lnum_mont_conv


extern "C" ied_encry_return m_lnum_test_prime(const struct dsd_lnum* adsp_candidate,
                                              struct dsd_mem_pool_ele* adsp_pool,
                                              const struct dsd_lnum_montgomery_ctx* adsp_mont_ctx,
                                              unsigned int unp_iterate,
                                              int (* amp_random)(void* avop_userfld,
                                                                 void* avop_dest,
                                                                 size_t szp_size),
                                              void* avop_userfld)
{
#ifndef HL_OMIT_PARAM_CHECKS
    if ((adsp_candidate == NULL) || (adsp_pool == NULL) || (amp_random == NULL) || (adsp_mont_ctx == NULL)) {
        return ied_encry_null_pointer;
    }
#endif
    ied_encry_return iel_ret;
    size_t szl_s;
    dsd_lnum* adsl_mont_one;
    dsd_mem_pool_frame dsl_frame = m_mem_pool_get_frame(adsp_pool);
    dsd_lnum* adsl_n_1 = m_mem_pool_get_lnum_copy(&adsp_pool,adsp_candidate);           // candidate-1 (equivalent to -1); eventually in Montgomery form
    dsd_lnum* adsl_d = m_mem_pool_get_lnum_same_size(&adsp_pool,adsp_candidate);        // d as in n-1 = d*2^s; regular form
    dsd_lnum* adsl_witness = m_mem_pool_get_lnum_byte_size(&adsp_pool, 2*adsp_candidate->szc_used_size_bytes +1);   // Witness    
    dsd_lnum* adsl_tmp = m_mem_pool_get_lnum_byte_size(&adsp_pool, 2*adsp_candidate->szc_used_size_bytes +1);       // Temporaries
    dsd_lnum* adsl_tmp2 = m_mem_pool_get_lnum_byte_size(&adsp_pool, 2*adsp_candidate->szc_used_size_bytes +1);      //
    if (!adsl_n_1 || !adsl_d || !adsl_witness || !adsl_tmp || !adsl_tmp2) {
        m_mem_pool_restore_frame(&adsp_pool, dsl_frame);
        return ied_encry_pool_empty;
    }

    // Determine n-1, d, s, mont(1), mont(n-1)
    ms_decrement(adsl_n_1);
    szl_s = ms_count_trailing_zeroes(adsl_n_1->aucc_data, adsl_n_1->szc_used_size_bytes); // s > 0
    m_lnum_rshift(adsl_d, adsl_n_1, szl_s);
    adsl_mont_one = adsp_mont_ctx->adsc_mont_one;
    m_lnum_mont_conv(adsl_n_1, adsp_pool, adsl_n_1, adsp_mont_ctx);

    iel_ret = ied_encry_success;
    unsigned int unl_k = 0;
    while((unl_k < unp_iterate) && (iel_ret == ied_encry_success)) {
        // Choose a witness candidate
        iel_ret = m_lnum_random_less_than(adsl_witness, adsp_candidate, amp_random, avop_userfld);
        if (iel_ret != ied_encry_success) break;
        if (m_lnum_is_zero(adsl_witness) || m_lnum_is_one(adsl_witness)) {
            continue;   // Witness must be between 2 and n-1
        }
        unl_k++;

        // Check if this random number is a witness (then we call 'passed')
        iel_ret = ms_exp_mod_mont(adsl_witness, adsp_pool, adsl_witness, adsl_d, adsp_mont_ctx);
        m_lnum_mont_conv(adsl_witness, adsp_pool, adsl_witness, adsp_mont_ctx);
        if (iel_ret != ied_encry_success) break;
        // Below, all lnums are montgomerized and 0-filled, so we use m_impl_cmp
        if (m_impl_cmp(adsl_witness->aucc_data, adsl_n_1->aucc_data, adsp_mont_ctx->adsc_mod->szc_used_size_bytes) == 0 ||
            m_impl_cmp(adsl_witness->aucc_data, adsl_mont_one->aucc_data, adsp_mont_ctx->adsc_mod->szc_used_size_bytes) == 0)
        {
            continue; //Passed
        }
        size_t szl_cnt = szl_s - 1;
        while (szl_cnt > 0)
        {
            m_square_mont(adsl_witness, adsl_witness, adsp_mont_ctx, adsl_tmp, adsl_tmp2);
            if (m_impl_cmp(adsl_witness->aucc_data, adsl_n_1->aucc_data, adsp_mont_ctx->adsc_mod->szc_used_size_bytes) == 0) {
                break;                          // Passed
            }
            if (m_impl_cmp(adsl_witness->aucc_data, adsl_mont_one->aucc_data, adsp_mont_ctx->adsc_mod->szc_used_size_bytes) == 0) {
                iel_ret = ied_lnum_no_prime;    // Failed
                break;
            }
            szl_cnt--;
        }
        if (szl_cnt == 0) {
            iel_ret = ied_lnum_no_prime;        // Failed
        }
    }
    m_mem_pool_restore_frame(&adsp_pool, dsl_frame);
    return iel_ret;
} // m_lnum_test_prime


ied_encry_return m_mont_init_impl(dsd_lnum_montgomery_ctx* adsp_context,
                                  dsd_mem_pool_ele* adsp_pool)
{
    size_t szl_mod_words = adsp_context->adsc_mod->szc_used_size_bytes / sizeof(LNUM_WORD);
    size_t szl_r_square_bytes = (szl_mod_words*2 +1)*sizeof(LNUM_WORD);
    dsd_mem_pool_frame dsl_frame = m_mem_pool_get_frame(adsp_pool);

    // calculate n_0_inv
    adsp_context->urc_n_0_inv = ms_inv_n_0(((LNUM_WORD*)(adsp_context->adsc_mod->aucc_data))[0]);

    // Prepare r^2
    dsd_lnum* adsl_r_squared = m_mem_pool_get_lnum_byte_size(&adsp_pool, szl_r_square_bytes);
    if( adsl_r_squared == NULL) {
        m_mem_pool_restore_frame(&adsp_pool, dsl_frame);
        return ied_encry_pool_empty;
    }
    memset(adsl_r_squared->aucc_data, 0, szl_r_square_bytes);
    ((LNUM_WORD*)(adsl_r_squared->aucc_data))[ szl_mod_words*2] = 1;
    adsl_r_squared->boc_is_negative = FALSE;
    adsl_r_squared->szc_used_size_bytes = (szl_mod_words*2+1) * sizeof(LNUM_WORD);

    // Calculate r^2 mod n. 0 out the context member first to assure, that all words up to mod len are usable
    memset(adsp_context->adsc_r_sqr->aucc_data, 0, adsp_context->adsc_mod->szc_used_size_bytes);
    ied_encry_return iel_ret = m_lnum_divide(NULL,
                                             adsp_context->adsc_r_sqr,
                                             adsp_pool,
                                             adsl_r_squared,
                                             adsp_context->adsc_mod);

    m_mem_pool_restore_frame(&adsp_pool, dsl_frame);
    if( iel_ret != ied_encry_success ) {
        return iel_ret;
    }

    return m_lnum_mont_red(adsp_context->adsc_mont_one,
                           adsp_pool,
                           adsp_context->adsc_r_sqr,
                           adsp_context);
} // m_mont_init_impl

/**
    adsp_dest = adsp_src is possible.
*/
void m_square_mont(struct dsd_lnum* adsp_dest,
                   const struct dsd_lnum* adsp_src,
                   const struct dsd_lnum_montgomery_ctx* adsp_ctx,
                   struct dsd_lnum* adsp_temp_prod,
                   struct dsd_lnum* adsp_temp_mont)
{
    ms_rec_sqr(adsp_temp_prod->aucc_data,
               adsp_temp_mont->aucc_data,
               adsp_src->aucc_data,
               adsp_ctx->adsc_mod->szc_used_size_bytes);

    ms_mont_red_impl(adsp_dest->aucc_data,
                     adsp_temp_prod->aucc_data,
                     adsp_ctx,
                     adsp_temp_mont->aucc_data);
}

/**
    adsp_dest = adsp_src is possible.
*/
void m_mul_mont(struct dsd_lnum* adsp_dest,
                const struct dsd_lnum* adsp_a,
                const struct dsd_lnum* adsp_b,
                const struct dsd_lnum_montgomery_ctx* adsp_ctx,
                struct dsd_lnum* adsp_temp_prod,
                struct dsd_lnum* adsp_temp_mont)
{
    ms_rec_mult(adsp_temp_prod->aucc_data,
                adsp_temp_mont->aucc_data,
                adsp_a->aucc_data,
                adsp_b->aucc_data,
                adsp_ctx->adsc_mod->szc_used_size_bytes);

    ms_mont_red_impl(adsp_dest->aucc_data,
                     adsp_temp_prod->aucc_data,
                     adsp_ctx,
                     adsp_temp_mont->aucc_data);
}

extern "C" void* m_mem_pool_get_chunk(dsd_mem_pool_ele** aadsp_pool,
                                      size_t szp_byte_size)
{
    ALIGN(unsigned int, szp_byte_size);
    dsd_mem_pool_ele* adsl_current = *aadsp_pool;

    // Search for large enough chunk
    while(adsl_current != NULL) {
        ALIGN(char*, adsl_current->achc_current);
        size_t szl_available = adsl_current->achc_end -
                               adsl_current->achc_current;
        if(szl_available < szp_byte_size) {
            adsl_current = adsl_current->adsc_next;
        } else {
            break;
        }
    }

    if(adsl_current == NULL) {
        // No large enough chunk found
        return NULL;
    }

    // Found chunk. Increment pointers as necessary
    void* avol_ret = adsl_current->achc_current;
    adsl_current->achc_current += szp_byte_size;
    if(adsl_current->achc_current > adsl_current->achc_max_used ) {
        adsl_current->achc_max_used = adsl_current->achc_current;
    }

    // Current element might not be the original one, so return current element
    *aadsp_pool = adsl_current;

    return avol_ret;
} // m_mem_pool_get_chunk

dsd_lnum* m_pool_get_lnum(struct dsd_mem_pool_ele** aadsp_element,
                          size_t szp_byte_size)
{
    struct dsd_lnum* adsl_temp_num = (struct dsd_lnum*)m_mem_pool_get_chunk(aadsp_element, sizeof(struct dsd_lnum));

    if(adsl_temp_num == NULL) {
        return NULL;
    }

    // Round byte size to nonzero multiple of LNUM_SIZE_ALIGN
    if(szp_byte_size == 0) {
        szp_byte_size = 1;
    }
    szp_byte_size = UINTROUNDUP(szp_byte_size, LNUM_SIZE_ALIGN);

    adsl_temp_num->aucc_data = (unsigned char*)m_mem_pool_get_chunk(aadsp_element, szp_byte_size);
    if(adsl_temp_num->aucc_data == NULL) {
        return NULL;
    }

    adsl_temp_num->szc_alloc_size_bytes = (szp_byte_size);
    adsl_temp_num->szc_used_size_bytes = 0;
    adsl_temp_num->boc_is_negative = FALSE;

    return adsl_temp_num;
} // m_pool_get_lnum

/**
   Implements modular exponentiation for arbitrary modulus.

   It uses a fixed window exponentiation of window size 5 and m_lnum_divide for
   calculating the modulus.

   @param[out] adsp_dest   Destination number.
   @param[in]  adsp_pool   Pool for temporary calculations.
   @param[in]  adsp_base   Base number.
   @param[in]  adsp_exp    Exponent number.
   @param[in]  adsp_mod    Modulus number.

   @return ied_encry_success on success, error code otherwise.
 */
static ied_encry_return ms_exp_mod_std(struct dsd_lnum* adsp_dest,
                                       struct dsd_mem_pool_ele* adsp_pool,
                                       const struct dsd_lnum* adsp_base,
                                       const struct dsd_lnum* adsp_exp,
                                       const struct dsd_lnum* adsp_mod)
{
    // For now, just assume a window size of 5
    const unsigned int unl_window_bits = 5;

    m_lnum_set(adsp_dest, 1);

    // Generate the pre-calculation table
    dsd_mem_pool_frame dsl_frame = m_mem_pool_get_frame(adsp_pool);
    size_t szl_mod_bytes = adsp_mod->szc_used_size_bytes;
    dsd_lnum* adsl_temp_1 = m_mem_pool_get_lnum_byte_size(&adsp_pool, szl_mod_bytes*2);
    dsd_lnum* adsrl_precalc[EXP_MOD_MAX_PRECALC];
    memset(adsrl_precalc, 0, sizeof(adsrl_precalc));

    adsrl_precalc[0] = m_mem_pool_get_lnum_byte_size(&adsp_pool, szl_mod_bytes);

    ied_encry_return iel_ret = ied_encry_success;
    if((adsl_temp_1 == NULL) || (adsrl_precalc[0] == NULL)) {
        m_mem_pool_restore_frame(&adsp_pool, dsl_frame);
        return ied_encry_pool_empty;
    }
    m_lnum_set(adsrl_precalc[0],1);

    for(int inl_index = 1; inl_index < 32; inl_index++) {
        adsrl_precalc[inl_index] = m_mem_pool_get_lnum_byte_size(&adsp_pool, szl_mod_bytes);
        if(adsrl_precalc[inl_index] == NULL) {
            m_mem_pool_restore_frame(&adsp_pool, dsl_frame);
            return ied_encry_pool_empty;
        }
        iel_ret = m_lnum_mult(adsl_temp_1, adsp_pool, adsp_base, adsrl_precalc[inl_index-1]);
        if(iel_ret != ied_encry_success) {
            m_mem_pool_restore_frame(&adsp_pool, dsl_frame);
            return iel_ret;
        }
        iel_ret = m_lnum_divide(NULL, adsrl_precalc[inl_index], adsp_pool, adsl_temp_1, adsp_mod);
        if(iel_ret != ied_encry_success) {
            m_mem_pool_restore_frame(&adsp_pool, dsl_frame);
            return iel_ret;
        }
    }

    // Prepare the actual processing loop

    size_t szl_exp_bits = ms_count_bits(adsp_exp->aucc_data, adsp_exp->szc_used_size_bytes);
    size_t szl_cur_shift = szl_exp_bits % LNUM_BIT;

    if(szl_cur_shift == 0){
        szl_cur_shift = LNUM_BIT;
    }

    LNUM_WORD url_mask = (1<<unl_window_bits) -1;
    const LNUM_WORD* aurl_exponent = (const LNUM_WORD*)adsp_exp->aucc_data;
    size_t szl_exp_index = (adsp_exp->szc_used_size_bytes/sizeof(LNUM_WORD))-1;
    LNUM_WORD url_window_val;

    while(szl_exp_bits > unl_window_bits) {
        // We know, that these calculations cannot fail. Fails would have happend during precalculations.
        // square 5 times
        m_lnum_square(adsl_temp_1, adsp_pool, adsp_dest);
        m_lnum_divide(NULL, adsp_dest, adsp_pool, adsl_temp_1, adsp_mod);
        m_lnum_square(adsl_temp_1, adsp_pool, adsp_dest);
        m_lnum_divide(NULL, adsp_dest, adsp_pool, adsl_temp_1, adsp_mod);
        m_lnum_square(adsl_temp_1, adsp_pool, adsp_dest);
        m_lnum_divide(NULL, adsp_dest, adsp_pool, adsl_temp_1, adsp_mod);
        m_lnum_square(adsl_temp_1, adsp_pool, adsp_dest);
        m_lnum_divide(NULL, adsp_dest, adsp_pool, adsl_temp_1, adsp_mod);
        m_lnum_square(adsl_temp_1, adsp_pool, adsp_dest);
        m_lnum_divide(NULL, adsp_dest, adsp_pool, adsl_temp_1, adsp_mod);
        
        url_window_val = ms_get_window_val(&szl_cur_shift,
                                           aurl_exponent,
                                           &szl_exp_index,
                                           unl_window_bits,
                                           url_mask);

        // Multiply with pre-calculation
        m_lnum_mult(adsl_temp_1, adsp_pool, adsp_dest, adsrl_precalc[url_window_val]);
        m_lnum_divide(NULL, adsp_dest, adsp_pool, adsl_temp_1, adsp_mod);

        szl_exp_bits -= unl_window_bits;
    }

    // generate final window word
    url_window_val = aurl_exponent[0] & ((1<<szl_exp_bits)-1);

    while(szl_exp_bits != 0){
        m_lnum_square(adsl_temp_1, adsp_pool, adsp_dest);
        m_lnum_divide(NULL, adsp_dest, adsp_pool, adsl_temp_1, adsp_mod);
        szl_exp_bits--;
    }
    
    m_lnum_mult(adsl_temp_1, adsp_pool, adsp_dest, adsrl_precalc[url_window_val]);
    m_lnum_divide(NULL, adsp_dest, adsp_pool, adsl_temp_1, adsp_mod);
    m_mem_pool_restore_frame(&adsp_pool, dsl_frame);
    return iel_ret;
} // ms_exp_mod_std

/**
   Implements modular exponentiation with Montgomery reduction.

   It uses a fixed window exponentiation of window size 5 and m_mul_mont/m_square_mont
   for modular multiplication/squaring.

   In-Place capable.

   @param[out] adsp_dest       Destination number.
   @param[in]  adsp_pool       Pool for temporary calculations.
   @param[in]  adsp_base       Base number.
   @param[in]  adsp_exp        Exponent number.
   @param[in]  adsp_mont_ctx   Montgomery context.

   @return ied_encry_success on success, error code otherwise.
 */
static ied_encry_return ms_exp_mod_mont(struct dsd_lnum* adsp_dest,
                                        struct dsd_mem_pool_ele* adsp_pool,
                                        const struct dsd_lnum* adsp_base,
                                        const struct dsd_lnum* adsp_exp,
                                        const dsd_lnum_montgomery_ctx* adsp_mont_ctx)
{
    // For now, just assume a window size of 5
    const unsigned int unl_window_bits = 5;
    const unsigned int unl_precomp_count = 1<<unl_window_bits;

    // Generate the pre-calculation table
    // Fetch all needed temps
    dsd_mem_pool_frame dsl_frame = m_mem_pool_get_frame(adsp_pool);
    size_t szl_mod_bytes = adsp_mont_ctx->adsc_mod->szc_used_size_bytes;
    dsd_lnum* adsrl_precalc[EXP_MOD_MAX_PRECALC];
    memset(adsrl_precalc, 0, sizeof(adsrl_precalc));

    for(unsigned unl_index = 1; unl_index < unl_precomp_count; unl_index++) {
        adsrl_precalc[unl_index] = m_mem_pool_get_lnum_byte_size(&adsp_pool, szl_mod_bytes);
    }

    dsd_lnum* adsl_temp_1 = NULL;
    dsd_lnum* adsl_mont_temp = NULL;

    // All temps have the same size, so we just need to check the last
    if(adsrl_precalc[unl_precomp_count-1] == NULL) {
        m_mem_pool_restore_frame(&adsp_pool, dsl_frame);
        return ied_encry_pool_empty;
    }

    // Montgomerize 1 and the base at index 0 and 1
    adsrl_precalc[0] = adsp_mont_ctx->adsc_mont_one;
    ied_encry_return iel_ret = m_lnum_mont_conv(adsrl_precalc[1], adsp_pool, adsp_base, adsp_mont_ctx);
    if( iel_ret != ied_encry_success ) {
        m_mem_pool_restore_frame(&adsp_pool, dsl_frame);
        return iel_ret;
    }

    // Set dest to 1 in Montgomery form. 0 out memory before this!
    memset(adsp_dest->aucc_data,0, adsp_mont_ctx->adsc_mod->szc_used_size_bytes);
    m_lnum_copy(adsp_dest, adsp_mont_ctx->adsc_mont_one);

    // Fetch the two temporaries for all calculations
    adsl_temp_1 = m_mem_pool_get_lnum_byte_size(&adsp_pool, szl_mod_bytes*2);
    adsl_mont_temp = m_mem_pool_get_lnum_byte_size(&adsp_pool, szl_mod_bytes*2+1);

    if((adsl_temp_1 == NULL) || (adsl_mont_temp == NULL)) {
        m_mem_pool_restore_frame(&adsp_pool, dsl_frame);
        return ied_encry_pool_empty;
    }

    // Calculate the remaining precomputation table using Montgomery multiplication
    for(unsigned unl_index = 2; unl_index < unl_precomp_count; unl_index++) {
        m_mul_mont(adsrl_precalc[unl_index],
                   adsrl_precalc[unl_index-1],
                   adsrl_precalc[1],
                   adsp_mont_ctx,
                   adsl_temp_1,
                   adsl_mont_temp);
    }

    // Prepare the actual processing loop

    size_t szl_exp_bits = ms_count_bits(adsp_exp->aucc_data, adsp_exp->szc_used_size_bytes);
    size_t szl_cur_shift = szl_exp_bits % LNUM_BIT;

    if(szl_cur_shift == 0){
        szl_cur_shift = LNUM_BIT;
    }

    LNUM_WORD url_mask = (1<<unl_window_bits) -1;
    const LNUM_WORD* aurl_exponent = (const LNUM_WORD*)adsp_exp->aucc_data;
    size_t szl_exp_index = (adsp_exp->szc_used_size_bytes/sizeof(LNUM_WORD))-1;
    LNUM_WORD url_window_val;
    // Perform the Square and multiplies for all full windows
    while(szl_exp_bits > unl_window_bits) {
        // We know, that these calculations cannot fail. Fails would have happend during precalculations.
        // square 5 times
        m_square_mont(adsp_dest, adsp_dest, adsp_mont_ctx, adsl_temp_1, adsl_mont_temp);
        m_square_mont(adsp_dest, adsp_dest, adsp_mont_ctx, adsl_temp_1, adsl_mont_temp);
        m_square_mont(adsp_dest, adsp_dest, adsp_mont_ctx, adsl_temp_1, adsl_mont_temp);
        m_square_mont(adsp_dest, adsp_dest, adsp_mont_ctx, adsl_temp_1, adsl_mont_temp);
        m_square_mont(adsp_dest, adsp_dest, adsp_mont_ctx, adsl_temp_1, adsl_mont_temp);

        url_window_val = ms_get_window_val(&szl_cur_shift,
                                           aurl_exponent,
                                           &szl_exp_index,
                                           unl_window_bits,
                                           url_mask);

        // Multiply with pre-calculation
        m_mul_mont(adsp_dest,
                   adsp_dest,
                   adsrl_precalc[url_window_val],
                   adsp_mont_ctx,
                   adsl_temp_1,
                   adsl_mont_temp);

        szl_exp_bits -= unl_window_bits;
    }
    
    // generate final window word
    url_window_val = aurl_exponent[0] & ((1<<szl_exp_bits)-1);

    while(szl_exp_bits != 0){
        m_square_mont(adsp_dest, adsp_dest, adsp_mont_ctx, adsl_temp_1, adsl_mont_temp);
        szl_exp_bits--;
    }
    
    m_mul_mont(adsl_temp_1,
               adsp_dest,
               adsrl_precalc[url_window_val],
               adsp_mont_ctx,
               adsl_temp_1,
               adsl_mont_temp);

    // Demontgomerize
    memset(((char*)adsl_temp_1->aucc_data)+szl_mod_bytes, 0, szl_mod_bytes);
    ms_mont_red_impl(adsp_dest->aucc_data,
                     adsl_temp_1->aucc_data,
                     adsp_mont_ctx,
                     adsl_mont_temp->aucc_data);
    adsp_dest->boc_is_negative = FALSE;
    adsp_dest->szc_used_size_bytes = adsp_mont_ctx->adsc_mod->szc_used_size_bytes;
    while((adsp_dest->szc_used_size_bytes != 0) &&
          (TOP_WORD(adsp_dest) == 0))
    {
        adsp_dest->szc_used_size_bytes-=sizeof(LNUM_WORD);
    }

    m_mem_pool_restore_frame(&adsp_pool, dsl_frame);
    return iel_ret;
} // ms_exp_mod_mont

/**
   Implements division of a 128 bit number by a 64 bit number.

   It does so by splitting the 64 bit words into 32 bit words and then using the
   division from 'The art of computer programming' vol.2 (Knuth), p. 257 ff.

   This implementation was taken from OpenSSL and just adapted to HOB coding standards.

   @param[in]  aulp_num Dividend.
   @param[in]  ulp_div  Divisor.

   @return Quotient of the division.
 */
static unsigned long long ms_div_word(const unsigned long long* aulp_num,
                                      unsigned long long ulp_div)
{
    const unsigned long long ulc_ff32 = 0xffffffff;

    unsigned long long ull_num_high = aulp_num[1];
    unsigned long long ull_num_low = aulp_num[0];

    unsigned long long ull_ret=0;


    size_t szl_bits=ms_count_bits((unsigned char*)&ulp_div,sizeof(unsigned long long));

    if(!((szl_bits == 64) || (ull_num_high <= (unsigned long long)1<<szl_bits))) {
        // Should never happen!
        return 0;
    }

    szl_bits=64-szl_bits;
    if (ull_num_high >= ulp_div) {
        ull_num_high-=ulp_div;
    }

    // Normalization, step D1, Knuth
    if (szl_bits) {
        ulp_div<<=szl_bits;
        ull_num_high=(ull_num_high<<szl_bits)|(ull_num_low>>(64-szl_bits));
        ull_num_low<<=szl_bits;
    }

    // Initialize j. We count from high to low, not from 0 to high. Step D2, Knuth
    int inl_count = 2;
    unsigned long long ull_high_div = ulp_div>>32;
    unsigned long long ull_low_div = ulp_div & ulc_ff32;
    unsigned long long ull_estimate;

    for (;; ) {
        // Step D3: Calculate q_est
        if ((ull_num_high>>32) == ull_high_div) {
            ull_estimate=ulc_ff32;
        } else {
            ull_estimate=ull_num_high/ull_high_div;
        }

        unsigned long long ull_temp_high= ull_estimate * ull_high_div;
        unsigned long long ull_temp_low= ull_low_div * ull_estimate;
        //ull_temp_* contain (q^*v_1) and (q^*v_2), separately

        //v_2*q^ > (u_j*b + u_j+1 - q^*v_1)*b + u_j+2  (Knuth)
        //the full right hand side term of the lemma is 96 bits long
        //the high 64 bits are stored in ull_lemma_high
        //the low 32 bits are identical to the high bits of ull_num_low
        unsigned long long ull_lemma_high;

        for (;; ) {
            ull_lemma_high = ull_num_high - ull_temp_high;
            if ((ull_lemma_high >> 32) ||
                (ull_temp_low <= ((ull_lemma_high<<32)|(ull_num_low>>32))))
            {
                break;
            }
            ull_estimate--;
            ull_temp_high-=ull_high_div;
            ull_temp_low-=ull_low_div;
        }

        //Set ull_temp_* to contain q^*v as combined 96-bit word
        ull_temp_high += ull_temp_low >> 32;
        ull_temp_low <<= 32;

        // Step D4: Subtract q^*v from num
        if (ull_num_low < ull_temp_low) {
            //carry over
            ull_temp_high++;
        }
        ull_num_low -= ull_temp_low;

        // Step D5: Test remainder
        if (ull_num_high < ull_temp_high) {
            // Step D6: Add back
            ull_num_high+=ulp_div;
            ull_estimate--;
        }
        ull_num_high -= ull_temp_high;
        //End of Step D4

        // Step D7: Loop on count
        if (--inl_count != 0) {
            ull_ret = ull_estimate << 32;
            //shift num by 32
            ull_num_high = ((ull_num_high << 32) | (ull_num_low >> 32));
            ull_num_low <<= 32;
            continue;
        } else {
            ull_ret |= ull_estimate;
            break;
        }
    }


    return ull_ret;
} // ms_div_word

inline unsigned long long ms_mod_word(const unsigned long long* aulp_num,
                                      unsigned long long ulp_div)
{
    unsigned long long quot = ms_div_word(aulp_num,ulp_div);
    return (aulp_num[0] - quot*ulp_div); //ignore higher-value word: it'll be 0 anyway
}

inline unsigned int ms_div_word(const unsigned int* aunp_num,
                                unsigned int unp_div)
{
#ifdef HL_BIG_ENDIAN
    unsigned long long ull_tmp;
    ull_tmp = (((unsigned long long)aunp_num[1]) << 32) | (unsigned long long)aunp_num[0];
    return (unsigned int)(ull_tmp/unp_div);
#else
    return (unsigned int)(*((unsigned long long*)aunp_num)/unp_div);
#endif
}

inline unsigned int ms_mod_word(const unsigned int* aulp_num,
                                unsigned int unp_div)
{
#ifdef HL_BIG_ENDIAN
    unsigned long long ull_tmp;
    ull_tmp = (((unsigned long long)aulp_num[1]) << 32) | (unsigned long long)aulp_num[0];
    return (unsigned int)((ull_tmp)%unp_div);
#else
    return *((unsigned long long*)aulp_num)%unp_div;
#endif
}



static size_t ms_count_bytes(const unsigned char* abyp_data,
                             size_t szp_len)
{
    if(szp_len == 0) {
        return 0;
    }
    // Count the bytes from the lower order words
    szp_len-=sizeof(LNUM_WORD);
    size_t szl_count = (int)szp_len;

    // The highest order word may be incomplete!
    LNUM_WORD url_high_word = ((LNUM_WORD*)abyp_data)[szp_len / sizeof(LNUM_WORD)];

    while(url_high_word != 0) {
        szl_count++;
        url_high_word >>= 8;
    }

    return szl_count;
} // ms_count_bytes

static size_t ms_count_bits(const unsigned char* abyp_data,
                            size_t szp_len)
{
    if(szp_len == 0) {
        return 0;
    }
    // Count the bits from the lower order words
    szp_len-=sizeof(LNUM_WORD);
    size_t szl_count = (int)szp_len*8;

    // The highest order word may be incomplete!
    LNUM_WORD url_high_word = ((LNUM_WORD*)abyp_data)[szp_len / sizeof(LNUM_WORD)];
    szl_count += (m_impl_last_bit(url_high_word) + 1);
    return szl_count;
} // ms_count_bits

static size_t ms_count_trailing_zeroes(const unsigned char* abyp_data,
                                       size_t szp_len)
{
#ifndef HL_OMIT_PARAM_CHECKS
    if(szp_len == 0) {
        return 0;
    }
#endif
    size_t szl_count = 0;

    LNUM_WORD url_low_word = ((LNUM_WORD*)abyp_data)[0];
    unsigned int unl_word_index = 0;
    // Detect, and skip over, all-zero low words
    while (url_low_word == (LNUM_WORD)0) {
        szl_count += LNUM_BIT;
        unl_word_index++;
        url_low_word = ((LNUM_WORD*)abyp_data)[unl_word_index];
        if (unl_word_index >= szp_len / sizeof(LNUM_WORD)) {
            // robustness check against an incorrectly-denoted zero number to prevent infinite loop/access violation
            return 0;
        }
    }
    // Count the zeros in the lowest word
    szl_count += m_impl_first_bit(url_low_word);
    return szl_count;
} // ms_count_trailing_zeroes

static void ms_write_partial_big(char* achp_dest,
                                 LNUM_WORD ulp_word,
                                 size_t szp_bytes)
{
    switch(szp_bytes) {
    case 8:
        achp_dest[7] = ulp_word & 0xff;
        ulp_word >>= 8;
    case 7:
        achp_dest[6] = ulp_word & 0xff;
        ulp_word >>= 8;
    case 6:
        achp_dest[5] = ulp_word & 0xff;
        ulp_word >>= 8;
    case 5:
        achp_dest[4] = ulp_word & 0xff;
        ulp_word >>= 8;
    case 4:
        achp_dest[3] = ulp_word & 0xff;
        ulp_word >>= 8;
    case 3:
        achp_dest[2] = ulp_word & 0xff;
        ulp_word >>= 8;
    case 2:
        achp_dest[1] = ulp_word & 0xff;
        ulp_word >>= 8;
    case 1:
        achp_dest[0] = ulp_word & 0xff;
    }
} // ms_write_partial_big


static void ms_write_partial_little(char* achp_dest,
                                    LNUM_WORD ulp_word,
                                    size_t szp_bytes)
{
    switch(szp_bytes) {
    case 8:
        *achp_dest = ulp_word & 0xff;
        ulp_word >>= 8;
        achp_dest++;
    case 7:
        *achp_dest = ulp_word & 0xff;
        ulp_word >>= 8;
        achp_dest++;
    case 6:
        *achp_dest = ulp_word & 0xff;
        ulp_word >>= 8;
        achp_dest++;
    case 5:
        *achp_dest = ulp_word & 0xff;
        ulp_word >>= 8;
        achp_dest++;
    case 4:
        *achp_dest = ulp_word & 0xff;
        ulp_word >>= 8;
        achp_dest++;
    case 3:
        *achp_dest = ulp_word & 0xff;
        ulp_word >>= 8;
        achp_dest++;
    case 2:
        *achp_dest = ulp_word & 0xff;
        ulp_word >>= 8;
        achp_dest++;
    case 1:
        *achp_dest = ulp_word & 0xff;
    }
} // ms_write_partial_little



/**
   Multiplies two equal length lnums, using recursive Karatsuba multiplication.

   abyp_dest and abyp_temp must be at least 2*szp_len words long.
   szp_len must be at least uns_karatsuba_limit / 2.
   All pointers must be non-NULL.
   No parameter checking is done!

   If szp_len is odd or smaller, than uns_karatsuba_limit, the recursion will stop.

   Algorithms and implementation are based on GMP and OpenSSL. This means, the
   calculation is using the equation

   x*y = (b^2+b)*x1*y1 - b*(x1-x0)*(y1-y0) + (b+1)*x0*y0.

   It also uses a similar switch construction as OpenSSL. However currently, the
   case where one of the differences is 0 is handled by not doing any operation.

   @todo Check, if the 0 case optimization is too much of a possible side channel!

   @param[out] abyp_dest    Destination for this recursion step.
   @param[out] abyp_temp    Temporary number field. Can be discarded after return.
   @param[in]  abyp_a       Pointer to the first number.
   @param[in]  abyp_b       Pointer to the second number.
   @param[in]  szp_len     Length of both inputs in bytes.
 */
static void ms_rec_mult(unsigned char* abyp_dest,
                        unsigned char* abyp_temp,
                        const unsigned char* abyp_a,
                        const unsigned char* abyp_b,
                        size_t szp_len)
{
    if ((szp_len < uns_karatsuba_limit) || (szp_len % (2*sizeof(LNUM_WORD)) != 0)) {
        m_impl_mult_basic(abyp_dest, abyp_a, szp_len, abyp_b, szp_len);
        return;
    }

    size_t szl_half_len = szp_len /2;
    const unsigned char* abyl_a_1 = abyp_a + szl_half_len;
    const unsigned char* abyl_b_1 = abyp_b + szl_half_len;

    int inl_a_cmp = m_impl_cmp(abyl_a_1, abyp_a, szl_half_len);
    int inl_b_cmp = m_impl_cmp(abyl_b_1, abyp_b, szl_half_len);

    bool bol_is_zero = false;
    bool bol_do_sub = true;

/** @todo Here, it is assumed, that m_impl_cmp will only return -1, 0 or 1 !! */

    // We use *4 instead of *3 as in OpenSSL, as this is likely to become a shift. We won't need the carry here.
    // dest[0] = a_1-a_0, dest[len] = b_1-b_0. Absolute values only.
    switch(inl_a_cmp * 4 + inl_b_cmp) {
    case -5:
        // a_1-a_0 and b_1-b_0 are negative
        m_impl_sub_karatsuba(abyp_dest, abyp_a, abyl_a_1, szl_half_len);
        m_impl_sub_karatsuba(abyp_dest+szp_len, abyp_b, abyl_b_1, szl_half_len);
        break;
    case -4:
        // b_1-b_0 is 0
        bol_is_zero = true;
        break;
    case -3:
        // a_1-a_0 is negative, b_1-b_0 is positive
        m_impl_sub_karatsuba(abyp_dest, abyp_a, abyl_a_1, szl_half_len);
        m_impl_sub_karatsuba(abyp_dest+szp_len, abyl_b_1, abyp_b, szl_half_len);
        bol_do_sub = false;
        break;
    case -1:
    case 0:
    case 1:
        // a_1-a_0 is 0
        bol_is_zero = true;
        break;
    case 3:
        // a_1-a_0 is positive, b_1-b_0 is negative
        m_impl_sub_karatsuba(abyp_dest, abyl_a_1, abyp_a, szl_half_len);
        m_impl_sub_karatsuba(abyp_dest+szp_len, abyp_b, abyl_b_1, szl_half_len);
        bol_do_sub = false;
        break;
    case 4:
        // b_1-b_0 is 0
        bol_is_zero = true;
        break;
    case 5:
        // a_1-a_0 and b_1-b_0 are positive
        m_impl_sub_karatsuba(abyp_dest, abyl_a_1, abyp_a, szl_half_len);
        m_impl_sub_karatsuba(abyp_dest+szp_len, abyl_b_1, abyp_b, szl_half_len);
        break;
    }

    if ( !bol_is_zero ) {
        ms_rec_mult(abyp_temp+szp_len, abyp_temp, abyp_dest, abyp_dest+szp_len, szl_half_len);
    }

    ms_rec_mult(abyp_dest, abyp_temp, abyp_a, abyp_b, szl_half_len);
    ms_rec_mult(abyp_dest+szp_len, abyp_temp, abyl_a_1, abyl_b_1, szl_half_len);

    LNUM_WORD url_carry = m_impl_add_karatsuba(abyp_temp, abyp_dest, abyp_dest+szp_len, szp_len);
    url_carry += m_impl_add_karatsuba(abyp_dest+szl_half_len, abyp_dest+szl_half_len, abyp_temp, szp_len);

    if ( !bol_is_zero ) {
        if (bol_do_sub) {
            url_carry -= m_impl_sub_karatsuba(abyp_dest+szl_half_len,
                                              abyp_dest+szl_half_len,
                                              abyp_temp+szp_len,
                                              szp_len);
        } else {
            url_carry += m_impl_add_karatsuba(abyp_dest+szl_half_len,
                                              abyp_dest+szl_half_len,
                                              abyp_temp+szp_len,
                                              szp_len);
        }
    }

    m_impl_add_word(abyp_dest+szl_half_len+szp_len, url_carry);
} // ms_rec_mult


/**
   Squares a large number using the recursive Karatsuba algorithm.

   The same methods and restrictions as for ms_rec_mult apply here.

   The equation is slightly modified:

   x^2 = (b^2+b)*x1^2 - b*(x1-x0)^2 + (b+1)*x0^2

   As (x1-x0)^2 is always positive, things are a bit simpler, than
   in the multiplication case.

   @param[out] abyp_dest    Destination for this recursion step.
   @param[out] abyp_temp    Temporary number field. Can be discarded after return.
   @param[in]  abyp_a       Pointer to the input number.
   @param[in]  szp_len     Length of the input in words.
 */
static void ms_rec_sqr(unsigned char* abyp_dest,
                       unsigned char* abyp_temp,
                       const unsigned char* abyp_a,
                       size_t szp_len)
{
    if ((szp_len < uns_karatsuba_limit) || (szp_len % (2*sizeof(LNUM_WORD)) != 0)) {
        m_impl_square(abyp_dest, abyp_a, szp_len);
        return;
    }

    size_t szl_half_len = szp_len / 2;
    const unsigned char* abyl_a_1 = abyp_a + szl_half_len;

    int inl_cmp = m_impl_cmp(abyp_a, abyl_a_1, szl_half_len);
    bool bol_is_zero = false;

    switch(inl_cmp) {
    case -1:
        // a_1 is larger
        m_impl_sub_karatsuba(abyp_dest, abyl_a_1, abyp_a, szl_half_len);
        ms_rec_sqr(abyp_temp+szp_len, abyp_temp, abyp_dest, szl_half_len);
        break;
    case 0:
        // both are equal
        bol_is_zero = true;
        break;
    case 1:
        // a_0 is larger
        m_impl_sub_karatsuba(abyp_dest, abyp_a, abyl_a_1, szl_half_len);
        ms_rec_sqr(abyp_temp+szp_len, abyp_temp, abyp_dest, szl_half_len);
        break;
    }

    ms_rec_sqr(abyp_dest, abyp_temp, abyp_a, szl_half_len);
    ms_rec_sqr(abyp_dest+szp_len, abyp_temp, abyl_a_1, szl_half_len);

    LNUM_WORD url_carry = m_impl_add_karatsuba(abyp_temp, abyp_dest, abyp_dest+szp_len, szp_len);
    url_carry += m_impl_add_karatsuba(abyp_dest+szl_half_len, abyp_dest+szl_half_len, abyp_temp, szp_len);

    if(!bol_is_zero) {
        url_carry -= m_impl_sub_karatsuba(abyp_dest+szl_half_len, abyp_dest+szl_half_len, abyp_temp+szp_len, szp_len);
    }

    m_impl_add_word(abyp_dest+szl_half_len+szp_len, url_carry);
} // ms_rec_sqr

/**
   Calculates the inverse element n_0' for Montgomery context.
   based on the equality:    N0(2**i) * N0'(2**i) = 1 (mod 2**i)
                for i = 1...w (w = 32)

   @param N0 lowest Element of modulus n

   @return N0' invers to N0 mod 2**32
 */
static LNUM_WORD ms_inv_n_0(LNUM_WORD urp_n_0)
{
    LNUM_WORD url_prod = urp_n_0;
    LNUM_WORD url_n_0_inv = 1;
    for (unsigned int unl_cnt=1; unl_cnt < (sizeof(LNUM_WORD)*8); unl_cnt++) {
        // Observe: url_prod = n_inv * urp_n_0   ...(A)
        // Observe: url_prod & (2^(cnt+1) -1) = 1
        if (url_prod & ((LNUM_WORD) 1 << unl_cnt)) {
            // current url_n_0_inv is not inverse mod 2^(cnt +1)
            url_n_0_inv = url_n_0_inv + ((LNUM_WORD) 1 << unl_cnt); // N0' = N0' + 2**unl_cnt
            url_prod = url_prod + (urp_n_0 << unl_cnt); // so that (A) holds again
        }
    }
    url_n_0_inv = (~url_n_0_inv)+1;
    return url_n_0_inv;
}

/**
   Performs the actual Montgomery reduction.

   abyp_dest must be at least the len of the modulus.
   abyp_src must be twice as long as the modulus, filled up with 0s, if needed.
   abyp_temp must be (mod len *2)+1 words long.
   abyp_dest = abyp_src is possible.

   The used method is SOS from the paper 'Analyzing and Comparing Montgomery
   Multiplication Algorithms' by Koc, Acar and Kaliski.

   @param[out] abyp_dest   Destination buffer
   @param[in]  abyp_src    Buffer with the number to be reduced.
   @param[in]  unp_src_len Length of the number to be reduced.
   @param[in]  adsp_ctx    Montgomery context to be used.
   @param[in]  abyp_tmp    Temporary number.
 */
static void ms_mont_red_impl(unsigned char* abyp_dest,
                             const unsigned char* abyp_src,
                             const dsd_lnum_montgomery_ctx* adsp_ctx,
                             unsigned char* abyp_tmp)
{
    size_t szl_mod_len = adsp_ctx->adsc_mod->szc_used_size_bytes;

    // perform the multiply-add loop
    m_impl_mont_mul_add(abyp_tmp,
                        adsp_ctx->urc_n_0_inv,
                        adsp_ctx->adsc_mod->aucc_data,
                        szl_mod_len,
                        abyp_src);

    unsigned char* abyrl_results[2];
    abyrl_results[0] = abyp_tmp;
    abyrl_results[1] = abyp_tmp+szl_mod_len;

    unsigned int unl_index = m_impl_sub_karatsuba(abyp_tmp,
                                                  abyrl_results[1],
                                                  adsp_ctx->adsc_mod->aucc_data,
                                                  szl_mod_len);

    unl_index ^= ((LNUM_WORD*)abyrl_results[1])[szl_mod_len / sizeof(LNUM_WORD)];

    memcpy(abyp_dest, abyrl_results[unl_index], szl_mod_len);
} // ms_mont_red_impl

/**
   Changes the value of the lnum by 1 towards zero
   (=subtracts 1 from positive values, adds 1 to negative values)

   @param dsp_lnum

   @return error code
 */
static ied_encry_return ms_decrement(struct dsd_lnum* adsp_lnum)
{
#ifndef HL_OMIT_PARAM_CHECKS
    if (adsp_lnum->szc_used_size_bytes == 0) {
        return ied_encry_miscellaneous;
    }
#endif
    unsigned int unl_index = 0;
    do {
        LNUM_WORD url_original = ((LNUM_WORD*)(adsp_lnum->aucc_data))[ unl_index];
        ((LNUM_WORD*)(adsp_lnum->aucc_data))[ unl_index]--;
        if (url_original != 0) {
            if (TOP_WORD(adsp_lnum) == 0) {
                adsp_lnum->szc_used_size_bytes-=sizeof(LNUM_WORD);
            }
            return ied_encry_success;
        }
        unl_index++;
    } while (unl_index < adsp_lnum->szc_used_size_bytes / sizeof(LNUM_WORD));
    // robustness check against an incorrectly-denoted zero number to prevent infinite loop/access violation
    return ied_encry_miscellaneous;
} // ms_decrement

static LNUM_WORD ms_get_window_val(size_t* aszp_cur_shift,
                                   const LNUM_WORD* aurp_exponent,
                                   size_t* aszp_exp_index,
                                   unsigned int unp_window_bits,
                                   LNUM_WORD urp_mask)
{
    LNUM_WORD url_window_val;
    if(*aszp_cur_shift < unp_window_bits){
        // Window goes into next word of the exponent
        size_t szl_l_shift = unp_window_bits-*aszp_cur_shift;
        url_window_val = aurp_exponent[*aszp_exp_index] << szl_l_shift;
        *aszp_exp_index-=1;
        *aszp_cur_shift = LNUM_BIT-szl_l_shift;
        url_window_val |= aurp_exponent[*aszp_exp_index] >> *aszp_cur_shift;
    } else {
        *aszp_cur_shift -= unp_window_bits;
        url_window_val = aurp_exponent[*aszp_exp_index] >> *aszp_cur_shift;
    }
    url_window_val &= urp_mask;
    return url_window_val;
}

