// This file was generated by the script combine_sources.rb
/** @date Wed Sep 27 12:11:27 2017  (creation) */
/**
@file
This file contains the main SSL module functionality.

It requires functionality from both xs-encry-1.cpp and xs-cert-1.cpp, so these 
must be compiled along with this source.

The following preprocessor defines may be used:

XH_INTERFACE            Use the XH Interface. This is the interface used by the WSP.
XH_INTF_VERSION         Explicitly set the version of the XH Interface. Valid values
                        are 220 for version 2, 300 for version 3. If not set, it 
                        defaults to 300.
ALT_SEEDING_SOURCE      Alternative seeding is used. This is for usage in mod_hob_ssl 
                        for Apache.
XH_DUMMY                Use dummy routines instead of the real SSL. Only for use 
                        with XH_INTERFACE and ONLY FOR DEBUGGING!
__VPN_INTERFACE__       This is for usage with HOB VPN interface. Do not use this
                        along with XH_INTERFACE.

The following C++ callback function must be defined by another source:

int HLSSL_CallBack(int Operation, 
                   int SocketIndex,
                   char pBuf[],
                   int BufferOffset,
                   int BufLen);

The function is required for proper linking.
*/
#if (!defined HL_SSL_PROT_MAIN) && (!defined HL_SSL_EXT_CERT) && (!defined HL_SSL_GLIB) && (!defined HL_SSL_CACHE) && (!defined HL_SSL_V42BIS) && (!defined HL_SSL_LOG)
#define HL_SSL_PROT_MAIN
#define HL_SSL_EXT_CERT
#define HL_SSL_GLIB
#define HL_SSL_CACHE
#define HL_SSL_V42BIS
#define HL_SSL_LOG
#endif

#ifdef HL_SSL_PROT_MAIN
/** @addtogroup hssl
* @{
* @file
* This file implements the core SSL/TLS functionality. This includes some non-
* protocol aspects, for example MAC algorithms or socket usage.
* @}
*/
#if (defined _WIN32) & (_MSC_VER < 1700)
#ifndef _STDINT
#define _STDINT
// MSVC lower than 17.00 does not have stdint.h, assure, all needed types are defined

typedef unsigned __int16 uint16_t;

typedef unsigned __int32 uint32_t;

typedef unsigned __int64 uint64_t;

#endif // !_STDINT
#else
#include <stdint.h>
#endif
#include <stddef.h>
#ifdef _WIN32
#define WIN32_LEAN_AND_MEAN
#include <Windows.h>
#undef WIN32_LEAN_AND_MEAN
#else// Define system-specific HL_* defines here
#ifndef HL_UNIX
#define HL_UNIX

#if (defined __gnu_linux__) || (defined __linux__)
#define HL_LINUX
#endif

#if (defined __APPLE__) && (defined __MACH__)
#define HL_LINUX
#define HL_MACOS
#endif

#ifdef _AIX
#define HL_AIX
#define HL_BIG_ENDIAN
#endif

#ifdef __FreeBSD__
#define HL_FREEBSD
#endif

#if (defined _hpux) || (defined hpux) || (defined __hpux)
#define HL_HPUX
#define HL_BIG_ENDIAN
#endif

#if (defined sun) || (defined __sun)
#define HL_SOLARIS
#endif

#if (defined __arm__) || (defined __aarch64__)
#define HL_LINUX_ARM
#endif

#ifdef __ANDROID__
#define HL_ANDROID
#endif

#endif
#include <hob-unix01.h>
#endif
#ifdef __APPLE__
/* We get target conditionals to keep apart Mac OS, iOS and iOS simulator.
   The conditionals are TARGET_IPHONE_SIMULATOR, TARGET_OS_IPHONE and TARGET_OS_MAC.
   TARGET_IPHONE_SIMULATOR has the highest priority, TARGET_OS_MAC the lowest.
   Always test, if the conditional is 1, as they will be defined as 0, if we 
   are not compiling for the target.
   */
#include <TargetConditionals.h>
#endif

#ifdef HL_ANDROID
#include <sys/endian.h>
#endif

#include "hob-encry-1.h"
#include <stdlib.h>
#if !(defined __HOB_XSCLIB01__) && !(defined DEF_IFUNC_START)
#define __HOB_XSCLIB01__

#include <hob-xsclib01.h>  
#endif // !__HOB_XSCLIB01__
#include "hob-cert-ext.h"
#include <stdlib.h>

#include <hob-encry-2.h>

#include "hob-ssl-intern.h"
#include "hob-ssl-err.h"
#ifdef _WIN32
#include <winsock.h>
#endif
#include "hob-cert-err.h"
#include <string.h>
#include "hob-cert-intern.h"
#include "hob-encry-intern-1.h"
#include "hob-ssl-01.h"

#include <stdio.h>
#include <stdarg.h>
#include <hob-xslunic1.h>
#if defined _WIN32
#define snprintf _snprintf
#pragma comment(lib, "Ws2_32.lib")
#endif
#ifndef HCU_SRP_PW_LEN
#define HCU_SRP_PW_LEN 32   // HCU shall use at most 32 characters for password
#endif

//undef the macros from hob-ssl-01.h to avoid compile errors
#undef m_cl_registerconfig
#undef m_se_registerconfig

//-----------------------------------------------------
// Continue States
//-----------------------------------------------------
#define	STATUS_CLOSED_BY_REMOTE			1
#define	STATUS_CONTINUE				0
#define	STATUS_TCP_TX_ERROR			-1
#define	STATUS_TCP_RX_ERROR			-2
#define	STATUS_TCP_RX_TIMEOUT			-3
#define STATUS_FATAL_ALERT_QUEUED		-4
#define STATUS_FATAL_NO_BUFS			-5

#define STATUS_MUST_CLOSE_IMMEDIATE		-6
#define	STATUS_TX_CLOSE_SELF			-7

#define	MAX_TOLERANCE_TIME	600			// 10 minutes

extern "C" int HLSSL_CallBack(int Operation, int SocketIndex,char pBuf[],
			  int BufferOffset,int BufLen);

#if defined _WIN32
#pragma warning(disable:4996)
#endif

/** List of supported signature types, use this for TLS prior 1.2 and SSL */
static  char abys_ssl_sigtype_list[11] ={
   10,PKCS1_MD5_WITH_RSA_ENC,
   PKCS1_SHA1_WITH_RSA_ENC,
   PKCS1_SHA256_WITH_RSA_ENC,
   PKCS1_SHA384_WITH_RSA_ENC,
   PKCS1_SHA512_WITH_RSA_ENC,
   TELESEC_RSA_WITH_RIPEMD160,
   PKCS1_SHA224_WITH_RSA_ENC, X957_DSA_WITH_SHA1, OIW_DSA_WITH_SHA, OIW_DSA_WITH_SHA1
};

/** List of signature algorithms for pre-TLS 1.2 DH-RSA */
static  char abys_rsa_sig_list[8] ={
   7,PKCS1_MD5_WITH_RSA_ENC,
   PKCS1_SHA1_WITH_RSA_ENC,
   PKCS1_SHA256_WITH_RSA_ENC,
   PKCS1_SHA384_WITH_RSA_ENC,
   PKCS1_SHA512_WITH_RSA_ENC,
   PKCS1_SHA224_WITH_RSA_ENC,
   TELESEC_RSA_WITH_RIPEMD160
};

/** Default signature type identifier for RSA in TLS 1.2 */
static  char abys_tls_12_rsa_sig_list[2] = {
   1, PKCS1_SHA1_WITH_RSA_ENC};  // SHA1-RSA

/** Default signature type identifier for DSA in TLS 1.2 */
static  char abys_dsa_sig_list[4] = {
   3,X957_DSA_WITH_SHA1, OIW_DSA_WITH_SHA, OIW_DSA_WITH_SHA1}; // SHA1-DSA

/** This sigtype list is used, if no sigtype list is configured for the server */
static  char abys_default_server_sigtype_list[8] ={
   7,
   PKCS1_SHA1_WITH_RSA_ENC,
   PKCS1_SHA256_WITH_RSA_ENC,
   PKCS1_SHA384_WITH_RSA_ENC,
   PKCS1_SHA512_WITH_RSA_ENC, X957_DSA_WITH_SHA1, OIW_DSA_WITH_SHA, OIW_DSA_WITH_SHA1
};

static const uint16_t uss_css_type = 0x100;

//------------------------------------------------------------
// Definitions for PAD1 / PAD2 access
//------------------------------------------------------------

#define	PAD1_LEN_MD5		3*MD5_DIGEST_LEN	// 48 Bytes
#define	PAD1_LEN_SHA1		2*SHA_DIGEST_LEN	// 40 Bytes
#define	PAD1_LEN_SHA256	2*SHA256_DIGEST_LEN	// 64 Bytes

#define	PAD2_LEN_MD5		3*MD5_DIGEST_LEN	// 48 Bytes
#define	PAD2_LEN_SHA1		2*SHA_DIGEST_LEN	// 40 Bytes
#define	PAD2_LEN_SHA256	2*SHA256_DIGEST_LEN	// 64 Bytes

//------------------------------------------------------------
// Helper Arrays for the PAD1 and PAD2 strings
//------------------------------------------------------------

static  char Pad1Str[PAD1_LEN_MD5]= 
{
  (char) 0x36, (char) 0x36, (char) 0x36, (char) 0x36,
  (char) 0x36, (char) 0x36, (char) 0x36, (char) 0x36,
  (char) 0x36, (char) 0x36, (char) 0x36, (char) 0x36,
  (char) 0x36, (char) 0x36, (char) 0x36, (char) 0x36,
  (char) 0x36, (char) 0x36, (char) 0x36, (char) 0x36,
  (char) 0x36, (char) 0x36, (char) 0x36, (char) 0x36,
  (char) 0x36, (char) 0x36, (char) 0x36, (char) 0x36,
  (char) 0x36, (char) 0x36, (char) 0x36, (char) 0x36,
  (char) 0x36, (char) 0x36, (char) 0x36, (char) 0x36,
  (char) 0x36, (char) 0x36, (char) 0x36, (char) 0x36,
  (char) 0x36, (char) 0x36, (char) 0x36, (char) 0x36,
  (char) 0x36, (char) 0x36, (char) 0x36, (char) 0x36,
};
static  char Pad2Str[PAD2_LEN_MD5]= 
{
  (char) 0x5C, (char) 0x5C, (char) 0x5C, (char) 0x5C,
  (char) 0x5C, (char) 0x5C, (char) 0x5C, (char) 0x5C,
  (char) 0x5C, (char) 0x5C, (char) 0x5C, (char) 0x5C,
  (char) 0x5C, (char) 0x5C, (char) 0x5C, (char) 0x5C,
  (char) 0x5C, (char) 0x5C, (char) 0x5C, (char) 0x5C,
  (char) 0x5C, (char) 0x5C, (char) 0x5C, (char) 0x5C,
  (char) 0x5C, (char) 0x5C, (char) 0x5C, (char) 0x5C,
  (char) 0x5C, (char) 0x5C, (char) 0x5C, (char) 0x5C,
  (char) 0x5C, (char) 0x5C, (char) 0x5C, (char) 0x5C,
  (char) 0x5C, (char) 0x5C, (char) 0x5C, (char) 0x5C,
  (char) 0x5C, (char) 0x5C, (char) 0x5C, (char) 0x5C,
  (char) 0x5C, (char) 0x5C, (char) 0x5C, (char) 0x5C,
};

//------------------------------------------------------------
// Definitions for Sender/Client strings access
//------------------------------------------------------------

#define	MAC_SENDER_SERVER_STR_LEN	4
#define	MAC_SENDER_CLIENT_STR_LEN	4
//------------------------------------------------------------
// Helper Arrays for the Server and Client Sender strings
//------------------------------------------------------------
static  char MacSenderSrvrStr[MAC_SENDER_SERVER_STR_LEN]= 
{
  (char) 0x53, (char) 0x52, (char) 0x56, (char) 0x52	// "SRVR"
};

static  char MacSenderClntStr[MAC_SENDER_CLIENT_STR_LEN]= 
{
  (char) 0x43, (char) 0x4C, (char) 0x4E, (char) 0x54	// "CLNT"
};

//-----------------------------------------------------------
// Definition for TLS PRF labels
//-----------------------------------------------------------
#define MASTER_SECR_LABEL_STR_LEN	13
#define KEY_EXP_LABEL_STR_LEN		13
#define CLNT_WR_KEY_LABEL_STR_LEN	16
#define SRVR_WR_KEY_LABEL_STR_LEN	16
#define IV_BLOCK_LABEL_STR_LEN		8
#define	HMAC_SENDER_SERVER_STR_LEN	15
#define	HMAC_SENDER_CLIENT_STR_LEN	15

//-----------------------------------------------------------
// Tables of TLS PRF labels
//-----------------------------------------------------------
static  char MasterSecrLabelStr[MASTER_SECR_LABEL_STR_LEN]=
{
  (char) 0x6D, (char) 0x61, (char) 0x73, (char) 0x74,	// "mast"
  (char) 0x65, (char) 0x72, (char) 0x20, (char) 0x73,	// "er s"
  (char) 0x65, (char) 0x63, (char) 0x72, (char) 0x65,	// "ecre"
  (char) 0x74						// "t"
};

static  char KeyExpLabelStr[KEY_EXP_LABEL_STR_LEN]=
{
  (char) 0x6B, (char) 0x65, (char) 0x79, (char) 0x20,	// "key "
  (char) 0x65, (char) 0x78, (char) 0x70, (char) 0x61,	// "expa"
  (char) 0x6E, (char) 0x73, (char) 0x69, (char) 0x6F,	// "nsio"
  (char) 0x6E						// "n"
};

static  char ClntWriteKeyLabelStr[CLNT_WR_KEY_LABEL_STR_LEN]=
{
  (char) 0x63, (char) 0x6C, (char) 0x69, (char) 0x65,	// "clie"
  (char) 0x6E, (char) 0x74, (char) 0x20, (char) 0x77,	// "nt w"
  (char) 0x72, (char) 0x69, (char) 0x74, (char) 0x65,	// "rite"
  (char) 0x20, (char) 0x6B, (char) 0x65, (char) 0x79	// " key"
};

static  char SrvrWriteKeyLabelStr[SRVR_WR_KEY_LABEL_STR_LEN]=
{
  (char) 0x73, (char) 0x65, (char) 0x72, (char) 0x76,	// "serv"
  (char) 0x65, (char) 0x72, (char) 0x20, (char) 0x77,	// "er w"
  (char) 0x72, (char) 0x69, (char) 0x74, (char) 0x65,	// "rite"
  (char) 0x20, (char) 0x6B, (char) 0x65, (char) 0x79	// " key"
};

static  char IVBlockLabelStr[IV_BLOCK_LABEL_STR_LEN]=
{
  (char) 0x49, (char) 0x56, (char) 0x20, (char) 0x62,	// "IV b"
  (char) 0x6C, (char) 0x6F, (char) 0x63, (char) 0x6B	// "lock"
};

static  char HMacSenderSrvrStr[HMAC_SENDER_SERVER_STR_LEN]= 
{
  (char) 0x73, (char) 0x65, (char) 0x72, (char) 0x76,	// "serv"
  (char) 0x65, (char) 0x72, (char) 0x20, (char) 0x66,	// "er f"
  (char) 0x69, (char) 0x6E, (char) 0x69, (char) 0x73,	// "inis"
  (char) 0x68, (char) 0x65, (char) 0x64			// "hed"
};

static  char HMacSenderClntStr[HMAC_SENDER_CLIENT_STR_LEN]= 
{
  (char) 0x63, (char) 0x6C, (char) 0x69, (char) 0x65,	// "clie"
  (char) 0x6E, (char) 0x74, (char) 0x20, (char) 0x66,	// "nt f"
  (char) 0x69, (char) 0x6E, (char) 0x69, (char) 0x73,	// "inis"
  (char) 0x68, (char) 0x65, (char) 0x64			// "hed"
};

//--------------------------------------------------------
// Configuration Structure Pointer, only used for WSP/JAVA,
// loaded only once.
//--------------------------------------------------------
#if !defined XH_INTERFACE
extern "C" CFG_STRU * pGlobalCfgStruct = NULL;
#else
static int VersionShow = 0;
#endif // XH_INTERFACE

//------------------------------------------------------------
// Definition of Cipher-State Array offsets
//------------------------------------------------------------
#define	CST_CipherID		0	// 1st Field, ID (LSB only)
#define	CST_CipherAlgor		1
#define	CST_CipherAlgorType	2
#define	CST_IsExportable	3
#define	CST_KeyMatSize		4
#define	CST_KeySize		5
#define	CST_IVSize		6
#define	CST_BlockSize		7
#define	CST_MacAlgor		8
#define	CST_MacSize		9
#define	CST_KeyExchgMode	10
#define	CST_Usability		11

#define	CST_ENTRY_SIZE		(CST_Usability + 1)
//------------------------------------------------------------
// Helper Array for setting the cipher params from selected
// Cipher Type,
// NOTE: New Table Version has ID as first Entry to get access
// ----- for given suite
//------------------------------------------------------------

static  unsigned char CipherParams[(CST_ENTRY_SIZE*MAX_DEFINED_SUITES)] =
{

// we now support NON encrypted but Maced modes for debugging purposes

  SSL_RSA_NULL_MD5,			// 0x01 SSL_RSA_NULL_MD5
  CIPHER_ALGOR_NULL,
  ALGOR_TYPE_STREAM,
  IS_NOT_EXPORTABLE,			// Avoid server key exchange...
  0,					// key material size
  0,					// key size
  0,					// IV size
  0,					// block size
  MAC_ALGOR_MD5,
  MD5_DIGEST_LEN,			// MAC-Size
  KEY_EXCHANGE_RSA,
  CIPH_TLS10_SSL|CIPH_TLS11|CIPH_TLS12,

  SSL_RSA_NULL_SHA,			// 0x02 SSL_RSA_NULL_MD5
  CIPHER_ALGOR_NULL,
  ALGOR_TYPE_STREAM,
  IS_NOT_EXPORTABLE,			// Avoid server key exchange...
  0,					// key material size
  0,					// key size
  0,					// IV size
  0,					// block size
  MAC_ALGOR_SHA1,
  SHA_DIGEST_LEN,			// MAC-Size
  KEY_EXCHANGE_RSA,
  CIPH_TLS10_SSL|CIPH_TLS11|CIPH_TLS12,

  SSL_RSA_EXP_RC4_40_MD5,		// 0x03 SSL_RSA_EXP_RC4_40_MD5
  CIPHER_ALGOR_RC4,
  ALGOR_TYPE_STREAM,
  IS_EXPORTABLE,
  5,					// key material size
  16,					// key size
  0,					// IV size
  0,					// block size
  MAC_ALGOR_MD5,
  MD5_DIGEST_LEN,			// MAC-Size
  KEY_EXCHANGE_RSA,
  CIPH_TLS10_SSL,

  SSL_RSA_RC4_128_MD5,			// 0x04	SSL_RSA_RC4_128_MD5
  CIPHER_ALGOR_RC4,
  ALGOR_TYPE_STREAM,
  IS_NOT_EXPORTABLE,
  16,					// key material size
  16,					// key size
  0,					// IV size
  0,					// block size
  MAC_ALGOR_MD5,
  MD5_DIGEST_LEN,			// MAC-Size
  KEY_EXCHANGE_RSA,
  CIPH_TLS10_SSL|CIPH_TLS11|CIPH_TLS12,

  SSL_RSA_RC4_128_SHA,			// 0x05 SSL_RSA_RC4_128_SHA
  CIPHER_ALGOR_RC4,
  ALGOR_TYPE_STREAM,
  IS_NOT_EXPORTABLE,
  16,					// key material size
  16,					// key size
  0,					// IV size
  0,					// block size
  MAC_ALGOR_SHA1,
  SHA_DIGEST_LEN,			// MAC-Size
  KEY_EXCHANGE_RSA,
  CIPH_TLS10_SSL|CIPH_TLS11|CIPH_TLS12,

  SSL_RSA_EXP_RC2_CBC_40_MD5,		// 0x06	SSL_RSA_EXP_RC2_CBC_40_MD5
  CIPHER_ALGOR_RC2_CBC,
  ALGOR_TYPE_BLOCK,
  IS_EXPORTABLE,
  5,					// key material size
  16,					// key size
  8,					// IV size
  8,					// block size
  MAC_ALGOR_MD5,
  MD5_DIGEST_LEN,			// MAC-Size
  KEY_EXCHANGE_RSA,
  CIPH_TLS10_SSL,

  SSL_RSA_EXP_DES40_CBC_SHA,		// 0x08 SSL_RSA_EXP_DES40_CBC_SHA
  CIPHER_ALGOR_DES_CBC,
  ALGOR_TYPE_BLOCK,
  IS_EXPORTABLE,
  5,					// key material size
  8,					// key size
  8,					// IV size
  8,					// block size
  MAC_ALGOR_SHA1,
  SHA_DIGEST_LEN,			// MAC-Size
  KEY_EXCHANGE_RSA,
  CIPH_TLS10_SSL,

  SSL_RSA_DES_CBC_SHA,			// 0x09	SSL_RSA_DES_CBC_SHA
  CIPHER_ALGOR_DES_CBC,
  ALGOR_TYPE_BLOCK,
  IS_NOT_EXPORTABLE,
  8,					// key material size
  8,					// key size
  8,					// IV size
  8,					// block size
  MAC_ALGOR_SHA1,
  SHA_DIGEST_LEN,			// MAC-Size
  KEY_EXCHANGE_RSA,
  CIPH_TLS10_SSL|CIPH_TLS11,

  SSL_RSA_3DES_EDE_CBC_SHA,		// 0x0A SSL_RSA_3DES_EDE_CBC_SHA
  CIPHER_ALGOR_3DES_EDE_CBC,
  ALGOR_TYPE_BLOCK,
  IS_NOT_EXPORTABLE,
  24,					// key material size
  24,					// key size
  8,					// IV size
  8,					// block size
  MAC_ALGOR_SHA1,
  SHA_DIGEST_LEN,			// MAC-Size
  KEY_EXCHANGE_RSA,
  CIPH_TLS10_SSL|CIPH_TLS11|CIPH_TLS12,

  SSL_DH_DSS_EXP_DES40_CBC_SHA,		// 0x0B SSL_DH_DSS_EXP_DES40_CBC_SHA
  CIPHER_ALGOR_DES_CBC,
  ALGOR_TYPE_BLOCK,
  IS_EXPORTABLE,
  5,					// key material size
  8,					// key size
  8,					// IV size
  8,					// block size
  MAC_ALGOR_SHA1,
  SHA_DIGEST_LEN,			// MAC-Size
  KEY_EXCHANGE_DH_DSS,
  CIPH_TLS10_SSL,

  SSL_DH_DSS_DES_CBC_SHA,		// 0x0C SSL_DH_DSS_DES_CBC_SHA
  CIPHER_ALGOR_DES_CBC,
  ALGOR_TYPE_BLOCK,
  IS_NOT_EXPORTABLE,
  8,					// key material size
  8,					// key size
  8,					// IV size
  8,					// block size
  MAC_ALGOR_SHA1,
  SHA_DIGEST_LEN,			// MAC-Size
  KEY_EXCHANGE_DH_DSS,
  CIPH_TLS10_SSL|CIPH_TLS11,

  SSL_DH_DSS_3DES_EDE_CBC_SHA,		// 0x0D SSL_DH_DSS_3DES_EDE_CBC_SHA
  CIPHER_ALGOR_3DES_EDE_CBC,
  ALGOR_TYPE_BLOCK,
  IS_NOT_EXPORTABLE,
  24,					// key material size
  24,					// key size
  8,					// IV size
  8,					// block size
  MAC_ALGOR_SHA1,
  SHA_DIGEST_LEN,			// MAC-Size
  KEY_EXCHANGE_DH_DSS,
  CIPH_TLS10_SSL|CIPH_TLS11|CIPH_TLS12,

  SSL_DH_RSA_EXP_DES40_CBC_SHA,		// 0x0E SSL_DH_RSA_EXP_DES40_CBC_SHA
  CIPHER_ALGOR_DES_CBC,
  ALGOR_TYPE_BLOCK,
  IS_EXPORTABLE,
  5,					// key material size
  8,					// key size
  8,					// IV size
  8,					// block size
  MAC_ALGOR_SHA1,
  SHA_DIGEST_LEN,			// MAC-Size
  KEY_EXCHANGE_DH_RSA,
  CIPH_TLS10_SSL,

  SSL_DH_RSA_DES_CBC_SHA,		// 0x0F SSL_DH_RSA_DES_CBC_SHA
  CIPHER_ALGOR_DES_CBC,
  ALGOR_TYPE_BLOCK,
  IS_NOT_EXPORTABLE,
  8,					// key material size
  8,					// key size
  8,					// IV size
  8,					// block size
  MAC_ALGOR_SHA1,
  SHA_DIGEST_LEN,			// MAC-Size
  KEY_EXCHANGE_DH_RSA,
  CIPH_TLS10_SSL|CIPH_TLS11,

  SSL_DH_RSA_3DES_EDE_CBC_SHA,		// 0x10 SSL_DH_RSA_3DES_EDE_CBC_SHA
  CIPHER_ALGOR_3DES_EDE_CBC,
  ALGOR_TYPE_BLOCK,
  IS_NOT_EXPORTABLE,
  24,					// key material size
  24,					// key size
  8,					// IV size
  8,					// block size
  MAC_ALGOR_SHA1,
  SHA_DIGEST_LEN,			// MAC-Size
  KEY_EXCHANGE_DH_RSA,
  CIPH_TLS10_SSL|CIPH_TLS11|CIPH_TLS12,

  SSL_DHE_DSS_EXP_DES40_CBC_SHA,	// 0x11 SSL_DHE_DSS_EXP_DES40_CBC_SHA
  CIPHER_ALGOR_DES_CBC,
  ALGOR_TYPE_BLOCK,
  IS_EXPORTABLE,
  5,					// key material size
  8,					// key size
  8,					// IV size
  8,					// block size
  MAC_ALGOR_SHA1,
  SHA_DIGEST_LEN,			// MAC-Size
  KEY_EXCHANGE_DHE_DSS,
  CIPH_TLS10_SSL,

  SSL_DHE_DSS_DES_CBC_SHA,		// 0x12 SSL_DHE_DSS_DES_CBC_SHA
  CIPHER_ALGOR_DES_CBC,
  ALGOR_TYPE_BLOCK,
  IS_NOT_EXPORTABLE,
  8,					// key material size
  8,					// key size
  8,					// IV size
  8,					// block size
  MAC_ALGOR_SHA1,
  SHA_DIGEST_LEN,			// MAC-Size
  KEY_EXCHANGE_DHE_DSS,
  CIPH_TLS10_SSL|CIPH_TLS11,

  SSL_DHE_DSS_3DES_EDE_CBC_SHA,		// 0x13 SSL_DHE_DSS_3DES_EDE_CBC_SHA
  CIPHER_ALGOR_3DES_EDE_CBC,
  ALGOR_TYPE_BLOCK,
  IS_NOT_EXPORTABLE,
  24,					// key material size
  24,					// key size
  8,					// IV size
  8,					// block size
  MAC_ALGOR_SHA1,
  SHA_DIGEST_LEN,			// MAC-Size
  KEY_EXCHANGE_DHE_DSS,
  CIPH_TLS10_SSL|CIPH_TLS11|CIPH_TLS12,

  SSL_DHE_RSA_EXP_DES40_CBC_SHA,	// 0x14 SSL_DHE_RSA_EXP_DES40_CBC_SHA
  CIPHER_ALGOR_DES_CBC,
  ALGOR_TYPE_BLOCK,
  IS_EXPORTABLE,
  5,					// key material size
  8,					// key size
  8,					// IV size
  8,					// block size
  MAC_ALGOR_SHA1,
  SHA_DIGEST_LEN,			// MAC-Size
  KEY_EXCHANGE_DHE_RSA,
  CIPH_TLS10_SSL,

  SSL_DHE_RSA_DES_CBC_SHA,		// 0x15 SSL_DHE_RSA_DES_CBC_SHA
  CIPHER_ALGOR_DES_CBC,
  ALGOR_TYPE_BLOCK,
  IS_NOT_EXPORTABLE,
  8,					// key material size
  8,					// key size
  8,					// IV size
  8,					// block size
  MAC_ALGOR_SHA1,
  SHA_DIGEST_LEN,			// MAC-Size
  KEY_EXCHANGE_DHE_RSA,
  CIPH_TLS10_SSL|CIPH_TLS11,

  SSL_DHE_RSA_3DES_EDE_CBC_SHA,		// 0x16 SSL_DHE_RSA_3DES_EDE_CBC_SHA
  CIPHER_ALGOR_3DES_EDE_CBC,
  ALGOR_TYPE_BLOCK,
  IS_NOT_EXPORTABLE,
  24,					// key material size
  24,					// key size
  8,					// IV size
  8,					// block size
  MAC_ALGOR_SHA1,
  SHA_DIGEST_LEN,			// MAC-Size
  KEY_EXCHANGE_DHE_RSA,
  CIPH_TLS10_SSL|CIPH_TLS11|CIPH_TLS12,

  SSL_RSA_AES_128_CBC_SHA,		// 0x2F SSL_RSA_AES_128_CBC_SHA
  CIPHER_ALGOR_AES_CBC,
  ALGOR_TYPE_BLOCK,
  IS_NOT_EXPORTABLE,
  16,					// key material size
  16,					// key size
  16,					// IV size
  16,					// block size
  MAC_ALGOR_SHA1,
  SHA_DIGEST_LEN,			// MAC-Size
  KEY_EXCHANGE_RSA,
  CIPH_TLS10_SSL|CIPH_TLS11|CIPH_TLS12,

  SSL_DH_DSS_AES_128_CBC_SHA,		// 0x30 SSL_DH_DSS_AES_128_CBC_SHA
  CIPHER_ALGOR_AES_CBC,
  ALGOR_TYPE_BLOCK,
  IS_NOT_EXPORTABLE,
  16,					// key material size
  16,					// key size
  16,					// IV size
  16,					// block size
  MAC_ALGOR_SHA1,
  SHA_DIGEST_LEN,			// MAC-Size
  KEY_EXCHANGE_DH_DSS,
  CIPH_TLS10_SSL|CIPH_TLS11|CIPH_TLS12,

  SSL_DH_RSA_AES_128_CBC_SHA,		// 0x31 SSL_DH_RSA_AES_128_CBC_SHA
  CIPHER_ALGOR_AES_CBC,
  ALGOR_TYPE_BLOCK,
  IS_NOT_EXPORTABLE,
  16,					// key material size
  16,					// key size
  16,					// IV size
  16,					// block size
  MAC_ALGOR_SHA1,
  SHA_DIGEST_LEN,			// MAC-Size
  KEY_EXCHANGE_DH_RSA,
  CIPH_TLS10_SSL|CIPH_TLS11|CIPH_TLS12,

  SSL_DHE_DSS_AES_128_CBC_SHA,		// 0x32 SSL_DHE_DSS_AES_128_CBC_SHA
  CIPHER_ALGOR_AES_CBC,
  ALGOR_TYPE_BLOCK,
  IS_NOT_EXPORTABLE,
  16,					// key material size
  16,					// key size
  16,					// IV size
  16,					// block size
  MAC_ALGOR_SHA1,
  SHA_DIGEST_LEN,			// MAC-Size
  KEY_EXCHANGE_DHE_DSS,
  CIPH_TLS10_SSL|CIPH_TLS11|CIPH_TLS12,

  SSL_DHE_RSA_AES_128_CBC_SHA,		// 0x33 SSL_DHE_RSA_AES_128_CBC_SHA
  CIPHER_ALGOR_AES_CBC,
  ALGOR_TYPE_BLOCK,
  IS_NOT_EXPORTABLE,
  16,					// key material size
  16,					// key size
  16,					// IV size
  16,					// block size
  MAC_ALGOR_SHA1,
  SHA_DIGEST_LEN,			// MAC-Size
  KEY_EXCHANGE_DHE_RSA,
  CIPH_TLS10_SSL|CIPH_TLS11|CIPH_TLS12,

  SSL_RSA_AES_256_CBC_SHA,		// 0x35 SSL_RSA_AES_256_CBC_SHA
  CIPHER_ALGOR_AES_CBC,
  ALGOR_TYPE_BLOCK,
  IS_NOT_EXPORTABLE,
  32,					// key material size
  32,					// key size
  16,					// IV size
  16,					// block size
  MAC_ALGOR_SHA1,
  SHA_DIGEST_LEN,			// MAC-Size
  KEY_EXCHANGE_RSA,
  CIPH_TLS10_SSL|CIPH_TLS11|CIPH_TLS12,

  SSL_DH_DSS_AES_256_CBC_SHA,		// 0x36 SSL_DH_DSS_AES_256_CBC_SHA
  CIPHER_ALGOR_AES_CBC,
  ALGOR_TYPE_BLOCK,
  IS_NOT_EXPORTABLE,
  32,					// key material size
  32,					// key size
  16,					// IV size
  16,					// block size
  MAC_ALGOR_SHA1,
  SHA_DIGEST_LEN,			// MAC-Size
  KEY_EXCHANGE_DH_DSS,
  CIPH_TLS10_SSL|CIPH_TLS11|CIPH_TLS12,

  SSL_DH_RSA_AES_256_CBC_SHA,		// 0x37 SSL_DH_RSA_AES_256_CBC_SHA
  CIPHER_ALGOR_AES_CBC,
  ALGOR_TYPE_BLOCK,
  IS_NOT_EXPORTABLE,
  32,					// key material size
  32,					// key size
  16,					// IV size
  16,					// block size
  MAC_ALGOR_SHA1,
  SHA_DIGEST_LEN,			// MAC-Size
  KEY_EXCHANGE_DH_RSA,
  CIPH_TLS10_SSL|CIPH_TLS11|CIPH_TLS12,

  SSL_DHE_DSS_AES_256_CBC_SHA,		// 0x38 SSL_DHE_DSS_AES_256_CBC_SHA
  CIPHER_ALGOR_AES_CBC,
  ALGOR_TYPE_BLOCK,
  IS_NOT_EXPORTABLE,
  32,					// key material size
  32,					// key size
  16,					// IV size
  16,					// block size
  MAC_ALGOR_SHA1,
  SHA_DIGEST_LEN,			// MAC-Size
  KEY_EXCHANGE_DHE_DSS,
  CIPH_TLS10_SSL|CIPH_TLS11|CIPH_TLS12,

  SSL_DHE_RSA_AES_256_CBC_SHA,		// 0x39 SSL_DHE_RSA_AES_256_CBC_SHA
  CIPHER_ALGOR_AES_CBC,
  ALGOR_TYPE_BLOCK,
  IS_NOT_EXPORTABLE,
  32,					// key material size
  32,					// key size
  16,					// IV size
  16,					// block size
  MAC_ALGOR_SHA1,
  SHA_DIGEST_LEN,			// MAC-Size
  KEY_EXCHANGE_DHE_RSA,
  CIPH_TLS10_SSL|CIPH_TLS11|CIPH_TLS12,

  TLS_RSA_NULL_SHA256,			// 0x3B TLS_RSA_NULL_SHA256
  CIPHER_ALGOR_NULL,
  ALGOR_TYPE_STREAM,
  IS_NOT_EXPORTABLE,			// Avoid server key exchange...
  0,					// key material size
  0,					// key size
  0,					// IV size
  0,					// block size
  MAC_ALGOR_SHA256,
  SHA256_DIGEST_LEN,			// MAC-Size
  KEY_EXCHANGE_RSA,
  CIPH_TLS12,

  TLS_RSA_AES_128_CBC_SHA256,		// 0x3C TLS_RSA_AES_128_CBC_SHA256
  CIPHER_ALGOR_AES_CBC,
  ALGOR_TYPE_BLOCK,
  IS_NOT_EXPORTABLE,			// Avoid server key exchange...
  16,					// key material size
  16,					// key size
  16,					// IV size
  16,					// block size
  MAC_ALGOR_SHA256,
  SHA256_DIGEST_LEN,			// MAC-Size
  KEY_EXCHANGE_RSA,
  CIPH_TLS12,

  TLS_RSA_AES_256_CBC_SHA256,		// 0x3D TLS_RSA_AES_256_CBC_SHA256
  CIPHER_ALGOR_AES_CBC,
  ALGOR_TYPE_BLOCK,
  IS_NOT_EXPORTABLE,			// Avoid server key exchange...
  32,					// key material size
  32,					// key size
  16,					// IV size
  16,					// block size
  MAC_ALGOR_SHA256,
  SHA256_DIGEST_LEN,			// MAC-Size
  KEY_EXCHANGE_RSA,
  CIPH_TLS12,

  TLS_DH_DSS_AES_128_CBC_SHA256,	// 0x3E TLS_DH_DSS_AES_128_CBC_SHA256
  CIPHER_ALGOR_AES_CBC,
  ALGOR_TYPE_BLOCK,
  IS_NOT_EXPORTABLE,			// Avoid server key exchange...
  16,					// key material size
  16,					// key size
  16,					// IV size
  16,					// block size
  MAC_ALGOR_SHA256,
  SHA256_DIGEST_LEN,			// MAC-Size
  KEY_EXCHANGE_DH_DSS,
  CIPH_TLS12,

  TLS_DH_RSA_AES_128_CBC_SHA256,	// 0x3F TLS_DH_RSA_AES_128_CBC_SHA256
  CIPHER_ALGOR_AES_CBC,
  ALGOR_TYPE_BLOCK,
  IS_NOT_EXPORTABLE,			// Avoid server key exchange...
  16,					// key material size
  16,					// key size
  16,					// IV size
  16,					// block size
  MAC_ALGOR_SHA256,
  SHA256_DIGEST_LEN,			// MAC-Size
  KEY_EXCHANGE_DH_RSA,
  CIPH_TLS12,

  TLS_DHE_DSS_AES_128_CBC_SHA256,	// 0x40 TLS_DHE_DSS_AES_128_CBC_SHA256
  CIPHER_ALGOR_AES_CBC,
  ALGOR_TYPE_BLOCK,
  IS_NOT_EXPORTABLE,			// Avoid server key exchange...
  16,					// key material size
  16,					// key size
  16,					// IV size
  16,					// block size
  MAC_ALGOR_SHA256,
  SHA256_DIGEST_LEN,			// MAC-Size
  KEY_EXCHANGE_DHE_DSS,
  CIPH_TLS12,

  TLS_DHE_RSA_AES_128_CBC_SHA256,	// 0x67 TLS_DHE_RSA_AES_128_CBC_SHA256
  CIPHER_ALGOR_AES_CBC,
  ALGOR_TYPE_BLOCK,
  IS_NOT_EXPORTABLE,			// Avoid server key exchange...
  16,					// key material size
  16,					// key size
  16,					// IV size
  16,					// block size
  MAC_ALGOR_SHA256,
  SHA256_DIGEST_LEN,			// MAC-Size
  KEY_EXCHANGE_DHE_RSA,
  CIPH_TLS12,

  TLS_DH_DSS_AES_256_CBC_SHA256,	// 0x68 TLS_DH_DSS_AES_256_CBC_SHA256
  CIPHER_ALGOR_AES_CBC,
  ALGOR_TYPE_BLOCK,
  IS_NOT_EXPORTABLE,			// Avoid server key exchange...
  32,					// key material size
  32,					// key size
  16,					// IV size
  16,					// block size
  MAC_ALGOR_SHA256,
  SHA256_DIGEST_LEN,			// MAC-Size
  KEY_EXCHANGE_DH_DSS,
  CIPH_TLS12,

  TLS_DH_RSA_AES_256_CBC_SHA256,	// 0x69 TLS_DH_RSA_AES_256_CBC_SHA256
  CIPHER_ALGOR_AES_CBC,
  ALGOR_TYPE_BLOCK,
  IS_NOT_EXPORTABLE,			// Avoid server key exchange...
  32,					// key material size
  32,					// key size
  16,					// IV size
  16,					// block size
  MAC_ALGOR_SHA256,
  SHA256_DIGEST_LEN,			// MAC-Size
  KEY_EXCHANGE_DH_RSA,
  CIPH_TLS12,

  TLS_DHE_DSS_AES_256_CBC_SHA256,	// 0x6A TLS_DHE_DSS_AES_256_CBC_SHA256
  CIPHER_ALGOR_AES_CBC,
  ALGOR_TYPE_BLOCK,
  IS_NOT_EXPORTABLE,			// Avoid server key exchange...
  32,					// key material size
  32,					// key size
  16,					// IV size
  16,					// block size
  MAC_ALGOR_SHA256,
  SHA256_DIGEST_LEN,			// MAC-Size
  KEY_EXCHANGE_DHE_DSS,
  CIPH_TLS12,

  TLS_DHE_RSA_AES_256_CBC_SHA256,	// 0x6B TLS_DHE_RSA_AES_256_CBC_SHA256
  CIPHER_ALGOR_AES_CBC,
  ALGOR_TYPE_BLOCK,
  IS_NOT_EXPORTABLE,			// Avoid server key exchange...
  32,					// key material size
  32,					// key size
  16,					// IV size
  16,					// block size
  MAC_ALGOR_SHA256,
  SHA256_DIGEST_LEN,			// MAC-Size
  KEY_EXCHANGE_DHE_RSA,
  CIPH_TLS12,

  TLS_SRP_SHA_WITH_AES_128_CBC_SHA,		// 0x1D SSL_DHE_RSA_AES_128_CBC_SHA (same id as SSL_FORTEZZA_KEA_FORT_CBC_SHA, which however is not used)
  CIPHER_ALGOR_AES_CBC,
  ALGOR_TYPE_BLOCK,
  IS_NOT_EXPORTABLE,
  16,					// key material size
  16,					// key size
  16,					// IV size
  16,					// block size
  MAC_ALGOR_SHA1,
  SHA_DIGEST_LEN,			// MAC-Size
  KEY_EXCHANGE_SRP,
  CIPH_TLS10_SSL|CIPH_TLS11|CIPH_TLS12,

  TLS_RSA_WITH_AES_128_GCM_SHA256,
  CIPHER_ALGOR_AES_GCM,
  ALGOR_TYPE_AEAD,
  IS_NOT_EXPORTABLE,
  16,                   // key material size
  16,                   // key size
  4,                    // implicit IV size
  0,                    // block size
  MAC_ALGOR_AES_GCM,
  AES_BLOCK_SIZE,
  KEY_EXCHANGE_RSA,
  CIPH_TLS12,

  TLS_DHE_RSA_WITH_AES_128_GCM_SHA256,
  CIPHER_ALGOR_AES_GCM,
  ALGOR_TYPE_AEAD,
  IS_NOT_EXPORTABLE,
  16,                   // key material size
  16,                   // key size
  4,                    // implicit IV size
  0,                    // block size
  MAC_ALGOR_AES_GCM,
  AES_BLOCK_SIZE,
  KEY_EXCHANGE_DHE_RSA,
  CIPH_TLS12,

  TLS_DHE_DSS_WITH_AES_128_GCM_SHA256,
  CIPHER_ALGOR_AES_GCM,
  ALGOR_TYPE_AEAD,
  IS_NOT_EXPORTABLE,
  16,                   // key material size
  16,                   // key size
  4,                    // implicit IV size
  0,                    // block size
  MAC_ALGOR_AES_GCM,
  AES_BLOCK_SIZE,
  KEY_EXCHANGE_DHE_DSS,
  CIPH_TLS12,
 
  (unsigned char)TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA,
  CIPHER_ALGOR_AES_CBC,
  ALGOR_TYPE_BLOCK,
  IS_NOT_EXPORTABLE,
  16,					// key material size
  16,					// key size
  16,					// IV size
  16,					// block size
  MAC_ALGOR_SHA1,
  SHA_DIGEST_LEN,			// MAC-Size
  KEY_EXCHANGE_ECDHE_RSA,
  CIPH_TLS10_SSL|CIPH_TLS11|CIPH_TLS12,
  
  (unsigned char)TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA,
  CIPHER_ALGOR_AES_CBC,
  ALGOR_TYPE_BLOCK,
  IS_NOT_EXPORTABLE,
  32,					// key material size
  32,					// key size
  16,					// IV size
  16,					// block size
  MAC_ALGOR_SHA1,
  SHA_DIGEST_LEN,			// MAC-Size
  KEY_EXCHANGE_ECDHE_RSA,
  CIPH_TLS10_SSL|CIPH_TLS11|CIPH_TLS12,
  
  (unsigned char)TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256,
  CIPHER_ALGOR_AES_CBC,
  ALGOR_TYPE_BLOCK,
  IS_NOT_EXPORTABLE,
  16,					// key material size
  16,					// key size
  16,					// IV size
  16,					// block size
  MAC_ALGOR_SHA256,
  SHA256_DIGEST_LEN,			// MAC-Size
  KEY_EXCHANGE_ECDHE_RSA,
  CIPH_TLS12,
  
  (unsigned char)TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256,
  CIPHER_ALGOR_AES_GCM,
  ALGOR_TYPE_AEAD,
  IS_NOT_EXPORTABLE,
  16,                   // key material size
  16,                   // key size
  4,                    // implicit IV size
  0,                    // block size
  MAC_ALGOR_AES_GCM,
  AES_BLOCK_SIZE,
  KEY_EXCHANGE_ECDHE_RSA,
  CIPH_TLS12,
};

//------------------------------------------------------------
// Helper Array of supported Compression Methods
//------------------------------------------------------------
#define	MAX_SUPPORTED_COMPR	2

static  unsigned char SupportedCompr[MAX_SUPPORTED_COMPR] =
{
	COMPR_NULL,			// none
	(unsigned char) COMPR_V42BIS		// V.42bis
};
//------------------------------------------------------------
// Helper Array of supported Cipher suites
//------------------------------------------------------------
#define	MAX_SUPPORTED_SUITES	(MAX_DEFINED_SUITES+1)

unsigned short SupportedSuites[MAX_SUPPORTED_SUITES] =
{
    SSL_NULL_NULL_NULL,
    SSL_RSA_NULL_MD5,
    SSL_RSA_NULL_SHA,
    SSL_RSA_EXP_RC4_40_MD5,
    SSL_RSA_RC4_128_MD5,
    SSL_RSA_RC4_128_SHA,
    SSL_RSA_EXP_RC2_CBC_40_MD5,
    SSL_RSA_EXP_DES40_CBC_SHA,
    SSL_RSA_DES_CBC_SHA,
    SSL_RSA_3DES_EDE_CBC_SHA,

    SSL_DH_DSS_EXP_DES40_CBC_SHA,
    SSL_DH_DSS_DES_CBC_SHA,
    SSL_DH_DSS_3DES_EDE_CBC_SHA,
    SSL_DH_RSA_EXP_DES40_CBC_SHA,
    SSL_DH_RSA_DES_CBC_SHA,
    SSL_DH_RSA_3DES_EDE_CBC_SHA,

    SSL_DHE_DSS_EXP_DES40_CBC_SHA,
    SSL_DHE_DSS_DES_CBC_SHA,
    SSL_DHE_DSS_3DES_EDE_CBC_SHA,
    SSL_DHE_RSA_EXP_DES40_CBC_SHA,
    SSL_DHE_RSA_DES_CBC_SHA,
    SSL_DHE_RSA_3DES_EDE_CBC_SHA,

    SSL_RSA_AES_128_CBC_SHA,
    SSL_DH_DSS_AES_128_CBC_SHA,
    SSL_DH_RSA_AES_128_CBC_SHA,
    SSL_DHE_DSS_AES_128_CBC_SHA,
    SSL_DHE_RSA_AES_128_CBC_SHA,

    SSL_RSA_AES_256_CBC_SHA,
    SSL_DH_DSS_AES_256_CBC_SHA,
    SSL_DH_RSA_AES_256_CBC_SHA,
    SSL_DHE_DSS_AES_256_CBC_SHA,
    SSL_DHE_RSA_AES_256_CBC_SHA,

    TLS_RSA_NULL_SHA256,
    TLS_RSA_AES_128_CBC_SHA256,
    TLS_RSA_AES_256_CBC_SHA256,
    TLS_DH_DSS_AES_128_CBC_SHA256,
    TLS_DH_RSA_AES_128_CBC_SHA256,
    TLS_DHE_DSS_AES_128_CBC_SHA256,

    TLS_DHE_RSA_AES_128_CBC_SHA256,
    TLS_DH_DSS_AES_256_CBC_SHA256,
    TLS_DH_RSA_AES_256_CBC_SHA256,
    TLS_DHE_DSS_AES_256_CBC_SHA256,
    TLS_DHE_RSA_AES_256_CBC_SHA256,

    TLS_SRP_SHA_WITH_AES_128_CBC_SHA,

    TLS_RSA_WITH_AES_128_GCM_SHA256,
    TLS_DHE_RSA_WITH_AES_128_GCM_SHA256,
    TLS_DHE_DSS_WITH_AES_128_GCM_SHA256,

    TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA,
    TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA,
    TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256,
    TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256,
};

/** Contains the EC point format extension with uncompressed point only, followed by the supported curves extension with:
*/
const unsigned char byrs_ecc_client_extensions[] = {
    0x00, 0x0b, 0x00, 0x02, 0x01, 0x00,
    0x00, 0x0a, 0x00, 0x10, 0x00, 0x0e,
    0x00, 0x17, 0x00, 0x18, 0x00, 0x19,             // secp***r1 curves
    0x00, 0x16,                                     // secp256k1
    0x00, 0x1A, 0x00, 0x1B, 0x00, 0x1C,             // brainpool curves
};
//-------------------------------------------------------
// Array for the Connection State Structure
// The array will be directly indexed by the
// ----- socket index - 1 from the Interface !!!!!
//-------------------------------------------------------
#if !defined XH_INTERFACE
//CONN_PTR_ARRAY_PTR
static CONNSTRU ** pConnPtrArray = NULL;
static int ActConnectionCount = 0;	// active Sessions
static int MaxConnectionIndex = 0;	// last used index in Table
//PRIVATE int ConnLockFlag = 0;		// Access Inhibit
static int InitializedFlag = 0;		// Global Initialized Flags
#endif // XH_INTERFACE

//
// Dummies for JAVA / C
//

/** @addtogroup hssl
* @{
*/
#if !defined XH_INTERFACE 		// not used with alternate
#if defined _WIN32
CRITICAL_SECTION HsslCriticalSection;
CRITICAL_SECTION HsslSubjListCriticalSection;

/**
* Gets a lock for the global HsslCriticalSection (GetConnStrucLock).
*/
static void GetConnStrucLock()
{
  EnterCriticalSection(&HsslCriticalSection);
}

/**
*  Releases the lock on the global HsslCriticalSection (ReleaseConnStrucLock).
*/
static void ReleaseConnStrucLock()
{
  LeaveCriticalSection(&HsslCriticalSection);
}

/**
* Initializes  the global HsslCriticalSection (InitConnStrucLock).
*/
static void InitConnStrucLock()
{
  InitializeCriticalSection(&HsslCriticalSection);
}

/**
* Gets a lock for the global HsslSubjListCriticalSection (GetSubjListLock).
*/
static void GetSubjListLock()
{
  EnterCriticalSection(&HsslSubjListCriticalSection);
}

/**
*  Releases the lock on the global HsslSubjListCriticalSection (ReleaseSubjListLock).
*/
static void ReleaseSubjListLock()
{
  LeaveCriticalSection(&HsslSubjListCriticalSection);
}

/**
* Initializes  the global HsslSubjListCriticalSection (InitSubjListLock).
*/
static void InitSubjListLock()
{
  InitializeCriticalSection(&HsslSubjListCriticalSection);
}
#else // !XH_INTERFACE
#define GetConnStrucLock()
#define ReleaseConnStrucLock()
#define InitConnStrucLock()
#define	GetSubjListLock()
#define	ReleaseSubjListLock()
#define	InitSubjListLock()

#endif // WIN32/64
#endif // !XH_INTERFACE
/** @} */

// Macros for Output

// dto.

//================================================================
//
// !!!!! END FOR TESTING ONLY !!!!!!
//
//================================================================
//----------------------------------------------------------------
// PRIVATE STATIC declarations
//----------------------------------------------------------------
//ExtractRenegotExtension
static  int ExtractRenegotExtension(HMEM_CTX_DEF CONNSTRU * pConnStruc,
			char* InpBuf, int InpOffset, int InpLen);
//CheckRenegotExtension
static  int CheckRenegotExtension(CONNSTRU * pConnStruc,int Mode);

/** @addtogroup hssl
* @{
*/

#if (defined _WIN32)
#pragma optimize("", off) // This is to assure, that optimization won't remove clear functions
#endif
/**
* Clears a BYTE array (ClearBit8Array).
* 
*  @param pArray Array base
*  @param length Size (in elements)
*/
static  void  ClearBit8Array(char* pArray, int length)
{
  if((pArray == NULL) || (length == 0)) return;		// nothing to do
  memset(pArray,0,length);
}
/**
* Clears a 16-bit array (ClearBit16Array).
* 
*  @param pArray Array base
*  @param length Size (in elements)
*/
extern "C"  void  ClearBit16Array(short* pArray, int length)
{
  if((pArray == NULL) || (length == 0)) return;		// nothing to do
  memset(pArray,0,length*2);
}
/**
* Clears a 32-Bit array (ClearBit32Array).
* 
*  @param pArray Array base
*  @param length Size (in elements)
*/
extern "C"  void  ClearBit32Array(int* pArray, int length)
{
  if((pArray == NULL) || (length == 0)) return;		// nothing to do
  memset(pArray,0,length*4);
}

/**
* Clears a 64-Bit array (ClearBit64Array).
* 
*  @param pArray Array base
*  @param length Size (in elements)
*/
static  void  ClearBit64Array(long long* pArray, int length)
{
  if((pArray == NULL) || (length == 0)) return;		// nothing to do
  memset(pArray,0,length*8);
}

/**
* Clears a Bit8Array if present and then frees it (ClearFreeBit8Array).
* 
*  @param pArray Array base
*  @param length Size (in elements)
*/
static  void  ClearFreeBit8Array(HMEM_CTX_DEF
					    char* pArray, int length)
{
  if(pArray == NULL)
    return;
  if(length > 0)
  {
    ClearBit8Array(pArray,length);
  }
  FREE_CARRAY(HMEM_CTX_REF,pArray);
}

static  char abys_dummy_pad[256] = {
   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
};

static int m_load_server_host_name(CONNSTRU* adsp_conn,
                                   const struct dsd_unicode_string* adsp_ucs_name)
{
    HMEM_CTX_DEF1;

    LOAD_HMEM_CTX_PTR(CONN_pMemCtx(adsp_conn));

    // Release possible old host name
    FREE_ARRAY(HMEM_CTX_REF, adsp_conn->dsc_ucs_se_host_name.ac_str);
    adsp_conn->dsc_ucs_se_host_name.ac_str = NULL;

    if( (adsp_ucs_name == NULL) || (adsp_ucs_name->imc_len_str == 0) ) {
        adsp_conn->dsc_ucs_se_host_name.imc_len_str = 0;
        return HSSL_OP_OK;
    }

    // The length of the actual host name
    int inl_string_len =  m_len_vx_vx(ied_chs_utf_8,
                                      adsp_ucs_name->ac_str,
                                      adsp_ucs_name->imc_len_str,
                                      adsp_ucs_name->iec_chs_str);

    if ((inl_string_len <= 0) || (inl_string_len > 0xffff)) {
        return HSSL_PARAM_ERR;
    }

    // Add an extra byte for the \0 termination!
    inl_string_len++;

    adsp_conn->dsc_ucs_se_host_name.ac_str = BIT8_ARRAY_ALLOC(HMEM_CTX_REF,
                                                               inl_string_len);

    if( adsp_conn->dsc_ucs_se_host_name.ac_str == NULL ){
        return HSSL_ALLOC_ERR;
    }

    int inl_ret = m_cpy_vx_vx(adsp_conn->dsc_ucs_se_host_name.ac_str,
                              inl_string_len,
                              ied_chs_utf_8, 
                              adsp_ucs_name->ac_str,
                              adsp_ucs_name->imc_len_str,
                              adsp_ucs_name->iec_chs_str);
    if( inl_ret < 0) {
        return inl_ret;
    }
    if((inl_ret > 0) && 
       (((char*)adsp_conn->dsc_ucs_se_host_name.ac_str)[inl_ret-1] == '\0'))
    {
        // remove \0 termination
        inl_ret--;
    }
    adsp_conn->dsc_ucs_se_host_name.imc_len_str = inl_ret;
    adsp_conn->dsc_ucs_se_host_name.iec_chs_str = ied_chs_utf_8;

    return HSSL_OP_OK;
}

/**
Performs a constant time check on the TLS padding.

This should be used for both the 'real' and the dummy checking!

@param inp_pad_cnt[in]  Padding count as read from the last byte.
@param inp_offset[in]   Offset of the first padding byte.
@param achp_pad_val[in] Buffer containing the padding.

@return 0, if padding is valid, non-0 otherwise.
*/
static  char  m_const_pad_compare(int inp_pad_cnt, int inp_offset, char* achp_pad_val){
   char chl_compare_val = (char)inp_pad_cnt;
   char chl_compare_res = 0;
   while(0 != inp_pad_cnt){
      inp_pad_cnt--;
      chl_compare_res |= achp_pad_val[inp_offset] ^ chl_compare_val;
      inp_offset++;
   }
   return chl_compare_res;
}

#if (defined _WIN32)
#pragma optimize("", on)
#endif

#ifdef XH_INTERFACE
static void* ms_malloc_hmem(struct dsd_memory* adsp_memory,
                            size_t szp_size)
{
    ds__hmem* adsl_hmem = (ds__hmem*)adsp_memory->avoc_context;

    void* avol_new_mem = NULL;
    if( adsl_hmem->am__aux2(adsl_hmem->vp__context,
                            DEF_AUX_MEMGET,
                            &avol_new_mem,
                            (int)szp_size))
    {
        return avol_new_mem;
    }
    return NULL;
}

static void ms_free_hmem(struct dsd_memory* adsp_memory,
                         void* avop_ptr)
{
    ds__hmem* adsl_hmem = (ds__hmem*)adsp_memory->avoc_context;

    adsl_hmem->am__aux2(adsl_hmem->vp__context, DEF_AUX_MEMFREE, &avop_ptr, 0);
}

static void* ms_get_mem_ptr(CONNSTRU* adsp_connection)
{
    return adsp_connection->pMemCtxStruc;
}

#define USR_FLD_HMEM (ds__hmem *)avop_user_field,

#else

#define USR_FLD_HMEM

static void* ms_malloc_hmem(struct dsd_memory*,
                            size_t szp_size)
{
    return malloc(szp_size);
}

static void ms_free_hmem(struct dsd_memory*,
                         void* avop_ptr)
{
    free(avop_ptr);
}

static void* ms_get_mem_ptr(CONNSTRU*)
{
    return NULL;
}
#endif // XH_INTERFACE

static int ms_rand_wrapper(void* avop_user_field, 
                           void* avop_dest, 
                           size_t szp_dest_len)
{
   return SecDrbgRandBytes(USR_FLD_HMEM (char*)avop_dest, 0, (int)szp_dest_len);
}

static int ms_process_ecdhe_cl_key_ex(CONNSTRU* adsp_connection,
                                      const unsigned char* achp_data,
                                      size_t szp_data_len);

static enum ied_ecc_named_curves ms_get_curve_name(ied_ec_curve_id iep_curve)
{
    switch (iep_curve)
    {
    case ied_ec_curve_none:
        return ied_size_curves;
    case ied_ec_curve_secp256k1:
        return ied_SECP256K1;
    case ied_ec_curve_secp256r1:
        return ied_P256;
    case ied_ec_curve_secp384r1:
        return ied_P384;
    case ied_ec_curve_secp521r1:
        return ied_P521;
    case ied_ec_curve_brainpoolP256r1:
        return ied_brainpoolP256r1;
    case ied_ec_curve_brainpoolP384r1:
        return ied_brainpoolP384r1;
    case ied_ec_curve_brainpoolP512r1:
        return ied_brainpoolP512r1;
    }
    
    return ied_size_curves;
}

static int ms_init_ecc(CONNSTRU* adsp_connection)
{

    HMEM_CTX_DEF1;

    LOAD_HMEM_CTX_PTR(CONN_pMemCtx(adsp_connection));

    if(! adsp_connection->boc_ecc_possible){
        return HSSL_INIT_ECC_PARAM_ERR;
    }

    enum ied_ecc_named_curves iel_curve = ms_get_curve_name(adsp_connection->iec_selected_curve);

    if( iel_curve == ied_size_curves ){
        return HSSL_INIT_ECC_PARAM_ERR;
    }

    // Allocate a fresh pool for each handshake
    if(adsp_connection->adsc_mem_pool != NULL){
        m_mem_pool_free(&adsp_connection->dsc_mem_mgr, adsp_connection->adsc_mem_pool);
    }
    size_t szl_pool_size_tmp = m_mem_pool_ecc_size(ied_m_ecc_init_named_curve,
                                                   iel_curve);

    adsp_connection->unc_pool_ele_size = m_mem_pool_ecc_size(ied_m_ecc_gen_rand_keypair,
                                                             iel_curve);

    if(szl_pool_size_tmp > adsp_connection->unc_pool_ele_size){
        adsp_connection->unc_pool_ele_size = szl_pool_size_tmp;
    }

    szl_pool_size_tmp = m_mem_pool_ecc_size(ied_m_ecc_gen_secret,
                                            iel_curve);

    if(szl_pool_size_tmp > adsp_connection->unc_pool_ele_size){
        adsp_connection->unc_pool_ele_size = szl_pool_size_tmp;
    }

    adsp_connection->adsc_mem_pool = m_mem_pool_create(&adsp_connection->dsc_mem_mgr,
                                                       adsp_connection->unc_pool_ele_size,
                                                       1);

    if(adsp_connection->adsc_mem_pool == NULL){
        return HSSL_ALLOC_ERR;
    }

    m_ecc_free_keypair(&adsp_connection->dsc_mem_mgr,
                       &adsp_connection->dsc_ecc_keypair);

    adsp_connection->dsc_ecc_keypair.adsc_params = m_ecc_init_named_curve(iel_curve,
                                                                          &dsg_std_memory,
                                                                          NULL);

    if(adsp_connection->dsc_ecc_keypair.adsc_params == NULL) {
        return HSSL_INIT_ECC_PARAM_GEN_ERR;
    }

    ied_encry_return iel_ret = m_ecc_init_keypair(&adsp_connection->dsc_mem_mgr,
                                                  &adsp_connection->dsc_ecc_keypair);

    if(iel_ret != ied_encry_success){
        return HSSL_INIT_ECC_PARAM_GEN_ERR;
    }

    return HSSL_OP_OK;
}

static bool ms_uses_ecc(const char* achp_cipher_list)
{
    const unsigned char* achl_cur_position = (unsigned char*)achp_cipher_list;
    unsigned short usl_remaining_len;
    BIGchar2wordn(achl_cur_position, usl_remaining_len, 0);
    achl_cur_position += 2;

    if((usl_remaining_len & 0x01) == 1){
        return false;
    }

    usl_remaining_len /= 2;
    while(usl_remaining_len != 0){
        if(achl_cur_position[0] == 0xc0){
            // Identifier for ECDHE
            return true;
        }
        achl_cur_position += 2;
        usl_remaining_len--;
    }
    return false;
}

/**
Performs the dummy MAC compressions for countering Lucky 13 attack.

To perform no compressions, just calling this function, use a padding length of -1.

@param adsp_conn[in]    Pointer to current connection structure.
@param inp_msg_len[in]  Length of the whole decrypted message block.
@param inp_pad_len[in]  Padding length as read from last message byte.
*/
static  void  m_dummy_compress(CONNSTRU * adsp_conn, int inp_msg_len, int inp_pad_len){
   // Initialize to (13-55+63)+plen-t
   int inl_l_1_2 = 21+inp_msg_len-adsp_conn->HashSize;
   int inl_hash_rounds = inl_l_1_2/64;
   int ainp_hash_array[SHA256_ARRAY_SIZE];

   // Calculate L2 and the necessary rounds
   inl_l_1_2 -= (inp_pad_len+1);
   inl_hash_rounds -= (inl_l_1_2/64);

   // Perform Hash compressions
   switch(adsp_conn->ActRX_MACAlgor)
   {
   case MAC_ALGOR_MD5:
      MD5_Init(ainp_hash_array);
      while(0 !=inl_hash_rounds){
         MD5_Update(ainp_hash_array,abys_dummy_pad,0,64);
         --inl_hash_rounds;
      }
      break;
   case MAC_ALGOR_SHA1:
      SHA1_Init(ainp_hash_array);
      while(0 !=inl_hash_rounds){
         SHA1_Update(ainp_hash_array,abys_dummy_pad,0,64);
         --inl_hash_rounds;
      }
      break;
   case MAC_ALGOR_SHA256:
      SHA256_Init(ainp_hash_array);
      while(0 !=inl_hash_rounds){
         SHA256_Update(ainp_hash_array,abys_dummy_pad,0,64);
         --inl_hash_rounds;
      }
      break;

   default:					// should not occur
      return;
   } // switch
}

struct dsd_srp_group_params {
   const unsigned char* aucc_n;
   size_t szp_n_len;
   const unsigned char* aucc_g;
   size_t szp_g_len;
};

static const unsigned char aucrs_srp_n_1024[] = { 
    0xEE, 0xAF, 0x0A, 0xB9, 0xAD, 0xB3, 0x8D, 0xD6, 0x9C, 0x33, 0xF8, 0x0A, 0xFA, 0x8F, 0xC5, 0xE8, 
    0x60, 0x72, 0x61, 0x87, 0x75, 0xFF, 0x3C, 0x0B, 0x9E, 0xA2, 0x31, 0x4C, 0x9C, 0x25, 0x65, 0x76, 
    0xD6, 0x74, 0xDF, 0x74, 0x96, 0xEA, 0x81, 0xD3, 0x38, 0x3B, 0x48, 0x13, 0xD6, 0x92, 0xC6, 0xE0, 
    0xE0, 0xD5, 0xD8, 0xE2, 0x50, 0xB9, 0x8B, 0xE4, 0x8E, 0x49, 0x5C, 0x1D, 0x60, 0x89, 0xDA, 0xD1,
    0x5D, 0xC7, 0xD7, 0xB4, 0x61, 0x54, 0xD6, 0xB6, 0xCE, 0x8E, 0xF4, 0xAD, 0x69, 0xB1, 0x5D, 0x49,
    0x82, 0x55, 0x9B, 0x29, 0x7B, 0xCF, 0x18, 0x85, 0xC5, 0x29, 0xF5, 0x66, 0x66, 0x0E, 0x57, 0xEC,
    0x68, 0xED, 0xBC, 0x3C, 0x05, 0x72, 0x6C, 0xC0, 0x2F, 0xD4, 0xCB, 0xF4, 0x97, 0x6E, 0xAA, 0x9A,
    0xFD, 0x51, 0x38, 0xFE, 0x83, 0x76, 0x43, 0x5B, 0x9F, 0xC6, 0x1D, 0x2F, 0xC0, 0xEB, 0x06, 0xE3
};

static const unsigned char aucrs_srp_g_1024[] = {2};

static const unsigned char aucrs_srp_n_2048[] = {
    0xAC, 0x6B, 0xDB, 0x41, 0x32, 0x4A, 0x9A, 0x9B, 0xF1, 0x66, 0xDE, 0x5E, 0x13, 0x89, 0x58, 0x2F,
    0xAF, 0x72, 0xB6, 0x65, 0x19, 0x87, 0xEE, 0x07, 0xFC, 0x31, 0x92, 0x94, 0x3D, 0xB5, 0x60, 0x50, 
    0xA3, 0x73, 0x29, 0xCB, 0xB4, 0xA0, 0x99, 0xED, 0x81, 0x93, 0xE0, 0x75, 0x77, 0x67, 0xA1, 0x3D,
    0xD5, 0x23, 0x12, 0xAB, 0x4B, 0x03, 0x31, 0x0D, 0xCD, 0x7F, 0x48, 0xA9, 0xDA, 0x04, 0xFD, 0x50,
    0xE8, 0x08, 0x39, 0x69, 0xED, 0xB7, 0x67, 0xB0, 0xCF, 0x60, 0x95, 0x17, 0x9A, 0x16, 0x3A, 0xB3,
    0x66, 0x1A, 0x05, 0xFB, 0xD5, 0xFA, 0xAA, 0xE8, 0x29, 0x18, 0xA9, 0x96, 0x2F, 0x0B, 0x93, 0xB8,
    0x55, 0xF9, 0x79, 0x93, 0xEC, 0x97, 0x5E, 0xEA, 0xA8, 0x0D, 0x74, 0x0A, 0xDB, 0xF4, 0xFF, 0x74, 
    0x73, 0x59, 0xD0, 0x41, 0xD5, 0xC3, 0x3E, 0xA7, 0x1D, 0x28, 0x1E, 0x44, 0x6B, 0x14, 0x77, 0x3B,
    0xCA, 0x97, 0xB4, 0x3A, 0x23, 0xFB, 0x80, 0x16, 0x76, 0xBD, 0x20, 0x7A, 0x43, 0x6C, 0x64, 0x81,
    0xF1, 0xD2, 0xB9, 0x07, 0x87, 0x17, 0x46, 0x1A, 0x5B, 0x9D, 0x32, 0xE6, 0x88, 0xF8, 0x77, 0x48,
    0x54, 0x45, 0x23, 0xB5, 0x24, 0xB0, 0xD5, 0x7D, 0x5E, 0xA7, 0x7A, 0x27, 0x75, 0xD2, 0xEC, 0xFA,
    0x03, 0x2C, 0xFB, 0xDB, 0xF5, 0x2F, 0xB3, 0x78, 0x61, 0x60, 0x27, 0x90, 0x04, 0xE5, 0x7A, 0xE6, 
    0xAF, 0x87, 0x4E, 0x73, 0x03, 0xCE, 0x53, 0x29, 0x9C, 0xCC, 0x04, 0x1C, 0x7B, 0xC3, 0x08, 0xD8, 
    0x2A, 0x56, 0x98, 0xF3, 0xA8, 0xD0, 0xC3, 0x82, 0x71, 0xAE, 0x35, 0xF8, 0xE9, 0xDB, 0xFB, 0xB6,
    0x94, 0xB5, 0xC8, 0x03, 0xD8, 0x9F, 0x7A, 0xE4, 0x35, 0xDE, 0x23, 0x6D, 0x52, 0x5F, 0x54, 0x75, 
    0x9B, 0x65, 0xE3, 0x72, 0xFC, 0xD6, 0x8E, 0xF2, 0x0F, 0xA7, 0x11, 0x1F, 0x9E, 0x4A, 0xFF, 0x73
};

static const unsigned char aucrs_srp_g_2048[] = {2};

static const struct dsd_srp_group_params adss_srp_gourp_param_array[] =
{
   { // 1024 bit group
      aucrs_srp_n_1024,128,
      aucrs_srp_g_1024,1
   },{ // 2048 bit group
      aucrs_srp_n_2048,256,
      aucrs_srp_g_2048,1
   }
};

static const unsigned int uns_group_cnt = sizeof(adss_srp_gourp_param_array)/sizeof(struct dsd_srp_group_params);

int m_fill_group_params(struct dsd_tls_srp_verifier_params* adsp_params)
{
   const struct dsd_srp_group_params* adsl_cur_params = NULL;
   unsigned int unl_index = 0;
   size_t szl_target_len = adsp_params->szc_n_len;
   if( 1 > adsp_params->szc_g_len){
      return (-1);
   }

   for(;uns_group_cnt > unl_index;unl_index++){
      if( (adss_srp_gourp_param_array[unl_index].szp_n_len <= szl_target_len) &&
         ( NULL == adsl_cur_params || (adss_srp_gourp_param_array[unl_index].
         szp_n_len > adsl_cur_params->szp_n_len )) )
      {
         adsl_cur_params = adss_srp_gourp_param_array+unl_index;
      }
   }

   if( NULL == adsl_cur_params ){
      return (-1);
   }
   
   memcpy(adsp_params->aucc_n, adsl_cur_params->aucc_n, adsl_cur_params->szp_n_len);
   adsp_params->szc_n_len = adsl_cur_params->szp_n_len;
   memcpy(adsp_params->aucc_g, adsl_cur_params->aucc_g, adsl_cur_params->szp_g_len);
   adsp_params->szc_g_len = adsl_cur_params->szp_g_len;
   
   return 0;
}//int m_fill_group_params(struct dsd_tls_srp_verifier_params* adsp_params);

/**
Validates the group parameters for TLS SRP.

Only parameters, that can be provided by m_fill_group_params are valid.
Bytewise big endian encoding is assumed.

@param[in]  abyp_n         Buffer containing n.
@param[in]  inp_n_offset   Offset at which n starts.
@param[in]  inp_n_len      Length of n.
@param[in]  abyp_g         Buffer containing g.
@param[in]  inp_g_offset   Offset at which g starts.
@param[in]  inp_g_len      Length of g.

@return 0, if parameters are valid, -1 otherwise.
*/
static  int  m_validate_group(char* abyp_n, 
                                         int inp_n_offset, 
                                         int inp_n_len, 
                                         char* abyp_g,
                                         int inp_g_offset,
                                         int inp_g_len)
{
   unsigned int unl_index = 0;
   int inl_cmp_res = 0;
   for(;uns_group_cnt > unl_index;unl_index++){
      if( adss_srp_gourp_param_array[unl_index].szp_n_len == (size_t)inp_n_len && 
         adss_srp_gourp_param_array[unl_index].szp_g_len == (size_t)inp_g_len)
      {
         inl_cmp_res = memcmp(abyp_n+inp_n_offset, adss_srp_gourp_param_array[unl_index].aucc_n, inp_n_len);
         inl_cmp_res |= memcmp(abyp_g+inp_g_offset, adss_srp_gourp_param_array[unl_index].aucc_g, inp_g_len);
         if( 0 == inl_cmp_res ){
            return 0;
         }
      }
   }
   return -1;
}

static  void m_generate_log_msg(CONNSTRU * adsp_connection,
                                const char * achp_message,
                                int inp_error_code,
                                int inp_trace_lvl,
                                const char * achp_tag)
{
#ifdef XH_INTERFACE
   char achl_message_array[512];
   int inl_msg_len =0;
   if(inp_error_code ==0)
   {
      inl_msg_len = (int)strlen(achp_message);
      if( inl_msg_len >512){
         inl_msg_len =512;
      }
      strncpy(achl_message_array, achp_message, inl_msg_len);
   } else {
      inl_msg_len = snprintf(achl_message_array, 512, achp_message, inp_error_code);
   }
   m_event_trace_lvl(adsp_connection->adsc_logger, inp_trace_lvl);
   m_add_text_data(adsp_connection->adsc_logger,achl_message_array, inl_msg_len);
   m_make_log_entry(adsp_connection->adsc_logger,achp_tag);
#endif
}

static int AllocInitOcspParamStruct(CONNSTRU * pConnStruc);
static int CheckAllCipherSuitesExportable(char* List, int ListOff);

/**
Sets a new configuration and resets configuration-dependent fields of a connection struct.

On error, the Connection struct may be partially invalid, but will not be released!

@param[in,out]  adsp_conn           Connection struct to which the CFG shall be set.
@param[in]      adsp_config         Configuration to be set.
@param[in]      inp_target_entity   Entity the cfg should be for.

@return HSSL_OP_OK on success, error code otherwise.
*/
static int m_set_configuration(CONNSTRU* adsp_conn,
                               CFG_STRU* adsp_config,
                               int inp_target_entity)
{
    if(inp_target_entity != adsp_config->Entity) {
        return(HSSL_NEWCONN_INV_CONN_ENTITY);
    }

    adsp_conn->Entity	= (char) inp_target_entity;

    // Setup protocol flags, authentication flags, check cipherlist

    char chl_protocol_flags = adsp_config->ProtFlags & CFG_PROTOCOLS_MASK;

    if((adsp_config->ExtConfigFlags & CFG_TLS_V1_BIT_MASK) != 0) {
        chl_protocol_flags |= TLS_V1_BIT_MASK;
    }

    if((adsp_config->ExtConfigFlags & CFG_TLS_V2_BIT_MASK) != 0) {
        chl_protocol_flags |= TLS_V2_BIT_MASK;
    }
    
    if((chl_protocol_flags & (TLS_V1_BIT_MASK | TLS_V2_BIT_MASK)) != 0) {
        // TLS 1.1 or 1.2 possible
        int inl_ret = CheckAllCipherSuitesExportable( adsp_config->CipherSuitesList, 0);
        if((inl_ret < 0) ||
           (((chl_protocol_flags & (TLS_BIT_MASK | SSL_BIT_MASK)) == 0) &&
            (inl_ret > 0)))
        {
            return(HSSL_CFG_TLS11_ONLY_EXPORT_CIPH_SUITES);
        }
        if(inl_ret > 0) {
            // only export ciphers are set, but SSL or TLS 1.0 is configured
            chl_protocol_flags &= ~(TLS_V1_BIT_MASK | TLS_V2_BIT_MASK);
        }
    }
    adsp_conn->SupportedProtocolsFlags	= chl_protocol_flags;

    adsp_conn->AuthFlags	= adsp_config->ProtFlags & (~CFG_PROTOCOLS_MASK);

    adsp_conn->ExtendedConfigFlags	= adsp_config->ExtConfigFlags;
    adsp_conn->ExtendedConf2Flags= adsp_config->ExtConf2Flags;

    adsp_conn->RenegotiateTime = adsp_config->RenegotiateTime * 60;

    adsp_conn->pCfgStruc = adsp_config;

    // Initialize SSL-V2 Header interpretation as needed
    if((adsp_conn->ExtendedConf2Flags & SRVR_SSLV2_ACCEPT_BIT_MASK) != 0) {   
        adsp_conn->RxHeaderSSLV2CheckEnable = 1;
    }

    // Initialize OCSP

    return AllocInitOcspParamStruct(adsp_conn);
    
 
}

/**
*  Finds the first signature type entry of a specified algorithm type and returns a fitting
*  TLS 1.2 SignatureAndHashAlgorithm specifier.
*
*  Only currently supported combinations are returned.
*/
static  int m_get_cert_pub_signature_tls(char* abyp_sig_list, int inp_public_alg_type)
{
   int inl_priority_sig_type= 0;
   int inl_sig_list_entry_count = abyp_sig_list[0];
   int inl_work1 = 1;
   for( ; inl_work1 <= inl_sig_list_entry_count; inl_work1++)
   {
      switch(abyp_sig_list[inl_work1]){
         case PKCS1_MD5_WITH_RSA_ENC:
            if(inp_public_alg_type != DSA_PUBLIC_ALGOR){
               inl_priority_sig_type = SIG_ALGOR_RSA;
               inl_priority_sig_type += (HASH_ALGOR_MD5)<<8;
            }
            break;
         case PKCS1_SHA1_WITH_RSA_ENC:
            if(inp_public_alg_type != DSA_PUBLIC_ALGOR){
               inl_priority_sig_type = SIG_ALGOR_RSA;
               inl_priority_sig_type += (HASH_ALGOR_SHA1)<<8;
            }
            break;
         case PKCS1_SHA256_WITH_RSA_ENC:
            if(inp_public_alg_type != DSA_PUBLIC_ALGOR){
               inl_priority_sig_type = SIG_ALGOR_RSA;
               inl_priority_sig_type += (HASH_ALGOR_SHA256)<<8;
            }
            break;
         case PKCS1_SHA384_WITH_RSA_ENC:
            if(inp_public_alg_type != DSA_PUBLIC_ALGOR){
               inl_priority_sig_type = SIG_ALGOR_RSA;
               inl_priority_sig_type += (HASH_ALGOR_SHA384)<<8;
            }
            break;
         case PKCS1_SHA512_WITH_RSA_ENC:
            if(inp_public_alg_type != DSA_PUBLIC_ALGOR){
               inl_priority_sig_type = SIG_ALGOR_RSA;
               inl_priority_sig_type += (HASH_ALGOR_SHA512)<<8;
            }
            break;
         //case PKCS1_SHA224_WITH_RSA_ENC:
         //   if(inp_public_alg_type != DSA_PUBLIC_ALGOR){
         //      inl_priority_sig_type = SIG_ALGOR_RSA;
         //      inl_priority_sig_type += (HASH_ALGOR_SHA224)<<8;
         //   }
         //   break;
         case X957_DSA_WITH_SHA1:
         case OIW_DSA_WITH_SHA:
         case OIW_DSA_WITH_SHA1:
            if(inp_public_alg_type != RSA_PUBLIC_ALGOR){
               inl_priority_sig_type = SIG_ALGOR_DSA;
               inl_priority_sig_type += (HASH_ALGOR_SHA1)<<8;
            }
            break;
         default:
            break;
      }
      if(inl_priority_sig_type != 0) break;
   }
   return inl_priority_sig_type;
}
/**
* Searches list array
* for content of given value (SearchSizedList).
* 
* The returned index is rel base and counted by entry size.
*  @param ListArray List array base
*  @param ListOffset Start of data
*  @param EntrySize 0 - Byte
*               1 - Word (Network Order)
*  @param Value Content to search for
* 
*  @return Index of the first found entry, 0, if none is found
*/
static int  SearchSizedList(char* ListArray, int ListOffset,
			int EntrySize, int Value)
{
  int ElementCnt;
  int Index = ListOffset;
  int Priority = 1;

  int TmpValue;
  //---------------------------------------------------
  // Check basic parameter values
  //---------------------------------------------------
  if(ListArray == NULL) return(0);			// not found/invalid
  //---------------------------------------------------
  // Search through list for value match
  //---------------------------------------------------
  switch(EntrySize)
  {
    case 0:						// Byte sized list
      ElementCnt = (int) ListArray[Index++] & 0xFF;	// number of elements
      if((ElementCnt == 0) ||				// not in list
         ((Value & (~(int) 0xFF)) != 0))		// too large
        return(0);
      do
      {
        if(ListArray[Index++] == (char) (Value & 0xFF)) // found
          return(Priority);					// signal priority
        ElementCnt--;
        Priority++;
     }while(ElementCnt != 0);
     return(0);						// not found

    case 1:						// BIGWORD sized list
      BIGchar2word(ListArray,ElementCnt,Index);
      if((ElementCnt == 0) || ((ElementCnt & 0x01) != 0) ||
         ((Value & (~(int) 0xFFFF)) != 0))
        return(0);
      ElementCnt >>= 1;
      do
      {
        BIGchar2word(ListArray,TmpValue,Index);
        if(TmpValue == (Value & 0xFFFF)) return(Priority);
        ElementCnt--;
        Priority++;
      }while(ElementCnt != 0);
      return(0);					// not found

    default:
      return(0);					// invalid size
  } // switch
}

/**
* Compares two byte arrays for equivalence (CmpSizedBit8Arrays). 
* First byte is length of remaining data.
* 
*  @param Array1 Array1 base
*  @param Offset1 Array1 start of Data
*  @param Array2 Array2 base
*  @param Offset2 Array2 start of Data
* 
*  @return int Result == 0 same
* <br>            <> 0 not same
*/
static int  CmpSizedBit8Arrays(char* Array1, int Offset1,
					  char* Array2, int Offset2)
{
  int Index1 = Offset1;
  int Index2 = Offset2;

  int i;
  if((Array1 == NULL) || (Array2 == NULL))	// not both present
  {
    if((Array1 == NULL) && (Array2 == NULL))	// both absent, same
      return(0);
    return(1);
  }
  //---------------------------------------------
  // compare sizes
  //---------------------------------------------
  i = (int) Array1[Index1++] & 0xFF;
  if(i != ((int) Array2[Index2++] & 0xFF)) return(1);	// not same length
  if(i == 0) return(0);				// both length Zero
  //---------------------------------------------
  // compare contents
  //---------------------------------------------
  do
  {
    if(Array1[Index1++] != Array2[Index2++]) return(1);	// not same
    i--;
  }while(i != 0);
  return(0);					// same
}
/**
*  Reads the signature extension from input buffer and generates the internal 
*  signature list (m_process_supported_sig).
*
*  The generated list will be put in a newly allocated buffer. 
*  If no list can be generated nothing is allocated.
*  The internal format is a length/value list, the first byte is the number of
*  values, each value is a signature type identifier of the ASN.1 certificate 
*  handler.
*
*  @param  abyp_in_buf         Input buffer, containing the extension
*  @param  inp_extension_len   Length of the the signature data in the extension
*  @param  inp_data_offset     Starting offset of the signature data, 
*                              excluding the length field
*  @param  aabyp_out_buf       Pointer for placing the generated buffer
*
*  @return HSSL_OP_OK on success, error code on failure
*/
static  int  m_process_supported_sig( HMEM_CTX_DEF
                                                 char* abyp_in_buf, 
                                                 int inp_extension_len,
                                                 int inp_data_offset,
                                                 char** aabyp_out_buf)
{ 
    // We reserve extra space for simplifying safeguards against stack overflows.
    // 6 extra: 1 for length, 2 for the possible additional 2 from DSA SHA1 and 3 for a second SHA1 entry
    char abyl_temp_sig_list[(SIG_ALGOR_MAX_COUNT+6)];
    int inl_sig_count=0;
    int inl_dsa_sig_count = 0;
    
    aabyp_out_buf[0] = NULL;
    for(;inp_extension_len >0;inp_extension_len-=2){ // iterate over all identifiers
       switch(abyp_in_buf[inp_data_offset+1]){
          case SIG_ALGOR_RSA:
             switch(abyp_in_buf[inp_data_offset]){
                case HASH_ALGOR_MD5:
                   abyl_temp_sig_list[++inl_sig_count] = PKCS1_MD5_WITH_RSA_ENC;
                   break;
                case HASH_ALGOR_SHA1:
                   abyl_temp_sig_list[++inl_sig_count] = PKCS1_SHA1_WITH_RSA_ENC;
                   break;
                case HASH_ALGOR_SHA256:
                   abyl_temp_sig_list[++inl_sig_count] = PKCS1_SHA256_WITH_RSA_ENC;
                   break;
                case HASH_ALGOR_SHA384:
                   abyl_temp_sig_list[++inl_sig_count] = PKCS1_SHA384_WITH_RSA_ENC;
                   break;
                case HASH_ALGOR_SHA512:
                   abyl_temp_sig_list[++inl_sig_count] = PKCS1_SHA512_WITH_RSA_ENC;
                   break;
             }
             break;
          case SIG_ALGOR_DSA:
             if(abyp_in_buf[inp_data_offset] == HASH_ALGOR_SHA1){
                abyl_temp_sig_list[++inl_sig_count] = X957_DSA_WITH_SHA1;
                abyl_temp_sig_list[++inl_sig_count] = OIW_DSA_WITH_SHA;
                abyl_temp_sig_list[++inl_sig_count] = OIW_DSA_WITH_SHA1;
                inl_dsa_sig_count = 3;
             }
             break;
       }
       if(inl_sig_count > (SIG_ALGOR_MAX_COUNT-1+inl_dsa_sig_count)){
           // Some sig data was duplicated, count this as error.
           return HSSL_EXT_DUPLICATE_SIG_ALG;
       }
       inp_data_offset +=2;
    }
    abyl_temp_sig_list[0] = (char)inl_sig_count++;
    if(abyl_temp_sig_list[0] != 0){
       aabyp_out_buf[0] = BIT8_ARRAY_ALLOC(HMEM_CTX_REF, (inl_sig_count));
       memcpy(aabyp_out_buf[0]+0,abyl_temp_sig_list+0,inl_sig_count);
    }
    return HSSL_OP_OK;
}
/**
*  Processes the secure renegotiation extension (m_process_sec_renegotiate_ext).
*
*  It extracts the secure renegotiation extension, checks it and writes it to
*  the connection structure.
*
*   @param adsp_connection  Pointer to connection structure of receiving side
*   @param abyp_in_buf      Input buffer, containing the extension data
*   @param inp_ext_len      Length of the extension data
*   @param inp_data_offset  Offset of the input data
*   @param ainp_alert_type  Return parameter for alert type in error case
*
*   @return HSSL_OP_OK on success, error code otherwise
*/
static  int  m_process_sec_renegotiate_ext(HMEM_CTX_DEF 
                                                      CONNSTRU * adsp_connection,
                                                      char* abyp_in_buf, 
                                                      int inp_ext_len,
                                                      int inp_data_offset,
                                                      int* ainp_alert_type)
{
   int Retcode = 0;
   int inl_mode = 1;

   if(adsp_connection->Entity == CLIENT_ENTITY){
      inl_mode = 2;
   }
   Retcode = ExtractRenegotExtension(HMEM_CTX_REF1 adsp_connection,
      abyp_in_buf,inp_data_offset,inp_ext_len);
   if(Retcode != HSSL_OP_OK)
      return(Retcode);

   if(adsp_connection->ConnectionState != CONN_STATE_CONNECTED) // initial hshake
   {
      Retcode = CheckRenegotExtension(adsp_connection,0); // should have none/empty
      if(Retcode >= 0)				// extension is present
      {
         if(Retcode == 0)			// but not empty extension!
         {
            ainp_alert_type[0] = AD_HSHAKE_FAILURE;
            if(inl_mode == 2){
               return(HSSL_SRVR_HELLO_UNSEC_RENEGOT);
            } else {
               return(HSSL_CLNT_HELLO_NO_RENEGOTIATE);
            }
         }
         adsp_connection->SecureRenegotiateFlag = 1; // save state!
      }
   }
   else					// is renegotiation mode
   {
      if(adsp_connection->SecureRenegotiateFlag != 0) // must be secure
      {
         Retcode = CheckRenegotExtension(adsp_connection,inl_mode);
         if(Retcode <= 0)			// extension NOT present/diff.
         {
            ainp_alert_type[0] = AD_HSHAKE_FAILURE;
            if(inl_mode == 2){
               return(HSSL_SRVR_HELLO_UNSEC_RENEGOT);
            } else {
               return(HSSL_CLNT_HELLO_NO_RENEGOTIATE);
            }
         }
      }
   }
   return(HSSL_OP_OK);
}

/**
Clears and frees an SRP parameter structure.

This function can process a null input. All members of the structure are cleared 
and freed, the structure itself is also freed.

@param[in]  adsp_params Pointer to the structure to be freed.
*/
static  void  m_free_srp_struct(HMEM_CTX_DEF SRP_SESSION_PARAMS* adsp_params)
{
   if( NULL == adsp_params ){
      return;
   }

   ClearFreeWLnum(HMEM_CTX_REF1 adsp_params[0].adsc_srv_pub_key);
   ClearFreeWLnum(HMEM_CTX_REF1 adsp_params[0].adsc_cl_pub_key);
   ClearFreeWLnum(HMEM_CTX_REF1 adsp_params[0].adsc_own_priv_key);
   ClearFreeWLnum(HMEM_CTX_REF1 adsp_params[0].adsc_n);
   ClearFreeWLnum(HMEM_CTX_REF1 adsp_params[0].adsc_g);
   ClearFreeWLnum(HMEM_CTX_REF1 adsp_params[0].adsc_verifier);
   ClearFreeBit8Array(HMEM_CTX_REF1 adsp_params[0].achc_salt, adsp_params[0].inc_salt_len);
   ClearFreeBit8Array(HMEM_CTX_REF1 adsp_params[0].achc_cl_name, adsp_params[0].inc_name_len);

   adsp_params[0].adsc_srv_pub_key=NULL;
   adsp_params[0].adsc_cl_pub_key=NULL;
   adsp_params[0].adsc_own_priv_key=NULL;
   adsp_params[0].adsc_n=NULL;
   adsp_params[0].adsc_g=NULL;
   adsp_params[0].adsc_verifier=NULL;
   adsp_params[0].achc_salt = NULL;
   adsp_params[0].achc_cl_name = NULL;

   FREE_CARRAY( HMEM_CTX_REF, adsp_params);

}//void  m_free_srp_struct(HMEM_CTX_DEF SRP_PARAM_PTR adsp_params);

/**
Allocates a new SRP parameter structure in the connection structure, if necessary.

If the connection structure already has a SRP structure, nothing is done. This is 
not considered an error situation. All large number members are initialized.

@param[inout]  adsp_conn   Connection structure in which the SRP structure is initialized.

@return HSSL_OP_OK on success, error code otherwise.
*/
static  int  m_alloc_srp_struct(CONNSTRU * adsp_conn)
{
   HMEM_CTX_DEF1;

   if( NULL != adsp_conn->adsc_srp_params ){
      return (HSSL_OP_OK);
   }

   LOAD_HMEM_CTX_PTR(CONN_pMemCtx(adsp_conn));
   adsp_conn->adsc_srp_params = (SRP_SESSION_PARAMS*)(BIT8_ARRAY_CALLOC(HMEM_CTX_REF,1,
      sizeof(SRP_SESSION_PARAMS)));

   if(NULL == adsp_conn->adsc_srp_params){
      return (HSSL_ALLOC_ERR);
   }

   adsp_conn->adsc_srp_params[0].achc_salt = NULL;
   adsp_conn->adsc_srp_params[0].inc_salt_len = 0;
   adsp_conn->adsc_srp_params[0].adsc_cl_pub_key = AllocNewWLnum(HMEM_CTX_REF1 1);
   adsp_conn->adsc_srp_params[0].adsc_n = AllocNewWLnum(HMEM_CTX_REF1 1);
   adsp_conn->adsc_srp_params[0].adsc_g = AllocNewWLnum(HMEM_CTX_REF1 1);
   adsp_conn->adsc_srp_params[0].adsc_own_priv_key = AllocNewWLnum(HMEM_CTX_REF1 1);
   adsp_conn->adsc_srp_params[0].adsc_srv_pub_key = AllocNewWLnum(HMEM_CTX_REF1 1);
   adsp_conn->adsc_srp_params[0].adsc_verifier = AllocNewWLnum(HMEM_CTX_REF1 1);

   if ( ( NULL == adsp_conn->adsc_srp_params[0].adsc_cl_pub_key) ||
        ( NULL == adsp_conn->adsc_srp_params[0].adsc_n) ||
        ( NULL == adsp_conn->adsc_srp_params[0].adsc_g) ||
        ( NULL == adsp_conn->adsc_srp_params[0].adsc_own_priv_key) ||
        ( NULL == adsp_conn->adsc_srp_params[0].adsc_srv_pub_key) ||
        ( NULL == adsp_conn->adsc_srp_params[0].adsc_verifier))
   {
      m_free_srp_struct(HMEM_CTX_REF1 adsp_conn->adsc_srp_params);
      adsp_conn->adsc_srp_params = NULL;
      return (HSSL_ALLOC_ERR);
   }
   
   return (HSSL_OP_OK);
}//int  m_alloc_srp_struct(CONN_PTR adsp_conn);

/**
Fetches the SRP user name and writes it to the connection structure.

@param[inout]  adsp_conn   Current connection structure.
@return HSSL_OP_OK on success, error code otherwise.
*/
static  int  m_get_srp_name(HMEM_CTX_DEF 
                                       CONNSTRU * adsp_conn)
{
   char* aachl_name_ret[1];
   int inl_name_len = 0;
   int inl_ret =0;

   aachl_name_ret[0]= NULL;

   // if no XH Interface is used, don't fetch name. Should not be possible anyway.
#if XH_INTF_VERSION >= 300
   inl_name_len = adsp_conn->pCfgStruc->amc_get_srp_name(aachl_name_ret,
      HMEM_CTX_REF->am__aux2, HMEM_CTX_REF->vp__context);
#endif
   // Name must be 1-255 byte
   if( 0 >= inl_name_len || 0xff < inl_name_len){
      FREE_ARRAY(HMEM_CTX_REF, aachl_name_ret[0]);
      return (HSSL_PARAM_ERR);
   }

   inl_ret = m_alloc_srp_struct(adsp_conn);

   if( HSSL_OP_OK != inl_ret ){
      FREE_ARRAY(HMEM_CTX_REF, aachl_name_ret[0]);
      return inl_ret;
   }

   adsp_conn->adsc_srp_params[0].achc_cl_name = aachl_name_ret[0];
   adsp_conn->adsc_srp_params[0].inc_name_len = inl_name_len;
   return (HSSL_OP_OK);
}

/**
Clears and releases the content of the SRP password file struct.

The structure itself is not freed.

@param[inout]  adsl_params_struct   Structure to be cleared.
*/
static  void  m_clear_srp_file_param(HMEM_CTX_DEF 
                                                struct tls_srp_pw_file_params* adsl_params_struct)
{
   // no Java version needed, no server SRP for java
   FREE_ARRAY(HMEM_CTX_REF, adsl_params_struct->aucc_g);
   FREE_ARRAY(HMEM_CTX_REF, adsl_params_struct->aucc_n);
   FREE_ARRAY(HMEM_CTX_REF, adsl_params_struct->achc_salt);
   ClearFreeBit8Array(HMEM_CTX_REF1 (char*)(adsl_params_struct->aucc_verifier), 
      (int)(adsl_params_struct->inc_ver_len));
}//void  m_clear_srp_file_params(HMEM_CTX_DEF struct tls_srp_pw_file_params* adsl_params_struct);

/**
Calculates x = SHA1(salt | SHA1(name | ":" | pw)) during SRP handshake.

The buffer for x must be sufficiently large.

@param[in]  abyp_name      Buffer containing the user name.
@param[in]  inp_name_len   Length of the user name.
@param[in]  abyp_password  Buffer containing the password.
@param[in]  inp_pw_len     Length of the password.
@param[in]  abyp_salt      Buffer containing the salt.
@param[in]  inp_salt_len   Length of the salt.
@param[out] abyp_x         Buffer for the result.
*/
static  void  m_srp_calc_x(char* abyp_name,
                                      int inp_name_len,
                                      char* abyp_password,
                                      int inp_pw_len,
                                      char* abyp_salt,
                                      int inp_salt_len,
                                      char* abyp_x)
{
   int ainl_sha_array[SHA_ARRAY_SIZE];

   // Put the ':' in the destination
   abyp_x[0]=0x3a;
   SHA1_Init(ainl_sha_array);
   SHA1_Update(ainl_sha_array,abyp_name,0,inp_name_len);
   SHA1_Update(ainl_sha_array,abyp_x,0,1);
   SHA1_Update(ainl_sha_array,abyp_password,0,inp_pw_len);
   SHA1_Final(ainl_sha_array,abyp_x,0);

   SHA1_Init(ainl_sha_array);
   SHA1_Update(ainl_sha_array,abyp_salt,0,inp_salt_len);
   SHA1_Update(ainl_sha_array,abyp_x,0,SHA_DIGEST_LEN);
   SHA1_Final(ainl_sha_array,abyp_x,0);
   
}//PRIVATE STATIC void  m_srp_calc_x(BIT8PTR abyp_name, int inp_name_len, BIT8PTR abyp_password, int inp_pw_len, BIT8PTR abyp_salt, int inp_salt_len, BIT8PTR abyp_x);

/**
Processes the SRP extension.

If no SRP is configured (no get server param function available), it is just 
ignored. This is considered successfull processing.

Else, the SRP parameters from the server password file are loaded and written
to the connection structure.

@param[in]     abyp_in_buf       Pointer to the data buffer.
@param[in]     inp_data_len      Length of the extension data.
@param[in]     inp_data_offset   Offset of the extension data.
@param[inout]  adsp_con          Pointer to the current connection data.
*/
static  int  m_process_srp_ext(HMEM_CTX_DEF
                                          char* abyp_in_buf, 
                                          int inp_data_len,
                                          int inp_data_offset,
                                          CONNSTRU * adsp_conn)
{
   struct tls_srp_pw_file_params dsl_srp_params;
   int inl_ret = 0;

   if( SERVER_ENTITY != adsp_conn->Entity){
      // only server may receive this extension
      return (HSSL_EXT_BAD_EXT_TYPE);
   }
   if( NULL == adsp_conn->pCfgStruc->amc_get_srp_server_params ){
      // no SRP configured, just ignore this
      return (HSSL_OP_OK);
   }

   // Check, if extension length and name field length match
   if( (inp_data_len-1) != ((((int)abyp_in_buf[inp_data_offset]) )&0xff)){
      return (HSSL_EXT_INCONSISTENT_EXT_DATA);
   }

   inp_data_offset += 1;
   inp_data_len -= 1;

   // Fetch data for the name from file
   memset(&dsl_srp_params,0,sizeof(struct tls_srp_pw_file_params));
#if XH_INTF_VERSION >= 300
   // XH interface version
   inl_ret = adsp_conn->pCfgStruc->amc_get_srp_server_params(abyp_in_buf+inp_data_offset, 
      inp_data_len, &dsl_srp_params, HMEM_CTX_REF->am__aux2, 
      HMEM_CTX_REF->vp__context);
#else
   // Not XH interface, just fail. Code should not be reachable.
   inl_ret = -1;
#endif
   if( 0 != inl_ret ){
      // Name not on file
      m_clear_srp_file_param(HMEM_CTX_REF1 &dsl_srp_params);
      return (HSSL_CLNT_HELLO_SRP_UNK_ID);
   }

   // Setup SRP structure and fill it with data
   inl_ret = m_alloc_srp_struct(adsp_conn);
   if( 0 != inl_ret ){
      m_clear_srp_file_param(HMEM_CTX_REF1 &dsl_srp_params);
      return (HSSL_ALLOC_ERR);
   }

   inl_ret = WLnum_bin2wlnum(HMEM_CTX_REF1 adsp_conn->adsc_srp_params->adsc_n, 
      (char*)dsl_srp_params.aucc_n, 0, dsl_srp_params.inc_n_len);

   inl_ret |= WLnum_bin2wlnum(HMEM_CTX_REF1 adsp_conn->adsc_srp_params->adsc_g, 
      (char*)dsl_srp_params.aucc_g, 0, dsl_srp_params.inc_g_len);

   inl_ret |= WLnum_bin2wlnum(HMEM_CTX_REF1 adsp_conn->adsc_srp_params->adsc_verifier, 
      (char*)dsl_srp_params.aucc_verifier, 0, dsl_srp_params.inc_ver_len);
   if( 0 != inl_ret ){
      m_clear_srp_file_param(HMEM_CTX_REF1 &dsl_srp_params);
      return (HSSL_ALLOC_ERR);
   }

   adsp_conn->adsc_srp_params->achc_salt = dsl_srp_params.achc_salt;
   adsp_conn->adsc_srp_params->inc_salt_len = dsl_srp_params.szc_salt_len;

   // Cleanup
   dsl_srp_params.achc_salt = NULL;
   m_clear_srp_file_param(HMEM_CTX_REF1 &dsl_srp_params);

   return (HSSL_OP_OK);
}//int  m_process_srp_ext(HMEM_CTX_DEF BIT8PTR abyp_in_buf, int inp_data_len, int inp_data_offset, CONN_PTR adsp_conn);

/**
Writes the SRP extension.

This means extension tag, length and content. User name must be set.
This function assumes sufficient buffer length.

@param[out] abyp_dest         Buffer for writing to.
@param[in]  inp_dest_offset   Offset at which to write the extension.
@param[in]  adsp_conn         Current connection structure.

@return >0 Number of bytes written, <0 Error code.
*/
static  int  m_generate_srp_ext(char* abyp_dest, 
                                           int inp_dest_offset,
                                           CONNSTRU * adsp_conn)
{
   // Check, if name has been set propperly
   if( NULL == adsp_conn->adsc_srp_params || 
      NULL == adsp_conn->adsc_srp_params[0].achc_cl_name)
   {
      return (HSSL_PARAM_ERR);
   }

   // Write extensiuon number, length and name field
   BIGword2char(12, abyp_dest, inp_dest_offset);
   BIGword2char(((adsp_conn->adsc_srp_params[0].inc_name_len)+1), abyp_dest, inp_dest_offset);
   abyp_dest[inp_dest_offset] = (char)(adsp_conn->adsc_srp_params[0].inc_name_len);
   inp_dest_offset += 1;

   memcpy(abyp_dest+inp_dest_offset,adsp_conn->adsc_srp_params[0].achc_cl_name+0,adsp_conn->adsc_srp_params[0].inc_name_len);

   return (adsp_conn->adsc_srp_params[0].inc_name_len)+5;
}//int  m_generate_srp_ext(BIT8PTR abyp_dest, int inp_dest_offset, CONN_PTR adsp_conn);

/**
Calculates u=SHA1(PAD(A)|PAD(B)) and writes it to a large number.

This can also be used to calculate k=SHA1(N|PAD(g)).

@param[in]  adsp_a      Pointer to Lnum instance of A.
@param[in]  adsp_b      Pointer to Lnum instance of B.
@param[in]  inp_n_len   Length for the padding function.
@param[out] adsp_u      Pointer to Lnum for writing the result.

@return HSSL_OP_OK on success, error code otherwise.
*/
static  int  m_srp_calc_u(HMEM_CTX_DEF
                                     WLARGENUM* adsp_a,
                                     WLARGENUM* adsp_b,
                                     int inp_n_len,
                                     WLARGENUM* adsp_u)
{
   char* abyl_padded = BIT8_ARRAY_ALLOC(HMEM_CTX_REF,inp_n_len);
   char abyl_u[SHA_DIGEST_LEN];
   int ainl_key_len[1];
   int ainl_sha_array[SHA_ARRAY_SIZE];
   int inl_ret = HSSL_OP_OK;

   if( NULL == abyl_padded){
      return (HSSL_ALLOC_ERR);
   }

   SHA1_Init(ainl_sha_array);

   ainl_key_len[0]= inp_n_len;
   inl_ret = WLnum_wlnum2binFill(abyl_padded,0,ainl_key_len,adsp_a,ainl_key_len[0]);
   if( LNUM_OP_OK != inl_ret){
      return (inl_ret);
   }
   SHA1_Update(ainl_sha_array,abyl_padded,0,inp_n_len);

   ainl_key_len[0]= inp_n_len;
   inl_ret = WLnum_wlnum2binFill(abyl_padded,0,ainl_key_len,adsp_b,ainl_key_len[0]);
   if( LNUM_OP_OK != inl_ret){
      return (inl_ret);
   }
   SHA1_Update(ainl_sha_array,abyl_padded,0,inp_n_len);

   SHA1_Final(ainl_sha_array,abyl_u,0);

   WLnum_bin2wlnum(HMEM_CTX_REF1 adsp_u,abyl_u,0,SHA_DIGEST_LEN);

   FREE_ARRAY(HMEM_CTX_REF, abyl_padded);

   return (HSSL_OP_OK);
}//int  m_srp_calc_u(HMEM_CTX_DEF WLNUM_PTR adsp_a, WLNUM_PTR adsp_b, int inp_n_len, WLNUM_PTR adsp_u);

/**
Performs the actual large number calculations for m_srp_gen_cl_prem_sec.

All large number instances should be cleared after return.
The premaster secret will not be written to the connection struct by this function.

@param[in]  adsp_conn   Pointer to the current connection structure.
@param[in]  adsp_x      Temporary large number used for calculations.
@param[in]  adsp_u      Temporary large number used for calculations.
@param[in]  adsp_k      Temporary large number used for calculations.
@param[out] adsp_res    Large number for taking the premaster secret.

@return 0 on success, error code otherwise.
*/
static  int  m_srp_cl_prem_calcs (HMEM_CTX_DEF
                                             CONNSTRU * adsp_conn,
                                             WLARGENUM* adsp_x, 
                                             WLARGENUM* adsp_u, 
                                             WLARGENUM* adsp_k,
                                             WLARGENUM* adsp_res)
{
   char abyl_pw_ptr[HCU_SRP_PW_LEN];
   char abyl_res_array[SHA_DIGEST_LEN];
   int inl_pw_len = 0;
   int inl_ret = 0;
   int inl_n_len = 0;

   SRP_SESSION_PARAMS* adsl_srp_params = adsp_conn->adsc_srp_params;
   inl_pw_len = adsp_conn->pCfgStruc->amc_get_srp_pw(adsl_srp_params->achc_salt, 
      (size_t)adsl_srp_params->inc_salt_len, abyl_pw_ptr, HCU_SRP_PW_LEN);
   if( 0 >= inl_pw_len ){
      return (HSSL_PARAM_ERR);
   }
   
   // Calcualte x
   m_srp_calc_x(adsl_srp_params[0].achc_cl_name, adsl_srp_params[0].inc_name_len, 
      abyl_pw_ptr, inl_pw_len, adsl_srp_params[0].achc_salt, 
      adsl_srp_params[0].inc_salt_len, abyl_res_array);
   ClearBit8Array(abyl_pw_ptr, HCU_SRP_PW_LEN);
   inl_ret = WLnum_bin2wlnum(HMEM_CTX_REF1 adsp_x,abyl_res_array,0,SHA_DIGEST_LEN);
   ClearBit8Array(abyl_res_array, SHA_DIGEST_LEN);
   if( 0 != inl_ret ){
      return inl_ret;
   }
   
   // generate key pair a and A
   inl_ret = SecDrbgRandBytes(HMEM_CTX_REF1 abyl_pw_ptr,0,HCU_SRP_PW_LEN);
   if( 0 != inl_ret ){
      return inl_ret;
   }

   inl_ret = WLnum_bin2wlnum(HMEM_CTX_REF1 adsl_srp_params[0]. adsc_own_priv_key,abyl_pw_ptr,0,HCU_SRP_PW_LEN);
   ClearBit8Array(abyl_pw_ptr, HCU_SRP_PW_LEN);
   if( 0 != inl_ret ){
      return inl_ret;
   }

   inl_ret = ExpModWLnum(HMEM_CTX_REF1 adsl_srp_params[0].adsc_cl_pub_key,adsl_srp_params[0].adsc_g,adsl_srp_params[0].adsc_own_priv_key,adsl_srp_params[0].adsc_n,NULL,NULL);
   if( 0 != inl_ret ){
      return inl_ret;
   }

   // Calculate the exponent (a+(u*x))
   inl_n_len = GetByteCntWLnum(adsl_srp_params[0].adsc_n);
   inl_ret = m_srp_calc_u(HMEM_CTX_REF1 adsl_srp_params[0].adsc_cl_pub_key, 
      adsl_srp_params[0].adsc_srv_pub_key, inl_n_len, adsp_u);
   if( 0 != inl_ret ){
      return inl_ret;
   }

   inl_ret = MulModWLnum(HMEM_CTX_REF1 adsp_res,adsp_u,adsp_x,adsl_srp_params[0].adsc_n,NULL);
   if( 0 != inl_ret ){
      return inl_ret;
   }

   inl_ret = AddWLnum(HMEM_CTX_REF1 adsp_res,adsp_res,adsl_srp_params[0].adsc_own_priv_key);
   if( 0 != inl_ret ){
      return inl_ret;
   }

   // Calculate (k*(g^x)) mod n
   inl_ret = m_srp_calc_u(HMEM_CTX_REF1 adsl_srp_params[0].adsc_n, 
      adsl_srp_params[0].adsc_g, inl_n_len, adsp_k);
   if( 0 != inl_ret ){
      return inl_ret;
   }
   
   inl_ret = ExpModWLnum(HMEM_CTX_REF1 adsp_u,adsl_srp_params[0].adsc_g,adsp_x,adsl_srp_params[0].adsc_n,NULL,NULL);
   if( 0 != inl_ret ){
      return inl_ret;
   }

   inl_ret = MulModWLnum(HMEM_CTX_REF1 adsp_x,adsp_k,adsp_u,adsl_srp_params[0].adsc_n,NULL);
   if( 0 != inl_ret ){
      return inl_ret;
   }

   // Calculate (B-(k*(g^x))) mod n
   if( 0 >= UcompWLnum(adsl_srp_params[0].adsc_srv_pub_key,adsp_x)){
      // B is smaller, than (k*(g^x)), add n to B
      inl_ret = AddWLnum(HMEM_CTX_REF1 adsp_u,adsl_srp_params[0].adsc_srv_pub_key,adsl_srp_params[0].adsc_n);
   } else {
      inl_ret = CopyWLnum(HMEM_CTX_REF1 adsp_u,adsl_srp_params[0].adsc_srv_pub_key);
   }
   if( 0 != inl_ret ){
      return inl_ret;
   }

   inl_ret = SubWLnum(HMEM_CTX_REF1 adsp_u,adsp_u,adsp_x);
   if( 0 != inl_ret ){
      return inl_ret;
   }

   // calculate the premaster secret
   inl_ret = CopyWLnum(HMEM_CTX_REF1 adsp_x,adsp_res);
   if( 0 != inl_ret ){
      return inl_ret;
   }

   inl_ret = ExpModWLnum(HMEM_CTX_REF1 adsp_res,adsp_u,adsp_x,adsl_srp_params[0].adsc_n,NULL,NULL);

   return inl_ret;
}//PRIVATE STATIC int  m_srp_cl_prem_calcs (SRP_PARAM_PTR adsl_srp_params, WLNUM_PTR adsp_x, WLNUM_PTR adsp_u, WLNUM_PTR adsp_k)

/**
Generestes the key pair and calculates the premaster secret for client side TLS SRP.

Group parameters, server public key and salt must be set.
Premaster secret is written to the connection structure.

@param[inout]  adsp_conn   Pointer to the current connection structure.

@return 0 on success, error code otherwise.
*/
static  int  m_srp_gen_cl_prem_sec(HMEM_CTX_DEF CONNSTRU * adsp_conn)
{
   int inl_ret =0;
   WLARGENUM* adsl_x = NULL;
   WLARGENUM* adsl_u = NULL;
   WLARGENUM* adsl_k = NULL;
   WLARGENUM* adsl_sec = NULL;
   int inrl_prem_sec_size[1];
   char* abyl_premaster_sec = NULL;

   
   adsl_x = AllocNewWLnum(HMEM_CTX_REF1 SHA_DIGEST_LEN/4);
   adsl_u = AllocNewWLnum(HMEM_CTX_REF1 SHA_DIGEST_LEN/4);
   adsl_k = AllocNewWLnum(HMEM_CTX_REF1 SHA_DIGEST_LEN/4);
   adsl_sec = AllocNewWLnum(HMEM_CTX_REF1 SHA_DIGEST_LEN/4);
   if(NULL == adsl_x || NULL == adsl_u || NULL == adsl_k )
   {
      ClearFreeWLnum(HMEM_CTX_REF1 adsl_x);
      ClearFreeWLnum(HMEM_CTX_REF1 adsl_u);
      ClearFreeWLnum(HMEM_CTX_REF1 adsl_k);
      ClearFreeWLnum(HMEM_CTX_REF1 adsl_sec);
      return (HSSL_ALLOC_ERR);
   }

   inl_ret = m_srp_cl_prem_calcs(HMEM_CTX_REF1 adsp_conn, adsl_x, 
      adsl_u, adsl_k, adsl_sec);
   if( 0 == inl_ret ) 
   {
      // write back premaster secret
      inrl_prem_sec_size[0] = GetByteCntWLnum(adsl_sec);

      abyl_premaster_sec = BIT8_ARRAY_ALLOC(HMEM_CTX_REF,inrl_prem_sec_size[0]);

      inl_ret = WLnum_wlnum2bin(abyl_premaster_sec,0,inrl_prem_sec_size,adsl_sec,0);

      adsp_conn->PreMasterSecrPtr = abyl_premaster_sec;
      adsp_conn->PreMasterSecrLen = inrl_prem_sec_size[0];
   }

   ClearFreeWLnum(HMEM_CTX_REF1 adsl_x);
   ClearFreeWLnum(HMEM_CTX_REF1 adsl_u);
   ClearFreeWLnum(HMEM_CTX_REF1 adsl_k);
   ClearFreeWLnum(HMEM_CTX_REF1 adsl_sec);

   return (inl_ret);
}

/**
Reads the SRP parameters from Server Key Exchange and generates all client side
parameters.

Client side parameters are client key pair and premaster secret. Group 
parameters are validated. On validation failure, HSSL_ALERT_MSG_INSUFF_SECURITY 
is returned. If B mod n = 0, HSSL_PARAM_ERR is returned.

@param[in]  abyp_input     Pointer to the buffer containing the data.
@param[in]  inp_in_offset  Offset at which data starts (length field of n).
@param[in]  inp_in_len     Length of the data to be processed.
@param[out] adsp_conn      Connection structure to receive the read and 
                           calculated parameters.

@return HSSL_OP_OK on success, error code otherwise.
*/
static  int  m_process_srp_srv_exch_params(HMEM_CTX_DEF
                                                      char* abyp_input, 
                                                      int inp_in_offset, 
                                                      int inp_in_len,
                                                      CONNSTRU * adsp_conn)
{
   SRP_SESSION_PARAMS* adsl_params = adsp_conn->adsc_srp_params;
   int inl_param_len = 0;
   int inl_ret = 0;
   int inl_n_pos = 0;
   int inl_n_len = 0;

   // Check for minimum length
   if( 11 > inp_in_len ){
      return (HSSL_SRVR_KEYEXC_INVALID_MSG);
   }

   // Read N
   BIGchar2word(abyp_input, inl_n_len, inp_in_offset);
   inp_in_len -= 2;
   if( 0 >= inl_n_len || inp_in_len < inl_n_len ){
      return (HSSL_SRVR_KEYEXC_INVALID_MSG);
   }
   inl_n_pos = inp_in_offset;
   inl_ret = WLnum_bin2wlnum(HMEM_CTX_REF1 adsl_params[0].adsc_n,abyp_input,inp_in_offset,inl_n_len);
   if( (HSSL_OP_OK != inl_ret) ){
      return (inl_ret);
   }
   inp_in_offset += inl_n_len;
   inp_in_len -= inl_n_len;

   // Read g, validate N and g here
   BIGchar2word(abyp_input, inl_param_len, inp_in_offset);
   inp_in_len -= 2;
   if( 0 >= inl_param_len || inp_in_len < inl_param_len ){
      return (HSSL_SRVR_KEYEXC_INVALID_MSG);
   }
   inl_ret = m_validate_group(abyp_input, inl_n_pos, inl_n_len, abyp_input,
      inp_in_offset, inl_param_len);
   if( 0 != inl_ret ){
      return (HSSL_ALERT_MSG_INSUFF_SECURITY);
   }
   inl_ret = WLnum_bin2wlnum(HMEM_CTX_REF1 adsl_params[0].adsc_g,abyp_input,inp_in_offset,inl_param_len);
   if( (HSSL_OP_OK != inl_ret) ){
      return (inl_ret);
   }
   inp_in_offset += inl_param_len;
   inp_in_len -= inl_param_len;

   // Read salt
   inl_param_len = (((int)abyp_input[inp_in_offset])&0xff);
   inp_in_offset++;
   inp_in_len--;
   if( 0 == inl_param_len || inp_in_len < inl_param_len ){
      return (HSSL_SRVR_KEYEXC_INVALID_MSG);
   }
   adsl_params[0].achc_salt = BIT8_ARRAY_ALLOC(HMEM_CTX_REF, inl_param_len);
   if( NULL == adsl_params[0].achc_salt ){
      return (HSSL_ALLOC_ERR);
   }
   memcpy(adsl_params[0].achc_salt+0,abyp_input+inp_in_offset,inl_param_len);
   adsl_params[0].inc_salt_len = inl_param_len;
   inp_in_offset += inl_param_len;
   inp_in_len -= inl_param_len;

   // Read server key B
   BIGchar2word(abyp_input, inl_param_len, inp_in_offset);
   inp_in_len -= 2;
   if( 0 >= inl_param_len || inp_in_len < inl_param_len ){
      return (HSSL_SRVR_KEYEXC_INVALID_MSG);
   }
   inl_ret = WLnum_bin2wlnum(HMEM_CTX_REF1 adsl_params[0].adsc_srv_pub_key,abyp_input,inp_in_offset,inl_param_len);
   if( (HSSL_OP_OK != inl_ret) ){
      return (inl_ret);
   }
   // Check, if B is in valid range
   if( (0 != IsZeroWLnum(adsl_params[0].adsc_srv_pub_key)) || 
      ( 0<=UcompWLnum(adsl_params[0].adsc_srv_pub_key,adsl_params[0].adsc_n) ))
   {
      return (HSSL_PARAM_ERR);
   }

   return m_srp_gen_cl_prem_sec(HMEM_CTX_REF1 adsp_conn);
}//int  m_process_srp_srv_exch_params(HMEM_CTX_DEF BIT8PTR abyp_input, int inp_in_offset, int inp_in_len, CONN_PTR adsp_conn);

static bool m_alpn_well_formed(char* achp_input,
                               unsigned int unp_in_len,
                               bool bop_is_client)
{
    unsigned int unl_ext_len;
    
    BIGchar2wordn(achp_input, unl_ext_len, 0);

    if ((unl_ext_len+2 != unp_in_len) || (unl_ext_len < 2)) {
        return false;
    }

    achp_input += 2;
    if(bop_is_client){
        return (unl_ext_len-1) == (unsigned char)achp_input[0];
    }
    while(unl_ext_len != 0) {
        unsigned int unl_name_size = (unsigned char)achp_input[0];
        unl_name_size++;

        if(unl_name_size > unl_ext_len) {
            return false;
        }
        unl_ext_len -= unl_name_size;
        achp_input += unl_name_size;
    }
    return true;
}

static int m_process_alpn(CONNSTRU* adsp_conn,
                          char* achp_input,
                          int inp_in_len,
                          int* ainp_alert_type)
{
    HMEM_CTX_DEF1;

    LOAD_HMEM_CTX_PTR(CONN_pMemCtx(adsp_conn));

    // Release possible old ALPN selection
    FREE_ARRAY(HMEM_CTX_REF, adsp_conn->achc_selected_alpn);
    adsp_conn->achc_selected_alpn = NULL;

    if(! m_alpn_well_formed(achp_input, inp_in_len, adsp_conn->Entity == CLIENT_ENTITY)) {
        ainp_alert_type[0] = AD_DECODE_ERROR;
        return HSSL_EXT_INCONSISTENT_EXT_DATA;
    }

    if( (adsp_conn->adsc_alpn_cfg == NULL) || 
        (adsp_conn->adsc_alpn_cfg->amc_callback == NULL) )
    {
        // No ALPN configured
        if (adsp_conn->Entity == 0) {
            // Server just continues
            return HSSL_OP_OK;
        } else {
            // Client received ALPN when not sending it
            ainp_alert_type[0] = AD_INTERNAL_ERROR;
            return HSSL_EXT_BAD_EXT_TYPE;
        }
    }

    unsigned int unl_len;
    BIGchar2wordn(achp_input, unl_len, 0);
    achp_input += 2;


    const char* achl_selected = NULL;
    int inl_ret = adsp_conn->adsc_alpn_cfg->amc_callback(&achl_selected,
                                                         adsp_conn->adsc_alpn_cfg->ac_context,
                                                         achp_input,
                                                         unl_len);

    if(inl_ret != 0) {
        // Offered protcols were rejected
        ainp_alert_type[0] = AD_NO_APPL_PROTOCOL;
        return HSSL_EXT_REJECTED;
    }

    if (achl_selected != NULL) {
        unsigned int unl_prot_len = (unsigned char)achl_selected[0];
        unl_prot_len++;
        adsp_conn->achc_selected_alpn = BIT8_ARRAY_ALLOC(HMEM_CTX_REF, unl_prot_len);
        if (adsp_conn->achc_selected_alpn == NULL) {
            ainp_alert_type[0] = AD_INTERNAL_ERROR;
            return HSSL_ALLOC_ERR;
        }
        memcpy(adsp_conn->achc_selected_alpn, achl_selected, unl_prot_len);
    }

    return HSSL_OP_OK;
}

static int m_process_sni_ext(CONNSTRU* adsp_conn,
                             char* achp_input,
                             int inp_in_len,
                             int* ainp_alert_type)
{

    if( adsp_conn->Entity == CLIENT_ENTITY) {
        // Client only makes an alert, if it did not send any SNI
        if( adsp_conn->dsc_ucs_se_host_name.imc_len_str == 0) {
            ainp_alert_type[0] = AD_UNSUP_EXTENSION;
            return HSSL_EXT_BAD_EXT_TYPE;
        }
        return HSSL_OP_OK;
    }

    int inl_ext_len;
    
    BIGchar2wordn(achp_input, inl_ext_len, 0);

    // Check length field
    if ((inl_ext_len+2 != inp_in_len) || (inl_ext_len < 3)) {
        ainp_alert_type[0] = AD_DECODE_ERROR;
        return HSSL_EXT_INCONSISTENT_EXT_DATA;
    }

    achp_input +=2;

    int inl_string_len;
    struct dsd_unicode_string dsl_ucs_host_name;
    dsl_ucs_host_name.ac_str = NULL;

    // Walk over all name entries
    while (inl_ext_len > 0) {
        BIGchar2wordn(achp_input, inl_string_len, 1);
        if(inl_string_len <= 0) {
            ainp_alert_type[0] = AD_DECODE_ERROR;
            return HSSL_EXT_INCONSISTENT_EXT_DATA;
        }
        if(achp_input[0] == TLS_SNI_HOST_NAME_TYPE) {
            if(dsl_ucs_host_name.ac_str != NULL) {
                // Second host name found, this is illegal
                ainp_alert_type[0] = AD_DECODE_ERROR;
                return HSSL_EXT_INCONSISTENT_EXT_DATA;
            }
            dsl_ucs_host_name.ac_str = achp_input+3;
            dsl_ucs_host_name.imc_len_str = inl_string_len;
            dsl_ucs_host_name.iec_chs_str = ied_chs_utf_8;
        }

        achp_input += inl_string_len+3;
        inl_ext_len -= inl_string_len+3;
    }

    if((dsl_ucs_host_name.ac_str != NULL) && (adsp_conn->adsc_sni_cfg != NULL)) {

        // Host name found and SNI is configured
        void* adsl_new_cfg = NULL;
        int inl_ret = adsp_conn->adsc_sni_cfg->amc_callback(&adsl_new_cfg,
                                                            adsp_conn->adsc_sni_cfg->ac_context,
                                                            &dsl_ucs_host_name);

        if (inl_ret != 0) {
            ainp_alert_type[0] = AD_UNREC_NAME;
            return HSSL_EXT_REJECTED;
        }

        if (adsl_new_cfg != NULL){
            // Server provided a new configuration
            inl_ret = m_set_configuration(adsp_conn,
                                          (CFG_STRU*)adsl_new_cfg,
                                          SERVER_ENTITY);
            if (inl_ret != HSSL_OP_OK){
                ainp_alert_type[0] = AD_INTERNAL_ERROR;
                return inl_ret;
            }
        }

        // Store the host name
        inl_ret = m_load_server_host_name(adsp_conn, &dsl_ucs_host_name);
        if (inl_ret != HSSL_OP_OK){
            ainp_alert_type[0] = AD_INTERNAL_ERROR;
            return inl_ret;
        }
    }

    return HSSL_OP_OK;
}

static int ms_process_point_format_ext(CONNSTRU* adsp_connection,
                                       char* abyp_in_buf, 
                                       int inp_ext_len,
                                       int* ainp_alert_type)
{
    if(!adsp_connection->pCfgStruc->boc_ecc_configured){
        if(adsp_connection->Entity == CLIENT_ENTITY) {
            // No ECC configured, server should not send this
            return HSSL_EXT_BAD_EXT_TYPE;
        } else {
            // Server without ECC configured, just ignore
            return HSSL_OP_OK;
        }
    }

    unsigned unl_len = (unsigned char)abyp_in_buf[0];

    if( inp_ext_len-1 != unl_len){
        // Length must match the extension len-1
        return HSSL_EXT_INCONSISTENT_EXT_DATA;
    }

    while(unl_len != 0){
        abyp_in_buf++;
        if(abyp_in_buf[0] == 0){
            adsp_connection->boc_ecc_possible = true;
            return HSSL_OP_OK;
        }
        unl_len--;
    }

    adsp_connection->boc_ecc_possible = false;

    return HSSL_OP_OK;
}

static int ms_process_named_curve_ext(CONNSTRU* adsp_connection,
                                      char* abyp_in_buf, 
                                      int inp_ext_len,
                                      int* ainp_alert_type)
{
    if(!adsp_connection->pCfgStruc->boc_ecc_configured){
        if(adsp_connection->Entity == CLIENT_ENTITY) {
            // No ECC configured, server should not send this
            return HSSL_EXT_BAD_EXT_TYPE;
        } else {
            // Server without ECC configured, just ignore
            return HSSL_OP_OK;
        }
    }

    unsigned unl_length = ((((unsigned)abyp_in_buf[0]) & 0xff) << 8) | 
                           (((unsigned)abyp_in_buf[1]) & 0xff);

    if(((unl_length & 0x01) != 0) || ( inp_ext_len-2 != unl_length)){
        // Length must be even and match the extension len -2
        return HSSL_EXT_INCONSISTENT_EXT_DATA;
    }

    abyp_in_buf += 2;

    while( unl_length != 0){
        if( (abyp_in_buf[0] == 0) &&
            (abyp_in_buf[1] >= ied_ec_curve_secp256k1) &&
            (abyp_in_buf[1] <= ied_ec_curve_brainpoolP512r1))
        {
            // Just select the first matching curve
            adsp_connection->iec_selected_curve = (enum ied_ec_curve_id)abyp_in_buf[1];
            return HSSL_OP_OK;
        }
        unl_length -= 2;
        abyp_in_buf += 2;
    }

    return HSSL_OP_OK;
}

/**
* Processes a block of TLS extensions (m_process_tls_extension).
*
* Takes a block of Hello Extensions, checks for correct length and structure
* and processes known extensions. If a client encounters an unknown extension,
* a fatal unsuported_extension warning is issued. This is correct behaviour,
* as unknown implies, that it hasn't been sent with the Client Hello.
*
* Supported extension types are: <ul>
*  <li> Signature algorithms
*  <li> Secure renegotiation
*</ul>
*   @param abyp_in_buf      Input buffer, containing the extension data
*   @param inp_data_len     Length of the extension data
*   @param inp_data_offset  Offset of the input data
*   @param adsp_connection  Pointer to connection structure of receiving side
*   @param ainp_alert_type  Return parameter for alert type in error case
*   @param ainp_alert_level Return parameter for alert level in error case
*
*   @return HSSL_OP_OK on success, error code otherwise
*/
static  int  m_process_tls_extension( HMEM_CTX_DEF 
                                            char* abyp_in_buf, 
                                            int inp_data_len,
                                            int inp_data_offset,
                                            CONNSTRU * adsp_connection,
                                            int* ainp_alert_type,
                                            int* ainp_alert_level,
                                            int inp_requested_minor_ver)
{
    int inl_remaining_len;
    int inl_data_index = inp_data_offset;
    int inl_extension_type;
    int inl_extension_len;
    int inl_ret = HSSL_OP_OK;
    int ainl_received_extensions[TLS_MAX_EXTENSIONS];
    int inl_ext_count =0;
    int inl_iteration_count;
    
    ainp_alert_level[0] = ALERT_LEVEL_FATAL;
    ainp_alert_type[0] = AD_DECODE_ERROR;
    if( inp_data_len == 0 ){
        return (HSSL_OP_OK);
    }
    /*if(inp_requested_minor_ver == SSL_MINOR_VERSION){
       ainp_alert_type[0] = AD_ILLEGAL_PARAMETER;
       return(HSSL_CLNT_HELLO_INVALID_MSGLEN);
    }*/
    BIGchar2word(abyp_in_buf,inl_remaining_len,inl_data_index);
    
    if( inl_remaining_len+2 != inp_data_len )
        return HSSL_ALERT_MSG_DECODE_ERROR;
    
    while( inl_remaining_len >= 4 ){
        BIGchar2word(abyp_in_buf,inl_extension_type,inl_data_index);
        BIGchar2word(abyp_in_buf,inl_extension_len,inl_data_index);
        inl_remaining_len -= inl_extension_len+4;
        if(inl_remaining_len<0){
            return HSSL_ALERT_MSG_DECODE_ERROR;
        }
        for(inl_iteration_count = 0; inl_iteration_count <inl_ext_count;
           inl_iteration_count++){
              if(ainl_received_extensions[inl_iteration_count] == inl_extension_type){
                 return HSSL_ALERT_MSG_DECODE_ERROR; // same ext used twice
              }
        }
        ainl_received_extensions[inl_ext_count++] =inl_extension_type;
        switch(inl_extension_type){
            case TLS_SIG_ALG_EXT_TYPE:
               if(adsp_connection->Entity == 1){
                  // Unsupported extension on client side
                  ainp_alert_type[0] = AD_UNSUP_EXTENSION;
                  return HSSL_EXT_BAD_EXT_TYPE;
               }
               if(inp_requested_minor_ver == TLS12_MINOR_VERSION){
                  char* aabyl_ret_arr[1];
                  int inl_sig_len = 0;
                  BIGchar2word(abyp_in_buf,inl_sig_len, inl_data_index);
                  if(inl_sig_len != inl_extension_len-2){
                     return HSSL_ALERT_MSG_DECODE_ERROR; // wrong length
                  }
                  aabyl_ret_arr[0] = adsp_connection->abyc_remote_sig_algs;
                  inl_ret = m_process_supported_sig(HMEM_CTX_REF1
                     abyp_in_buf,
                     inl_sig_len,
                     inl_data_index,
                     aabyl_ret_arr
                     );
                  inl_data_index -= 2;
                  if(inl_ret == HSSL_OP_OK) {
                      adsp_connection->abyc_remote_sig_algs = aabyl_ret_arr[0];
                  }
               }
               break;
            case TLS_SECURE_RENEG_EXT_TYPE:
               inl_ret = m_process_sec_renegotiate_ext(HMEM_CTX_REF1 
                  adsp_connection,
                  abyp_in_buf, 
                  inl_extension_len,
                  inl_data_index,
                  ainp_alert_type);
               break;
            case TLS_SRP_EXT_TYPE:
               inl_ret = m_process_srp_ext(HMEM_CTX_REF1 
                  abyp_in_buf, 
                  inl_extension_len,
                  inl_data_index,
                  adsp_connection);
               if( HSSL_CLNT_HELLO_SRP_UNK_ID == inl_ret){
                  ainp_alert_type[0] = AD_UNKN_PSK_ID;
               }
            case TLS_ALPN_EXT_TYPE:
                inl_ret = m_process_alpn(adsp_connection,
                                         abyp_in_buf+inl_data_index,
                                         inl_extension_len,
                                         ainp_alert_type);
                break;
            case TLS_SNI_EXT_TYPE:
                inl_ret = m_process_sni_ext(adsp_connection,
                                            abyp_in_buf+inl_data_index,
                                            inl_extension_len,
                                            ainp_alert_type);
                break;
            case TLS_EC_CURVE_EXT_TYPE:
                inl_ret = ms_process_named_curve_ext(adsp_connection,
                                                     abyp_in_buf+inl_data_index,
                                                     inl_extension_len,
                                                     ainp_alert_type);
                break;
            case TLS_EC_POINT_FORMAT_EXT_TYPE:
                inl_ret = ms_process_point_format_ext(adsp_connection,
                                                      abyp_in_buf+inl_data_index,
                                                      inl_extension_len,
                                                      ainp_alert_type);
                break;
            default:
               if(adsp_connection->Entity == 1){
                  // Unsupported extension on client side
                  ainp_alert_type[0] = AD_UNSUP_EXTENSION;
                  return HSSL_EXT_BAD_EXT_TYPE;
               }
               break;
        }
        if (inl_ret != HSSL_OP_OK) {
            return inl_ret;
        }
        inl_data_index+= inl_extension_len;
    }
    if( inl_remaining_len != 0 ){
        return HSSL_ALERT_MSG_DECODE_ERROR;
    }
    return HSSL_OP_OK;
}

static int m_rsa_sign_old(CONNSTRU * adsp_conn_struc,
                          char* abyp_message_buf,
                          int inp_message_offset,
                          int inp_message_len,
                          char* abyp_dest_buf,
                          int inp_dest_offset,
                          int* ainp_dest_len)
{
    int MD5_Array[MD5_ARRAY_SIZE];
    int SHA1_Array[SHA_ARRAY_SIZE];
    char abyl_hash_buf[MD5_DIGEST_LEN+SHA_DIGEST_LEN];

    // Old RSA signature is over MD5 and SHA1 hashes (See e.g. RFC 2246)
    MD5_Init(MD5_Array);
    MD5_Update(MD5_Array,abyp_message_buf,inp_message_offset,inp_message_len);
    MD5_Final(MD5_Array,abyl_hash_buf,0);
    
    SHA1_Init(SHA1_Array);
    SHA1_Update(SHA1_Array,abyp_message_buf,inp_message_offset,inp_message_len);
    SHA1_Final(SHA1_Array,abyl_hash_buf,MD5_DIGEST_LEN);
    
    // We do private encrypt, padding to full modulus length
    HMEM_CTX_DEF1;
    LOAD_HMEM_CTX_PTR(CONN_pMemCtx(adsp_conn_struc));
    int inl_ret = RSA_PrivateEncryptEx(HMEM_CTX_REF1 
                                       abyl_hash_buf,
                                       MD5_DIGEST_LEN+SHA_DIGEST_LEN,
                                       abyp_dest_buf,
                                       inp_dest_offset+2,
                                       ainp_dest_len,
                                       adsp_conn_struc->pLocalRsaStruc,
                                       -1);
    if(inl_ret != RSA_OP_OK){
        return HSSL_GEN_SRKYEX_SIG_RSAENC_ERR;
    }

    // We check the signature to counter fault based side channels, like Lenstra's CRT attack
    char abyl_decrypted[MD5_DIGEST_LEN+SHA_DIGEST_LEN];
    int ainl_return_len[1];
    ainl_return_len[0] = MD5_DIGEST_LEN+SHA_DIGEST_LEN;
    inl_ret = RSA_PublicDecryptEx(HMEM_CTX_REF1
                                  ainp_dest_len[0],
                                  abyp_dest_buf,
                                  inp_dest_offset+2,
                                  abyl_decrypted,
                                  ainl_return_len,
                                  adsp_conn_struc->pLocalRsaStruc,
                                  0);
    if((inl_ret != RSA_OP_OK) || 
        (const_time_memcmp(abyl_decrypted, abyl_hash_buf, MD5_DIGEST_LEN+SHA_DIGEST_LEN) != 0)){
        return HSSL_GEN_SRKYEX_SIG_RSAENC_ERR;
    }

    BIGword2char(ainp_dest_len[0],abyp_dest_buf,inp_dest_offset);
    ainp_dest_len[0] += 2;

    return inl_ret;
}

/**
*   Generates a signature, encoded according to Minor Version.
*
*   Minor Version, signature algorithm and keys are taken from 
*   adsp_conn_struct.
*
*   Error returns are currently done assuming, this is only called
*   for Server Key signing.
*
*   @param  adsp_conn_struc     Connection structure of this instance.
*   @param  abyp_message_buf    Buffer containing the message to be signed.
*   @param  inp_message_offset  Starting offset of the message.
*   @param  inp_message_len     Length of the message.
*   @param  abyp_dest_buf       Target buffer to write the signature to.
*   @param  inp_dest_offset     Starting offset for writing.
*   @param  ainp_dest_len       Writable length of the target buffer. 
*                               Return written bytes here.
*
*   @return HSSL_OP_OK on success, error code otherwise.
*/
static  int  m_generate_digitally_signed ( CONNSTRU * adsp_conn_struc,
                                                 char* abyp_message_buf,
                                                 int inp_message_offset,
                                                 int inp_message_len,
                                                 char* abyp_dest_buf,
                                                 int inp_dest_offset,
                                                 int* ainp_dest_len) 
{
    int inl_bytes_written =0;
    int inl_ret;
    int inl_hash_type = (adsp_conn_struc->LocalCertPublicAlgor>>8)&0xff;
    int inl_signature_type = (adsp_conn_struc->LocalCertPublicAlgor)&0xff;
    HMEM_CTX_DEF1;

    if(adsp_conn_struc == NULL || abyp_message_buf == NULL ||
       abyp_dest_buf == NULL || ainp_dest_len == NULL)
       return(HSSL_NULL_PTR);
    LOAD_HMEM_CTX_PTR(CONN_pMemCtx(adsp_conn_struc));
    if( adsp_conn_struc->ActualProtocol == TLS_V2_PROT_TYPE ) {
        BIGword2char(adsp_conn_struc->LocalCertPublicAlgor, abyp_dest_buf, 
                     inp_dest_offset);
        inl_bytes_written +=2;
    }
    
  if( inl_signature_type == SIG_ALGOR_RSA && 
        adsp_conn_struc->ActualProtocol != TLS_V2_PROT_TYPE)
  {
    return m_rsa_sign_old(adsp_conn_struc,
                          abyp_message_buf,
                          inp_message_offset,
                          inp_message_len,
                          abyp_dest_buf,
                          inp_dest_offset,
                          ainp_dest_len);
  }
  switch(inl_signature_type) {
    case SIG_ALGOR_RSA:
        inl_ret = RSA_signEx(HMEM_CTX_REF1 inl_hash_type,abyp_message_buf,inp_message_offset,inp_message_len,abyp_dest_buf,inp_dest_offset+2,ainp_dest_len,adsp_conn_struc->pLocalRsaStruc,0,-1);
        if(inl_ret != RSA_OP_OK)
          return(HSSL_GEN_SRKYEX_SIG_RSAENC_ERR);
        break;
    case SIG_ALGOR_DSA:
        inl_ret = DSA_Sign(HMEM_CTX_REF1 abyp_message_buf,inp_message_offset,inp_message_len,abyp_dest_buf,inp_dest_offset+2,ainp_dest_len,adsp_conn_struc->pLocalDsaStruc,NULL,0);
        if(inl_ret != DSA_OP_OK){
          return(HSSL_GEN_SRKYEX_DSA_SIG_GEN_ERR); 
        }
      break;
    default:
      return (HSSL_PARAM_ERR);              
  }
  
  BIGword2char(ainp_dest_len[0],abyp_dest_buf,inp_dest_offset);
  ainp_dest_len[0] += 2+inl_bytes_written;
  return (HSSL_OP_OK);
  
}

/**
*   Verifies a SSL signature.
*
*   Minor Version, signature algorithm and keys are taken from 
*   adsp_conn_struct.
*
*   Error returns are currently done assuming, this is only called
*   for Server Key verification.
*
*   @param  adsp_conn_struc     Connection structure of this instance.
*   @param  abyp_message_buf    Buffer containing the signed message.
*   @param  inp_message_offset  Starting offset of the message.
*   @param  inp_message_len     Length of the message.
*   @param  abyp_sig_buf        Buffer containing the signature to be veryfied.
*   @param  inp_sig_offset      Starting offset of the signature.
*   @param  inp_sig_len         Length of the signature buffer.
*
*   @return HSSL_OP_OK on success or error code.
*/
static  int  m_verify_digitally_signed ( CONNSTRU * adsp_conn_struc,
                                               char* abyp_message_buf,
                                               int inp_message_offset,
                                               int inp_message_len,
                                               char* abyp_sig_buf,
                                               int inp_sig_offset,
                                               int inp_sig_len) 
{
  int inl_hash_type = (adsp_conn_struc->RemoteCertPublicAlgor>>8)&0xff;
  int inl_signature_type = (adsp_conn_struc->RemoteCertPublicAlgor)&0xff;
  int inl_ret=0;
  int ainl_sig_len[1];
  HMEM_CTX_DEF1;
  
  LOAD_HMEM_CTX_PTR(CONN_pMemCtx(adsp_conn_struc));
  if(adsp_conn_struc == NULL || abyp_message_buf == NULL ||
       abyp_sig_buf == NULL)
       return(HSSL_NULL_PTR);
    
  if( inl_signature_type == SIG_ALGOR_RSA && 
        adsp_conn_struc->ActualProtocol != TLS_V2_PROT_TYPE)
  {
    int MD5_Array[MD5_ARRAY_SIZE];
    int SHA1_Array[SHA_ARRAY_SIZE];
    char abyl_hash_buf[MD5_DIGEST_LEN+SHA_DIGEST_LEN];
    char abyl_decrypt_buf[MD5_DIGEST_LEN+SHA_DIGEST_LEN];
    int Flags=0;
    int ainl_decrypt_len[1];
    //------------------------------------------------------
    // RSA, prior TLS 1.2
    //------------------------------------------------------
    MD5_Init(MD5_Array);
    MD5_Update(MD5_Array,abyp_message_buf,inp_message_offset,inp_message_len);
    MD5_Final(MD5_Array,abyl_hash_buf,0);
		
    SHA1_Init(SHA1_Array);
    SHA1_Update(SHA1_Array,abyp_message_buf,inp_message_offset,inp_message_len);
    SHA1_Final(SHA1_Array,abyl_hash_buf,MD5_DIGEST_LEN);
    //--------------------------------------------------
    // Public Decrypt the received signature
    //--------------------------------------------------
    ainl_decrypt_len[0] = MD5_DIGEST_LEN+SHA_DIGEST_LEN;

    if((adsp_conn_struc->ActualProtocol == TLS_V1_PROT_TYPE) ||
       (adsp_conn_struc->ActualProtocol == TLS_V2_PROT_TYPE))
      Flags = 1;			// TLS V1.1, Allow only Blocktype 0x01
    else
      Flags = 0;			// Allow Blocktypes 0x00 and 0x01

    inl_ret = RSA_PublicDecryptEx(HMEM_CTX_REF1 inp_sig_len,abyp_sig_buf,inp_sig_offset,abyl_decrypt_buf,ainl_decrypt_len,adsp_conn_struc->pRemoteRsaStruc,Flags);
    if(inl_ret != RSA_OP_OK)
    {
       return(HSSL_SRVR_KEYEXC_SIG_RSADEC_ERR);
    }
    if(ainl_decrypt_len[0] != (MD5_DIGEST_LEN + SHA_DIGEST_LEN)){
        return(HSSL_SRVR_KEYEXC_SIGNAT_INVALID);
    }
    inl_ret=0;
    for(Flags=0; Flags<(MD5_DIGEST_LEN + SHA_DIGEST_LEN); Flags++){
        inl_ret |= (abyl_decrypt_buf[Flags] ^ abyl_hash_buf[Flags]);
    }
    if(inl_ret == 0){
        return (HSSL_OP_OK);
    } else {
        return(HSSL_SRVR_KEYEXC_SIGNAT_INVALID);
    }
  }
  switch(inl_signature_type) {
    case SIG_ALGOR_RSA:
        ainl_sig_len[0] = inp_sig_len;
        inl_ret = RSA_signEx(HMEM_CTX_REF1 inl_hash_type,abyp_message_buf,inp_message_offset,inp_message_len,abyp_sig_buf,inp_sig_offset,ainl_sig_len,adsp_conn_struc->pRemoteRsaStruc,1,1);
        break;
    case SIG_ALGOR_DSA:
        inl_ret = DSA_Verify(HMEM_CTX_REF1 abyp_message_buf,inp_message_offset,inp_message_len,abyp_sig_buf,inp_sig_offset,inp_sig_len,adsp_conn_struc->pRemoteDsaStruc,0);
        break;
    default:
        return (HSSL_PARAM_ERR);
  }
  
  if(inl_ret ==0){
    return (HSSL_OP_OK);
  } else {
    return(HSSL_SRVR_KEYEXC_SIGNAT_INVALID);
  }
}

/**
*  Filters a list of signature types in internal format.
*
*  All types not in the filter list are removed from the sourcde list.
*  The source list is modified in place. Ordering of the source list may be changed.
*  Both lists are assumed to have no offset.
*  
*  @param abyp_src_sig_list      The list to be filtered.
*  @param abyp_filter_sig_list   The filter list, containing allowed types.
*
*  @return HSSL_OP_OK, if source list still contains signature types, 
*          HSSL_CLNT_HELLO_UNSUP_CIPHSUITE otherwise
*/
static  int  m_filter_sig_list(char* abyp_src_sig_list,
                                          char* abyp_filter_sig_list)
{
   int inl_src_work_index = abyp_src_sig_list[0];
   int inl_filter_work_index;
   for(; inl_src_work_index !=0; inl_src_work_index--){
      for(inl_filter_work_index = abyp_filter_sig_list[0];inl_filter_work_index!=0;
         inl_filter_work_index--){
            if(abyp_src_sig_list[inl_src_work_index] == 
               abyp_filter_sig_list[inl_filter_work_index])
               break;   
      }
      if(inl_filter_work_index == 0){  // Sig type was not in the filter list
         abyp_src_sig_list[inl_src_work_index] = 
             abyp_src_sig_list[static_cast<int>(abyp_src_sig_list[0])];
         abyp_src_sig_list[0]--;
      }
   }
   if(abyp_src_sig_list[0] == 0){ // Source list empty
      return(HSSL_CLNT_HELLO_UNSUP_CIPHSUITE);
   } else {
      return(HSSL_OP_OK);
   }
}

/**
*  Generates the data part (including length) of a signature extension.
*/
static  int  m_generate_sig_extension(char* abyp_src_sig_list,
                                                 char* abyp_dest_buf,
                                                 int inp_dest_offset)
{
   int inl_sig_count = 1;
   int inl_dsa_written = 0;                     // Signal, if DSA-SHA1 has already be written
   int inl_sigs_written = 0;                    // Total number of signature types written
   int inl_write_index = inp_dest_offset+2;     // Write index for destination buffer
   for(;inl_sig_count <= abyp_src_sig_list[0]; inl_sig_count++)
   {
      switch(abyp_src_sig_list[inl_sig_count]){
         case PKCS1_MD5_WITH_RSA_ENC:
            abyp_dest_buf[inl_write_index++] = HASH_ALGOR_MD5;
            abyp_dest_buf[inl_write_index++] = SIG_ALGOR_RSA;
            break;
         case PKCS1_SHA1_WITH_RSA_ENC:
            abyp_dest_buf[inl_write_index++] = HASH_ALGOR_SHA1;
            abyp_dest_buf[inl_write_index++] = SIG_ALGOR_RSA;
            break;
         case PKCS1_SHA256_WITH_RSA_ENC:
            abyp_dest_buf[inl_write_index++] = HASH_ALGOR_SHA256;
            abyp_dest_buf[inl_write_index++] = SIG_ALGOR_RSA;
            break;
         case PKCS1_SHA384_WITH_RSA_ENC:
            abyp_dest_buf[inl_write_index++] = HASH_ALGOR_SHA384;
            abyp_dest_buf[inl_write_index++] = SIG_ALGOR_RSA;
            break;
         case PKCS1_SHA512_WITH_RSA_ENC:
            abyp_dest_buf[inl_write_index++] = HASH_ALGOR_SHA512;
            abyp_dest_buf[inl_write_index++] = SIG_ALGOR_RSA;
            break;
         case X957_DSA_WITH_SHA1:
         case OIW_DSA_WITH_SHA:
         case OIW_DSA_WITH_SHA1:
            if(inl_dsa_written == 0){
               abyp_dest_buf[inl_write_index++] = HASH_ALGOR_SHA1;
               abyp_dest_buf[inl_write_index++] = SIG_ALGOR_DSA;
               inl_dsa_written = 1;
            } else {
               inl_sigs_written--;
            }
            break;
         default:
            return -1;
      }
      inl_sigs_written++;
   }
   BIGword2char((inl_sigs_written*2),abyp_dest_buf,inp_dest_offset);
   return((inl_sigs_written+1)*2);
}

/**
Performs the actual calculations to get the premaster secret on the server side.

The premaster secret will be stored in adsp_res on success. adsp_u will be 
overwritten.

@params[in]    adsp_srp_params   Structure holding the SRP session parameters.
@params[inout] adsp_u            Large number holding parameter u.
@params[out]   adsp_res          Large number for taking the premaster secret.

@return HSSL_OP_OK on succes, error code otherwise.
*/
static  int  m_srp_server_lnum_calcs(HMEM_CTX_DEF
                                                SRP_SESSION_PARAMS* adsp_srp_params,
                                                WLARGENUM* adsp_u,
                                                WLARGENUM* adsp_res)
{
   int inl_ret = 0;

   // Calculate tmp_res=(v^u) % N
   inl_ret = m_exp_mod_blind(HMEM_CTX_REF1 
                             adsp_res, 
                             adsp_srp_params[0].adsc_verifier,
                             adsp_u,
                             adsp_srp_params[0].adsc_n,
                             NULL,
                             (WLNUM_USE_BASE_BLINDING|WLNUM_USE_MOD_BLINDING| WLNUM_USE_EXP_BLINDING),
                             NULL);

   if( 0 != inl_ret ){
      return (HSSL_SRP_PREMASTER_LNUM_ERR);
   }

   // Calculate u=(A*tmp_res) % N
   inl_ret = MulModWLnum(HMEM_CTX_REF1 adsp_u,adsp_srp_params[0].adsc_cl_pub_key,adsp_res,adsp_srp_params[0].adsc_n,NULL);
   if( 0 != inl_ret ){
      return (HSSL_SRP_PREMASTER_LNUM_ERR);
   }

   // Check, if the result is 0, which would imply (A%N) = 0
   if( 0 != IsZeroWLnum(adsp_u) ){
      return (HSSL_SRP_PREMASTER_PARAM_ERR);
   }

   // Calculate tmp_res = (u^b) % N
   inl_ret = m_exp_mod_blind(HMEM_CTX_REF1
                             adsp_res,adsp_u,
                             adsp_srp_params[0].adsc_own_priv_key,
                             adsp_srp_params[0].adsc_n,
                             NULL,
                             (WLNUM_USE_BASE_BLINDING|WLNUM_USE_MOD_BLINDING| WLNUM_USE_EXP_BLINDING),
                             NULL);
   if( 0 != inl_ret ){
      return (HSSL_SRP_PREMASTER_LNUM_ERR);
   }

   return (HSSL_OP_OK);
}//m_srp_server_lnum_calcs(HMEM_CTX_DEF SRP_PARAM_PTR adsp_srp_params, WLNUM_PTR adsp_u, WLNUM_PTR adsp_res);

/**
Calculates the premaster secret for the server during a TLS SRP handshake.

The premaster secret will be stored in the connection structure. The SRP 
parameters in the connection structure will NOT be released by this function.

@param[inout]  adsp_conn            Connection structure, holding various 
                                    parameters and receiving the premaster secret.

@return 0 on success, error code otherwise.
*/
static  int  m_gen_srp_server_premaster_sec(CONNSTRU * adsp_conn)
{
   char* abyl_premaster_sec = NULL;
   int inrl_prem_sec_size[1];
   SRP_SESSION_PARAMS* adsl_param_ptr = adsp_conn->adsc_srp_params;
   int inl_pad_len = GetByteCntWLnum(adsl_param_ptr[0].adsc_n);
   int inl_ret = HSSL_OP_OK;
   WLARGENUM* adsl_u;
   WLARGENUM* adsl_tmp_res;
   HMEM_CTX_DEF1;
   LOAD_HMEM_CTX_PTR(CONN_pMemCtx(adsp_conn));

   adsl_u = AllocNewWLnum(HMEM_CTX_REF1 ((inl_pad_len/4)+1));
   adsl_tmp_res = AllocNewWLnum(HMEM_CTX_REF1 ((inl_pad_len/4)+1));
   
   if( NULL == adsl_u || NULL == adsl_tmp_res ){
      ClearFreeWLnum(HMEM_CTX_REF1 adsl_u);
      ClearFreeWLnum(HMEM_CTX_REF1 adsl_tmp_res);
      return (HSSL_SRP_PREMASTER_ALLOC_ERR);
   }

   inl_ret = m_srp_calc_u(HMEM_CTX_REF1 adsl_param_ptr[0].adsc_cl_pub_key, 
      adsl_param_ptr[0].adsc_srv_pub_key, inl_pad_len, adsl_u);
   if( HSSL_OP_OK != inl_ret ){
      ClearFreeWLnum(HMEM_CTX_REF1 adsl_u);
      ClearFreeWLnum(HMEM_CTX_REF1 adsl_tmp_res);
      return (inl_ret);
   }

   // Calculate the premaster secret
   inl_ret = m_srp_server_lnum_calcs(HMEM_CTX_REF1 adsl_param_ptr,
      adsl_u, adsl_tmp_res);

   if( HSSL_OP_OK != inl_ret ){
      ClearFreeWLnum(HMEM_CTX_REF1 adsl_u);
      ClearFreeWLnum(HMEM_CTX_REF1 adsl_tmp_res);
      return (inl_ret);
   }

   // Write the premaster secret
   inrl_prem_sec_size[0] = GetByteCntWLnum(adsl_tmp_res);

   abyl_premaster_sec = BIT8_ARRAY_ALLOC(HMEM_CTX_REF,inrl_prem_sec_size[0]);

   if( NULL == abyl_premaster_sec ){
      inl_ret = HSSL_SRP_PREMASTER_ALLOC_ERR;
   } else {
      WLnum_wlnum2bin(abyl_premaster_sec,0,inrl_prem_sec_size,adsl_tmp_res,0);

      adsp_conn->PreMasterSecrPtr = abyl_premaster_sec;
      adsp_conn->PreMasterSecrLen = inrl_prem_sec_size[0];
   }

   // Clean up
   ClearFreeWLnum(HMEM_CTX_REF1 adsl_u);
   ClearFreeWLnum(HMEM_CTX_REF1 adsl_tmp_res);

   return (inl_ret);
}//int  m_gen_srp_server_premaster_sec(CONN_PTR adsp_conn);

/**
Generates the server side SRP key pair and stores it in the connection structure.

The parameters from the password file must have been loaded already.

@param[inout]  adsp_conn   Connection structure of the current session.

@return HSSL_OP_OK on success, error code otherwise.
*/
static  int  m_gen_srp_srv_key_pair(CONNSTRU * adsp_conn){
   char abyl_priv_key[32];
   SRP_SESSION_PARAMS* adsl_param_ptr = adsp_conn->adsc_srp_params;
   WLARGENUM* adsl_k = NULL;
   WLARGENUM* adsl_k_v = NULL;
   int inl_n_len = GetByteCntWLnum(adsl_param_ptr[0].adsc_n); 
   int inl_ret = HSSL_OP_OK;
   HMEM_CTX_DEF1;

   LOAD_HMEM_CTX_PTR(CONN_pMemCtx(adsp_conn));

   if( NULL == adsl_param_ptr ){
      // No SRP parameters
      return (HSSL_PARAM_ERR);
   }

   // Allocate temporaries
   adsl_k = AllocNewWLnum(HMEM_CTX_REF1 inl_n_len/4);
   adsl_k_v = AllocNewWLnum(HMEM_CTX_REF1 inl_n_len/4);

   if( NULL == adsl_k || NULL == adsl_k_v ){
      ClearFreeWLnum(HMEM_CTX_REF1 adsl_k);
      ClearFreeWLnum(HMEM_CTX_REF1 adsl_k_v);
      return (HSSL_ALLOC_ERR);
   }
   
   // calculate k*v %N
   inl_ret = m_srp_calc_u(HMEM_CTX_REF1 adsl_param_ptr[0].adsc_n, 
      adsl_param_ptr[0].adsc_g, inl_n_len, adsl_k);
   if( HSSL_OP_OK != inl_ret ) {
      ClearFreeWLnum(HMEM_CTX_REF1 adsl_k);
      ClearFreeWLnum(HMEM_CTX_REF1 adsl_k_v);
      return inl_ret;
   }

   inl_ret = MulModWLnum(HMEM_CTX_REF1 adsl_k_v,adsl_k,adsl_param_ptr[0].adsc_verifier,adsl_param_ptr[0].adsc_n,NULL);
   if( HSSL_OP_OK != inl_ret ) {
      ClearFreeWLnum(HMEM_CTX_REF1 adsl_k);
      ClearFreeWLnum(HMEM_CTX_REF1 adsl_k_v);
      return inl_ret;
   }

   ClearWLnumElements(adsl_param_ptr[0].adsc_srv_pub_key);

   // loop, until a B is found, for which (B%N) != 0. use adsl_k as temporary
   while(0 != IsZeroWLnum(adsl_param_ptr[0].adsc_srv_pub_key)){
      // get b
      inl_ret = SecDrbgRandBytes(HMEM_CTX_REF1 abyl_priv_key,0,32);
      if( 0 != inl_ret){
         break;
      }

      inl_ret = WLnum_bin2wlnum(HMEM_CTX_REF1 adsl_param_ptr[0]. adsc_own_priv_key,abyl_priv_key,0,32);
      if( 0 != inl_ret){
         break;
      }
      
      // calculate B = (k*v+g^b) % N
      inl_ret = ExpModWLnum(HMEM_CTX_REF1 adsl_param_ptr[0]. adsc_srv_pub_key,adsl_param_ptr[0].adsc_g,adsl_param_ptr[0]. adsc_own_priv_key,adsl_param_ptr[0].adsc_n,NULL,NULL);
      if( 0 != inl_ret){
         break;
      }

      inl_ret = AddWLnum(HMEM_CTX_REF1 adsl_k,adsl_param_ptr[0]. adsc_srv_pub_key,adsl_k_v);
      if( 0 != inl_ret){
         break;
      }

      inl_ret = ModWLnum(HMEM_CTX_REF1 adsl_param_ptr[0].adsc_srv_pub_key,adsl_k,adsl_param_ptr[0].adsc_n,NULL);
      if( 0 != inl_ret){
         break;
      }
   }

   ClearBit8Array(abyl_priv_key, 32);
   ClearFreeWLnum(HMEM_CTX_REF1 adsl_k);
   ClearFreeWLnum(HMEM_CTX_REF1 adsl_k_v);
   return inl_ret;
}//int  m_gen_srp_srv_key_pair(CONN_PTR adsp_conn);

/**
Writes the parameters for the SRP Server Key Exchange message.

Writing starts at the specified index.

@param[in]  adsp_conn      Connection structure of the current session.
@param[out] abyp_dest      Buffer to which the message shall be written.
@param[in]  inp_offset     Offset at which writing should start.
@param[in]  inp_dest_len   Length available for writing in the destination.

@return Number of bytes written, <0 on error.
*/
static  int  m_write_srp_server_key(CONNSTRU * adsp_conn, 
                                               char* abyp_dest,
                                               int inp_offset, 
                                               int inp_dest_len)
{
   SRP_SESSION_PARAMS* adsl_param_ptr = adsp_conn->adsc_srp_params;
   int inl_len = GetByteCntWLnum(adsl_param_ptr[0].adsc_n);
   int ainl_dest_len[1];
   int inl_ret = 0;
   int inl_start_offset = inp_offset;

   //write n
   BIGword2char(inl_len, abyp_dest, inp_offset);
   inp_dest_len -=2;
   ainl_dest_len[0] = inp_dest_len;
   inl_ret = WLnum_wlnum2bin(abyp_dest,inp_offset,ainl_dest_len,adsl_param_ptr[0].adsc_n,0);
   if( 0 != inl_ret ){
      return inl_ret;
   }
   inp_offset += ainl_dest_len[0];
   inp_dest_len -= ainl_dest_len[0];

   //write g
   inl_len = GetByteCntWLnum(adsl_param_ptr[0].adsc_g);
   BIGword2char(inl_len, abyp_dest, inp_offset);
   inp_dest_len -=2;
   ainl_dest_len[0] = inp_dest_len;
   inl_ret = WLnum_wlnum2bin(abyp_dest,inp_offset,ainl_dest_len,adsl_param_ptr[0].adsc_g,0);
   if( 0 != inl_ret ){
      return inl_ret;
   }
   inp_offset += ainl_dest_len[0];
   inp_dest_len -= ainl_dest_len[0];

   // write salt
   abyp_dest[inp_offset] = (char)(adsl_param_ptr[0].inc_salt_len);
   inp_offset +=1;
   inp_dest_len-=1;
   memcpy(abyp_dest+inp_offset,adsl_param_ptr[0].achc_salt+0,adsl_param_ptr[0].inc_salt_len);
   inp_offset += adsl_param_ptr[0].inc_salt_len;
   inp_dest_len -= adsl_param_ptr[0].inc_salt_len;

   // write key
   inl_len = GetByteCntWLnum(adsl_param_ptr[0].adsc_srv_pub_key);
   BIGword2char(inl_len, abyp_dest, inp_offset);
   inp_dest_len -=2;
   ainl_dest_len[0] = inp_dest_len;
   inl_ret = WLnum_wlnum2bin(abyp_dest,inp_offset,ainl_dest_len,adsl_param_ptr[0].adsc_srv_pub_key,0);
   if( 0 != inl_ret ){
      return inl_ret;
   }
   inp_offset += ainl_dest_len[0];
   inp_dest_len -= ainl_dest_len[0];

   return inp_offset-inl_start_offset;
}//int  m_write_srp_server_key(CONN_PTR adsp_conn, BIT8PTR abyp_dest, int inp_offset, int inp_dest_len);

/**
* Generates an OCSP structure within the connection structure (AllocInitOcspParamStruct).
* Allocates and initializes OCSP parameter structure if needed,
* presets URLs / Flags from configuration.
* 
*  @param pConnStruc Connection structure 
*  @return  0 on success, else error occured
*/
static  int  AllocInitOcspParamStruct(CONNSTRU * pConnStruc)
{

  HOCSPPAR * pOcspParamStruc;
  CFG_STRU * pCfgStruc;
  HMEM_CTX_DEF1;

  if((pConnStruc == NULL) ||
     ((pCfgStruc = pConnStruc->pCfgStruc) == NULL))
    return(HSSL_NULL_PTR);

  LOAD_HMEM_CTX_PTR(CONN_pMemCtx(pConnStruc));
  //---------------------------------------------------
  // Check if OCSP shall be used
  //---------------------------------------------------
  if((pCfgStruc->ExtConf2Flags & ENABLE_USE_OCSP_BIT_MASK) == 0)
    return(HSSL_OP_OK);
  //-------------------------------------------------------
  // OCSP shall be used, check if an OCSP context is present
  // (XH-Interface only)
  //-------------------------------------------------------
#if defined XH_INTERFACE
  if(CONN_pOcspCtx(pConnStruc) == NULL)
    return(HSSL_NULL_PTR);
#endif // XH_INTERFACE

  if (pConnStruc->pOcspParamStruc != NULL) {
      // Clear the old parameter structure
      FREE_CARRAY(HMEM_CTX_REF,pConnStruc->pOcspParamStruc);
      pConnStruc->pOcspParamStruc = NULL;
  }
  //-------------------------------------------------------
  // Allocate OCSP parameter structure, initialize
  //-------------------------------------------------------
  if((pOcspParamStruc = AllocOcspParamStruc(HMEM_CTX_REF)) == NULL)
    return(HSSL_ALLOC_ERR);

  //-------------------------------------------------------
  // Set up the parameters for processing
  //-------------------------------------------------------
  pOcspParamStruc->pResponderUrls =
    pCfgStruc->pOcspUrlsBuffer;
  pOcspParamStruc->ResponderUrlsOff = 0;
  pOcspParamStruc->ResponderUrlsLen = 
    pCfgStruc->OcspUrlsDataLen;

  pOcspParamStruc->ProcessFlags &=
    ~(OCSP_PROC_FLAG_NO_REQ_NONCE | OCSP_PROC_FLAG_SORT_RESP_DN);

  if((pCfgStruc->ExtConf2Flags & NO_OCSP_NONCE_BIT_MASK) != 0)
  {
    pOcspParamStruc->ProcessFlags |=
      OCSP_PROC_FLAG_NO_REQ_NONCE;
  }

  if((pCfgStruc->ExtConf2Flags & DONT_SORT_RDNS_BIT_MASK) == 0)
  {
    pOcspParamStruc->ProcessFlags |=
      OCSP_PROC_FLAG_SORT_RESP_DN;
  }

#if defined XH_INTERFACE
  pOcspParamStruc->pOcspCtxStruc = CONN_pOcspCtx(pConnStruc);
#endif // XH_INTERFACE

  pConnStruc->pOcspParamStruc = pOcspParamStruc;

  return(HSSL_OP_OK);
}

/**
* Verifies certificate chain using OCSP, if enabled (VerifyChainWithOcsp).
*
* Only some parameters checked !!!
*
*  @param pConnStruc Connection structure
*  @param pCfgStruc Configuration structure
*  @param pCertList Certificate list
*  @param CertCount Number of certificates
*  @param pCertTree Tree structure
*  @param ActCertStatus Current verify status
*  @param pNewCertStatus new (reported) status
*  @param pOcspStatus Ocsp Status-Flags
*  @return Status - 0 on success, else error occured
*/
static  int  VerifyChainWithOcsp(
		CONNSTRU * pConnStruc, CFG_STRU * pCfgStruc,
		X509CERT ** pCertList, int CertCount, CTREESTR * pCertTree,
		int ActCertStatus, int* pNewCertStatus,
		int* pOcspStatus)
{

  int Retcode;
  int OcspStatus;
  HOCSPPAR * pOcspParamStruc;

  if((pConnStruc == NULL ) || (pCfgStruc == NULL) ||
     (pCertList == NULL) || (pCertTree == NULL) ||
     (pNewCertStatus == NULL) || (pOcspStatus == NULL))
    return(HSSL_NULL_PTR);

  //--------------------------------------------------------------
  // set output status same as input status, check if OCSP enabled
  //--------------------------------------------------------------
  pNewCertStatus[0] = ActCertStatus;
  pOcspStatus[0] = 0;
  if((pCfgStruc->ExtConf2Flags & ENABLE_USE_OCSP_BIT_MASK) == 0)
    return(HSSL_OP_OK);

  //--------------------------------------------------------------
  // get OCSP parameter structure, setup
  //--------------------------------------------------------------
  pNewCertStatus[0] |= ASN1_ENDCERT_OCSP_UNKNOWN;

  if((pOcspParamStruc = pConnStruc->pOcspParamStruc) == NULL)
    return(HSSL_NULL_PTR);

  pOcspParamStruc->pCertList  = pCertList;
  pOcspParamStruc->CertsCount = CertCount;
  pOcspParamStruc->pCertTree  = pCertTree;

  pOcspParamStruc->ProcessFlags &= (~OCSP_PROC_FLAG_IGNORE_PROD_AT);

  if((pCfgStruc->ExtConf2Flags & IGNORE_OCSP_PRODUCED_BIT_MASK) != 0)
    pOcspParamStruc->ProcessFlags |= OCSP_PROC_FLAG_IGNORE_PROD_AT;

#if defined XH_INTERFACE
  pOcspParamStruc->pXhConnStrucList = pCfgStruc->pXhConnStrucList;
#endif // XH_INTERFACE

// TEST TEST TEST
//  PRINT("Calling OCSP now...\n");

  Retcode = OcspVerifyCertList(pOcspParamStruc);
  if(Retcode != HOCSP_OP_OK)
    return(Retcode);
  //--------------------------------------------------------------
  // Post-Process OCSP Response...
  //--------------------------------------------------------------
  OcspStatus = pOcspParamStruc->ResponseStatusBits;
  pOcspStatus[0] = OcspStatus;

// TEST TEST TEST

//  PRINT("OCSP Status is: ");
//  PRINT_HEX_BIT32_NL(OcspStatus);

// Q: Should be set additional status bits in the following ???

  //--------------------------------------------------------------
  // check if some response was 'revoked'
  //--------------------------------------------------------------
  if((OcspStatus & OCSP_SRESP_REVOKED_BIT) != 0)
  {
    ActCertStatus |= ASN1_ENDCERT_REVOKED;
    pNewCertStatus[0] = ActCertStatus;
    return(HSSL_OP_OK);
  }
  //--------------------------------------------------------------
  // Check if Status has been retrieved succesfully (trusted) AND
  // no Response status was unknown
  //--------------------------------------------------------------
  if((OcspStatus & OCSP_RELIABILITY_CHECK_MASK2) != 0)
  {
    ActCertStatus |= ASN1_ENDCERT_REVOKSTATE_UNKNOWN;
    pNewCertStatus[0] = ActCertStatus;
    return(HSSL_OP_OK);
  }
  
  //--------------------------------------------------------------
  // Everything is fine (GOOD)...
  //--------------------------------------------------------------
  pNewCertStatus[0] = ActCertStatus;
  return(HSSL_OP_OK);
}

#if !defined XH_INTERFACE		// not needed with alternate
/**
* Gets a connection structure
* for the specified index and increments the lock flag if a
* structure exists (GetConnectStrucAndLock).
*
*  @param SocketID Index to socket array, rel. 1
*  @return Pointer to the connection structure, NULL, if none is found
*/
static CONNSTRU * GetConnectStrucAndLock(int SocketID)
{
  CONNSTRU * pConnStruc;

  GetConnStrucLock();				// acquire the global lock
  //-------------------------------------------------------
  // check if a connection structure exists, global locked!
  //-------------------------------------------------------
  pConnStruc = pConnPtrArray[SocketID-1];// get pointer

  if(pConnStruc != NULL)			// structure is present, lock
  {
    pConnStruc->LockFlag ++;		// for trace purposes
  }
  ReleaseConnStrucLock();			// release the lock
  return(pConnStruc);
}
#endif // !defined XH_INTERFACE

#if !defined XH_INTERFACE		// not needed with alternate
/**
* Releases the lock for
* the specified connect structure (ReleaseConnectStrucLock).
*
* synchronization changed for JAVA / CSHARP
*
*  @param pConnStruc Control Structure
*/
static void ReleaseConnectStrucLock(CONNSTRU * pConnStruc)
{

  GetConnStrucLock();				// acquire the global lock
  //-----------------------------------------------------
  // check if a connection pointer is valid
  //-----------------------------------------------------
  if(pConnStruc != NULL)			// structure is present, unlock
  {
    pConnStruc->LockFlag --;
  }
  ReleaseConnStrucLock();			// release the lock
}
#endif // !defined XH_INTERFACE

/**
* Allocates and initializes a new connection structure (AllocInitNewConnStateStruct).
* All values are set to their default state.
*
*  @return Pointer to the new structure, NULL on alloc failure.
*/
static  CONNSTRU *  AllocInitNewConnStateStruct(HMEM_CTX_DEF1)
{
  CONNSTRU * pConnStruc;
  //---------------------------------------------------
  // Allocate the Structure, defaulting it to 0-values
  //---------------------------------------------------
  pConnStruc = (CONNSTRU *)
    ((void *) BIT8_ARRAY_CALLOC(HMEM_CTX_REF,1,sizeof (CONNSTRU)));
  if(pConnStruc == NULL)
    return(NULL);

#if defined XH_INTERFACE
  //-----------------------------------------------------------
  // 0.1. Save a copy of the Memory helper descriptor Structure
  //-----------------------------------------------------------
  memcpy(&pConnStruc->MemCtxStruc,HMEM_CTX_REF,sizeof(ds__hmem));
  CONN_pMemCtx(pConnStruc) =&pConnStruc->MemCtxStruc;

  //----------------------------------------------------------
  // 0.2. Allocate OCSP Context structure, NOT YET FILLED !!
  //----------------------------------------------------------
  if((CONN_pOcspCtx(pConnStruc) =
        AllocXhOcspStruc(CONN_pMemCtx(pConnStruc))) == NULL)
  {
    FREE_CARRAY(HMEM_CTX_REF,CONN_pMemCtx(pConnStruc));
    FREE_CARRAY(HMEM_CTX_REF,pConnStruc);
    return(NULL);
  }
#endif // XH_INTERFACE

  //-------------------------------------------------
  // Initialize non-0 values
  //-------------------------------------------------
  pConnStruc->ConnectionState		= CONN_STATE_NOT_INITIALIZED;

  pConnStruc->ServerPort		= -1;	// none present

  pConnStruc->Entity		= (char) -1; // none yet

  pConnStruc->ActualComprMethod	= (char) -1;	// none
  pConnStruc->ActualCipherSuite		= -1;	// none	

  pConnStruc->LocalCertPublicAlgor	= INVALID_ALGOR;// no public algor
  pConnStruc->LocalCNIndex		= -1;		// no End Certificate

  pConnStruc->CipherType		= (char) ALGOR_TYPE_UNKNOWN;

  pConnStruc->IsExportable		= (char) -1;		// unknown
  pConnStruc->TxFragmentType		= (char) -1;	// invalid

  pConnStruc->adsc_srp_params = NULL;
  pConnStruc->adsc_alpn_cfg = NULL;
  pConnStruc->achc_selected_alpn = NULL;
  
  pConnStruc->boc_ecc_possible = false;
  pConnStruc->iec_selected_curve = ied_ec_curve_none;

  memset(pConnStruc->usrc_expected_handshake_messages, 
         0, 
         sizeof(pConnStruc->usrc_expected_handshake_messages));

  pConnStruc->dsc_mem_mgr.amc_malloc = ms_malloc_hmem;
  pConnStruc->dsc_mem_mgr.amc_free = ms_free_hmem;
  pConnStruc->dsc_mem_mgr.avoc_context = ms_get_mem_ptr(pConnStruc);

  return(pConnStruc);
}
/**
* Frees all elements in the application and priority transmit queues (PurgeTxQueues).
*
*  @param pConnStruc Connection structure containing the target queue
*/
static   void  PurgeTxQueues(CONNSTRU * pConnStruc)
{
  TX_QEL * pActTxQueue;
  TX_QEL * pNextTxQueue;
  HMEM_CTX_DEF1;

  if(pConnStruc == NULL)
    return;

  LOAD_HMEM_CTX_PTR(CONN_pMemCtx(pConnStruc));
  //---------------------------------------------
  // Flush Application transmit Queue
  //---------------------------------------------
  pActTxQueue = pConnStruc->pApplicationTxQueueHead;
  if(pActTxQueue != NULL)
  {
    for(;;)
    {
      FREE_ARRAY_POOL(HMEM_CTX_REF,pActTxQueue->pBuf);
      pNextTxQueue = pActTxQueue->pNextTxQel;
      FREE_ARRAY(HMEM_CTX_REF, pActTxQueue);
      if(pNextTxQueue == NULL)
        break;
      pActTxQueue = pNextTxQueue;
    }
    pConnStruc->pApplicationTxQueueHead = NULL;
    pConnStruc->pApplicationTxQueueTail = NULL;
  }
  //---------------------------------------------
  // Flush Priority transmit Queue
  //---------------------------------------------
  pActTxQueue = pConnStruc->pPriorityTxQueueHead;
  if(pActTxQueue != NULL)
  {
    for(;;)
    {
      FREE_ARRAY_POOL(HMEM_CTX_REF,pActTxQueue->pBuf);
      pNextTxQueue = pActTxQueue->pNextTxQel;
      FREE_ARRAY(HMEM_CTX_REF,pActTxQueue);
      if(pNextTxQueue == NULL)
        break;
      pActTxQueue = pNextTxQueue;
    }
    pConnStruc->pPriorityTxQueueHead = NULL;
    pConnStruc->pPriorityTxQueueTail = NULL;
  }
}
/**
* Frees all elements in the application receive queue (PurgeRxQueues).
*
*  @param pConnStruc Connection structure containing the target queue
*/
static   void  PurgeRxQueues(CONNSTRU * pConnStruc)
{
  RX_QEL * pActRxQueue;
  RX_QEL * pNextRxQueue;
  HMEM_CTX_DEF1;

  if(pConnStruc == NULL)
    return;

  LOAD_HMEM_CTX_PTR(CONN_pMemCtx(pConnStruc));
  //---------------------------------------------
  // Flush Application receive Queue
  //---------------------------------------------
  pActRxQueue = pConnStruc->pApplicationRxQueueHead;
  if(pActRxQueue != NULL)
  {
    for(;;)
    {
      FREE_ARRAY_POOL(HMEM_CTX_REF,pActRxQueue->pBuf);
      pNextRxQueue = pActRxQueue->pNextRxQel;
      FREE_ARRAY(HMEM_CTX_REF,pActRxQueue);
      if(pNextRxQueue == NULL)
        break;
      pActRxQueue = pNextRxQueue;
    }
    pConnStruc->pApplicationRxQueueHead = NULL;
    pConnStruc->pApplicationRxQueueTail = NULL;
  }
}

/**
* Frees a connection structure and its allocated substructures and queues (FreeConnStateStruct).
*
* Cryptographic secret data is cleared before being freed.
* 
*  @param pConnStruc Structure base
*/
static  void  FreeConnStateStruct(CONNSTRU * pConnStruc)
{
 
  DCDR* pCdr;

  HMEM_CTX_DEF1;

  LOAD_HMEM_CTX_PTR(CONN_pMemCtx(pConnStruc));

  //--------------------------------------------------------
  // 0. Unload PKCS11 library if used
  //--------------------------------------------------------
#if (defined _WIN32) && defined PKCS11
  m_pkcs11certcleanup(HMEM_CTX_REF1 pConnStruc);
#endif // defined _WIN32

  //--------------------------------------------------------
  // 1.1. Clear Server/Client Hello Randoms if required
  //--------------------------------------------------------
  ClearBit8Array(pConnStruc->ServerRandom,SERVER_HELLO_RANDOM_LEN);
  ClearBit8Array(pConnStruc->ClientRandom,CLIENT_HELLO_RANDOM_LEN);
  //--------------------------------------------------------
  // 1.2. Free Compression method/Cipher Suites Request lists
  // do  n o t  free, as they are only a copy !!!
  //--------------------------------------------------------
////  FREE_ARRAY(CONN_pReqCmprList(pConnStruc));
////  FREE_ARRAY(CONN_pReqCiphList(pConnStruc));
  //--------------------------------------------------------
  // 1.3. Clear/Free Pre-Master secret, Clear Master Secret
  //--------------------------------------------------------
  ClearBit8Array(pConnStruc->PreMasterSecrPtr,
		 pConnStruc->PreMasterSecrLen);
  FREE_ARRAY(HMEM_CTX_REF,pConnStruc->PreMasterSecrPtr);
  ClearBit8Array(pConnStruc->MasterSecret,MASTER_SECRET_LEN);
  //-----------------------------------------------------------
  // 1.4. Clear actual/pending server/client secret, key and IV
  //-----------------------------------------------------------
  ClearBit8Array(pConnStruc->ActRX_MACSecret,MAX_MAC_SECRET_LEN);
  ClearBit8Array(pConnStruc->ActTX_MACSecret,MAX_MAC_SECRET_LEN);
  ClearBit8Array(pConnStruc->PendRX_MACSecret,MAX_MAC_SECRET_LEN);
  ClearBit8Array(pConnStruc->PendTX_MACSecret,MAX_MAC_SECRET_LEN);

  ClearBit8Array(pConnStruc->ActRX_Key,MAX_WRITE_KEY_LEN);
  ClearBit8Array(pConnStruc->ActTX_Key,MAX_WRITE_KEY_LEN);
  ClearBit8Array(pConnStruc->PendRX_Key,MAX_WRITE_KEY_LEN);
  ClearBit8Array(pConnStruc->PendTX_Key,MAX_WRITE_KEY_LEN);

  ClearBit8Array(pConnStruc->ActRX_IV,MAX_IV_LEN);
  ClearBit8Array(pConnStruc->ActTX_IV,MAX_IV_LEN);
  ClearBit8Array(pConnStruc->PendRX_IV,MAX_IV_LEN);
  ClearBit8Array(pConnStruc->PendTX_IV,MAX_IV_LEN);
  //--------------------------------------------------------
  // 1.5. Clear Sequence numbers if required
  //--------------------------------------------------------
  ClearBit8Array(pConnStruc->ActRX_SeqNumber,SEQUENCE_NUM_LEN);
  ClearBit8Array(pConnStruc->ActTX_SeqNumber,SEQUENCE_NUM_LEN);
  ClearBit32Array(pConnStruc->HandshakeMD5_State,MD5_ARRAY_SIZE);
  ClearBit32Array(pConnStruc->HandshakeSHA1_State,SHA_ARRAY_SIZE);
  ClearBit32Array(pConnStruc->HandshakeSHA256_State,SHA256_ARRAY_SIZE);
  ClearBit64Array(pConnStruc->HandshakeSHA384_State,SHA384_ARRAY_SIZE);
  ClearBit64Array(pConnStruc->HandshakeSHA512_State,SHA512_ARRAY_SIZE);
  //--------------------------------------------------------
  // 1.6. Clear/Free the key exchange RSA/DSA/DH-Structures
  //--------------------------------------------------------
  RSA_Free(HMEM_CTX_REF1 pConnStruc->pRemoteRsaStruc);
  RSA_Free(HMEM_CTX_REF1 pConnStruc->pLocalRsaStruc);
  DSA_Free(HMEM_CTX_REF1 pConnStruc->pRemoteDsaStruc);
  DSA_Free(HMEM_CTX_REF1 pConnStruc->pLocalDsaStruc);
  DH_Free(HMEM_CTX_REF1 pConnStruc->pRemoteDhStruc);
  DH_Free(HMEM_CTX_REF1 pConnStruc->pLocalDhStruc);

  RSA_Free(HMEM_CTX_REF1 pConnStruc->pTmpRsaStruc);
  DH_Free(HMEM_CTX_REF1 pConnStruc->pTmpDhStruc);

  FREE_ARRAY(HMEM_CTX_REF,pConnStruc->abyc_remote_sig_algs);
  
  pConnStruc->pRemoteRsaStruc		= NULL;
  pConnStruc->pLocalRsaStruc		= NULL;
  pConnStruc->pRemoteDsaStruc		= NULL;
  pConnStruc->pLocalDsaStruc		= NULL;
  pConnStruc->pRemoteDhStruc		= NULL;
  pConnStruc->pLocalDhStruc		= NULL;

  pConnStruc->pTmpRsaStruc		= NULL;
  pConnStruc->pTmpDhStruc		= NULL;

  //--------------------------------------------------------
  // 2.1. Clear Allocated Cipher States and the MAC States
  // checking for NULL pointers is done in the subroutines/
  // ----- Macros
  //--------------------------------------------------------
  ClearBit8Array(pConnStruc->ActRX_RC4StateArrayPtr,RC4_STATE_SIZE);
  ClearBit8Array(pConnStruc->ActTX_RC4StateArrayPtr,RC4_STATE_SIZE);

  ClearBit16Array(pConnStruc->ActRX_RC2KeyArrayPtr,RC2_MAX_KEY_WORDS);
  ClearBit16Array(pConnStruc->ActTX_RC2KeyArrayPtr,RC2_MAX_KEY_WORDS);

  ClearBit32Array(pConnStruc->ActRX_DESSubkey1TabPtr,
                  DES_SUBKEY_ARRAY_SIZE);
  ClearBit32Array(pConnStruc->ActRX_DESSubkey2TabPtr,
                  DES_SUBKEY_ARRAY_SIZE);
  ClearBit32Array(pConnStruc->ActRX_DESSubkey3TabPtr,
                  DES_SUBKEY_ARRAY_SIZE);
  ClearBit32Array(pConnStruc->ActRX_AESKeyArrayPtr,
		  AES_KEY_ARRAY_SIZE_BIT32);
  ClearBit8Array((char*)pConnStruc->adsc_recv_gcm_state, 
                 sizeof(struct dsd_aes_gcm_state));

  ClearBit32Array(pConnStruc->ActTX_DESSubkey1TabPtr,
                  DES_SUBKEY_ARRAY_SIZE);
  ClearBit32Array(pConnStruc->ActTX_DESSubkey2TabPtr,
                  DES_SUBKEY_ARRAY_SIZE);
  ClearBit32Array(pConnStruc->ActTX_DESSubkey3TabPtr,
                  DES_SUBKEY_ARRAY_SIZE);
  ClearBit32Array(pConnStruc->ActTX_AESKeyArrayPtr,
		  pConnStruc->KeyLen + 28);
  ClearBit8Array((char*)pConnStruc->adsc_send_gcm_state, 
                 sizeof(struct dsd_aes_gcm_state));

  ClearBit32Array(pConnStruc->ActRX_MAC_I_Array,MAX_MD5_SHA1_STATE_SIZE);
  ClearBit32Array(pConnStruc->ActRX_MAC_O_Array,MAX_MD5_SHA1_STATE_SIZE);
  ClearBit32Array(pConnStruc->ActTX_MAC_I_Array,MAX_MD5_SHA1_STATE_SIZE);
  ClearBit32Array(pConnStruc->ActTX_MAC_O_Array,MAX_MD5_SHA1_STATE_SIZE);

  //--------------------------------------------------------
  // 2.2. free allocated Cipher States, compression buffers
  //--------------------------------------------------------
  FREE_ARRAY(HMEM_CTX_REF,pConnStruc->ActRX_RC4StateArrayPtr);
  FREE_ARRAY(HMEM_CTX_REF,pConnStruc->ActTX_RC4StateArrayPtr);

  FREE_ARRAY(HMEM_CTX_REF,pConnStruc->ActRX_RC2KeyArrayPtr);
  FREE_ARRAY(HMEM_CTX_REF,pConnStruc->ActTX_RC2KeyArrayPtr);

  FREE_ARRAY(HMEM_CTX_REF,pConnStruc->ActRX_DESSubkey1TabPtr);
  FREE_ARRAY(HMEM_CTX_REF,pConnStruc->ActRX_DESSubkey2TabPtr);
  FREE_ARRAY(HMEM_CTX_REF,pConnStruc->ActRX_DESSubkey3TabPtr);
  FREE_ARRAY(HMEM_CTX_REF,pConnStruc->ActRX_AESKeyArrayPtrRaw);
  FREE_ARRAY(HMEM_CTX_REF,pConnStruc->avoc_recv_gcm_base);

  FREE_ARRAY(HMEM_CTX_REF,pConnStruc->ActTX_DESSubkey1TabPtr);
  FREE_ARRAY(HMEM_CTX_REF,pConnStruc->ActTX_DESSubkey2TabPtr);
  FREE_ARRAY(HMEM_CTX_REF,pConnStruc->ActTX_DESSubkey3TabPtr);
  FREE_ARRAY(HMEM_CTX_REF,pConnStruc->ActTX_AESKeyArrayPtrRaw);
  FREE_ARRAY(HMEM_CTX_REF,pConnStruc->avoc_send_gcm_base);

// Before freeing the both V42 bis structs, dealloc helper buffer !!

  //---------------------------------------------
  // Free V42 Compression structures
  //---------------------------------------------
  pCdr = pConnStruc->ActRX_V42BisCdrPtr;
  if(pCdr != NULL)
  {
    pCdr->ifunc = DEF_IFUNC_END;
    CdrDec(HMEM_CTX_REF1 pCdr);
    FREE_ARRAY(HMEM_CTX_REF,pConnStruc->ActRX_V42BisCdrPtr);
  }
  pCdr = pConnStruc->ActTX_V42BisCdrPtr;
  if(pCdr != NULL)
  {
    pCdr->ifunc = DEF_IFUNC_END;
    CdrEnc(HMEM_CTX_REF1 pCdr);
    FREE_ARRAY(HMEM_CTX_REF,pConnStruc->ActTX_V42BisCdrPtr);
  }
  //---------------------------------------------
  // Free Partner Name Buffer
  //---------------------------------------------
  FREE_ARRAY(HMEM_CTX_REF,pConnStruc->pPartnerName);
  FREE_ARRAY(HMEM_CTX_REF,pConnStruc->pPartnerCert);

  //------------------------------------------------------------
  // 3.1. free allocated Data assemble buffers
  //------------------------------------------------------------
  FREE_ARRAY_POOL(HMEM_CTX_REF,pConnStruc->pRxFragmentBuffer);
  FREE_ARRAY_POOL(HMEM_CTX_REF,pConnStruc->pHandshake_RxMsgDataBuffer);
  //------------------------------------------------------------
  // 3.2. free Send Buffer and flush the send queues
  //------------------------------------------------------------
  FREE_ARRAY_POOL(HMEM_CTX_REF,pConnStruc->pTxFragmentBuffer);
  PurgeTxQueues(pConnStruc);
  //------------------------------------------------------------
  // 3.3. flush the receive queue
  //------------------------------------------------------------
  PurgeRxQueues(pConnStruc);

  //------------------------------------------------------------
  // 3.4. free OCSP parameter structure etc.
  //------------------------------------------------------------
  FREE_CARRAY(HMEM_CTX_REF,pConnStruc->pOcspParamStruc);

  FREE_CARRAY(HMEM_CTX_REF,pConnStruc->pHandshakeRenegotExt);

  FREE_LOG(HMEM_CTX_REF,pConnStruc->adsc_logger);
#if defined XH_INTERFACE
  pConnStruc->adsc_logger =NULL;
  //------------------------------------------------------------
  // Free the helper structures
  //------------------------------------------------------------
  FreeXhOcspStruc(CONN_pOcspCtx(pConnStruc));	// discard OCSP structure
  CONN_pOcspCtx(pConnStruc) = NULL;
#endif // XH_INTERFACE

  // Free the SRP structure
  m_free_srp_struct( HMEM_CTX_REF1 pConnStruc->adsc_srp_params);
  pConnStruc->adsc_srp_params=NULL;

  FREE_ARRAY(HMEM_CTX_REF,pConnStruc->achc_selected_alpn);
  pConnStruc->achc_selected_alpn = NULL;

  FREE_ARRAY(HMEM_CTX_REF, pConnStruc->dsc_ucs_se_host_name.ac_str);
  pConnStruc->dsc_ucs_se_host_name.ac_str = NULL;

  m_ecc_free_keypair(&pConnStruc->dsc_mem_mgr, &pConnStruc->dsc_ecc_keypair);
  m_mem_pool_free(&pConnStruc->dsc_mem_mgr, pConnStruc->adsc_mem_pool);
  pConnStruc->adsc_mem_pool = NULL;

}

/**
* Frees a configuration structure and the embedded data buffers (FreeCfgStruct).
*
*  @param pCfgStruc Pointer to configuration structure
*/
extern "C"  void FreeCfgStruct(HMEM_CTX_DEF
				 CFG_STRU * pCfgStruc)
{
#if defined XH_INTERFACE
  ds__hmem TmpMemCtxStruc;
#endif

  if(pCfgStruc == NULL)
    return;

#if defined XH_INTERFACE
  memcpy(&TmpMemCtxStruc,&pCfgStruc->CfgMemCtxStruc,sizeof(ds__hmem));
  if(pCfgStruc->pCfgMemCtx != NULL)
  {
    vp__ctx = &TmpMemCtxStruc;
    ((ds__hmem *) vp__ctx)->in__flags &= (~HMEM_LOCKED_STRUC_FLAG_BIT);	// unlock !
  }

#endif

  //--------------------------------------------------------------
  // Free PKCS11 DLL-Namebuffer if in use
  //--------------------------------------------------------------
#if (defined _WIN32) && defined PKCS11
  if(pCfgStruc->ach_pkcs11dllname != NULL)
  {
    FREE_ARRAY(HMEM_CTX_REF,pCfgStruc->ach_pkcs11dllname);
    pCfgStruc->ach_pkcs11dllname = NULL;
  }
#endif // defined _WIN32

  //--------------------------------------------------------------
  // Free Certificate Tree, Root RDN and Subject Common Names List
  //--------------------------------------------------------------
  FreeCertTreeStruc(HMEM_CTX_REF1 pCfgStruc->pCertTreeStruc);
  FreeIDATPARR_Struc(HMEM_CTX_REF1 pCfgStruc->pRootRdnArray);
  FREE_ARRAY(HMEM_CTX_REF,pCfgStruc->SubjCNamesListPtr);
  FreeExtCertStruc(HMEM_CTX_REF1 pCfgStruc->pExtCertStruc);// NEW NEW !
  FREE_ARRAY(HMEM_CTX_REF,pCfgStruc->pExtConfigData);
  FREE_ARRAY(HMEM_CTX_REF,pCfgStruc->pOcspUrlsBuffer);
  FREE_ARRAY(HMEM_CTX_REF,pCfgStruc->CipherSuitesList);
  
  FREE_ARRAY(HMEM_CTX_REF,pCfgStruc);		// free the structure itself

  MEMMGR_FREE(HMEM_CTX_REF);			// release management structs
}

#if defined XH_INTERFACE		// used for alternate interface only
#if XH_INTF_VERSION < 300
/**
* Frees all connection state
* structures and its allocated substructures and queues for
* the XH Server alternate interface (FreeXH2ConnStateStruct).
* 
*  @param pXif2Struc Structure base
*/
static void  FreeXH2ConnStateStruct(HMEM_CTX_DEF
					 struct dsd_hl_ssl_s_2 * pXif2Struc)
{

  ds__hmem LclMemCtxStruc;		// needed !!!

  CONNSTRU * pConnStruc;
  XHCONNSTRUC * XHConnData;
  //--------------------------------------------------
  // Check if private data structure is present at all
  //--------------------------------------------------
  if(pXif2Struc == NULL)			// nothing set, ignore
    return;
  XHConnData = (XHCONNSTRUC *) pXif2Struc->ac_ext; // get pointer to private structure
  if(XHConnData == NULL)
      return;
  //--------------------------------------------------
  // Assure that memory helper is kept alive !!!
  //--------------------------------------------------
  memcpy(&LclMemCtxStruc,vp__ctx,sizeof(ds__hmem));

  LOAD_HMEM_CTX_PTR(&LclMemCtxStruc);	// now we use local copy !!!
  //----------------------------------------------------
  // Free the connection structure and its substructures
  //----------------------------------------------------
  pConnStruc = XHConnData->pConnStruc;	// get connection struct. ptr
  if(pConnStruc != NULL)
  {
    FreeConnStateStruct(pConnStruc);	  // free connection data
    FREE_ARRAY(HMEM_CTX_REF,pConnStruc); // free the structure itself
  }
  FREE_ARRAY(HMEM_CTX_REF,XHConnData);	// free private structure
  pXif2Struc->ac_ext = NULL;		// invalidate

  MEMMGR_FREE(HMEM_CTX_REF);

}
#endif // XH_INTF_VERSION < 300

#if XH_INTF_VERSION >= 300
/**
* Frees all connection state
* structures and its allocated substructures and queues for
* the XH Server alternate interface (FreeXH3ConnStateStruct).
* 
*  @param pXif3Struc Structure base
*/
static void  FreeXH3ConnStateStruct(HMEM_CTX_DEF
					 struct dsd_hl_ssl_s_3 * pXif3Struc)
{

  ds__hmem LclMemCtxStruc;		// needed !!!

  CONNSTRU * pConnStruc;
  XHCONNSTRUC * XHConnData;
  //--------------------------------------------------
  // Check if private data structure is present at all
  //--------------------------------------------------
  if(pXif3Struc == NULL)			// nothing set, ignore
    return;
  XHConnData = (XHCONNSTRUC *) pXif3Struc->ac_ext; // get pointer to private structure
  if(XHConnData == NULL)
      return;
  //--------------------------------------------------
  // Assure that memory helper is kept alive !!!
  //--------------------------------------------------
  memcpy(&LclMemCtxStruc,vp__ctx,sizeof(ds__hmem));

  LOAD_HMEM_CTX_PTR(&LclMemCtxStruc);	// now we use local copy !!!
  //----------------------------------------------------
  // Free the connection structure and its substructures
  //----------------------------------------------------
  pConnStruc = XHConnData->pConnStruc;	// get connection struct. ptr
  if(pConnStruc != NULL)
  {
    FreeConnStateStruct(pConnStruc);	  // free connection data
    FREE_ARRAY(HMEM_CTX_REF,pConnStruc); // free the structure itself
    XHConnData->pConnStruc = NULL;
  }
  FREE_ARRAY(HMEM_CTX_REF,XHConnData);	// free private structure
  pXif3Struc->ac_ext = NULL;		// invalidate

  MEMMGR_FREE(HMEM_CTX_REF);

}
#endif // XH_INTF_VERSION >= 300

/**
* Frees all connection state
* structures and its allocated substructures and queues for
* the XH Server alternate interface, client side (FreeXHCLConnStateStruct).
* 
*  @param pXifClStruc Structure base
*/
static void  FreeXHCLConnStateStruct(HMEM_CTX_DEF
					 struct dsd_hl_ssl_c_1 * pXifClStruc)
{

  ds__hmem LclMemCtxStruc;		// needed !!!

  CONNSTRU * pConnStruc;
  XHCONNSTRUC * XHConnData;
  //--------------------------------------------------
  // Check if private data structure is present at all
  //--------------------------------------------------
  if(pXifClStruc == NULL)			// nothing set, ignore
    return;
  XHConnData = (XHCONNSTRUC *) pXifClStruc->vpc_ext; // get pointer to private structure
  if(XHConnData == NULL)
      return;
  //--------------------------------------------------
  // Assure that memory helper is kept alive !!!
  //--------------------------------------------------
  memcpy(&LclMemCtxStruc,vp__ctx,sizeof(ds__hmem));

  LOAD_HMEM_CTX_PTR(&LclMemCtxStruc);	// now we use local copy !!!
  //----------------------------------------------------
  // Free the connection structure and its substructures
  //----------------------------------------------------
  pConnStruc = XHConnData->pConnStruc;	// get connection struct. ptr
  if(pConnStruc != NULL)
  {
    FreeConnStateStruct(pConnStruc);	  // free connection data
    FREE_ARRAY(HMEM_CTX_REF,pConnStruc); // free the structure itself
    XHConnData->pConnStruc = NULL;
  }
  FREE_ARRAY(HMEM_CTX_REF,XHConnData);	// free private structure
  pXifClStruc->vpc_ext = NULL;		// invalidate

  MEMMGR_FREE(HMEM_CTX_REF);

}
#endif //XH_INTERFACE

static void* m_alloc_aligned_16(HMEM_CTX_DEF void** aavop_base_dest, int inp_len)
{
    void* al_mem = BIT8_ARRAY_ALLOC(HMEM_CTX_REF, (inp_len+16));
    
    if(al_mem == NULL){
        return NULL;
    }

    *aavop_base_dest = al_mem;

    al_mem = (char*)al_mem + (16 - ((size_t)al_mem & 0xf));
    return al_mem;
}

static struct dsd_aes_gcm_state* m_get_gcm_state(CONNSTRU* adsp_session, 
                                                 int inp_state_type)
{
    struct dsd_aes_gcm_state** aadsl_state;
    void** aavol_base;

    if(inp_state_type == 0){
        aadsl_state = &adsp_session->adsc_recv_gcm_state;
        aavol_base = &adsp_session->avoc_recv_gcm_base;
        memset(adsp_session->chrc_aes_gcm_recv_temp, 0, AES_BLOCK_SIZE+1);
    } else {
        aadsl_state = &adsp_session->adsc_send_gcm_state;
        aavol_base = &adsp_session->avoc_send_gcm_base;
        memset(adsp_session->chrc_aes_gcm_send_temp, 0, AES_BLOCK_SIZE+1);
    }

    if(*aadsl_state == NULL) {
        HMEM_CTX_DEF1;

        LOAD_HMEM_CTX_PTR(CONN_pMemCtx(adsp_session));

        *aadsl_state = (dsd_aes_gcm_state*)m_alloc_aligned_16(HMEM_CTX_REF1 
                                                              aavol_base,
                                                              sizeof(dsd_aes_gcm_state));

        if(*aavol_base == NULL){
            return NULL;
        }

        memset(*aadsl_state, 0, sizeof(dsd_aes_gcm_state));
    }

    return *aadsl_state;
}

static ds_aes_key* m_get_aes_state(CONNSTRU* adsp_session, 
                                   int inp_state_type)
{
    ds_aes_key** aadsl_state;
    void** aavol_base;

    if(inp_state_type == 0){
        aadsl_state = (ds_aes_key**)&adsp_session->ActRX_AESKeyArrayPtr;
        aavol_base = (void**)&adsp_session->ActRX_AESKeyArrayPtrRaw;
    } else {
        aadsl_state = (ds_aes_key**)&adsp_session->ActTX_AESKeyArrayPtr;
        aavol_base = (void**)&adsp_session->ActTX_AESKeyArrayPtrRaw;
    }

    if(*aadsl_state == NULL) {
        HMEM_CTX_DEF1;

        LOAD_HMEM_CTX_PTR(CONN_pMemCtx(adsp_session));

        *aadsl_state = (ds_aes_key*)m_alloc_aligned_16(HMEM_CTX_REF1 
                                                       aavol_base,
                                                       (AES_KEY_ARRAY_SIZE_BIT32+4)*4);

        if(*aavol_base == NULL){
            return NULL;
        }

        memset(*aadsl_state, 0, sizeof(ds_aes_key));
    }

    return *aadsl_state;
}

/**
* Initializes a specific cipher state of a connection structure (AllocInitCipherArrays).
* Allocates (if required) the necessary active cipher state/key
* arrays and initializes them / generates subkeys.
*
*  @param pConnStruc Connection structure
*  @param StateType 0 - initialize RX states <br>
*               <> 0 - initialize TX states
*  @param AlgorID Cipher algorithm to initialize
*
*  @return HSSL_OP_OK on success, else error occured
*/
static  int  AllocInitCipherArrays(CONNSTRU * pConnStruc,
                                   int StateType,
                                   int AlgorID)
{
    int KeyLen = pConnStruc->KeyLen;

    char* lpKey;
    char* lpBit8;
    short* lpBit16;
    int* lpBit32;
    int* lp2Bit32;
    int* lp3Bit32;
    HMEM_CTX_DEF1;

    LOAD_HMEM_CTX_PTR(CONN_pMemCtx(pConnStruc));
    //-------------------------------------------------------
    // Get appropriate Cipher Key pointer
    //-------------------------------------------------------
    if(StateType == 0)
        lpKey = pConnStruc->ActRX_Key;         // get Key pointer
    else
        lpKey = pConnStruc->ActTX_Key;         // dto.
    //-------------------------------------------------------
    // Distribute according to CipherAlgor
    //-------------------------------------------------------
    switch(AlgorID)
    {
    //-----------------------------------------------------
    // NULL 'Stream' Cipher
    //-----------------------------------------------------
    case CIPHER_ALGOR_NULL:
        return(HSSL_OP_OK);			// nothing to do

    //-----------------------------------------------------
    // RC4 Stream Cipher, allocate State Array, Initialize
    //-----------------------------------------------------
    case CIPHER_ALGOR_RC4:
        if(StateType == 0)			// RX State
            lpBit8 = pConnStruc->ActRX_RC4StateArrayPtr; // state pointer
        else					// TX State
            lpBit8 = pConnStruc->ActTX_RC4StateArrayPtr; // state pointer

        if(lpBit8 == NULL)			// no array yet..
        {
            //------------------------------------------------
            // Allocate the State Array
            //------------------------------------------------
            lpBit8 = BIT8_ARRAY_ALLOC(HMEM_CTX_REF,RC4_STATE_SIZE);
            if(lpBit8 == NULL)
                return(HSSL_INIT_RC4_CIPH_ALLOC_ERR);

            if(StateType == 0)				// RX State
                pConnStruc->ActRX_RC4StateArrayPtr = lpBit8;	// save buffer ptr
            else						// TX State
                pConnStruc->ActTX_RC4StateArrayPtr = lpBit8;	// save buffer ptr
        } // Buffer allocate if
        //-------------------------------------------------
        // Initialize the RC4 State Array
        //-------------------------------------------------
        RC4_SetKey(lpBit8,lpKey,0,KeyLen);
        break;

    //-----------------------------------------------------
    // RC2 CBC Block Cipher, allocate Key Array, Initialize
    //-----------------------------------------------------
    case CIPHER_ALGOR_RC2_CBC:
        if(StateType == 0)				// RX State
            lpBit16 = pConnStruc->ActRX_RC2KeyArrayPtr;	// key array pointer
        else						// TX State
            lpBit16 = pConnStruc->ActTX_RC2KeyArrayPtr;	// key array pointer

        if(lpBit16 == NULL)			// no array yet..
        {
            //------------------------------------------------
            // Allocate the RC2 Key Array
            //------------------------------------------------
            lpBit16 = BIT16_ARRAY_ALLOC(HMEM_CTX_REF,
                RC2_MAX_KEY_WORDS);
            if(lpBit16 == NULL)
                return(HSSL_INIT_RC2_CIPH_ALLOC_ERR);
            if(StateType == 0)				// RX State
                pConnStruc->ActRX_RC2KeyArrayPtr = lpBit16;// save buffer ptr
            else						// TX State
                pConnStruc->ActTX_RC2KeyArrayPtr = lpBit16;// save buffer ptr
        } // Buffer allocate if
        //-------------------------------------------------
        // Initialize the RC2 Key Array
        //-------------------------------------------------
        RC2_SetKey(lpBit16,lpKey,KeyLen,128);
        break;

    //-----------------------------------------------------
    // DES CBC Block Cipher, allocate Subkey Array, Initialize
    //-----------------------------------------------------
    case CIPHER_ALGOR_DES_CBC:
        if(StateType == 0)				// RX State
            lpBit32 = pConnStruc->ActRX_DESSubkey1TabPtr;	// key array pointer
        else						// TX State
            lpBit32 = pConnStruc->ActTX_DESSubkey1TabPtr;	// key array pointer

        if(lpBit32 == NULL)			// no array yet..
        {
            //------------------------------------------------
            // Allocate the DES Subkey Array
            //------------------------------------------------
            lpBit32 = BIT32_ARRAY_ALLOC(HMEM_CTX_REF,
                DES_SUBKEY_ARRAY_SIZE);
            if(lpBit32 == NULL)
                return(HSSL_INIT_DES_CIPH_ALLOC_ERR);

            if(StateType == 0)				// RX State
                pConnStruc->ActRX_DESSubkey1TabPtr = lpBit32;// save buffer ptr
            else						// TX State
                pConnStruc->ActTX_DESSubkey1TabPtr = lpBit32;// save buffer ptr
        } // Buffer allocate if
        //-------------------------------------------------
        // Generate the DES SubKey Array
        //-------------------------------------------------
        GenDESSubKeys((unsigned char *) lpKey,
            (unsigned int *) lpBit32);
        break;

    //-----------------------------------------------------
    // 3DES EDE CBC Block Cipher, allocate Subkey Arrays, Initialize
    //-----------------------------------------------------
    case CIPHER_ALGOR_3DES_EDE_CBC:
        if(StateType == 0)				// RX State
        {
            lpBit32  = pConnStruc->ActRX_DESSubkey1TabPtr;	// key array pointer 1
            lp2Bit32 = pConnStruc->ActRX_DESSubkey2TabPtr;	// key array pointer 2
            lp3Bit32 = pConnStruc->ActRX_DESSubkey3TabPtr;	// key array pointer 3
        }
        else						// TX State
        {
            lpBit32  = pConnStruc->ActTX_DESSubkey1TabPtr;	// key array pointer 1
            lp2Bit32 = pConnStruc->ActTX_DESSubkey2TabPtr;	// key array pointer 2
            lp3Bit32 = pConnStruc->ActTX_DESSubkey3TabPtr;	// key array pointer 3
        }

        if((lpBit32 == NULL) || (lp2Bit32 == NULL) ||
            (lp3Bit32 == NULL))				   // no array yet..
        {
            //------------------------------------------------
            // Allocate the not yet allocated DES Subkey Arrays
            //------------------------------------------------
            if(lpBit32 == NULL)
                lpBit32 = BIT32_ARRAY_ALLOC(HMEM_CTX_REF,
                DES_SUBKEY_ARRAY_SIZE);
            if(lp2Bit32 == NULL)
                lp2Bit32 = BIT32_ARRAY_ALLOC(HMEM_CTX_REF,
                DES_SUBKEY_ARRAY_SIZE);
            if(lp3Bit32 == NULL)
                lp3Bit32 = BIT32_ARRAY_ALLOC(HMEM_CTX_REF,
                DES_SUBKEY_ARRAY_SIZE);

            if((lpBit32 == NULL) || (lp2Bit32 == NULL) ||
                (lp3Bit32 == NULL))				// failure..
            {
                FREE_ARRAY(HMEM_CTX_REF,lpBit32);
                FREE_ARRAY(HMEM_CTX_REF,lp2Bit32);
                FREE_ARRAY(HMEM_CTX_REF,lp3Bit32);

                if(StateType == 0)				// RX State
                {
                    pConnStruc->ActRX_DESSubkey1TabPtr = NULL;	// invalidate pointer
                    pConnStruc->ActRX_DESSubkey2TabPtr = NULL;	// dto.
                    pConnStruc->ActRX_DESSubkey3TabPtr = NULL;	// dto.
                }
                else						// TX state
                {
                    pConnStruc->ActTX_DESSubkey1TabPtr = NULL;	// invalidate pointer
                    pConnStruc->ActTX_DESSubkey2TabPtr = NULL;	// dto.
                    pConnStruc->ActTX_DESSubkey3TabPtr = NULL;	// dto.
                }
                return(HSSL_INIT_3DES_CIPH_ALLOC_ERR);
            }

            if(StateType == 0)				// RX state
            {
                pConnStruc->ActRX_DESSubkey1TabPtr = lpBit32; // save buffer pointer
                pConnStruc->ActRX_DESSubkey2TabPtr = lp2Bit32;// dto.
                pConnStruc->ActRX_DESSubkey3TabPtr = lp3Bit32;// dto.
            }
            else						// TX state
            {
                pConnStruc->ActTX_DESSubkey1TabPtr = lpBit32; // save buffer pointer
                pConnStruc->ActTX_DESSubkey2TabPtr = lp2Bit32;// dto.
                pConnStruc->ActTX_DESSubkey3TabPtr = lp3Bit32;// dto.
            }
        } // Buffer allocate if
        //-------------------------------------------------
        // Generate the DES SubKey Arrays
        //-------------------------------------------------
        GenDESSubKeys((unsigned char *) lpKey,
            (unsigned int *) lpBit32);
        GenDESSubKeys((unsigned char *)(lpKey+DES_KEY_BYTES),
            (unsigned int *) lp2Bit32);
        GenDESSubKeys((unsigned char *)(lpKey+2*DES_KEY_BYTES),
            (unsigned int *) lp3Bit32);
        break;

    //-----------------------------------------------------
    // AES CBC Block Cipher, allocate Subkey Array, Initialize
    //-----------------------------------------------------
    case CIPHER_ALGOR_AES_CBC:
        KeyLen /= 4;				// size in DWords
        {
            ds_aes_key* adsl_key = m_get_aes_state(pConnStruc, StateType);

            if(adsl_key == NULL){
                return(HSSL_INIT_AES_CIPH_ALLOC_ERR);
            } // Buffer allocate if
            //-------------------------------------------------
            // Generate the AES RX/TX Key Array
            //-------------------------------------------------
            if(pConnStruc->pCfgStruc->in_use_cpu_aes != 0) {
                adsl_key->im_flags |= CHECK_CPU_AES_FLAG;
            }
            if(StateType == 0){				// RX State
                m_aes_set_decrypt_key((unsigned char *) lpKey, KeyLen, adsl_key);
            } else {
                m_aes_set_encrypt_key((unsigned char *) lpKey, KeyLen, adsl_key);
            }
        }
        break;
    case CIPHER_ALGOR_AES_GCM:
        KeyLen /= 4;				// size in DWords
        {
            ds_aes_key* adsl_key = m_get_aes_state(pConnStruc, StateType);
            dsd_aes_gcm_state* adsl_state = m_get_gcm_state(pConnStruc, StateType);

            if((adsl_key == NULL) || (adsl_state == NULL)) {
                return(HSSL_INIT_AES_CIPH_ALLOC_ERR);
            } // Buffer allocate if
            
            //-------------------------------------------------
            // Generate the AES RX/TX Key Array
            //-------------------------------------------------
            
            if(pConnStruc->pCfgStruc->in_use_cpu_aes != 0) {
                adsl_key->im_flags |= CHECK_CPU_AES_FLAG;
            }
            
            // For AES GCM, encrypt key is used for both directions
            m_aes_set_encrypt_key((unsigned char *) lpKey, KeyLen, adsl_key);

        }
        break;
    default:
        return(HSSL_INIT_CIPH_INV_CIPH_ALGOR);
    } // switch
    return(HSSL_OP_OK);
}

/**
* Initializes a specific compression state of a connection structure (AllocInitCompressionArrays).
* Allocates (if required) the necessary active compression state
* arrays and initializes them.
*
*  @param pConnStruc Connection struct
*  @param StateType 0 - initialize RX states <br>
*               <> 0 - initialize TX states
*  @param AlgorID Compression algorithm to initialize (low byte)
*
*  @return HSSL_OP_OK on success, else error occured
*/
static  int  AllocInitCompressionArrays(CONNSTRU * pConnStruc,
					           int StateType,
					           int AlgorID)
{
  DCDR* pCdr;
  HMEM_CTX_DEF1;

  LOAD_HMEM_CTX_PTR(CONN_pMemCtx(pConnStruc));
  //-------------------------------------------------------
  // Distribute according to CompressionAlgor
  //-------------------------------------------------------
  switch(AlgorID)
  {
    //-----------------------------------------------------
    // NULL Compression
    //-----------------------------------------------------
    case COMPR_NULL:
      return(HSSL_OP_OK);			// nothing to do
    //-----------------------------------------------------
    // V42BIS Compression, allocate State Array, Initialize
    // no reinit required !!
    //-----------------------------------------------------
    case COMPR_V42BIS:
      if(StateType == 0)			// RX State
        pCdr = pConnStruc->ActRX_V42BisCdrPtr;
      else					// TX State
        pCdr = pConnStruc->ActTX_V42BisCdrPtr;
      if(pCdr == NULL)				// no array yet..
      {
	//------------------------------------------------
	// Allocate the State Array
	//------------------------------------------------
	pCdr = (DCDR*)
          ((void *) BIT8_ARRAY_ALLOC(HMEM_CTX_REF, sizeof(DCDR)));
        if(pCdr == NULL)
	  return(HSSL_INIT_V42_CMPR_ALLOC_ERR);
	memset(pCdr,0,sizeof(DCDR));
	//------------------------------------------------
	// Initialize the State array
	//------------------------------------------------
	pCdr->ul_param_1 = COMPR_V42_N1_VAL;	// set codewordlen
	pCdr->ul_param_2 = COMPR_V42_N2_VAL;	// string length
	pCdr->ifunc = DEF_IFUNC_START;	// set initialize
        if(StateType == 0)			// RX State:
	  CdrDec(HMEM_CTX_REF1 pCdr);	//   initialize d e c o d e r
        else					// TX State
	  CdrEnc(HMEM_CTX_REF1 pCdr);	//   initialize e n c o d e r
        if(pCdr->ireturn != DEF_IRET_NORMAL)
	{
	  FREE_ARRAY(HMEM_CTX_REF,pCdr);
	  return(HSSL_INIT_V42_CMPR_ALLOC_ERR);
        }
        if(StateType == 0)				// RX State
          pConnStruc->ActRX_V42BisCdrPtr = pCdr;	// save struc. ptr
        else						// TX State
          pConnStruc->ActTX_V42BisCdrPtr = pCdr;	// save buffer ptr
      } // Buffer allocate/initialize
      return(HSSL_OP_OK);

    default:
      return(HSSL_INIT_COMPR_INVALID_METHOD);
  } // switch
}

/**
* Generates the MD5 MAC/HMAC inner and outer hash state arrays from a given 
* secret (InitMD5CipherMac).
*<ul>
* <li> SSL-MAC: The Inner State array is updated with the secret and PAD_1.
*	    The Outer State array is updated with the secret and PAD_2
* <li> TLS-MAC: The Inner State Array is updated with the EXOR of the
*	    (possibly truncated) key and IPAD.
* 	    The Outer State array is updated with the EXOR of the
*	    (possibly truncated) key and OPAD.
*</ul>
* This precalculation has to be done only once for a given secret
* and the state arrays can be saved.
*
*  @param Mac_I_Array Inner state array
*  @param Mac_O_Array Outer state array
*  @param secret Secret array base
*  @param secretoff Start of secret
*  @param secretlen Length of secret,
*               may be 0
*  @param Mode == 0 -> SSL, MAC <br>
*               <> 0 -> TLS, HMAC
*/
static  void  InitMD5CipherMac(int* Mac_I_Array,
				   	  int* Mac_O_Array,
					  char* secret, int secretoff,
					  int secretlen,
					  int Mode)

{

  int i,j;
  char Key[HMAC_BLOCKLEN];
  if(Mode == 0)
  {
    /*----------------------------------------------------------*/
    /* SSL-Mac: initialize inner array from secret and PAD_1,	*/
    /*		initialize outer array from secret and PAD2	*/
    /*----------------------------------------------------------*/
    MD5_Init(Mac_I_Array);			// initialize
							// hash secret
    MD5_Update(Mac_I_Array,secret,secretoff,secretlen);
							// hash PAD_1
    MD5_Update(Mac_I_Array,Pad1Str,0,PAD1_LEN_MD5);

    MD5_Init(Mac_O_Array);			// initialize
							// hash secret
    MD5_Update(Mac_O_Array,secret,secretoff,secretlen);
							// hash PAD_2
    MD5_Update(Mac_O_Array,Pad2Str,0,PAD2_LEN_MD5);
  } // SSL
  else
  /*------------------------------------------------------------*/
  /* TLS-HMac							*/
  /*------------------------------------------------------------*/
  {
    /*--------------------------------------------------------*/
    /* 1.) generate the MD5 key from secret, exor it with IPAD*/
    /*--------------------------------------------------------*/
    i = 0;				// key Startindex
    j = secretoff;
    if(secretlen > HMAC_BLOCKLEN)	// key too large, must hash first
    {
      MD5_Init(Mac_I_Array);
      MD5_Update(Mac_I_Array,secret,j,(int) secretlen);
      MD5_Final(Mac_I_Array,Key,0);
    
      do{Key[i++] ^= (char) 0x36;}while(i < MD5_DIGEST_LEN); // EXOR with IPAD
    }
    else				// key is short enough ...
    {
      for(i=0;i<secretlen;i++)		// can be zero length !!
        Key[i] = (char) (secret[j++] ^ 0x36);	// EXOR with IPAD
    }

    for(;i<HMAC_BLOCKLEN;i++) Key[i]=(char) 0x36; // fill the rest with IPAD
    /*--------------------------------------------------*/
    /* 2.) generate peloaded HMAC MD5 State Arrays	*/
    /*     for Inner and Outer Padding values		*/
    /*--------------------------------------------------*/
    MD5_Init(Mac_I_Array);
    MD5_Update(Mac_I_Array,Key,0,(int) HMAC_BLOCKLEN);

    i=HMAC_BLOCKLEN;
    do
    {
      i--;					// pre-decrement
      Key[i] = (char) (Key[i] ^(0x36^0x5C)); // Exor with OPAD
    }while(i != 0);

    MD5_Init(Mac_O_Array);
    MD5_Update(Mac_O_Array,Key,0,(int) HMAC_BLOCKLEN);
  }
}

/**
* Generates the SHA1 MAC/HMAC inner and outer hash state arrays from a given 
* secret (InitSHA1CipherMac).
*<ul>
* <li> SSL-MAC: The Inner State array is updated with the secret and PAD_1.
*	    The Outer State array is updated with the secret and PAD_2
* <li> TLS-MAC: The Inner State Array is updated with the EXOR of the
*	    (possibly truncated) key and IPAD.
* 	    The Outer State array is updated with the EXOR of the
*	    (possibly truncated) key and OPAD.
*</ul>
* This precalculation has to be done only once for a given secret
* and the state arrays can be saved.
*
*  @param Mac_I_Array Inner state array
*  @param Mac_O_Array Outer state array
*  @param secret Secret array base
*  @param secretoff Start of secret
*  @param secretlen Length of secret,
*               may be 0
*  @param Mode == 0 -> SSL, MAC <br>
*               <> 0 -> TLS, HMAC
*/
static  void  InitSHA1CipherMac(int* Mac_I_Array,
					   int* Mac_O_Array,
					   char* secret, int secretoff,
					   int secretlen,
					   int Mode)

{
  int i,j;
  char Key[HMAC_BLOCKLEN];
  if(Mode == 0)
  {
    /*----------------------------------------------------------*/
    /* SSL-Mac: initialize inner array from secret and PAD_1,	*/
    /*		initialize outer array from secret and PAD2	*/
    /*----------------------------------------------------------*/
    SHA1_Init(Mac_I_Array);			// initialize
							// hash secret
    SHA1_Update(Mac_I_Array,secret,secretoff,secretlen);
							// hash PAD_1
    SHA1_Update(Mac_I_Array,Pad1Str,0,PAD1_LEN_SHA1);

    SHA1_Init(Mac_O_Array);			// initialize
							// hash secret
    SHA1_Update(Mac_O_Array,secret,secretoff,secretlen);
							// hash PAD_2
    SHA1_Update(Mac_O_Array,Pad2Str,0,PAD2_LEN_SHA1);
  } // SSL
  else
  /*------------------------------------------------------------*/
  /* TLS-HMac							*/
  /*------------------------------------------------------------*/
  {
    /*---------------------------------------------------------*/
    /* 1.) generate the SHA1 key from secret, exor it with IPAD*/
    /*---------------------------------------------------------*/
    i = 0;				// key Startindex
    j = secretoff;
    if(secretlen > HMAC_BLOCKLEN)	// key too large, must hash first
    {
      SHA1_Init(Mac_I_Array);
      SHA1_Update(Mac_I_Array,secret,j,(int) secretlen);
      SHA1_Final(Mac_I_Array,Key,0);
    
      do{Key[i++] ^= (char) 0x36;}while(i < SHA_DIGEST_LEN); // EXOR with IPAD
    }
    else				// key is short enough ...
    {
      for(i=0;i<secretlen;i++)		// can be zero length !!
        Key[i] = (char) (secret[j++] ^ 0x36);	// EXOR with IPAD
    }

    for(;i<HMAC_BLOCKLEN;i++) Key[i]=(char) 0x36; // fill the rest with IPAD
    /*--------------------------------------------------*/
    /* 2.) generate peloaded HMAC SHA1 State Arrays	*/
    /*     for Inner and Outer Padding values		*/
    /*--------------------------------------------------*/
    SHA1_Init(Mac_I_Array);
    SHA1_Update(Mac_I_Array,Key,0,(int) HMAC_BLOCKLEN);

    i=HMAC_BLOCKLEN;
    do
    {
      i--;					// pre-decrement
      Key[i] = (char) (Key[i] ^(0x36^0x5C));	// Exor with OPAD
    }while(i != 0);

    SHA1_Init(Mac_O_Array);
    SHA1_Update(Mac_O_Array,Key,0,(int) HMAC_BLOCKLEN);
  }
}
/**
* Generates the SHA256 MAC/HMAC inner
* and outer hash state arrays from a given secret (InitSHA256CipherMac).
* <ul>
* <li> SSL-MAC: The Inner State array is updated with the secret and PAD_1.
*	    The Outer State array is updated with the secret and PAD_2.
* <li>TLS-MAC: The Inner State Array is updated with the EXOR of the
*	    (possibly truncated) key and IPAD.
* 	    The Outer State array is updated with the EXOR of the
*	    (possibly truncated) key and OPAD.
*</ul>
* This precalculation has to be done only once for a given secret
* and the state arrays can be saved.
*
*  @param Mac_I_Array Inner state array
*  @param Mac_O_Array Outer state array
*  @param secret Secret array base
*  @param secretoff Start of secret
*  @param secretlen Length of secret,
*               may be 0
*  @param Mode == 0 -> SSL, MAC <br>
*               <> 0 -> TLS, HMAC
*/
static  void  InitSHA256CipherMac(int* Mac_I_Array,
					   int* Mac_O_Array,
					   char* secret, int secretoff,
					   int secretlen,
					   int Mode)
{
  int i,j;
  char Key[HMAC_BLOCKLEN];
  if(Mode == 0)
  {
    /*----------------------------------------------------------*/
    /* SSL-Mac: initialize inner array from secret and PAD_1,	*/
    /*		initialize outer array from secret and PAD2	*/
    /*----------------------------------------------------------*/
    SHA256_Init(Mac_I_Array);			// initialize
							// hash secret
    SHA256_Update(Mac_I_Array,secret,secretoff,secretlen);
							// hash PAD_1
    SHA256_Update(Mac_I_Array,Pad1Str,0,PAD1_LEN_SHA256);

    SHA256_Init(Mac_O_Array);			// initialize
							// hash secret
    SHA256_Update(Mac_O_Array,secret,secretoff,secretlen);
							// hash PAD_2
    SHA256_Update(Mac_O_Array,Pad2Str,0,PAD2_LEN_SHA256);
  } // SSL
  else
  /*------------------------------------------------------------*/
  /* TLS-HMac							*/
  /*------------------------------------------------------------*/
  {
    /*---------------------------------------------------------*/
    /* 1.) generate the SHA256 key from secret, exor it with IPAD*/
    /*---------------------------------------------------------*/
    i = 0;				// key Startindex
    j = secretoff;
    if(secretlen > HMAC_BLOCKLEN)	// key too large, must hash first
    {
      SHA256_Init(Mac_I_Array);
      SHA256_Update(Mac_I_Array,secret,j,(int) secretlen);
      SHA256_Final(Mac_I_Array,Key,0);
    
      do{Key[i++] ^= (char) 0x36;}while(i < SHA256_DIGEST_LEN); // EXOR with IPAD
    }
    else				// key is short enough ...
    {
      for(i=0;i<secretlen;i++)		// can be zero length !!
        Key[i] = (char) (secret[j++] ^ 0x36);	// EXOR with IPAD
    }

    for(;i<HMAC_BLOCKLEN;i++) Key[i]=(char) 0x36; // fill the rest with IPAD
    /*--------------------------------------------------*/
    /* 2.) generate peloaded HMAC SHA256 State Arrays	*/
    /*     for Inner and Outer Padding values		*/
    /*--------------------------------------------------*/
    SHA256_Init(Mac_I_Array);
    SHA256_Update(Mac_I_Array,Key,0,(int) HMAC_BLOCKLEN);

    i=HMAC_BLOCKLEN;
    do
    {
      i--;					// pre-decrement
      Key[i] = (char) (Key[i] ^(0x36^0x5C));	// Exor with OPAD
    }while(i != 0);

    SHA256_Init(Mac_O_Array);
    SHA256_Update(Mac_O_Array,Key,0,(int) HMAC_BLOCKLEN);
  }
}

/**
* Implements the TLS PRF as defined in RFC 4346 (TLS_Prf).
*
* Destination buffer may not be same as seed or label buffer.
*
*  @param secret Keydata array base used in HMACS
*  @param secretoff Offset to keydata
*  @param secretlen Length of key, may be 0
*  @param label Pointer to label string
*  @param labellen Length of string
*  @param seed seed Seed data array base
*  @param seedoff Start of seed data
*  @param seedlen Length of seed data
*  @param dst Destination buffer base
*  @param dstoff Start destination data
*  @param dstlen Length of buffer
*/
static  void  TLS_Prf(char* secret, int secretoff, int secretlen,
				 char * label,  int labellen,
				 char* seed,   int seedoff,	int seedlen,
				 char* dst,    int dstoff,	int dstlen)
{

// at current sizes are same; if sizes are changed,
// ----- the  l a r g e r  one must be used for the following define

#define STATE_SIZE	MD5_ARRAY_SIZE

  int i,j,k;
  int cnt;
  int halflen;

  int I_State[STATE_SIZE];
  int O_State[STATE_SIZE];
  int State[STATE_SIZE];

  char Key[HMAC_BLOCKLEN];			// buffer for Keyblock

  char IteratDigestBuf[SHA_DIGEST_LEN];	// is 20 byte, also for MD5
  char TmpDigestBuf[SHA_DIGEST_LEN];	// is 20 byte, also for MD5
  //----------------------------------------------------
  // Check if destination size 0 first !
  //----------------------------------------------------
  if(dstlen == 0) return;

#define LabelData	label
  /*----------------------------------------------------*/
  /* Calculate the Keyblock partitioning size		*/
  /*----------------------------------------------------*/
  halflen = (secretlen + 1)/2;		// half the size of keyblock

  /*----------------------------------------------------*/
  /* A. Generate P_MD5 data from left half of key,	*/
  /*    label and seed, store to destination		*/
  /*----------------------------------------------------*/
  j = secretoff;			// start of left half
  /*--------------------------------------------------------*/
  /* 1.) generate the MD5 key S1 from left half of secret,  */
  /*     exor it with IPAD				    */
  /*--------------------------------------------------------*/
  i = 0;				// key Startindex
  if(halflen > HMAC_BLOCKLEN)		// key too large, must hash first
  {
    MD5_Init(State);
    MD5_Update(State,secret,j,(int) halflen);
    MD5_Final(State,Key,0);
    
    do{Key[i++] ^= (char) 0x36;}while(i < MD5_DIGEST_LEN); // EXOR with IPAD
  }
  else					// key is short enough ...
  {
    for(i=0;i<halflen;i++)
      Key[i] = (char) (secret[j++] ^ 0x36);	// EXOR with IPAD
  }

  for(;i<HMAC_BLOCKLEN;i++) Key[i]=(char) 0x36;	// fill the rest with IPAD
  /*----------------------------------------------------*/
  /* 2.) generate peloaded HMAC MD5 State Arrays	*/
  /*     for Inner and Outer Padding values		*/
  /*----------------------------------------------------*/
  MD5_Init(I_State);
  MD5_Update(I_State,Key,0,(int) HMAC_BLOCKLEN);

  i=HMAC_BLOCKLEN;
  do
  {
    i--;					// pre-decrement
    Key[i] = (char) (Key[i] ^ (0x36^0x5C));	// Exor with OPAD
  }while(i != 0);

  MD5_Init(O_State);
  MD5_Update(O_State,Key,0,(int) HMAC_BLOCKLEN);
  /*----------------------------------------------------*/
  /* 3.) Generate MD5 Iteration Start Digest A(0) from	*/
  /*     concatenation of label and seed		*/
  /*----------------------------------------------------*/
  memcpy(State+0,I_State+0,(MD5_ARRAY_SIZE)*4);	// preload inner hash

  MD5_Update(State,LabelData,0,(int) labellen); // hash label
  MD5_Update(State,seed,seedoff,(int) seedlen); // hash seed
  MD5_Final(State,IteratDigestBuf,0);		// save tmp. digest

  memcpy(State+0,O_State+0,(MD5_ARRAY_SIZE)*4);	// preload outer hash

  MD5_Update(State,IteratDigestBuf,0,MD5_DIGEST_LEN);
  MD5_Final(State,IteratDigestBuf,0);
  /*----------------------------------------------------*/
  /* 4.) Generate the required MD5 data			*/
  /*----------------------------------------------------*/
  cnt = dstlen;
  j = dstoff;
  for(;;)
  {
    /*--------------------------------------------------*/
    /* 4a) Get inner HMAC Digest from Iteration digest,	*/
    /*     label and seed				*/
    /*--------------------------------------------------*/
    memcpy(State+0,I_State+0,(MD5_ARRAY_SIZE)*4);	// preload inner hash

    MD5_Update(State,IteratDigestBuf,0,MD5_DIGEST_LEN); //hash iterat.
    MD5_Update(State,LabelData,0,(int) labellen);	// hash label
    MD5_Update(State,seed,seedoff,(int) seedlen);	// hash seed
    MD5_Final(State,TmpDigestBuf,0);		// get digest
    /*--------------------------------------------------*/
    /* 4b) Get outer HMAC Digest			*/
    /*--------------------------------------------------*/
    memcpy(State+0,O_State+0,(MD5_ARRAY_SIZE)*4);	// preload outer hash

    MD5_Update(State,TmpDigestBuf,0,MD5_DIGEST_LEN);
    MD5_Final(State,TmpDigestBuf,0);
    /*--------------------------------------------------*/
    /* 4c) copy data to destination			*/
    /*--------------------------------------------------*/
    i = MD5_DIGEST_LEN;				// max. data available
    if(i > cnt) i = cnt;			// limit size
    cnt -= i;					// reduce data count
    k = 0;
    memcpy(dst+j,TmpDigestBuf+0,i);	// copy the data
    j+= i;					// increment index
    /*--------------------------------------------------*/
    /* 4d) check if all data processed, if not get next	*/
    /*     iteration hash				*/
    /*--------------------------------------------------*/
    if(cnt == 0) break;

    memcpy(State+0,I_State+0,(MD5_ARRAY_SIZE)*4);	// preload inner hash

    MD5_Update(State,IteratDigestBuf,0,MD5_DIGEST_LEN);
    MD5_Final(State,IteratDigestBuf,0);

    memcpy(State+0,O_State+0,(MD5_ARRAY_SIZE)*4);	// preload outer hash

    MD5_Update(State,IteratDigestBuf,0,MD5_DIGEST_LEN);
    MD5_Final(State,IteratDigestBuf,0);
  } // for
  /*----------------------------------------------------*/
  /* B. Generate P_SHA1 data from right half of key,	*/
  /*    label and seed, exor data with destination	*/
  /*----------------------------------------------------*/
  j = secretoff+secretlen-halflen;		// start of right half

  /*----------------------------------------------------*/
  /* 1.) generate the SHA1 key S2 from right half of	*/
  /*     secret, exor it with IPAD			*/
  /*----------------------------------------------------*/
  if(halflen > HMAC_BLOCKLEN)		// key too large, must hash first
  {
    SHA1_Init(State);
    SHA1_Update(State,secret,j,(int) halflen);
    SHA1_Final(State,Key,0);

    for(i=0;i<SHA_DIGEST_LEN;i++) Key[i] ^= (char) 0x36; // EXOR with IPAD
  }
  else					// key is short enough ...
  {
    for(i=0;i<halflen;i++)
      Key[i] = (char) (secret[j++] ^ 0x36);	// EXOR with IPAD
  }

  for(;i<HMAC_BLOCKLEN;i++) Key[i]=(char) 0x36;	// fill the rest with IPAD
  /*----------------------------------------------------*/
  /* 2.) generate peloaded HMAC SHA1 State Arrays	*/
  /*     for Inner and Outer Padding values		*/
  /*----------------------------------------------------*/
  SHA1_Init(I_State);
  SHA1_Update(I_State,Key,0,(int) HMAC_BLOCKLEN);

  i=HMAC_BLOCKLEN;
  do
  {
    i--;					// pre-decrement
    Key[i] = (char) (Key[i] ^ (0x36^0x5C));	// Exor with OPAD
  }while(i != 0);

  SHA1_Init(O_State);
  SHA1_Update(O_State,Key,0,(int) HMAC_BLOCKLEN);
  /*----------------------------------------------------*/
  /* 3.) Generate SHA1 Iteration Start Digest A(0) from	*/
  /*     concatenation of label and seed		*/
  /*----------------------------------------------------*/
  memcpy(State+0,I_State+0,(SHA_ARRAY_SIZE)*4);	// preload inner hash

  SHA1_Update(State,LabelData,0,(int) labellen); // hash label
  SHA1_Update(State,seed,seedoff,(int) seedlen); // hash seed
  SHA1_Final(State,IteratDigestBuf,0);		// save tmp. digest

  memcpy(State+0,O_State+0,(SHA_ARRAY_SIZE)*4);	// preload outer hash

  SHA1_Update(State,IteratDigestBuf,0,SHA_DIGEST_LEN);
  SHA1_Final(State,IteratDigestBuf,0);
  /*----------------------------------------------------*/
  /* 4.) Generate the required SHA1 data		*/
  /*----------------------------------------------------*/
  cnt = dstlen;
  j = dstoff;
  for(;;)
  {
    /*--------------------------------------------------*/
    /* 4a) Get inner HMAC Digest from Iteration digest,	*/
    /*     label and seed				*/
    /*--------------------------------------------------*/
    memcpy(State+0,I_State+0,(SHA_ARRAY_SIZE)*4);	// preload inner hash

    SHA1_Update(State,IteratDigestBuf,0,SHA_DIGEST_LEN); //hash iter.
    SHA1_Update(State,LabelData,0,(int) labellen);	// hash label
    SHA1_Update(State,seed,seedoff,(int) seedlen);	// hash seed
    SHA1_Final(State,TmpDigestBuf,0);		// get digest
    /*--------------------------------------------------*/
    /* 4b) Get outer HMAC Digest			*/
    /*--------------------------------------------------*/
    memcpy(State+0,O_State+0,(SHA_ARRAY_SIZE)*4);	// preload outer hash

    SHA1_Update(State,TmpDigestBuf,0,SHA_DIGEST_LEN);
    SHA1_Final(State,TmpDigestBuf,0);
    /*--------------------------------------------------*/
    /* 4c) xor data with destination			*/
    /*--------------------------------------------------*/
    i = SHA_DIGEST_LEN;				// max. data available
    if(i > cnt) i = cnt;			// limit size
    cnt -= i;					// reduce data count
    k = 0;
    do{dst[j++] ^= TmpDigestBuf[k++];i--;}while(i!=0); // exor the data
    /*--------------------------------------------------*/
    /* 4d) check if all data processed, if not get next	*/
    /*     iteration hash				*/
    /*--------------------------------------------------*/
    if(cnt == 0) break;
    memcpy(State+0,I_State+0,(SHA_ARRAY_SIZE)*4);	// preload inner hash

    SHA1_Update(State,IteratDigestBuf,0,SHA_DIGEST_LEN);
    SHA1_Final(State,IteratDigestBuf,0);

    memcpy(State+0,O_State+0,(SHA_ARRAY_SIZE)*4);	// preload outer hash

    SHA1_Update(State,IteratDigestBuf,0,SHA_DIGEST_LEN);
    SHA1_Final(State,IteratDigestBuf,0);
  } // for
}
#undef STATE_SIZE
#undef LabelData

/**
*  Implements the P_HASH function as defined in RFC5246.
*
*  @param inp_hmac_id   Identifier for the used hash function. See GenHMAC function
*  @param abyp_secret   Buffer containing the secret
*  @param inp_secretoff Offset of the secret in buffer
*  @param inp_secretlen Length of the secret
*  @param abyp_seed     Buffer containing the seed
*  @param inp_seedlen   Length of the seed
*  @param abyp_dst      Buffer for taking the generated value
*  @param inp_dstoff    Offset where to start writing
*  @param inp_dstlen    Number of bytes to be generated
*/
static  void  m_phash(HMEM_CTX_DEF int inp_hmac_id, char* abyp_secret, int inp_secretoff,
                              int inp_secretlen, char* abyp_seed,
                              int inp_seedlen, char* abyp_dst, int inp_dstoff, 
                              int inp_dstlen)
{
   char abyl_a1_array[HMAC_MAX_DIGEST_LEN];    // One of the actual buffers to hold the a(i) values
   char abyl_a2_array[HMAC_MAX_DIGEST_LEN];    // One of the actual buffers to hold the a(i) values
   char* abyl_a_i = abyl_a1_array;        // Pointer to the current a(i)
   char* abyl_a_i_minus_1 = abyl_a2_array;// Pointer to the current a(i-1)
   int ainl_hash_len[1];     // keeps the actual Hash length
   char* abyl_a_i_plus_seed;              // keeps a(i)+seed
   char* abyl_tmp;

   // Generate a(1)
   ainl_hash_len[0] = HMAC_MAX_DIGEST_LEN;
   GenHMAC(abyp_secret,inp_secretoff,inp_secretlen,abyp_seed,0,inp_seedlen,inp_hmac_id,abyl_a_i,0,ainl_hash_len);
   // allocate buffer for a(i)+seed and copy seed
   abyl_a_i_plus_seed = BIT8_ARRAY_ALLOC(HMEM_CTX_REF, ainl_hash_len[0]+inp_seedlen);
   memcpy(abyl_a_i_plus_seed+ainl_hash_len[0],abyp_seed+0,inp_seedlen);
   while(inp_dstlen >= ainl_hash_len[0]){
      // Update a(i)+seed and calculate next block
      memcpy(abyl_a_i_plus_seed+0,abyl_a_i+0,ainl_hash_len[0]);
      GenHMAC(abyp_secret,inp_secretoff,inp_secretlen,abyl_a_i_plus_seed,0,ainl_hash_len[0]+inp_seedlen,inp_hmac_id,abyp_dst,inp_dstoff,ainl_hash_len);
      inp_dstoff += ainl_hash_len[0];
      inp_dstlen -= ainl_hash_len[0];
      // swap a(i) buffers and calculate next a(i)
      {
         abyl_tmp = abyl_a_i;
         abyl_a_i = abyl_a_i_minus_1;
         abyl_a_i_minus_1 = abyl_tmp;
      }
      GenHMAC(abyp_secret,inp_secretoff,inp_secretlen,abyl_a_i_minus_1,0,ainl_hash_len[0],inp_hmac_id,abyl_a_i,0,ainl_hash_len);
   }
   if(inp_dstlen != 0) // Destination has room for a partial block left
   {
      memcpy(abyl_a_i_plus_seed+0,abyl_a_i+0,ainl_hash_len[0]);
      GenHMAC(abyp_secret,inp_secretoff,inp_secretlen,abyl_a_i_plus_seed,0,ainl_hash_len[0]+inp_seedlen,inp_hmac_id,abyl_a_i,0,ainl_hash_len);
      memcpy(abyp_dst+inp_dstoff,abyl_a_i+0,inp_dstlen);
   }
   ClearBit8Array(abyl_a1_array, HMAC_MAX_DIGEST_LEN);
   ClearBit8Array(abyl_a2_array,HMAC_MAX_DIGEST_LEN);
   ClearBit8Array(abyl_a_i_plus_seed, ainl_hash_len[0]+inp_seedlen);
   FREE_ARRAY(HMEM_CTX_REF, abyl_a_i_plus_seed);
}

/**
* Implements the TLS 1.2 PRF with SHA256, as defined in RFC 5246 (TLS_12_Prf).
*
* Destination buffer may not be same as seed or label buffer.
*
*  @param secret Keydata array base used in HMACS
*  @param secretoff Offset to keydata
*  @param secretlen Length of key, may be 0 
*  @param label Pointer to label string
*  @param labellen Length of string
*  @param seed seed Seed data array base
*  @param seedoff Start of seed data
*  @param seedlen Length of seed data
*  @param dst Destination buffer base
*  @param dstoff Start destination data
*  @param dstlen Length of buffer
*/
static  void  TLS_12_Prf(HMEM_CTX_DEF char* secret,int secretoff,int secretlen,
				 char * label,  int labellen,
				 char* seed,   int seedoff,	int seedlen,
				 char* dst,    int dstoff,	int dstlen)
{
#define LabelData	label
   char* abyl_phash_seed = BIT8_ARRAY_ALLOC(HMEM_CTX_REF, seedlen+labellen);
   memcpy(abyl_phash_seed+0,LabelData+0,labellen);
   memcpy(abyl_phash_seed+labellen,seed+seedoff,seedlen);
   m_phash(HMEM_CTX_REF1 HMAC_SHA256_ID, secret, secretoff, secretlen, abyl_phash_seed,seedlen+labellen,dst,dstoff,dstlen);
   FREE_ARRAY(HMEM_CTX_REF, abyl_phash_seed);
}
#undef STATE_SIZE
#undef LabelData

/**
* Retrieves parameter table index for a given cipher suite (GetCipherParamsIndex).
*
*  @param CipherSuiteLSB Ciphersuite ID LSB (checked)
*  @return The index to parameter start, -1 if not found.
*/
static  int  GetCipherParamsIndex(unsigned short usp_cipher_id)
{
  int Index = 0;
  int Count = MAX_DEFINED_SUITES;
  bool bol_is_ecc = ((usp_cipher_id >> 8) == 0xC0);
  do
  {
    // First check the LSB. If usp_cipher_id is an ECC cipher, key exchange must be ECDHE_RSA, else it must be something different
    if((CipherParams[Index + CST_CipherID] == (unsigned char) usp_cipher_id) &&
       (bol_is_ecc ^ (CipherParams[Index + CST_KeyExchgMode] != KEY_EXCHANGE_ECDHE_RSA)))
    {
      return(Index);
    }
    Index += CST_ENTRY_SIZE;
    Count--;
  }while(Count != 0);
  return(-1);
}

/**
* Checks, if cipher suite
* is supported and if so loads the cipher, MAC parameters
* and signatures according to the selected cipher suite (SetCipherSuiteParams).
*
*  @param pConnStruc Connection structure
*  @param CipherSuite Selected cipher suite
*
*  @return HSSL_OP_OK on success, else Error occured
*/
static  int  SetCipherSuiteParams(CONNSTRU * pConnStruc,
					    int CipherSuite)
{
  int i;
  int Index;
  char* abyl_sig_filter_list = pConnStruc->pCfgStruc->achc_tls_12_sig_algs;
  HMEM_CTX_DEF1;
  LOAD_HMEM_CTX_PTR(CONN_pMemCtx(pConnStruc));
  //------------------------------------------------------
  // check if cipher suite is supported
  //------------------------------------------------------

  for(i=MAX_SUPPORTED_SUITES-1;i>=0;i--)
    if(SupportedSuites[i] == (unsigned short) (CipherSuite & 0xFFFF)) break;
  if(i < 0)
    return(HSSL_CLNT_HELLO_UNSUP_CIPHSUITE);					// not found
  //------------------------------------------------------
  // Cipher suite is supported, get Start of parameter array,
  // load the parameters into the connection structure
  //------------------------------------------------------
  Index = GetCipherParamsIndex((unsigned short) CipherSuite);
  if(Index == -1)				// SHOULD NOT HAPPEN !
    return(HSSL_CLNT_HELLO_UNSUP_CIPHSUITE);

//  Index = (CipherSuite & 0xFF) * CST_ENTRY_SIZE; // to start of params

  pConnStruc->ActualCipherSuite  = CipherSuite;

  pConnStruc->KeyExchgMode  = CipherParams[Index + CST_KeyExchgMode];
  pConnStruc->CipherAlgor     = CipherParams[Index + CST_CipherAlgor];
  pConnStruc->MacAlgorType      = CipherParams[Index + CST_MacAlgor];
  pConnStruc->CipherType      = CipherParams[Index + CST_CipherAlgorType];
  pConnStruc->IsExportable         = CipherParams[Index + CST_IsExportable];
  pConnStruc->HashSize      = CipherParams[Index + CST_MacSize];
  pConnStruc->KeyLen        = CipherParams[Index + CST_KeySize];
  pConnStruc->KeyMaterialSize    = CipherParams[Index + CST_KeyMatSize];
  pConnStruc->IVLen         = CipherParams[Index + CST_IVSize];
  pConnStruc->BlockLen      = CipherParams[Index + CST_BlockSize];
  //----------------------------------------------
  // Make sure to have a supported signature list and
  // select signature type.
  //----------------------------------------------
  if( pConnStruc->abyc_remote_sig_algs == NULL){ //load defaults
     if(pConnStruc->ActualProtocol == TLS_V2_PROT_TYPE){
        switch(pConnStruc->KeyExchgMode){
     case KEY_EXCHANGE_RSA:
     case KEY_EXCHANGE_DH_RSA:
     case KEY_EXCHANGE_DHE_RSA:
     case KEY_EXCHANGE_ECDHE_RSA:

        pConnStruc->abyc_remote_sig_algs = 
           BIT8_ARRAY_ALLOC(HMEM_CTX_REF, abys_tls_12_rsa_sig_list[0]+1);
        memcpy(pConnStruc->abyc_remote_sig_algs+0,abys_tls_12_rsa_sig_list+0,abys_tls_12_rsa_sig_list[0]+1);

        break;
     case KEY_EXCHANGE_DH_DSS:
     case KEY_EXCHANGE_DHE_DSS:
        pConnStruc->abyc_remote_sig_algs = 
           BIT8_ARRAY_ALLOC(HMEM_CTX_REF, (abys_dsa_sig_list[0]+1));
        memcpy(pConnStruc->abyc_remote_sig_algs+0,abys_dsa_sig_list+0,(abys_dsa_sig_list[0]+1));
        break;
     case KEY_EXCHANGE_SRP:
        // Just to make it work, no signatures will be needed
        pConnStruc->abyc_remote_sig_algs = 
           BIT8_ARRAY_ALLOC(HMEM_CTX_REF, (abys_ssl_sigtype_list[0]+1));
        memcpy(pConnStruc->abyc_remote_sig_algs+0,abys_ssl_sigtype_list+0,(abys_ssl_sigtype_list[0]+1));
        // Server key exchange will be required
        pConnStruc->CertifiedFlags |= SERVER_KEY_EXCHG_REQ_MASK;
        break;
        }
     } else {
        pConnStruc->abyc_remote_sig_algs = 
           BIT8_ARRAY_ALLOC(HMEM_CTX_REF, (abys_ssl_sigtype_list[0]+1));
        memcpy(pConnStruc->abyc_remote_sig_algs+0,abys_ssl_sigtype_list+0,(abys_ssl_sigtype_list[0]+1));
     }
  }
  if(abyl_sig_filter_list == NULL){
      abyl_sig_filter_list = abys_default_server_sigtype_list;
  }
  if(pConnStruc->ActualProtocol == TLS_V2_PROT_TYPE &&
     m_filter_sig_list(pConnStruc->abyc_remote_sig_algs, abyl_sig_filter_list)
     != HSSL_OP_OK){ //no supported signature type found
        return(HSSL_CLNT_HELLO_UNSUP_CIPHSUITE);
  }
  return(HSSL_OP_OK);
}

/**
* Checks if compression method
* is supported and if so loads the appropriate parameters (SetComprMethodsParams).
*
* Currently only method COMPR_NULL is supported.
* Later V42bis will be included.
*
*  @param pConnStruc Connection structure
*  @param ComprMethod selected compression method (low byte)
*
*  @return HSSL_OP_OK on success, error code otherwise
*/
static  int  SetComprMethodsParams(CONNSTRU * pConnStruc,
					     int ComprMethod)
{
  int i;
  //------------------------------------------------------
  // check if cipher suite is supported ( < 0xFF)
  //------------------------------------------------------
  if(((ComprMethod >> 8) != 0) ||		// high byte(s) not zero
       (ComprMethod == 0xFF))			// reserved
    return(HSSL_UNDEFINED_COMPR_METHOD);

  for(i=MAX_SUPPORTED_COMPR-1;i>=0;i--)
    if(SupportedCompr[i] == (unsigned char) (ComprMethod & 0xFF)) break;
  if(i < 0) return(HSSL_UNSUPPORTED_COMPR_METHOD);	// not found
  //------------------------------------------------------
  // Compression Method is supported, store to session status
  //------------------------------------------------------
  pConnStruc->ActualComprMethod = (char) ComprMethod;
  return(HSSL_OP_OK);
}

/**
* Clears the specified pending cipher states (ClearPendingCiphStates).
*
*  @param pConnStruc Connection structure
*  @param StateType == 0 - RX pending states <br>
*               <> 0 - TX pending states
*/
static  void  ClearPendingCiphStates(CONNSTRU * pConnStruc,
						int StateType)
{
  if(StateType == 0)
  {
    //-------------------------------------------------------
    // clear RX pending states (from Remote)
    //-------------------------------------------------------
    pConnStruc->PendRX_ValidFlag = 0;	// clear Flag
  }
  else
  {
    //-------------------------------------------------------
    // clear TX pending states (to Remote)
    //-------------------------------------------------------
    pConnStruc->PendTX_ValidFlag = 0;	// clear Flag
  }
}
/**
* Initializes all connection
* cipher state related values to their default values (InitConnCipherStates).
* Prepares the hash arrays for handshake processing.
*
*  @param pConnStruc Connection structure
*/
static  void  InitConnCipherStates(CONNSTRU * pConnStruc)
{
  //-------------------------------------------------------
  // clear RX active states (from Remote)
  //-------------------------------------------------------
  pConnStruc->ActRX_ComprAlgor =		// no compression
    COMPR_NULL;
  pConnStruc->ActRX_EncAlgor =		// no encryption
    CIPHER_ALGOR_NULL;
  pConnStruc->ActRX_MACAlgor =		// no MAC hash
    MAC_ALGOR_NULL;
  //-------------------------------------------------------
  // clear TX active states (to Remote)
  //-------------------------------------------------------
  pConnStruc->ActTX_ComprAlgor =		// no compression
    COMPR_NULL;
  pConnStruc->ActTX_EncAlgor =		// no encryption
    CIPHER_ALGOR_NULL;
  pConnStruc->ActTX_MACAlgor =		// no MAC hash
    MAC_ALGOR_NULL;
  //-------------------------------------------------------
  // clear RX/TX pending states
  //-------------------------------------------------------
  ClearPendingCiphStates(pConnStruc, 0);
  ClearPendingCiphStates(pConnStruc, 1);
  //-------------------------------------------------------
  // clear Server/Client randoms
  //-------------------------------------------------------
  ClearBit8Array(pConnStruc->ServerRandom,SERVER_HELLO_RANDOM_LEN);
  ClearBit8Array(pConnStruc->ClientRandom,CLIENT_HELLO_RANDOM_LEN);
  //-------------------------------------------------------
  // clear MAC/Key/IV-Vector length
  //-------------------------------------------------------
  pConnStruc->HashSize = 0;
  pConnStruc->KeyLen = 0;
  pConnStruc->IVLen = 0;
  //-------------------------------------------------------
  // clear RX/TX sequence numbers
  //-------------------------------------------------------
  ClearBit8Array(pConnStruc->ActRX_SeqNumber,SEQUENCE_NUM_LEN);
  ClearBit8Array(pConnStruc->ActTX_SeqNumber,SEQUENCE_NUM_LEN);
  //-------------------------------------------------------
  // preload Handshake Hash State Arrays
  //-------------------------------------------------------
  MD5_Init(pConnStruc->HandshakeMD5_State);
  SHA1_Init(pConnStruc->HandshakeSHA1_State);
  SHA256_Init(pConnStruc->HandshakeSHA256_State);
  SHA384_Init(pConnStruc->HandshakeSHA384_State);
  SHA512_Init(pConnStruc->HandshakeSHA512_State);
}

/**
* Activates the new active cipher states and destroys the old ones (CopyPendingToActCipherStates).
* Copies specified pending cipher states to the associated
* active cipher states, clears associated sequence numbers,
* generates Cipher State/Key/Subkey Arrays.
*
* The pending cipher states must have been initialized.
*       i.e. : All required parameters in the session state
*		must be present and valid.
*
*  @param pConnStruc Connection structure
*  @param StateType == 0 - RX States <br>
*               <> 0 - TX States
*  @return HSSL_OP_OK on success, else error occured
*/
static  int  CopyPendingToActCipherStates(CONNSTRU * pConnStruc,
						    int StateType)
{
  int i, Mode, MacAlgor;

  if(pConnStruc->ActualProtocol == SSL_PROT_TYPE)		
    Mode = 0;						// SSL-Mode
  else
    Mode = 1;						// TLS 1.0/1.1 Mode

  if(StateType == 0)					// RX States affected
  {
    //-------------------------------------------------------
    // check/copy RX pending Algorithms to active ones
    //-------------------------------------------------------
    if(pConnStruc->PendRX_ValidFlag == PENDING_STATES_NOT_INIT)
      return(HSSL_PEND_RX_STATES_NOT_INIT);

    pConnStruc->ActRX_ComprAlgor =		// copy Compression Type
      pConnStruc->PendRX_ComprAlgor;
    pConnStruc->ActRX_EncAlgor =		// copy encryption Type
      pConnStruc->PendRX_EncAlgor;
    pConnStruc->ActRX_MACAlgor =		// copy hash type
      pConnStruc->PendRX_MACAlgor;
    //-------------------------------------------------------
    // copy RX pending Secrets/Keys/IVs to active ones
    //-------------------------------------------------------
    memcpy(pConnStruc->ActRX_MACSecret+0,pConnStruc->PendRX_MACSecret+0,pConnStruc->HashSize);

    memcpy(pConnStruc->ActRX_Key+0,pConnStruc->PendRX_Key+0,pConnStruc->KeyLen);

    memcpy(pConnStruc->ActRX_IV+0,pConnStruc->PendRX_IV+0,pConnStruc->IVLen);
    //-------------------------------------------------------
    // clear active RX sequence number
    //-------------------------------------------------------
    ClearBit8Array(pConnStruc->ActRX_SeqNumber,SEQUENCE_NUM_LEN);
    //-------------------------------------------------------
    // initialize encryption MAC State-Arrays if required
    //-------------------------------------------------------
    MacAlgor      = pConnStruc->PendRX_MACAlgor;
    switch(MacAlgor)
    {
      case MAC_ALGOR_MD5:
        InitMD5CipherMac(pConnStruc->ActRX_MAC_I_Array,
			 pConnStruc->ActRX_MAC_O_Array,
			 pConnStruc->PendRX_MACSecret,
			 0,
		         pConnStruc->HashSize,
			 Mode);
        break;

      case MAC_ALGOR_SHA1:
        InitSHA1CipherMac(pConnStruc->ActRX_MAC_I_Array,
			  pConnStruc->ActRX_MAC_O_Array,
			  pConnStruc->PendRX_MACSecret,
			  0,
		          pConnStruc->HashSize,
			  Mode);
        break;

      case MAC_ALGOR_SHA256:
        InitSHA256CipherMac(pConnStruc->ActRX_MAC_I_Array,
			  pConnStruc->ActRX_MAC_O_Array,
			  pConnStruc->PendRX_MACSecret,
			  0,
		          pConnStruc->HashSize,
                Mode);
        break;

      default:
        break;
    }
    //-------------------------------------------------------
    // allocate Cipher Key/State-Array if required, preload
    //-------------------------------------------------------
    i = AllocInitCipherArrays(pConnStruc, 0,
			      pConnStruc->PendRX_EncAlgor);
    if(i != HSSL_OP_OK)
      return(i);				// report error
    //-------------------------------------------------------
    // allocate Compression State-Array if required, preload
    //-------------------------------------------------------
    i = AllocInitCompressionArrays(pConnStruc, 0,
			  (int) pConnStruc->PendRX_ComprAlgor & 0xFF);
    return(i);
  }
  else						// TX States
  {
    //-------------------------------------------------------
    // check/copy TX pending Algorithms to active ones
    //-------------------------------------------------------
    if(pConnStruc->PendTX_ValidFlag == PENDING_STATES_NOT_INIT)
      return(HSSL_PEND_TX_STATES_NOT_INIT);

    pConnStruc->ActTX_ComprAlgor =		// copy Compression Type
      pConnStruc->PendTX_ComprAlgor;
    pConnStruc->ActTX_EncAlgor =		// copy encryption Type
      pConnStruc->PendTX_EncAlgor;
    pConnStruc->ActTX_MACAlgor =		// copy hash type
      pConnStruc->PendTX_MACAlgor;
    //-------------------------------------------------------
    // copy TX pending Secrets/Keys/IVs to active ones
    //-------------------------------------------------------
    memcpy(pConnStruc->ActTX_MACSecret+0,pConnStruc->PendTX_MACSecret+0,pConnStruc->HashSize);

    memcpy(pConnStruc->ActTX_Key+0,pConnStruc->PendTX_Key+0,pConnStruc->KeyLen);

    memcpy(pConnStruc->ActTX_IV+0,pConnStruc->PendTX_IV+0,pConnStruc->IVLen);
    //-------------------------------------------------------
    // clear active TX sequence number
    //-------------------------------------------------------
    ClearBit8Array(pConnStruc->ActTX_SeqNumber,SEQUENCE_NUM_LEN);
    //-------------------------------------------------------
    // initialize encryption MAC State-Arrays if required
    //-------------------------------------------------------
    MacAlgor      = pConnStruc->PendTX_MACAlgor;
    switch(MacAlgor)
    {
      case MAC_ALGOR_MD5:
        InitMD5CipherMac(pConnStruc->ActTX_MAC_I_Array,
			 pConnStruc->ActTX_MAC_O_Array,
			 pConnStruc->PendTX_MACSecret,
			 0,
		         pConnStruc->HashSize,
			 Mode);
        break;

      case MAC_ALGOR_SHA1:
        InitSHA1CipherMac(pConnStruc->ActTX_MAC_I_Array,
			  pConnStruc->ActTX_MAC_O_Array,
			  pConnStruc->PendTX_MACSecret,
			  0,
		          pConnStruc->HashSize,
			  Mode);
        break;

      case MAC_ALGOR_SHA256:
        InitSHA256CipherMac(pConnStruc->ActTX_MAC_I_Array,
			  pConnStruc->ActTX_MAC_O_Array,
			  pConnStruc->PendTX_MACSecret,
			  0,
		          pConnStruc->HashSize,
                Mode);
        break;

      default:
        break;
    }
    //-------------------------------------------------------
    // allocate Key/State-Array if required, preload
    //-------------------------------------------------------
    i = AllocInitCipherArrays(pConnStruc, 1,
			      pConnStruc->PendTX_EncAlgor);
    if(i != HSSL_OP_OK)
      return(i);		// alloc failure
    //-------------------------------------------------------
    // allocate Compression State-Array if required, preload
    //-------------------------------------------------------
    i = AllocInitCompressionArrays(pConnStruc, 1,
			(int) pConnStruc->PendTX_ComprAlgor & 0xFF);
    return(i);
  }
}

/**
* Generates the MD5 MAC/HMAC
* used for enciphered blocks (SSL/TLS) (GenerateMD5CipherMac).
*
* <ol>
* <li> For SSL the Version is not included in the Hash
* <li> For TLS V1.1/1.2 when in CBC mode, the first block must
*	    not be hashed, a reduced size must be used for hashing!
*</ol>
*  @param InpData Base of input data
*  @param InpOffset Offset to input data
*  @param DataLen Length of data, rel . offset!
*  @param MacData Base of destination
*  @param MacOffset Offset to mac data
*  @param lpSeqNum Base of sequence number
*  @param lpMac_I_State Base of inner state buffer
*  @param lpMac_O_State Base of outer state buffer
*  @param ProtType == 1 -> SSL (without version) <br>
*               == 2 -> TLS 1.0 (with version) <br>
*               == 3 -> TLS 1.1 (with version) <br>
*               == 4 -> TLS 1.2 (with version)
*  @param SkipLen if <> 0, CBC in use (TLS V1.1/1.2)
*/
static  void  GenerateMD5CipherMac(char* InpData, int InpOffset,
					      int DataLen,
					      char* MacData, int MacOffset,
					      char* lpSeqNum,
					      int* lpMac_I_State,
					      int* lpMac_O_State,
					      int ProtType, int SkipLen)
{
  int ReducedLen;
  int MD5_Mac_State[MD5_ARRAY_SIZE];
  //------------------------------------------------
  // Generate MD5 MAC/HMAC
  //------------------------------------------------
							// copy inner state
  memcpy(MD5_Mac_State+0,lpMac_I_State+0,(MD5_ARRAY_SIZE)*4);
							// hash Sequence NR.
  MD5_Update(MD5_Mac_State,lpSeqNum,0,SEQUENCE_NUM_LEN);

  switch(ProtType)
  {
    case SSL_PROT_TYPE:					// SSL V3
							// hash content type
      MD5_Update(MD5_Mac_State,InpData,InpOffset,1);
							// hash len + data
      MD5_Update(MD5_Mac_State,InpData,InpOffset+RH_LENGTH,DataLen-3+RECORD_HDR_SIZE);		// without Version!
      break;

    case TLS_PROT_TYPE:					// TLS V1.0
      MD5_Update(MD5_Mac_State,InpData,InpOffset,DataLen+RECORD_HDR_SIZE); // with Version!
      break;

    case TLS_V1_PROT_TYPE:				// TLS V1.1
    case TLS_V2_PROT_TYPE:				// TLS V1.2
    default:
      if(SkipLen == 0)					// no CBC, same as 1.0
        MD5_Update(MD5_Mac_State,InpData,InpOffset,DataLen+RECORD_HDR_SIZE); // with Version!
      else						// TLS 1.1 in CBC mode
      {
        ReducedLen = DataLen - SkipLen;			// without 1st block
        BIGword2charn(ReducedLen,InpData,InpOffset+RH_LENGTH_MSB);

        MD5_Update(MD5_Mac_State,InpData,InpOffset,RECORD_HDR_SIZE);	// header with Version!

        MD5_Update(MD5_Mac_State,InpData,InpOffset+SkipLen+RECORD_HDR_SIZE,ReducedLen);				// data past skip
        BIGword2charn(DataLen,InpData,InpOffset+RH_LENGTH_MSB); // restore org.
      }
      break;
  } // switch    

  MD5_Final(MD5_Mac_State,MacData,MacOffset);	// save temporary

							// copy outer state
  memcpy(MD5_Mac_State+0,lpMac_O_State+0,(MD5_ARRAY_SIZE)*4);
							// hash the inner hash
  MD5_Update(MD5_Mac_State,MacData,MacOffset,MD5_DIGEST_LEN);
  MD5_Final(MD5_Mac_State,MacData,MacOffset);	// store hash
}

/**
* Generates the SHA1 MAC/HMAC used
* for enciphered blocks (SSL/TLS) (GenerateSHA1CipherMac).
*
*
*  @param InpData Base of input data
*  @param InpOffset Offset to input data
*  @param DataLen Length of data, rel . offset!
*  @param MacData Base of destination
*  @param MacOffset Offset to mac data
*  @param lpSeqNum Base of sequence number
*  @param lpMac_I_State Base of inner state buffer
*  @param lpMac_O_State Base of outer state buffer
*  @param ProtType == 1 -> SSL (without version) <br>
*               == 2 -> TLS 1.0 (with version) <br>
*               == 3 -> TLS 1.1 (with version) <br>
*               == 4 -> TLS 1.2 (with version)
*  @param SkipLen if <> 0, CBC in use (TLS V1.1/1.2)
*/
static  void  GenerateSHA1CipherMac(char* InpData, int InpOffset,
					       int DataLen,
					       char* MacData, int MacOffset,
					       char* lpSeqNum,
				               int* lpMac_I_State,
					       int* lpMac_O_State,
					       int ProtType, int SkipLen)
{
  int ReducedLen;
  int SHA1_Mac_State[SHA_ARRAY_SIZE];
  //------------------------------------------------
  // Generate SHA1 MAC/HMAC
  //------------------------------------------------
							// copy inner state
  memcpy(SHA1_Mac_State+0,lpMac_I_State+0,(SHA_ARRAY_SIZE)*4);
							// hash Sequence NR.
  SHA1_Update(SHA1_Mac_State,lpSeqNum,0,SEQUENCE_NUM_LEN);

  switch(ProtType)
  {
    case SSL_PROT_TYPE:					// SSL V3
							// hash content type
      SHA1_Update(SHA1_Mac_State,InpData,InpOffset,1);
							// hash len + data
      SHA1_Update(SHA1_Mac_State,InpData,InpOffset+RH_LENGTH,DataLen-3+RECORD_HDR_SIZE);		// without Version!
      break;

  case TLS_PROT_TYPE:					// TLS V1.0
      SHA1_Update(SHA1_Mac_State,InpData,InpOffset,DataLen+RECORD_HDR_SIZE); // with Version!
      break;

  case TLS_V1_PROT_TYPE:				// TLS V1.1
  case TLS_V2_PROT_TYPE:				// TLS V1.2
  default:
    if(SkipLen == 0)					// no CBC, same as 1.0
      SHA1_Update(SHA1_Mac_State,InpData,InpOffset,DataLen+RECORD_HDR_SIZE); // with Version!
    else						// CBC mode
    {
      ReducedLen = DataLen - SkipLen;			// without 1st block
      BIGword2charn(ReducedLen,InpData,InpOffset+RH_LENGTH_MSB);
      SHA1_Update(SHA1_Mac_State,InpData,InpOffset,RECORD_HDR_SIZE);	// header only
      
      SHA1_Update(SHA1_Mac_State,InpData,InpOffset+SkipLen+RECORD_HDR_SIZE,ReducedLen);				// data past skip
      BIGword2charn(DataLen,InpData,InpOffset+RH_LENGTH_MSB); // restore org.
    }
    break;
  }    
  SHA1_Final(SHA1_Mac_State,MacData,MacOffset);// save temporary

							// copy outer state
  memcpy(SHA1_Mac_State+0,lpMac_O_State+0,(SHA_ARRAY_SIZE)*4);
							// hash inner hash
  SHA1_Update(SHA1_Mac_State,MacData,MacOffset,SHA_DIGEST_LEN);
  SHA1_Final(SHA1_Mac_State,MacData,MacOffset);// store hash
}

/**
* Generates the SHA256 HMAC used
* for enciphered blocks (SSL/TLS) (GenerateSHA256CipherMac).
*
*
*  @param InpData Base of input data
*  @param InpOffset Offset to input data
*  @param DataLen Length of data, rel . offset!
*  @param MacData Base of destination
*  @param MacOffset Offset to mac data
*  @param lpSeqNum Base of sequence number
*  @param lpMac_I_State Base of inner state buffer
*  @param lpMac_O_State Base of outer state buffer
*  @param ProtType == 1 -> SSL (without version) <br>
*               == 2 -> TLS 1.0 (with version) <br>
*               == 3 -> TLS 1.1 (with version) <br>
*               == 4 -> TLS 1.2 (with version)
*  @param SkipLen if <> 0, CBC in use (TLS V1.1/1.2)
*/
static  void  GenerateSHA256CipherMac(char* InpData,int InpOffset,
					       int DataLen,
					       char* MacData, int MacOffset,
					       char* lpSeqNum,
				               int* lpMac_I_State,
					       int* lpMac_O_State,
					       int ProtType, int SkipLen)
{
  int ReducedLen;
  int SHA256_Mac_State[SHA256_ARRAY_SIZE];
  //------------------------------------------------
  // Generate SHA256 HMAC
  //------------------------------------------------
							// copy inner state
  memcpy(SHA256_Mac_State+0,lpMac_I_State+0,(SHA256_ARRAY_SIZE)*4);
							// hash Sequence NR.
  SHA256_Update(SHA256_Mac_State,lpSeqNum,0,SEQUENCE_NUM_LEN);

  switch(ProtType)
  {
    case SSL_PROT_TYPE:					// SSL V3
							// hash content type
      SHA256_Update(SHA256_Mac_State,InpData,InpOffset,1);
							// hash len + data
      SHA256_Update(SHA256_Mac_State,InpData,InpOffset+RH_LENGTH,DataLen-3+RECORD_HDR_SIZE);		// without Version!
      break;

    case TLS_PROT_TYPE:					// TLS V1.0
      SHA256_Update(SHA256_Mac_State,InpData,InpOffset,DataLen+RECORD_HDR_SIZE); // with Version!
      break;

    case TLS_V1_PROT_TYPE:				// TLS V1.1
    case TLS_V2_PROT_TYPE:				// TLS V1.2
    default:
      if(SkipLen == 0)					// no CBC, same as 1.0
        SHA256_Update(SHA256_Mac_State,InpData,InpOffset,DataLen+RECORD_HDR_SIZE); // with Version!
      else						// CBC mode
      {
        ReducedLen = DataLen - SkipLen;			// without 1st block
        BIGword2charn(ReducedLen,InpData,InpOffset+RH_LENGTH_MSB);
        SHA256_Update(SHA256_Mac_State,InpData,InpOffset,RECORD_HDR_SIZE);	// header only
      
        SHA256_Update(SHA256_Mac_State,InpData,InpOffset+SkipLen+RECORD_HDR_SIZE,ReducedLen);				// data past skip
        BIGword2charn(DataLen,InpData,InpOffset+RH_LENGTH_MSB); // restore org.
      }
      break;
  }    
  SHA256_Final(SHA256_Mac_State,MacData,MacOffset);// save temporary

							// copy outer state
  memcpy(SHA256_Mac_State+0,lpMac_O_State+0,(SHA256_ARRAY_SIZE)*4);
							// hash inner hash
  SHA256_Update(SHA256_Mac_State,MacData,MacOffset,SHA256_DIGEST_LEN);
  SHA256_Final(SHA256_Mac_State,MacData,MacOffset);// store hash
}

static int m_init_aes_gcm_send(CONNSTRU* adsp_conn_struct,
                               char* achp_input)
{
    char byrl_additional_data[RECORD_HDR_SIZE+SEQUENCE_NUM_LEN];
    char byrl_full_iv[AES_GCM_IV_TOTAL_LEN];

    unsigned long long ull_seq_nr = *((unsigned long long*)adsp_conn_struct->ActTX_SeqNumber);
    
    // Construct the additional data from seq number and header. subtract the explicit IV length.
    *((unsigned long long*)byrl_additional_data) = ull_seq_nr;
    memcpy(byrl_additional_data+SEQUENCE_NUM_LEN, achp_input, RECORD_HDR_SIZE);

    unsigned short unl_len;

    BIGchar2wordn((byrl_additional_data), (unl_len), (SEQUENCE_NUM_LEN+RH_LENGTH_MSB));
    unl_len -= AES_GCM_EXPL_IV_LEN;
    BIGword2charn((unl_len), (byrl_additional_data), (SEQUENCE_NUM_LEN+RH_LENGTH_MSB));

    // Construct the IV from implicit IV and seq number as suggested by RFC 5288
    *((unsigned int*)byrl_full_iv) = *((unsigned int*)adsp_conn_struct->ActTX_IV);
    *((unsigned long long*)(byrl_full_iv+4)) = ull_seq_nr;

    // write explicit IV part to record
    *((unsigned long long*)(achp_input+RECORD_HDR_SIZE)) = ull_seq_nr;

    m_init_aes_gcm_1(adsp_conn_struct->adsc_send_gcm_state,
                     byrl_additional_data,
                     (RECORD_HDR_SIZE+SEQUENCE_NUM_LEN),
                     byrl_full_iv,
                     AES_GCM_IV_TOTAL_LEN,
                     (struct ds_aes_key_t*) adsp_conn_struct->ActTX_AESKeyArrayPtr,
                     AES128_KEY_SIZE);

    return (HSSL_OP_OK);
}

/**
* Generates the MAC used
* for enciphered blocks (if a MAC is selected) and appends it
* to the block (AppendCipherMac). 
* Increases Block length, if a MAC is generated and
* increases appropriate sequence number.
*
*
*  @param pConnStruc Connection structure
*  @param InpData Base of input record data
*  @param InpOffset Offset to input data
*  @param DataLen Length of data, rel . offset,
*               exclusive record header length
*  @param InpBufLen Total(!) length of buffer
*
*  @return HSSL_OP_OK on success, error code otherwise
*/
static  int  AppendCipherMac(CONNSTRU * pConnStruc,
				       char* InpData, int InpOffset,
				       int* DataLen, int InpBufLen)
{
  int NewLen, MacLen, ProtType, SkipLen;
  int InpDataLen = DataLen[0];
  char MacAlgor;

  char* lpSeqNum;
  int* lpMac_I_State;
  int* lpMac_O_State;

  //----------------------------------------------------------
  // preload pointers, check if MAC algorithm <> MAC_ALGOR_NULL
  //----------------------------------------------------------
  MacAlgor      = pConnStruc->ActTX_MACAlgor;
  if(MacAlgor == MAC_ALGOR_NULL)			// nothing to do ...
    return(HSSL_OP_OK);

  ProtType = pConnStruc->ActualProtocol;			// get type of protocol
  SkipLen = 0;

  // Check TLS V1.1 CBC Cipher mode and encryption active
  if(((ProtType == TLS_V1_PROT_TYPE) || (ProtType == TLS_V2_PROT_TYPE)) &&
     (pConnStruc->ActTX_EncAlgor != CIPHER_ALGOR_NULL) &&
     (pConnStruc->CipherType == ALGOR_TYPE_BLOCK))
  {
    SkipLen = pConnStruc->BlockLen;		// skip a block
  }

  lpSeqNum      = pConnStruc->ActTX_SeqNumber;
  lpMac_I_State = pConnStruc->ActTX_MAC_I_Array; 
  lpMac_O_State = pConnStruc->ActTX_MAC_O_Array; 
  //-------------------------------------------------
  // MD5 / SHA1 selected, first check buffer space 
  //-------------------------------------------------
  if( MacAlgor == MAC_ALGOR_AES_GCM){
      // Length for GCM tag will be added in the encrypt step!
      MacLen = 0;
  } else {
      MacLen = pConnStruc->HashSize;                // same as selected hash size
  }
  NewLen 	= InpDataLen + MacLen + RECORD_HDR_SIZE;// required new length
  if(NewLen > InpBufLen)
    return(HSSL_MAC_BUF_TOO_SHORT);		// buffer too small

  switch(MacAlgor)
  {
    //-------------------------------------------------
    // MD5 selected, generate 
    //-------------------------------------------------
    case MAC_ALGOR_MD5:
      GenerateMD5CipherMac(InpData, InpOffset, InpDataLen,	// generate,
			   InpData, InpOffset+InpDataLen+RECORD_HDR_SIZE,
			   lpSeqNum,
			   lpMac_I_State,
			   lpMac_O_State,ProtType,SkipLen);
      break;
    //-------------------------------------------------
    // SHA1 selected, generate 
    //-------------------------------------------------
    case MAC_ALGOR_SHA1:
      GenerateSHA1CipherMac(InpData, InpOffset, InpDataLen,	// generate,
			    InpData, InpOffset+InpDataLen+RECORD_HDR_SIZE,
			    lpSeqNum,
			    lpMac_I_State,
			    lpMac_O_State,ProtType,SkipLen);
      break;
    //-------------------------------------------------
    // SHA256 selected, generate 
    //-------------------------------------------------
    case MAC_ALGOR_SHA256:
      GenerateSHA256CipherMac(InpData, InpOffset, InpDataLen,	// generate,
			    InpData, InpOffset+InpDataLen+RECORD_HDR_SIZE,
			    lpSeqNum,
			    lpMac_I_State,
			    lpMac_O_State,ProtType,SkipLen);
      break;
    case MAC_ALGOR_AES_GCM:
        m_init_aes_gcm_send(pConnStruc, InpData+InpOffset);
        break;
    default:					// should not occur
      return(HSSL_INVALID_MAC_ALGOR);
  } // switch
  //-------------------------------------------------
  // Increment Sequence Number (BIG ENDIAN !)
  //-------------------------------------------------
  IncSequenceNumber(lpSeqNum);
  //-------------------------------------------------
  // update actual length to new one, both in buffer
  // and pointer 
  //-------------------------------------------------
  DataLen[0] = NewLen-RECORD_HDR_SIZE;
 // InpData[InpOffset+RH_LENGTH_MSB] = (BIT8) (NewLen >> 8); // store MSB
 // InpData[InpOffset+RH_LENGTH_LSB] = (BIT8) NewLen;	   // store LSB
  return(HSSL_OP_OK);
}

/**
* Verifies the received MAC
* for enciphered blocks (if a MAC is selected) (VerifyRemoveCipherMac).
* Reduces block length if a MAC is present and
* increases appropriate sequence number.
*
*  @param pConnStruc Connection structure
*  @param InpData Base of Input data
*  @param InpOffset Offset to Input data
*  @param DataLen length of data, rel . Offset
*  @return HSSL_OP_OK on success, else error occured
*/
static   int  VerifyRemoveCipherMac(
		CONNSTRU * pConnStruc, char* InpData, int InpOffset,
	        int* DataLen)
{
  int i,j;
  int NewLen, MacLen, ProtType, SkipLen;
  int InpDataLen = DataLen[0];
  char chl_mac_res =0;
  char MacAlgor;

  char* lpSeqNum;
  int* lpMac_I_State;
  int* lpMac_O_State;

  char TmpBuf[MAX_MD5_SHA_DIGEST_LEN];
  //-------------------------------------------------
  // preload pointer, check if MAC algorithm <> MAC_ALGOR_NULL
  //-------------------------------------------------
  MacAlgor      = pConnStruc->ActRX_MACAlgor;
  if((MacAlgor == MAC_ALGOR_NULL) || (MacAlgor == MAC_ALGOR_AES_GCM)){
    return(HSSL_OP_OK);
  }

  ProtType = pConnStruc->ActualProtocol;		

  SkipLen = 0;

  // Check TLS V1.1 CBC Cipher mode and encryption active
  if(((ProtType == TLS_V1_PROT_TYPE) || (ProtType == TLS_V2_PROT_TYPE)) &&
     (pConnStruc->ActRX_EncAlgor != CIPHER_ALGOR_NULL) &&
     (pConnStruc->CipherType == ALGOR_TYPE_BLOCK))
  {
    SkipLen = pConnStruc->BlockLen;		// skip a block
  }

  lpSeqNum      = pConnStruc->ActRX_SeqNumber;
  lpMac_I_State = pConnStruc->ActRX_MAC_I_Array; 
  lpMac_O_State = pConnStruc->ActRX_MAC_O_Array; 
  //--------------------------------------------------------
  // MD5 / SHA1 selected, first check if enough data present
  //--------------------------------------------------------
  MacLen = pConnStruc->HashSize;	// same as selected hash size
  NewLen = InpDataLen - MacLen;		// length after remove
  if(NewLen < 0)
  {
    return(HSSL_MAC_TOO_FEW_DATA);	// too few data
  }
  //------------------------------------------------------------------
  // reduce the record length (by size of MAC) before doing the MAC !!
  //------------------------------------------------------
  BIGword2charn(NewLen,InpData,InpOffset+RH_LENGTH_MSB);

  switch(MacAlgor)
  {
    //-------------------------------------------------
    // MD5 selected, generate 
    //-------------------------------------------------
    case MAC_ALGOR_MD5:
      GenerateMD5CipherMac(InpData, InpOffset, NewLen,		// generate,
			   TmpBuf, 0,				// buffer
			   lpSeqNum,
			   lpMac_I_State,
			   lpMac_O_State,
			   ProtType,SkipLen);
      break;
    //-------------------------------------------------
    // SHA1 selected, generate 
    //-------------------------------------------------
    case MAC_ALGOR_SHA1:
      GenerateSHA1CipherMac(InpData, InpOffset, NewLen,		// generate,
			    TmpBuf, 0,				// buffer
			    lpSeqNum,
			    lpMac_I_State,
			    lpMac_O_State,
			    ProtType,SkipLen);
      break;
    //-------------------------------------------------
    // SHA256 selected, generate 
    //-------------------------------------------------
    case MAC_ALGOR_SHA256:
      GenerateSHA256CipherMac(InpData, InpOffset, NewLen,	// generate,
			    TmpBuf, 0,				// buffer
			    lpSeqNum,
			    lpMac_I_State,
			    lpMac_O_State,
			    ProtType,SkipLen);
      break;

    default:					// should not occur
      return(HSSL_INVALID_MAC_ALGOR);
  } // switch
  //-------------------------------------------------
  // Compare given MAC with own generated 
  //-------------------------------------------------
  j = InpOffset + InpDataLen - 1 + RECORD_HDR_SIZE;		// End of given MAC
  for(i = MacLen - 1;i >= 0;i--)
  {
    chl_mac_res |= (InpData[j--] ^ TmpBuf[i]);
  }
  if(0 != chl_mac_res)		// difference found
    {
      return(HSSL_MAC_VERIFY_ERR);
    }
  //-------------------------------------------------
  // Increment Sequence Number (BIG ENDIAN !)
  //-------------------------------------------------
  IncSequenceNumber(lpSeqNum);
  //-------------------------------------------------
  // update actual length to new one, both in buffer
  // and pointer 
  //-------------------------------------------------
  DataLen[0] = NewLen;
  return(HSSL_OP_OK);
}

/**
* Encrypts the record content of a TLS/SSL record (EncryptRecord).
*
*  @param pConnStruc Connection structure
*  @param InpData Base of input data
*  @param InpOffset Offset to input data
*  @param DataLen Length of data, rel . offset!
*  @param InpBufLen Length of buffer rel. offset!
*  @return HSSL_OP_OK on success, else error occured
*/
static  int  EncryptRecord(CONNSTRU * pConnStruc,
				     char* InpData, int InpOffset,
				     int* DataLen, int InpBufLen)
{
  int i;
  int j;
  int CryptLen;
  int BlockLen;
  int PaddingCnt;
  int BlockCnt;
  int CiphBlockSize;
//  int NewLen;
  int InpDataLen = DataLen[0];
  char EncAlgor;

  char* lpIV;

  char* lpRC4Stat;
  short* lpRC2Stat;
  int* lpDESStat1;
  int* lpDESStat2;
  int* lpDESStat3;
  int* lpAESStat;

  //-------------------------------------------------
  // preload pointer, check if Null encryption selected
  //-------------------------------------------------
  EncAlgor = pConnStruc->ActTX_EncAlgor;
  if(EncAlgor == CIPHER_ALGOR_NULL)
     return(HSSL_OP_OK);
  //-------------------------------------------------
  // Encryption selected, check stream/block
  //-------------------------------------------------
  if(EncAlgor == CIPHER_ALGOR_RC4)
  {
    //-------------------------------------------------
    // Process RC4 stream encryption (no length change)
    //-------------------------------------------------
    if(InpDataLen < 0)
      return(HSSL_ENCRYPT_INVALID_LEN);		// should not happen
    if(InpDataLen == 0)
      return(HSSL_OP_OK);			// no action required

    lpRC4Stat = pConnStruc->ActTX_RC4StateArrayPtr;
    RC4(InpData,InpOffset,InpDataLen,InpData,InpOffset,lpRC4Stat);
    return(HSSL_OP_OK);
  }

  if(EncAlgor == CIPHER_ALGOR_AES_GCM) {
      InpDataLen -= AES_GCM_EXPL_IV_LEN;
      InpOffset += AES_GCM_EXPL_IV_LEN;
      if(InpDataLen < 0){
        return(HSSL_ENCRYPT_INVALID_LEN);
      }

      // Check, if the MAC block can be added
      int inl_cipher_len = InpDataLen + AES_BLOCK_SIZE;
      if (inl_cipher_len > InpBufLen){
        return(HSSL_ENCRYPT_INVALID_LEN);
      }

      m_enc_update_aes_gcm_1(pConnStruc->adsc_send_gcm_state,
                             InpData + InpOffset,
                             InpData + InpOffset,
                             InpDataLen);

      m_enc_final_aes_gcm_1(pConnStruc->adsc_send_gcm_state,
                            InpData + InpOffset + InpDataLen,
                            AES_BLOCK_SIZE);

      *DataLen += AES_BLOCK_SIZE;

      return(HSSL_OP_OK);
  }

  //-------------------------------------------------
  // Block Cipher Selected, calculate padding to append
  //-------------------------------------------------
  CiphBlockSize = pConnStruc->BlockLen;	// get size of block
  BlockLen = InpDataLen + 1;			// plus padding length byte

  if((BlockLen <= 1) || (CiphBlockSize == 0))
    return(HSSL_ENCRYPT_INVALID_LEN);		// should not happen

  BlockCnt = (BlockLen + CiphBlockSize - 1)/	// calculate needed blocks
             CiphBlockSize;			// cannot be 0 (checked) !
  CryptLen = BlockCnt * CiphBlockSize;		// size of padded block
  PaddingCnt = CryptLen - BlockLen;
  //-------------------------------------------------
  // Check for enough Buffer Space for padding, append
  // padding
  //-------------------------------------------------
  j=InpDataLen + InpOffset;			// start of padding
  if(InpBufLen < CryptLen)
    return(HSSL_ENCRYPT_BUF_TOO_SHORT);		// not enough space
  if(PaddingCnt != 0)				// must apply more bytes
  {
    i=PaddingCnt;
    do{InpData[j++] = (char) PaddingCnt;i--;} while(i != 0); // append padding
  }
  InpData[j] = (char) PaddingCnt;		// append padding length
//  NewLen = CryptLen + RECORD_HDR_SIZE;
 // i = InpOffset + RECORD_HDR_SIZE;		// start of data
  //-------------------------------------------------
  // Get IV-Vector to use
  //-------------------------------------------------
  lpIV = pConnStruc->ActTX_IV;
  //---------------------------------------------------------
  // Distribute by selected algorithm
  //---------------------------------------------------------
  switch(EncAlgor)
  {
    //-------------------------------------------------
    // RC2_CBC selected, generate 
    //-------------------------------------------------
    case CIPHER_ALGOR_RC2_CBC:
      lpRC2Stat = pConnStruc->ActTX_RC2KeyArrayPtr; 
      RC2_cbc_encdecrypt(InpData,InpOffset,InpData,InpOffset,CryptLen,lpRC2Stat,lpIV,RC2_ENCRYPT);
      break;
    //-------------------------------------------------
    // DES_CBC selected, generate 
    //-------------------------------------------------
    case CIPHER_ALGOR_DES_CBC:
      lpDESStat1 = pConnStruc->ActTX_DESSubkey1TabPtr; 
      DES_cbc_encrypt_decrypt((unsigned char *)(InpData+InpOffset),
                              (unsigned char *)(InpData+InpOffset),
                              (unsigned int *) lpDESStat1,
			      BlockCnt,
			      (unsigned char *) lpIV,
			      DES_ENCRYPT);
      break;
    //-------------------------------------------------
    // 3DES_EDE_CBC selected, generate 
    //-------------------------------------------------
    case CIPHER_ALGOR_3DES_EDE_CBC:
      lpDESStat1 = pConnStruc->ActTX_DESSubkey1TabPtr; 
      lpDESStat2 = pConnStruc->ActTX_DESSubkey2TabPtr; 
      lpDESStat3 = pConnStruc->ActTX_DESSubkey3TabPtr; 
      DES3_ede_cbc_encrypt_decrypt((unsigned char *)(InpData+InpOffset),
                                   (unsigned char *)(InpData+InpOffset),
				   (unsigned int *) lpDESStat1,
				   (unsigned int *) lpDESStat2,
				   (unsigned int *) lpDESStat3,
				   BlockCnt,
			 	   (unsigned char *) lpIV,
				   DES_ENCRYPT);
      break;
    //-------------------------------------------------
    // AES_CBC selected, generate 
    //-------------------------------------------------
    case CIPHER_ALGOR_AES_CBC:
      lpAESStat = pConnStruc->ActTX_AESKeyArrayPtr; 
      m_aes_cbc_encrypt((unsigned char *) (InpData+InpOffset),
			(unsigned char *) (InpData+InpOffset),
			(ds_aes_key *) lpAESStat,BlockCnt,
			(unsigned char *) lpIV,
                        (pConnStruc->KeyLen/4) + 6);
      break;

    default:					// should not occur
      return(HSSL_ENCRYPT_INV_CIPH_ALGOR);
  } // switch
  //-------------------------------------------------
  // update actual length to new one, both in buffer
  // and pointer 
  //-------------------------------------------------
  DataLen[0] = CryptLen;
  //InpData[InpOffset+RH_LENGTH_MSB] = (BIT8) (NewLen >> 8); // store MSB
  //InpData[InpOffset+RH_LENGTH_LSB] = (BIT8) NewLen;	   // store LSB
  return(HSSL_OP_OK);
}

static int m_aes_gcm_decrypt(CONNSTRU * adsp_conn,
				             char* achp_data,
                             int* ainp_offset,
                             int* ainp_len)
{
    if(*ainp_len < (AES_GCM_EXPL_IV_LEN+AES_BLOCK_SIZE)) {
        // Input is smaller, than explicit IV and MAC tag
        return HSSL_DECRYPT_LEN_TOO_SHORT;
    }

    achp_data += *ainp_offset;

    // Prepare the IV
    unsigned char byrl_iv[AES_GCM_IV_TOTAL_LEN];
    memcpy(byrl_iv, adsp_conn->ActRX_IV, AES_GCM_IMPLICIT_IV_LEN);
    memcpy(byrl_iv+AES_GCM_IMPLICIT_IV_LEN, achp_data, AES_GCM_EXPL_IV_LEN);

    // Prepare additional data
    unsigned char byrl_additional_data[RECORD_HDR_SIZE+SEQUENCE_NUM_LEN];
    
    memcpy(byrl_additional_data, adsp_conn->ActRX_SeqNumber, SEQUENCE_NUM_LEN);
    memcpy(byrl_additional_data+SEQUENCE_NUM_LEN,
           achp_data-RECORD_HDR_SIZE,
           RECORD_HDR_SIZE);
    
    *ainp_len -=(AES_GCM_EXPL_IV_LEN+AES_BLOCK_SIZE);
    *ainp_offset += AES_GCM_EXPL_IV_LEN;
    achp_data += AES_GCM_EXPL_IV_LEN;
    
    unsigned char* byrl_tag = (unsigned char*)achp_data+*ainp_len;

    int inl_ret = m_aes_gcm_auth_dec(byrl_iv,
                                     AES_GCM_IV_TOTAL_LEN,
                                     byrl_additional_data,
                                     (RECORD_HDR_SIZE+SEQUENCE_NUM_LEN),
                                     (ds_aes_key*)adsp_conn->ActRX_AESKeyArrayPtr,
                                     adsp_conn->KeyLen,
                                     (unsigned char*)achp_data,
                                     *ainp_len,
                                     (unsigned char*)achp_data,
                                     *ainp_len,
                                     byrl_tag,
                                     AES_BLOCK_SIZE);

    if( inl_ret != 0 ){
        return HSSL_MAC_VERIFY_ERR;
    }

    return HSSL_OP_OK;
}

/**
* Decrypts the record content of a SSL record (DecryptRecord). 
*<ol>
* <li> For Stream Ciphers, the length is not changed
* <li> For Block Ciphers, the length will be reduced
*    according to the padding length. <ul>
*    <li> For Block Ciphers in TLS V1.1 mode, additionally the first
*      block has to be discarded. The offset will be increased.<br>
*      The length will be kept same as not to break
*	    MAC removal!</ul>
*</ol>
*  @param pConnStruc Connection structure
*  @param InpData Base of input data
*  @param pInpOffset IN: Offset to input data <br>
*               OUT: New offset (TLSV1.1 CBC)
*  @param DataLen Length of data, rel . offset!
*  @return HSSL_OP_OK on success, else error occured
*/
static  int  DecryptRecord(
				      CONNSTRU * pConnStruc,
				      char* InpData, int* pInpOffset,
				      int* DataLen)
{
  int j;

  int PaddingCnt,BlockCnt,CiphBlockSize;
  int InpOffset,NewLen;
  int InpDataLen = DataLen[0];
  char EncAlgor;
  int inl_ret_val = HSSL_OP_OK;

  char* lpIV;

  char* lpRC4Stat;
  short* lpRC2Stat;
  int* lpDESStat1;
  int* lpDESStat2;
  int* lpDESStat3;
  int* lpAESStat;

  //-------------------------------------------------
  // preload pointer, check if NULL encryption selected
  //-------------------------------------------------
  EncAlgor = pConnStruc->ActRX_EncAlgor;
  if(EncAlgor == CIPHER_ALGOR_NULL)
    return(HSSL_OP_OK);
  InpOffset = pInpOffset[0];
  //-------------------------------------------------
  // Encryption selected, check stream/block
  //-------------------------------------------------
  if(EncAlgor == CIPHER_ALGOR_RC4)
  {
    //-------------------------------------------------
    // Process RC4 stream decryption (no length change)
    //-------------------------------------------------
    if(InpDataLen < 0)
      return(HSSL_DECRYPT_INVALID_LEN);		// should not happen
    if(InpDataLen == 0)
      return(HSSL_OP_OK);			// no action required
    lpRC4Stat = pConnStruc->ActRX_RC4StateArrayPtr;
    RC4(InpData,InpOffset,InpDataLen,InpData,InpOffset,lpRC4Stat);

    return(HSSL_OP_OK);
  }

  if(EncAlgor == CIPHER_ALGOR_AES_GCM) {
      return m_aes_gcm_decrypt(pConnStruc,
                               InpData,
                               pInpOffset,
                               DataLen);
  }
  //-------------------------------------------------
  // Block Cipher Selected, check for correct length
  //-------------------------------------------------
  CiphBlockSize = pConnStruc->BlockLen;	// get size of cipherblock
  if((InpDataLen < CiphBlockSize) || (CiphBlockSize == 0))
  {

    return(HSSL_DECRYPT_LEN_TOO_SHORT);		// should not happen
  }
  BlockCnt = InpDataLen / CiphBlockSize;	// get number of blocks
  if((BlockCnt * CiphBlockSize) != InpDataLen)	// not valid padded
  {

    return(HSSL_DECRYPT_INVALID_LEN);
  }
 // i = InpOffset + RECORD_HDR_SIZE;		// start of data
  //-------------------------------------------------
  // Get IV-Vector to use
  //-------------------------------------------------
  lpIV = pConnStruc->ActRX_IV;
  //---------------------------------------------------------
  // Distribute by selected algorithm
  //---------------------------------------------------------
  switch(EncAlgor)
  {
    //-------------------------------------------------
    // RC2_CBC selected, decrypt 
    //-------------------------------------------------
    case CIPHER_ALGOR_RC2_CBC:
      lpRC2Stat = pConnStruc->ActRX_RC2KeyArrayPtr; 
      RC2_cbc_encdecrypt(InpData,InpOffset,InpData,InpOffset,InpDataLen,lpRC2Stat,lpIV,RC2_DECRYPT);
      break;
    //-------------------------------------------------
    // DES_CBC selected, decrypt
    //-------------------------------------------------
    case CIPHER_ALGOR_DES_CBC:
      lpDESStat1 = pConnStruc->ActRX_DESSubkey1TabPtr; 
      DES_cbc_encrypt_decrypt((unsigned char *)(InpData+InpOffset),
                              (unsigned char *)(InpData+InpOffset),
			      (unsigned int *) lpDESStat1,
			      BlockCnt,
			      (unsigned char *) lpIV,
			      DES_DECRYPT);
      break;
    //-------------------------------------------------
    // 3DES_EDE_CBC selected, decrypt
    //-------------------------------------------------
    case CIPHER_ALGOR_3DES_EDE_CBC:
      lpDESStat1 = pConnStruc->ActRX_DESSubkey1TabPtr; 
      lpDESStat2 = pConnStruc->ActRX_DESSubkey2TabPtr; 
      lpDESStat3 = pConnStruc->ActRX_DESSubkey3TabPtr; 
      DES3_ede_cbc_encrypt_decrypt((unsigned char *)(InpData+InpOffset),
				   (unsigned char *)(InpData+InpOffset),
				   (unsigned int *) lpDESStat1,
				   (unsigned int *) lpDESStat2,
				   (unsigned int *) lpDESStat3,
				   BlockCnt,
				   (unsigned char *) lpIV,
				   DES_DECRYPT);
      break;
    //-------------------------------------------------
    // AES_CBC selected, decrytp 
    //-------------------------------------------------
    case CIPHER_ALGOR_AES_CBC:
      lpAESStat = pConnStruc->ActRX_AESKeyArrayPtr; 
      m_aes_cbc_decrypt((unsigned char*) (InpData+InpOffset),
			(unsigned char*) (InpData+InpOffset),
                        (ds_aes_key *) lpAESStat, BlockCnt,
			(unsigned char *) lpIV,
                        (pConnStruc->KeyLen/4) + 6);
      break;

    default:					// should not occur
      return(HSSL_DECRYPT_INV_CIPH_ALGOR);
  } // switch
  //-------------------------------------------------------
  // get padding value, check correct padding (TLS only !!)
  //-------------------------------------------------------
  j = InpOffset + InpDataLen -1;		// to last byte
  PaddingCnt = (int) InpData[j--] & 0xFF;	// get padding count
  if((PaddingCnt >= CiphBlockSize) &&		// for SSL must be < Blocklen!
     (pConnStruc->ActualProtocol == SSL_PROT_TYPE))
  {
    // Invalid padding length, set length to 0 and error code
    inl_ret_val |= (HSSL_DECRYPT_INVALID_PADDING);
    PaddingCnt = 0;
  }
  NewLen = InpDataLen - PaddingCnt -1;		// get new length
  if(NewLen < 0)
  {
    inl_ret_val |= (HSSL_DECRYPT_INVALID_PADDING);	// too few data remaining
  }
  // Verify padding data, only required for TLS V1.0/V1.1
  if((PaddingCnt != 0) && (pConnStruc->ActualProtocol != SSL_PROT_TYPE))
  {
    inl_ret_val |= m_const_pad_compare(PaddingCnt, j-(PaddingCnt-1), InpData);
  }
  // Do dummy comparisons (Lucky 13 attack)
  m_const_pad_compare(256-PaddingCnt, 0, abys_dummy_pad);

  // Perform dummy compressions as needed (Lucky 13 attack)
  if( HSSL_OP_OK == inl_ret_val ){
     // Perform necessary dummy compressions here
     m_dummy_compress(pConnStruc, DataLen[0], PaddingCnt);
  } else {
     // Some error happend. Do a call for 0-length dummy compressions
     m_dummy_compress(pConnStruc, 0, -1);
     // Reset data length to full length, before removing padding
     NewLen = InpDataLen;
  }
  
  //-------------------------------------------------
  // update actual OFFSET only !
  //-------------------------------------------------
  if((pConnStruc->ActualProtocol == TLS_V1_PROT_TYPE) ||
     (pConnStruc->ActualProtocol == TLS_V2_PROT_TYPE))
  {
    InpOffset += CiphBlockSize;		// skip 1st block !
    pInpOffset[0] = InpOffset;
  }
  DataLen[0] = NewLen;

  return(HSSL_OP_OK);
}

/**
* Updates MD5/SHA1/SHA256/SHA512 hashes
* for handshake messages (HashHandshakeMessage).
* RX and TX have the same hash array.
*
*  @param pConnStruc Connection structure
*  @param InpData Base of input data
*  @param InpOffset Offset to input data
*  @param DataLen Length of data, rel . offset
*/
static  void  HashHandshakeMessage(CONNSTRU * pConnStruc,
		     char* InpData, int InpOffset, int DataLen)
{
  int* lpMD5State;
  int* lpSHA1State;
  int* lpSHA256State;
  long long* lpSHA512State;
  //-------------------------------------------------------
  // Get associates hash state pointers
  //-------------------------------------------------------
  lpMD5State  = pConnStruc->HandshakeMD5_State;  
  lpSHA1State = pConnStruc->HandshakeSHA1_State;  
  lpSHA256State = pConnStruc->HandshakeSHA256_State;
  lpSHA512State = pConnStruc->HandshakeSHA512_State;
  //-------------------------------------------------------
  // Update the hashes
  //-------------------------------------------------------
  MD5_Update(lpMD5State,InpData,InpOffset,DataLen);	// hash message
  SHA1_Update(lpSHA1State,InpData,InpOffset,DataLen);	// hash message
  SHA256_Update(lpSHA256State,InpData,InpOffset,DataLen); // dto.
  SHA384_512_Update(pConnStruc->HandshakeSHA384_State,InpData,InpOffset,DataLen); // dto.
  SHA384_512_Update(lpSHA512State,InpData,InpOffset,DataLen); // dto.
#if XH_INTF_VERSION==300
  m_event_trace_lvl(pConnStruc->adsc_logger, HL_AUX_WT_DATA2);
  m_add_text_data(pConnStruc->adsc_logger, "Hashed Handshake message:",25); 
  m_add_binary_data(pConnStruc->adsc_logger, InpData+InpOffset, DataLen);
  m_make_log_entry(pConnStruc->adsc_logger, "SSLHSH");
#endif
}

/**
* Compresses a record before
* encryption takes place (CompressRecord).
* The destination buffer must be different from
*    the source.
*
*  @param pConnStruc Connection structure
*  @param SrcBuf Base of data
*  @param SrcOff Offset to data
*  @param SrcLen Length of input data, excl. HDR
*  @param DstBuf Base of data
*  @param DstOff Offset to data
*  @param pDstLen in: length of buffer <br>
*               out: compressed data count,
*               excl. header
*  @return HSSL_OP_OK on success, else error occured
*/
static  int  CompressRecord(CONNSTRU * pConnStruc,
			char* SrcBuf, int SrcOff, int SrcLen,
			char* DstBuf, int DstOff, int* pDstLen)
{
  DCDR* pCdr;
  HMEM_CTX_DEF1;
  //---------------------------------------------------
  // Check parameters
  //---------------------------------------------------
  if((pConnStruc == NULL) || (SrcBuf == NULL) ||
     (DstBuf == NULL) || (pDstLen == NULL))
    return(HSSL_NULL_PTR);

  if(pDstLen[0] < SrcLen)
    return(HSSL_COMPR_BUF_TOO_SHORT);

  LOAD_HMEM_CTX_PTR(CONN_pMemCtx(pConnStruc));
  //---------------------------------------------------
  // Distribute according to active transmit method
  //---------------------------------------------------
  switch((int) pConnStruc->ActTX_ComprAlgor & 0xFF)
  {
    //-------------------------------------------------
    // V42bis Compression
    //-------------------------------------------------
    case COMPR_V42BIS:
      pCdr = pConnStruc->ActTX_V42BisCdrPtr;// get structure pointer
      if(pCdr == NULL)
        return(HSSL_COMPR_NULL_PTR);
      //-----------------------------------------------
      // setup parameters for compression, compress
      //-----------------------------------------------
//      BIGword2charn(SrcLen,DstBuf,DstOff);	// set uncompressed length
      pCdr->SrcBuf   = SrcBuf;
      pCdr->SrcStartIndex = SrcOff;		// Starting offset
      pCdr->SrcEndIndex  = SrcOff+SrcLen;	// Ending Offset
      pCdr->DstBuf	 = DstBuf;
//      CDR_DST_STRT(pCdr) = DstOff+COMPR_V42_LEN_SIZE;	// Starting Index
      pCdr->DstStartIndex = DstOff;		// Starting Index
      pCdr->DstEndIndex  = DstOff+ pDstLen[0];		// Ending Index
      CdrEnc(HMEM_CTX_REF1 pCdr);
      pCdr->SrcBuf   = NULL; 		// release buffer !
      pCdr->DstBuf   = NULL; 		// dto.
      if(pCdr->ireturn != DEF_IRET_NORMAL)
        return(HSSL_COMPR_FAILED);
      pDstLen[0] = pCdr->DstStartIndex - DstOff;
      if(pConnStruc->ConnectionState == CONN_STATE_CONNECTED)
      {
        ADD_64(pConnStruc->ComprTXDataMSW,pConnStruc->ComprTXDataLSW,
	       (int) pDstLen[0]);
      }
      return(HSSL_OP_OK);

   case COMPR_NULL:			// must not happen !!
   default:
     return(HSSL_COMPR_INVALID_METHOD);	
  }
}

/**
* Decompresses a record after decryption operation (DecompressRecord).
*
* The decompression process normally increases the original data
*       (except method COMPR_NULL) so a new buffer will be allocated
*       and returned.
*
*	 The Destination data will have NO header.
*
*  @param pConnStruc Connection structure
*  @param SrcBuf Base of data
*  @param SrcOff Offset to data
*  @param pDstBuf Allocated destination buffer
*  @param pDstLen in: Length of source data,
*               no header <br>
*               out: Decompressed data count
*  @return HSSL_OP_OK on success, else error occured
*/
static  int  DecompressRecord(CONNSTRU * pConnStruc,
			char* SrcBuf, int SrcOff, char** pDstBuf,
			int* pDstLen)
{
  int SrcLen;
  int BufLen;

  char* pBuf;
  DCDR* pCdr;
  HMEM_CTX_DEF1;

  //---------------------------------------------------
  // Check parameters
  //---------------------------------------------------
  if((pConnStruc == NULL) || (SrcBuf == NULL) ||
     (pDstBuf == NULL) || (pDstLen == NULL))
    return(HSSL_NULL_PTR);

  LOAD_HMEM_CTX_PTR(CONN_pMemCtx(pConnStruc));

  pDstBuf[0] = NULL;			// no buffer given
  SrcLen = pDstLen[0];			// get the length
  //---------------------------------------------------
  // Distribute according to active receive method
  //---------------------------------------------------
  switch((int) pConnStruc->ActRX_ComprAlgor & 0xFF)
  {
    //-------------------------------------------------
    // V42bis Compression
    //-------------------------------------------------
    case COMPR_V42BIS:
    //  if(SrcLen <= COMPR_V42_LEN_SIZE)	// no uncompressed data/data length !
      if(SrcLen <= 0)  
       return(HSSL_DECOMPR_INVALID_DATA);	
      pCdr = pConnStruc->ActRX_V42BisCdrPtr; // get structure pointer
      if(pCdr == NULL)
        return(HSSL_DECOMPR_NULL_PTR);
      //------------------------------------------------
      // allocate buffer for uncompressed data
      //------------------------------------------------
//      BIGchar2wordn(SrcBuf,BufLen,SrcOff);	// get uncompr. size, skip
//      if((BufLen <= 0) || (BufLen > SSL_PLAIN_RECORD_MAX_LEN))
//        return(HSSL_DECOMPR_INVALID_DATA);	
//      pBuf = BIT8_ARRAY_ALLOC(BufLen);		// get destination buffer

      pBuf = BIT8_ARRAY_ALLOC_POOL(HMEM_CTX_REF,
			SSL_PLAIN_RECORD_MAX_LEN); // allocate max. buf.
      if(pBuf == NULL)
        return(HSSL_OP_OK);
      //-----------------------------------------------
      // setup parameters for compression, compress
      //-----------------------------------------------
      pCdr->SrcBuf   = SrcBuf;
//      CDR_SRC_STRT(pCdr) = SrcOff+COMPR_V42_LEN_SIZE;
      pCdr->SrcStartIndex = SrcOff;
      pCdr->SrcEndIndex  = SrcOff+SrcLen;
      pCdr->DstBuf   = pBuf;
      pCdr->DstStartIndex = 0;
//      CDR_DST_END(pCdr)  = BufLen;
      pCdr->DstEndIndex  = SSL_PLAIN_RECORD_MAX_LEN;
      CdrDec(HMEM_CTX_REF1 pCdr);
//      if((CDR_RETCODE(pCdr) != DEF_IRET_NORMAL) ||
//         (CDR_DST_STRT(pCdr) != BufLen))
      if(pCdr->ireturn != DEF_IRET_NORMAL)
      {
        FREE_ARRAY_POOL(HMEM_CTX_REF,pBuf);
        return(HSSL_DECOMPR_FAILED);
      }        
      BufLen = pCdr->DstStartIndex;
      if(pConnStruc->ConnectionState == CONN_STATE_CONNECTED)
      {
        ADD_64(pConnStruc->ComprRXDataMSW,pConnStruc->ComprRXDataLSW,
	       (int) SrcLen);
      }
      pDstBuf[0] = pBuf;
      pDstLen[0] = BufLen;
      return(HSSL_OP_OK);

    case COMPR_NULL:			// must not happen !!
    default:
      return(HSSL_DECOMPR_INVALID_METHOD);	
  }
}

/**
* Generates the RSA pre-master secret as defined in RFC 4346 (GenerateRSAPreMasterSecret).
* Random generator must be already seeded.
*
*  @param pConnStruc Connection structure
*
*  @return HSSL_OP_OK on success, else error occured
*/
static  int  GenerateRSAPreMasterSecret(CONNSTRU * pConnStruc)
{

  int Retcode;
  char* pPreMasterSecret;			// base PreMaster Secret
  HMEM_CTX_DEF1;

  LOAD_HMEM_CTX_PTR(CONN_pMemCtx(pConnStruc));

  //---------------------------------------------------------
  // Allocate buffer for Pre-Master Secret, get random
  //---------------------------------------------------------
  pPreMasterSecret  = BIT8_ARRAY_ALLOC(HMEM_CTX_REF,
			RSA_PRE_MASTER_SECRET_LEN);
  if(pPreMasterSecret == NULL)
    return(HSSL_RSA_PREMASTER_ALLOC_ERR);
  if((Retcode = SecDrbgRandBytes(HMEM_CTX_REF1 pPreMasterSecret,2,RSA_PRE_MASTER_SECRET_LEN-2)) != 0)
  {
    FREE_ARRAY(HMEM_CTX_REF,pPreMasterSecret);
    return(HSSL_RSA_PREMASTER_RNG_ERR);
  }
  //---------------------------------------------------------
  // Insert highest possible Version into the first 2 bytes
  //---------------------------------------------------------
  pPreMasterSecret[0] = TLS_SSL_MAJOR_VERSION; // set Version High part

  if((pConnStruc->SupportedProtocolsFlags & TLS_V2_BIT_MASK) != 0) // can use TLS V1.2
    pPreMasterSecret[1] = TLS12_MINOR_VERSION;
  else if((pConnStruc->SupportedProtocolsFlags & TLS_V1_BIT_MASK) != 0) // can use TLS V1.1
    pPreMasterSecret[1] = TLS11_MINOR_VERSION;
  else if((pConnStruc->SupportedProtocolsFlags & TLS_BIT_MASK) != 0) // can use TLS V1.0
    pPreMasterSecret[1] = TLS10_MINOR_VERSION;
  else							// use SSL V3
    pPreMasterSecret[1] = SSL_MINOR_VERSION;

  pConnStruc->PreMasterSecrPtr = pPreMasterSecret;
  pConnStruc->PreMasterSecrLen = RSA_PRE_MASTER_SECRET_LEN;
  return(HSSL_OP_OK);
}

/**
* RSA encrypts the pre-master secret with the server public exponent and
* modulus (RSAEncPreMasterSecret).
*
*  @param pConnStruc Connection structure
*  @param rsa Loaded RSA structure
*  @param pDstBuf Destination base
*  @param DstOff Offset to start
*  @param pDstLen Length (In/Out)
*
*  @return HSSL_OP_OK on success else Error
*/
static  int  RSAEncPreMasterSecret(CONNSTRU * pConnStruc,
				RSA_STRUC* rsa,
				char* pDstBuf, int DstOff, int* pDstLen)
{
  int Retcode;
 
  HMEM_CTX_DEF1;
  LOAD_HMEM_CTX_PTR(CONN_pMemCtx(pConnStruc)); 

  //------------------------------------------------------------
  // RSA Public encrypt the premaster secret
  // must use zero fill mode here, no leading zero if neg.
  //------------------------------------------------------------
  Retcode = RSA_PublicEncrypt(HMEM_CTX_REF1 pConnStruc->PreMasterSecrPtr,0,RSA_PRE_MASTER_SECRET_LEN,pDstBuf,DstOff,pDstLen,rsa,1);
  if(Retcode != RSA_OP_OK)
    return(HSSL_RSA_PREMASTER_PUBL_ENC_ERR);

  return(HSSL_OP_OK);
}

/**
* RSA decrypts the pre-master secret with the server private key (RSADecrPreMasterSecret).
*
* The premaster secret is stored in the connection structure, using a newly
* allocated buffer.
*
*  @param pConnStruc Connection structure
*  @param rsa Loaded RSA structure
*  @param SrcBuf Source base
*  @param SrcOff Offset to start
*  @param SrcLen Length
*
*  @return HSSL_OP_OK on success
*/
static  int  RSADecrPreMasterSecret(CONNSTRU * pConnStruc,
		RSA_STRUC* rsa, char* SrcBuf, int SrcOff, int SrcLen)
{

  int Retcode;
  int DstLen[1];

  char* pPreMasterSecret;
  HMEM_CTX_DEF1;

  LOAD_HMEM_CTX_PTR(CONN_pMemCtx(pConnStruc));

  pConnStruc->PreMasterSecrLen=0;		 // no secret
  //---------------------------------------------------
  // 1. allocate buffer for Pre-Master secret
  //---------------------------------------------------
  pPreMasterSecret = BIT8_ARRAY_ALLOC(HMEM_CTX_REF,
				      RSA_PRE_MASTER_SECRET_LEN+1);
  if(pPreMasterSecret == NULL)
    return(HSSL_RSA_PREMASTER_DEC_ALLOC_ER);
  //---------------------------------------------------------
  // 2. RSA Private decrypt the premaster secret
  //---------------------------------------------------------
  DstLen[0] = RSA_PRE_MASTER_SECRET_LEN+1;
  Retcode = RSA_PrivateDecrypt(HMEM_CTX_REF1 SrcBuf,SrcOff,SrcLen,pPreMasterSecret,DstLen,rsa);
  if(Retcode != RSA_OP_OK)
  {
    FREE_ARRAY(HMEM_CTX_REF,pPreMasterSecret);
    return(HSSL_RSA_PREMASTER_PRIV_DEC_ERR);
  }
  // Check maximum supported version as from client hello now !!
  // if wrong, pretend decryption error -> Klima/Pokorny/Rosa Attack
  if((pPreMasterSecret[0] != (char) TLS_SSL_MAJOR_VERSION) ||
     (pPreMasterSecret[1] != pConnStruc->MaximumProtocol))
  {
    FREE_ARRAY(HMEM_CTX_REF,pPreMasterSecret);
    return(HSSL_RSA_PREMASTER_PRIV_DEC_ERR);
  }

  pConnStruc->PreMasterSecrLen = DstLen[0];
  pConnStruc->PreMasterSecrPtr = pPreMasterSecret;
  return(HSSL_OP_OK);
}

/**
* Generates the premaster secret from exchanged DH parameters (GenerateDHPreMasterSecret).
* The premaster secret is stored in the connection structure, using a newly
* allocated buffer.
* When invoked from client site checks / generates Yc if not
* present and puts to the LclTmpDh Structure for send.
*
* Random generator must be already seeded.
*
*  @param pConnStruc Connection structure
*
*  @return HSSL_OP_OK on success, else error occured
*/
static  int  GenerateDHPreMasterSecret(CONNSTRU * pConnStruc)
{
  int Retcode;

  int PrimeSize;
  int BaseSize;

  WLARGENUM* pLnum = NULL;

  DH_STRUC* pDhRemStruc;
  DH_STRUC* pDhLclStruc;

  char* pTmpBuf[1];
  int pTmpLen[1];
  HMEM_CTX_DEF1;

  LOAD_HMEM_CTX_PTR(CONN_pMemCtx(pConnStruc));
  
  //----------------------------------------------------------
  pDhRemStruc = pConnStruc->pRemoteDhStruc;
  pDhLclStruc = pConnStruc->pLocalDhStruc;
  //----------------------------------------------------------
  // check which site to generate
  //----------------------------------------------------------
  if(pConnStruc->Entity == SERVER_ENTITY)	// Server site
  {
    //---------------------------------------------------------------
    // Server Entity, check parameters
    //---------------------------------------------------------------
    if((pDhRemStruc == NULL) || (pDhLclStruc == NULL))	// should not happen
      return(HSSL_NULL_PTR);
    //---------------------------------------------------------------
    // move Yc from the remote DH structure to the local DH structure
    //---------------------------------------------------------------
    ClearFreeWLnum(HMEM_CTX_REF1 pDhLclStruc->PubKey);	// discard Ys
    pDhLclStruc->PubKey = pDhRemStruc->PubKey; // get Yc into local
    pDhRemStruc->PubKey = NULL;		// invalidate
    DH_Free(HMEM_CTX_REF1 pDhRemStruc);// not longer needed
    pConnStruc->pRemoteDhStruc = NULL;
    //---------------------------------------------------------------
    // generate Z = Yc^Xs mod p from local DH structure
    //---------------------------------------------------------------
    Retcode = DH_GenSecret(HMEM_CTX_REF1 pTmpBuf,pTmpLen,pDhLclStruc);
    if(Retcode != DH_OP_OK)
      return(HSSL_DH_PREMASTER_KEYGEN_ERR);
    DH_Free(HMEM_CTX_REF1 pDhLclStruc);
    pConnStruc->pLocalDhStruc = NULL;
  }
  else
  {
    //---------------------------------------------------------------
    // Client Entity, check parameters
    //---------------------------------------------------------------
    if(pDhRemStruc == NULL)			// should not happen
      return(HSSL_NULL_PTR);
    if(pDhLclStruc == NULL)			// no parameters yet !
    {
      //---------------------------------------------------------------
      // Allocate temporary DH structure, copy p,g and generate Yc, Xc
      //---------------------------------------------------------------
      PrimeSize = pDhRemStruc->p->UsedSize;
      BaseSize  = pDhRemStruc->g->UsedSize;
      pDhLclStruc = DH_New(HMEM_CTX_REF1 PrimeSize,0,BaseSize,PrimeSize,PrimeSize);
      if(pDhLclStruc == NULL)
        return(HSSL_DH_PREMASTER_ALLOC_ERR);
      Retcode = CopyWLnum(HMEM_CTX_REF1 pDhLclStruc->p,pDhRemStruc->p);
      if(Retcode != LNUM_OP_OK)
        return(HSSL_DH_PREMASTER_LNUM_ERR);
      Retcode = CopyWLnum(HMEM_CTX_REF1 pDhLclStruc->g,pDhRemStruc->g);
      if(Retcode != LNUM_OP_OK)
        return(HSSL_DH_PREMASTER_LNUM_ERR);

      Retcode = DH_GenKey(HMEM_CTX_REF1 pDhLclStruc,NULL);
      if(Retcode != DSA_DH_OP_OK)
        return(HSSL_DH_PREMASTER_KEYGEN_ERR);
      pConnStruc->pTmpDhStruc = pDhLclStruc;	// save for Yc send !
    }
    //-----------------------------------------------------------------
    // move Xc from the 'local' DH structure to the remote DH structure
    //-----------------------------------------------------------------
    pLnum = pDhRemStruc->PrivKey;		// get the unused
    pDhRemStruc->PrivKey = pDhLclStruc->PrivKey; // put Xc into remote
    pDhLclStruc->PrivKey = NULL;		// invalidate
    ClearFreeWLnum(HMEM_CTX_REF1 pLnum); // discard Ys
    //---------------------------------------------------------------
    // generate Z = Ys^Xc mod p from remote DH structure
    //---------------------------------------------------------------
    Retcode = DH_GenSecret(HMEM_CTX_REF1 pTmpBuf,pTmpLen,pDhRemStruc);
    if(Retcode != DH_OP_OK)
      return(HSSL_DH_PREMASTER_SECRET_ERR);
    DH_Free(HMEM_CTX_REF1 pDhRemStruc);
    pConnStruc->pRemoteDhStruc = NULL;
    DH_Free(HMEM_CTX_REF1 pConnStruc->pLocalDhStruc);// do  n o t free local variable!
    pConnStruc->pLocalDhStruc = NULL;
  }
  pConnStruc->PreMasterSecrLen = pTmpLen[0];
  pConnStruc->PreMasterSecrPtr = pTmpBuf[0];
  return(HSSL_OP_OK);
}

/**
* Generates the master secret from Server Random, Client Random and the
* Pre-Master secret (GenerateMasterSecret). 
* Stores it in the connection structure,
* clears the pre-master secret and frees it.
*
*  @param pConnStruc Connection structure
*
*/
static  void  GenerateMasterSecret(CONNSTRU * pConnStruc)
{
  char	c;

  int	i,j;
  int	padcnt=1;
  int	Index =0;
  int	blockcnt=3;				// 3 Blocks
  int   ProtType;

  int	PreMasterSecretLen =
          pConnStruc->PreMasterSecrLen;

  char* pSrvrRnd = pConnStruc->ServerRandom;	// base Server Random
  char* pClntRnd = pConnStruc->ClientRandom;	// base Client Random

  char* pMasterSecret =			// base Master Secret
          pConnStruc->MasterSecret;
  char* pPreMasterSecret =			// base PreMaster Secret
          pConnStruc->PreMasterSecrPtr;

						// also used for SHA1:
  char TmpBuf[(SERVER_HELLO_RANDOM_LEN+CLIENT_HELLO_RANDOM_LEN)];

  int StateArray[MAX_MD5_SHA1_STATE_SIZE];

  HMEM_CTX_DEF1;

  LOAD_HMEM_CTX_PTR(CONN_pMemCtx(pConnStruc));

  ProtType = pConnStruc->ActualProtocol;
  if(ProtType == SSL_PROT_TYPE)			// SSL V3.0
  {
    //-------------------------------------------------------
    // Generate SSL 3.0 Master Secret
    //-------------------------------------------------------
    do
    {
      c = (char) (padcnt + 0x40);		// get start value
      j = 0;					// clear index
      i = padcnt;
      do {TmpBuf[j++] = c; i--;} while(i != 0);	// fill buffer
      SHA1_Init(StateArray);		// initialize
						// Hash Start Byte(s)
      SHA1_Update(StateArray,TmpBuf,0,padcnt);
						// Hash PreMaster Secret
      SHA1_Update(StateArray,pPreMasterSecret,0,PreMasterSecretLen);
						// Hash Client Random
      SHA1_Update(StateArray,pClntRnd,0,CLIENT_HELLO_RANDOM_LEN);
						// Hash Server Random
      SHA1_Update(StateArray,pSrvrRnd,0,SERVER_HELLO_RANDOM_LEN);
      SHA1_Final(StateArray,TmpBuf,0);	// store digest

      MD5_Init(StateArray);		// initialize
						// hash premaster secret
      MD5_Update(StateArray,pPreMasterSecret,0,PreMasterSecretLen);
						 // hash the SHA1 hash
      MD5_Update(StateArray,TmpBuf,0,SHA_DIGEST_LEN);
      MD5_Final(StateArray,pMasterSecret,Index); // store digest
      Index += MD5_DIGEST_LEN;

      padcnt ++;
      blockcnt--;
    }while(blockcnt != 0);
  }
  else						// TLS V1.0
  {
    //-------------------------------------------------------
    // Generate TLS 1.0/1.1 Master Secret
    //-------------------------------------------------------
						// get seed 1st part
    memcpy(TmpBuf+0,pClntRnd+0,CLIENT_HELLO_RANDOM_LEN);
						// get seed 2nd part
    memcpy(TmpBuf+CLIENT_HELLO_RANDOM_LEN,pSrvrRnd+0,SERVER_HELLO_RANDOM_LEN);

    if(ProtType <= TLS_V1_PROT_TYPE)		// TLS 1.0/1.1
      TLS_Prf(pPreMasterSecret,0,PreMasterSecretLen,
	      MasterSecrLabelStr,MASTER_SECR_LABEL_STR_LEN,
	      TmpBuf,0,CLIENT_HELLO_RANDOM_LEN+SERVER_HELLO_RANDOM_LEN,
	      pMasterSecret,0,MASTER_SECRET_LEN);
    else
      TLS_12_Prf( HMEM_CTX_REF1 pPreMasterSecret,0,PreMasterSecretLen,		// TLS 1.2
	      MasterSecrLabelStr,MASTER_SECR_LABEL_STR_LEN,
	      TmpBuf,0,CLIENT_HELLO_RANDOM_LEN+SERVER_HELLO_RANDOM_LEN,
	      pMasterSecret,0,MASTER_SECRET_LEN);
  }
  //-------------------------------------------------------
  // Clear Pre-Master Secret and free it
  //-------------------------------------------------------
  ClearBit8Array(pPreMasterSecret,PreMasterSecretLen);
  FREE_ARRAY(HMEM_CTX_REF,pPreMasterSecret);
  pConnStruc->PreMasterSecrPtr = NULL;
  pConnStruc->PreMasterSecrLen = 0;
}

/**
* Generates server and client
* Write Keys, IVs and MAC secrets from server random,
* client random and the master secret (ConvertMasterSecret).
*
* Only the pending states are reloaded to support
*       renegotiation.
*
*  @param pConnStruc Connection structure
*/
static  void  ConvertMasterSecret(CONNSTRU * pConnStruc)
{
  char	c;

  int	i,j;
  int	padcnt=1;
  int	MacLen = 0;
  int	KeyLen;
  int	IVLen=0;
  int	len;
  int	Index=0;
  int	blockcnt;
  int ProtType;

  char* TmpBase1;
  char* TmpBase2;
  char* TmpBase3;
  char* TmpBase4;
  char* TmpBase5;
  char* TmpBase6;

  char* pSrvrRnd = pConnStruc->ServerRandom;	// base Server Random
  char* pClntRnd = pConnStruc->ClientRandom;	// base Client Random

  char* pMasterSecret =			// base Master Secret
          pConnStruc->MasterSecret;

						// Also for SHA1/MD5:
  char TmpBuf[(SERVER_HELLO_RANDOM_LEN+CLIENT_HELLO_RANDOM_LEN)];
  char KeyBlock[MAX_KEY_BLOCK_LEN];
  char IVBlock[MAX_IV_LEN];		// for TLS

  int StateArray[MAX_MD5_SHA1_STATE_SIZE];
  //-------------------------------------------------------
  // Calculate required number of keydata
  //-------------------------------------------------------
  if( pConnStruc->MacAlgorType != MAC_ALGOR_AES_GCM ) {
    // GCM needs no explicit hash key
    MacLen = pConnStruc->HashSize & 0xFF;
  }
  KeyLen = pConnStruc->KeyMaterialSize & 0xFF;		// Cipher key length

  if((pConnStruc->CipherType == ALGOR_TYPE_BLOCK) || 
     (pConnStruc->CipherType == ALGOR_TYPE_AEAD))
  {
    IVLen = (pConnStruc->IVLen & 0xFF);		// IV length
  }

  len = (MacLen + KeyLen + IVLen) * 2;
  //-------------------------------------------------------
  // Calculate needed Blocks, Generate the Key Block
  //-------------------------------------------------------
  ProtType = pConnStruc->ActualProtocol;
  if(ProtType == SSL_PROT_TYPE)			// is SSL 3.0
  {
    //----------------------------------------------------
    // perform SSL3.0 keyblock generation
    //----------------------------------------------------
    blockcnt = (len + MD5_DIGEST_LEN-1)/MD5_DIGEST_LEN; // get number
    do
    {
      c = (char) (padcnt + 0x40);		// get start value
      j = 0;					// clear index
      i = padcnt;
      do {TmpBuf[j++] = c; i--;} while(i != 0);	// fill buffer
      SHA1_Init(StateArray);		// initialize
      SHA1_Update(StateArray,TmpBuf,0,padcnt);	// Hash Start Bytes
						// Hash Master Secret
      SHA1_Update(StateArray,pMasterSecret,0,MASTER_SECRET_LEN);
						// Hash Server Random
      SHA1_Update(StateArray,pSrvrRnd,0,SERVER_HELLO_RANDOM_LEN);
						// Hash Client Random
      SHA1_Update(StateArray,pClntRnd,0,CLIENT_HELLO_RANDOM_LEN);
      SHA1_Final(StateArray,TmpBuf,0);	// store digest

      MD5_Init(StateArray);		// initialize
						// hash master secret
      MD5_Update(StateArray,pMasterSecret,0,MASTER_SECRET_LEN);
						// hash the SHA1 hash
      MD5_Update(StateArray,TmpBuf,0,SHA_DIGEST_LEN);
						// store digest
      MD5_Final(StateArray,KeyBlock,Index);
      Index += MD5_DIGEST_LEN;

      padcnt ++;
      blockcnt--;
    }while(blockcnt != 0);
  }
  else						// is TLS V1.0/1.1/1.2
  {
    //----------------------------------------------------
    // perform TLS 1.0/1.1 keyblock generation
    // IVs are not needed for TLS V1.1, but generated
    //-----------------------------------------------------
						// generate seed part 1
    memcpy(TmpBuf+0,pSrvrRnd+0,SERVER_HELLO_RANDOM_LEN);
						// generate seed part 2
    memcpy(TmpBuf+SERVER_HELLO_RANDOM_LEN,pClntRnd+0,CLIENT_HELLO_RANDOM_LEN);

    if(ProtType <= TLS_V1_PROT_TYPE)		// is TLS 1.0/1.1
      TLS_Prf(pMasterSecret, 0, MASTER_SECRET_LEN, // do pseudo random funct.
	      KeyExpLabelStr,KEY_EXP_LABEL_STR_LEN,
	      TmpBuf,0,SERVER_HELLO_RANDOM_LEN+
		       CLIENT_HELLO_RANDOM_LEN,
	      KeyBlock,0,len);
    else{
       HMEM_CTX_DEF1;
       LOAD_HMEM_CTX_PTR(CONN_pMemCtx(pConnStruc));
      TLS_12_Prf( HMEM_CTX_REF1 pMasterSecret, 0, MASTER_SECRET_LEN, // do pseudo random funct.
	      KeyExpLabelStr,KEY_EXP_LABEL_STR_LEN,
	      TmpBuf,0,SERVER_HELLO_RANDOM_LEN+
		  CLIENT_HELLO_RANDOM_LEN,
	      KeyBlock,0,len);
    }
  }
  //-------------------------------------------------------
  // Partition the Key Block
  // Order depends on entity !!!
  //-------------------------------------------------------
  if(pConnStruc->Entity == SERVER_ENTITY)	// correct order
  {
    TmpBase1 = pConnStruc->PendRX_MACSecret;	  // Destination: Server Write
    TmpBase2 = pConnStruc->PendTX_MACSecret;	  // Destination: Client Write
    TmpBase3 = pConnStruc->PendRX_Key;	  // Destination: Server Write
    TmpBase4 = pConnStruc->PendTX_Key;	  // Destination: Client Write
    TmpBase5 = pConnStruc->PendRX_IV;	  // Destination: Server Write
    TmpBase6 = pConnStruc->PendTX_IV;	  // Destination: Client Write
  }
  else						// must change order
  {
    TmpBase1 = pConnStruc->PendTX_MACSecret;	  // Destination: Client Write
    TmpBase2 = pConnStruc->PendRX_MACSecret;	  // Destination: Server Write
    TmpBase3 = pConnStruc->PendTX_Key;	  // Destination: Client Write
    TmpBase4 = pConnStruc->PendRX_Key;	  // Destination: Server Write
    TmpBase5 = pConnStruc->PendTX_IV;	  // Destination: Client Write
    TmpBase6 = pConnStruc->PendRX_IV;	  // Destination: Server Write
  }

  Index = 0;
  
  if( MacLen != 0 ) {
      memcpy(TmpBase1+0,KeyBlock+Index,MacLen);
      Index += MacLen;
      memcpy(TmpBase2+0,KeyBlock+Index,MacLen);
      Index += MacLen;
  }

  if(pConnStruc->IsExportable == IS_NOT_EXPORTABLE)
  {
    //----------------------------------------------------
    // not (US) exportable key, all data present, simple copy
    //----------------------------------------------------
    memcpy(TmpBase3+0,KeyBlock+Index,KeyLen);
    Index += KeyLen;
    memcpy(TmpBase4+0,KeyBlock+Index,KeyLen);
    Index += KeyLen;

    if(IVLen != 0)
    {
      memcpy(TmpBase5+0,KeyBlock+Index,IVLen);
      Index += IVLen;
      memcpy(TmpBase6+0,KeyBlock+Index,IVLen);
    }
  }
  else
  {
    //----------------------------------------------------
    // is (US) exportable key, must do special operations
    //----------------------------------------------------
    if(pConnStruc->ActualProtocol == SSL_PROT_TYPE)	// is SSL 3.0
    {
      //----------------------------------------------------
      // perform SSL3.0 final key processing
      //----------------------------------------------------
      MD5_Init(StateArray);			// Init the hash
      MD5_Update(StateArray,KeyBlock,Index,KeyLen);	// Hash key
      MD5_Update(StateArray,pClntRnd,0,CLIENT_HELLO_RANDOM_LEN);
      MD5_Update(StateArray,pSrvrRnd,0,SERVER_HELLO_RANDOM_LEN);
							// Destination
      MD5_Final(StateArray,TmpBase3,0);

      Index += KeyLen;

      MD5_Init(StateArray);			// Init the hash
      MD5_Update(StateArray,KeyBlock,Index,KeyLen);	// Hash key
      MD5_Update(StateArray,pSrvrRnd,0,SERVER_HELLO_RANDOM_LEN);
      MD5_Update(StateArray,pClntRnd,0,CLIENT_HELLO_RANDOM_LEN);
							// Destination
      MD5_Final(StateArray,TmpBase4,0);
   

      if(pConnStruc->CipherType == ALGOR_TYPE_BLOCK)
      {

        MD5_Init(StateArray);			// Init the hash
							// hash random
        MD5_Update(StateArray,pClntRnd,0,CLIENT_HELLO_RANDOM_LEN);
							// hash random
        MD5_Update(StateArray,pSrvrRnd,0,SERVER_HELLO_RANDOM_LEN);
							// Destination
        MD5_Final(StateArray,TmpBase5,0);

        MD5_Init(StateArray);			// Init the hash
							// hash random
        MD5_Update(StateArray,pSrvrRnd,0,SERVER_HELLO_RANDOM_LEN);
							// hash random
        MD5_Update(StateArray,pClntRnd,0,CLIENT_HELLO_RANDOM_LEN);
							// Destination
        MD5_Final(StateArray,TmpBase6,0);
      }
    }
    else						// is TLS V1.0 (/V1.1)
    {
      //----------------------------------------------------------------
      // perform TLS 1.0 final key processing
      // TLS 1.1/1.2 does no longer support export restricted methods!
      //----------------------------------------------------------------
							// generate seed part 1
      memcpy(TmpBuf+0,pClntRnd+0,CLIENT_HELLO_RANDOM_LEN);
							// generate seed part 2
      memcpy(TmpBuf+CLIENT_HELLO_RANDOM_LEN,pSrvrRnd+0,SERVER_HELLO_RANDOM_LEN);
						// do pseudo random funct.
      TLS_Prf(KeyBlock, Index, KeyLen,
	      ClntWriteKeyLabelStr,CLNT_WR_KEY_LABEL_STR_LEN,
	      TmpBuf,0,CLIENT_HELLO_RANDOM_LEN+
		       SERVER_HELLO_RANDOM_LEN,
              TmpBase3,0,MAX_EXPANDED_KEY_LEN);

      Index += KeyLen;

      TLS_Prf(KeyBlock, Index, KeyLen,		// do pseudo random funct.
	      SrvrWriteKeyLabelStr,SRVR_WR_KEY_LABEL_STR_LEN,
	      TmpBuf,0,CLIENT_HELLO_RANDOM_LEN+
		       SERVER_HELLO_RANDOM_LEN,
              TmpBase4,0,MAX_EXPANDED_KEY_LEN);

      if(pConnStruc->CipherType == ALGOR_TYPE_BLOCK)
      {
        TLS_Prf(NULL, 0, 0,			// do pseudo random funct.
	      IVBlockLabelStr,IV_BLOCK_LABEL_STR_LEN,
	      TmpBuf,0,CLIENT_HELLO_RANDOM_LEN+
		       SERVER_HELLO_RANDOM_LEN,
              IVBlock,0,MAX_IV_LEN);

        memcpy(TmpBase5+0,IVBlock+0,IVLen);	// 1st part for client
        memcpy(TmpBase6+0,IVBlock+IVLen,IVLen);// 2nd part for server
      } // Block Algor
    } // TLS
  } // not exportable
}

/**
* Generates hashes needed
* for Certificate Verify Handshake messages (GenerateCertVerifyHashes).
* The state arrays for the hashes will be kept valid.
*
* The buffer may need a total length of up to 83 Bytes
*       when using TLS 1.2, SHA-512 with RSA.
*
*  @param pConnStruc Connection structure
*  @param MacData Base for digest data
*  @param MacOffset Offset for digest data
*  @param SignatureType Type of the signature, according to RFC5246
*/
static  void  GenerateCertVerifyHashes(CONNSTRU * pConnStruc,
                                                  char* MacData, int MacOffset, int SignatureType)
{
   int MacIndex = MacOffset;

   char*  lpMasterSecret = pConnStruc->MasterSecret;

   int TmpMD5_State[MD5_ARRAY_SIZE];
   int TmpSHA1_State[SHA_ARRAY_SIZE];
   int TmpSHA256_State[SHA256_ARRAY_SIZE];
   long long TmpSHA384_State[SHA384_ARRAY_SIZE];
   long long TmpSHA512_State[SHA512_ARRAY_SIZE];
   //-------------------------------------------------------
   // Copy the current hash states to local states
   //-------------------------------------------------------
   memcpy(TmpMD5_State+0,pConnStruc->HandshakeMD5_State+0,(MD5_ARRAY_SIZE)*4);
   memcpy(TmpSHA1_State+0,pConnStruc->HandshakeSHA1_State+0,(SHA_ARRAY_SIZE)*4);
   memcpy(TmpSHA256_State+0,pConnStruc->HandshakeSHA256_State+0,(SHA256_ARRAY_SIZE)*4);
   memcpy(TmpSHA384_State+0,pConnStruc->HandshakeSHA384_State+0,(SHA384_ARRAY_SIZE)*8);
   memcpy(TmpSHA512_State+0,pConnStruc->HandshakeSHA512_State+0,(SHA512_ARRAY_SIZE)*8);
   //-------------------------------------------------------
   // Generate SSL Final Hashes
   //-------------------------------------------------------
   if(pConnStruc->ActualProtocol == SSL_PROT_TYPE)		// SSL V3.0
   {
      //-------------------------------------------------------
      // Generate the final MD5 hash, do NOT reinitialize hash state
      //-------------------------------------------------------
      //hash master secr.
      MD5_Update(TmpMD5_State,lpMasterSecret,0,MASTER_SECRET_LEN);
      // hash padding 1  
      MD5_Update(TmpMD5_State,Pad1Str,0,PAD1_LEN_MD5);
      // store temporary
      MD5_Final(TmpMD5_State,MacData,MacIndex);

      MD5_Init(TmpMD5_State);		// initialize
      // hash master secret
      MD5_Update(TmpMD5_State,lpMasterSecret,0,MASTER_SECRET_LEN);
      // hash padding 2
      MD5_Update(TmpMD5_State,Pad2Str,0,PAD2_LEN_MD5);
      // hash stored hash
      MD5_Update(TmpMD5_State,MacData,MacIndex,MD5_DIGEST_LEN);
      // store final hash
      MD5_Final(TmpMD5_State,MacData,MacIndex);

      MacIndex += MD5_DIGEST_LEN;			// to next location  
      //-------------------------------------------------------
      // Generate the final SHA1 hash, reinitialize hash state
      //-------------------------------------------------------
      // hash mastersecret
      SHA1_Update(TmpSHA1_State,lpMasterSecret,0,MASTER_SECRET_LEN);
      // hash padding 1  
      SHA1_Update(TmpSHA1_State,Pad1Str,0,PAD1_LEN_SHA1);
      // store temporary
      SHA1_Final(TmpSHA1_State,MacData,MacIndex);

      SHA1_Init(TmpSHA1_State);		// initialize
      // hash mastersecret
      SHA1_Update(TmpSHA1_State,lpMasterSecret,0,MASTER_SECRET_LEN);
      // hash padding 2  
      SHA1_Update(TmpSHA1_State,Pad2Str,0,PAD2_LEN_SHA1);
      // hash stored hash
      SHA1_Update(TmpSHA1_State,MacData,MacIndex,SHA_DIGEST_LEN);
      // store final hash
      SHA1_Final(TmpSHA1_State,MacData,MacIndex);
   }
   else if(pConnStruc->ActualProtocol != TLS_V2_PROT_TYPE)// TLS V1.0/V1.1
      //-------------------------------------------------------
      // Generate TLS pure MD5 and SHA1 Hash Data
      //-------------------------------------------------------
   {
      //-------------------------------------------------------
      // Generate the final MD5 hash
      //-------------------------------------------------------
      MD5_Final(TmpMD5_State,MacData,MacIndex);
      //-------------------------------------------------------
      // Generate the final SHA1 hash
      //-------------------------------------------------------
      SHA1_Final(TmpSHA1_State,MacData,MacIndex+MD5_DIGEST_LEN);
   }
   else
   {
      switch(SignatureType & 0xff){
      case SIG_ALGOR_RSA:
         switch( SignatureType >> 8){
            // Complicated, but necessary. Taken from r6.c, comments removed.
      case HASH_ALGOR_MD5:
         memcpy(MacData+MacIndex,RSA_Def_MD_Sign_Hdr+0,RSA_DEF_MD_SIGN_HDR_LEN);
         MacData[MacIndex+RSA_DEF_MD_HDR_ALG_ID_IND] = MD5_WITH_RSA_ALGOR_ID_BYTE;
         MD5_Final(TmpMD5_State,MacData,MacIndex+RSA_DEF_MD_SIGN_HDR_LEN);
         break;
      case HASH_ALGOR_SHA1:
         memcpy(MacData+MacIndex,RSA_Def_SHA_Sign_Hdr+0,RSA_DEF_SHA_SIGN_HDR_LEN);
         SHA1_Final(TmpSHA1_State,MacData,MacIndex+RSA_DEF_SHA_SIGN_HDR_LEN);
         break;
      case SHA256_WITH_RSA_ALGOR:
         memcpy(MacData+MacIndex,RSA_Def_SHA2_Sign_Hdr+0,RSA_DEF_SHA2_SIGN_HDR_LEN);
         MacData[MacIndex+RSA_DEF_SHA2_HDR_ALG_ID_IND] =	// insert Algor-ID (NIST)
            SHA256_WITH_RSA_ALGOR_ID_BYTE;
         MacData[MacIndex+RSA_DEF_SHA2_HDR_HASHLEN_IND] =	// insert hash length
            SHA256_DIGEST_LEN;
         MacData[MacIndex+RSA_DEF_SHA2_HDR_TOTLEN_IND] =	// insert total length
            RSA_DEF_SHA2_SIGN_HDR_LEN-2 + SHA256_DIGEST_LEN;
         SHA256_Final(TmpSHA256_State,MacData,MacIndex+RSA_DEF_SHA2_SIGN_HDR_LEN);
         break;
      case SHA384_WITH_RSA_ALGOR:
         memcpy(MacData+MacIndex,RSA_Def_SHA2_Sign_Hdr+0,RSA_DEF_SHA2_SIGN_HDR_LEN);
      
         MacData[MacIndex+RSA_DEF_SHA2_HDR_ALG_ID_IND] =	// insert Algor-ID (NIST)
            SHA384_WITH_RSA_ALGOR_ID_BYTE;
         MacData[MacIndex+RSA_DEF_SHA2_HDR_HASHLEN_IND] =	// insert hash length
            SHA384_DIGEST_LEN;
         MacData[MacIndex+RSA_DEF_SHA2_HDR_TOTLEN_IND] =	// insert total length
            RSA_DEF_SHA2_SIGN_HDR_LEN-2 + SHA384_DIGEST_LEN;
         SHA384_Final(TmpSHA384_State,MacData,MacIndex+RSA_DEF_SHA2_SIGN_HDR_LEN);
         break;
      case SHA512_WITH_RSA_ALGOR:
         memcpy(MacData+MacIndex,RSA_Def_SHA2_Sign_Hdr+0,RSA_DEF_SHA2_SIGN_HDR_LEN);
      
         MacData[MacIndex+RSA_DEF_SHA2_HDR_ALG_ID_IND] =	// insert Algor-ID (NIST)
            SHA512_WITH_RSA_ALGOR_ID_BYTE;
         MacData[MacIndex+RSA_DEF_SHA2_HDR_HASHLEN_IND] =	// insert hash length
            SHA512_DIGEST_LEN;
         MacData[MacIndex+RSA_DEF_SHA2_HDR_TOTLEN_IND] =	// insert total length
            RSA_DEF_SHA2_SIGN_HDR_LEN-2 + SHA512_DIGEST_LEN;
         SHA512_Final(TmpSHA512_State,MacData,MacIndex+RSA_DEF_SHA2_SIGN_HDR_LEN);
         break;
         } 
         break;
      case SIG_ALGOR_DSA:
         // Keep consistent offset for DSA
         SHA1_Final(TmpSHA1_State,MacData,MacIndex+MD5_DIGEST_LEN);
         break;
      }
   }
}

/**
* Generates hashes needed
* for Finished Handshake messages according
* to sender (GenerateFinishedHashes).
* The State Arrays for the hashes
* will be kept valid.
*
* <ol>
*  <li> For SSL, the buffer must have at least size of
*          MD5_DIGEST_LEN + SHA_DIGEST_LEN
*  <li> For TLS, the buffer must have at least size of
*	    TLS_VERIFY_DATA_LEN
*</ol>
*  @param pConnStruc Connection structure
*  @param MacData Base of Hash data
*  @param MacOffset Offset to Hash data
*  @param Sender == 0 - Server Entity <br>
*               <> 0 - Client Entity
*  @return The actual length of the generated hash.
*/
static  char  GenerateFinishedHashes(CONNSTRU * pConnStruc,
	       char* MacData, int MacOffset, int Sender)
{
  int MacIndex = MacOffset;
  int SenderStrLen;

  int Prot = pConnStruc->ActualProtocol;		// 0 - SSL

  char *  lpHSenderStr = NULL;
  char*  lpSenderStr = NULL;
  char*  lpMasterSecret = pConnStruc->MasterSecret;

  char TmpDigestBuf[MD5_DIGEST_LEN+SHA_DIGEST_LEN];

  int TmpMD5_State[MD5_ARRAY_SIZE];
  int TmpSHA1_State[SHA_ARRAY_SIZE];
  int TmpSHA256_State[SHA256_ARRAY_SIZE];
  //-------------------------------------------------------
  // Copy the current hash states to local states
  //-------------------------------------------------------
  memcpy(TmpMD5_State+0,pConnStruc->HandshakeMD5_State+0,(MD5_ARRAY_SIZE)*4);
  memcpy(TmpSHA1_State+0,pConnStruc->HandshakeSHA1_State+0,(SHA_ARRAY_SIZE)*4);
  memcpy(TmpSHA256_State+0,pConnStruc->HandshakeSHA256_State+0,(SHA256_ARRAY_SIZE)*4);
  //-------------------------------------------------------
  // Get associates Sender string pointers
  //-------------------------------------------------------
  if(Sender == SERVER_ENTITY)
  {
    if(Prot == SSL_PROT_TYPE)				// SSL V3.0
    {
      lpSenderStr = MacSenderSrvrStr;
      SenderStrLen = MAC_SENDER_SERVER_STR_LEN;
    }
    else						// TLS V1.0/V1.1/V1.2
    {
      lpHSenderStr = HMacSenderSrvrStr;
      SenderStrLen = HMAC_SENDER_SERVER_STR_LEN;
    }
  }
  else							// Client Entity
  {
    if(Prot == SSL_PROT_TYPE)				// SSL V3.0
    {
      lpSenderStr = MacSenderClntStr;
      SenderStrLen = MAC_SENDER_CLIENT_STR_LEN;
    }
    else						// TLS V1.0/V1.1/V1.2
    {
      lpHSenderStr = HMacSenderClntStr;
      SenderStrLen = HMAC_SENDER_CLIENT_STR_LEN;
    }
  }

  if(Prot == SSL_PROT_TYPE)				// SSL V3.0
  //-------------------------------------------------------
  // Generate SSL Final Hashes
  //-------------------------------------------------------
  {
    //-------------------------------------------------------
    // Generate the final MD5 hash, do NOT reinitialize hash state
    //-------------------------------------------------------
						// hash SENDER string
    MD5_Update(TmpMD5_State,lpSenderStr,0,SenderStrLen);
						//hash master secr.
    MD5_Update(TmpMD5_State,lpMasterSecret,0,MASTER_SECRET_LEN);
						// hash padding 1  
    MD5_Update(TmpMD5_State,Pad1Str,0,PAD1_LEN_MD5);
						// store temporary
    MD5_Final(TmpMD5_State,MacData,MacIndex);

    MD5_Init(TmpMD5_State);		// initialize
						// hash master secret
    MD5_Update(TmpMD5_State,lpMasterSecret,0,MASTER_SECRET_LEN);
						// hash padding 2
    MD5_Update(TmpMD5_State,Pad2Str,0,PAD2_LEN_MD5);
						// hash stored hash
    MD5_Update(TmpMD5_State,MacData,MacIndex,MD5_DIGEST_LEN);
						// store final hash
    MD5_Final(TmpMD5_State,MacData,MacIndex);

    MacIndex += MD5_DIGEST_LEN;			// to next location  
    //-------------------------------------------------------
    // Generate the final SHA1 hash, reinitialize hash state
    //-------------------------------------------------------
						// hash SENDER string
    SHA1_Update(TmpSHA1_State,lpSenderStr,0,SenderStrLen);
						// hash mastersecret
    SHA1_Update(TmpSHA1_State,lpMasterSecret,0,MASTER_SECRET_LEN);
						// hash padding 1  
    SHA1_Update(TmpSHA1_State,Pad1Str,0,PAD1_LEN_SHA1);
						// store temporary
    SHA1_Final(TmpSHA1_State,MacData,MacIndex);

    SHA1_Init(TmpSHA1_State);		// initialize
						// hash mastersecret
    SHA1_Update(TmpSHA1_State,lpMasterSecret,0,MASTER_SECRET_LEN);
						// hash padding 2  
    SHA1_Update(TmpSHA1_State,Pad2Str,0,PAD2_LEN_SHA1);
						// hash stored hash
    SHA1_Update(TmpSHA1_State,MacData,MacIndex,SHA_DIGEST_LEN);
						// store final hash
    SHA1_Final(TmpSHA1_State,MacData,MacIndex);
    return (MD5_DIGEST_LEN + SHA_DIGEST_LEN);
  }
  else if(Prot < TLS_V2_PROT_TYPE)	// TLS V1.0/V1.1
  //-------------------------------------------------------
  // Generate TLS Final Verify Data
  //-------------------------------------------------------
  {
    //-------------------------------------------------------
    // Generate the final MD5 hash
    //-------------------------------------------------------
						// store for PRF seed
    MD5_Final(TmpMD5_State,TmpDigestBuf,0);
    //-------------------------------------------------------
    // Generate the final SHA1 hash
    //-------------------------------------------------------
						// store for PRF seed
    SHA1_Final(TmpSHA1_State,TmpDigestBuf,MD5_DIGEST_LEN);
    //-------------------------------------------------------
    // Generate verification data from PRF function
    //-------------------------------------------------------
    TLS_Prf(lpMasterSecret,0,MASTER_SECRET_LEN,	// secret
            lpHSenderStr,SenderStrLen,		// label
	    TmpDigestBuf,0,MD5_DIGEST_LEN+SHA_DIGEST_LEN, // seed
	    MacData,MacOffset,TLS_VERIFY_DATA_LEN);
  return TLS_VERIFY_DATA_LEN;
  }
  else   // TLS 1.2
  {
    HMEM_CTX_DEF1;
    LOAD_HMEM_CTX_PTR(CONN_pMemCtx(pConnStruc));
    //------------------------------------------------------
    // Generate the final SHA256 hash
    //------------------------------------------------------
    SHA256_Final(TmpSHA256_State,TmpDigestBuf,0);
    //-------------------------------------------------------
    // Generate verification data from PRF function
    //-------------------------------------------------------
    TLS_12_Prf( HMEM_CTX_REF1  lpMasterSecret,0,MASTER_SECRET_LEN,	// secret
                lpHSenderStr,SenderStrLen,		// label
	            TmpDigestBuf,0,SHA256_DIGEST_LEN, // seed
	            MacData,MacOffset,TLS_VERIFY_DATA_LEN);
    
  return TLS_VERIFY_DATA_LEN;
  }
}
/**
* Compares two byte sized
* compression methods lists for a match (GetCompressionListMatch).
*
*  @param List1 1st list base
*  @param List1Off start of data in first list
*  @param List2 2nd list base
*  @param List2Off Start of data in second list
* 
*  @return  < 0 - no match found, else the first matching value
*/
static  int  GetCompressionListMatch(char* List1, int List1Off,
						  char* List2, int List2Off)
{
  int Len1;
  int Len2;
  int ActValue;

  int Index = List1Off;

  if((List1 == NULL) || (List2 == NULL))
    return((int) -1);

  //---------------------------------------------
  // Byte lists, check for zero length first
  //---------------------------------------------
  Len1 = (int) List1[Index++] & 0xFF;	// get length
  Len2 = (int) List2[List2Off];
  if((Len1 == 0) || (Len2 == 0))
    return((int) -1);
  do
  {
    ActValue = (int) List1[Index++] & 0xFF;	// get value to search
    if(SearchSizedList(List2,List2Off,0,ActValue) != 0)
        return(ActValue);			// found
    Len1--;
  }while(Len1 != 0);
  return((int) -1);
}
/**
* Compares two word sized
* cipher suite lists for a match (GetCipherSuiteListMatch). 
* If requested, ignores exportable
* cipher suite types.
*
*  @param List1 1st list base
*  @param List1Off start of data in first list
*  @param List2 2nd list base
*  @param List2Off Start of data in second list
*  @param inp_protocol_ver_flags specifies Flag of used TLS version: <br>
*                                Bit 0 - SSL 3.0 or TLS 1.0 <br>
*                                Bit 1 - TLS 1.1 <br>
*                                Bit 2 - TLS 1.2
* 
*  @return  < 0 - no match found, else the first matching value
*/
static  int  GetCipherSuiteListMatch(char* List1,
                                     int List1Off,
                                     char* List2, 
                                     int List2Off,
                                     int inp_protocol_ver_flags,
                                     bool bop_allow_ecc)
{
  char byl_version_flags;
  int Len1;
  int Len2;
  int ActValue;
  int SuiteIndex;
  int Index = List1Off;

  if((List1 == NULL) || (List2 == NULL))
    return((int) -1);

  //---------------------------------------------
  // BIGWord lists, check for zero length first
  //---------------------------------------------
  BIGchar2word(List1,Len1,Index);		// get size, skip
  BIGchar2wordn(List2,Len2,List2Off);		// dto. w/o skip
  if((Len1 == 0) || (Len2 == 0))
    return((int) -1);
  do
  {
    BIGchar2wordn(List1,ActValue,Index);	// get value to search
    SuiteIndex = GetCipherParamsIndex((unsigned short) ActValue);
    if(SuiteIndex == -1)			// should not happen !!
    {
      Index += 2;
      Len1  -= 2;
      continue;
    }
    byl_version_flags = CipherParams[SuiteIndex + CST_Usability];
    if((byl_version_flags & inp_protocol_ver_flags) == 0)		// Cipher not usable by target prot version
    {
      Index += 2;
      Len1  -= 2;
      continue;
    }
    unsigned char byl_key_exchange = CipherParams[SuiteIndex + CST_KeyExchgMode];
    if((byl_key_exchange == KEY_EXCHANGE_ECDHE_RSA) && 
        !bop_allow_ecc)
    {
      // No compatible named curve or point format
      Index += 2;
      Len1  -= 2;
      continue;
    }
    if(SearchSizedList(List2,List2Off,1,ActValue) != 0)
      return(ActValue);			// found
    Index += 2;
    Len1  -= 2;
  }while(Len1 > 0);
  return((int) -1);
}
/**
* Scans given ciphersuite
* list, if any non-exportable elements present (CheckAllCipherSuitesExportable).
*
*  @param List List base
*  @param ListOff Start of data
* 
*  @return  > 0 - all exportable
* <br>            == 0 - some not exportable
* <br>            < 0 - error occured
*/
static  int  CheckAllCipherSuitesExportable(char* List,
						       int ListOff)
{
  char IsExportable;
  int Len;
  int ActValue;
  int SuiteIndex;
  int Index = ListOff;

  if(List == NULL)
    return(-1);

  //---------------------------------------------
  // BIGWord lists, check for zero length first
  //---------------------------------------------
  BIGchar2word(List,Len,Index);			// get size, skip
  if((Len == 0) || ((Len & 0x01) != 0))		// must be > 0 and even
    return(-1);

  do
  {
    BIGchar2wordn(List,ActValue,Index);		// get value to check
    SuiteIndex = GetCipherParamsIndex((unsigned short) ActValue);
    if(SuiteIndex == -1)			// should not happen !!
      return(-1);
    IsExportable = CipherParams[SuiteIndex + CST_IsExportable];
    if(IsExportable == IS_NOT_EXPORTABLE)	// is a non exportable type
      return(0);				// say some not exportable

    Index += 2;
    Len   -= 2;
  }while(Len > 0);
  return(1);					// say all ekportable
}
/**
* Sets the timer for renegotiation start/receive timeout according to
* mode specified (SetRenegotiateTimer). 
* When start mode set is required, the timer is ONLY set if:
*<ol>
* <li> A renegotiation time is present from configuration.
* <li> Local renegotiation mode is active.
*</ol>
* No parameters are checked.
*
*  @param pConnStruc Connection structure
*  @param Mode == 0 - set start timer <br>
*               <> 0 - set response wait timer
*/
static  void  SetRenegotiateTimer(CONNSTRU * pConnStruc, int Mode)
{
  if(Mode == 0)					// set renegotiation start
  {

// HACK, disable renegotiation
    return;
  }
  else						// set timeout mode
  {
    //------------------------------------------------------------------
    // Set the response timeout time according to system.
    // Unix/Windows uses 1s resolution,  Java uses 1ms resulution,
    // ----- CSharp uses 100ns resolution
    //------------------------------------------------------------------
    pConnStruc->ActualRenegotiateTimer = (uint32_t)
      ((uint32_t) time(NULL) + HSSL_RENEGOTIATE_COMPLETE_MAX_WAIT);
  }
}

/**
* Generates SHA1 hash of peer
* certificate (HashPartnerCert).
*
*  @param pConnStruc Connection structure
*/
static  void HashPartnerCert(CONNSTRU * pConnStruc)
{
  int SHA1Array[SHA_ARRAY_SIZE];

  if((pConnStruc->pPartnerCert == NULL) ||
     (pConnStruc->PartnerCertLen <= 0))
    return;						// keep hash!
  //---------------------------------------------------
  // Hash the client certificate with SHA1
  //---------------------------------------------------
  SHA1_Init(SHA1Array);
  SHA1_Update(SHA1Array,pConnStruc->pPartnerCert,0,pConnStruc->PartnerCertLen);
  SHA1_Final(SHA1Array,pConnStruc->PartnerCertHash,0);
}
/**
* Puts a RX-Qel to end of the receive queue (EnqueueRxQel).
*
*  @param pConnStruc Connection structure
*  @param pRxQel Element to enqueue
*
*/
static   void  EnqueueRxQel(CONNSTRU * pConnStruc,
				RX_QEL * pRxQel)
{
  //-------------------------------------------------
  // put entry to queue
  //-------------------------------------------------
  if(pConnStruc->pApplicationRxQueueHead == NULL)	// first element
    pConnStruc->pApplicationRxQueueHead = pRxQel;	// insert as first
  else
    pConnStruc->pApplicationRxQueueTail->pNextRxQel = pRxQel; // insert as last
  pConnStruc->pApplicationRxQueueTail = pRxQel;	// set new last pointer
}

/**
* Removes a RX-Qel from start of the
* receive queue (DequeueRxQel). 
* Frees buffer and structure, reports next element.
*
*  @param pConnStruc Connection structure
*  @return Pointer to next element, NULL, if none exists or error happens
*/
static   RX_QEL *  DequeueRxQel(
						CONNSTRU * pConnStruc)
{
  RX_QEL * pActRxQel;
  RX_QEL * pNextRxQel;

  HMEM_CTX_DEF1;

  
  //-------------------------------------------------
  // check parameters, check for empty queue
  //-------------------------------------------------
  if(pConnStruc == NULL)			// should not happen
    return(NULL);				
  pActRxQel = pConnStruc->pApplicationRxQueueHead;	// get queue head
  if(pActRxQel == NULL)
    return(NULL);

  LOAD_HMEM_CTX_PTR(CONN_pMemCtx(pConnStruc));

  //-------------------------------------------------
  // remove queue element, set next if present
  //-------------------------------------------------
  pNextRxQel = pActRxQel->pNextRxQel;		// get next pointer
  FREE_ARRAY_POOL(HMEM_CTX_REF,pActRxQel->pBuf);// free buffer(if any)
  FREE_ARRAY(HMEM_CTX_REF,pActRxQel);		// free structure

  pConnStruc->pApplicationRxQueueHead = pNextRxQel;// set as first
  if(pNextRxQel == NULL)			// is also last
    pConnStruc->pApplicationRxQueueTail = NULL;	// clear pointer
  return(pNextRxQel);

  
}

/**
* Allocates and initializes an application receive queue element (AllocInitRxQel).
*
*  @param pSrcBuf Pointer to data buffer to be used
*  @param SrcOff Start of data in the buffer
*  @param SrcLen Length of data in the buffer
*
*  @return Pointer to new structure, NULL on failure
*/
static  RX_QEL *  AllocInitRxQel(HMEM_CTX_DEF
	char* pSrcBuf, int SrcOff, int SrcLen)
{
  RX_QEL * pRxQel;
  //-------------------------------------------------
  // Allocate the structure
  //-------------------------------------------------
  pRxQel = (RX_QEL *)
    ((void *) BIT8_ARRAY_ALLOC(HMEM_CTX_REF,sizeof(RX_QEL)));
  if(pRxQel == NULL)
    return(NULL);
  //-------------------------------------------------
  // Initialize the Structure
  //-------------------------------------------------
  pRxQel->pNextRxQel     = NULL;	// no Next pointer
  pRxQel->pBuf      = pSrcBuf;	// set Buffer-Pointer / NULL
  pRxQel->DataLen   = SrcLen;	// datalength
  pRxQel->DataIndex = SrcOff;	// index to start of buffer
  return(pRxQel);
}

#if !defined XH_INTERFACE		// not needed for alternate
/**
* Shuts down a connection and
* frees the connection structure (CloseConnection).
*
*  @param pConnStruc Connection structure
*  @param ErrorType
*/
static void  CloseConnection(CONNSTRU * pConnStruc, int ErrorType)
{
  int SocketIndex;
  int ShutdownMode;

  //------------------------------------------------
  // Get the Socket-ID from the Connection Structure,
  // free the structure and invalidate in global array
  // !!!!!! Assure LOCKED access !!!!!!
  //------------------------------------------------
  GetConnStrucLock();				// get the lock
  
  

  SocketIndex = pConnStruc->SocketIndex;
  if(SocketIndex == 0)
  {
    ReleaseConnStrucLock();
    return;
  }
//  DBG_PRINT("\nSocketIndex for FREE: ");
//  DBG_PRINT_INT(SocketIndex);
  pConnStruc->SocketIndex = 0;
  pConnPtrArray[SocketIndex-1] = NULL;	// remove
  ActConnectionCount --;			// reduce number
  if(ActConnectionCount == 0)
    MaxConnectionIndex = 0;
  else
  {
    if(SocketIndex == MaxConnectionIndex)
      MaxConnectionIndex--;
  }
  
  
  ReleaseConnStrucLock();			// release the lock
  //DBG_PRINT("\nA");
  //------------------------------------------------
  // Shutdown the connection ungraceful
  //------------------------------------------------
  if(ErrorType == TX_FATAL_ALERT)
    ShutdownMode = GRACEFUL;
  else
    ShutdownMode = UNGRACEFUL;

  HLSSL_CallBack(TCP_SHUTDOWN_FUNCTION,SocketIndex,NULL,ShutdownMode,ErrorType);

  FreeConnStateStruct(pConnStruc);

}
#endif // !defined XH_INTERFACE

/**
* Puts a TX-Qel to end of the
* desired send queue(EnqueueTxQel). 
* Queue selection depends on Qel Type.
*
*  @param pConnStruc Connection structure
*  @param pTxQel Element to enqueue
*
*/
static   void  EnqueueTxQel(CONNSTRU * pConnStruc,
							TX_QEL * pTxQel)
{
  char ProtType=0;

  

  if(pTxQel->Type == TX_TYPE_APPLICATION_DATA)
  {
    //-------------------------------------------------
    // get protocol for Record Layer to use
    //-------------------------------------------------
    pTxQel->ProtocolType = pConnStruc->ActualProtocol;	// must be valid !
    //-------------------------------------------------
    // put entry to application queue
    //-------------------------------------------------
    if(pConnStruc->pApplicationTxQueueHead == NULL)	// first element
      pConnStruc->pApplicationTxQueueHead = pTxQel;	// insert as first
    else
      pConnStruc->pApplicationTxQueueTail->pNextTxQel = pTxQel; // insert as last
    pConnStruc->pApplicationTxQueueTail = pTxQel;	// set new last pointer
  }
  else
  {
    //-------------------------------------------------
    // get protocol for Record Layer to use
    //-------------------------------------------------
    ProtType = pConnStruc->ActualProtocol;
    if(ProtType == UNKNOWN_PROT_TYPE)		// special case...
    {
      if((pConnStruc->SupportedProtocolsFlags & TLS_V2_BIT_MASK) != 0)// use TLS V1.2
        ProtType = TLS_V2_PROT_TYPE;
      else if((pConnStruc->SupportedProtocolsFlags & TLS_V1_BIT_MASK) != 0)// use TLS V1.1
        ProtType = TLS_V1_PROT_TYPE;
      else if((pConnStruc->SupportedProtocolsFlags & TLS_BIT_MASK) != 0)// use TLS V1.0
        ProtType = TLS_PROT_TYPE;
      else						// use SSL V3
        ProtType = SSL_PROT_TYPE;
    }
    pTxQel->ProtocolType = ProtType;
    //-------------------------------------------------
    // put entry to priority queue
    //-------------------------------------------------
    if(pConnStruc->pPriorityTxQueueHead == NULL)	// first element
      pConnStruc->pPriorityTxQueueHead = pTxQel;	// insert as first
    else
      pConnStruc->pPriorityTxQueueTail->pNextTxQel = pTxQel; // insert as last
    pConnStruc->pPriorityTxQueueTail = pTxQel;	// set new last pointer
  }
  
}
/**
* Removes either priority or application
* TX-Qel from the associated transmit queue, reports next element (DequeueTxQel).
*
*  @param pConnStruc Connection structure
*  @param QueueType TX_TYPE_APPLICATION_DATA for application queue, else
*                    priority queue
*  @return Pointer to next element in queue, NULL, if empty or on error
*/
static   TX_QEL *  DequeueTxQel(
			CONNSTRU * pConnStruc, int QueueType)
{
  TX_QEL * pActTxQel;
  TX_QEL * pNextTxQel;

  HMEM_CTX_DEF1;

  
  //-------------------------------------------------
  // check parameters, check for empty queue
  //-------------------------------------------------
  if(pConnStruc == NULL)				// should not happen
    return(NULL);				
  if(QueueType == TX_TYPE_APPLICATION_DATA)
    pActTxQel = pConnStruc->pApplicationTxQueueHead; // get queue head
  else
    pActTxQel = pConnStruc->pPriorityTxQueueHead; // get queue head
  if(pActTxQel == NULL)
    return(NULL);

  LOAD_HMEM_CTX_PTR(CONN_pMemCtx(pConnStruc));
  //-------------------------------------------------
  // remove queue element, set next if present
  //-------------------------------------------------
  pNextTxQel = pActTxQel->pNextTxQel;		// get next pointer
  FREE_ARRAY(HMEM_CTX_REF,pActTxQel);		// free the structure
  if(QueueType == TX_TYPE_APPLICATION_DATA)
  {
    pConnStruc->pApplicationTxQueueHead = pNextTxQel; // set as first
    if(pNextTxQel == NULL)			// is also last
      pConnStruc->pApplicationTxQueueTail = NULL;	// clear pointer
  }
  else
  {
    pConnStruc->pPriorityTxQueueHead = pNextTxQel; // set as first
    if(pNextTxQel == NULL)			// is also last
      pConnStruc->pPriorityTxQueueTail = NULL;	// clear pointer
  }
  return(pNextTxQel);

  
}
/**
* Allocates and initializes a transmit
* queue element and the buffer if required (AllocInitTxQel).
*
* The protocol type will be determined at the moment when the 
* Qel is put to the TX-Queue from the associated connection structure.
*
*  @param BufLen Size of buffer required
*  @param TxType Requested type to set
*
*  @return  <> NULL, allocated structure
* <br>            == NULL, allocate failure
*/
static  TX_QEL *  AllocInitTxQel(HMEM_CTX_DEF
					 int BufLen,char TxType)
{
  char* pBuf = NULL;
  TX_QEL * pTxQel;

  //-------------------------------------------------
  // Allocate the structure
  //-------------------------------------------------
  pTxQel = (TX_QEL *)
    ((void *) BIT8_ARRAY_ALLOC(HMEM_CTX_REF,sizeof(TX_QEL)));
  if(pTxQel == NULL) return(NULL);
  //-------------------------------------------------
  // Allocate the buffer if requested
  //-------------------------------------------------
  if(BufLen != 0)
  {
    pBuf = BIT8_ARRAY_ALLOC_POOL(HMEM_CTX_REF,BufLen);
    if(pBuf == NULL)
    {
      FREE_ARRAY(HMEM_CTX_REF,pTxQel);	// free structure
      return(NULL);
    }
  }
  //-------------------------------------------------
  // Initialize the Structure
  //-------------------------------------------------
  pTxQel->pNextTxQel     = NULL;	// no Next pointer
  pTxQel->pBuf      = pBuf;	// set Buffer-Pointer / NULL
  pTxQel->DataLen   = 0;		// datalength 0
  pTxQel->DataIndex = 0;		// index to start of buffer
  pTxQel->Type	   = TxType;	// set requested type
  pTxQel->ProtocolType  = UNKNOWN_PROT_TYPE;	// set unknown
  return(pTxQel);
}

/**
* Sends a SSL/TLS alert message (SendAlert).
* Queues a TX-Element to the priority send
* queue of type Alert-Warning, Alert-Fatal or Immediate Close
* depending on the Alert Level and Type. If allocation fails,
* the connection is closed ungraceful.
*
* The alert type AD_RESERVED is an internal type to signal an immideate close.
*
*  @param pConnStruc Connection structure
*  @param AlertType TLS alert type
*  @param AlertLevel Warning or Fatal
*/
static void  SendAlert(CONNSTRU * pConnStruc, int AlertType,
			    int AlertLevel)
{
  char TxType;
  int DataLen = 2;

  TX_QEL * pTxQel;

  HMEM_CTX_DEF1;
  LOAD_HMEM_CTX_PTR(CONN_pMemCtx(pConnStruc));

  //--------------------------------------------------------
  // Decide which alert-type to set
  //--------------------------------------------------------

  if(AlertLevel == ALERT_LEVEL_WARNING)
    TxType = TX_TYPE_ALERT_WARNING;
  else
  {
    if(AlertType != AD_RESERVED)
      TxType = TX_TYPE_ALERT_FATAL;
    else
    {
      TxType = TX_TYPE_SHUTDOWN;
      DataLen = 0;
    }
  }
  //--------------------------------------------------------
  // get Send Qel with/without buffer
  //--------------------------------------------------------
  pTxQel = AllocInitTxQel(HMEM_CTX_REF1 DataLen,TxType);
  if(pTxQel == NULL)			// allocate failed
  {
//  DBG_PRINT("\n1");

#if !defined XH_INTERFACE
    CloseConnection(pConnStruc,ALERT_GENERATE_FAILURE);
#endif // !XH_INTERFACE
    return;
  }
  if(DataLen != 0)
  {
    //--------------------------------------------------------
    // put alert message to buffer, 1st level, 2nd description
    //--------------------------------------------------------
    pTxQel->pBuf[0] = (char) AlertLevel;
    pTxQel->pBuf[1] = (char) AlertType;
    pTxQel->DataLen = DataLen;
  }
  //--------------------------------------------------------
  // enqueue Element to tail of priority send Queue
  //--------------------------------------------------------
  EnqueueTxQel(pConnStruc,pTxQel);
}

/**
* Gathers length of TX_QELs of same type
* and Protocol (Minor-)Version until either other type/version detected in
* queue or the max. SSL Plaintext length is reached (GatherTxQelsLengths).
*
* <ol>
* <li> Only Application data and Handshake messages may be gathered
* <li> No parameter checking is done
*</ol>
*  @param pTxQueue First element of queue
*  @param QelType Type to gather
*  @return Length of data
*/
static  int  GatherTxQelsLengths(TX_QEL * pTxQueue,
					   char QelType)
{
  int length = 0;
  TX_QEL * pActTxQel = pTxQueue;
  TX_QEL * pNextTxQel = NULL;

  for(;;)					// gather parts
  {
    length += pActTxQel->DataLen;  	// add up length
    if(length > SSL_PLAIN_RECORD_MAX_LEN)	// already too large
    {
      length = SSL_PLAIN_RECORD_MAX_LEN;	// set maximum
      return((int) length);
    }
    pNextTxQel = pActTxQel->pNextTxQel;	// get next Element
    if((pNextTxQel == NULL) ||			// Null Pointer
       (pNextTxQel->Type != QelType) ||	// other type
       (pNextTxQel->ProtocolType !=
        pActTxQel->ProtocolType))
    {
      return((int) length);			// last
    }
    pActTxQel = pNextTxQel;
  }
}
/**
* Gathers data of consecutive TX_QELs
* into buffer until datacount for buffer is reached (GatherTxQelsData).
* Elements that have been copied are removed from the queue. Elements that
* were only partial copied are changed in length and offset.
*
* <ol>
* <li> No checking of types is done, this has to be done ahead
* <li> No parameter checking is done
* <li> Destination copy start is past Record Header
*</ol>
*  @param pConnStruc Connection structure
*  @return HSSL_OP_OK on success, else error
*/
static  int  GatherTxQelsData(CONNSTRU * pConnStruc)
{
  int TxType;
  int SrcIndex;
#if !defined C_DUMMY_INTERFACE
  int DstIndex = RECORD_HDR_SIZE;
#else
  int DstIndex = 0;
#endif

  int length;
  int ElementLen;

  char* pSrcBuf;
  char* pDstBuf;

  TX_QEL * pActTxQel;
  TX_QEL * pNextTxQel;

  HMEM_CTX_DEF1;

  //---------------------------------------------------------
  // Check parameters
  //---------------------------------------------------------
  if((pConnStruc == NULL) || (pConnStruc->pTxFragmentBuffer == NULL))
    return(HSSL_NULL_PTR);			// should not happen

  LOAD_HMEM_CTX_PTR(CONN_pMemCtx(pConnStruc));

  //--------------------------------------------------
  // get the requested Transmit count, buffer and type
  //--------------------------------------------------
  TxType  =  pConnStruc->TxFragmentType;
  pDstBuf = pConnStruc->pTxFragmentBuffer;		// get Buffer Base
  length = (int) pConnStruc->TxFragmentToWriteCount & 0xFFFF; // get length
  DstIndex += pConnStruc->TxFragmentOffset;	// for TLS V1.1 CBC !!
  //--------------------------------------------------
  // get Start of QEL list according to type
  //--------------------------------------------------
  if(TxType == TX_TYPE_APPLICATION_DATA)
     pActTxQel = pConnStruc->pApplicationTxQueueHead;
  else
     pActTxQel = pConnStruc->pPriorityTxQueueHead;

  if(pActTxQel == NULL)
  {
    return(HSSL_NULL_PTR);			// should not happen
  }
  //--------------------------------------------------
  // process the QELs until all data gathered or error
  //--------------------------------------------------
//  DBG_PRINT("Gathering TX QELs: ");
  for(;;)
  {
    ElementLen = pActTxQel->DataLen;	// get size of Element
    pSrcBuf    = pActTxQel->pBuf;	// get buffer base
    SrcIndex   = (int) pActTxQel->DataIndex;	// get data start

    if(ElementLen > length)			// enough data present
    {
      memcpy(pDstBuf+DstIndex,pSrcBuf+SrcIndex,(int) length);  // copy
      ElementLen -= length;			// reduce count

      pActTxQel->DataLen   = ElementLen;	// save remaining count
      pActTxQel->DataIndex += length;	// set new Source index(+= !!)
      return(HSSL_OP_OK);
    }
    memcpy(pDstBuf+DstIndex,pSrcBuf+SrcIndex,(int) ElementLen);
    length -= ElementLen;			// reduce data count
    DstIndex += (int) ElementLen;		// to next index
    //---------------------------------------------------
    // Full element copied, remove from queue, free
    //---------------------------------------------------
    FREE_ARRAY_POOL(HMEM_CTX_REF,pActTxQel->pBuf); // free buffer
    pNextTxQel = DequeueTxQel(pConnStruc,TxType);// remove / free Qel
    pActTxQel = pNextTxQel;

    if(length == 0)
    {
      return(HSSL_OP_OK);
    }
    if(pActTxQel == NULL)
      return(HSSL_NULL_PTR);
  } // for
}

/**
* Generates Change Cipher Spec
* protocol element and enqueues it for send to the priority queue (GenerateChangeCipherSpec).
*
*  @param pConnStruc Connection structure
*  @return HSSL_OP_OK on success, else error occured
*/
static  int  GenerateChangeCipherSpec(CONNSTRU * pConnStruc)
{
  char* pDstBuf;
  TX_QEL * pTxQel;

  HMEM_CTX_DEF1;
  LOAD_HMEM_CTX_PTR(CONN_pMemCtx(pConnStruc));

  //----------------------------------------------------
  // Allocate TX-Qel with buffer
  //----------------------------------------------------
  pTxQel = AllocInitTxQel(HMEM_CTX_REF1
			  1,(unsigned char) TX_TYPE_CHANGE_CIPHER_SPEC);
  if(pTxQel == NULL)
    return(HSSL_TX_QEL_ALLOC_ERR);
  pDstBuf = pTxQel->pBuf;		// get buffer base
  //----------------------------------------------------
  // set Change Cipherspec Message
  //----------------------------------------------------
  pDstBuf[0] = CS_CHANGE_CIPHER_SPEC;
  pTxQel->DataLen = 1;
  //----------------------------------------------------
  // Enqueue TX-Quel for send
  //----------------------------------------------------
  EnqueueTxQel(pConnStruc,pTxQel);
  return(HSSL_OP_OK);
}

/**
* Checks ciphersuite list for Renegotiation specific SCSV info suite (CheckClntCiphSuitesForInfoScsv).
*
*  @param pInpBuf Buffer with suites
*  @param InpOff Start of data
*  @param InpLen Size of data (bytes)
*  @return 0 not found, else found SCSV
*/
static  int CheckClntCiphSuitesForInfoScsv(char* pInpBuf,
						  int InpOff, int InpLen)
{
  if((InpLen & 0x01) != 0)			// is ODD, BAD
    return(0);
  while(InpLen != 0)
  {
    if((pInpBuf[InpOff] == 0x00) &&		// MSB of Info SCVS
       ((unsigned char) pInpBuf[InpOff+1] == (unsigned char) 0xFF))	// LSB of Info SCVS
    {
      return(1);
    }
    InpOff += 2;
    InpLen -= 2;
  }
  return(0);
}
/**
* Extracts secure renegotiation extension and saves it if present (ExtractRenegotExtension).
*
*  @param pConnStruc Connection structure
*  @param InpBuf Buffer Base
*  @param InpOffset Start of data
*  @param ExtLen data length
*  @return  0 on success, else error occured
*/
static  int ExtractRenegotExtension(HMEM_CTX_DEF CONNSTRU * pConnStruc,
                                           char* InpBuf, int InpOffset, int ExtLen)
{
   int DataLen;
   char* pBuf;
   //------------------------------
   // Free buffer if already in use
   //------------------------------
   if(pConnStruc->pHandshakeRenegotExt != NULL)
   {
      FREE_ARRAY(HMEM_CTX_REF,pConnStruc->pHandshakeRenegotExt); // sets NULL
      //  CONN_pHshakeRenegotExt(pConnStruc) = NULL;
   }

   if(ExtLen <= 0)
      return(HSSL_EXT_TOO_FEW_EXT_DATA);
   if(ExtLen > (2* (SHA_DIGEST_LEN + MD5_DIGEST_LEN) + 1))
      return(HSSL_EXT_TOO_MANY_EXT_DATA);

   DataLen = (int) InpBuf[InpOffset] & 0xFF;	// get embedded length byte
   if(DataLen != ExtLen - 1)			// inconsistent length
      return(HSSL_EXT_INCONSISTENT_EXT_DATA);

   if((pBuf = BIT8_ARRAY_ALLOC(HMEM_CTX_REF,ExtLen)) == NULL)
      return(HSSL_ALLOC_ERR);

   memcpy(pBuf+0,InpBuf+InpOffset,ExtLen);
   pConnStruc->pHandshakeRenegotExt = pBuf;
   return(HSSL_OP_OK);
}

/**
* Generates secure renegotiation extension from saved values (GenerateRenegotExtension).
*
* Does not generate the List header
*
*  @param pConnStruc Connection structure
*  @param Mode 0 - empty extension <br>
*               1 - client side extension <br>
*               2 - server side extension
*  @param DstBuf Buffer Base
*  @param DstOffset Start of data
*  @return size of data bytes generated
*/
static  int GenerateRenegotExtension(CONNSTRU * pConnStruc,
			int Mode, char* DstBuf, int DstOffset)
{
  int CopyLen;
  int StartIndex = DstOffset;
  //--------------------
  // Generate type field
  //--------------------
  DstBuf[DstOffset++] = (unsigned char) (TLS_SECURE_RENEG_EXT_TYPE >> 8);
  DstBuf[DstOffset++] = (unsigned char) (TLS_SECURE_RENEG_EXT_TYPE & 0xFF);
  DstBuf[DstOffset++] = (unsigned char) 0x00;		// length MSB
  if(Mode == 0)					// Empty extension to build
  {
    DstBuf[DstOffset++] = (unsigned char) 0x01;		// length LSB
    DstBuf[DstOffset++] = (unsigned char) 0x00;		// implied length (==0)
  }
  else if(Mode == 1)				// Client side
  {
    CopyLen = (int) pConnStruc->HandshakeClntFinished[0] & 0xFF;
    CopyLen++;					// inclusie embedded length
    DstBuf[DstOffset++] = (unsigned char) (CopyLen);	// set length LSB    
    memcpy(DstBuf+DstOffset,pConnStruc->HandshakeClntFinished+0,CopyLen);
    DstOffset += CopyLen;
  }
  else						// server side
  {
    CopyLen = (int) pConnStruc->HandshakeClntFinished[0] & 0xFF;
    DstBuf[DstOffset++] = (unsigned char) (2*CopyLen + 1);	// set length LSB    
    DstBuf[DstOffset++] = (unsigned char) (2*CopyLen);		// set sized length
    memcpy(DstBuf+DstOffset,pConnStruc->HandshakeClntFinished+1,CopyLen);
    DstOffset += CopyLen;
    memcpy(DstBuf+DstOffset,pConnStruc->HandshakeSrvrFinished+1,CopyLen);
    DstOffset += CopyLen;
  }
  return(DstOffset - StartIndex);
}
/**
* Compares received secure renegotiation extension with saved values (CheckRenegotExtension).
*
*  @param pConnStruc Connection structure
*  @param Mode 0 - empty extension <br>
*               1 - client side extension <br>
*               2 - server side extension
*  @return  < 0 no extension received
* <br>            == 0 no match
* <br>            > 0 match found
*/
static  int CheckRenegotExtension(CONNSTRU * pConnStruc,int Mode)
{
  int ExtDataLen,CompareLen;
  int Index1,Index2;
  char* pBuf1;
  char* pBuf2;

  if(pConnStruc->pHandshakeRenegotExt == NULL)	// nothing received
    return(-1);

  pBuf1 = pConnStruc->pHandshakeRenegotExt;
  ExtDataLen = (int) pBuf1[0] & 0xFF;		// get embedded length byte

  if(Mode == 0)					// Check for empty extension
  {
    if(ExtDataLen != 0)				// not empty
      return(0);
    return(1);					// is an empty extension
  }
  else if(Mode == 1)				// check client extension
  {
    pBuf2 = pConnStruc->HandshakeClntFinished;
    CompareLen = (int) pBuf2[0] & 0xFF;

    if(ExtDataLen != CompareLen)		// different sizes
      return(0);

    Index1 = 1;
    while(Index1 <= CompareLen)
    {
      if(pBuf1[Index1] != pBuf2[Index1])
        return(0);
      Index1++;
    }
    return(1);
  }
  else						// server type
  {
    pBuf2 = pConnStruc->HandshakeClntFinished;
    CompareLen = (int) pBuf2[0] & 0xFF;

    if(ExtDataLen != CompareLen*2)		// different sizes
      return(0);

    Index1 = 1;
    Index2 = 1;
    while(Index2 <= CompareLen)
    {
      if(pBuf1[Index1++] != pBuf2[Index2])
        return(0);
      Index2++;
    }

    pBuf2 = pConnStruc->HandshakeSrvrFinished;
    Index2 = 1;
    while(Index2 <= CompareLen)
    {
      if(pBuf1[Index1++] != pBuf2[Index2])
        return(0);
      Index2++;
    }
    return(1);
  }
}

static int m_get_alpn_len(CONNSTRU* adsp_conn)
{
    if(adsp_conn->Entity == SERVER_ENTITY){
        if(adsp_conn->achc_selected_alpn == NULL) {
            return 0;
        }

        // Add the length of the selected string, the ALPN len bytes and the extension bytes
        return adsp_conn->achc_selected_alpn[0]+7;
    }

    if( adsp_conn->adsc_alpn_cfg == NULL ) {
        // No ALPN configured
        return 0;
    }

    struct dsd_alpn_config* adsl_conf = adsp_conn->adsc_alpn_cfg;

    // Start with 6 bytes for extension type, extension len and name list len and 1 len byte per name
    int inl_total_bytes = 6 + adsl_conf->unc_protocol_count;

    for ( int inl_index = adsl_conf->unc_protocol_count; inl_index > 0;){
        inl_index--;
        inl_total_bytes += (int)strlen(adsl_conf->aachc_protocols[inl_index]);
    }

    return inl_total_bytes;
}

static int m_write_alpn(CONNSTRU* adsp_conn,
                        char* abyp_dest_buf,
                        int& inp_offset)
{
    if( adsp_conn->adsc_alpn_cfg == NULL) {
        return 0;
    }

    int inl_alpn_len = m_get_alpn_len(adsp_conn);
    int inl_ret = inl_alpn_len;
    BIGword2char(TLS_ALPN_EXT_TYPE, abyp_dest_buf, inp_offset);
    inl_alpn_len-= 4;
    BIGword2char(inl_alpn_len, abyp_dest_buf, inp_offset);
    inl_alpn_len -= 2;
    BIGword2char(inl_alpn_len, abyp_dest_buf, inp_offset);

    for (int inl_index = 0;
         inl_index < adsp_conn->adsc_alpn_cfg->unc_protocol_count;
         inl_index++)
    {
        int inl_string_len = (int)strlen(adsp_conn->adsc_alpn_cfg->aachc_protocols[inl_index]);
        abyp_dest_buf[inp_offset++] = (char)inl_string_len;
        memcpy(abyp_dest_buf+inp_offset,
               adsp_conn->adsc_alpn_cfg->aachc_protocols[inl_index],
               inl_string_len);
        inp_offset += inl_string_len;
    }
    return inl_ret;
}

static int m_write_sni_ext(struct dsd_unicode_string* adsp_ucs_name,
                           char* abyp_dest_buf,
                           int& inp_offset)
{
    if(adsp_ucs_name->imc_len_str == 0 ) {
        return 0;
    }

    // The length of the actual host name. We already checked, that this is valid
    int inl_string_len =  adsp_ucs_name->imc_len_str;

    // Write extension type and the two bit extension length and name list length
    BIGword2char(TLS_SNI_EXT_TYPE, abyp_dest_buf, inp_offset);
    BIGword2char((inl_string_len+5), abyp_dest_buf, inp_offset);
    BIGword2char((inl_string_len+3), abyp_dest_buf, inp_offset);

    // Write name type and name length
    abyp_dest_buf[inp_offset++] = TLS_SNI_HOST_NAME_TYPE;
    BIGword2char(inl_string_len, abyp_dest_buf, inp_offset);

    // Write the name
    memcpy(abyp_dest_buf+inp_offset, adsp_ucs_name->ac_str, inl_string_len);
    inp_offset+= inl_string_len;

    return inl_string_len+9;
}


/**
* Generates extensions for Client Hello (m_generate_extensions).
*
* Generated extension, if configured and appliable, are:
*<ul>
*  <li> Renegotiation Indication Extension. Only on renegotiation, 
*        TLS_EMPTY_RENEGOTIATION_INFO_SCSV is used for initialization.
*  <li> Signature extension
*</ul>
*  @param pConnStruc Connection structure
*  @param abyp_dest_buf Buffer to write to
*  @param inp_offset Offset to start writing at
*/
static  int  m_generate_extensions(CONNSTRU * pConnStruc,
                                              char* abyp_dest_buf,
                                              int inp_offset)
{
   int ExtensionLen = 0;
   int inl_work_pos = inp_offset+2;
   // Secure Renegotiation extension
   if((pConnStruc->ConnectionState == CONN_STATE_CONNECTED) && 
      (pConnStruc->SecureRenegotiateFlag != 0))
   {
      ExtensionLen += ((int) pConnStruc->HandshakeClntFinished[0] & 0xFF) +
         1 + 4;
      inl_work_pos += GenerateRenegotExtension(pConnStruc,1,
                           abyp_dest_buf,inl_work_pos);
   }
   // Siganture extension
   if((pConnStruc->SupportedProtocolsFlags & TLS_V2_BIT_MASK) != 0 && 
      pConnStruc->pCfgStruc->achc_tls_12_sig_algs != NULL) {
      int inl_sig_len = 0;
      BIGword2char(TLS_SIG_ALG_EXT_TYPE,abyp_dest_buf,inl_work_pos);
      inl_sig_len= m_generate_sig_extension(
         pConnStruc->pCfgStruc->achc_tls_12_sig_algs,
         abyp_dest_buf, inl_work_pos+2);
      if(inl_sig_len < 4){
         return HSSL_CLNT_HELLO_INV_SIG_LIST;
      }
      BIGword2char(inl_sig_len,abyp_dest_buf,inl_work_pos);
      inl_work_pos += inl_sig_len;
      ExtensionLen += inl_sig_len+4;
   }
   // SRP extension
   if(( NULL != (pConnStruc->pCfgStruc)->amc_get_srp_name )){
      int inl_name_len = m_generate_srp_ext(abyp_dest_buf, inl_work_pos, pConnStruc);
      if( 6 > inl_name_len ){
         return (inl_name_len);
      }
      inl_work_pos += inl_name_len;
      ExtensionLen += inl_name_len;
   }
   
   ExtensionLen += m_write_sni_ext(&pConnStruc->dsc_ucs_se_host_name,
                                   abyp_dest_buf,
                                   inl_work_pos);

   ExtensionLen += m_write_alpn(pConnStruc, abyp_dest_buf, inl_work_pos);

   if(pConnStruc->pCfgStruc->boc_ecc_configured){
       // Write extensions needed for ECC
       memcpy(abyp_dest_buf+ inl_work_pos, byrs_ecc_client_extensions, sizeof(byrs_ecc_client_extensions));
       inl_work_pos += sizeof(byrs_ecc_client_extensions);
       ExtensionLen += sizeof(byrs_ecc_client_extensions);
   }

   if(ExtensionLen!=0){
      abyp_dest_buf[inp_offset++] = (char)(ExtensionLen <<8);
      abyp_dest_buf[inp_offset++] = (char) ExtensionLen;
   }
   return HSSL_OP_OK;
}

/**
* Generates client hello message from the connection structure parameters (GenerateClientHello).
* Updates Handshake Messages and enqueues Message for send to the priority queue.
*
*  @param pConnStruc Connection structure
*  @return HSSL_OP_OK on success, else error occured
*/
static  int  GenerateClientHello(CONNSTRU * pConnStruc)
{
  int ComprModesLen   = COMPR_METHODS_ENTRY_SIZE;	// preload
  int CipherSuitesLen = CIPHER_SUITE_ENTRY_SIZE;	// preload

#if defined XH_INTERFACE
  int MaxProtocol;
#endif

  int Retcode;
  int ActProtocol,MinorVersion;
  int CipherSpec,ComprMethod,SessionIDLen;

  int TotalLen,BufLen,AdditionalLen,ExtensionLen;
  int AddSavedIndex;
  int DstIndex = 0;

  int ltime;

  char* pDstBuf;

  char* lpCipherSuites = NULL;
  char* lpComprMethods = NULL;

  TX_QEL * pTxQel;

#ifdef XH_INTERFACE
  int CacheMode;
  HCLNT_CACHE_ELEM CacheTemplate;
#endif

  HMEM_CTX_DEF1;

  LOAD_HMEM_CTX_PTR(CONN_pMemCtx(pConnStruc));

  //----------------------------------------------------
  // Get session ID to use (from cache) if possible
  //----------------------------------------------------
  if(pConnStruc->RenegotiateMode == 0)	// not doing renegotiation
  {
    pConnStruc->CacheMode = CACHE_SESSION_TYPE_NON_CACHE;
    pConnStruc->SessionID[0] = 0;		// request a NEW session !!
#if defined XH_INTERFACE
    if((pConnStruc->ExtendedConfigFlags & SESS_CACHE_BIT_MASK) != 0)
    {
      //----------------------------------------------------------
      // Client side session caching is enabled, get cache element
      //----------------------------------------------------------
      if((pConnStruc->SupportedProtocolsFlags & TLS_V2_BIT_MASK) != 0)
        MaxProtocol = TLS_V2_PROT_TYPE;		// Start with TLS 1.2
      else if((pConnStruc->SupportedProtocolsFlags & TLS_V1_BIT_MASK) != 0)
        MaxProtocol = TLS_V1_PROT_TYPE;		// Start with TLS 1.1
      else if((pConnStruc->SupportedProtocolsFlags & TLS_BIT_MASK) != 0)
        MaxProtocol = TLS_PROT_TYPE;		// Start with TLS 1.0
      else
        MaxProtocol = SSL_MINOR_VERSION;	// use SSL V3.0

      memset(&CacheTemplate,0,sizeof(HCLNT_CACHE_ELEM));
      CacheTemplate.SelectedProtocol = (char) MaxProtocol;

      CacheMode = ClientCacheSessionCreate(HMEM_CTX_REF1
			&CacheTemplate,
			pConnStruc->pCfgStruc->CipherSuitesList,
			pConnStruc->pCfgStruc->CmprMethodsList);
      if(CacheMode >= 0)			// is valid !
        pConnStruc->CacheMode = (char) CacheMode;

      if(CacheMode > CACHE_SESSION_TYPE_NON_CACHE) // save connection ID!
      {
        memcpy(pConnStruc->ConnectionID,CacheTemplate.ConnectionID,
	       MAX_CONNECTION_ID_LEN+1);
      }

      if(CacheMode >= CACHE_SESSION_TYPE_RESUMED)
      {
        //---------------------------------------------------------
        // Client resumable session can be started, init parameters
        //---------------------------------------------------------
        pConnStruc->ActualProtocol       = CacheTemplate.SelectedProtocol;      
        pConnStruc->ActualCipherSuite  = CacheTemplate.SelectedCipherSuite;
        pConnStruc->ActualComprMethod = CacheTemplate.SelectedComprMethod;

        memcpy(pConnStruc->SessionID,CacheTemplate.SessionID,
	       MAX_SESSION_ID_LEN+1);

	memcpy(pConnStruc->MasterSecret,CacheTemplate.MasterSecret,
	       MASTER_SECRET_LEN);

        memcpy(pConnStruc->PartnerCertHash,CacheTemplate.PartnerCertHash,
	       SHA_DIGEST_LEN);

        pConnStruc->CertifiedFlags = CacheTemplate.CertifiedFlags;

        pConnStruc->HandshakeMode = SSL_SHORT_HANDSHAKE_MODE;
      }
    }
#endif // XH_INTERFACE
  }
  //----------------------------------------------------
  // Check if a specific Cipher Suite is selected
  //----------------------------------------------------
  CipherSpec = pConnStruc->ActualCipherSuite;	// get specific
  if(CipherSpec == -1)				// none set yet
  {
    lpCipherSuites = pConnStruc->pCfgStruc->CipherSuitesList;//get list
    if(lpCipherSuites == NULL)			// should not happen
      return(HSSL_NULL_PTR);
    BIGchar2wordn(lpCipherSuites,CipherSuitesLen,0); // get length
  }
  //----------------------------------------------------
  // Check if a specific Compression Method is selected
  //----------------------------------------------------
  ComprMethod =  pConnStruc->ActualComprMethod; // get specific
  if(ComprMethod == -1)				// none set yet
  {
    lpComprMethods = pConnStruc->pCfgStruc->CmprMethodsList; //get list
    if(lpComprMethods == NULL)			// should not happen
      return(HSSL_NULL_PTR);
    ComprModesLen = lpComprMethods[0];		// get count
  }
  //----------------------------------------------------
  // Get length of session ID (if present)
  //----------------------------------------------------
  SessionIDLen = (int) pConnStruc->SessionID[0] & 0xFF;

  //----------------------------------------------------
  // Check if initial Handshake (For Renegotiate SCSV)
  //----------------------------------------------------
  if(pConnStruc->ConnectionState != CONN_STATE_CONNECTED)
    AdditionalLen = 2;
  else
    AdditionalLen = 0;

  //---------------------------------------------------------
  // Check if secure renegotiate extension shall be generated
  //---------------------------------------------------------
  ExtensionLen = 0;
  if((pConnStruc->ConnectionState == CONN_STATE_CONNECTED) &&  // Renegotiate
     (pConnStruc->SecureRenegotiateFlag != 0))
  {
    ExtensionLen = ((int) pConnStruc->HandshakeClntFinished[0] & 0xFF) +
                   1 + 4;
  }

  // Check for SRP usage
  if(( NULL != (pConnStruc->pCfgStruc)->amc_get_srp_name )) {
     // Fetch name and add the required extension length
     Retcode = m_get_srp_name(HMEM_CTX_REF1 pConnStruc);
     if( HSSL_OP_OK != Retcode ){
        return Retcode;
     }
     ExtensionLen += (5 + (pConnStruc->adsc_srp_params[0].inc_name_len));
  }

  if( pConnStruc->dsc_ucs_se_host_name.imc_len_str != 0 ) {
      // Extension type, extension len, name list len, name type, name len and string len
      // The name is already propperly encoded
      ExtensionLen += 9 + pConnStruc->dsc_ucs_se_host_name.imc_len_str;
  }

  if( pConnStruc->pCfgStruc->boc_ecc_configured ){
      ExtensionLen += sizeof(byrs_ecc_client_extensions);
      pConnStruc->boc_ecc_possible = true;
  }
  //----------------------------------------------------------
  // Check if signature algorithm extension shall be generated
  //----------------------------------------------------------
  if((pConnStruc->SupportedProtocolsFlags & TLS_V2_BIT_MASK) != 0  &&
     pConnStruc->pCfgStruc->achc_tls_12_sig_algs != NULL){
     // TLS 1.2 with configured sigs. Add extension and store the allowed signature algorithms.
     char achl_sig_ext_tmp[MAX_SIG_EXT_LEN];
     ExtensionLen += m_generate_sig_extension(
        (pConnStruc->pCfgStruc->achc_tls_12_sig_algs), achl_sig_ext_tmp,0)+4;
     size_t szl_len = ((size_t) (pConnStruc->pCfgStruc->achc_tls_12_sig_algs[0]))+1;
     pConnStruc->abyc_remote_sig_algs = BIT8_ARRAY_ALLOC(HMEM_CTX_REF, (int)szl_len);
     memcpy(pConnStruc->abyc_remote_sig_algs, 
            pConnStruc->pCfgStruc->achc_tls_12_sig_algs,
            szl_len);
  }
  if(ExtensionLen != 0){
     ExtensionLen += 2;
  }
   
  ExtensionLen += m_get_alpn_len(pConnStruc);
  
  //----------------------------------------------------
  // Calculate Required Buffer Length
  //----------------------------------------------------
  BufLen   = HT_MESSAGE_SIZE + HT_LENGTH_SIZE +
	     VERSION_SIZE + CLIENT_HELLO_RANDOM_LEN +
	     SESSION_ID_LEN_SIZE + SessionIDLen +
             CIPHER_SUITES_LEN_SIZE + CipherSuitesLen + AdditionalLen +
	     COMPR_METHODS_LEN_SIZE + ComprModesLen +
	     ExtensionLen;
  TotalLen = BufLen - HT_RECORD_HDR_SIZE;
  //----------------------------------------------------
  // Allocate TX-Qel with buffer
  //----------------------------------------------------
  pTxQel = AllocInitTxQel(HMEM_CTX_REF1
			  BufLen,(unsigned char) TX_TYPE_HANDSHAKE_MSG);
  if(pTxQel == NULL)
    return(HSSL_TX_QEL_ALLOC_ERR);
  pDstBuf = pTxQel->pBuf;		// get buffer base
  //----------------------------------------------------
  // set ClientHello Message and length (Header)
  //----------------------------------------------------
  pDstBuf[DstIndex++] = HT_CLIENT_HELLO;
  pDstBuf[DstIndex++] = 0;			// is less 2^16
  pDstBuf[DstIndex++] = (char) (TotalLen >> 8);	// store MSB
  pDstBuf[DstIndex++] = (char) TotalLen;	// store LSB
  //----------------------------------------------------
  // set Client Version, according to mode / config.
  //----------------------------------------------------
  pDstBuf[DstIndex++] = TLS_SSL_MAJOR_VERSION;// TLS/SSL

  ActProtocol = pConnStruc->ActualProtocol;

  if(pConnStruc->HandshakeMode != 0)	// doing resume/renegotiate
  {
    //----------------------------------
    // Short connect mode (resume/clone)
    //----------------------------------
    if(ActProtocol == TLS_V2_PROT_TYPE)
      MinorVersion = TLS12_MINOR_VERSION;		// Set TLS 1.2
    else if(ActProtocol == TLS_V1_PROT_TYPE)
      MinorVersion = TLS11_MINOR_VERSION;		// Set TLS 1.1
    else if(ActProtocol == TLS_PROT_TYPE)
      MinorVersion = TLS10_MINOR_VERSION;		// Set TLS 1.0
    else if(ActProtocol == SSL_PROT_TYPE)
      MinorVersion = SSL_MINOR_VERSION;			// Set SSL 3
    else
      return(HSSL_PARAM_ERR);				// should not happen...

    pDstBuf[DstIndex++] = (unsigned char) MinorVersion;	// Set the minor version
  }
  else
  {
    //---------------------------------------------------------------
    // Initial negotiation, set highest possible Version
    //---------------------------------------------------------------
    if((pConnStruc->SupportedProtocolsFlags & TLS_V2_BIT_MASK) != 0)
      MinorVersion = TLS12_MINOR_VERSION;	// Start with TLS 1.2
    else if((pConnStruc->SupportedProtocolsFlags & TLS_V1_BIT_MASK) != 0)
      MinorVersion = TLS11_MINOR_VERSION;	// Start with TLS 1.1
    else if((pConnStruc->SupportedProtocolsFlags & TLS_BIT_MASK) != 0)
      MinorVersion = TLS10_MINOR_VERSION;	// Start with TLS 1.0
    else if((pConnStruc->SupportedProtocolsFlags & SSL_BIT_MASK) != 0)
      MinorVersion = SSL_MINOR_VERSION;		// use SSL V3.0
    else
      return(HSSL_PARAM_ERR);

    pDstBuf[DstIndex++] = (unsigned char) MinorVersion;	// Set the minor version
  }
  //----------------------------------------------------
  // get system UNIX time, convert from long to bytes
  //----------------------------------------------------
//  ltime = GET_SYSTEM_TIME_UTC(RANDinst);	// get the time
  ltime = SecGetSystemTimeUTC();	// get the time
  BIGlong2charn(ltime,pDstBuf,DstIndex);	// convert, store
  //----------------------------------------------------
  // get 28 Random bytes, save the whole Random
  //----------------------------------------------------
  Retcode = SecDrbgRandBytes(HMEM_CTX_REF1 pDstBuf,DstIndex+4,HELLO_RANDOM_LEN);
  if(Retcode != 0)
  {
    FREE_ARRAY_POOL(HMEM_CTX_REF,pDstBuf);
    FREE_ARRAY(HMEM_CTX_REF,pTxQel);
    return(HSSL_RNG_FETCH_ERROR);
  }
  memcpy(pConnStruc->ClientRandom+0,pDstBuf+DstIndex,CLIENT_HELLO_RANDOM_LEN);
  DstIndex += CLIENT_HELLO_RANDOM_LEN;		// past random
  //----------------------------------------------------
  // copy the session ID length and ID if present
  //----------------------------------------------------
  pDstBuf[DstIndex++] = (char) SessionIDLen;	// set length
  if(SessionIDLen != 0)
  {
    memcpy(pDstBuf+DstIndex,pConnStruc->SessionID+1,SessionIDLen);
    DstIndex += SessionIDLen;
  }
  //----------------------------------------------------
  // copy the Cipher Suites list or given Cipher Suite
  //----------------------------------------------------
  AddSavedIndex = DstIndex;
  BIGword2char(CipherSuitesLen,pDstBuf,DstIndex);
  if(lpCipherSuites == NULL)
  {
    BIGword2char(CipherSpec,pDstBuf,DstIndex);
  }
  else
  {
    memcpy(pDstBuf+DstIndex,lpCipherSuites+2,CipherSuitesLen);
    DstIndex += CipherSuitesLen;
  }

  if(AdditionalLen != 0)			// Add SCSV for renegot.
  {
    pDstBuf[DstIndex++] = (unsigned char) 0x00;		// SCSV MSB
    pDstBuf[DstIndex++] = (unsigned char) 0xFF;		// SCSV LSB
    BIGword2char((CipherSuitesLen+AdditionalLen),pDstBuf,AddSavedIndex);
  }
  //----------------------------------------------------
  // copy the Compression Modes list or given Mode
  //----------------------------------------------------
  pDstBuf[DstIndex++] = (char) ComprModesLen;
  if(lpComprMethods == NULL)
    pDstBuf[DstIndex++] = (char) ComprMethod;		// copy given
  else
  {
    memcpy(pDstBuf+DstIndex,lpComprMethods+1,ComprModesLen);
    DstIndex += ComprModesLen;
  }
  //----------------------------------------------------
  // Generate extensions as required
  //----------------------------------------------------
  Retcode = m_generate_extensions(pConnStruc, pDstBuf, DstIndex);
  if(Retcode != HSSL_OP_OK){
     return Retcode;
  }
  //------------------------------------------------------------
  // Update Handshake Hashes, reset hashes if renegotiate active
  //------------------------------------------------------------
  if(pConnStruc->RenegotiateMode == SSL_RENEGOTIATE_ACTIVE)
  {
    //---------------------------------------------------------
    // Reset the Message Hash states, start of a new handshake!
    //---------------------------------------------------------
    MD5_Init(pConnStruc->HandshakeMD5_State);
    SHA1_Init(pConnStruc->HandshakeSHA1_State);
    SHA256_Init(pConnStruc->HandshakeSHA256_State);
    SHA384_Init(pConnStruc->HandshakeSHA384_State);
    SHA512_Init(pConnStruc->HandshakeSHA512_State);
  }

  HashHandshakeMessage(pConnStruc,pDstBuf,0, BufLen);

  //----------------------------------------------------
  // Enqueue TX-Quel for send
  //----------------------------------------------------
  pTxQel->DataLen = BufLen;
  EnqueueTxQel(pConnStruc,pTxQel);

  //----------------------------------------------------
  // Set Renegotiate timeout if renegotiate mode active
  //----------------------------------------------------
  if(pConnStruc->RenegotiateMode != 0)	// ARE doing renegotiation
    SetRenegotiateTimer(pConnStruc, 1);
  return(HSSL_OP_OK);
}

static bool ms_check_invalid_fallback(const CONNSTRU* adsp_session,
                                      int inp_client_minor_version,
                                      const unsigned short* ausp_ciphers,
                                      int inp_cipher_len)
{
    static unsigned short usl_fallback_scsv = htons(TLS_FALLBACK_SCSV);

    while(inp_cipher_len > 0){
        if(*ausp_ciphers == usl_fallback_scsv){
            switch(inp_client_minor_version) {
            // Fall through from lowest to highest version, looking for a higher version configured
            // If this is the case, it is an illegal fallback
            case SSL_MINOR_VERSION:
                if((adsp_session->SupportedProtocolsFlags & TLS_BIT_MASK) !=  0){
                    return true;
                }
            case TLS10_MINOR_VERSION:
                if((adsp_session->SupportedProtocolsFlags & TLS_V1_BIT_MASK) !=  0){
                    return true;
                }
            case TLS11_MINOR_VERSION:
                if((adsp_session->SupportedProtocolsFlags & TLS_V2_BIT_MASK) !=  0){
                    return true;
                }
            default:
                // No higher version than client minor found
                return false;
            }
        }
        ausp_ciphers++;
        inp_cipher_len -= 2;
    }

    // No fallback scsv found
    return false;
}

/**
* Checks/processes client hello message (ProcessClientHello).
*<ol>
* <li> Check the Version (if supported at all), save it.
* <li> Save the Client Random.
* <li> Check if a session resume is requested, if so
*    search for a match if caching is enabled.
*    If no match found, generate a unique session ID, if caching
*    is enabled, and check for duplicate.
*    If match is found, get protocol / Compression method / Ciphersuite
*    and Mastersecret from session structure.
* <li> Check the protocol for a match to own Protocol, save.
* <li> Check the Cipher suites list for a match to own Ciphersuite/List,
*    save suite.
* <li> Check the Compression methods list for a match to own Method/List,
*    save method.
*</ol>
*  @param pConnStruc Connection structure
*  @param InpBuf Buffer Base
*  @param InpOffset Start of data
*  @param DataLen Input data count
*  @param pAlertType type of Alert on Error
*  @param pAlertLvl level of Alert on Error
*
*  @return HSSL_OP_OK on success, else error occured
*/
static int  ProcessClientHello(CONNSTRU * pConnStruc,
		   char* InpBuf, int InpOffset, int DataLen,
		   int* pAlertType, int* pAlertLvl)
{
  int i,Retcode;
  int SessionIDStartIndex,SessionIDLen;
  int CipherSuitesStartIndex,CipherSuitesLen;
  int ComprMethodsStartIndex,ComprMethodsLen;

  int MsgLen;
  int RenegotScsvFlag;

  int InpIndex = InpOffset;

  int ClientMinorVersion,ClientProt; // ActProt;
  int CipherSuite,ComprMethod;

#if defined XH_INTERFACE
  HSERV_CACHE_ELEM CacheTemplate;
#endif

  HMEM_CTX_DEF1;

  LOAD_HMEM_CTX_PTR(CONN_pMemCtx(pConnStruc));

  //-------------------------------------------------------
  // Preset Alert Type and Level to Illegal parameter/Fatal
  //-------------------------------------------------------
  pAlertType[0] = AD_ILLEGAL_PARAMETER;
  pAlertLvl[0]  = ALERT_LEVEL_FATAL;
  //----------------------------------------------------
  // Get/check Message length
  //----------------------------------------------------
  BIGchar2longn(InpBuf,MsgLen,InpIndex);		// from 1st 4 bytes
  MsgLen &= 0xFFFFFF;				// only 3 bytes valid
  InpIndex += HT_LENGTH_SIZE;			// skip size
  DataLen  -= HT_RECORD_HDR_SIZE;		// reduce length
  InpIndex++;

  if((DataLen <= 0) || (DataLen != MsgLen) ||
     (MsgLen < (VERSION_SIZE + UTC_TIME_LEN +  	//ckeck min. length
		HELLO_RANDOM_LEN +
                SESSION_ID_LEN_SIZE +
                CIPHER_SUITE_ENTRY_SIZE +
                COMPR_METHODS_ENTRY_SIZE)))
    return(HSSL_CLNT_HELLO_INVALID_MSGLEN);	// inconsistent data size
  //----------------------------------------------------
  // Check Client Version (SSL 3.0 / TLS 1.0/1.1/1.2)
  //----------------------------------------------------
  if(InpBuf[InpIndex++] != TLS_SSL_MAJOR_VERSION)	// check major version
    return(HSSL_CLNT_HELLO_UNSUPP_VERSION);
  ClientMinorVersion = InpBuf[InpIndex++];		// get minor version

// Do NOT Check for low version here (higher versions !!!)

  pConnStruc->MaximumProtocol = (char) ClientMinorVersion;	// save for Key Exchg.

  // Transcode minor version to protocol type
  if(ClientMinorVersion >= TLS12_MINOR_VERSION)
    ClientProt = TLS_V2_PROT_TYPE;
  else if(ClientMinorVersion == TLS11_MINOR_VERSION)
    ClientProt = TLS_V1_PROT_TYPE;
  else if(ClientMinorVersion == TLS10_MINOR_VERSION)
    ClientProt = TLS_PROT_TYPE;
  else
    ClientProt = SSL_PROT_TYPE;
  //----------------------------------------------------
  // Copy Client Random to Structure
  //----------------------------------------------------
  memcpy(pConnStruc->ClientRandom+0,InpBuf+InpIndex,CLIENT_HELLO_RANDOM_LEN);
  InpIndex += CLIENT_HELLO_RANDOM_LEN;
  //----------------------------------------------------
  // Calculate remaining data length
  //----------------------------------------------------
  DataLen -= (VERSION_SIZE + UTC_TIME_LEN + HELLO_RANDOM_LEN);
  //----------------------------------------------------
  // Check Session ID length if valid and enough data present
  //----------------------------------------------------
  SessionIDStartIndex = InpIndex;
  SessionIDLen = (int) InpBuf[InpIndex] & 0xFF; // get length
  if((SessionIDLen > MAX_SESSION_ID_LEN) ||
     (SessionIDLen > (DataLen -
                      CIPHER_SUITES_LEN_SIZE -
                      COMPR_METHODS_LEN_SIZE)))
    return(HSSL_CLNT_HELLO_INV_SESS_ID_LEN);

  InpIndex += (SessionIDLen+1);			// advance index
  DataLen  -= (SessionIDLen+1);			// reduce length
  //-----------------------------------------------------------------
  // Get Clients Cipher Suite List, check length
  //-----------------------------------------------------------------
  CipherSuitesStartIndex = InpIndex;
  BIGchar2wordn(InpBuf,CipherSuitesLen,InpIndex); // get length of list
  if((CipherSuitesLen == 0) ||			// may not be zero
     ((CipherSuitesLen & 0x01) != 0) ||		// not even !
     (CipherSuitesLen > (DataLen - COMPR_METHODS_LEN_SIZE)))
    return(HSSL_CLNT_HELLO_INVALID_MSGLEN);
  //---------------------------------------------------
  // Check for specific Renegotiation SCVS
  //---------------------------------------------------
  RenegotScsvFlag = CheckClntCiphSuitesForInfoScsv(InpBuf,InpIndex+2,
						   CipherSuitesLen);
  if(RenegotScsvFlag != 0)			// found the SCSV
  {
    if(pConnStruc->ConnectionState == CONN_STATE_CONNECTED) // is Illegal!
    {
      pAlertType[0] = AD_HSHAKE_FAILURE;
      pAlertLvl[0]  = ALERT_LEVEL_FATAL;
      return(HSSL_CLNT_HELLO_NO_RENEGOTIATE);
    }
    else					// initial handshake
    {
      pConnStruc->SecureRenegotiateFlag = 1;
    }
  }

  if(ms_check_invalid_fallback(pConnStruc,
                               ClientMinorVersion,
                               (unsigned short*)(InpBuf + InpIndex +2),
                               CipherSuitesLen))
  {
      pAlertType[0] = AD_INAPPROPRIATE_FALLBACK;
      pAlertLvl[0] = ALERT_LEVEL_FATAL;
      return HSSL_CLNT_HELLO_INAP_FALLBACK;
  }

  InpIndex += (CipherSuitesLen + CIPHER_SUITES_LEN_SIZE); // advance index
  DataLen  -= (CipherSuitesLen + CIPHER_SUITES_LEN_SIZE); // reduce count
  //-----------------------------------------------------------------
  // Get Clients Compression Methods List, check length
  //-----------------------------------------------------------------
  ComprMethodsStartIndex = InpIndex;
  ComprMethodsLen = (((int)InpBuf[InpIndex++])&0xff);		// get the length
  DataLen--;
  if((ComprMethodsLen == 0) ||
     (ComprMethodsLen > DataLen))
    return(HSSL_CLNT_HELLO_INVALID_MSGLEN);

  DataLen -= ComprMethodsLen;
  InpIndex += ComprMethodsLen;

  //------------------------------------------------------
  // Check for secure renegotiate extension
  //------------------------------------------------------
  if(DataLen != 0)
  {
    // Workaround to assure, that signature extensions are only processed, if TLS 1.2 will be negotiated
     /** @todo make a real sollution */
     int inl_minor_ver = ClientMinorVersion;
    if((TLS12_MINOR_VERSION == inl_minor_ver) &&
       ((pConnStruc->SupportedProtocolsFlags & TLS_V2_BIT_MASK) ==  0))
    {
      inl_minor_ver--;
    }
     Retcode = m_process_tls_extension( HMEM_CTX_REF1 InpBuf, DataLen, InpIndex,
                         pConnStruc,pAlertType,pAlertLvl,inl_minor_ver);
    if(Retcode != HSSL_OP_OK)
      return(Retcode);
  }

  //=================================================================
  // Check if this is a renegotiation 'start'
  //=================================================================
//  if((CONN_ConnState(pConnStruc) == CONN_STATE_CONNECTED) &&
//     (CONN_HandshakeMode(pConnStruc) != 0))		// short mode
  if(pConnStruc->ConnectionState == CONN_STATE_CONNECTED)
  {/** @todo make full check on renegotiation */
     // Never renegotiate
     pAlertType[0] = AD_NO_RENEGOTIATION;
     pAlertLvl[0]  = ALERT_LEVEL_WARNING;
     return(HSSL_CLNT_HELLO_NO_RENEGOTIATE);
  }
  //================================================================
  // 'Normal' connect request mode, with/without session ID, check
  //================================================================
  pConnStruc->HandshakeMode = SSL_NORMAL_HANDSHAKE_MODE;

  pConnStruc->SessionID[0] = 0;		// assure empty session ID
  pConnStruc->CacheMode = CACHE_SESSION_TYPE_NON_CACHE;

#if defined XH_INTERFACE
  if((pConnStruc->ExtendedConfigFlags & SESS_CACHE_BIT_MASK) != 0)
  {
    //--------------------------------------------------------------
    // Caching is enabled, generate a Random session ID ahead,
    // Prepare cache template structure
    //--------------------------------------------------------------
    pConnStruc->SessionID[0] = MAX_SESSION_ID_LEN;
    Retcode = SecDrbgRandBytes(HMEM_CTX_REF1 pConnStruc->SessionID,1,MAX_SESSION_ID_LEN); 
    if(Retcode != 0)
      return(Retcode);

    memset(&CacheTemplate,0,sizeof(HSERV_CACHE_ELEM));

    if(SessionIDLen == 0)			// new session requested
    {
      //------------------------------------------------------
      // Client did NOT specify a session ID, get a new ID
      //------------------------------------------------------
      i = ServerCacheSessionCreate(CONN_pMemCtx(pConnStruc),
			       &CacheTemplate,pConnStruc->SessionID,
                               CACHE_SESSION_CREATE_NEW,NULL,NULL);
      pConnStruc->SessionID[0] = 0;		// in case of fault!
      if(i == CACHE_SESSION_TYPE_NEW)
      {
        memcpy(pConnStruc->SessionID,
               CacheTemplate.SessionID,MAX_SESSION_ID_LEN+1);
        pConnStruc->CacheMode = CACHE_SESSION_TYPE_NEW;
      }
    }
    else					// client given ID
    {
      //------------------------------------------------------
      // Client specified a session ID, check if in cache
      //------------------------------------------------------
      // Store protocol and session ID from client to template
      CacheTemplate.SelectedProtocol = (unsigned char) ClientProt;
      memcpy(CacheTemplate.SessionID,
             InpBuf+SessionIDStartIndex,SessionIDLen+1);

      i = ServerCacheSessionCreate(CONN_pMemCtx(pConnStruc),
			       &CacheTemplate,pConnStruc->SessionID,
                               CACHE_SESSION_CREATE_USE_EXISTING,
			       InpBuf+CipherSuitesStartIndex,
			       InpBuf+ComprMethodsStartIndex);
      pConnStruc->SessionID[0] = 0;		// in case of fault!
      if(i >= 0)				// valid response
      {
        //-------------------------------------------------------
        // Valid response from cache, save type, get session ID
        //-------------------------------------------------------
        if(i == 0)				// not found indication
          i = CACHE_SESSION_TYPE_NEW;

        pConnStruc->CacheMode = (unsigned char) i;	// set cache mode returned
        memcpy(pConnStruc->SessionID,
               CacheTemplate.SessionID,MAX_SESSION_ID_LEN+1);
        if(i >= CACHE_SESSION_TYPE_RESUMED)	// short handshake !!
        {
          //-------------------------------------------------------
          // Resumed/Cloned session, set the needed parameters
          //-------------------------------------------------------
          pConnStruc->ActualProtocol       = CacheTemplate.SelectedProtocol;
          pConnStruc->ActualCipherSuite  = CacheTemplate.SelectedCipherSuite;
          pConnStruc->ActualComprMethod = CacheTemplate.SelectedComprMethod;

          if(SetCipherSuiteParams(pConnStruc,
			pConnStruc->ActualCipherSuite) != HSSL_OP_OK)
            return(HSSL_CLNT_HELLO_UNSUP_CIPHSUITE);	//  change ??

          if(SetComprMethodsParams(pConnStruc,
			pConnStruc->ActualComprMethod) != HSSL_OP_OK)
          {
            pAlertType[0] = AD_INTERNAL_ERROR;
            return(HSSL_CLNT_HELLO_UNDEF_CMPR_METH);	// change ???
          }
          memcpy(pConnStruc->MasterSecret,
		 CacheTemplate.MasterSecret,MASTER_SECRET_LEN);

          memcpy(pConnStruc->PartnerCertHash,
		 CacheTemplate.PartnerCertHash,SHA_DIGEST_LEN);
          pConnStruc->CertifiedFlags = CacheTemplate.CertifiedFlags;

          pConnStruc->HandshakeMode = SSL_SHORT_HANDSHAKE_MODE;
        }
      }
    }
  }
#endif // XH_INTERFACE
  //--------------------------------------------------------------------
  // Negotiate the initial parameters: Version, Ciphersuite, ComprMethod
  // Only needed, when in non cache/new session state; resume/clone
  // checking has already be done !!!
  //--------------------------------------------------------------------
  if(pConnStruc->HandshakeMode == SSL_SHORT_HANDSHAKE_MODE)
  {
    //----------------------------------------------------
    // Resumed/Cloned, Setup the pending cipher states
    //----------------------------------------------------
    pConnStruc->PendRX_ComprAlgor = pConnStruc->ActualComprMethod;
    pConnStruc->PendTX_ComprAlgor = pConnStruc->ActualComprMethod;

    pConnStruc->PendRX_EncAlgor = pConnStruc->CipherAlgor;
    pConnStruc->PendTX_EncAlgor = pConnStruc->CipherAlgor;

    pConnStruc->PendRX_MACAlgor = pConnStruc->MacAlgorType;
    pConnStruc->PendTX_MACAlgor = pConnStruc->MacAlgorType;
    return (HSSL_OP_OK);
  }
  //--------------------------------------------------------------------
  // New session mode, full negotiation needed ...
  // Session-ID already loaded/set empty
  //--------------------------------------------------------------------
  if(ClientMinorVersion== SSL_MINOR_VERSION){
    pAlertType[0] = AD_HSHAKE_FAILURE;
  } else {
    pAlertType[0] = AD_PROTOCOL_VERSION;		// TLS type
  }
  //-----------------------------------------------------------------
  // Check if Protocol is supported/valid
  //-----------------------------------------------------------------
  switch(ClientMinorVersion) {  // Fall through from highest to lowest minor version.
    case TLS12_MINOR_VERSION:
        if((pConnStruc->SupportedProtocolsFlags & TLS_V2_BIT_MASK) !=  0){ // server can TLS1.2
          pConnStruc->ActualProtocol = TLS_V2_PROT_TYPE;	// so select TLS 1.2
          break;
        }
    case TLS11_MINOR_VERSION:
        if((pConnStruc->SupportedProtocolsFlags & TLS_V1_BIT_MASK) !=  0){ // server can TLS1.1
          pConnStruc->ActualProtocol = TLS_V1_PROT_TYPE;	// so select TLS 1.1
          break;
        }
    case TLS10_MINOR_VERSION:
        if((pConnStruc->SupportedProtocolsFlags & TLS_BIT_MASK) !=  0){ // server can TLS1.0
            pConnStruc->ActualProtocol = TLS_PROT_TYPE;		// so select TLS 1.0
          break;
        }
    case SSL_MINOR_VERSION:
        if((pConnStruc->SupportedProtocolsFlags & SSL_BIT_MASK) != 0) // SSL fallback
            pConnStruc->ActualProtocol = SSL_PROT_TYPE;	// so select SSL
        else
            return(HSSL_CLNT_HELLO_UNSUPP_VERSION);		// stop connection
  }
  //-----------------------------------------------------------------
  // Search for a Cipher Suite match
  // TLS V1.1 does no longer support exportable ciphersuites,
  // ----- so do NOT negotiate exportable ones!!
  //-----------------------------------------------------------------
  pAlertType[0] = AD_HSHAKE_FAILURE;		// default alert type

  switch(pConnStruc->ActualProtocol){
     case TLS_V2_PROT_TYPE: 
        i = CIPH_TLS12;
        break;
     case TLS_V1_PROT_TYPE:
        i = CIPH_TLS11;
        break;
     default:        //SSL3/TLS1.0, equivalent to 'Exportable'
        i = 1;
        break;
  }

  bool bol_allow_ecc = (pConnStruc->iec_selected_curve != ied_ec_curve_none) &
                        pConnStruc->boc_ecc_possible;

  CipherSuite = (int) GetCipherSuiteListMatch(InpBuf,
                                              CipherSuitesStartIndex,
                                              pConnStruc->pCfgStruc->CipherSuitesList,
                                              0,
                                              i,
                                              bol_allow_ecc);
  if(CipherSuite <= 0)					// not matched!!
    return(HSSL_CLNT_HELLO_UNSUP_CIPHSUITE);		// set error

  pConnStruc->ActualCipherSuite = CipherSuite;
  //----------------------------------------------------
  // set parameters according to selected cipher suite
  //----------------------------------------------------
  if(SetCipherSuiteParams(pConnStruc,CipherSuite) != HSSL_OP_OK)
    return(HSSL_CLNT_HELLO_UNSUP_CIPHSUITE);

  //-----------------------------------------------------------------
  // Search for a Compression Method match
  //-----------------------------------------------------------------
  ComprMethod = (int) GetCompressionListMatch(InpBuf,ComprMethodsStartIndex,
			 pConnStruc->pCfgStruc->CmprMethodsList,0);
  if(ComprMethod < 0)
    return(HSSL_CLNT_HELLO_UNSUPP_CMPRMETH);		// error occured

  pConnStruc->ActualComprMethod = (char) ComprMethod;
  //--------------------------------------------------------
  // set parameters according to selected compression method
  //--------------------------------------------------------
  if(SetComprMethodsParams(pConnStruc,ComprMethod) != HSSL_OP_OK)
  {
    pAlertType[0] = AD_INTERNAL_ERROR;
    return(HSSL_CLNT_HELLO_UNDEF_CMPR_METH);		// error occured
  }
  //----------------------------------------------------
  // Setup the pending cipher states
  //----------------------------------------------------
  pConnStruc->PendRX_ComprAlgor = pConnStruc->ActualComprMethod;
  pConnStruc->PendTX_ComprAlgor = pConnStruc->ActualComprMethod;

  pConnStruc->PendRX_EncAlgor = pConnStruc->CipherAlgor;
  pConnStruc->PendTX_EncAlgor = pConnStruc->CipherAlgor;

  pConnStruc->PendRX_MACAlgor = pConnStruc->MacAlgorType;
  pConnStruc->PendTX_MACAlgor = pConnStruc->MacAlgorType;

  return(HSSL_OP_OK);
}

/**
* Checks/processes SSL-V2 Compatible Client Hello Message (ProcessV2_ClientHello).
*<ol>
* <li> Check/Convert SSL V2 Client Hello to SSL-V3/TLS Client Hello.
* <li> Run converted Message through 'normal' Client Hello.
*</ol>
*  @param pConnStruc Connection structure
*  @param InpBuf Buffer Base
*  @param InpOffset Start of data
*  @param DataLen Input data count
*  @param pAlertType type of Alert on Error
*  @param pAlertLvl level of Alert on Error
*
*  @return HSSL_OP_OK on success, else error occured
*/
static int  ProcessV2_ClientHello(CONNSTRU * pConnStruc,
		   char* InpBuf, int InpOffset, int DataLen,
		   int* pAlertType, int* pAlertLvl)
{
  int SrcIndex = InpOffset + SSL_V2_CIPHER_SPEC_LEN_INDEX;
  int DstIndex = 0;
  int Index;
  int Count;
  int Retcode;

  int V2_CipherSpecLen;
  int V2_SessionIDLen;
  int V2_ChallengeLen;
  int V2_CipherSuitesCnt;
  int V2_ChallengeStartIndex;
  
  int DstBufLen;
  int V3_CipherSuitesCnt;
  int DstDataLen;

  char* pDstBuf = NULL;

  HMEM_CTX_DEF1;
  LOAD_HMEM_CTX_PTR(CONN_pMemCtx(pConnStruc));

  //-------------------------------------------------------
  // Preset Alert Type and Level to Illegal parameter/Fatal
  //-------------------------------------------------------
  pAlertType[0] = AD_ILLEGAL_PARAMETER;
  pAlertLvl[0]  = ALERT_LEVEL_FATAL;
  //----------------------------------------------------
  // Extract the V2 length Parameters, check them
  //----------------------------------------------------
  BIGchar2word(InpBuf,V2_CipherSpecLen,SrcIndex); // get Cipher Specs size
  BIGchar2word(InpBuf,V2_SessionIDLen,SrcIndex);  // get Session ID size
  BIGchar2word(InpBuf,V2_ChallengeLen,SrcIndex);  // get Challenge size

  if((V2_CipherSpecLen < 3) || ((V2_CipherSpecLen % 3) != 0))
    return(HSSL_CLNT_HELLO_INVALID_MSGLEN);
  if(V2_SessionIDLen != 0)
    return(HSSL_CLNT_HELLO_INV_SESS_ID_LEN);
  if((V2_ChallengeLen < SSL_V2_CHALLENGE_MIN_LEN) ||
     (V2_ChallengeLen > SSL_V2_CHALLENGE_MAX_LEN))
    return(HSSL_CLNT_HELLO_INVALID_MSGLEN);
  //----------------------------------------------------
  // Check overall Message length consistency
  //----------------------------------------------------
  if(DataLen != (SSL_V2_HDR_LEN + SSL_V2_CLIENT_HELLO_FIXED_LEN +
	         V2_CipherSpecLen + V2_SessionIDLen + V2_ChallengeLen))
    return(HSSL_CLNT_HELLO_INVALID_MSGLEN);
  //-------------------------------------------------------------------
  // Check if there is at least one SSL-V3/TLS Cipher Suite in the list
  // SSL-V3 Cipher suites MUST have a leading 0x00 byte in SSL-V2
  // ----- AND should have high byte set to 0x00 also !!
  //-------------------------------------------------------------------
  V2_CipherSuitesCnt = V2_CipherSpecLen / 3;	// cannot be <= 0 (see above)
  Index = SrcIndex;				// Start of Cipher suites
  Count = V2_CipherSuitesCnt;			// number of suites, V2
  V3_CipherSuitesCnt = 0;
  do
  {
    if((InpBuf[Index] == 0) &&			// V3 Suite recognized
       (InpBuf[Index+1] == 0))			// also not private
      V3_CipherSuitesCnt++;
    Index += 3;					// to next suite ID
    Count--;					// reduce count
  }while(Count != 0);
  V2_ChallengeStartIndex = Index;		// save for later
  if(V3_CipherSuitesCnt == 0)
  {
    pAlertType[0] = AD_HSHAKE_FAILURE;
    return(HSSL_CLNT_HELLO_UNSUP_CIPHSUITE);	// error occured
  }
  //-----------------------------------------------------
  // Allocate Required Destination buffer (incl Header !)
  //-----------------------------------------------------
  DstBufLen = RECORD_HDR_SIZE +			// Fragment Header, 5 byte
              HT_RECORD_HDR_SIZE +		// Message  Header, 4 Byte
	      RH_VERSION_SIZE +			// 2 Byte Client Version
	      CLIENT_HELLO_RANDOM_LEN +		// 32 Byte Client Random
	      1 +				// 0+1 Byte session ID
              (V3_CipherSuitesCnt * 2) + 2 +	// 2n+2 Byte cipher suites list
	      1 + 1;				// 1+1  Byte compr. methods
  pDstBuf = BIT8_ARRAY_ALLOC_POOL(HMEM_CTX_REF,DstBufLen);
  if(pDstBuf == NULL)
  {
    pAlertType[0] = AD_INTERNAL_ERROR;
    return(HSSL_RX_BUF_ALLOC_ERR);
  }
  //-----------------------------------------------------
  // Generate the SSL-V3/TLS compatible Record/Message
  // 1. Generate the Record Header (w/o length)
  //-----------------------------------------------------
  pDstBuf[DstIndex++] = CT_HANDSHAKE;		// +0: Fragment Type
  pDstBuf[DstIndex++] =				// +1: Version MSB
    InpBuf[InpOffset+RH_VERSION_MSB_V2];
  pDstBuf[DstIndex] =				// +2: Version LSB
    InpBuf[InpOffset+RH_VERSION_LSB_V2];

  //-----------------------------------------------------
  // 2. Generate the Message Header (w/o length)
  //-----------------------------------------------------
  DstIndex = RECORD_HDR_SIZE;  
  pDstBuf[DstIndex++] = HT_CLIENT_HELLO;	// + 5: Message Type
  pDstBuf[DstIndex]   = 0;			// + 6: Len High Byte

  DstIndex += 3;	
  //-------------------------------------------------------------
  // 3. Copy Version to Client Version, Challenge to ClientRandom
  //-------------------------------------------------------------
  pDstBuf[DstIndex++] =				// + 9: Client Version MSB
    InpBuf[InpOffset+RH_VERSION_MSB_V2];	
  pDstBuf[DstIndex++] =				// +10: Client Version LSB
    InpBuf[InpOffset+RH_VERSION_LSB_V2];
  memset(pDstBuf+DstIndex,0,CLIENT_HELLO_RANDOM_LEN); // zero Random
  DstIndex += (CLIENT_HELLO_RANDOM_LEN-V2_ChallengeLen); // right justify
  memcpy(pDstBuf+DstIndex,InpBuf+V2_ChallengeStartIndex,V2_ChallengeLen);
  DstIndex += V2_ChallengeLen;
  //-------------------------------------------------------------
  // 4. Set Session ID-length zero, copy V3 Ciphersuites
  //-------------------------------------------------------------
  pDstBuf[DstIndex++] = 0;			// +43: SessionID-length = 0
  BIGword2char((V3_CipherSuitesCnt*2),pDstBuf,DstIndex); // +44: CiphersuitesCnt
  Index = SrcIndex;
  Count = V2_CipherSuitesCnt;
  do
  {
    if((InpBuf[Index] == 0) &&			// SSL-V3/TLS Type
       (InpBuf[Index+1] == 0))			// not private
    {
      pDstBuf[DstIndex++] = InpBuf[Index+1];	// copy MSB (is zero)
      pDstBuf[DstIndex++] = InpBuf[Index+2];	// copy LSB
    }
    Index += 3;
    Count--;
  }while(Count != 0);
  //-------------------------------------------------------------
  // 5. Set Compression Methods length 1 Byte, type NONE
  //-------------------------------------------------------------
  pDstBuf[DstIndex++] = COMPR_METHODS_ENTRY_SIZE;// Compression Methods length
  pDstBuf[DstIndex++] = COMPR_NULL;		// no compression
  //--------------------------------------------------------------
  // 6. Complete Message Header with Message length, Record Header
  //    with Record length
  //--------------------------------------------------------------
  DstDataLen = DstIndex;
  DstIndex -= RECORD_HDR_SIZE;			// Header excluded !
  BIGword2charn(DstIndex,pDstBuf,RH_LENGTH);	// +3/+4: length, exclusive
  DstIndex -= HT_RECORD_HDR_SIZE;		// Msg. Header Excluded
  BIGword2charn(DstIndex,pDstBuf,RECORD_HDR_SIZE+2); // +7/+8: MsgLen, excl.
  //--------------------------------------------------------------
  // Hash ORIGINAL Data without leading 2 byte record length
  //--------------------------------------------------------------
  HashHandshakeMessage(pConnStruc,InpBuf,InpOffset+2, DataLen-2);
  //--------------------------------------------------------------
  // Process the data through standard client hello
  //--------------------------------------------------------------
  Retcode = ProcessClientHello(pConnStruc,pDstBuf,RECORD_HDR_SIZE,
			       DstDataLen - RECORD_HDR_SIZE,
			       pAlertType,pAlertLvl);
  FREE_ARRAY_POOL(HMEM_CTX_REF,pDstBuf);
  return(Retcode);
}

/**
* Generates server hello request
* message and enqueues it for send to the priority queue (GenerateServerHelloReq).
*
*  @param pConnStruc Connection structure
*  @return HSSL_OP_OK on success, else error occured
*/
static  int  GenerateServerHelloReq(CONNSTRU * pConnStruc)
{
  int BufLen;
  int DstIndex = 0;

  char* pDstBuf;

  TX_QEL * pTxQel;

  HMEM_CTX_DEF1;
  LOAD_HMEM_CTX_PTR(CONN_pMemCtx(pConnStruc));

  //----------------------------------------------------
  // Allocate TX-Quel with required buffer
  //----------------------------------------------------
  BufLen = HT_RECORD_HDR_SIZE;
  pTxQel = AllocInitTxQel(HMEM_CTX_REF1
			  BufLen,(unsigned char) TX_TYPE_HANDSHAKE_MSG);
  if(pTxQel == NULL)
    return(HSSL_TX_QEL_ALLOC_ERR);
  pDstBuf = pTxQel->pBuf;		// get buffer base
  //----------------------------------------------------
  // set ServerHelloRequest Message and length
  //----------------------------------------------------
  pDstBuf[DstIndex++] = HT_HELLO_REQUEST;
  pDstBuf[DstIndex++] = 0;			// is less 2^16
  pDstBuf[DstIndex++] = 0;			// and even less 2^8
  pDstBuf[DstIndex]   = 0;			// store LSB
  //----------------------------------------------------
  // Enqueue TX-Quel for send
  //----------------------------------------------------
  pTxQel->DataLen = BufLen;
  EnqueueTxQel(pConnStruc,pTxQel);
  //----------------------------------------------------
  // Set Renegotiate timeout if renegotiate mode active
  //----------------------------------------------------
  if(pConnStruc->RenegotiateMode != 0)	// ARE doing renegotiation
    SetRenegotiateTimer(pConnStruc, 1);
  return(HSSL_OP_OK);
}

/**
* Checks server hello request
* for correct type and length, and checks if to ignore
* or to start renegotiation initiated by server (if allowed) (ProcessServerHelloReq).
*
*  @param pConnStruc Connection structure
*  @param InpBuf Buffer Base
*  @param InpOffset Start of data
*  @param DataLen data count
*  @param pAlertType type of Alert on Error
*  @param pAlertLvl level of Alert on Error
*
*  @return HSSL_OP_OK on success else error
*/
static  int  ProcessServerHelloReq(CONNSTRU * pConnStruc,
		char* InpBuf, int InpOffset, int DataLen,
		int* pAlertType, int* pAlertLvl)

{
  int InpIndex = InpOffset+1;
  //-------------------------------------------------------
  // Preset Alert Type and Level to Internal Error/Fatal
  //-------------------------------------------------------
  pAlertType[0] = AD_ILLEGAL_PARAMETER;
  pAlertLvl[0]  = ALERT_LEVEL_FATAL;
  //----------------------------------------------------
  // Get/check Message length
  //----------------------------------------------------
  if((InpBuf[InpIndex]   != 0) ||		// Length must be zero
     (InpBuf[InpIndex+1] != 0) ||
     (InpBuf[InpIndex+2] != 0) ||
     (DataLen != HT_RECORD_HDR_SIZE))
    return(HSSL_SRVR_HELREQ_INVALID_MSGLEN);	// too much data
  //-------------------------------------------------------
  // Check if a connection has already been established and
  // no renegotiation is currently beeing processed
  //--------------------------------------------------------
  if((pConnStruc->ConnectionState != CONN_STATE_CONNECTED) || // connecting..
     (pConnStruc->RenegotiateMode != 0) ||	// already started
     (0 == pConnStruc->SecureRenegotiateFlag))  // Renegotiation insecure
    return(HSSL_OP_OK);				// just ignore message
  //--------------------------------------------------------
  // Server initiated Renegotiation COULD be started,
  // check if remote start allowed by configuration
  //--------------------------------------------------------
#if defined NO_CLIENT_RENEGOTIATION
  if((pConnStruc->ExtendedConfigFlags & REMOTE_RENEGOTIATE_BIT_MASK) == 0)
  {
    pAlertType[0] = AD_NO_RENEGOTIATION;
    pAlertLvl[0]  = ALERT_LEVEL_WARNING;
    return(HSSL_SRVR_HELREQ_NO_RENEGOTIATE);
  }
#endif // 0
  //--------------------------------------------------------
  // Connection exists, remote start allowed, initialize
  // renegotiation now
  // 1. Timers will be set in GenerateClientHello...,
  //       2. Renegotiate requires FULL handshake, not short !
  //--------------------------------------------------------
  pConnStruc->RenegotiateMode = SSL_RENEGOTIATE_ACTIVE;
//  CONN_HandshakeMode(pConnStruc)   = SSL_SHORT_HANDSHAKE_MODE;
  pConnStruc->HandshakeMode = SSL_NORMAL_HANDSHAKE_MODE;
  pConnStruc->ActualRenegotiateTimer = 0;
  return(HSSL_OP_OK);
}


static void m_generate_server_extensions(CONNSTRU* adsp_conn,
                                         char* achp_dest,
                                         int& inp_dest_index,
                                         int inp_ext_len)
{
    if(inp_ext_len == 0) {
        return;
    }
    inp_ext_len -= 2;		    // exclusive the length!!
    achp_dest[inp_dest_index++] = (unsigned char) (inp_ext_len >> 8);
    achp_dest[inp_dest_index++] = (unsigned char) inp_ext_len;

    if(adsp_conn->SecureRenegotiateFlag != 0){
        int inl_mode = 0;
        if(adsp_conn->ConnectionState == CONN_STATE_CONNECTED) {
            // Renegotiating!!
            inl_mode = 2;
        }
        int inl_ret = GenerateRenegotExtension(adsp_conn,inl_mode,achp_dest,inp_dest_index);
        inp_dest_index += inl_ret;
    }

    if(adsp_conn->achc_selected_alpn != NULL) {
        // ALPN reply
        int inl_len = adsp_conn->achc_selected_alpn[0];
        inl_len++;
        
        BIGword2char(TLS_ALPN_EXT_TYPE, achp_dest, inp_dest_index);
        BIGword2char((inl_len+2), achp_dest, inp_dest_index);
        BIGword2char(inl_len, achp_dest, inp_dest_index);
        memcpy(achp_dest+inp_dest_index, adsp_conn->achc_selected_alpn, inl_len);

        inp_dest_index += inl_len;
    }
}

/**
* Generates server hello message
* from the connection structure parameters (GenerateServerHello). 
* Updates the Handshake
* Message hashes and enqueues the message for send to the priority queue.
*
*  @param pConnStruc Connection structure
*  @return HSSL_OP_OK on success, else error occured
*/
static  int  GenerateServerHello(CONNSTRU * pConnStruc)
{
  int Retcode,CipherSpec;
  int ExtensionLen;
  int SessionIDLen, BufLen, TotalLen;
  int DstIndex = 0;

  int ltime;

  char* pDstBuf;

  TX_QEL * pTxQel;

  HMEM_CTX_DEF1;

  LOAD_HMEM_CTX_PTR(CONN_pMemCtx(pConnStruc));
  //----------------------------------------------------
  // Calculate Required Length
  //----------------------------------------------------

  SessionIDLen = (int) pConnStruc->SessionID[0] & 0xFF;

  //-----------------------------------------------
  // Get required extension length
  //-----------------------------------------------
  ExtensionLen = 0;
  if(pConnStruc->SecureRenegotiateFlag != 0)
  {
    ExtensionLen = 2 + 4 + 1;			// Assume empty extension
    if(pConnStruc->ConnectionState == CONN_STATE_CONNECTED) // Renegotiating!!
    {
      ExtensionLen = 2* ((int) pConnStruc->HandshakeClntFinished[0] & 0xFF)+
                     1 + 4 + 2;
    }                     
  }

  ExtensionLen += m_get_alpn_len(pConnStruc);

  BufLen = HT_MESSAGE_SIZE + HT_LENGTH_SIZE +
	     VERSION_SIZE + SERVER_HELLO_RANDOM_LEN +
	     SESSION_ID_LEN_SIZE + SessionIDLen +
             CIPHER_SUITE_ENTRY_SIZE +
	     COMPR_METHODS_ENTRY_SIZE +
	     ExtensionLen;
  TotalLen = BufLen - HT_RECORD_HDR_SIZE;
  //----------------------------------------------------
  // Allocate TX-Quel with required buffer
  //----------------------------------------------------
  pTxQel = AllocInitTxQel(HMEM_CTX_REF1
			  BufLen,(unsigned char) TX_TYPE_HANDSHAKE_MSG);
  if(pTxQel == NULL)
    return(HSSL_TX_QEL_ALLOC_ERR);
  pDstBuf = pTxQel->pBuf;		// get buffer base
  //----------------------------------------------------
  // set ServerHello Message and length
  //----------------------------------------------------
  pDstBuf[DstIndex++] = HT_SERVER_HELLO;
  pDstBuf[DstIndex++] = 0;			// is less 2^16
  pDstBuf[DstIndex++] = 0;			// and even less 2^8
  pDstBuf[DstIndex++] = (char) TotalLen;	// store LSB
  //----------------------------------------------------
  // set Server Version
  //----------------------------------------------------
  pDstBuf[DstIndex++] = TLS_SSL_MAJOR_VERSION;	// SSL/TLS
  switch(pConnStruc->ActualProtocol){
    case TLS_V2_PROT_TYPE:
        pDstBuf[DstIndex++] = TLS12_MINOR_VERSION;	// TLS V1.2
        break;
    case TLS_V1_PROT_TYPE:
        pDstBuf[DstIndex++] = TLS11_MINOR_VERSION;	// TLS V1.1
        break;
    case TLS_PROT_TYPE:
        pDstBuf[DstIndex++] = TLS10_MINOR_VERSION;	// TLS V1.0
        break;
    default:
        pDstBuf[DstIndex++] = SSL_MINOR_VERSION;  	// SSL
  }
  //----------------------------------------------------
  // get system UNIX time, convert from long to bytes
  //----------------------------------------------------
//  ltime = GET_SYSTEM_TIME_UTC(RANDinst);	// get the time
  ltime = SecGetSystemTimeUTC();	// get the time
  BIGlong2charn(ltime,pDstBuf,DstIndex);	// convert store
  //----------------------------------------------------
  // get 28 Random bytes
  //----------------------------------------------------
  Retcode = SecDrbgRandBytes(HMEM_CTX_REF1 pDstBuf,DstIndex+4,HELLO_RANDOM_LEN);
  if(Retcode != 0)
  {
    FREE_ARRAY_POOL(HMEM_CTX_REF,pDstBuf);
    FREE_ARRAY(HMEM_CTX_REF,pTxQel);
    return(Retcode);
  }

  //----------------------------------------------------
  // save the UTC-Time + Random as Server Random
  //----------------------------------------------------
  memcpy(pConnStruc->ServerRandom+0,pDstBuf+DstIndex,SERVER_HELLO_RANDOM_LEN);
  DstIndex += SERVER_HELLO_RANDOM_LEN;			// past random
  //----------------------------------------------------
  // copy the session ID length and ID if present
  //----------------------------------------------------
  pDstBuf[DstIndex++] = (char) SessionIDLen;	// set length
  if(SessionIDLen != 0)
  {
    memcpy(pDstBuf+DstIndex,pConnStruc->SessionID+1,SessionIDLen);
    DstIndex += SessionIDLen;
  }
  //----------------------------------------------------
  // copy the given Cipher Suite (without length !)
  //----------------------------------------------------
  CipherSpec = pConnStruc->ActualCipherSuite;
  BIGword2char(CipherSpec,pDstBuf,DstIndex);
  //----------------------------------------------------
  // copy the given Compression Mode (without length !)
  //----------------------------------------------------
  pDstBuf[DstIndex++]  = pConnStruc->ActualComprMethod;

  //----------------------------------------------------
  // Generate secure renegotiation extension if required
  //----------------------------------------------------

  m_generate_server_extensions(pConnStruc, pDstBuf, DstIndex, ExtensionLen);

  //----------------------------------------------------
  // Update Handshake Hashes
  //----------------------------------------------------

  HashHandshakeMessage(pConnStruc,pDstBuf,0, BufLen);
  //----------------------------------------------------
  // Enqueue TX-Quel for send
  //----------------------------------------------------
  pTxQel->DataLen = BufLen;
  EnqueueTxQel(pConnStruc,pTxQel);
  //----------------------------------------------------------------
  // Generate new security parameters from master secret, if
  // Short handshake mode is active (resume/clone or renegotiate)
  //----------------------------------------------------------------
  if(pConnStruc->HandshakeMode == SSL_SHORT_HANDSHAKE_MODE)  // SHORT handshake !!!
  {
    ConvertMasterSecret(pConnStruc);	// process Client/Server RNDs
    pConnStruc->PendRX_ValidFlag = PENDING_STATES_INIT;
    pConnStruc->PendTX_ValidFlag = PENDING_STATES_INIT;
  }
  return(HSSL_OP_OK);
}

/**
* Checks server hello message
* for correct length and parameters, stores the parameters to
* the specified/appropriate Connection state (ProcessServerHello).
*
*  @param pConnStruc Connection structure
*  @param InpBuf Buffer Base
*  @param InpOffset Start of data
*  @param DataLen generated data count
*  @param pAlertType type of Alert on Error
*  @param pAlertLvl level of Alert on Error
*
*  @return HSSL_OP_OK on success, else error occured
*/
static int  ProcessServerHello(CONNSTRU * pConnStruc,
		   char* InpBuf, int InpOffset, int DataLen,
		   int* pAlertType, int* pAlertLvl)
{
  int i;

  int Retcode;
  int MsgLen,SessionIDLen,SessionIDIndex,OwnSessionIDLen,SameSessionID;
  int CipherSuite,ComprMethod,ServerProt,LclProt;

  int InpIndex = InpOffset;

#ifdef XH_INTERFACE
  int CacheMode;
  HCLNT_CACHE_ELEM CacheTemplate;
  HMEM_CTX_DEF1;
  LOAD_HMEM_CTX_PTR(CONN_pMemCtx(pConnStruc));
#endif

  //-------------------------------------------------------
  // Preset Alert Type and Level to Illegal parameter/Fatal
  //-------------------------------------------------------
  pAlertType[0] = AD_ILLEGAL_PARAMETER;
  pAlertLvl[0]  = ALERT_LEVEL_FATAL;
  //----------------------------------------------------
  // Get/check Message length
  //----------------------------------------------------
  BIGchar2longn(InpBuf,MsgLen,InpIndex);		// from 1st 4 bytes
  MsgLen &= 0xFFFFFF;				// only 3 bytes valid
  InpIndex += HT_LENGTH_SIZE;			// skip size
  DataLen  -= HT_RECORD_HDR_SIZE;		// reduce length
  InpIndex++;

  if((MsgLen != DataLen) ||
     (MsgLen < (VERSION_SIZE + UTC_TIME_LEN +  //ckeck min. length
		        HELLO_RANDOM_LEN +
                SESSION_ID_LEN_SIZE +
                CIPHER_SUITE_ENTRY_SIZE +
                COMPR_METHODS_ENTRY_SIZE)))
    return(HSSL_SRVR_HELLO_INVALID_MSGLEN);	// inconsistent data size
  //-----------------------------------------------------
  // Process Server Version (SSL 3.0 / TLS 1.0 / TLS 1.1 /TLS 1.2)
  //-----------------------------------------------------
  if(InpBuf[InpIndex++] != TLS_SSL_MAJOR_VERSION)
    return(HSSL_SRVR_HELLO_UNSUPP_VERSION);

  ServerProt = InpBuf[InpIndex++];		// get minor version

  if((ServerProt != TLS12_MINOR_VERSION) &&
     (ServerProt != TLS11_MINOR_VERSION) &&
     (ServerProt != TLS10_MINOR_VERSION) &&
     (ServerProt != SSL_MINOR_VERSION))
    return(HSSL_SRVR_HELLO_UNSUPP_VERSION);
  //----------------------------------------------------
  // Copy Server Random to Structure
  //----------------------------------------------------
  memcpy(pConnStruc->ServerRandom+0,InpBuf+InpIndex,SERVER_HELLO_RANDOM_LEN);
  InpIndex += SERVER_HELLO_RANDOM_LEN;
  //----------------------------------------------------
  // Calculate remaining data length
  //----------------------------------------------------
  DataLen -= (VERSION_SIZE + UTC_TIME_LEN + HELLO_RANDOM_LEN);
  //---------------------------------------------------------
  // Check Session ID length if valid and enough data present
  //---------------------------------------------------------
  SessionIDLen = (int) InpBuf[InpIndex] & 0xFF; // get length
  if((SessionIDLen > MAX_SESSION_ID_LEN) ||
     (SessionIDLen > (DataLen -
                      CIPHER_SUITE_ENTRY_SIZE -
                      COMPR_METHODS_ENTRY_SIZE)))
    return(HSSL_SRVR_HELLO_INV_SESSID_LEN);
  SessionIDIndex = InpIndex;
  InpIndex += (SessionIDLen+1);			// skip Session ID
  DataLen  -= (SessionIDLen+1);
  //-----------------------------------------------------------------
  // Get Server selected Cipher suite and Compression Method
  //-----------------------------------------------------------------
  BIGchar2word(InpBuf,CipherSuite,InpIndex);	// get Ciphersuite
  DataLen -= CIPHER_SUITE_ENTRY_SIZE;		// reduce Data count
  ComprMethod = (int) InpBuf[InpIndex++] & 0xFF;// get Compression Method
  DataLen -= COMPR_METHODS_ENTRY_SIZE;		// reduce Data count
  //-----------------------------------------------------
  // Process extensions if still data present
  //-----------------------------------------------------
  if(DataLen != 0)
  {
    Retcode = m_process_tls_extension(HMEM_CTX_REF1 InpBuf,DataLen,InpIndex,
                              pConnStruc,pAlertType,pAlertLvl,ServerProt);
    if(Retcode != HSSL_OP_OK)
      return(Retcode);
  }
  //-------------------------------------------------------
  // Check if same session ID returned as sent (if any)
  //-------------------------------------------------------
  SameSessionID = 0;

  OwnSessionIDLen = (int) pConnStruc->SessionID[0] & 0x0FF;
  if(SessionIDLen == OwnSessionIDLen)
  {
    if((SessionIDLen == 0) ||			// both empty
       (CmpSizedBit8Arrays(InpBuf,SessionIDIndex,pConnStruc->SessionID,0) == 0)) // both identic
      SameSessionID = 1;
  }
  //-------------------------------------------------------
  // Check if session resume/clone tried
  //-------------------------------------------------------
//if(CONN_RenegotiateMode(pConnStruc) == 0)	// doing initial renegotiate
//{
    if(pConnStruc->HandshakeMode != 0)	// Short tried
    {
      //------------------------------------------------------
      // Session resume/clone tried, but rejected, reset modes
      //------------------------------------------------------
      if((SessionIDLen == 0) || (SameSessionID == 0))	// was NOT accepted!!
      {
        pConnStruc->ActualProtocol = UNKNOWN_PROT_TYPE;	// not defined
        pConnStruc->ActualCipherSuite	=  -1;	// none	
        pConnStruc->ActualComprMethod	= (char) -1;	// none
        pConnStruc->CertifiedFlags	= 0;		// none authenticated
      }
    }
//}

  //------------------------------------------------------------
  // Check SessionID if renegotiation mode is active
  //------------------------------------------------------------
   
  //-------------------------------------------------------
  // Check if protocol is already defined, if so just check
  //-------------------------------------------------------
  LclProt = pConnStruc->ActualProtocol;		// get local selected type

  if(pConnStruc->RenegotiateMode != 0)	// doing renegotiate params!!
  {
    //--------------------------------------------------------
    // Security Parameters Renegotiation, must be same Version
    //--------------------------------------------------------
        if(!(((ServerProt == TLS12_MINOR_VERSION) && // server sent TLS1.2
         (LclProt == TLS_V2_PROT_TYPE)) ||	// was negotiated, o.k.
         ((ServerProt == TLS11_MINOR_VERSION) && // server sent TLS1.1
         (LclProt == TLS_V1_PROT_TYPE)) ||	// was negotiated, o.k.
        ((ServerProt == TLS10_MINOR_VERSION) &&	// server sent TLS1.0
         (LclProt == TLS_PROT_TYPE)) ||		// was negotiated, o.k.
        ((ServerProt == SSL_MINOR_VERSION) &&	// server sent SSL3
         (LclProt == SSL_PROT_TYPE))))		// was negotiated, o.k.
    {
      return(HSSL_SRVR_HELLO_DIFFERENT_VERS);	// none of allowed combinations
    }
  }
  else						// initial negotiate parameters
  {
    //--------------------------------------------------------
    // Initial Renegotiation, select highest possible protocol
    //--------------------------------------------------------
    switch(ServerProt){
        case TLS12_MINOR_VERSION:
          if(((LclProt != UNKNOWN_PROT_TYPE)&&(LclProt != TLS_V2_PROT_TYPE))||
                ((LclProt == UNKNOWN_PROT_TYPE) &&
                ((pConnStruc->SupportedProtocolsFlags & TLS_V2_BIT_MASK) == 0)))
                return(HSSL_SRVR_HELLO_UNSUPP_VERSION);
            pConnStruc->ActualProtocol = TLS_V2_PROT_TYPE;	// save protocol
            break;
        case TLS11_MINOR_VERSION:
          if(((LclProt != UNKNOWN_PROT_TYPE)&&(LclProt != TLS_V1_PROT_TYPE))||
                ((LclProt == UNKNOWN_PROT_TYPE) &&
                ((pConnStruc->SupportedProtocolsFlags & TLS_V1_BIT_MASK) == 0)))
                return(HSSL_SRVR_HELLO_UNSUPP_VERSION);
            pConnStruc->ActualProtocol = TLS_V1_PROT_TYPE;	// save protocol
            break;
        case TLS10_MINOR_VERSION:
          if(((LclProt != UNKNOWN_PROT_TYPE)&&(LclProt != TLS_PROT_TYPE))||
                ((LclProt == UNKNOWN_PROT_TYPE) &&
                ((pConnStruc->SupportedProtocolsFlags & TLS_BIT_MASK) == 0)))
                return(HSSL_SRVR_HELLO_UNSUPP_VERSION);
            pConnStruc->ActualProtocol = TLS_PROT_TYPE;	// save protocol
            break;
        default:
          if(((LclProt != UNKNOWN_PROT_TYPE)&&(LclProt != SSL_PROT_TYPE))||
                ((LclProt == UNKNOWN_PROT_TYPE) &&
                ((pConnStruc->SupportedProtocolsFlags & SSL_BIT_MASK) == 0)))
                return(HSSL_SRVR_HELLO_UNSUPP_VERSION);
            pConnStruc->ActualProtocol = SSL_PROT_TYPE;	// save protocol
      }
  }
  //---------------------------------------------------------
  // Check session ID from Server in Caching mode 
  //---------------------------------------------------------
  if(pConnStruc->RenegotiateMode == 0)	// doing first negotiate
  {
    //----------------------------------------------------------------
    // Initial Renegotiation, check if client sent session ID returned
    // This is only needed, when client side caching is ACTIVE !!!
    //----------------------------------------------------------------
#if defined XH_INTERFACE
    if((pConnStruc->ExtendedConfigFlags & SESS_CACHE_BIT_MASK) != 0)
    {
      //--------------------------------------------------------------
      // Client side caching is enabled, check if we sent a session ID
      // and if so, if returned ID is same as sent
      //--------------------------------------------------------------
      if(pConnStruc->HandshakeMode != 0)	// trying to clone/resume
      {
        memset(&CacheTemplate,0,sizeof(HCLNT_CACHE_ELEM));
        
        memcpy(&CacheTemplate.ConnectionID,pConnStruc->ConnectionID,
	       MAX_CONNECTION_ID_LEN+1);

        memcpy(&CacheTemplate.SessionID,pConnStruc->SessionID,
	       MAX_SESSION_ID_LEN+1);

        CacheMode = ClientCacheSessionModify(CONN_pMemCtx(pConnStruc),
				&CacheTemplate,
				InpBuf+SessionIDIndex,
				pConnStruc->CacheMode);
        // preset 'error' case
        pConnStruc->CacheMode     = CACHE_SESSION_TYPE_NON_CACHE;
        pConnStruc->HandshakeMode = SSL_NORMAL_HANDSHAKE_MODE;

        if(CacheMode >= 0)
        {
          pConnStruc->CacheMode = (char) CacheMode;
          if(CacheMode > CACHE_SESSION_TYPE_NEW)	// still resumed/cloned
            pConnStruc->HandshakeMode = SSL_SHORT_HANDSHAKE_MODE;
        }
      }
    }
#endif // XH_INTERFACE

    //----------------------------------------------------------------
    // Store Session ID received from Server if not empty
    //----------------------------------------------------------------
    if(SessionIDLen == 0)			// empty session ID received
      pConnStruc->SessionID[0] = 0;		// clear ID (set length 0)
    else					// non empty session ID recv.
      memcpy(pConnStruc->SessionID+0,InpBuf+SessionIDIndex,SessionIDLen+1);		// save new ID
  }
  //-----------------------------------------------------------------
  // Check cipher suite selected by server
  //-----------------------------------------------------------------
  if(pConnStruc->HandshakeMode != 0)	// resume/clone
  {
    //-----------------------------------------------------------------
    // Resume/clone, must be same Cipher suite; when resumed/cloned,
    // must initialize cipher params
    //-----------------------------------------------------------------
    if(CipherSuite != pConnStruc->ActualCipherSuite)
      return(HSSL_SRVR_HELLO_DIFF_CIPHSUITE);

//  if(CONN_RenegotiateMode(pConnStruc) == 0)	// is resume/clone!!
//  {
      i = SetCipherSuiteParams(pConnStruc,CipherSuite);	// check/set
      if(i != HSSL_OP_OK)
        return(HSSL_SRVR_HELLO_UNSUP_CIPHSUITE);
//  }
  }
  else
  {
    //----------------------------------------------------------------
    // Initial Renegotiation, check if returned Ciphersuite acceptable
    //----------------------------------------------------------------
    if(pConnStruc->ActualCipherSuite != -1)	// definite suite selected
    {
      if(CipherSuite != pConnStruc->ActualCipherSuite)
        return(HSSL_SRVR_HELLO_DIFF_CIPHSUITE);
    }
    else					// must search through list
    {    
      if(SearchSizedList(pConnStruc->pCfgStruc->CipherSuitesList,0,1,(int) CipherSuite) == 0)
        return(HSSL_SRVR_HELLO_DIFF_CIPHSUITE);
      pConnStruc->ActualCipherSuite = CipherSuite;
      i = SetCipherSuiteParams(pConnStruc,CipherSuite);	// check/set
      if(i != HSSL_OP_OK)
        return(HSSL_SRVR_HELLO_UNSUP_CIPHSUITE);
    }
  }
  //-----------------------------------------------------------------
  // Check compression method selected by Server
  //-----------------------------------------------------------------
  if(pConnStruc->HandshakeMode != 0)	// resume/clone
  {
    //-------------------------------------------------------------------
    // resume/clone, must be same Compression Method;
    // when resumed/cloned must initialize parameters
    //-------------------------------------------------------------------
    if(ComprMethod != ((int) pConnStruc->ActualComprMethod & 0x0FF))
      return(HSSL_SRVR_HELLO_DIFF_CMPRMETHOD);

//  if(CONN_RenegotiateMode(pConnStruc) == 0)	// is resume/clone!!
//  {
      i = SetComprMethodsParams(pConnStruc, ComprMethod);
      if(i != HSSL_OP_OK)
      {
        pAlertType[0] = AD_INTERNAL_ERROR;
        return(HSSL_SRVR_HELLO_UNDEF_CMPRMETH);	// error occured
      }
//  }
  }
  else						// initial negotiation
  {
    //-----------------------------------------------------------------------
    // Initial negotiation, check if returned compression method acceptable
    // if server sent Method NULL this must also be accepted (override)
    //-----------------------------------------------------------------------
    if(ComprMethod != COMPR_NULL)			// non null method
    {
      if( pConnStruc->ActualComprMethod != (char) -1) // definite method selected
      {
        if(ComprMethod != pConnStruc->ActualComprMethod)
          return(HSSL_SRVR_HELLO_DIFF_CMPRMETHOD);
        //----------------------------------------------------
        // initialize Compression here ??? (do that later)
        //----------------------------------------------------
        if(ComprMethod != COMPR_NULL)
        {

        }
      }
      else					// must search through list
      {    
        if(SearchSizedList(pConnStruc->pCfgStruc->CmprMethodsList,0,0,(int) ComprMethod) == 0)
          return(HSSL_SRVR_HELLO_DIFF_CMPRMETHOD);
        pConnStruc->ActualComprMethod = (char) ComprMethod;
        i = SetComprMethodsParams(pConnStruc, ComprMethod);
        if(i != HSSL_OP_OK)
        {
          pAlertType[0] = AD_INTERNAL_ERROR;
          return(HSSL_SRVR_HELLO_UNDEF_CMPRMETH);	// error occured
        }
        //----------------------------------------------------
        // initialize Compression here (do that later)
        //----------------------------------------------------
        if(ComprMethod != COMPR_NULL)
        {

        }
      }
    } // not NULL
    else					// server selected method NULL
    {
      pConnStruc->ActualComprMethod = (char) ComprMethod;
      i = SetComprMethodsParams(pConnStruc, ComprMethod);
      if(i != HSSL_OP_OK)
      {
        pAlertType[0] = AD_INTERNAL_ERROR;
        return(HSSL_SRVR_HELLO_UNDEF_CMPRMETH);	// error occured
      }
    }
  }
  //----------------------------------------------------
  // Setup the pending cipher states
  //----------------------------------------------------
  pConnStruc->PendRX_ComprAlgor = pConnStruc->ActualComprMethod;
  pConnStruc->PendTX_ComprAlgor = pConnStruc->ActualComprMethod;

  pConnStruc->PendRX_EncAlgor = pConnStruc->CipherAlgor;
  pConnStruc->PendTX_EncAlgor = pConnStruc->CipherAlgor;

  pConnStruc->PendRX_MACAlgor = pConnStruc->MacAlgorType;
  pConnStruc->PendTX_MACAlgor = pConnStruc->MacAlgorType;
  //----------------------------------------------------------------
  // Generate new security parameters from master secret, if
  // Short handshake mode is active (resume/clone)
  //----------------------------------------------------------------
  if(pConnStruc->HandshakeMode != 0)  // SHORT handshake !!!
  {
    ConvertMasterSecret(pConnStruc);		// process Client/Server RNDs
    pConnStruc->PendRX_ValidFlag = PENDING_STATES_INIT;
    pConnStruc->PendTX_ValidFlag = PENDING_STATES_INIT;
  }
  return(HSSL_OP_OK);
}

/**
* Generates server hello done
* message, updates the Handshake hashes and enqueues the message
* for send to the priority queue (GenerateServerHelloDone).
*
*  @param pConnStruc Connection structure
*  @return HSSL_OP_OK on success, else error occured
*/
static  int  GenerateServerHelloDone(CONNSTRU * pConnStruc)
{
  int BufLen;
  int DstIndex = 0;

  char* pDstBuf;

  TX_QEL * pTxQel;

  HMEM_CTX_DEF1;
  LOAD_HMEM_CTX_PTR(CONN_pMemCtx(pConnStruc));

  //-------------------------------------------------------
  // Calculate Required Length, allocate TX-Qel with buffer
  //-------------------------------------------------------
  BufLen = HT_MESSAGE_SIZE + HT_LENGTH_SIZE;

  pTxQel = AllocInitTxQel(HMEM_CTX_REF1
			  BufLen,(unsigned char) TX_TYPE_HANDSHAKE_MSG);
  if(pTxQel == NULL)
    return(HSSL_TX_QEL_ALLOC_ERR);
  pDstBuf = pTxQel->pBuf;		// get buffer base
  //----------------------------------------------------
  // set Server Hello Done Message and length
  //----------------------------------------------------
  pDstBuf[DstIndex++] = HT_SERVER_HELLO_DONE;
  pDstBuf[DstIndex++] = 0;			// is less 2^16
  pDstBuf[DstIndex++] = 0;			// and even less 2^8
  pDstBuf[DstIndex++] = 0;			// store LSB only
  //----------------------------------------------------
  // Update Handshake Hashes
  //----------------------------------------------------
  HashHandshakeMessage(pConnStruc,pDstBuf,0, BufLen);
  //----------------------------------------------------
  // Enqueue TX-Quel for send
  //----------------------------------------------------
  pTxQel->DataLen = BufLen;
  EnqueueTxQel(pConnStruc,pTxQel);
  return(HSSL_OP_OK);
}

/**
* Checks server hello done message
* for correct length (ProcessServerHelloDone).
*
*  @param pConnStruc Connection structure
*  @param InpBuf Buffer Base
*  @param InpOffset Start of data
*  @param DataLen generated data count
*  @param pAlertType type of Alert on Error
*  @param pAlertLvl level of Alert on Error
*
*  @return HSSL_OP_OK on success, else error occured
*/
static  int  ProcessServerHelloDone(CONNSTRU * pConnStruc,
		   char* InpBuf, int InpOffset, int DataLen,
		   int* pAlertType, int* pAlertLvl)
{
  int MsgLen;

  int InpIndex = InpOffset;

  //-------------------------------------------------------
  // Preset Alert Type and Level to Illegal parameter/Fatal
  //-------------------------------------------------------
  pAlertType[0] = AD_ILLEGAL_PARAMETER;
  pAlertLvl[0]  = ALERT_LEVEL_FATAL;
  //----------------------------------------------------
  // Get/check Message length
  //----------------------------------------------------
  BIGchar2longn(InpBuf,MsgLen,InpIndex);	// get length
  MsgLen &= 0xFFFFFF;				// only 3 bytes valid
  DataLen  -= HT_RECORD_HDR_SIZE;		// reduce length

  if((MsgLen != 0) || (DataLen != 0))
    return(HSSL_SRVR_HLDONE_INVALID_MSGLEN);	// inconsistent data size
  //----------------------------------------------------
  // Check if RSA Key Exchange with Server Certificate
  //----------------------------------------------------
  if((pConnStruc->KeyExchgMode == KEY_EXCHANGE_RSA) &&
     ((pConnStruc->CertifiedFlags & SERVER_KEY_EXCHG_REQ_MASK) == 0) &&
      (pConnStruc->IsExportable == IS_EXPORTABLE) &&	// US-Exportable
      (RSA_BitSize(pConnStruc->pRemoteRsaStruc) > RSA_EXPORT_MAX_BITS))
  {
    pAlertType[0] = AD_EXP_RESTRICTION;
    return(HSSL_SRVR_HLDONE_EXPT_RESTRICT);
  }
  return(HSSL_OP_OK);
}

/**
* Generates server/client certificate
* message from the connection structure parameters, updates Handshake
* Messages and enqueues Message for send to the priority queue (GenerateCertificate).
*
*  @param pConnStruc Connection structure
*  @return HSSL_OP_OK on success, else error occured
*/
static int  GenerateCertificate(CONNSTRU * pConnStruc)
{
  int Retcode;

  int Entity;
  int ProtocolType;
  int KeyExchgMode;
  int PublicAlgor;

  int Index = 0;
  int CertIndex = 0;
  int CertType;
  int NoCertFlag= 0;
#if (defined _WIN32) && defined PKCS11
  int CertsCount;
#endif

  TX_QEL * pTxQel;

  char* pBuf = NULL;

  int* pCNArray;

  char* pTmpBuf[1];
  int pTmpLong[1];
  int pTmpCNIndex[1];

  IDATPARR* pTmpCertsDesc[1];

  X509CERT * pCert;
  X509CERT ** pCertList;
  CTREESTR * pCertTreeStruc;

  RSA_STRUC* pTmpRsaStruc[1] = {NULL};
  DSA_STRUC* pTmpDsaStruc[1] = {NULL};
  DH_STRUC* pTmpDhStruc[1]   = {NULL};

  HMEM_CTX_DEF1;
  LOAD_HMEM_CTX_PTR(CONN_pMemCtx(pConnStruc));

  //----------------------------------------------------
  pTmpCertsDesc[0] = NULL;		// avoid freeing unused buffer !!!
  Entity       =  pConnStruc->Entity;
  ProtocolType = pConnStruc->ActualProtocol;
  //----------------------------------------------------
  // Allocate TX-Qel without buffer
  //----------------------------------------------------
  pTxQel = AllocInitTxQel(HMEM_CTX_REF1
			  0,(unsigned char) TX_TYPE_HANDSHAKE_MSG);
  if(pTxQel == NULL)
    return(HSSL_TX_QEL_ALLOC_ERR);
  KeyExchgMode = pConnStruc->KeyExchgMode;
  //----------------------------------------------------
  // Check if Server or Client Entity
  //----------------------------------------------------
  if(Entity == SERVER_ENTITY)			// simple case
  {
    //----------------------------------------------------------------
    // get from key exchange type the public algor
    //----------------------------------------------------------------
    switch(KeyExchgMode)
    {
      case KEY_EXCHANGE_RSA:
        PublicAlgor = RSA_PUBLIC_ALGOR;
        break;

      case KEY_EXCHANGE_DH_DSS:
      case KEY_EXCHANGE_DH_RSA:
        PublicAlgor = DH_PUBLIC_ALGOR;
        break;

      case KEY_EXCHANGE_DHE_DSS:
        PublicAlgor = DSA_PUBLIC_ALGOR;
        pConnStruc->CertifiedFlags |= SERVER_KEY_EXCHG_REQ_MASK;
        break;

      case KEY_EXCHANGE_DHE_RSA:
      case KEY_EXCHANGE_ECDHE_RSA:
        PublicAlgor = RSA_PUBLIC_ALGOR;
        pConnStruc->CertifiedFlags |= SERVER_KEY_EXCHG_REQ_MASK;
        break;

      default:
        FREE_ARRAY(HMEM_CTX_REF,pTxQel);
        return(HSSL_GENCERT_INV_KEY_EXCHG_MODE);
    }
    //----------------------------------------------------
    // Build Server certificate chain in internal notation
    // We Verify the Chain for Time Validity now...
    // -----
    //----------------------------------------------------
    Retcode = BuildCertChainFromSigList(HMEM_CTX_REF1 pConnStruc->pCfgStruc->pCertTreeStruc,1,0x1F,PublicAlgor,pConnStruc->abyc_remote_sig_algs,NULL,0,NULL,pTmpCNIndex,pTmpCertsDesc);
    if(Retcode != ASN1_OP_OK)
    {
      FREE_ARRAY(HMEM_CTX_REF,pTxQel);
      return(HSSL_GENCERT_BUILDCERTCHAIN_ERR);
    }
    pConnStruc->LocalCNIndex = pTmpCNIndex[0]; // save index to endcert
    //------------------------------------------------------------
    // Get the local RSA / DSS / DH parameters from the
    // endcert's private values
    //------------------------------------------------------------
    pCertTreeStruc = pConnStruc->pCfgStruc->pCertTreeStruc;
    pCNArray = pCertTreeStruc->CNodeArray;		// get array
    pCertList = pCertTreeStruc->ppCertList;		// get list
    Index = pCNArray[pTmpCNIndex[0] + CN_CERTLIST_INDEX]; // Cert Index
    pCert = pCertList[Index];			// Cert Structure pointer
    switch(PublicAlgor)
    {
      case RSA_PUBLIC_ALGOR:
        Retcode = FromArrayDescToRSAPrivParams(HMEM_CTX_REF1 pCert->PrivKeyData,pTmpRsaStruc);
	pConnStruc->pLocalRsaStruc       = pTmpRsaStruc[0];
        pConnStruc->LocalCertPublicAlgor = m_get_cert_pub_signature_tls(pConnStruc->abyc_remote_sig_algs,RSA_PUBLIC_ALGOR);
        break;

      case DSA_PUBLIC_ALGOR:
        Retcode = FromArrayDescToDSAPrivParams(HMEM_CTX_REF1 pCert->PrivKeyData,pTmpDsaStruc);
	pConnStruc->pLocalDsaStruc       = pTmpDsaStruc[0];
        pConnStruc->LocalCertPublicAlgor = m_get_cert_pub_signature_tls(pConnStruc->abyc_remote_sig_algs,DSA_PUBLIC_ALGOR);
        break;

      case DH_PUBLIC_ALGOR:
        Retcode = FromArrayDescToDHPrivParams(HMEM_CTX_REF1 pCert->PrivKeyData,pTmpDhStruc);
	pConnStruc->pLocalDhStruc       = pTmpDhStruc[0];
        pConnStruc->LocalCertPublicAlgor = m_get_cert_pub_signature_tls(pConnStruc->abyc_remote_sig_algs,DH_PUBLIC_ALGOR);
        break;
    }
    if(Retcode != ASN1_OP_OK)
    {
      FreeIDATPARR_Struc(HMEM_CTX_REF1 pTmpCertsDesc[0]);
      FREE_ARRAY(HMEM_CTX_REF,pTxQel);
      return(HSSL_GENCERT_TO_PRIVPARS_ERROR);
    }
    //------------------------------------------------------------
    // Check exportable restrictions when RSA exchange is selected
    //------------------------------------------------------------
    if((KeyExchgMode == KEY_EXCHANGE_RSA) &&		// RSA exchange
       (pConnStruc->IsExportable == IS_EXPORTABLE))	// US exportable
    {
      if(RSA_BitSize(pTmpRsaStruc[0]) > RSA_EXPORT_MAX_BITS)
        pConnStruc->CertifiedFlags |= SERVER_KEY_EXCHG_REQ_MASK;
    }
    //----------------------------------------------------
    // Convert the internal representation to SSL List
    //----------------------------------------------------
    Retcode = ToSSLCertList(HMEM_CTX_REF1 pTmpCertsDesc[0],HT_RECORD_HDR_SIZE,pTmpBuf,pTmpLong);
    if(Retcode != ASN1_OP_OK)
    {
      FreeIDATPARR_Struc(HMEM_CTX_REF1 pTmpCertsDesc[0]);
      FREE_ARRAY(HMEM_CTX_REF,pTxQel);
      return(HSSL_GENCERT_LISTGEN_FAILED);
    }
    pBuf = pTmpBuf[0];
    BIGlong2charn((pTmpLong[0]-HT_RECORD_HDR_SIZE),pBuf,0);// set size
    pBuf[0] = HT_CERTIFICATE;			// set message type
    pConnStruc->CertifiedFlags |= SERVER_CERTIFIED_MASK; // NEW (for K.B.)
  }
  else						// client entity   
  {
    //-----------------------------------------------------------------
    // Client certificate request, check if we have a certificate Index
    // from the server's Certificate Request Message processing or a
    // PKCS11 certificate
    //-----------------------------------------------------------------
    NoCertFlag = 0;

    Index = pConnStruc->LocalCNIndex;
    pCertTreeStruc = pConnStruc->pCfgStruc->pCertTreeStruc;
    if((Index < 0) || (pCertTreeStruc == NULL))
      NoCertFlag = 1;
    //-----------------------------------------------
    // Check if there is a PKCS11 certificate present
    //-----------------------------------------------
#if (defined _WIN32) && defined PKCS11
    if(pConnStruc->in_p11certid != 0)
      NoCertFlag = 0;
#endif // defined _WIN32

    if(NoCertFlag != 0)
    {
      if(ProtocolType == SSL_PROT_TYPE)		// SSL, alert required
      {
        SendAlert(pConnStruc,AD_NO_CERTIFICATE,ALERT_LEVEL_WARNING);
        FREE_ARRAY(HMEM_CTX_REF,pTxQel);
// CHANGED FOR VPN REASONS demand from Mr. Galea, 19.05.2004 Oed
//      return(HSSL_GENCERT_NO_CLIENT_CERT);
	return(HSSL_OP_OK);
      }
      else
      {
        //--------------------------------------------------------------
        // TLS V1.1/1.0, must send an  e m p t y  Certificate List
        //--------------------------------------------------------------
        pBuf = BIT8_ARRAY_ALLOC(HMEM_CTX_REF,HT_RECORD_HDR_SIZE+3);
        if(pBuf == NULL)
        {
          FREE_ARRAY(HMEM_CTX_REF,pTxQel);
          return(HSSL_GENCERT_MSGBUF_ALLOC_ERR);
        }
        Index = 0;
        pBuf[Index++] = HT_CERTIFICATE;		// set message type
        pBuf[Index++] = 0;			// length = 3 byte (list len)
        pBuf[Index++] = 0;
        pBuf[Index++] = 3;
        pBuf[Index++] = 0;			// list length = 0
        pBuf[Index++] = 0;
        pBuf[Index++] = 0;

        pTmpBuf[0]  = pBuf;
        pTmpLong[0] = HT_RECORD_HDR_SIZE+3;	// set length
      }
    }
    else					// we have a certificate
    {
      //------------------------------------------------------------
      // Certificate present, if Algor is DH, and the Certificate
      // is of the requested Type (!) get the DH values from the
      // own end Certificate.
      //------------------------------------------------------------
      pConnStruc->CertifiedFlags |= CLIENT_CERTIFIED_MASK; // NEW (for K.B.)

    //---------------------------------------------------
    // If PKCS11 certificate present, get list direct
    //---------------------------------------------------
#if (defined _WIN32) && defined PKCS11
    if(pConnStruc->in_p11certid != 0)
    {
      CertsCount = 0;
      Retcode = m_pk11certlistget(HMEM_CTX_REF1 pConnStruc,
			          pTmpCertsDesc,&CertsCount);
      if(Retcode != 0)
      {
        FREE_ARRAY(HMEM_CTX_REF,pTxQel);
        return(Retcode);
      }
    }
    else
    {
#endif // defined _WIN32

      pCNArray = pCertTreeStruc->CNodeArray;	// get array
      CertType = pCNArray[Index + CN_CERT_TYPE];	// get type of Cert.
      pCertList = pCertTreeStruc->ppCertList;	// get list
        CertIndex = pCNArray[Index + CN_CERTLIST_INDEX]; // Cert Index
        pCert = pCertList[CertIndex];		// Cert Structure pointer

      if(((KeyExchgMode == KEY_EXCHANGE_DH_DSS) ||	// DH exchange,
          (KeyExchgMode == KEY_EXCHANGE_DH_RSA)) &&
         ((CertType == CNODE_DH_RSA_CERT) ||		// is a fixed DH...
          (CertType == CNODE_DH_DSS_CERT)))
      {
        Retcode = FromArrayDescToDHPrivParams(HMEM_CTX_REF1 pCert->PrivKeyData,pTmpDhStruc);
        if(Retcode != ASN1_OP_OK)
        {
          FREE_ARRAY(HMEM_CTX_REF,pTxQel);
          return(HSSL_GENCERT_TO_PRIVPARS_ERROR);
        }
	pConnStruc->pLocalDhStruc       = pTmpDhStruc[0];
      }
      if(pConnStruc->ActualProtocol == TLS_V2_PROT_TYPE){
         pConnStruc->LocalCertPublicAlgor = // Get Signature identifier for Certificate Verify
            m_get_cert_pub_signature_tls(pConnStruc->abyc_remote_sig_algs,
                                         pCert->PublicKeyType);
      }
      Retcode = BuildLclCertChain(HMEM_CTX_REF1 pCertTreeStruc,Index,pTmpCertsDesc);
      if(Retcode != ASN1_OP_OK)
      {
        FREE_ARRAY(HMEM_CTX_REF,pTxQel);
        return(HSSL_GENCERT_BUILDLCLCHAIN_ERR);
      }
#if (defined _WIN32) && defined PKCS11
    }
#endif
      //----------------------------------------------------
      // Convert the internal representation to SSL List
      //----------------------------------------------------
      Retcode = ToSSLCertList(HMEM_CTX_REF1 pTmpCertsDesc[0],HT_RECORD_HDR_SIZE,pTmpBuf,pTmpLong);
      if(Retcode != ASN1_OP_OK)
      {
        FreeIDATPARR_Struc(HMEM_CTX_REF1 pTmpCertsDesc[0]);
        FREE_ARRAY(HMEM_CTX_REF,pTxQel);
        return(HSSL_GENCERT_LISTGEN_FAILED);
      }
      pBuf = pTmpBuf[0];
      BIGlong2charn((pTmpLong[0]-HT_RECORD_HDR_SIZE),pBuf,0);	// set size
      pBuf[0] = HT_CERTIFICATE;			// set message type
    }
  }
  pTxQel->pBuf    = pTmpBuf[0];
  pTxQel->DataLen = pTmpLong[0];
  //----------------------------------------------------
  // Update Handshake Hashes
  //----------------------------------------------------
  HashHandshakeMessage(pConnStruc,pTmpBuf[0],0, pTmpLong[0]);
  //----------------------------------------------------
  // Enqueue TX-Quel for send
  //----------------------------------------------------
  EnqueueTxQel(pConnStruc,pTxQel);
  FreeIDATPARR_Struc(HMEM_CTX_REF1 pTmpCertsDesc[0]);
  return(HSSL_OP_OK);
}

/**
* Prepares certificate data
* for display in the user interface, calls the user interface (PrepAskUserCertState).
*
*  @param pCfgStruc Config Structure
*  @param pCertArray Array of certificates
*  @param CertCount Number of certificates in the array
*  @param CertStatus Bits that are relevant for ask
*  @param SavedCertStatus Status from Chain verifier
*
*  @return int Status 0 - not acceptable
* <br>            1 - acceptable
*/
static  int  PrepAskUserCertState(HMEM_CTX_DEF
		CFG_STRU * pCfgStruc,
		X509CERT ** pCertArray, int CertCount,
		int CertStatus, int SavedCertStatus)
{
  int Retcode;
  int ReasonFlags;
  int AskStatus = 0;
  int (*pCallback)(int, void *, int, char*);

  char ShaDigestBuf[SHA_DIGEST_LEN];

  HCERWTXT ** ppTmpWTxtStruc[1];
  //----------------------------------------------------------
  // Prepare data for User interface
  //----------------------------------------------------------
  if((Retcode = PrepCertWTxtsList(HMEM_CTX_REF1 pCertArray,CertCount,ppTmpWTxtStruc,ShaDigestBuf)) != ASN1_OP_OK)
    return(0);
  //----------------------------------------------------------
  // Call the Callback Function
  //----------------------------------------------------------
  Retcode = 0;
  ReasonFlags = (CertStatus & 0x0FF) |
	        ((SavedCertStatus & 0x0FF) << 8);
//  pCallback = CFG_pAskUserCertsCb(pCfgStruc);

#if defined _AIX
#pragma info(none)
#endif
  pCallback =
   (int (*) (int, void*, int, char*)) pCfgStruc->pAskUserCertsCb;

#if defined _AIX
#pragma info(restore)
#endif

  AskStatus = pCallback(ReasonFlags, ppTmpWTxtStruc[0],
		        CertCount, ShaDigestBuf);
  //---------------------------------------------------
  // Check what to return
  //---------------------------------------------------
  Free_HCERWTXT_StrucArr(HMEM_CTX_REF1 ppTmpWTxtStruc[0],CertCount);
  if((Retcode != 0) || (AskStatus <= 0)) 	// reject
    return(0);
  return(1);
}

/**
* Processes the less
* severe and configuration overrideable certificate stati (GetCertAcceptStatus).
*
*  @param pConnStruc Control Structure
*  @param CertArray The Certificates
*  @param CertCount The number
*  @param CertStatus Status from Chain verifier
*
*  @return int Status 0 - not acceptable
* <br>            1 - acceptable
*/
static  int  GetCertAcceptStatus(CONNSTRU * pConnStruc,
			X509CERT ** CertArray,int CertCount, int CertStatus)
{
  int i;
  int Status = 0;
  int PolicyFlags;
  int SavedCertStatus = CertStatus;
  CFG_STRU * pCfgStruc;

  HMEM_CTX_DEF1;

  if(pConnStruc == NULL)
    return(0);					// reject

  LOAD_HMEM_CTX_PTR(CONN_pMemCtx(pConnStruc));

  pCfgStruc = pConnStruc->pCfgStruc;
  PolicyFlags = pCfgStruc->CertPolicyFlags;
  //---------------------------------------------
  // Check No Trusted Root / action
  //---------------------------------------------

  if((CertStatus & ASN1_ENDCERT_NO_TRUST_ROOT) != 0)	// no trusted root set
  {

    i = (PolicyFlags >> CERT_NO_TRUST_ROOT_POLICY_SHIFT) & CERT_POLICY_MASK;
    if((i != CERT_POLICY_ASK) && (i != CERT_POLICY_ACCEPT))
      return(0);
    if(i == CERT_POLICY_ASK)			// ask user
      Status |= 1;
    else					// always accept --> remove ???
    {
//      CertStatus &= (~ASN1_ENDCERT_NO_TRUST_ROOT); // remove flag
      Status |= 1;				// ALWAYS ASK !!
    }

  }
  //---------------------------------------------
  // Check revokation fetch status / action
  //---------------------------------------------
  if((CertStatus & ASN1_ENDCERT_REVOKSTATE_UNKNOWN) != 0) // status unknown set
  {
    i = (PolicyFlags >> CERT_UNKNOWN_OCSTA_POLICY_SHIFT) & CERT_POLICY_MASK;
    if((i != CERT_POLICY_ASK) && (i != CERT_POLICY_ACCEPT))
      return(0);
    if(i == CERT_POLICY_ASK)
      Status |= 1;
    else					// always accept
      CertStatus &= (~ASN1_ENDCERT_REVOKSTATE_UNKNOWN);	// remove flag
  }
  //---------------------------------------------
  // Check revoked status / action
  //---------------------------------------------
  if((CertStatus & ASN1_ENDCERT_REVOKED) != 0)		// revoked set
  {
    i = (PolicyFlags >> CERT_REVOKED_POLICY_SHIFT) & CERT_POLICY_MASK;
    if((i != CERT_POLICY_ASK) && (i != CERT_POLICY_ACCEPT))
      return(0);
    if(i == CERT_POLICY_ASK)
      Status |= 1;
    else					// always accept
      CertStatus &= (~ASN1_ENDCERT_REVOKED);	// remove flag
  }
  //---------------------------------------------
  // Check Root expire/action
  //---------------------------------------------
  if((CertStatus & ASN1_ENDCERT_ROOT_TIMEOUT) != 0)	// root timeout
  {
    i = (PolicyFlags >> CERT_ROOT_EXPIRED_POLICY_SHIFT) & CERT_POLICY_MASK;
    if((i != CERT_POLICY_ASK) && (i != CERT_POLICY_ACCEPT))
      return(0);
    if(i == CERT_POLICY_ASK)
      Status |= 1;
    else					// always accept
      CertStatus &= (~ASN1_ENDCERT_ROOT_TIMEOUT);	// remove flag
  }
  //---------------------------------------------
  // Check Chain expire/action
  //---------------------------------------------
  if((CertStatus & ASN1_ENDCERT_CHAIN_ELEM_TIMEOUT) != 0) // chain timeout
  {
    i = (PolicyFlags >> CERT_CHAIN_EXPIRED_POLICY_SHIFT) & CERT_POLICY_MASK;
    if((i != CERT_POLICY_ASK) && (i != CERT_POLICY_ACCEPT))
      return(0);
    if(i == CERT_POLICY_ASK)
      Status |= 1;
    else					// always accept
      CertStatus &= (~ASN1_ENDCERT_CHAIN_ELEM_TIMEOUT);	// remove flag
  }
  //---------------------------------------------
  // Check Endcert not yet valid/action
  //---------------------------------------------
  if((CertStatus & ASN1_ENDCERT_NOT_YET_VALID) != 0) // not yet
  {
    i = (PolicyFlags >> CERT_NOT_YET_VALID_POLICY_SHIFT) & CERT_POLICY_MASK;
    if((i != CERT_POLICY_ASK) && (i != CERT_POLICY_ACCEPT))
      return(0);
    if(i == CERT_POLICY_ASK)
      Status |= 1;
    else					// always accept
      CertStatus &= (~ASN1_ENDCERT_NOT_YET_VALID);// remove flag
  }
  //---------------------------------------------
  // Check Endcert expired/action
  //---------------------------------------------
  if((CertStatus & ASN1_ENDCERT_EXPIRED) != 0) // expired
  {
    i = (PolicyFlags >> CERT_EXPIRED_POLICY_SHIFT) & CERT_POLICY_MASK;
    if((i != CERT_POLICY_ASK) && (i != CERT_POLICY_ACCEPT))
      return(0);
    if(i == CERT_POLICY_ASK)
      Status |= 1;
    else					// always accept
      CertStatus &= (~ASN1_ENDCERT_EXPIRED);	// remove flag
  }
  //---------------------------------------------
  // Check Windows Terminal Server certificate/action
  //---------------------------------------------
  if((CertStatus & ASN1_ENDCERT_WTS_GENERATED_CERT) != 0)
  {
    i = (PolicyFlags >> CERT_WTS_CERTIFICATE_POLICY_SHIFT) & CERT_POLICY_MASK;
    if((i != CERT_POLICY_ASK) && (i != CERT_POLICY_ACCEPT))
      return(0);
    if(i == CERT_POLICY_ASK)
      Status |= 1;
    else					// always accept
      CertStatus &= (~ASN1_ENDCERT_WTS_GENERATED_CERT);	// remove flag
  }
  //---------------------------------------------
  // Check if all are to accept, i.e. Status = 0
  //---------------------------------------------
  if(Status == 0)
    return(1);					// do accept
  //---------------------------------------------
  // The User must be asked if to accept it....
  // Check if a Callback function is given
  //---------------------------------------------
  if(pCfgStruc->pAskUserCertsCb == NULL)
  {
    return(0);					// no callback !!
  }
  //---------------------------------------------
  // Prepare data for user callback, call the UI
  //---------------------------------------------
  Status = PrepAskUserCertState(HMEM_CTX_REF1
				pCfgStruc, CertArray, CertCount,
				CertStatus, SavedCertStatus);
  return(Status);
//  return(0);	// for the moment...
}

/**
* Subroutine ChkCertSubjCnameInList checks if a common name of a
* server/client certificate is in the subject comman name list (ChkCertSubjCnameInList).
*
* Will set the Subject names list lock flag before doing the check.
*
*  @param pCert Certificate Structure
*  @param pConnStruc Connection structure
*  @param pResult result of compare
*
*  @return HSSL_OP_OK on success, else error occured
*/
static   int ChkCertSubjCnameInList(X509CERT * pCert,
			CONNSTRU * pConnStruc, int* pResult)
{
  int Retcode;
  char* pSubjCNamesList;

  HMEM_CTX_DEF1;

  

  LOAD_HMEM_CTX_PTR(CONN_pMemCtx(pConnStruc));

#ifndef XH_INTERFACE
  GetSubjListLock();				// lock the names list 
#endif // XH_INTERFACE
  pSubjCNamesList = pConnStruc->pCfgStruc->SubjCNamesListPtr;

  if(pSubjCNamesList == NULL)
  {
#ifndef XH_INTERFACE
    ReleaseSubjListLock();			// release the lock
#endif // XH_INTERFACE
    pResult[0] = ASN1_NOT_SAME;
    return(HSSL_OP_OK);
  }
  Retcode = CheckKnownCertSubjCommonName(HMEM_CTX_REF1 pCert,pSubjCNamesList,pResult);

#ifndef XH_INTERFACE
  ReleaseSubjListLock();			// release the lock
#endif // XH_INTERFACE
  return(Retcode);

  
}

/**
*  Checks, if the given certificate chain complies with the signature types
*  configured for this connection.
*
*  If none are configured, default values are used according to the entity type.
*
*  @param adsp_connection  The structure, defining the current connection
*  @param aadsp_cert_array The certificate chain to be checked
*  @param inp_cert_count   The number of certificates in the chain
*  @param inp_entity       The entity type
*
*  @return  0, if the chain complies to the sig types, 1 otherwise
*/
static  int  m_check_chain_sig_types(CONNSTRU * adsp_connection,
                                                X509CERT ** aadsp_cert_array,
                                                int inp_cert_count,
                                                int inp_entity)
{
   char* abyp_sig_list = adsp_connection->pCfgStruc->achc_tls_12_sig_algs;
   if(abyp_sig_list == NULL){
      if(inp_entity == SERVER_ENTITY){
         abyp_sig_list = abys_default_server_sigtype_list;
      }else{
         switch(adsp_connection->KeyExchgMode)
         {
         case KEY_EXCHANGE_RSA:
         case KEY_EXCHANGE_DHE_RSA:
         case KEY_EXCHANGE_ECDHE_RSA:
         case KEY_EXCHANGE_DH_RSA:
            abyp_sig_list = abys_tls_12_rsa_sig_list;
            break;
         case KEY_EXCHANGE_DH_DSS:
         case KEY_EXCHANGE_DHE_DSS:
            abyp_sig_list = abys_dsa_sig_list;
            break;
         default:

            return 1;
         }
      }
   }
   inp_cert_count--;
   for(;inp_cert_count >= 0;inp_cert_count--){ 
      if(m_check_cert_from_array_sig_type(aadsp_cert_array,inp_cert_count,abyp_sig_list) == 0){
         return 1;
      }
   }
   return 0;
}
/**
* Subroutine ProcessCertificate checks server/client certificate message
* for correct length and parameters, verifies the certificate chain
* and extracts needed parameters for the key exchange (ProcessCertificate).
*
*  @param pConnStruc Connection structure
*  @param InpBuf Buffer Base
*  @param InpOffset Start of data
*  @param DataLen generated data count
*  @param pAlertType type of Alert on Error
*  @param pAlertLvl level of Alert on Error
*
*  @return HSSL_OP_OK on success, else error occured
*/
static  int  ProcessCertificate(CONNSTRU * pConnStruc,
		   char* InpBuf, int InpOffset, int DataLen,
		   int* pAlertType, int* pAlertLvl)
{
  int Retcode;
  int i;

  int Entity, ProtocolType, AuthFlags,KeyExchgMode;
  int PolicyFlags;
  int Flags = 0;

  int PublicAlgor, SignatAlgor;
  int DhFixedParamsFlag = 0;

  int CertCount;
  int InpIndex = InpOffset;
  int CertStatus, OcspStatus;

  IDATA* pIdata;
  char* pCertBuf;

  int MsgLen;
  CFG_STRU * pCfgStruc;
  X509CERT * pCert;
  X509CERT ** pCertArray;

  int pTmpCnt[1];
  int pTmpReason[1];
  int pTmpCNRootIndex[1];
  int pTmpResult[1];

  int pTmpLong[1];
  int pOcspStatus[1];

  char* pTmpBuf[1];

  RSA_STRUC* pTmpRsaStruc[1] = {NULL};
  DSA_STRUC* pTmpDsaStruc[1] = {NULL};
  DH_STRUC* pTmpDhStruc[1]   = {NULL};

  X509CERT ** ppTmpCertArray[1];
  CTREESTR * ppTmpTreeStruc[1];

  HMEM_CTX_DEF1;

  LOAD_HMEM_CTX_PTR(CONN_pMemCtx(pConnStruc));

  pCfgStruc = pConnStruc->pCfgStruc;
  pOcspStatus[0] = 0;
  //-------------------------------------------------------
  // Preset Alert Type and Level to Illegal parameter/Fatal
  //-------------------------------------------------------
  pAlertType[0] = AD_ILLEGAL_PARAMETER;
  pAlertLvl[0]  = ALERT_LEVEL_FATAL;
  //----------------------------------------------------
  // Get/check Message length
  //----------------------------------------------------
  BIGchar2long(InpBuf,MsgLen,InpIndex);		// from 1st 4 bytes
  MsgLen &= 0xFFFFFF;				// only 3 bytes valid
  DataLen  -= HT_RECORD_HDR_SIZE;		// reduce length

  if(MsgLen != (int) DataLen) 
    return(HSSL_CERTMSG_INVALID_MSGLEN);	// inconsistent data size
  //----------------------------------------------------
  // Check for special case of empty message (TLS1.0)
  //----------------------------------------------------
  Entity        =  pConnStruc->Entity;
  ProtocolType  = pConnStruc->ActualProtocol;
  AuthFlags     = pConnStruc->AuthFlags;
  KeyExchgMode  = pConnStruc->KeyExchgMode;
   
  // Our SRP does not allow use of Certificates
  if( KEY_EXCHANGE_SRP == KeyExchgMode){
     pAlertType[0] = AD_UNEXPECTED_MSG;
     return (HSSL_CERTMSG_INV_KEYEXCHG_MODE);
  }
  
  if(MsgLen <= 3)				// empty message/or list
  {
    pAlertType[0] = AD_HSHAKE_FAILURE;		// set Alert
    if(Entity == SERVER_ENTITY)			// may be allowed
    {
      if(ProtocolType != SSL_PROT_TYPE)		// in TLS may be allowed
      {
        if(((AuthFlags & CLNT_AUTH_BIT_MASK) == 0) ||  // no AUTH required
            (((AuthFlags & CLNT_AUTH_BIT_MASK) != 0) &&  // AUTH requested
            ((AuthFlags & SRVR_REQ_CERT_IF_AVAIL_BIT_MASK) != 0))){
          m_generate_log_msg(pConnStruc, "Client could not be authenticated. Continue is permited.",0,HL_AUX_WT_DATA2,"SSLCER");
          return(HSSL_OP_OK);			// just skip message
        }
      }
      return(HSSL_CERTMSG_NO_CLIENT_CERT);
    }
    return(HSSL_CERTMSG_NO_SERVER_CERT);
  }
  //-----------------------------------------------------------------
  // Convert the Certificate List into array of internal certificates
  //-----------------------------------------------------------------
  Retcode = FromSSLCertListEX(HMEM_CTX_REF1
                              InpBuf,
                              InpIndex,
                              DataLen,
                              ppTmpCertArray,
                              pTmpCnt,
                              pTmpLong,
                              (pCfgStruc->ExtConf2Flags & (DONT_SORT_RDNS_BIT_MASK | PROCESS_CERT_EXTS_BIT_MASK)) >> CERT_PROCESS_FLAGS_SHIFT);

  if(Retcode != ASN1_OP_OK)
  {
    pAlertType[0] = AD_BAD_CERTIFICATE;
    if((Entity == SERVER_ENTITY) &&
       ((AuthFlags & CLNT_AUTH_BIT_MASK) == 0))
      pAlertLvl[0] = ALERT_LEVEL_WARNING;
    return(HSSL_CERTMSG_BAD_CERTLIST);
  }
  pCertArray = ppTmpCertArray[0];	// get array base
  pCert      = pCertArray[0];		// get the first from the list
  CertCount  = pTmpCnt[0];		// get number for freeing

  //------------------------------------------------------------------
  // Certificate from the Server, Type must match the Key Exchange mode !
  //------------------------------------------------------------------
  if(Entity == CLIENT_ENTITY)
  {
    //----------------------------------------------------------------
    // get from key exchange type the public algor and signature algor
    //----------------------------------------------------------------
    switch(KeyExchgMode)
    {
      case KEY_EXCHANGE_RSA:
        PublicAlgor = RSA_PUBLIC_ALGOR;
        SignatAlgor = ANY_SIGNAT_ALGOR;
        break;

      case KEY_EXCHANGE_DH_DSS:
      case KEY_EXCHANGE_DH_RSA:
        PublicAlgor = DH_PUBLIC_ALGOR;
        DhFixedParamsFlag = 1;
        if(KeyExchgMode == KEY_EXCHANGE_DH_DSS)
          SignatAlgor = DSA_SIGNAT_ALGOR;
        else
          SignatAlgor = RSA_SIGNAT_ALGOR;
        break;

      case KEY_EXCHANGE_DHE_DSS:
        PublicAlgor = DSA_PUBLIC_ALGOR;
        SignatAlgor = ANY_SIGNAT_ALGOR;
        break;

      case KEY_EXCHANGE_DHE_RSA:
      case KEY_EXCHANGE_ECDHE_RSA:
        PublicAlgor = RSA_PUBLIC_ALGOR;
        SignatAlgor = ANY_SIGNAT_ALGOR;
        break;

      default:
        FreeCertList(HMEM_CTX_REF1 pCertArray,CertCount);
        pAlertType[0] = AD_INTERNAL_ERROR;
        return(HSSL_CERTMSG_INV_KEYEXCHG_MODE);
    }
    //----------------------------------------------------------------------
    // Check if the remote Endcertificate (is first in list) matches
    // public algorithm and signature algorithm;
    //----------------------------------------------------------------------
    /** @todo more precise check of signature algorithm. Implement, once configurable Sig Types are available. */
    if((pCert->PublicKeyType != PublicAlgor) || // public key mismatch
      ((SignatAlgor != ANY_SIGNAT_ALGOR) &&	// specific signature
       (pCert->SignatAlgor != SignatAlgor)))
    {
      pAlertType[0] = AD_CERTIFICATE_UNKNOWN;
      FreeCertList(HMEM_CTX_REF1 pCertArray,CertCount);
       return(HSSL_CERTMSG_ALG_EXCHG_MISMATCH);
    }
  }
  else
  {
  //------------------------------------------------------------------
  // Certificate from the Client, get the Public and Signature Algors
  // check if usable for Certificate verify
  //------------------------------------------------------------------
    PublicAlgor = pCert->PublicKeyType;		// get public key
    SignatAlgor = pCert->SignatAlgor;		// get signature
    if(PublicAlgor == DH_PUBLIC_ALGOR)
      DhFixedParamsFlag = 1;

    if((KeyExchgMode == KEY_EXCHANGE_RSA) &&		// RSA
       ((PublicAlgor != RSA_PUBLIC_ALGOR) &&		// only RSA and DSA
        (PublicAlgor != DSA_PUBLIC_ALGOR)))
    {
      pAlertType[0] = AD_CERTIFICATE_UNKNOWN;
      if((AuthFlags & CLNT_AUTH_BIT_MASK) == 0)
        pAlertLvl[0] = ALERT_LEVEL_WARNING;
      FreeCertList(HMEM_CTX_REF1 pCertArray,CertCount);
      return(HSSL_CERTMSG_ALG_EXCHG_MISMATCH);
    }
  }
  //----------------------------------------------------------------------
  // Extract the Certificates public parameters according to algorithm,
  // store them as remote parameters
  //----------------------------------------------------------------------
  switch(PublicAlgor)
  {
    case RSA_PUBLIC_ALGOR:
      Retcode = FromArrayDescToRSAPubParams(HMEM_CTX_REF1 pCert->SubjPubKeyParVal,pTmpRsaStruc);
      pConnStruc->pRemoteRsaStruc = pTmpRsaStruc[0];
      pConnStruc->RemoteCertPublicAlgor = SIG_ALGOR_RSA;
      break;

    case DSA_PUBLIC_ALGOR:
      Retcode = FromArrayDescToDSAPubParams(HMEM_CTX_REF1 pCert->SubjPubKeyParVal,pTmpDsaStruc);
      pConnStruc->pRemoteDsaStruc = pTmpDsaStruc[0];
      pConnStruc->RemoteCertPublicAlgor = SIG_ALGOR_DSA;
      break;

    case DH_PUBLIC_ALGOR:
      Retcode = FromArrayDescToDHPubParams(HMEM_CTX_REF1 pCert->SubjPubKeyParVal,pTmpDhStruc);
      pConnStruc->pRemoteDhStruc = pTmpDhStruc[0];
      break;
  }
  if(Retcode != ASN1_OP_OK)
  {
    FreeCertList(HMEM_CTX_REF1 pCertArray,CertCount);
    pAlertType[0] = AD_INTERNAL_ERROR;
    return(HSSL_CERTMSG_CERT_PUBPARS_ERROR);
  }
  //----------------------------------------------------------------------
  // If DH Client certificate received, check if the DH-Parameters match
  // the local ones
  //----------------------------------------------------------------------
  if((DhFixedParamsFlag != 0) &&		// DH with fixed parameters
     (Entity == SERVER_ENTITY))			// from the client
  {
    i = DH_ParamCompare(pTmpDhStruc[0],pConnStruc->pLocalDhStruc);
    if(i != 0)					// not same / Null etc.
    {
      FreeCertList(HMEM_CTX_REF1 pCertArray,CertCount);
      pAlertType[0] = AD_CERTIFICATE_UNKNOWN;
      if((AuthFlags & CLNT_AUTH_BIT_MASK) == 0)
        pAlertLvl[0] = ALERT_LEVEL_WARNING;
      return(HSSL_CERTMSG_DHPAR_MISMATCH);
    }
  }
  //-------------------------------------------------------
  // now verify the certificate chain and check the result
  //-------------------------------------------------------
//  pCfgStruc = CONN_CfgStrucPtr(pConnStruc);

  if((pCfgStruc->ExtConf2Flags & VALIDITY_CHK_OVERLAP_BIT_MASK) != 0)
    Flags = 0;				// perform weak check only
  else					// stronger check (default)
    Flags = 0x01;			// set extended time check mode

  PolicyFlags = pCfgStruc->CertPolicyFlags;
  PolicyFlags = (PolicyFlags >> CERT_NO_TRUST_ROOT_POLICY_SHIFT) &
                 CERT_POLICY_MASK;
  if((PolicyFlags == CERT_POLICY_ASK) || (PolicyFlags == CERT_POLICY_ACCEPT))
    Flags |= 0x02;			// Map no root error to untrusted root

  //--------------------------------------------------
  // Check if external storage is used
  //--------------------------------------------------
  pTmpReason[0] = 0;
  pTmpResult[0] = ASN1_ENDCERT_NO_TRUST_ROOT | ASN1_ENDCERT_NOT_USABLE_MASK;
  if((pCfgStruc->ExtCertsFlags & EXTCERT_STORE_USED_BIT) != 0) // external store...
  {
    Retcode = HSSL_GetIssuerCertChainFromExt(HMEM_CTX_REF1 pCfgStruc->pExtCertStruc,pCertArray,pTmpCnt[0],ppTmpTreeStruc);
    if(Retcode < ASN1_OP_OK)
    {
      FreeCertList(HMEM_CTX_REF1 pCertArray,CertCount);
      pAlertType[0] = AD_INTERNAL_ERROR;
      return(HSSL_CERTMSG_CERT_CHAIN_VFY_ERR);	// should not happen
    }

    if(ppTmpTreeStruc[0] != NULL)
    {
      Retcode = VerifyCertificateChainNew(HMEM_CTX_REF1 pCertArray,pTmpCnt[0],ppTmpTreeStruc[0],Flags,pTmpResult,pTmpReason,pTmpCNRootIndex);
      if(pConnStruc->ActualProtocol == TLS_V2_PROT_TYPE){ //check sig types at 1.2
         Retcode |= m_check_chain_sig_types(pConnStruc, pCertArray,
            pTmpCnt[0], Entity);
      }
      if(Retcode != ASN1_OP_OK)
      {
        FreeCertList(HMEM_CTX_REF1 pCertArray,CertCount);
        FreeCertTreeStruc(HMEM_CTX_REF1 ppTmpTreeStruc[0]);
        pAlertType[0] = AD_INTERNAL_ERROR;
        return(HSSL_CERTMSG_CERT_CHAIN_VFY_ERR);	// should not happen
      }
      if(pTmpReason[0] == 0)			// could be used
      {
        //------------------------------------------------------
        // Use OCSP verification if activated and possible 
        //------------------------------------------------------
        Retcode = VerifyChainWithOcsp(pConnStruc,
				      pCfgStruc,pCertArray,
				      pTmpCnt[0], ppTmpTreeStruc[0],
				      pTmpResult[0],pTmpResult,
				      pOcspStatus);
        if(Retcode != HSSL_OP_OK)
        {
          FreeCertList(HMEM_CTX_REF1 pCertArray,CertCount);
          FreeCertTreeStruc(HMEM_CTX_REF1 ppTmpTreeStruc[0]);
          pAlertType[0] = AD_INTERNAL_ERROR;
          return(HSSL_CERTMSG_CHAIN_OCSP_VFY_ERR);	// should not happen
        }
        m_generate_log_msg(pConnStruc,"OCSP verification returned result %i",pTmpResult[0],HL_AUX_WT_DATA2,"SSLCER");
      }
      FreeCertTreeStruc(HMEM_CTX_REF1 ppTmpTreeStruc[0]);
    }
  }
  //----------------------------------------------------------
  // Check if already a usable Certificate found (external)
  //----------------------------------------------------------
  if(((pTmpReason[0] != 0) || (pTmpResult[0] != ASN1_ENDCERT_USABLE)) &&
      ((pCfgStruc->ExtCertsFlags & EXTCERT_NO_CBD_USED_BIT) == 0))
  {
    pTmpReason[0] = 0;
    pTmpResult[0] = ASN1_ENDCERT_NO_TRUST_ROOT;

    Retcode = VerifyCertificateChainNew(HMEM_CTX_REF1 pCertArray,pTmpCnt[0],pConnStruc->pCfgStruc->pCertTreeStruc,Flags,pTmpResult,pTmpReason,pTmpCNRootIndex);
    if(pConnStruc->ActualProtocol == TLS_V2_PROT_TYPE){ //check sig types at 1.2
       Retcode |= m_check_chain_sig_types(pConnStruc, pCertArray,
          pTmpCnt[0], Entity);
    }

    if(Retcode != ASN1_OP_OK)
    {
      FreeCertList(HMEM_CTX_REF1 pCertArray,CertCount);
      pAlertType[0] = AD_INTERNAL_ERROR;
      return(HSSL_CERTMSG_CERT_CHAIN_VFY_ERR);	// should not happen
    }

    if(pTmpReason[0] == 0)			// could be used
    {
      Retcode = VerifyChainWithOcsp(pConnStruc,
			pCfgStruc,pCertArray, pTmpCnt[0],
			pConnStruc->pCfgStruc->pCertTreeStruc,
			pTmpResult[0],pTmpResult,pOcspStatus);
      if(Retcode != HSSL_OP_OK)
      {
        FreeCertList(HMEM_CTX_REF1 pCertArray,CertCount);
        pAlertType[0] = AD_INTERNAL_ERROR;
        return(HSSL_CERTMSG_CHAIN_OCSP_VFY_ERR);	// should not happen
      }
      m_generate_log_msg(pConnStruc,"OCSP verification returned result %i",pTmpResult[0],HL_AUX_WT_DATA2,"SSLCER");
    }    
  }
  //--------------------------------------------------------
  // Process checking results now...
  //--------------------------------------------------------
  if(pTmpReason[0] != 0)	// something was wrong with the chain
  {
    m_generate_log_msg(pConnStruc,
       "Certificate verification failed during SSL Handshake because of reason %i",
       pTmpReason[0],HL_AUX_WT_DATA2,"SSLCER");
    pAlertType[0] = AD_CERTIFICATE_UNKNOWN;

    if((Entity == SERVER_ENTITY) &&
       ((AuthFlags & CLNT_AUTH_BIT_MASK) == 0))
      pAlertLvl[0] = ALERT_LEVEL_WARNING;

    // fine translate reasons to errors for easier classification
    if((pTmpReason[0] <= ASN1_VFY_CHAIN_SELFSIGN_NOT_TOP) &&
       (pTmpReason[0] >= ASN1_VFY_CHAIN_KEYUSAGE_ERR))
      return(HSSL_VFY_CHAIN_REJECT_BASE + pTmpReason[0]); // -340..-355

    return(HSSL_CERTMSG_CERT_CHAIN_REJECT);
  }
  CertStatus = pTmpResult[0];		// get usability

  if(CertStatus == ASN1_ENDCERT_USABLE)	// everything is fine ....
  {
    //--------------------------------------------------------------
    // Save common name of Other side (for statistics...)
    //--------------------------------------------------------------
    if(FromASN1_DNCommonNameToString(HMEM_CTX_REF1 pCert->Subject,pTmpBuf) == ASN1_OP_OK)
      pConnStruc->pPartnerName = pTmpBuf[0];
    //--------------------------------------------------------------
    // Save certificate for the ?? LDAP processing ??
    //--------------------------------------------------------------
    pIdata = pCert->Certificate->ppArr[0];
    if((pCertBuf = BIT8_ARRAY_ALLOC(HMEM_CTX_REF,
				    pIdata->Len)) != NULL)
    {
      memcpy(pCertBuf+0,pIdata->Base+(int) pIdata->Off,pIdata->Len);
      pConnStruc->pPartnerCert = pCertBuf;
      pConnStruc->PartnerCertLen = pIdata->Len;
    }
    //--------------------------------------------------------------
    // Check Subject Common Name of Endcert is in list (if required)
    //--------------------------------------------------------------
    if(((AuthFlags & SRVR_AUTH_BIT_MASK) != 0) ||
       ((AuthFlags & (CLNT_AUTH_BIT_MASK|INCL_CLNT_SUBJ_LIST_BIT_MASK)) ==
        (CLNT_AUTH_BIT_MASK | INCL_CLNT_SUBJ_LIST_BIT_MASK)) ||
       ((AuthFlags & (CLNT_AUTH_BIT_MASK|EXCL_CLNT_SUBJ_LIST_BIT_MASK)) ==
        (CLNT_AUTH_BIT_MASK | EXCL_CLNT_SUBJ_LIST_BIT_MASK)))
    {
      Retcode = ChkCertSubjCnameInList(pCertArray[0],pConnStruc,pTmpResult);
      if(Retcode != ASN1_OP_OK)			// error occured
      {
        FreeCertList(HMEM_CTX_REF1 pCertArray,CertCount);
        pAlertType[0] = AD_INTERNAL_ERROR;
        return(HSSL_CERTMSG_CNAME_EXTRACT_ERR);
      }
      //---------------------------------------------------------
      // Check result of list search:
      // I . If Server Auth. selected and not found -> reject
      // II. If Client Auth. selected:
      //     a) If not found and List is Inclusion List -> reject
      //     b) If     found and List is Exclusion List -> reject
      //---------------------------------------------------------
      if((((AuthFlags & SRVR_AUTH_BIT_MASK) != 0) && // Server authenticate
           (pTmpResult[0] != ASN1_SAME)) ||		 // not found->reject

         (((AuthFlags & CLNT_AUTH_BIT_MASK) != 0) &&// Client authenticate
          ((((AuthFlags & INCL_CLNT_SUBJ_LIST_BIT_MASK) != 0) &&
            (pTmpResult[0] != ASN1_SAME)) ||		 // included, not found
           (((AuthFlags & EXCL_CLNT_SUBJ_LIST_BIT_MASK) != 0) &&
            (pTmpResult[0] == ASN1_SAME)))))		// excluded, found
      {
        FreeCertList(HMEM_CTX_REF1 pCertArray,CertCount);
        pAlertType[0] = AD_ACCESS_DENIED;
        if((AuthFlags & SRVR_AUTH_BIT_MASK) != 0)	// Server-Authenticate
          return(HSSL_CERTMSG_SRVR_CNAME_UNKNOWN);
        else						// must be client auth.
        {
          if((AuthFlags & INCL_CLNT_SUBJ_LIST_BIT_MASK) != 0) // included
            return(HSSL_CERTMSG_CLNT_CNAME_UNKNOWN);
          else
            return(HSSL_CERTMSG_CLNT_CNAME_EXCLUDE);
        }
      }  
    }
    //--------------------------------------------------
    // Set Certified Bit
    //--------------------------------------------------
    if(Entity == SERVER_ENTITY)
      pConnStruc->CertifiedFlags |= CLIENT_CERTIFIED_MASK;
    else
      pConnStruc->CertifiedFlags |= SERVER_CERTIFIED_MASK;
    FreeCertList(HMEM_CTX_REF1 pCertArray,CertCount);
    m_generate_log_msg(pConnStruc, "Certifcate successfully processed.", 0, HL_AUX_WT_DATA2,"SSLCER");
    return(HSSL_OP_OK);
  }
  //-------------------------------------------------------
  // something is wrong with the chain, check what, and
  // check accept by policy chosen
  //-------------------------------------------------------
  i = GetCertAcceptStatus(pConnStruc,pCertArray,CertCount,CertStatus);
  if(i != 0)				// should be accepted
  {
    if(Entity == SERVER_ENTITY)
      pConnStruc->CertifiedFlags |= CLIENT_CERTIFIED_MASK;
    else
      pConnStruc->CertifiedFlags |= SERVER_CERTIFIED_MASK;
    //--------------------------------------------------------------
    // Save common name of Other side (for statistics...)
    //--------------------------------------------------------------
    pCert = pCertArray[0];
    if(FromASN1_DNCommonNameToString(HMEM_CTX_REF1 pCert->Subject,pTmpBuf) == ASN1_OP_OK)
      pConnStruc->pPartnerName = pTmpBuf[0];
    //--------------------------------------------------------------
    // Save certificate for the ?? LDAP processing ??
    //--------------------------------------------------------------
    pIdata = pCert->Certificate->ppArr[0];
    if((pCertBuf = BIT8_ARRAY_ALLOC(HMEM_CTX_REF,
				    pIdata->Len)) != NULL)
    {
      memcpy(pCertBuf+0,pIdata->Base+(int) pIdata->Off,pIdata->Len);
      pConnStruc->pPartnerCert = pCertBuf;
      pConnStruc->PartnerCertLen = pIdata->Len;
    }

    FreeCertList(HMEM_CTX_REF1 pCertArray,CertCount);
    return(HSSL_OP_OK);
  }
  //-----------------------------------------------------------------
  // must be rejected, get correct alert type
  //-----------------------------------------------------------------
  FreeCertList(HMEM_CTX_REF1 pCertArray,CertCount);

  if((Entity == SERVER_ENTITY) &&
     ((AuthFlags & CLNT_AUTH_BIT_MASK) == 0))
    pAlertLvl[0] = ALERT_LEVEL_WARNING;

  pAlertType[0] = AD_CERTIFICATE_UNKNOWN;		// preload
  if((CertStatus & ASN1_ENDCERT_NO_TRUST_ROOT) != 0)
  {
    if(ProtocolType != SSL_PROT_TYPE)		// TLS
      pAlertType[0] = AD_UNKNOWN_CA;
    else 
      pAlertType[0] = AD_BAD_CERTIFICATE;
    return(HSSL_CERTMSG_NO_TRUST_ROOT);
  }

  if((CertStatus & ASN1_ENDCERT_REVOKSTATE_UNKNOWN) != 0)
  {
    pAlertType[0] = AD_CERTIFICATE_UNKNOWN;		// preload
    //-------------------------------------------------------
    // Sub-Decode OCSP-Status, if available
    //-------------------------------------------------------
    OcspStatus = pOcspStatus[0];
    if(OcspStatus == 0)			// none given
      return(HSSL_CERTMSG_REVOKSTATE_UNK_ERR);

    if((OcspStatus & OCSP_NO_RESPONSE_BIT) != 0)
      return(HSSL_CERTMSG_NO_OCSP_RESP);

    if((OcspStatus & OCSP_RESPONSE_UNSUCCESSFUL_BIT) != 0)
      return(HSSL_CERTMSG_UNSUCC_OCSP_RESP);

    if((OcspStatus & OCSP_UNTRUSTED_SIGNATURE_BIT) != 0)
      return(HSSL_CERTMSG_UNTRUST_OCSP_SIGN);

    if((OcspStatus & OCSP_UNTRUSTED_NONCE_BIT) != 0)
      return(HSSL_CERTMSG_UNTRUST_OCSP_NONCE);

    if((OcspStatus & OCSP_UNRELIABLE_PRODUCED_AT_BIT) != 0)
      return(HSSL_CERTMSG_UNREL_OCSP_PROD_AT);

    if((OcspStatus &
         (OCSP_UNRELIABLE_MATCH_A_BIT | OCSP_UNRELIABLE_MATCH_B_BIT |
          OCSP_UNRELIABLE_MATCH_C_BIT | OCSP_UNRELIABLE_MATCH_D_BIT)) != 0)
      return(HSSL_CERTMSG_UNREL_OCSP_MATCH);

    if((OcspStatus & OCSP_SRESP_UNRELIABLE_BIT) != 0)
      return(HSSL_CERTMSG_UNREL_OCSP_SRESP);

    if((OcspStatus & OCSP_SRESP_UNKNOWN_BIT) != 0)
      return(HSSL_CERTMSG_UNKNOWN_OCSP_SRESP);

    return(HSSL_CERTMSG_REVOKSTATE_UNK_ERR);
  }

  if((CertStatus & ASN1_ENDCERT_REVOKED) != 0)		// revoked set
  {
    pAlertType[0] = AD_CERTIFICATE_REVOKED;
    return(HSSL_CERTMSG_CERT_REVOKED);
  }
  else if((CertStatus & ASN1_ENDCERT_TIMEOUT_MASK) != 0)
  {
    pAlertType[0] = AD_CERTIFICATE_EXPIRED;
    return(HSSL_CERTMSG_CERT_EXPIRED);
  }
  return(HSSL_CERTMSG_BAD_CERTIFICATE);
}

/**
* Subroutine GenerateCertificateRequest generates server certificate
* request message from the connection structure parameters, updates
* Handshake Messages and enqueues Message for send to the priority queue (GenerateCertificateRequest).
*
*  @param pConnStruc Connection structure
*  @return HSSL_OP_OK on success, else error occured
*/
static  int  GenerateCertificateRequest(CONNSTRU * pConnStruc)
{
  int Retcode;
  int DstIndex = 0;
  int FormatFlag;

  int HeaderLen=0;
  int inl_sig_alg_len=0;

  int TotalLen;

  char* pDstBuf;

  char CertTypes[4];

  char* pTmpBuf[1];
  char abyl_temp_sig_ext[((SIG_ALGOR_MAX_COUNT+1)*2)];
  int pTmpLong[1];

  TX_QEL * pTxQel;

  HMEM_CTX_DEF1;

  LOAD_HMEM_CTX_PTR(CONN_pMemCtx(pConnStruc));

  //----------------------------------------------------
  // get the request types from key exchange mode
  //----------------------------------------------------
  switch(pConnStruc->KeyExchgMode)
  {
    case KEY_EXCHANGE_RSA:
    case KEY_EXCHANGE_DHE_RSA:
    case KEY_EXCHANGE_ECDHE_RSA:
      CertTypes[0] = 2;			// 2 types possible
      CertTypes[1] = CERT_TYPE_RSA_SIGN;
      CertTypes[2] = CERT_TYPE_DSS_SIGN;
      HeaderLen = 3;
      break;

    case KEY_EXCHANGE_DHE_DSS:
      CertTypes[0] = 2;			// 2 types possible
      CertTypes[1] = CERT_TYPE_DSS_SIGN;
      CertTypes[2] = CERT_TYPE_RSA_SIGN;
      HeaderLen = 3;
      break;

    case KEY_EXCHANGE_DH_DSS:
      CertTypes[0] = 3;			// 3 types possible
      CertTypes[1] = CERT_TYPE_DSS_FIXED_DH;
      CertTypes[2] = CERT_TYPE_DSS_SIGN;
      CertTypes[3] = CERT_TYPE_RSA_SIGN;
      HeaderLen = 4;
      break;

    case KEY_EXCHANGE_DH_RSA:
      CertTypes[0] = 3;			// 3 type possible
      CertTypes[1] = CERT_TYPE_RSA_FIXED_DH;
      CertTypes[2] = CERT_TYPE_RSA_SIGN;
      CertTypes[3] = CERT_TYPE_DSS_SIGN;
      HeaderLen = 4;
      break;

    default:
      return(HSSL_GENCREQ_INV_KEY_EXCHG_MODE);
  }
  if(pConnStruc->ActualProtocol == TLS_V2_PROT_TYPE){ //generate signature algorithm list
    char* abyp_sig_list = pConnStruc->pCfgStruc->achc_tls_12_sig_algs;
    if(abyp_sig_list == NULL){
       abyp_sig_list = abys_default_server_sigtype_list;
    }
    inl_sig_alg_len = m_generate_sig_extension(abyp_sig_list, abyl_temp_sig_ext,0);
    if(inl_sig_alg_len < 4){
       return HSSL_GENCREQ_INV_SIG_LIST;
    }
  }
  //----------------------------------------------------
  // Allocate TX-Qel without buffer
  //----------------------------------------------------
  pTxQel = AllocInitTxQel(HMEM_CTX_REF1
			  0,(unsigned char) TX_TYPE_HANDSHAKE_MSG);
  if(pTxQel == NULL)
    return(HSSL_TX_QEL_ALLOC_ERR);
  //----------------------------------------------------
  // Get the RDN-List with header for message/Cert-types
  //----------------------------------------------------
  FormatFlag = 0;
  if((pConnStruc->ExtendedConf2Flags & SRVR_RDN_LIST_WITH_SEQ_MASK) != 0)
    FormatFlag = 1;

  Retcode = ToSSL_RDNList(HMEM_CTX_REF1 pConnStruc->pCfgStruc->pRootRdnArray,HeaderLen+HT_RECORD_HDR_SIZE+inl_sig_alg_len,pTmpBuf,pTmpLong,FormatFlag);
  if(Retcode != ASN1_OP_OK)
  {
    FREE_ARRAY(HMEM_CTX_REF,pTxQel);
    return(HSSL_GENCREQ_RDNLIST_GEN_FAILED);
  }
  pDstBuf  = pTmpBuf[0];
  TotalLen = pTmpLong[0];
  //----------------------------------------------------
  // set Certificate Request Message and length
  //----------------------------------------------------
  BIGlong2charn((TotalLen-HT_RECORD_HDR_SIZE),pDstBuf,0);// convert to 4 bytes
  pDstBuf[DstIndex] = HT_CERTIFICATE_REQUEST;	// overwrite 1st byte
  DstIndex += HT_RECORD_HDR_SIZE;		// advance past MSG header
  //----------------------------------------------------
  // copy the given Certificate Type list to buffer
  //----------------------------------------------------
  memcpy(pDstBuf+DstIndex,CertTypes+0,HeaderLen);
  if(pConnStruc->ActualProtocol == TLS_V2_PROT_TYPE){
     memcpy(pDstBuf+DstIndex+HeaderLen,abyl_temp_sig_ext+0,inl_sig_alg_len);
  }
  pTxQel->pBuf    = pDstBuf;		// set the buffer
  pTxQel->DataLen = TotalLen;
  //----------------------------------------------------
  // Update Handshake Hashes
  //----------------------------------------------------
  HashHandshakeMessage(pConnStruc,pDstBuf,0, TotalLen);
  //----------------------------------------------------
  // Enqueue TX-Quel for send
  //----------------------------------------------------
  EnqueueTxQel(pConnStruc,pTxQel);
  return(HSSL_OP_OK);
}

/**
* Subroutine ProcessCertificateRequest checks server certificate
* request message for correct length and parameters,
* searches for end cert of specified type and RDN (ProcessCertificateRequest).
*
* With TLS V1.1, empty RDN list is possible.
*
*  @param pConnStruc Connection structure
*  @param InpBuf Buffer Base
*  @param InpOffset Start of data
*  @param DataLen data count
*  @param pAlertType type of Alert on Error
*  @param pAlertLvl level of Alert on Error
*
*  @return HSSL_OP_OK on success, else error occured
*/
static  int  ProcessCertificateRequest(CONNSTRU * pConnStruc,
		   char* InpBuf, int InpOffset, int DataLen,
		   int* pAlertType, int* pAlertLvl)
{
  int Retcode;
  int TotalLen;
  int InpIndex = InpOffset;

  int CertTypesLen;

  int KeyExchgMode;

  int CertTypeFlags = 0;			// Bit 0 - RSA sign
						// Bit 1 - DSS sign
						// Bit 2 - DH_RSA
						// Bit 3 - DH_DSS
  int ActCertType;

  int PrefCertAlgorsCnt = 0;
  int PrefCertAlgorsIndex = 0;

  int TypesListIndex;
  int TypesListLen;

  int Flags;
  int MsgLen;

  IDATPARR* pDhParValsDesc = NULL;

  int PrefCertAlgors[4];
  char* PrefSigAlgor[4];

  int pTmpCnt[1];
  int pTmpLen[1];
  int pTmpResult[1];

  IDATPARR* pTmpDhParValsDesc[1];

  X501_DN** pTmpDnDescArray[1];

  CFG_STRU * pCfgStruc;

  HMEM_CTX_DEF1;
  LOAD_HMEM_CTX_PTR(CONN_pMemCtx(pConnStruc));

  pCfgStruc = pConnStruc->pCfgStruc;
  //-------------------------------------------------------
  // Preset Alert Type and Level to Illegal parameter/Fatal
  //-------------------------------------------------------
  pAlertType[0] = AD_ILLEGAL_PARAMETER;
  pAlertLvl[0]  = ALERT_LEVEL_FATAL;
  
  // SRP does not allow use of Certificate Request
  if( KEY_EXCHANGE_SRP == pConnStruc->KeyExchgMode){
     pAlertType[0] = AD_UNEXPECTED_MSG;
     return (HSSL_CERTREQ_UNEXPECTED);
  }

  //----------------------------------------------------
  // Calculate minimal required length, smallest is TLS 1.1, Cert type field and empty RDN field
  //----------------------------------------------------
  TotalLen = CERT_TYPES_LEN_SIZE + CERT_TYPES_MIN_LEN + 2;
  //----------------------------------------------------
  // check Certificate Request Message length
  //----------------------------------------------------
  BIGchar2long(InpBuf,MsgLen,InpIndex);		// from 1st 4 bytes
  MsgLen &= 0xFFFFFF;				// only 3 bytes valid
  DataLen  -= HT_RECORD_HDR_SIZE;		// reduce length

  if((MsgLen != (int) DataLen) ||
     (MsgLen < TotalLen))
    return(HSSL_CERTREQ_INVALID_MSGLEN);	// inconsistent data size
  //----------------------------------------------------
  // check if Server is Certified
  //----------------------------------------------------
  if((pConnStruc->CertifiedFlags & SERVER_CERTIFIED_MASK) == 0)
  {
    pAlertType[0] = AD_HSHAKE_FAILURE;
    return(HSSL_CERTREQ_SRVR_NOT_CERTIFIED);	// is an ALERT Error !!
  }
  pConnStruc->CertifiedFlags |= CLIENT_CERT_REQ_MASK;	// save request present
  //----------------------------------------------------
  // get Certificate Types list len, check
  //----------------------------------------------------
  CertTypesLen = (int) InpBuf[InpIndex++] & 0xFF; // get length
  DataLen --;					  // reduce datacount
  if((CertTypesLen < CERT_TYPES_MIN_LEN) ||
     (CertTypesLen > DataLen))
    return(HSSL_CERTREQ_INV_TYPES_LEN);
  TypesListLen   = CertTypesLen;	// for PKCS11
  TypesListIndex = InpIndex;		// dto.
  //------------------------------------------------------------
  // Collect cert-types from list to flags and to array
  // Types in range >= 64 .. 255 are allowed with TLS 1.1!
  // ----- and should be ignored (MS Server 2008)
  //------------------------------------------------------------
  KeyExchgMode = pConnStruc->KeyExchgMode;
  DataLen -= CertTypesLen;
  do
  {
    ActCertType = (int) InpBuf[InpIndex++] & 0xFF; // get type
    switch(ActCertType)
    {
      case CERT_TYPE_RSA_EPHEMERAL_DH:
         if(pConnStruc->ActualProtocol != SSL_PROT_TYPE){
            return(HSSL_CERTREQ_UNSUPP_CERT_TYPE); // Old type, SSL3 only!
         }
      case CERT_TYPE_RSA_SIGN:
        if((CertTypeFlags & 0x01) == 0)
        {
          PrefCertAlgors[PrefCertAlgorsIndex] = RSA_PUBLIC_ALGOR;
          PrefSigAlgor[PrefCertAlgorsIndex++] = abys_ssl_sigtype_list;
          CertTypeFlags |= 1;
        }  
        break;

      case CERT_TYPE_DSS_EPHEMERAL_DH:
         if(pConnStruc->ActualProtocol != SSL_PROT_TYPE){
            return(HSSL_CERTREQ_UNSUPP_CERT_TYPE); // Old type, SSL3 only!
         }
      case CERT_TYPE_DSS_SIGN:
        if((CertTypeFlags & 0x02) == 0)
        {
          PrefCertAlgors[PrefCertAlgorsIndex] = DSA_PUBLIC_ALGOR;
          PrefSigAlgor[PrefCertAlgorsIndex++] = abys_ssl_sigtype_list;
          CertTypeFlags |= 2;
        }  
        break;

      case CERT_TYPE_RSA_FIXED_DH:
        if((CertTypeFlags & 0x04) == 0)
        {
          if((KeyExchgMode != KEY_EXCHANGE_DHE_RSA) &&
             (KeyExchgMode != KEY_EXCHANGE_DHE_DSS))
          {
            PrefCertAlgors[PrefCertAlgorsIndex] = DH_PUBLIC_ALGOR;
            PrefSigAlgor[PrefCertAlgorsIndex++] = abys_rsa_sig_list;
          }
          CertTypeFlags |= 4;
        }  
        break;

      case CERT_TYPE_DSS_FIXED_DH:
        if((CertTypeFlags & 0x08) == 0)
        {
          if((KeyExchgMode != KEY_EXCHANGE_DHE_RSA) &&
             (KeyExchgMode != KEY_EXCHANGE_DHE_DSS))
          {
            PrefCertAlgors[PrefCertAlgorsIndex] = DH_PUBLIC_ALGOR;
            PrefSigAlgor[PrefCertAlgorsIndex++] = abys_dsa_sig_list;
          }
          CertTypeFlags |= 8;
        }  
        break;
      case CERT_TYPE_ECDSA_SIGN:
      case CERT_TYPE_RSA_FIXED_ECDH:
      case CERT_TYPE_ECDSA_FIXED_ECDH:
         break;    //not yet supported

      default:						// TLS1.1/W2008 Server!
        if(ActCertType < CERT_TYPE_NONSTD_RANGE_START)	// IANA, unknown!
          return(HSSL_CERTREQ_UNSUPP_CERT_TYPE);
        break;						// non-std/private,skip
    } // switch
    CertTypesLen--;
  }while(CertTypesLen != 0);
  PrefCertAlgorsCnt = PrefCertAlgorsIndex;	// save count
  PrefCertAlgorsIndex = 0;
  //------------------------------------------------------
  // Check validity against selected key exchange mode
  //------------------------------------------------------
  if((KeyExchgMode == KEY_EXCHANGE_RSA) &&
     ((CertTypeFlags & 0x0C) != 0))		// is definitely invalid !
    return(HSSL_CERTREQ_UNSUPP_CERT_TYPE);
  //------------------------------------------------------
  // Check if a PKCS11 certificate is available
  //------------------------------------------------------
#if (defined _WIN32) && defined PKCS11
  Retcode = m_pk11certget(pConnStruc,InpBuf+TypesListIndex,TypesListLen,
                          InpBuf+InpIndex,DataLen);
  if(Retcode < 0)
    return(Retcode);
  if(Retcode > 0)			// found a certificate!!
  {
    pConnStruc->CertifiedFlags |= CLIENT_CERT_VERIFY_MASK; // must send verify
    pConnStruc->LocalCNIndex = -1;
    return(HSSL_OP_OK);
  }  
#endif // defined _WIN32
  //-------------------------------------------------------
  // If TLS 1.2, get requested signature algorithm list
  //-------------------------------------------------------
  if(pConnStruc->ActualProtocol == TLS_V2_PROT_TYPE){
     char* aabyl_return_ptr[1];
    int inl_work=0;
    BIGchar2word(InpBuf,inl_work,InpIndex);
    aabyl_return_ptr[0] = pConnStruc->abyc_remote_sig_algs;
    Retcode = m_process_supported_sig(HMEM_CTX_REF1 InpBuf, inl_work,
       InpIndex,aabyl_return_ptr);
    if(Retcode != HSSL_OP_OK){
        if(Retcode ==HSSL_ALERT_MSG_DECODE_ERROR){
            pAlertType[0] = AD_DECODE_ERROR;
        }
        return Retcode;
    }
    pConnStruc->abyc_remote_sig_algs = aabyl_return_ptr[0];
    if(pConnStruc->pCfgStruc->achc_tls_12_sig_algs != NULL){
       aabyl_return_ptr[0] = pConnStruc->pCfgStruc->achc_tls_12_sig_algs;
    } else {
       aabyl_return_ptr[0] = abys_default_server_sigtype_list;
    }
    if(m_filter_sig_list(pConnStruc->abyc_remote_sig_algs, aabyl_return_ptr[0])
       != HSSL_OP_OK){
        if(Retcode ==HSSL_ALERT_MSG_DECODE_ERROR){
            pAlertType[0] = AD_DECODE_ERROR;
        }
        return Retcode;
    }
    InpIndex += inl_work;
    for(inl_work=0 ; inl_work <= PrefCertAlgorsCnt ; inl_work++){
        PrefSigAlgor[inl_work]=pConnStruc->abyc_remote_sig_algs;
    }
  }
  //-------------------------------------------------------
  // Get the DN-List in internal format, sorted/not sorted
  //-------------------------------------------------------
  Retcode = FromSSL_DNList(HMEM_CTX_REF1 InpBuf,InpIndex,DataLen,pTmpDnDescArray,pTmpCnt,pTmpLen,pCfgStruc->ExtConf2Flags & DONT_SORT_RDNS_BIT_MASK);
  if(Retcode != ASN1_OP_OK)
    return(HSSL_CERTREQ_INV_RDNLIST_LEN);
  //------------------------------------------------------
  // if DH-Static exchange mode used, get DH-Param Array
  // from Remote Certs DH-Structure
  //------------------------------------------------------
  if((KeyExchgMode == KEY_EXCHANGE_DH_RSA) ||
     (KeyExchgMode == KEY_EXCHANGE_DH_DSS))
  {
    Retcode = FromDHPubParamsToArrayDesc(HMEM_CTX_REF1 pConnStruc->pRemoteDhStruc,pTmpDhParValsDesc);
    if(Retcode != ASN1_OP_OK)
    {
      FreeDnListArray(HMEM_CTX_REF1 pTmpDnDescArray[0],pTmpCnt[0]);
      pAlertType[0] = AD_INTERNAL_ERROR;
      return(HSSL_CERTREQ_DH_PUBPARAMS_ERROR);
    }
    pDhParValsDesc = pTmpDhParValsDesc[0];
  }
  //------------------------------------------------------
  // Get desired Certificate Index in order of request
  //------------------------------------------------------
  if(pCfgStruc->pCertTreeStruc != NULL)	// Priv key there, EXT/CDB
  {
    do
    {
      if((pCfgStruc->ExtCertsFlags & EXTCERT_STORE_USED_BIT) != 0)
      {
        Flags = 0;
        if((pCfgStruc->ExtConf2Flags & CFG2_EXT_ALWAYS_DLG_BIT_MASK) != 0)
        {
          Flags = HSSL_EXT_CERTSEL_FORCE_DLG_BIT |
		  HSSL_EXT_CERTSEL_IGN_INIF_BIT;
        }
        Retcode = HSSL_GetSpecifEndCertFromListTLS12(HMEM_CTX_REF1 
                                                     pCfgStruc->pExtCertStruc,
                                                     pCfgStruc->pCertTreeStruc,
                                                     PrefCertAlgors[PrefCertAlgorsIndex],
                                                     PrefSigAlgor[PrefCertAlgorsIndex],
                                                     Flags,
                                                     pTmpDnDescArray[0],
                                                     pTmpCnt[0],
                                                     pDhParValsDesc,
                                                     pTmpResult);
        if((Retcode > 0) &&
           ((Retcode & 0xFFFF) ==
	     (HOB_MSCAPI_ERRORBASE + GCCCFA_ERROROFFSET + GCCCFA_DC_CCBYUS_ERR)))
          Retcode = -Retcode;
        if((Retcode == ASN1_OP_OK) && (pTmpResult[0] >= 0)) // found Cert !!
          pCfgStruc->ExtCertsFlags |= EXTCERT_CLNTAUTH_FROM_EXT_BIT; // Signal
      }
      else
      {
        if((pCfgStruc->ExtConf2Flags & VALIDITY_CHK_OVERLAP_BIT_MASK) != 0)
        {
          Flags = 0x1E;			// perform weak check only
        }
        else				// stronger check (default)
        {
          Flags = 0x1F;			// set extended time check mode
        }
        Retcode = GetSpecificEndCertFromListTLS12(HMEM_CTX_REF1 
                                                  pCfgStruc->pCertTreeStruc,
                                                  1,
                                                  (int) Flags,
                                                  PrefCertAlgors[PrefCertAlgorsIndex],
                                                  PrefSigAlgor[PrefCertAlgorsIndex],
                                                  pTmpDnDescArray[0],
                                                  pTmpCnt[0],
                                                  pDhParValsDesc,
                                                  pTmpResult);
      }

      if(Retcode != ASN1_OP_OK)
      {
        FreeDnListArray(HMEM_CTX_REF1 pTmpDnDescArray[0],pTmpCnt[0]);
        FreeIDATPARR_Struc(HMEM_CTX_REF1 pDhParValsDesc);
        pAlertType[0] = AD_INTERNAL_ERROR;
        return(HSSL_CERTREQ_GET_ENDCERT_ERR);
      }
      if(pTmpResult[0] >= 0)			// found a certificate
      {
        if((PrefCertAlgors[PrefCertAlgorsIndex] == RSA_PUBLIC_ALGOR) ||
           (PrefCertAlgors[PrefCertAlgorsIndex] == DSA_PUBLIC_ALGOR))
          pConnStruc->CertifiedFlags |= CLIENT_CERT_VERIFY_MASK;
        pConnStruc->LocalCNIndex = pTmpResult[0];
        FreeDnListArray(HMEM_CTX_REF1 pTmpDnDescArray[0],pTmpCnt[0]);
        FreeIDATPARR_Struc(HMEM_CTX_REF1 pDhParValsDesc);
        return(HSSL_OP_OK);
      }
      PrefCertAlgorsIndex++;			// to next entry
      PrefCertAlgorsCnt--;
    }while(PrefCertAlgorsCnt != 0);
  }
  //------------------------------------------------------
  // no certificate was found, set local index negativ
  //------------------------------------------------------
  pConnStruc->LocalCNIndex = -1;
  FreeDnListArray(HMEM_CTX_REF1 pTmpDnDescArray[0],pTmpCnt[0]);
  FreeIDATPARR_Struc(HMEM_CTX_REF1 pDhParValsDesc);
  if((pCfgStruc->ExtCertsFlags & EXTCERT_STORE_USED_BIT) != 0)
  {
//    if(CFG_CertTreeStrucPtr(pCfgStruc) != NULL)	// Priv key there, EXT/CDB
//    {
      pCfgStruc->ExtCertsFlags |= EXTCERT_CLNTAUTH_FROM_EXT_BIT; // Signal!
//      return(HSSL_CERTREQ_GET_ENDCERT_NOCERT);
//    }
  }
  return(HSSL_OP_OK);
}

static int ms_gen_ecc_srv_exchange(char** aachp_dest,
                                   int* ainp_dest_len,
                                   int* ainp_param_len,
                                   CONNSTRU* adsp_connection)
{
    int inl_ret = ms_init_ecc(adsp_connection);
    if(inl_ret != HSSL_OP_OK){
        return inl_ret;
    }
    HMEM_CTX_DEF1;

    LOAD_HMEM_CTX_PTR(CONN_pMemCtx(adsp_connection));

    size_t szl_max_key_len = cszrg_ecdh_public_key_len[ms_get_curve_name(adsp_connection->iec_selected_curve)];
    unsigned int unl_message_len = HT_RECORD_HDR_SIZE +
                                   ECDHE_KEYEX_HDR_LEN +
                                   2*SIGNAT_VECTOR_LEN +
                                   szl_max_key_len;

    unl_message_len += GetByteCntWLnum(adsp_connection->pLocalRsaStruc->Modul) + 1;
    
    unsigned char* abyl_data = (unsigned char*)BIT8_ARRAY_ALLOC_POOL(HMEM_CTX_REF,unl_message_len);

    // Write the ECDHE header
    abyl_data[HT_RECORD_HDR_SIZE] = ECDHE_NAME_CURVE_TYPE;
    abyl_data[HT_RECORD_HDR_SIZE+1] = (unsigned char)(adsp_connection->iec_selected_curve>>8);
    abyl_data[HT_RECORD_HDR_SIZE+2] = (unsigned char)adsp_connection->iec_selected_curve;

    // Generate the keys and write public key
    size_t szl_key_data_len = unl_message_len - (HT_RECORD_HDR_SIZE+ECDHE_KEYEX_HDR_LEN);

    ied_encry_return iel_ec_ret = m_ecc_gen_rand_keypair(&adsp_connection->dsc_ecc_keypair,
                                                         (char*)abyl_data+HT_RECORD_HDR_SIZE+ECDHE_KEYEX_HDR_LEN, 
                                                         &szl_key_data_len,
                                                         adsp_connection->adsc_mem_pool,
                                                         ms_rand_wrapper,
                                                         ms_get_mem_ptr(adsp_connection));

    if ( iel_ec_ret != ied_encry_success ) {
        FREE_ARRAY_POOL(HMEM_CTX_REF, abyl_data);
        return HSSL_INIT_ECC_KEY_GEN_ERR;
    }

    abyl_data[HT_RECORD_HDR_SIZE+3] = (unsigned char)szl_key_data_len;

    // Set return parameters
    *aachp_dest = (char*)abyl_data;
    *ainp_dest_len = (int)(unl_message_len - SIGNAT_VECTOR_LEN - szl_max_key_len + szl_key_data_len);
    *ainp_param_len = (int)(ECDHE_KEYEX_HDR_LEN + szl_key_data_len);
    return HSSL_OP_OK;
}

/**
* Subroutine GenerateServerKeyExchange generates server key exchange
* message from the connection structure parameters, updates
* Handshake Messages and enqueues Message for send to the priority queue (GenerateServerKeyExchange).
*
* Is only used for RSA Key exchange with non exportable
*       certificate key length or DHE key exchange.
*
*  @param pConnStruc Connection structure
*  @return HSSL_OP_OK on success, else error occured
*/
static  int  GenerateServerKeyExchange(CONNSTRU * pConnStruc)
{
  int Retcode;
  int KeyExchgMode;

  int BufLen = 0;
  int ParamLen;
  int TotalParamLen = 0;

  char* pDstBuf;
  char* abyl_temp_buf;
  
  int pTmpLen[1];

  RSA_STRUC* pRsaStruc = NULL;
  DH_STRUC* pDhStruc   = NULL;

  TX_QEL * pTxQel;

  HMEM_CTX_DEF1;

  LOAD_HMEM_CTX_PTR(CONN_pMemCtx(pConnStruc));

  //----------------------------------------------------
  // Allocate TX-Qel without buffer
  //----------------------------------------------------
  pTxQel = AllocInitTxQel(HMEM_CTX_REF1
			  0,(unsigned char) TX_TYPE_HANDSHAKE_MSG);
  if(pTxQel == NULL)
    return(HSSL_TX_QEL_ALLOC_ERR);
  //----------------------------------------------------
  // get type of parameters and signature to use
  //----------------------------------------------------
  KeyExchgMode = pConnStruc->KeyExchgMode;
  switch(KeyExchgMode)
  {
    //--------------------------------------------------
    // Generate temporary RSA key (with private portion!)
    //--------------------------------------------------
    case KEY_EXCHANGE_RSA:
      if(pConnStruc->ActualProtocol == TLS_V2_PROT_TYPE)
        return (HSSL_OP_OK);    // TLS 1.2 disallows Key exchange for RSA
      pConnStruc->LocalCertPublicAlgor = m_get_cert_pub_signature_tls(pConnStruc->abyc_remote_sig_algs,SIG_ALGOR_RSA);
      pRsaStruc = RSA_GenKey(HMEM_CTX_REF1 RSA_EXPORT_MAX_BITS,(int) RSA_DEFAULT_PUB_EXP,NULL);
      if(pRsaStruc == NULL)			// error occured
      {
        return(HSSL_GEN_SRKYEX_RSAKEYGEN_ERR);
      }
      pConnStruc->pTmpRsaStruc = pRsaStruc;	// save for key exchange
      //--------------------------------------------------
      // Get buffer for parameters and signature
      //--------------------------------------------------
      BufLen = HT_RECORD_HDR_SIZE + 
        (2* PARAM_VECTOR_LEN) +
        SIGNAT_VECTOR_LEN +
        GetByteCntWLnum(pRsaStruc->Modul) + 1 +
        GetByteCntWLnum(pRsaStruc->PubExp) + 1 +
        GetByteCntWLnum(pConnStruc->pLocalRsaStruc->Modul) + 1;

      pDstBuf = BIT8_ARRAY_ALLOC_POOL(HMEM_CTX_REF,BufLen);
      if(pDstBuf == NULL)
      {
        FREE_ARRAY(HMEM_CTX_REF,pTxQel);
        return(HSSL_GEN_SRKYEX_MSGBUF_ALLOC_ER);
      }
      //--------------------------------------------------
      // put parameters to buffer
      // The Modulus should not have leading zero !!
      //--------------------------------------------------
      pTmpLen[0] = BufLen - HT_RECORD_HDR_SIZE - PARAM_VECTOR_LEN;
      Retcode = WLnum_wlnum2bin(pDstBuf,HT_RECORD_HDR_SIZE+PARAM_VECTOR_LEN,pTmpLen,pRsaStruc->Modul,0);
      if(Retcode != LNUM_OP_OK)
      {
        FREE_ARRAY_POOL(HMEM_CTX_REF,pDstBuf);
        FREE_ARRAY(HMEM_CTX_REF,pTxQel);
        return(HSSL_GEN_SRKYEX_RSAPAR_STORE_ER);
      }
      ParamLen = pTmpLen[0];
      BIGword2charn(ParamLen,pDstBuf,HT_RECORD_HDR_SIZE);
      TotalParamLen = ParamLen + PARAM_VECTOR_LEN;

      pTmpLen[0] = BufLen - TotalParamLen -
		   HT_RECORD_HDR_SIZE - PARAM_VECTOR_LEN;
      Retcode = WLnum_wlnum2bin(pDstBuf,HT_RECORD_HDR_SIZE+PARAM_VECTOR_LEN+TotalParamLen,pTmpLen,pRsaStruc->PubExp,1);
      if(Retcode != LNUM_OP_OK)
      {
        FREE_ARRAY_POOL(HMEM_CTX_REF,pDstBuf);
        FREE_ARRAY(HMEM_CTX_REF,pTxQel);
        return(HSSL_GEN_SRKYEX_RSAPAR_STORE_ER);
      }
      ParamLen = pTmpLen[0];
      BIGword2charn(ParamLen,pDstBuf,HT_RECORD_HDR_SIZE+TotalParamLen);
      TotalParamLen += ParamLen + PARAM_VECTOR_LEN;
      break;
    //--------------------------------------------------
    // Generate temporary DH key (with private portion!)
    //--------------------------------------------------
    case KEY_EXCHANGE_DHE_RSA:
    case KEY_EXCHANGE_DHE_DSS:
        // We generate a DH instance with named group ffdhe2048
        pDhStruc = m_dh_gen_named_group(HMEM_CTX_REF1 ied_dh_group_tls_ffdhe2048);
        if(pDhStruc == NULL){
            FREE_ARRAY(HMEM_CTX_REF,pTxQel);
            return(HSSL_GEN_SRKYEX_DH_KEY_GEN_ERR);
        }
      pConnStruc->pLocalDhStruc = pDhStruc;	// save for key exchange

						// generate public value
      Retcode = DH_GenKey(HMEM_CTX_REF1 pDhStruc,NULL);
      if(Retcode != DH_OP_OK)
      {
        FREE_ARRAY(HMEM_CTX_REF,pTxQel);
        return(HSSL_GEN_SRKYEX_DH_KEY_GEN_ERR);
      }
      //--------------------------------------------------
      // Get buffer for parameters and signature
      //--------------------------------------------------
      BufLen = HT_RECORD_HDR_SIZE + 
       (3* PARAM_VECTOR_LEN) +
       SIGNAT_VECTOR_LEN +
       GetByteCntWLnum(pDhStruc->p) + 1 +
       GetByteCntWLnum(pDhStruc->g)    + 1 +
       GetByteCntWLnum(pDhStruc->PubKey)  + 1;

      if(pConnStruc->pLocalRsaStruc != NULL)
        BufLen += GetByteCntWLnum(pConnStruc->pLocalRsaStruc->Modul) + 1;
      else
        BufLen += DSA_SignatMaxLen(pConnStruc->pLocalDsaStruc) +1;

      pDstBuf = BIT8_ARRAY_ALLOC_POOL(HMEM_CTX_REF,BufLen);
      if(pDstBuf == NULL)
      {
        FREE_ARRAY(HMEM_CTX_REF,pTxQel);
        return(HSSL_GEN_SRKYEX_MSGBUF_ALLOC_ER);
      }
      //--------------------------------------------------
      // put parameters to buffer
      // 1. Do NOT prepend leading zero for p,g,Ys !
      // ----- 2. Assure that length of Ys is same as p !
      //--------------------------------------------------
      pTmpLen[0] = BufLen - HT_RECORD_HDR_SIZE - PARAM_VECTOR_LEN;
      Retcode = WLnum_wlnum2bin(pDstBuf,HT_RECORD_HDR_SIZE+PARAM_VECTOR_LEN,pTmpLen,pDhStruc->p,0);
      if(Retcode != LNUM_OP_OK)
      {
        FREE_ARRAY_POOL(HMEM_CTX_REF,pDstBuf);
        FREE_ARRAY(HMEM_CTX_REF,pTxQel);
        return(HSSL_GEN_SRKYEX_DHPAR_STORE_ERR);
      }
      ParamLen = pTmpLen[0];
      BIGword2charn(ParamLen,pDstBuf,HT_RECORD_HDR_SIZE);
      TotalParamLen = ParamLen + PARAM_VECTOR_LEN;

      pTmpLen[0] = BufLen - TotalParamLen -
		   HT_RECORD_HDR_SIZE - PARAM_VECTOR_LEN;
      Retcode = WLnum_wlnum2bin(pDstBuf,HT_RECORD_HDR_SIZE+PARAM_VECTOR_LEN+TotalParamLen,pTmpLen,pDhStruc->g,0);
      if(Retcode != LNUM_OP_OK)
      {
        FREE_ARRAY_POOL(HMEM_CTX_REF,pDstBuf);
        FREE_ARRAY(HMEM_CTX_REF,pTxQel);
        return(HSSL_GEN_SRKYEX_DHPAR_STORE_ERR);
      }
      ParamLen = pTmpLen[0];
      BIGword2charn(ParamLen,pDstBuf,HT_RECORD_HDR_SIZE+TotalParamLen);
      TotalParamLen += ParamLen + PARAM_VECTOR_LEN;

      pTmpLen[0] = BufLen - TotalParamLen -
		   HT_RECORD_HDR_SIZE - PARAM_VECTOR_LEN;

      Retcode = WLnum_wlnum2binFill(pDstBuf,HT_RECORD_HDR_SIZE+PARAM_VECTOR_LEN+TotalParamLen,pTmpLen,pDhStruc->PubKey,GetByteCntWLnum(pDhStruc->PubKey));

      if(Retcode != LNUM_OP_OK)
      {
        FREE_ARRAY_POOL(HMEM_CTX_REF,pDstBuf);
        FREE_ARRAY(HMEM_CTX_REF,pTxQel);
        return(HSSL_GEN_SRKYEX_DHPAR_STORE_ERR);
      }
      ParamLen = pTmpLen[0];

      BIGword2charn(ParamLen,pDstBuf,HT_RECORD_HDR_SIZE+TotalParamLen);
      TotalParamLen += ParamLen + PARAM_VECTOR_LEN;
      break;

   case KEY_EXCHANGE_ECDHE_RSA:
       Retcode = ms_gen_ecc_srv_exchange(&pDstBuf,
                                         &BufLen,
                                         &TotalParamLen,
                                         pConnStruc);
       if(Retcode != HSSL_OP_OK)
       {
           FREE_ARRAY(HMEM_CTX_REF,pTxQel);
           return Retcode;
       }
       break;

   case KEY_EXCHANGE_SRP:
      Retcode = m_gen_srp_srv_key_pair(pConnStruc);
      if(Retcode != LNUM_OP_OK)
      {
        FREE_ARRAY(HMEM_CTX_REF,pTxQel);
        return(HSSL_GEN_SRKYEX_SRP_ERR);
      }
      BufLen = HT_RECORD_HDR_SIZE + 
        (3* PARAM_VECTOR_LEN) + 1 +
        GetByteCntWLnum(pConnStruc->adsc_srp_params[0].adsc_srv_pub_key) +
        GetByteCntWLnum(pConnStruc->adsc_srp_params[0].adsc_g) +
        GetByteCntWLnum(pConnStruc->adsc_srp_params[0].adsc_n) +
        pConnStruc->adsc_srp_params[0].inc_salt_len;
      pDstBuf = BIT8_ARRAY_ALLOC_POOL(HMEM_CTX_REF,BufLen);
      if(pDstBuf == NULL)
      {
        FREE_ARRAY(HMEM_CTX_REF,pTxQel);
        return(HSSL_GEN_SRKYEX_SRP_ERR);
      }
      
      TotalParamLen = m_write_srp_server_key(pConnStruc, pDstBuf, HT_RECORD_HDR_SIZE,
         BufLen-HT_RECORD_HDR_SIZE);
      if ( 0 > TotalParamLen)
      {
         FREE_ARRAY_POOL(HMEM_CTX_REF,pDstBuf);
         FREE_ARRAY(HMEM_CTX_REF,pTxQel);
         return(HSSL_GEN_SRKYEX_SRP_ERR);
      }
      break;
    default:
      return(HSSL_GEN_SRKYEX_INV_KEYEX_MODE);		// should not happen
  } // switch
  //--------------------------------------------------
  // Generate signature, either RSA or DSS, unless it's SRP
  //--------------------------------------------------
  if( KEY_EXCHANGE_SRP != KeyExchgMode) {
     pTmpLen[0] = BufLen - HT_RECORD_HDR_SIZE - SIGNAT_VECTOR_LEN -
        TotalParamLen;
     abyl_temp_buf = BIT8_ARRAY_ALLOC_POOL(HMEM_CTX_REF,TotalParamLen+
        CLIENT_HELLO_RANDOM_LEN+SERVER_HELLO_RANDOM_LEN);
     memcpy(abyl_temp_buf+0,pConnStruc->ClientRandom+0,CLIENT_HELLO_RANDOM_LEN);
     memcpy(abyl_temp_buf+CLIENT_HELLO_RANDOM_LEN,pConnStruc->ServerRandom+0,SERVER_HELLO_RANDOM_LEN);
     memcpy(abyl_temp_buf+CLIENT_HELLO_RANDOM_LEN+SERVER_HELLO_RANDOM_LEN,pDstBuf+HT_RECORD_HDR_SIZE,TotalParamLen);
     Retcode = m_generate_digitally_signed(pConnStruc, abyl_temp_buf, 0, 
        TotalParamLen+CLIENT_HELLO_RANDOM_LEN+SERVER_HELLO_RANDOM_LEN,
        pDstBuf,HT_RECORD_HDR_SIZE+TotalParamLen,
        pTmpLen);
     FREE_ARRAY_POOL(HMEM_CTX_REF,abyl_temp_buf);
     if(Retcode != HSSL_OP_OK)
     {
        FREE_ARRAY(HMEM_CTX_REF,pTxQel);
        FREE_ARRAY_POOL(HMEM_CTX_REF,pDstBuf);
        return Retcode;
     }
     ParamLen = pTmpLen[0];
     TotalParamLen += ParamLen;
  }
  //--------------------------------------------------
  // Generate the message header
  //--------------------------------------------------
  BIGlong2charn((int) TotalParamLen, pDstBuf,0);	// convert
  pDstBuf[0] = HT_SERVER_KEY_EXCHANGE;  
  TotalParamLen += HT_RECORD_HDR_SIZE;

  pTxQel->pBuf    = pDstBuf;
  pTxQel->DataLen = (int) TotalParamLen;
  //----------------------------------------------------
  // Update Handshake Hashes
  //----------------------------------------------------
  HashHandshakeMessage(pConnStruc,pDstBuf,0, TotalParamLen);
  //----------------------------------------------------
  // Enqueue TX-Quel for send
  //----------------------------------------------------
  EnqueueTxQel(pConnStruc,pTxQel);
  return(HSSL_OP_OK);
}

static int ms_process_ecdhe_se_key_ex(int* ainp_total_param_len,
                                      CONNSTRU* adsp_connection,
                                      const unsigned char* abyp_data,
                                      size_t szp_data_len)
{
    if((abyp_data[0] != 0x03) ||
       (abyp_data[1] != 0) ||
       (abyp_data[2] < ied_ec_curve_secp256k1) ||
       (abyp_data[2] > ied_ec_curve_brainpoolP512r1) ||
       (((size_t)abyp_data[3]+4) > szp_data_len))
    {
        return HSSL_SRVR_KEYEXC_INVALID_EC_PARAMS;
    }

    // Prepare the keypair for generating the secret
    adsp_connection->iec_selected_curve = (enum ied_ec_curve_id)abyp_data[2];

    int inl_ret = ms_init_ecc(adsp_connection);

    if (inl_ret != HSSL_OP_OK) {
        return inl_ret;
    }

    ied_encry_return iel_encry_ret = m_ecc_gen_rand_keypair(&adsp_connection->dsc_ecc_keypair,
                                                            NULL,
                                                            NULL,
                                                            adsp_connection->adsc_mem_pool,
                                                            ms_rand_wrapper,
                                                            ms_get_mem_ptr(adsp_connection));

    if(iel_encry_ret != ied_encry_success){
        return HSSL_SRVR_KEYEXC_EC_INTERNAL_ERR;
    }

    *ainp_total_param_len = (int)abyp_data[3]+ECDHE_KEYEX_HDR_LEN;

    // Processing the actual data is like in client key exchange
    return ms_process_ecdhe_cl_key_ex(adsp_connection, abyp_data+3, abyp_data[3]+1);
}

/**
* Subroutine ProcessServerKeyExchange checks server key exchange
* message for correct length and parameters, extracts parameters (ProcessServerKeyExchange).
*
*  @param pConnStruc Connection structure
*  @param InpBuf Buffer Base
*  @param InpOffset Start of data
*  @param DataLen data count
*  @param pAlertType type of Alert on Error
*  @param pAlertLvl level of Alert on Error
*
*  @return HSSL_OP_OK on success, else error occured
*/
static  int  ProcessServerKeyExchange(CONNSTRU * pConnStruc,
		   char* InpBuf, int InpOffset, int DataLen,
		   int* pAlertType, int* pAlertLvl)
{
  int Retcode;
  int TotalLen;
  int InpIndex = InpOffset;
  int Index = 0;

  int Param1Len = 0;
  int Param2Len = 0;
  int Param3Len = 0;
  int TotalParamLen = 0;

  int KeyExchgMode;

  int MsgLen;

  char* pBuf = NULL;

  RSA_STRUC* pRsaStruc = NULL;
  DH_STRUC* pDhStruc   = NULL;
 
  HMEM_CTX_DEF1;
  LOAD_HMEM_CTX_PTR(CONN_pMemCtx(pConnStruc));
 
  //-------------------------------------------------------
  // Preset Alert Type and Level to Illegal parameter/Fatal
  //-------------------------------------------------------
  pAlertType[0] = AD_ILLEGAL_PARAMETER;
  pAlertLvl[0]  = ALERT_LEVEL_FATAL;
  //----------------------------------------------------
  // Calculate minimal required length
  //----------------------------------------------------
  TotalLen = (2*PARAM_VECTOR_LEN) + SIGNAT_VECTOR_LEN;
  //----------------------------------------------------
  // check Server Key Exchange Message length
  //----------------------------------------------------
  BIGchar2long(InpBuf,MsgLen,InpIndex);		// from 1st 4 bytes
  MsgLen &= 0xFFFFFF;				// only 3 bytes valid
  DataLen  -= HT_RECORD_HDR_SIZE;		// reduce length

  if((MsgLen != (int) DataLen) ||
     (MsgLen < TotalLen)) 
  {
    return(HSSL_SRVR_KEYEXC_INVALID_MSGLEN);	// inconsistent data size
  }
  pConnStruc->CertifiedFlags |= SERVER_KEY_EXCHG_REQ_MASK;
  //----------------------------------------------------
  // get type of parameters and signature to use
  //----------------------------------------------------
  KeyExchgMode = pConnStruc->KeyExchgMode;
  switch(KeyExchgMode)
  {
    //-------------------------------------------------------
    // Temporary RSA key
    //-------------------------------------------------------
    case KEY_EXCHANGE_RSA:
      if(pConnStruc->ActualProtocol != SSL_PROT_TYPE){   // only SSLv3 allows this msg for RSA
         pAlertType[0] = AD_UNEXPECTED_MSG;
         return HSSL_SRVR_KEYEXC_INVALID_MSG;
      }
      pConnStruc->RemoteCertPublicAlgor = SIG_ALGOR_RSA;
      //-----------------------------------------------------
      // get parameter length for Modulus and Public Exponent
      //-----------------------------------------------------
      BIGchar2wordn(InpBuf,Param1Len,InpIndex);	// get modulus length
      DataLen -= PARAM_VECTOR_LEN;
      if(Param1Len > DataLen)
      {
        return(HSSL_SRVR_KEYEXC_INVALID_MSGLEN);// inconsistent data size
      }
      DataLen -= Param1Len;
      TotalParamLen = Param1Len + PARAM_VECTOR_LEN;

      if(DataLen < PARAM_VECTOR_LEN)
      {
        return(HSSL_SRVR_KEYEXC_INVALID_MSGLEN);// inconsistent data size
      }

      BIGchar2wordn(InpBuf,Param2Len,InpIndex + TotalParamLen);	// exponent len
      DataLen -= PARAM_VECTOR_LEN;
      if(Param2Len > DataLen)
      {
        return(HSSL_SRVR_KEYEXC_INVALID_MSGLEN); // inconsistent data size
      }
      DataLen -= Param2Len;
      TotalParamLen += Param2Len + PARAM_VECTOR_LEN;
      //-----------------------------------------------------
      // Allocate the local temporary RSA structure
      //-----------------------------------------------------
      pRsaStruc = RSA_New(HMEM_CTX_REF1 (Param1Len + WELEMENT_SIZE-1) / WELEMENT_SIZE,(Param2Len + WELEMENT_SIZE-1) / WELEMENT_SIZE,0,0,0);
      if(pRsaStruc == NULL)
      {
        pAlertType[0] = AD_INTERNAL_ERROR;
        return(HSSL_SRVR_KEYEXC_RSA_ALLOC_ERR);
      }
      //-----------------------------------------------------
      // Load the parameters into the RSA structure
      //-----------------------------------------------------
      Retcode = WLnum_bin2wlnum(HMEM_CTX_REF1 pRsaStruc->Modul,InpBuf,InpIndex+PARAM_VECTOR_LEN,Param1Len);
      if(Retcode != LNUM_OP_OK)
      {
        RSA_Free(HMEM_CTX_REF1 pRsaStruc);    
        pAlertType[0] = AD_INTERNAL_ERROR;
        return(HSSL_SRVR_KEYEXC_RSAPAR_LOADERR);
      }
      Retcode = WLnum_bin2wlnum(HMEM_CTX_REF1 pRsaStruc->PubExp,InpBuf,InpIndex+(2*PARAM_VECTOR_LEN)+ Param1Len,Param2Len);
      if(Retcode != LNUM_OP_OK)
      {
        RSA_Free(HMEM_CTX_REF1 pRsaStruc);    
        pAlertType[0] = AD_INTERNAL_ERROR;
        return(HSSL_SRVR_KEYEXC_RSAPAR_LOADERR);
      }
      break;
    //-------------------------------------------------------
    // Temporary DH key
    //-------------------------------------------------------
    case KEY_EXCHANGE_DHE_RSA:
    case KEY_EXCHANGE_DHE_DSS:
      if(KeyExchgMode == KEY_EXCHANGE_DHE_RSA)
        pConnStruc->RemoteCertPublicAlgor = SIG_ALGOR_RSA;
      else
        pConnStruc->RemoteCertPublicAlgor = SIG_ALGOR_DSA;
      //--------------------------------------------------------
      // get parameter length for Prime P, Base and Public Value
      //--------------------------------------------------------
      BIGchar2wordn(InpBuf,Param1Len,InpIndex);	// get Prime p length
      DataLen -= PARAM_VECTOR_LEN;
      if(Param1Len > DataLen)
      {
        return(HSSL_SRVR_KEYEXC_INVALID_MSGLEN);// inconsistent data size
      }
      DataLen -= Param1Len;
      TotalParamLen = Param1Len + PARAM_VECTOR_LEN;

      if(DataLen < PARAM_VECTOR_LEN)
      {
        return(HSSL_SRVR_KEYEXC_INVALID_MSGLEN);// inconsistent data size
      }
      BIGchar2wordn(InpBuf,Param2Len,InpIndex + TotalParamLen);//get Base len.
      DataLen -= PARAM_VECTOR_LEN;
      if(Param2Len > DataLen)
      {
        return(HSSL_SRVR_KEYEXC_INVALID_MSGLEN);// inconsistent data size
      }
      DataLen -= Param2Len;
      TotalParamLen += Param2Len + PARAM_VECTOR_LEN;

      if(DataLen < PARAM_VECTOR_LEN)
      {
        return(HSSL_SRVR_KEYEXC_INVALID_MSGLEN);// inconsistent data size
      }
      BIGchar2wordn(InpBuf,Param3Len,InpIndex + TotalParamLen);//get public len
      DataLen -= PARAM_VECTOR_LEN;
      if(Param3Len > DataLen)
      {
        return(HSSL_SRVR_KEYEXC_INVALID_MSGLEN);// inconsistent data size
      }
      DataLen -= Param3Len;
      TotalParamLen += Param3Len + PARAM_VECTOR_LEN;
      //-----------------------------------------------------
      // Allocate the local temporary DH structure
      //-----------------------------------------------------
      pDhStruc = DH_New(HMEM_CTX_REF1 (Param1Len + WELEMENT_SIZE-1) / WELEMENT_SIZE,0,(Param2Len + WELEMENT_SIZE-1) / WELEMENT_SIZE,(Param3Len + WELEMENT_SIZE-1) / WELEMENT_SIZE,0);
      if(pDhStruc == NULL)
      {
        pAlertType[0] = AD_INTERNAL_ERROR;
        return(HSSL_SRVR_KEYEXC_DH_ALLOC_ERR);
      }
      //-----------------------------------------------------
      // Load the parameters into the DH structure
      //-----------------------------------------------------
      Retcode = WLnum_bin2wlnum(HMEM_CTX_REF1 pDhStruc->p,InpBuf,InpIndex+PARAM_VECTOR_LEN,Param1Len);
      if(Retcode != LNUM_OP_OK)
      {
        DH_Free(HMEM_CTX_REF1 pDhStruc);    
        pAlertType[0] = AD_INTERNAL_ERROR;
        return(HSSL_SRVR_KEYEXC_DHPAR_LOAD_ERR);
      }
      Retcode = WLnum_bin2wlnum(HMEM_CTX_REF1 pDhStruc->g,InpBuf,InpIndex+(2*PARAM_VECTOR_LEN)+ Param1Len,Param2Len);
      if(Retcode != LNUM_OP_OK)
      {
        DH_Free(HMEM_CTX_REF1 pDhStruc);    
        pAlertType[0] = AD_INTERNAL_ERROR;
        return(HSSL_SRVR_KEYEXC_DHPAR_LOAD_ERR);
      }
      Retcode = WLnum_bin2wlnum(HMEM_CTX_REF1 pDhStruc->PubKey,InpBuf,InpIndex+(3*PARAM_VECTOR_LEN)+ Param1Len+Param2Len,Param3Len);
      if(Retcode != LNUM_OP_OK)
      {
        DH_Free(HMEM_CTX_REF1 pDhStruc);    
        pAlertType[0] = AD_INTERNAL_ERROR;
        return(HSSL_SRVR_KEYEXC_DHPAR_LOAD_ERR);
      }

      // We validate the DH group to prevent logjam attack
      if( ! m_dh_group_is_safe(pDhStruc, DH_MIN_P_BITS))
      {
        DH_Free(HMEM_CTX_REF1 pDhStruc);    
        pAlertType[0] = AD_HSHAKE_FAILURE;
        return(HSSL_SRVR_KEYEXC_DH_PARAM_INSECURE);
      }
      break;
    case KEY_EXCHANGE_ECDHE_RSA:
        Retcode = ms_process_ecdhe_se_key_ex(&TotalParamLen,
                                             pConnStruc,
                                             (unsigned char*)InpBuf+InpIndex,
                                             DataLen);
        if(Retcode != HSSL_OP_OK)
        {
            pAlertType[0] = AD_INTERNAL_ERROR;
            return Retcode;
        }
        DataLen -= TotalParamLen;
        break;
    case KEY_EXCHANGE_SRP:
       Retcode = m_process_srp_srv_exch_params(HMEM_CTX_REF1 InpBuf, InpIndex,
          DataLen, pConnStruc);
       if( HSSL_OP_OK != Retcode ){
          // Set allert type according to what error happend
          switch(Retcode){
          case HSSL_ALERT_MSG_INSUFF_SECURITY:
             pAlertType[0] = AD_INSUFF_SECURITY;
             break;
          case HSSL_PARAM_ERR:
             pAlertType[0] = AD_ILLEGAL_PARAMETER;
             break;
          default:
             pAlertType[0] = AD_INTERNAL_ERROR;
             break;
          }
          return Retcode;
       }
       break;
    default:
      pAlertType[0] = AD_INTERNAL_ERROR;
      return(HSSL_SRVR_KEYEXC_INV_KEYEX_MODE);	// should not happen
  }
  //----------------------------------------------------
  // verify the signature, get length of signature (not in SRP)
  //----------------------------------------------------
  if ( KEY_EXCHANGE_SRP != KeyExchgMode ){
  Index = InpIndex+TotalParamLen;
  if(pConnStruc->ActualProtocol == TLS_V2_PROT_TYPE){ // Extract Sig type
    BIGchar2word(InpBuf,pConnStruc->RemoteCertPublicAlgor,Index);
    DataLen-=2;
  }
  if(DataLen < SIGNAT_VECTOR_LEN)
  {
    RSA_Free(HMEM_CTX_REF1 pRsaStruc);
    DH_Free(HMEM_CTX_REF1 pDhStruc);
    return(HSSL_SRVR_KEYEXC_INVALID_MSGLEN);	// inconsistent data size
  }
  BIGchar2word(InpBuf,Param1Len,Index); // get signat length
  DataLen -= SIGNAT_VECTOR_LEN;
  if(Param1Len != DataLen)			// inconsistent
  {
    RSA_Free(HMEM_CTX_REF1 pRsaStruc);
    DH_Free(HMEM_CTX_REF1 pDhStruc);
    return(HSSL_SRVR_KEYEXC_INVALID_MSGLEN);	// inconsistent data size
  }
  pBuf = BIT8_ARRAY_ALLOC_POOL(HMEM_CTX_REF,TotalParamLen+
        CLIENT_HELLO_RANDOM_LEN+SERVER_HELLO_RANDOM_LEN);
  memcpy(pBuf+0,pConnStruc->ClientRandom+0,CLIENT_HELLO_RANDOM_LEN);
  memcpy(pBuf+CLIENT_HELLO_RANDOM_LEN,pConnStruc->ServerRandom+0,SERVER_HELLO_RANDOM_LEN);
  memcpy(pBuf+CLIENT_HELLO_RANDOM_LEN+SERVER_HELLO_RANDOM_LEN,InpBuf+InpIndex,TotalParamLen);
  Retcode = m_verify_digitally_signed ( pConnStruc, pBuf, 0, 
        CLIENT_HELLO_RANDOM_LEN+SERVER_HELLO_RANDOM_LEN+TotalParamLen, InpBuf, 
        Index, DataLen);
  FREE_ARRAY_POOL(HMEM_CTX_REF, pBuf);
  if( Retcode != HSSL_OP_OK ){
    pAlertType[0] = AD_HSHAKE_FAILURE;
    RSA_Free(HMEM_CTX_REF1 pRsaStruc);
    DH_Free(HMEM_CTX_REF1 pDhStruc);
    return Retcode;
  }
  }
  //-----------------------------------------------
  // Save the temporary values
  //-----------------------------------------------
  if(KeyExchgMode == KEY_EXCHANGE_RSA){
    pConnStruc->pTmpRsaStruc = pRsaStruc; 
  } else if( KEY_EXCHANGE_SRP != KeyExchgMode ){
    pConnStruc->pRemoteDhStruc = pDhStruc; 
  }
  return(HSSL_OP_OK);
}

/**
* Generates client certificate
* verify message from the connection structure parameters, updates 
* Handshake Messages and enqueues Message for send to the priority queue
* (GenerateCertificateVerify).
*
* Is only used when server requested client certificate
*       and client sent either RSA or DSS certificate.
*
*  @param pConnStruc Connection structure
*  @return HSSL_OP_OK on success, else error occured
*/
static  int  GenerateCertificateVerify(CONNSTRU * pConnStruc)
{
  int Retcode;
  int BufLen;
  int CNIndex;
  int Index;
  int PublicAlgor;
  int MAClen;
  
  int TotalLen;

  char* pDstBuf;
  int* pCNArray;

  int pTmpLen[1];

  char MacData[RSA_DEF_SHA2_SIGN_HDR_LEN+SHA512_DIGEST_LEN];

  X509CERT * pCert;
  X509CERT ** pCertList;
  CTREESTR * pCertTreeStruc;

  RSA_STRUC* pTmpRsaStruc[1] = {NULL};
  DSA_STRUC* pTmpDsaStruc[1] = {NULL};
  CFG_STRU * pCfgStruc;
  IDATA* pIdata;

  TX_QEL * pTxQel;

  HMEM_CTX_DEF1;
  LOAD_HMEM_CTX_PTR(CONN_pMemCtx(pConnStruc));

  //----------------------------------------------------
  // Allocate TX-Qel without buffer
  //----------------------------------------------------
  pTxQel = AllocInitTxQel(HMEM_CTX_REF1
			  0,(unsigned char) TX_TYPE_HANDSHAKE_MSG);
  if(pTxQel == NULL)
    return(HSSL_TX_QEL_ALLOC_ERR);
  //------------------------------------------------------
  // get the propper data block (Hashes or PKCS encodes hashes)
  // MAClen is the actual length for RSA signing, which can varry
  //------------------------------------------------------
  GenerateCertVerifyHashes(pConnStruc,MacData,0,pConnStruc->LocalCertPublicAlgor);
  if(pConnStruc->ActualProtocol == TLS_V2_PROT_TYPE){
    switch(pConnStruc->LocalCertPublicAlgor >>8){
        case HASH_ALGOR_MD5:
            MAClen = RSA_DEF_MD_SIGN_HDR_LEN+MD5_DIGEST_LEN;
            break;
        case HASH_ALGOR_SHA1:
            MAClen = RSA_DEF_SHA_SIGN_HDR_LEN+SHA_DIGEST_LEN;
            break;
        case HASH_ALGOR_SHA256:
            MAClen = RSA_DEF_SHA2_SIGN_HDR_LEN+SHA256_DIGEST_LEN;
            break;
        case HASH_ALGOR_SHA384:
            MAClen = RSA_DEF_SHA2_SIGN_HDR_LEN+SHA384_DIGEST_LEN;
            break;
        case HASH_ALGOR_SHA512:
            MAClen = RSA_DEF_SHA2_SIGN_HDR_LEN+SHA512_DIGEST_LEN;
            break;
        default:
           return HSSL_CERTVFY_INV_SIGNAT_ALGOR;
    }
  } else {
    MAClen = MD5_DIGEST_LEN+SHA_DIGEST_LEN;
  }
  //---------------------------------------------------------
  // get the private keys and the public algor from the
  // End-Cert
  //---------------------------------------------------------
  pCfgStruc = pConnStruc->pCfgStruc;

  //---------------------------------------------------------
  // First check if a PKCS11 certificate was used before
  //---------------------------------------------------------
#if (defined _WIN32) && defined PKCS11
  if(pConnStruc->in_p11certid != 0)
  {
    Retcode = m_pkcs11certsign(HMEM_CTX_REF1 pConnStruc,
			       MacData,MD5_DIGEST_LEN+SHA_DIGEST_LEN,
			       HT_RECORD_HDR_SIZE+SIGNAT_VECTOR_LEN,
			       HT_RECORD_HDR_SIZE+SIGNAT_VECTOR_LEN,
			       &pDstBuf,pTmpLen);
    if(Retcode != 0)
    {
      FREE_ARRAY(HMEM_CTX_REF,pTxQel);
      return(Retcode);
    }
  }
  else
  {
#endif // defined _WIN32
  pCertTreeStruc = pCfgStruc->pCertTreeStruc;
  CNIndex = pConnStruc->LocalCNIndex;	// get Certificate Index
  pCNArray = pCertTreeStruc->CNodeArray;		// get array
  pCertList = pCertTreeStruc->ppCertList;		// get list
  Index = pCNArray[CNIndex + CN_CERTLIST_INDEX]; // Cert Index
  pCert = pCertList[Index];			// Cert Structure pointer
  PublicAlgor = pCert->PublicKeyType;

  switch(PublicAlgor)
  {
    case RSA_PUBLIC_ALGOR:
      if((pCfgStruc->ExtCertsFlags & EXTCERT_STORE_USED_BIT) != 0)
        Retcode = FromArrayDescToRSAPubParams(HMEM_CTX_REF1 pCert->SubjPubKeyParVal,pTmpRsaStruc);
      else
        Retcode = FromArrayDescToRSAPrivParams(HMEM_CTX_REF1 pCert->PrivKeyData,pTmpRsaStruc);
      pConnStruc->pLocalRsaStruc       = pTmpRsaStruc[0];
      break;

    case DSA_PUBLIC_ALGOR:
      if((pCfgStruc->ExtCertsFlags & EXTCERT_STORE_USED_BIT) != 0)
        Retcode = FromArrayDescToDSAPubParams(HMEM_CTX_REF1 pCert->SubjPubKeyParVal,pTmpDsaStruc);
      else
        Retcode = FromArrayDescToDSAPrivParams(HMEM_CTX_REF1 pCert->PrivKeyData,pTmpDsaStruc);
      pConnStruc->pLocalDsaStruc       = pTmpDsaStruc[0];
      break;

    default:
      Retcode = HSSL_GEN_CERTVFY_INV_PUBLIC_ALG;
      break;
  }
  if(Retcode != ASN1_OP_OK)
  {
    FREE_ARRAY(HMEM_CTX_REF,pTxQel);
    return(HSSL_GEN_CERTVFY_TO_PRIVPAR_ERR);
  }
  //----------------------------------------------------
  // distribute by public algor of local certificate
  //----------------------------------------------------
  BufLen = (HT_RECORD_HDR_SIZE + SIGNAT_VECTOR_LEN);
  if(pConnStruc->ActualProtocol == TLS_V2_PROT_TYPE) {
    BufLen += 2;
    Index = HT_RECORD_HDR_SIZE+SIGNAT_VECTOR_LEN+2;
  } else {
    Index = HT_RECORD_HDR_SIZE+SIGNAT_VECTOR_LEN;
  }
  switch(PublicAlgor)
  {
    //-----------------------------------------------------
    // RSA, allocate buffer, private encrypt MAC-Data
    // Result must NOT contain leading Zero! (mozilla)
    //-----------------------------------------------------
    case RSA_PUBLIC_ALGOR:
      BufLen += RSA_Size(pConnStruc->pLocalRsaStruc) + 1;
      pDstBuf = BIT8_ARRAY_ALLOC_POOL(HMEM_CTX_REF,BufLen);
      if(pDstBuf == NULL)
      {
        FREE_ARRAY(HMEM_CTX_REF,pTxQel);
        return(HSSL_GEN_CERTVFY_MSGBUF_ALLOCER);
      }
      pTmpLen[0] = BufLen;

      if((pCfgStruc->ExtCertsFlags & EXTCERT_STORE_USED_BIT) != 0)
      {
        pIdata = pCert->Certificate->ppArr[0];
        Retcode = HSSL_GenSignatWithExtPrivKey(HMEM_CTX_REF1 
                                               pCfgStruc->pExtCertStruc,
                                               MacData,
                                               0,
                                               MAClen,
                                               pDstBuf,
                                               Index,
                                               pTmpLen,
                                               pIdata->Base,
                                               (int) pIdata->Off,
                                               pIdata->Len,
                                               RSA_PUBLIC_ALGOR,
                                               SIGDAPVKEY_HASHTY_SSL,
                                               0);			// no laeding zero !!
      }
      else // from CDB
      {
        Retcode = RSA_PrivateEncryptEx(HMEM_CTX_REF1 MacData,MAClen,pDstBuf,Index,pTmpLen,pConnStruc->pLocalRsaStruc,-1); 
            // no leading zero!
      }
      if(Retcode != RSA_OP_OK)
      {
        FREE_ARRAY(HMEM_CTX_REF,pTxQel);
        FREE_ARRAY_POOL(HMEM_CTX_REF,pDstBuf);
        return(HSSL_GEN_CERTVFY_SIG_RSAENC_ERR);
      }
      break;
    //-----------------------------------------------------
    // DSA, allocate buffer, generate DSS signature
    //-----------------------------------------------------
    case DSA_PUBLIC_ALGOR:
      BufLen += DSA_SignatMaxLen(pConnStruc->pLocalDsaStruc);
      pDstBuf = BIT8_ARRAY_ALLOC_POOL(HMEM_CTX_REF,BufLen);
      if(pDstBuf == NULL)
      {
        FREE_ARRAY(HMEM_CTX_REF,pTxQel);
        return(HSSL_GEN_CERTVFY_MSGBUF_ALLOCER);
      }
      pTmpLen[0] = BufLen;

      if((pCfgStruc->ExtCertsFlags & EXTCERT_STORE_USED_BIT) != 0)
      {
        pIdata = pCert->Certificate->ppArr[0];
        Retcode = HSSL_GenSignatWithExtPrivKey(HMEM_CTX_REF1 
                                               pCfgStruc->pExtCertStruc,
                                               MacData,
                                               MD5_DIGEST_LEN,
                                               SHA_DIGEST_LEN,
                                               pDstBuf,
                                               Index,
                                               pTmpLen,
                                               pIdata->Base,
                                               (int) pIdata->Off,
                                               pIdata->Len,
                                               DSA_PUBLIC_ALGOR,
                                               SIGDAPVKEY_HASHTY_SHA | SIGDAPVKEY_ASN1_ENCOP,
                                               1);
      }
      else // from CDB
      {
        Retcode = DSA_Sign(HMEM_CTX_REF1 MacData,MD5_DIGEST_LEN,0,pDstBuf,Index,pTmpLen,pConnStruc->pLocalDsaStruc,NULL,1);
      }
      if(Retcode != DSA_OP_OK)
      {
        FREE_ARRAY(HMEM_CTX_REF,pTxQel);
        FREE_ARRAY_POOL(HMEM_CTX_REF,pDstBuf);
        return(HSSL_GEN_CERTVFY_DSASIG_GEN_ERR);
      }
      break;

    default:
      FREE_ARRAY(HMEM_CTX_REF,pTxQel);
      return(HSSL_GEN_CERTVFY_INV_SIGNAT_ALG);
  }
#if (defined _WIN32) && defined PKCS11
  }
#endif // defined _WIN32
  //----------------------------------------------------
  // Format the message header
  //----------------------------------------------------
  Index = HT_RECORD_HDR_SIZE;
  if(pConnStruc->ActualProtocol == TLS_V2_PROT_TYPE) {
    BIGword2char(pConnStruc->LocalCertPublicAlgor,pDstBuf,Index);
  }
  TotalLen = (int) pTmpLen[0] & 0xFFFF;
  BIGword2charn(TotalLen,pDstBuf,Index); // set vector length
  TotalLen += SIGNAT_VECTOR_LEN;
  if(pConnStruc->ActualProtocol == TLS_V2_PROT_TYPE) {
    TotalLen += 2;
  }
  BIGlong2charn(TotalLen,pDstBuf,0);		// generate length
  pDstBuf[0] = HT_CERTIFICATE_VERIFY;		// set message type
  TotalLen += HT_RECORD_HDR_SIZE;

  pTxQel->pBuf    = pDstBuf;		// set the buffer
  pTxQel->DataLen = TotalLen;
  //----------------------------------------------------
  // Update Handshake Hashes
  //----------------------------------------------------
  HashHandshakeMessage(pConnStruc,pDstBuf,0, TotalLen);
  //----------------------------------------------------
  // Enqueue TX-Quel for send
  //----------------------------------------------------
  EnqueueTxQel(pConnStruc,pTxQel);
  return(HSSL_OP_OK);
}

static BOOL m_check_sig_type_from_array(int inp_signature_type,
                                        char* abyp_configured_types)
{
   int inl_index =1;

   for(; inl_index <= (int)abyp_configured_types[0]; inl_index++){
      if(inp_signature_type == (int)abyp_configured_types[inl_index]){
         return TRUE;
      }
   }
   return FALSE;
}

static BOOL m_signature_is_configured(int inp_encoded_type,
                                      char* abyp_configured_types)
{
    switch(inp_encoded_type& 0xff){
    case SIG_ALGOR_RSA:
        switch(inp_encoded_type >> 8){
        case HASH_ALGOR_MD5:
            return m_check_sig_type_from_array(PKCS1_MD5_WITH_RSA_ENC, abyp_configured_types);
        case HASH_ALGOR_SHA1:
            return m_check_sig_type_from_array(PKCS1_SHA1_WITH_RSA_ENC, abyp_configured_types);
        case HASH_ALGOR_SHA256:
            return m_check_sig_type_from_array(PKCS1_SHA256_WITH_RSA_ENC, abyp_configured_types);
        case HASH_ALGOR_SHA384:
            return m_check_sig_type_from_array(PKCS1_SHA384_WITH_RSA_ENC, abyp_configured_types);
        case HASH_ALGOR_SHA512:
            return m_check_sig_type_from_array(PKCS1_SHA512_WITH_RSA_ENC, abyp_configured_types);
        }
        break;
    case SIG_ALGOR_DSA:
        if((inp_encoded_type >> 8) == HASH_ALGOR_SHA1){
            return m_check_sig_type_from_array(X957_DSA_WITH_SHA1, abyp_configured_types) ||
                m_check_sig_type_from_array(OIW_DSA_WITH_SHA, abyp_configured_types) ||
                m_check_sig_type_from_array(OIW_DSA_WITH_SHA1, abyp_configured_types);
        }
        break;
    }
    return FALSE;
}

/**
* Checks client certificate
* verify message for correct length and parameters,
* verifies the signature with the remote (client) RSA/DSA structures (ProcessCertificateVerify).
*
*  @param pConnStruc Connection structure
*  @param InpBuf Buffer Base
*  @param InpOffset Start of data
*  @param DataLen generated data count
*  @param pAlertType type of Alert on Error
*  @param pAlertLvl level of Alert on Error
*
*  @return HSSL_OP_OK on success, else error occured
*/
static  int  ProcessCertificateVerify(CONNSTRU * pConnStruc,
		   char* InpBuf, int InpOffset, int DataLen,
		   int* pAlertType, int* pAlertLvl)
{
  int Retcode;
  int BufLen;
  int SignatLen;
  int InpIndex = InpOffset;
  int Index=0;
  int Flags;
  int MAClen;
  int MsgLen;

  char* pDstBuf;
  int pTmpLen[1];

  char MacData[RSA_DEF_SHA2_SIGN_HDR_LEN+SHA512_DIGEST_LEN];

  HMEM_CTX_DEF1;
  LOAD_HMEM_CTX_PTR(CONN_pMemCtx(pConnStruc));

  //-------------------------------------------------------
  // Preset Alert Type and Level to Illegal parameter/Fatal
  //-------------------------------------------------------
  pAlertType[0] = AD_ILLEGAL_PARAMETER;
  pAlertLvl[0]  = ALERT_LEVEL_FATAL;
  //----------------------------------------------------
  // Get/check Message length
  //----------------------------------------------------
  BIGchar2long(InpBuf,MsgLen,InpIndex);		// from 1st 4 bytes
  MsgLen &= 0xFFFFFF;				// only 3 bytes valid
  DataLen  -= HT_RECORD_HDR_SIZE;		// reduce length

  // SRP does not allow use of Certificate Request
  if( KEY_EXCHANGE_SRP == pConnStruc->KeyExchgMode){
     pAlertType[0] = AD_UNEXPECTED_MSG;
     return (HSSL_CERTREQ_UNEXPECTED);
  }

  if((MsgLen != (int) DataLen) ||
     (MsgLen <= SIGNAT_VECTOR_LEN))
    return(HSSL_CERTVFY_INVALID_MSGLEN);	// inconsistent data size
  //----------------------------------------------------
  // Get the signature length and type
  //----------------------------------------------------
  if(pConnStruc->ActualProtocol == TLS_V2_PROT_TYPE){ //only needed for TLS 1.2
    BIGchar2word(InpBuf,pConnStruc->RemoteCertPublicAlgor,InpIndex);
    DataLen -= 2;
    if(! m_signature_is_configured(pConnStruc->RemoteCertPublicAlgor,
                                   pConnStruc->pCfgStruc->achc_tls_12_sig_algs)){
        return HSSL_CERTVFY_INV_SIGNAT_ALGOR;
    }
  }
  BIGchar2word(InpBuf,SignatLen,InpIndex);	// from next 2 bytes
  DataLen -= SIGNAT_VECTOR_LEN;
  if(DataLen != SignatLen)
    return(HSSL_CERTVFY_INVALID_MSGLEN);	// inconsistent data size
  //------------------------------------------------------
  // get the propper data block (Hashes or PKCS encodes hashes)
  // MAClen is the actual length for RSA signing, which can varry
  //------------------------------------------------------
  if(pConnStruc->ActualProtocol == SSL_PROT_TYPE){
    pAlertType[0] = AD_HSHAKE_FAILURE;
  } else {
    pAlertType[0] = AD_DECRYPT_ERROR;
  }
  GenerateCertVerifyHashes(pConnStruc,MacData,0,pConnStruc->RemoteCertPublicAlgor);
  if(pConnStruc->ActualProtocol == TLS_V2_PROT_TYPE){
    switch(pConnStruc->RemoteCertPublicAlgor >>8){
        case HASH_ALGOR_MD5:
            MAClen = RSA_DEF_MD_SIGN_HDR_LEN+MD5_DIGEST_LEN;
            break;
        case HASH_ALGOR_SHA1:
            MAClen = RSA_DEF_SHA_SIGN_HDR_LEN+SHA_DIGEST_LEN;
            break;
        case HASH_ALGOR_SHA256:
            MAClen = RSA_DEF_SHA2_SIGN_HDR_LEN+SHA256_DIGEST_LEN;
            break;
        case HASH_ALGOR_SHA384:
            MAClen = RSA_DEF_SHA2_SIGN_HDR_LEN+SHA384_DIGEST_LEN;
            break;
        case HASH_ALGOR_SHA512:
            MAClen = RSA_DEF_SHA2_SIGN_HDR_LEN+SHA512_DIGEST_LEN;
            break;
        default:
           return HSSL_CERTVFY_INV_SIGNAT_ALGOR;
    }
  } else {
    MAClen = MD5_DIGEST_LEN+SHA_DIGEST_LEN;
  }
  //----------------------------------------------------
  // distribute by public algor of remote certificate
  //----------------------------------------------------
  switch(pConnStruc->RemoteCertPublicAlgor&0xff)
  {
    //-----------------------------------------------------
    // RSA, public decrypt the signature with remote params,
    // compare against own hashes
    //-----------------------------------------------------
    case SIG_ALGOR_RSA:
      BufLen = RSA_Size(pConnStruc->pRemoteRsaStruc) + 1;
      pDstBuf = BIT8_ARRAY_ALLOC_POOL(HMEM_CTX_REF,BufLen);
      if(pDstBuf == NULL)
      {   
        pAlertType[0] = AD_INTERNAL_ERROR;
        return(HSSL_CERTVFY_SIGBUF_ALLOC_ERR);
      }
      pTmpLen[0] = BufLen;

      if((pConnStruc->ActualProtocol == TLS_V1_PROT_TYPE) ||
         (pConnStruc->ActualProtocol == TLS_V2_PROT_TYPE))
        Flags = 1;			// TLS V1.1, allow only Blocktype 0x01
      else
        Flags = 0;			// allow RSA Blocktypes 0x00 and 0x01

      Retcode = RSA_PublicDecryptEx(HMEM_CTX_REF1 SignatLen,InpBuf,InpIndex,pDstBuf,pTmpLen,pConnStruc->pRemoteRsaStruc,Flags);
      if(Retcode != RSA_OP_OK)
      {
        FREE_ARRAY_POOL(HMEM_CTX_REF,pDstBuf);
        return(HSSL_CERTVFY_SIGNAT_RSADEC_ERR);
      }
      SignatLen = pTmpLen[0];		// get true size
      if(SignatLen != MAClen)
      {
        FREE_ARRAY_POOL(HMEM_CTX_REF,pDstBuf);
        return(HSSL_CERTVFY_SIGNATURE_INVALID);
      }
      do
      {
        if(pDstBuf[Index] != MacData[Index])
        {
          FREE_ARRAY_POOL(HMEM_CTX_REF,pDstBuf);
          return(HSSL_CERTVFY_SIGNATURE_INVALID);
        }
        Index++;
        SignatLen--;
      }while(SignatLen != 0);
      FREE_ARRAY_POOL(HMEM_CTX_REF,pDstBuf);
      break;
    //-----------------------------------------------------
    // DSA, verify DSS signature
    //-----------------------------------------------------
    case SIG_ALGOR_DSA:
      Retcode = DSA_Verify(HMEM_CTX_REF1 MacData,MD5_DIGEST_LEN,0,InpBuf,InpIndex,SignatLen,pConnStruc->pRemoteDsaStruc,1);
      if(Retcode != LNUM_OP_OK)
        return(HSSL_CERTVFY_SIGNATURE_INVALID);
      break;

    default:
      pAlertType[0] = AD_INTERNAL_ERROR;
      return(HSSL_CERTVFY_INV_SIGNAT_ALGOR);	// should not happen
  }
  //--------------------------------------------------
  // free the Client Certificates RSA/DSA structures
  //--------------------------------------------------
  RSA_Free(HMEM_CTX_REF1 pConnStruc->pRemoteRsaStruc);
  DSA_Free(HMEM_CTX_REF1 pConnStruc->pRemoteDsaStruc);
  pConnStruc->pRemoteRsaStruc = NULL;
  pConnStruc->pRemoteDsaStruc = NULL;
  //--------------------------------------------------
  // Hash the received message (finished is coming)
  //--------------------------------------------------
  HashHandshakeMessage(pConnStruc,InpBuf,InpOffset,
			 MsgLen+HT_RECORD_HDR_SIZE);

  return(HSSL_OP_OK);
}

static int ms_gen_ecc_cl_exchange(char** aachp_dest,
                                  int* ainp_param_len,
                                  CONNSTRU* adsp_connection)
{
    HMEM_CTX_DEF1;

    LOAD_HMEM_CTX_PTR(CONN_pMemCtx(adsp_connection));

    size_t szl_max_key_len = cszrg_ecdh_public_key_len[ms_get_curve_name(adsp_connection->iec_selected_curve)];
    unsigned int unl_message_len = HT_RECORD_HDR_SIZE +
                                   1 +
                                   szl_max_key_len;

    unl_message_len += GetByteCntWLnum(adsp_connection->pRemoteRsaStruc->Modul) + 1;
    
    unsigned char* abyl_data = (unsigned char*)BIT8_ARRAY_ALLOC_POOL(HMEM_CTX_REF,unl_message_len);

    // Generate the keys and write public key
    size_t szl_key_data_len = unl_message_len - (HT_RECORD_HDR_SIZE+1);

    ied_encry_return iel_ec_ret = m_ecc_export_pub_key((char*)abyl_data+HT_RECORD_HDR_SIZE+1, 
                                                       &szl_key_data_len,
                                                       &adsp_connection->dsc_ecc_keypair);

    if ( iel_ec_ret != ied_encry_success ) {
        FREE_ARRAY_POOL(HMEM_CTX_REF, abyl_data);
        return HSSL_GEN_CLKYEX_ECC_INTERNAL_ERR;
    }

    abyl_data[HT_RECORD_HDR_SIZE] = (unsigned char)szl_key_data_len;

    // Set return parameters
    *aachp_dest = (char*)abyl_data;
    *ainp_param_len = (int)(1 + szl_key_data_len);
    return HSSL_OP_OK;
}

/**
* Generates client key exchange
* message from the connection structure parameters, updates
* Handshake Messages and enqueues Message for send to the priority queue (GenerateClientKeyExchange).
*
*  @param pConnStruc Connection structure
*  @return HSSL_OP_OK on success, else error occured
*/
static  int  GenerateClientKeyExchange(CONNSTRU * pConnStruc)
{
  int Retcode;

  int KeyExchgMode;

  int BufLen = HT_RECORD_HDR_SIZE;		// primary length
  int ParamLen;
  int DstOff = HT_RECORD_HDR_SIZE;
  int TotalLen = 0;

  char* pDstBuf;

  int pTmpLen[1];

  RSA_STRUC* pRsaStruc = NULL;
  DH_STRUC* pDhStruc   = NULL;

  TX_QEL * pTxQel;

  HMEM_CTX_DEF1;

  LOAD_HMEM_CTX_PTR(CONN_pMemCtx(pConnStruc));

  //----------------------------------------------------
  // Allocate TX-Qel without buffer
  //----------------------------------------------------
  pTxQel = AllocInitTxQel(HMEM_CTX_REF1
			  0,(unsigned char) TX_TYPE_HANDSHAKE_MSG);
  if(pTxQel == NULL)
    return(HSSL_TX_QEL_ALLOC_ERR);

  //----------------------------------------------------
  // in case of TLS we also need a Vector length field
  //----------------------------------------------------
  if((pConnStruc->ActualProtocol != SSL_PROT_TYPE) &&	// TLS1.0 or 1.1
     ((pConnStruc->KeyExchgMode == KEY_EXCHANGE_RSA) ||
     (pConnStruc->KeyExchgMode == KEY_EXCHANGE_SRP))) // not for DH !!
  {
    BufLen += 2;				// 2 bytes more
    DstOff += 2;				// past Vector !
  }
  //----------------------------------------------------
  // get type of parameters to use
  //----------------------------------------------------
  KeyExchgMode = pConnStruc->KeyExchgMode;
  switch(KeyExchgMode)
  {
    //--------------------------------------------------
    // Generate RSA Premaster secret, Public encrypt either
    // with RemRsaStruc (Server Cert) or LclTmpRsaStruc
    // from the Server's key exchange
    //--------------------------------------------------
    case KEY_EXCHANGE_RSA:
      if((pConnStruc->CertifiedFlags & SERVER_KEY_EXCHG_REQ_MASK) == 0)
        pRsaStruc = pConnStruc->pRemoteRsaStruc;
      else
        pRsaStruc = pConnStruc->pTmpRsaStruc;
      //---------------------------------------------------------
      // Generate, save the RSA premaster secret, allocate buffer
      //---------------------------------------------------------
      Retcode = GenerateRSAPreMasterSecret(pConnStruc);
      if(Retcode != HSSL_OP_OK)
        return(HSSL_GEN_CLKYEX_RSA_PREMGEN_ERR);
      BufLen += RSA_Size(pRsaStruc) + 1;
      pDstBuf = BIT8_ARRAY_ALLOC_POOL(HMEM_CTX_REF,BufLen);
      if(pDstBuf == NULL)
        return(HSSL_GEN_CLKYEX_MSGBUF_ALLOC_ER);
      //------------------------------------------------------------
      // Public encrypt the Pre-Master secret with server public key
      //------------------------------------------------------------
      pTmpLen[0] = BufLen - DstOff;
      Retcode = RSAEncPreMasterSecret(pConnStruc,pRsaStruc,
			pDstBuf,DstOff,	pTmpLen);
      if(Retcode != HSSL_OP_OK)
      {
        FREE_ARRAY_POOL(HMEM_CTX_REF,pDstBuf);
        return(HSSL_GEN_CLKYEX_PREM_RSAENC_ERR);
      }
      ParamLen = pTmpLen[0];
//      BIGword2charn(ParamLen,pDstBuf,HT_RECORD_HDR_SIZE);
      TotalLen = ParamLen;
      break;
    //--------------------------------------------------------
    // Generate DH Pre-Master secret, check if Public value Yc
    // must be sent to Server
    //--------------------------------------------------
    case KEY_EXCHANGE_DH_RSA:
    case KEY_EXCHANGE_DH_DSS:
    case KEY_EXCHANGE_DHE_RSA:
    case KEY_EXCHANGE_DHE_DSS:

      Retcode = GenerateDHPreMasterSecret(pConnStruc);
      if(Retcode != HSSL_OP_OK)
        return(HSSL_GEN_CLKYEX_DH_PREMGEN_ERR);

      pDhStruc = pConnStruc->pTmpDhStruc;	// get the helper structure
      if(pDhStruc != NULL)			// Yc present, must send
        BufLen += SECRET_VECTOR_LEN +
                  DH_Size(pDhStruc)+1;

      pDstBuf = BIT8_ARRAY_ALLOC_POOL(HMEM_CTX_REF,BufLen);
      if(pDstBuf == NULL)
        return(HSSL_GEN_CLKYEX_MSGBUF_ALLOC_ER);

      TotalLen = 0;				// Assume empty message
      //------------------------------------------------------------
      // Generate Yc if needed (with leading zero)
      // no leading zero !!!
      //------------------------------------------------------------
      pTmpLen[0] = BufLen - DstOff - SECRET_VECTOR_LEN;
      if(pDhStruc != NULL)			// Yc conversion needed
      {
        Retcode = WLnum_wlnum2bin(pDstBuf,DstOff+SECRET_VECTOR_LEN,pTmpLen,pDhStruc->PubKey,0);
        if(Retcode != HSSL_OP_OK)
        {
          FREE_ARRAY_POOL(HMEM_CTX_REF,pDstBuf);
          return(HSSL_GEN_CLKYEX_DHPAR_STORE_ERR);
        }
        ParamLen = pTmpLen[0];
        BIGword2charn(ParamLen,pDstBuf,DstOff);
        TotalLen = ParamLen + SECRET_VECTOR_LEN;
      }
      break;
    case KEY_EXCHANGE_ECDHE_RSA:
        Retcode = ms_gen_ecc_cl_exchange(&pDstBuf, &TotalLen, pConnStruc);
        if(Retcode != HSSL_OP_OK) {
          return Retcode;
        }
        break;
    case KEY_EXCHANGE_SRP:
       if( NULL == pConnStruc->adsc_srp_params || 
          NULL == pConnStruc->adsc_srp_params[0].adsc_cl_pub_key )
       {
          return (HSSL_GEN_CLKYEX_MISSING_SRP_PARAM);
       }
       TotalLen = GetByteCntWLnum(pConnStruc->adsc_srp_params[0].adsc_cl_pub_key);
       BufLen += TotalLen;
       pDstBuf = BIT8_ARRAY_ALLOC_POOL(HMEM_CTX_REF,BufLen);
       pTmpLen[0] = TotalLen;
       Retcode = WLnum_wlnum2bin(pDstBuf,DstOff,pTmpLen,pConnStruc->adsc_srp_params[0].adsc_cl_pub_key,0);
       if( HSSL_OP_OK != Retcode ){
          FREE_ARRAY_POOL(HMEM_CTX_REF,pDstBuf);
          return (Retcode);
       }
       break;
    default:
      return(HSSL_GEN_CLKYEX_INV_KEYEX_MODE);	// should not happen
  } // switch
  //------------------------------------------------------------
  // Generate the Master secret, discard pre-master secret
  //------------------------------------------------------------
  GenerateMasterSecret(pConnStruc);
  ConvertMasterSecret(pConnStruc);
  pConnStruc->PendRX_ValidFlag = PENDING_STATES_INIT;
  pConnStruc->PendTX_ValidFlag = PENDING_STATES_INIT;
  //------------------------------------------------------------
  // Generate the message header
  //------------------------------------------------------------
  if(pConnStruc->ActualProtocol != SSL_PROT_TYPE) // a length header is needed
  {					       // with TLS, but ONLY for RSA !!!
    if((KeyExchgMode == KEY_EXCHANGE_RSA) ||
       (KeyExchgMode == KEY_EXCHANGE_SRP))
    {
      BIGword2charn(TotalLen,pDstBuf,HT_RECORD_HDR_SIZE); // set length
      TotalLen += 2;				// add vector length
    }
  }

  BIGlong2charn(TotalLen, pDstBuf,0);		// convert
  pDstBuf[0] = HT_CLIENT_KEY_EXCHANGE;  

  pTxQel->pBuf    = pDstBuf;
  pTxQel->DataLen = TotalLen+HT_RECORD_HDR_SIZE;
  //----------------------------------------------------
  // Update Handshake Hashes
  //----------------------------------------------------
  HashHandshakeMessage(pConnStruc,pDstBuf,0, TotalLen+HT_RECORD_HDR_SIZE);
  //----------------------------------------------------
  // Enqueue TX-Quel for send
  //----------------------------------------------------
  EnqueueTxQel(pConnStruc,pTxQel);
  //------------------------------------------------------------
  // Free all RSA/DSA/DH/SRP-Arrays for key exchange
  //------------------------------------------------------------
  RSA_Free(HMEM_CTX_REF1 pConnStruc->pRemoteRsaStruc);
  RSA_Free(HMEM_CTX_REF1 pConnStruc->pLocalRsaStruc);
  RSA_Free(HMEM_CTX_REF1 pConnStruc->pTmpRsaStruc);
  DSA_Free(HMEM_CTX_REF1 pConnStruc->pRemoteDsaStruc);
  DSA_Free(HMEM_CTX_REF1 pConnStruc->pLocalDsaStruc);
  DH_Free(HMEM_CTX_REF1 pConnStruc->pRemoteDhStruc);
  DH_Free(HMEM_CTX_REF1 pConnStruc->pLocalDhStruc);
  DH_Free(HMEM_CTX_REF1 pConnStruc->pTmpDhStruc);
  m_free_srp_struct(HMEM_CTX_REF1 pConnStruc->adsc_srp_params);

  pConnStruc->pRemoteRsaStruc = NULL;
  pConnStruc->pLocalRsaStruc = NULL;
  pConnStruc->pTmpRsaStruc = NULL;
  pConnStruc->pRemoteDsaStruc = NULL;
  pConnStruc->pLocalDsaStruc = NULL;
  pConnStruc->pRemoteDhStruc = NULL;
  pConnStruc->pLocalDhStruc = NULL;
  pConnStruc->pTmpDhStruc = NULL;
  pConnStruc->adsc_srp_params = NULL;

  return(HSSL_OP_OK);
}

static int ms_process_ecdhe_cl_key_ex(CONNSTRU* adsp_connection,
                                      const unsigned char* achp_data,
                                      size_t szp_data_len)
{
    HMEM_CTX_DEF1;
    LOAD_HMEM_CTX_PTR(CONN_pMemCtx(adsp_connection));
    
    size_t szl_pub_key_len = achp_data[0];
    if((szp_data_len-1) != achp_data[0]){
        return HSSL_CLNT_KEYEXC_INVALID_MSGLEN;
    }

    size_t szl_final_secret_len = cszrg_ecdh_secret_len[ms_get_curve_name(adsp_connection->iec_selected_curve)];
    char* achl_secret = BIT8_ARRAY_ALLOC(HMEM_CTX_REF, szl_final_secret_len);

    ied_encry_return iel_ret = m_ecc_gen_secret(achl_secret,
                                                &szl_final_secret_len, 
                                                &adsp_connection->dsc_ecc_keypair,
                                                adsp_connection->adsc_mem_pool,
                                                (const char*)achp_data+1,
                                                szp_data_len-1);

    if(iel_ret == ied_encry_pool_empty) {
        /** @todo improve this. */
        dsd_mem_pool_ele* adsl_new_ele = m_mem_pool_create(&adsp_connection->dsc_mem_mgr,
                                                           adsp_connection->unc_pool_ele_size,
                                                           1);
        if(adsl_new_ele == NULL){
            FREE_ARRAY(HMEM_CTX_REF, achl_secret);
            return HSSL_ALLOC_ERR;
        }
        adsl_new_ele->adsc_next = adsp_connection->adsc_mem_pool;
        adsp_connection->adsc_mem_pool = adsl_new_ele;
        return ms_process_ecdhe_cl_key_ex(adsp_connection, achp_data, szp_data_len);
    }

    if(iel_ret != ied_encry_success){
        FREE_ARRAY(HMEM_CTX_REF, achl_secret);
        return HSSL_CLNT_KEYEC_ECDHE_ERR;
    }

    adsp_connection->PreMasterSecrLen = szl_final_secret_len;
    adsp_connection->PreMasterSecrPtr = achl_secret;

    return HSSL_OP_OK;
}

/**
* Checks client key exchange
* message for correct length and parameters, extracts parameters (ProcessClientKeyExchange).
*
*  @param pConnStruc Connection structure
*  @param InpBuf Buffer Base
*  @param InpOffset Start of data
*  @param DataLen data count
*  @param pAlertType type of Alert on Error
*  @param pAlertLvl level of Alert on Error
*
*  @return HSSL_OP_OK on success, else error occured
*/
static  int  ProcessClientKeyExchange(CONNSTRU * pConnStruc,
		   char* InpBuf, int InpOffset, int DataLen,
		   int* pAlertType, int* pAlertLvl)
{
  int Retcode;
  int InpIndex = InpOffset;
  int ParamLen = 0;

  int DH_FixedFlag = 0;
  int KeyExchgMode;

  int TmpLen = 0;
  int MsgLen;

  char* pBuf = NULL;

  RSA_STRUC* pRsaStruc = NULL;
  DH_STRUC* pDhStruc   = NULL;
  
  HMEM_CTX_DEF1;
  LOAD_HMEM_CTX_PTR(CONN_pMemCtx(pConnStruc));

  //-------------------------------------------------------
  // Preset Alert Type and Level to Illegal parameter/Fatal
  //-------------------------------------------------------
  pAlertType[0] = AD_ILLEGAL_PARAMETER;
  pAlertLvl[0]  = ALERT_LEVEL_FATAL;

  //----------------------------------------------------
  // check Client Key Exchange Message length
  //----------------------------------------------------
  BIGchar2long(InpBuf,MsgLen,InpIndex);		// from 1st 4 bytes
  MsgLen &= 0xFFFFFF;				// only 3 bytes valid
  DataLen  -= HT_RECORD_HDR_SIZE;		// reduce length

  if(MsgLen != (int) DataLen)
  {
    return(HSSL_CLNT_KEYEXC_INVALID_MSGLEN);	// inconsistent data size
  }
  //----------------------------------------------------------
  // For TLS there is an additional Vector present, but
  // ----- ONLY for RSA key exchange mode !!
  //	   We earlier also used such a vector for DH which is
  //	   wrong. So we must check for the Wrong case also...
  //       For SSLv3, it was recommended to switch ti this format,
  //       so check for it anyway.
  //----------------------------------------------------------
  if(DataLen >= 4)				// could be a vector ahead
  {/** @todo Enforce this in TLS? */
    BIGchar2wordn(InpBuf,TmpLen,InpIndex);	// get possible Vector Length
    TmpLen += 2;				// add the vector length size
    if(DataLen == TmpLen)			// this could be a vector !
    {
      if(pConnStruc->KeyExchgMode == KEY_EXCHANGE_RSA ||
         pConnStruc->KeyExchgMode == KEY_EXCHANGE_SRP)
      {
        DataLen  -= 2;			// remove the vector length
        InpIndex += 2;			// skip the vector
      }
      else					// is DH/DHE mode, no vector
      {
        BIGchar2wordn(InpBuf,TmpLen,InpIndex+2);// get content length
        TmpLen += 2;				// add the vector length size
        if(DataLen == (TmpLen + 2))		// there IS a leading vector
        {
          DataLen  -= 2;			// remove the vector length
          InpIndex += 2;			// skip the vector
        }
      }
    }
  }
  //----------------------------------------------------
  // get type of parameter to use
  //----------------------------------------------------
  KeyExchgMode = pConnStruc->KeyExchgMode;
  switch(KeyExchgMode)
  {
    //-------------------------------------------------------
    // RSA encrypted key, must decrypt with private key
    //-------------------------------------------------------
    case KEY_EXCHANGE_RSA:
      if((pConnStruc->CertifiedFlags & SERVER_KEY_EXCHG_REQ_MASK) != 0)
        pRsaStruc = pConnStruc->pTmpRsaStruc;
      else
        pRsaStruc = pConnStruc->pLocalRsaStruc;
      //--------------------------------------------------------------
      // Private decrypt the Pre-Master secret with server private key,
      // store to Pre-Master secret.
      // Avoid Bleichenbacher attack in case of failure:
      // ----- If failure is from private decrypt use random
      //       48 byte Premaster secret instead !!!
      //       (this will obviously lead to decryption error alert)
      //--------------------------------------------------------------
      Retcode = RSADecrPreMasterSecret(pConnStruc,pRsaStruc,
				       InpBuf,InpIndex,DataLen);
      if(Retcode != HSSL_OP_OK)
      {
        if(Retcode != HSSL_RSA_PREMASTER_PRIV_DEC_ERR)
        {
          pAlertType[0] = AD_INTERNAL_ERROR;
          return(Retcode);			// HSSL_RSA_PREMASTER_ALLOC_ERR
        }
        //-------------------------------------------------------------
        // allocate buffer of 48 bytes size and load with random
        //-------------------------------------------------------------
        pBuf = BIT8_ARRAY_ALLOC(HMEM_CTX_REF,RSA_PRE_MASTER_SECRET_LEN);
        if(pBuf == NULL)
        {
          pAlertType[0] = AD_INTERNAL_ERROR;
          return(HSSL_CLNT_KEYEXC_PREM_ALLOC_ERR);
        }  
        Retcode = SecDrbgRandBytes(HMEM_CTX_REF1 pBuf,0,RSA_PRE_MASTER_SECRET_LEN);
        if(Retcode != 0)
        {
          FREE_ARRAY(HMEM_CTX_REF,pBuf);
          pAlertType[0] = AD_INTERNAL_ERROR;
          return(HSSL_CLNT_KEYEXC_RNG_FETCH_ERR);
        }

        pConnStruc->PreMasterSecrPtr = pBuf;
        pConnStruc->PreMasterSecrLen = RSA_PRE_MASTER_SECRET_LEN;
      }
      break;
    //-------------------------------------------------------
    // DH key exchange
    //-------------------------------------------------------
    case KEY_EXCHANGE_DH_RSA:
    case KEY_EXCHANGE_DH_DSS:
    case KEY_EXCHANGE_DHE_RSA:
    case KEY_EXCHANGE_DHE_DSS:
      //--------------------------------------------------------
      // Check if we have client parameters with Yc
      //--------------------------------------------------------
      pDhStruc = pConnStruc->pRemoteDhStruc;	// from the client
      if(pDhStruc != NULL)
        DH_FixedFlag = 1;			// was a fixed DH Cert

      if((pDhStruc == NULL) || (pDhStruc->PubKey == NULL) ||
         (pDhStruc->PubKey->UsedSize == 0))
      {
        //------------------------------------------------------
        // no/invalid Yc from client, check if we got one
        //------------------------------------------------------
        if(DataLen <= SECRET_VECTOR_LEN)
          return(HSSL_CLNT_KEYEXC_INV_DH_YC_DATA);

        DataLen -= SECRET_VECTOR_LEN;
        BIGchar2word(InpBuf,ParamLen,InpIndex);		// get length

        if(DataLen != ParamLen)
	{

          return(HSSL_CLNT_KEYEXC_INVALID_MSGLEN); // inconsistent data size
	}
        //--------------------------------------------------------------------
        // Client sent Yc value, put to the RemDhStruc (check for Alloc !)
        //--------------------------------------------------------------------
        if(pDhStruc == NULL)			// no structure yet !!
        {
          pDhStruc = DH_New(HMEM_CTX_REF1 0,0,0,(ParamLen+WELEMENT_SIZE-1)/WELEMENT_SIZE,0);
          if(pDhStruc == NULL)
          {
            pAlertType[0] = AD_INTERNAL_ERROR;
            return(HSSL_CLNT_KEYEXC_DH_ALLOC_ERR);
          }
          pConnStruc->pRemoteDhStruc = pDhStruc;	// save !!
        }
        Retcode = WLnum_bin2wlnum(HMEM_CTX_REF1 pDhStruc->PubKey,InpBuf,InpIndex,ParamLen);
        if(Retcode != LNUM_OP_OK)
        {
          pAlertType[0] = AD_INTERNAL_ERROR;
          return(HSSL_CLNT_KEYEXC_DHPAR_LOAD_ERR);
        }
      }
      else
      {          
        //------------------------------------------------------
        // valid Yc from client, check for empty message
        //------------------------------------------------------
        if(DataLen != 0)
        {
          return(HSSL_CLNT_KEYEXC_INVALID_MSGLEN);// inconsistent data size
        }
      }
      //--------------------------------------------------------
      // Generate the DH Premaster Secret
      //--------------------------------------------------------
      Retcode = GenerateDHPreMasterSecret(pConnStruc);
      if(Retcode != HSSL_OP_OK)
      {
        pAlertType[0] = AD_INTERNAL_ERROR;
        return(HSSL_CLNT_KEYEXC_DH_PREMGEN_ERR);
      }
      break;

    case KEY_EXCHANGE_ECDHE_RSA:
        Retcode = ms_process_ecdhe_cl_key_ex(pConnStruc,
                                             (unsigned char*)InpBuf+InpIndex,
                                             DataLen);
        
        m_ecc_free_keypair(&pConnStruc->dsc_mem_mgr,
                           &pConnStruc->dsc_ecc_keypair);
        m_mem_pool_free(&pConnStruc->dsc_mem_mgr,
                        pConnStruc->adsc_mem_pool);
        pConnStruc->adsc_mem_pool = NULL;
        if(Retcode != HSSL_OP_OK)
        {
            pAlertType[0] = AD_INTERNAL_ERROR;
            return Retcode;
        }
        break;
    case KEY_EXCHANGE_SRP:
       Retcode = WLnum_bin2wlnum(HMEM_CTX_REF1 pConnStruc->adsc_srp_params[0].adsc_cl_pub_key,InpBuf,InpIndex,DataLen); 
       if(Retcode != HSSL_OP_OK)
       {
          pAlertType[0] = AD_INTERNAL_ERROR;
          return(HSSL_CLNT_KEYEXC_SRP_ALLOC_ERR);
       }
       Retcode = m_gen_srp_server_premaster_sec(pConnStruc);
       if(Retcode != HSSL_OP_OK)
       {
          if( HSSL_SRP_PREMASTER_PARAM_ERR == Retcode ){
             pAlertType[0] = AD_ILLEGAL_PARAMETER;
          } else {
             pAlertType[0] = AD_INTERNAL_ERROR;
          }
          return HSSL_CLNT_KEYEXC_SRP_PREMGEN_ERR;
       }
       break;

    default:
      pAlertType[0] = AD_INTERNAL_ERROR;
      return(HSSL_CLNT_KEYEXC_INV_KEYEX_MODE);		// should not happen
  } // switch
  //------------------------------------------------------------
  // Generate the Master secret, discard pre-master secret
  //------------------------------------------------------------
  GenerateMasterSecret(pConnStruc);
  ConvertMasterSecret(pConnStruc);
  pConnStruc->PendRX_ValidFlag = PENDING_STATES_INIT;
  pConnStruc->PendTX_ValidFlag = PENDING_STATES_INIT;
  //------------------------------------------------------------
  // Free all RSA/DSA/DH-Arrays for key exchange,
  // keep Remote RSA / DSA if Client authentication is active
  // and client did not send DH-Fixed Parameters
  //------------------------------------------------------------
  if(((pConnStruc->AuthFlags & CLNT_AUTH_BIT_MASK) == 0) ||
      (DH_FixedFlag != 0))
  {
    RSA_Free(HMEM_CTX_REF1 pConnStruc->pRemoteRsaStruc);
    DSA_Free(HMEM_CTX_REF1 pConnStruc->pRemoteDsaStruc);
    pConnStruc->pRemoteRsaStruc = NULL;
    pConnStruc->pRemoteDsaStruc = NULL;
  }

  RSA_Free(HMEM_CTX_REF1 pConnStruc->pLocalRsaStruc);
  RSA_Free(HMEM_CTX_REF1 pConnStruc->pTmpRsaStruc);
  DSA_Free(HMEM_CTX_REF1 pConnStruc->pLocalDsaStruc);
  DH_Free(HMEM_CTX_REF1 pConnStruc->pRemoteDhStruc);
  DH_Free(HMEM_CTX_REF1 pConnStruc->pLocalDhStruc);
  DH_Free(HMEM_CTX_REF1 pConnStruc->pTmpDhStruc);
  m_free_srp_struct(HMEM_CTX_REF1 pConnStruc->adsc_srp_params);

  pConnStruc->pLocalRsaStruc = NULL;
  pConnStruc->pTmpRsaStruc = NULL;
  pConnStruc->pLocalDsaStruc = NULL;
  pConnStruc->pRemoteDhStruc = NULL;
  pConnStruc->pLocalDhStruc = NULL;
  pConnStruc->pTmpDhStruc = NULL;
  pConnStruc->adsc_srp_params = NULL;

  return(HSSL_OP_OK);
}

/**
* Generates finished handshake
* message from the stored messages MD5 and SHA1 MACS and
* enqueues Message for send to the priority queue (GenerateFinished).
*
*  @param pConnStruc Connection structure
*  @return HSSL_OP_OK on success, else error occured
*/
static  int  GenerateFinished(CONNSTRU * pConnStruc)
{
  int DstIndex=0;
  int BufLen;
  int TotalLen;
  char FinishedLen;

  char* pDstBuf;

  TX_QEL * pTxQel;

  HMEM_CTX_DEF1;
  LOAD_HMEM_CTX_PTR(CONN_pMemCtx(pConnStruc));

  //----------------------------------------------------
  // Calculate Required Length
  //----------------------------------------------------
  if(pConnStruc->ActualProtocol == SSL_PROT_TYPE)		// SSL
    BufLen = HT_MESSAGE_SIZE + HT_LENGTH_SIZE +
	     MD5_DIGEST_LEN + SHA_DIGEST_LEN;
  else							// TLS V1.0/1.1/1.2
    BufLen = HT_MESSAGE_SIZE + HT_LENGTH_SIZE +
	       TLS_VERIFY_DATA_LEN;
  TotalLen = BufLen - HT_RECORD_HDR_SIZE;
  //----------------------------------------------------
  // Allocate TX-Qel with buffer
  //----------------------------------------------------
  pTxQel = AllocInitTxQel(HMEM_CTX_REF1
			  BufLen,(unsigned char) TX_TYPE_HANDSHAKE_MSG);
  if(pTxQel == NULL)
    return(HSSL_TX_QEL_ALLOC_ERR);
  pDstBuf = pTxQel->pBuf;
  //----------------------------------------------------
  // set Finished Message and length
  //----------------------------------------------------
  pDstBuf[DstIndex++] = HT_FINISHED;
  pDstBuf[DstIndex++] = 0;			// is less 2^16
  pDstBuf[DstIndex++] = 0;			// and even less 2^8
  pDstBuf[DstIndex++] = (char) TotalLen;	// store LSB only
  //----------------------------------------------------
  // append the hashes
  //----------------------------------------------------
  FinishedLen = GenerateFinishedHashes(pConnStruc,pDstBuf,DstIndex,
			 pConnStruc->Entity);
  //----------------------------------------------------
  // Save finished hashes for save renegotiation
  //----------------------------------------------------
  if(pConnStruc->Entity == CLIENT_ENTITY)
  {
    pConnStruc->HandshakeClntFinished[0] = (char) FinishedLen;
    memcpy(pConnStruc->HandshakeClntFinished+1,pDstBuf+DstIndex,FinishedLen);
  }
  else
  {
    pConnStruc->HandshakeSrvrFinished[0] = (char) FinishedLen;
    memcpy(pConnStruc->HandshakeSrvrFinished+1,pDstBuf+DstIndex,FinishedLen);
  }

  //----------------------------------------------------
  // Update Handshake Hashes
  //----------------------------------------------------
  HashHandshakeMessage(pConnStruc,pDstBuf,0, BufLen);

  pTxQel->DataLen = BufLen;
  //----------------------------------------------------
  // Enqueue TX-Quel for send
  //----------------------------------------------------
  EnqueueTxQel(pConnStruc,pTxQel);
  return(HSSL_OP_OK);
}

/**
* Verifies received finished handshake
* message from the stored messages MD5 and SHA1 MACS (ProcessFinished).
*
* Sender is contrary to the generation for verification !
*
*  @param pConnStruc Connection structure
*  @param InpBuf Buffer Base
*  @param InpOffset Start of data
*  @param DataLen data count
*
*  @return HSSL_OP_OK on success, else error occured
*/
static  int  ProcessFinished(CONNSTRU * pConnStruc,
		   char* InpBuf, int InpOffset, int DataLen,
		   int* pAlertType, int* pAlertLvl)
{
  int TotalLen;
  int Entity;

  int InpIndex = InpOffset;
  int Index=0;
  int MsgLen;

  char MacData[MD5_DIGEST_LEN+SHA_DIGEST_LEN];
  //-------------------------------------------------------
  // Preset Alert Type and Level to Illegal parameter/Fatal
  //-------------------------------------------------------
  pAlertType[0] = AD_ILLEGAL_PARAMETER;
  pAlertLvl[0]  = ALERT_LEVEL_FATAL;
  //----------------------------------------------------
  // Calculate Required Length
  //----------------------------------------------------
  if(pConnStruc->ActualProtocol == SSL_PROT_TYPE)		// 0 - SSL
    TotalLen = MD5_DIGEST_LEN + SHA_DIGEST_LEN;
  else							// TLS 1.0/1.1/1.2
    TotalLen = TLS_VERIFY_DATA_LEN;
  //----------------------------------------------------
  // Get/check Message length
  //----------------------------------------------------
  BIGchar2long(InpBuf,MsgLen,InpIndex);		// from 1st 4 bytes
  MsgLen &= 0xFFFFFF;				// only 3 bytes valid
  DataLen  -= HT_RECORD_HDR_SIZE;		// reduce length

  if((MsgLen != (int) DataLen) ||
     (MsgLen != TotalLen))
    return(HSSL_FINISHED_INVALID_MSGLEN);	// inconsistent data size
  //----------------------------------------------------
  // Save verify data for secure renegotiation
  //----------------------------------------------------
  if(pConnStruc->Entity == CLIENT_ENTITY)	// from server !
  {
    pConnStruc->HandshakeSrvrFinished[0] = (char) TotalLen;
    memcpy(pConnStruc->HandshakeSrvrFinished+1,InpBuf+InpIndex,TotalLen);
  }
  else
  {
    pConnStruc->HandshakeClntFinished[0] = (char) TotalLen;
    memcpy(pConnStruc->HandshakeClntFinished+1,InpBuf+InpIndex,TotalLen);
  }
  //----------------------------------------------------
  // calculate the hashes
  //----------------------------------------------------
  Entity =  pConnStruc->Entity;
  if(Entity == SERVER_ENTITY)			// reverse Entity meaning
    Entity = CLIENT_ENTITY;
  else
    Entity = SERVER_ENTITY;

  GenerateFinishedHashes(pConnStruc,MacData,0,Entity);
  //----------------------------------------------------
  // compare Finished hashes
  //----------------------------------------------------
  if(pConnStruc->ActualProtocol == SSL_PROT_TYPE){
    pAlertType[0] = AD_HSHAKE_FAILURE;
  } else {
    pAlertType[0] = AD_DECRYPT_ERROR;
  }
  do
  {
    if(InpBuf[InpIndex++] != MacData[Index++])
      return(HSSL_FINISHED_VERIFY_ERR);
    DataLen--;
  }while(DataLen != 0);
  //------------------------------------------------------
  // if server in normal handshake mode or client in short
  // handshake mode must hash the data !!!!
  //------------------------------------------------------
  if(pConnStruc->HandshakeMode != SSL_SHORT_HANDSHAKE_MODE)
  {
    //----------------------------------------------------
    // Normal handshake mode, server must hash data
    //----------------------------------------------------
    if(Entity == CLIENT_ENTITY)			// S E R V E R, see above !!
    {
      HashHandshakeMessage(pConnStruc,InpBuf,InpOffset,
			   TotalLen+HT_RECORD_HDR_SIZE);
    }
  }
  else
  {
    //----------------------------------------------------
    // Short handshake mode, client! must hash data
    //----------------------------------------------------
    if(Entity == SERVER_ENTITY)			// C L I E N T, see above !!
    {
      HashHandshakeMessage(pConnStruc,InpBuf,InpOffset,
			   TotalLen+HT_RECORD_HDR_SIZE);
    }
  }
  return(HSSL_OP_OK);
}
static bool m_is_expected_message(CONNSTRU* adsp_conn, 
                                  const uint16_t usp_message_type)
{
    uint16_t* auml_message_array = adsp_conn->usrc_expected_handshake_messages;
    unsigned int unl_index;
    if((adsp_conn->Entity == CLIENT_ENTITY) && 
        (HT_HELLO_REQUEST == usp_message_type)){
            // Clients always expect Hello Request. Since this is 0, we handle it explicitly, to use 0 as terminator.
            return true;
    }

    for(unl_index=0; 
        ((auml_message_array[unl_index] != 0) && (unl_index < EXPECTED_MSG_CNT));
        unl_index++){
            if(usp_message_type == auml_message_array[unl_index]){
                return true;
            }
    }
    return false;
}

/**
Overwrites the current expected handsahke message types with one new.
*/
static void m_set_expected_message(CONNSTRU* adsp_conn, 
                                   uint16_t usp_next_message)
{
    adsp_conn->usrc_expected_handshake_messages[0] = usp_next_message;
    adsp_conn->usrc_expected_handshake_messages[1] = 0;
}

/**
Adds the given handshake message type to the list of expected types.
*/
static void m_add_expected_message(CONNSTRU* adsp_conn, 
                                   uint16_t usp_next_message)
{
    unsigned int unl_index = 0;
    uint16_t* auml_message_array = adsp_conn->usrc_expected_handshake_messages;
    while(0 != auml_message_array[unl_index])
    {
        unl_index++;
        if(EXPECTED_MSG_CNT < unl_index){
            return;
        }
    }

    auml_message_array[unl_index] = usp_next_message;
    unl_index++;
    auml_message_array[unl_index] = 0;
}

static void m_set_msg_after_server_cert(CONNSTRU* adsp_conn){
    // Reset expected message
    m_set_expected_message(adsp_conn,0);
    switch(adsp_conn->KeyExchgMode){
    case KEY_EXCHANGE_RSA:
        if(SSL_PROT_TYPE == adsp_conn->ActualProtocol){
            // SSLv3 MAY use this. TLS must not
            m_set_expected_message(adsp_conn,HT_SERVER_KEY_EXCHANGE);
        }
    case KEY_EXCHANGE_DH_DSS:
    case KEY_EXCHANGE_DH_RSA:
        break;
    case KEY_EXCHANGE_DHE_DSS:
    case KEY_EXCHANGE_DHE_RSA:
    case KEY_EXCHANGE_ECDHE_RSA:
        m_set_expected_message(adsp_conn,HT_SERVER_KEY_EXCHANGE);
        return;
    default:
        return;
    }

    m_add_expected_message(adsp_conn, HT_CERTIFICATE_REQUEST);
    m_add_expected_message(adsp_conn, HT_SERVER_HELLO_DONE);
}

static void m_set_next_msg_client(CONNSTRU* adsp_conn, 
                                  uint16_t usp_processed_type)
{
    uint16_t usl_next_msg = 0;
    switch(usp_processed_type){
    case HT_HELLO_REQUEST:
        if(adsp_conn->RenegotiateMode != 0){
            m_set_expected_message(adsp_conn, HT_SERVER_HELLO);
        }
        break;
    case HT_SERVER_HELLO:
        if(adsp_conn->HandshakeMode == SSL_SHORT_HANDSHAKE_MODE) {
            usl_next_msg = uss_css_type;
        } else if( (KEY_EXCHANGE_DH_anon == adsp_conn->KeyExchgMode) ||
            (KEY_EXCHANGE_SRP == adsp_conn->KeyExchgMode))
        {
            usl_next_msg = HT_SERVER_KEY_EXCHANGE;
        } else {
            usl_next_msg = HT_CERTIFICATE;
        }
        m_set_expected_message(adsp_conn, usl_next_msg);
        break;
    case HT_CERTIFICATE:
        m_set_msg_after_server_cert(adsp_conn);
        break;
    case HT_SERVER_KEY_EXCHANGE:
        m_set_expected_message(adsp_conn, HT_CERTIFICATE_REQUEST);
        m_add_expected_message(adsp_conn, HT_SERVER_HELLO_DONE);
        break;
    case HT_CERTIFICATE_REQUEST:
        m_set_expected_message(adsp_conn, HT_SERVER_HELLO_DONE);
        break;
    case HT_SERVER_HELLO_DONE:
        m_set_expected_message(adsp_conn, uss_css_type);
        break;
    case HT_FINISHED:
    default:
        m_set_expected_message(adsp_conn, 0);
        break;
    }
}

static void m_set_msg_after_srv_hello(CONNSTRU* adsp_conn)
{
    if(adsp_conn->HandshakeMode == SSL_SHORT_HANDSHAKE_MODE){
        m_set_expected_message(adsp_conn, uss_css_type);
        return;
    }

    m_set_expected_message(adsp_conn,HT_CLIENT_KEY_EXCHANGE);

    if(((adsp_conn->AuthFlags & CLNT_AUTH_BIT_MASK) == 0) ||
        (adsp_conn->KeyExchgMode == KEY_EXCHANGE_SRP)){
        //No client auth
        return;
    }

    // In SSL v3, the Client Certificate is optional, in later versions, it is mandatory!
    if(adsp_conn->ActualProtocol == SSL_PROT_TYPE){
        m_add_expected_message(adsp_conn,HT_CERTIFICATE);
    } else {
        m_set_expected_message(adsp_conn,HT_CERTIFICATE);
    }
}

static void m_set_next_msg_server(CONNSTRU* adsp_conn, 
                                  uint16_t usp_processed_type)
{
    switch(usp_processed_type){
    case HT_CLIENT_HELLO_V2_LCL:
    case HT_CLIENT_HELLO:
        m_set_msg_after_srv_hello(adsp_conn);
        break;
    case HT_CERTIFICATE:
        m_set_expected_message(adsp_conn, HT_CLIENT_KEY_EXCHANGE);
        break;
    case HT_CLIENT_KEY_EXCHANGE:
        if((adsp_conn->CertifiedFlags & CLIENT_CERTIFIED_MASK) != 0){
            // Client provided certificate, Cert verify needed!
            m_set_expected_message(adsp_conn, HT_CERTIFICATE_VERIFY);
        } else {
            m_set_expected_message(adsp_conn, uss_css_type);
        }
        break;
    case HT_CERTIFICATE_VERIFY:
        m_set_expected_message(adsp_conn, uss_css_type);
        break;
    case HT_FINISHED:
        m_set_expected_message(adsp_conn, HT_CLIENT_HELLO);
        break;
    }
}

/**
* Processes/checks received TLS/SSL
* Handshake messages according to entity and actual receiver state (ProcessRX_Message).
*
* No checking of type of message has been done before.
*
*  @param pConnStruc Connection structure
*  @param MessageType 'Handshake type'
*  @param MsgBuf Buffer, including header
*  @param MsgOff Start of Data
*  @param MsgLen length, including header
*  @param pContStat Continue status on exit, TBD
*  @return HSSL_OP_OK on success, else error occured
*/
static int  ProcessRX_Message(CONNSTRU * pConnStruc,
		char MessageType, char* MsgBuf, int MsgOff, int MsgLen,
		int* pContStat)
{
  int Retcode = HSSL_OP_OK;

  int Entity;
  int LastMsg;
  int LclMsgType = MessageType;

  int pTmpAlertType[1];
  int pTmpAlertLvl[1];

#if defined XH_INTERFACE
  int CacheMode;
  HSERV_CACHE_ELEM SrvrCacheTemplate;
  HCLNT_CACHE_ELEM ClntCacheTemplate;
#endif

  //---------------------------------------------------------------
  // Check parameters
  //---------------------------------------------------------------
  if((pConnStruc == NULL) || (MsgBuf == NULL) || (pContStat == NULL))
    return(HSSL_NULL_PTR);
  
  if( ! m_is_expected_message(pConnStruc, static_cast<uint16_t>(MessageType)))
  {
      SendAlert(pConnStruc,AD_UNEXPECTED_MSG,ALERT_LEVEL_FATAL);
      pContStat[0] = STATUS_FATAL_ALERT_QUEUED;
      return (HSSL_RX_HSHAKE_UNEXPECTED_MSG);
  }
  pContStat[0] = STATUS_CONTINUE;
  Entity  =  pConnStruc->Entity;
  LastMsg = (int) pConnStruc->Handshake_RX_LastMessage & 0x0FF;
  //---------------------------------------------------------------
  // Do first check on Site specific message
  //---------------------------------------------------------------
  if(LclMsgType == HT_CERTIFICATE_VERIFY)	// transcode to internal
    LclMsgType = HT_CERTIFICATE_VERIFY_LCL;
  else if(LclMsgType == HT_CLIENT_HELLO_V2_LCL)
    LclMsgType = HT_CLIENT_HELLO;

  m_generate_log_msg(pConnStruc, "Processing Handshake msg type %i",MessageType, HL_AUX_WT_DATA1, "SSLRXM");
  switch(MessageType)
  {
    //------------------------------------------------------
    // Messages that can only be received by the client site
    //------------------------------------------------------
    case HT_HELLO_REQUEST:
    case HT_SERVER_HELLO:
    case HT_SERVER_KEY_EXCHANGE:
    case HT_CERTIFICATE_REQUEST:
    case HT_SERVER_HELLO_DONE:
      if((Entity != CLIENT_ENTITY) ||		// not for this site !
         ((LclMsgType <= LastMsg) &&		// normally invalid
	  (LclMsgType != HT_HELLO_REQUEST)))
      {
        SendAlert(pConnStruc,AD_UNEXPECTED_MSG,ALERT_LEVEL_FATAL);
        pContStat[0] = STATUS_FATAL_ALERT_QUEUED;
        if(Entity != CLIENT_ENTITY)
          return(HSSL_RX_HSHAKE_MSG_INVALID_SITE);
        else
          return(HSSL_RX_HSHAKE_MSG_INVAL_ORDER);
      }
      break;
    //------------------------------------------------------
    // Messages that can only be received by the server site
    //------------------------------------------------------
    case HT_CLIENT_HELLO_V2_LCL:
    case HT_CLIENT_HELLO:
    case HT_CLIENT_KEY_EXCHANGE:
    case HT_CERTIFICATE_VERIFY:
      if((Entity != SERVER_ENTITY) ||		// not for this site !!
         (LclMsgType <= LastMsg))		// always invalid
      {
        SendAlert(pConnStruc,AD_UNEXPECTED_MSG,ALERT_LEVEL_FATAL);
        pContStat[0] = STATUS_FATAL_ALERT_QUEUED;
        if(Entity != SERVER_ENTITY)
          return(HSSL_RX_HSHAKE_MSG_INVALID_SITE);
        else
          return(HSSL_RX_HSHAKE_MSG_INVAL_ORDER);
      }
      break;
    //-------------------------------------------------------------
    // Messages that can be received both by server and client site
    //-------------------------------------------------------------
    case HT_CERTIFICATE:
    case HT_FINISHED:
      if(LclMsgType > LastMsg) break;		// is valid
      SendAlert(pConnStruc,AD_UNEXPECTED_MSG,ALERT_LEVEL_FATAL);
      pContStat[0] = STATUS_FATAL_ALERT_QUEUED;
      return(HSSL_RX_HSHAKE_MSG_INVAL_ORDER);
    //-------------------------------------------------------------
    // Unknown message, always unexpected message alert
    //-------------------------------------------------------------
    default:
      SendAlert(pConnStruc,AD_UNEXPECTED_MSG,ALERT_LEVEL_FATAL);
      pContStat[0] = STATUS_FATAL_ALERT_QUEUED;
      return(HSSL_RX_HSHAKE_UNKNOWN_MSG);
  } // switch
  //-----------------------------------------------------------
  // Message is valid for appropriate site, is not a duplicate,
  // and is in order of the series of messages, distribute
  //-----------------------------------------------------------
  pTmpAlertType[0] = AD_RESERVED;		// preset
  pTmpAlertLvl[0]  = 0;				// dto.

  if(Entity == CLIENT_ENTITY)
  {
    //---------------------------------------------------------
    // Process the messages for the client site
    //---------------------------------------------------------
    switch(MessageType)
    {
      //---------------------------------------------------------
      // Server Hello request, either ignore or start renegotiate
      //-----------------------------------------------------------
      case HT_HELLO_REQUEST:
        Retcode = ProcessServerHelloReq(pConnStruc,
			MsgBuf,MsgOff,(int) MsgLen,
			pTmpAlertType,pTmpAlertLvl);
        if((Retcode != HSSL_OP_OK) ||			// error occured
           (pConnStruc->RenegotiateMode == 0))	// not started...
          break;
        Retcode = GenerateClientHello(pConnStruc);	// Start Renegotiate
        break;
      //---------------------------------------------------------
      // Server Hello
      //-----------------------------------------------------------
      case HT_SERVER_HELLO:
        Retcode = ProcessServerHello(pConnStruc,MsgBuf,MsgOff,MsgLen,
				     pTmpAlertType,pTmpAlertLvl);
        if(Retcode != HSSL_OP_OK) break;	// error occured
        break;
      //---------------------------------------------------------
      // Server Certificate
      //-----------------------------------------------------------
      case HT_CERTIFICATE:
        Retcode = ProcessCertificate(pConnStruc,MsgBuf,MsgOff,MsgLen,
				     pTmpAlertType,pTmpAlertLvl);
        break;
      //---------------------------------------------------------
      // Server Key Exchange
      //-----------------------------------------------------------
      case HT_SERVER_KEY_EXCHANGE:
        Retcode = ProcessServerKeyExchange(pConnStruc,MsgBuf,MsgOff,MsgLen,
			pTmpAlertType,pTmpAlertLvl);
        break;
      //---------------------------------------------------------
      // Certificate Request
      //-----------------------------------------------------------
      case HT_CERTIFICATE_REQUEST:
        Retcode = ProcessCertificateRequest(pConnStruc,MsgBuf,MsgOff,MsgLen,
		        pTmpAlertType,pTmpAlertLvl);
        break;
      //---------------------------------------------------------
      // Server Hello done
      //-----------------------------------------------------------
      case HT_SERVER_HELLO_DONE:
        Retcode = ProcessServerHelloDone(pConnStruc,MsgBuf,MsgOff,MsgLen,
			pTmpAlertType,pTmpAlertLvl);
        if(Retcode != HSSL_OP_OK) break;
        pTmpAlertLvl[0] = 0;			// signal Transmit mode!
        //---------------------------------------------------------
        // Set up the reply messages for transmit
        //---------------------------------------------------------
	//---------------------------------------------
        // Queue Certificate Message if required
	//---------------------------------------------
        if((pConnStruc->CertifiedFlags & CLIENT_CERT_REQ_MASK) != 0)
        {
          Retcode = GenerateCertificate(pConnStruc);
          if((Retcode != HSSL_OP_OK) &&
             (Retcode != HSSL_GENCERT_NO_CLIENT_CERT))
	    break;
        }
	//---------------------------------------------
        // Queue Client Key Exchange Message
	//---------------------------------------------
	Retcode = GenerateClientKeyExchange(pConnStruc);
	if(Retcode != HSSL_OP_OK) break;
	//---------------------------------------------
        // Queue Certificate Verify Message if required
	//---------------------------------------------
        if((pConnStruc->CertifiedFlags & CLIENT_CERT_VERIFY_MASK) != 0)
        {
          Retcode = GenerateCertificateVerify(pConnStruc);
          if(Retcode != HSSL_OP_OK) break;
        }
	//-------------------------------------------------
        // Queue Change Cipher spec p r o t o c o l element
	//-------------------------------------------------
        Retcode = GenerateChangeCipherSpec(pConnStruc);
        if(Retcode != HSSL_OP_OK) break;
	//---------------------------------------------
        // Queue Finished Message
	//---------------------------------------------
        Retcode = GenerateFinished(pConnStruc);
        break;
      //---------------------------------------------------------
      // Finished
      //-----------------------------------------------------------
      case HT_FINISHED:
        Retcode = ProcessFinished(pConnStruc,MsgBuf,MsgOff,MsgLen,
			pTmpAlertType,pTmpAlertLvl);
        if(Retcode != HSSL_OP_OK)
          break;
        if(pConnStruc->HandshakeMode != 0)	// resumed/cloned
        {
          pTmpAlertLvl[0] = 0;			// signal Transmit mode!
          //---------------------------------------------------------
          // Set up the resume reply messages for transmit
          //---------------------------------------------------------
	  //-------------------------------------------------
          // Queue Change Cipher spec p r o t o c o l element
	  //-------------------------------------------------
          Retcode = GenerateChangeCipherSpec(pConnStruc);
          if(Retcode != HSSL_OP_OK) break;
	  //---------------------------------------------
          // Queue Finished Message
	  //---------------------------------------------
          Retcode = GenerateFinished(pConnStruc);
          if(Retcode != HSSL_OP_OK) break;
	  LclMsgType = HT_SERVER_HELLO;		// advance expected message
  	}
        //-----------------------------------------------------------
        // Activate Short handshake mode, deactivate Renegotiate mode
        // Set the Renegotiate timer if used
        //-----------------------------------------------------------
        pConnStruc->HandshakeMode   = SSL_NORMAL_HANDSHAKE_MODE;
        pConnStruc->RenegotiateMode = SSL_RENEGOTIATE_NOT_ACTIVE;
        pConnStruc->ActualRenegotiateTimer = 0;

        SetRenegotiateTimer(pConnStruc, 0);

        //-----------------------------------------------------------
        // Process Session caching connected state here
        //-----------------------------------------------------------
#if defined XH_INTERFACE
        if((pConnStruc->ExtendedConfigFlags & SESS_CACHE_BIT_MASK) != 0)
        {
          //---------------------------------------------------------
          // Caching is enabled, prepare element, store to cache
          //---------------------------------------------------------
          memset(&ClntCacheTemplate,0,sizeof(HCLNT_CACHE_ELEM));
          ClntCacheTemplate.SelectedProtocol    = pConnStruc->ActualProtocol;
          ClntCacheTemplate.SelectedCipherSuite = pConnStruc->ActualCipherSuite;
          ClntCacheTemplate.SelectedComprMethod = pConnStruc->ActualComprMethod;

          memcpy(ClntCacheTemplate.ConnectionID,pConnStruc->ConnectionID,
		 MAX_CONNECTION_ID_LEN+1);

          memcpy(ClntCacheTemplate.SessionID,pConnStruc->SessionID,
		 MAX_SESSION_ID_LEN+1);

          memcpy(ClntCacheTemplate.MasterSecret,pConnStruc->MasterSecret,
	         MASTER_SECRET_LEN);

          HashPartnerCert(pConnStruc);
          memcpy(ClntCacheTemplate.PartnerCertHash,
		 pConnStruc->PartnerCertHash,SHA_DIGEST_LEN);

          ClntCacheTemplate.CertifiedFlags = pConnStruc->CertifiedFlags;

          CacheMode = ClientCacheSessionEstablished(
				CONN_pMemCtx(pConnStruc),
			        &ClntCacheTemplate,
				pConnStruc->CacheMode);
          if(CacheMode< 0)
            CacheMode = CACHE_SESSION_TYPE_NON_CACHE; // set non cachable now
          pConnStruc->CacheMode = (char) CacheMode;
        }
#endif

        pConnStruc->ConnectionState = CONN_STATE_CONNECTED;
        LclMsgType = 0;					// prepare for reneg.

//      DBG_PRINT("\nCONNECTED (CLIENT) !!!!");
        break;
    } // switch

    m_set_next_msg_client(pConnStruc, static_cast<uint16_t>(MessageType));
  } // client site
  else
  {
    //---------------------------------------------------------
    // Process the messages for the server site
    //---------------------------------------------------------
    switch(MessageType)
    {
      //---------------------------------------------------------
      // Client Hello, Client Hello SSL-V2
      //-----------------------------------------------------------
      case HT_CLIENT_HELLO_V2_LCL:
      case HT_CLIENT_HELLO:
        if(MessageType == HT_CLIENT_HELLO_V2_LCL)
          Retcode = ProcessV2_ClientHello(pConnStruc,MsgBuf,MsgOff,MsgLen,
			                  pTmpAlertType,pTmpAlertLvl);
        else
        {
          Retcode = ProcessClientHello(pConnStruc,MsgBuf,MsgOff,MsgLen,
			               pTmpAlertType,pTmpAlertLvl);
          HashHandshakeMessage(pConnStruc,MsgBuf,MsgOff,MsgLen);
        }
        if(Retcode != HSSL_OP_OK)
        {
          if(Retcode != HSSL_CLNT_HELLO_NO_RENEGOTIATE) break;
          //-----------------------------------------------------
          // Remote renegotiation not supported, send alert, stop
          //-----------------------------------------------------
          SendAlert(pConnStruc,AD_NO_RENEGOTIATION,ALERT_LEVEL_WARNING);
          LclMsgType = 0;		// prepare for next client hello
          Retcode = HSSL_OP_OK;
          break;
        }
        pTmpAlertLvl[0] = 0;		// signal from transmit
        //---------------------------------------------
        // Queue Server Hello Message (all cases)
	//---------------------------------------------
        Retcode = GenerateServerHello(pConnStruc);
        if(Retcode != HSSL_OP_OK) break;
        LclMsgType = HT_CLIENT_HELLO;		// set received message
        //---------------------------------------------
        // Check if new or resumed/cloned connection
	//---------------------------------------------
        if(pConnStruc->HandshakeMode == SSL_NORMAL_HANDSHAKE_MODE) // new
        {
	  //---------------------------------------------
          // new session only
	  //---------------------------------------------
	  //---------------------------------------------
          // Queue Certificate Message, if not SRP
	  //---------------------------------------------
           if( KEY_EXCHANGE_SRP != pConnStruc->KeyExchgMode ){
              Retcode = GenerateCertificate(pConnStruc);
              if(Retcode != HSSL_OP_OK) break;
           }
	  //---------------------------------------------
          // Queue Server Key Exchange Message if required
	  //---------------------------------------------
          if((pConnStruc->CertifiedFlags & SERVER_KEY_EXCHG_REQ_MASK) != 0)
	  {
            Retcode = GenerateServerKeyExchange(pConnStruc);
            if(Retcode != HSSL_OP_OK) break;
          }     
	  //----------------------------------------------
          // Queue Certificate Request message if required
	  //----------------------------------------------
          if((pConnStruc->AuthFlags & CLNT_AUTH_BIT_MASK) != 0)
	  {
            Retcode = GenerateCertificateRequest(pConnStruc);
            if(Retcode != HSSL_OP_OK) break;
          }     
	  //----------------------------------------------
          // Queue Server Hello done
	  //----------------------------------------------
          Retcode = GenerateServerHelloDone(pConnStruc);
          break;
        }
	else
        {        
	  //----------------------------------------------
	  // resumed/cloned session
          //----------------------------------------------
//          LclMsgType = HT_CLIENT_HELLO;		// set received message
          //-------------------------------------------------
          // Queue Change Cipher spec p r o t o c o l element
          //-------------------------------------------------
          Retcode = GenerateChangeCipherSpec(pConnStruc);
          if(Retcode != HSSL_OP_OK) break;
 	  //---------------------------------------------
	  // Queue Finished Message
	  //---------------------------------------------
          Retcode = GenerateFinished(pConnStruc);
        }
        break;
      //---------------------------------------------------------
      // Client Certificate
      //-----------------------------------------------------------
      case HT_CERTIFICATE:
        Retcode = ProcessCertificate(pConnStruc,MsgBuf,MsgOff,MsgLen,
			pTmpAlertType,pTmpAlertLvl);
        break;
      //---------------------------------------------------------
      // Client Key Exchange
      //-----------------------------------------------------------
      case HT_CLIENT_KEY_EXCHANGE:
        Retcode = ProcessClientKeyExchange(pConnStruc,MsgBuf,MsgOff,MsgLen,
			pTmpAlertType,pTmpAlertLvl);
        break;
      //---------------------------------------------------------
      // Certificate Verify
      //---------------------------------------------------------
      case HT_CERTIFICATE_VERIFY:
        Retcode = ProcessCertificateVerify(pConnStruc,MsgBuf,MsgOff,MsgLen,
			pTmpAlertType,pTmpAlertLvl);
        break;
      //---------------------------------------------------------
      // Finished
      //---------------------------------------------------------
      case HT_FINISHED:
        Retcode = ProcessFinished(pConnStruc,MsgBuf,MsgOff,MsgLen,
			pTmpAlertType,pTmpAlertLvl);
        if(Retcode != HSSL_OP_OK) break;

        LclMsgType = 0;				// prepare for reneg.
        if(pConnStruc->HandshakeMode == SSL_NORMAL_HANDSHAKE_MODE) // new
        {
          //-------------------------------------------------
          // Queue Change Cipher spec p r o t o c o l element
          //-------------------------------------------------
          Retcode = GenerateChangeCipherSpec(pConnStruc);
          if(Retcode != HSSL_OP_OK) break;
	  //---------------------------------------------
          // Queue Finished Message
	  //---------------------------------------------
          Retcode = GenerateFinished(pConnStruc);
          if(Retcode != HSSL_OP_OK) break;
        }
        pConnStruc->ConnectionState = CONN_STATE_CONNECTED;
        //-----------------------------------------------------------
        // Activate Short handshake mode, deactivate Renegotiate mode
        // Set the Renegotiate timer if used
        //-----------------------------------------------------------
        pConnStruc->HandshakeMode   = SSL_NORMAL_HANDSHAKE_MODE;
        pConnStruc->RenegotiateMode = SSL_RENEGOTIATE_NOT_ACTIVE;
        pConnStruc->ActualRenegotiateTimer = 0;
        SetRenegotiateTimer(pConnStruc, 0);

        //-----------------------------------------------------------
        // Process Session caching connected state here
        //-----------------------------------------------------------
#if defined XH_INTERFACE
        if((pConnStruc->ExtendedConfigFlags & SESS_CACHE_BIT_MASK) != 0)
        {
          //---------------------------------------------------------
          // Caching is enabled, prepare element, store to cache
          //---------------------------------------------------------
          memset(&SrvrCacheTemplate,0,sizeof(HSERV_CACHE_ELEM));
          SrvrCacheTemplate.SelectedProtocol    = pConnStruc->ActualProtocol;
          SrvrCacheTemplate.SelectedCipherSuite = pConnStruc->ActualCipherSuite;
          SrvrCacheTemplate.SelectedComprMethod = pConnStruc->ActualComprMethod;

          memcpy(SrvrCacheTemplate.SessionID,pConnStruc->SessionID,
		 MAX_SESSION_ID_LEN+1);

          memcpy(SrvrCacheTemplate.MasterSecret,pConnStruc->MasterSecret,
	         MASTER_SECRET_LEN);

          HashPartnerCert(pConnStruc);
          memcpy(SrvrCacheTemplate.PartnerCertHash,
		 pConnStruc->PartnerCertHash,SHA_DIGEST_LEN);

          SrvrCacheTemplate.CertifiedFlags = pConnStruc->CertifiedFlags;

          CacheMode = ServerCacheSessionEstablished(
				CONN_pMemCtx(pConnStruc),
			        &SrvrCacheTemplate,
				pConnStruc->CacheMode);
          if(CacheMode != 0)
            pConnStruc->CacheMode = CACHE_SESSION_TYPE_NON_CACHE;
        }
#endif
//        DBG_PRINT("\nCONNECTED !!! (Server)");
        break;
    } // Server Message Switch
    
    m_set_next_msg_server(pConnStruc, static_cast<uint16_t>(MessageType));
  } // Client/Server
  //-------------------------------------------------------------------
  // global error processing/Alert generation, next state saving
  //-------------------------------------------------------------------
  pConnStruc->Handshake_RX_LastMessage = (char) LclMsgType;	// set processed Msg.
  if(Retcode == HSSL_OP_OK) return(Retcode);		// everything is fine
  //------------------------------------------------------
  // An error or alert request is present, process
  //------------------------------------------------------
  if(pTmpAlertLvl[0] != 0)			// from message processing
  {
    SendAlert(pConnStruc,pTmpAlertType[0],pTmpAlertLvl[0]);
    if(pTmpAlertLvl[0] == ALERT_LEVEL_WARNING)
      return(HSSL_OP_OK);			// keep on processing
  }
  else
    SendAlert(pConnStruc,AD_INTERNAL_ERROR,ALERT_LEVEL_FATAL);

  pContStat[0] = STATUS_FATAL_ALERT_QUEUED;	// Fatal Alert queued
  return(Retcode);
}

#if !defined XH_INTERFACE		// alternate used

/**
* Sends data from the actual transmit
* buffer, fetches next data to send from Priority / Application
* Transmit Queue, compresses and encrypt the data and prepares
* for next send (HSSL_Tcp_Transmit).
* Except for Change Cipher Spec, Alerts and Session Close
*       Message the TX-Quels will be fragmented if necessary or
*	 coalesced if possible.
*
*  @param pConnStruc Connection structure
*  @param pContStat Continue State
*  @param pShutdownReason Reason in case of Shutdown Req.
*
*  @return HSSL_OP_OK on success, error code otherwise
*/
static int  HSSL_Tcp_Transmit(CONNSTRU * pConnStruc,
				   int* pContStat,
				   int* pShutdownReason)
{
  int Retcode;

  char TxType = 0;
  char TxProt = 0;
  
  int SrcBufLen = 0;
  int DstBufLen;
  int BufLen;
  int AddLen = 0;
  int SendDataCount = 0;
  int Index = 0;
  int TxState = -1;

  char* pSrcBuf = NULL;
  char* pDstBuf;
  char* pBuf;

  TX_QEL * pStartTxQel;

  int pTmpLen[1];
  //------------------------------------------------------
  // Check Parameters
  //------------------------------------------------------
  if((pConnStruc == NULL) || (pContStat == NULL) ||
     (pShutdownReason == NULL))
    return(HSSL_NULL_PTR);
  pContStat[0]  = STATUS_CONTINUE;
  pShutdownReason[0] = 0;
  //------------------------------------------------------
  // Check if TX is in progress
  //------------------------------------------------------
//  DBG_PRINT("\nHSSL_TCP TX Start");
  for(;;)				// Transmit loop
  {
    TxState = pConnStruc->TX_State;
    switch(TxState)
    {
      //------------------------------------------------
      // Current Send buffer is empty, check queues
      //------------------------------------------------
      case TCP_TX_INACTIVE:		// idle
        if((pConnStruc->pPriorityTxQueueHead == NULL) &&
           (pConnStruc->pApplicationTxQueueHead == NULL))
          return(HSSL_OP_OK);			// no action required
        //---------------------------------------------------
        // Check what queue to service
        //---------------------------------------------------
        if((pConnStruc->pApplicationTxQueueHead != NULL) && // application data
	   (pConnStruc->pPriorityTxQueueHead == NULL))	// no priority data
        {
          //========================================================
          // Only Application data queued, check if Handshake active
          //========================================================
          if(pConnStruc->ConnectionState != CONN_STATE_CONNECTED)
            return(HSSL_OP_OK);				// do NOT send
          pStartTxQel = pConnStruc->pApplicationTxQueueHead;// get Structure
          TxType = pStartTxQel->Type;		// get type
          TxProt = pStartTxQel->ProtocolType;	// get protocol
          //---------------------------------------------------
          // gather all Application Data until buffer filled/Last
          //---------------------------------------------------
          SendDataCount = GatherTxQelsLengths(pStartTxQel,TxType);
        }
        else
        {
          //================================================
          // Data on Priority queue, service first (!)
          //================================================
          pStartTxQel = pConnStruc->pPriorityTxQueueHead;// get Structure
          TxType = pStartTxQel->Type;		// get type
          TxProt = pStartTxQel->ProtocolType;	// get protocol
          if(TxType == TX_TYPE_SHUTDOWN)		// immediate Shutdown
          {
             PurgeTxQueues(pConnStruc);			// release queues
             pContStat[0] = STATUS_MUST_CLOSE_IMMEDIATE;	// shutdown
//	     DBG_PRINT("LCL Shutdown\n");
	     return(HSSL_TX_LOCAL_SHUTDOWN);
          }
	  if(TxType == TX_TYPE_HANDSHAKE_MSG)		// special case
          {
            SendDataCount = GatherTxQelsLengths(pStartTxQel,TxType);
          }
          else
          {
            SendDataCount = (int) pStartTxQel->DataLen;
          }
        }
        //-----------------------------------------------------
        // Calculate required Source/Destination buffer lengths
        //-----------------------------------------------------
	BufLen = 0;			// no hash, no encryption
        AddLen = 0;			// no additional length (TLS V1.1)

	if(pConnStruc->ActTX_MACAlgor != MAC_ALGOR_NULL)
	  BufLen = pConnStruc->HashSize;
	if((pConnStruc->ActTX_EncAlgor != CIPHER_ALGOR_NULL) &&
	   (pConnStruc->CipherType == ALGOR_TYPE_BLOCK))
        {
	  BufLen += pConnStruc->BlockLen;
          if((pConnStruc->ActualProtocol == TLS_V1_PROT_TYPE) ||	// TLS V1.1,CBC
             (pConnStruc->ActualProtocol == TLS_V2_PROT_TYPE))
          {
   	    BufLen += pConnStruc->BlockLen;
            AddLen = pConnStruc->BlockLen;
          }
        }
	//------------------------------------------------
	// Get Compression buffer length if needed
	//------------------------------------------------
	SrcBufLen = SendDataCount+AddLen+RECORD_HDR_SIZE; // plain buf. length
	DstBufLen = 0;				// no additional buffer
	if(pConnStruc->ActTX_ComprAlgor == COMPR_NULL)
	  SrcBufLen += BufLen;			// prepare for MAC/Encrypt
	else
	{
	  if(SendDataCount > (SSL_COMPR_ADDITIONAL_LEN/2))	// < 0.5 k
	    DstBufLen = SrcBufLen + SSL_COMPR_ADDITIONAL_LEN;	// + 1k        
	  else
	    DstBufLen = (SendDataCount * 2) + RECORD_HDR_SIZE;	// double
	  DstBufLen += (BufLen+COMPR_V42_LEN_SIZE); // add space, MAC/Encrypt
        }
        //----------------------------------------------------------
        // Save Type,Protocol, Transmit Count, Src/Dst-Bufferlengths
        //----------------------------------------------------------
        pConnStruc->TxFragmentToWriteCount = (int) SendDataCount;
        pConnStruc->TxFragmentType = TxType;
        pConnStruc->TxFragmentProt = TxProt;
	pConnStruc->TxFragSrcBufLen = SrcBufLen;	// save for later
	pConnStruc->TxFragmentIndex     = DstBufLen;	// dto.
	pConnStruc->TxFragmentOffset       = AddLen;	// dto.
      //------------------------------------------------
      // Waiting for Send Src-Buffer
      //------------------------------------------------
      case TCP_TX_SRCBUF_WAIT:
	SrcBufLen = pConnStruc->TxFragSrcBufLen;
        pSrcBuf = BIT8_ARRAY_ALLOC_POOL(HMEM_CTX_REF,SrcBufLen); // get buffer
        if(pSrcBuf == NULL)				    // no buffer yet
        {
          pConnStruc->TX_State = TCP_TX_SRCBUF_WAIT;    // next State
          return(HSSL_OP_OK);
        }
	if(pConnStruc->TX_State == TCP_TX_SRCBUF_WAIT) // was a re-entry !!
        {
          SendDataCount = pConnStruc->TxFragmentToWriteCount;
	  TxType	= pConnStruc->TxFragmentType;
	  TxProt	= pConnStruc->TxFragmentProt;
	  DstBufLen	= pConnStruc->TxFragmentIndex;
          AddLen        = pConnStruc->TxFragmentOffset;
	}
        //-------------------------------------------------------------------
        // Got send buffer, format source data buffer (empty record header !)
        //-------------------------------------------------------------------
        pConnStruc->pTxFragmentBuffer = pSrcBuf;		// save buffer
 
        Retcode = GatherTxQelsData(pConnStruc);		// get the buffer
        if(Retcode != HSSL_OP_OK)
        {
          FREE_ARRAY_POOL(HMEM_CTX_REF,pSrcBuf);	// free
          pConnStruc->pTxFragmentBuffer = NULL;
          PurgeTxQueues(pConnStruc);			// release queues
          pContStat[0] = STATUS_MUST_CLOSE_IMMEDIATE;
	  pShutdownReason[0] = GATHER_FAILURE;
//	  DBG_PRINT("Gather Failed: ");
//        DBG_PRINT_INT_NL(Retcode);
          return(Retcode);
        }
      //------------------------------------------------------------
      // Waiting for Send Copy-Buffer (for Compression), if required
      //------------------------------------------------------------
      case TCP_TX_DSTBUF_WAIT:
        pDstBuf = NULL;
        DstBufLen	= pConnStruc->TxFragmentIndex;	// get length
	if(DstBufLen != 0)
        {
          pDstBuf = BIT8_ARRAY_ALLOC_POOL(HMEM_CTX_REF,DstBufLen);// get buffer
          if(pDstBuf == NULL)				    // no buffer yet
          {
            pConnStruc->TX_State = TCP_TX_DSTBUF_WAIT;    // next State
            return(HSSL_OP_OK);
          }
	  if(pConnStruc->TX_State == TCP_TX_DSTBUF_WAIT) // was re-entry !!
          {
            SendDataCount = pConnStruc->TxFragmentToWriteCount;
	    TxType	  = pConnStruc->TxFragmentType;
	    TxProt	  = pConnStruc->TxFragmentProt;
	    SrcBufLen	  = pConnStruc->TxFragSrcBufLen;
	    pSrcBuf	  = pConnStruc->pTxFragmentBuffer;
            AddLen        = pConnStruc->TxFragmentOffset;
          }
        }
        //------------------------------------------------
        // Format the Record Header in appropriate buffer
        //------------------------------------------------
	pBuf   = pSrcBuf;			// assume w/o. compression
	BufLen = SrcBufLen;
	if(DstBufLen != 0)
	{
	  pBuf   = pDstBuf;	// is with compression
	  BufLen = DstBufLen;
        }
        Index = 0;
        switch(TxType)
        {
          case TX_TYPE_APPLICATION_DATA:
            pBuf[Index++] = CT_APPLICATION_DATA;
            break;

          case TX_TYPE_CHANGE_CIPHER_SPEC:
            pBuf[Index++] = CT_CHANGE_CIPHER_SPEC;
            break;

          case TX_TYPE_ALERT_WARNING:
	  case TX_TYPE_ALERT_FATAL:
            pBuf[Index++] = CT_ALERT;
            break;

          case TX_TYPE_HANDSHAKE_MSG:
            pBuf[Index++] = CT_HANDSHAKE;
            break;

          default:
            pBuf[Index++] = 0;			// should not happen
            break;
        } // switch

        pBuf[Index++] = TLS_SSL_MAJOR_VERSION;	// set version MSB
        switch(TxProt){
          case TLS_V2_PROT_TYPE:
            pBuf[Index++] = TLS12_MINOR_VERSION;	// set Version LSB
            break;
          case TLS_V1_PROT_TYPE:
            pBuf[Index++] = TLS11_MINOR_VERSION;	// set Version LSB
            break;
          case TLS_PROT_TYPE:
            pBuf[Index++] = TLS10_MINOR_VERSION;	// set Version LSB
            break;
          default:
            pBuf[Index++] = SSL_MINOR_VERSION;	// dto.
            break;
        }
        //------------------------------------------------
        // Compress the Data if required
        //------------------------------------------------

	if(DstBufLen != 0)
        {
          pTmpLen[0] = DstBufLen;
          Retcode = CompressRecord(pConnStruc,pSrcBuf,AddLen+RECORD_HDR_SIZE,
				   SendDataCount,
				   pDstBuf,AddLen+RECORD_HDR_SIZE,pTmpLen);
          if(Retcode != HSSL_OP_OK)
          {
//          DBG_PRINT("TXCompress Error !!\n");
            FREE_ARRAY_POOL(HMEM_CTX_REF,pSrcBuf);		// free
            FREE_ARRAY_POOL(HMEM_CTX_REF,pDstBuf);		// free
            pConnStruc->pTxFragmentBuffer = NULL;
            PurgeTxQueues(pConnStruc);			// release queues
            pContStat[0] = STATUS_MUST_CLOSE_IMMEDIATE;
	    pShutdownReason[0] = COMPRESS_FAILURE;
            return(Retcode);
          }    
	  pConnStruc->pTxFragmentBuffer = pBuf;		// set alternate buffer
          SendDataCount = pTmpLen[0];
	  pConnStruc->TxFragmentIndex = 0;		// set index zero !!
	  FREE_ARRAY_POOL(HMEM_CTX_REF,pSrcBuf);	// free the other
        }
        //--------------------------------------------------------------
        // Prepend Random Data block when TLS V1.1 CBC is selected
        //--------------------------------------------------------------
        if(AddLen != 0)
        {
	  Retcode = SecDrbgRandBytes(HMEM_CTX_REF1 pBuf,RECORD_HDR_SIZE,AddLen);
          if(Retcode != 0)
          {
            FREE_ARRAY_POOL(HMEM_CTX_REF,pBuf);		// free
            pConnStruc->pTxFragmentBuffer = NULL;
            PurgeTxQueues(pConnStruc);			// release queues
            pContStat[0] = STATUS_MUST_CLOSE_IMMEDIATE;
	    pShutdownReason[0] = RAND_PREPEND_FAILURE;
//          DBG_PRINT("CBC Random append Failed\n");
            return(Retcode);
          }
        }
        //--------------------------------------------------------------
        // Append the Cipher MAC (Buffer is large enough !)
        //--------------------------------------------------------------
        BIGword2charn((SendDataCount+AddLen),pBuf,Index);// set length of data
	pTmpLen[0] = SendDataCount+AddLen;		// save for calls

        Retcode = AppendCipherMac(pConnStruc,pBuf,0,pTmpLen,BufLen);
        if(Retcode != HSSL_OP_OK)
        {
          FREE_ARRAY_POOL(HMEM_CTX_REF,pBuf);		// free
          pConnStruc->pTxFragmentBuffer = NULL;
          PurgeTxQueues(pConnStruc);			// release queues
          pContStat[0] = STATUS_MUST_CLOSE_IMMEDIATE;
	  pShutdownReason[0] = MAC_APPEND_FAILURE;
//	  DBG_PRINT("MAC append Failed\n");
          return(Retcode);
        }
        // SendDataCount = pTmpLen[0];
        //--------------------------------------------------------------
        // Encrypt the Data (Buffer is large enough !)
        //--------------------------------------------------------------
        Retcode = EncryptRecord(pConnStruc,pBuf,RECORD_HDR_SIZE,
				pTmpLen,BufLen);
        if(Retcode != HSSL_OP_OK)
        {
          FREE_ARRAY_POOL(HMEM_CTX_REF,pBuf);		// free
          pConnStruc->pTxFragmentBuffer = NULL;
          PurgeTxQueues(pConnStruc);			// release queues
          pContStat[0] = STATUS_MUST_CLOSE_IMMEDIATE;
	  pShutdownReason[0] = ENCRYPT_FAILURE;
//	  DBG_PRINT("Encrypt Failed\n");
          return(Retcode);
        }    

        //------------------------------------------------
        // Set the final record length
        //------------------------------------------------
        SendDataCount = pTmpLen[0];
        BIGword2charn(SendDataCount,pBuf,Index); // set length of data

        pConnStruc->TxFragmentToWriteCount = SendDataCount+RECORD_HDR_SIZE;
	pConnStruc->TX_State = TCP_TX_FRAGMENT_WRITE;

      //------------------------------------------------
      // Transmit active, try to send TCP data
      //------------------------------------------------
      case TCP_TX_FRAGMENT_WRITE:
        SendDataCount = pConnStruc->TxFragmentToWriteCount;
	pBuf          = pConnStruc->pTxFragmentBuffer;
        Retcode = HLSSL_CallBack(TCP_SEND_FUNCTION,pConnStruc->SocketIndex,pBuf,pConnStruc->TxFragmentIndex,SendDataCount);
        if(Retcode < 0)
        {
          if(Retcode == -2)			// TX-Timeout
          {
	    if(pConnStruc->ConnectionState != CONN_STATE_CONNECTED) // connect.
              return(Retcode);
          }  
          FREE_ARRAY_POOL(HMEM_CTX_REF,pBuf);	// free
          pConnStruc->pTxFragmentBuffer = NULL;
          PurgeTxQueues(pConnStruc);			// release queues
          pContStat[0] = STATUS_TCP_TX_ERROR;	// closed/error
          return(HSSL_TX_TCP_ERROR);
        }
        if(pConnStruc->ConnectionState == CONN_STATE_CONNECTED)
        {
          ADD_64(pConnStruc->TXDataMSW,pConnStruc->TXDataLSW,
	         (int) Retcode);
        }
        SendDataCount -= Retcode;		// check remaining amount
        if(SendDataCount != 0)			// must wait for more to send
        {
          pConnStruc->TxFragmentIndex  += Retcode;	// increment index
          pConnStruc->TxFragmentToWriteCount = SendDataCount;// save remaining
          return(HSSL_OP_OK);
        }
        //-----------------------------------------------------------
        // Block was sent, free buffer, check special action required
        //-----------------------------------------------------------
        FREE_ARRAY_POOL(HMEM_CTX_REF,pBuf);	// free
        pConnStruc->pTxFragmentBuffer = NULL;
	pConnStruc->TX_State = TCP_TX_INACTIVE;
        switch(TxType)
        {
          //--------------------------------------------------
	  // Change Ciphersuite transmitted, make pending TX-States
          // the actual states, clear the TX-pending states
          //--------------------------------------------------
          case TX_TYPE_CHANGE_CIPHER_SPEC:
            Retcode = CopyPendingToActCipherStates(pConnStruc,1);
            ClearPendingCiphStates(pConnStruc,1);
            if(Retcode == HSSL_OP_OK)
              break;
            //------------------------------------------
	    // Change Ciphersuite TX Error, terminate
            //------------------------------------------
            PurgeTxQueues(pConnStruc);			// release queues
            pContStat[0] = STATUS_MUST_CLOSE_IMMEDIATE;
	    pShutdownReason[0] = TX_CHG_CIPHERSUITE_ERR;
            return(Retcode);
          //--------------------------------------------------
	  // Alert, Level Fatal transmitted, close down
          //--------------------------------------------------
          case TX_TYPE_ALERT_FATAL:
            PurgeTxQueues(pConnStruc);			// release queues
            pContStat[0] = STATUS_MUST_CLOSE_IMMEDIATE;
	    pShutdownReason[0] = TX_FATAL_ALERT;
            return(HSSL_OP_OK);
        } // Special TX type Switch
    } // Distribution Switch
  } // Send FOR        
}
#endif // !defined XH_INTERFACE

#if defined XH_INTERFACE	// alternate for other interface

/**
* Implements TCP transmit of WSP C interface (m_xh_transmit).
*
* As required, it:
* <ol>
*  <li> Fetches new TLSPlaintext fragment(s) from application- or priority-
*        (non-application)queue.
*  <li> Allocates requried buffers.
*  <li> Encodes the fragment(s) according to active compression, MAC and 
*        encryption algorithms.
*  <li> Copies the record to the sending buffer.
*  <li> Performs postprocessing as required: <ul>
*     <li> Releases buffers.
*     <li> Switches to new cipher state.
*     <li> Shuts down after fatal errors.
*  </ul></ol>
*     
* Depending on it's state, this routine may jump in at any point in the list
* above and works itself downwards. Postprocessing is done in an indiviual call,
* the function returns, after writing to send buffer.
*
* Except for Change Cipher Spec, Alerts and Session Close
*       Message the TX-Quels will be fragmented if necessary or
*	 coalesced if possible.
*
* Does not perform any checks on parameters. Does not perform any network
* send operations.
*
*  @see HSSL_XH2Tcp_Transmit HSSL_XH3Tcp_Transmit HSSL_XHCLTcp_Transmit 
*        HSSL_XH3ATcp_Transmit
*
*  @param pConnStruc          Pointer to used connection structure
*  @param pContStat           Continuation state
*  @param pShutdownReason     Reason in case of shutdown request
*  @param bop_check_app_queue TRUE, if application data may be sent, FALSE,
*                             if only the priority queue is to be checked
*  @param ppDstBufBase        Pointer to the base of the send buffer
*  @param pDstBufTop          End of the send buffer
*
*  @return HSSL_OP_OK on success, error code otherwise
*/
static int  m_xh_transmit( CONNSTRU * pConnStruc, int* pContStat, 
                            int* pShutdownReason, BOOL bop_check_app_queue, 
                            char ** ppDstBufBase, char * pDstBufTop)
{
  int Retcode;

  char TxType = 0;
  char TxProt = 0;
  
  int SrcBufLen = 0;
  int DstBufLen,BufLen;
  int AddLen = 0;
  int SendDataCount = 0;
  int Index = 0;
  int TxState = -1;

  char* pSrcBuf = NULL;
  char* pDstBuf;
  char* pBuf;

  TX_QEL * pStartTxQel;

  int pTmpLen[1];
  
  HMEM_CTX_DEF1;
  //------------------------------------------------------
  // Setup Parameters
  //------------------------------------------------------
  pContStat[0]  = STATUS_CONTINUE;
  pShutdownReason[0] = 0;

  LOAD_HMEM_CTX_PTR(CONN_pMemCtx(pConnStruc));
  //------------------------------------------------------
  // Check if last TX-Buffer has been processed
  //------------------------------------------------------
//  DBG_PRINT("\nHSSL_TCP TX Start");

  TxState = pConnStruc->TX_State;
  switch(TxState)
  {
    //------------------------------------------------
    // Current Send buffer is empty, check queues
    //------------------------------------------------
    case TCP_TX_INACTIVE:		// idle
      if((pConnStruc->pPriorityTxQueueHead == NULL) &&
         (pConnStruc->pApplicationTxQueueHead == NULL))
        return(HSSL_OP_OK);			// Send queues empty
      //---------------------------------------------------
      // Check what queue to service
      //---------------------------------------------------
      if((pConnStruc->pPriorityTxQueueHead != NULL))	// Priority data
      {
        //================================================
        // Data on Priority queue, service first
        //================================================
        pStartTxQel = pConnStruc->pPriorityTxQueueHead;// get Structure
        TxType = pStartTxQel->Type;		// get type
        TxProt = pStartTxQel->ProtocolType;		// get protocol
        if(TxType == TX_TYPE_SHUTDOWN)			// immediate Shutdown
        {
           PurgeTxQueues(pConnStruc);			// release queues
           pContStat[0] = STATUS_MUST_CLOSE_IMMEDIATE;	// shutdown
//	   DBG_PRINT("LCL Shutdown\n");
           return(HSSL_TX_LOCAL_SHUTDOWN);
        }
        if(TxType == TX_TYPE_HANDSHAKE_MSG)		// special case
        {
          SendDataCount = GatherTxQelsLengths(pStartTxQel,TxType);
        }
        else
        {
          SendDataCount = (int) pStartTxQel->DataLen;
        }
      } else if(bop_check_app_queue &&
         (pConnStruc->pApplicationTxQueueHead != NULL))
      {
        //========================================================
        // Only Application data queued, check if connection is established
        //========================================================
        if(pConnStruc->ConnectionState != CONN_STATE_CONNECTED)
          return(HSSL_OP_OK);				// do NOT send
        pStartTxQel = pConnStruc->pApplicationTxQueueHead;// get Structure
        TxType = pStartTxQel->Type;		// get type
//      TxProt = TX_QEL_ProtType(pStartTxQel);		// get protocol WRONG!
        TxProt = pConnStruc->ActualProtocol;		// replace with current
        //---------------------------------------------------
        // gather all Application Data until buffer filled/Last
        //---------------------------------------------------
        SendDataCount = GatherTxQelsLengths(pStartTxQel,TxType);
      }     
      
      //-----------------------------------------------------
      // Calculate required Source/Destination buffer lengths
      //-----------------------------------------------------
      BufLen = 0;				// no hash, no encryption
      AddLen = 0;				// no additional len (TLS V1.1)

      if(pConnStruc->ActTX_MACAlgor != MAC_ALGOR_NULL)
        BufLen = pConnStruc->HashSize;
      if((pConnStruc->ActTX_EncAlgor != CIPHER_ALGOR_NULL) &&
	 (pConnStruc->CipherType == ALGOR_TYPE_BLOCK))
      {
        BufLen += pConnStruc->BlockLen;
        if((pConnStruc->ActualProtocol == TLS_V1_PROT_TYPE) || // TLS V1.1/1.2,CBC
           (pConnStruc->ActualProtocol == TLS_V2_PROT_TYPE))
        {
   	  BufLen += pConnStruc->BlockLen;
          AddLen = pConnStruc->BlockLen;
        }
      }

      if(pConnStruc->ActTX_EncAlgor == CIPHER_ALGOR_AES_GCM) {
          BufLen += AES_GCM_EXPL_IV_LEN;
          AddLen = AES_GCM_EXPL_IV_LEN;
      }

      //------------------------------------------------
      // Get Compression buffer length if needed
      //------------------------------------------------
      SrcBufLen = SendDataCount+AddLen+RECORD_HDR_SIZE;	// plain buffer length
      DstBufLen = 0;				// no additional buffer
      if(pConnStruc->ActTX_ComprAlgor == COMPR_NULL)
        SrcBufLen += BufLen;			// prepare for MAC/Encrypt
      else
      {
        if(SendDataCount > (SSL_COMPR_ADDITIONAL_LEN/2))	// < 0.5 k
          DstBufLen = SrcBufLen + SSL_COMPR_ADDITIONAL_LEN;	// + 1k        
        else
          DstBufLen = (SendDataCount * 2) + RECORD_HDR_SIZE;	// double
        DstBufLen += (BufLen+COMPR_V42_LEN_SIZE); // add space, MAC/Encrypt
      }
      //----------------------------------------------------------
      // Save Type,Protocol, Transmit Count, Src/Dst-Bufferlengths
      //----------------------------------------------------------
      pConnStruc->TxFragmentToWriteCount = (int) SendDataCount;
      pConnStruc->TxFragmentType      = TxType;
      pConnStruc->TxFragmentProt      = TxProt;
      pConnStruc->TxFragSrcBufLen = SrcBufLen;	// save for later
      pConnStruc->TxFragmentIndex     = DstBufLen;	// dto.
      pConnStruc->TxFragmentOffset       = AddLen;	// dto.
      //------------------------------------------------
      // Waiting for Send Src-Buffer
      //------------------------------------------------
    case TCP_TX_SRCBUF_WAIT:
      SrcBufLen = pConnStruc->TxFragSrcBufLen;
      pSrcBuf = BIT8_ARRAY_ALLOC_POOL(HMEM_CTX_REF,SrcBufLen);   // get buffer
      if(pSrcBuf == NULL)				    // no buffer yet
      {
        pConnStruc->TX_State = TCP_TX_SRCBUF_WAIT;    // next State
        return(HSSL_OP_OK);
      }
      if(pConnStruc->TX_State == TCP_TX_SRCBUF_WAIT) // was a re-entry !!
      {
        SendDataCount = pConnStruc->TxFragmentToWriteCount;
        TxType	      = pConnStruc->TxFragmentType;
	TxProt	      = pConnStruc->TxFragmentProt;
	DstBufLen     = pConnStruc->TxFragmentIndex;
        AddLen        = pConnStruc->TxFragmentOffset;
      }
      //-------------------------------------------------------------------
      // Got send buffer, format source data buffer (empty record header !)
      //-------------------------------------------------------------------
      pConnStruc->pTxFragmentBuffer = pSrcBuf;		// save buffer
 
      Retcode = GatherTxQelsData(pConnStruc);		// get the buffer
      if(Retcode != HSSL_OP_OK)
      {
        FREE_ARRAY_POOL(HMEM_CTX_REF,pSrcBuf);		// free
        pConnStruc->pTxFragmentBuffer = NULL;
        PurgeTxQueues(pConnStruc);			// release queues
        pContStat[0] = STATUS_MUST_CLOSE_IMMEDIATE;
        pShutdownReason[0] = GATHER_FAILURE;
//      DBG_PRINT("Gather Failed: ");
//      DBG_PRINT_INT_NL(Retcode);
        return(Retcode);
      }
    //------------------------------------------------------------
    // Waiting for Send Copy-Buffer (for Compression), if required
    //------------------------------------------------------------
    case TCP_TX_DSTBUF_WAIT:
      pDstBuf = NULL;
      DstBufLen	= pConnStruc->TxFragmentIndex;		// get length
      if(DstBufLen != 0)
      {
        pDstBuf = BIT8_ARRAY_ALLOC_POOL(HMEM_CTX_REF,DstBufLen); // get buffer
        if(pDstBuf == NULL)				    // no buffer yet
        {
          pConnStruc->TX_State = TCP_TX_DSTBUF_WAIT;    // next State
          return(HSSL_OP_OK);
        }
        if(pConnStruc->TX_State == TCP_TX_DSTBUF_WAIT) // was re-entry !!
        {
          SendDataCount = pConnStruc->TxFragmentToWriteCount;
	  TxType	= pConnStruc->TxFragmentType;
	  TxProt	= pConnStruc->TxFragmentProt;
	  SrcBufLen	= pConnStruc->TxFragSrcBufLen;
	  pSrcBuf	= pConnStruc->pTxFragmentBuffer;
          AddLen        = pConnStruc->TxFragmentOffset;
        }
      }
      //------------------------------------------------
      // Format the Record Header in appropriate buffer
      //------------------------------------------------
      pBuf   = pSrcBuf;			// assume w/o. compression
      BufLen = SrcBufLen;
      if(DstBufLen != 0)
      {
        pBuf   = pDstBuf;		// is with compression
        BufLen = DstBufLen;
      }
      Index = 0;
      switch(TxType)
      {
        case TX_TYPE_APPLICATION_DATA:
          pBuf[Index++] = CT_APPLICATION_DATA;
          break;

        case TX_TYPE_CHANGE_CIPHER_SPEC:
          pBuf[Index++] = CT_CHANGE_CIPHER_SPEC;
          break;

        case TX_TYPE_ALERT_WARNING:
        case TX_TYPE_ALERT_FATAL:
          pBuf[Index++] = CT_ALERT;
          break;

        case TX_TYPE_HANDSHAKE_MSG:
          pBuf[Index++] = CT_HANDSHAKE;
          break;

        default:
          pBuf[Index++] = 0;			// should not happen
          break;
      } // switch
      pBuf[Index++] = TLS_SSL_MAJOR_VERSION;	// set version MSB
      switch(TxProt){
        case TLS_V2_PROT_TYPE:
          pBuf[Index++] = TLS12_MINOR_VERSION;	// set Version LSB
          break;
        case TLS_V1_PROT_TYPE:
          pBuf[Index++] = TLS11_MINOR_VERSION;	// set Version LSB
          break;
        case TLS_PROT_TYPE:
          pBuf[Index++] = TLS10_MINOR_VERSION;	// set Version LSB
          break;
        default:
          pBuf[Index++] = SSL_MINOR_VERSION;	// dto.
          break;
      }
      //------------------------------------------------
      // Compress the Data if required
      //------------------------------------------------

      if(DstBufLen != 0)
      {
        pTmpLen[0] = DstBufLen;
        Retcode = CompressRecord(pConnStruc,pSrcBuf,AddLen+RECORD_HDR_SIZE,
				   SendDataCount,
				   pDstBuf,AddLen+RECORD_HDR_SIZE,pTmpLen);
        if(Retcode != HSSL_OP_OK)
        {
//        DBG_PRINT("TXCompress Error !!\n");
          FREE_ARRAY_POOL(HMEM_CTX_REF,pSrcBuf);	// free
          FREE_ARRAY_POOL(HMEM_CTX_REF,pDstBuf);	// free
          pConnStruc->pTxFragmentBuffer = NULL;
          PurgeTxQueues(pConnStruc);		// release queues
          pContStat[0] = STATUS_MUST_CLOSE_IMMEDIATE;
          pShutdownReason[0] = COMPRESS_FAILURE;
          return(Retcode);
        }    
        pConnStruc->pTxFragmentBuffer = pBuf;	// set alternate buffer
        SendDataCount = pTmpLen[0];
        pConnStruc->TxFragmentIndex = 0;	// set index zero !!
        FREE_ARRAY_POOL(HMEM_CTX_REF,pSrcBuf);	// free the other
      }
      //--------------------------------------------------------------
      // Prepend Random Data block when TLS V1.1 CBC is selected
      //--------------------------------------------------------------
      if(AddLen != 0)
      {
        Retcode = SecDrbgRandBytes(HMEM_CTX_REF1 pBuf,RECORD_HDR_SIZE,AddLen);
        if(Retcode != 0)
        {
          FREE_ARRAY_POOL(HMEM_CTX_REF,pBuf);			// free
          pConnStruc->pTxFragmentBuffer = NULL;
          PurgeTxQueues(pConnStruc);			// release queues
          pContStat[0] = STATUS_MUST_CLOSE_IMMEDIATE;
          pShutdownReason[0] = RAND_PREPEND_FAILURE;
//        DBG_PRINT("CBC random append Failed\n");
          return(Retcode);
        }
      }
      //--------------------------------------------------------------
      // Append the Cipher MAC (Buffer is large enough !)
      //--------------------------------------------------------------
      BIGword2charn((SendDataCount+AddLen),pBuf,Index);	// set length of data
      pTmpLen[0] = SendDataCount+AddLen;		// save for calls
//==================================================================
// modified for XH_Interface Mode (combined hash/encrypt) here
//==================================================================
#if defined XH_INTERFACE
    if((pConnStruc->ActTX_EncAlgor == CIPHER_ALGOR_AES_CBC) &&
       (pConnStruc->ActTX_MACAlgor == MAC_ALGOR_SHA1) &&
       (pConnStruc->ActualProtocol != TLS_V1_PROT_TYPE) &&
       (pConnStruc->ActualProtocol != TLS_V2_PROT_TYPE))
    {
      AppendMacEncryptRecord(pConnStruc,pBuf,pTmpLen);
    }
    else // not AES/SHA-1
    {
#endif // defined XH_INTERFACE

      Retcode = AppendCipherMac(pConnStruc,pBuf,0,pTmpLen,BufLen);
      if(Retcode != HSSL_OP_OK)
      {
        FREE_ARRAY_POOL(HMEM_CTX_REF,pBuf);			// free
        pConnStruc->pTxFragmentBuffer = NULL;
        PurgeTxQueues(pConnStruc);			// release queues
        pContStat[0] = STATUS_MUST_CLOSE_IMMEDIATE;
        pShutdownReason[0] = MAC_APPEND_FAILURE;
//      DBG_PRINT("MAC append Failed\n");
        return(Retcode);
      }
   // SendDataCount = pTmpLen[0];
      //--------------------------------------------------------------
      // Encrypt the Data (Buffer is large enough !)
      //--------------------------------------------------------------
      Retcode = EncryptRecord(pConnStruc,pBuf,RECORD_HDR_SIZE,
			      pTmpLen,BufLen);
      if(Retcode != HSSL_OP_OK)
      {
        FREE_ARRAY_POOL(HMEM_CTX_REF,pBuf);			// free
        pConnStruc->pTxFragmentBuffer = NULL;
        PurgeTxQueues(pConnStruc);			// release queues
        pContStat[0] = STATUS_MUST_CLOSE_IMMEDIATE;
        pShutdownReason[0] = ENCRYPT_FAILURE;
//      DBG_PRINT("Encrypt Failed\n");
        return(Retcode);
      }    
#if defined XH_INTERFACE
    }
#endif // defined XH_INTERFACE

      //------------------------------------------------
      // Set the final record length
      //------------------------------------------------
      SendDataCount = pTmpLen[0];
      BIGword2charn(SendDataCount,pBuf,Index); // set length of data

      pConnStruc->TxFragmentToWriteCount = SendDataCount+RECORD_HDR_SIZE;
      pConnStruc->TX_State = TCP_TX_FRAGMENT_WRITE;

    //------------------------------------------------
    // Transmit active, try to send TCP data
    //------------------------------------------------
    case TCP_TX_FRAGMENT_WRITE:
      //----------------------------------------------
      // Check if Space on Send Buffer [Current != End]
      //----------------------------------------------
      BufLen = (int) (pDstBufTop - *ppDstBufBase);	// get len
      if(BufLen <= 0)					// Buffer is full...
        return(HSSL_OP_OK);				// cannot send
      //-----------------------------------------------
      // Output buffer space present, fill with data...
      //-----------------------------------------------
      SendDataCount = pConnStruc->TxFragmentToWriteCount;
      Index = pConnStruc->TxFragmentIndex;		// get start offset
      pBuf = pConnStruc->pTxFragmentBuffer;

      SrcBufLen = SendDataCount;			// set length of src.
      if(BufLen < SrcBufLen)				// too small...
        SrcBufLen = BufLen;				// set maximum
      memcpy(*ppDstBufBase+0,pBuf+Index,SrcBufLen);
      *ppDstBufBase += SrcBufLen;		// adjust pointer
      SendDataCount -= SrcBufLen;		// reduce datacount
      if(SendDataCount != 0)			// must wait for more to send
      {
        pConnStruc->TxFragmentIndex  += SrcBufLen;	// increment index
        pConnStruc->TxFragmentToWriteCount = SendDataCount;// save remaining
        return(HSSL_OP_OK);
      }
      pConnStruc->TX_State = TCP_TX_FRAGMENT_POSTPROCESS;
      return(HSSL_OP_OK);
    //---------------------------------------------------
    // Transmit Post-Processing active, add up data count
    //---------------------------------------------------
    case TCP_TX_FRAGMENT_POSTPROCESS:
      SendDataCount = pConnStruc->TxFragmentToWriteCount;
      TxType	    = pConnStruc->TxFragmentType;
      pBuf = pConnStruc->pTxFragmentBuffer;
      if(pConnStruc->ConnectionState == CONN_STATE_CONNECTED)
      {
        ADD_64(pConnStruc->TXDataMSW,pConnStruc->TXDataLSW,
	         (int) SendDataCount);
      }
      //-----------------------------------------------------------
      // Block was sent, free buffer, check special action required
      //-----------------------------------------------------------
      FREE_ARRAY_POOL(HMEM_CTX_REF,pBuf);	// free
      pConnStruc->pTxFragmentBuffer = NULL;
      pConnStruc->TX_State = TCP_TX_INACTIVE; // must wait
      switch(TxType)
      {
        //--------------------------------------------------
        // Change Ciphersuite transmitted, make pending TX-States
        // the actual states, clear the TX-pending states
        //--------------------------------------------------
        case TX_TYPE_CHANGE_CIPHER_SPEC:
          Retcode = CopyPendingToActCipherStates(pConnStruc,1);
          ClearPendingCiphStates(pConnStruc,1);
          if(Retcode == HSSL_OP_OK)
            return(Retcode);
          //------------------------------------------
          // Change Ciphersuite TX Error, terminate
          //------------------------------------------
          PurgeTxQueues(pConnStruc);			// release queues
          pContStat[0] = STATUS_MUST_CLOSE_IMMEDIATE;
          pShutdownReason[0] = TX_CHG_CIPHERSUITE_ERR;
          return(Retcode);
        //--------------------------------------------------
        // Alert, Level Fatal transmitted, close down
        //--------------------------------------------------
        case TX_TYPE_ALERT_FATAL:
          PurgeTxQueues(pConnStruc);			// release queues
          pContStat[0] = STATUS_MUST_CLOSE_IMMEDIATE;
          pShutdownReason[0] = TX_FATAL_ALERT;
          return(HSSL_OP_OK);
        default:
          return(HSSL_OP_OK);			// no special postprocessing
      } // Special TX type Switch
  } // Distribution Switch
  return(HSSL_NEWCONN_STATE_ERR);
}

#if XH_INTF_VERSION < 300
/**
* Processes data from the TX (outgoing) queues and puts them to sending 
* buffers. Server side (HSSL_XH2Tcp_Transmit).
*
* @see m_xh_transmit
*
*  @param pXif2Struc Interface structure
*  @param pContStat Continuation state
*  @param pShutdownReason Reason in case of shutdown req.
*
*  @return HSSL_OP_OK on success, error code otherwise
*/
extern "C" int  HSSL_XH2Tcp_Transmit(struct dsd_hl_ssl_s_2 * pXif2Struc,
				     int* pContStat,
				     int* pShutdownReason)
{
   return m_xh_transmit(((XHCONNSTRUC *) pXif2Struc->ac_ext)->pConnStruc, 
       pContStat, pShutdownReason, TRUE, &(pXif2Struc->achc_send_cur),
       pXif2Struc->achc_send_end);
}
#endif // XH_INTF_VERSION < 300

#if XH_INTF_VERSION >= 300
/**
* Processes data from the TX (outgoing) queues and puts them to sending 
* buffers. Server side (HSSL_XH3Tcp_Transmit).
*
* @see m_xh_transmit
*
*  @param pXif3Struc Interface structure
*  @param pContStat Continuation state
*  @param pShutdownReason Reason in case of shutdown req.
*
*  @return HSSL_OP_OK on success, error code otherwise
*/
extern "C" int  HSSL_XH3Tcp_Transmit(struct dsd_hl_ssl_s_3 * pXif3Struc,
				     int* pContStat,
				     int* pShutdownReason)
{
   return m_xh_transmit(((XHCONNSTRUC *) pXif3Struc->ac_ext)->pConnStruc, 
       pContStat, pShutdownReason, TRUE, &(pXif3Struc->achc_tocl_cur),
       pXif3Struc->achc_tocl_end);
}
#endif // XH_INTF_VERSION >= 300

/**
* Processes data from the TX (outgoing) queues and puts them to sending 
* buffers. Client side (HSSL_XHCLTcp_Transmit).
*
* @see m_xh_transmit
*
*  @param pXifClStruc Interface structure
*  @param pContStat Continuation state
*  @param pShutdownReason Reason in case of shutdown req.
*
*  @return HSSL_OP_OK on success, error code otherwise
*/
extern "C" int  HSSL_XHCLTcp_Transmit(struct dsd_hl_ssl_c_1 * pXifClStruc,
				      int* pContStat,
				      int* pShutdownReason)
{
   return m_xh_transmit(((XHCONNSTRUC *) (pXifClStruc)->vpc_ext)->pConnStruc,
      pContStat, pShutdownReason, TRUE, &(pXifClStruc->achc_out_se_cur), 
      pXifClStruc->achc_out_se_end);
}
#endif // XH_INTERFACE

/**
* Performs checking of
* change cipher spec message, copies RX-Pending states into
* the RX-Actual States and initializes them for the record layer,
* resets the pending cipher states to invalid (ProcessRX_ChangeCipherSpec).
*
*  @param pConnStruc Connection structure
*  @param SrcBuf Source data base
*  @param SrcOff Start of source data
*  @param SrcLen Length of source data
*  @param pContStat Continuation status
*  @return HSSL_OP_OK on success, error code otherwise
*/
static int  ProcessRX_ChangeCipherSpec(CONNSTRU * pConnStruc,
		char* SrcBuf, int SrcOff, int SrcLen, int* pContStat)
{
  int Retcode;
  CFG_STRU * pCfgStruc;

  //------------------------------------------------------
  // Check Parameters
  //------------------------------------------------------
  if((pConnStruc == NULL) || (SrcBuf == NULL) || (pContStat == NULL))
    return(HSSL_NULL_PTR);
  pContStat[0] = STATUS_CONTINUE;

  if(( ! m_is_expected_message(pConnStruc, uss_css_type)) ||
      ((SrcLen != 1) || (SrcBuf[SrcOff] != CS_CHANGE_CIPHER_SPEC))) // mallformed
  {
    SendAlert(pConnStruc,AD_UNEXPECTED_MSG,ALERT_LEVEL_FATAL);
    pContStat[0] = STATUS_FATAL_ALERT_QUEUED;
    return(HSSL_CHG_CIPHSPEC_MSG_UNEXPECTD);
  }
  //-----------------------------------------------------------------
  // Copy Pending RX States to Actual RX-States, clear pending states
  //-----------------------------------------------------------------
  Retcode = CopyPendingToActCipherStates(pConnStruc,0);
  ClearPendingCiphStates(pConnStruc,0);
  if(Retcode != HSSL_OP_OK)
  {
    SendAlert(pConnStruc,AD_UNEXPECTED_MSG,ALERT_LEVEL_FATAL);
    pContStat[0] = STATUS_FATAL_ALERT_QUEUED;
  }
  if(pConnStruc->Entity == CLIENT_ENTITY)	// from Server, Clear Extcert
  {
    pCfgStruc = pConnStruc->pCfgStruc;
    pCfgStruc->ExtCertsFlags &= (~EXTCERT_CLNTAUTH_FROM_EXT_BIT); // Clear!
  }
  m_set_expected_message(pConnStruc, HT_FINISHED);
  return(Retcode);
}

/**
* Receives the two bytes of an alert
* message and processes them (ProcessRX_Alert).
*
* Theoretically the two bytes may be split into 2 records,
*       so assembly must be provided.
*       Warning alerts of unknown type are ignored to remain compatible
*       with yet unimplemented extensions.
*
*  @param pConnStruc Connection structure
*  @param SrcBuf Source data base
*  @param SrcOff Start of source data
*  @param SrcLen Length of source data
*  @param pContStat Continuation status
*  @return HSSL_OP_OK on success, error code otherwise
*/
static int  ProcessRX_Alert(CONNSTRU * pConnStruc,
		char* SrcBuf, int SrcOff, int SrcLen, int* pContStat)
{
  char AlertState;
  char AlertLevel;
  char AlertDescr;
  //------------------------------------------------------
  // Check Parameters
  //------------------------------------------------------
  if((pConnStruc == NULL) || (SrcBuf == NULL) || (pContStat == NULL))
    return(HSSL_NULL_PTR);
  pContStat[0] = STATUS_CONTINUE;
  //------------------------------------------------------
  // Check length of data
  //------------------------------------------------------
  AlertState = pConnStruc->Alert_RX_State;
  if((SrcLen <= 0) ||			// must be > 0
     ((AlertState == ALERT_WAIT_1ST_BYTE) &&	// only up to 2 bytes
      (SrcLen > 2)) ||
     ((AlertState == ALERT_WAIT_2ND_BYTE) &&	// exactly 1 byte required
      (SrcLen != 1)))
  {
    SendAlert(pConnStruc,AD_UNEXPECTED_MSG,ALERT_LEVEL_FATAL);
    pContStat[0] = STATUS_FATAL_ALERT_QUEUED;
    return(HSSL_OP_OK);
  }
  //------------------------------------------------------
  // Assemble Data
  //------------------------------------------------------
  if(AlertState == ALERT_WAIT_1ST_BYTE)
  {
    pConnStruc->Alert_RxLevel = SrcBuf[SrcOff++];
    SrcLen--;
    if(SrcLen == 0)
    {
      pConnStruc->Alert_RX_State = ALERT_WAIT_2ND_BYTE;
      return(HSSL_OP_OK);
    }
  }
  pConnStruc->Alert_RxDescr = SrcBuf[SrcOff];
  pConnStruc->Alert_RX_State = ALERT_WAIT_1ST_BYTE;
  //------------------------------------------------------
  // Check the Alert Meaning
  //------------------------------------------------------
  AlertLevel = pConnStruc->Alert_RxLevel;
  AlertDescr = pConnStruc->Alert_RxDescr;

  if(AlertLevel == ALERT_LEVEL_WARNING)
  {
      if(AlertDescr != AD_CLOSE_NOTIFY){
          m_generate_log_msg(pConnStruc, "Received Warning Alert with error number ", AlertDescr, HL_AUX_WT_DATA2, "SSLMSG");
      } else {
          m_generate_log_msg(pConnStruc, "Received Close Notifiy Warning", 0, HL_AUX_WT_DATA2, "SSLMSG");
      }
    //----------------------------------------------------
    // Process Warning Alerts
    //----------------------------------------------------
    switch(AlertDescr)
    {
      //--------------------------------------------------
      // Close Notification/User aborted
      //--------------------------------------------------
      case AD_CLOSE_NOTIFY:
      case AD_USER_CANCELED:
        SendAlert(pConnStruc,AD_CLOSE_NOTIFY,ALERT_LEVEL_WARNING);
        return(HSSL_OP_OK);
      //--------------------------------------------------------------
      // Certificate Alerts ----- MUST SPECIFIY MORE PRECISE !!! -----
      //--------------------------------------------------------------
      case AD_NO_CERTIFICATE:
        if(pConnStruc->Entity == SERVER_ENTITY && 
           pConnStruc->ActualProtocol == SSL_PROT_TYPE )	// comes from client
        {
          if((pConnStruc->AuthFlags & CLNT_AUTH_BIT_MASK) != 0)
          {
            if((pConnStruc->AuthFlags &
                SRVR_REQ_CERT_IF_AVAIL_BIT_MASK) != 0)	// was a request only
              return(HSSL_OP_OK);

            SendAlert(pConnStruc,AD_HSHAKE_FAILURE,ALERT_LEVEL_FATAL);
            pContStat[0] = STATUS_FATAL_ALERT_QUEUED;
            return(HSSL_ALERT_MSG_NO_CLIENT_CERT);
          }
        }
        // No SSLv3 or wrong entity
        SendAlert(pConnStruc,AD_UNEXPECTED_MSG,ALERT_LEVEL_FATAL);
        pContStat[0] = STATUS_FATAL_ALERT_QUEUED;
        return(HSSL_ALERT_MSG_FATAL_ALERT);

      case AD_BAD_CERTIFICATE:
      case AD_UNSUP_CERTIFICATE:
      case AD_CERTIFICATE_REVOKED:
      case AD_CERTIFICATE_EXPIRED:
      case AD_CERTIFICATE_UNKNOWN:
        if(pConnStruc->Entity == SERVER_ENTITY)	// comes from client
        { 
          if((pConnStruc->AuthFlags & CLNT_AUTH_BIT_MASK) != 0)
          {
            SendAlert(pConnStruc,AD_HSHAKE_FAILURE,ALERT_LEVEL_FATAL);
            pContStat[0] = STATUS_FATAL_ALERT_QUEUED;
	    return(HSSL_ALERT_MSG_NO_CLIENT_CERT);
          }
        }
        return(HSSL_OP_OK);
      //------------------------------------------------------------
      // No Renegotiation, disable local renegotiation timer/states,
      // Check if renegotiation is required
      //------------------------------------------------------------
      case AD_NO_RENEGOTIATION:
        pConnStruc->RenegotiateMode = 0;	// stop renegotiation
        pConnStruc->RenegotiateTime = 0;	// disable restart time
        pConnStruc->ActualRenegotiateTimer = 0;	// stop timer checking

        pConnStruc->ExtendedConfigFlags = (unsigned char)
          (pConnStruc->ExtendedConfigFlags & (~LOCAL_RENEGOTIATE_BIT_MASK));

        if((pConnStruc->ExtendedConfigFlags & RENEG_REJ_SHUTDOWN_BIT_MASK) != 0)
        { // Gracefully close
          SendAlert(pConnStruc,AD_CLOSE_NOTIFY,ALERT_LEVEL_FATAL); 
          pContStat[0] = STATUS_FATAL_ALERT_QUEUED;
          return(HSSL_ALERT_MSG_NO_RENEGOTIATE);
        }
        return(HSSL_OP_OK);

      default:
        return(HSSL_OP_OK);		// just ignore

    } // switch
  }
  else
  {
      if(AlertDescr != AD_CLOSE_NOTIFY){
          m_generate_log_msg(pConnStruc, "Received Fatal Alert with error number ", AlertDescr, HL_AUX_WT_DATA2, "SSLMSG");
      } else {
          m_generate_log_msg(pConnStruc, "Received Fatal Close Notifiy", 0, HL_AUX_WT_DATA2, "SSLMSG");
      }
    //----------------------------------------------------
    // Process Fatal Alerts: always shutdown ungraceful
    //----------------------------------------------------
    SendAlert(pConnStruc,AD_RESERVED,ALERT_LEVEL_FATAL); // Dummy!
    pContStat[0] = STATUS_FATAL_ALERT_QUEUED;

    switch(AlertDescr)
    {
      case AD_CLOSE_NOTIFY:
        return (HSSL_ALERT_MSG_FATAL_CLOSE_NOTIFY);
      case AD_UNEXPECTED_MSG:
        return(HSSL_ALERT_MSG_UNEXPECTED_MSG);

      case AD_BAD_RECORD_MAC:
        return(HSSL_ALERT_MSG_BAD_RECORD_MAC);

      case AD_DECRYPT_FAILURE:
        return(HSSL_ALERT_MSG_DECRYPT_FAILED);

      case AD_RECORD_OVERFLOW:
        return(HSSL_ALERT_MSG_RECORD_OVERFLOW);

      case AD_DECOMPRESS_FAILURE:
        return(HSSL_ALERT_MSG_DECOMPR_FAILURE);

      case AD_HSHAKE_FAILURE:
        return(HSSL_ALERT_MSG_HANDSHAKE_FAIL);

      case AD_BAD_CERTIFICATE:
        return(HSSL_ALERT_MSG_BAD_CERT);

      case AD_UNSUP_CERTIFICATE:
        return(HSSL_ALERT_MSG_UNSUP_CERT);

      case AD_CERTIFICATE_REVOKED:
        return(HSSL_ALERT_MSG_REVOKED_CERT);

      case AD_CERTIFICATE_EXPIRED:
        return(HSSL_ALERT_MSG_EXPIRED_CERT);

      case AD_CERTIFICATE_UNKNOWN:
        return(HSSL_ALERT_MSG_UNKNOWN_CERT);

      case AD_NO_CERTIFICATE:
        if(pConnStruc->Entity == CLIENT_ENTITY)	// comes from server
          return(HSSL_ALERT_MSG_NO_CLIENT_CERT);
        else
          return(HSSL_ALERT_MSG_FATAL_ALERT);

      case AD_ILLEGAL_PARAMETER:
        return(HSSL_ALERT_MSG_ILLEGAL_PARAM);

      case AD_UNKNOWN_CA:
        return(HSSL_ALERT_MSG_UNKNOWN_CA);

      case AD_ACCESS_DENIED:
        return(HSSL_ALERT_MSG_ACCESS_DENIED);

      case AD_DECODE_ERROR:
        return(HSSL_ALERT_MSG_DECODE_ERROR);

      case AD_DECRYPT_ERROR:
        return(HSSL_ALERT_MSG_DECRYPT_ERROR);

      case AD_EXP_RESTRICTION:
        return(HSSL_ALERT_MSG_EXPORT_RESTRICT);

      case AD_PROTOCOL_VERSION:
        return(HSSL_ALERT_MSG_PROTOCOL_VERSION);

      case AD_INSUFF_SECURITY:
        return(HSSL_ALERT_MSG_INSUFF_SECURITY);

      case AD_INTERNAL_ERROR:
        return(HSSL_ALERT_MSG_INTERNAL_ERROR);

      default:
        return(HSSL_ALERT_MSG_FATAL_ALERT);
    }
//  return(HSSL_ALERT_MSG_FATAL_ALERT);
  }
}

/**
* Queues application data for upper layer
* receive (ProcessRX_ApplData).
*
*  @param pConnStruc Connection structure
*  @param SrcBuf Source data base
*  @param SrcOff Start of source data
*  @param SrcLen Length of source data
*  @param pContStat Continuation status
*  @return HSSL_OP_OK on success, error code otherwise
*/
static int  ProcessRX_ApplData(CONNSTRU * pConnStruc,
		char* SrcBuf, int SrcOff, int SrcLen, int* pContStat)
{
  int Retcode;

  RX_QEL * pRxQel;

  HMEM_CTX_DEF1;

  LOAD_HMEM_CTX_PTR(CONN_pMemCtx(pConnStruc));

  pContStat[0] = STATUS_CONTINUE;

  //-------------------------------------------------
  // Process Renegotiation timer if set
  //-------------------------------------------------
  if(pConnStruc->ActualRenegotiateTimer != 0)
  {
    //------------------------------------------------
    // Check if time set has been reached
    //------------------------------------------------
    if((uint32_t) time(NULL) > pConnStruc->ActualRenegotiateTimer)
    {
      //--------------------------------------------------------
      // Have a renegotiate timer reached event, check which one
      //--------------------------------------------------------
      pConnStruc->ActualRenegotiateTimer = 0;	// clear timer

      if(pConnStruc->RenegotiateMode == 0)	// local initiated !
      {
        //----------------------------------------------------------
        // Local timer for start renegotiation reached,
        // activate renegotiation, generate the startup send messages
        // Wait timers are set in the start code !
        //----------------------------------------------------------
        pConnStruc->RenegotiateMode = SSL_RENEGOTIATE_ACTIVE;
        pConnStruc->HandshakeMode   = SSL_SHORT_HANDSHAKE_MODE;

        if(pConnStruc->Entity == SERVER_ENTITY){	// Server side
            m_set_expected_message(pConnStruc, HT_CLIENT_HELLO);
            Retcode = GenerateServerHelloReq(pConnStruc); // Start the Handshake
        } else {
            m_set_expected_message(pConnStruc, HT_SERVER_HELLO);
            Retcode = GenerateClientHello(pConnStruc);
        }

        if(Retcode != HSSL_OP_OK)
        {
          pContStat[0] = STATUS_MUST_CLOSE_IMMEDIATE;// shutdown/alert sent
          return(Retcode);
        }
      }
      else					// Receive timeout occured!
      {
        //----------------------------------------------------------
        // Renegotiation has not started/finished withing given
        // time limit, check what to do
        //----------------------------------------------------------
        pConnStruc->RenegotiateMode = 0;	// stop renegotiation
        pConnStruc->RenegotiateTime = 0;	// disable restart time
        pConnStruc->ActualRenegotiateTimer = 0;	// stop timer checking

        pConnStruc->ExtendedConfigFlags = (unsigned char)
          (pConnStruc->ExtendedConfigFlags & (~LOCAL_RENEGOTIATE_BIT_MASK));

        if((pConnStruc->ExtendedConfigFlags & RENEG_REJ_SHUTDOWN_BIT_MASK) != 0)
        { // Send fatal alert
          SendAlert(pConnStruc,AD_INTERNAL_ERROR,ALERT_LEVEL_FATAL);
          pContStat[0] = STATUS_FATAL_ALERT_QUEUED;
          return(HSSL_HSHAKE_RENEGOTIATE_TIMEOUT);
        }
      }
    }
  }
  //--------------------------------------------------
  // Process the Application data (buffer them if any)
  //--------------------------------------------------
  if(SrcLen <= 0)			// silly case (OpenSSL)
  {
    FREE_ARRAY_POOL(HMEM_CTX_REF,SrcBuf); // free buffer(if any)
    return(HSSL_RX_APPLDATA_NULL_MSG);	// just ignore the '0' data....
  }
  m_generate_log_msg(pConnStruc, "ProcessRX_ApplData processed package of length %i", SrcLen, HL_AUX_WT_DATA1,"SSLRXM");
  //----------------------------------------------
  // Allocate the RX Qel and put buffer to it
  //----------------------------------------------
  pRxQel = AllocInitRxQel(HMEM_CTX_REF1
			  SrcBuf, SrcOff, SrcLen);
  if(pRxQel == NULL)
  {
    pContStat[0] = STATUS_FATAL_NO_BUFS;
    return(HSSL_RX_APPLDATA_QEL_ALLOC_ERR);
  }
  EnqueueRxQel(pConnStruc,pRxQel);
  return(HSSL_OP_OK);
}

/**
* Assembles Handshake messages
* and processes them (AssembleProcessRX_Handshake). 
* This is the CORE of the RX Handshake protocol handling.
*
*  @param pConnStruc Connection structure
*  @param SrcBuf Source data base
*  @param SrcOff Start of source data
*  @param SrcLen Length of source data
*  @param pContStat Continuation status
*  @return HSSL_OP_OK on success, error code otherwise
*/
static int  AssembleProcessRX_Handshake(CONNSTRU * pConnStruc,
		char* SrcBuf, int SrcOff, int SrcLen, int* pContStat)
{
  int Retcode;

  int SrcIndex = SrcOff;
  int DstIndex;
  int RequiredDataCnt;

  int MsgLen;
  int MsgIndex;

  char* pDstBuf = NULL;
  char* pBuf = NULL;

  HMEM_CTX_DEF1;
  //------------------------------------------------------
  // Check Parameters
  //------------------------------------------------------
  if((pConnStruc == NULL) || (SrcBuf == NULL) || (pContStat == NULL))
    return(HSSL_NULL_PTR);
  pContStat[0] = STATUS_CONTINUE;

  LOAD_HMEM_CTX_PTR(CONN_pMemCtx(pConnStruc));

  //------------------------------------------------------
  // Distribute according to Handshake assembly state
  //------------------------------------------------------
  for(;;)					// multi-message case
  {
    switch(pConnStruc->Handshake_RX_State)
    {
      //---------------------------------------------------------
      // Header Read Start
      //---------------------------------------------------------
      case HS_RX_HDR_WAIT:			// Start of Data
        pConnStruc->Handshake_RxHdrIndex = 0;	// Start at base
        pConnStruc->Handshake_RX_State = HS_RX_HDR_READ;
      //---------------------------------------------------------
      // Header Read in progress
      //---------------------------------------------------------
      case HS_RX_HDR_READ:
        pDstBuf = pConnStruc->Handshake_RX_HdrBuffer;	// get Base
        DstIndex = pConnStruc->Handshake_RxHdrIndex;	// get destination
        RequiredDataCnt = HT_RECORD_HDR_SIZE - DstIndex; // Data Required
        //---------------------------------------------------------
        // Put data to Header Buffer
        // (Do Not Forget to Hash the Header Buffer later !!)
        //---------------------------------------------------------
        if(SrcLen < RequiredDataCnt)		// not enough data yet
        {
          m_generate_log_msg(pConnStruc, "Not enough header data during case HS_RX_HDR_READ in AssembleProcessRX_Handshake",0,HL_AUX_WT_DATA2,"SSLRXM");
          memcpy(pDstBuf+DstIndex,SrcBuf+SrcIndex,SrcLen);
          DstIndex += SrcLen;
          pConnStruc->Handshake_RxHdrIndex = DstIndex; // save new index
          return(HSSL_OP_OK);
        }
        memcpy(pDstBuf+DstIndex,SrcBuf+SrcIndex,RequiredDataCnt);
        SrcIndex += RequiredDataCnt;
        SrcLen   -= RequiredDataCnt;  
        pConnStruc->Handshake_RX_State = HS_RX_MSG_READ; // next state
        //---------------------------------------------------------
        // Header Data Complete, get length of message to receive,
        // may be zero. 24 bit of data length possible !
        //---------------------------------------------------------
        BIGchar2longn(pDstBuf,MsgLen,0);// get length (1st byte invalid !)
        MsgLen &= 0xFFFFFF;		// only 24 Bits valid
        pConnStruc->HandshakeRxDataSize      = MsgLen; // save size
        pConnStruc->HandshakeRxDataToReadCount = MsgLen; // set for receive
        //---------------------------------------------------------
        // Allocate Buffer for Data to receive (must get buffer !)
        //---------------------------------------------------------
        pBuf = BIT8_ARRAY_ALLOC_POOL(HMEM_CTX_REF,
			        (int) MsgLen + HT_RECORD_HDR_SIZE);
        if(pBuf == NULL)			// couldn't get buffer !!
        {
          pContStat[0] = STATUS_FATAL_NO_BUFS;
          return(HSSL_RX_BUF_ALLOC_ERR);
        }
        pConnStruc->pHandshake_RxMsgDataBuffer = pBuf;	// save buffer
        //---------------------------------------------------------
        // Copy the header to the buffer (for HANDSHAKE hashes !!!)
        //---------------------------------------------------------
        memcpy(pBuf+0,pDstBuf+0,HT_RECORD_HDR_SIZE);
        MsgIndex = HT_RECORD_HDR_SIZE;
        pConnStruc->HandshakeRxDataIndex = MsgIndex;
        //------------------------------------------------------------
        // Check if message data to receive (zero messages possible !)
        //------------------------------------------------------------
        if(MsgLen == 0)				// empty message
        {
          pConnStruc->Handshake_RX_State = HS_RX_HDR_WAIT; // next state
          pDstBuf = pBuf;			// use the allocated buffer !
          break;
        }
        if(SrcLen == 0)				// no data for message yet...
        {
          m_generate_log_msg(pConnStruc, "Not enough messge data during case HS_RX_HDR_READ in AssembleProcessRX_Handshake",0,HL_AUX_WT_DATA2,"SSLRXM");
          return(HSSL_OP_OK);
        }
      //-----------------------------------------------------------------
      // Message Read, buffer already allocated, data must be present (!)
      //-----------------------------------------------------------------
      case HS_RX_MSG_READ:
        pDstBuf  = pConnStruc->pHandshake_RxMsgDataBuffer;	// get buffer base
        MsgIndex = pConnStruc->HandshakeRxDataIndex;	// get Start Index
        MsgLen   = pConnStruc->HandshakeRxDataToReadCount;	// get size to read
        if(MsgLen > ((int) SrcLen & 0xFFFF))		// not enough data yet
        {
          m_generate_log_msg(pConnStruc, "Not enough data during case HS_RX_MSG_READ in AssembleProcessRX_Handshake",0,HL_AUX_WT_DATA2,"SSLRXM");
          memcpy(pDstBuf+MsgIndex,SrcBuf+SrcIndex,SrcLen);
          MsgLen   -= ((int) SrcLen & 0xFFFF);	// reduce count
          MsgIndex += ((int) SrcLen & 0xFFFF);	// advance Index
          pConnStruc->HandshakeRxDataToReadCount = MsgLen;	// save remaining size
          pConnStruc->HandshakeRxDataIndex     = MsgIndex;// save new Index
          return(HSSL_OP_OK);				// wait for more data
        }
        memcpy(pDstBuf+(int) MsgIndex,SrcBuf+SrcIndex,(int) MsgLen);
        SrcLen   -= (int) MsgLen;			// reduce data count
        SrcIndex += (int) MsgLen;			// advance Index
        pConnStruc->Handshake_RX_State = HS_RX_HDR_WAIT;	// next state
        break;
      default:
        return(HSSL_RX_UNSUPPORTED_VERSION);
    } // Message receive switch
    //-----------------------------------------------------------------
    // All message data present, hash the RX message exclusive
    // Server Hello Request and Finished, process message...
    //-----------------------------------------------------------------
    if((pDstBuf[0] != HT_HELLO_REQUEST) &&
       (pDstBuf[0] != HT_CLIENT_HELLO) &&
       (pDstBuf[0] != HT_FINISHED) &&
       (pDstBuf[0] != HT_CERTIFICATE_VERIFY))
    {
      HashHandshakeMessage(pConnStruc,pDstBuf,0,
		   pConnStruc->HandshakeRxDataSize+HT_RECORD_HDR_SIZE);    
    }
    Retcode = ProcessRX_Message(pConnStruc,pConnStruc->Handshake_RX_HdrBuffer[0],
		pDstBuf,0,
		(int) (HT_RECORD_HDR_SIZE+pConnStruc->HandshakeRxDataSize),
		pContStat);
    if((Retcode != HSSL_OP_OK) || (pContStat[0] != STATUS_CONTINUE))
    {
      m_generate_log_msg(pConnStruc, "AssembleProcessRX_Handshake failed at ProcessRX_Message. Ret: %i", Retcode, HL_AUX_WT_DATA2,"SSLRXM");
      FREE_ARRAY_POOL(HMEM_CTX_REF,pDstBuf);
      pConnStruc->pHandshake_RxMsgDataBuffer = NULL;
      return(Retcode);
    }
    //--------------------------------------------------------------------
    // free the message buffer, check if more Handshake data present
    //--------------------------------------------------------------------
    FREE_ARRAY_POOL(HMEM_CTX_REF,pDstBuf);
    pConnStruc->pHandshake_RxMsgDataBuffer = NULL;
    if(SrcLen == 0)
      return(HSSL_OP_OK);			// no more message data
    m_generate_log_msg(pConnStruc, "AssembleProcessRX_Handshake finished for iteration. Data left: %i", SrcLen, HL_AUX_WT_DATA2,"SSLRXM");
  } // RX Message processing FOR
}

/**
* Checks validity of a
* full / partial received SSL/TLS record header (Check_SSL_RecordHeader).
*
* No parameter checking is done.
*
*  @param pConnStruc Connection structure
*  @param NewHeaderLen Actual received header data
*  @return  0 on success,
* <br>            HSSL_RX_ILLEGAL_PARAM : parameter error
* <br>            HSSL_RX_UNSUPPORTED_VERSION : version mismatch
*/
static  int  Check_SSL_RecordHeader(CONNSTRU * pConnStruc,
					int NewHeaderLen)
{
  int ActProtocol;
  int PossibleProtocols;
  int LastLen;
  int DataLen;
  //------------------------------------------------
  // Check if any new header data have been received
  //------------------------------------------------
  if(NewHeaderLen <= 0)
    return(HSSL_OP_OK);
  //-----------------------------------------------------------
  // Check if Protocol is already negotiated
  //-----------------------------------------------------------
  LastLen = pConnStruc->RxHeaderIndex;	// already processed count
  ActProtocol = pConnStruc->ActualProtocol;	// get protocol type
  if(ActProtocol != UNKNOWN_PROT_TYPE)
  {
    //---------------------------------------------------------
    // A) standard case, protocol negotiated, client and server
    //---------------------------------------------------------
    switch(LastLen)
    {
      //---------------------------------------------------
      // No bytes processed yet..
      //---------------------------------------------------
      case 0:					// Byte 0 to process
        if((ActProtocol == SSL_PROT_TYPE) &&	// SSL-V3, check range !
           ((pConnStruc->RX_HeaderBuffer[RH_TYPE] < CT_CHANGE_CIPHER_SPEC) ||
            (pConnStruc->RX_HeaderBuffer[RH_TYPE] > CT_APPLICATION_DATA)))
        {
	  return(HSSL_RX_ILLEGAL_PARAM);
        }
        NewHeaderLen--;
        if(NewHeaderLen <= 0)
          return(HSSL_OP_OK);
      //---------------------------------------------------
      // Byte 0 already processed
      //---------------------------------------------------
      case 1:					// Byte 1 to process
	if(pConnStruc->RX_HeaderBuffer[RH_VERSION_MSB] != TLS_SSL_MAJOR_VERSION)
        {
	  return(HSSL_RX_ILLEGAL_PARAM);
        }
        NewHeaderLen--;
        if(NewHeaderLen <= 0)
          return(HSSL_OP_OK);
      //---------------------------------------------------
      // Byte 1 already processed
      //---------------------------------------------------
      case 2:					// Byte 2 to process
        if(((ActProtocol == TLS_V2_PROT_TYPE) && 
            (pConnStruc->RX_HeaderBuffer[RH_VERSION_LSB] !=
                    TLS12_MINOR_VERSION)) ||
           ((ActProtocol == TLS_V1_PROT_TYPE) && 
            (pConnStruc->RX_HeaderBuffer[RH_VERSION_LSB] !=
                    TLS11_MINOR_VERSION)) ||
           ((ActProtocol == TLS_PROT_TYPE) && 
            (pConnStruc->RX_HeaderBuffer[RH_VERSION_LSB] !=
                    TLS10_MINOR_VERSION)) ||
           ((ActProtocol == SSL_PROT_TYPE) && 
            (pConnStruc->RX_HeaderBuffer[RH_VERSION_LSB] !=
                    SSL_MINOR_VERSION)))
        {
	  return(HSSL_RX_ILLEGAL_PARAM);
        }
        NewHeaderLen--;
        if(NewHeaderLen <= 0)
          return(HSSL_OP_OK);
      //---------------------------------------------------
      // Byte 2 already processed
      //---------------------------------------------------
      case 3:					// Byte 3 to process
        DataLen =
          ((int) pConnStruc->RX_HeaderBuffer[RH_LENGTH_MSB] & 0x0FF) << 8;
        if(DataLen > SSL_CIPH_RECORD_MAX_LEN)	// 16384 + 2048
        {
	  return(HSSL_RX_ILLEGAL_PARAM);
        }
        NewHeaderLen--;
        if(NewHeaderLen <= 0)
          return(HSSL_OP_OK);
      //---------------------------------------------------
      // Byte 3 already processed
      //---------------------------------------------------
      case 4:					// Byte 4 to process
        DataLen =
          (((int) pConnStruc->RX_HeaderBuffer[RH_LENGTH_MSB] & 0x0FF) << 8) |
          ((int) pConnStruc->RX_HeaderBuffer[RH_LENGTH_LSB] & 0x0FF);

        if(DataLen > SSL_CIPH_RECORD_MAX_LEN)	// 16384 + 2048
        {
	  return(HSSL_RX_ILLEGAL_PARAM);
        }
        return(HSSL_OP_OK);

      default:					// should not happen...
	return(HSSL_RX_ILLEGAL_PARAM);
    }
  }
  else
  {
// HERE HERE HERE: TLS1.1 Flag checking needed!!!

    PossibleProtocols = pConnStruc->SupportedProtocolsFlags;
    //---------------------------------------------------------
    // B) special case, protocol not yet negotiated
    //---------------------------------------------------------
    if(pConnStruc->RxHeaderSSLV2CheckEnable != 0)
    {
      //-------------------------------------------------------
      // B.1. Interpret SSL-V2 compatible header if possible
      // Only server entity will interpret SSL-V2 !
      //-------------------------------------------------------
      switch(LastLen)				// == already processed count
      {
        //---------------------------------------------------
        // No bytes processed yet..
        //---------------------------------------------------
        case 0:					// Byte 0 to process
						// do NOT check here !!!
          NewHeaderLen--;
          if(NewHeaderLen <= 0)
            return(HSSL_OP_OK);
        //---------------------------------------------------
        // Byte 0 already processed
        //---------------------------------------------------
        case 1:					// Byte 1 to process
          //------------------------------------------------------
          // Check if we got 0x03, if so, cannot be SSL-V2 anyway
          //------------------------------------------------------
          if(pConnStruc->RX_HeaderBuffer[RH_VERSION_MSB] ==
                                    TLS_SSL_MAJOR_VERSION)
          {
            //----------------------------------------------------
            // must be processed as TLS-V1/SSL-V3, also disable V2
            //----------------------------------------------------
            LastLen = 0;			// restart interpret at byte 0
            NewHeaderLen ++;			// one more source (fake)
            pConnStruc->RxHeaderSSLV2CheckEnable = 0;// disable further SSL-V2 check
            break;
          }
          //--------------------------------------------------------
          // Byte 1 is NOT 0x03 --> cannot be a TLS-V1/2/SSL-V3 header,
          // Byte 0 and 1 are the length, check MSB bit and limits
          //--------------------------------------------------------
          if((pConnStruc->RX_HeaderBuffer[RH_LENGTH_MSB_V2] & (unsigned char) 0x80) == 0)
          {
            return(HSSL_RX_ILLEGAL_PARAM);
          }
          DataLen = 
            (((int) pConnStruc->RX_HeaderBuffer[RH_LENGTH_MSB_V2] & 0x7F)<<8) |
            ((int) pConnStruc->RX_HeaderBuffer[RH_LENGTH_LSB_V2] & 0x0FF);

          if((DataLen < SSL_V2_MIN_CLIENT_HELLO_LEN) ||
             (DataLen > SSL_V2_MAX_CLIENT_HELLO_LEN))
          {
            return(HSSL_RX_ILLEGAL_PARAM);
          }
          NewHeaderLen--;
          if(NewHeaderLen <= 0)
            return(HSSL_OP_OK);
        //---------------------------------------------------
        // Byte 1 already processed
        //---------------------------------------------------
        case 2:					// Byte 2 to process
          //------------------------------------------------------
          // Must be SSL-V2 client hello
          //------------------------------------------------------
          if(pConnStruc->RX_HeaderBuffer[RH_MSG_TYPE_V2] != HT_CLIENT_HELLO_V2)
          {
            return(HSSL_RX_ILLEGAL_PARAM);
          }
          NewHeaderLen--;
          if(NewHeaderLen <= 0)
            return(HSSL_OP_OK);
        //---------------------------------------------------
        // Byte 2 already processed
        //---------------------------------------------------
        case 3:					// Byte 3 to process
          //--------------------------------------------------------
          // Check if V2-Client Hello Major version supports TLS/SSL
          //--------------------------------------------------------
          if(pConnStruc->RX_HeaderBuffer[RH_VERSION_MSB_V2] !=
			TLS_SSL_MAJOR_VERSION)
          {
            return(HSSL_RX_UNSUPPORTED_VERSION);
          }
          NewHeaderLen--;
          if(NewHeaderLen <= 0)
            return(HSSL_OP_OK);
        //---------------------------------------------------
        // Byte 3 already processed
        //---------------------------------------------------
        case 4:					// Byte 4 to process
          //--------------------------------------------------------------
          // Check if Version Minor is one of TLS-V1.2/V1.1/V1.0 or SSL-V3
          //--------------------------------------------------------------
          if((pConnStruc->RX_HeaderBuffer[RH_VERSION_LSB_V2] !=
			TLS12_MINOR_VERSION) &&
             (pConnStruc->RX_HeaderBuffer[RH_VERSION_LSB_V2] !=
			TLS11_MINOR_VERSION) &&
             (pConnStruc->RX_HeaderBuffer[RH_VERSION_LSB_V2] !=
			TLS10_MINOR_VERSION) &&
             (pConnStruc->RX_HeaderBuffer[RH_VERSION_LSB_V2] !=
			SSL_MINOR_VERSION))
          {
            return(HSSL_RX_UNSUPPORTED_VERSION);
          }
          //-------------------------------------------------------------
          // Minor Version is TLS-V1.0/V1.1 or SSL-V3, check if supported
          // If TLS-V1.1/V1.0 received, protocol will check later!
          //-------------------------------------------------------------
          if(pConnStruc->RX_HeaderBuffer[RH_VERSION_LSB_V2] == SSL_MINOR_VERSION)
          {
            //---------------------------------------------------------
            // SSL-V3 compatible, check if SSL enabled at all
            //---------------------------------------------------------
            if((PossibleProtocols & SSL_BIT_MASK) == 0)	// SSL not enabled !
            {
              return(HSSL_RX_UNSUPPORTED_VERSION);
            }
          }
          //-----------------------------------------------------
          // we got a valid SSL-V2 client hello, disable further
          // SSL-V2 checking now
          //-----------------------------------------------------
          pConnStruc->RxHeaderSSLV2CheckEnable = 0;	// disable further SSL-V2 check
          return(HSSL_OP_OK);

        default:					// should not happen...
          return(HSSL_RX_ILLEGAL_PARAM);
      } // switch
    }
    //-------------------------------------------------------
    // B.2. from here on no SSL-V2 headers allowed anyway
    //      but protocol NOT yet negotiated !!!
    //-------------------------------------------------------
    switch(LastLen)				// == already processed count
    {
      //---------------------------------------------------
      // No bytes processed yet..
      //---------------------------------------------------
      case 0:					// Byte 0 to process
        if(((PossibleProtocols & (TLS_V2_BIT_MASK | TLS_V1_BIT_MASK | 
            TLS_BIT_MASK)) == 0) && // SSL-V3 only (!)
           ((pConnStruc->RX_HeaderBuffer[RH_TYPE] < CT_CHANGE_CIPHER_SPEC) ||
            (pConnStruc->RX_HeaderBuffer[RH_TYPE] > CT_APPLICATION_DATA)))
        {
	  return(HSSL_RX_ILLEGAL_PARAM);
        }
        NewHeaderLen--;
        if(NewHeaderLen <= 0)
          return(HSSL_OP_OK);
      //---------------------------------------------------
      // Byte 0 already processed
      //---------------------------------------------------
      case 1:					// Byte 1 to process
        if(pConnStruc->RX_HeaderBuffer[RH_VERSION_MSB] != TLS_SSL_MAJOR_VERSION)
        {
          return(HSSL_RX_ILLEGAL_PARAM);
        }
        NewHeaderLen--;
        if(NewHeaderLen <= 0)
          return(HSSL_OP_OK);
      //---------------------------------------------------
      // Byte 1 already processed
      //---------------------------------------------------
      case 2:					// Byte 2 to process
        //---------------------------------------------------------------
        // Minor version must be 0x00 (SSL), 0x01 (TLS1.0), 0x02 (TLS1.1)
        //---------------------------------------------------------------

        // Allowed protocol version may NOT be checked here as
        // ----- negotiation is still in progress !
        NewHeaderLen--;
        if(NewHeaderLen <= 0)
          return(HSSL_OP_OK);
      //---------------------------------------------------
      // Byte 2 already processed
      //---------------------------------------------------
      case 3:					// Byte 3 to process
        DataLen =
          ((int) pConnStruc->RX_HeaderBuffer[RH_LENGTH_MSB] & 0x0FF) << 8;
        if(DataLen > SSL_CIPH_RECORD_MAX_LEN)	// 16384 + 2048
        {
          return(HSSL_RX_ILLEGAL_PARAM);
        }
        NewHeaderLen--;
        if(NewHeaderLen <= 0)
          return(HSSL_OP_OK);
      //---------------------------------------------------
      // Byte 3 already processed
      //---------------------------------------------------
      case 4:					// Byte 4 to process
        DataLen =
          (((int) pConnStruc->RX_HeaderBuffer[RH_LENGTH_MSB] & 0x0FF) << 8) |
          ((int) pConnStruc->RX_HeaderBuffer[RH_LENGTH_LSB] & 0x0FF);
        if(DataLen > SSL_CIPH_RECORD_MAX_LEN)	// 16384 + 2048
        {
          return(HSSL_RX_ILLEGAL_PARAM);
        }
        return(HSSL_OP_OK);

      default:					// should not happen...
        return(HSSL_RX_ILLEGAL_PARAM);
    } // switch
  }
}

#if !defined XH_INTERFACE			// alternates used
/**
* Receives data from the TCP interface,
* assembles the records, runs them through decryption and
* decompression and distributes them to the 4 record layer clients
* for Change Cipherspec, Alert, Handshake and Application data (HSSL_Tcp_Receive).
*
*  @param pConnStruc Connection structure
*  @param pContStat Continuation state
*
*  @return HSSL_OP_OK on success, error code otherwise
*/
static int  HSSL_Tcp_Receive(CONNSTRU * pConnStruc, int* pContStat)
{
  int Retcode;
  int RequiredData;

  int RecordType,ProtVersionHigh,ProtVersionLow;
  int FragmentSize,FragmentOffset;
  int ActualProt=0;

  char* pBuf = NULL;

  char* pTmpBuf[1];
  int pTmpLen[1];
  int pTmpOff[1];
  //--------------------------------------------------
  // Check Input Parameters
  //--------------------------------------------------
  if((pConnStruc == NULL) || (pContStat == NULL))
    return(HSSL_NULL_PTR);
//DBG_PRINT("SSL TCP-RX: ");
  pContStat[0] = STATUS_CONTINUE;
  //--------------------------------------------------------
  // Check if data present from TCP Layer (for NON-Blocking)
  //--------------------------------------------------------
  if((pConnStruc->SocketMode & BLOCKING_MODE_MASK) ==
      NON_BLOCKING_MODE)
  {
    Retcode = HLSSL_CallBack(TCP_SELECT_RECV_FUNCTION,pConnStruc->SocketIndex,NULL,0,0);
    if(Retcode == 0)			// no Data Present
      return(HSSL_OP_OK);
  }
  //--------------------------------------------------
  // Distribute According to Current TCP Receive mode
  //--------------------------------------------------
  switch(pConnStruc->RX_State)
  {
    //-----------------------------------------------------
    // Start Header Receive, reset index
    //-----------------------------------------------------
    case TCP_RX_HDR_WAIT:			// wait for Header Start
 //   DBG_PRINT("R3");
      pConnStruc->RxHeaderIndex = 0;		// reset to start
      pConnStruc->RX_State = TCP_RX_HDR_READ; // set next state
    //------------------------------------------------------------
    // Header Receive in progress, read until complete/Error/Close
    //------------------------------------------------------------
    case TCP_RX_HDR_READ:
//    DBG_PRINT("R4");
      RequiredData = RECORD_HDR_SIZE - pConnStruc->RxHeaderIndex;
      Retcode = HLSSL_CallBack(TCP_RECEIVE_FUNCTION,pConnStruc->SocketIndex,pConnStruc->RX_HeaderBuffer,pConnStruc->RxHeaderIndex,RequiredData);
      if(Retcode <= 0)
      {
        if(Retcode < 0)
        {
          if(Retcode == -2)	// RX-Timeout
          {
	    if(pConnStruc->ConnectionState != CONN_STATE_CONNECTED) // connect.
            {
              return(Retcode);
            }
            pContStat[0] = STATUS_TCP_RX_TIMEOUT;
            return(HSSL_OP_OK);
          }  
	  pContStat[0] = STATUS_TCP_RX_ERROR;		// read error
          return(HSSL_RX_TCP_ERROR);
        }
        else
        {
//        DBG_PRINT("\nRemote Closed!!");
	  pContStat[0] = STATUS_CLOSED_BY_REMOTE;	// connection closed
          return(HSSL_OP_OK);
        }
      }
      RequiredData -= Retcode;			// check remaining amount

      // Check Record header validity
      if(Check_SSL_RecordHeader(pConnStruc,
  			        RECORD_HDR_SIZE-RequiredData) != HSSL_OP_OK)
      {
        SendAlert(pConnStruc,AD_UNEXPECTED_MSG,ALERT_LEVEL_FATAL);
        pContStat[0] = STATUS_FATAL_ALERT_QUEUED;
        return(HSSL_OP_OK);
      }

      if(RequiredData != 0)			// must wait for more
      {
        pConnStruc->RxHeaderIndex += Retcode;// increment index
        return(HSSL_OP_OK);
      }
      //------------------------------------------------------
      // All header data read, check if Fragment data to read
      // Check for SSL V2 Compatible Header Here,
      // ----- only process if SERVER and SSL-V2 mode enabled
      //------------------------------------------------------
      pConnStruc->RxFragmentIndex = 0;		// start of fragment = 0
      RecordType = pConnStruc->RX_HeaderBuffer[RH_TYPE] & 0xFF; // get Type
      if((RecordType & 0x80) != 0) // SSLV2 ?
      {
        //----------------------------------------------------
        // Could be SSL-V2 compatible Header, check further
        //----------------------------------------------------
        if((pConnStruc->Entity != SERVER_ENTITY) ||
           (pConnStruc->ConnectionState != CONN_STATE_HANDSHAKE_PHASE) ||
           (pConnStruc->Handshake_RX_LastMessage != 0) ||
           ((pConnStruc->ExtendedConf2Flags & SRVR_SSLV2_ACCEPT_BIT_MASK)==0) ||
           (pConnStruc->RX_HeaderBuffer[RH_MSG_TYPE_V2] != HT_CLIENT_HELLO_V2) ||
           (pConnStruc->RX_HeaderBuffer[RH_VERSION_MSB_V2] !=
              TLS_SSL_MAJOR_VERSION) ||
           ((pConnStruc->RX_HeaderBuffer[RH_VERSION_LSB_V2] !=
              TLS12_MINOR_VERSION) &&
            (pConnStruc->RX_HeaderBuffer[RH_VERSION_LSB_V2] !=
              TLS11_MINOR_VERSION) &&
            (pConnStruc->RX_HeaderBuffer[RH_VERSION_LSB_V2] !=
              TLS10_MINOR_VERSION) &&
            (pConnStruc->RX_HeaderBuffer[RH_VERSION_LSB_V2] !=
              SSL_MINOR_VERSION)))
        {
          SendAlert(pConnStruc,AD_UNEXPECTED_MSG,ALERT_LEVEL_FATAL);
          pContStat[0] = STATUS_FATAL_ALERT_QUEUED;
          return(HSSL_OP_OK);
        }
        //---------------------------------------------------------------
        // Is a SSL V2 compatible client Hello, get Data Size to fetch
        //---------------------------------------------------------------
        BIGchar2wordn(pConnStruc->RX_HeaderBuffer,
		    RequiredData,RH_LENGTH_MSB_V2);
        RequiredData = (RequiredData & RH_LENGTH_MASK_V2) - 3; // alrdy 3 bytes!
        if((RequiredData < SSL_V2_MIN_RECORD_LEN) ||
           (RequiredData > SSL_V2_MAX_RECORD_LEN))
        {
          SendAlert(pConnStruc,AD_RECORD_OVERFLOW,ALERT_LEVEL_FATAL);
          pContStat[0] = STATUS_FATAL_ALERT_QUEUED;
          return(HSSL_OP_OK);
        }
        pConnStruc->RX_HeaderBuffer[RH_TYPE] = (unsigned char) CT_RESERVED; //set internal Type!
      }        
      else
      {
        //--------------------------------------------
        // SSL-V3/TLS
        //--------------------------------------------
        BIGchar2wordn(pConnStruc->RX_HeaderBuffer,
		      RequiredData,RH_LENGTH);
        if((RequiredData < 0) ||
           (RequiredData > SSL_CIPH_RECORD_MAX_LEN))
        {
//        DBG_PRINT("OVERFLOW !!");
          SendAlert(pConnStruc,AD_RECORD_OVERFLOW,ALERT_LEVEL_FATAL);
          pContStat[0] = STATUS_FATAL_ALERT_QUEUED;
          return(HSSL_OP_OK);
        }
      }
      //---------------------------------------------------
      // Receive Required Data block
      //---------------------------------------------------
      pConnStruc->RxFragmentOffset  = RECORD_HDR_SIZE;	// initial offset
      pConnStruc->RxFragmentSize = RequiredData; // set additional RX-Data
      pConnStruc->RxFragmentToReadCount = RequiredData; // set received
      if(RequiredData == 0)
      {
        pConnStruc->RX_State = TCP_RX_HDR_WAIT; // set next state
        break;					// no Frag-Buffer !!
      }      
      pConnStruc->RX_State = TCP_RX_FRAGMENT_BUF_WAIT; // set next state
      //----------------------------------------------------------
      // Fragment data must be read, check if data present
      //----------------------------------------------------------
      if((pConnStruc->SocketMode & BLOCKING_MODE_MASK) ==
        NON_BLOCKING_MODE)
      {
        Retcode = HLSSL_CallBack(TCP_SELECT_RECV_FUNCTION,pConnStruc->SocketIndex,NULL,0,0);
        if(Retcode == 0)			// no Data Present
          return(HSSL_OP_OK);
      }
    //------------------------------------------------------------
    // Fragment Buffer Request, allocate the buffer
    //------------------------------------------------------------
    case TCP_RX_FRAGMENT_BUF_WAIT:
//    DBG_PRINT("5");
      pBuf = BIT8_ARRAY_ALLOC_POOL(HMEM_CTX_REF,
			      pConnStruc->RxFragmentSize+RECORD_HDR_SIZE);
      if(pBuf == NULL)				// must wait for Data
        return(HSSL_OP_OK);
      pConnStruc->pRxFragmentBuffer = pBuf;	// save buffer base
      pConnStruc->RxFragmentIndex = RECORD_HDR_SIZE; // start after Record Header
      pConnStruc->RX_State = TCP_RX_FRAGMENT_READ; // set next state
    //------------------------------------------------------------
    // Fragment Buffer Read, read the data
    //------------------------------------------------------------
    case TCP_RX_FRAGMENT_READ:
//    DBG_PRINT("6");
      RequiredData = pConnStruc->RxFragmentToReadCount;
      Retcode = HLSSL_CallBack(TCP_RECEIVE_FUNCTION,pConnStruc->SocketIndex,pConnStruc->pRxFragmentBuffer,pConnStruc->RxFragmentIndex,RequiredData);
      if(Retcode <= 0)
      {
        if(Retcode < 0)
        {
          if(Retcode == -2)	// TX-Timeout
          {
	    if(pConnStruc->ConnectionState != CONN_STATE_CONNECTED) // connect.
            {
              return(Retcode);
            }
            pContStat[0] = STATUS_TCP_RX_TIMEOUT;
            return(HSSL_OP_OK);
          }  
//	  DBG_PRINT("\nTCP RX Error 2");
	  pContStat[0] = STATUS_TCP_RX_ERROR;		// read error
          return(HSSL_RX_TCP_ERROR);
        }
        else
        {
//        DBG_PRINT("\nClosed By Remote 2 !!");
	  pContStat[0] = STATUS_CLOSED_BY_REMOTE;	// connection closed
	  return(HSSL_OP_OK);
        }
      }
      RequiredData -= Retcode;			// check remaining amount
      if(RequiredData != 0)			// must wait for more
      {
        pConnStruc->RxFragmentIndex += Retcode;	// increment index
        pConnStruc->RxFragmentToReadCount -= Retcode; // reduce count
        return(HSSL_OP_OK);
      }
      pConnStruc->RX_State = TCP_RX_HDR_WAIT; // set next state
      break;					// all data present !
    //------------------------------------------------------------
    // Fragment Decompression Buffer Wait
    //------------------------------------------------------------
    case TCP_RX_DSTBUF_WAIT:
      break;
  }
  //--------------------------------------------------------------
  // Record header and data have been read, distribute by contents
  //--------------------------------------------------------------
  pBuf = pConnStruc->pRxFragmentBuffer;
  RecordType = (int) pConnStruc->RX_HeaderBuffer[RH_TYPE] & 0xFF;
  ProtVersionHigh = (int) pConnStruc->RX_HeaderBuffer[RH_VERSION_MSB] & 0xFF;
  ProtVersionLow  = (int) pConnStruc->RX_HeaderBuffer[RH_VERSION_LSB] & 0xFF;
  if(RecordType == CT_RESERVED)			// SSL-V2 compat.
  {
    ProtVersionHigh= (int) pConnStruc->RX_HeaderBuffer[RH_VERSION_MSB_V2] & 0xFF;
    ProtVersionLow = (int) pConnStruc->RX_HeaderBuffer[RH_VERSION_LSB_V2] & 0xFF;
  }
  FragmentOffset = pConnStruc->RxFragmentOffset;	// Start of data (after decrypt)
  FragmentSize   = pConnStruc->RxFragmentSize;
  ActualProt     = pConnStruc->ActualProtocol;
  //----------------------------------------------------------------
  // Check if we are waiting for decompression buffer
  //----------------------------------------------------------------
  if(pConnStruc->RX_State != TCP_RX_DSTBUF_WAIT)
  {
    if(pBuf != NULL)				// check if data collected...
      memcpy(pBuf+0,pConnStruc->RX_HeaderBuffer+0,RECORD_HDR_SIZE);

    if(pConnStruc->ConnectionState == CONN_STATE_CONNECTED)
    {
      ADD_64(pConnStruc->RXDataMSW,pConnStruc->RXDataLSW,
	     (int) (FragmentSize + RECORD_HDR_SIZE));
    }

    //----------------------------------------------
    // Check for recognized record type
    //----------------------------------------------
    if(((RecordType < CT_CHANGE_CIPHER_SPEC) ||	// unknown record
        (RecordType > CT_APPLICATION_DATA)) &&
        (RecordType != CT_RESERVED))
    {
      FREE_ARRAY_POOL(HMEM_CTX_REF,pBuf);		// free
      pConnStruc->pRxFragmentBuffer = NULL;
      //--------------------------------------------
      // Check for TLS protocols, if 1.0/1.1, just ignore
      //--------------------------------------------
      if(ProtVersionLow == SSL_MINOR_VERSION){
        SendAlert(pConnStruc,AD_ILLEGAL_PARAMETER,ALERT_LEVEL_FATAL);
        pContStat[0] = STATUS_FATAL_ALERT_QUEUED; //   Record Type error
      } else if (ProtVersionLow == TLS12_MINOR_VERSION){
        SendAlert(pConnStruc,AD_UNEXPECTED_MSG,ALERT_LEVEL_FATAL);
        pContStat[0] = STATUS_FATAL_ALERT_QUEUED; //   Record Type error
      }

      return(HSSL_OP_OK);
    }

    if(FragmentSize == 0)				// no Fragment data
    {
      // Buffer free was missing !!!
      FREE_ARRAY_POOL(HMEM_CTX_REF,pBuf);		// free
      pConnStruc->pRxFragmentBuffer = NULL;
      return(HSSL_OP_OK);
    }

    if(RecordType == CT_RESERVED)
    {
      //----------------------------------------------------
      // Special Processing for SSL-V2 Startup done here !!!
      //----------------------------------------------------
      Retcode = ProcessRX_Message(pConnStruc,(unsigned char) HT_CLIENT_HELLO_V2_LCL,
		                  pBuf,0,FragmentSize+RECORD_HDR_SIZE,
				  pContStat);
      FREE_ARRAY_POOL(HMEM_CTX_REF,pBuf);
      pConnStruc->pRxFragmentBuffer = NULL;
      return(Retcode);
    }

    //--------------------------------------------------------------
    // Decrypt the received Data (Buffer will not increase !)
    // Send Alert if decryption fails
    // Failure of Decryption can only be detected for CBC Mode
    // ----- (invalid padding). This opens possible Timing attack
    //       hole.
    // Solution: Do NOT signal Decryption error, but continue with
    // --------- MAC verification, that should fail anyway !
    //          
    //--------------------------------------------------------------
    pTmpLen[0] = FragmentSize;			// set Size
    pTmpOff[0] = FragmentOffset;		// set Offset (TLS V1.1)

    Retcode = DecryptRecord(
			    pConnStruc,pBuf,pTmpOff,pTmpLen);

    FragmentOffset = pTmpOff[0];
    //--------------------------------------------------------------
    // Verify/Remove the Cipher MAC (Buffer will not increase !)
    // Send Alert if verify fails
    //--------------------------------------------------------------
    Retcode |= VerifyRemoveCipherMac(
				    pConnStruc,pBuf,0,pTmpLen);
    if(Retcode != HSSL_OP_OK)
    {
      FREE_ARRAY_POOL(HMEM_CTX_REF,pBuf);		// free
      pConnStruc->pRxFragmentBuffer = NULL;
      SendAlert(pConnStruc,AD_BAD_RECORD_MAC,ALERT_LEVEL_FATAL);
      pContStat[0] = STATUS_FATAL_ALERT_QUEUED;	// verify error    
      return(Retcode);
    }    
    FragmentSize = pTmpLen[0] - (FragmentOffset - RECORD_HDR_SIZE);
    pConnStruc->RxFragmentSize = FragmentSize;
    pConnStruc->RxFragmentOffset  = FragmentOffset;
  }
  //--------------------------------------------------------------
  // Decompress the received, decrypted, verified fragment
  // Send Alert if decompression fails
  //--------------------------------------------------------------
  FragmentSize   = pConnStruc->RxFragmentSize;	// get size (REENTRY!)
  FragmentOffset = pConnStruc->RxFragmentOffset;	// start of netto data

  if(pConnStruc->ActRX_ComprAlgor != COMPR_NULL)
  {
    pTmpLen[0] = FragmentSize;				// set source size    
    Retcode = DecompressRecord(pConnStruc,pBuf,FragmentOffset,pTmpBuf,pTmpLen);
    if(Retcode != HSSL_OP_OK)
    {
      FREE_ARRAY_POOL(HMEM_CTX_REF,pBuf);		// free
      pConnStruc->pRxFragmentBuffer = NULL;
      SendAlert(pConnStruc,AD_DECOMPRESS_FAILURE,ALERT_LEVEL_FATAL);
      pContStat[0] = STATUS_FATAL_ALERT_QUEUED; // decompress error
      return(Retcode);
    }    
    if(pTmpBuf[0] == NULL)			// no system buffers !
    {
      pConnStruc->RX_State = TCP_RX_DSTBUF_WAIT; // set next state
      return(HSSL_OP_OK);
    }
    pConnStruc->RX_State = TCP_RX_HDR_WAIT; // set next state (!)
    FragmentSize = pTmpLen[0];			// get data length
    FREE_ARRAY_POOL(HMEM_CTX_REF,pBuf);		// free other buffer
    pBuf = pTmpBuf[0];
    pConnStruc->pRxFragmentBuffer = pBuf;
    FragmentOffset = 0;				// no header !!
  }

  // Check for maximum record length
  if( SSL_PLAIN_RECORD_MAX_LEN < FragmentSize ){
     // Error code depending on Protocol version 
     if(ProtVersionLow == SSL_MINOR_VERSION){
        SendAlert(pConnStruc,AD_DECOMPRESS_FAILURE,ALERT_LEVEL_FATAL);
     }else{
        SendAlert(pConnStruc,AD_RECORD_OVERFLOW,ALERT_LEVEL_FATAL);
     }
     pContStat[0] = STATUS_FATAL_ALERT_QUEUED;
     return(HSSL_RX_ILLEGAL_PARAM);
  }

  //--------------------------------------------------------------
  // Distribute the plain fragment to the assembly / test routines
  //--------------------------------------------------------------

  Retcode = HSSL_OP_OK;		// for Compiler (warning)
  switch(RecordType)
  {
    case CT_CHANGE_CIPHER_SPEC:
      Retcode = ProcessRX_ChangeCipherSpec(pConnStruc,pBuf,FragmentOffset,
					   FragmentSize,pContStat);
      break;

    case CT_ALERT:
      Retcode = ProcessRX_Alert(pConnStruc,pBuf,FragmentOffset,
				FragmentSize,pContStat);
      break;

    case CT_HANDSHAKE:
      Retcode = AssembleProcessRX_Handshake(pConnStruc,pBuf,FragmentOffset,
					    FragmentSize,pContStat);
      break;

    case CT_APPLICATION_DATA:
      Retcode = ProcessRX_ApplData(pConnStruc,pBuf,FragmentOffset,
				   FragmentSize,pContStat);
      pBuf = NULL;			// prevent freeing the buffer !!
      break;

    default:				// can not happen !!
      break;
  } // switch
  FREE_ARRAY_POOL(HMEM_CTX_REF,pBuf);
  pConnStruc->pRxFragmentBuffer = NULL;

  return(Retcode);
}
#endif // !defined XH_INTERFACE

#if defined XH_INTERFACE
/**
* Get length of data from a list of data structures (GetXH2ListDataLen).
* Required for Version 2 of interface.
*
*  @param pDataList List start pointer
*  @return DataLen if >= 0, else error occured
*/
static  int  GetXH2ListDataLen(struct dsd_gather_i_1 * pDataList)
{
  int DataLen = 0;

  if(pDataList == NULL)
    return(0);

  for(;;)
  {
    if((pDataList->achc_ginp_cur != NULL) &&
       (pDataList->achc_ginp_end != NULL))
    {
      DataLen += (int) (pDataList->achc_ginp_end -
                        pDataList->achc_ginp_cur);
    }
    pDataList = pDataList->adsc_next;
    if(pDataList == NULL)
      return(DataLen);
  }
}
/**
* Copy data fragments from a list of data structures to a linear
* buffer (CopyXH2DataListToBuffer).
* Required for Version 2 of interface.
*
* <ol>
* <li> The buffer must have been properly allocated, size not checked
* <li> The list fragment buffers are 'cleared' [current = end] when
*	    processed
*</ol>
*  @param pDataList List start pointer
*  @param pDstBuf Destination of copy
*  @param DstOff Start of Data
*  @param DstLen max. Size of data to copy
*  @return CopiedCount
*/
static  int  CopyXH2DataListToBuffer(
				struct dsd_gather_i_1 * pDataList,
				char* pDstBuf, int DstOff, int DstLen)
{
  int CopiedLen = 0;
  int CopyLen;
  int FragmentLen;

  if((pDataList == NULL) || (pDstBuf == NULL) || (DstLen <= 0))
    return(0);

  for(;;)
  {
    if((pDataList->achc_ginp_cur != NULL) &&
       (pDataList->achc_ginp_end != NULL))
    {
      FragmentLen = (int) (pDataList->achc_ginp_end -
		           pDataList->achc_ginp_cur);
      if(FragmentLen > 0)
      {
	CopyLen = FragmentLen;
        if(CopyLen > DstLen)				// limit copy
          CopyLen = DstLen;	

        memcpy(pDstBuf+DstOff,pDataList->achc_ginp_cur+0,CopyLen);
	DstOff += CopyLen;
	DstLen -= CopyLen;
        CopiedLen += CopyLen;
        pDataList->achc_ginp_cur += CopyLen;
        if((CopyLen < FragmentLen) || (DstLen <= 0))
          return(CopiedLen);
      }
    }
    pDataList = pDataList->adsc_next;
    if(pDataList == NULL)
      return(CopiedLen);
  }
}

#if XH_INTF_VERSION >= 300
/**
* Copy data fragments from a list of data structures to a linear
* buffer (CopyXH3DataListToBuffer).
* Required for Version 3 of interface.
*
* <ol>
* <li> The buffer must have been properly allocated, size not checked
* <li> The list fragment buffers are NOT 'cleared' when processed
*</ol>
*  @param pDataList List start pointer
*  @param pDstBuf Destination of copy
*  @param DstOff Start of Data
*  @param DstLen max. Size of data to copy
*  @return CopiedCount
*/
static  int  CopyXH3DataListToBuffer(
				struct dsd_gather_i_1 * pDataList,
				char* pDstBuf, int DstOff, int DstLen)
{
  int CopiedLen = 0;
  int CopyLen;
  int FragmentLen;

  if((pDataList == NULL) || (pDstBuf == NULL) || (DstLen <= 0))
    return(0);

  for(;;)
  {
    if((pDataList->achc_ginp_cur != NULL) &&
       (pDataList->achc_ginp_end != NULL))
    {
      FragmentLen = (int) (pDataList->achc_ginp_end -
		           pDataList->achc_ginp_cur);
      if(FragmentLen > 0)
      {
	CopyLen = FragmentLen;
        if(CopyLen > DstLen)				// limit copy
          CopyLen = DstLen;	

        memcpy(pDstBuf+DstOff,pDataList->achc_ginp_cur+0,CopyLen);
	DstOff += CopyLen;
	DstLen -= CopyLen;
        CopiedLen += CopyLen;
        if((CopyLen < FragmentLen) || (DstLen <= 0))
          return(CopiedLen);
      }
    }
    pDataList = pDataList->adsc_next;
    if(pDataList == NULL)
      return(CopiedLen);
  }
}
#endif // XH_INTF_VERSION >= 300

/**
* Implements TCP recieve for the WSP C interface. This is the main implementation for
* both client and server side (m_xh_tcp_receive_main).
*
* <ol>
*  <li> Receives data fragments from the receive buffer, checking the header and 
*        reassembling fragmented records in the process.
*  <li> Decodes the records according to the current cipher state.
*  <li> Distributes the decoded records to the Processing functions according
*        to their record type.
* </ol>
*
* This does not perform any network recv operations.
*   
*   @param pConnStruc       Connection structure of the processed connection
*   @param DataLen          Amount of data present
*   @param pContStat        Continuation state
*   @param inp_is_server    TRUE, if a server instance is calling, FALSE for 
*                           Client
*   @param avop_xh_struc    Pointer to the XH structure of the caller
*
*   @return HSSL_OP_OK on success, error code otherwise
*/
static int  m_xh_tcp_receive_main( CONNSTRU * pConnStruc, 
                                        int DataLen,
                                        int* pContStat, 
                                        int inp_is_server, 
                                        void* avop_xh_struc)
{
  int Retcode;
  int ChkRetcode;
  int RequiredData;
  int RxDataLen;
  int TmpDataLen;

  int RecordType,ProtVersionLow;
  int FragmentSize,FragmentOffset;

  char* pBuf = NULL;

  char* pTmpBuf[1];
  int pTmpLen[1];
  int pTmpOff[1];

  HMEM_CTX_DEF1;

  //--------------------------------------------------
  // Check Input Parameters
  //--------------------------------------------------

//DBG_PRINT("SSL TCP-RX: ");

  pContStat[0] = STATUS_CONTINUE;

  LOAD_HMEM_CTX_PTR(CONN_pMemCtx(pConnStruc));
  //------------------------------------------
  // Check if RX data present from Upper layer
  //------------------------------------------
  if((RxDataLen = DataLen) <= 0)
    return(HSSL_OP_OK);
  //--------------------------------------------------
  // Distribute According to Current TCP Receive mode
  //--------------------------------------------------
  switch(pConnStruc->RX_State)
  {
    //-----------------------------------------------------
    // Start Header Receive, reset index
    //-----------------------------------------------------
    case TCP_RX_HDR_WAIT:			// wait for Header Start
 //   DBG_PRINT("R3");
      pConnStruc->RxHeaderIndex = 0;		// reset to start
      pConnStruc->RX_State = TCP_RX_HDR_READ; // set next state
    //------------------------------------------------------------
    // Header Receive in progress, read until complete/Error/Close
    //------------------------------------------------------------
    case TCP_RX_HDR_READ:
//    DBG_PRINT("R4");
      RequiredData = RECORD_HDR_SIZE - pConnStruc->RxHeaderIndex;
      //-----------------------------------
      // read the data to the header buffer
      //-----------------------------------
#if (XH_INTF_VERSION < 300)
      RxDataLen = (int) (((struct dsd_hl_ssl_s_2 *)avop_xh_struc)->achc_inp_end
                      - ((struct dsd_hl_ssl_s_2 *)avop_xh_struc)->achc_inp_cur);
#endif
      TmpDataLen = RxDataLen;
      if(TmpDataLen > RequiredData)	// more data present than needed
        TmpDataLen = RequiredData;	// set required count
      if(inp_is_server){
#if (XH_INTF_VERSION < 300)
      memcpy(pConnStruc->RX_HeaderBuffer+pConnStruc->RxHeaderIndex,((struct dsd_hl_ssl_s_2 *)avop_xh_struc)->achc_inp_cur+0,TmpDataLen);
      ((struct dsd_hl_ssl_s_2 *)avop_xh_struc)->achc_inp_cur += TmpDataLen; 
        // adjust pointer
        Retcode = TmpDataLen;
#else
        Retcode = CopyXH2DataListToBuffer(
            ((struct dsd_hl_ssl_s_3 *)avop_xh_struc)->adsc_gai1_fromcl,
			pConnStruc->RX_HeaderBuffer,
			pConnStruc->RxHeaderIndex, TmpDataLen);
#endif
      } else {
        Retcode = CopyXH2DataListToBuffer(
            ((struct dsd_hl_ssl_c_1 *)avop_xh_struc)->adsc_gai1_in_se,
			pConnStruc->RX_HeaderBuffer,
			pConnStruc->RxHeaderIndex, TmpDataLen);
      }
      RxDataLen    -= TmpDataLen;	// reduce total size
      RequiredData -= TmpDataLen;	// check remaining amount

      // Check Record header validity
      if((ChkRetcode = Check_SSL_RecordHeader(pConnStruc,
  			        RECORD_HDR_SIZE-RequiredData)) != HSSL_OP_OK)
      {
        SendAlert(pConnStruc,AD_UNEXPECTED_MSG,ALERT_LEVEL_FATAL);
        pContStat[0] = STATUS_FATAL_ALERT_QUEUED;
        if(inp_is_server){
          return(ChkRetcode);
        } else {
          return(HSSL_OP_OK);
        }
      }

      if(RequiredData != 0)			// must wait for more
      {
        if(inp_is_server){
          pConnStruc->RxHeaderIndex += Retcode;// increment index server
        } else {
          pConnStruc->RxHeaderIndex += TmpDataLen;// increment index client
        }
        return(HSSL_OP_OK);
      }
      //------------------------------------------------------
      // All header data read, check if Fragment data to read
      // Check for SSL V2 Compatible Header Here,
      // ----- only process if SERVER and SSL-V2 mode enabled
      //------------------------------------------------------
      pConnStruc->RxFragmentIndex = 0;		// start of fragment = 0
      RecordType = pConnStruc->RX_HeaderBuffer[RH_TYPE] & 0xFF; // get Type
      if((RecordType & 0x80) != 0) // SSLV2 ?
      {
        //----------------------------------------------------
        // Could be SSL-V2 compatible Header, check further
        //----------------------------------------------------
        if((!(inp_is_server)) ||    // only server may get SSL-V2 Client Hello
           (pConnStruc->ConnectionState != CONN_STATE_HANDSHAKE_PHASE) ||
           (pConnStruc->Handshake_RX_LastMessage != 0) ||
           ((pConnStruc->ExtendedConf2Flags & SRVR_SSLV2_ACCEPT_BIT_MASK)==0)||
           (pConnStruc->RX_HeaderBuffer[RH_MSG_TYPE_V2] != HT_CLIENT_HELLO_V2)||
           (pConnStruc->RX_HeaderBuffer[RH_VERSION_MSB_V2] !=
              TLS_SSL_MAJOR_VERSION) ||
           ((pConnStruc->RX_HeaderBuffer[RH_VERSION_LSB_V2] !=
              TLS12_MINOR_VERSION) &&
            (pConnStruc->RX_HeaderBuffer[RH_VERSION_LSB_V2] !=
              TLS11_MINOR_VERSION) &&
            (pConnStruc->RX_HeaderBuffer[RH_VERSION_LSB_V2] !=
              TLS10_MINOR_VERSION) &&
            (pConnStruc->RX_HeaderBuffer[RH_VERSION_LSB_V2] !=
              SSL_MINOR_VERSION)))
        {
          SendAlert(pConnStruc,AD_UNEXPECTED_MSG,ALERT_LEVEL_FATAL);
          pContStat[0] = STATUS_FATAL_ALERT_QUEUED;
          return(HSSL_OP_OK);
        }
        //---------------------------------------------------------------
        // Is a SSL V2 compatible client Hello, get Data Size to fetch
        //---------------------------------------------------------------
        BIGchar2wordn(pConnStruc->RX_HeaderBuffer,
		    RequiredData,RH_LENGTH_MSB_V2);
        RequiredData = (RequiredData & RH_LENGTH_MASK_V2) - 3; // alrdy 3 bytes!
        if((RequiredData < SSL_V2_MIN_RECORD_LEN) ||
           (RequiredData > SSL_V2_MAX_RECORD_LEN))
        {
          SendAlert(pConnStruc,AD_RECORD_OVERFLOW,ALERT_LEVEL_FATAL);
          pContStat[0] = STATUS_FATAL_ALERT_QUEUED;
          return(HSSL_OP_OK);
        }
        pConnStruc->RX_HeaderBuffer[RH_TYPE] = (char)
          ((unsigned char) CT_RESERVED);				//set internal Type!
      }        
      else
      {
        //--------------------------------------------
        // SSL-V3/TLS
        //--------------------------------------------
        BIGchar2wordn(pConnStruc->RX_HeaderBuffer,
		      RequiredData,RH_LENGTH);
        if((RequiredData < 0) ||
           (RequiredData > SSL_CIPH_RECORD_MAX_LEN))
        {
//        DBG_PRINT("OVERFLOW !!");
          SendAlert(pConnStruc,AD_RECORD_OVERFLOW,ALERT_LEVEL_FATAL);
          pContStat[0] = STATUS_FATAL_ALERT_QUEUED;
          return(HSSL_OP_OK);
        }
      }
      //---------------------------------------------------
      // Receive Required Data block
      //---------------------------------------------------
      pConnStruc->RxFragmentOffset  = RECORD_HDR_SIZE;	// initial offset
      pConnStruc->RxFragmentSize = RequiredData; // set additional RX-Data
      pConnStruc->RxFragmentToReadCount = RequiredData; // set received
      if(RequiredData == 0)
      {
        pConnStruc->RX_State = TCP_RX_HDR_WAIT; // set next state
        break;					// no Frag-Buffer !!
      }      
      pConnStruc->RX_State = TCP_RX_FRAGMENT_BUF_WAIT; // set next state
      //----------------------------------------------------------
      // Fragment data must be read, check if data present
      //----------------------------------------------------------
#if (XH_INTF_VERSION < 300)
      if((((struct dsd_hl_ssl_s_2 *)avop_xh_struc)->achc_inp_end
            == ((struct dsd_hl_ssl_s_2 *)avop_xh_struc)->achc_inp_cur))
#else
      if(RxDataLen <= 0)
#endif
        return(HSSL_OP_OK);			// wait for more...
    //------------------------------------------------------------
    // Fragment Buffer Request, allocate the buffer
    //------------------------------------------------------------
    case TCP_RX_FRAGMENT_BUF_WAIT:
//    DBG_PRINT("5");
      pBuf = BIT8_ARRAY_ALLOC_POOL(HMEM_CTX_REF,
		pConnStruc->RxFragmentSize+RECORD_HDR_SIZE);
      if(pBuf == NULL)				// must wait for Data
        return(HSSL_OP_OK);
      pConnStruc->pRxFragmentBuffer = pBuf;	// save buffer base
      pConnStruc->RxFragmentIndex = RECORD_HDR_SIZE; //start past Record Hdr.
      pConnStruc->RX_State = TCP_RX_FRAGMENT_READ; // set next state
    //------------------------------------------------------------
    // Fragment Buffer Read, read the data
    //------------------------------------------------------------
    case TCP_RX_FRAGMENT_READ:
//    DBG_PRINT("6");
      RequiredData = pConnStruc->RxFragmentToReadCount;
      //--------------------------------------------
      // read the data to the fragment buffer
      //--------------------------------------------
#if (XH_INTF_VERSION < 300)
      RxDataLen = (int) (((struct dsd_hl_ssl_s_2 *)avop_xh_struc)->achc_inp_end
                      - ((struct dsd_hl_ssl_s_2 *)avop_xh_struc)->achc_inp_cur);
#endif
      TmpDataLen = RxDataLen;
      if(TmpDataLen > RequiredData)	// more data present than needed
        TmpDataLen = RequiredData;	// set required count
      if(inp_is_server){
#if (XH_INTF_VERSION < 300)
      memcpy(pConnStruc->pRxFragmentBuffer+pConnStruc->RxFragmentIndex,((struct dsd_hl_ssl_s_2 *)avop_xh_struc)->achc_inp_cur+0,TmpDataLen);
      ((struct dsd_hl_ssl_s_2 *)avop_xh_struc)->achc_inp_cur += TmpDataLen; 
        // adjust pointer
#else
        Retcode = CopyXH3DataListToBuffer(
            ((struct dsd_hl_ssl_s_3 *)avop_xh_struc)->adsc_gai1_fromcl,
			pConnStruc->pRxFragmentBuffer,
			pConnStruc->RxFragmentIndex, TmpDataLen);
#endif
      } else {
        Retcode = CopyXH2DataListToBuffer(
            ((struct dsd_hl_ssl_c_1 *)avop_xh_struc)->adsc_gai1_in_se,
			pConnStruc->pRxFragmentBuffer,
			pConnStruc->RxFragmentIndex, TmpDataLen);
      }

      RxDataLen -= TmpDataLen;		// reduce amount
      RequiredData -= TmpDataLen;	// check remaining amount

      if(RequiredData != 0)		// must wait for more
      {
        pConnStruc->RxFragmentIndex     += TmpDataLen; // increment index
        pConnStruc->RxFragmentToReadCount -= TmpDataLen; // reduce count
        return(HSSL_OP_OK);
      }
      pConnStruc->RX_State = TCP_RX_HDR_WAIT; // set next state
      break;					// all data present !
    //------------------------------------------------------------
    // Fragment Decompression Buffer Wait
    //------------------------------------------------------------
    case TCP_RX_DSTBUF_WAIT:
      break;
  }
  //--------------------------------------------------------------
  // Record header and data have been read, distribute by contents
  //--------------------------------------------------------------
  pBuf = pConnStruc->pRxFragmentBuffer;
  RecordType = (int) pConnStruc->RX_HeaderBuffer[RH_TYPE] & 0xFF;
  ProtVersionLow  = (int) pConnStruc->RX_HeaderBuffer[RH_VERSION_LSB] & 0xFF;
  if(RecordType == CT_RESERVED)			// SSL-V2 compat.
  {
    ProtVersionLow = (int) pConnStruc->RX_HeaderBuffer[RH_VERSION_LSB_V2] & 0xFF;
  }
  FragmentOffset = pConnStruc->RxFragmentOffset;// Start of data (after decrypt)
  FragmentSize   = pConnStruc->RxFragmentSize;
  //----------------------------------------------------------------
  // Check if we are waiting for decompression buffer
  //----------------------------------------------------------------
  if(pConnStruc->RX_State != TCP_RX_DSTBUF_WAIT)
  {
    if(pBuf != NULL)				// check if data collected...
      memcpy(pBuf+0,pConnStruc->RX_HeaderBuffer+0,RECORD_HDR_SIZE);

    if(pConnStruc->ConnectionState == CONN_STATE_CONNECTED)
    {
      ADD_64(pConnStruc->RXDataMSW,pConnStruc->RXDataLSW,
	     (int) (FragmentSize + RECORD_HDR_SIZE));
    }
    //----------------------------------------------
    // Check for recognized record type
    //----------------------------------------------

    if(((RecordType < CT_CHANGE_CIPHER_SPEC) ||	// unknown record
        (RecordType > CT_APPLICATION_DATA)) &&
        ((!(inp_is_server)) || (RecordType != CT_RESERVED)))
    {
      FREE_ARRAY_POOL(HMEM_CTX_REF,pBuf);		// free
      pConnStruc->pRxFragmentBuffer = NULL;
      //--------------------------------------------
      // Check for TLS protocols, if 1.0/1.1, just ignore
      //--------------------------------------------
      if(ProtVersionLow == SSL_MINOR_VERSION){
        SendAlert(pConnStruc,AD_ILLEGAL_PARAMETER,ALERT_LEVEL_FATAL);
        pContStat[0] = STATUS_FATAL_ALERT_QUEUED; //   Record Type error
      } else if (ProtVersionLow == TLS12_MINOR_VERSION){
        SendAlert(pConnStruc,AD_UNEXPECTED_MSG,ALERT_LEVEL_FATAL);
        pContStat[0] = STATUS_FATAL_ALERT_QUEUED; //   Record Type error
      }
      return(HSSL_OP_OK);
    }
    if(FragmentSize == 0)				// no Fragment data
    {
      // Next was missing !!!
      FREE_ARRAY_POOL(HMEM_CTX_REF,pBuf);		// free
      pConnStruc->pRxFragmentBuffer = NULL;
      return(HSSL_OP_OK);
    }
    if(RecordType == CT_RESERVED && inp_is_server)
    {
      //----------------------------------------------------
      // Special Processing for SSL-V2 Startup done here !!!
      //----------------------------------------------------
      Retcode = ProcessRX_Message(pConnStruc,(unsigned char) HT_CLIENT_HELLO_V2_LCL,
		                  pBuf,0,FragmentSize+RECORD_HDR_SIZE,
				  pContStat);
      FREE_ARRAY_POOL(HMEM_CTX_REF,pBuf);
      pConnStruc->pRxFragmentBuffer = NULL;
      return(Retcode);
    }

    //--------------------------------------------------------------
    // Decrypt the received Data (Buffer will not increase !)
    // Send Alert if decryption fails
    // Failure of Decryption can only be detected for CBC Mode
    // ----- (invalid padding). This opens possible Timing attack
    //       hole.
    // Solution: Do NOT signal Decryption error, but continue with
    // --------- MAC verification, that should fail anyway !
    //--------------------------------------------------------------
    pTmpLen[0] = FragmentSize;			// set Size
    pTmpOff[0] = FragmentOffset;		// set Offset (TLS V1.1)

    Retcode = DecryptRecord(
			    pConnStruc,pBuf,pTmpOff,pTmpLen);

    FragmentOffset = pTmpOff[0];
    //--------------------------------------------------------------
    // Verify/Remove the Cipher MAC (Buffer will not increase !)
    // Send Alert if verify fails
    //--------------------------------------------------------------
    Retcode |= VerifyRemoveCipherMac(
				    pConnStruc,pBuf,0,pTmpLen);
    if(Retcode != HSSL_OP_OK)
    {
      FREE_ARRAY_POOL(HMEM_CTX_REF,pBuf);		// free
      pConnStruc->pRxFragmentBuffer = NULL;
      SendAlert(pConnStruc,AD_BAD_RECORD_MAC,ALERT_LEVEL_FATAL);
      pContStat[0] = STATUS_FATAL_ALERT_QUEUED;	// verify error    
      return(Retcode);
    }    
    FragmentSize = pTmpLen[0] - (FragmentOffset - RECORD_HDR_SIZE);
    pConnStruc->RxFragmentSize = FragmentSize;
    pConnStruc->RxFragmentOffset  = FragmentOffset;
  }
  //--------------------------------------------------------------
  // Decompress the received, decrypted, verified fragment
  // Send Alert if decompression fails
  //--------------------------------------------------------------
  FragmentSize   = pConnStruc->RxFragmentSize;	// get size (REENTRY!)
  FragmentOffset = pConnStruc->RxFragmentOffset;	// start of netto data

  if(pConnStruc->ActRX_ComprAlgor != COMPR_NULL)
  {
    pTmpLen[0] = FragmentSize;				// set source size    
    Retcode = DecompressRecord(pConnStruc,pBuf,FragmentOffset,pTmpBuf,pTmpLen);
    if(Retcode != HSSL_OP_OK)
    {
      FREE_ARRAY_POOL(HMEM_CTX_REF,pBuf);		// free
      pConnStruc->pRxFragmentBuffer = NULL;
      SendAlert(pConnStruc,AD_DECOMPRESS_FAILURE,ALERT_LEVEL_FATAL);
      pContStat[0] = STATUS_FATAL_ALERT_QUEUED; // decompress error
      return(Retcode);
    }    
    if(pTmpBuf[0] == NULL)			// no system buffers !
    {
      pConnStruc->RX_State = TCP_RX_DSTBUF_WAIT; // set next state
      return(HSSL_OP_OK);
    }
    pConnStruc->RX_State = TCP_RX_HDR_WAIT; // set next state (!)
    FragmentSize = pTmpLen[0];			// get data length
    FREE_ARRAY_POOL(HMEM_CTX_REF,pBuf);		// free other buffer
    pBuf = pTmpBuf[0];
    pConnStruc->pRxFragmentBuffer = pBuf;
    FragmentOffset = 0;				// no header !!
  }
  // Check for maximum record length
  if( SSL_PLAIN_RECORD_MAX_LEN < FragmentSize ){
     // Error code depending on Protocol version 
     if(ProtVersionLow == SSL_MINOR_VERSION){
        SendAlert(pConnStruc,AD_DECOMPRESS_FAILURE,ALERT_LEVEL_FATAL);
     }else{
        SendAlert(pConnStruc,AD_RECORD_OVERFLOW,ALERT_LEVEL_FATAL);
     }
     pContStat[0] = STATUS_FATAL_ALERT_QUEUED;
     return(HSSL_RX_ILLEGAL_PARAM);
  }
  //--------------------------------------------------------------
  // Distribute the plain fragment to the assembly / test routines
  //--------------------------------------------------------------

  Retcode = HSSL_OP_OK;		// for Compiler (warning)
  switch(RecordType)
  {
    case CT_CHANGE_CIPHER_SPEC:
      Retcode = ProcessRX_ChangeCipherSpec(pConnStruc,pBuf,FragmentOffset,
					   FragmentSize,pContStat);
      break;

    case CT_ALERT:
      Retcode = ProcessRX_Alert(pConnStruc,pBuf,FragmentOffset,
				FragmentSize,pContStat);
      break;

    case CT_HANDSHAKE:
      Retcode = AssembleProcessRX_Handshake(pConnStruc,pBuf,FragmentOffset,
					    FragmentSize,pContStat);
      break;

    case CT_APPLICATION_DATA:
      Retcode = ProcessRX_ApplData(pConnStruc,pBuf,FragmentOffset,
				   FragmentSize,pContStat);
      pBuf = NULL;			// prevent freeing the buffer !!
      break;

    default:				// can not happen !!
      break;
  } // switch
  FREE_ARRAY_POOL(HMEM_CTX_REF,pBuf);
  pConnStruc->pRxFragmentBuffer = NULL;
  return(Retcode);
}

#if XH_INTF_VERSION < 300
/**
* Takes SSL/TLS packages from the receive buffer and processes them (HSSL_XH2Tcp_Receive). 
* Server side.
*
* @see m_xh_tcp_receive_main
*
*  @param pXif2Struc Interface structure
*  @param pContStat Continuation state
*
*  @return HSSL_OP_OK on success, error code otherwise
*/
extern "C" int  HSSL_XH2Tcp_Receive(struct dsd_hl_ssl_s_2 * pXif2Struc,
				    int* pContStat)
{
  int DataLen;
  //--------------------------------------------------
  // Check Input Parameters
  //--------------------------------------------------
  if((pXif2Struc == NULL) || (pContStat == NULL) ||
     (pXif2Struc->ac_ext == NULL) ||
     ((((XHCONNSTRUC *) pXif2Struc->ac_ext)->pConnStruc) == NULL))
    return(HSSL_NULL_PTR);

  DataLen = (int) (pXif2Struc->achc_inp_end - pXif2Struc->achc_inp_cur);
  return m_xh_tcp_receive_main(((XHCONNSTRUC *) pXif2Struc->ac_ext)->pConnStruc,
    DataLen, pContStat,TRUE,pXif2Struc);
}
#endif // XH_INTF_VERSION < 300

#if XH_INTF_VERSION >= 300
/**
* Takes SSL/TLS packages from the receive buffer and processes them (HSSL_XH3Tcp_Receive). 
* Server side.
*
* @see m_xh_tcp_receive_main
*
*  @param pXif3Struc Interface structure
*  @param DataLen Amount of data present
*  @param pContStat Continuation state
*
*  @return HSSL_OP_OK on success, error code otherwise
*/
extern "C" int  HSSL_XH3Tcp_Receive(struct dsd_hl_ssl_s_3 * pXif3Struc,
				    int DataLen,
				    int* pContStat)
{
  //--------------------------------------------------
  // Check Input Parameters
  //--------------------------------------------------
  if((pXif3Struc == NULL) || (pContStat == NULL) ||
     (pXif3Struc->ac_ext == NULL) ||
     ((((XHCONNSTRUC *) pXif3Struc->ac_ext)->pConnStruc) == NULL))
    return(HSSL_NULL_PTR);
  return m_xh_tcp_receive_main(((XHCONNSTRUC *) pXif3Struc->ac_ext)->pConnStruc,
                               DataLen, pContStat,TRUE,pXif3Struc);
}
#endif // XH_INTF_VERSION >= 300

/**
* Takes SSL/TLS packages from the receive buffer and processes them. 
* Client side.
*
* @see m_xh_tcp_receive_main

*  @param pXifClStruc Interface Structure
*  @param DataLen Length of data to process
*  @param pContStat Continuation state
*
*  @return HSSL_OP_OK on success, error code otherwise
*/
//HSSL_XHCLTcp_Receive
extern "C" int  HSSL_XHCLTcp_Receive(struct dsd_hl_ssl_c_1 * pXifClStruc,
				     int DataLen,
				     int* pContStat)
{
  //--------------------------------------------------
  // Check Input Parameters
  //--------------------------------------------------
  if((pXifClStruc == NULL) || (pContStat == NULL) ||
     (pXifClStruc->vpc_ext == NULL) ||
     ((((XHCONNSTRUC *) pXifClStruc->vpc_ext)->pConnStruc) == NULL))
    return(HSSL_NULL_PTR);

  return m_xh_tcp_receive_main(
    ((XHCONNSTRUC *) pXifClStruc->vpc_ext)->pConnStruc,
    DataLen, pContStat,FALSE,pXifClStruc);
}
#endif // XH_INTERFACE

//***********************************************************************
//*									*
//* Interface service routines						*
//*									*
//***********************************************************************

#if !defined XH_INTERFACE		// not used for alternate
/**
* Puts a connection structure
* for the specified index into the desired slot if empty
* and increments the lock flag for the structure (NewSlotAndLock).
*
* synchronization changed for JAVA / CSHARP
*
*  @param SocketIndex Index to socket array, rel. 1
*  @param pConnStruc Structure to set
*  @return HSSL_OP_OK, o.k.
* <br>            else error occured
*/
static int NewSlotAndLock(int SocketIndex, CONNSTRU * pConnStruc)
{

  GetConnStrucLock();				// acquire the global lock
  
  
  //-----------------------------------------------------
  // check if slot is empty
  //-----------------------------------------------------
//  DBG_PRINT("\nNew Slot: ");
//  DBG_PRINT_INT(SocketIndex);
  SocketIndex--;
  if(pConnPtrArray[SocketIndex] != NULL)
  {
    ReleaseConnStrucLock();			// release the lock
    return(HSSL_NEWCONN_SLOT_ALRDY_USED);
  }
  //--------------------------------------------------------
  // Slot is empty, insert structure and increment lock flag
  //--------------------------------------------------------
  pConnPtrArray[SocketIndex] = pConnStruc; // insert structure
  ActConnectionCount++;			// increment number
  if(SocketIndex > MaxConnectionIndex)
    MaxConnectionIndex = SocketIndex;
  pConnStruc->LockFlag ++;			// increment lock

  ReleaseConnStrucLock();			// release the lock
  return(HSSL_OP_OK);

}
#endif // !defined XH_INTERFACE

#if !defined XH_INTERFACE		// alternate routine
/**
* Sets up a new connection,
* either from client or to server (InitializeNewConnection).
*
*  @param SocketID Index to socket array, rel. 1
*  @param ServerIpAdr IP-Address of server, 4 bytes
*  @param ServerPort Port of server 
*  @param ClientIpAdr IP-Address of client, 4 bytes
*  @param Entity SERVER_ENTITY/CLIENT_ENTITY
*
*  @return HSSL_OP_OK on success, error code otherwise
*/
static int InitializeNewConnection(int SocketID, char* ServerIpAdr,
			 int ServerPort, char* ClientIpAdr, int Entity)
{
  char ProtFlags;
  int SocketIndex;
  int IpAdrLen = 4;
  int Retcode;

  char* pDst;

  CONNSTRU * pConnStruc;
  //------------------------------------------------
  // Check Parameters
  //------------------------------------------------
  if((ServerIpAdr == NULL) || (ClientIpAdr == NULL))
    return(HSSL_NULL_PTR);
  if((SocketID < 1) ||
     (SocketID > pGlobalCfgStruct->MaxConnCount))
  {
    return(HSSL_NEWCONN_INVAL_SOCKINDEX);
  }
  //------------------------------------------------
  // allocate/init a connection structure
  //------------------------------------------------
  pConnStruc = AllocInitNewConnStateStruct();
  if(pConnStruc == NULL)
  {
    return(HSSL_NEWCONN_STRUC_ALLOC_ERR);
  }
  //------------------------------------------------
  // put the parameters to the Structure
  //------------------------------------------------
  SocketIndex = SocketID - 1;			// set relativ zero
  pConnStruc->SocketIndex = SocketID;	// save, rel. 1
  pConnStruc->ServerPort  = (short) ServerPort;
  pDst = pConnStruc->ServerIPAdr;
  pDst[0] = (char) IpAdrLen;
  memcpy(pDst+1,ServerIpAdr+0,IpAdrLen);

  pDst = pConnStruc->ClientIPAdr;
  pDst[0] = (char) IpAdrLen;
  memcpy(pDst+1,ClientIpAdr+0,IpAdrLen);
  //---------------------------------------------------------
  // get the configuration parameters to use
  // Up to now the configuration is loaded only once
  // ----- during new process startup, a Copy is made from
  //       the global pointers / values, so the
  //	   pointers must not be freed !!!
  //---------------------------------------------------------
  if(Entity != pGlobalCfgStruct->Entity)	// wrong site called !!
  {
//  DBG_PRINT("\nB");
    FreeConnStateStruct(pConnStruc);
    return(HSSL_NEWCONN_INV_CONN_ENTITY);
  }
  pConnStruc->pCfgStruc	= pGlobalCfgStruct; // set configuration...

  pConnStruc->Entity	= (char) Entity;

  //-------------------------------------------------------------
  // Setup protocol flags, authentication flags, check cipherlist
  //-------------------------------------------------------------
  // we use 2 different flags for protocols and authentication now !!

  ProtFlags =
     (char) (pGlobalCfgStruct->ProtFlags & CFG_PROTOCOLS_MASK);

  if((pGlobalCfgStruct->ExtConfigFlags & CFG_TLS_V1_BIT_MASK) != 0)
    ProtFlags = (char) (ProtFlags | TLS_V1_BIT_MASK);

  if((pGlobalCfgStruct->ExtConfigFlags & CFG_TLS_V2_BIT_MASK) != 0)
    ProtFlags |= TLS_V2_BIT_MASK;

  if((ProtFlags & (TLS_V1_BIT_MASK | TLS_V2_BIT_MASK)) != 0)
  {// TLS 1.1 or 1.2 possible
    Retcode = CheckAllCipherSuitesExportable(
			pGlobalCfgStruct->CipherSuitesList,0);
    if((Retcode < 0) ||				// should not happen!
       (((ProtFlags & (TLS_BIT_MASK | SSL_BIT_MASK)) == 0) &&
        (Retcode > 0)))				// only exportables!
    {
      FreeConnStateStruct(pConnStruc);
      return(HSSL_CFG_TLS11_ONLY_EXPORT_CIPH_SUITES);
    }
    if(Retcode > 0)				// only exp., but also TLS10/SSL
      ProtFlags = (char) (ProtFlags & (~(TLS_V1_BIT_MASK | TLS_V2_BIT_MASK)));
  }
  pConnStruc->SupportedProtocolsFlags	= ProtFlags;

  pConnStruc->AuthFlags	= (char)
    (pGlobalCfgStruct->ProtFlags & (~CFG_PROTOCOLS_MASK));

  pConnStruc->ExtendedConfigFlags	= pGlobalCfgStruct->ExtConfigFlags;
  pConnStruc->ExtendedConf2Flags= pGlobalCfgStruct->ExtConf2Flags;

  pConnStruc->RenegotiateTime =
               (int) pGlobalCfgStruct->RenegotiateTime * 60;

  //---------------------------------------------------------
  // Initialize OCSP
  //---------------------------------------------------------
  if((Retcode = AllocInitOcspParamStruct(pConnStruc)) != HSSL_OP_OK)
  {
    FreeConnStateStruct(pConnStruc);
    return(Retcode);
  }

  //--------------------------------------------------------------
  // Initialize SSL-V2 Header interpretation if server and enabled
  //--------------------------------------------------------------
  if(pConnStruc->Entity == SERVER_ENTITY)	
  {
    if((pConnStruc->ExtendedConf2Flags & SRVR_SSLV2_ACCEPT_BIT_MASK) != 0)    
      pConnStruc->RxHeaderSSLV2CheckEnable = 1;	// enable SSL-V2 checking
  }

  //---------------------------------------------------------
  // Initialize the Ciphers/Macs etc.
  //---------------------------------------------------------
  InitConnCipherStates(pConnStruc);
  //---------------------------------------------------------
  // Check if we have already a session between the parties
  // that can be used by session duplication
  //---------------------------------------------------------
  // !!!!!! must implement that later !!!!!

  //----------------------------------------------------
  // Start the Handshake Phase for the client/server:
  // Queue the  appropriate Transmit messages
  //----------------------------------------------------
  if(pConnStruc->Entity == CLIENT_ENTITY){
      m_set_expected_message(pConnStruc, HT_SERVER_HELLO);
      Retcode = GenerateClientHello(pConnStruc);	// Start the Handshake
  } else {
      m_set_expected_message(pConnStruc, HT_CLIENT_HELLO);
      Retcode = HSSL_OP_OK;
      if((pConnStruc->ExtendedConf2Flags & SRVR_NO_HELLO_REQ_BIT_MASK) == 0)
          Retcode = GenerateServerHelloReq(pConnStruc); // Start the Handshake
  }

  if(Retcode != HSSL_OP_OK)
  {
//  DBG_PRINT("\nC");
    FreeConnStateStruct(pConnStruc);
    return(HSSL_NEWCONN_GEN_STARTMSG_ERR);
  }
  pConnStruc->ConnectionState = CONN_STATE_HANDSHAKE_PHASE;
  //------------------------------------------------
  // get the connection lock and update global array
  //------------------------------------------------
  Retcode =  NewSlotAndLock(SocketID,pConnStruc);
  if(Retcode != HSSL_OP_OK)
  {
//  DBG_PRINT("\nD");
    FreeConnStateStruct(pConnStruc);
  }
  return(Retcode);
}
#endif // !defined XH_INTERFACE

#if defined XH_INTERFACE
#if XH_INTF_VERSION < 300
/**
* Subroutine XH2InitializeNewConnection sets up a new connection,
* either from client or to server (XH2InitializeNewConnection).
*
*  @param Entity SERVER_ENTITY/CLIENT_ENTITY
*  @param pCfgStruc Config to use
*  @param pXif2Struc Interface2 structure *
*  @param ppConnStruc returned Connection structure
*
*  @return HSSL_OP_OK on success, error code otherwise
*/
static  int XH2InitializeNewConnection(HMEM_CTX_DEF
		int Entity, CFG_STRU * pCfgStruc,
		struct dsd_hl_ssl_s_2 * pXif2Struc,   //NULL
		CONNSTRU ** ppConnStruc)
{
  char ProtFlags;
  int Retcode;

  CONNSTRU * pConnStruc;
  XH_OCSP_STRUC * pXhOcspStruc;

  //------------------------------------------------
  // Check Parameters
  //------------------------------------------------
  if((ppConnStruc == NULL) || (pCfgStruc == NULL))
    return(HSSL_NULL_PTR);
  ppConnStruc[0] = NULL;		// invalidate
  //------------------------------------------------
  // allocate/init a connection structure
  //------------------------------------------------
  pConnStruc = AllocInitNewConnStateStruct(HMEM_CTX_REF);
  if(pConnStruc == NULL)
  {
    return(HSSL_NEWCONN_STRUC_ALLOC_ERR);
  }
  //----------------------------------------------------------------
  // Prepare use of OCSP
  // For Interface Version 1 own emulation functions are used
  //----------------------------------------------------------------

    //------------------------------------------------------------
    // Version 2, load structure from interface struct
    //------------------------------------------------------------
    pXhOcspStruc = CONN_pOcspCtx(pConnStruc);	// get pointer (easier access)

#if defined _AIX
#pragma info(none)
#endif
    pXhOcspStruc->amc_ocsp_start =
      (int (*)(void *, struct dsd_hl_ocsp_d_1 *))
       pXif2Struc->amc_ocsp_start;

    pXhOcspStruc->amc_ocsp_recv  =
      (struct dsd_hl_ocsp_rec *(*)(void *))
       pXif2Struc->amc_ocsp_recv;

#if defined _AIX
#pragma info(restore)
#endif
 
    pXhOcspStruc->amc_ocsp_send  = pXif2Struc->amc_ocsp_send;

    pXhOcspStruc->amc_ocsp_stop  = pXif2Struc->amc_ocsp_stop;
    pXhOcspStruc->pOcspCtxStruc  = pXif2Struc->vpc_userfld;

  //---------------------------------------------------------
  // get the configuration parameters to use
  //---------------------------------------------------------
  if(Entity != pCfgStruc->Entity)	// wrong site called !!
  {
//  DBG_PRINT("\nB");
    FreeConnStateStruct(pConnStruc);
    return(HSSL_NEWCONN_INV_CONN_ENTITY);
  }

  pConnStruc->Entity	= (char) Entity;

  //-------------------------------------------------------------
  // Setup protocol flags, authentication flags, check cipherlist
  //-------------------------------------------------------------
  // we use 2 different flags for protocols and authentication now !!

  ProtFlags = pCfgStruc->ProtFlags & CFG_PROTOCOLS_MASK;

  if((pCfgStruc->ExtConfigFlags & CFG_TLS_V1_BIT_MASK) != 0)
    ProtFlags |= TLS_V1_BIT_MASK;

  if((pCfgStruc->ExtConfigFlags & CFG_TLS_V2_BIT_MASK) != 0)
    ProtFlags |= TLS_V2_BIT_MASK;

  if((ProtFlags & (TLS_V1_BIT_MASK | TLS_V2_BIT_MASK)) != 0)
  {// TLS 1.1 or 1.2 possible
    Retcode = CheckAllCipherSuitesExportable(
			pCfgStruc->CipherSuitesList,0);
    if((Retcode < 0) ||				// should not happen!
       (((ProtFlags & (TLS_BIT_MASK | SSL_BIT_MASK)) == 0) &&
        (Retcode > 0)))				// only exportables!
    {
      FreeConnStateStruct(pConnStruc);
      return(HSSL_CFG_TLS11_ONLY_EXPORT_CIPH_SUITES);
    }
    if(Retcode > 0)				// only exp., but also TLS10/SSL
      ProtFlags = (char) (ProtFlags & (~(TLS_V1_BIT_MASK | TLS_V2_BIT_MASK)));
  }
  pConnStruc->SupportedProtocolsFlags	= ProtFlags;

  pConnStruc->AuthFlags	= pCfgStruc->ProtFlags &
					(~CFG_PROTOCOLS_MASK);

  pConnStruc->ExtendedConfigFlags	= pCfgStruc->ExtConfigFlags;
  pConnStruc->ExtendedConf2Flags= pCfgStruc->ExtConf2Flags;

  pConnStruc->RenegotiateTime =
         (int) pCfgStruc->RenegotiateTime * 60;

  pConnStruc->pCfgStruc = pCfgStruc;
  //---------------------------------------------------------
  // Initialize OCSP
  //---------------------------------------------------------
  if((Retcode = AllocInitOcspParamStruct(pConnStruc)) != HSSL_OP_OK)
  {
    FreeConnStateStruct(pConnStruc);
    return(Retcode);
  }
  //--------------------------------------------------------------
  // Initialize SSL-V2 Header interpretation (this is a server !)
  //--------------------------------------------------------------
  if((pConnStruc->ExtendedConf2Flags & SRVR_SSLV2_ACCEPT_BIT_MASK) != 0)    
    pConnStruc->RxHeaderSSLV2CheckEnable = 1;	// enable SSL-V2 checking
 
  //---------------------------------------------------------
  // Initialize the Ciphers/Macs etc.
  //---------------------------------------------------------
  InitConnCipherStates(pConnStruc);
  //---------------------------------------------------------
  // Check if we have already a session between the parties
  // that can be used by session duplication
  //---------------------------------------------------------
  // !!!!!! must implement that later !!!!!

  //----------------------------------------------------
  // Start the Handshake Phase for the client/server:
  // Queue the  appropriate Transmit messages
  //----------------------------------------------------
  if(pConnStruc->Entity == CLIENT_ENTITY){
      m_set_expected_message(pConnStruc, HT_SERVER_HELLO);
      Retcode = GenerateClientHello(pConnStruc);	// Start the Handshake
  } else {
      m_set_expected_message(pConnStruc, HT_CLIENT_HELLO);
      Retcode = HSSL_OP_OK;
      if((pConnStruc->ExtendedConf2Flags & SRVR_NO_HELLO_REQ_BIT_MASK) == 0)
          Retcode = GenerateServerHelloReq(pConnStruc); // Start the Handshake
  }
  if(Retcode != HSSL_OP_OK)
  {
//  DBG_PRINT("\nC");
    FreeConnStateStruct(pConnStruc);
    return(HSSL_NEWCONN_GEN_STARTMSG_ERR);
  }
  pConnStruc->ConnectionState = CONN_STATE_HANDSHAKE_PHASE;
  ppConnStruc[0] = pConnStruc;			// report to caller
  return(Retcode);
}
#endif // XH_INTF_VERSION < 300

#if XH_INTF_VERSION >= 300
/**
* Sets up a new connection,
* either from client or to server (XH3InitializeNewConnection).
*
*  @param Entity SERVER_ENTITY/CLIENT_ENTITY
*  @param pCfgStruc Config to use
*  @param pXif3Struc Interface3 structure * 
*  @param ppConnStruc returned Connection structure
*
*  @return HSSL_OP_OK on success, error code otherwise
*/
static  int XH3InitializeNewConnection(HMEM_CTX_DEF
		int Entity, CFG_STRU * pCfgStruc,
		struct dsd_hl_ssl_s_3 * pXif3Struc, //NULL
		CONNSTRU ** ppConnStruc)
{
  char ProtFlags;
  int Retcode;

  CONNSTRU * pConnStruc;
  XH_OCSP_STRUC * pXhOcspStruc;

  //------------------------------------------------
  // Check Parameters
  //------------------------------------------------
  if((ppConnStruc == NULL) || (pCfgStruc == NULL))
    return(HSSL_NULL_PTR);
  ppConnStruc[0] = NULL;		// invalidate
  //------------------------------------------------
  // allocate/init a connection structure
  //------------------------------------------------
  pConnStruc = AllocInitNewConnStateStruct(HMEM_CTX_REF);
  if(pConnStruc == NULL)
  {
    return(HSSL_NEWCONN_STRUC_ALLOC_ERR);
  }
  //----------------------------------------------------------------
  // Prepare use of OCSP
  // For Interface Version 1 own emulation functions are used
  //----------------------------------------------------------------

    //------------------------------------------------------------
    // Version 2, load structure from interface struct
    //------------------------------------------------------------
    pXhOcspStruc = CONN_pOcspCtx(pConnStruc);	// get pointer (easier access)

#if defined _AIX
#pragma info(none)
#endif
    pXhOcspStruc->amc_ocsp_start =
      (int (*)(void *, struct dsd_hl_ocsp_d_1 *))
       pXif3Struc->amc_ocsp_start;

    pXhOcspStruc->amc_ocsp_recv  =
      (struct dsd_hl_ocsp_rec *(*)(void *))
       pXif3Struc->amc_ocsp_recv;

#if defined _AIX
#pragma info(restore)
#endif
 
    pXhOcspStruc->amc_ocsp_send  = pXif3Struc->amc_ocsp_send;

    pXhOcspStruc->amc_ocsp_stop  = pXif3Struc->amc_ocsp_stop;
    pXhOcspStruc->pOcspCtxStruc  = pXif3Struc->vpc_userfld;

    Retcode = m_set_configuration(pConnStruc, pCfgStruc, Entity);

    if(Retcode != HSSL_OP_OK){
        FreeConnStateStruct(pConnStruc);
        return Retcode;
    }

  //---------------------------------------------------------
  // Initialize the Ciphers/Macs etc.
  //---------------------------------------------------------
  InitConnCipherStates(pConnStruc);
  //---------------------------------------------------------
  // Check if we have already a session between the parties
  // that can be used by session duplication
  //---------------------------------------------------------
  // !!!!!! must implement that later !!!!!
  //---------------------------------------------------------
  // Initialize logger
  //---------------------------------------------------------
  pConnStruc->adsc_logger = m_gen_wsp_tracer(HMEM_CTX_REF1 pXif3Struc->imc_trace_level,
     FALSE, pXif3Struc->imc_sno, pXif3Struc->amc_aux, pXif3Struc->vpc_userfld);

  //----------------------------------------------------
  // Start the Handshake Phase for the client/server:
  // Queue the  appropriate Transmit messages
  //----------------------------------------------------
  if(pConnStruc->Entity == CLIENT_ENTITY){
      m_set_expected_message(pConnStruc, HT_SERVER_HELLO);
      Retcode = GenerateClientHello(pConnStruc);	// Start the Handshake
  } else {
      m_set_expected_message(pConnStruc, HT_CLIENT_HELLO);
      Retcode = HSSL_OP_OK;
      if((pConnStruc->ExtendedConf2Flags & SRVR_NO_HELLO_REQ_BIT_MASK) == 0)
          Retcode = GenerateServerHelloReq(pConnStruc); // Start the Handshake
  }
  if(Retcode != HSSL_OP_OK)
  {
//  DBG_PRINT("\nC");
    FreeConnStateStruct(pConnStruc);
    return(HSSL_NEWCONN_GEN_STARTMSG_ERR);
  }
  pConnStruc->ConnectionState = CONN_STATE_HANDSHAKE_PHASE;
  ppConnStruc[0] = pConnStruc;			// report to caller
  return(Retcode);
}
#endif // XH_INTF_VERSION >= 300

/**
* Sets up a new connection,
* either from client or to server (XHCLInitializeNewConnection).
*
*  @param Entity SERVER_ENTITY/CLIENT_ENTITY
*  @param pCfgStruc Config to use
*  @param pXifClStruc Interface Cl structure *
*  @param ppConnStruc returned Connection structure
*
*  @return HSSL_OP_OK on success, error code otherwise
*/
static  int XHCLInitializeNewConnection(HMEM_CTX_DEF
		int Entity, CFG_STRU * pCfgStruc,
		struct dsd_hl_ssl_c_1 * pXifClStruc,  //NULL
		CONNSTRU ** ppConnStruc)
{
  char ProtFlags;
  int Retcode;

  CONNSTRU * pConnStruc;
  XH_OCSP_STRUC * pXhOcspStruc;

  //------------------------------------------------
  // Check Parameters
  //------------------------------------------------
  if((ppConnStruc == NULL) || (pCfgStruc == NULL))
    return(HSSL_NULL_PTR);
  ppConnStruc[0] = NULL;		// invalidate
  //------------------------------------------------
  // allocate/init a connection structure
  //------------------------------------------------
  pConnStruc = AllocInitNewConnStateStruct(HMEM_CTX_REF);
  if(pConnStruc == NULL)
  {
    return(HSSL_NEWCONN_STRUC_ALLOC_ERR);
  }
  //----------------------------------------------------------------
  // Prepare use of OCSP
  // Client, load structure from interface struct
  //------------------------------------------------------------
  pXhOcspStruc = CONN_pOcspCtx(pConnStruc);	// get pointer (easier access)

#if defined _AIX
#pragma info(none)
#endif
  pXhOcspStruc->amc_ocsp_start =
      (int (*)(void *, struct dsd_hl_ocsp_d_1 *))
       pXifClStruc->amc_ocsp_start;

  pXhOcspStruc->amc_ocsp_recv  =
      (struct dsd_hl_ocsp_rec *(*)(void *))
       pXifClStruc->amc_ocsp_recv;

#if defined _AIX
#pragma info(restore)
#endif
 
  pXhOcspStruc->amc_ocsp_send  = pXifClStruc->amc_ocsp_send;

  pXhOcspStruc->amc_ocsp_stop  = pXifClStruc->amc_ocsp_stop;
  pXhOcspStruc->pOcspCtxStruc  = pXifClStruc->vpc_userfld;

  //---------------------------------------------------------
  // get the configuration parameters to use
  //---------------------------------------------------------
  if(Entity != pCfgStruc->Entity)	// wrong site called !!
  {
//  DBG_PRINT("\nB");
    FreeConnStateStruct(pConnStruc);
    return(HSSL_NEWCONN_INV_CONN_ENTITY);
  }

  pConnStruc->Entity	= (char) Entity;

  //-------------------------------------------------------------
  // Setup protocol flags, authentication flags, check cipherlist
  //-------------------------------------------------------------
  // we use 2 different flags for protocols and authentication now !!

  ProtFlags = pCfgStruc->ProtFlags & CFG_PROTOCOLS_MASK;

  if((pCfgStruc->ExtConfigFlags & CFG_TLS_V1_BIT_MASK) != 0)
    ProtFlags |= TLS_V1_BIT_MASK;

  if((pCfgStruc->ExtConfigFlags & CFG_TLS_V2_BIT_MASK) != 0)
    ProtFlags |= TLS_V2_BIT_MASK;

  if((ProtFlags & (TLS_V1_BIT_MASK | TLS_V2_BIT_MASK)) != 0)
  {// TLS 1.1 or 1.2 possible
    Retcode = CheckAllCipherSuitesExportable(
			pCfgStruc->CipherSuitesList,0);
    if((Retcode < 0) ||				// should not happen!
       (((ProtFlags & (TLS_BIT_MASK | SSL_BIT_MASK)) == 0) &&
        (Retcode > 0)))				// only exportables!
    {
      FreeConnStateStruct(pConnStruc);
      return(HSSL_CFG_TLS11_ONLY_EXPORT_CIPH_SUITES);
    }
    if(Retcode > 0)				// only exp., but also TLS10/SSL
      ProtFlags = (char) (ProtFlags & (~(TLS_V1_BIT_MASK | TLS_V2_BIT_MASK)));
  }
  pConnStruc->SupportedProtocolsFlags	= ProtFlags;

  pConnStruc->AuthFlags	= pCfgStruc->ProtFlags &
					(~CFG_PROTOCOLS_MASK);

  pConnStruc->ExtendedConfigFlags	= pCfgStruc->ExtConfigFlags;
  pConnStruc->ExtendedConf2Flags= pCfgStruc->ExtConf2Flags;

  pConnStruc->RenegotiateTime =
       (int) pCfgStruc->RenegotiateTime * 60;

  pConnStruc->pCfgStruc = pCfgStruc;

  //---------------------------------------------------------
  // Load PKCS11 Library now (if given)
  //---------------------------------------------------------
// HERE: PKCS11 init should be done!!

#if (defined _WIN32) && defined PKCS11
  Retcode = m_pkcs11certinit(pConnStruc);
  if(Retcode != HSSL_OP_OK)
  {
    FreeConnStateStruct(pConnStruc);
    return(Retcode);
  }
#endif // defined _WIN32

  //---------------------------------------------------------
  // Initialize OCSP
  //---------------------------------------------------------
  if((Retcode = AllocInitOcspParamStruct(pConnStruc)) != HSSL_OP_OK)
  {
    FreeConnStateStruct(pConnStruc);
    return(Retcode);
  }
  //---------------------------------------------------------
  // Initialize the Ciphers/Macs etc.
  //---------------------------------------------------------
  InitConnCipherStates(pConnStruc);
  //---------------------------------------------------------
  // Check if we have already a session between the parties
  // that can be used by session duplication
  //---------------------------------------------------------
  // !!!!!! must implement that later !!!!!
  //---------------------------------------------------------
  // Initialize logger
  //---------------------------------------------------------
  pConnStruc->adsc_logger = m_gen_wsp_tracer(HMEM_CTX_REF1 pXifClStruc->imc_trace_level,
     TRUE, pXifClStruc->imc_sno,pXifClStruc->amc_aux, pXifClStruc->vpc_userfld);
  
  // Check, if the no compression flag is set
  if( pXifClStruc->dsc_cs_ssl_options.ibc_cs_ssl_no_compression ){
     pConnStruc->ActualComprMethod = COMPR_NULL;
  }
  
  pConnStruc->adsc_alpn_cfg = pXifClStruc->adsc_alpn_cfg;

  Retcode = m_load_server_host_name(pConnStruc, &pXifClStruc->dsc_ucs_target_host);
  if (Retcode != HSSL_OP_OK){
      FreeConnStateStruct(pConnStruc);
      return Retcode;
  }

  //----------------------------------------------------
  // Start the Handshake Phase for the client/server:
  // Queue the  appropriate Transmit messages
  //----------------------------------------------------
  if(pConnStruc->Entity == CLIENT_ENTITY){
      m_set_expected_message(pConnStruc, HT_SERVER_HELLO);
      Retcode = GenerateClientHello(pConnStruc);	// Start the Handshake
  } else {
      m_set_expected_message(pConnStruc, HT_CLIENT_HELLO);
      Retcode = HSSL_OP_OK;
      if((pConnStruc->ExtendedConf2Flags & SRVR_NO_HELLO_REQ_BIT_MASK) == 0)
          Retcode = GenerateServerHelloReq(pConnStruc); // Start the Handshake
  }
  if(Retcode != HSSL_OP_OK)
  {
//  DBG_PRINT("\nC");
    FreeConnStateStruct(pConnStruc);
    return(HSSL_NEWCONN_GEN_STARTMSG_ERR);
  }

  pConnStruc->ConnectionState = CONN_STATE_HANDSHAKE_PHASE;
  ppConnStruc[0] = pConnStruc;			// report to caller
  return(Retcode);
}
#endif // XH_INTERFACE

#if !defined XH_INTERFACE	// alternate

/**
* Tries to send all still
* remaining data on the send queues (SendQueuedTxData).
*
*  @param pConnStruc Connection structure
*  @param pContStat Continue state
*  @param pShutdownReason Reason for shutdown
*  @return HSSL_OP_OK on success else error
*/
static int  SendQueuedTxData(CONNSTRU * pConnStruc,
			int* pContStat, int* pShutdownReason)
{
  int Retcode;
  int RetryCount = 10;
  //-------------------------------------------
  // Set TX-Data Timeout
  //-------------------------------------------
  Retcode = HLSSL_CallBack(TCP_TIMEOUT_FUNCTION,pConnStruc->SocketIndex,NULL,TCP_TX_TIMEOUT_SET,TCP_OPERATION_TIMEOUT);
  if(Retcode != 0)
    return(HSSL_TX_TCP_TIMEOUT);
  //-------------------------------------------
  // Send Data from TX buffer until empty/Error
  //-------------------------------------------
  for(;;)
  {
    Retcode = HSSL_Tcp_Transmit(pConnStruc,pContStat, pShutdownReason);
    if((Retcode != HSSL_OP_OK) ||			// error occured
       ((pConnStruc->pPriorityTxQueueHead == NULL) &&	// no more data to send
        (pConnStruc->pApplicationTxQueueHead == NULL)))
    if(Retcode == -2)					// timeout
    {
      RetryCount--;
      if(RetryCount != 0)
        continue;
      Retcode = HSSL_TX_TCP_TIMEOUT;
    }
    return(Retcode);
  }
}
#endif // !XH_INTERFACE

#if !defined XH_INTERFACE // alternate for others
/**
* Performs handshake phase for connection
* setup (DoHandshake). 
* The start message is already queued to the priority
* send queue and must be sent first.
* 
*  @param pConnStruc Connection structure
*
*  @return HSSL_OP_OK on success, error code otherwise
*/
static int DoHandshake(CONNSTRU * pConnStruc)
{
  int Retcode;
  int RetryTime;
  int ActTxTimeout = 0;
  int ActRxTimeout = 0;

  char pTmpBuf[4] = {0,0,0,0};	// Array for timeouts get
  int pTmpContStat[1];
  int pTmpReason[1];

  CFG_STRU * pCfgStruc;

  //-------------------------------------------------
  // Send Start Message to Remote site, obey timeouts
  //-------------------------------------------------
  pCfgStruc = pConnStruc->pCfgStruc;
  RetryTime = pCfgStruc->ConnectTimeout;
  for(;;)
  {
    //-------------------------------------------------
    // Get current timeouts for TCP-Operations
    //-------------------------------------------------
    if(HLSSL_CallBack(TCP_TIMEOUT_FUNCTION,pConnStruc->SocketIndex,pTmpBuf,TCP_TX_TIMEOUT_GET,0) != 0)
    {
      Retcode = HSSL_HSHAKE_GET_TX_TIMEOUT_ERR;
      break;
    }
    char2longn(pTmpBuf,ActTxTimeout,0);		// save value

    if(HLSSL_CallBack(TCP_TIMEOUT_FUNCTION,pConnStruc->SocketIndex,pTmpBuf,TCP_RX_TIMEOUT_GET,0) != 0)
    {
      Retcode = HSSL_HSHAKE_GET_RX_TIMEOUT_ERR;
      break;
    }
    char2longn(pTmpBuf,ActRxTimeout,0);		// save value
    //-------------------------------------------------
    // Set timeouts for TCP-Operations
    //-------------------------------------------------
    Retcode = HLSSL_CallBack(TCP_TIMEOUT_FUNCTION,pConnStruc->SocketIndex,NULL,TCP_TX_TIMEOUT_SET,TCP_OPERATION_TIMEOUT);
    if(Retcode != 0)
    {
      Retcode = HSSL_HSHAKE_SET_TX_TIMEOUT_ERR;
      break;
    }
    Retcode = HLSSL_CallBack(TCP_TIMEOUT_FUNCTION,pConnStruc->SocketIndex,NULL,TCP_RX_TIMEOUT_SET,TCP_OPERATION_TIMEOUT);
    if(Retcode != 0)
    {
      Retcode = HSSL_HSHAKE_SET_RX_TIMEOUT_ERR;
      break;
    }
    Retcode = HSSL_OP_OK;
    break;
  }
  if(Retcode != HSSL_OP_OK)
  {
    ReleaseConnectStrucLock(pConnStruc);		// release struc. lock
    CloseConnection(pConnStruc,0);			// structure freed!
    return(Retcode);
  }
  //-------------------------------------------------
  // Send Start Message to Remote site, obey timeouts
  //-------------------------------------------------
  for(;;)
  {
    Retcode = HSSL_Tcp_Transmit(pConnStruc,pTmpContStat, pTmpReason);
    if(Retcode != HSSL_OP_OK)				// Error/Timeout
    {
      if(Retcode == -2)					// TX-Timeout, wait
      {
        RetryTime--;
        if(RetryTime != 0)
          continue;					// keep on waiting...
        Retcode = HSSL_HSHAKE_TCP_TX_TIMEOUT;
      }
      //------------------------------------------
      // invalidate resumability for session cache
      //------------------------------------------
      // !!!! implement that later !!!!
      if((pConnStruc->Entity == CLIENT_ENTITY) &&
         ((pCfgStruc->ExtCertsFlags & EXTCERT_CLNTAUTH_FROM_EXT_BIT)!= 0))
      {
        //------------------------------------------------
        // Purge the external cert dll's INI file entries...
        //------------------------------------------------
        pCfgStruc->ExtCertsFlags &= (~EXTCERT_CLNTAUTH_FROM_EXT_BIT);
        HSSL_PurgeExtCertIniFile(pCfgStruc->pExtCertStruc);
      }

      ReleaseConnectStrucLock(pConnStruc);		// release struc. lock
//    DBG_PRINT("\nTXTO1");
      CloseConnection(pConnStruc,pTmpReason[0]);	// structure freed!
      return(Retcode);
    }
    //--------------------------------------------
    // send o.k., check if all sent
    //--------------------------------------------
    if(pConnStruc->pPriorityTxQueueHead == NULL)	// Start data sent
      break;
  }
  //===================================================================
  // Receive/Transmit until error/timeout occurs or handshake completed
  //===================================================================
  for(;;)
  {
    Retcode = HSSL_Tcp_Receive(pConnStruc,pTmpContStat);
    if((Retcode != HSSL_OP_OK) ||
       (pTmpContStat[0] == STATUS_CLOSED_BY_REMOTE) ||
       (pTmpContStat[0] == STATUS_FATAL_ALERT_QUEUED))
    {
      //------------------------------------------
      // check for timeout
      //------------------------------------------
      if(Retcode == -2)
      {
        RetryTime--;
        if(RetryTime != 0) continue;			// keep on waiting...
        Retcode = HSSL_HSHAKE_TCP_RX_TIMEOUT;
      }
      //------------------------------------------
      // invalidate resumability for session cache
      //------------------------------------------
      // !!!! implement that later !!!!

      if((pConnStruc->Entity == CLIENT_ENTITY) &&
         ((pCfgStruc->ExtCertsFlags & EXTCERT_CLNTAUTH_FROM_EXT_BIT)!= 0))
      {
        //------------------------------------------------
        // Purge the external cert dll's INI file entries...
        //------------------------------------------------
        pCfgStruc->ExtCertsFlags &= (~EXTCERT_CLNTAUTH_FROM_EXT_BIT);
        HSSL_PurgeExtCertIniFile(pCfgStruc->pExtCertStruc);
      }

      if(Retcode == HSSL_OP_OK)
      {
        if(pTmpContStat[0] == STATUS_CLOSED_BY_REMOTE)	// remote close
        {  
          ReleaseConnectStrucLock(pConnStruc);		// release struc. lock
// newly inserted,....
          CloseConnection(pConnStruc,REMOTE_SHUTDOWN_FAILURE);// structure freed!
          return(HSSL_HSHAKE_REMOTE_SHUTDOWN);
        }
        if(pTmpContStat[0] == STATUS_FATAL_ALERT_QUEUED)
        {
          SendQueuedTxData(pConnStruc,pTmpContStat,pTmpReason);
          ReleaseConnectStrucLock(pConnStruc);		// release struc. lock
//        DBG_PRINT("\nC4");
          CloseConnection(pConnStruc,pTmpReason[0]);	// structure freed!
          return(HSSL_HSHAKE_LCL_FATAL_ALERT);
        }
      }
      else						// Retcode set
      {
        if(pTmpContStat[0] == STATUS_FATAL_ALERT_QUEUED)
        {
          SendQueuedTxData(pConnStruc,pTmpContStat,pTmpReason);
        }
      }

      ReleaseConnectStrucLock(pConnStruc);		// release struc. lock
      CloseConnection(pConnStruc,0);			// structure freed!
      return(Retcode);
    }
    //----------------------------------------------------
    // Do send newly queued data
    //----------------------------------------------------
    for(;;)
    {
      Retcode = HSSL_Tcp_Transmit(pConnStruc,pTmpContStat, pTmpReason);
      if(Retcode != HSSL_OP_OK)
      {
        if(Retcode == -2)				// TX-Timeout, wait
        {
          RetryTime--;
          if(RetryTime != 0) continue;			// keep on waiting...
          Retcode = HSSL_HSHAKE_TCP_TX_TIMEOUT;
        }
        //------------------------------------------
        // invalidate resumability for session cache
        //------------------------------------------
        // !!!! implement that later !!!!

        if((pConnStruc->Entity == CLIENT_ENTITY) &&
           ((pCfgStruc->ExtCertsFlags & EXTCERT_CLNTAUTH_FROM_EXT_BIT)!= 0))
        {
          //------------------------------------------------
          // Purge the external cert dll's INI file entries...
          //------------------------------------------------
          pCfgStruc->ExtCertsFlags &= (~EXTCERT_CLNTAUTH_FROM_EXT_BIT);
          HSSL_PurgeExtCertIniFile(pCfgStruc->pExtCertStruc);
        }

        ReleaseConnectStrucLock(pConnStruc);		// release struc. lock
//      DBG_PRINT("\nC6");
        CloseConnection(pConnStruc,pTmpReason[0]);	// structure freed!
        return(Retcode);
      }
      break;
    } // send FOR
    if(pConnStruc->ConnectionState == CONN_STATE_CONNECTED)
      break;
  }
  //--------------------------------------------------
  // Restore timeouts for TCP-Operations to old values
  //--------------------------------------------------
  HLSSL_CallBack(TCP_TIMEOUT_FUNCTION,pConnStruc->SocketIndex,NULL,TCP_TX_TIMEOUT_SET,(int) ActTxTimeout);
  HLSSL_CallBack(TCP_TIMEOUT_FUNCTION,pConnStruc->SocketIndex,NULL,TCP_RX_TIMEOUT_SET,(int) ActRxTimeout);
  ReleaseConnectStrucLock(pConnStruc);			// release struc. lock
  return(HSSL_OP_OK);					// handshake completed !!
}
#endif // !defined XH_INTERFACE

#if defined XH_INTERFACE && !defined XH_DUMMY
#if XH_INTF_VERSION < 300
/**
* Performs handshake phase for connection
* setup (XH2DoHandshake). 
* The start message is already queued to the priority
* send queue and must be sent first.
* 
*  @param pXif2Struc Interface Structure
*
*  @return HSSL_OP_OK on success, error code otherwise
*/
static int XH2DoHandshake(struct dsd_hl_ssl_s_2 * pXif2Struc)
{
  int Retcode;

  int pTmpContStat[1];
  int pTmpReason[1];

  CONNSTRU * pConnStruc;
  XHCONNSTRUC * pXHConnStruc;

  HMEM_CTX_DEF1;

  //-----------------------------------------
  // Get Structure pointers
  //-----------------------------------------
  pXHConnStruc = (XHCONNSTRUC *) pXif2Struc->ac_ext;	// get control structure
  pConnStruc   = pXHConnStruc->pConnStruc;

  LOAD_HMEM_CTX_PTR(CONN_pMemCtx(pConnStruc));

  //-----------------------------------------
  // Send / Get data to send, try to send
  //-----------------------------------------
  Retcode = HSSL_XH2Tcp_Transmit(pXif2Struc,pTmpContStat, pTmpReason);
  if(Retcode != HSSL_OP_OK)
  {
    //------------------------------------------
    // invalidate resumability for session cache
    //------------------------------------------
    // !!!! implement that later !!!!

//    FreeXH2ConnStateStruct(HMEM_CTX_REF,pXif2Struc); // free all used...
    return(Retcode);				// set error reason
  }
  //--------------------------------------------
  // Distribute by mode
  //--------------------------------------------
  switch(pXHConnStruc->XHConnState)			// distribute...
  {
    case XH_STATE_CONNECT_START:		// connect data queued check
      pXHConnStruc->XHConnState = XH_STATE_CONNECT_SEND; // set next state
      if(pConnStruc->pTxFragmentBuffer != NULL)	// not all data sent yet
        return(Retcode);
      pXHConnStruc->XHConnState = XH_STATE_CONNECT_WAIT;// all sent, do receive
      break;
    //---------------------------------------------------
    // First Send part still in Transmit
    //---------------------------------------------------
    case XH_STATE_CONNECT_SEND:			// sending active
      if(pConnStruc->pTxFragmentBuffer != NULL)	// not all data sent yet
        return(Retcode);
      pXHConnStruc->XHConnState = XH_STATE_CONNECT_WAIT;// all sent, do receive
      break;
    //---------------------------------------------------
    // Connect is in exchange state
    //---------------------------------------------------
    case XH_STATE_CONNECT_WAIT:			// dummy
      break;
    //---------------------------------------------------
    // Connect is in alert send state
    //---------------------------------------------------
    case XH_STATE_CONNECT_ALERT:		// must send alert
      if(pConnStruc->pTxFragmentBuffer != NULL)	// not all data sent yet
        return(Retcode);

      pXHConnStruc->XHConnState = XH_STATE_CONNECT_CLOSING;	// all data buffered for send..
      return(Retcode);
    //---------------------------------------------------
    // Connect is in closing state
    //---------------------------------------------------
    case XH_STATE_CONNECT_CLOSING:		// all sent...
      pXHConnStruc->XHConnState = XH_STATE_CLOSED;
      Retcode = pXHConnStruc->DeferredRetcode;
//      FreeXH2ConnStateStruct(HMEM_CTX_REF,pXif2Struc);	// free all used...
      return(Retcode);

    //------------------------------------------------
    // is in invalid state...
    //------------------------------------------------
    default:
//      FreeXH2ConnStateStruct(HMEM_CTX_REF,pXif2Struc); // free all used...
      return(HSSL_NEWCONN_STATE_ERR);
  } // switch
  //------------------------------------------------
  // Receive data if data present
  //------------------------------------------------
  Retcode = HSSL_XH2Tcp_Receive(pXif2Struc, pTmpContStat);
  if((Retcode != HSSL_OP_OK) ||
     (pTmpContStat[0] == STATUS_FATAL_ALERT_QUEUED))
  {
    //------------------------------------------
    // invalidate resumability for session cache
    //------------------------------------------
    // !!!! implement that later !!!!

    if((pTmpContStat[0] == STATUS_FATAL_ALERT_QUEUED) &&
       (Retcode != HSSL_OP_OK))
    {
      pXHConnStruc->XHConnState = XH_STATE_CONNECT_ALERT;
      pXHConnStruc->DeferredRetcode = Retcode;
      return(HSSL_OP_OK);
    }

    if(Retcode != HSSL_OP_OK)
    {
//      FreeXH2ConnStateStruct(HMEM_CTX_REF,pXif2Struc);	// free all used...
//      return(HSSL_HSHAKE_LCL_FATAL_ALERT);
      return(Retcode);
    }
    return(Retcode);
  }
  Retcode = HSSL_XH2Tcp_Transmit(pXif2Struc,pTmpContStat, pTmpReason);
  if(Retcode != HSSL_OP_OK)
  {
    //------------------------------------------
    // invalidate resumability for session cache
    //------------------------------------------
    // !!!! implement that later !!!!
//    FreeXH2ConnStateStruct(HMEM_CTX_REF,pXif2Struc);	// free all used...
    return(Retcode);
  }
  if(pConnStruc->ConnectionState == CONN_STATE_CONNECTED)
  {
    if(pConnStruc->pPriorityTxQueueHead == NULL) // all Handshake data sent
      pXHConnStruc->XHConnState = XH_STATE_NORMAL;   // so switch to normal...
    return(Retcode);
  }
  return(Retcode);
}
#endif // XH_INTF_VERSION < 300

/**
* Performs handshake phase for connection
* setup (XHCLDoHandshake).
* The start message is already queued to the priority
* send queue and must be sent first.
* 
*  @param pXifClStruc Interface structure
*
*  @return HSSL_OP_OK on success, error code otherwise
*/
static int XHCLDoHandshake(struct dsd_hl_ssl_c_1 * pXifClStruc)
{
  int Retcode;
  int DataLen;

  int pTmpContStat[1];
  int pTmpReason[1];

  CONNSTRU * pConnStruc;
  XHCONNSTRUC * pXHConnStruc;

  HMEM_CTX_DEF1;

  //-----------------------------------------
  // Get Structure pointers
  //-----------------------------------------
  pXHConnStruc = (XHCONNSTRUC *) pXifClStruc->vpc_ext;	// get control structure
  pConnStruc   = pXHConnStruc->pConnStruc;

  LOAD_HMEM_CTX_PTR(CONN_pMemCtx(pConnStruc));

  //-----------------------------------------
  // Send / Get data to send, try to send
  //-----------------------------------------
  Retcode = HSSL_XHCLTcp_Transmit(pXifClStruc,pTmpContStat, pTmpReason);
  if(Retcode != HSSL_OP_OK)
  {
    //------------------------------------------
    // invalidate resumability for session cache
    //------------------------------------------
    // !!!! implement that later !!!!

// Do NOT Free here !!!
//    FreeXHCLConnStateStruct(HMEM_CTX_REF,pXifClStruc); // free all used...
    return(Retcode);				// set error reason
  }
  //--------------------------------------------
  // Distribute by mode
  //--------------------------------------------

  switch(pXHConnStruc->XHConnState)			// distribute...
  {
    case XH_STATE_CONNECT_START:		// connect data queued check
      pXHConnStruc->XHConnState = XH_STATE_CONNECT_SEND; // set next state
      if(pConnStruc->pTxFragmentBuffer != NULL)	// not all data sent yet
        return(Retcode);
      pXHConnStruc->XHConnState = XH_STATE_CONNECT_WAIT;// all sent, do receive
      break;
    //---------------------------------------------------
    // First Send part still in Transmit
    //---------------------------------------------------
    case XH_STATE_CONNECT_SEND:			// sending active
      if(pConnStruc->pTxFragmentBuffer != NULL)	// not all data sent yet
        return(Retcode);
      pXHConnStruc->XHConnState = XH_STATE_CONNECT_WAIT;// all sent, do receive
      break;
    //---------------------------------------------------
    // Connect is in exchange state
    //---------------------------------------------------
    case XH_STATE_CONNECT_WAIT:			// dummy
      break;
    //---------------------------------------------------
    // Connect is in alert send state
    //---------------------------------------------------
    case XH_STATE_CONNECT_ALERT:		// must send alert
      if(pConnStruc->pTxFragmentBuffer != NULL)	// not all data sent yet
        return(Retcode);

      pXHConnStruc->XHConnState = XH_STATE_CONNECT_CLOSING;	// all data buffered for send..
      return(Retcode);
    //---------------------------------------------------
    // Connect is in closing state
    //---------------------------------------------------
    case XH_STATE_CONNECT_CLOSING:		// all sent...
      pXHConnStruc->XHConnState = XH_STATE_CLOSED;
      Retcode = pXHConnStruc->DeferredRetcode;

// Do NOT free here !!!
//      FreeXHCLConnStateStruct(HMEM_CTX_REF,pXifClStruc);	// free all used...
      return(Retcode);

    //------------------------------------------------
    // is in invalid state...
    //------------------------------------------------
    default:
// do NOT free here
//      FreeXHCLConnStateStruct(HMEM_CTX_REF,pXifClStruc); // free all used...
      return(HSSL_NEWCONN_STATE_ERR);
  } // switch
  //------------------------------------------------
  // Receive data if data present
  //------------------------------------------------
  for(;;)
  {

    DataLen = GetXH2ListDataLen(pXifClStruc->adsc_gai1_in_se);
    if(DataLen <= 0)			// no more data to process...
      break;

//if(DataLen > 0)
//{
    Retcode = HSSL_XHCLTcp_Receive(pXifClStruc, DataLen, pTmpContStat);
    if((Retcode != HSSL_OP_OK) ||
       (pTmpContStat[0] == STATUS_FATAL_ALERT_QUEUED))
    {
      //------------------------------------------
      // invalidate resumability for session cache
      //------------------------------------------
      // !!!! implement that later !!!!

      if((pTmpContStat[0] == STATUS_FATAL_ALERT_QUEUED) &&
         (Retcode != HSSL_OP_OK))
      {
//        pXHConnStruc->XHConnState = XH_STATE_CONNECT_ALERT;
        pXHConnStruc->XHConnState = XH_STATE_CONNECT_CLOSING; // ??? CHECK THAT !!
        pXHConnStruc->DeferredRetcode = Retcode;

	Retcode = HSSL_XHCLTcp_Transmit(pXifClStruc,pTmpContStat, pTmpReason);
	if(Retcode != HSSL_OP_OK)
	  return(Retcode);

        return(HSSL_OP_OK);
      }

      if(Retcode != HSSL_OP_OK)
      {
// Do NOT free here !!!
//        FreeXHCLConnStateStruct(HMEM_CTX_REF,pXifClStruc); // free all used...
//        return(HSSL_HSHAKE_LCL_FATAL_ALERT);
        return(Retcode);
      }
      return(Retcode);
    }
  }

  Retcode = HSSL_XHCLTcp_Transmit(pXifClStruc,pTmpContStat, pTmpReason);
  if(Retcode != HSSL_OP_OK)
  {
    //------------------------------------------
    // invalidate resumability for session cache
    //------------------------------------------
    // !!!! implement that later !!!!
//    FreeXHCLConnStateStruct(HMEM_CTX_REF,pXifClStruc);	// free all used...
    return(Retcode);
  }
  if(pConnStruc->ConnectionState == CONN_STATE_CONNECTED)
  {
    if(pConnStruc->pPriorityTxQueueHead == NULL) // all Handshake data sent
      pXHConnStruc->XHConnState = XH_STATE_NORMAL;   // so switch to normal...
    return(Retcode);
  }
  return(Retcode);
}
#endif // defined XH_INTERFACE

#if !defined XH_INTERFACE // not used with alternate
extern "C" int HLSSL_Connect(int SocketID, char* ServerIpAdr,
			 int ServerPort, char* ClientIpAdr)
{
  int Retcode;
  CONNSTRU * pConnStruc;

  Retcode = InitializeNewConnection(SocketID,ServerIpAdr,ServerPort,
			            ClientIpAdr,CLIENT_ENTITY);
  if(Retcode != HSSL_OP_OK)
  {
    if(Retcode > 0)  return(-1);
    else return(Retcode);
  }
  pConnStruc = pConnPtrArray[SocketID-1];// get pointer
  Retcode = DoHandshake(pConnStruc);
  if(Retcode != HSSL_OP_OK)
  {
    if(Retcode > 0)  return(-1);
    else return(Retcode);
  }
  return(0);
}
#endif // !defined XH_INTERFACE

#if !defined XH_INTERFACE // alternate used
extern "C" int HLSSL_Accept(int SocketID, char* ServerIpAdr,
			int ServerPort, char* ClientIpAdr)
{
  int Retcode;
  CONNSTRU * pConnStruc;

  Retcode = InitializeNewConnection(SocketID,ServerIpAdr,ServerPort,
			            ClientIpAdr,SERVER_ENTITY);
  if(Retcode != HSSL_OP_OK)
  {
    if(Retcode >= 0) return(-1);
    else return(Retcode);
  }
  pConnStruc = pConnPtrArray[SocketID-1];// get pointer
  Retcode = DoHandshake(pConnStruc);

  if(Retcode != HSSL_OP_OK)
  {
    if(Retcode > 0) return(-1);
    else return(Retcode);
  }
  return(0);
}
#endif // !defined XH_INTERFACE

#if defined XH_INTERFACE
#if XH_INTF_VERSION < 300
/**
* Called from Interface when the lower
* level wants to establish a secure connection to the server (XH2SSL_Accept).
*
* The TCP connection is already established.
*
*  @param pXif2Struc Interface structure
*  @param CfgStruc Configuration
*
*  @return HSSL_OP_OK on success, else error occured
*/
static  int XH2SSL_Accept(HMEM_CTX_DEF
				 struct dsd_hl_ssl_s_2 * pXif2Struc,
				 CFG_STRU * CfgStruc)
{
  int Retcode;

  CONNSTRU * pConnStruc;
  CONNSTRU * pTmpConnStruc[1];
  XHCONNSTRUC * pXHConnStru;

//  DBG_PRINT("\nXHSSL Accept called");
  //------------------------------------------------------------
  // Allocate XH Connect Descriptor Structure, initialize
  //------------------------------------------------------------
  pXHConnStru = (XHCONNSTRUC *)
    ((void *) BIT8_ARRAY_ALLOC(HMEM_CTX_REF,sizeof(XHCONNSTRUC)));
  if(pXHConnStru == NULL)
    return(HSSL_NEWCONN_STRUC_ALLOC_ERR);
  memset(pXHConnStru,0,sizeof(XHCONNSTRUC));	// clear
  pXHConnStru->XHConnState = XH_STATE_CONNECT_START;// set primary state
  //------------------------------------------------------------
  // Initialize new connection structure, queue Hello message
  //------------------------------------------------------------
  Retcode = XH2InitializeNewConnection(HMEM_CTX_REF1
			SERVER_ENTITY,CfgStruc,pXif2Struc,pTmpConnStruc);
  if(Retcode != HSSL_OP_OK)
  {
    FREE_ARRAY(HMEM_CTX_REF,pXHConnStru);	// release base structure
    return(Retcode);
  }
  pConnStruc = pTmpConnStruc[0];		// get pointer
  pXHConnStru->pConnStruc = pConnStruc;		// put to XH controel struct.
  pXif2Struc->ac_ext = pXHConnStru;		// put to Connection extra  
  //------------------------------------------------------------
  // Try to send the queued Hello Message to the remote site
  //------------------------------------------------------------
#if !defined XH_DUMMY
  Retcode = XH2DoHandshake(pXif2Struc);
  if(Retcode != HSSL_OP_OK)
  {
    //------------------------------------------
    // invalidate resumability for session cache
    //------------------------------------------
    // !!!! implement that later !!!!

    FreeXH2ConnStateStruct(HMEM_CTX_REF,pXif2Struc);	// free all used...
    return(Retcode);
  }
#endif // XH_DUMMY

//  DBG_PRINT("\nXHSSL Accept ended, Retcode: ");
//  DBG_PRINT_INT(Retcode);
  return(Retcode);
}
#endif // XH_INTF_VERSION < 300

#if XH_INTF_VERSION >= 300
/**
* Called from Interface when the lower
* level wants to establish a secure connection to the server(XH3SSL_Accept).
*
* The TCP connection is already established.
*
*  @param pXif3Struc Interface structure
*  @param CfgStruc Configuration
*
*  @return HSSL_OP_OK on success,
* <br>            else error occured
*/
static  int XH3SSL_Accept(HMEM_CTX_DEF
				 struct dsd_hl_ssl_s_3 * pXif3Struc,
				 CFG_STRU * CfgStruc)
{
  int Retcode;

  CONNSTRU * pConnStruc;
  CONNSTRU * pTmpConnStruc[1];
  XHCONNSTRUC * pXHConnStru;

//  DBG_PRINT("\nXHSSL Accept called");
  //------------------------------------------------------------
  // Allocate XH Connect Descriptor Structure, initialize
  //------------------------------------------------------------
  pXHConnStru = (XHCONNSTRUC *)
    ((void *) BIT8_ARRAY_ALLOC(HMEM_CTX_REF,sizeof(XHCONNSTRUC)));
  if(pXHConnStru == NULL)
    return(HSSL_NEWCONN_STRUC_ALLOC_ERR);
  memset(pXHConnStru,0,sizeof(XHCONNSTRUC));	// clear
  pXHConnStru->XHConnState = XH_STATE_CONNECT_START;// set primary state
  //------------------------------------------------------------
  // Initialize new connection structure, queue Hello message
  //------------------------------------------------------------
  Retcode = XH3InitializeNewConnection(HMEM_CTX_REF1
			SERVER_ENTITY,CfgStruc,pXif3Struc,pTmpConnStruc);
  if(Retcode != HSSL_OP_OK)
  {
    FREE_ARRAY(HMEM_CTX_REF,pXHConnStru);	// release base structure
    return(Retcode);
  }
  pConnStruc = pTmpConnStruc[0];		// get pointer
  pXHConnStru->pConnStruc = pConnStruc;		// put to XH controel struct.
  pXif3Struc->ac_ext = pXHConnStru;		// put to Connection extra  

  pConnStruc->adsc_alpn_cfg = pXif3Struc->adsc_alpn_cfg;
  pConnStruc->adsc_sni_cfg = pXif3Struc->adsc_sni_cfg;
 
  return(Retcode);
}
#endif // XH_INTF_VERSION >= 300

/**
* Called from Interface when the lower
* level wants to establish a secure connection to the client(XHCLSSL_Connect).
*
* The TCP connection is already established.
*
*  @param pXifClStruc Interface structure
*  @param CfgStruc Configuration
*
*  @return HSSL_OP_OK on success,
* <br>            else error occured
*/
static  int XHCLSSL_Connect(HMEM_CTX_DEF
				   struct dsd_hl_ssl_c_1 * pXifClStruc,
				   CFG_STRU * CfgStruc)
{
  int Retcode;

  CONNSTRU * pConnStruc;
  CONNSTRU * pTmpConnStruc[1];
  XHCONNSTRUC * pXHConnStru;

//  DBG_PRINT("\nXHCL_SSL Connect called");
  //------------------------------------------------------------
  // Allocate XH Connect Descriptor Structure, initialize
  //------------------------------------------------------------
  pXHConnStru = (XHCONNSTRUC *)
    ((void *) BIT8_ARRAY_ALLOC(HMEM_CTX_REF,sizeof(XHCONNSTRUC)));
  if(pXHConnStru == NULL)
    return(HSSL_NEWCONN_STRUC_ALLOC_ERR);
  memset(pXHConnStru,0,sizeof(XHCONNSTRUC));	// clear
  pXHConnStru->XHConnState = XH_STATE_CONNECT_START;// set primary state
  //------------------------------------------------------------
  // Initialize new connection structure, queue Hello message
  //------------------------------------------------------------
  Retcode = XHCLInitializeNewConnection(HMEM_CTX_REF1
		CLIENT_ENTITY,CfgStruc,pXifClStruc,pTmpConnStruc);
  if(Retcode != HSSL_OP_OK)
  {
    FREE_ARRAY(HMEM_CTX_REF,pXHConnStru);	// release base structure
    return(Retcode);
  }
  pConnStruc = pTmpConnStruc[0];		// get pointer
  pXHConnStru->pConnStruc = pConnStruc;		// put to XH controel struct.
  pXifClStruc->vpc_ext = pXHConnStru;		// put to Connection extra  
  //------------------------------------------------------------
  // Try to send the queued Hello Message to the remote site
  //------------------------------------------------------------
#if !defined XH_DUMMY
  Retcode = XHCLDoHandshake(pXifClStruc);
  if(Retcode != HSSL_OP_OK)
  {
    //------------------------------------------
    // invalidate resumability for session cache
    //------------------------------------------
    // !!!! implement that later !!!!
// Do NOT free connection structure here !!!
//    FreeXHCLConnStateStruct(HMEM_CTX_REF,pXifClStruc);	// free all used...
    return(Retcode);
  }
#endif // XH_DUMMY

//  DBG_PRINT("\nXHSSL Connect ended, Retcode: ");
//  DBG_PRINT_INT(Retcode);
  return(Retcode);
}
#endif // XH_INTERFACE

#if !defined XH_INTERFACE
/**
* Sets timeout for application data receive (HLSSL_SetAppRxTimeout).
*
*
*  @param SocketID Index to socket array, rel. 1
*  @param Timeout 0 - no timeout, else in ms
*
*  @return == 0 on success, error code otherwise
*/
extern "C" int HLSSL_SetAppRxTimeout(int SocketID, int Timeout)
{
  int Retcode;
  CONNSTRU * pConnStruc;
  //-----------------------------------------------------
  // check parameters
  //-----------------------------------------------------
  if((SocketID < 1) ||
     (SocketID > pGlobalCfgStruct->MaxConnCount) ||
     (Timeout < 0))
    return(-1);
  //-----------------------------------------------------
  // check if a connection structure exists
  //-----------------------------------------------------
  pConnStruc = GetConnectStrucAndLock(SocketID);
  if(pConnStruc == NULL)
    return(-2);
  //---------------------------------------------------------
  // set the new Timeout, check if the Interface is connected
  //---------------------------------------------------------
  Retcode = 0;
  pConnStruc->DefApplRxTimeout = Timeout;
  if(pConnStruc->ActApplRxTimeout != Timeout)	// not same as set
  {
    if(pConnStruc->ConnectionState == CONN_STATE_CONNECTED) // is connected
    {    
      Retcode = HLSSL_CallBack(TCP_TIMEOUT_FUNCTION,pConnStruc->SocketIndex,NULL,TCP_RX_TIMEOUT_SET,(int) Timeout);
      if(Retcode == 0)
        pConnStruc->ActApplRxTimeout = Timeout;	// say is set
    }
  }
  ReleaseConnectStrucLock(pConnStruc);		// release structure lock
  return(Retcode);
}
/**
* Gets timeout for application data receive (HLSSL_GetAppRxTimeout).
*
*  The SSL interface must already have a connection structure at the
*        given index.
*
*  @param SocketID Index to socket array, rel. 1
*  @param pTimeout Pointer for timeout: 0 - no timeout, else in ms
*
*  @return 0 on success, error code otherwise
*/
extern "C" int HLSSL_GetAppRxTimeout(int SocketID, int* pTimeout)
{
  CONNSTRU * pConnStruc;
  //-----------------------------------------------------
  // check parameters
  //-----------------------------------------------------
  if((SocketID < 1) ||
     (SocketID > pGlobalCfgStruct->MaxConnCount) ||
     (pTimeout == NULL))
    return(-1);
  //-----------------------------------------------------
  // check if a connection structure exists
  //-----------------------------------------------------
  pConnStruc = GetConnectStrucAndLock(SocketID);
  if(pConnStruc == NULL)
    return(-2);
  //---------------------------------------------------------
  // get the current Timeout
  //---------------------------------------------------------
  pTimeout[0] = pConnStruc->DefApplRxTimeout;
  ReleaseConnectStrucLock(pConnStruc);		// release structure lock
  return(0);
}
#endif //!defined XH_INTERFACE

#if !defined XH_INTERFACE // not used with alternate
extern "C" int HLSSL_SelectRecv(int SocketID)
{
  int Retcode;
  int ConnectState;
  int ContStat;

  CONNSTRU * pConnStruc;

  int pTmpContState[1];
  int pTmpReason[1];
  //-----------------------------------------------------
  // check parameters
  //-----------------------------------------------------
  if((SocketID < 1) ||
     (SocketID > pGlobalCfgStruct->MaxConnCount))
    return(-1);
  pConnStruc = GetConnectStrucAndLock(SocketID);
  if(pConnStruc == NULL)
    return(-1);
  //-----------------------------------------------------
  // Check Connection State
  //-----------------------------------------------------
  ConnectState =  pConnStruc->ConnectionState;
  switch(ConnectState)
  {
    case CONN_STATE_NOT_INITIALIZED:
    case CONN_STATE_CLOSED:
      ReleaseConnectStrucLock(pConnStruc);	// release structure lock
      return(-1);

    case CONN_STATE_HANDSHAKE_PHASE:
    case CONN_STATE_CONNECTED:
      break;
    case CONN_STATE_REMOTE_CLOSE_PENDING:
      ReleaseConnectStrucLock(pConnStruc);	// release structure lock
      return(1);				// "Data" present

//    case CONN_STATE_LOCAL_CLOSE_PENDING:
    default:
      ReleaseConnectStrucLock(pConnStruc);	// release structure lock
      return(0);
  }
  //-----------------------------------------------------
  // Check if Data on the Application Receive Queue
  //-----------------------------------------------------
  if(pConnStruc->pApplicationRxQueueHead != NULL)
  {
    ReleaseConnectStrucLock(pConnStruc);	// release structure lock
    return(1);					// Application data present
  }
  //-----------------------------------------------------
  // No data on Application Receive Queue, check if Data
  // for the socket present in TCP-Buffers
  //-----------------------------------------------------
  Retcode = HLSSL_CallBack(TCP_SELECT_RECV_FUNCTION,pConnStruc->SocketIndex,NULL,0,0);
  if(Retcode == 0)
  {
    //-----------------------------------------------------
    // No data from the TCP socket, send data from the queues
    // if present, DO NOT BLOCK on send !!
    //-----------------------------------------------------
    // !!!! implement that later !!!!!
    ReleaseConnectStrucLock(pConnStruc);	// release structure lock
    return(0);
  }
  //-----------------------------------------------------
  // Data present on TCP Receive Queue, receive data,
  // DO NOT BLOCK on receive !!, process data
  //-----------------------------------------------------
  Retcode  = HSSL_Tcp_Receive(pConnStruc, pTmpContState);
  ContStat = pTmpContState[0];
  if(Retcode != HSSL_OP_OK)
  {
    pTmpReason[0] = 0;
    //------------------------------------------
    // invalidate resumability for session cache
    //------------------------------------------
    // !!!! implement that later !!!!
    if(ContStat == STATUS_TCP_RX_ERROR)
    {
      ReleaseConnectStrucLock(pConnStruc);	// release structure lock
//    DBG_PRINT("\nC8");
      CloseConnection(pConnStruc,pTmpReason[0]);// structure freed!
      return(-1);
    }
    if(ContStat == STATUS_FATAL_ALERT_QUEUED)
    {
      pConnStruc->ConnectionState = CONN_STATE_LOCAL_CLOSE_PENDING;
      //------------------------------------------
      // invalidate resumability for session cache
      //------------------------------------------
      SendQueuedTxData(pConnStruc,pTmpContState,pTmpReason);
    }
    ReleaseConnectStrucLock(pConnStruc);	// release structure lock
//  DBG_PRINT("\nC9");
    CloseConnection(pConnStruc,pTmpReason[0]);	// structure freed!
    return(-1);
  }
  //-----------------------------------------------------
  // Check if now Data on the Application Receive Queue
  // o r  connection closed by local / remote side
  //-----------------------------------------------------
  if(ContStat == STATUS_CLOSED_BY_REMOTE)
  {
    pConnStruc->ConnectionState = CONN_STATE_REMOTE_CLOSE_PENDING;
    ReleaseConnectStrucLock(pConnStruc);	// release structure lock
    return(1);
  }
  if(pConnStruc->pApplicationRxQueueHead != NULL)
  {
    ReleaseConnectStrucLock(pConnStruc);	// release structure lock
    return(1);					// Application data present
  }
  ReleaseConnectStrucLock(pConnStruc);		// release structure lock
  return(0);					// still no data...
}
#endif // !defined XH_INTERFACE

#if !defined XH_DUMMY
/**
* Copies as much data from
* the application RX queue to the user buffer as possible (CopyApplicationDataToUser).
*
*  @param pConnStruc Connection structure
*  @param DstBuf Destination buffer
*  @param DstOff Start of data
*  @param DstLen Length of buffer
*  @return Bytes copied (>0)
*/
static  int  CopyApplicationDataToUser(CONNSTRU * pConnStruc,
		char* DstBuf, int DstOff, int DstLen)
{
  int DstIndex = DstOff;
  int SrcIndex;
  int SrcCount;
  int DstCount=0;

  char* pSrcBuf;

  RX_QEL * pActRxQel;
  RX_QEL * pNextRxQel;

  //--------------------------------------------------
  // Get Queue Element
  //--------------------------------------------------
// DBG_PRINT("Data to User ");
  pActRxQel = pConnStruc->pApplicationRxQueueHead;
  for(;;)
  {
    SrcIndex = pActRxQel->DataIndex;
    SrcCount = pActRxQel->DataLen;
    pSrcBuf = pActRxQel->pBuf;
    if(SrcCount <= DstLen)			// element smaller/same
    {
      memcpy(DstBuf+DstIndex,pSrcBuf+SrcIndex,SrcCount);
      DstCount += SrcCount;			// total copied bytes
      DstIndex += SrcCount;			// adjust index
      DstLen   -= SrcCount;			// reduce requested count
      pNextRxQel = DequeueRxQel(pConnStruc);	// dequeue, get next
      if(pNextRxQel == NULL)			// last Element
      {
        return(DstCount);
      }
      if(DstLen == 0)				// filled
      {
        return(DstCount);
      }
      pActRxQel = pNextRxQel;
    }   
    else					//element larger than requested
    {
      memcpy(DstBuf+DstIndex,pSrcBuf+SrcIndex,DstLen);
      SrcCount -= DstLen;			// reduce size
      SrcIndex += DstLen;			// adjust index
      DstCount += DstLen;			// total copied bytes
      pActRxQel->DataIndex = SrcIndex;	// save new index
      pActRxQel->DataLen = SrcCount;	// save new length
      return(DstCount);
    }
  } // for
}
#endif // !defined XH_DUMMY

#if !defined XH_INTERFACE // alternate used
extern "C" int HLSSL_Recv(int SocketID, char* DstBuf, int DstOff, int DstLen)
{
  int Retcode;
  int ConnectState;
  int ContStat;

  CONNSTRU * pConnStruc;

  int pTmpContState[1];
  int pTmpReason[1];

  //-----------------------------------------------------
  // check parameters
  //-----------------------------------------------------
  if((SocketID < 1) ||
     (SocketID > pGlobalCfgStruct->MaxConnCount) ||
     (DstBuf == NULL))
    return(-1);
  pConnStruc = GetConnectStrucAndLock(SocketID);
  if(pConnStruc == NULL)
    return(-2);
  if(DstLen == 0)
  {
    ReleaseConnectStrucLock(pConnStruc);	// release structure lock
    return(0);			// very strange case !!!
  }
  //-----------------------------------------------------
  // Check Connection State
  //-----------------------------------------------------
  ConnectState =  pConnStruc->ConnectionState;
  switch(ConnectState)
  {
    case CONN_STATE_NOT_INITIALIZED:
      ReleaseConnectStrucLock(pConnStruc);	// release structure lock
      return(-1);

    case CONN_STATE_CLOSED:
      Retcode = 0;
      if(pConnStruc->pApplicationRxQueueHead != NULL)
      {  
        Retcode = CopyApplicationDataToUser(pConnStruc,DstBuf,DstOff,DstLen);
        ADD_64(pConnStruc->AppRXDataMSW,pConnStruc->AppRXDataLSW,
	       (int) Retcode);
      }
      ReleaseConnectStrucLock(pConnStruc);	// release structure lock
      return(Retcode);

    case CONN_STATE_HANDSHAKE_PHASE:
// Removed
//      RAND_UTC_SEED(RANDinst);			// seed the generator
      break;

    case CONN_STATE_CONNECTED:			// check if proper timeout set
      if(pConnStruc->ActApplRxTimeout ==	// is already set, o.k.
         pConnStruc->DefApplRxTimeout)
        break;
      Retcode = HLSSL_CallBack(TCP_TIMEOUT_FUNCTION,pConnStruc->SocketIndex,NULL,TCP_RX_TIMEOUT_SET,(int) pConnStruc->DefApplRxTimeout);
      if(Retcode != 0)				// not set, error !!
      {
        ReleaseConnectStrucLock(pConnStruc);	// release structure lock
        return(-3);
      }
      pConnStruc->ActApplRxTimeout =	 // say is set
       pConnStruc->DefApplRxTimeout;
      break;

    case CONN_STATE_REMOTE_CLOSE_PENDING:
//    case CONN_STATE_LOCAL_CLOSE_PENDING:	// (same as remote)
      if(pConnStruc->pApplicationRxQueueHead != NULL)
        break;
      ReleaseConnectStrucLock(pConnStruc);	// release structure lock
      return(0);
  }
  //--------------------------------------------------------
  // Check if there is data on the Application Receive Queue
  //--------------------------------------------------------
  if(pConnStruc->pApplicationRxQueueHead != NULL)
  {
    Retcode = CopyApplicationDataToUser(pConnStruc,DstBuf,DstOff,DstLen);
    ADD_64(pConnStruc->AppRXDataMSW,pConnStruc->AppRXDataLSW,
           (int) Retcode);
    ReleaseConnectStrucLock(pConnStruc);	// release structure lock
    if(0 == Retcode){// Data package was empty, retry
       return HLSSL_Recv(SocketID, DstBuf, DstOff, DstLen);
    }
    return(Retcode);
  }
  //-----------------------------------------------------
  // No data on Application Receive Queue, check if Data
  // for the socket present in TCP-Buffers
  //-----------------------------------------------------
  Retcode = HLSSL_CallBack(TCP_SELECT_RECV_FUNCTION,pConnStruc->SocketIndex,NULL,0,0);
  if((Retcode != 0) ||				// there are data !!
     ((pConnStruc->SocketMode & BLOCKING_MODE_MASK) !=
      NON_BLOCKING_MODE))			// is blocking, wait...
  {
    //--------------------------------------------------------
    // Data Present on TCP-RX Queue, process ...
    // PROBLEM: When to do TRANSMIT ????
    //--------------------------------------------------------
    for(;;)
    {
      Retcode = HSSL_Tcp_Receive(pConnStruc, pTmpContState);
      ContStat = pTmpContState[0];
      if(Retcode == HSSL_RX_APPLDATA_NULL_MSG){ //received empty Appl Data, retry
         Retcode = HSSL_Tcp_Receive(pConnStruc, pTmpContState);
         ContStat = pTmpContState[0];
      }
      if(Retcode != HSSL_OP_OK)			// error occured
      {
        SendQueuedTxData(pConnStruc,pTmpContState,pTmpReason);
        ReleaseConnectStrucLock(pConnStruc);	// release structure lock
        CloseConnection(pConnStruc,pTmpReason[0]);	// structure freed!
        return(-1);
      }
      if(ContStat == STATUS_TCP_RX_TIMEOUT)		// Receive Timeout
      {
        ReleaseConnectStrucLock(pConnStruc);	// release structure lock
        return(WSAE_RX_TIMEOUT);		// special returncode !!!!
      }

      if(ContStat == STATUS_CLOSED_BY_REMOTE)		// terminated
      {
        pConnStruc->ConnectionState = CONN_STATE_REMOTE_CLOSE_PENDING;
      }
      if(pConnStruc->pApplicationRxQueueHead != NULL)
      {
        Retcode = CopyApplicationDataToUser(pConnStruc,DstBuf,DstOff,DstLen);
        ADD_64(pConnStruc->AppRXDataMSW,pConnStruc->AppRXDataLSW,
	       (int) Retcode);
        ReleaseConnectStrucLock(pConnStruc);	// release structure lock
        if(0 == Retcode){// Data package was empty, retry
           return HLSSL_Recv(SocketID, DstBuf, DstOff, DstLen);
        }
        return(Retcode);
      }
      if(ContStat == STATUS_CLOSED_BY_REMOTE)
      {
        pConnStruc->ConnectionState = CONN_STATE_CLOSED;
        ReleaseConnectStrucLock(pConnStruc);	// release structure lock
        return(0);
      }
      if((pConnStruc->SocketMode & BLOCKING_MODE_MASK) == NON_BLOCKING_MODE)
      {  
        ReleaseConnectStrucLock(pConnStruc);	// release structure lock
        return(WSAE_WOULD_BLOCK);
      }
    }
  }
  else
  {
    //-----------------------------------------------------
    // No data from the TCP socket, send data from the queues
    // if present
    //-----------------------------------------------------
    Retcode = HSSL_Tcp_Transmit(pConnStruc,pTmpContState,pTmpReason);
    if(Retcode != HSSL_OP_OK)
    {
      ReleaseConnectStrucLock(pConnStruc);	// release structure lock
//    DBG_PRINT("\nC11");
      CloseConnection(pConnStruc,pTmpReason[0]); // structure freed!
      return(-1);
    }
    ReleaseConnectStrucLock(pConnStruc);	// release structure lock
//  DBG_PRINT("Would Block !!\n");
    return(WSAE_WOULD_BLOCK);
  }
}
#endif // !defined XH_INTERFACE

#if defined XH_INTERFACE && !defined XH_DUMMY
#if XH_INTF_VERSION < 300
/**
* Receives application for the upper
* layer (XH2SSL_Recv).
*
*  The SSL interface must already have a connection structure.
*
*  @param pXif2Struc Interface structure
*/
static  void XH2SSL_Recv(struct dsd_hl_ssl_s_2 * pXif2Struc)
{
  int SrcLen;
  int DstLen;

  CONNSTRU * pConnStruc;

//  DBG_PRINT("\nXHSSL RX called\n");

  //-------------------------------------------------
  // Check if 'client' side was closed...
  //-------------------------------------------------
#if defined _WIN32
  if(pXif2Struc->boc_eof_client != 0)
#else
  if(pXif2Struc->boc_eof_server != 0)
#endif
  {
//    printf("HSSL:Client EOF!\n");
    pConnStruc = ((XHCONNSTRUC *) pXif2Struc->ac_ext)->pConnStruc; // get connect structure
    if(pConnStruc->pApplicationRxQueueHead == NULL)	// no data on queue
    {
//      printf("HSSL:No more RX Queues.\n");
      return;
    }
//    printf("SSL:Purge RX Queues!\n");
    PurgeRxQueues(pConnStruc);
    return;
  }

  //-------------------------------------------------
  // Check if buffer space for application data
  //-------------------------------------------------
  DstLen = (int) (pXif2Struc->achc_out_end -
                  pXif2Struc->achc_out_cur); // get size
  if(DstLen <= 0)			// no space for data !
    return;
  //-------------------------------------------------
  // Check if data on the Application receive queue
  //-------------------------------------------------
  pConnStruc = ((XHCONNSTRUC *) pXif2Struc->ac_ext)->pConnStruc; // get connect structure
  if(pConnStruc->pApplicationRxQueueHead == NULL)	// no data on queue
    return;
  //--------------------------------------------------------------
  // Copy application data to the user buffer, advance pointer
  //--------------------------------------------------------------
  SrcLen = CopyApplicationDataToUser(pConnStruc,
		pXif2Struc->achc_out_cur,0,DstLen); // copy data
  ADD_64(pConnStruc->AppRXDataMSW,pConnStruc->AppRXDataLSW,
	       (int) SrcLen);
  pXif2Struc->achc_out_cur += SrcLen;		// advance pointer
}
#endif // XH_INTF_VERSION < 300

#if XH_INTF_VERSION >= 300
/**
* Receives application for the upper
* layer (XH3SSL_Recv).
*
*  The SSL interface must already have a connection structure.
*
*  @param pXif3Struc Interface Structure
*/
static  void XH3SSL_Recv(struct dsd_hl_ssl_s_3 * pXif3Struc)
{
  int SrcLen;
  int DstLen;

  CONNSTRU * pConnStruc;

//  DBG_PRINT("\nXHSSL RX called\n");

// NEW NEW NEW
  //-------------------------------------------------
  // Check if 'client' side was closed...
  //-------------------------------------------------
  if(pXif3Struc->boc_eof_client)
  {
//    printf("HSSL:Client EOF!\n");
    pConnStruc = ((XHCONNSTRUC * )pXif3Struc->ac_ext)->pConnStruc; // get connect structure
    if(pConnStruc->pApplicationRxQueueHead == NULL)	// no data on queue
    {
//      printf("HSSL:No more RX Queues.\n");
      return;
    }
//    printf("SSL:Purge RX Queues!\n");
    PurgeRxQueues(pConnStruc);
    return;
  }
  //-------------------------------------------------
  // Check if buffer space for application data
  //-------------------------------------------------
  DstLen = (int) (pXif3Struc->achc_tose_end -
                  pXif3Struc->achc_tose_cur); // get size
  if(DstLen <= 0)			// no space for data !
    return;
  //-------------------------------------------------
  // Check if data on the Application receive queue
  //-------------------------------------------------
  pConnStruc = ((XHCONNSTRUC *) pXif3Struc->ac_ext)->pConnStruc; // get connect structure
  if(pConnStruc->pApplicationRxQueueHead == NULL)	// no data on queue
    return;
  //--------------------------------------------------------------
  // Copy application data to the user buffer, advance pointer
  //--------------------------------------------------------------
  SrcLen = CopyApplicationDataToUser(pConnStruc,
		pXif3Struc->achc_tose_cur,0,DstLen); // copy data
  ADD_64(pConnStruc->AppRXDataMSW,pConnStruc->AppRXDataLSW,
	       (int) SrcLen);
  pXif3Struc->achc_tose_cur += SrcLen;		// advance pointer
}
#endif // XH_INTF_VERSION >= 300

/**
* Receives application for the upper
* layer (XHCLSSL_Recv).
*
*  The SSL interface must already have a connection structure.
*
*  @param pXifClStruc Interface Structure
*/
static  void XHCLSSL_Recv(struct dsd_hl_ssl_c_1 * pXifClStruc)
{
  int SrcLen;
  int DstLen;

  CONNSTRU * pConnStruc;

//  DBG_PRINT("\nXHCLSSL RX called\n");
  //-------------------------------------------------
  // Check if buffer space for application data
  //-------------------------------------------------
  DstLen = (int) (pXifClStruc->achc_out_cl_end -
                  pXifClStruc->achc_out_cl_cur); // get size
  if(DstLen <= 0)			// no space for data !
    return;
  //-------------------------------------------------
  // Check if data on the Application receive queue
  //-------------------------------------------------
  pConnStruc = ((XHCONNSTRUC *) pXifClStruc->vpc_ext)->pConnStruc; // get connect structure
  if(pConnStruc->pApplicationRxQueueHead == NULL)	// no data on queue
    return;
  //--------------------------------------------------------------
  // Copy application data to the user buffer, advance pointer
  //--------------------------------------------------------------
  SrcLen = CopyApplicationDataToUser(pConnStruc,
		pXifClStruc->achc_out_cl_cur,0,DstLen); // copy data
  ADD_64(pConnStruc->AppRXDataMSW,pConnStruc->AppRXDataLSW,
	       (int) SrcLen);
  pXifClStruc->achc_out_cl_cur += SrcLen;		// advance pointer
}
#endif // XH_INTERFACE

#if !defined XH_INTERFACE // alternate used
extern "C" int HLSSL_Send(int SocketID, char* SrcBuf, int SrcOff, int SrcLen)
{
  int Retcode;
  int ConnectState;
  int ContStat;

  CONNSTRU * pConnStruc;

  char* pBuf;
  int pTmpContState[1];
  int pTmpReason[1];

  TX_QEL * pTxQel;

  //-----------------------------------------------------
  // check parameters
  //-----------------------------------------------------
  if((SocketID < 1) ||
     (SocketID > pGlobalCfgStruct->MaxConnCount) ||
     (SrcBuf == NULL))
  {
//    PRINT("\nTX-ParamErr 1 !");
    return(-1);
  }
  pConnStruc = GetConnectStrucAndLock(SocketID);
  if(pConnStruc == NULL)
  {
//    PRINT("\nTX-ParamErr 2 !");
    return(-1);
  }
  if(SrcLen == 0)
  {
    ReleaseConnectStrucLock(pConnStruc);	// release structure lock
    return(0);			// strange case !!!
  } 
  //-----------------------------------------------------
  // Check Connection State
  //-----------------------------------------------------
  ConnectState =  pConnStruc->ConnectionState;
  switch(ConnectState)
  {
    case CONN_STATE_HANDSHAKE_PHASE:
    case CONN_STATE_CONNECTED:
      break;

    case CONN_STATE_NOT_INITIALIZED:
    case CONN_STATE_CLOSED:
    case CONN_STATE_REMOTE_CLOSE_PENDING:
//    case CONN_STATE_LOCAL_CLOSE_PENDING:	// (same as local)
    default:
      ReleaseConnectStrucLock(pConnStruc);	// release structure lock
//      PRINT("\nTX-Invalid State: ");
//      PRINT_INT(ConnectState);
      return(-1);
  }
  //-----------------------------------------------------------------
  // Allocate Application TX Qel if possible, copy data to buffer
  //-----------------------------------------------------------------
  pTxQel = AllocInitTxQel(SrcLen,(unsigned char) TX_TYPE_APPLICATION_DATA);
  if(pTxQel == NULL)			// allocate failed
  {
     ReleaseConnectStrucLock(pConnStruc);	// release structure lock
     return(0);					// nothing queued for send...
  }
  pBuf = pTxQel->pBuf;
  memcpy(pBuf+0,SrcBuf+SrcOff,SrcLen);
  pTxQel->DataLen = SrcLen;
  //-----------------------------------------------------------------
  // Enqueue Element for Transmit
  //-----------------------------------------------------------------
  EnqueueTxQel(pConnStruc,pTxQel);
  //-----------------------------------------------------------------
  // Check if Handshake is currently active
  //-----------------------------------------------------------------
  if(ConnectState == CONN_STATE_HANDSHAKE_PHASE)
  {
    //-----------------------------------------------------------------
    // Handshake is active, continue handshake as long as possible...
    //-----------------------------------------------------------------
    for(;;)
    {
      //---------------------------------------------------------------
      // Check if data on priority send queue, if so send until empty
      //---------------------------------------------------------------
      if(pConnStruc->pPriorityTxQueueHead != NULL)
      {
        for(;;)
        {
          //-----------------------------------------------------------
          // Send data from priority queue
          //-----------------------------------------------------------
          Retcode = HSSL_Tcp_Transmit(pConnStruc,pTmpContState,pTmpReason);
          if(Retcode != HSSL_OP_OK)
          {
            ReleaseConnectStrucLock(pConnStruc);	// release struc. lock
//          DBG_PRINT("\nC12");
            CloseConnection(pConnStruc,pTmpReason[0]);// structure freed!
            return(-1);
          }
          if(pConnStruc->pPriorityTxQueueHead == NULL)
            break;
          if((pConnStruc->SocketMode & BLOCKING_MODE_MASK) ==
              NON_BLOCKING_MODE)
          {
             ReleaseConnectStrucLock(pConnStruc);	// release struc. lock
             return(SrcLen);
          }
        }
      }
      //---------------------------------------------------------------
      // Check if Handshake mode ended
      //---------------------------------------------------------------
      ConnectState =  pConnStruc->ConnectionState; // get new state
      if(ConnectState != CONN_STATE_HANDSHAKE_PHASE)
        break;
      //---------------------------------------------------------------
      // Handshake still active, check if data to receive from socket
      //---------------------------------------------------------------
      Retcode = HLSSL_CallBack(TCP_SELECT_RECV_FUNCTION,pConnStruc->SocketIndex,NULL,0,0);

      if((Retcode == 0) &&			// no data present...
         ((pConnStruc->SocketMode & BLOCKING_MODE_MASK) ==
              NON_BLOCKING_MODE))
      {
         ReleaseConnectStrucLock(pConnStruc);	// release structure lock
         return(SrcLen);
      }
      //--------------------------------------------------------
      // Data Present/or blocking socket, receive data/process
      //--------------------------------------------------------
      for(;;)
      {
        Retcode = HSSL_Tcp_Receive(pConnStruc, pTmpContState);
        ContStat = pTmpContState[0];
        ConnectState =  pConnStruc->ConnectionState;	// get new state
        if(Retcode != HSSL_OP_OK)		// error occured
        {
          SendQueuedTxData(pConnStruc,pTmpContState,pTmpReason);
          ReleaseConnectStrucLock(pConnStruc);	// release structure lock
//        DBG_PRINT("\nC13");
          CloseConnection(pConnStruc,pTmpReason[0]);	// structure freed!
          return(-1);
        }
        if(ContStat == STATUS_CLOSED_BY_REMOTE)		// terminated
        {
          if(ConnectState != CONN_STATE_CONNECTED)	// some error occured..
          {
            ReleaseConnectStrucLock(pConnStruc);	// release struc. lock
//          DBG_PRINT("\nC14");
            CloseConnection(pConnStruc,0);		// structure freed!
            return(-1);
          }
          pConnStruc->ConnectionState = CONN_STATE_REMOTE_CLOSE_PENDING;
          break;
        }
        if(ConnectState == CONN_STATE_CONNECTED)	// handshake finished
          break;
      }
      if(ConnectState == CONN_STATE_CONNECTED)	// handshake finished
        break;
    } // Handshake FOR
  }
  //-----------------------------------------------------------------
  // Standard mode, Try to send data from the Transmit queues if possible
  //-----------------------------------------------------------------
  for(;;)
  {
    Retcode = HSSL_Tcp_Transmit(pConnStruc,pTmpContState,pTmpReason);
    if(Retcode != HSSL_OP_OK)
    {
      ReleaseConnectStrucLock(pConnStruc);	// release structure lock
//    DBG_PRINT("\nC15");
      CloseConnection(pConnStruc,pTmpReason[0]);// structure freed!
      return(-1);
    }
    if((pConnStruc->pPriorityTxQueueHead == NULL) &&
       (pConnStruc->pApplicationTxQueueHead == NULL))
    {
      ADD_64(pConnStruc->AppTXDataMSW,pConnStruc->AppTXDataLSW,
	     (int) SrcLen);
      ReleaseConnectStrucLock(pConnStruc);	// release structure lock
      return(SrcLen);
    }
    if((pConnStruc->SocketMode & BLOCKING_MODE_MASK) == NON_BLOCKING_MODE)
    {
       ADD_64(pConnStruc->AppTXDataMSW,pConnStruc->AppTXDataLSW,
	      (int) SrcLen);
       ReleaseConnectStrucLock(pConnStruc);	// release structure lock
       return(SrcLen);
    }
  }
}
#endif // !defined XH_INTERFACE

#if defined XH_INTERFACE

#if !defined XH_DUMMY
#if XH_INTF_VERSION < 300
/**
* Transmits/buffers application data from
* the upper layer (XH2SSL_Send).
*
*  The SSL interface must already have a connection structure.
*
*  @param pXif2Struc Interface Structure
*/
static  void XH2SSL_Send(HMEM_CTX_DEF
				struct dsd_hl_ssl_s_2 * pXif2Struc)
{
  int SrcLen;

  char* pBuf;
  TX_QEL * pTxQel;

//  DBG_PRINT("\nXHSSL TX called");
  //-----------------------------------------------------
  // Check if data from application layer present
  //-----------------------------------------------------
  SrcLen = GetXH2ListDataLen(pXif2Struc->adsc_gather_i_1);
  if(SrcLen <= 0)
    return;				// no data to process...
  //-----------------------------------------------------------------
  // Allocate Application TX Qel if possible, copy data to buffer
  //-----------------------------------------------------------------
  pTxQel = AllocInitTxQel(HMEM_CTX_REF1
			  SrcLen,(unsigned char) TX_TYPE_APPLICATION_DATA);
  if(pTxQel == NULL)			// allocate failed
    return;				// no buffer, wait...

  pBuf = pTxQel->pBuf;
  CopyXH2DataListToBuffer(pXif2Struc->adsc_gather_i_1,pBuf,0,SrcLen);
  pTxQel->DataLen = SrcLen;
  //-----------------------------------------------------------------
  // Enqueue Element for Transmit
  //-----------------------------------------------------------------
  EnqueueTxQel(((XHCONNSTRUC *) pXif2Struc->ac_ext)->pConnStruc,pTxQel);
}
#endif // XH_INTF_VERSION < 300

#if !defined XH_DUMMY && XH_INTF_VERSION < 300
/**
* Transmits/buffers application data from
* the upper layer (XHCLSSL_Send).
*
*  The SSL interface must already have a connection structure.
*  @param pXifClStruc Interface Structure
*/
static  void XHCLSSL_Send(HMEM_CTX_DEF
				 struct dsd_hl_ssl_c_1 * pXifClStruc)
{
  int SrcLen;

  char* pBuf;
  TX_QEL * pTxQel;

//  DBG_PRINT("\nXHCL_SSL TX called");
  //-----------------------------------------------------
  // Check if data from application layer present
  //-----------------------------------------------------
  SrcLen = GetXH2ListDataLen(pXifClStruc->adsc_gai1_in_cl);
  if(SrcLen <= 0)
    return;				// no data to process...

  //-----------------------------------------------------------------
  // Allocate Application TX Qel if possible, copy data to buffer
  //-----------------------------------------------------------------
  pTxQel = AllocInitTxQel(HMEM_CTX_REF1
			  SrcLen,(unsigned char) TX_TYPE_APPLICATION_DATA);
  if(pTxQel == NULL)			// allocate failed
    return;				// no buffer, wait...

  pBuf = pTxQel->pBuf;
  CopyXH2DataListToBuffer(pXifClStruc->adsc_gai1_in_cl,pBuf,0,SrcLen);
  pTxQel->DataLen = SrcLen;
  //-----------------------------------------------------------------
  // Enqueue Element for Transmit
  //-----------------------------------------------------------------
  EnqueueTxQel(((XHCONNSTRUC *) pXifClStruc->vpc_ext)->pConnStruc,pTxQel);
}
#endif // XH_INTF_VERSION < 300
#endif // !defined XH_DUMMY
#endif // XH_INTERFACE

#if !defined XH_INTERFACE // not used with alternate
extern "C" int HLSSL_Disconnect(int SocketID)
{
  CONNSTRU * pConnStruc;

  int pTmpContState[1];
  int pTmpReason[1];
  //-----------------------------------------------------
  // check parameters
  //-----------------------------------------------------
  if((SocketID < 1) ||
     (SocketID > pGlobalCfgStruct->MaxConnCount))
    return(-1);
  pConnStruc = GetConnectStrucAndLock(SocketID);
  if(pConnStruc == NULL)
    return(-2);
  //-----------------------------------------------------
  // Check if session was a new or a resumed session
  //-----------------------------------------------------
  if(pConnStruc->CacheMode > CACHE_SESSION_TYPE_NEW)
  {
    //---------------------------------------------------
    // session was a resumed session, queue closure alert
    //---------------------------------------------------
      // !!! reduce session reference count !!!

    if(pConnStruc->ConnectionState == CONN_STATE_CONNECTED)
      SendAlert(pConnStruc,AD_CLOSE_NOTIFY,ALERT_LEVEL_WARNING);
    else    
      SendAlert(pConnStruc,AD_CLOSE_NOTIFY,ALERT_LEVEL_FATAL);
  }
  else
  {
    //---------------------------------------------------
    // session was a new session, check if resumable
    //---------------------------------------------------
    if(((pConnStruc->SessionID[0] & 0xFF) != 0) &&	// resumable
      (pConnStruc->ConnectionState == CONN_STATE_CONNECTED))
    {
      SendAlert(pConnStruc,AD_CLOSE_NOTIFY,ALERT_LEVEL_WARNING);
    // !!! reduce session reference count !!!
    }
    else						// not resumable
      SendAlert(pConnStruc,AD_CLOSE_NOTIFY,ALERT_LEVEL_FATAL);
  }  
  //-----------------------------------------------------------------
  // Try to send data from the Transmit queues as long as possible
  //-----------------------------------------------------------------
  SendQueuedTxData(pConnStruc,pTmpContState,pTmpReason);
  ReleaseConnectStrucLock(pConnStruc);	// release structure lock
//  DBG_PRINT("\nC16");
  CloseConnection(pConnStruc,pTmpReason[0]);	// structure freed!
  return(0);
}
#endif // !defined XH_INTERFACE

#if defined XH_INTERFACE		// alternate version
/**
* Clean up connection server/client cache (if used) (CleanupCaches).
*
*  @param pConnStruc Connection structure
*  @param Reason 'Returncode', error if < 0
*/
static  void CleanupCaches(HMEM_CTX_DEF
				  CONNSTRU * pConnStruc, int Reason)
{
  int CacheMode;
  HSERV_CACHE_ELEM ServerTemplate;
  HCLNT_CACHE_ELEM ClientTemplate;

  // Check if caching activated
  if((pConnStruc->ExtendedConfigFlags & SESS_CACHE_BIT_MASK) == 0)
    return;

  // Check if session was a cacheable type at all
  CacheMode = pConnStruc->CacheMode;
  if(CacheMode == CACHE_SESSION_TYPE_NON_CACHE)
    return;

  if(pConnStruc->Entity == SERVER_ENTITY)	// Server side
  {  
    //----------------------------------------------------
    // Server, abortive close
    //----------------------------------------------------
    if(Reason < 0)				// was an Abort..
      ServerCacheSessionAbort(HMEM_CTX_REF,
					pConnStruc->SessionID,
					CacheMode);
    else
    {
      //----------------------------------------------------
      // Server 'normal' close, prepare Template for Re-Enter
      //----------------------------------------------------
      memset(&ServerTemplate,0,sizeof(HSERV_CACHE_ELEM));
      ServerTemplate.SelectedProtocol    = pConnStruc->ActualProtocol;
      ServerTemplate.SelectedCipherSuite = pConnStruc->ActualCipherSuite;
      ServerTemplate.SelectedComprMethod = pConnStruc->ActualComprMethod;

      memcpy(ServerTemplate.SessionID,pConnStruc->SessionID,
	     MAX_SESSION_ID_LEN+1);

      memcpy(ServerTemplate.MasterSecret,pConnStruc->MasterSecret,
	     MASTER_SECRET_LEN);

      memcpy(ServerTemplate.PartnerCertHash,
	     pConnStruc->PartnerCertHash,SHA_DIGEST_LEN);

      ServerTemplate.CertifiedFlags = pConnStruc->CertifiedFlags;

      ServerCacheSessionClosed(HMEM_CTX_REF,
					 &ServerTemplate,CacheMode);
    }
  }
  else	// Client side
  {
    //----------------------------------------------------
    // Client, abortive close
    //----------------------------------------------------
    if(Reason < 0)				// was an Abort..
      ClientCacheSessionAbort(HMEM_CTX_REF,
					pConnStruc->ConnectionID,
					pConnStruc->SessionID,
					CacheMode);
    else
    {
      //----------------------------------------------------
      // Client 'normal' close, prepare Template for Re-Enter
      //----------------------------------------------------
      memset(&ClientTemplate,0,sizeof(HCLNT_CACHE_ELEM));
      ClientTemplate.SelectedProtocol    = pConnStruc->ActualProtocol;
      ClientTemplate.SelectedCipherSuite = pConnStruc->ActualCipherSuite;
      ClientTemplate.SelectedComprMethod = pConnStruc->ActualComprMethod;

      memcpy(ClientTemplate.ConnectionID,pConnStruc->ConnectionID,
	     MAX_CONNECTION_ID_LEN+1);

      memcpy(ClientTemplate.SessionID,pConnStruc->SessionID,
	     MAX_SESSION_ID_LEN+1);

      memcpy(ClientTemplate.MasterSecret,pConnStruc->MasterSecret,
	     MASTER_SECRET_LEN);

      memcpy(ClientTemplate.PartnerCertHash,
	     pConnStruc->PartnerCertHash,SHA_DIGEST_LEN);

      ClientTemplate.CertifiedFlags = pConnStruc->CertifiedFlags;

      ClientCacheSessionClosed(HMEM_CTX_REF,
					 &ClientTemplate,CacheMode,0);
    }
  }
  //---------------------------------------------------------------
  // Avoid 2nd time processing, reset cache mode
  //---------------------------------------------------------------
  pConnStruc->CacheMode = CACHE_SESSION_TYPE_NON_CACHE;
}
#if XH_INTF_VERSION < 300
/**
* Processes a step in the disconnecting procedure of a SSL/TLS connection (XH2SSL_Disconnect).
* Steps consist of sending required alerts, sending pending TX data, flushing
* buffers and releasing used resources in the interface structure.
*
* The return satus of the procedure is in the return parameter of the interface
* structure.
*
* Server side.
*
*  @param pXif2Struc Interface structure
*  @return == 0 on success
* <br>            < 0 rejected
*/
extern "C" int XH2SSL_Disconnect(struct dsd_hl_ssl_s_2 * pXif2Struc)
{
  int Retcode;
  CONNSTRU * pConnStruc;

  int pTmpContState[1];
  int pTmpReason[1];

  HMEM_CTX_DEF1;

  //-----------------------------------------------------
  // check parameters
  //-----------------------------------------------------
  if((pXif2Struc == NULL) || (pXif2Struc->ac_ext == NULL) ||
     ((pConnStruc = ((XHCONNSTRUC *) pXif2Struc->ac_ext)->pConnStruc) == NULL))
    return(HSSL_NULL_PTR);

  LOAD_HMEM_CTX_PTR(CONN_pMemCtx(pConnStruc));
  //-----------------------------------------------------
  // check if this is a TX-Continuation (Alert/Data etc.)
  //-----------------------------------------------------
  if(((XHCONNSTRUC *) pXif2Struc->ac_ext)->XHConnState == XH_STATE_CLOSING)
  {
#if defined _WIN32
    if((pXif2Struc->boc_eof_server != 0) ||
#else
    if((pXif2Struc->boc_eof_client != 0) ||
#endif
       ((pConnStruc->pPriorityTxQueueHead == NULL) && // no more data to send
        (pConnStruc->pApplicationTxQueueHead == NULL)))
    {
      FreeXH2ConnStateStruct(HMEM_CTX_REF,pXif2Struc); // free all used...
      pXif2Struc->inc_return = DEF_IRET_END;	// ended
//    DBG_PRINT("\nHSSL Ended, Mode 0");
      return(HSSL_OP_OK);
    }
    //-----------------------------------------------
    // Continue sending data...
    //-----------------------------------------------
    Retcode = HSSL_XH2Tcp_Transmit(pXif2Struc, pTmpContState, pTmpReason);
    if((Retcode != HSSL_OP_OK) ||		// error during send
       (pTmpContState[0] != STATUS_CONTINUE))	// cannot continue
    {
      FreeXH2ConnStateStruct(HMEM_CTX_REF,pXif2Struc); // free all used...
      pXif2Struc->inc_return = DEF_IRET_END;	// ended
//    DBG_PRINT("\nHSSL Ended, Mode 1");
      return(HSSL_OP_OK);
    }
    pXif2Struc->inc_return = DEF_IRET_NORMAL;	// try to send...
    return(HSSL_OP_OK);
  }
  else						// is shutdown initiate
  {
#if defined _WIN32
    if(pXif2Struc->boc_eof_server != 0)		// no socket for send data
#else
    if(pXif2Struc->boc_eof_client != 0)		// no socket for send data
#endif
    {
      FreeXH2ConnStateStruct(HMEM_CTX_REF,pXif2Struc);// free all used...
      pXif2Struc->inc_return = DEF_IRET_END;	// ended
//    DBG_PRINT("\nHSSL Ended, Mode 2\n");
      return(HSSL_OP_OK);
    }
    //--------------------------------------------------------
    // Socket is still valid
    //--------------------------------------------------------
    ((XHCONNSTRUC *) pXif2Struc->ac_ext)->XHConnState = XH_STATE_CLOSING; // set next state
    //-----------------------------------------------------
    // Check if session was a new or a resumed session
    //-----------------------------------------------------
    if(pConnStruc->CacheMode > CACHE_SESSION_TYPE_NEW)
    {
      //---------------------------------------------------
      // session was a resumed session, queue closure alert
      //---------------------------------------------------
      // !!! reduce session reference count !!!

      if(pConnStruc->ConnectionState == CONN_STATE_CONNECTED)
        SendAlert(pConnStruc,AD_CLOSE_NOTIFY,ALERT_LEVEL_WARNING);
      else    
        SendAlert(pConnStruc,AD_CLOSE_NOTIFY,ALERT_LEVEL_FATAL);
    }
    else
    {
      //---------------------------------------------------
      // session was a new session, check if resumable
      //---------------------------------------------------
      if(((pConnStruc->SessionID[0] & 0xFF) != 0) &&	// resumable
        (pConnStruc->ConnectionState == CONN_STATE_CONNECTED))
      {
        SendAlert(pConnStruc,AD_CLOSE_NOTIFY,ALERT_LEVEL_WARNING);
      // !!! reduce session reference count !!!
      }
      else						// not resumable
        SendAlert(pConnStruc,AD_CLOSE_NOTIFY,ALERT_LEVEL_FATAL);
    }  
    //-----------------------------------------------------------------
    // Try to send data from the Transmit queues as long as possible
    //-----------------------------------------------------------------
    Retcode = HSSL_XH2Tcp_Transmit(pXif2Struc, pTmpContState, pTmpReason);
    if((Retcode != HSSL_OP_OK) || (pTmpContState[0] != STATUS_CONTINUE))
    {
      FreeXH2ConnStateStruct(HMEM_CTX_REF,pXif2Struc); // free all used...
      pXif2Struc->inc_return = DEF_IRET_END;	// ended
//    DBG_PRINT("\nHSSL Ended, Mode 3");
      return(HSSL_OP_OK);
    }
    pXif2Struc->inc_return = DEF_IRET_NORMAL;	// try to send...
    return(HSSL_OP_OK);
  }
}
#endif // XH_INTF_VERSION < 300

#if XH_INTF_VERSION >= 300
/**
* Processes a step in the disconnecting procedure of a SSL/TLS connection (XH3SSL_Disconnect).
* Steps consist of sending required alerts, sending pending TX data, flushing
* buffers and releasing used resources in the interface structure.
*
* The return satus of the procedure is in the return parameter of the interface
* structure.
*
* Server side.
*
*  @param pXif3Struc Interface Structure
*  @return == 0 on success
* <br>            < 0 rejected
*/
extern "C" int XH3SSL_Disconnect(struct dsd_hl_ssl_s_3 * pXif3Struc)
{
  int Retcode;
  CONNSTRU * pConnStruc;

  int pTmpContState[1];
  int pTmpReason[1];

  HMEM_CTX_DEF1;

  //-----------------------------------------------------
  // check parameters
  //-----------------------------------------------------
  if((pXif3Struc == NULL) || (pXif3Struc->ac_ext == NULL) ||
     ((pConnStruc = ((XHCONNSTRUC *) pXif3Struc->ac_ext)->pConnStruc) == NULL))
    return(HSSL_NULL_PTR);

  LOAD_HMEM_CTX_PTR(CONN_pMemCtx(pConnStruc));
  //-----------------------------------------------------
  // check if this is a TX-Continuation (Alert/Data etc.)
  //-----------------------------------------------------
  if(((XHCONNSTRUC *) pXif3Struc->ac_ext)->XHConnState == XH_STATE_CLOSING)
  {
    if((pXif3Struc->boc_eof_server != FALSE) ||
       ((pConnStruc->pPriorityTxQueueHead == NULL) && // no more data to send
        (pConnStruc->pApplicationTxQueueHead == NULL)))
    {
      FreeXH3ConnStateStruct(HMEM_CTX_REF,pXif3Struc); // free all used...
      pXif3Struc->inc_return = DEF_IRET_END;		// ended
//    DBG_PRINT("\nHSSL Ended, Mode 0");
      return(HSSL_OP_OK);
    }
    //-----------------------------------------------
    // Continue sending data...
    //-----------------------------------------------
    Retcode = HSSL_XH3Tcp_Transmit(pXif3Struc, pTmpContState, pTmpReason);
    if((Retcode != HSSL_OP_OK) ||		// error during send
       (pTmpContState[0] != STATUS_CONTINUE))	// cannot continue
    {
      FreeXH3ConnStateStruct(HMEM_CTX_REF,pXif3Struc); // free all used...
      pXif3Struc->inc_return = DEF_IRET_END;	// ended
//    DBG_PRINT("\nHSSL Ended, Mode 1");
      return(HSSL_OP_OK);
    }
    pXif3Struc->inc_return = DEF_IRET_NORMAL;	// try to send...
    return(HSSL_OP_OK);
  }
  else						// is shutdown initiate
  {
    if(pXif3Struc->boc_eof_server != FALSE)	// no socket for send data
    {
      FreeXH3ConnStateStruct(HMEM_CTX_REF,pXif3Struc);// free all used...
      pXif3Struc->inc_return = DEF_IRET_END;	// ended
//    DBG_PRINT("\nHSSL Ended, Mode 2\n");
      return(HSSL_OP_OK);
    }
    //--------------------------------------------------------
    // Socket is still valid
    //--------------------------------------------------------
    ((XHCONNSTRUC *) pXif3Struc->ac_ext)->XHConnState = XH_STATE_CLOSING; // set next state
    //-----------------------------------------------------
    // Check if session was a new or a resumed session
    //-----------------------------------------------------
    if(pConnStruc->CacheMode > CACHE_SESSION_TYPE_NEW)
    {
      //---------------------------------------------------
      // session was a resumed session, queue closure alert
      //---------------------------------------------------
      // !!! reduce session reference count !!!

      if(pConnStruc->ConnectionState == CONN_STATE_CONNECTED)
        SendAlert(pConnStruc,AD_CLOSE_NOTIFY,ALERT_LEVEL_WARNING);
      else    
        SendAlert(pConnStruc,AD_CLOSE_NOTIFY,ALERT_LEVEL_FATAL);
    }
    else
    {
      //---------------------------------------------------
      // session was a new session, check if resumable
      //---------------------------------------------------
      if(((pConnStruc->SessionID[0] & 0xFF) != 0) &&	// resumable
        (pConnStruc->ConnectionState == CONN_STATE_CONNECTED))
      {
        SendAlert(pConnStruc,AD_CLOSE_NOTIFY,ALERT_LEVEL_WARNING);
      // !!! reduce session reference count !!!
      }
      else						// not resumable
        SendAlert(pConnStruc,AD_CLOSE_NOTIFY,ALERT_LEVEL_FATAL);
    }  
    //-----------------------------------------------------------------
    // Try to send data from the Transmit queues as long as possible
    //-----------------------------------------------------------------
    Retcode = HSSL_XH3Tcp_Transmit(pXif3Struc, pTmpContState, pTmpReason);
    if((Retcode != HSSL_OP_OK) || (pTmpContState[0] != STATUS_CONTINUE))
    {
      FreeXH3ConnStateStruct(HMEM_CTX_REF,pXif3Struc); // free all used...
      pXif3Struc->inc_return = DEF_IRET_END;	// ended
//    DBG_PRINT("\nHSSL Ended, Mode 3");
      return(HSSL_OP_OK);
    }
    pXif3Struc->inc_return = DEF_IRET_NORMAL;	// try to send...
    return(HSSL_OP_OK);
  }
}
#endif // XH_INTF_VERSION >= 300

/**
* Processes a step in the disconnecting procedure of a SSL/TLS connection (XHCLSSL_Disconnect).
* Steps consist of sending required alerts, sending pending TX data, flushing
* buffers and releasing used resources in the interface structure.
*
* The return satus of the procedure is in the return parameter of the interface
* structure.
*
* Client side.
*
*  @param pXifClStruc Interface Structure
*  @return == 0 on success
* <br>            < 0 rejected
*/
extern "C" int XHCLSSL_Disconnect(struct dsd_hl_ssl_c_1 * pXifClStruc)
{
  int Retcode;
  CONNSTRU * pConnStruc;

  int pTmpContState[1];
  int pTmpReason[1];

  HMEM_CTX_DEF1;

  //-----------------------------------------------------
  // check parameters
  //-----------------------------------------------------
  if((pXifClStruc == NULL) || (pXifClStruc->vpc_ext == NULL) ||
     ((pConnStruc = ((XHCONNSTRUC *) pXifClStruc->vpc_ext)->pConnStruc) == NULL))
    return(HSSL_NULL_PTR);

  LOAD_HMEM_CTX_PTR(CONN_pMemCtx(pConnStruc));
  //-----------------------------------------------------
  // check if this is a TX-Continuation (Alert/Data etc.)
  //-----------------------------------------------------
  if(((XHCONNSTRUC *) pXifClStruc->vpc_ext)->XHConnState == XH_STATE_CLOSING)
  {
    if((pXifClStruc->boc_eof_server != 0) ||
       ((pConnStruc->pPriorityTxQueueHead == NULL) && // no more data to send
        (pConnStruc->pApplicationTxQueueHead == NULL)))
    {
      CleanupCaches(HMEM_CTX_REF,pConnStruc,0);

      FreeXHCLConnStateStruct(HMEM_CTX_REF,pXifClStruc); // free all used...
      pXifClStruc->inc_return = DEF_IRET_END;		// ended
//    DBG_PRINT("\nHSSL Ended, Mode 0");
      return(HSSL_OP_OK);
    }
    //-----------------------------------------------
    // Continue sending data...
    //-----------------------------------------------
    Retcode = HSSL_XHCLTcp_Transmit(pXifClStruc, pTmpContState, pTmpReason);
    if((Retcode != HSSL_OP_OK) ||		// error during send
       (pTmpContState[0] != STATUS_CONTINUE))	// cannot continue
    {
      CleanupCaches(HMEM_CTX_REF,pConnStruc,0);

      FreeXHCLConnStateStruct(HMEM_CTX_REF,pXifClStruc); // free all used...
      pXifClStruc->inc_return = DEF_IRET_END;	// ended
//    DBG_PRINT("\nHSSL Ended, Mode 1");
      return(HSSL_OP_OK);
    }
    pXifClStruc->inc_return = DEF_IRET_NORMAL;	// try to send...
    return(HSSL_OP_OK);
  }
  else						// is shutdown initiate
  {
    if(pXifClStruc->boc_eof_server != 0)	// no socket for send data
    {
      CleanupCaches(HMEM_CTX_REF,pConnStruc,0);

      FreeXHCLConnStateStruct(HMEM_CTX_REF,pXifClStruc);// free all used...
      pXifClStruc->inc_return = DEF_IRET_END;	// ended
//    DBG_PRINT("\nHSSL Ended, Mode 2\n");
      return(HSSL_OP_OK);
    }
    //--------------------------------------------------------
    // Socket is still valid
    //--------------------------------------------------------
    ((XHCONNSTRUC *) pXifClStruc->vpc_ext)->XHConnState = XH_STATE_CLOSING; // set next state
    //-----------------------------------------------------
    // Check if session was a new or a resumed session
    //-----------------------------------------------------
    if(pConnStruc->CacheMode > CACHE_SESSION_TYPE_NEW)
    {
      //---------------------------------------------------
      // session was a resumed session, queue closure alert
      //---------------------------------------------------
      // !!! reduce session reference count !!!

      if(pConnStruc->ConnectionState == CONN_STATE_CONNECTED)
        SendAlert(pConnStruc,AD_CLOSE_NOTIFY,ALERT_LEVEL_WARNING);
      else    
        SendAlert(pConnStruc,AD_CLOSE_NOTIFY,ALERT_LEVEL_FATAL);
    }
    else
    {
      //---------------------------------------------------
      // session was a new session, check if resumable
      //---------------------------------------------------
      if(((pConnStruc->SessionID[0] & 0xFF) != 0) &&	// resumable
        (pConnStruc->ConnectionState == CONN_STATE_CONNECTED))
      {
        SendAlert(pConnStruc,AD_CLOSE_NOTIFY,ALERT_LEVEL_WARNING);
      // !!! reduce session reference count !!!
      }
      else						// not resumable
        SendAlert(pConnStruc,AD_CLOSE_NOTIFY,ALERT_LEVEL_FATAL);
    }  
    //-----------------------------------------------------------------
    // Try to send data from the Transmit queues as long as possible
    //-----------------------------------------------------------------
    Retcode = HSSL_XHCLTcp_Transmit(pXifClStruc, pTmpContState, pTmpReason);
    if((Retcode != HSSL_OP_OK) || (pTmpContState[0] != STATUS_CONTINUE))
    {
      CleanupCaches(HMEM_CTX_REF,pConnStruc,0);

      FreeXHCLConnStateStruct(HMEM_CTX_REF,pXifClStruc); // free all used...
      pXifClStruc->inc_return = DEF_IRET_END;		// ended
//    DBG_PRINT("\nHSSL Ended, Mode 3");
      return(HSSL_OP_OK);
    }
    pXifClStruc->inc_return = DEF_IRET_NORMAL;		// try to send...
    return(HSSL_OP_OK);
  }
//  pXifStruc->inc_return = HSSL_NEWCONN_STATE_ERR;	// ended
//  return(HSSL_OP_OK);
}
#endif // XH_INTERFACE

//()()()()()()()()()()()()()()()()()()()()()()()()()())()()()()()()
//
// Initialization routines
//
//()()()()()()()()()()()()()()()()()()()()()()()()()())()()()()()()

/**
* Checks given TreeEntry
* list and count for presence of at least one Time-Valid
* Endcertficate/Selfsigned Root certificate (CheckValidEndcertsForServer).
*
* No parameters checked.
*
*  @param pTreeStruc Certificate tree structure
*  @param pCNIndexArray Array with certs CN-Indices
*  @param CertsCount Number of certificates
*  @param pValidCnt Number of VALID certificates
*
*  @return HSSLOP_OK o.k., else error occured
*/
static  int  CheckValidEndcertsForServer(HMEM_CTX_DEF
		CTREESTR * pTreeStruc,
		int* pCNIndexArray, int CertsCount, int* pValidCnt)
{
  int Retcode;
  int CertCNIndex,Index;

  int pTmpResult[1];

  pValidCnt[0] = 0;				// none valid yet...
  //-----------------------------------------------------
  // Check the Certificates for Time Validity, one by one
  //-----------------------------------------------------
  Index = 0;
  while(Index < CertsCount)
  {
    CertCNIndex = pCNIndexArray[Index];

    Retcode = VerifyLclCertChain(HMEM_CTX_REF1 pTreeStruc,CertCNIndex,0x1F,pTmpResult);
    if(Retcode != ASN1_OP_OK)
      return(Retcode);

    if(pTmpResult[0] == 0)			// is valid...
      pValidCnt[0] ++;

    Index++;
  }
  return(HSSL_OP_OK);
}

/**
* Checks given TreeEntry
* list and count for correctness of certificate chain signature
* for end certficate/selfsigned root certificates (CheckEndcertsChain).
*
* No parameters checked.
*
*  @param pTreeStruc Certificate tree structure
*  @param pCNIndexArray Array with certs CN-indices
*  @param CertsCount Number of certificates
*
*  @return  HSSLOP_OK o.k., else error occured
*/
static  int  CheckEndcertsChain(HMEM_CTX_DEF
		CTREESTR * pTreeStruc,
		int* pCNIndexArray, int CertsCount)
{
  int Retcode;
  int CertCNIndex,Index;

  int pTmpResult[1];

  //-------------------------------------------------------------
  // Check the Certificates for chain signature match, one by one
  //-------------------------------------------------------------
  if(CertsCount == 0)			// no certificates, is o.k.
    return(HSSL_OP_OK);

  Index = 0;
  while(Index < CertsCount)
  {
    CertCNIndex = pCNIndexArray[Index];

    Retcode = VerifyLclCertChain(HMEM_CTX_REF1 pTreeStruc,CertCNIndex,0x30,pTmpResult);
    if(Retcode != ASN1_OP_OK)
      return(Retcode);

    if(pTmpResult[0] != 0)			// is NOT valid...
      return(HSSL_CERTMSG_CERT_CHAIN_REJECT);

    Index++;
  }
  return(HSSL_OP_OK);
}

/**
* Checks all end certificates
* for correctness of certificate chain signature of the
* end certficate/selfsigned root certificates (CheckAllEndcertsChains).
*
* No parameters checked.
*
*  @param pCertTreeStruc Certificate tree structure
*
*  @return  HSSLOP_OK o.k., else error occured
*/
static  int  CheckAllEndcertsChains(HMEM_CTX_DEF
					       CTREESTR * pCertTreeStruc)
{
  int Retcode;

  // Check RSA Endcertificates
  if((Retcode = CheckEndcertsChain(HMEM_CTX_REF1
			      pCertTreeStruc,
	                      pCertTreeStruc->EndRsaIndexArray,
                              pCertTreeStruc->EndRsaCount)) != HSSL_OP_OK)
    return(Retcode);

  // Check RSA Rootcertificates
  if((Retcode = CheckEndcertsChain(HMEM_CTX_REF1
			      pCertTreeStruc,
	                      pCertTreeStruc->RootEndRsaIndexArray,
                              pCertTreeStruc->RootEndRsaCount)) != HSSL_OP_OK)
    return(Retcode);

  // Check DSS Endcertificates
  if((Retcode = CheckEndcertsChain(HMEM_CTX_REF1
			      pCertTreeStruc,
	                      pCertTreeStruc->EndDssIndexArray,
                              pCertTreeStruc->EndDssCount)) != HSSL_OP_OK)
    return(Retcode);

  // Check DSS Rootcertificates
  if((Retcode = CheckEndcertsChain(HMEM_CTX_REF1
			      pCertTreeStruc,
	                      pCertTreeStruc->RootEndDssIndexArray,
                              pCertTreeStruc->RootEndDssCount)) != HSSL_OP_OK)
    return(Retcode);

  // Check DH-RSA signed Endcertificates
  if((Retcode = CheckEndcertsChain(HMEM_CTX_REF1
			      pCertTreeStruc,
	                      pCertTreeStruc->EndDhRsaIndexArray,
                              pCertTreeStruc->EndDhRsaCount)) != HSSL_OP_OK)
    return(Retcode);

  // Check DH-DSS signed Endcertificates
  if((Retcode = CheckEndcertsChain(HMEM_CTX_REF1
			      pCertTreeStruc,
	                      pCertTreeStruc->EndDhDssIndexArray,
                              pCertTreeStruc->EndDhDssCount)) != HSSL_OP_OK)
    return(Retcode);

  return(HSSL_OP_OK);
}

/**
* Removes all
* ciphersuites that have no associated or only invalid endcertificates
* from the global ciphersuites list (RemoveCiphersuitesWithoutCert).
*
*  @param pCfgStruc Config to use
*
*  @return  HSSLOP_OK o.k., else error occured
*/
static  int  RemoveCiphersuitesWithoutCert(HMEM_CTX_DEF
				CFG_STRU * pCfgStruc)
{
  int Retcode;
  int Index;
  int CipherSuite;
  int KeyExchgMode;

  int RsaCertValid = -1;
  int DheDssCertValid = -1;
  int DhRsaCertValid = -1;
  int DhDssCertValid = -1;

  int SrcListIndex = 0;
  int SrcCipherSuitesCnt;
  int DstListIndex = 2;
  int DstCipherSuitesCnt = 0;

  char* pCiphSuitesList;
  char* pTmpCiphSuitesList;

  CTREESTR * pCertTreeStruc;

  int pTmpCnt[1];
  //------------------------------------------------------
  // Get List base and count of entries, allocate buffer
  //------------------------------------------------------
  pCertTreeStruc  = pCfgStruc->pCertTreeStruc;  
  pCiphSuitesList = pCfgStruc->CipherSuitesList;

  BIGchar2word(pCiphSuitesList,SrcCipherSuitesCnt,SrcListIndex);
  SrcCipherSuitesCnt = SrcCipherSuitesCnt/2;	// get entries cnt + hdr!
  pTmpCiphSuitesList = BIT8_ARRAY_ALLOC(HMEM_CTX_REF,
				        (SrcCipherSuitesCnt+1)*2);
  if(pTmpCiphSuitesList == NULL)
    return(HSSL_REMOVE_SUITES_ALLOC_ERR);
  //------------------------------------------------------
  // Scan the cipher suites
  //------------------------------------------------------
  do
  {
    //------------------------------------------------------
    // Get Cipher suite to check, get the key exchange algor
    //------------------------------------------------------
    BIGchar2word(pCiphSuitesList,CipherSuite,SrcListIndex);
    Index = GetCipherParamsIndex((unsigned short) CipherSuite);
    if(Index == -1)				// should not happen !!
      return(HSSL_REMOVE_SUITES_INVKEYEX_ERR);
//  Index = (CipherSuite & 0xFF) * CST_ENTRY_SIZE; // to start of params

    KeyExchgMode = CipherParams[Index + CST_KeyExchgMode];
    switch(KeyExchgMode)
    {
      //-------------------------------------------------------------------
      // Key exchange type RSA/DHE-RSA, check RSA endcerts/selfsigned roots
      //-------------------------------------------------------------------
      case KEY_EXCHANGE_RSA:
      case KEY_EXCHANGE_DHE_RSA:
      case KEY_EXCHANGE_ECDHE_RSA:
        if(RsaCertValid < 0)			// do the Checks now...
        {
          RsaCertValid = 0;			// assume none available...

          if((pCertTreeStruc->EndRsaCount != 0) ||
             (pCertTreeStruc->RootEndRsaCount != 0))
          {
            if(pCertTreeStruc->EndRsaCount != 0)
            {
              if((Retcode = CheckValidEndcertsForServer(HMEM_CTX_REF1
			      pCertTreeStruc,
	                      pCertTreeStruc->EndRsaIndexArray,
                              pCertTreeStruc->EndRsaCount,
                              pTmpCnt)) != HSSL_OP_OK)
              {
                FREE_ARRAY(HMEM_CTX_REF,pTmpCiphSuitesList);
                return(Retcode);
              }
              RsaCertValid += pTmpCnt[0];
            }    
            if(pCertTreeStruc->RootEndRsaCount != 0)
            {
              if((Retcode = CheckValidEndcertsForServer(HMEM_CTX_REF1
			      pCertTreeStruc,
	                      pCertTreeStruc->RootEndRsaIndexArray,
                              pCertTreeStruc->RootEndRsaCount,
                              pTmpCnt)) != HSSL_OP_OK)
              {
                FREE_ARRAY(HMEM_CTX_REF,pTmpCiphSuitesList);
                return(Retcode);
              }
              RsaCertValid += pTmpCnt[0];
            }                         
          }
        }
        //------------------------------------------------------
        // If there are valid RSA certs, add the ciphersuite
        //------------------------------------------------------
        if(RsaCertValid > 0)
        {
            BIGword2char(CipherSuite,pTmpCiphSuitesList,DstListIndex);
            DstCipherSuitesCnt++;
        }
        break;

      //------------------------------------------------------------------
      // Key exchange type is DHE-DSS, check DSS endcerts/selfsigned roots
      //------------------------------------------------------------------
      case KEY_EXCHANGE_DHE_DSS:
        if(DheDssCertValid < 0)			// do the Checks now...
        {
          DheDssCertValid = 0;			// assume none available...

          if((pCertTreeStruc->EndDssCount != 0) ||
             (pCertTreeStruc->RootEndDssCount != 0))
          {
            if(pCertTreeStruc->EndDssCount != 0)
            {
              if((Retcode = CheckValidEndcertsForServer(HMEM_CTX_REF1
			      pCertTreeStruc,
	                      pCertTreeStruc->EndDssIndexArray,
                              pCertTreeStruc->EndDssCount,
                              pTmpCnt)) != HSSL_OP_OK)
              {
                FREE_ARRAY(HMEM_CTX_REF,pTmpCiphSuitesList);
                return(Retcode);
              }
              DheDssCertValid += pTmpCnt[0];
            }                        
            if(pCertTreeStruc->RootEndDssCount != 0)
            {
              if((Retcode = CheckValidEndcertsForServer(HMEM_CTX_REF1
			      pCertTreeStruc,
	                      pCertTreeStruc->RootEndDssIndexArray,
                              pCertTreeStruc->RootEndDssCount,
                              pTmpCnt)) != HSSL_OP_OK)
              {
                FREE_ARRAY(HMEM_CTX_REF,pTmpCiphSuitesList);
                return(Retcode);
              }
              DheDssCertValid += pTmpCnt[0];
            }                        
          }                        
        }
        //------------------------------------------------------
        // If there are valid DSS certs, add the ciphersuite
        //------------------------------------------------------
        if(DheDssCertValid > 0)
        {
          BIGword2char(CipherSuite,pTmpCiphSuitesList,DstListIndex);
          DstCipherSuitesCnt++;
        }
        break;

      //---------------------------------------------------
      // Key exchange type is DH-RSA, check RSA-DH endcerts
      //---------------------------------------------------
      case KEY_EXCHANGE_DH_RSA:
        if(DhRsaCertValid < 0)
        {
          DhRsaCertValid = 0;			// assume non present

          if(pCertTreeStruc->EndDhRsaCount != 0)
          {
            if((Retcode = CheckValidEndcertsForServer(HMEM_CTX_REF1
			    pCertTreeStruc,
	                    pCertTreeStruc->EndDhRsaIndexArray,
                            pCertTreeStruc->EndDhRsaCount,
                            pTmpCnt)) != HSSL_OP_OK)
            {
              FREE_ARRAY(HMEM_CTX_REF,pTmpCiphSuitesList);
              return(Retcode);
            }
            DhRsaCertValid += pTmpCnt[0];
          }
        }
        //------------------------------------------------------
        // If there are valid DH-RSA certs, add the ciphersuite
        //------------------------------------------------------
        if(DhRsaCertValid > 0)
        {
          BIGword2char(CipherSuite,pTmpCiphSuitesList,DstListIndex);
          DstCipherSuitesCnt++;
        }
        break;

      //---------------------------------------------------
      // Key exchange type is DH-DSS, check DSS-DH endcerts
      //---------------------------------------------------
      case KEY_EXCHANGE_DH_DSS:
        if(DhDssCertValid < 0)
        {
          DhDssCertValid = 0;			// assume non present

          if(pCertTreeStruc->EndDhDssCount != 0)
          {
            if((Retcode = CheckValidEndcertsForServer(HMEM_CTX_REF1
			    pCertTreeStruc,
	                    pCertTreeStruc->EndDhDssIndexArray,
                            pCertTreeStruc->EndDhDssCount,
                            pTmpCnt)) != HSSL_OP_OK)
            {
              FREE_ARRAY(HMEM_CTX_REF,pTmpCiphSuitesList);
              return(Retcode);
            }
            DhDssCertValid += pTmpCnt[0];
          }
        }
        //------------------------------------------------------
        // If there are valid DH-DSS certs, add the ciphersuite
        //------------------------------------------------------
        if(DhDssCertValid > 0)
        {
          BIGword2char(CipherSuite,pTmpCiphSuitesList,DstListIndex);
          DstCipherSuitesCnt++;
        }
        break;

      default:
        FREE_ARRAY(HMEM_CTX_REF,pTmpCiphSuitesList);
        return(HSSL_REMOVE_SUITES_INVKEYEX_ERR);
    } // switch
    SrcCipherSuitesCnt--;
  }while(SrcCipherSuitesCnt != 0);
  //--------------------------------------------------------
  // check if ciphersuites survived ...
  //--------------------------------------------------------
  if(DstCipherSuitesCnt == 0)
  {
     FREE_ARRAY(HMEM_CTX_REF,pTmpCiphSuitesList);
     return(HSSL_NO_CIPHERSUITE_CERTS);
  }
  DstCipherSuitesCnt *= 2;			 // get length excl. hdr
  BIGword2charn(DstCipherSuitesCnt,pTmpCiphSuitesList,0); // set count
  memcpy(pCiphSuitesList+0,pTmpCiphSuitesList+0,DstCipherSuitesCnt+2);
  FREE_ARRAY(HMEM_CTX_REF,pTmpCiphSuitesList);
  return(HSSL_OP_OK);
}

/**
* Initializes the SSL/TLS module before use (HSSL_PrivExtInit).
*<ul>
* <li> Outputs version information of the TLS/SSL library module to console 
*     (if any).
* <li> Initializes the pseudo random generator from system data.
* <li> Generates plain password data from password data given in the 
*     initialization structure, if needed.
* <li> Generates a configuration structure and initializes it using 
*     configuration data in the initialization structure.
* <li> Extracts OCSP data from extended configuration data and puts them to 
*     configuration structure.
* <li> Allocates the connection structure pointer array for this instance (not
*     for WebSecureProxy C interface).
* <li> Builds certificate tree from given certificate database data in 
*     initialization structure and/or external certificate storage (Windows 
*     only).
* <li> Checks if at least one usable certificate with private key is present
*     (Server side only).
* <li> Builds the certificate root's distinguished names list (Needed for client
*     authentication requests during the TLS/SSL handshake phase when client 
*     authentication is enabled).
* <li> Removes configured cipher suites, that require a private key, but can't 
*     get a valid one from certificates (Server side only).
*</ul>
*
* The allocated and filled configuration structure is either stored back to the
* initialization structure (for the WebSecureProxy interface) or stored as 
* instance variable for the current protocol state machine instance.
*
* This function is public, but not supposed to be called from outside.
*
*
*  @param pIniStruc Structure with parameters
*  @return HSSL_OP_OK on success, error code otherwise
*/
extern "C" int  HSSL_PrivExtInit(HMEM_CTX_DEF HSISTR * pIniStruc)
{
  int Retcode;

  int CdbNeededFlag = 1;
  int CdbExtFlag = 0;
  int CertsCount = 0;
  int ExtCertsCount = 0;
  int CfgType;
  int CfgPwdFtype;
  int CertsType;
  int CertsPwdFtype;

  char* pDecodedConfPwdBuf = NULL;
  char* pDecodedCertsPwdBuf = NULL;
  char* pVersionBuf = NULL;

  char* ppTmpBuf[1];
  char* pConfPwdBuf[1];
  char* pCertsPwdBuf[1];
  char* pTmpExtPwdBuf[1];
  char* pTmpExtCertsBuf[1] = {NULL};
  char* pTmpExtCfgBuf[1];

//  BIT8ARRAY(ShaDigestBuf,SHA_DIGEST_LEN);

  int pTmpLen[1];
  int pConfPwdLen[1];
  int pCertsPwdLen[1];

  int pTmpCnt[1];
  int pTmpExtPwdLen[1];
  int pTmpExtCertsLen[1];
  int pTmpExtCfgLen[1];

  IDATPARR* pCertsDatArrayDesc = NULL;
  IDATPARR* pExtCertsDatArrayDesc = NULL;
  IDATPARR* pTmpCertsDatArrayDesc[1];
  IDATPARR* pTmpRDNDatArrayDesc[1];

  CTREESTR * pCertTreeStruc;
  CTREESTR * pTmpTreeStruc[1];
  CFG_STRU * pCfgStruc = NULL;
  CFG_STRU * ppCfgStruc[1];
  //----------------------------------------------------
  // check if Interface Already initialized, if so, o.k.
  //----------------------------------------------------

#if !defined XH_INTERFACE
  if(InitializedFlag != 0)
    return(HSSL_OP_OK);
#endif

  //==============================================================
  //
  // Output the Version String to console...
  // Also initialize Pseudo Random generator with true random data
  //
  //==============================================================
#if defined XH_INTERFACE
  if(VersionShow < 1)			// No output any longer....
    VersionShow = 1;
  if(VersionShow == 0)
  {
#endif
  //--------------------------------------------------------------
  // Show Version on console
  //--------------------------------------------------------------
  if((Retcode = HSSL_GetVersionInfo(pTmpExtCfgLen,NULL,pTmpCnt)) != HSSL_OP_OK)
    return(Retcode);

  if((pVersionBuf = BIT8_ARRAY_ALLOC(HMEM_CTX_REF,
				     pTmpCnt[0])) == NULL)
    return(HSSL_ALLOC_ERR);

  if((Retcode = HSSL_GetVersionInfo(pTmpExtCfgLen,pVersionBuf,pTmpCnt)) != HSSL_OP_OK)
  {
    FREE_CARRAY(HMEM_CTX_REF,pVersionBuf);
    return(Retcode);		
  }
  printf("\n%s\n", pVersionBuf);
  printf("Using HOB Encryption library v%s\n", chrg_encry2_version_string);

  FREE_CARRAY(HMEM_CTX_REF,pVersionBuf);

#if defined XH_INTERFACE
  VersionShow = 1;
  }
#endif

#if !defined ALT_SEEDING_SOURCE || !defined XH_INTERFACE || defined XH_DUMMY
  //--------------------------------------------------------------
  // Initialize Pseudo Random Generator with true random data now
  //--------------------------------------------------------------
  Retcode = SecDrbgInit(HMEM_CTX_REF);
  if(Retcode <= 0)
  {
#if !defined XH_INTERFACE
    printf("SECDRBG: ERROR - Random Generator not seeded");
    if(Retcode < 0)
      printf(", data fetch failed, Retcode: %d\n",Retcode);
    else
      printf(", no data available!");
#else
    PrintAux(HMEM_CTX_REF1 "SECDRBG: ERROR - Random Generator not seeded,");
    if(Retcode < 0)
      PrintAux(HMEM_CTX_REF1 " data fetch failed, Retcode: %d\n",Retcode);
    else
      PrintAux(HMEM_CTX_REF1 " no data available!\n");
#endif
  }
  else
#if defined XH_INTERFACE
  if(VersionShow <= 1)
  {
#endif
#if !defined XH_INTERFACE
    printf("SECDRBG: Seed o.k.\n");
#else
    PrintAux(HMEM_CTX_REF1 "SECDRBG: Seed o.k.\n");
#endif

#if defined XH_INTERFACE
    VersionShow = 2;
  }
#endif
#else  // !defined ALT_SEEDING_SOURCE || !defined XH_INTERFACE || defined XH_DUMMY
#if defined XH_INTERFACE
  if(VersionShow <= 1)
  {
    VersionShow = 2;
  }
#endif  // XH_INTERFACE
#endif  // !defined ALT_SEEDING_SOURCE || !defined XH_INTERFACE || defined XH_DUMMY

  //-------------------------------------------------
  // Set Entity related variables
  //-------------------------------------------------
  if((pIniStruc->Entity & ENTITY_BIT_MASK) == SERVER_ENTITY)
  {
    CfgType	  = FILE_TYPE_SRVR_CFG;
    CfgPwdFtype   = FILE_TYPE_SRVR_PWD;
    CertsType	  = FILE_TYPE_SRVR_CERT;
    CertsPwdFtype = FILE_TYPE_SRVR_CERT_PWD;
  }
  else
  {
    CfgType	  = FILE_TYPE_CLNT_CFG;
    CfgPwdFtype   = FILE_TYPE_CLNT_PWD;
    CertsType	  = FILE_TYPE_CLNT_CERT;
    CertsPwdFtype = FILE_TYPE_CLNT_CERT_PWD;
  }
  //-------------------------------------------------
  // Decode the password(s) if required
  //-------------------------------------------------
  pConfPwdBuf[0]  = pIniStruc->pCfgPwdBuf;
  pConfPwdLen[0]  = pIniStruc->CfgPwdLen;
  pCertsPwdBuf[0] = pIniStruc->pCertPwdBuf;
  pCertsPwdLen[0] = pIniStruc->CertPwdLen;

  if(pIniStruc->CfgPwdType != 0)	// from file, decrypt
  {
    if((Retcode = DecodePasswdData(HMEM_CTX_REF1 
                                   pIniStruc->pCfgPwdBuf,
                                   0,
                                   FILE_HEADER_LEN,
                                   pIniStruc->pCfgPwdBuf,
                                   FILE_HEADER_LEN,
                                   pIniStruc->CfgPwdLen-FILE_HEADER_LEN,
                                   CfgPwdFtype,
                                   pConfPwdBuf,
                                   pConfPwdLen)) != 0)
    {
      return(HSSL_CFG_PWD_DECODE_FAILED);
    }
    pDecodedConfPwdBuf = pConfPwdBuf[0];
  }

  if(pIniStruc->CertPwdType != 0)	// from file / duplicate
  {
    if(pIniStruc->CertPwdType > 0)	// from file, decrypt
    {
      if((Retcode = DecodePasswdData(HMEM_CTX_REF1 
                                     pIniStruc->pCertPwdBuf,
                                     0,
                                     FILE_HEADER_LEN,
                                     pIniStruc->pCertPwdBuf,
                                     FILE_HEADER_LEN,
                                     pIniStruc->CertPwdLen-FILE_HEADER_LEN,
                                     CertsPwdFtype,
                                     pCertsPwdBuf,
                                     pCertsPwdLen)) != 0)
      {
        FREE_ARRAY(HMEM_CTX_REF,pDecodedConfPwdBuf);
        return(HSSL_CERTS_PWD_DECODE_FAILED);
      }
      pDecodedCertsPwdBuf = pCertsPwdBuf[0];
    }
    else			// use same as Configuration Password
    {
      pCertsPwdBuf[0]  = pConfPwdBuf[0];
      pCertsPwdLen[0]  = pConfPwdLen[0];
    }
  }
  //---------------------------------------------------------------------
  // Extract the configuration data to structure, allocates the structure
  //---------------------------------------------------------------------
  if((Retcode = ExtractConfigDataEx(HMEM_CTX_REF1 pIniStruc->pCfgDataBuf,0,pIniStruc->CfgDataLen,pConfPwdBuf[0],0,pConfPwdLen[0],CfgType,ppCfgStruc,pTmpExtCfgBuf,pTmpExtCfgLen,NULL)) != 0)
  {
    ClearFreeBit8Array(HMEM_CTX_REF1 pDecodedConfPwdBuf,pConfPwdLen[0]);
    ClearFreeBit8Array(HMEM_CTX_REF1 pDecodedCertsPwdBuf,pCertsPwdLen[0]);
    if(Retcode == -7)			// CHECK THAT !!!!!!!!!!!!!!!!!!!!
      return(HSSL_CFG_PWD_ERROR);
    return(HSSL_CFG_READ_FAILED);
  }
  Retcode = m_filter_cipher_list(ppCfgStruc[0]->CipherSuitesList);
  if(Retcode < 1){
    return HSSL_CFG_NO_SUPPORTED_CIPHER;
  }
  pCfgStruc = ppCfgStruc[0];
  pCfgStruc->boc_ecc_configured = ms_uses_ecc(pCfgStruc->CipherSuitesList);
  //-------------------------------------------------------------
  // Save additional Flags from 'Entity' input, check if
  // this is a Server, and if so, check if client certificates shall
  // be requested if not yet so
  //-------------------------------------------------------------
  pCfgStruc->Flags = pIniStruc->Entity & (~ENTITY_BIT_MASK);

  if((pIniStruc->Entity & ENTITY_BIT_MASK) == SERVER_ENTITY)
  {
    if((pCfgStruc->ProtFlags & CLNT_AUTH_BIT_MASK) == 0)
    {
      if((pCfgStruc->Flags & SPC_CFG_SRVR_FETCH_CERTS_FLAG) != 0)
      {
        pCfgStruc->ProtFlags |= SRVR_REQ_CERT_IF_AVAIL_BIT_MASK;
      }
    }
  }
  if((pCfgStruc->ProtFlags & SRVR_REQ_CERT_IF_AVAIL_BIT_MASK) != 0)
  {
    pCfgStruc->ProtFlags |= CLNT_AUTH_BIT_MASK;	// do AUTH (Server)
  }
  //-------------------------------------------------------------
  // Check if Compression switch off force bit is set and this is
  // a Client, and if so, disable compression (set method 0x00, none)
  //-------------------------------------------------------------
  if((pIniStruc->Entity & ENTITY_BIT_MASK) == CLIENT_ENTITY)
  {
    if((pCfgStruc->Flags & SPC_CFG_CLNT_COMPRESS_OFF_FLAG) != 0)
    {
      //------------------------------------------------------------
      // Force compression off, set method length = 1, method = 0
      //------------------------------------------------------------
      pCfgStruc->CmprMethodsList[0] = 0x01;	   // length 1 byte
      pCfgStruc->CmprMethodsList[1] = COMPR_NULL; // set NO COMPRESSION
    }
  }

  pCfgStruc->pAskUserCertsCb = pIniStruc->pAskUserCertsCb;  

  pCfgStruc->InitFlags = pIniStruc->InitFlags;

  pCfgStruc->pExtConfigData   = pTmpExtCfgBuf[0];
  pCfgStruc->ExtConfigDataLen = (int) pTmpExtCfgLen[0];
  //---------------------------------------------------------------
  // Get extended config array from extended config data if present
  //---------------------------------------------------------------
  memset(pCfgStruc->ExtCfgArr,0,16);
  if(pCfgStruc->ExtConfigDataLen != 0)
  {
    Retcode = GetExtCfgDataByTag(HMEM_CTX_REF1 (int) EXTCFG_TAG_EXTCFG_ARRAY,pTmpExtCfgBuf[0],0,(int) pTmpExtCfgLen[0],ppTmpBuf,pTmpLen);
    if(Retcode != HSSL_OP_OK)
    {
      ClearFreeBit8Array(HMEM_CTX_REF1 pDecodedConfPwdBuf,pConfPwdLen[0]);
      ClearFreeBit8Array(HMEM_CTX_REF1 pDecodedCertsPwdBuf,pCertsPwdLen[0]);
      FreeCfgStruct(HMEM_CTX_REF1 pCfgStruc);		// free configuration
      return(Retcode);
    }
    if(pTmpLen[0] >= 0)
    {
      memcpy(pCfgStruc->ExtCfgArr+0,ppTmpBuf[0]+0,16);
      FREE_ARRAY(HMEM_CTX_REF,ppTmpBuf[0]);
      ppTmpBuf[0] = NULL;
      pTmpLen[0]  = 0;
    }
  }
  //---------------------------------------------------------------
  // Get the PKCS11 data if available from extended config data
  //---------------------------------------------------------------
// HERE: PKCS11 query/dll init must be inserted here
#if (defined _WIN32) && defined PKCS11
  Retcode = m_pkcs11getdllname(HMEM_CTX_REF1 pTmpExtCfgBuf[0],
			       pTmpExtCfgLen[0],pCfgStruc);
  if(Retcode != HSSL_OP_OK)
  {
    ClearFreeBit8Array(HMEM_CTX_REF1 pDecodedConfPwdBuf,pConfPwdLen[0]);
    ClearFreeBit8Array(HMEM_CTX_REF1 pDecodedCertsPwdBuf,pCertsPwdLen[0]);
    FreeCfgStruct(HMEM_CTX_REF1 pCfgStruc);		// free configuration
    return(Retcode);
  }
#endif // defined _WIN32

  //---------------------------------------------------------------
  // Get the allowed signature types for TLS 1.2
  //---------------------------------------------------------------
  if(pTmpExtCfgLen[0] > 0)
  {
    Retcode = GetExtCfgDataByTag(HMEM_CTX_REF1 (int) EXTCFG_TAG_TLS12_SIG_ALGS,pTmpExtCfgBuf[0],0,(int) pTmpExtCfgLen[0],ppTmpBuf,pTmpLen);
    if(Retcode != HSSL_OP_OK)
    {
      ClearFreeBit8Array(HMEM_CTX_REF1 pDecodedConfPwdBuf,pConfPwdLen[0]);
      ClearFreeBit8Array(HMEM_CTX_REF1 pDecodedCertsPwdBuf,pCertsPwdLen[0]);
      FreeCfgStruct(HMEM_CTX_REF1 pCfgStruc);		// free configuration
      return(Retcode);
    }
    if(pTmpLen[0] > 0)
    {
       char* aabyl_tmp_pptr[1];
       aabyl_tmp_pptr[0] = pCfgStruc->achc_tls_12_sig_algs;
       m_process_supported_sig(HMEM_CTX_REF1 ppTmpBuf[0], pTmpLen[0], 0,
          aabyl_tmp_pptr);
       pCfgStruc->achc_tls_12_sig_algs = aabyl_tmp_pptr[0];
    }
  }
  //---------------------------------------------------------------
  // Check, if CPU AES is requested
  //---------------------------------------------------------------
  if(pTmpExtCfgLen[0] > 0)
  {
    Retcode = GetExtCfgDataByTag(HMEM_CTX_REF1 (int) EXTCFG_TAG_USE_CPU_AES,pTmpExtCfgBuf[0],0,(int) pTmpExtCfgLen[0],ppTmpBuf,pTmpLen);
    if(Retcode != HSSL_OP_OK)
    {
      ClearFreeBit8Array(HMEM_CTX_REF1 pDecodedConfPwdBuf,pConfPwdLen[0]);
      ClearFreeBit8Array(HMEM_CTX_REF1 pDecodedCertsPwdBuf,pCertsPwdLen[0]);
      FreeCfgStruct(HMEM_CTX_REF1 pCfgStruc);		// free configuration
      return(Retcode);
    }
    if(pTmpLen[0] > 0)
    {
       pCfgStruc->in_use_cpu_aes = ppTmpBuf[0][0];
    }
  }
  //---------------------------------------------------------------
  // Get the OCSP data if available from extended config data
  // Check if OCSP is to be used, if so data must be present !
  //---------------------------------------------------------------
  if(pTmpExtCfgLen[0] > 0)
  {
    Retcode = GetExtCfgDataByTag(HMEM_CTX_REF1 (int) EXTCFG_TAG_OCSP_URLINF,pTmpExtCfgBuf[0],0,(int) pTmpExtCfgLen[0],ppTmpBuf,pTmpLen);
    if(Retcode != HSSL_OP_OK)
    {
      ClearFreeBit8Array(HMEM_CTX_REF1 pDecodedConfPwdBuf,pConfPwdLen[0]);
      ClearFreeBit8Array(HMEM_CTX_REF1 pDecodedCertsPwdBuf,pCertsPwdLen[0]);
      FreeCfgStruct(HMEM_CTX_REF1 pCfgStruc);		// free configuration
      return(Retcode);
    }
    if(pTmpLen[0] > 0)
    {
      pCfgStruc->pOcspUrlsBuffer = ppTmpBuf[0];
      pCfgStruc->OcspUrlsDataLen = pTmpLen[0];
    }
  }
  if((pCfgStruc->ExtConf2Flags & ENABLE_USE_OCSP_BIT_MASK) != 0)
  {
    if(pCfgStruc->OcspUrlsDataLen <= 0)
    {
      ClearFreeBit8Array(HMEM_CTX_REF1 pDecodedConfPwdBuf,pConfPwdLen[0]);
      ClearFreeBit8Array(HMEM_CTX_REF1 pDecodedCertsPwdBuf,pCertsPwdLen[0]);
      FreeCfgStruct(HMEM_CTX_REF1 pCfgStruc);		// free configuration
      return(HSSL_INIT_OCSP_DATA_MISSING);
    }
  }

  //--------------------------------------------------------------
  // Allocate the connection structures pointer array
  //--------------------------------------------------------------
#if !defined XH_INTERFACE
  int MaxConnCount = pCfgStruc->MaxConnCount;
  pConnPtrArray = (CONNSTRU **)
    ((void *) BIT8_ARRAY_CALLOC(HMEM_CTX_REF,
				1, sizeof(CONNSTRU *) * MaxConnCount));
  if(pConnPtrArray == NULL)		// allocate failed
  {
    ClearFreeBit8Array(HMEM_CTX_REF1 pDecodedConfPwdBuf,pConfPwdLen[0]);
    ClearFreeBit8Array(HMEM_CTX_REF1 pDecodedCertsPwdBuf,pCertsPwdLen[0]);
    FreeCfgStruct(pCfgStruc);			// free configuration
    return(HSSL_CONN_STRUC_ALLOC_ERR);
  }
#endif // XH_INTERFACE

  //===================================================================
  // Certificate Tree generation, somewhat VERY tricky:
  // 1. Server side: always needs a CDB file, no external store
  // 2. Client side: several different modes possible
  //    a) CDB only - certificates ,priv/nopriv key -> Cert Tree generated
  //    b) EXT only (no CDB file data specified)
  //       - no certificates for client -> NO Certificate Tree generated
  //       - certificate(s) for client  -> Cert Tree generated
  //    c) EXT and CDB (file data for CDB present)
  //       - EXT no certificate, build from CDB only    -> Cert Tree generated
  //	   - EXT with certificate(s) merge EXT with CDB -> Cert Tree generated
  //===================================================================

  //-------------------------------------------------------
  // Check if Certificate file data MUST be present
  //-------------------------------------------------------
  if((pIniStruc->Entity & ENTITY_BIT_MASK) != SERVER_ENTITY) // Client Config
  {
    if((pCfgStruc->ExtConf2Flags & CFG2_CERTS_EXT_STORE_BIT_MASK) != 0)
    {   // 0x100 = some/all certificates are in an external store
      CdbExtFlag = 1;			// ext. store available
      pCfgStruc->ExtCertsFlags |= EXTCERT_STORE_USED_BIT;

      if((pCfgStruc->ExtConf2Flags & CFG2_ADD_CERT_IN_CDB_BIT_MASK) == 0)
        // 0x200 = additional certificates are in a cdb-file
      {
        //----------------------------------------------------------
        // No CDB is really needed, but check if data are present !!
        //----------------------------------------------------------
        if((pIniStruc->pCertDataBuf == NULL) ||
           (pIniStruc->CertDataLen <= 0))
        {
          CdbNeededFlag = 0;		// no cdb-file needed
          pCfgStruc->ExtCertsFlags |= EXTCERT_NO_CBD_USED_BIT;
        }
      }
    }
  }
  //----------------------------------------------------
  // Check if an External Cert Store is available if so,
  // load and initialize the Interface
  //----------------------------------------------------
  if(CdbExtFlag != 0)			// ext. store available
  {
    Retcode = HSSL_InitExtCertLib(HMEM_CTX_REF1 pCfgStruc,NULL);
    if(Retcode != HSSL_OP_OK)
    {
#ifndef XH_INTERFACE
      FREE_ARRAY(HMEM_CTX_REF,pConnPtrArray);
#endif // XH_INTERFACE
      ClearFreeBit8Array(HMEM_CTX_REF1 pDecodedConfPwdBuf,pConfPwdLen[0]);
      ClearFreeBit8Array(HMEM_CTX_REF1 pDecodedCertsPwdBuf,pCertsPwdLen[0]);
      FreeCfgStruct(HMEM_CTX_REF1 pCfgStruc);	// free configuration
      return(Retcode);
    }
  }
  //-----------------------------------------------------------------
  // if Certificates in external storage, load from that first
  // Also Handle case of 'No client certificates'!!! (EXT public only)
  //-----------------------------------------------------------------
  if(CdbExtFlag != 0)			// ext. store available
  {
    pCfgStruc->ExtConf2Flags = (short)
      ((uint16_t) pCfgStruc->ExtConf2Flags |
       DONT_SORT_RDNS_BIT_MASK);		 // force unsorted!

    Retcode = HSSL_CreateExtStoreCertTree(HMEM_CTX_REF1 pCfgStruc->pExtCertStruc,pTmpExtCertsBuf,pTmpExtCertsLen,pTmpExtPwdBuf,pTmpExtPwdLen,NULL);
    if(Retcode >= 0)
    {
      Retcode = ExtractCertData(HMEM_CTX_REF1
                                pTmpExtCertsBuf[0],
                                0,
                                FILE_HEADER_LEN,
                                pTmpExtCertsBuf[0],
                                FILE_HEADER_LEN,
                                pTmpExtCertsLen[0]-FILE_HEADER_LEN,
                                pTmpExtPwdBuf[0],
                                0,
                                pTmpExtPwdLen[0],
                                FILE_TYPE_CLNT_CERT,
                                NULL,
                                NULL,
                                pTmpCertsDatArrayDesc,
                                NULL,
                                pTmpCnt);

      ClearFreeBit8Array(HMEM_CTX_REF1 pTmpExtPwdBuf[0],pTmpExtPwdLen[0]);
      pExtCertsDatArrayDesc = pTmpCertsDatArrayDesc[0];
      ExtCertsCount      = pTmpCnt[0];
    }
    if(Retcode < 0)
    {
      if(Retcode == HSSL_EXTCERT_NO_CLNT_CERTS)	// no priv keys, pub only
      {
        ExtCertsCount = 0;
        Retcode = 0;
      }
      else					// is a fatal error
      {
        FREE_ARRAY(HMEM_CTX_REF,pTmpExtCertsBuf[0]);
#ifndef XH_INTERFACE
        FREE_ARRAY(HMEM_CTX_REF,pConnPtrArray);
#endif // XH_INTERFACE
        ClearFreeBit8Array(HMEM_CTX_REF1 pDecodedConfPwdBuf,pConfPwdLen[0]);
        ClearFreeBit8Array(HMEM_CTX_REF1 pDecodedCertsPwdBuf,pCertsPwdLen[0]);
        FreeCfgStruct(HMEM_CTX_REF1 pCfgStruc);	// free configuration
        return(Retcode);
      }
    }
  }
  //-------------------------------------------------
  // Get the certificate library, without index table
  // and descriptive names if needed
  //-------------------------------------------------
  if(CdbNeededFlag != 0)
  {
    if((Retcode = ExtractCertData(HMEM_CTX_REF1
                                  pIniStruc->pCertDataBuf,
                                  0,
                                  FILE_HEADER_LEN,
                                  pIniStruc->pCertDataBuf,
                                  FILE_HEADER_LEN,
                                  pIniStruc->CertDataLen-FILE_HEADER_LEN,
                                  pCertsPwdBuf[0],
                                  0,
                                  pCertsPwdLen[0],
                                  CertsType,
                                  NULL,
                                  NULL,
                                  pTmpCertsDatArrayDesc,
                                  NULL,
                                  pTmpCnt)) != 0)
    {
      FREE_ARRAY(HMEM_CTX_REF,pTmpExtCertsBuf[0]);
//    FREE_CFG_STRUCT(HSSLGLIBinst, pCfgStruc);  // free configuration
#ifndef XH_INTERFACE
      FREE_ARRAY(HMEM_CTX_REF,pConnPtrArray);
#endif // XH_INTERFACE
      ClearFreeBit8Array(HMEM_CTX_REF1 pDecodedConfPwdBuf,pConfPwdLen[0]);
      ClearFreeBit8Array(HMEM_CTX_REF1 pDecodedCertsPwdBuf,pCertsPwdLen[0]);
      FreeCfgStruct(HMEM_CTX_REF1 pCfgStruc);	// free configuration
      if(Retcode == -7)				// CHECK THAT !!!!!!!!!
        return(HSSL_CERTS_PWD_ERROR);
      return(HSSL_CERT_READ_FAILED);
    }
    pCertsDatArrayDesc = pTmpCertsDatArrayDesc[0];
    CertsCount = pTmpCnt[0];
  }
  //----------------------------------------------------------------------
  // Combine Certs from External/CDB file into a single IDATPARR structure
  //----------------------------------------------------------------------
  Retcode = HSSL_OP_OK;
  for(;;)	// Error FOR
  {
    if((ExtCertsCount == 0) && (CertsCount == 0))
    {
      if((pIniStruc->Entity & ENTITY_BIT_MASK) == SERVER_ENTITY)	// Server Config
      {
        //--------------------------------------------------------
        // IS a server, Needs Certificates, but none given -> Fail
        //--------------------------------------------------------
        Retcode = HSSL_NO_SERVER_CERTS;
        break;
      }
      else
      {
        //--------------------------------------------------------
        // is a client, check if External store usable
        //--------------------------------------------------------
        if(CdbExtFlag == 0)		// NO external store -> Fail
          Retcode = HSSL_NO_CLIENT_CERTS;
        break;
      }
    }
    else
    {
      //--------------------------------------------------------
      // There ARE certificates, either from EXT And/Or from CDB
      //--------------------------------------------------------
      if((ExtCertsCount != 0) && (CertsCount != 0))	// both EXT/CDB present
      {
        if((Retcode = AllocIDATPARR_Struc(HMEM_CTX_REF1 pTmpCertsDatArrayDesc,ExtCertsCount+CertsCount)) != ASN1_OP_OK)
          break;

        if((Retcode = AllocCopyDatArrayToDatArray(HMEM_CTX_REF1 pExtCertsDatArrayDesc,0,pTmpCertsDatArrayDesc[0],0,ExtCertsCount,0)) != ASN1_OP_OK)
        {
          FreeIDATPARR_Struc(HMEM_CTX_REF1 pTmpCertsDatArrayDesc[0]);
          break;
        }
        if((Retcode = AllocCopyDatArrayToDatArray(HMEM_CTX_REF1 pCertsDatArrayDesc,0,pTmpCertsDatArrayDesc[0],ExtCertsCount,CertsCount,0)) != ASN1_OP_OK)
        {
          FreeIDATPARR_Struc(HMEM_CTX_REF1 pTmpCertsDatArrayDesc[0]);
          break;
        }
        FreeIDATPARR_Struc(HMEM_CTX_REF1 pCertsDatArrayDesc);
        FreeIDATPARR_Struc(HMEM_CTX_REF1 pExtCertsDatArrayDesc);
        pExtCertsDatArrayDesc = NULL;
        pCertsDatArrayDesc = pTmpCertsDatArrayDesc[0];
        CertsCount += ExtCertsCount;
        break;
      }
      else if(ExtCertsCount != 0)			// copy to 'normal'
      {
        pCertsDatArrayDesc = pExtCertsDatArrayDesc;
        pExtCertsDatArrayDesc = NULL;
        CertsCount = ExtCertsCount;
        break;
      }
      break;
    }
  }
  //---------------------------------------------------------------
  // Check result of Merging operation
  //---------------------------------------------------------------
  if(Retcode != 0)
  {
    FREE_ARRAY(HMEM_CTX_REF,pTmpExtCertsBuf[0]);
#ifndef XH_INTERFACE
    FREE_ARRAY(HMEM_CTX_REF,pConnPtrArray);
#endif // XH_INTERFACE
    FreeIDATPARR_Struc(HMEM_CTX_REF1 pCertsDatArrayDesc);
    ClearFreeBit8Array(HMEM_CTX_REF1 pDecodedConfPwdBuf,pConfPwdLen[0]);
    ClearFreeBit8Array(HMEM_CTX_REF1 pDecodedCertsPwdBuf,pCertsPwdLen[0]);
    FreeCfgStruct(HMEM_CTX_REF1 pCfgStruc);	// free configuration
    return(HSSL_CERTS_PROCESS_ERR);
  }
  //----------------------------------------------------
  // If any certificates present:
  // Build the Certificate Tree and associated structure
  // RDNs will be ssorted on request !!!
  //----------------------------------------------------
  if(CertsCount != 0)
  {
    Retcode = GenTreeFromASN1DatArrayDescEX(HMEM_CTX_REF1 
                                            pCertsDatArrayDesc,
                                            2,
                                            (pCfgStruc->ExtConf2Flags & (DONT_SORT_RDNS_BIT_MASK | PROCESS_CERT_EXTS_BIT_MASK)) >> CERT_PROCESS_FLAGS_SHIFT,
                                            pIniStruc->Entity & ENTITY_BIT_MASK,
                                            pCertsPwdBuf[0],
                                            pCertsPwdLen[0],
                                            pTmpTreeStruc);
    ClearFreeBit8Array(HMEM_CTX_REF1 pDecodedConfPwdBuf,pConfPwdLen[0]);
    ClearFreeBit8Array(HMEM_CTX_REF1 pDecodedCertsPwdBuf,pCertsPwdLen[0]);
    FREE_ARRAY(HMEM_CTX_REF,pTmpExtCertsBuf[0]);
    if(Retcode != ASN1_OP_OK)
    {
#ifndef XH_INTERFACE
      FREE_ARRAY(HMEM_CTX_REF,pConnPtrArray);
#endif // XH_INTERFACE
      FreeIDATPARR_Struc(HMEM_CTX_REF1 pCertsDatArrayDesc);
      FreeCfgStruct(HMEM_CTX_REF1 pCfgStruc);	// free configuration
      return(HSSL_CERT_TREE_GEN_FAILED);
    }
    pCertTreeStruc = pTmpTreeStruc[0];
    pCfgStruc->pCertTreeStruc = pTmpTreeStruc[0];
  }
  else					// no certificates, no tree (EXT only)
  {
    pCertTreeStruc = NULL;
    pCfgStruc->pCertTreeStruc = NULL;
  }

  //---------------------------------------------------------------
  // Check certificate chains in CDB for correct signature/matching
  //---------------------------------------------------------------
  if(pCertTreeStruc != NULL)
  {
    Retcode = CheckAllEndcertsChains(HMEM_CTX_REF1 pCertTreeStruc);
    if(Retcode != 0)
    {
#ifndef XH_INTERFACE
      FREE_ARRAY(HMEM_CTX_REF,pConnPtrArray);
#endif // XH_INTERFACE
      FreeIDATPARR_Struc(HMEM_CTX_REF1 pCertsDatArrayDesc);
      FreeCfgStruct(HMEM_CTX_REF1 pCfgStruc);	// free configuration
      return(Retcode);
    }
  }
  //----------------------------------------------------
  // If this is a server, there must be at least one
  // Endcertificate (with private key!)
  //----------------------------------------------------
  if((pIniStruc->Entity & ENTITY_BIT_MASK) == SERVER_ENTITY)
  {
    if((pCertTreeStruc == NULL) ||
       ((pCertTreeStruc->EndRsaCount == 0) &&
        (pCertTreeStruc->RootEndRsaCount == 0) &&
        (pCertTreeStruc->EndDssCount == 0) &&
        (pCertTreeStruc->RootEndDssCount == 0) &&
        (pCertTreeStruc->EndDhRsaCount == 0) &&
        (pCertTreeStruc->EndDhDssCount == 0)))
    {
#ifndef XH_INTERFACE
      FREE_ARRAY(HMEM_CTX_REF,pConnPtrArray);
#endif // XH_INTERFACE
      FreeIDATPARR_Struc(HMEM_CTX_REF1 pCertsDatArrayDesc);
      FreeCfgStruct(HMEM_CTX_REF1 pCfgStruc);	// free configuration
      return(HSSL_NO_SERVER_CERTS);
    }
  }
  //----------------------------------------------------
  // Build the Root RND list if Certificates present
  //----------------------------------------------------
  if(CertsCount != 0)
  {
    Retcode = BuildRootRDNsList(HMEM_CTX_REF1 pCertTreeStruc,pTmpRDNDatArrayDesc);
    if(Retcode != ASN1_OP_OK)
    {
#ifndef XH_INTERFACE
      FREE_ARRAY(HMEM_CTX_REF,pConnPtrArray);
#endif // XH_INTERFACE
      FreeIDATPARR_Struc(HMEM_CTX_REF1 pCertsDatArrayDesc);
      FreeCfgStruct(HMEM_CTX_REF1 pCfgStruc);	// free configuration
      return(HSSL_ROOT_RDN_LIST_GEN_FAILED);
    }
    pCfgStruc->pRootRdnArray = pTmpRDNDatArrayDesc[0];
  }
  else						// no certs.
    pCfgStruc->pRootRdnArray = NULL;

  //----------------------------------------------------
  // Remove all server cipher suites which have no
  // End-Certificate (i.e. no private key)
  //----------------------------------------------------
  if((pIniStruc->Entity & ENTITY_BIT_MASK) == SERVER_ENTITY)
  {
    Retcode = RemoveCiphersuitesWithoutCert(HMEM_CTX_REF1
					    pCfgStruc);
    if(Retcode != HSSL_OP_OK)
    {
#ifndef XH_INTERFACE
      FREE_ARRAY(HMEM_CTX_REF,pConnPtrArray);
#endif // XH_INTERFACE
      FreeIDATPARR_Struc(HMEM_CTX_REF1 pCertsDatArrayDesc);
      FreeCfgStruct(HMEM_CTX_REF1 pCfgStruc);	// free configuration
      return(Retcode);
    }
  }
  FreeIDATPARR_Struc(HMEM_CTX_REF1 pCertsDatArrayDesc);

#if !defined XH_INTERFACE
  pGlobalCfgStruct = pCfgStruc;// save config structure pointer !!
  InitConnStrucLock();			// initialize critical section
  InitSubjListLock();
  InitializedFlag = 1;
#else // XH_INTERFACE
  if(pIniStruc->Mode == 0)				// only do a check
  {
    FreeCfgStruct(HMEM_CTX_REF1 pCfgStruc);	// free configuration
  }
  else					// really initialize, report Cfg
  {
    pIniStruc->pCfgStruc = pCfgStruc;
  }
#endif // XH_INTERFACE

  return(HSSL_OP_OK);
}

//()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()
//
// Old Initialization Functions / Constructors
// These are wrapped to the new Extended initialization function
//
//()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()

//-----------------------------------------------------------------------
// Init-Function for the C Style Interfaces
//-----------------------------------------------------------------------
#ifndef XH_INTERFACE
extern "C"  int  HSSL_Init(HMEM_CTX_DEF
		char* ConfigDataBuf, int ConfigDataLen,
		char* CertsDataBuf, int CertsDataLen,
		char* CfgPwdBuf, int CfgPwdLen,
		char* CertsPwdBuf, int CertsPwdLen,
		int ConfigPwdType, int CertsPwdType,
		int Entity)
#else
/**
* Reads configuration data and certificates and initializes the SSL/TLS module (HSSL_Init).
*
* @see HSSL_PrivExtInit
*
*  @param ConfigDataBuf Configuration data
*  @param ConfigDataLen Length of configuration data
*  @param CertsDataBuf Certificate database data
*  @param CertsDataLen length of certificate data
*  @param CfgPwdBuf Configuration password data
*  @param CfgPwdLen Configuration password length
*  @param CertsPwdBuf Certificate password data
*  @param CertsPwdLen Certificate password length
*  @param ConfigPwdType == 0 - pure password <br>
*               <> 0 - from file, decode
*  @param CertsPwdType == 0 - pure password <br>
*               > 0 - from file, decode <br>
*               < 0 - use same as config pwd.
*  @param Entity Bit 0: Server / Client entity <br>
*               Bit 1: Server cert request mode <br>
*               Bit 2: Client disable compress <br>
*  @param Mode 0: Only check params
*
*  @return HSSL_OP_OK on success, error code otherwise
*/
extern "C"  int  HSSL_Init(HMEM_CTX_DEF
		char* ConfigDataBuf, int ConfigDataLen,
		char* CertsDataBuf, int CertsDataLen,
		char* CfgPwdBuf, int CfgPwdLen,
		char* CertsPwdBuf, int CertsPwdLen,
		int ConfigPwdType, int CertsPwdType,
		int Entity, int Mode, CFG_STRU * ppCfg[])
#endif

{
  int Retcode;
  HSISTR *	pIniStruc;

  for(;;)	// Error FOR
  {
    //------------------------------------------------------------
    // Allocate Initialization Structure
    //------------------------------------------------------------
    pIniStruc =	(HSISTR *)
      ((void *) BIT8_ARRAY_CALLOCEX(HMEM_CTX_REF,
				  1, sizeof(HSISTR)));
    if(pIniStruc == NULL)
    {
      Retcode = HSSL_ALLOC_ERR;
      break;
    }
    //------------------------------------------------------------
    // Put calling parameters to the Structure
    //------------------------------------------------------------
    pIniStruc->pCfgDataBuf    = ConfigDataBuf;
    pIniStruc->CfgDataLen  = ConfigDataLen;
    pIniStruc->pCfgPwdBuf     = CfgPwdBuf;
    pIniStruc->CfgPwdLen   = CfgPwdLen;
    pIniStruc->CfgPwdType  = ConfigPwdType;

    pIniStruc->pCertDataBuf   = CertsDataBuf;
    pIniStruc->CertDataLen = CertsDataLen;
    pIniStruc->pCertPwdBuf    = CertsPwdBuf;
    pIniStruc->CertPwdLen  = CertsPwdLen;
    pIniStruc->CertPwdType = CertsPwdType;

    pIniStruc->Entity      = Entity;
#if defined XH_INTERFACE
    pIniStruc->Mode        = Mode;
#endif
    //------------------------------------------------------------
    // Call Extended Initialization routine
    //------------------------------------------------------------
    Retcode = HSSL_PrivExtInit(HMEM_CTX_REF1 pIniStruc);
    pIniStruc->Retcode = Retcode;
    break;
  }
  //-------------------------------------------------------------
  // Set the Return parameters
  //-------------------------------------------------------------
#if defined XH_INTERFACE
  ppCfg[0] = pIniStruc->pCfgStruc;
#endif

  FREE_CARRAYEX(HMEM_CTX_REF,pIniStruc);	// was missing

  return(Retcode);
}

//()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()
//
// New Initialization Functions / Constructors
// These are wrapped to the new Extended initialization function
//
//()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()

//-----------------------------------------------------------------------
// Init-Function for the C Style Interfaces
//-----------------------------------------------------------------------
/**
* Initializes the SSL/TLS module, using an intialization structure (HSSL_InitEX).
* 
* @see HSSL_PrivExtInit
*  @param pIniStruc Initialization Structure
*  @return HSSL_OP_OK on success, error code otherwise
*/
extern "C"  int  HSSL_InitEX(HMEM_CTX_DEF HSISTR * pIniStruc)

{
  int Retcode;
  //------------------------------------------------------------
  // Check parameters
  //------------------------------------------------------------
  if(pIniStruc == NULL)
  {
    return(HSSL_NULL_PTR);
  }
  //------------------------------------------------------------
  // Check for Callback pointer (JAVA: resolve to Method!)
  //------------------------------------------------------------
  //------------------------------------------------------------
  // Call Extended Initialization routine
  //------------------------------------------------------------
  Retcode = HSSL_PrivExtInit(HMEM_CTX_REF1 pIniStruc);
  pIniStruc->Retcode = Retcode;
  //-------------------------------------------------------------
  // Set the Return value
  //-------------------------------------------------------------
  return(Retcode);
}

#if !defined XH_INTERFACE
extern "C" int  HLSSL_ReloadSubjNamesList(HMEM_CTX_DEF
		char* ConfigDataBuf,
		int ConfigDataLen, char* CfgPwdBuf, int CfgPwdLen,
		int ConfigPwdType)
{
  int Retcode;

  int CfgType;
  int CfgPwdFtype;
  
  int ProtocolFlags;
  int Entity;

  char* pDecodedConfPwdBuf = NULL;

  char* pConfPwdBuf[1];
  int pConfPwdLen[1];

  CFG_STRU * pCfgStruc;
  CFG_STRU * ppCfgStruc[1];

  //---------------------------------------------------------
  // check if Interface has been initialized, if not, error !
  //---------------------------------------------------------
  if(InitializedFlag == 0)
    return(HSSL_LD_SCNLIST_NOT_INIT);
  //-------------------------------------------------
  // Check if there is currently a list in use 
  //-------------------------------------------------
  Entity = pGlobalCfgStruct->Entity;

  ProtocolFlags = pGlobalCfgStruct->ProtFlags;// get relevant flags
  if(((Entity == SERVER_ENTITY) &&
      ((ProtocolFlags & CLNT_AUTH_BIT_MASK) == 0)) ||
     ((Entity == CLIENT_ENTITY) &&
      ((ProtocolFlags & SRVR_AUTH_BIT_MASK) == 0)))
    return(HSSL_LD_SCNLIST_NO_LIST_IN_USE);
  //-------------------------------------------------------------
  // A list is in use, get the new list data
  //-------------------------------------------------------------
  if(Entity == SERVER_ENTITY)
  {
    CfgType	  = FILE_TYPE_SRVR_CFG;
    CfgPwdFtype   = FILE_TYPE_SRVR_PWD;
  }
  else
  {
    CfgType	  = FILE_TYPE_CLNT_CFG;
    CfgPwdFtype   = FILE_TYPE_CLNT_PWD;
  }
  //-------------------------------------------------
  // Decode the password(s) if required
  //-------------------------------------------------
  pConfPwdBuf[0]  = CfgPwdBuf;
  pConfPwdLen[0]  = CfgPwdLen;

  if(ConfigPwdType != 0)		// from file, decrypt
  {
    Retcode = DecodePasswdData(HMEM_CTX_REF1 CfgPwdBuf,0,FILE_HEADER_LEN,CfgPwdBuf,FILE_HEADER_LEN,CfgPwdLen-FILE_HEADER_LEN,CfgPwdFtype,pConfPwdBuf,pConfPwdLen);
    if(Retcode != 0)
      return(HSSL_CFG_PWD_DECODE_FAILED);
    pDecodedConfPwdBuf = pConfPwdBuf[0];
  }
  //-------------------------------------------------
  // Extract the configuration data (new version)
  //-------------------------------------------------
  Retcode = ExtractConfigDataEx(HMEM_CTX_REF1 ConfigDataBuf,0,ConfigDataLen,pConfPwdBuf[0],0,pConfPwdLen[0],CfgType,ppCfgStruc,NULL,NULL,NULL);
  if(Retcode != 0)
  {
    ClearFreeBit8Array(HMEM_CTX_REF1 pDecodedConfPwdBuf,pConfPwdLen[0]);
    if(Retcode == -7)
      return(HSSL_CFG_PWD_ERROR);
     return(HSSL_CFG_READ_FAILED);
  }
  Retcode = m_filter_cipher_list(ppCfgStruc[0]->CipherSuitesList);
  if(Retcode < 1){
    return HSSL_CFG_NO_SUPPORTED_CIPHER;
  }
  ClearFreeBit8Array(HMEM_CTX_REF1 pDecodedConfPwdBuf,pConfPwdLen[0]);
  pCfgStruc = ppCfgStruc[0];
  //--------------------------------------------------
  // Check if there is a list in the new configuration
  //--------------------------------------------------
  if(pCfgStruc->SubjCNamesListPtr == NULL)
  {
//  FREE_CFG_STRUCT(HSSLGLIBinst, pCfgStruc);  // free configuration
    FreeCfgStruct(pCfgStruc);			// free configuration
    return(HSSL_LD_SCNLIST_NO_LIST_IN_NEW);	// no list present
  }
  //--------------------------------------------------
  // There is a list present, replace the old one
  //--------------------------------------------------
  GetSubjListLock();			// set the access lock
  FREE_ARRAY(HMEM_CTX_REF,
             pGlobalCfgStruct->SubjCNamesListPtr); // free the old one
  pGlobalCfgStruct->SubjCNamesListPtr =	// replace with new
    pCfgStruc->SubjCNamesListPtr;

  pCfgStruc->SubjCNamesListPtr = NULL;	// invalidate the pointer !
//FREE_CFG_STRUCT(HSSLGLIBinst, pCfgStruc);	// free configuration
  FreeCfgStruct(pCfgStruc);			// free configuration
  ReleaseSubjListLock();
  return(HSSL_OP_OK);
}
#endif // XH_INTERFACE

#if !defined XH_INTERFACE		// not used with other interface
extern "C" void  HSSL_DeInit(HMEM_CTX_DEF1)
{
  InitializedFlag = 0;
  FREE_ARRAY(HMEM_CTX_REF,pConnPtrArray);
  FreeCfgStruct(pGlobalCfgStruct);			// free configuration
}
#endif // XH_INTERFACE

#if !defined XH_INTERFACE // standard for HWSP
extern "C" int HLSSL_GetConnectionQueryData(int SocketID, char* DstBuf,
				        int* pDstLen)
{
  int BufLen;
  int PartnerNameLen = 0;
  int DstIndex = 0;
  int DstBufLen;
  int PartnerCertLen = 0;

  int l;

  char* pPartnerName;
  char* pPartnerCert;
  CONNSTRU * pConnStruc;
  //-----------------------------------------------------
  // check parameters
  //-----------------------------------------------------
  if(pDstLen == NULL) return(HSSL_NULL_PTR);
  if((SocketID < 1) ||
     (SocketID > pGlobalCfgStruct->MaxConnCount))
    return(HSSL_GET_CONN_Q_DATA_INV_SOCK);
  pConnStruc = GetConnectStrucAndLock(SocketID);
  if(pConnStruc == NULL)
    return(HSSL_GET_CONN_Q_DATA_LOCK_ERR);
  //-----------------------------------------------------
  // Get the size of needed buffer
  //-----------------------------------------------------
  pPartnerName = pConnStruc->pPartnerName;
  if(pPartnerName != NULL)
  {
    BIGchar2wordn(pPartnerName,PartnerNameLen,0); // get element count
    PartnerNameLen = (PartnerNameLen + 1) * 2;	// to byte count
  }
  pPartnerCert = pConnStruc->pPartnerCert;
  PartnerCertLen = pConnStruc->PartnerCertLen;
  if((pPartnerCert == NULL) || (PartnerCertLen <= 0))
    PartnerCertLen = 0;
  else
    PartnerCertLen += 2;			// inclusive leading size bytes

  BufLen = Q_CONNDAT_FIXED_PARAMS_SIZE + 2 +	// size of fixed portion
           PartnerNameLen + PartnerCertLen;	// variable size
  //-----------------------------------------------------
  // Check if copy is requested
  //-----------------------------------------------------
  if(DstBuf == NULL)
  {
    pDstLen[0] = BufLen;			// set length
    ReleaseConnectStrucLock(pConnStruc);	// release structure lock
    return(HSSL_OP_OK);
  }
  DstBufLen = pDstLen[0];			// get given length

//  if((DstBufLen < 0) || (DstBufLen < BufLen)) // changed on req.(Galea)
  if((DstBufLen < 0) || (DstBufLen < Q_CONNDAT_FIXED_PARAMS_SIZE))
  {
    ReleaseConnectStrucLock(pConnStruc);	// release structure lock
    return(HSSL_GET_CONN_Q_DATA_LEN_ERR);
  }
  DstBufLen -= Q_CONNDAT_FIXED_PARAMS_SIZE;
  //-----------------------------------------------------
  // Transfer Data from the Structure to the User Buffer
  //-----------------------------------------------------
  // 1. Statistical counters
//  pDstLen[0] = Q_BufLen;		// set length [removed]
  l = pConnStruc->AppTXDataMSW;	// get MSW
  BIGlong2char(l,DstBuf,DstIndex);	// transfer
  l = pConnStruc->AppTXDataLSW;	// get LSW
  BIGlong2char(l,DstBuf,DstIndex);	// transfer
  l = pConnStruc->AppRXDataMSW;	// get MSW
  BIGlong2char(l,DstBuf,DstIndex);	// transfer
  l = pConnStruc->AppRXDataLSW;	// get LSW
  BIGlong2char(l,DstBuf,DstIndex);	// transfer

  l = pConnStruc->ComprTXDataMSW;	// get MSW
  BIGlong2char(l,DstBuf,DstIndex);	// transfer
  l = pConnStruc->ComprTXDataLSW;	// get MSW
  BIGlong2char(l,DstBuf,DstIndex);	// transfer
  l = pConnStruc->ComprRXDataMSW;	// get MSW
  BIGlong2char(l,DstBuf,DstIndex);	// transfer
  l = pConnStruc->ComprRXDataLSW;	// get MSW
  BIGlong2char(l,DstBuf,DstIndex);	// transfer
    
  l = pConnStruc->TXDataMSW;		// get MSW
  BIGlong2char(l,DstBuf,DstIndex);	// transfer
  l = pConnStruc->TXDataLSW;		// get MSW
  BIGlong2char(l,DstBuf,DstIndex);	// transfer
  l = pConnStruc->RXDataMSW;		// get MSW
  BIGlong2char(l,DstBuf,DstIndex);	// transfer
  l = pConnStruc->RXDataLSW;		// get MSW
  BIGlong2char(l,DstBuf,DstIndex);	// transfer

  // 2. Compr/Cipher states

  DstBuf[DstIndex++] = pConnStruc->ActualProtocol;
  DstBuf[DstIndex++] = pConnStruc->ActualComprMethod;
  BIGword2char(pConnStruc->ActualCipherSuite,DstBuf,DstIndex);	// transfer
  DstBuf[DstIndex++] = pConnStruc->KeyExchgMode;
  DstBuf[DstIndex++] = pConnStruc->CipherAlgor;
  DstBuf[DstIndex++] = pConnStruc->CipherType;
  DstBuf[DstIndex++] = pConnStruc->MacAlgorType;
  DstBuf[DstIndex++] = pConnStruc->IsExportable;
  DstBuf[DstIndex++] = pConnStruc->CertifiedFlags;
  DstBuf[DstIndex++] = pConnStruc->CacheMode;
  switch(pConnStruc->ActualProtocol){ // Encoded protocol version
     /** @todo Wait for ok from KB */
     case TLS_V2_PROT_TYPE:
        l= 0x20102;
        BIGlong2char(l,DstBuf,DstIndex);
        break;
     case TLS_V1_PROT_TYPE:
        l= 0x20101;
        BIGlong2char(l,DstBuf,DstIndex);
        break;
     case TLS_PROT_TYPE:
        l= 0x20100;
        BIGlong2char(l,DstBuf,DstIndex);
        break;
     case SSL_PROT_TYPE:
        l= 0x10300;
        BIGlong2char(l,DstBuf,DstIndex);
        break;
  }

  // 3. Server Port, Server/Client IP-Addresses, Session-ID

  DstIndex = Q_SERVER_PORT_IND;		// skip reserved
  BIGword2char(pConnStruc->ServerPort,DstBuf,DstIndex);	// transfer
  memcpy(DstBuf+DstIndex,pConnStruc->ServerIPAdr+0,IP_ADR_MAXLEN+1);
  DstIndex += (IP_ADR_MAXLEN+1);
  memcpy(DstBuf+DstIndex,pConnStruc->ClientIPAdr+0,IP_ADR_MAXLEN+1);
  DstIndex += (IP_ADR_MAXLEN+1);
  memcpy(DstBuf+DstIndex,pConnStruc->SessionID+0,MAX_SESSION_ID_LEN+1);

  // 4. Partners name (if present and buffer supplied)

  DstIndex = Q_PARTNER_COM_NAME_IND;	// skip reserveds

  //----------------------------------------------
  // check if partner name should be copied
  //----------------------------------------------
  if(DstBufLen != 0)				// buffer space given
  {
    memset(DstBuf+DstIndex,0,DstBufLen);	// clear the rest first
    if(PartnerNameLen != 0)			// there is a partner name
    {
      if(PartnerNameLen > DstBufLen)		// limit to buffer size
        PartnerNameLen = DstBufLen;
      memcpy(DstBuf+DstIndex,pPartnerName+0,PartnerNameLen);
      DstIndex += PartnerNameLen;
      DstBufLen -= PartnerNameLen;
    }
    else					// there is NO partner name
    {
      DstIndex  += 2;				// length is set 00 00 !
      DstBufLen -= 2;
    }
  }
  if((DstBufLen > 2) && (PartnerCertLen > 2))	// still buffer space
  {
    if(PartnerCertLen > DstBufLen)
      PartnerCertLen = DstBufLen;
    PartnerCertLen -= 2;			// reduce by length header
    BIGword2char(PartnerCertLen,DstBuf,DstIndex); // set size
    memcpy(DstBuf+DstIndex,pPartnerCert+0,PartnerCertLen);    
//  DstIndex  += PartnerCertLen;
//  DstBufLen -= PartnerCertLen-2;
  }

  ReleaseConnectStrucLock(pConnStruc);	// release structure lock
  return(HSSL_OP_OK);
}

#else // XH_INTERFACE
/**
* Gets length/copies data related to a connection to user buffer (HLSSL_GetConnectionQueryData).
*
* If a buffer is provided, tries to copy, else it returns the required length.
*
* The general layout of the data in the buffer, going by indices, is:
*<ul>
* <li> 0-47: Data transfer statistics.
* <li> 48-62: Information about active state (prot. version, cipher suite and
*           so on).
* <li> 96-164: Server and client IP, session ID.
* <li> 192 and higher: Certificate information.
*</ul>
*
*  @param pConnStruc Pointer to connection structure.
*  @param DstBuf Destination buffer. Optional
*  @param pDstLen Length of data (copied / required)
*  @return HSSL_OP_OK on success, else error occured
*/
extern "C" int HLSSL_GetConnectionQueryData(CONNSTRU * pConnStruc,
					char* DstBuf, int* pDstLen)
{
  int BufLen;
  int PartnerNameLen = 0;
  int DstIndex = 0;
  int DstBufLen;
  int PartnerCertLen = 0;

  int l;

  char* pPartnerName;
  char* pPartnerCert;
  //-----------------------------------------------------
  // check parameters
  //-----------------------------------------------------
  if((pDstLen == NULL) || (pConnStruc == NULL))
    return(HSSL_NULL_PTR);
  //-----------------------------------------------------
  // Get the size of needed buffer
  //-----------------------------------------------------
  pPartnerName = pConnStruc->pPartnerName;
  if(pPartnerName != NULL)
  {
    BIGchar2wordn(pPartnerName,PartnerNameLen,0); // get element count
    PartnerNameLen = (PartnerNameLen + 1) * 2;	// to byte count
  }
  pPartnerCert = pConnStruc->pPartnerCert;
  PartnerCertLen = pConnStruc->PartnerCertLen;
  if((pPartnerCert == NULL) || (PartnerCertLen <= 0))
    PartnerCertLen = 0;
  else
    PartnerCertLen += 2;			// inclusive leading size bytes

  BufLen = Q_CONNDAT_FIXED_PARAMS_SIZE + 2 +	// size of fixed portion
           PartnerNameLen + PartnerCertLen;	// variable size
  //-----------------------------------------------------
  // Check if copy is requested
  //-----------------------------------------------------
  if(DstBuf == NULL)
  {
    pDstLen[0] = BufLen;			// set length
    return(HSSL_OP_OK);
  }
  DstBufLen = pDstLen[0];			// get given length

//  if((DstBufLen < 0) || (DstBufLen < BufLen)) // changed on req.(Galea)
  if((DstBufLen < 0) || (DstBufLen < Q_CONNDAT_FIXED_PARAMS_SIZE))
  {
    return(HSSL_GET_CONN_Q_DATA_LEN_ERR);
  }
  DstBufLen -= Q_CONNDAT_FIXED_PARAMS_SIZE;
  //-----------------------------------------------------
  // Transfer Data from the Structure to the User Buffer
  //-----------------------------------------------------
  // 1. Statistical counters
//  pDstLen[0] = Q_BufLen;		// set length [removed]
  l = pConnStruc->AppTXDataMSW;	// get MSW
  BIGlong2char(l,DstBuf,DstIndex);	// transfer
  l = pConnStruc->AppTXDataLSW;	// get LSW
  BIGlong2char(l,DstBuf,DstIndex);	// transfer
  l = pConnStruc->AppRXDataMSW;	// get MSW
  BIGlong2char(l,DstBuf,DstIndex);	// transfer
  l = pConnStruc->AppRXDataLSW;	// get LSW
  BIGlong2char(l,DstBuf,DstIndex);	// transfer

  l = pConnStruc->ComprTXDataMSW;	// get MSW
  BIGlong2char(l,DstBuf,DstIndex);	// transfer
  l = pConnStruc->ComprTXDataLSW;	// get MSW
  BIGlong2char(l,DstBuf,DstIndex);	// transfer
  l = pConnStruc->ComprRXDataMSW;	// get MSW
  BIGlong2char(l,DstBuf,DstIndex);	// transfer
  l = pConnStruc->ComprRXDataLSW;	// get MSW
  BIGlong2char(l,DstBuf,DstIndex);	// transfer
    
  l = pConnStruc->TXDataMSW;		// get MSW
  BIGlong2char(l,DstBuf,DstIndex);	// transfer
  l = pConnStruc->TXDataLSW;		// get MSW
  BIGlong2char(l,DstBuf,DstIndex);	// transfer
  l = pConnStruc->RXDataMSW;		// get MSW
  BIGlong2char(l,DstBuf,DstIndex);	// transfer
  l = pConnStruc->RXDataLSW;		// get MSW
  BIGlong2char(l,DstBuf,DstIndex);	// transfer

  // 2. Compr/Cipher states

  DstBuf[DstIndex++] = pConnStruc->ActualProtocol;
  DstBuf[DstIndex++] = pConnStruc->ActualComprMethod;
  BIGword2char(pConnStruc->ActualCipherSuite,DstBuf,DstIndex);	// transfer
  DstBuf[DstIndex++] = pConnStruc->KeyExchgMode;
  DstBuf[DstIndex++] = pConnStruc->CipherAlgor;
  DstBuf[DstIndex++] = pConnStruc->CipherType;
  DstBuf[DstIndex++] = pConnStruc->MacAlgorType;
  DstBuf[DstIndex++] = pConnStruc->IsExportable;
  DstBuf[DstIndex++] = pConnStruc->CertifiedFlags;
  DstBuf[DstIndex++] = pConnStruc->CacheMode;
  switch(pConnStruc->ActualProtocol){ // Encoded protocol version
     /** @todo Wait for ok from KB */
     case TLS_V2_PROT_TYPE:
        l= 0x20102;
        BIGlong2char(l,DstBuf,DstIndex);
        break;
     case TLS_V1_PROT_TYPE:
        l= 0x20101;
        BIGlong2char(l,DstBuf,DstIndex);
        break;
     case TLS_PROT_TYPE:
        l= 0x20100;
        BIGlong2char(l,DstBuf,DstIndex);
        break;
     case SSL_PROT_TYPE:
        l= 0x10300;
        BIGlong2char(l,DstBuf,DstIndex);
        break;
  }

  // 3. Server Port, Server/Client IP-Addresses, Session-ID

  DstIndex = Q_SERVER_PORT_IND;		// skip reserved
  BIGword2char(pConnStruc->ServerPort,DstBuf,DstIndex);	// transfer
  memcpy(DstBuf+DstIndex,pConnStruc->ServerIPAdr+0,IP_ADR_MAXLEN+1);
  DstIndex += (IP_ADR_MAXLEN+1);
  memcpy(DstBuf+DstIndex,pConnStruc->ClientIPAdr+0,IP_ADR_MAXLEN+1);
  DstIndex += (IP_ADR_MAXLEN+1);
  memcpy(DstBuf+DstIndex,pConnStruc->SessionID+0,MAX_SESSION_ID_LEN+1);

  // 4. Partners name (if present and buffer supplied)

  DstIndex = Q_PARTNER_COM_NAME_IND;	// skip reserveds

  //----------------------------------------------
  // check if partner name should be copied
  //----------------------------------------------
  if(DstBufLen != 0)				// buffer space given
  {
    memset(DstBuf+DstIndex,0,DstBufLen);	// clear the rest first
    if(PartnerNameLen != 0)			// there is a partner name
    {
      if(PartnerNameLen > DstBufLen)		// limit to buffer size
        PartnerNameLen = DstBufLen;
      memcpy(DstBuf+DstIndex,pPartnerName+0,PartnerNameLen);
      DstIndex  += PartnerNameLen;
      DstBufLen -= PartnerNameLen;
    }
    else					// there is NO partner name
    {
      DstIndex  += 2;				// length is set 00 00 !
      DstBufLen -= 2;
    }
  }

  if((DstBufLen > 2) && (PartnerCertLen > 2))	// still buffer space
  {
    if(PartnerCertLen > DstBufLen)
      PartnerCertLen = DstBufLen;
    PartnerCertLen -= 2;			// reduce by length header
    BIGword2char(PartnerCertLen,DstBuf,DstIndex); // set size
    memcpy(DstBuf+DstIndex,pPartnerCert+0,PartnerCertLen);    
//  DstIndex  += PartnerCertLen;
//  DstBufLen -= PartnerCertLen-2;
  }

  return(HSSL_OP_OK);
}
#endif // XH_INTERFACE

#if !defined XH_INTERFACE
extern "C" int HLSSL_GetConfigQueryData(char* DstBuf, int* pDstLen)
{

  int BufLen;
  int CmprListLen = 0;
  int CiphSuiteListLen = 0;
  int SubjCommonNameListLen = 0;
  int SubjCommonNamesCount;
  int OcspUrlListLen = 0;
  int DstIndex = 0;
  int i;

  char* pCmprMethList;
  char* pCiphSuitesList;
  char* pSubjCommonNameList;
  char* pOcspUrlList;
  //-----------------------------------------------------
  // check parameters
  //-----------------------------------------------------
  if(pDstLen == NULL) return(HSSL_NULL_PTR);
  //-----------------------------------------------------
  // Get the size of needed buffer
  //-----------------------------------------------------
  BufLen = 0;
  pCmprMethList   = pGlobalCfgStruct->CmprMethodsList;
  pCiphSuitesList = pGlobalCfgStruct->CipherSuitesList;

  if(pCmprMethList != NULL)
    CmprListLen = ((int) pCmprMethList[0] & 0xFF);
    
  if(pCiphSuitesList != NULL)
    BIGchar2wordn(pCiphSuitesList,CiphSuiteListLen,0);
 
  pSubjCommonNameList = pGlobalCfgStruct->SubjCNamesListPtr;

  if(pSubjCommonNameList != NULL)
  {
    BIGchar2word(pSubjCommonNameList,SubjCommonNamesCount,DstIndex);
    SubjCommonNameListLen = 2;		// set initial size
    while(SubjCommonNamesCount != 0)
    {
      BIGchar2word(pSubjCommonNameList,i,DstIndex); // get Element counter
      SubjCommonNameListLen += (i+1)*2;	// sum up
      DstIndex += (i*2);
      SubjCommonNamesCount--;
    }
  }

  pOcspUrlList = pGlobalCfgStruct->pOcspUrlsBuffer;
  if(pOcspUrlList != NULL)
  {
    OcspUrlListLen = pGlobalCfgStruct->OcspUrlsDataLen;
  }

  BufLen = Q_CONFDAT_FIXED_PARAMS_SIZE +	// size of fixed portion
           CmprListLen + 1 +			// add length byte
           CiphSuiteListLen + 2 +		// dto.
	   SubjCommonNameListLen + 2 +		// dto.
	   OcspUrlListLen + 2;			// dto.
  //-----------------------------------------------------
  // Check if copy is requested
  //-----------------------------------------------------
  if(DstBuf == NULL)
  {
    pDstLen[0] = BufLen;			// set length
    return(HSSL_OP_OK);
  }
  if((pDstLen[0] < 0) || (pDstLen[0] < BufLen))
    return(HSSL_GET_CONFG_Q_DATA_LEN_ERR);
  //-----------------------------------------------------
  // Transfer Data from the Structure to the User Buffer
  //-----------------------------------------------------
  // 1. Version, protocols, flags

  pDstLen[0] = BufLen;			// set length
  DstIndex = 0;
  DstBuf[DstIndex++] = HSSL_VERSION;
  DstBuf[DstIndex++] = HSSL_REVISION;
  DstBuf[DstIndex++] = pGlobalCfgStruct->ProtFlags;
  DstBuf[DstIndex++] = pGlobalCfgStruct->ExtConfigFlags;

  i = pGlobalCfgStruct->CertPolicyFlags;
  BIGword2char(i,DstBuf,DstIndex);

  i = pGlobalCfgStruct->MaxConnCount;
  BIGword2char(i,DstBuf,DstIndex);

  i = pGlobalCfgStruct->ConnectTimeout;
  BIGword2char(i,DstBuf,DstIndex);

  i = pGlobalCfgStruct->ExtConf2Flags;
  BIGword2char(i,DstBuf,DstIndex);

  // 2. Compr/Cipher lists

  DstIndex = Q_CMPR_METH_LIST_IND;
  if(CmprListLen != 0)
  {
    CmprListLen++;			// include length    
    memcpy(DstBuf+DstIndex,pCmprMethList+0,CmprListLen);
    DstIndex += CmprListLen;
  }
  else DstBuf[DstIndex++] = 0;

  if(CiphSuiteListLen != 0)
  {
    CiphSuiteListLen += 2;		// include length
    memcpy(DstBuf+DstIndex,pCiphSuitesList+0,CiphSuiteListLen);
    DstIndex += CiphSuiteListLen;
  }
  else
  {
    DstBuf[DstIndex++] = 0;
    DstBuf[DstIndex++] = 0;
  }

  // 3. Subject common names list

  if(SubjCommonNameListLen != 0)
  {
    BIGword2char(SubjCommonNameListLen,DstBuf,DstIndex); // set length
    memcpy(DstBuf+DstIndex,pSubjCommonNameList+0,SubjCommonNameListLen);
    DstIndex += SubjCommonNameListLen;
  }
  else
  {
    DstBuf[DstIndex++] = 0;
    DstBuf[DstIndex++] = 0;
  }

  // 4. OCSP Responder URLs list

  if(OcspUrlListLen != 0)
  {
    BIGword2char(OcspUrlListLen,DstBuf,DstIndex); // set length
    memcpy(DstBuf+DstIndex,pOcspUrlList+0,OcspUrlListLen);
//  DstIndex += OcspUrlListLen;
  }
  else
  {
    DstBuf[DstIndex++] = 0;
    DstBuf[DstIndex++] = 0;
  }

  return(HSSL_OP_OK);
}
#else  // for XH_INTERFACE
/**
* Gets length/copies data related to the global configuration to user buffer (HLSSL_GetConfigQueryData).
*
* If a buffer is provided, tries to copy, else it returns the required length.
*
*  @param pCfgStruct Pointer to configuration structure.
*  @param DstBuf Destination buffer. Optional
*  @param pDstLen length of data (copied/required)
*  @return HSSL_OP_OK on success, error code otherwise
*/
extern "C" int HLSSL_GetConfigQueryData(CFG_STRU * pCfgStruct,
				    char* DstBuf, int* pDstLen)
{
  int BufLen;
  int CmprListLen = 0;
  int CiphSuiteListLen = 0;
  int SubjCommonNameListLen = 0;
  int SubjCommonNamesCount;
  int OcspUrlListLen = 0;
  int DstIndex = 0;
  int i;

  char* pCmprMethList;
  char* pCiphSuitesList;
  char* pSubjCommonNameList;
  char* pOcspUrlList;
  //-----------------------------------------------------
  // check parameters
  //-----------------------------------------------------
  if(pDstLen == NULL) return(HSSL_NULL_PTR);
  //-----------------------------------------------------
  // Get the size of needed buffer
  //-----------------------------------------------------
  BufLen = 0;
  pCmprMethList   = pCfgStruct->CmprMethodsList;
  pCiphSuitesList = pCfgStruct->CipherSuitesList;

  if(pCmprMethList != NULL)
    CmprListLen = ((int) pCmprMethList[0] & 0xFF);
    
  if(pCiphSuitesList != NULL)
    BIGchar2wordn(pCiphSuitesList,CiphSuiteListLen,0);
 
  pSubjCommonNameList = pCfgStruct->SubjCNamesListPtr;

  if(pSubjCommonNameList != NULL)
  {
    BIGchar2word(pSubjCommonNameList,SubjCommonNamesCount,DstIndex);
    SubjCommonNameListLen = 2;		// set initial size
    while(SubjCommonNamesCount != 0)
    {
      BIGchar2word(pSubjCommonNameList,i,DstIndex); // get Element counter
      SubjCommonNameListLen += (i+1)*2;	// sum up
      DstIndex += (i*2);
      SubjCommonNamesCount--;
    }
  }

  pOcspUrlList = pCfgStruct->pOcspUrlsBuffer;

  if(pOcspUrlList != NULL)
  {
    OcspUrlListLen = pCfgStruct->OcspUrlsDataLen;
  }

  BufLen = Q_CONFDAT_FIXED_PARAMS_SIZE +	// size of fixed portion
           CmprListLen + 1 +			// add length byte
           CiphSuiteListLen + 2 +		// dto.
	   SubjCommonNameListLen + 2 +		// dto.
	   OcspUrlListLen + 2;			// dto.
  //-----------------------------------------------------
  // Check if copy is requested
  //-----------------------------------------------------
  if(DstBuf == NULL)
  {
    pDstLen[0] = BufLen;			// set length
    return(HSSL_OP_OK);
  }
  if((pDstLen[0] < 0) || (pDstLen[0] < BufLen))
    return(HSSL_GET_CONFG_Q_DATA_LEN_ERR);
  //-----------------------------------------------------
  // Transfer Data from the Structure to the User Buffer
  //-----------------------------------------------------
  // 1. Version, protocols, flags

  pDstLen[0] = BufLen;			// set length
  DstIndex = 0;
  DstBuf[DstIndex++] = HSSL_VERSION;
  DstBuf[DstIndex++] = HSSL_REVISION;
  DstBuf[DstIndex++] = pCfgStruct->ProtFlags;
  DstBuf[DstIndex++] = pCfgStruct->ExtConfigFlags;

  i = pCfgStruct->CertPolicyFlags;
  BIGword2char(i,DstBuf,DstIndex);

  i = pCfgStruct->MaxConnCount;
  BIGword2char(i,DstBuf,DstIndex);

  i = pCfgStruct->ConnectTimeout;
  BIGword2char(i,DstBuf,DstIndex);

  i = pCfgStruct->ExtConf2Flags;
  BIGword2char(i,DstBuf,DstIndex);

  // 2. Compr/Cipher lists

  DstIndex = Q_CMPR_METH_LIST_IND;
  if(CmprListLen != 0)
  {
    CmprListLen++;			// include length    
    memcpy(DstBuf+DstIndex,pCmprMethList+0,CmprListLen);
    DstIndex += CmprListLen;
  }
  else DstBuf[DstIndex++] = 0;

  if(CiphSuiteListLen != 0)
  {
    CiphSuiteListLen += 2;		// include length
    memcpy(DstBuf+DstIndex,pCiphSuitesList+0,CiphSuiteListLen);
    DstIndex += CiphSuiteListLen;
  }
  else
  {
    DstBuf[DstIndex++] = 0;
    DstBuf[DstIndex++] = 0;
  }

  // 3. Subject common names list

  if(SubjCommonNameListLen != 0)
  {
    BIGword2char(SubjCommonNameListLen,DstBuf,DstIndex); // set length
    memcpy(DstBuf+DstIndex,pSubjCommonNameList+0,SubjCommonNameListLen);
    DstIndex += SubjCommonNameListLen;
  }
  else
  {
    DstBuf[DstIndex++] = 0;
    DstBuf[DstIndex++] = 0;
  }

  // 4. OCSP Responder URLs list

  if(OcspUrlListLen != 0)
  {
    BIGword2char(OcspUrlListLen,DstBuf,DstIndex); // set length
    memcpy(DstBuf+DstIndex,pOcspUrlList+0,OcspUrlListLen);
//  DstIndex += OcspUrlListLen;
  }
  else
  {
    DstBuf[DstIndex++] = 0;
    DstBuf[DstIndex++] = 0;
  }

  return(HSSL_OP_OK);
}
#endif // XH_INTERFACE

//()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()
//()								()
//()     XH-Server Interface Base Routines			()
//()								()
//()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()

#if defined XH_INTERFACE

/**
This function used to be for release of the static configuration array, which is now deprecated.

It does nothing.
*/
extern "C"  void  ReleaseAllXhConfigs(ds__hmem *)
{
}

/**

This function used to be for release of the static configuration array, which is now deprecated.

It does nothing.
*/
extern "C"  void  m_deregister_all_configs(
		BOOL (*)(void * pContext, int, void *, int),
		void * )
{
}

/**
* Initializes a SSL/TLS configuration and writes it to the configuration array (m_registerconfig).
*
* Also prepares OCSP and session caching as possible.
*
* Server side only.
*
* @see HSSL_Init
*
*  @param pConfigDataBuf Configuration file buffer
*  @param ConfigDataLen Length of configuration data
*  @param pCertDataBuf Certificates file buffer
*  @param CertDataLen Length of certificate data
*  @param pPwdBuf Password Buffer
*  @param PwdLen Length of password Data
*  @param PwdFileFlag True: Password is from a file
*  @param OcspList OCSP configuration
*  @param amp_aux Pointer to auxilery function
*  @param vpp_userfld User field for amp_aux
*  @param ppConfigID Pointer to destination for config array index of the new
*                 configuration. Will take a pointer to a newly allocated int.
*  @return 0 - o.k., else error occured
*/
extern "C" int m_registerconfig(char* pConfigDataBuf, int ConfigDataLen,
			    char* pCertDataBuf, int CertDataLen,
			    char* pPwdBuf, int PwdLen,
			    BOOL PwdFileFlag,
			    struct dsd_hl_ocsp_d_1 * OcspList,
    BOOL (* amp_aux) (void *vpp_userfld,int,void *, int),
			    void * vpp_userfld,
			    void ** ppConfigID)
{
  int Retcode;
  int PwdDuplicateFlag = 0;

  CFG_STRU * pCfgStruc;
  CFG_STRU * pTmpCfgStruc[1];

  HMEM_CTX_DEF1;

  ds__hmem CtxStruc = m_make_mem_struct(amp_aux, 
                                        vpp_userfld, 
                                        HMEM_NO_POOLS_FLAG_BIT);
  
  LOAD_HMEM_CTX_PTR(&CtxStruc);

  //------------------------------------------------------
  // Process Configuration and Certificates for given data
  //------------------------------------------------------

  if(PwdFileFlag != 0)			// Password is from a File
    PwdDuplicateFlag = -1;		// use also for Certificates
  Retcode = HSSL_Init(HMEM_CTX_REF1
		      pConfigDataBuf, ConfigDataLen, pCertDataBuf, CertDataLen,
		      pPwdBuf, PwdLen, pPwdBuf, PwdLen, PwdFileFlag,
		      PwdDuplicateFlag, SERVER_ENTITY, 1, pTmpCfgStruc);
  if(Retcode != HSSL_OP_OK)
  {
    MEMMGR_FREE(HMEM_CTX_REF);
    return(Retcode);
  }
  pCfgStruc = pTmpCfgStruc[0];
  //---------------------------------------------------------------------
  // Save memory context to structure (!)
  //---------------------------------------------------------------------
  memcpy(&pCfgStruc->CfgMemCtxStruc,vp__ctx,sizeof(ds__hmem));
  pCfgStruc->pCfgMemCtx = &pCfgStruc->CfgMemCtxStruc;

  //---------------------------------------------------------------------
  // Get OCSP 'configuration' from XH-Interface, use as override later...
  //---------------------------------------------------------------------
  pCfgStruc->pXhConnStrucList = OcspList;
  if(OcspList != NULL)				// configuration given
  {
    pCfgStruc->ExtConf2Flags |= ENABLE_USE_OCSP_BIT_MASK; // force enable
  }
  else						// no configuration given
  {
    if((pCfgStruc->ExtConf2Flags & ENABLE_USE_OCSP_BIT_MASK) != 0)
    {
      FreeCfgStruct(HMEM_CTX_REF1 pCfgStruc);  // free configuration
      return(HSSL_INIT_OCSP_DATA_MISSING);
    }
  }
  //---------------------------------------------------------------------
  // Initialize Server Session cache if caching enabled/supported
  //---------------------------------------------------------------------
  pCfgStruc->ExtConfigFlags &= (~SESS_CACHE_BIT_MASK); // disable caching

  if((pCfgStruc->ExtConfigFlags & SESS_CACHE_BIT_MASK) != 0)
  {
    Retcode = CheckAuxCMASupport(HMEM_CTX_REF1 SERVER_CACHE_TYPE);
    if(Retcode <= 0)				// no support for CMA
      pCfgStruc->ExtConfigFlags &= (~SESS_CACHE_BIT_MASK); // disable caching
    else
    {
      // Bit 31-24 of cache aging time are used as elementcount * 256
      // ----- Bit 23-0  are time in minutes
      SetSessionCacheInitParams(SERVER_CACHE_TYPE,
			   ((pCfgStruc->CacheAgingTime >> 24) & 0x0FF)*256,
			   (pCfgStruc->CacheAgingTime & 0x0FFFFFF) * 60);
    }
  }

  pCfgStruc->pCfgMemCtx->in__flags |= HMEM_LOCKED_STRUC_FLAG_BIT;

  ppConfigID[0] = pCfgStruc;
  return(HSSL_OP_OK);
}

extern "C" int m_release_config(BOOL (* amp_aux) (void *vpp_userfld,
                                                  int,
                                                  void *,
                                                  int),
                                void * vpp_userfld,
                                void * avop_config)
{
    if((avop_config == NULL) || (amp_aux == NULL)){
        return HSSL_NULL_PTR;
    }

    ds__hmem dsl_mem = m_make_mem_struct(amp_aux, 
                                         vpp_userfld,
                                         HMEM_NO_POOLS_FLAG_BIT);

    CFG_STRU* pCfgStruc = static_cast<CFG_STRU*>(avop_config);

    FreeCfgStruct(&dsl_mem, pCfgStruc);  // free configuration
    return(HSSL_OP_OK);
}

extern "C" int m_se_registerconfig(char* pConfigDataBuf,
                                   int ConfigDataLen,
                                   char* pCertDataBuf, 
                                   int CertDataLen,
                                   char* pPwdBuf,
                                   int PwdLen,
                                   BOOL PwdFileFlag,
			                       struct dsd_hl_ocsp_d_1 * OcspList,
	                               BOOL (* amp_aux) (void *vpp_userfld,int,void *, int),
                                   void * vpp_userfld,
                                   void ** ppConfigID,
                                   BOOL bop_use_aux_seeding)
{
  if(bop_use_aux_seeding){
      m_init_random_aux(amp_aux, vpp_userfld);
  }
  return(m_registerconfig(pConfigDataBuf, ConfigDataLen,
			  pCertDataBuf, CertDataLen,
			  pPwdBuf, PwdLen, PwdFileFlag,
			  OcspList, amp_aux, vpp_userfld,
			  ppConfigID));
}

extern "C" int m_cl_registerconfig(char* pConfigDataBuf, 
                                   int ConfigDataLen,
                                   char* pCertDataBuf,
                                   int CertDataLen,
                                   char* pPwdBuf,
                                   int PwdLen,
                                   BOOL PwdFileFlag,
                                   struct dsd_hl_ocsp_d_1 * OcspList,
                                   BOOL (* amp_aux) (void *vpp_userfld,int,void *, int),
                                   void * vpp_userfld,
                                   void ** ppConfigID,
                                   BOOL bop_use_aux_seeding)
{
  int Retcode;
  int Entity;
  int CfgFileType;
  int PwdDuplicateFlag = 0;
  int pTmpLong[1];
  
  CFG_STRU * pCfgStruc;
  CFG_STRU * pTmpCfgStruc[1];

  HMEM_CTX_DEF1;

  ds__hmem CtxStruc = m_make_mem_struct(amp_aux,
                                        vpp_userfld,
                                        HMEM_NO_POOLS_FLAG_BIT);

  LOAD_HMEM_CTX_PTR(&CtxStruc);

  if(bop_use_aux_seeding){
      m_init_random_aux(amp_aux, vpp_userfld);
  }
  //------------------------------------------------------
  // Check which configuration file type was supplied...
  //------------------------------------------------------
  if(ConfigDataLen < FILE_HEADER_LEN)
    return(HSSL_CFG_READ_FAILED);

  Retcode = GetConfigHeaderInfo(pConfigDataBuf,0,FILE_HEADER_LEN,HQRY_CFG_FILETYPE,pTmpLong);
  if(Retcode != HSSL_OP_OK)
    return(HSSL_CFG_READ_FAILED);

  CfgFileType = (int) pTmpLong[0];

  if(CfgFileType == FILE_TYPE_SRVR_CFG)
  {
    Entity = SERVER_ENTITY;
  }
  else if(CfgFileType == FILE_TYPE_CLNT_CFG)
  {
    Entity = CLIENT_ENTITY;
  }
  else
  {
    return(HSSL_CFG_READ_FAILED);
  }

  //------------------------------------------------------
  // Process Configuration and Certificates for given data
  //------------------------------------------------------

  if(PwdFileFlag != 0)			// Password is from a File
    PwdDuplicateFlag = -1;		// use also for Certificates
  Retcode = HSSL_Init(HMEM_CTX_REF1
		      pConfigDataBuf, ConfigDataLen, pCertDataBuf, CertDataLen,
		      pPwdBuf, PwdLen, pPwdBuf, PwdLen, PwdFileFlag,
		      PwdDuplicateFlag, Entity, 1, pTmpCfgStruc);
  if(Retcode != HSSL_OP_OK)
  {
    MEMMGR_FREE(HMEM_CTX_REF);
    return(Retcode);
  }
  pCfgStruc = pTmpCfgStruc[0];
  if(pCfgStruc->Entity == SERVER_ENTITY)	// is from server...
  {
    // perhaps more flags need to be changed ...
    pCfgStruc->Entity = CLIENT_ENTITY;	// set to act as client !
  }
  //---------------------------------------------------------------------
  // Save memory context to structure (!)
  //---------------------------------------------------------------------
  memcpy(&pCfgStruc->CfgMemCtxStruc,vp__ctx,sizeof(ds__hmem));
  pCfgStruc->pCfgMemCtx = &pCfgStruc->CfgMemCtxStruc;

  //---------------------------------------------------------------------
  // Get OCSP 'configuration' from XH-Interface, use as override later...
  //---------------------------------------------------------------------
  pCfgStruc->pXhConnStrucList = OcspList;
  if(OcspList != NULL)				// configuration given
  {
    pCfgStruc->ExtConf2Flags |= ENABLE_USE_OCSP_BIT_MASK; // force enable
  }
  else						// no configuration given
  {
    if((pCfgStruc->ExtConf2Flags & ENABLE_USE_OCSP_BIT_MASK) != 0)
    {
      FreeCfgStruct(HMEM_CTX_REF1 pCfgStruc);  // free configuration
      return(HSSL_INIT_OCSP_DATA_MISSING);
    }
  }
  //---------------------------------------------------------------------
  // Initialize Client Session cache if caching enabled
  //---------------------------------------------------------------------
  pCfgStruc->ExtConfigFlags &= (~SESS_CACHE_BIT_MASK); // disable caching

  if((pCfgStruc->ExtConfigFlags & SESS_CACHE_BIT_MASK) != 0)
  {
    Retcode = CheckAuxCMASupport(HMEM_CTX_REF1 CLIENT_CACHE_TYPE);
    if(Retcode <= 0)				// no support for CMA
      pCfgStruc->ExtConfigFlags &= (~SESS_CACHE_BIT_MASK); // disable caching
    else
    {
      // Bit 31-24 of cache aging time are used as elementcount * 256
      // ----- Bit 23-0  are time in minutes
      SetSessionCacheInitParams(CLIENT_CACHE_TYPE,
			   ((pCfgStruc->CacheAgingTime >> 24) & 0x0FF)*256,
			   (pCfgStruc->CacheAgingTime & 0x0FFFFFF) *60);
    }
  }

  pCfgStruc->pCfgMemCtx->in__flags |= HMEM_LOCKED_STRUC_FLAG_BIT;

  ppConfigID[0] = pCfgStruc;
  return(HSSL_OP_OK);
}

/**
*  Generates a newly allocated struct dsd_ssl_query_info structure from a given connection
*  structure.
*
*  @param adsp_conn_stru   The connection structure to generate the info from
*
*  @return Newly allocated and filled info struct. NULL on alloc error.
*/
static  struct dsd_ssl_query_info*  m_generate_hssl_queryinfo(HMEM_CTX_DEF CONNSTRU * adsp_conn_stru)
{
   struct dsd_ssl_query_info* adsl_qinfo = 
      (struct dsd_ssl_query_info*)BIT8_ARRAY_ALLOC(HMEM_CTX_REF,sizeof(struct dsd_ssl_query_info));
   unsigned char ucl_partner_name_len =0;

   if(adsl_qinfo == NULL){ //Allocation failed
      return NULL;
   }
   //init to all 0
   memset(adsl_qinfo, 0,sizeof(struct dsd_ssl_query_info));
   // Written data counters
   adsl_qinfo->unc_app_tx_data_msw = htonl(adsp_conn_stru->AppTXDataMSW);
   adsl_qinfo->unc_app_tx_data_lsw = htonl(adsp_conn_stru->AppTXDataLSW);
   adsl_qinfo->unc_app_rx_data_msw = htonl(adsp_conn_stru->AppRXDataMSW);
   adsl_qinfo->unc_app_rx_data_lsw = htonl(adsp_conn_stru->AppRXDataLSW);
   adsl_qinfo->unc_comp_tx_data_msw = htonl(adsp_conn_stru->ComprTXDataMSW);
   adsl_qinfo->unc_comp_tx_data_lsw = htonl(adsp_conn_stru->ComprTXDataLSW);
   adsl_qinfo->unc_comp_rx_data_msw = htonl(adsp_conn_stru->ComprRXDataMSW);
   adsl_qinfo->unc_comp_rx_data_lsw = htonl(adsp_conn_stru->ComprRXDataLSW);
   adsl_qinfo->unc_pure_tx_data_msw = htonl(adsp_conn_stru->TXDataMSW);
   adsl_qinfo->unc_pure_tx_data_lsw = htonl(adsp_conn_stru->TXDataLSW);
   adsl_qinfo->unc_pure_rx_data_msw = htonl(adsp_conn_stru->RXDataMSW);
   adsl_qinfo->unc_pure_rx_data_lsw = htonl(adsp_conn_stru->RXDataLSW);
   // Protocol and cipher information
   adsl_qinfo->ucc_protocol = adsp_conn_stru->ActualProtocol;
   adsl_qinfo->ucc_compr_method = adsp_conn_stru->ActualComprMethod;
   adsl_qinfo->usc_cipher_suite = htons(adsp_conn_stru->ActualCipherSuite);
   adsl_qinfo->ucc_key_exchange = adsp_conn_stru->KeyExchgMode;
   adsl_qinfo->ucc_cipher_algo = adsp_conn_stru->CipherAlgor;
   adsl_qinfo->ucc_cipher_type = adsp_conn_stru->CipherType;
   adsl_qinfo->ucc_mac_algo = adsp_conn_stru->MacAlgorType;
   adsl_qinfo->ucc_us_export = adsp_conn_stru->IsExportable;
   adsl_qinfo->ucc_authenticate = adsp_conn_stru->CertifiedFlags;
   adsl_qinfo->ucc_session_init_mode = adsp_conn_stru->CacheMode;
   // Server and client adresses
   adsl_qinfo->ucc_server_port_h = (unsigned char)(adsp_conn_stru->ServerPort >> 8);
   adsl_qinfo->ucc_server_port_l = (unsigned char)(adsp_conn_stru->ServerPort & 0xff);
   memcpy(adsl_qinfo->ucrc_server_ip_address, adsp_conn_stru->ServerIPAdr, IP_ADR_MAXLEN+1);
   memcpy(adsl_qinfo->ucrc_client_ip_address, adsp_conn_stru->ClientIPAdr, IP_ADR_MAXLEN+1);
   memcpy(adsl_qinfo->ucrc_session_id, adsp_conn_stru->SessionID, 33);
   // Partner name from Certificate
   if(adsp_conn_stru->pPartnerName != NULL)
   {// Get name length in bytes
      if((*(adsp_conn_stru->pPartnerName+1)) < 127){
         ucl_partner_name_len = (*(adsp_conn_stru->pPartnerName+1))*2;	// to byte count
      }else{// limit to 254 bytes
         ucl_partner_name_len = 254;
      }
   }
   adsl_qinfo->ucc_partner_name_length =ucl_partner_name_len;
   memcpy(adsl_qinfo->ucrc_partner_name, adsp_conn_stru->pPartnerName+2,ucl_partner_name_len);

   //write version number
   switch(adsp_conn_stru->ActualProtocol){ // Encoded protocol version
     case TLS_V2_PROT_TYPE:
        adsl_qinfo->imc_ssl_tls_prot_vers = 0x20102;
        break;
     case TLS_V1_PROT_TYPE:
        adsl_qinfo->imc_ssl_tls_prot_vers = 0x20101;
        break;
     case TLS_PROT_TYPE:
        adsl_qinfo->imc_ssl_tls_prot_vers = 0x20100;
        break;
     case SSL_PROT_TYPE:
        adsl_qinfo->imc_ssl_tls_prot_vers = 0x10300;
        break;
   }
   return (adsl_qinfo);
}

#if XH_INTF_VERSION < 300
/**
* Generate configuration and connection data, Client certificate's
* SHA1 hash, put to new structure and do a callback (GetReturnConnectionData2New).
*
*  @param XIF2Structu Connection control structure
*  @return 0 on success, else error occured
*/
static  int  GetReturnConnectionData2New(
				struct dsd_hl_ssl_s_2 * XIF2Structu)
{
  int Retcode;
  int ConfigDataLen;
  int CertDataLen;

  char* pCfgDataBuf = NULL;
  struct dsd_ssl_query_info* pConnDataBuf = NULL;
  char* pCertData;

  XHCONNSTRUC * pXhConnStruc;
  CONNSTRU * pConnStruc;
  CFG_STRU * pCfgStruc;
  int pTmpLen[1];

  struct dsd_hl_ssl_ccb_1 Xh2CbParStruc;

  int SHA1Array[SHA_ARRAY_SIZE];
  char ClientCertSha1HashBuf[SHA_DIGEST_LEN];

  HMEM_CTX_DEF1;

  //----------------------------------------------
  // load pointers, check if all present
  //----------------------------------------------
  if(XIF2Structu == NULL)
    return(HSSL_NULL_PTR);
  pXhConnStruc = (XHCONNSTRUC *) XIF2Structu->ac_ext; // get access structure
  if(pXhConnStruc == NULL)
    return(HSSL_NULL_PTR);
  pConnStruc = pXhConnStruc->pConnStruc;	// get connection structure
  pCfgStruc  = pConnStruc->pCfgStruc;

  LOAD_HMEM_CTX_PTR(CONN_pMemCtx(pConnStruc));

  memset(&Xh2CbParStruc,0,sizeof(struct dsd_hl_ssl_ccb_1));
  //----------------------------------------------
  // Get needed Buffer Sizes
  //----------------------------------------------
  Retcode = HLSSL_GetConfigQueryData(pCfgStruc,NULL,pTmpLen);
  if(Retcode != HSSL_OP_OK)
    return(Retcode);
  ConfigDataLen = pTmpLen[0];

  //------------------------------------------------------
  // Allocate the buffers, fill with data, do the callback
  //------------------------------------------------------
  for(;;)
  {
    pCfgDataBuf  = BIT8_ARRAY_ALLOC(HMEM_CTX_REF,ConfigDataLen);
    
    if((pCfgDataBuf == NULL))
    {
      Retcode = HSSL_ALLOC_ERR;
      break;
    }
    pTmpLen[0] = ConfigDataLen;
    Retcode = HLSSL_GetConfigQueryData(pCfgStruc,pCfgDataBuf,pTmpLen);
    if(Retcode != HSSL_OP_OK)
      break;

    pConnDataBuf = m_generate_hssl_queryinfo(HMEM_CTX_REF1 pConnStruc);
    if((pCfgDataBuf == NULL))
    {
      Retcode = HSSL_ALLOC_ERR;
      break;
    }
    
    Xh2CbParStruc.ac_conndata = pConnDataBuf;

    //--------------------------------------------------------------
    // Generate the SHA1 hash for client certificate if present
    //--------------------------------------------------------------
    pCertData = pConnStruc->pPartnerCert;
    CertDataLen = pConnStruc->PartnerCertLen;   
    if((pCertData != NULL) && (CertDataLen > 0))
    {
      //---------------------------------------------------
      // Hash the client certificate with SHA1
      //---------------------------------------------------
      SHA1_Init(SHA1Array);
      SHA1_Update(SHA1Array,pCertData,0,CertDataLen);
      SHA1_Final(SHA1Array,ClientCertSha1HashBuf,0);
//      memcpy(CONN_PartnerCertHash(pConnStruc),
//             ClientCertSha1HashBuf,SHA_DIGEST_LEN);
      //----------------------------------------------------
      // set the certificate parameters to structure		
      //----------------------------------------------------
      Xh2CbParStruc.achc_fingerprint    = ClientCertSha1HashBuf;
      Xh2CbParStruc.achc_certificate      = pCertData;
      Xh2CbParStruc.inc_len_certificate    = CertDataLen;
    }      
    else if((pConnStruc->CertifiedFlags & CLIENT_CERTIFIED_MASK) != 0)
    {
      // only the Hash is present (resumed/cloned connection)
      memcpy(ClientCertSha1HashBuf,pConnStruc->PartnerCertHash,
             SHA_DIGEST_LEN);
      Xh2CbParStruc.achc_fingerprint    = ClientCertSha1HashBuf;
    }

    // Set PFS flag
    Xh2CbParStruc.boc_pfs_used = (pConnStruc->KeyExchgMode == KEY_EXCHANGE_DHE_DSS) ||
                                 (pConnStruc->KeyExchgMode == KEY_EXCHANGE_DHE_RSA);

    //---------------------------------------------------------
    // All data have been setup, do the callback now
    // The following is subject to modification !!!
    //---------------------------------------------------------
    Xh2CbParStruc.vpc_userfld = XIF2Structu->vpc_userfld;

    XIF2Structu->amc_conn_callback(&Xh2CbParStruc);
    break;
  }
  FREE_ARRAY(HMEM_CTX_REF,pCfgDataBuf);
  FREE_ARRAY(HMEM_CTX_REF,pConnDataBuf);
  return(Retcode);
}
#endif // XH_INTF_VERSION < 300

#if XH_INTF_VERSION >= 300
/**
* Generate configuration and connection data, Client certificate's
* SHA1 hash, put to new structure and do a callback (GetReturnConnectionData3).
*
*  @param XIF3Structu Connection control structure
*  @return 0 on success, else error occured
*/
static  int  GetReturnConnectionData3(
				struct dsd_hl_ssl_s_3 * XIF3Structu)
{
  int Retcode;
  int ConfigDataLen;
  int CertDataLen;

  char* pCfgDataBuf = NULL;
  struct dsd_ssl_query_info* pConnDataBuf = NULL;
  char* pCertData;

  XHCONNSTRUC * pXhConnStruc;
  CONNSTRU * pConnStruc;
  CFG_STRU * pCfgStruc;
  int pTmpLen[1];

  struct dsd_hl_ssl_ccb_1 Xh3CbParStruc;

  int SHA1Array[SHA_ARRAY_SIZE];
  char ClientCertSha1HashBuf[SHA_DIGEST_LEN];

  HMEM_CTX_DEF1;

  //----------------------------------------------
  // load pointers, check if all present
  //----------------------------------------------
  if(XIF3Structu == NULL)
    return(HSSL_NULL_PTR);
  pXhConnStruc = (XHCONNSTRUC *) XIF3Structu->ac_ext;	// get access structure
  if(pXhConnStruc == NULL)
    return(HSSL_NULL_PTR);
  pConnStruc = pXhConnStruc->pConnStruc;		// get connection structure
  pCfgStruc  = pConnStruc->pCfgStruc;

  LOAD_HMEM_CTX_PTR(CONN_pMemCtx(pConnStruc));

  memset(&Xh3CbParStruc,0,sizeof(struct dsd_hl_ssl_ccb_1));
  //----------------------------------------------
  // Get needed Buffer Sizes
  //----------------------------------------------
  Retcode = HLSSL_GetConfigQueryData(pCfgStruc,NULL,pTmpLen);
  if(Retcode != HSSL_OP_OK)
    return(Retcode);
  ConfigDataLen = pTmpLen[0];

  //------------------------------------------------------
  // Allocate the buffers, fill with data, do the callback
  //------------------------------------------------------
  for(;;)
  {
    pCfgDataBuf  = BIT8_ARRAY_ALLOC(HMEM_CTX_REF,ConfigDataLen);

    if(pCfgDataBuf == NULL)
    {
      Retcode = HSSL_ALLOC_ERR;
      break;
    }
    pTmpLen[0] = ConfigDataLen;
    Retcode = HLSSL_GetConfigQueryData(pCfgStruc,pCfgDataBuf,pTmpLen);
    if(Retcode != HSSL_OP_OK)
      break;

    pConnDataBuf = m_generate_hssl_queryinfo(HMEM_CTX_REF1 pConnStruc);
    if(pCfgDataBuf == NULL)
    {
      Retcode = HSSL_ALLOC_ERR;
      break;
    }

    Xh3CbParStruc.ac_conndata = pConnDataBuf;

    //--------------------------------------------------------------
    // Generate the SHA1 hash for client certificate if present
    //--------------------------------------------------------------
    pCertData = pConnStruc->pPartnerCert;
    CertDataLen = pConnStruc->PartnerCertLen;   
    if((pCertData != NULL) && (CertDataLen > 0))
    {
      //---------------------------------------------------
      // Hash the client certificate with SHA1
      //---------------------------------------------------
      SHA1_Init(SHA1Array);
      SHA1_Update(SHA1Array,pCertData,0,CertDataLen);
      SHA1_Final(SHA1Array,ClientCertSha1HashBuf,0);
//      memcpy(CONN_PartnerCertHash(pConnStruc),
//             ClientCertSha1HashBuf,SHA_DIGEST_LEN);
      //----------------------------------------------------
      // set the certificate parameters to structure		
      //----------------------------------------------------
      Xh3CbParStruc.achc_fingerprint          = ClientCertSha1HashBuf;
      Xh3CbParStruc.achc_certificate          = pCertData;
      Xh3CbParStruc.inc_len_certificate       = CertDataLen;
    }      
    else if((pConnStruc->CertifiedFlags & CLIENT_CERTIFIED_MASK) != 0)
    {
      // only the Hash is present (resumed/cloned connection)
      memcpy(ClientCertSha1HashBuf,pConnStruc->PartnerCertHash,
             SHA_DIGEST_LEN);
      Xh3CbParStruc.achc_fingerprint          = ClientCertSha1HashBuf;
    }

    // Set PFS flag
    Xh3CbParStruc.boc_pfs_used = (pConnStruc->KeyExchgMode == KEY_EXCHANGE_DHE_DSS) ||
                                 (pConnStruc->KeyExchgMode == KEY_EXCHANGE_DHE_RSA) ||
                                 (pConnStruc->KeyExchgMode == KEY_EXCHANGE_ECDHE_RSA);

    //---------------------------------------------------------
    // All data have been setup, do the callback now
    // The following is subject to modification !!!
    //---------------------------------------------------------
    Xh3CbParStruc.vpc_userfld = XIF3Structu->vpc_userfld;

    XIF3Structu->amc_conn_callback(&Xh3CbParStruc);
    break;
  }
  FREE_ARRAY(HMEM_CTX_REF,pCfgDataBuf);
  FREE_ARRAY(HMEM_CTX_REF,pConnDataBuf);
  return(Retcode);
}
#endif // XH_INTF_VERSION >= 300

/**
* Generate configuration and connection data, Server certificate's
* SHA1 hash, put to new structure and do a callback, client (GetReturnConnectionDataCL).
*
*  @param XIFCLStructu Connection control structure
*  @return 0 on success, else error occured
*/
static  int  GetReturnConnectionDataCL(
				struct dsd_hl_ssl_c_1 * XIFCLStructu)
{
  int Retcode;
  int ConfigDataLen;
  int CertDataLen;

  char* pCfgDataBuf = NULL;
  struct dsd_ssl_query_info*  pConnDataBuf = NULL;
  char* pCertData;

  XHCONNSTRUC * pXhConnStruc;
  CONNSTRU * pConnStruc;
  CFG_STRU * pCfgStruc;
  int pTmpLen[1];

  struct dsd_hl_ssl_ccb_1 XhClCbParStruc;

  int SHA1Array[SHA_ARRAY_SIZE];
  char ClientCertSha1HashBuf[SHA_DIGEST_LEN];

  HMEM_CTX_DEF1;

  //----------------------------------------------
  // load pointers, check if all present
  //----------------------------------------------
  if(XIFCLStructu == NULL)
    return(HSSL_NULL_PTR);
  pXhConnStruc = (XHCONNSTRUC *) XIFCLStructu->vpc_ext;		// get access structure
  if(pXhConnStruc == NULL)
    return(HSSL_NULL_PTR);
  pConnStruc = pXhConnStruc->pConnStruc;	// get connection structure
  pCfgStruc  = pConnStruc->pCfgStruc;

  LOAD_HMEM_CTX_PTR(CONN_pMemCtx(pConnStruc));

  memset(&XhClCbParStruc,0,sizeof(struct dsd_hl_ssl_ccb_1));
  //----------------------------------------------
  // Get needed Buffer Sizes
  //----------------------------------------------
  Retcode = HLSSL_GetConfigQueryData(pCfgStruc,NULL,pTmpLen);
  if(Retcode != HSSL_OP_OK)
    return(Retcode);
  ConfigDataLen = pTmpLen[0];

  //------------------------------------------------------
  // Allocate the buffers, fill with data, do the callback
  //------------------------------------------------------
  for(;;)
  {
    pCfgDataBuf  = BIT8_ARRAY_ALLOC(HMEM_CTX_REF,ConfigDataLen);

    if(pCfgDataBuf == NULL)
    {
      Retcode = HSSL_ALLOC_ERR;
      break;
    }
    pTmpLen[0] = ConfigDataLen;
    Retcode = HLSSL_GetConfigQueryData(pCfgStruc,pCfgDataBuf,pTmpLen);
    if(Retcode != HSSL_OP_OK)
      break;

    pConnDataBuf = m_generate_hssl_queryinfo(HMEM_CTX_REF1 pConnStruc);
    if(pConnDataBuf == NULL)
    {
      Retcode = HSSL_ALLOC_ERR;
      break;
    }

    XhClCbParStruc.ac_conndata = pConnDataBuf;

    //--------------------------------------------------------------
    // Generate the SHA1 hash for server certificate if present
    //--------------------------------------------------------------
    pCertData = pConnStruc->pPartnerCert;
    CertDataLen = pConnStruc->PartnerCertLen;   
    if((pCertData != NULL) && (CertDataLen > 0))
    {
      //---------------------------------------------------
      // Hash the client certificate with SHA1
      //---------------------------------------------------
      SHA1_Init(SHA1Array);
      SHA1_Update(SHA1Array,pCertData,0,CertDataLen);
      SHA1_Final(SHA1Array,ClientCertSha1HashBuf,0);
//      memcpy(CONN_PartnerCertHash(pConnStruc),
//             ClientCertSha1HashBuf,SHA_DIGEST_LEN);
      //----------------------------------------------------
      // set the certificate parameters to structure		
      //----------------------------------------------------
      XhClCbParStruc.achc_fingerprint    = ClientCertSha1HashBuf;
      XhClCbParStruc.achc_certificate    = pCertData;
      XhClCbParStruc.inc_len_certificate = CertDataLen;
    }      
    else if((pConnStruc->CertifiedFlags & SERVER_CERTIFIED_MASK) != 0)
    {
      // only the Hash is present (resumed/cloned connection)
      memcpy(ClientCertSha1HashBuf,pConnStruc->PartnerCertHash,
             SHA_DIGEST_LEN);
      XhClCbParStruc.achc_fingerprint    = ClientCertSha1HashBuf;
    }
    
    // Set PFS flag
    XhClCbParStruc.boc_pfs_used = (pConnStruc->KeyExchgMode == KEY_EXCHANGE_DHE_DSS) ||
                                 (pConnStruc->KeyExchgMode == KEY_EXCHANGE_DHE_RSA) ||
                                 (pConnStruc->KeyExchgMode == KEY_EXCHANGE_ECDHE_RSA);

    //---------------------------------------------------------
    // All data have been setup, do the callback now
    // The following is subject to modification !!!
    //---------------------------------------------------------
    XhClCbParStruc.vpc_userfld = XIFCLStructu->vpc_userfld;

    XIFCLStructu->amc_conn_callback(&XhClCbParStruc);
    break;
  }
  FREE_ARRAY(HMEM_CTX_REF,pCfgDataBuf);
  FREE_ARRAY(HMEM_CTX_REF,pConnDataBuf);
  return(Retcode);
}

#if !defined XH_DUMMY
/**
* Get the connect time out from a registered configuration (GetReturnConnectTimeout).
* 
*
*  @param pConfigID the connection ID (pointer!)
*  @return Timeout, if < 0 error occured
*/
static  int  GetReturnConnectTimeout(CFG_STRU* pConfigID)
{
    if(pConfigID == NULL){
        return(HSSL_NULL_PTR);  
    }

    return (int) pConfigID->ConnectTimeout & 0x0FFFF;
}

/**
* Gets the connect time out from a registered configuration,
* server side (m_se_get_conf_timeout).
* 
*
*  @param vpp_config_id pointer to config ID.
*  @return Timeout, 0 on error
*/
extern "C"  int m_se_get_conf_timeout(void * vpp_config_id)
{
  int Timeout;

  Timeout = GetReturnConnectTimeout((CFG_STRU *) vpp_config_id);

  if(Timeout < 0)
    return(0);

  if(Timeout == 0)			// no timeout specified
  {
    return(0x7FFFFFFF);
  }
  return(Timeout);
}
/**
* Gets the connect time out from a registered configuration,
* client side (m_cl_get_conf_timeout).
*
* Merely a wrapper to the server related routine.
*
*  @param vpp_config_id pointer to config ID. Cast to int*
*  @return Timeout, 0 on error
*/
extern "C"  int m_cl_get_conf_timeout(void * vpp_config_id)
{
  return(m_se_get_conf_timeout(vpp_config_id));
}

#else // XH_DUMMY is set...

/**
* Dummy Get the connect time out from a registered configuration,
* server side (m_se_get_conf_timeout).
* 
*
*  @param vpp_config_id pointer to config ID
*  @return Timeout, if 0 error occured
*/
extern "C"  int m_se_get_conf_timeout(void * vpp_config_id)
{
  vpp_config_id = vpp_config_id;
  return(60);
}
/**
* Dummy Get the connect time out from a registered configuration,
* client side (m_cl_get_conf_timeout).
* Merely a wrapper to the server related routine.
*
*  @param vpp_config_id pointer to config ID
*  @return Timeout, if 0 error occured
*/
extern "C"  int m_cl_get_conf_timeout(void * vpp_config_id)
{
  return(m_se_get_conf_timeout(vpp_config_id));
}
#endif // !defined XH_DUMMY
#endif // XH_INTERFACE

//======================================================================

#if defined XH_INTERFACE
//()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()
//()								()
//()	New Version (V2) of the HOBLink/HOBCom Server Interface	()
//()								()
//()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()

#if !defined XH_DUMMY
#if XH_INTF_VERSION < 300
//*********************************************************
//
// The HOBLink/HOBCom Server Interface as defined by
// Mr. Klaus Brandstaetter, V2
//
//*********************************************************
struct dsd_hl_ssl_s_2;

void m_hlse02(struct dsd_hl_ssl_s_2 * pXIF2Structu)
{
  int Retcode;
  int ConnCfgID;

  int pTmpContStat[1];
  int pTmpReason[1];
 
  XHCONNSTRUC * pXhConnStruc;
  CONNSTRU * pConnStruc;
  CFG_STRU * pCfgStruc;

  ds__hmem TmpMemCtxStruc;
  
  struct dsd_hl_ssl_s_2 * XIF2Structu = pXIF2Structu;

  HMEM_CTX_DEF1;

  //-----------------------------------------
  // Check parameters
  //-----------------------------------------
  if(XIF2Structu == NULL)
    return;

  LOAD_HMEM_CTX_PTR(NULL);

  //+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  // Distribute by caller requested function code
  //+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  switch(XIF2Structu->inc_func)
  {
    //=======================================================
    // A) Connection Startup, check if valid...
    //=======================================================
    case DEF_IFUNC_START:
      if(XIF2Structu->ac_ext != NULL)	// already have a connection!
      {

        XIF2Structu->inc_return = HSSL_NEWCONN_STATE_ERR; // already connecting...
        return;
      }
      pCfgStruc = (CFG_STRU *) XIF2Structu->ac_config_id;

      if(pCfgStruc  == NULL)
      {
        // Replace the errror code below !!!
        XIF2Structu->inc_return = HSSL_NEWCONN_STATE_ERR; // already connecting...
        return;
      }

      TmpMemCtxStruc = m_make_mem_struct(XIF2Structu->amc_aux, 
                                         XIF2Structu->vpc_userfld,
                                         0);
      LOAD_HMEM_CTX_PTR(&TmpMemCtxStruc);	// get correct context !!

      XIF2Structu->inc_func = DEF_IFUNC_CONT;  // Force Continue next...

      //-------------------------------------------
      // Seed the PRNG with entropy
      //-------------------------------------------
      CTR_DRBG_AddSeed256((char *) &XIF2Structu->ilc_entropy,sizeof(long long));

      //--------------------------------------------------------------
      // Get a connection structure to use, set up handshake data
      // to send, signal send data available, save state, send data
      //--------------------------------------------------------------
      Retcode = XH2SSL_Accept(HMEM_CTX_REF1
			      XIF2Structu,pCfgStruc);
      XIF2Structu->inc_return = Retcode;
      if(Retcode != HSSL_OP_OK)  
      {
         CleanupCaches(HMEM_CTX_REF1
		       ((XHCONNSTRUC *) XIF2Structu->ac_ext)->pConnStruc,
		       Retcode);

//        FreeCfgStruct(pCfgStruc[0]);		// MUST BE KEPT !!!
      }
      else
      {
        XIF2Structu->inc_func = DEF_IFUNC_CONT;	// Force Continue next...
      } 
      return;
    //=======================================================
    // B) Continuation, check what to do now....
    //=======================================================
    case DEF_IFUNC_CONT:
      //----------------------------------------------
      // Check if we have a connection state structure
      //----------------------------------------------
      pXhConnStruc = (XHCONNSTRUC *) XIF2Structu->ac_ext; // get connection structure
      if(pXhConnStruc == NULL)			// not allocated
      {
        XIF2Structu->inc_return = HSSL_XH_NOT_INITIALIZED_ERR; // report error
        return;
      }

      pConnStruc = pXhConnStruc->pConnStruc;	// get connection structure

      pConnStruc->pMemCtxStruc->vp__context = XIF2Structu->vpc_userfld;

      LOAD_HMEM_CTX_PTR(pConnStruc->pMemCtxStruc);
      //----------------------------------------------
      // Check if the server side socket is still open
      //----------------------------------------------
#if defined _WIN32
      if(XIF2Structu->boc_eof_server != 0)	// no socket for send data
#else
      if(XIF2Structu->boc_eof_client != 0)	// no socket for send data
#endif
      {
        CleanupCaches(HMEM_CTX_REF1 pConnStruc,XIF2Structu->inc_return);
        XH2SSL_Disconnect(XIF2Structu);

// Removed 28.11.2006 G.O. check that !!
//        FreeXH2ConnStateStruct(HMEM_CTX_REF1 XIF2Structu);// free all used...
        return;
      }
      //----------------------------------------------
      // Check if the client side socket was closed
      //----------------------------------------------
#if defined _WIN32
      if(XIF2Structu->boc_eof_client != 0)	// client side closed!
#else
      if(XIF2Structu->boc_eof_server != 0)	// client side closed!
#endif
      {
        CleanupCaches(HMEM_CTX_REF1 pConnStruc,XIF2Structu->inc_return);
        XH2SSL_Disconnect(XIF2Structu);
//        FreeXH2ConnStateStruct(HMEM_CTX_REF1 XIF2Structu);// free all used...
        return;
      }

      //----------------------------------------------
      // 1. Check if Handshake phase is still active
      //----------------------------------------------
      for(;;)
      {
        if((pXhConnStruc->XHConnState == XH_STATE_CONNECT_START) ||
           (pXhConnStruc->XHConnState == XH_STATE_CONNECT_SEND) ||
           (pXhConnStruc->XHConnState == XH_STATE_CONNECT_WAIT) ||
           (pXhConnStruc->XHConnState == XH_STATE_CONNECT_ALERT) ||
           (pXhConnStruc->XHConnState == XH_STATE_CONNECT_CLOSING))
        {
          Retcode = XH2DoHandshake(XIF2Structu);
          XIF2Structu->inc_return = Retcode;
          if(Retcode != HSSL_OP_OK)
          {
            CleanupCaches(HMEM_CTX_REF1 pXhConnStruc->pConnStruc,Retcode);
            FreeXH2ConnStateStruct(HMEM_CTX_REF1 XIF2Structu); // free all used...
	    return;
          }
          XH2SSL_Send(HMEM_CTX_REF1 XIF2Structu);	// queue send data
          if(pXhConnStruc->XHConnState == XH_STATE_NORMAL)  // now connected
          {
	    if(XIF2Structu->amc_conn_callback != NULL) // do a callback...
              GetReturnConnectionData2New(XIF2Structu);

            break;
          }
          if(XIF2Structu->achc_inp_cur == XIF2Structu->achc_inp_end) //no data
          {
            return;          
          }
        }
        else
        {
          break;
        }
      } // Handshake FOR
      //------------------------------------------------------------
      // 3. Check if Socket RX-Data are present
      //------------------------------------------------------------
      if(XIF2Structu->achc_inp_cur != XIF2Structu->achc_inp_end) // Sock.RX-Data
      {
        Retcode = HSSL_XH2Tcp_Receive(XIF2Structu, pTmpContStat);
        if(Retcode != HSSL_OP_OK)
        {
          CleanupCaches(HMEM_CTX_REF1 pXhConnStruc->pConnStruc,Retcode);

          FreeXH2ConnStateStruct(HMEM_CTX_REF1 XIF2Structu); // free all used...
          XIF2Structu->inc_return = Retcode;
          return;
        }
      }
      //------------------------------------------------------------
      // 4. Process Application TX-Data, if present
      //------------------------------------------------------------
      XH2SSL_Send(HMEM_CTX_REF1 XIF2Structu);	// queue send data
      //------------------------------------------------------------
      // 5. Process Socket TX (Postprocessing also done)
      // --- assure sending ALL data till buffer filled/no more Data ---
      //------------------------------------------------------------
      if((pConnStruc->TX_State != TCP_TX_INACTIVE)||// remaining TX data
	 (pConnStruc->pApplicationTxQueueHead != NULL) ||	// application data
         (pConnStruc->pPriorityTxQueueHead != NULL))	// priority data
      {
        for(;;)
        {
          Retcode = HSSL_XH2Tcp_Transmit(XIF2Structu, pTmpContStat,
				         pTmpReason);
          if(Retcode != HSSL_OP_OK)
          {
            CleanupCaches(HMEM_CTX_REF1 pXhConnStruc->pConnStruc,Retcode);

            XIF2Structu->inc_return = Retcode;
            FreeXH2ConnStateStruct(HMEM_CTX_REF1 XIF2Structu); // free all used...
            return;
          }
          if((XIF2Structu->achc_send_cur == 	// buffer is full...
              XIF2Structu->achc_send_end) ||
             ((pConnStruc->pApplicationTxQueueHead == NULL) && // no app. data
              (pConnStruc->pPriorityTxQueueHead == NULL)))  // no pri. data
          break;
        } // for
      }
      //------------------------------------------------------------
      // 6. Process Application RX
      //------------------------------------------------------------
      XH2SSL_Recv(XIF2Structu);
      XIF2Structu->inc_return = HSSL_OP_OK;
      return;
    //=======================================================
    // Unknown Command detected, signal error
    //=======================================================
    default:				// invalid operation requested
      XIF2Structu->inc_return = DEF_IRET_ERRAU;// set unspecific global error code
      return;
  } // function switch
}
#endif // XH_INTF_VERSION < 300

#endif // XH_DUMMY
#endif // XH_INTERFACE

//======================================================================
#if defined XH_INTERFACE && defined XH_DUMMY
//()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()
//()								()
//()     XH-Server Interface Dummy Routines, new Version	()
//()     does copy input to output , no SSL Processing is done	()
//()								()
//()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()
//*********************************************************
//
// The HOBLink/HOBCom Server Interface as defined, Version 2
//
//*********************************************************
void m_hlse02(struct dsd_hl_ssl_s_2 * pXIF2Structu)
{
  int SrcLen;
  int DstLen;
  int Retcode;
  int ConnCfgID;

  CFG_STRU * pCfgStruc;

  XIFSTRUC2 * XIF2Structu = (XIFSTRUC2 *) ((void *) pXIF2Structu);

  ds__hmem CtxStruc;

  HMEM_CTX_DEF1;

  //-----------------------------------------
  // Check parameters
  //-----------------------------------------
  if(XIF2Structu == NULL)
    return;

  CtxStruc = m_make_mem_struct(amp_aux, vpp_userfld, 0);
  LOAD_HMEM_CTX_PTR(&CtxStruc);

  //+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  // Distribute by caller requested function code
  //+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  XIF2Structu->inc_return = HSSL_OP_OK;
  switch(XIF2Structu->inc_func)
  {
    //=========================================================
    // A) Connection Startup, no operation except changing mode
    //=========================================================
    case DEF_IFUNC_START:
      pCfgStruc = (CFG_STRU *) XIF2Structu->ac_config_id;

      if(pCfgStruc  == NULL)
      {
        XIF2Structu->inc_return = HSSL_NEWCONN_STATE_ERR; // already connecting...
        return;
      }
      //--------------------------------------------------------------
      // Get a connection structure to use, set up handshake data
      // to send, signal send data available, save state, send data
      //--------------------------------------------------------------
      Retcode = XH2SSL_Accept(HMEM_CTX_REF,XIF2Structu,pCfgStruc);
      XIF2Structu->inc_return = Retcode;
      if(Retcode != HSSL_OP_OK)  
      {
        return;
      }
      else
      {
        XIF2Structu->inc_func = DEF_IFUNC_CONT;	// Force Continue next...
      } 
//      Sleep(5000);		// TEST TEST TEST
//      Sleep(2000);		// TEST TEST TEST

      if(XIF2_pQueryCallback(XIF2Structu) != NULL) // do a callback...
        GetReturnConnectionData2New(XIF2Structu);

      return;

    //=======================================================
    // B) Continuation, check what to do now....
    //=======================================================
    case DEF_IFUNC_CONT:
      //----------------------------------------------
      // Check if the server side socket is still open
      //----------------------------------------------
      if(XIF2_ServerEof(XIF2Structu) != 0)
      {
//        fprintf(stdout,"ContEntry: NoSock\n");
//        PRINT("HSSL Continue: NoSocket, ended\n");
        FreeXH2ConnStateStruct(HMEM_CTX_REF1 XIF2Structu);		// free all used...
        XIF2Structu->inc_return = DEF_IRET_END;	// ended !!
        return;
      }
      //----------------------------------------------
      // Check if the client side socket was closed
      //----------------------------------------------
      if(XIF2_ClientEof(XIF2Structu) != 0)	// client side closed!
      {
//        XH2SSL_Disconnect(XIF2Structu);
        FreeXH2ConnStateStruct(HMEM_CTX_REF1 XIF2Structu);		// free all used...
        XIF2Structu->inc_return = DEF_IRET_END;	// ended !!
        return;
      }
      //------------------------------------------------------------
      // 1. Check if Socket RX-Data are present
      //------------------------------------------------------------
      SrcLen = (int) (XIF2Structu->achc_inp_end - XIF2Structu->achc_inp_cur);
      DstLen = (int) (XIF2Structu->achc_out_end - XIF2Structu->achc_out_cur);
      if((SrcLen < 0) || (DstLen < 0))
      {
//       fprintf(stdout,"Sock/Appl RX-Datalen < 0\n");
//      XIF2Structu->inc_return = DEF_IRET_ERRAU; // not good !
        return;
      }
      if((SrcLen != 0) && (DstLen != 0))	// data to copy
      {
        if(DstLen < SrcLen)			// limit to buffer
          SrcLen = DstLen;

//      printf("\nSockDataCopy: %d",SrcLen);

        memcpy(XIF2Structu->achc_out_cur+0,XIF2Structu->achc_inp_cur+0,SrcLen);
        XIF2Structu->achc_inp_cur += SrcLen;
        XIF2Structu->achc_out_cur += SrcLen;
//        Sleep(200);		// TEST TEST TEST
//        Sleep(50);		// TEST TEST TEST
      }
      //------------------------------------------------------------
      // 2. Check if Application TX-Data present
      //------------------------------------------------------------
      SrcLen = GetXH2ListDataLen(XIF2Structu->adsc_gather_i_1);

      DstLen = XIF2Structu->achc_send_end - XIF2Structu->achc_send_cur;
      if((SrcLen < 0) || (DstLen < 0))
      {
//       fprintf(stdout,"Sock/Appl TX-Datalen < 0\n");
        XIF2Structu->inc_return = DEF_IRET_ERRAU;
        return;
      }
      if((SrcLen != 0) && (DstLen != 0))	// data to copy
      {
        if(DstLen < SrcLen)			// limit to buffer
          SrcLen = DstLen;

//      printf("\nApplDataCopy: %d",SrcLen);

        CopyXH2DataListToBuffer(XIF2Structu->adsc_gather_i_1,
				XIF2Structu->achc_send_cur,0,
				SrcLen);

        XIF2Structu->achc_send_cur += SrcLen;
//        Sleep(200);		// TEST TEST TEST
//        Sleep(50);		// TEST TEST TEST
      }
      return;
    //=======================================================
    // Unknown Command detected, signal error
    //=======================================================
    default:				// invalid operation requested
//      fprintf(stdout,"Unknown command\n");

      XIF2Structu->inc_return = DEF_IRET_ERRAU;// set unspecific global error code
      return;
  } // function switch
}
//*********************************************************
//
// The HOBLink/HOBCom Server Interface as defined, Version 3
//
//*********************************************************
extern "C" void m_hlse03(struct dsd_hl_ssl_s_3 * pXIF3Structu)
{
  int SrcLen;
  int DstLen;
  int Retcode;
  int ConnCfgID;

  CFG_STRU * pCfgStruc;

  XIFSTRUC3 * XIF3Structu = (XIFSTRUC3 *) ((void *) pXIF3Structu);

  ds__hmem CtxStruc;

  HMEM_CTX_DEF1;

  //-----------------------------------------
  // Check parameters
  //-----------------------------------------
  if(XIF3Structu == NULL)
    return;

  CtxStruc = m_make_mem_struct(XIF3_pHelperSr(XIF3Structu),
                               XIF3_pActualContext(XIF3Structu),
                               0);
  LOAD_HMEM_CTX_PTR(&CtxStruc);

  //+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  // Distribute by caller requested function code
  //+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  XIF3Structu->inc_return = HSSL_OP_OK;
  switch(XIF3Structu->inc_func)
  {
    //=========================================================
    // A) Connection Startup, no operation except changing mode
    //=========================================================
    case DEF_IFUNC_START:
      pCfgStruc = (CFG_STRU *) XIF3Structu->ac_config_id;

      if(pCfgStruc == NULL)
      {
        XIF3Structu->inc_return = HSSL_NEWCONN_STATE_ERR; // already connecting...
        return;
      }
      //-------------------------------------------
      // Seed the PRNG with entropy
      //-------------------------------------------
      CTR_DRBG_AddSeed256((char *) &XIF3Structu->ilc_entropy,sizeof(long long));

      //--------------------------------------------------------------
      // Get a connection structure to use, set up handshake data
      // to send, signal send data available, save state, send data
      //--------------------------------------------------------------
      Retcode = XH3SSL_Accept(HMEM_CTX_REF,XIF3Structu,pCfgStruc);
      XIF3Structu->inc_return = Retcode;
      if(Retcode != HSSL_OP_OK)  
      {
        return;
      }
      else
      {
        XIF3Structu->inc_func = DEF_IFUNC_CONT;	// Force Continue next...
      } 
//      Sleep(5000);		// TEST TEST TEST
//      Sleep(2000);		// TEST TEST TEST

      if(XIF3_pQueryCallback(XIF3Structu) != NULL) // do a callback...
        GetReturnConnectionData3(XIF3Structu);

      return;

    //=======================================================
    // B) Continuation, check what to do now....
    //=======================================================
    case DEF_IFUNC_CONT:
      //----------------------------------------------
      // Check if the server side socket is still open
      //----------------------------------------------
      if(XIF3Structu->boc_eof_server != 0)
      {
//        fprintf(stdout,"ContEntry: NoSock\n");
//        PRINT("HSSL Continue: NoSocket, ended\n");
        FreeXH3ConnStateStruct(HMEM_CTX_REF1 XIF3Structu);		// free all used...
        XIF3Structu->inc_return = DEF_IRET_END;		// ended !!
        return;
      }
      //----------------------------------------------
      // Check if the client side socket was closed
      //----------------------------------------------
      if(XIF3Structu->boc_eof_client != 0)	// client side closed!
      {
//        XH3SSL_Disconnect(XIF3Structu);	// no more sends possible!!!
        FreeXH3ConnStateStruct(HMEM_CTX_REF1 XIF3Structu);		// free all used...
        XIF3Structu->inc_return = DEF_IRET_END;	// ended !!
        return;
      }
      //------------------------------------------------------------
      // 1. Check if Socket RX-Data are present
      //------------------------------------------------------------
      SrcLen = GetXH2ListDataLen(XIF3_pSockRxList(XIF3Structu));

      DstLen = (int) (XIF3_pApplRxBufTop(XIF3Structu) -
                      XIF3_pApplRxBufBase(XIF3Structu));
      if((SrcLen < 0) || (DstLen < 0))
      {
//       fprintf(stdout,"Sock/Appl RX-Datalen < 0\n");
//      XIF3Structu->inc_return = DEF_IRET_ERRAU; // not good !
        return;
      }
      if((SrcLen != 0) && (DstLen != 0))	// data to copy
      {
        if(DstLen < SrcLen)			// limit to buffer
          SrcLen = DstLen;

//      printf("\nSockDataCopy: %d",SrcLen);

//        BIT8_ARRAY_COPY(XIF2Structu->achc_inp_cur,0,
//			  XIF2Structu->achc_out_cur,0, SrcLen);

        CopyXH2DataListToBuffer(XIF3_pSockRxList(pXif3Struc),
			XIF3_pApplRxBufBase(XIF3Structu),0,SrcLen);
        XIF3_pApplRxBufBase(XIF3Structu) += SrcLen;

//        Sleep(200);		// TEST TEST TEST
//        Sleep(50);		// TEST TEST TEST
      }
      //------------------------------------------------------------
      // 2. Check if Application TX-Data present
      //------------------------------------------------------------
      SrcLen = GetXH2ListDataLen(XIF3_pApplTxList(XIF3Structu));

      DstLen = XIF3_pSockTxBufTop(XIF3Structu) - 
               XIF3_pSockTxBufBase(XIF3Structu);
      if((SrcLen < 0) || (DstLen < 0))
      {
//       fprintf(stdout,"Sock/Appl TX-Datalen < 0\n");
        XIF3Structu->inc_return = DEF_IRET_ERRAU;
        return;
      }
      if((SrcLen != 0) && (DstLen != 0))	// data to copy
      {
        if(DstLen < SrcLen)			// limit to buffer
          SrcLen = DstLen;

//      printf("\nApplDataCopy: %d",SrcLen);

        CopyXH2DataListToBuffer(XIF3_pApplTxList(XIF3Structu),
				XIF3_pSockTxBufBase(XIF3Structu),0,
				SrcLen);

        XIF3_pSockTxBufBase(XIF2Structu) += SrcLen;
//        Sleep(200);		// TEST TEST TEST
//        Sleep(50);		// TEST TEST TEST
      }
      return;
    //=======================================================
    // Unknown Command detected, signal error
    //=======================================================
    default:				// invalid operation requested
//      fprintf(stdout,"Unknown command\n");

      XIF3Structu->inc_return = DEF_IRET_ERRAU;// set unspecific global error code
      return;
  } // function switch
}
#endif// defined XH_INTERFACE && defined XH_DUMMY

#if defined XH_INTERFACE
//()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()
//()								()
//()	HOBLink/HOBCom Client Interface				()
//()								()
//()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()

#if !defined XH_DUMMY && XH_INTF_VERSION < 300
//*********************************************************
//
// The HOBLink/HOBCom Client Interface as defined by
// Mr. Klaus Brandstaetter, V1
//
//*********************************************************
//m_hlcl01
extern "C" void m_hlcl01(struct dsd_hl_ssl_c_1 * pXIFCLStructu)
{
  int Retcode;
  int DataLen;

  int pTmpContStat[1];
  int pTmpReason[1];
 
  XHCONNSTRUC * pXhConnStruc;
  CONNSTRU * pConnStruc;
  CFG_STRU * pCfgStruc;

  ds__hmem TmpMemCtxStruc;
  
  struct dsd_hl_ssl_c_1 * XIFCLStructu = pXIFCLStructu;

  HMEM_CTX_DEF1;

  //-----------------------------------------
  // Check parameters
  //-----------------------------------------
  if(XIFCLStructu == NULL)
    return;

  LOAD_HMEM_CTX_PTR(NULL);

  //+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  // Distribute by caller requested function code
  //+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  switch(XIFCLStructu->inc_func)
  {
    //=======================================================
    // A) Connection Startup, check if valid...
    //=======================================================
    case DEF_IFUNC_START:
      if(XIFCLStructu->vpc_ext != NULL)		// already have a connection!
      {
        XIFCLStructu->inc_return = HSSL_NEWCONN_STATE_ERR; // already connecting...
        return;
      }
      pCfgStruc = (CFG_STRU *) XIFCLStructu->vpc_config_id;

      if(pCfgStruc == NULL)
      {
        // Replace the errror code below !!!
        XIFCLStructu->inc_return = HSSL_NEWCONN_STATE_ERR; // already connecting...
        return;
      }

      TmpMemCtxStruc = m_make_mem_struct(XIFCLStructu->amc_aux, 
                                         XIFCLStructu->vpc_userfld,
                                         0);
      LOAD_HMEM_CTX_PTR(&TmpMemCtxStruc);	// get correct context !!

      XIFCLStructu->inc_func = DEF_IFUNC_CONT;  // Force Continue next...
      //-------------------------------------------
      // Seed the PRNG with entropy
      //-------------------------------------------
      CTR_DRBG_AddSeed256((char *) &XIFCLStructu->ilc_entropy,sizeof(long long));

      //--------------------------------------------------------------
      // Get a connection structure to use, set up handshake data
      // to send, signal send data available, save state, send data
      //--------------------------------------------------------------
      Retcode = XHCLSSL_Connect(HMEM_CTX_REF1
			        XIFCLStructu,pCfgStruc);
      XIFCLStructu->inc_return = Retcode;
      if(Retcode != HSSL_OP_OK)  
      {
        CleanupCaches(HMEM_CTX_REF1
		      ((XHCONNSTRUC *) XIFCLStructu->vpc_ext)->pConnStruc,
		      Retcode);

//        FreeCfgStruct(pCfgStruc[0]);		// MUST BE KEPT !!!
        FreeXHCLConnStateStruct(HMEM_CTX_REF1 XIFCLStructu);// free all used...
      }
      else
      {
        XIFCLStructu->inc_func = DEF_IFUNC_CONT;	// Force Continue next...
      } 
      return;
    //=======================================================
    // B) Continuation, check what to do now....
    //=======================================================
    case DEF_IFUNC_CONT:

      //----------------------------------------------
      // Check if we have a connection state structure
      //----------------------------------------------
      pXhConnStruc = (XHCONNSTRUC *) XIFCLStructu->vpc_ext;	// get connection structure
      if(pXhConnStruc == NULL)			// not allocated
      {
        XIFCLStructu->inc_return = HSSL_XH_NOT_INITIALIZED_ERR; // report error
        return;
      }

      pConnStruc = pXhConnStruc->pConnStruc;	// get connection structure

      pConnStruc->pMemCtxStruc->vp__context = XIFCLStructu->vpc_userfld;

      LOAD_HMEM_CTX_PTR(pConnStruc->pMemCtxStruc);

      //----------------------------------------------------
      // Check if the client side socket (SSL) is still open
      //----------------------------------------------------
      if(XIFCLStructu->boc_eof_server != 0) // no socket for send data
      {
        CleanupCaches(HMEM_CTX_REF1 pConnStruc,XIFCLStructu->inc_return);

        XHCLSSL_Disconnect(XIFCLStructu);
        FreeXHCLConnStateStruct(HMEM_CTX_REF1 XIFCLStructu);// free all used...
        return;
      }
      //-----------------------------------------------------
      // Check if the server side socket (Non-SSL) was closed
      //-----------------------------------------------------
      if(XIFCLStructu->boc_eof_client != 0)	// server side (WSP) closed!
      {
        CleanupCaches(HMEM_CTX_REF1 pConnStruc,XIFCLStructu->inc_return);

        XHCLSSL_Disconnect(XIFCLStructu);
//        FreeXHCLConnStateStruct(HMEM_CTX_REF1 XIFCLStructu);// free all used...
        return;
      }

      //----------------------------------------------
      // 1. Check if Handshake phase is still active
      //----------------------------------------------
      for(;;)
      {
        if((pXhConnStruc->XHConnState == XH_STATE_CONNECT_START) ||
           (pXhConnStruc->XHConnState == XH_STATE_CONNECT_SEND) ||
           (pXhConnStruc->XHConnState == XH_STATE_CONNECT_WAIT) ||
           (pXhConnStruc->XHConnState == XH_STATE_CONNECT_ALERT) ||
           (pXhConnStruc->XHConnState == XH_STATE_CONNECT_CLOSING))
        {

          Retcode = XHCLDoHandshake(XIFCLStructu);
          XIFCLStructu->inc_return = Retcode;
          if((Retcode != HSSL_OP_OK) ||
            (pXhConnStruc->XHConnState == XH_STATE_CLOSED))
          {
            CleanupCaches(HMEM_CTX_REF1 pXhConnStruc->pConnStruc,Retcode);

//            XIFCLStructu->inc_func = DEF_IFUNC_CLOSE; // Force Start next...
            FreeXHCLConnStateStruct(HMEM_CTX_REF1 XIFCLStructu); // free all used...
	    return;
          }

// TEST TEST TEST: Next commented out !!!
          XHCLSSL_Send(HMEM_CTX_REF1 XIFCLStructu);	// queue send data
// TEST TEST TEST
          if(pXhConnStruc->XHConnState == XH_STATE_NORMAL)  // now connected
          {
//	    Client type has no callback (but would need one...)
//	    - new version HAS a callback !!!
	    if(XIFCLStructu->amc_conn_callback != NULL) // do a callback...
              GetReturnConnectionDataCL(XIFCLStructu);
            break;
          }
	  if((DataLen =
               GetXH2ListDataLen(XIFCLStructu->adsc_gai1_in_se)) <= 0)
          {
            return;          
          }
        }
        else
        {
          break;
        }
      } // Handshake FOR
      //------------------------------------------------------------
      // 3. Check if Socket RX-Data are present, receive all (!)
      //------------------------------------------------------------
      for(;;)
      {
        DataLen = GetXH2ListDataLen(XIFCLStructu->adsc_gai1_in_se);
        if(DataLen <= 0)
          break;
        {
          Retcode = HSSL_XHCLTcp_Receive(XIFCLStructu, DataLen, pTmpContStat);
          if(Retcode != HSSL_OP_OK)
          {

            CleanupCaches(HMEM_CTX_REF1 pXhConnStruc->pConnStruc,Retcode);

            FreeXHCLConnStateStruct(HMEM_CTX_REF1 XIFCLStructu); // free all used...
            XIFCLStructu->inc_return = Retcode;
            return;
          }
        }
      }
      //------------------------------------------------------------
      // 4. Process Application TX-Data, if present
      //------------------------------------------------------------
      XHCLSSL_Send(HMEM_CTX_REF1 XIFCLStructu);	// queue send data
      //------------------------------------------------------------
      // 5. Process Socket TX (Postprocessing also done)
      // --- assure sending ALL data till buffer filled/no more Data ---
      //------------------------------------------------------------
      if((pConnStruc->TX_State != TCP_TX_INACTIVE)||// remaining TX data
	 (pConnStruc->pApplicationTxQueueHead != NULL) ||	// application data
         (pConnStruc->pPriorityTxQueueHead != NULL))	// priority data
      {
        for(;;)
        {
          Retcode = HSSL_XHCLTcp_Transmit(XIFCLStructu, pTmpContStat,
				          pTmpReason);
          if(Retcode != HSSL_OP_OK)
          {

            CleanupCaches(HMEM_CTX_REF1 pXhConnStruc->pConnStruc,Retcode);

            XIFCLStructu->inc_return = Retcode;
            FreeXHCLConnStateStruct(HMEM_CTX_REF1 XIFCLStructu); // free all used...
            return;
          }
          if((XIFCLStructu->achc_out_se_cur == 	// buffer is full...
              XIFCLStructu->achc_out_se_end) ||
             ((pConnStruc->pApplicationTxQueueHead == NULL) && // no app. data
              (pConnStruc->pPriorityTxQueueHead == NULL)))  // no pri. data
          break;
        } // for
      }
      //------------------------------------------------------------
      // 6. Process Application RX
      //------------------------------------------------------------
      XHCLSSL_Recv(XIFCLStructu);
      XIFCLStructu->inc_return = HSSL_OP_OK;

      return;
    //=======================================================
    // C) Connection shall be ended, check what to do now....
    //=======================================================
    case DEF_IFUNC_CLOSE:
      //----------------------------------------------
      // Check if we have a connection state structure
      //----------------------------------------------
      pXhConnStruc = (XHCONNSTRUC *) XIFCLStructu->vpc_ext; // get connection structure
      if(pXhConnStruc == NULL)			// not allocated
      {
        XIFCLStructu->inc_return = HSSL_XH_NOT_INITIALIZED_ERR; // report error
        return;
      }

      pConnStruc = pXhConnStruc->pConnStruc;	// get connection structure
      pConnStruc->pMemCtxStruc->vp__context = XIFCLStructu->vpc_userfld;
      LOAD_HMEM_CTX_PTR(pConnStruc->pMemCtxStruc);
      //-------------------------------------------------------
      // Check State...
      //-------------------------------------------------------
      if((pXhConnStruc->XHConnState != XH_STATE_NORMAL) &&
         (pXhConnStruc->XHConnState != XH_STATE_CLOSING) &&
         (pXhConnStruc->XHConnState != XH_STATE_CLOSED))
      {
        CleanupCaches(HMEM_CTX_REF1 pXhConnStruc->pConnStruc,
		      HSSL_XH_INVALID_STATE);

        FreeXHCLConnStateStruct(HMEM_CTX_REF1 XIFCLStructu); // free all used...
        XIFCLStructu->inc_return = HSSL_XH_INVALID_STATE;
        return;
      }
      //-------------------------------------------------------
      // Process remaining data....
      // Continue to SEND on TCP until socket closed
      //-------------------------------------------------------
      Retcode = XHCLSSL_Disconnect(XIFCLStructu);
      if(Retcode != HSSL_OP_OK)
      {
        if(XIFCLStructu->vpc_ext != NULL)
          CleanupCaches(HMEM_CTX_REF1 pXhConnStruc->pConnStruc,Retcode);

        FreeXHCLConnStateStruct(HMEM_CTX_REF1 XIFCLStructu); // free all used...
        XIFCLStructu->inc_return = Retcode;
        return;
      }
      //----------------------------------------------
      // Check if all the data processed now
      //----------------------------------------------
      if(XIFCLStructu->inc_return == DEF_IRET_END)
      {
        if(XIFCLStructu->vpc_ext != NULL)
          CleanupCaches(HMEM_CTX_REF1 pXhConnStruc->pConnStruc,0);

        FreeXHCLConnStateStruct(HMEM_CTX_REF1 XIFCLStructu); // free all used...
        return;
      }
      return;
    //=======================================================
    // Unknown Command detected, signal error
    //=======================================================
    default:				// invalid operation requested
      XIFCLStructu->inc_return = DEF_IRET_ERRAU;// set unspecific global error code
      return;
  } // function switch
}

#endif // XH_DUMMY
#endif // XH_INTERFACE

//======================================================================
#if defined XH_INTERFACE && defined XH_DUMMY
//()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()
//()								()
//()     XH-Client Interface Dummy Routines,			()
//()     does copy input to output , no SSL Processing is done	()
//()								()
//()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()
//*********************************************************
//
// The HOBLink/HOBCom Client Interface as defined, Version 1
//
//*********************************************************
//m_hlcl01
extern "C" void m_hlcl01(struct dsd_hl_ssl_c_1 * pXIFCLStructu)
{
  int SrcLen;
  int DstLen;
  int Retcode;

  CFG_STRU * pCfgStruc;

  XIFSTRUC_CL * XIFCLStructu = (XIFSTRUC_CL *) ((void *) pXIFCLStructu);

  XHCONNSTRUC * pXhConnStruc;
  CONNSTRU * pConnStruc;

  ds__hmem CtxStruc;

  HMEM_CTX_DEF1;

  //-----------------------------------------
  // Check parameters
  //-----------------------------------------
  if(XIFCLStructu == NULL)
    return;

  CtxStruc = m_make_mem_struct(XIFCL_pHelperSr(XIFCLStructu),
                               XIFCL_pActualContext(XIFCLStructu), 
                               0);
  LOAD_HMEM_CTX_PTR(&CtxStruc);

  //+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  // Distribute by caller requested function code
  //+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  XIFCL_Retcode(XIFCLStructu) = HSSL_OP_OK;
  switch(XIFCL_ReqCode(XIFCLStructu))
  {
    //=========================================================
    // A) Connection Startup, no operation except changing mode
    //=========================================================
    case DEF_IFUNC_START:
      pCfgStruc = (CFG_STRU *) XIFCLStructu->vpc_config_id;

      if(pCfgStruc == NULL)
      {
        XIFCL_Retcode(XIFCLStructu) = HSSL_NEWCONN_STATE_ERR; // already connecting...
        return;
      }
      //--------------------------------------------------------------
      // Get a connection structure to use, set up handshake data
      // to send, signal send data available, save state, send data
      //--------------------------------------------------------------
      Retcode = XHCLSSL_Connect(HMEM_CTX_REF1
			        XIFCLStructu,pCfgStruc);

      XIFCL_Retcode(XIFCLStructu) = Retcode;
      if(Retcode != HSSL_OP_OK)  
      {
        return;
      }
      else
      {
        XIFCL_ReqCode(XIFCLStructu) = DEF_IFUNC_CONT;	// Force Continue next...
      } 
//      Sleep(5000);		// TEST TEST TEST
//      Sleep(2000);		// TEST TEST TEST

//    Not implement with client interface....
//    IS now implemented (16.02.2005)
    if(XIFCL_pQueryCallback(XIFCLStructu) != NULL) // do a callback...
      GetReturnConnectionDataCL(XIFCLStructu);
      return;

    //=======================================================
    // B) Continuation, check what to do now....
    //=======================================================
    case DEF_IFUNC_CONT:
      //-----------------------------------------------
      // Check if the Client (SSL) socket is still open
      //-----------------------------------------------
      if(XIFCLStructu->boc_eof_server != 0)	// no socket for send data
      {
//        fprintf(stdout,"ContEntry: NoSock\n");
//        PRINT("HSSL Continue: NoSocket, ended\n");
        FreeXHCLConnStateStruct(HMEM_CTX_REF1 XIFCLStructu);		// free all used...
        XIFCL_Retcode(XIFCLStructu) = DEF_IRET_END;	// ended !!
        return;
      }
      //-----------------------------------------------------
      // Check if the Server side socket (Non-SSL) was closed
      //-----------------------------------------------------
      if(XIFCLStructu->boc_eof_client != 0)	// server side (WSP) closed!
      {
        FreeXHCLConnStateStruct(HMEM_CTX_REF1 XIFCLStructu);		// free all used...
        XIFCL_Retcode(XIFCLStructu) = DEF_IRET_END;	// ended !!
        return;
      }
      //------------------------------------------------------------
      // 1. Check if Socket RX-Data are present
      //------------------------------------------------------------
      SrcLen = GetXH2ListDataLen(XIFCL_pSockRxList(XIFCLStructu));

      DstLen = (int) (XIFCL_pApplRxBufTop(XIFCLStructu) -
                      XIFCL_pApplRxBufBase(XIFCLStructu));
      if((SrcLen < 0) || (DstLen < 0))
      {
//       fprintf(stdout,"Sock/Appl RX-Datalen < 0\n");
//      XIFCL_Retcode(XIFCLStructu) = DEF_IRET_ERRAU; // not good !
        return;
      }
      if((SrcLen != 0) && (DstLen != 0))	// data to copy
      {
        if(DstLen < SrcLen)			// limit to buffer
          SrcLen = DstLen;

//      printf("\nSockDataCopy: %d",SrcLen);

	CopyXH2DataListToBuffer(XIFCL_pSockRxList(XIFCLStructu),
			        XIFCL_pApplRxBufBase(XIFCLStructu),0, SrcLen);

//        Sleep(200);		// TEST TEST TEST
//        Sleep(50);		// TEST TEST TEST
      }
      //------------------------------------------------------------
      // 2. Check if Application TX-Data present
      //------------------------------------------------------------
      SrcLen = GetXH2ListDataLen(XIFCL_pApplTxList(XIFCLStructu));

      DstLen = XIFCL_pSockTxBufTop(XIFCLStructu) - 
               XIFCL_pSockTxBufBase(XIFCLStructu);
      if((SrcLen < 0) || (DstLen < 0))
      {
//       fprintf(stdout,"Sock/Appl TX-Datalen < 0\n");
        XIFCL_Retcode(XIFCLStructu) = DEF_IRET_ERRAU;
        return;
      }
      if((SrcLen != 0) && (DstLen != 0))	// data to copy
      {
        if(DstLen < SrcLen)			// limit to buffer
          SrcLen = DstLen;

//      printf("\nApplDataCopy: %d",SrcLen);

        CopyXH2DataListToBuffer(XIFCL_pApplTxList(XIFCLStructu),
				 XIFCL_pSockTxBufBase(XIFCLStructu),0,
				 SrcLen);

        XIFCL_pSockTxBufBase(XIFCLStructu) += SrcLen;
//        Sleep(200);		// TEST TEST TEST
//        Sleep(50);		// TEST TEST TEST
      }
      return;
    //=======================================================
    // C) Connection shall be ended, check what to do now....
    //=======================================================
    case DEF_IFUNC_CLOSE:
      //----------------------------------------------
      // Check if we have a connection state structure
      //----------------------------------------------
      pXhConnStruc = XIFCL_pXHConnData(XIFCLStructu);	// get connection structure
      if(pXhConnStruc == NULL)			// not allocated
      {
        XIFCL_Retcode(XIFCLStructu) = HSSL_XH_NOT_INITIALIZED_ERR; // report error
        return;
      }

      pConnStruc = pXhConnStruc->pConnStruc;	// get connection structure
      LOAD_HMEM_CTX_PTR(pConnStruc->pMemCtxStruc);
      //-------------------------------------------------------
      // Check State...
      //-------------------------------------------------------
      if((pXhConnStruc->XHConnState != XH_STATE_NORMAL) &&
         (pXhConnStruc->XHConnState != XH_STATE_CLOSING) &&
         (pXhConnStruc->XHConnState != XH_STATE_CLOSED))
      {
        FreeXHCLConnStateStruct(HMEM_CTX_REF1 XIFCLStructu); // free all used...
        XIFCL_Retcode(XIFCLStructu) = HSSL_XH_INVALID_STATE;
        return;
      }

      if(pXhConnStruc->XHConnState == XH_STATE_CLOSED)
      {
        FreeXHCLConnStateStruct(HMEM_CTX_REF1 XIFCLStructu);
        XIFCL_Retcode(XIFCLStructu) = DEF_IRET_END;	// ended !!
        return;
      }

      if(pXhConnStruc->XHConnState  == XH_STATE_NORMAL)
      {
        pXhConnStruc->XHConnState = XH_STATE_CLOSING;
      }
      //-----------------------------------------------
      // Check if the Client socket (SSL) is still open
      //-----------------------------------------------
      if(XIFCLStructu->boc_eof_server != 0)	// no socket for send data
      {
//        fprintf(stdout,"ContEntry: NoSock\n");
//        PRINT("HSSL Continue: NoSocket, ended\n");
        FreeXHCLConnStateStruct(HMEM_CTX_REF1 XIFCLStructu);		// free all used...
        XIFCL_Retcode(XIFCLStructu) = DEF_IRET_END;	// ended !!
        return;
      }
      //--------------------------------------------------
      // Socket is still open, check if still data to send
      //------------------------------------------------------------
      SrcLen = GetXH2ListDataLen(XIFCL_pApplTxList(XIFCLStructu));

      DstLen = (int) (XIFCL_pSockTxBufTop(XIFCLStructu) - 
                      XIFCL_pSockTxBufBase(XIFCLStructu));
      if((SrcLen < 0) || (DstLen < 0))
      {
//       fprintf(stdout,"Sock/Appl TX-Datalen < 0\n");
        XIFCL_Retcode(XIFCLStructu) = DEF_IRET_ERRAU;
        FreeXHCLConnStateStruct(HMEM_CTX_REF1 XIFCLStructu);		// free all used...
        return;
      }
      if((SrcLen != 0) && (DstLen != 0))	// data to copy
      {
        if(DstLen < SrcLen)			// limit to buffer
          SrcLen = DstLen;

//      printf("\nApplDataCopy: %d",SrcLen);

        CopyXH2DataListToBuffer(XIFCL_pApplTxList(XIFCLStructu),
				 XIFCL_pSockTxBufBase(XIFCLStructu),0,
				 SrcLen);

        XIFCL_pSockTxBufBase(XIFCLStructu) += SrcLen;
      }
      else					// no more data...
      {
        FreeXHCLConnStateStruct(HMEM_CTX_REF1 XIFCLStructu);		// free all used...
        XIFCL_Retcode(XIFCLStructu) = DEF_IRET_END;	// ended !!
        return;
      }
      return;
    //=======================================================
    // Unknown Command detected, signal error
    //=======================================================
    default:				// invalid operation requested
//      fprintf(stdout,"Unknown command\n");

      XIFCL_Retcode(XIFCLStructu) = DEF_IRET_ERRAU;// set unspecific global error code
      return;
  } // function switch
}
#endif// defined XH_INTERFACE && defined XH_DUMMY

//()()()()()()()()()()()()()()()()()()()()()()()()()()()()
//()
//() NEW INTERFACE NEW NEW NEW
//()
//()()()()()()()()()()()()()()()()()()()()()()()()()()()()

#if defined XH_INTERFACE && !defined XH_DUMMY && XH_INTF_VERSION >= 300

/**
Calculates the total length of a gather chain in bytes.

Total length means the total number of bytes in the combined buffers, referenced 
by the gather chain. A NULL pointer will be interpreted as length 0.

@param[in]  adsp_gather Pointer to the gather chain.

@return Length of the chain in bytes.
*/
static size_t m_calc_gather_len(struct dsd_gather_i_1 * adsp_gather)
{
   size_t szl_len = 0;
   while( NULL != adsp_gather){
      szl_len += adsp_gather->achc_ginp_end-adsp_gather->achc_ginp_cur;
      adsp_gather = adsp_gather->adsc_next;
   }
   return szl_len;
}

/**
* Increments the current buffer pointer(s) of the gather element(s) by TotalLen.
*
* This makes the gather buffer look empty (length 0).
*
* It does NOT invoke any free operations.
*
*  @param pListElement packet element to free buffer
*/
void FreeRxPktListBuf(RX_PKT_PTR pListElement)
{
  struct dsd_gather_i_1 * pGather;

  pGather = pListElement->pGatherStruc;
  while( 0 != pListElement->TotalLen ){
     if( pListElement->TotalLen > (pGather->achc_ginp_end - pGather->achc_ginp_cur)){
        pListElement->TotalLen -= static_cast<int>(pGather->achc_ginp_end - pGather->achc_ginp_cur);
        pGather->achc_ginp_cur = pGather->achc_ginp_end;
        pGather = pGather->adsc_next;
     } else {
        pGather->achc_ginp_cur += pListElement->TotalLen;
        pListElement->TotalLen = 0;
     }
  }
} 
/**
* Frees a list of RX packet structures and their data buffers.
*
* Contained gather structures are not modified, only the
* structures and buffers are freed.
*
*  @param pList List with elements to free
*/
void FreeRxPktList(HMEM_CTX_DEF RX_PKT_PTR pList)
{
  RX_PKT_PTR pNext;

  for(;;)
  {
    if(pList == NULL)
      return;
    pNext = pList->pNext;
    FREE_ARRAY(HMEM_CTX_REF,pList->pDataBuf);
    FREE_ARRAY(HMEM_CTX_REF,pList);
    pList = pNext;
  }
}

/**
Generates a RX packet with data from the provided gather structures.

The gather pointer will be advanced to the first gather, that sill contains data.
The offset will be set to the offset of unread data.
If not enough data are present, NULL is returned.

@param aadsp_gath[inout]   Pointer to a pointer of the current gather.
@param aunp_offset[inout]  Offset of data in the current gather.
@param szp_len[in]         Number of bytes to be read.

@return New RX packet, NULL on error.
*/
static RX_PKT_PTR m_gen_rx_packet(HMEM_CTX_DEF struct dsd_gather_i_1** aadsp_gath, 
                                  unsigned int* aunp_offset, 
                                  size_t szp_len)
{
   RX_PKT_PTR adsl_new_pkt = NULL;                       // Pointer to the new packet
   unsigned int unl_cur_index = 0;                       // Current index in the packets data buffer
   // Trivial cases
   if( NULL == aadsp_gath || NULL == *aadsp_gath ){
      return NULL;
   }

   // Allocate packet and buffer
   adsl_new_pkt = (RX_PKT_PTR) BIT8_ARRAY_ALLOC(HMEM_CTX_REF,sizeof(RX_PKT_STRUC));
   if( NULL == adsl_new_pkt ){
      return NULL;
   }

   adsl_new_pkt->pDataBuf = BIT8_ARRAY_ALLOC(HMEM_CTX_REF,static_cast<int>(szp_len));
   if( NULL == adsl_new_pkt->pDataBuf) {
      FREE_ARRAY(HMEM_CTX_REF, adsl_new_pkt);
      return NULL;
   }

   // Initialize the fields
   adsl_new_pkt->pGatherStruc = *aadsp_gath;
   adsl_new_pkt->Offset = 0;
   adsl_new_pkt->pNext = NULL;
   adsl_new_pkt->RemainingLen = static_cast<int>(szp_len);
   adsl_new_pkt->TotalLen = static_cast<int>(szp_len);

   // Copy data from gathers to the data buffer
   while( 0 != szp_len && NULL != *aadsp_gath ){
      size_t szl_gath_len = (*aadsp_gath)->achc_ginp_end - 
         (*aadsp_gath)->achc_ginp_cur - *aunp_offset;
      if( szl_gath_len > szp_len ){
         memcpy(adsl_new_pkt->pDataBuf+unl_cur_index,
            (*aadsp_gath)->achc_ginp_cur+*aunp_offset, szp_len);
         *aunp_offset += (unsigned int)szp_len;
         szp_len = 0;
      } else {
         memcpy(adsl_new_pkt->pDataBuf+unl_cur_index,
            (*aadsp_gath)->achc_ginp_cur+*aunp_offset, szl_gath_len);
         unl_cur_index += (unsigned int)szl_gath_len;
         szp_len -= szl_gath_len;
         *aunp_offset = 0;
         *aadsp_gath = (*aadsp_gath)->adsc_next;
      }
   }

   // Check, if the requested amount was written
   if( 0 != szp_len ){
      FREE_ARRAY(HMEM_CTX_REF, adsl_new_pkt->pDataBuf);
      FREE_ARRAY(HMEM_CTX_REF, adsl_new_pkt);
      return NULL;
   }

   return adsl_new_pkt;
}//static RX_PKT_PTR m_gen_rx_packet(HMEM_CTX_DEF struct dsd_gather_i_1** aadsp_gath, unsigned int* aunp_offset, size_t szp_len);

/**
* Generates SSL receive packet list from given SSL RX gather structure.
*
* Gather list is not checked.
*
*  @param pGatherStruc Pointer to gather structure
*  @return List of packet structures / NULL if alloc failed
*/
RX_PKT_PTR GenSSLRxPktList(HMEM_CTX_DEF struct dsd_gather_i_1 * pGatherStruc)
{
  size_t TotalLen;
  unsigned int unl_offset = 0;

  RX_PKT_PTR pPkt = NULL;
  RX_PKT_PTR pAct = NULL;
  RX_PKT_PTR pPrev;

  if(pGatherStruc == NULL)
    return(NULL);
  
  // Copy data from gathers
  while( NULL != pGatherStruc )
  {
    // Calculate length
    TotalLen = pGatherStruc->achc_ginp_end - pGatherStruc->achc_ginp_cur;
    
    if(TotalLen == 0)
    {
      // Empty gather, process next
      pGatherStruc = pGatherStruc->adsc_next;
      continue;
    }
    
    if((pGatherStruc->achc_ginp_cur == NULL) ||
       (pGatherStruc->achc_ginp_end < pGatherStruc->achc_ginp_cur) )
    {
      // Invalid gather, release packets and return
      FreeRxPktList(HMEM_CTX_REF1 pPkt);
      return(NULL);
    }

    pPrev = pAct;

    // Generate the packet
    pAct = m_gen_rx_packet(HMEM_CTX_REF1 &pGatherStruc, &unl_offset, TotalLen);
    if(pAct == NULL)
    {
      // Error during packet generation
      FreeRxPktList(HMEM_CTX_REF1 pPkt);
      return(NULL);
    }

    // put packet into the list
    if(pPkt == NULL)
      pPkt = pAct;
    else
      pPrev->pNext = pAct;
  }

  return pPkt;
}      
/**
* Gets next SSL packet buffer element to process, puts current
* element (if any) to the to be freed queue.
*
*  @param pConnStruc Connection structure
*  @return Pointer to next packet / NULL if no more packets
*/
RX_PKT_PTR GetNextSSLPacket(CONNSTRU * pConnStruc)
{
  RX_PKT_PTR pPkt;
  //------------------------------------------------------
  // Check if packet was present, put to to be freed queue
  //------------------------------------------------------
  pPkt = pConnStruc->pSSLActRxPkt;	// get active packet pointer
  if(pPkt != NULL)			// a packet was present
  {
    pPkt->pNext = NULL;			// end queue
    if(pConnStruc->pSSLRxPktToFreeAnchor == NULL)
    {
      pConnStruc->pSSLRxPktToFreeAnchor = pPkt;
      pConnStruc->pSSLRxPktToFreeTail   = pPkt;
    }
    else
    {
      pConnStruc->pSSLRxPktToFreeTail->pNext = pPkt;
      pConnStruc->pSSLRxPktToFreeTail   = pPkt;
    }
    pConnStruc->pSSLActRxPkt = NULL;

  }
  //----------------------------------------------------
  // Get next packet from List if more present
  //----------------------------------------------------
  pPkt = pConnStruc->pSSLRxPktInUseAnchor;
  if(pPkt != NULL)
  {
    pConnStruc->pSSLRxPktInUseAnchor = pPkt->pNext;
    pConnStruc->pSSLActRxPkt = pPkt;	// set active packet pointer
  }
  return(pPkt);
}
/**
* Get next Application Packet buffer element to process, put
* current element (if any) to the to be freed queue.
*
*  @param pConnStruc Connection structure
*  @return next packet / NULL if no more packets
*/
RX_PKT_PTR GetNextAPPPacket(CONNSTRU * pConnStruc)
{
  RX_PKT_PTR pPkt;
  //------------------------------------------------------
  // Check if packet was present, put to to be freed queue
  //------------------------------------------------------
  pPkt = pConnStruc->pAPPActRxPkt;	// get active packet pointer
  if(pPkt != NULL)			// a packet was present
  {
    pPkt->pNext = NULL;			// end queue
    if(pConnStruc->pAPPRxPktToFreeAnchor == NULL)
    {
      pConnStruc->pAPPRxPktToFreeAnchor = pPkt;
      pConnStruc->pAPPRxPktToFreeTail   = pPkt;
    }
    else
    {
      pConnStruc->pAPPRxPktToFreeTail->pNext = pPkt;
      pConnStruc->pAPPRxPktToFreeTail   = pPkt;
    }
    pConnStruc->pAPPActRxPkt = NULL;
  }
  //----------------------------------------------------
  // Get next packet from List if more present
  //----------------------------------------------------
  pPkt = pConnStruc->pAPPRxPktInUseAnchor;
  if(pPkt != NULL)
  {
    pConnStruc->pAPPRxPktInUseAnchor = pPkt->pNext;
    pConnStruc->pAPPActRxPkt = pPkt;	// set active packet pointer
  }
  return(pPkt);
}
/**
* Sets all gather buffers for the elements in the to be freed
* RX list to length 0 and frees the list elements themself for SSL packets.
*
* The gather buffers are not freed.
*
* @see FreeRxPktListBuf 
*
*  @param pConnStruc Connection structure
*/
void FreeSSLGatherBufsAndFreeList(HMEM_CTX_DEF CONNSTRU * pConnStruc)
{
  RX_PKT_PTR pAct;
  RX_PKT_PTR pNext;

  pAct = pConnStruc->pSSLRxPktToFreeAnchor;
  pConnStruc->pSSLRxPktToFreeAnchor = NULL;
  pConnStruc->pSSLRxPktToFreeTail   = NULL;

  for(;;)
  {
    if(pAct == NULL)
      return;

    FreeRxPktListBuf(pAct);
    pNext = pAct->pNext;
    FREE_ARRAY(HMEM_CTX_REF,pAct->pDataBuf);
    FREE_ARRAY(HMEM_CTX_REF,pAct);

    pAct = pNext;    
  }
}
/**
* Sets all gather buffers for the elements in the to be freed
* RX list to length 0 and frees the list elements themself for application 
* packets.
*
* The gather buffers are not freed.
*
* @see FreeRxPktListBuf 
*
*  @param pConnStruc Connection structure
*/
void FreeAPPGatherBufsAndFreeList(HMEM_CTX_DEF CONNSTRU * pConnStruc)
{
  RX_PKT_PTR pAct;
  RX_PKT_PTR pNext;

  pAct = pConnStruc->pAPPRxPktToFreeAnchor;
  pConnStruc->pAPPRxPktToFreeAnchor = NULL;
  pConnStruc->pAPPRxPktToFreeTail   = NULL;

  for(;;)
  {
    if(pAct == NULL)
      return;

    FreeRxPktListBuf(pAct);
    pNext = pAct->pNext;
    FREE_ARRAY(HMEM_CTX_REF,pAct->pDataBuf);
    FREE_ARRAY(HMEM_CTX_REF,pAct);

    pAct = pNext;    
  }
}

/**
* Generates application RX list from given gather structure.
*
* The elements are partitioned to the limit that SSL
*      can transport in one block (16KB). Large receive
*	    buffers will be split into several blocks if needed.
*
* 1/(n-1) Splitting is applied to prevent attacks against old style CBC encryption.
*
*  @param pGatherStruc Pointer to gather structure
*  @return Pointer to generated list head /NULL on error
*/
static RX_PKT_PTR GenAppRxList(HMEM_CTX_DEF struct dsd_gather_i_1 * pGatherStruc)
{
  RX_PKT_PTR pPkt = NULL;
  RX_PKT_PTR pAct = NULL;

  struct dsd_gather_i_1* adsl_cur_gather = pGatherStruc;
  size_t szl_total_len = m_calc_gather_len(pGatherStruc);
  unsigned int unl_offset = 0;

  adsl_cur_gather = pGatherStruc;

  // Generate initial length 1 packet for 1/n-1 splitting
  if( 0 != szl_total_len ){
     pPkt = m_gen_rx_packet(HMEM_CTX_REF1 &adsl_cur_gather, &unl_offset, 1);
     szl_total_len--;
  }

  if( NULL == pPkt){
     return NULL;
  }

  // Generate the remaining packets. Keep up the record splitting
  pAct = pPkt;
  while( 0 != szl_total_len && NULL != adsl_cur_gather ){
     if(SSL_PLAIN_RECORD_MAX_LEN < szl_total_len ){
        // More data left, than max record length. Generate a packet of max record length and a length 1 packet
        pAct->pNext = m_gen_rx_packet(HMEM_CTX_REF1 &adsl_cur_gather, &unl_offset, 
           SSL_PLAIN_RECORD_MAX_LEN);
        if( NULL == pAct->pNext ){
           break;
        }
        pAct = pAct->pNext;

        pAct->pNext = m_gen_rx_packet(HMEM_CTX_REF1 &adsl_cur_gather, &unl_offset, 1);
        if( NULL == pAct->pNext ){
           break;
        }
        pAct = pAct->pNext;
        szl_total_len -= (SSL_PLAIN_RECORD_MAX_LEN+1);
     } else {
        // Remaining data fits into single record
        pAct->pNext = m_gen_rx_packet(HMEM_CTX_REF1 &adsl_cur_gather, &unl_offset, 
           szl_total_len);
        if( NULL == pAct->pNext ){
           break;
        }
        szl_total_len = 0;
     }
  }

  if( 0 != szl_total_len ){
     FreeRxPktList(HMEM_CTX_REF1 pPkt);
     pPkt = NULL;
  }

  return pPkt;
}

/**
Generates application RX list from given gather structure.

The elements are partitioned to the limit that SSL can transport in one block 
(16KB). Large receive buffers will be split into several blocks if needed.

@param pGatherStruc Pointer to gather structure
@return Pointer to generated list head /NULL on error
*/
static RX_PKT_PTR m_gen_app_rx_list_no_split(HMEM_CTX_DEF 
                                             dsd_gather_i_1* pGatherStruc)
{ 
    size_t szl_total_len = m_calc_gather_len(pGatherStruc);
    if( 0 == szl_total_len ){
        return NULL;
    }
    
    unsigned int unl_offset = 0;
    if( szl_total_len <= SSL_PLAIN_RECORD_MAX_LEN){
        return m_gen_rx_packet(HMEM_CTX_REF1 
                               &pGatherStruc,
                               &unl_offset, 
                               szl_total_len);
    }
    
    
    struct dsd_gather_i_1* adsl_cur_gather = pGatherStruc;
    RX_PKT_PTR  pPkt = m_gen_rx_packet(HMEM_CTX_REF1 
                                       &adsl_cur_gather,
                                       &unl_offset, 
                                       SSL_PLAIN_RECORD_MAX_LEN);
    if( pPkt == NULL){
        return NULL;
    }
    RX_PKT_PTR pAct = pPkt;
    szl_total_len -= SSL_PLAIN_RECORD_MAX_LEN;

    // Generate the remaining packets. Keep up the record splitting
    while( 0 != szl_total_len && NULL != adsl_cur_gather ){
        if(SSL_PLAIN_RECORD_MAX_LEN <= szl_total_len ){
            // More data left, than max record length. Generate a packet of max record length and a length 1 packet
            pAct->pNext = m_gen_rx_packet(HMEM_CTX_REF1 
                                          &adsl_cur_gather, 
                                          &unl_offset, 
                                          SSL_PLAIN_RECORD_MAX_LEN);
            if( NULL == pAct->pNext ){
                break;
            }
            pAct = pAct->pNext;
            szl_total_len -= SSL_PLAIN_RECORD_MAX_LEN;
        } else {
            // Remaining data fits into single record
            pAct->pNext = m_gen_rx_packet(HMEM_CTX_REF1 
                                          &adsl_cur_gather,
                                          &unl_offset, 
                                          szl_total_len);
            if( NULL == pAct->pNext ){
                break;
            }
            szl_total_len = 0;
        }
    }

    if( 0 != szl_total_len ){
        FreeRxPktList(HMEM_CTX_REF1 pPkt);
        pPkt = NULL;
    }

    return pPkt;
}

/**
Generates application RX list from given gather structure.

The elements are partitioned to the limit that SSL can transport in one block 
(16KB). Large receive buffers will be split into several blocks if needed.

1/(n-1) Splitting will be applied, if the negotiated protocol version and cipher
makes it necessary.

@param  adsp_connection Pointer to the connection instance.
@param  adsp_data       Pointer to gather structure
@return Pointer to generated list head /NULL on error
*/
static RX_PKT_PTR m_gen_app_rx_list(HMEM_CTX_DEF
                                    CONNSTRU* adsp_connection, 
                                    dsd_gather_i_1* adsp_data)
{
    // Only use splitting on TLS 1.0 and SSL 3 with block ciphers
    bool bol_is_low_tls_version = ((adsp_connection->ActualProtocol == SSL_PROT_TYPE) || 
                                   (adsp_connection->ActualProtocol == TLS_PROT_TYPE));
    bool bol_is_block_cipher = adsp_connection->CipherType == 1;
    if(bol_is_low_tls_version && bol_is_block_cipher){
        return GenAppRxList(HMEM_CTX_REF1 adsp_data);
    } else {
        return m_gen_app_rx_list_no_split(HMEM_CTX_REF1 adsp_data);
    }
}

/**
Updates the RX list with new gather pointers.

This simply means, that old pointers are replaced with new ones. It is assumed, 
that the content is identical. It works with both SSL and aplication RX lists, 
as it reads the length from the RX packets. Only the gather pointers in the 
packets are updated, no reallocations will happen.

If adsp_rx_list is NULL, the update always succeeds. If adsp_new_gath is NULL,
but adsp_rx_list is not, the update always fails. If the gather chain contains 
insufficient data, meaning less, than specified by the list elements, the 
update fails.

@param[inout]  adsp_rx_list   Pointer to the RX packet list to be updated.
@param[in]     adsp_new_gath  Pointer to the new gather chain.

@return TRUE, if the update was successfull, FALSE, if it failed.
*/
static BOOL m_update_rx_list(RX_PKT_PTR adsp_rx_list, 
                             struct dsd_gather_i_1 * adsp_new_gath)
{
   int inl_len = (int)m_calc_gather_len(adsp_new_gath);    // Total remaining length of the gathers
   int inl_cur_gather_offset = 0;                     // Offset within the current gather

   if(NULL == adsp_rx_list){
      // No list to update
      return TRUE;
   }

   if(NULL == adsp_new_gath){
      // List there, but no gather, fail
      return FALSE;
   }

   // Loop over all list elements
   while(NULL != adsp_rx_list){
      // Reset gather pointer and decrement total length
      int inl_cur_ele_len = adsp_rx_list->TotalLen;
      adsp_rx_list->pGatherStruc = adsp_new_gath;
      inl_len -= inl_cur_ele_len;
      
      if(0 > inl_len){
         // Gather chain is too short
         return FALSE;
      }
      
      // Gather must be updated, depending on length of RX pkt
      // One gather may span over multiple packets and one packet may cover multiple gathers
      while((0 != inl_cur_ele_len) &&                                                                 // Covers the case, that last list element ends with the last gather
         ((adsp_new_gath->achc_ginp_end-adsp_new_gath->achc_ginp_cur+inl_cur_gather_offset) <= inl_cur_ele_len))
      {
         // Current gather completely in current RX pkt. Decrement length, get next gather and reset offset.
         inl_cur_ele_len -= (int)(adsp_new_gath->achc_ginp_end-adsp_new_gath->achc_ginp_cur+inl_cur_gather_offset);
         adsp_new_gath = adsp_new_gath->adsc_next;
         inl_cur_gather_offset = 0;
      }

      // remaining inl_cur_ele_len added to offset
      inl_cur_gather_offset += inl_cur_ele_len;

      // get next pkt
      adsp_rx_list = adsp_rx_list->pNext;
   }

   // Update sucessfull
   return TRUE;
}//static BOOL m_update_rx_list(RX_PKT_PTR adsp_rx_list, struct dsd_gather_i_1 * adsp_new_gath);

/**
* Gets SSL Segment header (5 Bytes) from SSL RX packet list, checks it and
* prepares decryption buffer.
*
*  @param pConnStruc Connection structure
*  @param pContinueStat Continuation status
*  @return 0 on success, completed,
* <br>            > 0 data yet incomplete
* <br>            < 0 error occured
*/
int ReceiveSslRecordHeader(HMEM_CTX_DEF CONNSTRU * pConnStruc,
			   int* pContinueStat)
{
  int DataLen,RequiredLen,Retcode;
  int RecordLen,BlockSize,BlockCount;
  char * pBuf;
  char * pDstBuf;
  RX_PKT_PTR pPkt;

  pContinueStat[0] = 0;

  pPkt = pConnStruc->pSSLActRxPkt;	// current active packet

  //------------------------------------------------------
  // Copy Record header to header buffer
  //------------------------------------------------------
  RequiredLen = RECORD_HDR_SIZE - pConnStruc->RxHeaderIndex;
  while(RequiredLen > 0)
  {
    if(pPkt == NULL)			// no more data available...
      return(1);

    DataLen = pPkt->RemainingLen;
    pBuf    = pPkt->pDataBuf;

    if(DataLen < RequiredLen)
    {
      memcpy(pConnStruc->RX_HeaderBuffer+pConnStruc->RxHeaderIndex,pBuf+pPkt->Offset,DataLen);
      Retcode = Check_SSL_RecordHeader(pConnStruc,DataLen);
      pConnStruc->RxHeaderIndex += DataLen;
      if(Retcode != HSSL_OP_OK)
        return(Retcode);

      RequiredLen -= DataLen;
      pPkt = GetNextSSLPacket(pConnStruc);
    }
    else				// enough data for header
    {
      memcpy(pConnStruc->RX_HeaderBuffer+pConnStruc->RxHeaderIndex,pBuf+pPkt->Offset,RequiredLen);
      pPkt->Offset       += RequiredLen;
      pPkt->RemainingLen -= RequiredLen;

      Retcode = Check_SSL_RecordHeader(pConnStruc,RequiredLen);
      if(Retcode != HSSL_OP_OK)
        return(Retcode);
      if(DataLen == RequiredLen)	// packet was processed!
        GetNextSSLPacket(pConnStruc);	// get next packet
      RequiredLen = 0;
    }
  }      
  //------------------------------------------------------
  // SSL Record header has been received, setup parameters
  // for record decryption/direct processing to follow
  //------------------------------------------------------
  pBuf = pConnStruc->RX_HeaderBuffer;		// SSL Record header

  if((pBuf[0] & 0x080) != 0)
  {
    RecordLen = (((int) pBuf[0] & 0x7F) << 8) +
		 ((int) pBuf[1] & 0x0FF) - 3;
    //-------------------------------------------------
    // Received SSL-V2 Client hello, always unencrypted
    //-------------------------------------------------
    pConnStruc->SSLV2Flag = 1;		// set processing Flag for others
  }
  else
  {
    RecordLen = (((int) pBuf[3] & 0x0FF) << 8) +
		 ((int) pBuf[4] & 0x0FF);
  }
  //-----------------------------------------------------
  // Check if a blockcipher is currently active
  //-----------------------------------------------------
  if((pConnStruc->ActRX_EncAlgor != CIPHER_ALGOR_NULL) &&
     (pConnStruc->CipherType == ALGOR_TYPE_BLOCK))
  {
    BlockSize = pConnStruc->BlockLen;
    BlockCount = RecordLen / BlockSize;
    if(RecordLen != (BlockCount * BlockSize))
      return(HSSL_DECRYPT_INVALID_LEN);
  }

  pConnStruc->DecryptOffset      = RECORD_HDR_SIZE;
  pConnStruc->DecryptLen         = RecordLen;
  pConnStruc->DecryptRequiredLen = RecordLen;
  //-----------------------------------------------------
  // Check for empty record now (OpenSSL strange case)
  //-----------------------------------------------------
  if(RecordLen == 0)			// no data to process
    return(HSSL_OP_OK);

  //-----------------------------------------------------
  // Allocate decryption buffer incl. Header length
  //-----------------------------------------------------
  pDstBuf = BIT8_ARRAY_ALLOC_POOL(HMEM_CTX_REF,RecordLen + RECORD_HDR_SIZE);
  if(pDstBuf == NULL)
    return(HSSL_RX_BUF_ALLOC_ERR);

  pConnStruc->pDecryptBuf        = pDstBuf;

  memcpy(pDstBuf+0,pBuf+0,RECORD_HDR_SIZE);

  return(HSSL_OP_OK);
}
/**
* Decrypts stream ciphered SSL datablock.
*
* Also handles non encrypted data (as a copy operation).
*
*  @param pConnStruc Connection structure
*  @return 0 data completed, > 0 data yet incomplete
*/
int SSLPktStreamDecrypt(HMEM_CTX_DEF CONNSTRU * pConnStruc)
{
  int EncAlgor;
  int RequiredLen,DstOff;
  int DataLen,SrcOff,DecryptLen;
  char * pDstBuf;
  char * pSrcBuf;
  RX_PKT_PTR pPkt;

  EncAlgor = pConnStruc->ActRX_EncAlgor;
  pPkt = pConnStruc->pSSLActRxPkt;

  pDstBuf     = pConnStruc->pDecryptBuf;
  DstOff      = pConnStruc->DecryptOffset;
  RequiredLen = pConnStruc->DecryptRequiredLen;
  //-----------------------------------------------------
  // Process input data as long as data available
  //-----------------------------------------------------
  while(RequiredLen > 0)
  {
    if(pPkt == NULL)			// no more data given
    {
      pConnStruc->DecryptOffset      = DstOff;
      pConnStruc->DecryptRequiredLen = RequiredLen;
      FreeSSLGatherBufsAndFreeList(HMEM_CTX_REF1 pConnStruc);
      return(1);			// data incomplete yet
    }
    DataLen = pPkt->RemainingLen;
    if(DataLen == 0)
    {
      pPkt = GetNextSSLPacket(pConnStruc);
      continue;
    }

    pSrcBuf = pPkt->pDataBuf;
    SrcOff  = pPkt->Offset;

    if(DataLen < RequiredLen)		// not enough data yet
    {
      if(EncAlgor == CIPHER_ALGOR_RC4)
        RC4(pSrcBuf,SrcOff,DataLen,pDstBuf,DstOff,
	    pConnStruc->ActRX_RC4StateArrayPtr);
      else
        memcpy(pDstBuf+DstOff,pSrcBuf+SrcOff,DataLen);
      DstOff      += DataLen;
      RequiredLen -= DataLen;
      pPkt = GetNextSSLPacket(pConnStruc);
      continue;
    }

    DecryptLen = DataLen;
    if(DecryptLen > RequiredLen)
      DecryptLen = RequiredLen;

    if(EncAlgor == CIPHER_ALGOR_RC4)
      RC4(pSrcBuf,SrcOff,DecryptLen,pDstBuf,DstOff,
	  pConnStruc->ActRX_RC4StateArrayPtr);
    else
      memcpy(pDstBuf+DstOff,pSrcBuf+SrcOff,DecryptLen);

    DstOff      += DecryptLen;
    RequiredLen -= DecryptLen;

    pPkt->Offset       += DecryptLen;
    pPkt->RemainingLen -= DecryptLen;

    if(DecryptLen == DataLen)			// packet processed so far
      pPkt = GetNextSSLPacket(pConnStruc);	// get next packet
  }

  pConnStruc->DecryptOffset      = RECORD_HDR_SIZE;
  pConnStruc->DecryptRequiredLen = RequiredLen;

  return(0);				// Data complete
}
/**
* Decrypts an incomplete single block from SSL input data.
*
*  @param pConnStruc Connection structure
*  @return 0 Block decrpted, > 0 data incomplete
*/
int SSLPktInBlockDecrypt(HMEM_CTX_DEF CONNSTRU * pConnStruc)
{
  int RequiredLen,BlockSize,DataLen,DecryptLen;
  int SrcOff,DstOff;
  char * pDstBuf;
  char * pSrcBuf;
  char * lpIV;
  RX_PKT_PTR pPkt;

  pPkt = pConnStruc->pSSLActRxPkt;

  pDstBuf = pConnStruc->BlockBuffer;
  DstOff  = pConnStruc->BlockBufOffset;

  BlockSize = pConnStruc->BlockLen;		// Cipherblock length

  RequiredLen = BlockSize - pConnStruc->BlockBufDataLen;

  while(RequiredLen > 0)
  {
    if(pPkt == NULL)
    {
      FreeSSLGatherBufsAndFreeList(HMEM_CTX_REF1 pConnStruc);
      return(1);
    }

    DataLen = pPkt->RemainingLen;
    if(DataLen == 0)
    {
      pPkt = GetNextSSLPacket(pConnStruc);
      continue;
    }
    pSrcBuf = pPkt->pDataBuf;
    SrcOff  = pPkt->Offset;

    if(DataLen < RequiredLen)
    {
      memcpy(pDstBuf+DstOff,pSrcBuf+SrcOff,DataLen);
      DstOff      += DataLen;
      RequiredLen -= DataLen;
      pConnStruc->BlockBufDataLen += DataLen;
      pConnStruc->BlockBufOffset  += DataLen;
      pPkt = GetNextSSLPacket(pConnStruc);
      continue;
    }

    DecryptLen = DataLen;
    if(DecryptLen > RequiredLen)
      DecryptLen = RequiredLen;

    memcpy(pDstBuf+DstOff,pSrcBuf+SrcOff,DecryptLen);
    DstOff      += DecryptLen;
    RequiredLen -= DecryptLen;
    pPkt->Offset       += DecryptLen;
    pPkt->RemainingLen -= DecryptLen;

    if(DecryptLen == DataLen)			// packet processed
      pPkt = GetNextSSLPacket(pConnStruc);	// get next packet

  }
  //-------------------------------------------------------
  // One cipherblock is complete now, decrypt it
  //-------------------------------------------------------
  lpIV = pConnStruc->ActRX_IV;		// CBC I-Vector

  pSrcBuf = pConnStruc->BlockBuffer;
  pDstBuf = pConnStruc->pDecryptBuf;
  DstOff  = pConnStruc->DecryptOffset;

  switch(pConnStruc->ActRX_EncAlgor)
  {
    case CIPHER_ALGOR_RC2_CBC:
      RC2_cbc_encdecrypt(pSrcBuf,0,pDstBuf,DstOff,BlockSize,
			 pConnStruc->ActRX_RC2KeyArrayPtr,
			 lpIV,RC2_DECRYPT);
      break;

    case CIPHER_ALGOR_DES_CBC:
      DES_cbc_encrypt_decrypt((unsigned char *) pSrcBuf,
			      (unsigned char *)(pDstBuf+DstOff),
			      (unsigned int *) pConnStruc->ActRX_DESSubkey1TabPtr,
			      1,
			      (unsigned char *) lpIV,
			      DES_DECRYPT);
      break;

    case CIPHER_ALGOR_3DES_EDE_CBC:
      DES3_ede_cbc_encrypt_decrypt((unsigned char *) pSrcBuf,
				   (unsigned char *)(pDstBuf+DstOff),
			           (unsigned int *) pConnStruc->ActRX_DESSubkey1TabPtr,
			           (unsigned int *) pConnStruc->ActRX_DESSubkey2TabPtr,
			           (unsigned int *) pConnStruc->ActRX_DESSubkey3TabPtr,
				   1,
				   (unsigned char *) lpIV,
				   DES_DECRYPT);
      break;

    case CIPHER_ALGOR_AES_CBC:
      m_aes_cbc_decrypt((unsigned char *) pSrcBuf,
	                (unsigned char *) (pDstBuf+DstOff),
			(ds_aes_key *) pConnStruc->ActRX_AESKeyArrayPtr,1,
			(unsigned char *) lpIV,
			(pConnStruc->KeyLen/4)+6);
      break;
  }

  pConnStruc->DecryptRequiredLen -= BlockSize;
  pConnStruc->DecryptOffset      += BlockSize;

  return(0);
}
/**
* Decrypts block ciphered SSL record from SSL RX list.
*
* After decryption, the padding is checked for compliance with the TLS/SSL RFCs.
*
*  @param pConnStruc Connection structure
*  @return 0 data completed
* <br>       > 0 data yet incomplete
* <br>       < 0 error occured
*/
int SSLPktBlockDecrypt(HMEM_CTX_DEF CONNSTRU * pConnStruc)
{
  char PadByte;
  int Retcode;
  int RequiredLen,DstOff,BlockSize,BlockCount;
  int DataLen,SrcOff,CipherLen;
  int PadLen,NewLen;
  char * pDstBuf;
  char * pSrcBuf;
  char * lpIV;
  RX_PKT_PTR pPkt;
  int inl_ret_val = HSSL_OP_OK;

  BlockSize = pConnStruc->BlockLen;

  pPkt = pConnStruc->pSSLActRxPkt;

  RequiredLen = pConnStruc->DecryptRequiredLen;
  pDstBuf     = pConnStruc->pDecryptBuf;
  DstOff      = pConnStruc->DecryptOffset;
  //--------------------------------------------------
  // Decrypt the packet data according to mode active
  //--------------------------------------------------
  while(RequiredLen > 0)
  {
    if(pPkt == NULL)			// no more data given
    {
      pConnStruc->DecryptOffset      = DstOff;
      pConnStruc->DecryptRequiredLen = RequiredLen;
      FreeSSLGatherBufsAndFreeList(HMEM_CTX_REF1 pConnStruc);
      return(1);			// data incomplete yet
    }
    //-----------------------------------------------
    // Check if still data in packet, if not get next
    //-----------------------------------------------
    DataLen = pPkt->RemainingLen;
    if(DataLen == 0)
    {
      pPkt = GetNextSSLPacket(pConnStruc);
      continue;
    }

    pSrcBuf = pPkt->pDataBuf;
    SrcOff  = pPkt->Offset;
    //-----------------------------------------------
    // Check if a single block is currently processed
    //-----------------------------------------------
    if(pConnStruc->BlockBufInUse != 0)
    {
      Retcode = SSLPktInBlockDecrypt(HMEM_CTX_REF1 pConnStruc);
      if(Retcode > 0)			// Data incomplete
        return(Retcode);

      pConnStruc->BlockBufInUse = 0;		// Block processed
      RequiredLen -= BlockSize;
      DstOff      += BlockSize;

      if(RequiredLen == 0)			// very rare case !!!
        break;

      pPkt = pConnStruc->pSSLActRxPkt;		// get active packet if any
      if(pPkt == NULL)				// no more data, save state
        continue;

      DataLen = pPkt->RemainingLen;		// check data in packet
      if(DataLen == 0)
      {
        pPkt = GetNextSSLPacket(pConnStruc);	// get next packet if any
        continue;
      }

      pSrcBuf = pPkt->pDataBuf;			// get current packet source
      SrcOff  = pPkt->Offset;
    }
    //------------------------------------------
    // Check if full blocks possible for decrypt
    //------------------------------------------
    if(DataLen > RequiredLen)
      BlockCount = RequiredLen / BlockSize; // get number of blocks possible
    else
      BlockCount = DataLen / BlockSize;     // dto.

    if(BlockCount == 0)			// incomplete block!!
    {
      pConnStruc->BlockBufOffset  = 0;
      pConnStruc->BlockBufDataLen = 0;
      pConnStruc->BlockBufInUse   = 1;
      Retcode = SSLPktInBlockDecrypt(HMEM_CTX_REF1 pConnStruc);
      if(Retcode > 0)			// Data incomplete
        return(Retcode);

      pConnStruc->BlockBufInUse = 0;
      RequiredLen -= BlockSize;
      DstOff      += BlockSize;

      pPkt = pConnStruc->pSSLActRxPkt;		// get active packet if any
      if(pPkt == NULL)				// no more data, save state
        continue;

      DataLen = pPkt->RemainingLen;		// check data in packet
      if(DataLen == 0)
      {
        pPkt = GetNextSSLPacket(pConnStruc);	// get next packet if any
        continue;
      }

      pSrcBuf = pPkt->pDataBuf;			// get current packet source
      SrcOff  = pPkt->Offset;
    }
    else				// full blocks presented!
    {
      CipherLen = BlockSize * BlockCount;
      lpIV = pConnStruc->ActRX_IV;		// CBC I-Vector

      switch(pConnStruc->ActRX_EncAlgor)
      {
        case CIPHER_ALGOR_RC2_CBC:
          RC2_cbc_encdecrypt(pSrcBuf,SrcOff,pDstBuf,DstOff,
			     BlockSize*BlockCount,
			     pConnStruc->ActRX_RC2KeyArrayPtr,
			     lpIV,RC2_DECRYPT);
          break;

        case CIPHER_ALGOR_DES_CBC:
          DES_cbc_encrypt_decrypt((unsigned char *)(pSrcBuf+SrcOff),
				  (unsigned char *)(pDstBuf+DstOff),
			          (unsigned int *) pConnStruc->ActRX_DESSubkey1TabPtr,
				  BlockCount,
				  (unsigned char *) lpIV,
				  DES_DECRYPT);
          break;

        case CIPHER_ALGOR_3DES_EDE_CBC:
          DES3_ede_cbc_encrypt_decrypt((unsigned char *)(pSrcBuf+SrcOff),
				       (unsigned char *)(pDstBuf+DstOff),
			               (unsigned int *) pConnStruc->ActRX_DESSubkey1TabPtr,
			               (unsigned int *) pConnStruc->ActRX_DESSubkey2TabPtr,
			               (unsigned int *) pConnStruc->ActRX_DESSubkey3TabPtr,
				       BlockCount,
				       (unsigned char *) lpIV,
				       DES_DECRYPT);
          break;

        case CIPHER_ALGOR_AES_CBC:
          m_aes_cbc_decrypt((unsigned char *) (pSrcBuf+SrcOff),
	                    (unsigned char *) (pDstBuf+DstOff),
			    (ds_aes_key *) pConnStruc->ActRX_AESKeyArrayPtr,
			    BlockCount,
			    (unsigned char *) lpIV,
			    (pConnStruc->KeyLen/4)+6);
          break;
      }

      DstOff      += CipherLen;
      RequiredLen -= CipherLen;
      pConnStruc->DecryptOffset      = DstOff;
      pConnStruc->DecryptRequiredLen = RequiredLen;

      pPkt->Offset       += CipherLen;
      pPkt->RemainingLen -= CipherLen;

      if(DataLen == CipherLen)			// packet processed
        pPkt = GetNextSSLPacket(pConnStruc);	// get next packet if any
    }
  }
  //---------------------------------------------------
  // Record has been decrypted so far, check padding
  //---------------------------------------------------
  DstOff = pConnStruc->DecryptLen-1+RECORD_HDR_SIZE;		// position of padding byte
  PadByte = pDstBuf[DstOff];
  PadLen = (int) PadByte & 0x0FF;

  if((PadLen > BlockSize) && (pConnStruc->ActualProtocol == SSL_PROT_TYPE)){
    inl_ret_val |=(HSSL_DECRYPT_INVALID_PADDING);
    PadLen = 0;
  }

  NewLen = pConnStruc->DecryptLen - PadLen - 1;
  if(NewLen < 0){
    inl_ret_val |=(HSSL_DECRYPT_INVALID_PADDING);
    PadLen = 0;
  }

  if((PadLen != 0) && (pConnStruc->ActualProtocol != SSL_PROT_TYPE))
  {
    DstOff -= PadLen;
    inl_ret_val |= m_const_pad_compare(PadLen, DstOff, pDstBuf);
  }

  // Perform dummy comparisons to mitigate Lucky 13 attack
  m_const_pad_compare(256-PadLen, 0, abys_dummy_pad);

  if( HSSL_OP_OK == inl_ret_val ){
     // Perform necessary dummy compressions here
     m_dummy_compress(pConnStruc, pConnStruc->DecryptLen, PadLen);
     pConnStruc->DecryptLen = NewLen;
  } else {
     // Some error happend. Call dummy compression function with -1 padding(no compressions)
     // Leave DecryptLen at full length, so the MAC checking is done on the entire decrypted block
     // Set MAC Error
     m_dummy_compress(pConnStruc, 0, -1);
     inl_ret_val = HSSL_MAC_VERIFY_ERR;
  }
  pConnStruc->DecryptOffset = RECORD_HDR_SIZE;

  //-------------------------------------------------
  // When TLS V1.1 used skip 1st Cipherblock
  //-------------------------------------------------
  if((pConnStruc->ActualProtocol == TLS_V1_PROT_TYPE) ||
     (pConnStruc->ActualProtocol == TLS_V2_PROT_TYPE))
  {
    pConnStruc->DecryptOffset += BlockSize;
    pConnStruc->DecryptLen    -= BlockSize;
  }
  return(inl_ret_val);
}

/**
Decrypts and verifies AES GCM encrypted SSL record from SSL RX list.

@param  adsp_conn   Connection structure
@return 0 data completed, > 0 data yet incomplete, < 0 error occured
*/
static int m_ssl_pkt_gcm_decrypt(HMEM_CTX_DEF CONNSTRU* adsp_conn)
{
    // Fetch current input packet and output buffer
    RX_PKT_PTR adsl_curr_packet = adsp_conn->pSSLActRxPkt;

    int inl_remaining_record_len = adsp_conn->DecryptRequiredLen;
    char* achl_dest = adsp_conn->pDecryptBuf + adsp_conn->DecryptOffset;

    // Iterate over the input data for decryption
    while(inl_remaining_record_len > 0) {

        if(adsl_curr_packet == NULL) {
            // Some data are still missing, return and wait for more data
            adsp_conn->DecryptOffset = (int)(achl_dest - adsp_conn->pDecryptBuf);
            adsp_conn->DecryptRequiredLen = inl_remaining_record_len;
            FreeSSLGatherBufsAndFreeList(HMEM_CTX_REF1 adsp_conn);
            return(1);
        }

        // fetch the actual input buffer
        int inl_input_len = adsl_curr_packet->RemainingLen;

        if( inl_input_len == 0) {
            adsl_curr_packet = GetNextSSLPacket(adsp_conn);
            continue;
        }

        char* achl_input = adsl_curr_packet->pDataBuf + adsl_curr_packet->Offset;

        if( inl_input_len > inl_remaining_record_len ){
            inl_input_len = inl_remaining_record_len;
        }

        m_dec_update_aes_gcm_1(adsp_conn->adsc_recv_gcm_state,
                               achl_dest,
                               achl_input,
                               inl_input_len);

        achl_dest += inl_input_len;
        adsl_curr_packet->RemainingLen -= inl_input_len;
        adsl_curr_packet->Offset += inl_input_len;

        inl_remaining_record_len -= inl_input_len;
    }
    
    adsp_conn->DecryptRequiredLen = 0;

    // Decryption is done, now the validation
    // processed Tag bytes are in the first byte of the temp
    inl_remaining_record_len = (AES_BLOCK_SIZE) - adsp_conn->chrc_aes_gcm_recv_temp[0];
    char* achl_tag_data = adsp_conn->chrc_aes_gcm_recv_temp+1;

    while(inl_remaining_record_len > 0) {

        if(adsl_curr_packet == NULL) {
            // Some data are still missing, return and wait for more data
            FreeSSLGatherBufsAndFreeList(HMEM_CTX_REF1 adsp_conn);
            return(1);
        }

        // fetch the actual input buffer
        int inl_input_len = adsl_curr_packet->RemainingLen;

        if( inl_input_len == 0) {
            adsl_curr_packet = GetNextSSLPacket(adsp_conn);
            continue;
        }
        
        char* achl_input = adsl_curr_packet->pDataBuf + adsl_curr_packet->Offset;

        if( inl_input_len > inl_remaining_record_len ){
            inl_input_len = inl_remaining_record_len;
        }

        memcpy(achl_tag_data + AES_BLOCK_SIZE - inl_remaining_record_len,
               achl_input,
               inl_input_len);

        adsl_curr_packet->RemainingLen -= inl_input_len;
        adsl_curr_packet->Offset += inl_input_len;
        adsp_conn->chrc_aes_gcm_recv_temp[0] += inl_input_len;
        inl_remaining_record_len -= inl_input_len;
    }
    adsp_conn->chrc_aes_gcm_recv_temp[0] = 0;

    if(!m_dec_final_aes_gcm_1(adsp_conn->adsc_recv_gcm_state,
                              achl_tag_data,
                              AES_BLOCK_SIZE))
    {
        return HSSL_MAC_VERIFY_ERR;
    }

    // All done, now set the offset
    adsp_conn->DecryptOffset = RECORD_HDR_SIZE+AES_GCM_EXPL_IV_LEN;

    return HSSL_OP_OK;
}

/**
* Decrypts SSL record direct from received packets.
*
*  @param pConnStruc Connection structure
*  @return 0 completed w/o errors
* <br>            > 0 data incomplete
* <br>            < 0 error occured
*/
int SSLPktDecrypt(HMEM_CTX_DEF CONNSTRU * pConnStruc)
{
  int Retcode;

  switch(pConnStruc->ActRX_EncAlgor)
  {
    case CIPHER_ALGOR_NULL:
    case CIPHER_ALGOR_RC4:
      Retcode = SSLPktStreamDecrypt(HMEM_CTX_REF1 pConnStruc);
      break;

    case CIPHER_ALGOR_RC2_CBC:
    case CIPHER_ALGOR_DES_CBC:
    case CIPHER_ALGOR_3DES_EDE_CBC:
    case CIPHER_ALGOR_AES_CBC:
      Retcode = SSLPktBlockDecrypt(HMEM_CTX_REF1 pConnStruc);
      break;

    case CIPHER_ALGOR_AES_GCM:
        return m_ssl_pkt_gcm_decrypt(HMEM_CTX_REF1 pConnStruc);
    default:
      return(HSSL_DECRYPT_INV_CIPH_ALGOR);	// should not happen!
  }

  return(Retcode);
}
/**
* Skip received packet data for specified length (SkipSslDataPackets).
* Needed when unknown Record type received (allowed in TLS).
*
*  @param pConnStruc Connection structure
*  @return 0 on success, >0 data incomplete
*/
static  int SkipSslDataPackets(CONNSTRU * pConnStruc)
{
  int RequiredLen,DataLen;
  RX_PKT_PTR pPkt;

  RequiredLen = pConnStruc->RecordSkipLen;	// get length to skip
  pPkt = pConnStruc->pSSLActRxPkt;

  while(RequiredLen != 0)
  {
    if(pPkt == NULL)
    {
      pConnStruc->RecordSkipLen = RequiredLen;
      return(1);
    }
    DataLen = pPkt->RemainingLen;
    if(DataLen < RequiredLen)
    {
      RequiredLen -= DataLen;
      pPkt = GetNextSSLPacket(pConnStruc);
      continue;
    }
    else
    {
      pPkt->RemainingLen -= RequiredLen;
      pPkt->Offset       += RequiredLen;
      if(DataLen == RequiredLen)
        pPkt = GetNextSSLPacket(pConnStruc);
      RequiredLen = 0;
    }
  }
  return(HSSL_OP_OK);
}
/**
* Receive SSL-V2 Client hello from packets and process it (RcvProcessSslV2ClntHello).
*
*  @param pConnStruc Connection structure
*  @param pContStat Continue state
*  @return > 0 Data incomplete
* <br>            == 0 on success,
* <br>            < 0 error occured
*/
static  int  RcvProcessSslV2ClntHello(HMEM_CTX_DEF
				CONNSTRU * pConnStruc,int* pContStat)
{
  int Retcode,RequiredLen,DstOff;
  int DataLen,SrcOff,CopyLen;
  char * pDstBuf;
  char * pSrcBuf;
  RX_PKT_PTR pPkt;

  pPkt = pConnStruc->pSSLActRxPkt;

  RequiredLen = pConnStruc->DecryptRequiredLen;
  pDstBuf     = pConnStruc->pDecryptBuf;
  DstOff      = pConnStruc->DecryptOffset;
  //-----------------------------------------------------
  // Process input data as long as data available
  //-----------------------------------------------------
  while(RequiredLen > 0)
  {
    if(pPkt == NULL)			// no more data given
    {
      pConnStruc->DecryptOffset      = DstOff;
      pConnStruc->DecryptRequiredLen = RequiredLen;
      FreeSSLGatherBufsAndFreeList(HMEM_CTX_REF1 pConnStruc);
      return(1);			// data incomplete yet
    }
    DataLen = pPkt->RemainingLen;
    if(DataLen == 0)
    {
      pPkt = GetNextSSLPacket(pConnStruc);
      continue;
    }
    pSrcBuf = pPkt->pDataBuf;
    SrcOff  = pPkt->Offset;
    if(DataLen < RequiredLen)		// not enough data yet
    {
      memcpy(pDstBuf+DstOff,pSrcBuf+SrcOff,DataLen);
      DstOff      += DataLen;
      RequiredLen -= DataLen;
      pPkt = GetNextSSLPacket(pConnStruc);
      continue;
    }

    CopyLen = DataLen;
    if(CopyLen > RequiredLen)
      CopyLen = RequiredLen;

    memcpy(pDstBuf+DstOff,pSrcBuf+SrcOff,CopyLen);

    DstOff      += CopyLen;
    RequiredLen -= CopyLen;

    pPkt->Offset       += CopyLen;
    pPkt->RemainingLen -= CopyLen;

    if(CopyLen == DataLen)			// packet processed so far
      pPkt = GetNextSSLPacket(pConnStruc);	// get next packet
  }
  //-------------------------------------------------
  // SSL V2 client hello received, process it now
  //-------------------------------------------------
  pConnStruc->DecryptOffset      = RECORD_HDR_SIZE;
  pConnStruc->DecryptRequiredLen = RequiredLen;

  pConnStruc->SSLV2Flag = 0;			// reset flag saver

  Retcode = ProcessRX_Message(pConnStruc,(unsigned char) HT_CLIENT_HELLO_V2_LCL,
		              pDstBuf,0,
			      pConnStruc->DecryptLen+RECORD_HDR_SIZE,
			      pContStat);
  FREE_ARRAY_POOL(HMEM_CTX_REF,pDstBuf);
  pConnStruc->pDecryptBuf = NULL;
  return(Retcode);
}

/**
Initializes the recv AES GCM state.

This requires at least the explicit IV to be recevied already.

After successful initialization, DecryptOffset, DecryptLen and DecryptRequiredLen
are updated to cover exactly the encrypted record part.

@param[in,out]  adsp_conn   Pointer to the current session.

@return HSSL_OP_OK on success, 1, if more data are required, <0 on error
*/
static int m_init_aes_gcm_recv(HMEM_CTX_DEF CONNSTRU* adsp_conn)
{
    if(adsp_conn->DecryptLen < (AES_GCM_EXPL_IV_LEN+AES_BLOCK_SIZE)){
        // Record is too small for AES GCM!
        return (HSSL_DECRYPT_INVALID_LEN);
    }

    // Try fetching the explicit IV part. Use the temp to store it over multiple iterations as needed
    int inl_iv_bytes_missing = AES_GCM_EXPL_IV_LEN -
                               (signed char)adsp_conn->chrc_aes_gcm_recv_temp[0];
    char* chrl_iv = adsp_conn->chrc_aes_gcm_recv_temp + 1;
    
    while(inl_iv_bytes_missing > 0) {
        RX_PKT_PTR adsl_curr_packet = adsp_conn->pSSLActRxPkt;

        if(adsl_curr_packet == NULL){
            // Not enough data. store bytes written
            adsp_conn->chrc_aes_gcm_recv_temp[0] = (signed char)AES_GCM_EXPL_IV_LEN -
                                                   (signed char)inl_iv_bytes_missing;
            FreeSSLGatherBufsAndFreeList(HMEM_CTX_REF1 adsp_conn);
            return 1;
        }
        
        int inl_data_len = adsl_curr_packet->RemainingLen;

        if( inl_data_len == 0) {
            adsl_curr_packet = GetNextSSLPacket(adsp_conn);
            continue;
        }

        char* achl_in_data = adsl_curr_packet->pDataBuf + adsl_curr_packet->Offset;

        if( inl_data_len > inl_iv_bytes_missing ){
            inl_data_len = inl_iv_bytes_missing;
        }
        memcpy(chrl_iv+AES_GCM_IV_TOTAL_LEN-inl_iv_bytes_missing,
               achl_in_data,
               inl_data_len);

        inl_iv_bytes_missing -= inl_data_len;
        adsl_curr_packet->Offset += inl_data_len;
        adsl_curr_packet->RemainingLen -= inl_data_len;
    }

    adsp_conn->chrc_aes_gcm_recv_temp[0] = 0;
    
    // Wrtie the implicit IV
    *((unsigned int*)chrl_iv) = *((unsigned int*)adsp_conn->ActRX_IV);

    // Write additional data. Length in header must be reduced
    char chrl_additional_data[SEQUENCE_NUM_LEN+RECORD_HDR_SIZE];
    
    memcpy(chrl_additional_data, adsp_conn->ActRX_SeqNumber, SEQUENCE_NUM_LEN);
    memcpy(chrl_additional_data+SEQUENCE_NUM_LEN,
           adsp_conn->RX_HeaderBuffer,
           RECORD_HDR_SIZE);

    unsigned short unl_len;

    BIGchar2wordn((chrl_additional_data), (unl_len), (SEQUENCE_NUM_LEN+RH_LENGTH_MSB));
    unl_len -= (AES_GCM_EXPL_IV_LEN+AES_BLOCK_SIZE);
    BIGword2charn((unl_len), (chrl_additional_data), (SEQUENCE_NUM_LEN+RH_LENGTH_MSB));

    m_init_aes_gcm_1(adsp_conn->adsc_recv_gcm_state,
                     chrl_additional_data,
                     SEQUENCE_NUM_LEN+RECORD_HDR_SIZE,
                     chrl_iv,
                     AES_GCM_IV_TOTAL_LEN,
                     (ds_aes_key_t*)adsp_conn->ActRX_AESKeyArrayPtr,
                     AES128_KEY_SIZE);
    
    adsp_conn->DecryptOffset += AES_GCM_EXPL_IV_LEN;
    adsp_conn->DecryptLen -= (AES_GCM_EXPL_IV_LEN+AES_BLOCK_SIZE);
    adsp_conn->DecryptRequiredLen -= (AES_GCM_EXPL_IV_LEN+AES_BLOCK_SIZE);

    IncSequenceNumber(adsp_conn->ActRX_SeqNumber);

    return HSSL_OP_OK;
}

/**
* Receives SSL data packets from RX queue and processes it.
*
* Processing involves decryption, decompression, verification and handing it
* to processing routines by message type.
*
* Packet list must have been setup before !!!
*
*  @param pConnStruc Connection structure
*  @param pContStat Continue status
*  @param Entity 0 - server, else client <br>
*  @return 0 - Data complete, decrypted o.k. <br>
*               > 0 - Data incomplete yet, wait for more <br>
*               < 0 - Error occured
*/
int SSLPktReceive(HMEM_CTX_DEF CONNSTRU * pConnStruc, int* pContStat,
		  int Entity)
{
  int Retcode,ContinueStat,TempLen;
  int SrcOff,SrcLen;
  int RecordType,ProtVersionLow; // ProtVersionHigh;

  char * pSrcBuf;
  char * pTmpBuf;
  RX_PKT_PTR pPkt;

  pContStat[0] = STATUS_CONTINUE;
  //---------------------------------------------
  // Process special cases first
  //---------------------------------------------
  if(pConnStruc->RecordSkipLen != 0)
  {
    Retcode = SkipSslDataPackets(pConnStruc);
    return(Retcode);
  }
  if((Entity == 0) && (pConnStruc->SSLV2Flag != 0))
  {
    Retcode = RcvProcessSslV2ClntHello(HMEM_CTX_REF1 pConnStruc,pContStat);
    return(Retcode);
  }
  //---------------------------------------------
  // Distribute by receive state
  //---------------------------------------------
  switch(pConnStruc->SSLPktRxState)
  {
    case SSL_PKT_FIRST_GET:
      if(pConnStruc->pSSLActRxPkt == NULL)
      {
        pPkt = GetNextSSLPacket(pConnStruc);
        if(pPkt == NULL)
          return(1);
      }
      pConnStruc->RxHeaderIndex = 0;			// No data yet
      pConnStruc->SSLPktRxState = SSL_PKT_HDR_GET;	// set next state
    //------------------------------------------
    // 1. Receive the packet header, check it
    //------------------------------------------
    case SSL_PKT_HDR_GET:
      Retcode = ReceiveSslRecordHeader(HMEM_CTX_REF1 pConnStruc,
			               &ContinueStat);
      if(Retcode != 0)				// incomplete/error
        return(Retcode);

      if(pConnStruc->DecryptLen == 0)	// empty record received!!
      {
        pConnStruc->SSLPktRxState = SSL_PKT_FIRST_GET;	// set next state
        return(HSSL_OP_OK);		// no data to process
      }
      //-------------------------------------------
      // Check for recognized Record type now
      // SSL-V2 is indicated by specific flag
      //-------------------------------------------
      RecordType = (int) pConnStruc->RX_HeaderBuffer[0] & 0x0FF;
      if(((RecordType < CT_CHANGE_CIPHER_SPEC) ||
          (RecordType > CT_APPLICATION_DATA)) &&
          ((Entity != 0) || (pConnStruc->SSLV2Flag == 0)))
      {
        //------------------------------------------------
        // unknown record received, check if TLS protocol,
        // if TLS just skip the data packet...
        //------------------------------------------------
        FREE_ARRAY_POOL(HMEM_CTX_REF,pConnStruc->pDecryptBuf);	// free
        pConnStruc->pDecryptBuf = NULL;

        ProtVersionLow = pConnStruc->RX_HeaderBuffer[2] & 0x0FF;
        if(ProtVersionLow == SSL_MINOR_VERSION){
          SendAlert(pConnStruc,AD_ILLEGAL_PARAMETER,ALERT_LEVEL_FATAL);
        } else if(ProtVersionLow == TLS12_MINOR_VERSION){
          SendAlert(pConnStruc,AD_UNEXPECTED_MSG,ALERT_LEVEL_FATAL);
        } else {// TLS1.0/1.1 ignore
          pConnStruc->RecordSkipLen = pConnStruc->DecryptLen; // size to skip
          Retcode = SkipSslDataPackets(pConnStruc);
          return(Retcode);
        }
        pContStat[0] = STATUS_FATAL_ALERT_QUEUED; //   Record Type error    
        return(HSSL_OP_OK);
      }
      //--------------------------------------------------
      // Check if SSL-V2 client hello received
      //--------------------------------------------------
      if((Entity == 0) && (pConnStruc->SSLV2Flag != 0))
      {
        Retcode = RcvProcessSslV2ClntHello(HMEM_CTX_REF1 pConnStruc,pContStat);
        return(Retcode);
      }
    case SSL_PKT_INIT_DEC:
      if(pConnStruc->ActRX_EncAlgor == CIPHER_ALGOR_AES_GCM) {
          Retcode = m_init_aes_gcm_recv(HMEM_CTX_REF1 pConnStruc);
          if(Retcode != HSSL_OP_OK) {
              pConnStruc->SSLPktRxState = SSL_PKT_INIT_DEC;
              return Retcode;
          }
      }

      pConnStruc->SSLPktRxState = SSL_PKT_DECRYPT;	// set next state
    //------------------------------------------
    // 2. Decrypt the record from the packets      
    //------------------------------------------
    case SSL_PKT_DECRYPT:
      Retcode = SSLPktDecrypt(HMEM_CTX_REF1 pConnStruc); 

      if(Retcode > 0){				
        //incomplete package, return the ret code
        return Retcode;
      }

      pConnStruc->SSLPktRxState = SSL_PKT_PROCESS;	// set next state
      break;

    case SSL_PKT_PROCESS:
    default:
      // Retcode variable must be initialized, so set it 0 here
      Retcode = 0;
      break;
  }
  //-----------------------------------------------------------
  // SSL Record has been received and decrypted, verify the MAC
  //-----------------------------------------------------------
  pSrcBuf = pConnStruc->pDecryptBuf;
  SrcOff  = 0;

  SrcLen  = pConnStruc->DecryptLen;
  TempLen  = SrcLen;
  if(((pConnStruc->ActualProtocol == TLS_V1_PROT_TYPE) || (pConnStruc->ActualProtocol == TLS_V2_PROT_TYPE)) &&
     (pConnStruc->ActRX_EncAlgor != CIPHER_ALGOR_NULL) &&
     (pConnStruc->CipherType == ALGOR_TYPE_BLOCK)){
        TempLen += pConnStruc->BlockLen;
  }
  // XOR Retcode to keep result from decrypt phase (Lucky 13)
  Retcode |= VerifyRemoveCipherMac(
				  pConnStruc,pSrcBuf,SrcOff,&TempLen);
  if(Retcode != HSSL_OP_OK)
  {
    FREE_ARRAY_POOL(HMEM_CTX_REF,pSrcBuf);		// free
    pConnStruc->pDecryptBuf = NULL;
    SendAlert(pConnStruc,AD_BAD_RECORD_MAC,ALERT_LEVEL_FATAL);
    pContStat[0] = STATUS_FATAL_ALERT_QUEUED;	// verify error    
    return(Retcode);
  }    
  SrcOff  = RECORD_HDR_SIZE;
  RecordType = (int) pSrcBuf[0] & 0x0FF;
  SrcLen = TempLen;
  if(((pConnStruc->ActualProtocol == TLS_V1_PROT_TYPE) || (pConnStruc->ActualProtocol == TLS_V2_PROT_TYPE)) &&
     (pConnStruc->ActRX_EncAlgor != CIPHER_ALGOR_NULL) &&
     (pConnStruc->CipherType == ALGOR_TYPE_BLOCK)){
        SrcOff += pConnStruc->BlockLen;
        SrcLen = TempLen - pConnStruc->BlockLen;
  }
  if(pConnStruc->ActRX_EncAlgor == CIPHER_ALGOR_AES_GCM){
      SrcOff += AES_GCM_EXPL_IV_LEN;
  }
  //--------------------------------------------------------------
  // Decompress the received, decrypted, verified fragment
  // Send Alert if decompression fails
  //--------------------------------------------------------------
  if(pConnStruc->ActRX_ComprAlgor != COMPR_NULL)
  {
    TempLen = SrcLen;				// set source size
    Retcode = DecompressRecord(pConnStruc,pSrcBuf,SrcOff,
				 &pTmpBuf,&TempLen);
    if(Retcode != HSSL_OP_OK)
    {
      FREE_ARRAY_POOL(HMEM_CTX_REF,pSrcBuf);		// free
      pConnStruc->pDecryptBuf = NULL;
      SendAlert(pConnStruc,AD_DECOMPRESS_FAILURE,ALERT_LEVEL_FATAL);
      pContStat[0] = STATUS_FATAL_ALERT_QUEUED; // decompress error
      return(Retcode);
    }    
    if(pTmpBuf == NULL)			// no system buffers !
    {
      FREE_ARRAY_POOL(HMEM_CTX_REF,pSrcBuf);		// free
      pConnStruc->pDecryptBuf = NULL;
      return(HSSL_RX_BUF_ALLOC_ERR);
    }
    SrcLen = TempLen;			// get data length
    FREE_ARRAY_POOL(HMEM_CTX_REF,pSrcBuf);	// free other buffer
    pSrcBuf = pTmpBuf;
    pConnStruc->pDecryptBuf = pSrcBuf;
    SrcOff = 0;
  }
  // Check for maximum record length
  if( SSL_PLAIN_RECORD_MAX_LEN < SrcLen ){
     // Error code depending on Protocol version 
     ProtVersionLow = pConnStruc->RX_HeaderBuffer[2] & 0x0FF;
     if(ProtVersionLow == SSL_MINOR_VERSION){
        SendAlert(pConnStruc,AD_DECOMPRESS_FAILURE,ALERT_LEVEL_FATAL);
     }else{
        SendAlert(pConnStruc,AD_RECORD_OVERFLOW,ALERT_LEVEL_FATAL);
     }
     pContStat[0] = STATUS_FATAL_ALERT_QUEUED;
     return(HSSL_RX_ILLEGAL_PARAM);
  }
  //--------------------------------------------------------------
  // Distribute the plain fragment to the assembly / test routines
  //--------------------------------------------------------------
  pConnStruc->SSLPktRxState = SSL_PKT_FIRST_GET;	// set next state

  Retcode = HSSL_OP_OK;		// for Compiler (warning)

  switch(RecordType)
  {
    case CT_CHANGE_CIPHER_SPEC:
      Retcode = ProcessRX_ChangeCipherSpec(pConnStruc,pSrcBuf,SrcOff,
					   SrcLen,pContStat);
      break;

    case CT_ALERT:
      Retcode = ProcessRX_Alert(pConnStruc,pSrcBuf,SrcOff,SrcLen,
			        pContStat);
      break;

    case CT_HANDSHAKE:
      Retcode = AssembleProcessRX_Handshake(pConnStruc,pSrcBuf,SrcOff,
				            SrcLen,pContStat);
      break;

    case CT_APPLICATION_DATA:
      Retcode = ProcessRX_ApplData(pConnStruc,pSrcBuf,SrcOff,
				   SrcLen,pContStat);
      pSrcBuf = NULL;			// prevent freeing the buffer !!
      break;

    default:				// can not happen !!
      break;
  } // switch
  FREE_ARRAY_POOL(HMEM_CTX_REF,pSrcBuf);
  pConnStruc->pDecryptBuf = NULL;
  return(Retcode);
}
/**
* Generates the MD5 MAC/HMAC
* used for enciphered blocks (SSL/TLS) (XH3GenerateMD5CipherMac).
* <ol>
*  <li> For SSL the Version is not included in the Hash
*  <li> For TLS V1.1 when in CBC mode, the first block must
*	    not be hashed, a reduced size must be used for hashing!
*</ol>
*
*  @param InpData Base of Input data w/o Header!
*  @param InpOffset Offset to Input data
*  @param DataLen length of data, rel . Offset!
*  @param MacData Base of Destination
*  @param MacOffset Offset to Mac data
*  @param lpSeqNum Base of Sequence Number
*  @param lpMac_I_State Base of Inner State Buffer
*  @param lpMac_O_State Base of Outer State Buffer
*  @param ProtType == 1 -> SSL (without version)<br>
*               == 2 -> TLS 1.0 (with version)<br>
*               == 3 -> TLS 1.1 (with version)
*  @param HeaderData Record header (correct length)
*/
static  void  XH3GenerateMD5CipherMac(char* InpData,
				int InpOffset, int DataLen,
				char* MacData, int MacOffset,
				char* lpSeqNum,
				int* lpMac_I_State,
				int* lpMac_O_State,
				int ProtType, char* HeaderData)
{
  int MD5_Mac_State[MD5_ARRAY_SIZE];
  //------------------------------------------------
  // Generate MD5 MAC/HMAC
  //------------------------------------------------
							// copy inner state
  memcpy(MD5_Mac_State+0,lpMac_I_State+0,(MD5_ARRAY_SIZE)*4);
							// hash Sequence NR.
  MD5_Update(MD5_Mac_State,lpSeqNum,0,SEQUENCE_NUM_LEN);

  switch(ProtType)
  {
    case SSL_PROT_TYPE:					// SSL V3
							// hash content type
      MD5_Update(MD5_Mac_State,HeaderData,0,1);
							// hash length
      MD5_Update(MD5_Mac_State,HeaderData,3,2);
							// data
      MD5_Update(MD5_Mac_State,InpData,InpOffset,DataLen);
      break;

    case TLS_PROT_TYPE:					// TLS V1.0
    case TLS_V1_PROT_TYPE:				// TLS V1.1
    case TLS_V2_PROT_TYPE:				// TLS V1.2
    default:
							// content type, vers.
							// and length
      MD5_Update(MD5_Mac_State,HeaderData,0,RECORD_HDR_SIZE);

      MD5_Update(MD5_Mac_State,InpData,InpOffset,DataLen);
      break;

  } // switch    

  MD5_Final(MD5_Mac_State,MacData,MacOffset);	// save temporary

							// copy outer state
  memcpy(MD5_Mac_State+0,lpMac_O_State+0,(MD5_ARRAY_SIZE)*4);
							// hash the inner hash
  MD5_Update(MD5_Mac_State,MacData,MacOffset,MD5_DIGEST_LEN);
  MD5_Final(MD5_Mac_State,MacData,MacOffset);	// store hash
}
/**
* Generates the SHA1 MAC/HMAC used
* for enciphered blocks (SSL/TLS) (XH3GenerateSHA1CipherMac).
*
*  @param InpData Base of Input data
*  @param InpOffset Offset to Input data
*  @param DataLen length of data, rel . Offset!
*  @param MacData Base of Destination
*  @param MacOffset Offset to Mac data
*  @param lpSeqNum Base of Sequence Number
*  @param lpMac_I_State Base of Inner State Buffer
*  @param lpMac_O_State Base of Outer State Buffer
*  @param ProtType == 1 -> SSL (without version)<br>
*               == 2 -> TLS 1.0 (with version)<br>
*               == 3 -> TLS 1.1 (with version)
*  @param HeaderData Record header (correct length)
*/
static  void  XH3GenerateSHA1CipherMac(char* InpData,
				int InpOffset, int DataLen,
				char* MacData, int MacOffset,
			        char* lpSeqNum,
				int* lpMac_I_State,
			        int* lpMac_O_State,
				int ProtType, char* HeaderData)
{
  int SHA1_Mac_State[SHA_ARRAY_SIZE];
  //------------------------------------------------
  // Generate SHA1 MAC/HMAC
  //------------------------------------------------
							// copy inner state
  memcpy(SHA1_Mac_State+0,lpMac_I_State+0,(SHA_ARRAY_SIZE)*4);
							// hash Sequence NR.
  SHA1_Update(SHA1_Mac_State,lpSeqNum,0,SEQUENCE_NUM_LEN);

  switch(ProtType)
  {
    case SSL_PROT_TYPE:					// SSL V3
							// hash content type
      SHA1_Update(SHA1_Mac_State,HeaderData,0,1);
							// hash length
      SHA1_Update(SHA1_Mac_State,HeaderData,3,2);
							// hash data
      SHA1_Update(SHA1_Mac_State,InpData,InpOffset,DataLen);
      break;

  case TLS_PROT_TYPE:					// TLS V1.0
  case TLS_V1_PROT_TYPE:				// TLS V1.1
  case TLS_V2_PROT_TYPE:				// TLS V1.2
  default:
							// hash content, vers.
							// length
      SHA1_Update(SHA1_Mac_State,HeaderData,0,RECORD_HDR_SIZE);
							// hash data
      SHA1_Update(SHA1_Mac_State,InpData,InpOffset,DataLen);
      break;
  }    
  SHA1_Final(SHA1_Mac_State,MacData,MacOffset);// save temporary

							// copy outer state
  memcpy(SHA1_Mac_State+0,lpMac_O_State+0,(SHA_ARRAY_SIZE)*4);
							// hash inner hash
  SHA1_Update(SHA1_Mac_State,MacData,MacOffset,SHA_DIGEST_LEN);
  SHA1_Final(SHA1_Mac_State,MacData,MacOffset);// store hash
}
/**
* Generates the SHA1 MAC/HMAC used
* for enciphered blocks (SSL/TLS).
*
*  @param InpData Base of Input data
*  @param InpOffset Offset to Input data
*  @param DataLen length of data, rel . Offset!
*  @param MacData Base of Destination
*  @param MacOffset Offset to Mac data
*  @param lpSeqNum Base of Sequence Number
*  @param lpMac_I_State Base of Inner State Buffer
*  @param lpMac_O_State Base of Outer State Buffer
*  @param ProtType == 1 -> SSL (without version)<br>
*               == 2 -> TLS 1.0 (with version)<br>
*               == 3 -> TLS 1.1 (with version)
*  @param HeaderData Record header (correct length)
*/
static  void  XH3GenerateSHA256CipherMac(char* InpData,
				int InpOffset, int DataLen,
				char* MacData, int MacOffset,
			        char* lpSeqNum,
				int* lpMac_I_State,
			        int* lpMac_O_State,
				int ProtType, char* HeaderData)
{
  int SHA256_Mac_State[SHA256_ARRAY_SIZE];
  //------------------------------------------------
  // Generate SHA1 MAC/HMAC
  //------------------------------------------------
							// copy inner state
  memcpy(SHA256_Mac_State+0,lpMac_I_State+0,(SHA256_ARRAY_SIZE)*4);
							// hash Sequence NR.
  SHA256_Update(SHA256_Mac_State,lpSeqNum,0,SEQUENCE_NUM_LEN);

  switch(ProtType)
  {
    case SSL_PROT_TYPE:					// SSL V3
							// hash content type
      SHA256_Update(SHA256_Mac_State,HeaderData,0,1);
							// hash length
      SHA256_Update(SHA256_Mac_State,HeaderData,3,2);
							// hash data
      SHA256_Update(SHA256_Mac_State,InpData,InpOffset,DataLen);
      break;

  case TLS_PROT_TYPE:					// TLS V1.0
  case TLS_V1_PROT_TYPE:				// TLS V1.1
  case TLS_V2_PROT_TYPE:				// TLS V1.2
  default:
							// hash content, vers.
							// length
      SHA256_Update(SHA256_Mac_State,HeaderData,0,RECORD_HDR_SIZE);
							// hash data
      SHA256_Update(SHA256_Mac_State,InpData,InpOffset,DataLen);
      break;
  }    
  SHA256_Final(SHA256_Mac_State,MacData,MacOffset);// save temporary

							// copy outer state
  memcpy(SHA256_Mac_State+0,lpMac_O_State+0,(SHA256_ARRAY_SIZE)*4);
							// hash inner hash
  SHA256_Update(SHA256_Mac_State,MacData,MacOffset,SHA256_DIGEST_LEN);
  SHA256_Final(SHA256_Mac_State,MacData,MacOffset);// store hash
}
/**
* Generates the MAC used
* for enciphered blocks (if a MAC is selected) and the needed
* padding bytes (if a block cipher is used) and stores it (XH3GenMacAndPad).
*
*  @param pConnStruc Connection structure
*  @param pInpData Base of Input Record data
*  @param InpOffset Offset to Input data
*  @param InpLen length of input data
*  @param HeaderData Record header (correct length)
*
*  @return HSSL_OP_OK on success, error code otherwise
*/
static  int  XH3GenMacAndPad(CONNSTRU * pConnStruc,
				 char* pInpData, int InpOffset,
				 int InpLen, char* HeaderData)
{
  int ProtType;
  int DstLen, PadLen, BlockSize, CipherLen;
  char MacAlgor,CipherAlgor;
  char* pDstBuf;

  char* lpSeqNum;
  int* lpMac_I_State;
  int* lpMac_O_State;

  //-----------------------------------------------------------
  // preload pointers, check if MAC algorithm <> MAC_ALGOR_NULL
  //-----------------------------------------------------------
  pDstBuf = pConnStruc->MacPadBuffer;
  DstLen = 0;

  MacAlgor      = pConnStruc->ActTX_MACAlgor;

  if(MacAlgor != MAC_ALGOR_NULL)			// MAC is selected
  {
    ProtType      = pConnStruc->ActualProtocol;

    lpSeqNum      = pConnStruc->ActTX_SeqNumber;
    lpMac_I_State = pConnStruc->ActTX_MAC_I_Array; 
    lpMac_O_State = pConnStruc->ActTX_MAC_O_Array; 
    //-------------------------------------------------
    // MD5 / SHA1 selected, first check buffer space 
    //-------------------------------------------------
    switch(MacAlgor)
    {
      //-------------------------------------------------
      // MD5 selected, generate 
      //-------------------------------------------------
      case MAC_ALGOR_MD5:
        XH3GenerateMD5CipherMac(pInpData, InpOffset, InpLen,	// generate,
			        pDstBuf, 0, lpSeqNum,
				lpMac_I_State,lpMac_O_State,
			        ProtType,HeaderData);
        break;
      //-------------------------------------------------
      // SHA1 selected, generate 
      //-------------------------------------------------
      case MAC_ALGOR_SHA1:
        XH3GenerateSHA1CipherMac(pInpData, InpOffset, InpLen,	// generate,
			         pDstBuf, 0, lpSeqNum,
				 lpMac_I_State,lpMac_O_State,
			         ProtType,HeaderData);
        break;
      //-------------------------------------------------
      // SHA256 selected, generate 
      //-------------------------------------------------
      case MAC_ALGOR_SHA256:
        XH3GenerateSHA256CipherMac(pInpData, InpOffset, InpLen,	// generate,
			         pDstBuf, 0, lpSeqNum,
				 lpMac_I_State,lpMac_O_State,
			         ProtType,HeaderData);
        break;
      case MAC_ALGOR_AES_GCM:
          m_init_aes_gcm_send(pConnStruc, HeaderData);
          memcpy(pConnStruc->EncBlockBuffer, lpSeqNum, SEQUENCE_NUM_LEN);
          pConnStruc->EncBlockIndex = 0;
          pConnStruc->EncBlockLen   = SEQUENCE_NUM_LEN;
          break;
      default:					// should not occur
        return(HSSL_INVALID_MAC_ALGOR);
    } // switch
    //-------------------------------------------------
    // Increment Sequence Number (BIG ENDIAN !)
    //-------------------------------------------------
    IncSequenceNumber(lpSeqNum);

    DstLen = pConnStruc->HashSize;	// set length according to selected MAC

  }
  //---------------------------------------------------
  // Check if a Block cipher is active
  //---------------------------------------------------
  CipherAlgor   = pConnStruc->ActTX_EncAlgor;
  if((CipherAlgor != CIPHER_ALGOR_NULL) &&
     (CipherAlgor != CIPHER_ALGOR_RC4) &&
     (CipherAlgor != CIPHER_ALGOR_AES_GCM))
  {
    BlockSize = pConnStruc->BlockLen;
    CipherLen = (((InpLen + DstLen) / BlockSize) + 1) * BlockSize;

    PadLen = CipherLen - (InpLen + DstLen);
    memset(pDstBuf+DstLen,(char) (PadLen-1), PadLen);

    DstLen += PadLen;
  }
  pConnStruc->MacPadOffset = 0;
  pConnStruc->MacPadLen    = DstLen;

  return(HSSL_OP_OK);
}
/**
* Stream Encrypt data direct from source buffer and MAC-Padding
* buffer to destination buffer (PktStreamEncrypt).
*
*  @param pConnStruc Connection structure
*  @return > 0 no buffer space
* <br>            == 0 on success, all processed
*/
static  int  PktStreamEncrypt(CONNSTRU * pConnStruc)
{
  int SrcLen,SrcOff,DstLen;
  int EncLen;

  char* pSrcBuf;
  char* pDstBuf;

  pDstBuf = *pConnStruc->pEncDstStart;
  DstLen  = (int) (pConnStruc->pEncDstEnd - pDstBuf);

  if((DstLen == 0) || (pDstBuf == NULL))
    return(1);

  pSrcBuf = pConnStruc->pEncSrcBuf;
  SrcOff  = pConnStruc->EncSrcOffset;
  SrcLen  = pConnStruc->EncSrcLen;
  //---------------------------------------------
  // first encrypt the source data
  //---------------------------------------------
  if(SrcLen != 0)
  {
    EncLen = SrcLen;
    if(EncLen > DstLen)
      EncLen = DstLen;

    if(pConnStruc->ActTX_EncAlgor == CIPHER_ALGOR_RC4)
      RC4(pSrcBuf,SrcOff,EncLen,pDstBuf,0,
	  pConnStruc->ActTX_RC4StateArrayPtr);
    else
      memcpy(pDstBuf+0,pSrcBuf+SrcOff,EncLen);

    pDstBuf += EncLen;
    *pConnStruc->pEncDstStart = pDstBuf;

    SrcLen -= EncLen;
    if(SrcLen != 0)			// no buffer space
    {
      pConnStruc->EncSrcOffset += EncLen;
      pConnStruc->EncSrcLen    -= EncLen;
      return(1);
    }
    pConnStruc->EncSrcLen  = 0;		// all encrypted
  }
  //-------------------------------------------------  
  // Encrypt the MAC now
  //-------------------------------------------------  
  pDstBuf = *pConnStruc->pEncDstStart;
  DstLen  = (int) (pConnStruc->pEncDstEnd - pDstBuf);

  pSrcBuf = pConnStruc->MacPadBuffer;
  SrcOff  = pConnStruc->MacPadOffset;
  SrcLen  = pConnStruc->MacPadLen;

  EncLen = SrcLen;
  if(EncLen > DstLen)
    EncLen = DstLen;

  if(pConnStruc->ActTX_EncAlgor == CIPHER_ALGOR_RC4)
    RC4(pSrcBuf,SrcOff,EncLen,pDstBuf,0,
        pConnStruc->ActTX_RC4StateArrayPtr);
  else
    memcpy(pDstBuf+0,pSrcBuf+SrcOff,EncLen);

  pDstBuf += EncLen;
  *pConnStruc->pEncDstStart = pDstBuf;

  SrcLen -= EncLen;
  if(SrcLen != 0)			// no buffer space
  {
    pConnStruc->MacPadOffset += EncLen;
    pConnStruc->MacPadLen    -= EncLen;
    return(1);
  }
  pConnStruc->MacPadLen  = 0;		// all encrypted
  return(HSSL_OP_OK);
}
/**
* Copy single encrypted block to output buffer if possible (CopyPktEncBufDst).
*
*  @param pConnStruc Connection structure
*  @return 0 all copied, > 0 no buffer space
*/
static  int  CopyPktEncBufDst(CONNSTRU * pConnStruc)
{
  int DstLen,CopyLen;
  char* pDstBuf;

  CopyLen = pConnStruc->PartialEncLen;
  pDstBuf = *pConnStruc->pEncDstStart;
  DstLen = (int) (pConnStruc->pEncDstEnd - pDstBuf);

  if((DstLen == 0) || (pDstBuf == NULL))	// no buffer space anyway
    return(1);

  if(CopyLen > DstLen)
    CopyLen = DstLen;
  memcpy(pDstBuf+0,pConnStruc->PartialEncBuf+pConnStruc->PartialEncOff,CopyLen);

  pConnStruc->PartialEncLen -= CopyLen;
  pConnStruc->PartialEncOff += CopyLen;
  pDstBuf += CopyLen;

  *pConnStruc->pEncDstStart = pDstBuf;

  if(pConnStruc->PartialEncLen != 0)
    return(1);
  return(0);
}
/**
* Encrypt a single block in CBC mode in blockbuffer (PktInblockEncrypt).
*
*  @param pConnStruc Connection structure
*/
static  void  PktInblockEncrypt(CONNSTRU * pConnStruc)
{
  int BlockSize;
  char* pBuf;
  char* lpIV;

  BlockSize = pConnStruc->BlockLen;
  pBuf = pConnStruc->PartialEncBuf;

  lpIV = pConnStruc->ActTX_IV;			// CBC I-Vector

  switch(pConnStruc->ActTX_EncAlgor)
  {
    case CIPHER_ALGOR_RC2_CBC:
      RC2_cbc_encdecrypt(pBuf,0,pBuf,0,BlockSize,
			       pConnStruc->ActTX_RC2KeyArrayPtr,
			       lpIV,RC2_ENCRYPT);
      break;

    case CIPHER_ALGOR_DES_CBC:
      DES_cbc_encrypt_decrypt((unsigned char *) pBuf,
			      (unsigned char *) pBuf,
			      (unsigned int *) pConnStruc->ActTX_DESSubkey1TabPtr,
			      1,
			      (unsigned char *) lpIV,
			      DES_ENCRYPT);
      break;

    case CIPHER_ALGOR_3DES_EDE_CBC:
      DES3_ede_cbc_encrypt_decrypt((unsigned char *) pBuf,
				   (unsigned char *) pBuf,
			           (unsigned int *) pConnStruc->ActTX_DESSubkey1TabPtr,
			           (unsigned int *) pConnStruc->ActTX_DESSubkey2TabPtr,
			           (unsigned int *) pConnStruc->ActTX_DESSubkey3TabPtr,
				   1,
				   (unsigned char *) lpIV,
				   DES_ENCRYPT);
      break;

    case CIPHER_ALGOR_AES_CBC:
      m_aes_cbc_encrypt((unsigned char *) pBuf,
	                (unsigned char *) pBuf,
			(ds_aes_key *) pConnStruc->ActTX_AESKeyArrayPtr,
			1,
			(unsigned char *) lpIV,
			(pConnStruc->KeyLen/4)+6);
      break;

    default:				// should not happen
      break;
  }
  pConnStruc->PartialEncOff = 0;
  pConnStruc->PartialEncLen = BlockSize;
}
/**
* Encrypt multi blocks in CBC mode to destination buffer (MultiblockEncrypt).
*
*  @param pConnStruc Connection structure
*  @param pSrcBuf Source buffer
*  @param SrcOff Offset to data
*  @param SrcLen Size of data (multiple blocks)
*  @param pDstBuf Destination buffer
*  @param DstOff Offset to data
*/
static  void  MultiblockEncrypt(CONNSTRU * pConnStruc,
				char* pSrcBuf, int SrcOff, int SrcLen,
				char* pDstBuf, int DstOff)
{
  int BlockSize, BlockCount;
  char* lpIV;

  BlockSize = pConnStruc->BlockLen;
  BlockCount = SrcLen / BlockSize;

  lpIV = pConnStruc->ActTX_IV;			// CBC I-Vector

  switch(pConnStruc->ActTX_EncAlgor)
  {
    case CIPHER_ALGOR_RC2_CBC:
      RC2_cbc_encdecrypt(pSrcBuf,SrcOff,pDstBuf,DstOff,SrcLen,
			 pConnStruc->ActTX_RC2KeyArrayPtr,
			 lpIV,RC2_ENCRYPT);
      break;

    case CIPHER_ALGOR_DES_CBC:
      DES_cbc_encrypt_decrypt((unsigned char *)(pSrcBuf+SrcOff),
			      (unsigned char *)(pDstBuf+DstOff),
			      (unsigned int *) pConnStruc->ActTX_DESSubkey1TabPtr,
			      BlockCount,
			      (unsigned char *) lpIV,
			      DES_ENCRYPT);
      break;

    case CIPHER_ALGOR_3DES_EDE_CBC:
      DES3_ede_cbc_encrypt_decrypt((unsigned char *)(pSrcBuf+SrcOff),
				   (unsigned char *)(pDstBuf+DstOff),
			           (unsigned int *) pConnStruc->ActTX_DESSubkey1TabPtr,
			           (unsigned int *) pConnStruc->ActTX_DESSubkey2TabPtr,
			           (unsigned int *) pConnStruc->ActTX_DESSubkey3TabPtr,
				   BlockCount,
				   (unsigned char *) lpIV,
				   DES_ENCRYPT);
      break;

    case CIPHER_ALGOR_AES_CBC:
      m_aes_cbc_encrypt((unsigned char *) (pSrcBuf+SrcOff),
	                (unsigned char *) (pDstBuf+DstOff),
			(ds_aes_key *) pConnStruc->ActTX_AESKeyArrayPtr,
			BlockCount,
			(unsigned char *) lpIV,
			(pConnStruc->KeyLen/4)+6);
      break;

    default:				// should not happen
      break;
  }
}
/**
* Combine remaining Source and MAC/Padding data into a single
* enciphered block for further processing (CombineSrcAndMac).
*
*  @param pConnStruc Connection structure
*/
static  void  CombineSrcAndMac(CONNSTRU * pConnStruc)
{
  int SrcLen,SrcOff,BlockSize,CopyLen;
  char* pSrcBuf;

  SrcLen  = pConnStruc->EncSrcLen;
  pSrcBuf = pConnStruc->pEncSrcBuf;
  SrcOff  = pConnStruc->EncSrcOffset;
  BlockSize = pConnStruc->BlockLen;

  memcpy(pConnStruc->PartialEncBuf+0,pSrcBuf+SrcOff,SrcLen);
  CopyLen = BlockSize - SrcLen;	// data to complete block

  memcpy(pConnStruc->PartialEncBuf+SrcLen,pConnStruc->MacPadBuffer+0,CopyLen);

  pConnStruc->MacPadOffset += CopyLen;
  pConnStruc->MacPadLen    -= CopyLen;
  pConnStruc->EncSrcLen = 0;
}
/**
* Block Encrypt data direct from source buffer and MAC-Padding
* buffer with intermediate buffer to destination buffer (PktBlockEncrypt).
*
*  @param pConnStruc Connection structure
*  @return > 0 no buffer space
* <br>            == 0 on success
* <br>            < 0 error occured
*/
static  int  PktBlockEncrypt(CONNSTRU * pConnStruc)
{
  int Retcode;
  int SrcLen,SrcOff,BlockSize, BlockCount;
  int CipherLen,DstLen;

  char* pSrcBuf;
  char* pDstBuf;

  pDstBuf = *pConnStruc->pEncDstStart;
  DstLen  = (int) (pConnStruc->pEncDstEnd - pDstBuf);

  if((DstLen == 0) || (pDstBuf == NULL))
    return(1);

  BlockSize = pConnStruc->BlockLen;
  //------------------------------------------------------------
  // Copy single encrypted block (if any pending) to destination
  //------------------------------------------------------------
  if(pConnStruc->PartialEncLen != 0)	// tested
  {
    Retcode = CopyPktEncBufDst(pConnStruc);
    if(Retcode != 0)
      return(Retcode);

    pDstBuf = *pConnStruc->pEncDstStart;
    DstLen  = (int) (pConnStruc->pEncDstEnd - pDstBuf);
    if(DstLen == 0)
      return(1);
  }
  //-------------------------------------------------
  // Check if still source data to process
  //-------------------------------------------------
  SrcLen  = pConnStruc->EncSrcLen;
  while(SrcLen > 0)			// source data to process
  {
    pSrcBuf = pConnStruc->pEncSrcBuf;
    SrcOff  = pConnStruc->EncSrcOffset;

    if(SrcLen < BlockSize)		// incomplete data block, tested
    {
      CombineSrcAndMac(pConnStruc);	// tested
      PktInblockEncrypt(pConnStruc);	// tested
      Retcode = CopyPktEncBufDst(pConnStruc); // tested
      if(Retcode != 0)
        return(Retcode);

      SrcLen = pConnStruc->EncSrcLen;	// reload length !

      pDstBuf = *pConnStruc->pEncDstStart;
      DstLen  = (int) (pConnStruc->pEncDstEnd - pDstBuf);
      if(DstLen == 0)
        return(1);
    }
    else				// enough data for block encrypt
    {
      if(DstLen < BlockSize)		// too small buffer, tested
      {
        memcpy(pConnStruc->PartialEncBuf+0,pSrcBuf+SrcOff,BlockSize);
        pConnStruc->EncSrcLen    -= BlockSize;
        pConnStruc->EncSrcOffset += BlockSize;

        PktInblockEncrypt(pConnStruc);	  // tested
        CopyPktEncBufDst(pConnStruc);	  // tested
        return(1);
      }
      if(DstLen < SrcLen)		// too few buffer, tested
        BlockCount = DstLen/BlockSize;
      else				// enough buffer, tested
        BlockCount = SrcLen/BlockSize;

      CipherLen  = BlockCount * BlockSize;
      MultiblockEncrypt(pConnStruc,pSrcBuf,SrcOff,CipherLen,pDstBuf,0); // tested

      SrcLen -= CipherLen;
      SrcOff += CipherLen;
      pConnStruc->EncSrcOffset += CipherLen;
      pConnStruc->EncSrcLen    -= CipherLen;

      pDstBuf += CipherLen;
      *pConnStruc->pEncDstStart = pDstBuf;
      DstLen  = (int) (pConnStruc->pEncDstEnd - pDstBuf);
      if(DstLen == 0)
        return(1);
    }
  }
  //--------------------------------------------------------------
  // All source data processed so far, continue with MAC/Pad
  // due to padding only multiple of blocksizes are possible
  //--------------------------------------------------------------
  pSrcBuf = pConnStruc->MacPadBuffer;
  SrcOff  = pConnStruc->MacPadOffset;
  SrcLen  = pConnStruc->MacPadLen;

  while(SrcLen != 0)
  {
    pDstBuf = *pConnStruc->pEncDstStart;
    DstLen  = (int) (pConnStruc->pEncDstEnd - pDstBuf);
    if(DstLen == 0)
      return(1);

    if(DstLen < BlockSize)		// tested
    {
      memcpy(pConnStruc->PartialEncBuf+0,pSrcBuf+SrcOff,BlockSize);
      PktInblockEncrypt(pConnStruc);
      CopyPktEncBufDst(pConnStruc);
      pConnStruc->MacPadOffset += BlockSize; 
      pConnStruc->MacPadLen    -= BlockSize;
      return(1);
    }

    if(DstLen < SrcLen)
      BlockCount = DstLen/BlockSize;
    else
      BlockCount = SrcLen/BlockSize;

    CipherLen  = BlockCount * BlockSize;
    MultiblockEncrypt(pConnStruc,pSrcBuf,SrcOff,CipherLen,pDstBuf,0);// tested

    SrcLen -= CipherLen;
    SrcOff += CipherLen;
    pConnStruc->MacPadOffset += CipherLen;
    pConnStruc->MacPadLen    -= CipherLen;

    pDstBuf += CipherLen;
    *pConnStruc->pEncDstStart = pDstBuf;
  }
  return(HSSL_OP_OK);
}

static int m_aes_gcm_record_encrypt(CONNSTRU* adsp_conn)
{
    char* achl_dest = *adsp_conn->pEncDstStart;
    int inl_dest_len  = (int) (adsp_conn->pEncDstEnd - achl_dest);

    if( (achl_dest == NULL) || (inl_dest_len <= 0) ){
        // No destination buffer
        return 1;
    }

    int inl_src_len  = adsp_conn->EncSrcLen;
    
    if(inl_src_len > 0){
        char* achl_src = adsp_conn->pEncSrcBuf + adsp_conn->EncSrcOffset;
        int inl_cipher_len;
        if( inl_src_len > inl_dest_len ) {
            inl_cipher_len = inl_dest_len;
        } else {
            inl_cipher_len = inl_src_len;
        }
        m_enc_update_aes_gcm_1(adsp_conn->adsc_send_gcm_state,
                               achl_dest,
                               achl_src,
                               inl_cipher_len);

        achl_dest += inl_cipher_len;
        adsp_conn->EncSrcOffset += inl_cipher_len;
        *adsp_conn->pEncDstStart = achl_dest;
        inl_dest_len -= inl_cipher_len;
        adsp_conn->EncSrcLen -= inl_cipher_len;
    }

    if(inl_dest_len <= 0) {
        return 1;
    }

    if( adsp_conn->MacPadOffset == 0 ) {
        // Tag is not yet calculated, do it now
        m_enc_final_aes_gcm_1(adsp_conn->adsc_send_gcm_state,
                              adsp_conn->MacPadBuffer,
                              AES_BLOCK_SIZE);
    }

    int inl_tag_copy_size = adsp_conn->MacPadLen;

    if ( inl_tag_copy_size > inl_dest_len ){
        inl_tag_copy_size = inl_dest_len;
    }

    memcpy(achl_dest,
           adsp_conn->MacPadBuffer+adsp_conn->MacPadOffset,
           inl_tag_copy_size);

    *adsp_conn->pEncDstStart += inl_tag_copy_size;

    adsp_conn->MacPadOffset += inl_tag_copy_size;
    adsp_conn->MacPadLen -= inl_tag_copy_size;

    if( adsp_conn->MacPadLen == 0) {
        return HSSL_OP_OK;
    } else {
        return 1;
    }
}

/**
* Encrypt packet/source data in place with MAC/Padlen
* direct to destination buffer (PktEncrypt).
* If no encryption selected, just copy the data / MAC
*
*  @param pConnStruc Connection structure
*  @return 0 all processed,<br> > 0 no buffer space
* <br>            < 0 error occured (should not happen)
*/
static  int  PktEncrypt(CONNSTRU * pConnStruc)
{
  int Retcode;

  switch(pConnStruc->ActTX_EncAlgor)
  {
    case CIPHER_ALGOR_NULL:
    case CIPHER_ALGOR_RC4:
      Retcode = PktStreamEncrypt(pConnStruc);
      break;

    case CIPHER_ALGOR_RC2_CBC:
    case CIPHER_ALGOR_DES_CBC:
    case CIPHER_ALGOR_3DES_EDE_CBC:
    case CIPHER_ALGOR_AES_CBC:
      Retcode = PktBlockEncrypt(pConnStruc);
      break;
    case CIPHER_ALGOR_AES_GCM:
        return m_aes_gcm_record_encrypt(pConnStruc);
    default:
      return(HSSL_DECRYPT_INV_CIPH_ALGOR);
  }
  return(Retcode);
}
/**
* Generate 1st CBC block from random data when TLSV1
* block cipher is in use, encrypt it to temporary buffer (GenTlsV1CbcHeader).
*
*  @param pConnStruc Connection structure
*  @return 0 on success, else error occured
*/
static  int  GenTlsV1CbcHeader(HMEM_CTX_DEF CONNSTRU * pConnStruc)
{
  int Retcode,BlockSize;
  char* pBuf;
  char* lpIV;

  BlockSize = pConnStruc->BlockLen;

  pBuf = pConnStruc->EncBlockBuffer;
  pConnStruc->EncBlockIndex = 0;
  pConnStruc->EncBlockLen   = BlockSize;

  Retcode = SecDrbgRandBytes(HMEM_CTX_REF1 pBuf,0,BlockSize);
  if(Retcode != 0)
    return(Retcode);

  lpIV = pConnStruc->ActTX_IV;		// CBC I-Vector

  switch(pConnStruc->ActTX_EncAlgor)
  {
    case CIPHER_ALGOR_RC2_CBC:
      RC2_cbc_encdecrypt(pBuf,0,pBuf,0,BlockSize,
			 pConnStruc->ActTX_RC2KeyArrayPtr,
			 lpIV,RC2_ENCRYPT);
      break;

    case CIPHER_ALGOR_DES_CBC:
      DES_cbc_encrypt_decrypt((unsigned char *) pBuf,
			      (unsigned char *) pBuf,
			      (unsigned int *) pConnStruc->ActTX_DESSubkey1TabPtr,
			      1,
			      (unsigned char *) lpIV,
			      DES_ENCRYPT);
      break;

    case CIPHER_ALGOR_3DES_EDE_CBC:
      DES3_ede_cbc_encrypt_decrypt((unsigned char *) pBuf,
				   (unsigned char *) pBuf,
			           (unsigned int *) pConnStruc->ActTX_DESSubkey1TabPtr,
			           (unsigned int *) pConnStruc->ActTX_DESSubkey2TabPtr,
			           (unsigned int *) pConnStruc->ActTX_DESSubkey3TabPtr,
				   1,
				   (unsigned char *) lpIV,
				   DES_ENCRYPT);
      break;

    case CIPHER_ALGOR_AES_CBC:
      m_aes_cbc_encrypt((unsigned char *) pBuf,
	                (unsigned char *) pBuf,
			(ds_aes_key *) pConnStruc->ActTX_AESKeyArrayPtr,
			1,
			(unsigned char *)lpIV,
			(pConnStruc->KeyLen/4)+6);
      break;
  }
  return(HSSL_OP_OK);
}
/**
* Wraps an application packet into an encrypted SSL reckord packet and writes 
* it to the provided buffer.
*
* Packets are already limited according to SSL max.
*       record size requirements; but no coalescing will be
*	 done (processed for given length anyway).
*
*  @param pConnStruc Connection structure
*  @param pContStat Continue state
*  @param ppDstBufBase Destination buffer base pointer
*  @param pDstBufTop Destination buffer top pointer
*  @return 0 on success, else error occured
*/
int AppPktTransmit(CONNSTRU * pConnStruc, int* pContStat,
		   char ** ppDstBufBase, char * pDstBufTop)
{
  int Retcode,SrcLen,SrcOff,DstLen,DstBufLen;
  int AddLen,TmpLen,ProtType,CopyLen;
  char * pSrcBuf;
  char * pDstBuf = NULL;

  RX_PKT_PTR pPkt = NULL;

//  CONN_PTR pConnStruc;

  HMEM_CTX_DEF1;
  //------------------------------------------------------
  // Setup Parameters
  //------------------------------------------------------
  pContStat[0]  = STATUS_CONTINUE;

  LOAD_HMEM_CTX_PTR(CONN_pMemCtx(pConnStruc));
  //------------------------------------------------------
  // Distribute according to state
  //------------------------------------------------------
  switch(pConnStruc->APPPktTxState)
  {
    //------------------------------------------
    // 1. Fetch packet to process if any present
    //------------------------------------------
    case APP_PKT_FIRST_GET:
      pPkt = pConnStruc->pAPPActRxPkt;
      if(pPkt == NULL)
      {
	pPkt = GetNextAPPPacket(pConnStruc);
        if(pPkt == NULL)			// no data to process...
          return(HSSL_OP_OK);
      }
      pConnStruc->APPPktTxState = APP_PKT_PROCESS;	// set next state
    //------------------------------------------
    // 2. Process application data packet
    //------------------------------------------
    case APP_PKT_PROCESS:
      pSrcBuf = pPkt->pDataBuf;
      SrcLen  = pPkt->RemainingLen;
      //-------------------------------------------
      // 2.1. Format the send header for given data
      //-------------------------------------------
      ProtType = pConnStruc->ActualProtocol;

      pConnStruc->EncTxHeader[0] = (char) CT_APPLICATION_DATA;
      pConnStruc->EncTxHeader[1] = (char) TLS_SSL_MAJOR_VERSION;
      if(ProtType == SSL_PROT_TYPE)
        pConnStruc->EncTxHeader[2] = (char) SSL_MINOR_VERSION;
      else if(ProtType == TLS_PROT_TYPE)
        pConnStruc->EncTxHeader[2] = (char) TLS10_MINOR_VERSION;
      else if(ProtType == TLS_V1_PROT_TYPE)
        pConnStruc->EncTxHeader[2] = (char) TLS11_MINOR_VERSION;
      else
        pConnStruc->EncTxHeader[2] = (char) TLS12_MINOR_VERSION;

      pConnStruc->EncTxHeader[3] = (char) (SrcLen >> 8);
      pConnStruc->EncTxHeader[4] = (char) SrcLen;
      //--------------------------------------------
      // 2.2. Compress data if compression is active
      //--------------------------------------------
      if(pConnStruc->ActTX_ComprAlgor != COMPR_NULL)
      {
        DstBufLen = SrcLen + SSL_COMPR_ADDITIONAL_LEN;
        pDstBuf = BIT8_ARRAY_ALLOC_POOL(HMEM_CTX_REF,DstBufLen);
        if(pDstBuf == NULL)
          return(HSSL_TX_BUF_ALLOC_ERR);

        pConnStruc->pEncryptBuf = pDstBuf;

        TmpLen = DstBufLen;
        Retcode = CompressRecord(pConnStruc,pSrcBuf,0,SrcLen,
				 pDstBuf,0,&TmpLen);
	if(Retcode != HSSL_OP_OK)
        {
          FREE_ARRAY_POOL(HMEM_CTX_REF,pDstBuf);
          pConnStruc->pEncryptBuf = NULL;
	  PurgeTxQueues(pConnStruc);
          pContStat[0] = STATUS_MUST_CLOSE_IMMEDIATE;
          return(Retcode);
        }
        SrcLen  = TmpLen;		// set new size
        pSrcBuf = pDstBuf;		// set source for MAC/encrypt
      }
      //-----------------------------------------------------------
      // 2.3. Generate the MAC/Padding
      //-----------------------------------------------------------
      if(pConnStruc->ActRX_EncAlgor == CIPHER_ALGOR_AES_GCM ) {
          BIGword2charn((SrcLen+AES_GCM_EXPL_IV_LEN),pConnStruc->EncTxHeader,3); // set length of data
      } else {
          BIGword2charn(SrcLen,pConnStruc->EncTxHeader,3); // set length of data
      }
      Retcode = XH3GenMacAndPad(pConnStruc,pSrcBuf,0,SrcLen,
				pConnStruc->EncTxHeader);
      if(Retcode != HSSL_OP_OK)
      {
        FREE_ARRAY_POOL(HMEM_CTX_REF,pDstBuf);			// free
        pConnStruc->pEncryptBuf = NULL;
        PurgeTxQueues(pConnStruc);			// release queues
        pContStat[0] = STATUS_MUST_CLOSE_IMMEDIATE;
//      DBG_PRINT("MAC generate Failed\n");
        return(Retcode);
      }
      //-----------------------------------------------------------
      // 2.4. If TLS V1.1 CBC prepare random data block, encrypt it
      // will be output after record header from buffer
      //-----------------------------------------------------------
      if((pConnStruc->ActTX_EncAlgor != CIPHER_ALGOR_NULL) &&
         (pConnStruc->CipherType == ALGOR_TYPE_BLOCK) &&
         ((pConnStruc->ActualProtocol == TLS_V1_PROT_TYPE) ||
          (pConnStruc->ActualProtocol == TLS_V2_PROT_TYPE)))
      {
        Retcode = GenTlsV1CbcHeader(HMEM_CTX_REF1 pConnStruc);
        if(Retcode != 0)
        {
          FREE_ARRAY_POOL(HMEM_CTX_REF,pDstBuf);	// free
          pConnStruc->pEncryptBuf = NULL;
          PurgeTxQueues(pConnStruc);			// release queues
          pContStat[0] = STATUS_MUST_CLOSE_IMMEDIATE;
//        DBG_PRINT("TLSV1 CBC random append Failed\n");
          return(Retcode);
        }
      }
      //---------------------------------
      // 2.5. Set the final record length
      //---------------------------------
      DstLen = SrcLen + pConnStruc->EncBlockLen + pConnStruc->MacPadLen;
      BIGword2charn(DstLen,pConnStruc->EncTxHeader,3); // set length of data

      pConnStruc->EncHdrSendLen   = RECORD_HDR_SIZE;
      pConnStruc->EncHdrSendIndex = 0;

      pConnStruc->pEncSrcBuf   = pSrcBuf;
      pConnStruc->EncSrcOffset = 0;
      pConnStruc->EncSrcLen    = SrcLen;

      pConnStruc->pEncDstStart = ppDstBufBase;
      pConnStruc->pEncDstEnd   = pDstBufTop;

      pConnStruc->APPPktTxState   = APP_PKT_HDR_SEND;
      //---------------------------------------------------
      // 3. Try to send record header now
      //---------------------------------------------------
    case APP_PKT_HDR_SEND:
      SrcLen  = pConnStruc->EncHdrSendLen;
      SrcOff  = pConnStruc->EncHdrSendIndex;
      pSrcBuf = pConnStruc->EncTxHeader;

      DstLen = (int) (pDstBufTop - *ppDstBufBase);
      if(DstLen == 0)		// no buffer space
        return(1);

      CopyLen = SrcLen;
      if(CopyLen > DstLen)
        CopyLen = DstLen;

      memcpy(*ppDstBufBase+0,pSrcBuf+SrcOff,CopyLen);
      SrcLen -= CopyLen;
      SrcOff += CopyLen;
      *ppDstBufBase += CopyLen;

      pConnStruc->EncHdrSendIndex = SrcOff;
      pConnStruc->EncHdrSendLen   = SrcLen;
      if(SrcLen != 0)		// no buffer space
        return(1);

      pConnStruc->APPPktTxState = APP_PKT_PREFIX_SEND;
      //------------------------------------------------------
      // 4. Try to send encrypted Predata (TLS V1.1) if needed
      //------------------------------------------------------
    case APP_PKT_PREFIX_SEND:
      AddLen  = pConnStruc->EncBlockLen;
      if(AddLen != 0)
      {
        SrcLen  = AddLen;
        SrcOff  = pConnStruc->EncBlockIndex;
        pSrcBuf = pConnStruc->EncBlockBuffer;

        DstLen = (int) (pDstBufTop - *ppDstBufBase);	// get len

        if(DstLen == 0)		  // no buffer space
          return(1);

        CopyLen = SrcLen;
        if(CopyLen > DstLen)
          CopyLen = DstLen;

        memcpy(*ppDstBufBase+0,pSrcBuf+SrcOff,CopyLen);

        SrcLen -= CopyLen;
        SrcOff += CopyLen;
        *ppDstBufBase += CopyLen;

        pConnStruc->EncBlockIndex = SrcOff;
        pConnStruc->EncBlockLen   = SrcLen;
        if(SrcLen != 0)		// no buffer space
          return(1);
      }
      pConnStruc->APPPktTxState = APP_PKT_DATA_SEND;
      //---------------------------------------------------
      // 5. Try to encrypt/send source/MAC/Pad data now
      //---------------------------------------------------
    case APP_PKT_DATA_SEND:
      pConnStruc->pEncDstStart = ppDstBufBase;
      pConnStruc->pEncDstEnd   = pDstBufTop;

      Retcode = PktEncrypt(pConnStruc);
      if(Retcode > 0)
        return(Retcode);
      if(Retcode < 0)
      {
        FREE_ARRAY_POOL(HMEM_CTX_REF,pConnStruc->pEncryptBuf);	// free
        pConnStruc->pEncryptBuf = NULL;
        PurgeTxQueues(pConnStruc);			// release queues
        pContStat[0] = STATUS_MUST_CLOSE_IMMEDIATE;
//      DBG_PRINT("Encrypt Failed\n");
        return(Retcode);
      }
      pConnStruc->APPPktTxState = APP_PKT_POSTPROCESS;
      //-------------------------------------------------------
      // 6. Postprocess application data (all sent from packet)
      //-------------------------------------------------------
    case APP_PKT_POSTPROCESS:
      FREE_ARRAY_POOL(HMEM_CTX_REF,pConnStruc->pEncryptBuf);
      pConnStruc->pEncryptBuf = NULL;
      GetNextAPPPacket(pConnStruc);
      FreeAPPGatherBufsAndFreeList(HMEM_CTX_REF1 pConnStruc);
      pConnStruc->APPPktTxState = APP_PKT_FIRST_GET;
      return(HSSL_OP_OK);

    default:				// should not happen
      return(HSSL_PARAM_ERR);
  } // Switch
}
/**
* Processes data from the TX (outgoing) priority queue only and puts it to 
* sending buffers (HSSL_XH3ATcp_Transmit).
*
* @see m_xh_transmit
*
*  @param pConnStruc Connection structure
*  @param pContStat Continue State
*  @param ppDstBufBase Destination buffer base pointer
*  @param pDstBufTop Destination buffer top
*
*  @return HSSL_OP_OK on success, error code otherwise
*/
extern "C" int  HSSL_XH3ATcp_Transmit(CONNSTRU * pConnStruc,
				      int* pContStat, char ** ppDstBufBase,
				      char * pDstBufTop)
{
  int inl_shutdown_reason = 0;
  
  return m_xh_transmit( pConnStruc, pContStat, &inl_shutdown_reason, 
     FALSE, ppDstBufBase, pDstBufTop);
}
/**
* Prepares Application data send and
* sends the application data if connection is established (XH3ASSL_Send).
*
*  The SSL interface must already have a connection structure.
*
*  @param pXif3Struc Interface Structure
*  @return 0 on success, else error occured
*/
static  int XH3ASSL_Send(struct dsd_hl_ssl_s_3 * pXif3Struc)
{
  int Retcode;
  int ContStat;

  RX_PKT_PTR pPkt = NULL;
  CONNSTRU * pConnStruc;
  HMEM_CTX_DEF1;

  //------------------------------------------------------
  // Setup Parameters
  //------------------------------------------------------
  pConnStruc = ((XHCONNSTRUC *) pXif3Struc->ac_ext)->pConnStruc;

  LOAD_HMEM_CTX_PTR(CONN_pMemCtx(pConnStruc));

  if(pConnStruc->ConnectionState != CONN_STATE_CONNECTED)
    return(HSSL_OP_OK);
  //-----------------------------------------------------
  // Check if data from application layer present, but only
  // if there is no active packet element
  //-----------------------------------------------------
  if((pConnStruc->pAPPActRxPkt == NULL) &&
     (pConnStruc->pAPPRxPktToFreeAnchor == NULL))
  {
      pPkt = m_gen_app_rx_list(HMEM_CTX_REF1 
                               pConnStruc,
                               pXif3Struc->adsc_gai1_fromse);
    if(pPkt == NULL)
      return(HSSL_OP_OK);

    pConnStruc->pAPPRxPktInUseAnchor = pPkt->pNext;
    pConnStruc->pAPPActRxPkt         = pPkt;
  }
  //--------------------------------
  // Process application data (send)
  //--------------------------------
  pPkt = pConnStruc->pAPPActRxPkt;
  for(;;)
  {
    if(pPkt == NULL)
      return(HSSL_OP_OK);

    Retcode = AppPktTransmit(pConnStruc,&ContStat,
			     &pXif3Struc->achc_tocl_cur,
			     pXif3Struc->achc_tocl_end);
    if(Retcode > 0)		  // no more buffer space
      return(HSSL_OP_OK);
    if(Retcode != HSSL_OP_OK)
      return(Retcode);

    pPkt = pConnStruc->pAPPActRxPkt;
  }
}
/**
* Performs handshake phase for connection
* setup (XH3ADoHandshake). 
* The start message is already queued to the priority
* send queue and must be sent first.
* 
*  @param pXif3Struc Interface Structure
*
*  @return HSSL_OP_OK on success, error code otherwise
*/
static int XH3ADoHandshake(struct dsd_hl_ssl_s_3 * pXif3Struc)
{
  int Retcode;
  int pTmpContStat[1];

  CONNSTRU * pConnStruc;
  XHCONNSTRUC * pXHConnStruc;

  HMEM_CTX_DEF1;

  //-----------------------------------------
  // Get Structure pointers
  //-----------------------------------------
  pXHConnStruc = (XHCONNSTRUC *) pXif3Struc->ac_ext;	// get control structure
  pConnStruc   = pXHConnStruc->pConnStruc;

  LOAD_HMEM_CTX_PTR(CONN_pMemCtx(pConnStruc));
  //-----------------------------------------
  // Send / Get data to send, try to send
  //-----------------------------------------
  Retcode = HSSL_XH3ATcp_Transmit(pConnStruc,pTmpContStat,
				  &pXif3Struc->achc_tocl_cur,
				  pXif3Struc->achc_tocl_end);
  if(Retcode != HSSL_OP_OK)
  {
    //------------------------------------------
    // invalidate resumability for session cache
    //------------------------------------------
    // !!!! implement that later !!!! -> no, leave open!

    return(Retcode);				// set error reason
  }
  //--------------------------------------------
  // Distribute by mode
  //--------------------------------------------
  switch(pXHConnStruc->XHConnState)		// distribute...
  {
    case XH_STATE_CONNECT_START:		// connect data queued check
      pXHConnStruc->XHConnState = XH_STATE_CONNECT_SEND; // set next state
      if(pConnStruc->pTxFragmentBuffer != NULL)	// not all data sent yet
        return(HSSL_OP_OK);
      pXHConnStruc->XHConnState = XH_STATE_CONNECT_WAIT;// all sent, do receive
      break;
    //---------------------------------------------------
    // First Send part still in Transmit
    //---------------------------------------------------
    case XH_STATE_CONNECT_SEND:			// sending active
      if(pConnStruc->pTxFragmentBuffer != NULL)	// not all data sent yet
        return(HSSL_OP_OK);
      pXHConnStruc->XHConnState = XH_STATE_CONNECT_WAIT;// all sent, do receive
      break;
    //---------------------------------------------------
    // Connect is in exchange state
    //---------------------------------------------------
    case XH_STATE_CONNECT_WAIT:			// dummy
      break;
    //---------------------------------------------------
    // Connect is in alert send state
    //---------------------------------------------------
    case XH_STATE_CONNECT_ALERT:		// must send alert
      if(pConnStruc->pTxFragmentBuffer != NULL)	// not all data sent yet
        return(HSSL_OP_OK);

      pXHConnStruc->XHConnState = XH_STATE_CONNECT_CLOSING;	// all data buffered for send..
      return(HSSL_OP_OK);
    //---------------------------------------------------
    // Connect is in closing state
    //---------------------------------------------------
    case XH_STATE_CONNECT_CLOSING:		// all sent...
      pXHConnStruc->XHConnState = XH_STATE_CLOSED;
      Retcode = pXHConnStruc->DeferredRetcode;
      return(Retcode);
    //------------------------------------------------
    // is in invalid state...
    //------------------------------------------------
    default:
      return(HSSL_NEWCONN_STATE_ERR);
  } // switch
  //------------------------------------------------
  // Receive data if any data present
  //------------------------------------------------
  if((pConnStruc->pSSLRxPktInUseAnchor != NULL) ||
     (pConnStruc->pSSLActRxPkt != NULL))
  {
    Retcode = SSLPktReceive(HMEM_CTX_REF1 pConnStruc, pTmpContStat,0);
    if(Retcode > 0)				// data incomplete
      return(HSSL_OP_OK);

    if((Retcode != HSSL_OP_OK) ||
       (pTmpContStat[0] == STATUS_FATAL_ALERT_QUEUED))
    {
      //------------------------------------------
      // invalidate resumability for session cache
      //------------------------------------------
      // !!!! implement that later !!!! -> no, leave open

      if((pTmpContStat[0] == STATUS_FATAL_ALERT_QUEUED) &&
         (Retcode != HSSL_OP_OK))
      {
        pXHConnStruc->XHConnState = XH_STATE_CONNECT_ALERT;
        pXHConnStruc->DeferredRetcode = Retcode;
        return(HSSL_OP_OK);
      }

      if(Retcode != HSSL_OP_OK)
      {
        return(Retcode);
      }
      return(Retcode);
    }
  }
  Retcode = HSSL_XH3ATcp_Transmit(pConnStruc,pTmpContStat,
				  &pXif3Struc->achc_tocl_cur,
				  pXif3Struc->achc_tocl_end);
  if(Retcode != HSSL_OP_OK)
  {
    //------------------------------------------
    // invalidate resumability for session cache
    //------------------------------------------
    // !!!! implement that later !!!! --> no, leave as is

    return(Retcode);
  }
  if(pConnStruc->ConnectionState == CONN_STATE_CONNECTED)
  {
    if(pConnStruc->pPriorityTxQueueHead == NULL) // all Handshake data sent
      pXHConnStruc->XHConnState = XH_STATE_NORMAL;   // so switch to normal...
    return(HSSL_OP_OK);
  }
  return(HSSL_OP_OK);
}
/**
* Prepare SSL receive list if no elements active/queued (PrepSslPktList).
*
*  @param pConnStruc Connection structure
*  @param pGatherStruc Gather Structure
*
*  @return HSSL_OP_OK on success, error code otherwise
*/
static int PrepSslPktList(CONNSTRU * pConnStruc,
			   struct dsd_gather_i_1 * pGatherStruc)
{
  RX_PKT_PTR pPkt = NULL;
  HMEM_CTX_DEF1;
  //------------------------------------------------------
  // Setup Parameters
  //------------------------------------------------------

  LOAD_HMEM_CTX_PTR(CONN_pMemCtx(pConnStruc));
  //-----------------------------------------------------
  // Check if data from TCP-SSL layer present, but only
  // if there is no active packet element
  //-----------------------------------------------------
  if((pConnStruc->pSSLRxPktInUseAnchor == NULL) &&
     (pConnStruc->pSSLRxPktToFreeAnchor == NULL))
  {
    pPkt = GenSSLRxPktList(HMEM_CTX_REF1 pGatherStruc);
    if(pPkt == NULL)
      return(HSSL_OP_OK);

    pConnStruc->pSSLRxPktInUseAnchor = pPkt->pNext;
    pConnStruc->pSSLActRxPkt         = pPkt;
  }
  return(HSSL_OP_OK);
}
/**
* Free SSL receive list if all Application RX and SSL TX
* data have been processed (CheckFreeSSLRxPktList).
*
*  @param pConnStruc Connection structure
*/
static  void  CheckFreeSSLRxPktList(CONNSTRU * pConnStruc)
{
  HMEM_CTX_DEF1;
  //------------------------------------------------------
  // Check if to free list exists at all
  //------------------------------------------------------
  if(pConnStruc->pSSLRxPktToFreeAnchor == NULL)
    return;
  //------------------------------------------------------
  // Check if all SSL data have been transmitted so far
  //------------------------------------------------------
  if((pConnStruc->pPriorityTxQueueHead != NULL) ||  // Priority data on Queue
     (pConnStruc->pApplicationRxQueueHead != NULL)) // Application data queued
    return;
  //------------------------------------------------------
  // Free the SSL packet list now
  //------------------------------------------------------
  LOAD_HMEM_CTX_PTR(CONN_pMemCtx(pConnStruc));
  FreeSSLGatherBufsAndFreeList(HMEM_CTX_REF1 pConnStruc);
}
/**
* Processes a step in the disconnecting procedure of a SSL/TLS connection (XH3ASSL_Disconnect).
* Steps consist of sending required alerts, sending pending TX data, flushing
* buffers and releasing used resources in the interface structure.
*
* The return satus of the procedure is in the return parameter of the interface
* structure.
*
* Server side. This variant does not send pending application data.
*
*  @param pXif3Struc Interface Structure
*  @return == 0 on success
* <br>            < 0 rejected
*/
extern "C" int XH3ASSL_Disconnect(struct dsd_hl_ssl_s_3 * pXif3Struc)
{
  int Retcode;
  CONNSTRU * pConnStruc;

  int pTmpContState[1];

  HMEM_CTX_DEF1;

  //-----------------------------------------------------
  // check parameters
  //-----------------------------------------------------
  if((pXif3Struc == NULL) || (pXif3Struc->ac_ext == NULL) ||
     ((pConnStruc = ((XHCONNSTRUC *) pXif3Struc->ac_ext)->pConnStruc) == NULL))
    return(HSSL_NULL_PTR);

  LOAD_HMEM_CTX_PTR(CONN_pMemCtx(pConnStruc));
  //-----------------------------------------------------
  // check if this is a TX-Continuation (Alert/Data etc.)
  //-----------------------------------------------------
  if(((XHCONNSTRUC *) pXif3Struc->ac_ext)->XHConnState == XH_STATE_CLOSING)
  {
    if((pXif3Struc->boc_eof_client) ||
       ((pConnStruc->pPriorityTxQueueHead == NULL) && // no more data to send
        (pConnStruc->pApplicationTxQueueHead == NULL)))
    {
      FreeXH3ConnStateStruct(HMEM_CTX_REF,pXif3Struc); // free all used...
      pXif3Struc->inc_return = DEF_IRET_END;	// ended
//    DBG_PRINT("\nHSSL Ended, Mode 0");
      return(HSSL_OP_OK);
    }
    //-----------------------------------------------
    // Continue sending data...
    //-----------------------------------------------
    Retcode = HSSL_XH3ATcp_Transmit(pConnStruc,pTmpContState,
				    &pXif3Struc->achc_tocl_cur,
				    pXif3Struc->achc_tocl_end);
    if((Retcode != HSSL_OP_OK) ||		// error during send
       (pTmpContState[0] != STATUS_CONTINUE))	// cannot continue
    {
      FreeXH3ConnStateStruct(HMEM_CTX_REF,pXif3Struc); // free all used...
      pXif3Struc->inc_return = DEF_IRET_END;	// ended
//    DBG_PRINT("\nHSSL Ended, Mode 1");
      return(HSSL_OP_OK);
    }
    pXif3Struc->inc_return = DEF_IRET_NORMAL;	// try to send...
    return(HSSL_OP_OK);
  }
  else						// is shutdown initiate
  {
    if(pXif3Struc->boc_eof_client)		// no socket for send data
    {
      FreeXH3ConnStateStruct(HMEM_CTX_REF,pXif3Struc);// free all used...
      pXif3Struc->inc_return = DEF_IRET_END;	// ended
//    DBG_PRINT("\nHSSL Ended, Mode 2\n");
      return(HSSL_OP_OK);
    }
    //--------------------------------------------------------
    // Socket is still valid
    //--------------------------------------------------------
    ((XHCONNSTRUC *) pXif3Struc->ac_ext)->XHConnState = XH_STATE_CLOSING; // set next state
    //-----------------------------------------------------
    // Check if session was a new or a resumed session
    //-----------------------------------------------------
    if(pConnStruc->CacheMode > CACHE_SESSION_TYPE_NEW)
    {
      //---------------------------------------------------
      // session was a resumed session, queue closure alert
      //---------------------------------------------------
      // !!! reduce session reference count !!!

      if(pConnStruc->ConnectionState == CONN_STATE_CONNECTED)
        SendAlert(pConnStruc,AD_CLOSE_NOTIFY,ALERT_LEVEL_WARNING);
      else    
        SendAlert(pConnStruc,AD_CLOSE_NOTIFY,ALERT_LEVEL_FATAL);
    }
    else
    {
      //---------------------------------------------------
      // session was a new session, check if resumable
      //---------------------------------------------------
      if(((pConnStruc->SessionID[0] & 0xFF) != 0) &&	// resumable
        (pConnStruc->ConnectionState == CONN_STATE_CONNECTED))
      {
        SendAlert(pConnStruc,AD_CLOSE_NOTIFY,ALERT_LEVEL_WARNING);
      // !!! reduce session reference count !!!
      }
      else						// not resumable
        SendAlert(pConnStruc,AD_CLOSE_NOTIFY,ALERT_LEVEL_FATAL);
    }  
    //-----------------------------------------------------------------
    // Try to send data from the Transmit queues as long as possible
    //-----------------------------------------------------------------
    Retcode = HSSL_XH3ATcp_Transmit(pConnStruc,pTmpContState,
				    &pXif3Struc->achc_tocl_cur,
				    pXif3Struc->achc_tocl_end);
    if((Retcode != HSSL_OP_OK) || (pTmpContState[0] != STATUS_CONTINUE))
    {
      FreeXH3ConnStateStruct(HMEM_CTX_REF,pXif3Struc); // free all used...
      pXif3Struc->inc_return = DEF_IRET_END;	// ended
//    DBG_PRINT("\nHSSL Ended, Mode 3");
      return(HSSL_OP_OK);
    }
    pXif3Struc->inc_return = DEF_IRET_NORMAL;	// try to send...
    return(HSSL_OP_OK);
  }
}
//*********************************************************
//
// The HOBLink/HOBCom Server Interface as defined by
// Mr. Klaus Brandstaetter, V3
//
//*********************************************************

/**
Writes a log message specifying the bytes in the input gathers.

@param[in]  adsp_conn      Pointer to the current session structure.
@param[in]  adsp_from_peer Gather containing the input from the peer.
@param[in]  adsp_from_app  Gather containing the input fropm application.
*/
static void m_log_gathers(CONNSTRU * adsp_conn, 
                          struct dsd_gather_i_1* adsp_from_peer,
                          struct dsd_gather_i_1* adsp_from_app)
{
   int inl_gather_len = (int)m_calc_gather_len(adsp_from_peer);
   if(0 != inl_gather_len){
      m_generate_log_msg(adsp_conn, "SSL received %i bytes from peer.", inl_gather_len,HL_AUX_WT_DATA2,"SSLINP");
   } else {
      m_generate_log_msg(adsp_conn, "SSL received 0 bytes from peer.", 0,HL_AUX_WT_DATA2,"SSLINP");
   }

   inl_gather_len = (int)m_calc_gather_len(adsp_from_app);
   if(0 != inl_gather_len){
      m_generate_log_msg(adsp_conn, "SSL received %i bytes from application.", inl_gather_len,HL_AUX_WT_DATA2,"SSLINP");
   } else {
      m_generate_log_msg(adsp_conn, "SSL received 0 bytes from application.", 0,HL_AUX_WT_DATA2,"SSLINP");
   }
}

/**
Process the continuation in m_hlse03.

Process is as described in m_hlse03:

<ol>
  <li> Process messages from priority send queue, if available.
  <li> Check, if either side has closed the connection.
  <li> Continue processing handshake, if required.
  <li> Process received data.
  <li> Process data to be sent.
  <li> Copy data to be sent to the respective buffer.
  <li> Copy received data to the respective buffer.
  <li> Cleanup the receive queue, if it is empty.
</ol>

It is assumed, that both parameters are valid and non-NULL.
The adsp_ssl_conn structure may be invalidated by this function. If so, the member 
ac_ext of adsp_xh_conn will be set to NULL.

@param[in]  adsp_xh_conn   Pointer to the parameter structure used by m_hlse03.
@param[in]  adsp_ssl_conn  Pointer to the structure of the current ssl connection.
*/
static void m_process_se_cont(struct dsd_hl_ssl_s_3 * adsp_xh_conn, 
                              CONNSTRU * adsp_ssl_conn)
{
   XHCONNSTRUC * pXhConnStruc = (XHCONNSTRUC *) adsp_xh_conn->ac_ext; // get connection structure
   int Retcode = HSSL_OP_OK;
   int pTmpContStat[1];
   HMEM_CTX_DEF1;
   
   LOAD_HMEM_CTX_PTR(adsp_ssl_conn->pMemCtxStruc);
   // No initial cleanup needed
   //------------------------------------------
   // 1.1. Check if SSL-Data to 'send'
   //------------------------------------------
   if((adsp_ssl_conn->pPriorityTxQueueHead != NULL) ||
      (adsp_ssl_conn->TX_State != TCP_TX_INACTIVE))
   {
      //---------------------------------------------------------
      // Check if SSL-Send is possible at all (socket not closed)
      //---------------------------------------------------------
      if(adsp_xh_conn->boc_eof_client)	// client side closed!
      {
         FreeSSLGatherBufsAndFreeList(HMEM_CTX_REF1 adsp_ssl_conn);
         FreeAPPGatherBufsAndFreeList(HMEM_CTX_REF1 adsp_ssl_conn);
         adsp_xh_conn->inc_return = DEF_IRET_END;
         FreeXH3ConnStateStruct(HMEM_CTX_REF1 adsp_xh_conn); // free all used...
         return;
      }
      //----------------------------------------
      // Send as much SSL data as possible
      //----------------------------------------
      for(;;)
      {
         Retcode = HSSL_XH3ATcp_Transmit(adsp_ssl_conn,pTmpContStat,
            &adsp_xh_conn->achc_tocl_cur,
            adsp_xh_conn->achc_tocl_end);
         if(Retcode != HSSL_OP_OK)
         {
            CleanupCaches(HMEM_CTX_REF1 pXhConnStruc->pConnStruc,Retcode);
            adsp_xh_conn->inc_return = Retcode;
            FreeXH3ConnStateStruct(HMEM_CTX_REF1 adsp_xh_conn); // free all used...
            return;
         }
         if((adsp_xh_conn->achc_tocl_cur ==	 	// buffer is full...
            adsp_xh_conn->achc_tocl_end) ||
            (adsp_ssl_conn->pPriorityTxQueueHead == NULL))  // no pri. data
            break;
      }
      //-------------------------------------------------
      // Check if all data to send have been sent now
      //-------------------------------------------------
      if((adsp_ssl_conn->pPriorityTxQueueHead != NULL) ||
         (adsp_ssl_conn->TX_State != TCP_TX_INACTIVE))
         return;				// wait for buffers...
      //-------------------------------------------------------
      // All data to be sent have been sent, free pending recv
      // but only if buffer pointers are NOT NULL !!! (strange)
      //-------------------------------------------------------
      CheckFreeSSLRxPktList(adsp_ssl_conn);
   }
   //---------------------------------------------------
   // 2.1. Check if the server side socket is still open
   //---------------------------------------------------
   if(adsp_xh_conn->boc_eof_server)	// no socket for send data
   {
      m_generate_log_msg(((XHCONNSTRUC *) adsp_xh_conn->ac_ext)->pConnStruc,
         "m_hlse03 detected server eof", 0,HL_AUX_WT_DATA1,"SSLEOF");
      CleanupCaches(HMEM_CTX_REF1 adsp_ssl_conn,adsp_xh_conn->inc_return);
      XH3ASSL_Disconnect(adsp_xh_conn);
      return;
   }
   //------------------------------------------------
   // 2.2. Check if the client side socket was closed
   //------------------------------------------------
   if(adsp_xh_conn->boc_eof_client)	// client side closed!
   {
      m_generate_log_msg(((XHCONNSTRUC *) adsp_xh_conn->ac_ext)->pConnStruc,
         "m_hlse03 detected client eof", 0,HL_AUX_WT_DATA1,"SSLEOF");
      CleanupCaches(HMEM_CTX_REF1 adsp_ssl_conn,adsp_xh_conn->inc_return);
      XH3ASSL_Disconnect(adsp_xh_conn);
      return;
   }
   //--------------------------------------------
   // 3. Check if Handshake phase is still active
   //--------------------------------------------
   for(;;)
   {
      if((pXhConnStruc->XHConnState == XH_STATE_CONNECT_START) ||
         (pXhConnStruc->XHConnState == XH_STATE_CONNECT_SEND) ||
         (pXhConnStruc->XHConnState == XH_STATE_CONNECT_WAIT) ||
         (pXhConnStruc->XHConnState == XH_STATE_CONNECT_ALERT) ||
         (pXhConnStruc->XHConnState == XH_STATE_CONNECT_CLOSING))
      {
         Retcode = XH3ADoHandshake(adsp_xh_conn);
         adsp_xh_conn->inc_return = Retcode;
         if(Retcode != HSSL_OP_OK)
         {
            m_generate_log_msg(((XHCONNSTRUC *) adsp_xh_conn->ac_ext)->pConnStruc,
               "XH3ADoHandshake in m_hlse03 failed with error code %i", Retcode,HL_AUX_WT_DATA1,"SSLERR");
            CleanupCaches(HMEM_CTX_REF1 pXhConnStruc->pConnStruc,Retcode);
            FreeXH3ConnStateStruct(HMEM_CTX_REF1 adsp_xh_conn); // free all used...
            return;
         }

         if(pXhConnStruc->XHConnState == XH_STATE_NORMAL)  // now connected
         {
            m_generate_log_msg(((XHCONNSTRUC *) adsp_xh_conn->ac_ext)->pConnStruc,
               "m_hlse03 finished SSL handshake.", 0,HL_AUX_WT_DATA1,"SSLHSF");
            if(adsp_xh_conn->amc_conn_callback != NULL) // do a callback...
               GetReturnConnectionData3(adsp_xh_conn);

            break;
         }
         //-----------------------------------------
         // Check if all SSL data were sent so far
         //-----------------------------------------
         if((adsp_ssl_conn->pPriorityTxQueueHead != NULL) ||
            (adsp_ssl_conn->TX_State != TCP_TX_INACTIVE)){
               if(pXhConnStruc->XHConnState == XH_STATE_CONNECT_ALERT)
                  m_hlse03(adsp_xh_conn);  // Workaround: This call writes the queued Alert Message to the send buffer.
               return;
         }

         CheckFreeSSLRxPktList(adsp_ssl_conn);

         //--------------------------------------------------
         // Check if more receive data present for processing
         //--------------------------------------------------
         if(adsp_ssl_conn->pSSLActRxPkt == NULL)
            Retcode = PrepSslPktList(adsp_ssl_conn,
            adsp_xh_conn->adsc_gai1_fromcl);
         if(adsp_ssl_conn->pSSLActRxPkt == NULL)
            return;
      }
      else			// Session is established
      {
         break;
      }
   } // Handshake FOR
   //------------------------------------------------------------
   // 4. Check if Socket RX-Data are present
   //------------------------------------------------------------
   if(adsp_ssl_conn->pSSLActRxPkt == NULL)
      PrepSslPktList(adsp_ssl_conn,adsp_xh_conn->adsc_gai1_fromcl);

   if(adsp_ssl_conn->pSSLActRxPkt != NULL)
   {
      Retcode = SSLPktReceive(HMEM_CTX_REF1 adsp_ssl_conn, pTmpContStat,0);
      if(Retcode == HSSL_RX_APPLDATA_NULL_MSG){  // Received empty App data, retry
         Retcode = SSLPktReceive(HMEM_CTX_REF1 adsp_ssl_conn, pTmpContStat,0);
      }

      if(Retcode < 0)
      {
         CleanupCaches(HMEM_CTX_REF1 pXhConnStruc->pConnStruc,Retcode);

         FreeXH3ConnStateStruct(HMEM_CTX_REF1 adsp_xh_conn); // free all used...
         if(HSSL_ALERT_MSG_FATAL_CLOSE_NOTIFY == Retcode){
             adsp_xh_conn->inc_return = DEF_IRET_END;
         } else {
             adsp_xh_conn->inc_return = Retcode;
         }
         return;
      }
   }
   //------------------------------------------------------------
   // 5. Process Application TX-Data, if present
   //------------------------------------------------------------
   Retcode = XH3ASSL_Send(adsp_xh_conn);	// queue send data
   if(Retcode != HSSL_OP_OK)
   {
      CleanupCaches(HMEM_CTX_REF1 pXhConnStruc->pConnStruc,Retcode);

      adsp_xh_conn->inc_return = Retcode;
      FreeXH3ConnStateStruct(HMEM_CTX_REF1 adsp_xh_conn); // free all used...
      return;
   }

   //------------------------------------------------------------
   // 6. Process Socket TX (Postprocessing also done)
   // --- assure sending ALL data till buffer filled/no more Data ---
   //------------------------------------------------------------
   if((adsp_ssl_conn->TX_State != TCP_TX_INACTIVE)||// remaining TX data
      (adsp_ssl_conn->pPriorityTxQueueHead != NULL))	// priority data
   {
      for(;;)
      {
         Retcode = HSSL_XH3ATcp_Transmit(adsp_ssl_conn,pTmpContStat,
            &adsp_xh_conn->achc_tocl_cur,
            adsp_xh_conn->achc_tocl_end);
         if(Retcode != HSSL_OP_OK)
         {
            CleanupCaches(HMEM_CTX_REF1 pXhConnStruc->pConnStruc,Retcode);

            adsp_xh_conn->inc_return = Retcode;
            FreeXH3ConnStateStruct(HMEM_CTX_REF1 adsp_xh_conn); // free all used...
            return;
         }
         if((adsp_xh_conn->achc_tocl_cur == 		// buffer is full...
            adsp_xh_conn->achc_tocl_end) ||
            (adsp_ssl_conn->pPriorityTxQueueHead == NULL))  // no pri. data
            break;
      } // for
   }
   //------------------------------------------------------------
   // 7. Process Application RX
   //------------------------------------------------------------
   XH3SSL_Recv(adsp_xh_conn);
   adsp_xh_conn->inc_return = HSSL_OP_OK;

   //-----------------------------------------------
   // 8. Check if all data to be sent HAVE been sent
   //-----------------------------------------------
   CheckFreeSSLRxPktList(adsp_ssl_conn);

   return;
}//static void m_process_se_cont(struct dsd_hl_ssl_s_3 * adsp_xh_conn, CONN_PTR adsp_ssl_conn);

static void m_hlse03_impl(struct dsd_hl_ssl_s_3 * pXIF3Struct)
{
  int Retcode;
 
  XHCONNSTRUC * pXhConnStruc;
  CONNSTRU * pConnStruc;
  CFG_STRU * pCfgStruc;

  ds__hmem TmpMemCtxStruc;
  
  struct dsd_hl_ssl_s_3 * XIF3Struct = pXIF3Struct;

  BOOL bol_flow_control;

  HMEM_CTX_DEF1;

  //-----------------------------------------
  // Check parameters
  //-----------------------------------------
  if(XIF3Struct == NULL)
  {
    return;
  }

  bol_flow_control = ((0 == m_calc_gather_len(XIF3Struct->adsc_gai1_fromse)) && // No app data and no output buffer -> Flow control active
     (XIF3Struct->achc_tocl_cur == XIF3Struct->achc_tocl_end));

  LOAD_HMEM_CTX_PTR(NULL);

  //+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  // Distribute by caller requested function code
  //+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  switch(XIF3Struct->inc_func)
  {
    //=======================================================
    // A) Connection Startup, check if valid...
    //=======================================================
    case DEF_IFUNC_START:
      if(XIF3Struct->ac_ext != NULL)	// already have a connection!
      {
        XIF3Struct->inc_return = HSSL_NEWCONN_STATE_ERR; // already connecting...
        return;
      }
      pCfgStruc = (CFG_STRU *) (XIF3Struct->ac_config_id);

      if(pCfgStruc == NULL)
      {
        XIF3Struct->inc_return = HSSL_NEWCONN_STATE_ERR; // already connecting...
        return;
      }

      TmpMemCtxStruc = m_make_mem_struct(XIF3Struct->amc_aux,
                                         XIF3Struct->vpc_userfld, 
                                         0);

      LOAD_HMEM_CTX_PTR(&TmpMemCtxStruc);	// get correct context !!

      XIF3Struct->inc_func = DEF_IFUNC_CONT;  // Force Continue next...

#if defined ALT_SEEDING_SOURCE && defined XH_INTERFACE && !defined XH_DUMMY
      //--------------------------------------------------------------
      // Initialize Pseudo Random Generator with true random data now
      //--------------------------------------------------------------
      Retcode = SecDrbgInit(HMEM_CTX_REF);
      if (Retcode <= 0)
      {
        PrintAux(HMEM_CTX_REF1 "SECDRBG: ERROR - Random Generator not seeded,");
        if (Retcode < 0)
           PrintAux(HMEM_CTX_REF1 " data fetch failed, Retcode: %d\n",Retcode);
        else
           PrintAux(HMEM_CTX_REF1 " no data available!\n");
        XIF3Struct->inc_return = HSSL_RNG_FETCH_ERROR;  // random generator not initialized
        return;
      }
      else
         PrintAux(HMEM_CTX_REF1 "SECDRBG: Seed o.k.\n");
#endif  // defined ALT_SEEDING_SOURCE && defined XH_INTERFACE && !defined XH_DUMMY

      //-------------------------------------------
      // Seed the PRNG with entropy
      //-------------------------------------------
      CTR_DRBG_AddSeed256((char *) &XIF3Struct->ilc_entropy,sizeof(long long));

      //--------------------------------------------------------------
      // Get a connection structure to use, set up handshake data
      // to send, signal send data available, save state, send data
      //--------------------------------------------------------------
      Retcode = XH3SSL_Accept(HMEM_CTX_REF1 XIF3Struct,pCfgStruc);
      XIF3Struct->inc_return = Retcode;
      if(Retcode != HSSL_OP_OK)  
      {
         if(XIF3Struct->ac_ext != NULL && 
            ((XHCONNSTRUC *) XIF3Struct->ac_ext)->pConnStruc != NULL){
        CleanupCaches(HMEM_CTX_REF1
		      ((XHCONNSTRUC *) XIF3Struct->ac_ext)->pConnStruc,
		      Retcode);
         }

      }
      // If no data are there, return, else, fall through to DEF_IFUNC_CONT
      if(NULL == XIF3Struct->adsc_gai1_fromcl){
         return;
      }
    //=======================================================
    // B) Continuation, check what to do now....
    //=======================================================
    case DEF_IFUNC_CONT:
       //----------------------------------------------
       // Check if we have a connection state structure
       //----------------------------------------------
       pXhConnStruc = (XHCONNSTRUC *) XIF3Struct->ac_ext; // get connection structure
       if(pXhConnStruc == NULL)			// not allocated
       {
          XIF3Struct->inc_return = HSSL_XH_NOT_INITIALIZED_ERR; // report error
          return;
       }

       pConnStruc = pXhConnStruc->pConnStruc;	// get connection structure
       m_reload_field(pConnStruc->adsc_logger, XIF3Struct->amc_aux, XIF3Struct->vpc_userfld);

       pConnStruc->pMemCtxStruc->vp__context = XIF3Struct->vpc_userfld;

       m_generate_log_msg(pConnStruc, "Starting SSL continuation",0,HL_AUX_WT_DATA2,"SSLCNT");
       m_log_gathers(pConnStruc, XIF3Struct->adsc_gai1_fromcl, XIF3Struct->adsc_gai1_fromse);
       LOAD_HMEM_CTX_PTR(pConnStruc->pMemCtxStruc);

       // Update RX lists. Update list from client only, if no flow control is active
       if((!m_update_rx_list(pXhConnStruc->pConnStruc->pSSLActRxPkt, XIF3Struct->adsc_gai1_fromcl)) ||
          ((!bol_flow_control) && !m_update_rx_list(pXhConnStruc->pConnStruc->pAPPActRxPkt, XIF3Struct->adsc_gai1_fromse)))
       {
          // Less gather data, than expected, close session with error
          FreeSSLGatherBufsAndFreeList(HMEM_CTX_REF1 pConnStruc);
          FreeAPPGatherBufsAndFreeList(HMEM_CTX_REF1 pConnStruc);
          XIF3Struct->inc_return = HSSL_XH_MISSING_GATHER_INPUT;
          FreeXH3ConnStateStruct(HMEM_CTX_REF1 XIF3Struct);
          return;
       }

       // Call processing function
       m_process_se_cont(XIF3Struct, pXhConnStruc->pConnStruc);
       if( NULL != XIF3Struct->ac_ext ){
          // Session still up, release to free buffers
          FreeSSLGatherBufsAndFreeList(HMEM_CTX_REF1 pXhConnStruc->pConnStruc);
          FreeAPPGatherBufsAndFreeList(HMEM_CTX_REF1 pXhConnStruc->pConnStruc);
       }
       return;
    //=======================================================
    // Unknown Command detected, signal error
    //=======================================================
    default:				// invalid operation requested
      XIF3Struct->inc_return = DEF_IRET_ERRAU;// set unspecific global error code
      return;
  } // function switch
}

static char* ms_get_cur(dsd_gather_i_1* adsp_gather){
    if(adsp_gather == NULL){
        return NULL;
    }
    return adsp_gather->achc_ginp_cur;
}

/**
Sets up a delayed return code, if the last call did process data.
*/
static void ms_fix_se_retcode(dsd_hl_ssl_s_3 * adsp_cur_session,
                              dsd_hl_ssl_s_3 * adsp_old_session,
                              char* achp_old_from_se,
                              char* achp_old_from_cl)
{
    if((adsp_cur_session->achc_tocl_cur != adsp_old_session->achc_tocl_cur) ||
       (adsp_cur_session->achc_tose_cur != adsp_old_session->achc_tose_cur) ||
       (ms_get_cur(adsp_cur_session->adsc_gai1_fromse) != achp_old_from_se) ||
       (ms_get_cur(adsp_cur_session->adsc_gai1_fromcl) != achp_old_from_cl))
    {
        adsp_cur_session->inc_delay_return = adsp_cur_session->inc_return;
        adsp_cur_session->inc_return = DEF_IRET_NORMAL;
    }
}

extern "C" void m_hlse03(struct dsd_hl_ssl_s_3 * pXIF3Struct)
{
    if(pXIF3Struct->inc_delay_return != DEF_IRET_NORMAL){
        // Previous call was actually no normal return, use delayed return code
        pXIF3Struct->inc_return = pXIF3Struct->inc_delay_return;
        return;
    }
    dsd_hl_ssl_s_3 dsl_old_struct = *pXIF3Struct;
    char* achl_old_fromse_cur = ms_get_cur(pXIF3Struct->adsc_gai1_fromse);
    char* achl_old_fromcl_cur = ms_get_cur(pXIF3Struct->adsc_gai1_fromcl);
    // For some reason, it sometimes takes up to 3 calls for correct processing
    m_hlse03_impl(pXIF3Struct);
    if(pXIF3Struct->inc_return != DEF_IRET_NORMAL){
        ms_fix_se_retcode(pXIF3Struct, &dsl_old_struct, achl_old_fromse_cur, achl_old_fromcl_cur);
        return;
    }

    m_hlse03_impl(pXIF3Struct);
    if(pXIF3Struct->inc_return != DEF_IRET_NORMAL){
        ms_fix_se_retcode(pXIF3Struct, &dsl_old_struct, achl_old_fromse_cur, achl_old_fromcl_cur);
        return;
    }

    m_hlse03_impl(pXIF3Struct);
    if(pXIF3Struct->inc_return != DEF_IRET_NORMAL){
        ms_fix_se_retcode(pXIF3Struct, &dsl_old_struct, achl_old_fromse_cur, achl_old_fromcl_cur);
    }
}

//***********************************************************
//
// Client side new interface
//
//***********************************************************

#if XH_INTF_VERSION >= 300

/**
* Prepares Application data send and
* sends the application data if connection is established (XHCLASSL_Send).
*
*  The SSL interface must already have a connection structure.
*
*  @param pXifClStruc Interface Structure
*  @return 0 on success, else error occured
*/
static  int XHCLASSL_Send(struct dsd_hl_ssl_c_1 * pXifClStruc)
{
  int Retcode;
  int ContStat;

  RX_PKT_PTR pPkt = NULL;
  CONNSTRU * pConnStruc;
  HMEM_CTX_DEF1;

  //------------------------------------------------------
  // Setup Parameters
  //------------------------------------------------------
  pConnStruc = ((XHCONNSTRUC *) pXifClStruc->vpc_ext)->pConnStruc;

  LOAD_HMEM_CTX_PTR(CONN_pMemCtx(pConnStruc));

  if(pConnStruc->ConnectionState != CONN_STATE_CONNECTED)
    return(HSSL_OP_OK);
  //-----------------------------------------------------
  // Check if data from application layer present, but only
  // if there is no active packet element
  //-----------------------------------------------------
  if((pConnStruc->pAPPActRxPkt == NULL) &&
     (pConnStruc->pAPPRxPktToFreeAnchor == NULL))
  {
      pPkt = m_gen_app_rx_list(HMEM_CTX_REF1 
                               pConnStruc, 
                               pXifClStruc->adsc_gai1_in_cl);
    if(pPkt == NULL)
      return(HSSL_OP_OK);

    pConnStruc->pAPPRxPktInUseAnchor = pPkt->pNext;
    pConnStruc->pAPPActRxPkt         = pPkt;
  }
  //--------------------------------
  // Process application data (send)
  //--------------------------------
  pPkt = pConnStruc->pAPPActRxPkt;
  for(;;)
  {
    if(pPkt == NULL)
      return(HSSL_OP_OK);

    Retcode = AppPktTransmit(pConnStruc,&ContStat,
			     &pXifClStruc->achc_out_se_cur,
			     pXifClStruc->achc_out_se_end);
    if(Retcode > 0)		  // no more buffer space
      return(HSSL_OP_OK);
    if(Retcode != HSSL_OP_OK)
      return(Retcode);

    pPkt = pConnStruc->pAPPActRxPkt;
  }
}

/**
* Performs handshake phase for connection
* setup (XHCLADoHandshake).
*  The start message is already queued to the priority
* send queue and must be sent first.
* 
*  @param pXifClStruc Interface Structure
*
*  @return HSSL_OP_OK on success, error code otherwise
*/
static int XHCLADoHandshake(struct dsd_hl_ssl_c_1 * pXifClStruc)
{
  int Retcode;

  int pTmpContStat[1];

  CONNSTRU * pConnStruc;
  XHCONNSTRUC * pXHConnStruc;

  HMEM_CTX_DEF1;

  //-----------------------------------------
  // Get Structure pointers
  //-----------------------------------------
  pXHConnStruc = (XHCONNSTRUC *) pXifClStruc->vpc_ext;	// get control structure
  pConnStruc   = pXHConnStruc->pConnStruc;

  LOAD_HMEM_CTX_PTR(CONN_pMemCtx(pConnStruc));

  //-----------------------------------------
  // Send / Get data to send, try to send
  //-----------------------------------------
  Retcode = HSSL_XH3ATcp_Transmit(pConnStruc,pTmpContStat,
				  &pXifClStruc->achc_out_se_cur,
				  pXifClStruc->achc_out_se_end);
  if(Retcode != HSSL_OP_OK)
  {
    //------------------------------------------
    // invalidate resumability for session cache
    //------------------------------------------
    // !!!! implement that later !!!!

// Do NOT Free here !!!
//    FreeXHCLConnStateStruct(HMEM_CTX_REF,pXifClStruc); // free all used...
    return(Retcode);				// set error reason
  }
  //--------------------------------------------
  // Distribute by mode
  //--------------------------------------------
  switch(pXHConnStruc->XHConnState)		// distribute...
  {
    case XH_STATE_CONNECT_START:		// connect data queued check
      pXHConnStruc->XHConnState = XH_STATE_CONNECT_SEND; // set next state
      if(pConnStruc->pTxFragmentBuffer != NULL)	// not all data sent yet
        return(Retcode);
      pXHConnStruc->XHConnState = XH_STATE_CONNECT_WAIT;// all sent, do receive
      break;
    //---------------------------------------------------
    // First Send part still in Transmit
    //---------------------------------------------------
    case XH_STATE_CONNECT_SEND:			// sending active
      if(pConnStruc->pTxFragmentBuffer != NULL)	// not all data sent yet
        return(Retcode);
      pXHConnStruc->XHConnState = XH_STATE_CONNECT_WAIT;// all sent, do receive
      break;
    //---------------------------------------------------
    // Connect is in exchange state
    //---------------------------------------------------
    case XH_STATE_CONNECT_WAIT:			// dummy
      break;
    //---------------------------------------------------
    // Connect is in alert send state
    //---------------------------------------------------
    case XH_STATE_CONNECT_ALERT:		// must send alert
      if(pConnStruc->pTxFragmentBuffer != NULL)	// not all data sent yet
        return(Retcode);

      pXHConnStruc->XHConnState = XH_STATE_CONNECT_CLOSING;	// all data buffered for send..
      return(Retcode);
    //---------------------------------------------------
    // Connect is in closing state
    //---------------------------------------------------
    case XH_STATE_CONNECT_CLOSING:		// all sent...
      pXHConnStruc->XHConnState = XH_STATE_CLOSED;
      Retcode = pXHConnStruc->DeferredRetcode;

// Do NOT free here !!!
//      FreeXHCLConnStateStruct(HMEM_CTX_REF,pXifClStruc);	// free all used...
      return(Retcode);

    //------------------------------------------------
    // is in invalid state...
    //------------------------------------------------
    default:
// do NOT free here
//      FreeXHCLConnStateStruct(HMEM_CTX_REF,pXifClStruc); // free all used...
      return(HSSL_NEWCONN_STATE_ERR);
  } // switch
  //------------------------------------------------
  // Receive data if data present
  //------------------------------------------------
  if((pConnStruc->pSSLRxPktInUseAnchor != NULL) ||
     (pConnStruc->pSSLActRxPkt != NULL))
  {
    Retcode = SSLPktReceive(HMEM_CTX_REF1 pConnStruc, pTmpContStat,0);
    if(Retcode > 0)				// data incomplete
      return(HSSL_OP_OK);

    if((Retcode != HSSL_OP_OK) ||
       (pTmpContStat[0] == STATUS_FATAL_ALERT_QUEUED))
    {
      //------------------------------------------
      // invalidate resumability for session cache
      //------------------------------------------
      // !!!! implement that later !!!!

      if((pTmpContStat[0] == STATUS_FATAL_ALERT_QUEUED) &&
         (Retcode != HSSL_OP_OK))
      {
        pXHConnStruc->XHConnState = XH_STATE_CONNECT_CLOSING; // ??? CHECK THAT !!
        pXHConnStruc->DeferredRetcode = Retcode;

        Retcode = HSSL_XH3ATcp_Transmit(pConnStruc,pTmpContStat,
				  &pXifClStruc->achc_out_se_cur,
				  pXifClStruc->achc_out_se_end);
	if(Retcode != HSSL_OP_OK)
	  return(Retcode);

        return(HSSL_OP_OK);
      }

      if(Retcode != HSSL_OP_OK)
      {
// Do NOT free here !!!
//        FreeXHCLConnStateStruct(HMEM_CTX_REF,pXifClStruc); // free all used...
//        return(HSSL_HSHAKE_LCL_FATAL_ALERT);
        return(Retcode);
      }
      return(Retcode);
    }
  }

  Retcode = HSSL_XH3ATcp_Transmit(pConnStruc,pTmpContStat,
				  &pXifClStruc->achc_out_se_cur,
				  pXifClStruc->achc_out_se_end);
  if(Retcode != HSSL_OP_OK)
  {
    //------------------------------------------
    // invalidate resumability for session cache
    //------------------------------------------
    // !!!! implement that later !!!!
//    FreeXHCLConnStateStruct(HMEM_CTX_REF,pXifClStruc);	// free all used...
    return(Retcode);
  }
  if(pConnStruc->ConnectionState == CONN_STATE_CONNECTED)
  {
    if(pConnStruc->pPriorityTxQueueHead == NULL) // all Handshake data sent
      pXHConnStruc->XHConnState = XH_STATE_NORMAL;   // so switch to normal...
    return(Retcode);
  }
  return(Retcode);
}

//*********************************************************
//
// The HOBLink/HOBCom Client Interface as defined by
// Mr. Klaus Brandstaetter, V1/3
//
//*********************************************************

/**
Process the continuation in m_hlcl01.

Process is as described in m_hlcl01:

<ol>
  <li> Process messages from priority send queue, if available.
  <li> Check, if either side has closed the connection.
  <li> Continue processing handshake, if required.
  <li> Process received data.
  <li> Process data to be sent.
  <li> Copy data to be sent to the respective buffer.
  <li> Copy received data to the respective buffer.
  <li> Cleanup the receive queue, if it is empty.
</ol>

It is assumed, that both parameters are valid and non-NULL.
The adsp_ssl_conn structure may be invalidated by this function. If so, the member 
vpc_ext of adsp_xh_conn will be set to NULL.

@param[in]  adsp_xh_cl_conn   Pointer to the parameter structure used by m_hlcl01.
@param[in]  pConnStruc        Pointer to the structure of the current ssl connection.
*/
static void m_process_cl_cont(struct dsd_hl_ssl_c_1 * adsp_xh_cl_conn, 
                              CONNSTRU * pConnStruc)
{
   XHCONNSTRUC * pXhConnStruc = (XHCONNSTRUC *) adsp_xh_cl_conn->vpc_ext; // get connection structure

   int pTmpContStat[1];
   int Retcode = 0;
   HMEM_CTX_DEF1;
   LOAD_HMEM_CTX_PTR(pConnStruc->pMemCtxStruc);
   //----------------------------------------------------
   // 1. Cleanup pending receive list if any
   //----------------------------------------------------
   CheckFreeSSLRxPktList(pConnStruc);

   //----------------------------------------------------
   // 1.1. Check if SSL-Data to 'send'
   //----------------------------------------------------
   if(((pConnStruc->pPriorityTxQueueHead != NULL) ||
      (pConnStruc->TX_State != TCP_TX_INACTIVE)))
   {
      //-----------------------------------------
      // Send as much SSL data as possible
      //-----------------------------------------
      for(;;)
      {
         Retcode = HSSL_XH3ATcp_Transmit(pConnStruc,pTmpContStat,
            &adsp_xh_cl_conn->achc_out_se_cur,
            adsp_xh_cl_conn->achc_out_se_end);
         if(Retcode != HSSL_OP_OK)
         {
            CleanupCaches(HMEM_CTX_REF1 pConnStruc,Retcode);
            adsp_xh_cl_conn->inc_return = Retcode;

            FreeXHCLConnStateStruct(HMEM_CTX_REF1 adsp_xh_cl_conn);// free all used...
            return;
         }
         if((adsp_xh_cl_conn->achc_out_se_cur == 	// buffer is full...
            adsp_xh_cl_conn->achc_out_se_end) ||
            (pConnStruc->pPriorityTxQueueHead == NULL))  // no pri. data
            break;
      } // for
      //-------------------------------------------------
      // Check if all data to send have been sent now
      //-------------------------------------------------
      if((pConnStruc->pPriorityTxQueueHead != NULL) ||
         (pConnStruc->TX_State != TCP_TX_INACTIVE))
         return;
      //-------------------------------------------------------
      // All data to be sent have been sent, free pending recv
      // but only if buffer pointers are NOT NULL !!! (strange)
      //-------------------------------------------------------
      CheckFreeSSLRxPktList(pConnStruc);
   }
   //---------------------------------------------------------
   // 2.1. Check if the client side socket (SSL) is still open
   //---------------------------------------------------------
   if(adsp_xh_cl_conn->boc_eof_server != 0) // no socket for send data
   {
      m_generate_log_msg(pConnStruc, "m_hlcl01 detected server eof", 0,HL_AUX_WT_DATA1,"SSLEOF");
      CleanupCaches(HMEM_CTX_REF1 pConnStruc,adsp_xh_cl_conn->inc_return);

      XHCLSSL_Disconnect(adsp_xh_cl_conn);
      FreeXHCLConnStateStruct(HMEM_CTX_REF1 adsp_xh_cl_conn);// free all used...
      return;
   }
   //----------------------------------------------------------
   // 2.2. Check if the server side socket (Non-SSL) was closed
   //----------------------------------------------------------
   if(adsp_xh_cl_conn->boc_eof_client != 0)	// server side (WSP) closed!
   {
      m_generate_log_msg(pConnStruc, "m_hlcl01 detected client eof", 0,HL_AUX_WT_DATA1,"SSLEOF");
      CleanupCaches(HMEM_CTX_REF1 pConnStruc,adsp_xh_cl_conn->inc_return);

      XHCLSSL_Disconnect(adsp_xh_cl_conn);
      //        FreeXHCLConnStateStruct(HMEM_CTX_REF1 adsp_xh_cl_conn);// free all used...
      return;
   }
   //----------------------------------------------
   // 3. Check if Handshake phase is still active
   //----------------------------------------------
   for(;;)
   {
      if((pXhConnStruc->XHConnState == XH_STATE_CONNECT_START) ||
         (pXhConnStruc->XHConnState == XH_STATE_CONNECT_SEND) ||
         (pXhConnStruc->XHConnState == XH_STATE_CONNECT_WAIT) ||
         (pXhConnStruc->XHConnState == XH_STATE_CONNECT_ALERT) ||
         (pXhConnStruc->XHConnState == XH_STATE_CONNECT_CLOSING))
      {
         Retcode = XHCLADoHandshake(adsp_xh_cl_conn);
         adsp_xh_cl_conn->inc_return = Retcode;
         if((Retcode != HSSL_OP_OK) ||
            (pXhConnStruc->XHConnState == XH_STATE_CLOSED))
         {
            if(Retcode != HSSL_OP_OK){
               m_generate_log_msg(pConnStruc, "XHCLADoHandshake in m_hlcl01 failed with error code %i",
                  Retcode,HL_AUX_WT_DATA1,"SSLERR");
            }
            CleanupCaches(HMEM_CTX_REF1 pXhConnStruc->pConnStruc,Retcode);
            FreeXHCLConnStateStruct(HMEM_CTX_REF1 adsp_xh_cl_conn); // free all used...
            return;
         }

         if(pXhConnStruc->XHConnState == XH_STATE_NORMAL)  // now connected
         {
            m_generate_log_msg(pConnStruc, "m_hlcl01 finished SSL handshake.", 0,HL_AUX_WT_DATA1,"SSLHSF");
            if(adsp_xh_cl_conn->amc_conn_callback != NULL) // do a callback...
               GetReturnConnectionDataCL(adsp_xh_cl_conn);
            break;
         }
         //---------------------------------------
         // Check if all SSL data were sent so far
         //---------------------------------------
         if((pConnStruc->pPriorityTxQueueHead != NULL) ||
            (pConnStruc->TX_State != TCP_TX_INACTIVE)){
               if(pXhConnStruc->XHConnState == XH_STATE_CONNECT_ALERT){
                  /** @todo test this for side effects and with missing send buffer. */
                  m_hlcl01(adsp_xh_cl_conn);   // Workaround for problem of failing to send Alerts
               }
               return;
         }
         //--------------------------------------------------
         // Check if more receive data present for processing
         //--------------------------------------------------
         if(pConnStruc->pSSLActRxPkt == NULL)
            Retcode = PrepSslPktList(pConnStruc,adsp_xh_cl_conn->adsc_gai1_in_se);
         if(pConnStruc->pSSLActRxPkt == NULL)
            return;
      }
      else
      {
         break;
      }
   } // Handshake FOR
   //------------------------------------------------------------
   // 4. Check if Socket RX-Data are present
   //------------------------------------------------------------
   if(pConnStruc->pSSLActRxPkt == NULL)
      PrepSslPktList(pConnStruc,adsp_xh_cl_conn->adsc_gai1_in_se);

   if(pConnStruc->pSSLActRxPkt != NULL)
   {
      Retcode = SSLPktReceive(HMEM_CTX_REF1 pConnStruc, pTmpContStat,1);
      if(Retcode == HSSL_RX_APPLDATA_NULL_MSG){  // Received empty App data, retry
         Retcode = SSLPktReceive(HMEM_CTX_REF1 pConnStruc, pTmpContStat,0);
      }
      //        if(Retcode != HSSL_OP_OK)
      if(Retcode < 0)
      {
         CleanupCaches(HMEM_CTX_REF1 pXhConnStruc->pConnStruc,Retcode);

         FreeXHCLConnStateStruct(HMEM_CTX_REF1 adsp_xh_cl_conn); // free all used...
         if(HSSL_ALERT_MSG_FATAL_CLOSE_NOTIFY == Retcode){
             adsp_xh_cl_conn->inc_return = DEF_IRET_END;
         } else {
             adsp_xh_cl_conn->inc_return = Retcode;
         }
         return;
      }
   }
   //------------------------------------------------------------
   // 5. Process Application TX-Data, if present
   //------------------------------------------------------------
   Retcode = XHCLASSL_Send(adsp_xh_cl_conn);	// queue send data
   if(Retcode != HSSL_OP_OK)
   {
      CleanupCaches(HMEM_CTX_REF1 pXhConnStruc->pConnStruc,Retcode);

      FreeXHCLConnStateStruct(HMEM_CTX_REF1 adsp_xh_cl_conn); // free all used...
      adsp_xh_cl_conn->inc_return = Retcode;
      return;
   }
   //------------------------------------------------------------
   // 6. Process Socket TX (Postprocessing also done)
   // --- assure sending ALL data till buffer filled/no more Data ---
   //------------------------------------------------------------
   if((pConnStruc->TX_State != TCP_TX_INACTIVE)||// remaining TX data
      (pConnStruc->pPriorityTxQueueHead != NULL))	// priority data
   {
      for(;;)
      {
         Retcode = HSSL_XH3ATcp_Transmit(pConnStruc,pTmpContStat,
            &adsp_xh_cl_conn->achc_out_se_cur,
            adsp_xh_cl_conn->achc_out_se_end);
         if(Retcode != HSSL_OP_OK)
         {
            CleanupCaches(HMEM_CTX_REF1 pXhConnStruc->pConnStruc,Retcode);

            adsp_xh_cl_conn->inc_return = Retcode;
            FreeXHCLConnStateStruct(HMEM_CTX_REF1 adsp_xh_cl_conn); // free all used...
            return;
         }
         if((adsp_xh_cl_conn->achc_out_se_cur == 	// buffer is full...
            adsp_xh_cl_conn->achc_out_se_end) ||
            (pConnStruc->pPriorityTxQueueHead == NULL))  // no pri. data
            break;
      } // for
   }
   //------------------------------------------------------------
   // 7. Process Application RX
   //------------------------------------------------------------
   XHCLSSL_Recv(adsp_xh_cl_conn);
   adsp_xh_cl_conn->inc_return = HSSL_OP_OK;

   //------------------------------------------------------------
   // 8. Check if all data to be sent HAVE been sent
   //------------------------------------------------------------
   CheckFreeSSLRxPktList(pConnStruc);

   return;
}//static void m_process_cl_cont(struct dsd_hl_ssl_c_1 * adsp_xh_cl_conn, CONN_PTR pConnStruc );

//m_hlcl01
static void m_hlcl01_impl(struct dsd_hl_ssl_c_1 * pXIFCLStructu)
{
  int Retcode;

  XHCONNSTRUC * pXhConnStruc;
  CONNSTRU * pConnStruc;
  CFG_STRU * pCfgStruc;

  ds__hmem TmpMemCtxStruc;
  
  BOOL bol_flow_control;

  struct dsd_hl_ssl_c_1 * XIFCLStruct = pXIFCLStructu;

  HMEM_CTX_DEF1;

  //-----------------------------------------
  // Check parameters
  //-----------------------------------------
  if(XIFCLStruct == NULL)
  {
    return;
  }

  bol_flow_control = ((0 == m_calc_gather_len(XIFCLStruct->adsc_gai1_in_cl) )   // No app data and no output buffer -> Flow control active 
      && (XIFCLStruct->achc_out_se_cur == XIFCLStruct->achc_out_se_end));

  LOAD_HMEM_CTX_PTR(NULL);

  //+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  // Distribute by caller requested function code
  //+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  switch(XIFCLStruct->inc_func)
  {
    //=======================================================
    // A) Connection Startup, check if valid...
    //=======================================================
    case DEF_IFUNC_START:
      if(XIFCLStruct->vpc_ext != NULL)	// already have a connection!
      {
        XIFCLStruct->inc_return = HSSL_NEWCONN_STATE_ERR; // already connecting...
        return;
      }
      pCfgStruc = (CFG_STRU *) XIFCLStruct->vpc_config_id;

      if(pCfgStruc == NULL)
      {
        // Replace the errror code below !!!
        XIFCLStruct->inc_return = HSSL_NEWCONN_STATE_ERR; // already connecting...
        return;
      }

      TmpMemCtxStruc = m_make_mem_struct(XIFCLStruct->amc_aux, 
                                         XIFCLStruct->vpc_userfld, 
                                         0);

      LOAD_HMEM_CTX_PTR(&TmpMemCtxStruc);	// get correct context !!

      XIFCLStruct->inc_func = DEF_IFUNC_CONT;  // Force Continue next...
      //-------------------------------------------
      // Seed the PRNG with entropy
      //-------------------------------------------
      CTR_DRBG_AddSeed256((char *) &XIFCLStruct->ilc_entropy,sizeof(long long));

      //--------------------------------------------------------------
      // Get a connection structure to use, set up handshake data
      // to send, signal send data available, save state, send data
      //--------------------------------------------------------------
      Retcode = XHCLSSL_Connect(HMEM_CTX_REF1 XIFCLStruct,pCfgStruc);
      XIFCLStruct->inc_return = Retcode;
      if(Retcode != HSSL_OP_OK)  
      {
         if(XIFCLStruct->vpc_ext != NULL && 
            ((XHCONNSTRUC *) XIFCLStruct->vpc_ext)->pConnStruc != NULL){
        CleanupCaches(HMEM_CTX_REF1
		      ((XHCONNSTRUC *) XIFCLStruct->vpc_ext)->pConnStruc,
		      Retcode);
         }
        FreeXHCLConnStateStruct(HMEM_CTX_REF1 XIFCLStruct);// free all used...
      }
      else
      {
        XIFCLStruct->inc_func = DEF_IFUNC_CONT;	// Force Continue next...
      } 
      return;
    //=======================================================
    // B) Continuation, check what to do now....
    //=======================================================
    case DEF_IFUNC_CONT:
      //----------------------------------------------
      // Check if we have a connection state structure
      //----------------------------------------------
      pXhConnStruc = (XHCONNSTRUC *) XIFCLStruct->vpc_ext; // get connection structure
      if(pXhConnStruc == NULL)			// not allocated
      {
        XIFCLStruct->inc_return = HSSL_XH_NOT_INITIALIZED_ERR; // report error
        return;
      }

      pConnStruc = pXhConnStruc->pConnStruc;	// get connection structure
      m_reload_field(pConnStruc->adsc_logger, XIFCLStruct->amc_aux, XIFCLStruct->vpc_userfld);
      pConnStruc->pMemCtxStruc->vp__context = XIFCLStruct->vpc_userfld;

      m_generate_log_msg(pConnStruc, "Starting SSL continuation",0,HL_AUX_WT_DATA2,"SSLCNT");
      m_log_gathers(pConnStruc, XIFCLStruct->adsc_gai1_in_se, XIFCLStruct->adsc_gai1_in_cl);
      LOAD_HMEM_CTX_PTR(pConnStruc->pMemCtxStruc);

      // Update RX lists. Do list for server in only, if no flow control is active
      if(((!bol_flow_control) &&
         (!m_update_rx_list(pXhConnStruc->pConnStruc->pSSLActRxPkt, XIFCLStruct->adsc_gai1_in_se))) ||
         (!m_update_rx_list(pXhConnStruc->pConnStruc->pAPPActRxPkt, XIFCLStruct->adsc_gai1_in_cl)) )
      {
         // Less gather data, than expected, close session with error
         CleanupCaches(HMEM_CTX_REF1 pXhConnStruc->pConnStruc,
            HSSL_XH_MISSING_GATHER_INPUT);

         FreeXHCLConnStateStruct(HMEM_CTX_REF1 XIFCLStruct); // free all used...
         XIFCLStruct->inc_return = HSSL_XH_MISSING_GATHER_INPUT;
         return;
      }

      // Call processing function
      m_process_cl_cont(XIFCLStruct, pXhConnStruc->pConnStruc);
      if( NULL != XIFCLStruct->vpc_ext ){
         // Session still up, cleanup gather lists as possible
         FreeSSLGatherBufsAndFreeList(HMEM_CTX_REF1 pXhConnStruc->pConnStruc);
         FreeAPPGatherBufsAndFreeList(HMEM_CTX_REF1 pXhConnStruc->pConnStruc);
      }
      return;
    //=======================================================
    // C) Connection shall be ended, check what to do now....
    //=======================================================
    case DEF_IFUNC_CLOSE:
      //----------------------------------------------
      // Check if we have a connection state structure
      //----------------------------------------------
      pXhConnStruc = (XHCONNSTRUC *) XIFCLStruct->vpc_ext;	// get connection structure
      if(pXhConnStruc == NULL)			// not allocated
      {
        XIFCLStruct->inc_return = HSSL_XH_NOT_INITIALIZED_ERR; // report error
        return;
      }

      pConnStruc = pXhConnStruc->pConnStruc;	// get connection structure
      pConnStruc->pMemCtxStruc->vp__context = XIFCLStruct->vpc_userfld;
      LOAD_HMEM_CTX_PTR(pConnStruc->pMemCtxStruc);
      //-------------------------------------------------------
      // Check State...
      //-------------------------------------------------------
      if((pXhConnStruc->XHConnState != XH_STATE_NORMAL) &&
         (pXhConnStruc->XHConnState != XH_STATE_CLOSING) &&
         (pXhConnStruc->XHConnState != XH_STATE_CLOSED))
      {
        CleanupCaches(HMEM_CTX_REF1 pXhConnStruc->pConnStruc,
		      HSSL_XH_INVALID_STATE);

        FreeXHCLConnStateStruct(HMEM_CTX_REF1 XIFCLStruct); // free all used...
        XIFCLStruct->inc_return = HSSL_XH_INVALID_STATE;
        return;
      }
      //-------------------------------------------------------
      // Process remaining data....
      // Continue to SEND on TCP until socket closed
      //-------------------------------------------------------
      Retcode = XHCLSSL_Disconnect(XIFCLStruct);
      if(Retcode != HSSL_OP_OK)
      {
        if(XIFCLStruct->vpc_ext != NULL)
          CleanupCaches(HMEM_CTX_REF1 pXhConnStruc->pConnStruc,Retcode);

        FreeXHCLConnStateStruct(HMEM_CTX_REF1 XIFCLStruct); // free all used...
        XIFCLStruct->inc_return = Retcode;
        return;
      }
      //----------------------------------------------
      // Check if all the data processed now
      //----------------------------------------------
      if(XIFCLStruct->inc_return == DEF_IRET_END)
      {
        if(XIFCLStruct->vpc_ext != NULL)
          CleanupCaches(HMEM_CTX_REF1 pXhConnStruc->pConnStruc,0);

        FreeXHCLConnStateStruct(HMEM_CTX_REF1 XIFCLStruct); // free all used...
        return;
      }
      return;
    //=======================================================
    // Unknown Command detected, signal error
    //=======================================================
    default:				// invalid operation requested
      XIFCLStruct->inc_return = DEF_IRET_ERRAU;// set unspecific global error code
      return;
  } // function switch
}

/**
Sets up a delayed return code, if the last call did process data.
*/
static void ms_fix_cl_retcode(dsd_hl_ssl_c_1 * adsp_cur_session,
                              dsd_hl_ssl_c_1 * adsp_old_session,
                              char* achp_old_from_se,
                              char* achp_old_from_cl)
{
    if((adsp_cur_session->achc_out_cl_cur != adsp_old_session->achc_out_cl_cur) ||
       (adsp_cur_session->achc_out_se_cur != adsp_old_session->achc_out_se_cur) ||
       (ms_get_cur(adsp_cur_session->adsc_gai1_in_se) != achp_old_from_se) ||
       (ms_get_cur(adsp_cur_session->adsc_gai1_in_cl) != achp_old_from_cl))
    {
        adsp_cur_session->inc_delay_return = adsp_cur_session->inc_return;
        adsp_cur_session->inc_return = DEF_IRET_NORMAL;
    }
}

extern "C" void m_hlcl01(struct dsd_hl_ssl_c_1 * pXIFCLStructu)
{
    if(pXIFCLStructu->inc_delay_return != DEF_IRET_NORMAL){
        // Apply the delayed return
        pXIFCLStructu->inc_return = pXIFCLStructu->inc_delay_return;
        return;
    }
    dsd_hl_ssl_c_1 dsl_old_struct = *pXIFCLStructu;
    char* achl_old_fromse_cur = ms_get_cur(pXIFCLStructu->adsc_gai1_in_se);
    char* achl_old_fromcl_cur = ms_get_cur(pXIFCLStructu->adsc_gai1_in_cl);

    // For some reason, it sometimes takes up to 3 calls for correct processing
    m_hlcl01_impl(pXIFCLStructu);
    if( pXIFCLStructu->inc_return != DEF_IRET_NORMAL){
        ms_fix_cl_retcode(pXIFCLStructu, &dsl_old_struct, achl_old_fromse_cur, achl_old_fromcl_cur);
        return;
    }
    m_hlcl01_impl(pXIFCLStructu);
    if( pXIFCLStructu->inc_return != DEF_IRET_NORMAL){
        ms_fix_cl_retcode(pXIFCLStructu, &dsl_old_struct, achl_old_fromse_cur, achl_old_fromcl_cur);
        return;
    }
    m_hlcl01_impl(pXIFCLStructu);
    if( pXIFCLStructu->inc_return != DEF_IRET_NORMAL){
        ms_fix_cl_retcode(pXIFCLStructu, &dsl_old_struct, achl_old_fromse_cur, achl_old_fromcl_cur);
    }
}


#endif // XH_INTF_VERSION >= 300

#endif // !defined XH_INTERFACE
/**
Allocates a configuration structure and initializes it for use of SRP.

Memory context, entity and SRP functions must be set by the caller.

@param[out] aadsp_cfg   Pointer to take the pointer to the newly allocated 
                        cfg structure.

@return HSSL_OP_OK on success, error code otherwise.
*/
static  int  m_new_srp_cfg(HMEM_CTX_DEF CFG_STRU ** aadsp_cfg)
{
   int inl_ret;

   char* achl_version_buf = NULL;
   CFG_STRU * adsl_new_cfg = NULL;

   int ainl_tmp_cnt[1];
   int aiml_ver_info_len[1];
#if defined XH_INTERFACE
   if(VersionShow < 1)			// No output any longer....
      VersionShow = 1;
   if(VersionShow == 0)
   {
#endif
      // Show Version on console
      if((inl_ret = HSSL_GetVersionInfo(aiml_ver_info_len,NULL,ainl_tmp_cnt)) != HSSL_OP_OK)
         return(inl_ret);

      if((achl_version_buf = BIT8_ARRAY_ALLOC(HMEM_CTX_REF, ainl_tmp_cnt[0])) == NULL) {
         return(HSSL_ALLOC_ERR);
      }

      if((inl_ret = HSSL_GetVersionInfo(aiml_ver_info_len,achl_version_buf,ainl_tmp_cnt)) != HSSL_OP_OK)
      {
         FREE_CARRAY(HMEM_CTX_REF,achl_version_buf);
         return(inl_ret);		
      }
      printf("\n%s\n", achl_version_buf);

      FREE_CARRAY(HMEM_CTX_REF,achl_version_buf);

#if defined XH_INTERFACE
      VersionShow = 1;
   }
#endif
   // Initialize Pseudo Random Generator with true random data now
   inl_ret = SecDrbgInit(HMEM_CTX_REF);
   if(inl_ret <= 0)
   {
#if !defined XH_INTERFACE
      printf("SECDRBG: ERROR - Random Generator not seeded");
      if(inl_ret < 0)
         printf(", data fetch failed, Retcode: %d\n",inl_ret);
      else
         printf(", no data available!");
#else
      PrintAux(HMEM_CTX_REF1 "SECDRBG: ERROR - Random Generator not seeded,");
      if(inl_ret < 0)
         PrintAux(HMEM_CTX_REF1 " data fetch failed, Retcode: %d\n",inl_ret);
      else
         PrintAux(HMEM_CTX_REF1 " no data available!\n");
#endif
   }
   else
#if defined XH_INTERFACE
      if(VersionShow <= 1)
      {
#endif
#if !defined XH_INTERFACE
         printf("SECDRBG: Seed o.k.\n");
#else
         PrintAux(HMEM_CTX_REF1 "SECDRBG: Seed o.k.\n");
#endif

#if defined XH_INTERFACE
         VersionShow = 2;
      }
#endif

   adsl_new_cfg = (CFG_STRU *)
      ((void *) BIT8_ARRAY_ALLOC(HMEM_CTX_REF,sizeof(CFG_STRU)));

   if(adsl_new_cfg != NULL){
      memset(adsl_new_cfg,0,sizeof(CFG_STRU));
   } else {
      return(-6);
   }

   char* achl_cipher_buffer = BIT8_ARRAY_ALLOC(HMEM_CTX_REF, 4);
   if(achl_cipher_buffer == NULL){
       FREE_ARRAY(HMEM_CTX_REF,adsl_new_cfg);
       return HSSL_ALLOC_ERR;
   }
   
   // Fill the Structure with 'fixed' values
   // use CPU AES, no Compression, TLS 1.2 and SRP cipher only
   // As we do not allow DHE for SRP configs, no DHE group is needed, even if this is a server
   adsl_new_cfg->in_use_cpu_aes = 1;
   adsl_new_cfg->CmprMethodsList[0] = 1;
   adsl_new_cfg->ExtConfigFlags |= CFG_TLS_V2_BIT_MASK;
   adsl_new_cfg->CipherSuitesList = achl_cipher_buffer;
   adsl_new_cfg->CipherSuitesList[0] = 0;
   adsl_new_cfg->CipherSuitesList[1] = 2;
   adsl_new_cfg->CipherSuitesList[2] = (char)0xC0u;
   adsl_new_cfg->CipherSuitesList[3] = 0x1D;
   adsl_new_cfg->ExtConf2Flags |= SRVR_NO_HELLO_REQ_BIT_MASK;

   aadsp_cfg[0] = adsl_new_cfg;

   return (HSSL_OP_OK);
}//int  m_new_srp_cfg(HMEM_CTX_DEF CFG_STRUCT_PPTR aadsp_cfg);
#ifdef XH_INTERFACE

/**
Fills the strings from source array to destionation array, if they are not 
already contained in it.

This is done by first comparing the raw struct dsd_unicode_string data, then, 
if they do not match, call m_cmpi_vx_vx of the unicode library. This means, 
that the limitations of that comparison function also apply fully to this 
function.

If the destination array is full, no further strings are added.

@param adsp_ucs_src_arr     Source array to be added.
@param ump_src_len          Length of the source array.
@param adsp_ucs_dest_arr    Destination array to be filled.
@param ump_dest_cnt         Number of strings already in the dest array.
@param ump_dest_len         Total length of the destination array.

@return Number of strings in the dest array after filling it.
*/
static unsigned int m_compare_and_fill( struct dsd_unicode_string *adsp_ucs_src_arr, 
                                        unsigned int ump_src_len, 
                                        struct dsd_unicode_string* adsp_ucs_dest_arr, 
                                        unsigned int ump_dest_cnt, 
                                        unsigned int ump_dest_len)
{
   unsigned int uml_dest_loop_index = 0;
   int inl_comp_res = 1;
   // Loop over whole input
   while(ump_src_len != 0){
      ump_src_len--;
      // Loop over destination
      for(uml_dest_loop_index = 0, inl_comp_res = 1; 
         (uml_dest_loop_index < ump_dest_cnt) && (inl_comp_res != 0); 
         uml_dest_loop_index++)
      {
         // Memcompare will catch identical structs. Important, as unicode compare seems to miss IDNA.
         inl_comp_res = memcmp(adsp_ucs_dest_arr+uml_dest_loop_index, adsp_ucs_src_arr+ump_src_len, sizeof(struct dsd_unicode_string));
         if(inl_comp_res != 0){
         m_cmpi_vx_vx( &inl_comp_res, 
            adsp_ucs_dest_arr[uml_dest_loop_index].ac_str, 
            adsp_ucs_dest_arr[uml_dest_loop_index].imc_len_str, 
            adsp_ucs_dest_arr[uml_dest_loop_index].iec_chs_str, 
            adsp_ucs_src_arr[ump_src_len].ac_str,
            adsp_ucs_src_arr[ump_src_len].imc_len_str, 
            adsp_ucs_src_arr[ump_src_len].iec_chs_str);
         }
      }
      if(inl_comp_res != 0){
         // Found new name. copy and increase counters
         adsp_ucs_dest_arr[uml_dest_loop_index] = adsp_ucs_src_arr[ump_src_len];
         ump_dest_cnt++;
         if(ump_dest_cnt == ump_dest_len){
            break;
         }
      }
   }
   return ump_dest_cnt;
}

/**
Fills the given array of unicode strings with the DNS names of the end 
certificates from the provided configuration.

Names in multiple certificates are put only once. If the array is to small, it
is filled completely and returns the total number of DNS names in the 
certificates. If it is of length 0, it is treated as error. Encoding is 
maintained, as it is.

The strings are only valid, while the configuration is registered.

Only a maximum of 100 names per certificate (Including other types of subject 
alternative names) and 512 different DNS names per configuration can be processed 
by this routine.

@note m_cmpi_vx_vx is used to filter out double names from different certs. Since
      DNS names are generally assumed to be IDNA coding, doubles may appear, 
      while INDA isn't supported by this function.

@param vpp_config_id       Configuration ID pointer returned by m_registerconfig.
@param adsp_ucs_dns_name   Array to which the names are written.
@param imp_no_dns_name     Size of adsp_ucs_dns_name.

@return Total number of DNS names in the certificates. <0 on error.
*/
extern "C" int m_get_ssl_server_cert_dns_names(void * vpp_config_id, 
                                               struct dsd_unicode_string *adsp_ucs_dns_name, 
                                               int imp_no_dns_name ) 
{
   struct dsd_unicode_string adsl_ucs_cert_name_buf[100];
   struct dsd_unicode_string adsl_ucs_full_name_buf[512];
   unsigned int uml_full_name_cnt = 0;
   int inl_cert_cnt = 0;
   int inl_cert_name_cnt = 0;
   CTREESTR * adsl_cert_tree = NULL;
   X509CERT ** adsl_cert_list = NULL;
   int* ainl_cert_index_arr = NULL;
   int* ainl_cnode_index_array = NULL;
   X509CERT * adsl_cert = NULL;
   int inl_index = 0;

   // Input validation. Verify, that some config is set
   if( vpp_config_id == NULL || 
       adsp_ucs_dns_name == NULL ||
       imp_no_dns_name < 0)
   {
      return -1;
   }

   // Fetch the cert tree and cert list
   adsl_cert_tree = ((CFG_STRU*)vpp_config_id)->pCertTreeStruc;
   if( adsl_cert_tree == NULL || adsl_cert_tree->ppCertList == NULL){
      return -1;
   }
   adsl_cert_list = adsl_cert_tree->ppCertList;
   ainl_cnode_index_array = adsl_cert_tree->CNodeArray;

   // Iterate over end certificates, fill the full name buf

   // RSA certs
   ainl_cert_index_arr = adsl_cert_tree->EndRsaIndexArray;
   for(inl_cert_cnt = adsl_cert_tree->EndRsaCount; inl_cert_cnt > 0 ;)
   {
      inl_cert_cnt--;
      inl_index = ainl_cnode_index_array[ainl_cert_index_arr[
         inl_cert_cnt]+CN_CERTLIST_INDEX];
      adsl_cert = adsl_cert_list[inl_index];
      inl_cert_name_cnt = m_get_cert_dns_names( adsl_cert, adsl_ucs_cert_name_buf, 100);
      if( inl_cert_name_cnt < 0){
         // Error detected
         return -1;
      }
      uml_full_name_cnt = m_compare_and_fill(
         adsl_ucs_cert_name_buf, (unsigned int) inl_cert_name_cnt, 
         adsl_ucs_full_name_buf, uml_full_name_cnt, 512);
   }

   // DSA certs
   ainl_cert_index_arr = adsl_cert_tree->EndDssIndexArray;
   for(inl_cert_cnt = adsl_cert_tree->EndDssCount; inl_cert_cnt > 0 ;)
   {
      inl_cert_cnt--;
      inl_index = ainl_cnode_index_array[ainl_cert_index_arr[
         inl_cert_cnt]+CN_CERTLIST_INDEX];
      adsl_cert = adsl_cert_list[inl_index];
      inl_cert_name_cnt = m_get_cert_dns_names( adsl_cert, adsl_ucs_cert_name_buf, 100);
      if( inl_cert_name_cnt < 0){
         // Error detected
         return -1;
      }
      uml_full_name_cnt = m_compare_and_fill(
         adsl_ucs_cert_name_buf, (unsigned int) inl_cert_name_cnt, 
         adsl_ucs_full_name_buf, uml_full_name_cnt, 512);
   }

   // DH-RSA certs
   ainl_cert_index_arr = adsl_cert_tree->EndDhRsaIndexArray;
   for(inl_cert_cnt = adsl_cert_tree->EndDhRsaCount; inl_cert_cnt > 0 ;)
   {
      inl_cert_cnt--;
      inl_index = ainl_cnode_index_array[ainl_cert_index_arr[
         inl_cert_cnt]+CN_CERTLIST_INDEX];
      adsl_cert = adsl_cert_list[inl_index];
      inl_cert_name_cnt = m_get_cert_dns_names( adsl_cert, adsl_ucs_cert_name_buf, 100);
      if( inl_cert_name_cnt < 0){
         // Error detected
         return -1;
      }
      uml_full_name_cnt = m_compare_and_fill(
         adsl_ucs_cert_name_buf, (unsigned int) inl_cert_name_cnt, 
         adsl_ucs_full_name_buf, uml_full_name_cnt, 512);
   }

   // DH-DSA certs
   ainl_cert_index_arr = adsl_cert_tree->EndDhDssIndexArray;
   for(inl_cert_cnt = adsl_cert_tree->EndDhDssCount; inl_cert_cnt > 0 ;)
   {
      inl_cert_cnt--;
      inl_index = ainl_cnode_index_array[ainl_cert_index_arr[
         inl_cert_cnt]+CN_CERTLIST_INDEX];
      adsl_cert = adsl_cert_list[inl_index];
      inl_cert_name_cnt = m_get_cert_dns_names( adsl_cert, adsl_ucs_cert_name_buf, 100);
      if( inl_cert_name_cnt < 0){
         // Error detected
         return -1;
      }
      uml_full_name_cnt = m_compare_and_fill(
         adsl_ucs_cert_name_buf, (unsigned int) inl_cert_name_cnt, 
         adsl_ucs_full_name_buf, uml_full_name_cnt, 512);
   }

   // Now fill the destination array
   if((int)uml_full_name_cnt > imp_no_dns_name){
      memcpy(adsp_ucs_dns_name, adsl_ucs_full_name_buf, imp_no_dns_name*sizeof(struct dsd_unicode_string));
   } else {
      memcpy(adsp_ucs_dns_name, adsl_ucs_full_name_buf, uml_full_name_cnt*sizeof(struct dsd_unicode_string));
   }

   return uml_full_name_cnt;
}//int m_get_ssl_server_cert_dns_names( void * vpp_config_id, struct dsd_unicode_string *adsp_ucs_dns_name, int imp_no_dns_name );

#if XH_INTF_VERSION >= 300

extern "C" BOOL m_get_server_certificate(void **aap_addr,
                                         int *aimp_len,
                                         void * avop_ssl_con_struct )
{
   CONNSTRU* adsl_conn_struct;
   CFG_STRU* adsl_cfg;
   CTREESTR* adsl_cert_tree;
   X509CERT* adsl_cert;
   int inl_cert_index;

   if( NULL == aap_addr || NULL == aimp_len || NULL == avop_ssl_con_struct ||
      NULL == avop_ssl_con_struct || NULL == ((XHCONNSTRUC *) avop_ssl_con_struct)->pConnStruc )
   {
      return FALSE;
   }

   // Prepare conn struct and configuration
   adsl_conn_struct = ((XHCONNSTRUC *) avop_ssl_con_struct)->pConnStruc;
   adsl_cfg = adsl_conn_struct->pCfgStruc;

   if( NULL == adsl_cfg )
   {
      return FALSE;
   }

   adsl_cert_tree = adsl_cfg->pCertTreeStruc;

   if( NULL == adsl_cert_tree )
   {
      return FALSE;
   }

   inl_cert_index = 				// get index to Cert List
      adsl_cert_tree->CNodeArray[
         (adsl_conn_struct->LocalCNIndex)+CN_CERTLIST_INDEX];
   adsl_cert = adsl_cert_tree->ppCertList[inl_cert_index]; // get Certificate

   if( NULL == adsl_cert || NULL == adsl_cert->Certificate ||
      NULL == adsl_cert->Certificate->ppArr ||
      NULL == adsl_cert->Certificate->ppArr[0]->Base)
   {
      return FALSE;
   }

   *aap_addr = adsl_cert->Certificate->ppArr[0]->Base + 
      adsl_cert->Certificate->ppArr[0]->Off;

   *aimp_len = adsl_cert->Certificate->ppArr[0]->Len;

   return TRUE;

}//BOOL m_get_server_certificate( void **aap_addr, int *aimp_len, struct dsd_hl_ssl_s_3 * adsp_ssl_struct );

int m_se_reg_srp_cfg(am_get_srp_params amp_get_param_fct,
                     BOOL (* amp_aux) (void *vpp_userfld,int,void *, int),
                     void * vpp_userfld,
                     void ** aavop_cfg_id)
{
   int inl_ret;

   CFG_STRU * pCfgStruc;
   CFG_STRU * pTmpCfgStruc[1];

   HMEM_CTX_DEF1;

   ds__hmem CtxStruc;

   if((NULL == amp_aux) ||
      (NULL == amp_get_param_fct) || 
      (NULL == aavop_cfg_id) )
   {
      return (HSSL_NULL_PTR);
   }

   CtxStruc = m_make_mem_struct(amp_aux, vpp_userfld, HMEM_NO_POOLS_FLAG_BIT);

   LOAD_HMEM_CTX_PTR(&CtxStruc);
   
   inl_ret = m_new_srp_cfg(HMEM_CTX_REF1 pTmpCfgStruc);
   if(inl_ret != HSSL_OP_OK)
   {
      MEMMGR_FREE(HMEM_CTX_REF);
      return(inl_ret);
   }
   pCfgStruc = pTmpCfgStruc[0];
   
   // Save memory context to structure (!)
   memcpy(&pCfgStruc->CfgMemCtxStruc,vp__ctx,sizeof(ds__hmem));
   pCfgStruc->pCfgMemCtx = &pCfgStruc->CfgMemCtxStruc;

   // Set entity and SRP function
   pCfgStruc->Entity = SERVER_ENTITY;
   pCfgStruc->amc_get_srp_server_params = amp_get_param_fct;

   pCfgStruc->pCfgMemCtx->in__flags |= HMEM_LOCKED_STRUC_FLAG_BIT;

   aavop_cfg_id[0] = pCfgStruc;
   return(HSSL_OP_OK);
}//int m_se_reg_srp_cfg(am_get_srp_params amp_get_param_fct, BOOL (* amp_aux) (void *vpp_userfld,int,void *, int), void * vpp_userfld, void ** aavop_cfg_id);

int m_cl_reg_srp_cfg(am_get_srp_user_name amp_get_user_name,
                     am_get_srp_pw amp_get_user_pw,
                     BOOL (* amp_aux) (void *vpp_userfld,int,void *, int),
                     void * vpp_userfld,
                     void ** aavop_cfg_id)
{
   int inl_ret;

   CFG_STRU * pCfgStruc;
   CFG_STRU * pTmpCfgStruc[1];

   HMEM_CTX_DEF1;

   ds__hmem CtxStruc;

   if(NULL == amp_aux || NULL == amp_get_user_name || 
      NULL == amp_get_user_pw || NULL == aavop_cfg_id )
   {
      return (HSSL_NULL_PTR);
   }

   CtxStruc = m_make_mem_struct(amp_aux, vpp_userfld, HMEM_NO_POOLS_FLAG_BIT);

   LOAD_HMEM_CTX_PTR(&CtxStruc);

   inl_ret = m_new_srp_cfg(HMEM_CTX_REF1 pTmpCfgStruc);
   if(inl_ret != HSSL_OP_OK)
   {
      MEMMGR_FREE(HMEM_CTX_REF);
      return(inl_ret);
   }
   pCfgStruc = pTmpCfgStruc[0];
   
   // Save memory context to structure (!)
   memcpy(&pCfgStruc->CfgMemCtxStruc,vp__ctx,sizeof(ds__hmem));
   pCfgStruc->pCfgMemCtx = &pCfgStruc->CfgMemCtxStruc;

   // Set entity and SRP function
   pCfgStruc->Entity = CLIENT_ENTITY;
   pCfgStruc->amc_get_srp_name = amp_get_user_name;
   pCfgStruc->amc_get_srp_pw = amp_get_user_pw;

   pCfgStruc->pCfgMemCtx->in__flags |= HMEM_LOCKED_STRUC_FLAG_BIT;

   aavop_cfg_id[0] = pCfgStruc;
   return(HSSL_OP_OK);
}//int m_cl_reg_srp_cfg(am_get_srp_user_name amp_get_user_name, am_get_srp_pw amp_get_user_pw, BOOL (* amp_aux) (void *vpp_userfld,int,void *, int), void * vpp_userfld, void ** aavop_cfg_id);

int m_calulate_verifier(struct dsd_tls_srp_verifier_params* adsp_params, 
                        BOOL (* amp_aux) (void *vpp_userfld,int,void *, int), 
                        void * vpp_userfld)
{
   char chrl_x[SHA_DIGEST_LEN];
   WLARGENUM* adsl_x = NULL;
   WLARGENUM* adsl_g = NULL;
   WLARGENUM* adsl_n = NULL;
   WLARGENUM* adsl_ver = NULL;
   int inl_ret = 0;

   HMEM_CTX_DEF1;

   ds__hmem CtxStruc;

   // Input validation
   if( (NULL == adsp_params->achc_password) || (NULL == adsp_params->achc_salt) || 
       (NULL == adsp_params->aucc_n) || (NULL ==adsp_params->aucc_g) || 
       (NULL == adsp_params->aucc_verifier) ||
       (1 > adsp_params->szc_pw_len) || (0xff < adsp_params->szc_pw_len) ||
       (1 > adsp_params->szc_salt_len) || (0xff < adsp_params->szc_salt_len) ||
       (1 > adsp_params->szc_n_len) || (0xffff < adsp_params->szc_n_len) ||
       (1 > adsp_params->szc_g_len) || (0xffff < adsp_params->szc_g_len) ||
       (adsp_params->szc_ver_len < adsp_params->szc_n_len) )
   {
      return (HSSL_PARAM_ERR);
   }

   CtxStruc = m_make_mem_struct(amp_aux, vpp_userfld, HMEM_NO_POOLS_FLAG_BIT);

   LOAD_HMEM_CTX_PTR(&CtxStruc);

   adsl_x = AllocNewWLnum(HMEM_CTX_REF1 SHA_DIGEST_LEN/4);
   adsl_g = AllocNewWLnum(HMEM_CTX_REF1 (int)(adsp_params->szc_g_len/4)+1);
   adsl_n = AllocNewWLnum(HMEM_CTX_REF1 (int)(adsp_params->szc_n_len/4)+1);
   adsl_ver = AllocNewWLnum(HMEM_CTX_REF1 (int)(adsp_params->szc_n_len/4)+1);

   if( (NULL == adsl_x) || (NULL == adsl_g) || 
      (NULL == adsl_n) || (NULL == adsl_ver) )
   {
      FreeWLnum(HMEM_CTX_REF1 adsl_x);
      FreeWLnum(HMEM_CTX_REF1 adsl_g);
      FreeWLnum(HMEM_CTX_REF1 adsl_n);
      FreeWLnum(HMEM_CTX_REF1 adsl_ver);
      return (HSSL_ALLOC_ERR);
   }

   m_srp_calc_x(adsp_params->achc_name, (int)adsp_params->szc_name_len, 
      adsp_params->achc_password, (int)adsp_params->szc_pw_len, 
      adsp_params->achc_salt, (int)adsp_params->szc_salt_len, chrl_x);
   
   inl_ret = WLnum_bin2wlnum(HMEM_CTX_REF1 adsl_x,chrl_x,0,SHA_DIGEST_LEN);
   inl_ret |= WLnum_bin2wlnum(HMEM_CTX_REF1 adsl_g,(char*)(adsp_params->aucc_g),0,(int)(adsp_params->szc_g_len));
   inl_ret |= WLnum_bin2wlnum(HMEM_CTX_REF1 adsl_n,(char*)(adsp_params->aucc_n),0,(int)(adsp_params->szc_n_len));
   
   if( 0 != inl_ret ){
      ClearBit8Array(chrl_x, SHA_DIGEST_LEN);
      ClearFreeWLnum(HMEM_CTX_REF1 adsl_x);
      FreeWLnum(HMEM_CTX_REF1 adsl_n);
      FreeWLnum(HMEM_CTX_REF1 adsl_g);
      FreeWLnum(HMEM_CTX_REF1 adsl_ver);
      return (inl_ret);
   }

   inl_ret = ExpModWLnum(HMEM_CTX_REF1 adsl_ver,adsl_g,adsl_x,adsl_n,NULL,NULL);

   if( 0 == inl_ret ){
      int inl_len = (int)(adsp_params->szc_ver_len);
      inl_ret = WLnum_wlnum2bin((char*)(adsp_params->aucc_verifier),0,&inl_len,adsl_ver,0);
      adsp_params->szc_ver_len = inl_len;
   }

   ClearBit8Array(chrl_x, SHA_DIGEST_LEN);
   ClearFreeWLnum(HMEM_CTX_REF1 adsl_x);
   FreeWLnum(HMEM_CTX_REF1 adsl_n);
   FreeWLnum(HMEM_CTX_REF1 adsl_g);
   ClearFreeWLnum(HMEM_CTX_REF1 adsl_ver);
   return (inl_ret);
}//int m_calulate_verifier(struct dsd_tls_srp_verifier_params* adsp_params, BOOL (* amp_aux) (void *vpp_userfld,int,void *, int), void * vpp_userfld);

#endif //  XH_INTF_VERSION >= 300

#endif //!JAVA

static bool ms_is_supported_cipher(unsigned short chp_cipher)
{
    bool bol_is_supported = false;
    for(unsigned int unl_index = 0;
        unl_index < MAX_SUPPORTED_SUITES;
        unl_index++)
    {
        bol_is_supported |= (SupportedSuites[unl_index] == (unsigned short)chp_cipher);
    }

    return bol_is_supported;
}

extern "C" int m_filter_cipher_list(char* achp_cipher_list)
{
    char* achl_cur_position = achp_cipher_list;
    unsigned short usl_remaining_len;
    BIGchar2wordn(achl_cur_position, usl_remaining_len, 0);
    achl_cur_position += 2;

    if((usl_remaining_len & 0X01) != 0){
        return -1;
    }

    unsigned short usl_total_len = 0;
    while(usl_remaining_len != 0){
        usl_remaining_len -= 2;
        unsigned short usl_cipher = (((unsigned short)achl_cur_position[0] & 0xff) << 8) |
                                    ((unsigned short)achl_cur_position[1] & 0xff);
        if(! ms_is_supported_cipher(usl_cipher))
        {
            memmove(achl_cur_position, achl_cur_position+2, usl_remaining_len);
        } else {
            usl_total_len += 2;
            achl_cur_position += 2;
        }
    }

    BIGword2charn(usl_total_len, achp_cipher_list, 0);

    return usl_total_len/2;
}

/** @} */


#endif //HL_SSL_PROT_MAIN
// end of file ../hssl/hssldpro.cpp


#ifdef HL_SSL_EXT_CERT
/** @addtogroup asn1
* @{
* @file
* This file implements functions for accessing external certificate storages
* using MS-CAPI.
* @}
*/
//*****************************************************************
//
// Routines for external Certificates/Signing from MS-CAPI
// with JAVA and C
//
//*****************************************************************
#if (defined _WIN32) & (_MSC_VER < 1700)
#ifndef _STDINT
#define _STDINT
// MSVC lower than 17.00 does not have stdint.h, assure, all needed types are defined

typedef unsigned __int16 uint16_t;

typedef unsigned __int32 uint32_t;

typedef unsigned __int64 uint64_t;

#endif // !_STDINT
#else
#include <stdint.h>
#endif
#include <stddef.h>
#ifdef _WIN32
#define WIN32_LEAN_AND_MEAN
#include <Windows.h>
#undef WIN32_LEAN_AND_MEAN
#else// Define system-specific HL_* defines here
#ifndef HL_UNIX
#define HL_UNIX

#if (defined __gnu_linux__) || (defined __linux__)
#define HL_LINUX
#endif

#if (defined __APPLE__) && (defined __MACH__)
#define HL_LINUX
#define HL_MACOS
#endif

#ifdef _AIX
#define HL_AIX
#define HL_BIG_ENDIAN
#endif

#ifdef __FreeBSD__
#define HL_FREEBSD
#endif

#if (defined _hpux) || (defined hpux) || (defined __hpux)
#define HL_HPUX
#define HL_BIG_ENDIAN
#endif

#if (defined sun) || (defined __sun)
#define HL_SOLARIS
#endif

#if (defined __arm__) || (defined __aarch64__)
#define HL_LINUX_ARM
#endif

#ifdef __ANDROID__
#define HL_ANDROID
#endif

#endif
#include <hob-unix01.h>
#endif
#ifdef __APPLE__
/* We get target conditionals to keep apart Mac OS, iOS and iOS simulator.
   The conditionals are TARGET_IPHONE_SIMULATOR, TARGET_OS_IPHONE and TARGET_OS_MAC.
   TARGET_IPHONE_SIMULATOR has the highest priority, TARGET_OS_MAC the lowest.
   Always test, if the conditional is 1, as they will be defined as 0, if we 
   are not compiling for the target.
   */
#include <TargetConditionals.h>
#endif

#ifdef HL_ANDROID
#include <sys/endian.h>
#endif

#ifdef _WIN32
#include <winsock.h>
#endif
#include "hob-encry-1.h"
#include "hob-cert-ext.h"
#if !(defined __HOB_XSCLIB01__) && !(defined DEF_IFUNC_START)
#define __HOB_XSCLIB01__

#include <hob-xsclib01.h>  
#endif // !__HOB_XSCLIB01__
#include <stdlib.h>
#include <hob-encry-2.h>
#include "hob-ssl-intern.h"
#include "hob-ssl-err.h"
#include "hob-cert-err.h"
#include <string.h>
#include "hob-cert-intern.h"
#include "hob-encry-intern-1.h"

#if !defined C_OUT
#include <stdlib.h>
#include <string.h>
#if defined _WIN32
#include <direct.h>
#endif
#endif // C_OUT

#if defined _WIN32
#pragma warning(disable:4996)
#include <wchar.h>
#endif

//()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()
//
// Interface Wrapper functions, WIN32/64, C and JAVA
//
//()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()
/** @addtogroup asn1
* @{
*/
#if defined _WIN32
#define DLL_PATH_LEN 2048
static LPWSTR awcs_dll_path = NULL;
static size_t szs_dll_path_len = 0;

//---------------------------------------------------------------------------------------------
// Functions for Windows systems
//---------------------------------------------------------------------------------------------

/**
* Initializes 'Crypto-API' (HSSL_InitCryptoApiDll).
* for detailed parameter specification see the C/Java Sources
*
*  @param pExtStruc Extension Structure
*  @param nOpMode Mode of operation; reserved, 0
*  @param pbyWrDirBuf Path for file write / NULL ?
*  @param nWrDirBufOff start of path data
*  @param nWrDirBufLen length of path
*  @param pbyAddInBuf Additional data buffer / NULL
*  @param nAddInBufOff Start of Data
*  @param nAddInBufLen Length of additional data
*  @param pnCrApiType Type of API loaded
*
*  @return int Status - 0 o.k., else error occured
*/
static  int  HSSL_InitCryptoApiDll(HEXTCST * pExtStruc,
	int nOpMode, char* pbyWrDirBuf, int nWrDirBufOff, int nWrDirBufLen,
	char* pbyAddInBuf, int nAddInBufOff, int nAddInBufLen,
	int* pnCrApiType)
{
  int Retcode;
  //-------------------------------------------------------
  // Check parameters first
  //-------------------------------------------------------
  if(pExtStruc == NULL)
    return(HSSL_NULL_PTR);
  if(pExtStruc->IntfLoadedFlag == 0)
    return(HSSL_EXTCERT_INTF_NOT_LOADED_ER);
  //-------------------------------------------------------
  // Call the Interface Function
  //-------------------------------------------------------
  Retcode =
    ((LPInitCryptoApiDll)
     (pExtStruc->pFunctPtrArr[INIT_CRYPTO_API_DLL_IND]))(
	nOpMode, pbyWrDirBuf, nWrDirBufOff, nWrDirBufLen,
	pbyAddInBuf, nAddInBufOff, nAddInBufLen,
        pnCrApiType);
  if(Retcode < 0)
    Retcode = -(-Retcode & 0xFFFF);

  return(Retcode);
}

/**
* Get Certificate chain for server Verification (HSSL_GetCChainForSrvrVerify).
* for detailed parameter specification see the C/Java Sources.
*
*  @param pExtStruc Extension Structure
*  @param pbyInputDataBuf Buffer with Data to process
*  @param nIDOffset Start of data
*  @param nIDLength Length of Data
*  @param nOpMode Type of Operation
*
*  @param ppbyDestBuf ??
*  @param pnNmbOfCerts OUT: Certificate Count
*  @param pnMaxDataLen OUT: max. req. size
*
*  @return int Status - 0 o.k., else error occured
*/
static  int  HSSL_GetCChainForSrvrVerify(HEXTCST * pExtStruc,
	char* pbyInputDataBuf, int nIDOffset, int nIDLength, int nOpMode,
	char** ppbyDestBuf, int* pnNmbOfCerts, int* pnMaxDataLen)
{
  int Retcode;
  //-------------------------------------------------------
  // Check parameters first
  //-------------------------------------------------------
  if(pExtStruc == NULL)
    return(HSSL_NULL_PTR);
  if(pExtStruc->IntfLoadedFlag == 0)
    return(HSSL_EXTCERT_INTF_NOT_LOADED_ER);
  //-------------------------------------------------------
  // Call the Interface Function
  //-------------------------------------------------------
  Retcode =
    ((LPGetCChainForSrvrVerify)
     (pExtStruc->pFunctPtrArr[GET_CCHAIN_FOR_SRVR_VERIFY_IND]))(
	pbyInputDataBuf, nIDOffset, nIDLength, nOpMode,
	ppbyDestBuf, pnNmbOfCerts, pnMaxDataLen);
  if(Retcode < 0)
    Retcode = -(-Retcode & 0xFFFF);
  return(Retcode);
}

/**
* Get a Certificate chain for Client Authentication (HSSL_GetClntCChainForAuthent).
* for detailed parameter specification see the C/Java Sources.
*
*  @param pExtStruc Extension Structure
*  @param pbyRdnInput RDN from Server for select
*  @param nRdnDOffset Start of RDN data
*  @param nRdnDLength length of RDN data
*  @param pbySigAlgInput Signature Algors for select
*  @param nSAlgDOffset Start of Data
*  @param nSAlgDLength length of Algors data
*  @param pbySubjectSelIn Subject Name (RDN?) buffer
*  @param nSubSelOffset Start of Data
*  @param nSubSelLength length of subject name
*  @param nOpMode Chain Build/Select mode
*  @param pnPrevCertID ???
*  @param pnPrevStoreID ???
*  @param ppbyDestBuf OUT: Chain of Certs
*  @param pnNmbOfCerts OUT: Certificate Count
*  @param pnMaxDataLen OUT: max. req. size
*
*  @return int Status - 0 o.k., else error occured
*/
static  int  HSSL_GetClntCChainForAuthent(HEXTCST * pExtStruc,
	char* pbyRdnInput, int nRdnDOffset, int nRdnDLength,
	char* pbySigAlgInput, int nSAlgDOffset, int nSAlgDLength,
	char* pbySubjectSelIn, int nSubSelOffset, int nSubSelLength,
	int nOpMode, int* pnPrevCertID, int* pnPrevStoreID,
	char** ppbyDestBuf, int* pnNmbOfCerts, int* pnMaxDataLen)
{
  int Retcode;
  //-------------------------------------------------------
  // Check parameters first
  //-------------------------------------------------------
  if(pExtStruc == NULL)
    return(HSSL_NULL_PTR);
  if(pExtStruc->IntfLoadedFlag == 0)
    return(HSSL_EXTCERT_INTF_NOT_LOADED_ER);
  //-------------------------------------------------------
  // Call the Interface Function
  //-------------------------------------------------------
  Retcode =
    ((LPGetClntCChainForAuthent)
     (pExtStruc->pFunctPtrArr[GET_CLIENT_CCHAIN_FOR_AUTH_IND]))(
	pbyRdnInput, nRdnDOffset, nRdnDLength,
	pbySigAlgInput, nSAlgDOffset, nSAlgDLength,
	pbySubjectSelIn, nSubSelOffset, nSubSelLength,
        nOpMode, pnPrevCertID, pnPrevStoreID,
	ppbyDestBuf, pnNmbOfCerts, pnMaxDataLen);
  if(Retcode < 0)
    Retcode = -(-Retcode & 0xFFFF);
  return(Retcode);
}
/**
* Sign given Data with the Client's private key associated with a
* Client certificate (HSSL_SignDataWithCPrivKey).
* for detailed parameter specification see the C/Java Sources.
*
*  @param pExtStruc Extension Structure
*  @param pbyCertDInput Client Certificate to use
*  @param nCertDOffset Start of Cert data
*  @param nCertDLength Length of Cert data
*  @param pbyDataInput Buffer with Data to sign
*  @param nDataOffset Start of data
*  @param nDataLength length of data to sign
*  @param nOpMode Sign mode selected
*  @param ppbyDestBuf OUT: Signed data
*  @param pnMaxDataLen OUT: max. req. size
*
*  @return int Status - 0 o.k., else error occured
*/
static  int  HSSL_SignDataWithCPrivKey(HEXTCST * pExtStruc,
	char* pbyCertDInput, int nCertDOffset, int nCertDLength,
	char* pbyDataInput, int nDataOffset, int nDataLength,
	int nOpMode, char** ppbyDestBuf, int* pnMaxDataLen)
{
  int Retcode;
  //-------------------------------------------------------
  // Check parameters first
  //-------------------------------------------------------
  if(pExtStruc == NULL)
    return(HSSL_NULL_PTR);
  if(pExtStruc->IntfLoadedFlag == 0)
    return(HSSL_EXTCERT_INTF_NOT_LOADED_ER);
  //-------------------------------------------------------
  // Call the Interface Function
  //-------------------------------------------------------
  Retcode =
    ((LPSignDataWithCPrivKey)
     (pExtStruc->pFunctPtrArr[SIGN_DATA_WITH_CPRIVKEY_IND]))(
	pbyCertDInput, nCertDOffset, nCertDLength,
	pbyDataInput, nDataOffset, nDataLength,
	nOpMode, ppbyDestBuf, pnMaxDataLen);
  if(Retcode < 0)
    Retcode = -(-Retcode & 0xFFFF);
  return(Retcode);
}

/**
* This function is called to clear the data from the key "SelCertIdent" 
* in the section "HOBCryptoApi" of the ini-file "CSelCAhob.ini" (HSSL_ForgetCertIniEntry). 
* It is 
* necessary to clear this entry after an error occured so that the user 
* has the chance to select the certificate again which he wishes to use.
* Otherwise, if the connection failed because of a wrong certificate,
* the user has to clear the ini-file manually (which is not desirable).
*
*  @param pExtStruc Extension Structure
*  @param nOpMode Mode of operation:
*               0 - reserved (currently not used)
*  @return int Status - 0 o.k., else error occured
*/
static  int  HSSL_ForgetCertIniEntry(HEXTCST * pExtStruc,
						int nOpMode)
{
  int Retcode;
  //-------------------------------------------------------
  // Check parameters first
  //-------------------------------------------------------
  if(pExtStruc == NULL)
    return(HSSL_NULL_PTR);
  if(pExtStruc->IntfLoadedFlag == 0)
    return(HSSL_EXTCERT_INTF_NOT_LOADED_ER);
  //-------------------------------------------------------
  // Call the Interface Function (if implemented)
  //-------------------------------------------------------
  if(pExtStruc->pFunctPtrArr[FORGET_CERT_INI_ENTRY_IND] == NULL)
    return(HSSL_OP_OK);

  Retcode =
    ((LPForgetCertIniEntry)
     (pExtStruc->pFunctPtrArr[FORGET_CERT_INI_ENTRY_IND]))(nOpMode);

  if(Retcode < 0)
    Retcode = -(-Retcode & 0xFFFF);
  return(Retcode);
}

static int m_read_ext_clib_path(HINSTANCE dsp_module_instance, 
                                LPWSTR awcp_module_path)
{
    if(awcs_dll_path != NULL){
        memcpy(awcp_module_path, awcs_dll_path, szs_dll_path_len*sizeof(LPWSTR*));
    } else {
        if(dsp_module_instance == NULL){
            awcp_module_path[0] = 0;
            wcscat(awcp_module_path,HSSL_EX_MODULE_DLLNAME);
            return HSSL_OP_OK;
        }

        // Get the Modules Path from the instance.
        DWORD iml_path_len = GetModuleFileNameW(dsp_module_instance, 
                                                awcp_module_path, 
                                                DLL_PATH_LEN+1);
        if(iml_path_len <= 0) {
            return HSSL_EXTCERT_INIT_GET_PATH_FAIL;
        }
        awcp_module_path[iml_path_len] = 0;		// zero terminate
    }
    // Scan backward for the last '\' Character, if any
    LPWSTR achl_delimiter = wcsrchr(awcp_module_path,(int) '\\');
    if(achl_delimiter == NULL){
        awcp_module_path[0] = 0;		// no delimiter, discard !
    } else {
        *(achl_delimiter+1) = 0;			// delimit past the '\' 
    }

    // Append the DLL's name to the path
    wcscat(awcp_module_path,HSSL_EX_MODULE_DLLNAME);
    return HSSL_OP_OK;
}

/**
* Load the C Interface Library, get the Entry point addresses (LoadExtClib).
* NOTE: We use the path to the current module's path, if a module instance is given.
* -----
*
*  @param pExtStruc Extension Structure
*  @param hModuleInst Instance of Module / NULL
*  @return int Status - 0 o.k., else error occured
*/
static int LoadExtClib(HMEM_CTX_DEF
                       HEXTCST * pExtStruc,
                       HINSTANCE hModuleInst)
{
    int (**pFunctPtrArr)();
    HMODULE hExtCertLib = NULL;
    WCHAR ModulePathBuf[DLL_PATH_LEN + 64];

    int Retcode = m_read_ext_clib_path(hModuleInst, ModulePathBuf);
    if(Retcode != HSSL_OP_OK){
        return Retcode;
    }

    // Allocate the function pointer Array needed
    pFunctPtrArr = (int (**)()) BIT8_ARRAY_CALLOC(HMEM_CTX_REF, 
                                                  1, 
                                                  sizeof(void *) * EXT_CERT_MAX_FUNCT_CNT);
    if(pFunctPtrArr == NULL){
        return(HSSL_EXTCERT_INIT_ALLOC_FAILED);
    }

    // Load the Library, get the PROC Addresses
    hExtCertLib = LoadLibraryW(ModulePathBuf);
    if(hExtCertLib == NULL) {
        Retcode = HSSL_EXTCERT_INIT_LOAD_LIB_FAIL;
        goto error;
    }

    // Get the functions addressed
    Retcode = HSSL_EXTCERT_INIT_PROCADR_FAIL;	// assume Error...
    pFunctPtrArr[INIT_CRYPTO_API_DLL_IND] = 
        (int (*) ()) GetProcAddress(hExtCertLib, INIT_CRAPI_PROC_NAME);
    pFunctPtrArr[GET_CCHAIN_FOR_SRVR_VERIFY_IND] = 
        (int (*) ()) GetProcAddress(hExtCertLib, GET_SRVR_VERIFY_CCHAIN_NAME);
    pFunctPtrArr[GET_CLIENT_CCHAIN_FOR_AUTH_IND] = 
        (int (*) ()) GetProcAddress(hExtCertLib, GET_CLNT_AUTHENT_CCHAIN_NAME);
    pFunctPtrArr[SIGN_DATA_WITH_CPRIVKEY_IND] = 
        (int (*) ()) GetProcAddress(hExtCertLib, SIGN_DATA_CLNT_PRIVKEY_NAME);

    if((pFunctPtrArr[INIT_CRYPTO_API_DLL_IND] == NULL) || 
        (pFunctPtrArr[GET_CCHAIN_FOR_SRVR_VERIFY_IND] == NULL) || 
        (pFunctPtrArr[GET_CLIENT_CCHAIN_FOR_AUTH_IND] == NULL) || 
        (pFunctPtrArr[SIGN_DATA_WITH_CPRIVKEY_IND] == NULL)){
            goto error;
    }

    // Note: next function is optional !!
    pFunctPtrArr[FORGET_CERT_INI_ENTRY_IND] = (int (*) ())
        GetProcAddress(hExtCertLib,CRAPI_FORGET_INI_NAME);

#if defined __VPN_INTERFACE__
    pFunctPtrArr[STARTUP_ENTRY_IND] = 
        (int (*) ()) GetProcAddress(hExtCertLib,EXT_DLL_STARTUP_NAME);
    pFunctPtrArr[CLEANUP_ENTRY_IND] = 
        (int (*) ()) GetProcAddress(hExtCertLib,EXT_DLL_CLEANUP_NAME);
    pFunctPtrArr[CONN_CHECK_ENTRY_IND] =
        (int (*) ()) GetProcAddress(hExtCertLib,EXT_DLL_CONNCHK_NAME);
    if((pFunctPtrArr[STARTUP_ENTRY_IND] == NULL) || 
        (pFunctPtrArr[CLEANUP_ENTRY_IND] == NULL) ||  
        (pFunctPtrArr[CONN_CHECK_ENTRY_IND] == NULL)){
            goto error;
    }
    Retcode = ((LPVpnStartup)
        (pFunctPtrArr[STARTUP_ENTRY_IND]))();
    if(Retcode != HSSL_OP_OK){
        goto error;
    }
#endif

    // Insert Parameters into Extension structure
    pExtStruc->hExtCertLib    = hExtCertLib;
    pExtStruc->pFunctPtrArr   = pFunctPtrArr;
    pExtStruc->IntfLoadedFlag = 1;
    return HSSL_OP_OK;

error:
    if(hExtCertLib != NULL)
    {
#if defined __VPN_INTERFACE__
        if(pFunctPtrArr[CLEANUP_ENTRY_IND] != NULL)
            ((LPVpnCleanup)(pFunctPtrArr[CLEANUP_ENTRY_IND]))();
#endif
        FreeLibrary(hExtCertLib);
    }
    FREE_ARRAY(HMEM_CTX_REF,pFunctPtrArr);
    return Retcode;
}

/**
* Get Path to a writeable Directory. At the moment we use
* the current directory (GetCWritePath). 
* This will be replaces later (for XP).
*
*  @param pExtStruc Extension Structure
*  @param ppPathBuf Allocated Path (ASCIIz)
*  @param pPathLen size of Path (excl. 0)
*  @return int Status - 0 o.k., else error occured
*/
static  int  GetCWritePath(HEXTCST * pExtStruc,
			char** ppPathBuf, int* pPathLen)
{
  pExtStruc = pExtStruc;

  if((ppPathBuf == NULL) || (pPathLen == NULL))
    return(HSSL_NULL_PTR);

  pPathLen[0] = 0;
  ppPathBuf[0] = getcwd(NULL,_MAX_PATH+1);
  if(ppPathBuf[0] == NULL)
    return(HSSL_EXTCERT_INIT_GET_PATH_FAIL);
  pPathLen[0] = (int) strlen(ppPathBuf[0]);
  return(HSSL_OP_OK);
}

extern "C" void m_reset_hssl_dll_path()
{
    if(awcs_dll_path != NULL){
        free(awcs_dll_path);
        awcs_dll_path = NULL;
        szs_dll_path_len = 0;
    }
}

extern "C" int m_set_hssl_dll_path(const LPWSTR awcp_path,
                                   size_t szp_len)
{
    if(awcp_path == NULL || szp_len == 0){
        return HSSL_PARAM_ERR;
    }
    awcs_dll_path = (LPWSTR)realloc(awcs_dll_path, szp_len*sizeof(LPWSTR*));
    if(awcs_dll_path == NULL){
        return HSSL_ALLOC_ERR;
    }
    memcpy(awcs_dll_path, awcp_path, szp_len*sizeof(LPWSTR*));
    szs_dll_path_len = szp_len;
    return HSSL_OP_OK;
}

/**
* Loads the interface libraries/class, initializes the interface (HSSL_InitExtCertLib).
*
* This is the main starter function which has to be called first to
* get access to external stores via the Crypto API DLLs (MS Win only).
*
*  @param pCfgStruc Configuration structure
*  @param hModuleInst Module instance
*  @return int Status - 0 o.k., else error occured
*/
extern "C"  int  HSSL_InitExtCertLib(HMEM_CTX_DEF
					   CFG_STRU * pCfgStruc, HINSTANCE hModuleInst )
{
  int Retcode;
  HEXTCST * pExtStruc = NULL;
  int pApiType[1];
  int pPathLen[1];
  char* ppPathBuf[1];

  if(pCfgStruc == NULL)
  {
    return(HSSL_NULL_PTR);
  }
  //---------------------------------------------------------
  // Allocate the extension structure needed
  //---------------------------------------------------------
  pExtStruc = (HEXTCST *)
    BIT8_ARRAY_CALLOC(HMEM_CTX_REF,1,sizeof(HEXTCST));
  if(pExtStruc == NULL)
    return(HSSL_EXTCERT_STRUC_ALLOC_FAILED);

  //---------------------------------------------------------
  // C: Load the DLL, get Function Pointers
  //---------------------------------------------------------
  if((Retcode = LoadExtClib(HMEM_CTX_REF1
			    pExtStruc, hModuleInst)) != HSSL_OP_OK)
  {
    FREE_ARRAY(HMEM_CTX_REF,pExtStruc);
    return(Retcode);
  }
  //---------------------------------------------------------
  // C: Get Path to Writeable Directory
  //    (hierfuer kommt neuer Code von Malta...)
  //---------------------------------------------------------
  if((Retcode = GetCWritePath(pExtStruc,ppPathBuf,pPathLen)) != HSSL_OP_OK)
  {
    FreeExtCertStruc(HMEM_CTX_REF1 pExtStruc);
    return(Retcode);
  }

  //---------------------------------------------------------
  // initialize the CryptoAPI and get API type
  //---------------------------------------------------------
  pApiType[0] = ICAD_NOCRYPAPI;  // = 0; see DefsMsCapi.h
  Retcode = HSSL_InitCryptoApiDll(pExtStruc, 0,
		ppPathBuf[0], 0, pPathLen[0],
		pCfgStruc->pExtConfigData, 0,
		pCfgStruc->ExtConfigDataLen,
		pApiType);
  if(Retcode != HSSL_OP_OK)
  {
    FreeExtCertStruc(HMEM_CTX_REF1 pExtStruc);
    return(HSSL_EXTCERT_INIT_LIBRARY_FAIL);
  }
  //--------------------------------------------------------
  // check nRetCode, if Crypto API type is ok
  //--------------------------------------------------------
  if(pApiType[0] != ICAD_MISOCRAPI)  // see DefsMsCapi.h
  {
    FreeExtCertStruc(HMEM_CTX_REF1 pExtStruc);
    return(HSSL_EXTCERT_INIT_INV_LIB_TYPE);
  }
  //--------------------------------------------------------
  // All o.k., Insert Extension Structure into configuration
  //--------------------------------------------------------
  pCfgStruc->pExtCertStruc = pExtStruc;
  return(HSSL_OP_OK);
}

//()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()
//
// Local Helper functions
//
//()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()

/**
* Convert internal Widestring to 'normal' character string, ASCIIz (FromStringArrayToJavaString).
*
*  @param pbySrcBuf Source data buffer
*  @param nSrcLen length of Data
*  @param ppbyDstBuf Allocated destination buffer
*  @return int DstLen, should be > 0 if o.k., without trailing NUL
*/
static  int  FromStringArrayToJavaString(HMEM_CTX_DEF
			char* pbySrcBuf,
			int nSrcLen, char** ppbyDstBuf)
{
  int nLen;
  int ni;
  int SrcIndex = 0;
  int pcTempChar;
  char* pbyDstBuf;

  if((pbySrcBuf == NULL) || (ppbyDstBuf == NULL))
    return(HSSL_NULL_PTR);
  ppbyDstBuf[0] = NULL;
  if(nSrcLen < 2)
    return(0);

  // extract the length from the first two bytes
  BIGchar2word(pbySrcBuf,nLen,SrcIndex);
  if(nLen <= 0)
    return(0);
  if(nLen > (nSrcLen-2))
    return(0);

  if((pbyDstBuf = BIT8_ARRAY_ALLOC(HMEM_CTX_REF,
				   nLen+1)) == NULL)
    return(HSSL_EXTCERT_ALLOC_ERR);

  for (ni = 0; ni < nLen; ni++)
  {
    BIGchar2word(pbySrcBuf,pcTempChar,SrcIndex);
    pbyDstBuf[ni] = (unsigned char) pcTempChar;
  }
  pbyDstBuf[ni] = 0;
  ppbyDstBuf[0] = pbyDstBuf;
  return(ni);
}

/**
* Get a description ASCIIz string for a certificate from the Subject's
* CommonName, Organization Name or E-mail Address from a certificate (GetSubjectItemName).
*
*  @param pCertStruc Certificate Structure
*  @param ppbyDstBuf Name buffer, allocated
*  @param pnDstLen size of name, excl. NUL
*  @return in Status - 0 o.k., else error occured
*/
static  int  GetSubjectItemName(HMEM_CTX_DEF
		X509CERT * pCertStruc,
		char** ppbyDstBuf, int* pnDstLen)
{
  int nLen;
  int nRetVal;
  int NameLen = 0;
  char* ppbyTmpBuf[1];

  IDATA* pIdata;
  IDATPARR* ppTmpDatArrayDesc[1];

  X501_DN* pSubjNameDesc;

  if((pCertStruc == NULL) || (ppbyDstBuf == NULL) ||
     (pnDstLen == NULL))
    return(HSSL_NULL_PTR);

  ppbyDstBuf[0] = NULL;
  pnDstLen[0] = 0;

  pSubjNameDesc = pCertStruc->Subject;

  nLen = pSubjNameDesc->Cnt;
  if(nLen > 0)
  {
    nRetVal = FromASN1_DN_ToStringArray(HMEM_CTX_REF1 pSubjNameDesc,ppTmpDatArrayDesc);

    if(nRetVal == ASN1_OP_OK)		 // == 0
    {
      nLen = ppTmpDatArrayDesc[0]->Cnt;	// c = Cnt
      if (nLen > RDN_COMMON_NAME_INDEX)
      {
        pIdata =
          ppTmpDatArrayDesc[0]->ppArr[RDN_COMMON_NAME_INDEX];
        if(pIdata->Len > 0)
        {
          NameLen = FromStringArrayToJavaString(HMEM_CTX_REF1
				pIdata->Base,
				pIdata->Len,ppbyTmpBuf);
        }
      }
      if(NameLen <= 0)
      {
        if(nLen > RDN_ORGANIZATION_NAME_INDEX)
        {
          pIdata =
            ppTmpDatArrayDesc[0]->ppArr[RDN_ORGANIZATION_NAME_INDEX];
          if(pIdata->Len > 0)
          {
            NameLen = FromStringArrayToJavaString(HMEM_CTX_REF1
				pIdata->Base,
				pIdata->Len,ppbyTmpBuf);
          }
        }
      }
      if(NameLen <= 0)
      {
        if(nLen > RDN_PKCS9_EMAIL_ADDRESS_INDEX)
        {
          pIdata =
            ppTmpDatArrayDesc[0]->ppArr[RDN_PKCS9_EMAIL_ADDRESS_INDEX];
          if(pIdata->Len > 0)
          {
            NameLen = FromStringArrayToJavaString(HMEM_CTX_REF1
				pIdata->Base,
				pIdata->Len,ppbyTmpBuf);
          }
        }
      }
    }
  }

  if(NameLen <= 0)
  {
    NameLen = 0;
    if((ppbyTmpBuf[0] = BIT8_ARRAY_ALLOC(HMEM_CTX_REF,
					 1)) == NULL)
      return(HSSL_EXTCERT_ALLOC_ERR);
    ppbyTmpBuf[0][0] = 0;
  }
  ppbyDstBuf[0] = ppbyTmpBuf[0];
  pnDstLen[0] = NameLen;
  return(HSSL_OP_OK);
}

/**
* Construct a unique alias name for a Certificate from
* e.g. Common Name, CertStore ID, Cert ID, Processing ID (GetAliasName).
* NOTE: Integers supplied with a negative value are ignored !
* -----
*
*  @param pszCertName Name from Cert, ASCIIz
*  @param CertNameLen length excl. NUL
*  @param CertStoreID Storage ID / -1
*  @param CertID Certificate ID / -1
*  @param ProcessingID Loop Index / -1
*  @param ppbyDstBuf Name buffer, allocated
*  @param pnDstLen size of name, excl. NUL
*  @return in Status - 0 o.k., else error occured
*/
static  int  GetAliasName(HMEM_CTX_DEF
	char* pszCertName, int CertNameLen,
	int CertStoreID, int CertID, int ProcessingID,
	char** ppbyDstBuf, int* pnDstLen)
{
  int NameLen;
  int SeparatorFlag = 0;
  char* pbyDstBuf;

  char pNumBuf[32];

  if((pszCertName == NULL) || (ppbyDstBuf == NULL) ||
     (pnDstLen == NULL))
    return(HSSL_NULL_PTR);
  if((CertNameLen < 0) ||
     ((CertStoreID < 0) && (CertID < 0) && (ProcessingID < 0)))
    return(HSSL_EXTCERT_PARAM_ERR);

  ppbyDstBuf[0] = NULL;
  pnDstLen[0] = 0;

  if((pbyDstBuf = BIT8_ARRAY_ALLOC(HMEM_CTX_REF,
			CertNameLen+(3*16)+4)) == NULL)
    return(HSSL_EXTCERT_ALLOC_ERR);
  pbyDstBuf[0] = 0;

  if(CertNameLen > 0)
  {
    strcpy(pbyDstBuf,pszCertName);
    strcat(pbyDstBuf," : ");
  }
  if(CertStoreID >= 0)
  {
    itoa(CertStoreID,pNumBuf,10);
    strcat(pbyDstBuf,pNumBuf);
    SeparatorFlag = 1;
  }
  if(CertID >= 0)
  {
    if(SeparatorFlag != 0)
      strcat(pbyDstBuf," ");
    itoa(CertID,pNumBuf,10);
    strcat(pbyDstBuf,pNumBuf);
    SeparatorFlag = 1;
  }
  if(ProcessingID >= 0)
  {
    if(SeparatorFlag != 0)
      strcat(pbyDstBuf," ");
    itoa(ProcessingID,pNumBuf,10);
    strcat(pbyDstBuf,pNumBuf);
  }
  NameLen = (int) strlen(pbyDstBuf);

  ppbyDstBuf[0] = pbyDstBuf;
  pnDstLen[0]   = NameLen;
  return(HSSL_OP_OK);
}

//()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()
//
// HSSL Helper functions for external certificates / signing
//
//()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()

/**
* Fetches a client certificate database, encoded like a CDB file.
* The returned CDB data contain the client certificate tree found
* in the certificate store(s) on the client operating system.
* The certificates are read from this external store using the  
* applied Crypto Interface.
* All end certificates have a private key which can be accessed 
* via the Crypto Interface.
* The flag IBM_Cont_Flag_Ext_Priv_Key is set in the ModeFlags of
* the IBM-Container of the end certificate which has a private key.
*
* 
*  @param pExtStruc DLL interface structure
*  @param ppbyCertsDataBuf Generated certificate database buffer
*  @param pnCertsDataLen Length of CDB data
*  @param ppbyCertsPwdBuf Password base
*  @param pnCertsPwdLen Password length
*  @param pnCertsPwdType = 0 - pure password
*
*  @return == 0 - function completed without errors
* <br>            > 0 - warning status, value represents a reason code
* <br>            < 0 - error occured, value represents a reason code
*/
extern "C"  int  HSSL_CreateExtStoreCertTree(HMEM_CTX_DEF
		HEXTCST * pExtStruc,
		char** ppbyCertsDataBuf, int* pnCertsDataLen,
		char** ppbyCertsPwdBuf,  int* pnCertsPwdLen,
		int* pnCertsPwdType)
{
  int		ni, nj, nk;
  int		nMode, bCertIsRoot;
  int		nRetVal;

  int		nNmbOfCerts = 0;
  int		nMaxDataLen;
  int		nPrevCertIdSaver = -1;
  int		nPrevStoreIdSaver = -1;
  int		nMaxCertChainLen = 0;  // returned in pnMaxCCAllocLen[0]
  int		nOff;
  int		nModeFlags;
  int		nRootCaCmpVal  = 0;
  int		nCertNmbCmpVal = 0;
  int		nEntryCnt = 0;
  int		nLen;

  char*	pbyCD;
  int pnPrevCertID[1] = {0};
  int pnPrevStoreID[1] = {0};
  char* ppbyDestBuffer[1] = {NULL};
  int pTmpCnt[1];
  int pTmpLen[1];

  X509CERT * pCertStruc[1];		// x1 = X509CERT

  char* pbyContainerName = NULL;

  int* pnIndexArray = NULL;
  int* pnIndexTmp = NULL;

  CTREESTR * ppTmpTreeStruc[1];
  CTREESTR * pTreeStruc = NULL;

  int pnRetIntPtr[1];
  char* pszCertAliName = NULL;

  char* ppbyDstBuf[1];
  char* ppbyTmpBuf[1];

  IDATPARR* pAsn1ContDescTemp[1];
  IDATPARR* pNameDescTemp[1];

  IDATPARR* pi2Asn1ContDescArr = NULL;	// i2 = IDATPARR
  IDATPARR* pi2NameDescArr = NULL;		// i2 = IDATPARR

  IDATA* pIdata;

#define	TMP_PWD_LEN	3
  char pbyPwdArray[TMP_PWD_LEN] = { (unsigned char)'H', (unsigned char)'O', (unsigned char)'B' };

  for(;;)
  {
    ppbyDstBuf[0] = NULL;
    nMode = 0;  // see GETCLNCCAUTH_MODECOLL = 0x01 in DefsMsCapi.h
    do
    {
      // free buffer, if necessary
      FREE_ARRAY(HMEM_CTX_REF,ppbyDestBuffer[0]);

      pTmpCnt[0] = 0;
      pTmpLen[0] = 0;
      nRetVal = HSSL_GetClntCChainForAuthent(pExtStruc,
                       NULL, 0, 0,     // pbyRdnInput, nRdnDOffset, nRdnDLength
                       NULL, 0, 0,     // pbySigAlgInput, nSAlgDOffset, nSAlgDLength
                       NULL, 0, 0,     // pbySubjectSel, nSubSelOffset, nSubSelLength,
                       nMode,          // nOpMode
                       pnPrevCertID,   // pnPrevCertID
                       pnPrevStoreID,  // pnPrevStoreID
                       NULL,           // ppbyDestBuffer
                       pTmpCnt,		// pnNmbOfCerts
                       pTmpLen);	// pnMaxDataLen

      nNmbOfCerts = pTmpCnt[0];
      nMaxDataLen = pTmpLen[0];

      // check returned parameters
      if (nRetVal < 0)
      {
        break;
      }
      if (((nNmbOfCerts < 0) || (nMaxDataLen < 0)) ||
          ((nNmbOfCerts > 0) && (nMaxDataLen <= 0)))
      {
        nRetVal = HSSL_EXTCERT_NO_CLNT_CHAIN_DATA;
        break;
      }

      if ((nNmbOfCerts == 0) || (nMaxDataLen == 0))
      {
        if ((pnPrevCertID[0] == nPrevCertIdSaver) &&
            (pnPrevStoreID[0] == nPrevStoreIdSaver))
        {
          // no more certificates available
		  break;
        }
        // no certificates found for current IDs
        nPrevCertIdSaver = pnPrevCertID[0];
        nPrevStoreIdSaver = pnPrevStoreID[0];
        continue;
      }

      // allocate buffer for certificate chain
      nj = ((nMaxDataLen + 3) & (~0x01));
      if((ppbyDestBuffer[0] = BIT8_ARRAY_ALLOC(HMEM_CTX_REF,
					nj)) == NULL)
      {
        nRetVal = HSSL_EXTCERT_ALLOC_ERR;
        break;
      }

      // set relevant variables
      // the following resolves to: MAX(nj, nMaxCertChainLen)
      nMaxCertChainLen = (nMaxCertChainLen > nj) ? nMaxCertChainLen : nj;

      nPrevCertIdSaver = pnPrevCertID[0];
      nPrevStoreIdSaver = pnPrevStoreID[0];

      // get the data
      pTmpCnt[0] = 0;
      pTmpLen[0] = nj;
      nRetVal = HSSL_GetClntCChainForAuthent(pExtStruc,
                      NULL, 0, 0,     // pbyRdnInput, nRdnDOffset, nRdnDLength
                      NULL, 0, 0,     // pbySigAlgInput, nSAlgDOffset, nSAlgDLength
                      NULL, 0, 0,     // pbySubjectSel, nSubSelOffset, nSubSelLength,
                      nMode,          // nOpMode
                      pnPrevCertID,   // pnPrevCertID
                      pnPrevStoreID,  // pnPrevStoreID
                      ppbyDestBuffer, // ppbyDestBuffer
                      pTmpCnt,		// pnNmbOfCerts
                      pTmpLen);		// pnMaxDataLen
      nNmbOfCerts = pTmpCnt[0];
      nMaxDataLen = pTmpLen[0];

      // check returned parameters
      if (nRetVal < 0)
      {
        break;
      }
      if((nNmbOfCerts <= 0) || (nMaxDataLen <= 0))
      {
        nRetVal = HSSL_EXTCERT_NO_CLNT_CHAIN_DATA;
        break;
      }

      // process the number of certs
      nRetVal = 0;
      pbyCD = ppbyDestBuffer[0];  // pbyCertData
      ni = nNmbOfCerts;
      while (ni > 0)
      {
        for (nj = 0, nLen = 0, nOff = 0; nj < ni; )
        {
          if ((nOff + 4) > nMaxDataLen)
          {
            nRetVal = HSSL_EXTCERT_INV_CCHAIN_DATALEN;
            break;  // too less data
          }
          BIGchar2long(pbyCD,nLen,nOff);	// get length, BIG Endian
//        for (nk = 0, nLen = 0; nk < 4; nk++)
//          nLen = ((nLen << 8) | (((int)pbyCD[nOff + nk]) & 0xFF));
//        nOff += 4;

          if ((nOff + nLen) > nMaxDataLen)
          {
            nRetVal = HSSL_EXTCERT_INV_CCHAIN_DATALEN;
            break;  // too less data
          }
          nj++;
          if (nj == ni)
            nRetVal = 1;  // take nLen data from pbyCD at nOff
          else
            nOff += nLen;
        } // end of for (nj = 0, nLen = 0, nOff = 0; nj < ni; )
        if (nRetVal < 0)
        {
          break;  // too less data
        }
        ni--;

        // convert the binary certificate to the internal X509 structure
        // Input: Base of Source buffer, Start of Data (Offset), Length of Data
        // Input: CertType, SortFlag (no RDN Sort), Password, Length of Password
        // Output: Pointer to Certificate
        nRetVal =FromASN1CertToCertStruc(HMEM_CTX_REF1 pbyCD,nOff,(int) nLen,0,1,NULL,0,pCertStruc);
        if(nRetVal != ASN1_OP_OK)
        {
          if(nRetVal < 0)  	// ignore the error and continue
            nRetVal = (-nRetVal);
          break;		// certificate not decoded
        }

        if((pCertStruc[0]->Flags & SELF_SIGNED_MASK) == 0)
          bCertIsRoot = 0;	// certificate is not a root certificate
        else
          bCertIsRoot = 1;	// certificate is a root certificate

        // check, if matching certificate already exists
        if(pTreeStruc != NULL)
        {
          // if serial number and issuer are equal in an existing certificate, 
          // the certificate is already in the database and can not be imported

          for (nj = 0; nj < pTreeStruc->CNodeCount; nj++)
          {
            pnRetIntPtr[0] = -1;
            nk = (nj * CNODE_SIZE);  // pTreeStruc.RootCaIndexArray[ni];
            nk = pTreeStruc->CNodeArray[nk + CN_CERTLIST_INDEX];  // pCn = CNodeArray
            nModeFlags = IDENTITY_MATCH;	// identity match mode
            if((bCertIsRoot != 0) &&
              ((pTreeStruc->ppCertList[nk]->Flags &
                SELF_SIGNED_MASK) != 0))
              nModeFlags = ROOT_MATCH;		// root match mode

            // compare certificates
            // input: certificate 1, certificate 2
            // input: matching rule
            // output: result of match
            nRetVal = MatchCerts(pCertStruc[0],pTreeStruc->ppCertList[nk],nModeFlags,pnRetIntPtr);
            if(nRetVal != ASN1_OP_OK)
            {
              break;
            }
            if(pnRetIntPtr[0] == ASN1_SAME)
              break;
          }
          if(nRetVal != ASN1_OP_OK)
          { // error
            break;
          }
          if(pnRetIntPtr[0] == ASN1_SAME)
          { // certificate already exists
            continue;
          }

          // save the total number of certificates and the number of root certificates in the tree
          // get the number of root certificates in the tree
          nRootCaCmpVal = pTreeStruc->RootCaCount;
          // get the total number of certificates in the tree
          nk = (pTreeStruc->RootCaCount +
                pTreeStruc->SubCaCount +
                pTreeStruc->EndRsaCount +
                pTreeStruc->EndDssCount +
                pTreeStruc->EndDhRsaCount +
                pTreeStruc->EndDhDssCount);
          nCertNmbCmpVal = nk;
        }

        // get any Certificate Subject item (Common Name) and form Alias Name
        nRetVal =  GetSubjectItemName(HMEM_CTX_REF1
				      pCertStruc[0],ppbyTmpBuf,pTmpLen);
        if(nRetVal < 0)
        {
          break;
        }
        nj = pTmpLen[0];
        pszCertAliName = ppbyTmpBuf[0];

        // use StoreID, CertID and index ni to get different names
        nRetVal = GetAliasName(HMEM_CTX_REF1
			pszCertAliName, nj,
			nPrevStoreIdSaver, nPrevCertIdSaver, ni,
			ppbyTmpBuf, pTmpLen);
        FREE_ARRAY(HMEM_CTX_REF,pszCertAliName);
        if(nRetVal < 0)
        {
          break;
        }
        pbyContainerName = ppbyTmpBuf[0];
        nj = pTmpLen[0];

        // generate an IBM container
        ppbyDstBuf[0] = NULL;
        pnRetIntPtr[0] = -1;  // used for destination 
        nModeFlags = IBM_CONT_FLAG_HOB_SW_USED |
                     IBM_CONT_FLAG_EXT_CERT;
//      nk = 1;
        nk = 3;					// always 3 used bits
        if (ni == 0)
        { // end certificate in progress
          nModeFlags |= IBM_CONT_FLAG_EXT_PRIV_KEY;
//        nk++;
        }
        
        // build an IBM container,
        // input: Sourcebuffer with certificate, Offset of data, data length
        // input: Container type = Standard Certificate, OrdinalNumber = next available
        // input: RSA private key, DSA private key, DH private key
        // input: PasswordBuffer, PasswordLength, public algorithm
        // input: PKCS5 iteration count, PKCS5 Hash
        // input: container name, container name length,
        // input: flags, used flagbits size
        // output: Destination buffer pointer, Length of DstBuf
        pIdata = pCertStruc[0]->Certificate->ppArr[0];

        nRetVal = GenIbmStdContainer(HMEM_CTX_REF1 pIdata->Base,(int) pIdata->Off,pIdata->Len,(int) (nEntryCnt + 1),pbyContainerName,nj,(int) nModeFlags,nk,ppbyDstBuf,pnRetIntPtr);
        if (nRetVal != ASN1_OP_OK)
        {
          break;
        }

        // generate the new container description array
        // input/output: IDATPARR array base
        // input: number of elements requested
        nRetVal = AllocIDATPARR_Struc(HMEM_CTX_REF1 pAsn1ContDescTemp,(nEntryCnt + 1));
        if (nRetVal != ASN1_OP_OK)
        {
          break;
        }

        // copy the existing container array entries

        if (pi2Asn1ContDescArr != NULL)
        {
          // input: IDATPARR source array base, source array index
          // input/output: IDATPARR destination array base, destination array index
          // input: number of elements, copy mode
          nRetVal =AllocCopyDatArrayToDatArray(HMEM_CTX_REF1 pi2Asn1ContDescArr,0,pAsn1ContDescTemp[0],0,nEntryCnt,0);
          if(nRetVal != ASN1_OP_OK)
          {
            break;
          }
        }

        // add the new certificate
        pIdata = pAsn1ContDescTemp[0]->ppArr[nEntryCnt];
        pIdata->Base = ppbyDstBuf[0];
        pIdata->Off  = 0;
        pIdata->Len  = pnRetIntPtr[0];

        // generate the new name description array
        // input/output: IDATPARR array base
        // input: number of elements requested
        nRetVal = AllocIDATPARR_Struc(HMEM_CTX_REF1 pNameDescTemp,(nEntryCnt + 1));
        if (nRetVal != ASN1_OP_OK)
        {
          break;
        }

        // copy the existing name array entries
        if (pi2NameDescArr != NULL)
        {
          // input: IDATPARR source array base, source array index
          // input/output: IDATPARR destination array base, destination array index
          // input: number of elements, copy mode
          nRetVal = AllocCopyDatArrayToDatArray(HMEM_CTX_REF1 pi2NameDescArr,0,pNameDescTemp[0],0,nEntryCnt,0);
          if(nRetVal != ASN1_OP_OK)
          {
            break;
          }
        }

        // add the new container alias name
        pIdata = pNameDescTemp[0]->ppArr[nEntryCnt];
        pIdata->Base = pbyContainerName;
        pIdata->Off  = 0;
        pIdata->Len  = nj;
        pbyContainerName = NULL;

        // generate the new index array
        if((pnIndexTmp = BIT32_ARRAY_ALLOC(HMEM_CTX_REF,
				nEntryCnt + 1)) == NULL)
        {
          nRetVal = HSSL_EXTCERT_ALLOC_ERR;
          break;
        }

        nj = 0;
        if(pnIndexArray != NULL)
        {
          for (; nj < nEntryCnt; nj++)
            pnIndexTmp[nj] = pnIndexArray[nj];
        }
        pnIndexTmp[nj] = (nEntryCnt + 1);

        ppTmpTreeStruc[0] = NULL;

        // generate the tree description
        // input: IDATPARR pCertsDatArrayDesc[] loaded descriptor
        // input: CertificateType, SortFlag (no RDN Sort), RequestEntity = client CDB
        // input: PasswordBuffer, PasswordLength
        // output: certificate tree structure description
        nRetVal = GenTreeFromASN1DatArrayDesc(HMEM_CTX_REF1 pAsn1ContDescTemp[0],2,1,1,pbyPwdArray,TMP_PWD_LEN,ppTmpTreeStruc);
        pTreeStruc = ppTmpTreeStruc[0];
        if(nRetVal != ASN1_OP_OK)
        { // error
          break;
        }

        // check, if the certificate has been added properly
        if (bCertIsRoot != 0)
        {
          if (pTreeStruc->RootCaCount <= nRootCaCmpVal)
          { // error: root certificate has not been added
            nRetVal = HSSL_EXTCERT_CCHAIN_ADDCERT_ERR;
            break;
          }
        }
        else
        {
          if (pTreeStruc->RootCaCount != nRootCaCmpVal)
          { // the number of root certs has changed, but no root has been added or removed
            nRetVal = HSSL_EXTCERT_CCHAIN_ADDCERT_ERR;
            break;
          }
        }

        // check the total number of certificates in the tree
        nk = (pTreeStruc->RootCaCount +
              pTreeStruc->SubCaCount +
              pTreeStruc->EndRsaCount +
              pTreeStruc->EndDssCount +
              pTreeStruc->EndDhRsaCount +
              pTreeStruc->EndDhDssCount);
        if (nk <= nCertNmbCmpVal)
        { // error: certificate has not been added
          nRetVal = HSSL_EXTCERT_CCHAIN_ADDCERT_ERR;
          break;
        }

        // free the old buffers before new pointers are set
        FreeIDATPARR_Struc(HMEM_CTX_REF1 pi2Asn1ContDescArr);
        pi2Asn1ContDescArr = NULL;
        FreeIDATPARR_Struc(HMEM_CTX_REF1 pi2NameDescArr);
        pi2NameDescArr = NULL;
        FREE_ARRAY(HMEM_CTX_REF,pnIndexArray);

        // set the changes to the local arrays
        pi2Asn1ContDescArr   = pAsn1ContDescTemp[0];
        pAsn1ContDescTemp[0] = NULL;

        pi2NameDescArr     = pNameDescTemp[0];
        pNameDescTemp[0]   = NULL; 

        pnIndexArray = pnIndexTmp;
        pnIndexTmp   = NULL;
        nEntryCnt++;
      } // end of while (ni > 0)

      if (nRetVal < 0)
      {
        break;
      }
    }
    while (nRetVal >= 0);
//    while ((nRetVal >= 0) && (nNmbOfCerts > 0));

    // free buffer, if necessary
    FREE_ARRAY(HMEM_CTX_REF,ppbyDestBuffer[0]);

    // check, if processing was ok
    if (nRetVal < 0)
    {
      break;
    }
    else			// nRetVal >= 0 !
    {
      if(nEntryCnt <= 0)
      {
        nRetVal = HSSL_EXTCERT_NO_CLNT_CERTS;
        break;
      }
    }

    // set up the returning arrays
    ppbyDstBuf[0] = NULL;
    pnRetIntPtr[0] = 0;

    // Generate certificate data ???
    // input: PasswordBuffer, PasswordOffset, PasswordLength
    // input: ExpireTime, FileType
    // input: Number of Containers, IndexArray
    // input: ASN1 ContainerDescriptionArray, AliasNameDescriptionArray
    // output: Destination buffer pointer, Length of DstBuf
    nRetVal = GenerateCertData(HMEM_CTX_REF1 pbyPwdArray,0,TMP_PWD_LEN,0,FILE_TYPE_CLNT_CERT,nEntryCnt,pnIndexArray,pi2Asn1ContDescArr,pi2NameDescArr,ppbyDstBuf,pnRetIntPtr);
    if (nRetVal < 0)
    {
      break;
    }

    break;
  } // end of for ( ; ; )

   // free buffers, if necessary
  if(pi2Asn1ContDescArr != NULL)
  {
    pi2Asn1ContDescArr->Flags |= FREE_BIT_MASK; // assure ELEMENT free
    FreeIDATPARR_Struc(HMEM_CTX_REF1 pi2Asn1ContDescArr);
  }
  if(pi2NameDescArr != NULL)
  {
    pi2NameDescArr->Flags |= FREE_BIT_MASK; // assure ELEMENT free
    FreeIDATPARR_Struc(HMEM_CTX_REF1 pi2NameDescArr);
  }
  FREE_ARRAY(HMEM_CTX_REF,pnIndexArray);
  FREE_ARRAY(HMEM_CTX_REF,pszCertAliName);
  FREE_ARRAY(HMEM_CTX_REF,pbyContainerName);

  // fill up return variables
  if (nRetVal >= 0)
  {
    if(ppbyCertsDataBuf != NULL)
    {
      ppbyCertsDataBuf[0] = ppbyDstBuf[0];
      ppbyDstBuf[0] = NULL;
    }
    else
    {
      FREE_ARRAY(HMEM_CTX_REF,ppbyDstBuf[0]);
    }

    if(pnCertsDataLen != NULL)
      pnCertsDataLen[0] = pnRetIntPtr[0];
    if(ppbyCertsPwdBuf != NULL)
    {
      ppbyCertsPwdBuf[0] = BIT8_ARRAY_ALLOC(HMEM_CTX_REF,
				TMP_PWD_LEN);
      if(ppbyCertsPwdBuf[0] != NULL)
        memcpy(ppbyCertsPwdBuf[0]+0,pbyPwdArray+0,TMP_PWD_LEN);
    }
    if(pnCertsPwdLen != NULL)
      pnCertsPwdLen[0] = TMP_PWD_LEN;
    if(pnCertsPwdType != NULL)
      pnCertsPwdType[0] = 0;

    // save maximal length of chain
    pExtStruc->MaxCCAllocLen = nMaxCertChainLen;
  }
  FREE_ARRAY(HMEM_CTX_REF,ppbyDstBuf[0]);
  return(nRetVal);
}

/**
* Generates an issuer certificate chain, formated as <code>CTREESTR</code>. 
* Beginning at the end certificate, provided by the certificate array, 
* the issuer certificate chain is build up from the certificates 
* found in the external store. If no suitable certificate is 
* found, the next certificate in the input array is used and 
* the search process starts again. If only a root is passed, 
* the root itself is returned.
*
* 
*  @param pExtStruc Extension Structure
*  @param pInpCertChain array of X509 structure certificates
*  @param nInpCertCount number of certificates in the array
*  @param pRetTreeStruc Pointer to generated certificate tree structure. 
*                       Will point to NULL, if no chain could be generated.
*
*  @return == 0 - function completed without errors
* <br>            > 0 - warning status, value represents a reason code
* <br>            < 0 - error occured, value represents a reason code
*/
extern "C"  int  HSSL_GetIssuerCertChainFromExt(HMEM_CTX_DEF
		HEXTCST * pExtStruc,
                X509CERT ** pInpCertChain, int nInpCertCount,
                CTREESTR ** pRetTreeStruc)
{
  int           nActCC;
  int           nRetVal;
  int           nOff;
  int           ni, nj, nk;
  int           bCertIsRoot;
  int           nRootCaCmpVal = 0;
  int           nCertNmbCmpVal = 0;
  int           nEntryCnt = 0;
  int           nNmbOfCerts = 0;
  int           nMaxDataLen;
  int         nLen;

  int pTmpCnt[1];
  int pTmpLen[1];
  int pnRetIntPtr[1];

  X509CERT * xActCert;		// x1 = X509CERT
  X509CERT * pCertStruc[1];		// x1 = X509CERT

  char* ppbyDestBuffer[1] = {NULL};

  CTREESTR * ppTmpTreeStruc[1];
  CTREESTR * pTreeStruc = NULL;

  char* pbyCD;
  char* pszCertAliName = NULL;
  char* pbyContainerName = NULL;

  int* pnIndexTmp = NULL;
  int* pnIndexArray = NULL;

  char* ppbyDstBuf[1];
  char* ppbyTmpBuf[1];

  IDATA* pIdata;

  IDATPARR* pi2Asn1ContDescArr = NULL;	// i2 = IDATPARR
  IDATPARR* pi2NameDescArr = NULL;		// i2 = IDATPARR

  IDATPARR* pAsn1ContDescTemp[1];
  IDATPARR* pNameDescTemp[1];

  char pbyPwdArray[TMP_PWD_LEN] = { (unsigned char)'H', (unsigned char)'O', (unsigned char)'B' };

  //------------------------------------------------------
  // check for NULL pointers
  //------------------------------------------------------
  if((pInpCertChain == NULL) || (pRetTreeStruc == NULL))
     return(HSSL_NULL_PTR);
  //------------------------------------------------------
  // check if at least 1 Certificate present
  //------------------------------------------------------
  if(nInpCertCount <= 0)
    return(HSSL_EXTCERT_NO_SRVR_CERT);

   // intialize return value
  pRetTreeStruc[0] = NULL;

  // intialize variables
  nActCC = nInpCertCount;
  nRetVal = 0;

  // process the number of input certificates
  do
  {
    nActCC--;
    xActCert = pInpCertChain[nActCC];

    // free buffer, if necessary
    FREE_ARRAY(HMEM_CTX_REF,ppbyDestBuffer[0]);

    pTmpCnt[0] = 0;
    pTmpLen[0] = 0;
    // try to find the issuer certificate of the current certificate
    pIdata = xActCert->Certificate->ppArr[0];
    nRetVal = HSSL_GetCChainForSrvrVerify(pExtStruc,
		pIdata->Base, (int) pIdata->Off, pIdata->Len,
                GETCERTCHAIN_FULLCERT,		//  (see DefMCapi.h)
                NULL,				// ppbyDestBuffer
                pTmpCnt,			// pnNmbOfCerts
                pTmpLen);			// pnMaxDataLen
    nNmbOfCerts = pTmpCnt[0];
    nMaxDataLen = pTmpLen[0];

    // return error 
    if (nRetVal < 0)
    {
      break;
    }

    // check next certificate in the input array, if nothing found
    if(nNmbOfCerts <= 0)
       continue;

    // allocate memory for returning data
    nMaxDataLen += 2;

    if((ppbyDestBuffer[0] = BIT8_ARRAY_ALLOC(HMEM_CTX_REF,
				nMaxDataLen)) == NULL)
    {
      nRetVal = HSSL_EXTCERT_ALLOC_ERR;
      break;
    }

    // get the data of the issuer certificate (chain) of the current certificate
    pTmpCnt[0] = 0;
    pTmpLen[0] = nMaxDataLen;
    pIdata = xActCert->Certificate->ppArr[0];
    //Input: pbyInputData, nDOffset, nDLength
    nRetVal = HSSL_GetCChainForSrvrVerify(pExtStruc,
		pIdata->Base, (int) pIdata->Off, pIdata->Len,
                GETCERTCHAIN_FULLCERT,		//  (see DefMCapi.h)
                ppbyDestBuffer,  // ppbyDestBuffer
                pTmpCnt,    // pnNmbOfCerts
                pTmpLen);   // pnMaxDataLen
    nNmbOfCerts = pTmpCnt[0];
    nMaxDataLen = pTmpLen[0];

    // return error
    if (nRetVal < 0)
    {
      break;
    }

    if ((nNmbOfCerts <= 0) || (nMaxDataLen <= 0))
    {
      nRetVal = HSSL_EXTCERT_NO_SRVR_CHAIN_DATA;
      break;
    }

    // process the number of certs
    nRetVal = 0;
    pbyCD = ppbyDestBuffer[0];  // pbyCertData
    ni = nNmbOfCerts;
    while (ni > 0)
    {
      for (nj = 0, nLen = 0, nOff = 0; nj < ni; )
      {
        if ((nOff + 4) > nMaxDataLen)
        {
          nRetVal = HSSL_EXTCERT_INV_SCHAIN_DATALEN;
          break;  // too less data
        }
        BIGchar2long(pbyCD,nLen,nOff);	// get length, BIG Endian
//      for (nk = 0, nLen = 0; nk < 4; nk++)
//         nLen = ((nLen << 8) | (((int)pbyCD[nOff + nk]) & 0xFF));
//      nOff += 4;

        if ((nOff + nLen) > nMaxDataLen)
        {
          nRetVal = HSSL_EXTCERT_INV_SCHAIN_DATALEN;
          break;  // too less data
        }
        nj++;
        if(nj == ni)
          nRetVal = 1;  // take nLen data from pbyCD at nOff
        else
          nOff += nLen;
      } // end of for (nj = 0, nLen = 0, nOff = 0; nj < ni; )

      if(nRetVal < 0)
      {
        break;  // too less data
      }
      ni--;

      // convert the binary certificate to the internal X509 structure
      // Input: Base of Source buffer, Start of Data (Offset), Length of Data
      // Input: CertType, SortFlag (no RDN Sort), Password, Length of Password
      // Output: Pointer to Certificate
      nRetVal = FromASN1CertToCertStruc(HMEM_CTX_REF1 pbyCD,nOff,(int) nLen,0,1,NULL,0,pCertStruc);
      if (nRetVal != ASN1_OP_OK)
      {
        break;  // certificate not decoded
      }

      if((pCertStruc[0]->Flags & SELF_SIGNED_MASK) == 0)
        bCertIsRoot = 0;  // certificate is not a root certificate
      else
        bCertIsRoot = 1;  // certificate is a root certificate

      // check, if matching certificate already exists
      if(pTreeStruc != NULL)
      {
        // save the total number of certificates and the number of root certificates in the tree
        // get the number of root certificates in the tree

        nRootCaCmpVal = pTreeStruc->RootCaCount;
        // get the total number of certificates in the tree
        nk = (pTreeStruc->RootCaCount +
              pTreeStruc->SubCaCount +
              pTreeStruc->EndRsaCount +
              pTreeStruc->EndDssCount +
              pTreeStruc->EndDhRsaCount +
              pTreeStruc->EndDhDssCount);
        nCertNmbCmpVal = nk;
      }

      // get any Certificate Subject item (Common Name) and form Alias Name

      nRetVal =  GetSubjectItemName(HMEM_CTX_REF1
				    pCertStruc[0],ppbyTmpBuf,pTmpLen);
      if(nRetVal < 0)
      {
        break;
      }
      nj = pTmpLen[0];
      pszCertAliName = ppbyTmpBuf[0];

      // use index ni to get different names
      nRetVal = GetAliasName(HMEM_CTX_REF1
			     pszCertAliName, nj,
			     -1, -1, ni,
			     ppbyTmpBuf, pTmpLen);
      FREE_ARRAY(HMEM_CTX_REF,pszCertAliName);
      if(nRetVal < 0)
      {
        break;
      }
      pbyContainerName = ppbyTmpBuf[0];
      nj = pTmpLen[0];

      // generate an IBM container
      ppbyDstBuf[0]  = NULL;
      pnRetIntPtr[0] = -1;  // used for destination 
      pIdata = pCertStruc[0]->Certificate->ppArr[0];

      // input: Sourcebuffer with certificate, Offset of data, data length
      // input: Container type = Standard Certificate, OrdinalNumber = next available
      // input: RSA private key, DSA private key, DH private key
      // input: PasswordBuffer, PasswordLength, public algorithm
      // input: PKCS5 iteration count, PKCS5 Hash
      // input: container name, container name length, flags, used flagbits size
      // output: Destination buffer pointer, Length of DstBuf
      nRetVal = GenIbmStdContainer(HMEM_CTX_REF1 
                                   pIdata->Base,
                                   (int) pIdata->Off,
                                   pIdata->Len,
                                   (nEntryCnt + 1),
                                   pbyContainerName,
                                   nj,
                                   IBM_CONT_FLAG_HOB_SW_USED | IBM_CONT_FLAG_EXT_CERT,
                                   3,
                                   ppbyDstBuf,
                                   pnRetIntPtr);
      if(nRetVal != ASN1_OP_OK)
      {
        break;
      }

      // generate the new container description array
      // input/output: IDATPARR array base
      // input: number of elements requested
      nRetVal = AllocIDATPARR_Struc(HMEM_CTX_REF1 pAsn1ContDescTemp,(nEntryCnt + 1));
      if (nRetVal != ASN1_OP_OK)
      {
        break;
      }

      // copy the existing container array entries
      if (pi2Asn1ContDescArr != NULL)
      {
        // input: IDATPARR source array base, source array index
        // input/output: IDATPARR destination array base, destination array index
        // input: number of elements, copy mode
        nRetVal = AllocCopyDatArrayToDatArray(HMEM_CTX_REF1 pi2Asn1ContDescArr,0,pAsn1ContDescTemp[0],0,nEntryCnt,0);
        if(nRetVal != ASN1_OP_OK)
        {
          break;
        }
      }

         // add the new certificate
      pIdata = pAsn1ContDescTemp[0]->ppArr[nEntryCnt];
      pIdata->Base = ppbyDstBuf[0];
      pIdata->Off  = 0;
      pIdata->Len  = pnRetIntPtr[0];

      // generate the new name description array
      // input/output: IDATPARR array base
      // input: number of elements requested
      nRetVal = AllocIDATPARR_Struc(HMEM_CTX_REF1 pNameDescTemp,(nEntryCnt + 1));
      if(nRetVal != ASN1_OP_OK)
      {
        break;
      }

      // copy the existing name array entries
      if (pi2NameDescArr != NULL)
      {
        // input: IDATPARR source array base, source array index
        // input/output: IDATPARR destination array base, destination array index
        // input: number of elements, copy mode
        nRetVal = AllocCopyDatArrayToDatArray(HMEM_CTX_REF1 pi2NameDescArr,0,pNameDescTemp[0],0,nEntryCnt,0);
        if(nRetVal != ASN1_OP_OK)
        {
          break;
        }
      }

      // add the new container alias name
      pIdata = pNameDescTemp[0]->ppArr[nEntryCnt];

      pIdata->Base = pbyContainerName;
      pIdata->Off  = 0;
      pIdata->Len  = nj;
      pbyContainerName = NULL;

      // generate the new index array
      if((pnIndexTmp = BIT32_ARRAY_ALLOC(HMEM_CTX_REF,
				nEntryCnt + 1)) == NULL)
      {
        nRetVal = HSSL_EXTCERT_ALLOC_ERR;
        break;
      }

      nj = 0;
      if(pnIndexArray != NULL)
      {
        for ( ; nj < nEntryCnt; nj++)
          pnIndexTmp[nj] = pnIndexArray[nj];
      }
      pnIndexTmp[nj] = (nEntryCnt + 1);
      pTreeStruc = NULL;

      // generate the tree description
      // input: IDATPARR pCertsDatArrayDesc[] loaded descriptor
      // input: CertificateType, SortFlag (no RDN Sort), RequestEntity = client CDB
      // input: PasswordBuffer, PasswordLength
      // output: certificate tree structure description
      nRetVal = GenTreeFromASN1DatArrayDesc(HMEM_CTX_REF1 pAsn1ContDescTemp[0],2,1,1,pbyPwdArray,TMP_PWD_LEN,ppTmpTreeStruc);
      pTreeStruc = ppTmpTreeStruc[0];
      if(nRetVal != ASN1_OP_OK)
      { // error
        break;
      }

      // check, if the certificate has been added properly
      if(bCertIsRoot != 0)
      { // certificate is a root
        if(pTreeStruc->RootCaCount <= nRootCaCmpVal)
        { // error: root certificate has not been added
          nRetVal = HSSL_EXTCERT_SCHAIN_ADDCERT_ERR;
          break;
        }
      }
      else
      {
        if(pTreeStruc->RootCaCount != nRootCaCmpVal)
        { // the number of root certs has changed, but no root has been added or removed
          nRetVal = HSSL_EXTCERT_SCHAIN_ADDCERT_ERR;
          break;
        }
      }
      // check the total number of certificates in the tree
      nk = (pTreeStruc->RootCaCount +
            pTreeStruc->SubCaCount +
            pTreeStruc->EndRsaCount +
            pTreeStruc->EndDssCount +
            pTreeStruc->EndDhRsaCount +
            pTreeStruc->EndDhDssCount);
      if(nk <= nCertNmbCmpVal)
      { // error: certificate has not been added
        nRetVal = HSSL_EXTCERT_SCHAIN_ADDCERT_ERR;
        break;
      }

      // free the old buffers before new pointers are set
      FreeIDATPARR_Struc(HMEM_CTX_REF1 pi2Asn1ContDescArr);
      pi2Asn1ContDescArr = NULL;
      FreeIDATPARR_Struc(HMEM_CTX_REF1 pi2NameDescArr);
      pi2NameDescArr = NULL;
      FREE_ARRAY(HMEM_CTX_REF,pnIndexArray);

      // set the changes to the local arrays
      pi2Asn1ContDescArr   = pAsn1ContDescTemp[0];
      pAsn1ContDescTemp[0] = NULL;

      pi2NameDescArr     = pNameDescTemp[0];
      pNameDescTemp[0]   = NULL; 

      pnIndexArray = pnIndexTmp;
      pnIndexTmp   = NULL;

      nEntryCnt++;
    } // end of while (ni > 0)

    if(nRetVal < 0)
    {
      break;
    }
  }
  while(nActCC > 0);

  // free allocated buffer, if necessary
  FREE_ARRAY(HMEM_CTX_REF,ppbyDestBuffer[0]);

//*   ----------------------------------------
//*   --- use this code for debug purposes ---
     // set up the returning arrays

//    --- end of code for debug purposes --- */
//*   --------------------------------------

  // free the allocated buffers
  if(pi2Asn1ContDescArr != NULL)
  {
    pi2Asn1ContDescArr->Flags |= FREE_BIT_MASK; // assure ELEMENT free
    FreeIDATPARR_Struc(HMEM_CTX_REF1 pi2Asn1ContDescArr);
  }
  if(pi2NameDescArr != NULL)
  {
    pi2NameDescArr->Flags |= FREE_BIT_MASK; // assure ELEMENT free
    FreeIDATPARR_Struc(HMEM_CTX_REF1 pi2NameDescArr);
  }
  FREE_ARRAY(HMEM_CTX_REF,pnIndexArray);
  FREE_ARRAY(HMEM_CTX_REF,pszCertAliName);
  FREE_ARRAY(HMEM_CTX_REF,pbyContainerName);

  // set the return array for the tree structure, if successful
  if(nRetVal >= 0)
  {
    pRetTreeStruc[0] = pTreeStruc;
  }
  return(nRetVal);
}

/**
* Generate a DN Sequence from the associated X501 DN Structure
* with leading size (used for BLOB in the interface) (GenDNSequenceFromStruct).
*
* formerly 'getByteBufFromIdatparrArray'
*
*  @param pNameDescArr DN Structures array
*  @param nArrLen number of Elements used
*  @param ppbyReturnBuf allocated buffer with data
*  @param pnReturnLen size of data in buffer 
*  @return int Status - 0 o.k., else error occured
*/
static  int  GenDNSequenceFromStruct(HMEM_CTX_DEF
		X501_DN** pNameDescArr,
		int nArrLen, char** ppbyReturnBuf, int* pnReturnLen)
{
  int       ni;
  int       nCnt, nDC;
  int       nRetVal;
  int       nDataArLen = 0;

  int*    pnIdatPLen = NULL;
  int pnDstLen1[1];
  int pnDstLen2[1];

  char* pbyDataArr = NULL;

  char* ppbyDstBuf1[1] = {NULL};
  char* ppbyDstBuf2[1] = {NULL};

  // check return parameters

  if((ppbyReturnBuf == NULL) || (pnReturnLen == NULL))
    return(HSSL_NULL_PTR);

  if((pNameDescArr != NULL) && (nArrLen > 0))
  {
    nCnt = 0;  // count the number of bytes
    if((pnIdatPLen = INT_ARRAY_ALLOC(HMEM_CTX_REF,
			nArrLen)) == NULL)
      return(HSSL_EXTCERT_ALLOC_ERR);

    // count the length of each input item after conversion
    nRetVal = 0;
    for (ni = 0; ni < nArrLen; ni++)
    {
      nDC = 0;
      if(pNameDescArr[ni] != NULL)
      {
        nRetVal = ToASN1_DN(HMEM_CTX_REF1 pNameDescArr[ni],ppbyDstBuf1,pnDstLen1);
        if (nRetVal == ASN1_OP_OK)
        {
          nRetVal = ToASN1_Sequence(HMEM_CTX_REF1 ppbyDstBuf1[0],0,pnDstLen1[0],ppbyDstBuf2,pnDstLen2);
          if (nRetVal == ASN1_OP_OK)
          {
            nCnt += pnDstLen2[0];
            nDC += pnDstLen2[0];
          }
        }
        FREE_ARRAY(HMEM_CTX_REF,ppbyDstBuf1[0]);
        FREE_ARRAY(HMEM_CTX_REF,ppbyDstBuf2[0]);
      }
      pnIdatPLen[ni] = nDC;
    } // end of for

    nCnt += ((nArrLen << 2) + 16);

    // copy the bytes to a new array
    if((pbyDataArr = BIT8_ARRAY_ALLOC(HMEM_CTX_REF,
				nCnt)) == NULL)
    {
      FREE_ARRAY(HMEM_CTX_REF,pnIdatPLen);
      return(HSSL_EXTCERT_ALLOC_ERR);
    }

    nDataArLen = 0;
    for (ni = 0; ni < nArrLen; ni++)
    {
      if (pnIdatPLen[ni] > 0)
      {
        // add the length DWORD to the buffer, used for BLOB in interface
        long2char(pnIdatPLen[ni],pbyDataArr,nDataArLen);
//      for (nj = 0; nj < 4; nj++)
//      {
//        pbyDataArr[nDataArLen] =
//            (byte)((pnIdatPLen[ni] >> (nj << 3)) & 0xFF);
//        nDataArLen++;
//      }

        // add the RDN data to the buffer
//      nLC = IDATPARR_Cnt(pIdatpArr[ni]);
        nRetVal = ToASN1_DN(HMEM_CTX_REF1 pNameDescArr[ni],ppbyDstBuf1,pnDstLen1);
        if (nRetVal == ASN1_OP_OK)
        {
          nRetVal = ToASN1_Sequence(HMEM_CTX_REF1 ppbyDstBuf1[0],0,pnDstLen1[0],ppbyDstBuf2,pnDstLen2);
          if (nRetVal == ASN1_OP_OK)
          {
            memcpy(pbyDataArr+nDataArLen,ppbyDstBuf2[0]+0,pnDstLen2[0]);
            nDataArLen +=  pnDstLen2[0];
          }
        }
        FREE_ARRAY(HMEM_CTX_REF,ppbyDstBuf1[0]);
        FREE_ARRAY(HMEM_CTX_REF,ppbyDstBuf2[0]);
      } //end of if (pnIdatPLen[ni] > 0)
    } // end of for (ni = 0; ni < nArrLen; ni++)
  } // end of if ((pIdatpArr != NULL) && (nArrLen > 0))

  FREE_ARRAY(HMEM_CTX_REF,pnIdatPLen);

  // set the return pointer to the created values
  ppbyReturnBuf[0] = pbyDataArr;
  pnReturnLen[0] = nDataArLen;
  return(HSSL_OP_OK);
}

/**
* Searches a tree structure for a specific end certificate.
*
* NOTE: no check on pointers is done.
* 
*  @param pExtStruc Extension Structure
*  @param pTreeStruc Tree Structure
*  @param PublicAlgor Requested public algorithm
*  @param SignatAlgor Requested signat algorithm
*  @param ProcessFlags Special processing flags:
*               Bit 0: CR-API: 1 - Force dialog always
*               Bit 1: CR-API: 1 - Ignore IniFile
*               Bit 2: CR-API: 1 - Clear IniFile 
*               Bit 3-9 reserved
*               Bit 10: CrypAPI NoDialog
*               0 - normal dialog mode
*               1 - never show a dialog
*               Bit 11-31 reserved
*  @param pDNList List of DNs. Optional
*  @param DnCount Number of elements in DN list
*  @param pDHParams DH Parameters. Optional
*  @param pResult Return pointer for index into CNodeList, <0, if not found
*
*               The variable nMaxCCAllocLen is the last parameter in the
*               Extension Structure. It is needed for the interface call
*               to the function "GetClntCChainForAuthent". The value of
*               is returnde by createExtStoreCertTree.
*
*  @return == 0 - function completed without errors
* <br>            > 0 - warning status, value represents a reason code
* <br>            < 0 - error occured, value represents a reason code
*/

extern "C"  int  HSSL_GetSpecifEndCertFromListEx(HMEM_CTX_DEF
		HEXTCST * pExtStruc,
		CTREESTR * pTreeStruc,
                int PublicAlgor, int SignatAlgor, int ProcessFlags,
		X501_DN** pDNList, int DnCount,
	        IDATPARR* pDHParams,
                int* pResult)
{
  int	    nMaxCCAllocLen;
  int	    nSrcIndex, nDstIndex;
  int       ni, nj;
  int       nRetVal = 0;
  int       nTotCertsNmb;

  int       nActCNIndex;
  int       nCertIndex;
  int     nCnt;
  int*    pnCertIndexList = NULL;

  X509CERT * xActCert;			// x1 = X509CERT
  IDATPARR* DatArrayDesc;		// i2 = IDATPARR
  int       nCertIdxSaver;
  int       nResult;
  int       nIdx;
  X509CERT * xTstCert;			// x1 = X509CERT
  int pnTmpResult[1];
  char*   pbyRdnInput = NULL;
  int       nRdnDOffset;
  int       nRdnDLength;
  int       nSAlgDOffset;
  int       nSAlgDLength;
  char*   pbySubjSel = NULL;
  int       nSubSOffset;
  int       nSubSLength;
  int       nMode;
  char*   pbyTmpBuf;
  char*   pSrcBuf;
  char* ppbyDestBuffer[1] = {NULL};
  int pnNmbOfCerts[1];
  int pnMaxDataLen[1];
  int pnPrevCertID[1] = {0};
  int pnPrevStoreID[1] = {0};
  IDATA* pIdata;
//  IDATPARR_PPTR pSubjectDatArr = NULL;  // i2 = IDATPARR

  X501_DN** pSubjectNamesArr = NULL;

  char pbySigAlgInput[1];

  X501_DN* pIssuerNameDesc;

  //------------------------------------------------------------
  // Get Count and List pointer according to given Algors
  //------------------------------------------------------------
  pResult[0] = -1;  // not found

   // check the total number of certificates in the tree
  nTotCertsNmb = (pTreeStruc->RootCaCount +
                  pTreeStruc->SubCaCount +
                  pTreeStruc->EndRsaCount +
                  pTreeStruc->EndDssCount +
                  pTreeStruc->EndDhRsaCount +
                  pTreeStruc->EndDhDssCount);
  if(nTotCertsNmb <= 0)
  {
    nRetVal = HSSL_EXTCERT_GET_ECERT_NO_CERTS;
    return(nRetVal);
  }
  pnCertIndexList = INT_ARRAY_ALLOC(HMEM_CTX_REF,
			nTotCertsNmb);
  if (pnCertIndexList == NULL)
  {
    nRetVal = HSSL_EXTCERT_ALLOC_ERR;
    return(nRetVal);
  }

  // preselect the certificates and check the matching criteria
  for (nCnt = 0, nActCNIndex = 0; nCnt < nTotCertsNmb; nCnt++)
  {
    pnCertIndexList[nCnt] = -1;
    nCertIndex = pTreeStruc->CNodeArray[nActCNIndex + CN_CERTLIST_INDEX];
    xActCert = pTreeStruc->ppCertList[nCertIndex];  // pCl = ppCertList

    // check the certificate flags
    if ((xActCert->ContFlags & IBM_CONT_FLAG_EXT_PRIV_KEY) != 0)  // CFl = Certificate IBM Container Flags
    { // private key accessible from external store
      switch (PublicAlgor)
      { // check, if the requested algorithm equals the certificate algorithms
        case RSA_PUBLIC_ALGOR:  // = 0
          if(xActCert->PublicKeyType == RSA_PUBLIC_ALGOR)
             pnCertIndexList[nCnt] = nActCNIndex;
          break;

        case DSA_PUBLIC_ALGOR:  // = 2
          if(xActCert->PublicKeyType == DSA_PUBLIC_ALGOR)
             pnCertIndexList[nCnt] = nActCNIndex;
          break;

        case DH_PUBLIC_ALGOR:  // = 1
          if(xActCert->PublicKeyType == DH_PUBLIC_ALGOR)
          {
            switch (SignatAlgor)
            {
              case RSA_SIGNAT_ALGOR:  // = 0
                if(xActCert->SignatAlgor == RSA_SIGNAT_ALGOR)
                  pnCertIndexList[nCnt] = nActCNIndex;
                break;

              case DSA_SIGNAT_ALGOR:  // = 2
                if(xActCert->SignatAlgor == DSA_SIGNAT_ALGOR)
                  pnCertIndexList[nCnt] = nActCNIndex;
                break;

              case ANY_SIGNAT_ALGOR:  // = 1, either RSA/DSA
                if((xActCert->SignatAlgor == RSA_SIGNAT_ALGOR) ||
                   (xActCert->SignatAlgor == DSA_SIGNAT_ALGOR))
                  pnCertIndexList[nCnt] = nActCNIndex;
                break;

              default:
                break;
            }
          }
          break;

        default:
          break;
      } // end of switch (PublicAlgor)

      // Check if the Public Algorithm is DH and DH Params given
      if((PublicAlgor == DH_PUBLIC_ALGOR) &&  // = 1
         (pDHParams != NULL))
      {
        DatArrayDesc = xActCert->SubjPubKeyParVal;
        if(DatArrayDesc == NULL)
        {
          pnCertIndexList[nCnt] = -2;
          continue;
        }

        // check equality of special DH parameters
        for(;;)
        {
          nCertIdxSaver = pnCertIndexList[nCnt];
          pnCertIndexList[nCnt] = -4;
          // Prime P and Generator G must match
          nResult = MatchIDATPARRStrucs(DatArrayDesc,DH_ALG_PAR_P_INDEX,pDHParams,DH_ALG_PAR_P_INDEX,1);
          if(nResult != ASN1_OP_OK)
            break;

          nResult = MatchIDATPARRStrucs(DatArrayDesc,DH_ALG_PAR_G_INDEX,pDHParams,DH_ALG_PAR_G_INDEX,1);
          if(nResult != ASN1_OP_OK)
            break;

          // Public value Yc must be same or absent
          nResult =MatchIDATPARRStrucs(DatArrayDesc,DH_ALG_PAR_MAX_INDEX+DH_PUB_VAL_Y_INDEX,pDHParams,DH_ALG_PAR_MAX_INDEX+DH_PUB_VAL_Y_INDEX,1);
          if(nResult != ASN1_OP_OK)
            break;
          pnCertIndexList[nCnt] = nCertIdxSaver;
          break;
        } // end of for ( ; ; )
      } // end of if ((PublicAlgor == DH_PUBLIC_ALGOR) && (pDHParams != NULL))

      // Check if there is a CA issuer name constraints list present
      if((pDNList != NULL) && (DnCount > 0))
      {
        nCertIdxSaver = pnCertIndexList[nCnt];
        pnCertIndexList[nCnt] = -3;
        // search for Root Certificate
        nIdx = nActCNIndex;
        for(;;)
        {
          if(pTreeStruc->CNodeArray[nIdx + CN_P_INDEX] == -1)
            break;  // no more parents, at the root
          // get index to Parent
          nIdx = pTreeStruc->CNodeArray[nIdx + CN_P_INDEX];
        }
        // get index to Cert List
        nCertIndex = pTreeStruc->CNodeArray[nIdx + CN_CERTLIST_INDEX];

        // get Root Certificate and issuer RDNs of trusted root
        xTstCert = pTreeStruc->ppCertList[nCertIndex];
//        pDatArray   = IDATPARR_ppArr(CERT_Issuer(xTstCert));
//        nCertRDNCnt = IDATPARR_Cnt(CERT_Issuer(xTstCert));
        pIssuerNameDesc = xTstCert->Issuer;

        pnTmpResult[0] = -1;
        nIdx = 0;
        nj = DnCount;  // use a local copy for RdnCount loop
        do
        { // here the passed RDNs are compared with the issuer RDNs
          // of the trusted root certs found on the system

          nRetVal = MatchX501_DNs(pIssuerNameDesc,pDNList[nIdx],pnTmpResult);
          nIdx++;

          if(nRetVal != ASN1_OP_OK)
          {
            // MUST FREE HERE !!!
            FREE_ARRAY(HMEM_CTX_REF,pnCertIndexList);
            return(nRetVal);
          }
          if(pnTmpResult[0] == ASN1_SAME)
            break;  // found match !
          nj--;
        }
        while(nj != 0);

        if(pnTmpResult[0] == ASN1_SAME)
          pnCertIndexList[nCnt] = nCertIdxSaver;
      } // end of if ((pRDNList != NULL) && (RdnCount > 0))
    } // end of if ((CERT_ContFlags(xActCert) & IBM_CONT_FLAG_EXT_PRIV_KEY) != 0)

    // increment index into CNODE list
    nActCNIndex += CNODE_SIZE;

  } // end of for (nCnt = 0, nActCNIndex = 0; nCnt < nTotCertsNmb; nCnt++)

  // check the found matches
  nIdx = -1;
  for(nCnt = 0, nActCNIndex = 0; nCnt < nTotCertsNmb; nCnt++)
  {
    if(pnCertIndexList[nCnt] >= 0)
    {
      nIdx = pnCertIndexList[nCnt];
      nActCNIndex++;
    }
  }

  // if only one certificate has been found, it is ok
  // NEW: only if FORCE DIALOG is NOT set
  if((nActCNIndex == 1) && 
     ((ProcessFlags & HSSL_EXT_CERTSEL_FORCE_DLG_BIT) == 0))
  {
    pResult[0] = nIdx;
  }

  // OLD: if there are more than 1 certificates, ask the Crypto API again
  // NEW: now also used if 1 certificate AND force Dialog is set !!
  else if(nActCNIndex >= 1)
  {
    for(;;)
    {
      pnMaxDataLen[0] = 0;

      // copy the RDN data to the buffer passed to the interface
      nRetVal = GenDNSequenceFromStruct(HMEM_CTX_REF1
				pDNList, DnCount,
                                ppbyDestBuffer, pnMaxDataLen);
      if(nRetVal != HSSL_OP_OK)
        break;

      pbyRdnInput = ppbyDestBuffer[0];
      nRdnDOffset = 0;
      nRdnDLength = DnCount;

      // copy the subject data of the valid certificates;
      // only those certificates which have been added to the
      // client certificate ppTreeStruc should be displayed
      // in the selection dialog of the Crypto-API
      ppbyDestBuffer[0] = NULL;
      pnMaxDataLen[0] = 0;

      // find the index of the certificate returned from the Crypto API
      for(nIdx = 0, nCnt = 0; nIdx < nTotCertsNmb; nIdx++)
      {
        if(pnCertIndexList[nIdx] >= 0)
          nCnt++;
      }

      pSubjectNamesArr = (X501_DN**)
	BIT8_ARRAY_CALLOC(HMEM_CTX_REF,1,(int) nCnt * sizeof(X501_DN*));
      if(pSubjectNamesArr == NULL)
      {
        nRetVal = HSSL_EXTCERT_ALLOC_ERR;
        break;
      }

      for (nIdx = 0, ni = 0; nIdx < nTotCertsNmb; nIdx++)
      {
        if (pnCertIndexList[nIdx] >= 0)
        {
          // get one certificate from the preselected list
          nCertIndex = pTreeStruc->CNodeArray[pnCertIndexList[nIdx] +
				                  CN_CERTLIST_INDEX];
          xActCert = pTreeStruc->ppCertList[nCertIndex];
          if(ni < (int) nCnt)
          {
            pSubjectNamesArr[ni] = xActCert->Subject;
            ni++;
          }
        }
      }
      nRetVal = GenDNSequenceFromStruct(HMEM_CTX_REF1
				pSubjectNamesArr, ni,
                                ppbyDestBuffer, pnMaxDataLen);
      if(nRetVal != HSSL_OP_OK)
        break;

      pbySubjSel = ppbyDestBuffer[0];
      nSubSOffset = 0;
      nSubSLength = ni;

      FREE_ARRAY(HMEM_CTX_REF,pSubjectNamesArr);
      pSubjectNamesArr = NULL;

      // set the input parameters
      nMode = GETCLNCCAUTH_MODECOLL;		// from DefMCapi.h

      if((ProcessFlags & HSSL_EXT_CERTSEL_FORCE_DLG_BIT) != 0)
        nMode |= GETCLNCCAUTH_SHOWSDLG;
      if((ProcessFlags & HSSL_EXT_CERTSEL_IGN_INIF_BIT) != 0)
        nMode |= GETCLNCCAUTH_IGNORPSC;
      if((ProcessFlags & HSSL_EXT_CERTSEL_CLR_INIF_BIT) != 0)
        nMode |= GETCLNCCAUTH_CLRCINIF;

      pbySigAlgInput[0] = (unsigned char)PublicAlgor;
      nSAlgDOffset = 0;
      nSAlgDLength = 1;

      // set the return parameters
      nMaxCCAllocLen = pExtStruc->MaxCCAllocLen;
      if(nMaxCCAllocLen <= 0)
        nMaxCCAllocLen = 2048;  // hope for the best
      nCnt = ((nMaxCCAllocLen + 32) & (~0x03));

      ppbyDestBuffer[0] = BIT8_ARRAY_ALLOC(HMEM_CTX_REF,
				(int) nCnt);
      if(ppbyDestBuffer[0] == NULL)
      {
        nRetVal = HSSL_EXTCERT_ALLOC_ERR;
        break;
      }

      pnMaxDataLen[0] = (int) nCnt;
      pnNmbOfCerts[0] = 0;

      if((ProcessFlags & HSSL_EXT_CERTSEL_NEVER_DLG_BIT) == 0)
      {
        nRetVal = HSSL_GetClntCChainForAuthent(pExtStruc,
                 pbyRdnInput, nRdnDOffset, nRdnDLength,      // pbyRdnInput, nRdnDOffset, nRdnDLength
                 pbySigAlgInput, nSAlgDOffset, nSAlgDLength, // pbySigAlgInput, nSAlgDOffset, nSAlgDLength
                 pbySubjSel, nSubSOffset, nSubSLength,       // pbySubjectSel, nSubSelOffset, nSubSelLength,
                 nMode,          // nOpMode
                 NULL,           // pnPrevCertID
                 NULL,           // pnPrevStoreID
                 ppbyDestBuffer, // ppbyDestBuffer
                 pnNmbOfCerts,   // pnNmbOfCerts
                 pnMaxDataLen);  // pnMaxDataLen
      }
      else // no dialog at all, take the first one !!!
      {
        nMode = 0;
        nRetVal = HSSL_GetClntCChainForAuthent(pExtStruc,
                 pbyRdnInput, nRdnDOffset, nRdnDLength,      // pbyRdnInput, nRdnDOffset, nRdnDLength
                 pbySigAlgInput, nSAlgDOffset, nSAlgDLength, // pbySigAlgInput, nSAlgDOffset, nSAlgDLength
                 pbySubjSel, nSubSOffset, nSubSLength,       // pbySubjectSel, nSubSelOffset, nSubSelLength,
                 nMode,          // nOpMode
                 pnPrevCertID,   // pnPrevCertID
                 pnPrevStoreID,  // pnPrevStoreID
                 ppbyDestBuffer, // ppbyDestBuffer
                 pnNmbOfCerts,   // pnNmbOfCerts
                 pnMaxDataLen);  // pnMaxDataLen
      }

      // check returned parameters
      if (nRetVal < 0)
      {
        break;
      }
      if(((pnNmbOfCerts[0] < 0) || (pnMaxDataLen[0] < 0)) ||
          ((pnNmbOfCerts[0] > 0) && (pnMaxDataLen[0] <= 0)))
      {
        nRetVal = HSSL_EXTCERT_GET_ECERT_NO_DATA;
        break;
      }

      // get the length of the selected end certificate
      nCnt = 0;
      pbyTmpBuf = ppbyDestBuffer[0];
      if (pnMaxDataLen[0] > 4)
      { // the length of the certificate is stored in the first 4 bytes
        // of the returned buffer and is copied to nCnt
        BIGchar2longn(pbyTmpBuf,nCnt,0);	// get length, BIG Endian
//      for (ni = 0;  ni < 4; ni++)
//        nCnt = ((nCnt << 8) | (((int)ppbyDestBuffer[0][ni]) & 0xFF));
      }

      // find the index of the certificate returned from the Crypto API
      for (nIdx = 0; nIdx < nTotCertsNmb; nIdx++)
      {
        if (pnCertIndexList[nIdx] >= 0)
        {
          // get one certificate from the preselected list
          nCertIndex = pTreeStruc->CNodeArray[pnCertIndexList[nIdx] +
                                                  CN_CERTLIST_INDEX];
          xActCert = pTreeStruc->ppCertList[nCertIndex];

          // compare the returned end certificate with the ones in the list
          pIdata = xActCert->Certificate->ppArr[0];
          if(pIdata->Len == (int) nCnt)
          {
            if((nCnt + 4) < pnMaxDataLen[0])  // avoid buffer overflow
            {
              nSrcIndex = (int) pIdata->Off;
              pSrcBuf  = pIdata->Base;
              nDstIndex = 4;  // 4 bytes length ahead (Blob)

              for(ni = 0, nj = 0; ni < (int) nCnt; ni++)
              {
                if(pSrcBuf[nSrcIndex++] != pbyTmpBuf[nDstIndex++])
                {
                  nj = -1;
                  break;
                }
              }
              if (nj == 0)
              {
                pResult[0] = pnCertIndexList[nIdx];
                break;
              }
            }
          }
        } // end of if (pnCertIndexList[nIdx] >= 0)
      } // end of for (nIdx = 0; nIdx < nTotCertsNmb; nIdx++)

      break;
    } // end of for ( ; ; )
  } // end of if (nActCNIndex > 1)

  // free allocated buffer, if necessary
  FREE_ARRAY(HMEM_CTX_REF,pnCertIndexList);
  FREE_ARRAY(HMEM_CTX_REF,pbyRdnInput);
  FREE_ARRAY(HMEM_CTX_REF,pbySubjSel);
  FREE_ARRAY(HMEM_CTX_REF,ppbyDestBuffer[0]);

  return(nRetVal);
}

/**
*  Support function for HSSL_GetSpecifEndCertFromListTLS12 (m_check_cert_sig_type).
*  This checks, if a certificate has a signature type from a given list.
*  
*  @param   abyp_target_cert  Pointer to the certificate, which is to be tested.
*  @param   abyp_sig_types    Array of signature types. First entry is the 
*                             number of signature types.
*
*  @return  1, if the certificate was signed with one of the signature types, 0
*           otherwise.
*/
static  int  m_check_cert_sig_type(X509CERT * abyp_target_cert, char* abyp_sig_types)
{
   int inl_sig_count = (int)abyp_sig_types[0]+1;
   while(--inl_sig_count > 0)
   {
      if (abyp_target_cert->SignatType == abyp_sig_types[inl_sig_count]){
         return 1;
      }
   }
   return 0;
}

/**
* Searches a tree structure for a specific end certificate.
* Basically same as HSSL_GetSpecifEndCertFromListEx, but takes a list of 
* allowed signature TYPES instead of one allowed signature ALGORITHM.
* The first byte of the list is the number of entries, excluding the length 
* byte.
*
* NOTE: no check on pointers is done.
*
*  @param   adsp_ext_c_struc  Extension Structure
*  @param   adsp_tree_struc   Tree Structure
*  @param   inp_public_alg    Requested public algorithm
*  @param   abyp_sig_types    List of requested signat types
*  @param inp_process_flags Special processing flags:
*               Bit 0: CR-API: 1 - Force dialog always
*               Bit 1: CR-API: 1 - Ignore IniFile
*               Bit 2: CR-API: 1 - Clear IniFile 
*               Bit 3-9 reserved
*               Bit 10: CrypAPI NoDialog
*               0 - normal dialog mode
*               1 - never show a dialog
*               Bit 11-31 reserved
*  @param aadsp_dn_list List of DNs. Optional
*  @param inp_dn_count Number of elements in DN list
*  @param adsp_dh_params DH Parameters. Optional
*  @param ainp_result Return pointer for index into CNodeList, <0, if not found
*
*  @return  0 on success, >0 on a warning, <0 on an error.
*/

extern "C"  int  HSSL_GetSpecifEndCertFromListTLS12(HMEM_CTX_DEF
                  HEXTCST * adsp_ext_c_struc, CTREESTR * adsp_tree_struc,
                  int inp_public_alg, char* abyp_sig_types, 
                  int inp_process_flags, X501_DN* aadsp_dn_list[], 
                  int inp_dn_count, IDATPARR* adsp_dh_params, 
                  int ainp_result[])
{
  int	    nMaxCCAllocLen;
  int	    nSrcIndex, nDstIndex;
  int       ni, nj;
  int       nRetVal = 0;
  int       nTotCertsNmb;

  int       nActCNIndex;
  int       nCertIndex;
  int     nCnt;
  int*    pnCertIndexList = NULL;

  X509CERT * xActCert;			// x1 = X509CERT
  IDATPARR* DatArrayDesc;		// i2 = IDATPARR
  int       nCertIdxSaver;
  int       nResult;
  int       nIdx;
  X509CERT * xTstCert;			// x1 = X509CERT
  int pnTmpResult[1];
  char*   pbyRdnInput = NULL;
  int       nRdnDOffset;
  int       nRdnDLength;
  int       nSAlgDOffset;
  int       nSAlgDLength;
  char*   pbySubjSel = NULL;
  int       nSubSOffset;
  int       nSubSLength;
  int       nMode;
  char*   pbyTmpBuf;
  char*   pSrcBuf;
  char* ppbyDestBuffer[1] = {NULL};
  int pnNmbOfCerts[1];
  int pnMaxDataLen[1];
  int pnPrevCertID[1] = {0};
  int pnPrevStoreID[1] = {0};
  IDATA* pIdata;
//  IDATPARR_PPTR pSubjectDatArr = NULL;  // i2 = IDATPARR

  X501_DN** pSubjectNamesArr = NULL;

  char pbySigAlgInput[1];

  X501_DN* pIssuerNameDesc;

  //------------------------------------------------------------
  // Get Count and List pointer according to given Algors
  //------------------------------------------------------------
  ainp_result[0] = -1;  // not found

   // check the total number of certificates in the tree
  nTotCertsNmb = (adsp_tree_struc->RootCaCount +
                  adsp_tree_struc->SubCaCount +
                  adsp_tree_struc->EndRsaCount +
                  adsp_tree_struc->EndDssCount +
                  adsp_tree_struc->EndDhRsaCount +
                  adsp_tree_struc->EndDhDssCount);
  if(nTotCertsNmb <= 0)
  {
    nRetVal = HSSL_EXTCERT_GET_ECERT_NO_CERTS;
    return(nRetVal);
  }
  pnCertIndexList = INT_ARRAY_ALLOC(HMEM_CTX_REF,
			nTotCertsNmb);
  if (pnCertIndexList == NULL)
  {
    nRetVal = HSSL_EXTCERT_ALLOC_ERR;
    return(nRetVal);
  }

  // preselect the certificates and check the matching criteria
  for (nCnt = 0, nActCNIndex = 0; nCnt < nTotCertsNmb; nCnt++)
  {
    pnCertIndexList[nCnt] = -1;
    nCertIndex = adsp_tree_struc->CNodeArray[nActCNIndex + CN_CERTLIST_INDEX];
    xActCert = adsp_tree_struc->ppCertList[nCertIndex];  // pCl = ppCertList

    // check the certificate flags
    if ((xActCert->ContFlags & IBM_CONT_FLAG_EXT_PRIV_KEY) != 0)  // CFl = Certificate IBM Container Flags
    { // private key accessible from external store
      switch (inp_public_alg)
      { // check, if the requested algorithm equals the certificate algorithms
        case RSA_PUBLIC_ALGOR:  // = 0
          if(xActCert->PublicKeyType == RSA_PUBLIC_ALGOR && 
             m_check_cert_sig_type(xActCert, abyp_sig_types) == 1)
             pnCertIndexList[nCnt] = nActCNIndex;
          break;

        case DSA_PUBLIC_ALGOR:  // = 2
          if(xActCert->PublicKeyType == DSA_PUBLIC_ALGOR && 
             m_check_cert_sig_type(xActCert, abyp_sig_types) == 1)
             pnCertIndexList[nCnt] = nActCNIndex;
          break;

        case DH_PUBLIC_ALGOR:  // = 1
          if(xActCert->PublicKeyType == DH_PUBLIC_ALGOR && 
             m_check_cert_sig_type(xActCert, abyp_sig_types) == 1)
          {
             pnCertIndexList[nCnt] = nActCNIndex;
          }
          break;

        default:
          break;
      } // end of switch (inp_public_alg)

      // Check if the Public Algorithm is DH and DH Params given
      if((inp_public_alg == DH_PUBLIC_ALGOR) &&  // = 1
         (adsp_dh_params != NULL))
      {
        DatArrayDesc = xActCert->SubjPubKeyParVal;
        if(DatArrayDesc == NULL)
        {
          pnCertIndexList[nCnt] = -2;
          continue;
        }

        // check equality of special DH parameters
        for(;;)
        {
          nCertIdxSaver = pnCertIndexList[nCnt];
          pnCertIndexList[nCnt] = -4;
          // Prime P and Generator G must match
          nResult = MatchIDATPARRStrucs(DatArrayDesc,DH_ALG_PAR_P_INDEX,adsp_dh_params,DH_ALG_PAR_P_INDEX,1);
          if(nResult != ASN1_OP_OK)
            break;

          nResult = MatchIDATPARRStrucs(DatArrayDesc,DH_ALG_PAR_G_INDEX,adsp_dh_params,DH_ALG_PAR_G_INDEX,1);
          if(nResult != ASN1_OP_OK)
            break;

          // Public value Yc must be same or absent
          nResult =MatchIDATPARRStrucs(DatArrayDesc,DH_ALG_PAR_MAX_INDEX+DH_PUB_VAL_Y_INDEX,adsp_dh_params,DH_ALG_PAR_MAX_INDEX+DH_PUB_VAL_Y_INDEX,1);
          if(nResult != ASN1_OP_OK)
            break;
          pnCertIndexList[nCnt] = nCertIdxSaver;
          break;
        } // end of for ( ; ; )
      } // end of if ((inp_public_alg == DH_PUBLIC_ALGOR) && (adsp_dh_params != NULL))

      // Check if there is a CA issuer name constraints list present
      if((aadsp_dn_list != NULL) && (inp_dn_count > 0))
      {
        nCertIdxSaver = pnCertIndexList[nCnt];
        pnCertIndexList[nCnt] = -3;
        // search for Root Certificate
        nIdx = nActCNIndex;
        for(;;)
        {
          if(adsp_tree_struc->CNodeArray[nIdx + CN_P_INDEX] == -1)
            break;  // no more parents, at the root
          // get index to Parent
          nIdx = adsp_tree_struc->CNodeArray[nIdx + CN_P_INDEX];
        }
        // get index to Cert List
        nCertIndex = adsp_tree_struc->CNodeArray[nIdx + CN_CERTLIST_INDEX];

        // get Root Certificate and issuer RDNs of trusted root
        xTstCert = adsp_tree_struc->ppCertList[nCertIndex];
//        pDatArray   = IDATPARR_ppArr(CERT_Issuer(xTstCert));
//        nCertRDNCnt = IDATPARR_Cnt(CERT_Issuer(xTstCert));
        pIssuerNameDesc = xTstCert->Issuer;

        pnTmpResult[0] = -1;
        nIdx = 0;
        nj = inp_dn_count;  // use a local copy for RdnCount loop
        do
        { // here the passed RDNs are compared with the issuer RDNs
          // of the trusted root certs found on the system

          nRetVal = MatchX501_DNs(pIssuerNameDesc,aadsp_dn_list[nIdx],pnTmpResult);
          nIdx++;

          if(nRetVal != ASN1_OP_OK)
          {
            // MUST FREE HERE !!!
            FREE_ARRAY(HMEM_CTX_REF,pnCertIndexList);
            return(nRetVal);
          }
          if(pnTmpResult[0] == ASN1_SAME)
            break;  // found match !
          nj--;
        }
        while(nj != 0);

        if(pnTmpResult[0] == ASN1_SAME)
          pnCertIndexList[nCnt] = nCertIdxSaver;
      } // end of if ((pRDNList != NULL) && (RdnCount > 0))
    } // end of if ((CERT_ContFlags(xActCert) & IBM_CONT_FLAG_EXT_PRIV_KEY) != 0)

    // increment index into CNODE list
    nActCNIndex += CNODE_SIZE;

  } // end of for (nCnt = 0, nActCNIndex = 0; nCnt < nTotCertsNmb; nCnt++)

  // check the found matches
  nIdx = -1;
  for(nCnt = 0, nActCNIndex = 0; nCnt < nTotCertsNmb; nCnt++)
  {
    if(pnCertIndexList[nCnt] >= 0)
    {
      nIdx = pnCertIndexList[nCnt];
      nActCNIndex++;
    }
  }

  // if only one certificate has been found, it is ok
  // NEW: only if FORCE DIALOG is NOT set
  if((nActCNIndex == 1) && 
     ((inp_process_flags & HSSL_EXT_CERTSEL_FORCE_DLG_BIT) == 0))
  {
    ainp_result[0] = nIdx;
  }

  // OLD: if there are more than 1 certificates, ask the Crypto API again
  // NEW: now also used if 1 certificate AND force Dialog is set !!
  else if(nActCNIndex >= 1)
  {
    for(;;)
    {
      pnMaxDataLen[0] = 0;

      // copy the RDN data to the buffer passed to the interface
      nRetVal = GenDNSequenceFromStruct(HMEM_CTX_REF1
				aadsp_dn_list, inp_dn_count,
                                ppbyDestBuffer, pnMaxDataLen);
      if(nRetVal != HSSL_OP_OK)
        break;

      pbyRdnInput = ppbyDestBuffer[0];
      nRdnDOffset = 0;
      nRdnDLength = inp_dn_count;

      // copy the subject data of the valid certificates;
      // only those certificates which have been added to the
      // client certificate ppTreeStruc should be displayed
      // in the selection dialog of the Crypto-API
      ppbyDestBuffer[0] = NULL;
      pnMaxDataLen[0] = 0;

      // find the index of the certificate returned from the Crypto API
      for(nIdx = 0, nCnt = 0; nIdx < nTotCertsNmb; nIdx++)
      {
        if(pnCertIndexList[nIdx] >= 0)
          nCnt++;
      }

      pSubjectNamesArr = (X501_DN**)
	BIT8_ARRAY_CALLOC(HMEM_CTX_REF,1,(int) nCnt * sizeof(X501_DN*));
      if(pSubjectNamesArr == NULL)
      {
        nRetVal = HSSL_EXTCERT_ALLOC_ERR;
        break;
      }

      for (nIdx = 0, ni = 0; nIdx < nTotCertsNmb; nIdx++)
      {
        if (pnCertIndexList[nIdx] >= 0)
        {
          // get one certificate from the preselected list
          nCertIndex = adsp_tree_struc->CNodeArray[pnCertIndexList[nIdx] +
				                  CN_CERTLIST_INDEX];
          xActCert = adsp_tree_struc->ppCertList[nCertIndex];
          if(ni < (int) nCnt)
          {
            pSubjectNamesArr[ni] = xActCert->Subject;
            ni++;
          }
        }
      }
      nRetVal = GenDNSequenceFromStruct(HMEM_CTX_REF1
				pSubjectNamesArr, ni,
                                ppbyDestBuffer, pnMaxDataLen);
      if(nRetVal != HSSL_OP_OK)
        break;

      pbySubjSel = ppbyDestBuffer[0];
      nSubSOffset = 0;
      nSubSLength = ni;

      FREE_ARRAY(HMEM_CTX_REF,pSubjectNamesArr);
      pSubjectNamesArr = NULL;

      // set the input parameters
      nMode = GETCLNCCAUTH_MODECOLL;		// from DefMCapi.h

      if((inp_process_flags & HSSL_EXT_CERTSEL_FORCE_DLG_BIT) != 0)
        nMode |= GETCLNCCAUTH_SHOWSDLG;
      if((inp_process_flags & HSSL_EXT_CERTSEL_IGN_INIF_BIT) != 0)
        nMode |= GETCLNCCAUTH_IGNORPSC;
      if((inp_process_flags & HSSL_EXT_CERTSEL_CLR_INIF_BIT) != 0)
        nMode |= GETCLNCCAUTH_CLRCINIF;

      pbySigAlgInput[0] = (unsigned char)inp_public_alg;
      nSAlgDOffset = 0;
      nSAlgDLength = 1;

      // set the return parameters
      nMaxCCAllocLen = adsp_ext_c_struc->MaxCCAllocLen;
      if(nMaxCCAllocLen <= 0)
        nMaxCCAllocLen = 2048;  // hope for the best
      nCnt = ((nMaxCCAllocLen + 32) & (~0x03));

      ppbyDestBuffer[0] = BIT8_ARRAY_ALLOC(HMEM_CTX_REF,
				(int) nCnt);
      if(ppbyDestBuffer[0] == NULL)
      {
        nRetVal = HSSL_EXTCERT_ALLOC_ERR;
        break;
      }

      pnMaxDataLen[0] = (int) nCnt;
      pnNmbOfCerts[0] = 0;

      if((inp_process_flags & HSSL_EXT_CERTSEL_NEVER_DLG_BIT) == 0)
      {
        nRetVal = HSSL_GetClntCChainForAuthent(adsp_ext_c_struc,
                 pbyRdnInput, nRdnDOffset, nRdnDLength,      // pbyRdnInput, nRdnDOffset, nRdnDLength
                 pbySigAlgInput, nSAlgDOffset, nSAlgDLength, // pbySigAlgInput, nSAlgDOffset, nSAlgDLength
                 pbySubjSel, nSubSOffset, nSubSLength,       // pbySubjectSel, nSubSelOffset, nSubSelLength,
                 nMode,          // nOpMode
                 NULL,           // pnPrevCertID
                 NULL,           // pnPrevStoreID
                 ppbyDestBuffer, // ppbyDestBuffer
                 pnNmbOfCerts,   // pnNmbOfCerts
                 pnMaxDataLen);  // pnMaxDataLen
      }
      else // no dialog at all, take the first one !!!
      {
        nMode = 0;
        nRetVal = HSSL_GetClntCChainForAuthent(adsp_ext_c_struc,
                 pbyRdnInput, nRdnDOffset, nRdnDLength,      // pbyRdnInput, nRdnDOffset, nRdnDLength
                 pbySigAlgInput, nSAlgDOffset, nSAlgDLength, // pbySigAlgInput, nSAlgDOffset, nSAlgDLength
                 pbySubjSel, nSubSOffset, nSubSLength,       // pbySubjectSel, nSubSelOffset, nSubSelLength,
                 nMode,          // nOpMode
                 pnPrevCertID,   // pnPrevCertID
                 pnPrevStoreID,  // pnPrevStoreID
                 ppbyDestBuffer, // ppbyDestBuffer
                 pnNmbOfCerts,   // pnNmbOfCerts
                 pnMaxDataLen);  // pnMaxDataLen
      }

      // check returned parameters
      if (nRetVal < 0)
      {
        break;
      }
      if(((pnNmbOfCerts[0] < 0) || (pnMaxDataLen[0] < 0)) ||
          ((pnNmbOfCerts[0] > 0) && (pnMaxDataLen[0] <= 0)))
      {
        nRetVal = HSSL_EXTCERT_GET_ECERT_NO_DATA;
        break;
      }

      // get the length of the selected end certificate
      nCnt = 0;
      pbyTmpBuf = ppbyDestBuffer[0];
      if (pnMaxDataLen[0] > 4)
      { // the length of the certificate is stored in the first 4 bytes
        // of the returned buffer and is copied to nCnt
        BIGchar2longn(pbyTmpBuf,nCnt,0);	// get length, BIG Endian
//      for (ni = 0;  ni < 4; ni++)
//        nCnt = ((nCnt << 8) | (((int)ppbyDestBuffer[0][ni]) & 0xFF));
      }

      // find the index of the certificate returned from the Crypto API
      for (nIdx = 0; nIdx < nTotCertsNmb; nIdx++)
      {
        if (pnCertIndexList[nIdx] >= 0)
        {
          // get one certificate from the preselected list
          nCertIndex = adsp_tree_struc->CNodeArray[pnCertIndexList[nIdx] +
                                                  CN_CERTLIST_INDEX];
          xActCert = adsp_tree_struc->ppCertList[nCertIndex];

          // compare the returned end certificate with the ones in the list
          pIdata = xActCert->Certificate->ppArr[0];
          if(pIdata->Len == (int) nCnt)
          {
            if((nCnt + 4) < pnMaxDataLen[0])  // avoid buffer overflow
            {
              nSrcIndex = (int) pIdata->Off;
              pSrcBuf  = pIdata->Base;
              nDstIndex = 4;  // 4 bytes length ahead (Blob)

              for(ni = 0, nj = 0; ni < (int) nCnt; ni++)
              {
                if(pSrcBuf[nSrcIndex++] != pbyTmpBuf[nDstIndex++])
                {
                  nj = -1;
                  break;
                }
              }
              if (nj == 0)
              {
                ainp_result[0] = pnCertIndexList[nIdx];
                break;
              }
            }
          }
        } // end of if (pnCertIndexList[nIdx] >= 0)
      } // end of for (nIdx = 0; nIdx < nTotCertsNmb; nIdx++)

      break;
    } // end of for ( ; ; )
  } // end of if (nActCNIndex > 1)

  // free allocated buffer, if necessary
  FREE_ARRAY(HMEM_CTX_REF,pnCertIndexList);
  FREE_ARRAY(HMEM_CTX_REF,pbyRdnInput);
  FREE_ARRAY(HMEM_CTX_REF,pbySubjSel);
  FREE_ARRAY(HMEM_CTX_REF,ppbyDestBuffer[0]);

  return(nRetVal);
}

/**
* Mirror a given buffer (MemRev).
*
*  @param pBuf Data buffer
*  @param Off Start of Data
*  @param Len length of data
*/
static  void  MemRev(char* pBuf, int Off, int Len)
{
  char c;
  int LowerIndex, UpperIndex;

  if((pBuf == NULL) || (Len <= 1))
    return;

  LowerIndex = Off;			// at start
  UpperIndex = Off + Len - 1;		// at End
  Len = Len/2;				// even count
  do
  {
    c = pBuf[LowerIndex];
    pBuf[LowerIndex++] = pBuf[UpperIndex];
    pBuf[UpperIndex--] = c;
    Len--;
  }while(Len > 0);
}

/**
* Encrypts a message block using the private key from an external Crypto API. 
*
* Note: When the cipherblock has the MSB bit set (BIG ENDIAN),
*   a leading zero is inserted in front of the cipher block,
*	 if requested.
*
*               Description of mode operation: (see DefsMsCapi.h for defines) <br>
*               Bits 0-3 - Type of Hash:
*               Use SIGDAPVKEY_HASHTYMASK to isolate bits. <br>
*               Possible values: <br>
*               SIGDAPVKEY_HASHTY_MD5 (0x02)
*               for MD5 (16 byte) <br>
*               SIGDAPVKEY_HASHTY_SHA (0x03)
*               for SHA1 (20 byte) <br>
*               SIGDAPVKEY_HASHTY_SSL (0x04)
*               for SSL3 SHA1 & MD5 (36 byte) <br>
*               other values: reserved.
*               Bits 4-7 - reserved <br>
*               Bit 8 - ASN1 encoded output
*               Use SIGDAPVKEY_ASN1_ENCOP to isolate, set or
*               check this bit. <br>
*               Bits 9-11 - reserved <br>
*               Bits 12-15 - usage prohibited <br>
*               Bits 16-31 - reserved
* 
*  @param pExtStruc Extension Structure
*  @param pbyInpBuf Message block ptr.
*  @param nInpOff Start of data
*  @param nInpLen Length of input data block
*  @param pbyDstBuf Encrypted output block ptr.
*  @param nDstOffset Start offset in output buffer
*  @param pnDstLen Size (in/out) in: available buffer size starting at offset
*  @param pbyCertData X509 certificate to be used for signing
*  @param nCertOffset Start of certificate data
*  @param nCertLen Length of certificate data
*  @param nCertPty Type of public key of certificate
*  @param nMode Mode of operation
*  @param nZeroFlag == 0 dont't insert zero <br>
*               != 0 insert zero if required
*
*  @return == 0 - function completed without errors
* <br>            > 0 - warning status, value represents a reason code
* <br>            < 0 - error occured, value represents a reason code
*/
extern "C"  int  HSSL_GenSignatWithExtPrivKey(HMEM_CTX_DEF
		HEXTCST * pExtStruc,
		char* pbyInpBuf, int nInpOff, int nInpLen,
                char* pbyDstBuf, int nDstOffset, int* pnDstLen,
                char* pbyCertData, int nCertOffset, int nCertLen,
                int nCertPty, int nMode, int nZeroFlag)
{
  int   nRetVal,BufLen,DstIndex;
  int	rLen,sLen;
  char* pSignBuf = NULL;
  char* ppbyDestBuffer[1];

  int pnMaxDataLen[1] = {0};
  char TmpDsaBuf[SHA_DIGEST_LEN*2];
  int      nRetLen;

  for (;;)
  {
    nRetVal = 0;

    // call SignDataWithCPrivKey to get length of return data
    nRetVal = HSSL_SignDataWithCPrivKey(pExtStruc,
                                   pbyCertData,   // pbyCertDInput
                                   nCertOffset,   // nCertDOffset
                                   nCertLen,      // nCertDLength
                                   pbyInpBuf,     // pbyDataInput,
                                   nInpOff,       // nDataOffset,
                                   nInpLen,       // nDataLength,
                                   nMode,         // nOpMode,
                                   NULL,          // ppbyDestBuffer
                                   pnMaxDataLen); // pnMaxDataLen

    if (nRetVal < 0)
    {
      break;
    }
    if (pnMaxDataLen[0] <= 0)
    {
      nRetVal = HSSL_EXTCERT_PRIV_SIGN_NO_DATA;
      break;
    }

    // -------------------------------------------------------------
    // check for correct destination buffer length
    // Needed sizes:
    // RSA: - without Zero-Insert mode: >= returned size
    //      - with    Zero-Insert mode: >= returned size+1
    // DSS: - without ASN.1 encoding: >= returned size
    //        with    ASN.1 encoding: >= returned size+8 (max. ASN1-Headers)
    // -------------------------------------------------------------
    BufLen = pnMaxDataLen[0];			// minimal size required
    if(nCertPty == RSA_PUBLIC_ALGOR)
    {
      if(nZeroFlag != 0)				// with leading Zero mode on
        BufLen++;					// one more byte ! 
    }
    else if(nCertPty == DSA_PUBLIC_ALGOR)
    {
      if((nMode & SIGDAPVKEY_ASN1_ENCOP) != 0)  // ASN.1 formatted
        BufLen += 8;
    }
    else
    {
      nRetVal = HSSL_EXTCERT_PSIGN_INV_SIGALGOR;
      break;
    }

    if(pnDstLen[0] < BufLen)			// buffer too small
    {
      nRetVal = HSSL_EXTCERT_PSIGN_BUF_TOOSMALL;
      break;
    }

    // -----------------------------------------------------------------
    // allocate memory for return data, round up to 4 byte,
    // in case of DSS with ASN.1 encoding mode, set temporary buffer (!)
    //------------------------------------------------------------------
    pnMaxDataLen[0] = ((BufLen+3)/4)*4;
    if((pSignBuf = BIT8_ARRAY_ALLOC(HMEM_CTX_REF,
			pnMaxDataLen[0])) == NULL)
    {
      nRetVal = HSSL_EXTCERT_ALLOC_ERR;
      break;
    }
    ppbyDestBuffer[0] = pSignBuf;

    if((nCertPty == DSA_PUBLIC_ALGOR) &&	// DSS signing
       ((nMode & SIGDAPVKEY_ASN1_ENCOP) != 0))	// ASN.1 formatted
    {
      ppbyDestBuffer[0] = TmpDsaBuf;
      pnMaxDataLen[0] = 2*SHA_DIGEST_LEN;	// Raw mode buffer
    }

    // call SignDataWithCPrivKey to do the signing
    nRetVal = HSSL_SignDataWithCPrivKey(pExtStruc,
                                    pbyCertData,     // pbyCertDInput
                                    nCertOffset,     // nCertDOffset
                                    nCertLen,        // nCertDLength
                                    pbyInpBuf,       // pbyDataInput,
                                    nInpOff,         // nDataOffset,
                                    nInpLen,         // nDataLength,
                                    nMode,           // nOpMode,
                                    ppbyDestBuffer,  // ppbyDestBuffer
                                    pnMaxDataLen);   // pnMaxDataLen

    if (nRetVal < 0)
    {
      break;
    }

    nRetLen  = pnMaxDataLen[0];
    if(nRetLen <= 0)
    {
      nRetVal = HSSL_EXTCERT_PRIV_SIGN_NO_DATA;
      break;
    }

    //-----------------------------------------------------------
    // Post process the returned data according to Algor and mode
    //-----------------------------------------------------------
    DstIndex = nDstOffset;
    if(nCertPty == RSA_PUBLIC_ALGOR)		// is RSA signing
    {
      // MSCAPI has a reversed byte order to HOB when RSA is used
      MemRev(ppbyDestBuffer[0], 0, pnMaxDataLen[0]);
      if((nZeroFlag != 0) && (ppbyDestBuffer[0][0] & 0x80) != 0)
      {
        pbyDstBuf[DstIndex++] = 0;		// set the leading zero
      }
      memcpy(pbyDstBuf+DstIndex,pSignBuf+0,nRetLen);
      DstIndex += nRetLen;
      pnDstLen[0] = DstIndex - nDstOffset;
      break;
    }
    else                                    	// must be DSS signing
    {
      if(nRetLen != (2*SHA_DIGEST_LEN))
      {
        nRetVal = HSSL_EXTCERT_PSIGN_INV_RETLEN;
        break;
      }
      // MSCAPI has a reversed byte order of each DSA parameter r and s
      MemRev(ppbyDestBuffer[0], 0, SHA_DIGEST_LEN);
      MemRev(ppbyDestBuffer[0], SHA_DIGEST_LEN, SHA_DIGEST_LEN);

      if((nMode & SIGDAPVKEY_ASN1_ENCOP) != 0)	// ASN.1 formatted !
      {
        // MSCAPI does not ASN.1 embed, must do that here !
        rLen = sLen = SHA_DIGEST_LEN;
        if((TmpDsaBuf[0] & 0x80) != 0)
          rLen++;
        if((TmpDsaBuf[SHA_DIGEST_LEN] & 0x80) != 0)
          sLen++;
        pbyDstBuf[DstIndex++] = (char) 0x30;		// ASN.1 Sequence
        pbyDstBuf[DstIndex++] = (char) (rLen+sLen+4);  // length of data
        pbyDstBuf[DstIndex++] = (char) 0x02;		// ASN.1 Integer
        pbyDstBuf[DstIndex++] = (char) rLen;		// length of r
        if(rLen != SHA_DIGEST_LEN)
          pbyDstBuf[DstIndex++] = 0;			// leading zero
        memcpy(pbyDstBuf+DstIndex,TmpDsaBuf+0,SHA_DIGEST_LEN);
        DstIndex += SHA_DIGEST_LEN;
        pbyDstBuf[DstIndex++] = (char) 0x02;		// ASN.1 Integer
        pbyDstBuf[DstIndex++] = (char) sLen;		// length of s
        if(sLen != SHA_DIGEST_LEN)
          pbyDstBuf[DstIndex++] = 0;			// leading zero
        memcpy(pbyDstBuf+DstIndex,TmpDsaBuf+SHA_DIGEST_LEN,SHA_DIGEST_LEN);
        DstIndex += SHA_DIGEST_LEN;
      }
      else						// not ASN.1 formatted
      {
        memcpy(pbyDstBuf+DstIndex,pSignBuf+0,2*SHA_DIGEST_LEN);
        DstIndex += 2 * SHA_DIGEST_LEN;
      }
    }
    pnDstLen[0] = DstIndex - nDstOffset;
    break;
  } // end of for ( ; ; )

  // free all memory, if necessary
  FREE_ARRAY(HMEM_CTX_REF,pSignBuf);

  return (nRetVal);
}

/**
* Removes certain entries from the External Certificate's .ini file.
* In case of external certificate used but not accepted.
*
*  @param pExtStruc Extension Structure
*  @return int Status - 0 o.k., else error occured
*/
extern "C"  int  HSSL_PurgeExtCertIniFile(HEXTCST * pExtStruc)
{
  return(HSSL_ForgetCertIniEntry(pExtStruc, 0));
}

/**
* Frees extension structure, unloads library and frees pointer array (FreeExtCertStruc).
*
*  @param pExtStruc Extension Structure
*/
extern "C"  void  FreeExtCertStruc(HMEM_CTX_DEF
					 HEXTCST * pExtStruc)
{
  if(pExtStruc != NULL)
  {
    if(pExtStruc->hExtCertLib != NULL)
    {
#if defined __VPN_INTERFACE__
      if(pExtStruc->pFunctPtrArr[CLEANUP_ENTRY_IND] != NULL)
        ((LPVpnCleanup)(pExtStruc->pFunctPtrArr[CLEANUP_ENTRY_IND]))();
#endif
      FreeLibrary(pExtStruc->hExtCertLib);
    }
    FREE_ARRAY(HMEM_CTX_REF,pExtStruc->pFunctPtrArr);
    FREE_ARRAY(HMEM_CTX_REF,pExtStruc);
  }
}
#else
//---------------------------------------------------------------------------------------------
// Functions for non-Windows systems
//---------------------------------------------------------------------------------------------

/**
* Initialization routine for MS-CAPI interface. Not supported by this plattform (HSSL_InitExtCertLib).
*
*  @param pCfgStruc Configuration Structure
*  @return int Status - 0 o.k., else error occured
*/
extern "C"  int  HSSL_InitExtCertLib(HMEM_CTX_DEF
					   CFG_STRU * , HINSTANCE)
{
  return(HSSL_EXTCERT_INTF_NOT_SUPPORTED);
}

/**
* Frees extension structure, unloads library and frees pointer array (FreeExtCertStruc).
*
*  @param pExtStruc Extension Structure
*/
extern "C"  void  FreeExtCertStruc(HMEM_CTX_DEF
					 HEXTCST * pExtStruc)
{
  if(pExtStruc != NULL)
  {
    FREE_ARRAY(HMEM_CTX_REF,pExtStruc);
  }
}

//()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()
//
// HSSL Helper functions for external certificates / signing
//
//()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()

/**
* Fetches a client certificate database, encoded like a CDB file.
* The returned CDB data contain the client certificate tree found
* in the certificate store(s) on the client operating system.
* The certificates are read from this external store using the  
* applied Crypto Interface.
* All end certificates have a private key which can be accessed 
* via the Crypto Interface.
* The flag IBM_Cont_Flag_Ext_Priv_Key is set in the ModeFlags of
* the IBM-Container of the end certificate which has a private key.
*
* 
*  @param pExtStruc DLL interface structure
*  @param ppbyCertsDataBuf Generated certificate database buffer
*  @param pnCertsDataLen Length of CDB data
*  @param ppbyCertsPwdBuf Password base
*  @param pnCertsPwdLen Password length
*  @param pnCertsPwdType = 0 - pure password
*
*  @return == 0 - function completed without errors
* <br>            > 0 - warning status, value represents a reason code
* <br>            < 0 - error occured, value represents a reason code
*/
extern "C"  int  HSSL_CreateExtStoreCertTree(HMEM_CTX_DEF
		HEXTCST * ,
		char** , int* ,
		char** , int* ,
		int* )
{
  return(HSSL_EXTCERT_INTF_NOT_LOADED_ER);
}

/**
* Generates an issuer certificate chain, formated as <code>CTREESTR</code>. 
* Beginning at the end certificate, provided by the certificate array, 
* the issuer certificate chain is build up from the certificates 
* found in the external store. If no suitable certificate is 
* found, the next certificate in the input array is used and 
* the search process starts again. If only a root is passed, 
* the root itself is returned.
*
* 
*  @param pExtStruc Extension Structure
*  @param pInpCertChain array of X509 structure certificates
*  @param nInpCertCount number of certificates in the array
*  @param pRetTreeStruc Pointer to generated certificate tree structure. 
*                       Will point to NULL, if no chain could be generated.
*
*  @return == 0 - function completed without errors
* <br>            > 0 - warning status, value represents a reason code
* <br>            < 0 - error occured, value represents a reason code
*/
extern "C"  int  HSSL_GetIssuerCertChainFromExt(HMEM_CTX_DEF
		HEXTCST * ,
                X509CERT ** , int ,
                CTREESTR ** )
{
  return(HSSL_EXTCERT_INTF_NOT_LOADED_ER);
}

/**
* Searches a tree structure for a specific end certificate.
*
* NOTE: no check on pointers is done.
* 
*  @param pExtStruc Extension Structure
*  @param pTreeStruc Tree Structure
*  @param PublicAlgor Requested public algorithm
*  @param SignatAlgor Requested signat algorithm
*  @param ProcessFlags Special processing flags:
*               Bit 0: CR-API: 1 - Force dialog always
*               Bit 1: CR-API: 1 - Ignore IniFile
*               Bit 2: CR-API: 1 - Clear IniFile 
*               Bit 3-9 reserved
*               Bit 10: CrypAPI NoDialog
*               0 - normal dialog mode
*               1 - never show a dialog
*               Bit 11-31 reserved
*  @param pDNList List of DNs. Optional
*  @param DnCount Number of elements in DN list
*  @param pDHParams DH Parameters. Optional
*  @param pResult Return pointer for index into CNodeList, <0, if not found
*
*               The variable nMaxCCAllocLen is the last parameter in the
*               Extension Structure. It is needed for the interface call
*               to the function "GetClntCChainForAuthent". The value of
*               is returnde by createExtStoreCertTree.
*
*  @return == 0 - function completed without errors
* <br>            > 0 - warning status, value represents a reason code
* <br>            < 0 - error occured, value represents a reason code
*/
extern "C"  int  HSSL_GetSpecifEndCertFromListEx(HMEM_CTX_DEF
                        HEXTCST * ,
                        CTREESTR * ,
                        int , int , int ,
                        X501_DN** , int ,
                        IDATPARR* ,
                        int* )
{
  return(HSSL_EXTCERT_INTF_NOT_LOADED_ER);
}

/**
* Searches a tree structure for a specific end certificate.
* Basically same as HSSL_GetSpecifEndCertFromListEx, but takes a list of 
* allowed signature TYPES instead of one allowed signature ALGORITHM.
* The first byte of the list is the number of entries, excluding the length 
* byte.
*
* NOTE: no check on pointers is done.
*
*  @param   adsp_ext_c_struc  Extension Structure
*  @param   adsp_tree_struc   Tree Structure
*  @param   inp_public_alg    Requested public algorithm
*  @param   abyp_sig_types    List of requested signat types
*  @param inp_process_flags Special processing flags:
*               Bit 0: CR-API: 1 - Force dialog always
*               Bit 1: CR-API: 1 - Ignore IniFile
*               Bit 2: CR-API: 1 - Clear IniFile 
*               Bit 3-9 reserved
*               Bit 10: CrypAPI NoDialog
*               0 - normal dialog mode
*               1 - never show a dialog
*               Bit 11-31 reserved
*  @param aadsp_dn_list List of DNs. Optional
*  @param inp_dn_count Number of elements in DN list
*  @param adsp_dh_params DH Parameters. Optional
*  @param ainp_result Return pointer for index into CNodeList, <0, if not found
*
*  @return  0 on success, >0 on a warning, <0 on an error.
*/
extern "C"  int  HSSL_GetSpecifEndCertFromListTLS12(HMEM_CTX_DEF
                  HEXTCST * , CTREESTR * ,
                  int , char* , 
                  int , X501_DN**, 
                  int , IDATPARR* , 
                  int*)
{
  return(HSSL_EXTCERT_INTF_NOT_LOADED_ER);
}

/**
* Encrypts a message block using the private key from an external Crypto API. 
*
* Note: When the cipherblock has the MSB bit set (BIG ENDIAN),
*   a leading zero is inserted in front of the cipher block,
*	 if requested.
*
*               Description of mode operation: (see DefsMsCapi.h for defines) <br>
*               Bits 0-3 - Type of Hash:
*               Use SIGDAPVKEY_HASHTYMASK to isolate bits. <br>
*               Possible values: <br>
*               SIGDAPVKEY_HASHTY_MD5 (0x02)
*               for MD5 (16 byte) <br>
*               SIGDAPVKEY_HASHTY_SHA (0x03)
*               for SHA1 (20 byte) <br>
*               SIGDAPVKEY_HASHTY_SSL (0x04)
*               for SSL3 SHA1 & MD5 (36 byte) <br>
*               other values: reserved.
*               Bits 4-7 - reserved <br>
*               Bit 8 - ASN1 encoded output
*               Use SIGDAPVKEY_ASN1_ENCOP to isolate, set or
*               check this bit. <br>
*               Bits 9-11 - reserved <br>
*               Bits 12-15 - usage prohibited <br>
*               Bits 16-31 - reserved
* 
*  @param pExtStruc Extension Structure
*  @param pbyInpBuf Message block ptr.
*  @param nInpOff Start of data
*  @param nInpLen Length of input data block
*  @param pbyDstBuf Encrypted output block ptr.
*  @param nDstOffset Start offset in output buffer
*  @param pnDstLen Size (in/out) in: available buffer size starting at offset
*  @param pbyCertData X509 certificate to be used for signing
*  @param nCertOffset Start of certificate data
*  @param nCertLen Length of certificate data
*  @param nCertPty Type of public key of certificate
*  @param nMode Mode of operation
*  @param nZeroFlag == 0 dont't insert zero <br>
*               != 0 insert zero if required
*
*  @return == 0 - function completed without errors
* <br>            > 0 - warning status, value represents a reason code
* <br>            < 0 - error occured, value represents a reason code
*/
extern "C"  int  HSSL_GenSignatWithExtPrivKey(HMEM_CTX_DEF
		HEXTCST * ,
		char* , int , int ,
                char* , int , int* ,
                char* , int , int ,
                int , int , int )
{
  return(HSSL_EXTCERT_INTF_NOT_LOADED_ER);
}

/**
* Removes certain entries from the External Certificate's .ini file.
* In case of external certificate used but not accepted.
*
*  @param pExtStruc Extension Structure
*  @return int Status - 0 o.k., else error occured
*/
extern "C"  int  HSSL_PurgeExtCertIniFile(HEXTCST * )
{
  return(HSSL_OP_OK);
}
#endif

//()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()
//()
//() VPN Specific functions....
//()
//()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()
#if defined __VPN_INTERFACE__

/**
* Load the Interface Libraries/Class, do *NOT* call the INIT-Function yet (HSSL_VPNPreInitExtCertLib).
*
* This is the main starter function which has to be called first to
* get access to external stores via the Crypto API DLLs (MS Win only).
*
*  @param hModuleInst Module Instance (C)
*  @param ppExtStruc Extension Structure returned
* 
*  @return int Status - 0 o.k., else error occured
*/
extern "C"  int  HSSL_VPNPreInitExtCertLib( HINSTANCE hModuleInst,
	HEXTCST ** ppExtStruc)
{
  int Retcode;
  HEXTCST * pExtStruc = NULL;
//  INTARRAY(pPathLen,1);
//  BIT8PTRARRAY(ppPathBuf,1);

  if(ppExtStruc == NULL)
  {
    return(HSSL_NULL_PTR);
  }
  ppExtStruc[0] = NULL;
  //---------------------------------------------------------
  // Allocate the extension structure needed
  //---------------------------------------------------------
  pExtStruc = (HEXTCST *)
    BIT8_ARRAY_CALLOC(HMEM_CTX_REF,1,sizeof(HEXTCST));
  if(pExtStruc == NULL)
    return(HSSL_EXTCERT_STRUC_ALLOC_FAILED);
  //---------------------------------------------------------
  // C: Load the DLL, get Function Pointers, Pre-Init Threads
  //---------------------------------------------------------
  if((Retcode = LoadExtClib(pExtStruc, hModuleInst)) != HSSL_OP_OK)
  {
    FREE_ARRAY(HMEM_CTX_REF,pExtStruc);
    return(Retcode);
  }
  ppExtStruc[0] =pExtStruc;
  return(HSSL_OP_OK);
}
/**
* Call the External Library Initialization function now (HSSL_VPNPostInitExtCertLib).
*
* 2nd part of initialization for the external library;
* requires connection to client is established !
*
*  @param pExtStruc Extension Structure
*  @param pAddDataBuf Additional data for Init
*  @param AddDataOff Start of data
*  @param AddDataLen Size of Data
*  @return int Status - 0 o.k., else errror occured
*/
extern "C"  int  HSSL_VPNPostInitExtCertLib(HEXTCST * pExtStruc,
	char* pAddDataBuf, int AddDataOff, int AddDataLen)
{
  int Retcode;
  int pApiType[1];
  //-------------------------------------------------------
  // Check parameters first
  //-------------------------------------------------------
  if(pExtStruc == NULL)
    return(HSSL_NULL_PTR);
  if(pExtStruc->IntfLoadedFlag == 0)
    return(HSSL_EXTCERT_INTF_NOT_LOADED_ER);
  //---------------------------------------------------------
  // initialize the CryptoAPI and get API type
  //---------------------------------------------------------
  pApiType[0] = ICAD_NOCRYPAPI;  // = 0; see DefsMsCapi.h
  Retcode = HSSL_InitCryptoApiDll(pExtStruc, 0,
		NULL, 0, 0,
		pAddDataBuf, AddDataOff, AddDataLen,
		pApiType);
  if(Retcode != HSSL_OP_OK)
  {
    return(HSSL_EXTCERT_INIT_LIBRARY_FAIL);
  }
  //--------------------------------------------------------
  // check nRetCode, if Crypto API type is ok
  //--------------------------------------------------------
  if(pApiType[0] != ICAD_MISOCRAPI)  // see DefsMsCapi.h
  {
    return(HSSL_EXTCERT_INIT_INV_LIB_TYPE);
  }
  //--------------------------------------------------------
  // All o.k., Insert Extension Structure into configuration
  //--------------------------------------------------------
  return(HSSL_OP_OK);
}

/**
* Check if the external interface library is ready to use
* (needed for VPN: Pre-Initialize the DLL, wait for connection
* from the client, initialize....) (HSSL_GetExtCertlibIntfStatus).
* If a wait time is specified, waits for connection to get established
*
*  @param pExtStruc Extension Structure
*  @param WaitTimeMillis Time to wait, 0-dont wait
*  @return int ConnectStatus < 0 Not initialized/Error
* <br>            == 0 initialized, no connection/timeout
* <br>            > 0 initialized and connected
*/
extern "C"  int  HSSL_GetExtCertlibIntfStatus(HEXTCST * pExtStruc,
		int WaitTimeMillis)
{
  int Retcode;
  //-------------------------------------------------------
  // Check parameters first
  //-------------------------------------------------------
  if(pExtStruc == NULL)
    return(HSSL_NULL_PTR);
  if(pExtStruc->IntfLoadedFlag == 0)
    return(HSSL_EXTCERT_INTF_NOT_LOADED_ER);
  //-------------------------------------------------------
  // Call the Interface Function
  //-------------------------------------------------------
  Retcode =
    ((LPVpnConnState)
     (pExtStruc->pFunctPtrArr[CONN_CHECK_ENTRY_IND]))(WaitTimeMillis);
  return(Retcode);
}
#endif // defined __VPN_INTERFACE__

/** @} */


#endif //HL_SSL_EXT_CERT
// end of file ../hssl/Hextcert.cpp


#ifdef HL_SSL_PROT_MAIN
/**
* @file
* Module for combined AES/SHA-1 processing in the WSP C interface for SSL.
* (Includes tester)
*
* NOTES: <ol>
* <li> AES/SHA-1 blocks are misaligned, so data processing will
*     perhaps not be speeded up much.
* <li> Complicates processing: <ul>
*	    <li> SHA-1 has 64 byte blocks, AES uses 16 byte blocks
*	    <li> SHA-1 blocks do not start on same boundary as AES blocks
*	      (difference: SSL 9/7 bytes, TLS 1.0 3/13 bytes)  </ul>
* <li> Combined hashing is NOT possible in AES-Decrypt mode as: <ul>
*	    <li> the hash includes the length of the data AFTER decryption
*	      without the padding and the hash itself.
*	      This length can not be calculated ahead as the padding
*	      length is the last byte of the decrypted record.
*	      As AES is used in CBC mode, the whole record data
*	      must have been decryted to get this value.
*	      It is NOT possible to prehash data ahead during AES
*	      decryption and then insert the netto data langth into
*	      the hash.  </ul>
* <li> Difficult to test all possible paths (various datalength)
*	      contrary to simple verification of AES module / SHA-1
*	      module as stand alone modules -> error prone !
*</ol>
* @todo Check this module, decide, which module it belongs to
*/
#if (defined _WIN32) & (_MSC_VER < 1700)
#ifndef _STDINT
#define _STDINT
// MSVC lower than 17.00 does not have stdint.h, assure, all needed types are defined

typedef unsigned __int16 uint16_t;

typedef unsigned __int32 uint32_t;

typedef unsigned __int64 uint64_t;

#endif // !_STDINT
#else
#include <stdint.h>
#endif
#include <stddef.h>
#ifdef _WIN32
#define WIN32_LEAN_AND_MEAN
#include <Windows.h>
#undef WIN32_LEAN_AND_MEAN
#else// Define system-specific HL_* defines here
#ifndef HL_UNIX
#define HL_UNIX

#if (defined __gnu_linux__) || (defined __linux__)
#define HL_LINUX
#endif

#if (defined __APPLE__) && (defined __MACH__)
#define HL_LINUX
#define HL_MACOS
#endif

#ifdef _AIX
#define HL_AIX
#define HL_BIG_ENDIAN
#endif

#ifdef __FreeBSD__
#define HL_FREEBSD
#endif

#if (defined _hpux) || (defined hpux) || (defined __hpux)
#define HL_HPUX
#define HL_BIG_ENDIAN
#endif

#if (defined sun) || (defined __sun)
#define HL_SOLARIS
#endif

#if (defined __arm__) || (defined __aarch64__)
#define HL_LINUX_ARM
#endif

#ifdef __ANDROID__
#define HL_ANDROID
#endif

#endif
#include <hob-unix01.h>
#endif
#ifdef __APPLE__
/* We get target conditionals to keep apart Mac OS, iOS and iOS simulator.
   The conditionals are TARGET_IPHONE_SIMULATOR, TARGET_OS_IPHONE and TARGET_OS_MAC.
   TARGET_IPHONE_SIMULATOR has the highest priority, TARGET_OS_MAC the lowest.
   Always test, if the conditional is 1, as they will be defined as 0, if we 
   are not compiling for the target.
   */
#include <TargetConditionals.h>
#endif

#ifdef HL_ANDROID
#include <sys/endian.h>
#endif

#include <string.h>
#include <stdlib.h>
#include "hob-encry-1.h"
#include "hob-cert-ext.h"
#if !(defined __HOB_XSCLIB01__) && !(defined DEF_IFUNC_START)
#define __HOB_XSCLIB01__

#include <hob-xsclib01.h>  
#endif // !__HOB_XSCLIB01__
#include <stdlib.h>
#include <hob-encry-2.h>
#include "hob-ssl-intern.h"
#include "hob-ssl-err.h"
#include "hob-encry-intern-1.h"

#if defined _WIN32
#if HOB_WIN64_ASM == 1
#pragma message("USING EM64T ASSEMBLER SOURCES")
#else
#pragma message("USING C SOURCES")
#endif
#endif // WIN32 || WIN64

/**
* @file
* Principles of operation:
*
* Combined processing should be possible for all SSL, TLS V1.0 and
* the new TLS V1.1 (to be published, currently an IETF draft).
*
*
* SHA-1 Precalculations
* =====================
* Two SHA-1 state arrays, the so called 'Inner' state array and
* the 'Outer' state array are precomputed with the MAC key data and
* PAD values. A copy of these state arrays is used for generating
* the SHA-1 record hashes.
*
* NOTE: Pre-Computation of the State arrays is different for SSL and TLS.
*
* Initial calculation of the SHA-1 state arrays
* ---------------------------------------------
*<ol>
*<li> Initialize the Inner and Outer state arrays (as already implemented).
*<li> Depending on Protocol:<ol>
*    <li> SSL:<ol>
*       <li> Store 20 byte from the MAC secret to both state arrays.
*       <li> Store 40 bytes padding PAD1 (0x36) past secret to Inner state array.
*       <li> Store 40 bytes padding PAD2 (0x5C) past secret to Outer state array. <ul>
*          <li> both state arrays contain now 60 byte of 'stored' data. </ul></ol>
*    <li> TLS V1.0:<ol>
*       <li> If key material size is > 64, first reduce key size using SHA-1.
*           If (resulting) key length is < 64 byte, pad the key with zero
*	         data bytes up to 64 bytes.
*       <li> Store 64 bytes of padded key Xor IPAD (0x36) to Inner state array
*	         Perform SHA-1 block operation on the Inner state array to generate
*	         next SHA-1 state, clear the 'stored' data count.
*       <li> Store 64 bytes of padded key Xor OPAD (0x5C) to Outer state array
*	         Perform SHA-1 block operation on the Outer state array to generate
*	         next SHA-1 state, clear the 'stored' data count. <ul>
*              <li> both state arrays now have NO data 'stored'. </ul>
*</ol></ol></ol>
*
* SHA-1 Record 'Pre-Hashing'
* ==========================
* Both with SSL and TLS a sequence number ( 8 byte) and portion/all of the
* 5 byte record header must be hashed before payload data hashing starts.
*
* This Pre-Hashing is different for SSL/TLS:<ol>
* <li> Get a copy of the Inner state array.
* <li> Hash the 8 byte sequence number.<ol>
*    <li> SSL: <ul>
*        <li> Copy 4 byte to end of state array buffer, array is now filled (64 byte).
*        <li> Apply SHA-1 round function to generate new state from the block.
*        <li> Copy 4 byte to start of state array buffer, set stored data count 
*           to 4.  </ul>
*    <li> TLS V1.0: <ul>
*        <li> Copy all 8 byte to the state array buffer, set stored data count 
*           to 8. </ul></ol>
* <li> Hash parts/full record header.<ol>
*    <li> SSL:  <ul>
*        <li> Copy 1 byte  RecordType to state array buffer.
*        <li> Copy 2 bytes RecordLen  to state array buffer.
*        <li> Add 3 to stored data count, makes a total of 7 bytes stored. </ul>
*    <li> TLS: <ul>
*        <li> Copy all 5 bytes of the Record header to state array buffer.
*        <li> Add 5 to stored data count, makes a total of 13 bytes stored. </ul>
*</ol></ol>
* Now the start position of the data that also have to be encrypted
* with AES in CBC mode is reached.
*
* NOTE: With TLS V1.1 there will be a 16 byte block inserted ahead
*       of the user data that serves as an 'additional' IV to XOR
*       the data following past that block (the negotiated IV is
*	 also supplied during Encryption!).
*	 This 16 byte block must be encrypted, but will NOT be hashed!
*
* Block alignement problem with AES/SHA-1 both SSL and TLS
* --------------------------------------------------------
* SHA-1 operates on 64 byte elements.
* For SSL there are already 7 bytes stored in the state buffer,
* in case of TLS there are already 13 byte stored in the state buffer.
* Therefore the AES and SHA-1 block boundaries will be different!
*
* Special considerations for AES-Encrypt
* --------------------------------------
*<ol>
*<li> The final SHA-1 hash for the record must have been stored to the
*    record buffer (20 byte, past data) when AES reaches this position.
*<li> The required block padding for the record and the padding length
*    byte must have been stored to the record buffer (1..16 bytes)
*    when the last AES block has to be processed.
*<li> Hashing must be done before (!) data is encrypted </ol>
*/
/**
* Subroutine IncSequenceNumber increments Sequence Number.
*
*  @param pSeqNumber Base of Sequence number
*               <> 0 - Server Read
*/

/**
* Appends SHA-1 based MAC and performs AES encryption of a record message (AppendMacEncryptRecord).
* The operation is in-place, so input buffer = output buffer.
*
*  @param pConnStruc Control structure
*  @param pInpData Base of message buffer
*  @param pDataLen Message length before/after the operation
*
*  @return int Status HSSL_OP_OK o.k., else error occured
*/
extern "C"  int AppendMacEncryptRecord(CONNSTRU * pConnStruc,
		char* pInpData, int* pDataLen)
{
  int ProtType = 0;				// 0-SSL, 1-TLS1.0, 2-TLS1.1

  int CryptLen,NettoLen,DataLen,AesRounds;
  int AesBlkCnt,PadLen;
  int SHA1_FirstBlockLen;
  int SHA1_FullBlockCnt = 0;
  int SHA1_RemainingLen = 0;

  uint32_t SHA1_ArrayCopyStartIndex,Index;
  char* pShaSrc;
  char* pAesSrc;

  char* pTmpByte;

  int* pTmp;

  char SHA_Digest[SHA_DIGEST_LEN];
  int SHA_I_Array[SHA_ARRAY_SIZE];
  int SHA_O_Array[SHA_ARRAY_SIZE];
  //--------------------------------------------------------------
  // Get connection protocol from Record header
  //--------------------------------------------------------------
  ProtType = (int) pInpData[RH_VERSION_LSB] & 0x0FF; // already valid, checked

  //--------------------------------------------------------------
  // Calculate SHA-1 full block count
  //--------------------------------------------------------------
  DataLen  = pDataLen[0];
  NettoLen = DataLen;				// length w/o header
  DataLen += RECORD_HDR_SIZE;			// inclusive header!

  if(ProtType == SSL_MINOR_VERSION)
  {
    SHA1_FirstBlockLen = SHA_CBLOCK - 7;
    SHA1_ArrayCopyStartIndex = 0;		// must copy stored data
  }
  else
  {
    SHA1_FirstBlockLen = SHA_CBLOCK - 13;
    SHA1_ArrayCopyStartIndex = 16;		// need not copy stored data
  }

  if(NettoLen <= SHA1_FirstBlockLen)
  {
    SHA1_FirstBlockLen = NettoLen;
  }
  else
  {
    SHA1_FullBlockCnt = (NettoLen - SHA1_FirstBlockLen)/SHA_CBLOCK;
    SHA1_RemainingLen = NettoLen - SHA1_FirstBlockLen -
                          (SHA1_FullBlockCnt * SHA_CBLOCK);
  }
  pShaSrc = pInpData + RECORD_HDR_SIZE;		// start pointer SHA-1
  pAesSrc = pShaSrc;				// dto.          AES

  //--------------------------------------------------------------
  // Calculate AES total block count (incl. hash, padding)
  // and required padding length
  //--------------------------------------------------------------
  AesRounds = pConnStruc->KeyLen/4 + 6;
  AesBlkCnt = (NettoLen + SHA_DIGEST_LEN + 1 + AES_BLOCK_SIZE - 1)/
		    AES_BLOCK_SIZE;
  CryptLen  = AesBlkCnt * AES_BLOCK_SIZE;	   // exclusiv header!
  PadLen    = CryptLen-(NettoLen+SHA_DIGEST_LEN+1);// padding count

  //==============================================================
  // Initialize Inner/Outer SHA-Arrays
  // NOTE: different for SSL/TLS
  //==============================================================
  //--------------------------------------------------------------
  // 0. Copy data from inner/outer saved array to local,
  //    SSL: Copy WITH data, (60 bytes stored),
  //    TLS: Copy only state variables
  //--------------------------------------------------------------
  Index = SHA1_ArrayCopyStartIndex;
  pTmp = pConnStruc->ActTX_MAC_I_Array;  // get inner array start
  do
  {
    SHA_I_Array[Index+0] = pTmp[Index+0];
    SHA_I_Array[Index+1] = pTmp[Index+1];
    SHA_I_Array[Index+2] = pTmp[Index+2];
    SHA_I_Array[Index+3] = pTmp[Index+3];
    SHA_I_Array[Index+4] = pTmp[Index+4];
    SHA_I_Array[Index+5] = pTmp[Index+5];
    SHA_I_Array[Index+6] = pTmp[Index+6];
    SHA_I_Array[Index+7] = pTmp[Index+7];
    Index += 8;
  }while(Index < SHA_ARRAY_SIZE);    

  Index = SHA1_ArrayCopyStartIndex;
  pTmp = pConnStruc->ActTX_MAC_O_Array;  // get outer array start
  do
  {
    SHA_O_Array[Index+0] = pTmp[Index+0];
    SHA_O_Array[Index+1] = pTmp[Index+1];
    SHA_O_Array[Index+2] = pTmp[Index+2];
    SHA_O_Array[Index+3] = pTmp[Index+3];
    SHA_O_Array[Index+4] = pTmp[Index+4];
    SHA_O_Array[Index+5] = pTmp[Index+5];
    SHA_O_Array[Index+6] = pTmp[Index+6];
    SHA_O_Array[Index+7] = pTmp[Index+7];
    Index += 8;
  }while(Index < SHA_ARRAY_SIZE);    

  if(ProtType == SSL_MINOR_VERSION)
  {
    //================================================================
    // SSL-Protocol in use
    //================================================================
    //-------------------------------------------------------------
    // 1. Hash the sequence number (requires block update!)
    //-------------------------------------------------------------
    SHA1_Update(SHA_I_Array,pConnStruc->ActTX_SeqNumber,0,SEQUENCE_NUM_LEN);
    //--------------------------------------------------------------
    // 2. Put record type and length (MSB, LSB) to SHA-1 data buffer
    //--------------------------------------------------------------
#if HOB_WIN64_ASM == 1 // Assembler, byte array
    ((unsigned char*) &SHA_I_Array[SHA_data+1])[0] = pInpData[RH_TYPE];
    ((unsigned char*) &SHA_I_Array[SHA_data+1])[1] = pInpData[RH_LENGTH_MSB];
    ((unsigned char*) &SHA_I_Array[SHA_data+1])[2] = pInpData[RH_LENGTH_LSB];
#else // C, int array
    SHA_I_Array[SHA_data+1] = (uint32_t)
             ((((uint32_t) ((unsigned char) pInpData[RH_TYPE]))       << 24) |
              (((uint32_t) ((unsigned char) pInpData[RH_LENGTH_MSB])) << 16) |
              (((uint32_t) ((unsigned char) pInpData[RH_LENGTH_LSB])) <<  8));
#endif
    SHA_I_Array[SHA_Nl]   += 24;		// additional bits
    SHA_I_Array[SHA_num]  = 7;			// 3+4 from sequence Nr.
  }
  else
  {
    //============================================================
    // TLS Protocol in use (1.0 or 1.1)
    //============================================================

    //--------------------------------------------------------------
    // 1. Copy the 8 byte sequence number to Data element 0 and 1
    //    of the inner array (bitcount now: 512+64, storedlen: 8)
    //--------------------------------------------------------------
    pTmpByte = pConnStruc->ActTX_SeqNumber;
#if HOB_WIN64_ASM == 1 // Assembler, byte array
    SHA_I_Array[SHA_data+0] = ((int*) &pTmpByte[0])[0];
    SHA_I_Array[SHA_data+1] = ((int*) &pTmpByte[0])[1];
#else // C, int array
    SHA_I_Array[SHA_data+0] = (uint32_t)
            ((((uint32_t) ((unsigned char) pTmpByte[0])) << 24) |
	     (((uint32_t) ((unsigned char) pTmpByte[1])) << 16) |
             (((uint32_t) ((unsigned char) pTmpByte[2])) <<  8) |
               (uint32_t) ((unsigned char) pTmpByte[3]));
    SHA_I_Array[SHA_data+1] = (uint32_t)
            ((((uint32_t) ((unsigned char) pTmpByte[4])) << 24) |
	     (((uint32_t) ((unsigned char) pTmpByte[5])) << 16) |
             (((uint32_t) ((unsigned char) pTmpByte[6])) <<  8) |
               (uint32_t) ((unsigned char) pTmpByte[7]));
#endif
    //---------------------------------------------------------------
    // 2. Copy the 5 byte record header to Data element 2 and 3 (low)
    //    of the inner array (bitcount now: 512+64+40, storedlen: 13)
    //---------------------------------------------------------------
#if HOB_WIN64_ASM == 1 // Assembler uses byte array
    SHA_I_Array[SHA_data+2] = ((int*) &pInpData[0])[0];
    ((unsigned char*) &SHA_I_Array[SHA_data+3])[0] = pInpData[4];
#else // C uses int array
    SHA_I_Array[SHA_data+2] = (uint32_t)
            ((((uint32_t) ((unsigned char) pInpData[0])) << 24) |
	     (((uint32_t) ((unsigned char) pInpData[1])) << 16) |
             (((uint32_t) ((unsigned char) pInpData[2])) <<  8) |
               (uint32_t) ((unsigned char) pInpData[3]));
    SHA_I_Array[SHA_data+3] = (uint32_t)
            (((uint32_t) ((unsigned char) pInpData[4])) << 24);
#endif
    SHA_I_Array[SHA_Nl]     = 512+64+40; 	// bitcount LSW
    SHA_I_Array[SHA_Nh]     = 0;		// bitcount MSW
    SHA_I_Array[SHA_num]    = 13;		// bytes stored
  }
  //--------------------------------------------------------------
  // Increment sequence number
  //--------------------------------------------------------------
  IncSequenceNumber(pConnStruc->ActTX_SeqNumber);

  //--------------------------------------------------------------
  // Process the first SHA-1 partial block (size < 64)
  //--------------------------------------------------------------
  SHA1_Update(SHA_I_Array,pShaSrc,0,SHA1_FirstBlockLen);
  pShaSrc += SHA1_FirstBlockLen;

  //--------------------------------------------------------------
  // Check if parallel servicing is useful (>= 1 full SHA-1 block)
  //--------------------------------------------------------------
  if(SHA1_FullBlockCnt == 0)
  {
    //------------------------------------------------------------
    // less data than a full block for SHA-1, calculate direct
    //------------------------------------------------------------
    if(SHA1_RemainingLen > 0)
      SHA1_Update(SHA_I_Array,pShaSrc,0,SHA1_RemainingLen);

    SHA1_Final(SHA_I_Array,SHA_Digest,0);  // intermediate
    SHA1_Update(SHA_O_Array,SHA_Digest,0,SHA_DIGEST_LEN);		    // generate outer
    SHA1_Final(SHA_O_Array,pInpData,DataLen); // append hash      

    //-------------------------------------------------------------
    // Pad the data for encrypt, add padlen
    //-------------------------------------------------------------
    Index = DataLen+SHA_DIGEST_LEN;
    while(Index < (uint32_t) (CryptLen-1+RECORD_HDR_SIZE))
    {
      pInpData[Index++] = (unsigned char) PadLen;
    }
    pInpData[Index] = (unsigned char) PadLen;
    //-------------------------------------------------------------
    // Encrypt the data now
    //-------------------------------------------------------------
//    AES_CBC_ENCRYPT_DECRYPT(AESinst,pAesSrc,0, pAesSrc,0,
//			    CONN_ActTX_AESKeyArrayPtr(pConnStruc),
//			    AesBlkCnt, CONN_ActTX_IV(pConnStruc),0,
//	        	    AesRounds, AES_ENCRYPT);
    m_aes_cbc_encrypt((unsigned char *) pAesSrc,
		      (unsigned char *) pAesSrc,
	              (ds_aes_key *) pConnStruc->ActTX_AESKeyArrayPtr,
		      AesBlkCnt, 
                      (unsigned char *) pConnStruc->ActTX_IV,
	              AesRounds);
    pDataLen[0] = CryptLen;
    return(HSSL_OP_OK);
  }

  //---------------------------------------------------------------
  // parallel servicing can be done, >= 1 complete SHA1-Block
  // NOTE: The first (incomplete) block has already been processed
  // -----
  // Encrypt 3 AES blocks ahead (no overlap)
  //---------------------------------------------------------------
//  AES_CBC_ENCRYPT_DECRYPT(AESinst, pAesSrc,0, pAesSrc,0,
//			  CONN_ActTX_AESKeyArrayPtr(pConnStruc),
//			  3, CONN_ActTX_IV(pConnStruc),0,
//		          AesRounds,AES_ENCRYPT);
  m_aes_cbc_encrypt((unsigned char *) pAesSrc,
                    (unsigned char *) pAesSrc,
		    (ds_aes_key *) pConnStruc->ActTX_AESKeyArrayPtr,
		    3,
		    (unsigned char *) pConnStruc->ActTX_IV,
		    AesRounds);

  pAesSrc   += AES_BLOCK_SIZE * 3; 
  AesBlkCnt -= ((SHA1_FullBlockCnt*4) + 3);
  //---------------------------------------------------------------
  // Full SHA-1 block processing loop
  //---------------------------------------------------------------
  do
  {
    //---------------------------------------------------------------
    // process a full SHA-1 data block update
    //---------------------------------------------------------------
    SHA1_Update(SHA_I_Array,pShaSrc,0,SHA_CBLOCK);
    pShaSrc += SHA_CBLOCK;
    //---------------------------------------------------------------
    // Encrypt 4 AES blocks (no overlap)
    //---------------------------------------------------------------
//    AES_CBC_ENCRYPT_DECRYPT(AESinst, pAesSrc,0, pAesSrc,0 ,
//			    CONN_ActTX_AESKeyArrayPtr(pConnStruc),
//			    4, CONN_ActTX_IV(pConnStruc),0,
//	 		    AesRounds,AES_ENCRYPT);
    m_aes_cbc_encrypt((unsigned char *) pAesSrc,
                      (unsigned char *) pAesSrc,
		      (ds_aes_key *) pConnStruc->ActTX_AESKeyArrayPtr,
                      4,
                      (unsigned char *) pConnStruc->ActTX_IV,
		      AesRounds);

    pAesSrc += AES_BLOCK_SIZE * 4; 
    SHA1_FullBlockCnt--;
  }while(SHA1_FullBlockCnt != 0);
  //-------------------------------------------------------------
  // Hash remaining SHA-1 data if any, generate inner hash
  //-------------------------------------------------------------
  if(SHA1_RemainingLen > 0)
      SHA1_Update(SHA_I_Array,pShaSrc,0,SHA1_RemainingLen);

  SHA1_Final(SHA_I_Array,SHA_Digest,0); // intermediate
  SHA1_Update(SHA_O_Array,SHA_Digest,0,SHA_DIGEST_LEN);			// generate outer
  SHA1_Final(SHA_O_Array,pInpData,DataLen); // append hash      

  //-------------------------------------------------------------
  // Pad the data for encrypt, add Pad length
  //-------------------------------------------------------------
  Index = DataLen + SHA_DIGEST_LEN;		// padding starts past hash
  while(Index < (uint32_t) (CryptLen-1+RECORD_HDR_SIZE))
  {
    pInpData[Index++] = (unsigned char) PadLen;
  }
  pInpData[Index] = (unsigned char) PadLen;
  //-------------------------------------------------------------
  // Encrypt the remaining data blocks now
  //-------------------------------------------------------------
//  AES_CBC_ENCRYPT_DECRYPT(AESinst, pAesSrc,0, pAesSrc,0,
//			  CONN_ActTX_AESKeyArrayPtr(pConnStruc),
//			  AesBlkCnt, CONN_ActTX_IV(pConnStruc),0,
//			  AesRounds, AES_ENCRYPT);
  m_aes_cbc_encrypt((unsigned char *) pAesSrc,
                    (unsigned char *) pAesSrc,
		    (ds_aes_key *) pConnStruc->ActTX_AESKeyArrayPtr,
		    AesBlkCnt,
                    (unsigned char *) pConnStruc->ActTX_IV,
		    AesRounds);
  pDataLen[0] = CryptLen;
  return(HSSL_OP_OK);
}


#endif //HL_SSL_PROT_MAIN
// end of file ../hssl/haessha.cpp


#ifdef HL_SSL_GLIB
/** @defgroup util Utility module
*
* This module contains a set of untilities.
*
* It is split in various submodules by the types of utilities.
* Dependencies and exact functionality is described by the sub-modules.
*/
/** @defgroup gutil Generic and configuration utility module
* @ingroup util
*
* This module contains utilities for configuration processing and general 
* utilities.
* @{
* @file
* This file contains the implementation of the generic library module.
* @}
*/

#if (defined _WIN32) & (_MSC_VER < 1700)
#ifndef _STDINT
#define _STDINT
// MSVC lower than 17.00 does not have stdint.h, assure, all needed types are defined

typedef unsigned __int16 uint16_t;

typedef unsigned __int32 uint32_t;

typedef unsigned __int64 uint64_t;

#endif // !_STDINT
#else
#include <stdint.h>
#endif
#include <stddef.h>
#ifdef _WIN32
#define WIN32_LEAN_AND_MEAN
#include <Windows.h>
#undef WIN32_LEAN_AND_MEAN
#else// Define system-specific HL_* defines here
#ifndef HL_UNIX
#define HL_UNIX

#if (defined __gnu_linux__) || (defined __linux__)
#define HL_LINUX
#endif

#if (defined __APPLE__) && (defined __MACH__)
#define HL_LINUX
#define HL_MACOS
#endif

#ifdef _AIX
#define HL_AIX
#define HL_BIG_ENDIAN
#endif

#ifdef __FreeBSD__
#define HL_FREEBSD
#endif

#if (defined _hpux) || (defined hpux) || (defined __hpux)
#define HL_HPUX
#define HL_BIG_ENDIAN
#endif

#if (defined sun) || (defined __sun)
#define HL_SOLARIS
#endif

#if (defined __arm__) || (defined __aarch64__)
#define HL_LINUX_ARM
#endif

#ifdef __ANDROID__
#define HL_ANDROID
#endif

#endif
#include <hob-unix01.h>
#endif
#ifdef __APPLE__
/* We get target conditionals to keep apart Mac OS, iOS and iOS simulator.
   The conditionals are TARGET_IPHONE_SIMULATOR, TARGET_OS_IPHONE and TARGET_OS_MAC.
   TARGET_IPHONE_SIMULATOR has the highest priority, TARGET_OS_MAC the lowest.
   Always test, if the conditional is 1, as they will be defined as 0, if we 
   are not compiling for the target.
   */
#include <TargetConditionals.h>
#endif

#ifdef HL_ANDROID
#include <sys/endian.h>
#endif

#include "hob-encry-1.h"
#include "hob-cert-ext.h"
#if !(defined __HOB_XSCLIB01__) && !(defined DEF_IFUNC_START)
#define __HOB_XSCLIB01__

#include <hob-xsclib01.h>  
#endif // !__HOB_XSCLIB01__
#include <stdlib.h>
#include <hob-encry-2.h>
#include "hob-ssl-intern.h"
#include "hob-ssl-err.h"
#include "hob-ssl-err.h"
#ifdef _WIN32
#include <winsock.h>
#endif
#include "hob-cert-err.h"
#include <string.h>
#include "hob-cert-intern.h"

//-------------------------------------------------------
// Configuration File ID-Strings
//-------------------------------------------------------
static  char SrvrCfgIdStr[FILE_HDR_ID_LEN] = {
	(char)'S',(char)'E',(char)'R',(char)'V',
	(char)'C',(char)'F',(char)'G',0
};

static  char ClntCfgIdStr[FILE_HDR_ID_LEN] = {
	(char)'C',(char)'L',(char)'N',(char)'T',
	(char)'C',(char)'F',(char)'G',0
};

//-------------------------------------------------------
// Certificate File ID-Strings
//-------------------------------------------------------
static  char SrvrCertsIdStr[FILE_HDR_ID_LEN] = {
	(char)'S',(char)'R',(char)'V',(char)'R',
        (char)'C',(char)'R',(char)'T',0
};

static  char ClntCertsIdStr[FILE_HDR_ID_LEN] = {
	(char)'C',(char)'L',(char)'N',(char)'T',
	(char)'C',(char)'R',(char)'T',0
};

static  char SrvrCertReqsIdStr[FILE_HDR_ID_LEN] = {
	(char)'S',(char)'R',(char)'V',(char)'R',
	(char)'C',(char)'R',(char)'Q',0
};

static  char ClntCertReqsIdStr[FILE_HDR_ID_LEN] = {
	(char)'C',(char)'L',(char)'N',(char)'T',
	(char)'C',(char)'R',(char)'Q',0
};

static  char VpnCertsIdStr[FILE_HDR_ID_LEN] = {
	(char)'V',(char)'P',(char)'N',(char)' ',
	(char)'C',(char)'R',(char)'T',0
};

static  char VpnCertReqsIdStr[FILE_HDR_ID_LEN] = {
	(char)'V',(char)'P',(char)'N',(char)' ',
	(char)'C',(char)'R',(char)'Q',0
};

//-------------------------------------------------------
// Password File ID-Strings
//-------------------------------------------------------
static  char SrvrPwdIdStr[FILE_HDR_ID_LEN] = {
	(char)'S',(char)'R',(char)'V',(char)'R',
	(char)'P',(char)'D',(char)'A',0
};

static  char ClntPwdIdStr[FILE_HDR_ID_LEN] = {
	(char)'C',(char)'L',(char)'N',(char)'T',
	(char)'P',(char)'D',(char)'A',0
};

static  char SrvrCertPwdIdStr[FILE_HDR_ID_LEN] = {
	(char)'C',(char)'R',(char)'T',(char)'S',
	(char)'P',(char)'D',(char)'A',0
};
static  char ClntCertPwdIdStr[FILE_HDR_ID_LEN] = {
	(char)'C',(char)'R',(char)'T',(char)'C',
	(char)'P',(char)'D',(char)'A',0
};
static  char VpnCertPwdIdStr[FILE_HDR_ID_LEN] = {
	(char)'V',(char)'P',(char)'N',(char)'C',
	(char)'P',(char)'D',(char)'A',0
};

//------------------------------------------------------
// Access Array for IDs and Default filenames
//------------------------------------------------------
char* IDStrTab[13] = {
	SrvrCfgIdStr,
	ClntCfgIdStr,
	SrvrCertsIdStr,
	ClntCertsIdStr,
	SrvrCertReqsIdStr,
	ClntCertReqsIdStr,
	SrvrPwdIdStr,
	ClntPwdIdStr,
	SrvrCertPwdIdStr,
	ClntCertPwdIdStr,
	VpnCertPwdIdStr,
	VpnCertsIdStr,
	VpnCertReqsIdStr,
};

/** @addtogroup gutil
* @{
*/

/**
* XORs two byte arrays of same size (XorBit8Arrays).
* 
*  @param Src1Base Source1 base
*  @param Src1Off Source1 data start
*  @param Src2Base Source2 base
*  @param Src2Off Source2 data start
*  @param DstBuf Destination Base
*  @param DstOff Start offset for writing
*  @param DataCnt Length of arrays
* 
*/
static  void  XorBit8Arrays(char* Src1Base, int Src1Off,
		 char* Src2Base, int Src2Off, char* DstBuf, int DstOff,
		 int DataCnt)
{
  int index1 = Src1Off;
  int index2 = Src2Off;
  int index3 = DstOff;
  int i;

  for(i=DataCnt;i>0;i--)
    DstBuf[index3++]  = (unsigned char) (Src1Base[index1++] ^ Src2Base[index2++]);
}

/**
* Generates/verifies the header
* and data MD5 hashes for a given header-/data- and password
* buffer (GenVfyPwdMD5Hashes). 
* In generate mode puts hashes to header, in verify mode
* compares hashes with header hashes.
*
*  @param HdrBuf Buffer of header
*  @param HdrOff Start of data
*  @param HdrLen Length of header
*  @param DataBuf Buffer of data
*  @param DataOff Start of data
*  @param DataLen Length of data
*  @param PwdBuf Password Buffer base
*  @param PwdOff Start of Data
*  @param PwdLen Length of password
*  @param Mode == 0 - Generate
*               <> 0 - Verify
*  @return 0 - o.k.
* <br>            <> 0 Error occurred:
* <br>            -1 Null Pointer
* <br>            -2 length mismatch/Zero
* <br>            -3 Verify failed
*/
extern "C"  int  GenVfyPwdMD5Hashes(char* HdrBuf, int HdrOff,
		int HdrLen, char* DataBuf, int DataOff, int DataLen,
		char* PwdBuf, int PwdOff, int PwdLen, int Mode)
{
  char mdigest1[MD5_DIGEST_LEN];
  char mdigest2[MD5_DIGEST_LEN];

  int md5array[MD5_ARRAY_SIZE];

  //---------------------------------------------------------
  // Check pointers and lengths
  //---------------------------------------------------------
  if((HdrBuf == NULL) || (DataBuf == NULL) || (PwdBuf == NULL))
    return(-1);

  if((HdrLen != FILE_HEADER_LEN) || (DataLen == 0) || (PwdLen == 0))
    return(-2);
  //---------------------------------------------------------
  // Generate the header hash
  //---------------------------------------------------------
  MD5_Init(md5array);				// initialize
  MD5_Update(md5array,HdrBuf,HdrOff,FILE_HEADER_LEN1);
  MD5_Update(md5array,PwdBuf,PwdOff,PwdLen);
  if(Mode == 0)
    MD5_Final(md5array,HdrBuf,HdrOff+FILE_HDR_PWD_HDR_HASH_INDEX);
  else
  {
    MD5_Final(md5array,mdigest1,0);
    if(CmpBit8Arrays(HdrBuf,HdrOff+FILE_HDR_PWD_HDR_HASH_INDEX,
		     mdigest1,0,MD5_DIGEST_LEN) != 0) return(-3);
  }
  //---------------------------------------------------------
  // Generate 1st part of data hash
  //---------------------------------------------------------
  MD5_Init(md5array);				// initialize
  MD5_Update(md5array,HdrBuf,HdrOff,FILE_HEADER_LEN2);
  MD5_Update(md5array,PwdBuf,PwdOff,PwdLen);
  MD5_Final(md5array,mdigest1,0);
  //---------------------------------------------------------
  // Generate 2nd part of data hash
  //---------------------------------------------------------
  MD5_Init(md5array);				// initialize
  MD5_Update(md5array,DataBuf,DataOff,DataLen);
  MD5_Update(md5array,PwdBuf,PwdOff,PwdLen);
  MD5_Final(md5array,mdigest2,0);
  if(Mode == 0)
    XorBit8Arrays(mdigest1,0,mdigest2,0,HdrBuf,
		  HdrOff+FILE_HDR_PWD_DATA_HASH_INDEX,MD5_DIGEST_LEN);
  else
  {
    XorBit8Arrays(mdigest1,0,mdigest2,0,mdigest1,0,MD5_DIGEST_LEN);
    if(CmpBit8Arrays(HdrBuf,HdrOff+FILE_HDR_PWD_DATA_HASH_INDEX,
		     mdigest1,0,MD5_DIGEST_LEN) != 0) return(-3);
  }
  return(0);
}
/**
* Generates/vertifies the
* fixed data portions of the file headers (GenVfyFixedFileHdrs).
* During generate the full header is cleared first.
*
*  @param HdrBuf Buffer of header
*  @param HdrOff Start of data
*  @param HdrLen Length of header
*  @param Type 1 - Server Configuration
*               2 - Client Configuration
*               3 - Server Certificate Database
*               4 - Client Certificate Database
*               5 - Server Cert.Req. Database
*               6 - Client Cert.Req. Database
*               7 - ServerCfg Password File
*               8 - ClientCfg Password File
*               9 - Server Cert/Req.Password
*               10- Client Cert/Req.Password
*               11- VPN Cert Password
*               12- VPN Certificate Database
*               13- VPN Cert.Req Database
*  @param Mode == 0 - generate
*               != 0 - verify
*
*  @return 0 - o.k.
* <br>            <> 0 Error occurred:
* <br>            -1 Null Pointer
* <br>            -2 length mismatch/Zero
* <br>            -3 not used (new)
* <br>            -4 invalid type (formerly -3)
* <br>            -5 not used (new)
* <br>            -6 verify error (formerly -4)
*/
extern "C"  int  GenVfyFixedFileHdrs(char* HdrBuf, int HdrOff,
		int HdrLen, int Type, int Mode)
{
//  BIT8PTR pIDStr=NULL;
  char* pIDStr;
  int i;
  //--------------------------------------------------
  // initial checks on parameters
  //--------------------------------------------------
  if(HdrBuf == NULL)
    return(-1);
  if(HdrLen != FILE_HEADER_LEN)
    return(-2);
  if((Type < FILE_TYPE_SRVR_CFG) ||
     (Type > FILE_TYPE_VPN_CERT_REQ))
    return(-4);
  //--------------------------------------------------
  // get proper ID-String to use
  //--------------------------------------------------
  pIDStr = IDStrTab[Type-1];		// get the ID string
  if(Mode == 0)
  {
    //--------------------------------------------------
    // Generate header, newest Revision will be generated
    //--------------------------------------------------
    i = FILE_HEADER_LEN;
    do{i--;HdrBuf[HdrOff+i] = 0;}while(i != 0);
    BIGword2charn(FILE_MAGIC_NUMBER,HdrBuf,FILE_HDR_MAGIC_INDEX);
// Will be activated in *NEXT* release with smartcards !!
    BIGword2charn(FILE_VERSION1_REV2,HdrBuf,FILE_HDR_VERSION_INDEX);
//  BIGword2charn(FILE_VERSION1_REV1,HdrBuf,FILE_HDR_VERSION_INDEX);
    memcpy(HdrBuf+FILE_HDR_FILE_ID_INDEX,pIDStr+0,FILE_HDR_ID_LEN);
    return(0);
  }
  else
  {
    //--------------------------------------------------
    // Verify header
    //--------------------------------------------------
    BIGchar2wordn(HdrBuf,i,(HdrOff+FILE_HDR_MAGIC_INDEX));
    if(i != FILE_MAGIC_NUMBER)
      return(-6);
    BIGchar2wordn(HdrBuf,i,(HdrOff+FILE_HDR_VERSION_INDEX));
    if((i < FILE_VERSION1_REV0) || (i > FILE_VERSION1_REV3))
      return(-6);
    if(CmpBit8Arrays(HdrBuf,HdrOff+FILE_HDR_FILE_ID_INDEX,
		     pIDStr,0,FILE_HDR_ID_LEN) != 0)
      return(-6);
    return(0);
  }
}
/**
* Generates password from password
* file Header/Databuffer (DecodePasswdData).
*
* Destination buffer will be allocated by this function.
*
*  @param HdrBuf Header Base
*  @param HdrOff Start of data
*  @param HdrLen Length of Header
*  @param DataBuf Data Base
*  @param DataOff Start of data
*  @param DataLen Length of data
*  @param Type 5 Server config
*               6 Client config
*               7 Cert/CertReq.
*               11 VPN Cert/CertReq
*  @param ppDst Destination buffer pointer
*  @param pPwdLen Length of generated data
*
*  @return int Status 0 - o.k.
* <br>            <> 0 Error occurred:
* <br>            -1 Null Pointer
* <br>            -2 Invalid Type
* <br>            -3 invalid Header/Data length
* <br>            -4 header error
* <br>            -5 decrypt error
* <br>            -6 format error
* <br>            -7 length error
* <br>            -8 alloc error
* <br>            -9 hash error
*/
extern "C"  int  DecodePasswdData(HMEM_CTX_DEF
		char* HdrBuf, int HdrOff,
		int HdrLen, char* DataBuf, int DataOff, int DataLen,
		int Type, char** ppDst, int* pPwdLen)
{

  int Retcode;

  char pTmpBuf[8];

  char* pOutBuf = NULL;
  char* pDecryptBuf = NULL;

  int DesSubKeys[DES_SUBKEY_ARRAY_SIZE]; 

  int Index;
  int Index1;
  int i,j;
  int PasswdLen = 0;

  int lDataLen;

  //------------------------------------------
  // check parameters
  //------------------------------------------
  if((HdrBuf == NULL) || (DataBuf == NULL) || (ppDst == NULL)) return(-1);
  if((Type != FILE_TYPE_SRVR_PWD) &&
     (Type != FILE_TYPE_CLNT_PWD) &&
     (Type != FILE_TYPE_SRVR_CERT_PWD) &&
     (Type != FILE_TYPE_CLNT_CERT_PWD) &&
     (Type != FILE_TYPE_VPN_CERT_PWD)) return(-2);

  if((HdrLen != FILE_HEADER_LEN) || (DataLen < FILE_DATA_PWD_LEN) ||
    (DataLen > (FILE_DATA_PWD_LEN+FILE_DATA_MAX_SALT_LEN+(DES_KEY_BYTES*2))))
    return(-3);

  ppDst[0] = NULL;
  pPwdLen[0] = 0;
  //---------------------------------------------
  // check header fixed portions, get data length
  //---------------------------------------------
  if(GenVfyFixedFileHdrs(HdrBuf, 0, FILE_HEADER_LEN,Type, 1) != 0)
    return(-4);

  BIGchar2longn(HdrBuf,lDataLen,FILE_HDR_PWD_DATALEN_INDEX);
  if(lDataLen != (int) DataLen) return(-4);
  //------------------------------------------------------
  // DES CBC-Decrypt the formatted password
  //------------------------------------------------------
  Index = DataOff+DataLen-(DES_KEY_BYTES*2);		// position of key
  GenDESSubKeys((unsigned char *)(DataBuf+Index),
		(unsigned int *) DesSubKeys);

  memcpy(pTmpBuf+0,DataBuf+Index+8,DES_KEY_BYTES); // copy IV

  pDecryptBuf = BIT8_ARRAY_ALLOC(HMEM_CTX_REF,DataLen);
  if(pDecryptBuf == NULL) return(-7);
  DES_cbc_encrypt_decrypt((unsigned char *)(DataBuf+DataOff),
			  (unsigned char *) pDecryptBuf,
			  (unsigned int *) DesSubKeys,
                          (FILE_DATA_PWD_LEN/8),
			  (unsigned char *) pTmpBuf,
			  DES_DECRYPT);

  memcpy(pDecryptBuf+FILE_DATA_PWD_LEN,DataBuf+DataOff+FILE_DATA_PWD_LEN,DataLen-FILE_DATA_PWD_LEN);
  //------------------------------------------------------
  // check for correct Blocktype, padding, delimiter
  //------------------------------------------------------
  Retcode = 0;
  for(;;)				// error processing FOR
  {
    Index = 0;				// to start of Decrypted Data
    if(pDecryptBuf[Index++] != FILE_DATA_PWD_BLOCKTYPE)
    {
      Retcode = -5;
      break;
    }    
    i = FILE_DATA_PWD_PADDING_LEN;
    do
    {
      if(pDecryptBuf[Index++] == 0)	// must be all non zero
      {
        Retcode = -5;
        break;
      }
      i--;
    }while(i != 0);
    if(Retcode != 0) break;

    if(pDecryptBuf[Index++] != FILE_DATA_PWD_DELIM)
    {
      Retcode = -5;
      break;
    }
    //------------------------------------------------------
    // get/check the password length, allocate buffer
    //------------------------------------------------------
    PasswdLen = (int) pDecryptBuf[Index++] & 0xFF;
    if((PasswdLen == 0) || (PasswdLen > MAX_PASSWORD_LEN))
    {
      Retcode = -6;
      break;
    }
    pOutBuf = BIT8_ARRAY_ALLOC(HMEM_CTX_REF,PasswdLen);
    if(pOutBuf == NULL)
    {
      Retcode = -7;
      break;
    }
    //------------------------------------------------------
    // Check formatting of remainder of password
    //------------------------------------------------------
    i = MAX_PASSWORD_LEN-PasswdLen;		// remaining padding
    if(i != 0)
    {
      j = Index + PasswdLen;
      Index1 = PasswdLen+2;
      do
      {
        if(pDecryptBuf[j++] != (char) Index1++)
        {
          Retcode = -5;
          break;
        }
        i--;
      }while(i != 0);
      if(Retcode != 0) break;
    }
    //------------------------------------------------------
    // check the hashes
    //------------------------------------------------------
    if(GenVfyPwdMD5Hashes(HdrBuf,HdrOff,FILE_HEADER_LEN,
		        pDecryptBuf,0, DataLen,
		        pDecryptBuf,Index, PasswdLen, 1) != 0)
    {
      Retcode = -8;
      break;
    } 
    //------------------------------------------------------
    // set return buffer pointer and length of password,
    // copy the password, clear tmp. buffer
    //------------------------------------------------------
    memcpy(pOutBuf+0,pDecryptBuf+Index,PasswdLen);
    break;
  } // Error FOR
  ClearBit8Array(pDecryptBuf,0,DataLen);
  FREE_ARRAY(HMEM_CTX_REF,pDecryptBuf);

  if(Retcode != 0)
  {
    ClearBit8Array(pOutBuf,0,PasswdLen);
    FREE_ARRAY(HMEM_CTX_REF,pOutBuf);
  }
  else
  {
    ppDst[0] = pOutBuf;
    pPwdLen[0] = PasswdLen;
  }
  return(Retcode);
}
/**
* Generates password file
* header/databuffer and hashes (GeneratePasswdData).
*
* Destination buffer will be allocated by this function.
*
*  @param PwdBuf Password base
*  @param PwdOff Start of password data
*  @param PwdLen Length of password
*  @param ExpireTime UTC time. If 0, never expires
*  @param Type 7 - Server configuration
*               8 - Client configuration
*               9 - Server Cert/Certreq
*               10 - Client Cert/Certreq
*               11 - VPN Cert/Certreq
*  @param ppDst Destination buffer pointer
*  @param pDstLen Length of generated data
*
*  @return 0 - o.k.
* <br>            <> 0 Error occurred:
* <br>            -1 Null Pointer
* <br>            -2 invalid Pwd length
* <br>            -3 invalid Type
* <br>            -4 allocate error
* <br>            -5 Random fetch failed
*/
extern "C"  int  GeneratePasswdData(HMEM_CTX_DEF
		char* PwdBuf, int PwdOff,
		int PwdLen, int ExpireTime, int Type,
	        char** ppDst, int* pDstLen)
{

  char pTmpBuf[8];

  char* pBuf;

  int DesSubKeys[DES_SUBKEY_ARRAY_SIZE]; 

  int Index,Retcode;
  int Index1;
  int i;
  int SaltLen;
  int DataLen;

  //------------------------------------------
  // check parameters
  //------------------------------------------
  if((PwdBuf == NULL) || (ppDst == NULL) || (pDstLen == NULL)) return(-1);
  if((PwdLen == 0) || (PwdLen > MAX_PASSWORD_LEN)) return(-2);
  if((Type != FILE_TYPE_SRVR_PWD) &&
     (Type != FILE_TYPE_CLNT_PWD) &&
     (Type != FILE_TYPE_SRVR_CERT_PWD) &&
     (Type != FILE_TYPE_CLNT_CERT_PWD) &&
     (Type != FILE_TYPE_VPN_CERT_PWD)) return(-3);
  ppDst[0] = NULL;
  pDstLen[0] = 0;
  //------------------------------------------
  // generate Salt length (Random)
  //------------------------------------------
//  RAND_BYTES(RANDinst,pTmpBuf,0,1);		// get value  
  Retcode = SecDrbgRandBytes(HMEM_CTX_REF1 pTmpBuf,0,1);
  if(Retcode != 0)
    return(-5);

  SaltLen = (int) pTmpBuf[0] & 0x7F;		// 0..128 Byte
  DataLen = SaltLen + FILE_DATA_PWD_LEN + (DES_KEY_BYTES*2);
  //------------------------------------------
  // Allocate necessary buffer
  //------------------------------------------
  pBuf = BIT8_ARRAY_ALLOC(HMEM_CTX_REF,FILE_HEADER_LEN+DataLen);
  if(pBuf == NULL) return(-4);
  ppDst[0] = pBuf;
  pDstLen[0] = DataLen + FILE_HEADER_LEN;
  //--------------------------------------------------------
  // Generate the header, set the datalength and Expire time
  //--------------------------------------------------------
  GenVfyFixedFileHdrs(pBuf, 0, FILE_HEADER_LEN,Type, 0);
  BIGlong2charn(ExpireTime,pBuf,FILE_HDR_PWD_EXPIRE_TIME_INDEX);
  BIGlong2charn(DataLen,pBuf,FILE_HDR_PWD_DATALEN_INDEX);
  //------------------------------------------------------
  // set the block-type, get padding, assure no zero bytes
  //------------------------------------------------------
  Index = FILE_DATA_START_INDEX;
  pBuf[Index++] = FILE_DATA_PWD_BLOCKTYPE;

//  RAND_BYTES(RANDinst,pBuf,Index,FILE_DATA_PWD_PADDING_LEN); // get padding
  Retcode = SecDrbgRandBytes(HMEM_CTX_REF1 pBuf,Index,FILE_DATA_PWD_PADDING_LEN);
  if(Retcode != 0)
  {
    FREE_ARRAY(HMEM_CTX_REF,pBuf);
    return(-5);
  }

  i = FILE_DATA_PWD_PADDING_LEN;
  do
  {
    while(pBuf[Index] == 0)			// we had a zero
    {
//      RAND_BYTES(RANDinst,pBuf,Index,1);	// replace with new one
      Retcode = SecDrbgRandBytes(HMEM_CTX_REF1 pBuf,Index,1); 
      if(Retcode != 0)
      {
        FREE_ARRAY(HMEM_CTX_REF,pBuf);
        return(-5);
      }
    }
    Index++;
    i--;
  }while(i != 0);    
  //------------------------------------------------------
  // set the Data delimiter, generate password buffer
  //------------------------------------------------------
  pBuf[Index++] = FILE_DATA_PWD_DELIM;
  pBuf[Index++] = (unsigned char) PwdLen;		// set length
  i = PwdLen;
  Index1 = PwdOff;
  do{pBuf[Index++] = PwdBuf[Index1++];i--;}while(i!=0); // copy password
  i = MAX_PASSWORD_LEN - PwdLen;		// get fill count
  if(i != 0)					// bytes to fill
  {
    Index1 = PwdLen+2;				// start of index
    do{pBuf[Index++] = (unsigned char) Index1++;i--;}while(i!=0); //append filler
  }
  //------------------------------------------------------
  // append Salt data
  //------------------------------------------------------
//  RAND_BYTES(RANDinst,pBuf,Index,SaltLen);	// append salt
  Retcode = SecDrbgRandBytes(HMEM_CTX_REF1 pBuf,Index,SaltLen);
  if(Retcode != 0)
  {
    FREE_ARRAY(HMEM_CTX_REF,pBuf);
    return(-5);
  }

  Index += SaltLen;				// increment pointer
  //------------------------------------------------------
  // get 8 byte key and 8 byte IV
  //------------------------------------------------------
//  RAND_BYTES(RANDinst,pBuf,Index,DES_KEY_BYTES*2);
  Retcode = SecDrbgRandBytes(HMEM_CTX_REF1 pBuf,Index,DES_KEY_BYTES*2);
  if(Retcode != 0)
  {
    FREE_ARRAY(HMEM_CTX_REF,pBuf);
    return(-5);
  }

  memcpy(pTmpBuf+0,pBuf+Index+8,DES_KEY_BYTES); // copy IV
  //------------------------------------------------------
  // Generate the data hashes
  //------------------------------------------------------
  GenVfyPwdMD5Hashes(pBuf,0,FILE_HEADER_LEN,
		     pBuf,FILE_DATA_START_INDEX, DataLen,
		     PwdBuf, PwdOff, PwdLen, 0);
  //------------------------------------------------------
  // DES CBC-Encrypt the formatted password
  //------------------------------------------------------
  GenDESSubKeys((unsigned char *)(pBuf+Index),
                (unsigned int *) DesSubKeys);
  DES_cbc_encrypt_decrypt((unsigned char *)(pBuf+FILE_DATA_START_INDEX),
			  (unsigned char *)(pBuf+FILE_DATA_START_INDEX),
			  (unsigned int *) DesSubKeys,
		          (FILE_DATA_PWD_LEN/8),
			  (unsigned char *) pTmpBuf,
			  DES_ENCRYPT);    
  return(0);
}
/**
* Generates container structure for certificate/certificate request file data (ExtractCertData).
* Extracts certificate indices,
* ASN.1 certificate containers and certificate alias names
* from certificate/certificate request file into
* arrays. The arrays will be allocated by this function.
*
* NOTE: The Original buffer must be valid as long as the
*   data are needed, as no copy is made.
* 
*  @param HdrBuf Header base
*  @param HdrOff Start of header data
*  @param HdrLen Length of header
*  @param DataBuf Data buffer base
*  @param DataOff Start of actual data
*  @param DataLen Length of data
*  @param PwdBuf Password base
*  @param PwdOff Start of password data
*  @param PwdLen Length of password
*  @param Type 3 - Server Certificate
*               4 - Client Certificate
*               5 - Server Certificate Req.
*               6 - Client Certificate Req.
*               12 - VPN Certificate
*               13 - VPN Certificate Req.
*
*  @param pPwdExpireTime Return pointer for expire time of password. Optional
*  @param ppIndexArray Return pointer for array of Indices. Optional
*  @param ppAsn1ContDescArr Return pointer for array of containers desc.
*  @param ppNameDescArr Return pointer for array of alias name desc. Optional
*  @param pEntryCnt Return pointer for number of entries
*
*  @return int Status 0 - o.k.
* <br>            <> 0 Error occurred:
* <br>            -1 Null Pointer
* <br>            -2 invalid type
* <br>            -3 invalid Data length
* <br>            -4 invalid header
* <br>            -5 invalid flags
* <br>            -6 allocate error
* <br>            -7 invalid hashes
* <br>            -8 Container length too small
* <br>            -9 Container ID invalid
* <br>            -10 Container length invalid
* <br>            -11 Container length inconsist.
* <br>            -12 Aliasname length too small
* <br>            -13 Aliasname length invalid
* <br>            -14 Aliasname length inconsist.
*/
extern "C"  int  ExtractCertData(HMEM_CTX_DEF
			char* HdrBuf, int HdrOff, int HdrLen,
			char* DataBuf, int DataOff, int DataLen,
			char* PwdBuf, int PwdOff, int PwdLen, int Type,
			int* pPwdExpireTime,
			int** ppIndexArray,
			IDATPARR** ppAsn1ContDescArr,
			IDATPARR** ppNameDescArr,
			int* pEntryCnt)
{
  int Retcode = 0;

  int DataIndex = DataOff;

  int i;
  int ContainerCnt;
  int ContainerLen;
  int NameLen;
  int Length = DataLen;

  int l;
  int PwdExpireTime;

  int* pIndexArray = NULL;

  IDATA** pAsn1ContDatArray;
  IDATA** pNameDatArray = NULL;

  IDATPARR* pAsn1ContDescArr = NULL;
  IDATPARR* pNameDescArr     = NULL;

  IDATPARR* pTmpDatArrayDesc[1];

  //------------------------------------------
  // check parameters
  //------------------------------------------
  if((HdrBuf == NULL) || (DataBuf == NULL) || (PwdBuf == NULL) ||
     (ppAsn1ContDescArr == NULL) || (pEntryCnt== NULL))
    return(-1);

  pEntryCnt[0] = 0;

  if((Type != FILE_TYPE_SRVR_CERT) &&
     (Type != FILE_TYPE_CLNT_CERT) &&
     (Type != FILE_TYPE_SRVR_CERT_REQ) &&
     (Type != FILE_TYPE_CLNT_CERT_REQ) &&
     (Type != FILE_TYPE_VPN_CERT) &&
     (Type != FILE_TYPE_VPN_CERT_REQ)) return(-2);
  
  if((HdrLen != FILE_HEADER_LEN) || (DataLen <= 0) ||
     (PwdLen <= 0) || (PwdLen > MAX_PASSWORD_LEN)) return(-3);

  //-------------------------------------------------------
  // check header fixed portions, get number of containers
  //-------------------------------------------------------
  if(GenVfyFixedFileHdrs(HdrBuf, HdrOff, FILE_HEADER_LEN, Type, 1) != 0)
    return(-4);

  BIGchar2longn(HdrBuf,PwdExpireTime,HdrOff+FILE_HDR_PWD_EXPIRE_TIME_INDEX);
  if(pPwdExpireTime != NULL)
    pPwdExpireTime[0] = PwdExpireTime;

  BIGchar2longn(HdrBuf,l,HdrOff+FILE_HDR_ENTRY_CNT_INDEX);
  if((l <= 0) || (l > MAX_CONT_COUNT)) return(-5);
  ContainerCnt = (int) l;
  //------------------------------------------------------
  // check the hashes
  //------------------------------------------------------
  if(GenVfyPwdMD5Hashes(HdrBuf,HdrOff,FILE_HEADER_LEN,
		        DataBuf,DataOff, DataLen,
		        PwdBuf,PwdOff, PwdLen, 1) != 0)
    return(-7);
  for(;;)	// ERROR FOR
  {
    //----------------------------------------------------------
    // allocate the Descriptor arrays and the related entries
    //----------------------------------------------------------
    Retcode = -6;				// preset Allocate Error
    if(ppIndexArray != NULL)
    {
      pIndexArray = BIT32_ARRAY_ALLOC(HMEM_CTX_REF,ContainerCnt);
      if(pIndexArray == NULL) break;
    }
    if(AllocIDATPARR_Struc(HMEM_CTX_REF1 pTmpDatArrayDesc,ContainerCnt) != ASN1_OP_OK)
      break;
    pAsn1ContDescArr = pTmpDatArrayDesc[0];

    if(ppNameDescArr != NULL)
    {
      if(AllocIDATPARR_Struc(HMEM_CTX_REF1 pTmpDatArrayDesc,ContainerCnt) != ASN1_OP_OK)
	break;
      pNameDescArr = pTmpDatArrayDesc[0];
      pNameDatArray     = pNameDescArr->ppArr;
    }
    //----------------------------------------------------------------
    // process the Container Entries, shuffle to the Array descriptors
    //----------------------------------------------------------------
    pAsn1ContDatArray = pAsn1ContDescArr->ppArr;

    i = 0;
    do
    {    
      pAsn1ContDatArray[i]->Base = DataBuf; // dto.
      if(pNameDatArray != NULL)
      {
        pNameDatArray[i]->Base     = DataBuf; // dto.
      }  
      //----------------------------------------------------------------
      // check the ID, get ASN.1 Container length
      //----------------------------------------------------------------
      Retcode = -8;				// set length Error
      if(Length < ENTRY_HDR_LEN) break;
      Length -= ENTRY_HDR_LEN;			// reduce count
      BIGchar2long(DataBuf,l,DataIndex);    	// get ID, increment index

      Retcode = -9;				// set ID Error
      if(l != ENTRY_ID) break;
      BIGchar2long(DataBuf,l,DataIndex);    	// get rel Index, incr. index
      if(pIndexArray != NULL)  
        pIndexArray[i] = l;			// save

      Retcode = -10;
      BIGchar2long(DataBuf,l,DataIndex);    	// get Container length
      if((l <= 0) || (l > MAX_CONTAINER_LEN)) break;
      //----------------------------------------------------------------
      // save data for Container (offset, length), skip in buffer
      //----------------------------------------------------------------
      ContainerLen = (int) l & 0xFFFF;
      pAsn1ContDatArray[i]->Off = (int) DataIndex;// Start of Container
      pAsn1ContDatArray[i]->Len = ContainerLen;	// length
      Retcode = -11;				// set Length Error
      if(ContainerLen > Length) break;
      Length -= ContainerLen;		// reduce length
      DataIndex += ContainerLen;
      //----------------------------------------------------------------
      // Get Alias Name length, check save data
      //----------------------------------------------------------------
      Retcode = -12;				// set length Error
      if(Length < 4) break;
      Retcode = -13;
      BIGchar2long(DataBuf,l,DataIndex);    	// get Name length
      if((l < 0) || (l > MAX_CONT_ALIAS_NAME_LEN)) break;

      NameLen = (int) l & 0xFFFF;
      if(pNameDatArray != NULL)
      {
        pNameDatArray[i]->Off = (int) DataIndex;// Start of name
        pNameDatArray[i]->Len = NameLen;	// length
      }
      Retcode = -14;
      if(NameLen > Length) break;
      Length -= NameLen;		// reduce length
      DataIndex += NameLen;
      i++;
    }while(i < ContainerCnt);
    if(i == ContainerCnt) Retcode = 0;
    break;
  } // ERROR FOR
  if(Retcode != 0)
  {
    FREE_ARRAY(HMEM_CTX_REF,pIndexArray);
    FreeIDATPARR_Struc(HMEM_CTX_REF1 pAsn1ContDescArr);
    FreeIDATPARR_Struc(HMEM_CTX_REF1 pNameDescArr);
    return(Retcode);
  }
  if(ppIndexArray != NULL)
    ppIndexArray[0] = pIndexArray;
  ppAsn1ContDescArr[0] = pAsn1ContDescArr;
  if(ppNameDescArr != NULL)
    ppNameDescArr[0] = pNameDescArr;
  pEntryCnt[0] = ContainerCnt;
  return(Retcode);
}

/**
* Generates a new configuration structure from configuration file data (ExtractConfigDataEx).
*
* Extracts configuration data from
* configuration file databuffer, checks correct hashes,flags and lengths.
*
* NOTE: New Version: <ol>
*  <li> Allocates config structure, fills structure from
*	    configuration data
*	<li> If extended Configuration Data are present and
*	    user wants this data, then a buffer is allocated
*	    and filled with the extended configuration data
*	    and returned, also its size.
*</ol>
*  @param DataBuf Configuration data buffer (incl. header)
*  @param DataOff Start of configuration data
*  @param DataLen Length of configuration data (incl. header)
*  @param PwdBuf Password base
*  @param PwdOff Start of password data
*  @param PwdLen Length of password
*  @param Type 1 - Server <br>
*               2 - Client
*
*  @param ppCfgStr Return pointer for generated structure
*  @param ppExtCfgBuf Return pointer for extended config buffer. Optional
*  @param pExtCfgLen Return pointer for size of ext. config. Optional. 
*                    Required, if ppExtCfgBuf != NULL.
*  @param pPwdExpireTime Return pointer for password UTC expire time. Optional
*
*  @return 0 - o.k.
* <br>            <> 0 Error occurred:
* <br>            -1 Null Pointer
* <br>            -2 invalid type
* <br>            -3 invalid Data length
* <br>            -4 invalid header
* <br>            -5 invalid flags
* <br>            -6 allocate error
* <br>            -7 invalid hashes
*/
extern "C"  int  ExtractConfigDataEx(HMEM_CTX_DEF
	char* DataBuf, int DataOff,
	int DataLen, char* PwdBuf, int PwdOff, int PwdLen, int Type,
	CFG_STRU ** ppCfgStr, char** ppExtCfgBuf,
	int* pExtCfgLen, int* pPwdExpireTime)
{
  int   TmpInt, Index;
  int	Version, ConfigFlags, CiphListLen, CmprListLen;
  int TmpBit32,SubjNamesListLen,ExtCfgLen,lDataLen;

  char* pCmprBuf;
  char* pCiphBuf;
  char* pSubjNamesList = NULL;
  char* pExtCfgBuf = NULL;

  CFG_STRU * pCfgStruc = NULL;
  //------------------------------------------
  // check parameters
  //------------------------------------------
  if((DataBuf == NULL) || (PwdBuf == NULL) || (ppCfgStr == NULL) ||
     ((ppExtCfgBuf != NULL) && (pExtCfgLen == NULL)))
    return(-1);
  if((Type < FILE_TYPE_SRVR_CFG) || (Type > FILE_TYPE_CLNT_CFG))
    return(-2);

  if((DataLen <= FILE_HEADER_LEN) ||
     (PwdLen <= 0) || (PwdLen > MAX_PASSWORD_LEN))
    return(-3);

  //------------------------------------------
  // preset return parameters
  //------------------------------------------
  ppCfgStr[0] = NULL;
  if(ppExtCfgBuf != NULL)
    ppExtCfgBuf[0] = NULL;

  if(pExtCfgLen != NULL)
    pExtCfgLen[0] = 0;
  //-------------------------------------------------------
  // check header fixed portion
  //-------------------------------------------------------
  if(GenVfyFixedFileHdrs(DataBuf, DataOff, FILE_HEADER_LEN, Type, 1) != 0)
    return(-4);

  BIGchar2wordn(DataBuf,ConfigFlags,DataOff + FILE_HDR_PROTO_INDEX);
  if((((ConfigFlags & 0x03) == 0) && ((ConfigFlags & (0x18 << 8)) == 0)) ||
     (((ConfigFlags & 0x04) != 0) && (Type == FILE_TYPE_CLNT_CFG)))
    return(-5);
  //----------------------------------------------------------------
  // Get Compression and Ciphersuites list sizes, check
  //----------------------------------------------------------------
  BIGchar2wordn(DataBuf,Version,DataOff+FILE_HDR_VERSION_INDEX); // get version
  BIGchar2wordn(DataBuf,CiphListLen,DataOff+FILE_HDR_CIPHSUITES_LEN_INDEX);
  BIGchar2wordn(DataBuf,CmprListLen,DataOff+FILE_HDR_CMPRMETHODS_LEN_INDEX);

  if((CmprListLen > COMPR_TYPES_MAX_COUNT) ||
     (CiphListLen > (CIPHER_SUITES_MAX_COUNT*2)))
    return(-3);
  //-----------------------------------------------------------
  // Get Subject Names list length, NOTE: V1.0 had only a Big16
  //-----------------------------------------------------------
  if(Version == FILE_VERSION1_REV0)
  {
    BIGchar2wordn(DataBuf,SubjNamesListLen,
                  DataOff+FILE_HDR_SUBJ_NAMELST_LEN_INDEX);
  }
  else
  {
    BIGchar2longn(DataBuf,SubjNamesListLen,
		  DataOff+FILE_HDR_SUBJ_NAMELST_LEN_INDEX);
  }
  //-----------------------------------------------------------
  // Get Extended configuration length (since V1.2)
  //-----------------------------------------------------------
  ExtCfgLen = 0;
  if(Version >= FILE_VERSION1_REV2)
  {
    BIGchar2longn(DataBuf, ExtCfgLen, DataOff + FILE_HDR_EXT_CFG_LEN_INDEX);
  }
  //-------------------------------------------------
  // Check total data size against given
  //-------------------------------------------------
  lDataLen = CiphListLen + CmprListLen + SubjNamesListLen + ExtCfgLen;
  if((lDataLen != (DataLen - FILE_HEADER_LEN)) || (CiphListLen == 0) ||
     ((CiphListLen & 0x01) != 0) || (CmprListLen == 0) ||
      (CmprListLen > 0xFF))
    return(-3);
  //------------------------------------------------------
  // check the hashes
  //------------------------------------------------------
  if(GenVfyPwdMD5Hashes(DataBuf,DataOff,FILE_HEADER_LEN,
		  DataBuf,DataOff+FILE_HEADER_LEN,
                  DataLen-FILE_HEADER_LEN,
		  PwdBuf,PwdOff, PwdLen, 1) != 0)
    return(-7);

  //------------------------------------------------------
  // report the password expire time if requested
  //------------------------------------------------------
  if(pPwdExpireTime != NULL)
  {
    BIGchar2longn(DataBuf,pPwdExpireTime[0],
                  DataOff+FILE_HDR_PWD_EXPIRE_TIME_INDEX);
  }
  //-------------------------------------------------------
  // allocate configuration structure, clear it
  //-------------------------------------------------------
  pCfgStruc = (CFG_STRU *)
    ((void *) BIT8_ARRAY_ALLOC(HMEM_CTX_REF,sizeof(CFG_STRU)));

  if(pCfgStruc != NULL)
    memset(pCfgStruc,0,sizeof(CFG_STRU));
  if(pCfgStruc == NULL)
    return(-6);
  
  //-------------------------------------------------------
  // Fill the Structure with values from the fixed header
  //-------------------------------------------------------
  if(Type == FILE_TYPE_SRVR_CFG)
    pCfgStruc->Entity	 = SERVER_ENTITY;
  else
    pCfgStruc->Entity	 = CLIENT_ENTITY;

  pCfgStruc->ProtFlags	 = (unsigned char) ConfigFlags;
  pCfgStruc->ExtConfigFlags	 = (unsigned char) (ConfigFlags >> 8);

  BIGchar2longn(DataBuf,TmpBit32,DataOff+FILE_HDR_CACHE_AGING_TIME_INDEX);
  pCfgStruc->CacheAgingTime	 = TmpBit32;

  BIGchar2longn(DataBuf,TmpBit32,DataOff+FILE_HDR_RENEGOTIATE_TIME_INDEX);
  pCfgStruc->RenegotiateTime = TmpBit32;

  BIGchar2wordn(DataBuf,TmpInt,DataOff+FILE_HDR_CERT_POLICIES_INDEX);
  pCfgStruc->CertPolicyFlags = (short) TmpInt;

  BIGchar2wordn(DataBuf,TmpInt,DataOff+FILE_HDR_MAX_CONNECTIONS_INDEX);
  if(TmpInt == 0)
  {
    if(Type == FILE_TYPE_SRVR_CFG)
      TmpInt = SERVER_DEFAULT_CONNECTIONS;
    else
      TmpInt = CLIENT_DEFAULT_CONNECTIONS;
  }
  pCfgStruc->MaxConnCount	 = (int) TmpInt & 0x0FFFF;

  BIGchar2wordn(DataBuf,TmpInt,DataOff+FILE_HDR_CONNECT_TIMEOUT_INDEX);
  if(TmpInt == 0)				// not set
    TmpInt = DEFAULT_CONNECT_TIMEOUT;
  pCfgStruc->ConnectTimeout	 = (short) TmpInt;

  BIGchar2wordn(DataBuf,TmpInt,DataOff+FILE_HDR_EXT_CFG2_FLAGS_INDEX);
  pCfgStruc->ExtConf2Flags	 = (short) TmpInt;
  //------------------------------------------------------------
  // allocate buffers for Subject names list and extended config
  //------------------------------------------------------------
  if(SubjNamesListLen != 0)
  {
    pSubjNamesList = BIT8_ARRAY_ALLOC(HMEM_CTX_REF,(int) SubjNamesListLen);
    if(pSubjNamesList == NULL)
    {
      FREE_ARRAY(HMEM_CTX_REF,pCfgStruc);
      return(-6);
    }
  }

  if((ExtCfgLen != 0) && (ppExtCfgBuf != NULL))
  {
    pExtCfgBuf = BIT8_ARRAY_ALLOC(HMEM_CTX_REF,(int) ExtCfgLen);
    if(pExtCfgBuf == NULL)
    {
      FREE_ARRAY(HMEM_CTX_REF,pCfgStruc);
      return(-6);
    }
    ppExtCfgBuf[0] = pExtCfgBuf;
    pExtCfgLen[0]  = ExtCfgLen;
  }
  //------------------------------------------
  // Copy the lists
  //------------------------------------------
  Index = DataOff + FILE_HEADER_LEN;

  pCiphBuf = BIT8_ARRAY_ALLOC(HMEM_CTX_REF,(int) CiphListLen+2);
  if(pCiphBuf == NULL){
      FREE_ARRAY(HMEM_CTX_REF,pCfgStruc);
      return (-6);
  }
  pCfgStruc->CipherSuitesList = pCiphBuf;
  BIGword2charn(CiphListLen,pCiphBuf,0);	// set length bytes
  memcpy(pCiphBuf+2,DataBuf+Index,CiphListLen);
  Index += CiphListLen;

  pCmprBuf = pCfgStruc->CmprMethodsList;
  pCmprBuf[0] = (unsigned char) CmprListLen;
  memcpy(pCmprBuf+1,DataBuf+Index,CmprListLen);
  Index += CmprListLen;

  if(SubjNamesListLen != 0)
  {
    memcpy(pSubjNamesList+0,DataBuf+Index,(int) SubjNamesListLen);
    Index += SubjNamesListLen;
  }

  if(pExtCfgBuf != NULL)
  {
    memcpy(pExtCfgBuf+0,DataBuf+Index,(int) ExtCfgLen);
    Index += ExtCfgLen;
  }
    
  //-------------------------------------------------------------
  // save buffer pointers to structures
  //-------------------------------------------------------------
  pCfgStruc->SubjCNamesListPtr = pSubjNamesList;
  ppCfgStr[0] = pCfgStruc;

  return(0);
}

/**
* Extracts requested information
* from configuration file header in given buffer (GetConfigHeaderInfo).
*
*  @param HdrBuf Buffer of header
*  @param HdrOff Start of data
*  @param HdrLen Length of header
*  @param QueryType Type of data requested
*  @param pQueryRetValue Returned data
*
*  @return 0 - o.k.,
* <br>            -1 - no data present/Null-Pointer
* <br>            -2 - too few data
* <br>            -3 - invalid Data (Magic/Vers.)
* <br>            -4 - invalid type
* <br>            -5 - no return-Pointer/invalid Query type
*/
extern "C"  int  GetConfigHeaderInfo(char* HdrBuf, int HdrOff,
		int HdrLen, int QueryType, int* pQueryRetValue)
{
  char* pIDStr=NULL;

  int i,j,FileType,FileVersion;
  int ConfigFlags,ExtCfg2Flags;
  //--------------------------------------------------
  // initial checks on parameters
  //--------------------------------------------------
  if((HdrBuf == NULL) || (HdrLen == 0)) return(-1);
  if(HdrLen < FILE_HDR_FILE_ID_INDEX+FILE_HDR_ID_LEN) return(-2);
  if(pQueryRetValue == NULL) return(-5);
  //--------------------------------------------------
  // Verify header
  //--------------------------------------------------
  BIGchar2wordn(HdrBuf,i,FILE_HDR_MAGIC_INDEX);
  if(i != FILE_MAGIC_NUMBER) return(-3);
  BIGchar2wordn(HdrBuf,FileVersion,FILE_HDR_VERSION_INDEX);
  if((FileVersion < FILE_VERSION1_REV0) ||
     (FileVersion > FILE_VERSION1_REV3))
    return(-3);
  //--------------------------------------------------
  // Check if known File Header ID-String
  //--------------------------------------------------
  FileType = -1;			// preset invalid
  j = FILE_TYPE_VPN_CERT_REQ;		// max. ID Index + 1
  do
  {
    pIDStr = IDStrTab[j-1];
    if(CmpBit8Arrays(HdrBuf,HdrOff+FILE_HDR_FILE_ID_INDEX,pIDStr,0,FILE_HDR_ID_LEN) == 0)
    {
      FileType = j;
      break;
    }
    j--;
  }while(j != 0);
  if(FileType < 0)
    return(-4);
  //--------------------------------------------------------------
  // Fetch Config/Ext config and additional Ext config flags
  //--------------------------------------------------------------
  BIGchar2wordn(HdrBuf,ConfigFlags,HdrOff + FILE_HDR_PROTO_INDEX);
  BIGchar2wordn(HdrBuf,ExtCfg2Flags,HdrOff+FILE_HDR_EXT_CFG2_FLAGS_INDEX);
  switch(QueryType)
  {
    case HQRY_CFG_FILETYPE:
      pQueryRetValue[0] = FileType;
      break;

    case HQRY_CFG_CFGFLAGS:
      pQueryRetValue[0] = (ConfigFlags & 0xFF); // Protocol Flags
      break;

    case HQRY_CFG_EXTCFGFLAGS:
      pQueryRetValue[0] = ((ConfigFlags >> 8) & 0xFF); // Ext Config Flags
      break;

    case HQRY_CFG_CFGEXTCFGFL:
      pQueryRetValue[0] = ConfigFlags;	// both, Proto: Bit 7-0, Ext: Bit 15-8
      break;

    case HQRY_CFG_ADDEXTCFGFL:
      pQueryRetValue[0] = ExtCfg2Flags;	// additional flags
      break;

    case HQRY_CFG_FULLFLAGS:
      pQueryRetValue[0] = (ExtCfg2Flags << 16) | ConfigFlags; // all
      break;

    case HQRY_FILE_VERSION:
      pQueryRetValue[0] = FileVersion;
      break;

    default:
      return(-5);
  }
  return(0);
}

/**
* Subroutine IsSingleConfig returns boolean information
* from configuration file header in given buffer (IsSingleConfig).
* The returned bit information determines, if there must
* be a certificate database file available or not and if
* there are certificates available in an external store.
* Both cases are not(!) mutually exclusive.
*
*  @param pDataBuf Buffer of data
*  @param DataLen Length of data
*  @param pRetValue Returned data
*               Bit 0: 0 = cdb-file needed
*               1 = no cdb-file available
*               Bit 4: 0 = no external store
*               1 = external store needed
*
*  @return int Status 0 - o.k.,
* <br>            -1 - no data present/Null-Pointer
* <br>            -2 - too few data/length mismatch
* <br>            -3 - invalid Data (Magic/Vers.)
* <br>            -4 - invalid type
* <br>            -5 - no return-Pointer
* <br>            -6 - verify error
*/
extern "C"  int  IsSingleConfig(char* pDataBuf, int DataLen,
                                      int* pRetValue)
{/** @todo find out real meaning of the pRetValue bits. */
  int Retcode;
  int Len;
  int pTmpRetData[2];
  //--------------------------------------------------------
  // check the input parameters
  //--------------------------------------------------------
  if((pDataBuf == NULL) || (DataLen <= 0))
    return(-1);
  Len = FILE_HEADER_LEN;
  if(DataLen < Len)
    return(-2);
  if(pRetValue == NULL)
    return(-5);
  //------------------------------------------------------------------
  // get the file type specification: file type + add ext config flags
  //------------------------------------------------------------------
  if((Retcode = GetConfigHeaderInfo(pDataBuf, 0, Len,
				HQRY_CFG_ADDEXTCFGFL,pTmpRetData)) < 0)
    return(Retcode);			// file is not compatible

  pTmpRetData[1] = pTmpRetData[0];	// add ext config flags in [1]

  if((Retcode = GetConfigHeaderInfo(pDataBuf, 0, Len,
				 HQRY_CFG_FILETYPE, pTmpRetData)) < 0)
    return(Retcode);			// file is not compatible
  //------------------------------------------------------------------
  // Verify that the File Header is correct
  //------------------------------------------------------------------
  if((Retcode = GenVfyFixedFileHdrs(pDataBuf,0,Len,
				    (int) pTmpRetData[0], 1)) != 0)
    return(Retcode);			// verify file failed
  //------------------------------------------------------
  // Decide on Configuration Flags if CDB File needed
  //------------------------------------------------------
  pRetValue[0] = 0;		// assume CDB file needed / no external store
  if(pTmpRetData[0] == FILE_TYPE_CLNT_CFG)	// is a 'CLIENT' Config
  {
    if((pTmpRetData[1] & CFG2_CERTS_EXT_STORE_BIT_MASK) != 0)
    {   // 0x100 = certificates are in an external store
      pRetValue[0] |= 0x10;			// ext. store available
      if ((pTmpRetData[1] & CFG2_ADD_CERT_IN_CDB_BIT_MASK) == 0)
        // 0x200 = additional certificates are in a cdb-file
         pRetValue[0] |= 0x01;			// no cdb-file needed
    }
  }
  return(0);
}

/**
* Generates certificate/req. file header/databuffer and hashes (GenerateCertData).
*
* NOTE: The data are copied to the destination buffer, so
*  the source arrays may be freed.
*
* The destination buffer is allocated by this function.
*
*  @param PwdBuf Password base
*  @param PwdOff Start of password data
*  @param PwdLen Length of password
*  @param ExpireTime UTC time. if 0 never expires
*  @param Type 3 - Server certificate
*               4 - Client certificate
*               5 - Server certificate req.
*               6 - Client certificate req.
*               12 - VPN certificate
*               13 - VPN certificate req.
*  @param ContainerCnt Number of containers
*  @param IndexArray Array with the rel. indices
*  @param pAsn1ContDesc Array with the containers
*  @param pNameDesc Array with the names
*
*  @param ppDst Destination buffer pointer
*  @param pDstLen Returned length of generated data
*
*  @return 0 - o.k.
* <br>            <> 0 Error occurred:
* <br>            -1 Null Pointer
* <br>            -2 invalid Type
* <br>            -3 invalid Data length
* <br>            -4 invalid Container count
* <br>            -5 allocate error
*/
extern "C"  int  GenerateCertData(HMEM_CTX_DEF
		char* PwdBuf, int PwdOff,
		int PwdLen, int ExpireTime, int Type,
		int ContainerCnt, int* IndexArray,
		IDATPARR* pAsn1ContDesc,
		IDATPARR* pNameDesc,
		char** ppDst, int* pDstLen)
{

  char* pBuf;
  char* pSrc;

  int i;

  int Index;
  int SrcIndex;
  int SrcLen;
#if !defined _WIN32
  unsigned int DataLen=0;
#else
  int DataLen=0;
#endif // WIN32/64
  int ContainerLen;
  int NameLen;

  IDATA** pAsn1ContDatArray;
  IDATA** pNameDatArray;

  //------------------------------------------
  // check parameters
  //------------------------------------------
  if((PwdBuf == NULL) || (IndexArray == NULL) || (pAsn1ContDesc == NULL) ||
     (pNameDesc == NULL) || (ppDst == NULL) || (pDstLen == NULL)) return(-1);

  ppDst[0] = NULL;
  pDstLen[0] = 0;

  if((Type < FILE_TYPE_SRVR_CERT) ||
     (Type > FILE_TYPE_VPN_CERT_REQ)) return(-2);

  if((PwdLen == 0) || (PwdLen > MAX_PASSWORD_LEN))
    return(-3);
  if((ContainerCnt <= 0) || (ContainerCnt > MAX_CONT_COUNT)) return(-4);
  //-----------------------------------------------------------------
  // get the required Destination buffer size from the array contents,
  // allocate the buffer
  //-----------------------------------------------------------------
  pAsn1ContDatArray = pAsn1ContDesc->ppArr;
  pNameDatArray     = pNameDesc->ppArr;

  i=0;
  do
  {
    ContainerLen = pAsn1ContDatArray[i]->Len;
    NameLen      = pNameDatArray[i]->Len;
    if((ContainerLen <= 0) || (ContainerLen > MAX_CONTAINER_LEN) ||
       (NameLen > MAX_CONT_ALIAS_NAME_LEN))
    {
//    if(ContainerLen > MAX_CONTAINER_LEN)		// TEST TEST TEST
//      PRINT("Larger Than Max");			// TEST TEST TEST
      return(-3);
    }
    DataLen += (ContainerLen + NameLen + ENTRY_HDR_LEN + 4);    
    i++;
  }while(i < ContainerCnt);      
  //------------------------------------------
  // Allocate necessary buffer
  //------------------------------------------
  pBuf = BIT8_ARRAY_ALLOC(HMEM_CTX_REF,DataLen+FILE_HEADER_LEN);
  if(pBuf == NULL) return(-5);
  ppDst[0] = pBuf;
  pDstLen[0] = DataLen + FILE_HEADER_LEN;
  //----------------------------------------------------------
  // Generate the header, set the Container count
  //----------------------------------------------------------
  GenVfyFixedFileHdrs(pBuf,0,FILE_HEADER_LEN,Type,0);
  BIGlong2charn(ExpireTime,pBuf,FILE_HDR_PWD_EXPIRE_TIME_INDEX);
  BIGlong2charn(ContainerCnt,pBuf,FILE_HDR_ENTRY_CNT_INDEX);
  //------------------------------------------------------
  // generate the container entries
  //------------------------------------------------------
  Index = FILE_DATA_START_INDEX;
  i = 0;
  do
  {
    BIGlong2char(ENTRY_ID,pBuf,Index);		// set Entry ID
    BIGlong2char(IndexArray[i],pBuf,Index);	// set rel. index
    SrcLen = pAsn1ContDatArray[i]->Len;	// get Container length
    BIGlong2char((int) SrcLen,pBuf,Index);	// set

    pSrc = pAsn1ContDatArray[i]->Base;	// source buffer
    SrcIndex = (int) pAsn1ContDatArray[i]->Off;	// start of data
    memcpy(pBuf+Index,pSrc+SrcIndex,SrcLen); // copy Data

    Index += SrcLen;				// position past Container

    SrcLen = pNameDatArray[i]->Len;	// length of Name
    BIGlong2char((int) SrcLen,pBuf,Index);	// set
    if(SrcLen != 0)
    {
      pSrc = pNameDatArray[i]->Base;	// source buffer
      SrcIndex = (int) pNameDatArray[i]->Off;	// start of data
      memcpy(pBuf+Index,pSrc+SrcIndex,SrcLen); // copy Data
      Index += SrcLen;				// position past Name
    }
    i++;
  }while(i < ContainerCnt);
  //------------------------------------------------------
  // Generate the data hashes
  //------------------------------------------------------
  GenVfyPwdMD5Hashes(pBuf,0,FILE_HEADER_LEN,
		     pBuf,FILE_DATA_START_INDEX, DataLen,
		     PwdBuf, PwdOff, PwdLen, 0);
  return(0);
}

/**
* Extracts an element from the extended configuration data
* specified by the associated TAG (GetExtCfgDataByTag).
*
* NOTE: TAG and LEN of the elements in the extended data are
*  stored as 16 bit BIG endian.
*
* The extracted data is copied to a newly allocated buffer.
*
*  @param ExtensionTagID TAG of the data
*  @param pExtensionData Buffer with extension data
*  @param ExtensionOff Start of data in buffer
*  @param ExtensionLen Size of extension data
*  @param ppTagDataBuf Pointer to return the new data buffer
*  @param pTagDataLen Pointer to return the data length. <0, if tag not found
* 
*  @return 0 o.k., else error occurred
*/
extern "C"  int  GetExtCfgDataByTag(HMEM_CTX_DEF
	int ExtensionTagID,
	char* pExtensionData, int ExtensionOff, int ExtensionLen,
	char** ppTagDataBuf, int* pTagDataLen)
{
  int wTagID;
  int wTagValLen;
  int ActTagID;
  int ActTagValLen;

  char* pDataBuf;

  if((pExtensionData == NULL) ||
     (ppTagDataBuf == NULL) || (pTagDataLen == NULL))
    return(HSSL_NULL_PTR);

  ppTagDataBuf[0] = NULL;
  pTagDataLen[0]  = -1;

  //---------------------------------------------------------------
  // Find the TAG if present
  //---------------------------------------------------------------
  while(ExtensionLen > 0)
  {
    //-----------------------------------------------------
    // get next TAG and LEN field
    //-----------------------------------------------------
    if(ExtensionLen < 4)			// incomplete TAG/LEN
      return(HSSL_CFG_EXTCFG_DATA_INCOMPLETE);

    BIGchar2word(pExtensionData,wTagID,ExtensionOff);
    BIGchar2word(pExtensionData,wTagValLen,ExtensionOff);
    ExtensionLen -= 4;
    ActTagID     = (int) wTagID & 0x0FFFF;
    ActTagValLen = (int) wTagValLen & 0x0FFFF;

    if(ExtensionTagID == ActTagID)
    {
      //---------------------------------------------------
      // found the TAG, check if it has data associated
      //---------------------------------------------------
      if(ActTagValLen <= 0)
      {
        pTagDataLen[0] = 0;			// no data, no buffer
        return(HSSL_OP_OK);
      }
      if(ExtensionLen < (int) ActTagValLen)
        return(HSSL_CFG_EXTCFG_DATA_INCOMPLETE);

      if((pDataBuf = BIT8_ARRAY_ALLOC(HMEM_CTX_REF,
				      (int) ActTagValLen)) == NULL)
        return(HSSL_ALLOC_ERR);

      memcpy(pDataBuf+0,pExtensionData+ExtensionOff,(int) ActTagValLen);
      ppTagDataBuf[0] = pDataBuf;
      pTagDataLen[0]  = (int) ActTagValLen;
      return(HSSL_OP_OK);
    }
    //------------------------------------------------------
    // not the requested TAG, skip the data...
    //------------------------------------------------------
    if(ActTagValLen > 0)
    {
      ExtensionOff += ActTagValLen;
      ExtensionLen -= ActTagValLen;
    }
  }
  return(HSSL_OP_OK);
}

/**
* Gets version number information of the
* SSL-Module as 32 bit int and/or ASWCIIz string (HSSL_GetVersionInfo).
*
* The required buffer size for the string will be returned when
* the supplied buffer pointer is NULL and the size pointer is
* non NULL.
* If Version number is not required, use NULL for pVersion.
*
*  @param pVersion Version: Byte 0 - Version
*               Byte 1 - Revision
*               Byte 2 - Release Major
*               Byte 3 - Release Minor
*  @param pDstBuf Buffer for string data
*  @param pDstLen Size of string data buffer, IN/OUT
*  @return 0 - o.k., else error occurred
*/
extern "C"  int HSSL_GetVersionInfo(int* pVersion,  
				      char* pDstBuf, int* pDstLen)
{
  int BufLen;

  char VersionStr[] = HSSL_VERSION_PROD_TXT " " HSSL_VERSION_DESC_TXT
       ", Version " HSSL_VERSION_1_STR "." HSSL_VERSION_2_STR " "
       HSSL_VERSION_3_STR "." HSSL_VERSION_4_STR ", Rev. "     
       HSSL_RELEASE_MAJ_STR "." HSSL_RELEASE_MIN_STR
       ", " HSSL_VERSION_DATE_TXT;
  //------------------------------------------------------
  // Check parameters first
  //------------------------------------------------------
  if(((pVersion == NULL) && (pDstBuf == NULL) && (pDstLen == NULL)) ||
     ((pDstBuf != NULL) && (pDstLen == NULL)))
    return(HSSL_NULL_PTR);

  //------------------------------------------------------
  // Set the Version Number
  //------------------------------------------------------
  if(pVersion != NULL)
  {
    pVersion[0] = (HSSL_VERSION_3_NO << 24) |
                  (HSSL_VERSION_4_NO << 16) |
	          (HSSL_RELEASE_MAJ_NO << 8) |
		  (HSSL_RELEASE_MIN_NO);
  }
  //------------------------------------------------------
  // Check if string is requested...
  //------------------------------------------------------
  if(pDstLen != NULL)
  {
    //----------------------------------------------------------
    // Get required buffer size, check if only size is requested
    //----------------------------------------------------------
    BufLen = (int) strlen(VersionStr);

    if(pDstBuf == NULL)
    {
      pDstLen[0] = BufLen + 1;
      return(HSSL_OP_OK);
    }
    //-----------------------------------------------------
    // Check buffer size given
    //-----------------------------------------------------
    if(pDstLen[0] <= BufLen)
    {
      pDstLen[0] = BufLen + 1;
      return(HSSL_PARAM_ERR);
    }

    //-----------------------------------------------------
    // Copy String to user buffer
    //-----------------------------------------------------
    pDstLen[0] = BufLen;			// exclusive NUL !
    memcpy(pDstBuf,VersionStr,BufLen);
    pDstBuf[BufLen] = 0;			// delimiting NUL
  }
  return(HSSL_OP_OK);
}

#if defined XH_INTERFACE
/**
* Wrapper for HSSL_GetVersionInfo (m_hssl_getversioninfo).
*
*  @param pVersion Version: Byte 0 - Version
*               Byte 1 - Revision
*               Byte 2 - Release Major
*               Byte 3 - Release Minor
*  @param pDstBuf Buffer for string data
*  @param pDstLen Size of string data buffer, IN/OUT
*  @return 0 - o.k., else error occurred
*/
extern "C"  int m_hssl_getversioninfo(int* pVersion,  
				      char* pDstBuf, int* pDstLen)
{
  int Retcode;
  int pTmpVersion[1];

  if(pVersion == NULL)
  {
    Retcode = HSSL_GetVersionInfo(NULL, pDstBuf, pDstLen);
  }
  else
  {
    Retcode = HSSL_GetVersionInfo(pTmpVersion, pDstBuf, pDstLen);
    pVersion[0] = (int) pTmpVersion[0];
  }
  return(Retcode);
}
#endif // defined XH_INTERFACE

/** @} */


#endif //HL_SSL_GLIB
// end of file ../hssl/hsslglib.cpp


#ifdef HL_SSL_CACHE
#ifdef XH_INTERFACE
/** @defgroup sslcache SSL session cache module for WSP
* This module provides SSL/TLS session cache functions for the WSP.
*
* It is made purely for use with the WSP and requires some of it's 
* functionality, most notably the CMA.
*
* There are distinct areas within a cache control structure for server
* and client cache and also different functions to manipulate either.
*@{
*@file
* This file contains the main functional implementation for the SSL/TLS 
* session cache module.
*@}
*/
#if (defined _WIN32) & (_MSC_VER < 1700)
#ifndef _STDINT
#define _STDINT
// MSVC lower than 17.00 does not have stdint.h, assure, all needed types are defined

typedef unsigned __int16 uint16_t;

typedef unsigned __int32 uint32_t;

typedef unsigned __int64 uint64_t;

#endif // !_STDINT
#else
#include <stdint.h>
#endif
#include <stddef.h>
#ifdef _WIN32
#define WIN32_LEAN_AND_MEAN
#include <Windows.h>
#undef WIN32_LEAN_AND_MEAN
#else// Define system-specific HL_* defines here
#ifndef HL_UNIX
#define HL_UNIX

#if (defined __gnu_linux__) || (defined __linux__)
#define HL_LINUX
#endif

#if (defined __APPLE__) && (defined __MACH__)
#define HL_LINUX
#define HL_MACOS
#endif

#ifdef _AIX
#define HL_AIX
#define HL_BIG_ENDIAN
#endif

#ifdef __FreeBSD__
#define HL_FREEBSD
#endif

#if (defined _hpux) || (defined hpux) || (defined __hpux)
#define HL_HPUX
#define HL_BIG_ENDIAN
#endif

#if (defined sun) || (defined __sun)
#define HL_SOLARIS
#endif

#if (defined __arm__) || (defined __aarch64__)
#define HL_LINUX_ARM
#endif

#ifdef __ANDROID__
#define HL_ANDROID
#endif

#endif
#include <hob-unix01.h>
#endif
#ifdef __APPLE__
/* We get target conditionals to keep apart Mac OS, iOS and iOS simulator.
   The conditionals are TARGET_IPHONE_SIMULATOR, TARGET_OS_IPHONE and TARGET_OS_MAC.
   TARGET_IPHONE_SIMULATOR has the highest priority, TARGET_OS_MAC the lowest.
   Always test, if the conditional is 1, as they will be defined as 0, if we 
   are not compiling for the target.
   */
#include <TargetConditionals.h>
#endif

#ifdef HL_ANDROID
#include <sys/endian.h>
#endif

#include "hob-encry-1.h"
#include "hob-cert-ext.h"
#if !(defined __HOB_XSCLIB01__) && !(defined DEF_IFUNC_START)
#define __HOB_XSCLIB01__

#include <hob-xsclib01.h>
#endif // !__HOB_XSCLIB01__
#include <stdlib.h>
#include <hob-encry-2.h>
#include "hob-ssl-intern.h"
#include "hob-ssl-err.h"
#include "hob-ssl-err.h"


#if !(defined HL_IWT) && (defined HAVE_dsd_aux_query_client_server)
//===================================================================
// Global variables
//===================================================================
#define SSL_SESSION_CACHE_CMA_NAME_LEN	9		// in elements !

static HL_WCHAR SslServerCacheCMAName[10] = {
   (HL_WCHAR) 'S',  (HL_WCHAR) 'S',  (HL_WCHAR) 'L',  (HL_WCHAR) 'S',
   (HL_WCHAR) 'C',  (HL_WCHAR) 'A',  (HL_WCHAR) 'C',  (HL_WCHAR) 'H',
   (HL_WCHAR) 'E',  (HL_WCHAR) 0
};

static HL_WCHAR SslClientCacheCMAName[10] = {
   (HL_WCHAR) 'S',  (HL_WCHAR) 'S',  (HL_WCHAR) 'L',  (HL_WCHAR) 'C',
   (HL_WCHAR) 'C',  (HL_WCHAR) 'A',  (HL_WCHAR) 'C',  (HL_WCHAR) 'H',
   (HL_WCHAR) 'E',  (HL_WCHAR) 0
};

int    ServerCacheInitDataSet       = 0;
uint32_t ServerCacheCmaSize	    = 0;	// total size of CMA
uint32_t ServerCacheMaxEntriesCount   = 0;
uint32_t ServerCacheElementTimeToLive = 0;

int    ClientCacheInitDataSet       = 0;
uint32_t ClientCacheCmaSize	    = 0;	// total size of CMA
uint32_t ClientCacheMaxEntriesCount   = 0;
uint32_t ClientCacheElementTimeToLive = 0;

/** @addtogroup sslcache
*@{
*/
/** @todo check and if necessary rework the session caching. */
/**
* Checks, if the AUX-Interface supports CMA operations (CheckAuxCMASupport).
*
* --- needed for XH-Interface library users that have no CMA ---
*
*  @param CacheType 0-Server, else Client cache
*  @return > 0 Interface supported 
* <br>            == 0 Interface not supported
* <br>            < 0 Error occured
*/
extern "C" int CheckAuxCMASupport(HMEM_CTX_DEF int CacheType)
{
   int Retcode;

   struct dsd_hl_aux_c_cma_1 CmaCmdStruc;

   //-----------------------------------------------------------------
   // 0. check correct version of XH-Interface
   //-----------------------------------------------------------------
   if(vp__ctx->in__aux_up_version < 1)	// invalid version XH-Interface!
      return(HSSL_PARAM_ERR);

   //-----------------------------------------------------------------
   // 1. Setup CMA Query command data for SSL Cache control structure
   //-----------------------------------------------------------------
   if(CacheType == 0)			// Server side
      CmaCmdStruc.ac_cma_name    = SslServerCacheCMAName;
   else
      CmaCmdStruc.ac_cma_name    = SslClientCacheCMAName;
   CmaCmdStruc.iec_chs_name     = ied_chs_utf_16;
   CmaCmdStruc.inc_len_cma_name = SSL_SESSION_CACHE_CMA_NAME_LEN;
   CmaCmdStruc.ac_cma_handle    = NULL;
   CmaCmdStruc.achc_cma_area    = NULL;
   CmaCmdStruc.iec_ccma_def     = ied_ccma_query;
   //-----------------------------------------------------------------
   // 2. Query the CMA by name (may/may not exist)
   //-----------------------------------------------------------------
   Retcode = vp__ctx->am__aux2(vp__ctx->vp__context,
      DEF_AUX_COM_CMA,
      (void *) &CmaCmdStruc,0);
   if(Retcode == 0)				// no CMA support
      return(0);
   else						// CMA IS supported
      return(1);
}

/**
* Gets the SSL session cache control block from the CMA-Area, lock it.
*
* NOTE: If no server cache control block exists, generate the
*  control block (needs to be initialized!).
*
*  @param CacheType 0-Server, else Client cache
*  @param ppSessCacheCtlDesc The server session chache control block
*  @return 0 o.k., is initialized

* <br>            > 0 o.k., but needs initialization!
*/
//GetAndLockSessCacheCtlDesc
extern "C" int GetAndLockSessCacheCtlDesc(HMEM_CTX_DEF
                                          int CacheType,
                                          HSESSCACHE_CTL_DESC ** ppSessCacheCtlDesc)
{
   int Retcode;
   uint32_t CmaSize,Offset,ElementCnt;

   HSESSCACHE_CTL_DESC * pSessCacheCtlDesc = NULL;

   struct dsd_hl_aux_c_cma_1 CmaCmdStruc;

   //-----------------------------------------------------------------
   // 0. check correct version of XH-Interface
   //-----------------------------------------------------------------
   if(vp__ctx->in__aux_up_version < 1)	// invalid version XH-Interface!
      return(HSSL_PARAM_ERR);

   //-----------------------------------------------------------------
   // 1. Setup CMA Query command data for SSL Cache control structure
   //-----------------------------------------------------------------
   if(CacheType == 0)			// Server side
   {
      CmaCmdStruc.ac_cma_name    = SslServerCacheCMAName;
      CmaSize                    = ServerCacheCmaSize;
   }
   else
   {
      CmaCmdStruc.ac_cma_name    = SslClientCacheCMAName;
      CmaSize                    = ClientCacheCmaSize;
   }
   CmaCmdStruc.iec_chs_name     = ied_chs_utf_16;
   CmaCmdStruc.inc_len_cma_name = SSL_SESSION_CACHE_CMA_NAME_LEN;
   CmaCmdStruc.ac_cma_handle    = NULL;
   CmaCmdStruc.achc_cma_area    = NULL;
   CmaCmdStruc.iec_ccma_def     = ied_ccma_query;
   //-----------------------------------------------------------------
   // 2. Query the CMA by name, check if the control structure exists
   //-----------------------------------------------------------------
   Retcode = vp__ctx->am__aux2(vp__ctx->vp__context,
      DEF_AUX_COM_CMA,
      (void *) &CmaCmdStruc,0);
   if(Retcode == 0)
      return(HCMA_QUERY_CMA_ERR);

   if(CmaCmdStruc.inc_len_cma_area == 0)
   {
      //-----------------------------------------------------
      // 2.0. Lock the non existent cma now (strange)
      //-----------------------------------------------------
      CmaCmdStruc.iec_ccma_def     = ied_ccma_lock_global;
      CmaCmdStruc.imc_lock_type    = D_CMA_ALL_ACCESS;
      vp__ctx->am__aux2(vp__ctx->vp__context,
         DEF_AUX_COM_CMA,
         (void *) &CmaCmdStruc,0);
      //-----------------------------------------------------
      // 2.1. Control structure does not exist yet, create it
      //-----------------------------------------------------
      CmaCmdStruc.inc_len_cma_area = CmaSize;
      CmaCmdStruc.iec_ccma_def     = ied_ccma_set_size;
      Retcode = vp__ctx->am__aux2(vp__ctx->vp__context,
         DEF_AUX_COM_CMA,
         (void *) &CmaCmdStruc,0);
      //    memset(CmaCmdStruc.achc_cma_area,0,sizeof(HSESSCACHE_CTL_DESC));
      memset(CmaCmdStruc.achc_cma_area,0,CmaSize);
      //-----------------------------------------------------
      // 2.2. Initialize Control structure pointers
      //-----------------------------------------------------
      pSessCacheCtlDesc = (HSESSCACHE_CTL_DESC *) CmaCmdStruc.achc_cma_area;

      if(CacheType == 0)			// Server side
         ElementCnt = ServerCacheMaxEntriesCount;
      else
         ElementCnt = ClientCacheMaxEntriesCount;
      Offset = sizeof(HSESSCACHE_CTL_DESC);

      pSessCacheCtlDesc->SlotsAllocedCount = ElementCnt;	// number of elements
      pSessCacheCtlDesc->SlotsMaxAllocCount = ElementCnt; // dto. for maximum

      pSessCacheCtlDesc->pUseStateBitsList =
         (uint32_t *) ((char *) pSessCacheCtlDesc + Offset);
      Offset += ((ElementCnt + 31)/32 * sizeof(uint32_t));

      pSessCacheCtlDesc->pUtcSortedIndexArr =
         (uint32_t *) ((char *) pSessCacheCtlDesc + Offset);
      Offset += (ElementCnt * sizeof(uint32_t));

      pSessCacheCtlDesc->pIdSortedIndexArr = 
         (uint32_t *) ((char *) pSessCacheCtlDesc + Offset);
      Offset += (ElementCnt * sizeof(uint32_t));

      pSessCacheCtlDesc->pIdCompactBitList =
         (uint32_t *) ((char *) pSessCacheCtlDesc + Offset);
      Offset += ((ElementCnt + 31)/32 * sizeof(uint32_t));

      pSessCacheCtlDesc->pSessionCacheBuf =
         (unsigned char *) ((char *) pSessCacheCtlDesc + Offset);

      //-----------------------------------------------------
      // 2.3. Unlock the now existing cma
      //-----------------------------------------------------
      CmaCmdStruc.iec_ccma_def     = ied_ccma_lock_release;
      vp__ctx->am__aux2(vp__ctx->vp__context,
         DEF_AUX_COM_CMA,
         (void *) &CmaCmdStruc,0);

      if(Retcode == 0)
         return(HCMA_SETSIZE_CMA_ERR);

      if((unsigned int) CmaCmdStruc.inc_len_cma_area != CmaSize)
         return(HCMA_SETSIZE_CMA_ERR);
   }
   //-----------------------------------------------------------------
   // 3. Lock the control structure
   //-----------------------------------------------------------------
   CmaCmdStruc.iec_ccma_def       = ied_ccma_lock_region;
   CmaCmdStruc.boc_ret_lock_fails = FALSE;
   CmaCmdStruc.inc_lock_disp      = 0;
   CmaCmdStruc.inc_lock_len       = CmaSize;
   CmaCmdStruc.imc_lock_type      = D_CMA_ALL_ACCESS;
   CmaCmdStruc.vpc_cma_lock       = NULL;

   Retcode = vp__ctx->am__aux2(vp__ctx->vp__context,
      DEF_AUX_COM_CMA,
      (void *) &CmaCmdStruc,0);
   if(Retcode == 0)
      return(HCMA_LOCK_CMA_ERR);
   //-----------------------------------------------------------------
   // Session cache control structure retrieved and locked
   //-----------------------------------------------------------------
   pSessCacheCtlDesc = (HSESSCACHE_CTL_DESC *) CmaCmdStruc.achc_cma_area;

   pSessCacheCtlDesc->pds__hmem      = vp__ctx;
   pSessCacheCtlDesc->pCmaHandle     = CmaCmdStruc.ac_cma_handle;
   pSessCacheCtlDesc->pCmaLockHandle = CmaCmdStruc.vpc_cma_lock;

   *ppSessCacheCtlDesc = pSessCacheCtlDesc;

   if((pSessCacheCtlDesc->Flags & 0x01) == 0)
      return(1);				// requires basic initialization

   return(HSSL_OP_OK);			// already initialized
}
/**
* CMA Unlocks SSL session control block (UnlockSessCacheCtlDesc).
*
*  @param pSessCacheCtlDesc The server session chache control block to be unlocked
*  @return 0 on success, error code otherwise
*/
extern "C" int UnlockSessCacheCtlDesc(HSESSCACHE_CTL_DESC * pSessCacheCtlDesc)
{
   int Retcode;
   uint32_t CmaSize;
   ds__hmem * vp__ctx;

   struct dsd_hl_aux_c_cma_1 CmaCmdStruc;

   //-----------------------------------------------------------------
   // 0. Check parameters
   //-----------------------------------------------------------------
   if(pSessCacheCtlDesc == NULL)
      return(0);

   if((vp__ctx = (ds__hmem*)(pSessCacheCtlDesc->pds__hmem)) == NULL)
      return(HSSL_PARAM_ERR);

   if((pSessCacheCtlDesc->pCmaHandle == NULL) ||
      (pSessCacheCtlDesc->pCmaLockHandle == NULL))
      return(HSSL_PARAM_ERR);
   //------------------------------------------------------------------
   // 1. Setup CMA lock release command for SSL Cache control structure
   //------------------------------------------------------------------
   if((pSessCacheCtlDesc->Flags & 0x02) == 0)
      CmaSize = ServerCacheCmaSize;
   else
      CmaSize = ClientCacheCmaSize;

   CmaCmdStruc.ac_cma_name      = NULL;			// by handle !
   CmaCmdStruc.iec_chs_name     = ied_chs_utf_16;
   CmaCmdStruc.inc_len_cma_name = 0;
   CmaCmdStruc.ac_cma_handle    = pSessCacheCtlDesc->pCmaHandle;
   CmaCmdStruc.achc_cma_area    = (char *) pSessCacheCtlDesc;
   CmaCmdStruc.inc_len_cma_area = CmaSize;
   CmaCmdStruc.vpc_cma_lock     = pSessCacheCtlDesc->pCmaLockHandle;
   CmaCmdStruc.inc_lock_disp    = 0;
   CmaCmdStruc.inc_lock_len     = CmaSize;
   CmaCmdStruc.imc_lock_type    = D_CMA_ALL_ACCESS;
   CmaCmdStruc.iec_ccma_def     = ied_ccma_lock_release;

   pSessCacheCtlDesc->pds__hmem      = NULL;
   pSessCacheCtlDesc->pCmaHandle     = NULL;
   pSessCacheCtlDesc->pCmaLockHandle = NULL;

   //-----------------------------------------------------------------
   // 2. Unlock the CMA
   //-----------------------------------------------------------------
   Retcode = vp__ctx->am__aux2(vp__ctx->vp__context,
      DEF_AUX_COM_CMA,
      (void *) &CmaCmdStruc,0);

   if(Retcode == 0)
      return(HCMA_UNLOCK_CMA_ERR);

   return(HSSL_OP_OK);
}

/**
* Queries the Server/Client IP-Address and Port (for client side SSL),
* stores to given buffer (GetServerClientIP).
*
* The client address is normally not needed but can also be added on request.
*
*  @param AddSrcAddr 0 - do not store source, else store
*  @param pDstBuf Destination buffer, >= 38 byte
*  @return 0 on success, error code otherwise
*/
extern "C" int GetServerClientIP(HMEM_CTX_DEF int AddSrcAddr, char* pDstBuf)
{
   int Retcode,DstIndex,Len,Flags;

   struct dsd_aux_query_client_server AddrStruc;
   //-----------------------------------------------------------------
   // 0. check correct version of XH-Interface
   //-----------------------------------------------------------------
   if(vp__ctx->in__aux_up_version < 1)	// invalid version XH-Interface!
      return(HSSL_PARAM_ERR);

   //-----------------------------------------------------------------
   // 1. Get the addresses
   //-----------------------------------------------------------------
   Retcode = vp__ctx->am__aux2(vp__ctx->vp__context,
      DEF_AUX_QUERY_CLIENT,
      (void *) &AddrStruc,
      sizeof(struct dsd_aux_query_client_server));
   if(Retcode == 0)
   {
      //    printf("HSSL_CLNT-Test: Failed to get Address structure, RC=%d\n",Retcode);
      return(HS_CLNT_CACHE_IPADDR_FETCH_FAIL);
   }

   //  printf("Client/Server Address buffer dump:\n");
   //  DumpHexData((BIT8 *) &AddrStruc, 0, sizeof(AddrStruc));
   //---------------------------------------------------------------------
   // Copy the addresses to buffer:
   // 1 Byte Flags, 1 Byte length of address(es)
   // 4-16 byte server IP-address, 2 byte server port
   // 4-16 byte client IP-address, 2 byte client listener (!) port, optional
   //---------------------------------------------------------------------
   Flags = 0;
   if(AddrStruc.inc_srvr_addr_family == AF_INET)
      Len   = 4;
   else if(AddrStruc.inc_srvr_addr_family == AF_INET6)
   {
      Len = 16;
      Flags = CLNT_CACHE_DST_ADR_IPV6_BIT;
   }
   else					// unknown connecting address family
      return(HS_CLNT_CACHE_UNK_SRVR_ADFAMILY);

   memcpy(pDstBuf+2,AddrStruc.chrc_srvr_ineta,Len);
   DstIndex = Len+2;

   pDstBuf[DstIndex++] = (char) (AddrStruc.inc_srvr_port >> 8); 
   pDstBuf[DstIndex++] = (char) AddrStruc.inc_srvr_port; 

   if(AddSrcAddr != 0)			// with source address (if present)
   {
      if(AddrStruc.inc_addr_family == AF_INET)
      {
         Len = 4;
         Flags |= CLNT_CACHE_DST_ADR_PRESENT_BIT;
      }
      else if(AddrStruc.inc_addr_family == AF_INET6)
      {
         Len = 16;
         Flags |= (CLNT_CACHE_SRC_ADR_IPV6_BIT |
            CLNT_CACHE_DST_ADR_PRESENT_BIT);
      }
      else				// unknown connecting address family
         Len = 0;

      if(Len != 0)
      {
         memcpy(pDstBuf+DstIndex,AddrStruc.chrc_client_ineta,Len);
         DstIndex += Len;

         pDstBuf[DstIndex++] = (char) (AddrStruc.inc_port >> 8); 
         pDstBuf[DstIndex++] = (char) AddrStruc.inc_port; 
      }
   }
   pDstBuf[1] = (char) (DstIndex-2);	// exclusive length/flags !
   pDstBuf[0] = (char) Flags;

   return(HSSL_OP_OK);
}

/**
* Finds a session cache entry by session ID in the session cache sorted
* SessionID index array (FindSessSrvrCacheEntryBySessionID).
* If element is NOT found, the neighbour positions for the SessionID
* are returned.
*
* -- SERVER SIDE --
* 
* NOTE: The element array must be sorted in ascending order.
*  Returned indices are the indices into the SessionID sorted index array.
*
*  @param pSessCacheCtlDesc The used session chache control block
*  @param pSessionID ID, 1st byte is length !
*  @param pIndexBelow lower Index, -1 if none (< bottom)
*  @param pIndexAbove upper Index, -1 if none (> top)
* 
*  @return SessionID sorted array Index or -1 if not found
*/
static uint32_t FindSessSrvrCacheEntryBySessionID(
   HSESSCACHE_CTL_DESC * pSessCacheCtlDesc,
   char* pSessionID,
   uint32_t* pIndexBelow, uint32_t* pIndexAbove)
{
   int Result;
   uint32_t ActIndex, BotIndex, TopIndex, ElementIndex;
   HSERV_CACHE_ELEM * pCacheElement, * pCacheElementBase;

   uint32_t * pAccessArray;

   if(pIndexBelow != NULL)
      *pIndexBelow = (uint32_t) -1;

   if(pIndexAbove != NULL)
      *pIndexAbove = (uint32_t) -1;

   if((pSessCacheCtlDesc == NULL) ||
      ((TopIndex = pSessCacheCtlDesc->IdSlotsInUseCount) == 0))
      return((uint32_t) -1);
   //--------------------------------------------------------------
   // Search for Session ID, binary search
   // Note: Indices from 1..N !
   //--------------------------------------------------------------
   pAccessArray = pSessCacheCtlDesc->pIdSortedIndexArr;
   pCacheElementBase =
      (HSERV_CACHE_ELEM *) pSessCacheCtlDesc->pSessionCacheBuf;

   BotIndex = 1;
   for(;;)
   {
      if(TopIndex < BotIndex)		// end, not found
      {
         if(pIndexBelow != NULL)
            *pIndexBelow = TopIndex-1;

         if((pIndexAbove != NULL) &&
            (BotIndex <= pSessCacheCtlDesc->IdSlotsInUseCount))
            *pIndexAbove = BotIndex-1;

         return((uint32_t) -1);
      }

      ActIndex = (TopIndex + BotIndex)/2 - 1; // approximate half index, rel. 0

      ElementIndex = pAccessArray[ActIndex]; // use index rel. 0!

      pCacheElement = pCacheElementBase+ElementIndex;

      //---------------------------------------------------------------
      // Compare Session IDs, should not be 0-sized!
      //---------------------------------------------------------------
      if((Result = ((int) *pSessionID & 0x0FF) - 
         ((int) *pCacheElement->SessionID & 0x0FF)) == 0)
      {
         Result = memcmp(pSessionID+1,
            pCacheElement->SessionID+1,
            (int) *pSessionID & 0x0FF);
      }

      if(Result == 0)			// found element !
         return(ActIndex); 
      else if(Result < 0)			// given ID  < Element's ID
         TopIndex = ActIndex;
      else				// given ID > Element's ID
         BotIndex = ActIndex + 2;
   }
}
/**
* Finds a session cache entry by connection ID in the session cache sorted
* ConnectionID index array (FindSessClntCacheEntryByConnectionID).
* If element is NOT found, the neighbour positions for the ConnectionID
* are returned.
*
* -- CLIENT SIDE --
* 
* NOTE: The element array must be sorted in ascending order.
*   Returned indices are the indices into the SessionID sorted index array.
*
*  @param pSessCacheCtlDesc The used session chache control block
*  @param pConnectionID ID, 2nd byte is length !
*  @param pIndexBelow Lower index, -1 if none (< bottom)
*  @param pIndexAbove Upper index, -1 if none (> top)
* 
*  @return ConnectionID sorted array Index or -1 if not found
*/
static uint32_t FindSessClntCacheEntryByConnectionID(
   HSESSCACHE_CTL_DESC * pSessCacheCtlDesc,
   char* pConnectionID,
   uint32_t* pIndexBelow, uint32_t* pIndexAbove)
{
   int Result;
   uint32_t ActIndex, BotIndex, TopIndex, ElementIndex;
   HCLNT_CACHE_ELEM * pCacheElement, * pCacheElementBase;

   uint32_t * pAccessArray;

   if(pIndexBelow != NULL)
      *pIndexBelow = (uint32_t) -1;

   if(pIndexAbove != NULL)
      *pIndexAbove = (uint32_t) -1;

   if((pSessCacheCtlDesc == NULL) ||
      ((TopIndex = pSessCacheCtlDesc->IdSlotsInUseCount) == 0))
      return((uint32_t) -1);
   //--------------------------------------------------------------
   // Search for Connection ID, binary search
   // Note: Indices from 1..N !
   //--------------------------------------------------------------
   pAccessArray = pSessCacheCtlDesc->pIdSortedIndexArr;
   pCacheElementBase =
      (HCLNT_CACHE_ELEM *) pSessCacheCtlDesc->pSessionCacheBuf;

   BotIndex = 1;
   for(;;)
   {
      if(TopIndex < BotIndex)		// end, not found
      {
         if(pIndexBelow != NULL)
            *pIndexBelow = TopIndex-1;

         if((pIndexAbove != NULL) &&
            (BotIndex <= pSessCacheCtlDesc->IdSlotsInUseCount))
            *pIndexAbove = BotIndex-1;

         return((uint32_t) -1);
      }

      ActIndex = (TopIndex + BotIndex)/2 - 1; // approximate half index, rel. 0

      ElementIndex = pAccessArray[ActIndex]; // use index rel. 0!

      pCacheElement = pCacheElementBase+ElementIndex;

      //---------------------------------------------------------------
      // Compare Connection IDs, should not be 0-sized!
      //---------------------------------------------------------------
      if((Result = ((int) *(pConnectionID+1) & 0x0FF) - 
         ((int) *(pCacheElement->ConnectionID+1) & 0x0FF)) == 0)
      {
         Result = memcmp(pConnectionID+2,
            pCacheElement->ConnectionID+2,
            (int) *(pConnectionID+1) & 0x0FF);
      }

      if(Result == 0)			// found element !
         return(ActIndex); 
      else if(Result < 0)			// given ID  < Element's ID
         TopIndex = ActIndex;
      else				// given ID > Element's ID
         BotIndex = ActIndex + 2;
   }
}

/**
* Finds a session cache entry by UTC Time in the session cache sorted
* UTC index array (FindSessSrvrCacheEntryByUtc).
* If element is NOT found, the neighbour positions for the UTC
* are returned.
*
* -- SERVER SIDE --
* 
* NOTE: The element array must be sorted in ascending order
*   Returned indices are the indices into the UTC sorted index array.
*
*  @param pSessCacheCtlDesc The used session chache control block
*  @param UtcMsw High word of UTC (UTC itself)
*  @param UtcLsw Low word of UTC (modifier)
*  @param pIndexBelow Lower index, -1 if none (< bottom)
*  @param pIndexAbove Upper index, -1 if none (> top)
* 
*  @return SessionID sorted array index or -1 if not found
*/
static uint32_t FindSessSrvrCacheEntryByUtc(
   HSESSCACHE_CTL_DESC * pSessCacheCtlDesc,
   uint32_t UtcMsw, uint32_t UtcLsw,
   uint32_t* pIndexBelow, uint32_t* pIndexAbove)
{
   int Result;
   uint32_t ActIndex, BotIndex, TopIndex, ElementIndex;
   uint32_t ElementUtcMsw, ElementUtcLsw;
   HSERV_CACHE_ELEM * pCacheElement, * pCacheElementBase;

   uint32_t * pAccessArray;

   if(pIndexBelow != NULL)
      *pIndexBelow = (uint32_t) -1;

   if(pIndexAbove != NULL)
      *pIndexAbove = (uint32_t) -1;

   if((pSessCacheCtlDesc == NULL) ||
      ((TopIndex = pSessCacheCtlDesc->UtcSlotsInUseCount) == 0))
      return((uint32_t) -1);
   //--------------------------------------------------------------
   // Search for UTC, binary search
   // Note: Indices from 1..N !
   //--------------------------------------------------------------
   pAccessArray = pSessCacheCtlDesc->pUtcSortedIndexArr;
   pCacheElementBase = (HSERV_CACHE_ELEM *) pSessCacheCtlDesc->pSessionCacheBuf;

   BotIndex = 1;
   for(;;)
   {
      if(TopIndex < BotIndex)		// end, not found
      {
         if(pIndexBelow != NULL)
            *pIndexBelow = TopIndex-1;

         if((pIndexAbove != NULL) &&
            (BotIndex <= pSessCacheCtlDesc->UtcSlotsInUseCount))
            *pIndexAbove = BotIndex-1;

         return((uint32_t) -1);
      }

      ActIndex = (TopIndex + BotIndex)/2 - 1; // approximate half index, rel. 0

      ElementIndex = pAccessArray[ActIndex];  // use index rel. 0!

      pCacheElement = pCacheElementBase+ElementIndex;

      ElementUtcMsw = pCacheElement->ExpireUtcMsw;
      ElementUtcLsw = pCacheElement->ExpireUtcLsw;
      //---------------------------------------------------------------
      // Compare UTCs, MSW/LSW
      //---------------------------------------------------------------
      if(ElementUtcMsw != UtcMsw)			// MSWs different
         Result = (UtcMsw < ElementUtcMsw) ? -1 : +1;
      else					// MSWs are same
      {
         if(ElementUtcLsw != UtcLsw)		// LSWs different
            Result = (UtcLsw < ElementUtcLsw) ? -1 : +1;
         else
            Result = 0;  
      }

      if(Result == 0)			// found element !
         return(ActIndex); 
      else if(Result < 0)			// given ID  < Element's ID
         TopIndex = ActIndex;
      else				// given ID > Element's ID
         BotIndex = ActIndex + 2;
   }
}
/**
* Finds a session cache entry by UTC Time in the session cache sorted
* UTC index array (FindSessClntCacheEntryByUtc).
* If element is NOT found, the neighbour positions for the UTC
* are returned.
*
* -- CLIENT SIDE --
* 
* NOTE: The element array must be sorted in ascending order.
*  Returned indices are the indices into the UTC sorted index array.
*
*  @param pSessCacheCtlDesc  The used session chache control block
*  @param UtcMsw High word of UTC (UTC itself)
*  @param UtcLsw Low word of UTC (modifier)
*  @param pIndexBelow Lower index, -1 if none (< bottom)
*  @param pIndexAbove Upper index, -1 if none (> top)
* 
*  @return SessionID sorted array index or -1 if not found
*/
static uint32_t FindSessClntCacheEntryByUtc(
   HSESSCACHE_CTL_DESC * pSessCacheCtlDesc,
   uint32_t UtcMsw, uint32_t UtcLsw,
   uint32_t* pIndexBelow, uint32_t* pIndexAbove)
{
   int Result;
   uint32_t ActIndex, BotIndex, TopIndex, ElementIndex;
   uint32_t ElementUtcMsw, ElementUtcLsw;
   HCLNT_CACHE_ELEM * pCacheElement, * pCacheElementBase;

   uint32_t * pAccessArray;

   if(pIndexBelow != NULL)
      *pIndexBelow = (uint32_t) -1;

   if(pIndexAbove != NULL)
      *pIndexAbove = (uint32_t) -1;

   if((pSessCacheCtlDesc == NULL) ||
      ((TopIndex = pSessCacheCtlDesc->UtcSlotsInUseCount) == 0))
      return((uint32_t) -1);
   //--------------------------------------------------------------
   // Search for UTC, binary search
   // Note: Indices from 1..N !
   //--------------------------------------------------------------
   pAccessArray = pSessCacheCtlDesc->pUtcSortedIndexArr;
   pCacheElementBase = (HCLNT_CACHE_ELEM *) pSessCacheCtlDesc->pSessionCacheBuf;

   BotIndex = 1;
   for(;;)
   {
      if(TopIndex < BotIndex)		// end, not found
      {
         if(pIndexBelow != NULL)
            *pIndexBelow = TopIndex-1;

         if((pIndexAbove != NULL) &&
            (BotIndex <= pSessCacheCtlDesc->UtcSlotsInUseCount))
            *pIndexAbove = BotIndex-1;

         return((uint32_t) -1);
      }

      ActIndex = (TopIndex + BotIndex)/2 - 1; // approximate half index, rel. 0

      ElementIndex = pAccessArray[ActIndex];  // use index rel. 0!

      pCacheElement = pCacheElementBase+ElementIndex;

      ElementUtcMsw = pCacheElement->ExpireUtcMsw;
      ElementUtcLsw = pCacheElement->ExpireUtcLsw;
      //---------------------------------------------------------------
      // Compare UTCs, MSW/LSW
      //---------------------------------------------------------------
      if(ElementUtcMsw != UtcMsw)			// MSWs different
         Result = (UtcMsw < ElementUtcMsw) ? -1 : +1;
      else					// MSWs are same
      {
         if(ElementUtcLsw != UtcLsw)		// LSWs different
            Result = (UtcLsw < ElementUtcLsw) ? -1 : +1;
         else
            Result = 0;  
      }

      if(Result == 0)			// found element !
         return(ActIndex); 
      else if(Result < 0)			// given ID  < Element's ID
         TopIndex = ActIndex;
      else				// given ID > Element's ID
         BotIndex = ActIndex + 2;
   }
}
/**
* Initializes base elements of session cache control structure (BaseInitCacheCtrlStruct).
* Sets initial UTC time.
*
* -- SERVER/CLIENT --
*
*  @param pSessCacheCtlDesc The session chache control block to be initialized
*  @param CacheType 0-Server, else Client cache
*  @param EntriesMaxCount Maximum entries allowed in this cache
*  @param TimeToLive Lifetime of cache elements in seconds
*  @return 0 on success, error code otherwise
*/
extern "C" int BaseInitCacheCtrlStruct(HSESSCACHE_CTL_DESC * pSessCacheCtlDesc,
                                       int CacheType,
                                       uint32_t EntriesMaxCount, uint32_t TimeToLive)

{
   EntriesMaxCount = EntriesMaxCount;

   //  pSessCacheCtlDesc->SlotsMaxAllocCount   = EntriesMaxCount * 2;
   pSessCacheCtlDesc->CacheExpireDeltaTime = TimeToLive; 
   pSessCacheCtlDesc->LastAccessUtc        = (uint32_t) time(NULL);
   pSessCacheCtlDesc->Flags               = 1; // set initialized

   if(CacheType != 0)			// client cache
      pSessCacheCtlDesc->Flags |= 0x02;	// set flag for client cache

   return(HSSL_OP_OK);
}
/**
* Flushes all session cache elements (FlushSessionCache).
*
* -- SERVER/CLIENT SIDE --
*
*  @param pSessCacheCtlDesc The session chache control block to be flushed
*  @param CacheType 0-Server, else Client cache
*/
static void FlushSessionCache(HSESSCACHE_CTL_DESC * pSessCacheCtlDesc,
                              int CacheType)
{
   int ElementState;
   uint32_t StateFlags = 0;
   uint32_t Index;
   uint32_t * pStateArr;

   void * pMasterSecret;

   if((pSessCacheCtlDesc == NULL) ||
      (pSessCacheCtlDesc->SlotsInUseCount == 0))
      return;
   //------------------------------------------------------------
   // Clear used elements master secrets, reset in use state bits
   //------------------------------------------------------------
   pStateArr = pSessCacheCtlDesc->pUseStateBitsList;
   Index = 0;
   if((Index & 0x1F) != 0)
   {
      StateFlags = pStateArr[Index/32] >> (Index & 0x1F);
      pStateArr[Index/32] = 0;
   }

   for(;Index <= pSessCacheCtlDesc->SlotsAllocedCount; Index++)
   {
      if((Index & 0x1F) == 0)		// fetch next state flag bits element
      {
         StateFlags = pStateArr[Index/32];
         pStateArr[Index/32] = 0;
      }

      ElementState = StateFlags & 0x01;
      StateFlags   = StateFlags >> 1;

      if(ElementState != 0)
      {
         if(CacheType == 0)
         {
            pMasterSecret = ((HSERV_CACHE_ELEM *)
               pSessCacheCtlDesc->pSessionCacheBuf + Index)->MasterSecret;
         }
         else
         {
            pMasterSecret = ((HCLNT_CACHE_ELEM *)
               pSessCacheCtlDesc->pSessionCacheBuf + Index)->MasterSecret;
         }
         memset(pMasterSecret,0,MASTER_SECRET_LEN);
      }
   }
   //------------------------------------------------------------
   // 'Remove' the Entries
   //------------------------------------------------------------
   pSessCacheCtlDesc->SlotsInUseCount    = 0;
   //  pSessCacheCtlDesc->MinSlotInUseIndex  = 0;
   //  pSessCacheCtlDesc->MaxSlotInUseIndex  = 0;
   pSessCacheCtlDesc->UtcSlotsInUseCount = 0;
   pSessCacheCtlDesc->LastAccessUtc      = (uint32_t) time(NULL);
}

/**
* Removes a cache element entry from the UTC index array (RemoveCacheElementFromUtcArray).
* Element is identified by UTC Msw/Lsw.
*
* -- SERVER/CLIENT SIDE --
*
*  @param pSessCacheCtlDesc The session chache control block to be used
*  @param CacheType 0-Server, else Client cache
*  @param UtcMsw High word of UTC (UTC itself)
*  @param UtcLsw Low word of UTC (modifier)
*  @return 0 on success
* <br>            > 0 - not found
* <br>            < 0 - error occured
*/
static int RemoveCacheElementFromUtcArray(
   HSESSCACHE_CTL_DESC * pSessCacheCtlDesc,
   int CacheType,
   uint32_t UtcMsw, uint32_t UtcLsw)
{
   uint32_t UtcArrIndex,UtcArrMaxIndex,MoveCount;
   uint32_t * pUtcIndexArr;

   if(pSessCacheCtlDesc == NULL)
      return(HSSL_NULL_PTR);
   //------------------------------------------------------------
   // Check if UTC array has elements, if so search for element
   //------------------------------------------------------------
   if((UtcArrMaxIndex = pSessCacheCtlDesc->UtcSlotsInUseCount) == 0) //none used
      return(1);

   if(CacheType == 0)
      UtcArrIndex = FindSessSrvrCacheEntryByUtc(pSessCacheCtlDesc,UtcMsw,UtcLsw,
      NULL,NULL);
   else
      UtcArrIndex = FindSessClntCacheEntryByUtc(pSessCacheCtlDesc,UtcMsw,UtcLsw,
      NULL,NULL);

   if(UtcArrIndex == (uint32_t) -1)	// not in array!
      return(2);
   //------------------------------------------------------------
   // Found the Element, remove the entry from array
   //------------------------------------------------------------
   if((MoveCount = UtcArrMaxIndex - UtcArrIndex - 1) > 0)
   {
      pUtcIndexArr = pSessCacheCtlDesc->pUtcSortedIndexArr;
      memmove(pUtcIndexArr + UtcArrIndex,
         pUtcIndexArr + UtcArrIndex + 1,
         MoveCount * sizeof(uint32_t));
   }
   pSessCacheCtlDesc->UtcSlotsInUseCount--;

   return(0);
}

/**
* Puts a server cache element to the UTC Index array.
*<ol>
* <li> Set cache element's expire UTC MSW to current UTC + ExpireDeltaTime
* <li> Set cache element's expire UTC LSW = 0
*</ol>
*
* -- SERVER SIDE --
*
*  @param pSessCacheCtlDesc
*  @param ElementIndex Index to the element
*  @return 0 on success, error code otherwise
* <br>            < 0 - error occured

*/
//PutSrvrCacheElementToUtcArray
static int PutSrvrCacheElementToUtcArray(
   HSESSCACHE_CTL_DESC * pSessCacheCtlDesc,
   uint32_t ElementIndex)
{
   uint32_t UtcArrIndex,BelowIndex,AboveIndex,UsedCount,NextElementIndex,UtcMid;
   uint32_t * pUtcIndexArr;
   HSERV_CACHE_ELEM * pCacheElement, * pNextCacheElement;

   if(pSessCacheCtlDesc == NULL)
      return(HSSL_NULL_PTR);
   //------------------------------------------------------------
   // Prepare Expire UTC of the cache element
   //------------------------------------------------------------
   pCacheElement =
      (HSERV_CACHE_ELEM *) pSessCacheCtlDesc->pSessionCacheBuf + ElementIndex;

   pCacheElement->ExpireUtcMsw =
      (uint32_t) time(NULL) + pSessCacheCtlDesc->CacheExpireDeltaTime;
   pCacheElement->ExpireUtcLsw = 0;
   //------------------------------------------------------------
   // Put element to the UTC sorted array now
   //------------------------------------------------------------
   pUtcIndexArr = pSessCacheCtlDesc->pUtcSortedIndexArr; // get array base
   UsedCount    = pSessCacheCtlDesc->UtcSlotsInUseCount; // get slots used count

   if(UsedCount == 0) // array is empty
   {
      pUtcIndexArr[0] = ElementIndex;
      pSessCacheCtlDesc->UtcSlotsInUseCount++;
      return(HSSL_OP_OK);
   }
   //------------------------------------------------------------
   // UTC sorted array has already elements, get insert position
   //------------------------------------------------------------
   for(;;)				// insert Retry (UTC duplicate test)
   {
      UtcArrIndex = FindSessSrvrCacheEntryByUtc(pSessCacheCtlDesc,
         pCacheElement->ExpireUtcMsw,
         pCacheElement->ExpireUtcLsw,
         &BelowIndex,&AboveIndex);
      if(UtcArrIndex == (uint32_t) -1)
      {
         //----------------------------------------------------------
         // unique UTC element, insert at correct postion
         //----------------------------------------------------------
         if(AboveIndex == (uint32_t) -1)			// UTC > all present
            pUtcIndexArr[UsedCount] = ElementIndex;		// add at top

         else if(BelowIndex == (uint32_t) -1)		// UTC < all present
         {
            memmove(&pUtcIndexArr[1],&pUtcIndexArr[0],UsedCount*sizeof(uint32_t));
            pUtcIndexArr[0] = ElementIndex;			// add at bottom
         }
         else
         {
            memmove(&pUtcIndexArr[AboveIndex+1],&pUtcIndexArr[AboveIndex],
               (UsedCount-AboveIndex)*sizeof(uint32_t));
            pUtcIndexArr[AboveIndex] = ElementIndex;	// add at above index
         }
         pSessCacheCtlDesc->UtcSlotsInUseCount++;
         return(HSSL_OP_OK);
      }
      //--------------------------------------------------------------
      // UTC generated was a duplicate UTC, check what to do
      //--------------------------------------------------------------
      if(UtcArrIndex == (UsedCount-1))
      {
         //------------------------------------------------------------
         // Duplicate at top element found, increase UTC, append at top
         //------------------------------------------------------------
         pCacheElement->ExpireUtcLsw = (uint32_t) 0x80000000;  // set 2**31
         pUtcIndexArr[UsedCount] = ElementIndex;		// add at top
         pSessCacheCtlDesc->UtcSlotsInUseCount++;
         return(HSSL_OP_OK);
      }
      //--------------------------------------------------------------
      // Duplicate inside array found, more tricky case,
      // Check if expire UTC of next upper element different from this
      //--------------------------------------------------------------
      NextElementIndex = pUtcIndexArr[UtcArrIndex + 1];

      pNextCacheElement = (HSERV_CACHE_ELEM *)
         pSessCacheCtlDesc->pSessionCacheBuf + NextElementIndex;

      if(pCacheElement->ExpireUtcMsw != pNextCacheElement->ExpireUtcMsw)
      {
         pCacheElement->ExpireUtcLsw = (uint32_t) 0x80000000;  // set 2**31

         memmove(&pUtcIndexArr[UtcArrIndex+2],&pUtcIndexArr[UtcArrIndex+1],
            (UsedCount-UtcArrIndex-1)*sizeof(uint32_t));

         pUtcIndexArr[UtcArrIndex+1] = ElementIndex;	// add at above index
         pSessCacheCtlDesc->UtcSlotsInUseCount++;
         return(HSSL_OP_OK);
      }
      //--------------------------------------------------------------
      // Still more tricky, next UtcMsw == current UtcMsw
      //--------------------------------------------------------------
      UtcMid = (pNextCacheElement->ExpireUtcLsw / 2);	// half distance
      if(UtcMid == 0)					// bad result...
      {
         pCacheElement->ExpireUtcMsw++;			// increase UTC Msw
         continue;						// retry...
      }
      //--------------------------------------------------------------
      // Set new UtcLsw, insert past current element
      //--------------------------------------------------------------
      pCacheElement->ExpireUtcLsw = UtcMid;

      memmove(&pUtcIndexArr[UtcArrIndex+2],&pUtcIndexArr[UtcArrIndex+1],
         (UsedCount-UtcArrIndex-1)*sizeof(uint32_t));

      pUtcIndexArr[UtcArrIndex+1] = ElementIndex;	// add at above index
      pSessCacheCtlDesc->UtcSlotsInUseCount++;
      return(HSSL_OP_OK);
   } // insert pos search FOR
}
/**
* Put a client cache element to the UTC Index array (PutClntCacheElementToUtcArray).
* 1. Set cache element's expire UTC MSW to current UTC + ExpireDeltaTime
* 2. Set cache element's expire UTC LSW = 0
*
* -- CLIENT SIDE --
*
*  @param pSessCacheCtlDesc
*  @param ElementIndex Index to the element
*  @return 0 on success, error code otherwise
* <br>            < 0 - error occured
* <br>            Checked: no
*/
static int PutClntCacheElementToUtcArray(
   HSESSCACHE_CTL_DESC * pSessCacheCtlDesc,
   uint32_t ElementIndex)
{
   uint32_t UtcArrIndex,BelowIndex,AboveIndex,UsedCount,NextElementIndex,UtcMid;
   uint32_t * pUtcIndexArr;
   HCLNT_CACHE_ELEM * pCacheElement, * pNextCacheElement;

   if(pSessCacheCtlDesc == NULL)
      return(HSSL_NULL_PTR);
   //------------------------------------------------------------
   // Prepare Expire UTC of the cache element
   //------------------------------------------------------------
   pCacheElement =
      (HCLNT_CACHE_ELEM *) pSessCacheCtlDesc->pSessionCacheBuf + ElementIndex;

   pCacheElement->ExpireUtcMsw =
      (uint32_t) time(NULL) + pSessCacheCtlDesc->CacheExpireDeltaTime;
   pCacheElement->ExpireUtcLsw = 0;
   //------------------------------------------------------------
   // Put element to the UTC sorted array now
   //------------------------------------------------------------
   pUtcIndexArr = pSessCacheCtlDesc->pUtcSortedIndexArr; // get array base
   UsedCount    = pSessCacheCtlDesc->UtcSlotsInUseCount; // get slots used count

   if(UsedCount == 0) // array is empty
   {
      pUtcIndexArr[0] = ElementIndex;
      pSessCacheCtlDesc->UtcSlotsInUseCount++;
      return(HSSL_OP_OK);
   }
   //------------------------------------------------------------
   // UTC sorted array has already elements, get insert position
   //------------------------------------------------------------
   for(;;)				// insert Retry (UTC duplicate test)
   {
      UtcArrIndex = FindSessClntCacheEntryByUtc(pSessCacheCtlDesc,
         pCacheElement->ExpireUtcMsw,
         pCacheElement->ExpireUtcLsw,
         &BelowIndex,&AboveIndex);
      if(UtcArrIndex == (uint32_t) -1)
      {
         //----------------------------------------------------------
         // unique UTC element, insert at correct postion
         //----------------------------------------------------------
         if(AboveIndex == (uint32_t) -1)			// UTC > all present
            pUtcIndexArr[UsedCount] = ElementIndex;		// add at top

         else if(BelowIndex == (uint32_t) -1)		// UTC < all present
         {
            memmove(&pUtcIndexArr[1],&pUtcIndexArr[0],UsedCount*sizeof(uint32_t));
            pUtcIndexArr[0] = ElementIndex;			// add at bottom
         }
         else
         {
            memmove(&pUtcIndexArr[AboveIndex+1],&pUtcIndexArr[AboveIndex],
               (UsedCount-AboveIndex)*sizeof(uint32_t));
            pUtcIndexArr[AboveIndex] = ElementIndex;	// add at above index
         }
         pSessCacheCtlDesc->UtcSlotsInUseCount++;
         return(HSSL_OP_OK);
      }
      //--------------------------------------------------------------
      // UTC generated was a duplicate UTC, check what to do
      //--------------------------------------------------------------
      if(UtcArrIndex == (UsedCount-1))
      {
         //------------------------------------------------------------
         // Duplicate at top element found, increase UTC, append at top
         //------------------------------------------------------------
         pCacheElement->ExpireUtcLsw = (uint32_t) 0x80000000;  // set 2**31
         pUtcIndexArr[UsedCount] = ElementIndex;		// add at top
         pSessCacheCtlDesc->UtcSlotsInUseCount++;
         return(HSSL_OP_OK);
      }
      //--------------------------------------------------------------
      // Duplicate inside array found, more tricky case,
      // Check if expire UTC of next upper element different from this
      //--------------------------------------------------------------
      NextElementIndex = pUtcIndexArr[UtcArrIndex + 1];

      pNextCacheElement = (HCLNT_CACHE_ELEM *)
         pSessCacheCtlDesc->pSessionCacheBuf + NextElementIndex;

      if(pCacheElement->ExpireUtcMsw != pNextCacheElement->ExpireUtcMsw)
      {
         pCacheElement->ExpireUtcLsw = (uint32_t) 0x80000000;  // set 2**31

         memmove(&pUtcIndexArr[UtcArrIndex+2],&pUtcIndexArr[UtcArrIndex+1],
            (UsedCount-UtcArrIndex-1)*sizeof(uint32_t));

         pUtcIndexArr[UtcArrIndex+1] = ElementIndex;	// add at above index
         pSessCacheCtlDesc->UtcSlotsInUseCount++;
         return(HSSL_OP_OK);
      }
      //--------------------------------------------------------------
      // Still more tricky, next UtcMsw == current UtcMsw
      //--------------------------------------------------------------
      UtcMid = (pNextCacheElement->ExpireUtcLsw / 2);	// half distance
      if(UtcMid == 0)					// bad result...
      {
         pCacheElement->ExpireUtcMsw++;			// increase UTC Msw
         continue;						// retry...
      }
      //--------------------------------------------------------------
      // Set new UtcLsw, insert past current element
      //--------------------------------------------------------------
      pCacheElement->ExpireUtcLsw = UtcMid;

      memmove(&pUtcIndexArr[UtcArrIndex+2],&pUtcIndexArr[UtcArrIndex+1],
         (UsedCount-UtcArrIndex-1)*sizeof(uint32_t));

      pUtcIndexArr[UtcArrIndex+1] = ElementIndex;	// add at above index
      pSessCacheCtlDesc->UtcSlotsInUseCount++;
      return(HSSL_OP_OK);
   } // insert pos search FOR
}
/**
* Remove a Cache Element Entry from the Session/ConnectionID Index array (RemoveCacheElementFromIdArray).
* Element is identified by Session/ConnectionID.
* -- SERVER/CLIENT SIDE --
*
*  @param pSessCacheCtlDesc
*  @param CacheType 0-Server, else Client cache
*  @param pIdBuf Session/Connection ID
*  @return 0 on success, error code otherwise
* <br>            > 0 - not found
* <br>            < 0 - error occured
* <br>            Checked: partial
*/
static int RemoveCacheElementFromIdArray(
   HSESSCACHE_CTL_DESC * pSessCacheCtlDesc,
   int CacheType,
   char* pIdBuf)
{
   uint32_t IdArrIndex,IdArrMaxIndex,MoveCount;
   uint32_t * pIdIndexArr;

   if(pSessCacheCtlDesc == NULL)
      return(HSSL_NULL_PTR);
   //-------------------------------------------------------------------
   // Check if Session/ConnectionID array has elements, if so search for
   // element
   //-------------------------------------------------------------------
   if((IdArrMaxIndex = pSessCacheCtlDesc->IdSlotsInUseCount) == 0) //none used
      return(1);

   if(CacheType == 0)
      IdArrIndex = FindSessSrvrCacheEntryBySessionID(pSessCacheCtlDesc,
      pIdBuf,NULL,NULL);
   else
      IdArrIndex = FindSessClntCacheEntryByConnectionID(pSessCacheCtlDesc,
      pIdBuf,NULL,NULL);
   if(IdArrIndex == (uint32_t) -1)	// not in array!
      return(2);
   //------------------------------------------------------------
   // Found the Element, remove the entry from array
   //------------------------------------------------------------
   if((MoveCount = IdArrMaxIndex - IdArrIndex - 1) > 0)
   {
      pIdIndexArr = pSessCacheCtlDesc->pIdSortedIndexArr;
      memmove(pIdIndexArr + IdArrIndex,
         pIdIndexArr + IdArrIndex + 1,
         MoveCount * sizeof(uint32_t));
   }
   pSessCacheCtlDesc->IdSlotsInUseCount--;

   return(0);
}

/**
* Put a server cache element to the SessionID sorted Index array.
* NOTE: If there is already an element with same session ID, do NOT
* ----- insert the element !
* -- SERVER SIDE --
*
*  @param pSessCacheCtlDesc
*  @param ElementIndex Index to element to insert
*  @return int Status - > 0 special cases:
* <br>            1 - duplicate element found in ID array
* <br>            == 0 o.k.
* <br>            < 0 - error occured

*/
//PutSrvrCacheElementToSessIDArray
static int PutSrvrCacheElementToSessIDArray(
   HSESSCACHE_CTL_DESC * pSessCacheCtlDesc,
   uint32_t ElementIndex)
{
   uint32_t IdArrIndex,BelowIndex,AboveIndex,UsedCount;
   uint32_t * pIdIndexArr;
   HSERV_CACHE_ELEM * pCacheElement;

   if(pSessCacheCtlDesc == NULL)
      return(HSSL_NULL_PTR);
   //------------------------------------------------------------
   // Get pointer to cache element from index given
   //------------------------------------------------------------
   pCacheElement =
      (HSERV_CACHE_ELEM *) pSessCacheCtlDesc->pSessionCacheBuf + ElementIndex;

   //----------------------------------------------------------------
   // Check if SessionID array already has elements
   //----------------------------------------------------------------
   pIdIndexArr = pSessCacheCtlDesc->pIdSortedIndexArr;
   UsedCount   = pSessCacheCtlDesc->IdSlotsInUseCount;

   if(UsedCount == 0) //none used
   {
      pIdIndexArr[0] = ElementIndex;		// set at base  
      pSessCacheCtlDesc->IdSlotsInUseCount++;
      return(0);
   }
   //----------------------------------------------------------------
   // Find insert position for new Element's SessionID
   //----------------------------------------------------------------
   IdArrIndex = FindSessSrvrCacheEntryBySessionID(pSessCacheCtlDesc,
      pCacheElement->SessionID,
      &BelowIndex,&AboveIndex);
   if(IdArrIndex != (uint32_t) -1)	// SessionID already in array !!
      return(1);
   //-----------------------------------------------------------------
   // Element's SessionID not yet in array, insert at correct location
   //-----------------------------------------------------------------
   if(AboveIndex == (uint32_t) -1)			// SessionID > all present
      pIdIndexArr[UsedCount] = ElementIndex;	// add at top

   else if(BelowIndex == (uint32_t) -1)		// SessionID < all present
   {
      memmove(&pIdIndexArr[1],&pIdIndexArr[0],UsedCount*sizeof(uint32_t));
      pIdIndexArr[0] = ElementIndex;		// add at bottom
   }
   else
   {
      memmove(&pIdIndexArr[AboveIndex+1],&pIdIndexArr[AboveIndex],
         (UsedCount-AboveIndex)*sizeof(uint32_t));
      pIdIndexArr[AboveIndex] = ElementIndex;	// add at above index
   }
   pSessCacheCtlDesc->IdSlotsInUseCount++;
   return(HSSL_OP_OK);
}

/**
* Put a client cache element to the ConnectionID sorted Index array (PutClntCacheElementToSessIDArray).
* NOTE: If there is already an element with same Connection ID, do NOT
* ----- insert the element !
* -- CLIENT SIDE --
*
*  @param pSessCacheCtlDesc
*  @param ElementIndex Index to element to insert
*  @return int Status - > 0 special cases:
* <br>            1 - duplicate element found in ID array
* <br>            == 0 o.k.
* <br>            < 0 - error occured
* <br>            Checked: no
*/
static int PutClntCacheElementToSessIDArray(
   HSESSCACHE_CTL_DESC * pSessCacheCtlDesc,
   uint32_t ElementIndex)
{
   uint32_t IdArrIndex,BelowIndex,AboveIndex,UsedCount;
   uint32_t * pIdIndexArr;
   HCLNT_CACHE_ELEM * pCacheElement;

   if(pSessCacheCtlDesc == NULL)
      return(HSSL_NULL_PTR);
   //------------------------------------------------------------
   // Get pointer to cache element from index given
   //------------------------------------------------------------
   pCacheElement =
      (HCLNT_CACHE_ELEM *) pSessCacheCtlDesc->pSessionCacheBuf + ElementIndex;

   //----------------------------------------------------------------
   // Check if SessionID array already has elements
   //----------------------------------------------------------------
   pIdIndexArr = pSessCacheCtlDesc->pIdSortedIndexArr;
   UsedCount   = pSessCacheCtlDesc->IdSlotsInUseCount;

   if(UsedCount == 0) //none used
   {
      pIdIndexArr[0] = ElementIndex;		// set at base  
      pSessCacheCtlDesc->IdSlotsInUseCount++;
      return(0);
   }
   //----------------------------------------------------------------
   // Find insert position for new Element's SessionID
   //----------------------------------------------------------------
   IdArrIndex = FindSessClntCacheEntryByConnectionID(pSessCacheCtlDesc,
      pCacheElement->ConnectionID,
      &BelowIndex,&AboveIndex);
   if(IdArrIndex != (uint32_t) -1)	// SessionID already in array !!
      return(1);
   //-----------------------------------------------------------------
   // Element's SessionID not yet in array, insert at correct location
   //-----------------------------------------------------------------
   if(AboveIndex == (uint32_t) -1)			// SessionID > all present
      pIdIndexArr[UsedCount] = ElementIndex;	// add at top

   else if(BelowIndex == (uint32_t) -1)		// SessionID < all present
   {
      memmove(&pIdIndexArr[1],&pIdIndexArr[0],UsedCount*sizeof(uint32_t));
      pIdIndexArr[0] = ElementIndex;		// add at bottom
   }
   else
   {
      memmove(&pIdIndexArr[AboveIndex+1],&pIdIndexArr[AboveIndex],
         (UsedCount-AboveIndex)*sizeof(uint32_t));
      pIdIndexArr[AboveIndex] = ElementIndex;	// add at above index
   }
   pSessCacheCtlDesc->IdSlotsInUseCount++;
   return(HSSL_OP_OK);
}

/**
* Get a free Cache element to use from used bit array, if none free
* expand the cache if possible.
* -- SERVER/CLIENT SIDE --
*

*  @param pSessCacheCtlDesc
*  @param CacheType 0-Server, else Client cache
*  @param pElementIndex Index of element found, -1 if none
*  @return 0 on success, error code otherwise
* <br>            Checked: partial
*/
//GetFreeCacheElement
static int GetFreeCacheElement(HSESSCACHE_CTL_DESC * pSessCacheCtlDesc,
                               int CacheType,
                               uint32_t * pElementIndex)
{
   int ElementSize;
   uint32_t Index,MaxIndex,BitIndex,Remaining,StateBits;
   uint32_t * pStateArr;
   void * pCacheElement;

   if((pSessCacheCtlDesc == NULL) || (pElementIndex == NULL))
      return(HSSL_NULL_PTR);
   //-------------------------------------------------------
   // Initialize start values
   //-------------------------------------------------------
   *pElementIndex = (uint32_t) -1;

   if(CacheType == 0)
      ElementSize = sizeof(HSERV_CACHE_ELEM);
   else
      ElementSize = sizeof(HCLNT_CACHE_ELEM);

   //--------------------------------------------------------------
   // We already have elements, check if free elements present
   //--------------------------------------------------------------
   if(pSessCacheCtlDesc->SlotsInUseCount >=
      pSessCacheCtlDesc->SlotsAllocedCount)
   {
      //------------------------------------------------------------
      // No more free elements, enlarge cache if possible
      //------------------------------------------------------------
      if(pSessCacheCtlDesc->SlotsAllocedCount >=
         pSessCacheCtlDesc->SlotsMaxAllocCount)	// limit reached       
         return(HSSL_OP_OK);			// cannot grow...

      return(HSSL_OP_OK);
   }
   //-------------------------------------------------------------
   // There are free elements available, search first free element
   //-------------------------------------------------------------
   pStateArr = pSessCacheCtlDesc->pUseStateBitsList;
   MaxIndex  = pSessCacheCtlDesc->SlotsAllocedCount / 32;
   Remaining = pSessCacheCtlDesc->SlotsAllocedCount - (MaxIndex * 32);

   //-------------------------------------------------------------
   // Scan full bitmask elements (32 bit used) first
   //-------------------------------------------------------------
   for(Index=0;Index<MaxIndex;Index++)
   {
      if(pStateArr[Index] != (uint32_t) 0xFFFFFFFF)	// there IS a free element
      {
         StateBits = pStateArr[Index];		// get bits
         for(BitIndex=0;BitIndex<32;BitIndex++)
         {
            if((StateBits & 0x01) == 0)		// found usable element
            {
               *pElementIndex = (Index * 32) + BitIndex;
               pStateArr[Index] |= (1 << BitIndex);
               pSessCacheCtlDesc->SlotsInUseCount++;

               if(CacheType == 0)
                  pCacheElement = (HSERV_CACHE_ELEM *)
                  pSessCacheCtlDesc->pSessionCacheBuf + *pElementIndex;
               else
                  pCacheElement = (HCLNT_CACHE_ELEM *)
                  pSessCacheCtlDesc->pSessionCacheBuf + *pElementIndex;

               memset(pCacheElement,0,ElementSize);
               return(HSSL_OP_OK);
            }
            StateBits >>= 1;
         }
      }
   }
   //--------------------------------------------------------------
   // Scan bits last remaining element if one
   //--------------------------------------------------------------
   if(Remaining != 0)				// remaining bits
   {
      StateBits = pStateArr[MaxIndex];		// last element
      for(BitIndex=0;BitIndex<Remaining;BitIndex++)
      {
         if((StateBits & 0x01) == 0)		// found usable element
         {
            *pElementIndex = (MaxIndex * 32) + BitIndex;
            pStateArr[MaxIndex] |= (1 << BitIndex);
            pSessCacheCtlDesc->SlotsInUseCount++;

            if(CacheType == 0)
               pCacheElement = (HSERV_CACHE_ELEM *)
               pSessCacheCtlDesc->pSessionCacheBuf + *pElementIndex;
            else
               pCacheElement = (HCLNT_CACHE_ELEM *)
               pSessCacheCtlDesc->pSessionCacheBuf + *pElementIndex;

            memset(pCacheElement,0,ElementSize);
            return(HSSL_OP_OK);
         }
         StateBits >>= 1;
      }
   }
   //---------------------------------------------------------------
   // We SHOULD have found a match....
   //---------------------------------------------------------------
   return(HSSL_PARAM_ERR);
}

/**
* Get a free Cache element to use.
* -- SERVER/CLIENT SIDE --
*
* Algorithm as follows:
* - check if free elements available, if so get first free element index,
*   mark element as in use, not timed
* - if no free elements available, try to enlarge cache, if enlarge
*   succeeds, get first new element index, mark in use, not timed
* - if enlarge fails, get oldest element (first) from UTC index array if any,
*   remove from the Index array, remove from the ID-Array,
*   mark in use, not timed
* - if still no free element, get first (oldest) from the ID index array
*   remove from array and mark as in use, not timed
*

*  @param pSessCacheCtlDesc
*  @param CacheType 0-Server, else Client cache
*  @param pElementIndex Index of element found, -1 if none
*  @return 0 on success, error code otherwise
* <br>            Checked: partial
*/
//GetUsableCacheElement
static int GetUsableCacheElement(HSESSCACHE_CTL_DESC * pSessCacheCtlDesc,
                                 int CacheType,
                                 uint32_t * pElementIndex)
{
   int Retcode, ElementSize;
   uint32_t ElementIndex, MoveCount;
   void * pCacheElement, * pIdBuf;

   //----------------------------------------------------------
   // Try to fetch a free element from the cache, check if got
   //----------------------------------------------------------
   if((Retcode = GetFreeCacheElement(pSessCacheCtlDesc,
      CacheType,pElementIndex)) != 0)
      return(Retcode);

   if(*pElementIndex != (uint32_t) -1)
      return(HSSL_OP_OK);
   //----------------------------------------------------------
   // No free element found, cache limit reached/out of memory
   // Check if timed elements present
   //----------------------------------------------------------
   if(pSessCacheCtlDesc->UtcSlotsInUseCount != 0)
   {
      ElementIndex = pSessCacheCtlDesc->pUtcSortedIndexArr[0];

      if((MoveCount = pSessCacheCtlDesc->UtcSlotsInUseCount - 1) != 0)
      {
         memmove(pSessCacheCtlDesc->pUtcSortedIndexArr,
            pSessCacheCtlDesc->pUtcSortedIndexArr+1,
            MoveCount * sizeof(uint32_t));
      }
      pSessCacheCtlDesc->UtcSlotsInUseCount--;

      if(CacheType == 0)
      {
         pCacheElement = (HSERV_CACHE_ELEM *)
            pSessCacheCtlDesc->pSessionCacheBuf + ElementIndex;
         pIdBuf = ((HSERV_CACHE_ELEM *) pCacheElement)->SessionID;
         ElementSize = sizeof(HSERV_CACHE_ELEM);
      }
      else
      {
         pCacheElement = (HCLNT_CACHE_ELEM *)
            pSessCacheCtlDesc->pSessionCacheBuf + ElementIndex;
         pIdBuf = ((HCLNT_CACHE_ELEM *) pCacheElement)->SessionID;
         ElementSize = sizeof(HCLNT_CACHE_ELEM);
      }
      //----------------------------------------------------------
      // Remove the Element from the Session ID array
      //----------------------------------------------------------
      Retcode = RemoveCacheElementFromIdArray(pSessCacheCtlDesc,CacheType,
         (char*)pIdBuf);

      memset(pCacheElement,0,ElementSize);

      *pElementIndex = ElementIndex;
      return(HSSL_OP_OK);
   }
   //---------------------------------------------------------------
   // No Elements to fetch from UTC list, get oldest element ID list
   //----------------------------------------------------------
   if(pSessCacheCtlDesc->IdSlotsInUseCount != 0)
   {
      ElementIndex = pSessCacheCtlDesc->pIdSortedIndexArr[0];

      if((MoveCount = pSessCacheCtlDesc->IdSlotsInUseCount - 1) != 0)
      {
         memmove(pSessCacheCtlDesc->pIdSortedIndexArr,
            pSessCacheCtlDesc->pIdSortedIndexArr+1,
            MoveCount * sizeof(uint32_t));
      }
      pSessCacheCtlDesc->IdSlotsInUseCount--;

      if(CacheType == 0)
      {
         pCacheElement = (HSERV_CACHE_ELEM *)
            pSessCacheCtlDesc->pSessionCacheBuf + ElementIndex;
         ElementSize = sizeof(HSERV_CACHE_ELEM);
      }
      else
      {
         pCacheElement = (HCLNT_CACHE_ELEM *)
            pSessCacheCtlDesc->pSessionCacheBuf + ElementIndex;
         ElementSize = sizeof(HCLNT_CACHE_ELEM);
      }

      memset(pCacheElement,0,ElementSize);

      *pElementIndex = ElementIndex;
      return(HSSL_OP_OK);
   }
   //---------------------------------------------------------
   // Should not come here...
   //---------------------------------------------------------
   return(HSSL_PARAM_ERR);
}

/**
* Generates a unique session ID to use from supplied Random Session ID,
* current UTC and Cache control structure (ServerGenUniqueSessionID).
* NOTE: Supplied SessionID must be >= 8 bytes.
*
* -- ONLY SERVER SIDE --
*
*  @param pSessCacheCtlDesc Session control structure to be used
*  @param pSessionID Random ID and generated ID, 1st byte is length
*  @return 0 on success, error code otherwise
*/
extern "C" int ServerGenUniqueSessionID(HSESSCACHE_CTL_DESC * pSessCacheCtlDesc,
                                        char* pSessionID)
{
   uint32_t CurrentUtc, Modifier;
   //------------------------------------------------------------
   // Check parameters
   //------------------------------------------------------------
   if((pSessCacheCtlDesc == NULL) || (pSessionID == NULL))
      return(HSSL_NULL_PTR);

   if(pSessionID[0] < 8)
      return(HSSL_PARAM_ERR);

   //------------------------------------------------------------
   // Get current UTC, compare against last used Session Utc
   //------------------------------------------------------------
   CurrentUtc = (uint32_t) time(NULL);

   if(pSessCacheCtlDesc->LastSessIdPrefixUtc != CurrentUtc)
   {
      //----------------------------------------------------------
      // Current UTC different from last used, save
      //----------------------------------------------------------
      pSessCacheCtlDesc->LastSessIdPrefixUtc = CurrentUtc;

      pSessionID[5] &= 0x7F;			// clear the MSB

      Modifier = (((uint32_t) pSessionID[5] & 0x0FF) << 24) |
         (((uint32_t) pSessionID[6] & 0x0FF) << 16) |
         (((uint32_t) pSessionID[7] & 0x0FF) <<  8) |
         ((uint32_t) pSessionID[8] & 0x0FF);
      pSessCacheCtlDesc->LastSessIdPrefixModifier = Modifier;
   }
   else
   {
      //----------------------------------------------------------
      // Current UTC same as last used, take last modifier + 2
      //----------------------------------------------------------
      pSessCacheCtlDesc->LastSessIdPrefixModifier += 2;
      Modifier = pSessCacheCtlDesc->LastSessIdPrefixModifier;

      pSessionID[5] = (unsigned char) (Modifier >> 24);
      pSessionID[6] = (unsigned char) (Modifier >> 16);
      pSessionID[7] = (unsigned char) (Modifier >>  8);
      pSessionID[8] = (unsigned char) Modifier;
   }

   pSessionID[1] = (unsigned char) (CurrentUtc >> 24);
   pSessionID[2] = (unsigned char) (CurrentUtc >> 16);
   pSessionID[3] = (unsigned char) (CurrentUtc >>  8);
   pSessionID[4] = (unsigned char) CurrentUtc;

   return(HSSL_OP_OK);
}

/**
* Decrements the reference count of a server session cache entry
* identified by given session ID (DecrementSrvrCacheElementRefCount).
* If reference count is already at 0,
* ignore. If reference count drops to zero, puts cache element into
* UTC array list.
*
* Note: If cache element not found, ignore the request
*
* -- SERVER SIDE --
*
*  @param pSessCacheCtlDesc Session control structure to be used
*  @param pSessionID Session ID, 1st byte is length
*  @return 0 on success, error code otherwise
* <br>            > 0 special contition found:
* <br>            1 - no cache elements exist
* <br>            2 - no such element for given ID
*/
extern "C" int DecrementSrvrCacheElementRefCount(
   HSESSCACHE_CTL_DESC * pSessCacheCtlDesc,
   char* pSessionID)
{
   int Retcode;
   uint32_t IdArrIndex,IdArrMaxIndex,ElementIndex;
   uint32_t * pIdIndexArr;

   HSERV_CACHE_ELEM * pCacheElement;

   if((pSessCacheCtlDesc == NULL) || (pSessionID == NULL))
      return(HSSL_NULL_PTR);
   //----------------------------------------------------------------
   // Check if SessionID array has elements, if so search for element
   //----------------------------------------------------------------
   if((IdArrMaxIndex = pSessCacheCtlDesc->IdSlotsInUseCount) == 0) //none used
      return(1);				// signal no elements in use

   IdArrIndex = FindSessSrvrCacheEntryBySessionID(pSessCacheCtlDesc,pSessionID,
      NULL,NULL);
   if(IdArrIndex == (uint32_t) -1)	// not in array!
      return(2);				// signal element not found
   //----------------------------------------------------------------
   // Found the cache element, modify reference count
   //----------------------------------------------------------------
   pIdIndexArr = pSessCacheCtlDesc->pIdSortedIndexArr;

   ElementIndex = pIdIndexArr[IdArrIndex];	// get element number
   pCacheElement =
      (HSERV_CACHE_ELEM *) pSessCacheCtlDesc->pSessionCacheBuf + ElementIndex;

   if(pCacheElement->ReferenceCount == 0)	// already at count 0
      return(0);					// reduced, o.k.

   pCacheElement->ReferenceCount--;		// reduce reference count

   if(pCacheElement->ReferenceCount != 0)	// check if now reached 0
      return(0);					// no, 'keep alive'
   //----------------------------------------------------------------
   // Reference count dropped to 0, put Element to UTC Array
   //----------------------------------------------------------------
   Retcode = PutSrvrCacheElementToUtcArray(pSessCacheCtlDesc,ElementIndex);
   return(Retcode);
}
/**
* Decrements the reference count of a client session cache entry
* identified by given connection and session ID (DecrementClntCacheElementRefCount). 
* If reference count
* is already at 0, ignore. If reference count drops to zero, puts cache
* element into UTC array list.
*
* Note: If cache element not found, or different sessionID ignore the request
*
* -- CLIENT SIDE --
*
*  @param pSessCacheCtlDesc Session control structure to be used
*  @param pConnectionID Connection ID, 2nd byte is length
*  @param pSessionID Session ID, 1st byte is length
*  @return < 0 error occured
* <br>            == 0 o.k., reference count reduced
* <br>            > 0 special condition found:
* <br>            1 - no cache elements exist
* <br>            2 - no such element for given connection ID
* <br>            3 - element has different sessionID
*/
extern "C" int DecrementClntCacheElementRefCount(
   HSESSCACHE_CTL_DESC * pSessCacheCtlDesc,
   char* pConnectionID, char* pSessionID)
{
   int Retcode;
   uint32_t IdArrIndex,IdArrMaxIndex,ElementIndex;
   uint32_t * pIdIndexArr;

   HCLNT_CACHE_ELEM * pCacheElement;

   if((pSessCacheCtlDesc == NULL) || (pConnectionID == NULL) ||
      (pSessionID == NULL))
      return(HSSL_NULL_PTR);
   //----------------------------------------------------------------
   // Check if ID array has elements, if so search for element
   //----------------------------------------------------------------
   if((IdArrMaxIndex = pSessCacheCtlDesc->IdSlotsInUseCount) == 0) //none used
      return(1);				// signal no elements in use

   IdArrIndex = FindSessClntCacheEntryByConnectionID(pSessCacheCtlDesc,
      pConnectionID,
      NULL,NULL);
   if(IdArrIndex == (uint32_t) -1)	// not in array!
      return(2);				// signal element not found

   //----------------------------------------------------------------
   // Address the Cache element
   //----------------------------------------------------------------
   pIdIndexArr = pSessCacheCtlDesc->pIdSortedIndexArr;

   ElementIndex = pIdIndexArr[IdArrIndex];	// get element number
   pCacheElement =
      (HCLNT_CACHE_ELEM *) pSessCacheCtlDesc->pSessionCacheBuf + ElementIndex;
   //----------------------------------------------------------------
   // compare session IDs
   //----------------------------------------------------------------
   if(((int) pSessionID[0] & 0x0FF) !=
      ((int) pCacheElement->SessionID[0] & 0x0FF))
      return(3);					// different IDs

   if(memcmp(pCacheElement->SessionID+1,pSessionID+1,
      (int) *pSessionID & 0x0FF) != 0)
      return(3);					// different IDs

   //----------------------------------------------------------------
   // check if already reference count 0
   //----------------------------------------------------------------
   if(pCacheElement->ReferenceCount == 0)	// already at count 0
      return(0);					// reduced, o.k.

   pCacheElement->ReferenceCount--;		// reduce reference count

   if(pCacheElement->ReferenceCount != 0)	// check if now reached 0
      return(0);					// no, 'keep alive'
   //----------------------------------------------------------------
   // Reference count dropped to 0, put Element to UTC Array
   //----------------------------------------------------------------
   Retcode = PutClntCacheElementToUtcArray(pSessCacheCtlDesc,ElementIndex);
   return(Retcode);
}
/**
* Decrements the reference count of a client session cache entry
* identified by given connection and session ID (DecrClntCacheElementRefCountRemoveIfZero). 
* If reference count
* is already at 0 / drops to zero, removes element.
*
* Note: If cache element not found, or different sessionID ignore the request
*
* -- CLIENT SIDE --
*
*  @param pSessCacheCtlDesc Session control structure to be used
*  @param pConnectionID Connection ID, 2nd byte is length
*  @param pSessionID Session ID, 1st byte is length
*  @param CloneInhibit if <> 0 mark as no longer clonable
*  @return 0 on success, error code otherwise
* <br>            > 0 special condition found:
* <br>            1 - no cache elements exist
* <br>            2 - no such element for given connection ID
* <br>            3 - element has different sessionID
*/
extern "C" int DecrClntCacheElementRefCountRemoveIfZero(
   HSESSCACHE_CTL_DESC * pSessCacheCtlDesc,
   char* pConnectionID, char* pSessionID,
   int CloneInhibit)
{
   int Retcode;
   uint32_t IdArrIndex,IdArrMaxIndex,ElementIndex,StateMask,StateElement;
   uint32_t * pIdIndexArr;

   HCLNT_CACHE_ELEM * pCacheElement;

   if((pSessCacheCtlDesc == NULL) || (pConnectionID == NULL) ||
      (pSessionID == NULL))
      return(HSSL_NULL_PTR);
   //----------------------------------------------------------------
   // Check if ID array has elements, if so search for element
   //----------------------------------------------------------------
   if((IdArrMaxIndex = pSessCacheCtlDesc->IdSlotsInUseCount) == 0) //none used
      return(1);				// signal no elements in use

   IdArrIndex = FindSessClntCacheEntryByConnectionID(pSessCacheCtlDesc,
      pConnectionID,
      NULL,NULL);
   if(IdArrIndex == (uint32_t) -1)	// not in array!
      return(2);				// signal element not found

   //----------------------------------------------------------------
   // Address the Cache element
   //----------------------------------------------------------------
   pIdIndexArr = pSessCacheCtlDesc->pIdSortedIndexArr;

   ElementIndex = pIdIndexArr[IdArrIndex];	// get element number
   pCacheElement =
      (HCLNT_CACHE_ELEM *) pSessCacheCtlDesc->pSessionCacheBuf + ElementIndex;
   //----------------------------------------------------------------
   // compare session IDs
   //----------------------------------------------------------------
   if(((int) pSessionID[0] & 0x0FF) !=
      ((int) pCacheElement->SessionID[0] & 0x0FF))
      return(3);					// different IDs

   if(memcmp(pCacheElement->SessionID+1,pSessionID+1,
      (int) *pSessionID & 0x0FF) != 0)
      return(3);					// different IDs

   //----------------------------------------------------------------
   // reduce Reference count, check for zero
   //----------------------------------------------------------------
   if(CloneInhibit != 0)
      pCacheElement->Flags |= CLNT_CACHE_FLG_CLONE_INHIBIT;

   if(pCacheElement->ReferenceCount != 0)	// not yet 0
      pCacheElement->ReferenceCount--;		// reduce count

   if(pCacheElement->ReferenceCount != 0)	// still in use...
      return(HSSL_OP_OK);

   //-------------------------------------------------------------------
   // Remove the Element from UTC array, ignore not found case
   //-------------------------------------------------------------------
   if((Retcode = RemoveCacheElementFromUtcArray(pSessCacheCtlDesc,
      CLIENT_CACHE_TYPE,
      pCacheElement->ExpireUtcMsw,
      pCacheElement->ExpireUtcLsw)) < 0)
      return(Retcode);
   //-------------------------------------------------------------------
   // Remove the Element from ConnectionID array, ignore not found case
   //-------------------------------------------------------------------
   if((Retcode = RemoveCacheElementFromIdArray(pSessCacheCtlDesc,
      CLIENT_CACHE_TYPE,
      pCacheElement->ConnectionID)) < 0)
      return(Retcode);
   //-------------------------------------------------------------------
   // Clear the cache element (Master secret, session ID)
   //-------------------------------------------------------------------
   memset(pCacheElement,0,sizeof(HCLNT_CACHE_ELEM));
   //-------------------------------------------------------------------
   // Mark element as no longer in use
   //-------------------------------------------------------------------
   StateMask = (uint32_t) 0x01 << (ElementIndex % 32); // get bit mask

   StateElement = pSessCacheCtlDesc->pUseStateBitsList[ElementIndex/32];
   StateElement = StateElement & (~StateMask);	     // clear in use bit
   pSessCacheCtlDesc->pUseStateBitsList[ElementIndex/32] = StateElement; // set new bits

   pSessCacheCtlDesc->SlotsInUseCount--;

   return(HSSL_OP_OK);
}

/**
* Decrements the reference count of a server session cache entry identified
* by session ID from the template element (DecrSrvrCacheElementRefCountOrAddNew). 
* If reference count is already at 0, 
* ignore. If reference count drops to zero, puts cache element into UTC array 
* list. If cache element not yet present, adds a copy of the template with 
* reference count 0 and puts to the UTC array list.
*
* Sets the element fields Reserved1, ExpireUtcMsw and ExpireUtcLsw 0 for the
* template copy.
*
* -- SERVER SIDE --
*
*  @param pSessCacheCtlDesc Session control structure to be used
*  @param pElementTemplate Used template element
*  @return 0 on success, error code otherwise
* <br>            > 0 special conditions:
* <br>            1 - no memory for new element add
*/
extern "C" int DecrSrvrCacheElementRefCountOrAddNew(
   HSESSCACHE_CTL_DESC * pSessCacheCtlDesc,
   HSERV_CACHE_ELEM * pElementTemplate)
{
   int Retcode;
   uint32_t ElementIndex;

   HSERV_CACHE_ELEM * pCacheElement;

   if((pSessCacheCtlDesc == NULL) || (pElementTemplate == NULL))
      return(HSSL_NULL_PTR);
   //-------------------------------------------------------------------
   // Check valid session ID in Template
   //-------------------------------------------------------------------
   if(pElementTemplate->SessionID[0] == 0)
      return(HSSL_PARAM_ERR);

   //-------------------------------------------------------------------
   // Try to decrement reference count for already present cache element
   //-------------------------------------------------------------------
   Retcode = DecrementSrvrCacheElementRefCount(pSessCacheCtlDesc,
      pElementTemplate->SessionID);

   if(Retcode <= 0)			// error or o.k.
      return(Retcode);
   //-------------------------------------------------------------------
   // No element found for that session ID, get a new one to use
   //-------------------------------------------------------------------
   Retcode = GetUsableCacheElement(pSessCacheCtlDesc, 0,
      &ElementIndex);
   if(Retcode != HSSL_OP_OK)
      return(Retcode);
   //-------------------------------------------------------------------
   // Check if we *REALLY* got an element to use
   //-------------------------------------------------------------------
   if(ElementIndex == (uint32_t) -1)
      return(1);				// no memory for Element Add
   //-------------------------------------------------------------------
   // Got a new Element, get structure pointer
   //-------------------------------------------------------------------
   pCacheElement =
      (HSERV_CACHE_ELEM *) pSessCacheCtlDesc->pSessionCacheBuf + ElementIndex;

   //---------------------------------------------------------------------
   // Copy Template contents to new cache element, clear specific elements
   //---------------------------------------------------------------------
   memcpy(pCacheElement,pElementTemplate,sizeof(HSERV_CACHE_ELEM));

   pCacheElement->Reserved1      = 0;
   pCacheElement->ReferenceCount = 0;
   pCacheElement->ExpireUtcMsw   = 0;
   pCacheElement->ExpireUtcLsw   = 0;

   //---------------------------------------------------------------------
   // Put the new Element to sorted SessionID array
   //---------------------------------------------------------------------
   Retcode = PutSrvrCacheElementToSessIDArray(pSessCacheCtlDesc,ElementIndex);

   if(Retcode != 0)
   {
      if(Retcode > 0)			// duplicate, strange
         Retcode = HSSL_PARAM_ERR;
      return(Retcode);
   }    
   //---------------------------------------------------------------------
   // Also put element to the Sorted Utc Array list (Refcount == 0)
   //---------------------------------------------------------------------
   Retcode = PutSrvrCacheElementToUtcArray(pSessCacheCtlDesc,ElementIndex);
   return(Retcode);
}
/**
* Increments the reference count of a server session cache entry
* identified by given session ID (IncrementSrvrCacheElementRefCount). 
* If reference count was 0, removes
* element from UTC index array list.
* Note: If cache element not found, ignore the request
* 
* -- SERVER SIDE --
*
*  @param pSessCacheCtlDesc Session control structure to be used
*  @param pSessionID Session ID, 1st byte is length
*  @return 0 on success, error code otherwise
* <br>            > 0 special contition found:
* <br>            1 - no cache elements exist
* <br>            2 - no such element for given ID
*/
extern "C" int IncrementSrvrCacheElementRefCount(
   HSESSCACHE_CTL_DESC * pSessCacheCtlDesc,
   char* pSessionID)
{
   int Retcode;
   uint32_t IdArrIndex,IdArrMaxIndex,ElementIndex;
   uint32_t * pIdIndexArr;

   HSERV_CACHE_ELEM * pCacheElement;

   if((pSessCacheCtlDesc == NULL) || (pSessionID == NULL))
      return(HSSL_NULL_PTR);
   //----------------------------------------------------------------
   // Check if SessionID array has elements, if so search for element
   //----------------------------------------------------------------
   if((IdArrMaxIndex = pSessCacheCtlDesc->IdSlotsInUseCount) == 0) //none used
      return(1);				// signal no elements in use

   IdArrIndex = FindSessSrvrCacheEntryBySessionID(pSessCacheCtlDesc,pSessionID,
      NULL,NULL);
   if(IdArrIndex == (uint32_t) -1)	// not in array!
      return(2);				// signal element not found
   //----------------------------------------------------------------
   // Found the cache element, modify reference count
   //----------------------------------------------------------------
   pIdIndexArr = pSessCacheCtlDesc->pIdSortedIndexArr;

   ElementIndex = pIdIndexArr[IdArrIndex];	// get element number
   pCacheElement =
      (HSERV_CACHE_ELEM *) pSessCacheCtlDesc->pSessionCacheBuf + ElementIndex;

   if(pCacheElement->ReferenceCount != 0)	// is NOT on UTC array
   {
      pCacheElement->ReferenceCount++;		// increase reference count
      return(0);					// increased, o.k.
   }
   //----------------------------------------------------------------
   // Reference count was 0, Element is on the UTC array, remove it
   //----------------------------------------------------------------
   pCacheElement->ReferenceCount++;		// increase reference count

   Retcode = RemoveCacheElementFromUtcArray(pSessCacheCtlDesc,
      SERVER_CACHE_TYPE,
      pCacheElement->ExpireUtcMsw,
      pCacheElement->ExpireUtcLsw);
   return(Retcode);
}
/**
* Increments the reference count of a session cache entry identified by
* session ID in the template (IncrSrvrCacheElementRefCountOrAddNew).
* If reference was 0, removes from UTC index list.
* If cache element not yet present, adds a copy of the template with reference
* count 1.
*
* Sets the element fields Reserved1, ExpireUtcMsw and ExpireUtcLsw 0 for the
* template copy.
*
* -- SERVER SIDE --
*
*  @param pSessCacheCtlDesc Session control structure to be used
*  @param pElementTemplate Template element to be used
*  @return 0 on success, error code otherwise
* <br>            > 0 special conditions:
* <br>            1 - no memory for new element add
*/
extern "C" int IncrSrvrCacheElementRefCountOrAddNew(
   HSESSCACHE_CTL_DESC * pSessCacheCtlDesc,
   HSERV_CACHE_ELEM * pElementTemplate)
{
   int Retcode;
   uint32_t ElementIndex;

   HSERV_CACHE_ELEM * pCacheElement;

   if((pSessCacheCtlDesc == NULL) || (pElementTemplate == NULL))
      return(HSSL_NULL_PTR);
   //-------------------------------------------------------------------
   // Check valid session ID in Template
   //-------------------------------------------------------------------
   if(pElementTemplate->SessionID[0] == 0)
      return(HSSL_PARAM_ERR);

   //-------------------------------------------------------------------
   // Try to increment reference count for already present cache element
   //-------------------------------------------------------------------
   Retcode = IncrementSrvrCacheElementRefCount(pSessCacheCtlDesc,
      pElementTemplate->SessionID);

   if(Retcode <= 0)			// error or o.k.
      return(Retcode);
   //-------------------------------------------------------------------
   // No element found for that session ID, get a new one to use
   //-------------------------------------------------------------------
   Retcode = GetUsableCacheElement(pSessCacheCtlDesc, 0,
      &ElementIndex);
   if(Retcode != HSSL_OP_OK)
      return(Retcode);
   //-------------------------------------------------------------------
   // Check if we *REALLY* got an element to use
   //-------------------------------------------------------------------
   if(ElementIndex == (uint32_t) -1)
      return(1);				// no memory for Element Add
   //-------------------------------------------------------------------
   // Got a new Element, get structure pointer
   //-------------------------------------------------------------------
   pCacheElement =
      (HSERV_CACHE_ELEM *) pSessCacheCtlDesc->pSessionCacheBuf + ElementIndex;

   //---------------------------------------------------------------------
   // Copy Template contents to new cache element, clear specific elements
   //---------------------------------------------------------------------
   memcpy(pCacheElement,pElementTemplate,sizeof(HSERV_CACHE_ELEM));

   pCacheElement->Reserved1      = 0;
   pCacheElement->ReferenceCount = 1;
   pCacheElement->ExpireUtcMsw   = 0;
   pCacheElement->ExpireUtcLsw   = 0;

   //---------------------------------------------------------------------
   // Put the new Element to sorted SessionID array
   //---------------------------------------------------------------------
   Retcode = PutSrvrCacheElementToSessIDArray(pSessCacheCtlDesc,ElementIndex);

   if(Retcode != 0)
   {
      if(Retcode > 0)			// duplicate, strange
         Retcode = HSSL_PARAM_ERR;
      return(Retcode);
   }    
   return(HSSL_OP_OK);
}
/**
* Adds a new server session cache entry. Gets an element to use, copies
* template data, inserts into sessionID array and sets reference count to 1 (AddNewSrvrCacheElement).
*
* -- SERVER SIDE --
*
*  @param pSessCacheCtlDesc Session control structure to be used
*  @param pElementTemplate Template to use
*  @return 0 on success, error code otherwise
* <br>            > 0 special conditions:
* <br>            1 - no memory for new element add
* <br>            2 - duplicate SessionID found with different params
*/
extern "C" int AddNewSrvrCacheElement(
   HSESSCACHE_CTL_DESC * pSessCacheCtlDesc,
   HSERV_CACHE_ELEM * pElementTemplate)
{
   int Retcode;
   uint32_t IdArrayIndex,ElementIndex,StateMask,StateElement;

   HSERV_CACHE_ELEM * pCacheElement;

   if((pSessCacheCtlDesc == NULL) || (pElementTemplate == NULL))
      return(HSSL_NULL_PTR);
   //-------------------------------------------------------------------
   // Check valid session ID in Template
   //-------------------------------------------------------------------
   if(pElementTemplate->SessionID[0] == 0)
      return(HSSL_PARAM_ERR);

   //-------------------------------------------------------------------
   // Check if SessionID already in use
   //-------------------------------------------------------------------
   IdArrayIndex = FindSessSrvrCacheEntryBySessionID(pSessCacheCtlDesc,
      pElementTemplate->SessionID,
      NULL, NULL);
   if(IdArrayIndex != (uint32_t) -1)
   {
      //------------------------------------------------------------------
      // We have a duplicate, check if same parameters
      //------------------------------------------------------------------
      ElementIndex = pSessCacheCtlDesc->pIdSortedIndexArr[IdArrayIndex];

      pCacheElement =
         (HSERV_CACHE_ELEM *) pSessCacheCtlDesc->pSessionCacheBuf + ElementIndex;

      //------------------------------------------------------------------
      // Check same protocol, Compression/Cipher method, certified flags
      //------------------------------------------------------------------
      if((pCacheElement->SelectedProtocol !=
         pElementTemplate->SelectedProtocol) ||
         (pCacheElement->SelectedComprMethod !=
         pElementTemplate->SelectedComprMethod) ||
         (pCacheElement->SelectedCipherSuite !=
         pElementTemplate->SelectedCipherSuite) ||
         (pCacheElement->CertifiedFlags !=
         pElementTemplate->CertifiedFlags))
         return(2);				// parameter mismatch duplicate
      //------------------------------------------------------------------
      // Check same master secret, Certificate hash
      //------------------------------------------------------------------
      if(memcmp(pElementTemplate->MasterSecret,pCacheElement->MasterSecret,
         MASTER_SECRET_LEN) != 0)
         return(2);				// parameter mismatch duplicate

      if(memcmp(pElementTemplate->PartnerCertHash,pCacheElement->PartnerCertHash,
         SHA_DIGEST_LEN) != 0)
         return(2);				// we have a duplicate !!
      //-----------------------------------------------------------------
      // Parameters matched, remove from UTC array if on array
      //-----------------------------------------------------------------
      if(pCacheElement->ReferenceCount != 0)	// is active, o.k.
         return(HSSL_OP_OK);

      pCacheElement->ReferenceCount = 1;		// set as active

      Retcode = RemoveCacheElementFromUtcArray(pSessCacheCtlDesc,
         SERVER_CACHE_TYPE,
         pCacheElement->ExpireUtcMsw,
         pCacheElement->ExpireUtcLsw);
      if(Retcode < 0)				// error occured
         return(Retcode);

      return(HSSL_OP_OK);				// ignore 'not found' case!
   }
   //-------------------------------------------------------------------
   // No element found for that session ID, get a new one to use
   //-------------------------------------------------------------------
   Retcode = GetUsableCacheElement(pSessCacheCtlDesc, 0,
      &ElementIndex);
   if(Retcode != HSSL_OP_OK)
      return(Retcode);
   //-------------------------------------------------------------------
   // Check if we *REALLY* got an element to use
   //-------------------------------------------------------------------
   if(ElementIndex == (uint32_t) -1)
      return(1);				// no memory for Element Add
   //-------------------------------------------------------------------
   // Got a new Element, get structure pointer
   //-------------------------------------------------------------------
   pCacheElement =
      (HSERV_CACHE_ELEM *) pSessCacheCtlDesc->pSessionCacheBuf + ElementIndex;

   //---------------------------------------------------------------------
   // Copy Template contents to new cache element, clear specific elements
   //---------------------------------------------------------------------
   memcpy(pCacheElement,pElementTemplate,sizeof(HSERV_CACHE_ELEM));

   pCacheElement->Reserved1      = 0;
   pCacheElement->ReferenceCount = 1;
   pCacheElement->ExpireUtcMsw   = 0;
   pCacheElement->ExpireUtcLsw   = 0;

   //---------------------------------------------------------------------
   // Put the new Element to sorted SessionID array
   //---------------------------------------------------------------------
   Retcode = PutSrvrCacheElementToSessIDArray(pSessCacheCtlDesc,ElementIndex);

   if(Retcode != 0)
   {
      //-----------------------------------------------------------
      // Put ID failed, 'free' Cache element
      //-----------------------------------------------------------
      StateMask = (uint32_t) 0x01 << (ElementIndex % 32); // get bit mask

      StateElement = pSessCacheCtlDesc->pUseStateBitsList[ElementIndex/32];
      StateElement = StateElement & (~StateMask);	     // clear in use bit
      pSessCacheCtlDesc->pUseStateBitsList[ElementIndex/32] = StateElement; // set new bits

      pSessCacheCtlDesc->SlotsInUseCount--;

      if(Retcode > 0)			// duplicate, strange
         Retcode = HSSL_PARAM_ERR;
      return(Retcode);
   }    
   return(HSSL_OP_OK);
}

/**
* Adds a new client session cache entry. Gets an element to use, copies
* template data, inserts into ConnectionID array and sets reference count to 1 (AddReplaceClntCacheElement).
* NOTE: If already an element exists (regardless of sessionID),
*   replace parameters of element with template given.
*
* -- CLIENT SIDE --
*
*  @param pSessCacheCtlDesc Session control structure to be used
*  @param pElementTemplate Template to use
*  @return 0 on success, error code otherwise
* <br>            > 0 special conditions:
* <br>            1 - no memory for new element add
*/
extern "C" int AddReplaceClntCacheElement(
   HSESSCACHE_CTL_DESC * pSessCacheCtlDesc,
   HCLNT_CACHE_ELEM * pElementTemplate)
{
   int Retcode;
   uint32_t IdArrayIndex,ElementIndex,StateMask,StateElement;

   HCLNT_CACHE_ELEM * pCacheElement;

   if((pSessCacheCtlDesc == NULL) || (pElementTemplate == NULL))
      return(HSSL_NULL_PTR);
   //-------------------------------------------------------------------
   // Check valid connection ID, session ID in Template
   //-------------------------------------------------------------------
   if(pElementTemplate->ConnectionID[1] == 0)
      return(HSSL_PARAM_ERR);
   if(pElementTemplate->SessionID[0] == 0)
      return(HSSL_PARAM_ERR);

   //-------------------------------------------------------------------
   // Check if ConnectionID already in use
   //-------------------------------------------------------------------
   IdArrayIndex = FindSessClntCacheEntryByConnectionID(pSessCacheCtlDesc,
      pElementTemplate->ConnectionID,
      NULL, NULL);
   if(IdArrayIndex != (uint32_t) -1)
   {
      //------------------------------------------------------------------
      // We already have an element, replace the parameters
      //------------------------------------------------------------------
      ElementIndex = pSessCacheCtlDesc->pIdSortedIndexArr[IdArrayIndex];

      pCacheElement =
         (HCLNT_CACHE_ELEM *) pSessCacheCtlDesc->pSessionCacheBuf + ElementIndex;

      //------------------------------------------------------------------
      // Set new parameters from template
      //------------------------------------------------------------------
      pCacheElement->SelectedProtocol    = pElementTemplate->SelectedProtocol;
      pCacheElement->SelectedComprMethod = pElementTemplate->SelectedComprMethod;
      pCacheElement->SelectedCipherSuite = pElementTemplate->SelectedCipherSuite;

      pCacheElement->CertifiedFlags      = pElementTemplate->CertifiedFlags;

      memcpy(pCacheElement->MasterSecret,
         pElementTemplate->MasterSecret, MASTER_SECRET_LEN);

      memcpy(pCacheElement->PartnerCertHash,
         pElementTemplate->PartnerCertHash, SHA_DIGEST_LEN);
      //-----------------------------------------------------------------
      // Remove from UTC array if on array
      //-----------------------------------------------------------------
      if(pCacheElement->ReferenceCount != 0)	// is active, o.k.
         return(HSSL_OP_OK);

      pCacheElement->ReferenceCount = 1;		// set as active

      Retcode = RemoveCacheElementFromUtcArray(pSessCacheCtlDesc,
         CLIENT_CACHE_TYPE,
         pCacheElement->ExpireUtcMsw,
         pCacheElement->ExpireUtcLsw);
      if(Retcode < 0)				// error occured
         return(Retcode);

      return(HSSL_OP_OK);				// ignore 'not found' case!
   }
   //--------------------------------------------------------------
   // No element found for that connection ID, get a new one to use
   //--------------------------------------------------------------
   Retcode = GetUsableCacheElement(pSessCacheCtlDesc, 1,
      &ElementIndex);
   if(Retcode != HSSL_OP_OK)
      return(Retcode);
   //-------------------------------------------------------------------
   // Check if we *REALLY* got an element to use
   //-------------------------------------------------------------------
   if(ElementIndex == (uint32_t) -1)
      return(1);				// no memory for Element Add
   //-------------------------------------------------------------------
   // Got a new Element, get structure pointer
   //-------------------------------------------------------------------
   pCacheElement =
      (HCLNT_CACHE_ELEM *) pSessCacheCtlDesc->pSessionCacheBuf + ElementIndex;

   //---------------------------------------------------------------------
   // Copy Template contents to new cache element, clear specific elements
   //---------------------------------------------------------------------
   memcpy(pCacheElement,pElementTemplate,sizeof(HCLNT_CACHE_ELEM));

   pCacheElement->Flags          = 0;
   pCacheElement->ReferenceCount = 1;
   pCacheElement->ExpireUtcMsw   = 0;
   pCacheElement->ExpireUtcLsw   = 0;

   //---------------------------------------------------------------------
   // Put the new Element to sorted SessionID array
   //---------------------------------------------------------------------
   Retcode = PutClntCacheElementToSessIDArray(pSessCacheCtlDesc,ElementIndex);

   if(Retcode != 0)
   {
      //-----------------------------------------------------------
      // Put ID failed, 'free' Cache element
      //-----------------------------------------------------------
      StateMask = (uint32_t) 0x01 << (ElementIndex % 32); // get bit mask

      StateElement = pSessCacheCtlDesc->pUseStateBitsList[ElementIndex/32];
      StateElement = StateElement & (~StateMask);	     // clear in use bit
      pSessCacheCtlDesc->pUseStateBitsList[ElementIndex/32] = StateElement; // set new bits

      pSessCacheCtlDesc->SlotsInUseCount--;

      if(Retcode > 0)			// duplicate, strange
         Retcode = HSSL_PARAM_ERR;
      return(Retcode);
   }    
   return(HSSL_OP_OK);
}

/**
* Adds a client session cache entry, if none in cache yet. If already
* one found, and same ID, increment reference count (ConditionalAddClntCacheElement).
*
* -- CLIENT SIDE --
*
*  @param pSessCacheCtlDesc Session control structure to be used
*  @param pElementTemplate Element to add
*  @return == 0 added new element
* <br>            > 0 special conditions:
* <br>            1 - no memory for new element add
* <br>            2 - found element different sessionID
* <br>            3 - found element same ID, count > 0
* <br>            4 - found element same ID, count was 0
*/
extern "C" int ConditionalAddClntCacheElement(
   HSESSCACHE_CTL_DESC * pSessCacheCtlDesc,
   HCLNT_CACHE_ELEM * pElementTemplate)
{
   int Retcode;
   uint32_t IdArrayIndex,ElementIndex,StateMask,StateElement;

   HCLNT_CACHE_ELEM * pCacheElement;

   if((pSessCacheCtlDesc == NULL) || (pElementTemplate == NULL))
      return(HSSL_NULL_PTR);
   //-------------------------------------------------------------------
   // Check valid connection ID, session ID in Template
   //-------------------------------------------------------------------
   if(pElementTemplate->ConnectionID[1] == 0)
      return(HSSL_PARAM_ERR);
   if(pElementTemplate->SessionID[0] == 0)
      return(HSSL_PARAM_ERR);

   //-------------------------------------------------------------------
   // Check if a ConnectionID already in use
   //-------------------------------------------------------------------
   IdArrayIndex = FindSessClntCacheEntryByConnectionID(pSessCacheCtlDesc,
      pElementTemplate->ConnectionID,
      NULL, NULL);
   if(IdArrayIndex != (uint32_t) -1)
   {
      //------------------------------------------------------------------
      // We already have an element, check if same session ID
      //------------------------------------------------------------------
      ElementIndex = pSessCacheCtlDesc->pIdSortedIndexArr[IdArrayIndex];

      pCacheElement =
         (HCLNT_CACHE_ELEM *) pSessCacheCtlDesc->pSessionCacheBuf + ElementIndex;

      if(((int) pElementTemplate->SessionID[0] & 0x0FF) != 
         ((int) pCacheElement->SessionID[0] & 0x0FF))
         return(2);				// different ID

      if(memcmp(pElementTemplate->SessionID+1,pCacheElement->SessionID+1,
         (int) pElementTemplate->SessionID[0] & 0x0FF) != 0)
         return(2);				// different ID
      //------------------------------------------------------------------
      // Same session ID, check reference count > 0
      //------------------------------------------------------------------
      if(pCacheElement->ReferenceCount != 0)	// is above 0, o.k.
         return(3);
      //------------------------------------------------------------------
      // Same session ID, Element is not referenced, increment
      //------------------------------------------------------------------
      Retcode = RemoveCacheElementFromUtcArray(pSessCacheCtlDesc,
         CLIENT_CACHE_TYPE,
         pCacheElement->ExpireUtcMsw,
         pCacheElement->ExpireUtcLsw);
      if(Retcode < 0)				// error occured
         return(Retcode);

      pCacheElement->ReferenceCount = 1;	// set referenced
      return(4);
   }
   //--------------------------------------------------------------
   // No element found for that connection ID, get a new one to use
   //--------------------------------------------------------------
   Retcode = GetUsableCacheElement(pSessCacheCtlDesc,
      CLIENT_CACHE_TYPE,
      &ElementIndex);
   if(Retcode != HSSL_OP_OK)
      return(Retcode);
   //-------------------------------------------------------------------
   // Check if we *REALLY* got an element to use
   //-------------------------------------------------------------------
   if(ElementIndex == (uint32_t) -1)
      return(1);				// no memory for Element Add
   //-------------------------------------------------------------------
   // Got a new Element, get structure pointer
   //-------------------------------------------------------------------
   pCacheElement =
      (HCLNT_CACHE_ELEM *) pSessCacheCtlDesc->pSessionCacheBuf + ElementIndex;

   //---------------------------------------------------------------------
   // Copy Template contents to new cache element, clear specific elements
   //---------------------------------------------------------------------
   memcpy(pCacheElement,pElementTemplate,sizeof(HCLNT_CACHE_ELEM));

   pCacheElement->Flags          = 0;
   pCacheElement->ReferenceCount = 1;
   pCacheElement->ExpireUtcMsw   = 0;
   pCacheElement->ExpireUtcLsw   = 0;

   //---------------------------------------------------------------------
   // Put the new Element to sorted SessionID array
   //---------------------------------------------------------------------
   Retcode = PutClntCacheElementToSessIDArray(pSessCacheCtlDesc,ElementIndex);

   if(Retcode != 0)
   {
      //-----------------------------------------------------------
      // Put ID failed, 'free' Cache element
      //-----------------------------------------------------------
      StateMask = (uint32_t) 0x01 << (ElementIndex % 32); // get bit mask

      StateElement = pSessCacheCtlDesc->pUseStateBitsList[ElementIndex/32];
      StateElement = StateElement & (~StateMask);	     // clear in use bit
      pSessCacheCtlDesc->pUseStateBitsList[ElementIndex/32] = StateElement; // set new bits

      pSessCacheCtlDesc->SlotsInUseCount--;

      if(Retcode > 0)			// duplicate, strange
         Retcode = HSSL_PARAM_ERR;
      return(Retcode);
   }    
   return(HSSL_OP_OK);
}

/**
* 'Frees' an expired server cache element (FreeSrvrCacheElementByUtcIndex).
*
* -- SERVER SIDE --
*<ul>
* <li> Remove element from Session ID array.
* <li> Clear element master secret.
* <li> Mark element as not used.
* <li> Reduce slots in use count.
*</ul>
*  @param pSessCacheCtlDesc Session control structure to be used
*  @param UtcArrIndex Reference index into UTC-Array
*  @return 0 on success, error code otherwise
* <br>            > 0 special conditions:
* <br>            1 - element not freed ?
*/
static int FreeSrvrCacheElementByUtcIndex(
   HSESSCACHE_CTL_DESC * pSessCacheCtlDesc,
   uint32_t UtcArrIndex)
{
   int Retcode;
   uint32_t StateElement,StateMask,ElementIndex;

   HSERV_CACHE_ELEM * pCacheElement;

   if(pSessCacheCtlDesc == NULL)
      return(HSSL_NULL_PTR);
   //-------------------------------------------------------------------
   // Get the element index/Element pointer from the UTC Array index
   //-------------------------------------------------------------------
   ElementIndex = pSessCacheCtlDesc->pUtcSortedIndexArr[UtcArrIndex];
   pCacheElement =
      (HSERV_CACHE_ELEM *) pSessCacheCtlDesc->pSessionCacheBuf + ElementIndex;
   //-------------------------------------------------------------------
   // Remove the Element from the SessionID array, ignore not found case
   //-------------------------------------------------------------------
   Retcode = RemoveCacheElementFromIdArray(pSessCacheCtlDesc,
      SERVER_CACHE_TYPE,
      pCacheElement->SessionID);
   if(Retcode < 0)
      return(Retcode);
   //-------------------------------------------------------------------
   // Clear the cache element (Master secret, session ID)
   //-------------------------------------------------------------------
   memset(pCacheElement,0,sizeof(HSERV_CACHE_ELEM));
   //-------------------------------------------------------------------
   // Mark element as no longer in use
   //-------------------------------------------------------------------
   StateMask = (uint32_t) 0x01 << (ElementIndex % 32); // get bit mask

   StateElement = pSessCacheCtlDesc->pUseStateBitsList[ElementIndex/32];
   StateElement = StateElement & (~StateMask);	     // clear in use bit
   pSessCacheCtlDesc->pUseStateBitsList[ElementIndex/32] = StateElement; // set new bits

   pSessCacheCtlDesc->SlotsInUseCount--;

   return(HSSL_OP_OK);
}
/**
* 'Frees' an expired client cache element (FreeClntCacheElementByUtcIndex).
*
* -- CLIENT SIDE --
*<ul>
* <li> Remove element from Connection ID array
* <li> Clear element master secret.
* <li> Mark element as not used.
* <li> Reduce slots in use count.
*</ul>
*  @param pSessCacheCtlDesc Session control structure to be used
*  @param UtcArrIndex  Reference index into UTC-Array
*  @return 0 on success, error code otherwise
* <br>            > 0 special conditions:
* <br>            1 - element not freed ?
*/
static int FreeClntCacheElementByUtcIndex(
   HSESSCACHE_CTL_DESC * pSessCacheCtlDesc,
   uint32_t UtcArrIndex)
{
   int Retcode;
   uint32_t StateElement,StateMask,ElementIndex;

   HCLNT_CACHE_ELEM * pCacheElement;

   if(pSessCacheCtlDesc == NULL)
      return(HSSL_NULL_PTR);
   //-------------------------------------------------------------------
   // Get the element index/Element pointer from the UTC Array index
   //-------------------------------------------------------------------
   ElementIndex = pSessCacheCtlDesc->pUtcSortedIndexArr[UtcArrIndex];
   pCacheElement =
      (HCLNT_CACHE_ELEM *) pSessCacheCtlDesc->pSessionCacheBuf + ElementIndex;
   //-------------------------------------------------------------------
   // Remove the Element from the ID array, ignore not found case
   //-------------------------------------------------------------------
   Retcode = RemoveCacheElementFromIdArray(pSessCacheCtlDesc,
      CLIENT_CACHE_TYPE,
      pCacheElement->SessionID);
   if(Retcode < 0)
      return(Retcode);
   //-------------------------------------------------------------------
   // Clear the cache element (Master secret, session ID)
   //-------------------------------------------------------------------
   memset(pCacheElement,0,sizeof(HCLNT_CACHE_ELEM));
   //-------------------------------------------------------------------
   // Mark element as no longer in use
   //-------------------------------------------------------------------
   StateMask = (uint32_t) 0x01 << (ElementIndex % 32); // get bit mask

   StateElement = pSessCacheCtlDesc->pUseStateBitsList[ElementIndex/32];
   StateElement = StateElement & (~StateMask);	     // clear in use bit
   pSessCacheCtlDesc->pUseStateBitsList[ElementIndex/32] = StateElement; // set new bits

   pSessCacheCtlDesc->SlotsInUseCount--;

   return(HSSL_OP_OK);
}

/**
* 'Frees' multiple expired server cache elements spcified by count and UTC
* sorted array. Uses a faster algorithm for removing from SessionID array (FreeMultiSrvrCacheElementsByUtcArr).
*
* -- SERVER SIDE --
*
*  @param pSessCacheCtlDesc Session control structure to be used
*  @param ExpiredCount Number of expired cache elements
*  @return 0 on success, error code otherwise
* <br>            > 0 special conditions:
*/
static int FreeMultiSrvrCacheElementsByUtcArr(
   HSESSCACHE_CTL_DESC * pSessCacheCtlDesc,
   uint32_t ExpiredCount)
{
   int Retcode,Mode;
   uint32_t StateElement,StateMask,ElementIndex;
   uint32_t HelperSize, IdArrayIndex;
   uint32_t IdUsedCount,UtcArrIndex, RemoveCount, LIndex, UIndex;
   uint32_t SrcIndex, DstIndex, SrcCount, BitIndex, MoveCount;

   uint32_t * pBitList, * pUtcIndexArr, * pIdIndexArr;

   HSERV_CACHE_ELEM * pCacheElement;

   if(pSessCacheCtlDesc == NULL)
      return(HSSL_NULL_PTR);
   //-------------------------------------------------------------------
   // Check if any / single element to free
   //-------------------------------------------------------------------
   if(ExpiredCount <= 1)
   {
      if(ExpiredCount == 0)
         return(HSSL_OP_OK);  

      Retcode = FreeSrvrCacheElementByUtcIndex(pSessCacheCtlDesc, 0);
      return(Retcode);
   }
   //-------------------------------------------------------------------
   // Multi free, clear helper bit array
   //-------------------------------------------------------------------
   IdUsedCount = pSessCacheCtlDesc->IdSlotsInUseCount;  

   pBitList = pSessCacheCtlDesc->pIdCompactBitList;

   HelperSize = (IdUsedCount + 31) / 32; // number of elements

   memset(pBitList,0,HelperSize*sizeof(uint32_t));

   pUtcIndexArr = pSessCacheCtlDesc->pUtcSortedIndexArr;

   RemoveCount = 0;
   LIndex = (uint32_t) 0xFFFFFFFF;			// set maximum
   UIndex = 0;					// set minimum
   //-------------------------------------------------------------------
   // 1. Get the Session ID Indices for the elements to remove, set bits
   //    Construct the remove bitarray, count, upper/lower indices
   //-------------------------------------------------------------------
   for(UtcArrIndex = 0; UtcArrIndex < ExpiredCount; UtcArrIndex++)
   {
      ElementIndex = pUtcIndexArr[UtcArrIndex];

      pCacheElement =
         (HSERV_CACHE_ELEM *) pSessCacheCtlDesc->pSessionCacheBuf + ElementIndex;

      IdArrayIndex = FindSessSrvrCacheEntryBySessionID(pSessCacheCtlDesc,
         pCacheElement->SessionID,
         NULL,NULL);
      if(IdArrayIndex != (uint32_t) -1)	// found the ID
      {
         StateMask = (uint32_t) 0x01 << (IdArrayIndex % 32);
         StateElement = pBitList[IdArrayIndex / 32];
         StateElement = StateElement | StateMask;	// set to remove bit
         pBitList[IdArrayIndex / 32] = StateElement;

         if(IdArrayIndex < LIndex)			// check for lower index change
            LIndex = IdArrayIndex;

         if(IdArrayIndex > UIndex)			// check for upper index change
            UIndex = IdArrayIndex;

         RemoveCount++;
      }
   } // UTC-Index FOR
   //-------------------------------------------------------------------
   // 2. Cleanup the Session Cache Elements (after search!)
   //-------------------------------------------------------------------
   for(UtcArrIndex = 0; UtcArrIndex < ExpiredCount; UtcArrIndex++)
   {
      ElementIndex = pUtcIndexArr[UtcArrIndex];

      pCacheElement =
         (HSERV_CACHE_ELEM *) pSessCacheCtlDesc->pSessionCacheBuf + ElementIndex;

      memset(pCacheElement,0,sizeof(HSERV_CACHE_ELEM));
      //-------------------------------------------------------------------
      // Mark element as no longer in use
      //-------------------------------------------------------------------
      StateMask = (uint32_t) 0x01 << (ElementIndex % 32); // get bit mask

      StateElement = pSessCacheCtlDesc->pUseStateBitsList[ElementIndex/32];
      StateElement = StateElement & (~StateMask);	     // clear in use bit
      pSessCacheCtlDesc->pUseStateBitsList[ElementIndex/32] = StateElement; // set new bits

      pSessCacheCtlDesc->SlotsInUseCount--;

   }
   //----------------------------------------------------------------
   // Check if any Elements were still present in the SessionID array
   //----------------------------------------------------------------
   if(RemoveCount == 0)
      return(1);					// say none found

   //----------------------------------------------------------
   // Compact the SessionID array now (using Bitruns)
   //----------------------------------------------------------
   Mode = 1;
   SrcCount = 0;					// number of elements for move
   SrcIndex = LIndex;				// start of source elements
   DstIndex = LIndex;				// destination of elements

   pIdIndexArr = pSessCacheCtlDesc->pIdSortedIndexArr;

   for(BitIndex = LIndex+1; BitIndex <= UIndex; BitIndex++)
   {
      StateMask    = (uint32_t) 0x01 << (BitIndex % 32); // get bit mask
      StateElement = pSessCacheCtlDesc->pIdCompactBitList[BitIndex/32];

      if(Mode != 0)				// Scan ONE bits mode active
      {
         SrcIndex++;				// advance source index anyway
         if((StateElement & StateMask) == 0)	// found a '0' bit
            Mode = 0;				// switch to other mode
      }
      else					// Scan ZERO bits mode active
      {
         SrcCount++;				// always count sources
         if((StateElement & StateMask) == 0)	// found another '0' bit
         {}
         else					// found a '1' bit
         {
            memmove(&pIdIndexArr[DstIndex],&pIdIndexArr[SrcIndex],
               SrcCount * sizeof(uint32_t));
            DstIndex += SrcCount;
            SrcIndex += SrcCount;
            SrcCount = 0;
            Mode = 1;
         }
      }
   } 
   if(UIndex < (IdUsedCount-1))			// elements left to shift
   {
      MoveCount = IdUsedCount - UIndex - 1;
      SrcIndex++;
      memmove(&pIdIndexArr[DstIndex],&pIdIndexArr[SrcIndex],
         MoveCount * sizeof(uint32_t));
   }

   pSessCacheCtlDesc->IdSlotsInUseCount -= RemoveCount;  
   return(HSSL_OP_OK);
}
/**
* 'Frees' multiple expired client cache elements spcified by count and UTC
* sorted array. Uses a faster algorithm for removing from SessionID array (FreeMultiClntCacheElementsByUtcArr).
*
* -- CLIENT SIDE --
*
*  @param pSessCacheCtlDesc Session control structure to be used
*  @param ExpiredCount Number of expired cache elements
*  @return 0 on success, error code otherwise
*/
static int FreeMultiClntCacheElementsByUtcArr(
   HSESSCACHE_CTL_DESC * pSessCacheCtlDesc,
   uint32_t ExpiredCount)
{
   int Retcode,Mode;
   uint32_t StateElement,StateMask,ElementIndex;
   uint32_t HelperSize, IdArrayIndex;
   uint32_t IdUsedCount,UtcArrIndex, RemoveCount, LIndex, UIndex;
   uint32_t SrcIndex, DstIndex, SrcCount, BitIndex, MoveCount;

   uint32_t * pBitList, * pUtcIndexArr, * pIdIndexArr;

   HCLNT_CACHE_ELEM * pCacheElement;

   if(pSessCacheCtlDesc == NULL)
      return(HSSL_NULL_PTR);
   //-------------------------------------------------------------------
   // Check if any / single element to free
   //-------------------------------------------------------------------
   if(ExpiredCount <= 1)
   {
      if(ExpiredCount == 0)
         return(HSSL_OP_OK);  

      Retcode = FreeClntCacheElementByUtcIndex(pSessCacheCtlDesc, 0);
      return(Retcode);
   }
   //-------------------------------------------------------------------
   // Multi free, clear helper bit array
   //-------------------------------------------------------------------
   IdUsedCount = pSessCacheCtlDesc->IdSlotsInUseCount;  

   pBitList = pSessCacheCtlDesc->pIdCompactBitList;

   HelperSize = (IdUsedCount + 31) / 32; // number of elements

   memset(pBitList,0,HelperSize*sizeof(uint32_t));

   pUtcIndexArr = pSessCacheCtlDesc->pUtcSortedIndexArr;

   RemoveCount = 0;
   LIndex = (uint32_t) 0xFFFFFFFF;			// set maximum
   UIndex = 0;					// set minimum
   //-------------------------------------------------------------------
   // 1. Get the Connection ID Indices for the elements to remove, set bits
   //    Construct the remove bitarray, count, upper/lower indices
   //-------------------------------------------------------------------
   for(UtcArrIndex = 0; UtcArrIndex < ExpiredCount; UtcArrIndex++)
   {
      ElementIndex = pUtcIndexArr[UtcArrIndex];

      pCacheElement =
         (HCLNT_CACHE_ELEM *) pSessCacheCtlDesc->pSessionCacheBuf + ElementIndex;

      IdArrayIndex = FindSessClntCacheEntryByConnectionID(pSessCacheCtlDesc,
         pCacheElement->ConnectionID,
         NULL,NULL);
      if(IdArrayIndex != (uint32_t) -1)	// found the ID
      {
         StateMask = (uint32_t) 0x01 << (IdArrayIndex % 32);
         StateElement = pBitList[IdArrayIndex / 32];
         StateElement = StateElement | StateMask;	// set to remove bit
         pBitList[IdArrayIndex / 32] = StateElement;

         if(IdArrayIndex < LIndex)			// check for lower index change
            LIndex = IdArrayIndex;

         if(IdArrayIndex > UIndex)			// check for upper index change
            UIndex = IdArrayIndex;

         RemoveCount++;
      }
   } // UTC-Index FOR
   //-------------------------------------------------------------------
   // 2. Cleanup the Session Cache Elements (after search!)
   //-------------------------------------------------------------------
   for(UtcArrIndex = 0; UtcArrIndex < ExpiredCount; UtcArrIndex++)
   {
      ElementIndex = pUtcIndexArr[UtcArrIndex];

      pCacheElement =
         (HCLNT_CACHE_ELEM *) pSessCacheCtlDesc->pSessionCacheBuf + ElementIndex;

      memset(pCacheElement,0,sizeof(HCLNT_CACHE_ELEM));
      //-------------------------------------------------------------------
      // Mark element as no longer in use
      //-------------------------------------------------------------------
      StateMask = (uint32_t) 0x01 << (ElementIndex % 32); // get bit mask

      StateElement = pSessCacheCtlDesc->pUseStateBitsList[ElementIndex/32];
      StateElement = StateElement & (~StateMask);	     // clear in use bit
      pSessCacheCtlDesc->pUseStateBitsList[ElementIndex/32] = StateElement; // set new bits

      pSessCacheCtlDesc->SlotsInUseCount--;

   }
   //----------------------------------------------------------------
   // Check if any Elements were still present in the SessionID array
   //----------------------------------------------------------------
   if(RemoveCount == 0)
      return(1);					// say none found

   //----------------------------------------------------------
   // Compact the SessionID array now (using Bitruns)
   //----------------------------------------------------------
   Mode = 1;
   SrcCount = 0;					// number of elements for move
   SrcIndex = LIndex;				// start of source elements
   DstIndex = LIndex;				// destination of elements

   pIdIndexArr = pSessCacheCtlDesc->pIdSortedIndexArr;

   for(BitIndex = LIndex+1; BitIndex <= UIndex; BitIndex++)
   {
      StateMask    = (uint32_t) 0x01 << (BitIndex % 32); // get bit mask
      StateElement = pSessCacheCtlDesc->pIdCompactBitList[BitIndex/32];

      if(Mode != 0)				// Scan ONE bits mode active
      {
         SrcIndex++;				// advance source index anyway
         if((StateElement & StateMask) == 0)	// found a '0' bit
            Mode = 0;				// switch to other mode
      }
      else					// Scan ZERO bits mode active
      {
         SrcCount++;				// always count sources
         if((StateElement & StateMask) == 0)	// found another '0' bit
         {}
         else					// found a '1' bit
         {
            memmove(&pIdIndexArr[DstIndex],&pIdIndexArr[SrcIndex],
               SrcCount * sizeof(uint32_t));
            DstIndex += SrcCount;
            SrcIndex += SrcCount;
            SrcCount = 0;
            Mode = 1;
         }
      }
   } 
   if(UIndex < (IdUsedCount-1))			// elements left to shift
   {
      MoveCount = IdUsedCount - UIndex - 1;
      SrcIndex++;
      memmove(&pIdIndexArr[DstIndex],&pIdIndexArr[SrcIndex],
         MoveCount * sizeof(uint32_t));
   }

   pSessCacheCtlDesc->IdSlotsInUseCount -= RemoveCount;  
   return(HSSL_OP_OK);
}

/**
* Performs server session cache aging (AgeSessionSrvrCache).
*<ul>
* <li> Check if there are elements in UTC sorted array.
* <li> Find outdated elements, if any.
* <li> Remove the elements from the UTC Index array, SessionID array
*   and mark elements as unused. Clear master secret in those elements.
*</ul>
* -- SERVER SIDE --
*
*  @param pSessCacheCtlDesc Session control structure to be aged
*  @return 0 on success, error code otherwise
*/
extern "C" int AgeSessionSrvrCache(HSESSCACHE_CTL_DESC * pSessCacheCtlDesc)
{
   int Retcode;

   uint32_t ExpiredCount;
   uint32_t UtcArrIndex,UtcUsedCount,UtcMsw,UtcLsw, BelowIndex,AboveIndex;
   uint32_t * pUtcIndexArr;

   if(pSessCacheCtlDesc == NULL)
      return(HSSL_NULL_PTR);
   //------------------------------------------------------------
   // Check if there are elements in the UTC sorted index array
   //------------------------------------------------------------
   UtcUsedCount = pSessCacheCtlDesc->UtcSlotsInUseCount;
   pUtcIndexArr = pSessCacheCtlDesc->pUtcSortedIndexArr;

   if(UtcUsedCount == 0)				// non stored in array
      return(HSSL_OP_OK);

   //--------------------------------------------------------------
   // generate current UTC, set LSW to maximum, find 'insert point'
   //--------------------------------------------------------------
   UtcMsw = (uint32_t) time(NULL);		// get actual UTC
   UtcLsw = (uint32_t) 0xFFFFFFFF;		// set maximum

   UtcArrIndex = FindSessSrvrCacheEntryByUtc(pSessCacheCtlDesc,
      UtcMsw,UtcLsw,
      &BelowIndex,&AboveIndex);
   if(UtcArrIndex == (uint32_t) -1)	// ''not found''
   {
      //-----------------------------------------------------------
      // No direct match found, check Below/Above Indices
      //-----------------------------------------------------------
      if(BelowIndex == (uint32_t) -1)	// current UTC below all
         return(HSSL_OP_OK);		// no elements expired

      else if(AboveIndex == (uint32_t) -1)  // all elements expired
      {
         Retcode = FreeMultiSrvrCacheElementsByUtcArr(pSessCacheCtlDesc,
            UtcUsedCount);
         if(Retcode < 0)
            return(Retcode);

         pSessCacheCtlDesc->UtcSlotsInUseCount = 0; // set none used
         return(HSSL_OP_OK);
      }
      else				// some elements expired
      {
         ExpiredCount = BelowIndex+1;	// number of elements expired

         Retcode = FreeMultiSrvrCacheElementsByUtcArr(pSessCacheCtlDesc,
            ExpiredCount);
         if(Retcode < 0)
            return(Retcode);

         UtcUsedCount -= ExpiredCount;

         // shift down stilll used elements
         if(UtcUsedCount != 0)
            memmove(&pUtcIndexArr[0],&pUtcIndexArr[BelowIndex+1],
            UtcUsedCount*sizeof(uint32_t));

         pSessCacheCtlDesc->UtcSlotsInUseCount = UtcUsedCount; // reduce in use
         return(HSSL_OP_OK);
      }
   }
   else
   {
      //-----------------------------------------------------------
      // Had a 'find' match (really very very rare...)
      //-----------------------------------------------------------
      ExpiredCount = UtcArrIndex+1;	// number expired

      Retcode = FreeMultiSrvrCacheElementsByUtcArr(pSessCacheCtlDesc,
         ExpiredCount);
      if(Retcode < 0)
         return(Retcode);

      UtcUsedCount -= ExpiredCount;	// calculate remaining elements

      if(UtcUsedCount != 0)
         memmove(&pUtcIndexArr[0],&pUtcIndexArr[UtcArrIndex+1],
         UtcUsedCount*sizeof(uint32_t));

      pSessCacheCtlDesc->UtcSlotsInUseCount = UtcUsedCount; // reduce in use
      return(HSSL_OP_OK);
   }
}
/**
* Perform client session cache aging (AgeSessionClntCache).
*<ul>
* <li> Check if there are elements in UTC sorted array.
* <li> Find outdated elements, if any.
* <li> Remove the elements from the UTC Index array, ConnectionID array
*   and mark elements as unused. Clear Master secret in those elements.
*</ul>
* -- CLIENT SIDE --
*
*  @param pSessCacheCtlDesc Session control structure to be used
*  @return 0 on success, error code otherwise
*/
extern "C" int AgeSessionClntCache(HSESSCACHE_CTL_DESC * pSessCacheCtlDesc)
{
   int Retcode;

   uint32_t ExpiredCount;
   uint32_t UtcArrIndex,UtcUsedCount,UtcMsw,UtcLsw, BelowIndex,AboveIndex;
   uint32_t * pUtcIndexArr;

   if(pSessCacheCtlDesc == NULL)
      return(HSSL_NULL_PTR);
   //------------------------------------------------------------
   // Check if there are elements in the UTC sorted index array
   //------------------------------------------------------------
   UtcUsedCount = pSessCacheCtlDesc->UtcSlotsInUseCount;
   pUtcIndexArr = pSessCacheCtlDesc->pUtcSortedIndexArr;

   if(UtcUsedCount == 0)				// non stored in array
      return(HSSL_OP_OK);

   //--------------------------------------------------------------
   // generate current UTC, set LSW to maximum, find 'insert point'
   //--------------------------------------------------------------
   UtcMsw = (uint32_t) time(NULL);		// get actual UTC
   UtcLsw = (uint32_t) 0xFFFFFFFF;		// set maximum

   UtcArrIndex = FindSessClntCacheEntryByUtc(pSessCacheCtlDesc,
      UtcMsw,UtcLsw,
      &BelowIndex,&AboveIndex);
   if(UtcArrIndex == (uint32_t) -1)	// ''not found''
   {
      //-----------------------------------------------------------
      // No direct match found, check Below/Above Indices
      //-----------------------------------------------------------
      if(BelowIndex == (uint32_t) -1)	// current UTC below all
         return(HSSL_OP_OK);		// no elements expired

      else if(AboveIndex == (uint32_t) -1)  // all elements expired
      {
         Retcode = FreeMultiClntCacheElementsByUtcArr(pSessCacheCtlDesc,
            UtcUsedCount);
         if(Retcode < 0)
            return(Retcode);

         pSessCacheCtlDesc->UtcSlotsInUseCount = 0; // set none used
         return(HSSL_OP_OK);
      }
      else				// some elements expired
      {
         ExpiredCount = BelowIndex+1;	// number of elements expired

         Retcode = FreeMultiClntCacheElementsByUtcArr(pSessCacheCtlDesc,
            ExpiredCount);
         if(Retcode < 0)
            return(Retcode);

         UtcUsedCount -= ExpiredCount;

         // shift down stilll used elements
         if(UtcUsedCount != 0)
            memmove(&pUtcIndexArr[0],&pUtcIndexArr[BelowIndex+1],
            UtcUsedCount*sizeof(uint32_t));

         pSessCacheCtlDesc->UtcSlotsInUseCount = UtcUsedCount; // reduce in use
         return(HSSL_OP_OK);
      }
   }
   else
   {
      //-----------------------------------------------------------
      // Had a 'find' match (really very very rare...)
      //-----------------------------------------------------------
      ExpiredCount = UtcArrIndex+1;	// number expired

      Retcode = FreeMultiClntCacheElementsByUtcArr(pSessCacheCtlDesc,
         ExpiredCount);
      if(Retcode < 0)
         return(Retcode);

      UtcUsedCount -= ExpiredCount;	// calculate remaining elements

      if(UtcUsedCount != 0)
         memmove(&pUtcIndexArr[0],&pUtcIndexArr[UtcArrIndex+1],
         UtcUsedCount*sizeof(uint32_t));

      pSessCacheCtlDesc->UtcSlotsInUseCount = UtcUsedCount; // reduce in use
      return(HSSL_OP_OK);
   }
}

/**
* 'Frees' a cache element referenced by Session ID (FreeSrvrCacheElementBySessionID).
*
* -- SERVER SIDE --
*<ul>
* <li> Remove element from Session ID array.
* <li> Remove element from UTC array.
* <li> Clear element master secret.
* <li> Mark element as not used.
* <li> Reduce slots in use count.
*</ul>
*  @param pSessCacheCtlDesc Session control structure to be used
*  @param pSessionID Session ID to be freed
*
*  @return 0 on success, error code otherwise
* <br>            > 0 special conditions:
* <br>            1 - element not found
*/
extern "C" int FreeSrvrCacheElementBySessionID(
   HSESSCACHE_CTL_DESC * pSessCacheCtlDesc,
   char* pSessionID)
{
   int Retcode;
   uint32_t StateElement,StateMask,IdArrayIndex,ElementIndex, MoveCount;

   uint32_t * pIdIndexArr;

   HSERV_CACHE_ELEM * pCacheElement;

   if((pSessCacheCtlDesc == NULL) || (pSessionID == NULL))
      return(HSSL_NULL_PTR);

   if(pSessionID[0] == 0)			// check valid ID
      return(HSSL_PARAM_ERR);

   //-------------------------------------------------------------------
   // Search the SessionID array for SessionID
   //-------------------------------------------------------------------
   IdArrayIndex = FindSessSrvrCacheEntryBySessionID(pSessCacheCtlDesc,
      pSessionID,
      NULL,NULL);
   if(IdArrayIndex == (uint32_t) -1)	// ID not found
      return(1);

   //-------------------------------------------------------------------
   // Found cache element for SessionID, remove from SessionID-Array
   //-------------------------------------------------------------------
   ElementIndex = pSessCacheCtlDesc->pIdSortedIndexArr[IdArrayIndex];
   pCacheElement =
      (HSERV_CACHE_ELEM *) pSessCacheCtlDesc->pSessionCacheBuf + ElementIndex;

   MoveCount = pSessCacheCtlDesc->IdSlotsInUseCount - IdArrayIndex - 1;
   if(MoveCount != 0)
   {
      pIdIndexArr = pSessCacheCtlDesc->pIdSortedIndexArr;

      memmove(&pIdIndexArr[IdArrayIndex],&pIdIndexArr[IdArrayIndex+1],
         MoveCount * sizeof(uint32_t));
   }
   pSessCacheCtlDesc->IdSlotsInUseCount--;		// reduce used count
   //-------------------------------------------------------------------
   // Check if reference count is 0
   //-------------------------------------------------------------------
   if(pCacheElement->ReferenceCount == 0)
   {
      //----------------------------------------------------
      // Is propably on UTC array, remove from the UTC array
      //----------------------------------------------------
      Retcode = RemoveCacheElementFromUtcArray(pSessCacheCtlDesc,
         SERVER_CACHE_TYPE,
         pCacheElement->ExpireUtcMsw,
         pCacheElement->ExpireUtcLsw);
      if(Retcode < 0)
         return(Retcode);
   }

   //----------------------------------------------------
   // Release the current cache element now
   //----------------------------------------------------

   memset(pCacheElement,0,sizeof(HSERV_CACHE_ELEM));
   //-------------------------------------------------------------------
   // Mark element as no longer in use
   //-------------------------------------------------------------------
   StateMask = (uint32_t) 0x01 << (ElementIndex % 32); // get bit mask

   StateElement = pSessCacheCtlDesc->pUseStateBitsList[ElementIndex/32];
   StateElement = StateElement & (~StateMask);	     // clear in use bit
   pSessCacheCtlDesc->pUseStateBitsList[ElementIndex/32] = StateElement; // set new bits

   pSessCacheCtlDesc->SlotsInUseCount--;

   return(HSSL_OP_OK);
}

/**
* Checks, if system clock has been set back before last UTC (CheckUtcBackset).
* Needed to guarantee correct operation of cache aging.
* If UTC was set back, invalidate all cache entries.
*
* -- SERVER/CLIENT SIDE --
*
*  @param pSessCacheCtlDesc Session control structure to be used
*  @param CacheType 0-Server, else Client cache
*
*  @return 0 on success, error code otherwise, no change to cache
* <br>            > 0 Cache flushed
*/
extern "C" int CheckUtcBackset(HSESSCACHE_CTL_DESC * pSessCacheCtlDesc,
                               int CacheType)
{
   uint32_t ActUtc;

   if(pSessCacheCtlDesc == NULL)
      return(HSSL_NULL_PTR);

   //---------------------------------------------------------------
   // Get Current UTC, check against last access UTC
   //---------------------------------------------------------------
   ActUtc = (uint32_t) time(NULL);

   if(pSessCacheCtlDesc->LastAccessUtc > ActUtc)
   {
      FlushSessionCache(pSessCacheCtlDesc, CacheType);
      pSessCacheCtlDesc->LastAccessUtc = ActUtc;
      return(1);
   }

   pSessCacheCtlDesc->LastAccessUtc = ActUtc;
   return(HSSL_OP_OK);
}

/**
* Finds a server cache element (ServerVerifyGetSessionParamsBySessionID).
* The session ID and some parameters to check are 
* contained in pElementTemplate. Cached parameters and the master secret is
* written to that struct.
*
* -- SERVER SIDE --
*
* NOTE: If element found, reference count is NOT modified.
* This will be done when session has been successfully
*	 (re-)established.
*
*  @param pSessCacheCtlDesc Session control structure to be used
*  @param pElementTemplate Element to be filled.
*  @param pCipherSuitesList Client supported ciphers list
*  @param pComprMethodsList Client supported compressions list
*
*  @return 0 on success, error code otherwise
* <br>            > 0 special conditions:
* <br>            1 - element not found, use
* <br>            2 - session parameters mismatch
*/
extern "C" int ServerVerifyGetSessionParamsBySessionID(
   HSESSCACHE_CTL_DESC * pSessCacheCtlDesc,
   HSERV_CACHE_ELEM * pElementTemplate,
   char* pCipherSuitesList,
   char* pComprMethodsList)
{
   int Index,Len;
   char Protocol;
   char ComprMethod;
   short CipherSuite;
   uint32_t IdArrayIndex,ElementIndex;

   HSERV_CACHE_ELEM * pCacheElement;
   //--------------------------------------------------------------------
   // Check, validate parameters
   //--------------------------------------------------------------------
   if((pSessCacheCtlDesc == NULL) || (pElementTemplate == NULL) ||
      (pCipherSuitesList == NULL) || (pComprMethodsList == NULL))
      return(HSSL_NULL_PTR);

   if(pElementTemplate->SessionID[0] == 0)		// check valid ID
      return(HSSL_PARAM_ERR);
   //-------------------------------------------------------------------
   // Search the SessionID array for SessionID
   //-------------------------------------------------------------------
   IdArrayIndex = FindSessSrvrCacheEntryBySessionID(pSessCacheCtlDesc,
      pElementTemplate->SessionID,
      NULL,NULL);
   if(IdArrayIndex == (uint32_t) -1)	// ID not found
      return(1);

   //===================================================================
   // Found cache element for SessionID, compare session parameters
   // 1. Protocol Version from client must be higher/same as cached
   // 2. Cached cipher suite must be contained in client list
   // 3. Cached compr. method must be contained in client list 
   //===================================================================
   ElementIndex = pSessCacheCtlDesc->pIdSortedIndexArr[IdArrayIndex];
   pCacheElement =
      (HSERV_CACHE_ELEM *) pSessCacheCtlDesc->pSessionCacheBuf + ElementIndex;
   //-------------------------------------------------------------------
   // 1. Compare protocol from cache to client given (in internal format)
   //-------------------------------------------------------------------
   Protocol = pElementTemplate->SelectedProtocol;

   if(Protocol < pCacheElement->SelectedProtocol) // will not fit
      return(2);					 // use new session
   //-------------------------------------------------------------------
   // 2. Scan client ciphersuite list for cached ciphersuite
   //-------------------------------------------------------------------
   CipherSuite = 0;
   Len   = (((int) pCipherSuitesList[0] << 8) & 0x0FF) |
      ((int) pCipherSuitesList[1] & 0x0FF);
   Index = 2;
   Len += 2;				// add size of length field
   while(Index < Len)
   {
      CipherSuite = (short)
         ((((int) pCipherSuitesList[Index]  & 0x0FF) << 8) |
         ((int) pCipherSuitesList[Index+1]  & 0x0FF));
      Index += 2;
      if(pCacheElement->SelectedCipherSuite == CipherSuite)
         break;
   }
   if(pCacheElement->SelectedCipherSuite != CipherSuite)	// not in list
      return(2);					 // use new session
   //--------------------------------------------------------------------
   // 3. Scan client compressionmethods list for cached compressionmethod
   //--------------------------------------------------------------------
   ComprMethod = 0;
   Index = 0;
   Len = pComprMethodsList[Index++];		// get list length
   if(Len == 0)					// is possible (->no compr.)
   {
      if(pCacheElement->SelectedComprMethod != COMPR_NULL)
         return(2);				 // use new session
   }
   else						// have a list
   {
      Len++;					// add size of length field
      while(Index < Len)
      {
         ComprMethod = pComprMethodsList[Index]; 
         if(ComprMethod == pCacheElement->SelectedComprMethod)
            break;
         Index++;
      }
      if(ComprMethod != pCacheElement->SelectedComprMethod) // not in list
         return(2);				 // use new session
   }
   //-----------------------------------------------------------------
   // Copy saved parameters back to caller's template structure
   //-----------------------------------------------------------------
   pElementTemplate->SelectedProtocol    = pCacheElement->SelectedProtocol;
   pElementTemplate->SelectedCipherSuite = pCacheElement->SelectedCipherSuite;
   pElementTemplate->SelectedComprMethod = pCacheElement->SelectedComprMethod;

   pElementTemplate->CertifiedFlags      = pCacheElement->CertifiedFlags;
   pElementTemplate->ReferenceCount      = pCacheElement->ReferenceCount;
   pElementTemplate->ExpireUtcMsw        = 0;
   pElementTemplate->ExpireUtcLsw        = 0;

   memcpy(pElementTemplate->MasterSecret,pCacheElement->MasterSecret,
      MASTER_SECRET_LEN);

   memcpy(pElementTemplate->PartnerCertHash,pCacheElement->PartnerCertHash,
      SHA_DIGEST_LEN);

   return(HSSL_OP_OK);
}

/**
* Finds a client cache element (ClientGetSessionParamsByConnectionID).
* The connection ID and some parameters to check
* are contained in pElementTemplate. Cached parameters and the master secret is
* written to that struct.
*
* -- CLIENT SIDE --
*
* NOTE: If element found and good, reference count is modified,
*   when reference count was 0, remove from UTC list
*
*  @param pSessCacheCtlDesc Session control structure to be used
*  @param pElementTemplate Element to be filled
*  @param pCipherSuitesList Client supported ciphers list
*  @param pComprMethodsList Client supported compressions list
*  @return int Status - < 0 error occured
* <br>            >= 0 'Cache state' to use
* <br>            0 - no element, use new
* <br>            1 - element found, but use new
* <br>            2 - element found, resume mode
* <br>            3 - element found, clone mode
*/
extern "C" int ClientGetSessionParamsByConnectionID(
   HSESSCACHE_CTL_DESC * pSessCacheCtlDesc,
   HCLNT_CACHE_ELEM * pElementTemplate,
   char* pCipherSuitesList,
   char* pComprMethodsList)
{
   int Retcode;
   int Index,Len;
   char Protocol;
   char ComprMethod;
   short CipherSuite;
   uint32_t IdArrayIndex,ElementIndex;

   HCLNT_CACHE_ELEM * pCacheElement;
   //--------------------------------------------------------------------
   // Check, validate parameters
   //--------------------------------------------------------------------
   if((pSessCacheCtlDesc == NULL) || (pElementTemplate == NULL) ||
      (pCipherSuitesList == NULL) || (pComprMethodsList == NULL))
      return(HSSL_NULL_PTR);
   if(pElementTemplate->ConnectionID[1] == 0)		// check valid ID
      return(HSSL_PARAM_ERR);
   //-------------------------------------------------------------------
   // Search the ID array for ConnectionID
   //-------------------------------------------------------------------
   IdArrayIndex = FindSessClntCacheEntryByConnectionID(pSessCacheCtlDesc,
      pElementTemplate->ConnectionID,
      NULL,NULL);
   if(IdArrayIndex == (uint32_t) -1)	// ID not found
      return(0);
   //===================================================================
   // Found cache element for ConnectionID, compare session parameters
   // 1. Protocol Version from client must be higher/same as cached
   // 2. Cached cipher suite must be contained in client list
   // 3. Cached compr. method must be contained in client list 
   //===================================================================
   ElementIndex = pSessCacheCtlDesc->pIdSortedIndexArr[IdArrayIndex];
   pCacheElement =
      (HCLNT_CACHE_ELEM *) pSessCacheCtlDesc->pSessionCacheBuf + ElementIndex;

   //--------------------------------------------------------------------
   // 1. Compare protocol from cache to client given (in internal format)
   //--------------------------------------------------------------------
   Protocol = pElementTemplate->SelectedProtocol;

   if(Protocol < pCacheElement->SelectedProtocol) // will not fit
      return(1);					 // use new session
   //-------------------------------------------------------------------
   // 2. Scan client ciphersuite list for cached ciphersuite
   //-------------------------------------------------------------------
   CipherSuite = 0;
   Len   = (((int) pCipherSuitesList[0] << 8) & 0x0FF) |
      ((int) pCipherSuitesList[1] & 0x0FF);
   Index = 2;
   Len += 2;				// add size of length field
   while(Index < Len)
   {
      CipherSuite = (short)
         ((((int) pCipherSuitesList[Index]  & 0x0FF) << 8) |
         ((int) pCipherSuitesList[Index+1]  & 0x0FF));
      Index += 2;

      if(pCacheElement->SelectedCipherSuite == CipherSuite)
         break;
   }
   if(pCacheElement->SelectedCipherSuite != CipherSuite)	// not in list
      return(1);					 // use new session
   //--------------------------------------------------------------------
   // 3. Scan client compressionmethods list for cached compressionmethod
   //--------------------------------------------------------------------
   ComprMethod = 0;
   Index = 0;
   Len = pComprMethodsList[Index++];		// get list length
   if(Len == 0)					// is possible (->no compr.)
   {
      if(pCacheElement->SelectedComprMethod != COMPR_NULL)
         return(1);				 // use new session
   }
   else						// have a list
   {
      Len++;					// add size of length field
      while(Index < Len)
      {
         ComprMethod = pComprMethodsList[Index]; 
         if(ComprMethod == pCacheElement->SelectedComprMethod)
            break;
         Index++;
      }
      if(ComprMethod != pCacheElement->SelectedComprMethod) // not in list
         return(1);				 // use new session
   }
   //---------------------------------------------------------------------
   // Found matching element for ConnectionID, copy parameters to template
   //---------------------------------------------------------------------

   memcpy(pElementTemplate,pCacheElement,sizeof(HCLNT_CACHE_ELEM));
   //-----------------------------------------------------------------
   // Check if resumed or cloned session mode
   //-----------------------------------------------------------------
   if(pCacheElement->ReferenceCount == 0)	// resume mode
   {
      //----------------------------------------------------
      // Is propably on UTC array, remove from the UTC array
      //----------------------------------------------------
      Retcode = RemoveCacheElementFromUtcArray(pSessCacheCtlDesc,
         CLIENT_CACHE_TYPE,
         pCacheElement->ExpireUtcMsw,
         pCacheElement->ExpireUtcLsw);
      if(Retcode < 0)
         return(Retcode);
      pCacheElement->ReferenceCount = 1;
      return(2);					// resume mode
   }
   //------------------------------------------------------------------
   // Clone mode, check clone inhibit flag
   //------------------------------------------------------------------
   if((pCacheElement->Flags & CLNT_CACHE_FLG_CLONE_INHIBIT) != 0)
      return(1);
   return(3);					// clone mode
}

//()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()
//
// Server/Client Side Session Establishment/Closing helper functions
//
//()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()

/**
* CMA Descriptor locking/init helper routine.
*
* -- SERVER/CLIENT --
*
* - fetches the Cache descriptor structure/creates and initializes it
*   if not yet available.
* - runs UTC backward set check
* - performs Cache elements aging
* 
*

*  @param CacheType 0-Server, else Client cache
*  @param ppSessCacheCtlDesc
* 
*  @return 0 on success, error code otherwise

*/
//LockedGetSessCacheCtlDesc
static int LockedGetSessCacheCtlDesc(HMEM_CTX_DEF
                                     int CacheType,
                                     HSESSCACHE_CTL_DESC ** ppSessCacheCtlDesc)
{
   int Retcode;
   int CacheMaxEntriesCount;
   int CacheElementTimeToLive;
   //------------------------------------------------------------------
   // Get Control structure from CMA
   //------------------------------------------------------------------
   Retcode = GetAndLockSessCacheCtlDesc(HMEM_CTX_REF,
      CacheType,
      ppSessCacheCtlDesc);
   if(Retcode < 0)			// had en error
      return(Retcode);
   //------------------------------------------------------------------
   // Check if parameter initialization is needed (after new create)
   //------------------------------------------------------------------
   else if(Retcode > 0)
   {
      if(CacheType == SERVER_CACHE_TYPE)		// Server Cache
      {
         if(ServerCacheInitDataSet == 0)
         {
            UnlockSessCacheCtlDesc(*ppSessCacheCtlDesc); // release lock
            return(HS_SRVR_CACHE_NOTINITIALIZED);
         }
         CacheMaxEntriesCount   = ServerCacheMaxEntriesCount;
         CacheElementTimeToLive = ServerCacheElementTimeToLive;
      }
      else					// Client Cache
      {
         if(ClientCacheInitDataSet == 0)
         {
            UnlockSessCacheCtlDesc(*ppSessCacheCtlDesc); // release lock
            return(HS_CLNT_CACHE_NOTINITIALIZED);
         }
         CacheMaxEntriesCount   = ClientCacheMaxEntriesCount;
         CacheElementTimeToLive = ClientCacheElementTimeToLive;
      }

      Retcode = BaseInitCacheCtrlStruct(*ppSessCacheCtlDesc,
         CacheType,
         CacheMaxEntriesCount,
         CacheElementTimeToLive);
      if(Retcode != 0)
      {
         UnlockSessCacheCtlDesc(*ppSessCacheCtlDesc); // release lock
         return(Retcode);
      }
   }
   //-----------------------------------------------------------------
   // Check for UTC backward set condition
   //-----------------------------------------------------------------
   if((Retcode = CheckUtcBackset(*ppSessCacheCtlDesc,CacheType)) != 0)
   {
      if(Retcode < 0)				// had an error
      {
         UnlockSessCacheCtlDesc(*ppSessCacheCtlDesc); // release lock
         return(Retcode);
      }
      else					// cache has been flushed!
         return(HSSL_OP_OK);
   }
   //-----------------------------------------------------------------
   // Age the Cache
   //-----------------------------------------------------------------
   if(CacheType == SERVER_CACHE_TYPE)
      Retcode = AgeSessionSrvrCache(*ppSessCacheCtlDesc);
   else
      Retcode = AgeSessionClntCache(*ppSessCacheCtlDesc);

   if(Retcode != 0)
      UnlockSessCacheCtlDesc(*ppSessCacheCtlDesc); // release lock

   return(Retcode);
}

/**
* Sets cache initial parameters. Must be called once for server/client (SetSessionCacheInitParams).
*
* -- SERVER/CLIENT SIDE --
*
*  @param CacheType 0 - server, else client
*  @param CacheMaxEntriesCount Must be != 0
*  @param CacheElementTimeToLive Lifetime of this element in seconds
* 
*  @return 0 on success, error code otherwise
*/
extern "C" int SetSessionCacheInitParams(int CacheType,
                                         uint32_t CacheMaxEntriesCount,
                                         uint32_t CacheElementTimeToLive)
{
   if(CacheType == SERVER_CACHE_TYPE)		// server cache
   {
      if(ServerCacheInitDataSet != 0)		// already initialized
         return(HSSL_OP_OK);

      CacheMaxEntriesCount = SRVR_SESS_CACHE_DEFAULT_MAX_ELEMENT_COUNT;

      if(CacheElementTimeToLive != 0)
      {
         if(CacheElementTimeToLive < SRVR_SESS_CACHE_MIN_TIME_TO_LIVE)
            CacheElementTimeToLive = SRVR_SESS_CACHE_MIN_TIME_TO_LIVE;
      }
      else
         CacheElementTimeToLive = SRVR_SESS_CACHE_DEFAULT_DELTA_EXPIRE_TIME;

      ServerCacheMaxEntriesCount   = CacheMaxEntriesCount;
      ServerCacheElementTimeToLive = CacheElementTimeToLive;
      ServerCacheCmaSize = sizeof(HSESSCACHE_CTL_DESC) +
         2 * CacheMaxEntriesCount * sizeof(uint32_t) +
         2 * (CacheMaxEntriesCount + 31)/32 * sizeof(uint32_t) +
         CacheMaxEntriesCount * sizeof(HSERV_CACHE_ELEM);

      ServerCacheInitDataSet       = 1;
      return(HSSL_OP_OK);
   }
   else
   {
      if(ClientCacheInitDataSet != 0)		// already initialized
         return(HSSL_OP_OK);

      CacheMaxEntriesCount = CLNT_SESS_CACHE_DEFAULT_MAX_ELEMENT_COUNT;

      if(CacheElementTimeToLive != 0)
      {
         if(CacheElementTimeToLive < CLNT_SESS_CACHE_MIN_TIME_TO_LIVE)
            CacheElementTimeToLive = CLNT_SESS_CACHE_MIN_TIME_TO_LIVE;
      }
      else
         CacheElementTimeToLive = CLNT_SESS_CACHE_DEFAULT_DELTA_EXPIRE_TIME;

      ClientCacheMaxEntriesCount   = CacheMaxEntriesCount;
      ClientCacheElementTimeToLive = CacheElementTimeToLive;
      ClientCacheCmaSize = sizeof(HSESSCACHE_CTL_DESC) +
         2 * CacheMaxEntriesCount * sizeof(uint32_t) +
         2 * (CacheMaxEntriesCount + 31)/32 * sizeof(uint32_t) +
         CacheMaxEntriesCount * sizeof(HCLNT_CACHE_ELEM);

      ClientCacheInitDataSet       = 1;
      return(HSSL_OP_OK);
   }
}
//()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()
//
// Server Side Session Establishment/Closing functions
//
//()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()

/**
* Creates,resumes or clones a session (ServerCacheSessionCreate).
*
* The necessary session ID for resuming and clonig is provided in the template
* element.
*
* -- SERVER SIDE --
*
* Note: A random Session ID has to be supplied, size at least 8 bytes
*  that will be used when either a new session is created or session
*	 cannot be cloned/resumed. This session ID (modified) will be given
*	 back in the template structure.
* 
*
*  @param pElementTemplate Template for the requested session element
*  @param pNewSessionID Random session ID to use
*  @param CreateMode == 1 create a new session
*               == 2 resume session
*               == 3 clone session
*  @param pCipherSuitesList client supported cipher list / NULL
*  @param pComprMethodsList client supported compression list / NULL
* 
*  @return < 0 error occured
* <br>            == 0 - not resumable, use new session instead
* <br>            == 1 - new session 
* <br>            == 2 - resumed session
* <br>            == 3 - cloned session
*/
extern "C" int ServerCacheSessionCreate(HMEM_CTX_DEF
                                        HSERV_CACHE_ELEM * pElementTemplate,
                                        char* pNewSessionID,
                                        int CreateMode,
                                        char* pCipherSuitesList,
                                        char* pComprMethodsList)
{
   int Retcode;
   HSESSCACHE_CTL_DESC * pSessCacheCtlDesc;

   //------------------------------------------------------------
   // Check parameters first
   //------------------------------------------------------------
   if((pElementTemplate == NULL) || (pNewSessionID == NULL))
      return(HSSL_NULL_PTR);

   if(pNewSessionID[0] < 8)
      return(HSSL_PARAM_ERR);

   if((CreateMode != CACHE_SESSION_CREATE_NEW) &&
      (pElementTemplate->SessionID[0] == 0))
      return(HSSL_PARAM_ERR);
   //-----------------------------------------------------------------
   // Get the Cache control structure from CMA, locked and initialized
   //-----------------------------------------------------------------
   if((Retcode = LockedGetSessCacheCtlDesc(HMEM_CTX_REF,
      SERVER_CACHE_TYPE,
      &pSessCacheCtlDesc)) != 0)
      return(Retcode);
   //----------------------------------------------------------------
   // Check if create mode is new or resume/clone
   //----------------------------------------------------------------
   if(CreateMode == CACHE_SESSION_CREATE_NEW)
   {
      //--------------------------------------------------------------
      // New session shall be created, generate Unique ID
      //--------------------------------------------------------------
      memcpy(&pElementTemplate->SessionID,pNewSessionID,pNewSessionID[0]+1);

      Retcode = ServerGenUniqueSessionID(pSessCacheCtlDesc,
         pElementTemplate->SessionID);
      UnlockSessCacheCtlDesc(pSessCacheCtlDesc); // release lock
      if(Retcode == HSSL_OP_OK)
         Retcode = CACHE_SESSION_TYPE_NEW;
      return(Retcode);
   }
   //----------------------------------------------------------------
   // Session Resume/Clone is requested, find session ID
   //----------------------------------------------------------------
   Retcode = ServerVerifyGetSessionParamsBySessionID(pSessCacheCtlDesc,
      pElementTemplate,
      pCipherSuitesList,
      pComprMethodsList);
   if(Retcode <= 0)		// error or found...
   {
      UnlockSessCacheCtlDesc(pSessCacheCtlDesc); // release lock
      if(Retcode < 0)
         return(Retcode);

      if(pElementTemplate->ReferenceCount == 0)	// is a resumed
         return(CACHE_SESSION_TYPE_RESUMED);
      else
         return(CACHE_SESSION_TYPE_CLONED);
   }
   //----------------------------------------------------------------
   // Session ID for resume/clone not found, generate new one
   //----------------------------------------------------------------
   memcpy(&pElementTemplate->SessionID,pNewSessionID,pNewSessionID[0]+1);

   Retcode = ServerGenUniqueSessionID(pSessCacheCtlDesc,
      pElementTemplate->SessionID);
   UnlockSessCacheCtlDesc(pSessCacheCtlDesc); // release lock
   return(Retcode);				// 0 or negative, when error
}

/**
* Releases a resumed session from the cache, if it is in cache (ServerCacheSessionAbort).
* First, the cache is seached for the specified session ID. If it is found
* and the mode is specified as 'resumed session', it is removed from the cache
* and the cache element is released to the free pool.
*
* -- SERVER SIDE  --
* 
*
*  @param pSessionID Session ID to act on
*  @param CacheMode 0 - not cachable
*               1 - new session
*               2 - resumed session
*               3 - cloned session
* 
*  @return 0 on success, error code otherwise
* <br>            > 0 special conditions:
* <br>            1 - not found
*/
extern "C" int ServerCacheSessionAbort(HMEM_CTX_DEF
                                       char* pSessionID, int CacheMode)
{
   int Retcode;
   HSESSCACHE_CTL_DESC * pSessCacheCtlDesc;

   if(CacheMode == CACHE_SESSION_TYPE_NON_CACHE)
      return(HSSL_OP_OK);

   //------------------------------------------------------------
   // Check parameters first
   //------------------------------------------------------------
   if(pSessionID == NULL)
      return(HSSL_NULL_PTR);

   if(pSessionID[0] == 0)
      return(HSSL_PARAM_ERR);
   //------------------------------------------------------------
   // Get the Cache control structure from CMA, locked and initialized
   //-----------------------------------------------------------------
   if((Retcode = LockedGetSessCacheCtlDesc(HMEM_CTX_REF,
      SERVER_CACHE_TYPE,
      &pSessCacheCtlDesc)) != 0)
      return(Retcode);
   //----------------------------------------------------------------
   // Check if session type is resumed session
   //----------------------------------------------------------------
   if(CacheMode == CACHE_SESSION_TYPE_RESUMED)
   {
      //--------------------------------------------------------------
      // Was a resumed session, remove element
      //--------------------------------------------------------------
      Retcode = FreeSrvrCacheElementBySessionID(pSessCacheCtlDesc,pSessionID);
      UnlockSessCacheCtlDesc(pSessCacheCtlDesc); // release lock
      return(Retcode);
   }
   //----------------------------------------------------------------
   // Not a resumed session, nothing specific to be done
   //----------------------------------------------------------------
   UnlockSessCacheCtlDesc(pSessCacheCtlDesc); // release lock
   return(HSSL_OP_OK);
}

/**
* Pushes a session element representing a newly established session to cache (ServerCacheSessionEstablished). 
* Depending on if it is a new, resumed or  cloned session, it is added or it's
* reference count is incremented.
*
* -- Server Side --
*
*  @param pElementTemplate Session element to be pushed
*  @param CacheMode 0 - non cachable
*               1 - new session
*               2 - resumed session
*               3 - cloned session
*  @return 0 on success, error code otherwise
* <br>            > 0 special conditions:
* <br>            1 - no more memory
*/
extern "C" int ServerCacheSessionEstablished(HMEM_CTX_DEF
                                             HSERV_CACHE_ELEM * pElementTemplate,
                                             int CacheMode)
{
   int Retcode;
   HSESSCACHE_CTL_DESC * pSessCacheCtlDesc;

   if(CacheMode == CACHE_SESSION_TYPE_NON_CACHE)
      return(HSSL_OP_OK);

   //------------------------------------------------------------
   // Check parameters first
   //------------------------------------------------------------
   if(pElementTemplate == NULL)
      return(HSSL_NULL_PTR);

   if(pElementTemplate->SessionID[0] == 0)
      return(HSSL_PARAM_ERR);
   //-----------------------------------------------------------------
   // Get the Cache control structure from CMA, locked and initialized
   //-----------------------------------------------------------------
   if((Retcode = LockedGetSessCacheCtlDesc(HMEM_CTX_REF,
      SERVER_CACHE_TYPE,
      &pSessCacheCtlDesc)) != 0)
      return(Retcode);
   //----------------------------------------------------------------
   // Check which session type was established
   //----------------------------------------------------------------
   if(CacheMode == CACHE_SESSION_TYPE_NEW)	// new session
   {
      Retcode = AddNewSrvrCacheElement(pSessCacheCtlDesc,
         pElementTemplate);
      UnlockSessCacheCtlDesc(pSessCacheCtlDesc); // release lock
      return(Retcode);
   }
   else if(CacheMode == CACHE_SESSION_TYPE_CLONED) // cloned session
   {
      Retcode = IncrementSrvrCacheElementRefCount(pSessCacheCtlDesc,
         pElementTemplate->SessionID);
      UnlockSessCacheCtlDesc(pSessCacheCtlDesc); // release lock
      return(Retcode);
   }
   else					// resumed session
   {
      Retcode = IncrSrvrCacheElementRefCountOrAddNew(pSessCacheCtlDesc,
         pElementTemplate);
      UnlockSessCacheCtlDesc(pSessCacheCtlDesc); // release lock
      return(Retcode);
   }
}

/**
* Decrease the reference count of a closed session (ServerCacheSessionClosed).
* Push the session to cache,
* if it isn't already in cache.
*
* -- SERVER SIDE --
*
*  @param pElementTemplate Session cache element of the closed session
*  @param CacheMode 0 - non cacheable
*               1 - new session
*               2 - resumed session
*               3 - cloned session
*  @return 0 on success, error code otherwise
* <br>            > 0 special conditions:
* <br>            1 - no more memory
*/
extern "C" int ServerCacheSessionClosed(HMEM_CTX_DEF
                                        HSERV_CACHE_ELEM * pElementTemplate,
                                        int CacheMode)
{
   int Retcode;
   HSESSCACHE_CTL_DESC * pSessCacheCtlDesc;

   if(CacheMode == CACHE_SESSION_TYPE_NON_CACHE)
      return(HSSL_OP_OK);

   //------------------------------------------------------------
   // Check parameters first
   //------------------------------------------------------------
   if(pElementTemplate == NULL)
      return(HSSL_NULL_PTR);

   if(pElementTemplate->SessionID[0] == 0)
      return(HSSL_PARAM_ERR);
   //-----------------------------------------------------------------
   // Get the Cache control structure from CMA, locked and initialized
   //-----------------------------------------------------------------
   if((Retcode = LockedGetSessCacheCtlDesc(HMEM_CTX_REF,
      SERVER_CACHE_TYPE,
      &pSessCacheCtlDesc)) != 0)
      return(Retcode);
   //----------------------------------------------------------------
   // Check which session type was established
   //----------------------------------------------------------------
   if(CacheMode == CACHE_SESSION_TYPE_NEW)	// new session
   {
      Retcode = DecrSrvrCacheElementRefCountOrAddNew(pSessCacheCtlDesc,
         pElementTemplate);
      UnlockSessCacheCtlDesc(pSessCacheCtlDesc); // release lock
      return(Retcode);
   }
   else if(CacheMode == CACHE_SESSION_TYPE_CLONED) // cloned session
   {
      Retcode = DecrementSrvrCacheElementRefCount(pSessCacheCtlDesc,
         pElementTemplate->SessionID);
      UnlockSessCacheCtlDesc(pSessCacheCtlDesc); // release lock
      return(Retcode);
   }
   else					// resumed session
   {
      Retcode = DecrSrvrCacheElementRefCountOrAddNew(pSessCacheCtlDesc,
         pElementTemplate);
      UnlockSessCacheCtlDesc(pSessCacheCtlDesc); // release lock
      return(Retcode);
   }
}

//()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()
//
// Client Side Session Establishment/Closing functions
//
//()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()

/**
* Creates, resumes or clones a session (ClientCacheSessionCreate).
* The generated cache data is filled into the provided element.
*
*NOTE: If no session ID is given, fetch from connection structure,
*   else use given session ID.
*
* -- CLIENT SIDE --
*
*  @param pElementTemplate Cache element to be filled
*  @param pCipherSuitesList client supported cipher list / NULL
*  @param pComprMethodsList client supported compression list / NULL
*
*  @return < 0 error occured
* <br>            >= 0 Initial Cache mode to use:
* <br>            0 - Session NOT cachable (no connection ID, etc.)
* <br>            1 - Element found, but mismatch/Not found, use new
* <br>            2 - Element found, resume mode
* <br>            3 - Element found, clone mode
*/
extern "C" int ClientCacheSessionCreate(HMEM_CTX_DEF
                                        HCLNT_CACHE_ELEM * pElementTemplate,
                                        char* pCipherSuitesList,
                                        char* pComprMethodsList)
{
   int Retcode;
   HSESSCACHE_CTL_DESC * pSessCacheCtlDesc;

   //------------------------------------------------------------
   // Check parameters first
   //------------------------------------------------------------
   if(pElementTemplate == NULL)
      return(HSSL_NULL_PTR);

   //-----------------------------------------------------------------
   // Generate ConnectionID if possible
   //-----------------------------------------------------------------
   if(pElementTemplate->ConnectionID[1] == 0)
   {
      Retcode = GetServerClientIP(HMEM_CTX_REF,0,pElementTemplate->ConnectionID);
      if(Retcode != 0)
         return(CACHE_SESSION_TYPE_NON_CACHE);		// set NON cacheable
   }
   //-----------------------------------------------------------------
   // Get the Cache control structure from CMA, locked and initialized
   //-----------------------------------------------------------------
   if((Retcode = LockedGetSessCacheCtlDesc(HMEM_CTX_REF,
      CLIENT_CACHE_TYPE,
      &pSessCacheCtlDesc)) != 0)
      return(Retcode);
   //----------------------------------------------------------------
   // Find Connection ID, check parameters, copy data to template
   //----------------------------------------------------------------
   Retcode = ClientGetSessionParamsByConnectionID(pSessCacheCtlDesc,
      pElementTemplate,
      pCipherSuitesList,
      pComprMethodsList);
   UnlockSessCacheCtlDesc(pSessCacheCtlDesc); // release lock
   if(Retcode == 0)			// not found
      Retcode = CACHE_SESSION_TYPE_NEW; 

   return(Retcode);
}

/**
* Reduces the reference count for the element of a resumed session (ClientCacheSessionAbort). 
* The session is identified by connection ID and session ID.
* If the reference count drops to 0, the session is removed.
*
* -- CLIENT SIDE  --
* 
*  @param pConnectionID Connection ID, 2nd byte is length 
*  @param pSessionID Session ID, 1st byte is length
*  @param CacheMode 0 - non cachable
*               1 - new session
*               2 - resumed session
*               3 - resumed session
* 
*  @return < 0 error occured
* <br>            == 0 o.k.
* <br>            > 0 special conditions:
* <br>            1 - no cache elements exist
* <br>            2 - no such element for given connection ID
* <br>            3 - element has different sessionID
*/
extern "C" int ClientCacheSessionAbort(HMEM_CTX_DEF
                                       char* pConnectionID, char* pSessionID,
                                       int CacheMode)
{
   int Retcode;

   HSESSCACHE_CTL_DESC * pSessCacheCtlDesc;
   //------------------------------------------------------------
   // No action required if Cache mode NON cachable/ new session
   //------------------------------------------------------------
   if((CacheMode == CACHE_SESSION_TYPE_NON_CACHE) ||
      (CacheMode == CACHE_SESSION_TYPE_NEW))
      return(HSSL_OP_OK);
   //------------------------------------------------------------
   // Check parameters
   //------------------------------------------------------------
   if((pConnectionID == NULL) || (pSessionID == NULL))
      return(HSSL_NULL_PTR);

   if((pConnectionID[1] == 0) || (pSessionID[0] == 0))
      return(HSSL_PARAM_ERR);
   //------------------------------------------------------------
   // Get the Cache control structure from CMA, locked and initialized
   //-----------------------------------------------------------------
   if((Retcode = LockedGetSessCacheCtlDesc(HMEM_CTX_REF,
      CLIENT_CACHE_TYPE,
      &pSessCacheCtlDesc)) != 0)
      return(Retcode);
   //----------------------------------------------------------------
   // Reduce reference count, remove if count reaches 0
   //----------------------------------------------------------------
   Retcode = DecrementClntCacheElementRefCount(pSessCacheCtlDesc,
      pConnectionID,pSessionID);
   UnlockSessCacheCtlDesc(pSessCacheCtlDesc); // release lock
   return(Retcode);
}

/**
* Modifies the cache entry for a session, depending on the session ID received
* from the server (ClientCacheSessionModify).
* Done only for resumed sessions. If the received ID matches the elements 
* session ID, nothing happens (successfull resume), else, the reference count
* is decreased (new, possibly non-cachable session).
*
* NOTE: Template must contain ConnectionID, Session ID if CacheMode > 0
* 
* -- CLIENT SIDE  --
* 
*  @param pElementTemplate temporary
*  @param pSessionID received ID, 1st byte length
*  @param CacheMode 0 - non cachable
*               1 - new session
*               2 - resumed session
*               3 - resumed session
* 
*  @return < 0 error occured
* <br>            >= 0 New cache mode to use 
* <br>            0 set not cachable cache mode
* <br>            1 initial new/different session ID,process as new
* <br>            2 session ID same as sent, keep resume mode
* <br>            3 session ID same as sent, keep clone mode
*/
extern "C" int ClientCacheSessionModify(HMEM_CTX_DEF
                                        HCLNT_CACHE_ELEM * pElementTemplate,
                                        char* pSessionID,
                                        int CacheMode)
{
   int Retcode;

   HSESSCACHE_CTL_DESC * pSessCacheCtlDesc;
   //------------------------------------------------------------
   // No action required if Cache mode NON cachable/ new session
   //------------------------------------------------------------
   if((CacheMode == CACHE_SESSION_TYPE_NON_CACHE) ||
      (CacheMode == CACHE_SESSION_TYPE_NEW))
   {
      return(CacheMode);
   }
   //------------------------------------------------------------
   // Check parameters
   //------------------------------------------------------------
   if((pElementTemplate == NULL) || (pSessionID == NULL))
      return(HSSL_NULL_PTR);

   if((pElementTemplate->ConnectionID[1] == 0) ||
      (pElementTemplate->SessionID[0] == 0))
      return(HSSL_PARAM_ERR);
   //------------------------------------------------------------
   // Get the Cache control structure from CMA, locked and initialized
   //-----------------------------------------------------------------
   if((Retcode = LockedGetSessCacheCtlDesc(HMEM_CTX_REF,
      CLIENT_CACHE_TYPE,
      &pSessCacheCtlDesc)) != 0)
      return(Retcode);
   //----------------------------------------------------------------
   // Check how to continue
   //----------------------------------------------------------------
   if(pSessionID[0] == 0)		// no session ID returned, remove
   {
      //--------------------------------------------------------------
      // Server did not accept, returned empty ID, non cacheable
      //--------------------------------------------------------------
      Retcode = DecrClntCacheElementRefCountRemoveIfZero(pSessCacheCtlDesc,
         pElementTemplate->ConnectionID,
         pElementTemplate->SessionID,
         0);
      UnlockSessCacheCtlDesc(pSessCacheCtlDesc); // release lock
      if(Retcode < 0)
         return(Retcode);
      return(CACHE_SESSION_TYPE_NON_CACHE);	// not cacheable
   }
   //---------------------------------------------------------------
   // Received ID not 0, check if same as cached
   //---------------------------------------------------------------
   if((((int) pSessionID[0] & 0x0FF) !=
      ((int) pElementTemplate->SessionID[0] & 0x0FF)) ||
      (memcmp(pSessionID+1,pElementTemplate->SessionID+1,
      (int) pSessionID[0] & 0x0FF) != 0))
   {
      //-------------------------------------------------------------
      // different session ID received
      //-------------------------------------------------------------
      Retcode = DecrClntCacheElementRefCountRemoveIfZero(pSessCacheCtlDesc,
         pElementTemplate->ConnectionID,
         pElementTemplate->SessionID,
         0);
      UnlockSessCacheCtlDesc(pSessCacheCtlDesc); // release lock
      if(Retcode < 0)
         return(Retcode);
      return(CACHE_SESSION_TYPE_NEW);
   }
   //---------------------------------------------------------------
   // Received ID is same as sent
   //---------------------------------------------------------------
   UnlockSessCacheCtlDesc(pSessCacheCtlDesc); // release lock
   return(CacheMode);
}

/**
* Pushes an element for an established session to cache (ClientCacheSessionEstablished). 
* For a new session,
* the element is added, for a resumed or cloned session, the reference count
* is incremented.
*
* -- CLIENT SIDE --
*
*  @param pElementTemplate Element of the new session
*  @param CacheMode 0 - non cachable
*               1 - new session
*               2 - resumed session
*               3 - cloned session
*
*  @return int Status - < 0 error occured
* <br>            >= 0 Cache mode to use
* <br>            0 non cacheable
* <br>            1 new session
* <br>            2 resumed session
* <br>            3 cloned session
*/
extern "C" int ClientCacheSessionEstablished(HMEM_CTX_DEF
                                             HCLNT_CACHE_ELEM * pElementTemplate,
                                             int CacheMode)
{
   int Retcode;
   HSESSCACHE_CTL_DESC * pSessCacheCtlDesc;
   //------------------------------------------------------------
   // No action required if Cache mode NON cachable
   //------------------------------------------------------------
   if(CacheMode == CACHE_SESSION_TYPE_NON_CACHE)
      return(CacheMode);

   //------------------------------------------------------------
   // Check parameters first
   //------------------------------------------------------------
   if(pElementTemplate == NULL)
      return(HSSL_NULL_PTR);

   if((pElementTemplate->ConnectionID[1] == 0) ||
      (pElementTemplate->SessionID[0] == 0))
      return(HSSL_PARAM_ERR);
   //-----------------------------------------------------------------
   // Get the Cache control structure from CMA, locked and initialized
   //-----------------------------------------------------------------
   if((Retcode = LockedGetSessCacheCtlDesc(HMEM_CTX_REF,
      CLIENT_CACHE_TYPE,
      &pSessCacheCtlDesc)) != 0)
      return(Retcode);
   //----------------------------------------------------------------
   // Check which session type was established
   //----------------------------------------------------------------
   if(CacheMode == CACHE_SESSION_TYPE_NEW)	// new session
   {
      Retcode = AddReplaceClntCacheElement(pSessCacheCtlDesc,
         pElementTemplate);
      UnlockSessCacheCtlDesc(pSessCacheCtlDesc); // release lock
      if(Retcode < 0)				// error occured
         return(Retcode);
      else if(Retcode > 0)			// no space in cache
         return(CACHE_SESSION_TYPE_NON_CACHE);
      else					// added o.k.
         return(CacheMode);
   }
   else						// resumed/cloned session
   {
      Retcode = ConditionalAddClntCacheElement(pSessCacheCtlDesc,
         pElementTemplate);
      UnlockSessCacheCtlDesc(pSessCacheCtlDesc); // release lock
      if(Retcode < 0)				// error occured
         return(Retcode);
      else if((Retcode == 0) || (Retcode > 2))	// added/incremented
         return(CacheMode);
      else					// not added/different ID
         return(CACHE_SESSION_TYPE_NON_CACHE);
   }
}

/**
* Decreases reference count of a session (ClientCacheSessionClosed).
* If requested, the session entry is removed, if the reference count should 
* reach 0.
*
* -- CLIENT SIDE --
*
*  @param pElementTemplate Session cache element with the ID data
*  @param CacheMode 0 - non cachable
*               1 - new session
*               2 - resumed session
*               3 - cloned session
*  @param CacheRemove == 0 - standard close, keep in cache
*               <> 0 - abnormal close, remove
* @todo rework return status
*
*  @return < 0 error occured
* <br>            == 0 o.k. 
* <br>            > 0 special conditions:
* <br>            1 - no cache elements exist
* <br>            2 - no such element for given connection ID
* <br>            3 - element has different sessionID
*/
extern "C" int ClientCacheSessionClosed(HMEM_CTX_DEF
                                        HCLNT_CACHE_ELEM * pElementTemplate,
                                        int CacheMode, int CacheRemove)
{
   int Retcode;
   HSESSCACHE_CTL_DESC * pSessCacheCtlDesc;

   //------------------------------------------------------------
   // Check if cacheable mode at all
   //------------------------------------------------------------
   if(CacheMode == CACHE_SESSION_TYPE_NON_CACHE)
      return(HSSL_OP_OK);

   //------------------------------------------------------------
   // Check parameters first
   //------------------------------------------------------------
   if(pElementTemplate == NULL)
      return(HSSL_NULL_PTR);

   if((pElementTemplate->ConnectionID[1] == 0) ||
      (pElementTemplate->SessionID[0] == 0))
      return(HSSL_PARAM_ERR);
   //-----------------------------------------------------------------
   // Get the Cache control structure from CMA, locked and initialized
   //-----------------------------------------------------------------
   if((Retcode = LockedGetSessCacheCtlDesc(HMEM_CTX_REF,
      CLIENT_CACHE_TYPE,
      &pSessCacheCtlDesc)) != 0)
      return(Retcode);
   //----------------------------------------------------------------
   // Check if normal/abnormal close requested
   //----------------------------------------------------------------
   if(CacheRemove != 0)				// abnormal close
   {
      Retcode = DecrClntCacheElementRefCountRemoveIfZero(pSessCacheCtlDesc,
         pElementTemplate->ConnectionID,
         pElementTemplate->SessionID,
         CacheRemove);
      UnlockSessCacheCtlDesc(pSessCacheCtlDesc); // release lock
      return(Retcode);
   }
   else						// normal close
   {
      Retcode = DecrementClntCacheElementRefCount(pSessCacheCtlDesc,
         pElementTemplate->ConnectionID,
         pElementTemplate->SessionID);
      UnlockSessCacheCtlDesc(pSessCacheCtlDesc); // release lock
      return(Retcode);
   }
}

/**
* Frees all used cache elements for a given cache type (FreeSessionCache).
*
*  @param CacheType 0 for server elements, non-0 for client elements
*  @return 0 on success, error code otherwise
*/
extern "C" int FreeSessionCache(HMEM_CTX_DEF int CacheType)
{
   int Retcode;
   int ElementSize;
   HSESSCACHE_CTL_DESC * pSessCacheCtlDesc;
   //-----------------------------------------------------------------
   // Get the Cache control structure from CMA, locked and initialized
   //-----------------------------------------------------------------
   if((Retcode = LockedGetSessCacheCtlDesc(HMEM_CTX_REF,
      CacheType,
      &pSessCacheCtlDesc)) != 0)
      return(Retcode);
   //----------------------------------------------------------------
   // Free all allocated elements
   //----------------------------------------------------------------
   if(CacheType == 0)
      ElementSize = sizeof(HSERV_CACHE_ELEM);
   else
      ElementSize = sizeof(HCLNT_CACHE_ELEM);

   // Free the Element buffer, first clear it (master secrets!)
   if(pSessCacheCtlDesc->pSessionCacheBuf != NULL)
      memset(pSessCacheCtlDesc->pSessionCacheBuf,0,
      pSessCacheCtlDesc->SlotsAllocedCount * ElementSize);

   FREE_ARRAYEX_GLBL(HMEM_CTX_REF,pSessCacheCtlDesc->pSessionCacheBuf);
   pSessCacheCtlDesc->pSessionCacheBuf = NULL;

   FREE_ARRAYEX_GLBL(HMEM_CTX_REF,pSessCacheCtlDesc->pUseStateBitsList);
   pSessCacheCtlDesc->pUseStateBitsList = NULL;

   FREE_ARRAYEX_GLBL(HMEM_CTX_REF,pSessCacheCtlDesc->pUtcSortedIndexArr);
   pSessCacheCtlDesc->pUtcSortedIndexArr = NULL;

   FREE_ARRAYEX_GLBL(HMEM_CTX_REF,pSessCacheCtlDesc->pIdSortedIndexArr);
   pSessCacheCtlDesc->pIdSortedIndexArr = NULL;

   FREE_ARRAYEX_GLBL(HMEM_CTX_REF,pSessCacheCtlDesc->pIdCompactBitList);
   pSessCacheCtlDesc->pIdCompactBitList = NULL;

   pSessCacheCtlDesc->SlotsAllocedCount  = 0;
   pSessCacheCtlDesc->SlotsInUseCount    = 0;
   pSessCacheCtlDesc->IdSlotsInUseCount  = 0;
   pSessCacheCtlDesc->UtcSlotsInUseCount = 0;

   UnlockSessCacheCtlDesc(pSessCacheCtlDesc); // release lock
   return(HSSL_OP_OK);			// o.k.
}
#else

#ifdef _WIN32
// Disable warnings for unused parameters, these are all dummies
#pragma warning(push)
#pragma warning(disable: 4100)
#endif
/*
Special 'no cache' version for IWT
*/

extern "C" int CheckAuxCMASupport(HMEM_CTX_DEF int CacheType)
{
   return 0;
}

int SetSessionCacheInitParams(int CacheType,
                              uint32_t CacheMaxEntriesCount,
                              uint32_t CacheElementTimeToLive)
{
   return -1;
}

int ServerCacheSessionCreate(HMEM_CTX_DEF
                             HSERV_CACHE_ELEM * pElementTemplate,
                             char* pNewSessionID,
                             int CreateMode,
                             char* pCipherSuitesList,
                             char* pComprMethodsList)
{
   return -1;
}

int ServerCacheSessionAbort(HMEM_CTX_DEF
                            char* pSessionID, int CacheMode)
{
   return -1;
}

int ServerCacheSessionEstablished(HMEM_CTX_DEF
                                  HSERV_CACHE_ELEM * pElementTemplate,
                                  int CacheMode)
{
   return -1;
}

int ServerCacheSessionClosed(HMEM_CTX_DEF
                             HSERV_CACHE_ELEM * pElementTemplate,
                             int CacheMode)
{
   return -1;
}

int ClientCacheSessionCreate(HMEM_CTX_DEF
                             HCLNT_CACHE_ELEM * pElementTemplate,
                             char* pCipherSuitesList,
                             char* pComprMethodsList)
{
   return -1;
}

int ClientCacheSessionAbort(HMEM_CTX_DEF
                            char* pConnectionID, char* pSessionID,
                            int CacheMode)
{
   return -1;
}

int ClientCacheSessionModify(HMEM_CTX_DEF
                             HCLNT_CACHE_ELEM * pElementTemplate,
                             char* pSessionID,
                             int CacheMode)
{
   return -1;
}

int ClientCacheSessionEstablished(HMEM_CTX_DEF
                                  HCLNT_CACHE_ELEM * pElementTemplate,
                                  int CacheMode)
{
   return -1;
}

int ClientCacheSessionClosed(HMEM_CTX_DEF
                             HCLNT_CACHE_ELEM * pElementTemplate,
                             int CacheMode, int CacheRemove)
{
   return -1;
}

int FreeSessionCache(HMEM_CTX_DEF int CacheType)
{
   return -1;
}
#endif

/** @} */

#ifdef _WIN32
// Restore warning setting
#pragma warning(pop)
#endif
#endif // XH_INTERFACE

#endif //HL_SSL_CACHE
// end of file ../hcma/hscache.cpp


#ifdef HL_SSL_V42BIS
//define TRACEHL1
/*+--------------------------------------------------------------------------+*/
//  2001/07/07, 2001/07/09 adopted to newest Version of Original KB Program
/*|                                                                          |*/
/*| PROGRAM NAME: UV42BIS1                                                   |*/
/*| -------------                                                            |*/
/*|  created 29.03.99 KB                                                     |*/
/*|  Subroutine LZW-compression analog ITU standard V.42bis.                 |*/
/*|  Attention: not tested if conform to standard.                           |*/
/*|  Routine with code-word size up to 15 bits.                              |*/
// NOTE: 1. Encoding/Decoding reduced to single record mode
//       2. Max. Codewordsize reduced to 14 bit
//	 3. Memory Allocation is directly performed
//	 4. Encoding is terminated if output buffer is filled
//	    (SSL demands for max. 1k longer buffer for compression)
//	 5. Additional structures removed (changed to arrays)
/*|                                                                          |*/
/*| COPYRIGHT:                                                               |*/
/*| ----------                                                               |*/
/*|  Copyright (C) HOB electronic 1999                                       |*/
/*|                                                                          |*/
/*| WHAT THIS PROGRAM DOES:                                                  |*/
/*| -----------------------                                                  |*/
/*|  This program is a subroutine to other programs and                      |*/
/*|  compresses data.                                                        |*/
/*|                                                                          |*/
/*| WHAT YOU NEED TO COMPILE THIS PROGRAM:                                   |*/
/*| --------------------------------------                                   |*/
/*|                                                                          |*/
/*|  REQUIRED FILES:                                                         |*/
/*|  ---------------                                                         |*/
/*|                                                                          |*/
//     BASETYPE.H	- Types for C and JAVA
//     BASEMACS.H	- Macros for C and JAVA
/*|    UV42BIS1.cpp   - Source code                                          |*/
/*|    UCDRDEF1.h     - Application header file                              |*/
/*|                                                                          |*/
/*|    STDLIB.H       - Standard library function declarations               |*/
/*|    STRING.H       - String handling function declarations                |*/
/*|                                                                          |*/
/*|  REQUIRED LIBRARIES:                                                     |*/
/*|  -------------------                                                     |*/
//   Standard libraries/classes for C // JAVA
/*|                                                                          |*/
/*|    OS2386.LIB     - Presentation Manager/OS2 library                     |*/
/*|    DDE4NBS.LIB    - Subsystem Development Library                        |*/
/*|                                                                          |*/
/*|  REQUIRED PROGRAMS:                                                      |*/
/*|  ------------------                                                      |*/
/*|                                                                          |*/
/*|    IBM C Set/2 Compiler                                                  |*/
/*|    IBM Linker                                                            |*/
/*|                                                                          |*/
/*| EXPECTED INPUT:                                                          |*/
/*| ---------------                                                          |*/
/*|                                                                          |*/
/*| EXPECTED OUTPUT:                                                         |*/
/*| ----------------                                                         |*/
/*|                                                                          |*/
/*+--------------------------------------------------------------------------+*/
#if (defined _WIN32) & (_MSC_VER < 1700)
#ifndef _STDINT
#define _STDINT
// MSVC lower than 17.00 does not have stdint.h, assure, all needed types are defined

typedef unsigned __int16 uint16_t;

typedef unsigned __int32 uint32_t;

typedef unsigned __int64 uint64_t;

#endif // !_STDINT
#else
#include <stdint.h>
#endif
#include <stddef.h>
#ifdef _WIN32
#define WIN32_LEAN_AND_MEAN
#include <Windows.h>
#undef WIN32_LEAN_AND_MEAN
#else// Define system-specific HL_* defines here
#ifndef HL_UNIX
#define HL_UNIX

#if (defined __gnu_linux__) || (defined __linux__)
#define HL_LINUX
#endif

#if (defined __APPLE__) && (defined __MACH__)
#define HL_LINUX
#define HL_MACOS
#endif

#ifdef _AIX
#define HL_AIX
#define HL_BIG_ENDIAN
#endif

#ifdef __FreeBSD__
#define HL_FREEBSD
#endif

#if (defined _hpux) || (defined hpux) || (defined __hpux)
#define HL_HPUX
#define HL_BIG_ENDIAN
#endif

#if (defined sun) || (defined __sun)
#define HL_SOLARIS
#endif

#if (defined __arm__) || (defined __aarch64__)
#define HL_LINUX_ARM
#endif

#ifdef __ANDROID__
#define HL_ANDROID
#endif

#endif
#include <hob-unix01.h>
#endif
#ifdef __APPLE__
/* We get target conditionals to keep apart Mac OS, iOS and iOS simulator.
   The conditionals are TARGET_IPHONE_SIMULATOR, TARGET_OS_IPHONE and TARGET_OS_MAC.
   TARGET_IPHONE_SIMULATOR has the highest priority, TARGET_OS_MAC the lowest.
   Always test, if the conditional is 1, as they will be defined as 0, if we 
   are not compiling for the target.
   */
#include <TargetConditionals.h>
#endif

#ifdef HL_ANDROID
#include <sys/endian.h>
#endif

#include "hob-encry-1.h"
#include "hob-cert-ext.h"
#if !(defined __HOB_XSCLIB01__) && !(defined DEF_IFUNC_START)
#define __HOB_XSCLIB01__

#include <hob-xsclib01.h>  
#endif // !__HOB_XSCLIB01__
#include <stdlib.h>
#include <hob-encry-2.h>
#include "hob-ssl-intern.h"
#include <string.h>
#if (defined TRACEHL1) || (defined _DEBUG_)
#include <stdio.h>
#endif
#if defined _DEBUG_
#define DBG_PRT(a) printf a
#else
#define DBG_PRT(a)
#endif

#ifndef TRUE
#define TRUE 1
#endif

#ifndef FALSE
#define FALSE 0
#endif
/** @defgroup v42bis V.42bis
* This module implements the ITU/CCITT V.42bis compression. It is used for 
* TLS/SSL (used proprietary, not specified for TLS/SSL yet).
*
* This module depends on no other module.
*  @{
*  @file
* This file contains the V.42bis implementation.
* @} 
*/

/*+--------------------------------------------------------------------------+*/
/*| System and library header files.                                         |*/
/*+--------------------------------------------------------------------------+*/

//=============================================================
// Output codewordsize change if there is a difference between
// current (requested size) and the size of the receiver
//=============================================================
/** @addtogroup v42bis
* @{
*/
/**
*  Generates codeword size change encoding if there is a difference between the
*  new requested code word size and the code word size the receiver is 
*  currently using. Used for compression only.
*/
static int enc_checkcw(DENC* denc, char* pDstBuf,
		int TmpDstBufTopIndex, int pDstBufCurrIndex)
{
  while(denc->uscodews_d < denc->uscodews_e)
  {
#ifdef TRACEHL1
    printf( "enc_checkcw uscodews_d = %d / i_shift_c = %d / i_shift_v = %08X\n",
             denc->uscodews_d, denc->i_shift_c, denc->i_shift_v );
#endif
    denc->i_shift_v |= (((int) CODE_SETUP & 0xFF) << denc->i_shift_c);  /* get new bi  */
    denc->i_shift_c = (char) (denc->i_shift_c + denc->uscodews_d);   /* add bits                */
    do
    {
      if(pDstBufCurrIndex >= TmpDstBufTopIndex) return(-1);
      pDstBuf[pDstBufCurrIndex++] = (char) denc->i_shift_v;   /* insert character        */
      denc->i_shift_v >>= VAL_N3;          /* shift result            */
      denc->i_shift_c -= VAL_N3;           /* remove bits             */
    } while (denc->i_shift_c >= VAL_N3);
    denc->uscodews_d++;                    /* increment value         */
  }
  return(pDstBufCurrIndex);
}
/*+--------------------------------------------------------------------------+*/
/*| Main control procedure.                                                  |*/
/*+--------------------------------------------------------------------------+*/

  /* The encoder function builds the compressed data in the
     output area. If the compressed data is larger than the
     transparent data, the transparent data is moved to the output
     area.                                                            */
// NOTE: This is NOT QUITE true: output data m u s t be some kind longer
// ----- before replacement happens !!
/**
*  This method gets a structure containing data input/output buffer pointers 
*  and current compress state structure (parameters, wordlength, dicitionary
*  etc). It processes data from the input buffer and compresses them according
*  to the current state from the compress state structure and outputs the data
*  to the output buffer.
*
* @param dcdf Pointer to compress parameter structure
*/ 
extern "C" void  CdrEnc(HMEM_CTX_DEF DCDR* dcdf)
{
  /* Declare local variables.                                         */

  DENC* denc;                            /* fields for enqueue      */
  short  iu1 = 0;
  short  iu2 = 0;
  short  isu1 = 0;                          /* working variable        */
  short  isu2 = 0;                          /* working variable        */
  int    au1 = 0;                             /* temporary field addr    */

  char* SrcBuf = NULL;
  char* DstBuf = NULL;

  int SrcBufCurrIndex = 0;
  int SrcBufTopIndex  = 0;
  int DstBufCurrIndex = 0;
  int DstBufTopIndex  = 0;
  //----------------------------------------------------------
  // distribute according to function
  //----------------------------------------------------------
  switch(dcdf->ifunc)
  {
    case DEF_IFUNC_CONT:		// start encoding !
      break;

    case DEF_IFUNC_START:
      //------------------------------------------------------
      // Initialization, allocate Memory, clear it, set states
      //------------------------------------------------------
      dcdf->ireturn = DEF_IRET_ERRAU;        // preset error 
      denc = (DENC *)
               ((void *) BIT8_ARRAY_ALLOC((ds__hmem *) 
				          HMEM_CTX_REF,sizeof(DENC)));
      if(denc == NULL) return;			// allocate error
      memset(denc, 0, sizeof(DENC) );         /* clear structure          */
      for(iu1 = 0;iu1 < VAL_N4;iu1++) denc->ddic1[iu1] = UNUSED;
      denc->addic2 = (short*)
        BIT16_ARRAY_ALLOC((ds__hmem *) HMEM_CTX_REF,
		          DIC2_ELEN*((1<<dcdf->ul_param_1) -VAL_N5));
      if(denc->addic2 == NULL)
      {
        FREE_ARRAY((ds__hmem *) HMEM_CTX_REF,denc); // free 2nd array
        return;                                /* return to main-prog     */
      }

      denc->isnextfree = VAL_N5;               /* here are free entries   */
      denc->uscodews_e = VAL_N3 + 1;           /* C2 encoder number of bi */
      denc->uscodews_d = VAL_N3 + 1;           /* C2 decoder number of bi */
      denc->iscwthreshold = VAL_N4 * 2;        /* C3 threshold code w s c */
      denc->ispostree = UNUSED;                /* position in tree        */
      dcdf->penc = denc;                 /* store address of fields */
//      dcdf->bo_compressed = COMPRESSED;        /* output always compr     */
      dcdf->ifunc    = DEF_IFUNC_CONT;       /* next call continue      */
      dcdf->ireturn = DEF_IRET_NORMAL;      /* call subroutine again   */
      return;                                  /* return to main program  */

      //----------------------------------------------
      // Deallocate memory in use
      //----------------------------------------------
    case DEF_IFUNC_END:
      FREE_ARRAY((ds__hmem *) HMEM_CTX_REF,dcdf->penc->addic2);
      FREE_ARRAY((ds__hmem *) HMEM_CTX_REF,dcdf->penc);
      dcdf->ireturn = DEF_IRET_END;        /* all done                */
      return;                                  /* return to main program  */

    default:
//      printf( "ENC invalid function %d\n", CDR_FUNC(dcdf) );
      dcdf->ireturn = DEF_IRET_ERRAU;        /* message error           */
      return;
  } // switch

  //--------------------------------------------------------------------
  // Start encoding, single record mode with complete output buffer only
  //--------------------------------------------------------------------
  dcdf->ireturn = DEF_IRET_OVERFLOW;		// preset error case
  denc = dcdf->penc;              /* get address of fields   */
  SrcBuf = dcdf->SrcBuf;  	            // Buffer base
  SrcBufCurrIndex = dcdf->SrcStartIndex;    /* start of input          */
  SrcBufTopIndex  = dcdf->SrcEndIndex;
  DstBuf = dcdf->DstBuf;			// Buffer base
  DstBufCurrIndex = dcdf->DstStartIndex;         /* start of output         */
  DstBufTopIndex  = dcdf->DstEndIndex;		// size

  denc->ai_st_start_index = -1;		// set invalid
  //--------------------------------------------------------------------
  // Data Processing loop (outmost FOR)
  //--------------------------------------------------------------------
for(;;)
{
  if (SrcBufCurrIndex >= SrcBufTopIndex) break;	// no more data !!
  denc->ch_st_escape_3 = denc->ch_st_escape_2;  /* save last escape c */
  denc->ch_st_escape_2 = denc->ch_escape;  /* escape character last c */
  //----------------------------------------------------------
  // Check for Escape Character first; ADDED 9.7.2001
  //----------------------------------------------------------
  if (SrcBuf[SrcBufCurrIndex] == denc->ch_escape)    /* escape found            */
  {
    denc->ch_escape += ESCAPE_MOD;         /* modify escape character */
    denc->i_add_transparent++;             /* add to transparent len  */
  }

  if(denc->ispostree < 0)			// no predecessor
  {
// The following moved ahead of IF clause; 9.7.2001
//  if (SrcBuf[SrcBufCurrIndex] == ENC_CH_ESC(denc))    /* escape found            */
//  {
//    ENC_CH_ESC(denc) += ESCAPE_MOD;         /* modify escape character */
//    ENC_ADD_TRAN(denc)++;             /* add to transparent len  */
//  }
    if (denc->bo_compressed == UNCOMPRESSED)  /* state transp / compr    */
    {
      denc->ai_st_start_index = SrcBufCurrIndex;      /* start of input          */
      denc->ch_st_escape_1 = denc->ch_st_escape_2;  /* escape character */
    }
    denc->ilenstr = 1;                       /* length of string found  */
					  /* position in tree is ch  */
    denc->ispostree = (short) ((short) SrcBuf[SrcBufCurrIndex++] & 0xFF);
    continue;				// get more input data !
  }

		                             /* is anywhere in tree     */
// The following moved ahead of IF clause; 9.7.2001
//if (SrcBuf[SrcBufCurrIndex] == ENC_CH_ESC(denc))  /* escape in data stream   */
//{
//  ENC_CH_ESC(denc) += ESCAPE_MOD;         /* modify escape character */
//  ENC_ADD_TRAN(denc)++;             /* add to transparent len  */
//}
  //------------------------------------------------
  // check if caracter is in root or tree arena
  //------------------------------------------------
  denc->bo_add_tree = MUST_ADD_TREE;     	// assume must add to tree
  if(denc->ispostree < VAL_N5)          // is in root arena, must add
    isu1 = denc->ddic1[denc->ispostree];
  else					// is in tree arena
  {
    if(denc->ilenstr >= (short) dcdf->ul_param_2) /* if string length equal to P2, output string                      */
    {
      denc->bo_add_tree = DONT_ADD_TREE;   /* do not add to tree      */
      isu1 = -1;				// allowed ???
    }
    else
      isu1 = denc->addic2[(denc->ispostree*DIC2_ELEN)+ISCHDOWN_INDEX];
  }

  if(isu1 >= 0)				// not end of tree (0 also allowed!)
  {
    isu2 = 0;
    do
    {
      if (SrcBuf[SrcBufCurrIndex] == (char)
	 (denc->addic2[(isu1*DIC2_ELEN)+CHVAL_INDEX]))
      {
        if (denc->bo_ignore_nch == IGNORE_NEXT_CHAR) /* ignore next char. */
        {
          if (denc->bo_compressed == UNCOMPRESSED)  /* transparent till end  */
	  {
            if(DstBufCurrIndex >= DstBufTopIndex)	// error !
            {
              DBG_PRT(("Error 1\n");)
              return;
            }
            DstBuf[DstBufCurrIndex++] = SrcBuf[SrcBufCurrIndex];// copy character to output
//          if (SrcBuf[SrcBufCurrIndex] == ENC_CH_ESC3(denc))//CHANGED 6.7.2001
            if (SrcBuf[SrcBufCurrIndex] == denc->ch_st_escape_2)//CHANGED 6.7.2001
	    {
              if(DstBufCurrIndex >= DstBufTopIndex)		// error !
              {
                DBG_PRT(("Error 2\n");)
                return;
              }
              DstBuf[DstBufCurrIndex++] = CODE_EID;		 /* insert character        */
            }
          }
          else
          {
            denc->bo_ignore_nch = DONT_IGNORE_NEXT_CHAR;   /* ignore next character   */
            denc->ilenstr = 1;               /* length of string found  */
						  /* position in tree ch  */
            denc->ispostree = (short) ((short) SrcBuf[SrcBufCurrIndex++] & 0xFF);
	    isu2 = 1;			// signal continue mode
            break;
          }
        }
        denc->ilenstr++;                     /* length of string found  */
        SrcBufCurrIndex++;                      /* next input character    */
        denc->ispostree = isu1;              /* save position in tree   */
        isu2 = 1;			// signal continue mode
	break;
      }
      isu1 = denc->addic2[(isu1*DIC2_ELEN)+ISCHNEXT_INDEX];
    } while (isu1 >= 0);
    if(isu2 != 0) continue;		// continue processing outmost loop
  }

   /* character not found in tree                                      */
   /* output the found string position                                 */
  for(;;)				// inner processing for (output)
  {
    if(denc->bo_ignore_nch == IGNORE_NEXT_CHAR)   /* ignore next character   */
    {
      denc->bo_ignore_nch = DONT_IGNORE_NEXT_CHAR;  /* ignore next character   */
//      isu1 = ENC_POSTREE(denc);  // REMOVED 6.7.2001 /* get position found      */
    //  goto pecco76;                          /* continue                */
      break;
    }

    if(denc->bo_compressed == UNCOMPRESSED)	// in transparent mode
    {
      if ((denc->ispostree >= VAL_N5) ||	 // enter compressed
          (denc->ispostree == ((int) denc->ch_st_escape_3 & 0xFF)))
      {
        denc->bo_st_compressed = UNCOMPRESSED;          /* state transp / compr    */

        denc->ao_st_start = DstBufCurrIndex;        /* save start of output    */
        denc->us_st_codews = denc->uscodews_d;   /* save C2 no of bits codw */
        denc->i_add_transparent = 0;             /* add to transparent len  */
        if(denc->ispostree == ((int) denc->ch_st_escape_3 & 0xFF))
          denc->i_add_transparent = 1;
        denc->bo_compressed = COMPRESSED;        /* state transp / compr    */
        if(DstBufCurrIndex >= DstBufTopIndex)		// error !
        {
          DBG_PRT(("Error 3\n");)
          return;	
        }
        DstBuf[DstBufCurrIndex++] = denc->ch_st_escape_1;   /* insert character        */
        if(DstBufCurrIndex >= DstBufTopIndex)		// error !
        {
          DBG_PRT(("Error 4\n");)
          return;
        }

        DstBuf[DstBufCurrIndex++] = CODE_ECM;   /* insert character        */
        denc->i_shift_c = 0;                     /* nothing in buffer       */
        denc->i_shift_v = 0;                     /* also no value           */
      }
      else					// do not enter compressed
      {
        if (DstBufCurrIndex == DstBufTopIndex)	// Error !
        {
          DBG_PRT(("Error 5\n");)
          return;
        }
        DstBuf[DstBufCurrIndex++] = (char) denc->ispostree;  /* output transparent   */
//        isu1 = ENC_POSTREE(denc); // REMOVED 6.7.2001 /* get position found      */
//        goto pecco76;                            /* output has been done    */
        break;
      }
    }

    /* check if receiver knows codeword size                            */

    DstBufCurrIndex = enc_checkcw(denc,DstBuf,DstBufTopIndex,DstBufCurrIndex);
    if(DstBufCurrIndex < 0)			// error occured
    {
      DBG_PRT(("Error 6\n");)
      return;
    }

//  isu1 = isu2 = ENC_POSTREE(denc);           /* get position found      */
    isu1 = denc->ispostree;		// CHANGED 9.7.2001  /* get position found      */
//  if (isu2 < VAL_N4) isu2 += VAL_N6;       /* first values control    */
    if (isu1 < VAL_N4) isu1 += VAL_N6;  // CHANGED 9.7.2001  /* first values control    */

#ifdef TRACEHL1
//  printf( "ENC pecco64 output compr = %04X\n", isu2 );
    printf( "ENC pecco64 output compr = %04X\n", isu1 ); // CHANGED 9.7.2001
#endif

//  ENC_SHIFT_V(denc) |= (((BIT32) isu2 & 0xFFFF) << ENC_SHIFT_C(denc));  /* get new bits        */
    denc->i_shift_v |= (((int) isu1 & 0xFFFF) << denc->i_shift_c); // CHANGED 9.7.2001   /* get new bits        */

    denc->i_shift_c = (char) (denc->i_shift_c + denc->uscodews_e);     /* add bits                */
    do
    {
      if(DstBufCurrIndex >= DstBufTopIndex)	// error !
      {
        DBG_PRT(("Error 7\n");)
        return;
      }

      DstBuf[DstBufCurrIndex++] = (char) denc->i_shift_v;   /* insert character        */
      denc->i_shift_v >>= VAL_N3;            /* shift result            */
      denc->i_shift_c -= VAL_N3;             /* remove bits             */
    }while (denc->i_shift_c >= VAL_N3);

   /* compare with transparent output                                  */

    if (denc->ai_st_start_index < 0)
    {

#ifdef TRACEHL1
    printf( "ENC compressed is smaller ch_escape = %02X / ch_st_escape_1 = %02X / ch_st_escape_2 = %02X / ch_st_escape_3 = %02X\n",
               denc->ch_escape, denc->ch_st_escape_1, denc->ch_st_escape_2, denc->ch_st_escape_3 );
#endif

       /* compressed is smaller, so output till here is valid anyhow     */
      denc->ai_st_start_index = SrcBufCurrIndex;        /* start of input          */
      denc->ao_st_start = DstBufCurrIndex;        /* start of output         */
      denc->bo_st_compressed = COMPRESSED;     /* state transp / compr    */
      denc->ch_st_escape_1 = denc->ch_st_escape_2;  /* escape character   */
      denc->us_st_codews = denc->uscodews_d;   /* save C2 no of bits codw */
      denc->i_st_shift_c = denc->i_shift_c;    /* shift-count             */
      denc->i_st_shift_v = denc->i_shift_v;    /* shift-value             */
      denc->i_add_transparent = 0;             /* add to transparent len  */
      if (SrcBuf[denc->ai_st_start_index] == denc->ch_st_escape_2)  /* escape in da  */
        denc->i_add_transparent = 1;           /* add to transparent len  */

//      if (!((DstBufCurrIndex >= DstBufTopIndex) &&
//         (DstBufCurrIndex <= DstBufTopIndex)))

//        return;				// is an error !
//      goto pecco76;
      break;
    }

    iu1 = (short) (DstBufCurrIndex - denc->ao_st_start);// act. compressed length
    iu2 = (short) (SrcBufCurrIndex - denc->ai_st_start_index+	// act. Transparent length
          denc->i_add_transparent);

#ifdef TRACEHL1
    printf( "compressed = %d / transparent = %d\n", iu1, iu2 );
#endif

    if((iu1 + (denc->i_shift_c + denc->uscodews_e + VAL_N3 - 1) / VAL_N3)<iu2)
    {
#ifdef TRACEHL1
      printf( "ENC compressed is smaller ch_escape = %02X / ch_st_escape_1 = %02X / ch_st_escape_2 = %02X / ch_st_escape_3 = %02X\n",
               denc->ch_escape, denc->ch_st_escape_1, denc->ch_st_escape_2, denc->ch_st_escape_3 );
#endif
     /* compressed is smaller, so output till here is valid anyhow     */
      denc->ai_st_start_index = SrcBufCurrIndex;        /* start of input          */
      denc->ao_st_start = DstBufCurrIndex;        /* start of output         */
      denc->bo_st_compressed = COMPRESSED;     /* state transp / compr    */
      denc->ch_st_escape_1 = denc->ch_st_escape_2;  /* escape character   */
      denc->us_st_codews = denc->uscodews_d;   /* save C2 no of bits codw */
      denc->i_st_shift_c = denc->i_shift_c;    /* shift-count             */
      denc->i_st_shift_v = denc->i_shift_v;    /* shift-value             */
      denc->i_add_transparent = 0;             /* add to transparent len  */
      if (SrcBuf[denc->ai_st_start_index] == denc->ch_st_escape_2)  /* escape in da  */
        denc->i_add_transparent = 1;           /* add to transparent len  */
//      if (!((DstBufCurrIndex >= dcdf->aouta) && (DstBufCurrIndex <= dcdf->aoute)))
//        return;				// is an error !
//      goto pecco76;
      break;
    }

    if(iu1 > (iu2 + 2))			   /* transparent IS smaller */
    {
      /* ignore last output                                               */

      DstBufCurrIndex = denc->ao_st_start;        /* restore position output */
      denc->uscodews_d = denc->us_st_codews;   /* restore C2 no bits codw */
      if(denc->bo_st_compressed == COMPRESSED)  /* state transp / compr    */
      {
        denc->i_st_shift_v |=
         (((int) CODE_ETM & 0xFF) << denc->i_st_shift_c);  /* get new */
        denc->i_st_shift_c = (char) (denc->i_st_shift_c + denc->uscodews_d);  /* add bits              */
        do
        {
          if(DstBufCurrIndex >= DstBufTopIndex)		// error
          {
            DBG_PRT(("Error 8\n");)
            return;
          }
          DstBuf[DstBufCurrIndex++] = (char) denc->i_st_shift_v;   /* insert character        */
          denc->i_st_shift_v >>= VAL_N3;       /* shift result            */
          denc->i_st_shift_c -= VAL_N3;        /* remove bits             */
        }while ((char) denc->i_st_shift_c > 0);
      }

      au1 = denc->ai_st_start_index;               /* only last part input    */
      while(au1 < SrcBufCurrIndex)
      {
        if(DstBufCurrIndex >= DstBufTopIndex)	// error
        {
          DBG_PRT(("Error 9\n");)
          return;
        }
        DstBuf[DstBufCurrIndex++] = SrcBuf[au1];   /* insert character        */
        if (SrcBuf[au1] == denc->ch_st_escape_1)
        {
          if(DstBufCurrIndex >= DstBufTopIndex)	// error
          {
            DBG_PRT(("Error 10\n");)
            return;
          }
          DstBuf[DstBufCurrIndex++] = CODE_EID;   /* insert character        */
          denc->ch_st_escape_1 += ESCAPE_MOD;  /* modify escape character */
        }
        au1++;                                 /* increment input         */
      }
      denc->bo_compressed = UNCOMPRESSED;      /* state transp / compr    */
//      if (!((DstBufCurrIndex >= dcdf->aouta) && (DstBufCurrIndex <= dcdf->aoute)))
//        return;				// is an error !
    }
    break;				// leave loop always
  } // inner (output) FOR

//pecco76:                                 /* character output done   */
  //--------------------------------------------------------
  // add character to tree if requested
  //--------------------------------------------------------
  if (denc->bo_add_tree != DONT_ADD_TREE)	// add character to tree
  {
    isu1 = denc->ispostree; // ADDED 6.7.2001   /* get position found      */

//    denc->islastpos = isu1;                  /* save position found     */
    denc->addic2[(denc->isnextfree*DIC2_ELEN)+CHVAL_INDEX] =
      SrcBuf[SrcBufCurrIndex];
    denc->addic2[(denc->isnextfree*DIC2_ELEN)+ISCHUP_INDEX] = isu1;
    denc->addic2[(denc->isnextfree*DIC2_ELEN)+ISCHDOWN_INDEX] = UNUSED;
    if (isu1 < VAL_N4)
    {
      isu2 = denc->ddic1[isu1];
      denc->ddic1[isu1] = denc->isnextfree; // ADDED 9.7.2001
    }
    else
    {
      isu2 = denc->addic2[(isu1*DIC2_ELEN)+ISCHDOWN_INDEX];
      denc->addic2[(isu1*DIC2_ELEN)+ISCHDOWN_INDEX] = denc->isnextfree; // ADDED 9.7.2001
    }
    denc->addic2[(denc->isnextfree*DIC2_ELEN)+ISCHNEXT_INDEX] = isu2;
// The following put ahead into IF clause; 9.7.2001
//  if (isu1 < VAL_N4)
//    ENC_DIC1(denc)[isu1] = ENC_NEXTFREE(denc);
//  else
//    ENC_ADDIC2(denc)[(isu1*DIC2_ELEN)+ISCHDOWN_INDEX] = ENC_NEXTFREE(denc);

   /* compute next free entry                                          */
    denc->isnextfree++;
    if (denc->isnextfree >= denc->iscwthreshold)
    {
      /* compare if number of codewords P1 reached                      */
      if (denc->uscodews_e < (char) dcdf->ul_param_1)
      {
        denc->uscodews_e++;
        denc->iscwthreshold <<= 1;
      }
      else
      {
        denc->bo_treefull = TREE_FULL;        /* tree is full            */
        denc->isnextfree = VAL_N5;           /* here are free entries   */
      }
    }
    //-----------------------------------------------------
    // character added to the tree, check if tree filled
    //-----------------------------------------------------
    if(denc->bo_treefull == TREE_FULL)       /* tree is full            */
    {
      while((denc->addic2[(denc->isnextfree*DIC2_ELEN)+ISCHDOWN_INDEX] >= 0) ||
             (denc->isnextfree == denc->ispostree))
      {
        denc->isnextfree++;
        if (denc->isnextfree >= denc->iscwthreshold)
          denc->isnextfree = VAL_N5;         /* here are free entries   */
      }
      /* remove leaf from tree                                          */
      isu1 = denc->addic2[(denc->isnextfree*DIC2_ELEN)+ISCHUP_INDEX];
      if (isu1 < VAL_N4) isu2 = denc->ddic1[isu1];
      else isu2 = denc->addic2[(isu1*DIC2_ELEN)+ISCHDOWN_INDEX];
      if(isu2 == denc->isnextfree)
      {
        if (isu1 < VAL_N5) denc->ddic1[isu1] =
          denc->addic2[(isu2*DIC2_ELEN)+ISCHNEXT_INDEX];
        else
          denc->addic2[(isu1*DIC2_ELEN)+ISCHDOWN_INDEX] =
            denc->addic2[(isu2*DIC2_ELEN)+ISCHNEXT_INDEX];
      }
      else
      {
        do
        {
          isu1 = isu2;                       /* save last entry         */
          isu2 = denc->addic2[(isu2*DIC2_ELEN)+ISCHNEXT_INDEX];
        } while (isu2 != denc->isnextfree);
        denc->addic2[(isu1*DIC2_ELEN)+ISCHNEXT_INDEX] =
          denc->addic2[(isu2*DIC2_ELEN)+ISCHNEXT_INDEX];
      }
    } // tree full if
  } // add to tree if

	                                 /* prepare next step       */
  if (denc->bo_compressed == UNCOMPRESSED)   /* state transp / compr    */
  {
    denc->ai_st_start_index = SrcBufCurrIndex;      /* start of input          */
    denc->ch_st_escape_1 = denc->ch_st_escape_2;  /* escape character */
  }
  denc->ilenstr = 1;                       /* length of string found  */
					  /* position in tree is ch  */
  denc->ispostree = (short) ((short) SrcBuf[SrcBufCurrIndex++] & 0xFF);
} // outmost FOR loop

  //--------------------------------------------------
  // all input data processed...
  //--------------------------------------------------
//  dcdf->ainpa = SrcBufCurrIndex;              /* input exhausted         */
  if(denc->bo_compressed == UNCOMPRESSED)  /* state transp / compr    */
  {
    if(denc->bo_ignore_nch == IGNORE_NEXT_CHAR)	  /* output all areas       */
    {
      dcdf->DstStartIndex = DstBufCurrIndex;            /* set output              */
      dcdf->ireturn = DEF_IRET_NORMAL;
      return;                                /* return to main program  */
    }

    if (denc->ispostree >= VAL_N5)       /* has to be compressed    */
    {
      if (denc->ilenstr <= 4)            /* length of string found  */
      {
        au1 = denc->ai_st_start_index;         /* only last part input    */
        while (au1 < SrcBufCurrIndex)
        {
          if(DstBufCurrIndex >= DstBufTopIndex)	// error
          {
            DBG_PRT(("Error 11\n");)
            return;
          }
          DstBuf[DstBufCurrIndex++] = (char) SrcBuf[au1]; /* insert character        */
          if (SrcBuf[au1] == denc->ch_st_escape_1)
          {
            if(DstBufCurrIndex >= DstBufTopIndex)	// error
            {
              DBG_PRT(("Error 12\n");)
              return;
            }
            DstBuf[DstBufCurrIndex++] = CODE_EID;   /* insert character        */
            denc->ch_st_escape_1 += ESCAPE_MOD;  /* modify escape ch  */
          }
          au1++;                           /* increment input         */
        }
        denc->bo_ignore_nch = IGNORE_NEXT_CHAR;        /* ignore next character   */
        dcdf->DstStartIndex = DstBufCurrIndex;            /* set output              */
        dcdf->ireturn = DEF_IRET_NORMAL;
        return;                                /* return to main program  */
      }
      else
      {
        denc->bo_compressed = COMPRESSED;        /* state transp / compr    */
        if(DstBufCurrIndex+1 >= DstBufTopIndex)	// error
        {
          DBG_PRT(("Error 13\n");)
          return;
        }
        DstBuf[DstBufCurrIndex++] = denc->ch_st_escape_1;   /* insert character        */
        DstBuf[DstBufCurrIndex++] = CODE_ECM;		  /* insert character        */
        denc->i_shift_c = 0;               /* nothing in buffer       */
        denc->i_shift_v = 0;               /* also no value           */
      }
    }
    else
    {                               /* compressed too long     */
      if (denc->ispostree >= 0)
      {
        if(DstBufCurrIndex >= DstBufTopIndex)		// error
        {
          DBG_PRT(("Error 14\n");)
          return;
        }
        DstBuf[DstBufCurrIndex++] = (char) denc->ispostree;   /* insert character        */
        if (denc->ispostree == ((int) denc->ch_st_escape_2 & 0xFF))
        {
          if(DstBufCurrIndex >= DstBufTopIndex)	// error
          {
            DBG_PRT(("Error 15\n");)
            return;
          }
          DstBuf[DstBufCurrIndex++] = CODE_EID;   /* insert character        */
        }
        denc->bo_ignore_nch = IGNORE_NEXT_CHAR;   /* ignore next character   */
      }
      dcdf->DstStartIndex = DstBufCurrIndex;            /* set output              */
      dcdf->ireturn = DEF_IRET_NORMAL;
      return;                                /* return to main program  */
    }
  }

  if(denc->ispostree >= 0)			// output from tree found
  {
#ifdef TRACEHL1
     printf( "ENC pecco80 output last char ispostree = %04X\n", denc->ispostree );
#endif

     /* check if receiver knows codeword size                            */
    DstBufCurrIndex = enc_checkcw(denc,DstBuf,DstBufTopIndex,DstBufCurrIndex);
    if(DstBufCurrIndex < 0)		// error occured
    {
      DBG_PRT(("Error 16\n");)
      return;		
    }
    isu1 = denc->ispostree;                  /* get position found      */
    if(isu1 < VAL_N4) isu1 += VAL_N6;       /* first values control    */
    denc->i_shift_v |= (((int) isu1 & 0xFFFF) << denc->i_shift_c);  /* get new bits        */
    denc->i_shift_c = (char) (denc->i_shift_c + denc->uscodews_e);     /* add bits                */
    do
    {
      if(DstBufCurrIndex >= DstBufTopIndex)	// error
      {
        DBG_PRT(("Error 17\n");)
        return;
      }
      DstBuf[DstBufCurrIndex++] = (char) denc->i_shift_v;   /* insert character        */
      denc->i_shift_v >>= VAL_N3;            /* shift result            */
      denc->i_shift_c -= VAL_N3;             /* remove bits             */
    } while (denc->i_shift_c >= VAL_N3);
    denc->bo_ignore_nch = IGNORE_NEXT_CHAR;    /* ignore next character   */
  }
  //---------------------------------------------------------
  // check if still temporary bits stored. If so, output them
  //---------------------------------------------------------
  if(denc->i_shift_c != 0)                  /* if output to store      */
  {
    denc->i_shift_v |= (((int) CODE_FLUSH & 0xFF) << denc->i_shift_c);  /* get new bi  */
    denc->i_shift_c = (char) (denc->i_shift_c + denc->uscodews_d);   /* add bits                */
    do
    {
      if(DstBufCurrIndex >= DstBufTopIndex)	// error
      {
        DBG_PRT(("Error 18, DstBufCurrIndex = %d, DstBufTopIndex = %d\n",
		 DstBufCurrIndex, DstBufTopIndex);)
        DBG_PRT(("ENC_SHIFT_C = %d\n",denc->i_shift_c);)
        return;
      }
      DstBuf[DstBufCurrIndex++] = (char) denc->i_shift_v;   /* insert character        */
      denc->i_shift_v >>= VAL_N3;          /* shift result            */
      denc->i_shift_c -= VAL_N3;           /* remove bits             */
    }while ((char) denc->i_shift_c > 0);
    denc->i_shift_c = 0;                   /* nothing stored          */
  }
  dcdf->DstStartIndex = DstBufCurrIndex;            /* set output              */
  dcdf->ireturn = DEF_IRET_NORMAL;
  return;                                /* return to main program  */
}
//=====================================================================
/**
*  Add character to decompression tree. Used for decompression only.
*/
static  void  DecAddToTree(DDEC* ddec,DCDR* dcdf,
				      short isu2)
{
  short isu3;

//pdcco64:                                 /* add to tree             */
  ddec->addic2[ddec->isnextfree*DIC2_ELEN+CHVAL_INDEX]    = ddec->savedInpByte;
  ddec->addic2[ddec->isnextfree*DIC2_ELEN+ISCHUP_INDEX]   = ddec->ispostree;
  ddec->addic2[ddec->isnextfree*DIC2_ELEN+ISCHDOWN_INDEX] = UNUSED;
  ddec->addic2[ddec->isnextfree*DIC2_ELEN+ISCHNEXT_INDEX] = isu2;

  if(ddec->ispostree < VAL_N5)
    ddec->ddic1[ ddec->ispostree ] = ddec->isnextfree;
  else
    ddec->addic2[ddec->ispostree*DIC2_ELEN+ISCHDOWN_INDEX] = ddec->isnextfree;

     /* compute next free entry                                          */
  ddec->isnextfree++;
  if(ddec->isnextfree >= ddec->iscwthreshold)
  {
    /* compare if number of codewords P1 reached                      */
    if(ddec->uscodews_d < (char) dcdf->ul_param_1)
    {
      ddec->uscodews_d++;
      ddec->iscwthreshold <<= 1;
    }
    else
    {
      ddec->bo_treefull = TREE_FULL;       /* tree is full            */
      ddec->isnextfree = VAL_N5;           /* here are free entries   */
    }
  }
  if(ddec->bo_treefull == TREE_FULL)       /* tree is full            */
  {
    while((ddec->addic2[ddec->isnextfree*DIC2_ELEN+ISCHDOWN_INDEX] >= 0) ||
          (ddec->isnextfree == ddec->iswork1))
    {
      ddec->isnextfree++;
      if(ddec->isnextfree >= ddec->iscwthreshold)
        ddec->isnextfree = VAL_N5;         /* here are free entries   */
    }
    /* remove leaf from tree                                          */
    isu2 = ddec->addic2[ddec->isnextfree*DIC2_ELEN+ISCHUP_INDEX];
    if (isu2 < VAL_N5)
      isu3 = ddec->ddic1[isu2];
    else
      isu3 = ddec->addic2[isu2*DIC2_ELEN+ISCHDOWN_INDEX];

    if (isu3 == ddec->isnextfree)
    {
      if(isu2 < VAL_N5)
        ddec->ddic1[isu2] = ddec->addic2[isu3*DIC2_ELEN+ISCHNEXT_INDEX];
      else
        ddec->addic2[isu2*DIC2_ELEN+ISCHDOWN_INDEX] =
              ddec->addic2[isu3*DIC2_ELEN+ISCHNEXT_INDEX];
    }
    else
    {
      do
      {
        isu2 = isu3;                       /* save last entry         */
        isu3 = ddec->addic2[isu3*DIC2_ELEN+ISCHNEXT_INDEX];
      }while (isu3 != ddec->isnextfree);
      ddec->addic2[isu2*DIC2_ELEN+ISCHNEXT_INDEX] =
        ddec->addic2[isu3*DIC2_ELEN+ISCHNEXT_INDEX];
    }
  }
  ddec->ispostree = ddec->iswork1;         /* add to this tree later  */
}
//============================================================
// Return: 1 -> to main, 0 -> continue, -1 -> to transparent
/**
*  Decompresses (really) compressed input data until either end of input or
*  switch to transparent mode is encountered. Used for decompression only.
*/
static  int DecCompressed(DDEC* ddec, DCDR* dcdf)
{
  int iu1;
  short isu1;
  int au1;
  int au2;
//  BIT8PTR au1;
//  BIT8PTR au2;
//----------------------------------------------------
  //---------------------------------------------------------------
  // Compressed data processing loop
  //---------------------------------------------------------------
  for(;;)
  {
    if(dcdf->SrcStartIndex >= dcdf->SrcEndIndex)	// End of source data
    {
      if(ddec->i_shift_c != 0)             /* still input stored      */
        dcdf->ireturn = DEF_IRET_INVDA;    /* message error           */
      else dcdf->bo_sr_flush = TRUE;       /* set FLUSH as input      */
      return(1);                           /* return to main-prog     */
    }
    ddec->i_shift_v |=
     (((int) (dcdf->SrcBuf[dcdf->SrcStartIndex++]) & 0xFF)
        << ddec->i_shift_c);  /* get new b */
    ddec->i_shift_c += VAL_N3;               /* add bits                */
    if ((short) ddec->i_shift_c < ddec->uscodews_e)
      continue;			// compressed loop
    ddec->i_shift_c = (char) (ddec->i_shift_c - ddec->uscodews_e);     /* subtract bits           */
    isu1 = (short) (ddec->i_shift_v & ((1 << ddec->uscodews_e) - 1));  /* get val */
    ddec->i_shift_v >>= ddec->uscodews_e;    /* shift value             */
    ddec->ilenssave = ddec->ilenstr;         /* string length           */
//  -----------------------------------------------------------------
    if(isu1 >= VAL_N5)        /* in dictinary part 2     */
    {
      ddec->iswork1 = isu1;                    /* save value for later    */
      if (isu1 != ddec->isnextfree)	  /* check if undefined  */
      {
                                          /* is not undefined value  */
        if((ddec->bo_treefull != TREE_FULL)   /* tree not full           */
             && (isu1 > ddec->isnextfree))
        {
          dcdf->ireturn = DEF_IRET_INVDA;        /* message error           */
          return(1);                              /* report error            */
        }
//        ddec->awork1 = (BIT8 *) (ddec + 1) + CDR_PAR2(dcdf);
	ddec->aindex1 = (short) (dcdf->ul_param_2+1);	// set to end (+1 ?)
        while (isu1 >= VAL_N5)
        {
//          *(--ddec->awork1)=
          ddec->awork1[--ddec->aindex1]=
            (char) (ddec->addic2[isu1*DIC2_ELEN+CHVAL_INDEX]);
          isu1 = ddec->addic2[isu1*DIC2_ELEN+ISCHUP_INDEX];
        }
//        *(--ddec->awork1) = (BIT8) isu1;        /* last character          */
        ddec->awork1[--ddec->aindex1] = (char) isu1;        /* last character          */
        ddec->savedInpByte = (char) isu1;            /* save character          */
        /* output decoded string                                            */
//        au1 = (BIT8 *) (ddec + 1) + CDR_PAR2(dcdf);
        au1 = (int) (dcdf->ul_param_2 + 1);  /* end of output    */
//        au2 = ddec->awork1;
        au2 = ddec->aindex1;
        ddec->ilenstr = (short) (au1 - au2);               /* current string length   */
        do
        {
          if (ddec->awork1[au2] == ddec->ch_escape)
             ddec->ch_escape += ESCAPE_MOD;       /* modify escape character */
          au2++;
        } while (au2 < au1);
        if (dcdf->DstStartIndex >= dcdf->DstEndIndex)
        {
          dcdf->ireturn = DEF_IRET_OVERFLOW;  /* message error           */
          return(1);                             /* needs more output space */
        }
//pdcco48:                                 /* copy source to output   */
        iu1 = dcdf->DstEndIndex - dcdf->DstStartIndex;         /* compute space           */
//        au1 = (BIT8 *) (ddec + 1) + CDR_PAR2(dcdf);  /* end of output    */
        au1 =  (int) (dcdf->ul_param_2 + 1);  /* end of output    */
//        if (iu1 > (au1 - ddec->awork1)) iu1 = au1 - ddec->awork1;
        if (iu1 > (au1 - ddec->aindex1)) iu1 = au1 - ddec->aindex1;
//        memcpy(CDR_DSTBUF(dcdf)+CDR_DST_STRT(dcdf),
//               DEC_AWORK1(ddec)+DEC_AINDEX1(ddec), iu1 );  /* copy output           */
        memcpy(dcdf->DstBuf+dcdf->DstStartIndex,ddec->awork1+ddec->aindex1,iu1);

        dcdf->DstStartIndex += iu1;                      /* adjust output           */
//        ddec->awork1 += iu1;                     /* adjust source           */
        ddec->aindex1 += iu1;                     /* adjust source           */
//        if(ddec->awork1 < au1)		// not all data copied !!
        if(ddec->aindex1 < au1)		// not all data copied !!
        {
          dcdf->ireturn = DEF_IRET_OVERFLOW;  /* message error           */
          return(1);                            /* needs more output space */
        }
        if(ddec->ispostree >= 0) return(0);	// already had a tree
        ddec->ispostree = ddec->iswork1;       /* add to this tree later  */
        continue;				// next compressed
      } // undefined IF
      isu1 = ddec->ispostree;                  /* get previous value      */
      if(isu1 < 0)                          /* value undefined         */
      {
        dcdf->ireturn = DEF_IRET_INVDA;        /* message error           */
        return(1);                            /* report error            */
      }
//      ddec->awork1 = (BIT8 *) (ddec + 1) + CDR_PAR2(dcdf) - 1;
      ddec->aindex1 = (int) dcdf->ul_param_2;
      while (isu1 >= VAL_N5)
      {
//        *(--ddec->awork1) = (BIT8) (DEC_ADDIC2(ddec)[isu1*DIC2_ELEN+CHVAL_INDEX]);
        ddec->awork1[--ddec->aindex1] =
          (char) (ddec->addic2[isu1*DIC2_ELEN+CHVAL_INDEX]);
        isu1 = ddec->addic2[isu1*DIC2_ELEN+ISCHUP_INDEX];
      }
//      *(--ddec->awork1) = (BIT8) isu1;        /* last character          */
      ddec->awork1[--ddec->aindex1] = (char) isu1;        /* last character          */
//      *((BIT8 *) (ddec + 1) + CDR_PAR2(dcdf) - 1) =
//        (BIT8) isu1;
      ddec->awork1[dcdf->ul_param_2] = (char) isu1;

      ddec->savedInpByte = (char) isu1;            /* save character          */
       /* output decoded string                                            */
//      au1 = (BIT8 *) (ddec + 1) + CDR_PAR2(dcdf);  /* end of output    */
      au1 = (int) (dcdf->ul_param_2+1);		  /* end of output    */
//      au2 = ddec->awork1;
      au2 = ddec->aindex1;
      ddec->ilenstr = (short) (au1 - au2);         /* current string length   */
      do
      {
//        if (*au2 == DEC_CH_ESC(ddec))
        if (ddec->awork1[au2] == ddec->ch_escape)
          ddec->ch_escape += ESCAPE_MOD;       /* modify escape character */
        au2++;
      }while (au2 < au1);
      if (dcdf->DstStartIndex >= dcdf->DstEndIndex)
      {
	dcdf->ireturn = DEF_IRET_OVERFLOW;  /* message error           */
        return(1);                               /* needs more output space */
      }
//pdcco48:                                 /* copy source to output   */
      iu1 = dcdf->DstEndIndex - dcdf->DstStartIndex;         /* compute space           */
//      au1 = (BIT8 *) (ddec + 1) + CDR_PAR2(dcdf);  /* end of output    */
      au1 = (int) (dcdf->ul_param_2 + 1);	  /* end of output    */
//      if (iu1 > (au1 - ddec->awork1)) iu1 = au1 - ddec->awork1;
      if (iu1 > (au1 - ddec->aindex1)) iu1 = au1 - ddec->aindex1;
//      memcpy(CDR_DSTBUF(dcdf)+CDR_DST_STRT(dcdf),
//             DEC_AWORK1(ddec)+DEC_AINDEX1(ddec), iu1 );  /* copy output           */
      memcpy(dcdf->DstBuf+dcdf->DstStartIndex,ddec->awork1+ddec->aindex1,iu1);

      dcdf->DstStartIndex += iu1;                      /* adjust output           */
//      ddec->awork1 += iu1;                     /* adjust source           */
      ddec->aindex1 += iu1;                     /* adjust source           */
//      if(ddec->awork1 < au1)		// not all data copied !!
      if(ddec->aindex1 < au1)		// not all data copied !!
      {
	dcdf->ireturn = DEF_IRET_OVERFLOW;  /* message error           */
        return(1);                                /* needs more output space */
      }
      if(ddec->ispostree >= 0) return(0);	// already had a tree
      ddec->ispostree = ddec->iswork1;       /* add to this tree later  */
      continue;				// compressed process loop
    } // dictionary part 2 if
//   --------------------------------------------------------------------
    if(isu1 >= VAL_N6)	        /* in dictinary part 1     */
    {
      isu1 -= VAL_N6;
      if(isu1 == ((int) ddec->ch_escape & 0xFF))
        ddec->ch_escape += ESCAPE_MOD;         /* modify escape character */
      ddec->iswork1 = isu1;                    /* save value for later    */
      if (dcdf->DstStartIndex >= dcdf->DstEndIndex)	// no buffer space
      {
	dcdf->ireturn = DEF_IRET_OVERFLOW;  /* message error           */
        return(1);                              /* needs more output space */
      }
//Entry2:                                 /* space in output area    */
      ddec->savedInpByte = (char) ddec->iswork1;   /* save character          */
      dcdf->DstBuf[dcdf->DstStartIndex++] = ddec->savedInpByte;          /* output character        */
      ddec->ilenstr = 1;                       /* set next length tree    */
      if(ddec->ispostree >= 0) return(0);	// exit inner for
      ddec->ispostree = ddec->iswork1;       /* add to this tree later  */
      continue;				// compressed process loop
    } // dictionary part 1 IF
//  ----------------------------------------------------------------
  /* control codeword found                                           */
    if (isu1 == CODE_SETUP)
    {
      if (ddec->uscodews_e >= (char) dcdf->ul_param_1)
      {
        dcdf->ireturn = DEF_IRET_INVDA;      /* message error           */
        return(1);                            /* report error            */
      }
      ddec->uscodews_e++;                    /* adjust codeword size    */
      continue;		// compressed process loop
    }
    if (isu1 == CODE_FLUSH)                /* FLUSH found             */
    {
      if(ddec->i_shift_v != 0)            /* shift value             */
      {
//        printf( "UUUU ETM bits not zero\n" );
        dcdf->ireturn = DEF_IRET_INVDA;      /* message error           */
        return(1);                            /* report error            */
      }
      ddec->i_shift_c = 0;                   /* no bits stored          */
      continue;			// compressed process loop
    }
    if(isu1 != CODE_ETM)
    {
//      printf( "UUUU not ETM found\n" );
      dcdf->ireturn = DEF_IRET_INVDA;      /* message error           */
      return(1);                            /* report error            */
    }
    if (ddec->i_shift_v != 0)              /* shift value             */
    {
//      printf( "UUUU ETM bits not zero\n" );
      dcdf->ireturn = DEF_IRET_INVDA;      /* message error           */
      return(1);                            /* report error            */
    }
#ifdef TRACEHL1
    printf( "DEC pdcco00 continue transparent\n" );
#endif
   /* UUUU */
    ddec->icont = DEF_C_DCBU00;              /* set next input / cont   */
    return(-1);                            /* get next input transpar */
  } // COMPRESSED PROCESSING LOOP
}
//============================================================
// Return: 1 -> to main, 0 -> not found in tree, -1 -> found in tree

/**
*  Decompresses 'transparent' compressed input data until either end of input 
*  or switch to normal compressed mode is encountered. Used for decompression
*  only.
*/
static  int  DecTransparent(DDEC* ddec, DCDR* dcdf,
				short* pTmpPos)
{
  int i;

  short isu2;
  short isu3;

//  ------------------------------------------------------------------
//  Transparent processing loop
//  ------------------------------------------------------------------
  for(;;)
  {
    if (dcdf->SrcStartIndex >= dcdf->SrcEndIndex)  /* no more input  */
    {
      dcdf->bo_sr_flush = TRUE;            /* set FLUSH as input      */
      return(1);                            /* return to main-prog     */
    }
    if(dcdf->DstStartIndex >= dcdf->DstEndIndex)
       return(1);  /* nothing free in output  */
    ddec->savedInpByte =
      dcdf->SrcBuf[dcdf->SrcStartIndex++];/* get next character */
    //------------------------------------------------
    // check / process escape character
    //------------------------------------------------
    if(ddec->savedInpByte != ddec->ch_escape)	// is not escape, store
      dcdf->DstBuf[dcdf->DstStartIndex++] = ddec->savedInpByte;
    else
    {
      if(dcdf->SrcStartIndex >= dcdf->SrcEndIndex)// data exhausted but in escape...
      {
        dcdf->ireturn = DEF_IRET_UNDERRUN;	// is an error (??)
        return(1);
      }
      if(dcdf->SrcBuf[dcdf->SrcStartIndex] == CODE_EID)
      {
        ddec->ch_escape += ESCAPE_MOD;         /* modify escape character */
        dcdf->DstBuf[dcdf->DstStartIndex++] = ddec->savedInpByte;
        dcdf->SrcStartIndex++;                         /* next input              */
      }
      else if(dcdf->SrcBuf[dcdf->SrcStartIndex] == CODE_ECM) // ECM found
      {
        dcdf->SrcStartIndex++;                      /* next input              */
        ddec->i_shift_c = 0;                     /* no bits stored          */
        ddec->i_shift_v = 0;   // ADDED 6.7.2001  /* shift value             */
        ddec->icont = DEF_C_DCCO00;              /* set next input / cont   */
        i = DecCompressed(ddec, dcdf);
        if(i == 1) return(1);
        if(i == -1) continue;	               /* get next input transpar */
        return(-1);				// process tree
      }
      else // not CODE_EID or CODE_ECM, check others
      {
	//---------------------------------------------------------------
        // Must be Code Reset, else Error occured; ADDED 9.7.2001
	//---------------------------------------------------------------
        if(dcdf->SrcBuf[dcdf->SrcStartIndex] != CODE_RESET)    /* not Code Reset */
        {
          dcdf->ireturn = DEF_IRET_INVDA;        /* message error           */
          return(1);                                /* report error            */
        }
        dcdf->SrcStartIndex++;                           /* next input              */
        for(i = 0;i < VAL_N4;i++) ddec->ddic1[i] = UNUSED;
        ddec->isnextfree = VAL_N5;             /* here are free entries   */
        ddec->uscodews_d = VAL_N3 + 1;         /* C2 decoder number of bi */
        ddec->uscodews_e = VAL_N3 + 1;         /* C2 decoder number of bi */
        ddec->iscwthreshold = VAL_N4 * 2;         /* C3 threshold code w s c */
        ddec->ispostree  = UNUSED;             /* position in tree        */
        ddec->bo_treefull = TREE_NOT_FULL;	 /* tree not full           */
        ddec->ch_escape = 0;                    /* clear escape character */
        continue;     	                         /* get next input transpar */
      }
    }
//  ----------------------------------------------------------------  
//pdcbuYY:                                 /* adjust tree             */
    if (ddec->ispostree < 0)               /* no tree before          */
    {
      ddec->ispostree =
        (short)((short) ddec->savedInpByte & 0xFF);       /* new tree from here      */
      ddec->ilenstr = 1;                     /* new string length       */
      continue;	               /* get next input transpar */
    }
    if (ddec->ilenstr >= (short) dcdf->ul_param_2)  /* maximum string reached */
    {
      ddec->ispostree =
        (short)((short) ddec->savedInpByte & 0xFF);/* start from here         */
      ddec->iswork1 = UNUSED;                /* start from new          */
      ddec->ilenstr = 0;                     /* set string length       */
      continue;	               /* get next input transpar */
    }
    if (ddec->ispostree < VAL_N5)
      isu2 = ddec->ddic1[ ddec->ispostree ];
    else
      isu2 = ddec->addic2[ddec->ispostree*DIC2_ELEN+ISCHDOWN_INDEX];
    isu3 = isu2;                             /* start here              */
    while (isu3 >= VAL_N5)
    {
      if(ddec->savedInpByte ==
         (char) (ddec->addic2[isu3*DIC2_ELEN+CHVAL_INDEX]))
        break;
      isu3 = ddec->addic2[isu3*DIC2_ELEN+ISCHNEXT_INDEX];
    }
    ddec->iswork1 =
     (short)((short) ddec->savedInpByte & 0xFF);   /* start from new          */
    ddec->ilenstr++;                         /* increment string length */
    if (isu3 >= 0)	                    /* found in tree           */
    {
      ddec->ispostree = isu3;                /* start from this later   */
      continue;	               /* get next input transpar */
    }
//    break;		// not found in tree ??
    pTmpPos[0] = isu2;
    return(0);		// not found in tree ??
  } // Transparent FOR
}
//============================================================
/**
* This method gets a structure containing data input/output buffer pointers and
* current decompress state structure (parameters, wordlength, dicitionary etc).
* It processes data from the input buffer and decompresses them according to 
* the current state from the decompress state structure and outputs the data to
* the output buffer.
*
* @param dcdf Pointer to decompress parameter structure
*/
extern "C" void CdrDec(HMEM_CTX_DEF DCDR* dcdf)
{
  /* Declare local variables.                                         */
  DDEC* ddec;                            /* fields for decode       */
  short isu2;                          /* working variable        */
  short isu3;                          /* working variable        */
  int   iu1;
  int i;
  char	c1;
  short pTmpPos[1];

  //---------------------------------------------------
  // Distribute according to function
  //---------------------------------------------------
  switch(dcdf->ifunc)
  {
    case DEF_IFUNC_CONT:
      break;

    case DEF_IFUNC_START:
//      Retstat = (*dcdf->uaux)( DEF_AUX_MEMGET, &ddec,
//                 (int) (sizeof(DDEC) +
//		 CDR_PAR2(dcdf) +
//                 ((1 << CDR_PAR1(dcdf)) - VAL_N5) * sizeof(DDIC2)) );
                                            /* get memory              */
//      Retstat = (*dcdf->uaux)( DEF_AUX_MEMGET, &ddec,
//                 (int) (sizeof(DDEC) +
//		  CDR_PAR2(dcdf) +
//                 ((1 << CDR_PAR1(dcdf)) - VAL_N5) * DIC2_ELEN * 2));
//
//      ddec = (DDEC * ) malloc((int) (sizeof(DDEC) +
//		           CDR_PAR2(dcdf) +
//                 ((1 << CDR_PAR1(dcdf)) - VAL_N5) * DIC2_ELEN * 2));

      ddec = (DDEC * )
               ((void *) BIT8_ARRAY_ALLOC((ds__hmem *) HMEM_CTX_REF,
			        	  sizeof(DDEC)));
      if(ddec == NULL)
      {
        dcdf->ireturn = DEF_IRET_ERRAU;        /* message error           */
        return;                                /* return to main-prog     */
      }
      memset(ddec, 0, sizeof(DDEC));         /* clear structure          */
      for( iu1 = 0; iu1 < VAL_N4; iu1++ )
        ddec->ddic1[iu1] = UNUSED;

      ddec->addic2 = (short*)
        BIT16_ARRAY_ALLOC((ds__hmem *) HMEM_CTX_REF,
                          DIC2_ELEN*((1<<dcdf->ul_param_1) -VAL_N5));
      if(ddec->addic2 == NULL)
      {
        FREE_ARRAY((ds__hmem *) HMEM_CTX_REF,ddec);
        dcdf->ireturn = DEF_IRET_ERRAU;        /* message error           */
        return;                                /* return to main-prog     */
      }
      ddec->awork1 = (char*)		// get working buffer
        BIT8_ARRAY_ALLOC((ds__hmem *) HMEM_CTX_REF,
			 (int) (dcdf->ul_param_2+1));
      if(ddec->awork1 == NULL)
      {
        FREE_ARRAY((ds__hmem *) HMEM_CTX_REF,ddec->addic2);
	FREE_ARRAY((ds__hmem *) HMEM_CTX_REF,ddec);
        dcdf->ireturn = DEF_IRET_ERRAU;        /* message error           */
        return;                                /* return to main-prog     */
      }

                                            /* addr dictionary part 2  */
      ddec->isnextfree = VAL_N5;               /* here are free entries   */
      ddec->uscodews_d = VAL_N3 + 1;           /* C2 decoder number of bi */
      ddec->uscodews_e = VAL_N3 + 1;           /* C2 decoder number of bi */
      ddec->iscwthreshold = VAL_N4 * 2;        /* C3 threshold code w s c */
      ddec->ispostree = UNUSED;                /* position in tree        */
      ddec->icont = DEF_C_DCBU00;              /* set next input / cont   */
//      dcdf->bo_compressed = TRUE;              /* always compressed       */
      dcdf->pdec = ddec;                 /* store address of fields */
      dcdf->ifunc = DEF_IFUNC_CONT;            /* next call continue      */
      dcdf->ireturn = DEF_IRET_NORMAL;         /* call subroutine again   */
      return;                                  /* return to main program  */

    case DEF_IFUNC_END:
      FREE_ARRAY((ds__hmem *) HMEM_CTX_REF,dcdf->pdec->addic2);
      FREE_ARRAY((ds__hmem *) HMEM_CTX_REF,dcdf->pdec->awork1);
      FREE_ARRAY((ds__hmem *) HMEM_CTX_REF,dcdf->pdec);
      dcdf->ireturn = DEF_IRET_END;            /* all done                */
      return;                                  /* return to main-prog     */

    default:
//      printf( "DEC invalid function %d\n", CDR_FUNC(dcdf) );
      dcdf->ireturn = DEF_IRET_ERRAU;        /* message error           */
      return;
  } // switch

  //---------------------------------------------------
  // Start Decoding
  //---------------------------------------------------
  ddec = dcdf->pdec;              /* get address of fields   */
  dcdf->bo_sr_flush = FALSE;               /* not yet end of record   */
#ifdef TRACEHL1
  printf( "DEC start ispostree = %04X / escape = %02X\n", ddec->ispostree, ddec->ch_escape );
#endif
  //---------------------------------------------------
  // Outer Decoder Loop
  //---------------------------------------------------
  for(;;)	// outmost FOR
  {
    c1 = 0;				// assume transparent continue
    switch(ddec->icont)
    {
      case DEF_C_DCBU00:		// to transparent
        i = DecTransparent(ddec,dcdf,pTmpPos);
        if(i == 1) return;		// error/out of buffer space
        if(i == 0)			// not found in tree, must add
        {
          isu2 = pTmpPos[0];
          ddec->ilenstr = 1;         /* set new string length   */
          DecAddToTree(ddec,dcdf,isu2);
          continue;				// to outmost FOR
        }
        break;				// found in tree

      case DEF_C_DCCO00:
        i = DecCompressed(ddec, dcdf);
        if(i == 1) return;
	if(i != 0)			// continue Transparent
        {
          i = DecTransparent(ddec,dcdf,pTmpPos);
          if(i == 1) return;			// error/out of buffer space
          if(i == 0)				// not found in tree, must add
          {
            /* not found in tree                          */
            isu2 = pTmpPos[0];
            ddec->ilenstr = 1;               /* set new string length   */
            DecAddToTree(ddec,dcdf,isu2);
            continue;				// to outmost FOR
          }
        }
	break;
    } // switch
    //-------------------------------------------------------------------
    if (ddec->ilenssave >= (int) dcdf->ul_param_2)  /* maximum string reach */
    {
      if (ddec->iswork1 == ddec->isnextfree)
      {
        /* make this entry valid                                        */
        ddec->iswork1 = UNUSED;
      }
      else
      {
        ddec->ispostree = ddec->iswork1;         /* add to this tree later  */
        continue;
      }
    }

    /* search if already in tree                                        */
    if (ddec->ispostree < VAL_N5)
      isu2 = ddec->ddic1[ ddec->ispostree ];
    else
      isu2 = ddec->addic2[ddec->ispostree*DIC2_ELEN+ISCHDOWN_INDEX];
    isu3 = isu2;                             /* start here              */

    c1 = 0;
    while(isu3 >= VAL_N5)
    {
      if(ddec->savedInpByte==(char)(ddec->addic2[isu3*DIC2_ELEN+CHVAL_INDEX]))
      {
        if(ddec->iswork1 != ddec->isnextfree)
        {
          ddec->ispostree = ddec->iswork1;         /* add to this tree later  */
          c1 = 1;
          break;
        }
        dcdf->ireturn = DEF_IRET_INVDA;      /* message error           */
        return;                              /* report error            */
      }
      isu3 = ddec->addic2[isu3*DIC2_ELEN+ISCHNEXT_INDEX];
    }
    if(c1 != 0) continue;
    DecAddToTree(ddec,dcdf,isu2);
  } // outmost FOR
}

/** @} */


#endif //HL_SSL_V42BIS
// end of file ../compr/v42bis.cpp


#ifdef HL_SSL_LOG

#if (defined _WIN32) & (_MSC_VER < 1700)
#ifndef _STDINT
#define _STDINT
// MSVC lower than 17.00 does not have stdint.h, assure, all needed types are defined

typedef unsigned __int16 uint16_t;

typedef unsigned __int32 uint32_t;

typedef unsigned __int64 uint64_t;

#endif // !_STDINT
#else
#include <stdint.h>
#endif
#include <stddef.h>
#ifdef _WIN32
#define WIN32_LEAN_AND_MEAN
#include <Windows.h>
#undef WIN32_LEAN_AND_MEAN
// We suppress the warning for new initialization behavior
#pragma warning( disable : 4351 )
#else// Define system-specific HL_* defines here
#ifndef HL_UNIX
#define HL_UNIX

#if (defined __gnu_linux__) || (defined __linux__)
#define HL_LINUX
#endif

#if (defined __APPLE__) && (defined __MACH__)
#define HL_LINUX
#define HL_MACOS
#endif

#ifdef _AIX
#define HL_AIX
#define HL_BIG_ENDIAN
#endif

#ifdef __FreeBSD__
#define HL_FREEBSD
#endif

#if (defined _hpux) || (defined hpux) || (defined __hpux)
#define HL_HPUX
#define HL_BIG_ENDIAN
#endif

#if (defined sun) || (defined __sun)
#define HL_SOLARIS
#endif

#if (defined __arm__) || (defined __aarch64__)
#define HL_LINUX_ARM
#endif

#ifdef __ANDROID__
#define HL_ANDROID
#endif

#endif
#include <hob-unix01.h>
#endif
#ifdef __APPLE__
/* We get target conditionals to keep apart Mac OS, iOS and iOS simulator.
   The conditionals are TARGET_IPHONE_SIMULATOR, TARGET_OS_IPHONE and TARGET_OS_MAC.
   TARGET_IPHONE_SIMULATOR has the highest priority, TARGET_OS_MAC the lowest.
   Always test, if the conditional is 1, as they will be defined as 0, if we 
   are not compiling for the target.
   */
#include <TargetConditionals.h>
#endif

#ifdef HL_ANDROID
#include <sys/endian.h>
#endif

#include "hob-encry-1.h"
#include "hob-cert-ext.h"
#if !(defined __HOB_XSCLIB01__) && !(defined DEF_IFUNC_START)
#define __HOB_XSCLIB01__

#include <hob-xsclib01.h>  
#endif // !__HOB_XSCLIB01__
#include <stdlib.h>
#include <hob-encry-2.h>
#include "hob-ssl-intern.h"
#include <new>
#include <string.h>

/** @defgroup ssllog WSP trace support
*  This module provides a simple interface for the use of the WSP trace
*  facility.
*
*  The implementing class is a thin wrapper, that manages the task of 
*  writing the data into the appropriate structures.
*  An abstract class is used as interface to allow simple extension and
*  replacement.
*
*  @{
*  @file
*  This file provides method implementations for dsd_wsp_trace_log.
*  Additionally, it provides implementation of a C interface, that can
*  be called by the SSL module and other C code.
*  @}
*/

dsd_wsp_trace_log::dsd_wsp_trace_log(int inp_trace_lvl, bool bop_is_client, 
                                     int inp_session_nr,  
                                     BOOL (* amp_aux) ( void *vpp_userfld, int, void *, int ),
                                     void* avop_usr_field):
dsd_logger(),
dsc_trace_header(),
inc_session_trace_level(inp_trace_lvl),
inc_event_trace_lvl(0),
adsc_trace_record(),
amc_aux(amp_aux),
avoc_usr_field(avop_usr_field),
inc_next_record_index(0){
   memset(&dsc_trace_header,0,sizeof(struct dsd_wsp_trace_header));
   dsc_trace_header.imc_wtrh_sno = inp_session_nr;
   if(bop_is_client){
      memcpy(dsc_trace_header.chrc_wtrt_id+6,"CL", 2);
   } else {
      memcpy(dsc_trace_header.chrc_wtrt_id+6,"SE", 2);
   }
   dsc_trace_header.adsc_wtrh_chain = adsc_trace_record;
   memset(adsc_trace_record,0,sizeof(struct dsd_wsp_trace_record)*incc_max_records);
}
void dsd_wsp_trace_log::m_make_log_entry(const char* achp_log_tag){
   if(inc_next_record_index == 0){
      return; // No Records to log
   }
   memcpy(dsc_trace_header.chrc_wtrt_id,achp_log_tag, 6);
   inc_next_record_index--;
   adsc_trace_record[inc_next_record_index].adsc_next = NULL;
   amc_aux( avoc_usr_field, DEF_AUX_WSP_TRACE, &dsc_trace_header, 0 );
   inc_next_record_index = 0;
}
void dsd_wsp_trace_log::m_add_text_data(const char* achp_data_buf, int inp_len){
   // Check, if trace level fits and free records are available
   if((inc_event_trace_lvl & inc_session_trace_level) ==0 ||
      inc_next_record_index >= incc_max_records){
      return;
   }
   adsc_trace_record[inc_next_record_index].achc_content = const_cast<char*>(achp_data_buf);
   adsc_trace_record[inc_next_record_index].imc_length = inp_len;
   adsc_trace_record[inc_next_record_index].iec_wtrt = ied_wtrt_text;
   if(inc_next_record_index > 0){
      adsc_trace_record[inc_next_record_index-1].adsc_next = 
         &(adsc_trace_record[inc_next_record_index]);
   }
   inc_next_record_index++;
}
void dsd_wsp_trace_log::m_add_binary_data(char* achp_data_buf, int inp_len){
   // Check, if trace level fits and free records are available
   if((inc_event_trace_lvl & inc_session_trace_level) ==0 ||
      inc_next_record_index >= incc_max_records){
      return;
   }
   adsc_trace_record[inc_next_record_index].achc_content = achp_data_buf;
   adsc_trace_record[inc_next_record_index].imc_length = inp_len;
   adsc_trace_record[inc_next_record_index].iec_wtrt = ied_wtrt_data;
   if(inc_next_record_index > 0){
      adsc_trace_record[inc_next_record_index-1].adsc_next = 
         &(adsc_trace_record[inc_next_record_index]);
   }
   inc_next_record_index++;
}
void dsd_wsp_trace_log::m_event_trace_lvl(int inp_target_trace_lvl){
   inc_event_trace_lvl = inp_target_trace_lvl;
}

void dsd_wsp_trace_log::m_reload_field(BOOL (* amp_aux) ( void *vpp_userfld, int, void *, int ),
                                       void* avop_usr_field)
{
   amc_aux = amp_aux;
   avoc_usr_field = avop_usr_field;
}
dsd_wsp_trace_log::~dsd_wsp_trace_log(){}

extern "C" {
   struct dsd_logger* m_gen_wsp_tracer(HMEM_CTX_DEF int inp_trace_lvl, 
                                       int inp_is_client, 
                                       int inp_session_nr, 
                                       BOOL (* amp_aux) ( void *vpp_userfld, int, void *, int ), 
                                       void* avop_usr_field)
   {
      char* abyl_logger_buf = BIT8_ARRAY_ALLOC(HMEM_CTX_REF, sizeof(class dsd_wsp_trace_log));
      dsd_logger* adsl_return = new ((void*)abyl_logger_buf) 
         dsd_wsp_trace_log(inp_trace_lvl, (inp_is_client !=0), inp_session_nr, amp_aux, avop_usr_field);
      return adsl_return;
   }

   void m_make_log_entry(struct dsd_logger* adsp_log_inst, const char* achp_log_tag)
   {
      if(adsp_log_inst != NULL){
         adsp_log_inst->m_make_log_entry(achp_log_tag);
      }
   }
   void m_add_text_data(struct dsd_logger* adsp_log_inst, const char* achp_data_buf, int inp_len)
   {
      if(adsp_log_inst != NULL){
         adsp_log_inst->m_add_text_data(achp_data_buf, inp_len);
      }
   }
   void m_add_binary_data(struct dsd_logger* adsp_log_inst, char* achp_data_buf, int inp_len)
   {
      if(adsp_log_inst != NULL){
         adsp_log_inst->m_add_binary_data(achp_data_buf, inp_len);
      }
   }
   void m_event_trace_lvl(struct dsd_logger* adsp_log_inst, int inp_target_trace_lvl)
   {
      if(adsp_log_inst != NULL){
         adsp_log_inst->m_event_trace_lvl(inp_target_trace_lvl);
      }
   }
   void m_destroy_logger(HMEM_CTX_DEF struct dsd_logger* adsp_log_inst){
      if(adsp_log_inst != NULL){
         char* abyl_buffer_to_be_freed = (char*)adsp_log_inst;
         adsp_log_inst->~dsd_logger();
         FREE_ARRAY(HMEM_CTX_REF, abyl_buffer_to_be_freed);
      }
   }
   void m_reload_field(struct dsd_logger* adsp_log_inst,BOOL (* amp_aux) ( void *vpp_userfld, int, void *, int ), void* avop_usr_field){
      if(adsp_log_inst != NULL){
         ((dsd_wsp_trace_log*)adsp_log_inst)->m_reload_field(amp_aux, avop_usr_field);
      }
   }
}

#endif //HL_SSL_LOG
// end of file ../htrace/xs-wsp-logger.cpp

