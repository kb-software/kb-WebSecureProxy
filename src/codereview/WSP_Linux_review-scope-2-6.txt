Coverage of this document
-------------------------

The code changing reviews for "WebSecure Proxy"
include the following source paths:
-  https://linux02.hob.de/repos/nbipgw20-v23/S/	


The code review covers the changes introduced in revisions 2-6 into
the following files:

    xshusip01.cpp
    xs-gw-udp-01.cpp
    hob-htcp-int-01.h
    hob-tun01.h
    hob-hppp01.h
    xsavl03.cpp
    xiipgw08-pd-main.cpp
    hob-xbipgw08-1.h
    xiipgw08-tun.cpp
    xslnetw1.cpp
    hob-htcp-01.h
    xshpppi01.cpp
    xstuntapif.cpp
    xslunic1.cpp
    xsthlse3.cpp
    hob-xslunic1.h
    hob-gw-ppp-1.h
    hob-encry-1.h
    hob-htcp-hdr-01.h
    xiipgw08-seli.cpp
    xsclibrdp1.cpp
    xsipgw08-conf.cpp
    xshsstp01.cpp
    hob-xbipgw08-2.h
    hob-ldap01.hpp
    xshsessutil01.cpp
    xs-gw-ppp.cpp
    hob-tcpco1.hpp
    xsllog01.cpp
    nsl-tcpcomp-singthr.cpp
    xiipgw08-pd-auth.cpp
    xs-gw-l2tp.cpp
    hob-sessutil01.h
    xiipgw08-pttd.cpp
    nst-tun-dummy-1.cpp
    hob-xsclib01.h
    xsthlcl1.cpp
    xs-gw-cma1-02.cpp
    xs-encry-1.c
    hob-hsstp01.h
    xs-gw-cluster.cpp
    hob-ssl-01.h
    hob-tcpcomp-singthr.hpp
    xsldapco1.cpp
    hob-session01.h
    nbipgw19.cpp
    hob-tuntapif01.h
    xs-gw-serv-vch-icap.cpp
    hob-perf-data-1.h
    xs-htcp-hdr-01.cpp
    xs-htcp-htun-01.cpp
    nbipgw20.cpp
    xs-gw-admin.cpp
    xs-lbal-win-1.cpp
    hob-htcp-htun-01.h
    xiipgw08-tcp.cpp
    xs-htcp-01.cpp
    xiipgw08-admin.cpp
    hob-li-gw-01.h
    xs-gw-radius-01.cpp
    xiipgw08-aux.cpp
    xiipgw08-trace.cpp
    xsl-tcp-sync-01.cpp
    xiipgw08-pd-sdh.cpp

Code Review Report:
-------------------
Date: 29.01.2013
File: <see above>
Path: <see above>
Revision: 2-6
File commit date: n/a
Modified by: Mr. K. Brandst√§tter
Reviewed by: Mr. C. Wittinger
Comment: <various changes>
Review status: pass

<review-scope type="diff">
Index: SOFTWARE.HLSEC.SERDAHO1.act.txt
===================================================================
--- SOFTWARE.HLSEC.SERDAHO1.act.txt	(revision 2)
+++ SOFTWARE.HLSEC.SERDAHO1.act.txt	(revision 6)
@@ -107,9 +107,10 @@
          variables = stack, since this is used for other things when the
          structures dsd_gather_i_1 are sent or processed elsewhere.
          When the method m_hlclib01 returns, the field
-         adsc_gather_i_1_out in the structure dsd_hl_clib_1 contains the
-         output of the subroutine.
-
+         adsc_gai1_out_to_client in the structure dsd_hl_clib_1 contains
+         the output of the subroutine to be sent to the client.
+         The field adsc_gai1_out_to_server in the structure dsd_hl_clib_1
+         contains the output of the subroutine to be sent to the server.
          When the subroutine has processed input data, the corresponding
          fields achc_ginp_cur in the structure dsd_gather_i_1 are
          updated.
@@ -125,7 +126,7 @@

          When the Server-Data-Hook processes the input data, and the
          output would be more than what can be placed in the work area,
-         the following strategy should be applied:
+         the following strategy can be applied:
          The Server-Data-Hook fills the work area as far as possible. In
          the input data, it is marked by updating of the fields
          achc_ginp_cur in the structure dsd_gather_i_1 how far the input
@@ -137,7 +138,6 @@
          new work area. The Server-Data-Hook may now fill the remaining
          data into the new work area.

-         +++ not yet implemented 29.12.06 KB +++
          The Server-Data-Hook may also acquire more work areas during
          processing. These work areas may contain any data, or they may
          contain output data (including structure dsd_gather_i_1).
@@ -168,7 +168,22 @@
          boc_callrevdir are no more set by the last call to the
          Server-Data-Hook. This means, data can be saved in workareas
          over more than one call to the Server-Data-Hook.
-         +++ not yet implemented 11.08.07 KB +++
+
+         A single call to m_hlclib01() of a Server-Data-Hook should not
+         generate too many data to be sent to the client or to the
+         server. If, for example, more than ten work-areas would be
+         filled in a single call to m_hlclib01(), there would be too much
+         overhead in the WebSecureProxy to manage these work-areas.
+         Instead, a single call to m_hlclib01() should return only a part
+         of the data to be sent and should set boc_callagain, so that
+         m_hlclib01() is called again when a part of the data has already
+         been sent and freed.
+
+
+
+
+
+
          It may even be desired for Server-Data-Hooks, that the
          WebSecureProxy keeps work areas for a longer time, when input or
          output (or nothing of that) have already been processed.
@@ -179,16 +194,8 @@
          aux-callback-routine with either DEF_AUX_MARK_WORKAREA_INC or
          DEF_AUX_MARK_WORKAREA_DEC as second parameter. The third address
          is some pointer internal to any of the used work areas or in any
-         of the input buffers.
-
+         of the input buffers.

-
-
-
-
-         +++ not yet implemented 29.12.06 KB +++
-         +++ not yet implemented 11.08.07 KB +++
-
          It is also possible, that the Server-Data-Hook acquires some
          storage thru a call to the aux-callback-routine with
          DEF_AUX_MEMGET, and this is used as output buffers.
@@ -217,6 +224,11 @@
          This behavior may also be controlled thru the flag
          boc_callrevdir.

+         The flag boc_callrevdir, call on reverse direction, is mainly
+         kept for compatibility reasons to older versions. As a
+         Server-Data-Hook can sent data to the client and the server at
+         all times, the flag boc_callrevdir should no more be used.
+
          When a new connection between the client and the server has
          successfully been established, the Server-Data-Hook is called
          with no input data.
@@ -229,7 +241,13 @@
          the Server-Data-Hook is still called and can send data to the
          remaining partner, before this connection also will be closed.
          So when the connection to the client has ended, the
-         Server-Data-Hook is called and can send data to the server.
+         Server-Data-Hook is called and can send data to the server.
+
+
+
+
+
+
          And when the connection to the server has ended, the
          Server-Data-Hook is called and can send data to the client.

@@ -239,13 +257,8 @@
          The Server-Data-Hook may end the session between client and
          server thru setting the variable inc_return to values other than
          DEF_IRET_NORMAL, such as DEF_IRET_END, before it returns to the
-         main program.
-
+         main program.

-
-
-
-
          2. When the Server-Data-Hook is called

          2.1. Calling for Processing of the Configuration
@@ -264,8 +277,8 @@
          When the routine m_hlclib_conf() returns FALSE, this
          Server-Data-Hook is not processed, so it is ignored.
          The WebSecureProxy issues a message about this.
-         The Server-Data-Hook itself (routine m_hlclib_conf())should give
-         messages why it does not return as expected.
+         The Server-Data-Hook itself (routine m_hlclib_conf()) should
+         give messages why it does not return as expected.
          This should be done thru calling the callback-routine.
          printf() or cout are not allowed, at least for a production
          release.
@@ -292,23 +305,22 @@
          during the livetime of this session. The address of this piece
          of storage was stored in ac_ext.
          The Server-Data-Hook should also free other memory regions and
-         resources it used until now.
+         resources it used until now.
+

+
+
+
+
          2.4. Calling during the Livetime of a Session

          The Server-Data-Hook is called in routine m_hlclib01() with the
          parameter inc_func set to DEF_IFUNC_FROMSERVER,
          DEF_IFUNC_TOSERVER or DEF_IFUNC_REFLECT.
-         The Server-Data-Hook is called whenever there are any input data
-         to process.
+         The Server-Data-Hook is called whenever there are any new input
+         data to process.
          At the start of a session, and at the end of a session, the
-         Server-Data-Hook is called with no input data, so it is possible
-
-
-
-
-
-
+         Server-Data-Hook is called with no input data, so it is possible
          to send data in any direction before or after the other side
          sent any data.

@@ -335,10 +347,14 @@

          2.7. Sending Data in the other Direction

-         When the Server-Data-Hook is called, it can give output only for
-         the direction it is called for. If it has output for the other
-         direction (which is where the input data came from at this
-         time), it can set the variable boc_callrevdir.
+         When the Server-Data-Hook is called, it can give output to both
+         directions thru setting the variables adsc_gai1_out_to_client
+         and adsc_gai1_out_to_server.
+         Flow-control is applied, mainly not receiving data from the
+         client when no data can be sent to the server, and not receiving
+         data from the server when no data can be sent to the client.
+         It is also possible that a Server-Data-Hook sets the variable
+         boc_callrevdir.
          It will then be called later, on the way to the other direction,
          even if there would not be any input data.

@@ -353,25 +369,25 @@
          There may also be another section included, which will give the
          parameters for the Server-Data-Hook:
            <configuration-section>
-         The parameters entered here are not known to the WSP.
+         The parameters entered here are not known to the WSP.
+
+
+
+
+
+
          When processing the xml-file, the WSP loads the DLL of the
          Server-Data-Hook and calls the method m_hlclib_conf with a
          pointer to the structure dsd_hl_clib_dom_conf.
          The Server-Data-Hook can now process the parameters and save the
          configuration in memory in a format not known to the WSP.

-         4. Do Radius-Authentication
+         4. Do Radius-Authentication or Other Authentication

          The Server-Data-Hook cannot do any TCP/IP or UDP socket calls
          thru operating system calls; instead it has to use the
          callback-routine amc_aux for exchange of data with
-         Radius-Servers.
-
-
-
-
-
-
+         Radius-Servers.
          The Radius-Servers, which may be a single one, or a certain
          number of Radius-Servers to avoid single point of failure, are
          configured in the Web-Secure-Proxy configuration-file (xml).
@@ -390,25 +406,39 @@
          In imc_flags_1, there is represented if one or multiple Radius
          Servers are configured for this connection.
          If, for this client side connection, a Subroutine for
-         Authentication, HLWSAT2, is defined, the bit
-         DEF_CLIB1_CONF_HLWSAT2 is set in the field imc_flags_1 of the
+         Authentication, HOB-WSP-AT3, is defined, the bit
+         DEF_CLIB1_CONF_HOBWSAT3 is set in the field imc_flags_1 of the
          structure dsd_hl_clib_dom_conf.
          If, in the field imc_flags_1 of the structure
          dsd_hl_clib_dom_conf, the bit DEF_CLIB1_CONF_RADIUS is set, one
          or more Radius Servers are defined.
+         When multiple Radius Servers are configured, the flag
+         DEF_CLIB1_CONF_DYN_RADIUS is set.
+         When authentication over Kerberos is possible, the flag
+         DEF_CLIB1_CONF_KRB5 is set.
+         When multiple Kerberos KDCs are configured, the flag
+         DEF_CLIB1_CONF_DYN_KRB5 is set.
+         When access to an LDAP directory is configured, the flag
+         DEF_CLIB1_CONF_LDAP is set.
+         When multiple LDAP directories are configured, the flag
+         DEF_CLIB1_CONF_DYN_LDAP is set.
          When users are defined for this connection, that is user-lists
          are defined, the bit DEF_CLIB1_CONF_USERLI is set in the field
          imc_flags_1 of the structure dsd_hl_clib_dom_conf.

-         DEF_CLIB1_CONF_SERVLI
-
-         For the Server-Data-Hook to contact the configurated
+         For the Server-Data-Hook to contact the configured
          Radius-Server, it calls the callback-routine amc_aux with the
          function DEF_AUX_RADIUS_QUERY; the address of the structure
          dsd_hl_aux_radius_1 is passed.
          This structure dsd_hl_aux_radius_1 is used to pass parameters to
          and from the program routine, which processes the Radius
-         Requests and Responses.
+         Requests and Responses.
+
+
+
+
+
+
          The option fields to be passed to the Radius Server may be
          specified; the options fields received are passed back.

@@ -418,7 +448,7 @@
          called with the function DEF_AUX_RADIUS_FREE; all resources are
          freed then.

-         5. Read the Contents of a Disk-File
+         5. Read the Content of a Disk-File

          The Server-Data-Hook cannot read a file from disk thru operating
          system calls; instead it has to use the callback-routine
@@ -428,13 +458,7 @@
          The Server-Data-Hook may or may not inform the WebSecureProxy if
          this disk-file is not longer accessed.
          The Server-Data-Hook will check in certain time intervalls
-         (configured in section general) if this disk-file has changed.
-
-
-
-
-
-
+         (configured in section general) if this disk-file has changed.
          If this disk-file has changed, it will load a new copy of this
          file, if another instance of the Server-Data-Hook requests
          access to the contents of this file.
@@ -466,18 +490,22 @@
          characters, UTF-16 = WCHAR = unsigned short int, immediatly
          followed by the Distinguished Name in Unicode characters.

-         8xx. Authenticate Against Configuration Set Parameters
+         8. Authenticate Against Configuration Set Parameters

          With the function DEF_AUX_CHECK_IDENT, Userid and Password can
          be authenticated against the configuration.
          This is done thru filling the structure dsd_hl_aux_ch_ident.
          User-Name und Password can be given in any character set, which
-         is conveniant for the calling program.
-         UUU1
+         is conveniant for the calling program.
+

-         8. Retrieve the Name from Authentication - either from Radius or
-         from HLWSAT2

+
+
+
+         9. Retrieve the Name from Authentication - either from Radius,
+         Kerberos, LDAP or from HOB-WSP-AT3.
+
          To retrieve the Name from the authentication of the client, the
          callback-routine amc_aux is called with the function
          DEF_AUX_GET_AUTH.
@@ -487,16 +515,11 @@
          by the third parameter contains the address of a storage, which
          first contains the length of the Name in Unicode characters,
          UTF-16 = WCHAR = unsigned short int, immediatly followed by the
-         Name in Unicode characters.
-
+         Name in Unicode characters.

+         10. Shared Memory - memory file - common memory area

-
-
-
-         9. Shared Memory - memory file - common memory area
-
-         For the Server-Data-Hook sessions, all sessions need to have a
+         For the Server-Data-Hook sessions, all sessions can have a
          common memory area.
          In this common memory area, data can stored and retrieved for
          all sessions. This is also used to exchanged data between
@@ -505,8 +528,8 @@
          This common memory area will also be accessible from programs
          running in the BCI (byte-code-interpreter) on WSP plus.

-         The future direction may be, to share this command memory area
-         between multiple WSP running on more than one server.
+         This command memory area can be shared between and accessed by
+         multiple WSP running on more than one server.
          In such a way, a cluster is build.

          The following operations (methods) are available:
@@ -522,8 +545,32 @@
          - read part (position and length) of common memory area
          - write part (position and length) of common memory area

-         10. Memory-Management
+         11. Aux-Pipe

+         A Server-Data-Hook may exchange data over a socalled aux-pipe.
+         This functionality is described in another document.
+         Data may be exchanged with internals of the WebSecureProxy, with
+         other Server-Data-Hooks, either of the same client connection,
+         or also of other client connections.
+
+         12. Administration Interface
+
+         A Server-Data-Hook can administrate the WebSecureProxy over
+         aux-calls of type DEF_AUX_ADMIN.
+         The Server-Data-Hook sends a command, the WebSecureProxy
+         processes the command and the response is given back to the
+         Server-Data-Hook. Administration of all members of a cluster of
+
+
+
+
+
+
+         connected WebSecureProxies can be done from a single
+         Server-Data-Hook.
+
+         13. Memory-Management
+
          The Server-Data-Hook is called on a work-thread. The
          Server-Data-Hook may be called multiple times parallel, if it is
          included in multiple sessions.
@@ -551,13 +598,8 @@
          m_hlclib01() is called.
          The routine m_hlclib01() should handle this storage, which is
          addressed by the variable ac_conf in the structure
-         dsd_hl_clib_1, as read-only.
-
+         dsd_hl_clib_1, as read-only.

-
-
-
-
          The design also provides a piece of storage, which is unique for
          a session using the Server-Data-Hook.
          The variable ac_ext in the structure dsd_hl_clib_1 may be used
@@ -577,11 +619,16 @@
          with inc_func == DEF_IFUNC_CLOSE, it should free this memory
          again (by calling amc_aux).

-         11. Generation of Random Numbers
+         14. Generation of Random Numbers
+

+
+
+
+
          To generate random numbers, the callback-routine amc_aux is
-         called with the function DEF_AUX_RANDOM_RAW or
-         DEF_AUX_RANDOM_BASE64.
+         called with the function DEF_AUX_RANDOM_RAW,
+         DEF_AUX_RANDOM_BASE64 or DEF_AUX_SECURE_RANDOM.
          The third paraneter of amc_aux gives the memory address, where
          the random number is to be stored, and the fourth parameter
          gives the length of this area in bytes.
@@ -593,8 +640,16 @@
          per byte are random; the 6 random bits are encoded BASE64 =
          MIME, RFC 1341.

-         12. Query Main / Calling Program about Capabilities
+         When the parameter DEF_AUX_SECURE_RANDOM is used, a secure
+         random is generated. This secure random may need many CPU cycles
+         to be generated, so a secure random should be used only in
+         security relevant functions. When currently there are not enough
+         data to return a secure random, the aux-call returns FALSE.
+         With the parameter DEF_AUX_SECURE_RANDOM, all 8 bits of each
+         returned byte are random.

+         15. Query Main / Calling Program about Capabilities
+
          There are and will be different programs / implementations
          calling the Server-Data-Hooks. So the Server-Data-Hooks need to
          query the calling program about its capabilities, because not
@@ -603,20 +658,15 @@
          Three different queries are supported by the callback-routine
          amc_aux:

-         12.1. Program Name of Calling Program
+         15.1. Program Name of Calling Program

          When the callback-routine amc_aux is called with
          DEF_AUX_QUERY_MAIN_STR, a zero-terminated string will be
          returned from the calling program, giving in 7-bit ASCII the
          name of the calling program.

-         12.2. Returning Capabilities of a Certain Feature
-
+         15.2. Returning Capabilities of a Certain Feature

-
-
-
-
          For every feature, given by the second parameter in the call to
          amc_aux, three int values may be returned for this feature.
          The first int is boolean, giving TRUE when this function is
@@ -625,17 +675,22 @@
          The third parameter is made up by 32 single bits, each set when
          a certain sub-function is implemented.

-         12.2.1. Query a Single Function
+         15.2.1. Query a Single Function

          When the callback-routine amc_aux is called with
          DEF_AUX_QUERY_MAIN_OPT as second parameter, the third parameter
          gives the address in memory where to return the three int
          values, and the fourth parameter, which is int, gives the
          function, which is passed as second parameter when the function
-         itself is called.
+         itself is called.
+

-         12.2.2. Querying Multiple Functions in a Single Call

+
+
+
+         15.2.2. Querying Multiple Functions in a Single Call
+
          The Server-Data-Hook may prepare a structure, where the first
          int gives the length in bytes (including this length field) of
          the passed structure.
@@ -651,7 +706,7 @@
          - version of implementation
          - sub-functions inplemented in single bits

-         13. Check Identification = Authenticate
+         16. Check Identification = Authenticate

          A program running as Server-Data-Hook may authenticate. This is
          true, for example, if a Web-Server is implemented as a
@@ -661,7 +716,7 @@
          returns, a fields tells if authentication succeeded, or if it
          failed and why.

-         14. Set a Timer
+         17. Set a Timer

          A Timer may be set. The callback-routine amc_aux is called with
          DEF_AUX_TIMER1_SET as second parameter, and the number of
@@ -674,19 +729,13 @@
          by calling the callback-routine amc_aux again with
          DEF_AUX_TIMER1_REL in the second parameter.
          Only one timer may be set for one instance of the
-         Server-Data-Hook.
-
-
-
-
-
-
+         Server-Data-Hook.
          It is also possible to call the callback-routine amc_aux with
          DEF_AUX_TIMER1_QUERY, and parameters three and four containing
          the address and the length of struct dsd_timer1_ret. On return,
          this structure will be filled with the corresponding values.

-         15. SDH Session Storage
+         18. SDH Session Storage

          There is the need, that subroutines which run for a certain
          session, can exchange data.
@@ -696,10 +745,17 @@
          WSP.
          Over this Session-Storage, the following components can exchange
          data:
-         15.1. SSL-subroutine m_hlse02()
-         15.2. HLWSPAT2
-         15.2. Server-Data-Hooks, either cascaded or one links the other
+         18.1. SSL-subroutine m_hlse03()
+         18.2. HOB-WSP-AT3
+

+
+
+
+
+         18.3. Server-Data-Hooks, either cascaded or one links the other
+         18.4. client-side-SSL-subroutine m_hlcl01()
+
          For this, the functions DEF_AUX_PUT_SESS_STOR,
          DEF_AUX_GET_SESS_STOR and DEF_AUX_DESCR_SESS_STOR exist.
          For DEF_AUX_PUT_SESS_STOR, the third parameter points on the
@@ -725,7 +781,7 @@
          and one single session will run only on a single thread, never
          on multiple threads parallel, no synchronisation is needed.

-         16. Data in the local stack passed to the callback-routine
+         19. Data in the local stack passed to the callback-routine
          amc_aux

          Care has to be taken when data in the local stack are passed
@@ -736,16 +792,13 @@
          in the stack local to a certain thread in all threads.
          In Unix this is not possible, data in the stack of one thread
          cannot be accessed from another thread. In Unix, the stack
-         memory of all threads lies in the same memory area.
-
+         memory of all threads lies in the same memory area.

+         20. References

-
-
-
-         17. References
-
          HOBTEXT SOFTWARE.HLSEC.CMA-DOC
+         HOBTEXT SOFTWARE.HLSEC.WSPADM2
+         HOBTEXT SOFTWARE.HLSEC.AUXPIPE1
          HOBTEXT SOFTWARE.COSTAND.SERDAHOA

          06.08.04  KB
@@ -757,7 +810,13 @@
          03.10.04  KB
          05.10.04  KB
          14.10.04  KB
-         29.11.04  KB
+         29.11.04  KB
+
+
+
+
+
+
          25.12.04  KB
          12.02.05  KB
          13.02.05  KB
@@ -773,5 +832,6 @@
          19.05.07  KB
          30.06.07  KB
          11.08.07  KB
-         06.09.08  KB
+         06.09.08  KB
+         17.11.12  KB
\ No newline at end of file
Index: SOFTWARE.HLSEC.WSPTUN08.act.txt
===================================================================
--- SOFTWARE.HLSEC.WSPTUN08.act.txt	(revision 2)
+++ SOFTWARE.HLSEC.WSPTUN08.act.txt	(revision 6)
@@ -49,22 +49,21 @@
               resource bound the the INETA and optionally TCP source port
               used by HOB-TUN to communicate in the intranet

-
          3. Routines in HOB-TUN and WSP for alternately calling each
             other

          3.1. Starting HOB-TUN from the WSP

          HOB-TUN, by design, cannot issue any OS API calls that would
-         require superuser rights in Unix.
+         require superuser rights in Unix.
+
+         The WSP starts HOB-TUN thru calling:





-         The WSP starts HOB-TUN thru calling:
-
          extern "C" BOOL m_htun_start(
              struct dsd_raw_packet_if_conf *adsp_rpi_conf,
              struct dsd_tun_ctrl *adsp_tun_ctrl );
@@ -115,19 +114,19 @@
          SSL-TCP-session with the client. struct dsd_tun_contr_conn is no
          more accessable by HOB-TUN as soon as HOB-TUN has called
          m_htun_session_end() or the WSP did call m_htun_sess_close().
-         Exception: the critical section is still available.-
+         Exception: the critical section is still available.

-
-
-
-
          Before the WSP calls m_htun_new_sess_htcp(), it creates the used
          struct dsd_tun_contr_ineta which, at the moment while IPV6 is
          not yet implemented, contains struct sockaddr_in with valid
          INETA and TCP port. The WSP did the necessary ARP entries and
-         set the necessary routes.
+         set the necessary routes.+

+
+
+
+
          m_htun_new_sess_htcp() returns immediately, meaning it does not
          contain any blocking API-calls to the operation system (besides
          writing to the TUN-adapter).
@@ -178,16 +177,15 @@
          The value filled is dsd_htun_h, the handle to the HOB-TUN object
          for this INETA or PPP session. dsd_htun_h is always passed from
          the WSP to HOB-TUN if the WSP calles a function in HOB-TUN.
-         Filling adsc_htun_h immediately is needed to update the AVL-tree+         Filling adsc_htun_h immediately is needed to update the AVL-tree
+         because m_find_htun_ineta() could be called with this INETA
+         before m_htun_new_sess_ppp() returns.





-         because m_find_htun_ineta() could be called with this INETA
-         before m_htun_new_sess_ppp() returns.
-
          3.3. INETAs or struct dsd_tun_contr_ineta for HOB-TUN PPP,
               meaning HOB-PPP-T1 or SSTP

@@ -242,16 +240,15 @@
          HTCP in HOB-TUN will try all INETAs either sequentially, one
          after the other, or in a random order if boc_connect_round_robin
          is set in struct dsd_tun_start1.
-         (see Round Robin of DNS servers)+         (see Round Robin of DNS servers)
+         To get a random number in the WSP, the routine
+         m_get_random_number() is called.





-         To get a random number in the WSP, the routine
-         m_get_random_number() is called.
-
          3.4.2. Routines in WSP that are called while HTCP in HOB-TUN
          does connect()

@@ -299,18 +296,19 @@
          extern "C" void m_htun_htcp_connect_end(
              struct dsd_tun_contr_conn *adsp_tun_contr_conn,
              struct dsd_target_ineta_1 *adsp_server_ineta,
+             void * ap_free_ti1,  /* INETA to free */
              struct sockaddr *adsp_soa, socklen_t imp_len_soa,
              int imp_errno )

-         3.5. sending and receiving in HOB-TUN+         3.5. sending and receiving in HOB-TUN
+
+         3.5.1. receive





-         3.5.1. receive
-
          3.5.1.1. buffer needed for receive

          All buffers are managed by the WSP, not by HOB-TUN.
@@ -362,16 +360,16 @@
          3.5.1.4. Flow-Control for Receive Data, m_htun_sess_canrecv()

          Flow-Control is done thru the return value to the routine
-         m_se_htun_recvbuf(), passed from the WSP to HOB-TUN.+         m_se_htun_recvbuf(), passed from the WSP to HOB-TUN.
+
+         When the WSP has stopped receiving and wants to resume
+         receiving, it calls m_htun_sess_canrecv() in HOB-TUN.





-         When the WSP has stopped receiving and wants to resume
-         receiving, it calls m_htun_sess_canrecv() in HOB-TUN.
-
          extern "C" void m_htun_sess_canrecv(dsd_htun_h dsp_hdl_sess);

          3.5.1.6. Avoid Copying of Data
@@ -425,16 +423,16 @@
          could not send all data. But in the parameter in the call to
          m_htun_sess_send(), the WSP will always give all data which have
          not been sent yet, not only the new data. This makes it more
-         simple for both, the WSP and HOB-TUN, since HOB-TUN can simply+         simple for both, the WSP and HOB-TUN, since HOB-TUN can simply
+         update its internal field where is stores the address of the
+         first gather-structure to be sent.
+         When HTCP accesses fields of any of the passed





-         update its internal field where is stores the address of the
-         first gather-structure to be sent.
-         When HTCP accesses fields of any of the passed
          gather-structures, no critical section is needed, since the WSP
          or any other thread will do only read-access to the fields in
          the passed gather-structures, never any write access.
@@ -484,17 +482,17 @@
          part may call m_htun_session_end() in the WSP when there is a
          reason to end the connection.
          In HTCP this would be it did receive FIN or RST from the partner
-         TCP.+         TCP.
+
+         extern "C" void m_htun_session_end(
+            struct dsd_tun_contr_conn *adsp_tun_contr_conn,
+            int imp_reason );





-         extern "C" void m_htun_session_end(
-            struct dsd_tun_contr_conn *adsp_tun_contr_conn,
-            int imp_reason );
-
          3.6.3. After HOB-TUN HTCP did cleanup,
                 m_htun_htcp_free_resources()

@@ -544,19 +542,19 @@
          of race conditions, when boths sides of the TCP connection want
          to close the connection at the same time, m_htun_sess_close()
          may be called by the WSP shortly before or shortly after HTCP in
-         HOB-TUN calls m_htun_session_end().-
+         HOB-TUN calls m_htun_session_end().

-
-
-
-
          The WSP may call m_htun_sess_close() also during the time when
          HTCP in HOB-TUN tries to establish the TCP connection. When this
          happens, HTCP in HOB-TUN calls m_htun_htcp_connect_end() with
          error set, then m_htun_session_end() and at the end
-         m_htun_htcp_free_resources().
+         m_htun_htcp_free_resources().+

+
+
+
+
          4. Miscellaneous in the WSP

          4.1. Critical Sections
@@ -608,16 +606,16 @@
            struct dsd_tun_contr_conn *adsp_tun_contr_conn,
            struct dsd_tun_contr_ineta *adsp_tun_contr_ineta,
            int imp_error_number,
-           const char *achp_format, ... );+           const char *achp_format, ... );
+
+         int imp_error_number is an up to three digit error number which
+         needs to be unique for HOB-TUN.





-         int imp_error_number is an up to three digit error number which
-         needs to be unique for HOB-TUN.
-
          Either adsp_tun_contr_conn or adsp_tun_contr_ineta need to be
          valid, meaning not NULL.
          Setting adsp_tun_contr_conn should be preferred, but this is not
@@ -669,18 +667,18 @@
          extern "C" enum ied_ret_cf m_proc_ppp_targfi_ipv4(
              struct dsd_hco_wothr *adsp_hco_wothr,
              struct dsd_ppp_targfi_act_1 *adsp_ptfa1,
-             struct dsd_gather_i_1 *adsp_gai1, int imp_len );+             struct dsd_gather_i_1 *adsp_gai1, int imp_len );
+
+         The returned enum ied_ret_cf says what to do with the packet.
+         enum ied_ret_cf may also say the IPV4 packet is incomplete, so
+         m_proc_ppp_targfi_ipv4() needs to be called again when the IPV4
+         packet is complete.





-         The returned enum ied_ret_cf says what to do with the packet.
-         enum ied_ret_cf may also say the IPV4 packet is incomplete, so
-         m_proc_ppp_targfi_ipv4() needs to be called again when the IPV4
-         packet is complete.
-
          The input data, struct dsd_gather_i_1 *adsp_gai1, might contain
          more data than the IPV4 packet which needs to be checked. For
          this, int imp_len is passed. m_proc_ppp_targfi_ipv4() looks at
@@ -732,18 +730,18 @@
          In the WSP there is a mechanism that when the SSL packet is
          really sent to the client, the field
          imc_on_the_fly_packets_client is set to zero.
-         This field imc_on_the_fly_packets_client is also in struct+         This field imc_on_the_fly_packets_client is also in struct
+         dsd_tun_contr_conn. But struct dsd_tun_contr_conn is only
+         available as there is a real connection to the client. If the
+         connection to the client was interrupted and HOB-PPP-T1 waits
+         for a reconnect, all IP packets received over the TUN adapter
+         have to be discarded anyway.





-         dsd_tun_contr_conn. But struct dsd_tun_contr_conn is only
-         available as there is a real connection to the client. If the
-         connection to the client was interrupted and HOB-PPP-T1 waits
-         for a reconnect, all IP packets received over the TUN adapter
-         have to be discarded anyway.
          Now when HOB-TUN receives an IP packet over the TUN adapter, it
          checks if the field imc_on_the_fly_packets_client already
          contains the maximum number of packets that are temporarily
@@ -776,5 +774,6 @@
          15.09.12  KB
          21.09.12  KB
          22.09.12  KB
-         23.09.12  KB+         23.09.12  KB
+         21.11.12  KB
\ No newline at end of file
Index: xshusip01.cpp
===================================================================
--- xshusip01.cpp	(revision 2)
+++ xshusip01.cpp	(revision 6)
@@ -14,10 +14,16 @@
 //|                                                                   |
 //+-------------------------------------------------------------------+

+#ifndef D_INCL_TUN_CTRL
+#define D_INCL_TUN_CTRL
+#endif
+
 #ifndef HL_UNIX
 #include <winsock2.h>
 #include <ws2tcpip.h>
 #include <windows.h>
+#else
+#include "hob-unix01.h"
 #endif
 #ifndef HL_UNIX
 #include <hob-avl03.h>
@@ -28,11 +34,20 @@
 typedef int socklen_t;
 #endif
 #ifdef HL_UNIX
+#ifndef HOB_CONTR_TIMER
 #define HOB_CONTR_TIMER
+#endif
+#include <net/if.h>
 #include <netinet/in.h>
+#include <sys/select.h>
 #include <string.h>
-#include "types_defines.h"
+
+//#include "types_defines.h"
+#ifndef byte
+#define byte unsigned char
 #endif
+
+#endif
 #include <hob-xslhcla1.hpp>
 #include <hob-netw-01.h>
 #include <string>
@@ -43,18 +58,21 @@
 #include <iostream>
 #include "hob-xslcontr.h"
 #include "hob-tun01.h"
-#include "hob-htcp-int-types.h"
-#include "hob-htcp.h"
-#include "hob-htcp-bit-reference.h"
-#include "hob-htcp-tcpip-hdr.h"
-#include "hob-htcp-misc.h"
-#include "hob-htcp-connection.h"
+#include "hob-htcp-int-01.h"
+#include "hob-htcp-hdr-01.h"
+#include "hob-htcp-01.h"
+//#include "hob-htcp-int-types.h"
+//#include "hob-htcp.h"
+//#include "hob-htcp-bit-reference.h"
+//#include "hob-htcp-tcpip-hdr.h"
+//#include "hob-htcp-misc.h"
+//#include "hob-htcp-connection.h"
 #include "hob-session01.h"
-#include "hob-htcp-session.h"
+//#include "hob-htcp-session.h"
+#include "hob-htcp-htun-01.h"
 #include "hob-gw-ppp-1.h"
 #include "hob-hppp01.h"
 #include "hob-hsstp01.h"
-#include "hob-tun02.h"
 #include "hob-tuntapif01.h"
 #include <stdio.h>
 #include <vector>
@@ -71,36 +89,37 @@
 #include <Iphlpapi.h>
 #endif

-extern "C" void m_htun_session_end( struct dsd_tun_contr1 *adsp_tun_contr1,
-                                         int imp_reason );
+extern PTYPE void m_htun_session_end( struct dsd_tun_contr_conn *adsp_tun_contr_conn,
+                                      int imp_reason );

-static BOOL bos_htun_started = FALSE;
+extern "C" int img_wsp_trace_core_flags1;

-#ifdef NEW_HOB_TUN_1103
+#ifndef NEW_HOB_TUN_1103
 dsd_vnic dsg_vnic;
 #endif

 //-------------------
 //FUNCTION PROTOTYPES
 //-------------------
-static THDRET WINAPI m_htun_read_loop(LPVOID ap_param);
-static int m_getindex_if(unsigned long ulp_ifaddr);
+THDRET WINAPI m_htun_read_loop(LPVOID ap_param);
 extern "C" int m_hl1_printf(char * aptext, ... );
+
+/**
+ * Send packet from TUN adapter to HTUN.
+ *
+ * @param  ap_handle   Handle to the buffer.
+ * @param  inp_offset  Empty space available just before data.
+ * @param  achp_data   Pointer to the start of the packet data.
+ * @param  inp_len     Length of the packet.
+ */
+extern "C" void m_htun_recv( void * ap_handle, int inp_offset,
+                             char *achp_data, int inp_len );
+
 //static void m_del_next_node(struct dsd_timer_ele* dsl_timer_ele_w1);
-#ifdef B120213 // incorrect prototypes
-extern "C" void m_htun_critsect_enter
-   (class dsc_htcp_session* adsp_htcp_session);
-extern "C" void m_htun_critsect_leave
-   (class dsc_htcp_session* adsp_htcp_session);
-#endif // B120213

 //-----------
 //GLOBAL VARS
 //-----------
-#ifdef B100706
-// Critical section object for AVL operations.
-DEFCRITSEC(dsg_critsec_avl);
-#endif
 // Critical section object for WSP configuration.
 DEFCRITSEC(dsg_critsec_wspconf);
 // WSP configuration struct.
@@ -110,10 +129,6 @@
 //FILE STATIC VARS
 //----------------
 // TUN DEVICE RELATED VARS.
-#ifdef B090317
-// Handle to tun device in use.
-static TUNHANDLE as_htun = 0;
-#endif
 // TUN interface.
 static struct dsd_tun_intf_1 dss_tun_intf_1;
 static char chrs_htun_name[ 1024 ];
@@ -122,160 +137,13 @@
 // BOOL indicating whether WSP config crit section has been initialized.
 static BOOL bos_wspconf_init = false;

-#ifdef B100706
-// AVL TREE RELATED VARS.
-// True after AVL tree has been initialised.
-static BOOL bos_avl_initd = false;
-// Control struct for AVL tree.
-static dsd_htree1_avl_cntl dss_control;
-// Workspace struct for AVL tree.
-static dsd_htree1_avl_work dss_workspace;
-// Vector with nodes to be deleted.
-static std::vector<dsd_avl_session*> dss_nodes_to_del;
-// Vector with active timers.
-static std::vector<dsd_timer_ele*> dss_active_timers;
-#endif
-
-//--------------------
-//FUNCTION DEFINITIONS
-//--------------------
-//
-// AVL Tree comparison callback function.
-// This sub routine is called by the AVL tree module when it attempts to
-// compare two nodes.
-//
-// @param   ap_userfld  Not used.
-// @param   adsp_ent_x  Pointer to one of the nodes to compare.
-// @param   adsp_ent_y  Pointer to the other node to be compared.
-// @return  1 if the first node is greater than the second, -1 if it is
-//          smaller, and 0 if both are equal.
-//
-int m_cmp_sess_nodes(void* ap_userfld,
-                     dsd_htree1_avl_entry* adsp_ent_x,
-                     dsd_htree1_avl_entry* adsp_ent_y)
+extern "C" BOOL m_htun_start( struct dsd_raw_packet_if_conf *adsp_raw_packet_if_conf,
+                              struct dsd_tun_ctrl *adsp_tun_ctrl )
 {
-   // Key of node adsp_ent_x.
-   unsigned long uml_val_x;
-   // Key of node adsp_ent_y.
-   unsigned long uml_val_y;
-
-   // Get key values.
-   // Skip hdr and point to value payload.
-   uml_val_x = *((u_long*)(adsp_ent_x + 1));
-   // Same here.
-   uml_val_y = *((u_long*)(adsp_ent_y + 1));
-
-   return uml_val_x - uml_val_y;
-}// ~m_cmp_sess_nodes.
-
-#ifdef B100706
-//
-// Initialises the AVL tree.
-// Attempts to initialize an AVL tree by calling the m_cmp_sess_nodes()
-// function, and passing to it the comparison callback function
-// m_cmp_sess_nodes() and a pointer to an existing m_cmp_sess_nodes structure.
-//
-// @return  True if successful, False if otherwise.
-//
-static BOOL m_avl_init(void)
-{
-   // Try to init the tree.
-   if(!m_htree1_avl_init(NULL, &dss_control, &m_cmp_sess_nodes))
-   {  // Tree init FAILED.
-      m_hl1_printf("AVL ERROR!");
-      return false;
-   }
-   else
-   {  // Tree init OK.
-      // Init critical section object for tree manipulation.
-      INITCRITSEC(dsg_critsec_avl);
-      // Initialize HOB-Timer.
-      m_hco_init(8 << 1, 8);
-      // Set AVL Init flag & return.
-      bos_avl_initd = true;
-      return true;
-   }
-}// ~m_avl_init.
-#endif // B100706
-
-#ifdef B100802
-extern PTYPE BOOL m_htun_start(void)
-{
-   int iml_retval;
-   char str_htun_name[1024] = "";
-
-#ifdef B090317
-   // Try to get handle to a tun device.
-   if(m_open_tun(&as_htun, str_htun_name, 1024) != 0)
-   {  // Get handle FAILED.
-      m_hl1_printf(m_tun_last_err());
-      return false;
-   }
-
-   // Try to configure tun device endpoints.
-   // TODO: allow caller to specify endpoints.
-   // Currently endpoint ip addresses are hard-coded.
-// if(m_init_tun(as_htun, str_htun_name, "10.24.39.1", "10.24.39.2") != 0)
-// if(m_init_tun(as_htun, str_htun_name, "172.22.81.200", "172.22.81.201") != 0)
-   if(m_init_tun(as_htun, str_htun_name, "172.22.81.200", "172.22.81.201") != 0)
-   {  // Tun config FAILED.
-      m_hl1_printf(m_tun_last_err());
-      return false;
-   }
-#endif
-   if (m_open_tun(&dss_tun_intf_1.dsc_tunhandle,
-                  chrs_htun_name,
-                  sizeof(chrs_htun_name) ) != 0)
-   {  // Get handle FAILED.
-      m_hl1_printf(m_tun_last_err());
-      return false;
-   }
-   dss_tun_intf_1.achc_adapter_name = chrs_htun_name;  // Adapter name.
-   *((unsigned long int *) dss_tun_intf_1.chrc_ineta_locale) =
-      inet_addr( "10.24.39.1" );  // Local end-point.
-   *((unsigned long int *) dss_tun_intf_1.chrc_ineta_remote) =
-      inet_addr( "10.24.39.2" );  // Remote end-point.
-   *((unsigned long int *) dss_tun_intf_1.chrc_netmask_1) =
-      inet_addr( "255.255.255.252" ); // Network mask.
-   if (m_init_tun( &dss_tun_intf_1 ) != 0)
-   {  // Tun config FAILED.
-      m_hl1_printf(m_tun_last_err());
-      return false;
-   }
-
-   // Try to set tun to "connected".
-// if(m_connect_tun(as_htun) != 0)
-   if(m_connect_tun(dss_tun_intf_1.dsc_tunhandle) != 0)
-   {  // Tun status "connected" FAILED.
-      m_hl1_printf(m_tun_last_err());
-      return false;
-   }
-
-#ifdef B100706
-#ifndef B090316
-   // If tree not initd, do init.
-// if(!bos_avl_initd)
-      m_avl_init();
-#endif
-#endif // B100706
-   // Launch thread to read packets coming over TUN adapter & dispatch
-   // them to HPPP or HTCP modules as required.
-   iml_retval = dsl_thd_read.mc_create(m_htun_read_loop);
-   if(iml_retval < 0)
-   {
-      m_hl1_printf("Create TUN read thread failed with code %d.\n", iml_retval);
-      return false;
-   }
-
-   // All OK.
-   return true;
-}// ~m_htun_start.
-#endif
-extern "C" BOOL m_htun_start( struct dsd_raw_packet_if_conf *adsp_raw_packet_if_conf ) {
    BOOL bol_retval = FALSE;
    int iml_retval;

-#ifndef NEW_HOB_TUN_1103
+#ifdef NEW_HOB_TUN_1103
    char str_htun_name[1024] = "";

 // to-do 02.08.10 KB - reload configuration
@@ -290,17 +158,7 @@
    dss_tun_intf_1.achc_adapter_name = chrs_htun_name;  // Adapter name.
    *((unsigned int *) dss_tun_intf_1.chrc_ineta_locale)
      = adsp_raw_packet_if_conf->umc_ta_ineta_local;  /* <TUN-adapter-ineta>     */
-#ifdef B100912
-   *((unsigned int *) dss_tun_intf_1.chrc_ineta_remote)
-     = adsp_raw_packet_if_conf->umc_ta_ineta_remote;  /* <TUN-adapter-ineta>     */
-   *((unsigned int *) dss_tun_intf_1.chrc_netmask_1)
-     = adsp_raw_packet_if_conf->umc_ta_ineta_mask;  /* <TUN-adapter-ineta>     */
-#endif

-#ifdef B101007
-   *((unsigned int *) dss_tun_intf_1.chrc_ineta_remote)
-     = adsp_raw_packet_if_conf->umc_ta_ineta_local ^ 0X03;  /* <TUN-adapter-ineta> */
-#endif
    *((unsigned int *) dss_tun_intf_1.chrc_ineta_remote) = adsp_raw_packet_if_conf->umc_ta_ineta_local;
    *((unsigned char *) &dss_tun_intf_1.chrc_ineta_remote + sizeof(int) - 1) ^= 0X03; /* <TUN-adapter-ineta> */
    *((unsigned int *) dss_tun_intf_1.chrc_netmask_1)
@@ -325,6 +183,19 @@

 #else

+   dsg_tun_hdl = adsp_tun_ctrl->imc_fd_tun;
+
+   iml_retval = dsl_thd_read.mc_create(m_htun_read_loop);
+   if(iml_retval < 0)
+   {
+      m_hlnew_printf(HLOG_WARN1, "HWSPTUN1014W Create TUN read thread failed with code %d.", iml_retval);
+      return FALSE;
+   }
+
+   return TRUE;
+
+
+#ifdef B130109
     dss_tun_intf_1.achc_adapter_name = chrs_htun_name;  // Adapter name.
    *((unsigned int *) dss_tun_intf_1.chrc_ineta_locale)
      = adsp_raw_packet_if_conf->umc_ta_ineta_local;  /* <TUN-adapter-ineta>     */
@@ -338,17 +209,15 @@
    dsl_ineta.s_addr = adsp_raw_packet_if_conf->umc_ta_ineta_local;
    char* achl_ineta = inet_ntoa(dsl_ineta);

-   bol_retval = dsg_vnic.m_init(achl_ineta, 0, false, false);
-
+   bol_retval = dsg_vnic.m_init(achl_ineta, 0, "255.255.255.0", false);
 #endif

-   if(bol_retval)
+
+#endif
+#ifdef B130110
+   if(!bol_retval)
    {
-       m_hlnew_printf(HLOG_INFO1, "HWSPTUN1000I TUN adapter successfully started.");
-   }
-   else
-   {
-#ifdef NEW_HOB_TUN_1103
+#ifndef NEW_HOB_TUN_1103
       m_hlnew_printf(HLOG_WARN1, "HWSPTUN1012W Starting TUN adapter failed with error '%s'.", dsg_vnic.m_get_last_error());
 #else
        m_hlnew_printf(HLOG_WARN1, "HWSPTUN1013W Starting TUN adapter failed.");
@@ -356,6 +225,8 @@
       return false;
    }

+   m_hlnew_printf(HLOG_INFO1, "HWSPTUN1000I TUN adapter successfully started.");
+
    // Launch thread to read packets coming over TUN adapter & dispatch
    // them to HPPP or HTCP modules as required.
    iml_retval = dsl_thd_read.mc_create(m_htun_read_loop);
@@ -365,13 +236,15 @@
       return FALSE;
    }

+   adsp_tun_ctrl->boc_tun_opened = TRUE;
    return bol_retval;
+#endif
 }// ~m_htun_start.

 extern PTYPE void m_htun_end(void)
 {

-#ifndef NEW_HOB_TUN_1103
+#ifdef NEW_HOB_TUN_1103
    // Try to close tun device.
 // if(m_close_tun(as_htun) != 0)
    if(m_close_tun(dss_tun_intf_1.dsc_tunhandle) != 0)
@@ -386,677 +259,467 @@
 #endif
 }// ~m_htun_end.

-#ifdef B080925
-extern PTYPE dsd_tun_ppp_h m_htun_new_sess
-   (struct dsd_tun_contr1 *adsp_tun_contr1,
-    sockaddr* adsp_saddr,
-    unsigned long ulp_ifaddr,
-    dsd_usrcredents_mschap2* adsp_auth_info,
-    BOOL* abop_ipok)
-{
-   int iml_retval;
-   unsigned long ull_index_if;

-   // If tree not initd, do init.
-   if(!bos_avl_initd)
-      m_avl_init();
-
-   *abop_ipok = true;
-
-   if(adsp_tun_contr1->dsc_ineta_conf_1.imc_family == 23) // AF_INET6.
+extern PTYPE void m_htun_new_sess_ppp(struct dsd_tun_start_ppp* adsp_tun_start_ppp,
+                                      struct dsd_tun_contr_conn* adsp_tun_contr_conn)
+{
+#ifdef NEW_HOB_TUN_1103
+   if(adsp_tun_start1->dsc_soa_local.ss_family != 2) //AF_INET
    {
-      m_hl1_printf
-         ("Current version of TAP-Win32 only supports IPv4 when in TUN mode.");
-      return NULL;
+      m_hl1_printf("Current version of TAP-Win32 only supports IPv4 when in TUN mode.");
+      return;
    }
+#endif
+   //create session
+   m_init_sess(/*NULL,*/ adsp_tun_start_ppp, adsp_tun_contr_conn, NULL);
+} /* m_htun_new_sess()                                                 */

-   // Create new AVL tree node.
-   dsd_avl_sess* adsl_new_sess = new dsd_avl_sess();
-   // Set node members.
-   // Node KEY (client virtual ineta as u_long).
-   adsl_new_sess->ulc_key_ineta =
-      *(u_long*)(adsp_tun_contr1->dsc_ineta_conf_1.chrc_ineta);
-   // Client configuration data.
-   adsl_new_sess->adsc_cli_conf = new dsd_tun_contr1(*adsp_tun_contr1);
-   // Session owner protocol (SSTP).
-   adsl_new_sess->iec_sess_proto = adsp_tun_contr1->iec_tunc;
+extern PTYPE void m_htun_sess_close(dsd_htun_h dsp_husip_sess)
+{
+   dsd_htun_handle* adsl_hth = (dsd_htun_handle*)dsp_husip_sess;

-   // Enter critical section.
-   ENTERCRITSEC(dsg_critsec_avl);
-
-   // Look for new node.
-   if(!m_htree1_avl_search(NULL,
-                           &dss_control,
-                           &dss_workspace,
-                           &(adsl_new_sess->dsc_avl_hdr)))
+   if (adsl_hth->iec_tunc == ied_tunc_htcp)
    {
-      m_hl1_printf("AVL ERROR!");
-      delete adsl_new_sess->adsc_cli_conf;
-      delete adsl_new_sess;
-      // Leave critical section.
-      LEAVECRITSEC(dsg_critsec_avl);
-      return NULL;
+      struct dsd_htcp_htun* adsl_hh = (struct dsd_htcp_htun*)adsl_hth->vpc_contr;
+      m_htcp_sess_close(adsl_hh);
+      return;
    }
-   else
+   else if (adsl_hth->iec_tunc == ied_tunc_ppp)
    {
-      // Node already exists.
-      if(dss_workspace.adsc_found != NULL)
-      {
-         m_hl1_printf("AVL TREE COLLISION!");
-         delete adsl_new_sess->adsc_cli_conf;
-         delete adsl_new_sess;
-         // Leave critical section.
-         LEAVECRITSEC(dsg_critsec_avl);
-         // Indicate that INETA is already in use.
-         *abop_ipok = false;
-         return NULL;
-      }
-      // Insert new session node into tree.
-      if(!m_htree1_avl_insert(NULL,
-                              &dss_control,
-                              &dss_workspace,
-                              &(adsl_new_sess->dsc_avl_hdr)))
-      {
-         m_hl1_printf("AVL ERROR!");
-         delete adsl_new_sess->adsc_cli_conf;
-         delete adsl_new_sess;
-         // Leave critical section.
-         LEAVECRITSEC(dsg_critsec_avl);
-         return NULL;
-      }
+	  struct dsd_ppp_session* adsl_ppp = (struct dsd_ppp_session*)adsl_hth->vpc_contr;
+      adsl_ppp->mc_close();
+      return;
    }

-   // Leave critical section.
-   LEAVECRITSEC(dsg_critsec_avl);
+   dsd_session* adsl_session = (dsd_session*)adsl_hth->vpc_contr;
+   // NOTE: adsl_session can be ppp or pppt session
+   adsl_session->mc_close();
+}

-   ull_index_if = 0;
+extern PTYPE BOOL m_se_husip_send(unsigned char *aucp_data,
+                                  int imp_length)
+{
+// if(m_writeone_blk(as_htun,
+//                   aucp_data,
+//                   imp_length,
+//                   NULL,
+//                   &iml_bytes_written) < 0)

-#if defined WIN32 || WIN64
+#ifdef NEW_HOB_TUN_1103
+   int iml_bytes_written;

-   // Try to create PARP entry for this client.
-   ull_index_if = m_getindex_if(ulp_ifaddr);
-   if(ull_index_if < 0)
-      m_hl1_printf("Could not create PARP entry for this connection.\n");
+   if(m_writeone_blk(dss_tun_intf_1.dsc_tunhandle,
+                     aucp_data,
+                     imp_length,
+                     NULL,
+                     &iml_bytes_written) < 0)
+      return false;
    else
-   {
-      iml_retval = CreateProxyArpEntry(adsl_new_sess->ulc_key_ineta,
-                                       0xFFFFFFFF,
-                                       ull_index_if);
-      if(iml_retval != NO_ERROR)
-         m_hl1_printf("Could not create PARP entry for this connection.\n");
-   }
+      return true;

-#endif
+#else
+   unsigned int iml_bytes_written;
+   BOOL bol_ret;
+   const char* achl_message;
+   dsd_gather_i_1 dsl_gath;

-   // Try to create static route for this client.
-   char chrl_cmd[1024];
+   bol_ret = dsg_vnic.m_write(aucp_data,
+                              imp_length,
+                              iml_bytes_written) >= 0;

-#if defined WIN32 || WIN64
+   if ((img_wsp_trace_core_flags1 & HL_WT_CORE_HOB_TUN) != 0) {
+       if (bol_ret) {
+           achl_message = "TUN adapter write %d bytes over internal network.";
+       } else {
+           achl_message = "TUN adapter failed to write %d bytes over internal network.";
+       }

-   sprintf(chrl_cmd,
-           "route add %u.%u.%u.%u mask 255.255.255.255 172.22.81.2",
-           (unsigned char)(adsp_tun_contr1->dsc_ineta_conf_1.chrc_ineta[0]),
-           (unsigned char)(adsp_tun_contr1->dsc_ineta_conf_1.chrc_ineta[1]),
-           (unsigned char)(adsp_tun_contr1->dsc_ineta_conf_1.chrc_ineta[2]),
-           (unsigned char)(adsp_tun_contr1->dsc_ineta_conf_1.chrc_ineta[3]));
+      dsl_gath.achc_ginp_cur = (char*)aucp_data;
+      dsl_gath.achc_ginp_end = dsl_gath.achc_ginp_cur + imp_length;
+      dsl_gath.adsc_next = NULL;
+      m_do_wsp_trace("CTUNSEND", HL_WT_CORE_HOB_TUN, 0, 0, &dsl_gath,
+                     imp_length, 48, achl_message, imp_length);
+   }

-#elif defined HL_LINUX
-
-   sprintf(chrl_cmd,
-           "route add %u.%u.%u.%u gw 10.24.39.2",
-           (unsigned char)(adsp_tun_contr1->dsc_ineta_conf_1.chrc_ineta[0]),
-           (unsigned char)(adsp_tun_contr1->dsc_ineta_conf_1.chrc_ineta[1]),
-           (unsigned char)(adsp_tun_contr1->dsc_ineta_conf_1.chrc_ineta[2]),
-           (unsigned char)(adsp_tun_contr1->dsc_ineta_conf_1.chrc_ineta[3]));
-
+   return bol_ret;
 #endif
+}

-   system(chrl_cmd);
+extern PTYPE BOOL m_se_husip_send_gather(dsd_gather_i_1* adsp_data,
+                                         unsigned unp_length)
+{
+#ifdef NEW_HOB_TUN_1103

-   // Create session.
-   adsl_new_sess->a_extend = m_init_sess(adsp_tun_contr1, ull_index_if);
+    if (adsp_data->achc_ginp_cur + unp_length <= adsp_data->achc_ginp_end) {
+        return m_se_husip_send((unsigned char*)adsp_data->achc_ginp_cur,
+                               unp_length);
+    } else {
+        const unsigned unl_buf_len = 16384;
+        char chrl_buffer[unl_buf_len];
+        char* achl_buffer;
+        struct dsd_gather_i_1* adsl_g = adsp_data;
+        unsigned unl_cur_ofs;
+        unsigned unl_l;
+        BOOL bol_ret;

-   // All OK: return pointer to new session node.
-   return adsl_new_sess;
-} // ~m_htun_new_sstp.
-#endif
+        if (unp_length <= unl_buf_len) {
+            achl_buffer = chrl_buffer;
+        } else {
+            achl_buffer = (char*)malloc(unp_length);
+            if (achl_buffer == NULL) {
+                // TODO: warning message
+                return FALSE;
+            }
+        }

-#ifdef B100702
-extern "C" dsd_htun_h m_htun_new_sess( struct dsd_tun_contr1 *adsp_tun_contr1 )
-{
-   sockaddr* adsp_saddr = NULL;
-   unsigned long ulp_ifaddr = 0;
-   dsd_usrcredents_mschap2* adsp_auth_info = NULL;
-   BOOL bo_dummy; // KS.
-   BOOL* abop_ipok = &bo_dummy; // KS - was NULL.
-   // End of pseudo parameters.
-   int iml_retval;
-   unsigned long ull_index_if;
-   DWORD      dwl1;
-   char       chrl_work1[ 512 ];
+        unl_cur_ofs = 0;
+        while (unl_cur_ofs < unp_length) {
+            while (adsl_g != NULL &&
+                   adsl_g->achc_ginp_cur == adsl_g->achc_ginp_end) {

-#ifdef B090316
-   // If tree not initd, do init.
-   if(!bos_avl_initd)
-      m_avl_init();
-#endif
+                adsl_g = adsl_g->adsc_next;
+            }
+            if (adsl_g == NULL) {
+                // TODO: warning message
+                if (achl_buffer != chrl_buffer)
+                    free(achl_buffer);
+                return FALSE;
+            }
+            unl_l = adsl_g->achc_ginp_end - adsl_g->achc_ginp_cur;
+            if (unl_cur_ofs + unl_l > unp_length)
+                unl_l = unp_length - unl_cur_ofs;
+            memcpy(achl_buffer + unl_cur_ofs, adsl_g->achc_ginp_cur, unl_l);
+            unl_cur_ofs += unl_l;
+            adsl_g = adsl_g->adsc_next;
+        }

-   *abop_ipok = true;
+        bol_ret = m_se_husip_send((unsigned char*)achl_buffer, unp_length);

-// if(adsp_tun_contr1->dsc_ineta_conf_1.imc_family == 23) // AF_INET6.
-   if (adsp_tun_contr1->dsc_soa_local.ss_family != 2) // AF_INET.
-   {
-      m_hl1_printf
-         ("Current version of TAP-Win32 only supports IPv4 when in TUN mode.");
-      return NULL;
-   }
+        if (achl_buffer != chrl_buffer)
+            free(achl_buffer);

-   // Create new AVL tree node.
-   // KS090319   dsd_avl_sess* adsl_new_sess = new dsd_avl_sess();
-   dsd_avl_session* adsl_new_sess = new dsd_avl_session;
-   adsl_new_sess->ds_info.ie_type = adsp_tun_contr1->iec_tunc;
+        return bol_ret;
+    }

-   // Set node members.
-   // Node KEY (client virtual ineta as u_long).
-#ifdef B090317
-   adsl_new_sess->ulc_key_ineta =
-      *(u_long*)(adsp_tun_contr1->dsc_ineta_conf_1.chrc_ineta);
-#endif
-   adsl_new_sess->ds_entry.umc_key_ineta =
-      *(u_long*)&((struct sockaddr_in *)&adsp_tun_contr1->dsc_soa_local)->
-      sin_addr;
-   // Client configuration data.
-   adsl_new_sess->ds_entry.adsc_cli_conf = new dsd_tun_contr1(*adsp_tun_contr1);
-   // Session owner protocol (SSTP).
-   adsl_new_sess->ds_entry.iec_sess_proto = adsp_tun_contr1->iec_tunc;
+#else // !defined NEW_HOB_TUN_1103

-   // Enter critical section.
-   ENTERCRITSEC(dsg_critsec_avl);
+    const int inl_vect_len = 16;
+    struct dsd_gather_i_1* adsl_data = adsp_data;
+    unsigned unl_length = unp_length;
+    struct dsd_vector dsrl_vect[inl_vect_len];
+    struct dsd_vector* adsl_vect = NULL;
+    int inl_vect_count = 0;
+    BOOL bol_ret = TRUE;
+    const char* achl_message;

-   // Look for new node.
-   if(!m_htree1_avl_search(NULL,
-                           &dss_control,
-                           &dss_workspace,
-                           &(adsl_new_sess->ds_entry.dsc_avl_hdr)))
-   {
-      m_hl1_printf("AVL ERROR!");
-      delete adsl_new_sess->ds_entry.adsc_cli_conf;
-      delete adsl_new_sess;
-      // Leave critical section.
-      LEAVECRITSEC(dsg_critsec_avl);
-      return NULL;
-   }
-   else
-   {
-      // Node already exists.
-      if(dss_workspace.adsc_found != NULL)
-      {
-#define ADSL_AVL_SESS ((struct dsd_avl_session *) ((char*)dss_workspace.adsc_found - offsetof(dsd_avl_session, ds_entry)))
-         while (ADSL_AVL_SESS->ds_entry.iec_sess_proto == ied_tunc_htcp)
-         { // HTCP.
-           if (adsp_tun_contr1->iec_tunc != ied_tunc_htcp) break;
+    if (unp_length == 0)
+        return TRUE;

-           // HTCP session with this IP already exits - insert in linked list.
+    for (inl_vect_count = 0; inl_vect_count < inl_vect_len; ++inl_vect_count) {
+        while (adsl_data != NULL &&
+               adsl_data->achc_ginp_cur == adsl_data->achc_ginp_end) {

-           // When passing a handle (third parameter) to dsd_htcp_session
-           // constructor,the constructor inserts the new session in the linked
-           // list.
-           dsd_htcp_ip_info* ads_info =
-              (dsd_htcp_ip_info*)ADSL_AVL_SESS->ds_entry.a_extend;
-           dsd_htcp_session* ads_htcp_sess =
-               (dsd_htcp_session*)m_init_sess(adsp_tun_contr1,
-                                              ull_index_if,
-                                              ads_info);
-           ads_htcp_sess->ads_ip_info = ads_info;
-           dsd_session_info* ads_htcp_sess_info
-              = &ads_htcp_sess->ds_handle_info;
-           delete adsl_new_sess->ds_entry.adsc_cli_conf;
-           delete adsl_new_sess;
-           LEAVECRITSEC(dsg_critsec_avl);
-           return ads_htcp_sess_info;
-         }
-#undef ADSL_AVL_SESS
-         m_hl1_printf("AVL TREE COLLISION!");
-         delete adsl_new_sess->ds_entry.adsc_cli_conf;
-         delete adsl_new_sess;
-         // Leave critical section.
-         LEAVECRITSEC(dsg_critsec_avl);
-         // Indicate that INETA is already in use.
-         *abop_ipok = false;
-         return NULL;
-      }
-      // Insert new session node into tree.
-      if(!m_htree1_avl_insert(NULL,
-                              &dss_control,
-                              &dss_workspace,
-                              &(adsl_new_sess->ds_entry.dsc_avl_hdr)))
-      {
-         m_hl1_printf("AVL ERROR!");
-         delete adsl_new_sess->ds_entry.adsc_cli_conf;
-         delete adsl_new_sess;
-         // Leave critical section.
-         LEAVECRITSEC(dsg_critsec_avl);
-         return NULL;
-      }
-   }
+            adsl_data = adsl_data->adsc_next;
+        }
+        if (adsl_data == NULL) {
+            // TODO: warning message
+            bol_ret = FALSE;
+            break;
+        }

-   // Leave critical section.
-   LEAVECRITSEC(dsg_critsec_avl);
+        dsrl_vect[inl_vect_count].ach_buf = adsl_data->achc_ginp_cur;
+        dsrl_vect[inl_vect_count].ul_size =
+            adsl_data->achc_ginp_end - adsl_data->achc_ginp_cur;

-   ull_index_if = 0;
-//#ifdef XYZ1
-//#ifndef B090316
-   // TODO - Here I need to know the INETA of the adapter which is to be used
-   // with this connection!!!
-   ulp_ifaddr = 0XF06E6F0A;
-//#endif
-//#endif
-// ulp_ifaddr = *((unsigned long int *) dss_tun_intf_1.chrc_ineta_locale);
+        if (dsrl_vect[inl_vect_count].ul_size >= unl_length) {
+            dsrl_vect[inl_vect_count].ul_size = unl_length;
+            ++inl_vect_count;
+            adsl_vect = dsrl_vect;
+            break;
+            // if (dsg_vnic.m_write(dsrl_vect, inl_vect_count + 1) < 0) {
+            //     // TODO: warning message
+            //     bol_ret = FALSE;
+            //     break;
+            // }
+        }

-#if defined WIN32 || WIN64
+        adsl_data = adsl_data->adsc_next;
+        unl_length -= dsrl_vect[inl_vect_count].ul_size;
+    }

-#ifdef B090316
-   // Try to create PARP entry for this client.
-   ull_index_if = m_getindex_if(ulp_ifaddr);
-   if(ull_index_if < 0)
-      m_hl1_printf("Could not create PARP entry for this connection.\n");
-   else
-   {
-      iml_retval = CreateProxyArpEntry(adsl_new_sess->ulc_key_ineta,
-                                       0xFFFFFFFF,
-                                       ull_index_if);
-      if(iml_retval != NO_ERROR)
-         m_hl1_printf("Could not create PARP entry for this connection.\n");
-   }
-#endif
-   ull_index_if = m_getindex_if(ulp_ifaddr);
-   iml_retval = CreateProxyArpEntry(adsl_new_sess->ds_entry.umc_key_ineta,
-                                    0xFFFFFFFF,
-                                    ull_index_if);
-   if (iml_retval != NO_ERROR)
-   {
-      dwl1 = FormatMessageA( FORMAT_MESSAGE_IGNORE_INSERTS |
-                              FORMAT_MESSAGE_FROM_SYSTEM,
-                             NULL,
-                             iml_retval,
-                             0,             // Default language.
-                             chrl_work1,
-                             sizeof(chrl_work1),
-                             NULL );
-      m_hl1_printf( "xshusip01-l%05d-W Could not create PARP entry for this connection 0X%08X \"%s\"",
-                    __LINE__, iml_retval, chrl_work1 );
-   }
-#endif
+    // packet does not fit in inl_vect_len blocks

-   // Commented (Duca). Route creation has now moved to Mr. Brandstaetter's
-   // control.
-   /*
-   // Try to create static route for this client.
-   sockaddr_storage* adsl_rt_dest     = NULL;
-   sockaddr_storage* adsl_rt_mask     = NULL;
-   sockaddr_storage* adsl_rt_next_hop = NULL;
+    if (bol_ret && adsl_vect == NULL) {
+        struct dsd_gather_i_1* adsl_search = adsl_data;
+        for (unsigned unl_rem = unl_length; unl_rem > 0; ) {
+            while (adsl_search != NULL &&
+                   adsl_search->achc_ginp_cur == adsl_search->achc_ginp_end) {

-#if defined WIN32 || WIN64
+                adsl_search = adsl_search->adsc_next;
+            }
+            if (adsl_search == NULL) {
+                // TODO: warning message
+                bol_ret = FALSE;
+                break;
+            }

-   adsl_rt_dest = &adsp_tun_contr1->dsc_soa_local;
+            ++inl_vect_count;
+            if (adsl_search->achc_ginp_cur + unl_rem <=
+                adsl_search->achc_ginp_end) {

-   sockaddr_in dsl_mask = { 0 };
-   dsl_mask.sin_family = AF_INET;
-   dsl_mask.sin_addr.S_un.S_addr = 0xFFFFFFFF;
-   adsl_rt_mask = (sockaddr_storage*)&dsl_mask;
+                unl_rem = 0;
+            } else {
+                unl_rem -=
+                    adsl_search->achc_ginp_end - adsl_search->achc_ginp_cur;
+            }
+        }

-   sockaddr_in dsl_next_hop = { 0 };
-   dsl_next_hop.sin_family = AF_INET;
-   dsl_next_hop.sin_addr.S_un.S_addr = *(uint32*)(dss_tun_intf_1.chrc_ineta_remote);
-   adsl_rt_next_hop = (sockaddr_storage*)&dsl_next_hop;
+        if (bol_ret) {
+            adsl_vect = (struct dsd_vector*)
+                malloc(inl_vect_count * sizeof(struct dsd_vector));
+            if (adsl_vect == NULL) {
+                // TODO: warning message
+                bol_ret = FALSE;
+            }
+        }

-#elif defined HL_LINUX
+        if (bol_ret) {
+            memcpy(adsl_vect, dsrl_vect,
+                   inl_vect_len * sizeof(struct dsd_vector));
+            inl_vect_count = inl_vect_len;

-   adsl_rt_dest = &adsp_tun_contr1->dsc_soa_local;
+            while (unl_length > 0) {
+                while (adsl_data->achc_ginp_cur == adsl_data->achc_ginp_end)
+                    adsl_data = adsl_data->adsc_next;

-   sockaddr_in dsl_mask = { 0 };
-   dsl_mask.sin_family = AF_INET;
-   dsl_mask.sin_addr.s_addr = 0xFFFFFFFF;
-   adsl_rt_mask = (sockaddr_storage*)&dsl_mask;
+                adsl_vect[inl_vect_count].ach_buf = adsl_data->achc_ginp_cur;
+                dsrl_vect[inl_vect_count].ul_size =
+                    adsl_data->achc_ginp_end - adsl_data->achc_ginp_cur;

-   sockaddr_in dsl_next_hop = { 0 };
-   dsl_next_hop.sin_family = AF_INET;
-   dsl_next_hop.sin_addr.s_addr = *(uint32*)(dss_tun_intf_1.chrc_ineta_remote);
-   adsl_rt_next_hop = (sockaddr_storage*)&dsl_next_hop;
+                if (dsrl_vect[inl_vect_count].ul_size > unl_length)
+                    dsrl_vect[inl_vect_count].ul_size = unl_length;

-#endif
+                unl_length -= dsrl_vect[inl_vect_count].ul_size;

-    m_create_route(adsl_rt_dest,
-                   adsl_rt_mask,
-                   adsl_rt_next_hop);
-    */
+                ++inl_vect_count;
+            }
+        }
+    }

+    if (bol_ret) {
+        bol_ret = dsg_vnic.m_write(adsl_vect, inl_vect_count) >= 0;
+    }

-#ifdef NOT_SYSTEM
-#endif
+    if ((img_wsp_trace_core_flags1 & HL_WT_CORE_HOB_TUN) != 0) {
+        if (bol_ret) {
+            achl_message = "TUN adapter gather write %u bytes "
+                "over internal network.";
+        } else {
+            achl_message = "TUN adapter failed to gather write %u bytes "
+                "over internal network.";
+        }

-   if (adsp_tun_contr1->iec_tunc == ied_tunc_htcp)
-   {
-       dsd_htcp_ip_info* ads_ip_info = new dsd_htcp_ip_info; // Initialized.
-       adsl_new_sess->ds_info.ads_sess =
-          m_init_sess(adsp_tun_contr1, ull_index_if, ads_ip_info);
-       dsd_htcp_session* ads_htcp_session =
-          (dsd_htcp_session*)adsl_new_sess->ds_info.ads_sess;
-       ads_ip_info->ads_avl_sess = adsl_new_sess;
-       ads_ip_info->u_if_idx = adsl_new_sess->ds_info.ads_sess->umc_if_idx;
-       adsl_new_sess->ds_entry.a_extend = ads_ip_info;
-       return &ads_htcp_session->ds_handle_info;
-   }
+        // m_do_wsp_trace can handle adsp_data being NULL or having less
+        // data than unp_length.
+        m_do_wsp_trace("CTUNSEND", HL_WT_CORE_HOB_TUN, 0, 0, adsp_data,
+                       unp_length, 48, achl_message, unp_length);
+    }

-   // Create session.
-   adsl_new_sess->ds_info.ads_sess = m_init_sess(adsp_tun_contr1, ull_index_if);
-   adsl_new_sess->ds_entry.a_extend = adsl_new_sess->ds_info.ads_sess;
+    if (adsl_vect != NULL && adsl_vect != dsrl_vect) {
+        free(adsl_vect);
+    }

+    return bol_ret;

-   // All OK: return pointer to new session node.
-   return adsl_new_sess;
-} // m_htun_new_sess().
+#endif // !defined NEW_HOB_TUN_1103
+}

-#endif //B100702
+extern "C" void* m_find_htun_ineta(struct sockaddr_storage*);

-extern PTYPE void m_htun_new_sess( struct dsd_tun_start1* adsp_tun_start1, struct dsd_tun_contr1* adsp_tun_contr1)
-{
-#ifndef NEW_HOB_TUN_1103
-   if(adsp_tun_start1->dsc_soa_local.ss_family != 2) //AF_INET
-   {
-      m_hl1_printf("Current version of TAP-Win32 only supports IPv4 when in TUN mode.");
-      return;
-   }
-#endif
+#ifndef B121024 // KS

-   //create session
-   m_init_sess(adsp_tun_start1, adsp_tun_contr1);
-} /* m_htun_new_sess()                                                 */
-
-#ifdef B100706
-extern PTYPE void m_htun_sess_close(dsd_tun_ppp_h dsp_husip_sess)
+extern "C" void m_htun_recv( void * ap_handle, int inp_offset,
+                             char *achp_data, int inp_len )
 {
-  int iml_retval;
-  unsigned long ull_index_if;
+    bool bol_ipv4 = false;
+    bool bol_ipv6 = false;
+    unsigned unl_prot = 0;
+    int inl_hlen = 0;

-   dsd_session* adsl_session;
+    if (inp_len > 0) {
+        switch (((unsigned char)(*achp_data) >> 4) & 0x0f) {
+        case 4: // IPv4
+            if (inp_len >= 20) {
+                inl_hlen = m_get_calc_ip_hlen(achp_data);
+                if (inl_hlen >= 20 && inp_len >= inl_hlen &&
+                    (int)m_get_ip_tlen(achp_data) <= inp_len) {

-    // check if session is HTCP
-    if (((dsd_session_info*)dsp_husip_sess)->ie_type == ied_tunc_htcp) {
-        ENTERCRITSEC(dsg_critsec_avl);
-        dsd_htcp_session* ads_htcps = (dsd_htcp_session*)(((dsd_session_info*)dsp_husip_sess)->ads_sess);
-        if (ads_htcps->ads_avl_sess == 0) {
-            // this is not the first item in linked list
-            ads_htcps->ads_previous->ads_next = ads_htcps->ads_next;
-            if (ads_htcps->ads_next != 0) {
-                ads_htcps->ads_next->ads_previous = ads_htcps->ads_previous;
+                    bol_ipv4 = true;
+                    unl_prot = m_get_ip_prot(achp_data);
+                }
             }
-            LEAVECRITSEC(dsg_critsec_avl);
-            ads_htcps->~dsd_htcp_session();
-            return;
-        } else if (ads_htcps->ads_next != 0) {
-            // the first item in linked list, but there are other items
-            // replace item in AVL tree
+            break;

-            ads_htcps->ads_next->us_next_port = ads_htcps->us_next_port;
-            ads_htcps->ads_next->ads_previous = 0;
-            ads_htcps->ads_next->ads_avl_sess = ads_htcps->ads_avl_sess;
-            ads_htcps->ads_avl_sess->ds_info.ads_sess = ads_htcps->ads_next;
-            ads_htcps->ads_avl_sess->ds_entry.a_extend = ads_htcps->ads_next;
-            LEAVECRITSEC(dsg_critsec_avl);
-            ads_htcps->~dsd_htcp_session();
-            return;
-//            ((dsd_avl_session*)dsp_husip_sess)->ds_info.ads_sess = ads_htcps->ads_next;
-//            ((dsd_avl_session*)dsp_husip_sess)->ds_entry.a_extend = ads_htcps->ads_next;
-        }
+        case 6: // IPv6
+            if (inp_len >= 40 &&
+                inp_len >= 40 + (int)m_get_ip6_plen(achp_data)) {

-
-#ifdef XYZ1
-            // TODO: is following the correct procedure to replace entry in AVL tree?
-            //create node struct to find
-            dsd_avl_sess_entry ds_search_node;
-            ds_search_node.ulc_key_ineta = *(u_long*) &((struct sockaddr_in *) &ads_htcps->adsc_sess_info->dsc_soa_local)->sin_addr;
-            //search for node struct
-            if(!m_htree1_avl_search(NULL, &dss_control, &dss_workspace, &(ds_search_node.dsc_avl_hdr)))
-            {  //search failed
-                m_hl1_printf("AVL ERROR!");
-                //leave critical section
-                LEAVECRITSEC(dsg_critsec_avl);
-                return;
+                inl_hlen = 40;
+                bol_ipv6 = true;
+                unl_prot = m_get_ip6_nh(achp_data);
             }
-            if(dss_workspace.adsc_found == NULL)
-            {  //matching node not found
-                m_hl1_printf("AVL ERROR: SPECIFIED NODE DOES NOT EXIST!");
-                //leave critical section
-                LEAVECRITSEC(dsg_critsec_avl);
-                return;
-            }
-            //remove the node just found from the AVL tree
-            if(!m_htree1_avl_delete(NULL, &dss_control, &dss_workspace))
-            {
-                m_hl1_printf("AVL ERROR!\n");
-                //leave critical section
-                LEAVECRITSEC(dsg_critsec_avl);
-                return;
-            }
-            dsd_avl_session* ads_sess = (dsd_avl_session*)ads_htcps->ads_next->vp_handle;
-            //search for node struct
-            if(!m_htree1_avl_search(NULL, &dss_control, &dss_workspace, &(ds_search_node.dsc_avl_hdr)))
-            {  //search failed
-                m_hl1_printf("AVL ERROR!");
-                //leave critical section
-                LEAVECRITSEC(dsg_critsec_avl);
-                return;
-            }
-            if(dss_workspace.adsc_found != NULL)
-            {  //matching node still found
-                m_hl1_printf("AVL ERROR: SPECIFIED NODE SHOULD NOT EXIST!");
-                //leave critical section
-                LEAVECRITSEC(dsg_critsec_avl);
-                return;
-            }
-            //insert new session node into tree
-            if(!m_htree1_avl_insert(NULL, &dss_control, &dss_workspace, &(ads_sess->ds_entry.dsc_avl_hdr)))
-            {
-                m_hl1_printf("AVL ERROR!");
-                //leave critical section
-                LEAVECRITSEC(dsg_critsec_avl);
-                return;
-            }
-            // TODO: was the above the correct procedure to replace entry in AVL tree?
-//#else // XYZ1
-            //create node struct to find
-            dsd_avl_sess ds_search_node;
-            ds_search_node.ulc_key_ineta = *(u_long*) &((struct sockaddr_in *) &ads_htcps->adsc_sess_info->dsc_soa_local)->sin_addr;
-            //search for node struct
-            if(!m_htree1_avl_search(NULL, &dss_control, &dss_workspace, &(ds_search_node.dsc_avl_hdr)))
-            {  //search failed
-                m_hl1_printf("AVL ERROR!");
-                //leave critical section
-                LEAVECRITSEC(dsg_critsec_avl);
-                return;
-            }
-            if(dss_workspace.adsc_found == NULL)
-            {  //matching node not found
-                m_hl1_printf("AVL ERROR: SPECIFIED NODE DOES NOT EXIST!");
-                //leave critical section
-                LEAVECRITSEC(dsg_critsec_avl);
-                return;
-            }
-            // BAD
-            *((dsd_avl_sess*)dss_workspace.adsc_found) = *(dsd_avl_sess*)ads_htcps->ads_next->vp_handle;
-//#endif // XYZ1
-
-            //leave critical section
-            LEAVECRITSEC(dsg_critsec_avl);
-            delete ((dsd_avl_session*)ads_htcps->vp_handle)->ds_entry.adsc_cli_conf;
-            delete (dsd_avl_session*)ads_htcps->vp_handle;
-            ads_htcps->~dsd_htcp_session();
-            return;
+            break;
         }
-#endif // XYZ1
+    }

-        // only this session in list, so fall through to remove IP address from system
-        LEAVECRITSEC(dsg_critsec_avl);
-        adsl_session = ads_htcps;
-        dss_nodes_to_del.insert(dss_nodes_to_del.end(), ads_htcps->ads_avl_sess);
-        ads_htcps->ads_avl_sess->ds_entry.a_extend = 0;
-    } else {
-        adsl_session = (dsd_session*)(((dsd_avl_session*)dsp_husip_sess)->ds_entry.a_extend);
-        // check if session obj is NULL
-        if(adsl_session != NULL)
-        { //not NULL: session still open
-          //add node to list of nodes to delete
-          dss_nodes_to_del.insert(dss_nodes_to_del.end(), (dsd_avl_session*)dsp_husip_sess);
-        }
+    if (!bol_ipv4 && !bol_ipv6) {
+        m_hlnew_printf(HLOG_WARN1, "HWSPTUN???? Received malformed packet on TUN interface.");
+        m_htun_relrecvbuf(ap_handle);
+        return;
     }

+    bool bol_tcp = unl_prot == 6 && inp_len >= inl_hlen + 20;

+    // TODO: handle ICMP for HTCP (currenlty useless since HTCP does not yet support ICMP)

-  //get session object from node
-//  dsd_session* adsl_session = (dsd_session*)(((dsd_avl_session*)dsp_husip_sess)->ds_entry.a_extend);
+    struct sockaddr_storage dsl_address;
+    memset(&dsl_address, 0, sizeof(dsl_address));
+    if (bol_ipv4) {
+        sockaddr_in* adsl_sa = (sockaddr_in*)&dsl_address;
+        adsl_sa->sin_family = AF_INET;
+        memcpy(&adsl_sa->sin_addr.s_addr, m_get_ip_dst_addr_buf(achp_data), 4);
+        if (bol_tcp)
+            memcpy(&adsl_sa->sin_port, achp_data + inl_hlen + 2, 2);
+    } else { // here bol_ipv6 is true
+        sockaddr_in6* adsl_sa6 = (sockaddr_in6*)&dsl_address;
+        adsl_sa6->sin6_family = AF_INET6;
+        memcpy(&adsl_sa6->sin6_addr.s6_addr, m_get_ip6_dst_addr(achp_data), 16);
+        if (bol_tcp)
+            memcpy(&adsl_sa6->sin6_port, achp_data + inl_hlen + 2, 2);
+    }

-  // check if session obj is NULL
-  if(adsl_session != NULL)
-  { //not NULL: session still open
-    //add node to list of nodes to delete
-//    dss_nodes_to_del.insert(dss_nodes_to_del.end(), (dsd_avl_session*)dsp_husip_sess);
+    dsd_htun_h vp_handle = m_find_htun_ineta(&dsl_address);
+    if (vp_handle != NULL) {
+        dsd_htun_handle* adsl_hth = (dsd_htun_handle*)vp_handle;
+        if (adsl_hth->iec_tunc == ied_tunc_htcp) {
+            struct dsd_htcp_htun* adsl_hh = (struct dsd_htcp_htun*)adsl_hth->vpc_contr;
+            m_htcp_packet_from_network(adsl_hh, ap_handle, inp_offset, achp_data, inp_len);
+        }
+        else if(adsl_hth->iec_tunc == ied_tunc_ppp) {
+            struct dsd_ppp_session* adsl_ppp_sess = (struct dsd_ppp_session*)adsl_hth->vpc_contr;
+            adsl_ppp_sess->mc_encapsulate_msg(ap_handle, (byte*)achp_data, inp_len);
+        } else {
+            dsd_session* adsl_session = (dsd_session*)adsl_hth->vpc_contr;
+            // NOTE: adsl_session can be ppp or pppt session
+            //the IP packet is encapsulated in a session header, and sent to the WSP module
+            adsl_session->mc_encapsulate_msg(ap_handle, (byte*)achp_data, inp_len);
+        }
+    } else { // vp_handle == NULL
+        if (bol_tcp) {
+            // if TCP packet received, send RST
+            // uses some utilities from HTCP
+            char chrl_rst[60];
+            uint32_t uml_rlen = sizeof(chrl_rst);
+            if (bol_ipv4) {
+                uml_rlen = m_ip_tcp_answer_reset(chrl_rst, uml_rlen, achp_data, inp_len, 0);
+            } else { // bol_ipv6
+                uml_rlen = m_ip6_tcp_answer_reset(chrl_rst, uml_rlen, achp_data, inp_len);
+            }
+            if (uml_rlen > 0) {
+                m_hlnew_printf(HLOG_WARN1, "HWSPTUN1018 Received unexpected TCP segment on TUN interface, replying with RST.");
+                m_se_husip_send((unsigned char*)chrl_rst, uml_rlen);
+            } else {
+                m_hlnew_printf(HLOG_WARN1, "HWSPTUN1019 Received unexpected TCP segment on TUN interface, ignoring.");
+            }
+        } else {
+            m_hlnew_printf(HLOG_WARN1, "HWSPTUN1020 Received unexpected IP packet (protocol %u) on TUN interface, ignoring.", unl_prot);
+        }
+        m_htun_relrecvbuf(ap_handle);
+    } // vp_handle == NULL
+}

+//
+// Executes a loop to read data incoming over the TUN adapter.
+// This function is called in a seperate thread, as soon as a TUN adapter is
+// activated. It constantly reads IP packets going over the virtual
+// TUN adapter, reads their destination IPs, determines the session
+// they belong to, and calls upon the respective session object for further
+// processing. Once processed by the session object these packets are
+// forwarded to the WSP module, in order to be sent to the client machine.
+//
+// @param  ap_param  Not used.
+//
+// @return  Always returns 0.
+//

-    //start new timer
-// 17.03.09 KB memory adsl_newtimer is too short, how does it find data to belongs to ???
-    dsd_timer_ele* adsl_newtimer = new dsd_timer_ele;
-    memset(adsl_newtimer, 0, sizeof(dsd_timer_ele));
-    dss_active_timers.insert(dss_active_timers.end(), adsl_newtimer);
-    adsl_newtimer->amc_compl = m_del_next_node;
-    adsl_newtimer->ilcwaitmsec = 60000;
-    adsl_newtimer->adsctiele_next = NULL;
-    adsl_newtimer->adsctiele_prev = NULL;
-    m_time_set(adsl_newtimer, false);
+THDRET WINAPI m_htun_read_loop(LPVOID ap_param)
+{
+   // Number of bytes reserved for PPP Header, HOB-TUN Header & SSTP Header.
+    // This is also used by HTCP for packet control information.
+   const int iml_OFFSET = 32;
+   int iml1; // Working var.

-#if defined WIN32 || WIN64
+   void* al_handle;  // Handle to buffer obtained from WSP module.
+   char* achl_data;  // Ptr to the start of data field in the obtained buffer.
+   int iml_data_len; // Length of data field in the obtained buffer.

-    //try to delete PARP entry for this client
-    iml_retval = DeleteProxyArpEntry(((dsd_avl_session*)(dsp_husip_sess))->ds_entry.ulc_key_ineta, 0xFFFFFFFF, adsl_session->ulc_if_idx);
-    if(iml_retval != NO_ERROR)
-      m_hl1_printf("Failed to delete PARP entry for this connection.\n");
+   // Read IP pkt from intranet.
+   unsigned int uml_bytes_read;           // Int to hold number of bytes read.
+   while(true)
+   {
+      // Get new buffer from WSP module.
+      iml_data_len = m_htun_getrecvbuf(&al_handle, &achl_data);

-#endif
+      // Block until a single incoming IP packet is read on the TUN adapter.

-    //try to delete static route for this client
-    char chrl_cmd[1024];
-    sprintf(chrl_cmd, "route delete %u.%u.%u.%u",
-                      *((unsigned char*)(&(((dsd_avl_session*)(dsp_husip_sess))->ds_entry.ulc_key_ineta)) + 0),
-                      *((unsigned char*)(&(((dsd_avl_session*)(dsp_husip_sess))->ds_entry.ulc_key_ineta)) + 1),
-                      *((unsigned char*)(&(((dsd_avl_session*)(dsp_husip_sess))->ds_entry.ulc_key_ineta)) + 2),
-                      *((unsigned char*)(&(((dsd_avl_session*)(dsp_husip_sess))->ds_entry.ulc_key_ineta)) + 3));
-    system(chrl_cmd);
+#ifdef NEW_HOB_TUN_1103
+      iml1 = m_readone_blk(dss_tun_intf_1.dsc_tunhandle,
+                           (unsigned char*)(achl_data + iml_OFFSET),
+                           iml_data_len - iml_OFFSET,
+                           NULL,
+                           (int*)&uml_bytes_read);

-    //delete session (TODO: This might need to be in a critical section, but that would not be the case if
-    //a single session is used/accessed by a single thread)
-    if (adsl_session->adsc_sess_info->iec_tunc == ied_tunc_htcp) {
-      TUN_CONTR_HTCP_SESSION(adsl_session->adsc_sess_info)->~dsd_htcp_session();
-    } else {
-      delete adsl_session;
-    }
-    ((dsd_avl_session*)dsp_husip_sess)->ds_entry.a_extend = NULL;
-  }
-}
-#endif // B100706
+#else

-extern PTYPE void m_htun_sess_close(dsd_htun_h dsp_husip_sess)
-{
-   int iml_retval;
+      fd_set dsl_fd_read;
+      FD_ZERO(&dsl_fd_read);
+      FD_SET(dsg_tun_hdl, &dsl_fd_read);
+      iml1 = select(dsg_tun_hdl + 1, &dsl_fd_read, NULL, NULL, NULL);

-   dsd_tun_contr1* adsl_tun_contr1 = (dsd_tun_contr1*)dsp_husip_sess;
-
-   dsd_session* adsl_session =
-      (dsd_session*)&adsl_tun_contr1->achc_session_buffer;
-   // NOTE: adsl_session can be htcp, ppp or pppt session
-#ifndef B120213
-   if (adsl_session->mc_signal_using()) {
-   adsl_session->mc_close();
-      adsl_session->mc_unsignal_using();
-   }
-#else
-   adsl_session->mc_close();
+      if (iml1 >= 0) {
+	iml1 = dsg_vnic.m_read((unsigned char*)(achl_data + iml_OFFSET), iml_data_len - iml_OFFSET, uml_bytes_read);
+      }
 #endif

-#ifdef B100812
-   //delete session (TODO: This might need to be in a critical section, but that would not be the case if
-   //a single session is used/accessed by a single thread)
-   switch (adsl_tun_contr1->iec_tunc) {
-   case ied_tunc_htcp:
-      DEF_HTCP_SESSION(adsl_tun_contr1)->~dsd_htcp_session();
-      break;
-   case ied_tunc_ppp:
-      DEF_PPP_SESSION(adsl_tun_contr1)->~dsd_ppp_session();
-      break;
-   case ied_tunc_sstp:
-      DEF_SSTP_SESSION(adsl_tun_contr1)->~dsd_sstp_session();
-      break;
-   }
-#endif
-}
+      if(iml1 < 0)
+      {  // Read operation failed.
+         // Release buffer obtained from WSP module.
+         m_htun_relrecvbuf(al_handle);
+         m_hlnew_printf(HLOG_WARN1, "HWSPTUN???? TUN read operation failed.");
+         break;
+      }

-extern PTYPE BOOL m_se_husip_send(unsigned char *aucp_data,
-                                  int imp_length)
-{
-// if(m_writeone_blk(as_htun,
-//                   aucp_data,
-//                   imp_length,
-//                   NULL,
-//                   &iml_bytes_written) < 0)
+      if ((img_wsp_trace_core_flags1 & HL_WT_CORE_HOB_TUN) != 0) {
+          dsd_gather_i_1 dsl_gath;
+          dsl_gath.achc_ginp_cur = (achl_data + iml_OFFSET);
+          dsl_gath.achc_ginp_end = dsl_gath.achc_ginp_cur + uml_bytes_read;
+          dsl_gath.adsc_next = NULL;
+          m_do_wsp_trace("CTUNRECV", HL_WT_CORE_HOB_TUN, 0, 0, &dsl_gath,
+                         uml_bytes_read, 48,
+                         "TUN adapter read %d bytes over internal network.", uml_bytes_read);
+      }

-#ifndef NEW_HOB_TUN_1103
-   int iml_bytes_written;
+      m_htun_recv(al_handle, iml_OFFSET, achl_data + iml_OFFSET, uml_bytes_read);

-   if(m_writeone_blk(dss_tun_intf_1.dsc_tunhandle,
-                     aucp_data,
-                     imp_length,
-                     NULL,
-                     &iml_bytes_written) < 0)
-      return false;
-   else
-      return true;
+   } // loop forever

-#else
-   unsigned int iml_bytes_written;
-
-   if(dsg_vnic.m_write(aucp_data,
-                       imp_length,
-                       iml_bytes_written) < 0)
-      return false;
-   else
-   {
-      dsd_gather_i_1 dsl_gath;
-      dsl_gath.achc_ginp_cur = (char*)aucp_data;
-      dsl_gath.achc_ginp_end = dsl_gath.achc_ginp_cur + imp_length;
-      dsl_gath.adsc_next = NULL;
-      m_do_wsp_trace("CTUNSEND", HL_WT_CORE_HOB_TUN, 0, 0, &dsl_gath,
-                     imp_length, 20,
-                     "TUN adapter write %d bytes over internal network.", imp_length);
-      return true;
-   }
-#endif
+   // only arrive here in case of error reading from TUN
+   return NULL;
 }

-extern "C" void* m_find_htun_ineta(struct sockaddr_storage*);
+#else // B121024 KS

-//
-// Executes a loop to read data incoming over the TUN adapter.
-// This function is called in a seperate thread, as soon as a TUN adapter is
-// activated. It constantly reads IP packets going over the virtual
-// TUN adapter, reads their destination IPs, determines the session
-// they belong to, and calls upon the respective session object for further
-// processing. Once processed by the session object these packets are
-// forwarded to the WSP module, in order to be sent to the client machine.
-//
-// @param  ap_param  Not used.
-//
-// @return  Always returns 0.
-//
-static THDRET WINAPI m_htun_read_loop(LPVOID ap_param)
+THDRET WINAPI m_htun_read_loop(LPVOID ap_param)
 {
    // Number of bytes reserved for PPP Header, HOB-TUN Header & SSTP Header.
    const int iml_OFFSET = 20;
@@ -1082,7 +745,7 @@
 //                         NULL,
 //                         &iml_bytes_read);

-#ifndef NEW_HOB_TUN_1103
+#ifdef NEW_HOB_TUN_1103
       iml1 = m_readone_blk(dss_tun_intf_1.dsc_tunhandle,
                            (unsigned char*)(achl_data + iml_OFFSET),
                            iml_data_len - iml_OFFSET,
@@ -1173,21 +836,11 @@
           //leave critical section
           LEAVECRITSEC(dsg_critsec_avl);
 #endif
-          dsd_tun_contr1* adsl_tc = (dsd_tun_contr1*)vp_handle;
-          dsd_session* adsl_session = (dsd_session*)&adsl_tc->achc_session_buffer;
+          dsd_tun_contr_conn* adsl_tun_contr_conn = (dsd_tun_contr_conn*)vp_handle;
+          dsd_session* adsl_session = (dsd_session*)&adsl_tun_contr_conn->dsc_session_buffer;
           // NOTE: adsl_session can be htcp, ppp or pppt session
           //the IP packet is encapsulated in a session header, and sent to the WSP module
-#ifndef B120213
-          if (adsl_session->mc_signal_using()) {
-             if (!adsl_session->boc_sess_closed)
-             adsl_session->mc_encapsulate_msg(al_handle, (byte*)achl_data + iml_OFFSET, uml_bytes_read);
-             adsl_session->mc_unsignal_using();
-          } else {
-              m_htun_relrecvbuf(al_handle);
-          }
-#else
           adsl_session->mc_encapsulate_msg(al_handle, (byte*)achl_data + iml_OFFSET, uml_bytes_read);
-#endif
       } else { // vp_handle == NULL
 #ifdef B100706
           LEAVECRITSEC(dsg_critsec_avl);
@@ -1204,9 +857,8 @@
                 dsd_htun_h vp_handle = m_find_htun_ineta(&dsl_address);

                 if (vp_handle != NULL) {
-                    dsd_tun_contr1* adsl_tc = (dsd_tun_contr1*)vp_handle;
-                    dsd_session* adsl_session = (dsd_session*)&adsl_tc->achc_session_buffer;
-                    if (!adsl_session->boc_sess_closed)
+                    dsd_tun_contr_conn* adsl_tun_contr_conn = (dsd_tun_contr_conn*)vp_handle;
+                    dsd_session* adsl_session = (dsd_session*)&adsl_tun_contr_conn->dsc_session_buffer;
                     adsl_session->mc_encapsulate_msg(al_handle, (byte*)achl_data + iml_OFFSET, uml_bytes_read);
                 } else {
                     m_hlnew_printf(HLOG_WARN1, "HWSPTUN1016W Received unexpected ICMP packet on TUN interface, ignoring.");
@@ -1262,6 +914,8 @@
    return NULL;
 }

+#endif // B121024 KS
+
 #if defined WIN32 || WIN64

 static int m_getindex_if(unsigned long ulp_ifaddr)
@@ -1343,63 +997,7 @@

 #endif

-#ifdef B100706
-static void m_del_next_node(struct dsd_timer_ele* dsl_timer_ele_w1)
-{
-  // Get front element of vector.
-  dsd_avl_session* adsl_node_to_delete = dss_nodes_to_del.front();

-  // Remove the node from the tree.
-
-  // Enter critical section.
-  ENTERCRITSEC(dsg_critsec_avl);
-
-  // Find the specified node in the AVL tree.
-  if(!m_htree1_avl_search(NULL,
-                          &dss_control,
-                          &dss_workspace,
-                          &(adsl_node_to_delete->ds_entry.dsc_avl_hdr)))
-  {
-    m_hl1_printf("AVL ERROR!\n");
-    // Leave critical section.
-    LEAVECRITSEC(dsg_critsec_avl);
-    return;
-  }
-  if(dss_workspace.adsc_found == NULL)
-  {
-    m_hl1_printf("AVL DELETE ERROR: SPECIFIED NODE DOES NOT EXIST!\n");
-    // Leave critical section.
-    LEAVECRITSEC(dsg_critsec_avl);
-    return;
-  }
-  else
-  {
-    // Remove the node just found from the AVL tree.
-    if(!m_htree1_avl_delete(NULL, &dss_control, &dss_workspace))
-    {
-      m_hl1_printf("AVL ERROR!\n");
-      // Leave critical section.
-      LEAVECRITSEC(dsg_critsec_avl);
-      return;
-    }
-    // Leave critical section.
-    LEAVECRITSEC(dsg_critsec_avl);
-  }
-
-  // Destroy the element.
-  delete adsl_node_to_delete->ds_entry.adsc_cli_conf;
-  delete adsl_node_to_delete;
-
-  // Remove the element from the vector.
-  dss_nodes_to_del.erase(dss_nodes_to_del.begin());
-
-  // Fetch & delete the corresponding timer.
-  dsd_timer_ele* adsl_timer_to_delete = dss_active_timers.front();
-  delete adsl_timer_to_delete;
-  dss_active_timers.erase(dss_active_timers.begin());
-}
-#endif // B100706
-
 extern PTYPE void m_wsptun_reset_conf(dsd_wsptun_conf_1* adsp_wsptun_newconfig)
 {

@@ -1419,109 +1017,70 @@
   LEAVECRITSEC(dsg_critsec_wspconf);
 }

-#ifdef B080924
-extern PTYPE void m_se_cansend(dsd_tun_ppp_h dsp_hdl_sess)
-{
-   // Get session object from node.
-   dsd_session* adsl_session =
-      (dsd_session*)(((dsd_avl_sess*)dsp_hdl_sess)->a_extend);
-   // Signal event to resume data transmission to client.
-   SetEvent(adsl_session->dsc_eve_cansend);
-}
-#endif
 // Defined m_htun_sess_canrecv, since this was being called by WSP,
 // and was apparently not implemented anywhere.
 extern PTYPE void m_htun_sess_canrecv(dsd_htun_h dsp_hdl_sess)
 {
-   // Get session object from node.
-   dsd_session* adsl_session =
-       (dsd_session*)&((dsd_tun_contr1*)dsp_hdl_sess)->achc_session_buffer;
+   dsd_htun_handle* adsl_hth = (dsd_htun_handle*)dsp_hdl_sess;

+   if (adsl_hth->iec_tunc == ied_tunc_htcp) {
+      struct dsd_htcp_htun* adsl_hh = (struct dsd_htcp_htun*)adsl_hth->vpc_contr;
+      m_htcp_sess_canrecv(adsl_hh);
+      return;
+   }
+   else if (adsl_hth->iec_tunc == ied_tunc_ppp) {
+      struct dsd_ppp_session* adsl_ppp_sess = (struct dsd_ppp_session*)adsl_hth->vpc_contr;
+      adsl_ppp_sess->mc_can_send();
+      return;
+   }
+
+   dsd_session* adsl_session = (dsd_session*)adsl_hth->vpc_contr;
+
    // Indicate that it is OK to resume data transmission to client.
    // should be inside mc_can_send: adsl_session->boc_cansend = true;
-#ifndef B120213
-   if (adsl_session->mc_signal_using()) {
-      if (!adsl_session->boc_sess_closed)
-      adsl_session->mc_can_send();
-      adsl_session->mc_unsignal_using();
-   }
-#else
    adsl_session->mc_can_send();
-#endif
 }

-#ifdef B100706
-extern PTYPE void m_htun_sess_send(dsd_htun_h dsp_session,
-                                   struct dsd_gather_i_1* adsp_gather)
-{
-  // Get ptr to existing sstp session object.
-//  dsd_session* adsl_session = (dsd_session*)(((dsd_avl_session*)dsp_session)->ds_entry.a_extend);
-  //dsd_session* adsl_session = (dsd_session*)(((dsd_avl_session*)dsp_session)->ds_info.ads_sess);
-    dsd_session* adsl_session = (dsd_session*)(((dsd_tun_contr1*)dsp_session)->chrc_htcp_session);
-
-  // Check if session ptr is NULL.
-  if(adsl_session != NULL)
-  { // Not NULL: session still open.
-     adsl_session->mc_interpret_msg(adsp_gather);
-    // Check if session has been closed.
-    if(adsl_session->boc_sess_closed == true)
-    {
-      // Remove from AVL tree & Delete session instance.
-       m_htun_sess_close(dsp_session);
-    }
-  }
-}
-#endif
-
 extern PTYPE void m_htun_sess_send( struct dsd_hco_wothr *adsp_hco_wothr,
                                     dsd_htun_h dsp_session,
                                     struct dsd_gather_i_1* adsp_gather )
 {
-    dsd_session* adsl_session = (dsd_session*)(&((dsd_tun_contr1*)dsp_session)->achc_session_buffer);
+   dsd_htun_handle* adsl_hth = (dsd_htun_handle*)dsp_session;

-#ifndef B120213
-   if (!adsl_session->mc_signal_using())
-       return;
-#endif
+   if (adsl_hth->iec_tunc == ied_tunc_htcp) {
+      struct dsd_htcp_htun* adsl_hh = (struct dsd_htcp_htun*)adsl_hth->vpc_contr;
+      m_htcp_sess_send(adsl_hh, adsp_gather);
+      return;
+   }
+   else if (adsl_hth->iec_tunc == ied_tunc_ppp) {
+      struct dsd_ppp_session* adsl_ppp_sess = (struct dsd_ppp_session*)adsl_hth->vpc_contr;
+      dsd_tun_contr_conn* adsl_tun_contr_conn = adsl_ppp_sess->adsc_tun_contr_conn;
+      adsl_ppp_sess->mc_interpret_msg(adsp_gather, adsp_hco_wothr);
+      if(adsl_ppp_sess->boc_sess_closed)
+      {
+          adsl_ppp_sess->mc_close();
+          m_htun_session_end(adsl_tun_contr_conn, -1);
+      }
+      return;
+   }

-    if (!adsl_session->boc_sess_closed)
+   dsd_session* adsl_session = (dsd_session*)adsl_hth->vpc_contr;
+   dsd_tun_contr_conn* adsl_tun_contr_conn = adsl_session->adsc_tun_contr_conn;
+
     adsl_session->mc_interpret_msg(adsp_gather, adsp_hco_wothr);
     // Check if session has been closed.
     if(adsl_session->boc_sess_closed)
     {
        // Delete session instance.
-       dsd_tun_contr1* adsl_tun_contr1 = (dsd_tun_contr1*)dsp_session;
+        //////////dsd_tun_contr_conn* adsl_tun_contr_conn = (dsd_tun_contr_conn*)dsp_session;

-       dsd_session* adsl_session =
-          (dsd_session*)&adsl_tun_contr1->achc_session_buffer;
+       //dsd_session* adsl_session =
+       //   (dsd_session*)&adsl_tun_contr_conn->dsc_session_buffer;
        // NOTE: adsl_session can be htcp, ppp or pppt session
        adsl_session->mc_close();
        // NOTE: not really - cannot be htcp which uses different mechanism KS 2012-02-13

        // Inform WSP re session close.
-       m_htun_session_end(adsl_tun_contr1, -1);
+       m_htun_session_end(adsl_tun_contr_conn, -1);
     }
-
-#ifndef B120213
-   adsl_session->mc_unsignal_using();
-#endif
 }
-
-#ifdef B120213 // code below not used, and incorrect
-// The class parameter is allowed, even though the full definition of the class
-// is not available.
-// This is allowed because no members of the class are accessed at any time.
-// As a result, this function does not need to know anything about the class.
-// It is sufficient to use a "stub" of the class.
-extern "C" void m_htun_htcp_critsect_enter
-   (class dsc_htcp_session* adsp_htcp_session)
-{
-   m_htun_critsect_enter(adsp_htcp_session);
-}
-
-extern "C" void m_htun_htcp_critsect_leave
-   (class dsc_htcp_session* adsp_htcp_session)
-{
-   m_htun_critsect_leave(adsp_htcp_session);
-}
-#endif // B120213
\ No newline at end of file
Index: hob-htcp-int-01.h
===================================================================
--- hob-htcp-int-01.h	(revision 0)
+++ hob-htcp-int-01.h	(revision 6)
@@ -0,0 +1,110 @@
+/******************************************************************************
+ * File name: hob-htcp-int-01.h
+ *
+ * Provides typedefs for 8, 16, 32 and 64 bit signed and unsigned integers.
+ * Also provides bool in C.
+ *
+ * Author: Kevin Spiteri
+ * Copyright: Copyright (c) HOB Software 2011
+ ******************************************************************************/
+
+#ifndef HOB_HTCP_INT_01_H
+#define HOB_HTCP_INT_01_H
+
+#if __STDC_VERSION__ >= 199901L /* C99 */
+
+#include <stdint.h>
+
+#elif defined _MSC_VER
+
+#if _MSC_VER >= 1600 /* Visual Studio 2010 */
+
+#include <stdint.h>
+
+#else /* _MSC_VER < 1600 */
+
+typedef unsigned __int8 uint8_t;
+typedef unsigned __int16 uint16_t;
+typedef unsigned __int32 uint32_t;
+typedef unsigned __int64 uint64_t;
+
+typedef __int8 int8_t;
+typedef __int16 int16_t;
+typedef __int32 int32_t;
+typedef __int64 int64_t;
+
+#endif /* _MSC_VER < 1600 */
+
+#else /* __STDC_VERSION__ < 199901L && !defined _MSC_VER */
+
+
+#include <limits.h>
+
+
+typedef unsigned char uint8_t;
+typedef signed char int8_t;
+
+
+#if SHRT_MAX == 32767
+
+typedef unsigned short uint16_t;
+typedef short int16_t;
+
+#else /* SHRT_MAX != 32767 */
+
+#if INT_MAX == 32767
+typedef unsigned uint16_t;
+typedef int int16_t;
+#else /* INT_MAX != 32767 */
+#error "cannot find 16-bit integer type"
+#endif /* INT_MAX != 32767 */
+
+#endif /* SHRT_MAX != 32767 */
+
+
+#if INT_MAX == 2147483647
+
+typedef unsigned uint32_t;
+typedef int int32_t;
+
+#else /* INT_MAX != 2147483647 */
+
+#if LONG_MAX == 2147483647L
+typedef unsigned long uint32_t;
+typedef long int32_t;
+#else /* LONG_MAX != 2147483647L */
+#error "cannot find 32-bit integer type"
+#endif /* LONG_MAX != 2147483647L */
+
+#endif /* INT_MAX != 2147483647 */
+
+
+#if LONG_MAX == 9223372036854775807L
+
+typedef unsigned long uint64_t;
+typedef long int64_t;
+
+#else /* LONG_MAX != 9223372036854775807L */
+
+#if defined LLONG_MAX && LLONG_MAX == 9223372036854775807LL
+typedef unsigned long long uint64_t;
+typedef long long int64_t;
+#else /* !defined LLONG_MAX || LLONG_MAX != 9223372036854775807LL */
+#error "cannot find 64-bit integer type"
+#endif /* !defined LLONG_MAX || LLONG_MAX != 9223372036854775807LL */
+
+#endif /* LONG_MAX != 9223372036854775807L */
+
+
+#endif /* __STDC_VERSION__ < 199901L && !defined _MSC_VER */
+
+
+#ifndef __cplusplus
+
+#define bool unsigned char
+#define false 0
+#define true (!false)
+
+#endif /* !__cplusplus */
+
+#endif /* HOB_HTCP_INT_01_H */
Index: hob-tun01.h
===================================================================
--- hob-tun01.h	(revision 2)
+++ hob-tun01.h	(revision 6)
@@ -13,6 +13,8 @@
 //|  Copyright (C) HOB Germany 2009                                   |
 //|  Copyright (C) HOB Germany 2010                                   |
 //|  Copyright (C) HOB Germany 2011                                   |
+//|  Copyright (C) HOB Germany 2012                                   |
+//|  Copyright (C) HOB Germany 2013                                   |
 //|                                                                   |
 //| REQUIRED PROGRAMS:                                                |
 //| ------------------                                                |
@@ -47,13 +49,25 @@
 #define UNSIG_MED unsigned int
 #endif

+#define HTCP_ERR_BASE                  60000
+#define HTCP_ERR_CANCELLED            (HTCP_ERR_BASE + 0)
+#define HTCP_ERR_CONN_REFUSED         (HTCP_ERR_BASE + 1)
+#define HTCP_ERR_CONN_TIMEOUT         (HTCP_ERR_BASE + 2)
+#define HTCP_ERR_CONN_ALL_REFUSED     (HTCP_ERR_BASE + 3)
+#define HTCP_ERR_CONN_ALL_TIMEOUT     (HTCP_ERR_BASE + 4)
+#define HTCP_ERR_CONN_ALL_RF_TO       (HTCP_ERR_BASE + 5)
+#define HTCP_ERR_SESS_END_FIN         (HTCP_ERR_BASE + 10)
+#define HTCP_ERR_SESS_END_RST         (HTCP_ERR_BASE + 11)
+#define HTCP_ERR_SESS_END_TIMEOUT     (HTCP_ERR_BASE + 12)
+#define HTCP_ERR_INTERNAL_ERROR       (HTCP_ERR_BASE + 13)
+
 // TUN control type
 enum ied_tunc_def
 {
-  ied_tunc_invalid = 0,                      // invalid
-  ied_tunc_htcp,                             // HTCP
-  ied_tunc_ppp,                              // PPP
-  ied_tunc_sstp                              // SSTP
+   ied_tunc_invalid = 0,                    /* invalid                 */
+   ied_tunc_htcp,                           /* HTCP                    */
+   ied_tunc_ppp,                            /* PPP - HOB-PPP-T1        */
+   ied_tunc_sstp                            /* SSTP                    */
 };

 /* we need only one type of handle 24.09.08 KB                         */
@@ -84,17 +98,20 @@
 };
 /* to be replaced later 24.09.08 KB - end                              */

-#ifdef OLD01
-// struct for configuration of sessions
-struct dsd_wsptun_conf_1
-{
-  int  imc_family;                           // address family - IPV4 or IPV6
-  char chrc_dns_pri[16];                     // primary dns INETA
-  char chrc_dns_sec[16];                     // secondary dns INETA
-  char chrc_wins_pri[16];                    // primary wins INETA
-  char chrc_wins_sec[16];                    // secondary wins INETA
+#ifdef HL_UNIX
+#ifdef D_INCL_TUN_CTRL
+struct dsd_tun_ctrl {                       /* HOB-TUN control area    */
+   int        imc_fd_tun;                   /* file-descriptor TUN adapter */
+   BOOL       boc_tun_opened;               /* TUN-adapter successful opened */
+   int        imc_tun_socket;               /* socket for HOB-TUN      */
+   char       *achc_ta_ineta_ipv4;          /* entry <TUN-adapter-ineta> IPV4 */
+   char       *achc_ta_ineta_ipv6;          /* entry <TUN-adapter-ineta> IPV6 */
+   char       chrc_tiface[ IFNAMSIZ ];      /* name of tun interface   */
+   char       chrc_riface[ IFNAMSIZ ];      /* name of real interface  */
+   struct sockaddr dsc_rhwaddr;             /* real interface mac addr */
 };
 #endif
+#endif

 // struct for configuration of INETAs
 struct dsd_wsptun_conf_1 {
@@ -110,6 +127,16 @@
    char       chrc_ipv6_nbns_sec[16];       /* secondary wins INETA IPV6 */
 };

+#ifndef HL_UNIX
+enum ied_strategy_inst_win_driver {         /* strategy install - uninstall Windows TUN driver */
+   ied_siwd_invalid = 0,                    /* invalid value           */
+   ied_siwd_no_inst_uninst,                 /* no install or uninstall */
+   ied_siwd_only_inst,                      /* only install when needed */
+   ied_siwd_uninst_startup,                 /* uninstall at startup    */
+   ied_siwd_uninst_all                      /* uninstall all possible  */
+};
+#endif
+
 /**
   the ports adsc_appl_port_conf are sorted in ascending order
   if boc_random_appl_port is set, otherwise not.
@@ -118,12 +145,25 @@
    struct dsd_tun_ineta_1 *adsc_tun_ineta_1;  /* chain range of INETAs used by TUN */
    struct dsd_pool_ineta_1 *adsc_pool_ineta_1;  /* chain of pools of INETAs */
    struct dsd_appl_port_conf *adsc_appl_port_conf;  /* configured ports for appl */
+#ifdef B130109
    UNSIG_MED  umc_ta_ineta_local;           /* <TUN-adapter-ineta>     */
 #ifdef B100912
    UNSIG_MED  umc_ta_ineta_remote;          /* <TUN-adapter-ineta>     */
    UNSIG_MED  umc_ta_ineta_mask;            /* <TUN-adapter-ineta>     */
 #endif
    UNSIG_MED  umc_taif_ineta;               /* <TUN-adapter-use-interface-ineta> */
+#endif
+/* new 06.01.13 KB - start                                             */
+   int        imc_no_ta_ineta_ipv4;         /* <TUN-adapter-ineta> IPV4 */
+   int        imc_no_ta_ineta_ipv6;         /* <TUN-adapter-ineta> IPV6 */
+   char       *achc_ar_ta_ineta_ipv4;       /* array <TUN-adapter-ineta> IPV4 */
+   char       *achc_ar_ta_ineta_ipv6;       /* array <TUN-adapter-ineta> IPV6 */
+   UNSIG_MED  umc_taif_ineta_ipv4;          /* <TUN-adapter-use-interface-ineta> IPV4 */
+   char       chrc_taif_ineta_ipv6[ 16 ];   /* <TUN-adapter-use-interface-ineta> IPV6 */
+#ifndef HL_UNIX
+   enum ied_strategy_inst_win_driver iec_siwd;  /* strategy install - uninstall Windows TUN driver */
+#endif
+/* new 06.01.13 KB - end                                               */
    int        imc_tcpc_to_msec;             /* <TCP-connect-timeout-millisec> */
    int        imc_tcpc_try_no;              /* <TCP-connect-number-of-try> */
    int        imc_no_ele_appl_port_conf;    /* number of elements configured ports for appl */
@@ -149,21 +189,8 @@
    unsigned char  ucrc_pw_md4[16];          //md4 peer password hash
 };

-#ifdef OLD01
-enum ied_ppp_subr_query {                   /* request PPP subroutine query */
-   ied_pppsq_invalid = 0,                   /* invalid value           */
-   ied_pppsq_get_auth,                      /* get authentication parameters */
-   ied_pppsq_fr_client,                     /* check PPP packet from client */
-   ied_pppsq_fr_server                      /* check PPP packet from server */
-};

-enum ied_ppp_subr_rc {                      /* request PPP subroutine return code */
-   ied_pppsr_ok = 0,                        /* request was checked O.K. */
-   ied_pppsr_not_compl,                     /* packet not complete     */
-   ied_pppsr_ign_p,                         /* ignore the packet       */
-};
-#endif
-
+#ifdef B130123
 enum ied_ppp_auth_rc {                      /* PPP authentication return code */
    ied_pppar_ok = 0,                        /* authentication was checked O.K. */
    ied_pppar_userid_inv,                    /* userid invalid          */
@@ -171,29 +198,91 @@
    ied_pppar_auth_failed,                   /* authentication failed   */
    ied_pppar_misc                           /* miscellaneous           */
 };
+#endif

-#ifdef OLD01
-typedef void ( * amd_ppp_auth_callback )( struct dsd_ppp_str_1 *, ied_ppp_auth_rc, struct dsd_buf_vector_ele * );

-struct dsd_ppp_str_1 {                      /* PPP structure           */
-   BOOL       boc_type;                     /* FALSE is L2TP, TRUE is HTUN */
-   void *     vpc_handle;                   /* handle L2TP or HTUN     */
-   void *     ac_auth_1;                    /* authentication parameters */
-   amd_ppp_auth_callback amc_ppp_auth_callback;  /* callback after authentication was done */
-   void *     vprc_work[ 8 ];               /* work area               */
+/**
+   in struct dsd_tun_contr_ineta it needs to be checked if
+   sin_family is set to AF_INET and if sin6_family is set to AF_INETA6.
+   Only when sinx_family is not equal to zero, this structure is in use.
+   For HOB-TUN HTCP, either dsc_soa_local_ipv4 is valid
+   or dsc_soa_local_ipv6 is valid, never both.
+   For HOB-TUN PPP, there maybe one INETA IPV4 and one INETA IPV6
+   at the same time. So both, dsc_soa_local_ipv4 and dsc_soa_local_ipv6
+   may be vaild.
+
+   When the HOB WebSecureProxy (WSP) starts a session using HOB-TUN HTCP
+   by calling m_htun_new_sess_htcp(), three structures are passed.
+   struct dsd_tun_start_htcp is used to pass parameters required only
+   during startup. struct dsd_tun_start_htcp is mostly in memory located
+   in the stack and is destroyed after m_htun_new_sess_htcp() returns.
+   m_htun_new_sess_htcp() returns immediately, it does not call any
+   blocking APIs.
+   struct dsd_tun_contr_conn is alive as long as the INETA is
+   bound to the WSP SSL-TCP-session to the client.
+   struct dsd_tun_contr_ineta is alive as long as the INETA given in
+   struct sockaddr_in dsc_soa_local_ipv4
+   or struct sockaddr_in6 dsc_soa_local_ipv6 is in use.
+*/
+
+struct dsd_tun_start_htcp {                 /* HOB-TUN start interface HTCP */
+   dsd_htun_h *adsc_htun_h;                 /* where to put the handle created */
+   /* for HTCP connect                                                 */
+   struct dsd_target_ineta_1 *adsc_server_ineta;  /* server INETA      */
+   void *     ac_free_ti1;                  /* INETA to free           */
+   int        imc_server_port;              /* TCP/IP port connect     */
+   BOOL       boc_connect_round_robin;      /* do connect round-robin  */
+   int        imc_tcpc_to_msec;             /* TCP connect timeout milliseconds */
+   int        imc_tcpc_try_no;              /* TCP connect number of try */
+   BOOL       boc_tcp_keepalive;            /* TCP KEEPALIVE           */
+#ifdef XYZ1
+   /* for PPP                                                          */
+   struct dsd_wsptun_conf_1 *adsc_wsptun_conf_1;  /* TUN PPP INETAs    */
+   UNSIG_MED  umc_s_nw_ineta;               /* server-network-ineta    */
+   UNSIG_MED  umc_s_nw_mask;                /* server-network-mask     */
+#endif
 };

-struct dsd_ppp_subr_1 {                     /* request PPP subroutine  */
-   ied_ppp_subr_query iec_pppsq;            /* request PPP subroutine query */
-   ied_ppp_subr_rc iec_pppsr;               /* request PPP subroutine return code */
-   struct dsd_ppp_str_1 *adsc_ppp_str_1;    /* PPP structure           */
-   struct dsd_gather_i_1 *adsc_gai1_inp;    /* input data              */
-   int        imc_len_inp;                  /* length input data       */
-   char       *achc_buf_out;                /* buffer output data      */
-   int        imc_len_out;                  /* length output data      */
+struct dsd_tun_start_ppp {                  /* HOB-TUN start interface PPP */
+   dsd_htun_h *adsc_htun_h;                 /* where to put the handle created */
+   /* for PPP                                                          */
+// struct dsd_wsptun_conf_1 *adsc_wsptun_conf_1;  /* TUN PPP INETAs    */
+   UNSIG_MED  umc_s_nw_ineta_ipv4;          /* server-network-ineta    */
+   UNSIG_MED  umc_s_nw_mask_ipv4;           /* server-network-mask     */
 };
+
+struct dsd_tun_contr_conn {                 /* HOB-TUN control interface for connection */
+   enum ied_tunc_def iec_tunc;              /* HOB-TUN interface type  */
+   int        imc_sno;                      /* session number          */
+   int        imc_trace_level;              /* WSP trace level         */
+   BOOL       boc_not_drop_tcp_packet;      /* do not drop TCP packets */
+   int        imc_on_the_fly_packets_client;  /* number of packets on the fly to the client */
+#ifdef NOT_YET_120911
+   union {
+     char chrc_htcp_session[ sizeof(class dsd_htcp_session) ];  /* for HTCP */
+     char chrc_ppp_session [ sizeof(class dsd_ppp_session ) ];  /* for PPP */
+     char chrc_sstp_session[ sizeof(class dsd_sstp_session) ];  /* for SSTP */
+// 12.06.12 KB HOB coding-standards - should be dsc_session_buffer
+// beginning a means address = pointer, but is no address
+   } achc_session_buffer;
 #endif
+};

+struct dsd_tun_contr_ineta {                /* HOB-TUN control interface for INETA */
+   struct dsd_tun_contr_conn *adsc_tun_contr_conn;  /* HOB-TUN control interface for connection */
+   struct sockaddr_in dsc_soa_local_ipv4;   /* address information INETA to be used locally */
+   struct sockaddr_in6 dsc_soa_local_ipv6;  /* address information INETA to be used locally */
+};
+
+#ifdef B120923
+#ifdef HL_UNIX
+struct dsd_tun_main_contr {                 /* HOB-TUN main control interface */
+   int        imc_fd_tun;                   /* file descriptor TUN adapter */
+   BOOL       boc_tun_active;               /* TUN is active and initialized */
+};
+#endif
+#endif
+
 /**
  * Finds & opens an existing and available TUN adapter.
  * Calling this function instructs the system to find an available and unused
@@ -202,10 +291,11 @@
  *
  * @return  True if successful, False if otherwise.
  */
-#ifdef B100802
-extern PTYPE BOOL m_htun_start(void);
+#ifndef HL_UNIX
+extern PTYPE BOOL m_htun_start( struct dsd_raw_packet_if_conf *, struct dsd_tun_main_contr * );
+#else
+extern PTYPE BOOL m_htun_start( struct dsd_raw_packet_if_conf *, struct dsd_tun_ctrl * );
 #endif
-extern PTYPE BOOL m_htun_start( struct dsd_raw_packet_if_conf * );

 /**
  * Closes the opened TUN device.
@@ -234,18 +324,13 @@
  *                          address was already in use.
  * @return  Returns a handle to the newly created session.
  */
-#ifdef B080924
-extern PTYPE dsd_tun_ppp_h m_htun_new_sess(struct dsd_tun_contr1*   adsp_tun_contr1,
-                                           struct sockaddr*         adsp_saddr,
-                                           unsigned long            ulp_ifaddr,
-                                           dsd_usrcredents_mschap2* adsp_auth_info,
-                                           BOOL*                    abop_ipok);
+extern PTYPE void m_htun_new_sess_htcp( struct dsd_tun_start_htcp *,
+                                        struct dsd_tun_contr_conn *,
+                                        struct dsd_tun_contr_ineta * );

-#endif
-#ifdef B100702
-extern PTYPE dsd_htun_h m_htun_new_sess( struct dsd_tun_contr1*   adsp_tun_contr1 );
-#endif
-extern PTYPE void m_htun_new_sess( struct dsd_tun_start1 *, struct dsd_tun_contr1 * );
+extern PTYPE void m_htun_new_sess_ppp( struct dsd_tun_start_ppp *,
+                                       struct dsd_tun_contr_conn * );
+
 /**
    called from HTCP when the connect to the target failed.
    IBIPGW08 may give multiple INETAs, and so HTCP can try all INETAs.
@@ -254,26 +339,26 @@
    to the administrator.
    02.10.08 KB
 */
-extern PTYPE void m_htun_htcp_connect_failed( struct dsd_tun_contr1 *adsp_tun_contr1,
-   sockaddr *, socklen_t, int imp_current_index, int imp_total_index, int imp_errno );
+extern PTYPE void m_htun_htcp_connect_failed( struct dsd_tun_contr_conn *adsp_tun_contr_conn,
+   struct sockaddr *, socklen_t, int imp_current_index, int imp_total_index, int imp_errno );
+
 /**
    called from HTCP when the connect to the target ended, either because
    the connect succeeded or all connects (multiple INETAs) have failed.
    imp_errno zero means the connect succeeded.
 */
-extern PTYPE void m_htun_htcp_connect_end( struct dsd_tun_contr1 *adsp_tun_contr1,
+extern PTYPE void m_htun_htcp_connect_end( struct dsd_tun_contr_conn *adsp_tun_contr_conn,
+   struct dsd_target_ineta_1 *adsp_server_ineta,
+   void * ap_free_ti1,                      /* INETA to free           */
+   struct sockaddr *, socklen_t,
    int imp_errno );

 /**
-   WSP can free the target INETA
+   give a warning on a session using HOB-TUN
+   either adsp_tun_contr_conn or adsp_tun_contr_ineta are not NULL
 */
-extern PTYPE void m_htun_htcp_free_target_ineta( struct dsd_tun_contr1 *adsp_tun_contr1,
-                                                 struct dsd_target_ineta_1 *adsc_server_ineta );
-
-/**
-   give a warning on a session using HTUN
-*/
-extern PTYPE void m_htun_warning( struct dsd_tun_contr1 *adsp_tun_contr1,
+extern PTYPE void m_htun_warning( struct dsd_tun_contr_conn *adsp_tun_contr_conn,
+                                  struct dsd_tun_contr_ineta *adsp_tun_contr_ineta,
                                   int imp_error_number,
                                   const char *achp_format, ... );
 /**
@@ -298,43 +383,37 @@
    data plus the new data.
    02.10.08 KB
 */
-#ifdef B080924
-extern PTYPE void m_htun_sess_send(dsd_tun_sstp_h         dsp_session,
-                                   struct dsd_gather_i_1* adsp_gather);
-
-#endif
-#ifdef B080924
-extern PTYPE void m_htun_sess_send(dsd_htun_h             dsp_session,
-                                   struct dsd_gather_i_1* adsp_gather);
-#endif
 extern PTYPE void m_htun_sess_send( struct dsd_hco_wothr *,
                                     dsd_htun_h dsp_session,
                                     struct dsd_gather_i_1* adsp_gather );
+
+extern PTYPE void m_htun_htcp_send_complete( struct dsd_tun_contr_conn *adsp_tun_contr_conn );
+
 /**
- * Closes a PPP, SSTP or HTCP session and deletes it from the AVL tree.
+ * Closes a PPP, SSTP or HTCP session.
  * Finds the session node pointed to by the handle passed as parameter, and
- * schedules it to be removed from the AVL tree. The session object is referenced
- * by this session node is also deleted.
+ * The session object referenced by this session node is also deleted.
  *
  * @param  dsp_husip_sess  Session handle pointing to the session to be deleted
- *                         and closed. Must be obtained by calling m_htun_new_sess().
+ *                         and closed. Must be obtained by calling
+ *                         m_htun_new_sess_htcp() or m_htun_new_sess_ppp().
  */
-#ifdef B080924
-extern PTYPE void m_htun_sess_close(dsd_tun_ppp_h dsp_husip_sess);
-#endif
 extern PTYPE void m_htun_sess_close(dsd_htun_h dsp_husip_sess);

-#ifdef B100702
-/* added 24.09.08 KB - if INETA is already in tree                     */
-extern PTYPE BOOL m_htun_sess_ineta_double( struct dsd_tun_contr1 * adsp_tctl );
-#endif
-#ifdef NEW_HOB_TUN_1103
-extern PTYPE char * m_htun_ppp_acquire_local_ineta_ipv4( struct dsd_hco_wothr *, struct dsd_tun_contr1 * );
-extern PTYPE void m_htun_ppp_use_local_ineta( struct dsd_tun_contr1 *, char * );
-extern PTYPE void m_htun_ppp_release_local_ineta( struct dsd_tun_contr1 *, char * );
-#endif
-extern PTYPE struct dsd_targfi_1 * m_htun_ppp_get_targfi( struct dsd_tun_contr1 * );
+extern PTYPE void m_htun_session_end( struct dsd_tun_contr_conn *adsp_tun_contr_conn,
+                                      int imp_reason );

+extern PTYPE void m_htun_htcp_free_resources( struct dsd_tun_contr_ineta *adsp_tun_contr_ineta );
+
+extern PTYPE struct dsd_tun_contr_ineta *
+     m_htun_ppp_acquire_local_ineta_ipv4( struct dsd_hco_wothr *,
+                                          struct dsd_tun_contr_conn *,
+                                          struct dsd_tun_contr_ineta * );
+
+extern PTYPE void m_htun_ppp_free_resources( struct dsd_tun_contr_ineta *adsp_tun_contr_ineta );
+
+extern PTYPE struct dsd_targfi_1 * m_htun_ppp_get_targfi( struct dsd_tun_contr_conn * );
+
 /**
  * Sends data traveling over an opened session towards the client.
  * Sends messages belonging to any of the opened sessions torwards the
@@ -351,7 +430,7 @@
  *          session client. Returns FALSE if no more messages can be handled. To
  *          resume the sending of messages, call m_se_cansend().
  */
-extern PTYPE BOOL m_se_htun_recvbuf(struct dsd_tun_contr1*     adsp_tctl,
+extern PTYPE BOOL m_se_htun_recvbuf(struct dsd_tun_contr_conn* adsp_tctl,
                                     struct dsd_buf_vector_ele* adsp_vector,
                                     int                        imp_ele_vector );

@@ -378,6 +457,7 @@
 //extern PTYPE void m_tun_relrecvbuf(void *ap_handle);
 extern PTYPE void m_htun_relrecvbuf(void *ap_handle);

+#ifdef B120921
 /**
  * Applies a DNS and WINS configuration.
  * Sets the configuration options for DNS and WINS servers. These option values
@@ -387,7 +467,8 @@
  *
  * @param  adsp_wsptun_newconfig  DNS and WINS configuration to apply.
  */
-extern PTYPE void m_wsptun_reset_conf(dsd_wsptun_conf_1* adsp_wsptun_newconfig);
+extern PTYPE void m_wsptun_reset_conf( dsd_wsptun_conf_1* adsp_wsptun_newconfig );
+#endif

 /**
  * Sets the 'can send' event.
@@ -397,18 +478,12 @@
  *
  * @param  dsp_hdl_sess  Handle to the session.
  */
-#ifdef B080924
-extern PTYPE void m_se_cansend(dsd_tun_ppp_h dsp_hdl_sess);
-#endif
 extern PTYPE void m_htun_sess_canrecv(dsd_htun_h dsp_hdl_sess);

-#ifdef OLD01
-/* check PPP packets and do authentification                           */
-extern PTYPE void m_ppp_subr_1( struct dsd_ppp_subr_1 * );  /* request PPP subroutine */
-#endif
-
+//#ifdef B120921
 extern PTYPE struct dsd_wsptun_conf_1 * m_get_wsptun_conf_1();

 extern PTYPE char * m_get_wsptun_ineta_ipv4_adapter();
+//#endif

 #endif
Index: hob-hppp01.h
===================================================================
--- hob-hppp01.h	(revision 0)
+++ hob-hppp01.h	(revision 6)
@@ -0,0 +1,176 @@
+#ifndef HOBHPPP_H_INC
+#define HOBHPPP_H_INC
+
+#include "hob-session01.h"
+
+#define MAX_HOBPPPT1_MSGLEN 1024 * 16
+
+class dsd_ppp_session;
+
+struct dsd_ppp_wrap {
+   dsd_ppp_session* adsc_ppp_session;
+   dsd_ppp_server_1 dsc_ppp_se_1;      // Associated PPP session.
+   dsd_timer_ele    dsc_timer_close;   // Timer for PPP session close.
+};
+
+inline dsd_ppp_session* m_ppp_session_from_s1(dsd_ppp_server_1* adsp_ppp_se_1)
+{
+   dsd_ppp_wrap* adsl_ppp_wrap = (dsd_ppp_wrap*)
+      ((char*)adsp_ppp_se_1 - offsetof(dsd_ppp_wrap, dsc_ppp_se_1));
+   return adsl_ppp_wrap->adsc_ppp_session;
+}
+
+inline dsd_ppp_session* m_ppp_session_from_te(dsd_timer_ele* adsp_timer_ele)
+{
+   dsd_ppp_wrap* adsl_ppp_wrap = (dsd_ppp_wrap*)
+      ((char*)adsp_timer_ele - offsetof(dsd_ppp_wrap, dsc_timer_close));
+   return adsl_ppp_wrap->adsc_ppp_session;
+}
+
+// HOB-PPP-T1 session class.
+struct dsd_ppp_session
+{
+   // Control handle for application.
+   dsd_tun_contr_conn* adsc_tun_contr_conn;
+   // Client VINETA.
+   dsd_tun_contr_ineta* adsc_tun_contr_ineta;
+   // Location where WSP can find this.
+   dsd_htun_handle dsc_htun_handle;
+   // Indicates whether session has been closed.
+   BOOL boc_sess_closed;
+   // Signaled when data can be sent to client.
+   BOOL boc_cansend;
+   // Index of internal network interface associated with this session.
+   //uint32_t umc_if_idx;
+   // Buffer for error and warning messages.
+   char chrc_last_error[256];
+
+   dsd_ppp_wrap   dsc_ppp_wrap;
+   uint32_t         umc_discard_count; // Number of messages discarded.
+   uint32_t         umc_s_nw_ineta;    // Server internal network ineta.
+   uint32_t         umc_s_nw_mask;     // Server internal network netmask.
+   // Queue for messages which are to be sent to the client over the external
+   // network.
+   std::queue<dsd_queued_msg> dsc_sendto_extnw_msgq;
+   dsd_hcla_critsect_1 dsd_cs; // General critical section for session.
+   BOOL boc_ppp_svr_started;
+
+#ifdef QUICKFIX16112010
+   // Workaround.
+   int32   imc_i;
+   BOOLEAN boc_b;
+#endif
+
+#ifdef QUICKFIX18112010
+   BOOLEAN boc_ppp_svr_started;
+#endif
+
+   //
+   // Default constructor.
+   // Not implemented.
+   //
+   dsd_ppp_session();
+
+   //
+   // Constructor.
+   // Initializes the HOB-PPP-T1 session object.
+   //
+   // @param  adsp_sess_info  Configuration for the new session.
+   //
+   dsd_ppp_session(dsd_tun_start_ppp* adsp_tun_start_ppp,
+                   dsd_tun_contr_conn* adsp_tun_contr_conn,
+                   dsd_tun_contr_ineta* adsp_tun_contr_ineta);
+
+   //
+   // Copy constructor.
+   // Not implemented.
+   //
+   dsd_ppp_session(const dsd_ppp_session& dsp_orig);
+
+   //
+   // Assignment operator.
+   // Not implemented.
+   //
+   const dsd_ppp_session& operator=(dsd_ppp_session& dsp_rhs);
+
+   //
+   // Destructor.
+   // Performs the necessary cleanup.
+   //
+   ~dsd_ppp_session();
+  
+   //
+   // Initializes the PPP session.
+   // Must be called before any other methods are called on the object. Performs
+   // any initialisation of the object which might possibly fail.
+   //
+   // @return  Returns a value which is < 0 on faliure.
+   //
+   int32_t mc_init();
+
+   void mc_close();
+
+   //
+   // Processes the message header.
+   // Reads the contents of the message header and updates the session
+   // accordingly. Depending on the header contents, this can trigger a
+   // response to the session client, the transfer of data over the internal
+   // network, or the updating of the session object.
+   //
+   // @param  adsp_gather  Gather struct containing message to be interpreted.
+   // @param  adsp_hco_wothr  Pointer to the calling workthread.
+   //
+   // @return  Returns a value which is < 0 on faliure.
+   //
+   int32_t mc_interpret_msg(dsd_gather_i_1* adsp_gather,
+                                    dsd_hco_wothr*  adsp_hco_wothr);
+
+   //
+   // Sends the RESPONSE-START message to the HOB-PPP-T1 client.
+   // Writes and sends a RESPONSE-START message to the client. This message is
+   // meant to be sent upon receipt of a START message, and contains the ID of the tunnel
+   // created and the network address and netmask for the server's internal network.
+   //
+   // @return  Returns TRUE if the call succeeded.
+   //
+   BOOL mc_send_responsestart();
+
+   //
+   // Called when more data can be sent.
+   //
+   void mc_can_send();
+
+   //
+   // Adds a PPP header to the data.
+   // Encapsulates the data in a PPP header, and sends the message over to
+   // the session client.
+   //
+   // @param  ap_handle   Handle to the buffer containing the data to
+   //                     encapsulate.
+   // @param  aucp_data   Pointer to the buffer containing the data to
+   //                     encapsulate.
+   // @param  ump_length  Length, in bytes, of the data to encapsulate.
+   //
+   // @return  Returns a value which is < 0 on faliure.
+   //
+   int32_t mc_encapsulate_msg(void*    ap_handle,
+                                      byte*    abyp_data,
+                                      uint32_t ump_length);
+
+   //
+   // Adds an HTUN header to the data.
+   // Encapsulates the passed data in an HTUN header.
+   //
+   // @param  adsp_buf_vec  Buffer containing data to encapsulate.
+   //
+   void mc_make_htun(dsd_buf_vector_ele* adsp_buf_vec);
+
+   int32_t mc_tunnel_to_cl(void*    ap_handle,
+                           byte*    abyp_data,
+                           uint32_t ump_length);
+
+   BOOL mc_send_stop();
+
+};
+
+#endif
Index: xiipgw08-pd-main.cpp
===================================================================
--- xiipgw08-pd-main.cpp	(revision 2)
+++ xiipgw08-pd-main.cpp	(revision 6)
@@ -537,12 +537,20 @@
      goto pcopd28;                          /* check if data received  */
    }
 #else
+#ifdef B121121
    if (   (ADSL_CONN1_G->iec_st_cls != ied_cls_normal)  /* status client normal processing */
        && (ADSL_CONN1_G->iec_st_cls != ied_cls_rec_close)) {   /* received close */
      goto pcopd28;                          /* check if data received  */
    }
+#else
+   if (   (ADSL_CONN1_G->iec_st_cls != ied_cls_normal)  /* status client normal processing */
+       && (ADSL_CONN1_G->iec_st_cls != ied_cls_rec_close)  /* received close */
+       && (ADSL_CONN1_G->iec_st_cls != ied_cls_set_entropy)) {  /* set entropy */
+     goto pcopd28;                          /* check if data received  */
+   }
 #endif
 #endif
+#endif
 #ifdef OLD_1112
    if (ADSL_CONN1_G->adsc_radqu) {          /* radius active           */
      if (   (ADSL_CONN1_G->adsc_radqu->imc_len_received)  /* length radius received */
@@ -1372,8 +1380,8 @@
                        __LINE__, m_get_time() );
      }
 #endif
-     m_hlnew_printf( HLOG_XYZ1, "m_proc_data l%05d time-sec=%d bol_cont=%d ->boc_st_act=%d adsl_sdhc1_client=%p.",
-                     __LINE__, m_get_time(), bol_cont, ADSL_CONN1_G->boc_st_act, adsl_sdhc1_client );
+     m_hlnew_printf( HLOG_XYZ1, "m_proc_data l%05d time-sec=%d bol_cont=%d ->boc_st_act=%d adsl_sdhc1_client=%p ADSL_CONN1_G->iec_st_ses=%d ADSL_CONN1_G->iec_st_cls=%d
ADSL_CONN1_G->adsc_sdhc1_c1=%p.",
+                     __LINE__, m_get_time(), bol_cont, ADSL_CONN1_G->boc_st_act, adsl_sdhc1_client, ADSL_CONN1_G->iec_st_ses, ADSL_CONN1_G->iec_st_cls, ADSL_CONN1_G->adsc_sdhc1_c1
);
 #endif
 #ifdef TRACEHLD
      *iptrace_act = 0X18;
@@ -2026,7 +2034,12 @@
          && (ADSL_CONN1_G->dsc_hlse03s.inc_func != DEF_IFUNC_START)) {  /* not start mode */
        goto pcopd32;                        /* process SSL data        */
      }
+#ifndef B121121
+     if (ADSL_CONN1_G->iec_st_cls == ied_cls_set_entropy) {  /* set entropy */
+       goto pcopd32;                        /* process SSL data        */
+     }
 #endif
+#endif
 #ifdef B100408X
      if (iec_st_cls == ied_cls_normal) {    /* status client normal processing */
        goto pcopd32;                        /* process SSL data        */
@@ -5298,6 +5311,11 @@
 static BOOL m_do_send_server( struct dsd_hco_wothr *adsp_hco_wothr, DSD_CONN_G *adsp_conn1 ) {
    BOOL       bol1;                         /* working varibale        */
    int        iml1;                         /* working variable        */
+#ifdef D_INCL_HOB_TUN
+#ifndef B121212
+   dsd_htun_h dsl_htun_h;                   /* handle for HOB-TUN      */
+#endif
+#endif
    struct dsd_sdh_control_1 *adsl_sdhc1_cur_1;  /* current location 1  */
    struct dsd_sdh_control_1 *adsl_sdhc1_last_1;  /* last location 1    */
    struct dsd_sdh_control_1 *adsl_sdhc1_w1;  /* working variable       */
@@ -5454,11 +5472,21 @@
 #endif
 #else
 #ifndef NEW_HOB_TUN_1103
+#ifdef B121212
        m_htun_sess_send( adsp_hco_wothr,
                          adsp_conn1->adsc_ineta_raws_1->dsc_htun_h,
                          adsl_gai1_w1 );
 #else
+       dsl_htun_h = adsp_conn1->dsc_htun_h;  /* handle for HOB-TUN     */
+       if (adsp_conn1->adsc_ineta_raws_1) {  /* with INETA             */
+         dsl_htun_h = adsp_conn1->adsc_ineta_raws_1->dsc_htun_h;  /* handle for HOB-TUN */
+       }
        m_htun_sess_send( adsp_hco_wothr,
+                         dsl_htun_h,
+                         adsl_gai1_w1 );
+#endif
+#else
+       m_htun_sess_send( adsp_hco_wothr,
                          adsp_conn1->dsc_htun_h,
                          adsl_gai1_w1 );
 #endif
Index: xiipgw08-tun.cpp
===================================================================
--- xiipgw08-tun.cpp	(revision 0)
+++ xiipgw08-tun.cpp	(revision 6)
@@ -0,0 +1,1942 @@
+#ifdef D_INCL_HOB_TUN
+/** start HOB-TUN interface                                            */
+static void m_gw_start_htun( struct dsd_raw_packet_if_conf *adsp_rpi_conf ) {
+#ifndef HL_UNIX
+   BOOL       bol_rc;                       /* return code             */
+   BOOL       bol_if_arp;                   /* interface for ARP found */
+   BOOL       bol_if_route;                 /* interface for routes found */
+   DWORD      dwl_ret;                      /* return code             */
+   DWORD      dwl_ineta;                    /* temporary INETA         */
+   unsigned long int uml_ai_buf_len;        /* length of buffer for adapter info */
+   DWORD      dwl_index_if;                 /* holds index of compatible IF */
+   PIP_ADAPTER_INFO adsl_adap_info_w1;      /* points to first adapter info */
+   PIP_ADAPTER_INFO adsl_adap_info_w2;      /* points to first adapter info */
+   IP_ADDR_STRING *adsl_ineta_cur;
+
+#ifdef TRACEHL1
+   m_hlnew_printf( HLOG_XYZ1, "l%05d IBIPGW08.cpp m_gw_start_htun( 0X%p ) called",
+                   __LINE__, adsp_rpi_conf );
+#endif
+   if (adsp_rpi_conf == NULL) return;
+   bol_rc = m_htun_start( adsp_rpi_conf );
+#ifdef TRACEHL1
+   m_hlnew_printf( HLOG_XYZ1, "IBIPGW08-l%05d-T m_htun_start() returned %d.",
+                   __LINE__, bol_rc );
+#endif
+   Sleep( 5000 );                           /* wait till Windows has created the TUN adapter */
+   bol_if_arp = FALSE;                      /* interface for ARP found */
+   bol_if_route = FALSE;                    /* interface for routes found */
+   uml_ai_buf_len = 0;                      /* length of buffer for adapter info */
+   adsl_adap_info_w1 = NULL;                /* points to first adapter info */
+   dwl_ret = GetAdaptersInfo( adsl_adap_info_w1, &uml_ai_buf_len );
+   if (dwl_ret != ERROR_BUFFER_OVERFLOW) {
+     m_hlnew_printf( HLOG_XYZ1, "IBIPGW08-l%05d-W GetAdaptersInfo() returned %d/0X%08X.",
+                     __LINE__, dwl_ret, dwl_ret );
+   }
+   adsl_adap_info_w1 = (PIP_ADAPTER_INFO) malloc( uml_ai_buf_len );
+   dwl_ret = GetAdaptersInfo( adsl_adap_info_w1, &uml_ai_buf_len );
+   if (dwl_ret != ERROR_SUCCESS) {
+     m_hlnew_printf( HLOG_XYZ1, "IBIPGW08-l%05d-W GetAdaptersInfo() returned %d/0X%08X.",
+                     __LINE__, dwl_ret, dwl_ret );
+   }
+   adsl_adap_info_w2 = adsl_adap_info_w1;
+   while (adsl_adap_info_w2) {
+     adsl_ineta_cur = &(adsl_adap_info_w2->IpAddressList);
+     /* check all addresses                                            */
+     while (adsl_ineta_cur) {
+#ifdef TRACEHL1
+       m_hlnew_printf( HLOG_XYZ1, "IBIPGW08-l%05d-T m_getindex_if() found INETA \"%s\" Index=%d 0X%08X.",
+                       __LINE__,
+                       adsl_ineta_cur->IpAddress.String,
+                       adsl_adap_info_w2->Index,
+                       inet_addr( adsl_ineta_cur->IpAddress.String ) );
+#endif
+       dwl_ineta = inet_addr( adsl_ineta_cur->IpAddress.String);  /* temporary INETA */
+       if (dwl_ineta == *((DWORD *) &adss_loconf_1_fill->adsc_raw_packet_if_conf->umc_taif_ineta)) {  /* <TUN-adapter-use-interface-ineta> */
+         dss_ser_thr_ctrl.umc_index_if_arp = adsl_adap_info_w2->Index;  /* holds index of compatible IF for ARP */
+         bol_if_arp = TRUE;                 /* interface for ARP found */
+         if (bol_if_route) break;           /* interface for routes found */
+       }
+       if (dwl_ineta == *((DWORD *) &adss_loconf_1_fill->adsc_raw_packet_if_conf->umc_ta_ineta_local)) {  /* <TUN-adapter-ineta> */
+         dss_ser_thr_ctrl.umc_index_if_route = adsl_adap_info_w2->Index;  /* holds index of compatible IF for routes */
+         bol_if_route = TRUE;               /* interface for routes found */
+         if (bol_if_arp) break;             /* interface for ARP found */
+       }
+       adsl_ineta_cur = adsl_ineta_cur->Next;
+     }
+     if (adsl_ineta_cur) break;
+     /* move to next interface                                         */
+     adsl_adap_info_w2 = adsl_adap_info_w2->Next;
+   }
+   free( adsl_adap_info_w1 );
+#ifdef B100806
+   if (adsl_adap_info_w2 == NULL) {         /* adapter not found       */
+// 31.07.10 KB error message
+   }
+#endif
+   if (bol_if_arp == FALSE) {               /* interface for ARP found */
+     m_hlnew_printf( HLOG_XYZ1, "IBIPGW08-l%05d-W m_gw_start_htun() no interface for ARP found",
+                     __LINE__ );
+   }
+   if (bol_if_route == FALSE) {             /* interface for routes found */
+     m_hlnew_printf( HLOG_XYZ1, "IBIPGW08-l%05d-W m_gw_start_htun() no interface for routes found",
+                     __LINE__ );
+   }
+#else
+#define TRY_130109_01
+   BOOL       bol_rc;                       /* return code             */
+   int        iml_rc;                       /* return code             */
+   int        iml_error;                    /* error code              */
+   int        iml_fd;                       /* file dexcriptor         */
+   int        iml1;                         /* working variable        */
+   time_t     dsl_time_1;                   /* for time                */
+   enum ied_ret_main_poll iel_rmp;          /* return from main poll   */
+   struct ifreq dsl_ifreq;                  /* interface request       */
+#ifdef XYZ1
+   struct msghdr dsl_msghdr;                /* message structure       */
+#endif
+#ifdef TRY_130109_01
+   char       chrl_liface[ IFNAMSIZ ];      /* name of logical interface */
+   struct sockaddr dsl_lhwaddr;             /* logical interface mac addr */
+#endif
+   char       byrl_work1[ 16 ];             /* working area            */
+
+   do {                                     /* check IP forwarding     */
+     iml_fd = open( D_FN_IP_FORW, O_RDONLY );
+     if (iml_fd < 0) {                      /* error occured           */
+       m_hlnew_printf( HLOG_WARN1, "HWSPSnnnW nbipgw20 l%05d file IP forwarding %s open error %d.",
+                       __LINE__, D_FN_IP_FORW, errno );
+       break;
+     }
+     iml_rc = read( iml_fd, byrl_work1, sizeof(byrl_work1) );
+     if (iml_rc < 0) {                      /* error occured           */
+       m_hlnew_printf( HLOG_WARN1, "HWSPSnnnW nbipgw20 l%05d file IP forwarding %s read error %d.",
+                       __LINE__, D_FN_IP_FORW, errno );
+       close( iml_fd );
+       break;
+     }
+#ifdef TRACEHL1
+     m_console_out( (char *) byrl_work1, iml_rc );
+#endif
+     if (iml_rc != (1 + 1)) {
+       m_hlnew_printf( HLOG_WARN1, "HWSPSnnnW nbipgw20 l%05d file IP forwarding %s length read returned %d - not (1 + 1) as expected",
+                       __LINE__, D_FN_IP_FORW, iml_rc );
+     }
+     if ((iml_rc > 1) && (byrl_work1[ iml_rc - 1 ] != CHAR_LF)) {
+       m_hlnew_printf( HLOG_WARN1, "HWSPSnnnW nbipgw20 l%05d file IP forwarding %s read returned last character 0X%02X - not CHAR_LF as expected",
+                       __LINE__, D_FN_IP_FORW, byrl_work1[ iml_rc - 1 ] );
+     }
+     if (byrl_work1[ 0 ] == '0') {
+       m_hlnew_printf( HLOG_WARN1, "HWSPSnnnW nbipgw20 l%05d IP forwarding switched off - TUN cannot work",
+                       __LINE__ );
+     } else if (byrl_work1[ 0 ] != '1') {
+       m_hlnew_printf( HLOG_WARN1, "HWSPSnnnW nbipgw20 l%05d file IP forwarding %s read returned first character 0X%02X - neither \'0\' nor \'1\' as expected",
+                       __LINE__, D_FN_IP_FORW, byrl_work1[ iml_rc - 1 ] );
+     }
+     iml_rc = close( iml_fd );
+     if (iml_rc != 0) {                     /* error occured           */
+       m_hlnew_printf( HLOG_WARN1, "HWSPSnnnW nbipgw20 l%05d file IP forwarding %s close error %d.",
+                       __LINE__, D_FN_IP_FORW, errno );
+     }
+   } while (FALSE);
+   memset( &dss_tun_ctrl, 0, sizeof(struct dsd_tun_ctrl) );  /* HOB-TUN control area */
+   if (adsp_rpi_conf == NULL) return;
+   dss_tun_ctrl.imc_tun_socket              /* socket for HOB-TUN      */
+     = socket( AF_INET, SOCK_STREAM, 0 );
+   if (dss_tun_ctrl.imc_tun_socket < 0) {   /* error occured           */
+     m_hlnew_printf( HLOG_WARN1, "xxxxxxxx-%05d-W m_gw_start_htun() socket() Return Code %d Error %d.",
+                     __LINE__, dss_tun_ctrl.imc_tun_socket, errno );
+   }
+#ifdef B130109
+   bol_rc = m_htun_search_interface_ipv4( adsp_rpi_conf->umc_taif_ineta,  /* <TUN-adapter-use-interface-ineta> */
+                                          dss_tun_ctrl.chrc_riface,
+                                          &dss_tun_ctrl.dsc_rhwaddr );
+#endif
+   bol_rc = m_htun_search_interface_ipv4( adsp_rpi_conf->umc_taif_ineta_ipv4,  /* <TUN-adapter-use-interface-ineta> */
+                                          dss_tun_ctrl.chrc_riface,
+                                          &dss_tun_ctrl.dsc_rhwaddr );
+   if (bol_rc == FALSE) return;
+   dss_tun_ctrl.imc_fd_tun = open( "/dev/net/tun", O_RDWR );
+//#ifdef TRACEHL1
+   m_hlnew_printf( HLOG_XYZ1, "nbipgw20-l%05d-T m_gw_start_htun() open( ... ) returned %d errno %d.",
+                   __LINE__, iml_rc, errno );
+//#endif
+   if (dss_tun_ctrl.imc_fd_tun < 0) {
+   }
+   if (dss_loconf_1.boc_listen_gw) {        /* do use listen-gateway   */
+     goto p_start_20;                       /* start TUN adapter with listen-gateway */
+   }
+   memset( &dsl_ifreq, 0, sizeof(struct ifreq) );  /* interface request */
+   dsl_ifreq.ifr_flags = IFF_TUN | IFF_NO_PI;
+   iml_rc = ioctl( dss_tun_ctrl.imc_fd_tun, TUNSETIFF, &dsl_ifreq );
+//#ifdef TRACEHL1
+   m_hlnew_printf( HLOG_XYZ1, "nbipgw20-l%05d-T m_gw_start_htun() ioctl( ... , TUNSETIFF , ... ) returned %d errno %d.",
+                   __LINE__, iml_rc, errno );
+//#endif
+   if (iml_rc < 0) {                        /* error occured           */
+   }
+#ifdef TRACEHL1
+#ifdef B130109
+   m_hlnew_printf( HLOG_XYZ1, "nbipgw20-l%05d-T m_gw_start_htun() SIOCSIFADDR with INETA %d.%d.%d.%d.",
+                   __LINE__,
+                   *((unsigned char *) &adsp_rpi_conf->umc_ta_ineta_local + 0),
+                   *((unsigned char *) &adsp_rpi_conf->umc_ta_ineta_local + 1),
+                   *((unsigned char *) &adsp_rpi_conf->umc_ta_ineta_local + 2),
+                   *((unsigned char *) &adsp_rpi_conf->umc_ta_ineta_local + 3) );
+#endif
+#endif
+#ifdef TRY_130109_01
+   iml1 = 0;                                /* clear index             */
+   while (iml1 < adsp_rpi_conf->imc_no_ta_ineta_ipv4) {  /* <TUN-adapter-ineta> IPV4 */
+     dss_tun_ctrl.achc_ta_ineta_ipv4          /* entry <TUN-adapter-ineta> IPV4 */
+       = &adsp_rpi_conf->achc_ar_ta_ineta_ipv4[ iml1 * 4 ];  /* entry array <TUN-adapter-ineta> IPV4 */
+     bol_rc = m_htun_search_interface_ipv4( *((UNSIG_MED *) dss_tun_ctrl.achc_ta_ineta_ipv4),  /* <TUN-adapter-use-interface-ineta> */
+                                            chrl_liface,
+                                            &dsl_lhwaddr );
+     m_hlnew_printf( HLOG_XYZ1, "nbipgw20-l%05d-T m_gw_start_htun() m_htun_search_interface_ipv4 returned %d INETA %d.%d.%d.%d.",
+                     __LINE__,
+                     bol_rc,
+                     *((unsigned char *) dss_tun_ctrl.achc_ta_ineta_ipv4 + 0),
+                     *((unsigned char *) dss_tun_ctrl.achc_ta_ineta_ipv4 + 1),
+                     *((unsigned char *) dss_tun_ctrl.achc_ta_ineta_ipv4 + 2),
+                     *((unsigned char *) dss_tun_ctrl.achc_ta_ineta_ipv4 + 3) );
+     if (bol_rc == FALSE) break;
+     iml1++;                                /* increment               */
+   }
+   if (iml1 >= adsp_rpi_conf->imc_no_ta_ineta_ipv4) {  /* <TUN-adapter-ineta> IPV4 */
+     iml_rc = close( dss_tun_ctrl.imc_fd_tun );
+     if (iml_rc < 0) {                      /* error occured           */
+     }
+//   return FALSE;
+     return;
+   }
+#endif
+#define ADSL_SOCKADDR_IFR_ADDR ((struct sockaddr_in *) &dsl_ifreq.ifr_addr)
+   ADSL_SOCKADDR_IFR_ADDR->sin_family = AF_INET;
+#ifdef B130109
+   *((UNSIG_MED *) &ADSL_SOCKADDR_IFR_ADDR->sin_addr)
+     = adsp_rpi_conf->umc_ta_ineta_local;   /* <TUN-adapter-ineta>     */
+#endif
+   *((UNSIG_MED *) &ADSL_SOCKADDR_IFR_ADDR->sin_addr)
+     = *((UNSIG_MED *) dss_tun_ctrl.achc_ta_ineta_ipv4);  /* entry <TUN-adapter-ineta> IPV4 */
+#undef ADSL_SOCKADDR_IFR_ADDR
+#ifndef B121211
+   memcpy( dss_tun_ctrl.chrc_tiface, dsl_ifreq.ifr_name, IFNAMSIZ );
+#endif
+   iml_rc = ioctl( dss_tun_ctrl.imc_tun_socket, SIOCSIFADDR, &dsl_ifreq );
+//#ifdef TRACEHL1
+   m_hlnew_printf( HLOG_XYZ1, "nbipgw20-l%05d-T m_gw_start_htun() ioctl( ... , SIOCSIFADDR , ... ) returned %d errno %d.",
+                   __LINE__, iml_rc, errno );
+//#endif
+   if (iml_rc < 0) {                        /* error occured           */
+   }
+#ifdef TRACEHL1
+   m_hlnew_printf( HLOG_XYZ1, "nbipgw20-l%05d-T m_gw_start_htun() SIOCSIFADDR with INETA %d.%d.%d.%d.",
+                   __LINE__,
+                   *((unsigned char *) dss_tun_ctrl.achc_ta_ineta_ipv4 + 0),
+                   *((unsigned char *) dss_tun_ctrl.achc_ta_ineta_ipv4 + 1),
+                   *((unsigned char *) dss_tun_ctrl.achc_ta_ineta_ipv4 + 2),
+                   *((unsigned char *) dss_tun_ctrl.achc_ta_ineta_ipv4 + 3) );
+#endif
+   iml_rc = ioctl( dss_tun_ctrl.imc_tun_socket, SIOCGIFFLAGS, &dsl_ifreq );
+//#ifdef TRACEHL1
+   m_hlnew_printf( HLOG_XYZ1, "nbipgw20-l%05d-T m_gw_start_htun() ioctl( ... , SIOCGIFFLAGS , ... ) returned %d errno %d.",
+                   __LINE__, iml_rc, errno );
+//#endif
+   if (iml_rc < 0) {                        /* error occured           */
+   }
+   dsl_ifreq.ifr_flags |= IFF_UP | IFF_RUNNING;
+   iml_rc = ioctl( dss_tun_ctrl.imc_tun_socket, SIOCSIFFLAGS, &dsl_ifreq );
+//#ifdef TRACEHL1
+   m_hlnew_printf( HLOG_XYZ1, "nbipgw20-l%05d-T m_gw_start_htun() ioctl( ... , SIOCSIFFLAGS , ... ) returned %d errno %d.",
+                   __LINE__, iml_rc, errno );
+//#endif
+   if (iml_rc < 0) {                        /* error occured           */
+   }
+   goto p_start_40;                         /* continue starting TUN adapter */
+
+   p_start_20:                              /* start TUN adapter with listen-gateway */
+   time( &dsl_time_1 );                     /* get current time        */
+   iel_rmp = m_main_poll( ied_fmp_open_tun, dsl_time_1 + D_WAIT_OPEN_TUN );
+#ifdef XYZ1
+   switch (iel_rmp) {                       /* check how returned      */
+     case ied_rmp_timeout:                  /* timer elapsed           */
+       goto p_m_poll_00;                    /* poll for events         */
+     case ied_rmp_sig_end:                  /* message signal end      */
+       goto p_disp_stat_00;                 /* display statistics now  */
+     case ied_rmp_sig_reload:               /* message signal reload configuration */
+       goto p_reload_00;                    /* received reload configuration */
+     case ied_rmp_sig_check_shu:            /* message signal check shutdown */
+       goto p_shutdown_00;                  /* check shutdown of this process */
+     default:
+#endif
+       m_hlnew_printf( HLOG_WARN1, "HWSPSnnnW nbipgw20 l%05d returned from m_main_poll() iel_rmp = %d invalid",
+                       __LINE__, iel_rmp );
+#ifdef XYZ1
+       break;
+   }
+#endif
+
+   p_start_40:                              /* continue starting TUN adapter */
+   /* set TUN-adapter access non-blocking                              */
+   iml1 = fcntl( dss_tun_ctrl.imc_fd_tun, F_GETFL, 0 );
+   if (iml1 == -1) iml1 = 0;
+   iml_rc = fcntl( dss_tun_ctrl.imc_fd_tun, F_SETFL, iml1 | O_NONBLOCK );
+//#ifdef TRACEHL1
+   m_hlnew_printf( HLOG_XYZ1, "nbipgw20-l%05d-T m_gw_start_htun() fcntl( ... , 0X%X ) returned %d errno %d.",
+                   __LINE__, iml1 | O_NONBLOCK, iml_rc, errno );
+//#endif
+   if (iml_rc < 0) {                        /* error occured           */
+   }
+   bol_rc = m_htun_start( adsp_rpi_conf, &dss_tun_ctrl );
+   if (dss_loconf_1.boc_listen_gw) return;  /* do use listen-gateway   */
+   iml_rc = dss_ser_thr_ctrl.dsc_event_thr.m_create( &iml_error );  /* event for serial thread */
+   if (iml_rc < 0) {                        /* error occured           */
+     m_hlnew_printf( HLOG_WARN1, "HWSPMnnnW l%05d event serial m_create Return Code %d Error %d.",
+                     __LINE__, iml_rc, iml_error );
+   }
+   iml_rc = dss_ser_thr_ctrl.dsc_thread.mc_create( &m_serial_thread, NULL );
+   if (iml_rc < 0) {                        /* error occured           */
+     m_hlnew_printf( HLOG_WARN1, "HWSPMnnnW l%05d CreateThread Serial Error", __LINE__ );
+   }
+#endif
+} /* end m_gw_start_htun()                                             */
+
+#ifdef HL_UNIX
+/** search the TUN interface for IPV4                                  */
+static BOOL m_htun_search_interface_ipv4( UNSIG_MED ump_ineta, char *achp_if_name, struct sockaddr *adsp_rhwaddr ) {
+   int        iml1;                         /* working variable        */
+   int        iml_rc;                       /* return code             */
+#define HL_TUN_UNIX_MAX_IF 64
+   struct ifconf dsl_ifconf;                /* interface configuration */
+   struct ifreq dsrl_ifreq[ HL_TUN_UNIX_MAX_IF ];  /* return for each iface */
+
+   memset( &dsl_ifconf, 0, sizeof(struct ifconf) );  /* interface configuration */
+   memset( dsrl_ifreq, 0, sizeof(dsrl_ifreq) );  /* return for each iface */
+   dsl_ifconf.ifc_len = sizeof(dsrl_ifreq);
+   dsl_ifconf.ifc_buf = (char*) dsrl_ifreq;
+   iml_rc = ioctl( dss_tun_ctrl.imc_tun_socket, SIOCGIFCONF, &dsl_ifconf );
+//#ifdef TRACEHL1
+   m_hlnew_printf( HLOG_XYZ1, "nbipgw20-l%05d-T m_htun_search_interface_ipv4() ioctl( ... , SIOCGIFCONF , ... ) returned %d errno %d.",
+                   __LINE__, iml_rc, errno );
+//#endif
+   if (iml_rc < 0) {                        /* error occured           */
+   }
+   iml1 = 0;                                /* clear index             */
+
+   p_check_if_20:                           /* check interface         */
+   if (iml1 >= HL_TUN_UNIX_MAX_IF) {
+     m_hlnew_printf( HLOG_XYZ1, "nbipgw20-l%05d-T m_htun_search_interface_ipv4() no interface for INETA %d.%d.%d.%d found",
+                     __LINE__,
+                     *((unsigned char *) &ump_ineta + 0),  /* <TUN-adapter-use-interface-ineta> */
+                     *((unsigned char *) &ump_ineta + 1),  /* <TUN-adapter-use-interface-ineta> */
+                     *((unsigned char *) &ump_ineta + 2),  /* <TUN-adapter-use-interface-ineta> */
+                     *((unsigned char *) &ump_ineta + 3) );  /* <TUN-adapter-use-interface-ineta> */
+     return FALSE;
+   }
+   /* get flags for each network interfaces                            */
+   iml_rc = ioctl( dss_tun_ctrl.imc_tun_socket, SIOCGIFFLAGS, &dsrl_ifreq[ iml1 ] );
+//#ifdef TRACEHL1
+   m_hlnew_printf( HLOG_XYZ1, "nbipgw20-l%05d-T m_htun_search_interface_ipv4() ioctl( ... , SIOCGIFFLAGS , ... ) returned %d errno %d.",
+                   __LINE__, iml_rc, errno );
+//#endif
+   if (iml_rc < 0) {                        /* error occured           */
+     iml1++;                                /* next interface          */
+     goto p_check_if_20;                    /* check interface         */
+   }
+   if ((dsrl_ifreq[ iml1 ].ifr_flags & IFF_UP) == 0) {
+     iml1++;                                /* next interface          */
+     goto p_check_if_20;                    /* check interface         */
+   }
+   /* get interface INETA                                              */
+   iml_rc = ioctl( dss_tun_ctrl.imc_tun_socket, SIOCGIFADDR, &dsrl_ifreq[ iml1 ] );
+//#ifdef TRACEHL1
+   m_hlnew_printf( HLOG_XYZ1, "nbipgw20-l%05d-T m_htun_search_interface_ipv4() ioctl( ... , SIOCGIFADDR , ... ) returned %d errno %d.",
+                   __LINE__, iml_rc, errno );
+//#endif
+   if (iml_rc < 0) {                        /* error occured           */
+     iml1++;                                /* next interface          */
+     goto p_check_if_20;                    /* check interface         */
+   }
+   if (*((unsigned int *) &(((struct sockaddr_in *) &dsrl_ifreq[ iml1 ].ifr_addr))->sin_addr) != ump_ineta) {
+     iml1++;                                /* next interface          */
+     goto p_check_if_20;                    /* check interface         */
+   }
+   m_hlnew_printf( HLOG_XYZ1, "nbipgw20-l%05d-T m_htun_search_interface_ipv4() found interface \"%.*s\" for INETA %d.%d.%d.%d.",
+                   __LINE__,
+                   IFNAMSIZ, dsrl_ifreq[ iml1 ].ifr_name,
+                   *((unsigned char *) &ump_ineta + 0),  /* <TUN-adapter-use-interface-ineta> */
+                   *((unsigned char *) &ump_ineta + 1),  /* <TUN-adapter-use-interface-ineta> */
+                   *((unsigned char *) &ump_ineta + 2),  /* <TUN-adapter-use-interface-ineta> */
+                   *((unsigned char *) &ump_ineta + 3) );  /* <TUN-adapter-use-interface-ineta> */
+   if (achp_if_name) {
+     memcpy( achp_if_name, dsrl_ifreq[ iml1 ].ifr_name, IFNAMSIZ );
+   }
+   if (adsp_rhwaddr == NULL) return TRUE;
+   iml_rc = ioctl( dss_tun_ctrl.imc_tun_socket, SIOCGIFHWADDR, &dsrl_ifreq[ iml1 ] );
+//#ifdef TRACEHL1
+   m_hlnew_printf( HLOG_XYZ1, "nbipgw20-l%05d-T m_htun_search_interface_ipv4() ioctl( ... , SIOCGIFHWADDR , ... ) returned %d errno %d.",
+                   __LINE__, iml_rc, errno );
+//#endif
+   if (iml_rc < 0) {                        /* error occured           */
+   }
+   memcpy( adsp_rhwaddr, &dsrl_ifreq[ iml1 ].ifr_hwaddr, sizeof(struct sockaddr) );
+   return TRUE;
+} /* end m_htun_search_interface_ipv4()                                */
+#endif
+#endif
+
+#ifdef NEW_HOB_TUN_1103
+extern dsd_vnic dsg_vnic;
+#endif
+
+/** thread for serializiation                                          */
+static htfunc1_t m_serial_thread( void * ) {
+   int        iml_rc;                       /* return code             */
+   int        iml_error;                    /* error code              */
+#ifndef HL_UNIX
+   DWORD      dwl_ret;                      /* return code             */
+#endif
+#ifdef HL_UNIX
+// int        iml_kernel_socket;
+   struct arpreq dsl_arpreq;                /* struct for arp requests */
+   struct rtentry dsl_routereq;             /* struct for route request */
+// struct sockaddr_in dsl_app_ineta_ipv4;   /* application ineta IPV4  */
+#endif
+   struct dsd_ser_thr_task *adsl_sth_w1;    /* working variable        */
+   struct dsd_ser_thr_task dsl_sth_work;    /* work as task for serial thread */
+#ifndef HL_UNIX
+   MIB_IPFORWARDROW dsl_ipforw_01;          /* to set routes           */
+#endif
+
+#ifdef HL_UNIX
+#ifdef XYZ1
+   iml_kernel_socket = socket( AF_INET, SOCK_STREAM, 0 );
+   if (iml_kernel_socket < 0) {             /* error occured           */
+     m_hlnew_printf( HLOG_WARN1, "xxxxxxxx-%05d-W m_serial_thread socket() Return Code %d Error %d.",
+                     __LINE__, iml_kernel_socket, errno );
+   }
+#endif
+#endif
+
+   p_serial_00:                             /* serialisation start     */
+   if (dss_ser_thr_ctrl.adsc_sth_work) {    /* work as task for serial thread */
+     goto p_serial_20;                      /* found work to do        */
+   }
+   iml_rc = dss_ser_thr_ctrl.dsc_event_thr.m_wait( &iml_error );
+   if (iml_rc == 0) goto p_serial_00;       /* serialisation start     */
+// to-do 02.07.10 KB error message
+   m_hlnew_printf( HLOG_WARN1, "xxxxxxxx-%05d-W m_serial_thread thread m_wait Return Code %d Error %d.",
+                   __LINE__, iml_rc, iml_error );
+#ifndef HL_UNIX
+   Sleep( 2000 );                           /* wait some time          */
+#else
+   sleep( 2 );                              /* wait some time          */
+#endif
+   goto p_serial_00;                        /* serialisation start     */
+
+   p_serial_20:                             /* found work to do        */
+   dsg_global_lock.m_enter();               /* enter critical section  */
+   adsl_sth_w1 = dss_ser_thr_ctrl.adsc_sth_work;  /* get work as task for serial thread */
+   memcpy( &dsl_sth_work, adsl_sth_w1, sizeof(struct dsd_ser_thr_task) );
+   dss_ser_thr_ctrl.adsc_sth_work = adsl_sth_w1->adsc_next;  /* remove from chain */
+   adsl_sth_w1->adsc_next = dss_ser_thr_ctrl.adsc_sth_free;  /* get old chain free */
+   dss_ser_thr_ctrl.adsc_sth_free = adsl_sth_w1;  /* set new chain free */
+   dsg_global_lock.m_leave();               /* leave critical section  */
+   switch (dsl_sth_work.iec_sth) {          /* serial thread task type */
+     case ied_sth_route_ipv4_add:           /* add a route IPV4        */
+#ifndef HL_UNIX
+#ifdef B100731
+       dwl_ret = CreateProxyArpEntry( *((DWORD *) dsl_sth_work.chrc_ineta),
+                                      0XFFFFFFFF,  /* 255.255.255.255  */
+                                      dwl_index_if );
+#endif
+       dwl_ret = CreateProxyArpEntry( *((DWORD *) dsl_sth_work.chrc_ineta),
+                                      0XFFFFFFFF,  /* 255.255.255.255  */
+                                      *((DWORD *) &dsl_sth_work.umc_index_if_arp) );
+//#ifdef TRACEHL1
+       m_hlnew_printf( HLOG_XYZ1, "IBIPGW08-l%05d-T CreateProxyArpEntry() returned %d/0X%08X.",
+                       __LINE__, dwl_ret, dwl_ret );
+//#endif
+#ifdef NEW_HOB_TUN_1103
+       dsg_vnic.m_add_arp_entry((char*)&dsl_sth_work.chrc_ineta, "255.255.255.255");
+#endif
+//#endif
+       memset( &dsl_ipforw_01, 0, sizeof(MIB_IPFORWARDROW) );
+       dsl_ipforw_01.dwForwardProto = MIB_IPPROTO_NETMGMT;
+       dsl_ipforw_01.dwForwardIfIndex = *((DWORD *) &dsl_sth_work.umc_index_if_route);
+       dsl_ipforw_01.dwForwardMetric1 = 100;
+       dsl_ipforw_01.dwForwardMetric2 = -1;
+       dsl_ipforw_01.dwForwardMetric3 = -1;
+       dsl_ipforw_01.dwForwardMetric4 = -1;
+       dsl_ipforw_01.dwForwardMetric5 = -1;
+       dsl_ipforw_01.dwForwardDest = *((DWORD *) dsl_sth_work.chrc_ineta);
+//     dsl_ipforw_01.dwForwardMask = *((DWORD *) ucrs_route_mask);
+       dsl_ipforw_01.dwForwardMask = 0XFFFFFFFF;  /* 255.255.255.255   */
+#ifdef B100731
+       dsl_ipforw_01.dwForwardNextHop = *((DWORD *) ucrs_route_next_hop);
+#endif
+#ifdef B120203
+#ifdef B100802
+       dsl_ipforw_01.dwForwardNextHop = *((DWORD *) &dsl_sth_work.umc_taif_ineta);  /* <TUN-adapter-use-interface-ineta> = next hop */
+#endif
+       dsl_ipforw_01.dwForwardNextHop = *((DWORD *) &dsl_sth_work.umc_taif_ineta);  /* <TUN-adapter-use-interface-ineta> = next hop */
+#endif
+#ifdef TRACEHL1
+       m_console_out( (char *) &dsl_ipforw_01, sizeof(MIB_IPFORWARDROW) );
+#endif
+       dwl_ret = CreateIpForwardEntry( &dsl_ipforw_01 );
+//#ifdef TRACEHL1
+       m_hlnew_printf( HLOG_XYZ1, "IBIPGW08-l%05d-T CreateIpForwardEntry() returned %d/0X%08X.",
+                       __LINE__, dwl_ret, dwl_ret );
+//#endif
+       if (dwl_ret == NO_ERROR) break;
+// to-do 05.07.10 KB error message
+       break;
+#endif
+#ifdef HL_UNIX
+       memset( &dsl_arpreq, 0, sizeof(struct arpreq) );  /* struct for arp requests */
+#define ADSL_SOCKADDR_ARP ((struct sockaddr_in *) &dsl_arpreq.arp_pa)
+       ADSL_SOCKADDR_ARP->sin_family = AF_INET;
+       *((unsigned int *) &ADSL_SOCKADDR_ARP->sin_addr)
+         = *((unsigned int *) dsl_sth_work.chrc_ineta);
+#undef ADSL_SOCKADDR_ARP
+       memcpy( &dsl_arpreq.arp_ha, &dss_tun_ctrl.dsc_rhwaddr, sizeof(struct sockaddr) );
+       dsl_arpreq.arp_flags = ATF_PUBL | ATF_NETMASK;
+       memcpy( dsl_arpreq.arp_dev, dss_tun_ctrl.chrc_riface, IFNAMSIZ );
+#define ADSL_SOCKADDR_NETMASK ((struct sockaddr_in *) &dsl_arpreq.arp_pa)
+       ADSL_SOCKADDR_NETMASK->sin_family = AF_INET;
+       *((unsigned int *) &ADSL_SOCKADDR_NETMASK->sin_addr) = 0XFFFFFFFF;  /* 255.255.255.255 */
+#undef ADSL_SOCKADDR_ARP
+       iml_rc = ioctl( dss_tun_ctrl.imc_tun_socket, SIOCSARP, &dsl_arpreq );
+//#ifdef TRACEHL1
+       m_hlnew_printf( HLOG_XYZ1, "nbipgw20-l%05d-T ioctl( ... , SIOCSARP , ... ) returned %d errno %d.",
+                       __LINE__, iml_rc, errno );
+//#endif
+       if (iml_rc < 0) {                    /* error occured           */
+       }
+#ifdef XYZ1
+       memset( &dsl_app_ineta_ipv4, 0, sizeof(struct sockaddr_in) );  /* application ineta IPV4 */
+       dsl_app_ineta_ipv4.sin_family = AF_INET;
+       *((unsigned int *) &dsl_app_ineta_ipv4.sin_addr)
+         = *((unsigned int *) dsl_sth_work.chrc_ineta);
+       memset( &dsl_routereq, 0, sizeof(struct rtentry) );  /* struct for route request */
+       dsl_routereq.rt_dst    = *adsp_addr;
+       dsl_routereq.rt_metric = 31;
+       dsl_routereq.rt_dev    = adsp_tun->chrc_tiface;
+#endif
+       memset( &dsl_routereq, 0, sizeof(struct rtentry) );  /* struct for route request */
+#define ADSL_SOCKADDR_DST ((struct sockaddr_in *) &dsl_routereq.rt_dst)
+       ADSL_SOCKADDR_DST->sin_family = AF_INET;
+       *((unsigned int *) &ADSL_SOCKADDR_DST->sin_addr)
+         = *((unsigned int *) dsl_sth_work.chrc_ineta);
+#undef ADSL_SOCKADDR_DST
+       dsl_routereq.rt_metric = 31;
+       dsl_routereq.rt_dev = dss_tun_ctrl.chrc_tiface;
+#ifndef B121211
+#define ADSL_RT_MASK ((struct sockaddr_in *) &dsl_routereq.rt_genmask)
+       /* set netmask to 255.255.255.255                               */
+       ADSL_RT_MASK->sin_family      = AF_INET;
+       ADSL_RT_MASK->sin_addr.s_addr = 0XFFFFFFFF;
+#undef ADSL_RT_MASK
+#endif
+       iml_rc = ioctl( dss_tun_ctrl.imc_tun_socket, SIOCADDRT, &dsl_routereq );
+//#ifdef TRACEHL1
+       m_hlnew_printf( HLOG_XYZ1, "nbipgw20-l%05d-T ioctl( ... , SIOCADDRT , ... ) returned %d errno %d.",
+                       __LINE__, iml_rc, errno );
+//#endif
+       if (iml_rc < 0) {                    /* error occured           */
+       }
+       break;
+#endif
+     case ied_sth_route_ipv4_del:           /* delete a route IPV4     */
+#ifndef HL_UNIX
+       dwl_ret = DeleteProxyArpEntry( *((DWORD *) dsl_sth_work.chrc_ineta),
+                                      0XFFFFFFFF,  /* 255.255.255.255  */
+                                      *((DWORD *) &dsl_sth_work.umc_index_if_arp) );
+#ifdef TRACEHL1
+       m_hlnew_printf( HLOG_XYZ1, "IBIPGW08-l%05d-T DeleteProxyArpEntry() returned %d/0X%08X.",
+                       __LINE__, dwl_ret, dwl_ret );
+#endif
+#ifndef NEW_HOB_TUN_1103
+       dsg_vnic.m_remove_arp_entry((char*)&dsl_sth_work.chrc_ineta, "255.255.255.255");
+#endif
+       memset( &dsl_ipforw_01, 0, sizeof(MIB_IPFORWARDROW) );
+       dsl_ipforw_01.dwForwardProto = MIB_IPPROTO_NETMGMT;
+       dsl_ipforw_01.dwForwardType = MIB_IPROUTE_TYPE_INDIRECT;
+       dsl_ipforw_01.dwForwardAge = INFINITE;
+       dsl_ipforw_01.dwForwardIfIndex = *((DWORD *) &dsl_sth_work.umc_index_if_route);
+       dsl_ipforw_01.dwForwardMetric1 = 100;
+       dsl_ipforw_01.dwForwardMetric2 = -1;
+       dsl_ipforw_01.dwForwardMetric3 = -1;
+       dsl_ipforw_01.dwForwardMetric4 = -1;
+       dsl_ipforw_01.dwForwardMetric5 = -1;
+       dsl_ipforw_01.dwForwardDest = *((DWORD *) dsl_sth_work.chrc_ineta);
+//     dsl_ipforw_01.dwForwardMask = *((DWORD *) ucrs_route_mask);
+       dsl_ipforw_01.dwForwardMask = 0XFFFFFFFF;  /* 255.255.255.255   */
+#ifdef B100731
+       dsl_ipforw_01.dwForwardNextHop = *((DWORD *) ucrs_route_next_hop);
+#endif
+#ifdef B100802
+       dsl_ipforw_01.dwForwardNextHop = *((DWORD *) &dsl_sth_work.umc_taif_ineta);  /* <TUN-adapter-use-interface-ineta> = next hop */
+#endif
+       dsl_ipforw_01.dwForwardNextHop = *((DWORD *) &dsl_sth_work.umc_taif_ineta);  /* <TUN-adapter-use-interface-ineta> = next hop */
+#ifdef TRACEHL1
+       m_console_out( (char *) &dsl_ipforw_01, sizeof(MIB_IPFORWARDROW) );
+#endif
+       dwl_ret = DeleteIpForwardEntry( &dsl_ipforw_01 );
+//#ifdef TRACEHL1
+       m_hlnew_printf( HLOG_XYZ1, "IBIPGW08-l%05d-T DeleteIpForwardEntry() returned %d/0X%08X.",
+                       __LINE__, dwl_ret, dwl_ret );
+//#endif
+       if (dwl_ret == NO_ERROR) break;
+// to-do 08.08.10 KB error message
+       break;
+#endif
+#ifdef HL_UNIX
+       memset( &dsl_arpreq, 0, sizeof(struct arpreq) );  /* struct for arp requests */
+#define ADSL_SOCKADDR_ARP ((struct sockaddr_in *) &dsl_arpreq.arp_pa)
+       ADSL_SOCKADDR_ARP->sin_family = AF_INET;
+       *((unsigned int *) &ADSL_SOCKADDR_ARP->sin_addr)
+         = *((unsigned int *) dsl_sth_work.chrc_ineta);
+#undef ADSL_SOCKADDR_ARP
+       memcpy( &dsl_arpreq.arp_ha, &dss_tun_ctrl.dsc_rhwaddr, sizeof(struct sockaddr) );
+       dsl_arpreq.arp_flags = ATF_PUBL | ATF_NETMASK;
+       memcpy( dsl_arpreq.arp_dev, dss_tun_ctrl.chrc_riface, IFNAMSIZ );
+#define ADSL_SOCKADDR_NETMASK ((struct sockaddr_in *) &dsl_arpreq.arp_pa)
+       ADSL_SOCKADDR_NETMASK->sin_family = AF_INET;
+       *((unsigned int *) &ADSL_SOCKADDR_NETMASK->sin_addr) = 0XFFFFFFFF;  /* 255.255.255.255 */
+#undef ADSL_SOCKADDR_ARP
+       iml_rc = ioctl( dss_tun_ctrl.imc_tun_socket, SIOCDARP, &dsl_arpreq );
+//#ifdef TRACEHL1
+       m_hlnew_printf( HLOG_XYZ1, "nbipgw20-l%05d-T ioctl( ... , SIOCDARP , ... ) returned %d errno %d.",
+                       __LINE__, iml_rc, errno );
+//#endif
+       if (iml_rc < 0) {                    /* error occured           */
+       }
+       memset( &dsl_routereq, 0, sizeof(struct rtentry) );  /* struct for route request */
+#define ADSL_SOCKADDR_DST ((struct sockaddr_in *) &dsl_routereq.rt_dst)
+       ADSL_SOCKADDR_DST->sin_family = AF_INET;
+       *((unsigned int *) &ADSL_SOCKADDR_DST->sin_addr)
+         = *((unsigned int *) dsl_sth_work.chrc_ineta);
+#undef ADSL_SOCKADDR_DST
+       dsl_routereq.rt_metric = 31;
+       dsl_routereq.rt_dev = dss_tun_ctrl.chrc_tiface;
+#ifndef B121211
+#define ADSL_RT_MASK ((struct sockaddr_in *) &dsl_routereq.rt_genmask)
+       /* set netmask to 255.255.255.255                               */
+       ADSL_RT_MASK->sin_family      = AF_INET;
+       ADSL_RT_MASK->sin_addr.s_addr = 0XFFFFFFFF;
+#undef ADSL_RT_MASK
+#endif
+       iml_rc = ioctl( dss_tun_ctrl.imc_tun_socket, SIOCDELRT, &dsl_routereq );
+//#ifdef TRACEHL1
+       m_hlnew_printf( HLOG_XYZ1, "nbipgw20-l%05d-T ioctl( ... , SIOCDELRT , ... ) returned %d errno %d.",
+                       __LINE__, iml_rc, errno );
+//#endif
+       if (iml_rc < 0) {                    /* error occured           */
+       }
+       break;
+#endif
+   }
+   if (dsl_sth_work.aboc_posted) {          /* with mark posted        */
+     *dsl_sth_work.aboc_posted = TRUE;      /* mark posted             */
+   }
+   if (dsl_sth_work.adsc_event_posted) {    /* event for posted        */
+     iml_rc = dsl_sth_work.adsc_event_posted->m_post( &iml_error );  /* event for posted */
+// to-do 02.07.10 KB error message
+     if (iml_rc < 0) {                     /* error occured           */
+       m_hl1_printf( "xxxxxxxr-%05d-W m_serial_thread thread m_post Return Code %d Error %d",
+                     __LINE__, iml_rc, iml_error );
+     }
+   }
+   goto p_serial_00;                        /* serialisation start     */
+} /* end m_serial_thread()                                             */
+
+#ifdef D_INCL_HOB_TUN
+/** function which returns a newly allocated buffer and its length     */
+extern "C" int m_htun_getrecvbuf( void **aap_handle, char **aachp_buffer ) {
+#ifdef OLD01
+   *aap_handle = new char[16384];
+   *aachp_buffer = (char*)*aap_handle;
+   return 16384;
+#endif
+   *aap_handle = m_proc_alloc();
+   *aachp_buffer = (char *) *aap_handle + sizeof(struct dsd_sdh_control_1) + sizeof(struct dsd_gather_i_1);
+   return LEN_TCP_RECV - sizeof(struct dsd_sdh_control_1) - sizeof(struct dsd_gather_i_1);
+} /* end m_htun_getrecvbuf()                                           */
+
+/** function which releases a previously allocated buffer              */
+extern "C" void m_htun_relrecvbuf( void *ap_handle ) {
+#ifdef OLD01
+   delete ap_handle;
+#endif
+   m_proc_free( ap_handle );
+} /* end m_htun_relrecvbuf()                                           */
+
+/** callback routine for HOB-TUN, HOB-TUN did receive data from the server */
+#ifndef HL_UNIX
+extern "C" BOOL m_se_htun_recvbuf( struct dsd_tun_contr1 *adsp_tctl,
+                                   struct dsd_buf_vector_ele *adsp_vector,
+                                   int imp_ele_vector )
+#else
+extern "C" BOOL m_se_htun_recvbuf( struct dsd_tun_contr_conn *adsp_tun_contr_conn,
+                                   struct dsd_buf_vector_ele *adsp_vector,
+                                   int imp_ele_vector )
+#endif
+{
+   int        iml_index;                    /* index input buffers     */
+   BOOL       bol_act;                      /* activate connection     */
+   BOOL       bol_ret;                      /* return value            */
+#ifndef HL_UNIX
+   class clconn1 *adsl_conn1;               /* class connection        */
+#else
+   struct dsd_conn1 *adsl_conn1;            /* for this connection     */
+#endif
+   struct dsd_sdh_control_1 *adsl_sdhc1_w1;  /* working variable       */
+   struct dsd_sdh_control_1 *adsl_sdhc1_first;  /* first in chain      */
+   struct dsd_sdh_control_1 *adsl_sdhc1_last;  /* last in chain        */
+#ifdef B120601
+   struct dsd_gather_i_1 **aadsl_gai1_w1;   /* for chaining            */
+#endif
+
+#ifndef HL_UNIX
+#ifdef B100702
+   adsl_conn1 = ((class clconn1 *)
+                   ((char *) adsp_tctl
+                      - offsetof( class clconn1, dsc_tun_contr1 )));
+#endif
+#ifndef NEW_HOB_TUN_1103
+#define ADSL_INETA_RAWS_1_G ((struct dsd_ineta_raws_1 *) ((char *) adsp_tctl - offsetof( struct dsd_ineta_raws_1, dsc_tun_contr1 )))
+   adsl_conn1 = (class clconn1 *) ADSL_INETA_RAWS_1_G->ac_conn1;
+#undef ADSL_INETA_RAWS_1_G
+#endif
+#ifdef NEW_HOB_TUN_1103
+   adsl_conn1 = ((class clconn1 *)
+                   ((char *) adsp_tctl
+                      - offsetof( class clconn1, dsc_tun_contr1 )));
+#endif
+#ifdef TRACEHL1
+   m_hlnew_printf( HLOG_XYZ1, "IBIPGW08-l%05d-T m_se_htun_recvbuf() adsp_tctl=%p adsl_conn1=%p.",
+                   __LINE__, adsp_tctl, adsl_conn1 );
+#endif
+#endif
+#ifdef HL_UNIX
+   adsl_conn1 = ((struct dsd_conn1 *)
+                   ((char *) adsp_tun_contr_conn
+                      - offsetof( struct dsd_conn1, dsc_tun_contr_conn )));
+#ifdef TRACEHL1
+   m_hlnew_printf( HLOG_XYZ1, "nbipgw20-l%05d-T m_se_htun_recvbuf() adsp_tun_contr_conn=%p adsl_conn1=%p.",
+                   __LINE__, adsp_tun_contr_conn, adsl_conn1 );
+#endif
+#endif
+   if (adsl_conn1->adsc_sdhc1_s2) {         /* all buffer full         */
+     m_hlnew_printf( HLOG_XYZ1, "IBIPGW08-l%05d-W m_se_htun_recvbuf() adsl_conn1=%p adsc_sdhc1_s2 already set",
+                     __LINE__, adsl_conn1 );
+     return FALSE;
+   }
+#ifndef B120601
+/**
+   the blocks sdhc1 are chained together,
+   but the gather structures are not yet chained together
+*/
+#endif
+   adsl_sdhc1_last = NULL;                  /* clear last in chain     */
+   iml_index = 0;                           /* clear index input buffers */
+   do {                                     /* loop over all input buffers */
+     adsl_sdhc1_w1 = (struct dsd_sdh_control_1 *) (adsp_vector + iml_index)->ac_handle;
+     memset( adsl_sdhc1_w1, 0, sizeof(struct dsd_sdh_control_1) + sizeof(struct dsd_gather_i_1) );
+#define ADSL_GAI1_W1 ((struct dsd_gather_i_1 *) (adsl_sdhc1_w1 + 1))
+     adsl_sdhc1_w1->adsc_gather_i_1_i = ADSL_GAI1_W1;
+     ADSL_GAI1_W1->achc_ginp_cur = (adsp_vector + iml_index)->achc_data;
+     ADSL_GAI1_W1->achc_ginp_end = (adsp_vector + iml_index)->achc_data + (adsp_vector + iml_index)->imc_len_data;
+     if (adsl_sdhc1_last == NULL) {         /* is first in chain       */
+       adsl_sdhc1_first = adsl_sdhc1_w1;
+     } else {                               /* middle in chain         */
+       adsl_sdhc1_last->adsc_next = adsl_sdhc1_w1;
+#ifdef B120601
+       *aadsl_gai1_w1 = ADSL_GAI1_W1;
+#endif
+     }
+#undef ADSL_GAI1_W1
+     adsl_sdhc1_last = adsl_sdhc1_w1;
+#ifdef B120601
+     aadsl_gai1_w1 = ((struct dsd_gather_i_1 **) (adsl_sdhc1_w1 + 1));
+#endif
+     iml_index++;                           /* increment index input buffers */
+   } while (iml_index < imp_ele_vector);    /* till all buffers read   */
+   bol_act = FALSE;                         /* do not activate connection */
+#ifndef HL_UNIX
+   EnterCriticalSection( &adsl_conn1->d_act_critsect );  /* critical section act */
+#else
+   adsl_conn1->dsc_critsect.m_enter();      /* critical section        */
+#endif
+   if (adsl_conn1->adsc_sdhc1_s1 == NULL) {  /* take first buffer      */
+     adsl_conn1->adsc_sdhc1_s1 = adsl_sdhc1_first;  /* set first buffer */
+     if (adsl_conn1->boc_st_act == FALSE) {  /* util-thread not active */
+       adsl_conn1->boc_st_act = TRUE;       /* util-thread active now  */
+       bol_act = TRUE;                      /* activate thread         */
+     }
+     bol_ret = TRUE;                        /* return value            */
+#ifndef B120604
+#ifndef HL_UNIX
+   } else if (   (adsp_tctl->iec_tunc == ied_tunc_ppp)
+              || (adsp_tctl->iec_tunc == ied_tunc_sstp)) {
+#else
+   } else if (   (adsp_tun_contr_conn->iec_tunc == ied_tunc_ppp)
+              || (adsp_tun_contr_conn->iec_tunc == ied_tunc_sstp)) {
+#endif
+     adsl_sdhc1_w1 = adsl_conn1->adsc_sdhc1_s1;  /* get old chain      */
+     while (adsl_sdhc1_w1->adsc_next) adsl_sdhc1_w1 = adsl_sdhc1_w1->adsc_next;
+     adsl_sdhc1_w1->adsc_next = adsl_sdhc1_first;  /* append new buffers */
+#ifdef XYZ1
+     if (adsl_conn1->boc_st_act == FALSE) {  /* util-thread not active */
+       adsl_conn1->boc_st_act = TRUE;       /* util-thread active now  */
+       bol_act = TRUE;                      /* activate thread         */
+     }
+#endif
+     bol_ret = TRUE;                        /* return value            */
+#endif
+   } else {                                 /* take second buffer      */
+// to-do 25.11.08 KB - adsc_sdhc1_s2 already occupied ???
+     adsl_conn1->adsc_sdhc1_s2 = adsl_sdhc1_first;  /* set first buffer */
+     bol_ret = FALSE;                       /* return value            */
+   }
+#ifndef HL_UNIX
+   LeaveCriticalSection( &adsl_conn1->d_act_critsect );  /* critical section act */
+#else
+   adsl_conn1->dsc_critsect.m_leave();      /* critical section        */
+#endif
+   if (bol_act == FALSE) return bol_ret;    /* all done                */
+   m_act_thread_2( adsl_conn1 );            /* activate m_proc_data()  */
+   return bol_ret;                          /* all done                */
+} /* end m_se_htun_recvbuf()                                           */
+
+/** error message when HTCP connect failed                             */
+#ifndef HL_UNIX
+extern "C" void m_htun_htcp_connect_failed( struct dsd_tun_contr1 *adsp_tun_contr1,
+   struct sockaddr *adsp_soa, socklen_t imp_len_soa, int imp_current_index, int imp_total_index, int imp_errno ) {
+#ifdef FORKEDIT
+}
+#endif
+#else
+extern "C" void m_htun_htcp_connect_failed( struct dsd_tun_contr_conn *adsp_tun_contr_conn,
+   struct sockaddr *adsp_soa, socklen_t imp_len_soa, int imp_current_index, int imp_total_index, int imp_errno ) {
+#endif
+   int        iml_rc;                       /* return code             */
+   char       *achl1;                       /* working variable        */
+#ifndef HL_UNIX
+   class clconn1 *adsl_conn1;               /* class connection        */
+#else
+   struct dsd_conn1 *adsl_conn1;            /* for this connection     */
+#endif
+   char       chrl_ineta[ LEN_DISP_INETA ];  /* internet-address char  */
+
+#ifndef HL_UNIX
+#ifdef TRACEHL1
+   m_hlnew_printf( HLOG_XYZ1, "IBIPGW08-l%05d-T m_htun_htcp_connect_failed( %p , ... ) called",
+                   __LINE__, adsp_tun_contr1 );
+#endif
+#ifdef B100702
+   adsl_conn1 = ((class clconn1 *)
+                   ((char *) adsp_tun_contr1
+                      - offsetof( class clconn1, dsc_tun_contr1 )));
+#endif
+#ifndef NEW_HOB_TUN_1103
+#define ADSL_INETA_RAWS_1_G ((struct dsd_ineta_raws_1 *) ((char *) adsp_tun_contr1 - offsetof( struct dsd_ineta_raws_1, dsc_tun_contr1 )))
+   adsl_conn1 = (class clconn1 *) ADSL_INETA_RAWS_1_G->ac_conn1;
+#undef ADSL_INETA_RAWS_1_G
+#endif
+#ifdef NEW_HOB_TUN_1103
+   adsl_conn1 = ((class clconn1 *)
+                   ((char *) adsp_tun_contr1
+                      - offsetof( class clconn1, dsc_tun_contr1 )));
+#endif
+#endif
+#ifdef HL_UNIX
+#ifdef TRACEHL1
+   m_hlnew_printf( HLOG_XYZ1, "nbipgw20-l%05d-T m_htun_htcp_connect_failed( %p , ... ) called",
+                   __LINE__, adsp_tun_contr_conn );
+#endif
+   adsl_conn1 = ((struct dsd_conn1 *)
+                   ((char *) adsp_tun_contr_conn
+                      - offsetof( struct dsd_conn1, dsc_tun_contr_conn )));
+#endif
+   iml_rc = getnameinfo( adsp_soa, imp_len_soa,
+                         chrl_ineta, sizeof(chrl_ineta),
+                         0, 0, NI_NUMERICHOST );
+   if (iml_rc) {                            /* error occured           */
+#ifdef DEBUG_100923_01
+     if (adsl_conn1 == NULL) {
+       m_hlnew_printf( HLOG_XYZ1, "HWSPnnnnW DEBUG_100923_01 GATE=??? SNO=??? INETA=??? l%05d HTUN connect to %s getnameinfo() returned %d %d.",
+                       __LINE__, chrl_ineta, iml_rc, D_TCP_ERROR );
+       return;
+     }
+#endif
+     m_hlnew_printf( HLOG_XYZ1, "HWSPnnnnW GATE=%(ux)s SNO=%08d INETA=%s l%05d getnameinfo() returned %d %d.",
+                     adsl_conn1->adsc_gate1 + 1,
+                     adsl_conn1->dsc_co_sort.imc_sno,
+                     adsl_conn1->chrc_ineta,
+                     __LINE__, iml_rc, D_TCP_ERROR );
+     strcpy( chrl_ineta, "???" );
+   }
+   achl1 = "";
+   if ((imp_current_index + 1) < imp_total_index) {
+     achl1 = " - try next INETA from DNS";  /* set additional text     */
+   } else if (imp_total_index > 1) {
+     achl1 = " - was last INETA from DNS";  /* set additional text     */
+   }
+#ifdef DEBUG_100923_01
+   if (adsl_conn1 == NULL) {
+     m_hlnew_printf( HLOG_XYZ1, "HWSPnnnnW DEBUG_100923_01 GATE=??? SNO=??? INETA=??? l%05d HTUN connect to %s failed %d%s",
+                     __LINE__, chrl_ineta, imp_errno, achl1 );
+     return;
+   }
+#endif
+   m_hlnew_printf( HLOG_XYZ1, "HWSPnnnnW GATE=%(ux)s SNO=%08d INETA=%s l%05d HTUN connect to %s failed %d%s",
+                   adsl_conn1->adsc_gate1 + 1,
+                   adsl_conn1->dsc_co_sort.imc_sno,
+                   adsl_conn1->chrc_ineta,
+                   __LINE__, chrl_ineta, imp_errno, achl1 );
+   return;
+} /* end m_htun_htcp_connect_failed()                                  */
+
+/** connect has been done - either successfully or the connect failed  */
+#ifndef HL_UNIX
+extern "C" void m_htun_htcp_connect_end( struct dsd_tun_contr1 *adsp_tun_contr1,
+                                         int imp_errno ) {
+#ifdef FORKEDIT
+}
+#endif
+#else
+extern "C" void m_htun_htcp_connect_end( struct dsd_tun_contr_conn *adsp_tun_contr_conn,
+                                         struct dsd_target_ineta_1 *adsp_target_ineta_1,
+                                         void * ap_free_ti1,  /* INETA to free */
+                                         struct sockaddr *adsp_soa, socklen_t imp_len_soa,
+                                         int imp_errno ) {
+#endif
+   int        iml_select;                   /* select the events       */
+   int        iml_rc;                       /* return code             */
+   int        iml_error;                    /* error code              */
+   struct dsd_netw_post_1 *adsl_netw_post_1;  /* structure to post from network callback */
+#ifndef HL_UNIX
+   class clconn1 *adsl_conn1;               /* class connection        */
+#else
+   struct dsd_conn1 *adsl_conn1;            /* for this connection     */
+#endif
+
+#ifndef HL_UNIX
+#ifdef TRACEHL1
+   m_hlnew_printf( HLOG_XYZ1, "IBIPGW08-l%05d-T m_htun_htcp_connect_end( %p , ... ) called",
+                   __LINE__, adsp_tun_contr1 );
+#endif
+#else
+#ifdef TRACEHL1
+   m_hlnew_printf( HLOG_XYZ1, "nbipgw20-l%05d-T m_htun_htcp_connect_end( %p , ... ) called",
+                   __LINE__, adsp_tun_contr_conn );
+#endif
+#endif
+#ifdef B100702
+   adsl_conn1 = ((class clconn1 *)
+                   ((char *) adsp_tun_contr1
+                      - offsetof( class clconn1, dsc_tun_contr1 )));
+#endif
+#ifndef HL_UNIX
+#ifndef NEW_HOB_TUN_1103
+#define ADSL_INETA_RAWS_1_G ((struct dsd_ineta_raws_1 *) ((char *) adsp_tun_contr1 - offsetof( struct dsd_ineta_raws_1, dsc_tun_contr1 )))
+   adsl_conn1 = (class clconn1 *) ADSL_INETA_RAWS_1_G->ac_conn1;
+#endif
+#ifdef NEW_HOB_TUN_1103
+   adsl_conn1 = ((class clconn1 *)
+                   ((char *) adsp_tun_contr1
+                      - offsetof( class clconn1, dsc_tun_contr1 )));
+#define ADSL_INETA_RAWS_1_G adsl_conn1->adsc_ineta_raws_1
+#endif
+#endif
+#ifdef HL_UNIX
+   if (ap_free_ti1) free( ap_free_ti1 );    /* INETA to free           */
+   adsl_conn1 = ((struct dsd_conn1 *)
+                   ((char *) adsp_tun_contr_conn
+                      - offsetof( struct dsd_conn1, dsc_tun_contr_conn )));
+#define ADSL_INETA_RAWS_1_G adsl_conn1->adsc_ineta_raws_1
+#endif
+#ifdef HL_UNIX
+#ifdef B130116
+   if (ADSL_INETA_RAWS_1_G->imc_state & DEF_STATE_HTUN_INETA_TARGET) {  /* need to free target INETA */
+     free( adsp_target_ineta_1 );           /* free target INETA       */
+   }
+#endif
+#endif
+   if (imp_errno == 0) goto p_conn_ok;      /* connect succeeded       */
+   iml_select = DEF_NETW_POST_1_HTUN_CONN_ERR;  /* posted for HTUN connect error */
+   do {                                     /* pseudo-loop             */
+#ifdef OLD_1112
+     if (adsl_conn1->adsc_radqu) {          /* radius still active     */
+       adsl_conn1->adsc_radqu->imc_connect_error = imp_errno;
+       break;
+     }
+#endif
+#ifndef HL_UNIX
+#ifdef B101214
+     adsl_conn1->iec_st_ses = clconn1::ied_ses_error_conn;  /* status server error */
+     if (adsl_conn1->adsc_server_conf_1->boc_dynamic == FALSE) break;  /* not dynamicly allocated */
+     adsl_conn1->iec_st_ses = clconn1::ied_ses_error_co_dyn;  /* status server error */
+#else
+     if (adsl_conn1->iec_st_ses != clconn1::ied_ses_wait_conn_s_dynamic) {  /* wait for dynamic connect to server */
+       adsl_conn1->iec_st_ses = clconn1::ied_ses_error_conn;  /* status server error */
+     } else {
+       adsl_conn1->iec_st_ses = clconn1::ied_ses_error_co_dyn;  /* status server error */
+     }
+#endif
+#endif
+#ifdef HL_UNIX
+     if (adsl_conn1->iec_st_ses != ied_ses_wait_conn_s_dynamic) {  /* wait for dynamic connect to server */
+       adsl_conn1->iec_st_ses = ied_ses_error_conn;  /* status server error */
+     } else {
+       adsl_conn1->iec_st_ses = ied_ses_error_co_dyn;  /* status server error */
+     }
+#endif
+   } while (FALSE);
+   goto p_ret_00;                           /* return to HOB-TUN       */
+
+   p_conn_ok:                               /* connect succeeded       */
+#ifdef HL_UNIX
+   if (ADSL_INETA_RAWS_1_G->imc_state & DEF_STATE_HTUN_NO_FREE_INETA) {  /* do not free local INETA */
+     ADSL_INETA_RAWS_1_G->imc_state &= -1 - DEF_STATE_HTUN_NO_FREE_INETA;  /* do free local INETA at session end */
+   }
+#endif
+   iml_select = DEF_NETW_POST_1_HTUN_CONN_OK;  /* posted for HOB-TUN connect ok */
+   ADSL_INETA_RAWS_1_G->imc_state |= DEF_STATE_HTUN_CONN_OK;  /* done HOB-TUN connect ok */
+   m_hlnew_printf( HLOG_INFO1, "HWSPnnnnI GATE=%(ux)s SNO=%08d INETA=%s connect (HTCP) to %(ux)s successful",
+                   adsl_conn1->adsc_gate1 + 1,
+                   adsl_conn1->dsc_co_sort.imc_sno,
+                   adsl_conn1->chrc_ineta,
+                   (char *) (adsl_conn1->adsc_server_conf_1 + 1)
+                     + adsl_conn1->adsc_server_conf_1->inc_no_sdh
+                       * sizeof(struct dsd_sdh_work_1) );
+#ifndef HL_UNIX
+#ifndef X101214_XX
+   adsl_conn1->iec_st_ses = clconn1::ied_ses_start_server_1;  /* status server continue */
+#else
+   if (adsl_conn1->iec_st_ses != clconn1::ied_ses_wait_conn_s_dynamic) {  /* wait for dynamic connect to server */
+     adsl_conn1->iec_st_ses = clconn1::ied_ses_start_server_1;  /* status server continue */
+   } else {
+     adsl_conn1->iec_st_ses = clconn1::ied_ses_start_dyn_serv_1;  /* start connection to server part one dynamic */
+   }
+#endif
+#endif
+#ifdef HL_UNIX
+   adsl_conn1->iec_st_ses = ied_ses_start_server_1;  /* status server continue */
+#endif
+
+   p_ret_00:                                /* return to HOB-TUN       */
+   if (adsl_conn1->adsc_wsp_auth_1) {       /* authentication active   */
+     adsl_conn1->adsc_wsp_auth_1->imc_connect_error = imp_errno;  /* set connect error */
+     adsl_conn1->adsc_wsp_auth_1->boc_did_connect = TRUE;  /* did connect */
+     adsl_conn1->adsc_wsp_auth_1->boc_notify = TRUE;  /* notify authentication routine */
+   }
+   if (adsl_conn1->adsc_int_webso_conn_1) {  /* connect for WebSocket applications - internal */
+     adsl_conn1->adsc_int_webso_conn_1->imc_connect_error = imp_errno;  /* set connect error */
+     adsl_conn1->adsc_int_webso_conn_1->boc_did_connect = TRUE;  /* did connect */
+     adsl_conn1->adsc_int_webso_conn_1->boc_notify = TRUE;  /* notify SDH */
+   }
+   adsl_netw_post_1 = ADSL_INETA_RAWS_1_G->adsc_netw_post_1;  /* get structure to post from network callback */
+   if (   (adsl_netw_post_1)                /* has to do post          */
+       && (iml_select & adsl_netw_post_1->imc_select)) {  /* is selected */
+     ADSL_INETA_RAWS_1_G->adsc_netw_post_1 = NULL;  /* remove structure to post from network callback */
+     adsl_netw_post_1->boc_posted = TRUE;   /* event has been posted   */
+     iml_rc = adsl_netw_post_1->adsc_event->m_post( &iml_error );  /* event for posted */
+     if (iml_rc < 0) {                      /* error occured           */
+       m_hl1_printf( "xxxxxxxr-%05d-W m_htun_htcp_connect_end() m_post Return Code %d Error %d.",
+                     __LINE__, iml_rc, iml_error );
+     }
+   }
+   m_act_thread_1( adsl_conn1 );            /* activate thread for session */
+   return;                                  /* all done                */
+#undef ADSL_INETA_RAWS_1_G
+} /* end m_htun_htcp_connect_end()                                     */
+
+#ifndef HL_UNIX
+/** WSP can free the target INETA                                      */
+extern "C" void m_htun_htcp_free_target_ineta( struct dsd_tun_contr1 *adsp_tun_contr1,
+                                               struct dsd_target_ineta_1 *adsp_target_ineta_1 ) {
+   class clconn1 *adsl_conn_w1;             /* class connection        */
+
+#ifndef NEW_HOB_TUN_1103
+#define ADSL_INETA_RAWS_1_G ((struct dsd_ineta_raws_1 *) ((char *) adsp_tun_contr1 - offsetof( struct dsd_ineta_raws_1, dsc_tun_contr1 )))
+   adsl_conn_w1 = (class clconn1 *) ADSL_INETA_RAWS_1_G->ac_conn1;
+#endif
+#ifdef NEW_HOB_TUN_1103
+   adsl_conn_w1 = ((class clconn1 *)
+                     ((char *) adsp_tun_contr1
+                        - offsetof( class clconn1, dsc_tun_contr1 )));
+#endif
+   if (adsl_conn_w1->adsc_server_conf_1 == NULL) return;
+   if (adsl_conn_w1->adsc_server_conf_1->inc_function != DEF_FUNC_DIR) return;
+   if (adsl_conn_w1->adsc_server_conf_1->boc_dynamic) return;  /* dynamically allocated */
+   if (adsl_conn_w1->adsc_server_conf_1->boc_dns_lookup_before_connect == FALSE) return;  /* needs to solve INETA before connect */
+   if (adsp_target_ineta_1 == adsl_conn_w1->adsc_server_conf_1->adsc_server_ineta) return;
+   free( adsp_target_ineta_1 );             /* free the memory         */
+   return;
+#ifndef NEW_HOB_TUN_1103
+#undef ADSL_INETA_RAWS_1_G
+#endif
+} /* end m_htun_htcp_free_target_ineta()                               */
+#endif
+
+/** TCP session of HTCP / HOB-TUN has sent something to the server     */
+#ifndef HL_UNIX
+extern "C" void m_htun_htcp_send_complete( struct dsd_tun_contr1 *adsp_tun_contr1 ) {
+#ifdef FORKEDIT
+}
+#endif
+#else
+extern "C" void m_htun_htcp_send_complete( struct dsd_tun_contr_conn *adsp_tun_contr_conn ) {
+#endif
+   int        iml_rc;                       /* return code             */
+   int        iml_error;                    /* error code              */
+   struct dsd_netw_post_1 *adsl_netw_post_1;  /* structure to post from network callback */
+#ifndef HL_UNIX
+   class clconn1 *adsl_conn1;               /* class connection        */
+#else
+   struct dsd_conn1 *adsl_conn1;            /* for this connection     */
+#endif
+
+#ifdef B100824
+   m_hlnew_printf( HLOG_XYZ1, "IBIPGW08-l%05d-T m_htun_htcp_send_complete( %p ) called",
+                   __LINE__, adsp_tun_contr1 );
+#endif
+#ifndef HL_UNIX
+#ifndef NEW_HOB_TUN_1103
+#define ADSL_INETA_RAWS_1_G ((struct dsd_ineta_raws_1 *) ((char *) adsp_tun_contr1 - offsetof( struct dsd_ineta_raws_1, dsc_tun_contr1 )))
+   adsl_conn1 = (class clconn1 *) ADSL_INETA_RAWS_1_G->ac_conn1;
+#endif
+#ifdef NEW_HOB_TUN_1103
+   adsl_conn1 = ((class clconn1 *)
+                   ((char *) adsp_tun_contr1
+                      - offsetof( class clconn1, dsc_tun_contr1 )));
+#define ADSL_INETA_RAWS_1_G adsl_conn1->adsc_ineta_raws_1
+#endif
+#endif
+#ifdef HL_UNIX
+   adsl_conn1 = ((struct dsd_conn1 *)
+                   ((char *) adsp_tun_contr_conn
+                      - offsetof( struct dsd_conn1, dsc_tun_contr_conn )));
+#define ADSL_INETA_RAWS_1_G adsl_conn1->adsc_ineta_raws_1
+#endif
+   ADSL_INETA_RAWS_1_G->imc_state |= DEF_STATE_HTUN_SEND_COMPL;  /* done HOB-TUN send complete - m_htun_htcp_send_complete() */
+   adsl_netw_post_1 = ADSL_INETA_RAWS_1_G->adsc_netw_post_1;  /* get structure to post from network callback */
+   if (   (adsl_netw_post_1)                /* has to do post          */
+       && (adsl_netw_post_1->imc_select & DEF_NETW_POST_1_HTUN_SEND_COMPL)) {  /* posted for HTUN HTCP send complete */
+     ADSL_INETA_RAWS_1_G->adsc_netw_post_1 = NULL;  /* remove structure to post from network callback */
+     adsl_netw_post_1->boc_posted = TRUE;   /* event has been posted  */
+     iml_rc = adsl_netw_post_1->adsc_event->m_post( &iml_error );  /* event for posted */
+     if (iml_rc < 0) {                      /* error occured           */
+       m_hl1_printf( "xxxxxxxr-%05d-W m_htun_htcp_send_complete() m_post Return Code %d Error %d.",
+                     __LINE__, iml_rc, iml_error );
+     }
+   }
+   if (adsl_conn1 == NULL) return;
+   m_act_thread_1( adsl_conn1 );            /* activate thread for session */
+   return;                                  /* all done                */
+#undef ADSL_INETA_RAWS_1_G
+} /* end m_htun_htcp_send_complete()                                   */
+
+/** TCP session of HOB-TUN, HTCP HOB-PPP-T1 or SSTP has ended          */
+#ifndef HL_UNIX
+extern "C" void m_htun_session_end( struct dsd_tun_contr1 *adsp_tun_contr1,
+                                    int imp_reason ) {
+#ifdef FORKEDIT
+}
+#endif
+#else
+extern "C" void m_htun_session_end( struct dsd_tun_contr_conn *adsp_tun_contr_conn,
+                                    int imp_reason ) {
+#endif
+   int        iml_rc;                       /* return code             */
+   int        iml_error;                    /* error code              */
+   int        iml_state_l;                  /* state of HTUN / HTCP session */
+#ifdef HL_UNIX
+   int        *aiml_state_a;                /* address state of HTUN / HTCP session */
+   void       **avpl_netw_post_1;           /* address clear structure to post */
+#endif
+   struct dsd_ineta_raws_1 *adsl_ineta_raws_1_w1;  /* used INETA       */
+   struct dsd_netw_post_1 *adsl_netw_post_1;  /* structure to post from network callback */
+#ifndef HL_UNIX
+   class clconn1 *adsl_conn1;               /* class connection        */
+#else
+   struct dsd_conn1 *adsl_conn1;            /* for this connection     */
+#endif
+#ifdef HL_UNIX
+   struct dsd_server_conf_1 *adsl_server_conf_1_w1;  /* working variable */
+#endif
+   struct dsd_sdh_control_1 *adsl_sdhc1_w1;  /* working variable       */
+
+#ifdef TRACEHL1
+   m_hlnew_printf( HLOG_TRACE1, "xiipgw08-tun-l%05d-T m_htun_session_end( %p , %d ) called",
+                   __LINE__, adsp_tun_contr_conn, imp_reason );
+#endif
+#ifndef HL_UNIX
+#ifndef NEW_HOB_TUN_1103
+#define ADSL_INETA_RAWS_1_G ((struct dsd_ineta_raws_1 *) ((char *) adsp_tun_contr1 - offsetof( struct dsd_ineta_raws_1, dsc_tun_contr1 )))
+   adsl_conn1 = (class clconn1 *) ADSL_INETA_RAWS_1_G->ac_conn1;
+#endif
+#ifdef NEW_HOB_TUN_1103
+   adsl_conn1 = ((class clconn1 *)
+                   ((char *) adsp_tun_contr1
+                      - offsetof( class clconn1, dsc_tun_contr1 )));
+#define ADSL_INETA_RAWS_1_G adsl_conn1->adsc_ineta_raws_1
+#endif
+#endif
+#ifdef HL_UNIX
+   adsl_conn1 = ((struct dsd_conn1 *)
+                   ((char *) adsp_tun_contr_conn
+                      - offsetof( struct dsd_conn1, dsc_tun_contr_conn )));
+#define ADSL_INETA_RAWS_1_G adsl_conn1->adsc_ineta_raws_1
+#endif
+#ifdef B100811
+   if (adsl_conn1 == NULL) goto p_sess_end_20;  /* no connection associated */
+   adsl_conn1->iec_servcotype = ied_servcotype_none;  /* no server connection */
+   while (adsl_conn1->adsc_sdhc1_htun_sch) {  /* loop over all buffers  */
+     adsl_sdhc1_w1 = adsl_conn1->adsc_sdhc1_htun_sch;  /* save this buffer */
+     adsl_conn1->adsc_sdhc1_htun_sch = adsl_conn1->adsc_sdhc1_htun_sch->adsc_next;  /* get next in chain */
+     m_proc_free( adsl_sdhc1_w1 );          /* free this buffer        */
+   }
+   if (adsl_conn1->achc_reason_end == NULL) {  /* reason end session   */
+     /* do not set when dynamic server                                 */
+     if (   (adsl_conn1->adsc_server_conf_1 == NULL)
+         || (adsl_conn1->adsc_server_conf_1->boc_dynamic == FALSE)) {
+       if (imp_reason == 0) {               /* normal end              */
+         adsl_conn1->achc_reason_end = "server normal end";
+       } else {                             /* abnormal end            */
+         adsl_conn1->achc_reason_end = "server ended with error";
+       }
+     }
+   }
+// to-do 29.11.08 KB - notify session, start work-thread, set session-status
+   p_sess_end_20:                           /* connection part has been processed */
+#endif
+#ifdef TRACEHL1
+   m_hlnew_printf( HLOG_TRACE1, "xiipgw08-tun-l%05d-T m_htun_session_end() ADSL_INETA_RAWS_1_G=%p adsl_conn1->adsc_server_conf_1=%p.",
+                   __LINE__, ADSL_INETA_RAWS_1_G, adsl_conn1->adsc_server_conf_1 );
+#endif
+#ifdef HL_UNIX
+   aiml_state_a = NULL;                     /* address state of HTUN / HTCP session */
+   adsl_netw_post_1 = NULL;                 /* get structure to post from network callback */
+   adsl_ineta_raws_1_w1 = ADSL_INETA_RAWS_1_G;
+   adsl_server_conf_1_w1 = adsl_conn1->adsc_server_conf_1;
+   if (   (adsl_server_conf_1_w1)
+       && (   (adsl_server_conf_1_w1->inc_function == DEF_FUNC_HPPPT1)   /* PPP type session  */
+           || (adsl_server_conf_1_w1->inc_function == DEF_FUNC_SSTP))) {  /* SSTP session type */
+     aiml_state_a                           /* address state of HTUN / HTCP session */
+       = &adsl_conn1->imc_ppp_state;        /* PPP state               */
+     adsl_netw_post_1                       /* get structure to post from network callback */
+       = adsl_conn1->adsc_ppp_netw_post_1;  /* structure to post from network callback */
+     avpl_netw_post_1                       /* address clear structure to post */
+       = (void **) &adsl_conn1->adsc_ppp_netw_post_1;  /* address structure to post from network callback */
+     adsl_ineta_raws_1_w1 = NULL;
+   }
+   if (adsl_ineta_raws_1_w1) {
+     aiml_state_a                           /* address state of HTUN / HTCP session */
+       = &adsl_ineta_raws_1_w1->imc_state;  /* HTCP state              */
+     adsl_netw_post_1                       /* get structure to post from network callback */
+       = adsl_ineta_raws_1_w1->adsc_netw_post_1;  /* structure to post from network callback */
+     avpl_netw_post_1                       /* address clear structure to post */
+       = (void **) &adsl_ineta_raws_1_w1->adsc_netw_post_1;  /* address structure to post from network callback */
+   }
+   ADSL_INETA_RAWS_1_G = NULL;
+   iml_state_l = DEF_STATE_HTUN_SESS_END;     /* done HOB-TUN HTCP session end */
+   if (imp_reason) {                        /* abnormal end            */
+     iml_state_l |= DEF_STATE_HTUN_ERR_SESS_END;  /* done HOB-TUN HTCP session end was with error */
+   }
+   if (aiml_state_a) {                      /* address state of HTUN / HTCP session */
+     *aiml_state_a |= iml_state_l;          /* state of HOB-TUN / HTCP session */
+   }
+   if (   (adsl_netw_post_1)                /* has to do post          */
+       && (adsl_netw_post_1->imc_select & DEF_NETW_POST_1_HTUN_SESS_END)) {  /* posted for HOB-TUN HTCP session end */
+     *avpl_netw_post_1 = NULL;              /* address clear structure to post */
+     adsl_netw_post_1->boc_posted = TRUE;   /* event has been posted  */
+     iml_rc = adsl_netw_post_1->adsc_event->m_post( &iml_error );  /* event for posted */
+     if (iml_rc < 0) {                      /* error occured           */
+       m_hl1_printf( "xxxxxxxr-%05d-W m_htun_session_end() m_post Return Code %d Error %d.",
+                     __LINE__, iml_rc, iml_error );
+     }
+   }
+#endif
+#ifndef HL_UNIX
+   adsl_ineta_raws_1_w1 = ADSL_INETA_RAWS_1_G;
+   if (adsl_ineta_raws_1_w1 == NULL) return;
+   iml_state_l = DEF_STATE_HTUN_SESS_END;     /* done HOB-TUN HTCP session end */
+   if (imp_reason) {                        /* abnormal end            */
+     iml_state_l |= DEF_STATE_HTUN_ERR_SESS_END;  /* done HOB-TUN HTCP session end was with error */
+   }
+   adsl_ineta_raws_1_w1->imc_state |= iml_state_l;  /* state of HOB-TUN / HTCP session */
+   adsl_netw_post_1 = adsl_ineta_raws_1_w1->adsc_netw_post_1;  /* get structure to post from network callback */
+   if (   (adsl_netw_post_1)                /* has to do post          */
+       && (adsl_netw_post_1->imc_select & DEF_NETW_POST_1_HTUN_SESS_END)) {  /* posted for HOB-TUN HTCP session end */
+     adsl_ineta_raws_1_w1->adsc_netw_post_1 = NULL;  /* remove structure to post from network callback */
+     adsl_netw_post_1->boc_posted = TRUE;   /* event has been posted  */
+     iml_rc = adsl_netw_post_1->adsc_event->m_post( &iml_error );  /* event for posted */
+     if (iml_rc < 0) {                      /* error occured           */
+       m_hl1_printf( "xxxxxxxr-%05d-W m_htun_session_end() m_post Return Code %d Error %d.",
+                     __LINE__, iml_rc, iml_error );
+     }
+   }
+#endif
+#ifdef HL_UNIX
+   adsl_conn1->iec_servcotype = ied_servcotype_none;  /* no server connection */
+   while (adsl_conn1->adsc_sdhc1_htun_sch) {  /* loop over all buffers  */
+     adsl_sdhc1_w1 = adsl_conn1->adsc_sdhc1_htun_sch;  /* save this buffer */
+     adsl_conn1->adsc_sdhc1_htun_sch = adsl_conn1->adsc_sdhc1_htun_sch->adsc_next;  /* get next in chain */
+     m_proc_free( adsl_sdhc1_w1 );          /* free this buffer        */
+   }
+   if (adsl_conn1->achc_reason_end == NULL) {  /* reason end session   */
+     /* do not set when dynamic server                                 */
+     if (   (adsl_conn1->adsc_server_conf_1 == NULL)
+         || (adsl_conn1->adsc_server_conf_1->boc_dynamic == FALSE)) {
+       if (imp_reason == 0) {               /* normal end              */
+         adsl_conn1->achc_reason_end = "server normal end";
+       } else {                             /* abnormal end            */
+         adsl_conn1->achc_reason_end = "server ended with error";
+       }
+     }
+   }
+   adsl_conn1->iec_st_ses = ied_ses_rec_close;  /* received close      */
+#endif
+#ifdef B120206
+   if (   (ADSL_INETA_RAWS_1_G->iec_irs != ied_ineta_raws_n_ipv4)  /* INETA IPV4 */
+       && (ADSL_INETA_RAWS_1_G->iec_irs != ied_ineta_raws_n_ipv6)) {  /* INETA IPV6 */
+     goto p_sess_end_40;                    /* connection part has been processed */
+   }
+   ADSL_INETA_RAWS_1_G->ac_conn1 = NULL;    /* not associated with session */
+   adsl_conn1->adsc_ineta_raws_1 = NULL;    /* no more INETA associated */
+   adsl_conn1->iec_servcotype = ied_servcotype_none;  /* no server connection */
+   while (adsl_conn1->adsc_sdhc1_htun_sch) {  /* loop over all buffers  */
+     adsl_sdhc1_w1 = adsl_conn1->adsc_sdhc1_htun_sch;  /* save this buffer */
+     adsl_conn1->adsc_sdhc1_htun_sch = adsl_conn1->adsc_sdhc1_htun_sch->adsc_next;  /* get next in chain */
+     m_proc_free( adsl_sdhc1_w1 );          /* free this buffer        */
+   }
+   if (adsl_conn1->achc_reason_end == NULL) {  /* reason end session   */
+     /* do not set when dynamic server                                 */
+     if (   (adsl_conn1->adsc_server_conf_1 == NULL)
+         || (adsl_conn1->adsc_server_conf_1->boc_dynamic == FALSE)) {
+       if (imp_reason == 0) {               /* normal end              */
+         adsl_conn1->achc_reason_end = "server normal end";
+       } else {                             /* abnormal end            */
+         adsl_conn1->achc_reason_end = "server ended with error";
+       }
+     }
+   }
+
+   p_sess_end_40:                           /* connection part has been processed */
+#endif
+   m_act_thread_1( adsl_conn1 );            /* activate thread for session */
+   return;                                  /* all done                */
+#undef ADSL_INETA_RAWS_1_G
+} /* end m_htun_session_end()                                          */
+
+#ifndef HL_UNIX
+/** session of HOB-TUN has ended, free all resources                   */
+extern "C" void m_htun_free_resources( struct dsd_tun_contr1 *adsp_tun_contr1 ) {
+   BOOL       bol_free;                     /* this routine does free  */
+   int        iml_state;                    /* state of HTUN / HTCP session */
+   int        iml_rc;                       /* return code             */
+   int        iml_error;                    /* error code              */
+   struct dsd_netw_post_1 *adsl_netw_post_1;  /* structure to post from network callback */
+#ifndef HL_UNIX
+   class clconn1 *adsl_conn1;               /* class connection        */
+#else
+   struct dsd_conn1 *adsl_conn1;            /* for this connection     */
+#endif
+
+#ifdef B100824
+   m_hlnew_printf( HLOG_XYZ1, "IBIPGW08-l%05d-T m_htun_free_resources( %p ) called",
+                   __LINE__, adsp_tun_contr1 );
+#endif
+   bol_free = FALSE;                        /* this routine does free  */
+#ifndef NEW_HOB_TUN_1103
+#define ADSL_INETA_RAWS_1_G ((struct dsd_ineta_raws_1 *) ((char *) adsp_tun_contr1 - offsetof( struct dsd_ineta_raws_1, dsc_tun_contr1 )))
+   adsl_conn1 = (class clconn1 *) ADSL_INETA_RAWS_1_G->ac_conn1;
+#endif
+#ifdef NEW_HOB_TUN_1103
+   adsl_conn1 = ((class clconn1 *)
+                   ((char *) adsp_tun_contr1
+                      - offsetof( class clconn1, dsc_tun_contr1 )));
+#define ADSL_INETA_RAWS_1_G adsl_conn1->adsc_ineta_raws_1
+#endif
+   iml_state = DEF_STATE_HTUN_FREE_R_1;     /* done HOB-TUN free resources */
+   if (adsl_conn1) {                        /* connection still alive  */
+     adsl_conn1->iec_servcotype = ied_servcotype_none;  /* no server connection */
+#ifdef NEW_HOB_TUN_1103
+     adsl_conn1->dsc_htun_h = NULL;         /* handle for HOB-TUN      */
+#endif
+   } else {                                 /* connection not still alive  */
+     iml_state |= DEF_STATE_HTUN_FREE_R_2;  /* done HTUN free resources */
+   }
+#ifdef NEW_HOB_TUN_1103
+   if (ADSL_INETA_RAWS_1_G == NULL) return;
+#endif
+   ADSL_INETA_RAWS_1_G->imc_state |= iml_state;  /* done HTUN free resources */
+#ifndef NEW_HOB_TUN_1103
+   ADSL_INETA_RAWS_1_G->dsc_htun_h = NULL;  /* handle for HTUN         */
+#endif
+   adsl_netw_post_1 = ADSL_INETA_RAWS_1_G->adsc_netw_post_1;  /* get structure to post from network callback */
+   if (   (adsl_netw_post_1)                /* has to do post          */
+       && (adsl_netw_post_1->imc_select & DEF_NETW_POST_1_HTUN_FREE_R)) {  /* posted for HTUN free resources */
+     ADSL_INETA_RAWS_1_G->adsc_netw_post_1 = NULL;  /* remove structure to post from network callback */
+     adsl_netw_post_1->boc_posted = TRUE;   /* event has been posted   */
+     iml_rc = adsl_netw_post_1->adsc_event->m_post( &iml_error );  /* event for posted */
+     if (iml_rc < 0) {                      /* error occured           */
+       m_hl1_printf( "xxxxxxxr-%05d-W m_htun_free_resources() m_post Return Code %d Error %d.",
+                     __LINE__, iml_rc, iml_error );
+     }
+   }
+   if ((iml_state & DEF_STATE_HTUN_FREE_R_2) == 0) {  /* done HTUN free resources part two */
+     return;                                /* clconn1::close1() will free the memory */
+   }
+   m_cleanup_htun_ineta( ADSL_INETA_RAWS_1_G );
+#ifndef TRY_120126_01
+   if (ADSL_INETA_RAWS_1_G->adsc_auxf_1_ident) {  /* store ident to free */
+     free( ADSL_INETA_RAWS_1_G->adsc_auxf_1_ident );  /* free ident    */
+   }
+#endif
+#define ADSL_TIMER_G ((struct dsd_timer_ele *) ADSL_INETA_RAWS_1_G)  /* timer to free memory later */
+   memset( ADSL_TIMER_G, 0, sizeof(struct dsd_timer_ele) );
+   ADSL_TIMER_G->amc_compl = &m_timeout_free_memory;  /* set routine for timeout */
+   ADSL_TIMER_G->ilcwaitmsec = TIMER_FREE_MEMORY;  /* timer to wait some time before freeing memory */
+   m_time_set( ADSL_TIMER_G, FALSE );       /* set timeout now         */
+#undef ADSL_TIMER_G
+#undef ADSL_INETA_RAWS_1_G
+} /* end m_htun_free_resources()                                       */
+#endif
+#ifdef HL_UNIX
+/** session of HOB-TUN has ended, free all resources                   */
+extern "C" void m_htun_htcp_free_resources( struct dsd_tun_contr_ineta *adsp_tun_contr_ineta ) {
+   int        iml_rc;                       /* return code             */
+   int        iml_error;                    /* error code              */
+   struct dsd_netw_post_1 *adsl_netw_post_1;  /* structure to post from network callback */
+
+#ifdef TRACEHL1
+   m_hlnew_printf( HLOG_XYZ1, "HOB-TUN l%05d m_htun_free_resources( %p ) called",
+                   __LINE__, adsp_tun_contr_ineta );
+#endif
+#define ADSL_INETA_RAWS_1_G ((struct dsd_ineta_raws_1 *) ((char *) adsp_tun_contr_ineta - offsetof( struct dsd_ineta_raws_1, dsc_tun_contr_ineta )))
+#define ADSL_CONN1_G ((struct dsd_conn1 *) ADSL_INETA_RAWS_1_G->ac_conn1)
+   m_hl_lock_dec_1( &ADSL_CONN1_G->imc_references );  /* references to this session */
+   adsl_netw_post_1 = ADSL_INETA_RAWS_1_G->adsc_netw_post_1;  /* get structure to post from network callback */
+   if (   (adsl_netw_post_1)                /* has to do post          */
+       && (adsl_netw_post_1->imc_select & DEF_NETW_POST_1_HTUN_FREE_R)) {  /* posted for HOB-TUN free resources */
+     ADSL_INETA_RAWS_1_G->adsc_netw_post_1 = NULL;  /* remove structure to post from network callback */
+     adsl_netw_post_1->boc_posted = TRUE;   /* event has been posted   */
+     iml_rc = adsl_netw_post_1->adsc_event->m_post( &iml_error );  /* event for posted */
+     if (iml_rc < 0) {                      /* error occured           */
+       m_hl1_printf( "xxxxxxxr-%05d-W m_htun_htcp_free_resources() m_post Return Code %d Error %d.",
+                     __LINE__, iml_rc, iml_error );
+     }
+   }
+   if (ADSL_INETA_RAWS_1_G->imc_state & DEF_STATE_HTUN_NO_FREE_INETA) return;  /* do not free local INETA */
+   m_cleanup_htun_ineta( ADSL_INETA_RAWS_1_G );  /* remove from AVL-trees and remove ARP and route */
+   free( ADSL_INETA_RAWS_1_G );             /* free memory             */
+#undef ADSL_INETA_RAWS_1_G
+#undef ADSL_CONN1_G
+} /* end m_htun_htcp_free_resources()                                  */
+
+/** free resources for HOB-TUN PPP, HOB-PPP-T1 or SSTP                 */
+extern "C" void m_htun_ppp_free_resources( struct dsd_tun_contr_ineta *adsp_tun_contr_ineta ) {
+#define ADSL_INETA_RAWS_1_G ((struct dsd_ineta_raws_1 *) ((char *) adsp_tun_contr_ineta - offsetof( struct dsd_ineta_raws_1, dsc_tun_contr_ineta )))
+   m_cleanup_htun_ineta( ADSL_INETA_RAWS_1_G );  /* remove from AVL-trees and remove ARP and route */
+   free( ADSL_INETA_RAWS_1_G );             /* free memory             */
+#undef ADSL_INETA_RAWS_1_G
+} /* end m_htun_ppp_free_resources()                                   */
+#endif
+
+/** put a warning related to the session to the console                */
+#ifndef HL_UNIX
+extern "C" void m_htun_warning( struct dsd_tun_contr1 *adsp_tun_contr1,
+                                int imp_error_number,
+                                const char *achp_format, ... ) {
+   int        iml_rc;                       /* return code             */
+   int        iml_len;                      /* length of message       */
+   int        iml_cpy_pos;                  /* position of copy        */
+   int        iml_cpy_len;                  /* length of copy          */
+#ifndef HL_UNIX
+   class clconn1 *adsl_conn1;               /* class connection        */
+#else
+   struct dsd_conn1 *adsl_conn1;            /* for this connection     */
+#endif
+   va_list    dsl_list;                     /* list of arguments       */
+   struct sockaddr_storage dsl_soa;         /* filled with INETA       */
+   char       chrl_ineta[ LEN_DISP_INETA ];  /* internet-address char  */
+   char       chrl_port[ 32 ];              /* for message port        */
+   char       chrl_msg[ 512 ];              /* area for message        */
+
+#ifndef NEW_HOB_TUN_1103
+#define ADSL_INETA_RAWS_1_G ((struct dsd_ineta_raws_1 *) ((char *) adsp_tun_contr1 - offsetof( struct dsd_ineta_raws_1, dsc_tun_contr1 )))
+#ifdef B110314
+#define ADSL_AUXF_1_G ((struct dsd_auxf_1 *) ((char *) ADSL_INETA_RAWS_1_G - sizeof(struct dsd_auxf_1)))
+#endif
+   adsl_conn1 = (class clconn1 *) ADSL_INETA_RAWS_1_G->ac_conn1;
+#endif
+#ifdef NEW_HOB_TUN_1103
+   adsl_conn1 = ((class clconn1 *)
+                   ((char *) adsp_tun_contr1
+                      - offsetof( class clconn1, dsc_tun_contr1 )));
+#define ADSL_INETA_RAWS_1_G adsl_conn1->adsc_ineta_raws_1
+#endif
+   va_start( dsl_list, achp_format );       /* build dsl_list of variable arguments */
+   iml_len = m_hlvsnprintf( chrl_msg, sizeof(chrl_msg), ied_chs_utf_8,
+                            achp_format, dsl_list );
+   va_end( dsl_list );                      /* destroy list            */
+   if (adsl_conn1) {                        /* connection valid        */
+     m_hlnew_printf( HLOG_XYZ1, "HWSPS121W GATE=%(ux)s SNO=%08d INETA=%s HTUN %.*(u8)s",
+                     adsl_conn1->adsc_gate1 + 1,
+                     adsl_conn1->dsc_co_sort.imc_sno,
+                     adsl_conn1->chrc_ineta,
+                     iml_len, chrl_msg );
+     return;                                /* all done                */
+   }
+   memset( &dsl_soa, 0, sizeof(struct sockaddr_storage) );  /* filled with INETA */
+   iml_cpy_len = 0;                         /* clear length copy       */
+#ifdef B110314
+   switch (ADSL_AUXF_1_G->iec_auxf_def) {
+#ifdef FORKEDIT
+   }
+#endif
+#else
+   switch (ADSL_INETA_RAWS_1_G->iec_irs) {  /* type of INETA raw socket */
+#endif
+     case ied_ineta_raws_n_ipv4:            /* INETA IPV4              */
+     case ied_ineta_raws_user_ipv4:         /* INETA user IPV4         */
+     case ied_ineta_raws_l2tp_ipv4:         /* INETA L2TP IPV4         */
+       dsl_soa.ss_family = AF_INET;         /* IPV4                    */
+       iml_cpy_pos = offsetof( struct sockaddr_in, sin_addr );  /* position to copy */
+       iml_cpy_len = 4;                     /* length to copy          */
+       break;
+     case ied_ineta_raws_n_ipv6:            /* INETA IPV6              */
+     case ied_ineta_raws_user_ipv6:         /* INETA user IPV6         */
+     case ied_ineta_raws_l2tp_ipv6:         /* INETA L2TP IPV6         */
+       dsl_soa.ss_family = AF_INET6;        /* IPV6                    */
+       iml_cpy_pos = offsetof( struct sockaddr_in6, sin6_addr );  /* position to compare */
+       iml_cpy_len = 16;                    /* length to copy          */
+       break;
+   }
+   strcpy( chrl_ineta, "???" );
+   if (iml_cpy_len > 0) {                   /* length copy set         */
+     memcpy( (char *) &dsl_soa + iml_cpy_pos,
+             ADSL_INETA_RAWS_1_G + 1,
+             iml_cpy_len );
+     iml_rc = IP_getnameinfo( (struct sockaddr *) &dsl_soa, sizeof(struct sockaddr_storage),
+                              chrl_ineta, sizeof(chrl_ineta),
+                              0, 0, NI_NUMERICHOST );
+     if (iml_rc) {           /* error occured           */
+       m_hlnew_printf( HLOG_XYZ1, "HWSPnnnnW HTUN IBIPGW08 m_htun_warning() l%05d getnameinfo() returned %d %d.",
+                       __LINE__, iml_rc, D_TCP_ERROR );
+       strcpy( chrl_ineta, "???" );
+     }
+   }
+   chrl_port[0] = 0;                        /* for message port        */
+#ifdef B110314
+   if (   (ADSL_AUXF_1_G->iec_auxf_def == ied_ineta_raws_user_ipv4)  /* INETA user IPV4 */
+       || (ADSL_AUXF_1_G->iec_auxf_def == ied_ineta_raws_user_ipv6)) {  /* INETA user IPV6 */
+#ifdef FORKEDIT
+   }
+#endif
+#else
+   if (   (ADSL_INETA_RAWS_1_G->iec_irs == ied_ineta_raws_user_ipv4)  /* INETA user IPV4 */
+       || (ADSL_INETA_RAWS_1_G->iec_irs == ied_ineta_raws_user_ipv6)) {  /* INETA user IPV6 */
+#endif
+     sprintf( chrl_port, "TCP source port %d ", ADSL_INETA_RAWS_1_G->usc_appl_port );  /* port in use */
+   }
+   m_hlnew_printf( HLOG_WARN1, "HWSPTUN0%03d HOB-TUN message use ineta-appl %s %s%.*(u8)s",
+                   imp_error_number,
+                   chrl_ineta, chrl_port,
+                   iml_len, chrl_msg );
+#undef ADSL_INETA_RAWS_1_G
+#ifdef B110314
+#undef ADSL_AUXF_1_G
+#endif
+} /* end m_htun_warning()                                              */
+#endif
+#ifdef HL_UNIX
+extern "C" void m_htun_warning( struct dsd_tun_contr_conn *adsp_tun_contr_conn,
+                                struct dsd_tun_contr_ineta *adsp_tun_contr_ineta,
+                                int imp_error_number,
+                                const char *achp_format, ... ) {
+   int        iml_rc;                       /* return code             */
+   int        iml_len;                      /* length of message       */
+   int        iml_cpy_pos;                  /* position of copy        */
+   int        iml_cpy_len;                  /* length of copy          */
+   struct dsd_conn1 *adsl_conn1;            /* for this connection     */
+   va_list    dsl_list;                     /* list of arguments       */
+   struct sockaddr_storage dsl_soa;         /* filled with INETA       */
+   char       chrl_ineta[ LEN_DISP_INETA ];  /* internet-address char  */
+   char       chrl_port[ 32 ];              /* for message port        */
+   char       chrl_msg[ 512 ];              /* area for message        */
+
+   adsl_conn1 = NULL;                       /* for this connection     */
+   if (adsp_tun_contr_conn) {               /* connected to session    */
+     adsl_conn1 = ((struct dsd_conn1 *)
+                     ((char *) adsp_tun_contr_conn
+                        - offsetof( struct dsd_conn1, dsc_tun_contr_conn )));
+   }
+//#define ADSL_INETA_RAWS_1_G adsl_conn1->adsc_ineta_raws_1
+   va_start( dsl_list, achp_format );       /* build dsl_list of variable arguments */
+   iml_len = m_hlvsnprintf( chrl_msg, sizeof(chrl_msg), ied_chs_utf_8,
+                            achp_format, dsl_list );
+   va_end( dsl_list );                      /* destroy list            */
+   if (adsl_conn1) {                        /* connection valid        */
+     m_hlnew_printf( HLOG_XYZ1, "HWSPS121W GATE=%(ux)s SNO=%08d INETA=%s HTUN %.*(u8)s",
+                     adsl_conn1->adsc_gate1 + 1,
+                     adsl_conn1->dsc_co_sort.imc_sno,
+                     adsl_conn1->chrc_ineta,
+                     iml_len, chrl_msg );
+     return;                                /* all done                */
+   }
+#ifdef NOT_YET_120916
+   memset( &dsl_soa, 0, sizeof(struct sockaddr_storage) );  /* filled with INETA */
+   iml_cpy_len = 0;                         /* clear length copy       */
+#ifdef B110314
+   switch (ADSL_AUXF_1_G->iec_auxf_def) {
+#ifdef FORKEDIT
+   }
+#endif
+#else
+   switch (ADSL_INETA_RAWS_1_G->iec_irs) {  /* type of INETA raw socket */
+#endif
+     case ied_ineta_raws_n_ipv4:            /* INETA IPV4              */
+     case ied_ineta_raws_user_ipv4:         /* INETA user IPV4         */
+     case ied_ineta_raws_l2tp_ipv4:         /* INETA L2TP IPV4         */
+       dsl_soa.ss_family = AF_INET;         /* IPV4                    */
+       iml_cpy_pos = offsetof( struct sockaddr_in, sin_addr );  /* position to copy */
+       iml_cpy_len = 4;                     /* length to copy          */
+       break;
+     case ied_ineta_raws_n_ipv6:            /* INETA IPV6              */
+     case ied_ineta_raws_user_ipv6:         /* INETA user IPV6         */
+     case ied_ineta_raws_l2tp_ipv6:         /* INETA L2TP IPV6         */
+       dsl_soa.ss_family = AF_INET6;        /* IPV6                    */
+       iml_cpy_pos = offsetof( struct sockaddr_in6, sin6_addr );  /* position to compare */
+       iml_cpy_len = 16;                    /* length to copy          */
+       break;
+   }
+   strcpy( chrl_ineta, "???" );
+   if (iml_cpy_len > 0) {                   /* length copy set         */
+     memcpy( (char *) &dsl_soa + iml_cpy_pos,
+             ADSL_INETA_RAWS_1_G + 1,
+             iml_cpy_len );
+     iml_rc = IP_getnameinfo( (struct sockaddr *) &dsl_soa, sizeof(struct sockaddr_storage),
+                              chrl_ineta, sizeof(chrl_ineta),
+                              0, 0, NI_NUMERICHOST );
+     if (iml_rc) {           /* error occured           */
+       m_hlnew_printf( HLOG_XYZ1, "HWSPnnnnW HTUN IBIPGW08 m_htun_warning() l%05d getnameinfo() returned %d %d.",
+                       __LINE__, iml_rc, D_TCP_ERROR );
+       strcpy( chrl_ineta, "???" );
+     }
+   }
+   chrl_port[0] = 0;                        /* for message port        */
+#ifdef B110314
+   if (   (ADSL_AUXF_1_G->iec_auxf_def == ied_ineta_raws_user_ipv4)  /* INETA user IPV4 */
+       || (ADSL_AUXF_1_G->iec_auxf_def == ied_ineta_raws_user_ipv6)) {  /* INETA user IPV6 */
+#ifdef FORKEDIT
+   }
+#endif
+#else
+   if (   (ADSL_INETA_RAWS_1_G->iec_irs == ied_ineta_raws_user_ipv4)  /* INETA user IPV4 */
+       || (ADSL_INETA_RAWS_1_G->iec_irs == ied_ineta_raws_user_ipv6)) {  /* INETA user IPV6 */
+#endif
+     sprintf( chrl_port, "TCP source port %d ", ADSL_INETA_RAWS_1_G->usc_appl_port );  /* port in use */
+   }
+   m_hlnew_printf( HLOG_WARN1, "HWSPTUN0%03d HOB-TUN message use ineta-appl %s %s%.*(u8)s",
+                   imp_error_number,
+                   chrl_ineta, chrl_port,
+                   iml_len, chrl_msg );
+#endif
+//#undef ADSL_INETA_RAWS_1_G
+} /* end m_htun_warning()                                              */
+#endif
+
+#ifndef HL_UNIX
+/** enter critical section of WSP session from HOB-TUN                 */
+extern "C" void m_htun_critsect_enter( struct dsd_tun_contr1 *adsp_tun_contr1 ) {
+#ifdef B100702
+   EnterCriticalSection( &((class clconn1 *) ((char *) adsp_tun_contr1
+                           - offsetof( class clconn1, dsc_tun_contr1 )))
+                               ->d_act_critsect );  /* critical section act */
+#endif
+#ifndef NEW_HOB_TUN_1103
+#define ADSL_INETA_RAWS_1_G ((struct dsd_ineta_raws_1 *) ((char *) adsp_tun_contr1 - offsetof( struct dsd_ineta_raws_1, dsc_tun_contr1 )))
+#define ADSL_CONN1_G ((class clconn1 *) ADSL_INETA_RAWS_1_G->ac_conn1)
+   EnterCriticalSection( &ADSL_CONN1_G->d_act_critsect );  /* critical section act */
+#undef ADSL_CONN1_G
+#undef ADSL_INETA_RAWS_1_G
+#endif
+#ifdef NEW_HOB_TUN_1103
+   EnterCriticalSection( &((class clconn1 *) ((char *) adsp_tun_contr1
+                           - offsetof( class clconn1, dsc_tun_contr1 )))
+                               ->d_act_critsect );  /* critical section act */
+#endif
+} /* end m_htun_critsect_enter()                                       */
+
+/** leave critical section of WSP session from HOB-TUN                 */
+extern "C" void m_htun_critsect_leave( struct dsd_tun_contr1 *adsp_tun_contr1 ) {
+#ifdef B100702
+   LeaveCriticalSection( &((class clconn1 *) ((char *) adsp_tun_contr1
+                           - offsetof( class clconn1, dsc_tun_contr1 )))
+                               ->d_act_critsect );  /* critical section act */
+#endif
+#ifndef NEW_HOB_TUN_1103
+#define ADSL_INETA_RAWS_1_G ((struct dsd_ineta_raws_1 *) ((char *) adsp_tun_contr1 - offsetof( struct dsd_ineta_raws_1, dsc_tun_contr1 )))
+#define ADSL_CONN1_G ((class clconn1 *) ADSL_INETA_RAWS_1_G->ac_conn1)
+   LeaveCriticalSection( &ADSL_CONN1_G->d_act_critsect );  /* critical section act */
+#undef ADSL_CONN1_G
+#undef ADSL_INETA_RAWS_1_G
+#endif
+#ifdef NEW_HOB_TUN_1103
+   LeaveCriticalSection( &((class clconn1 *) ((char *) adsp_tun_contr1
+                           - offsetof( class clconn1, dsc_tun_contr1 )))
+                               ->d_act_critsect );  /* critical section act */
+#endif
+} /* end m_htun_critsect_leave()                                       */
+#endif
+#ifdef HL_UNIX
+/** enter critical section of WSP session from HOB-TUN                 */
+extern "C" void m_htun_critsect_enter( struct dsd_tun_contr_conn *adsp_tun_contr_conn ) {
+   int        iml_rc;                       /* return code             */
+   struct dsd_conn1 *adsl_conn1;            /* for this connection     */
+
+   adsl_conn1 = ((struct dsd_conn1 *)
+                   ((char *) adsp_tun_contr_conn
+                      - offsetof( struct dsd_conn1, dsc_tun_contr_conn )));
+   iml_rc = adsl_conn1->dsc_critsect.m_enter();  /* enter CriticalSection */
+} /* end m_htun_critsect_enter()                                       */
+
+/** leave critical section of WSP session from HOB-TUN                 */
+extern "C" void m_htun_critsect_leave( struct dsd_tun_contr_conn *adsp_tun_contr_conn ) {
+   int        iml_rc;                       /* return code             */
+   struct dsd_conn1 *adsl_conn1;            /* for this connection     */
+
+   adsl_conn1 = ((struct dsd_conn1 *)
+                   ((char *) adsp_tun_contr_conn
+                      - offsetof( struct dsd_conn1, dsc_tun_contr_conn )));
+   iml_rc = adsl_conn1->dsc_critsect.m_leave();  /* leave CriticalSection */
+} /* end m_htun_critsect_leave()                                       */
+#endif
+#ifdef FOR_ALAN_DUCA
+/* enter critical section of WSP session from HTCP                     */
+extern "C" void m_htun_htcp_critsect_enter( class dsc_htcp_session *adsp_htcp_session ) {
+   m_htun_critsect_enter( &((struct dsd_tun_contr1 *) ((char *) adsp_htcp_session
+                              - offsetof( struct dsd_tun_contr1, chrc_htcp_session ))) );
+} /* end m_htun_htcp_critsect_enter()                                  */
+
+/* leave critical section of WSP session from HTCP                     */
+extern "C" void m_htun_htcp_critsect_leave( class dsc_htcp_session *adsp_htcp_session ) {
+   m_htun_critsect_leave( &((struct dsd_tun_contr1 *) ((char *) adsp_htcp_session
+                              - offsetof( struct dsd_tun_contr1, chrc_htcp_session ))) );
+} /* end m_htun_htcp_critsect_leave()                                  */
+#endif
+
+/** callback routine for HOB-TUN, get target-filter assoziated with the session, for PPP */
+#ifndef HL_UNIX
+extern "C" struct dsd_targfi_1 * m_htun_ppp_get_targfi( struct dsd_tun_contr1 *adsp_tun_contr1 ) {
+#ifdef FORKEDIT
+}
+#endif
+#else
+extern "C" struct dsd_targfi_1 * m_htun_ppp_get_targfi( struct dsd_tun_contr_conn *adsp_tun_contr_conn ) {
+#endif
+#ifndef HL_UNIX
+   class clconn1 *adsl_conn1;               /* class connection        */
+#else
+   struct dsd_conn1 *adsl_conn1;            /* for this connection     */
+#endif
+   char       *achl_stf;                    /* source target-filter    */
+   struct dsd_targfi_1 *adsl_targfi_w1;     /* working variable        */
+
+#ifndef HL_UNIX
+#ifndef NEW_HOB_TUN_1103
+#define ADSL_INETA_RAWS_1_G ((struct dsd_ineta_raws_1 *) ((char *) adsp_tun_contr1 - offsetof( struct dsd_ineta_raws_1, dsc_tun_contr1 )))
+   adsl_conn1 = (class clconn1 *) ADSL_INETA_RAWS_1_G->ac_conn1;
+#undef ADSL_INETA_RAWS_1_G
+#endif
+#ifdef NEW_HOB_TUN_1103
+   adsl_conn1 = ((class clconn1 *)
+                   ((char *) adsp_tun_contr1
+                      - offsetof( class clconn1, dsc_tun_contr1 )));
+#endif
+#endif
+#ifdef HL_UNIX
+   adsl_conn1 = ((struct dsd_conn1 *)
+                   ((char *) adsp_tun_contr_conn
+                      - offsetof( struct dsd_conn1, dsc_tun_contr_conn )));
+#endif
+   adsl_targfi_w1 = m_get_session_targfi( &achl_stf, adsl_conn1 );
+   if (adsl_targfi_w1 == NULL) return NULL;
+   if (adsg_loconf_1_inuse->inc_network_stat >= 4) {
+     m_hlnew_printf( HLOG_INFO1, "HWSPS083I GATE=%(ux)s SNO=%08d INETA=%s HOB-TUN apply target-filter %(u8)s from %s.",
+                     adsl_conn1->adsc_gate1 + 1, adsl_conn1->dsc_co_sort.imc_sno,
+                     adsl_conn1->chrc_ineta, (char *) adsl_targfi_w1 + adsl_targfi_w1->imc_off_name, achl_stf );
+   }
+   return adsl_targfi_w1;
+} /* end m_htun_ppp_get_targfi()                                       */
+
+#ifdef HL_UNIX
+void m_reconnect_workaround(struct dsd_tun_contr_ineta* adsp_tun_contr_ineta, struct dsd_tun_contr_conn* adsp_tun_contr_conn) {
+   m_hlnew_printf( HLOG_INFO1, "HWSPSnnnI m_reconnect_workaround() called" );
+   /* 05.01.13 KB - from HSM                                           */
+    struct dsd_ineta_raws_1 * adsl_ir1 = (struct dsd_ineta_raws_1*)
+       ((char*)adsp_tun_contr_ineta - offsetof(struct dsd_ineta_raws_1, dsc_tun_contr_ineta));
+    struct dsd_conn1* adsl_c1 = (struct dsd_conn1*)
+       ((char*)adsp_tun_contr_conn - offsetof(struct dsd_conn1, dsc_tun_contr_conn));
+    // adsl_ir1->ac_conn1 = adsl_c1;
+    adsl_ir1->dsc_htun_h = adsl_c1->dsc_htun_h;
+    // adsl_c1->adsc_ineta_raws_1 = adsl_ir1;
+
+}
+#endif
+#endif
+#ifndef HL_UNIX
+/** callback routine for HOB-TUN PPP, get INETA IPV4 to be used for VPN tunnel */
+extern "C" char * m_htun_ppp_acquire_local_ineta_ipv4( struct dsd_hco_wothr *adsp_hco_wothr,
+                                                       struct dsd_tun_contr1 *adsp_tun_contr1 ) {
+   BOOL       bol1;                         /* working variable        */
+   int        iml_rc;                       /* return code             */
+   socklen_t  iml_local_namelen;            /* length of name local    */
+   class clconn1 *adsl_conn1;               /* class connection        */
+   struct sockaddr_storage dsl_soa_local;   /* address information INETA to be used locally */
+   char       chrl_ineta_local[ LEN_DISP_INETA ];  /* for INETA local  */
+
+   adsl_conn1 = ((class clconn1 *)
+                   ((char *) adsp_tun_contr1
+                      - offsetof( class clconn1, dsc_tun_contr1 )));
+   adsl_conn1->adsc_ineta_raws_1            /* auxiliary field for HOB-TUN */
+     = m_prepare_htun_ineta( &dsl_soa_local,
+                             &iml_local_namelen,
+                             adsl_conn1,
+                             adsp_hco_wothr,
+                             ied_ineta_raws_n_ipv4 );  /* INETA IPV4   */
+   if (adsl_conn1->adsc_ineta_raws_1 == NULL) {  /* no INETA found     */
+     m_hlnew_printf( HLOG_WARN1, "HWSPS190W GATE=%(ux)s SNO=%08d INETA=%s tries to start raw-interface PPP but no ineta-ppp available",
+                     adsl_conn1->adsc_gate1 + 1, adsl_conn1->dsc_co_sort.imc_sno, adsl_conn1->chrc_ineta );
+     return NULL;
+   }
+   iml_rc = IP_getnameinfo( (struct sockaddr *) &dsl_soa_local, iml_local_namelen,
+                            chrl_ineta_local, sizeof(chrl_ineta_local),
+                            0, 0, NI_NUMERICHOST );
+   if (iml_rc < 0) {                  /* error occured           */
+     if (cl_tcp_r::hws2mod != NULL) {  /* functions loaded       */
+       iml_rc = cl_tcp_r::afunc_wsaglerr();  /* get error code   */
+     }
+     m_hlnew_printf( HLOG_WARN1, "HWSPS191W GATE=%(ux)s SNO=%08d INETA=%s getnameinfo local failed with code %d.",
+                     adsl_conn1->adsc_gate1 + 1, adsl_conn1->dsc_co_sort.imc_sno, adsl_conn1->chrc_ineta, iml_rc );
+     strcpy( chrl_ineta_local, "???" );
+   }
+   m_hlnew_printf( HLOG_INFO1, "HWSPS192I GATE=%(ux)s SNO=%08d INETA=%s use ineta-ppp %s.",
+                   adsl_conn1->adsc_gate1 + 1, adsl_conn1->dsc_co_sort.imc_sno, adsl_conn1->chrc_ineta, chrl_ineta_local );
+   adsl_conn1->adsc_ineta_raws_1->ac_conn1 = adsl_conn1;  /* set connection  */
+   return (char *) (adsl_conn1->adsc_ineta_raws_1 + 1);  /* return address of field with INETA */
+} /* end m_htun_ppp_acquire_local_ineta_ipv4()                         */
+#endif
+#ifdef XYZ1
+#ifdef HL_UNIX
+extern "C" struct dsd_tun_contr_ineta *
+     m_htun_ppp_acquire_local_ineta_ipv4( struct dsd_hco_wothr *adsp_hco_wothr,
+                                          struct dsd_tun_contr_conn *adsp_tun_contr_conn,
+                                          struct dsd_tun_contr_ineta *adsp_tun_contr_ineta ) {
+   return NULL;
+} /* end m_htun_ppp_acquire_local_ineta_ipv4()                         */
+#endif
+#endif
+
+/** callback routine for HOB-TUN PPP, notify session that IPV4 INETA is used for VPN tunnel */
+#ifndef HL_UNIX
+extern "C" void m_htun_ppp_use_local_ineta( struct dsd_tun_contr1 *adsp_tun_contr1,
+                                            char *achrp_local_ineta ) {
+#define ADSL_INETA_RAWS_1_G ((struct dsd_ineta_raws_1 *) (achrp_local_ineta - sizeof(struct dsd_ineta_raws_1)))
+   if (ADSL_INETA_RAWS_1_G->ac_conn1) {     /* set in old connection   */
+     ((class clconn1 *) ADSL_INETA_RAWS_1_G->ac_conn1)->adsc_ineta_raws_1 = NULL;
+   }
+   ADSL_INETA_RAWS_1_G->ac_conn1
+     = ((class clconn1 *)
+          ((char *) adsp_tun_contr1
+             - offsetof( class clconn1, dsc_tun_contr1 )));
+#undef ADSL_INETA_RAWS_1_G
+} /* end m_htun_ppp_use_local_ineta()                                  */
+
+/** callback routine for HOB-TUN PPP, notify session that IPV4 INETA is no more assoziated with the session */
+extern "C" void m_htun_ppp_release_local_ineta( struct dsd_tun_contr1 *adsp_tun_contr1,
+                                                char *achrp_local_ineta ) {
+#ifndef HL_UNIX
+   class clconn1 *adsl_conn1;               /* class connection        */
+#else
+   struct dsd_conn1 *adsl_conn1;            /* for this connection     */
+#endif
+
+#define ADSL_INETA_RAWS_1_G ((struct dsd_ineta_raws_1 *) (achrp_local_ineta - sizeof(struct dsd_ineta_raws_1)))
+   adsl_conn1 = (class clconn1 *) ADSL_INETA_RAWS_1_G->ac_conn1;
+   m_cleanup_htun_ineta( ADSL_INETA_RAWS_1_G );  /* cleanup INETA      */
+   free( ADSL_INETA_RAWS_1_G );             /* free memory area with INETA */
+#undef ADSL_INETA_RAWS_1_G
+   if (adsl_conn1 == NULL) return;          /* not used with connection */
+   adsl_conn1->adsc_ineta_raws_1 = NULL;    /* no more auxiliary field for HOB-TUN */
+} /* end m_htun_ppp_release_local_ineta()                              */
+#endif
+
+#ifndef HL_UNIX
+/** HOB-TUN has new parameters for the session                         */
+static void m_session_new_params( class clconn1 *adsp_conn1 ) {
+#ifdef B100702
+#ifdef D_HPPPT1_1
+   if (adsp_conn1->iec_servcotype == ied_servcotype_htun) {  /* HTUN   */
+     *((UNSIG_MED *) &((struct sockaddr_in *) &adsp_conn1->dsc_tun_contr1.dsc_soa_local)->sin_addr)
+       = adsp_conn1->umc_ineta_ppp_ipv4;                  /* INETA PPP IPV4          */
+   }
+#endif
+#endif
+// to-do 03.07.10 KB - remove this subroutine
+} /* end m_session_new_params()                                        */
+#endif
+#ifdef B100702
+/**
+  this routine will be called from HTUN when the given INETA is already
+  in use.
+*/
+extern "C" BOOL m_htun_sess_ineta_double( struct dsd_tun_contr1 * adsp_tctl ) {
+   class clconn1 *adsl_conn1;               /* class connection        */
+
+   adsl_conn1 = ((class clconn1 *)
+                   ((char *) adsp_tctl
+                      - offsetof( class clconn1, dsc_tun_contr1 )));
+   m_hlnew_printf( HLOG_XYZ1, "IBIPGW08-l%05d-T m_htun_sess_ineta_double() adsp_tctl=%p adsl_conn1=%p.",
+                   __LINE__, adsp_tctl, adsl_conn1 );
+   /* no INETA available, cancel the session                           */
+   if (adsl_conn1->achc_reason_end == NULL) {  /* reason end session */
+     adsl_conn1->achc_reason_end = "session canceled because no INETA for HOB-TUN";  /* set text */
+   }
+   m_hlnew_printf( HLOG_XYZ1, "HWSPS120W GATE=%(ux)s SNO=%08d INETA=%s no INETA for HOB-TUN available",
+                   adsl_conn1->adsc_gate1 + 1, adsl_conn1->dsc_co_sort.imc_sno, adsl_conn1->chrc_ineta );
+   adsl_conn1->dcl_tcp_r_c.close1();
+   return FALSE;                            /* could not give INETA    */
+} /* end m_htun_sess_ineta_double()                                    */
+#endif
+
+#ifndef HL_UNIX
+/** get configuration for HOB-TUN                                      */
+extern "C" struct dsd_wsptun_conf_1 * m_get_wsptun_conf_1() {
+   struct dsd_raw_packet_if_conf *adsl_raw_packet_if_conf;  /* configuration raw-packet-interface */
+
+#ifdef B100702
+   return &dss_wsptun_conf_1;
+#endif
+   adsl_raw_packet_if_conf = adsg_loconf_1_inuse->adsc_raw_packet_if_conf;  /* get configuration raw-packet-interface */
+   if (adsl_raw_packet_if_conf == NULL) return NULL;  /* did not find the configuration */
+   return &adsl_raw_packet_if_conf->dsc_wsptun_conf_1;  /* TUN PPP INETAs */
+} /* end m_get_wsptun_conf_1()                                         */
+
+/** retrieve TUN adapter for HOB-TUN                                   */
+extern "C" char * m_get_wsptun_ineta_ipv4_adapter() {
+   struct dsd_raw_packet_if_conf *adsl_raw_packet_if_conf;  /* configuration raw-packet-interface */
+
+   adsl_raw_packet_if_conf = adsg_loconf_1_inuse->adsc_raw_packet_if_conf;  /* get configuration raw-packet-interface */
+   if (adsl_raw_packet_if_conf == NULL) return NULL;  /* did not find the configuration */
+   return (char *) &adsl_raw_packet_if_conf->umc_ta_ineta_local;  /* <TUN-adapter-ineta> */
+} /* end m_get_wsptun_ineta_ipv4_adapter()                             */
+#endif
Index: xslnetw1.cpp
===================================================================
--- xslnetw1.cpp	(revision 2)
+++ xslnetw1.cpp	(revision 6)
@@ -578,7 +578,10 @@
        || (imp_len_ineta >= 0)) {
      iml_rc = m_cpy_vx_vx( chrl_work_ineta, sizeof(chrl_work_ineta), ied_chs_idna_1,
                            ap_ineta, imp_len_ineta, iep_cs_ineta );
-     if (iml_rc <= 0) return -1;            /* string not valid        */
+     if (iml_rc <= 0) {                     /* string not valid        */
+       if (aimp_error) *aimp_error = -2;
+       return FALSE;
+     }
      achl_ineta = chrl_work_ineta;
    }
    if (*achl_ineta == 0) {                  /* string is empty         */
Index: hob-htcp-01.h
===================================================================
--- hob-htcp-01.h	(revision 0)
+++ hob-htcp-01.h	(revision 6)
@@ -0,0 +1,315 @@
+/******************************************************************************
+ * File name: hob-htcp-01.h
+ *
+ * Interface for HTCP.
+ *
+ * Author: Kevin Spiteri
+ * Copyright: Copyright (c) HOB Software 2011
+ ******************************************************************************/
+
+#ifndef HOB_HTCP_01_H
+#define HOB_HTCP_01_H
+
+#ifdef DEF_INCLUDE_HEADERS
+#include "hob-htcp-int-01.h"
+#include "hob-htcp-hdr-01.h"
+#endif /* DEF_INCLUDE_HEADERS */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+#if 0
+} /* so as not to confuse auto-indentation */
+#endif
+
+/*
+ * output: direction from application to network
+ * input: direction from network to application
+ */
+
+enum ied_htcp_close {
+    ied_htcpc_open,
+    ied_htcpc_normal,
+    ied_htcpc_conn_refused,
+    ied_htcpc_conn_timeout,
+    ied_htcpc_conn_error,
+    ied_htcpc_remote_reset,
+    ied_htcpc_local_reset,
+    ied_htcpc_error,
+    ied_htcpc_interface_error,
+    ied_htcpc_application_error
+};
+
+struct dsd_htcp_in_info {
+    uint32_t umc_seq;
+    uint32_t umc_len;
+    uint32_t umc_offset;
+    bool boc_push;
+    struct dsd_htcp_in_info* adsc_next;
+};
+
+enum ied_htcp_cc_algorithm {
+    ied_htcp_cca_newreno,
+    ied_htcp_cca_cubic,
+    ied_htcp_cca_compound,
+    ied_htcp_cca_illinois
+};
+
+enum ied_htcp_cc_event {
+    ied_htcp_cce_init,
+    ied_htcp_cce_newack,
+    ied_htcp_cce_timeout,
+    ied_htcp_cce_three_dup,
+    ied_htcp_cce_three_dup_sack,
+    ied_htcp_cce_more_dup,
+    ied_htcp_cce_recover_ack
+};
+
+struct dsd_htcp_cc_newreno {
+    uint32_t umc_ssthresh;
+};
+
+struct dsd_htcp_cc_cubic {
+    uint32_t umc_ssthresh;
+    uint32_t umc_w_lastmax;
+    int64_t ilc_epoch_start;
+    uint32_t umc_origin_point;
+    uint32_t umc_dmin;
+    uint32_t umc_wtcp;
+    uint32_t umc_k;
+    uint32_t umc_ack_cnt;
+};
+
+union dsd_htcp_ucc {
+    struct dsd_htcp_cc_newreno dsc_cc_newreno;
+    struct dsd_htcp_cc_cubic dsc_cc_cubic;
+};
+
+struct dsd_htcp_cc {
+    uint32_t umc_cwnd;
+    uint32_t umc_bytes_acked;
+    union dsd_htcp_ucc dsc_ucc;
+};
+
+typedef void (*amd_cc_func)(enum ied_htcp_cc_event iep_cce_e,
+                            int64_t ilp_time, uint32_t ump_rtt_ms,
+                            uint32_t ump_snd_smss, uint32_t ump_flight,
+                            struct dsd_htcp_cc* adsp_cc);
+
+struct dsd_htcp_config {
+    uint32_t umc_in_bufsize; /* initial receive window */
+    uint32_t umc_in_mss; /* incoming maximum segment size */
+    uint32_t umc_out_mss_cap; /* outgoing maximum segment size cap */
+    uint32_t umc_msl_s; /* MSL used in calculation of timeouts */
+    uint32_t umc_delay_ack_ms; /* delayed ACK timeout */
+    bool boc_sack; /* use selective acknowledgement option */
+    bool boc_window_scaling; /* use window scaling option */
+    bool boc_timestamp; /* use timestamp option */
+    enum ied_htcp_cc_algorithm iec_cc_algorithm; /* congestion control */
+};
+
+struct dsd_htcp_status {
+    /* TODO: add more fields */
+    uint32_t umc_out_queue_len;
+    uint32_t umc_out_in_flight;
+};
+
+void m_htcp_init(struct dsd_htcp_conn* adsp_hc,
+                 const struct dsd_htcp_config* adsp_hconf,
+                 const struct dsd_htcp_callbacks* adsp_hcb,
+                 uint16_t usp_pseudo_header_chksum,
+                 uint16_t usp_local_port, uint16_t usp_remote_port);
+
+void m_htcp_out_send(struct dsd_htcp_conn* adsp_hc,
+                     uint32_t ump_len, bool bop_push, bool bop_eof);
+
+void m_htcp_out_get_packet(struct dsd_htcp_conn* adsp_hc,
+                           char* achp_header, uint32_t* aump_hlen,
+                           uint32_t* aump_offset, uint32_t* aump_dlen,
+                           bool* abop_more);
+
+void m_htcp_in_packet(struct dsd_htcp_conn* adsp_hc,
+                      struct dsd_htcp_in_info* adsp_hii,
+                      uint32_t ump_tcp_len);
+
+void m_htcp_in_get_data(struct dsd_htcp_conn* adsp_hc,
+                        struct dsd_htcp_in_info** aadsp_hii,
+                        uint32_t* aump_offset, uint32_t* aump_len,
+                        bool* abop_push,
+                        bool* abop_eof, bool* abop_more,
+                        bool bop_throttle);
+
+void m_htcp_timeout(struct dsd_htcp_conn* adsp_hc);
+
+void m_htcp_abort(struct dsd_htcp_conn* adsp_hc, bool bop_reset);
+
+void m_htcp_status(struct dsd_htcp_conn* adsp_hc,
+                   struct dsd_htcp_status* adsp_hs);
+
+void m_htcp_describe_close(struct dsd_htcp_conn* adsp_hc,
+                           char* achp_description, uint32_t* aump_dlen,
+                           char* achp_debug_info, uint32_t* aump_dilen);
+
+struct dsd_htcp_callbacks {
+
+    bool (*amc_out_get)(struct dsd_htcp_conn* adsp_hc,
+                        uint32_t ump_offset,
+                        const char** aachp_buf, uint32_t* aump_len);
+    bool (*amc_out_packets)(struct dsd_htcp_conn* adsp_hc);
+    bool (*amc_out_ack)(struct dsd_htcp_conn* adsp_hc, uint32_t ump_len);
+
+    bool (*amc_in_get)(struct dsd_htcp_conn* adsp_hc,
+                       struct dsd_htcp_in_info* adsp_hii,
+                       uint32_t ump_offset,
+                       const char** aachp_buf, uint32_t* aump_len);
+    bool (*amc_in_more_data)(struct dsd_htcp_conn* adsp_hc);
+    bool (*amc_in_rel)(struct dsd_htcp_conn* adsp_hc,
+                       struct dsd_htcp_in_info* adsp_hii);
+
+    bool (*amc_get_time)(struct dsd_htcp_conn* adsp_hc, int64_t* ailp_time);
+    bool (*amc_set_timer)(struct dsd_htcp_conn* adsp_hc,
+                          uint32_t ump_delay_ms);
+    bool (*amc_rel_timer)(struct dsd_htcp_conn* adsp_hc);
+
+    bool (*amc_lock)(struct dsd_htcp_conn* adsp_hc);
+    bool (*amc_unlock)(struct dsd_htcp_conn* adsp_hc);
+
+    bool (*amc_established)(struct dsd_htcp_conn* adsp_hc);
+    void (*amc_closed)(struct dsd_htcp_conn* adsp_hc,
+                       enum ied_htcp_close iep_htcpc);
+};
+
+
+
+extern const struct dsd_htcp_config dsg_htcp_default_config;
+
+
+enum ied_tcp_state_t {
+    ied_htcp_closed,
+    ied_htcp_listen,
+    ied_htcp_syn_sent,
+    ied_htcp_syn_rcvd,
+    ied_htcp_syn_sent_eof,
+    ied_htcp_syn_rcvd_eof,
+    ied_htcp_established,
+    ied_htcp_fin_wait_1,
+    ied_htcp_fin_wait_2,
+    ied_htcp_closing,
+    ied_htcp_time_wait,
+    ied_htcp_close_wait,
+    ied_htcp_last_ack
+};
+
+static const int ins_htcp_out_sack_count = 6;
+static const int ins_dup_thresh = 3;
+
+struct dsd_htcp_conn {
+
+    enum ied_tcp_state_t iec_state;
+
+    struct dsd_htcp_in_info* adsc_in_list;
+    struct dsd_htcp_in_info* adsc_oo_list;
+    struct dsd_htcp_in_info* adsc_sack_first;
+
+    bool boc_oo_fin_received;
+    uint32_t umc_oo_fin_seq;
+
+    /* umc_snd_nxt:     highest octet sent
+     * umc_snd_nxt_cur: after timeout, assume in flight octets are lost,
+     *                  and sending is done here
+     */
+    uint32_t umc_snd_una;
+    uint32_t umc_snd_nxt;
+    uint32_t umc_snd_nxt_cur;
+    uint32_t umc_snd_wnd;
+    uint32_t umc_snd_iss;
+    uint32_t umc_snd_smss;
+
+    uint32_t umc_send_pending;
+    uint32_t umc_out_send_recover_seq;
+    bool boc_out_send_recover;
+
+    uint32_t umc_rcv_nxt;
+    uint32_t umc_rcv_wnd;
+    uint32_t umc_rcv_irs;
+    uint32_t umc_rcv_rmss;
+    uint32_t umc_last_ack_sent;
+    uint32_t umc_rcv_wnd_throttled;
+
+    uint32_t umc_msl_s;
+    uint32_t umc_delay_ack_ms;
+
+    bool boc_use_sack;
+    bool boc_use_winscale;
+    bool boc_use_timestamp;
+    uint32_t umc_snd_winscale;
+    uint32_t umc_rcv_winscale;
+
+    uint32_t umc_srtt_ms;
+    uint32_t umc_rttvar_ms;
+    uint32_t umc_rto_ms;
+    uint32_t umc_ts_recent;
+    int32_t imc_recent_age_s;
+    uint32_t umc_last_update_ts;
+    uint32_t umc_last_tsecr;
+
+    int64_t ilc_rtt_calc_time_sent_ms;
+    uint32_t umc_rtt_calc_seq_sent;
+    bool boc_rtt_calc_valid;
+
+    uint64_t ulc_syn_time_ms;
+
+    amd_cc_func amc_cc_func;
+    struct dsd_htcp_cc dsc_cc;
+    bool boc_recovering;
+    bool boc_pack_time;
+    uint32_t umc_recover;
+    uint32_t umc_dack;
+    uint32_t umc_exp_backoff;
+
+    uint32_t umrc_out_sack_left[ins_htcp_out_sack_count];
+    uint32_t umrc_out_sack_right[ins_htcp_out_sack_count];
+    uint32_t umc_out_sack_count;
+
+    uint32_t umc_sack_data_size;
+    uint32_t umc_recovery_point;
+    uint32_t umc_sack_pipe;
+    uint32_t umc_high_rxt; /* beyond last highest retransmitted */
+
+    int64_t ilc_timer;
+    int64_t ilc_da_timer;
+
+    enum ied_htcp_close iec_htcpc;
+    const char* achc_close_reason;
+    int inc_close_line;
+
+    uint16_t usc_local_port;
+    uint16_t usc_remote_port;
+    uint16_t usc_pseudo_header_chksum;
+    const struct dsd_htcp_callbacks* adsc_cb;
+
+    /*
+     * umc_packet_seq used for SYN/RST/recover packets:
+     * during syn or after rst, recover should not be invoked
+     *
+     * umc_packet_ack used only for RST
+     */
+    bool boc_out_packet_promised;
+    bool boc_zwnd_probe;
+    bool boc_recover_packet;
+    uint8_t utc_packet_flags;
+    uint32_t umc_packet_seq;
+    uint32_t umc_packet_ack;
+    uint32_t umc_limited_transmit;
+    uint32_t umc_tosend_dack;
+    uint32_t umc_pending_dacks;
+};
+
+#if 0
+{ /* so as not to confuse auto-indentation */
+#endif
+#ifdef __cplusplus
+} /* extern "C" */
+#endif
+
+#endif /* !HOB_HTCP_01_H */
Index: xshpppi01.cpp
===================================================================
--- xshpppi01.cpp	(revision 2)
+++ xshpppi01.cpp	(revision 6)
@@ -1,3 +1,5 @@
+// #define TRY_HPPPT1_130116
+
 //+-------------------------------------------------------------------+
 //|                                                                   |
 //| PROGRAM NAME: HPPP.cpp                                            |
@@ -13,16 +15,20 @@
 //|                                                                   |
 //+-------------------------------------------------------------------+

+#ifndef D_INCL_TUN_CTRL
+#define D_INCL_TUN_CTRL
+#endif
+
 #ifdef B090317
 #ifndef HL_UNIX
 #include <hob-avl03.h>
 #else
 #include "hob-avl03.h"
 #endif
-#if defined WIN32 || WIN64
+#if defined WIN32 || defined WIN64
 #include <winsock2.h>
 #include <windows.h>
-#elif defined HL_LINUX
+#elif defined HL_UNIX
 #include <netinet/in.h>
 #endif
 #ifndef HL_UNIX
@@ -39,6 +45,8 @@
 #include <winsock2.h>
 #include <ws2tcpip.h>
 #include <windows.h>
+#else
+#include "hob-unix01.h"
 #endif
 #ifndef HL_UNIX
 #include <hob-avl03.h>
@@ -49,12 +57,20 @@
 typedef int socklen_t;
 #endif
 #ifdef HL_UNIX
+#ifndef HOB_CONTR_TIMER
 #define HOB_CONTR_TIMER
+#endif
 #include <netinet/in.h>
+#include <net/if.h>
 #include <time.h>
 #include <string.h>
-#include "types_defines.h"
+
+//#include "types_defines.h"
+#ifndef byte
+#define byte unsigned char
 #endif
+
+#endif
 #include <hob-xslhcla1.hpp>
 #include <hob-netw-01.h>
 #include <string>
@@ -66,18 +82,18 @@
 #include <queue>
 #include "hob-xslcontr.h"
 #include "hob-tun01.h"
-#include "hob-htcp-int-types.h"
-#include "hob-htcp.h"
-#include "hob-htcp-bit-reference.h"
-#include "hob-htcp-tcpip-hdr.h"
-#include "hob-htcp-misc.h"
-#include "hob-htcp-connection.h"
+#include "hob-htcp-int-01.h"
+//#include "hob-htcp-int-types.h"
+//#include "hob-htcp.h"
+//#include "hob-htcp-bit-reference.h"
+//#include "hob-htcp-tcpip-hdr.h"
+//#include "hob-htcp-misc.h"
+//#include "hob-htcp-connection.h"
 #include "hob-session01.h"
-#include "hob-htcp-session.h"
+//#include "hob-htcp-session.h"
 #include "hob-gw-ppp-1.h"
 #include "hob-hppp01.h"
 #include "hob-hsstp01.h"
-#include "hob-tun02.h"
 #include "hob-tuntapif01.h"
 #include <stdio.h>
 #include <vector>
@@ -94,23 +110,15 @@

 struct dsd_ppp_targfi_act_1 *adsc_ptfa1;

-// Map of "old INETAS".
-static std::map<uint32, uint32*> dss_old_ineta_map;
-
 // Callback for new PPP implementation to do authentication.
 extern PTYPE void m_ppp_auth_1(struct dsd_ppp_server_1*);

 // New function implemented to get address of INETA configured for htun.
 static char* m_ppp_se_get_ineta_client(struct dsd_ppp_server_1 *adsp_ppp_se_1);

-// Required to get address of INETA configured for HTUN sessions. Implemented in
-// ibipgw08.cpp.
-extern PTYPE byte* m_htun_get_client_ineta( struct dsd_tun_contr1 * );
-
-extern "C" void m_htun_free_resources( struct dsd_tun_contr1 *adsp_tun_contr1 );
-
 // Called to inform WPS that a session has terminated.
-extern "C" void m_htun_session_end( struct dsd_tun_contr1 *adsp_tun_contr1, int imp_reason );
+extern PTYPE void m_htun_session_end( struct dsd_tun_contr_conn *adsp_tun_contr_conn,
+                                      int imp_reason );

 extern PTYPE struct dsd_ppp_targfi_act_1 * m_create_ppp_targfi( struct dsd_targfi_1 * );

@@ -129,28 +137,64 @@
 // Prints a PPP server related message.
 static void m_log_ppp_warning(dsd_ppp_server_1* adsp_ppp_svr, char* achp_message);

-dsd_ppp_session::dsd_ppp_session(dsd_tun_start1* adsp_tun_start1,
-                                 dsd_tun_contr1* adsp_sess_info)
-   : dsd_session(adsp_sess_info),
+bool bo_pppsess_avl_initd = false;
+dsd_htree1_avl_cntl ds_pppsess_avl_cntl;
+dsd_htree1_avl_work ds_pppsess_avl_wrk;
+dsd_hcla_critsect_1 ds_pppsess_avl_cs;
+
+// AVL tree node comparison function.
+int m_cmp_pppsess_nodes(void*, dsd_htree1_avl_entry* adsp_a, dsd_htree1_avl_entry* adsp_b)
+{
+    // Get tunnel IDs
+    uint32_t uml_a = *(uint32_t*)(adsp_a + 1);
+    uint32_t uml_b = *(uint32_t*)(adsp_b + 1);
+    // Compare.
+    return uml_a - uml_b;
+}
+
+dsd_ppp_session::dsd_ppp_session(dsd_tun_start_ppp* adsp_tun_start_ppp,
+                                 dsd_tun_contr_conn* adsp_tun_contr_conn,
+                                 dsd_tun_contr_ineta* adsp_tun_contr_ineta)
+   : adsc_tun_contr_conn(adsp_tun_contr_conn),
+     adsc_tun_contr_ineta(adsp_tun_contr_ineta),
+     boc_sess_closed(false),
+     boc_cansend(true),
      umc_discard_count(0)
 {
+#ifdef TRY_HPPPT1_130116
+   adsc_tun_contr_conn->imc_trace_level = HL_WT_SESS_NETW;
+#endif

+   dsc_htun_handle.iec_tunc = adsp_tun_contr_conn->iec_tunc;
+   memset(chrc_last_error, 0, sizeof(chrc_last_error));
+   dsg_tun_contr_ineta_list.push_back(adsp_tun_contr_ineta);
+
+   dsc_ppp_wrap.adsc_ppp_session = this;
+   dsc_htun_handle.vpc_contr = this;
+   // Init AVL tree, if necessary.
+   if(!bo_pppsess_avl_initd)
+   {
+      m_htree1_avl_init(NULL, &ds_pppsess_avl_cntl, m_cmp_pppsess_nodes);
+      ds_pppsess_avl_cs.m_create();
+      bo_pppsess_avl_initd = true;
+   }
+
    // Initialize PPP server instance for this HOB-PPP-T1 session.
-   memset(&dsc_ppp_se_1, 0, sizeof(dsd_ppp_server_1));
-   dsc_ppp_se_1.amc_ppp_se_send = m_ppp_send_callback_se;
-   dsc_ppp_se_1.amc_ppp_se_auth = m_ppp_auth_1;
-   dsc_ppp_se_1.amc_ppp_se_abend = m_log_ppp_warning;
-   dsc_ppp_se_1.amc_ppp_se_get_ineta_client = m_ppp_se_get_ineta_client; // obtain from sockaddr_storage
-   dsc_ppp_se_1.chrc_magic_number_se[0] = 0x01;
-   dsc_ppp_se_1.chrc_magic_number_se[1] = 0x02;
-   dsc_ppp_se_1.chrc_magic_number_se[2] = 0x03;
-   dsc_ppp_se_1.chrc_magic_number_se[3] = 0x04;
-   dsc_ppp_se_1.isc_recv_ident_lcp_conf = -1;
-   dsc_ppp_se_1.vpc_handle = adsp_sess_info;
+   memset(&dsc_ppp_wrap.dsc_ppp_se_1, 0, sizeof(dsd_ppp_server_1));
+   dsc_ppp_wrap.dsc_ppp_se_1.amc_ppp_se_send = m_ppp_send_callback_se;
+   dsc_ppp_wrap.dsc_ppp_se_1.amc_ppp_se_auth = m_ppp_auth_1;
+   dsc_ppp_wrap.dsc_ppp_se_1.amc_ppp_se_abend = m_log_ppp_warning;
+   dsc_ppp_wrap.dsc_ppp_se_1.amc_ppp_se_get_ineta_client = m_ppp_se_get_ineta_client; // obtain from sockaddr_storage
+   dsc_ppp_wrap.dsc_ppp_se_1.chrc_magic_number_se[0] = 0x01;
+   dsc_ppp_wrap.dsc_ppp_se_1.chrc_magic_number_se[1] = 0x02;
+   dsc_ppp_wrap.dsc_ppp_se_1.chrc_magic_number_se[2] = 0x03;
+   dsc_ppp_wrap.dsc_ppp_se_1.chrc_magic_number_se[3] = 0x04;
+   dsc_ppp_wrap.dsc_ppp_se_1.isc_recv_ident_lcp_conf = -1;
+   dsc_ppp_wrap.dsc_ppp_se_1.vpc_handle = &dsc_htun_handle;

    // Obtain server's internal network INETA and netmask.
-   umc_s_nw_ineta = adsp_tun_start1->umc_s_nw_ineta;
-   umc_s_nw_mask = adsp_tun_start1->umc_s_nw_mask;
+   umc_s_nw_ineta = adsp_tun_start_ppp->umc_s_nw_ineta_ipv4;
+   umc_s_nw_mask = adsp_tun_start_ppp->umc_s_nw_mask_ipv4;

    // Init general CS.
    dsd_cs.m_create();
@@ -169,17 +213,32 @@

 };

+const dsd_ppp_session& dsd_ppp_session::operator=(dsd_ppp_session& dsp_rhs)
+{
+    if(this != &dsp_rhs)
+    {
+   adsc_tun_contr_ineta = dsp_rhs.adsc_tun_contr_ineta;
+   dsc_ppp_wrap.dsc_ppp_se_1 = dsp_rhs.dsc_ppp_wrap.dsc_ppp_se_1;
+   umc_discard_count = dsp_rhs.umc_discard_count;
+   umc_s_nw_ineta = dsp_rhs.umc_s_nw_ineta;
+   umc_s_nw_mask = dsp_rhs.umc_s_nw_mask;
+   //dsc_sendto_extnw_msgq = dsp_rhs.dsc_sendto_extnw_msgq;
+   boc_ppp_svr_started = dsp_rhs.boc_ppp_svr_started;
+}
+    return *this;
+}
+
 dsd_ppp_session::~dsd_ppp_session()
 {
     // Close PPP server.
     if(boc_ppp_svr_started)
-    m_close_ppp_server_cs(&dsc_ppp_se_1);
+    m_close_ppp_server_cs(&dsc_ppp_wrap.dsc_ppp_se_1);

     // Release general CS.
     dsd_cs.m_close();
 }

-int32 dsd_ppp_session::mc_init()
+int32_t dsd_ppp_session::mc_init()
 {

    // Return OK.
@@ -189,35 +248,52 @@

 void dsd_ppp_session::mc_close()
 {
-#ifdef HPPPT1_RECONNECT
+    if((adsc_tun_contr_conn->imc_trace_level & HL_WT_SESS_NETW) != 0)
+    {
+        m_do_wsp_trace("SNEPPPCL", 0, adsc_tun_contr_conn->imc_sno,
+            adsc_tun_contr_conn->imc_trace_level, NULL, 0, 0,
+            "HOB-PPP-T1 session being closed. Reconnect timer launching for %d seconds.",
+			1000 * 60 * 4);
+    }
+	// Inform WSP about session termination.
+    m_htun_session_end(adsc_tun_contr_conn, 0);
+//#ifdef HPPPT1_RECONNECT
     // Create and set timer to release resources (Route, PARP, INETA etc...).
-    memset(&dsc_timer_close, 0, sizeof(dsc_timer_close));
-    dsc_timer_close.amc_compl = m_cb_timer_close;
-    dsc_timer_close.ilcwaitmsec = 1000 * 30; // 30s timeout.
-    m_time_set(&dsc_timer_close, false);
-#else
-    mc_ppp_close_and_release(this);
-#endif
+    memset(&dsc_ppp_wrap.dsc_timer_close, 0, sizeof(dsc_ppp_wrap.dsc_timer_close));
+    dsc_ppp_wrap.dsc_timer_close.amc_compl = m_cb_timer_close;
+    dsc_ppp_wrap.dsc_timer_close.ilcwaitmsec = 1000 * 60 * 4; // 4 min timeout.
+    m_time_set(&dsc_ppp_wrap.dsc_timer_close, false);
+//#else
+//    mc_ppp_close_and_release(this);
+//#endif

     return;

 }

+void m_reconnect_workaround(struct dsd_tun_contr_ineta* adsp_tun_contr_ineta, struct dsd_tun_contr_conn* adsp_tun_contr_conn);
+
 // TODO: Remove duplicate code.
-int32 dsd_ppp_session::mc_interpret_msg(dsd_gather_i_1* adsp_gather,
-                                        dsd_hco_wothr*  adsp_hco_wothr)
+int32_t dsd_ppp_session::mc_interpret_msg(dsd_gather_i_1* adsp_gather,
+                                          dsd_hco_wothr*  adsp_hco_wothr)
 {

-   int32 iml_len                  = 0; // Length value of hob-tun length field.
-   int32 iml_lenlen               = 0; // Length of hob-tun length field.
-   int32 iml_tot_ht_pkt_len       = 0; // Tot length of hob-tun pkt.
+   int32_t iml_len                = 0; // Length value of hob-tun length field.
+   int32_t iml_lenlen             = 0; // Length of hob-tun length field.
+   int32_t iml_tot_ht_pkt_len     = 0; // Tot length of hob-tun pkt.
    dsd_gather_i_1* adsl_curr_link = adsp_gather;

-   dsd_targfi_1* adsl_targ_filter = m_htun_ppp_get_targfi(adsc_sess_info);
+   dsd_targfi_1* adsl_targ_filter = m_htun_ppp_get_targfi(adsc_tun_contr_conn);
    dsd_ppp_targfi_act_1* adsl_ppp_targfi_act = NULL;
    if(adsl_targ_filter != NULL)
    {
-       adsl_ppp_targfi_act = m_create_ppp_targfi(adsl_targ_filter);
+      if((adsc_tun_contr_conn->imc_trace_level & HL_WT_SESS_NETW) != 0)
+      {
+         m_do_wsp_trace("SNEPPPTC", 0, adsc_tun_contr_conn->imc_sno,
+            adsc_tun_contr_conn->imc_trace_level, NULL, 0, 0,
+            "Creating PPP target filter.");
+      }
+      adsl_ppp_targfi_act = m_create_ppp_targfi(adsl_targ_filter);
    }

    // While more links are available.
@@ -228,10 +304,10 @@
       if(iel_ret == ied_comm_found)
       {
          // move to start of length
-         uint32 uml_skip_len = 20;
+         uint32_t uml_skip_len = 20;
          do
          {
-            uint32 uml_link_len = adsl_curr_link->achc_ginp_end - adsl_curr_link->achc_ginp_cur;
+            uint32_t uml_link_len = adsl_curr_link->achc_ginp_end - adsl_curr_link->achc_ginp_cur;
 #ifdef HL_UNIX
 			adsl_curr_link->achc_ginp_cur += std::min(uml_skip_len, uml_link_len);
 			uml_skip_len -= std::min(uml_skip_len, uml_link_len);
@@ -275,10 +351,13 @@
          if((adsl_curr_link->achc_ginp_end - adsl_curr_link->achc_ginp_cur) >=
             iml_tot_ht_pkt_len)
          {  // IS completely inside this link.
-            m_do_wsp_trace("SNETUNRE", 0, adsc_sess_info->imc_sno,
-                           adsc_sess_info->imc_trace_level, adsl_curr_link,
-                           iml_tot_ht_pkt_len, 20,
-                           "HOB-PPP-T1 read %d bytes from client.", iml_tot_ht_pkt_len);
+            if((adsc_tun_contr_conn->imc_trace_level & HL_WT_SESS_NETW) != 0)
+			{
+               m_do_wsp_trace("SNETUNRE", 0, adsc_tun_contr_conn->imc_sno,
+                              adsc_tun_contr_conn->imc_trace_level, adsl_curr_link,
+                              iml_tot_ht_pkt_len, 20,
+                              "HOB-PPP-T1 read %d bytes from client.", iml_tot_ht_pkt_len);
+            }
             // If HOB-TUN control byte is 0x30 (i.e.: ASCII "0")...
             if(*(adsl_curr_link->achc_ginp_cur + iml_lenlen) == 0x30)
             {
@@ -291,68 +370,132 @@
                 // Match following sequence against "START"...
                 if(memcmp(achrl_comm, chrl_start, 5) == 0)
                 {
-#ifdef NEW_HOB_TUN_1103
+                    if((adsc_tun_contr_conn->imc_trace_level & HL_WT_SESS_NETW) != 0)
+                    {
+                        m_do_wsp_trace("SNEPPPST", 0, adsc_tun_contr_conn->imc_sno,
+                            adsc_tun_contr_conn->imc_trace_level, NULL, 0, 0,
+                            "HOB-PPP-T1 START received from client.");
+                    }
+#ifndef NEW_HOB_TUN_1103
                     // Try to obtain a VINETA for the connecting client.
-                    aumc_client_ineta =
-                        (uint32*)(m_htun_ppp_acquire_local_ineta_ipv4(adsp_hco_wothr,
-                                                                      (dsd_tun_contr1*)dsc_ppp_se_1.vpc_handle));
+                    if((adsc_tun_contr_conn->imc_trace_level & HL_WT_SESS_NETW) != 0)
+                    {
+                        m_do_wsp_trace("SNEPPPIA", 0, adsc_tun_contr_conn->imc_sno,
+                            adsc_tun_contr_conn->imc_trace_level, NULL, 0, 0,
+                            "Attempting to acquire VINETA for connecting client.");
+                    }
+                    adsc_tun_contr_ineta = m_htun_ppp_acquire_local_ineta_ipv4(adsp_hco_wothr,
+                        adsc_tun_contr_conn, NULL);
 #endif
-                    if(aumc_client_ineta == NULL)
+                    if(adsc_tun_contr_ineta == NULL)
                     {
+                        if((adsc_tun_contr_conn->imc_trace_level & HL_WT_SESS_NETW) != 0)
+                        {
+                            m_do_wsp_trace("SNEPPPIF", 0, adsc_tun_contr_conn->imc_sno,
+                                adsc_tun_contr_conn->imc_trace_level, NULL, 0, 0,
+                                "Could not acquire VINETA for connecting client. Closing session.");
+                        }
                         // Close PPP session immediately, without timer.
                         mc_ppp_close_and_release(this);
                         return 0;
                     }
-                    // Add new INETA pointer to "old INETA" map, for use in case of reconnect.
-                    dss_old_ineta_map[ntohl(*aumc_client_ineta)] = aumc_client_ineta;

+                    // Add new node to AVL tree.
+                    ds_pppsess_avl_cs.m_enter();
+                    dsd_avl_sess_entry* ads_new_pppsess_node = new dsd_avl_sess_entry;
+                    ads_new_pppsess_node->umc_key_ineta = adsc_tun_contr_ineta->dsc_soa_local_ipv4.
+                       sin_addr.s_addr;
+                    ads_new_pppsess_node->adsc_ppp_sess = this;
+                    m_htree1_avl_search(NULL, &ds_pppsess_avl_cntl, &ds_pppsess_avl_wrk,
+                        &ads_new_pppsess_node->dsc_avl_hdr);
+                    m_htree1_avl_insert(NULL, &ds_pppsess_avl_cntl, &ds_pppsess_avl_wrk, &ads_new_pppsess_node->dsc_avl_hdr);
+                    ds_pppsess_avl_cs.m_leave();
+
                     mc_send_responsestart();
                 }
-#ifdef HPPPT1_RECONNECT
                 // Match following sequence against "RECONNECT"...
                 else if(memcmp(achrl_comm, chrl_reconnect, 9) == 0)
                 {
-                    // Call m_htun_ppp_use_local_ineta() to use the INETA
-                    // acquired by the old WSP session.
+                    if((adsc_tun_contr_conn->imc_trace_level & HL_WT_SESS_NETW) != 0)
+                    {
+                        m_do_wsp_trace("SNEPPPRC", 0, adsc_tun_contr_conn->imc_sno,
+                            adsc_tun_contr_conn->imc_trace_level, NULL, 0, 0,
+                            "HOB-PPP-T1 RECONNECT received from client.");
+                    }

                     // Obtain old VINETA from RECONNECT message.
                     char chrl_vineta[9] = { 0 };
                     memcpy(chrl_vineta, achrl_comm + 20, 8);
                     std::stringstream dsl_ss;
                     dsl_ss << std::hex << chrl_vineta;
-                    uint32 uml_vineta = 0;
+                    uint32_t uml_vineta = 0;
                     dsl_ss >> uml_vineta;
+                    uml_vineta = htonl(uml_vineta);

-                    // Look up old VINETA in map.
-                    std::map<uint32, uint32*>::iterator dsl_iter;
-                    dsl_iter = dss_old_ineta_map.find(uml_vineta);
-                    if(dsl_iter == dss_old_ineta_map.end())
+                    // Look up VINETA in AVL tree.
+                    ds_pppsess_avl_cs.m_enter();
+                    dsd_avl_sess_entry dsl_pppsess_search_node;
+                    dsl_pppsess_search_node.umc_key_ineta = uml_vineta;
+                    m_htree1_avl_search(NULL, &ds_pppsess_avl_cntl, &ds_pppsess_avl_wrk,
+                        (dsd_htree1_avl_entry*)&dsl_pppsess_search_node);
+                
+                    // If original session found...
+                    dsd_ppp_session* adsl_orig_ppp_sess = NULL;
+                    if(ds_pppsess_avl_wrk.adsc_found)
                     {
-                        // TODO: Terminate session.
+                       // Copy original session.
+                       dsd_avl_sess_entry* adsl_found_node =
+                          (dsd_avl_sess_entry*)ds_pppsess_avl_wrk.adsc_found;
+                       adsl_orig_ppp_sess = (dsd_ppp_session*)adsl_found_node->adsc_ppp_sess;
+                       *this = *adsl_orig_ppp_sess;
+                       // Release close timer on original session.
+                       m_time_rel(&adsl_orig_ppp_sess->dsc_ppp_wrap.dsc_timer_close);
+                       // Remove original session and release its resources.
+                       m_htree1_avl_delete(NULL, &ds_pppsess_avl_cntl, &ds_pppsess_avl_wrk);
+                       delete adsl_found_node;
+                       adsl_orig_ppp_sess->boc_ppp_svr_started = FALSE;
+                       delete adsl_orig_ppp_sess;
+                       // Add new node to AVL tree.
+                       dsd_avl_sess_entry* ads_new_pppsess_node = new dsd_avl_sess_entry;
+                       ads_new_pppsess_node->umc_key_ineta = adsc_tun_contr_ineta->dsc_soa_local_ipv4.
+                          sin_addr.s_addr;
+                       ads_new_pppsess_node->adsc_ppp_sess = this;
+                       m_htree1_avl_insert(NULL, &ds_pppsess_avl_cntl, &ds_pppsess_avl_wrk, &ads_new_pppsess_node->dsc_avl_hdr);
+
+                       ////////////////////////////
+                       m_reconnect_workaround(adsc_tun_contr_ineta, adsc_tun_contr_conn);
+                       ////////////////////////////
                     }
                     else
                     {
-                        uint32* auml_ptr = (*dsl_iter).second;
-#ifdef NEW_HOB_TUN_1103
-                        // Use old INETA.
-                        m_htun_ppp_use_local_ineta(adsc_sess_info, (char*)auml_ptr);
-#endif
+                       if((adsc_tun_contr_conn->imc_trace_level & HL_WT_SESS_NETW) != 0)
+                       {
+                          m_do_wsp_trace("SNEPPPRF", 0, adsc_tun_contr_conn->imc_sno,
+                             adsc_tun_contr_conn->imc_trace_level, NULL, 0, 0,
+                             "RECONNECT failed. Could not find original session.");
+                       }
+                       // Terminate session.
+                       mc_ppp_close_and_release(this);
                     }
+                    ds_pppsess_avl_cs.m_leave();
                 }
-#endif
                 // Match following sequence against "END"...
                 else if(memcmp(achrl_comm, chrl_end, 3) == 0)
                 {
-#ifdef NEW_HOB_TUN_1103
-                    if ( aumc_client_ineta ) {
+                    if((adsc_tun_contr_conn->imc_trace_level & HL_WT_SESS_NETW) != 0)
+                    {
+                        m_do_wsp_trace("SNEPPPEN", 0, adsc_tun_contr_conn->imc_sno,
+                            adsc_tun_contr_conn->imc_trace_level, NULL, 0, 0,
+                            "HOB-PPP-T1 END received from client.");
+                    }
+#ifndef HL_UNIX
+#ifndef NEW_HOB_TUN_1103
+                    if ( adsc_tun_contr_ineta ) {
                         // Indicate that INETA is no longer in use.
                         m_htun_ppp_release_local_ineta(adsc_sess_info, (char*)aumc_client_ineta);
                     }
 #endif
-                    if ( aumc_client_ineta ) {
-                        // Remove old INETA from map.
-                        dss_old_ineta_map.erase(*aumc_client_ineta);
-                    }
+#endif
                     // Close PPP session immediately, without timer.
                     mc_ppp_close_and_release(this);
                 }
@@ -398,7 +541,7 @@
                    adsl_curr_link->achc_ginp_cur += iml_lenlen + 1;
                   // Send Data field to PPP implementation for processing.
                   m_recv_ppp_server_cs
-                     (&dsc_ppp_se_1,
+                     (&dsc_ppp_wrap.dsc_ppp_se_1,
                       adsl_curr_link->achc_ginp_cur,
                       iml_len - 1);
                   adsl_curr_link->achc_ginp_cur -= iml_lenlen + 1;
@@ -406,7 +549,7 @@
                   // Initiate PPP server LCP negotiation after first PPP message is received from client.
                   if(boc_ppp_svr_started == false)
                   {
-                     m_start_ppp_server_cs(&dsc_ppp_se_1);
+                     m_start_ppp_server_cs(&dsc_ppp_wrap.dsc_ppp_se_1);
                      boc_ppp_svr_started = true;
                   }
                }
@@ -458,7 +601,7 @@
             // PPP client.
             if(imc_i == 2)
             {
-               m_start_ppp_server_cs(&dsc_ppp_se_1); 
+               m_start_ppp_server_cs(&dsc_ppp_wrap.dsc_ppp_se_1); 
                imc_i++;
                boc_b = false;
             }
@@ -472,9 +615,9 @@
             // Initiate PPP server LCP negotiation after client IPCP negotiation
             // completes.
             if(boc_ppp_svr_started == false &&
-               dsc_ppp_se_1.imc_options & D_PPP_OPT_HS_COMPL > 0)
+               dsc_ppp_wrap.dsc_ppp_se_1.imc_options & D_PPP_OPT_HS_COMPL > 0)
             {
-               m_start_ppp_server_cs(&dsc_ppp_se_1);
+               m_start_ppp_server_cs(&dsc_ppp_wrap.dsc_ppp_se_1);
                boc_ppp_svr_started = true;
             }
 #endif
@@ -496,12 +639,15 @@
             if(m_check_pkt_complete(adsl_curr_link,
                                     iml_tot_ht_pkt_len, &abyl_pkt_end))
             {  // IS completely available in this chain.
-                m_do_wsp_trace("SNETUNRE", 0, adsc_sess_info->imc_sno,
-                               adsc_sess_info->imc_trace_level, adsl_curr_link,
-                               iml_tot_ht_pkt_len, 20,
-                               "HOB-PPP-T1 read %d bytes from client.",
-                               iml_tot_ht_pkt_len);
-               int32 iml_bytes_copied = 0; //number of bytes copied.
+               if((adsc_tun_contr_conn->imc_trace_level & HL_WT_SESS_NETW) != 0)
+			   {
+                  m_do_wsp_trace("SNETUNRE", 0, adsc_tun_contr_conn->imc_sno,
+                                 adsc_tun_contr_conn->imc_trace_level, adsl_curr_link,
+                                 iml_tot_ht_pkt_len, 20,
+                                 "HOB-PPP-T1 read %d bytes from client.",
+                                 iml_tot_ht_pkt_len);
+               }
+               int32_t iml_bytes_copied = 0; //number of bytes copied.
                // Create buffer to hold complete hob-tun pkt.
                byte* abyl_cpy_buff =
                   new byte[iml_tot_ht_pkt_len];
@@ -545,71 +691,132 @@
                    // Match following sequence against "START"...
                    if(memcmp(achl_hpppt1_msg_start, chrl_start, 5) == 0)
                    {
-#ifdef NEW_HOB_TUN_1103
+                       if((adsc_tun_contr_conn->imc_trace_level & HL_WT_SESS_NETW) != 0)
+                       {
+                           m_do_wsp_trace("SNEPPPST", 0, adsc_tun_contr_conn->imc_sno,
+                               adsc_tun_contr_conn->imc_trace_level, NULL, 0, 0,
+                               "HOB-PPP-T1 START received from client.");
+                       }
+#ifndef NEW_HOB_TUN_1103
                       // Try to obtain a VINETA for the connecting client.
-                      aumc_client_ineta =
-                          (uint32*)(m_htun_ppp_acquire_local_ineta_ipv4(adsp_hco_wothr,
-                                                                        (dsd_tun_contr1*)dsc_ppp_se_1.vpc_handle));
+                       if((adsc_tun_contr_conn->imc_trace_level & HL_WT_SESS_NETW) != 0)
+                       {
+                          m_do_wsp_trace("SNEPPPIA", 0, adsc_tun_contr_conn->imc_sno,
+                             adsc_tun_contr_conn->imc_trace_level, NULL, 0, 0,
+                             "Attempting to acquire VINETA for connecting client.");
+                       }
+                       adsc_tun_contr_ineta = m_htun_ppp_acquire_local_ineta_ipv4(adsp_hco_wothr,
+                          adsc_tun_contr_conn, NULL);
 #endif
-                      if(aumc_client_ineta == NULL)
+                      if(adsc_tun_contr_ineta == NULL)
                       {
+                         if((adsc_tun_contr_conn->imc_trace_level & HL_WT_SESS_NETW) != 0)
+                         {
+                            m_do_wsp_trace("SNEPPPIF", 0, adsc_tun_contr_conn->imc_sno,
+                               adsc_tun_contr_conn->imc_trace_level, NULL, 0, 0,
+                               "Could not acquire VINETA for connecting client. Closing session.");
+                         }
                          // Close PPP session immediately, without timer.
                          mc_ppp_close_and_release(this);
                          return 0;
                       }
-                      // Add new INETA pointer to "old INETA" map, for use in case of reconnect.
-                      dss_old_ineta_map[ntohl(*aumc_client_ineta)] = aumc_client_ineta;

+                      // Add new node to AVL tree.
+                      ds_pppsess_avl_cs.m_enter();
+                      dsd_avl_sess_entry* ads_new_pppsess_node = new dsd_avl_sess_entry;
+                      ads_new_pppsess_node->umc_key_ineta = adsc_tun_contr_ineta->dsc_soa_local_ipv4.
+                         sin_addr.s_addr;
+                      ads_new_pppsess_node->adsc_ppp_sess = this;
+                      m_htree1_avl_insert(NULL, &ds_pppsess_avl_cntl, &ds_pppsess_avl_wrk, &ads_new_pppsess_node->dsc_avl_hdr);
+                      ds_pppsess_avl_cs.m_leave();
+
                       // Initiate PPP server LCP negotiation.
-                      m_start_ppp_server_cs(&dsc_ppp_se_1);
+                      m_start_ppp_server_cs(&dsc_ppp_wrap.dsc_ppp_se_1);

                       mc_send_responsestart();
                    }
-#ifdef HPPPT1_RECONNECT
                    // Match following sequence against "RECONNECT"...
                    else if(memcmp(achrl_comm, chrl_reconnect, 9) == 0)
                    {
-                      // Call m_htun_ppp_use_local_ineta() to use the INETA
-                      // acquired by the old WSP session.
-
+                      if((adsc_tun_contr_conn->imc_trace_level & HL_WT_SESS_NETW) != 0)
+                      {
+                         m_do_wsp_trace("SNEPPPRC", 0, adsc_tun_contr_conn->imc_sno,
+                            adsc_tun_contr_conn->imc_trace_level, NULL, 0, 0,
+                            "HOB-PPP-T1 RECONNECT received from client.");
+                      }
                       // Obtain old VINETA from RECONNECT message.
                       char chrl_vineta[9] = { 0 };
                       memcpy(chrl_vineta, achrl_comm + 20, 8);
                       std::stringstream dsl_ss;
                       dsl_ss << std::hex << chrl_vineta;
-                      uint32 uml_vineta = 0;
+                      uint32_t uml_vineta = 0;
                       dsl_ss >> uml_vineta;
+                      uml_vineta = htonl(uml_vineta);

-                      // Look up old VINETA in map.
-                      std::map<uint32, uint32*>::iterator dsl_iter;
-                      dsl_iter = dss_old_ineta_map.find(uml_vineta);
-                      if(dsl_iter == dss_old_ineta_map.end())
+                      // Look up VINETA in AVL tree.
+                      ds_pppsess_avl_cs.m_enter();
+                      dsd_avl_sess_entry dsl_pppsess_search_node;
+                      dsl_pppsess_search_node.umc_key_ineta = uml_vineta;
+                      m_htree1_avl_search(NULL, &ds_pppsess_avl_cntl, &ds_pppsess_avl_wrk,
+                         (dsd_htree1_avl_entry*)&dsl_pppsess_search_node);
+                
+                      // If original session found...
+                      dsd_ppp_session* adsl_orig_ppp_sess = NULL;
+                      if(ds_pppsess_avl_wrk.adsc_found)
                       {
-                          // TODO: Terminate session.
+                         // Copy original session.
+                         dsd_avl_sess_entry* adsl_found_node =
+                           (dsd_avl_sess_entry*)ds_pppsess_avl_wrk.adsc_found;
+                         adsl_orig_ppp_sess = (dsd_ppp_session*)adsl_found_node->adsc_ppp_sess;
+                         *this = *adsl_orig_ppp_sess;
+                         // Release close timer on original session.
+                         m_time_rel(&adsl_orig_ppp_sess->dsc_ppp_wrap.dsc_timer_close);
+                         // Remove original session and release its resources.
+                         m_htree1_avl_delete(NULL, &ds_pppsess_avl_cntl, &ds_pppsess_avl_wrk);
+                         delete adsl_found_node;
+                         adsl_orig_ppp_sess->boc_ppp_svr_started = FALSE;
+                         delete adsl_orig_ppp_sess;
+                         // Add new node to AVL tree.
+                         dsd_avl_sess_entry* ads_new_pppsess_node = new dsd_avl_sess_entry;
+                         ads_new_pppsess_node->umc_key_ineta = adsc_tun_contr_ineta->dsc_soa_local_ipv4.
+                            sin_addr.s_addr;
+                         ads_new_pppsess_node->adsc_ppp_sess = this;
+                         m_htree1_avl_insert(NULL, &ds_pppsess_avl_cntl, &ds_pppsess_avl_wrk, &ads_new_pppsess_node->dsc_avl_hdr);
+
+                         ////////////////////////////
+                         m_reconnect_workaround(adsc_tun_contr_ineta, adsc_tun_contr_conn);
+                         ////////////////////////////
                       }
                       else
                       {
-                          uint32* auml_ptr = (*dsl_iter).second;
-#ifdef NEW_HOB_TUN_1103
-                          // Use old INETA.
-                          m_htun_ppp_use_local_ineta(adsc_sess_info, (char*)auml_ptr);
-#endif
+                         if((adsc_tun_contr_conn->imc_trace_level & HL_WT_SESS_NETW) != 0)
+                         {
+                             m_do_wsp_trace("SNEPPPRF", 0, adsc_tun_contr_conn->imc_sno,
+                                adsc_tun_contr_conn->imc_trace_level, NULL, 0, 0,
+                                "RECONNECT failed. Could not find original session.");
+                         }
+                         // Terminate session.
+                         mc_ppp_close_and_release(this);
                       }
+                      ds_pppsess_avl_cs.m_leave();
                    }
-#endif
                    // Match following sequence against "END"...
                    else if(memcmp(achl_hpppt1_msg_start, chrl_end, 3) == 0)
                    {
-#ifdef NEW_HOB_TUN_1103
-                      if ( aumc_client_ineta ) {
+                      if((adsc_tun_contr_conn->imc_trace_level & HL_WT_SESS_NETW) != 0)
+                      {
+                         m_do_wsp_trace("SNEPPPEN", 0, adsc_tun_contr_conn->imc_sno,
+                            adsc_tun_contr_conn->imc_trace_level, NULL, 0, 0,
+                            "HOB-PPP-T1 END received from client.");
+                      }
+#ifndef HL_UNIX
+#ifndef NEW_HOB_TUN_1103
+                      if ( adsc_tun_contr_ineta ) {
                         // Indicate that INETA is no longer in use.
                         m_htun_ppp_release_local_ineta(adsc_sess_info, (char*)aumc_client_ineta);
                       }
 #endif
-                      if ( aumc_client_ineta ) {
-                        // Remove old INETA from map.
-                        dss_old_ineta_map.erase(*aumc_client_ineta);
-                      }
+#endif
                       // Close PPP session immediately, without timer.
                       mc_ppp_close_and_release(this);
                    }
@@ -654,7 +861,7 @@
                   else
                   {
                      // Send Data field to PPP implementation for processing.
-                     m_recv_ppp_server_cs(&dsc_ppp_se_1,
+                     m_recv_ppp_server_cs(&dsc_ppp_wrap.dsc_ppp_se_1,
                                           (char*)(achl_hpppt1_msg_start + iml_lenlen + 1),
                                           iml_len - 1);
                   }
@@ -735,7 +942,8 @@
         return FALSE;

     // Obtain VINETA from AVL node.
-    uint32 uml_tunnel_id = htonl(*aumc_client_ineta);
+    uint32_t uml_tunnel_id = htonl(adsc_tun_contr_ineta->
+                          dsc_soa_local_ipv4.sin_addr.s_addr);

     // Obtain server network (internal) INETA.
     in_addr dsl_s_net_ineta;
@@ -752,7 +960,7 @@
     // Build RESPONSE-START message.
     char chrl_buf[256] = { 0 };
     sprintf(chrl_buf, "RESPONSE-START TUNNEL-ID=%08X SERVER-NETWORK-INETA=%s SERVER-NETWORK-MASK=%s", uml_tunnel_id, chrl_s_net_ineta, chrl_s_net_mask);
-    uint32 uml_msglen = strlen(chrl_buf);
+    uint32_t uml_msglen = strlen(chrl_buf);
     memcpy(abyl_data + 10, chrl_buf, uml_msglen);

     // Create buf vec ele.
@@ -767,9 +975,9 @@
     dsl_buf_vec.imc_len_data += 1;

     // Calculate HOB-TUN length field val.
-    int32 iml_1 = dsl_buf_vec.imc_len_data;
+    int32_t iml_1 = dsl_buf_vec.imc_len_data;
     // Write HOB-TUN length value to pkt.
-    int8 chl_more = 0;
+    int8_t chl_more = 0;
     while(true)
     {
        dsl_buf_vec.achc_data -= 1;
@@ -778,14 +986,14 @@
        dsl_buf_vec.imc_len_data += 1;
        iml_1 >>= 7;
        if(iml_1 == 0) break;
-       chl_more = (int8)0x80;
+       chl_more = (int8_t)0x80;
     }

     // Check whether it is OK to send message towards client...
     if(boc_cansend)
     {
     // Send pkt to client.
-    if(!(m_se_htun_recvbuf(adsc_sess_info, &dsl_buf_vec, 1)))
+    if(!(m_se_htun_recvbuf(adsc_tun_contr_conn, &dsl_buf_vec, 1)))
     {
           // Indicate that it is not OK to send more messages towards client.
           boc_cansend = false;
@@ -801,6 +1009,70 @@
     return TRUE;
 }

+BOOL dsd_ppp_session::mc_send_stop()
+{
+    // Obtain a buffer to use for sending.
+    void* apl_handle = NULL;
+    byte* abyl_data = NULL;
+    int iml_data_len = 0;
+    iml_data_len = m_htun_getrecvbuf(&apl_handle, (char**)&abyl_data);
+
+    // Do a basic length check on the buffer obtained.
+    if(iml_data_len < 266)
+        return FALSE;
+
+    // Build STOP message.
+    char chrl_buf[256] = { 0 };
+    sprintf(chrl_buf, "STOP");
+    uint32_t uml_msglen = strlen(chrl_buf);
+    memcpy(abyl_data + 10, chrl_buf, uml_msglen);
+
+    // Create buf vec ele.
+    dsd_buf_vector_ele dsl_buf_vec;
+    dsl_buf_vec.ac_handle = apl_handle;
+    dsl_buf_vec.achc_data = (char*)(abyl_data + 10);
+    dsl_buf_vec.imc_len_data = uml_msglen;
+
+    // Add HOB-TUN control byte (ASCII "0").
+    dsl_buf_vec.achc_data -= 1;
+    *((byte*)(dsl_buf_vec.achc_data)) = 0x30;
+    dsl_buf_vec.imc_len_data += 1;
+
+    // Calculate HOB-TUN length field val.
+    int32_t iml_1 = dsl_buf_vec.imc_len_data;
+    // Write HOB-TUN length value to pkt.
+    int8_t chl_more = 0;
+    while(true)
+    {
+       dsl_buf_vec.achc_data -= 1;
+       *((byte*)(dsl_buf_vec.achc_data))
+          = (byte)(iml_1 & 0x7F) | chl_more;
+       dsl_buf_vec.imc_len_data += 1;
+       iml_1 >>= 7;
+       if(iml_1 == 0) break;
+       chl_more = (int8_t)0x80;
+    }
+
+    // Check whether it is OK to send message towards client...
+    if(boc_cansend)
+    {
+    // Send pkt to client.
+    if(!(m_se_htun_recvbuf(adsc_tun_contr_conn, &dsl_buf_vec, 1)))
+    {
+          // Indicate that it is not OK to send more messages towards client.
+          boc_cansend = false;
+       }
+    }
+    else
+    {
+       // Increment number of messages discarded.
+       umc_discard_count++;
+    }
+
+    // Return success.
+    return TRUE;
+}
+
 void dsd_ppp_session::mc_can_send()
 {
     // Enter general CS.
@@ -815,20 +1087,23 @@
         dsd_buf_vector_ele dsl_buf_vec = dsl_q_msg.ds_buf_vec_ele;
         dsc_sendto_extnw_msgq.pop();

-        // Create gather struct for tracing.
-        dsd_gather_i_1 dsl_gath;
-        dsl_gath.achc_ginp_cur = dsl_buf_vec.achc_data;
-        dsl_gath.achc_ginp_end =
-        dsl_buf_vec.achc_data + dsl_buf_vec.imc_len_data;
-        dsl_gath.adsc_next = NULL;
+        // Send queued message to client.
+        if((adsc_tun_contr_conn->imc_trace_level & HL_WT_SESS_NETW) != 0)
+		{
+            // Create gather struct for tracing.
+            dsd_gather_i_1 dsl_gath;
+            dsl_gath.achc_ginp_cur = dsl_buf_vec.achc_data;
+            dsl_gath.achc_ginp_end =
+                dsl_buf_vec.achc_data + dsl_buf_vec.imc_len_data;
+            dsl_gath.adsc_next = NULL;

-        // Send queued message to client.
-        m_do_wsp_trace("SNETUNSE", 0, adsc_sess_info->imc_sno,
-        adsc_sess_info->imc_trace_level, &dsl_gath,
-        dsl_buf_vec.imc_len_data, 20,
-        "HOB-PPP-T1 send %d bytes to client.",
-        dsl_buf_vec.imc_len_data);
-        if(!(m_se_htun_recvbuf(adsc_sess_info, &dsl_buf_vec, 1)))
+            m_do_wsp_trace("SNETUNSE", 0, adsc_tun_contr_conn->imc_sno,
+                           adsc_tun_contr_conn->imc_trace_level, &dsl_gath,
+                           dsl_buf_vec.imc_len_data, 20,
+                           "HOB-PPP-T1 send %d bytes to client.",
+                           dsl_buf_vec.imc_len_data);
+        }
+        if(!(m_se_htun_recvbuf(adsc_tun_contr_conn, &dsl_buf_vec, 1)))
         {
             // Indicate that it is not OK to send more messages towards client.
             boc_cansend = false;
@@ -838,7 +1113,7 @@
         if(!dsl_q_msg.bo_nodrop)
         {
             // Decrement number of queued messages.
-            adsc_sess_info->imc_on_the_fly_packets_client--;
+            adsc_tun_contr_conn->imc_on_the_fly_packets_client--;
         }
     }

@@ -846,9 +1121,9 @@
     dsd_cs.m_leave();
 }

-int32 dsd_ppp_session::mc_encapsulate_msg(void*  ap_handle,
-                                          byte*  abyp_data,
-                                          uint32 ump_length)
+int32_t dsd_ppp_session::mc_encapsulate_msg(void*  ap_handle,
+                                            byte*  abyp_data,
+                                            uint32_t ump_length)
 {
     // Enter general CS.
     dsd_cs.m_enter();
@@ -862,20 +1137,23 @@
         dsd_buf_vector_ele dsl_buf_vec = dsl_q_msg.ds_buf_vec_ele;
         dsc_sendto_extnw_msgq.pop();

-        // Create gather struct for tracing.
-        dsd_gather_i_1 dsl_gath;
-        dsl_gath.achc_ginp_cur = dsl_buf_vec.achc_data;
-        dsl_gath.achc_ginp_end =
-            dsl_buf_vec.achc_data + dsl_buf_vec.imc_len_data;
-        dsl_gath.adsc_next = NULL;
+        // Send queued message to client.
+        if((adsc_tun_contr_conn->imc_trace_level & HL_WT_SESS_NETW) != 0)
+		{
+            // Create gather struct for tracing.
+            dsd_gather_i_1 dsl_gath;
+            dsl_gath.achc_ginp_cur = dsl_buf_vec.achc_data;
+            dsl_gath.achc_ginp_end =
+                dsl_buf_vec.achc_data + dsl_buf_vec.imc_len_data;
+            dsl_gath.adsc_next = NULL;

-        // Send queued message to client.
-        m_do_wsp_trace("SNETUNSE", 0, adsc_sess_info->imc_sno,
-        adsc_sess_info->imc_trace_level, &dsl_gath,
-        dsl_buf_vec.imc_len_data, 20,
-        "HOB-PPP-T1 send %d bytes to client.",
-        dsl_buf_vec.imc_len_data);
-        if(!(m_se_htun_recvbuf(adsc_sess_info, &dsl_buf_vec, 1)))
+            m_do_wsp_trace("SNETUNSE", 0, adsc_tun_contr_conn->imc_sno,
+                           adsc_tun_contr_conn->imc_trace_level, &dsl_gath,
+                           dsl_buf_vec.imc_len_data, 20,
+                           "HOB-PPP-T1 send %d bytes to client.",
+                           dsl_buf_vec.imc_len_data);
+        }
+        if(!(m_se_htun_recvbuf(adsc_tun_contr_conn, &dsl_buf_vec, 1)))
         {
             // Indicate that it is not OK to send more messages towards client.
             boc_cansend = false;
@@ -885,7 +1163,7 @@
         if(!dsl_q_msg.bo_nodrop)
         {
             // Decrement number of queued messages.
-            adsc_sess_info->imc_on_the_fly_packets_client--;
+            adsc_tun_contr_conn->imc_on_the_fly_packets_client--;
         }
     }

@@ -901,9 +1179,9 @@
     dsl_buf_vec.imc_len_data += 1;

     // Calculate HOB-TUN length field val.
-    int32 iml_1 = dsl_buf_vec.imc_len_data;
+    int32_t iml_1 = dsl_buf_vec.imc_len_data;
     // Write HOB-TUN length value to pkt.
-    int8 chl_more = 0;
+    int8_t chl_more = 0;
     while(true)
     {
         dsl_buf_vec.achc_data -= 1;
@@ -918,19 +1196,23 @@
     // If it is still OK to continue sending messages to client...
     if(boc_cansend)
     {
-        // Prepare gather structure for tracing.
-        dsd_gather_i_1 dsl_gath;
-        dsl_gath.achc_ginp_cur = dsl_buf_vec.achc_data;
-        dsl_gath.achc_ginp_end = dsl_gath.achc_ginp_cur + dsl_buf_vec.imc_len_data;
-        dsl_gath.adsc_next = NULL;
-        m_do_wsp_trace("SNETUNSE", 0, adsc_sess_info->imc_sno,
-        adsc_sess_info->imc_trace_level, &dsl_gath,
-        dsl_buf_vec.imc_len_data, 20,
-        "HOB-PPP-T1 send %d bytes to client.",
-        dsl_buf_vec.imc_len_data);
+        if((adsc_tun_contr_conn->imc_trace_level & HL_WT_SESS_NETW) != 0)
+		{
+            // Prepare gather structure for tracing.
+            dsd_gather_i_1 dsl_gath;
+            dsl_gath.achc_ginp_cur = dsl_buf_vec.achc_data;
+            dsl_gath.achc_ginp_end = dsl_gath.achc_ginp_cur + dsl_buf_vec.imc_len_data;
+            dsl_gath.adsc_next = NULL;

+            m_do_wsp_trace("SNETUNSE", 0, adsc_tun_contr_conn->imc_sno,
+                           adsc_tun_contr_conn->imc_trace_level, &dsl_gath,
+                           dsl_buf_vec.imc_len_data, 20,
+                           "HOB-PPP-T1 send %d bytes to client.",
+                           dsl_buf_vec.imc_len_data);
+        }
+
         // Send message to client.
-        if(!(m_se_htun_recvbuf(adsc_sess_info, &dsl_buf_vec, 1)))
+        if(!(m_se_htun_recvbuf(adsc_tun_contr_conn, &dsl_buf_vec, 1)))
         {
             // Indicate that it is not OK to send more messages towards client.
             boc_cansend = false;
@@ -940,19 +1222,19 @@
     {
         // If number of queued messages is still below limit OR no drop flag is
         // set ...
-        if(adsc_sess_info->imc_on_the_fly_packets_client < MAX_PPP_ON_THE_FLY_PACKETS_CLIENT
-            || adsc_sess_info->boc_not_drop_tcp_packet)
+        if(adsc_tun_contr_conn->imc_on_the_fly_packets_client < MAX_PPP_ON_THE_FLY_PACKETS_CLIENT
+            || adsc_tun_contr_conn->boc_not_drop_tcp_packet)
         {
             // Place message in queue.
             dsd_queued_msg dsl_q_msg;
             dsl_q_msg.ds_buf_vec_ele = dsl_buf_vec;
-            dsl_q_msg.bo_nodrop = adsc_sess_info->boc_not_drop_tcp_packet;
+            dsl_q_msg.bo_nodrop = adsc_tun_contr_conn->boc_not_drop_tcp_packet;
             dsc_sendto_extnw_msgq.push(dsl_q_msg);
             // If no drop flag is not set...
-            if(!adsc_sess_info->boc_not_drop_tcp_packet)
+            if(!adsc_tun_contr_conn->boc_not_drop_tcp_packet)
             {
                 // Increment number of queued messages.
-                adsc_sess_info->imc_on_the_fly_packets_client++;
+                adsc_tun_contr_conn->imc_on_the_fly_packets_client++;
             }
         }
         else // Queue length limit reached...
@@ -978,7 +1260,7 @@
    adsp_buf_vec->imc_len_data += 1;

    // Calculate HOB-TUN length field val.
-   int32 iml_1 = adsp_buf_vec->imc_len_data;
+   int32_t iml_1 = adsp_buf_vec->imc_len_data;
    // Write HOB-TUN length value to pkt.
    char chl_more = 0;
    while(true)
@@ -994,9 +1276,9 @@
 }
 */

-int32 dsd_ppp_session::mc_tunnel_to_cl(void*  ap_handle,
-                                       byte*  abyp_data,
-                                       uint32 ump_length)
+int32_t dsd_ppp_session::mc_tunnel_to_cl(void*    ap_handle,
+                                         byte*    abyp_data,
+                                         uint32_t ump_length)
 {
     // Enter general CS.
     dsd_cs.m_enter();
@@ -1010,20 +1292,23 @@
         dsd_buf_vector_ele dsl_buf_vec = dsl_q_msg.ds_buf_vec_ele;
         dsc_sendto_extnw_msgq.pop();

-        // Create gather struct for tracing.
-        dsd_gather_i_1 dsl_gath;
-        dsl_gath.achc_ginp_cur = dsl_buf_vec.achc_data;
-        dsl_gath.achc_ginp_end =
-            dsl_buf_vec.achc_data + dsl_buf_vec.imc_len_data;
-        dsl_gath.adsc_next = NULL;
+        // Send queued message to client.
+        if((adsc_tun_contr_conn->imc_trace_level & HL_WT_SESS_NETW) != 0)
+		{
+            // Create gather struct for tracing.
+            dsd_gather_i_1 dsl_gath;
+            dsl_gath.achc_ginp_cur = dsl_buf_vec.achc_data;
+            dsl_gath.achc_ginp_end =
+                dsl_buf_vec.achc_data + dsl_buf_vec.imc_len_data;
+            dsl_gath.adsc_next = NULL;

-        // Send queued message to client.
-        m_do_wsp_trace("SNETUNSE", 0, adsc_sess_info->imc_sno,
-        adsc_sess_info->imc_trace_level, &dsl_gath,
-        dsl_buf_vec.imc_len_data, 20,
-        "HOB-PPP-T1 send %d bytes to client.",
-        dsl_buf_vec.imc_len_data);
-        if(!(m_se_htun_recvbuf(adsc_sess_info, &dsl_buf_vec, 1)))
+            m_do_wsp_trace("SNETUNSE", 0, adsc_tun_contr_conn->imc_sno,
+                           adsc_tun_contr_conn->imc_trace_level, &dsl_gath,
+                           dsl_buf_vec.imc_len_data, 20,
+                           "HOB-PPP-T1 send %d bytes to client.",
+                           dsl_buf_vec.imc_len_data);
+        }
+        if(!(m_se_htun_recvbuf(adsc_tun_contr_conn, &dsl_buf_vec, 1)))
         {
             // Indicate that it is not OK to send more messages towards client.
             boc_cansend = false;
@@ -1033,7 +1318,7 @@
         if(!dsl_q_msg.bo_nodrop)
         {
             // Decrement number of queued messages.
-            adsc_sess_info->imc_on_the_fly_packets_client--;
+            adsc_tun_contr_conn->imc_on_the_fly_packets_client--;
         }
     }

@@ -1049,9 +1334,9 @@
     dsl_buf_vec.imc_len_data += 1;

     // Calculate HOB-TUN length field val.
-    int32 iml_1 = dsl_buf_vec.imc_len_data;
+    int32_t iml_1 = dsl_buf_vec.imc_len_data;
     // Write HOB-TUN length value to pkt.
-    int8 chl_more = 0;
+    int8_t chl_more = 0;
     while(true)
     {
         dsl_buf_vec.achc_data -= 1;
@@ -1066,19 +1351,23 @@
     // If it is still OK to continue sending messages to client...
     if(boc_cansend)
     {
-        // Prepare gather structure for tracing.
-        dsd_gather_i_1 dsl_gath;
-        dsl_gath.achc_ginp_cur = dsl_buf_vec.achc_data;
-        dsl_gath.achc_ginp_end = dsl_gath.achc_ginp_cur + dsl_buf_vec.imc_len_data;
-        dsl_gath.adsc_next = NULL;
-        m_do_wsp_trace("SNETUNSE", 0, adsc_sess_info->imc_sno,
-        adsc_sess_info->imc_trace_level, &dsl_gath,
-        dsl_buf_vec.imc_len_data, 20,
-        "HOB-PPP-T1 send %d bytes to client.",
-        dsl_buf_vec.imc_len_data);
+        if((adsc_tun_contr_conn->imc_trace_level & HL_WT_SESS_NETW) != 0)
+		{
+            // Prepare gather structure for tracing.
+            dsd_gather_i_1 dsl_gath;
+            dsl_gath.achc_ginp_cur = dsl_buf_vec.achc_data;
+            dsl_gath.achc_ginp_end = dsl_gath.achc_ginp_cur + dsl_buf_vec.imc_len_data;
+            dsl_gath.adsc_next = NULL;

+            m_do_wsp_trace("SNETUNSE", 0, adsc_tun_contr_conn->imc_sno,
+                           adsc_tun_contr_conn->imc_trace_level, &dsl_gath,
+                           dsl_buf_vec.imc_len_data, 20,
+                           "HOB-PPP-T1 send %d bytes to client.",
+                           dsl_buf_vec.imc_len_data);
+        }
+
         // Send message to client.
-        if(!(m_se_htun_recvbuf(adsc_sess_info, &dsl_buf_vec, 1)))
+        if(!(m_se_htun_recvbuf(adsc_tun_contr_conn, &dsl_buf_vec, 1)))
         {
             // Indicate that it is not OK to send more messages towards client.
             boc_cansend = false;
@@ -1088,19 +1377,19 @@
     {
         // If number of queued messages is still below limit OR no drop flag is
         // set ...
-        if(adsc_sess_info->imc_on_the_fly_packets_client < MAX_PPP_ON_THE_FLY_PACKETS_CLIENT
-            || adsc_sess_info->boc_not_drop_tcp_packet)
+        if(adsc_tun_contr_conn->imc_on_the_fly_packets_client < MAX_PPP_ON_THE_FLY_PACKETS_CLIENT
+            || adsc_tun_contr_conn->boc_not_drop_tcp_packet)
         {
             // Place message in queue.
             dsd_queued_msg dsl_q_msg;
             dsl_q_msg.ds_buf_vec_ele = dsl_buf_vec;
-            dsl_q_msg.bo_nodrop = adsc_sess_info->boc_not_drop_tcp_packet;
+            dsl_q_msg.bo_nodrop = adsc_tun_contr_conn->boc_not_drop_tcp_packet;
             dsc_sendto_extnw_msgq.push(dsl_q_msg);
             // If no drop flag is not set...
-            if(!adsc_sess_info->boc_not_drop_tcp_packet)
+            if(!adsc_tun_contr_conn->boc_not_drop_tcp_packet)
             {
                 // Increment number of queued messages.
-                adsc_sess_info->imc_on_the_fly_packets_client++;
+                adsc_tun_contr_conn->imc_on_the_fly_packets_client++;
             }
         }
         else // Queue length limit reached...
@@ -1120,19 +1409,20 @@
 // New routine implemented in order to get address of INETA configured for htun.
 static char* m_ppp_se_get_ineta_client(struct dsd_ppp_server_1 *adsp_ppp_se_1)
 {
-   uint32* auml_client_ineta =
-       DEF_PPP_SESSION((dsd_tun_contr1*)adsp_ppp_se_1->vpc_handle)->
-       aumc_client_ineta;
+   //dsd_tun_contr_ineta* adsl_tun_contr_ineta = DEF_PPP_SESSION((dsd_tun_contr_conn*)adsp_ppp_se_1->
+   //    vpc_handle)->adsc_tun_contr_ineta;
+    dsd_tun_contr_ineta* adsl_tun_contr_ineta = ((dsd_ppp_session*)(((dsd_htun_handle*)(adsp_ppp_se_1->vpc_handle))->vpc_contr))->adsc_tun_contr_ineta;

+   if(adsl_tun_contr_ineta == NULL)
+      return NULL;
+
+   uint32_t* auml_client_ineta =
+       &(adsl_tun_contr_ineta->dsc_soa_local_ipv4.sin_addr.s_addr);
+
    if(*auml_client_ineta > 0)
-   {
        return (char*)(auml_client_ineta);
-   }
    else
-   {
        return NULL;
-   }
-
 } // End m_ppp_se_get_ineta_client().

 // Callback for PPP implementation to send HOB-PPP-T1 message back to client.
@@ -1140,9 +1430,10 @@
                                    dsd_buf_vector_ele* adsp_buf_vec)
 {

-   dsd_ppp_session* adsl_sess =
-      (dsd_ppp_session*)((char*)adsp_ppp_server -
-      offsetof(dsd_ppp_session, dsc_ppp_se_1));
+   // dsd_ppp_session* adsl_sess =
+   //    (dsd_ppp_session*)((char*)adsp_ppp_server -
+   //    offsetof(dsd_ppp_session, dsc_ppp_se_1));
+   dsd_ppp_session* adsl_sess = m_ppp_session_from_s1(adsp_ppp_server);
    adsl_sess->mc_tunnel_to_cl(adsp_buf_vec->ac_handle,
                               (byte*)adsp_buf_vec->achc_data,
                               adsp_buf_vec->imc_len_data);
@@ -1152,16 +1443,34 @@

 static void m_cb_timer_close(dsd_timer_ele* adsp_timer_close)
 {
-
     // Obtain ptr to ppp session.
-    int iml_offset = offsetof(dsd_ppp_session, dsc_timer_close);
-    dsd_ppp_session* adsl_ppp_sess =
-        (dsd_ppp_session*)((char*)adsp_timer_close - iml_offset);
+    // int iml_offset = offsetof(dsd_ppp_session, dsc_timer_close);
+    // dsd_ppp_session* adsl_ppp_sess =
+    //     (dsd_ppp_session*)((char*)adsp_timer_close - iml_offset);
+   dsd_ppp_session* adsl_ppp_sess = m_ppp_session_from_te(adsp_timer_close);

-    if ( adsl_ppp_sess->aumc_client_ineta )
-        // Remove old INETA from map.
-        dss_old_ineta_map.erase(*(adsl_ppp_sess->aumc_client_ineta));
+   	if((adsl_ppp_sess->adsc_tun_contr_conn->imc_trace_level & HL_WT_SESS_NETW) != 0)
+    {
+        m_do_wsp_trace("SNEPPPRE", 0, adsl_ppp_sess->adsc_tun_contr_conn->imc_sno,
+            adsl_ppp_sess->adsc_tun_contr_conn->imc_trace_level, NULL, 0, 0,
+            "HOB-PPP-T1 reconnect timer expired.");
+    }

+    // Remove PPP session node from AVL tree.
+    ds_pppsess_avl_cs.m_enter();
+    dsd_avl_sess_entry dsl_pppsess_search;
+    dsl_pppsess_search.umc_key_ineta = adsl_ppp_sess->adsc_tun_contr_ineta->dsc_soa_local_ipv4.
+        sin_addr.s_addr;
+    m_htree1_avl_search(NULL, &ds_pppsess_avl_cntl, &ds_pppsess_avl_wrk,
+        (dsd_htree1_avl_entry*)&dsl_pppsess_search);
+    if(ds_pppsess_avl_wrk.adsc_found)
+    {
+        dsd_avl_sess_entry* ads_pppsess_found = (dsd_avl_sess_entry*)ds_pppsess_avl_wrk.adsc_found;
+        m_htree1_avl_delete(NULL, &ds_pppsess_avl_cntl, &ds_pppsess_avl_wrk);
+        delete ads_pppsess_found;
+    }
+    ds_pppsess_avl_cs.m_leave();
+
     // Close PPP tunnel and release resources.
     mc_ppp_close_and_release(adsl_ppp_sess);

@@ -1170,23 +1479,32 @@

 static void mc_ppp_close_and_release(dsd_ppp_session* adsp_ppp_sess)
 {
-    dsd_tun_contr1* adsl_tc = adsp_ppp_sess->adsc_sess_info;
+    dsd_tun_contr_conn* adsl_tc = adsp_ppp_sess->adsc_tun_contr_conn;

+   	if((adsp_ppp_sess->adsc_tun_contr_conn->imc_trace_level & HL_WT_SESS_NETW) != 0)
+    {
+        m_do_wsp_trace("SNEPPPCR", 0, adsp_ppp_sess->adsc_tun_contr_conn->imc_sno,
+            adsp_ppp_sess->adsc_tun_contr_conn->imc_trace_level, NULL, 0, 0,
+            "HOB-PPP-T1 session being closed and released.");
+    }
+
+    // Release tun_contr_ineta of session.
+    m_htun_ppp_free_resources(adsp_ppp_sess->adsc_tun_contr_ineta);
+
     // Call class dtor.
     adsp_ppp_sess->~dsd_ppp_session();

     // Inform WSP about session termination.
     m_htun_session_end(adsl_tc, 0);

-    // Free session resources.
-    m_htun_free_resources(adsl_tc);
-
     return;
 }

 static void m_log_ppp_warning(dsd_ppp_server_1* adsp_ppp_svr, char* achp_message)
 {
     // Report PPP server warning.
-    m_htun_warning((dsd_tun_contr1*)(adsp_ppp_svr->vpc_handle), BASE_ERR_NUMBER + 0, achp_message);
+    dsd_ppp_session* ads_ppp_se = ((dsd_ppp_session*)(((dsd_htun_handle*)(adsp_ppp_svr->vpc_handle))->vpc_contr));
+    m_htun_warning(ads_ppp_se->adsc_tun_contr_conn, ads_ppp_se->adsc_tun_contr_ineta,
+       BASE_ERR_NUMBER + 0, achp_message);
     return;
-}
\ No newline at end of file
+}
Index: comp-LINUX-nbipgw19-tun1
===================================================================
--- comp-LINUX-nbipgw19-tun1	(revision 0)
+++ comp-LINUX-nbipgw19-tun1	(revision 6)
@@ -0,0 +1,5 @@
+g++ -m32 -g -c -Wno-write-strings -I. -DHL_UNIX -DHL_LINUX -DD_INCL_HOB_TUN -DTRACEHL1 nbipgw19.cpp -o nbipgw19.o
+g++ -m32 -g -c -Wno-write-strings -I. -DHL_UNIX xslunic1.cpp -o xslunic1.o
+g++ -m32 -g -c -Wno-write-strings -I. -DHL_UNIX -DTRACEHL1 nsl-tcpcomp-singthr.cpp -o nsl-tcpcomp-singthr.o
+g++ -m32 -g -c -Wno-write-strings -I. -DHL_UNIX xs-encry-1.c -o xs-encry-1.o
+g++ -m32 -g -L/usr/local/lib32 -lrt nbipgw19.o xslunic1.o nsl-tcpcomp-singthr.o xs-encry-1.o -o nbipgw19
Index: xstuntapif.cpp
===================================================================
--- xstuntapif.cpp	(revision 2)
+++ xstuntapif.cpp	(revision 6)
@@ -12,9 +12,9 @@
 /*|                                                                   |*/
 /*+-------------------------------------------------------------------+*/

-#include "hob-tuntapif01.h"
 #include <stdlib.h>
-#if defined HL_LINUX
+#if defined HL_UNIX
+#include "hob-unix01.h"
 #include <stdio.h>
 #include <string.h>
 #include <errno.h>
@@ -25,6 +25,8 @@
 #include <linux/if_tun.h>
 #endif

+#include "hob-tuntapif01.h"
+
 #include <string>

 static const int MAX_ERR_STRING   = 1024;
@@ -32,7 +34,7 @@
 static int im_retval;
 static char str_tun_last_err[MAX_ERR_STRING] = "";

-#if defined WIN32 || WIN64
+#if defined WIN32 || defined WIN64

 static const char ADAPTER_KEY[]   = "SYSTEM\\CurrentControlSet\\Control\\Class\\{4D36E972-E325-11CE-BFC1-08002BE10318}";
 static const int MAX_REG_STRING   = 1024;
@@ -46,8 +48,12 @@
 static HANDLE a_ev_read = CreateEvent(NULL, FALSE, TRUE, NULL);
 static OVERLAPPED ds_olap_read;

-#endif //defined WIN32 || WIN64
+#endif // defined WIN32 || defined WIN64

+#if not defined WIN32 && not defined WIN64
+TUNHANDLE dsg_tun_hdl = 0;
+#endif
+
 extern "C" int m_hl1_printf(char * aptext, ... );

 #if defined WIN32 || WIN64
@@ -354,7 +360,7 @@
          }
       }
    }
-#elif defined HL_LINUX
+#elif defined HL_UNIX

    int im_fd;
    char str_openmode[15] = "/dev/net/tun";
@@ -437,7 +443,7 @@
    {  //TUN mode initialization OK
       return 0;
    }
-#elif defined HL_LINUX
+#elif defined HL_UNIX

    struct ifreq ds_ifr;

@@ -454,17 +460,12 @@
 	   return -2;
    }

-   in_addr in_ip;
-   in_addr in_net_mask;
    char str_ip[16];
-   char str_net_mask[16] = "255.255.255.252";
+   inet_ntop(AF_INET, adsp_tun_intf_1->chrc_ineta_locale, str_ip, sizeof(str_ip));
+   char str_net_mask[16];
+   inet_ntop(AF_INET, adsp_tun_intf_1->chrc_netmask_1, str_net_mask, sizeof(str_net_mask));

-   in_ip.s_addr = inet_addr(strp_local_ep);
-   in_net_mask.s_addr = inet_addr("255.255.255.252");
-   strcpy(str_ip, strp_local_ep);
-
    char str_command[128];
-
    snprintf(str_command,
 		   sizeof(str_command),
 		   "%s %s %s %s %s",
@@ -516,7 +517,7 @@
    {
       return 0;
    }
-#elif defined HL_LINUX
+#elif defined HL_UNIX
    return 0;
 #endif //defined WIN32 || WIN64
 }// m_connect_tun
@@ -582,7 +583,7 @@
          return 0;
       }

-#elif defined HL_LINUX
+#elif defined HL_UNIX

       *aimp_bytes_read = read(ap_tun_dev, aucp_read_buff, imp_buff_len);
       if(*aimp_bytes_read < 0)
@@ -672,7 +673,7 @@
       return -1;
    }

-#elif defined HL_LINUX
+#elif defined HL_UNIX

    *aimp_bytes_written = write(ap_tun_dev, aucp_write_buff, imp_data_len);
    if(*aimp_bytes_written < 0)
@@ -684,9 +685,7 @@
 	   return -1;
    }
    else
-   {
-	   return 0;
-   }
+           return 0;

 #endif //defined WIN32 || WIN64
 }// m_writeone_blk
@@ -709,7 +708,7 @@
       return -1;
    }

-#elif defined HL_LINUX
+#elif defined HL_UNIX

    im_retval = close(ap_tun_dev);
    if(im_retval < 0)
@@ -750,7 +749,7 @@
    if (chl_a == 0 || chl_a == 3)
        return FALSE;

-   *(DWORD*)achp_remote = *(DWORD*)achp_local;
+   *(long*)achp_remote = *(long*)achp_local;
    achp_remote[3] ^= 3;
    return TRUE;
 }
@@ -761,56 +760,109 @@

 dsd_vnic::dsd_vnic()
 {
+#if defined WIN32 || defined WIN64
     ads_win_intf = new dsd_win_intf;
+#endif
 } // dsd_vnic()

 dsd_vnic::~dsd_vnic()
 {
+#if defined WIN32 || defined WIN64
     delete ads_win_intf;
+#endif
 } // ~dsd_vnic

 // Initializes the adapter
 bool dsd_vnic::m_init(char* astr_vnic_ip_one, char* astr_vnic_ip_two,
     char* astr_vnic_mask, bool bo_need_sr)
 {
-    bool bo_ret = false;
+    bool bo_ret = true;

+#if defined WIN32 || defined WIN64
     bo_ret = ads_win_intf->m_init(astr_vnic_ip_one, astr_vnic_mask, false);
+#else
+    dsd_tun_intf_1 ds_tun_intf;
+    ds_tun_intf.dsc_tunhandle = 0;

+    in_addr ds_vnic_ip_one;
+    memset(&ds_vnic_ip_one, 0, sizeof(ds_vnic_ip_one));
+    inet_pton(AF_INET, astr_vnic_ip_one, &ds_vnic_ip_one);
+    memcpy(ds_tun_intf.chrc_ineta_locale, &(ds_vnic_ip_one.s_addr),
+        sizeof(ds_tun_intf.chrc_ineta_locale));
+
+    in_addr ds_vnic_mask;
+    memset(&ds_vnic_mask, 0, sizeof(ds_vnic_mask));
+    inet_pton(AF_INET, astr_vnic_mask, &ds_vnic_mask);
+    memcpy(ds_tun_intf.chrc_netmask_1, &(ds_vnic_mask.s_addr), sizeof(ds_tun_intf.chrc_netmask_1));
+
+    if(m_open_tun(&(ds_tun_intf.dsc_tunhandle), NULL, 0) != 0)
+        bo_ret = false;
+    if(bo_ret)
+    {
+        if(m_init_tun(&ds_tun_intf) != 0)
+            bo_ret = false;
+    }
+
+    if(bo_ret)
+        dsg_tun_hdl = ds_tun_intf.dsc_tunhandle;
+#endif
     return bo_ret;
 } // m_init

-int dsd_vnic::m_read(byte* aby_buff, uint32 um_max_read_size, uint32 &um_bytes_read)
+int dsd_vnic::m_read(byte* aby_buff, uint32_t um_max_read_size, uint32_t &um_bytes_read)
 {
     int im_ret = 0;
-   
+
     if (aby_buff)
     {
+#if defined WIN32 || defined WIN64
         im_ret = ads_win_intf->m_read(aby_buff, um_max_read_size, um_bytes_read);
+#else
+        int32_t im_bytes_read = 0;
+        im_ret = m_readone_blk(dsg_tun_hdl, aby_buff, um_max_read_size, NULL, &im_bytes_read);
+        if(im_ret == 0)
+            um_bytes_read = im_bytes_read;
+#endif
     }

     return im_ret;
 } // m_read

-void dsd_vnic::m_read_ex(byte* aby_buff, uint32 um_buff_size, uint32& um_bytes_read,
+void dsd_vnic::m_read_ex(byte* aby_buff, uint32_t um_buff_size, uint32_t& um_bytes_read,
     HANDLE& a_read_handle)
 {
     if (aby_buff)
+    {
+#if defined WIN32 || defined WIN64
         ads_win_intf->m_read_ex(aby_buff, um_buff_size, um_bytes_read, a_read_handle);
+#endif
+    }
 } // m_read_ex

-int dsd_vnic::m_get_read_ex_result(int im_wait_for_multiple_objects_result, uint32& um_bytes_read)
+int dsd_vnic::m_get_read_ex_result(int im_wait_for_multiple_objects_result, uint32_t& um_bytes_read)
 {
+#if defined WIN32 || defined WIN64
     return ads_win_intf->m_get_read_ex_result(im_wait_for_multiple_objects_result, um_bytes_read);
+#else
+    return 0;
+#endif
 } // m_get_read_ex_result

-int dsd_vnic::m_write(byte* aby_buff, uint32 um_buf_size, uint32 &um_bytes_written)
+
+int dsd_vnic::m_write(byte* aby_buff, uint32_t um_buf_size, uint32_t &um_bytes_written)
 {
     int im_ret = 0;

     if (aby_buff)
     {
+#if defined WIN32 || defined WIN64
         im_ret = ads_win_intf->m_write(aby_buff, um_buf_size, um_bytes_written);
+#else
+        int32_t im_bytes_written = 0;
+        im_ret = m_writeone_blk(dsg_tun_hdl, aby_buff, um_buf_size, NULL, &im_bytes_written);
+        if(im_ret == 0)
+            um_bytes_written = im_bytes_written;
+#endif
     }

     return im_ret;
@@ -822,7 +874,15 @@

     if (ads_vector)
     {
+#if defined WIN32 || defined WIN64
         im_ret = ads_win_intf->m_write(ads_vector, im_count);
+#else
+        im_ret = writev(dsg_tun_hdl, (iovec*)ads_vector, im_count);
+        if (im_ret == 0 || im_ret == -1)
+            im_ret = -1;
+        else
+            im_ret = 0;
+#endif
     }

     return im_ret;
@@ -842,29 +902,29 @@
     return astr;
 } // m_get_devname

-uint32 dsd_vnic::m_get_if_index()
+uint32_t dsd_vnic::m_get_if_index()
 {
-    uint32 um_ret = 0;
-
+    uint32_t um_ret = 0;
+#if defined WIN32 || defined WIN64
     um_ret = ads_win_intf->m_get_if_index(ads_win_intf->um_ip);
-
+#endif
     return um_ret;
 } // m_get_if_index


-dsd_hobsrhlp_proc* dsd_vnic::m_get_prochlp()
-{
-    dsd_hobsrhlp_proc* ads_ret = NULL;
+// dsd_hobsrhlp_proc* dsd_vnic::m_get_prochlp()
+// {
+//     dsd_hobsrhlp_proc* ads_ret = NULL;

-    return ads_ret;
-} // m_get_prochlp
+//     return ads_ret;
+// } // m_get_prochlp

-dsd_tun_info* dsd_vnic::m_get_tun_info()
-{
-    dsd_tun_info* ads_ret = NULL;
+// dsd_tun_info* dsd_vnic::m_get_tun_info()
+// {
+//     dsd_tun_info* ads_ret = NULL;

-    return ads_ret;
-}
+//     return ads_ret;
+// }

 bool dsd_vnic::m_add_static_route(char* ach_intranet, char* ach_mask, bool bo_single,
     char* ach_proxy_gw)
@@ -873,7 +933,9 @@

     if (ach_intranet && ach_mask)
     {
+#if defined WIN32 || defined WIN64
         bo_ret = ads_win_intf->m_add_static_route(ach_intranet, ach_mask, bo_single, ach_proxy_gw);
+#endif
     }

     return bo_ret;
@@ -886,8 +948,10 @@

     if (ach_ip && ach_mask)
     {
+#if defined WIN32 || defined WIN64
         bo_ret = ads_win_intf->m_remove_static_route(ach_ip, ach_mask, bo_single, ach_proxy_gw,
             bo_del_route);
+#endif
     }

     return bo_ret;
@@ -898,10 +962,12 @@
     char chr_addr[16] = { 0 };
     in_addr ds_addr;
     char* ach_addr;
-    ds_addr.s_addr = *(DWORD*)ach_ineta;
+    ds_addr.s_addr = *(long*)ach_ineta;
     ach_addr = inet_ntoa(ds_addr);
     memcpy(chr_addr, ach_addr, 16);
+#if defined WIN32 || defined WIN64
     ads_win_intf->m_add_arp_entry(chr_addr, ach_mask);
+#endif
 } // m_add_arp_entry

 void dsd_vnic::m_remove_arp_entry(char* ach_ineta, char* ach_mask)
@@ -909,26 +975,35 @@
     char chr_addr[16] = { 0 };
     in_addr ds_addr;
     char* ach_addr;
-    ds_addr.s_addr = *(DWORD*)ach_ineta;
+    ds_addr.s_addr = *(long*)ach_ineta;
     ach_addr = inet_ntoa(ds_addr);
     memcpy(chr_addr, ach_addr, 16);
+#if defined WIN32 || defined WIN64
     ads_win_intf->m_remove_proxy_arp(chr_addr, ach_mask);
+#endif
 } // m_remove_arp_entry

 void dsd_vnic::m_terminating()
 {
+#if defined WIN32 || defined WIN64
     ads_win_intf->m_terminating();
+#endif
 } // m_terminating

 char* dsd_vnic::m_get_last_error()
 {
+#if defined WIN32 || defined WIN64
     return ads_win_intf->astr_last_err;
+#else
+    return ""; // TODO
+#endif
 } // m_get_last_error

 void dsd_vnic::m_destroy()
 {
 }

+#if defined WIN32 || defined WIN64
 dsd_win_intf::dsd_win_intf()
 {
     a_cancel_event = CreateEventA(NULL, TRUE, FALSE, NULL);
@@ -1082,7 +1157,7 @@
 } // m_get_guid

 HRESULT dsd_win_intf::m_assign_vnic_static_ip(char* ach_guid, char* ach_ip,
-    char* ach_mask, uint32 um_tries, uint32 um_wait)
+    char* ach_mask, uint32_t um_tries, uint32_t um_wait)
 {
     // netsh interface ip set address "<Connection Name>" static <ip> <mask>
     // netsh interface ip delete dns "<Connection Name>" all
@@ -1099,7 +1174,7 @@

     HKEY hConnKey;
     LONG il_ret;
-    uint32 um_tries_left;
+    uint32_t um_tries_left;
     ulong ul_conn_name_buf_size = 0;

     char chr_guid_str[64] = {0};
@@ -1152,7 +1227,7 @@

     if (il_ret == ERROR_SUCCESS)
     {
-        uint32 um_size;
+        uint32_t um_size;
         char* ach_buf;

         um_size = 128 + (int)strlen(chr_conn_name);
@@ -1197,8 +1272,8 @@
 {
     bool bo_ret = false;

-    uint32 um_flags = FILE_ATTRIBUTE_SYSTEM | FILE_FLAG_OVERLAPPED;
-    uint32 um_attr = GENERIC_READ | GENERIC_WRITE;
+    uint32_t um_flags = FILE_ATTRIBUTE_SYSTEM | FILE_FLAG_OVERLAPPED;
+    uint32_t um_attr = GENERIC_READ | GENERIC_WRITE;

     vnic_handle = CreateFileA("\\\\.\\Global\\hobtun", um_attr, FILE_SHARE_READ, 0, OPEN_EXISTING,
         um_flags, 0);
@@ -1234,10 +1309,10 @@
     return bo_ret;
 } // m_close

-int dsd_win_intf::m_read(byte* aby_buff, uint32 um_buff_size, uint32& um_bytes_read)
+int dsd_win_intf::m_read(byte* aby_buff, uint32_t um_buff_size, uint32_t& um_bytes_read)
 {
     int im_ret = 0;
-    uint32 um_reset = 0;
+    uint32_t um_reset = 0;

     ds_read.Offset = 0;
     ds_read.OffsetHigh = 0;
@@ -1249,7 +1324,7 @@

     if (im_ret <= 0)
     {
-        uint32 um_err = GetLastError();
+        uint32_t um_err = GetLastError();

         if (um_err == ERROR_IO_PENDING)
         {
@@ -1293,7 +1368,7 @@

 // Allows an application to do the WaitForMutlipleObjects() itself.
 // Called m_get_read_ex_result() after WaitForMutlipleObjects() returns.
-void dsd_win_intf::m_read_ex(byte* aby_buff, uint32 um_buff_size, uint32& um_bytes_read,
+void dsd_win_intf::m_read_ex(byte* aby_buff, uint32_t um_buff_size, uint32_t& um_bytes_read,
     HANDLE& a_read_handle)
 {
     // Set to 0 to indicate if data was available.
@@ -1315,7 +1390,7 @@

 // Processes input after WaitForMultipleObjects().
 int dsd_win_intf::m_get_read_ex_result(int im_wait_for_multiple_objects_result,
-    uint32& um_bytes_read)
+    uint32_t& um_bytes_read)
 {
     int im_ret = 0;
     um_bytes_read = 0;
@@ -1341,7 +1416,7 @@
 } // m_get_read_result

 // Writes an IP packet to the TUN adapter
-int dsd_win_intf::m_write(byte* aby_buff, uint32 um_buff_size, uint32& im_bytes_written)
+int dsd_win_intf::m_write(byte* aby_buff, uint32_t um_buff_size, uint32_t& im_bytes_written)
 {
     int im_ret = 0;

@@ -1442,7 +1517,7 @@
     assert(ie_type == ied_et_ip || ie_type == ied_et_sn);

     char chr_ineta[4];
-    uint32 um_temp = inet_addr(ach_intranet);
+    uint32_t um_temp = inet_addr(ach_intranet);
     memcpy(chr_ineta, &um_temp, 4);

     char chr_mask[4];
@@ -1485,7 +1560,7 @@
     memset(&ds_add_endpt, 0, sizeof(dsd_vnic_add_endpt));

     char chr_ineta[4];
-    uint32 um_temp = inet_addr(ach_intranet);
+    uint32_t um_temp = inet_addr(ach_intranet);
     memcpy(chr_ineta, &um_temp, 4);

     char chr_mask[4];
@@ -1518,8 +1593,8 @@
     in_addr ds_next_hop;
     ds_next_hop.s_addr = um_ip;

-    uint32 um_dest = inet_addr(ach_intranet);
-    uint32 um_mask = inet_addr(ach_mask);
+    uint32_t um_dest = inet_addr(ach_intranet);
+    uint32_t um_mask = inet_addr(ach_mask);
    
     // This is done to avoid the application from outputting the "Ok!" from the
     // route command. route is used as CreateIpForwardEntry() doesn't properly
@@ -1564,7 +1639,7 @@

         // VPNv2 also needs an extra ARP entry (see ticket 21631). Since VPNv2 does know know the
         // address of the adapter attached to the intranet, some extra work has to be done.
-        uint32 um_proxy_if_index = 0;
+        uint32_t um_proxy_if_index = 0;
         char chr_proxy_adapter[16] = {0};

         if (!ach_proxy_gw)
@@ -1620,8 +1695,8 @@
     in_addr ds_next_hop;
     ds_next_hop.s_addr = um_ip;

-    uint32 um_dest = inet_addr(ach_intranet);
-    uint32 um_mask = inet_addr(ach_mask);
+    uint32_t um_dest = inet_addr(ach_intranet);
+    uint32_t um_mask = inet_addr(ach_mask);

     // This is done to avoid the application from outputting the "Ok!" from the
     // route command. route is used as CreateIpForwardEntry() doesn't properly
@@ -1659,7 +1734,7 @@

     if (bo_ret)
     {
-        uint32 um_proxy_if_index = 0;
+        uint32_t um_proxy_if_index = 0;
         char chr_proxy_adapter[16] = {0};

         if (!ach_proxy_gw)
@@ -1736,11 +1811,11 @@
     return true;
 } // m_get_vnic_mac

-uint32 dsd_win_intf::m_get_if_index(uint32 um_if_ip)
+uint32_t dsd_win_intf::m_get_if_index(uint32_t um_if_ip)
 {
     bool bo_found = false;
-    uint32 um_ret = 0;
-    uint32 um_tries  = 0;
+    uint32_t um_ret = 0;
+    uint32_t um_tries  = 0;
     ULONG ul_size = 0;
     PMIB_IPADDRTABLE ads_net_table = NULL;
     PMIB_IPADDRROW ads_row = NULL;
@@ -1804,7 +1879,7 @@
     im_num_adps = (buf_len / sizeof(IP_ADAPTER_INFO)) + 1;
     ads_adp_info = new IP_ADAPTER_INFO[im_num_adps];

-    uint32 um_intra = inet_addr(ach_intranet) & inet_addr(ach_mask);
+    uint32_t um_intra = inet_addr(ach_intranet) & inet_addr(ach_mask);

     if (GetAdaptersInfo(ads_adp_info, &buf_len) == NO_ERROR)
     {
@@ -1815,7 +1890,7 @@
             PIP_ADDR_STRING ads_ip_str = &ads->IpAddressList;
             while (ads_ip_str)
             {
-                uint32 um_adp_intra = inet_addr(ads_ip_str->IpAddress.String) & inet_addr(ach_mask);
+                uint32_t um_adp_intra = inet_addr(ads_ip_str->IpAddress.String) & inet_addr(ach_mask);

                 if (um_adp_intra == um_intra)
                 {
@@ -1848,8 +1923,8 @@

 void dsd_win_intf::m_add_arp_entry(char* ach_ip, char* ach_mask)
 {
-    uint32 um_dest = inet_addr(ach_ip);
-    uint32 um_mask = inet_addr(ach_mask);
+    uint32_t um_dest = inet_addr(ach_ip);
+    uint32_t um_mask = inet_addr(ach_mask);

     byte byr_vnic_mac[6];
     if (m_get_vnic_mac(byr_vnic_mac))
@@ -1862,8 +1937,8 @@

 void dsd_win_intf::m_remove_proxy_arp(char* ach_ip, char* ach_mask)
 {
-    uint32 um_dest = inet_addr(ach_ip);
-    uint32 um_mask = inet_addr(ach_mask);
+    uint32_t um_dest = inet_addr(ach_ip);
+    uint32_t um_mask = inet_addr(ach_mask);

     byte byr_vnic_mac[6];
     if (m_get_vnic_mac(byr_vnic_mac))
@@ -1873,4 +1948,4 @@
         m_del_arp_endpt(ie_type, ach_ip, ach_mask, byr_vnic_mac);
     }
 } // m_remove_proxy_arp
-
+#endif
Index: SOFTWARE.HLSEC.WSPADM2.act.txt
===================================================================
--- SOFTWARE.HLSEC.WSPADM2.act.txt	(revision 0)
+++ SOFTWARE.HLSEC.WSPADM2.act.txt	(revision 6)
@@ -0,0 +1,82 @@
+
+
+
+
+
+
+         Administration in HOB WebSecureProxy
+
+         over HTML (aux), SNMP, Pipe
+
+         A Pipe may be used from a WMI Provider
+
+         1. Data to be retrieved:
+
+         1.1. Open Ports
+
+         1.2. Open Connections
+         search with userid und user-group, also with wildcard
+
+         1.3. Users currently signed on
+
+         1.4. Used Resources of the Process
+
+         1.5. Log
+
+         1.6. Cluster, State of other WSPs
+
+         1.7. Information from Background-Tasks (Name)
+
+         Backgroud-Tasks
+
+         Redirect new Console Messages to some target
+
+         2. Format of Data Exchanged
+
+         As data is exchanged over a pipe, this is similar to a TCP
+         connection, and certain rules have to be followed.
+         All strings are exchanged as UTF-8.
+         Care has to be taken, since structures exchanged contain little
+         or big endian data, depending on the machine type.
+         Since pipes are normally used inside of a single system, it
+         makes no sense to transform data from big to little endian or
+         vice versa.
+         Structure contain data which are aligned some how, depending on
+         the compiler and the memory model used. At the moment, there is
+         no pragma statement used to change the alignment chosen by the
+         default compiler setting.
+         As data are received over a pipe and there may be a misalignment
+         problem, so before accessing data inside of the structures it
+         makes sense to copy the whole structure from the pipe input
+         buffer to some buffer for that structure in the stack of the
+         function used.
+
+         When a client requests some information, it has to send the
+         following data stream:
+
+         NHASN length of total packet not including length
+         NHASN length of following service name, not including length
+         service name, UTF-8
+         NHASN length of following query packet, not including length
+         record type, length one
+         structure with query+
+
+
+
+
+
+         When there is a reply from from the WSP admin module, the
+         following data stream is sent:
+
+         NHASN length of total packet not including length
+         NHASN length of following response packet, not including length
+         record type, length one
+         structure with response
+
+         03.04.08  KB
+         04.04.08  KB
+         07.05.08  KB
+         02.09.08  KB
+         03.09.08  KB+
\ No newline at end of file
Index: xslunic1.cpp
===================================================================
--- xslunic1.cpp	(revision 2)
+++ xslunic1.cpp	(revision 6)
@@ -17,6 +17,7 @@
 /*|  Copyright (C) HOB Germany 2010                                   |*/
 /*|  Copyright (C) HOB Germany 2011                                   |*/
 /*|  Copyright (C) HOB Germany 2012                                   |*/
+/*|  Copyright (C) HOB Germany 2013                                   |*/
 /*|                                                                   |*/
 /*| REQUIRED PROGRAMS:                                                |*/
 /*| ------------------                                                |*/
@@ -99,6 +100,7 @@
 /** @defgroup unicode Character and string processing in different encodings.
 * @{
 */
+#define IDNACMP_WORKAROUND20121112

 #define MAX_NO_WILDCARD 16                  /* maximum number of wildcard characters */

@@ -7338,6 +7340,10 @@
    achl_end_p1 = NULL;                      /* still zero-terminated   */
    if (imp_len_p1 >= 0) {                   /* length p1 given         */
      switch (iep_cs_p1) {
+#ifdef IDNACMP_WORKAROUND20121112
+       case ied_chs_idna_1:                 /* IDNA RFC 3490 - Punycode */
+         iep_cs_p1 = ied_chs_ascii_850;     /* and fall through        */
+#endif
        case ied_chs_ascii_850:              /* ASCII 850               */
        case ied_chs_ansi_819:               /* ANSI 819                */
        case ied_chs_oem_437:                /* DOS-Codepage 437        */
@@ -7385,12 +7391,21 @@
        default:
          return FALSE;                      /* cannot compare          */
      }
+#ifdef IDNACMP_WORKAROUND20121112
+   } else {
+     if (iep_cs_p1 == ied_chs_idna_1)       /* IDNA RFC 3490 - Punycode */
+         iep_cs_p1 = ied_chs_ascii_850;
+#endif
    }
    /* calculate end of parameter 2                                     */
    achl_cur_p2 = (char *) ap_p2;
    achl_end_p2 = NULL;                      /* still zero-terminated   */
    if (imp_len_p2 >= 0) {                   /* length p2 given         */
      switch (iep_cs_p2) {
+#ifdef IDNACMP_WORKAROUND20121112
+       case ied_chs_idna_1:                 /* IDNA RFC 3490 - Punycode */
+         iep_cs_p2 = ied_chs_ascii_850;     /* and fall through        */
+#endif
        case ied_chs_ascii_850:              /* ASCII 850               */
        case ied_chs_ansi_819:               /* ANSI 819                */
        case ied_chs_oem_437:                /* DOS-Codepage 437        */
@@ -7438,6 +7453,11 @@
        default:
          return FALSE;                      /* cannot compare          */
      }
+#ifdef IDNACMP_WORKAROUND20121112
+   } else {
+     if (iep_cs_p2 == ied_chs_idna_1)       /* IDNA RFC 3490 - Punycode */
+         iep_cs_p2 = ied_chs_ascii_850;
+#endif
    }

    pcmp_00:                                 /* compare characters      */
@@ -7543,6 +7563,10 @@
    achl_end_p1 = NULL;                      /* still zero-terminated   */
    if (imp_len_p1 >= 0) {                   /* length p1 given         */
      switch (iep_cs_p1) {
+#ifdef IDNACMP_WORKAROUND20121112
+       case ied_chs_idna_1:                 /* IDNA RFC 3490 - Punycode */
+         iep_cs_p1 = ied_chs_ascii_850;     /* and fall through        */
+#endif
        case ied_chs_ascii_850:              /* ASCII 850               */
        case ied_chs_ansi_819:               /* ANSI 819                */
        case ied_chs_oem_437:                /* DOS-Codepage 437        */
@@ -7590,12 +7614,21 @@
        default:
          return FALSE;                      /* cannot compare          */
      }
+#ifdef IDNACMP_WORKAROUND20121112
+   } else {
+     if (iep_cs_p1 == ied_chs_idna_1)       /* IDNA RFC 3490 - Punycode */
+         iep_cs_p1 = ied_chs_ascii_850;
+#endif
    }
    /* calculate end of parameter 2                                     */
    achl_cur_p2 = (char *) ap_p2;
    achl_end_p2 = NULL;                      /* still zero-terminated   */
    if (imp_len_p2 >= 0) {                   /* length p2 given         */
      switch (iep_cs_p2) {
+#ifdef IDNACMP_WORKAROUND20121112
+       case ied_chs_idna_1:                 /* IDNA RFC 3490 - Punycode */
+         iep_cs_p2 = ied_chs_ascii_850;     /* and fall through        */
+#endif
        case ied_chs_ascii_850:              /* ASCII 850               */
        case ied_chs_ansi_819:               /* ANSI 819                */
        case ied_chs_oem_437:                /* DOS-Codepage 437        */
@@ -7643,6 +7676,11 @@
        default:
          return FALSE;                      /* cannot compare          */
      }
+#ifdef IDNACMP_WORKAROUND20121112
+   } else {
+     if (iep_cs_p2 == ied_chs_idna_1)       /* IDNA RFC 3490 - Punycode */
+         iep_cs_p2 = ied_chs_ascii_850;
+#endif
    }

    pcmp_00:                                 /* compare characters      */
@@ -7753,6 +7791,10 @@
    achl_end_p1 = NULL;                      /* still zero-terminated   */
    if (imp_len_p1 >= 0) {                   /* length p1 given         */
      switch (iep_cs_p1) {
+#ifdef IDNACMP_WORKAROUND20121112
+       case ied_chs_idna_1:                 /* IDNA RFC 3490 - Punycode */
+         iep_cs_p1 = ied_chs_ascii_850;     /* and fall through        */
+#endif
        case ied_chs_ascii_850:              /* ASCII 850               */
        case ied_chs_ansi_819:               /* ANSI 819                */
        case ied_chs_oem_437:                /* DOS-Codepage 437        */
@@ -7800,6 +7842,11 @@
        default:
          return FALSE;                      /* cannot compare          */
      }
+#ifdef IDNACMP_WORKAROUND20121112
+   } else {
+     if (iep_cs_p1 == ied_chs_idna_1)       /* IDNA RFC 3490 - Punycode */
+         iep_cs_p1 = ied_chs_ascii_850;
+#endif
    }
    /* calculate end of parameter 2                                     */
    achl_cur_p2 = (char *) ap_p2;
@@ -8326,6 +8373,13 @@
    }
 } /* end m_idna_add_to_treelist()                                      */

+/* When giving ied_chs_idna_1 as target charset to m_cpy_vx_vx, m_cpy_lc_vx_vx
+   or m_len_vx_vx, as a special feature it will accept any string (e.g. an IPv6
+   address) that does not contain any character above 'z' like simple 819 input,
+   if an IDNA-prohibited char (e.g. ':') is among the first MAX_IDNAPART_LENGTH.
+*/
+#define IED_CHS_COPY7A ied_chs_invalid
+
 /**
 * copy source string to target
 *  @param ap_target destination (output) pointer
@@ -8354,6 +8408,7 @@
    unsigned char utl_idna_openzwnj;         /* U+200C yet to be accepted (RFC 5892 A.1.) */
    /* variables for tests required for IDNA target by RFC 5891 5.4.    */
    int           iel_idna_minuspair;        /* detect labels starting with "..--" */
+   BOOL          bol_idna_nohighyet;        /* only <='z' in all labels so far */
    int           inl_idna_prevccc;          /* canonical combining class */
    unsigned int  unl_prevstrt;              /* last char with ccc == 0 */

@@ -8412,6 +8467,7 @@
        iml_idna_labelspace = 1+MAX_IDNAPART_LENGTH;
        utl_idna_openzwnj = 0;        /* =none, at 0 would not be legal */
        iel_idna_minuspair = 0;
+       bol_idna_nohighyet = TRUE;
        inl_idna_prevccc = 255;
        unl_prevstrt = 0;
        utl_idna_tn = 0;
@@ -8515,6 +8571,7 @@
              if ((achl_cur_target == NULL) || (achl_cur_target >= achl_end_target))
                return -1;                   /* target overflow         */
            }                                /* fall through            */
+         case IED_CHS_COPY7A:               /* idna-prohibited ascii   */
          case ied_chs_ascii_850:            /* ASCII 850               */
          case ied_chs_ansi_819:             /* ANSI 819                */
          case ied_chs_oem_437:              /* DOS-Codepage 437        */
@@ -8821,6 +8878,11 @@
              *achl_cur_target++ = (unsigned char) uml_ch_source;
              break;
            }
+           if (bol_idna_nohighyet) {        /* permit IPv6 addresses etc. */
+             *achl_cur_target++ = (unsigned char) uml_ch_source;
+             iep_cs_target = IED_CHS_COPY7A;
+             break;
+           }
            return -1;                       /* prohibited ASCII char   */
          } else {
            if (uml_ch_source == 0x2D) {     /* hyphen-minus, unchanged */
@@ -8844,6 +8906,11 @@
            if (uml_ch_source == 0x2E) {     /* dot, begin new part     */
              goto p_next_idnlbl;
            }
+           if (bol_idna_nohighyet) {        /* permit IPv6 addresses etc. */
+             *achl_cur_target++ = (unsigned char) uml_ch_source;
+             iep_cs_target = IED_CHS_COPY7A;
+             break;
+           }
            return -1;                       /* prohibited ASCII char   */
          }
        } else {                             /* not an unchanged char   */
@@ -8900,6 +8967,7 @@
        if ((iml_idna_labelspace==MAX_IDNAPART_LENGTH) && m_get_unicode_is_combining(uml_ch_source))
          return -1;                         /* combining mark as first in label */
        if (!utl_idna_tn) {                  /* first non-ASCII in this part*/
+         bol_idna_nohighyet = FALSE;
          if (achl_cur_target+5 >= achl_end_target)
            return -1;                       /* output area too small   */
          /* prepend prefix to what we already have translated to ASCII */
@@ -8934,6 +9002,12 @@
        unl_prevstrt = 0;
        utl_idna_tn = 0;
        break;
+     case IED_CHS_COPY7A:                   /* idna-prohibited ascii   */
+       if (uml_ch_source > 'z')
+         return -1;  /* neither IDNA nor something like a IPv6-address */
+       *((unsigned char *) achl_cur_target) = (unsigned char) uml_ch_source;
+       achl_cur_target++;                   /* output one character    */
+       break;
      case ied_chs_utf_16:                   /* Unicode UTF-16 = WCHAR  */
        if (uml_ch_source >= 0X10000) {      /* over 16-bit, needs surrogates */
          uml_ch_source -= 0X10000;
@@ -9032,6 +9106,7 @@
    unsigned char utl_idna_openzwnj;         /* U+200C yet to be accepted (RFC 5892 A.1.) */
    /* variables for tests required for IDNA target by RFC 5891 5.4.    */
    int           iel_idna_minuspair;        /* detect labels starting with "..--" */
+   BOOL          bol_idna_nohighyet;        /* only <='z' in all labels so far */
    int           inl_idna_prevccc;          /* canonical combining class */
    unsigned int  unl_prevstrt;              /* last char with ccc == 0 */

@@ -9090,6 +9165,7 @@
        iml_idna_labelspace = 1+MAX_IDNAPART_LENGTH;
        utl_idna_openzwnj = 0;        /* =none, at 0 would not be legal */
        iel_idna_minuspair = 0;
+       bol_idna_nohighyet = TRUE;
        inl_idna_prevccc = 255;
        unl_prevstrt = 0;
        utl_idna_tn = 0;
@@ -9193,6 +9269,7 @@
              if ((achl_cur_target == NULL) || (achl_cur_target >= achl_end_target))
                return -1;                   /* target overflow         */
            }                                /* fall through            */
+         case IED_CHS_COPY7A:               /* idna-prohibited ascii   */
          case ied_chs_ascii_850:            /* ASCII 850               */
          case ied_chs_ansi_819:             /* ANSI 819                */
          case ied_chs_oem_437:              /* DOS-Codepage 437        */
@@ -9500,6 +9577,11 @@
              *achl_cur_target++ = (unsigned char) uml_ch_source;
              break;
            }
+           if (bol_idna_nohighyet) {        /* permit IPv6 addresses etc. */
+             *achl_cur_target++ = (unsigned char) uml_ch_source;
+             iep_cs_target = IED_CHS_COPY7A;
+             break;
+           }
            return -1;                       /* prohibited ASCII char   */
          } else {
            if (uml_ch_source == 0x2D) {     /* hyphen-minus, unchanged */
@@ -9523,6 +9605,11 @@
            if (uml_ch_source == 0x2E) {     /* dot, begin new part     */
              goto p_next_idnlbl;
            }
+           if (bol_idna_nohighyet) {        /* permit IPv6 addresses etc. */
+             *achl_cur_target++ = (unsigned char) uml_ch_source;
+             iep_cs_target = IED_CHS_COPY7A;
+             break;
+           }
            return -1;                       /* prohibited ASCII char   */
          }
        } else {                             /* not an unchanged char   */
@@ -9579,6 +9666,7 @@
        if ((iml_idna_labelspace==MAX_IDNAPART_LENGTH) && m_get_unicode_is_combining(uml_ch_source))
          return -1;                         /* combining mark as first in label */
        if (!utl_idna_tn) {                  /* first non-ASCII in this part*/
+         bol_idna_nohighyet = FALSE;
          if (achl_cur_target+5 >= achl_end_target)
            return -1;                       /* output area too small   */
          /* prepend prefix to what we already have translated to ASCII */
@@ -9613,6 +9701,12 @@
        unl_prevstrt = 0;
        utl_idna_tn = 0;
        break;
+     case IED_CHS_COPY7A:                   /* idna-prohibited ascii   */
+       if (uml_ch_source > 'z')
+         return -1;  /* neither IDNA nor something like a IPv6-address */
+       *((unsigned char *) achl_cur_target) = (unsigned char) uml_ch_source;
+       achl_cur_target++;                   /* output one character    */
+       break;
      case ied_chs_utf_16:                   /* Unicode UTF-16 = WCHAR  */
        if (uml_ch_source >= 0X10000) {      /* over 16-bit, needs surrogates */
          uml_ch_source -= 0X10000;
@@ -9683,6 +9777,694 @@
    goto pcpy_00;                            /* copy characters         */
 } /* end m_cpy_lc_vx_vx()                                              */

+/** copy string to uppercase                                           */
+extern "C" int m_cpy_uc_vx_vx( void *ap_target, int imp_len_target, enum ied_charset iep_cs_target,
+                               void *ap_source, int imp_len_source, enum ied_charset iep_cs_source ) {
+   BOOL          bol1;                      /* working-variable        */
+   int           iml1;                      /* working-variable        */
+   char          *achl_cur_target, *achl_cur_source;  /* current position parameters */
+   char          *achl_end_target, *achl_end_source;  /* end of parameters */
+   unsigned int  uml_ch_source;             /* character decoded       */
+   int           iml_len_ch_source;         /* length of parameter     */
+   HL_WCHAR      *awcl_dbcsenc;             /* dbcs encoding table     */
+   struct dsd_idna_upoint dslr_idna_treelist[MAX_IDNAPART_LENGTH];  /* non-ascii data */
+   unsigned char utl_idna_tn;               /* length for dsd_idna_upoint */
+   char          *achl_idna_ps;             /* target start of current label */
+   int           iml_idna_labelspace;       /* rest of RFC 1034 maxlen */
+   unsigned char utl_idna_openzwnj;         /* U+200C yet to be accepted (RFC 5892 A.1.) */
+   /* variables for tests required for IDNA target by RFC 5891 5.4.    */
+   int           iel_idna_minuspair;        /* detect labels starting with "..--" */
+   BOOL          bol_idna_nohighyet;        /* only <='z' in all labels so far */
+   int           inl_idna_prevccc;          /* canonical combining class */
+   unsigned int  unl_prevstrt;              /* last char with ccc == 0 */
+
+#ifdef CHECK_HTML
+   int        iml2;                         /* working variable        */
+   iml1 = sizeof(dsrs_sort_html_alpha) / sizeof(dsrs_sort_html_alpha[0]) - 1;
+   do {
+     iml1--;
+     iml2 = strcmp( dsrs_sort_html_alpha[ iml1 ].achc_char,
+                    dsrs_sort_html_alpha[ iml1 + 1 ].achc_char );
+     if (iml2 >= 0) {
+       printf( "xslunic1-l%05d-E invalid sort sequence dsrs_sort_html_alpha element %d.\n",
+               __LINE__, iml1 );
+       return -1;
+     }
+   } while (iml1 > 0);
+#endif
+   if (imp_len_target <= 0) return -1;
+   /* calculate end of parameter target                                */
+   achl_cur_target = (char *) ap_target;
+   switch (iep_cs_target) {
+     case ied_chs_ascii_850:                /* ASCII 850               */
+     case ied_chs_ansi_819:                 /* ANSI 819                */
+     case ied_chs_oem_437:                  /* DOS-Codepage 437        */
+     case ied_chs_wcp_874:                  /* Windows-Codepage  874   */
+     case ied_chs_wcp_1250:                 /* Windows-Codepage 1250   */
+     case ied_chs_wcp_1251:                 /* Windows-Codepage 1251   */
+     case ied_chs_wcp_1252:                 /* Windows-Codepage 1252   */
+     case ied_chs_wcp_1253:                 /* Windows-Codepage 1253   */
+     case ied_chs_wcp_1254:                 /* Windows-Codepage 1254   */
+     case ied_chs_wcp_1255:                 /* Windows-Codepage 1255   */
+     case ied_chs_wcp_1256:                 /* Windows-Codepage 1256   */
+     case ied_chs_wcp_1257:                 /* Windows-Codepage 1257   */
+     case ied_chs_wcp_1258:                 /* Windows-Codepage 1258   */
+     case ied_chs_iso8859_2:                /* ISO 8859-2              */
+     case ied_chs_iso8859_3:                /* ISO 8859-3              */
+     case ied_chs_iso8859_4:                /* ISO 8859-4              */
+     case ied_chs_iso8859_5:                /* ISO 8859-5              */
+     case ied_chs_iso8859_6:                /* ISO 8859-6              */
+     case ied_chs_iso8859_7:                /* ISO 8859-7              */
+     case ied_chs_iso8859_8:                /* ISO 8859-8              */
+     case ied_chs_iso8859_9:                /* ISO 8859-9              */
+     case ied_chs_iso8859_10:               /* ISO 8859-10             */
+     case ied_chs_iso8859_11:               /* ISO 8859-11             */
+     case ied_chs_iso8859_13:               /* ISO 8859-13             */
+     case ied_chs_iso8859_14:               /* ISO 8859-14             */
+     case ied_chs_iso8859_15:               /* ISO 8859-15             */
+     case ied_chs_iso8859_16:               /* ISO 8859-16             */
+     case ied_chs_utf_8:                    /* Unicode UTF-8           */
+     case ied_chs_html_1:                   /* HTML character set      */
+     case ied_chs_uri_1:                    /* URI RFC 3986            */
+       achl_end_target = ((char *) ap_target) + imp_len_target;
+       break;
+     case ied_chs_idna_1:                   /* IDNA RFC 3490 - Punycode */
+       achl_idna_ps = achl_cur_target;
+       iml_idna_labelspace = 1+MAX_IDNAPART_LENGTH;
+       utl_idna_openzwnj = 0;        /* =none, at 0 would not be legal */
+       iel_idna_minuspair = 0;
+       bol_idna_nohighyet = TRUE;
+       inl_idna_prevccc = 255;
+       unl_prevstrt = 0;
+       utl_idna_tn = 0;
+       achl_end_target = ((char *) ap_target) + imp_len_target;
+       break;
+     case ied_chs_wcp_932:                  /* Windows-Codepage 932    */
+     case ied_chs_wcp_936:                  /* Windows-Codepage 936    */
+     case ied_chs_wcp_949:                  /* Windows-Codepage 949    */
+     case ied_chs_wcp_950:                  /* Windows-Codepage 950    */
+       awcl_dbcsenc = m_get_tab_uni_to_mb(iep_cs_target);
+       achl_end_target = ((char *) ap_target) + imp_len_target;
+       break;
+     case ied_chs_utf_16:                   /* Unicode UTF-16 = WCHAR  */
+     case ied_chs_be_utf_16:                /* Unicode UTF-16 big endian */
+     case ied_chs_le_utf_16:                /* Unicode UTF-16 little endian */
+       achl_end_target = ((char *) ap_target) + imp_len_target * sizeof(HL_WCHAR);
+       break;
+     case ied_chs_utf_32:                   /* Unicode UTF-32          */
+     case ied_chs_be_utf_32:                /* Unicode UTF-32 big endian */
+     case ied_chs_le_utf_32:                /* Unicode UTF-32 little endian */
+       achl_end_target = ((char *) ap_target) + imp_len_target * sizeof(unsigned int);
+       break;
+     default:
+       return -1;                           /* cannot copy             */
+   }
+   /* calculate end of parameter source                                */
+   achl_cur_source = (char *) ap_source;
+   achl_end_source = NULL;                  /* still zero-terminated   */
+   if (imp_len_source >= 0) {               /* length source given     */
+     switch (iep_cs_source) {
+       case ied_chs_ascii_850:              /* ASCII 850               */
+       case ied_chs_ansi_819:               /* ANSI 819                */
+       case ied_chs_oem_437:                /* DOS-Codepage 437        */
+       case ied_chs_wcp_874:                /* Windows-Codepage  874   */
+       case ied_chs_wcp_1250:               /* Windows-Codepage 1250   */
+       case ied_chs_wcp_1251:               /* Windows-Codepage 1251   */
+       case ied_chs_wcp_1252:               /* Windows-Codepage 1252   */
+       case ied_chs_wcp_1253:               /* Windows-Codepage 1253   */
+       case ied_chs_wcp_1254:               /* Windows-Codepage 1254   */
+       case ied_chs_wcp_1255:               /* Windows-Codepage 1255   */
+       case ied_chs_wcp_1256:               /* Windows-Codepage 1256   */
+       case ied_chs_wcp_1257:               /* Windows-Codepage 1257   */
+       case ied_chs_wcp_1258:               /* Windows-Codepage 1258   */
+       case ied_chs_wcp_932:                /* Windows-Codepage 932    */
+       case ied_chs_wcp_936:                /* Windows-Codepage 936    */
+       case ied_chs_wcp_949:                /* Windows-Codepage 949    */
+       case ied_chs_wcp_950:                /* Windows-Codepage 950    */
+       case ied_chs_iso8859_2:              /* ISO 8859-2              */
+       case ied_chs_iso8859_3:              /* ISO 8859-3              */
+       case ied_chs_iso8859_4:              /* ISO 8859-4              */
+       case ied_chs_iso8859_5:              /* ISO 8859-5              */
+       case ied_chs_iso8859_6:              /* ISO 8859-6              */
+       case ied_chs_iso8859_7:              /* ISO 8859-7              */
+       case ied_chs_iso8859_8:              /* ISO 8859-8              */
+       case ied_chs_iso8859_9:              /* ISO 8859-9              */
+       case ied_chs_iso8859_10:             /* ISO 8859-10             */
+       case ied_chs_iso8859_11:             /* ISO 8859-11             */
+       case ied_chs_iso8859_13:             /* ISO 8859-13             */
+       case ied_chs_iso8859_14:             /* ISO 8859-14             */
+       case ied_chs_iso8859_15:             /* ISO 8859-15             */
+       case ied_chs_iso8859_16:             /* ISO 8859-16             */
+       case ied_chs_utf_8:                  /* Unicode UTF-8           */
+       case ied_chs_html_1:                 /* HTML character set      */
+       case ied_chs_uri_1:                  /* URI RFC 3986            */
+         achl_end_source = ((char *) ap_source) + imp_len_source;
+         break;
+       case ied_chs_utf_16:                 /* Unicode UTF-16 = WCHAR  */
+       case ied_chs_be_utf_16:              /* Unicode UTF-16 big endian */
+       case ied_chs_le_utf_16:              /* Unicode UTF-16 little endian */
+         achl_end_source = ((char *) ap_source) + imp_len_source * sizeof(HL_WCHAR);
+         break;
+       case ied_chs_utf_32:                 /* Unicode UTF-32          */
+       case ied_chs_be_utf_32:              /* Unicode UTF-32 big endian */
+       case ied_chs_le_utf_32:              /* Unicode UTF-32 little endian */
+         achl_end_source = ((char *) ap_source) + imp_len_source * sizeof(unsigned int);
+         break;
+       default:
+         return -1;                         /* cannot copy             */
+     }
+   }
+
+   pcpy_00:                                 /* copy characters         */
+   iml_len_ch_source = m_get_vc_ch( &uml_ch_source, achl_cur_source, achl_end_source, iep_cs_source );
+   if (iml_len_ch_source <= 0) {            /* subroutine reported end or error */
+     if (iml_len_ch_source == 0) {          /* end of input found      */
+       if (achl_cur_target >= achl_end_target) return -1;  /* output area too short */
+       switch (iep_cs_target) {
+         case ied_chs_idna_1:             /* IDNA RFC 3490 - Punycode */
+           if (utl_idna_tn) {               /* last part had non-ASCII */
+             if (utl_idna_openzwnj &&
+                 !m_idna_zwnj_jtrule_ok( dslr_idna_treelist, utl_idna_openzwnj, utl_idna_tn ))
+               return -1;                   /* earlier U+200C not conforming */
+             /* encode the non-ascii chars of the last part            */
+             achl_cur_target = m_idna_encode_utree( dslr_idna_treelist,
+                               achl_cur_target-(achl_idna_ps+4),
+                               achl_cur_target,
+                               achl_end_target<=achl_idna_ps+MAX_IDNAPART_LENGTH
+                                              ? achl_end_target
+                                              : achl_idna_ps+MAX_IDNAPART_LENGTH
+                               );
+             if ((achl_cur_target == NULL) || (achl_cur_target >= achl_end_target))
+               return -1;                   /* target overflow         */
+           }                                /* fall through            */
+         case IED_CHS_COPY7A:               /* idna-prohibited ascii   */
+         case ied_chs_ascii_850:            /* ASCII 850               */
+         case ied_chs_ansi_819:             /* ANSI 819                */
+         case ied_chs_oem_437:              /* DOS-Codepage 437        */
+         case ied_chs_wcp_874:              /* Windows-Codepage  874   */
+         case ied_chs_wcp_1250:             /* Windows-Codepage 1250   */
+         case ied_chs_wcp_1251:             /* Windows-Codepage 1251   */
+         case ied_chs_wcp_1252:             /* Windows-Codepage 1252   */
+         case ied_chs_wcp_1253:             /* Windows-Codepage 1253   */
+         case ied_chs_wcp_1254:             /* Windows-Codepage 1254   */
+         case ied_chs_wcp_1255:             /* Windows-Codepage 1255   */
+         case ied_chs_wcp_1256:             /* Windows-Codepage 1256   */
+         case ied_chs_wcp_1257:             /* Windows-Codepage 1257   */
+         case ied_chs_wcp_1258:             /* Windows-Codepage 1258   */
+         case ied_chs_wcp_932:              /* Windows-Codepage 932    */
+         case ied_chs_wcp_936:              /* Windows-Codepage 936    */
+         case ied_chs_wcp_949:              /* Windows-Codepage 949    */
+         case ied_chs_wcp_950:              /* Windows-Codepage 950    */
+         case ied_chs_iso8859_2:            /* ISO 8859-2              */
+         case ied_chs_iso8859_3:            /* ISO 8859-3              */
+         case ied_chs_iso8859_4:            /* ISO 8859-4              */
+         case ied_chs_iso8859_5:            /* ISO 8859-5              */
+         case ied_chs_iso8859_6:            /* ISO 8859-6              */
+         case ied_chs_iso8859_7:            /* ISO 8859-7              */
+         case ied_chs_iso8859_8:            /* ISO 8859-8              */
+         case ied_chs_iso8859_9:            /* ISO 8859-9              */
+         case ied_chs_iso8859_10:           /* ISO 8859-10             */
+         case ied_chs_iso8859_11:           /* ISO 8859-11             */
+         case ied_chs_iso8859_13:           /* ISO 8859-13             */
+         case ied_chs_iso8859_14:           /* ISO 8859-14             */
+         case ied_chs_iso8859_15:           /* ISO 8859-15             */
+         case ied_chs_iso8859_16:           /* ISO 8859-16             */
+         case ied_chs_utf_8:                /* Unicode UTF-8           */
+         case ied_chs_html_1:               /* HTML character set      */
+         case ied_chs_uri_1:                /* URI RFC 3986            */
+           *achl_cur_target = 0;            /* make zero-terminated    */
+           return achl_cur_target - (char *) ap_target;
+         case ied_chs_utf_16:               /* Unicode UTF-16 = WCHAR  */
+           *((HL_WCHAR *) achl_cur_target) = 0;  /* make zero-terminated */
+           return (achl_cur_target - (char *) ap_target) / sizeof(HL_WCHAR);
+         case ied_chs_be_utf_16:            /* Unicode UTF-16 big endian */
+           *((char  *) achl_cur_target + 0) = 0;  /* make zero-terminated */
+           *((char  *) achl_cur_target + 1) = 0;  /* make zero-terminated */
+           return (achl_cur_target - (char *) ap_target) / sizeof(HL_WCHAR);
+         case ied_chs_le_utf_16:            /* Unicode UTF-16 little endian */
+           *((char  *) achl_cur_target + 0) = 0;  /* make zero-terminated */
+           *((char  *) achl_cur_target + 1) = 0;  /* make zero-terminated */
+           return (achl_cur_target - (char *) ap_target) / sizeof(HL_WCHAR);
+         case ied_chs_utf_32:               /* Unicode UTF-32          */
+           *((unsigned int *) achl_cur_target) = 0;  /* make zero-terminated */
+           return (achl_cur_target - (char *) ap_target) / sizeof(unsigned int);
+         case ied_chs_be_utf_32:            /* Unicode UTF-32 big endian */
+           *((char  *) achl_cur_target + 0) = 0;  /* make zero-terminated */
+           *((char  *) achl_cur_target + 1) = 0;  /* make zero-terminated */
+           *((char  *) achl_cur_target + 2) = 0;  /* make zero-terminated */
+           *((char  *) achl_cur_target + 3) = 0;  /* make zero-terminated */
+           return (achl_cur_target - (char *) ap_target) / sizeof(unsigned int);
+         case ied_chs_le_utf_32:            /* Unicode UTF-32 little endian */
+           *((char  *) achl_cur_target + 0) = 0;  /* make zero-terminated */
+           *((char  *) achl_cur_target + 1) = 0;  /* make zero-terminated */
+           *((char  *) achl_cur_target + 2) = 0;  /* make zero-terminated */
+           *((char  *) achl_cur_target + 3) = 0;  /* make zero-terminated */
+           return (achl_cur_target - (char *) ap_target) / sizeof(unsigned int);
+         default:
+           return -1;                       /* error                   */
+       }
+     }
+     return -1;                             /* return error            */
+   }
+   if (achl_cur_target >= achl_end_target) return -1;  /* output area too short */
+   uml_ch_source = m_trans_32_to_uc( uml_ch_source );  /* translate to upper case */
+   switch (iep_cs_target) {
+     case ied_chs_ascii_850:                /* ASCII 850               */
+       if (uml_ch_source < 0X0100) {
+         *((unsigned char *) achl_cur_target) = (unsigned char) ucrg_tab_819_to_850[ uml_ch_source ];
+       } else {
+         *achl_cur_target = '?';
+       }
+       achl_cur_target++;                   /* output one character    */
+       break;
+     case ied_chs_ansi_819:                 /* ANSI 819                */
+       if (uml_ch_source < 0X0100) {
+         *((unsigned char *) achl_cur_target) = (unsigned char) uml_ch_source;
+       } else {
+         *achl_cur_target = '?';
+       }
+       achl_cur_target++;                   /* output one character    */
+       break;
+     case ied_chs_oem_437:                  /* DOS-Codepage 437        */
+       *((unsigned char *) achl_cur_target) = (unsigned char) m_u32c_to_437( uml_ch_source );
+       achl_cur_target++;                   /* output one character    */
+       break;
+     case ied_chs_wcp_874:                  /* Windows-Codepage  874   */
+       *((unsigned char *) achl_cur_target) = (unsigned char) m_u32c_to_874( uml_ch_source );
+       achl_cur_target++;                   /* output one character    */
+       break;
+     case ied_chs_wcp_1250:                 /* Windows-Codepage 1250   */
+       *((unsigned char *) achl_cur_target) = (unsigned char) m_u32c_to_1250( uml_ch_source );
+       achl_cur_target++;                   /* output one character    */
+       break;
+     case ied_chs_wcp_1251:                 /* Windows-Codepage 1251   */
+       *((unsigned char *) achl_cur_target) = (unsigned char) m_u32c_to_1251( uml_ch_source );
+       achl_cur_target++;                   /* output one character    */
+       break;
+     case ied_chs_wcp_1252:                 /* Windows-Codepage 1252   */
+       *((unsigned char *) achl_cur_target) = (unsigned char) m_u32c_to_1252( uml_ch_source );
+       achl_cur_target++;                   /* output one character    */
+       break;
+     case ied_chs_wcp_1253:                 /* Windows-Codepage 1253   */
+       *((unsigned char *) achl_cur_target) = (unsigned char) m_u32c_to_1253( uml_ch_source );
+       achl_cur_target++;                   /* output one character    */
+       break;
+     case ied_chs_wcp_1254:                 /* Windows-Codepage 1254   */
+       *((unsigned char *) achl_cur_target) = (unsigned char) m_u32c_to_1254( uml_ch_source );
+       achl_cur_target++;                   /* output one character    */
+       break;
+     case ied_chs_wcp_1255:                 /* Windows-Codepage 1255   */
+       *((unsigned char *) achl_cur_target) = (unsigned char) m_u32c_to_1255( uml_ch_source );
+       achl_cur_target++;                   /* output one character    */
+       break;
+     case ied_chs_wcp_1256:                 /* Windows-Codepage 1256   */
+       *((unsigned char *) achl_cur_target) = (unsigned char) m_u32c_to_1256( uml_ch_source );
+       achl_cur_target++;                   /* output one character    */
+       break;
+     case ied_chs_wcp_1257:                 /* Windows-Codepage 1257   */
+       *((unsigned char *) achl_cur_target) = (unsigned char) m_u32c_to_1257( uml_ch_source );
+       achl_cur_target++;                   /* output one character    */
+       break;
+     case ied_chs_wcp_1258:                 /* Windows-Codepage 1258   */
+       *((unsigned char *) achl_cur_target) = (unsigned char) m_u32c_to_1258( uml_ch_source );
+       achl_cur_target++;                   /* output one character    */
+       break;
+     case ied_chs_iso8859_2:                /* ISO 8859-2 (Latin-2)    */
+       *((unsigned char *) achl_cur_target) = (unsigned char) m_u32c_to_i02( uml_ch_source );
+       achl_cur_target++;                   /* output one character    */
+       break;
+     case ied_chs_iso8859_3:                /* ISO 8859-3 (Latin-3)    */
+       *((unsigned char *) achl_cur_target) = (unsigned char) m_u32c_to_i03( uml_ch_source );
+       achl_cur_target++;                   /* output one character    */
+       break;
+     case ied_chs_iso8859_4:                /* ISO 8859-4 (Latin-4)    */
+       *((unsigned char *) achl_cur_target) = (unsigned char) m_u32c_to_i04( uml_ch_source );
+       achl_cur_target++;                   /* output one character    */
+       break;
+     case ied_chs_iso8859_5:                /* ISO 8859-5              */
+       *((unsigned char *) achl_cur_target) = (unsigned char) m_u32c_to_i05( uml_ch_source );
+       achl_cur_target++;                   /* output one character    */
+       break;
+     case ied_chs_iso8859_6:                /* ISO 8859-6              */
+       *((unsigned char *) achl_cur_target) = (unsigned char) m_u32c_to_i06( uml_ch_source );
+       achl_cur_target++;                   /* output one character    */
+       break;
+     case ied_chs_iso8859_7:                /* ISO 8859-7              */
+       *((unsigned char *) achl_cur_target) = (unsigned char) m_u32c_to_i07( uml_ch_source );
+       achl_cur_target++;                   /* output one character    */
+       break;
+     case ied_chs_iso8859_8:                /* ISO 8859-8              */
+       *((unsigned char *) achl_cur_target) = (unsigned char) m_u32c_to_i08( uml_ch_source );
+       achl_cur_target++;                   /* output one character    */
+       break;
+     case ied_chs_iso8859_9:                /* ISO 8859-9 (Latin-5)    */
+       *((unsigned char *) achl_cur_target) = (unsigned char) m_u32c_to_i09( uml_ch_source );
+       achl_cur_target++;                   /* output one character    */
+       break;
+     case ied_chs_iso8859_10:               /* ISO 8859-10 (Latin-6)   */
+       *((unsigned char *) achl_cur_target) = (unsigned char) m_u32c_to_i10( uml_ch_source );
+       achl_cur_target++;                   /* output one character    */
+       break;
+     case ied_chs_iso8859_11:               /* ISO 8859-11             */
+       *((unsigned char *) achl_cur_target) = (unsigned char) m_u32c_to_i11( uml_ch_source );
+       achl_cur_target++;                   /* output one character    */
+       break;
+     case ied_chs_iso8859_13:               /* ISO 8859-13 (Latin-7)   */
+       *((unsigned char *) achl_cur_target) = (unsigned char) m_u32c_to_i13( uml_ch_source );
+       achl_cur_target++;                   /* output one character    */
+       break;
+     case ied_chs_iso8859_14:               /* ISO 8859-14 (Latin-8)   */
+       *((unsigned char *) achl_cur_target) = (unsigned char) m_u32c_to_i14( uml_ch_source );
+       achl_cur_target++;                   /* output one character    */
+       break;
+     case ied_chs_iso8859_15:               /* ISO 8859-15 (Latin-9)   */
+       *((unsigned char *) achl_cur_target) = (unsigned char) m_u32c_to_i15( uml_ch_source );
+       achl_cur_target++;                   /* output one character    */
+       break;
+     case ied_chs_iso8859_16:               /* ISO 8859-16 (Latin-10)  */
+       *((unsigned char *) achl_cur_target) = (unsigned char) m_u32c_to_i16( uml_ch_source );
+       achl_cur_target++;                   /* output one character    */
+       break;
+     case ied_chs_wcp_932:                  /* Windows-Codepage 932    */
+     case ied_chs_wcp_936:                  /* Windows-Codepage 936    */
+     case ied_chs_wcp_949:                  /* Windows-Codepage 949    */
+     case ied_chs_wcp_950:                  /* Windows-Codepage 950    */
+       if (uml_ch_source >= 0x10000) {
+         *achl_cur_target++ = ASCII_REP_CHAR;
+       } else {
+         iml1 = awcl_dbcsenc[uml_ch_source];
+         if (iml1 & 0xFF00)
+           *achl_cur_target++ = (char)(iml1>>8);  /* dbcs lead byte    */
+         *achl_cur_target++ = (char)iml1;   /* bits for second byte    */
+       }
+       break;
+     case ied_chs_utf_8:                    /* Unicode UTF-8           */
+       if ((uml_ch_source != 0) && ((uml_ch_source >> 7) == 0)) {  /* not zero or 0X80 (Why not zero? This way it encodes U+0000 with a superfluous extra byte WS 8.12.2011) */
+         *achl_cur_target++ = (unsigned char) uml_ch_source;
+         break;
+       }
+       if ((uml_ch_source >> 11) == 0) {
+         *achl_cur_target++ = 0XC0 | (uml_ch_source >> 6);
+         /* check at maximum output                                      */
+         if (achl_cur_target >= achl_end_target) return -1;  /* output area too short */
+         *achl_cur_target++ = 0X80 | (uml_ch_source & 0X3F);
+         break;
+       }
+       if ((uml_ch_source >> 16) == 0) {
+         *achl_cur_target++ = 0XE0 | (uml_ch_source >> 12);
+         if (achl_cur_target >= achl_end_target) return -1;  /* output area too short */
+         *achl_cur_target++ = (0X80 | ((uml_ch_source >> 6) & 0X3F));
+         if (achl_cur_target >= achl_end_target) return -1;  /* output area too short */
+         *achl_cur_target++ = (0X80 | (uml_ch_source & 0X3F));
+         break;
+       }
+       if ((uml_ch_source >> 21) == 0) {
+         *achl_cur_target++ = 0XF0 | (uml_ch_source >> 18);
+         if (achl_cur_target >= achl_end_target) return -1;  /* output area too short */
+         *achl_cur_target++ = (0X80 | ((uml_ch_source >> 12) & 0X3F));
+         if (achl_cur_target >= achl_end_target) return -1;  /* output area too short */
+         *achl_cur_target++ = (0X80 | ((uml_ch_source >> 6) & 0X3F));
+         if (achl_cur_target >= achl_end_target) return -1;  /* output area too short */
+         *achl_cur_target++ = (0X80 | (uml_ch_source & 0X3F));
+         break;
+       }
+       if ((uml_ch_source >> 26) == 0) {
+         *achl_cur_target++ = 0XF8 | (uml_ch_source >> 24);
+         if (achl_cur_target >= achl_end_target) return -1;  /* output area too short */
+         *achl_cur_target++ = (0X80 | ((uml_ch_source >> 18) & 0X3F));
+         if (achl_cur_target >= achl_end_target) return -1;  /* output area too short */
+         *achl_cur_target++ = (0X80 | ((uml_ch_source >> 12) & 0X3F));
+         if (achl_cur_target >= achl_end_target) return -1;  /* output area too short */
+         *achl_cur_target++ = (0X80 | ((uml_ch_source >> 6) & 0X3F));
+         if (achl_cur_target >= achl_end_target) return -1;  /* output area too short */
+         *achl_cur_target++ = (0X80 | (uml_ch_source & 0X3F));
+         break;
+       }
+       if ((uml_ch_source >> 31) == 0) {
+         *achl_cur_target++ = 0XFC | (uml_ch_source >> 30);
+         if (achl_cur_target >= achl_end_target) return -1;  /* output area too short */
+         *achl_cur_target++ = (0X80 | ((uml_ch_source >> 24) & 0X3F));
+         if (achl_cur_target >= achl_end_target) return -1;  /* output area too short */
+         *achl_cur_target++ = (0X80 | ((uml_ch_source >> 18) & 0X3F));
+         if (achl_cur_target >= achl_end_target) return -1;  /* output area too short */
+         *achl_cur_target++ = (0X80 | ((uml_ch_source >> 12) & 0X3F));
+         if (achl_cur_target >= achl_end_target) return -1;  /* output area too short */
+         *achl_cur_target++ = (0X80 | ((uml_ch_source >> 6) & 0X3F));
+         if (achl_cur_target >= achl_end_target) return -1;  /* output area too short */
+         *achl_cur_target++ = (0X80 | (uml_ch_source & 0X3F));
+         break;
+       }
+       return -1;                           /* character undefined     */
+     case ied_chs_html_1:                   /* HTML character set      */
+       bol1 = FALSE;                        /* character not copied    */
+       if (uml_ch_source < 0X80) {          /* may be a single character */
+         switch (uml_ch_source) {           /* check special values    */
+           case 0X22:                       /* chrs_html_quote         */
+             break;                         /* set in string           */
+           case 0X26:                       /* chrs_html_amp           */
+             break;                         /* set in string           */
+           case 0X3C:                       /* chrs_html_lt            */
+             break;                         /* set in string           */
+           case 0X3E:                       /* chrs_html_gt            */
+             break;                         /* set in string           */
+           default:
+             *achl_cur_target++ = (unsigned char) uml_ch_source;
+             bol1 = TRUE;                   /* character has been copied */
+             break;
+         }
+       }
+       if (bol1) break;                     /* all done                */
+       iml1 = m_put_html_1_a( achl_cur_target, achl_end_target, uml_ch_source );
+       if (iml1 < 0) return -1;             /* output area too small   */
+       achl_cur_target += iml1;             /* increment pointer output */
+       break;                               /* all done                */
+     case ied_chs_uri_1:                    /* URI RFC 3986            */
+       if (   ((uml_ch_source >> 7) == 0)   /* only 7 bits - < 0X80    */
+           && (chrs_uri_1_tab[ uml_ch_source ] == 0)) {  /* not reserved */
+         *achl_cur_target++ = (unsigned char) uml_ch_source;
+         break;
+       }
+       iml1 = m_put_uri_1_a( achl_cur_target, achl_end_target, uml_ch_source );
+       if (iml1 < 0) return -1;             /* output area too small   */
+       achl_cur_target += iml1;             /* increment pointer output */
+       break;                               /* all done                */
+     case ied_chs_idna_1:                   /* IDNA RFC 3490 - Punycode */
+       if (uml_ch_source < 0x7B) {          /* maybe unchanged char    */
+         if (--iml_idna_labelspace == 0) {  /* over RFC 1034 maxlength */
+           if (uml_ch_source != 0x2E)       /* last-chance part-end?   */
+             return -1;
+         }                   /* (limiting also precludes int overflow) */
+         inl_idna_prevccc = 0;              /* all these have ccc of 0 */
+         unl_prevstrt = uml_ch_source;      /* no test, as NFC_QC is Y */
+         if (uml_ch_source > 0x60) {        /* lcase ASCII, unchanged  */
+           *achl_cur_target++ = (unsigned char) uml_ch_source;
+           break;
+         }
+         if (uml_ch_source >= 0x30) {       /* maybe ASCII digit       */
+           if (uml_ch_source < 0x3A) {      /* ASCII digit, unchanged  */
+             *achl_cur_target++ = (unsigned char) uml_ch_source;
+             break;
+           }
+           if (bol_idna_nohighyet) {        /* permit IPv6 addresses etc. */
+             *achl_cur_target++ = (unsigned char) uml_ch_source;
+             iep_cs_target = IED_CHS_COPY7A;
+             break;
+           }
+           return -1;                       /* prohibited ASCII char   */
+         } else {
+           if (uml_ch_source == 0x2D) {     /* hyphen-minus, unchanged */
+             switch (MAX_IDNAPART_LENGTH-iml_idna_labelspace) {
+               case 2:
+                 iel_idna_minuspair = 1;
+                 break;
+               case 3:
+                 if (iel_idna_minuspair) {
+                   if (utl_idna_tn)
+                     return -1;             /* already non-ASCII at [0] or [1] */
+                   iel_idna_minuspair = 2;
+                 }
+                 break;
+               default:                     /* ignore at /^..--/-detection */
+                 break;
+             }
+             *achl_cur_target++ = (unsigned char) uml_ch_source;
+             break;
+           }
+           if (uml_ch_source == 0x2E) {     /* dot, begin new part     */
+             goto p_next_idnlbl;
+           }
+           if (bol_idna_nohighyet) {        /* permit IPv6 addresses etc. */
+             *achl_cur_target++ = (unsigned char) uml_ch_source;
+             iep_cs_target = IED_CHS_COPY7A;
+             break;
+           }
+           return -1;                       /* prohibited ASCII char   */
+         }
+       } else {                             /* not an unchanged char   */
+         if (iel_idna_minuspair) {
+           if (iel_idna_minuspair == 1)
+             iel_idna_minuspair = 0;        /* '-' only at [2], not at [3] */
+            else
+             return -1;                     /* label must be ASCII, "--"-rule */
+         }
+         switch (uml_ch_source) {           /* check for part end end CONTEXTJ cases */
+           case 0x200C:                     /* ZERO WIDTH NON-JOINER   */
+             if (utl_idna_tn==0)
+               return -1;                   /* cannot fulfil either rule */
+             if (utl_idna_openzwnj) {       /* still earlier one unclear, check that first */
+               if (!m_idna_zwnj_jtrule_ok( dslr_idna_treelist, utl_idna_openzwnj, utl_idna_tn ))
+                 return -1;                 /* earlier zwnj not conforming */
+             }
+             if (inl_idna_prevccc == 9) {   /* previous char is virama */
+               utl_idna_openzwnj = 0;
+               /* virama rule fulfilled, joiningtype not checked       */
+             } else {                       /* must fulfil joiningtype rule */
+               /* the rule would be complicated to test now, so it is tested on label end or
+                  next zwnj, as this is probably too rare to check utl_idna_openzwnj often */
+               utl_idna_openzwnj = utl_idna_tn;
+             }
+             inl_idna_prevccc = 0;          /* U+200C has ccc of 0     */
+             break;
+           case 0x200D:                     /* ZERO WIDTH JOINER       */
+             if (inl_idna_prevccc != 9)     /* previous char no virama */
+               return -1;                   /* failed CONTEXTJ rule    */
+             inl_idna_prevccc = 0;          /* U+200D has ccc of 0     */
+             break;                         /* virama rule fulfilled   */
+           case 0x3002:   /* dots, see RFC 3490, section 3.1, number 1 */
+           case 0xFF0E:
+           case 0xFF61:                     /* begin new part          */
+             goto p_next_idnlbl;
+           default:
+             if (!m_is_idna_allowed(uml_ch_source))
+               return -1;                   /* prohibited non-ASCII char */
+             iml1 = m_get_unicode_canonical_combining_class(uml_ch_source);
+             if (iml1 && (iml1 < inl_idna_prevccc))
+               return -1;                   /* cannot be in NFC form   */
+             inl_idna_prevccc = iml1;
+             if (m_idna_cannotbe_nfc(unl_prevstrt, uml_ch_source))
+               return -1;                   /* cannot be in NFC form   */
+             if (!iml1)                     /* remember "starter"      */
+               unl_prevstrt = uml_ch_source;
+             break;
+         }
+       }
+       /* store character in tree for later punycode representation    */
+       if (--iml_idna_labelspace == 0)      /* over RFC 1034 maxlength */
+         return -1;                         /* (limiting also precludes int overflow) */
+       if ((iml_idna_labelspace==MAX_IDNAPART_LENGTH) && m_get_unicode_is_combining(uml_ch_source))
+         return -1;                         /* combining mark as first in label */
+       if (!utl_idna_tn) {                  /* first non-ASCII in this part*/
+         bol_idna_nohighyet = FALSE;
+         if (achl_cur_target+5 >= achl_end_target)
+           return -1;                       /* output area too small   */
+         /* prepend prefix to what we already have translated to ASCII */
+         memmove( achl_idna_ps+4, achl_idna_ps, achl_cur_target-achl_idna_ps );
+         memcpy( achl_idna_ps, "xn--", 4 );
+         achl_cur_target += 4;
+       }
+       m_idna_add_to_treelist( dslr_idna_treelist, uml_ch_source, utl_idna_tn ++,
+                               MAX_IDNAPART_LENGTH-iml_idna_labelspace );
+       break;
+       p_next_idnlbl:                       /* next dot-separated part */
+       if (utl_idna_tn) {                   /* last part had non-ASCII */
+         if (utl_idna_openzwnj &&
+             !m_idna_zwnj_jtrule_ok( dslr_idna_treelist, utl_idna_openzwnj, utl_idna_tn ))
+           return -1;                       /* earlier U+200C not conforming */
+         achl_cur_target = m_idna_encode_utree( dslr_idna_treelist,
+                           achl_cur_target-(achl_idna_ps+4),
+                           achl_cur_target,
+                           achl_end_target<=achl_idna_ps+MAX_IDNAPART_LENGTH
+                                          ? achl_end_target
+                                          : achl_idna_ps+MAX_IDNAPART_LENGTH
+                           );
+         if ((achl_cur_target == NULL) || (achl_cur_target >= achl_end_target))
+           return -1;                       /* target overflow         */
+       }
+       *achl_cur_target++ = (unsigned char) '.';
+       achl_idna_ps = achl_cur_target;
+       iml_idna_labelspace = 1+MAX_IDNAPART_LENGTH;
+       utl_idna_openzwnj = 0;
+       iel_idna_minuspair = 0;
+       inl_idna_prevccc = 255;
+       unl_prevstrt = 0;
+       utl_idna_tn = 0;
+       break;
+     case IED_CHS_COPY7A:                   /* idna-prohibited ascii   */
+       if (uml_ch_source > 'z')
+         return -1;  /* neither IDNA nor something like a IPv6-address */
+       *((unsigned char *) achl_cur_target) = (unsigned char) uml_ch_source;
+       achl_cur_target++;                   /* output one character    */
+       break;
+     case ied_chs_utf_16:                   /* Unicode UTF-16 = WCHAR  */
+       if (uml_ch_source >= 0X10000) {      /* over 16-bit, needs surrogates */
+         uml_ch_source -= 0X10000;
+         *((HL_WCHAR *) achl_cur_target) = (HL_WCHAR)(0xD800 | (uml_ch_source >> 10));
+         achl_cur_target += sizeof(HL_WCHAR);
+         if (achl_cur_target >= achl_end_target)
+           return -1;                       /* target overflow         */
+         *((HL_WCHAR *) achl_cur_target) = (HL_WCHAR)(0xDC00 | (uml_ch_source & 0x03FF));
+       } else {                             /* 16-bit is enough        */
+         *((HL_WCHAR *) achl_cur_target) = (HL_WCHAR) uml_ch_source;
+       }
+       achl_cur_target += sizeof(HL_WCHAR);
+       break;
+     case ied_chs_be_utf_16:                /* Unicode UTF-16 big endian */
+       if (uml_ch_source >= 0X10000) {      /* over 16-bit, needs surrogates */
+         uml_ch_source -= 0X10000;
+         if (achl_cur_target >= achl_end_target)
+           return -1;                       /* target overflow         */
+         *((unsigned char *) achl_cur_target + 0) = (unsigned char) (0xD8 | (3 & (uml_ch_source >> 18)));
+         *((unsigned char *) achl_cur_target + 1) = (unsigned char) (uml_ch_source >> 10);
+         *((unsigned char *) achl_cur_target + 2) = (unsigned char) (0xDC | (3 & (uml_ch_source >> 8)));
+         *((unsigned char *) achl_cur_target + 3) = (unsigned char) uml_ch_source;
+         achl_cur_target += 2 * sizeof(HL_WCHAR);
+       } else {                             /* 16-bit is enough        */
+         *((unsigned char *) achl_cur_target + 0) = (unsigned char) (uml_ch_source >> 8);
+         *((unsigned char *) achl_cur_target + 1) = (unsigned char) uml_ch_source;
+         achl_cur_target += sizeof(HL_WCHAR);
+       }
+       break;
+     case ied_chs_le_utf_16:                /* Unicode UTF-16 little endian */
+       if (uml_ch_source >= 0X10000) {      /* over 16-bit, needs surrogates */
+         uml_ch_source -= 0X10000;
+         if (achl_cur_target >= achl_end_target)
+           return -1;                       /* target overflow         */
+         *((unsigned char *) achl_cur_target + 0) = (unsigned char) (uml_ch_source >> 10);
+         *((unsigned char *) achl_cur_target + 1) = (unsigned char) (0xD8 | (3 & (uml_ch_source >> 18)));
+         *((unsigned char *) achl_cur_target + 2) = (unsigned char) uml_ch_source;
+         *((unsigned char *) achl_cur_target + 3) = (unsigned char) (0xDC | (3 & (uml_ch_source >> 8)));
+         achl_cur_target += 2 * sizeof(HL_WCHAR);
+       } else {                             /* 16-bit is enough        */
+         *((unsigned char *) achl_cur_target + 0) = (unsigned char) uml_ch_source;
+         *((unsigned char *) achl_cur_target + 1) = (unsigned char) (uml_ch_source >> 8);
+         achl_cur_target += sizeof(HL_WCHAR);
+       }
+       break;
+     case ied_chs_utf_32:                   /* Unicode UTF-32          */
+       *((unsigned int *) achl_cur_target) = (unsigned int) uml_ch_source;
+       achl_cur_target += sizeof(unsigned int);
+       break;
+     case ied_chs_be_utf_32:                /* Unicode UTF-32 big endian */
+       *((unsigned char *) achl_cur_target + 0) = (unsigned char) (uml_ch_source >> 24);
+       *((unsigned char *) achl_cur_target + 1) = (unsigned char) (uml_ch_source >> 16);
+       *((unsigned char *) achl_cur_target + 2) = (unsigned char) (uml_ch_source >> 8);
+       *((unsigned char *) achl_cur_target + 3) = (unsigned char) uml_ch_source;
+       achl_cur_target += sizeof(unsigned int);
+       break;
+     case ied_chs_le_utf_32:                /* Unicode UTF-32 little endian */
+       *((unsigned char *) achl_cur_target + 0) = (unsigned char) uml_ch_source;
+       *((unsigned char *) achl_cur_target + 1) = (unsigned char) (uml_ch_source >> 8);
+       *((unsigned char *) achl_cur_target + 2) = (unsigned char) (uml_ch_source >> 16);
+       *((unsigned char *) achl_cur_target + 3) = (unsigned char) (uml_ch_source >> 24);
+       achl_cur_target += sizeof(unsigned int);
+       break;
+     default:
+       return -1;                           /* cannot copy             */
+   }
+   achl_cur_source += iml_len_ch_source;
+   goto pcpy_00;                            /* copy characters         */
+} /* end m_cpy_uc_vx_vx()                                              */
+
 /**
 * compute length of space needed for target, in elements
 *  @param iep_cs_target encoding for the hypothetical output string
@@ -9712,6 +10494,7 @@
    unsigned char utl_idna_openzwnj;         /* U+200C yet to be accepted (RFC 5892 A.1.) */
    /* variables for tests required for IDNA target by RFC 5891 5.4.    */
    int           iel_idna_minuspair;        /* detect labels starting with "..--" */
+   BOOL          bol_idna_nohighyet;        /* only <='z' in all labels so far */
    int           inl_idna_prevccc;          /* canonical combining class */
    unsigned int  unl_prevstrt;              /* last char with ccc == 0 */

@@ -9775,6 +10558,7 @@
      iml_idna_labelspace = 1+MAX_IDNAPART_LENGTH;
      utl_idna_openzwnj = 0;          /* =none, at 0 would not be legal */
      iel_idna_minuspair = 0;
+     bol_idna_nohighyet = TRUE;
      inl_idna_prevccc = 255;
      unl_prevstrt = 0;
      utl_idna_tn = 0;
@@ -9909,6 +10693,11 @@
              iml_len_return++;              /* increment length to return */
              break;
            }
+           if (bol_idna_nohighyet) {        /* permit IPv6 addresses etc. */
+             iml_len_return++;              /* increment length to return */
+             iep_cs_target = IED_CHS_COPY7A;
+             break;
+           }
            return -1;                       /* prohibited ASCII char   */
          } else {
            if (uml_ch_source == 0x2D) {     /* hyphen-minus, unchanged */
@@ -9932,6 +10721,11 @@
            if (uml_ch_source == 0x2E) {     /* dot, begin new part     */
              goto p_next_idnlbl;
            }
+           if (bol_idna_nohighyet) {        /* permit IPv6 addresses etc. */
+             iml_len_return++;              /* increment length to return */
+             iep_cs_target = IED_CHS_COPY7A;
+             break;
+           }
            return -1;                       /* prohibited ASCII char   */
          }
        } else {                             /* not an unchanged char   */
@@ -9987,8 +10781,10 @@
          return -1;                         /* (limiting also precludes int overflow) */
        if ((iml_idna_labelspace==MAX_IDNAPART_LENGTH) && m_get_unicode_is_combining(uml_ch_source))
          return -1;                         /* combining mark as first in label */
-       if (!utl_idna_tn)                    /* first non-ASCII in this part */
+       if (!utl_idna_tn) {                  /* first non-ASCII in this part */
+         bol_idna_nohighyet = FALSE;
          iml_len_return += 4;               /* increment length to return, for "xn--" */
+       }
        m_idna_add_to_treelist( dslr_idna_treelist, uml_ch_source, utl_idna_tn ++,
                                MAX_IDNAPART_LENGTH-iml_idna_labelspace );
        break;
@@ -10011,6 +10807,11 @@
        unl_prevstrt = 0;
        utl_idna_tn = 0;
        break;
+     case IED_CHS_COPY7A:                   /* idna-prohibited ascii   */
+       if (uml_ch_source > 'z')
+         return -1;  /* neither IDNA nor something like a IPv6-address */
+       iml_len_return++;                    /* increment length to return */
+       break;
      case ied_chs_utf_8:                    /* Unicode UTF-8           */
        if (   ((uml_ch_source >> 7) == 0)   /* only 7 bits - < 0X80    */
            && (uml_ch_source != 0)) {       /* not zero (Why not zero? Fits to other places in code where U+0000 is encoded with a superfluous extra byte WS 22.5.2012) */
@@ -10060,6 +10861,8 @@
    goto pcheck_00;                          /* check characters        */
 } /* end m_len_vx_vx()                                                 */

+#undef IED_CHS_COPY7A
+
 /**
 * return storage needed for the variable
 *  @param ap_source pointer to a string
@@ -10321,6 +11124,17 @@
                        adsp_usc_source->iec_chs_str );  /* character set string */
 } /* end m_cpy_vx_ucs()                                                */

+/** copy to uppercase                                                  */
+extern "C" int m_cpy_uc_vx_ucs( void *ap_target, int imp_len_target, enum ied_charset iep_cs_target,
+                                struct dsd_unicode_string *adsp_usc_source ) {
+   return m_cpy_uc_vx_vx( ap_target,
+                          imp_len_target,
+                          iep_cs_target,
+                          adsp_usc_source->ac_str,  /* address of string  */
+                          adsp_usc_source->imc_len_str,  /* length string in elements */
+                          adsp_usc_source->iec_chs_str );  /* character set string */
+} /* end m_cpy_uc_vx_ucs()                                             */
+
 /**
 * compute length of space needed for target, in elements
 *  @param iep_cs_target encoding for the hypothetical output string
@@ -11042,7 +11856,7 @@
 * retrieve a single HMTL character, the control character is already discarded
 *  @param[out] ump_res unicode codepoint number corresponding to the entity
 *  @param achp_start pointer to the char after the char starting an entity
-*  @param achp_end NULL to mean zero-terminated input, else
+*  @param achp_end NULL to mean zero-terminated input, else
 *                  pointer to (the byte after) the end of the input buffer
 *  @return -1 on error, else length of the entity (bytes read + 1 for the '&')
 */
@@ -14003,7 +14817,7 @@

 /**
 * Count the number of characters in an UTF8-string that contains only characters
-* whose unicode number needs no more than 16 bits.
+* whose unicode number needs no more than 16 bits.
 *  @param[out] aimp_result
 *  @param achp_source the string that shall be measured
 *  @param inp_len_source length of the string in bytes
@@ -14059,7 +14873,7 @@
 * get number of bytes before '\0' or limit of utf8 chars is reached
 *  @param achp_source input string to measure
 *  @param inp_max_chars_source length limit in (encoded, logial) characters
-*  @return -1 if malformed UTF8 was found; else 
+*  @return -1 if malformed UTF8 was found; else
 *          length in bytes of the first inp_max_chars_source encoded characters
 *          or bytes before the terminating zero, whatever is smaller
 */
@@ -14094,7 +14908,7 @@
 *                       other limit is reached), less will be returned (only
 *                       bytes before that sequence starts will count).
 *  @return -1 if malformed UTF8 was found, else length in bytes until one of the
-*                                               limitations was reached
+*                                               limitations was reached
 */
 static int m_count_with_u8l( const char *achp_source, int inp_max_chars_source,
                              int inp_max_bytes ) {
Index: hob-xslunic1.h
===================================================================
--- hob-xslunic1.h	(revision 2)
+++ hob-xslunic1.h	(revision 6)
@@ -264,6 +264,8 @@
                               void *ap_source, int imp_len_source, enum ied_charset iep_cs_source );
 extern PTYPE int m_cpy_lc_vx_vx( void *ap_target, int imp_len_target, enum ied_charset iep_cs_target,
                                  void *ap_source, int imp_len_source, enum ied_charset iep_cs_source );
+extern PTYPE int m_cpy_uc_vx_vx( void *ap_target, int imp_len_target, enum ied_charset iep_cs_target,
+                                 void *ap_source, int imp_len_source, enum ied_charset iep_cs_source );
 extern PTYPE BOOL m_to_lc_inplace( void *ap_p, int imp_len, enum ied_charset iep_cs );
 extern PTYPE BOOL m_to_uc_inplace( void *ap_p, int imp_len, enum ied_charset iep_cs );
 extern PTYPE void m_tolowercase_inplace_u32c(unsigned int *aimp_c);
@@ -277,6 +279,8 @@
 extern PTYPE BOOL m_cmpi_ucs_ucs( int *aimp_result, struct dsd_unicode_string *adsp_us_p1, struct dsd_unicode_string *adsp_us_p2 );
 extern PTYPE int m_cpy_vx_ucs( void *ap_target, int imp_len_target, enum ied_charset iep_cs_target,
                                struct dsd_unicode_string *adsp_usc_source );
+extern PTYPE int m_cpy_uc_vx_ucs( void *ap_target, int imp_len_target, enum ied_charset iep_cs_target,
+                                  struct dsd_unicode_string *adsp_usc_source );
 extern PTYPE int m_len_vx_ucs( enum ied_charset iep_cs_target, struct dsd_unicode_string *adsp_usc_source );
 extern PTYPE int m_len_bytes_ucs( struct dsd_unicode_string *adsp_usc_source );
 extern PTYPE int m_get_ucs_base64( int *aimp_error, int *aimp_pos_error, char *achp_target, int imp_len_target, struct dsd_unicode_string *adsp_usc_source );
Index: hob-gw-ppp-1.h
===================================================================
--- hob-gw-ppp-1.h	(revision 2)
+++ hob-gw-ppp-1.h	(revision 6)
@@ -87,6 +87,16 @@
    ied_par_aux                              /* auxiliary record        */
 };

+#ifndef B130123
+enum ied_ppp_auth_rc {                      /* PPP authentication return code */
+   ied_pppar_ok = 0,                        /* authentication was checked O.K. */
+   ied_pppar_userid_inv,                    /* userid invalid          */
+   ied_pppar_password_inv,                  /* password invalid        */
+   ied_pppar_auth_failed,                   /* authentication failed   */
+   ied_pppar_misc                           /* miscellaneous           */
+};
+#endif
+
 /* PPP server sends packet to the client                               */
 typedef void ( * amd_ppp_se_send )( struct dsd_ppp_server_1 *, struct dsd_buf_vector_ele * );

Index: comp-LINUX-nbipgw20-tun2
===================================================================
--- comp-LINUX-nbipgw20-tun2	(revision 0)
+++ comp-LINUX-nbipgw20-tun2	(revision 6)
@@ -0,0 +1,57 @@
+g++ -m32 -g -Wno-write-strings -Wno-invalid-offsetof -c -I. -I/usr/local/include -DTRACEHL1 -DD_INCL_HOB_TUN -DHL_UNIX -DHL_LINUX nbipgw20.cpp -o nbipgw20.o
+g++ -m32 -g -c -Wno-write-strings -I. -I/usr/local/include -DHL_UNIX -DHL_LINUX -DHOB_CONTR_TIMER xsipgw08-conf.cpp -o xsipgw08-conf.o
+g++ -m32 -g -c -Wno-write-strings -I. -DHL_UNIX xstuntapif.cpp -o xstuntapif.o
+g++ -m32 -g -c -Wno-write-strings -I. -DHL_UNIX xshusip01.cpp -o xshusip01.o
+g++ -m32 -g -c -Wno-write-strings -I. -DHL_UNIX xshsstp01.cpp -o xshsstp01.o
+g++ -m32 -g -c -Wno-write-strings -I. -DHL_UNIX xshsessutil01.cpp -o xshsessutil01.o
+g++ -m32 -g -c -Wno-write-strings -I. -DHL_UNIX xshpppi01.cpp -o xshpppi01.o
+g++ -m32 -g -c -Wno-write-strings -I. -DHL_UNIX xs-htcp-01.cpp -o xs-htcp-01.o
+g++ -m32 -g -c -Wno-write-strings -I. -DHL_UNIX xs-htcp-hdr-01.cpp -o xs-htcp-hdr-01.o
+g++ -m32 -g -c -Wno-write-strings -I. -DHL_UNIX xs-htcp-htun-01.cpp -o xs-htcp-htun-01.o
+g++ -m32 -g -c -Wno-write-strings -I. -DHL_UNIX xsclibrdp1.cpp -o xsclibrdp1.o
+g++ -m32 -g -c -Wno-write-strings -I. -DHL_UNIX xslunic1.cpp -o xslunic1.o
+g++ -m32 -g -c -Wno-write-strings -I. -DHL_UNIX xsavl03.cpp -o xsavl03.o
+g++ -m32 -g -c -Wno-write-strings -I. -DHL_UNIX xslnetw1.cpp -o xslnetw1.o
+g++ -m32 -g -c -Wno-write-strings -I. -DHL_UNIX -DHOB_CONTR_TIMER xslcontr.cpp -o xslcontr.o
+g++ -m32 -g -c -Wno-write-strings -I. -DTRACEHL1 -DHL_UNIX nstcpco1.cpp -o nstcpco1.o
+g++ -m32 -g -c -Wno-write-strings -I. -DHL_UNIX xs_nblock_acc.cpp -o xs_nblock_acc.o
+g++ -m32 -g -c -Wno-write-strings -I. -DHL_UNIX xsllog01.cpp -o xsllog01.o
+g++ -m32 -g -c -Wno-write-strings -I. -DHL_UNIX xsrerrm1.cpp -o xsrerrm1.o
+g++ -m32 -g -c -Wno-write-strings -I. -DHL_UNIX xsthlcl1.cpp -o xsthlcl1.o
+g++ -m32 -g -c -Wno-write-strings -I. -DHL_UNIX xsthlse3.cpp -o xsthlcl3.o
+g++ -m32 -g -c -Wno-write-strings -I. -DHL_UNIX xst-lbal-dummy-1.cpp -o xst-lbal-dummy-1.o
+g++ -m32 -g -c -Wno-write-strings -I. -DHL_UNIX xs-gw-radius-01.cpp -o xs-gw-radius-01.o
+g++ -m32 -g -c -Wno-write-strings -I. -DHL_UNIX -DHL_LINUX xs-gw-cluster.cpp -o xs-gw-cluster.o
+g++ -m32 -g -c -Wno-write-strings -I. -I/usr/local/include -DHL_UNIX xs-gw-serv-vch-icap.cpp -o xs-gw-serv-vch-icap.o
+g++ -m32 -g -c -Wno-write-strings -I. -DTRACEHL1 -DHL_UNIX -DHL_LINUX xs-gw-udp-01.cpp -o xs-gw-udp-01.o
+g++ -m32 -g -c -Wno-write-strings -I. -DHL_UNIX xs-gw-udp-gate-srtp.cpp -o xs-gw-udp-gate-srtp.o
+g++ -m32 -g -c -Wno-write-strings -I. -DHL_UNIX -DHL_LINUX xs-gw-admin.cpp -o xs-gw-admin.o
+g++ -m32 -g -c -Wno-write-strings -I. -DHL_UNIX xs-gw-l2tp.cpp -o xs-gw-l2tp.o
+g++ -m32 -g -c -Wno-write-strings -I. -DHL_UNIX xs-gw-ppp.cpp -o xs-gw-ppp.o
+g++ -m32 -g -c -Wno-write-strings -I. -DHL_UNIX xsl-stor-big-n.cpp -o xsl-stor-big-n.o
+g++ -m32 -g -c -Wno-write-strings -I. -DHL_UNIX xsltime1.cpp -o xsltime1.o
+g++ -m32 -g -c -Wno-write-strings -I. -DHL_UNIX xsl-tcp-sync-01.cpp -o xsl-tcp-sync-01.o
+gcc -m32 -g -c -Wno-write-strings -I. -DHL_UNIX xsregex01.c -o xsregex01.o
+gcc -m32 -g -c -Wno-write-strings -I. -DHL_UNIX -DHOB_CONTR_TIMER xs-encry-1.c -o xs-encry-1.o
+g++ -m32 -g -c -Wno-write-strings -I. -DHL_UNIX -DHL_LINUX -DHOB_CONTR_TIMER xs-gw-cma1-02.cpp -o xs-gw-cma1-02.o
+// g++ -m32 -g -c -Wno-write-strings -I. -DHL_UNIX xs-ipgw08-snmp-01.cpp -o xs-ipgw08-snmp-01.o
+g++ -m32 -g -c -Wno-write-strings -I. -DHL_UNIX xsldapco1.cpp -o xsldapco1.o
+gcc -m32 -g -c -Wno-write-strings -I. -DHL_UNIX -DHOB_CONTR_TIMER xs-gw-krb5-lib-interface.c -o xs-gw-krb5-lib-interface.o
+gcc -m32 -g -c -Wno-write-strings -I. -DHL_UNIX -DHOB_CONTR_TIMER xs-gw-krb5-lib.c -o xs-gw-krb5-lib.o
+g++ -m32 -g -c -Wno-write-strings -I. -DHL_UNIX -DHOB_CONTR_TIMER xs-gw-krb5-control.cpp -o xs-gw-krb5-control.o
+gcc -c -g -O -Wa,-alh,-L,--32 islock02-32.s
+gcc -m32 -g -pthread -L/usr/local/lib32 -lrt -ldl -lxerces-c nbipgw20.o \
+   xsipgw08-conf.o xsclibrdp1.o \
+   xstuntapif.o xshusip01.o xshsstp01.o xshsessutil01.o xshpppi01.o \
+   xs-htcp-01.o xs-htcp-hdr-01.o xs-htcp-htun-01.o \
+   xslunic1.o xslcontr.o xsavl03.o xslnetw1.o xs_nblock_acc.o nstcpco1.o xsl-tcp-sync-01.o \
+   xs-gw-udp-01.o xs-gw-udp-gate-srtp.o xs-gw-l2tp.o xs-gw-ppp.o \
+   xs-gw-radius-01.o xs-gw-cluster.o xs-gw-admin.o \
+   xsl-stor-big-n.o xsltime1.o xsllog01.o xsregex01.o xs-gw-cma1-02.o \
+   xsthlcl1.o xsthlcl3.o xst-lbal-dummy-1.o xsrerrm1.o \
+   xs-gw-serv-vch-icap.o \
+   xs-encry-1.o \
+   xsldapco1.o \
+   xs-gw-krb5-lib-interface.o xs-gw-krb5-lib.o xs-gw-krb5-control.o \
+   islock02-32.o \
+   -o nbipgw20
Index: SOFTWARE.KBPC.SSLI03.act.txt
===================================================================
--- SOFTWARE.KBPC.SSLI03.act.txt	(revision 0)
+++ SOFTWARE.KBPC.SSLI03.act.txt	(revision 6)
@@ -0,0 +1,393 @@
+
+
+
+
+
+
+         Interface for SSL and TLS Encryption, Server Side
+         Version 3 of the Interface
+
+         1. Overview
+
+         The gateways IBIPGW08 and nbipgw20, also called HOB
+         WebSecureProxy, have the possibility of receiving data encrypted
+         and to use SSL V3 or TLS.
+
+         Theses gateways are designed to handle many concurrent sessions;
+         for this non-blocking TCP sockets are used.
+
+         The subroutine for encryption, called XSHLSE03 (Subroutine
+         HOBLink Server Encryption 03) herein, should not do any socket
+         calls.
+         All necessary socket calls from the subroutine will go thru the
+         interface to the main program.
+         Also XSHLSE03 is not allowed to call any APIs of the OS
+         (Operating System) direct, instead of this there is a
+         Callback-Routine amc_aux() implemented in the server (calling)
+         program which communicats with the OS. In this way, XSHLSE03 is
+         totally independant of the underlying OS.
+
+         2. Function Calls of XSHLSE03
+
+         2.1. Progressing of Configuration Files, m_se_registerconfig()
+
+         At first, the main program has to read in the necessary files:
+         - CONFIG-FILE SSL configuration file
+         - CERTDB-FILE SSL certificate database file
+         - PASSWORD-FILE SSL password file (password encrypted)
+
+         Now the main program calls m_se_registerconfig:
+         int m_se_registerconfig( char * achp_configdatabuf,
+               int inp_configdatalen,
+               char * achp_certdatabuf, int inp_certdatalen,
+               char * achp_pdwbuf, int inp_pdwlen,
+               BOOL boc_pwdfileflag,
+               struct dsd_hl_ocsp_d_1 * adsp_ocspd,
+               BOOL (* amp_aux) ( void *vpp_userfld, int, void *, int ),
+               void * vpp_userfld,
+               void ** avpp_config_id );
+
+         achp_configdatabuf = pointer to configuration file contents
+         inp_configdatalen = length of configuration file contents
+         achp_certdatabuf = pointer to certificate database file contents
+         inp_certdatalen = length of certificate database file contents
+         achp_pdwbuf = pointer to password
+         inp_pdwlen = length of password
+         boc_pwdfileflag = TRUE if password encrypted
+         ...
+         avpp_config_id = pointer to void * which receives a value which
+         has to be forwarded to SSL-functions later+
+
+
+
+
+
+         After the function has been called, all memory for the files can
+         be freed.
+
+         When the function returns zero, everything is o.k. and the void
+         * value at avpp_config_id can be used to encrypt data.
+
+         When the function returns not-zero, this is a SSL-error-number.
+
+         2.2. Main Function m_hlse03()
+
+         2.2.1. Prototype Function
+
+         The main function of XSHLSE03 is called m_hlse03() which has the
+         prototype function defined like that:
+         void m_hlse03( struct dsd_hl_ssl_s_3 * );
+         m_hlse03() may be called from C or from C++ programs, in C++
+         programs extern "C" needs to be added to enable proper linking.
+
+         The function m_hlse03() processed to data in both directions, it
+         decrypts data received from the client and it decrypts data to
+         be sent to the client. In one single call, data in both
+         directions may be processed.
+
+         2.2.2. The Header-File hob-ssl-01.h:
+
+         struct dsd_hl_ssl_s_3 {          /* HOBLink SSL Server 3    */
+           int  inc_func;                 /* function of call        */
+         #define DEF_IFUNC_START 0
+         #define DEF_IFUNC_CONT  1
+           int  inc_return;               /* return value            */
+         #define DEF_IRET_NORMAL 0
+         #define DEF_IRET_END    1
+         #define DEF_IRET_ERRAU  2        /* error in auxiliary subr */
+           boc_eof_client;                /* End-of-File Client      */
+           boc_eof_server;                /* End-of-File Server      */
+           struct dsd_gather_i_1 *adsc_gai1_fromcl;
+                                       /* input received from client */
+           struct dsd_gather_i_1 *adsc_gai1_fromse;
+                                       /* input received from server */
+           char *     achc_tose_cur;   /* current address output buffer
+                                          to be sent to the server   */
+           char *     achc_tose_end;   /* end address output buffer
+                                          to be sent to the server   */
+           char *     achc_tocl_cur;   /* current address output buffer
+                                          to be sent to the client   */
+           char *     achc_tocl_end;   /* end address output buffer
+                                          to be sent to the client   */
+           BOOL (* amc_aux) ( void *vpp_userfld, int, void *, int );
+                                        /* address of aux subroutine */
+         #define DEF_AUX_MEMGET  0
+         #define DEF_AUX_MEMFREE 1
+           void *     ac_ext;           /* address of attached buffer */
+           void *     ac_config_id;
+                               /* address of configuration parameters */
+           ... fields for Connect Callback and OCSP
+           void *     vpc_userfld;        /* User Field Subroutine   */
+           int        imc_sno;            /* Session number          */
+           int        imc_trace_level;    /* WSP trace level         */+
+
+
+
+
+
+           HL_LONGLONG ilc_entropy;       /* Seed for random         */
+         };
+
+         2.2.3. inc_func and inc_return
+
+         The main program will set inc_func. The variable inc_func will
+         be set to DEF_IFUNC_START when a new connection has been
+         established.
+         m_hlse03() will set the variable inc_func to DEF_IFUNC_CONT to
+         continue the communication.
+
+         m_hlse03() will set the variable inc_return. The variable
+         inc_return will normally contain DEF_IRET_NORMAL for normal
+         processing.
+         If the communication has ended, m_hlse03() will free all its
+         buffers and will set inc_return to DEF_IRET_END.
+         If an error has been returned from the Callback-Routine
+         amc_aux(), m_hlse03() will free all its buffers and will set
+         inc_return to DEF_IRET_ERRAU.
+         The subroutine m_hlse03() may set other values to inc_return,
+         indicating SSL errors.
+         If inc_return does not contain DEF_IRET_NORMAL when m_hlse03()
+         returns, the main program will close the connection and will not
+         call m_hlse03() any more (for this connection).
+         2.2.4. boc_eof_client and boc_eof_server
+
+         The main program may receive session-end or an error over the
+         socket connection, either on the connection to the client or on
+         the connection to the server.
+         So the connection to the client is alive as long as
+         boc_eof_client == FALSE; the connection to the server is alive
+         as long as boc_eof_server == FALSE.
+         When either boc_eof_client or boc_eof_server are set to TRUE (or
+         both), this means the SSL subroutine m_hlse03() has to end.
+         But this also means m_hlse03() still can send data to the side
+         still open, client or server.
+         The main program will call m_hlse03() until it sets inc_return
+         to DEF_IRET_END or any other value not equal to DEF_IRET_NORMAL.
+
+         2.2.5. Designed for Maximum Performance
+
+         In server-programs copying of buffers should be avoided.
+         Also the Memory-Management-Functions (like malloc(), free(), new
+         or delete) should not be called frequently.
+         Both, copying of buffers and calling Memory-Management-Functions
+         would mean a performance penalty for a server application.
+
+         So the design of XSHLSE03 and struct dsd_hl_ssl_s_3 were made in
+         a way so that the SSL subroutine does not need to copy any data
+         in buffers and also does not need to temporary save any buffers.
+         The calling = main program (HOB WebSecureProxy) has to handle
+         the buffers anyway, so there is no need that XSHLSE03 also does
+         the same.+
+
+
+
+
+
+         2.2.6 Input to XSHLSE03 as struct dsd_gather_i_1
+
+         SSL is record-oriented, not a streaming interface like TCP.
+         When an SSL-encrypted block is received from an SSL-client, the
+         TCP receive() may have received only part of an SSL-record.
+         XSHLSE03 can only decrypt the SSL-record when it has access to
+         the entire buffer. So the main = calling program gives all
+         buffers received in a chain of gather-structures. As long as
+         XSHLSE03 cannot decrypt the SSL-record, it simply returns
+         without filling the output area. Once the main = calling program
+         has received more, it will append the newly received data to the
+         chain and call XSHLSE03 m_hlse03() again.
+         When XSHLSE03 m_hlse03() has processed part or all of the input
+         data, it sets the field achc_ginp_cur in struct dsd_gather_i_1
+         the mark how for it has processed the data.
+         After returning to the main program, the main program will free
+         all memory blocks that are no longer needed.
+         XSHLSE03 m_hlse03() changes only field achc_ginp_cur in struct
+         dsd_gather_i_1, it does not modify the fields adsc_next or
+         achc_ginp_end.
+
+         The input from the server is also giving as a chain of struct
+         dsd_gather_i_1, adsc_gai1_fromcl (from client).
+
+         The input from the server is also giving as a chain of struct
+         dsd_gather_i_1, adsc_gai1_fromse (from server).
+
+         XSHLSE03 m_hlse03() does not modify the fields adsc_gai1_fromcl
+         or adsc_gai1_fromse in struct dsd_hl_ssl_s_3.
+
+         2.2.7. Output buffers for XSHLSE03
+
+         The main = calling program supplies buffers for output of
+         XSHLSE03 m_hlse03(), output to be sent to the client and output
+         to be sent to the server. These buffers are each one contiguous
+         area of memory.
+         But the main = calling program may call XSHLSE03 m_hlse03() with
+         setting the variables for buffer start and end equal to NULL.
+         This is done when the main = calling program cannot actually
+         send data in this direction because sending has blocked and
+         there is flow-control.
+
+         When XSHLSE03 m_hlse03() does not get any output buffer from the
+         main = calling program in a certain direction (either client to
+         server or server to client), it will not process any input data.
+
+         When XSHLSE03 m_hlse03() has received a complete SSL-encrypted
+         block from the client (in adsc_gai1_fromcl) and the output
+         buffer between achc_tose_cur and achc_tose_end is not big enough
+         to receive all decrypted data, XSHLSE03 m_hlse03() will fill the
+         output buffer as far as space available, will internally save
+         how far the input block has been filled, and will return. The
+         main = calling program will call XSHLSE03 m_hlse03() again with
+         a new output buffer between achc_tose_cur and achc_tose_end so
+         that this can be filled.
+         XSHLSE03 m_hlse03() does set achc_tose_cur how far the output
+         buffer is filled, it will not modify the field achc_tose_end.+
+
+
+
+
+
+         When XSHLSE03 m_hlse03() processes data received from the
+         server, it will process only so much input data as it can store
+         in the output buffer represented by achc_tocl_cur and
+         achc_tocl_end.
+         XSHLSE03 m_hlse03() will set achc_tocl_cur to indicate how far
+         the output buffer to be sent to the client has been filled.
+         This size of the output buffers for XSHLSE03 m_hlse03() may
+         change, depending on the needs of the outside main = calling
+         program.
+         If XSHLSE03 m_hlse03() is called with a memory area between
+         achc_tocl_cur and achc_tocl_end that does not have the length
+         zero (no output desired at this moment), but less than necessary
+         to hold the shortest possible output SSL-record, it will return
+         with an error since this is a bug in the main = calling program.
+
+         2.2.8. SSL and Compression
+
+         HOB XSHLSE03 also supports compression. This means data from the
+         client are decryted first and then decompressed. Data from the
+         server to the client are compressed first and then encryted.
+         If compression is used, this means XSHLSE03 m_hlse03() may need
+         internal buffers to store the intermediate results either from
+         decryption or from compression. Still, copying buffers is not
+         needed. But if XSHLSE03 m_hlse03() for example decrypts the data
+         received from the client to an internal buffer, it should not
+         set achc_ginp_cur of struct dsd_gather_i_1 of adsc_gai1_fromcl
+         as if all data have been processed (as long the data are not
+         completely processed). The outside main = calling program needs
+         to know that it has to call XSHLSE03 m_hlse03() again; it does
+         not call XSHLSE03 m_hlse03() if there are no more input buffers
+         and as long as no new input data have arrived.
+
+         2.2.9. End of Processing
+
+         During normal processing, the main program first will set
+         inc_func to DEF_IFUNC_START and will never again touch inc_func
+         again (m_hlse03() will set inc_func to DEF_IFUNC_CONT). The main
+         program will set boc_eof_client or boc_eof_server (or both) to
+         TRUE when either the client or the gateway / server wants to end
+         the communication.
+
+         2.2.10. Buffer handling done by the Main Program
+
+         The main program is responsible for supplying all buffers and
+         freeing the buffer when no longer needed.
+         XSHLSE03 will not directly call any APIs the allocate or free
+         buffer, instead it will call the subroutine, whos address is
+         supplied by the main program in amc_aux. When calling amc_aux
+         the variable Userfield (sometimes also called Opaque)
+         vpc_userfld has to be passed, so that the Callback-Routine can
+         identify the session it is called for.
+         XSHLSE03 will free all the buffers allocated, the main program
+         does not need to keep track of the buffers allocated by
+         XSHLSE03.
+         XSHLSE03 will need a work area for its data.
+         XSHLSE03 will allocate storage thru the subroutine amc_aux and
+         will save the address in ac_ext. The main program will do
+         nothing with the field ac_ext.+
+
+
+
+
+
+         2.2.11. The Subroutine amc_aux
+
+         The subroutine amc_aux has four parameters.
+         The first parameter is the Userfield vpp_userfld, the subroutine
+         needs this to find the correspondig fields of the main (calling)
+         program.
+         The second parameter is the function imp_func (DEF_AUX_MEMGET or
+         DEF_AUX_MEMFREE or others).
+         The third parameter is the address where the pointer of the
+         allocated storage has to be stored (DEF_AUX_MEMGET) or where the
+         address of the storage to free is supplied (DEF_AUX_MEMFREE).
+         The fourth parameter contains the length of the storage to be
+         allocated or freed.
+         The subroutine amc_aux returns FALSE if an error occured.
+
+         2.2.12. Handling of Threads
+
+         m_hlse03() will be called from only one thread at one time (with
+         a certain control-block struct dsd_hl_ssl_s_3), so m_hlse03()
+         does not need to be thread-safe.
+         But m_hlse03() may be called from different threads with
+         different control-blocks struct dsd_hl_ssl_s_3 at the same time.
+         m_hlse03() may be called at different times with the same
+         control-block struct dsd_hl_ssl_s_3 using different threads.
+
+         2.2.13. Callback-Routine amc_conn_callback
+
+         2.3. Entry Point to Retrieve the Configured Timeout Value
+
+         The function m_se_get_conf_timeout() has been defined so that
+         the calling program (main, WebSecureProxy) can find out, which
+         timeout (in seconds) has been configured for SSL.
+         The function will return the timeout in seconds. If there is any
+         error, the function will return zero.
+
+         Prototype Statement:
+
+         int m_se_get_conf_timeout( void *vpp_config_id );
+
+         2.4. Entry Point to Retrieve the Version of the SSL Subroutine
+         XSHLSE03
+
+         The function m_hssl_getversioninfo() retrieves the version of
+         XSHLSE03 so that the main program can display this version.
+
+         Prototype Statement:
+
+         int m_hssl_getversioninfo( int *, char *, int * );
+
+         The return value is the indicator for success like HSSL_OP_OK.
+
+         The first parameter is the address of an int-field to receive
+         the version number.
+         The second parameter is the address of a byte-array to receive
+         text corresponding to the version of XSHLSE03.
+         The third parameter serves as length field (input and output)
+         for the text corresponding to the version of XSHLSE03.+
+
+
+
+
+
+         On input to m_hssl_getversioninfo() the third parameter contains
+         the maximum length field to receive the text.
+         When m_hssl_getversioninfo() returns it has set the length of
+         the text field filled.
+
+         3. References
+
+         HOBTEXT SOFTWARE.KBPC.SSLI01, first version 23.12.98
+         HOBTEXT SOFTWARE.KBPC.SSLI02, 16.02.05
+
+         14.08.09  KB
+         15.08.09  KB
+         16.08.09  KB
+         11.11.12  KB+
\ No newline at end of file
Index: hob-htcp-hdr-01.h
===================================================================
--- hob-htcp-hdr-01.h	(revision 0)
+++ hob-htcp-hdr-01.h	(revision 6)
@@ -0,0 +1,730 @@
+/******************************************************************************
+ * File name: hob-htcp-hdr-01.h
+ *
+ * Utility for handling TCP/IP headers.
+ *
+ * Author: Kevin Spiteri
+ * Copyright: Copyright (c) HOB Software 2011
+ ******************************************************************************/
+
+#ifndef HOB_HTCP_HDR_01_H
+#define HOB_HTCP_HDR_01_H
+
+
+#ifdef DEF_INCLUDE_HEADERS
+#include <string.h>
+#include "hob-htcp-int-01.h"
+#endif /* DEF_INCLUDE_HEADERS */
+
+#ifdef DEF_TCPIP_INLINE
+#error "DEF_TCPIP_INLINE already defined"
+#elif defined __cplusplus
+#define DEF_TCPIP_INLINE inline
+#elif defined __GNUC__
+#define DEF_TCPIP_INLINE __inline__
+#elif defined _MSC_VER
+#define DEF_TCPIP_INLINE __inline
+#elif __STDC_VERSION__ >= 199901L /* C99 */
+#define DEF_TCPIP_INLINE static inline
+#else
+#define DEF_TCPIP_INLINE static
+#endif
+
+/* IPv4 get */
+
+DEF_TCPIP_INLINE uint8_t m_get_ip_version(const char* achp_ip_header)
+{
+    return ((uint8_t)achp_ip_header[0] >> 4) & 0x0f;
+}
+
+DEF_TCPIP_INLINE uint8_t m_get_ip_hlen_4(const char* achp_ip_header)
+{
+    return (uint8_t)achp_ip_header[0] & 0x0f;
+}
+
+DEF_TCPIP_INLINE uint8_t m_get_calc_ip_hlen(const char* achp_ip_header)
+{
+    return m_get_ip_hlen_4(achp_ip_header) * 4;
+}
+
+DEF_TCPIP_INLINE uint8_t m_get_ip_tos(const char* achp_ip_header)
+{
+    return (uint8_t)achp_ip_header[1];
+}
+
+DEF_TCPIP_INLINE uint16_t m_get_ip_tlen(const char* achp_ip_header)
+{
+    return ((uint8_t)achp_ip_header[2] << 8) | (uint8_t)achp_ip_header[3];
+}
+
+DEF_TCPIP_INLINE uint16_t m_get_calc_ip_plen(const char* achp_ip_header)
+{
+    return m_get_ip_tlen(achp_ip_header) - m_get_calc_ip_hlen(achp_ip_header);
+}
+
+DEF_TCPIP_INLINE uint16_t m_get_ip_id(const char* achp_ip_header)
+{
+    return ((uint8_t)achp_ip_header[4] << 8) | (uint8_t)achp_ip_header[5];
+}
+
+DEF_TCPIP_INLINE uint8_t m_get_ip_flags(const char* achp_ip_header)
+{
+    return ((uint8_t)achp_ip_header[6] >> 5) & 0x07;
+}
+
+DEF_TCPIP_INLINE uint8_t m_get_ip_df(const char* achp_ip_header)
+{
+    return ((uint8_t)achp_ip_header[6] >> 6) & 0x01;
+}
+
+DEF_TCPIP_INLINE uint8_t m_get_ip_mf(const char* achp_ip_header)
+{
+    return ((uint8_t)achp_ip_header[6] >> 5) & 0x01;
+}
+
+DEF_TCPIP_INLINE uint16_t m_get_ip_fofs_8(const char* achp_ip_header)
+{
+    return (((uint8_t)achp_ip_header[6] & 0x1f) << 8) |
+	(uint8_t)achp_ip_header[7];
+}
+
+DEF_TCPIP_INLINE uint16_t m_get_calc_ip_fofs(const char* achp_ip_header)
+{
+    return m_get_ip_fofs_8(achp_ip_header) * 8;
+}
+
+DEF_TCPIP_INLINE uint8_t m_get_ip_ttl(const char* achp_ip_header)
+{
+    return (uint8_t)achp_ip_header[8];
+}
+
+DEF_TCPIP_INLINE uint8_t m_get_ip_prot(const char* achp_ip_header)
+{
+    return (uint8_t)achp_ip_header[9];
+}
+
+DEF_TCPIP_INLINE uint16_t m_get_ip_chksum(const char* achp_ip_header)
+{
+    return ((uint8_t)achp_ip_header[10] << 8) | (uint8_t)achp_ip_header[11];
+}
+
+DEF_TCPIP_INLINE uint32_t m_get_ip_src_addr(const char* achp_ip_header)
+{
+    return ((uint8_t)achp_ip_header[12] << 24) |
+	((uint8_t)achp_ip_header[13] << 16) |
+        ((uint8_t)achp_ip_header[14] << 8) |
+	(uint8_t)achp_ip_header[15];
+}
+
+DEF_TCPIP_INLINE uint32_t m_get_ip_dst_addr(const char* achp_ip_header)
+{
+    return ((uint8_t)achp_ip_header[16] << 24) |
+	((uint8_t)achp_ip_header[17] << 16) |
+        ((uint8_t)achp_ip_header[18] << 8) |
+	(uint8_t)achp_ip_header[19];
+}
+
+DEF_TCPIP_INLINE const char* m_get_ip_src_addr_buf(const char* achp_ip_header)
+{
+    return achp_ip_header + 12;
+}
+
+DEF_TCPIP_INLINE const char* m_get_ip_dst_addr_buf(const char* achp_ip_header)
+{
+    return achp_ip_header + 16;
+}
+
+
+/* IPv4 set */
+
+DEF_TCPIP_INLINE void m_set_ip_version(char* achp_ip_header, uint8_t utp_ver)
+{
+    achp_ip_header[0] = ((uint8_t)achp_ip_header[0] & 0x0f) |
+        ((utp_ver << 4) & 0xf0);
+}
+
+DEF_TCPIP_INLINE void m_set_ip_hlen_4(char* achp_ip_header, uint8_t utp_hl)
+{
+    achp_ip_header[0] = ((uint8_t)achp_ip_header[0] & 0xf0) | (utp_hl & 0x0f);
+}
+
+DEF_TCPIP_INLINE void m_set_calc_ip_hlen(char* achp_ip_header, uint8_t utp_hl)
+{
+    m_set_ip_hlen_4(achp_ip_header, utp_hl / 4);
+}
+
+DEF_TCPIP_INLINE void m_set_ip_tos(char* achp_ip_header, uint8_t utp_tos)
+{
+    achp_ip_header[1] = utp_tos;
+}
+
+DEF_TCPIP_INLINE void m_set_ip_tlen(char* achp_ip_header, uint16_t usp_tl)
+{
+    achp_ip_header[2] = usp_tl >> 8;
+    achp_ip_header[3] = (char)usp_tl;
+}
+
+DEF_TCPIP_INLINE void m_set_ip_id(char* achp_ip_header, uint16_t usp_id)
+{
+    achp_ip_header[4] = usp_id >> 8;
+    achp_ip_header[5] = (char)usp_id;
+}
+
+DEF_TCPIP_INLINE void m_set_ip_flags(char* achp_ip_header, uint8_t utp_fs)
+{
+    achp_ip_header[6] = ((uint8_t)achp_ip_header[6] & 0x1f) |
+        ((utp_fs << 5) & 0xe0);
+}
+
+DEF_TCPIP_INLINE void m_set_ip_df(char* achp_ip_header, uint8_t utp_df)
+{
+    achp_ip_header[6] = ((uint8_t)achp_ip_header[6] & 0xbf) |
+        ((utp_df << 6) & 0x40);
+}
+
+DEF_TCPIP_INLINE void m_set_ip_mf(char* achp_ip_header, uint8_t utp_mf)
+{
+    achp_ip_header[6] = ((uint8_t)achp_ip_header[6] & 0xdf) |
+        ((utp_mf << 5) & 0x20);
+}
+
+DEF_TCPIP_INLINE void m_set_ip_fofs_8(char* achp_ip_header, uint16_t usp_ofs)
+{
+    achp_ip_header[6] = ((uint8_t)achp_ip_header[6] & 0xe0) |
+        ((usp_ofs >> 8) & 0x1f);
+    achp_ip_header[7] = (char)usp_ofs;
+}
+
+DEF_TCPIP_INLINE void m_set_calc_ip_fofs(char* achp_ip_header, uint16_t usp_ofs)
+{
+    m_set_ip_fofs_8(achp_ip_header, usp_ofs / 8);
+}
+
+DEF_TCPIP_INLINE void m_set_ip_ttl(char* achp_ip_header, uint8_t utp_ttl)
+{
+    achp_ip_header[8] = utp_ttl;
+}
+
+DEF_TCPIP_INLINE void m_set_ip_prot(char* achp_ip_header, uint8_t utp_prot)
+{
+    achp_ip_header[9] = utp_prot;
+}
+
+DEF_TCPIP_INLINE void m_set_ip_chksum(char* achp_ip_header, uint16_t usp_chksum)
+{
+    achp_ip_header[10] = usp_chksum >> 8;
+    achp_ip_header[11] = (char)usp_chksum;
+}
+
+DEF_TCPIP_INLINE void m_set_ip_src_addr(char* achp_ip_header, uint32_t ump_addr)
+{
+    achp_ip_header[12] = ump_addr >> 24;
+    achp_ip_header[13] = ump_addr >> 16;
+    achp_ip_header[14] = ump_addr >> 8;
+    achp_ip_header[15] = (char)ump_addr;
+}
+
+DEF_TCPIP_INLINE void m_set_ip_dst_addr(char* achp_ip_header, uint32_t ump_addr)
+{
+    achp_ip_header[16] = ump_addr >> 24;
+    achp_ip_header[17] = ump_addr >> 16;
+    achp_ip_header[18] = ump_addr >> 8;
+    achp_ip_header[19] = (char)ump_addr;
+}
+
+DEF_TCPIP_INLINE void m_set_ip_src_addr_buf(char* achp_ip_header,
+                                            const char* autp_addr)
+{
+    memcpy(achp_ip_header + 12, autp_addr, 4);
+}
+
+DEF_TCPIP_INLINE void m_set_ip_dst_addr_buf(char* achp_ip_header,
+                                            const char* autp_addr)
+{
+    memcpy(achp_ip_header + 16, autp_addr, 4);
+}
+
+
+/* IPv6 get */
+
+DEF_TCPIP_INLINE uint8_t m_get_ip6_version(const char* achp_ip6_header)
+{
+    return ((uint8_t)achp_ip6_header[0] >> 4) & 0x0f;
+}
+
+DEF_TCPIP_INLINE uint8_t m_get_ip6_tcls(const char* achp_ip6_header)
+{
+    return (((uint8_t)achp_ip6_header[0] << 4) & 0xf0) |
+        (((uint8_t)achp_ip6_header[1] >> 4) & 0x0f);
+}
+
+DEF_TCPIP_INLINE uint32_t m_get_ip6_flow(const char* achp_ip6_header)
+{
+    return (((uint8_t)achp_ip6_header[1] << 16) & 0xf0000) |
+        ((uint8_t)achp_ip6_header[2] << 8) | (uint8_t)achp_ip6_header[3];
+}
+
+DEF_TCPIP_INLINE uint16_t m_get_ip6_plen(const char* achp_ip6_header)
+{
+    return ((uint8_t)achp_ip6_header[4] << 8) | (uint8_t)achp_ip6_header[5];
+}
+
+DEF_TCPIP_INLINE uint8_t m_get_ip6_nh(const char* achp_ip6_header)
+{
+    return (uint8_t)achp_ip6_header[6];
+}
+
+DEF_TCPIP_INLINE uint8_t m_get_ip6_hlim(const char* achp_ip6_header)
+{
+    return (uint8_t)achp_ip6_header[7];
+}
+
+DEF_TCPIP_INLINE const char* m_get_ip6_src_addr(const char* achp_ip6_header)
+{
+    return achp_ip6_header + 8;
+}
+
+DEF_TCPIP_INLINE const char* m_get_ip6_dst_addr(const char* achp_ip6_header)
+{
+    return achp_ip6_header + 24;
+}
+
+
+/* IPv6 set */
+
+DEF_TCPIP_INLINE void m_set_ip6_version(char* achp_ip6_header, uint8_t utp_ver)
+{
+    achp_ip6_header[0] = ((uint8_t)achp_ip6_header[0] & 0x0f) |
+        ((utp_ver << 4) & 0xf0);
+}
+
+DEF_TCPIP_INLINE void m_set_ip6_tcls(char* achp_ip6_header, uint8_t utp_tcls)
+{
+    achp_ip6_header[0] = ((uint8_t)achp_ip6_header[0] & 0xf0) |
+        ((utp_tcls >> 4) & 0x0f);
+    achp_ip6_header[1] = ((uint8_t)achp_ip6_header[1] & 0x0f) |
+        ((utp_tcls << 4) & 0xf0);
+}
+
+DEF_TCPIP_INLINE void m_set_ip6_flow(char* achp_ip6_header, uint32_t ump_flow)
+{
+    achp_ip6_header[1] = ((uint8_t)achp_ip6_header[1] & 0xf0) |
+        ((ump_flow >> 16) & 0x0f);
+    achp_ip6_header[2] = ump_flow >> 8;
+    achp_ip6_header[3] = (char)ump_flow;
+}
+
+DEF_TCPIP_INLINE void m_set_ip6_plen(char* achp_ip6_header, uint16_t usp_plen)
+{
+    achp_ip6_header[4] = usp_plen >> 8;
+    achp_ip6_header[5] = (char)usp_plen;
+}
+
+DEF_TCPIP_INLINE void m_set_ip6_nh(char* achp_ip6_header, uint8_t utp_nh)
+{
+    achp_ip6_header[6] = utp_nh;
+}
+
+DEF_TCPIP_INLINE void m_set_ip6_hlim(char* achp_ip6_header, uint8_t utp_hlim)
+{
+    achp_ip6_header[7] = utp_hlim;
+}
+
+DEF_TCPIP_INLINE void m_set_ip6_src_addr(char* achp_ip6_header,
+                                         const char* autp_addr)
+{
+    memcpy(achp_ip6_header + 8, autp_addr, 16);
+}
+
+DEF_TCPIP_INLINE void m_set_ip6_dst_addr(char* achp_ip6_header,
+                                         const char* autp_addr)
+{
+    memcpy(achp_ip6_header + 24, autp_addr, 16);
+}
+
+
+/* TCP get */
+
+DEF_TCPIP_INLINE uint16_t m_get_tcp_src_port(const char* achp_tcp_header)
+{
+    return ((uint8_t)achp_tcp_header[0] << 8) | (uint8_t)achp_tcp_header[1];
+}
+
+DEF_TCPIP_INLINE uint16_t m_get_tcp_dst_port(const char* achp_tcp_header)
+{
+    return ((uint8_t)achp_tcp_header[2] << 8) | (uint8_t)achp_tcp_header[3];
+}
+
+DEF_TCPIP_INLINE uint32_t m_get_tcp_seqn(const char* achp_tcp_header)
+{
+    return ((uint8_t)achp_tcp_header[4] << 24) |
+	((uint8_t)achp_tcp_header[5] << 16) |
+        ((uint8_t)achp_tcp_header[6] << 8) |
+	(uint8_t)achp_tcp_header[7];
+}
+
+DEF_TCPIP_INLINE uint32_t m_get_tcp_ackn(const char* achp_tcp_header)
+{
+    return ((uint8_t)achp_tcp_header[8] << 24) |
+	((uint8_t)achp_tcp_header[9] << 16) |
+        ((uint8_t)achp_tcp_header[10] << 8) |
+	(uint8_t)achp_tcp_header[11];
+}
+
+DEF_TCPIP_INLINE uint8_t m_get_tcp_hlen_4(const char* achp_tcp_header)
+{
+    return ((uint8_t)achp_tcp_header[12] >> 4) & 0x0f;
+}
+
+DEF_TCPIP_INLINE uint8_t m_get_calc_tcp_hlen(const char* achp_tcp_header)
+{
+    return m_get_tcp_hlen_4(achp_tcp_header) * 4;
+}
+
+DEF_TCPIP_INLINE uint8_t m_get_tcp_resv(const char* achp_tcp_header)
+{
+    return (((uint8_t)achp_tcp_header[12] << 2) & 0x3c) |
+        (((uint8_t)achp_tcp_header[13] >> 6) & 0x03);
+}
+
+DEF_TCPIP_INLINE uint8_t m_get_tcp_flags(const char* achp_tcp_header)
+{
+    return (uint8_t)achp_tcp_header[13] & 0x3f;
+}
+
+DEF_TCPIP_INLINE uint8_t m_get_tcp_urg(const char* achp_tcp_header)
+{
+    return ((uint8_t)achp_tcp_header[13] >> 5) & 0x01;
+}
+
+DEF_TCPIP_INLINE uint8_t m_get_tcp_ack(const char* achp_tcp_header)
+{
+    return ((uint8_t)achp_tcp_header[13] >> 4) & 0x01;
+}
+
+DEF_TCPIP_INLINE uint8_t m_get_tcp_psh(const char* achp_tcp_header)
+{
+    return ((uint8_t)achp_tcp_header[13] >> 3) & 0x01;
+}
+
+DEF_TCPIP_INLINE uint8_t m_get_tcp_rst(const char* achp_tcp_header)
+{
+    return ((uint8_t)achp_tcp_header[13] >> 2) & 0x01;
+}
+
+DEF_TCPIP_INLINE uint8_t m_get_tcp_syn(const char* achp_tcp_header)
+{
+    return ((uint8_t)achp_tcp_header[13] >> 1) & 0x01;
+}
+
+DEF_TCPIP_INLINE uint8_t m_get_tcp_fin(const char* achp_tcp_header)
+{
+    return (uint8_t)achp_tcp_header[13] & 0x01;
+}
+
+DEF_TCPIP_INLINE uint8_t m_get_tcp_flags_urg(uint8_t utp_tcp_flags)
+{
+    return (utp_tcp_flags >> 5) & 0x01;
+}
+
+DEF_TCPIP_INLINE uint8_t m_get_tcp_flags_ack(uint8_t utp_tcp_flags)
+{
+    return (utp_tcp_flags >> 4) & 0x01;
+}
+
+DEF_TCPIP_INLINE uint8_t m_get_tcp_flags_psh(uint8_t utp_tcp_flags)
+{
+    return (utp_tcp_flags >> 3) & 0x01;
+}
+
+DEF_TCPIP_INLINE uint8_t m_get_tcp_flags_rst(uint8_t utp_tcp_flags)
+{
+    return (utp_tcp_flags >> 2) & 0x01;
+}
+
+DEF_TCPIP_INLINE uint8_t m_get_tcp_flags_syn(uint8_t utp_tcp_flags)
+{
+    return (utp_tcp_flags >> 1) & 0x01;
+}
+
+DEF_TCPIP_INLINE uint8_t m_get_tcp_flags_fin(uint8_t utp_tcp_flags)
+{
+    return utp_tcp_flags & 0x01;
+}
+
+DEF_TCPIP_INLINE uint16_t m_get_tcp_window(const char* achp_tcp_header)
+{
+    return ((uint8_t)achp_tcp_header[14] << 8) | (uint8_t)achp_tcp_header[15];
+}
+
+DEF_TCPIP_INLINE uint16_t m_get_tcp_chksum(const char* achp_tcp_header)
+{
+    return ((uint8_t)achp_tcp_header[16] << 8) | (uint8_t)achp_tcp_header[17];
+}
+
+DEF_TCPIP_INLINE uint16_t m_get_tcp_urgent(const char* achp_tcp_header)
+{
+    return ((uint8_t)achp_tcp_header[18] << 8) | (uint8_t)achp_tcp_header[19];
+}
+
+
+/* TCP set */
+
+DEF_TCPIP_INLINE void m_set_tcp_src_port(char* achp_tcp_header,
+                                         uint16_t asp_port)
+{
+    achp_tcp_header[0] = asp_port >> 8;
+    achp_tcp_header[1] = (char)asp_port;
+}
+
+DEF_TCPIP_INLINE void m_set_tcp_dst_port(char* achp_tcp_header,
+                                         uint16_t asp_port)
+{
+    achp_tcp_header[2] = asp_port >> 8;
+    achp_tcp_header[3] = (char)asp_port;
+}
+
+DEF_TCPIP_INLINE void m_set_tcp_seqn(char* achp_tcp_header, uint32_t ump_seqn)
+{
+    achp_tcp_header[4] = ump_seqn >> 24;
+    achp_tcp_header[5] = ump_seqn >> 16;
+    achp_tcp_header[6] = ump_seqn >> 8;
+    achp_tcp_header[7] = (char)ump_seqn;
+}
+
+DEF_TCPIP_INLINE void m_set_tcp_ackn(char* achp_tcp_header, uint32_t ump_ackn)
+{
+    achp_tcp_header[8] = ump_ackn >> 24;
+    achp_tcp_header[9] = ump_ackn >> 16;
+    achp_tcp_header[10] = ump_ackn >> 8;
+    achp_tcp_header[11] = (char)ump_ackn;
+}
+
+DEF_TCPIP_INLINE void m_set_tcp_hlen_4(char* achp_tcp_header, uint8_t utp_hl)
+{
+    achp_tcp_header[12] = ((uint8_t)achp_tcp_header[12] & 0x0f) |
+	((utp_hl << 4) & 0xf0);
+}
+
+DEF_TCPIP_INLINE void m_set_calc_tcp_hlen(char* achp_tcp_header, uint8_t utp_hl)
+{
+    m_set_tcp_hlen_4(achp_tcp_header, utp_hl / 4);
+}
+
+DEF_TCPIP_INLINE void m_set_tcp_resv(char* achp_tcp_header, uint8_t utp_res)
+{
+    achp_tcp_header[12] = ((uint8_t)achp_tcp_header[12] & 0xf0) |
+        ((utp_res >> 2) & 0x0f);
+    achp_tcp_header[13] = ((uint8_t)achp_tcp_header[13] & 0x3f) |
+        ((utp_res << 6) & 0xc0);
+}
+
+DEF_TCPIP_INLINE void m_set_tcp_flags(char* achp_tcp_header, uint8_t utp_fs)
+{
+    achp_tcp_header[13] = ((uint8_t)achp_tcp_header[13] & 0xc0) |
+        (utp_fs & 0x3f);
+}
+
+DEF_TCPIP_INLINE void m_set_tcp_urg(char* achp_tcp_header, uint8_t utp_urg)
+{
+    achp_tcp_header[13] = ((uint8_t)achp_tcp_header[13] & 0xdf) |
+        ((utp_urg << 5) & 0x20);
+}
+
+DEF_TCPIP_INLINE void m_set_tcp_ack(char* achp_tcp_header, uint8_t utp_ack)
+{
+    achp_tcp_header[13] = ((uint8_t)achp_tcp_header[13] & 0xef) |
+        ((utp_ack << 4) & 0x10);
+}
+
+DEF_TCPIP_INLINE void m_set_tcp_psh(char* achp_tcp_header, uint8_t utp_psh)
+{
+    achp_tcp_header[13] = ((uint8_t)achp_tcp_header[13] & 0xf7) |
+        ((utp_psh << 3) & 0x08);
+}
+
+DEF_TCPIP_INLINE void m_set_tcp_rst(char* achp_tcp_header, uint8_t utp_rst)
+{
+    achp_tcp_header[13] = ((uint8_t)achp_tcp_header[13] & 0xfb) |
+        ((utp_rst << 2) & 0x04);
+}
+
+DEF_TCPIP_INLINE void m_set_tcp_syn(char* achp_tcp_header, uint8_t utp_syn)
+{
+    achp_tcp_header[13] = ((uint8_t)achp_tcp_header[13] & 0xfd) |
+        ((utp_syn << 1) & 0x02);
+}
+
+DEF_TCPIP_INLINE void m_set_tcp_fin(char* achp_tcp_header, uint8_t utp_fin)
+{
+    achp_tcp_header[13] = (achp_tcp_header[13] & 0xfe) | (utp_fin & 0x01);
+}
+
+DEF_TCPIP_INLINE uint8_t m_set_tcp_flags_urg(uint8_t utp_tcp_flags,
+                                             uint8_t utp_urg)
+{
+    return (utp_tcp_flags & 0xdf) | ((utp_urg << 5) & 0x20);
+}
+
+DEF_TCPIP_INLINE uint8_t m_set_tcp_flags_ack(uint8_t utp_tcp_flags,
+                                             uint8_t utp_ack)
+{
+    return (utp_tcp_flags & 0xef) | ((utp_ack << 4) & 0x10);
+}
+
+DEF_TCPIP_INLINE uint8_t m_set_tcp_flags_psh(uint8_t utp_tcp_flags,
+                                             uint8_t utp_psh)
+{
+    return (utp_tcp_flags & 0xf7) | ((utp_psh << 3) & 0x08);
+}
+
+DEF_TCPIP_INLINE uint8_t m_set_tcp_flags_rst(uint8_t utp_tcp_flags,
+                                             uint8_t utp_rst)
+{
+    return (utp_tcp_flags & 0xfb) | ((utp_rst << 2) & 0x04);
+}
+
+DEF_TCPIP_INLINE uint8_t m_set_tcp_flags_syn(uint8_t utp_tcp_flags,
+                                             uint8_t utp_syn)
+{
+    return (utp_tcp_flags & 0xfd) | ((utp_syn << 1) & 0x02);
+}
+
+DEF_TCPIP_INLINE uint8_t m_set_tcp_flags_fin(uint8_t utp_tcp_flags,
+                                             uint8_t utp_fin)
+{
+    return (utp_tcp_flags & 0xfe) | (utp_fin & 0x01);
+}
+
+DEF_TCPIP_INLINE void m_set_tcp_window(char* achp_tcp_header, uint16_t usp_win)
+{
+    achp_tcp_header[14] = usp_win >> 8;
+    achp_tcp_header[15] = (char)usp_win;
+}
+
+DEF_TCPIP_INLINE void m_set_tcp_chksum(char* achp_tcp_header,
+                                       uint16_t usp_chksum)
+{
+    achp_tcp_header[16] = usp_chksum >> 8;
+    achp_tcp_header[17] = (char)usp_chksum;
+}
+
+DEF_TCPIP_INLINE void m_set_tcp_urgent(char* achp_tcp_header, uint16_t usp_urg)
+{
+    achp_tcp_header[18] = usp_urg >> 8;
+    achp_tcp_header[19] = (char)usp_urg;
+}
+
+#undef DEF_TCPIP_INLINE
+
+static const uint8_t utd_tcp_ack = 0x10;
+static const uint8_t utd_tcp_syn = 0x02;
+static const uint8_t utd_tcp_syn_ack = 0x12;
+static const uint8_t utd_tcp_fin = 0x01;
+static const uint8_t utd_tcp_fin_ack = 0x11;
+static const uint8_t utd_tcp_rst = 0x04;
+static const uint8_t utd_tcp_rst_ack = 0x14;
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+#if 0
+} /* so as not to confuse auto-indentation */
+#endif
+
+/* others */
+
+uint16_t m_calc_ip_chksum(const char* achp_ip_header);
+
+/*
+ * TCP checksum calculation:
+ *
+ * To calculate a TCP segment checksum, start with the partial checksum
+ * for the pseudo header excluding the length. This is done using
+ * m_calc_ip_tcp_pseudo_chksum() or m_calc_ip6_tcp_pseudo_chksum().
+ *
+ * Next, update the partial checksum for the TCP data. If the TCP data is
+ * contiguous, this is done using one call to m_calc_tcp_data_chksum().
+ * If the TCP data is in non-contiguous blocks, either
+ * m_calc_tcp_data_chksum() or m_calc_tcp_odd_data_chksum() must be called
+ * for each block. The offset for the first byte of each block should be
+ * used to decide wether to choose the even or odd variant.
+ *
+ * Finally, m_calc_tcp_chksum() is called with the partial checksum and the
+ * data length. The data length is used to complete the pseudo header.
+ *
+ * Note that m_calc_ip_tcp_pseudo_chksum() or m_calc_ip6_tcp_pseudo_chksum()
+ * may be substituted with a call to m_calc_tcp_data_chksum(), with the data
+ * and data length parameters pointing to the source and destination
+ * IP or IPv6 addresses, and the initial partial checksum parameter set to 6.
+ */
+
+uint16_t m_calc_ip_tcp_pseudo_chksum(const char* achp_ip_header);
+uint16_t m_calc_ip6_tcp_pseudo_chksum(const char* achp_ip6_header);
+
+uint16_t m_calc_tcp_data_chksum(const char* achp_data, uint32_t ump_len,
+                                uint16_t usp_part);
+uint16_t m_calc_tcp_odd_data_chksum(const char* achp_data, uint32_t ump_len,
+                                    uint16_t usp_part);
+uint16_t m_calc_tcp_chksum(const char* achp_tcp_header, uint32_t ump_data_len,
+                           uint16_t usp_part);
+
+/*
+ * If a TCP packet is modified, the checksum might be updated without a
+ * complete recalculation.
+ *
+ * m_tcp_chksum_add() updates the checksum to include some data. The length
+ * in the pseudo header is not updated here. If the data to add has an odd
+ * offset, use m_tcp_chksum_odd_add() instead.
+ *
+ * m_tcp_chksum_sub() and m_tcp_chksum_odd_sub() update the checksum to exclude
+ * some data which was previously included in the checksum.
+ *
+ * If a block of data had an odd offset and was shifted to an even offet,
+ * m_tcp_chksum_odd_to_even() should be called. m_tcp_chksum_even_to_odd()
+ * works similarly.
+ *
+ * If the data length of a TCP segment was changed, m_tcp_chksum_change_len()
+ * should be called together with the functions described above. The order
+ * does not matter.
+ */
+uint16_t m_tcp_chksum_add(uint16_t usp_chksum,
+                          const char* achp_data, uint32_t ump_len);
+uint16_t m_tcp_chksum_odd_add(uint16_t usp_chksum,
+                              const char* achp_data, uint32_t ump_len);
+uint16_t m_tcp_chksum_sub(uint16_t usp_chksum,
+                          const char* achp_data, uint32_t ump_len);
+uint16_t m_tcp_chksum_odd_sub(uint16_t usp_chksum,
+                              const char* achp_data, uint32_t ump_len);
+uint16_t m_tcp_chksum_odd_to_even(uint16_t usp_chksum,
+                                  const char* achp_data, uint32_t ump_len);
+uint16_t m_tcp_chksum_even_to_odd(uint16_t usp_chksum,
+                                  const char* achp_data, uint32_t ump_len);
+uint16_t m_tcp_chksum_change_len(uint16_t usp_chksum, int32_t ump_add_len);
+
+bool m_is_ip_size_ok(const char* achp_ip_header, uint32_t ump_hsize);
+bool m_is_ip6_size_ok(const char* achp_ip6_header, uint32_t ump_hsize);
+bool m_is_tcp_size_ok(const char* achp_tcp_header, uint32_t ump_hsize,
+                      uint32_t ump_segsize);
+
+const char* m_first_tcp_option(const char* achp_tcp_header,
+                               const char* achp_tcp_header_end);
+const char* m_next_tcp_option(const char* achp_tcp_option,
+                              const char* achp_tcp_header_end);
+
+uint32_t m_ip_tcp_answer_reset(char* achp_answer, uint32_t ump_alen,
+                               const char* achp_header, uint32_t ump_hlen,
+                               uint16_t usp_id);
+
+uint32_t m_ip6_tcp_answer_reset(char* achp_answer, uint32_t ump_alen,
+                                const char* achp_header, uint32_t ump_hlen);
+
+#if 0
+{ /* so as not to confuse auto-indentation */
+#endif
+#ifdef __cplusplus
+} /* extern "C" */
+#endif
+
+
+#endif /* HOB_HTCP_HDR_01_H */
Index: xiipgw08-seli.cpp
===================================================================
--- xiipgw08-seli.cpp	(revision 2)
+++ xiipgw08-seli.cpp	(revision 6)
@@ -3170,6 +3170,9 @@
                                       struct dsd_unicode_string *adsp_ucs_dns_name,
                                       struct dsd_target_ineta_1 *adsp_target_ineta_1,
                                       int imp_port ) {
+#ifndef B121114
+   BOOL       bol_rc;                       /* return code             */
+#endif
    int        iml_rc;                       /* return code             */
    int        iml1;                         /* working variable        */
    int        iml_port;                     /* port to check           */
@@ -3179,12 +3182,14 @@
    int        iml_stack;                    /* position in stack       */
    int        iml_is1_cur;                  /* number current INETA    */
    char       *achl_w1;                     /* working variable        */
+#ifdef B121114
    char       *achl_mask_cur;               /* current position in mask */
    char       *achl_mask_end;               /* end of mask             */
    char       *achl_inp;                    /* position input          */
 #define DEF_MASK_STACK 16
    char       *achrl_sm[ DEF_MASK_STACK ];
    char       *achrl_si[ DEF_MASK_STACK ];
+#endif
    struct dsd_ineta_single_1 *adsl_is1_cur;  /* current INETA          */
    struct hostent *adsl_hostentry;          /* for gethostbyname()     */
    struct addrinfo *adsl_addrinfo_w1;
@@ -3205,12 +3210,21 @@
    }
    adsl_hostentry = NULL;                   /* no gethostbyname()      */
    achl_w1 = (char *) adsp_ucs_dns_name->ac_str;
+#ifdef B121114
    if (   (adsp_ucs_dns_name->iec_chs_str == D_CHARSET_IP)
        && (adsp_ucs_dns_name->imc_len_str == -1)) {
      goto p_dns_20;                         /* DNS name at achl_w1     */
    }
    iml_rc = m_cpy_vx_ucs( chrl_work1, sizeof(chrl_work1), D_CHARSET_IP,
                           adsp_ucs_dns_name );
+#else
+   if (   (adsp_ucs_dns_name->iec_chs_str == ied_chs_idna_1)
+       && (adsp_ucs_dns_name->imc_len_str == -1)) {
+     goto p_dns_20;                         /* DNS name at achl_w1     */
+   }
+   iml_rc = m_cpy_vx_ucs( chrl_work1, sizeof(chrl_work1), ied_chs_idna_1,
+                          adsp_ucs_dns_name );
+#endif
    if (iml_rc <= 0) {                       /* did not copy DNS name   */
      m_hlnew_printf( HLOG_INFO1, "HWSPnnnnW GATE=%(ux)s SNO=%08d INETA=%s check target-filter could not copy DNS name",
                      adsp_conn1->adsc_gate1 + 1,
@@ -3234,9 +3248,13 @@
 #ifndef HL_UNIX
 #define D_TEMP_ERROR WSAHOST_NOT_FOUND
 #else
+#ifdef B121115
 // to-do 13.02.12 KB error number
 #define D_TEMP_ERROR EPERM
+#else
+#define D_TEMP_ERROR EAI_NONAME
 #endif
+#endif
    if (iml_rc != D_TEMP_ERROR) {            /* error occured           */
      m_hlnew_printf( HLOG_INFO1, "HWSPnnnnW GATE=%(ux)s SNO=%08d INETA=%s check target-filter getaddrinfo() returned %d %d.",
                      adsp_conn1->adsc_gate1 + 1,
@@ -3312,6 +3330,7 @@
 #endif
      goto p_cht_dns_60;                     /* ignore this element     */
    }
+#ifdef B121114
    iml_stack = 0;                           /* clear stack index       */
    achl_mask_cur = (char *) adsp_targfi_1
                      + ((struct dsd_targfi_ele_1 *) (adsp_targfi_1 + 1)
@@ -3380,6 +3399,21 @@
    goto plook62;

    p_cht_dns_40:                            /* this element matches    */
+#endif
+#ifndef B121114
+   bol_rc = m_cmp_wc_i_vx_vx( &iml_rc,
+                              achl_w1, -1, ied_chs_idna_1,
+                              (char *) adsp_targfi_1
+                                + ((struct dsd_targfi_ele_1 *) (adsp_targfi_1 + 1)
+                                     + iml_no_targfi_ele_1)->imc_off_dns_name,
+                              ((struct dsd_targfi_ele_1 *) (adsp_targfi_1 + 1)
+                                 + iml_no_targfi_ele_1)->imc_len_dns_name,
+                              ied_chs_utf_8 );
+   if (   (bol_rc == FALSE)
+       || (iml_rc != 0)) {
+     goto p_cht_dns_60;                     /* mask does not match     */
+   }
+#endif
 #ifdef B110205
    if (((struct dsd_targfi_ele_1 *) (adsp_targfi_1 + 1)
          + iml_no_targfi_ele_1)->boc_allow) {
@@ -4367,7 +4401,11 @@
 #ifdef B101007
        dsl_work_i.dsc_ineta_raws_1.umc_taif_ineta = adsl_raw_packet_if_conf->umc_ta_ineta_local ^ 0X03;
 #endif
+#ifdef B130108
        dsl_work_i.dsc_ineta_raws_1.umc_taif_ineta = adsl_raw_packet_if_conf->umc_ta_ineta_local;
+#else
+       dsl_work_i.dsc_ineta_raws_1.umc_taif_ineta = *((UNSIG_MED *) adsl_raw_packet_if_conf->achc_ar_ta_ineta_ipv4);  /* array <TUN-adapter-ineta> IPV4 */
+#endif
 #ifndef XYZ1                                /* set route with next hop */
        *((unsigned char *) &dsl_work_i.dsc_ineta_raws_1.umc_taif_ineta + sizeof(int) - 1) ^= 0X03;
 #endif
@@ -5866,8 +5904,11 @@
      memcpy( adsl_wt1_w1->chrc_wtrt_id, "CTUNINNU", sizeof(adsl_wt1_w1->chrc_wtrt_id) );  /* Id of trace record */
 #define ADSL_WTR_G1 ((struct dsd_wsp_trace_record *) (adsl_wt1_w1 + 1))
      iml1 = m_hlsnprintf( (char *) (ADSL_WTR_G1 + 1), 256, ied_chs_ansi_819,
-                          "m_prepare_htun_ineta_htcp( ... , %d ) group=%(ucs)s userid=%(ucs)s.",
+                          "l%05d m_prepare_htun_ineta_htcp( ... , %d ) ac_conn1 %p SNO=%08d group=%(ucs)s userid=%(ucs)s.",
+                          __LINE__,
                           iep_irs_def,
+                          adsp_conn1,
+                          adsp_conn1->dsc_co_sort.imc_sno,
                           &adsl_ineta_raws_1_new->dsc_user_group,
                           &adsl_ineta_raws_1_new->dsc_user_name );
      ADSL_WTR_G1->iec_wtrt = ied_wtrt_text;  /* text passed            */
@@ -5939,6 +5980,8 @@
    struct dsd_appl_port_conf *adsl_appl_port_conf_w1;  /* configured ports for appl */
    struct dsd_cluster_ineta_wait *adsl_cluster_ineta_wait_ch;  /* wait to process INETAs this cluster member */
    struct dsd_cluster_ineta_wait *adsl_cluster_ineta_wait_w1;  /* wait to process INETAs this cluster member */
+   struct sockaddr *adsl_soa_l;             /* local sockaddr          */
+   struct dsd_wsp_trace_1 *adsl_wt1_w1;     /* WSP trace control record */
    struct dsd_htree1_avl_cntl *adsl_hac_ineta;
    struct dsd_htree1_avl_cntl *adsl_hac_user_i;
    struct dsd_htree1_avl_entry *adsl_sort_ineta_w1;
@@ -6079,11 +6122,17 @@
 #endif
      }
 #endif
+#ifndef HL_UNIX
      if (iml_ineta_family == AF_INET) {     /* family IPV4 / IPV6      */
        adsp_ineta_raws_1->umc_index_if_arp_ipv4 = dss_ser_thr_ctrl.umc_index_if_arp;  /* holds index of compatible IF for ARP */
        adsp_ineta_raws_1->umc_index_if_route_ipv4 = dss_ser_thr_ctrl.umc_index_if_route;  /* holds index of compatible IF for routes */
+#ifdef B130109
        adsp_ineta_raws_1->umc_taif_ineta_ipv4 = adsl_raw_packet_if_conf->umc_taif_ineta;  /* <TUN-adapter-use-interface-ineta> */
+#else
+       adsp_ineta_raws_1->umc_taif_ineta_ipv4 = adsl_raw_packet_if_conf->umc_taif_ineta_ipv4;  /* <TUN-adapter-use-interface-ineta> */
+#endif
      }
+#endif
    }
    if (bol_search_appl == FALSE) {          /* INETA PPP               */
      goto p_new_ineta_00;                   /* needs new INETA         */
@@ -6116,7 +6165,11 @@
      }
      if (dsl_htree1_work.adsc_found == NULL) break;  /* entry not found */
      /* check if userid and group are still the same                   */
+#ifdef B121212
 #define ADSL_INETA_RAWS_1_G ((struct dsd_ineta_raws_1 *) ((char *) dsl_htree1_work.adsc_found - iml_disp_sort_ineta))
+#else
+#define ADSL_INETA_RAWS_1_G ((struct dsd_ineta_raws_1 *) ((char *) dsl_htree1_work.adsc_found - offsetof( struct dsd_ineta_raws_1, dsc_sort_user )))
+#endif
      bol1 = m_cmpi_ucs_ucs( &iml_cmp,
                             &adsp_ineta_raws_1->dsc_user_name,
                             &ADSL_INETA_RAWS_1_G->dsc_user_name );
@@ -6142,7 +6195,11 @@
    bol_route_add = FALSE;                   /* add a route             */

    /* check which port can be used                                     */
+#ifdef B121212
 #define ADSL_INETA_RAWS_1_G ((struct dsd_ineta_raws_1 *) ((char *) dsl_htree1_work.adsc_found - iml_disp_sort_ineta))
+#else
+#define ADSL_INETA_RAWS_1_G ((struct dsd_ineta_raws_1 *) ((char *) dsl_htree1_work.adsc_found - offsetof( struct dsd_ineta_raws_1, dsc_sort_user )))
+#endif
    memcpy( achl_ineta_raws_t,
            (char *) ADSL_INETA_RAWS_1_G + iml_disp_ineta,
            iml_len_ineta );
@@ -7287,6 +7344,11 @@
        achl_avl_error = chrl_work1;
        goto p_ret_err;                      /* no INETA found          */
      }
+     if (iml_ineta_family == AF_INET) {     /* family IPV4 / IPV6 - IPV4 */
+       adsp_ineta_raws_1->dsc_tun_contr_ineta.dsc_soa_local_ipv4.sin_port = htons( adsp_ineta_raws_1->usc_appl_port );
+     } else {                               /* IPV6                    */
+       adsp_ineta_raws_1->dsc_tun_contr_ineta.dsc_soa_local_ipv6.sin6_port = htons( adsp_ineta_raws_1->usc_appl_port );
+     }
      bol1 = m_htree1_avl_insert( NULL, adsl_hac_user_i,
                                  &dsl_htree1_work, &adsp_ineta_raws_1->dsc_sort_user );
      if (bol1 == FALSE) {                   /* error occured           */
@@ -7335,11 +7397,23 @@
    }
    dsg_global_lock.m_leave();
    if (bol_ser_post) {                      /* post serialize thread   */
-     iml_rc = dss_ser_thr_ctrl.dsc_event_thr.m_post( &iml_error );  /* event for serial thread */
-     if (iml_rc < 0) {                       /* error occured           */
-       m_hlnew_printf( HLOG_WARN1, "HWSPM155W l%05d update HOB-TUN INETA event serial m_post Return Code %d Error %d.",
-                     __LINE__, iml_rc, iml_error );
+#ifdef HL_UNIX
+     if (dss_loconf_1.boc_listen_gw == FALSE) {  /* do not use listen gateway */
+#endif
+       iml_rc = dss_ser_thr_ctrl.dsc_event_thr.m_post( &iml_error );  /* event for serial thread */
+       if (iml_rc < 0) {                    /* error occured           */
+         m_hlnew_printf( HLOG_WARN1, "HWSPM155W l%05d update HOB-TUN INETA event serial m_post Return Code %d Error %d.",
+                         __LINE__, iml_rc, iml_error );
+       }
+#ifdef HL_UNIX
+     } else {                               /* do use listen gateway   */
+       iml_rc = write( imrs_m_fd_pipe[1], vprs_message_work, sizeof(vprs_message_work) );
+       if (iml_rc != sizeof(vprs_message_work)) {
+         m_hlnew_printf( HLOG_WARN1, "HWSPMnnnW m_update_htun_ineta() l%05d write pipe work error %d %d.",
+                         __LINE__, iml_rc, errno );
+       }
      }
+#endif
    }
    while (adsl_cluster_ineta_wait_ch) {     /* wait to process INETAs this cluster member */
      adsl_cluster_ineta_wait_w1 = adsl_cluster_ineta_wait_ch;  /* get this entry */
@@ -7392,6 +7466,64 @@
    bol1 = FALSE;                            /* return error            */

    p_ret_end:                               /* housekeeping            */
+   if (img_wsp_trace_core_flags1 & HL_WT_CORE_HOB_TUN) {  /* HOB-TUN   */
+     adsl_wt1_w1 = (struct dsd_wsp_trace_1 *) m_proc_alloc();  /* WSP trace record */
+     memset( adsl_wt1_w1, 0, sizeof(struct dsd_wsp_trace_1) + sizeof(struct dsd_wsp_trace_record) );  /* clear WSP trace record */
+     adsl_wt1_w1->iec_wtrt = ied_wtrt_trace_data;  /* trace data       */
+     adsl_wt1_w1->ilc_epoch = m_get_rand_epoch_ms();  /* time trace record recorded */
+     memcpy( adsl_wt1_w1->chrc_wtrt_id, "CTUNIADU", sizeof(adsl_wt1_w1->chrc_wtrt_id) );  /* Id of trace record */
+#define ADSL_WTR_G1 ((struct dsd_wsp_trace_record *) (adsl_wt1_w1 + 1))
+     if (bol1 == FALSE) {                   /* no INETA found          */
+       ADSL_WTR_G1->imc_length = sprintf( (char *) (ADSL_WTR_G1 + 1),
+                                          "l%05d m_update_htun_ineta( %p ) -  ac_conn1 %p SNO=%08d - returns FALSE, no INETA",
+                                          __LINE__,
+                                          adsp_ineta_raws_1,
+                                          adsp_conn1,
+                                          adsp_conn1->dsc_co_sort.imc_sno );
+     } else {                               /* INETA inserted          */
+       if (iml_ineta_family = AF_INET) {    /* IPV4                    */
+         adsl_soa_l = (struct sockaddr *) &adsp_ineta_raws_1->dsc_tun_contr_ineta.dsc_soa_local_ipv4;
+         iml1 = sizeof(struct sockaddr_in);
+       } else {                             /* IPV6                    */
+         adsl_soa_l = (struct sockaddr *) &adsp_ineta_raws_1->dsc_tun_contr_ineta.dsc_soa_local_ipv6;
+         iml1 = sizeof(struct sockaddr_in6);
+       }
+       iml_rc = getnameinfo( adsl_soa_l, iml1,
+                             chrl_work1, sizeof(chrl_work1), 0, 0, NI_NUMERICHOST );
+       if (iml_rc) {                            /* error occured           */
+         strcpy( chrl_work1, "???" );
+       }
+       ADSL_WTR_G1->imc_length = sprintf( (char *) (ADSL_WTR_G1 + 1),
+                                          "l%05d m_update_htun_ineta( %p ) -  ac_conn1 %p SNO=%08d - returns TRUE, INETA \"%s\"",
+                                          __LINE__,
+                                          adsp_ineta_raws_1,
+                                          adsp_conn1,
+                                          adsp_conn1->dsc_co_sort.imc_sno,
+                                          chrl_work1 );
+     }
+     ADSL_WTR_G1->iec_wtrt = ied_wtrt_text;  /* text passed            */
+     ADSL_WTR_G1->achc_content              /* content of text / data  */
+       = (char *) (ADSL_WTR_G1 + 1);
+     adsl_wt1_w1->adsc_wsp_trace_record = ADSL_WTR_G1;  /* WSP trace records */
+     if (   (bol1)                          /* INETA inserted          */
+         && (bol_search_appl)) {            /* search appl             */
+       achl1 = (char *) (((long long int) ((char *) (ADSL_WTR_G1 + 1) + ADSL_WTR_G1->imc_length + sizeof(void *) - 1)) & (0 - sizeof(void *)));
+#define ADSL_WTR_G2 ((struct dsd_wsp_trace_record *) achl1)
+       memset( ADSL_WTR_G2, 0, sizeof(struct dsd_wsp_trace_record) );  /* clear WSP trace record */
+       ADSL_WTR_G2->imc_length = m_hlsnprintf( (char *) (ADSL_WTR_G2 + 1), 256, ied_chs_ansi_819,
+                                               "  TCP-port %d group=%(ucs)s userid=%(ucs)s.",
+                                               adsp_ineta_raws_1->usc_appl_port,
+                                               &adsp_ineta_raws_1->dsc_user_group,
+                                               &adsp_ineta_raws_1->dsc_user_name );
+       ADSL_WTR_G2->iec_wtrt = ied_wtrt_text;  /* text passed          */
+       ADSL_WTR_G2->achc_content            /* content of text / data  */
+         = (char *) (ADSL_WTR_G2 + 1);
+       ADSL_WTR_G1->adsc_next = ADSL_WTR_G2;  /* append to chain       */
+#undef ADSL_WTR_G2
+     }
+#undef ADSL_WTR_G1
+     m_wsp_trace_out( adsl_wt1_w1 );        /* output of WSP trace record */
+   }
    if (bol_err_savebl_full) {               /* give error message later */
      m_hlnew_printf( HLOG_WARN1, "HWSPM141W update HOB-TUN INETA buffer with INETAs overflow" );
    }
@@ -9388,11 +9520,12 @@
    int        iml_rc;                       /* return code 1           */
    int        iml_error;                    /* return code 2           */
    int        iml_cmp;                      /* for compare operations  */
+#ifdef XYZ1
    unsigned short int usl_ineta_length;     /* length of INETA         */
+#endif
    BOOL       bol_no_tun;                   /* INETA not for TUN-adapter */
-   BOOL       bol_search_appl;              /* search appl             */
    BOOL       bol_failed_del_appl;          /* failed to delete appl   */
-   BOOL       bol_route_del;                /* delete the route        */
+   BOOL       bol_route_del_ipv4;           /* delete the route IPV4   */
    BOOL       bol_ser_post;                 /* post serialize thread   */
    char       *achl_avl_error;              /* error code AVL tree     */
    struct dsd_ser_thr_task *adsl_ser_thr_task_free;  /* task for serial thread */
@@ -9400,6 +9533,8 @@
    struct dsd_ser_thr_task *adsl_ser_thr_task_w2;  /* task for serial thread */
    struct dsd_htree1_avl_cntl *adsl_hac_ineta;
    struct dsd_htree1_avl_cntl *adsl_hac_user_i;
+   struct dsd_wsp_trace_1 *adsl_wt1_w1;     /* WSP trace control record */
+   DSD_CONN_G *adsl_conn1;                  /* connection              */
    struct dsd_htree1_avl_work dsl_htree1_work;  /* work-area for AVL-Tree */
    struct {
      struct dsd_auxf_1 dsc_auxf_1;
@@ -9407,6 +9542,38 @@
    } dsl_work_i;
    char       chrl_work1[ 256 ];            /* work area               */

+#ifdef TRACEHL1
+   m_hlnew_printf( HLOG_XYZ1, "HOB-TUN l%05d m_cleanup_htun_ineta( %p ) called",
+                   __LINE__, adsp_ineta_raws_1 );
+#endif
+   if (img_wsp_trace_core_flags1 & HL_WT_CORE_HOB_TUN) {  /* HOB-TUN   */
+     adsl_conn1 = (DSD_CONN_G *) adsp_ineta_raws_1->ac_conn1;
+     adsl_wt1_w1 = (struct dsd_wsp_trace_1 *) m_proc_alloc();  /* WSP trace record */
+     memset( adsl_wt1_w1, 0, sizeof(struct dsd_wsp_trace_1) + sizeof(struct dsd_wsp_trace_record) );  /* clear WSP trace record */
+     adsl_wt1_w1->iec_wtrt = ied_wtrt_trace_data;  /* trace data       */
+     adsl_wt1_w1->ilc_epoch = m_get_rand_epoch_ms();  /* time trace record recorded */
+     memcpy( adsl_wt1_w1->chrc_wtrt_id, "CTUNIADC", sizeof(adsl_wt1_w1->chrc_wtrt_id) );  /* Id of trace record */
+#define ADSL_WTR_G1 ((struct dsd_wsp_trace_record *) (adsl_wt1_w1 + 1))
+     if (adsl_conn1 == NULL) {              /* no connection           */
+       ADSL_WTR_G1->imc_length = sprintf( (char *) (ADSL_WTR_G1 + 1),
+                                          "l%05d m_cleanup_htun_ineta( %p ) -  ac_conn1 NULL",
+                                          __LINE__,
+                                          adsp_ineta_raws_1 );
+     } else {                               /* with connection         */
+       ADSL_WTR_G1->imc_length = sprintf( (char *) (ADSL_WTR_G1 + 1),
+                                          "l%05d m_cleanup_htun_ineta( %p ) -  ac_conn1 %p SNO=%08d.",
+                                          __LINE__,
+                                          adsp_ineta_raws_1,
+                                          adsl_conn1,
+                                          adsl_conn1->dsc_co_sort.imc_sno );
+     }
+     ADSL_WTR_G1->iec_wtrt = ied_wtrt_text;  /* text passed            */
+     ADSL_WTR_G1->achc_content              /* content of text / data  */
+       = (char *) (ADSL_WTR_G1 + 1);
+     adsl_wt1_w1->adsc_wsp_trace_record = ADSL_WTR_G1;  /* WSP trace records */
+#undef ADSL_WTR_G1
+     m_wsp_trace_out( adsl_wt1_w1 );        /* output of WSP trace record */
+   }
 #ifdef XYZ1
    memset( &dsl_work_i, 0, sizeof(dsl_work_i) );
    bol_lock_set = FALSE;                    /* lock not set            */
@@ -9414,10 +9581,14 @@
    bol_err_illogic = FALSE;                 /* give error message illogic */
    bol_err_resp_cluster = FALSE;            /* give error message cluster responses */
 #endif
-   bol_route_del = FALSE;                   /* delete the route        */
+   bol_route_del_ipv4 = FALSE;              /* delete the route IPV4   */
    bol_failed_del_appl = FALSE;             /* failed to delete appl   */
    bol_ser_post = FALSE;                    /* post serialize thread   */
    bol_no_tun = FALSE;                      /* INETA not for TUN-adapter */
+// to-do 10.12.12 KB - check no-tun - L2TP
+   if (adsp_ineta_raws_1->dsc_tun_contr_ineta.dsc_soa_local_ipv4.sin_family) {  /* with IPV4 */
+     bol_route_del_ipv4 = TRUE;             /* delete the route IPV4   */
+   }
 // to-do 15.09.12 KB - IPV4 and IPV6
 #ifdef XYZ1
    switch (adsp_ineta_raws_1->iec_irs) {    /* type of INETA raw socket */
@@ -9485,8 +9656,10 @@
        break;
    }
 #endif
+// check IPV6 later - 14.12.12 KB
+   adsl_hac_ineta = &dss_htree1_avl_cntl_ineta_ipv4;
    adsl_ser_thr_task_free = NULL;           /* task for serial thread  */
-   if (bol_route_del) {                     /* delete the route        */
+   if (bol_route_del_ipv4) {                /* delete the route IPV4   */
      adsl_ser_thr_task_free
        = (struct dsd_ser_thr_task *) malloc( DEF_SERIAL_FREE_POOL * sizeof(struct dsd_ser_thr_task) );
      adsl_ser_thr_task_free->adsc_next = adsl_ser_thr_task_free + DEF_SERIAL_FREE_POOL - 1;
@@ -9499,16 +9672,18 @@
        iml1--;                              /* decrement index         */
      } while (iml1 > 0);
    }
-   if (bol_search_appl) {                   /* search appl             */
+   if (adsp_ineta_raws_1->boc_with_user) {  /* structure with user     */
      memcpy( &dsl_work_i.dsc_ineta_raws_1,
              adsp_ineta_raws_1,
-             sizeof(struct dsd_ineta_raws_1) + usl_ineta_length );
+             sizeof(struct dsd_ineta_raws_1) );
+// check IPV6 later - 14.12.12 KB
+     adsl_hac_user_i = &dss_htree1_avl_cntl_user_i_ipv4;
      dsl_work_i.dsc_ineta_raws_1.usc_appl_port = 0;  /* clear port in use */
      bol_failed_del_appl = TRUE;            /* failed to delete appl   */
    }
    achl_avl_error = NULL;                   /* clear error code AVL tree */
    dsg_global_lock.m_enter();
-   if (bol_search_appl) {                   /* search appl             */
+   if (adsp_ineta_raws_1->boc_with_user) {  /* structure with user     */
      do {                                   /* pseudo-loop             */
        bol1 = m_htree1_avl_search( NULL, adsl_hac_user_i,
                                    &dsl_htree1_work, &dsl_work_i.dsc_ineta_raws_1.dsc_sort_user );
@@ -9534,9 +9709,9 @@
                                   &ADSL_INETA_RAWS_1_S->dsc_user_name,  /* Username Sign On */
                                   &dsl_work_i.dsc_ineta_raws_1.dsc_user_name );  /* Username Sign On */
            if (iml_cmp != 0) break;
-           iml_cmp = memcmp( ADSL_INETA_RAWS_1_S + 1,
-                             &dsl_work_i.dsc_ineta_raws_1 + 1,
-                             usl_ineta_length );
+           iml_cmp = memcmp( &ADSL_INETA_RAWS_1_S->dsc_tun_contr_ineta.dsc_soa_local_ipv4.sin_addr,
+                             &dsl_work_i.dsc_ineta_raws_1.dsc_tun_contr_ineta.dsc_soa_local_ipv4.sin_addr,
+                             4 );
            if (iml_cmp) break;              /* not same INETA          */
            if (ADSL_INETA_RAWS_1_S->usc_appl_port == adsp_ineta_raws_1->usc_appl_port) {  /* port in use */
              bol1 = m_htree1_avl_delete( NULL, adsl_hac_user_i,
@@ -9550,7 +9725,7 @@
              }
              bol_failed_del_appl = FALSE;   /* failed to delete appl   */
            } else {                         /* is same INETA           */
-             bol_route_del = FALSE;         /* do not delete the route */
+             bol_route_del_ipv4 = FALSE;    /* do not delete the route */
            }
          }
          bol1 = m_htree1_avl_getnext( NULL, adsl_hac_user_i,
@@ -9568,14 +9743,8 @@
      } while (FALSE);
    }
    do {                                     /* pseudo-loop             */
-#ifndef HL_UNIX
      bol1 = m_htree1_avl_search( NULL, adsl_hac_ineta,
-                                 &dsl_htree1_work, &adsp_ineta_raws_1->dsc_sort_ineta );
-#endif
-#ifdef HL_UNIX
-     bol1 = m_htree1_avl_search( NULL, adsl_hac_ineta,
                                  &dsl_htree1_work, &adsp_ineta_raws_1->dsc_sort_ineta_ipv4 );
-#endif
      if (bol1 == FALSE) {                   /* error occured           */
        if (achl_avl_error) break;           /* error already set       */
        sprintf( chrl_work1,
@@ -9603,7 +9772,7 @@
        break;
      }
    } while (FALSE);
-   if (bol_route_del) {                     /* delete the route        */
+   if (bol_route_del_ipv4) {                /* delete the route IPV4   */
      /* give work to serialisation thread to delete the route          */
      adsl_ser_thr_task_w1 = dss_ser_thr_ctrl.adsc_sth_free;  /* chain of free structures */
      if (adsl_ser_thr_task_w1 == NULL) {    /* we need more entries    */
@@ -9614,12 +9783,13 @@
      memset( adsl_ser_thr_task_w1, 0, sizeof(struct dsd_ser_thr_task) );  /* task for serial thread */
 // to-do 03.07.10 KB attention IPV6
      adsl_ser_thr_task_w1->iec_sth = ied_sth_route_ipv4_del;  /* delete a route IPV4 */
-#ifndef HL_UNIX
-     memcpy( adsl_ser_thr_task_w1->chrc_ineta, adsp_ineta_raws_1 + 1, usl_ineta_length );
-     adsl_ser_thr_task_w1->umc_index_if_arp = adsp_ineta_raws_1->umc_index_if_arp;  /* holds index of compatible IF for ARP */
-     adsl_ser_thr_task_w1->umc_index_if_route = adsp_ineta_raws_1->umc_index_if_route;  /* holds index of compatible IF for routes */
-     adsl_ser_thr_task_w1->umc_taif_ineta = adsp_ineta_raws_1->umc_taif_ineta;  /* <TUN-adapter-use-interface-ineta> */
-#endif
+     memcpy( adsl_ser_thr_task_w1->chrc_ineta,
+             &adsp_ineta_raws_1->dsc_tun_contr_ineta.dsc_soa_local_ipv4.sin_addr,
+             4 );
+// to-do 29.12.12 KB following three fields not used with TUN adapter in Unix
+     adsl_ser_thr_task_w1->umc_index_if_arp = adsp_ineta_raws_1->umc_index_if_arp_ipv4;  /* holds index of compatible IF for ARP */
+     adsl_ser_thr_task_w1->umc_index_if_route = adsp_ineta_raws_1->umc_index_if_route_ipv4;  /* holds index of compatible IF for routes */
+     adsl_ser_thr_task_w1->umc_taif_ineta = adsp_ineta_raws_1->umc_taif_ineta_ipv4;  /* <TUN-adapter-use-interface-ineta> */
      /* append at end of chain to process                              */
      if (dss_ser_thr_ctrl.adsc_sth_work == NULL) {  /* work as task for serial thread */
        dss_ser_thr_ctrl.adsc_sth_work = adsl_ser_thr_task_w1;  /* work as task for serial thread */
@@ -9632,11 +9802,24 @@
    }
    dsg_global_lock.m_leave();
    if (bol_ser_post) {                      /* post serialize thread   */
-     iml_rc = dss_ser_thr_ctrl.dsc_event_thr.m_post( &iml_error );  /* event for serial thread */
-     if (iml_rc < 0) {                      /* error occured           */
-       m_hlnew_printf( HLOG_WARN1, "HWSPM155W l%05d cleanup HOB-TUN INETA event serial m_post Return Code %d Error %d.",
-                       __LINE__, iml_rc, iml_error );
+#ifdef HL_UNIX
+     if (dss_loconf_1.boc_listen_gw == FALSE) {  /* do not use listen gateway */
+#endif
+       iml_rc = dss_ser_thr_ctrl.dsc_event_thr.m_post( &iml_error );  /* event for serial thread */
+       if (iml_rc < 0) {                    /* error occured           */
+// to-do 29.12.12 KB HWSPM155W double
+         m_hlnew_printf( HLOG_WARN1, "HWSPM155W l%05d cleanup HOB-TUN INETA event serial m_post Return Code %d Error %d.",
+                         __LINE__, iml_rc, iml_error );
+       }
+#ifdef HL_UNIX
+     } else {                               /* do use listen gateway   */
+       iml_rc = write( imrs_m_fd_pipe[1], vprs_message_work, sizeof(vprs_message_work) );
+       if (iml_rc != sizeof(vprs_message_work)) {
+         m_hlnew_printf( HLOG_WARN1, "HWSPMnnnW m_cleanup_htun_ineta() l%05d write pipe work error %d %d.",
+                         __LINE__, iml_rc, errno );
+       }
      }
+#endif
    }
    if (achl_avl_error) {
 // to-do 23.01.12 KB error number
@@ -10491,11 +10674,21 @@
    } dsl_work_i;

    dsl_htree1_work.adsc_found = NULL;       /* clear return value      */
-   achl_avl_error = NULL;                     /* clear error code AVL tree */
+   achl_avl_error = NULL;                   /* clear error code AVL tree */
    dsl_work_i.dsc_auxf_1.iec_auxf_def = (enum ied_auxf_def) -1;  /* type of entry invalid */
+#ifndef B121231
+   memset( &dsl_work_i.dsc_ineta_raws_1, 0, sizeof(struct dsd_ineta_raws_1) );
+#endif
+#ifdef HL_UNIX
+#ifndef B121212
+   dsl_work_i.dsc_ineta_raws_1.boc_with_user = TRUE;
+#endif
+#endif
    switch (dsp_soa->ss_family) {
      case AF_INET:                          /* IPV4                    */
+#ifdef B121231
        memset( &dsl_work_i.dsc_ineta_raws_1, 0, sizeof(struct dsd_ineta_raws_1) );
+#endif
 #ifndef HL_UNIX
        dsl_work_i.dsc_ineta_raws_1.usc_ineta_family = AF_INET;  /* family IPV4 / IPV6 */
        dsl_work_i.dsc_ineta_raws_1.usc_ineta_length = 4;  /* length of following address */
@@ -10609,9 +10802,16 @@
      aucl_p2_s++;                           /* next INETA 2            */
    } while (aucl_p1_s < aucl_p1_e);
 #endif
+#ifndef HL_UNIX
    iml_cmp = memcmp( (unsigned char *) ADSL_INETA_RAWS_1_P1 + sizeof(struct dsd_ineta_raws_1),
                      (unsigned char *) ADSL_INETA_RAWS_1_P2 + sizeof(struct dsd_ineta_raws_1),
                      4 );
+#endif
+#ifdef HL_UNIX
+   iml_cmp = memcmp( &ADSL_INETA_RAWS_1_P1->dsc_tun_contr_ineta.dsc_soa_local_ipv4.sin_addr,
+                     &ADSL_INETA_RAWS_1_P2->dsc_tun_contr_ineta.dsc_soa_local_ipv4.sin_addr,
+                     4 );
+#endif
    if (iml_cmp) return iml_cmp;             /* not same INETA          */
    if (ap_option) {
      if (*((char *) ap_option) == 'C') {
@@ -10624,7 +10824,7 @@
        return 0;                            /* is PPP, do not check the port */
      }
 #endif
-#ifdef HL_UINX
+#ifdef HL_UNIX
      if (   (*((char *) ap_option) == 'S')
          && (   (ADSL_INETA_RAWS_1_P1->boc_with_user == FALSE)  /* structure without user */
              || (ADSL_INETA_RAWS_1_P2->boc_with_user == FALSE))) {  /* structure without user */
@@ -10673,9 +10873,21 @@
                           &ADSL_INETA_RAWS_1_P1->dsc_user_name,  /* Username Sign On */
                           &ADSL_INETA_RAWS_1_P2->dsc_user_name );  /* Username Sign On */
    if (iml_cmp != 0) return iml_cmp;
+#ifndef HL_UNIX
    iml_cmp = memcmp( (ADSL_INETA_RAWS_1_P1 + 1),
                      (ADSL_INETA_RAWS_1_P2 + 1),
                      4 );
+#endif
+#ifdef HL_UNIX
+#ifdef B130110
+   iml_cmp = memcmp( (ADSL_INETA_RAWS_1_P1 + 1),
+                     (ADSL_INETA_RAWS_1_P2 + 1),
+                     4 );
+#endif
+   iml_cmp = memcmp( &ADSL_INETA_RAWS_1_P1->dsc_tun_contr_ineta.dsc_soa_local_ipv4.sin_addr,
+                     &ADSL_INETA_RAWS_1_P2->dsc_tun_contr_ineta.dsc_soa_local_ipv4.sin_addr,
+                     4 );
+#endif
    if (iml_cmp) return iml_cmp;             /* not same INETA          */
    return ADSL_INETA_RAWS_1_P1->usc_appl_port  /* port in use          */
             - ADSL_INETA_RAWS_1_P2->usc_appl_port;  /* port in use     */
@@ -10693,7 +10905,7 @@
    return ADSL_CO_SORT_P1->imc_sno - ADSL_CO_SORT_P2->imc_sno;
 #undef ADSL_CO_SORT_P1
 #undef ADSL_CO_SORT_P2
-} /* end m_cmp_ineta_user_ipv4()                                       */
+} /* end m_cmp_ineta_user_ipv6()                                       */
 #endif

 /** display information about the configuration file                   */
Index: xsclibrdp1.cpp
===================================================================
--- xsclibrdp1.cpp	(revision 2)
+++ xsclibrdp1.cpp	(revision 6)
@@ -57,7 +57,8 @@
 #define DEF_HL_INCL_INET
 #include "hob-xsclib01.h"

-extern "C" BOOL m_tcp_conn( void *, struct dsd_aux_tcp_conn_1 *, struct dsd_target_ineta_1 *, BOOL );
+extern "C" BOOL m_tcp_dynamic_conn( void *, struct dsd_aux_tcp_conn_1 *, struct dsd_target_ineta_1 *, void *, BOOL );
+extern "C" int m_tcp_static_conn( void *, BOOL );
 extern "C" BOOL m_tcp_close( void * );

 static int m_sdh_printf( struct dsd_sdh_call_1 *, char *, ... );
@@ -126,7 +127,10 @@
    char       chl1;                         /* working variable        */
 #endif
    int        iml1, iml2, iml3;             /* working variables       */
+#ifdef B121117
    BOOL       bol1, bol2;                   /* working variables       */
+#endif
+   BOOL       bol1;                         /* working variable        */
    BOOL       bol_connected;                /* connected to server     */
    int        iml_ineta_len;                /* length INETA            */
    int        iml_port;                     /* port to connect to      */
@@ -135,8 +139,9 @@
    char       *achl1, *achl2, *achl3, *achl4;  /* working variables    */
    char       *achl_ineta_start;            /* start of INETA          */
    struct dsd_target_ineta_1 *adsl_server_ineta_w1;  /* server INETA   */
-   char       *achl_work_1;
-   char       *achl_work_2;
+   void *     al_free_ti1;                  /* INETA to be freed       */
+   char       *achl_work_1;                 /* working variable        */
+   char       *achl_work_2;                 /* working variable        */
    struct dsd_gather_i_1 *adsl_gai1_inp_1;  /* input data              */
    struct dsd_gather_i_1 *adsl_gai1_inp_2;  /* input data              */
    struct dsd_gather_i_1 *adsl_gai1_out_1;  /* output data             */
@@ -842,6 +847,7 @@
    adsl_server_ineta_w1 = m_get_target_ineta( achl_ineta_start, iml_ineta_len, ied_chs_utf_8,
                                               dsl_ag_sess_info.adsc_bind_out );
    bol_connected = FALSE;                   /* connected to server     */
+   al_free_ti1 = adsl_server_ineta_w1;
    if (adsl_server_ineta_w1) goto pne_conn_40;  /* all prepared for connect */
    dsl_aux_tcp_conn_1.iec_tcpconn_ret = ied_tcr_hostname;  /* host-name not in DNS */
    goto p_conn_err_00;                      /* error from connect      */
@@ -935,6 +941,7 @@
 // 31.07.10 KB change connect
    /* prepare INETA for connect                                        */
    adsl_server_ineta_w1 = NULL;             /* pass argument           */
+   al_free_ti1 = NULL;
    iml_port = 0;                            /* no port yet             */
 #define ADSL_SERVER_INETA_G ((struct dsd_target_ineta_1 *) chrl_work1)
    memset( ADSL_SERVER_INETA_G, 0, sizeof(struct dsd_target_ineta_1) + sizeof(struct dsd_ineta_single_1));
@@ -985,17 +992,29 @@
    }

    pne_conn_44:                             /* no more connected to server */
+   if (adsl_server_ineta_w1 == NULL) {      /* do static connect       */
+     iml1 = m_tcp_static_conn( adsp_hl_clib_1->vpc_userfld, TRUE );
+     achl1 = "m_tcp_static_conn()";
+     if (iml1 == 0) {                       /* connect successful      */
+       goto pne_conn_48;
+     }
+     achl2 = achl_work_1;                   /* save address output error */
+     achl_work_1 += sprintf( achl_work_1, "error from static connect %d", iml1 ) + 1;
+     goto p_conn_err_20;                    /* connect error set       */
+   }
    memset( &dsl_aux_tcp_conn_1, 0, sizeof(struct dsd_aux_tcp_conn_1) ); /* TCP Connect to Server */
    dsl_aux_tcp_conn_1.imc_server_port = iml_port;  /* port of server   */
-   bol1 = m_tcp_conn( adsp_hl_clib_1->vpc_userfld,
-                      &dsl_aux_tcp_conn_1,
-                      adsl_server_ineta_w1,
-                      adsl_cl1d1_1->boc_dynamic );
+   bol1 = m_tcp_dynamic_conn( adsp_hl_clib_1->vpc_userfld,
+                              &dsl_aux_tcp_conn_1,
+                              adsl_server_ineta_w1,
+                              al_free_ti1,
+                              adsl_cl1d1_1->boc_dynamic );
 #ifdef TRACEHL1
-   printf( "xsclibrdp1-l%05d-T m_rdp1_hlclib01() m_tcp_conn() returned %d iec_tcpconn_ret=%d.\n",
+   printf( "xsclibrdp1-l%05d-T m_rdp1_hlclib01() m_tcp_dynamic_conn() returned %d iec_tcpconn_ret=%d.\n",
            __LINE__, bol1, dsl_aux_tcp_conn_1.iec_tcpconn_ret );
    fflush( stdout );
 #endif
+#ifdef B12117
 // to-do 15.08.10 KB check return
    if (   (adsl_server_ineta_w1)
        && (adsl_server_ineta_w1 != ADSL_SERVER_INETA_G)) {
@@ -1011,23 +1030,27 @@
      }
 #endif
    }
+#endif
 #undef ADSL_SERVER_INETA_G
    if (bol1 == FALSE) {                     /* connect invalid parameters */
      adsp_hl_clib_1->inc_return = DEF_IRET_ERRAU;
-     m_sdh_printf( &dsl_sdh_call_1, "xsclibrdp1-l%05d-W m_tcp_conn() returned FALSE",
+     m_sdh_printf( &dsl_sdh_call_1, "xsclibrdp1-l%05d-W m_tcp_dynamic_conn() returned FALSE",
                    __LINE__ );
      return;
    }
+   achl1 = "m_tcp_dynamic_conn()";
    if (dsl_aux_tcp_conn_1.iec_tcpconn_ret != ied_tcr_ok) {  /* connect successful */
      goto p_conn_err_00;                    /* error from connect      */
    }
+
+   pne_conn_48:                             /* connected was successful */
    /* send to client, that we did connect                              */
    adsl_cl1d1_1->iec_cos = ied_cos_cont;    /* continue                */
    achl_work_2 -= sizeof(struct dsd_gather_i_1);
    if (achl_work_2 < achl_work_1) {         /* no more space in work-area */
      adsp_hl_clib_1->inc_return = DEF_IRET_ERRAU;
-     m_sdh_printf( &dsl_sdh_call_1, "xsclibrdp1-l%05d-E m_tcp_conn() succeeded - no space in work area",
-                   __LINE__ );
+     m_sdh_printf( &dsl_sdh_call_1, "xsclibrdp1-l%05d-E %s succeeded - no space in work area",
+                   __LINE__, achl1 );
      return;
    }
    adsl_gai1_out_1 = (struct dsd_gather_i_1 *) achl_work_2;
@@ -1045,47 +1068,49 @@
 // to-do 08.12.10 KB
    switch (dsl_aux_tcp_conn_1.iec_tcpconn_ret) {
      case ied_tcr_invalid:                  /* parameter is invalid    */
-       achl1 = "error ied_tcr_invalid - parameter is invalid";
+       achl2 = "error ied_tcr_invalid - parameter is invalid";
        break;
      case ied_tcr_no_ocos:                  /* option-connect-other-server not configured */
-       achl1 = "error ied_tcr_no_ocos - option-connect-other-server not configured";
+       achl2 = "error ied_tcr_no_ocos - option-connect-other-server not configured";
        break;
      case ied_tcr_no_cs_ssl:                /* no Client-Side SSL configured */
-       achl1 = "error ied_tcr_no_cs_ssl - no Client-Side SSL configured";
+       achl2 = "error ied_tcr_no_cs_ssl - no Client-Side SSL configured";
        break;
      case ied_tcr_denied_tf:                /* access denied because of target-filter */
-       achl1 = "error ied_tcr_denied_tf - access denied because of target-filter";
+       achl2 = "error ied_tcr_denied_tf - access denied because of target-filter";
        break;
      case ied_tcr_hostname:                 /* host-name not in DNS    */
-       achl1 = "error ied_tcr_hostname - host-name not in DNS";
+       achl2 = "error ied_tcr_hostname - host-name not in DNS";
        break;
      case ied_tcr_no_route:                 /* no route to host        */
-       achl1 = "error ied_tcr_no_route - no route to host";
+       achl2 = "error ied_tcr_no_route - no route to host";
        break;
      case ied_tcr_refused:                  /* connection refused      */
-       achl1 = "error ied_tcr_refused - connection refused";
+       achl2 = "error ied_tcr_refused - connection refused";
        break;
      case ied_tcr_timeout:                  /* connection timed out    */
-       achl1 = "error ied_tcr_timeout - connection timed out";
+       achl2 = "error ied_tcr_timeout - connection timed out";
        break;
      case ied_tcr_error:                    /* other error             */
-       achl1 = "error ied_tcr_error - error not specified";
+       achl2 = "error ied_tcr_error - error not specified";
        break;
      default:                               /* error undefined         */
-       achl1 = "error undefined";
+       achl2 = "error undefined";
        break;
    }
+
+   p_conn_err_20:                           /* connect error set       */
    achl_work_2 -= 2 * sizeof(struct dsd_gather_i_1) + 8;
    if (achl_work_2 < achl_work_1) {         /* no more space in work-area */
      adsp_hl_clib_1->inc_return = DEF_IRET_ERRAU;
-     m_sdh_printf( &dsl_sdh_call_1, "xsclibrdp1-l%05d-E m_tcp_conn() failed - no space in work area",
-                   __LINE__ );
+     m_sdh_printf( &dsl_sdh_call_1, "xsclibrdp1-l%05d-E %s failed - no space in work area",
+                   __LINE__, achl1 );
      return;
    }
 #define ADSL_GAI1_OUT_G1 ((struct dsd_gather_i_1 *) achl_work_2)
 #define ADSL_GAI1_OUT_G2 ((struct dsd_gather_i_1 *) achl_work_2 + 1)
 #define ACHL_OUT_G       ((char *) (ADSL_GAI1_OUT_G2 + 1))
-   iml1 = strlen( achl1 );
+   iml1 = strlen( achl2 );
    iml2 = iml1 + 5;
    *(ACHL_OUT_G + 0) = (unsigned char) 0X03;
    *(ACHL_OUT_G + 1) = (unsigned char) 0XFF;
@@ -1096,8 +1121,8 @@
    ADSL_GAI1_OUT_G1->achc_ginp_cur = ACHL_OUT_G;
    ADSL_GAI1_OUT_G1->achc_ginp_end = ACHL_OUT_G + 5;
    ADSL_GAI1_OUT_G2->adsc_next = NULL;
-   ADSL_GAI1_OUT_G2->achc_ginp_cur = achl1;
-   ADSL_GAI1_OUT_G2->achc_ginp_end = achl1 + iml1;
+   ADSL_GAI1_OUT_G2->achc_ginp_cur = achl2;
+   ADSL_GAI1_OUT_G2->achc_ginp_end = achl2 + iml1;
    if (adsl_gai1_out_2 == NULL) {
      adsp_hl_clib_1->adsc_gai1_out_to_client = ADSL_GAI1_OUT_G1;  /* output data to client */
    } else {
Index: xsipgw08-conf.cpp
===================================================================
--- xsipgw08-conf.cpp	(revision 2)
+++ xsipgw08-conf.cpp	(revision 6)
@@ -12,6 +12,11 @@
 //#define TRACEHL1
 #define CSSSL_060620
 #ifdef TODO
+--- 20.11.12 KB
+<max-utility-thread>
+--- RSA key file
+--- Tageszeit Log
+--- Unix PID in syslog
 --- 11.09.12 KB ---
 cluster
 keepalive
@@ -208,6 +213,7 @@
 /*|  Copyright (C) HOB Germany 2010                                   |*/
 /*|  Copyright (C) HOB Germany 2011                                   |*/
 /*|  Copyright (C) HOB Germany 2012                                   |*/
+/*|  Copyright (C) HOB Germany 2013                                   |*/
 /*|                                                                   |*/
 /*| REQUIRED PROGRAMS:                                                |*/
 /*| ------------------                                                |*/
@@ -347,7 +353,23 @@
 /*| <disk-file-size-max> maximum size of one single file, MB, GB      |*/
 /*| <disk-file-storage>  maximum size of cache, MB, GB                |*/
 /*| <network-statistic-level> [1 - 9] report stat about network usage |*/
+/*| <TCP-sndbuf>nnn - K                                               |*/
+/*| <TCP-rcvbuf>nnn - K                                               |*/
+/*| $$UU$$                                                            |*/
+/*| <TCP-keepalive>YES/NO                                             |*/
 /*| <clear-used-memory> YES/NO (NO default)                           |*/
+/*| $$UU$$                                                            |*/
+/*| <size-swap-in-memory>                                             |*/
+/*| $$UU$$                                                            |*/
+/*| <max-swap-size>                                                   |*/
+/*| $$UU$$                                                            |*/
+/*| <swap-file>                                                       |*/
+/*| $$UU$$                                                            |*/
+/*| <max-util-thread>                                                 |*/
+/*| $$UU$$                                                            |*/
+/*| <signature-credentials-file>                                      |*/
+/*| $$UU$$                                                            |*/
+/*| <time-of-day-mark-log>                                            |*/
 /*| Windows-Parameters:                                               |*/
 /*| <prot-event-log> YES/NO (NO default)                              |*/
 /*| <event-server-name> Server Name for RegisterEventSource           |*/
@@ -360,6 +382,8 @@
 /*|   <password>     password                                         |*/
 /*| Unix-Parameters:                                                  |*/
 /*| <prot-syslog>    YES/NO write protocol to syslog                  |*/
+/*| $$UU$$                                                            |*/
+/*| <prot-include-pid> YES/NO (NO default)                            |*/
 /*| <pid-file>       name of file to write PID (process Id) to        |*/
 /*| <listen-error>   ignore/wait/abend                                |*/
 /*| <listen-gateway> YES/NO (NO default)                              |*/
@@ -467,6 +491,10 @@
 /*|                       the current load is calculated and          |*/
 /*|                       exchanged with the other members of the     |*/
 /*|                       cluster                                     |*/
+/*|   $$UU$$                                                          |*/
+/*|   <display-load>                                                  |*/
+/*|   $$UU$$                                                          |*/
+/*|   <timeout-receive-millisec-all>  timeout in milliseconds         |*/
 /*|   <time-retry-connect>  time in seconds when a connect is retried |*/
 /*|                       when no connection is currently established |*/
 /*|   <cluster-entry>     sub-section describing the network          |*/
@@ -483,8 +511,40 @@
 /*|   <timeout-millisec>  timeout in milliseconds when no reply was   |*/
 /*|                       received after sending a query              |*/
 /*|                       only used in type REMOTE                    |*/
+/*|   $$UU$$                                                          |*/
+/*|   <timeout-receive-millisec>  timeout in milliseconds             |*/
 /*|                                                                   |*/
+/*| <raw-packet-interface>                   .                        |*/
+/*|   <TUN-adapter-ineta>                                             |*/
+/*|   <TUN-adapter-use-interface-ineta>                               |*/
+/*|   <TCP-connect-timeout-millisec>                                  |*/
+/*|   <TCP-connect-number-of-try>                                     |*/
+/*|   <PPP-server>                                                    |*/
+/*|   <PPP-ineta-pool>                                                |*/
+/*|   <TUN-use-ineta>                                                 |*/
+/*|   <appl-use-tcp-source-port>                                      |*/
+/*|   <appl-use-random-tcp-source-port>                               |*/
+/*|   $$UU$$                                                          |*/
+/*|   <strategy-inst-win-driver>                                      |*/
+/*|      ied_siwd_no_inst_uninst,                 -- no install or uninstall */
+/*|      ied_siwd_only_inst,                      -- only install when needed */
+/*|      ied_siwd_uninst_startup,                 -- uninstall at startup    */
+/*|      ied_siwd_uninst_all                      -- uninstall all possible  */
+/*|      no-install-or-uninstall                                      |*/
+/*|      only-install-when-needed                                     |*/
+/*|      uninstall-at-startup                                         |*/
+/*|      uninstall-all-possible                                       |*/
+/*| <L2TP-gateway>                                                    |*/
+/*|   <serverineta>                                                   |*/
+/*|   <serverport>                                                    |*/
+/*|   <gate-ineta>                                                    |*/
+/*|   $$UU$$                                                          |*/
+/*|   <authenticate-use-charset>                                      |*/
+/*|   <authenticate-use-userid>                                       |*/
+/*|   <authenticate-use-password-plain>                               |*/
+/*|   <authenticate-use-password-encrypted>                           |*/
 /*|                                                                   |*/
+/*|                                                                   |*/
 /*| EXPECTED OUTPUT:                                                  |*/
 /*| ----------------                                                  |*/
 /*|                                                                   |*/
@@ -721,7 +781,8 @@
 #define D_CHARSET_IP ied_chs_ansi_819       /* ANSI 819                */
 #define D_TCP_ERROR WSAGetLastError()
 #else
-#define D_CHARSET_IP ied_chs_ascii_850      /* ASCII 850               */
+//#define D_CHARSET_IP ied_chs_ascii_850      /* ASCII 850               */
+#define D_CHARSET_IP ieg_charset_system
 #define D_TCP_ERROR errno
 #endif

@@ -734,11 +795,15 @@
 #define HL_WCSCMP( p1, p2 ) wcscmp( (WCHAR *) p1, (WCHAR *) p2 )
 #define HL_FN_WCSCMP( p1, p2 ) _wcsicmp( (WCHAR *) p1, (WCHAR *) p2 )
 #define HL_NAME_WCSCMP( p1, p2 ) _wcsicmp( (WCHAR *) p1, (WCHAR *) p2 )
+#define HL_M_CMP_FN m_cmpi_ucs_ucs
+#define HL_FN_CHARSET ied_chs_utf_16
 #else
 #define HL_WCSLEN( p ) m_len_u16z( (HL_WCHAR *) p )
 #define HL_WCSCMP( p1, p2 ) m_cmp_u16z_u16z( (HL_WCHAR *) p1, (HL_WCHAR *) p2 )
 #define HL_FN_WCSCMP( p1, p2 ) m_cmp_u16z_u16z( (HL_WCHAR *) p1, (HL_WCHAR *) p2 )
 #define HL_NAME_WCSCMP( p1, p2 ) m_cmpi_u16z_u16z( (HL_WCHAR *) p1, (HL_WCHAR *) p2 )
+#define HL_M_CMP_FN m_cmp_ucs_ucs
+#define HL_FN_CHARSET ieg_charset_system
 #endif

 /* message HWSPXMLC024xxX                                              */
@@ -917,16 +982,25 @@
    "event-source-name",
    "windows-core-dump",
    "prot-syslog",
+/*| $$UU$$                                                            |*/
+   "prot-include-pid",
+/*| $$UU$$                                                            |*/
+// to-do 08.01.13 KB
+   "time-of-day-mark-log",
    "pid-file",
    "listen-error",
    "listen-gateway",
    "reload-configuration",
    "TCP-sndbuf",
    "TCP-rcvbuf",
+/*| $$UU$$                                                            |*/
+   "TCP-keepalive",
    "max-poss-work-thread",
    "max-active-work-thread",
    "prio-work-thread",
    "prio-process",
+/*| $$UU$$                                                            |*/
+   "max-util-thread",
    "report-intv",
    "wake-on-lan-relay-ineta",
    "wake-on-lan-port",
@@ -936,6 +1010,16 @@
    "disk-file-storage",
    "network-statistic-level",
    "clear-used-memory",
+/*| $$UU$$                                                            |*/
+   "size-swap-in-memory",
+/*| $$UU$$                                                            |*/
+   "max-swap-size",
+/*| $$UU$$                                                            |*/
+// to-do 08.01.13 KB
+   "swap-file",
+/*| $$UU$$                                                            |*/
+// to-do 08.01.13 KB
+   "signature-credentials-file",
    "SNMP-configuration",
    "alert-subsystem-configuration",
    "ignore-PTTD-connect-error-host-unreachable",
@@ -965,50 +1049,58 @@
 #define DEF_XML_GENERAL_EVSOURCEN      3    /* <event-source-name>     */
 #define DEF_XML_GENERAL_WICOREDU       4    /* <windows-core-dump>     */
 #define DEF_XML_GENERAL_SYSLOG         5    /* <prot-syslog>           */
-#define DEF_XML_GENERAL_PIDFILE        6    /* <pid-file>              */
-#define DEF_XML_GENERAL_LISTENERR      7    /* <listen-error>          */
-#define DEF_XML_GENERAL_LISTENGW       8    /* <listen-gateway>        */
-#define DEF_XML_GENERAL_RELOCONF       9
-#define DEF_XML_GENERAL_TCP_SNDBUF     10   /* <TCP-sndbuf>            */
-#define DEF_XML_GENERAL_TCP_RCVBUF     11   /* <TCP-rcvbuf>            */
-#define DEF_XML_GENERAL_MAXPOSSWTHR    12
-#define DEF_XML_GENERAL_MAXACTWTHR     13
-#define DEF_XML_GENERAL_PRIOWT         14
-#define DEF_XML_GENERAL_PRIOPR         15
-#define DEF_XML_GENERAL_REPINTV        16
-#define DEF_XML_GENERAL_WOLRINETA      17
-#define DEF_XML_GENERAL_WOLPORT        18
-#define DEF_XML_GENERAL_TIME_C_DF      19   /* <time-cache-disk-file>  */
-#define DEF_XML_GENERAL_TIME_R_DF      20   /* <time-reload-disk-file> */
-#define DEF_XML_GENERAL_FILE_S_MAX     21   /* <disk-file-size-max>    */
-#define DEF_XML_GENERAL_FILE_STOR      22   /* <disk-file-storage>     */
-#define DEF_XML_GENERAL_NET_STAT_LEVEL 23   /* <network-statistic-level> */
-#define DEF_XML_GENERAL_CLUSEDM        24   /* <clear-used-memory>     */
-#define DEF_XML_GENERAL_SNMP_CO        25   /* <SNMP-configuration>    */
-#define DEF_XML_GENERAL_ALERT_SSC      26   /* <alert-subsystem-configuration> */
-#define DEF_XML_GENERAL_PTTD_CEHU      27   /* <ignore-PTTD-connect-error-host-unreachable> */
-#define DEF_XML_GENERAL_TIME_RDA       28   /* <time-repeat-delay-alert> */
-#define DEF_XML_GENERAL_THRES_BL_WT    29   /* <backlog-work-thread-threshold> */
-#define DEF_XML_GENERAL_THRES_CPUT     30   /* <CPU-time-percent-threshold> */
-#define DEF_XML_GENERAL_THRES_MEM      31   /* <memory-threshold>      */
-#define DEF_XML_GENERAL_SYN_W_NO       32   /* <watch-syn-no>          */
-#define DEF_XML_GENERAL_SYN_W_TIME     33   /* <watch-syn-time>        */
-#define DEF_XML_GENERAL_ENA_SION_NPW   34   /* <enable-sign-on-no-password> */
-#define DEF_XML_GENERAL_MEM_LS         35   /* <memory-log-size>       */
-#define DEF_XML_GENERAL_SIP_L_INETA    36   /* <SIP-local-ineta>       */
-#define DEF_XML_GENERAL_SIP_P5060      37   /* <SIP-use-UDP-port-5060> */
-#define DEF_XML_GENERAL_UDP_INETA      38   /* <UDP-gw-ineta>          */
-#define DEF_XML_GENERAL_UDP_GATE       39   /* <UDP-gate>              */
-#define DEF_XML_GENERAL_WIN_NAMED_P    40   /* <Windows-named-pipe>    */
-#define DEF_XML_GENERAL_UNIX_D_SOCKET  41   /* <Unix-Domain-Socket>    */
-#define DEF_XML_GENERAL_ALLOW_WSP_TR   42   /* <allow-wsp-trace>       */
+#define DEF_XML_GENERAL_PROT_INCL_PID  6    /* <prot-include-pid>      */
+#define DEF_XML_GENERAL_TOD_MARK_LOG   7    /* <time-of-day-mark-log>  */
+#define DEF_XML_GENERAL_PIDFILE        8    /* <pid-file>              */
+#define DEF_XML_GENERAL_LISTENERR      9    /* <listen-error>          */
+#define DEF_XML_GENERAL_LISTENGW       10   /* <listen-gateway>        */
+#define DEF_XML_GENERAL_RELOCONF       11
+#define DEF_XML_GENERAL_TCP_SNDBUF     12   /* <TCP-sndbuf>            */
+#define DEF_XML_GENERAL_TCP_RCVBUF     13   /* <TCP-rcvbuf>            */
+#define DEF_XML_GENERAL_TCP_KEEPALIVE  14   /* <TCP-keepalive>         */
+#define DEF_XML_GENERAL_MAXPOSSWTHR    15
+#define DEF_XML_GENERAL_MAXACTWTHR     16
+#define DEF_XML_GENERAL_PRIOWT         17
+#define DEF_XML_GENERAL_PRIOPR         18
+#define DEF_XML_GENERAL_MAX_UTIL_THR   19   /* <max-util-thread>       */
+#define DEF_XML_GENERAL_REPINTV        20
+#define DEF_XML_GENERAL_WOLRINETA      21
+#define DEF_XML_GENERAL_WOLPORT        22
+#define DEF_XML_GENERAL_TIME_C_DF      23   /* <time-cache-disk-file>  */
+#define DEF_XML_GENERAL_TIME_R_DF      24   /* <time-reload-disk-file> */
+#define DEF_XML_GENERAL_FILE_S_MAX     25   /* <disk-file-size-max>    */
+#define DEF_XML_GENERAL_FILE_STOR      26   /* <disk-file-storage>     */
+#define DEF_XML_GENERAL_NET_STAT_LEVEL 27   /* <network-statistic-level> */
+#define DEF_XML_GENERAL_CLUSEDM        28   /* <clear-used-memory>     */
+#define DEF_XML_GENERAL_SWAP_IN_MEM    29   /* <size-swap-in-memory>   */
+#define DEF_XML_GENERAL_MAX_SWAP_SIZE  30   /* <max-swap-size>         */
+#define DEF_XML_GENERAL_SWAP_FILE      31   /* <swap-file>             */
+#define DEF_XML_GENERAL_SIG_CRED_FILE  32   /* <signature-credentials-file> */
+#define DEF_XML_GENERAL_SNMP_CO        33   /* <SNMP-configuration>    */
+#define DEF_XML_GENERAL_ALERT_SSC      34   /* <alert-subsystem-configuration> */
+#define DEF_XML_GENERAL_PTTD_CEHU      35   /* <ignore-PTTD-connect-error-host-unreachable> */
+#define DEF_XML_GENERAL_TIME_RDA       36   /* <time-repeat-delay-alert> */
+#define DEF_XML_GENERAL_THRES_BL_WT    37   /* <backlog-work-thread-threshold> */
+#define DEF_XML_GENERAL_THRES_CPUT     38   /* <CPU-time-percent-threshold> */
+#define DEF_XML_GENERAL_THRES_MEM      39   /* <memory-threshold>      */
+#define DEF_XML_GENERAL_SYN_W_NO       40   /* <watch-syn-no>          */
+#define DEF_XML_GENERAL_SYN_W_TIME     41   /* <watch-syn-time>        */
+#define DEF_XML_GENERAL_ENA_SION_NPW   42   /* <enable-sign-on-no-password> */
+#define DEF_XML_GENERAL_MEM_LS         43   /* <memory-log-size>       */
+#define DEF_XML_GENERAL_SIP_L_INETA    44   /* <SIP-local-ineta>       */
+#define DEF_XML_GENERAL_SIP_P5060      45   /* <SIP-use-UDP-port-5060> */
+#define DEF_XML_GENERAL_UDP_INETA      46   /* <UDP-gw-ineta>          */
+#define DEF_XML_GENERAL_UDP_GATE       47   /* <UDP-gate>              */
+#define DEF_XML_GENERAL_WIN_NAMED_P    48   /* <Windows-named-pipe>    */
+#define DEF_XML_GENERAL_UNIX_D_SOCKET  49   /* <Unix-Domain-Socket>    */
+#define DEF_XML_GENERAL_ALLOW_WSP_TR   50   /* <allow-wsp-trace>       */
 //#define DEF_XML_GENERAL_SECURITY_TOKEN 43   /* <security-token>        */
-#define DEF_XML_GENERAL_SEC_TOKEN_PLAIN 43  /* <security-token-plain>  */
-#define DEF_XML_GENERAL_SEC_TOKEN_ENCRY 44  /* <security-token-encrypted> */
-#define DEF_XML_GENERAL_VDI_SO_TIME     45  /* <VDI-sign-on-time>      */
-#define DEF_XML_GENERAL_SUPP_W_LT_NR    46  /* <suppress-warning-LDAP-template-not-referenced> */
+#define DEF_XML_GENERAL_SEC_TOKEN_PLAIN 51  /* <security-token-plain>  */
+#define DEF_XML_GENERAL_SEC_TOKEN_ENCRY 52  /* <security-token-encrypted> */
+#define DEF_XML_GENERAL_VDI_SO_TIME     53  /* <VDI-sign-on-time>      */
+#define DEF_XML_GENERAL_SUPP_W_LT_NR    54  /* <suppress-warning-LDAP-template-not-referenced> */
 //#define DEF_XML_GENERAL_MAX             47  /* maximum value           */
-#define DEF_XML_GENERAL_MAX             46  /* maximum value           */
+#define DEF_XML_GENERAL_MAX             54  /* maximum value           */

 #ifndef HL_UNIX
 static const char * achrs_node_gwcd[] = {
@@ -1395,10 +1487,9 @@
    "load-balancing-formula",
    "interval-load-balancing-probe",
    "time-retry-connect",
-   "deny-not-configured"
-/* to-do 29.08.12
-   "recv-timeout"
-*/
+   "timeout-receive-millisec-all",
+   "deny-not-configured",
+   "display-load"
 };

 #define DEF_XML_CL04_CLUSTER_ENTRY     1
@@ -1406,7 +1497,9 @@
 #define DEF_XML_CL04_LBAL_FORMULA      3
 #define DEF_XML_CL04_LBAL_INTV         4
 #define DEF_XML_CL04_TIME_RETRY_C      5
-#define DEF_XML_CL04_DENY_NOT_CONF     6
+#define DEF_XML_CL04_TIMEOUT_RECV      6
+#define DEF_XML_CL04_DENY_NOT_CONF     7
+#define DEF_XML_CL04_DISPLAY_LOAD      8

 static const char * achrs_node_cluster_entry[] = {  /* for cluster-entry */
    "TCP-port",
@@ -1415,9 +1508,7 @@
    "backlog",
    "remote-ineta",
    "timeout-millisec",
-/* to-do 29.08.12
-   "recv-timeout"
-*/
+   "timeout-receive-millisec",
    "group",
    "location",
    "URL"
@@ -1429,9 +1520,10 @@
 #define DEF_XML_CL_ENT_BACKLOG         4
 #define DEF_XML_CL_ENT_REMOTE_INETA    5
 #define DEF_XML_CL_ENT_TIMEOUT_MSEC    6
-#define DEF_XML_CL_ENT_GROUP           7
-#define DEF_XML_CL_ENT_LOCATION        8
-#define DEF_XML_CL_ENT_URL             9
+#define DEF_XML_CL_ENT_TO_RECV_MSEC    7
+#define DEF_XML_CL_ENT_GROUP           8
+#define DEF_XML_CL_ENT_LOCATION        9
+#define DEF_XML_CL_ENT_URL             10

 #ifdef B100907
 static const char * achrs_node_ldap_template[] = {  /* for LDAP-template */
@@ -1554,6 +1646,7 @@
    "serverineta",
    "serverport",
    "gate-ineta",
+   "authenticate-use-charset",
    "authenticate-use-userid",
    "authenticate-use-password-plain",
    "authenticate-use-password-encrypted"
@@ -1562,10 +1655,11 @@
 #define DEF_XML_L2TP_GW_SERVER_INETA   0
 #define DEF_XML_L2TP_GW_SERVER_PORT    1
 #define DEF_XML_L2TP_GW_GATE_I         2
-#define DEF_XML_L2TP_GW_AUTH_USERID    3
-#define DEF_XML_L2TP_GW_AUTH_PWD_PLAIN 4
-#define DEF_XML_L2TP_GW_AUTH_PWD_ENCRY 5
-#define DEF_XML_L2TP_GW_MAX            6
+#define DEF_XML_L2TP_GW_AUTH_CHARSET   3
+#define DEF_XML_L2TP_GW_AUTH_USERID    4
+#define DEF_XML_L2TP_GW_AUTH_PWD_PLAIN 5
+#define DEF_XML_L2TP_GW_AUTH_PWD_ENCRY 6
+#define DEF_XML_L2TP_GW_MAX            7

 static const char * achrs_node_krb5_kdc[] = {  /* Kerberos-5-KDC       */
    "comment",
@@ -1619,6 +1713,7 @@
 // "TUN-adapter-name",
    "TUN-adapter-ineta",
    "TUN-adapter-use-interface-ineta",
+   "strategy-inst-win-driver",
    "TCP-connect-timeout-millisec",
    "TCP-connect-number-of-try",
    "PPP-server",
@@ -1630,15 +1725,42 @@

 #define DEF_XML_RPI_TA_INETA              0
 #define DEF_XML_RPI_TA_UIF_INETA          1
-#define DEF_XML_RPI_TCPC_TOMS             2
-#define DEF_XML_RPI_TCPC_NOT              3
-#define DEF_XML_RPI_PPP_SERVER            4
-#define DEF_XML_RPI_PPP_INETA_POOL        5
-#define DEF_XML_RPI_TUN_USE_INETA         6
-#define DEF_XML_RPI_APPL_TCPS_PORT        7
-#define DEF_XML_RPI_APPL_RANDOM_TCPSP     8
-#define DEF_XML_RPI_MAX                   9
+#define DEF_XML_RPI_STRAT_DRIVER          2
+#define DEF_XML_RPI_TCPC_TOMS             3
+#define DEF_XML_RPI_TCPC_NOT              4
+#define DEF_XML_RPI_PPP_SERVER            5
+#define DEF_XML_RPI_PPP_INETA_POOL        6
+#define DEF_XML_RPI_TUN_USE_INETA         7
+#define DEF_XML_RPI_APPL_TCPS_PORT        8
+#define DEF_XML_RPI_APPL_RANDOM_TCPSP     9
+#define DEF_XML_RPI_MAX                   10

+#ifndef HL_UNIX
+struct dsd_conf_strat_driver_e {            /* strategy-inst-win-driver */
+   char       *achc_keyword;                /* function name           */
+   enum ied_strategy_inst_win_driver iec_siwd;  /* strategy install - uninstall Windows TUN driver */
+};
+
+static struct dsd_conf_strat_driver_e dsrs_strat_driver[] = {  /* strategy-inst-win-driver */
+   {
+     "no-install-or-uninstall",
+     ied_siwd_no_inst_uninst                /* no install or uninstall */
+   },
+   {
+     "only-install-when-needed",
+     ied_siwd_only_inst                     /* only install when needed */
+   },
+   {
+     "uninstall-at-startup",
+     ied_siwd_uninst_startup                /* uninstall at startup    */
+   },
+   {
+     "uninstall-all-possible",
+     ied_siwd_uninst_all                      /* uninstall all possible  */
+   }
+};
+#endif
+
 static const char * achrs_node_rpi_ineta[] = {  /* raw-packet-interface INETA */
    "single-ineta",
    "ineta-start",
@@ -2430,6 +2552,10 @@
    struct dsd_user_ineta_c1 *adsl_user_ineta_c1_ch;  /* user entry configured INETA */
    struct dsd_user_ineta_c1 *adsl_user_ineta_c1_w1;  /* user entry configured INETA */
    struct dsd_user_ineta_c1 *adsl_user_ineta_c1_new;  /* user entry configured INETA */
+   struct dsd_filename_1 *adsl_filename_1_w1;  /* for filenames        */
+#ifdef HL_UNIX
+   struct dsd_filename_1 *adsl_filename_1_w2;  /* for filenames        */
+#endif
    struct dsd_user_group dsl_usgro;         /* structure in stack      */
    struct dsd_user_entry dsl_usent;         /* structure in stack      */
    struct dsd_ineta_single_ret dsl_ineta_sret_sip_gw;
@@ -3014,6 +3140,56 @@
 #endif
            break;
          }
+         if (iu1 == DEF_XML_GENERAL_SWAP_FILE) {  /* <swap-file>       */
+           dsl_ucs_l.ac_str = awcu3_value;  /* address of string       */
+           dsl_ucs_l.imc_len_str = -1;      /* length string in elements */
+           dsl_ucs_l.iec_chs_str = ied_chs_utf_16;  /* character set string */
+#ifdef HL_UNIX
+           adsl_filename_1_w1 = dsl_cs.adsc_loconf_1_fill->adsc_swap_fn_chain;  /* chain of filenames for swap file */
+           adsl_filename_1_w2 = NULL;
+           while (adsl_filename_1_w1) {     /* loop over chain of filenames for swap file */
+             bol2 = HL_M_CMP_FN( &iml1, &adsl_filename_1_w1->dsc_ucs_file_name, &dsl_ucs_l );
+             if ((bol2) && (iml1 == 0)) {   /* strings are equal       */
+               m_hlnew_printf( HLOG_WARN1, "HWSPXMLC0xxxxW line=%d col=%d Error element name \"sslgate-configuration\" \"general\" \"swap-file\"\
+ value \"%(ux)s\" defined double - ignored",
+                               MAC_XML_LINENO( adunode3 ), MAC_XML_COL( adunode3 ),
+                               awcu4_name );
+               break;
+             }
+             adsl_filename_1_w2 = adsl_filename_1_w1;  /* save last filename */
+             adsl_filename_1_w1 = adsl_filename_1_w1->adsc_next;  /* get next in chain */
+           }
+           if (adsl_filename_1_w1) break;
+#endif
+           iml1 = m_len_vx_ucs( HL_FN_CHARSET,
+                                &dsl_ucs_l )
+                    + 1;
+#ifndef HL_UNIX
+           iml1 *= sizeof(HL_WCHAR);
+#endif
+           adsl_filename_1_w1 = (struct dsd_filename_1 *) malloc( sizeof(struct dsd_filename_1) + iml1 );
+           adsl_filename_1_w1->adsc_next = NULL;
+           adsl_filename_1_w1->dsc_ucs_file_name.ac_str = adsl_filename_1_w1 + 1;  /* address of string */
+           adsl_filename_1_w1->dsc_ucs_file_name.imc_len_str = -1;  /* length string in elements */
+           adsl_filename_1_w1->dsc_ucs_file_name.iec_chs_str = HL_FN_CHARSET;
+           m_cpy_vx_ucs( adsl_filename_1_w1 + 1, iml1, HL_FN_CHARSET,
+                         &dsl_ucs_l );
+#ifndef HL_UNIX
+           dsl_cs.adsc_loconf_1_fill->adsc_swap_fn_chain = adsl_filename_1_w1;  /* chain of filenames for swap file */
+           break;
+#endif
+#ifdef HL_UNIX
+           if (adsl_filename_1_w2 == NULL) {  /* first in chain        */
+             dsl_cs.adsc_loconf_1_fill->adsc_swap_fn_chain = adsl_filename_1_w1;  /* chain of filenames for swap file */
+           } else {
+             adsl_filename_1_w2->adsc_next = adsl_filename_1_w1;  /* append to chain */
+           }
+           iu1 = 0;                         /* parameter may be defined multiple times */
+           break;
+#endif
+         }
+         if (iu1 == DEF_XML_GENERAL_SIG_CRED_FILE) {  /* <signature-credentials-file> */
+         }
          if (iu1 == DEF_XML_GENERAL_SNMP_CO) {  /* <SNMP-configuration> */
            bol1 = m_general_snmp( &dsl_cs, adunode3 );
 #ifdef B100726
@@ -3166,6 +3342,7 @@
              || (iu1 == DEF_XML_GENERAL_MAXACTWTHR)
              || (iu1 == DEF_XML_GENERAL_PRIOWT)
              || (iu1 == DEF_XML_GENERAL_PRIOPR)
+             || (iu1 == DEF_XML_GENERAL_MAX_UTIL_THR)  /* <max-util-thread> */
              || (iu1 == DEF_XML_GENERAL_REPINTV)
              || (iu1 == DEF_XML_GENERAL_WOLPORT)
              || (iu1 == DEF_XML_GENERAL_TIME_C_DF)  /* <time-cache-disk-file>  */
@@ -3186,9 +3363,11 @@
            }
          } else if (   (iu1 == DEF_XML_GENERAL_TCP_SNDBUF)  /* <TCP-sndbuf> */
                     || (iu1 == DEF_XML_GENERAL_TCP_RCVBUF)  /* <TCP-rcvbuf> */
+                    || (iu1 == DEF_XML_GENERAL_SWAP_IN_MEM)  /* <size-swap-in-memory> */
+                    || (iu1 == DEF_XML_GENERAL_MAX_SWAP_SIZE)  /* <max-swap-size> */
                     || (iu1 == DEF_XML_GENERAL_FILE_S_MAX)
                     || (iu1 == DEF_XML_GENERAL_FILE_STOR)
-                    || (iu1 == DEF_XML_GENERAL_THRES_MEM)  /* <memory-threshold>      */
+                    || (iu1 == DEF_XML_GENERAL_THRES_MEM)  /* <memory-threshold> */
                     || (iu1 == DEF_XML_GENERAL_MEM_LS)) {  /* <memory-log-size> */
            ill1 = m_get_bytes_no( awcu3_value );
            if (ill1 < 0) {
@@ -3199,8 +3378,10 @@
            }
          } else if (   (iu1 == DEF_XML_GENERAL_EVELOG)
                     || (iu1 == DEF_XML_GENERAL_SYSLOG)  /* <prot-syslog> */
+                    || (iu1 == DEF_XML_GENERAL_PROT_INCL_PID)  /* <prot-include-pid> */
                     || (iu1 == DEF_XML_GENERAL_LISTENGW)  /* <listen-gateway> */
                     || (iu1 == DEF_XML_GENERAL_RELOCONF)
+                    || (iu1 == DEF_XML_GENERAL_TCP_KEEPALIVE)  /* <TCP-keepalive> */
                     || (iu1 == DEF_XML_GENERAL_CLUSEDM)  /* <clear-used-memory> */
                     || (iu1 == DEF_XML_GENERAL_PTTD_CEHU)  /* <ignore-PTTD-connect-error-host-unreachable> */
                     || (iu1 == DEF_XML_GENERAL_ENA_SION_NPW)  /* <enable-sign-on-no-password> */
@@ -3265,6 +3446,16 @@
              bol_log = bol2;                /* with event log now      */
              break;
 #endif
+           case DEF_XML_GENERAL_PROT_INCL_PID:  /* <prot-include-pid>  */
+#ifndef HL_UNIX
+             m_hlnew_printf( HLOG_WARN1, "HWSPXMLC01060W Error element general name \"%(ux)s\" value \"%(ux)s\" not valid in Windows environment - ignored",
+                             awcu3_name, awcu3_value );
+             iu1 = 0;                       /* ignore this parameter   */
+             break;
+#else
+             adsp_loconf_1_fill->boc_prot_include_pid = bol2;  /* <prot-include-pid> */
+             break;
+#endif
            case DEF_XML_GENERAL_PIDFILE:    /* <pid-file>              */
 #ifndef HL_UNIX
              m_hlnew_printf( HLOG_WARN1, "HWSPXMLC01061W Error element general name \"%(ux)s\" value \"%(ux)s\" not valid in Windows environment - ignored",
@@ -3340,6 +3531,17 @@
              }
              adsp_loconf_1_fill->imc_tcp_rcvbuf = (int) ill1;  /* set TCP RCVBUF */
              break;
+           case DEF_XML_GENERAL_TCP_KEEPALIVE:  /* <TCP-keepalive>     */
+             adsp_loconf_1_fill->boc_tcp_keepalive = bol2;  /* set TCP KEEPALIVE */
+             break;
+           case DEF_XML_GENERAL_SWAP_IN_MEM:  /* <size-swap-in-memory> */
+// to-do 08.01.13 KB - warning if not multiple of ...
+             adsp_loconf_1_fill->imc_swap_mem_size = (int) (ill1 >> SHIFT_BLOCK_SWAP);  /* <size-swap-in-memory> in 64 KB units */
+             break;
+           case DEF_XML_GENERAL_MAX_SWAP_SIZE:  /* <max-swap-size>     */
+// to-do 08.01.13 KB - warning if not multiple of ...
+             adsp_loconf_1_fill->imc_max_swap_size = (int) (ill1 >> SHIFT_BLOCK_SWAP);  /* <max-swap-size> in 64 KB units */
+             break;
            case DEF_XML_GENERAL_MAXPOSSWTHR:
              if (iu2 == 0) break;           /* nothing to do           */
              if (iu2 < DEF_NO_WTHR_MINIMUM) {
@@ -3389,6 +3591,9 @@
              }
              iml_priority_process = iu2;    /* save for later          */
              break;
+           case DEF_XML_GENERAL_MAX_UTIL_THR:  /* <max-util-thread>    */
+             adsp_loconf_1_fill->imc_max_util_thread = iu2;  /* <max-util-thread> */
+             break;
            case DEF_XML_GENERAL_REPINTV:
              adsp_loconf_1_fill->inc_report_intv = iu2;  /* set value found */
              break;
@@ -5193,12 +5398,21 @@
    } while (FALSE);

    if (dsl_cs_ssl_cp.achc_fconfig) {        /* check file-content      */
+#ifndef B130121
+     memset( dsl_cs_ssl_cp.achc_fconfig, 0, dsl_cs_ssl_cp.unc_len_fconfig );
+#endif
      free( dsl_cs_ssl_cp.achc_fconfig );    /* free memory again       */
    }
    if (dsl_cs_ssl_cp.achc_fcertdb) {        /* check file-content      */
+#ifndef B130121
+     memset( dsl_cs_ssl_cp.achc_fcertdb, 0, dsl_cs_ssl_cp.unc_len_fcertdb );
+#endif
      free( dsl_cs_ssl_cp.achc_fcertdb );    /* free memory again       */
    }
    if (dsl_cs_ssl_cp.achc_password) {       /* check file-content      */
+#ifndef B130121
+     memset( dsl_cs_ssl_cp.achc_password, 0, dsl_cs_ssl_cp.unc_len_password );
+#endif
      free( dsl_cs_ssl_cp.achc_password );   /* free memory again       */
    }

@@ -6899,10 +7113,19 @@
 #ifdef TRACEHL1
    m_hlnew_printf( HLOG_XYZ1, "main check returned SSL / ireturn = %d", inl1 );
 #endif
+#ifndef B130121
+   memset( dsl_cs.achc_fconfig, 0, dsl_cs.unc_len_fconfig );
+#endif
    free( dsl_cs.achc_fconfig );
    dsl_cs.achc_fconfig = NULL;
+#ifndef B130121
+   memset( dsl_cs.achc_fcertdb, 0, dsl_cs.unc_len_fcertdb );
+#endif
    free( dsl_cs.achc_fcertdb );
    dsl_cs.achc_fcertdb = NULL;
+#ifndef B130121
+   memset( dsl_cs.achc_password, 0, dsl_cs.unc_len_password );
+#endif
    free( dsl_cs.achc_password );
    dsl_cs.achc_password = NULL;
    if (inl1) {
@@ -7579,9 +7802,24 @@
    goto p_buco_sect_80;                     /* sslgate-c next child    */

    p_buco_conn_92:                          /* free all set resources  */
+#ifdef B130121
    if (dsl_cs.achc_fconfig) free( dsl_cs.achc_fconfig );
    if (dsl_cs.achc_fcertdb) free( dsl_cs.achc_fcertdb );
    if (dsl_cs.achc_password) free( dsl_cs.achc_password );
+#else
+   if (dsl_cs.achc_fconfig) {               /* check file-content      */
+     memset( dsl_cs.achc_fconfig, 0, dsl_cs.unc_len_fconfig );
+     free( dsl_cs.achc_fconfig );           /* free memory again       */
+   }
+   if (dsl_cs.achc_fcertdb) {               /* check file-content      */
+     memset( dsl_cs.achc_fcertdb, 0, dsl_cs.unc_len_fcertdb );
+     free( dsl_cs.achc_fcertdb );           /* free memory again       */
+   }
+   if (dsl_cs.achc_password) {              /* check file-content      */
+     memset( dsl_cs.achc_password, 0, dsl_cs.unc_len_password );
+     free( dsl_cs.achc_password );          /* free memory again       */
+   }
+#endif
    /* free resources WTSGATE                                           */
    while (dsl_cs.adsc_wtsg1_ch) {           /* loop over total chain   */
      adsl_wtsg1_1 = dsl_cs.adsc_wtsg1_ch;   /* save element            */
@@ -9883,7 +10121,11 @@
 #ifndef OLD_1112
    struct dsd_ineta_single_ret dsl_ineta_single_ret;  /* single INETA  */
 #endif
+#ifdef B121120
    char       chrl_buffer_01[ 256 ];        /* buffer for different needs */
+#else
+   char       chrl_buffer_01[ 1024 ];       /* buffer for different needs */
+#endif

 #ifdef TRACEHL1
    m_hlnew_printf( HLOG_XYZ1, "m_conf_conn called %p", adsp_cs );
@@ -12768,10 +13010,10 @@
      adsp_cs->dsc_server_conf_1_c.iec_naeg1_se = ied_naeg1_no;  /* disable-naegle-send-server */
      goto p_buco_conn_76;                   /* mark element as set     */
    }
-   m_hlnew_printf( HLOG_XYZ1, "HWSPXMLC01nnnW Error %s%(ux)s%s %(ux)s disable-naegle-send-server not automatic / YES / NO: \"%(ux)s\" - ignored",
-               adsp_cs->achc_msgtext_1, adsp_cs->awcc_msgtext_1, adsp_cs->achc_msgtext_2,
-               adsp_cs->awcc_name_value,
-               awcu3_value );
+   m_hlnew_printf( HLOG_WARN1, "HWSPXMLC01nnnW Error %s%(ux)s%s %(ux)s disable-naegle-send-server not automatic / YES / NO: \"%(ux)s\" - ignored",
+                   adsp_cs->achc_msgtext_1, adsp_cs->awcc_msgtext_1, adsp_cs->achc_msgtext_2,
+                   adsp_cs->awcc_name_value,
+                   awcu3_value );
    goto p_buco_conn_80;                     /* get next name           */

    p_buco_conn_co_other_se:                 /* option-connect-other-server */
@@ -12818,7 +13060,7 @@

    p_buco_wtss_00:                          /* <wts-server-list>       */
    if (adsp_cs->dsc_server_conf_1_c.inc_function != DEF_FUNC_WTS) {  /* compare if WTSGATE */
-     m_hlnew_printf( HLOG_XYZ1, "HWSPXMLC01132W Error %s%(ux)s%s %(ux)s function not WTSGATE - wts-server-list superfluous - ignored",
+     m_hlnew_printf( HLOG_WARN1, "HWSPXMLC01132W Error %s%(ux)s%s %(ux)s function not WTSGATE - wts-server-list superfluous - ignored",
                      adsp_cs->achc_msgtext_1, adsp_cs->awcc_msgtext_1, adsp_cs->achc_msgtext_2,
                      adsp_cs->awcc_name_value );
      goto p_buco_conn_80;                   /* get next name           */
@@ -12835,7 +13077,7 @@
    awcu4_name = (HL_WCHAR *) adsl_node_02->getNodeName();
    bol1 = m_cmp_u16z_u8z( &inl1, awcu4_name, "wts-server-url" );
    if ((bol1 == FALSE) || (inl1)) {         /* strings not equal */
-     m_hlnew_printf( HLOG_XYZ1, "HWSPXMLC01134W Error %s%(ux)s%s %(ux)s wts-server-list entry \"%(ux)s\" invalid - ignored",
+     m_hlnew_printf( HLOG_WARN1, "HWSPXMLC01134W Error %s%(ux)s%s %(ux)s wts-server-list entry \"%(ux)s\" invalid - ignored",
                      adsp_cs->achc_msgtext_1, adsp_cs->awcc_msgtext_1, adsp_cs->achc_msgtext_2,
                      adsp_cs->awcc_name_value,
                      awcu4_name );
@@ -12843,7 +13085,7 @@
    }
    adsl_node_03 = adsl_node_02->getFirstChild();
    if (adsl_node_03 == NULL) {
-     m_hlnew_printf( HLOG_XYZ1, "HWSPXMLC01135W Error %s%(ux)s%s %(ux)s wts-server-list entry has no child - ignored",
+     m_hlnew_printf( HLOG_WARN1, "HWSPXMLC01135W Error %s%(ux)s%s %(ux)s wts-server-list entry has no child - ignored",
                      adsp_cs->achc_msgtext_1, adsp_cs->awcc_msgtext_1, adsp_cs->achc_msgtext_2,
                      adsp_cs->awcc_name_value );
      goto p_buco_wtss_60;                   /* get next list entry     */
@@ -12856,7 +13098,7 @@
      adsl_node_03 = adsl_node_03->getNextSibling();
    } while (adsl_node_03);
    if (adsl_node_03 == NULL) {
-     m_hlnew_printf( HLOG_XYZ1, "HWSPXMLC01136W Error %s%(ux)s%s %(ux)s wts-server-list entry \"%(ux)s\" no value found - ignored",
+     m_hlnew_printf( HLOG_WARN1, "HWSPXMLC01136W Error %s%(ux)s%s %(ux)s wts-server-list entry \"%(ux)s\" no value found - ignored",
                      adsp_cs->achc_msgtext_1, adsp_cs->awcc_msgtext_1, adsp_cs->achc_msgtext_2,
                      adsp_cs->awcc_name_value,
                      awcu3_name );
@@ -12866,6 +13108,11 @@
    iml1 = 0;                                /* index of character      */
    iml2 = 0;                                /* count brackets          */
    iml3 = 0;                                /* clear indicator end     */
+#ifndef B121120
+   iml4 = 0;                                /* clear position output   */
+#define AUCL_BUFFER_STA_L ((HL_WCHAR *) chrl_buffer_01)
+#define AUCL_BUFFER_END_L ((HL_WCHAR *) chrl_buffer_01 + sizeof(chrl_buffer_01) - sizeof(HL_WCHAR))
+#endif
    while (TRUE) {                           /* loop over characters    */
      switch (*(awcu4_value + iml1)) {       /* check character         */
        case 0:                              /* end if string           */
@@ -12894,10 +13141,32 @@
          iml2++;                            /* did close bracket       */
          break;
        case ':':                            /* separator in INETA IPV6 or before port */
+#ifdef B121120
          if (iml2 & 1) break;               /* bracket open            */
          iml3 = -1;                         /* set success             */
          break;
+#else
+         if (iml2 & 1) {                    /* bracket open            */
+           if ((AUCL_BUFFER_STA_L + iml1) >= AUCL_BUFFER_END_L) {
+             iml3 = 2;                      /* set error               */
+             break;
+           }
+           *(AUCL_BUFFER_STA_L + iml4) = *(awcu4_value + iml1);
+           iml4++;                          /* increment position output */
+           break;                           /* all done                */
+         }
+         iml3 = -1;                         /* set success             */
+         break;
+#endif
        default:                             /* other character         */
+#ifndef B121120
+         if ((AUCL_BUFFER_STA_L + iml1) >= AUCL_BUFFER_END_L) {
+           iml3 = 2;                        /* set error               */
+           break;
+         }
+         *(AUCL_BUFFER_STA_L + iml4) = *(awcu4_value + iml1);
+         iml4++;                            /* increment position output */
+#endif
          if (iml2 < 2) break;               /* not after end bracket   */
          iml3 = 2;                          /* set error               */
          break;
@@ -12906,7 +13175,7 @@
      iml1++;                                /* next character          */
    }
    if (iml3 >= 2) {                         /* error in string         */
-     m_hlnew_printf( HLOG_XYZ1, "HWSPXMLC01300W line=%d col=%d Error %s%(ux)s%s %(ux)s wts-server-list entry invalid URL found / %(ux)s / at character index %d. - ignored",
+     m_hlnew_printf( HLOG_WARN1, "HWSPXMLC01300W line=%d col=%d Error %s%(ux)s%s %(ux)s wts-server-list entry invalid URL found / %(ux)s / at character index %d. - ignored",
                      MAC_XML_LINENO( adsl_node_03 ),  /* line number in XML configuration file */
                      MAC_XML_COL( adsl_node_03 ),  /* column in XML configuration file */
                      adsp_cs->achc_msgtext_1, adsp_cs->awcc_msgtext_1, adsp_cs->achc_msgtext_2,
@@ -12914,10 +13183,15 @@
                      awcu4_value, iml1 );
      goto p_buco_wtss_60;                   /* get next list entry     */
    }
+#ifdef B121120
    bol1 = m_get_single_ineta( &iml2, &dsl_ineta_single_ret,
                               awcu4_value, iml1, ied_chs_utf_16 );  /* Unicode UTF-16 = WCHAR */
+#else
+   bol1 = m_get_single_ineta( &iml2, &dsl_ineta_single_ret,
+                              AUCL_BUFFER_STA_L, iml4, ied_chs_utf_16 );  /* Unicode UTF-16 = WCHAR */
+#endif
    if (bol1 == FALSE) {                     /* could not resolve INETA */
-     m_hlnew_printf( HLOG_XYZ1, "HWSPXMLC01301W line=%d col=%d Error %s%(ux)s%s %(ux)s wts-server-list entry invalid INETA found / %.*(ux)s error %d - ignored",
+     m_hlnew_printf( HLOG_WARN1, "HWSPXMLC01301W line=%d col=%d Error %s%(ux)s%s %(ux)s wts-server-list entry invalid INETA found / %.*(ux)s error %d - ignored",
                      MAC_XML_LINENO( adsl_node_03 ),  /* line number in XML configuration file */
                      MAC_XML_COL( adsl_node_03 ),  /* column in XML configuration file */
                      adsp_cs->achc_msgtext_1, adsp_cs->awcc_msgtext_1, adsp_cs->achc_msgtext_2,
@@ -12929,7 +13203,7 @@
    if (iml3 < 0) {                          /* with port               */
      iml_wtsg_port = m_get_port_no( awcu4_value + iml1 + 1, -1, ied_chs_utf_16 );  /* Unicode UTF-16 = WCHAR */
      if (iml_wtsg_port < 0) {               /* port number invalid     */
-       m_hlnew_printf( HLOG_XYZ1, "HWSPXMLC01302W line=%d col=%d Error %s%(ux)s%s %(ux)s wts-server-list entry invalid port after INETA found / %(ux)s - ignored",
+       m_hlnew_printf( HLOG_WARN1, "HWSPXMLC01302W line=%d col=%d Error %s%(ux)s%s %(ux)s wts-server-list entry invalid port after INETA found / %(ux)s - ignored",
                        MAC_XML_LINENO( adsl_node_03 ),  /* line number in XML configuration file */
                        MAC_XML_COL( adsl_node_03 ),  /* column in XML configuration file */
                        adsp_cs->achc_msgtext_1, adsp_cs->awcc_msgtext_1, adsp_cs->achc_msgtext_2,
@@ -12960,7 +13234,7 @@
      if (!memcmp( &adsl_wtsg1_2->dsc_soa,
                   &adsl_wtsg1_1->dsc_soa,
                   sizeof(struct sockaddr_storage) )) {
-       m_hlnew_printf( HLOG_XYZ1, "HWSPXMLC01303W line=%d col=%d Error %s%(ux)s%s %(ux)s wts-server-list entry INETA \"%(ux)s\" defined before - ignored",
+       m_hlnew_printf( HLOG_WARN1, "HWSPXMLC01303W line=%d col=%d Error %s%(ux)s%s %(ux)s wts-server-list entry INETA \"%(ux)s\" defined before - ignored",
                        MAC_XML_LINENO( adsl_node_03 ),  /* line number in XML configuration file */
                        MAC_XML_COL( adsl_node_03 ),  /* column in XML configuration file */
                        adsp_cs->achc_msgtext_1, adsp_cs->awcc_msgtext_1, adsp_cs->achc_msgtext_2,
@@ -13047,7 +13321,7 @@
    adsl_node_02 = adsl_node_02->getNextSibling();
    if (adsl_node_02) goto p_buco_wtss_20;
    if (adsp_cs->adsc_wtsg1_ch == NULL) {    /* chain server list       */
-     m_hlnew_printf( HLOG_XYZ1, "HWSPXMLC01139W Error %s%(ux)s%s %(ux)s wts-server-list no URL found - ignored",
+     m_hlnew_printf( HLOG_WARN1, "HWSPXMLC01139W Error %s%(ux)s%s %(ux)s wts-server-list no URL found - ignored",
                      adsp_cs->achc_msgtext_1, adsp_cs->awcc_msgtext_1, adsp_cs->achc_msgtext_2,
                      adsp_cs->awcc_name_value );
      goto p_buco_conn_80;                   /* get next name           */
@@ -14779,6 +15053,7 @@
    int        *aiml_val;                    /* address of value        */
    BOOL       bol_remote;                   /* cluster-entry is remote */
    BOOL       bol_deny_not_conf;            /* <deny-not-configured> set */
+   BOOL       bol_display_load;             /* <deny-not-configured> set */
    int        iml_e_04;                     /* entry on stage 4        */
    int        iml_e_se;                     /* entry server-entry, stage 5 */
    DOMNode    *adsl_node_04;
@@ -15176,6 +15451,14 @@
        }
        dsl_cluster_remote.imc_timeout_msec = m_get_cluster_entry_number( awcl_se_name, awcl_05_name, awcl_06_value );
        break;
+     case (DEF_XML_CL_ENT_TO_RECV_MSEC - 1):
+       if (bol_remote == FALSE) {           /* not remote              */
+         m_hlnew_printf( HLOG_XYZ1, "HWSPXMLC0UUUUW Error cluster cluster-entry %(ux)s node found \"%(ux)s\" not allowed when type LOCAL - ignored",
+                         awcl_se_name, awcl_05_name );
+         goto p_cluster_60;                 /* get next node on stage 5 */
+       }
+       dsl_cluster_remote.imc_recv_timeout = m_get_cluster_entry_number( awcl_se_name, awcl_05_name, awcl_06_value );
+       break;
      case (DEF_XML_CL_ENT_GROUP - 1):
        if (bol_remote) {                    /* is remote               */
          m_hlnew_printf( HLOG_XYZ1, "HWSPXMLC0UUUUW line=%d col=%d Error cluster cluster-entry %(ux)s node \"%(ux)s\" value \"%(ux)s\" not allowed when type REMOTE - ignored",
@@ -15352,8 +15635,20 @@
        }
        dsl_cluster_main.imc_time_retry_conn = iml1;
        break;
+     case (DEF_XML_CL04_TIMEOUT_RECV - 1):  /* <timeout-receive-millisec-all> */
+       if (dsl_cluster_main.imc_recv_timeout) {  /* already defined    */
+         m_hlnew_printf( HLOG_XYZ1, "HWSPXMLC0UUUUW Error element cluster name \"%(ux)s\" value \"%(ux)s\" already defined - ignored",
+                         awcl_04_name, awcl_05_value );
+         goto p_cluster_80;                 /* get next node on stage 4 */
+       }
+       dsl_cluster_main.imc_recv_timeout = iml1;  /* receive timeout   */
+       break;
      case (DEF_XML_CL04_DENY_NOT_CONF - 1):  /* <deny-not-configured>  */
-       if (bol_deny_not_conf) {             /* already defined         */
+     case (DEF_XML_CL04_DISPLAY_LOAD - 1):  /* <display-load>          */
+       if (   (   (iml_e_04 == DEF_XML_CL04_DENY_NOT_CONF - 1)
+               && (bol_deny_not_conf))      /* already defined         */
+           || (   (iml_e_04 == DEF_XML_CL04_DISPLAY_LOAD - 1)
+               && (bol_display_load))) {    /* already defined         */
          m_hlnew_printf( HLOG_XYZ1, "HWSPXMLC0UUUUW line=%d col=%d Error element cluster name \"%(ux)s\" value \"%(ux)s\" already defined - ignored",
                          MAC_XML_LINENO( adsl_node_05 ), MAC_XML_COL( adsl_node_05 ),
                          awcl_04_name, awcl_05_value );
@@ -15361,14 +15656,26 @@
        }
        bol1 = m_cmp_u16z_u8z( &iml1, awcl_05_value, "YES" );
        if ((bol1) && (iml1 == 0)) {         /* strings are equal       */
-         dsl_cluster_main.boc_deny_not_configured = TRUE;  /* deny connect in from not configured WSP */
-         bol_deny_not_conf = TRUE;          /* parameter defined       */
+         if (iml_e_04 == DEF_XML_CL04_DENY_NOT_CONF - 1) {
+           dsl_cluster_main.boc_deny_not_configured = TRUE;  /* deny connect in from not configured WSP */
+           bol_deny_not_conf = TRUE;        /* parameter defined       */
+         }
+         if (iml_e_04 == DEF_XML_CL04_DISPLAY_LOAD - 1) {
+           dsl_cluster_main.boc_display_load = TRUE;  /* display load every time calculated */
+           bol_display_load = TRUE;         /* parameter defined       */
+         }
          goto p_cluster_80;                 /* get next node on stage 4 */
        }
        bol1 = m_cmp_u16z_u8z( &iml1, awcl_05_value, "NO" );
        if ((bol1) && (iml1 == 0)) {         /* strings are equal       */
-         dsl_cluster_main.boc_deny_not_configured = FALSE;  /* deny connect in from not configured WSP */
-         bol_deny_not_conf = TRUE;          /* parameter defined       */
+         if (iml_e_04 == DEF_XML_CL04_DENY_NOT_CONF - 1) {
+           dsl_cluster_main.boc_deny_not_configured = FALSE;  /* deny connect in from not configured WSP */
+           bol_deny_not_conf = TRUE;        /* parameter defined       */
+         }
+         if (iml_e_04 == DEF_XML_CL04_DISPLAY_LOAD - 1) {
+           dsl_cluster_main.boc_display_load = FALSE;  /* display load every time calculated */
+           bol_display_load = TRUE;         /* parameter defined       */
+         }
          goto p_cluster_80;                 /* get next node on stage 4 */
        }
        m_hlnew_printf( HLOG_XYZ1, "HWSPXMLC0UUUUW line=%d col=%d Error element cluster name \"%(ux)s\" value \"%(ux)s\" neither \"YES\" nor \"NO\" - ignored",
@@ -17547,7 +17854,7 @@
 //#ifdef OLD01
    adsl_node_fichi = adsp_node->getFirstChild();
    if (adsl_node_fichi == NULL) {
-     m_hlnew_printf( HLOG_XYZ1, "HWSPXMLCUUUUUW Error L2TP-gateway has no child - ignored" );
+     m_hlnew_printf( HLOG_XYZ1, "HWSPXMLC02700W Error L2TP-gateway has no child - ignored" );
      return;                                /* all done                */
    }
 //#endif
@@ -17561,7 +17868,7 @@
        bol1 = m_cmp_u16z_u8z( &iml1, awcl_05_name, "name" );
        if ((bol1) && (iml1 == 0)) {         /* strings are equal       */
          if (adsl_node_l2tp_gw) {           /* name already defined    */
-           m_hlnew_printf( HLOG_XYZ1, "HWSPXMLCUUUUUW Error element L2TP-gateway name double - ignored" );
+           m_hlnew_printf( HLOG_XYZ1, "HWSPXMLC02701W Error element L2TP-gateway name double - ignored" );
          } else {
            adsl_node_l2tp_gw = adsl_node_04;  /* save name             */
          }
@@ -17570,13 +17877,13 @@
      adsl_node_04 = adsl_node_04->getNextSibling();
    } while (adsl_node_04);
    if (adsl_node_l2tp_gw == NULL) {         /* no name found           */
-     m_hlnew_printf( HLOG_XYZ1, "HWSPXMLCUUUUUW Error L2TP-gateway has no name - ignored" );
+     m_hlnew_printf( HLOG_XYZ1, "HWSPXMLC02702W Error L2TP-gateway has no name - ignored" );
      return;                                /* do not process this entry */
    }
    /* retrieve name                                                    */
    adsl_node_05 = adsl_node_l2tp_gw->getFirstChild();
    if (adsl_node_05 == NULL) {              /* no child found          */
-     m_hlnew_printf( HLOG_XYZ1, "HWSPXMLC0UUUUW Error element L2TP-gateway name \"name\" has no child - ignored" );
+     m_hlnew_printf( HLOG_XYZ1, "HWSPXMLC02703W Error element L2TP-gateway name \"name\" has no child - ignored" );
      return;                                /* do not process this entry */
    }
    do {
@@ -17587,7 +17894,7 @@
      adsl_node_05 = adsl_node_05->getNextSibling();
    } while (adsl_node_05);                  /* for all siblings        */
    if (adsl_node_05 == NULL) {              /* no text found           */
-     m_hlnew_printf( HLOG_XYZ1, "HWSPXMLC0UUUUW Error element L2TP-gateway name \"name\" no TEXT_NODE found - ignored" );
+     m_hlnew_printf( HLOG_XYZ1, "HWSPXMLC02704W Error element L2TP-gateway name \"name\" no TEXT_NODE found - ignored" );
      return;                                /* do not process this entry */
    }
    adsl_l2tp_conf_w1 = adsp_cs->adsc_loconf_1_fill->adsc_l2tp_conf;  /* get chain L2TP gateways */
@@ -17596,7 +17903,7 @@
                          awcl_l2tp_gw_name, -1, ied_chs_utf_16,
                          adsl_l2tp_conf_w1 + 1, adsl_l2tp_conf_w1->imc_len_name, ied_chs_utf_8 );
      if (bol1 && (iml_cmp == 0)) {          /* strings are equal       */
-       m_hlnew_printf( HLOG_XYZ1, "HWSPXMLC0UUUUW Error element L2TP-gateway %(ux)s already defined - ignored",
+       m_hlnew_printf( HLOG_XYZ1, "HWSPXMLC02705W Error element L2TP-gateway %(ux)s already defined - ignored",
                        awcl_l2tp_gw_name );
        return;                              /* do not process this entry */
      }
@@ -17623,39 +17930,76 @@
        } while (iml1);
        do {                                 /* pseudo-loop             */
          if (iml1 <= 0) {                   /* keyword not defined     */
-           m_hlnew_printf( HLOG_XYZ1, "HWSPXMLC0UUUUW Error L2TP-gateway name \"%(ux)s\" element \"%(ux)s\" not defined - ignored",
+           m_hlnew_printf( HLOG_XYZ1, "HWSPXMLC02710W Error L2TP-gateway name \"%(ux)s\" element \"%(ux)s\" not defined - ignored",
                            awcl_l2tp_gw_name, awcl_05_name );
            break;
          }
          if (awcrl_value[ iml1 - 1 ]) {     /* element already defined */
-           m_hlnew_printf( HLOG_XYZ1, "HWSPXMLC0UUUUW Error L2TP-gateway name \"%(ux)s\" element \"%(ux)s\" double - ignored",
+           m_hlnew_printf( HLOG_XYZ1, "HWSPXMLC02711W Error L2TP-gateway name \"%(ux)s\" element \"%(ux)s\" double - ignored",
                            awcl_l2tp_gw_name, awcl_05_name );
            break;
          }
-         if (   (iml1 == DEF_XML_L2TP_GW_AUTH_PWD_PLAIN)
-             && (awcrl_value[ DEF_XML_L2TP_GW_AUTH_PWD_ENCRY - 1 ])) {
-           m_hlnew_printf( HLOG_WARN1, "HWSPXMLC0nnnnW line=%d col=%d Error L2TP-gateway name \"%(ux)s\" found node name \"<authenticate-use-password-plain>\" but
authenticate-use-password-enrypted already defined - ignored",
-                           MAC_XML_LINENO( adsp_node ), MAC_XML_COL( adsp_node ),
+//       if (   (iml1 == DEF_XML_L2TP_GW_AUTH_PWD_PLAIN)
+//           && (awcrl_value[ DEF_XML_L2TP_GW_AUTH_PWD_ENCRY - 1 ])) {
+         if (   (iml1 == (DEF_XML_L2TP_GW_AUTH_PWD_PLAIN + 1))
+             && (awcrl_value[ DEF_XML_L2TP_GW_AUTH_PWD_ENCRY ])) {
+           m_hlnew_printf( HLOG_WARN1, "HWSPXMLC02712W line=%d col=%d Error L2TP-gateway name \"%(ux)s\" found node name \"<authenticate-use-password-plain>\" but
authenticate-use-password-enrypted already defined - ignored",
+                           MAC_XML_LINENO( adsl_node_04 ), MAC_XML_COL( adsl_node_04 ),
                            awcl_l2tp_gw_name );
            break;
          }
-         if (   (iml1 == DEF_XML_L2TP_GW_AUTH_PWD_ENCRY)
-             && (awcrl_value[ DEF_XML_L2TP_GW_AUTH_PWD_PLAIN - 1 ])) {
-           m_hlnew_printf( HLOG_WARN1, "HWSPXMLC0nnnnW line=%d col=%d Error L2TP-gateway name \"%(ux)s\" found node name \"<authenticate-use-password-encrypted>\" but
authenticate-use-password-plain already defined - ignored",
-                           MAC_XML_LINENO( adsp_node ), MAC_XML_COL( adsp_node ),
+//       if (   (iml1 == DEF_XML_L2TP_GW_AUTH_PWD_ENCRY)
+//           && (awcrl_value[ DEF_XML_L2TP_GW_AUTH_PWD_PLAIN - 1 ])) {
+         if (   (iml1 == (DEF_XML_L2TP_GW_AUTH_PWD_ENCRY + 1))
+             && (awcrl_value[ DEF_XML_L2TP_GW_AUTH_PWD_PLAIN ])) {
+           m_hlnew_printf( HLOG_WARN1, "HWSPXMLC02713W line=%d col=%d Error L2TP-gateway name \"%(ux)s\" found node name \"<authenticate-use-password-encrypted>\" but
authenticate-use-password-plain already defined - ignored",
+                           MAC_XML_LINENO( adsl_node_04 ), MAC_XML_COL( adsl_node_04 ),
                            awcl_l2tp_gw_name );
            break;
          }
          adsl_node_05 = adsl_node_04->getFirstChild();
          if (adsl_node_05 == NULL) {        /* no child found          */
-           m_hlnew_printf( HLOG_XYZ1, "HWSPXMLC0UUUUW Error L2TP-gateway name \"%(ux)s\" element \"%(ux)s\" has no child - ignored",
+           m_hlnew_printf( HLOG_XYZ1, "HWSPXMLC02714W Error L2TP-gateway name \"%(ux)s\" element \"%(ux)s\" has no child - ignored",
                            awcl_l2tp_gw_name, awcl_05_name );
            break;
          }
          do {
            if (adsl_node_05->getNodeType() == DOMNode::TEXT_NODE) {
              awcrl_value[ iml1 - 1 ] = (HL_WCHAR *) adsl_node_05->getNodeValue();
-             if (iml1 != DEF_XML_L2TP_GW_AUTH_PWD_ENCRY) break;
+//           if (iml1 == DEF_XML_L2TP_GW_AUTH_CHARSET) {
+             if (iml1 == (DEF_XML_L2TP_GW_AUTH_CHARSET + 1)) {
+               iml2 = sizeof(dsrs_radius_gr_charset_tab) / sizeof(dsrs_radius_gr_charset_tab[0]);
+               while (TRUE) {               /* loop over possible values */
+                 iml2--;                    /* decrement index         */
+                 if (iml2 < 0) {            /* value not found in table */
+                   m_hlnew_printf( HLOG_XYZ1, "HWSPXMLC02720W line=%d col=%d Error L2TP-gateway name %(ux)s element \"authenticate-use-charset\" charset found \"%(ux)s\" - not
defined, ignored",
+                                   MAC_XML_LINENO( adsl_node_04 ), MAC_XML_COL( adsl_node_04 ),
+                                   awcl_l2tp_gw_name,
+                                   awcrl_value[ iml1 - 1 ] );
+                   awcrl_value[ iml1 - 1 ] = NULL;
+                   break;
+                 }
+                 bol1 = m_cmp_vx_vx( &iml_cmp,
+                                     awcrl_value[ iml1 - 1 ], -1, ied_chs_utf_16,
+                                     dsrs_radius_gr_charset_tab[ iml2 ].achc_name, -1, ied_chs_utf_8 );
+                 if ((bol1) && (iml_cmp == 0)) break;  /* strings are equal    */
+               }
+               if (iml2 < 0) break;
+               if (   (dsrs_radius_gr_charset_tab[ iml2 ].iec_chs != ied_chs_utf_8)  /* Unicode UTF-8 */
+                   && (dsrs_radius_gr_charset_tab[ iml2 ].iec_chs != ied_chs_ansi_819)  /* ANSI 819 */
+                   && (dsrs_radius_gr_charset_tab[ iml2 ].iec_chs != ied_chs_ascii_850)) {  /* ASCII 850 */
+                 m_hlnew_printf( HLOG_XYZ1, "HWSPXMLC02721W line=%d col=%d Error L2TP-gateway name %(ux)s element \"authenticate-use-charset\" charset found \"%(ux)s\" not valid for
PPP authentication - ignored",
+                                 MAC_XML_LINENO( adsl_node_04 ), MAC_XML_COL( adsl_node_04 ),
+                                 awcl_l2tp_gw_name,
+                                 awcrl_value[ iml1 - 1 ] );
+                 awcrl_value[ iml1 - 1 ] = NULL;
+                 break;
+               }
+               dsl_l2tp_conf_fill.iec_chs_ppp = dsrs_radius_gr_charset_tab[ iml2 ].iec_chs;  /* character set PPP */
+               break;
+             }
+//           if (iml1 != DEF_XML_L2TP_GW_AUTH_PWD_ENCRY) break;
+             if (iml1 != (DEF_XML_L2TP_GW_AUTH_PWD_ENCRY + 1)) break;
              dsl_ucs_l.ac_str = awcrl_value[ iml1 - 1 ];    /* address of string       */
              dsl_ucs_l.imc_len_str = -1;          /* length string in elements */
              dsl_ucs_l.iec_chs_str = ied_chs_utf_16;  /* character set string */
@@ -17665,30 +18009,32 @@
                                                     achl_auth_pwd_1, iml2,
                                                     &dsl_ucs_l );
              if (iml_len_auth_pwd_1 <= 0) {  /* error occured          */
-               m_hlnew_printf( HLOG_WARN1, "HWSPXMLC0nnnnW line=%d col=%d Error L2TP-gateway name \"%(ux)s\" element \"authenticate-use-password-encrypted\" base64 error %d position
%d in string \"%(ux)s\" - ignored",
-                               MAC_XML_LINENO( adsl_node_05 ), MAC_XML_COL( adsl_node_05 ),
+               m_hlnew_printf( HLOG_WARN1, "HWSPXMLC02730W line=%d col=%d Error L2TP-gateway name \"%(ux)s\" element \"authenticate-use-password-encrypted\" base64 error %d position
%d in string \"%(ux)s\" - ignored",
+                               MAC_XML_LINENO( adsl_node_04 ), MAC_XML_COL( adsl_node_04 ),
                                awcl_l2tp_gw_name,
                                iml2, iml3, dsl_ucs_l.ac_str );
                free( achl_auth_pwd_1 );     /* free memory again       */
                achl_auth_pwd_1 = NULL;
-               awcrl_value[ DEF_XML_L2TP_GW_AUTH_PWD_ENCRY - 1 ] = NULL;  /* node ignored */
+//             awcrl_value[ DEF_XML_L2TP_GW_AUTH_PWD_ENCRY - 1 ] = NULL;  /* node ignored */
+               awcrl_value[ DEF_XML_L2TP_GW_AUTH_PWD_ENCRY ] = NULL;  /* node ignored */
                break;
              }
              bol1 = m_check_vx( achl_auth_pwd_1, iml_len_auth_pwd_1, ied_chs_utf_8 );  /* check Unicode UTF-8 */
              if (bol1) break;               /* no error                */
-             m_hlnew_printf( HLOG_WARN1, "HWSPXMLC0nnnnW line=%d col=%d Error L2TP-gateway name \"%(ux)s\" element \"authenticate-use-password-encrypted\" string \"%(ux)s\" decoded
no valid UTF-8 - ignored",
-                             MAC_XML_LINENO( adsl_node_05 ), MAC_XML_COL( adsl_node_05 ),
+             m_hlnew_printf( HLOG_WARN1, "HWSPXMLC02731W line=%d col=%d Error L2TP-gateway name \"%(ux)s\" element \"authenticate-use-password-encrypted\" string \"%(ux)s\" decoded
no valid UTF-8 - ignored",
+                             MAC_XML_LINENO( adsl_node_04 ), MAC_XML_COL( adsl_node_04 ),
                              awcl_l2tp_gw_name,
                              dsl_ucs_l.ac_str );
              free( achl_auth_pwd_1 );       /* free memory again       */
              achl_auth_pwd_1 = NULL;
-             awcrl_value[ DEF_XML_L2TP_GW_AUTH_PWD_ENCRY - 1 ] = NULL;  /* node ignored */
+//           awcrl_value[ DEF_XML_L2TP_GW_AUTH_PWD_ENCRY - 1 ] = NULL;  /* node ignored */
+             awcrl_value[ DEF_XML_L2TP_GW_AUTH_PWD_ENCRY ] = NULL;  /* node ignored */
              break;
            }
            adsl_node_05 = adsl_node_05->getNextSibling();
          } while (adsl_node_05);            /* for all siblings        */
          if (adsl_node_05 == NULL) {        /* no text found           */
-           m_hlnew_printf( HLOG_XYZ1, "HWSPXMLC0UUUUW Error L2TP-gateway name \"%(ux)s\" element \"%(ux)s\" no TEXT_NODE found - ignored",
+           m_hlnew_printf( HLOG_XYZ1, "HWSPXMLC02715W Error L2TP-gateway name \"%(ux)s\" element \"%(ux)s\" no TEXT_NODE found - ignored",
                            awcl_l2tp_gw_name, awcl_05_name );
          }
        } while (FALSE);
@@ -17696,7 +18042,7 @@
      adsl_node_04 = adsl_node_04->getNextSibling();
    } while (adsl_node_04);
    if (awcrl_value[ DEF_XML_L2TP_GW_SERVER_INETA ] == NULL) {  /* no serverineta found */
-     m_hlnew_printf( HLOG_XYZ1, "HWSPXMLCUUUUUW Error L2TP-gateway name %(ux)s <serverineta> missing - ignored",
+     m_hlnew_printf( HLOG_XYZ1, "HWSPXMLC02750W Error L2TP-gateway name %(ux)s <serverineta> missing - ignored",
                      awcl_l2tp_gw_name );
      if (achl_auth_pwd_1 == NULL) return;   /* address of password     */
      free( achl_auth_pwd_1 );               /* free memory of password */
@@ -17708,7 +18054,7 @@
                              awcrl_value[ DEF_XML_L2TP_GW_GATE_I ], -1, ied_chs_utf_16,
                              awcrl_value[ DEF_XML_L2TP_GW_SERVER_INETA ], -1, ied_chs_utf_16 );
    if (iml1) {                              /* error occured           */
-     m_hlnew_printf( HLOG_XYZ1, "HWSPXMLCUUUUUW Error L2TP-gateway name \"%(ux)s\" serverineta \"%(ux)s\" error %d %s - ignored",
+     m_hlnew_printf( HLOG_XYZ1, "HWSPXMLC02751W Error L2TP-gateway name \"%(ux)s\" serverineta \"%(ux)s\" error %d %s - ignored",
                      awcl_l2tp_gw_name, awcrl_value[ DEF_XML_L2TP_GW_SERVER_INETA ], iml1, chrl_work1 );
      if (achl_auth_pwd_1 == NULL) return;   /* address of password     */
      free( achl_auth_pwd_1 );               /* free memory of password */
@@ -17718,7 +18064,7 @@
    if (awcrl_value[ DEF_XML_L2TP_GW_SERVER_PORT ]) {  /* port configured */
      iml1 = m_get_port_no( awcrl_value[ DEF_XML_L2TP_GW_SERVER_PORT ], -1, ied_chs_utf_16 );
      if (iml1 < 0) {                        /* port not valid          */
-       m_hlnew_printf( HLOG_XYZ1, "HWSPXMLCUUUUUW Error L2TP-gateway name \"%(ux)s\" serverport \"%(ux)s\" invalid - use default L2TP port 1701",
+       m_hlnew_printf( HLOG_XYZ1, "HWSPXMLC02752W Error L2TP-gateway name \"%(ux)s\" serverport \"%(ux)s\" invalid - use default L2TP port 1701",
                        awcl_l2tp_gw_name, awcrl_value[ DEF_XML_L2TP_GW_SERVER_PORT ] );
        iml1 = DEFAULT_UDP_PORT_L2TP;        /* set default port        */
      }
@@ -17727,13 +18073,13 @@
      = htons( iml1 );                       /* set target port         */
    if (   (awcrl_value[ DEF_XML_L2TP_GW_AUTH_PWD_PLAIN ])  /* password configured */
        && (awcrl_value[ DEF_XML_L2TP_GW_AUTH_USERID ] == NULL)) {  /* userid not configured */
-     m_hlnew_printf( HLOG_XYZ1, "HWSPXMLCUUUUUW Error L2TP-gateway name \"%(ux)s\" <authenticate-use-password-plain> \"%(ux)s\" configured but no <authenticate-use-userid> -
<authenticate-use-password-plain> ignored",
+     m_hlnew_printf( HLOG_XYZ1, "HWSPXMLC02753W Error L2TP-gateway name \"%(ux)s\" <authenticate-use-password-plain> \"%(ux)s\" configured but no <authenticate-use-userid> -
<authenticate-use-password-plain> ignored",
                      awcl_l2tp_gw_name, awcrl_value[ DEF_XML_L2TP_GW_AUTH_PWD_PLAIN ] );
      awcrl_value[ DEF_XML_L2TP_GW_AUTH_PWD_PLAIN ] = NULL;
    }
    if (   (awcrl_value[ DEF_XML_L2TP_GW_AUTH_PWD_ENCRY ])  /* password configured */
        && (awcrl_value[ DEF_XML_L2TP_GW_AUTH_USERID ] == NULL)) {  /* userid not configured */
-     m_hlnew_printf( HLOG_XYZ1, "HWSPXMLCUUUUUW Error L2TP-gateway name \"%(ux)s\" <authenticate-use-password-encrypted> \"%(ux)s\" configured but no <authenticate-use-userid> -
<authenticate-use-password-encrypted> ignored",
+     m_hlnew_printf( HLOG_XYZ1, "HWSPXMLC02754W Error L2TP-gateway name \"%(ux)s\" <authenticate-use-password-encrypted> \"%(ux)s\" configured but no <authenticate-use-userid> -
<authenticate-use-password-encrypted> ignored",
                      awcl_l2tp_gw_name, awcrl_value[ DEF_XML_L2TP_GW_AUTH_PWD_ENCRY ] );
      free( achl_auth_pwd_1 );               /* free memory again       */
      achl_auth_pwd_1 = NULL;
@@ -19049,14 +19395,24 @@
                                   struct dsd_conf_serv *adsp_cs ) {
    int        iml1, iml2, iml3;             /* working variables       */
    BOOL       bol1;                         /* working variable        */
+#ifdef B130108
    BOOL       bol_c_tun_ipv4;               /* configured TUN IPV4     */
    BOOL       bol_c_tun_ipv6;               /* configured TUN IPV6     */
+#endif
    BOOL       bol_pool_compl;               /* pool entries have been processed */
+   BOOL       bol_taif_ineta_ipv4;          /* <TUN-adapter-use-interface-ineta> IPV4 filled */
+   BOOL       bol_taif_ineta_ipv6;          /* <TUN-adapter-use-interface-ineta> IPV6 filled */
    int        iml_ign_pool;                 /* ignore some pool entries */
    int        iml_cmp;                      /* compare values          */
    int        iml_e_04;                     /* entry on stage 4        */
    int        iml_e_05;                     /* entry on stage 5        */
    int        iml_len_pool;                 /* compute length entries of pool */
+#ifdef XYZ1
+   int        iml_ineta_type;               /* type of INETA           */
+                                            /* 0 = TUN-adapter-ineta   */
+                                            /* 1 = TUN-adapter-use-interface-ineta */
+#endif
+   int        iml_len_temp_ineta;           /* length array temporary INETAs filled */
    void *     al_work1;                     /* pointer to value        */
    char       *achl1, *achl2, *achl3;       /* working variables       */
    HL_WCHAR   *awcl1;                       /* working variable        */
@@ -19087,6 +19443,7 @@
    struct dsd_ineta_single_ret dsl_ineta_sret_work_2;
    struct dsd_ineta_temp_1 dsl_ineta_temp_1_l;  /* temporary INETA     */
    struct dsd_port_temp_1 dsl_port_temp_1_l;  /* temporary port        */
+   char       byrl_temp_ineta[ 512 ];       /* temporary storage INETAs */

    adsl_node_fichi = adsp_node->getFirstChild();
    if (adsl_node_fichi == NULL) {
@@ -19098,6 +19455,9 @@
    adsl_ineta_temp_1_ch = NULL;             /* clear chain temporary INETAs */
    adsl_port_temp_1_ch = NULL;              /* clear chain temporary ports */
    iml_ign_pool = 0;                        /* ignore some pool entries */
+   iml_len_temp_ineta = 0;                  /* length array temporary INETAs filled */
+   bol_taif_ineta_ipv4 = FALSE;             /* <TUN-adapter-use-interface-ineta> IPV4 filled */
+   bol_taif_ineta_ipv6 = FALSE;             /* <TUN-adapter-use-interface-ineta> IPV6 filled */
    adsl_node_04 = adsl_node_fichi;          /* get first node          */

    p_rpi_main_20:                           /* process node on stage 4 */
@@ -19191,6 +19551,7 @@
    bol1 = FALSE;                            /* is not invalid          */
    switch (iml_e_04) {                      /* index keyword           */
      case DEF_XML_RPI_TA_INETA:             /* TUN-adapter-ineta       */
+#ifdef B130107
 #ifdef B100802
        al_work1 = &dsl_rpi_conf.umc_ta_ineta;  /* pointer to value     */
 #endif
@@ -19202,11 +19563,25 @@
        if (awcl_05_value) goto p_rpi_ta_ineta_00;  /* TUN-adapter INETA */
        bol1 = TRUE;                         /* node is invalid         */
        break;
+#endif
+#ifdef XYZ1
+       iml_ineta_type                       /* type of INETA           */
+         = 0;                               /* 0 = TUN-adapter-ineta   */
+#endif
+       goto p_rpi_ta_ineta_00;              /* TUN-adapter INETA */
      case DEF_XML_RPI_TA_UIF_INETA:         /* TUN-adapter-use-interface-ineta */
+#ifdef B130107
        al_work1 = &dsl_rpi_conf.umc_taif_ineta;  /* pointer to value   */
        if (awcl_05_value) goto p_rpi_ta_ineta_00;  /* TUN-adapter INETA */
        bol1 = TRUE;                         /* node is invalid         */
        break;
+#endif
+#ifdef XYZ1
+       iml_ineta_type                       /* type of INETA           */
+         = 1;                               /* 1 = TUN-adapter-use-interface-ineta */
+#endif
+       goto p_rpi_ta_ineta_00;              /* TUN-adapter INETA */
+     case DEF_XML_RPI_STRAT_DRIVER:         /* strategy-inst-win-driver */
      case DEF_XML_RPI_TCPC_TOMS:            /* TCP-connect-timeout-millisec */
        al_work1 = &dsl_rpi_conf.imc_tcpc_to_msec;  /* pointer to value */
        if (awcl_05_value) goto p_rpi_num_00;  /* numeric value         */
@@ -19360,17 +19735,21 @@
    goto p_rpi_ineta_60;                     /* compare INETAs if previously defined */

    p_rpi_ta_ineta_00:                       /* TUN-adapter INETA       */
+#ifdef B130107
 // to-do 24.07.10 KB - Unix multiple
    if (borl_rpi_main[ iml_e_04 ]) {         /* defined double          */
      goto p_rpi_node_double;                /* the node is double defined */
    }
+#endif
    bol1 = m_get_single_ineta( &iml1, &dsl_ineta_sret_work_1,
                               awcl_05_value, -1, ied_chs_utf_16 );
    if (bol1 == FALSE) {                     /* error occured           */
-     m_hlnew_printf( HLOG_XYZ1, "HWSPXMLC01nnnW Error raw-packet-interface name \"%(ux)s\" value \"%(ux)s\" INETA invalid, error %d - ignored",
+     m_hlnew_printf( HLOG_XYZ1, "HWSPXMLC01nnnW line=%d col=%d Error raw-packet-interface name \"%(ux)s\" value \"%(ux)s\" INETA invalid, error %d - ignored",
+                     MAC_XML_LINENO( adsl_node_04 ), MAC_XML_COL( adsl_node_04 ),
                      awcl_05_name, awcl_05_value, iml1 );
      goto p_rpi_main_60;                    /* get next node on stage 4 */
    }
+#ifdef B130107
    if (dsl_ineta_sret_work_1.usc_family != AF_INET) {  /* family IPV4 / IPV6 */
      m_hlnew_printf( HLOG_XYZ1, "HWSPXMLC01nnnW Error raw-packet-interface name \"%(ux)s\" value \"%(ux)s\" INETA not IPV4 (only IPV4 supported) - ignored",
                      awcl_05_name, awcl_05_value );
@@ -19390,6 +19769,93 @@
    *((UNSIG_MED *) al_work1) = *((UNSIG_MED *) dsl_ineta_sret_work_1.chrc_ineta);
    borl_rpi_main[ iml_e_04 ] = TRUE;        /* for defined double      */
    goto p_rpi_main_60;                      /* get next node on stage 4 */
+#endif
+   if (iml_e_04 == DEF_XML_RPI_TA_UIF_INETA) {  /* TUN-adapter-use-interface-ineta */
+     if (dsl_ineta_sret_work_1.usc_family == AF_INET) {  /* family IPV4 */
+       if (bol_taif_ineta_ipv4) {           /* <TUN-adapter-use-interface-ineta> IPV4 filled */
+         m_hlnew_printf( HLOG_XYZ1, "HWSPXMLC01nnnW line=%d col=%d Error raw-packet-interface name \"TUN-adapter-use-interface-ineta\" IPV4 value \"%(ux)s\" already defined before -
ignored",
+                         MAC_XML_LINENO( adsl_node_04 ), MAC_XML_COL( adsl_node_04 ),
+                         awcl_05_value,
+                         (unsigned char) dsl_ineta_sret_work_1.chrc_ineta[0],
+                         (unsigned char) dsl_ineta_sret_work_1.chrc_ineta[1],
+                         (unsigned char) dsl_ineta_sret_work_1.chrc_ineta[2],
+                         (unsigned char) dsl_ineta_sret_work_1.chrc_ineta[3] );
+         goto p_rpi_main_60;                /* get next node on stage 4 */
+       }
+       dsl_rpi_conf.umc_taif_ineta_ipv4 = *((UNSIG_MED *) dsl_ineta_sret_work_1.chrc_ineta);  /* <TUN-adapter-use-interface-ineta> IPV4 */
+       bol_taif_ineta_ipv4 = TRUE;          /* <TUN-adapter-use-interface-ineta> IPV4 filled */
+       goto p_rpi_main_60;                  /* get next node on stage 4 */
+     }
+     /* IPV6                                                           */
+     if (bol_taif_ineta_ipv6) {             /* <TUN-adapter-use-interface-ineta> IPV6 filled */
+       m_hlnew_printf( HLOG_XYZ1, "HWSPXMLC01nnnW line=%d col=%d Error raw-packet-interface name \"TUN-adapter-use-interface-ineta\" IPV6 value \"%(ux)s\" already defined before -
ignored",
+                       MAC_XML_LINENO( adsl_node_04 ), MAC_XML_COL( adsl_node_04 ),
+                       awcl_05_value );
+       goto p_rpi_main_60;                  /* get next node on stage 4 */
+     }
+     memcpy( dsl_rpi_conf.chrc_taif_ineta_ipv6, dsl_ineta_sret_work_1.chrc_ineta, 16 );  /* <TUN-adapter-use-interface-ineta> IPV6 */
+     bol_taif_ineta_ipv6 = TRUE;            /* <TUN-adapter-use-interface-ineta> IPV6 filled */
+     goto p_rpi_main_60;                    /* get next node on stage 4 */
+   }
+   /* iml_e_04 == DEF_XML_RPI_TA_INETA -       TUN-adapter-ineta       */
+   iml1 = 4;                                /* length of INETA         */
+   al_work1 = &dsl_rpi_conf.imc_no_ta_ineta_ipv4;  /* <TUN-adapter-ineta> IPV4 */
+   if (dsl_ineta_sret_work_1.usc_family != AF_INET) {  /* family IPV6  */
+     iml1 = 16;
+     al_work1 = &dsl_rpi_conf.imc_no_ta_ineta_ipv6;  /* <TUN-adapter-ineta> IPV6 */
+   }
+   while (iml1 == 0) {                      /* family IPV4             */
+     if ((dsl_ineta_sret_work_1.chrc_ineta[3] & 0X03) == 0X01) break;
+     if ((dsl_ineta_sret_work_1.chrc_ineta[3] & 0X03) == 0X02) break;
+     m_hlnew_printf( HLOG_XYZ1, "HWSPXMLC01nnnW line=%d col=%d Error raw-packet-interface name \"TUN-adapter-ineta\" value \"%(ux)s\" = %d.%d.%d.%d INETA not valid for TUN-adapter -
ignored",
+                     MAC_XML_LINENO( adsl_node_04 ), MAC_XML_COL( adsl_node_04 ),
+                     awcl_05_value,
+                     (unsigned char) dsl_ineta_sret_work_1.chrc_ineta[0],
+                     (unsigned char) dsl_ineta_sret_work_1.chrc_ineta[1],
+                     (unsigned char) dsl_ineta_sret_work_1.chrc_ineta[2],
+                     (unsigned char) dsl_ineta_sret_work_1.chrc_ineta[3] );
+     goto p_rpi_main_60;                    /* get next node on stage 4 */
+   }
+   iml2 = 0;                                /* index in temporary storage INETAs */
+   while (iml2 < iml_len_temp_ineta) {      /* length array temporary INETAs filled */
+     iml3 = (unsigned char) byrl_temp_ineta[ iml2 ];
+     if (iml3 == iml1) {                    /* same family             */
+       if (!memcmp( &byrl_temp_ineta[ iml2 + 1 ], dsl_ineta_sret_work_1.chrc_ineta, iml1 )) {
+         m_hlnew_printf( HLOG_XYZ1, "HWSPXMLC01nnnW line=%d col=%d Error raw-packet-interface name \"TUN-adapter-ineta\" value \"%(ux)s\" already defined before - ignored",
+                         MAC_XML_LINENO( adsl_node_04 ), MAC_XML_COL( adsl_node_04 ),
+                         awcl_05_value );
+         goto p_rpi_main_60;                /* get next node on stage 4 */
+       }
+       if (   (iml3 == 4)                   /* IPV4                    */
+           && (!memcmp( &byrl_temp_ineta[ iml2 + 1 ], dsl_ineta_sret_work_1.chrc_ineta, 4 - 1 ))
+           && ((byrl_temp_ineta[ iml2 + 1 + 4 - 1] & 0XFC) == dsl_ineta_sret_work_1.chrc_ineta[ 4 - 1 ] & 0XFC)) {
+         m_hlnew_printf( HLOG_XYZ1, "HWSPXMLC01nnnW line=%d col=%d Error raw-packet-interface name \"TUN-adapter-ineta\" value \"%(ux)s\" INETA same network (mask 255.255.255.252)
defined before - ignored",
+                         MAC_XML_LINENO( adsl_node_04 ), MAC_XML_COL( adsl_node_04 ),
+                         awcl_05_value );
+         goto p_rpi_main_60;                /* get next node on stage 4 */
+       }
+     }
+     iml2 += 1 + iml3;                      /* end of this entry       */
+   }
+#ifndef HL_UNIX
+   if (*((int *) al_work1) != 0) {          /* number of INETAS configured */
+     m_hlnew_printf( HLOG_XYZ1, "HWSPXMLC01nnnW line=%d col=%d Error raw-packet-interface name \"TUN-adapter-ineta\" value \"%(ux)s\" defined multiple times - not valid in Windows
environment - ignored",
+                     MAC_XML_LINENO( adsl_node_04 ), MAC_XML_COL( adsl_node_04 ),
+                     awcl_05_value );
+     goto p_rpi_main_60;                    /* get next node on stage 4 */
+   }
+#endif
+   if ((iml_len_temp_ineta + 1 + iml1) > sizeof(byrl_temp_ineta)) {
+     m_hlnew_printf( HLOG_XYZ1, "HWSPXMLC01nnnW line=%d col=%d Error raw-packet-interface name \"TUN-adapter-ineta\" value \"%(ux)s\" internal error, array for INETAs too small -
ignored",
+                     MAC_XML_LINENO( adsl_node_04 ), MAC_XML_COL( adsl_node_04 ),
+                     awcl_05_value );
+     goto p_rpi_main_60;                    /* get next node on stage 4 */
+   }
+   byrl_temp_ineta[ iml_len_temp_ineta ] = (unsigned char) iml1;  /* set length entry */
+   memcpy( &byrl_temp_ineta[ 1 + iml_len_temp_ineta ], dsl_ineta_sret_work_1.chrc_ineta, iml1 );
+   iml_len_temp_ineta += 1 + iml1;
+   (*((int *) al_work1))++;                 /* increment number of INETAS configured */
+   goto p_rpi_main_60;                      /* get next node on stage 4 */

    p_rpi_num_00:                            /* numeric value           */
    if (borl_rpi_main[ iml_e_04 ]) {         /* defined double          */
@@ -19492,6 +19958,37 @@
    borl_rpi_main[ DEF_XML_RPI_PPP_SERVER ] = TRUE;  /* for check defined double */
    goto p_rpi_main_60;                      /* get next node on stage 4 */

+   p_rpi_strat_driver:                      /* strategy-inst-win-driver */
+#ifndef HL_UNIX
+   if (dsl_rpi_conf.iec_siwd != ied_siwd_invalid) {  /* invalid value  */
+     m_hlnew_printf( HLOG_XYZ1, "HWSPXMLC01nnnW line=%d col=%d Error raw-packet-interface name \"strategy-inst-win-driver\" defined double - ignored",
+                     MAC_XML_LINENO( adsl_node_04 ), MAC_XML_COL( adsl_node_04 ),
+                     awcl_05_value );
+     goto p_rpi_main_60;                    /* get next node on stage 4 */
+   }
+   iml_e_05 = sizeof(dsrs_strat_driver) / sizeof(dsrs_strat_driver[0]);
+   while (TRUE) {                           /* loop over possible values */
+     if (iml_e_05 == 0) {                   /* value not found in table */
+       m_hlnew_printf( HLOG_XYZ1, "HWSPXMLC0UUUUW Error element raw-packet-interface name \"strategy-inst-win-driver\" value \"%(ux)s\" not defined - ignored",
+                       awcl_05_value );
+       goto p_rpi_main_60;                  /* get next node on stage 4 */
+     }
+     iml_e_05--;                            /* decrement index         */
+     bol1 = m_cmp_u16z_u8z( &iml_cmp, awcl_05_value, (char *) dsrs_strat_driver[ iml_e_05 ].achc_keyword );
+     if ((bol1) && (iml_cmp == 0)) {        /* strings are equal       */
+       break;
+     }
+   }
+   dsl_rpi_conf.iec_siwd = dsrs_strat_driver[ iml_e_05 ].iec_siwd;
+   goto p_rpi_main_60;                      /* get next node on stage 4 */
+#endif
+#ifdef HL_UNIX
+   m_hlnew_printf( HLOG_XYZ1, "HWSPXMLC01nnnW line=%d col=%d Error raw-packet-interface name \"strategy-inst-win-driver\" not supported in Unix environment - ignored",
+                   MAC_XML_LINENO( adsl_node_04 ), MAC_XML_COL( adsl_node_04 ),
+                   awcl_05_value );
+   goto p_rpi_main_60;                      /* get next node on stage 4 */
+#endif
+
    p_rpi_ineta_00:                          /* multiple INETAs         */
    iml1 = 0;                                /* clear flags             */

@@ -19897,6 +20394,7 @@

    /* check if configuration valid                                     */
    bol1 = FALSE;                            /* no error yet            */
+#ifdef B130108
    if (borl_rpi_main[ DEF_XML_RPI_TA_INETA ] == FALSE) {  /* check TUN-adapter-ineta */
      m_hlnew_printf( HLOG_XYZ1, "HWSPXMLC0UUUUW Error element raw-packet-interface TUN-adapter-ineta not configured - cannot use TUN-adapter" );
      bol1 = TRUE;                           /* error found             */
@@ -19905,7 +20403,32 @@
      m_hlnew_printf( HLOG_XYZ1, "HWSPXMLC0UUUUW Error element raw-packet-interface TUN-adapter-use-interface-ineta not configured - cannot use TUN-adapter" );
      bol1 = TRUE;                           /* error found             */
    }
-   if (bol1) {                              /* error found             */
+#endif
+   if (bol_taif_ineta_ipv4) {               /* <TUN-adapter-use-interface-ineta> IPV4 filled */
+     if (dsl_rpi_conf.imc_no_ta_ineta_ipv4 == 0) {  /* <TUN-adapter-ineta> IPV4 */
+       m_hlnew_printf( HLOG_XYZ1, "HWSPXMLC0UUUUW Error element raw-packet-interface IPV4 TUN-adapter-use-interface-ineta configured but no TUN-adapter-ineta configured - cannot use
TUN-adapter with IPV4" );
+       bol_taif_ineta_ipv4 = FALSE;         /* <TUN-adapter-use-interface-ineta> IPV4 filled */
+     }
+   } else {
+     if (dsl_rpi_conf.imc_no_ta_ineta_ipv4 > 0) {  /* <TUN-adapter-ineta> IPV4 */
+       m_hlnew_printf( HLOG_XYZ1, "HWSPXMLC0UUUUW Error element raw-packet-interface IPV4 TUN-adapter-ineta configured but no TUN-adapter-use-interface-ineta configured - cannot use
TUN-adapter with IPV4" );
+       dsl_rpi_conf.imc_no_ta_ineta_ipv4 = 0;  /* <TUN-adapter-ineta> IPV4 */
+     }
+   }
+   if (bol_taif_ineta_ipv6) {               /* <TUN-adapter-use-interface-ineta> IPV6 filled */
+     if (dsl_rpi_conf.imc_no_ta_ineta_ipv6 == 0) {  /* <TUN-adapter-ineta> IPV6 */
+       m_hlnew_printf( HLOG_XYZ1, "HWSPXMLC0UUUUW Error element raw-packet-interface IPV6 TUN-adapter-use-interface-ineta configured but no TUN-adapter-ineta configured - cannot use
TUN-adapter with IPV6" );
+       bol_taif_ineta_ipv6 = FALSE;         /* <TUN-adapter-use-interface-ineta> IPV6 filled */
+     }
+   } else {
+     if (dsl_rpi_conf.imc_no_ta_ineta_ipv6 > 0) {  /* <TUN-adapter-ineta> IPV6 */
+       m_hlnew_printf( HLOG_XYZ1, "HWSPXMLC0UUUUW Error element raw-packet-interface IPV6 TUN-adapter-ineta configured but no TUN-adapter-use-interface-ineta configured - cannot use
TUN-adapter with IPV6" );
+       dsl_rpi_conf.imc_no_ta_ineta_ipv6 = 0;  /* <TUN-adapter-ineta> IPV6 */
+     }
+   }
+   if (   (bol_taif_ineta_ipv4 == FALSE)    /* <TUN-adapter-use-interface-ineta> IPV4 filled */
+       && (bol_taif_ineta_ipv6 == FALSE)) {  /* <TUN-adapter-use-interface-ineta> IPV6 filled */
+     m_hlnew_printf( HLOG_XYZ1, "HWSPXMLC0UUUUW Error element raw-packet-interface TUN-adapter neither IPV4 nor IPV6 configured - cannot use TUN-adapter, ignored" );
      /* free all resources                                             */
      while (adsl_ineta_temp_1_ch) {         /* free temporary INETAs   */
        adsl_ineta_temp_1_w1 = adsl_ineta_temp_1_ch;  /* get start of chain */
@@ -20105,6 +20628,12 @@
      }
      adsl_port_temp_1_w1 = adsl_port_temp_1_w1->adsc_next;  /* get next in chain */
    }
+   iml1
+     += (dsl_rpi_conf.imc_no_ta_ineta_ipv4 * 4  /* <TUN-adapter-ineta> IPV4 */
+          + dsl_rpi_conf.imc_no_ta_ineta_ipv6 * 16  /* <TUN-adapter-ineta> IPV6 */
+          + sizeof(void *) - 1)
+        & (0 - sizeof(void *));
+
 #define ADSL_RPI_CONF_G adsp_cs->adsc_loconf_1_fill->adsc_raw_packet_if_conf
    ADSL_RPI_CONF_G = (struct dsd_raw_packet_if_conf *) malloc( iml1 );
    memcpy( ADSL_RPI_CONF_G, &dsl_rpi_conf, sizeof(struct dsd_raw_packet_if_conf) );
@@ -20283,6 +20812,31 @@
        adsl_port_temp_1_w2->boc_invalid = TRUE;  /* entry is invalid now */
      }
    }
+   /* first INETAs IPV6 because of alignment                           */
+   if (dsl_rpi_conf.imc_no_ta_ineta_ipv6 > 0) {  /* <TUN-adapter-ineta> IPV6 */
+     ADSL_RPI_CONF_G->achc_ar_ta_ineta_ipv6 = achl1;  /* array <TUN-adapter-ineta> IPV6 */
+     iml1 = 0;                              /* clear index             */
+     while (iml1 < iml_len_temp_ineta) {    /* length array temporary INETAs filled */
+       iml2 = (unsigned char) byrl_temp_ineta[ iml1 ];
+       if (iml2 == 16) {                    /* same family IPV6        */
+         memcpy( achl1, &byrl_temp_ineta[ iml1 + 1 ], 16 );
+         achl1 += 16;
+       }
+       iml1 += 1 + iml2;                    /* end of this entry       */
+     }
+   }
+   if (dsl_rpi_conf.imc_no_ta_ineta_ipv4 > 0) {  /* <TUN-adapter-ineta> IPV4 */
+     ADSL_RPI_CONF_G->achc_ar_ta_ineta_ipv4 = achl1;  /* array <TUN-adapter-ineta> IPV4 */
+     iml1 = 0;                              /* clear index             */
+     while (iml1 < iml_len_temp_ineta) {    /* length array temporary INETAs filled */
+       iml2 = (unsigned char) byrl_temp_ineta[ iml1 ];
+       if (iml2 == 4) {                     /* same family IPV4        */
+         memcpy( achl1, &byrl_temp_ineta[ iml1 + 1 ], 4 );
+         achl1 += 4;
+       }
+       iml1 += 1 + iml2;                    /* end of this entry       */
+     }
+   }
 // p_rpi_main_96:                           /* end of ports            */
    while (adsl_ineta_temp_1_ch) {           /* free temporary INETAs   */
      adsl_ineta_temp_1_w1 = adsl_ineta_temp_1_ch;  /* get start of chain */
Index: xshsstp01.cpp
===================================================================
--- xshsstp01.cpp	(revision 2)
+++ xshsstp01.cpp	(revision 6)
@@ -1,3 +1,7 @@
+#ifndef D_INCL_TUN_CTRL
+#define D_INCL_TUN_CTRL
+#endif
+
 #ifdef B090317
 #ifndef HL_UNIX
 #include <hob-avl03.h>
@@ -4,10 +8,10 @@
 #else
 #include "hob-avl03.h"
 #endif
-#if defined WIN32 || WIN64
+#if defined WIN32 || defined WIN64
 #include <winsock2.h>
 #include <windows.h>
-#elif defined HL_LINUX
+#elif defined HL_UNIX
 #include <netinet/in.h>
 #endif
 #ifndef HL_UNIX
@@ -23,6 +27,8 @@
 #include <winsock2.h>
 #include <ws2tcpip.h>
 #include <windows.h>
+#else
+#include "hob-unix01.h"
 #endif
 #ifndef HL_UNIX
 #include <hob-avl03.h>
@@ -33,12 +39,20 @@
 typedef int socklen_t;
 #endif
 #ifdef HL_UNIX
+#ifndef HOB_CONTR_TIMER
 #define HOB_CONTR_TIMER
+#endif
+#include <net/if.h>
 #include <netinet/in.h>
 #include <time.h>
 #include <string.h>
-#include "types_defines.h"
+
+//#include "types_defines.h"
+#ifndef byte
+#define byte unsigned char
 #endif
+
+#endif
 #include <hob-xslhcla1.hpp>
 #include <hob-netw-01.h>
 #include <string>
@@ -50,18 +64,18 @@
 #include <time.h>
 #include "hob-xslcontr.h"
 #include "hob-tun01.h"
-#include "hob-htcp-int-types.h"
-#include "hob-htcp.h"
-#include "hob-htcp-bit-reference.h"
-#include "hob-htcp-tcpip-hdr.h"
-#include "hob-htcp-misc.h"
-#include "hob-htcp-connection.h"
+#include "hob-htcp-int-01.h"
+//#include "hob-htcp-int-types.h"
+//#include "hob-htcp.h"
+//#include "hob-htcp-bit-reference.h"
+//#include "hob-htcp-tcpip-hdr.h"
+//#include "hob-htcp-misc.h"
+//#include "hob-htcp-connection.h"
 #include "hob-session01.h"
-#include "hob-htcp-session.h"
+//#include "hob-htcp-session.h"
 #include "hob-gw-ppp-1.h"
 #include "hob-hppp01.h"
 #include "hob-hsstp01.h"
-#include "hob-tun02.h"
 #include "hob-tuntapif01.h"
 #include <stdio.h>
 #include <vector>
@@ -74,6 +88,10 @@
 #include "hob-xbipgw08-1.h"
 #include "hob-xbipgw08-2.h"

+#ifdef HL_UNIX
+#include <semaphore.h>
+#endif
+
 #define HTTP_PROTOVER "HTTP/1.1 "
 #define HTTP_STATCODE "200 \r\n"
 #define HTTP_CONTLEN  "Content-Length: 18446744073709551615\r\n"
@@ -84,19 +102,19 @@

 // Buffer for Protocol Version string.
 static const byte byrl_http_proto_ver[] = HTTP_PROTOVER;
-static const uint32 uml_len_http_proto_ver =
+static const uint32_t uml_len_http_proto_ver =
    sizeof(byrl_http_proto_ver) - 1;
 // Buffer for Status Code string.
 static const byte         byrl_http_stat_code[] = HTTP_STATCODE;
-static const uint32 uml_len_http_stat_code =
+static const uint32_t uml_len_http_stat_code =
    sizeof(byrl_http_stat_code) - 1;
 // Buffer for Content Length string.
 static const byte         byrl_http_cont_len[] = HTTP_CONTLEN;
-static const uint32 uml_len_http_cont_len =
+static const uint32_t uml_len_http_cont_len =
    sizeof(byrl_http_cont_len) - 1;
 // Buffer for Server string.
 static const byte         byrl_http_server[] = HTTP_SERVER;
-static const uint32 uml_len_http_server = sizeof(byrl_http_server) - 1;
+static const uint32_t uml_len_http_server = sizeof(byrl_http_server) - 1;

 // Buffer for OK message string
 static byte byrl_http_OK[uml_len_http_proto_ver
@@ -128,8 +146,13 @@
                                                  "Nov",
                                                  "Dec" };

+#ifndef HL_UNIX
 // Signaled when a session is done with the C++ timer structure.
 static HANDLE dsc_eve_timer = CreateEvent(NULL, TRUE, TRUE, NULL);
+#else
+static sem_t dsc_eve_timer;
+int um_sem_ret = sem_init (&dsc_eve_timer, 0, 1);
+#endif

 static byte byrl_nonce[] =
    { 0xE6, 0xEC, 0x2A, 0x72, 0xB3, 0x31, 0x73, 0xFD,
@@ -152,22 +175,21 @@
 // New function to get address of INETA configured for htun.
 static char * m_ppp_se_get_ineta_client(struct dsd_ppp_server_1 *adsp_ppp_se_1);

-// Gets address of INETA configured for HTUN sessions. Defined in ibipgw08.cpp.
-extern PTYPE char * m_htun_get_client_ineta( struct dsd_tun_contr1 * );
-
 static void m_sstp_make_http_response();

 static void m_cb_timer_close(dsd_timer_ele* adsp_timer_close);

-extern "C" void m_htun_free_resources( struct dsd_tun_contr1 *adsp_tun_contr1 );
-
-dsd_sstp_session::dsd_sstp_session(dsd_tun_start1* adsp_tun_start1,
-                                   dsd_tun_contr1* adsp_sess_info)
-    : dsd_session(adsp_sess_info),
+dsd_sstp_session::dsd_sstp_session(dsd_tun_start_ppp * adsp_tun_start_ppp,
+                                   dsd_tun_contr_conn* adsp_tun_contr_conn,
+                                   dsd_tun_contr_ineta* adsp_tun_contr_ineta)
+    : dsd_session(adsp_tun_contr_conn, adsp_tun_contr_ineta),
       iec_sstp_state(ied_sstp_state_waithttp)
 {
-    umc_client_ineta =
-        ((sockaddr_in*)(&adsp_tun_start1->dsc_soa_local))->sin_addr.s_addr;
+   dsc_sstp_wrap.adsc_sstp_session = this;
+   dsc_htun_handle.vpc_contr = this;
+    /* TODO Not sure if this is right but there is no IP information in the start
+            structure */
+    umc_client_ineta = adsp_tun_start_ppp->umc_s_nw_ineta_ipv4;
 };

 dsd_sstp_session::~dsd_sstp_session()
@@ -175,20 +197,20 @@

 };

-int32 dsd_sstp_session::mc_init()
+int32_t dsd_sstp_session::mc_init()
 {
    // Init dsd_ppp_server_1 instance in order to use new PPP implementation.
-   memset(&dsc_ppp_se_1, 0, sizeof(dsd_ppp_server_1));
-   dsc_ppp_se_1.amc_ppp_se_send = m_ppp_send_callback_se;
-   dsc_ppp_se_1.amc_ppp_se_auth = m_ppp_auth_1;
-   dsc_ppp_se_1.amc_ppp_se_get_ineta_client = m_ppp_se_get_ineta_client;
+   memset(&dsc_sstp_wrap.dsc_ppp_se_1, 0, sizeof(dsd_ppp_server_1));
+   dsc_sstp_wrap.dsc_ppp_se_1.amc_ppp_se_send = m_ppp_send_callback_se;
+   dsc_sstp_wrap.dsc_ppp_se_1.amc_ppp_se_auth = m_ppp_auth_1;
+   dsc_sstp_wrap.dsc_ppp_se_1.amc_ppp_se_get_ineta_client = m_ppp_se_get_ineta_client;

-   dsc_ppp_se_1.chrc_magic_number_se[0] = 0x01;
-   dsc_ppp_se_1.chrc_magic_number_se[1] = 0x02;
-   dsc_ppp_se_1.chrc_magic_number_se[2] = 0x03;
-   dsc_ppp_se_1.chrc_magic_number_se[3] = 0x04;
-   dsc_ppp_se_1.isc_recv_ident_lcp_conf = -1;
-   dsc_ppp_se_1.vpc_handle = adsc_sess_info;
+   dsc_sstp_wrap.dsc_ppp_se_1.chrc_magic_number_se[0] = 0x01;
+   dsc_sstp_wrap.dsc_ppp_se_1.chrc_magic_number_se[1] = 0x02;
+   dsc_sstp_wrap.dsc_ppp_se_1.chrc_magic_number_se[2] = 0x03;
+   dsc_sstp_wrap.dsc_ppp_se_1.chrc_magic_number_se[3] = 0x04;
+   dsc_sstp_wrap.dsc_ppp_se_1.isc_recv_ident_lcp_conf = -1;
+   dsc_sstp_wrap.dsc_ppp_se_1.vpc_handle = &dsc_htun_handle;

    // Rreturn OK.
    return 0;
@@ -198,15 +220,15 @@
 {

     // Create and set timer to release resources (Route, PARP, INETA etc...).
-    memset(&dsc_timer_close, 0, sizeof(dsc_timer_close));
-    dsc_timer_close.amc_compl = m_cb_timer_close;
-    dsc_timer_close.ilcwaitmsec = 1000 * 30; // 30s timeout.
-    m_time_set(&dsc_timer_close, false);
+    memset(&dsc_sstp_wrap.dsc_timer_close, 0, sizeof(dsc_sstp_wrap.dsc_timer_close));
+    dsc_sstp_wrap.dsc_timer_close.amc_compl = m_cb_timer_close;
+    dsc_sstp_wrap.dsc_timer_close.ilcwaitmsec = 1000 * 30; // 30s timeout.
+    m_time_set(&dsc_sstp_wrap.dsc_timer_close, false);

 }

-int32 dsd_sstp_session::mc_interpret_msg(dsd_gather_i_1* adsp_gather,
-                                         dsd_hco_wothr*  adsp_hco_wothr)
+int32_t dsd_sstp_session::mc_interpret_msg(dsd_gather_i_1* adsp_gather,
+                                           dsd_hco_wothr*  adsp_hco_wothr)
 {

    while((adsp_gather->achc_ginp_cur != adsp_gather->achc_ginp_end)
@@ -229,7 +251,7 @@
             // Look for HTTP message.

             // Length of data seen/traversed.
-            uint32 uml_http_len = 0;
+            uint32_t uml_http_len = 0;
             // Traverse chain of buffers, starting from first link.
             dsd_gather_i_1* adsl_link_cur = adsp_gather;

@@ -268,7 +290,7 @@
                adsl_link_cur = adsp_gather;
                // Traverse chain, starting from first link again, and copying
                // contents of buffers as we go.
-               uint32 uml_bytescopied = 0;
+               uint32_t uml_bytescopied = 0;
                while(!(((byte*)(adsl_link_cur->achc_ginp_cur) <
                   abyl_data_end) &&
                   ((byte*)(adsl_link_cur->achc_ginp_end) >=
@@ -301,14 +323,20 @@
                   // Get new buffer.
                   void* al_handle;
                   char* achl_data;
-                  int32 iml_data_len;
+                  int32_t iml_data_len;
                   iml_data_len = m_htun_getrecvbuf(&al_handle, &achl_data);
+                  #ifndef HL_UNIX
                   WaitForSingleObject(dsc_eve_timer, INFINITE);
+                  #else
+                  sem_wait (&dsc_eve_timer);
+                  #endif
                   // Create HTTP OK message.
                   m_sstp_make_http_response();
                   // Write HTTP OK message.
                   memcpy(achl_data, byrl_http_OK, sizeof(byrl_http_OK));
+                  #ifndef HL_UNIX
                   ResetEvent(dsc_eve_timer);
+                  #endif
                   // Init new vec ele.
                   dsd_buf_vector_ele dsl_http_ok;
                   dsl_http_ok.ac_handle = al_handle;
@@ -319,7 +347,7 @@
                   if(boc_cansend)
                   {
                      // Send pkt to client.
-                  if(!(m_se_htun_recvbuf(adsc_sess_info, &dsl_http_ok, 1)))
+                  if(!(m_se_htun_recvbuf(adsc_tun_contr_conn, &dsl_http_ok, 1)))
                      {
                         // Indicate that it is not OK to send more messages
                         // towards client.
@@ -338,7 +366,7 @@
                else
                {
                   // Indicate incorrect HTTP message.
-                  m_htun_warning(adsc_sess_info, BASE_ERR_NUMBER + 0, "SSTP warning: Invalid HTTP message received.");
+                  m_htun_warning(adsc_tun_contr_conn,adsc_tun_contr_ineta, BASE_ERR_NUMBER + 0, "SSTP warning: Invalid HTTP message received.");
                   // TODO: Send HTTP message with error code.
                   return 1;
                }
@@ -356,11 +384,11 @@
          {
             // Try to read Control field of SSTP message.
             dsd_gather_i_1* adsl_link_cur = adsp_gather;
-            uint16 usl_sstp_control;
+            uint16_t usl_sstp_control;
             if(adsl_link_cur->achc_ginp_end - adsl_link_cur->achc_ginp_cur >= 2)
             {
                usl_sstp_control =
-                  *((uint16*)(adsl_link_cur->achc_ginp_cur));
+                  *((uint16_t*)(adsl_link_cur->achc_ginp_cur));
             }
             else
             {
@@ -378,7 +406,7 @@
                // At this point, message seems to be valid SSTP.
                // Now find LengthPacket field, and read rest of packet from
                // chain.
-               int32 iml_lengthpacket = m_get_sstp_lengthpacket(adsl_link_cur);
+               int32_t iml_lengthpacket = m_get_sstp_lengthpacket(adsl_link_cur);
                if(iml_lengthpacket < 0)
                {  // Entire length value not available.
                   return 0;
@@ -408,11 +436,11 @@
                // Now we can process the remaining contents of the message.

                // Make sure that SSTP message has correct size.
-               int32 iml1 = 0; // Use as offset.
+               int32_t iml1 = 0; // Use as offset.
                if(iml_lengthpacket < 8)
                {
                   // Indicate invalid SSTP message.
-                  m_htun_warning(adsc_sess_info, BASE_ERR_NUMBER + 1, "SSTP warning: Invalid length SSTP message received during SSTP connection establishment. Session closed.");
+                  m_htun_warning(adsc_tun_contr_conn,adsc_tun_contr_ineta, BASE_ERR_NUMBER + 1, "SSTP warning: Invalid length SSTP message received during SSTP connection
establishment. Session closed.");
                   delete []abyl_cpy_buf;
                   // Send SSTP Call Abort message.
                   mc_abort_sstp_conn();
@@ -424,7 +452,7 @@

                // Make sure MessageType value is SSTP_MSG_CALL_CONNECT_REQ.
                iml1 += 4;
-               switch(*((uint16*)(abyl_cpy_buf + iml1)))
+               switch(*((uint16_t*)(abyl_cpy_buf + iml1)))
                {
                   case SSTP_MSG_CALL_ABORT:
                   {
@@ -441,7 +469,7 @@
                      // Get new buffer.
                      void* al_handle;
                      char* achl_data;
-                     int32 iml_data_len;
+                     int32_t iml_data_len;
                      iml_data_len = m_htun_getrecvbuf(&al_handle, &achl_data);
                      // Init new vec ele.
                      dsd_buf_vector_ele dsl_sstp_call_disconn_ack;
@@ -456,7 +484,7 @@
                      if(boc_cansend)
                      {
                         // Send pkt to client.
-                     if(!(m_se_htun_recvbuf(adsc_sess_info,
+                     if(!(m_se_htun_recvbuf(adsc_tun_contr_conn,
                                                &dsl_sstp_call_disconn_ack, 1)))
                         {
                            // Indicate that it is not OK to send more messages
@@ -481,11 +509,11 @@
                      // Make sure NumAttributes value is 0x0001 (only 1
                      // attribute).
                      iml1 += 2;
-                     if(*((uint16*)(abyl_cpy_buf + iml1)) !=
+                     if(*((uint16_t*)(abyl_cpy_buf + iml1)) !=
                         htons(0x0001))
                      {
                         // Indicate invalid SSTP message.
-                        m_htun_warning(adsc_sess_info, BASE_ERR_NUMBER + 2, "SSTP warning: Unexpected SSTP NumAttributes received during SSTP connection establishment. Session
closed.");
+                        m_htun_warning(adsc_tun_contr_conn,adsc_tun_contr_ineta, BASE_ERR_NUMBER + 2, "SSTP warning: Unexpected SSTP NumAttributes received during SSTP connection
establishment. Session closed.");
                         delete []abyl_cpy_buf;
                         // Send SSTP Call Abort message.
                         mc_abort_sstp_conn();
@@ -501,7 +529,7 @@
                         SSTP_ATTR_ENCAPSULATED_PROTO)
                      {
                         // Indicate invalid SSTP message.
-                        m_htun_warning(adsc_sess_info, BASE_ERR_NUMBER + 3, "SSTP warning: Unexpected SSTP AttributeID received during SSTP connection establishment. Session
closed.");
+                        m_htun_warning(adsc_tun_contr_conn,adsc_tun_contr_ineta, BASE_ERR_NUMBER + 3, "SSTP warning: Unexpected SSTP AttributeID received during SSTP connection
establishment. Session closed.");
                         delete []abyl_cpy_buf;
                         // Send SSTP Call Abort message.
                         mc_abort_sstp_conn();
@@ -513,11 +541,11 @@
                      // Make sure ProtocolID value is
                      // SSTP_ATTR_ENCAPSULATED_PROTO_PPP.
                      iml1 += 3;
-                     if(*((uint16*)(abyl_cpy_buf + iml1)) !=
+                     if(*((uint16_t*)(abyl_cpy_buf + iml1)) !=
                         SSTP_ATTR_ENCAPSULATED_PROTO_PPP)
                      {
                         // Indicate invalid SSTP message.
-                        m_htun_warning(adsc_sess_info, BASE_ERR_NUMBER + 4, "SSTP warning: Unexpected SSTP ProtocolID received during SSTP connection establishment. Session
closed");
+                        m_htun_warning(adsc_tun_contr_conn,adsc_tun_contr_ineta, BASE_ERR_NUMBER + 4, "SSTP warning: Unexpected SSTP ProtocolID received during SSTP connection
establishment. Session closed");
                         delete []abyl_cpy_buf;
                         // Send SSTP Call Abort message.
                         mc_abort_sstp_conn();
@@ -536,24 +564,24 @@
                      // Get new buffer.
                      void* al_handle;
                      char* achl_data;
-                     int32 iml_data_len;
+                     int32_t iml_data_len;
                      iml_data_len = m_htun_getrecvbuf(&al_handle, &achl_data);
                      // Write SSTP CALL_CONNECT_ACK message.
                      // Version and control fields.
-                     *((uint16*)(achl_data + 0)) = SSTP_CONTROL_MSG;
+                     *((uint16_t*)(achl_data + 0)) = SSTP_CONTROL_MSG;
                      // LengthPacket field.
-                     *((uint16*)(achl_data + 2)) = htons(0x0030);
+                     *((uint16_t*)(achl_data + 2)) = htons(0x0030);
                      // MessageType field.
-                     *((uint16*)(achl_data + 4)) =
+                     *((uint16_t*)(achl_data + 4)) =
                         SSTP_MSG_CALL_CONNECT_ACK;
                      // NumAttributes field.
-                     *((uint16*)(achl_data + 6)) = htons(0x0001);
+                     *((uint16_t*)(achl_data + 6)) = htons(0x0001);
                      // Reserved1 field.
                      *((byte*)(achl_data + 8)) = 0x00;
                      // AttributeID field.
                      *((byte*)(achl_data + 9)) = SSTP_ATTR_CRYPTO_REQ;
                      // LengthAttribute field.
-                     *((uint16*)(achl_data + 10)) = htons(0x0028);
+                     *((uint16_t*)(achl_data + 10)) = htons(0x0028);
                      // Reserved2 field.
                      memset(achl_data + 12, 0, 3);
                      // HashProtocol field.
@@ -572,7 +600,7 @@
                      if(boc_cansend)
                      {
                         // Send pkt to client.
-                     if(!(m_se_htun_recvbuf(adsc_sess_info,
+                     if(!(m_se_htun_recvbuf(adsc_tun_contr_conn,
                                                &dsl_sstp_call_conn_ack, 1)))
                         {
                            // Indicate that it is not OK to send more messages
@@ -593,7 +621,7 @@
                   default:
                   {
                      // Indicate invalid SSTP message.
-                     m_htun_warning(adsc_sess_info, BASE_ERR_NUMBER + 5, "SSTP warning: Unexpected SSTP MessageType received during SSTP connection establishment. Session closed.");
+                     m_htun_warning(adsc_tun_contr_conn,adsc_tun_contr_ineta, BASE_ERR_NUMBER + 5, "SSTP warning: Unexpected SSTP MessageType received during SSTP connection
establishment. Session closed.");
                      delete []abyl_cpy_buf;
                      // Send SSTP Call Abort message.
                      mc_abort_sstp_conn();
@@ -607,7 +635,7 @@
             else // Not an SSTP message.
             {
                // Indicate invalid SSTP message.
-               m_htun_warning(adsc_sess_info, BASE_ERR_NUMBER + 6, "SSTP warning: Invalid SSTP message received during SSTP connection establishment. Session closed.");
+               m_htun_warning(adsc_tun_contr_conn,adsc_tun_contr_ineta, BASE_ERR_NUMBER + 6, "SSTP warning: Invalid SSTP message received during SSTP connection establishment.
Session closed.");
                // Send SSTP Call Abort message.
                mc_abort_sstp_conn();
                // Close SSTP connection.
@@ -621,11 +649,11 @@
          {
             // Try to read Control field of SSTP message.
             dsd_gather_i_1* adsl_link_cur = adsp_gather;
-            uint16 usl_sstp_control;
+            uint16_t usl_sstp_control;
             if(adsl_link_cur->achc_ginp_end - adsl_link_cur->achc_ginp_cur >= 2)
             {
                usl_sstp_control =
-                  *((uint16*)(adsl_link_cur->achc_ginp_cur));
+                  *((uint16_t*)(adsl_link_cur->achc_ginp_cur));
             }
             else
             {
@@ -643,7 +671,7 @@
             {
                // At this point, message seems to be valid SSTP.
                // Now find LengthPacket field and read rest of pkt from chain.
-               int32 iml_lengthpacket = m_get_sstp_lengthpacket(adsl_link_cur);
+               int32_t iml_lengthpacket = m_get_sstp_lengthpacket(adsl_link_cur);
                if(iml_lengthpacket < 0)
                { // Entire length value not available.
                   return 0;
@@ -676,11 +704,11 @@
                   // Now we can process the remaining contents of the message.

                   // Make sure that SSTP message has correct size.
-                  int32 iml1 = 0; // Use as offset.
+                  int32_t iml1 = 0; // Use as offset.
                   if(iml_lengthpacket < 8)
                   {
                      // Indicate invalid SSTP message
-                     m_htun_warning(adsc_sess_info, BASE_ERR_NUMBER + 7, "SSTP warning: Invalid length SSTP message received during SSTP connection establishment. Session closed.");
+                     m_htun_warning(adsc_tun_contr_conn,adsc_tun_contr_ineta, BASE_ERR_NUMBER + 7, "SSTP warning: Invalid length SSTP message received during SSTP connection
establishment. Session closed.");
                      delete []abyl_cpy_buf;
                      // Send SSTP Call Abort message.
                      mc_abort_sstp_conn();
@@ -691,14 +719,14 @@
                   }
                   // Make sure MessageType value is SSTP_MSG_CALL_CONNECTED.
                   iml1 += 4;
-                  if(*((uint16*)(abyl_cpy_buf + iml1)) !=
+                  if(*((uint16_t*)(abyl_cpy_buf + iml1)) !=
                      SSTP_MSG_CALL_CONNECTED)
                   {
                      // Check if MessageType is SSTP_MSG_CALL_ABORT.
-                     if(*((uint16*)(abyl_cpy_buf + iml1)) ==
+                     if(*((uint16_t*)(abyl_cpy_buf + iml1)) ==
                         SSTP_MSG_CALL_ABORT)
                      {
-                        m_htun_warning(adsc_sess_info, BASE_ERR_NUMBER + 8, "SSTP warning: SSTP connection establishment aborted by peer. Session closed");
+                        m_htun_warning(adsc_tun_contr_conn,adsc_tun_contr_ineta, BASE_ERR_NUMBER + 8, "SSTP warning: SSTP connection establishment aborted by peer. Session closed");
                         // Close SSTP connection.
                         boc_sess_closed = true;

@@ -706,7 +734,7 @@
                         return 1;
                      }
                      // Check if MessageType is SSTP_MSG_CALL_DISCONNECT.
-                     else if (*((uint16*)(abyl_cpy_buf + iml1)) ==
+                     else if (*((uint16_t*)(abyl_cpy_buf + iml1)) ==
                         SSTP_MSG_CALL_DISCONNECT)
                      {
                         // Create and send SSTP_MSG_CALL_DISCONNECT_ACK SSTP
@@ -714,7 +742,7 @@
                         // Get new buffer.
                         void* al_handle;
                         char* achl_data;
-                        int32 iml_data_len;
+                        int32_t iml_data_len;
                         iml_data_len = m_htun_getrecvbuf(&al_handle, &achl_data);
                         // Init new vec ele.
                         dsd_buf_vector_ele dsl_sstp_call_disconn_ack;
@@ -729,7 +757,7 @@
                         if(boc_cansend)
                         {
                            // Send pkt to client.
-                        if(!(m_se_htun_recvbuf(adsc_sess_info,
+                        if(!(m_se_htun_recvbuf(adsc_tun_contr_conn,
                                                &dsl_sstp_call_disconn_ack,
                                                1)))
                            {
@@ -753,7 +781,7 @@
                      else
                      {
                         // Indicate invalid SSTP message.
-                        m_htun_warning(adsc_sess_info, BASE_ERR_NUMBER + 9, "SSTP warning: Unexpected SSTP MessageType received during SSTP connection establishment. Session
closed.");
+                        m_htun_warning(adsc_tun_contr_conn,adsc_tun_contr_ineta, BASE_ERR_NUMBER + 9, "SSTP warning: Unexpected SSTP MessageType received during SSTP connection
establishment. Session closed.");
                         delete []abyl_cpy_buf;
                         // Send SSTP Call Abort message.
                         mc_abort_sstp_conn();
@@ -765,10 +793,10 @@
                   }
                   // Make sure NumAttributes value is 0x0001 (only 1 attribute).
                   iml1 += 2;
-                  if(*((uint16*)(abyl_cpy_buf + iml1)) != htons(0x0001))
+                  if(*((uint16_t*)(abyl_cpy_buf + iml1)) != htons(0x0001))
                   {
                      // Indicate invalid SSTP message.
-                     m_htun_warning(adsc_sess_info, BASE_ERR_NUMBER + 10, "SSTP warning: Unexpected SSTP NumAttributes received during SSTP connection establishment. Session
closed.");
+                     m_htun_warning(adsc_tun_contr_conn,adsc_tun_contr_ineta, BASE_ERR_NUMBER + 10, "SSTP warning: Unexpected SSTP NumAttributes received during SSTP connection
establishment. Session closed.");
                      delete []abyl_cpy_buf;
                      // Send SSTP Call Abort message.
                      mc_abort_sstp_conn();
@@ -783,7 +811,7 @@
                      SSTP_ATTR_CRYPTO)
                   {
                      // Indicate invalid SSTP message.
-                     m_htun_warning(adsc_sess_info, BASE_ERR_NUMBER + 11, "SSTP warning: Unexpected SSTP AttributeID received during SSTP connection establishment. Session
closed.");
+                     m_htun_warning(adsc_tun_contr_conn,adsc_tun_contr_ineta, BASE_ERR_NUMBER + 11, "SSTP warning: Unexpected SSTP AttributeID received during SSTP connection
establishment. Session closed.");
                      delete []abyl_cpy_buf;
                      // Send SSTP Call Abort message.
                      mc_abort_sstp_conn();
@@ -800,7 +828,7 @@
                      HASH_PROTO_SHA256))
                   {
                      // Indicate invalid SSTP message.
-                     m_htun_warning(adsc_sess_info, BASE_ERR_NUMBER + 12, "SSTP warning: Unexpected HashProtocol received during SSTP connection establishment. Session closed.");
+                     m_htun_warning(adsc_tun_contr_conn,adsc_tun_contr_ineta, BASE_ERR_NUMBER + 12, "SSTP warning: Unexpected HashProtocol received during SSTP connection
establishment. Session closed.");
                      delete []abyl_cpy_buf;
                      // Send SSTP Call Abort message.
                      mc_abort_sstp_conn();
@@ -816,7 +844,7 @@
                             sizeof(byrl_nonce)) != 0)
                   {
                      // Indicate invalid SSTP message.
-                     m_htun_warning(adsc_sess_info, BASE_ERR_NUMBER + 13, "SSTP warning: Unexpected SSTP Nonce received during SSTP connection establishment. Session closed.");
+                     m_htun_warning(adsc_tun_contr_conn,adsc_tun_contr_ineta, BASE_ERR_NUMBER + 13, "SSTP warning: Unexpected SSTP Nonce received during SSTP connection
establishment. Session closed.");
                      delete []abyl_cpy_buf;
                      // Send SSTP Call Abort message.
                      mc_abort_sstp_conn();
@@ -842,7 +870,7 @@
                   // Now we can process the remaining contents of the message.

                   // Send Data field to PPP implementation for processing.
-                  m_recv_ppp_server_cs(&dsc_ppp_se_1,
+                  m_recv_ppp_server_cs(&dsc_sstp_wrap.dsc_ppp_se_1,
                                        (char*)(abyl_cpy_buf + 4),
                                        iml_lengthpacket - 4);

@@ -852,10 +880,10 @@
                   // this approach is replaced by a callback which is called
                   // from the new PPP server as soon as a Configure Ack LCP msg
                   // is sent to the PPP client.
-                  static int32 i = 1;
+                  static int32_t i = 1;
                   if(i==2)
                   {
-                     m_start_ppp_server_cs(&dsc_ppp_se_1); 
+                     m_start_ppp_server_cs(&dsc_sstp_wrap.dsc_ppp_se_1); 
                   }
                   i++;

@@ -866,7 +894,7 @@
             else // Not an SSTP message.
             {
                // Indicate invalid SSTP message.
-               m_htun_warning(adsc_sess_info, BASE_ERR_NUMBER + 14, "SSTP warning: Invalid SSTP message received during SSTP connection establishment. Session closed.");
+               m_htun_warning(adsc_tun_contr_conn,adsc_tun_contr_ineta, BASE_ERR_NUMBER + 14, "SSTP warning: Invalid SSTP message received during SSTP connection establishment.
Session closed.");
                // Send SSTP Call Abort message.
                mc_abort_sstp_conn();
                // Close SSTP connection.
@@ -879,11 +907,11 @@
          {
             // Try to read Control field of SSTP message.
             dsd_gather_i_1* adsl_link_cur = adsp_gather;
-            uint16 usl_sstp_control;
+            uint16_t usl_sstp_control;
             if(adsl_link_cur->achc_ginp_end - adsl_link_cur->achc_ginp_cur >= 2)
             {
                usl_sstp_control =
-                  *((uint16*)(adsl_link_cur->achc_ginp_cur));
+                  *((uint16_t*)(adsl_link_cur->achc_ginp_cur));
             }
             else
             {
@@ -903,7 +931,7 @@
                // At this point, message seems to be valid SSTP.
                // Now find LengthPacket field, and read rest of pkt from chain.

-               int32 iml_lengthpacket = 0;
+               int32_t iml_lengthpacket = 0;
                iml_lengthpacket = m_get_sstp_lengthpacket(adsl_link_cur);
                if(iml_lengthpacket < 0)
                {  // Entire length value not available.
@@ -945,7 +973,7 @@
                   else
                   {
                      // Send Data field to PPP implementation for processing.
-                     m_recv_ppp_server_cs(&dsc_ppp_se_1,
+                     m_recv_ppp_server_cs(&dsc_sstp_wrap.dsc_ppp_se_1,
                                           (char*)(abyl_cpy_buf + 4),
                                           iml_lengthpacket - 4);
                   }
@@ -961,7 +989,7 @@
                   if(iml_lengthpacket < 8)
                   {
                      // Indicate invalid SSTP message.
-                     m_htun_warning(adsc_sess_info, BASE_ERR_NUMBER + 15, "SSTP warning: Invalid length SSTP message received. Session closed.");
+                     m_htun_warning(adsc_tun_contr_conn,adsc_tun_contr_ineta, BASE_ERR_NUMBER + 15, "SSTP warning: Invalid length SSTP message received. Session closed.");
                      delete []abyl_cpy_buf;
                      // Send SSTP Call Abort message.
                      mc_abort_sstp_conn();
@@ -972,8 +1000,8 @@
                   }

                   // Read the MessageType field of the SSTP Control message.
-                  uint16 usl_sstp_messtyp =
-                     *((uint16*)(abyl_cpy_buf + 4));
+                  uint16_t usl_sstp_messtyp =
+                     *((uint16_t*)(abyl_cpy_buf + 4));

                   switch(usl_sstp_messtyp)
                   {
@@ -983,17 +1011,17 @@
                         // Get new buffer.
                         void* al_handle;
                         char* achl_data;
-                        int32 iml_data_len;
+                        int32_t iml_data_len;
                         iml_data_len = m_htun_getrecvbuf(&al_handle, &achl_data);
                         // Write SSTP SSTP_MSG_ECHO_ACK message.
                         // Version and control fields.
-                        *((uint16*)(achl_data + 0)) = SSTP_CONTROL_MSG;
+                        *((uint16_t*)(achl_data + 0)) = SSTP_CONTROL_MSG;
                         // LengthPacket field.
-                        *((uint16*)(achl_data + 2)) = htons(0x0008);
+                        *((uint16_t*)(achl_data + 2)) = htons(0x0008);
                         // MessageType field.
-                        *((uint16*)(achl_data + 4)) = SSTP_MSG_ECHO_ACK;
+                        *((uint16_t*)(achl_data + 4)) = SSTP_MSG_ECHO_ACK;
                         // NumAttributes field.
-                        *((uint16*)(achl_data + 6)) = htons(0x0000);
+                        *((uint16_t*)(achl_data + 6)) = htons(0x0000);

                         // Init new vec ele.
                         dsd_buf_vector_ele dsl_sstp_echo_ack;
@@ -1006,7 +1034,7 @@
                         if(boc_cansend)
                         {
                            // Send pkt to client.
-                        if(!(m_se_htun_recvbuf(adsc_sess_info,
+                        if(!(m_se_htun_recvbuf(adsc_tun_contr_conn,
                                                   &dsl_sstp_echo_ack, 1)))
                            {
                               // Indicate that it is not OK to send more
@@ -1028,7 +1056,7 @@
                         // Get new buffer.
                         void* al_handle;
                         char* achl_data;
-                        int32 iml_data_len;
+                        int32_t iml_data_len;
                         iml_data_len = m_htun_getrecvbuf(&al_handle, &achl_data);
                         // Init new vec ele.
                         dsd_buf_vector_ele dsl_sstp_call_disconn_ack;
@@ -1046,7 +1074,7 @@
                         if(boc_cansend)
                         {
                            // Send pkt to client.
-                        if(!(m_se_htun_recvbuf(adsc_sess_info,
+                        if(!(m_se_htun_recvbuf(adsc_tun_contr_conn,
                                                &dsl_sstp_call_disconn_ack,
                                                1)))
                            {
@@ -1078,7 +1106,7 @@
                      default:
                      {
                         // Indicate invalid SSTP message.
-                        m_htun_warning(adsc_sess_info, BASE_ERR_NUMBER + 16, "SSTP warning: Unexpected SSTP MessageType received. Session closed.");
+                        m_htun_warning(adsc_tun_contr_conn,adsc_tun_contr_ineta, BASE_ERR_NUMBER + 16, "SSTP warning: Unexpected SSTP MessageType received. Session closed.");
                         delete []abyl_cpy_buf;
                         // Send SSTP Call Abort message.
                         mc_abort_sstp_conn();
@@ -1093,7 +1121,7 @@
             else // Not an SSTP message.
             {
                // Indicate invalid SSTP message.
-               m_htun_warning(adsc_sess_info, BASE_ERR_NUMBER + 17, "SSTP warning: Invalid SSTP message received. Session closed.");
+               m_htun_warning(adsc_tun_contr_conn,adsc_tun_contr_ineta, BASE_ERR_NUMBER + 17, "SSTP warning: Invalid SSTP message received. Session closed.");
                // Send SSTP Call Abort message.
                mc_abort_sstp_conn();
                // Close SSTP connection.
@@ -1108,30 +1136,30 @@
    return 0;
 }

-int32 dsd_sstp_session::mc_tunnel_to_cl(void* ap_handle,
-                                      byte* abyp_data,
-                                      uint32 ump_length)
+int32_t dsd_sstp_session::mc_tunnel_to_cl(void* ap_handle,
+                                          byte* abyp_data,
+                                          uint32_t ump_length)
 {
    // Create buf vec ele.
    dsd_buf_vector_ele dsl_buf_vec;
    dsl_buf_vec.ac_handle = ap_handle;
    dsl_buf_vec.achc_data = (char*)abyp_data;
-   dsl_buf_vec.imc_len_data = (int32)ump_length;
+   dsl_buf_vec.imc_len_data = (int32_t)ump_length;

    mc_sstp_tunnel_data(&dsl_buf_vec);

    return 0;
 }

-int32 dsd_sstp_session::mc_encapsulate_msg(void* ap_handle,
-                                         byte* abyp_data,
-                                         uint32 ump_length)
+int32_t dsd_sstp_session::mc_encapsulate_msg(void* ap_handle,
+                                             byte* abyp_data,
+                                             uint32_t ump_length)
 {
    // Create buf vec ele.
    dsd_buf_vector_ele dsl_buf_vec;
    dsl_buf_vec.ac_handle = ap_handle;
    dsl_buf_vec.achc_data = (char*)abyp_data;
-   dsl_buf_vec.imc_len_data = (int32)ump_length;
+   dsl_buf_vec.imc_len_data = (int32_t)ump_length;

    dsl_buf_vec.achc_data -= 1;
    *dsl_buf_vec.achc_data = 0x21;
@@ -1155,7 +1183,7 @@
         dsc_sendto_extnw_msgq.pop();

         // Send message.
-        if(!(m_se_htun_recvbuf(adsc_sess_info, &dsl_buf_vec, 1)))
+        if(!(m_se_htun_recvbuf(adsc_tun_contr_conn, &dsl_buf_vec, 1)))
         {
             // Indicate that it is not OK to send more messages towards client.
             boc_cansend = false;
@@ -1165,23 +1193,23 @@
         if(!dsl_q_msg.bo_nodrop)
         {
             // Decrement number of queued messages.
-            adsc_sess_info->imc_on_the_fly_packets_client--;
+            adsc_tun_contr_conn->imc_on_the_fly_packets_client--;
         }
     }

     // Write LengthPacket field.
     adsp_vector->achc_data -= 2;
-    *(uint16*)(adsp_vector->achc_data) = htons(adsp_vector->imc_len_data + 4);
+    *(uint16_t*)(adsp_vector->achc_data) = htons(adsp_vector->imc_len_data + 4);
     // Write Version and Control fields.
     adsp_vector->achc_data -= 2;
-    *(uint16*)(adsp_vector->achc_data) = SSTP_DATA_MSG;
+    *(uint16_t*)(adsp_vector->achc_data) = SSTP_DATA_MSG;

     // If it is still OK to continue sending messages to client OR no drop flag
     // is set...
-    if(boc_cansend || adsc_sess_info->boc_not_drop_tcp_packet)
+    if(boc_cansend || adsc_tun_contr_conn->boc_not_drop_tcp_packet)
     {
         // Send message to client.
-        if(!(m_se_htun_recvbuf(adsc_sess_info, adsp_vector, 1)))
+        if(!(m_se_htun_recvbuf(adsc_tun_contr_conn, adsp_vector, 1)))
         {
             // Indicate that it is not OK to send more messages towards client.
             boc_cansend = false;
@@ -1190,18 +1218,18 @@
     else
     {
         // If number of queued messages is still below limit...
-        if(adsc_sess_info->imc_on_the_fly_packets_client < MAX_PPP_ON_THE_FLY_PACKETS_CLIENT)
+        if(adsc_tun_contr_conn->imc_on_the_fly_packets_client < MAX_PPP_ON_THE_FLY_PACKETS_CLIENT)
         {
             // Place message in queue.
             dsd_queued_msg dsl_q_msg;
             dsl_q_msg.ds_buf_vec_ele = *adsp_vector;
-            dsl_q_msg.bo_nodrop = adsc_sess_info->boc_not_drop_tcp_packet;
+            dsl_q_msg.bo_nodrop = adsc_tun_contr_conn->boc_not_drop_tcp_packet;
             dsc_sendto_extnw_msgq.push(dsl_q_msg);
             // If no drop flag is not set...
-            if(!adsc_sess_info->boc_not_drop_tcp_packet)
+            if(!adsc_tun_contr_conn->boc_not_drop_tcp_packet)
             {
                 // Increment number of queued messages.
-                adsc_sess_info->imc_on_the_fly_packets_client++;
+                adsc_tun_contr_conn->imc_on_the_fly_packets_client++;
             }
         }
         else // Queue length limit reached...
@@ -1219,41 +1247,41 @@
 {
    adsp_buf_vec->imc_len_data += 8;
    // NumAttributes field.
-   adsp_buf_vec->achc_data -= sizeof(uint16);
-   *((uint16*)(adsp_buf_vec->achc_data)) = htons(0x0000);
+   adsp_buf_vec->achc_data -= sizeof(uint16_t);
+   *((uint16_t*)(adsp_buf_vec->achc_data)) = htons(0x0000);
    // MessageType field.
-   adsp_buf_vec->achc_data -= sizeof(uint16);
-   *((uint16*)(adsp_buf_vec->achc_data)) = SSTP_MSG_CALL_DISCONNECT_ACK;
+   adsp_buf_vec->achc_data -= sizeof(uint16_t);
+   *((uint16_t*)(adsp_buf_vec->achc_data)) = SSTP_MSG_CALL_DISCONNECT_ACK;
    // LengthPacket field.
-   adsp_buf_vec->achc_data -= sizeof(uint16);
-   *((uint16*)(adsp_buf_vec->achc_data)) = htons(0x0008);
+   adsp_buf_vec->achc_data -= sizeof(uint16_t);
+   *((uint16_t*)(adsp_buf_vec->achc_data)) = htons(0x0008);
    // Version and control fields.
-   adsp_buf_vec->achc_data -= sizeof(uint16);
-   *((uint16*)(adsp_buf_vec->achc_data)) = SSTP_CONTROL_MSG;
+   adsp_buf_vec->achc_data -= sizeof(uint16_t);
+   *((uint16_t*)(adsp_buf_vec->achc_data)) = SSTP_CONTROL_MSG;
 }
 void dsd_sstp_session::mc_make_sstp_call_abort(dsd_buf_vector_ele* adsp_buf_vec)
 {
    // Update length value for vec ele.
    adsp_buf_vec->imc_len_data += 8;
    // Write NumAttributes field.
-   adsp_buf_vec->achc_data -= sizeof(uint16);
-   *((uint16*)(adsp_buf_vec->achc_data)) = 0x0000;
+   adsp_buf_vec->achc_data -= sizeof(uint16_t);
+   *((uint16_t*)(adsp_buf_vec->achc_data)) = 0x0000;
    // Write MessageType field.
-   adsp_buf_vec->achc_data -= sizeof(uint16);
-   *((uint16*)(adsp_buf_vec->achc_data)) = SSTP_MSG_CALL_ABORT;
+   adsp_buf_vec->achc_data -= sizeof(uint16_t);
+   *((uint16_t*)(adsp_buf_vec->achc_data)) = SSTP_MSG_CALL_ABORT;
    // Write LengthPacket field.
-   adsp_buf_vec->achc_data -= sizeof(uint16);
-   *((uint16*)(adsp_buf_vec->achc_data)) = 0x0008;
+   adsp_buf_vec->achc_data -= sizeof(uint16_t);
+   *((uint16_t*)(adsp_buf_vec->achc_data)) = 0x0008;
    // Write Version & Control fields.
-   adsp_buf_vec->achc_data -= sizeof(uint16);
-   *((uint16*)(adsp_buf_vec->achc_data)) = SSTP_CONTROL_MSG;
+   adsp_buf_vec->achc_data -= sizeof(uint16_t);
+   *((uint16_t*)(adsp_buf_vec->achc_data)) = SSTP_CONTROL_MSG;
 }
 void dsd_sstp_session::mc_abort_sstp_conn()
 {
    // Get new recv buffer.
    void* al_handle;
    char* achl_data;
-   int32 iml_data_len;
+   int32_t iml_data_len;
    iml_data_len = m_htun_getrecvbuf(&al_handle, &achl_data);
    // Create & init new vec ele struct.
    dsd_buf_vector_ele dsl_sstp_call_abort;
@@ -1267,7 +1295,7 @@
    if(boc_cansend)
    {
       // Send pkt to client.
-   if(!(m_se_htun_recvbuf(adsc_sess_info, &dsl_sstp_call_abort, 1)))
+   if(!(m_se_htun_recvbuf(adsc_tun_contr_conn, &dsl_sstp_call_abort, 1)))
       {
          // Indicate that it is not OK to send more messages towards client.
          boc_cansend = false;
@@ -1284,10 +1312,12 @@
 static void m_ppp_send_callback_se(dsd_ppp_server_1* adsp_ppp_server,
                                    dsd_buf_vector_ele* adsp_buf_vec)
 {
-
-   dsd_sstp_session* adsl_sess =
-      (dsd_sstp_session*)((char*)adsp_ppp_server -
-      offsetof(dsd_sstp_session, dsc_ppp_se_1));
+    /* TODO Usage of the offsetof macro on non-pod structures
+            could be dangaerous*/
+   // dsd_sstp_session* adsl_sess =
+   //    (dsd_sstp_session*)((char*)adsp_ppp_server -
+   //    offsetof(dsd_sstp_session, dsc_ppp_se_1));
+   dsd_sstp_session* adsl_sess = m_sstp_session_from_s1(adsp_ppp_server);
    adsl_sess->mc_tunnel_to_cl(adsp_buf_vec->ac_handle,
                               (byte*)adsp_buf_vec->achc_data,
                               adsp_buf_vec->imc_len_data);
@@ -1298,9 +1328,7 @@
 // New routine implemented in order to get address of INETA configured for htun.
 static char* m_ppp_se_get_ineta_client(struct dsd_ppp_server_1 *adsp_ppp_se_1)
 {
-   uint32* auml_client_ineta =
-       &DEF_SSTP_SESSION((dsd_tun_contr1*)adsp_ppp_se_1->vpc_handle)->
-       umc_client_ineta;
+   uint32_t* auml_client_ineta = &((dsd_sstp_session*)(((dsd_htun_handle*)(adsp_ppp_se_1->vpc_handle))->vpc_contr))->umc_client_ineta;

    if(*auml_client_ineta > 0)
    {
@@ -1333,10 +1361,10 @@
    time_t dsl_rawtime = time(NULL);
    tm* adsl_gmtime = gmtime(&dsl_rawtime);

-   const uint32 uml_offset_date =
+   const uint32_t uml_offset_date =
       uml_len_http_proto_ver + uml_len_http_stat_code + uml_len_http_cont_len +
       uml_len_http_server;
-   uint32 uml_tmp_offset = uml_offset_date;
+   uint32_t uml_tmp_offset = uml_offset_date;
    memcpy(byrl_http_OK + uml_tmp_offset, "Date: ", 6);
    uml_tmp_offset += 6;
    memcpy(byrl_http_OK + uml_tmp_offset,
@@ -1432,19 +1460,18 @@

 static void m_cb_timer_close(dsd_timer_ele* adsp_timer_close)
 {
-
+    /*TODO Usage of offsetof on non-pod structures could be dangerous */
     // Obtain ptr to sstp session.
-    int iml_offset = offsetof(dsd_sstp_session, dsc_timer_close);
-    dsd_sstp_session* adsl_sstp_sess =
-        (dsd_sstp_session*)((char*)adsp_timer_close - iml_offset);
+    // int iml_offset = offsetof(dsd_sstp_session, dsc_timer_close);
+    // dsd_sstp_session* adsl_sstp_sess =
+    //     (dsd_sstp_session*)((char*)adsp_timer_close - iml_offset);
+   dsd_sstp_session* adsl_sstp_sess = m_sstp_session_from_te(adsp_timer_close);

-    dsd_tun_contr1* adsl_tc = adsl_sstp_sess->adsc_sess_info;
-
     // Call class dtor.
     adsl_sstp_sess->~dsd_sstp_session();

     // Free session resources.
-    m_htun_free_resources(adsl_tc);
+    m_htun_ppp_free_resources(adsl_sstp_sess->adsc_tun_contr_ineta);

     return;
-}
\ No newline at end of file
+}
Index: hob-xbipgw08-2.h
===================================================================
--- hob-xbipgw08-2.h	(revision 2)
+++ hob-xbipgw08-2.h	(revision 6)
@@ -21,6 +21,7 @@
 /*|  Copyright (C) HOB Germany 2010                                   |*/
 /*|  Copyright (C) HOB Germany 2011                                   |*/
 /*|  Copyright (C) HOB Germany 2012                                   |*/
+/*|  Copyright (C) HOB Germany 2013                                   |*/
 /*|                                                                   |*/
 /*| REQUIRED PROGRAMS:                                                |*/
 /*| ------------------                                                |*/
@@ -122,6 +123,8 @@
 #define RANDOM_INETA_CLUSTER_WAIT 20        /* maximum random times cluster timeout value */
 #define DEF_INETA_CLUSTER_WAIT 500          /* default cluster timeout value in milliseconds */
 #define TIMER_FREE_MEMORY      (30 * 1000)  /* timer to wait some time before freeing memory */
+#define SHIFT_BLOCK_SWAP       16           /* shift bits length block of swap area */
+#define LEN_BLOCK_SWAP         (1 << SHIFT_BLOCK_SWAP)  /* length block of swap area */
 #define CHAR_CR                0X0D         /* carriage-return         */
 #define CHAR_LF                0X0A         /* line-feed               */
 #define HLOG_XYZ1              0            /* to be replaced later    */
@@ -296,7 +299,10 @@
    ied_auxf_admin,                          /* admin command           */
    ied_auxf_ident,                          /* ident - userid and user-group */
    ied_auxf_pipe_listen,                    /* aux-pipe create with name */
-   ied_auxf_pipe_conn                       /* aux-pipe established connection */
+   ied_auxf_pipe_conn,                      /* aux-pipe established connection */
+   ied_auxf_util_thread,                    /* utility thread          */
+   ied_auxf_swap_stor,                      /* swap storage            */
+   ied_auxf_dyn_lib                         /* dynamic library         */
 };

 enum ied_src_func  {                        /* for auxiliary timer     */
@@ -489,11 +495,14 @@
    struct dsd_sdh_obj_1 *adsc_sdh_obj_1;    /* chain server-data-hook-object */
    struct dsd_bgt_contr_1 *adsc_bgt_contr_1;  /* chain background-task control */
    struct dsd_l2tp_conf *adsc_l2tp_conf;    /* chain L2TP gateways     */
+   struct dsd_sig_cred_1 *adsc_sig_cred_1;  /* signature credentials   */
+   struct dsd_filename_1 *adsc_swap_fn_chain;  /* chain of filenames for swap file */
 #ifndef HL_UNIX
    WCHAR      *awcc_rev_server;             /* for RegisterEventSourceW */
    WCHAR      *awcc_rev_source;             /* for RegisterEventSourceW */
    WCHAR      *awcc_windows_pipe_name;      /* <Windows-named-pipe>    */
 #else
+   BOOL       boc_prot_include_pid;         /* <prot-include-pid>      */
    char       *achc_pid_file;               /* name PID-file           */
 #ifdef XYZ1
    ied_lierr  iec_lierr;                    /* state LISTEN-ERROR      */
@@ -504,13 +513,17 @@
    char       *achc_ligw_shared_secret;     /* shared secret of Listen Gateway */
    char       *achc_unix_domain_socket;     /* <Unix-Domain-Socket>    */
 #endif
+   int        imc_tod_mark_log;             /* <time-of-day-mark-log> seconds from midnight, +1 */
    int        inc_max_poss_workthr;         /* max possible work thr   */
    int        inc_max_act_workthr;          /* max active work thr     */
    int        inc_prio_work_thread;         /* priority work thread    */
+   int        imc_max_util_thread;          /* <max-util-thread>       */
    int        inc_report_intv;              /* interval in seconds     */
    int        inc_network_stat;             /* give network statistic  */
    int        inc_time_reload_disk_file;    /* time in seconds         */
    int        inc_time_cache_disk_file;     /* time in seconds         */
+   int        imc_swap_mem_size;            /* <size-swap-in-memory> in 64 KB units */
+   int        imc_max_swap_size;            /* <max-swap-size> in 64 KB units */
    int        imc_tcp_sndbuf;               /* set TCP SNDBUF          */
    int        imc_tcp_rcvbuf;               /* set TCP RCVBUF          */
    BOOL       boc_tcp_keepalive;            /* set TCP KEEPALIVE       */
@@ -640,6 +653,22 @@
    ied_rcf_ok                               /* packet is o.k.          */
 };

+struct dsd_sig_cred_1 {                     /* signature credentials   */
+   int        imc_len_modulus_bin;
+   int        imc_len_modulus_base64;
+   int        imc_len_private_key_bin;
+   int        imc_len_public_key_base64;
+   char       *achc_modulus_bin;
+   char       *achc_modulus_base64;
+   char       *achc_private_key_bin;
+   char       *achc_public_key_base64;
+};
+
+struct dsd_filename_1 {                     /* for filenames           */
+   struct dsd_filename_1 *adsc_next;        /* for chaining            */
+   struct dsd_unicode_string dsc_ucs_file_name;  /* file name          */
+};
+
 #ifndef INCL_GW_EXTERN
 #ifndef HL_KRB5
 struct dsd_ext_lib1 {                       /* external loaded library */
@@ -2475,7 +2504,9 @@
 #define DEF_STATE_HTUN_ERR_SESS_END  8      /* done HTUN HTCP session end was with error */
 #define DEF_STATE_HTUN_FREE_R_1      16     /* done HTUN free resources */
 #define DEF_STATE_HTUN_FREE_R_2      32     /* done HTUN free resources */
+#ifdef B130116
 #define DEF_STATE_HTUN_INETA_TARGET  64     /* need to free target INETA */
+#endif
 #define DEF_STATE_HTUN_NO_FREE_INETA 128    /* do not free local INETA */

 enum ied_ineta_raws_def {                   /* type of INETA raw socket */
@@ -2606,6 +2637,15 @@
    struct dsd_appl_port_conf *adsc_appl_port_conf;  /* configured ports for appl */
    UNSIG_MED  umc_ta_ineta;                 /* <TUN-adapter-ineta>     */
    UNSIG_MED  umc_taif_ineta;               /* <TUN-adapter-use-interface-ineta> */
+/* see B100802 - now in hob-tun01.h                                    */
+/* new 06.01.13 KB - start                                             */
+   int        imc_no_ta_ineta_ipv4;         /* <TUN-adapter-ineta ???>     */
+   int        imc_no_ta_ineta_ipv6;         /* <TUN-adapter-ineta ???>     */
+   char       *achc_ar_ta_ineta_ipv4;       /* <TUN-adapter-ineta ???>     */
+   char       *achc_ar_ta_ineta_ipv6;         /* <TUN-adapter-ineta ???>     */
+   UNSIG_MED  umc_taif_ineta_ipv4;          /* <TUN-adapter-use-interface-ineta> IPV4 */
+   char       chrc_taif_ineta_ipv6[ 16 ];   /* <TUN-adapter-use-interface-ineta> IPV6 */
+/* new 06.01.13 KB - end                                               */
    int        imc_tcpc_to_msec;             /* <TCP-connect-timeout-millisec> */
    int        imc_tcpc_try_no;              /* <TCP-connect-number-of-try> */
    int        imc_no_ele_appl_port_conf;    /* number of elements configured ports for appl */
@@ -2809,7 +2849,7 @@
                                    struct dsd_loconf_1 *, amd_startprog );
 #endif
 extern PTYPE void m_cluster_start( struct dsd_cluster_main * );
-extern PTYPE BOOL m_status_cluster_lbal( void );
+extern PTYPE BOOL m_status_cluster_lbal( BOOL );
 extern PTYPE BOOL m_create_log( HL_LONGLONG );
 extern PTYPE BOOL m_write_log( int, char *, int );
 #ifdef INCL_GW_ALL
@@ -2910,11 +2950,13 @@
 #endif
 #endif
 #ifdef TRY_D_INCL_HTUN
-extern PTYPE BOOL m_tcp_conn( void *, struct dsd_aux_tcp_conn_1 *, struct dsd_target_ineta_1 *, BOOL );
+extern PTYPE BOOL m_tcp_dynamic_conn( void *, struct dsd_aux_tcp_conn_1 *, struct dsd_target_ineta_1 *, void *, BOOL );
+extern PTYPE int m_tcp_static_conn( void *, BOOL );
 extern PTYPE BOOL m_tcp_close( void * );
 #endif
 #ifdef HL_UNIX
-extern PTYPE BOOL m_tcp_conn( void *, struct dsd_aux_tcp_conn_1 *, struct dsd_target_ineta_1 *, BOOL );
+extern PTYPE BOOL m_tcp_dynamic_conn( void *, struct dsd_aux_tcp_conn_1 *, struct dsd_target_ineta_1 *, void *, BOOL );
+extern PTYPE int m_tcp_static_conn( void *, BOOL );
 extern PTYPE BOOL m_tcp_close( void * );
 #endif
 #ifdef B110904
Index: SOFTWARE.HLSEC.CLUSTER1.act.txt
===================================================================
--- SOFTWARE.HLSEC.CLUSTER1.act.txt	(revision 2)
+++ SOFTWARE.HLSEC.CLUSTER1.act.txt	(revision 6)
@@ -12,7 +12,7 @@
          TUN/TAP and for CMA.
          Cluster is configured in <cluster>, giving Name, INETA and Port.
          In Unix, to reload the configuration, multiple WSPs may run.
-         In this szenario, the Listen-Gateway nbipgw12 is needed to
+         In this szenario, the Listen-Gateway nbipgw19 is needed to
          coordinate the access.
          When a Listen-Gateway is used, the WSP sends INETA multihomed
          and port over the Pipe. Then the WSP queries which WSPs are
@@ -24,6 +24,16 @@
          answers "reconnect" and gives all Ports. For the Ports, the
          number NHASN and the Ports are sent.

+         In Unix, when the Listen-Gateway is used, the WSPs can connect
+         to each other also when no cluster is configured. This
+         connection is useful when a new WSP is started because the
+         configuration has changed. The old WSP is still running, and
+         over the cluster connection the new WSP can get the content of
+         the CMA of the old WSP.
+         In this szenario, the WSPs are not connected over TCP, instead
+         Unix sockets are used which contain the PID (Process identifier)
+         in their name.
+
          Messages between WSPs connected thru a cluster are sent as
          length in NHASN, the tag and the information.
          As the first part of each message, there is a 16-Byte eyecatcher
@@ -51,22 +61,20 @@
          1 = PID, process-Id of WSP on this server, 4 bytes big endian
          2 = Epoch started, in milliseconds, 8 bytes big endian
          3 = Fingerprint
-         4 = Endian-ness
+         4 = Endian-ness+
+
+
+
+
+
          5 = Alignment
          6 = Query Main
          7 = Name in Configuration, UTF-8
          8 = Configuration Group
          9 = Configuration Location
          10 = Configuration URL
-         --- ??? ---
-         0X10 = redirect
-         0X20 = end WSP-

-
-
-
-
          The CMA part of the WSP has implemented the following methods:
          void m_cma1_cluster_open( struct dsd_cluster_active * );
          void m_cma1_cluster_close( struct dsd_cluster_active * );
@@ -78,8 +86,8 @@
          void * vpc_cma_entry;  /* field for CMA entry */
          The CMA part can do with this field whatever it wants to.

-         Each of these methods are called on threads, where no lengly
-         processing is possible. If lengly processing is necessary, a
+         Each of these methods are called on threads, where no lenghly
+         processing is possible. If lenghly processing is necessary, a
          work thread has to be scheduled.

          When data are received for CMA, the method m_cma1_cluster_recv()
@@ -112,8 +120,27 @@
          members. It is needed, that the CMA part keeps track how many
          data have been scheduled for sending and that the CMA part stops
          sending more data when there is a certain amount of data in the
-         queue to be sent.
+         queue to be sent.+

+
+
+
+
+         In Unix environment, when the Listen-Gateway is used, another
+         cluster member may connect over TCP to the Listen-Gateway since
+         this opened the TCP port configured at the other cluster member.
+         Then the Listen-Gateway sends the Redirect message which is
+         built as follows:
+         - Eyecatcher
+         - Length NHASN
+         - Ascii '2', command reconnect
+         - Entries for original listen (maybe multiple entries)
+           - Length NHASN of following entry
+           - 2 bytes big endian original TCP port
+           - 2 bytes big endian TCP port to connect to WSP
+           - 4 bytes or 16 bytes INETA, either IPV4 or IPV6
+
          01.04.07  KB
          12.08.07  KB
          13.08.07  KB
@@ -123,5 +150,6 @@
          31.10.07  KB
          11.02.09  KB
          08.05.10  KB
-         07.02.12  KB+         07.02.12  KB
+         13.11.12  KB
\ No newline at end of file
Index: hob-ldap01.hpp
===================================================================
--- hob-ldap01.hpp	(revision 2)
+++ hob-ldap01.hpp	(revision 6)
@@ -25,7 +25,7 @@
 extern "C" void  *m_aux_stor_realloc( void **, void *, int );
 extern "C" void   m_aux_stor_end( void ** );

-extern "C" int    m_hl_inet_ntop( struct sockaddr_storage *, char * /**< ipaddr */, int /**< length */ );
+extern "C" int    m_hl_inet_ntop( struct sockaddr_storage *, char *, int );


 /// macro definitions
@@ -39,8 +39,7 @@
 #define GET_MEM_CHAR(a,b,c)  \
                         b = (char *)(b ? m_aux_stor_realloc(&a,b,c) : m_aux_stor_alloc(&a,c));

-
-#define LDAP_VERSION   3
+#define LDAP_VERSION  3
 #define LDAP_PORT	   389		/**< default LDAP port          */
 #define LDAPS_PORT	   636		/**< default LDAP over TLS port */

@@ -56,92 +55,9 @@
 #endif


-/**
- * Overview of LBER tag construction
- *
- *	Bits
- *	______
- *	8 7 | CLASS
- *	0 0 = UNIVERSAL
- *	0 1 = APPLICATION
- *	1 0 = CONTEXT-SPECIFIC
- *	1 1 = PRIVATE
- *		_____
- *		| 6 | DATA-TYPE
- *		  0 = PRIMITIVE
- *		  1 = CONSTRUCTED
- *			___________
- *			| 5 ... 1 | TAG-NUMBER
- */
-
-/* general stuff */
-#define LDAP_TAG_MESSAGE	((unsigned int) 0x30U)	/**< constructed + 16 */
-#define LDAP_TAG_MSGID		((unsigned int) 0x02U)	/**< integer */
-
-#define LDAP_TAG_LDAPDN		((unsigned int) 0x04U)	/**< octet string */
-#define LDAP_TAG_LDAPCRED	((unsigned int) 0x04U)	/**< octet string */
-
-#define LDAP_TAG_CONTROLS	((unsigned int) 0xa0U)	/**< context specific + constructed + 0 */
-#define LDAP_TAG_REFERRAL	((unsigned int) 0xa3U)	/**< context specific + constructed + 3 */
-
-#define LDAP_TAG_NEWSUPERIOR	((unsigned int) 0x80U)	/**< context-specific + primitive + 0 */
-
-#define LDAP_TAG_EXOP_REQ_OID   ((unsigned int) 0x80U)	/**< context specific + primitive */
-#define LDAP_TAG_EXOP_REQ_VALUE ((unsigned int) 0x81U)	/**< context specific + primitive */
-#define LDAP_TAG_EXOP_MOD_USER 	((unsigned int) 0x80U)
-#define LDAP_TAG_EXOP_MOD_PWD_O	((unsigned int) 0x81U)
-#define LDAP_TAG_EXOP_MOD_PWD_N	((unsigned int) 0x82U)
-#define LDAP_TAG_EXOP_RES_OID   ((unsigned int) 0x8aU)	/**< context specific + primitive */
-#define LDAP_TAG_EXOP_RES_VALUE ((unsigned int) 0x8bU)	/**< context specific + primitive */
-
-/** LDAP Request Messages */
-#define LDAP_REQ_BIND		((unsigned int) 0x60U)	/**< application + constructed */
-#define LDAP_REQ_UNBIND		((unsigned int) 0x42U)	/**< application + primitive   */
-#define LDAP_REQ_SEARCH		((unsigned int) 0x63U)	/**< application + constructed */
-#define LDAP_REQ_MODIFY		((unsigned int) 0x66U)	/**< application + constructed */
-#define LDAP_REQ_ADD		((unsigned int) 0x68U)	/**< application + constructed */
-#define LDAP_REQ_DELETE		((unsigned int) 0x4aU)	/**< application + primitive   */
-#define LDAP_REQ_MODDN		((unsigned int) 0x6cU)	/**< application + constructed */
-#define LDAP_REQ_MODRDN		LDAP_REQ_MODDN
-#define LDAP_REQ_RENAME		LDAP_REQ_MODDN
-#define LDAP_REQ_COMPARE	((unsigned int) 0x6eU)	/**< application + constructed */
-#define LDAP_REQ_ABANDON	((unsigned int) 0x50U)	/**< application + primitive   */
-#define LDAP_REQ_EXTENDED	((unsigned int) 0x77U)	/**< application + constructed */
-
-/** LDAP Response Messages */
-#define LDAP_RESP_BIND		    ((unsigned int) 0x61U)	/**< application + constructed */
-#define LDAP_RESP_SEARCH_ENTRY	((unsigned int) 0x64U)	/**< application + constructed */
-#define LDAP_RESP_SEARCH_REF	((unsigned int) 0x73U)	/**< application + constructed */
-#define LDAP_RESP_SEARCH_DONE  	((unsigned int) 0x65U)	/**< application + constructed */
-#define LDAP_RESP_MODIFY		((unsigned int) 0x67U)	/**< application + constructed */
-#define LDAP_RESP_ADD		    ((unsigned int) 0x69U)	/**< application + constructed */
-#define LDAP_RESP_DELETE		((unsigned int) 0x6bU)	/**< application + constructed */
-#define LDAP_RESP_MODDN		    ((unsigned int) 0x6dU)	/**< application + constructed */
-#define LDAP_RESP_COMPARE	    ((unsigned int) 0x6fU)	/**< application + constructed */
-#define LDAP_RESP_EXTENDED	    ((unsigned int) 0x78U)	/**< V3: application + constructed */
-#define LDAP_RESP_INTERMEDIATE	((unsigned int) 0x79U)  /**< V3+: application + constructed */
-#define LDAP_RESP_NONE          ((unsigned int) 0xffU)  /**< no response expected      */
-
-/** authentication methods available */
-#define LDAP_AUTH_NONE   ((unsigned int) 0x00U) /**< no authentication */
-#define LDAP_AUTH_SIMPLE ((unsigned int) 0x80U) /**< context specific + primitive */
-#define LDAP_AUTH_SASL   ((unsigned int) 0xa3U) /**< context specific + constructed */
-
-/** substring filter component types */
-#define LDAP_SUBSTRING_INITIAL	((unsigned int) 0x80U)	/**< context specific */
-#define LDAP_SUBSTRING_ANY		((unsigned int) 0x81U)	/**< context specific */
-#define LDAP_SUBSTRING_FINAL	((unsigned int) 0x82U)	/**< context specific */
-
-/** OID supported for extended operations */
-#define OID_CANCEL_EX    "1.3.6.1.1.8"
-#define OID_STARTTLS_EX  "1.3.6.1.4.1.1466.20037"
-#define OID_PW_MODIFY_EX "1.3.6.1.4.1.4203.1.11.1"
-#define OID_WHOAMI       "1.3.6.1.4.1.4203.1.11.3"
-
-
-
 /* ---------------------------------------------------------------------------------- */
 #define LDAPREQ_INIT(a)      (a).imc_msgid    = this->m_get_msgid();    \
+                             (a).ac_req       = "";                     \
                              (a).imc_resp[1]  = LDAP_RESP_EXTENDED;     \
                              (a).imc_resp[2]  =                         \
                              (a).imc_resp[3]  = LDAP_RESP_NONE;         \
@@ -149,35 +65,43 @@
 /* ---------------------------------------------------------------------------------- */
 #define LDAPREQ_ABANDON(a)   LDAPREQ_INIT((a))                          \
                              (a).imc_req     = LDAP_REQ_ABANDON;        \
+                             (a).ac_req      = "Abandon";               \
                              (a).imc_resp[0] = LDAP_RESP_EXTENDED;      \
                              (a).imc_resp[1] = LDAP_RESP_NONE;
 /* ---------------------------------------------------------------------------------- */
 #define LDAPREQ_ADD(a)       LDAPREQ_INIT((a))                          \
                              (a).imc_req     = LDAP_REQ_ADD;            \
+                             (a).ac_req      = "Add";                   \
                              (a).imc_resp[0] = LDAP_RESP_ADD;
 /* ---------------------------------------------------------------------------------- */
 #define LDAPREQ_BIND(a)      LDAPREQ_INIT((a))                          \
                              (a).imc_req     = LDAP_REQ_BIND;           \
+                             (a).ac_req      = "Bind";                  \
                              (a).imc_resp[0] = LDAP_RESP_BIND;
 /* ---------------------------------------------------------------------------------- */
 #define LDAPREQ_COMPARE(a)   LDAPREQ_INIT((a))                          \
                              (a).imc_req     = LDAP_REQ_COMPARE;        \
+                             (a).ac_req      = "Compare";               \
                              (a).imc_resp[0] = LDAP_RESP_COMPARE;
 /* ---------------------------------------------------------------------------------- */
 #define LDAPREQ_DELETE(a)    LDAPREQ_INIT((a))                          \
                              (a).imc_req     = LDAP_REQ_DELETE;         \
+                             (a).ac_req      = "Delete";                \
                              (a).imc_resp[0] = LDAP_RESP_DELETE;
 /* ---------------------------------------------------------------------------------- */
 #define LDAPREQ_MODIFY(a)    LDAPREQ_INIT((a))                          \
                              (a).imc_req     = LDAP_REQ_MODIFY;         \
+                             (a).ac_req      = "Modify";                \
                              (a).imc_resp[0] = LDAP_RESP_MODIFY;
 /* ---------------------------------------------------------------------------------- */
 #define LDAPREQ_MODIFYDN(a)  LDAPREQ_INIT((a))                          \
                              (a).imc_req     = LDAP_REQ_MODDN;          \
+                             (a).ac_req      = "ModifyDN";              \
                              (a).imc_resp[0] = LDAP_RESP_MODDN;
 /* ---------------------------------------------------------------------------------- */
 #define LDAPREQ_SEARCH(a)    LDAPREQ_INIT((a))                          \
                              (a).imc_req     = LDAP_REQ_SEARCH;         \
+                             (a).ac_req      = "Search";                \
                              (a).imc_resp[0] = LDAP_RESP_SEARCH_ENTRY;  \
                              (a).imc_resp[1] = LDAP_RESP_SEARCH_DONE;   \
                              (a).imc_resp[2] = LDAP_RESP_SEARCH_REF;    \
@@ -185,11 +109,13 @@
 /* ---------------------------------------------------------------------------------- */
 #define LDAPREQ_UNBIND(a)    LDAPREQ_INIT((a))                          \
                              (a).imc_req     = LDAP_REQ_UNBIND;         \
+                             (a).ac_req      = "Unbind";                \
                              (a).imc_resp[0] = LDAP_RESP_EXTENDED;      \
                              (a).imc_resp[1] = LDAP_RESP_NONE;
 /* ---------------------------------------------------------------------------------- */
 #define LDAPREQ_PWMOD_EX(a)  LDAPREQ_INIT((a))                          \
                              (a).imc_req     = LDAP_REQ_EXTENDED;       \
+                             (a).ac_req      = "Modify PasswordEx";     \
                              (a).imc_resp[0] = LDAP_RESP_EXTENDED;      \
                              (a).imc_resp[1] = LDAP_RESP_NONE;
 /* ---------------------------------------------------------------------------------- */
@@ -280,7 +206,7 @@
    char     chrc_buf[DEF_LDAP_RBUF_SIZE]; ///< internal buffer

 public:
-   void *m_init( void *avop_hl_stor, int imp_len = 0 )   ///< constructor
+   void *m_init( void *avop_hl_stor /** storage handler */, int imp_len = 0 /** storage length */ )   ///< constructor
    { 
       this->imc_recvlen  = imc_pos = imc_nextpos = 0;
       this->imc_buflen   = imp_len;
@@ -387,7 +313,7 @@

     char  ch_type;           ///< ("I")information, ("W")warning, ("E")error
 	int	  im_result_code;    ///< LDAP result code
-	const char *ach_err_msg;       ///< pointer to the default error string
+	const char *ach_err_msg; ///< pointer to the default error string
 public:
 	int   im_apicode;        ///< return code of other (external) APIs
 	char *ach_matched_dn;    ///< copy of the LDAP DN-directory the error occured
@@ -409,7 +335,8 @@
     *
     * Initializes the error structure.
     *
-    * @param [in]  void *adsp_hl_stor    hob internal storage handler
+    * @param[in]  adsp_hl_stor    hob internal storage handler
+    *
     */
     void m_init( void *adsp_hl_stor )
     {
@@ -434,12 +361,12 @@
     *
     * Formats a printable error message string. A minimum size of MIN_ERRMSG_LEN is required.
     *
-    * @param [in,out] char                    *achp_msg    message string to print in
-    * @param [in]     int                      inp_len     maximum string length
-    * @param [in]     struct sockaddr_storage *adsp_conn   LDAP socket address information
-    * @param [in]     int                      imp_port    LDAp socket port
+    * @param[in,out]  achp_msg    message string to print in
+    * @param[in]      imp_len     maximum string length
+    * @param[in]      adsp_conn   LDAP socket address information
+    * @param[in]      imp_port    LDAP socket port
     *
-    * @return         int   number of bytes printed or 0 if error
+    * @return         number of bytes printed or 0 if error
     */
     size_t m_format_msg( char *achp_msg, int imp_len,
                          struct sockaddr_storage *adsp_conn = NULL, int imp_port = 0 )
@@ -544,7 +471,7 @@
     *
     * Sets the LDAP returned apicode.
     *
-    * @param [in]  int imp_apicode   API error code
+    * @param[in]  imp_apicode   API error code
     */
     void m_set_apicode( int imp_apicode ) 
     {
@@ -577,21 +504,23 @@
     *
     * Registers the last result code and any associated strings, if an error has occured.
     *
-    * Comment:   LDAPResult ::= SEQUENCE { resultCode      ENUMERATED {...}
-    *                                      matchedDN       LDAPDN,
-    *                                      errorMessage    LDAPString,
-    *                                      referral        [3] Referral OPTIONAL
-    *                                    }
+    * @param[in]  imp_result_code     LDAP result code (ENUMERATED {...})
+    * @param[in]  imp_apicode         optional: API code
+    * @param[in]  achp_matched_dn     optional: (R)DN of the error
+    * @param[in]  imp_len_matched_dn  optional: (R)DN length   
+    * @param[in]  achp_ldap_msg       optional: error message (sent by LDAP)
+    * @param[in]  imp_len_ldap_msg    optional: error message length
     *
-    * @param [in]  int   inp_result_code     LDAP result code (ENUMERATED {...})
-    * @param [in]  int   inp_apicode         optional: API error code
-    * @param [in]  char *achp_matched_dn     optional: (R)DN of the error
-    * @param [in]  int   inp_len_matched_dn  optional: (R)DN length   
-    * @param [in]  char *achp_ldap_msg       optional: error message (sent by LDAP)
-    * @param [in]  int   inp_len_ldap_msg    optional: error message length
+    * Remarks: 
+    *     
+    *     LDAPResult ::= SEQUENCE { resultCode      ENUMERATED {...}
+    *                               matchedDN       LDAPDN,
+    *                               errorMessage    LDAPString,
+    *                               referral        [3] Referral OPTIONAL
+    *                             }
     */
     void m_set_error( int   imp_result_code,
-                      int   imp_apicode     = -1,
+                      int   imp_apicode     = ied_ldap_failure,
                       char *achp_matched_dn = NULL, int imp_len_matched_dn = 0,
                       char *achp_ldap_msg   = NULL, int imp_len_ldap_msg   = 0 )
     {
@@ -666,7 +595,7 @@
  */
 class dsd_trace
 {
-#define HL_TRACEMSG_LEN  384
+#define HL_TRACEMSG_LEN    512

 public:
     enum ied_def_trace_level
@@ -676,11 +605,21 @@
       LEVEL_INFO,
       LEVEL_DATA
     };
-     
-protected:
+   
+    enum ied_def_trace_str
+    {
+       S_BIND_AUTH,
+       S_SEARCH_SCOPE
+    };  
+      
+protected:      
+    static const char *achs_t_bind_auth[];     // translation tables
+    static const char *achs_t_sear_scope[];
+
     int   im_trace_level;     ///< trace level (0: nothing to trace)
     void *ads_hl_stor;        ///< internal hob permanent storage handle  
-    char  chr_prefix[9];      ///< trace message prefix (e.g. "LDAP\0")             
+    char  chr_prefix[9];      ///< trace message prefix (e.g. "LDAP\0")   
+    char  chr_buffer[8];             
    
     struct sockaddr_storage  ds_conn;
     char  chr_ineta[64];      ///< "ineta"
@@ -694,10 +633,10 @@
     *
     * Initializes the trace class (constructor).
     *
-    * @param [in]  void        *adsp_hl_stor     hob internal storage handler
-    * @param [in]  const char  *achp_prefix      trace message prefix
-    * @param [in]  int         *imp_prefix_len   trace message prefix length
-    * @param [in]  int          imp_trace_level  trace level (0: none)
+    * @param[in]  adsp_hl_stor     hob internal storage handler
+    * @param[in]  achp_prefix      trace message prefix
+    * @param[in]  imp_prefix_len   trace message prefix length
+    * @param[in]  imp_trace_level  trace level (0: none)
     */
     void m_init( void       *adsp_hl_stor,
                  const char *achp_prefix     = "LDAP",
@@ -747,7 +686,7 @@
     *
     * Sets the trace level.
     *
-    * @param [in]  int  imp_trace_level   trace level (0: none)
+    * @param [in]  imp_trace_level   trace level (0: none)
     */
     void m_set_level( int imp_trace_level = LEVEL_NONE )
     {
@@ -767,20 +706,61 @@

   
    /**
+    * dsd_trace::m_translate()
+    *
+    * Translates a given enum-value into a string.
+    *
+    * @param[in]  iep_value      enum value of the choosen parameter
+    * @param[in]  iep_parameter  parameter to translate
+    *
+    * @return     pointer to string translation
+    */
+    const char* m_translate( int iep_value, int iep_parameter )
+    {
+       static const char *ach_unknown = "unknown";
+      
+       // check parameter (currently we support BIND_AUTH and SEARCH_SCOPE only)
+       switch (iep_parameter)
+       {
+         case S_BIND_AUTH:
+                   if (iep_value > ied_auth_sid)
+                   { // out of range
+                     m_hlsnprintf( this->chr_buffer, sizeof chr_buffer, ied_chs_utf_8, "%d", iep_value );
+                     return this->chr_buffer;
+                   }
+                   else
+                     return this->achs_t_bind_auth[ iep_value ];
+                            
+         case S_SEARCH_SCOPE:
+                   if (iep_value > ied_sear_attronly)
+                   { // out of range
+                     m_hlsnprintf( this->chr_buffer, sizeof chr_buffer, ied_chs_utf_8, "%d", iep_value );
+                     return this->chr_buffer;
+                   }
+                   else
+                     return this->achs_t_sear_scope[ iep_value ];
+
+         default:  return ach_unknown;
+       } // switch()
+
+    } // dsd_trace::m_translate()
+   
+   
+   /**
     * dsd_trace::m_trace()
     *
     * Formats a printable trace message string.
     *
-    * @param [in]  int                      imp_trace_level  trace level expected
-    * @param [in]  int                      imp_msg_num      message number
-    * @param [in]  int                      imp_sess_num     session number
-    * @param [in]  HL_LONGLONG              illp_epoch_ms    epoch time in milliseconds
-    * @param [in]  struct sockaddr_storage *adsp_conn        socket address information 
-    * @param [in]  template <T>            *adsp_entry       configuration entry (e.g. dsd_ldap_entry)
-    * @param [in]  const char              *achp_msg         message
-    * @param [in]  ...                      additional parameters
+    * @param[in]  imp_trace_level  trace level expected
+    * @param[in]  imp_msg_num      message number
+    * @param[in]  imp_sess_num     session number
+    * @param[in]  illp_epoch_ms    epoch time in milliseconds
+    * @param[in]  adsp_conn        socket address information 
+    * @param[in]  adsp_entry       configuration entry (e.g. dsd_ldap_entry)
+    * @param[in]  achp_msg         message
+    * @param[in]  ...              additional parameters
     *
-    * @return         void
+    * @return     void
     */
     template <class T>
     void m_trace( int imp_trace_level, int imp_msg_num, int imp_sess_num,
@@ -846,25 +826,28 @@
     *
     * Formats a printable trace data message string.
     *
-    * @param [in]  int                      imp_trace_level  trace level expected
-    * @param [in]  int                      imp_msg_num      message number
-    * @param [in]  int                      imp_sess_num     session number
-    * @param [in]  HL_LONGLONG              illp_epoch_ms    epoch time in milliseconds
-    * @param [in]  struct sockaddr_storage *adsp_conn        socket address information 
-    * @param [in]  template <T>            *adsp_entry       configuration entry (e.g. dsd_ldap_entry)
-    * @param [in]  const unsigned char     *aucp_data        data buffer address
-    * @param [in]  unsigned int             ump_size         data buffer size  
+    * @param[in]  imp_trace_level   trace level expected
+    * @param[in]  imp_msg_id        message id
+    * @param[in]  imp_sess_id       session id
+    * @param[in]  imp_ldap_msg_id   ldap message id
+    * @param[in]  achp_ldap_req     ldap request name
+    * @param[in]  illp_epoch_ms     epoch time in milliseconds
+    * @param[in]  adsp_conn         socket address information 
+    * @param[in]  adsp_entry        configuration entry (e.g. dsd_ldap_entry)
+    * @param[in]  aucp_data         data buffer address
+    * @param[in]  ump_size          data buffer size  
     *
-    * @return         void
+    * @return     void
     *
     * Remarks:
-    * 0         1  1  1  1  2  2  2  3   3  3  4  4  4  5  5  5   6        6       7 7 7
-    * 0         0  3  6  9  2  5  8  1   5  8  1  4  7  0  3  6   0        9       7 8 9
-    * xxxxxxxx  xx xx xx xx xx xx xx xx  xx xx xx xx xx xx xx xx  ........ ........ \n\0 (length: 80)
+    *
+    *     0         1  1  1  1  2  2  2  3   3  3  4  4  4  5  5  5   6        6       7 7 7
+    *     0         0  3  6  9  2  5  8  1   5  8  1  4  7  0  3  6   0        9       7 8 9
+    *     xxxxxxxx  xx xx xx xx xx xx xx xx  xx xx xx xx xx xx xx xx  ........ ........ \n\0 (length: 80)
     */
     template <class T>
-    void m_trace_data( int imp_trace_level, int imp_msg_num, int imp_sess_num,
-                       HL_LONGLONG illp_epoch_ms, struct sockaddr_storage *adsp_conn,
+    void m_trace_data( int imp_trace_level, int imp_msg_id, int imp_sess_id, int imp_ldap_msg_id,
+                       char *achp_ldap_req, HL_LONGLONG illp_epoch_ms, struct sockaddr_storage *adsp_conn,
                        T *adsp_entry,
                        const unsigned char *aucp_data, unsigned int ump_size )
     {
@@ -904,9 +887,9 @@
         char *achl_1, *achl_line ((char *)m_aux_stor_alloc( &this->ads_hl_stor, HL_TRACEMSG_LEN + ((ump_size / 16) + 1) * 80 ));
        
         int iml_1 (m_hlsnprintf( (void *)achl_line, HL_TRACEMSG_LEN, ied_chs_utf_8,
-                                   (const char *)"%s%04iT  Name=\"%.*(.*)s\" S-id=%i Time=%10u Ineta=%s:%i Response\n",
-                                   this->chr_prefix, imp_msg_num, iml_len_name, ied_chs_utf_8, achl_name,
-                                   imp_sess_num, (unsigned int)illp_epoch_ms, this->chr_ineta, this->im_port ));
+                                 (const char *)"%s%04iT  Name=\"%.*(.*)s\" S-id=%i Time=%10u Ineta=%s:%i Response(%i) %s\r\n",
+                                 this->chr_prefix, imp_msg_id, iml_len_name, ied_chs_utf_8, achl_name, imp_sess_id,
+                                 (unsigned int)illp_epoch_ms, this->chr_ineta, this->im_port, imp_ldap_msg_id, achp_ldap_req ));
         // set address for data area
         achl_1 = achl_line + iml_1;
        
@@ -914,11 +897,19 @@
         int           iml_index, iml_data_i, iml_text_i;
         unsigned char uchl_1, uchl_2;
        
+        // hint: m_hlnew_printf() supports a length of 512 bytes only, so we have to split longer blocks
+        int   iml_out_count (0);
+        char *achl_out (achl_line);
+        int   iml_max (60);   // maximum of 60 blocks (each 64 bytes)
+       
+
         // step over all lines
         while (ump_size) 
         {  // format print out line   
+           iml_out_count++;
+
            m_hlsnprintf( (void *)achl_1, 80, ied_chs_utf_8,
-                         "%08x                                                    ........ ........ \n",
+                         "%08x                                                    ........ ........\r\n",
                          uml_data_offset );
            // set data- and text zone offset     
            iml_data_i = 10;
@@ -957,11 +948,27 @@
            uml_data_offset += 16;
            achl_1 += 79;
 
+           // should we print out a part of the data dump?
+           if (iml_out_count == 4 && ump_size && iml_max > 0)
+           {
+             *(achl_1 - 2) = '\0';
+             m_hlnew_printf( 0/*HLOG_INFO1*/, achl_out );
+
+             iml_max--;
+             achl_out = achl_1;
+             iml_out_count = 0;
+           }
         }; // while (ump_size)
  
         // display message...
+        if (iml_max == 0)
+          m_hlnew_printf( 0/*HLOG_INFO1*/, "more..." );
+        else
+          if (iml_out_count != 0)
+          {
         *(achl_1 - 2) = '\0';
-        m_hlnew_printf( 0/*HLOG_INFO1*/, achl_line );
+            m_hlnew_printf( 0/*HLOG_INFO1*/, achl_out /*achl_line */);
+          }
      
         m_aux_stor_free( &this->ads_hl_stor, (void *)achl_line );
       } // valid parameters
@@ -970,29 +977,32 @@


    /**
-    * dsd_trace::m_trace_data_gather()
+    * dsd_trace::m_trace_gather_data()
     *
     * Formats a printable trace data message string. The function works like the
     * dsd_trace::m_trace_data(), but uses gather data.
     *
-    * @param [in]  int                      imp_trace_level  trace level expected
-    * @param [in]  int                      imp_msg_num      message number
-    * @param [in]  int                      imp_sess_num     session number
-    * @param [in]  HL_LONGLONG              illp_epoch_ms    epoch time in milliseconds
-    * @param [in]  struct sockaddr_storage *adsp_conn        socket address information 
-    * @param [in]  template <T>            *adsp_entry       configuration entry (e.g. dsd_ldap_entry)
-    * @param [in]  struct dsd_gather_i_1   *adsp_data        data address
+    * @param[in]  imp_trace_level  trace level expected
+    * @param[in]  imp_msg_id       trace message id   
+    * @param[in]  imp_sess_id      session id    
+    * @param[in]  imp_ldap_msg_id  ldap message id
+    * @param[in]  achp_ldap_req    ldap request name
+    * @param[in]  illp_epoch_ms    epoch time in milliseconds
+    * @param[in]  adsp_conn        socket address information 
+    * @param[in]  adsp_entry       configuration entry (e.g. dsd_ldap_entry)
+    * @param[in]  adsp_data        data address
     *
-    * @return         void
+    * @return     void
     *
     * Remarks:
-    * 0         1  1  1  1  2  2  2  3   3  3  4  4  4  5  5  5   6        6       7 7 7
-    * 0         0  3  6  9  2  5  8  1   5  8  1  4  7  0  3  6   0        9       7 8 9
-    * xxxxxxxx  xx xx xx xx xx xx xx xx  xx xx xx xx xx xx xx xx  ........ ........ \n\0 (length: 80)
+    *
+    *     0         1  1  1  1  2  2  2  3   3  3  4  4  4  5  5  5   6        6       7 7 7
+    *     0         0  3  6  9  2  5  8  1   5  8  1  4  7  0  3  6   0        9       7 8 9
+    *     xxxxxxxx  xx xx xx xx xx xx xx xx  xx xx xx xx xx xx xx xx  ........ ........\r\n\0 (length: 80)
     */
     template <class T>
-    void m_trace_gather_data( int imp_trace_level, int imp_msg_num, int imp_sess_num,
-                              HL_LONGLONG illp_epoch_ms, struct sockaddr_storage *adsp_conn,
+    void m_trace_gather_data( int imp_trace_level, int imp_msg_id, int imp_sess_id, int imp_ldap_msg_id,
+                              char *achp_ldap_req, HL_LONGLONG illp_epoch_ms, struct sockaddr_storage *adsp_conn,
                               T *adsp_entry,
                               struct dsd_gather_i_1 *adsp_data )
 {
@@ -1041,9 +1051,9 @@
         char *achl_1, *achl_line ((char *)m_aux_stor_alloc( &this->ads_hl_stor, HL_TRACEMSG_LEN + ((uml_size / 16) + 1) * 80 ));
        
         int iml_1 (m_hlsnprintf( (void *)achl_line, HL_TRACEMSG_LEN, ied_chs_utf_8,
-                                 (const char *)"%s%04iT  Name=\"%.*(.*)s\" S-id=%i Time=%10u Ineta=%s:%i Request\n",
-                                 this->chr_prefix, imp_msg_num, iml_len_name, ied_chs_utf_8, achl_name,
-                                 imp_sess_num, (unsigned int)illp_epoch_ms, this->chr_ineta, this->im_port ));
+                                 (const char *)"%s%04iT  Name=\"%.*(.*)s\" S-id=%i Time=%10u Ineta=%s:%i Request(%i) %s\r\n",
+                                 this->chr_prefix, imp_msg_id, iml_len_name, ied_chs_utf_8, achl_name, imp_sess_id,
+                                 (unsigned int)illp_epoch_ms, this->chr_ineta, this->im_port, imp_ldap_msg_id, achp_ldap_req ));
         // set address for data area
         achl_1 = achl_line + iml_1;
        
@@ -1051,14 +1061,20 @@
         int           iml_index, iml_data_i, iml_text_i;
         unsigned char uchl_1, uchl_2, *auchl_data;
        
+        // hint: m_hlnew_printf() supports a length of 512 bytes only, so we have to split longer blocks
+        int   iml_out_count (0);   
+        char *achl_out (achl_line);
+       
         // step over all lines
         adsl_gather_1 = adsp_data;
         auchl_data = (unsigned char *)adsl_gather_1->achc_ginp_cur;

         while (uml_size) 
         {  // format print out line   
+           iml_out_count++;
+
            m_hlsnprintf( (void *)achl_1, 80, ied_chs_utf_8,
-                         "%08x                                                    ........ ........ \n",
+                         "%08x                                                    ........ ........\r\n",
                          uml_data_offset );
            // set data- and text zone offset     
            iml_data_i = 10;
@@ -1098,17 +1114,30 @@
                 auchl_data    = (unsigned char *)adsl_gather_1->achc_ginp_cur;
               }
              
-           } while (iml_index < 16 && uml_size);
+           } while (iml_index < 16 && uml_size);  // single line finished
    
            // set next line number
            uml_data_offset += 16;
            achl_1 += 79;
 
+           // should we print out a part of the data dump?
+           if (iml_out_count == 4 && uml_size)
+           {
+             *(achl_1 - 2) = '\0';
+             m_hlnew_printf( 0/*HLOG_INFO1*/, achl_out );
+
+             achl_out = achl_1;
+             iml_out_count = 0;
+           }
+
         }; // while (uml_size)
  
         // display message...
-        *(achl_1 - 2) = '\0';
-        m_hlnew_printf( 0/*HLOG_INFO1*/, achl_line );
+        if (iml_out_count != 0)
+        {
+          *(achl_1 - 2) = '\0';
+          m_hlnew_printf( 0/*HLOG_INFO1*/, achl_out /*achl_line*/ );
+        }
      
         m_aux_stor_free( &this->ads_hl_stor, (void *)achl_line );
       } // valid parameters
@@ -1136,39 +1165,84 @@
  * @author  Juergen-Lorenz Lauenstein                        
  * @date    2005/08/16   (creation)
  * @date    2008/03/10   (last changes)   
- */
-
-/**
+ *
  * Overview of ASN1 tag construction
  *
- *	Bits
- *	______
- *	8 7 | CLASS
- *	0 0 = UNIVERSAL
- *	0 1 = APPLICATION
- *	1 0 = CONTEXT-SPECIFIC
- *	1 1 = PRIVATE
- *		_____
- *		| 6 | DATA-TYPE
- *		  0 = PRIMITIVE
- *		  1 = CONSTRUCTED
- *			___________
- *			| 5 ... 1 | TAG-NUMBER
+ *	     Bits
+ *	   _______
+ *	   | 8 7 | CLASS
+ *	     0 0 = UNIVERSAL
+ *	     0 1 = APPLICATION
+ *	     1 0 = CONTEXT-SPECIFIC
+ *	     1 1 = PRIVATE
+ *		     _____
+ *		     | 6 | DATA-TYPE
+ *		       0 = PRIMITIVE
+ *		       1 = CONSTRUCTED
+ *	  		     ___________
+ *			     | 5 ... 1 | TAG-NUMBER
+ *
  */
-#define LASN1_CLASS_UNIVERSAL	((unsigned int) 0x00U)
+#define LASN1_CLASS_UNIVERSAL	((unsigned int) 0x00U) 
 #define LASN1_CLASS_APPLICATION	((unsigned int) 0x40U)
-#define LASN1_CLASS_CONTEXT		((unsigned int) 0x80U)
-#define LASN1_CLASS_PRIVATE		((unsigned int) 0xc0U)
+#define LASN1_CLASS_CONTEXT		((unsigned int) 0x80U) 
+#define LASN1_CLASS_PRIVATE		((unsigned int) 0xc0U) 
 #define LASN1_CLASS_MASK		((unsigned int) 0xc0U)

 /**< BER encoding type and mask */
-#define LASN1_PRIMITIVE			((unsigned int) 0x00U)
-#define LASN1_CONSTRUCTED		((unsigned int) 0x20U)
-#define LASN1_ENCODING_MASK		((unsigned int) 0x20U)
+#define LASN1_DATA_PRIMITIVE	((unsigned int) 0x00U)
+#define LASN1_DATA_CONSTRUCTED	((unsigned int) 0x20U)
+#define LASN1_DATA_MASK		    ((unsigned int) 0x20U)

 #define LASN1_BIG_TAG_MASK		((unsigned int) 0x1fU)
 #define LASN1_MORE_TAG_MASK		((unsigned int) 0x80U)

+#define LDAP_TAG_NEWSUPERIOR	((unsigned int) 0x80U)	/**< context-specific + primitive + 0 */
+
+#define LDAP_TAG_EXOP_REQ_OID   ((unsigned int) 0x80U)	/**< context specific + primitive */
+#define LDAP_TAG_EXOP_REQ_VALUE ((unsigned int) 0x81U)	/**< context specific + primitive */
+#define LDAP_TAG_EXOP_MOD_USER 	((unsigned int) 0x80U)
+#define LDAP_TAG_EXOP_MOD_PWD_O	((unsigned int) 0x81U)
+#define LDAP_TAG_EXOP_MOD_PWD_N	((unsigned int) 0x82U)
+
+/** LDAP Request and Response Messages */
+#define LDAP_REQ_BIND		   ((unsigned int)(LASN1_CLASS_APPLICATION | LASN1_DATA_CONSTRUCTED | 0))  /**< application[0] + constructed  : 0x60 */
+#define LDAP_RESP_BIND		   ((unsigned int)(LASN1_CLASS_APPLICATION | LASN1_DATA_CONSTRUCTED | 1))  /**< application[1] + constructed  : 0x61 */
+
+#define LDAP_REQ_UNBIND		   ((unsigned int)(LASN1_CLASS_APPLICATION | LASN1_DATA_PRIMITIVE   | 2))  /**< application[2] + primitive    : 0x42 */
+
+#define LDAP_REQ_SEARCH	   	   ((unsigned int)(LASN1_CLASS_APPLICATION | LASN1_DATA_CONSTRUCTED | 3))  /**< application[3] + constructed  : 0x63 */
+#define LDAP_RESP_SEARCH_ENTRY ((unsigned int)(LASN1_CLASS_APPLICATION | LASN1_DATA_CONSTRUCTED | 4))  /**< application[4} + constructed  : 0x64 */
+#define LDAP_RESP_SEARCH_DONE  ((unsigned int)(LASN1_CLASS_APPLICATION | LASN1_DATA_CONSTRUCTED | 5))  /**< application[5] + constructed  : 0x65 */
+#define LDAP_RESP_SEARCH_REF   ((unsigned int)(LASN1_CLASS_APPLICATION | LASN1_DATA_CONSTRUCTED | 19)) /**< application[19] + constructed : 0x73 */
+
+#define LDAP_REQ_MODIFY		   ((unsigned int)(LASN1_CLASS_APPLICATION | LASN1_DATA_CONSTRUCTED | 6))  /**< application[6] + constructed  : 0x66 */
+#define LDAP_RESP_MODIFY	   ((unsigned int)(LASN1_CLASS_APPLICATION | LASN1_DATA_CONSTRUCTED | 7))  /**< application[7] + constructed  : 0x67 */
+
+#define LDAP_REQ_ADD		   ((unsigned int)(LASN1_CLASS_APPLICATION | LASN1_DATA_CONSTRUCTED | 8))  /**< application[8] + constructed  : 0x68 */
+#define LDAP_RESP_ADD		   ((unsigned int)(LASN1_CLASS_APPLICATION | LASN1_DATA_CONSTRUCTED | 9))  /**< application[9] + constructed  : 0x69 */
+
+#define LDAP_REQ_DELETE		   ((unsigned int)(LASN1_CLASS_APPLICATION | LASN1_DATA_PRIMITIVE   | 10)) /**< application[10] + primitive   : 0x4A */
+#define LDAP_RESP_DELETE	   ((unsigned int)(LASN1_CLASS_APPLICATION | LASN1_DATA_CONSTRUCTED | 11)) /**< application[11] + constructed : 0x6B */
+
+#define LDAP_REQ_MODDN		   ((unsigned int)(LASN1_CLASS_APPLICATION | LASN1_DATA_CONSTRUCTED | 12)) /**< application[12] + constructed : 0x6C */
+#define LDAP_RESP_MODDN		   ((unsigned int)(LASN1_CLASS_APPLICATION | LASN1_DATA_CONSTRUCTED | 13)) /**< application[13} + constructed : 0x6D */
+
+#define LDAP_REQ_COMPARE	   ((unsigned int)(LASN1_CLASS_APPLICATION | LASN1_DATA_CONSTRUCTED | 14)) /**< application[14] + constructed : 0x6E */
+#define LDAP_RESP_COMPARE	   ((unsigned int)(LASN1_CLASS_APPLICATION | LASN1_DATA_CONSTRUCTED | 15)) /**< application[15] + constructed : 0x6F */
+
+#define LDAP_REQ_ABANDON	   ((unsigned int)(LASN1_CLASS_APPLICATION | LASN1_DATA_PRIMITIVE   | 16)) /**< application[16] + primitive   : 0x50 */
+
+#define LDAP_REQ_EXTENDED	   ((unsigned int)(LASN1_CLASS_APPLICATION | LASN1_DATA_CONSTRUCTED | 23)) /**< application[23] + constructed : 0x77 */
+#define LDAP_RESP_EXTENDED	   ((unsigned int)(LASN1_CLASS_APPLICATION | LASN1_DATA_CONSTRUCTED | 24)) /**< application[24] + constructed : 0x78 */
+
+#define LDAP_RESP_NONE         ((unsigned int)0xffU)  /**< no response expected      */
+
+/** authentication methods available */
+#define LDAP_AUTH_NONE   ((unsigned int) 0x00U) /**< no authentication */
+#define LDAP_AUTH_SIMPLE ((unsigned int) 0x80U) /**< context specific + primitive */
+#define LDAP_AUTH_SASL   ((unsigned int) 0xa3U) /**< context specific + constructed */
+
 /**< general BER types we know about */
 #define LASN1_BOOLEAN		((unsigned int) 0x01UL)
 #define LASN1_INTEGER		((unsigned int) 0x02UL)
@@ -1209,8 +1283,20 @@
 #define LASN1_ERROR		  ((unsigned int) -1)
 #define LASN1_WAIT_MORE   ((unsigned int) -2)

+/** substring filter component types */
+#define LDAP_SUBSTRING_INITIAL	((unsigned int) 0x80U)	/**< context specific */
+#define LDAP_SUBSTRING_ANY		((unsigned int) 0x81U)	/**< context specific */
+#define LDAP_SUBSTRING_FINAL	((unsigned int) 0x82U)	/**< context specific */

+/** OID supported for extended operations */
+#define OID_CANCEL_EX    "1.3.6.1.1.8"
+#define OID_STARTTLS_EX  "1.3.6.1.4.1.1466.20037"
+#define OID_PW_MODIFY_EX "1.3.6.1.4.1.4203.1.11.1"
+#define OID_WHOAMI       "1.3.6.1.4.1.4203.1.11.3"
+#define OID_DELTREE      "1.2.840.113556.1.4.805"

+
+
 class dsd_asn1
 {
     struct dsd_elem_1;
@@ -1260,8 +1346,7 @@
    
 // public methods
 public:
-	void m_init( void *adsp_hl_stor = NULL );    ///< constructor dsd_asn1()
-                                                 ///< destructor  ~dsd_asn1()
+	void m_init( void *adsp_hl_stor = NULL );   

     int  m_test_resp( class dsd_bufm *, int *, int *imp_nextpos = NULL ); ///< wait for a complete TLV-response...                                                        
 	int  m_set_gather( HL_LONGLONG * );
@@ -1283,7 +1368,7 @@
 	int  m_get_enum( int *aimp_enum );
 	int  m_get_int ( int *aimp_int );
 	int	 m_get_string( char **aachp_string, int *imp_len, void **aavop_handle = NULL );
-	int  m_get_stringar( struct dsd_ldap_val **aadsp_ldap_values, void **aavop_handle = NULL );
+	int  m_get_stringar( struct dsd_ldap_val **aadsp_attr_vals, void **aavop_handle = NULL );

 	int	 m_put_tag( int /**< tag */, int /**< taglen */, char * /**< buf */ );
 	int	 m_put_len( int /**< len */, int /**< lenlen */, char * /**< buf */ );
@@ -1294,7 +1379,7 @@
 	int	 m_put_null( int /**< tag */ );
 	int  m_put_string( char * /**< string value */, int /**< string length */, enum ied_charset /**< charset */, int /**< tag */ );
 	int  m_put_string_uc( struct dsd_unicode_string * /**< unicode string */, int /**< tag */ );
-	int  m_put_octetstring( char * /*string value*/, int /**< string length */, int /**< tag */ );
+	int  m_put_octetstring( char *, int, int );

 	int  m_calc_lenlen( int imp_len );
 	int	 m_calc_taglen( int imp_tag );
@@ -1337,6 +1422,7 @@
    static int    im_sess_cnt;                             ///< counter for number of running ldap connections
    static class  dsd_hcla_critsect_1  ds_cs_ldap;         ///< synchronisation object for all class instances
    static class  dsd_ldap_schema     *ads_schema_anc;     ///< ldap schema class anchor for nonMSAD servers
+   static void  *ads_hl_stor_glob;                        ///< global storage handler
    static struct dsd_timer_ele        ds_timer_1;         ///< utc timer update interval
    static HL_LONGLONG  il_utc_time;                       ///< current utc time (in 100ns since 1.1.1601 12a.m)

@@ -1388,9 +1474,10 @@
      enum L_Status{ REQ_BUILDING, REQ_INPROGRESS, REQ_COMPLETED, REQ_FLUSHING };
      L_Status  imc_l_status;  ///< status of request

-     int  imc_msgid;          ///< LDAP message ID
-     int  imc_req;            ///< LDAP request (e.g. BIND)
-     int  imc_resp[4];        ///< LDAP one or more response(s) expected (e.g. BIND_RESP)  
+     int   imc_msgid;          ///< LDAP message ID
+     int   imc_req;            ///< LDAP request (e.g. BIND)
+     char *ac_req;             ///< LDAP request string (e.g. "Bind")
+     int   imc_resp[4];        ///< LDAP one or more response(s) expected (e.g. BIND_RESP)  
    };

 public:
@@ -1525,7 +1612,7 @@
                        CREATOR_SID_AUTHORITY,                // 0x03
                        NON_UNIQUE_AUTHORITY,                 // 0x04
                        NT_AUTHORITY,                         // 0x05
-                       SECURITY_MANDATORY_LABEL_AUTHORITY }; // 0x06
+                       SEC_MANDATORY_LABEL_AUTHORITY }; // 0x06
                       
    struct dsd_sid
    {
@@ -1539,12 +1626,12 @@
    BOOL   bo_le;                        ///< TRUE: le-endianess, FALSE: be-endianess
   
    ///< convertion routines for SIDs
-   int m_aux_sid_to_hex( char *,                ///< sid-string ("S-1-5-21-...")
-                         int,                   ///< sid-string length
-                         struct dsd_sid * );    ///< out: sid in a hexadecimal format
-   int m_aux_hex_to_sid( struct dsd_sid      *, ///< sid in a hexdecimal format
-                         struct dsd_ldap_val *, ///< out: sid in the string-format ("S-1-...")
-                         void * );              ///< storage handler
+   int m_aux_sid_to_hex( char *,               
+                         int,                  
+                         struct dsd_sid * );   
+   int m_aux_hex_to_sid( struct dsd_sid      *,
+                         struct dsd_ldap_val *,
+                         void * );             
   
 private:                       
    /// for non-blocking calls of m_ldap_request()
@@ -1615,7 +1702,7 @@
    struct dsd_ldap_entry  *ads_ldap_entry;  ///< configuration context

    /// constructor  
-   dsd_ldap_schema( struct dsd_ldap_group *adsp_ldap_group = NULL, struct dsd_ldap_entry *adsp_ldap_entry = NULL )
+   void m_init( struct dsd_ldap_group *adsp_ldap_group = NULL, struct dsd_ldap_entry *adsp_ldap_entry = NULL )
    {
       dsd_ldap::ds_cs_ldap.m_enter();
       this->ads_next = dsd_ldap::ads_schema_anc;     
@@ -1626,37 +1713,27 @@
       this->ads_ldap_group = adsp_ldap_group;
       this->ads_ldap_entry = adsp_ldap_entry;
                                               
-      // initialize storage handler
-      m_aux_stor_start( &this->ads_hl_stor );  
-
       this->im_avl_status = (m_htree1_avl_init( NULL,
                                                 &this->ds_htree_control, 
                                                 &(dsd_ldap_schema::m_htree1_avl_compare) ) == TRUE) ? dsd_ldap_schema::SUCCESS
                                                                                                     : dsd_ldap_schema::TREE_ERROR;
    };
   
-   /// destructor  
-   ~dsd_ldap_schema()
-   {
-      // free storage handler (this frees the whole tree)...
-      m_aux_stor_end( &this->ads_hl_stor );
-   };

-
    /**
-     m_htree1_avl_insert() - Insert a new entry to the tree
-   
-     @param[in]  char                   *achp_attr     attribute name to insert
-     @param[in]  int                     imp_len_attr  attribute name length
-     @param[in]  enum ied_ldap_attr_def  iep_attr_def  'ied_ldap_attr_single' or 'ied_ldap_attr_multi'
-
-     @return     BOOL  TRUE    successful
-                       FALSE   operation failed, a more detailed information
-                               is set in dsd_ldap_schema::im_avl_status
+    * m_htree1_avl_insert() - Insert a new entry to the tree 
+    *                                                            
+    * @param[in]  achp_attr     attribute name to insert           
+    * @param[in]  imp_len_attr  attribute name length                
+    * @param[in]  iep_attr_def  'ied_ldap_attr_single' or 'ied_ldap_attr_multi'     
+    *                                                                                 
+    * @return     \b TRUE    if successful or
+    *             \b FALSE   if the operation failed. A more detailed information
+    *                        is set in dsd_ldap_schema::im_avl_status
     */
    BOOL m_htree_avl_insert( char *achp_attr, int imp_len_attr, enum ied_ldap_attr_def iep_attr_def )
    {
-      struct dsd_avl_schema_attr  *adsl_schema_attr = (struct dsd_avl_schema_attr *)m_aux_stor_alloc( &this->ads_hl_stor,
+      struct dsd_avl_schema_attr  *adsl_schema_attr = (struct dsd_avl_schema_attr *)m_aux_stor_alloc( &dsd_ldap::ads_hl_stor_glob,
                                                                                                       sizeof(struct dsd_avl_schema_attr) + imp_len_attr );
       memset( adsl_schema_attr, 0, sizeof(struct dsd_avl_schema_attr) );
       adsl_schema_attr->iec_attr_def = iep_attr_def;
@@ -1700,15 +1777,15 @@


    /**
-     m_htree1_avl_search() - Search an entry in the tree
-   
-     @param[in]     char                   *achp_attr      attribute name to search
-     @param[in]     int                     imp_len_attr   attribute name length
-     @param[√≠n,out] enum ied_ldap_attr_def *aiep_attr_def  returns the 'single' or 'multivalued'-state
-
-     @return     BOOL  TRUE    successful, entry found (aiep_attr_def is valid)
-                       FALSE   operation failed, a more detailed information
-                               is set in dsd_ldap_schema::im_avl_status
+    * m_htree1_avl_search() - Search an entry in the tree 
+    *               
+    * @param[in]     achp_attr      attribute name to search 
+    * @param[in]     imp_len_attr   attribute name length 
+    * @param[in,out] aiep_attr_def  returns the 'single' or 'multivalued'-state 
+    * 
+    * @return     \b TRUE    if successful, the entry is found (aiep_attr_def is valid). 
+    *             \b FALSE   if the operation failed. A a more detailed information  
+    *                        is set in dsd_ldap_schema::im_avl_status. 
     */
    BOOL m_htree_avl_search( char *achp_attr, int imp_len_attr, enum ied_ldap_attr_def *aiep_attr_def )
    {
@@ -1765,8 +1842,6 @@
    enum ied_avl_status_def  im_avl_status;          ///< state of the HOB tree AVL

 private:  
-   void  *ads_hl_stor;           ///< internal hob storage handle
-
    struct dsd_avl_schema_attr    ///< structure for defining a schema attribute
    {                                                         
      char                        *ac_val;        ///< attribute (utf-8)
@@ -1786,17 +1861,19 @@
 extern "C" void m_ldap_init( class dsd_ldap * );   ///< -> constructor
 extern "C" void m_ldap_free( class dsd_ldap * );   ///< -> destructor

-extern "C" int  m_ldap_request( class  dsd_ldap *, /**< ldap class instance   */
-                     struct dsd_ldap_group *,      /**< ldap configuration    */
-                     struct dsd_co_ldap_1 *,       /**< ldap command structure*/    
-                     void  *vpp_userfld = NULL,    /**< user field            */
-                     int   (*m_cb_func)( void *,                /**< user field             */
-                                         class dsd_ldap *,      /**< ldap class instance    */
-                                         struct dsd_co_ldap_1 * /**< ldap command structure */ ) = NULL /**< callback function */ );
+extern "C" int  m_ldap_request( class  dsd_ldap *,         /**< ldap class instance   */
+                                struct dsd_ldap_group *,   /**< ldap configuration    */
+                                struct dsd_co_ldap_1 *,    /**< ldap command structure*/    
+                                void  *vpp_userfld = NULL, /**< user field            */
+                                int   (*m_cb_func)( void *,                /**< user field             */
+                                                    class dsd_ldap *,      /**< ldap class instance    */
+                                                    struct dsd_co_ldap_1 * /**< ldap command structure */ ) = NULL /**< callback function */ );

-extern "C" enum ied_ret_ldap_def  m_ldap_auth( struct dsd_ldap_group *,      /**< configuration */
-                                               struct dsd_unicode_string *,  /**< userid        */
-                                               struct dsd_unicode_string *   /**< password      */ ); 
+extern "C" enum ied_ret_ldap_def  m_ldap_auth( struct dsd_ldap_group *,     /**< configuration */
+                                               struct dsd_unicode_string *, /**< userid        */
+                                               struct dsd_unicode_string *  /**< password      */ ); 
+  
+extern "C" int m_hl_memicmp( void *, void *, int );   ///< _memicmp() replacement for Linux
                                        
 #endif	// _hob_ldap_H

Index: xshsessutil01.cpp
===================================================================
--- xshsessutil01.cpp	(revision 2)
+++ xshsessutil01.cpp	(revision 6)
@@ -30,12 +30,18 @@
 #else
 #define HOB_CONTR_TIMER
 #include <time.h>
-#include "types_defines.h"
+
+//#include "types_defines.h"
+#ifndef byte
+#define byte unsigned char
+#endif
+
 #include "hob-unix01.h"
 #include "hob-avl03.h"
 #include <string.h>
 #include <stdarg.h>
 #include <netdb.h>
+#include <net/if.h>
 #endif
 #ifndef HL_UNIX
 typedef int socklen_t;
@@ -50,18 +56,18 @@
 #include <iostream>
 #include "hob-xslcontr.h"
 #include "hob-tun01.h"
-#include "hob-htcp-int-types.h"
-#include "hob-htcp.h"
-#include "hob-htcp-bit-reference.h"
-#include "hob-htcp-tcpip-hdr.h"
-#include "hob-htcp-misc.h"
-#include "hob-htcp-connection.h"
+#include "hob-htcp-int-01.h"
+//#include "hob-htcp-int-types.h"
+//#include "hob-htcp.h"
+//#include "hob-htcp-bit-reference.h"
+//#include "hob-htcp-tcpip-hdr.h"
+//#include "hob-htcp-misc.h"
+//#include "hob-htcp-connection.h"
 #include "hob-session01.h"
-#include "hob-htcp-session.h"
+//#include "hob-htcp-session.h"
 #include "hob-gw-ppp-1.h"
 #include "hob-hppp01.h"
 #include "hob-hsstp01.h"
-#include "hob-tun02.h"
 #include "hob-tuntapif01.h"
 #include <stdio.h>
 #include <vector>
@@ -75,45 +81,43 @@
 #include <hob-encry-1.h>
 #endif

-dsd_session* m_init_sess(dsd_tun_start1* adsp_tun_start,
-                         dsd_tun_contr1* adsp_sess_info)
+std::list<dsd_tun_contr_ineta*> dsg_tun_contr_ineta_list;
+
+void m_init_sess(//dsd_tun_start_htcp* adsp_tun_start_htcp,
+                         dsd_tun_start_ppp* adsp_tun_start_ppp,
+                         dsd_tun_contr_conn* adsp_tun_contr_conn,
+                         dsd_tun_contr_ineta* adsp_tun_contr_ineta)
 {
    dsd_session* adsl_new_sess = 0; // Return value.

    // Create the session object based on the session configuration info.
-
-   switch(adsp_sess_info->iec_tunc)
+   switch(adsp_tun_contr_conn->iec_tunc)
    {
       case ied_tunc_ppp:
       {  // PPP session.
-          adsl_new_sess = new(&adsp_sess_info->achc_session_buffer) dsd_ppp_session(adsp_tun_start, adsp_sess_info);
+         dsd_ppp_session* adsl_new_ppp_sess = new dsd_ppp_session(adsp_tun_start_ppp, adsp_tun_contr_conn,
+            adsp_tun_contr_ineta);
+         *(adsp_tun_start_ppp->adsc_htun_h) = (void*)&adsl_new_ppp_sess->dsc_htun_handle; //adsp_tun_contr_conn;
+		 // Initialize the session object properly.
+		 adsl_new_ppp_sess->mc_init();
+	     return;
       }; break;
       case ied_tunc_sstp:
       {  // SSTP session.
-          adsl_new_sess = new(&adsp_sess_info->achc_session_buffer) dsd_sstp_session(adsp_tun_start, adsp_sess_info);
+         adsl_new_sess = new dsd_sstp_session(adsp_tun_start_ppp, adsp_tun_contr_conn,
+            adsp_tun_contr_ineta);
+         *(adsp_tun_start_ppp->adsc_htun_h) = (void*)&adsl_new_sess->dsc_htun_handle; //adsp_tun_contr_conn;
       }; break;
-      case ied_tunc_htcp:
-      {  // HTCP session.
-          adsl_new_sess = new(&adsp_sess_info->achc_session_buffer) dsd_htcp_session(adsp_tun_start, adsp_sess_info);
-#ifdef KS_18_03_09
-		  //adsl_new_sess = new(TUN_CONTR_HTCP_SESSION(adsp_sess_info)) dsd_htcp_session(adsp_sess_info, ulp_if_idx, vp_info); // KS 18-03-09
-#else
-		  adsl_new_sess = new(&(adsp_sess_info->dsc_htcp_session)) dsd_htcp_session(adsp_sess_info, ulp_if_idx, vp_info); // KS 18-03-09
-#endif
-	  }; break;
+//      case ied_tunc_htcp:
+//      {  // HTCP session.
+//         adsl_new_sess = new dsd_htcp_session(adsp_tun_start_htcp, adsp_tun_contr_conn,
+//            adsp_tun_contr_ineta);
+//         *(adsp_tun_start_htcp->adsc_htun_h) = (void*)adsp_tun_contr_conn;
+//	  }; break;
    }

-   /* Set handle to return to caller. Should be set before legitate packets may
-      be received, but not before a packet can be handled. */
-   *adsp_tun_start->adsc_htun_h = adsp_sess_info;
-
    // Initialize the session object properly.
-
    adsl_new_sess->mc_init();
-
-   // Return pointer to new session object.
-
-   return adsl_new_sess;
 }

 void m_free_gath_chain(dsd_gather_i_1* adsp_chain_root)
@@ -129,8 +133,8 @@

 #ifdef B101123
 BOOL m_getlen(dsd_gather_i_1* adsp_root_gather,
-              int32& imp_length,
-              int32& imp_lenlen)
+              int32_t& imp_length,
+              int32_t& imp_lenlen)
 {
    imp_length = 0; // Value of length field.
    imp_lenlen = 1; // Length of length field.
@@ -171,8 +175,8 @@
 #endif

 BOOL m_getlen(dsd_gather_i_1* adsp_root_gather,
-              int32& imp_length,
-              int32& imp_lenlen)
+              int32_t& imp_length,
+              int32_t& imp_lenlen)
 {
     imp_length = 0; // Value of length field.
     imp_lenlen = 0; // Length of length field.
@@ -198,7 +202,7 @@
 }

 BOOL m_check_pkt_complete(dsd_gather_i_1* adsp_root_link,
-                          int32 imp_tot_pkt_len,
+                          int32_t imp_tot_pkt_len,
                           byte** aabyp_pkt_end)
 {
    // Set ptr to pass back to NULL.
@@ -206,7 +210,7 @@
    // Set current link to root link.
    dsd_gather_i_1* adsl_cur_link = adsp_root_link;
    // Set pkt length found to be available to 0.
-   int32 iml_tot_avail_len = 0;
+   int32_t iml_tot_avail_len = 0;
    // While more links are available in chain.
    while(adsl_cur_link != NULL)
    {
@@ -238,13 +242,13 @@

 byte* m_search_nlnl(byte* abyp_pos_start, byte* abyp_pos_end)
 {
-  uint32 uml_nlnl = 0x0A0D0A0D; // Value to find.
+  uint32_t uml_nlnl = 0x0A0D0A0D; // Value to find.
   // Set current position to start of buffer.
   byte* ubyl_pos_cur = abyp_pos_start;
   // Iterate through buffer, searching for value.
   while(ubyl_pos_cur != abyp_pos_end - 3)
   {
-    if(*((uint32*)(ubyl_pos_cur)) == uml_nlnl)
+    if(*((uint32_t*)(ubyl_pos_cur)) == uml_nlnl)
       // Value found!
       return ubyl_pos_cur + 4;
     // Move to next position in buffer.
@@ -254,9 +258,9 @@
   return NULL;
 }

-int32 m_get_sstp_lengthpacket(dsd_gather_i_1* adsp_link_cur)
+int32_t m_get_sstp_lengthpacket(dsd_gather_i_1* adsp_link_cur)
 {
-  int32 iml1 = 2;
+  int32_t iml1 = 2;
   dsd_gather_i_1* adsl_link_cur = adsp_link_cur;
   while((adsl_link_cur != NULL) &&
      (adsl_link_cur->achc_ginp_end - adsl_link_cur->achc_ginp_cur) <= iml1)
@@ -268,12 +272,12 @@
   if(adsl_link_cur == NULL)
     return -1;

-  int32 iml_lengthpacket = -1;
+  int32_t iml_lengthpacket = -1;
   if((adsl_link_cur->achc_ginp_cur + iml1 + 2) <= adsl_link_cur->achc_ginp_end)
   { // Entire LengthPacket value in current link.
     // Get SSTP length value.
     iml_lengthpacket =
-       ntohs(0xFF0F & *((uint16*)(adsl_link_cur->achc_ginp_cur + iml1)));
+       ntohs(0xFF0F & *((uint16_t*)(adsl_link_cur->achc_ginp_cur + iml1)));
   }
   // Entire length value not available.
   else if(adsl_link_cur->adsc_next != NULL)
@@ -287,11 +291,11 @@
 }

 byte* m_check_sstp_complete(dsd_gather_i_1* adsp_link_cur,
-                            uint16 usp_lengthpacket)
+                            uint16_t usp_lengthpacket)
 {
   // Get ptr to start of chain.
   dsd_gather_i_1* adsl_link_cur = adsp_link_cur;
-  int32 iml1 = usp_lengthpacket;
+  int32_t iml1 = usp_lengthpacket;
   // Loop through links in chain, looking for end of message.
   // Stop when end of message found, or no more links in chain.
   while(adsl_link_cur != NULL)
@@ -308,7 +312,7 @@
 }

 byte* m_copy_sstp_message(dsd_gather_i_1* adsp_link_cur,
-                          uint16 usp_lengthpacket,
+                          uint16_t usp_lengthpacket,
                           byte* abyp_sstp_msg_end)
 {
   // Get ptr to start of chain.
@@ -318,7 +322,7 @@
   // Create a new buffer large enough for the entire SSTP message.
   byte* abyl_cpy_buf = new byte[usp_lengthpacket];
   // Traverse links containing the SSTP message, starting from 1st link.
-  int32 iml1 = 0;
+  int32_t iml1 = 0;
   while(!(((byte*)(adsl_link_cur->achc_ginp_cur) < abyl_sstp_msg_end) &&
      ((byte*)(adsl_link_cur->achc_ginp_end) >= abyl_sstp_msg_end)))
   {
@@ -343,14 +347,14 @@
 }

 byte* GenerateAuthenticatorResponse
-   (byte*  abyp_peer_pw,    // Peer password.
-    uint32 ump_peer_pw_len, // Peer password length.
-    byte*  abyp_peer_un,    // Peer username.
-    uint32 ump_peer_un_len, // Peer username length.
-    byte*  abyp_peer_resp,  // Peer NT-Response value (24 byte).
-    byte*  abyp_peer_chal,  // Peer challenge value (16 byte).
-    byte*  abyp_own_chal,   // Own challenge value (16 byte).
-    byte*  abyp_result_buf) // Buffer to place result.
+   (byte*    abyp_peer_pw,    // Peer password.
+    uint32_t ump_peer_pw_len, // Peer password length.
+    byte*    abyp_peer_un,    // Peer username.
+    uint32_t ump_peer_un_len, // Peer username length.
+    byte*    abyp_peer_resp,  // Peer NT-Response value (24 byte).
+    byte*    abyp_peer_chal,  // Peer challenge value (16 byte).
+    byte*    abyp_own_chal,   // Own challenge value (16 byte).
+    byte*    abyp_result_buf) // Buffer to place result.
 {
   // MD4 hash of peer password.
   byte byrl_pw_hash[16]     = { 0 };
@@ -381,62 +385,62 @@

  
   // Hash the password with MD4.
-  uint32 umrl_md4_state[24] = { 0 };
-  MD4_Init((int32*)umrl_md4_state);
-  MD4_Update((int32*)umrl_md4_state, (char*)abyp_peer_pw, 0, ump_peer_pw_len);
-  MD4_Final((int32*)umrl_md4_state, (char*)byrl_pw_hash, 0);
+  uint32_t umrl_md4_state[24] = { 0 };
+  MD4_Init((int32_t*)umrl_md4_state);
+  MD4_Update((int32_t*)umrl_md4_state, (char*)abyp_peer_pw, 0, ump_peer_pw_len);
+  MD4_Final((int32_t*)umrl_md4_state, (char*)byrl_pw_hash, 0);

   // Now hash the hash with MD4.
-  MD4_Init((int32*)umrl_md4_state);
-  MD4_Update((int32*)umrl_md4_state, (char*)byrl_pw_hash, 0, 16);
-  MD4_Final((int32*)umrl_md4_state, (char*)byrl_pw_hashhash, 0);
+  MD4_Init((int32_t*)umrl_md4_state);
+  MD4_Update((int32_t*)umrl_md4_state, (char*)byrl_pw_hash, 0, 16);
+  MD4_Final((int32_t*)umrl_md4_state, (char*)byrl_pw_hashhash, 0);

   // Hash a combination of the MD4 password digest, NT-Response
   // and the first Magic constant with SHA1.
-  uint32 umrl_sha_state[24] = { 0 };
-  SHA1_Init((int32*)umrl_sha_state);
-  SHA1_Update((int32*)umrl_sha_state, (char*)byrl_pw_hashhash, 0, 16);
-  SHA1_Update((int32*)umrl_sha_state, (char*)abyp_peer_resp, 0, 24);
-  SHA1_Update((int32*)umrl_sha_state, (char*)byrl_magic1, 0, 39);
-  SHA1_Final((int32*)umrl_sha_state, (char*)byrl_digest_1, 0);
+  uint32_t umrl_sha_state[24] = { 0 };
+  SHA1_Init((int32_t*)umrl_sha_state);
+  SHA1_Update((int32_t*)umrl_sha_state, (char*)byrl_pw_hashhash, 0, 16);
+  SHA1_Update((int32_t*)umrl_sha_state, (char*)abyp_peer_resp, 0, 24);
+  SHA1_Update((int32_t*)umrl_sha_state, (char*)byrl_magic1, 0, 39);
+  SHA1_Final((int32_t*)umrl_sha_state, (char*)byrl_digest_1, 0);

   // Hash a combination of the original challenge, peer challenge
   // and the peer username with SHA1.

-  SHA1_Init((int32*)umrl_sha_state);
-  SHA1_Update((int32*)umrl_sha_state, (char*)abyp_peer_chal, 0, 16);
-  SHA1_Update((int32*)umrl_sha_state, (char*)abyp_own_chal, 0, 16);
-  SHA1_Update((int32*)umrl_sha_state, (char*)abyp_peer_un, 0, ump_peer_un_len);
-  SHA1_Final((int32*)umrl_sha_state, (char*)byrl_digest_2, 0);
+  SHA1_Init((int32_t*)umrl_sha_state);
+  SHA1_Update((int32_t*)umrl_sha_state, (char*)abyp_peer_chal, 0, 16);
+  SHA1_Update((int32_t*)umrl_sha_state, (char*)abyp_own_chal, 0, 16);
+  SHA1_Update((int32_t*)umrl_sha_state, (char*)abyp_peer_un, 0, ump_peer_un_len);
+  SHA1_Final((int32_t*)umrl_sha_state, (char*)byrl_digest_2, 0);
   memcpy(byrl_digest_chal, byrl_digest_2, 8);

   // Hash a combination of the first SHA1 digest, Challenge SHA1 digest
   // and the second magic number with SHA1.

-  SHA1_Init((int32*)umrl_sha_state);
-  SHA1_Update((int32*)umrl_sha_state, (char*)byrl_digest_1, 0, 20);
-  SHA1_Update((int32*)umrl_sha_state, (char*)byrl_digest_chal, 0, 8);
-  SHA1_Update((int32*)umrl_sha_state, (char*)byrl_magic2, 0, 41);
-  SHA1_Final((int32*)umrl_sha_state, (char*)byrl_digest_1, 0);
+  SHA1_Init((int32_t*)umrl_sha_state);
+  SHA1_Update((int32_t*)umrl_sha_state, (char*)byrl_digest_1, 0, 20);
+  SHA1_Update((int32_t*)umrl_sha_state, (char*)byrl_digest_chal, 0, 8);
+  SHA1_Update((int32_t*)umrl_sha_state, (char*)byrl_magic2, 0, 41);
+  SHA1_Final((int32_t*)umrl_sha_state, (char*)byrl_digest_1, 0);

   sprintf((char*)abyp_result_buf,
           "S=%08X%08X%08X%08X%08X",
-          htonl(*((uint32*)(byrl_digest_1) + 0)),
-          htonl(*((uint32*)(byrl_digest_1) + 1)),
-          htonl(*((uint32*)(byrl_digest_1) + 2)),
-          htonl(*((uint32*)(byrl_digest_1) + 3)),
-          htonl(*((uint32*)(byrl_digest_1) + 4)));
+          htonl(*((uint32_t*)(byrl_digest_1) + 0)),
+          htonl(*((uint32_t*)(byrl_digest_1) + 1)),
+          htonl(*((uint32_t*)(byrl_digest_1) + 2)),
+          htonl(*((uint32_t*)(byrl_digest_1) + 3)),
+          htonl(*((uint32_t*)(byrl_digest_1) + 4)));

   return NULL;

 }

-unsigned int m_seek_comm(dsd_gather_i_1* adsp_gather, char* achp_cmp_buf, uint32 ump_pos)
+unsigned int m_seek_comm(dsd_gather_i_1* adsp_gather, char* achp_cmp_buf, uint32_t ump_pos)
 {
     // Length of current link.
-    uint32 uml_link_len = adsp_gather->achc_ginp_end - adsp_gather->achc_ginp_cur;
+    uint32_t uml_link_len = adsp_gather->achc_ginp_end - adsp_gather->achc_ginp_cur;
     // Command length remaining.
-    uint32 uml_remaining_len = 20 - ump_pos;
+    uint32_t uml_remaining_len = 20 - ump_pos;

     // If length of current link is >= than remaining command length...
     if(uml_link_len >= uml_remaining_len)
@@ -561,8 +565,10 @@
         // core
         inp_session_wtrt_sno = 0;

+#ifdef B130115
         if ((img_wsp_trace_core_flags1 & inp_core_id) == 0)
             return;
+#endif

         if (adsp_data == NULL || inp_data_len < 0) {
             inp_data_len = 0;
@@ -578,12 +584,14 @@
     } else {
         // session

+#ifdef B130115
 #ifndef B120710
         if (!(inp_session_trace_level & HL_WT_SESS_NETW))
 #else
         if (inp_session_trace_level == 0)
 #endif
             return;
+#endif

         if (adsp_data == NULL || inp_data_len < 0) {
             inp_data_len = 0;
Index: xs-gw-ppp.cpp
===================================================================
--- xs-gw-ppp.cpp	(revision 2)
+++ xs-gw-ppp.cpp	(revision 6)
@@ -1,3 +1,11 @@
+#ifdef TO_DO_130105
+ define TRY_130104_01                       /* problem solved by HSM   */
+   needed because no authentication handled out.
+   better solution:
+   call m_ppp_server_set_inetas() when sending LCP Configuration Ack
+   and no authentication
+   05.01.13  KB
+#endif
 #define NO_YET_AUTH_COMPL                   /* 03.09.12 KB - authentication not yet complete */
 #define TRY_111117_01
 #define TRACEHL1
@@ -9,6 +17,7 @@
 //#define TRY_081204_01
 #define TRY_081204_02
 #define TRY_120509_01
+#define TRY_130104_01                       /* problem solved by HSM   */
 #ifdef TRACEHL1
 #define TRACEHL_081204
 #endif
@@ -1043,6 +1052,12 @@
    if ((achl_rp + sizeof(ucrs_ctrl_lcp) + iml1) != achl_end) {  /* length is invalid */
      goto p_inv_00;                         /* packet invalid          */
    }
+#ifdef TRY_130104_01                        /* problem solved by HSM   */
+   /* KB 04.01.13 - should not be set here, should have been set before. */
+   /* this point in the program may be passed multiple times, but m_ppp_server_set_inetas() should be called only once. */
+   /* may problem because of authentication MS-CHAP-V2. */
+   m_ppp_server_set_inetas( adsp_ppp_se_1 );  /* begin IPCP            */
+#endif
    if (   (adsp_ppp_se_1->adsc_ppp_cl_1)    /* with PPP client         */
        && ((adsp_ppp_se_1->adsc_ppp_cl_1->imc_options & D_PPP_OPT_IPCP_SEND) == 0)) {  /* IPCP send INETAS not complete */
 #ifdef TRACEHL_081204
@@ -2186,7 +2201,9 @@

    m_auth_ok_40:                            /* can begin IPCP now      */
 #endif
+#ifndef TRY_130104_01                       /* problem solved by HSM   */
    m_ppp_server_set_inetas( adsp_ppp_se_1 );  /* begin IPCP            */
+#endif
    return;                                  /* all done                */
 } /* end m_auth_compl_ppp_server()                                     */
 #endif
Index: hob-tcpco1.hpp
===================================================================
--- hob-tcpco1.hpp	(revision 2)
+++ hob-tcpco1.hpp	(revision 6)
@@ -1,5 +1,19 @@
 // temporary start 19.04.12 KB
-
+/*
+  changes needed 20.11.12 KB
+  1. callback-routine amc_free_target_ineta has been removed
+  2. am_conncallback has two more parameters
+  3. m_startco_mh() has one more parameter
+  4. use new error numbers of connect callback routine,
+     result of multiple connect()
+*/
+#define TCPCOMP_ERR_BASE              70000
+#define TCPCOMP_ERR_CANCELLED         (TCPCOMP_ERR_BASE + 0)
+//#define TCPCOMP_ERR_CONN_REFUSED      (TCPCOMP_ERR_BASE + 1)
+//#define TCPCOMP_ERR_CONN_TIMEOUT      (TCPCOMP_ERR_BASE + 2)
+#define TCPCOMP_ERR_CONN_ALL_REFUSED  (TCPCOMP_ERR_BASE + 3)
+#define TCPCOMP_ERR_CONN_ALL_TIMEOUT  (TCPCOMP_ERR_BASE + 4)
+#define TCPCOMP_ERR_CONN_ALL_RF_TO    (TCPCOMP_ERR_BASE + 5)
 /**
  * AKre
  * DEBUG_POLL_TIME is a switcher for
@@ -41,7 +55,14 @@
 #include <time.h>
 #endif

+#ifdef WIN32
+#define HL_WIN
+#endif

+#ifdef WIN64
+#define HL_WIN
+#endif
+
 #ifdef HL_UNIX
 #ifdef TRACEHL1
 #define TRACE                               /* 11.08.11 KB             */
@@ -65,7 +86,7 @@
 #endif
 #define TRACE_090801_01
 //#define TRACE
-#if defined(WIN32) || defined(WIN64)
+#ifdef HL_WIN
 #ifndef TCPCOMP
 #ifndef __ccdoc__
 #define TCPCOMP
@@ -194,14 +215,16 @@
      */
     typedef struct dsd_tcpcallback {
         void (*am_connerrcallback)(dsd_tcpcomp *, void *, struct sockaddr *adsp_soa, socklen_t imp_len_soa, int imp_current_index, int imp_total_index, int imp_errno ); /* connect
failed function */
-        void (*am_conncallback)( dsd_tcpcomp *, void *, struct sockaddr *adsp_soa, socklen_t imp_len_soa, int imp_error ); /* connect callback function */
+        void (*am_conncallback)( dsd_tcpcomp *, void *, struct dsd_target_ineta_1 *adsp_server_ineta, void * ap_free_ti1, struct sockaddr *adsp_soa, socklen_t imp_len_soa, int
imp_error ); /* connect callback function */
         void (*am_sendcallback)( dsd_tcpcomp *, void * ); /* send callback function */
         int (*am_getrecvbuf)( dsd_tcpcomp *, void *, void **, char **, int ** ); /* get receive buffer callback function */
         int (*am_recvcallback)( dsd_tcpcomp *, void *, void * ); /* receive callback function */
         void (*am_errorcallback)( dsd_tcpcomp *, void *, char *, int, int ); /* error callback function */
         void (*amc_cleanup)( dsd_tcpcomp *, void * ); /* cleanup callback function */
         int (*amc_get_random_number)( int ); /* get random number       */
+#ifdef B121120
         void (*amc_free_target_ineta)( dsd_tcpcomp *, void *, const struct dsd_target_ineta_1 * ); /* free target INETA */
+#endif
     }dsd_tcpcallback_t;
     /** Pointer to a callback structure. */
     typedef dsd_tcpcallback_t* dsd_tcpcallback_p;
@@ -447,6 +470,9 @@
         inline int m_startco_mh( dsd_tcpcallback_p adsp_callback, void * vpp_userfld,
                 const struct dsd_bind_ineta_1* adsp_bind_ineta,
                 const struct dsd_target_ineta_1* adsp_target_ineta,
+#ifndef B121120
+                const void * ap_free_ti1,
+#endif
                 unsigned short usp_port,
                 BOOL bop_round_robin = FALSE );

@@ -495,6 +521,7 @@
         dsd_tcphandle ds_sock;
         /** User specific data. */
         void* ads_usrfld;
+        const void* aps_free_ti1;
         /** Corresponding thread object. */
         dsd_tcpthread_p ads_thread;
         /** Event used with this connection. */
@@ -661,6 +688,7 @@
         ads_newcon->ds_sock = ds_sock;
         ads_newcon->ads_callback = ads_callback;
         ads_newcon->ads_usrfld = ads_usrfld;
+        ads_newcon->aps_free_ti1 = NULL;
         ads_newcon->im_error = 0;
         ads_newcon->ads_findsock = NULL;
         ads_newcon->ads_findcur = NULL;
@@ -795,6 +823,7 @@
         this->ds_sock = imp_socket;
         this->ads_callback = adsp_callback;
         this->ads_usrfld = vpp_userfld;
+        this->aps_free_ti1 = NULL;
         this->im_error = 0;
         this->ads_findsock = NULL;
         this->ads_findcur = NULL;
@@ -934,6 +963,7 @@
 // this->ds_sock = imp_socket;
         this->ads_callback = adsp_callback;
         this->ads_usrfld = vpp_userfld;
+        this->aps_free_ti1 = NULL;
         this->im_error = 0;
         this->ads_findsock = NULL;
         this->ads_findcur = NULL;
@@ -1863,13 +1893,22 @@
                                     ads_thread->av_last_callbacks[ads_thread->in_cb_called] = (void*) adsl_callback->am_conncallback;
                                     ads_thread->in_cb_called = (ads_thread->in_cb_called == MAX_CB_CALLED) ? 0 : ads_thread->in_cb_called + 1;
 #endif
+#ifdef B121120
                                     adsl_callback->am_conncallback(ads_thread->dsr_tcpconn[im_conn],
                                             ads_thread->dsr_tcpconn[im_conn]->ads_usrfld, NULL, 0, 0 );
+#else
+                                    adsl_callback->am_conncallback(ads_thread->dsr_tcpconn[im_conn],
+                                        ads_thread->dsr_tcpconn[im_conn]->ads_usrfld,
+                                        (struct dsd_target_ineta_1*) &ads_thread->dsr_tcpconn[im_conn]->ads_target_ineta,
+                                        (void*) ads_thread->dsr_tcpconn[im_conn]->aps_free_ti1,
+                                        NULL, 0, 0 );
+#endif
                                 }
                                 if (ads_thread->dsr_tcpconn[im_conn]->ads_findsock) {
                                     freeaddrinfo( ads_thread->dsr_tcpconn[im_conn]->ads_findsock);
                                     ads_thread->dsr_tcpconn[im_conn]->ads_findsock = NULL;
                                 }
+#ifdef B121120
                                 if (       (adsl_callback != NULL)
                                         && (adsl_callback->amc_free_target_ineta)
                                         && (ads_thread->dsr_tcpconn[im_conn]->ads_target_ineta)) {
@@ -1882,6 +1921,7 @@
                                             ads_thread->dsr_tcpconn[im_conn]->ads_target_ineta);
                                     ads_thread->dsr_tcpconn[im_conn]->ads_target_ineta = NULL; /* do not free twice */
                                 }
+#endif
                                 break;
                                 case TRUE:
                                 {
@@ -1918,9 +1958,17 @@
                                             ads_thread->av_last_callbacks[ads_thread->in_cb_called] = (void*) adsl_callback->am_conncallback;
                                             ads_thread->in_cb_called = (ads_thread->in_cb_called == MAX_CB_CALLED) ? 0 : ads_thread->in_cb_called + 1;
 #endif
+#ifdef B121120
                                             adsl_callback->am_conncallback(ads_thread->dsr_tcpconn[im_conn],
                                                     ads_thread->dsr_tcpconn[im_conn]->ads_usrfld,
                                                     (struct sockaddr *) &dsl_sockaddr, dsl_len, im_error );
+#else
+                                            adsl_callback->am_conncallback(ads_thread->dsr_tcpconn[im_conn],
+                                                    ads_thread->dsr_tcpconn[im_conn]->ads_usrfld,
+                                                    (struct dsd_target_ineta_1*) &ads_thread->dsr_tcpconn[im_conn]->ads_target_ineta,
+                                                    (void*) ads_thread->dsr_tcpconn[im_conn]->aps_free_ti1,
+                                                    (struct sockaddr *) &dsl_sockaddr, dsl_len, im_error );
+#endif

                                         }
                                         if (ads_thread->dsr_tcpconn[im_conn]->im_ineta_curno == ads_thread->dsr_tcpconn[im_conn]->ads_target_ineta->imc_no_ineta) {
@@ -1930,7 +1978,11 @@
                                         else {
                                             closesocket(ads_thread->dsr_tcpconn[im_conn]->ds_sock);
                                             ads_thread->dsr_tcpconn[im_conn]->ds_sock = INVALID_SOCKET;
+#ifdef B121120
                                             if (ads_thread->dsr_tcpconn[im_conn]->m_startco_mh(NULL, NULL, NULL, NULL, 0) != 0)
+#else
+                                            if (ads_thread->dsr_tcpconn[im_conn]->m_startco_mh(NULL, NULL, NULL, NULL, NULL, 0) != 0)
+#endif
                                             bol_remove_entry = TRUE; /* set has to remove entry */
                                             break;
                                         }
@@ -1943,6 +1995,10 @@
 #endif
                                         adsl_callback->am_conncallback(ads_thread->dsr_tcpconn[im_conn],
                                                 ads_thread->dsr_tcpconn[im_conn]->ads_usrfld,
+#ifndef B121120
+                                                (struct dsd_target_ineta_1*) &ads_thread->dsr_tcpconn[im_conn]->ads_target_ineta,
+                                                (void*) ads_thread->dsr_tcpconn[im_conn]->aps_free_ti1,
+#endif
                                                 (struct sockaddr *) &dsl_sockaddr, dsl_len, 0 );
                                     }
                                 }
@@ -2447,6 +2503,9 @@
     int dsd_tcpcomp::m_startco_mh( dsd_tcpcallback_p adsp_callback, void * vpp_userfld,
             const dsd_bind_ineta_1* adsp_bind_ineta,
             const dsd_target_ineta_1* adsp_target_ineta,
+#ifndef B121120
+            const void * ap_free_ti1,
+#endif
             unsigned short usp_port, BOOL bop_round_robin ) {
         dsd_tcpthread_p ads_thrcur; // current thread object
         dsd_tcpthread_p ads_thrlast;// last thread in chain
@@ -2487,6 +2546,7 @@
             this->bo_fd_close = FALSE; // AG 14.04.2008
             this->ads_callback = adsp_callback;
             this->ads_usrfld = vpp_userfld;
+            this->aps_free_ti1 = ap_free_ti1;
             this->im_error = 0;
             this->ads_findsock = NULL;
             this->ads_findcur = NULL;
@@ -2629,7 +2689,11 @@
         if (im_ineta_curno < ads_target_ineta->imc_no_ineta) {
             closesocket(ds_sock);
             ds_sock = INVALID_SOCKET;
+#ifdef B121120
             iml_ret = m_startco_mh( NULL, NULL, NULL, NULL, us_port, FALSE );
+#else
+            iml_ret = m_startco_mh( NULL, NULL, NULL, NULL, NULL, us_port, FALSE );
+#endif
         }
         else
         iml_ret = -1;
@@ -2652,9 +2716,11 @@
             closesocket(ds_sock);
             CloseHandle(ds_event);
             bol_save_1 = boc_storage; /* save value */
+#ifdef B121120
             if ( (adsl_callback->amc_free_target_ineta)
                     && (ads_target_ineta))
             adsl_callback->amc_free_target_ineta(this, ads_usrfld, ads_target_ineta);
+#endif
             if (adsl_callback->amc_cleanup)
             adsl_callback->amc_cleanup(this, ads_usrfld );
             if (bol_save_1)
@@ -2886,6 +2952,7 @@
         /* should we delete the memory also? */
         bol_free = ADSL_CUR_SESSION->boc_storage;

+#ifdef B121120
         /* free ineta and call cleanup */
         if (    (adsl_callback != NULL)
              && (adsl_callback->amc_free_target_ineta)
@@ -2898,6 +2965,7 @@
                                                   ADSL_CUR_SESSION->ads_usrfld,
                                                   ADSL_CUR_SESSION->ads_target_ineta );
         }
+#endif
         if (    (adsl_callback != NULL)
              && (adsl_callback->amc_cleanup) ) {
 #ifdef DEBUG_POLL_TIME
@@ -3289,16 +3357,22 @@
     void (*am_connerrcallback)(dsd_tcpcomp *, void *, struct sockaddr *adsp_soa,
             socklen_t imp_len_soa, int imp_current_index, int imp_total_index,
             int imp_errno); /* connect failed function */
+#ifdef B121120
     void (*am_conncallback)(dsd_tcpcomp *, void *, struct sockaddr *adsp_soa,
             socklen_t imp_len_soa, int imp_error); /* connect callback function */
+#else
+    void (*am_conncallback)( dsd_tcpcomp *, void *, struct dsd_target_ineta_1 *adsp_server_ineta, void * ap_free_ti1, struct sockaddr *adsp_soa, socklen_t imp_len_soa, int imp_error
); /* connect callback function */
+#endif
     void (*am_sendcallback)(dsd_tcpcomp *, void *); /* send callback function */
     int (*am_getrecvbuf)(dsd_tcpcomp *, void *, void **, char **, int **); /* get receive buffer callback function */
     int (*am_recvcallback)(dsd_tcpcomp *, void *, void *); /* receive callback function */
     void (*am_errorcallback)(dsd_tcpcomp *, void *, char *, int, int); /* error callback function */
     void (*amc_cleanup)(dsd_tcpcomp *, void *); /* cleanup callback function */
     int (*amc_get_random_number)(int); /* get random number       */
+#ifdef B121120
     void (*amc_free_target_ineta)(dsd_tcpcomp *, void *,
             const struct dsd_target_ineta_1 *); /* free target INETA */
+#endif
 } dsd_tcpcallback_t;
 typedef dsd_tcpcallback_t* dsd_tcpcallback_p;

@@ -3515,6 +3589,9 @@
     inline int m_startco_mh(dsd_tcpcallback_p adsp_callback, void * vpp_userfld,
             const struct dsd_bind_ineta_1* adsp_bind_ineta,
             const struct dsd_target_ineta_1* adsp_target_ineta,
+#ifndef B121121
+            const void * ap_free_ti1,
+#endif
             unsigned short usp_port, BOOL bop_round_robin = FALSE);
     /**
      *  disable/enable the Naegle Algorithm
@@ -3570,6 +3647,7 @@
     dsd_tcphandle ds_sock;
     /** User specific data. */
     void* ads_usrfld;
+    const void* aps_free_ti1;
     /** Corresponding thread object. */
     dsd_tcpthread_p ads_thread;
     /** Notify that send is possible. */
@@ -3682,6 +3760,7 @@
     ads_newcon->ds_sock = ds_sock;
     ads_newcon->ads_callback = ads_callback;
     ads_newcon->ads_usrfld = ads_usrfld;
+    ads_newcon->aps_free_ti1 = NULL;
     ads_newcon->im_error = 0;
     ads_newcon->ads_findsock = 0;
     ads_newcon->ads_findcur = 0;
@@ -3834,6 +3913,7 @@
     this->ds_sock = imp_socket;
     this->ads_callback = adsp_callback;
     this->ads_usrfld = vpp_userfld;
+    this->aps_free_ti1 = NULL;
     this->im_error = 0;
     this->ads_findsock = NULL;
     this->ads_findcur = NULL;
@@ -3905,7 +3985,7 @@
 int dsd_tcpcomp::m_startco_bind_conn_fix(dsd_tcpcallback_p adsp_callback,
         void * vpp_userfld, struct sockaddr *adsp_bind, socklen_t iml_len_bind,
         struct sockaddr *adsp_connect, socklen_t iml_len_connect) {
-       
+
         int iml_rc; /* return code             */
         dsd_tcpthread_p ads_thrcur; // current thread object
         dsd_tcpthread_p ads_thrlast;// last thread in chain
@@ -3934,13 +4014,14 @@
         // this->ds_sock = imp_socket;
         this->ads_callback = adsp_callback;
         this->ads_usrfld = vpp_userfld;
+        this->aps_free_ti1 = NULL;
         this->im_error = 0;
         this->ads_findsock = NULL;
         this->ads_findcur = NULL;
-       
+
         this->ds_sock = socket ( adsp_connect->sa_family, SOCK_STREAM, IPPROTO_TCP );
-       
-        if ( fcntl( ds_sock, F_SETFL, O_NONBLOCK ) != 0 ) //Set socket to non-blocking mod 
+
+        if ( fcntl( ds_sock, F_SETFL, O_NONBLOCK ) != 0 ) //Set socket to non-blocking mod
         {
 #ifdef TRACE
         m_hlnew_printf(123, "Unable to set socket to non-blocking operation: %d\n", errno);
@@ -3995,7 +4076,7 @@
 #ifndef HL_SOLARIS
             | POLLOUT
 #endif
-            ;       
+            ;
         ads_thrcur->dsr_waitevent[ads_thrcur->im_concount + 1].revents = 0;
         ads_thrcur->dsr_tcpconn[ads_thrcur->im_concount + 1] = this;
         ads_thrcur->im_concount++;
@@ -4004,8 +4085,8 @@
         m_hlnew_printf(123, "hob-tcpco1.hpp l%05d m_startco_bind_conn_fix() ads_thrcur=%p im_concount=%d\n",
                 __LINE__, ads_thrcur, ads_thrcur->im_concount );
 #endif
-        write( ads_thrcur->imr_pipefd[1], &ads_thrcur, sizeof(ads_thrcur) ); // Tell thread to handle this
-       
+        write( ads_thrcur->imr_pipefd[1], &ads_thrcur, sizeof(ads_thrcur) ); // Tell thread to handle this
+
         if (iml_len_bind > 0) {
             iml_rc = bind( this->ds_sock, adsp_bind, iml_len_bind );
 			if ( iml_rc != 0 ) {
@@ -4019,7 +4100,7 @@
         memcpy( &this->dsc_soa_connect, adsp_connect, iml_len_connect );
         iml_rc = connect( this->ds_sock, adsp_connect, iml_len_connect );
 		if ( iml_rc == 0 ) {
-       
+
         } else {
             iml_rc = errno;
             if ( iml_rc != EWOULDBLOCK && iml_rc != EINPROGRESS ) {
@@ -4034,7 +4115,7 @@
                 }
 				return 6;
 			}
-           
+
 		}
     return 0;
 } /* end dsd_tcpcomp::m_startco_bind_conn_fix()                        */
@@ -4124,7 +4205,7 @@
     adsl_callback = this->ads_callback;
     if ( adsl_callback == NULL )
         return;
-    boc_end = TRUE; /* end has been set        */   
+    boc_end = TRUE; /* end has been set        */
     write( ads_thread->imr_pipefd[1], &ads_thread, sizeof(ads_thread) ); // Tell thread to handle this connection
 } /* end dsd_tcpcomp::m_end_session()                                  */

@@ -4667,6 +4748,9 @@
                 ads_callback->am_conncallback(this, ads_usrfld, NULL, 0, 0 );
 #else
                 ads_callback->am_conncallback( this, ads_usrfld,
+#ifndef B121120
+                        (struct dsd_target_ineta_1*)&adsc_target_ineta, (void*)aps_free_ti1,
+#endif
                         (struct sockaddr *) &this->dsc_soa_connect, iml_soa_len,
                         0 );
 #endif
@@ -4754,7 +4838,11 @@
                 } else {
                     close( ds_sock );
                     ds_sock = INVALID_SOCKET;
+#ifdef B121121
                     if ( m_startco_mh( NULL, NULL, NULL, NULL, 0, FALSE ) != 0 )
+#else
+                    if ( m_startco_mh( NULL, NULL, NULL, NULL, NULL, 0, FALSE ) != 0 )
+#endif
                         bol_remove_entry = TRUE; /* set has to remove entry */
                     break;
                 }
@@ -4769,6 +4857,10 @@
                         (struct sockaddr *) &dsl_sockaddr, dsl_len, 0 );
 #else
                 ads_callback->am_conncallback( this, ads_usrfld,
+#ifndef B121120
+                        (struct dsd_target_ineta_1*) &adsc_target_ineta,
+                        (void*) aps_free_ti1,
+#endif
                         (struct sockaddr *) &this->dsc_soa_connect, iml_soa_len,
                         0 );
 #endif
@@ -4840,19 +4932,21 @@
         }
         m_hlnew_printf(123, "TRACEEND-------------------\n");
 #endif
+#ifdef TRACE
         if ( ads_thread->bo_cleanup ) {
             m_hlnew_printf(123, "Cleanup requested\n" );
             break;
         }
+#endif
 #ifdef TRACE
         m_hlnew_printf(123, "poll returned with %d\n", im_waitret);
-#endif
         if ( im_waitret <= 0 ) {
             m_hlnew_printf(123, "Poll error %d or nothing received? %d\n", errno,
                     im_waitret );
             sleep( 1 );
             continue;
         }
+#endif

         im_conn = 0;
         do {
@@ -4893,7 +4987,7 @@
 #ifdef TRACE
                                     m_hlnew_printf(123, "Close Event handle\n");
 #endif
-                                    if ( ads_stop->bo_close ) {                                       
+                                    if ( ads_stop->bo_close ) {
                                         close(
                                                 ads_thread->dsr_tcpconn[im_index]->ds_sock );
 										ads_thread->dsr_tcpconn[im_index]->ds_sock = INVALID_SOCKET;
@@ -5044,12 +5138,14 @@
                                 close( ads_thread->dsr_tcpconn[im_index]->ds_sock );
 								ads_thread->dsr_tcpconn[im_index]->ds_sock = INVALID_SOCKET;
                                 bol_save_1 = ads_thread->dsr_tcpconn[im_index]->boc_storage; /* save value */
+#ifdef B121120
                                 if (    (adsl_callback->amc_free_target_ineta)
                                      && (ads_thread->dsr_tcpconn[im_index]->adsc_target_ineta) )
                                     adsl_callback->amc_free_target_ineta(
                                             ads_thread->dsr_tcpconn[im_index],
                                             ads_thread->dsr_tcpconn[im_index]->ads_usrfld,
                                             (struct dsd_target_ineta_1 *) ads_thread->dsr_tcpconn[im_index]->adsc_target_ineta );
+#endif
                                 if ( adsl_callback->amc_cleanup ) {
                                     adsl_callback->amc_cleanup(
                                             ads_thread->dsr_tcpconn[im_index],
@@ -5144,12 +5240,14 @@
 							ads_thread->dsr_tcpconn[im_conn]->ds_sock = INVALID_SOCKET;
                             bol_save_1 =
                                     ads_thread->dsr_tcpconn[im_conn]->boc_storage; /* save value */
+#ifdef B121120
                             if (    (adsl_callback->amc_free_target_ineta)
                                  && (ads_thread->dsr_tcpconn[im_conn]->adsc_target_ineta) )
                                 adsl_callback->amc_free_target_ineta(
                                         ads_thread->dsr_tcpconn[im_conn],
                                         ads_thread->dsr_tcpconn[im_conn]->ads_usrfld,
                                         (struct dsd_target_ineta_1 *) ads_thread->dsr_tcpconn[im_conn]->adsc_target_ineta );
+#endif
                             if ( adsl_callback->amc_cleanup ) {
                                 adsl_callback->amc_cleanup(
                                         ads_thread->dsr_tcpconn[im_conn],
@@ -5238,6 +5336,10 @@
                                         adsl_callback->am_conncallback(
                                                 ADSL_TCPCO_G,
                                                 ADSL_TCPCO_G->ads_usrfld,
+#ifndef B121120
+                                                (struct dsd_target_ineta_1*) &ADSL_TCPCO_G->adsc_target_ineta,
+                                                (void*)ADSL_TCPCO_G->aps_free_ti1,
+#endif
                                                 (struct sockaddr *) &ADSL_TCPCO_G->dsc_soa_connect,
                                                 iml_soa_len, 0 );
 #undef ADSL_TCPCO_G
@@ -5266,6 +5368,10 @@
                                         adsl_callback->am_conncallback(
                                                 ads_thread->dsr_tcpconn[im_conn],
                                                 ads_thread->dsr_tcpconn[im_conn]->ads_usrfld,
+#ifndef B121120
+                                                (struct dsd_target_ineta_1*)&ads_thread->dsr_tcpconn[im_conn]->adsc_target_ineta,
+                                                (void*)ads_thread->dsr_tcpconn[im_conn]->aps_free_ti1,
+#endif
                                                 (struct sockaddr *) &dsl_sockaddr,
                                                 dsl_len, 0 );
                                     }
@@ -5383,7 +5489,13 @@

 int dsd_tcpcomp::m_startco_mh(dsd_tcpcallback_p adsp_callback,
         void * vpp_userfld, const dsd_bind_ineta_1* adsp_bind_ineta,
+#ifdef B121121
         const dsd_target_ineta_1* adsp_target_ineta, unsigned short usp_port,
+#else
+        const dsd_target_ineta_1* adsp_target_ineta,
+        const void * ap_free_ti1,
+        unsigned short usp_port,
+#endif
         BOOL bop_round_robin) {
 #ifdef DEF_EPOLL
     if (dsd_tcpcomp::boc_epoll)
@@ -5436,6 +5548,7 @@
 #endif
         this->ads_callback = adsp_callback;
         this->ads_usrfld = vpp_userfld;
+        this->aps_free_ti1 = ap_free_ti1;
         this->im_error = 0;
         this->ads_findsock = NULL;
         this->ads_findcur = NULL;
@@ -5602,7 +5715,11 @@
             m_hlnew_printf(123, "error close on sock %d\n", ds_sock);
 #endif
         }
+#ifdef B121121
         iml_ret = m_startco_mh( NULL, NULL, NULL, NULL, usc_port, FALSE );
+#else
+        iml_ret = m_startco_mh( NULL, NULL, NULL, NULL, NULL, usc_port, FALSE );
+#endif
     } else
         iml_ret = -1;

@@ -5621,9 +5738,11 @@
         ads_callback = NULL;
         close( ds_sock );
         bol_save_1 = boc_storage; /* save value */
+#ifdef B121120
         if ( (adsl_callback->amc_free_target_ineta) && (adsc_target_ineta) )
             adsl_callback->amc_free_target_ineta( this, ads_usrfld,
                     (struct dsd_target_ineta_1 *) adsc_target_ineta );
+#endif
         if ( adsl_callback->amc_cleanup )
             adsl_callback->amc_cleanup( this, ads_usrfld );

Index: comp-LINUX-nbipgw19-d2
===================================================================
--- comp-LINUX-nbipgw19-d2	(revision 2)
+++ comp-LINUX-nbipgw19-d2	(revision 6)
@@ -1,5 +1,5 @@
 g++ -m32 -g -c -Wno-write-strings -I. -DHL_UNIX -DHL_LINUX -DTRACEHL1 nbipgw19.cpp -o nbipgw19.o
 g++ -m32 -g -c -Wno-write-strings -I. -DHL_UNIX xslunic1.cpp -o xslunic1.o
-g++ -m32 -g -c -Wno-write-strings -I. -DHL_UNIX nsl-tcpcomp-singthr.cpp -o nsl-tcpcomp-singthr.o
+g++ -m32 -g -c -Wno-write-strings -I. -DHL_UNIX -DTRACEHL1 nsl-tcpcomp-singthr.cpp -o nsl-tcpcomp-singthr.o
 g++ -m32 -g -c -Wno-write-strings -I. -DHL_UNIX xs-encry-1.c -o xs-encry-1.o
 g++ -m32 -g -L/usr/local/lib32 -lrt nbipgw19.o xslunic1.o nsl-tcpcomp-singthr.o xs-encry-1.o -o nbipgw19
Index: nsl-tcpcomp-singthr.cpp
===================================================================
--- nsl-tcpcomp-singthr.cpp	(revision 2)
+++ nsl-tcpcomp-singthr.cpp	(revision 6)
@@ -10,6 +10,7 @@
 /*| ----------                                                        |*/
 /*|  Copyright (C) HOB Germany 2010                                   |*/
 /*|  Copyright (C) HOB Germany 2011                                   |*/
+/*|  Copyright (C) HOB Germany 2012                                   |*/
 /*|                                                                   |*/
 /*+-------------------------------------------------------------------+*/

@@ -196,6 +197,9 @@

    this->boc_cb_active = FALSE;             /* callback routine is active */
    this->boc_do_close = FALSE;              /* do close                */
+#ifdef D_INCL_UNIX_SOCKET
+   this->boc_unix_socket = FALSE;           /* is not Unix socket      */
+#endif
    this->adsc_callback = adsp_callback;
    this->vpc_userfld = vpp_userfld;
    this->imc_conn_no = -1;                  /* number of connect       */
@@ -223,6 +227,7 @@

    this->boc_cb_active = FALSE;             /* callback routine is active */
    this->boc_do_close = FALSE;              /* do close                */
+   this->boc_unix_socket = TRUE;            /* is Unix socket          */
    this->adsc_callback = adsp_callback;
    this->vpc_userfld = vpp_userfld;
    this->imc_conn_no = -1;                  /* number of connect       */
@@ -257,6 +262,9 @@
 #endif
    this->boc_cb_active = FALSE;             /* callback routine is active */
    this->boc_do_close = FALSE;              /* do close                */
+#ifdef D_INCL_UNIX_SOCKET
+   this->boc_unix_socket = FALSE;           /* is not Unix socket      */
+#endif
    this->adsc_callback = adsp_callback;
    this->vpc_userfld = vpp_userfld;
    this->adsc_target_ineta = (struct dsd_target_ineta_1 *) adsp_target_ineta;
@@ -284,9 +292,9 @@
    iel_rcc = m_sub_conn_start( this, iml1 );
    switch (iel_rcc) {                       /* returned from TCP connect() */
      case ied_rcc_ok:                       /* connect done            */
-		   adsc_callback->amc_conncallback( this,
-										  vpc_userfld,
-										  (struct sockaddr *) &dsc_soa_conn, imc_len_soa_conn, 0 );
+       adsc_callback->amc_conncallback( this,
+                                        vpc_userfld,
+                                        (struct sockaddr *) &dsc_soa_conn, imc_len_soa_conn, 0 );
        return 0;                            /* return success, no error */
      case ied_rcc_block:                    /* connect is blocking     */
        return 0;                            /* return success, no error */
@@ -509,7 +517,7 @@
      adsp_tcpcomp->adsc_callback->amc_errorcallback(adsp_tcpcomp, adsp_tcpcomp->vpc_userfld, (char*)"Error creating socket", errno, ERRORAT_STARTCONN); // AGAG

 #ifdef TRACEHL1
-     m_hl1_printf( "xbttcp62-%05d-E socket() failed with code %d %d.",
+     m_hl1_printf( "nsl-tcpcomp-singthr-%05d-E socket() failed with code %d %d.",
                    __LINE__, iml_socket, D_TCP_ERROR );
 #endif
      return ied_rcc_error_socket;           /* error from socket       */
@@ -524,7 +532,7 @@
      if (iml_rc != 0) {                     /* error occured           */
 // to-do 15.06.10 KB call error routine
 #ifdef TRACEHL1
-       m_hl1_printf( "xbttcp45-%05d-W bind GW-OUT Error %d %d",
+       m_hl1_printf( "nsl-tcpcomp-singthr-%05d-W bind GW-OUT Error %d %d",
                      __LINE__, iml_rc, D_TCP_ERROR );
 #endif
        D_TCP_CLOSE( iml_socket );           /* close socket again      */
@@ -554,19 +562,51 @@
    if (errno == EINPROGRESS) return ied_rcc_block;  /* connect is blocking */
 #ifdef TRACEHL1
    iml_save_errno = errno;
-   m_hl1_printf( "xbttcp62-%05d-W connect() Error %d %d.",
+   m_hl1_printf( "nsl-tcpcomp-singthr-%05d-W connect() Error %d %d.",
                  __LINE__, iml_rc, D_TCP_ERROR );
    errno = iml_save_errno;                  /* restore errno           */
 #endif
-   adsp_tcpcomp->adsc_callback->amc_connerrcallback(adsp_tcpcomp, adsp_tcpcomp->vpc_userfld,
-					   (struct sockaddr *) &adsp_tcpcomp->dsc_soa_conn,
-						adsp_tcpcomp->imc_len_soa_conn,
-						adsp_tcpcomp->imc_conn_no, adsp_tcpcomp->adsc_target_ineta->imc_no_ineta, errno);
-	
+   adsp_tcpcomp->adsc_callback->amc_connerrcallback( adsp_tcpcomp, adsp_tcpcomp->vpc_userfld,
+                                                     (struct sockaddr *) &adsp_tcpcomp->dsc_soa_conn,
+                                                     adsp_tcpcomp->imc_len_soa_conn,
+                                                     adsp_tcpcomp->imc_conn_no, adsp_tcpcomp->adsc_target_ineta->imc_no_ineta, errno );
    D_TCP_CLOSE( iml_socket );               /* close socket again      */
    return ied_rcc_error_conn;               /* error from connect      */
 } /* end m_sub_conn_start()                                            */

+#ifdef D_INCL_UNIX_SOCKET
+/** retrieve file-descriptor passed with last message received over Unix socket connection */
+int dsd_tcpcomp::m_get_unix_socket_fd( void ) {
+#ifdef MSGHDR_CONTROL_AVAILABLE
+   struct cmsghdr *adsl_cmd;
+#endif
+
+#ifdef MSGHDR_CONTROL_AVAILABLE
+   adsl_cmd = CMSG_FIRSTHDR( &this->dsc_msghdr );
+   if (   (adsl_cmd == NULL)
+       || (adsl_cmd->cmsg_len != CMSG_LEN(sizeof(int)))
+       || (adsl_cmd->cmsg_level != SOL_SOCKET)
+       || (adsl_cmd->cmsg_type != SCM_RIGHTS)) {
+#ifdef XYZ1
+     m_hlnew_printf( HLOG_WARN1, "HWSPM167W nbipgw20 l%05d listen-gateway recvmsg() no descriptor in message",
+                     __LINE__ );
+#endif
+     return -1;                             /* return error            */
+   }
+   return *((int *) CMSG_DATA( adsl_cmd ));
+#else
+   if (this->dsc_msghdr.msg_accrightslen != sizeof(int)) {
+#ifdef XYZ1
+     m_hlnew_printf( HLOG_WARN1, "HWSPM167W nbipgw20 l%05d listen-gateway recvmsg() no descriptor in message",
+                     __LINE__ );
+#endif
+     return -1;                             /* return error            */
+   }
+   return this->imc_msg_fd;                 /* file-descriptor received */
+#endif
+} /* end m_get_unix_socket_fd()                                        */
+#endif
+
 /** callback event POLL for TCPCOMP                                    */
 static void m_pc_tc_poll( struct dsd_sithr_poll_1 *adsp_sp1 ) {
    void *     vpl_handle;                   /* handle to receive buffer */
@@ -587,10 +627,20 @@
    int        iml1;                         /* working variable        */
    enum ied_ret_conn iel_rcc;               /* returned from TCP connect() */
    class dsd_tcpcomp *adsl_tcpcomp;
+#ifdef D_INCL_UNIX_SOCKET
+   struct iovec dsrl_iov[1];                /* vector containing send data */
+#ifdef MSGHDR_CONTROL_AVAILABLE
+   union {
+     struct cmsghdr dsc_msg;
+     char chrc_control[ CMSG_SPACE(sizeof(int)) ];
+   } dsl_control_un;
+   struct cmsghdr *adsl_cmd;
+#endif
+#endif

 #ifdef TRACEHL1
-   m_hl1_printf( "nsl-tcpcomp-singthr-%05d-T called m_pc_tc_poll()",
-                 __LINE__ );
+   m_hl1_printf( "nsl-tcpcomp-singthr-%05d-T called m_pc_tc_poll( adsp_sp1=%p )",
+                 __LINE__, adsp_sp1 );
 #endif
    adsl_tcpcomp = (class dsd_tcpcomp *) ((char *) adsp_sp1 - offsetof( class dsd_tcpcomp, dsc_sithr_poll_1 ));
    if ((adsp_sp1->adsc_pollfd->revents & POLLIN) == 0) {
@@ -615,15 +665,43 @@
      adsl_tcpcomp->dsc_sithr_poll_1.adsc_pollfd->events &= -1 - POLLIN;
      return;
    }
+#ifdef D_INCL_UNIX_SOCKET
+   if (adsl_tcpcomp->boc_unix_socket == FALSE) {  /* is not Unix socket */
+     goto p_recv_20;                        /* receive normal          */
+   }
+#ifdef MSGHDR_CONTROL_AVAILABLE
+   adsl_tcpcomp->dsc_msghdr.msg_control = dsl_control_un.chrc_control;
+   adsl_tcpcomp->dsc_msghdr.msg_controllen = sizeof(dsl_control_un.chrc_control);
+#else
+   adsl_tcpcomp->imc_msg_fd = -1;           /* file-descriptor received invalid */
+   adsl_tcpcomp->dsc_msghdr.msg_accrights = (caddr_t) &adsl_tcpcomp->imc_msg_fd;
+   adsl_tcpcomp->dsc_msghdr.msg_accrightslen = sizeof(int);
+#endif
+   adsl_tcpcomp->dsc_msghdr.msg_name = NULL;
+   adsl_tcpcomp->dsc_msghdr.msg_namelen = 0;
+   dsrl_iov[0].iov_base = achl_buffer;
+   dsrl_iov[0].iov_len = iml_bufferlen;
+   adsl_tcpcomp->dsc_msghdr.msg_iov = dsrl_iov;
+   adsl_tcpcomp->dsc_msghdr.msg_iovlen = 1;
+
+   iml_received = recvmsg( adsl_tcpcomp->dsc_sithr_poll_1.adsc_pollfd->fd, &adsl_tcpcomp->dsc_msghdr, 0 );
+   goto p_recv_40;                          /* after receive           */
+
+   p_recv_20:                               /* receive normal          */
+#endif
    iml_received = recv( adsl_tcpcomp->dsc_sithr_poll_1.adsc_pollfd->fd,
                         achl_buffer, iml_bufferlen,
                         0 );
+
+#ifdef D_INCL_UNIX_SOCKET
+   p_recv_40:                               /* after receive           */
+#endif
    *aiml_datalen = iml_received;            /* pass length received    */
    if (iml_received <= 0) {                 /* error occured           */
      adsl_tcpcomp->boc_do_close = TRUE;     /* do close                */
-	   if (iml_received < 0) {
-		   adsl_tcpcomp->adsc_callback->amc_errorcallback(adsl_tcpcomp, adsl_tcpcomp->vpc_userfld, "Error receiving data", errno, ERRORAT_RECV); // AGAG
-	   }
+     if (iml_received < 0) {
+       adsl_tcpcomp->adsc_callback->amc_errorcallback(adsl_tcpcomp, adsl_tcpcomp->vpc_userfld, "Error receiving data", errno, ERRORAT_RECV); // AGAG
+     }
 // to-do 04.06.10 KB error message
 #ifdef XYZ1
      bol_close = TRUE;                      /* has to do close         */
Index: xs-gw-l2tp.cpp
===================================================================
--- xs-gw-l2tp.cpp	(revision 2)
+++ xs-gw-l2tp.cpp	(revision 6)
@@ -3,7 +3,8 @@
 send to client:
 enum ied_charset iec_chs_ppp;            /* character set PPP       */
 #endif
-#define HPPPT1_V14_RECV                     /* 31.08.12 KB HOB-PPP-T1 V1.4 receive */
+//#define HPPPT1_V14_RECV                     /* 31.08.12 KB HOB-PPP-T1 V1.4 receive */
+//#define HPPPT1_V21                          /* 03.12.12 KB HOB-PPP-T1 V2.1 */
 //#define TRY_090424
 //#define TRACEHL1
 /*+-------------------------------------------------------------------+*/
@@ -20,6 +21,7 @@
 /*|  Copyright (C) HOB Germany 2010                                   |*/
 /*|  Copyright (C) HOB Germany 2011                                   |*/
 /*|  Copyright (C) HOB Germany 2012                                   |*/
+/*|  Copyright (C) HOB Germany 2013                                   |*/
 /*|                                                                   |*/
 /*| EXPECTED INPUT:                                                   |*/
 /*| ---------------                                                   |*/
@@ -189,6 +191,7 @@
 #define DEF_SEND_IOV           32           /* for WSASendTo() or sendmsg() */
 #define D_POS_IPV4_H_PROT      9            /* position protocol in IPV4 header */
 #define D_POS_IPV6_H_NEXT      6            /* position type next header in IPV6 header */
+#define D_LEN_HEADER_IPV6      40           /* length of IPV6 header   */

 /*+-------------------------------------------------------------------+*/
 /*| Internal used structures.                                         |*/
@@ -542,7 +545,9 @@
 #endif
 #ifndef B100316
 static const unsigned char ucrs_send_response_start_1[] = {
+#ifndef HPPPT1_V21                          /* 03.12.12 KB HOB-PPP-T1 V2.1 */
    '0',                                     /* control channel         */
+#endif
    'R', 'E', 'S', 'P', 'O', 'N', 'S', 'E', '-', 'S', 'T', 'A', 'R', 'T', ' ',
    'T', 'U', 'N', 'N', 'E', 'L', '-', 'I', 'D',
    '='                                      /* variable follows        */
@@ -561,6 +566,7 @@
 };
 #endif

+#ifndef HPPPT1_V21                          /* 03.12.12 KB HOB-PPP-T1 V2.1 */
 static const unsigned char ucrs_send_stop[] = {
    1 + 4,
    '0',                                     /* control channel         */
@@ -572,7 +578,21 @@
    '0',                                     /* control channel         */
    'N', 'O', 'P'
 };
+#endif
+#ifdef HPPPT1_V21                           /* 03.12.12 KB HOB-PPP-T1 V2.1 */
+static const unsigned char ucrs_send_stop[] = {
+   '0',                                     /* control channel         */
+   4,                                       /* length                  */
+   'S', 'T', 'O', 'P'
+};

+static const unsigned char ucrs_send_nop[] = {
+   '0',                                     /* control channel         */
+   3,                                       /* length                  */
+   'N', 'O', 'P'
+};
+#endif
+
 /* this PPP control header part is forbidden                           */
 static const unsigned char ucrs_send_ppp_header[] = {
    0XFF, 0X03, 0X00
@@ -786,9 +806,14 @@
    iel_state_recvc = ied_str_wait_cr;       /* state of received from client */
    achl_out = chrl_work_1;                  /* start output word       */
    if (adsp_l2tp_session->boc_rec_eye_catcher) {  /* first record received  */
+#ifndef HPPPT1_V21                          /* 03.12.12 KB HOB-PPP-T1 V2.1 */
      iel_state_recvc = ied_str_len_nhasn;   /* process length in NHASN */
      iml_len = 0;                           /* clear length            */
      iml1 = 4;                              /* maximum number of digits */
+#endif
+#ifdef HPPPT1_V21                           /* 03.12.12 KB HOB-PPP-T1 V2.1 */
+     iel_state_recvc = ied_str_control;     /* process control character */
+#endif
    }
    iel_corc = ied_corc_invalid;             /* nothing set yet         */
    iml_tunnel_id = 0;                       /* clear decoded tunnel-id */
@@ -829,9 +854,14 @@
            m_hpppt1_proc_tcp_header( adsp_l2tp_session, chrl_work_1, achl_out - chrl_work_1 );
            adsp_l2tp_session->boc_rec_header = TRUE;  /* now header first record received */
          }
+#ifndef HPPPT1_V21                          /* 03.12.12 KB HOB-PPP-T1 V2.1 */
          iel_state_recvc = ied_str_len_nhasn;  /* process length in NHASN */
          iml_len = 0;                       /* clear length            */
          iml1 = 4;                          /* maximum number of digits */
+#endif
+#ifdef HPPPT1_V21                           /* 03.12.12 KB HOB-PPP-T1 V2.1 */
+         iel_state_recvc = ied_str_control;  /* process control character */
+#endif
          achl1++;                           /* this character has been processed */
          goto p_wi_scan_20;                 /* search character        */
        }
@@ -845,6 +875,7 @@
        iel_state_recvc = ied_str_wait_cr;   /* wait for carriage-return again */
        *achl_out++ = *achl1++;              /* copy this character     */
        goto p_wi_scan_20;                   /* search character        */
+#ifndef HPPPT1_V21                          /* 03.12.12 KB HOB-PPP-T1 V2.1 */
      case ied_str_len_nhasn:                /* process length in NHASN */
        iml_len <<= 8;                       /* shift old value length  */
        iml_len |= *achl1 & 0X7F;            /* apply new bits          */
@@ -866,6 +897,30 @@
        achl_out = chrl_work_1;              /* start output word       */
        achl1++;                             /* next character          */
        goto p_wi_scan_20;                   /* search character        */
+#endif
+#ifdef HPPPT1_V21                           /* 03.12.12 KB HOB-PPP-T1 V2.1 */
+     case ied_str_control:                  /* process control character */
+       if (*achl1 != '0') goto p_wi_scan_err;  /* error in datastream  */
+       achl1++;                             /* next character          */
+       iel_state_recvc = ied_str_len_nhasn;   /* process length in NHASN */
+       iml_len = 0;                         /* clear length            */
+       iml1 = 4;                            /* maximum number of digits */
+       goto p_wi_scan_20;                   /* search character        */
+     case ied_str_len_nhasn:                /* process length in NHASN */
+       iml_len <<= 8;                       /* shift old value length  */
+       iml_len |= *achl1 & 0X7F;            /* apply new bits          */
+       iml1--;                              /* decrement number of digits */
+       if ((signed char) *achl1 < 0) {      /* more bit set            */
+         if (iml1 <= 0) goto p_wi_scan_err;  /* error in datastream    */
+         achl1++;                           /* next character          */
+         goto p_wi_scan_20;                 /* search character        */
+       }
+       if (iml_len <= 0) goto p_wi_scan_err;  /* error in datastream   */
+       iel_state_recvc = ied_str_word_01;   /* process first word      */
+       achl_out = chrl_work_1;              /* start output word       */
+       achl1++;                             /* next character          */
+       goto p_wi_scan_20;                   /* search character        */
+#endif
      case ied_str_word_01:                  /* process first word      */
        if (*achl1 != ' ') {                 /* real character found    */
          if (achl_out >= (chrl_work_1 + sizeof(chrl_work_1))) {  /* output word too long */
@@ -1194,6 +1249,9 @@
      if (iml1 == 0) break;                  /* end of output           */
      chl_more = (unsigned char) 0X80;       /* set more bit            */
    }
+#ifdef HPPPT1_V21                           /* 03.12.12 KB HOB-PPP-T1 V2.1 */
+   *(--achl_buf_w1) = (unsigned char) '0';  /* control character       */
+#endif
    ADSL_GAI1_G->achc_ginp_cur = achl_buf_w1;
    ADSL_GAI1_G->adsc_next = NULL;           /* clear chain             */
    adsl_sdhc1_w1->adsc_gather_i_1_i = ADSL_GAI1_G;  /* gather input data */
@@ -1510,11 +1568,17 @@
    struct dsd_gather_i_1 *adsl_gai1_w1;     /* working variable        */
    struct dsd_gather_i_1 *adsl_gai1_w2;     /* working variable        */
    struct dsd_l2tp_conn_1 *adsl_l2tpc1;     /* for L2TP UDP connection */
+#ifndef HPPPT1_V21                          /* 03.12.12 KB HOB-PPP-T1 V2.1 */
    struct dsd_gather_i_1 dsl_gai1_sub;      /* data to pass to subroutine */
 #ifdef HPPPT1_V14_RECV                      /* 31.08.12 KB HOB-PPP-T1 V1.4 receive */
    struct dsd_gather_i_1 dsl_gai1_sub_1;    /* data to pass to subroutine */
    struct dsd_gather_i_1 dsl_gai1_sub_2;    /* data to pass to subroutine */
 #endif
+#endif
+#ifdef HPPPT1_V21                           /* 03.12.12 KB HOB-PPP-T1 V2.1 */
+   struct dsd_gather_i_1 dsl_gai1_sub_1;    /* data to pass to subroutine */
+   struct dsd_gather_i_1 dsl_gai1_sub_2;    /* data to pass to subroutine */
+#endif
 #ifdef OLD01
    struct dsd_ppp_subr_1 dsl_ppps1;         /* request PPP subroutine */
 #endif
@@ -1526,11 +1590,15 @@
 #endif
    struct iovec dsrl_iov[ DEF_SEND_IOV ];   /* buffer for sendmsg()    */
 #endif
+#ifndef HPPPT1_V21                          /* 03.12.12 KB HOB-PPP-T1 V2.1 */
 #ifndef HPPPT1_V14_RECV                     /* 31.08.12 KB HOB-PPP-T1 V1.4 receive */
    char       chrl_l2tp_header[ D_LEN_L2TP_HEADER + 1 ];  /* L2TP header */
 #else
    char       chrl_l2tp_header[ D_LEN_L2TP_HEADER + 2 ];  /* L2TP header */
 #endif
+#else
+   char       chrl_l2tp_header[ D_LEN_L2TP_HEADER + 1 + 6 ];  /* L2TP header */
+#endif
    char       chrl_work_1[ 1024 ];          /* work area               */

 #ifdef TRACEHL1
@@ -1551,8 +1619,12 @@
 #endif
    adsl_gai1_w1 = adsp_gai1;                /* chain of receive buffers */
    achl1 = adsl_gai1_w1->achc_ginp_cur;     /* get start of buffer     */
+#ifndef HPPPT1_V21                          /* 03.12.12 KB HOB-PPP-T1 V2.1 */
    iml_remainder = 0;                       /* remaining length packet */
    iml1 = 4;                                /* characters NHASN maximum */
+#endif
+#ifdef HPPPT1_V21                           /* 03.12.12 KB HOB-PPP-T1 V2.1 */
+#endif

    p_rec_00:                                /* scan length             */
    if (achl1 >= adsl_gai1_w1->achc_ginp_end) {  /* at end of buffer    */
@@ -1560,6 +1632,7 @@
      if (adsl_gai1_w1 == NULL) goto p_ret_00;  /* needs more data      */
      achl1 = adsl_gai1_w1->achc_ginp_cur;   /* get start of buffer     */
    }
+#ifndef HPPPT1_V21                          /* 03.12.12 KB HOB-PPP-T1 V2.1 */
    iml_remainder <<= 7;                     /* shift old bits          */
    iml_remainder |= *achl1 & 0X7F;          /* apply new bits          */
    if ((signed char) *achl1 < 0) {          /* more bit set            */
@@ -1580,6 +1653,66 @@
    if (iml_remainder <= 0) goto p_rec_err;  /* data received invalid   */
    iml_no_iov = 1;                          /* number of WSABUF / vector */
    iml_len_packet = D_LEN_L2TP_HEADER + iml_remainder;  /* length of packet */
+#endif
+#ifdef HPPPT1_V21                           /* 03.12.12 KB HOB-PPP-T1 V2.1 */
+   chl_type = *achl1++;                     /* type received           */
+   if ((chl_type & 0XFE) == 0X30) {         /* 0X30 '0' and 0X31 '1'   */
+     iml_remainder = 0;                     /* remaining length packet */
+     iml1 = 4;                              /* characters NHASN maximum */
+     while (TRUE) {                         /* loop                    */
+       if (achl1 >= adsl_gai1_w1->achc_ginp_end) {  /* at end of buffer */
+         adsl_gai1_w1 = adsl_gai1_w1->adsc_next;  /* get next gather in chain */
+         if (adsl_gai1_w1 == NULL) goto p_ret_00;  /* needs more data  */
+         achl1 = adsl_gai1_w1->achc_ginp_cur;  /* get start of buffer  */
+       }
+       iml_remainder <<= 7;                 /* shift old bits          */
+       iml_remainder |= *achl1 & 0X7F;      /* apply new bits          */
+       if ((signed char) *achl1 >= 0) break;  /* more bit not set      */
+       achl1++;                             /* next character input    */
+       iml1--;                              /* count character NHASN   */
+       if (iml1 < 0) goto p_rec_err;        /* data received invalid   */
+     }
+     achl1++;                               /* next character input    */
+     iml_no_iov = 1;                        /* number of WSABUF / vector */
+     iml_len_packet = D_LEN_L2TP_HEADER + iml_remainder;  /* length of packet */
+   } else if ((chl_type & 0XD0) == 0X40) {  /* received IPV4 or IPV6   */
+     chrl_l2tp_header[ D_LEN_L2TP_HEADER + 1 ] = chl_type;  /* save first byte */
+     chl_type &= 0XF0;                      /* only bits IPV4 - IPV6   */
+     iml_len_packet = 4;                    /* after length            */
+     if (chl_type == 0X60) {                /* received IPV6           */
+       iml_len_packet = 6;                  /* after length            */
+     }
+     iml1 = 1;                              /* first byte already copied */
+     do {                                   /* copy part of header     */
+       if (achl1 >= adsl_gai1_w1->achc_ginp_end) {  /* at end of buffer */
+         adsl_gai1_w1 = adsl_gai1_w1->adsc_next;  /* get next gather in chain */
+         if (adsl_gai1_w1 == NULL) goto p_ret_00;  /* needs more data  */
+         achl1 = adsl_gai1_w1->achc_ginp_cur;  /* get start of buffer  */
+       }
+       chrl_l2tp_header[ D_LEN_L2TP_HEADER + 1 + iml1++ ] = *achl1++;  /* copy IP header */
+     } while (iml1 < iml_len_packet);
+     iml_len_packet
+       = ((*((unsigned char *) chrl_l2tp_header + D_LEN_L2TP_HEADER + 1 + 2 + 0) << 8)
+             | *((unsigned char *) chrl_l2tp_header + D_LEN_L2TP_HEADER + 1 + 2 + 1));
+     iml_remainder = iml_len_packet - 4;
+     iml1 = (chrl_l2tp_header[ D_LEN_L2TP_HEADER + 1 ] & 0X0F) << 2;  /* length IPV4 header */
+     if (chl_type == 0X60) {                /* is IPV6                 */
+       iml_len_packet
+         = ((*((unsigned char *) chrl_l2tp_header + D_LEN_L2TP_HEADER + 1 + 4 + 0) << 8)
+               | *((unsigned char *) chrl_l2tp_header + D_LEN_L2TP_HEADER + 1 + 4 + 1))
+             + D_LEN_HEADER_IPV6;
+       iml_remainder = iml_len_packet - 6;
+       iml1 = D_LEN_HEADER_IPV6;            /* length IPV6 header      */
+     }
+     if (iml_len_packet <= iml1) {          /* length too short        */
+       goto p_rec_err;                      /* data received invalid   */
+     }
+     iml_len_packet += D_LEN_L2TP_HEADER + 1;  /* length of packet     */
+     iml_no_iov = 1;                        /* number of WSABUF / vector */
+   } else {                                 /* invalid type received   */
+     goto p_rec_err;                        /* data received invalid   */
+   }
+#endif
    if (chl_type != '0') {                   /* not control data received / PPP, IPV4, IPV6 */
      if (   (adsl_l2tpc1)                   /* with connection to L2TP UDP */
          && (adsl_l2tpc1->iec_stl != ied_stl_connected)) {  /* not connected */
@@ -1684,6 +1817,7 @@
 #endif
 // to-do 10.11.08 KB check PPP
 //   }
+#ifndef HPPPT1_V21                          /* 03.12.12 KB HOB-PPP-T1 V2.1 */
    } else if (chl_type == '4') {            /* IPV4 packet received    */
      if ((adsl_l2tpc1->dsc_ppp_se_1.imc_options & D_PPP_OPT_HS_COMPL) == 0) {  /* handshake not complete */
        if (adsl_l2tpc1->adsc_l2tp_session) {  /* session exists        */
@@ -1772,6 +1906,55 @@
        }
      }
 #endif
+#endif
+#ifdef HPPPT1_V21                           /* 03.12.12 KB HOB-PPP-T1 V2.1 */
+   } else if (chl_type == 0X40) {           /* IPV4 packet received    */
+     if ((adsl_l2tpc1->dsc_ppp_se_1.imc_options & D_PPP_OPT_HS_COMPL) == 0) {  /* handshake not complete */
+       if (adsl_l2tpc1->adsc_l2tp_session) {  /* session exists        */
+         m_l2tp_warning( adsl_l2tpc1->adsc_l2tp_session, "l%05d HOB-PPP-T1 m_hpppt1_rec_client() received IPV4 packet but handshake not complete - ignored",
+                         __LINE__ );
+       }
+       goto p_consume_00;                   /* consume the record      */
+     }
+     if (adsp_l2tp_session->adsc_ptfa1) {   /* active target filter    */
+       dsl_gai1_sub_1.achc_ginp_cur = &chrl_l2tp_header[ D_LEN_L2TP_HEADER + 1 ];  /* start with first byte IP packet */
+       dsl_gai1_sub_1.achc_ginp_end = &chrl_l2tp_header[ D_LEN_L2TP_HEADER + 1 + 4 ];  /* end of this gather */
+       dsl_gai1_sub_1.adsc_next = &dsl_gai1_sub_2;  /* next gather in chain */
+       dsl_gai1_sub_2.achc_ginp_cur = achl1;  /* start with current data */
+       dsl_gai1_sub_2.achc_ginp_end = adsl_gai1_w1->achc_ginp_end;  /* end of this gather */
+       dsl_gai1_sub_2.adsc_next = adsl_gai1_w1->adsc_next;  /* next gather in chain */
+       iel_rcf = m_proc_ppp_targfi_ipv4( adsp_hco_wothr, adsp_l2tp_session->adsc_ptfa1,
+                                         &dsl_gai1_sub_1, 4 + iml_remainder );
+       if (iel_rcf != ied_rcf_ok) {         /* packet is not o.k.      */
+         if (iel_rcf == ied_rcf_incompl) goto p_ret_00;  /* needs more data */
+         adsl_l2tpc1->imc_dropped_packet_targfi++;  /* increment number of packets dropped because of target-filter */
+         goto p_consume_00;                 /* consume the record      */
+       }
+     }
+   } else if (chl_type == 0X60) {           /* IPV6 packet received    */
+     if ((adsl_l2tpc1->dsc_ppp_se_1.imc_options & D_PPP_OPT_HS_COMPL) == 0) {  /* handshake not complete */
+       if (adsl_l2tpc1->adsc_l2tp_session) {  /* session exists        */
+         m_l2tp_warning( adsl_l2tpc1->adsc_l2tp_session, "l%05d HOB-PPP-T1 m_hpppt1_rec_client() received IPV6 packet but handshake not complete - ignored",
+                         __LINE__ );
+       }
+       goto p_consume_00;                   /* consume the record      */
+     }
+     if (adsp_l2tp_session->adsc_ptfa1) {   /* active target filter    */
+       dsl_gai1_sub_1.achc_ginp_cur = &chrl_l2tp_header[ D_LEN_L2TP_HEADER + 1 ];  /* start with first byte IP packet */
+       dsl_gai1_sub_1.achc_ginp_end = &chrl_l2tp_header[ D_LEN_L2TP_HEADER + 1 + 6 ];  /* end of this gather */
+       dsl_gai1_sub_1.adsc_next = &dsl_gai1_sub_2;  /* next gather in chain */
+       dsl_gai1_sub_2.achc_ginp_cur = achl1;  /* start with current data */
+       dsl_gai1_sub_2.achc_ginp_end = adsl_gai1_w1->achc_ginp_end;  /* end of this gather */
+       dsl_gai1_sub_2.adsc_next = adsl_gai1_w1->adsc_next;  /* next gather in chain */
+       iel_rcf = m_proc_ppp_targfi_ipv6( adsp_hco_wothr, adsp_l2tp_session->adsc_ptfa1,
+                                         &dsl_gai1_sub_1, 6 + iml_remainder );
+       if (iel_rcf != ied_rcf_ok) {         /* packet is not o.k.      */
+         if (iel_rcf == ied_rcf_incompl) goto p_ret_00;  /* needs more data */
+         adsl_l2tpc1->imc_dropped_packet_targfi++;  /* increment number of packets dropped because of target-filter */
+         goto p_consume_00;                 /* consume the record      */
+       }
+     }
+#endif
    }

    p_rec_20:                                /* scan data               */
@@ -1949,6 +2132,7 @@
    if (chl_type == '0') goto p_rec_60;      /* no PPP / IPV4 / IPV6 packet received */
    if (adsl_l2tpc1 == NULL) goto p_rec_60;  /* no more connection to L2TP UDP */
    iml1 = D_LEN_L2TP_HEADER;
+#ifndef HPPPT1_V21                          /* 03.12.12 KB HOB-PPP-T1 V2.1 */
    if (chl_type == '4') {                   /* IPV4 received           */
      *((unsigned char *) chrl_l2tp_header + D_LEN_L2TP_HEADER) = (unsigned char) 0X21;  /* IPV4 */
      iml1++;                                /* increment length        */
@@ -1970,6 +2154,22 @@
      iml_len_packet += 2;                   /* increment length of packet */
 #endif
    }
+#endif
+#ifdef HPPPT1_V21                           /* 03.12.12 KB HOB-PPP-T1 V2.1 */
+   if (chl_type == 0X40) {                  /* IPV4 packet received    */
+     *((unsigned char *) chrl_l2tp_header + D_LEN_L2TP_HEADER) = (unsigned char) 0X21;  /* IPV4 */
+     iml1 += 1 + 4;                         /* increment length        */
+#ifdef B121218
+     iml_len_packet += D_LEN_L2TP_HEADER + 1;  /* increment length of packet */
+#endif
+   } else if (chl_type == 0X60) {           /* IPV6 packet received    */
+     *((unsigned char *) chrl_l2tp_header + D_LEN_L2TP_HEADER) = (unsigned char) 0X57;  /* IPV6 */
+     iml1 += 1 + 6;                         /* increment length        */
+#ifdef B121218
+     iml_len_packet += D_LEN_L2TP_HEADER + 1;  /* increment length of packet */
+#endif
+   }
+#endif
    *(chrl_l2tp_header) = (unsigned char) 0X40;  /* data packet         */
    *(chrl_l2tp_header + 1) = (unsigned char) 0X02;  /* version         */
    *(chrl_l2tp_header + 2 + 0) = (unsigned char) (iml_len_packet >> 8);  /* length of packet */
@@ -3631,7 +3831,9 @@
    char       *achl_buf_w1;                 /* buffer for receive      */
    char       *achl_buf_end;                /* end of buffer           */
    char       chl_more;                     /* more bit                */
+#ifndef HPPPT1_V21                          /* 03.12.12 KB HOB-PPP-T1 V2.1 */
    char       chl_type;                     /* type of send            */
+#endif
 #ifdef OLD01
    ied_ppp_frse_rc iel_pppfsr;              /* return code PPP from server */
 #endif
@@ -3807,6 +4009,7 @@
 #endif
    bol_not_count_packet = FALSE;            /* do not count packet     */
    if (adsl_l2tpc1_w1->iec_scp == ied_scp_hpppt1) {  /* protocol HOB-PPP-T1 */
+#ifndef HPPPT1_V21                          /* 03.12.12 KB HOB-PPP-T1 V2.1 */
      chl_type = '1';                        /* type of send            */
      if (*((unsigned char *) achl1) == 0X21) {  /* IPV4 received       */
        chl_type = '4';                      /* type of send IPV4       */
@@ -3838,6 +4041,90 @@
        if (iml1 == 0) break;                /* end of output           */
        chl_more = (unsigned char) 0X80;     /* set more bit            */
      }
+#endif
+#ifdef HPPPT1_V21                           /* 03.12.12 KB HOB-PPP-T1 V2.1 */
+     if (*((unsigned char *) achl1) == 0X21) {  /* IPV4 received       */
+       achl1++;                             /* do not send first byte PPP */
+       iml_len_rec--;                       /* decrement length        */
+       if ((*achl1 & 0XF0) != 0X40) {       /* not IPV4 packet         */
+         m_l2tp_warning( adsl_l2tp_session, "l%05d m_cb_udp_recv() invalid packet IPV4 received - 0X%02X.",
+                         __LINE__, *((unsigned char *) achl1) );
+         adsl_l2tpc1_w1->imc_dropped_packet_server++;  /* number of packets dropped by the server */
+         m_proc_free( adsp_sdhc1_rb );      /* free buffer again       */
+         return;                            /* nothing more to do      */
+       }
+       if ((*achl1 & 0X0F) < 5) {           /* IPV4 header too short   */
+         m_l2tp_warning( adsl_l2tp_session, "l%05d m_cb_udp_recv() received packet IPV4 header too short - 0X%02X.",
+                         __LINE__, *((unsigned char *) achl1) );
+         adsl_l2tpc1_w1->imc_dropped_packet_server++;  /* number of packets dropped by the server */
+         m_proc_free( adsp_sdhc1_rb );      /* free buffer again       */
+         return;                            /* nothing more to do      */
+       }
+       if (iml_len_rec <= (5 * 4)) {        /* length too short      */
+         m_l2tp_warning( adsl_l2tp_session, "l%05d m_cb_udp_recv() received packet IPV4 length %d too short",
+                         __LINE__, iml_len_rec );
+         adsl_l2tpc1_w1->imc_dropped_packet_server++;  /* number of packets dropped by the server */
+         m_proc_free( adsp_sdhc1_rb );      /* free buffer again       */
+         return;                            /* nothing more to do      */
+       }
+       iml1 = (*((unsigned char *) achl1 + 2 + 0) << 8)
+                | *((unsigned char *) achl1 + 2 + 1);
+       if (iml1 != iml_len_rec) {           /* length invalid          */
+         m_l2tp_warning( adsl_l2tp_session, "l%05d m_cb_udp_recv() received packet IPV4 length %d - %d does not match",
+                         __LINE__, iml1, iml_len_rec );
+         adsl_l2tpc1_w1->imc_dropped_packet_server++;  /* number of packets dropped by the server */
+         m_proc_free( adsp_sdhc1_rb );      /* free buffer again       */
+         return;                            /* nothing more to do      */
+       }
+       if (   (adsl_l2tp_session)           /* L2TP session connected  */
+           && (adsl_l2tp_session->boc_not_drop_tcp_packet)  /* do not drop TCP packets */
+           && (*(achl1 + D_POS_IPV4_H_PROT) == IPPROTO_TCP)) {  /* protocol TCP from IP header */
+         bol_not_count_packet = TRUE;       /* do not count packet     */
+       }
+     } else if (*((unsigned char *) achl1) == 0X57) {  /* IPV6 received */
+       achl1++;                               /* do not send first byte PPP */
+       iml_len_rec--;                       /* decrement length        */
+       if ((*achl1 & 0XF0) != 0X60) {         /* not IPV6 packet         */
+         m_l2tp_warning( adsl_l2tp_session, "l%05d m_cb_udp_recv() invalid packet IPV6 received - 0X%02X.",
+                         __LINE__, *((unsigned char *) achl1) );
+         adsl_l2tpc1_w1->imc_dropped_packet_server++;  /* number of packets dropped by the server */
+         m_proc_free( adsp_sdhc1_rb );      /* free buffer again       */
+         return;                            /* nothing more to do      */
+       }
+       if (iml_len_rec <= D_LEN_HEADER_IPV6) {  /* length too short    */
+         m_l2tp_warning( adsl_l2tp_session, "l%05d m_cb_udp_recv() received packet IPV6 length %d too short",
+                         __LINE__, iml_len_rec );
+         adsl_l2tpc1_w1->imc_dropped_packet_server++;  /* number of packets dropped by the server */
+         m_proc_free( adsp_sdhc1_rb );      /* free buffer again       */
+         return;                            /* nothing more to do      */
+       }
+       iml1 = (*((unsigned char *) achl1 + 4 + 0) << 8)
+                | *((unsigned char *) achl1 + 4 + 1);
+       if ((iml1 + D_LEN_HEADER_IPV6) != iml_len_rec) {  /* length invalid */
+         m_l2tp_warning( adsl_l2tp_session, "l%05d m_cb_udp_recv() received packet IPV6 length 40 + %d - %d does not match",
+                         __LINE__, iml1, iml_len_rec );
+         adsl_l2tpc1_w1->imc_dropped_packet_server++;  /* number of packets dropped by the server */
+         m_proc_free( adsp_sdhc1_rb );      /* free buffer again       */
+         return;                            /* nothing more to do      */
+       }
+       if (   (adsl_l2tp_session)           /* L2TP session connected  */
+           && (adsl_l2tp_session->boc_not_drop_tcp_packet)  /* do not drop TCP packets */
+           && (*(achl1 + D_POS_IPV6_H_NEXT) == IPPROTO_TCP)) {  /* protocol TCP from IP header */
+         bol_not_count_packet = TRUE;       /* do not count packet     */
+       }
+     } else {                               /* other PPP data          */
+       bol_not_count_packet = TRUE;         /* do not count packet     */
+       iml1 = iml_len_rec;                  /* get length              */
+       chl_more = 0;                        /* not yet more bit        */
+       while (TRUE) {                       /* loop output length NHASN */
+         *(--achl1) = (unsigned char) (iml1 & 0X7F) | chl_more;
+         iml1 >>= 7;                        /* shift bits              */
+         if (iml1 == 0) break;              /* end of output           */
+         chl_more = (unsigned char) 0X80;   /* set more bit            */
+       }
+       *(--achl1) = '1';                    /* source UDP              */
+     }
+#endif
    } else {                                 /* protocol SSTP           */
      iml1 = 4 + iml_len_rec;                /* get length              */
      *(--achl1) = (unsigned char) iml1;
@@ -4285,6 +4572,10 @@
 /** check IPV4 packet against target-filter                            */
 extern "C" enum ied_ret_cf m_proc_ppp_targfi_ipv4( struct dsd_hco_wothr *adsp_hco_wothr, struct dsd_ppp_targfi_act_1 *adsp_ptfa1,
                                                    struct dsd_gather_i_1 *adsp_gai1, int imp_len ) {
+#ifndef B121116
+   BOOL       bol_rc;                       /* return code             */
+   int        iml_rc;                       /* return code             */
+#endif
    int        iml1, iml2;                   /* working variables       */
    int        iml_inp;                      /* position in input       */
    int        iml_pos_ce_s;                 /* position in cache entry */
@@ -4295,7 +4586,9 @@
    int        iml_no_targfi_ele_1;          /* number of elements      */
    int        iml_no_protocol;              /* number of protocols     */
    int        iml_no_port;                  /* number of ports         */
+#ifdef B121116
    int        iml_stack;                    /* position in stack       */
+#endif
    int        iml_no_dns;                   /* position in DNS response */
    UNSIG_MED  uml_ineta_w1;                 /* temporary INETA         */
 #ifdef B110104
@@ -4303,7 +4596,9 @@
    UNSIG_MED  uml_work;                     /* for shift INETA         */
 #endif
    char       *achl_inp;                    /* input bytes from here   */
+#ifdef B121116
    char       *achl_mask;                   /* position in mask        */
+#endif
    char       *achl_w1;                     /* working variable        */
    struct dsd_gather_i_1 *adsl_gai1_w1;     /* working variable        */
    struct dsd_ppp_targfi_cache_ipv4 *adsl_ptfca_w1;  /* working variable  */
@@ -4311,9 +4606,11 @@
    struct dsd_ppp_targfi_cache_ipv4 *adsl_ptfca_keep;  /* last entry to keep */
    struct hostent *adsl_hostentry;          /* for gethostbyname()     */
    char       chrl_ce[ D_CACHE_TF_IPV4_LEN ];  /* compare to cache entry */
+#ifdef B121116
 #define DEF_MASK_STACK 16
    char       *achrl_sm[ DEF_MASK_STACK ];
    char       *achrl_si[ DEF_MASK_STACK ];
+#endif

    adsl_gai1_w1 = adsp_gai1;                /* get input               */
    iml_inp = imp_len;                       /* position in input       */
@@ -4505,6 +4802,7 @@
    if (achl_inp == NULL) goto p_cht_in_30;  /* try next name from DNS  */

    p_cht_in_28:                             /* check next DNS name     */
+#ifdef B121116
    iml_stack = 0;                           /* clear stack index       */
    achl_mask = (char *) adsp_ptfa1->adsc_targfi_1
                           + ((struct dsd_targfi_ele_1 *) (adsp_ptfa1->adsc_targfi_1 + 1)
@@ -4572,6 +4870,21 @@
    if (*achl_mask == 0) goto p_cht_in_32;   /* end already found       */
    iml_stack--;
    goto plook62;
+#endif
+#ifndef B121116
+   bol_rc = m_cmp_wc_i_vx_vx( &iml_rc,
+                              achl_inp, -1, ied_chs_idna_1,
+                              (char *) adsp_ptfa1->adsc_targfi_1
+                                + ((struct dsd_targfi_ele_1 *) (adsp_ptfa1->adsc_targfi_1 + 1)
+                                     + iml_no_targfi_ele_1)->imc_off_dns_name,
+                              ((struct dsd_targfi_ele_1 *) (adsp_ptfa1->adsc_targfi_1 + 1)
+                                 + iml_no_targfi_ele_1)->imc_len_dns_name,
+                              ied_chs_utf_8 );
+   if (   (bol_rc)
+       && (iml_rc == 0)) {
+     goto p_cht_in_32;                      /* mask does match         */
+   }
+#endif

    p_cht_in_30:                             /* try next name from DNS  */
    iml_no_dns++;                            /* position in DNS response */
@@ -4674,6 +4987,10 @@
 /** check IPV6 packet against target-filter                            */
 extern "C" enum ied_ret_cf m_proc_ppp_targfi_ipv6( struct dsd_hco_wothr *adsp_hco_wothr, struct dsd_ppp_targfi_act_1 *adsp_ptfa1,
                                                    struct dsd_gather_i_1 *adsp_gai1, int imp_len ) {
+#ifndef B121116
+   BOOL       bol_rc;                       /* return code             */
+   int        iml_rc;                       /* return code             */
+#endif
    int        iml1, iml2;                   /* working variables       */
    int        iml_inp;                      /* position in input       */
    int        iml_pos_ce_s;                 /* position in cache entry */
@@ -4684,7 +5001,9 @@
    int        iml_no_targfi_ele_1;          /* number of elements      */
    int        iml_no_protocol;              /* number of protocols     */
    int        iml_no_port;                  /* number of ports         */
+#ifdef B121116
    int        iml_stack;                    /* position in stack       */
+#endif
    int        iml_no_dns;                   /* position in DNS response */
    char       *achl_inp;                    /* input bytes from here   */
    char       *achl_mask;                   /* position in mask        */
@@ -4696,9 +5015,11 @@
    struct hostent *adsl_hostentry;          /* for gethostbyname()     */
    char       chrl_ineta[ 16 ];             /* temporary INETA IPV6    */
    char       chrl_ce[ D_CACHE_TF_IPV6_LEN ];  /* compare to cache entry */
+#ifdef B121116
 #define DEF_MASK_STACK 16
    char       *achrl_sm[ DEF_MASK_STACK ];
    char       *achrl_si[ DEF_MASK_STACK ];
+#endif

    adsl_gai1_w1 = adsp_gai1;                /* get input               */
    iml_inp = imp_len;                       /* position in input       */
@@ -4881,6 +5202,7 @@
    if (achl_inp == NULL) goto p_cht_in_30;  /* try next name from DNS  */

    p_cht_in_28:                             /* check next DNS name     */
+#ifdef B121116
    iml_stack = 0;                           /* clear stack index       */
    achl_mask = (char *) adsp_ptfa1->adsc_targfi_1
                           + ((struct dsd_targfi_ele_1 *) (adsp_ptfa1->adsc_targfi_1 + 1)
@@ -4940,6 +5262,21 @@
    if (*achl_mask == 0) goto p_cht_in_32;   /* end already found       */
    iml_stack--;
    goto plook62;
+#endif
+#ifndef B121116
+   bol_rc = m_cmp_wc_i_vx_vx( &iml_rc,
+                              achl_inp, -1, ied_chs_idna_1,
+                              (char *) adsp_ptfa1->adsc_targfi_1
+                                + ((struct dsd_targfi_ele_1 *) (adsp_ptfa1->adsc_targfi_1 + 1)
+                                     + iml_no_targfi_ele_1)->imc_off_dns_name,
+                              ((struct dsd_targfi_ele_1 *) (adsp_ptfa1->adsc_targfi_1 + 1)
+                                 + iml_no_targfi_ele_1)->imc_len_dns_name,
+                              ied_chs_utf_8 );
+   if (   (bol_rc)
+       && (iml_rc == 0)) {
+     goto p_cht_in_32;                      /* mask does match         */
+   }
+#endif

    p_cht_in_30:                             /* try next name from DNS  */
    iml_no_dns++;                            /* position in DNS response */
Index: hob-sessutil01.h
===================================================================
--- hob-sessutil01.h	(revision 0)
+++ hob-sessutil01.h	(revision 6)
@@ -0,0 +1,141 @@
+#ifndef HOB_SESSUTIL_H_INC
+#define HOB_SESSUTIL_H_INC
+
+enum ied_check_comm_result
+{
+    ied_comm_found         = 0,
+    ied_comm_found_partial = 1,
+    ied_comm_not_found     = 2
+};
+
+//
+// Frees a chain of gather structures.
+// Frees the memory allocated by a chain of gather structures, starting from
+// the root link, and finishing at the last link.
+//
+// @param adsp_chain_root  First link in the chain of gather structures.
+//
+extern inline void m_free_gath_chain(dsd_gather_i_1* adsp_chain_root);
+
+//
+// Reads and returns the message length value from the HOB-TUN header.
+// Attempts to read the message length value of the variable length 'length'
+// field of the HOB-TUN header.
+//
+// @param  adsp_root_gather  Pointer to the first relevant link in the gather
+//                           chain.
+// @param  imp_length        After the call returns, holds the length value
+//                           read.
+// @param  imp_lenlen        After the call returns, holds the length of the
+//                           header's 'length' field.
+//
+// @return  Returns TRUE if the gather chain contained the entire lenght field
+//          and FALSE otherwise.
+//
+extern BOOL m_getlen(dsd_gather_i_1* adsp_root_gather,
+                     int32_t&        imp_length,
+                     int32_t&        imp_lenlen);
+
+//
+// Determines whether a gather structure chain contains an entire SSTP message.
+// Given a chain of gather structures and the length of a HOB-TUN message,
+// finds out if the chain of gather structures stores the entire HOB-TUN
+// message within it.
+//
+// @param  adsp_root_link   Pointer to the first relevant link in the gather
+//                          chain.
+// @param  imp_tot_pkt_len  Length of the HOB-TUN relevant message.
+// @param  aabyp_pkt_end    After the call returns, holds a pointer to the end
+//                          of the HOB-TUN message in the gather chain.
+//
+// @return  If the entire HOB-TUN message is found, returns TRUE. Otherwise
+//          returns FALSE.
+//
+extern BOOL m_check_pkt_complete(dsd_gather_i_1* adsp_root_link,
+                                 int32_t         imp_tot_pkt_len,
+                                 byte**          aabyp_pkt_end);
+
+//
+// Finds a sequence of two newline characters.
+// Searches a string of characters looking for a sequence of two consecutive
+// newline characters.
+//
+// @param  aucp_pos_start  Pointer to the beginning of the character string.
+// @param  aucp_pos_end    Pointer to the end of the character string.
+//
+// @return  If the sequence is found, the call returns a pointer to the end of
+//          the sequence. If it is not found, the call returns NULL.
+//
+extern byte* m_search_nlnl(byte* abyp_pos_start,
+                           byte* abyp_pos_end);
+
+//
+// Gets the SSTP message length.
+// Attempts to read the SSTP LengthValue field in order to determine the length
+// of an SSTP message in a gather chain.
+//
+// @param  adsp_link_cur  Pointer to the first relevant link in the gather chain.
+//
+// @return  If the length value was successfully read, the call returns the
+//          length of the SSTP message. If the length value could not be read
+//          the call returns a value of -1.
+//
+extern int32_t m_get_sstp_lengthpacket(dsd_gather_i_1* adsp_link_cur);
+
+//
+// Determines whether a gather structure chain contains an entire SSTP message.
+// Given a chain of gather structures and the length of an SSTP message,
+// finds out if the chain of gather structures stores the entire SSTP message
+// within it.
+//
+// @param  adsp_link_cur     Pointer to the first relevant link in the gather
+//                           chain.
+// @param  usp_lengthpacket  Length of the SSTP relevant message.
+//
+// @return  If the entire SSTP message is found, returns a pointer to the end
+//          of the message in the gather chain. Returns NULL if only part of the
+//          SSTP message was found.
+//
+extern byte* m_check_sstp_complete(dsd_gather_i_1* adsp_link_cur,
+                                   uint16_t        usp_lengthpacket);
+
+//
+// Copies an SSTP message from a gather chain to a single contiguous buffer.
+//
+// @param  adsp_link_cur      Pointer to the first relevant link in the gather
+//                            chain.
+// @param  usp_lengthpacket   Length of the SSTP message being copied.
+// @param  abyp_sstp_msg_end  Pointer to the position in the gather chain where
+//                            the SSTP message ends.
+//
+// @return  Returns a pointer to the new buffer.
+//
+extern byte* m_copy_sstp_message(dsd_gather_i_1* adsp_link_cur,
+                                 uint16_t        usp_lengthpacket,
+                                 byte*           abyp_sstp_msg_end);
+
+//
+// Generates a valid MS-CHAP challenge response.
+//
+// @return  Returns the valid response for the given challenge.
+//
+extern byte* GenerateAuthenticatorResponse(byte*    abyp_peer_pw,
+                                           uint32_t ump_peer_pw_len,
+                                           byte*    abyp_peer_un,
+                                           uint32_t ump_peer_un_len,
+                                           byte*    abyp_peer_resp,
+                                           byte*    abyp_peer_chal,
+                                           byte*    abyp_own_chal,
+                                           byte*    abyp_result_buf);
+
+#endif
+
+unsigned int m_seek_comm(dsd_gather_i_1* adsp_gather, char* achp_cmp_buf, uint32_t ump_pos);
+
+ied_check_comm_result m_check_hpppt1_cmd(dsd_gather_i_1* adsp_root_link);
+
+void m_do_wsp_trace(const char* achp_wtrt_id, int inp_core_id,
+                    int inp_session_wtrt_sno, int inp_session_trace_level,
+                    struct dsd_gather_i_1* adsp_data, int inp_data_len,
+                    int inp_short_len,
+                    const char* achp_message, ...);
\ No newline at end of file
Index: xiipgw08-pttd.cpp
===================================================================
--- xiipgw08-pttd.cpp	(revision 2)
+++ xiipgw08-pttd.cpp	(revision 6)
@@ -593,6 +593,10 @@
 // dsl_tun_start_htcp.boc_connect_round_robin = FALSE;  /* do not connect round-robin */
 // dsl_tun_start_htcp.adsc_htun_h = (dsd_htun_h *) &adsl_conn1->dsc_htun_h;  /* where to put the handle created */
    dsl_tun_start_htcp.adsc_htun_h = (dsd_htun_h *) &adsl_ineta_raws_1_w1->dsc_htun_h;  /* where to put the handle created */
+#ifndef B130116
+   adsl_conn1->adsc_ineta_raws_1 = adsl_ineta_raws_1_w1;  /* auxiliary field for HOB-TUN */
+   adsl_conn1->iec_servcotype = ied_servcotype_htun;  /* HOB-TUN       */
+#endif
    m_hl_lock_inc_1( &adsl_conn1->imc_references );  /* references to this session */
    m_htun_new_sess_htcp( &dsl_tun_start_htcp,
                          &adsl_conn1->dsc_tun_contr_conn,  /* HOB-TUN control area connection */
@@ -651,8 +655,10 @@
      if (iml_no_wol > 0) goto pcpttdt12;    /* send WOL packet again   */
      goto pcpttdt24;                        /* do connect over HTCP    */
    }
+#ifdef B130116
    adsl_conn1->adsc_ineta_raws_1 = adsl_ineta_raws_1_w1;  /* auxiliary field for HOB-TUN */
    adsl_conn1->iec_servcotype = ied_servcotype_htun;  /* HOB-TUN       */
+#endif
    iml_rc_sock = 0;                         /* does not return error   */
 #ifdef B101125
    adsl_conn1->iec_st_ses = clconn1::ied_ses_compl_cpttdt;  /* connect pass thru to desktop completed */
Index: SOFTWARE.HLJWT.XSLBGW01.act.txt
===================================================================
--- SOFTWARE.HLJWT.XSLBGW01.act.txt	(revision 2)
+++ SOFTWARE.HLJWT.XSLBGW01.act.txt	(revision 6)
@@ -15,10 +15,10 @@
          Gateway, require HOBLink Secure (Implementation of SSL V3.0) and
          a special feature in the WTS client. The special feature in the
          WTS client may also be a special redirector.
-         The routine XSLBGW01 (which implements C++ class HLcllbgw1) is
-         implemented in the Gateway products IBIPGW08 (WIN32) and
-         NBIPGW08 (UNIX with XTI).
-         Normally the gateways IBIPGW08 or NBIPGW08 are placed in the
+         The routine XSLBGW01 (which implements C++ class dsd_lbal_gw_1)
+         is implemented in the Gateway products IBIPGW08 (Windows) and
+         nbipgw20 (UNIX).
+         Normally the gateways IBIPGW08 or nbipgw20 are placed in the
          de-militarized-zone, between two firewalls.

          2. Protocol (TCP/IP) between Load-Balancing Gateway and WTS
@@ -27,7 +27,7 @@
          There are additional structures in the communication between the
          WTS client and the Load Balancing Gateway.

-         Structures send from the WTS client to the Load Balancing
+         Structures sent from the WTS client to the Load Balancing
          Gateway:
            64 = 40 hexa = function requested. 2 bytes big endian.
                 0 = client selects server
@@ -60,7 +60,7 @@
            73 = 49 hexa = error message connect. 2 bytes big endian.
            74 = 4A hexa = error message. 2 bytes big endian.
                 1 means no servers responded.
-           75 = 4B hexa = user other server from list sent by client+           75 = 4B hexa = use other server from list sent by client


@@ -69,27 +69,27 @@

          3. Routines in the Main Program that will be Called

-         3.1. void HLGW_set_timer( void *apparam, int iseconds );
+         3.1. void HLGW_set_timer( void *apparam, int imp_time );

          - apparam is a value (any value know by the main program) passed
-           to class HLcllbgw1 when the constructor was called.
-         - iseconds is the time in seconds when the timer has to expire
-           and proc_CL_recv has to be called
+           to class dsd_lbal_gw_1 when the constructor was called.
+         - imp_times is the time in seconds when the timer has to expire
+           and m_proc_se_recv() has to be called

-         When the class HLcllbgw1 calls HLGW_set_end, any not yet expired
-         timer will automaticly be removed by the main program.
+         When the class dsd_lbal_gw_1 calls HLGW_set_end, any not yet
+         expired timer will automaticly be removed by the main program.

          3.2. void HLGW_sendto_LB( void *apparam,
-                                   char *apbuf, int ipsendlen );
+                                   char *achp_buf, int imp_sendlen );

          - apparam is a value (any value know by the main program) passed
-           to class HLcllbgw1 when the constructor was called.
+           to class dsd_lbal_gw_1 when the constructor was called.

          3.3. int HLGW_start_conn( void *apparam,
-                       unsigned long int ulpineta, int ipport );
+                                   struct sockaddr *adsp_soa );

          - apparam is a value (any value know by the main program) passed
-           to class HLcllbgw1 when the constructor was called.
+           to class dsd_lbal_gw_1 when the constructor was called.

          3.4. int HLGW_check_name( void *apparam,
                                    char *apname, int iplenname,
@@ -99,75 +99,82 @@
          3.5. void HLGW_set_abend( void *apparam );

          - apparam is a value (any value know by the main program) passed
-           to class HLcllbgw1 when the constructor was called.
+           to class dsd_lbal_gw_1 when the constructor was called.

-         4. Methodes of the class HLcllbgw1 to be called
+         4. Methodes of the class dsd_lbal_gw_1 to be called

-         All calls to the class HLcllbgw1 are made in a worker thread.
+         All calls to the class dsd_lbal_gw_1 are made in a worker
+         thread.

-         4.1. Constructor / HLcllbgw1( void *apparam, int iptime1, int
-         iptime2, struct DWTSG1 *apdwtsg1 );
+         4.1. Constructor / dsd_lbal_gw_1( void *apparam,
+                        int iptime1, int iptime2,
+                        struct dsd_wtsg_1 *adsp_wtsg_1,
+                        BOOL bop_is_blade_server );

          The constructor will be called by the main program with apparam
          as any value the main program needs to find back to the
          connection used for.

-         4.2. void proc_CL_recv( char *arecvs, int irecvl,
-                                 char *aworkas, int iworkal,
-                                 char **apsendcs, int  *apisendcl );
+         4.2. void m_proc_cl_recv( char *achp_received,
+                        int imp_len_received,
+                        char *achp_workarea_start, int imp_workarea_len,
+                        char **aachp_ret_msg, int *aimp_ret_msg_len );

-         - arecvs is the address of the received data from the client.
-         - irecvl is the length of the received data (may be zero).
-         - aworkas is the address of a workarea supplied by the main
-           program.
-         - iworkal is the length of the workarea supplied by the main
-           program.
-         - apsendcs is a pointer where the subroutine requests data to be
-           sent to the client.+         - achp_received is the address of the received data from the
+           client.
+         - imp_len_received is the length of the received data (may be
+           zero).





-         - apisendcl is a pointer to an int where the subroutine sets the
-           length of the data to be send to the client.
+         - achp_workarea_start is the address of a workarea supplied by
+           the main program.
+         - imp_workarea_len is the length of the workarea supplied by the
+           main program.
+         - aachp_ret_msg is a pointer where the subroutine requests data
+           to be sent to the client.
+         - aimp_ret_msg_len is a pointer to an int where the subroutine
+           sets the length of the data to be send to the client.

-         The calling program has to supply a values for apisendcl, so
-         that no data will be sent when the subroutine returns without
+         The calling program has to supply a value in aimp_ret_msg_len,
+         so that no data will be sent when the subroutine returns without
          setting this value.

-         4.3. void proc_SE_recv( ULONG ul_ineta,
-                                 char *arecvs, int irecvl,
-                                 BOOL bo_timed_out,
-                                 char *aworkas, int iworkal,
-                                 char **apsendcs, int *apisendcl );
+         4.3. void m_proc_se_recv( struct sockaddr *adsp_soa,
+                        char *achp_received, int imp_len_received,
+                        BOOL bop_timed_out,
+                        char *achp_workarea_start, int imp_workarea_len,
+                        char **aachp_ret_msg, int *aimp_ret_msg_len );

-         - ul_ineta is the IP-address where the gateway received the UDP
+         - adsp_soa contains the INETA where the gateway received the UDP
            packet from.
-         - arecvs is the address of the received packet.
-         - irecvl is the length of the received packet (may be zero).
-         - bo_timed_out is set to TRUE if a timer, previously set by a
+         - achp_received is the address of the received packet.
+         - imp_len_received is the length of the received packet (may be
+           zero).
+         - bop_timed_out is set to TRUE if a timer, previously set by a
            call to HLGW_set_timer, has expired.
-         - aworkas is the address of a workarea supplied by the main
-           program.
-         - iworkal is the length of the workarea supplied by the main
-           program.
-         - apsendcs is a pointer where the subroutine requests data to be
-           sent to the client.
-         - apisendcl is a pointer to an int where the subroutine sets the
-           length of the data to be send to the client.
+         - achp_workarea_start is the address of a workarea supplied by
+           the main program.
+         - imp_workarea_len is the length of the workarea supplied by the
+           main program.
+         - aachp_ret_msg is a pointer where the subroutine requests data
+           to be sent to the client.
+         - aimp_ret_msg_len is a pointer to an int where the subroutine
+           sets the length of the data to be send to the client.

-         The calling program has to supply a values for apisendcl, so
-         that no data will be sent when the subroutine returns without
+         The calling program has to supply a values for aimp_ret_msg_len,
+         so that no data will be sent when the subroutine returns without
          setting this value.

-         When the subroutine proc_SE_recv returns with apsendcs and
-         apisendcl set, the subroutine has to be called again, maybe
-         there are more data to be send.
-         The main program then has to set irecvl to zero and bo_timed_out
-         to FALSE to notify the subroutine that there are no new data to
-         process.
+         When the subroutine m_proc_se_recv() returns with *aachp_ret_msg
+         and *aimp_ret_msg_len set, the subroutine has to be called
+         again, maybe there are more data to be sent.
+         The main program then has to set imp_len_received to zero and
+         bop_timed_out to FALSE to notify the subroutine that there are
+         no new data to process.

          4.4. Destructur

@@ -178,5 +185,6 @@
          22.02.01  KB
          21.10.02  KB
          02.03.07  KB
-         09.09.08  KB+         09.09.08  KB
+         12.11.12  KB
\ No newline at end of file
Index: SOFTWARE.HLSEC.WSPDOCU1.act.txt
===================================================================
--- SOFTWARE.HLSEC.WSPDOCU1.act.txt	(revision 2)
+++ SOFTWARE.HLSEC.WSPDOCU1.act.txt	(revision 6)
@@ -6,54 +6,109 @@

          Documentation of WebSecureProxy Program Internals

-         1. IBIPGW08
+         1. IBIPGW08 and nbipgw20

-         1.1. Central Routine, proc_data()
+         1.1. Central Routine, m_proc_data()

-         1.1.1. What the Routine proc_data() does
+         1.1.1. What the Routine m_proc_data() does

-         The routine proc_data() processes all the data. This function is
-         called on a work thread.
+         The routine m_proc_data() processes all the data. This function
+         is called on a work thread.
          This function can run only once at a certain time for a given
-         connection. This is control thru the flag clconn1::bo_st_act.
+         connection. This is controlled thru the flag clconn1::bo_st_act.

-         The function proc_data has to run if an event has occurred on a
-         given connection, for example when data where received from the
-         client or from the server.
+         The function m_proc_data() has to run if an event has occurred
+         on a given connection, for example when data where received from
+         the client or from the server.

-         The function proc_data() loops till it has no more to do. Then
-         the flag clconn1::bo_st_act is reset and the function returns.
-         The work thread can do something else now.
+         The function m_proc_data() loops till it has no more to do. Then
+         the flag boc_st_act of the connection structure is reset and the
+         function returns. The work thread can do something else now.

-         The function proc_data() has a main outer loop and a main inner
-         loop.
+         The function m_proc_data() has a main outer loop and a main
+         inner loop.
          The main outer loop starts at pcopd20 and checks if there are
-         any data received. Then the main inner loop, starting at pcopd40
-         runs and encrypts the data (calls SSL sunroutine).
+         any data received. Then the main inner loop, starting at
+         pcopd40, runs and encrypts the data (calls the SSL subroutine).
          The resulting data is then send to the client or the server.

-         1.1.2. Limit how long proc_data() processes data
+         1.1.2. Limit how long m_proc_data() processes data

          In the WebSecureProxy, resulting from the design, the function
-         proc_data() may loop very many times in certain cases.
-         Such as case happens, when input data arrives as fast or fastes
-         as proc_data() can process the data, and also sending data to
+         m_proc_data() may loop very many times in certain cases.
+         Such a case happens, when input data arrives as fast or faster
+         as m_proc_data() can process the data, and also sending data to
          the vis-a-vis side is not blocked.

-         But this very many times looping thru proc_data() uses a
+         But this very many times looping thru m_proc_data() uses a
          work-thread, and maybe others are waiting for a free
          work-thread. To perfectly handling this situation, the variables
            bol_suspend_do    /* do suspend work thread  */
            bol_suspend_act   /* do activate work thread after suspend */
-           inl_count_loop    /* loop counter for suspend */
-         are used. When the outer loop of proc_data() was already
+           iml_count_loop    /* loop counter for suspend */
+         are used. When the outer loop of m_proc_data() was already
          processed DEF_WOTHR_LOOP times, others are waiting for a
          work-thread, and this connection has more to do, the routine
          jumps back after activating itself.
          Because it has activated itself, it will automaticly be
-         processes again after others waiting for work-threads have been
+         processed again after others waiting for work-threads have been
          satisfied.

+         1.1.3. Flow Control for TCP/IP
+
+         There are two ways = paths thru the WSP, one for data from the
+         client to the server, and the other one for data from the server
+         to the client.
+         These are the two directions of data thru the WSP.
+         Both go over TCP connections.+
+
+
+
+
+
+         The WSP has to provide Flow-Control for these paths, independent
+         for the two directions.
+         This is done in m_proc_data() (and in the receive completition
+         routines) in the following way:
+         In each direction, there may be up to two blocks received, which
+         have not yet been processed. These are stored in:
+           class clconn1 or struct dsd_conn1
+             adsc_sdhc1_c1;  /* receive buffer client 1 */
+             adsc_sdhc1_c2;  /* receive buffer client 2 */
+             adsc_sdhc1_s1;  /* receive buffer server 1 */
+             adsc_sdhc1_s2;  /* receive buffer server 2 */
+
+         The first block received goes to adsc_sdhc1_x1 (x = c / s), the
+         next received block goes to adsc_sdhc1_x2, and then receiving is
+         stopped. This is needed for Flow-Control.
+         When data are received, a work-thread gets scheduled, and the
+         routine m_proc_data() will be processed.
+         In m_proc_data(), at pcopd20, a Critical Section is entered.
+         Then it is checked if there are any data received, first from
+         the client, then from the server.
+         When there are data received, it is checked, if there are any
+         data which could not be sent in this direction, because the TCP
+         stack blocked.
+         This is done thru calling the function:
+           cl_tcp_r::m_check_send_act() or something equivalent
+
+         If there is data in the send buffers, the receive buffers are
+         not processed.
+         If there are no data in the send buffers, a receive buffer is
+         processed. If there had been two receive buffers (for a single
+         connection), the TCPCOMP thread is notified thru a call to
+         cl_tcp_r::newreceive() or something equivalent
+         (see variables bol_c_act and bol_s_act in m_proc_data()).
+         In this way, receiving is started again.
+
+         2. References
+
+         HOBTEXT SOFTWARE.HLJWT.XSLBGW01
+
          25.02.05  KB
-         01.03.05  KB+         01.03.05  KB
+         02.03.05  KB
+         06.03.05  KB
+         13.11.12  KB
\ No newline at end of file
Index: nst-tun-dummy-1.cpp
===================================================================
--- nst-tun-dummy-1.cpp	(revision 0)
+++ nst-tun-dummy-1.cpp	(revision 6)
@@ -0,0 +1,151 @@
+/*+-------------------------------------------------------------------+*/
+/*|                                                                   |*/
+/*| PROGRAM NAME: nst-tun-dummy-1.cpp                                 |*/
+/*| -------------                                                     |*/
+/*|  dummy source for compiling nbipgw20 with HOB-TUN                 |*/
+/*|  KB 11.09.12                                                      |*/
+/*|                                                                   |*/
+/*| COPYRIGHT:                                                        |*/
+/*| ----------                                                        |*/
+/*|  Copyright (C) HOB Germany 2012                                   |*/
+/*|                                                                   |*/
+/*+-------------------------------------------------------------------+*/
+
+/*+-------------------------------------------------------------------+*/
+/*| System and library header files.                                  |*/
+/*+-------------------------------------------------------------------+*/
+
+#ifdef XYZ1
+#ifdef TRACEHL1
+#define TRACEHL_CO_OUT
+#endif
+
+#include <stddef.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include <stdarg.h>
+#include <string.h>
+#ifdef XYZ2
+#include <conio.h>
+#endif
+#include <time.h>
+#ifdef HL_UNIX
+#include <fcntl.h>
+#include <poll.h>
+#ifdef HL_LINUX
+#include <pth.h>
+#endif
+#include <sys/socket.h>
+//#include <sys/stropts.h>
+#include <errno.h>
+#include <arpa/inet.h>
+#include <netdb.h>
+#include <netinet/in.h>
+//#include <xti.h>
+#ifndef HL_LINUX
+#include <unistd.h>
+#endif
+#include <sys/types.h>
+#ifdef HL_OPENUNIX
+#include <rpc/types.h>
+#endif
+#include <sys/ipc.h>
+#include <sys/sem.h>
+#ifdef HL_LINUX
+#include <sys/time.h>
+//#include <LiS/sys/xti_ip.h>
+#endif
+#include <limits.h>
+#include <dlfcn.h>
+#include "hob-unix01.h"
+#include "hob-xslhcla1.hpp"
+#include "hob-thread.hpp"
+#endif
+#ifndef HL_UNIX
+#include <wchar.h>
+#include <winsock2.h>
+//#ifdef HL_IPV6
+#include <ws2tcpip.h>
+//#include <wspiapi.h>
+//#endif
+#include <hob-wtspo1.h>
+#endif
+#define EXT_BASE64
+#include <hob-tab-mime-base64.h>
+#include <hob-xslunic1.h>
+#ifndef HL_UNIX
+#include <hob-thread.hpp>
+#include <iswcord1.h>
+#endif
+#ifdef XYZ1
+//#include "hob-hlwspat2.h"
+#include <hob-wspsu1.h>
+#include <hob-avl03.h>
+#endif
+#include <hob-encry-1.h>
+
+#define DOMNode void
+
+#define DEF_HL_INCL_DOM
+#include "hob-xsclib01.h"
+
+#include <hob-netw-01.h>
+#include "hob-wsppriv.h"                    /* privileges              */
+#define HOB_CONTR_TIMER
+#include <hob-xslcontr.h>                   /* HOB Control             */
+//#define INCL_GW_ALL
+#define D_INCL_AUX_UDP
+#include "hob-xbipgw08-1.h"
+#include "hob-xbipgw08-2.h"
+#endif
+#include <sys/socket.h>
+#include <netinet/in.h>
+#include <net/if.h>
+//#include <net/if_arp.h>
+//#include <net/route.h>
+#define HL_LINUX
+#ifdef HL_LINUX
+#include <linux/if_tun.h>                   /* check for other unixes   */
+#endif
+#include "hob-unix01.h"
+#define HL_UNIX
+#define D_INCL_TUN_CTRL
+#include "hob-tun01.h"
+
+/*+-------------------------------------------------------------------+*/
+/*| Procedure division.                                               |*/
+/*+-------------------------------------------------------------------+*/
+
+extern "C" BOOL m_htun_start( struct dsd_raw_packet_if_conf *adsp_rpi_conf, struct dsd_tun_ctrl *adsp_tun_ctrl ) {
+   adsp_tun_ctrl->boc_tun_opened = TRUE;    /* TUN-adapter successful opened */
+   return TRUE;
+} /* end m_htun_start()                                                */
+
+/**
+* start HOB-TUN for a TCP session
+*/
+extern "C" void m_htun_new_sess_htcp( struct dsd_tun_start_htcp *,
+                                      struct dsd_tun_contr_conn *,
+                                      struct dsd_tun_contr_ineta *) {
+} /* end m_htun_new_sess_htcp()                                        */
+
+/**
+* start HOB-TUN for a PPP session
+*/
+extern "C" void m_htun_new_sess_ppp( struct dsd_tun_start_ppp *,
+                                     struct dsd_tun_contr_conn * ) {
+} /* end m_htun_new_sess_ppp()                                         */
+
+/**
+* notify HOB-TUN that the session can receive data
+*/
+extern "C" void m_htun_sess_canrecv( dsd_htun_h dsp_htun_h ) {
+} /* end m_htun_sess_canrecv()                                         */
+
+extern "C" void m_htun_sess_send( struct dsd_hco_wothr *adsp_hco_wothr,
+                                  dsd_htun_h dsp_htun_h,
+                                  struct dsd_gather_i_1 *adsp_gather ) {
+} /* end m_htun_sess_send()                                            */
+
+extern "C" void m_htun_sess_close( dsd_htun_h dsp_htun_h ) {
+} /* end m_htun_sess_close()                                           */
Index: hob-xsclib01.h
===================================================================
--- hob-xsclib01.h	(revision 2)
+++ hob-xsclib01.h	(revision 6)
@@ -215,7 +215,7 @@
 #define DEF_AUX_RADIUS_GET_ATTR    35       /* get attributes from received Radius packet */
 #endif
 #ifndef DEF_AUX_CONN_PREPARE
-#define DEF_AUX_CONN_PREPARE       36       /* prepare for connect HLWSPAT2 */
+#define DEF_AUX_CONN_PREPARE       36       /* prepare for connect HOB-WSP-AT3 */
 #endif
 #ifndef DEF_AUX_GET_PRIV_PERS
 #define DEF_AUX_GET_PRIV_PERS      37       /* return priviliges of user entry */
@@ -380,6 +380,27 @@
 #ifndef DEF_AUX_SECURE_RANDOM
 #define DEF_AUX_SECURE_RANDOM      90       /* get secure random       */
 #endif
+#ifndef DEF_AUX_GET_WSP_FINGERPRINT
+#define DEF_AUX_GET_WSP_FINGERPRINT 91      /* get WSP fingerprint     */
+#endif
+#ifndef DEF_AUX_PIPE
+#define DEF_AUX_PIPE               92       /* aux-pipe                */
+#endif
+#ifndef DEF_AUX_UTILITY_THREAD
+#define DEF_AUX_UTILITY_THREAD     93       /* create unitliy thread   */
+#endif
+#ifndef DEF_AUX_SWAP_STOR
+#define DEF_AUX_SWAP_STOR          94       /* manage swap storage     */
+#endif
+#ifndef DEF_AUX_DYN_LIB
+#define DEF_AUX_DYN_LIB            95       /* manage dynamic library  */
+#endif
+#ifndef DEF_AUX_SIG_GET_CLIENT
+#define DEF_AUX_SIG_GET_CLIENT     96       /* signature - get client credentials */
+#endif
+#ifndef DEF_AUX_SIG_SIGN_NONCE
+#define DEF_AUX_SIG_SIGN_NONCE     97       /* signature - sign nonce  */
+#endif
 #ifdef XYZ1  /* use DEF_AUX_GET_SESSION_INFO */
 #ifndef DEF_AUX_QUERY_SERVER
 #define DEF_AUX_QUERY_SERVER       18       /* query server connection, TCP or other */
@@ -935,6 +956,9 @@
    ied_scp_soap,                            /* protocol SOAP           */
    ied_scp_ms_rpc,                          /* protocol MS-RPC         */
    ied_scp_websocket,                       /* protocol WebSocket      */
+   ied_scp_hl_dash,                         /* protocol HOBLink data share */
+   ied_scp_dg_out_d,                        /* protocol MS DG_OUT_DATA */
+   ied_scp_dg_in_d,                         /* protocol MS DG_IN_DATA  */
    ied_scp_spec                             /* special protocol        */
 };

@@ -1904,6 +1928,43 @@
    void *     vpc_aux_pipe_handle;          /* handle of aux-pipe      */
 };

+struct dsd_aux_util_thread_param_1 {        /* utility thread parameter */
+   int xyz1;
+};
+
+enum ied_aux_dyn_lib_command {              /* dynamic library command */
+   ied_adlc_invalid = 0,                    /* invalid value           */
+   ied_adlc_load,                           /* load dynamic library    */
+   ied_adlc_unload,                         /* unload dynamic library  */
+   ied_adlc_entry                           /* return entry of dynamic library */
+};
+
+enum ied_ret_dyn_lib_def {                  /* return code dynamic library */
+   ied_ret_dl_ok,                           /* command returned o.k.   */
+// to-do 06.12.12 KB
+   ied_ret_dlg_idset1_not_found               /* ident not found         */
+};
+
+struct dsd_aux_dyn_lib_req_1 {              /* dynamic library request */
+   enum ied_aux_dyn_lib_command iec_adlc;   /* dynamic library command */
+   enum ied_ret_dyn_lib_def iec_ret_dl;     /* return code dynamic library */
+   void *     vpc_aux_dyn_lib_handle;       /* handle of dynamic library */
+   void *     vpc_aux_dyn_lib_entry;        /* entry in dynamic library */
+   union {
+     struct dsd_unicode_string dsc_dyn_lib_name;  /* name and path dynamic library */
+     struct dsd_unicode_string dsc_dyn_lib_entry;  /* name of entry of dynamic library */
+   };
+};
+
+typedef void ( * amd_util_thread )( struct dsd_aux_util_thread_param_1 * );
+
+struct dsd_aux_util_thread_call_1 {         /* create utility thread   */
+   amd_util_thread amc_util_thread;         /* entry of utility thread */
+   struct dsd_aux_util_thread_param_1 *adsc_aux_util_thread_param_1;  /* paramter call utility thread */
+   int        imc_thread_priority;          /* priority of utility thread to be created */
+   BOOL       boc_thread_priority_relative;  /* priority of utility thread to be created is relative */
+};
+
 typedef void ( * amd_hlclib01 )( struct dsd_hl_clib_1 * );
 typedef void ( * amd_call_hrl_1 )( struct dsd_hrl_call_1 * );
 typedef void ( * amd_call_phl_1 )( struct dsd_phl_call_1 * );
Index: SOFTWARE.HLSEC.THREAD02.act.txt
===================================================================
--- SOFTWARE.HLSEC.THREAD02.act.txt	(revision 0)
+++ SOFTWARE.HLSEC.THREAD02.act.txt	(revision 6)
@@ -0,0 +1,183 @@
+
+
+
+
+
+
+         Threads used in the HOB WebSecureProxy (WSP),
+         IBIPGW08 for Windows, nbipgw20 for Unix
+
+         1. Overview
+
+         Machine instructions to be executed need to run on a thread, as
+         long as we see userspace, not the kernel with interrupts.
+
+         Modern software needs to run on many kernels, otherwise high
+         performance cannot be reached.
+
+         The design of the thread usage is one of the most important
+         points in any application.
+
+         This document desribes the usage of threads in the HOB
+         WebSecureProxy (WSP).
+
+         2. HOB Control
+
+         In the WSP, the load, meaning to most CPU cycles, is processed
+         on work threads. These work threads are implemented in a
+         component call HOB Control.
+         This component is described in HOBTEXT SOFTWARE.COSTAND.CONTR1,
+         and implemented in xslcontr.cpp.
+         The C/C++ header file for HOB Control is hob-xslcontr.h
+
+         Work threads are started whenever needed and never terminate,
+         they are reused when new load needs to be processed.
+
+         The maximum number of work threads used, both the total number
+         of threads and the number of active threads, can be configured
+         in the XML-configuration-file of the WSP.
+
+         The maximum number of work threads should correspond to the
+         number of CPUs = kernels in the underlying hardware.
+
+         HOB Control also contains (optionally) one additional thread to
+         handle all timers.
+
+         3. The Thread of main()
+
+         The WSP is started by the OS calling main(). main()
+         automatically has a thread associated with it.
+         main() processes the XML-configuration-file of the WSP, by
+         calling Xerces which calls m_build_conf_01() implemented in
+         xsipgw08-conf.cpp. During and after processing
+         m_build_conf_01(), other components of the WSP are started.
+         After this startup, the thread of main() has little work.
+         The thread of main() does the Report messages, giving statistics
+         to the console and log (as far as configured).
+
+         3.1. IBIPGW08 Reload of Configuration
+
+         IBIPGW08 (Windows) can, as far as configured, check if the
+         XML-configuration-file has changed and if there was a change, it
+         can apply the new configuration to the WSP.
+         All this is done on the thread of main().+
+
+
+
+
+
+         3.2. nbipgw20 Communication with the Listen-Gateway nbipgw19
+
+         nbipgw20 starts communication to the listen-gateway nbipgw19 and
+         handles all necessary communication (as far as a listen-gateway
+         is configured).
+         All this is done on the thread of main().
+
+         3.3. Stopping the WSP
+
+         Stopping the WSP is also done on the thread of main() by main()
+         simply returning to the OS.
+         In nbipgw20, Unix, the thread of main() gets notifications from
+         signals, these are forwarded thru a Unix pipe.
+
+         4. Threads for Communication
+
+         4.1. Non-Blocking-Accept
+
+         Non-Blocking-Accept is a part of TCPCOMP, but at the moment
+         implemented in sources different from TCPCOMP.
+
+         Non-Blocking-Accept for incomming TCP connections, after
+         listen(), needs to be done on threads managed by this component.
+         This component uses non-blocking sockets, so that one thread can
+         handle many sockets. In IBIPGW08 (Windows),
+         WSAWaitForMultipleEvents() is used, in nbipgw20 (Unix) poll() is
+         used.
+
+         As a single wait OS call can handle only a certain number of
+         sockets, the component Non-Blocking-Accept starts more if
+         needed.
+
+         Non-Blocking-Accept calls callback routines when something
+         happens. These callback routines should return after a short
+         time, otherwise other connections = users would get slow
+         performance.
+
+         4.2. Streaming Socket IO
+
+         Streaming Socket IO is handled by TCPCOMP.
+         Streaming Sockets mostly are TCP connections, in nbipgw20 (Unix)
+         this can also be Unix sockets.
+
+         Management to streaming sockets needs to be done on threads
+         managed by TCPCOMP. This component uses non-blocking sockets, so
+         that one thread can handle many sockets. In IBIPGW08 (Windows),
+         WSAWaitForMultipleEvents() is used, in nbipgw20 (Unix) poll() or
+         epoll() is used.
+
+         As a single wait OS call can handle only a certain number of
+         sockets, the component TCPCOMP starts more if needed.
+
+         TCPCOMP calls callback routines when something happens. These
+         callback routines should return after a short time, otherwise
+         other connections = users would get slow performance.+
+
+
+
+
+
+         4.3. UDP Processing
+
+         UDP (User Datagram Protocol) is handled by the component
+         xs-gw-udp-01.cpp.
+
+         The UDP component uses non-blocking sockets, so that one thread
+         can handle many sockets. In IBIPGW08 (Windows),
+         WSAWaitForMultipleEvents() is used, in nbipgw20 (Unix) poll() or
+         epoll() is used.
+
+         As a single wait OS call can handle only a certain number of
+         sockets, the UDP component starts more if needed.
+
+         The UDP component calls callback routines when something
+         happens. These callback routines should return after a short
+         time, otherwise other connections = users would get slow
+         performance.
+
+         5. Pass-Thru-to-Desktop, also called Desktop-on-Demand
+
+         The functionality Pass-Thru-to-Desktop or PTTD connects to a
+         desktop. Connecting to a desktop means sending wake-on-LAN
+         packets, doing DNS name-resolution and repeatedly trying to
+         connect to this desktop, either till the connect() succeeds, or
+         till the maximum time has elapsed. For this, a thread is started
+         in m_conn_pttd_thread(). This thread terminates after the work
+         is done, either successful or with fail.
+
+         At a certain time, any number of threads can be running inside
+         the WSP doing PTTD. But at most times, no thread doing PTTD is
+         running.
+         The typical lifetime of a thread doing PTTD is less than two
+         minutes.
+
+         6. Serialize Thread
+
+         One thread, m_serial_thread(), is started to manage ARP entries
+         and add or delete routes. This is needed by the component
+         HOB-TUN. Serialization is needed because otherwise there could
+         be race conditions.
+
+         The serialize thread is not started and used in nbipgw20 (Unix)
+         when a listen-gateway nbipgw19 is configured and used.
+
+         7. WSP-Trace-Thread
+
+         One thread, m_wsp_trace_thread(), is started for the output of
+         different trace messages. Trace message records are build on any
+         other thread, then passed to the WSP-trace-thread which does the
+         output.
+
+         09.11.12  KB+
\ No newline at end of file
Index: hob-hsstp01.h
===================================================================
--- hob-hsstp01.h	(revision 0)
+++ hob-hsstp01.h	(revision 6)
@@ -0,0 +1,210 @@
+#ifndef HOSHSSTP_H_INC
+#define HOSHSSTP_H_INC
+
+#define MAX_HSSTP_MSGLEN 1024 * 16
+
+#define MS_CHAP_V2
+
+class dsd_sstp_session;
+
+struct dsd_sstp_wrap {
+   dsd_sstp_session* adsc_sstp_session;
+   dsd_ppp_server_1 dsc_ppp_se_1;      // Associated PPP session.
+   dsd_timer_ele    dsc_timer_close;   // Timer for PPP session close.
+};
+
+inline dsd_sstp_session* m_sstp_session_from_s1(dsd_ppp_server_1* adsp_ppp_se_1)
+{
+   dsd_sstp_wrap* adsl_sstp_wrap = (dsd_sstp_wrap*)
+      ((char*)adsp_ppp_se_1 - offsetof(dsd_sstp_wrap, dsc_ppp_se_1));
+   return adsl_sstp_wrap->adsc_sstp_session;
+}
+
+inline dsd_sstp_session* m_sstp_session_from_te(dsd_timer_ele* adsp_timer_ele)
+{
+   dsd_sstp_wrap* adsl_sstp_wrap = (dsd_sstp_wrap*)
+      ((char*)adsp_timer_ele - offsetof(dsd_sstp_wrap, dsc_timer_close));
+   return adsl_sstp_wrap->adsc_sstp_session;
+}
+
+// Class representing an SSTP session.
+class dsd_sstp_session : public dsd_session
+{
+
+private:
+
+   // SSTP FSM states.
+   enum ied_sstp_state
+   {
+      ied_sstp_state_waithttp,
+      ied_sstp_state_waitcallconnreq,
+      ied_sstp_state_waitcallconnected,
+      ied_sstp_state_connected
+   };
+
+   // SSTP message types.
+   static const uint16_t SSTP_CONTROL_MSG = 0x0110;
+   static const uint16_t SSTP_DATA_MSG    = 0x0010;
+
+   // SSTP control message types.
+   static const uint16_t SSTP_MSG_CALL_CONNECT_REQ    = 0x0100;
+   static const uint16_t SSTP_MSG_CALL_CONNECT_ACK    = 0x0200;
+   static const uint16_t SSTP_MSG_CALL_CONNECTED      = 0x0400;
+   static const uint16_t SSTP_MSG_CALL_ABORT          = 0x0500;
+   static const uint16_t SSTP_MSG_CALL_DISCONNECT     = 0x0600;
+   static const uint16_t SSTP_MSG_CALL_DISCONNECT_ACK = 0x0700;
+   static const uint16_t SSTP_MSG_ECHO_REQ            = 0x0800;
+   static const uint16_t SSTP_MSG_ECHO_ACK            = 0x0900;
+
+   // SSTP control message attribute types.
+   static const byte SSTP_ATTR_ENCAPSULATED_PROTO = 0x01;
+   static const byte SSTP_ATTR_CRYPTO             = 0x03;
+   static const byte SSTP_ATTR_CRYPTO_REQ         = 0x04;
+
+   // Encapsulated Protocol attribute values.
+   static const uint16_t SSTP_ATTR_ENCAPSULATED_PROTO_PPP = 0x0100;
+
+   // Certificate Hash Protocol values.
+   static const byte HASH_PROTO_SHA1   = 0x01;
+   static const byte HASH_PROTO_SHA256 = 0x02;
+
+   // Current SSTP FSM state.
+   ied_sstp_state   iec_sstp_state;
+   dsd_ppp_client_1 dsc_ppp_cl_1;
+
+public:
+
+   dsd_sstp_wrap    dsc_sstp_wrap;
+   uint32_t         umc_client_ineta;  // Client VINETA.
+   uint32_t         umc_discard_count; // Number of messages discarded.
+   // Queue for messages which are to be sent to the client over the external
+   // network.
+   std::queue<dsd_queued_msg> dsc_sendto_extnw_msgq;
+
+private:
+
+   //
+   // Writes a Disconnect Ack SSTP control message.
+   // Writes to a buffer an SSTP Disconnect Ack control message. The buffer
+   // which is written to is referenced by adsp_buf_vec. The Disconnect Ack SSTP
+   // control message indicates to the client that his request to terminate the
+   // session has been received and accepted.
+   //
+   // @param  adsp_buf_vec  Pointer to the dsd_buf_vector_ele containing the
+   //                       buffer to write to.
+   //
+   void mc_make_sstp_disconnect_ack(dsd_buf_vector_ele *adsp_buf_vec);
+
+   //
+   // Writes a Call Abort SSTP control message.
+   // Writes to a buffer an SSTP Call Abort control message. The buffer which is
+   // written to is referenced by adsp_buf_vec. The Call Abort SSTP control
+   // message requests the client to abort the session.
+   //
+   // @param  adsp_buf_vec  Pointer to the dsd_buf_vector_ele containing the
+   //                       buffer to write to.
+   //
+   void mc_make_sstp_call_abort(dsd_buf_vector_ele* adsp_buf_vec);
+
+   //
+   // Aborts the SSTP session.
+   // Terminates the entire session by generating an SSTP Call Abort message and
+   // sending it to the client.
+   //
+   void mc_abort_sstp_conn();
+
+public:
+
+   //
+   // Default constructor.
+   // Not implemented.
+   //
+   dsd_sstp_session();
+
+   //
+   // Constructor.
+   // Initializes the SSTP session object.
+   //
+   // @param  adsp_sess_info  Configuration for the new session.
+   //
+   dsd_sstp_session(dsd_tun_start_ppp * adsp_tun_start1,
+                    dsd_tun_contr_conn* adsp_sess_info,
+                    dsd_tun_contr_ineta* adsp_ineta_info);
+
+   //
+   // Copy constructor.
+   // Not implemented.
+   //
+   dsd_sstp_session(const dsd_sstp_session& dsp_orig);
+
+   //
+   // Copy assignment operator.
+   // Not implemented.
+   //
+   const dsd_sstp_session& operator=(const dsd_sstp_session& dsp_rhs);
+
+   //
+   // Destructor.
+   // Performs the necessary cleanup.
+   //
+   ~dsd_sstp_session();
+
+   //
+   // Initializes the SSTP session.
+   // Must be called before any other methods are called on the object. Performs
+   // any initialisation of the object which might possibly fail.
+   //
+   // @return  Returns a value which is < 0 on faliure.
+   //
+   virtual int32_t mc_init();
+
+   virtual void mc_close();
+
+   //
+   // Processes the message header.
+   // Reads the contents of the message header and updates the session
+   // accordingly. Depending on the header contents, this can trigger a
+   // response to the session client, the transfer of data over the internal
+   // network, or the updating of the session object.
+   //
+   // @param  adsp_gather  Gather struct containing message to be interpreted.
+   // @param  adsp_hco_wothr  Pointer to the calling workthread.
+   //
+   // @return  Returns a value which is < 0 on faliure.
+   //
+   virtual int32_t mc_interpret_msg(dsd_gather_i_1* adsp_gather,
+                                    dsd_hco_wothr*  adsp_hco_wothr);
+
+   //
+   // Adds an SSTP header to the data.
+   // Encapsulates the data in an SSTP header, and sends the message over to
+   // the session client.
+   //
+   // @param  ap_handle   Handle to the buffer containing the data to
+   //                     encapsulate.
+   // @param  aucp_data   Pointer to the buffer containing the data to
+   //                     encapsulate.
+   // @param  ump_length  Length, in bytes, of the data to encapsulate.
+   //
+   // @return  Returns a value which is < 0 on faliure.
+   //
+   virtual int32_t mc_encapsulate_msg(void*  ap_handle,
+                                    byte*    abyp_data,
+                                    uint32_t ump_length);
+
+   int32_t mc_tunnel_to_cl(void*    ap_handle,
+                           byte*    abyp_data,
+                           uint32_t ump_length);
+
+   //
+   // Adds an SSTP header to the data.
+   // Encapsulates the data in an SSTP header, and sends the message over to
+   // the session client.
+   //
+   // @param  adsp_vector  Buffer containing data to be encapsulates and sent.
+   //
+   void mc_sstp_tunnel_data(dsd_buf_vector_ele* adsp_vector);
+
+};
+
+#endif
Index: xs-gw-cluster.cpp
===================================================================
--- xs-gw-cluster.cpp	(revision 2)
+++ xs-gw-cluster.cpp	(revision 6)
@@ -219,7 +219,11 @@
 static void m_acc_errorcallback( class dsd_nblock_acc *, void *, char *, int, int );  /* error callback function */
 static void m_acceptcallback( class dsd_nblock_acc *, void *, int, struct sockaddr *, int );
 static void m_cb_conn_err( class dsd_tcpcomp *, void *, struct sockaddr *, socklen_t, int, int, int );
+#ifdef B121120
 static void m_conncallback( class dsd_tcpcomp *, void *, struct sockaddr *, socklen_t, int );  /* connect callback function */
+#else
+static void m_conncallback( class dsd_tcpcomp *, void *, struct dsd_target_ineta_1 *, void *, struct sockaddr *, socklen_t, int );  /* connect callback function */
+#endif
 static void m_sendcallback( class dsd_tcpcomp *, void * );  /* send callback function */
 static int m_getrecvbuf( class dsd_tcpcomp *, void *, void **, char **, int ** );  /* get receive buffer callback function */
 static BOOL m_recvcallback( class dsd_tcpcomp *, void *, void * );  /* receive callback function */
@@ -385,12 +389,12 @@
 #endif

    p_start_80:                              /* initialization complete */
-   m_set_lb_formula( adsp_cluster_main->achc_lbal_formula, adsp_cluster_main->imc_lbal_len_formula );  /* load-balancing-formula UTF-8 */
 #ifdef HL_UNIX
    if (adsp_cluster_main == NULL) {         /* no cluster configured   */
      goto p_uds_00;                         /* start Unix domain socket */
    }
 #endif
+   m_set_lb_formula( adsp_cluster_main->achc_lbal_formula, adsp_cluster_main->imc_lbal_len_formula );  /* load-balancing-formula UTF-8 */
    if (adsp_cluster_main->imc_lbal_intv) {  /* <interval-load-balancing-probe> */
      dsg_sys_state_1.imc_load_balancing_value = m_get_load();  /* last value returned by load-balancing */
 #ifdef TRACEHL_LOAD
@@ -783,6 +787,9 @@
               adsl_clact_w1,
               &adsl_clact_w1->adsc_clrem->dsc_bind_multih,  /* for bind multihomed */
               adsl_clact_w1->adsc_clrem->adsc_remote_ineta,  /* remote INETA */
+#ifndef B121120
+              NULL,                         /* INETA to free           */
+#endif
               adsl_clact_w1->adsc_clrem->imc_port,  /* port of remote WSP */
               TRUE );                       /* do connect round-robin <connect-round-robin> */
    if (iml_rc) {                            /* error occured           */
@@ -910,6 +917,9 @@

 /** TCPCOMP connect callback function                                  */
 static void m_conncallback( class dsd_tcpcomp *adsp_tcpco, void *vpp_userfld,
+#ifndef B121120
+                            struct dsd_target_ineta_1 *, void *,
+#endif
                             struct sockaddr *adsp_soa, socklen_t imp_len_soa, int imp_error ) {
    int        iml_rc;                       /* return code             */
    struct dsd_cluster_active *adsl_clact;   /* active cluster entry    */
@@ -1778,7 +1788,7 @@
 #else
    if (   (iel_clr_stat == ied_clrs_open)   /* state was open          */
        || (iel_clr_stat == ied_clrs_timed_out)) {  /* state is timed out */
-     m_status_cluster_lbal();               /* do load-balancing again */
+     m_status_cluster_lbal( FALSE );        /* do load-balancing again */
    }
    m_check_reco_cluster();                  /* set timer for reconnect */
 #endif
@@ -1864,6 +1874,10 @@
    ADSL_GAI1_W1->achc_ginp_cur = achl_w2;
    ADSL_GAI1_W1->achc_ginp_end = achl_w2 + iml2;
    ADSL_GAI1_W1->adsc_next = ADSL_GAI1_W1 + 1;
+   if (adss_cluster_main == NULL) {         /* cluster not configured  */
+     ADSL_GAI1_W1->adsc_next = NULL;        /* end of data             */
+     goto p_send_02;                        /* send packet             */
+   }
 #undef ADSL_GAI1_W1
 #define ADSL_GAI1_W1 ((struct dsd_gather_i_1 *) (adsl_clsend_w1 + 1) + 4)
    achl_w1 = (char *) adsl_clsend_w1 + LEN_TCP_RECV - 8 - 26 - DEF_LEN_FINGERPRINT - 8;
@@ -1950,6 +1964,8 @@
        = adss_cluster_main->achc_this_url + adss_cluster_main->imc_this_len_url;
    }
    adsl_gai1_w1->adsc_next = NULL;          /* end of chain            */
+
+   p_send_02:                               /* send packet             */
 #ifdef OLD01
    iml1 = adsp_clact->dsc_tcpcomp.m_send_gather( adsl_gai1_start, &adsl_gai1_w1 );
 #ifdef TRACEHL1
@@ -3287,7 +3303,7 @@
      goto p_lbal_40;                        /* status set              */
    }
    iml1 = (adsp_clact->imc_lbal_epoch_recv - adsp_clact->imc_lbal_epoch_sent) * 10;
-   bol1 = m_status_cluster_lbal();
+   bol1 = m_status_cluster_lbal( FALSE );
    achl_status = "03 status already set";   /* text with status        */
    iml_trace_line = __LINE__;               /* line of trace           */
    if (bol1) {                              /* status already sent to all connected WSPs */
@@ -3332,7 +3348,7 @@
 } /* end m_recv_cluster_lbal()                                         */

 /** calculate the new state of load-balancing                          */
-extern "C" BOOL m_status_cluster_lbal( void ) {
+extern "C" BOOL m_status_cluster_lbal( BOOL bop_listen_started ) {
    BOOL       bol1;                         /* working variable        */
    int        iml1;                         /* working variable        */
 #ifdef TRACEHL1
@@ -3455,18 +3471,35 @@
      m_wsp_trace_out( adsl_wt1_w1 );        /* output of WSP trace record */
    }
    bol_ret = FALSE;                         /* return value            */
+#ifdef B121107
    bol1 = FALSE;                            /* state did not change    */
+#else
+   bol1 = bop_listen_started;               /* set if state changed    */
+#endif
    if (bol_listen_active == dsg_sys_state_1.boc_listen_active) goto p_stat_40;  /* nothing changed */
+#ifndef HL_UNIX
    bol1 = TRUE;                             /* state did change        */
+#endif
 // dsg_sys_state_1.boc_listen_active = bol_listen_active;  /* set new state */
    if (bol_listen_active) {                 /* start listening         */
      iml1 = m_start_all_listen( TRUE );
+#ifdef HL_UNIX
+     if (iml1 < 0) {                        /* listen-gateway - already started */
+       goto p_stat_40;                      /* all done - restart timer */
+     }
+#endif
      m_hlnew_printf( HLOG_INFO1, "HWSPCL0053I Cluster load %d listen started ports %d.",
                      dsg_sys_state_1.imc_load_balancing_value, iml1 );
+#ifdef HL_UNIX
+     bol1 = dsg_sys_state_1.boc_listen_active;  /* state did change    */
+#endif
    } else {                                 /* stop listening          */
      iml1 = m_stop_all_listen( TRUE );
      m_hlnew_printf( HLOG_INFO1, "HWSPCL0052I Cluster load %d listen stopped ports %d.",
                      dsg_sys_state_1.imc_load_balancing_value, iml1 );
+#ifdef HL_UNIX
+     bol1 = TRUE;                           /* state did change        */
+#endif
    }
 #ifdef B120829
    adsl_clact_w1 = adsg_clact_ch;           /* get chain of active cluster entries */
@@ -5213,6 +5246,9 @@
               adsl_clact_w1,
               &adsl_clact_w1->adsc_clrem->dsc_bind_multih,  /* for bind multihomed */
               adsl_clact_w1->adsc_clrem->adsc_remote_ineta,  /* remote INETA */
+#ifndef B121120
+              NULL,                         /* INETA to free           */
+#endif
               adsl_clact_w1->adsc_clrem->imc_port,  /* port of remote WSP */
               TRUE );                       /* do connect round-robin <connect-round-robin> */
    if (iml_rc) {                            /* error occured           */
Index: SV-WSP-N-23-KB-source.bat
===================================================================
--- SV-WSP-N-23-KB-source.bat	(revision 2)
+++ SV-WSP-N-23-KB-source.bat	(revision 6)
@@ -11,6 +11,7 @@
 copy /Y D:\AKBI61\HLSEC\xiipgw08-pttd.cpp D:\AKBI63\SV-WSP-23\nbipgw20-V23\S\
 copy /Y D:\AKBI61\HLSEC\xiipgw08-trace.cpp D:\AKBI63\SV-WSP-23\nbipgw20-V23\S\
 copy /Y D:\AKBI61\HLSEC\xiipgw08-admin.cpp D:\AKBI63\SV-WSP-23\nbipgw20-V23\S\
+copy /Y D:\AKBI61\HLSEC\xiipgw08-tun.cpp D:\AKBI63\SV-WSP-23\nbipgw20-V23\S\
 copy /Y D:\AKBI61\HLSEC\xs-gw-admin.cpp D:\AKBI63\SV-WSP-23\nbipgw20-V23\S\
 copy /Y D:\AKBI61\HLSEC\xs-gw-cluster.cpp D:\AKBI63\SV-WSP-23\nbipgw20-V23\S\
 copy /Y D:\AKBI61\HLSEC\xs-gw-l2tp.cpp D:\AKBI63\SV-WSP-23\nbipgw20-V23\S\
@@ -38,7 +39,6 @@
 copy /Y D:\AKBI61\HLSEC\xsl-stor-big-n.cpp D:\AKBI63\SV-WSP-23\nbipgw20-V23\S\
 copy /Y D:\AKBI61\HLSEC\XSBSTR01.hpp D:\AKBI63\SV-WSP-23\nbipgw20-V23\S\
 copy /Y D:\AKBI61\HLSEC\XSLBGW01.hpp D:\AKBI63\SV-WSP-23\nbipgw20-V23\S\
-copy /Y D:\AKBI62\SOURCE-WSP-23\hob-tun01.h D:\AKBI63\SV-WSP-23\nbipgw20-V23\S\
 copy /Y D:\AKBI62\SOURCE-WSP-23\hob-perf-data-1.h D:\AKBI63\SV-WSP-23\nbipgw20-V23\S\
 copy /Y D:\AKBI62\SOURCE-WSP-23\hob-ldap01.hpp D:\AKBI63\SV-WSP-23\nbipgw20-V23\S\
 copy /Y D:\AKBI62\SOURCE-WSP-23\xsregex01.c D:\AKBI63\SV-WSP-23\nbipgw20-V23\S\
@@ -79,13 +79,28 @@
 copy /Y D:\AKBI62\SOURCE-WSP-23\xs-htcp-tcpip-hdr.cpp D:\AKBI63\SV-WSP-23\nbipgw20-V23\S\
 copy /Y D:\AKBI62\SOURCE-WSP-23\xs-ipgw08-snmp-01.cpp D:\AKBI63\SV-WSP-23\nbipgw20-V23\S\
 copy /Y D:\AKBI62\SOURCE-WSP-23\xs-lbal-win-1.cpp D:\AKBI63\SV-WSP-23\nbipgw20-V23\S\
-copy /Y D:\AKBI62\SOURCE-WSP-23\xshpppi01.cpp D:\AKBI63\SV-WSP-23\nbipgw20-V23\S\
-copy /Y D:\AKBI62\SOURCE-WSP-23\xshsessutil01.cpp D:\AKBI63\SV-WSP-23\nbipgw20-V23\S\
-copy /Y D:\AKBI62\SOURCE-WSP-23\xshsstp01.cpp D:\AKBI63\SV-WSP-23\nbipgw20-V23\S\
-copy /Y D:\AKBI62\SOURCE-WSP-23\xshusip01.cpp D:\AKBI63\SV-WSP-23\nbipgw20-V23\S\
 copy /Y D:\AKBI62\SOURCE-WSP-23\xsldapco1.cpp D:\AKBI63\SV-WSP-23\nbipgw20-V23\S\
 copy /Y D:\AKBI62\SOURCE-WSP-23\xsltime1.cpp D:\AKBI63\SV-WSP-23\nbipgw20-V23\S\
 copy /Y D:\AKBI62\SOURCE-WSP-23\xstuntapif.cpp D:\AKBI63\SV-WSP-23\nbipgw20-V23\S\
+copy /Y D:\AKBI62\SOURCE-NEWWSPV23U\hob-tun01.h D:\AKBI63\SV-WSP-23\nbipgw20-V23\S\
+copy /Y D:\AKBI62\SOURCE-NEWWSPV23U\xstuntapif.cpp D:\AKBI63\SV-WSP-23\nbipgw20-V23\S\
+copy /Y D:\AKBI62\SOURCE-NEWWSPV23U\xshusip01.cpp D:\AKBI63\SV-WSP-23\nbipgw20-V23\S\
+copy /Y D:\AKBI62\SOURCE-NEWWSPV23U\xshsstp01.cpp D:\AKBI63\SV-WSP-23\nbipgw20-V23\S\
+copy /Y D:\AKBI62\SOURCE-NEWWSPV23U\xshsessutil01.cpp D:\AKBI63\SV-WSP-23\nbipgw20-V23\S\
+copy /Y D:\AKBI62\SOURCE-NEWWSPV23U\xshpppi01.cpp D:\AKBI63\SV-WSP-23\nbipgw20-V23\S\
+copy /Y D:\AKBI62\SOURCE-NEWWSPV23U\xs-htcp-01.cpp D:\AKBI63\SV-WSP-23\nbipgw20-V23\S\
+copy /Y D:\AKBI62\SOURCE-NEWWSPV23U\xs-htcp-hdr-01.cpp D:\AKBI63\SV-WSP-23\nbipgw20-V23\S\
+copy /Y D:\AKBI62\SOURCE-NEWWSPV23U\xs-htcp-htun-01.cpp D:\AKBI63\SV-WSP-23\nbipgw20-V23\S\
+copy /Y D:\AKBI62\SOURCE-NEWWSPV23U\hob-tuntapif01.h D:\AKBI63\SV-WSP-23\nbipgw20-V23\S\
+copy /Y D:\AKBI62\SOURCE-NEWWSPV23U\hob-sessutil01.h D:\AKBI63\SV-WSP-23\nbipgw20-V23\S\
+copy /Y D:\AKBI62\SOURCE-NEWWSPV23U\hob-session01.h D:\AKBI63\SV-WSP-23\nbipgw20-V23\S\
+copy /Y D:\AKBI62\SOURCE-NEWWSPV23U\hob-hppp01.h D:\AKBI63\SV-WSP-23\nbipgw20-V23\S\
+copy /Y D:\AKBI62\SOURCE-NEWWSPV23U\hob-hsstp01.h D:\AKBI63\SV-WSP-23\nbipgw20-V23\S\
+copy /Y D:\AKBI62\SOURCE-NEWWSPV23U\hob-htcp-01.h D:\AKBI63\SV-WSP-23\nbipgw20-V23\S\
+copy /Y D:\AKBI62\SOURCE-NEWWSPV23U\hob-htcp-hdr-01.h D:\AKBI63\SV-WSP-23\nbipgw20-V23\S\
+copy /Y D:\AKBI62\SOURCE-NEWWSPV23U\hob-htcp-htun-01.h D:\AKBI63\SV-WSP-23\nbipgw20-V23\S\
+copy /Y D:\AKBI62\SOURCE-NEWWSPV23U\hob-htcp-int-01.h D:\AKBI63\SV-WSP-23\nbipgw20-V23\S\
+copy /Y D:\AKBI61\HLSEC\nst-tun-dummy-1.cpp D:\AKBI63\SV-WSP-23\nbipgw20-V23\S\
 copy /Y D:\AKBI61\UTIL\xsllog01.cpp D:\AKBI63\SV-WSP-23\nbipgw20-V23\S\
 copy /Y D:\AKBI61\UTIL\hob-tcp-sync-01.h D:\AKBI63\SV-WSP-23\nbipgw20-V23\S\
 copy /Y D:\AKBI61\UTIL\xsl-tcp-sync-01.cpp D:\AKBI63\SV-WSP-23\nbipgw20-V23\S\
@@ -121,7 +136,10 @@
 copy /Y D:\HOBEXE\hob-llog01.h D:\AKBI63\SV-WSP-23\nbipgw20-V23\S\
 copy /Y D:\AKBI61\HLSEC\comp-LINUX-nbipgw19-d2 D:\AKBI63\SV-WSP-23\nbipgw20-V23\S\
 copy /Y D:\AKBI61\HLSEC\comp-LINUX-nbipgw20-d2 D:\AKBI63\SV-WSP-23\nbipgw20-V23\S\
+copy /Y D:\AKBI61\HLSEC\comp-LINUX-nbipgw19-tun1 D:\AKBI63\SV-WSP-23\nbipgw20-V23\S\
+copy /Y D:\AKBI61\HLSEC\comp-LINUX-nbipgw20-tun2 D:\AKBI63\SV-WSP-23\nbipgw20-V23\S\
 copy /Y D:\AKBI62\HOBTEXT\SOFTWARE.HLSEC.WSPDESI1.act.txt D:\AKBI63\SV-WSP-23\nbipgw20-V23\S\
+copy /Y D:\AKBI62\HOBTEXT\SOFTWARE.HLSEC.THREAD02.act.txt D:\AKBI63\SV-WSP-23\nbipgw20-V23\S\
 copy /Y D:\AKBI62\HOBTEXT\SOFTWARE.HLSEC.CSSSL01.act.txt D:\AKBI63\SV-WSP-23\nbipgw20-V23\S\
 copy /Y D:\AKBI62\HOBTEXT\SOFTWARE.HLSEC.HOBRDPE1.act.txt D:\AKBI63\SV-WSP-23\nbipgw20-V23\S\
 copy /Y D:\AKBI62\HOBTEXT\SOFTWARE.HLSEC.HOBRDPE3.act.txt D:\AKBI63\SV-WSP-23\nbipgw20-V23\S\
@@ -134,15 +152,18 @@
 copy /Y D:\AKBI62\HOBTEXT\SOFTWARE.HLSEC.RADIUS03.act.txt D:\AKBI63\SV-WSP-23\nbipgw20-V23\S\
 copy /Y D:\AKBI62\HOBTEXT\SOFTWARE.HLSEC.WSPAUTH1.act.txt D:\AKBI63\SV-WSP-23\nbipgw20-V23\S\
 copy /Y D:\AKBI62\HOBTEXT\SOFTWARE.HLSEC.WSPAUTH2.act.txt D:\AKBI63\SV-WSP-23\nbipgw20-V23\S\
+copy /Y D:\AKBI62\HOBTEXT\SOFTWARE.HLSEC.WSPADM2.act.txt D:\AKBI63\SV-WSP-23\nbipgw20-V23\S\
 copy /Y D:\AKBI62\HOBTEXT\SOFTWARE.HLSEC.WSPTUN08.act.txt D:\AKBI63\SV-WSP-23\nbipgw20-V23\S\
 copy /Y D:\AKBI62\HOBTEXT\SOFTWARE.HLSEC.MS-RPC-1.act.txt D:\AKBI63\SV-WSP-23\nbipgw20-V23\S\
 copy /Y D:\AKBI62\HOBTEXT\SOFTWARE.HLSEC.SNMPTRAP.act.txt D:\AKBI63\SV-WSP-23\nbipgw20-V23\S\
 copy /Y D:\AKBI62\HOBTEXT\SOFTWARE.HLSEC.INETA01.act.txt D:\AKBI63\SV-WSP-23\nbipgw20-V23\S\
 copy /Y D:\AKBI62\HOBTEXT\SOFTWARE.HLSEC.TARGFIM1.act.txt D:\AKBI63\SV-WSP-23\nbipgw20-V23\S\
 copy /Y D:\AKBI62\HOBTEXT\SOFTWARE.HLSEC.HPPPT1P1.act.txt D:\AKBI63\SV-WSP-23\nbipgw20-V23\S\
+copy /Y D:\AKBI62\HOBTEXT\SOFTWARE.HLSEC.HPPPT1P2.act.txt D:\AKBI63\SV-WSP-23\nbipgw20-V23\S\
 copy /Y D:\AKBI62\HOBTEXT\SOFTWARE.HLSEC.WSP-NETW.act.txt D:\AKBI63\SV-WSP-23\nbipgw20-V23\S\
 copy /Y D:\AKBI62\HOBTEXT\SOFTWARE.HLSEC.WSPSDH02.act.txt D:\AKBI63\SV-WSP-23\nbipgw20-V23\S\
 copy /Y D:\AKBI62\HOBTEXT\SOFTWARE.HLSEC.AUXWEBSO.act.txt D:\AKBI63\SV-WSP-23\nbipgw20-V23\S\
+copy /Y D:\AKBI62\HOBTEXT\SOFTWARE.HLSEC.NBIPGW19.act.txt D:\AKBI63\SV-WSP-23\nbipgw20-V23\S\
 copy /Y D:\AKBI62\HOBTEXT\SOFTWARE.HLJWT.XSLBGW01.act.txt D:\AKBI63\SV-WSP-23\nbipgw20-V23\S\
 copy /Y D:\AKBI62\HOBTEXT\SOFTWARE.HLJWT.IBSELBXX.act.txt D:\AKBI63\SV-WSP-23\nbipgw20-V23\S\
 copy /Y D:\AKBI62\HOBTEXT\SOFTWARE.HLJWT.RADIUS01.act.txt D:\AKBI63\SV-WSP-23\nbipgw20-V23\S\
@@ -150,4 +171,5 @@
 copy /Y D:\AKBI62\HOBTEXT\SOFTWARE.COSTAND.TCPCOMP1.act.txt D:\AKBI63\SV-WSP-23\nbipgw20-V23\S\
 copy /Y D:\AKBI62\HOBTEXT\SOFTWARE.COSTAND.TCPCOMP2.act.txt D:\AKBI63\SV-WSP-23\nbipgw20-V23\S\
 copy /Y D:\AKBI62\HOBTEXT\SOFTWARE.COSTAND.CORELOG.act.txt D:\AKBI63\SV-WSP-23\nbipgw20-V23\S\
+copy /Y D:\AKBI62\HOBTEXT\SOFTWARE.KBPC.SSLI03.act.txt D:\AKBI63\SV-WSP-23\nbipgw20-V23\S\
 copy /Y D:\AKBI61\HLSEC\SV-WSP-N-23-KB-source.bat D:\AKBI63\SV-WSP-23\nbipgw20-V23\S\
Index: hob-tcpcomp-singthr.hpp
===================================================================
--- hob-tcpcomp-singthr.hpp	(revision 2)
+++ hob-tcpcomp-singthr.hpp	(revision 6)
@@ -10,6 +10,7 @@
 /*| ----------                                                        |*/
 /*|  Copyright (C) HOB Germany 2010                                   |*/
 /*|  Copyright (C) HOB Germany 2011                                   |*/
+/*|  Copyright (C) HOB Germany 2012                                   |*/
 /*|                                                                   |*/
 /*+-------------------------------------------------------------------+*/

@@ -25,6 +26,12 @@

 #define D_INCL_UNIX_SOCKET

+#ifndef HL_SOLARIS
+#ifndef HL_HPUX
+#define MSGHDR_CONTROL_AVAILABLE 1
+#endif
+#endif
+
 #ifndef HL_LONGLONG
 #ifndef HL_UNIX
 #define HL_LONGLONG LONGLONG
@@ -152,9 +159,18 @@
      int      imc_conn_no;                  /* number of connect       */
      BOOL     boc_cb_active;                /* callback routine is active */
      BOOL     boc_do_close;                 /* do close                */
+#ifdef D_INCL_UNIX_SOCKET
+     BOOL     boc_unix_socket;              /* is Unix socket          */
+#endif
      HL_LONGLONG ilc_used_round_robin;      /* used bits round robin   */
      socklen_t imc_len_soa_conn;
      struct sockaddr_storage dsc_soa_conn;
+#ifdef D_INCL_UNIX_SOCKET
+#ifndef MSGHDR_CONTROL_AVAILABLE
+     int      imc_msg_fd;                   /* file-descriptor received */
+#endif
+     struct msghdr dsc_msghdr;              /* last received message structure */
+#endif
 /**
  * Initiate dsd_tcpcomp.
  * @param amp_at_thread_start optional parameter - callback address of function which is called after a new thread was created
@@ -259,6 +275,11 @@
  */
      void m_sendnotify( void );

+#ifdef D_INCL_UNIX_SOCKET
+/** retrieve file-descriptor passed with last message received over Unix socket connection */
+     int m_get_unix_socket_fd( void );
+#endif
+
 /**
  * Starting connection: bind if needed execute non blocking connect till any first was successfuly or all failed
  * @param adsp_callback
Index: xsldapco1.cpp
===================================================================
--- xsldapco1.cpp	(revision 2)
+++ xsldapco1.cpp	(revision 6)
@@ -15,12 +15,12 @@
  * - UNIX  is the switch for a Linux Library.
  *
  * Required programs:
- * - MS Visual Studio .NET 2005                                           
+ * - MS Visual Studio .NET 2005, 2010 or 2012                                         
  * - MS Linker
  *
- * Copyright (C) HOB Germany 2005-2012
+ * Copyright (C) HOB Germany 2005-2013
  *
- * @version 1.01.0542
+ * @version 1.01.0552
  * @author  Juergen-Lorenz Lauenstein
  * @date    2005/08/16   (creation)
  * @date    2012/07/25   (svn 516)
@@ -30,6 +30,9 @@
  * @date    2012/10/11   (svn 536)
  * @date    2012/10/18   (svn 538)
  * @date    2012/11/06   (svn 542)
+ * @date    2012/11/21   (svn 547)
+ * @date    2012/11/27   (svn 549)
+ * @date    2013/01/22   (svn 552)
  *
  * @todo  save sessionnumber, do not use the current number
  * @todo  m_ldap_connect() - wait for a cleanup-event after an error retry
@@ -54,25 +57,24 @@
  * The LDAP-configuration is part of the WebSecureProxy-configuration and defines the parameters for
  * the connection like ip-address and port (nonSSL and SSL), the server type (e.g. MSAD), the administrator
  * bind for searching users without a distinguished name-paths and some other parameters. The document
- * \b[SOFTWARE.HLSEC.DOC-LDAP](@ref page1) contains detailed paragraphs for every parameter. It's recommended
+ * [SOFTWARE.HLSEC.DOC-LDAP](@ref page1) contains detailed paragraphs for every parameter. It's recommended
  * to use SSL for a server connection. Some operations like password change in a MSAD-environment require a
  * SSL connection. The HOB-LDAP supports a client-side SSL using the HOB implementation. The document
- * \b[SOFTWARE.HLSEC.CSSSL01](@ref page2) describes this scenario. 
+ * [SOFTWARE.HLSEC.CSSSL01](@ref page2) describes this scenario. 
  * Programmers find a detailed tutorial how to use the interface either at 
- * [HOB-Wiki](http://wiki.hob.de/wiki/attach/SoftwareDocumentation_Development/LDAP-Tutorial.pdf) or 
- * [LDAP-Tutorial](LDAP-Tutorial.rtf), if you are using the doxygen generated documentation.  
+ * [HOB-Wiki](http://wiki.hob.de/wiki/attach/SoftwareDocumentation_Development/LDAP-Tutorial.pdf "LDAP-Tutorial.pdf") or 
+ * [LDAP-Tutorial](LDAP-Tutorial.rtf "LDAP-Tutorial.rtf"), if you are using the doxygen generated documentation.  
  *
  * The LDAP interface uses two classes (dsd_ldap, dsd_ldap_control) for managing the LDAP- and the TCP-
  * protocol (tcpcomp01) and 5 helper classes, e.g. for the ASN.1-, the trace-management or others (dsd_bufm,
  * dsd_ldap_schema, dsd_asn1, dsd_error, dsd_trace). This module is loaded provides the following global functions:
  * m_ldap_init(), m_ldap_free(), m_ldap_request() and m_ldap_auth().
  * LDAP is loaded by a main program, e.g. the WebSecureProxy and acts as a 'pseudo' class, since the main program
- * has to call a 'pseudo'-constructor and -destructor to initialize or free the class. This is done by m_ldap_int()
+ * has to call a 'pseudo'-constructor and -destructor to initialize or free the class. This is done by m_ldap_init()
  * and m_ldap_free(). All LDAP-client requests are handled by m_ldap_request(). The function m_ldap_auth() supports
  * the authentication with a given userid and password only. All global functions (except m_ldap_auth) have the
  * class pointer as the parameter to address the the class instance. 
  *
- *
  * The following specifications are fulfilled, missing topics are marked:
  * - RFC 3045 (Storing Vendor Information in the LDAP rootDSE)
  * - RFC 4510 (Technical Specification Road Map) covers the following specifications:
@@ -107,6 +109,8 @@
 /*+----------------------------------------------------------------------------------------------+*/
 /*| System and library header files...                                                           |*/
 /*+----------------------------------------------------------------------------------------------+*/
+#define CLIENT_VERSION  "1.01.0552"
+
 #if defined (WIN32) || defined (WIN64)
 #include <cstdlib>
 #include <cstring>
@@ -120,7 +124,6 @@
 #include <windows.h>
 #elif defined (HL_UNIX)
 #define _ASSERTE(expr)
-#define _memicmp(a,b,c)  memcmp(a,b,c)
 #define _atoi64(a)       strtoll(a, NULL, 10)
 #define _ultoa(a,b,c)    ultoa(a, c, b, 20)

@@ -151,10 +154,8 @@
 #endif
 #include "hob-xslcontr.h"
 #include "hob-ssl-01.h"
-//#ifdef B121009
 //#include "hob-xshlcl01.h"
 //#include "hob-xshlse03.h"
-//#endif
 #include "hob-xsclib01.h"
 #include "hob-wsppriv.h"
 #include "hob-xbipgw08-1.h"
@@ -175,12 +176,12 @@
 /*+----------------------------------------------------------------------------------------------+*/
 /*| global function prototypes...                                                                |*/
 /*+----------------------------------------------------------------------------------------------+*/
-void mg_cb_connect    ( class dsd_tcpcomp *, void *, struct sockaddr *, socklen_t, int );
+void mg_cb_connect    ( class dsd_tcpcomp *, void *, struct dsd_target_ineta_1 *, void *, struct sockaddr *, socklen_t, int );
+void mg_cb_connect_err( class dsd_tcpcomp *, void *, struct sockaddr *, socklen_t, int, int, int );
 void mg_cb_send       ( class dsd_tcpcomp *, void * );
 int  mg_cb_getrecvbuf ( class dsd_tcpcomp *, void *, void **, char **, int ** );
 int  mg_cb_recv       ( class dsd_tcpcomp *, void *, void * ); 
 void mg_cb_error      ( class dsd_tcpcomp *, void *, char *, int, int );
-void mg_cb_connect_err( class dsd_tcpcomp *, void *, struct sockaddr *, socklen_t, int, int, int );
 void mg_cb_cleanup    ( class dsd_tcpcomp *, void * );
                  
 /*+----------------------------------------------------------------------------------------------+*/
@@ -194,6 +195,7 @@
 HL_LONGLONG         dsd_ldap::il_utc_time (0);        // utc time
 dsd_timer_ele       dsd_ldap::ds_timer_1;
 dsd_ldap_schema    *dsd_ldap::ads_schema_anc (NULL);  // ldap schema object chain for non MSAD servers
+void               *dsd_ldap::ads_hl_stor_glob (NULL); // global storage handler
 dsd_hcla_critsect_1 dsd_ldap::ds_cs_ldap;             // synchronisation object
 dsd_tcpcallback_t   dsd_ldap::ds_tcpcb = { mg_cb_connect_err, // tcpcomp callback structure
                                            mg_cb_connect, 
@@ -215,7 +217,26 @@
                                          "vendorversion",             // index: VVer
                                          NULL };

+const char *dsd_trace::achs_t_bind_auth[] = { "user",        // 0 [S_BIND_AUTH][ied_auth_user]
+                                              "pwd-change",  // 1 [S_BIND_AUTH][ied_auth_user_pwd_change]
+                                              "dn",          // 2 [S_BIND_AUTH][ied_auth_dn]
+                                              "admin",       // 3 [S_BIND_AUTH][ied_auth_admin]
+                                              "ntlm-1",      // 4 [S_BIND_AUTH][ied_auth_ntlm_type_1]
+                                              "ntlm-2",      // 5 [S_BIND_AUTH][ied_auth_ntlm_type_2]
+                                              "ntlm-3",      // 6 [S_BIND_AUTH][ied_auth_ntlm_type_3]
+                                              "sid"          // 7 [S_BIND_AUTH][ied_auth_sid]
+                                            };

+const char *dsd_trace::achs_t_sear_scope[] = { "baseobject",  // 0 [S_SEARCH_SCOPE][ied_sear_baseobject]
+                                               "onelevel",    // 1 [S_SEARCH_SCOPE][ied_sear_onelevel]
+                                               "sublevel",    // 2 [S_SEARCH_SCOPE][ied_sear_sublevel]
+                                               "children",    // 3 [S_SEARCH_SCOPE][ied_sear_children]
+                                               "superlevel",  // 4 [S_SEARCH_SCOPE][ied_sear_superlevel]
+                                               "root",        // 5 [S_SEARCH_SCOPE][ied_sear_root]
+                                               "basedn",      // 6 [S_SEARCH_SCOPE][ied_sear_basedn]
+                                               "attronly"     // 7 [S_SEARCH_SCOPE][ied_sear_attronly]
+                                             };
+
 // class dsd_error - LDAP error messages
 static struct dsd_error ds_ldap_errlist[] =
 {
@@ -328,12 +349,12 @@
  *
  * Get storage ssl-function. Allocates storage for any ssl-purposes.
  *
- * @param [in]  void  *vpp_userfld    user context address (e.g. 'this'-pointer)
- * @param [in]  int    imp_func       DEF_AUX_xxx function code
- * @param [in]  void  *avop_mem       pointer to the memory address
- * @param [in]  int    imp_size       requested memory size
+ * @param[in]  vpp_userfld    user context address (e.g. 'this'-pointer)
+ * @param[in]  imp_func       DEF_AUX_xxx function code
+ * @param[in]  avop_mem       pointer to the memory address
+ * @param[in]  imp_size       requested memory size
  *
- * @return      BOOL   TRUE if success, else FALSE
+ * @return     \b TRUE if success, else \b FALSE
  *
  * @todo  WSP error management
  */
@@ -381,11 +402,11 @@
  *
  * Function for the authentication of a given userid and password.
  *
- * @param [in]  struct dsd_ldap_group      *adsp_cfg_ldap     LDAP configuration parameters
- * @param [in]  struct dsd_unicode_string  *adsp_uc_userid    userid (unicode)
- * @param [in]  struct dsd_unicode_string  *adsp_uc_password  password (unicode)
+ * @param[in]  adsp_cfg_ldap     LDAP configuration parameters
+ * @param[in]  adsp_uc_userid    userid (unicode)
+ * @param[in]  adsp_uc_password  password (unicode)
  *
- * @return      enum ied_ret_ldap_def     a enumeration of possible return values
+ * @return     \b enum ied_ret_ldap_def   a enumeration of possible return values
  *
  * Comment:
  * LDAP-, TCP/IP- or other errors are send back as 'ied_ret_ldap_not_avail'
@@ -455,9 +476,9 @@
  *
  * SSL 'hello'-protoocl completed.
  *
- * @param [in]  struct dsd_hl_ssl_ccb_1 *adsp_ssl_ccb    corresponding ssl object
+ * @param[in]  adsp_ssl_ccb    corresponding ssl object
  *
- * @return      none
+ * @return     none
  */
 void mg_cb_ssl_compl( struct dsd_hl_ssl_ccb_1 *adsp_ssl_ccb )
 {
@@ -475,9 +496,9 @@
  *
  * LDAP utc-timer update interval completed.
  *
- * @param [in]  struct dsd_timer_ele  adsp_utc_timer   utc-timer structure
+ * @param[in]  adsp_utc_timer   utc-timer structure
  *
- * @return      none
+ * @return     none
  */
 void mg_cb_utc_timer( dsd_timer_ele *adsp_utc_timer )
 {
@@ -496,15 +517,23 @@
  *
  * Connect callback function. Close connections if an error occured.
  *
- * @param [in]  class dsd_tcpcomp *adsp_tcp           tcpcomp object for nonblocking IO
- * @param [in]  void              *adsp_ldap_control  ldap control object
- * @param [in]  struct sockaddr   *adsp_soa           sockaddr structure (ipv4 / ipv6)
- * @param [in]  socklen_t          imp_len_soa        length of the sockaddr structure
- * @param [in]  int                imp_error          error code
+ * @param[in]  adsp_tcp           tcpcomp object for nonblocking IO
+ * @param[in]  adsp_ldap_control  ldap control object
+ * @param[in]  adsp_target_ineta  todo: missing description (currently used as dummy)
+ * @param[in]  avop_free_til      todo: missing description (currently used as dummy)
+ * @param[in]  adsp_soa           sockaddr structure (ipv4 oripv6)
+ * @param[in]  imp_len_soa        length of the sockaddr structure
+ * @param[in]  imp_error          error code
  *
- * @return      none
+ * @return     none
  */
-void mg_cb_connect( class dsd_tcpcomp *adsp_tcp, void *adsp_ldap_control, struct sockaddr *adsp_soa, socklen_t imp_len_soa, int imp_error )
+void mg_cb_connect( class dsd_tcpcomp         *adsp_tcp,
+                    void                      *adsp_ldap_control,
+                    struct dsd_target_ineta_1 *adsp_target_ineta,
+                    void                      *avop_free_til,
+                    struct sockaddr           *adsp_soa,
+                    socklen_t                  imp_len_soa,
+                    int                        imp_error )
 {
 #ifdef HL_DEBUG                                
    _ASSERTE(_CrtIsValidPointer( adsp_ldap_control, sizeof(class dsd_ldap_control), FALSE ));
@@ -527,15 +556,15 @@
  *
  * Connect error callback function. Close connections if called.
  *
- * @param [in]  class dsd_tcpcomp *adsp_tcp           tcpcomp object for nonblocking IO
- * @param [in]  void              *adsp_ldap_control  ldap control object
- * @param [in]  struct sockaddr   *adsp_soa           sockaddr structure (ipv4 / ipv6)
- * @param [in]  socklen_t          imp_len_soa        length of the sockaddr structure
- * @param [in]  int                imp_current_index  index number of the entry failed
- * @param [in]  int                imp_total_index    number of all entries
- * @param [in]  int                imp_errno          error code
+ * @param[in]  adsp_tcp           tcpcomp object for nonblocking IO
+ * @param[in]  adsp_ldap_control  ldap control object
+ * @param[in]  adsp_soa           sockaddr structure (ipv4 or ipv6)
+ * @param[in]  imp_len_soa        length of the sockaddr structure
+ * @param[in]  imp_current_index  index number of the entry failed
+ * @param[in]  imp_total_index    number of all entries
+ * @param[in]  imp_errno          error code
  *
- * @return      none
+ * @return     none
  */
 void mg_cb_connect_err( class dsd_tcpcomp *adsp_tcp,
                         void              *adsp_ldap_control,
@@ -560,10 +589,10 @@
  *
  * Send callback function. Resend buffers.
  *
- * @param [in]  class dsd_tcpcomp *adsp_tcp           tcpcomp object for nonblocking IO
- * @param [in]  void              *adsp_ldap_control  ldap control object
+ * @param[in]  adsp_tcp           tcpcomp object for nonblocking IO
+ * @param[in]  adsp_ldap_control  ldap control object
  *
- * @return      none
+ * @return     none
  */
 void mg_cb_send( class dsd_tcpcomp *adsp_tcp, void *adsp_ldap_control )
 {
@@ -582,13 +611,13 @@
  *
  * Get receive buffer callback function.
  *
- * @param [in]  class dsd_tcpcomp *adsp_tcp           tcpcomp object for nonblocking IO
- * @param [in]  void              *adsp_ldap_control  ldap control object
- * @param [out] void             **aavop_handle       pointer to the buffer handle variable (internally used)
- * @param [out] char             **aachp_buffer       pointer to the buffer pointer variable (where to write)
- * @param [out] int              **aaimp_len          pointer to the buffer length variable (bytes written)
+ * @param[in]  adsp_tcp           tcpcomp object for nonblocking IO
+ * @param[in]  adsp_ldap_control  ldap control object
+ * @param[out] aavop_handle       pointer to the buffer handle variable (internally used)
+ * @param[out] aachp_buffer       pointer to the buffer pointer variable (where to write)
+ * @param[out] aaimp_len          pointer to the buffer length variable (bytes written)
  *
- * @return      maximum buffer length (0 = receive not allowed)
+ * @return     maximum buffer length (0 = receive not allowed)
  */
 int mg_cb_getrecvbuf( class dsd_tcpcomp *adsp_tcp,
                       void              *adsp_ldap_control,
@@ -613,12 +642,12 @@
  *
  * Receive callback function.
  *
- * @param [in]  class dsd_tcpcomp *adsp_tcp           tcpcomp object for nonblocking IO
- * @param [in]  void              *adsp_ldap_control  ldap control object
- * @param [in]  void              *avop_handle        handle of buffer (internally used)
+ * @param[in]  adsp_tcp           tcpcomp object for nonblocking IO
+ * @param[in]  adsp_ldap_control  ldap control object
+ * @param[in]  avop_handle        handle of buffer (internally used)
  *
- * @return      TRUE,  if more data should be received
- *              FALSE, otherwise
+ * @return     \b TRUE,  if more data should be received or
+ *             \b FALSE, otherwise
  */
 int mg_cb_recv( class dsd_tcpcomp *adsp_tcp, void *adsp_ldap_control, void* avop_handle )
 {
@@ -639,10 +668,10 @@
  *
  * Cleanup callback function.
  *
- * @param [in]  class dsd_tcpcomp *adsp_tcp           tcpcomp object for nonblocking IO
- * @param [in]  void              *adsp_ldap_control  ldap control object
+ * @param[in]  adsp_tcp           tcpcomp object for nonblocking IO
+ * @param[in]  adsp_ldap_control  ldap control object
  *
- * @return      none
+ * @return     none
  */
 void mg_cb_cleanup( class dsd_tcpcomp *adsp_tcp, void *adsp_ldap_control )
 {
@@ -664,13 +693,13 @@
  *
  * Error callback function.
  *
- * @param [in]  class dsd_tcpcomp *adsp_tcp           tcpcomp object for nonblocking IO
- * @param [in]  void              *adsp_ldap_control  ldap control object
- * @param [in]  char              *strp_err           short error message
- * @param [in]  int                imp_errno          API error number
- * @param [in]  int                imp_errloc         tcpcomp error location. (See tcpcomp::ERRORAT_XXXX flags)
+ * @param[in]  adsp_tcp           tcpcomp object for nonblocking IO
+ * @param[in]  adsp_ldap_control  ldap control object
+ * @param[in]  strp_err           short error message
+ * @param[in]  imp_errno          API error number
+ * @param[in]  imp_errloc         tcpcomp error location. (See tcpcomp::ERRORAT_XXXX flags)
  *
- * @return      none
+ * @return     none
  */
 void mg_cb_error( class dsd_tcpcomp *adsp_tcp,
                   void              *adsp_ldap_control,
@@ -695,12 +724,12 @@
  *
  * Workthread function for different LDAP commands, which would block.
  *
- * @param [in]  struct dsd_hco_wothr *adsp_wt   workthread object
- * @param [in]  void                 *avop_p0   1.parameter: class  dsd_ldap   * (LDAP class instance)
- * @param [in]  void                 *avop_p1   2.parameter: struct dsd_co_ldap_1 * (LDAP command structure)
- * @param [in]  void                 *avop_p2   3.parameter: not used
+ * @param[in]  adsp_wt   workthread object
+ * @param[in]  avop_p0   1.parameter: class  dsd_ldap   * (LDAP class instance)
+ * @param[in]  avop_p1   2.parameter: struct dsd_co_ldap_1 * (LDAP command structure)
+ * @param[in]  avop_p2   3.parameter: not used
  *
- * @return      none
+ * @return     none
  */
 void mg_wt_ldap_request( struct dsd_hco_wothr *adsp_wt,
                          void *avop_p0,
@@ -722,14 +751,14 @@
  * Function for different LDAP commands. A list of possible commands can be
  * found at 'ied_co_ldap_def'.
  *
- * @param [in]  class  dsd_ldap        *adsp_ldap        ldap class instance
- * @param [in]  struct dsd_ldap_group  *adsp_cfg_ldap    LDAP configuration parameters
- * @param [in]  struct dsd_co_ldap_1   *adsp_co_ldap     LDAP command structure
- * @param [in]  void                   *vpp_userfld      user field for callback-function
- * @param [in]  int (*m_cb_func)(void *, class ...)      callback function
+ * @param[in]  adsp_ldap         ldap class instance
+ * @param[in]  adsp_cfg_ldap     LDAP configuration parameters
+ * @param[in]  adsp_co_ldap      LDAP command structure
+ * @param[in]  vpp_userfld       user field for callback-function
+ * @param[in]  (*m_cb_func)()    callback function  
  *
- * @return      FALSE  if the class instance was requested to be freed
- *              TRUE   otherwise
+ * @return     \b FALSE  if the class instance was requested to be freed or
+ *             \b TRUE   otherwise
  *
  * Comment:
  * LDAP-, TCP/IP- or other errors are send back in the 'dsd_co_ldap_1'-structure
@@ -757,9 +786,9 @@
  *
  * The constructor-function of the current class instance.
  *
- * @param [in]  class dsd_ldap  *adsp_ldap    ldap class instance
+ * @param[in]  adsp_ldap    ldap class instance
  *
- * @return      none
+ * @return     none
  */
 void m_ldap_init( class dsd_ldap *adsp_ldap )
 {
@@ -778,9 +807,9 @@
  *
  * The destructor-function of the current class instance.
  *
- * @param [in]  class dsd_ldap  *adsp_ldap    ldap class instance
+ * @param[in]  adsp_ldap    ldap class instance
  *
- * @return      none
+ * @return     none
  */
 void m_ldap_free( class dsd_ldap *adsp_ldap )
 {
@@ -805,20 +834,22 @@
  * found at 'ied_co_ldap_def'. This is the main entry function. Every request has
  * to be send with the initiated structure 'dsd_co_ldap_1'.
  *
- * @param [in]  struct dsd_ldap_group   *adsp_cfg_ldap    LDAP configuration parameters
- * @param [in]  struct dsd_co_ldap_1    *adsp_co_ldap     LDAP command structure
+ * @param[in]  adsp_cfg_ldap    LDAP configuration parameters
+ * @param[in]  adsp_co_ldap     LDAP command structure
+ * @param[in]  vpp_userfld      user field for callback-function
+ * @param[in]  m_cb_func()      callbach function (used in nonblocking mode)
  *
- * @return      FALSE  if the class instance was requested to be freed
- *              TRUE   otherwise
+ * @return     \b FALSE  if the class instance was requested to be freed or
+ *             \b TRUE   otherwise
  *
  * Comment:
- * The following parameters have to be set for all requests (ied_co_ldap_...):
- * [in]  'iec_co_ldap'       - LDAP command code
+ *     The following parameters have to be set for all requests (ied_co_ldap_...):
+ *     [in]  'iec_co_ldap'       - LDAP command code
  *
- * [out] 'iec_ldap_resp'     - response code (ied_ldap_success if successful or any error code(ied_ldap_...)
- *                             note:  ied_ldap_sasl_bind flags a type2-message (ntlm-challenge) returned
- *                                    by the server
- * [out] 'dsc_err_msg'       - error message
+ *     [out] 'iec_ldap_resp'     - response code (ied_ldap_success if successful or any error code(ied_ldap_...)
+ *                               note:  ied_ldap_sasl_bind flags a type2-message (ntlm-challenge) returned
+ *                                      by the server
+ *     [out] 'dsc_err_msg'       - error message
  *
  *  The requests ied_co_ldap_abandon, ied_co_ldap_close, ied_co_ldap_get_last_err don't use any
  *  further input parameters.
@@ -827,232 +858,232 @@
  **************************************************************************************************
  * ied_co_ldap_add:
  *
- * [in]  'adsc_attr_desc'        - attribute description(s) (single- / multi-valued)
- *        ->adsc_next_attr_desc  - next attribute description list
- *        ->iec_chs_dn           - dn name character set (ied_chs_utf_8)
- *        ->imc_len_dn           - dn name length
- *        ->ac_dn                - dn name (of the following attribute(s)
- *        ->adsc_attr            - attribute description(s)
- *          ->adsc_next_attr     - next attribute description
- *          ->iec_chs_attr       - attribute name character set (ied_chs_utf_8)
- *          ->imc_len_attr       - attribute name length
- *          ->ac_attr            - attribute name (which values are added)
- *            ->dsc_val;         - attribute value description
- *             .adsc_next_val    - next value description (if multivalued)
- *             .iec_chs_val;     - value character set (ied_chs_utf_8)
- *             .imc_len_val;     - value length
- *             .ac_val;          - value (to add)
+ *     [in]  'adsc_attr_desc'        - attribute description(s) (single- or multi-valued)
+ *            ->adsc_next_attr_desc  - next attribute description list
+ *            ->iec_chs_dn           - dn name character set (ied_chs_utf_8)
+ *            ->imc_len_dn           - dn name length
+ *            ->ac_dn                - dn name (of the following attribute(s)
+ *            ->adsc_attr            - attribute description(s)
+ *              ->adsc_next_attr     - next attribute description
+ *              ->iec_chs_attr       - attribute name character set (ied_chs_utf_8)
+ *              ->imc_len_attr       - attribute name length
+ *              ->ac_attr            - attribute name (which values are added)
+ *                ->dsc_val;         - attribute value description
+ *                 .adsc_next_val    - next value description (if multivalued)
+ *                 .iec_chs_val;     - value character set (ied_chs_utf_8)
+ *                 .imc_len_val;     - value length
+ *                 .ac_val;          - value (to add)
  *
  **************************************************************************************************
  * ied_co_ldap_bind:
  *
  * there are two different kinds of bind():  simple and sasl (3-way handshake for ntlm)
  *
- * [in]  'iec_ldap_auth'      - bind with dn, user name, administrator or sasl
- * [in]  'iec_chs_userid'     - simple: user name character set (e.g. ied_chs_ascii_850)
- *                              sasl:   ignored
- * [in]  'imc_len_userid'     - simple: user name length
- *                              sasl:   ignored
- * [in]  'ac_userid'          - simple: user name
- *                              sasl:   ignored
- * [in]  'iec_chs_passwd'     - simple: password character set (e.g. ied_chs_ascii_850)
- *                              sasl:   ignored
- * [in]  'imc_len_passwd'     - simple: password length
- *                              sasl:   credentials length
- * [in]  'ac_passwd'          - simple: password
- *                              sasl:   credentials
- * sasl (ntlm-challenge, type 2 - message)
+ *     [in]  'iec_ldap_auth'      - bind with dn, user name, administrator or sasl
+ *     [in]  'iec_chs_userid'     - simple: user name character set (e.g. ied_chs_ascii_850)
+ *                                  sasl:   ignored
+ *     [in]  'imc_len_userid'     - simple: user name length
+ *                                  sasl:   ignored
+ *     [in]  'ac_userid'          - simple: user name
+ *                                  sasl:   ignored
+ *     [in]  'iec_chs_passwd'     - simple: password character set (e.g. ied_chs_ascii_850)
+ *                                  sasl:   ignored
+ *     [in]  'imc_len_passwd'     - simple: password length
+ *                                  sasl:   credentials length
+ *     [in]  'ac_passwd'          - simple: password
+ *                                  sasl:   credentials
+ *     sasl (ntlm-challenge, type 2 - message)
  *
- * [out]  'iec_ldap_auth'     - ied_auth_ntlm_type_2 (NTLM-Challenge)
- * [out]  'imc_len_passwd'    - challenge string length
- * [out]  'ac_passwd'         - challenge string
+ *     [out]  'iec_ldap_auth'     - ied_auth_ntlm_type_2 (NTLM-Challenge)
+ *     [out]  'imc_len_passwd'    - challenge string length
+ *     [out]  'ac_passwd'         - challenge string
  *
  * simple authentication:
  *
- * [out] 'iec_chs_dn'        - DN name character set (ied_chs_utf_8)
- * [out] 'imc_len_dn'        - DN name length
- * [out] 'ac_dn'             - DN name of the user
+ *     [out] 'iec_chs_dn'        - DN name character set (ied_chs_utf_8)
+ *     [out] 'imc_len_dn'        - DN name length
+ *     [out] 'ac_dn'             - DN name of the user
  *
  *
  * These parameters overwrites the <dn>- and <password>-entries of the xml-configuration
  **************************************************************************************************
  * ied_co_ldap_compare:
  *
- * [in]  'adsc_attr_desc'        - partial attribute description (single- / multi-valued)
- *        ->adsc_next_attr_desc  - NULL
- *        ->iec_chs_dn           - dn name character set (ied_chs_utf_8)
- *        ->imc_len_dn           - dn name length
- *        ->ac_dn                - dn name (of the following attribute(s)
- *        ->adsc_attr            - attribute description(s)
- *          ->adsc_next_attr     - NULL
- *          ->iec_chs_attr       - attribute name character set (ied_chs_utf_8)
- *          ->imc_len_attr       - attribute name length
- *          ->ac_attr            - attribute name (which value is compared)
- *            ->dsc_val;         - attribute value description
- *             .adsc_next_val    - NULL
- *             .iec_chs_val;     - value character set (ied_chs_utf_8)
- *             .imc_len_val;     - value length
- *             .ac_val;          - value (new)
- *
+ *     [in]  'adsc_attr_desc'        - partial attribute description (single- or multi-valued)
+ *            ->adsc_next_attr_desc  - NULL
+ *            ->iec_chs_dn           - dn name character set (ied_chs_utf_8)
+ *            ->imc_len_dn           - dn name length
+ *            ->ac_dn                - dn name (of the following attribute(s)
+ *            ->adsc_attr            - attribute description(s)
+ *              ->adsc_next_attr     - NULL
+ *              ->iec_chs_attr       - attribute name character set (ied_chs_utf_8)
+ *              ->imc_len_attr       - attribute name length
+ *              ->ac_attr            - attribute name (which value is compared)
+ *                ->dsc_val;         - attribute value description
+ *                 .adsc_next_val    - NULL
+ *                 .iec_chs_val;     - value character set (ied_chs_utf_8)
+ *                 .imc_len_val;     - value length
+ *                 .ac_val;          - value (new)
+ *     
  **************************************************************************************************
  * ied_co_ldap_delete:
  *
- * [in]  'iec_chs_dn'        - character set of the DN entry name
- * [in]  'imc_len_dn'        - DN entry name length (in bytes)
- * [in]  'ac_dn'             - DN entry name to delete
+ *     [in]  'iec_chs_dn'        - character set of the DN entry name
+ *     [in]  'imc_len_dn'        - DN entry name length (in bytes)
+ *     [in]  'ac_dn'             - DN entry name to delete
  *
  **************************************************************************************************
  * ied_co_ldap_explode_dn:
  *
- * [in]  'avoc_stor_handle'      - NULL: LDAP storage handle, else use this client handle
- *
- * [out] 'adsc_attr_desc'        - RDN-attribute description list
- *        ->adsc_next_attr_desc  - next RDN-attribute description list
- *        ->iec_chs_dn           - RDN name character set (ied_chs_utf_8)
- *        ->imc_len_dn           - RDN name length
- *        ->ac_dn                - RDN name
- *        ->adsc_attr            - NULL: no further attribute description(s)
- *
+ *     [in]  'avoc_stor_handle'      - NULL: LDAP storage handle, else use this client handle
+ *    
+ *     [out] 'adsc_attr_desc'        - RDN-attribute description list
+ *            ->adsc_next_attr_desc  - next RDN-attribute description list
+ *            ->iec_chs_dn           - RDN name character set (ied_chs_utf_8)
+ *            ->imc_len_dn           - RDN name length
+ *            ->ac_dn                - RDN name
+ *            ->adsc_attr            - NULL: no further attribute description(s)
+ *    
  **************************************************************************************************
  * ied_co_ldap_clone_dn:  
  *
- * [in]  'avoc_stor_handle'      - NULL: LDAP storage handle, else use this client handle
+ *     [in]  'avoc_stor_handle'      - NULL: LDAP storage handle, else use this client handle
+ *    
+ *     [in]  'iec_chs_dn'            - (optional) RDN name character set
+ *     [in]  'imc_len_dn'            - (optional) RDN name length (in bytes)
+ *     [in]  'ac_dn'                 - (optional) RDN name
+ *     [in]  'adsc_attr_desc'        - RDN-attribute description list
+ *            ->adsc_next_attr_desc  - next RDN-attribute description list
+ *            ->iec_chs_dn           - RDN name character set (ied_chs_utf_8)
+ *            ->imc_len_dn           - RDN name length
+ *            ->ac_dn                - RDN name
+ *            ->adsc_attr            - NULL: no further attribute description(s)
+ *    
+ *     [out] 'iec_chs_dn'            - created DN name character set
+ *     [out] 'imc_len_dn'            - created DN name length (in bytes)
+ *     [out] 'ac_dn'                 - created DN name
  *
- * [in]  'iec_chs_dn'            - (optional) RDN name character set
- * [in]  'imc_len_dn'            - (optional) RDN name length (in bytes)
- * [in]  'ac_dn'                 - (optional) RDN name
- * [in]  'adsc_attr_desc'        - RDN-attribute description list
- *        ->adsc_next_attr_desc  - next RDN-attribute description list
- *        ->iec_chs_dn           - RDN name character set (ied_chs_utf_8)
- *        ->imc_len_dn           - RDN name length
- *        ->ac_dn                - RDN name
- *        ->adsc_attr            - NULL: no further attribute description(s)
- *
- * [out] 'iec_chs_dn'            - created DN name character set
- * [out] 'imc_len_dn'            - created DN name length (in bytes)
- * [out] 'ac_dn'                 - created DN name
- *
  **************************************************************************************************
  * ied_co_ldap_get_membership (any, list):
  *
- * [out] 'adsc_attr_desc'        - attribute description list (personal- or group-membership)
- *        ->adsc_next_attr_desc  - next attribute description list
- *        ->iec_chs_dn           - dn name character set (ied_chs_utf_8)
- *        ->imc_len_dn           - dn name length
- *        ->ac_dn                - dn name (of the following attribute(s)
- *        ->adsc_attr            - attribute description(s)
- *          ->adsc_next_attr     - next attribute description
- *          ->iec_chs_attr       - attribute name character set (ied_chs_utf_8)
- *          ->imc_len_attr       - attribute name length
- *          ->ac_attr            - attribute name
- *            ->dsc_val;         - attribute value description
- *             .adsc_next_val    - next value description (if multivalued)
- *             .iec_chs_val;     - value character set (ied_chs_utf_8)
- *             .imc_len_val;     - value length
- *             .ac_val;          - value
+ *     [out] 'adsc_attr_desc'        - attribute description list (personal- or group-membership)
+ *            ->adsc_next_attr_desc  - next attribute description list
+ *            ->iec_chs_dn           - dn name character set (ied_chs_utf_8)
+ *            ->imc_len_dn           - dn name length
+ *            ->ac_dn                - dn name (of the following attribute(s)
+ *            ->adsc_attr            - attribute description(s)
+ *              ->adsc_next_attr     - next attribute description
+ *              ->iec_chs_attr       - attribute name character set (ied_chs_utf_8)
+ *              ->imc_len_attr       - attribute name length
+ *              ->ac_attr            - attribute name
+ *                ->dsc_val;         - attribute value description
+ *                 .adsc_next_val    - next value description (if multivalued)
+ *                 .iec_chs_val;     - value character set (ied_chs_utf_8)
+ *                 .imc_len_val;     - value length
+ *                 .ac_val;          - value
  *
  **************************************************************************************************
  * ied_co_ldap_get_sysinfo:    
  *
- * [out] 'adsc_sys_info'         - ldap server system information list
- *        ->adsc_target_ineta    - server ip-address structure
- *        ->imc_port             - server ip-port 
- *        ->iec_type             - server ldap type (e.g. OpenLDAP)
- *        ->dsc_base_dn          - list of base-dn description(s)
- *          .adsc_next_val       - next base-dn description (if more than one is defined)
- *          .iec_chs_val;        - base-dn character set (ied_chs_utf_8)
- *          .imc_len_val;        - base-dn length
- *          .ac_val;             - base-dn
+ *     [out] 'adsc_sys_info'         - ldap server system information list
+ *            ->adsc_target_ineta    - server ip-address structure
+ *            ->imc_port             - server ip-port 
+ *            ->iec_type             - server ldap type (e.g. OpenLDAP)
+ *            ->dsc_base_dn          - list of base-dn description(s)
+ *              .adsc_next_val       - next base-dn description (if more than one is defined)
+ *              .iec_chs_val;        - base-dn character set (ied_chs_utf_8)
+ *              .imc_len_val;        - base-dn length
+ *              .ac_val;             - base-dn
  *
  **************************************************************************************************
  * ied_co_ldap_check_pwd_age:
  *
- * [in]  'iec_chs_dn'            - character set of the DN entry name
- * [in]  'imc_len_dn'            - DN entry name length (in bytes)
- * [in]  'ac_dn'                 - DN entry name (to check the password for)
+ *     [in]  'iec_chs_dn'            - character set of the DN entry name
+ *     [in]  'imc_len_dn'            - DN entry name length (in bytes)
+ *     [in]  'ac_dn'                 - DN entry name (to check the password for)
  *
- * [out] 'adsc_pwd_info'         - ldap server password expire time list
- *        ->iec_account_control  - ldap user account control
- *        ->ilc_exp_minutes;     - password expire time in minutes  
- *        ->ilc_exp_hours;       - password expire time in hours    
- *        ->ilc_exp_days;        - password expire time in days     
- *
+ *     [out] 'adsc_pwd_info'         - ldap server password expire time list
+ *            ->iec_account_control  - ldap user account control
+ *            ->ilc_exp_minutes;     - password expire time in minutes  
+ *            ->ilc_exp_hours;       - password expire time in hours    
+ *            ->ilc_exp_days;        - password expire time in days     
+ *    
  **************************************************************************************************
  * ied_co_ldap_modify:
  *
- * [in]  'adsc_attr_desc'        - partial attribute description (single- / multi-valued)
- *        ->adsc_next_attr_desc  - next attribute description list
- *        ->iec_chs_dn           - dn name character set (ied_chs_utf_8)
- *        ->imc_len_dn           - dn name length
- *        ->ac_dn                - dn name (of the following attribute(s)
- *        ->adsc_attr            - attribute description(s)
- *          ->adsc_next_attr     - next attribute description
- *          ->iec_chs_attr       - attribute name character set (ied_chs_utf_8)
- *          ->imc_len_attr       - attribute name length
- *          ->ac_attr            - attribute name (which values are changed)
- *            ->dsc_val;         - attribute value description
- *             .adsc_next_val    - next value description (if multivalued)
- *             .iec_chs_val;     - value character set (ied_chs_utf_8)
- *             .imc_len_val;     - value length
- *             .ac_val;          - value (new)
+ *     [in]  'adsc_attr_desc'        - partial attribute description (single- or multi-valued)
+ *            ->adsc_next_attr_desc  - next attribute description list
+ *            ->iec_chs_dn           - dn name character set (ied_chs_utf_8)
+ *            ->imc_len_dn           - dn name length
+ *            ->ac_dn                - dn name (of the following attribute(s)
+ *            ->adsc_attr            - attribute description(s)
+ *              ->adsc_next_attr     - next attribute description
+ *              ->iec_chs_attr       - attribute name character set (ied_chs_utf_8)
+ *              ->imc_len_attr       - attribute name length
+ *              ->ac_attr            - attribute name (which values are changed)
+ *                ->dsc_val;         - attribute value description
+ *                 .adsc_next_val    - next value description (if multivalued)
+ *                 .iec_chs_val;     - value character set (ied_chs_utf_8)
+ *                 .imc_len_val;     - value length
+ *                 .ac_val;          - value (new)
  *
  **************************************************************************************************
  * ied_co_ldap_modify_dn:
  *
- * [in]  'iec_chs_dn'        - character set of the (R)DN entry name
- * [in]  'imc_len_dn'        - (R)DN entry name length (in bytes)
- * [in]  'ac_dn'             - (R)DN entry name to change
- * [in]  'iec_chs_newrdn'    - character set of the modifyRDN (e.g. UTF-8)
- * [in]  'imc_len_newrdn'    - new modifyRDN-name length (in bytes)
- * [in]  'ac_newrdn'         - new modifyRDN-name (e.g. UTF-8 coded)
+ *     [in]  'iec_chs_dn'        - character set of the (R)DN entry name
+ *     [in]  'imc_len_dn'        - (R)DN entry name length (in bytes)
+ *     [in]  'ac_dn'             - (R)DN entry name to change
+ *     [in]  'iec_chs_newrdn'    - character set of the modifyRDN (e.g. UTF-8)
+ *     [in]  'imc_len_newrdn'    - new modifyRDN-name length (in bytes)
+ *     [in]  'ac_newrdn'         - new modifyRDN-name (e.g. UTF-8 coded)
  *
  **************************************************************************************************
  * ied_co_ldap_msad_change_password:
  *
- * [in]  'iec_chs_passwd_new' - simple: new password character set (e.g. ied_chs_ascii_850)
- * [in]  'imc_len_passwd_new' - simple: new password length
- * [in]  'ac_passwd_new'      - simple: new password
+ *     [in]  'iec_chs_passwd_new' - simple: new password character set (e.g. ied_chs_ascii_850)
+ *     [in]  'imc_len_passwd_new' - simple: new password length
+ *     [in]  'ac_passwd_new'      - simple: new password
  *
  **************************************************************************************************
  * ied_co_ldap_search:
  *
- * [in]  'iec_chs_dn'        - DN baseObject character set
- * [in]  'imc_len_dn'        - DN baseObject length
- * [in]  'ac_dn'             - DN baseObject
- *                             if NULL, the last 'dn' and if not set, the 'namingcontexts' is used
- *                             as baseObject
- * [in]  'dsc_add_dn'        - additional relative (user-)base dn
- * [in]  'iec_sear_scope'    - search at the baseObject or backwards to the root
+ *     [in]  'iec_chs_dn'        - DN baseObject character set
+ *     [in]  'imc_len_dn'        - DN baseObject length
+ *     [in]  'ac_dn'             - DN baseObject
+ *                                 if NULL, the last 'dn' and if not set, the 'namingcontexts' is used
+ *                                 as baseObject
+ *     [in]  'dsc_add_dn'        - additional relative (user-)base dn
+ *     [in]  'iec_sear_scope'    - search at the baseObject or backwards to the root
+ *    
+ *     [in]  'iec_chs_filter'    - filter expression character set (e.g. ied_chs_ascii_850)
+ *     [in]  'imc_len_filter'    - filter expression name length
+ *     [in]  'ac_filter'         - filter expression (e.g. '(&(ou=hob)(o=malta))' )
+ *    
+ *     [in]  'iec_chs_attrlist'  - attribute list character set (e.g. ied_chs_ascii_850)
+ *     [in]  'imc_len_attrlist'  - attribute list length
+ *     [in]  'ac_attrlist'       - list of attributes to return, comma separated (CSV)
+ *                                 (e.g. 'hcName,hcNo,hcKey')
+ *    
+ *     [out] 'adsc_attr_desc'        - attribute description list (personal- or group-membership)
+ *            ->adsc_next_attr_desc  - next attribute description list
+ *            ->iec_chs_dn           - dn name character set (ied_chs_utf_8)
+ *            ->imc_len_dn           - dn name length
+ *            ->ac_dn                - dn name (of the following attribute(s)
+ *            ->adsc_attr            - attribute description(s)
+ *              ->adsc_next_attr     - next attribute description
+ *              ->iec_chs_attr       - attribute name character set (ied_chs_utf_8)
+ *              ->imc_len_attr       - attribute name length
+ *              ->ac_attr            - attribute name
+ *                ->dsc_val;         - attribute value description
+ *                 .adsc_next_val    - next value description (if multivalued)
+ *                 .iec_chs_val;     - value character set (ied_chs_utf_8)
+ *                 .imc_len_val;     - value length
+ *                 .ac_val;          - value
+ *    
+ *     [out] 'iec_chs_dn'        - DN baseObject character set (ied_chs_utf_8)
+ *     [out] 'imc_len_dn'        - DN baseObject length
+ *     [out] 'ac_dn'             - DN baseObject
  *
- * [in]  'iec_chs_filter'    - filter expression character set (e.g. ied_chs_ascii_850)
- * [in]  'imc_len_filter'    - filter expression name length
- * [in]  'ac_filter'         - filter expression (e.g. '(&(ou=hob)(o=malta))' )
- *
- * [in]  'iec_chs_attrlist'  - attribute list character set (e.g. ied_chs_ascii_850)
- * [in]  'imc_len_attrlist'  - attribute list length
- * [in]  'ac_attrlist'       - list of attributes to return, comma separated (CSV)
- *                             (e.g. 'hcName,hcNo,hcKey')
- *
- * [out] 'adsc_attr_desc'        - attribute description list (personal- or group-membership)
- *        ->adsc_next_attr_desc  - next attribute description list
- *        ->iec_chs_dn           - dn name character set (ied_chs_utf_8)
- *        ->imc_len_dn           - dn name length
- *        ->ac_dn                - dn name (of the following attribute(s)
- *        ->adsc_attr            - attribute description(s)
- *          ->adsc_next_attr     - next attribute description
- *          ->iec_chs_attr       - attribute name character set (ied_chs_utf_8)
- *          ->imc_len_attr       - attribute name length
- *          ->ac_attr            - attribute name
- *            ->dsc_val;         - attribute value description
- *             .adsc_next_val    - next value description (if multivalued)
- *             .iec_chs_val;     - value character set (ied_chs_utf_8)
- *             .imc_len_val;     - value length
- *             .ac_val;          - value
- *
- * [out] 'iec_chs_dn'        - DN baseObject character set (ied_chs_utf_8)
- * [out] 'imc_len_dn'        - DN baseObject length
- * [out] 'ac_dn'             - DN baseObject
- *
  */
 int dsd_ldap::m_ldap_request( struct dsd_ldap_group *adsp_cfg_ldap,
                               struct dsd_co_ldap_1  *adsp_co_ldap,
@@ -1305,15 +1336,14 @@
                       break;
       case ied_ldap_no_bind:
                       // no valid bind context...
+      case ied_ldap_not_allowed_on_nleaf:
+                      // non-empty node is not deleted...
+      case ied_ldap_attr_or_val_exist:
+                      // modify value already set...
       case ied_ldap_password_change:
                       // password expired...
                       adsp_co_ldap->iec_ldap_resp = (ied_resp_ldap_def)im_rc;
                       goto REQ_ERROR;
-                     
-      case ied_ldap_attr_or_val_exist:
-                      // modify value already set...
-                      adsp_co_ldap->iec_ldap_resp = (ied_resp_ldap_def)im_rc;
-                      goto REQ_ERROR;

       case ied_ldap_would_block:
                       // function would block...
@@ -1371,6 +1401,7 @@
    memset( (void *)&this->ds_ldapreq, 0, sizeof(struct dsd_ldap::dsd_ldapreq) );
    this->bo_RootDSE    = FALSE;
    this->ads_domainSID = NULL;
+   this->ads_ldap_schema = NULL;
   
    // initialize ssl...
    this->ach_ssltoappl_buf = NULL; // ssl translate buffers
@@ -1378,8 +1409,8 @@
    this->ads_hl_stor_ssl   = NULL;

    // initialize permanent and temporary storage handle
-   m_aux_stor_start( &this->ads_hl_stor_tmp );
-   m_aux_stor_start( &this->ads_hl_stor_per );
+   START_MEM( this->ads_hl_stor_tmp );
+   START_MEM( this->ads_hl_stor_per );

    // initialize error/trace handling
    this->ds_ldap_error.m_init( this->ads_hl_stor_per );
@@ -1388,10 +1419,16 @@
    // initialize static members only once...
 #if defined (WIN32) || defined (WIN64)   
    if (InterlockedCompareExchange( (volatile LONG *)&dsd_ldap::im_init_cs, 1, 0 ) == 0)
+   {
      dsd_ldap::ds_cs_ldap.m_create();  // critical section overall instances
+     START_MEM( dsd_ldap::ads_hl_stor_glob );  // initialize storage handler
+   }
 #elif defined (HL_UNIX)
    if (__sync_val_compare_and_swap( &dsd_ldap::im_init_cs, 1, 0) == 0)
+   {
      dsd_ldap::ds_cs_ldap.m_create();  // critical section overall instances
+     START_MEM( dsd_ldap::ads_hl_stor_glob );  // initialize storage handler
+   }
 #endif  

    // next instance...
@@ -1443,16 +1480,9 @@

      //cleanup resources, if this is the last running session!
      if (!dsd_ldap::im_init_cnt)  
-     { // free the AVL tree...
-       dsd_ldap_schema *adsl_schema_1 (dsd_ldap::ads_schema_anc), *adsl_schema_2;
-       while (adsl_schema_1)
-       {
-         adsl_schema_2 = adsl_schema_1->ads_next;
-         delete adsl_schema_1;
-         adsl_schema_1 = adsl_schema_2; 
-       }
-       // reset schema anchor
+     { // free the AVL trees and reset schema anchor
        dsd_ldap::ads_schema_anc = NULL;
+       END_MEM(dsd_ldap::ads_hl_stor_glob);
      } 
    } // last running session
    dsd_ldap::ds_cs_ldap.m_leave();
@@ -1489,12 +1519,12 @@
  *
  * Workthread function for different LDAP commands, which would block.
  *
- * @param [in]  struct dsd_hco_wothr *adsp_wt       workthread object
- * @param [in]  struct dsd_co_ldap_1 *adsp_co_ldap  LDAP command structure
+ * @param[in]  adsp_wt       workthread object
+ * @param[in]  adsp_co_ldap  LDAP command structure
  *
- * @return      none
+ * @return     none
  *
- * Remarks:
+ * Remarks:\n
  * The caller is responsible for the input parameters. They are not tested for validity.
  */
 void dsd_ldap::m_wt_ldap_request( struct dsd_hco_wothr *adsp_wt, struct dsd_co_ldap_1 *adsp_co_ldap )
@@ -1604,6 +1634,8 @@
                         // function would block...
         case ied_ldap_sasl_bind:
                         // bind in progress...
+        case ied_ldap_not_allowed_on_nleaf:
+                        // non-empty node is not deleted...
         case ied_ldap_cmp_true:
         case ied_ldap_cmp_false:
                         // m_ldap_compare() return values...
@@ -1634,10 +1666,10 @@
  * Connect callback function. In the case of an error the callback-function
  * 'm_cb_connect_err()' is called.
  *
- * @param [in]  struct sockaddr *adsp_soa      sockaddr structure (ipv4 / ipv6)
- * @param [in]  socklen_t        imp_len_soa   length of the sockaddr structure
+ * @param[in]  adsp_soa      sockaddr structure (ipv4 or ipv6)
+ * @param[in]  imp_len_soa   length of the sockaddr structure
  *
- * @return      none
+ * @return     none
  */
 void dsd_ldap::m_cb_connect( struct sockaddr *adsp_soa, socklen_t imp_len_soa )
 {
@@ -1662,8 +1694,6 @@
    this->im_c_status = dsd_ldap::CONNECTED;
    this->ads_ldap_control->bo_tcperr = FALSE;
    this->ads_ldap_control->bo_ready  = FALSE;
-// 16.05.2011 la; this->ads_ldap_control->bo_recv   = TRUE;
-// 16.05.2011 la; this->ads_ldap_control->ds_tcpcomp.m_recv(); // start receiving

    // set event (connect succesful or error)
    this->ads_ldap_control->bo_connect = TRUE;
@@ -1678,13 +1708,13 @@
  *
  * Connect error callback function.
  *
- * @param [in]  struct sockaddr *adsp_soa           sockaddr structure (ipv4 / ipv6)
- * @param [in]  socklen_t        imp_len_soa        length of the sockaddr structure
- * @param [in]  int              imp_current_index  index number of the entry failed
- * @param [in]  int              imp_total_index    number of all entries
- * @param [in]  int              imp_errno          error code
+ * @param[in]  adsp_soa           sockaddr structure (ipv4 or ipv6)
+ * @param[in]  imp_len_soa        length of the sockaddr structure
+ * @param[in]  imp_current_index  index number of the entry failed
+ * @param[in]  imp_total_index    number of all entries
+ * @param[in]  imp_errno          error code
  *
- * @return      none
+ * @return     none
  */
 void dsd_ldap::m_cb_connect_err( struct sockaddr *adsp_soa, socklen_t imp_len_soa,
                                  int imp_current_index, int imp_total_index, int imp_errno )
@@ -1693,7 +1723,7 @@
    // save error code 'imp_err' and ip-address...
    if (adsp_soa && imp_len_soa)
      memcpy( (void *)&this->ds_conn, (const void *)adsp_soa, imp_len_soa );
-   this->ds_ldap_error.m_set_error( ied_ldap_connect_err/*LDAP result code*/, imp_errno/*API error*/, NULL/*(R)DN*/, NULL, 0 );
+   this->ds_ldap_error.m_set_error( ied_ldap_connect_err/*LDAP result code*/, imp_errno/*API error*/ );

    // >>> trace message LDAP0021T
    if (this->ds_ldap_trace.m_is_enabled())                                                                                  
@@ -1753,9 +1783,9 @@
  *
  * Get receive buffer callback function (SSL and nonSSL).
  *
- * @param [out] void  **aavop_handle  pointer to the buffer handle variable (internally used)
- * @param [out] char  **aachp_buffer  pointer to the buffer pointer variable (where to write)
- * @param [out] int   **aaimp_len     pointer to the buffer length variable (bytes written)
+ * @param[out]  aavop_handle  pointer to the buffer handle variable (internally used)
+ * @param[out]  aachp_buffer  pointer to the buffer pointer variable (where to write)
+ * @param[out]  aaimp_len     pointer to the buffer length variable (bytes written)
  *
  * @return      maximum buffer length. 0 = receive not allowed
  */
@@ -1835,10 +1865,10 @@
  *
  * Receive callback function.
  *
- * @param [in]  void  *avop_handle   pointer to the buffer handle (dsd_ldap::ach_buf)
+ * @param[in]  avop_handle   pointer to the buffer handle (dsd_ldap::ach_buf)
  *
- * @return      TRUE   if more data should be received,
- *              FALSE  otherwise
+ * @return     \b TRUE   if more data should be received,
+ *             \b FALSE  otherwise
  */
 int dsd_ldap::m_cb_recv( void* avop_handle )
 {
@@ -1908,11 +1938,11 @@
  *
  * Error callback function (to the specific instance of dsd_ldap).
  *
- * @param [in]  char  *strp_err     short error message
- * @param [in]  int    imp_errno    API error number
- * @param [in]  int    imp_errloc   tcpcomp error location (See tcpcomp::ERRORAT_XXXX flags)
+ * @param[in]  strp_err     short error message
+ * @param[in]  imp_errno    API error number
+ * @param[in]  imp_errloc   tcpcomp error location (See tcpcomp::ERRORAT_XXXX flags)
  *
- * @return      none
+ * @return     none
  */
 void dsd_ldap::m_cb_error( char *strp_err, int imp_errno, int imp_errloc )
 {
@@ -1952,7 +1982,7 @@
      this->ds_ldap_trace.m_trace( dsd_trace::LEVEL_ERROR, 93, this->im_sess_no, m_get_epoch_ms(),
                                   &this->ds_conn, this->ads_ldap_entry,
                                   "TCPIP-Error=%i Function=%i Message=%s",
-                                  imp_errno, imp_errloc, strp_err );
+                                  imp_errno, imp_errloc, strp_err ? strp_err : "none" );
    return;

 } // dsd_ldap::m_cb_error( char*, int, int )
@@ -1963,7 +1993,7 @@
  *
  * Cleanup callback function (to the specific instance of dsd_ldap).
  *
- * @return      none
+ * @return     none
  */
 void dsd_ldap::m_cb_cleanup()
 {
@@ -2006,11 +2036,11 @@
  *
  * Initiates the connection to a ldap server.
  *
- * @param [in]  dsd_ldap_group_t *adsp_ldap_group  grouped list of ldap-configurations
+ * @param[in]  adsp_ldap_group  grouped list of ldap-configurations
  *
- * @return      error (ied_ldap_failure) or successful (ied_ldap_success)
+ * @return     error (\b ied_ldap_failure) or successful (\b ied_ldap_success)
  *
- * Remarks:
+ * Remarks:\n
  * We have a chain of configuration entries inside a ldap configuration group.
  * Starting with the first entry we try to connect to a ldap server. If the connection
  * fails, we wait a time (<retry-after-error>) before we start a retry using the current
@@ -2042,46 +2072,46 @@
    // calculate template index...
    switch (this->ads_ldap_entry->adsc_ldap_template->imc_len_name)
    {
-      case sizeof DEF_LDAP_MSAD-1:      if (!_memicmp( (const void *)(this->ads_ldap_entry->adsc_ldap_template + 1),
-                                                       DEF_LDAP_MSAD,
+      case sizeof DEF_LDAP_MSAD-1:      if (!m_hl_memicmp( (void *)(this->ads_ldap_entry->adsc_ldap_template + 1),
+                                                           (void *)DEF_LDAP_MSAD,
                                                        this->ads_ldap_entry->adsc_ldap_template->imc_len_name ))
                                           this->im_ldap_templ = ied_sys_ldap_msad;     // Microsoft active directory
                                         break;
-      case sizeof DEF_LDAP_IBM-1:       if (!_memicmp( (const void *)(this->ads_ldap_entry->adsc_ldap_template + 1),
-                                                       DEF_LDAP_IBM,
+      case sizeof DEF_LDAP_IBM-1:       if (!m_hl_memicmp( (void *)(this->ads_ldap_entry->adsc_ldap_template + 1),
+                                                           (void *)DEF_LDAP_IBM,
                                                        this->ads_ldap_entry->adsc_ldap_template->imc_len_name ))
                                           this->im_ldap_templ = ied_sys_ldap_ibm;      // IBM directory  server
                                         break; 
-      case sizeof DEF_LDAP_IPLANET-1:   if (!_memicmp( (const void *)(this->ads_ldap_entry->adsc_ldap_template + 1),
-                                                       DEF_LDAP_IPLANET,
+      case sizeof DEF_LDAP_IPLANET-1:   if (!m_hl_memicmp( (void *)(this->ads_ldap_entry->adsc_ldap_template + 1),
+                                                           (void *)DEF_LDAP_IPLANET,
                                                        this->ads_ldap_entry->adsc_ldap_template->imc_len_name ))
                                           this->im_ldap_templ = ied_sys_ldap_iplanet;  // iPlanet directory  server
                                         break;
-      case sizeof DEF_LDAP_NOVELL-1:    if (!_memicmp( (const void *)(this->ads_ldap_entry->adsc_ldap_template + 1),
-                                                       DEF_LDAP_NOVELL,
+      case sizeof DEF_LDAP_NOVELL-1:    if (!m_hl_memicmp( (void *)(this->ads_ldap_entry->adsc_ldap_template + 1),
+                                                           (void *)DEF_LDAP_NOVELL,
                                                        this->ads_ldap_entry->adsc_ldap_template->imc_len_name ))
                                           this->im_ldap_templ = ied_sys_ldap_novell;   // NOVELL directory  server
                                         break; 
-      case sizeof DEF_LDAP_OPENLDAP-1:  if (!_memicmp( (const void *)(this->ads_ldap_entry->adsc_ldap_template + 1),
-                                                       DEF_LDAP_OPENLDAP,
+      case sizeof DEF_LDAP_OPENLDAP-1:  if (!m_hl_memicmp( (void *)(this->ads_ldap_entry->adsc_ldap_template + 1),
+                                                           (void *)DEF_LDAP_OPENLDAP,
                                                        this->ads_ldap_entry->adsc_ldap_template->imc_len_name ))
                                           this->im_ldap_templ = ied_sys_ldap_openldap; // OpenLDAP
                                         break;
       case sizeof DEF_LDAP_OPENDS-1:  
-    /*case sizeof DEF_LDAP_OPENDJ-1:*/  if (!_memicmp( (const void *)(this->ads_ldap_entry->adsc_ldap_template + 1),
-                                                       DEF_LDAP_OPENDS,
+    /*case sizeof DEF_LDAP_OPENDJ-1:*/  if (!m_hl_memicmp( (void *)(this->ads_ldap_entry->adsc_ldap_template + 1),
+                                                           (void *)DEF_LDAP_OPENDS,
                                                        this->ads_ldap_entry->adsc_ldap_template->imc_len_name ))
                                           this->im_ldap_templ = ied_sys_ldap_opends;   // OpenDS
                                         else
                                         {
-                                          if (!_memicmp( (const void *)(this->ads_ldap_entry->adsc_ldap_template + 1),
-                                                         DEF_LDAP_OPENDJ,
+                                          if (!m_hl_memicmp( (void *)(this->ads_ldap_entry->adsc_ldap_template + 1),
+                                                             (void *)DEF_LDAP_OPENDJ,
                                                          this->ads_ldap_entry->adsc_ldap_template->imc_len_name ))
                                             this->im_ldap_templ = ied_sys_ldap_opendj; // OpenDJ
                                         }
                                         break;
-      case sizeof DEF_LDAP_SIEMENS-1:   if (!_memicmp( (const void *)(this->ads_ldap_entry->adsc_ldap_template + 1),
-                                                       DEF_LDAP_SIEMENS,
+      case sizeof DEF_LDAP_SIEMENS-1:   if (!m_hl_memicmp( (void *)(this->ads_ldap_entry->adsc_ldap_template + 1),
+                                                           (void *)DEF_LDAP_SIEMENS,
                                                        this->ads_ldap_entry->adsc_ldap_template->imc_len_name ))
                                           this->im_ldap_templ = ied_sys_ldap_siemens;  // Siemens
                                         break;
@@ -2140,18 +2170,20 @@

      // start TCPCOMP connection...
      m_set_connect_p1( &this->ds_conn, (socklen_t *)&dsl_socklen, this->ads_ldap_entry->adsc_server_ineta, 0 );
+    
      // trace message LDAP0020T
      if (this->ds_ldap_trace.m_is_enabled())                                                                                  
        this->ds_ldap_trace.m_trace( dsd_trace::LEVEL_INFO, 20, this->im_sess_no, m_get_epoch_ms(),
                                     &this->ds_conn, this->ads_ldap_entry,
-                                    "Connect Template=\"%.*(.*)s\" Max-Session=%i",
+                                    "Connect Template=\"%.*(.*)s\" Max-Session=%i, Version=%s",
                                     this->ads_ldap_entry->adsc_ldap_template->imc_len_name, ied_chs_utf_8, this->ads_ldap_entry->adsc_ldap_template + 1,
-                                    this->ads_ldap_entry->imc_conf_max_session ); 
+                                    this->ads_ldap_entry->imc_conf_max_session, CLIENT_VERSION ); 

      if (this->ads_ldap_control->ds_tcpcomp.m_startco_mh( (dsd_tcpcallback_p)&dsd_ldap::ds_tcpcb,
                                                           (void *)this->ads_ldap_control,
                                                           (struct dsd_bind_ineta_1 *)&this->ads_ldap_entry->dsc_bind_multih,
                                                           (struct dsd_target_ineta_1 *)this->ads_ldap_entry->adsc_server_ineta,
+                                                          (void *)NULL,
                                                           (unsigned short)this->ads_ldap_entry->imc_port,
                                                           TRUE /*do connect round-robin*/ ))
      { // @todo: error message to event viewer or something else...
@@ -2215,9 +2247,9 @@
  *
  * Initiates the ssl-connection to a ldap server.
  *
- * @param [in]  dsd_ldap_entry_t *adsp_ldap_entry   entry list of ldap-configurations
+ * @param[in]  adsp_ldap_entry   entry list of ldap-configurations
  *
- * @return      error (ied_ldap_failure) or successful (ied_ldap_success)
+ * @return     error (\b ied_ldap_failure) or successful (\b ied_ldap_success)
  */
 int  dsd_ldap::m_ssl_init( struct dsd_ldap_entry *adsp_ldap_entry )
 {
@@ -2265,9 +2297,9 @@
  *
  * Performs the ssl-handshake protocol (send 'hello'...) to the SSL LDAP server.
  *
- * @param [in]  dsd_ldap_entry_t *adsp_ldap_entry   entry list of ldap-configurations
+ * @param[in]  adsp_ldap_entry   entry list of ldap-configurations
  *
- * @return      error (ied_ldap_failure) or successful (ied_ldap_success)
+ * @return     error (\b ied_ldap_failure) or successful (\b ied_ldap_success)
  */
 int  dsd_ldap::m_ssl_hello( struct dsd_ldap_entry *adsp_ldap_entry )
 {
@@ -2359,10 +2391,8 @@
  *
  * Disconnect to a ldap server by sending an 'unbind'-request.
  *
- * @param    none
+ * @return   error (\b ied_ldap_failure) or successful (\b ied_ldap_success)
  *
- * @return   error (ied_ldap_failure) or successful (ied_ldap_success)
- *
  * Comment:
  * If the function returns 'ied_ldap_failure', the error can be retrieved by 'ied_co_ldap_get_last_err'.
  */
@@ -2434,6 +2464,9 @@
    FREE_MEM( this->ads_hl_stor_per, this->achr_pwd )
    this->im_len_dn = this->im_len_pwd = 0;
   
+   // reset ldap schema
+   this->ads_ldap_schema = NULL;
+  
    return ied_ldap_success;

 } // dsd_ldap::m_ldap_close()
@@ -2444,24 +2477,25 @@
  *
  * Binds and authenticates to a ldap server.
  *
- * ASN.1:
- * BindRequest ::= [APPLICATION 0] SEQUENCE { version         INTEGER (1 ... 127),
- *                                            name            LDAPDN,
- *                                            authentication  AuthenticaionChoice
- *                                          }
+ *     ASN.1:
+ *     BindRequest ::= [APPLICATION 0] SEQUENCE { version         INTEGER (1 ... 127),
+ *                                                name            LDAPDN,
+ *                                                authentication  AuthenticaionChoice
+ *                                              }
+ *                  
+ *                      AuthenticationChoice ::= CHOICE { simple [0] OCTET STRING,
+ *                                                        sasl [3]   SaslCredentials
+ *                                                      }
+ *       
+ *                      SaslCredentials ::= SEQUENCE { mechanism   LDAPString,
+ *                                                     credentials OCTET STRING OPTIONAL
+ *                                                   }
  *
- *                  AuthenticationChoice ::= CHOICE { simple [0] OCTET STRING,
- *                                                    sasl [3]   SaslCredentials
- *                                                  }
  *
- *                  SaslCredentials ::= SEQUENCE { mechanism   LDAPString,
- *                                                 credentials OCTET STRING OPTIONAL
- *                                               }
+ * @param[in,out]   adsp_co_ldap  request structure
  *
- * @param [in,out]   struct dsd_co_ldap_1  *adsp_co_ldap  request structure
+ * @return   error (\b ied_ldap_failure) or successful (\b ied_ldap_success)
  *
- * @return   error (ied_ldap_failure) or successful (ied_ldap_success)
- *
  * Comment:
  * If the function returns 'ied_ldap_failure', the error can be retrieved by 'ied_co_ldap_get_last_err'.
  */
@@ -2488,10 +2522,14 @@
    if (this->ds_ldap_trace.m_is_enabled())                                                                                  
      this->ds_ldap_trace.m_trace( dsd_trace::LEVEL_INFO, 30, this->im_sess_no, m_get_epoch_ms(),
                                   &this->ds_conn, this->ads_ldap_entry,
-                                  "Bind Authentication=%i Realm=\"%.*(.*)s\" Userid=\"%.*(.*)s\" Administrator=\"%.*(.*)s\"",
-                                  adsp_co_ldap->iec_ldap_auth,
-                                  adsp_co_ldap->dsc_add_dn.imc_len_str, adsp_co_ldap->dsc_add_dn.iec_chs_str, adsp_co_ldap->dsc_add_dn.ac_str,
-                                  adsp_co_ldap->imc_len_userid, adsp_co_ldap->iec_chs_userid, adsp_co_ldap->ac_userid,
+                                  "Bind Authentication=%s Realm=\"%.*(.*)s\" Userid=\"%.*(.*)s\" Administrator=\"%.*(.*)s\"",
+                                  this->ds_ldap_trace.m_translate( (int)adsp_co_ldap->iec_ldap_auth, dsd_trace::S_BIND_AUTH ),
+                                  adsp_co_ldap->dsc_add_dn.ac_str ? adsp_co_ldap->dsc_add_dn.imc_len_str : sizeof "none" -1,
+                                  adsp_co_ldap->dsc_add_dn.ac_str ? adsp_co_ldap->dsc_add_dn.iec_chs_str : ied_chs_ascii_850,
+                                  adsp_co_ldap->dsc_add_dn.ac_str ? adsp_co_ldap->dsc_add_dn.ac_str : "none",
+                                  adsp_co_ldap->ac_userid ? adsp_co_ldap->imc_len_userid : sizeof "none" - 1,
+                                  adsp_co_ldap->ac_userid ? adsp_co_ldap->iec_chs_userid : ied_chs_ascii_850,
+                                  adsp_co_ldap->ac_userid ? adsp_co_ldap->ac_userid : "none",
                                   this->ads_ldap_entry->imc_len_userid, ied_chs_utf_8, this->ads_ldap_entry->achc_userid ); 


@@ -2759,13 +2797,13 @@
        while (adsl_attr_1)
        { // check the returned partial attributes...
          if (adsl_attr_1->imc_len_attr == this->ads_ldap_entry->adsc_ldap_template->imc_len_mship_attr &&
-             !_memicmp( adsl_attr_1->ac_attr, this->ads_ldap_entry->adsc_ldap_template->achc_mship_attr, adsl_attr_1->imc_len_attr ))            
+             !m_hl_memicmp( adsl_attr_1->ac_attr, this->ads_ldap_entry->adsc_ldap_template->achc_mship_attr, adsl_attr_1->imc_len_attr ))            
            // save attribute address of <memberOf>
            adsl_attr_mship = adsl_attr_1;
          else
          { 
            if (adsl_attr_1->imc_len_attr == sizeof "objectSid" - 1 &&
-               !_memicmp( adsl_attr_1->ac_attr, "objectSid", adsl_attr_1->imc_len_attr ))
+               !m_hl_memicmp( adsl_attr_1->ac_attr, (void *)"objectSid", adsl_attr_1->imc_len_attr ))
            { // 'objectSid'...
              memcpy( (void *)&dsl_sid_1,
                      (void *)adsl_attr_1->dsc_val.ac_val,
@@ -2775,7 +2813,7 @@
            else
            { // 'primaryGroupID'...
              if (adsl_attr_1->imc_len_attr == sizeof "primaryGroupID" - 1 &&
-                 !_memicmp( adsl_attr_1->ac_attr, "primaryGroupID", adsl_attr_1->imc_len_attr ))
+                 !m_hl_memicmp( adsl_attr_1->ac_attr, (void *)"primaryGroupID", adsl_attr_1->imc_len_attr ))
              { // search group associated with the 'primaryGroupID' found!
                string str_pg( adsl_attr_1->dsc_val.ac_val, adsl_attr_1->dsc_val.imc_len_val );
                iml_pg = atoi( str_pg.c_str() );
@@ -2937,12 +2975,12 @@
  * Binds and authenticates as the administrator to a ldap server. Look for a further
  * description at m_ldap_bind().
  *
- * @return   error             (ied_ldap_failure)
- *           successful        (ied_ldap_success)
- *           send blocked      (ied_ldap_send_blocked)
+ * @return   error        (\b ied_ldap_failure),
+ *           successful   (\b ied_ldap_success) or
+ *           send blocked (\b ied_ldap_send_blocked)
  *
- * Remarks:
- * If the function returns 'ied_ldap_failure', the error can be retrieved by 'ied_co_ldap_get_last_err'.
+ * Remarks:\n
+ * If the function returns 'ied_ldap_failure', the error can be retrieved by 'ied_co_ldap_get_last_err'.\n
  * The caller is responsible for the input parameters. They are not tested for validity.
  */
 int dsd_ldap::m_aux_bind_admin()
@@ -2963,23 +3001,23 @@
  * Binds and authenticates to a ldap server. Look for a further
  * description at m_ldap_bind().
  *
- * @param [in]  char            *strp_userid      user-dn (required!)
- * @param [in]  int              imp_len_userid   user-dn length
- * @param [in]  enum ied_charset iep_chs_userid   user-dn character set
- * @param [in]  char            *strp_passwd      password (utf-8, required)
- * @param [in]  int              imp_len_passwd   password length
- * @param [in]  enum ied_charset iep_chs_passwd   password character set
+ * @param[in]  strp_userid      user-dn (required!)
+ * @param[in]  imp_len_userid   user-dn length
+ * @param[in]  iep_chs_userid   user-dn character set
+ * @param[in]  strp_passwd      password (utf-8, required)
+ * @param[in]  imp_len_passwd   password length
+ * @param[in]  iep_chs_passwd   password character set
  *
- * @return   error                   (ied_ldap_failure)
- *           successful              (ied_ldap_success)
- *           send blocked            (ied_ldap_send_blocked)
- *           password expired        (ied_ldap_password_expired)
- *           invalid credentials     (ied_ldap_inv_cred)
- *           anonymous not supported (ied_ldap_auth_notsupp)
- *           password required       (ied_ldap_strong_auth_req)
+ * @return     error                   (\b ied_ldap_failure),
+ *             successful              (\b ied_ldap_success),
+ *             send blocked            (\b ied_ldap_send_blocked),
+ *             password expired        (\b ied_ldap_password_expired),
+ *             invalid credentials     (\b ied_ldap_inv_cred),
+ *             anonymous not supported (\b ied_ldap_auth_notsupp) or
+ *             password required       (\b ied_ldap_strong_auth_req)
  *
- * Remarks:
- * If the function returns 'ied_ldap_failure', the error can be retrieved by 'ied_co_ldap_get_last_err'.
+ * Remarks:\n
+ * If the function returns 'ied_ldap_failure', the error can be retrieved by 'ied_co_ldap_get_last_err'.\n
  * The caller is responsible for the input parameters. They are not tested for validity.
  */
 int dsd_ldap::m_aux_bind_simple( char *strp_userid, int imp_len_userid, enum ied_charset iep_chs_userid,
@@ -3076,15 +3114,17 @@
  * Binds and authenticates to a ldap server, using SASL credentials.
  * Look for a further description at m_ldap_bind().
  *
- * @param [in,out]  char                  **aastrp_passwd     sasl credentials (ignore character sets!)
- * @param [in,out]  int                    *aimp_len_passwd   sasl credentials length
- * @param [in]      enum ied_auth_ldap_def *aiep_ldap_auth    sasl mechanism (e.g. NTLM type 1)
+ * @param[in,out]  aastrp_passwd     sasl credentials (ignore character sets!)
+ * @param[in,out]  aimp_len_passwd   sasl credentials length
+ * @param[in]      aiep_ldap_auth    sasl mechanism (e.g. NTLM type 1)
  *
- * @return   error (ied_ldap_failure), successful (ied_ldap_success),
- *           send blocked (ied_ldap_send_blocked) or saslInProgress (ied_ldap_sasl_bind)
+ * @return     error          (\b ied_ldap_failure),
+ *             successful     (\b ied_ldap_success),
+ *             send blocked   (\b ied_ldap_send_blocked) or
+ *             saslInProgress (\b ied_ldap_sasl_bind)
  *
- * Remarks:
- * If the function returns 'ied_ldap_failure', the error can be retrieved by 'ied_co_ldap_get_last_err'.
+ * Remarks:\n
+ * If the function returns 'ied_ldap_failure', the error can be retrieved by 'ied_co_ldap_get_last_err'.\n
  * The caller is responsible for the input parameters. They are not tested for validity.
  */
 int dsd_ldap::m_aux_bind_sasl( char **aastrp_passwd, int *aimp_len_passwd, enum ied_auth_ldap_def *aiep_ldap_auth )
@@ -3167,16 +3207,16 @@
  * under the administrator's control.
  *
  * Only 'Password Modify Extended Operation'-support:
- * Set up a LDAP request [APPLICATION 23] with OID of 1.3.6.1.4.1.4203.1.11.1
+ * Set up an extended LDAP request [APPLICATION 23] with OID of 1.3.6.1.4.1.4203.1.11.1
  *
- * @param [in]  struct dsd_co_ldap_1  *adsp_co_ldap   LDAP command structure
+ * @param[in]  adsp_co_ldap   LDAP command structure
  *
- * @return   error           (ied_ldap_failure)
- *           successful      (ied_ldap_success)
- *           send blocked    (ied_ldap_send_blocked)
+ * @return     error         (\b ied_ldap_failure),
+ *             successful    (\b ied_ldap_success) or
+ *             send blocked  (\b ied_ldap_send_blocked)
  *
- * Remarks:
- * If the function returns 'ied_ldap_failure', the error can be retrieved by 'ied_co_ldap_get_last_err'.
+ * Remarks:\n
+ * If the function returns 'ied_ldap_failure', the error can be retrieved by 'ied_co_ldap_get_last_err'.\n
  * The caller is responsible for the input parameters. They are not tested for validity.
  */
 int dsd_ldap::m_ldap_password( struct dsd_co_ldap_1 *adsp_co_ldap )
@@ -3254,16 +3294,22 @@
 /**
  * Private class function:  dsd_ldap::m_aux_password_ex()
  *
- * Set up a LDAP request [APPLICATION 23] with OID of 1.3.6.1.4.1.4203.1.11.1
+ * Set up an extended LDAP request [APPLICATION 23] with OID of 1.3.6.1.4.1.4203.1.11.1
  *
- * @param [in]  struct dsd_co_ldap_1  *adsp_co_ldap   LDAP command structure
+ * ASN.1:
+ * ExtendedRequest ::= [APPLICATION 23] SEQUENCE { requestName    LDAPOID,
+ *                                                 requestValue   OCTET STRING OPTIONAL,
+ *                                               }
  *
- * @return   error           (ied_ldap_failure)
- *           successful      (ied_ldap_success)
- *           send blocked    (ied_ldap_send_blocked)
  *
- * Remarks:
- * If the function returns 'ied_ldap_failure', the error can be retrieved by 'ied_co_ldap_get_last_err'.
+ * @param[in]  adsp_co_ldap   LDAP command structure
+ *
+ * @return     error         (\b ied_ldap_failure),
+ *             successful    (\b ied_ldap_success) or
+ *             send blocked  (\b ied_ldap_send_blocked)
+ *
+ * Remarks:\n
+ * If the function returns 'ied_ldap_failure', the error can be retrieved by 'ied_co_ldap_get_last_err'.\n
  * The caller is responsible for the input parameters. They are not tested for validity.
  */
  int dsd_ldap::m_aux_password_ex( struct dsd_co_ldap_1 *adsp_co_ldap )
@@ -3280,7 +3326,7 @@
    while (adsl_OID)
    { // search OID...
      if (adsl_OID->imc_len_val == sizeof OID_PW_MODIFY_EX - 1 &&
-         !_memicmp( adsl_OID->ac_val, OID_PW_MODIFY_EX, sizeof OID_PW_MODIFY_EX - 1))
+         !m_hl_memicmp( adsl_OID->ac_val, (void *)OID_PW_MODIFY_EX, sizeof OID_PW_MODIFY_EX - 1))
        break;
      else
        adsl_OID = adsl_OID->adsc_next_val;
@@ -3297,7 +3343,10 @@
      this->ds_ldap_trace.m_trace( dsd_trace::LEVEL_INFO, 45, this->im_sess_no, m_get_epoch_ms(),
                                   &this->ds_conn, this->ads_ldap_entry,
                                   "Modify password (OID=%s) Userid=\"%.*(.*)s\"",
-                                  OID_PW_MODIFY_EX, adsp_co_ldap->imc_len_userid, adsp_co_ldap->iec_chs_userid, adsp_co_ldap->ac_userid ); 
+                                  OID_PW_MODIFY_EX,
+                                  adsp_co_ldap->ac_userid ? adsp_co_ldap->imc_len_userid : sizeof "none" - 1,
+                                  adsp_co_ldap->ac_userid ? adsp_co_ldap->iec_chs_userid : ied_chs_ascii_850,
+                                  adsp_co_ldap->ac_userid ? adsp_co_ldap->ac_userid : "none" ); 

    // OID-support found, now we can do the following...
    // 1. new_password only --> password change (administrator bind)
@@ -3397,14 +3446,13 @@
  *
  * Look for the single- or multi-valued property of an given attribute.
  *
- * @param [in]     struct dsd_ldap_attr      *adsp_ldap_attr   structure, that contains the attribute to look for
- * @param [in,out] enum   ied_ldap_attr_def  *aiep_attrtype    the result of the single /multivalue test is stored there
+ * @param[in]     adsp_ldap_attr   structure, that contains the attribute to look for
+ * @param[in,out] aiep_attrtype    the result of the single /multivalue test is stored there
  *
- * @return   error             (ied_ldap_failure)
- *           successful        (ied_ldap_success)
+ * @return        error (\b ied_ldap_failure) or successful (\b ied_ldap_success)
  *
- * Remarks:
- * If the function returns 'ied_ldap_failure', the error can be retrieved by 'ied_co_ldap_get_last_err'.
+ * Remarks:\n
+ * If the function returns 'ied_ldap_failure', the error can be retrieved by 'ied_co_ldap_get_last_err'.\n
  * The caller is responsible for the input parameters. They are not tested for validity.
  */
 int dsd_ldap::m_aux_is_singlevalued( struct dsd_ldap_attr *adsp_ldap_attr, enum ied_ldap_attr_def *aiep_attrtype )
@@ -3462,6 +3510,19 @@
      *achl_1 = ',';
      memcpy( (void *)(achl_1 + 1), this->ds_RootDSE.ads_schemacontext->ac_val, this->ds_RootDSE.ads_schemacontext->imc_len_val );
     
+     // trace message LDAP0074T
+     if (this->ds_ldap_trace.m_is_enabled())                                                                                  
+       this->ds_ldap_trace.m_trace( dsd_trace::LEVEL_INFO, 74, this->im_sess_no, m_get_epoch_ms(),
+                                    &this->ds_conn, this->ads_ldap_entry,
+                                    "IsSinglevalued Scope=%s DN=\"%.*(.*)s\" Filter=\"%.*(.*)s\" Attributelist=\"%.*(.*)s\" Max-Size=%i Max-Time=%i",
+                                    this->ds_ldap_trace.m_translate( (int)ied_sear_baseobject, dsd_trace::S_SEARCH_SCOPE ),
+                                    achl_dn ? iml_len_dn : sizeof "none" - 1,
+                                    achl_dn ? this->ds_RootDSE.ads_schemacontext->iec_chs_val : ied_chs_ascii_850,
+                                    achl_dn ? achl_dn : "none",
+                                    sizeof "(objectclass=*)" - 1, ied_chs_ascii_850, "(objectclass=*)",
+                                    sizeof "isSingleValued" - 1, ied_chs_ascii_850, "IsSingleValued",
+                                    this->ads_ldap_entry->imc_search_buf_size, this->ads_ldap_entry->imc_max_search_t_msec ); 
+    
      // build the asn.1-formatted search request...
      if (this->ds_asn1.m_printf( "{it{seeiib",
                                  this->ds_ldapreq.imc_msgid /*i*/,
@@ -3526,10 +3587,10 @@
               if (iml_rc == ied_ldap_success)
               { // test for 'singlevalued'...
                 if ((*aadsl_attr_desc)->adsc_attr->dsc_val.imc_len_val)
-                { if (_memicmp( (const char *)(*aadsl_attr_desc)->adsc_attr->dsc_val.ac_val, "TRUE", sizeof "TRUE" - 1 ) == 0)
+                { if (m_hl_memicmp( (char *)(*aadsl_attr_desc)->adsc_attr->dsc_val.ac_val, (void *)"TRUE", sizeof "TRUE" - 1 ) == 0)
                     *aiep_attrtype = ied_ldap_attr_single;
                   else
-                  { if (_memicmp( (const char *)(*aadsl_attr_desc)->adsc_attr->dsc_val.ac_val, "FALSE", sizeof "FALSE" - 1 ) == 0)
+                  { if (m_hl_memicmp( (char *)(*aadsl_attr_desc)->adsc_attr->dsc_val.ac_val, (void *)"FALSE", sizeof "FALSE" - 1 ) == 0)
                       *aiep_attrtype = ied_ldap_attr_multi;
                   }
                 } 
@@ -3551,7 +3612,7 @@
    } // end of 'schemaNamingcontext' (MSAD)
    else
    { // nonMSAD: use the common context 'subschemaSubentry'...
-     if (this->ds_RootDSE.ads_subschemaentry && this->ads_ldap_schema == NULL)
+     if (this->ds_RootDSE.ads_subschemaentry)
      { // context is set, look for an already saved LDAP-schema with the same configuration data...
        dsd_ldap_schema *adsl_schema (dsd_ldap::ads_schema_anc);
        while (adsl_schema)
@@ -3564,13 +3625,27 @@
          } 
          // next in chain
          adsl_schema = adsl_schema->ads_next;
-       }
+       } // while()
     
        // did we found a schema?
        if (this->ads_ldap_schema == NULL)
        { // no, we have ask the ldap server...
          LDAPREQ_SEARCH(this->ds_ldapreq)

+         // trace message LDAP0075T
+         if (this->ds_ldap_trace.m_is_enabled())                                                                                  
+           this->ds_ldap_trace.m_trace( dsd_trace::LEVEL_INFO, 75, this->im_sess_no, m_get_epoch_ms(),
+                                        &this->ds_conn, this->ads_ldap_entry,
+                                        "IsSingleValued Scope=%s DN=\"%.*(.*)s\" Filter=\"%.*(.*)s\" Attributelist=\"%.*(.*)s\" Max-Size=%i Max-Time=%i",
+                                        this->ds_ldap_trace.m_translate( (int)ied_sear_baseobject, dsd_trace::S_SEARCH_SCOPE ),
+                                        this->ds_RootDSE.ads_subschemaentry->ac_val ? this->ds_RootDSE.ads_subschemaentry->imc_len_val : sizeof "none" - 1,
+                                        this->ds_RootDSE.ads_subschemaentry->ac_val ? this->ds_RootDSE.ads_subschemaentry->iec_chs_val : ied_chs_ascii_850,
+                                        this->ds_RootDSE.ads_subschemaentry->ac_val ? this->ds_RootDSE.ads_subschemaentry->ac_val : "none",
+                                        sizeof "(objectclass=*)" - 1, ied_chs_ascii_850, "(objectclass=*)",
+                                        sizeof "attributeTypes" - 1, ied_chs_ascii_850, "attributeTypes",
+                                        0, this->ads_ldap_entry->imc_max_search_t_msec ); 
+
+
          // build the asn.1-formatted search request...
          if (this->ds_asn1.m_printf( "{it{seeiib",
                                      this->ds_ldapreq.imc_msgid /*i*/,
@@ -3638,8 +3713,10 @@
                   { // 'partialAttribute'-list found, search for 'singlevalued' attributes...
                     // example:
                     // "( 1.3.6.1.4.1.6275.3 NAME 'hobte' DESC 'HOB EA Terminal Emulation Settings' SYNTAX 1.3.6.1.4.1.1466.115.121.1.5 SINGLE-VALUE ... )"
-                    this->ads_ldap_schema = new class dsd_ldap_schema( this->ads_ldap_group, this->ads_ldap_entry );
+                    this->ads_ldap_schema = (dsd_ldap_schema *)m_aux_stor_alloc( &dsd_ldap::ads_hl_stor_glob, sizeof(class dsd_ldap_schema) );
+                    this->ads_ldap_schema->m_init( this->ads_ldap_group, this->ads_ldap_entry );

+
                     char *achl_1, *achl_2, *achl_3, *achl_end;                 
                     BOOL  bol_next;

@@ -3689,7 +3766,8 @@
                                            !memcmp( (void *)achl_3, (void *)"SINGLE-VALUE", sizeof "SINGLE-VALUE" - 1 )) 
                                        { // insert!
                                          if (this->ads_ldap_schema->m_htree_avl_insert( achl_1, achl_2 - achl_1,
-                                                                                        ied_ldap_attr_single ) == FALSE)
+                                                                                        ied_ldap_attr_single ) == FALSE &&
+                                             this->ads_ldap_schema->im_avl_status != dsd_ldap_schema::ALREADY_INSERTED)
                                          { // error; we can't use any schema!
                                            this->ds_ldap_error.m_set_error( ied_ldap_undef_attr_type, ied_ldap_lookup_err );
                                            return ied_ldap_failure;
@@ -3703,7 +3781,8 @@
                                      else
                                      { // string end reached, insert attribut with 'multi-valued'-property
                                        if (this->ads_ldap_schema->m_htree_avl_insert( achl_1, achl_2 - achl_1,
-                                                                                      ied_ldap_attr_multi ) == FALSE)
+                                                                                      ied_ldap_attr_multi ) == FALSE &&
+                                           this->ads_ldap_schema->im_avl_status != dsd_ldap_schema::ALREADY_INSERTED)
                                        { // error; we can't use any schema!
                                          this->ds_ldap_error.m_set_error( ied_ldap_undef_attr_type, ied_ldap_lookup_err );
                                          return ied_ldap_failure;
@@ -3771,16 +3850,17 @@
  *
  * Initiates a ldap add operation. Look for a further description at m_ldap_add().
  *
- * @param [in]  char                 *strp_dn     dn of the attribute(s) to add (utf-8)
- * @param [in]  int                   imp_len_dn  dn length
- * @param [in]  enum   ied_charset    iep_chs_dn  dn character set
- * @param [in]  struct dsd_ldap_attr *adsp_attr   list of all attribute(s) to add
+ * @param[in]  strp_dn      dn of the attribute(s) to add (utf-8)
+ * @param[in]  imp_len_dn   dn length
+ * @param[in]  iep_chs_dn   dn character set
+ * @param[in]  adsp_attr    list of all attribute(s) to add
  *
- * @return   error (ied_ldap_failure), successful (ied_ldap_success) or
- *           send blocked (ied_ldap_send_blocked)
+ * @return     error        (\b ied_ldap_failure),
+ *             successful   (\b ied_ldap_success) or
+ *             send blocked (\b ied_ldap_send_blocked)
  *
- * Remarks:
- * If the function returns 'ied_ldap_failure', the error can be retrieved by 'ied_co_ldap_get_last_err'.
+ * Remarks:\n
+ * If the function returns 'ied_ldap_failure', the error can be retrieved by 'ied_co_ldap_get_last_err'.\n
  * The caller is responsible for the input parameters. They are not tested for validity.
  */
 int dsd_ldap::m_aux_add( char *strp_dn, int imp_len_dn, enum ied_charset iep_chs_dn, struct dsd_ldap_attr *adsp_attr )
@@ -3884,17 +3964,18 @@
  * Initiates a ldap modify operation. Look for a further
  * description at m_ldap_modify().
  *
- * @param [in]  char                    *strp_dn     dn of the attribute(s) to modify (utf-8)
- * @param [in]  int                      imp_len_dn  dn length
- * @param [in]  enum   ied_charset       iep_chs_dn  dn character set
- * @param [in]  struct dsd_ldap_attr    *adsp_attr   list of all attribute(s) to modify
- * @param [in]  enum   ied_ldap_mod_def  iep_mod     ldap modify mode (ADD, REPLACE or DELETE)
+ * @param[in]  strp_dn      dn of the attribute(s) to modify (utf-8)
+ * @param[in]  imp_len_dn   dn length
+ * @param[in]  iep_chs_dn   dn character set
+ * @param[in]  adsp_attr    list of all attribute(s) to modify
+ * @param[in]  iep_mod      ldap modify mode (ADD, REPLACE or DELETE)
  *
- * @return   error (ied_ldap_failure), successful (ied_ldap_success) or
- *           send blocked (ied_ldap_send_blocked)
+ * @return     error        (\b ied_ldap_failure),
+ *             successful   (\b ied_ldap_success) or
+ *             send blocked (\b ied_ldap_send_blocked)
  *
- * Remarks:
- * If the function returns 'ied_ldap_failure', the error can be retrieved by 'ied_co_ldap_get_last_err'.
+ * Remarks:\n
+ * If the function returns 'ied_ldap_failure', the error can be retrieved by 'ied_co_ldap_get_last_err'.\n
  * The caller is responsible for the input parameters. They are not tested for validity.
  */
 int dsd_ldap::m_aux_modify( char *strp_dn, int imp_len_dn, enum ied_charset iep_chs_dn,
@@ -3979,17 +4060,18 @@
  * Initiates a special msad ldap modify operation. Look for a further
  * description at m_ldap_modify().
  *
- * @param [in]  char                    *strp_dn      user-dn
- * @param [in]  int                      imp_len_dn   user-dn length
- * @param [in]  enum   ied_charset       iep_chs_dn   user-dn character set
- * @param [in]  struct dsd_ldap_attr    *adsp_pw_old  old password to delete
- * @param [in]  struct dsd_ldap_attr    *adsp_pw_new  new password to add
+ * @param[in]  strp_userdn      user-dn
+ * @param[in]  imp_len_userdn   user-dn length
+ * @param[in]  iep_chs_userdn   user-dn character set
+ * @param[in]  adsp_pw_old      old password to delete
+ * @param[in]  adsp_pw_new      new password to add
  *
- * @return   error (ied_ldap_failure), successful (ied_ldap_success) or
- *           send blocked (ied_ldap_send_blocked)
+ * @return     error        (\b ied_ldap_failure),
+ *             successful   (\b ied_ldap_success) or
+ *             send blocked (\b ied_ldap_send_blocked)
  *
- * Remarks:
- * If the function returns 'ied_ldap_failure', the error can be retrieved by 'ied_co_ldap_get_last_err'.
+ * Remarks:\n
+ * If the function returns 'ied_ldap_failure', the error can be retrieved by 'ied_co_ldap_get_last_err'.\n
  * The caller is responsible for the input parameters. They are not tested for validity.
  */
 int dsd_ldap::m_aux_msad_modify_pw( char *strp_userdn, int imp_len_userdn, enum ied_charset iep_chs_userdn,
@@ -4076,57 +4158,60 @@
  *
  * Initiates a ldap search operation.
  *
- * ASN.1:
- * SearchRequest ::= [APPLICATION 3] SEQUENCE { baseObject   LDAPDN,
- *                                              scope        ENUMERATED { baseObject   (0),
- *                                                                        singleLevel  (1),
- *                                                                        wholeSubtree (2) },
- *                                              derefAliases ENUMERATED { neverDerefAliases   (0),
- *                                                                        derefInSearching    (1),
- *                                                                        derefFindingBaseObj (2),
- *                                                                        derefAlways         (3) },
- *                                              sizeLimit    INTEGER (0 .. maxInt),
- *                                              timeLimit    INTEGER (0 .. maxInt),
- *                                              typesOnly    BOOLEAN,
- *                                              filter       Filter,
- *                                              attributes   AttributeSelection }
+ *      ASN.1:
+ *      SearchRequest ::= [APPLICATION 3] SEQUENCE { baseObject   LDAPDN,
+ *                                                   scope        ENUMERATED { baseObject   (0),
+ *                                                                             singleLevel  (1),
+ *                                                                             wholeSubtree (2) },
+ *                                                   derefAliases ENUMERATED { neverDerefAliases   (0),
+ *                                                                             derefInSearching    (1),
+ *                                                                             derefFindingBaseObj (2),
+ *                                                                             derefAlways         (3) },
+ *                                                   sizeLimit    INTEGER (0 .. maxInt),
+ *                                                   timeLimit    INTEGER (0 .. maxInt),
+ *                                                   typesOnly    BOOLEAN,
+ *                                                   filter       Filter,
+ *                                                   attributes   AttributeSelection }
+ *     
+ *                              Filter ::= CHOICE { and             [0]  SET SIZE (1..MAX) OF filter Filter,
+ *                                                  or              [1]  SET SIZE (1..MAX) OF filter Filter,
+ *                                                  not             [2]  Filter,
+ *                                                  equalityMatch   [3]  AttributeValueAssertion,
+ *                                                  substrings      [4]  SubstringFilter,
+ *                                                  greaterOrEqual  [5]  AttributeValueAssertion,
+ *                                                  lessOrEqual     [6]  AttributeValueAssertion,
+ *                                                  present         [7]  AttributeDescription,
+ *                                                  approxMatch     [8]  AttributeValueAssertion,
+ *                                                  extensibleMatch [9]  MatchingRuleAssertion }
+ *          
+ *                              AttributeSelection ::= SEQUENCE OF selector LDAPString
+ *     
+ *                              AttributeValueAssertion ::= SEQUENCE { attributeDesc  AttributeDescription (LDAPString),
+ *                                                                     assertionValue AssertionValue       (OCTET STRING) }
+ *          
+ *                              SubstringFilter ::= SEQUENCE { type       AttributeDescription,
+ *                                                             substrings SEQUENCE SIZE OF substring CHOICE { initial [0] AssertionValue,
+ *                                                                                                            any     [1] AssertionValue,
+ *                                                                                                            final   [2] AssertionValue }
+ *                                                           }
+ *          
+ *                              MatchingRuleAssertion ::= SEQUENCE { matchingRule [1]  MatchingRuleId (LDAPString) OPTIONAL,
+ *                                                                   type         [2]  AttributeDescription        OPTIONAL,
+ *                                                                   matchValue   [3]  AssertionValue,
+ *                                                                   dnAttributes [4]  BOOLEAN
+ *                                                                 }
+ *     
+ *    
+ * @param[in,out]  adsp_co_ldap   request structure
+ * @param[in]      bop_init       internal storage class init, ir TRUE
+ * @param[in,out]  aachp_dn       pointer to the dn-string address
+ * @param[in,out]  aimp_len_dn    pointer to the dn-string length address
+ * @param[in,out]  aiep_chs_dn    pointer to the dn-string character set
  *
- *                    Filter ::= CHOICE { and             [0]  SET SIZE (1..MAX) OF filter Filter,
- *                                        or              [1]  SET SIZE (1..MAX) OF filter Filter,
- *                                        not             [2]  Filter,
- *                                        equalityMatch   [3]  AttributeValueAssertion,
- *                                        substrings      [4]  SubstringFilter,
- *                                        greaterOrEqual  [5]  AttributeValueAssertion,
- *                                        lessOrEqual     [6]  AttributeValueAssertion,
- *                                        present         [7]  AttributeDescription,
- *                                        approxMatch     [8]  AttributeValueAssertion,
- *                                        extensibleMatch [9]  MatchingRuleAssertion }
+ * @return    error        (\b ied_ldap_failure),
+ *            successful   (\b ied_ldap_success) or
+ *            send blocked (\b ied_ldap_send_blocked)
  *
- *                    AttributeSelection ::= SEQUENCE OF selector LDAPString
- *
- *                    AttributeValueAssertion ::= SEQUENCE { attributeDesc  AttributeDescription (LDAPString),
- *                                                           assertionValue AssertionValue       (OCTET STRING) }
- *
- *                    SubstringFilter ::= SEQUENCE { type       AttributeDescription,
- *                                                   substrings SEQUENCE SIZE OF substring CHOICE { initial [0] AssertionValue,
- *                                                                                                  any     [1] AssertionValue,
- *                                                                                                  final   [2] AssertionValue }
- *                                                 }
- *
- *                    MatchingRuleAssertion ::= SEQUENCE { matchingRule [1]  MatchingRuleId (LDAPString) OPTIONAL,
- *                                                         type         [2]  AttributeDescription        OPTIONAL,
- *                                                         matchValue   [3]  AssertionValue,
- *                                                         dnAttributes [4]  BOOLEAN
- *                                                       }
- *
- * @param [in,out]  struct dsd_co_ldap_1  *adsp_co_ldap   request structure
- * @param [in]      BOOL                   bol_init       internal storage class init, ir TRUE
- * @param [in,out]  char                 **aachp_dn       pointer to the dn-string address
- * @param [in,out]  int                   *aimp_len_dn    pointer to the dn-string length address
- * @param [in,out]  enum ied_charset      *aiep_chs_dn    pointer to the dn-string character set
- *
- * @return   error (ied_ldap_failure), successful (ied_ldap_success) or send blocked (ied_ldap_send_blocked)
- *
  * Comment:
  * If the function returns 'ied_ldap_failure', the error can be retrieved by 'ied_co_ldap_get_last_err'.
  * The caller is responsible for the input parameters. They are not tested for validity.
@@ -4172,13 +4257,20 @@
    if (this->ds_ldap_trace.m_is_enabled())                                                                                  
      this->ds_ldap_trace.m_trace( dsd_trace::LEVEL_INFO, 40, this->im_sess_no, m_get_epoch_ms(),
                                   &this->ds_conn, this->ads_ldap_entry,
-                                  "Search Scope=%i DN=\"%.*(.*)s\" Realm=\"%.*(.*)s\"\n           \
-Filter=\"%.*(.*)s\" Attributelist=\"%.*(.*)s\" Max-Size=%i Max-Time=%i",
-                                  adsp_co_ldap->iec_sear_scope,
-                                  adsp_co_ldap->imc_len_dn, adsp_co_ldap->iec_chs_dn, adsp_co_ldap->ac_dn,
-                                  REALM.imc_len_str, REALM.iec_chs_str, REALM.ac_str,
-                                  adsp_co_ldap->imc_len_filter, adsp_co_ldap->iec_chs_filter, adsp_co_ldap->ac_filter,
-                                  adsp_co_ldap->imc_len_attrlist, adsp_co_ldap->iec_chs_attrlist, adsp_co_ldap->ac_attrlist,
+                                  "Search Scope=%s DN=\"%.*(.*)s\" Realm=\"%.*(.*)s\" Filter=\"%.*(.*)s\" Attributelist=\"%.*(.*)s\" Max-Size=%i Max-Time=%i",
+                                  this->ds_ldap_trace.m_translate( (int)adsp_co_ldap->iec_sear_scope, dsd_trace::S_SEARCH_SCOPE ),
+                                  adsp_co_ldap->ac_dn ? adsp_co_ldap->imc_len_dn : sizeof "none" - 1,
+                                  adsp_co_ldap->ac_dn ? adsp_co_ldap->iec_chs_dn : ied_chs_ascii_850,
+                                  adsp_co_ldap->ac_dn ? adsp_co_ldap->ac_dn : "none",
+                                  REALM.ac_str ? REALM.imc_len_str : sizeof "none" - 1,
+                                  REALM.ac_str ? REALM.iec_chs_str : ied_chs_ascii_850,
+                                  REALM.ac_str ? REALM.ac_str : "none",
+                                  adsp_co_ldap->ac_filter ? adsp_co_ldap->imc_len_filter : sizeof "(objectclass=*)" - 1,
+                                  adsp_co_ldap->ac_filter ? adsp_co_ldap->iec_chs_filter : ied_chs_ascii_850,
+                                  adsp_co_ldap->ac_filter ? adsp_co_ldap->ac_filter : "(objectclass=*)",
+                                  adsp_co_ldap->ac_attrlist ? adsp_co_ldap->imc_len_attrlist : sizeof "none" - 1,
+                                  adsp_co_ldap->ac_attrlist ? adsp_co_ldap->iec_chs_attrlist : ied_chs_ascii_850,
+                                  adsp_co_ldap->ac_attrlist ? adsp_co_ldap->ac_attrlist : "none",
                                   this->ads_ldap_entry->imc_search_buf_size, this->ads_ldap_entry->imc_max_search_t_msec ); 

    // initiate ASN.1 class, if requested...
@@ -4407,9 +4499,11 @@
  * Test the validity of a given DN and returns the attributes requested by the caller. If no attribute
  * list is requested, only the DN is tested.
  *
- * @param [in,out]  struct dsd_co_ldap_1  *adsp_co_ldap   request structure
+ * @param[in,out]  adsp_co_ldap   request structure
  *
- * @return   error (ied_ldap_failure), successful (ied_ldap_success) or send blocked (ied_ldap_send_blocked)
+ * @return    error        (\b ied_ldap_failure),
+ *            successful   (\b ied_ldap_success) or
+ *            send blocked (\b ied_ldap_send_blocked)
  *
  * Comment:
  * If the function returns 'ied_ldap_failure', the error can be retrieved by 'ied_co_ldap_get_last_err'.
@@ -4595,11 +4689,12 @@
  *
  * Unbinds to a ldap server (the connection is closed!!!).
  *
- * ASN.1:
- * UnbindRequest ::= [APPLICATION 2] NULL
+ *     ASN.1:
+ *     UnbindRequest ::= [APPLICATION 2] NULL
  *
- * @return   error (ied_ldap_failure) or successful (ied_ldap_success)
  *
+ * @return   error (\b ied_ldap_failure) or successful (\b ied_ldap_success)
+ *
  * Comment:
  * If the function returns 'ied_ldap_failure', the error can be retrieved by 'ied_co_ldap_get_last_err'.
  */
@@ -4669,11 +4764,12 @@
  *
  * Cancel of a current LDAP operation (e.g. 'search').
  *
- * ASN.1:
- * AbandonRequest ::= [APPLICATION 16] MessageID
+ *     ASN.1:
+ *     AbandonRequest ::= [APPLICATION 16] MessageID
  *
- * @return   error (ied_ldap_failure) or successful (ied_ldap_success)
  *
+ * @return   error (\b ied_ldap_failure) or successful (\b ied_ldap_success)
+ *
  * Comment:
  * If the function returns 'ied_ldap_failure', the error can be retrieved by 'ied_co_ldap_get_last_err'.
  */
@@ -4738,20 +4834,22 @@
  *
  * Searches and returns the whole attribute list (with/without values ) of a given dn.
  *
- * ASN.1:
- * SearchRequest ::= [APPLICATION 3] SEQUENCE { baseObject   LDAPDN,
- *                                              scope        ENUMERATED { baseObject   (0) },
- *                                              derefAliases ENUMERATED { derefAlways  (3) },
- *                                              sizeLimit    INTEGER (0 .. maxInt),
- *                                              timeLimit    INTEGER (0 .. maxInt),
- *                                              typesOnly    True/False,
- *                                              filter       Filter '(objectClass=*)'
- *                                              attributes   NULL }
+ *      ASN.1:
+ *      SearchRequest ::= [APPLICATION 3] SEQUENCE { baseObject   LDAPDN,
+ *                                                   scope        ENUMERATED { baseObject   (0) },
+ *                                                   derefAliases ENUMERATED { derefAlways  (3) },
+ *                                                   sizeLimit    INTEGER (0 .. maxInt),
+ *                                                   timeLimit    INTEGER (0 .. maxInt),
+ *                                                   typesOnly    True/False,
+ *                                                   filter       Filter '(objectClass=*)'
+ *                                                   attributes   NULL }
  *
  *
- * @param [in,out]  struct dsd_co_ldap_1  *adsp_co_ldap   request structure
+ * @param[in,out]  adsp_co_ldap   request structure
  *
- * @return   error (ied_ldap_failure), successful (ied_ldap_success) or send blocked (ied_ldap_send_blocked)
+ * @return    error        (\b ied_ldap_failure),
+ *            successful   (\b ied_ldap_success) or
+ *            send blocked (\b ied_ldap_send_blocked)
  *
  * Comment:
  * If the function returns 'ied_ldap_failure', the error can be retrieved by 'ied_co_ldap_get_last_err'.
@@ -4796,9 +4894,11 @@
    if (this->ds_ldap_trace.m_is_enabled())                                                                                  
      this->ds_ldap_trace.m_trace( dsd_trace::LEVEL_INFO, 46, this->im_sess_no, m_get_epoch_ms(),
                                   &this->ds_conn, this->ads_ldap_entry,
-                                  "Attributelist Scope=%i DN=\"%.*(.*)s\"",
-                                  adsp_co_ldap->iec_sear_scope,
-                                  adsp_co_ldap->imc_len_dn, adsp_co_ldap->iec_chs_dn, adsp_co_ldap->ac_dn );
+                                  "Attributelist Scope=%s DN=\"%.*(.*)s\"",
+                                  this->ds_ldap_trace.m_translate( (int)adsp_co_ldap->iec_sear_scope, dsd_trace::S_SEARCH_SCOPE ),
+                                  adsp_co_ldap->ac_dn ? adsp_co_ldap->imc_len_dn : sizeof "none" - 1,
+                                  adsp_co_ldap->ac_dn ? adsp_co_ldap->iec_chs_dn : ied_chs_ascii_850,
+                                  adsp_co_ldap->ac_dn ? adsp_co_ldap->ac_dn : "none" );

    // initialize asn.1-storage manager...
    this->ds_asn1.m_init( this->ads_hl_stor_tmp );
@@ -4902,9 +5002,9 @@
  *
  * Searches the personal and(or) the group-membership of a user bound to ldap.
  *
- * @param [in,out]  struct dsd_co_ldap_1  *adsp_co_ldap  request structure
+ * @param[in,out]  adsp_co_ldap  request structure
  *
- * @return   error (ied_ldap_failure) or successful (ied_ldap_success)
+ * @return   error (\b ied_ldap_failure) or successful (\b ied_ldap_success)
  *
  * Comment:
  * If the function returns 'ied_ldap_failure', the error can be retrieved by 'ied_co_ldap_get_last_err'.
@@ -4990,11 +5090,17 @@
    if (this->ds_ldap_trace.m_is_enabled())                                                                                  
      this->ds_ldap_trace.m_trace( dsd_trace::LEVEL_INFO, 42, this->im_sess_no, m_get_epoch_ms(),
                                   &this->ds_conn, this->ads_ldap_entry,
-                                  "Membership Scope=%i DN=\"%.*(.*)s\" Filter=\"%.*(.*)s\" Attributelist=\"%.*(.*)s\"",
-                                  dsl_co_ldap.iec_sear_scope,
-                                  dsl_co_ldap.imc_len_dn, dsl_co_ldap.iec_chs_dn, dsl_co_ldap.ac_dn,
-                                  dsl_co_ldap.imc_len_filter, dsl_co_ldap.iec_chs_filter, dsl_co_ldap.ac_filter,
-                                  dsl_co_ldap.imc_len_attrlist, dsl_co_ldap.iec_chs_attrlist, dsl_co_ldap.ac_attrlist );
+                                  "Membership Scope=%s DN=\"%.*(.*)s\" Filter=\"%.*(.*)s\" Attributelist=\"%.*(.*)s\"",
+                                  this->ds_ldap_trace.m_translate( (int)adsp_co_ldap->iec_sear_scope, dsd_trace::S_SEARCH_SCOPE ),
+                                  dsl_co_ldap.ac_dn ? dsl_co_ldap.imc_len_dn : sizeof "none" - 1,
+                                  dsl_co_ldap.ac_dn ? dsl_co_ldap.iec_chs_dn : ied_chs_ascii_850,
+                                  dsl_co_ldap.ac_dn ? dsl_co_ldap.ac_dn : "none",
+                                  dsl_co_ldap.ac_filter ? dsl_co_ldap.imc_len_filter : sizeof "none" - 1,
+                                  dsl_co_ldap.ac_filter ? dsl_co_ldap.iec_chs_filter : ied_chs_ascii_850,
+                                  dsl_co_ldap.ac_filter ? dsl_co_ldap.ac_filter : "none",
+                                  dsl_co_ldap.ac_attrlist ? dsl_co_ldap.imc_len_attrlist : sizeof "none" - 1,
+                                  dsl_co_ldap.ac_attrlist ? dsl_co_ldap.iec_chs_attrlist : ied_chs_ascii_850,
+                                  dsl_co_ldap.ac_attrlist ? dsl_co_ldap.ac_attrlist : "none" );

    // perform the search-request(person)...
    iml_rc = this->m_ldap_search( &dsl_co_ldap, FALSE /*no storage handler init*/ );
@@ -5158,9 +5264,9 @@
  * Searches the personal and(or) the group-membership of any user. You have to do this
  * with the administrator account.
  *
- * @param [in,out]  struct dsd_co_ldap_1  *adsp_co_ldap  request structure
+ * @param[in,out]  adsp_co_ldap  request structure
  *
- * @return   error (ied_ldap_failure) or successful (ied_ldap_success)
+ * @return         error (\b ied_ldap_failure) or successful (\b ied_ldap_success)
  *
  * Comment:
  * If the function returns 'ied_ldap_failure', the error can be retrieved by 'ied_co_ldap_get_last_err'.
@@ -5278,11 +5384,17 @@
      if (this->ds_ldap_trace.m_is_enabled())                                                                                  
        this->ds_ldap_trace.m_trace( dsd_trace::LEVEL_INFO, 43, this->im_sess_no, m_get_epoch_ms(),
                                     &this->ds_conn, this->ads_ldap_entry,
-                                    "Membership(Any) Scope=%i DN=\"%.*(.*)s\" Filter=\"%.*(.*)s\" Attributelist=\"%.*(.*)s\"",
-                                    dsl_co_ldap.iec_sear_scope,
-                                    dsl_co_ldap.imc_len_dn, dsl_co_ldap.iec_chs_dn, dsl_co_ldap.ac_dn,
-                                    dsl_co_ldap.imc_len_filter, dsl_co_ldap.iec_chs_filter, dsl_co_ldap.ac_filter,
-                                    dsl_co_ldap.imc_len_attrlist, dsl_co_ldap.iec_chs_attrlist, dsl_co_ldap.ac_attrlist );
+                                    "Membership(Any) Scope=%s DN=\"%.*(.*)s\" Filter=\"%.*(.*)s\" Attributelist=\"%.*(.*)s\"",
+                                    this->ds_ldap_trace.m_translate( (int)adsp_co_ldap->iec_sear_scope, dsd_trace::S_SEARCH_SCOPE ), 
+                                    dsl_co_ldap.ac_dn ? dsl_co_ldap.imc_len_dn : sizeof "none" - 1,
+                                    dsl_co_ldap.ac_dn ? dsl_co_ldap.iec_chs_dn : ied_chs_ascii_850,
+                                    dsl_co_ldap.ac_dn ? dsl_co_ldap.ac_dn : "none",
+                                    dsl_co_ldap.ac_filter ? dsl_co_ldap.imc_len_filter : sizeof "none" - 1,
+                                    dsl_co_ldap.ac_filter ? dsl_co_ldap.iec_chs_filter : ied_chs_ascii_850,
+                                    dsl_co_ldap.ac_filter ? dsl_co_ldap.ac_filter : "none",
+                                    dsl_co_ldap.ac_attrlist ? dsl_co_ldap.imc_len_attrlist : sizeof "none" - 1,
+                                    dsl_co_ldap.ac_attrlist ? dsl_co_ldap.iec_chs_attrlist : ied_chs_ascii_850,
+                                    dsl_co_ldap.ac_attrlist ? dsl_co_ldap.ac_attrlist : "none" );

      // perform the search-request(person)...
      iml_rc = this->m_ldap_search( &dsl_co_ldap, FALSE /*no storage handler init*/ );
@@ -5460,9 +5572,9 @@
  * Returns a list of all user memberships of a given group. You have to do this
  * with the administrator account.
  *
- * @param [in,out]  struct dsd_co_ldap_1  *adsp_co_ldap  request structure
+ * @param[in,out]  adsp_co_ldap  request structure
  *
- * @return   error (ied_ldap_failure) or successful (ied_ldap_success)
+ * @return         error (\b ied_ldap_failure) or successful (\b ied_ldap_success)
  *
  * Comment:
  * If the function returns 'ied_ldap_failure', the error can be retrieved by 'ied_co_ldap_get_last_err'.
@@ -5578,11 +5690,17 @@
      if (this->ds_ldap_trace.m_is_enabled())                                                                                  
        this->ds_ldap_trace.m_trace( dsd_trace::LEVEL_INFO, 44, this->im_sess_no, m_get_epoch_ms(),
                                     &this->ds_conn, this->ads_ldap_entry,
-                                    "Membership(List) Scope=%i DN=\"%.*(.*)s\" Filter=\"%.*(.*)s\" Attributelist=\"%.*(.*)s\"",
-                                    dsl_co_ldap.iec_sear_scope,
-                                    dsl_co_ldap.imc_len_dn, dsl_co_ldap.iec_chs_dn, dsl_co_ldap.ac_dn,
-                                    dsl_co_ldap.imc_len_filter, dsl_co_ldap.iec_chs_filter, dsl_co_ldap.ac_filter,
-                                    dsl_co_ldap.imc_len_attrlist, dsl_co_ldap.iec_chs_attrlist, dsl_co_ldap.ac_attrlist );
+                                    "Membership(List) Scope=%s DN=\"%.*(.*)s\" Filter=\"%.*(.*)s\" Attributelist=\"%.*(.*)s\"",
+                                    this->ds_ldap_trace.m_translate( (int)adsp_co_ldap->iec_sear_scope, dsd_trace::S_SEARCH_SCOPE ), 
+                                    dsl_co_ldap.ac_dn ? dsl_co_ldap.imc_len_dn : sizeof "none" - 1,
+                                    dsl_co_ldap.ac_dn ? dsl_co_ldap.iec_chs_dn : ied_chs_ascii_850,
+                                    dsl_co_ldap.ac_dn ? dsl_co_ldap.ac_dn : "none",
+                                    dsl_co_ldap.ac_filter ? dsl_co_ldap.imc_len_filter : sizeof "none" - 1,
+                                    dsl_co_ldap.ac_filter ? dsl_co_ldap.iec_chs_filter : ied_chs_ascii_850,
+                                    dsl_co_ldap.ac_filter ? dsl_co_ldap.ac_filter : "none",
+                                    dsl_co_ldap.ac_attrlist ? dsl_co_ldap.imc_len_attrlist : sizeof "none" - 1,
+                                    dsl_co_ldap.ac_attrlist ? dsl_co_ldap.iec_chs_attrlist : ied_chs_ascii_850,
+                                    dsl_co_ldap.ac_attrlist ? dsl_co_ldap.ac_attrlist : "none" );

      // perform the search-request(group-list)...
      iml_rc = this->m_ldap_search( &dsl_co_ldap, FALSE /*no storage handler init*/ );
@@ -5668,29 +5786,31 @@
  *
  * Initiates a ldap extened add operation.
  *
- * ASN.1:
- * AddRequest ::= [APPLICATION 8] SEQUENCE { entry       LDAPDN,
- *                                           attributes  AttributeList
- *                                         }
+ *      ASN.1:
+ *      AddRequest ::= [APPLICATION 8] SEQUENCE { entry       LDAPDN,
+ *                                                attributes  AttributeList
+ *                                              }
+ *     
+ *                     AttributeList ::= SEQUENCE of attribute Attribute
+ *     
+ *    
+ * @param[in,out]  adsp_co_ldap  request structure
+ *     
+ * @return         error (\b ied_ldap_failure) or successful (\b ied_ldap_success)
  *
- *                AttributeList ::= SEQUENCE of attribute Attribute
- *
- * @param [in,out]  struct dsd_co_ldap_1  *adsp_co_ldap  request structure
- *
- * @return   error (ied_ldap_failure) or successful (ied_ldap_success)
- *
- * Remarks:
+ * Remarks:\n
  * We only use the 'replace'-operation, because it includes the 'add'. The use of 'delete' to delete
  * partial values is not recommended, instead of the atrribute with all its values should be read and
- * replaced over this 'modify'-request.
- *
- * Comment:
+ * replaced over this 'modify'-request.\n\n
+ *
  * If the function returns 'ied_ldap_failure', the error can be retrieved by 'ied_co_ldap_get_last_err'.
  */
 int dsd_ldap::m_ldap_add( struct dsd_co_ldap_1 *adsp_co_ldap )
 {
 #define SEARCH_TO  this->ads_ldap_entry->imc_timeout_search
+#define ATTR_DESC  adsp_co_ldap->adsc_attr_desc

+
    int  iml_rc = ied_ldap_success;

    struct dsd_ldap_attr_desc *adsl_attr_desc = adsp_co_ldap->adsc_attr_desc;
@@ -5720,13 +5840,15 @@
      this->ds_ldap_trace.m_trace( dsd_trace::LEVEL_INFO, 50, this->im_sess_no, m_get_epoch_ms(),
                                   &this->ds_conn, this->ads_ldap_entry,
                                   "Add DN=\"%.*(.*)s\" Attribute(s)=\"%.*(.*)s\" Value(s)=\"%.*(.*)s\"",
-                                  adsp_co_ldap->adsc_attr_desc->imc_len_dn, adsp_co_ldap->adsc_attr_desc->iec_chs_dn, adsp_co_ldap->adsc_attr_desc->ac_dn,
-                                  adsp_co_ldap->adsc_attr_desc->adsc_attr ? adsp_co_ldap->adsc_attr_desc->adsc_attr->imc_len_attr : sizeof "none" - 1,
-                                  adsp_co_ldap->adsc_attr_desc->adsc_attr ? adsp_co_ldap->adsc_attr_desc->adsc_attr->iec_chs_attr : ied_chs_ascii_850,
-                                  adsp_co_ldap->adsc_attr_desc->adsc_attr ? adsp_co_ldap->adsc_attr_desc->adsc_attr->ac_attr : "none",
-                                  adsp_co_ldap->adsc_attr_desc->adsc_attr ? adsp_co_ldap->adsc_attr_desc->adsc_attr->dsc_val.imc_len_val : sizeof "none" - 1,
-                                  adsp_co_ldap->adsc_attr_desc->adsc_attr ? adsp_co_ldap->adsc_attr_desc->adsc_attr->dsc_val.iec_chs_val : ied_chs_ascii_850,
-                                  adsp_co_ldap->adsc_attr_desc->adsc_attr ? adsp_co_ldap->adsc_attr_desc->adsc_attr->dsc_val.ac_val : "none" );
+                                  ATTR_DESC->ac_dn ? ATTR_DESC->imc_len_dn : sizeof "none" - 1,
+                                  ATTR_DESC->ac_dn ? ATTR_DESC->iec_chs_dn : ied_chs_ascii_850,
+                                  ATTR_DESC->ac_dn ? ATTR_DESC->ac_dn : "none",
+                                  ATTR_DESC->adsc_attr ? ATTR_DESC->adsc_attr->imc_len_attr : sizeof "none" - 1,
+                                  ATTR_DESC->adsc_attr ? ATTR_DESC->adsc_attr->iec_chs_attr : ied_chs_ascii_850,
+                                  ATTR_DESC->adsc_attr ? ATTR_DESC->adsc_attr->ac_attr : "none",
+                                  ATTR_DESC->adsc_attr ? ATTR_DESC->adsc_attr->dsc_val.imc_len_val : sizeof "none" - 1,
+                                  ATTR_DESC->adsc_attr ? ATTR_DESC->adsc_attr->dsc_val.iec_chs_val : ied_chs_ascii_850,
+                                  ATTR_DESC->adsc_attr ? ATTR_DESC->adsc_attr->dsc_val.ac_val : "none" );

    // initiate ASN.1 class...
    START_MEM(this->ads_hl_stor_tmp)
@@ -5751,6 +5873,7 @@

    return ied_ldap_success;

+#undef ATTR_DESC
 } // dsd_ldap::m_ldap_add()


@@ -5759,34 +5882,34 @@
  *
  * Initiates a ldap compare operation.
  *
- * ASN.1:
- * CompareRequest ::= [APPLICATION 14] SEQUENCE { entry   LDAPDN,
- *                                                ava     AttributeValueAssertion
- *                                              }
- *
- *                     AttributeValueAssertion ::= SEQUENCE { attributeDesc   AttributeDescription (LDAPString)
- *                                                            assertionValue  AssertionValue (OCTET STRING)
- *                                                          }
- *
- * Fields of the CompareRequest are:
- *
- * - entry:  the name of the entry to be compared.
- *
- * - ava:    holds the attribute value assertion to be compared.
- *
- * The resultCode is set to compareTrue, compareFalse, or an appropriate error. 
+ *      ASN.1:
+ *      CompareRequest ::= [APPLICATION 14] SEQUENCE { entry   LDAPDN,
+ *                                                     ava     AttributeValueAssertion
+ *                                                   }
+ *     
+ *                          AttributeValueAssertion ::= SEQUENCE { attributeDesc   AttributeDescription (LDAPString)
+ *                                                                 assertionValue  AssertionValue (OCTET STRING)
+ *                                                               }
+ *          
+ *      Fields of the CompareRequest are:
+ *     
+ * entry:  the name of the entry to be compared.
+ * ava:    holds the attribute value assertion to be compared.
+ *
+ *     
+ * The resultCode is set to \b compareTrue, \b compareFalse, or an appropriate error. 
  * 'compareTrue' indicates that the assertion value in the ava field matches a value
  * of the attribute or subtype according to the attribute's EQUALITY matching rule. 
  * 'compareFalse' indicates that the assertion value in the ava field and the values
  * of the attribute or subtype did not match. Other result codes indicate either that
  * the result of the comparison was undefined or that some error occurred.
  *
- * @param [in,out]  struct dsd_co_ldap_1       *adsp_co_ldap   request structure
+ * @param[in,out]  adsp_co_ldap   request structure
  *
- * @return   error         (ied_ldap_failure)
- *           compare true  (ied_ldap_cmp_true)
- *           compare false (ied_ldap_cmp_false)
- *           send blocked  (ied_ldap_send_blocked)
+ * @return         error         (\b ied_ldap_failure) ,
+ *                 compare true  (\b ied_ldap_cmp_true),
+ *                 compare false (\b ied_ldap_cmp_false) or
+ *                 send blocked  (\b ied_ldap_send_blocked)
  *
  * Comment:
  * If the function returns 'ied_ldap_failure', the error can be retrieved by 'ied_co_ldap_get_last_err'.
@@ -5822,13 +5945,15 @@
      this->ds_ldap_trace.m_trace( dsd_trace::LEVEL_INFO, 61, this->im_sess_no, m_get_epoch_ms(),
                                   &this->ds_conn, this->ads_ldap_entry,
                                   "Compare DN=\"%.*(.*)s\" Attribute=\"%.*(.*)s\" Value=\"%.*(.*)s\"",
-                                  ATTR_DESC->imc_len_dn, ATTR_DESC->iec_chs_dn, ATTR_DESC->ac_dn,
-                                  ATTR_DESC->adsc_attr->imc_len_attr,
-                                  ATTR_DESC->adsc_attr->iec_chs_attr,
-                                  ATTR_DESC->adsc_attr->ac_attr,
-                                  ATTR_DESC->adsc_attr->dsc_val.imc_len_val,
-                                  ATTR_DESC->adsc_attr->dsc_val.iec_chs_val,
-                                  ATTR_DESC->adsc_attr->dsc_val.ac_val );
+                                  ATTR_DESC->ac_dn ? ATTR_DESC->imc_len_dn : sizeof "none" - 1,
+                                  ATTR_DESC->ac_dn ? ATTR_DESC->iec_chs_dn : ied_chs_ascii_850,
+                                  ATTR_DESC->ac_dn ? ATTR_DESC->ac_dn : "none",
+                                  ATTR_DESC->adsc_attr->ac_attr ? ATTR_DESC->adsc_attr->imc_len_attr : sizeof "none" - 1,
+                                  ATTR_DESC->adsc_attr->ac_attr ? ATTR_DESC->adsc_attr->iec_chs_attr : ied_chs_ascii_850,
+                                  ATTR_DESC->adsc_attr->ac_attr ? ATTR_DESC->adsc_attr->ac_attr : "none",
+                                  ATTR_DESC->adsc_attr->dsc_val.ac_val ? ATTR_DESC->adsc_attr->dsc_val.imc_len_val : sizeof "none" - 1,
+                                  ATTR_DESC->adsc_attr->dsc_val.ac_val ? ATTR_DESC->adsc_attr->dsc_val.iec_chs_val : ied_chs_ascii_850,
+                                  ATTR_DESC->adsc_attr->dsc_val.ac_val ? ATTR_DESC->adsc_attr->dsc_val.ac_val : "none" );

    // initiate ASN.1 class...
    START_MEM(this->ads_hl_stor_tmp)
@@ -5898,39 +6023,43 @@
  *
  * Initiates a ldap modify operation.
  *
- * ASN.1:
- * ModfiyRequest ::= [APPLICATION 6] SEQUENCE { object   LDAPDN,
- *                                              changes  SEQUENCE OF change SEQUENCE
- *                                                                          { operation     ENUMERATED
- *                                                                                          { add     (0),
- *                                                                                            delete  (1),
- *                                                                                            replace (2),
- *                                                                                            ...
- *                                                                                          },
- *                                                                            modification  PartialAttribute
- *                                                                          }
- *                                            }
+ *     ASN.1:
+ *     ModfiyRequest ::= [APPLICATION 6] SEQUENCE { object   LDAPDN,
+ *                                                  changes  SEQUENCE OF change SEQUENCE
+ *                                                                              { operation     ENUMERATED
+ *                                                                                              { add     (0),
+ *                                                                                                delete  (1),
+ *                                                                                                replace (2),
+ *                                                                                                ...
+ *                                                                                              },
+ *                                                                                modification  PartialAttribute
+ *                                                                              }
+ *                                               }
  *
  *                   PartialAttribute ::= SEQUENCE { type   AttributeDescription (LDAPString),
  *                                                   vals   SET OF value  AttributeValue (OCTETString)
  *                                                 }
  *
- * @param [in,out]  struct dsd_co_ldap_1       *adsp_co_ldap   request structure
  *
- * @return   error (ied_ldap_failure), successful (ied_ldap_success) or send blocked (ied_ldap_send_blocked)
+ * @param[in,out]  adsp_co_ldap   request structure
  *
- * Remarks:
+ * @return         error        (\b ied_ldap_failure),
+ *                 successful   (\b ied_ldap_success) or
+ *                 send blocked (\b ied_ldap_send_blocked)
+ *
+ * Remarks:\n
  * We only use the 'replace'-operation, because it includes the 'add'. The use of 'delete' to delete
  * partial values is not recommended, instead of the atrribute with all its values should be read and
- * replaced over this 'modify'-request.
+ * replaced over this 'modify'-request.\n\n
  *
- * Comment:
  * If the function returns 'ied_ldap_failure', the error can be retrieved by 'ied_co_ldap_get_last_err'.
  */
 int dsd_ldap::m_ldap_modify( struct dsd_co_ldap_1 *adsp_co_ldap )
 {
 #define SEARCH_TO  this->ads_ldap_entry->imc_timeout_search
+#define ATTR_DESC  adsp_co_ldap->adsc_attr_desc

+
    int  iml_rc = ied_ldap_success;
    int  iml_cmp;
   
@@ -5965,13 +6094,15 @@
      this->ds_ldap_trace.m_trace( dsd_trace::LEVEL_INFO, 60, this->im_sess_no, m_get_epoch_ms(),
                                   &this->ds_conn, this->ads_ldap_entry,
                                   "Modify DN=\"%.*(.*)s\" Attribute(s)=\"%.*(.*)s\" Value(s)=\"%.*(.*)s\"",
-                                  adsp_co_ldap->adsc_attr_desc->imc_len_dn, adsp_co_ldap->adsc_attr_desc->iec_chs_dn, adsp_co_ldap->adsc_attr_desc->ac_dn,
-                                  adsp_co_ldap->adsc_attr_desc->adsc_attr->imc_len_attr,
-                                  adsp_co_ldap->adsc_attr_desc->adsc_attr->iec_chs_attr,
-                                  adsp_co_ldap->adsc_attr_desc->adsc_attr->ac_attr,
-                                  adsp_co_ldap->adsc_attr_desc->adsc_attr->dsc_val.imc_len_val,
-                                  adsp_co_ldap->adsc_attr_desc->adsc_attr->dsc_val.iec_chs_val,
-                                  adsp_co_ldap->adsc_attr_desc->adsc_attr->dsc_val.ac_val );
+                                  ATTR_DESC->ac_dn ? ATTR_DESC->imc_len_dn : sizeof "none" - 1,
+                                  ATTR_DESC->ac_dn ? ATTR_DESC->iec_chs_dn : ied_chs_ascii_850,
+                                  ATTR_DESC->ac_dn ? ATTR_DESC->ac_dn : "none",
+                                  ATTR_DESC->adsc_attr->ac_attr ? ATTR_DESC->adsc_attr->imc_len_attr : sizeof "none" - 1,
+                                  ATTR_DESC->adsc_attr->ac_attr ? ATTR_DESC->adsc_attr->iec_chs_attr : ied_chs_ascii_850,
+                                  ATTR_DESC->adsc_attr->ac_attr ? ATTR_DESC->adsc_attr->ac_attr : "none",
+                                  ATTR_DESC->adsc_attr->dsc_val.ac_val ? ATTR_DESC->adsc_attr->dsc_val.imc_len_val : sizeof "none" - 1,
+                                  ATTR_DESC->adsc_attr->dsc_val.ac_val ? ATTR_DESC->adsc_attr->dsc_val.iec_chs_val : ied_chs_ascii_850,
+                                  ATTR_DESC->adsc_attr->dsc_val.ac_val ? ATTR_DESC->adsc_attr->dsc_val.ac_val : "none" );

    // initiate ASN.1 class...
    START_MEM(this->ads_hl_stor_tmp)
@@ -5997,8 +6128,8 @@
   
       adsl_attr = adsl_attr_desc->adsc_attr;
       if (this->m_aux_is_singlevalued( adsl_attr, &iel_attr ) != ied_ldap_success)
-      { // error; we didn't find this attribute!
-        this->ds_ldap_error.m_set_error( ied_ldap_no_such_attr, ied_ldap_modify_err );
+      { // error; we didn't find this attribute! The error code is set by m_aux_is_singlevalued()
+        // this->ds_ldap_error.m_set_error( ied_ldap_no_such_attr, ied_ldap_modify_err );
         return ied_ldap_failure;
       }
         
@@ -6171,6 +6302,7 @@

    return ied_ldap_success;

+#undef ATTR_DESC
 } // dsd_ldap::m_ldap_modify()


@@ -6179,17 +6311,20 @@
  *
  * Changes the relative dn (RDN) of a ldap entry.
  *
- * ASN.1:
- * ModfiyDNRequest ::= [APPLICATION 12] SEQUENCE { entry         LDAPDN,
- *                                                 newrdn        RelativeLDAPDN,
- *                                                 deleteoldrdn  BOOLEAN,
- *                                                 newSuperior   [0] LDAPDN optional
- *                                               }
+ *      ASN.1:
+ *      ModfiyDNRequest ::= [APPLICATION 12] SEQUENCE { entry         LDAPDN,
+ *                                                      newrdn        RelativeLDAPDN,
+ *                                                      deleteoldrdn  BOOLEAN,
+ *                                                      newSuperior   [0] LDAPDN optional
+ *                                                    }
+ *     
+ *    
+ * @param[in,out]  adsp_co_ldap  request structure
+ *     
+ * @return         error        (\b ied_ldap_failure),  
+ *                 successful   (\b ied_ldap_success) or
+ *                 send blocked (\b ied_ldap_send_blocked)
  *
- * @param [in,out]  struct dsd_co_ldap_1  *adsp_co_ldap  request structure
- *
- * @return   error (ied_ldap_failure), successful (ied_ldap_success) or send blocked (ied_ldap_send_blocked)
- *
  * Comment:
  * If the function returns 'ied_ldap_failure', the error can be retrieved by 'ied_co_ldap_get_last_err'.
  */
@@ -6225,9 +6360,13 @@
    if (this->ds_ldap_trace.m_is_enabled())                                                                                  
      this->ds_ldap_trace.m_trace( dsd_trace::LEVEL_INFO, 70, this->im_sess_no, m_get_epoch_ms(),
                                   &this->ds_conn, this->ads_ldap_entry,
-                                  "Modify-dn DN=\"%.*(.*)s\" DN-new=\"%.*(.*)s\"",
-                                  adsp_co_ldap->imc_len_dn, adsp_co_ldap->iec_chs_dn, adsp_co_ldap->ac_dn,
-                                  adsp_co_ldap->imc_len_newrdn, adsp_co_ldap->iec_chs_newrdn, adsp_co_ldap->ac_newrdn );
+                                  "ModifyDN DN=\"%.*(.*)s\" DN-new=\"%.*(.*)s\"",
+                                  adsp_co_ldap->ac_dn ? adsp_co_ldap->imc_len_dn : sizeof "none" - 1,
+                                  adsp_co_ldap->ac_dn ? adsp_co_ldap->iec_chs_dn : ied_chs_ascii_850,
+                                  adsp_co_ldap->ac_dn ? adsp_co_ldap->ac_dn : "none",
+                                  adsp_co_ldap->ac_newrdn ? adsp_co_ldap->imc_len_newrdn : sizeof "none" - 1,
+                                  adsp_co_ldap->ac_newrdn ? adsp_co_ldap->iec_chs_newrdn : ied_chs_ascii_850,
+                                  adsp_co_ldap->ac_newrdn ? adsp_co_ldap->ac_newrdn : "none" );

    // initiate ASN.1 class...
    START_MEM(this->ads_hl_stor_tmp)
@@ -6337,9 +6476,9 @@
  *
  * Returns informations about the used ldap server.
  *
- * @param [in,out]  struct dsd_co_ldap_1  *adsp_co_ldap  request structure
+ * @param[in,out]  adsp_co_ldap  request structure
  *
- * @return   error (ied_ldap_failure) or successful (ied_ldap_success)
+ * @return         error (\b ied_ldap_failure) or successful (\b ied_ldap_success)
  *
  * Comment:
  * If the function returns 'ied_ldap_failure', the error can be retrieved by 'ied_co_ldap_get_last_err'.
@@ -6376,6 +6515,10 @@
      if (this->bo_RootDSE == FALSE)
        this->m_aux_search_RootDSE();  // don't check for any error(s) returned. That's bad luck!
       
+     // 16.01.2013; new logic, here we return the list of base-DNs on the LDAP-side
+     // We insert a new member 'adsc_base_dn_config' returning the configured base-dn 
+     // Some LDAP-server provide a default base-dn (e.g. MSAD) -> 'adsc_base_dn_default'
+    
      // set base-dn(s) - "namingcontexts"
      if (this->ads_ldap_entry->imc_len_base_dn == 0)
      { // nothing configured -> ask the server..
@@ -6415,9 +6558,9 @@
  *
  * Returns informations about the user's password expire date.
  *
- * @param [in,out]  struct dsd_co_ldap_1  *adsp_co_ldap  request structure
+ * @param[in,out]  adsp_co_ldap  request structure
  *
- * @return   error (ied_ldap_failure) or successful (ied_ldap_success)
+ * @return         error (\b ied_ldap_failure) or successful (\b ied_ldap_success)
  *
  * Comment:
  * If the function returns 'ied_ldap_failure', the error can be retrieved by 'ied_co_ldap_get_last_err'.
@@ -6622,9 +6765,9 @@
  *
  * Returns informations about the current bind-context.
  *
- * @param [in,out]  struct dsd_co_ldap_1  *adsp_co_ldap  request structure
+ * @param[in,out]  adsp_co_ldap  request structure
  *
- * @return   error (ied_ldap_failure) or successful (ied_ldap_success)
+ * @return         error (\b ied_ldap_failure) or successful (\b ied_ldap_success)
  *
  * Comment:
  * If the function returns 'ied_ldap_failure', the error can be retrieved by 'ied_co_ldap_get_last_err'.
@@ -6656,29 +6799,28 @@
  *
  * Scans the LDAPResult messages.
  *
- * BindResponse     ::= [APPLICATION 1]  SEQUENCE { COMPONENTS OF LDAPResult,
- *                                                  serverSaslCreds  [7] OCTET STRING OPTIONAL
- *                                                }
- * SearchResultDone ::= [APPLICATION 5]  LDAPResult
- * ModifyResponse   ::= [APPLICATION 7]  LDAPResult
- * AddResponse      ::= [APPLICATION 9]  LDAPResult
- * DeleteResponse   ::= [APPLICATION 11] LDAPResult
- * ModifyDNResponse ::= [APPLICATION 13] LDAPResult
- * CompareResponse  ::= [APPLICATION 15] LDAPResult
+ *      BindResponse     ::= [APPLICATION 1]  SEQUENCE { COMPONENTS OF LDAPResult,
+ *                                                       serverSaslCreds  [7] OCTET STRING OPTIONAL
+ *                                                     }
+ *      SearchResultDone ::= [APPLICATION 5]  LDAPResult
+ *      ModifyResponse   ::= [APPLICATION 7]  LDAPResult
+ *      AddResponse      ::= [APPLICATION 9]  LDAPResult
+ *      DeleteResponse   ::= [APPLICATION 11] LDAPResult
+ *      ModifyDNResponse ::= [APPLICATION 13] LDAPResult
+ *      CompareResponse  ::= [APPLICATION 15] LDAPResult
+ *     
+ *      LDAPResult ::= SEQUENCE { resultCode      ENUMERATED {...},
+ *                                matchedDN       LDAPDN,
+ *                                errorMessage    LDAPString,
+ *                                referral        [3] Referral OPTIONAL
+ *                              }
+ *     
+ * @param[in]   adsp_buf   LDAPMessage structure to parse
  *
- * LDAPResult ::= SEQUENCE { resultCode      ENUMERATED {...},
- *                           matchedDN       LDAPDN,
- *                           errorMessage    LDAPString,
- *                           referral        [3] Referral OPTIONAL
- *                         }
+ * @return      resultCode(Error)
  *
- * Remarks:
+ * Remarks:\n
  * All other LDAP responses have be parsed by other routines.
- *
- *
- * @param[in]   class dsd_bufm  *adsp_buf   LDAPMessage structure to parse
- *
- * @return      int       resultCode(Error)
  */
 int dsd_ldap::m_aux_parse_resp( class dsd_bufm *adsp_buf )
 {
@@ -6699,8 +6841,8 @@
    
     // trace message LDAP0095T
     if (this->ds_ldap_trace.m_is_enabled())                                                                                  
-      this->ds_ldap_trace.m_trace_data( dsd_trace::LEVEL_DATA, 95, this->im_sess_no, m_get_epoch_ms(),
-                                        &this->ds_conn, this->ads_ldap_entry,
+      this->ds_ldap_trace.m_trace_data( dsd_trace::LEVEL_DATA, 95, this->im_sess_no, this->ds_ldapreq.imc_msgid, this->ds_ldapreq.ac_req,
+                                        m_get_epoch_ms(), &this->ds_conn, this->ads_ldap_entry,
                                         (const unsigned char *)this->ds_asn1.asn1_beg, this->ds_asn1.asn1_end - this->ds_asn1.asn1_beg );

     // test for the right messageID and the right response type...
@@ -6719,10 +6861,10 @@
       return ied_ldap_failure;
     }

-    // parse LDAPResult::= SEQUENCE { resultCode         ENUMERATED {...}
-    //                                matchedDN          LDAPDN,     --> LDAPString ::= OCTET STRING
-    //                                diagnosticMessage  LDAPString, --> LDAPString ::= OCTET STRING
-    //                              }
+    // LDAPResult::= SEQUENCE { resultCode         ENUMERATED {...}
+    //                          matchedDN          LDAPDN,     --> LDAPString ::= OCTET STRING
+    //                          diagnosticMessage  LDAPString, --> LDAPString ::= OCTET STRING
+    //                        }
     switch (this->ds_asn1.im_op)
     {
        case LDAP_RESP_SEARCH_DONE:
@@ -6812,8 +6954,12 @@
                                                                      &this->ds_conn, this->ads_ldap_entry,
                                                                      "LDAP-Error=%i DN=\"%.*(.*)s\" Message=\"%.*(.*)s\"",
                                                                      iml_result_code,
-                                                                     iml_len_dn, ied_chs_utf_8, achl_matched_dn,
-                                                                     iml_len_msg, ied_chs_utf_8, achl_diagnostic_msg );
+                                                                     achl_matched_dn ? iml_len_dn : sizeof "none" - 1,
+                                                                     ied_chs_utf_8,
+                                                                     achl_matched_dn ? achl_matched_dn : "none",
+                                                                     achl_diagnostic_msg ? iml_len_msg : sizeof "none" - 1,
+                                                                     ied_chs_utf_8,
+                                                                     achl_diagnostic_msg ? achl_diagnostic_msg : "none" );
                                       break;                            
                                } // switch(iml_result_code)                     

@@ -6837,23 +6983,44 @@
 /**
  * Private class function:  dsd_ldap::m_ldap_delete()
  *
- * Initiates a ldap delete operation.
+ * Initiates a ldap delete operation. Only leaf entries without any sub-nodes can be
+ * deleted with this function. There are two ways to delete non-leaf entries:
+ * If the LDAP server supports the following control OID (1.2.840.113556.1.4.805),
+ * the entry and all its sub-entries are deleted by one LDAP request only or, and
+ * this the normal way, we have to build a list of all sub-entries first. Then we can
+ * delete all entries beginning at the lowest level and ending with the entry at the
+ * highest level (in other words: the entry pointed by the DN of the function's call
+ * parameter list).
+ * There is a safety check against unwantedly delete of non-leaf entries. The caller
+ * of the function can set a confirmation flag to control the processing. If the flag
+ * is set to 'yes' or 'skip', the function continues and delets all sub-entries. The
+ * 'no' (default) forces the function to return with an error 'ied_ldap_not_allowed_on_nleaf'.
+ * So the function has to be called a second time with 'yes' or 'skip' for continue
+ * the delete.
+ *
  *
- * ASN.1:
- * DeleteRequest ::= [APPLICATION 10] LDAPDN
+ *     ASN.1:
+ *     DeleteRequest ::= [APPLICATION 10] LDAPDN
  *
- * @param [in,out]  struct dsd_co_ldap_1  *adsp_co_ldap  request structure
+ * Controls ::= SEQUENCE OF control Control
  *
- * @return   error (ied_ldap_failure), successful (ied_ldap_success) or
- *           send blocked (ied_ldap_send_blocked)
+ * Control ::= SEQUENCE { controlType   LDAPOID,
+ *                        criticality   BOOLEAN DEFAULT FALSE,
+ *                        controlValue  OCTET STRING OPTIONAL
+ *                      }
  *
+ *
+ * @param[in,out]  adsp_co_ldap  request structure
+ *
+ * @return         error        (\b ied_ldap_failure),
+ *                 successful   (\b ied_ldap_success) or
+ *                 send blocked (\b ied_ldap_send_blocked)
+ *
  * Comment:
  * If the function returns 'ied_ldap_failure', the error can be retrieved by 'ied_co_ldap_get_last_err'.
  */
 int dsd_ldap::m_ldap_delete( struct dsd_co_ldap_1 *adsp_co_ldap )
 {
-#define SEARCH_TO  this->ads_ldap_entry->imc_timeout_search
-
    int   iml_rc = ied_ldap_success;

    // valid connection?
@@ -6880,14 +7047,10 @@
    if (this->ds_ldap_trace.m_is_enabled())                                                                                  
      this->ds_ldap_trace.m_trace( dsd_trace::LEVEL_INFO, 55, this->im_sess_no, m_get_epoch_ms(),
                                   &this->ds_conn, this->ads_ldap_entry,
-                                  "Delete DN=\"%.*(.*)s\" Attribute(s)=\"%.*(.*)s\" Value(s)=\"%.*(.*)s\"",
-                                  adsp_co_ldap->adsc_attr_desc->imc_len_dn, adsp_co_ldap->adsc_attr_desc->iec_chs_dn, adsp_co_ldap->adsc_attr_desc->ac_dn,
-                                  adsp_co_ldap->adsc_attr_desc->adsc_attr->imc_len_attr,
-                                  adsp_co_ldap->adsc_attr_desc->adsc_attr->iec_chs_attr,
-                                  adsp_co_ldap->adsc_attr_desc->adsc_attr->ac_attr,
-                                  adsp_co_ldap->adsc_attr_desc->adsc_attr->dsc_val.imc_len_val,
-                                  adsp_co_ldap->adsc_attr_desc->adsc_attr->dsc_val.iec_chs_val,
-                                  adsp_co_ldap->adsc_attr_desc->adsc_attr->dsc_val.ac_val );
+                                  "Delete DN=\"%.*(.*)s\" ",
+                                  adsp_co_ldap->ac_dn ? adsp_co_ldap->imc_len_dn : sizeof "none" - 1,
+                                  adsp_co_ldap->ac_dn? adsp_co_ldap->iec_chs_dn : ied_chs_ascii_850,
+                                  adsp_co_ldap->ac_dn? adsp_co_ldap->ac_dn : "none" );
   
    // initiate ASN.1 class...
    START_MEM(this->ads_hl_stor_tmp)
@@ -6956,9 +7119,9 @@
  * handler, the output fields are allocated from there. So the caller is responsible for
  * the right memory handling!
  *
- * @param [in,out]  struct dsd_co_ldap_1  *adsp_co_ldap  request structure
+ * @param[in,out]  adsp_co_ldap  request structure
  *
- * @return   error (ied_ldap_failure) or successful (ied_ldap_success)
+ * @return         error (\b ied_ldap_failure) or successful (\b ied_ldap_success)
  *
  * Comment:
  * If the function returns 'ied_ldap_failure', the error can be retrieved by 'ied_co_ldap_get_last_err'.
@@ -6977,8 +7140,10 @@
    if (this->ds_ldap_trace.m_is_enabled())                                                                                  
      this->ds_ldap_trace.m_trace( dsd_trace::LEVEL_INFO, 56, this->im_sess_no, m_get_epoch_ms(),
                                   &this->ds_conn, this->ads_ldap_entry,
-                                  "Explode-dn DN=\"%.*(.*)s\"",
-                                  adsp_co_ldap->imc_len_dn, adsp_co_ldap->iec_chs_dn, adsp_co_ldap->ac_dn );
+                                  "ExplodeDN DN=\"%.*(.*)s\"",
+                                  adsp_co_ldap->ac_dn ? adsp_co_ldap->imc_len_dn : sizeof "none" - 1,
+                                  adsp_co_ldap->ac_dn ? adsp_co_ldap->iec_chs_dn : ied_chs_ascii_850,
+                                  adsp_co_ldap->ac_dn ? adsp_co_ldap->ac_dn : "none" );
               
    // check the input parameter...
    if (adsp_co_ldap->imc_len_dn == 0 || adsp_co_ldap->ac_dn == NULL)
@@ -7046,15 +7211,17 @@
           while (adsl_namingcontext)
           {  // have we reached the base-dn?
              if (iml_1 == adsl_namingcontext->imc_len_val &&
-                 !_memicmp( (const void *)achl_2,
-                            (const void *)adsl_namingcontext->ac_val,
-                            (size_t)adsl_namingcontext->imc_len_val ))
+                 !m_hl_memicmp( (void *)achl_2,
+                                (void *)adsl_namingcontext->ac_val,
+                                (size_t)adsl_namingcontext->imc_len_val ))
              { // trace message LDAP0052T
                if (this->ds_ldap_trace.m_is_enabled())                                                                                  
                  this->ds_ldap_trace.m_trace( dsd_trace::LEVEL_DATA, 52, this->im_sess_no, m_get_epoch_ms(),
                                               &this->ds_conn, this->ads_ldap_entry,
-                                              "Explode-dn RootDSE=\"%.*(.*)s\"",
-                                              adsl_namingcontext->imc_len_val, adsl_namingcontext->iec_chs_val, adsl_namingcontext->ac_val );
+                                              "ExplodeDN RootDSE=\"%.*(.*)s\"",
+                                              adsl_namingcontext->ac_val ? adsl_namingcontext->imc_len_val : sizeof "none" - 1,
+                                              adsl_namingcontext->ac_val ? adsl_namingcontext->iec_chs_val : ied_chs_ascii_850,
+                                              adsl_namingcontext->ac_val ? adsl_namingcontext->ac_val : "none" );
                // base-dn found!
                bol_basedn = TRUE;
                break;
@@ -7070,15 +7237,29 @@
           ((struct dsd_ldap_attr_desc *)*aadsl_attr_desc_1)->adsc_next_attr_desc = NULL;
           ((struct dsd_ldap_attr_desc *)*aadsl_attr_desc_1)->adsc_attr  = NULL;
           ((struct dsd_ldap_attr_desc *)*aadsl_attr_desc_1)->iec_chs_dn = dsl_uc_dn.iec_chs_str;
+          // remove blanks at the begin of this RDN
+          while (iml_2 && isspace((unsigned char)*achl_3))
+          {
+            achl_3++; iml_2--;
+          } // while()
+          ((struct dsd_ldap_attr_desc *)*aadsl_attr_desc_1)->ac_dn = achl_3;
+
+          // remove blanks at the end of this RDN
+          achl_3 += iml_2 - 1;
+          while (iml_2 && isspace((unsigned char)*achl_3))
+          {
+            achl_3--; iml_2--;
+          } // while()
           ((struct dsd_ldap_attr_desc *)*aadsl_attr_desc_1)->imc_len_dn = iml_2;
-          ((struct dsd_ldap_attr_desc *)*aadsl_attr_desc_1)->ac_dn      = achl_3;

           // trace message LDAP0053T
           if (this->ds_ldap_trace.m_is_enabled())                                                                                  
             this->ds_ldap_trace.m_trace( dsd_trace::LEVEL_DATA, 53, this->im_sess_no, m_get_epoch_ms(),
                                          &this->ds_conn, this->ads_ldap_entry,
-                                         "Explode-dn RDN=\"%.*(.*)s\"",
-                                         iml_2, dsl_uc_dn.iec_chs_str, achl_3 );
+                                         "ExplodeDN RDN=\"%.*(.*)s\"",
+                                         ((struct dsd_ldap_attr_desc *)*aadsl_attr_desc_1)->imc_len_dn,
+                                         dsl_uc_dn.iec_chs_str,
+                                         ((struct dsd_ldap_attr_desc *)*aadsl_attr_desc_1)->ac_dn );
        
           // address for the next insert...
           aadsl_attr_desc_1 = &((struct dsd_ldap_attr_desc *)*aadsl_attr_desc_1)->adsc_next_attr_desc;
@@ -7108,7 +7289,7 @@
      if (this->ds_ldap_trace.m_is_enabled())                                                                                  
        this->ds_ldap_trace.m_trace( dsd_trace::LEVEL_DATA, 54, this->im_sess_no, m_get_epoch_ms(),
                                     &this->ds_conn, this->ads_ldap_entry,
-                                    "Explode-dn RDN=\"%.*(.*)s\"",
+                                    "ExplodeDN RDN=\"%.*(.*)s\"",
                                     iml_1, dsl_uc_dn.iec_chs_str, achl_3 );
    }      

@@ -7123,9 +7304,9 @@
  * Clones given RDNs to the actual connected LDAP server.
  * The system looks for the different RDNs and creates it they don't exist.
  *
- * @param [in,out]  struct dsd_co_ldap_1  *adsp_co_ldap  request structure
+ * @param[in,out]  adsp_co_ldap  request structure
  *
- * @return   error (ied_ldap_failure) or successful (ied_ldap_success)
+ * @return         error (\b ied_ldap_failure) or successful (\b ied_ldap_success)
  *
  * Comment:
  * If the function returns 'ied_ldap_failure', the error can be retrieved by 'ied_co_ldap_get_last_err'.
@@ -7202,8 +7383,8 @@
      
       // set new anchor and step to the next attribute description
       adsl_list_1->adsc_next = adsl_list_anc;
+      adsl_list_anc = adsl_list_1;

-      adsl_list_anc  = adsl_list_1;
       adsl_attr_desc = adsl_attr_desc->adsc_next_attr_desc;
    }; // while(RDNs)

@@ -7376,9 +7557,9 @@
         { // take value...
           achl_1++;
           // container or user/group-entry?
-          iml_cn = _memicmp( (void *)(adsl_list_1 + 1),
-                             (void *)this->ads_ldap_entry->adsc_ldap_template->achc_upref,
-                             this->ads_ldap_entry->adsc_ldap_template->imc_len_upref );
+          iml_cn = m_hl_memicmp( (void *)(adsl_list_1 + 1),
+                                 (void *)this->ads_ldap_entry->adsc_ldap_template->achc_upref,
+                                 this->ads_ldap_entry->adsc_ldap_template->imc_len_upref );
                             
           if (!iml_cn)
           { // note: only the last entry in the chain can be a user/group entry!
@@ -7475,7 +7656,7 @@
           } // user/group-entry
           else
           { // domain or container?
-            if (!_memicmp( (void *)(adsl_list_1 + 1), (void *)"dc", 2 ))
+            if (!m_hl_memicmp( (void *)(adsl_list_1 + 1), (void *)"dc", 2 ))
             { // domain...
               dsl_oc.dsc_val.adsc_next_val = &dsl_val_domain;
               dsl_oc.adsc_next_attr = &dsl_attr_dc;
@@ -7556,33 +7737,35 @@
  *
  * Searches for the 'namingcontexts'-entries of the LDAP directory and
  *
- * ASN.1:
- * SearchRequest ::= [APPLICATION 3] SEQUENCE { baseObject   none,
- *                                              scope        baseObject (0),
- *                                              derefAliases neverDerefAliases (0),
- *                                              sizeLimit    INTEGER (0 .. maxInt),
- *                                              timeLimit    INTEGER (0 .. maxInt),
- *                                              typesOnly    False,
- *                                              filter       present('objectclass'),
- *                                              attributes   'namingContexts' 'subschemSubentry' 'defaultNamingContext'
- *                                                           'schemaNamingContext' 'supportedSASLMechanisms'
- *                                                           'supportedExtension' 'vendorname' 'vendorversion'
- *                                            }
- *
- * MSAD only:
- * SearchRequest ::= [APPLICATION 3] SEQUENCE { baseObject   none,
- *                                              scope        wholeSubtree (0),
- *                                              derefAliases neverDerefAliases (0),
- *                                              sizeLimit    INTEGER (0 .. maxInt),
- *                                              timeLimit    INTEGER (0 .. maxInt),
- *                                              typesOnly    False,
- *                                              filter       present('objectclass=domainDNS'),
- *                                              attributes   'objectSID'
- *                                            }
- *
- * @return   error (ied_ldap_failure), successful (ied_ldap_success) or
- *           send blocked (ied_ldap_send_blocked)
- *
+ *      ASN.1:
+ *      SearchRequest ::= [APPLICATION 3] SEQUENCE { baseObject   none,
+ *                                                   scope        baseObject (0),
+ *                                                   derefAliases neverDerefAliases (0),
+ *                                                   sizeLimit    INTEGER (0 .. maxInt),
+ *                                                   timeLimit    INTEGER (0 .. maxInt),
+ *                                                   typesOnly    False,
+ *                                                   filter       present('objectclass'),
+ *                                                   attributes   'namingContexts' 'subschemSubentry' 'defaultNamingContext'
+ *                                                                'schemaNamingContext' 'supportedSASLMechanisms'
+ *                                                                'supportedExtension' 'vendorname' 'vendorversion'
+ *                                                 }
+ *     
+ *      MSAD only:
+ *      SearchRequest ::= [APPLICATION 3] SEQUENCE { baseObject   none,
+ *                                                   scope        wholeSubtree (0),
+ *                                                   derefAliases neverDerefAliases (0),
+ *                                                   sizeLimit    INTEGER (0 .. maxInt),
+ *                                                   timeLimit    INTEGER (0 .. maxInt),
+ *                                                   typesOnly    False,
+ *                                                   filter       present('objectclass=domainDNS'),
+ *                                                   attributes   'objectSID'
+ *                                                 }
+ *     
+ *    
+ * @return    error        (\b ied_ldap_failure),
+ *            successful   (\b ied_ldap_success) or
+ *            send blocked (\b ied_ldap_send_blocked)
+ *     
  * Comment:
  * If the function returns 'ied_ldap_failure', the error can be retrieved by 'ied_co_ldap_get_last_err'.
  */
@@ -7658,6 +7841,7 @@
       iml_rc = this->m_recv( ied_ldap_search_err /* apicode */ );
       if (iml_rc != ied_ldap_success)
         return iml_rc;
+       
       // event posted, now parse the LDAP result (one of the SEARCH-responses set above)...
       this->ds_ldapreq.imc_l_status = dsd_ldap::dsd_ldapreq::REQ_COMPLETED;
      
@@ -7711,7 +7895,7 @@
                adsl_val_1 = &adsl_attr_1->dsc_val;

                if (adsl_attr_1->imc_len_attr == (int)strnlen( achs_RootDSE[SSub], DEF_LDAP_MAX_STRLEN ) &&
-                   !_memicmp( adsl_attr_1->ac_attr, achs_RootDSE[SSub], adsl_attr_1->imc_len_attr ))
+                   !m_hl_memicmp( adsl_attr_1->ac_attr, (void *)achs_RootDSE[SSub], adsl_attr_1->imc_len_attr ))
                { // 'subschemaSubentry'...
                  this->ds_RootDSE.ads_subschemaentry = (struct dsd_ldap_val *)m_aux_stor_alloc( &this->ads_hl_stor_per, sizeof(struct dsd_ldap_val) + adsl_val_1->imc_len_val );
                  this->ds_RootDSE.ads_subschemaentry->ac_val        = (char *)this->ds_RootDSE.ads_subschemaentry + sizeof(struct dsd_ldap_val);
@@ -7722,7 +7906,7 @@
                } 
                else
                { if (adsl_attr_1->imc_len_attr == (int)strnlen( achs_RootDSE[VName], DEF_LDAP_MAX_STRLEN ) &&
-                     !_memicmp( adsl_attr_1->ac_attr, achs_RootDSE[VName], adsl_attr_1->imc_len_attr ))
+                     !m_hl_memicmp( adsl_attr_1->ac_attr, (void *)achs_RootDSE[VName], adsl_attr_1->imc_len_attr ))
                  { // 'vendorname'...
                    this->ds_RootDSE.ads_vendorname = (struct dsd_ldap_val *)m_aux_stor_alloc( &this->ads_hl_stor_per, sizeof(struct dsd_ldap_val) + adsl_val_1->imc_len_val );
                    this->ds_RootDSE.ads_vendorname->ac_val        = (char *)this->ds_RootDSE.ads_vendorname + sizeof(struct dsd_ldap_val);
@@ -7733,7 +7917,7 @@
                  }
                  else
                  { if (adsl_attr_1->imc_len_attr == (int)strnlen( achs_RootDSE[VVer], DEF_LDAP_MAX_STRLEN ) &&
-                       !_memicmp( adsl_attr_1->ac_attr, achs_RootDSE[VVer], adsl_attr_1->imc_len_attr ))
+                       !m_hl_memicmp( adsl_attr_1->ac_attr, (void *)achs_RootDSE[VVer], adsl_attr_1->imc_len_attr ))
                    { // 'vendorversion'...
                      this->ds_RootDSE.ads_vendorversion = (struct dsd_ldap_val *)m_aux_stor_alloc( &this->ads_hl_stor_per, sizeof(struct dsd_ldap_val) + adsl_val_1->imc_len_val );
                      this->ds_RootDSE.ads_vendorversion->ac_val        = (char *)this->ds_RootDSE.ads_vendorversion + sizeof(struct dsd_ldap_val);
@@ -7744,7 +7928,7 @@
                    }
                    else
                    { if (adsl_attr_1->imc_len_attr == (int)strnlen( achs_RootDSE[DNCtx], DEF_LDAP_MAX_STRLEN ) &&
-                         !_memicmp( adsl_attr_1->ac_attr, achs_RootDSE[DNCtx], adsl_attr_1->imc_len_attr ))
+                         !m_hl_memicmp( adsl_attr_1->ac_attr, (void *)achs_RootDSE[DNCtx], adsl_attr_1->imc_len_attr ))
                      { // 'defaultNamingContext'...
                        this->ds_RootDSE.ads_defaultcontext = (struct dsd_ldap_val *)m_aux_stor_alloc( &this->ads_hl_stor_per, sizeof(struct dsd_ldap_val) + adsl_val_1->imc_len_val
);
                        this->ds_RootDSE.ads_defaultcontext->ac_val        = (char *)this->ds_RootDSE.ads_defaultcontext + sizeof(struct dsd_ldap_val);
@@ -7755,7 +7939,7 @@
                      }
                      else
                      { if (adsl_attr_1->imc_len_attr == (int)strnlen( achs_RootDSE[SNCtx], DEF_LDAP_MAX_STRLEN ) &&
-                           !_memicmp( adsl_attr_1->ac_attr, achs_RootDSE[SNCtx], adsl_attr_1->imc_len_attr ))
+                           !m_hl_memicmp( adsl_attr_1->ac_attr, (void *)achs_RootDSE[SNCtx], adsl_attr_1->imc_len_attr ))
                        { // 'schemaNamingContext' (MSAD only)
                          this->ds_RootDSE.ads_schemacontext = (struct dsd_ldap_val *)m_aux_stor_alloc( &this->ads_hl_stor_per, sizeof(struct dsd_ldap_val) + adsl_val_1->imc_len_val
);
                          this->ds_RootDSE.ads_schemacontext->ac_val        = (char *)this->ds_RootDSE.ads_schemacontext + sizeof(struct dsd_ldap_val);
@@ -7770,7 +7954,7 @@
                        }
                        else
                        { if (adsl_attr_1->imc_len_attr == (int)strnlen( achs_RootDSE[NCtx], DEF_LDAP_MAX_STRLEN ) &&
-                             !_memicmp( adsl_attr_1->ac_attr, achs_RootDSE[NCtx], adsl_attr_1->imc_len_attr ))
+                             !m_hl_memicmp( adsl_attr_1->ac_attr, (void *)achs_RootDSE[NCtx], adsl_attr_1->imc_len_attr ))
                          { // 'namingContext'...
                            aadsl_val_1 = &this->ds_RootDSE.ads_namingcontexts;
                            while (adsl_val_1)
@@ -7788,7 +7972,7 @@
                          }
                          else
                          { if (adsl_attr_1->imc_len_attr == (int)strnlen( achs_RootDSE[SMech], DEF_LDAP_MAX_STRLEN ) &&
-                               !_memicmp( adsl_attr_1->ac_attr, achs_RootDSE[SMech], adsl_attr_1->imc_len_attr ))
+                               !m_hl_memicmp( adsl_attr_1->ac_attr, (void *)achs_RootDSE[SMech], adsl_attr_1->imc_len_attr ))
                            { // 'supportedSASLMechanisms'...
                              aadsl_val_1 = &this->ds_RootDSE.ads_SASLmechanisms;
                              while (adsl_val_1)
@@ -7806,7 +7990,7 @@
                            }
                            else
                            { if (adsl_attr_1->imc_len_attr == (int)strnlen( achs_RootDSE[SExt], DEF_LDAP_MAX_STRLEN ) &&
-                               !_memicmp( adsl_attr_1->ac_attr, achs_RootDSE[SExt], adsl_attr_1->imc_len_attr ))
+                               !m_hl_memicmp( adsl_attr_1->ac_attr, (void *)achs_RootDSE[SExt], adsl_attr_1->imc_len_attr ))
                              { // 'supportedExtensions'...
                                aadsl_val_1 = &this->ds_RootDSE.ads_extendedOIDs;
                                while (adsl_val_1)
@@ -7893,23 +8077,24 @@
  *
  * Parses the 'SearchResultEntry'-operation.
  *
- * ASN.1:
- * SearchResultEntry ::= [APPLICATION 4] SEQUENCE { objectName   LDAPDN,
- *                                                  attributes   PartialAttributeList }
+ *      ASN.1:
+ *      SearchResultEntry ::= [APPLICATION 4] SEQUENCE { objectName   LDAPDN,
+ *                                                       attributes   PartialAttributeList }
+ *     
+ *                        PartialAttributeList ::= SEQUENCE OF partialAttribute PartialAttribute
+ *     
+ *                        PartialAttribute ::= SEQUENCE { type   AttributeDescription (LDAPString),
+ *                                                        vals   SET OF value  AttributeValue (OCTETString)
+ *                                                      }
  *
- *                   PartialAttributeList ::= SEQUENCE OF partialAttribute PartialAttribute
  *
- *                   PartialAttribute ::= SEQUENCE { type   AttributeDescription (LDAPString),
- *                                                   vals   SET OF value  AttributeValue (OCTETString)
- *                                                 }
+ * @param[in,out]  aadsp_ldap_attr_desc  request structure
+ * @param[in,out]  aachp_dn              pointer to the dn string address
+ * @param[in,out]  aimp_len_dn           pointer to the dn string length address
+ * @param[in,out]  aiep_chs_dn           pointer to the dn string characterset address
  *
- * @param [in,out]  struct dsd_ldap_attr_desc **aadsp_ldap_attr_desc  request structure
- * @param [in,out]  char                      **aachp_dn              pointer to the dn string address
- * @param [in,out]  int                        *aimp_len_dn           pointer to the dn string length address
- * @param [in,out]  enum ied_charset           *aiep_chs_dn           pointer to the dn string characterset address
+ * @return         error (\b ied_ldap_failure) or successful (\b ied_ldap_success)
  *
- * @return   error (ied_ldap_failure) or successful (ied_ldap_success)
- *
  * Comment:
  * If the function returns 'ied_ldap_failure', the error can be retrieved by 'ied_co_ldap_get_last_err'.
  */
@@ -8097,53 +8282,56 @@
  * Initiates a ldap search operation, beginning at the baseObject and then along the tree back to
  * the root-entry (one of the namingcontexts).
  *
- * ASN.1:
- * SearchRequest ::= [APPLICATION 3] SEQUENCE { baseObject   LDAPDN,
- *                                              scope        ENUMERATED { baseObject   (0),
- *                                                                        singleLevel  (1),
- *                                                                        wholeSubtree (2) },
- *                                              derefAliases ENUMERATED { neverDerefAliases   (0),
- *                                                                        derefInSearching    (1),
- *                                                                        derefFindingBaseObj (2),
- *                                                                        derefAlways         (3) },
- *                                              sizeLimit    INTEGER (0 .. maxInt),
- *                                              timeLimit    INTEGER (0 .. maxInt),
- *                                              typesOnly    BOOLEAN,
- *                                              filter       Filter,
- *                                              attributes   AttributeSelection }
+ *      ASN.1:
+ *      SearchRequest ::= [APPLICATION 3] SEQUENCE { baseObject   LDAPDN,
+ *                                                   scope        ENUMERATED { baseObject   (0),
+ *                                                                             singleLevel  (1),
+ *                                                                             wholeSubtree (2) },
+ *                                                   derefAliases ENUMERATED { neverDerefAliases   (0),
+ *                                                                             derefInSearching    (1),
+ *                                                                             derefFindingBaseObj (2),
+ *                                                                             derefAlways         (3) },
+ *                                                   sizeLimit    INTEGER (0 .. maxInt),
+ *                                                   timeLimit    INTEGER (0 .. maxInt),
+ *                                                   typesOnly    BOOLEAN,
+ *                                                   filter       Filter,
+ *                                                   attributes   AttributeSelection }
+ *     
+ *                         Filter ::= CHOICE { and             [0]  SET SIZE (1..MAX) OF filter Filter,
+ *                                             or              [1]  SET SIZE (1..MAX) OF filter Filter,
+ *                                             not             [2]  Filter,
+ *                                             equalityMatch   [3]  AttributeValueAssertion,
+ *                                             substrings      [4]  SubstringFilter,
+ *                                             greaterOrEqual  [5]  AttributeValueAssertion,
+ *                                             lessOrEqual     [6]  AttributeValueAssertion,
+ *                                             present         [7]  AttributeDescription,
+ *                                             approxMatch     [8]  AttributeValueAssertion,
+ *                                             extensibleMatch [9]  MatchingRuleAssertion }
+ *     
+ *                         AttributeSelection ::= SEQUENCE OF selector LDAPString
  *
- *                    Filter ::= CHOICE { and             [0]  SET SIZE (1..MAX) OF filter Filter,
- *                                        or              [1]  SET SIZE (1..MAX) OF filter Filter,
- *                                        not             [2]  Filter,
- *                                        equalityMatch   [3]  AttributeValueAssertion,
- *                                        substrings      [4]  SubstringFilter,
- *                                        greaterOrEqual  [5]  AttributeValueAssertion,
- *                                        lessOrEqual     [6]  AttributeValueAssertion,
- *                                        present         [7]  AttributeDescription,
- *                                        approxMatch     [8]  AttributeValueAssertion,
- *                                        extensibleMatch [9]  MatchingRuleAssertion }
+ *                         AttributeValueAssertion ::= SEQUENCE { attributeDesc  AttributeDescription (LDAPString),
+ *                                                                assertionValue AssertionValue       (OCTET STRING) }
+ *     
+ *                         SubstringFilter ::= SEQUENCE { type       AttributeDescription,
+ *                                                        substrings SEQUENCE SIZE OF substring CHOICE { initial [0] AssertionValue,
+ *                                                                                                       any     [1] AssertionValue,
+ *                                                                                                       final   [2] AssertionValue }
+ *                                                      }
+ *     
+ *                         MatchingRuleAssertion ::= SEQUENCE { matchingRule [1]  MatchingRuleId (LDAPString) OPTIONAL,
+ *                                                              type         [2]  AttributeDescription        OPTIONAL,
+ *                                                              matchValue   [3]  AssertionValue,
+ *                                                              dnAttributes [4]  BOOLEAN
+ *                                                            }
+ *     
+ *   
+ * @param[in,out]  adsp_co_ldap   request structure
+ *     
+ * @return         error        (\b ied_ldap_failure),
+ *                 successful   (\b ied_ldap_success) or
+ +                 send blocked (\b ied_ldap_send_blocked)
  *
- *                    AttributeSelection ::= SEQUENCE OF selector LDAPString
- *
- *                    AttributeValueAssertion ::= SEQUENCE { attributeDesc  AttributeDescription (LDAPString),
- *                                                           assertionValue AssertionValue       (OCTET STRING) }
- *
- *                    SubstringFilter ::= SEQUENCE { type       AttributeDescription,
- *                                                   substrings SEQUENCE SIZE OF substring CHOICE { initial [0] AssertionValue,
- *                                                                                                  any     [1] AssertionValue,
- *                                                                                                  final   [2] AssertionValue }
- *                                                 }
- *
- *                    MatchingRuleAssertion ::= SEQUENCE { matchingRule [1]  MatchingRuleId (LDAPString) OPTIONAL,
- *                                                         type         [2]  AttributeDescription        OPTIONAL,
- *                                                         matchValue   [3]  AssertionValue,
- *                                                         dnAttributes [4]  BOOLEAN
- *                                                       }
- *
- * @param [in,out]  struct dsd_co_ldap_1  *adsp_co_ldap   request structure
- *
- * @return   error (ied_ldap_failure), successful (ied_ldap_success) or send blocked (ied_ldap_send_blocked)
- *
  * Comment:
  * If the function returns 'ied_ldap_failure', the error can be retrieved by 'ied_co_ldap_get_last_err'.
  */
@@ -8234,6 +8422,24 @@

    // create valid LDAP message ID...
    this->ds_ldapreq.imc_msgid = this->m_get_msgid();
+  
+   // trace message LDAP0073T
+   if (this->ds_ldap_trace.m_is_enabled())                                                                                  
+     this->ds_ldap_trace.m_trace( dsd_trace::LEVEL_INFO, 73, this->im_sess_no, m_get_epoch_ms(),
+                                  &this->ds_conn, this->ads_ldap_entry,
+                                  "Search-Tree Scope=%s DN=\"%.*(.*)s\" Filter=\"%.*(.*)s\" Attributelist=\"%.*(.*)s\" Max-Size=%i Max-Time=%i",
+                                  this->ds_ldap_trace.m_translate( (int)ied_sear_baseobject, dsd_trace::S_SEARCH_SCOPE ),
+                                  achl_dn ? iml_len_dn : sizeof "none" - 1,
+                                  achl_dn ? iel_chs_dn : ied_chs_ascii_850,
+                                  achl_dn ? achl_dn : "none",
+                                  adsp_co_ldap->ac_filter ? adsp_co_ldap->imc_len_filter : sizeof "(objectclass=*)" - 1,
+                                  adsp_co_ldap->ac_filter ? adsp_co_ldap->iec_chs_filter : ied_chs_ascii_850,
+                                  adsp_co_ldap->ac_filter ? adsp_co_ldap->ac_filter : "(objectclass=*)",
+                                  adsp_co_ldap->ac_attrlist ? adsp_co_ldap->imc_len_attrlist : sizeof "none" - 1,
+                                  adsp_co_ldap->ac_attrlist ? adsp_co_ldap->iec_chs_attrlist : ied_chs_ascii_850,
+                                  adsp_co_ldap->ac_attrlist ? adsp_co_ldap->ac_attrlist : "none",
+                                  this->ads_ldap_entry->imc_search_buf_size, this->ads_ldap_entry->imc_max_search_t_msec ); 
+
    // build the asn.1-formatted search request...
    if (this->ds_asn1.m_printf( "{it{seeiib",
                                this->ds_ldapreq.imc_msgid /*i*/,
@@ -8292,6 +8498,7 @@
       iml_rc = this->m_recv( ied_ldap_search_err /* apicode */ );
       if (iml_rc != ied_ldap_success)
         return iml_rc;
+       
       // event posted, now parse the LDAP result (one of the SEARCH-responses set above)...
       this->ds_ldapreq.imc_l_status = dsd_ldap::dsd_ldapreq::REQ_COMPLETED;
      
@@ -8359,53 +8566,56 @@
  * Initiates a ldap search operation, beginning at the namingcontexts (as baseObject) and then all
  * sub-levels.
  *
- * ASN.1:
- * SearchRequest ::= [APPLICATION 3] SEQUENCE { baseObject   LDAPDN,
- *                                              scope        ENUMERATED { baseObject   (0),
- *                                                                        singleLevel  (1),
- *                                                                        wholeSubtree (2) },
- *                                              derefAliases ENUMERATED { neverDerefAliases   (0),
- *                                                                        derefInSearching    (1),
- *                                                                        derefFindingBaseObj (2),
- *                                                                        derefAlways         (3) },
- *                                              sizeLimit    INTEGER (0 .. maxInt),
- *                                              timeLimit    INTEGER (0 .. maxInt),
- *                                              typesOnly    BOOLEAN,
- *                                              filter       Filter,
- *                                              attributes   AttributeSelection }
+ *      ASN.1:
+ *      SearchRequest ::= [APPLICATION 3] SEQUENCE { baseObject   LDAPDN,
+ *                                                   scope        ENUMERATED { baseObject   (0),
+ *                                                                             singleLevel  (1),
+ *                                                                             wholeSubtree (2) },
+ *                                                   derefAliases ENUMERATED { neverDerefAliases   (0),
+ *                                                                             derefInSearching    (1),
+ *                                                                             derefFindingBaseObj (2),
+ *                                                                             derefAlways         (3) },
+ *                                                   sizeLimit    INTEGER (0 .. maxInt),
+ *                                                   timeLimit    INTEGER (0 .. maxInt),
+ *                                                   typesOnly    BOOLEAN,
+ *                                                   filter       Filter,
+ *                                                   attributes   AttributeSelection }
+ *     
+ *                         Filter ::= CHOICE { and             [0]  SET SIZE (1..MAX) OF filter Filter,
+ *                                             or              [1]  SET SIZE (1..MAX) OF filter Filter,
+ *                                             not             [2]  Filter,
+ *                                             equalityMatch   [3]  AttributeValueAssertion,
+ *                                             substrings      [4]  SubstringFilter,
+ *                                             greaterOrEqual  [5]  AttributeValueAssertion,
+ *                                             lessOrEqual     [6]  AttributeValueAssertion,
+ *                                             present         [7]  AttributeDescription,
+ *                                             approxMatch     [8]  AttributeValueAssertion,
+ *                                             extensibleMatch [9]  MatchingRuleAssertion }
+ *                        
+ *                         AttributeSelection ::= SEQUENCE OF selector LDAPString
  *
- *                    Filter ::= CHOICE { and             [0]  SET SIZE (1..MAX) OF filter Filter,
- *                                        or              [1]  SET SIZE (1..MAX) OF filter Filter,
- *                                        not             [2]  Filter,
- *                                        equalityMatch   [3]  AttributeValueAssertion,
- *                                        substrings      [4]  SubstringFilter,
- *                                        greaterOrEqual  [5]  AttributeValueAssertion,
- *                                        lessOrEqual     [6]  AttributeValueAssertion,
- *                                        present         [7]  AttributeDescription,
- *                                        approxMatch     [8]  AttributeValueAssertion,
- *                                        extensibleMatch [9]  MatchingRuleAssertion }
+ *                         AttributeValueAssertion ::= SEQUENCE { attributeDesc  AttributeDescription (LDAPString),
+ *                                                                assertionValue AssertionValue       (OCTET STRING) }
+ *                    
+ *                         SubstringFilter ::= SEQUENCE { type       AttributeDescription,
+ *                                                        substrings SEQUENCE SIZE OF substring CHOICE { initial [0] AssertionValue,
+ *                                                                                                       any     [1] AssertionValue,
+ *                                                                                                       final   [2] AssertionValue }
+ *                                                      }
+ *                    
+ *                         MatchingRuleAssertion ::= SEQUENCE { matchingRule [1]  MatchingRuleId (LDAPString) OPTIONAL,
+ *                                                              type         [2]  AttributeDescription        OPTIONAL,
+ *                                                              matchValue   [3]  AssertionValue,
+ *                                                              dnAttributes [4]  BOOLEAN
+ *                                                            }
+ *                    
+ *                   
+ * @param[in,out]   adsp_co_ldap   request structure
+ *                    
+ * @return          error        (\b ied_ldap_failure),
+ *                  successful   (\b ied_ldap_success) or
+ *                  send blocked (\b ied_ldap_send_blocked)
  *
- *                    AttributeSelection ::= SEQUENCE OF selector LDAPString
- *
- *                    AttributeValueAssertion ::= SEQUENCE { attributeDesc  AttributeDescription (LDAPString),
- *                                                           assertionValue AssertionValue       (OCTET STRING) }
- *
- *                    SubstringFilter ::= SEQUENCE { type       AttributeDescription,
- *                                                   substrings SEQUENCE SIZE OF substring CHOICE { initial [0] AssertionValue,
- *                                                                                                  any     [1] AssertionValue,
- *                                                                                                  final   [2] AssertionValue }
- *                                                 }
- *
- *                    MatchingRuleAssertion ::= SEQUENCE { matchingRule [1]  MatchingRuleId (LDAPString) OPTIONAL,
- *                                                         type         [2]  AttributeDescription        OPTIONAL,
- *                                                         matchValue   [3]  AssertionValue,
- *                                                         dnAttributes [4]  BOOLEAN
- *                                                       }
- *
- * @param [in,out]  struct dsd_co_ldap_1  *adsp_co_ldap   request structure
- *
- * @return   error (ied_ldap_failure), successful (ied_ldap_success) or send blocked (ied_ldap_send_blocked)
- *
  * Comment:
  * If the function returns 'ied_ldap_failure', the error can be retrieved by 'ied_co_ldap_get_last_err'.
  */
@@ -8451,6 +8661,24 @@

    // create valid LDAP message ID...
    this->ds_ldapreq.imc_msgid = this->m_get_msgid();
+  
+   // trace message LDAP0072T
+   if (this->ds_ldap_trace.m_is_enabled())                                                                                  
+     this->ds_ldap_trace.m_trace( dsd_trace::LEVEL_INFO, 72, this->im_sess_no, m_get_epoch_ms(),
+                                  &this->ds_conn, this->ads_ldap_entry,
+                                  "Search-Root Scope=%s DN=\"%.*(.*)s\" Filter=\"%.*(.*)s\" Attributelist=\"%.*(.*)s\" Max-Size=%i Max-Time=%i",
+                                  this->ds_ldap_trace.m_translate( (int)ied_sear_sublevel, dsd_trace::S_SEARCH_SCOPE ),
+                                  adsl_namingcontexts->ac_val ? adsl_namingcontexts->imc_len_val : sizeof "none" - 1,
+                                  adsl_namingcontexts->ac_val ? adsl_namingcontexts->iec_chs_val : ied_chs_ascii_850,
+                                  adsl_namingcontexts->ac_val ? adsl_namingcontexts->ac_val : "none",
+                                  adsp_co_ldap->ac_filter ? adsp_co_ldap->imc_len_filter : sizeof "(objectclass=*)" - 1,
+                                  adsp_co_ldap->ac_filter ? adsp_co_ldap->iec_chs_filter : ied_chs_ascii_850,
+                                  adsp_co_ldap->ac_filter ? adsp_co_ldap->ac_filter : "(objectclass=*)",
+                                  adsp_co_ldap->ac_attrlist ? adsp_co_ldap->imc_len_attrlist : sizeof "none" - 1,
+                                  adsp_co_ldap->ac_attrlist ? adsp_co_ldap->iec_chs_attrlist : ied_chs_ascii_850,
+                                  adsp_co_ldap->ac_attrlist ? adsp_co_ldap->ac_attrlist : "none",
+                                  this->ads_ldap_entry->imc_search_buf_size, this->ads_ldap_entry->imc_max_search_t_msec ); 
+
    // build the asn.1-formatted search request...
    if (this->ds_asn1.m_printf( "{it{seeiib",
                                this->ds_ldapreq.imc_msgid /*i*/,
@@ -8509,6 +8737,7 @@
       iml_rc = this->m_recv( ied_ldap_search_err /* apicode */ );
       if (iml_rc != ied_ldap_success)
         return iml_rc;
+       
       // event posted, now parse the LDAP result (one of the SEARCH-responses set above)...
       this->ds_ldapreq.imc_l_status = dsd_ldap::dsd_ldapreq::REQ_COMPLETED;
      
@@ -8566,18 +8795,17 @@
  * Convert an attribute value in a MSAD compatible unicode quoted version.
  * This must be done for the following attributes: 'unicodePwd, ...
  *
- * @param [in]   char              *achp_in       input string
- * @param [in]   int                imp_len_in    input string length
- * @param [in]   enum ied_charset   iep_chs_in    input string character set
- * @param [out]  char             **aachp_out     output string (quoted unicode, little endian)
- * @param [out]  int               *aimp_len_out  output string length
- * @param [out]  enum ied_charset  *aiep_chs_out  output string character set
+ * @param[in]   achp_in       input string
+ * @param[in]   imp_len_in    input string length
+ * @param[in]   iep_chs_in    input string character set
+ * @param[out]  aachp_out     output string (quoted unicode, little endian)
+ * @param[out]  aimp_len_out  output string length
+ * @param[out]  aiep_chs_out  output string character set
  *
- * @return   error            (ied_ldap_failure)
- *           successful       (ied_ldap_success)
+ * @return      error (\b ied_ldap_failure) or successful (\b ied_ldap_success)
  *
- * Remarks:
- * If the function returns 'ied_ldap_failure', the error can be retrieved by 'ied_co_ldap_get_last_err'.
+ * Remarks:\n
+ * If the function returns 'ied_ldap_failure', the error can be retrieved by 'ied_co_ldap_get_last_err'.\n
  * The caller is responsible for the input parameters. They are not tested for validity.
  */
 int  dsd_ldap::m_aux_msad_val(  char *achp_in, int imp_len_in, enum ied_charset iep_chs_in,
@@ -8634,10 +8862,12 @@
  *
  * Sends SSL- or nonSSL data to the LDAP server.
  *
- * @param [in]  struct dsd_gather_i_1 *adsp_gather_send  LDAP request data
- * @param [in]  int                    imp_apicode       LDAP api function code using this routine
+ * @param[in]  adsp_gather_send  LDAP request data
+ * @param[in]  imp_apicode       LDAP api function code using this routine
  *
- * @return   error (ied_ldap_failure), successful (ied_ldap_success) or send blocked (ied_ldap_send_blocked)
+ * @return     error        (\b ied_ldap_failure),
+ *             successful   (\b ied_ldap_success) or
+ *             send blocked (\b ied_ldap_send_blocked)
  *
  * Comment:
  * If the function returns 'ied_ldap_failure', the error can be retrieved by 'ied_co_ldap_get_last_err'.
@@ -8652,8 +8882,9 @@
    {
      // trace message LDAP0096T
      if (this->ds_ldap_trace.m_is_enabled())                                                                                  
-       this->ds_ldap_trace.m_trace_gather_data( dsd_trace::LEVEL_DATA, 96, this->im_sess_no, m_get_epoch_ms(),
-                                                &this->ds_conn, this->ads_ldap_entry, adsp_gather_send );
+       this->ds_ldap_trace.m_trace_gather_data( dsd_trace::LEVEL_DATA, 96, this->im_sess_no,
+                                                this->ds_ldapreq.imc_msgid, this->ds_ldapreq.ac_req,
+                                                m_get_epoch_ms(), &this->ds_conn, this->ads_ldap_entry, adsp_gather_send );

      // SSL or nonSSl?
      if (this->ads_ldap_entry->boc_csssl_conf)
@@ -8715,9 +8946,11 @@
  *
  * Receives SSL- or nonSSL data from the LDAP server.
  *
- * @param [in]  int   imp_apicode     LDAP api function code  using this routine
+ * @param[in]  imp_apicode     LDAP api function code  using this routine
  *
- * @return   error (ied_ldap_failure), successful (ied_ldap_success) or send blocked (ied_ldap_send_blocked)
+ * @return     error        (\b ied_ldap_failure),
+ *             successful   (\b ied_ldap_success) or
+ *             send blocked (\b ied_ldap_send_blocked)
  *
  * Comment:
  * If the function returns 'ied_ldap_failure', the error can be retrieved by 'ied_co_ldap_get_last_err'.
@@ -8857,13 +9090,13 @@
 /**
  * Private class function:  dsd_ldap::m_aux_sid_to_hex()
  *
- * Converts a human-readable SID in a hexadecimal-coded SID format (\x01\x00\x00\x00\x00\x00\x05...).
+ * Converts a human-readable SID in a hexadecimal-coded SID format (x01,x00,x00,x00,x00,x00,x05,...).
  *
- * @param [in]     char           *achp_sid    string-format of the SID
- * @param [in]     int             imp_len     string length
- * @param[in, out] struct dsd_sid *adsp_sid    hexadecimal-coded SID
+ * @param[in]      achp_sid    string-format of the SID
+ * @param[in]      imp_len     string length
+ * @param[in, out] adsp_sid    hexadecimal-coded SID
  *
- * @return   error (ied_ldap_failure), successful (ied_ldap_success)
+ * @return         error (\b ied_ldap_failure) or successful (\b ied_ldap_success)
  *
  * Comment:
  * If the function returns 'ied_ldap_failure', the error can be retrieved by 'ied_co_ldap_get_last_err'.
@@ -8956,11 +9189,11 @@
  *
  * Converts a hexadecimal-coded SID to a human readable SID in the form of "S-1-5-...".
  *
- * @param [in]       struct dsd_sid      *adsp_sid      hexadecimal-coded SID
- * @param [in, out]  struct dsd_ldap_val *adsp_val      string-format of the SID
- * @param [in]       void                *adsp_hl_stor  storage handler 
+ * @param[in]       adsp_sid      hexadecimal-coded SID
+ * @param[in, out]  adsp_val      string-format of the SID
+ * @param[in]       adsp_hl_stor  storage handler 
  *
- * @return   error (ied_ldap_failure), successful (ied_ldap_success)
+ * @return          error (\b ied_ldap_failure) or successful (\b ied_ldap_success)
  *
  * Comment:
  * If the function returns 'ied_ldap_failure', the error can be retrieved by 'ied_co_ldap_get_last_err'.
@@ -9041,15 +9274,15 @@
 /*| class 'dsd_asn1' ...                                                        |*/
 /*+-----------------------------------------------------------------------------+*/
 /**
- *********************************************************************************
- * class dsd_asn1
+ * \class dsd_asn1
  *
- * implements a complete ASN.1 class interface to any LDAPv3 server.
+ * Implements a complete ASN.1 class interface to any LDAPv3 server.
  *
  * Comment:
- * The functions 'm_init()' and 'm_free()' are called as the constructor
- * and the destructor. The ASN.1-fields are built as gather structures. The
- * documentation is found at \b[SOFTWARE.HCDEVE.GATHER01](@ref page3).
+ * The functions 'm_init()' is called as the class initializer. The class itself
+ * is constructed by the class dsd_ldap.\n
+ * The ASN.1-fields are built as gather structures. A detailed description is found
+ * at [SOFTWARE.HLSEC.SERDAHO1](@ref page13) in the chapter 1.6 and 1.7.
  *
  * WIN32   has to be set for 32-Bit version for windows.
  * WIN64   creates a 64-Bit windows library.
@@ -9073,17 +9306,16 @@
  */
 
 /**
- * class constructor: dsd_asn1::m_init()
+ * initialize the class: dsd_asn1::m_init()
  *
  * initializes the class dsd_asn1
  *
- * @param [in]  void  *adsp_hl_stor  hob storage handler
+ * @param[in]  adsp_hl_stor  hob storage handler
  *
- * @return      void
+ * @return     none
  *
- * Remarks:
- * The caller is responsible for the input parameters. They are not tested for
- * validity.
+ * Remarks:\n
+ * The caller is responsible for the input parameters. They are not tested for validity.
  */
 void dsd_asn1::m_init( void *adsp_hl_stor/*ASN.1-request*/ )
 {
@@ -9113,15 +9345,14 @@
  *
  * get 'integer'-value after TLV-parsing
  *
- * @param [in,out] int  *aimp_int   value bytes to return
+ * @param[in,out] aimp_int   value bytes to return
  *
- * @return   int   LASN1_SUCCESS    if everything is ok
- *                 LASN1_WAIT_MORE  if there are not enough data for processing
- *                 LASN1_ERROR      if an error in the ASN.1 Protocol is detected
+ * @return  \b LASN1_SUCCESS    if everything is ok,
+ *          \b LASN1_WAIT_MORE  if there are not enough data for processing or
+ *          \b LASN1_ERROR      if an error in the ASN.1 Protocol is detected
  *
- * Remarks:
- * The caller is responsible for the input parameters. They are not tested for
- * validity.
+ * Remarks:\n
+ * The caller is responsible for the input parameters. They are not tested for validity.
  */
 int dsd_asn1::m_get_int( int *aimp_int )
 {
@@ -9207,15 +9438,14 @@
  *
  * gets the 'boolean'-value after TLV-parsing
  *
- * @param [in,out] int  *aimp_bool  value bytes to return
+ * @param[in,out] aimp_bool  value bytes to return
  *
- * @return   int   LASN1_SUCCESS    if everything is ok
- *                 LASN1_WAIT_MORE  if there are not enough data for processing
- *                 LASN1_ERROR      if an error in the ASN.1 Protocol is detected
+ * @return  \b LASN1_SUCCESS    if everything is ok,
+ *          \b LASN1_WAIT_MORE  if there are not enough data for processing or
+ *          \b LASN1_ERROR      if an error in the ASN.1 Protocol is detected
  *
- * Remarks:
- * The caller is responsible for the input parameters. They are not tested for
- * validity.
+ * Remarks:\n
+ * The caller is responsible for the input parameters. They are not tested for validity.
  */
 int dsd_asn1::m_get_bool( BOOL *aimp_bool )
 {
@@ -9300,15 +9530,14 @@
  *
  * sets an boolean in ASN.1-notation
  *
- * @param [in]    int   imp_bool   value bytes
- * @param [in]    int   imp_tag    tag byte (LASN1_BOOLEAN or usertag)
+ * @param[in]  imp_bool   value bytes
+ * @param[in]  imp_tag    tag byte (LASN1_BOOLEAN or usertag)
  *
- * @return   int  LASN1_SUCCESS    if everything is ok
- *                LASN1_ERROR      if an error in the ASN.1 Protocol is detected
+ * @return  \b LASN1_SUCCESS    if everything is ok or
+ *          \b LASN1_ERROR      if an error in the ASN.1 Protocol is detected
  *
- * Remarks:
- * The caller is responsible for the input parameters. They are not tested for
- * validity.
+ * Remarks:\n
+ * The caller is responsible for the input parameters. They are not tested for validity.
  */
 int dsd_asn1::m_put_bool( int imp_bool/*value*/, int imp_tag/*tag*/ )
 {
@@ -9343,15 +9572,14 @@
  *
  * get 'enumeration'-value after TLV-parsing
  *
- * @param [in,out] int  *aimp_enum  value bytes to return
+ * @param[in,out] aimp_enum  value bytes to return
  *
- * @return   int   LASN1_SUCCESS    if everything is ok
- *                 LASN1_WAIT_MORE  if there are not enough data for processing
- *                 LASN1_ERROR      if an error in the ASN.1 Protocol is detected
+ * @return  \b LASN1_SUCCESS    if everything is ok,
+ *          \b LASN1_WAIT_MORE  if there are not enough data for processing or
+ *          \b LASN1_ERROR      if an error in the ASN.1 Protocol is detected
  *
- * Remarks:
- * The caller is responsible for the input parameters. They are not tested for
- * validity.
+ * Remarks:\n
+ * The caller is responsible for the input parameters. They are not tested for validity.
  */
 int dsd_asn1::m_get_enum( int *aimp_enum )
 {
@@ -9436,19 +9664,18 @@
  *
  * gets an octet-string after TLV-parsing, allocates temporary or permanent storage as needed
  *
- * @param [in,out] int  **aachp_string  pointer to string address
- * @param [in,out] int   *aimp_len      pointer to the length of the string
- * @param [in]     void **aavop_handle  permanent storage handler
+ * @param[in,out]  aachp_string  pointer to string address
+ * @param[in,out]  aimp_len      pointer to the length of the string
+ * @param[in]      aavop_handle  permanent storage handler
  *
- * @return   int   LASN1_SUCCESS    if everything is ok
- *                 LASN1_WAIT_MORE  if there are not enough data for processing
- *                 LASN1_ERROR      if an error in the ASN.1 Protocol is detected
+ * @return  \b LASN1_SUCCESS    if everything is ok,
+ *          \b LASN1_WAIT_MORE  if there are not enough data for processing or
+ *          \b LASN1_ERROR      if an error in the ASN.1 Protocol is detected
  *
- * Remarks:
- * The caller is responsible for the input parameters. They are not tested for
- * validity.
+ * Remarks:\n
+ * The caller is responsible for the input parameters. They are not tested for validity.
  */
-int dsd_asn1::m_get_string( char **aachp_string, int *aimp_len, void **aavop_handler )
+int dsd_asn1::m_get_string( char **aachp_string, int *aimp_len, void **aavop_handle )
 {
    int           iml_lenlen;
    char         *achl_beg;
@@ -9505,7 +9732,7 @@
    // copy bytes...
    if (uml_len)
    { // allocate storage and read into the low-order bytes of our buffer...
-     *aachp_string = (char *)m_aux_stor_alloc( aavop_handler ? aavop_handler : &this->ads_hl_stor, int(uml_len) );
+     *aachp_string = (char *)m_aux_stor_alloc( aavop_handle ? aavop_handle : &this->ads_hl_stor, int(uml_len) );
      *aimp_len     = uml_len;
      memcpy( (void *)*aachp_string, (const void *)achl_beg, size_t(uml_len) );

@@ -9523,16 +9750,15 @@
  *
  * gets an array(vector) of octet-strings after TLV-parsing, allocates temporary storage as needed
  *
- * @param [in,out] dsd_ldap_val **aadsp_attr_vals  pointer to the structure of values
- * @param [in]     void         **aavop_handle     permanent storage handler
+ * @param[in,out]  aadsp_attr_vals  pointer to the structure of values
+ * @param[in]      aavop_handle     permanent storage handler
  *
- * @return   int   LASN1_SUCCESS    if everything is ok
- *                 LASN1_WAIT_MORE  if there are not enough data for processing
- *                 LASN1_ERROR      if an error in the ASN.1 Protocol is detected
+ * @return  \b LASN1_SUCCESS    if everything is ok,
+ *          \b LASN1_WAIT_MORE  if there are not enough data for processing or
+ *          \b LASN1_ERROR      if an error in the ASN.1 Protocol is detected
  *
- * Remarks:
- * The caller is responsible for the input parameters. They are not tested for
- * validity.
+ * Remarks:\n
+ * The caller is responsible for the input parameters. They are not tested for validity.
  */
 int dsd_asn1::m_get_stringar( dsd_ldap_val **aadsp_attr_vals, void **aavop_handle )
 {
@@ -9618,19 +9844,18 @@
  *
  * tests the LDAP-response for a complete ASN.1-structure
  *
- * @param [in]    class dsd_bufm  *adsp_buf      received data in a dsd_bufm-structure
- * @param [out]   int             *aimp_len      minimum number of bytes for a complete parsing,
- *                                               if LASN1_WAIT_MORE is returned
- * @param [out]   int             *aimp_nextpos  position of the next ldap response
- *                                               if LASN1_SUCCESS is returned (only ssl)
+ * @param[in]    adsp_buf      received data in a dsd_bufm-structure
+ * @param[out]   aimp_len      minimum number of bytes for a complete parsing,
+ *                             if LASN1_WAIT_MORE is returned
+ * @param[out]   aimp_nextpos  position of the next ldap response
+ *                             if LASN1_SUCCESS is returned (only ssl)
  *
- * @return   int  LASN1_SUCCESS      if everything is ok
- *                LASN1_WAIT_MORE    if there are not enough data for processing
- *                LASN1_ERROR        if an error in the ASN.1 Protocol is detected
+ * @return  \b LASN1_SUCCESS      if everything is ok,
+ *          \b LASN1_WAIT_MORE    if there are not enough data for processing or
+ *          \b LASN1_ERROR        if an error in the ASN.1 Protocol is detected
  *
- * Remarks:
- * The caller is responsible for the input parameters. They are not tested for
- * validity.
+ * Remarks:\n
+ * The caller is responsible for the input parameters. They are not tested for validity.
  */
 int dsd_asn1::m_test_resp( class dsd_bufm *adsp_buf, int *aimp_len, int *aimp_nextpos )
 {
@@ -9754,15 +9979,14 @@
  *
  * get the tag after TLV-parsing
  *
- * @param [in,out] int  *aimp_tag   tag bytes to return
+ * @param[in,out]  aimp_tag   tag bytes to return
  *
- * @return   int   LASN1_SUCCESS    if everything is ok
- *                 LASN1_WAIT_MORE  if there are not enough data for processing
- *                 LASN1_ERROR      if an error in the ASN.1 Protocol is detected
+ * @return  \b LASN1_SUCCESS    if everything is ok,
+ *          \b LASN1_WAIT_MORE  if there are not enough data for processing or
+ *          \b LASN1_ERROR      if an error in the ASN.1 Protocol is detected
  *
- * Remarks:
- * The caller is responsible for the input parameters. They are not tested for
- * validity.
+ * Remarks:\n
+ * The caller is responsible for the input parameters. They are not tested for validity.
  */
 int dsd_asn1::m_get_tag( int *aimp_tag )
 {
@@ -9831,22 +10055,21 @@
  *
  * get the length after TLV-parsing
  *
- * @param [in,out] int  *aimp_len   length bytes to return
+ * @param[in,out]  aimp_len   length bytes to return
  *
- * @return   int   LASN1_SUCCESS    if everything is ok
- *                 LASN1_WAIT_MORE  if there are not enough data for processing
- *                 LASN1_ERROR      if an error in the ASN.1 Protocol is detected
+ * @return  \b LASN1_SUCCESS    if everything is ok,
+ *          \b LASN1_WAIT_MORE  if there are not enough data for processing or
+ *          \b LASN1_ERROR      if an error in the ASN.1 Protocol is detected
  *
- * Remarks:
- * The caller is responsible for the input parameters. They are not tested for
- * validity.
+ * Remarks:\n
+ * The caller is responsible for the input parameters. They are not tested for validity.
  */
 int dsd_asn1::m_get_len( int *aimp_len )
 {
    int   inl_len;
    char *achl_beg;   // temporary buffer pointer

-   // is the buffer size sufficient?
+   // is the buffer size sufficient?                              
    if (this->asn1_end - this->asn1_beg < 1 /*L, without V*/)
    { // no, we have to wait for more data...
      *aimp_len = 0;
@@ -9896,15 +10119,14 @@
  *
  * gets the ldap message id
  *
- * @param [in,out] int  *aimp_msgid   message id bytes to return
+ * @param[in,out]  aimp_msgid   message id bytes to return
  *
- * @return   int   LASN1_SUCCESS    if everything is ok
- *                 LASN1_WAIT_MORE  if there are not enough data for processing
- *                 LASN1_ERROR      if an error in the ASN.1 Protocol is detected
+ * @return  \b LASN1_SUCCESS    if everything is ok,
+ *          \b LASN1_WAIT_MORE  if there are not enough data for processing or
+ *          \b LASN1_ERROR      if an error in the ASN.1 Protocol is detected
  *
- * Remarks:
- * The caller is responsible for the input parameters. They are not tested for
- * validity.
+ * Remarks:\n
+ * The caller is responsible for the input parameters. They are not tested for validity.
  */
 int dsd_asn1::m_get_msgid( int *aimp_msgid )
 {
@@ -9919,15 +10141,14 @@
  *
  * get ldap operation byte (we don't step the buffer pointer!!!)
  *
- * @param [in,out] int  *aimp_op    operation bytes to return
+ * @param[in,out]  aimp_op      operation bytes to return
  *
- * @return   int   LASN1_SUCCESS    if everything is ok
- *                 LASN1_WAIT_MORE  if there are not enough data for processing
- *                 LASN1_ERROR      if an error in the ASN.1 Protocol is detected
+ * @return  \b LASN1_SUCCESS    if everything is ok,
+ *          \b LASN1_WAIT_MORE  if there are not enough data for processing or
+ *          \b LASN1_ERROR      if an error in the ASN.1 Protocol is detected
  *
- * Remarks:
- * The caller is responsible for the input parameters. They are not tested for
- * validity.
+ * Remarks:\n
+ * The caller is responsible for the input parameters. They are not tested for validity.
  */
 int dsd_asn1::m_get_op( int *aimp_op )
 {
@@ -9953,14 +10174,13 @@
  *
  * return the pointer to the value stream (we don't step the buffer pointer!!!)
  *
- * @param [in,out] char **achp_val  value address to return
+ * @param[in,out]  achp_val     value address to return
  *
- * @return   int   LASN1_SUCCESS    if everything is ok
- *                 LASN1_WAIT_MORE  if there are not enough data for processing
+ * @return  \b LASN1_SUCCESS    if everything is ok or
+ *          \b LASN1_WAIT_MORE  if there are not enough data for processing
  *
- * Remarks:
- * The caller is responsible for the input parameters. They are not tested for
- * validity.
+ * Remarks:\n
+ * The caller is responsible for the input parameters. They are not tested for validity.
  */
 int dsd_asn1::m_get_val( char **achp_val )
 {
@@ -9982,14 +10202,13 @@
  *
  * formats an ASN.1 message buffer.
  *
- * @param [in]  const char  *achp_fmt   operation format string
+ * @param[in]   achp_fmt   operation format string
  *
- * @return      int   LASN1_SUCCESS     if everything is ok
- *                    LASN1_ERROR       if an error in the ASN.1 Protocol is detected
+ * @return     \b LASN1_SUCCESS     if everything is ok or
+ *             \b LASN1_ERROR       if an error in the ASN.1 Protocol is detected
  *
- * Remarks:
- * The caller is responsible for the input parameters. They are not tested for
- * validity.
+ * Remarks:\n
+ * The caller is responsible for the input parameters. They are not tested for validity.
  */
 int dsd_asn1::m_printf( const char *achp_fmt, ... )
 {
@@ -10160,15 +10379,13 @@
  *
  * parses the received ASN.1 message string.
  *
- * @param [in]  const char  *achp_fmt   operation format string
+ * @param[in]   achp_fmt   operation format string
  *
- * @return      int   LASN1_SUCCESS     if everything is ok
- *                    LASN1_ERROR,
- *                    LASN1_...         if an error in the ASN.1 Protocol is detected
+ * @return     \b LASN1_SUCCESS     if everything is ok or
+ *             \b LASN1_ERROR       if an error in the ASN.1 Protocol is detected
  *
- * Remarks:
- * The caller is responsible for the input parameters. They are not tested for
- * validity.
+ * Remarks:\n
+ * The caller is responsible for the input parameters. They are not tested for validity.
  */
 int dsd_asn1::m_scanf( const char *achp_fmt, ... )
 {
@@ -10261,14 +10478,13 @@
  *
  * sets a gather chain for sending data and set statistic data
  *
- * @param [in,out]  HL_LONGLONG*  ailp_datalen  add the length of gather data (statistics)
+ * @param[in,out]  ailp_datalen  add the length of gather data (statistics)
  *
- * @return   int  LASN1_SUCCESS   if everything is ok
- *                LASN1_ERROR     if an error in the ASN.1 Protocol is detected
+ * @return   \b LASN1_SUCCESS   if everything is ok or
+ *           \b LASN1_ERROR     if an error in the ASN.1 Protocol is detected
  *
- * Remarks:
- * The caller is responsible for the input parameters. They are not tested for
- * validity.
+ * Remarks:\n
+ * The caller is responsible for the input parameters. They are not tested for validity.
  */
 int dsd_asn1::m_set_gather( HL_LONGLONG* ailp_datalen )
 {
@@ -10334,14 +10550,13 @@
  *
  * sets a null in ASN.1-notation
  *
- * @param [in]    int   imp_tag    tag byte (LASN1_NULL or usertag)
+ * @param[in]    imp_tag    tag byte (LASN1_NULL or usertag)
  *
- * @return   int  LASN1_SUCCESS    if everything is ok
- *                LASN1_ERROR      if an error in the ASN.1 Protocol is detected
+ * @return  \b LASN1_SUCCESS    if everything is ok or
+ *          \b LASN1_ERROR      if an error in the ASN.1 Protocol is detected
  *
- * Remarks:
- * The caller is responsible for the input parameters. They are not tested for
- * validity.
+ * Remarks:\n
+ * The caller is responsible for the input parameters. They are not tested for validity.
  */
 int dsd_asn1::m_put_null( int imp_tag )
 {
@@ -10374,14 +10589,13 @@
  *
  * sets the SET_OF tag
  *
- * @param [in]    int  imp_tag    tag byte (LASN1_SET or usertag)
+ * @param[in]   imp_tag    tag byte (LASN1_SET or usertag)
  *
- * @return   int  LASN1_SUCCESS   if everything is ok
- *                LASN1_ERROR     if an error in the ASN.1 Protocol is detected
+ * @return  \b LASN1_SUCCESS   if everything is ok or
+ *          \b LASN1_ERROR     if an error in the ASN.1 Protocol is detected
  *
- * Remarks:
- * The caller is responsible for the input parameters. They are not tested for
- * validity.
+ * Remarks:\n
+ * The caller is responsible for the input parameters. They are not tested for validity.
  */
 int dsd_asn1::m_start_set( int imp_tag )
 {
@@ -10395,14 +10609,11 @@
  *
  * ends the SET_OF tag and calculate the length of all elements
  *
- * @param [in]    none
+ * @return  \b LASN1_SUCCESS   if everything is ok or
+ *          \b LASN1_ERROR     if an error in the ASN.1 Protocol is detected
  *
- * @return   int  LASN1_SUCCESS   if everything is ok
- *                LASN1_ERROR     if an error in the ASN.1 Protocol is detected
- *
- * Remarks:
- * The caller is responsible for the input parameters. They are not tested for
- * validity.
+ * Remarks:\n
+ * The caller is responsible for the input parameters. They are not tested for validity.
  */
 int  dsd_asn1::m_end_set()
 {
@@ -10423,14 +10634,13 @@
  *
  * sets the SEQUENCE_OF tag
  *
- * @param [in]    int  imp_tag    tag byte (LASN1_SEQUENCE or usertag)
+ * @param[in]  imp_tag    tag byte (LASN1_SEQUENCE or usertag)
  *
- * @return   int  LASN1_SUCCESS   if everything is ok
- *                LASN1_ERROR     if an error in the ASN.1 Protocol is detected
+ * @return  \b LASN1_SUCCESS   if everything is ok or
+ *          \b LASN1_ERROR     if an error in the ASN.1 Protocol is detected
  *
- * Remarks:
- * The caller is responsible for the input parameters. They are not tested for
- * validity.
+ * Remarks:\n
+ * The caller is responsible for the input parameters. They are not tested for validity.
  */
 int dsd_asn1::m_start_seq( int imp_tag )
 {
@@ -10464,14 +10674,11 @@
  *
  * ends the SEQUENCE_OF tag and calculate the length of all elements
  *
- * @param [in]    none
+ * @return  \b LASN1_SUCCESS   if everything is ok or
+ *          \b LASN1_ERROR     if an error in the ASN.1 Protocol is detected
  *
- * @return   int  LASN1_SUCCESS   if everything is ok
- *                LASN1_ERROR     if an error in the ASN.1 Protocol is detected
- *
- * Remarks:
- * The caller is responsible for the input parameters. They are not tested for
- * validity.
+ * Remarks:\n
+ * The caller is responsible for the input parameters. They are not tested for validity.
  */
 int dsd_asn1::m_end_seq()
 {
@@ -10543,14 +10750,13 @@
  *
  * calculate the length of the tag bytes in the TLV
  *
- * @param [in]    int   imp_len    tag value
+ * @param[in]  imp_tag   tag value
  *
- * @return   int  number of bytes  if everything is ok
- *                LASN1_ERROR      if an error in the ASN.1 Protocol is detected
+ * @return      number of bytes  if everything is ok or
+ *           \b LASN1_ERROR      if an error in the ASN.1 Protocol is detected
  *
- * Remarks:
- * The caller is responsible for the input parameters. They are not tested for
- * validity.
+ * Remarks:\n
+ * The caller is responsible for the input parameters. They are not tested for validity.
  */
 int dsd_asn1::m_calc_taglen( int imp_tag )
 {
@@ -10573,13 +10779,12 @@
  *
  * calculate the length of the length bytes in the TLV
  *
- * @param [in]    int   imp_len    length value
+ * @param[in]  imp_len    length value
  *
- * @return   int  number of bytes in asn.1-length notation
+ * @return     number of bytes in asn.1-length notation
  *
- * Remarks:
- * The caller is responsible for the input parameters. They are not tested for
- * validity.
+ * Remarks:\n
+ * The caller is responsible for the input parameters. They are not tested for validity.
  */
 int dsd_asn1::m_calc_lenlen( int imp_len )
 {
@@ -10601,16 +10806,15 @@
  *
  * writes an ASN.1-tag in network byte order
  *
- * @param [in]    int   imp_tag     tag bytes
- * @param [in]    int   imp_taglen  number of tag bytes
- * @param [in]    char *achp_buf    destination buffer to write
+ * @param[in]  imp_tag     tag bytes
+ * @param[in]  imp_taglen  number of tag bytes
+ * @param[in]  achp_buf    destination buffer to write
  *
- * @return   int  LASN1_SUCCESS    if everything is ok
- *                LASN1_ERROR      if an error in the ASN.1 Protocol is detected
+ * @return  \b LASN1_SUCCESS    if everything is ok or
+ *          \b LASN1_ERROR      if an error in the ASN.1 Protocol is detected
  *
- * Remarks:
- * The caller is responsible for the input parameters. They are not tested for
- * validity.
+ * Remarks:\n
+ * The caller is responsible for the input parameters. They are not tested for validity.
  */
 int dsd_asn1::m_put_tag( int imp_tag, int imp_taglen, char *achp_buf )
 {
@@ -10633,16 +10837,15 @@
  *
  * writes an ASN.1-length in network byte order
  *
- * @param [in]    int   imp_len     length bytes
- * @param [in]    int   imp_lenlen  number of length bytes
- * @param [in]    char *achp_buf    destination buffer to write
+ * @param[in]  imp_len     length bytes
+ * @param[in]  imp_lenlen  number of length bytes
+ * @param[in]  achp_buf    destination buffer to write
  *
- * @return   int  LASN1_SUCCESS    if everything is ok
- *                LASN1_ERROR      if an error in the ASN.1 Protocol is detected
+ * @return  \b LASN1_SUCCESS    if everything is ok or
+ *          \b LASN1_ERROR      if an error in the ASN.1 Protocol is detected
  *
- * Remarks:
- * The caller is responsible for the input parameters. They are not tested for
- * validity.
+ * Remarks:\n
+ * The caller is responsible for the input parameters. They are not tested for validity.
  */
 int dsd_asn1::m_put_len( int imp_len, int imp_lenlen, char *achp_buf )
 {
@@ -10674,15 +10877,14 @@
  *
  * sets an integer in ASN.1-notation
  *
- * @param [in]    int   imp_int    value bytes
- * @param [in]    int   imp_tag    tag byte (LASN1_INTEGER or usertag)
+ * @param[in]  imp_int    value bytes
+ * @param[in]  imp_tag    tag byte (LASN1_INTEGER or usertag)
  *
- * @return   int  LASN1_SUCCESS    if everything is ok
- *                LASN1_ERROR      if an error in the ASN.1 Protocol is detected
+ * @return  \b LASN1_SUCCESS    if everything is ok or
+ *          \b LASN1_ERROR      if an error in the ASN.1 Protocol is detected
  *
- * Remarks:
- * The caller is responsible for the input parameters. They are not tested for
- * validity.
+ * Remarks:\n
+ * The caller is responsible for the input parameters. They are not tested for validity.
  */
 int dsd_asn1::m_put_int( int imp_int/*value*/, int imp_tag/*tag*/ )
 {
@@ -10746,15 +10948,14 @@
  *
  * sets an enumeration in ASN.1-notation
  *
- * @param [in]    int  imp_enum    value bytes
- * @param [in]    int  imp_tag     tag byte (LASN1_ENUMERATED or usertag)
+ * @param[in]  imp_enum    value bytes
+ * @param[in]  imp_tag     tag byte (LASN1_ENUMERATED or usertag)
  *
- * @return   int  LASN1_SUCCESS    if everything is ok
- *                LASN1_ERROR      if an error in the ASN.1 Protocol is detected
+ * @return  \b LASN1_SUCCESS    if everything is ok or
+ *          \b LASN1_ERROR      if an error in the ASN.1 Protocol is detected
  *
- * Remarks:
- * The caller is responsible for the input parameters. They are not tested for
- * validity.
+ * Remarks:\n
+ * The caller is responsible for the input parameters. They are not tested for validity.
  */
 int dsd_asn1::m_put_enum( int imp_enum/*value*/, int imp_tag/*tag*/ )
 {
@@ -10818,19 +11019,18 @@
  *
  * sets an octet string in ASN.1-notation, the string is translated in UTF-8.
  *
- * @param [in]    char            *astrp_str    string bytes
- * @param [in]    int              imp_len      string length
- * @param [in]    enum ied_charset iep_chs_src  charset of the string
- * @param [in]    int              imp_tag      tag byte (LASN1_OCTETSTRING or usertag)
+ * @param[in]  astrp_str    string bytes
+ * @param[in]  imp_len      string length
+ * @param[in]  iep_chs_src  charset of the string
+ * @param[in]  imp_tag      tag byte (LASN1_OCTETSTRING or usertag)
  *
- * @return   int  LASN1_SUCCESS    if everything is ok
- *                LASN1_ERROR      if an error in the ASN.1 Protocol is detected
+ * @return   \b LASN1_SUCCESS    if everything is ok or
+ *           \b LASN1_ERROR      if an error in the ASN.1 Protocol is detected
  *
- * Remarks:
+ * Remarks:\n
  * MSAD uses a quoted unicode-16 little endian string for the password modification,
- * we must copy this without any changes!
- * The caller is responsible for the input parameters. They are not tested for
- * validity.
+ * we must copy this without any changes!\n
+ * The caller is responsible for the input parameters. They are not tested for validity.
  */
 int dsd_asn1::m_put_string( char *astrp_str, int imp_len, enum ied_charset iep_chs_src, int imp_tag )
 {
@@ -10885,17 +11085,16 @@
  *
  * sets an octet string in ASN.1-notation, the string is translated in UTF-8.
  *
- * @param [in]    dsd_unicode_string  *adsp_unicode  unicode string description
- * @param [in]    int                  imp_tag       tag byte (LASN1_OCTETSTRING or usertag)
+ * @param[in]  adsp_unicode  unicode string description
+ * @param[in]  imp_tag       tag byte (LASN1_OCTETSTRING or usertag)
  *
- * @return   int  LASN1_SUCCESS    if everything is ok
- *                LASN1_ERROR      if an error in the ASN.1 Protocol is detected
+ * @return  \b LASN1_SUCCESS    if everything is ok or
+ *          \b LASN1_ERROR      if an error in the ASN.1 Protocol is detected
  *
- * Remarks:
+ * Remarks:\n
  * MSAD uses a quoted unicode-16 little endian string for the password modification,
- * we must copy this without any changes!
- * The caller is responsible for the input parameters. They are not tested for
- * validity.
+ * we must copy this without any changes!\n
+ * The caller is responsible for the input parameters. They are not tested for validity.
  */
 int dsd_asn1::m_put_string_uc( dsd_unicode_string *adsp_unicode, int imp_tag )
 {
@@ -10951,16 +11150,15 @@
  *
  * sets an octet string in ASN.1-notation w/o any translation.
  *
- * @param [in]    char       *astrp_str    string bytes
- * @param [in]    int         imp_len      string length
- * @param [in]    int         imp_tag      tag byte (LASN1_OCTETSTRING or usertag)
+ * @param[in]  astrp_str    string bytes
+ * @param[in]  imp_len      string length
+ * @param[in]  imp_tag      tag byte (LASN1_OCTETSTRING or usertag)
  *
- * @return   int  LASN1_SUCCESS    if everything is ok
- *                LASN1_ERROR      if an error in the ASN.1 Protocol is detected
+ * @return  \b LASN1_SUCCESS    if everything is ok or
+ *          \b LASN1_ERROR      if an error in the ASN.1 Protocol is detected
  *
- * Remarks:
- * The caller is responsible for the input parameters. They are not tested for
- * validity.
+ * Remarks:\n
+ * The caller is responsible for the input parameters. They are not tested for validity.
  */
 int dsd_asn1::m_put_octetstring( char *astrp_str, int imp_len, int imp_tag )
 {
@@ -11000,15 +11198,14 @@
  *
  * constructs an ASN.1-coded filter with OR, AND or NOT.
  *
- * @param [in]  char *achp_filter  filter string to search in
- * @param [in]  int   imp_tag      explicit tag (AND, OR, NOT) to be set
+ * @param[in]  achp_filter  filter string to search in
+ * @param[in]  imp_tag      explicit tag (AND, OR, NOT) to be set
  *
- * @return      char*   pointer to the next filter element, if everything is ok
- *              NULL    if an error in the filter string is detected
+ * @return     char*   pointer to the next filter element, if everything is ok or
+ *          \b NULL    if an error in the filter string is detected
  *
- * Remarks:
- * The caller is responsible for the input parameters. They are not tested for
- * validity.
+ * Remarks:\n
+ * The caller is responsible for the input parameters. They are not tested for validity.
  */
 char * dsd_asn1::m_put_complex_filter(  char *achp_filter, int imp_tag )
 {
@@ -11044,46 +11241,41 @@
  *
  * constructs an ASN.1-coded filter (OpenLDAP::ldap_pvt_put_filter()).
  *
- * a filter looks like this:
- *      Filter ::= CHOICE {
- *              and             [0]     SET OF Filter,
- *              or              [1]     SET OF Filter,
- *              not             [2]     Filter,
- *              equalityMatch   [3]     AttributeValueAssertion,
- *              substrings      [4]     SubstringFilter,
- *              greaterOrEqual  [5]     AttributeValueAssertion,
- *              lessOrEqual     [6]     AttributeValueAssertion,
- *              present         [7]     AttributeType,
- *              approxMatch     [8]     AttributeValueAssertion,
- *      extensibleMatch [9] MatchingRuleAssertion -- LDAPv3
- *      }
+ * A filter looks like this:
+ *      Filter ::= CHOICE { and             [0]     SET OF Filter,
+ *                          or              [1]     SET OF Filter,
+ *                          not             [2]     Filter,
+ *                          equalityMatch   [3]     AttributeValueAssertion,
+ *                          substrings      [4]     SubstringFilter,
+ *                          greaterOrEqual  [5]     AttributeValueAssertion,
+ *                          lessOrEqual     [6]     AttributeValueAssertion,
+ *                          present         [7]     AttributeType,
+ *                          approxMatch     [8]     AttributeValueAssertion,
+ *                          extensibleMatch [9]     MatchingRuleAssertion -- LDAPv3 }
  *
- *      SubstringFilter ::= SEQUENCE {
- *              type               AttributeType,
- *              SEQUENCE OF CHOICE {
- *                      initial          [0] IA5String,
- *                      any              [1] IA5String,
- *                      final            [2] IA5String
- *              }
- *      }
+ *      SubstringFilter ::= SEQUENCE { type               AttributeType,
+ *                                     SEQUENCE OF CHOICE { initial          [0] IA5String,
+ *                                                          any              [1] IA5String,
+ *                                                          final            [2] IA5String }
+ *                                   }
  *
- *  MatchingRuleAssertion ::= SEQUENCE {    -- LDAPv3
- *      matchingRule    [1] MatchingRuleId OPTIONAL,
- *      type            [2] AttributeDescription OPTIONAL,
- *      matchValue      [3] AssertionValue,
- *      dnAttributes    [4] BOOLEAN Default: FALSE }
+ *      MatchingRuleAssertion ::= SEQUENCE { -- LDAPv3
+ *                                           matchingRule    [1] MatchingRuleId OPTIONAL,
+ *                                           type            [2] AttributeDescription OPTIONAL,
+ *                                           matchValue      [3] AssertionValue,
+ *                                           dnAttributes    [4] BOOLEAN Default: FALSE }
  *
  * Note: tags in a choice are always explicit
  *
  *
- * @param [in]  const char      *achp_filter      filter string to search in
- * @param [in]  int              imp_len_filter   length of the filter string
- * @param [in]  enum ied_charset iep_chs_filter   character set of the filter
+ * @param[in]  achp_filter      filter string to search in
+ * @param[in]  imp_len_filter   length of the filter string
+ * @param[in]  iep_chs_filter   character set of the filter
  *
- * @return      LASN1_SUCCESS    if everything is ok
- *              LASN1_ERROR      if an error in the ASN.1 Protocol is detected
+ * @return     \b LASN1_SUCCESS    if everything is ok or
+ *             \b LASN1_ERROR      if an error in the ASN.1 Protocol is detected
  *
- * Remarks:
+ * Remarks:\n
  * The filter string has to be UTF-8 formatted!
  */
 int dsd_asn1::m_put_filter( const char *achp_filter, int imp_len_filter, enum ied_charset iep_chs_filter )
@@ -11229,15 +11421,14 @@
  *
  * puts a list of filters like this "(filter1)(filter2)...".
  *
- * @param [in]  char *achp_filter  filter string to search in
- * @param [in]  int   imp_tag      explicit tag to be set
+ * @param[in]  achp_filter  filter string to search in
+ * @param[in]  imp_tag      explicit tag to be set
  *
- * @return      LASN1_SUCCESS    if everything is ok
- *              LASN1_ERROR      if an error in the ASN.1 Protocol is detected
+ * @return     \b LASN1_SUCCESS    if everything is ok or
+ *             \b LASN1_ERROR      if an error in the ASN.1 Protocol is detected
  *
- * Remarks:
- * The caller is responsible for the input parameters. They are not tested for
- * validity.
+ * Remarks:\n
+ * The caller is responsible for the input parameters. They are not tested for validity.
  */
 int dsd_asn1::m_put_filter_list( char *achp_filter, int imp_tag )
 {
@@ -11284,34 +11475,33 @@
  *
  * search filter format:   attribute operator value (e.g. cn=smith)
  *
- * operator  description                            example
- * -------------------------------------------------------------------------------
- *    =      returns entries whose attribute is     cn=John Smith finds the entry
- *           equal to the value                     with common name John Smith
+ *     operator  description                            example
+ *     -------------------------------------------------------------------------------
+ *        =      returns entries whose attribute is     cn=John Smith finds the entry
+ *               equal to the value                     with common name John Smith
  *
- *   >=      returns entries whose attribute is     sn>=smith finds all entries
- *           greater than or equal to the value     from smith to z*
+ *       >=      returns entries whose attribute is     sn>=smith finds all entries
+ *               greater than or equal to the value     from smith to z*
  *
- *   <=      returns entries whose attribute is     sn<=smith finds all entries
- *           less than or equal to the value        from a* to smith
+ *       <=      returns entries whose attribute is     sn<=smith finds all entries
+ *               less than or equal to the value        from a* to smith
  *
- *   =*      returns entries that have a value      sn=* finds all entries that
- *           set for that attribute                 have the sn attribute
+ *       =*      returns entries that have a value      sn=* finds all entries that
+ *               set for that attribute                 have the sn attribute
  *
- *   ~=      returns entries whose attribute value  sn~=smit might find the entry
- *           approximately matches the specified    "sn=smith"
- *           value. Typically, this is an algorithm
- *           that matches words that sound alike
+ *       ~=      returns entries whose attribute value  sn~=smit might find the entry
+ *               approximately matches the specified    "sn=smith"
+ *               value. Typically, this is an algorithm
+ *               that matches words that sound alike
  *
  *
- * @param [in]  char *achp_filter  filter string to search in (utf-8 format)
+ * @param[in]  achp_filter  filter string to search in (utf-8 format)
  *
- * @return      LASN1_SUCCESS    if everything is ok
- *              LASN1_ERROR      if an error in the ASN.1 Protocol is detected
+ * @return     \b LASN1_SUCCESS    if everything is ok or
+ *             \b LASN1_ERROR      if an error in the ASN.1 Protocol is detected
  *
- * Remarks:
- * The caller is responsible for the input parameters. They are not tested for
- * validity.
+ * Remarks:\n
+ * The caller is responsible for the input parameters. They are not tested for validity.
  */
 int dsd_asn1::m_put_simple_filter( char *achp_filter )
 {
@@ -11412,15 +11602,14 @@
  *
  * puts a substring-filter like this "(cn=smith)...".
  *
- * @param [in]  char *achp_type  filter attribute string
- * @param [in]  char *achp_val   filter value string
+ * @param[in]  achp_type  filter attribute string
+ * @param[in]  achp_val   filter value string
  *
- * @return      LASN1_SUCCESS    if everything is ok
- *              LASN1_ERROR      if an error in the ASN.1 Protocol is detected
+ * @return     \b LASN1_SUCCESS    if everything is ok or
+ *             \b LASN1_ERROR      if an error in the ASN.1 Protocol is detected
  *
- * Remarks:
- * The caller is responsible for the input parameters. They are not tested for
- * validity.
+ * Remarks:\n
+ * The caller is responsible for the input parameters. They are not tested for validity.
  */
 int dsd_asn1::m_put_substring_filter( char *achp_type, char *achp_val )
 {
@@ -11490,14 +11679,13 @@
  *
  * finds the ending ')' of the given filter string.
  *
- * @param [in]  char *achp_filter  filter string to search in
+ * @param[in]  achp_filter  filter string to search in
  *
- * @return      char*    pointer to position found
- *              NULL     error, if not found before the string ends
+ * @return     char*    pointer to position found or
+ *          \b NULL     error, if not found before the string ends
  *
- * Remarks:
- * The caller is responsible for the input parameters. They are not tested for
- * validity.
+ * Remarks:\n
+ * The caller is responsible for the input parameters. They are not tested for validity.
  */
 char *dsd_asn1::m_find_filter_right_parent( char *achp_filter )
 {
@@ -11532,14 +11720,13 @@
  *
  * returns the value of a hex-character (e.g. 'A' -> 0x0A).
  *
- * @param [in]  int  imp_ch   hex character (ascii)
+ * @param[in]  imp_ch   hex character (ascii)
  *
- * @return      int           hex value
- *              LASN1_ERROR   error, if not a valid hex character
+ * @return     int           hex value or
+ *          \b LASN1_ERROR   error, if not a valid hex character
  *
- * Remarks:
- * The caller is responsible for the input parameters. They are not tested for
- * validity.
+ * Remarks:\n
+ * The caller is responsible for the input parameters. They are not tested for validity.
  */
 int dsd_asn1::m_hex2value( int imp_ch )
 {
@@ -11556,14 +11743,13 @@
  *
  * search for a wildcard ('*') in der value part of the filter string.
  *
- * @param [in]  char *achp_filter  filter string to search in
+ * @param[in]  achp_filter  filter string to search in
  *
- * @return      const char*   pointer to the value part of the filter
- *              NULL          error, if not found before the string ends
+ * @return     const char*   pointer to the value part of the filter or
+ *          \b NULL          error, if not found before the string ends
  *
- * Remarks:
- * The caller is responsible for the input parameters. They are not tested for
- * validity.
+ * Remarks:\n
+ * The caller is responsible for the input parameters. They are not tested for validity.
  */
 char * dsd_asn1::m_find_filter_wildcard( const char *achp_filter )
 {
@@ -11608,15 +11794,14 @@
  * unescapes the value string if necessary. It supports both LDAPv2 and
  * LDAPv3 escapes.
  *
- * @param [in]  char *achp_val  filter value string
+ * @param[in]  achp_val  filter value string
  *
- * @return      int             length of the filter value or
- *              LASN1_ERROR     if an error is detected
+ * @return     int             length of the filter value or
+ *          \b LASN1_ERROR     if an error is detected
  *
- * Remarks:
- * The output can include null characters!!!
- * The caller is responsible for the input parameters. They are not tested for
- * validity.
+ * Remarks:\n
+ * The output can include null characters!\n
+ * The caller is responsible for the input parameters. They are not tested for validity.
  */
 int dsd_asn1::m_put_filter_value_unescape( char *achp_val )
 {
@@ -11679,13 +11864,10 @@
  *
  * gets a new initiated element to build an ASN.1-TLV.
  *
- * @param[in]       none
+ * @return     struct dsd_elem_1 *   pointer to a fresh element
  *
- * @return   struct dsd_elem_1 *   pointer to a fresh element
- *
- * Remarks:
- * The caller is responsible for the input parameters. They are not tested for
- * validity.
+ * Remarks:\n
+ * The caller is responsible for the input parameters. They are not tested for validity.
  */
 dsd_asn1::dsd_elem_1 *dsd_asn1::m_get_element()
 {
@@ -11722,6 +11904,9 @@
 /*+---------------------------------------------------------------------------------------------+*/
 /*| helper functions ...                                                                        |*/
 /*+---------------------------------------------------------------------------------------------+*/
+int m_hl_inet_ntop4( const unsigned char *, char *, int );
+int m_hl_inet_ntop6( const unsigned char *, char *, int );
+
 /**
  *  m_hl_inet_ntop() - Convert an ipv4/ipv6-address to presentation format.
  *
@@ -11729,24 +11914,20 @@
  *  internet standard format.
  *  AF_INET:    ddd.ddd.ddd.ddd
  *  AF_INET6:   xxxxxxxxxxxxx
+ *                                                                                            
+ *  @param[in]     adsp_soa        network address structure:
+ *                                 struct in_addr  (AF_INET)
+ *                                 struct in6_addr (AF_INET6)
+ *  @param[in,out] achrp_ipaddr    ip-address buffer
+ *  @param[in]     inp_len_ipaddr  maximum length of ip-address buffer
  *
- *  @param[in]     struct sockaddr_storage *adsp_soa      network address structure:
- *                                                        struct in_addr  (AF_INET)
- *                                                        struct in6_addr (AF_INET6)
- *  @param[in,out] char                    *achrp_addr    ip-address buffer
- *  @param[in]     int                      inp_len_addr  maximum length of ip-address buffer
+ *  @return   \b 0                 if successful, else an error is happened,
+ *            \b EOPNOTSUPP        invalid address format,
+ *            \b EAFNOSUPPORT      invalid address family or
+ *            \b ENOBUFS           converted address or port would exceed 'inl_len_...'
  *
- *  @return     0                 if successful, else an error is happened
- *              EOPNOTSUPP        invalid address format
- *              EAFNOSUPPORT      invalid address family
- *              ENOBUFS           converted address or port would exceed 'inl_len_...'
- *
  *  comment:  This is based on the official BSD source of 'inet_ntop()'.
  */
-int m_hl_inet_ntop4( const unsigned char *, char *, int );
-int m_hl_inet_ntop6( const unsigned char *, char *, int );
-
-
 int m_hl_inet_ntop( struct sockaddr_storage *adsp_soa, char *achrp_ipaddr, int inp_len_ipaddr )
 {
    // valid parameter?
@@ -11787,15 +11968,14 @@
  *  internet standard format.
  *  AF_INET:    ddd.ddd.ddd.ddd
  *
- *  @param[in]     struct sockaddr_storage *adsp_soa      network address structure:
- *                                                        struct in_addr  (AF_INET)
- *  @param[in,out] char                    *achrp_addr    ip-address buffer
- *  @param[in]     int                      inp_len_addr  maximum length of ip-address buffer
+ *  @param[in]  achrp_src    ipv4 network address
+ *  @param[out] achrp_dst    ASCII output buffer
+ *  @param[out] inp_len_dst  maximum ASCII output buffer length
  *
- *  @return     0                 if successful, else an error is happened
- *              EOPNOTSUPP        invalid address format
- *              EAFNOSUPPORT      invalid address family
- *              ENOBUFS           converted address or port would exceed 'inl_len_...'
+ *  @return   \b 0             if successful, else an error is happened,
+ *            \b EOPNOTSUPP    invalid address format,
+ *            \b EAFNOSUPPORT  invalid address family or
+ *            \b ENOBUFS       converted address or port would exceed 'inl_len_...'
  *
  *  comment:  This is based on the official BSD source of 'inet_ntop()'.
  */
@@ -11821,15 +12001,14 @@
  *  internet standard format.
  *  AF_INET6:   xxxxxxxxxxxxx
  *
- *  @param[in]     struct sockaddr_storage *adsp_soa      network address structure:
- *                                                        struct in6_addr (AF_INET6)
- *  @param[in,out] char                    *achrp_addr    ip-address buffer
- *  @param[in]     int                      inp_len_addr  maximum length of ip-address buffer
+ *  @param[in]  achrp_src    ipv6 network address
+ *  @param[out] achrp_dst    ASCII output buffer
+ *  @param[out] inp_len_dst  maximum ASCII output buffer length
  *
- *  @return     0                 if successful, else an error is happened
- *              EOPNOTSUPP        invalid address format
- *              EAFNOSUPPORT      invalid address family
- *              ENOBUFS           converted address or port would exceed 'inl_len_...'
+ *  @return   \b 0             if successful, else an error is happened,
+ *            \b EOPNOTSUPP    invalid address format,
+ *            \b EAFNOSUPPORT  invalid address family or
+ *            \b ENOBUFS       converted address or port would exceed 'inl_len_...'
  *
  *  comment:  This is based on the official BSD source of 'inet_ntop()'.
  */
@@ -11934,13 +12113,13 @@
  *
  *  The function compares entries using different criterias.
  *
- *  @param[in]    void *                      avop_userfld       htree user field structure
- *  @param[in]    struct dsd_htree_avl_entry  adsp_htree_elem_1  first element to compare
- *  @param[in]    struct dsd_htree_avl_entry  adsp_htree_elem_2  second element to compare
+ *  @param[in]  avop_userfld       htree user field structure
+ *  @param[in]  adsp_htree_elem_1  first element to compare
+ *  @param[in]  adsp_htree_elem_2  second element to compare
  *                                                            
- *  @return     -1   the second element is longer
- *               1   the first element is longer
- *               0   the elements are equal
+ *  @return   \b -1   the second element is longer,
+ *            \b  1   the first element is longer or
+ *            \b  0   the elements are equal
  */
 int dsd_ldap_schema::m_htree1_avl_compare( void *avop_userfld,
                                            struct dsd_htree1_avl_entry *adsp_htree_elem_1,
@@ -11951,9 +12130,9 @@

    // compare the attribute names only if both lengths are equal
    if (adsl_schema_attr_1->imc_len_val == adsl_schema_attr_2->imc_len_val)
-   { return _memicmp( adsl_schema_attr_1->ac_val,
-                      adsl_schema_attr_2->ac_val,
-                      adsl_schema_attr_1->imc_len_val );
+   { return m_hl_memicmp( adsl_schema_attr_1->ac_val,
+                          adsl_schema_attr_2->ac_val,
+                          adsl_schema_attr_1->imc_len_val );
    }                     
   
    if (adsl_schema_attr_1->imc_len_val > adsl_schema_attr_2->imc_len_val)
@@ -11964,7 +12143,31 @@
 } // dsd_ldap_schema::m_htree1_avl_compare()                                          


+/**
+ *  m_hl_memicmp() - Replacement for _memicmp() in a Linux-environment.
+ *
+ *  The function compares entries ignoring their case.
+ *
+ *  @param[in]  avop_buf1   first buffer
+ *  @param[in]  avop_buf2   second buffer
+*   @param[in]  imp_count   number of characters to compare
+ *                                                            
+ *  @return   \b  -1  avop_buf1 less than avop_buf2
+ *            \b   0  both buffers are equal
+ *            \b   1  avop_buf1 greater than avop_buf2
+ */
+int m_hl_memicmp( void *avop_buf1, void *avop_buf2, int imp_count )
+{
+   int  imp_result (-1);

+   m_cmpi_vx_vx( &imp_result,
+                 avop_buf1, imp_count, ied_chs_utf_8,
+                 avop_buf2, imp_count, ied_chs_utf_8 );
+   return imp_result;
+  
+} // m_hl_memicmp()                                          
+
+
 // we need some functions in environments outside the WebSecureProxy
 // first we start with WIN32 and WIN64, later we add support for
 // HL_LINUX and HL_UNIX
Index: hob-session01.h
===================================================================
--- hob-session01.h	(revision 0)
+++ hob-session01.h	(revision 6)
@@ -0,0 +1,259 @@
+#ifndef HOBSESSION_H_INC
+#define HOBSESSION_H_INC
+
+#ifndef PTYPE
+#ifdef __cplusplus
+#define PTYPE "C"
+#else
+#define PTYPE
+#endif
+#endif
+
+#if defined WIN32 || defined WIN64
+#define THDRET unsigned int
+#define DEFCRITSEC(x) CRITICAL_SECTION x
+#define INITCRITSEC(x) InitializeCriticalSection(&x)
+#define ENTERCRITSEC(x) EnterCriticalSection(&x)
+#define LEAVECRITSEC(x) LeaveCriticalSection(&x)
+#elif defined HL_UNIX
+#define THDRET void*
+#define DEFCRITSEC(x) pthread_mutex_t x
+#define INITCRITSEC(x)                                                     \
+{                                                                          \
+   pthread_mutexattr_t dsl_mattr;                                          \
+   pthread_mutexattr_settype(&dsl_mattr, PTHREAD_MUTEX_RECURSIVE_NP);      \
+   pthread_mutex_init(&x, &dsl_mattr);                                     \
+   pthread_mutexattr_destroy(&dsl_mattr);                                  \
+}
+#define ENTERCRITSEC(x) pthread_mutex_lock(&x)
+#define LEAVECRITSEC(x) pthread_mutex_unlock(&x)
+#define WINAPI
+#define LPVOID void*
+#endif
+
+// Custom avl tree node struct.
+struct dsd_avl_sess_entry
+{
+   // NODE HEADER.
+   dsd_htree1_avl_entry dsc_avl_hdr;
+   // NODE PAYLOAD.
+   // Node KEY: Tunnel ID.
+   uint32_t umc_key_ineta;
+   // PPP session.
+   void* adsc_ppp_sess;
+};
+
+extern std::list<dsd_tun_contr_ineta*> dsg_tun_contr_ineta_list;
+
+extern "C" void m_htun_critsect_enter( struct dsd_tun_contr_conn *adsp_tun_contr_conn );
+extern "C" void m_htun_critsect_leave( struct dsd_tun_contr_conn *adsp_tun_contr_conn );
+
+// Session class stub.
+class dsd_session;
+
+struct dsd_queued_msg
+{
+    BOOL bo_nodrop;
+    dsd_buf_vector_ele ds_buf_vec_ele;
+};
+
+struct dsd_htun_handle {
+    enum ied_tunc_def iec_tunc;
+    void* vpc_contr;
+};
+
+// Abstract class to superclass all session classes (HOB-PPP-T1, SSTR & HTCP).
+class dsd_session
+{
+
+public:
+
+   // Control handle for application.
+   dsd_tun_contr_conn* adsc_tun_contr_conn;
+   // Client VINETA.
+   dsd_tun_contr_ineta* adsc_tun_contr_ineta;
+   // Location where WSP can find this.
+   dsd_htun_handle dsc_htun_handle;
+   // Indicates whether session has been closed.
+   BOOL boc_sess_closed;
+   // Signaled when data can be sent to client.
+   BOOL boc_cansend;
+   // Index of internal network interface associated with this session.
+   //uint32_t umc_if_idx;
+   // Buffer for error and warning messages.
+   char chrc_last_error[256];
+
+public:
+
+   //
+   // Default Constructor.
+   // Not implemented.
+   //
+   dsd_session();
+
+   //
+   // Constructor.
+   // Initializes part of the session object.
+   //
+   dsd_session(dsd_tun_contr_conn* adsp_tun_contr_conn,
+               dsd_tun_contr_ineta* adsp_tun_contr_ineta) :
+   adsc_tun_contr_conn(adsp_tun_contr_conn),
+   adsc_tun_contr_ineta(adsp_tun_contr_ineta),
+   boc_sess_closed(false),
+   boc_cansend(true)
+   {
+      dsc_htun_handle.iec_tunc = adsp_tun_contr_conn->iec_tunc;
+      memset(chrc_last_error, 0, sizeof(chrc_last_error));
+      dsg_tun_contr_ineta_list.push_back(adsp_tun_contr_ineta);
+   };
+
+   //
+   // Copy constructor.
+   // Not implemented.
+   //
+   dsd_session(const dsd_session& dsp_orig);
+
+   //
+   // Copy assignment operator.
+   // Not implemented.
+   //
+   const dsd_session& operator=(const dsd_session& dsp_rhs);
+
+   //
+   // Destructor.
+   //
+   virtual ~dsd_session()
+   {
+      std::list<dsd_tun_contr_ineta*>::iterator dsl_iter;
+      for(dsl_iter = dsg_tun_contr_ineta_list.begin();
+		  dsl_iter != dsg_tun_contr_ineta_list.end(); dsl_iter++)
+	  {
+		  if(*dsl_iter == adsc_tun_contr_ineta)
+			  break;
+	  }
+      if(dsl_iter != dsg_tun_contr_ineta_list.end())
+         dsg_tun_contr_ineta_list.erase(dsl_iter);
+   };
+
+   //
+   // Initializes the session object.
+   // Must be called before any other methods are called on the object. Performs
+   // any initialisation of the object which might possibly fail.
+   //
+   // @return  Returns a value which is < 0 on faliure.
+   //
+   virtual int32_t mc_init() = 0;
+
+   //
+   // Called from m_htun_sess_close().
+   // Defaults to calling the destructor, but can be changed.
+   // Note that since destructor is virtual, correct destructor is called.
+   //
+   virtual void mc_close()
+   {
+       this->~dsd_session();
+   }
+
+   //
+   // Processes the message header.
+   // Reads the contents of the message header and updates the session
+   // accordingly. Depending on the header contents, this can trigger a
+   // response to the session client, the transfer of data over the internal
+   // network, or the updating of the session object.
+   //
+   // @param  adsp_gather  Gather struct containing message to be interpreted.
+   // @param  adsp_hco_wothr  Pointer to the calling workthread.
+   //
+   // @return  Returns a value which is < 0 on faliure.
+   //
+   virtual int32_t mc_interpret_msg(dsd_gather_i_1* adsp_gather,
+                                    dsd_hco_wothr*  adsp_hco_wothr) = 0;
+
+   //
+   // Adds a message header to the data.
+   // Encapsulates the data in a message header, and sends the message over to
+   // the session client.
+   //
+   // @param  ap_handle   Handle to the buffer containing the data to
+   //                     encapsulate.
+   // @param  aucp_data   Pointer to the buffer containing the data to
+   //                     encapsulate.
+   // @param  ump_length  Length, in bytes, of the data to encapsulate.
+   //
+   // @return  Returns a value which is < 0 on faliure.
+   //
+   virtual int32_t mc_encapsulate_msg(void*  ap_handle,
+                                      byte*  abyp_data,
+                                      uint32_t ump_length) = 0;
+
+   //
+   // Called when more data can be sent.
+   // This virtual method is optional.
+   // If overrriden, remember to set boc_cansend to true.
+   //
+   virtual void mc_can_send()
+   {
+       boc_cansend = true;
+   }
+
+   //
+   // Returns a description of the last error or warning of the session.
+   //
+   // @return  Pointer to the NULL terminated error or warning message.
+   //
+   inline char* mc_sess_last_err() { return chrc_last_error; };
+
+};
+
+//
+// Creates and initializes a session object.
+// Creates a session object based on the session information passed as
+// parameter. The session object created might be an instance of one of any
+// of the session classes which subclass the dsd_session class.
+//
+// @param  m_se_htun_recvbuf  New session configuration.
+//
+//
+
+extern PTYPE void m_init_sess(//dsd_tun_start_htcp* adsp_tun_start_htcp,
+                                      dsd_tun_start_ppp* adsp_tun_start_ppp,
+                                      dsd_tun_contr_conn* adsp_tun_contr_conn,
+                                      dsd_tun_contr_ineta* adsp_tun_contr_ineta);
+//
+// Sends data over the opened TUN adapter towards the internal network.
+// This function is called when it is necessary to send some data over the
+// internal network through the currently opened TUN virtual adapter. It
+// makes use of the HTUN_WIN32API module in order to execute a blocking write
+// to the TUN adapter.
+//
+// @param  achp_data   Pointer to the start of the buffer containing the data
+//                     to be sent.
+// @param  imp_length  Number of bytes to be sent.
+//
+// @return  True if successful, False if otherwise.
+//
+extern PTYPE BOOL m_se_husip_send(byte* abyp_data,
+                                  int32_t imp_length);
+
+//
+// Sends data over the opened TUN adapter towards the internal network.
+// This function is called when it is necessary to send some data over the
+// internal network through the currently opened TUN virtual adapter. It
+// makes use of the HTUN_WIN32API module in order to execute a blocking write
+// to the TUN adapter.
+//
+// @param  adsp_data   Pointer to the initial struct dsd_gather_i_1 block
+//                     for the data to be sent.
+// @param  unp_length  Number of bytes to be sent.
+//
+// @return  TRUE if successful, FALSE if otherwise.
+//
+extern PTYPE BOOL m_se_husip_send_gather(dsd_gather_i_1* adsp_data,
+                                         unsigned unp_length);
+// WSP configuration struct declaration.
+extern dsd_wsptun_conf_1 dss_wsptun_config;
+
+// Critical section object for WSP configuration (defined in ishusip01.cpp).
+extern DEFCRITSEC(dsg_critsec_wspconf);
+
+#endif
Index: nbipgw19.cpp
===================================================================
--- nbipgw19.cpp	(revision 2)
+++ nbipgw19.cpp	(revision 6)
@@ -14,6 +14,7 @@
 /*| ----------                                                        |*/
 /*|  Copyright (C) HOB Germany 2011                                   |*/
 /*|  Copyright (C) HOB Germany 2012                                   |*/
+/*|  Copyright (C) HOB Germany 2013                                   |*/
 /*|                                                                   |*/
 /*| EXPECTED INPUT:                                                   |*/
 /*| ---------------                                                   |*/
@@ -73,6 +74,16 @@
 #include <netinet/in.h>
 #include <sys/time.h>
 #include <syslog.h>
+#ifdef D_INCL_HOB_TUN
+#include <sys/ioctl.h>
+//#include <sys/net/if.h>
+#include <net/if.h>
+#include <net/if_arp.h>
+#include <net/route.h>
+#ifdef HL_LINUX
+#include <linux/if_tun.h>                   /* check for other unixes   */
+#endif
+#endif
 #include <hob-unix01.h>
 #include <hob-xslunic1.h>
 #include <hob-tab-ascii-ansi-1.h>
@@ -136,6 +147,9 @@
 static void m_tccb_cluster_errorcallback( class dsd_tcpcomp *, void *, char *, int, int );
 static void m_tccb_cluster_cleanup( class dsd_tcpcomp *, void * );
 static void m_wsp_send_msg( struct dsd_wsp_conn *, char *, ... );
+#ifdef D_INCL_HOB_TUN
+static BOOL m_htun_search_interface_ipv4( UNSIG_MED ump_ineta, char *achp_if_name, struct sockaddr *adsp_rhwaddr );
+#endif
 static void * m_proc_alloc( void );
 static void m_proc_free( void * );
 static void m_console_out( char *achp_buff, int implength );
@@ -245,6 +259,10 @@
 static struct dsd_listen *adss_listen_chain = NULL;  /* chain for UDS and TCP listen */
 static struct dsd_wsp_conn *adss_wsp_conn_chain = NULL;  /* connections to WSPs */

+#ifdef D_INCL_HOB_TUN
+static int    ims_tun_socket;               /* socket for HOB-TUN      */
+#endif
+
 static struct dsd_acccallback dss_acc_cb = {  /* callback routines     */
    &m_cb_nbacc_acceptcallback,
    &m_cb_nbacc_errorcallback
@@ -306,6 +324,18 @@
    (unsigned char) ied_ligwr_resp_socket_ok  /* create socket succeeded */
 };

+#ifdef D_INCL_HOB_TUN
+static const unsigned char ucrs_resp_ar_add_ipv4[] = {
+   (unsigned char) 1,                       /* length of message       */
+   (unsigned char) ied_ligwr_resp_arproute_add_ipv4  /* add ARP and route IPV4  */
+};
+
+static const unsigned char ucrs_resp_ar_del_ipv4[] = {
+   (unsigned char) 1,                       /* length of message       */
+   (unsigned char) ied_ligwr_resp_arproute_del_ipv4  /* del ARP and route IPV4  */
+};
+#endif
+
 static const unsigned char ucrs_cluster_eye_catcher[] = {
    'H', 'O', 'B', ' ', 'W', 'S', 'P', ' ',
    'C', 'L', 'U', 'S', 'T', 'E', 'R', 0
@@ -504,6 +534,14 @@
      D_TCP_CLOSE( iml_unix_socket );
      return -1;                             /* abend                   */
    }
+#ifdef D_INCL_HOB_TUN
+   ims_tun_socket                           /* socket for HOB-TUN      */
+     = socket( AF_INET, SOCK_STREAM, 0 );
+   if (ims_tun_socket < 0) {                /* error occured           */
+     m_hl1_printf( "nbipgw19-l%05d-W TUN socket() Return Code %d Error %d.",
+                   __LINE__, ims_tun_socket, errno );
+   }
+#endif

    ppoll00:                                 /* do poll                 */
    iml1 = INFTIM;                           /* set wait infinite       */
@@ -539,6 +577,10 @@
    iml_poll_cur = 0;                        /* clear current poll array */
    do {
      if (dsrs_poll[ iml_poll_cur ].revents) {  /* event to process     */
+#ifdef TRACEHL1
+       m_hl1_printf( "nbipgw19-l%05d-T after poll() %d event %08X dsrs_sithr_poll_1[ iml_poll_cur ]=%p.",
+                     __LINE__, iml_poll_cur, dsrs_poll[ iml_poll_cur ].revents, dsrs_sithr_poll_1[ iml_poll_cur ] );
+#endif
        dsrs_sithr_poll_1[ iml_poll_cur ]->amc_p_compl_poll( dsrs_sithr_poll_1[ iml_poll_cur ] );
        dsrs_poll[ iml_poll_cur ].revents = 0;  /* event has been processed */
      }
@@ -547,6 +589,7 @@
    goto ppoll00;                            /* do poll                 */
 } /* end main()                                                        */

+/** close cluster connection                                           */
 static void m_cluster_listen_close( struct dsd_listen *adsp_listen ) {
    int        iml_rc;                       /* return code             */
    struct dsd_listen *adsl_listen_w1;       /* for TCP listen          */
@@ -617,7 +660,7 @@
    return TRUE;                             /* all done                */
 } /* end m_poll_arr_del()                                              */

-// accept callback routine
+/** accept callback routine                                            */
 static void m_cb_nbacc_acceptcallback( class dsd_nblock_acc * adsp_na, void * vpp_userfld, int imp_socket, struct sockaddr *adsp_soa, int imp_len_soa ) {
    int        iml_rc;                       /* return code             */
    char       *achl1;                       /* working-variable        */
@@ -646,7 +689,7 @@
                  __LINE__, chrl_client_ineta );
    adsl_cluster_conn = (struct dsd_cluster_conn *) malloc( sizeof(struct dsd_cluster_conn) );  /* connection to a cluster member */
    memset( adsl_cluster_conn, 0, sizeof(struct dsd_cluster_conn) );  /* clear connection to a cluster member */
-   strcpy( adsl_cluster_conn->chrc_ineta, chrl_client_ineta );  /* internet-address char  */
+   strcpy( adsl_cluster_conn->chrc_ineta, chrl_client_ineta );  /* internet-address char */
    iml_rc = adsl_cluster_conn->dsc_connect.dsc_tcpco1.m_startco_fb(
                 imp_socket,
                 &dss_tcpcomp_cluster_cb1,
@@ -675,6 +718,10 @@
                 imp_socket,
                 &dss_tcpcomp_wsp_cb1,
                 adsl_wsp_conn_w1 );
+#ifdef TRACEHL1
+   m_hl1_printf( "nbipgw19-l%05d-T m_cb_nbacc_acceptcallback() m_startco_unix_socket_fix( ... , %p ) at %p returned %d.",
+                 __LINE__, adsl_wsp_conn_w1, &adsl_wsp_conn_w1->dsc_connect.dsc_tcpco1, iml_rc );
+#endif
    if (iml_rc) {                            /* error occured           */
      m_hl1_printf( "nbipgw19-%05d-W Unix socket m_startco_unix_socket_fix() failed %d.",
                    __LINE__, iml_rc );
@@ -694,7 +741,7 @@
    adss_wsp_conn_chain = adsl_wsp_conn_w1;  /* new chain connections to WSPs */
 } /* end m_cb_nbacc_acceptcallback()                                   */

-// error callback routine
+/** error callback routine                                             */
 static void m_cb_nbacc_errorcallback( class dsd_nblock_acc *, void *, char *, int, int ) // Error callback function.
 {
 // do-to 27.01.08 KB
@@ -703,7 +750,7 @@
    return;
 } /* end m_cb_nbacc_errorcallback()                                    */

-/* get receive buffer callback function                                */
+/** get receive buffer callback function                               */
 static int m_tccb_all_getrecvcallback( class dsd_tcpcomp *adsp_tcpcomp,
                                        void * vpp_userfld,
                                        void **avpp_handle,
@@ -724,7 +771,7 @@
    void (*am_conncallback)( class dsd_tcpcomp *, void *, struct sockaddr *adsp_soa, socklen_t imp_len_soa );  /* connect callback function */
 #endif

-/* WSP send callback function                                          */
+/** TCPCOMP WSP send callback function                                 */
 static void m_tccb_wsp_sendcallback( class dsd_tcpcomp *adsp_tcpcomp, void * vpp_userfld ) {
    struct dsd_connect *adsl_conn_1;         /* connection              */

@@ -741,12 +788,21 @@
 #endif
 } /* end m_tccb_wsp_sendcallback()                                     */

-/* WSP receive callback function                                       */
+/** TCPCOMP WSP receive callback function                              */
 static BOOL m_tccb_wsp_recvcallback( class dsd_tcpcomp *adsp_tcpcomp, void * vpp_userfld, void * vpp_handle ) {
+#ifdef D_INCL_HOB_TUN
+   BOOL       bol_rc;                       /* return code             */
+#endif
    BOOL       bol1;                         /* working variable        */
    int        iml1, iml2, iml3;             /* working variables       */
    int        iml_rc;                       /* return code             */
    int        iml_socket;                   /* socket to be created    */
+#ifdef D_INCL_HOB_TUN
+   int        iml_error;                    /* error retrieved         */
+   int        iml_index_ineta_ipv4;         /* index INETA IPV4        */
+   int        iml_index_ineta_ipv6;         /* index INETA IPV6        */
+   UNSIG_MED  uml_ineta_w1;                 /* working variable INETA IPV4 */
+#endif
    enum ied_decode_wsp_recv_1 iel_dwr1;     /* decode received from WSP */
    char       *achl1, *achl2, *achl3, *achl4, *achl5;  /* working variables */
    struct dsd_wsp_conn *adsl_wsp_conn_w1;   /* connection to a WSP     */
@@ -762,6 +818,15 @@
    char       chrl_next_xor[ D_LIGW_RANDOM_L ];  /* for next SHA-1     */
    char       chrl_sha1_out[ D_LIGW_RANDOM_L ];  /* output of SHA-1    */
    struct sockaddr_storage dsl_soa;         /* for bind()              */
+#ifdef D_INCL_HOB_TUN
+   union {
+     struct ifreq dsl_ifreq;                /* interface request       */
+     struct arpreq dsl_arpreq;              /* struct for arp requests */
+     struct rtentry dsl_routereq;           /* struct for route request */
+   };
+   char       chrl_liface[ IFNAMSIZ ];      /* name of logical interface */
+   struct sockaddr dsl_lhwaddr;             /* logical interface mac addr */
+#endif
    struct msghdr dsl_msg;                   /* message structure       */
    struct iovec dsrl_iov[ 2 ];              /* vector containing send data */
 #ifdef MSGHDR_CONTROL_AVAILABLE
@@ -784,8 +849,8 @@
 #define ACHL_INPUT_END (chrl_input + sizeof(chrl_input))

 #ifdef TRACEHL1
-   m_hl1_printf( "nbipgw19-l%05d-T m_tccb_wsp_recvcallback() called",
-                 __LINE__ );
+   m_hl1_printf( "nbipgw19-l%05d-T m_tccb_wsp_recvcallback( adsp_tcpcomp=%p , vpp_userfld=%p , vpp_handle=%p ) called",
+                 __LINE__, adsp_tcpcomp, vpp_userfld, vpp_handle );
 #endif
    adsl_wsp_conn_w1 = (struct dsd_wsp_conn *) vpp_userfld;  /* connection to a WSP */
    adsl_receive_in1 = (struct dsd_receive_1 *) vpp_handle;
@@ -923,7 +988,9 @@
    return TRUE;                             /* continue receiving      */

    p_record_00:                             /* record has been received */
+#ifdef TRACEHL1
    m_console_out( ACHL_INPUT_STA, achl1 - ACHL_INPUT_STA );
+#endif
    adsl_gai1_w1->achc_ginp_cur = achl3;     /* processed till here     */
    if (adsl_gai1_w1->achc_ginp_cur >= adsl_gai1_w1->achc_ginp_end) {  /* this gather processed */
      adsl_gai1_w1 = adsl_gai1_w1->adsc_next;  /* get next in chain     */
@@ -934,8 +1001,24 @@
      adsl_wsp_conn_w1->dsc_connect.adsc_rec1_ch = adsl_rec1_w1->adsc_next;  /* remove from chain */
      m_proc_free( adsl_rec1_w1 );           /* free receive block      */
    }
-   iml1 = *((int *) (chrl_nonce + 16)) - (int) time( NULL );
+   /* time is passed big endian                                        */
+   iml1 = (*((unsigned char *) chrl_nonce + 16 + 0) << 24)
+            | (*((unsigned char *) chrl_nonce + 16 + 1) << 16)
+            | (*((unsigned char *) chrl_nonce + 16 + 2) << 8)
+            | *((unsigned char *) chrl_nonce + 16 + 3);
+   iml1 -= (int) time( NULL );
 // to-do 13.09.11 KB compare time, abend if wrong
+#ifdef TRACEHL1
+   m_hl1_printf( "nbipgw19-l%05d-T time difference %d received 0X%08X current 0X%08X.",
+                 __LINE__, iml1, *((int *) (chrl_nonce + 16)), time( NULL ) );
+#endif
+   if (   (iml1 < 0)
+       || (iml1 > D_LIGW_MAX_TIME_RANDOM)) {  /* maximum time in seconds that the listen-gateway decrypts the message after sent */
+     m_hl1_printf( "nbipgw19-l%05d-W from connected WSP received encrypted time %d out of range",
+                   __LINE__, iml1 );
+     adsl_wsp_conn_w1->dsc_connect.dsc_tcpco1.m_end_session();  /* stop session */
+     return FALSE;                          /* do not receive more     */
+   }
    iml1 = achl1 - ACHL_INPUT_STA;           /* length of input         */
    if (adsl_wsp_conn_w1->boc_first_message) {  /* first message has arrived */
      goto p_record_20;                      /* process record          */
@@ -1010,8 +1093,8 @@
                    __LINE__, iml1 );
      goto p_record_80;                      /* the record has been processed */
    }
+   *(--achl2) = (unsigned char) ied_ligwr_wsps;  /* other WSPs         */
    iml1 = achl1 - achl2;                    /* sizeof record           */
-   *(--achl2) = (unsigned char) ied_ligwr_wsps;  /* other WSPs         */
    iml2 = 0;                                /* clear more bit          */
    do {                                     /* loop output NHASN       */
      *(--achl2) = (unsigned char) ((iml1 & 0X7F) | iml2);
@@ -1033,8 +1116,20 @@
        goto p_rec_crso_00;                  /* received create socket  */
      case ied_ligwq_cluster:                /* cluster message         */
        goto p_rec_cluster_00;               /* received cluster        */
+#ifdef D_INCL_HOB_TUN
+     case ied_ligwq_open_tun:               /* open TUN adapter        */
+       goto p_rec_open_tun;                 /* received query open TUN */
+     case ied_ligwq_arproute_add_ipv4:      /* add ARP and route IPV4  */
+       goto p_rec_ar_add_ipv4;              /* received add AR IPV4    */
+     case ied_ligwq_arproute_del_ipv4:      /* del ARP and route IPV4  */
+       goto p_rec_ar_del_ipv4;              /* received del AR IPV4    */
+#endif
    }
-// to-do 19.09.11 KB error message
+   m_hl1_printf( "nbipgw19-l%05d-W from connected WSP PID %d received ied_li_gw_query %d invalid",
+                 __LINE__, adsl_wsp_conn_w1->imc_pid, *((unsigned char *) ACHL_INPUT_STA) );
+   m_wsp_send_msg( adsl_wsp_conn_w1,
+                   "nbipgw19-l%05d-W from connected WSP received ied_li_gw_query %d invalid",
+                   __LINE__, *((unsigned char *) ACHL_INPUT_STA) );
    goto p_record_80;                        /* the record has been processed */

    p_rec_crso_00:                           /* received create socket  */
@@ -1331,10 +1426,342 @@
    p_rec_cluster_80:                        /* end of this cluster structure */
    achl1 = achl3;                           /* point to next cluster structure */
    if (achl1 < achl2) goto p_rec_cluster_20;  /* check cluster structure */
-// goto p_record_80;                        /* the record has been processed */
+#ifdef D_INCL_HOB_TUN
+   goto p_record_80;                        /* the record has been processed */
+#endif

 #undef ADSL_LIGW_CLI_EXT_G

+#ifdef D_INCL_HOB_TUN
+   p_rec_open_tun:                          /* received query open TUN */
+#define ADSL_QUERY_OPEN_TUN_G ((struct dsd_ligw_q_open_tun *) (ACHL_INPUT_STA + 1))  /* query open TUN adapter */
+   iml_socket = adsp_tcpcomp->m_get_unix_socket_fd();
+#ifdef TRACEHL1
+   m_hl1_printf( "nbipgw19-l%05d-T m_tccb_wsp_recvcallback() p_rec_open_tun: fd=%d.",
+                 __LINE__, iml_socket );
+#endif
+   memset( &dsl_ifreq, 0, sizeof(struct ifreq) );  /* interface request */
+   dsl_ifreq.ifr_flags = IFF_TUN | IFF_NO_PI;
+   iml_rc = ioctl( iml_socket, TUNSETIFF, &dsl_ifreq );
+#ifdef TRACEHL1
+   iml_error = errno;                       /* error retrieved         */
+   m_hl1_printf( "nbipgw19-l%05d-T p_rec_open_tun: ioctl( ... , TUNSETIFF , ... ) returned %d errno %d.",
+                 __LINE__, iml_rc, errno );
+   m_console_out( (char *) &dsl_ifreq, sizeof(dsl_ifreq) );
+   errno = iml_error;                       /* error retrieved         */
+#endif
+   if (iml_rc < 0) {                        /* error occured           */
+     iml_error = errno;                     /* error retrieved         */
+     m_hl1_printf( "nbipgw19-l%05d-W p_rec_open_tun: ioctl( ... , TUNSETIFF , ... ) returned %d errno %d.",
+                   __LINE__, iml_rc, iml_error );
+     m_wsp_send_msg( adsl_wsp_conn_w1,
+                     "nbipgw19-l%05d-W p_rec_open_tun: ioctl( ... , TUNSETIFF , ... ) returned %d errno %d.",
+                     __LINE__, iml_rc, iml_error );
+   }
+   iml_index_ineta_ipv6 = 0;                /* index INETA IPV6        */
+   iml_index_ineta_ipv4 = 0;                /* index INETA IPV4        */
+   achl1 = (char *) (ADSL_QUERY_OPEN_TUN_G + 1);
+   while (iml_index_ineta_ipv4 < ADSL_QUERY_OPEN_TUN_G->ucc_no_ineta_ipv4) {  /* number of INETAs IPV4 */
+     /* aligned needed                                                 */
+     memcpy( &uml_ineta_w1, achl1, sizeof(UNSIG_MED) );
+     bol_rc = m_htun_search_interface_ipv4( uml_ineta_w1,  /* <TUN-adapter-use-interface-ineta> */
+                                            chrl_liface,
+                                            &dsl_lhwaddr );
+     m_hl1_printf( "nbipgw19-l%05d-T p_rec_open_tun: m_htun_search_interface_ipv4 returned %d INETA %d.%d.%d.%d.",
+                   __LINE__,
+                   bol_rc,
+                   *((unsigned char *) achl1 + 0),
+                   *((unsigned char *) achl1 + 1),
+                   *((unsigned char *) achl1 + 2),
+                   *((unsigned char *) achl1 + 3) );
+     if (bol_rc == FALSE) break;
+     iml_index_ineta_ipv4++;                /* increment index INETA IPV4 */
+     achl1 += 4;                            /* next INETA received     */
+   }
+   if (iml_index_ineta_ipv4 >= ADSL_QUERY_OPEN_TUN_G->ucc_no_ineta_ipv4) {  /* number of INETAs IPV4 */
+     m_hl1_printf( "nbipgw19-l%05d-W p_rec_open_tun: no free <TUN-adapter-ineta> IPV4 found",
+                   __LINE__ );
+     m_wsp_send_msg( adsl_wsp_conn_w1,
+                     "nbipgw19-l%05d-W p_rec_open_tun: no free <TUN-adapter-ineta> IPV4 found",
+                     __LINE__ );
+     iml_index_ineta_ipv4 = 0;              /* return error            */
+     goto p_ro_tun_20;                      /* continue open TUN       */
+   }
+   iml_index_ineta_ipv4++;                  /* return + 1              */
+#ifdef TRACEHL1
+   m_hl1_printf( "nbipgw19-l%05d-T m_tccb_wsp_recvcallback() p_rec_open_tun: SIOCSIFADDR with INETA %d.%d.%d.%d.",
+                 __LINE__,
+                   *((unsigned char *) achl1 + 0),
+                   *((unsigned char *) achl1 + 1),
+                   *((unsigned char *) achl1 + 2),
+                   *((unsigned char *) achl1 + 3) );
+#endif
+#define ADSL_SOCKADDR_IFR_ADDR ((struct sockaddr_in *) &dsl_ifreq.ifr_addr)
+   ADSL_SOCKADDR_IFR_ADDR->sin_family = AF_INET;
+   memcpy( &ADSL_SOCKADDR_IFR_ADDR->sin_addr, achl1, sizeof(UNSIG_MED) );  /* <TUN-adapter-ineta> */
+#undef ADSL_SOCKADDR_IFR_ADDR
+   iml_rc = ioctl( ims_tun_socket, SIOCSIFADDR, &dsl_ifreq );
+// iml_rc = ioctl( iml_socket, SIOCSIFADDR, &dsl_ifreq );
+#ifdef TRACEHL1
+   iml_error = errno;                       /* error retrieved         */
+   m_hl1_printf( "nbipgw19-l%05d-T m_tccb_wsp_recvcallback() p_rec_open_tun: ioctl( ... , SIOCSIFADDR , ... ) returned %d errno %d.",
+                   __LINE__, iml_rc, errno );
+   m_console_out( (char *) &dsl_ifreq, sizeof(dsl_ifreq) );
+   errno = iml_error;                       /* error retrieved         */
+#endif
+   if (iml_rc < 0) {                        /* error occured           */
+     iml_error = errno;                     /* error retrieved         */
+     m_hl1_printf( "nbipgw19-l%05d-W p_rec_open_tun: ioctl( ... , SIOCSIFADDR , ... ) returned %d errno %d.",
+                   __LINE__, iml_rc, iml_error );
+     m_wsp_send_msg( adsl_wsp_conn_w1,
+                     "nbipgw19-l%05d-W p_rec_open_tun: ioctl( ... , SIOCSIFADDR , ... ) returned %d errno %d.",
+                     __LINE__, iml_rc, iml_error );
+   }
+   iml_rc = ioctl( ims_tun_socket, SIOCGIFFLAGS, &dsl_ifreq );
+// iml_rc = ioctl( iml_socket, SIOCGIFFLAGS, &dsl_ifreq );
+#ifdef TRACEHL1
+   iml_error = errno;                       /* error retrieved         */
+   m_hl1_printf( "nbipgw19-l%05d-T m_tccb_wsp_recvcallback() p_rec_open_tun: ioctl( ... , SIOCGIFFLAGS , ... ) returned %d errno %d.",
+                   __LINE__, iml_rc, errno );
+   m_console_out( (char *) &dsl_ifreq, sizeof(dsl_ifreq) );
+   errno = iml_error;                       /* error retrieved         */
+#endif
+   if (iml_rc < 0) {                        /* error occured           */
+     iml_error = errno;                     /* error retrieved         */
+     m_hl1_printf( "nbipgw19-l%05d-W p_rec_open_tun: ioctl( ... , SIOCGIFFLAGS , ... ) returned %d errno %d.",
+                   __LINE__, iml_rc, iml_error );
+     m_wsp_send_msg( adsl_wsp_conn_w1,
+                     "nbipgw19-l%05d-W p_rec_open_tun: ioctl( ... , SIOCGIFFLAGS , ... ) returned %d errno %d.",
+                     __LINE__, iml_rc, iml_error );
+   }
+   dsl_ifreq.ifr_flags |= IFF_UP | IFF_RUNNING;
+   iml_rc = ioctl( ims_tun_socket, SIOCSIFFLAGS, &dsl_ifreq );
+// iml_rc = ioctl( iml_socket, SIOCSIFFLAGS, &dsl_ifreq );
+#ifdef TRACEHL1
+   iml_error = errno;                       /* error retrieved         */
+   m_hl1_printf( "nbipgw19-l%05d-T m_tccb_wsp_recvcallback() p_rec_open_tun: ioctl( ... , SIOCSIFFLAGS , ... ) returned %d errno %d.",
+                   __LINE__, iml_rc, errno );
+   m_console_out( (char *) &dsl_ifreq, sizeof(dsl_ifreq) );
+   errno = iml_error;                       /* error retrieved         */
+#endif
+   if (iml_rc < 0) {                        /* error occured           */
+     iml_error = errno;                     /* error retrieved         */
+     m_hl1_printf( "nbipgw19-l%05d-W p_rec_open_tun: ioctl( ... , SIOCSIFFLAGS , ... ) returned %d errno %d.",
+                   __LINE__, iml_rc, iml_error );
+     m_wsp_send_msg( adsl_wsp_conn_w1,
+                     "nbipgw19-l%05d-W p_rec_open_tun: ioctl( ... , SIOCSIFFLAGS , ... ) returned %d errno %d.",
+                     __LINE__, iml_rc, iml_error );
+   }
+
+   p_ro_tun_20:                             /* continue open TUN       */
+   iml_rc = close( iml_socket );
+   if (iml_rc < 0) {                        /* error occured           */
+     iml_error = errno;                     /* error retrieved         */
+     m_hl1_printf( "nbipgw19-l%05d-W p_rec_open_tun: TUN adapter close( %d ) returned %d errno %d.",
+                   __LINE__, iml_socket, iml_rc, iml_error );
+     m_wsp_send_msg( adsl_wsp_conn_w1,
+                     "nbipgw19-l%05d-W p_rec_open_tun: TUN adapter close( %d ) returned %d errno %d.",
+                     __LINE__, iml_socket, iml_rc, iml_error );
+   }
+#define ADSL_RESP_OPEN_TUN_G ((struct dsd_ligw_r_open_tun *) (chrl_output + 8))  /* response open TUN adapter */
+   ADSL_RESP_OPEN_TUN_G->ucc_index_ineta_ipv4  /* index of INETA IPV4 + 1 */
+     = iml_index_ineta_ipv4;                /* index INETA IPV4        */
+   ADSL_RESP_OPEN_TUN_G->ucc_index_ineta_ipv6  /* index of INETA IPV6 + 1 */
+     = iml_index_ineta_ipv6;                /* index INETA IPV6        */
+   memcpy( ADSL_RESP_OPEN_TUN_G->chrc_tiface, dsl_ifreq.ifr_name, IFNAMSIZ );
+   achl1 = (char *) ADSL_RESP_OPEN_TUN_G;
+   achl2 = (char *) (ADSL_RESP_OPEN_TUN_G + 1);
+#undef ADSL_RESP_OPEN_TUN_G
+#undef ADSL_QUERY_OPEN_TUN_G
+   *(--achl1) = (unsigned char) ied_ligwr_resp_open_tun;  /* open TUN adapter */
+   iml1 = achl2 - achl1;                    /* sizeof record           */
+   iml2 = 0;                                /* clear more bit          */
+   do {                                     /* loop output NHASN       */
+     *(--achl1) = (unsigned char) ((iml1 & 0X7F) | iml2);
+     iml1 >>= 7;                            /* shift bits              */
+     iml2 = 0X80;                           /* set more bit            */
+   } while (iml1 > 0);
+   dsrl_gai1_out1[ 0 ].adsc_next = &dsrl_gai1_out1[ 1 ];
+   dsrl_gai1_out1[ 0 ].achc_ginp_cur = chrs_requestheader_response;
+   dsrl_gai1_out1[ 0 ].achc_ginp_end = chrs_requestheader_response + sizeof(chrs_requestheader_response);
+   dsrl_gai1_out1[ 1 ].adsc_next = NULL;
+   dsrl_gai1_out1[ 1 ].achc_ginp_cur = achl1;  /* start of content     */
+   dsrl_gai1_out1[ 1 ].achc_ginp_end = achl2;  /* end of content       */
+   adsl_wsp_conn_w1->dsc_connect.dsc_tcpco1.m_send_gather( dsrl_gai1_out1, NULL );
+   goto p_record_80;                        /* the record has been processed */
+
+   p_rec_ar_add_ipv4:                       /* received add AR IPV4    */
+#define ADSL_QUERY_AR_ADD_IPV4_G ((struct dsd_ligw_q_ar_add_ipv4 *) (ACHL_INPUT_STA + 1))  /* add ARP and route IPV4 */
+   memset( &dsl_arpreq, 0, sizeof(struct arpreq) );  /* struct for arp requests */
+#define ADSL_SOCKADDR_ARP ((struct sockaddr_in *) &dsl_arpreq.arp_pa)
+   ADSL_SOCKADDR_ARP->sin_family = AF_INET;
+   memcpy( &ADSL_SOCKADDR_ARP->sin_addr, ADSL_QUERY_AR_ADD_IPV4_G->chrc_ineta, sizeof(UNSIG_MED) );
+#undef ADSL_SOCKADDR_ARP
+   memcpy( &dsl_arpreq.arp_ha, &ADSL_QUERY_AR_ADD_IPV4_G->dsc_rhwaddr, sizeof(struct sockaddr) );
+   dsl_arpreq.arp_flags = ATF_PUBL | ATF_NETMASK;
+   memcpy( dsl_arpreq.arp_dev, ADSL_QUERY_AR_ADD_IPV4_G->chrc_riface, IFNAMSIZ );
+#define ADSL_SOCKADDR_NETMASK ((struct sockaddr_in *) &dsl_arpreq.arp_pa)
+   ADSL_SOCKADDR_NETMASK->sin_family = AF_INET;
+   *((unsigned int *) &ADSL_SOCKADDR_NETMASK->sin_addr) = 0XFFFFFFFF;  /* 255.255.255.255 */
+#undef ADSL_SOCKADDR_ARP
+   iml_rc = ioctl( ims_tun_socket, SIOCSARP, &dsl_arpreq );
+#ifdef TRACEHL1
+   iml_error = errno;                       /* error retrieved         */
+   m_hl1_printf( "nbipgw19-l%05d-T m_tccb_wsp_recvcallback() p_rec_ar_add_ipv4: ioctl( ... , SIOCSARP , ... ) returned %d errno %d.",
+                   __LINE__, iml_rc, errno );
+   errno = iml_error;                       /* error retrieved         */
+#endif
+   if (iml_rc < 0) {                        /* error occured           */
+     iml_error = errno;                     /* error retrieved         */
+     m_hl1_printf( "nbipgw19-l%05d-W p_rec_ar_add_ipv4: INETA=%d.%d.%d.%d ioctl( ... , SIOCSARP , ... ) returned %d errno %d.",
+                   __LINE__,
+                   (unsigned char) ADSL_QUERY_AR_ADD_IPV4_G->chrc_ineta[ 0 ],
+                   (unsigned char) ADSL_QUERY_AR_ADD_IPV4_G->chrc_ineta[ 1 ],
+                   (unsigned char) ADSL_QUERY_AR_ADD_IPV4_G->chrc_ineta[ 2 ],
+                   (unsigned char) ADSL_QUERY_AR_ADD_IPV4_G->chrc_ineta[ 3 ],
+                   iml_rc, iml_error );
+     m_wsp_send_msg( adsl_wsp_conn_w1,
+                     "nbipgw19-l%05d-W p_rec_ar_add_ipv4: INETA=%d.%d.%d.%d ioctl( ... , SIOCSARP , ... ) returned %d errno %d.",
+                     __LINE__,
+                     (unsigned char) ADSL_QUERY_AR_ADD_IPV4_G->chrc_ineta[ 0 ],
+                     (unsigned char) ADSL_QUERY_AR_ADD_IPV4_G->chrc_ineta[ 1 ],
+                     (unsigned char) ADSL_QUERY_AR_ADD_IPV4_G->chrc_ineta[ 2 ],
+                     (unsigned char) ADSL_QUERY_AR_ADD_IPV4_G->chrc_ineta[ 3 ],
+                     iml_rc, iml_error );
+   }
+   memset( &dsl_routereq, 0, sizeof(struct rtentry) );  /* struct for route request */
+#define ADSL_SOCKADDR_DST ((struct sockaddr_in *) &dsl_routereq.rt_dst)
+   ADSL_SOCKADDR_DST->sin_family = AF_INET;
+   memcpy( &ADSL_SOCKADDR_DST->sin_addr, ADSL_QUERY_AR_ADD_IPV4_G->chrc_ineta, sizeof(UNSIG_MED) );
+#undef ADSL_SOCKADDR_DST
+   dsl_routereq.rt_metric = 31;
+   dsl_routereq.rt_dev = ADSL_QUERY_AR_ADD_IPV4_G->chrc_tiface;
+#define ADSL_RT_MASK ((struct sockaddr_in *) &dsl_routereq.rt_genmask)
+   /* set netmask to 255.255.255.255                                   */
+   ADSL_RT_MASK->sin_family      = AF_INET;
+   ADSL_RT_MASK->sin_addr.s_addr = 0XFFFFFFFF;
+#undef ADSL_RT_MASK
+   iml_rc = ioctl( ims_tun_socket, SIOCADDRT, &dsl_routereq );
+#ifdef TRACEHL1
+   iml_error = errno;                       /* error retrieved         */
+   m_hl1_printf( "nbipgw19-l%05d-T m_tccb_wsp_recvcallback() p_rec_ar_add_ipv4: ioctl( ... , SIOCADDRT , ... ) returned %d errno %d.",
+                 __LINE__, iml_rc, errno );
+   errno = iml_error;                       /* error retrieved         */
+#endif
+   if (iml_rc < 0) {                        /* error occured           */
+     iml_error = errno;                     /* error retrieved         */
+     m_hl1_printf( "nbipgw19-l%05d-W p_rec_ar_add_ipv4: INETA=%d.%d.%d.%d ioctl( ... , SIOCADDRT , ... ) returned %d errno %d.",
+                   __LINE__,
+                   (unsigned char) ADSL_QUERY_AR_ADD_IPV4_G->chrc_ineta[ 0 ],
+                   (unsigned char) ADSL_QUERY_AR_ADD_IPV4_G->chrc_ineta[ 1 ],
+                   (unsigned char) ADSL_QUERY_AR_ADD_IPV4_G->chrc_ineta[ 2 ],
+                   (unsigned char) ADSL_QUERY_AR_ADD_IPV4_G->chrc_ineta[ 3 ],
+                   iml_rc, iml_error );
+     m_wsp_send_msg( adsl_wsp_conn_w1,
+                     "nbipgw19-l%05d-W p_rec_ar_add_ipv4: INETA=%d.%d.%d.%d ioctl( ... , SIOCADDRT , ... ) returned %d errno %d.",
+                     __LINE__,
+                     (unsigned char) ADSL_QUERY_AR_ADD_IPV4_G->chrc_ineta[ 0 ],
+                     (unsigned char) ADSL_QUERY_AR_ADD_IPV4_G->chrc_ineta[ 1 ],
+                     (unsigned char) ADSL_QUERY_AR_ADD_IPV4_G->chrc_ineta[ 2 ],
+                     (unsigned char) ADSL_QUERY_AR_ADD_IPV4_G->chrc_ineta[ 3 ],
+                     iml_rc, iml_error );
+   }
+   dsrl_gai1_out1[ 0 ].adsc_next = &dsrl_gai1_out1[ 1 ];
+   dsrl_gai1_out1[ 0 ].achc_ginp_cur = chrs_requestheader_response;
+   dsrl_gai1_out1[ 0 ].achc_ginp_end = chrs_requestheader_response + sizeof(chrs_requestheader_response);
+   dsrl_gai1_out1[ 1 ].adsc_next = NULL;
+   dsrl_gai1_out1[ 1 ].achc_ginp_cur = (char *) ucrs_resp_ar_add_ipv4;
+   dsrl_gai1_out1[ 1 ].achc_ginp_end = (char *) ucrs_resp_ar_add_ipv4 + sizeof(ucrs_resp_ar_add_ipv4);
+   adsl_wsp_conn_w1->dsc_connect.dsc_tcpco1.m_send_gather( dsrl_gai1_out1, NULL );
+   goto p_record_80;                        /* the record has been processed */
+#undef ADSL_QUERY_AR_ADD_IPV4_G
+
+   p_rec_ar_del_ipv4:                       /* received del AR IPV4    */
+#define ADSL_QUERY_AR_DEL_IPV4_G ((struct dsd_ligw_q_ar_del_ipv4 *) (ACHL_INPUT_STA + 1))  /* del ARP and route IPV4 */
+   memset( &dsl_arpreq, 0, sizeof(struct arpreq) );  /* struct for arp requests */
+#define ADSL_SOCKADDR_ARP ((struct sockaddr_in *) &dsl_arpreq.arp_pa)
+   ADSL_SOCKADDR_ARP->sin_family = AF_INET;
+   memcpy( &ADSL_SOCKADDR_ARP->sin_addr, ADSL_QUERY_AR_DEL_IPV4_G->chrc_ineta, sizeof(UNSIG_MED) );
+#undef ADSL_SOCKADDR_ARP
+   memcpy( &dsl_arpreq.arp_ha, &ADSL_QUERY_AR_DEL_IPV4_G->dsc_rhwaddr, sizeof(struct sockaddr) );
+   dsl_arpreq.arp_flags = ATF_PUBL | ATF_NETMASK;
+   memcpy( dsl_arpreq.arp_dev, ADSL_QUERY_AR_DEL_IPV4_G->chrc_riface, IFNAMSIZ );
+#define ADSL_SOCKADDR_NETMASK ((struct sockaddr_in *) &dsl_arpreq.arp_pa)
+   ADSL_SOCKADDR_NETMASK->sin_family = AF_INET;
+   *((unsigned int *) &ADSL_SOCKADDR_NETMASK->sin_addr) = 0XFFFFFFFF;  /* 255.255.255.255 */
+#undef ADSL_SOCKADDR_ARP
+   iml_rc = ioctl( ims_tun_socket, SIOCDARP, &dsl_arpreq );
+#ifdef TRACEHL1
+   iml_error = errno;                       /* error retrieved         */
+   m_hl1_printf( "nbipgw19-l%05d-T m_tccb_wsp_recvcallback() p_rec_ar_del_ipv4: ioctl( ... , SIOCDARP , ... ) returned %d errno %d.",
+                 __LINE__, iml_rc, errno );
+   errno = iml_error;                       /* error retrieved         */
+#endif
+   if (iml_rc < 0) {                        /* error occured           */
+     iml_error = errno;                     /* error retrieved         */
+     m_hl1_printf( "nbipgw19-l%05d-W p_rec_ar_del_ipv4: INETA=%d.%d.%d.%d ioctl( ... , SIOCDARP , ... ) returned %d errno %d.",
+                   __LINE__,
+                   (unsigned char) ADSL_QUERY_AR_DEL_IPV4_G->chrc_ineta[ 0 ],
+                   (unsigned char) ADSL_QUERY_AR_DEL_IPV4_G->chrc_ineta[ 1 ],
+                   (unsigned char) ADSL_QUERY_AR_DEL_IPV4_G->chrc_ineta[ 2 ],
+                   (unsigned char) ADSL_QUERY_AR_DEL_IPV4_G->chrc_ineta[ 3 ],
+                   iml_rc, iml_error );
+     m_wsp_send_msg( adsl_wsp_conn_w1,
+                     "nbipgw19-l%05d-W p_rec_ar_del_ipv4: INETA=%d.%d.%d.%d ioctl( ... , SIOCDARP , ... ) returned %d errno %d.",
+                     __LINE__,
+                     (unsigned char) ADSL_QUERY_AR_DEL_IPV4_G->chrc_ineta[ 0 ],
+                     (unsigned char) ADSL_QUERY_AR_DEL_IPV4_G->chrc_ineta[ 1 ],
+                     (unsigned char) ADSL_QUERY_AR_DEL_IPV4_G->chrc_ineta[ 2 ],
+                     (unsigned char) ADSL_QUERY_AR_DEL_IPV4_G->chrc_ineta[ 3 ],
+                     iml_rc, iml_error );
+   }
+   memset( &dsl_routereq, 0, sizeof(struct rtentry) );  /* struct for route request */
+#define ADSL_SOCKADDR_DST ((struct sockaddr_in *) &dsl_routereq.rt_dst)
+   ADSL_SOCKADDR_DST->sin_family = AF_INET;
+   memcpy( &ADSL_SOCKADDR_DST->sin_addr, ADSL_QUERY_AR_DEL_IPV4_G->chrc_ineta, sizeof(UNSIG_MED) );
+#undef ADSL_SOCKADDR_DST
+   dsl_routereq.rt_metric = 31;
+   dsl_routereq.rt_dev = ADSL_QUERY_AR_DEL_IPV4_G->chrc_tiface;
+#define ADSL_RT_MASK ((struct sockaddr_in *) &dsl_routereq.rt_genmask)
+   /* set netmask to 255.255.255.255                                   */
+   ADSL_RT_MASK->sin_family      = AF_INET;
+   ADSL_RT_MASK->sin_addr.s_addr = 0XFFFFFFFF;
+#undef ADSL_RT_MASK
+   iml_rc = ioctl( ims_tun_socket, SIOCDELRT, &dsl_routereq );
+#ifdef TRACEHL1
+   iml_error = errno;                       /* error retrieved         */
+   m_hl1_printf( "nbipgw19-l%05d-T m_tccb_wsp_recvcallback() p_rec_ar_del_ipv4: ioctl( ... , SIOCDELRT , ... ) returned %d errno %d.",
+                 __LINE__, iml_rc, errno );
+   errno = iml_error;                       /* error retrieved         */
+#endif
+   if (iml_rc < 0) {                        /* error occured           */
+     iml_error = errno;                     /* error retrieved         */
+     m_hl1_printf( "nbipgw19-l%05d-W p_rec_ar_del_ipv4: INETA=%d.%d.%d.%d ioctl( ... , SIOCDELRT , ... ) returned %d errno %d.",
+                   __LINE__,
+                   (unsigned char) ADSL_QUERY_AR_DEL_IPV4_G->chrc_ineta[ 0 ],
+                   (unsigned char) ADSL_QUERY_AR_DEL_IPV4_G->chrc_ineta[ 1 ],
+                   (unsigned char) ADSL_QUERY_AR_DEL_IPV4_G->chrc_ineta[ 2 ],
+                   (unsigned char) ADSL_QUERY_AR_DEL_IPV4_G->chrc_ineta[ 3 ],
+                   iml_rc, iml_error );
+     m_wsp_send_msg( adsl_wsp_conn_w1,
+                     "nbipgw19-l%05d-W p_rec_ar_del_ipv4: INETA=%d.%d.%d.%d ioctl( ... , SIOCDELRT , ... ) returned %d errno %d.",
+                     __LINE__,
+                     (unsigned char) ADSL_QUERY_AR_DEL_IPV4_G->chrc_ineta[ 0 ],
+                     (unsigned char) ADSL_QUERY_AR_DEL_IPV4_G->chrc_ineta[ 1 ],
+                     (unsigned char) ADSL_QUERY_AR_DEL_IPV4_G->chrc_ineta[ 2 ],
+                     (unsigned char) ADSL_QUERY_AR_DEL_IPV4_G->chrc_ineta[ 3 ],
+                     iml_rc, iml_error );
+   }
+   dsrl_gai1_out1[ 0 ].adsc_next = &dsrl_gai1_out1[ 1 ];
+   dsrl_gai1_out1[ 0 ].achc_ginp_cur = chrs_requestheader_response;
+   dsrl_gai1_out1[ 0 ].achc_ginp_end = chrs_requestheader_response + sizeof(chrs_requestheader_response);
+   dsrl_gai1_out1[ 1 ].adsc_next = NULL;
+   dsrl_gai1_out1[ 1 ].achc_ginp_cur = (char *) ucrs_resp_ar_del_ipv4;
+   dsrl_gai1_out1[ 1 ].achc_ginp_end = (char *) ucrs_resp_ar_del_ipv4 + sizeof(ucrs_resp_ar_del_ipv4);
+   adsl_wsp_conn_w1->dsc_connect.dsc_tcpco1.m_send_gather( dsrl_gai1_out1, NULL );
+#undef ADSL_QUERY_AR_DEL_IPV4_G
+#endif
+
    p_record_80:                             /* the record has been processed */
    if (adsl_wsp_conn_w1->dsc_connect.adsc_rec1_ch) {  /* check chain received data */
      goto p_recv_sc_00;                     /* we have input           */
@@ -1346,13 +1773,13 @@

 } /* end m_tccb_wsp_recvcallback()                                     */

-/* WSP error callback function                                         */
+/** TCPCOMP WSP error callback function                                */
 static void m_tccb_wsp_errorcallback( class dsd_tcpcomp *adsp_tcpcomp, void * vpp_userfld, char *, int, int ) {
    m_hl1_printf( "nbipgw19-l%05d-T m_tccb_wsp_errorcallback() called",
                  __LINE__ );
 } /* end m_tccb_wsp_errorcallback()                                    */

-/* WSP cleanup callback function                                       */
+/* TCPCOMP WSP cleanup callback function                               */
 static void m_tccb_wsp_cleanup( class dsd_tcpcomp *adsp_tcpcomp, void * vpp_userfld ) {
    int        iml1;                         /* working variable        */
    char       *achl1;                       /* working variable        */
@@ -1415,7 +1842,7 @@
    free( adsl_wsp_conn_w1 );                /* free memory of connected WSP */
 } /* end m_tccb_wsp_cleanup()                                          */

-/* cluster send callback function                                      */
+/** TCPCOMP cluster send callback function                             */
 static void m_tccb_cluster_sendcallback( class dsd_tcpcomp *adsp_tcpcomp, void * vpp_userfld ) {
    struct dsd_connect *adsl_conn_1;         /* connection              */

@@ -1432,7 +1859,7 @@
 #endif
 } /* end m_tccb_cluster_sendcallback()                                 */

-/* cluster receive callback function                                   */
+/** TCPCOMP cluster receive callback function                          */
 static BOOL m_tccb_cluster_recvcallback( class dsd_tcpcomp *adsp_tcpco, void * vpp_userfld, void * vpp_handle ) {
    BOOL       bol1;                         /* working variable        */
    int        iml_rc;                       /* return code             */
@@ -2258,13 +2685,13 @@
    return TRUE;                             /* continue receiving      */
 } /* end m_tccb_cluster_recvcallback()                                 */

-/* cluster error callback function                                     */
+/* TCPCOMP cluster error callback function                             */
 static void m_tccb_cluster_errorcallback( class dsd_tcpcomp *adsp_tcpcomp, void * vpp_userfld, char *, int, int ) {
    m_hl1_printf( "nbipgw19-l%05d-T m_tccb_cluster_errorcallback() called",
                  __LINE__ );
 } /* end m_tccb_cluster_errorcallback()                                */

-/* cluster cleanup callback function                                   */
+/* TCPCOMP cluster cleanup callback function                           */
 static void m_tccb_cluster_cleanup( class dsd_tcpcomp *adsp_tcpcomp, void * vpp_userfld ) {
    int        iml1;                         /* working variable        */
    char       *achl1;                       /* working variable        */
@@ -2293,7 +2720,7 @@
    free( adsl_cluster_conn );               /* free this cluster member */
 } /* end m_tccb_cluster_cleanup()                                          */

-/* send a message to a connected WSP                                   */
+/** send a message to a connected WSP                                  */
 static void m_wsp_send_msg( struct dsd_wsp_conn *adsp_wsp_conn, char *aptext, ... ) {
    int        iml1, iml2;                   /* working-variables       */
    char       *achl1, *achl2;               /* working-variables       */
@@ -2310,8 +2737,9 @@
    va_end( dsl_argptr );
    if (iml1 <= 0) iml1 = sizeof(chrl_out1) - D_MAX_LEN_NHASN - 1;
    achl1 = chrl_out1 + D_MAX_LEN_NHASN + 1;  /* start of message       */
+   achl2 = achl1 + iml1;                    /* end of message          */
    *(--achl1) = (unsigned char) ied_ligwr_msg;  /* message             */
-   achl2 = achl1 + iml1;                    /* end of message          */
+   iml1++;                                  /* plus length of tag      */
    iml2 = 0;                                /* clear more bit          */
    do {                                     /* loop output NHASN       */
      *(--achl1) = (unsigned char) ((iml1 & 0X7F) | iml2);
@@ -2327,16 +2755,100 @@
    adsp_wsp_conn->dsc_connect.dsc_tcpco1.m_send_gather( dsrl_gai1_out1, NULL );
 } /* end m_wsp_send_msg()                                              */

-/* acquire memory as a buffer                                          */
+#ifdef D_INCL_HOB_TUN
+/** search the TUN interface for IPV4                                  */
+static BOOL m_htun_search_interface_ipv4( UNSIG_MED ump_ineta, char *achp_if_name, struct sockaddr *adsp_rhwaddr ) {
+   int        iml1;                         /* working variable        */
+   int        iml_rc;                       /* return code             */
+#define HL_TUN_UNIX_MAX_IF 64
+   struct ifconf dsl_ifconf;                /* interface configuration */
+   struct ifreq dsrl_ifreq[ HL_TUN_UNIX_MAX_IF ];  /* return for each iface */
+
+   memset( &dsl_ifconf, 0, sizeof(struct ifconf) );  /* interface configuration */
+   memset( dsrl_ifreq, 0, sizeof(dsrl_ifreq) );  /* return for each iface */
+   dsl_ifconf.ifc_len = sizeof(dsrl_ifreq);
+   dsl_ifconf.ifc_buf = (char*) dsrl_ifreq;
+   iml_rc = ioctl( ims_tun_socket, SIOCGIFCONF, &dsl_ifconf );
+//#ifdef TRACEHL1
+   m_hl1_printf( "nbipgw19-l%05d-T m_htun_search_interface_ipv4() ioctl( ... , SIOCGIFCONF , ... ) returned %d errno %d.",
+                 __LINE__, iml_rc, errno );
+//#endif
+   if (iml_rc < 0) {                        /* error occured           */
+   }
+   iml1 = 0;                                /* clear index             */
+
+   p_check_if_20:                           /* check interface         */
+   if (iml1 >= HL_TUN_UNIX_MAX_IF) {
+     m_hl1_printf( "nbipgw19-l%05d-T m_htun_search_interface_ipv4() no interface for INETA %d.%d.%d.%d found",
+                   __LINE__,
+                   *((unsigned char *) &ump_ineta + 0),  /* <TUN-adapter-use-interface-ineta> */
+                   *((unsigned char *) &ump_ineta + 1),  /* <TUN-adapter-use-interface-ineta> */
+                   *((unsigned char *) &ump_ineta + 2),  /* <TUN-adapter-use-interface-ineta> */
+                   *((unsigned char *) &ump_ineta + 3) );  /* <TUN-adapter-use-interface-ineta> */
+     return FALSE;
+   }
+   /* get flags for each network interfaces                            */
+   iml_rc = ioctl( ims_tun_socket, SIOCGIFFLAGS, &dsrl_ifreq[ iml1 ] );
+//#ifdef TRACEHL1
+   m_hl1_printf( "nbipgw19-l%05d-T m_htun_search_interface_ipv4() ioctl( ... , SIOCGIFFLAGS , ... ) returned %d errno %d.",
+                 __LINE__, iml_rc, errno );
+//#endif
+   if (iml_rc < 0) {                        /* error occured           */
+     iml1++;                                /* next interface          */
+     goto p_check_if_20;                    /* check interface         */
+   }
+   if ((dsrl_ifreq[ iml1 ].ifr_flags & IFF_UP) == 0) {
+     iml1++;                                /* next interface          */
+     goto p_check_if_20;                    /* check interface         */
+   }
+   /* get interface INETA                                              */
+   iml_rc = ioctl( ims_tun_socket, SIOCGIFADDR, &dsrl_ifreq[ iml1 ] );
+//#ifdef TRACEHL1
+   m_hl1_printf( "nbipgw19-l%05d-T m_htun_search_interface_ipv4() ioctl( ... , SIOCGIFADDR , ... ) returned %d errno %d.",
+                 __LINE__, iml_rc, errno );
+//#endif
+   if (iml_rc < 0) {                        /* error occured           */
+     iml1++;                                /* next interface          */
+     goto p_check_if_20;                    /* check interface         */
+   }
+   if (*((unsigned int *) &(((struct sockaddr_in *) &dsrl_ifreq[ iml1 ].ifr_addr))->sin_addr) != ump_ineta) {
+     iml1++;                                /* next interface          */
+     goto p_check_if_20;                    /* check interface         */
+   }
+   m_hl1_printf( "nbipgw19-l%05d-T m_htun_search_interface_ipv4() found interface \"%.*s\" for INETA %d.%d.%d.%d.",
+                 __LINE__,
+                 IFNAMSIZ, dsrl_ifreq[ iml1 ].ifr_name,
+                 *((unsigned char *) &ump_ineta + 0),  /* <TUN-adapter-use-interface-ineta> */
+                 *((unsigned char *) &ump_ineta + 1),  /* <TUN-adapter-use-interface-ineta> */
+                 *((unsigned char *) &ump_ineta + 2),  /* <TUN-adapter-use-interface-ineta> */
+                 *((unsigned char *) &ump_ineta + 3) );  /* <TUN-adapter-use-interface-ineta> */
+   if (achp_if_name) {
+     memcpy( achp_if_name, dsrl_ifreq[ iml1 ].ifr_name, IFNAMSIZ );
+   }
+   if (adsp_rhwaddr == NULL) return TRUE;
+   iml_rc = ioctl( ims_tun_socket, SIOCGIFHWADDR, &dsrl_ifreq[ iml1 ] );
+//#ifdef TRACEHL1
+   m_hl1_printf( "nbipgw19-l%05d-T m_htun_search_interface_ipv4() ioctl( ... , SIOCGIFHWADDR , ... ) returned %d errno %d.",
+                 __LINE__, iml_rc, errno );
+//#endif
+   if (iml_rc < 0) {                        /* error occured           */
+   }
+   memcpy( adsp_rhwaddr, &dsrl_ifreq[ iml1 ].ifr_hwaddr, sizeof(struct sockaddr) );
+   return TRUE;
+} /* end m_htun_search_interface_ipv4()                                */
+#endif
+
+/** acquire memory as a buffer                                         */
 static void * m_proc_alloc( void ) {
    return malloc( D_BUFFER_LEN );
 } /* end m_proc_alloc()                                                */

-/* free memory of buffer                                               */
+/** free memory of buffer                                              */
 static void m_proc_free( void *ap1 ) {
    free( ap1 );                             /* free memory             */
 } /* end m_proc_free()                                                 */

+/** print message on console                                           */
 extern "C" int m_hl1_printf( char *aptext, ... ) {
    va_list    dsl_argptr;
    char       chrl_out1[ 512 ];
@@ -2355,7 +2867,7 @@
 } /* end m_hl1_printf()                                                */

 #ifdef HL_UNIX
-/* return the Epoch value in micro-seconds                             */
+/** return the Epoch value in micro-seconds                            */
 static HL_LONGLONG m_get_epoch_micro_sec( void ) {
    struct timeval dsl_timeval;

@@ -2364,7 +2876,7 @@
 } /* end m_get_epoch_micro_sec()                                       */
 #endif

-/* subroutine to display date and time                                 */
+/** subroutine to display date and time                                */
 static int m_get_date_time( char *achp_buff ) {
    time_t     dsl_time;

@@ -2372,7 +2884,7 @@
    return strftime( achp_buff, 18, "%d.%m.%y %H:%M:%S", localtime( &dsl_time ) );
 } /* end m_get_date_time()                                             */

-/* subroutine to dump storage-content to console                       */
+/** subroutine to dump storage-content to console                      */
 static void m_console_out( char *achp_buff, int implength ) {
    int        iml1, iml2, iml3, iml4, iml5, iml6;  /* working variable */
    char       byl1;                         /* working-variable        */
@@ -2412,9 +2924,9 @@
      } while (iml1 < iml2);
      printf( "%.*s\n", sizeof(chrlwork1), chrlwork1 );
    }
-} /* end m_console_out()                                            */
+} /* end m_console_out()                                               */

-/* edit a long integer number for decimal display                      */
+/** edit a long integer number for decimal display                     */
 static char * m_edit_dec_long( char *achp_target, HL_LONGLONG ilp1 ) {
    int        iml1;                         /* working variable        */
    char       *achl1;
Index: hob-tuntapif01.h
===================================================================
--- hob-tuntapif01.h	(revision 0)
+++ hob-tuntapif01.h	(revision 6)
@@ -0,0 +1,565 @@
+//+-------------------------------------------------------------------+
+//|                                                                   |
+//| PROGRAM NAME: tun_WIN32API.h                                      |
+//| -------------                                                     |
+//|  Header file for HOB Utility function library for use with the    |
+//|    TAP-Win32 virtual network adapter for Windows                  |
+//|  Alan Duca 19.11.07                                               |
+//|                                                                   |
+//| COPYRIGHT:                                                        |
+//| ----------                                                        |
+//|  Copyright (C) HOB Germany 2007                                   |
+//|  Copyright (C) HOB Germany 2009                                   |
+//|                                                                   |
+//+-------------------------------------------------------------------+
+
+#include <stdio.h>
+//#include <hobsrhlp.h>
+#include <cassert>
+#include <list>
+
+#if defined WIN32 || defined WIN64
+#include <windows.h>
+#include <iphlpapi.h>
+#elif defined HL_UNIX
+#define HANDLE void*
+#include <net/if.h>
+#include <arpa/inet.h>
+#include <string.h>
+#include <errno.h>
+#include <sys/ioctl.h>
+
+//#include "types_defines.h"
+#ifndef byte
+#define byte unsigned char
+#endif
+
+#endif // defined WIN32 || WIN64
+#include "hob-htcp-int-01.h"
+
+#if defined WIN32 || WIN64
+#define TUNHANDLE HANDLE
+#elif defined HL_UNIX
+#define TUNHANDLE int
+extern TUNHANDLE dsg_tun_hdl;
+#endif // defined WIN32 || WIN64
+
+struct dsd_tun_intf_1 {             // TUN interface
+   TUNHANDLE  dsc_tunhandle;        // TUN handle
+   char       *achc_adapter_name;   // Adapter name
+   char       chrc_ineta_locale[4]; // Local end-point
+   char       chrc_ineta_remote[4]; // Remote end-point
+   char       chrc_netmask_1[4];    // Network mask
+};
+
+//
+// Find a tun device on the system and get handle to it.
+// This function looks through the windows registry in search for
+// an available TAP-Win32 virtual adapter. It may either be used to
+// return a handle to any one of a number of available virtual adapters,
+// or to return a handle to a specific virtual adapter.
+//
+// @param   aap_tun_dev    Pointer to the virtual device handle. Initialised
+//                         by this function.
+// @param   strp_dev_name  Pointer to the beginning of a string. If this
+//                         string is the empty string, then the function will
+//                         return the handle to the first available virtual
+//                         adapter it finds. Otherwise, the function will
+//                         return the handle to the virtual device who's name
+//                         corresponds to the value of this string.
+// @param   imp_name_len   Specifies the size of the buffer pointed to by
+//                         strp_dev_name.
+// @return  An int which is 0 on success, and non-zero on faliure. Further
+//          information about the reason af failure can be obtained by
+//          calling m_tun_last_err().
+//
+int m_open_tun(TUNHANDLE* aa_tun_dev,
+               char*      astr_dev_name,
+               const int  imp_name_len);
+
+//
+// Configures a virtual device to work in TUN mode, as opposed to TAP mode.
+// This function configures the local and remote endpoints of the virtual
+// adapter to be used for the reading and writing of ip packets. It also
+// configures the ip address and subnet mask for this device. Local and
+// remote endpoints need to be configured in order for a TAP-Win32 adapter
+// to operate in TUN mode. Additionally, the endpoints must be the two
+// "middle" host addresses of any 255.255.255.252 subnet (eg.: 10.1.1.1 and
+// 10.1.1.2 or 68.128.40.57 and 68.128.40.58).
+//
+// @param   ap_tun_dev      Handle to the virtual device to be configured.
+//                          Obtainable by calling m_open_tun().
+// @param   strp_dev_name   Name of the device being pointed to by
+//                          ap_tun_dev (as listed in the "Control Panel").
+// @param   strp_local_ep   The address of the local endpoint, in string
+//                          representation. This is also the address which
+//                          will be assigned to the virtual interface.
+// @param   strp_remote_ep  The address of the remote endpoint, in string
+//                          representation. Any ip packets directed to this
+//                          address will be pushed to application level.
+// @return  An int which is 0 on success, and non-zero on faliure. Further
+//          information about the reason af failure can be obtained by
+//          calling m_tun_last_err().
+//
+#ifdef B090317
+int m_init_tun(const TUNHANDLE ap_tun_dev,
+               const char*     strp_dev_name,
+               const char*     strp_local_ep,
+               const char*     strp_remote_ep);
+#endif
+int m_init_tun( struct dsd_tun_intf_1 * );
+
+//
+// Sets virtual adapter's status to "Connected".
+// The status of an opened TAP-Win32 adapter is set to "Connected".
+//
+// @param   ap_tun_dev  Handle pointing to the device which should be
+//                      assigned the "Connected" status.
+// @return  An int which is 0 on success, and non-zero on faliure. Further
+//          information about the reason af failure can be obtained by
+//          calling m_tun_last_err().
+//
+int m_connect_tun(const TUNHANDLE ap_tun_dev);
+
+//
+// Read a single captured packet from the virtual device.
+// A single call to this method causes the read of a single ip
+// packet from the virtual device. If packets to be read are available,
+// this function returns immediately. Otherwise, it enters blocking
+// state until a packet has been read.
+//
+// @param   ap_tun_dev       Handle pointing to the device to be read from.
+// @param   aucp_read_buff   Pointer to a buffer. This buffer will be populated
+//                           by this function with data read from the virtual
+//                           adapter. This buffer must be allocated and freed by
+//                           the caller.
+// @param   imp_buff_len     Length of the buffer pointed to by aucp_read_buff.
+// @param   ap_ev_cancel     Event which, if signalled, will abort the read.
+// @param   aimp_bytes_read  Pointer to an integer which will be set by this
+//                           function to represent the number of bytes read from
+//                           the virtual adapter.
+// @return  An int which is >= 0 on success, and < 0 on faliure. Further
+//          information about the reason af failure can be obtained by
+//          calling m_tun_last_err(). If the read has been completed the call
+//          returns 0. If the read has been aborted, the call returns 1.
+//
+int m_readone_blk(TUNHANDLE      ap_tun_dev,
+                  unsigned char* aucp_read_buff,
+                  int            imp_buff_len,
+                  HANDLE         ap_ev_cancel,
+                  int*           aimp_bytes_read);
+
+//
+// Write a single ip packet through the virtual device.
+// A single call to this method writes a single ip packet to the network
+// through the specified virtual device. Though this function operates in
+// blocking mode (blocks execution until the packet has been completely written)
+// it has been observed that this method does not slow down to accomodate the
+// maximum throughput of the network (it has been observed that the sendto()
+// Winsock method slows down to accomodate this). Therefore, packets are pushed
+// to the system as fast as possible.
+//
+// @param   ap_tun_dev          Handle to the virtual adapter through which to
+//                              write anip packet.
+// @param   aucp_write_buff     Pointer to a buffer containing the ip packet to
+//                              be written to the network.
+// @param   imp_data_len        Number of bytes to be written to the network.
+// @param   ap_ev_cancel        Event which, if signalled, will abort the write.
+// @param   aimp_bytes_written  Pointer to an int specifying the number of bytes
+//                              actually written to the network.
+// @return  An int which is >= 0 on success, and < 0 on faliure. Further
+//          information about the reason af failure can be obtained by
+//          calling m_tun_last_err().  If the write has been completed the call
+//          returns 0. If the write has been aborted, the call returns 1.
+//
+int m_writeone_blk(TUNHANDLE            ap_tun_dev,
+                   const unsigned char* aucp_write_buff,
+                   int                  imp_data_len,
+                   HANDLE               ap_ev_cancel,
+                   int*                 aimp_bytes_written);
+
+//
+// Closes an active virtual adapter.
+// This function closes the specified virtual adapter, making it available
+// once more. Any connections are note terminated gracefully.
+//
+// @param   ap_tun_dev  Handle to the virtual device to close and release.
+// @return  An int which is 0 on success, and non-zero on faliure. Further
+//          information about the reason af failure can be obtained by
+//          calling m_tun_last_err().
+//
+int m_close_tun(TUNHANDLE ap_tun_dev);
+
+//
+// Returns a description of the last error caused by a tun_WIN32API function.
+//
+// @return  pointer to the error string.
+//
+char* m_tun_last_err();
+
+///////////////////////////////////////////////////////
+// HOB TUN ADAPTER INTERFACE
+///////////////////////////////////////////////////////
+
+#if defined WIN32 || defined WIN64
+// General typedefs
+typedef int             int32_t;
+typedef unsigned char   byte;
+typedef unsigned short  uint16_t;
+typedef unsigned int    uint32_t;
+typedef unsigned long   ulong;
+#endif
+
+// Endpoint information
+enum ied_endpoint_type
+{
+    ied_et_ip,
+    ied_et_sn
+};
+
+#pragma pack(push,1)
+// Structure used to pass non-contiguous data buffers to the driver.
+struct dsd_vector
+{
+    char* ach_buf;      // Pointer to the size of the data
+    size_t ul_size;     // Length of data
+};
+#pragma pack(pop)
+
+// Generic patform-specific class. This class will be derived from, and is pure
+// virtual to force every platform to override the functions with their own
+// implementation.
+
+#if defined WIN32 || defined WIN64
+class dsd_platform_base
+{
+public:
+    uint32_t um_max_err_string;
+    char* astr_last_err;
+    uint32_t um_ip;
+
+    dsd_platform_base()
+    {
+        // This string is used for error reporting.
+        um_max_err_string = 1024;
+        astr_last_err = new char[um_max_err_string];
+        memset(astr_last_err, 0, um_max_err_string);
+
+        um_ip = 0;
+    };
+
+    ~dsd_platform_base()
+    {
+        delete[] astr_last_err;
+    };
+
+    // Initialize the adapter with the given IP address
+    virtual bool m_init(char* astr_vnic_ip, char* astr_vnic_mask, bool bo_need_sr) = 0;
+
+    // Write a single packet
+    virtual int m_write(byte* aby_buff, uint32_t um_buff_size, uint32_t& im_bytes_written) = 0;
+
+    // Write gather structures
+    virtual int m_write(dsd_vector* ads_vec, int im_count) = 0;
+
+    // Read a single packet
+    virtual int m_read(byte* aby_buff, uint32_t um_buff_size, uint32_t& um_bytes_read) = 0;
+
+    // Adds a static route to hook packets for a specific intranet to the
+    // TUN adapter
+    virtual bool m_add_static_route(char* ach_intranet, char* ach_mask, bool bo_single = false,
+        char* ach_proxy_gw = NULL) = 0;
+
+    // Remove a static route associated with the TUN adapter
+    virtual bool m_remove_static_route(char* ach_ip, char* ach_mask, bool bo_single = false,
+        char* ach_proxy_gw = NULL, bool bo_del_route = true) = 0;
+
+    // Retrieves the interface index for the TUN adapter
+    virtual uint32_t m_get_if_index(uint32_t um_if_ip) = 0;
+
+    // Cancels all pending reads and writes
+    virtual void m_terminating() = 0;
+
+protected:
+    int im_if_index;
+   
+private:
+    // Open a handle/file-descriptor to the adapter
+    virtual bool m_open(char* astr_vnic_ip, char* astr_vnic_mask, bool bo_need_sr) = 0;
+
+    // Close the handle/file-descriptor to the adapter
+    virtual bool m_close() = 0;
+};
+
+// Windows-specific implementation.
+class dsd_win_intf : public dsd_platform_base
+{
+public:
+    HANDLE vnic_handle;
+    HANDLE a_cancel_event;
+    HANDLE a_read_event;
+    HANDLE a_read_event_ex;
+    HANDLE a_write_event;
+
+    OVERLAPPED ds_read;     // Async read
+    OVERLAPPED ds_read_ex;  // Async read - WaitForMultipleObjects() done by the caller
+    OVERLAPPED ds_write;    // Async write
+
+    dsd_win_intf();
+    ~dsd_win_intf();
+
+    // Initialize the adapter with the given IP address and mask
+    bool m_init(char* astr_vnic_ip, char* astr_vnic_mask, bool bo_need_sr);
+
+    // Read a single packet from the adapter. Uses IRP_MJ_READ.
+    int m_read(byte* aby_buff, uint32_t um_buff_size, uint32_t& um_bytes_read);
+
+    void m_read_ex(byte* aby_buff, uint32_t um_buff_size, uint32_t& um_bytes_read,
+        HANDLE& a_read_handle);
+
+    // Processes input after WaitForMultipleObjects().
+    int m_get_read_ex_result(int im_wait_for_multiple_objects_result, uint32_t& um_bytes_read);
+
+    // Write a single packet to the adapter. Uses IRP_MJ_WRITE.
+    int m_write(byte* aby_buff, uint32_t um_buff_size, uint32_t& im_bytes_written);
+
+    // Writes a single packet represented by a vector of dsd_vector to the adapter.
+    int m_write(dsd_vector* ads_vec, int im_count);
+
+    // Retreives the index associated with an interface.
+    uint32_t m_get_if_index(uint32_t um_if_ip);
+
+    // Update ach_adp to reflect the name of the adapter which has an address on the given
+    bool m_get_adp(char* ach_intranet, char* ach_mask, char* ach_adp);
+
+    // Adds a static route to hook packets for a specific intranet to the
+    // TUN adapter. Also allows for ARP proxying.
+    bool m_add_static_route(char* ach_intranet, char* ach_mask, bool bo_single = false,
+        char* ach_proxy_gw = NULL);
+
+    // Remove a static route associated with the TUN adapter
+    bool m_remove_static_route(char* ach_intranet, char* ach_mask, bool bo_single = false,
+        char* ach_proxy_gw = NULL, bool bo_del_route = true);
+
+    void m_terminating();
+
+    void m_add_arp_entry(char* ach_ip, char* ach_mask);
+
+    void m_remove_proxy_arp(char* ach_ip, char* ach_mask);
+
+private:
+    // Route metric to use.
+    uint32_t um_metric;
+
+    // Assign an IP address and mask to the adapter (called from m_init)
+    bool m_assign_ip(char* astr_vnic_ip, char* astr_vnic_mask);
+
+    // Open a handle/file-descriptor to the adapter
+    bool m_open(char* astr_vnic_ip, char* astr_vnic_mask, bool bo_need_sr);
+
+    // Close the handle/file-descriptor to the adapter
+    bool m_close();
+
+    // Obtain the GUID of the virtual adapter
+    bool m_get_guid(char* ach_guid);
+
+    HRESULT m_assign_vnic_static_ip(char* ach_guid, char* ach_ip,
+        char* ach_mask, uint32_t um_tries, uint32_t um_wait);
+
+    bool m_get_vnic_mac(byte* aby_mac);
+
+    bool m_add_arp_endpt(ied_endpoint_type ie_type, char* ach_intranet, char* ach_mask,
+        byte byr_next_hop_mac[6]);
+
+    bool m_del_arp_endpt(ied_endpoint_type ie_type, char* ach_intranet, char* ach_mask,
+        byte byr_next_hop_mac[6]);
+};
+#endif
+
+class dsd_vnic
+{
+public:
+    dsd_vnic();
+    ~dsd_vnic();
+
+    // If astr_vnic_ip is provided, the IP will be set, else a default,
+    // hard-coded IP will be used (10.0.1.1).
+    // If astr_vnic_mask is provided, the mask will be set, else a default,
+    // hard-coded mask will be used (255.255.255.0).
+    // bo_need_sr true if this is to be executed as non-superuser on Linux/BSD.
+    // This function needs to be called before any other function calls.
+    //
+    // Return Value:
+    // True:  Initialization was successful.
+    // False: Initialization did not work.
+    bool m_init(char* astr_vnic_ip_one = NULL, char* astr_vnic_ip_two = NULL,
+        char* astr_vnic_mask = NULL, bool bo_need_sr = false);
+
+    // This function pends a read operation (asynchronous) to the driver. When
+    // a packet is received, aby_buff will hold a copy of the packet.
+    // um_max_read_size is the maximum amount of data to be read, and
+    // um_bytes_read is the size of the data returned in aby_buff.
+    //
+    // Return Value:
+    // -1: An error occured.
+    // 1:  Read aborted.
+    // 0:  Read successful.
+    int m_read(byte* aby_buff, uint32_t um_max_read_size, uint32_t& um_bytes_read);
+
+    // Registers a read operation with the driver. The calling application is responsable of using
+    // WaitForMultipleObjects() on a_read_handle and calling m_get_read_ex_result() upon return.
+    //
+    // Return Value: None.
+    // um_bytes_read is used to indicate data received as follows:
+    // Upon return, if 0: no data was available, read pended.
+    //                >0: data was available and was placed in aby_buff.
+    //
+    // N.B: um_bytes_read is always set to 0 when the function is called. This is only applicable
+    // for Windows.
+    void m_read_ex(byte* aby_buff, uint32_t um_buff_size, uint32_t& um_bytes_read,
+        HANDLE& a_read_handle);
+
+    // Return Value:
+    // -1: An error occured.
+    // 1:  Read aborted.
+    // 0:  Read successful.
+    int m_get_read_ex_result(int im_wait_for_multiple_objects_result, uint32_t& um_bytes_read);
+
+    // This function writes the contents of aby_buff to the driver.
+    // If any pending writes are present, this function will wait until writing
+    // again.
+    // um_buf_size is the size of data inside aby_buff.
+    // um_bytes_written is the amount of data copied to the driver.
+    //
+    // Return Value:
+    // -1: An error occured.
+    // 0:  Write successful.
+    int m_write(byte* aby_buff, uint32_t um_buf_size, uint32_t& um_bytes_written);
+
+    // This function writes buffers described by ads_vector to the TUN.
+    // The data described by ads_vector is non-contiguous.
+    // ads_vector is the first element of the array representing data to be written.
+    // un_total_len is the total number of bytes in all elements of the array.
+    //
+    // Return Value:
+    // -1: An error occured.
+    // 0: Write successful.
+    int m_write(dsd_vector* ads_vector, int im_count);
+
+    // Returns the file descriptor associated with the adapter (not for
+    // Windows).
+    int m_get_fd();
+
+    // Returns the device name associated with the adapter (not for Windows).
+    char* m_get_devname();
+
+    // Returns the index associated with the TUN adapter.
+    uint32_t m_get_if_index();
+
+    // Used by applications that need special rights to allow them to use
+    // the special rights module for other purposes (for example, creating
+    // sockets). Not implemented/needed for Windows.
+    // dsd_hobsrhlp_proc* m_get_prochlp();
+
+    // Returns a pointer to the dsd_tun_info structure. This may be required
+    // for multiplexing I/O operations (FD_SET etc).
+    // Not implemented for Windows.
+    // dsd_tun_info* m_get_tun_info();
+
+    // This function adds a static route (non-persistant) to the Operating
+    // System's routing table.
+    // ach_intranet is the destination of the route.
+    // ach_mask is the subnet mask for ach_intranet.
+    // bo_single can be set to true to allow for a route to be created for a single IP if
+    // the intranet is an IP (not network) but the mask is a network. This was required
+    // by VPNv2.
+    // This function also adds an ARP proxy entry to the driver for the given
+    // address.
+    //
+    // Return value:
+    // true:  Route addition successful.
+    // false: Route addition failed.
+    bool m_add_static_route(char* ach_intranet, char* ach_mask, bool bo_single = false,
+        char* ach_proxy_gw = NULL);
+
+    // This function removes a static route (non-persistant) from the Operating
+    // System's routing table.
+    // ach_intranet is the destination of the route.
+    // ach_mask is the subnet mask for ach_intranet.
+    // This function also removes an ARP proxy entry from the driver for the
+    // given address.
+    //
+    // Return value:
+    // true:  Route removal successful.
+    // false: Route removal failed.
+    bool m_remove_static_route(char* ach_intranet, char* ach_mask, bool bo_single = false,
+        char* ach_proxy_gw = NULL, bool bo_del_route = true);
+   
+    void m_add_arp_entry(char* ach_ineta, char* ach_mask);
+
+    void m_remove_arp_entry(char* ach_ineta, char* ach_mask);
+
+    // Notifies the interface that the application is terminating. This cancels
+    // all pending actions.
+    void m_terminating();
+
+    // Destroys the interface.
+    void m_destroy();
+
+    // Returns a string detailing the last error.
+    char* m_get_last_error();
+
+private:
+    // Hides implementation details and makes usage far cleaner. There is no
+    // real need to show the user a large list of private functions that will
+    // never be used.
+
+    class dsd_win_intf* ads_win_intf;
+};
+
+#define TUN_ADAPTER_NETMASK  "255.255.255.252"
+
+#if defined _WIN32
+#define ETH_TYPE             0x0008         // IPv4
+#define ETH_FRAME_SIZE       14             // Size of ethernet (MAC) header
+
+#define DEFINE_CTL_CODE(a)                  CTL_CODE(FILE_DEVICE_UNKNOWN, a, METHOD_BUFFERED, FILE_ANY_ACCESS)
+#define IOCTL_VNIC_ID_ARP_ADD_ENDPT         DEFINE_CTL_CODE(0x807)
+#define IOCTL_VNIC_ID_ARP_DEL_ENDPT         DEFINE_CTL_CODE(0x808)
+#define IOCTL_VNIC_ID_ARP_DEL_ALL_ENDPTS    DEFINE_CTL_CODE(0x809)
+#define IOCTL_VNIC_WRITE_VECTOR             DEFINE_CTL_CODE(0x9BA)
+
+#define MAX_MAC_ADDRESS_LEN  20
+
+#pragma pack(push, 1)
+typedef enum ied_tun_driver_error
+{
+    ied_tde_noerror = 0,
+    ied_tde_unexpected,
+    ied_tde_allocation_failed,
+    ied_tde_mac_not_found,
+} ied_tun_driver_error;
+
+// Used for VNIC ARP proxying
+struct dsd_vnic_endpt
+{
+    BOOL              boc_use_ipv4;
+    BOOL              boc_use_ipv6;
+    ied_endpoint_type iec_type;
+    char              chrc_ineta_ipv4[4];
+    char              chrc_mask_ipv4[4];
+    char              chrc_ineta_ipv6[16];
+    int               imc_prefix_ipv6;
+    char              chrc_mac[6];
+};
+
+// Add endpoint structure for IO_CONTROL
+struct dsd_vnic_add_endpt
+{
+    dsd_vnic_endpt ds_endpt;
+    ied_tun_driver_error ie_error_code;
+};
+
+#pragma pack(pop)
+
+#endif // _WIN32
Index: xs-gw-serv-vch-icap.cpp
===================================================================
--- xs-gw-serv-vch-icap.cpp	(revision 2)
+++ xs-gw-serv-vch-icap.cpp	(revision 6)
@@ -303,7 +303,11 @@
 static void m_virch_do_connect( struct dsd_virch_active * );
 #endif
 static void m_virch_cb_conn_err( dsd_tcpcomp *, void *, struct sockaddr *, socklen_t, int, int, int );
+#ifdef B121120
 static void m_virch_conncallback( dsd_tcpcomp *, void *, struct sockaddr *, socklen_t, int );  /* connect callback function */
+#else
+static void m_virch_conncallback( dsd_tcpcomp *, void *, struct dsd_target_ineta_1 *, void *, struct sockaddr *, socklen_t, int );  /* connect callback function */
+#endif
 static void m_virch_sendcallback( dsd_tcpcomp *, void * );  /* send callback function */
 static int m_virch_getrecvbuf( dsd_tcpcomp *, void *, void **, char **, int ** );  /* get receive buffer callback function */
 static int m_virch_recvcallback( dsd_tcpcomp *, void *, void * );  /* receive callback function */
@@ -2051,6 +2055,9 @@
               adsl_vchact,
               &adsl_vchact->adsc_sevirch_entry->dsc_bind_multih,  /* for bind multihomed */
               adsl_vchact->adsc_sevirch_entry->adsc_server_ineta,  /* remote INETA */
+#ifndef B121120
+              NULL,                         /* INETA to free           */
+#endif
               adsl_vchact->adsc_sevirch_entry->imc_port,  /* port of target */
               TRUE );                       /* do connect round-robin */
    if (iml_rc == 0) {                       /* no error occured        */
@@ -3152,6 +3159,9 @@

 /** TCPCOMP connect callback function                                  */
 static void m_virch_conncallback( dsd_tcpcomp *adsp_tcpco, void *vpp_userfld,
+#ifndef B121120
+                                  struct dsd_target_ineta_1 *, void *,  /* INETA to free */
+#endif
                                   struct sockaddr *adsp_soa, socklen_t imp_len_soa, int imp_error ) {
    BOOL       bol1;                         /* working-variable        */
    int        iml1;                         /* working-variable        */
Index: xs-htcp-hdr-01.cpp
===================================================================
--- xs-htcp-hdr-01.cpp	(revision 0)
+++ xs-htcp-hdr-01.cpp	(revision 6)
@@ -0,0 +1,473 @@
+/******************************************************************************
+ * File name: xs-htcp-hdr-01.cpp
+ *
+ * Implementation of non-inline functions for hob-htcp-hdr-01.h
+ *
+ * Author: Kevin Spiteri
+ * Copyright: Copyright (c) HOB Software 2011
+ ******************************************************************************/
+
+#include <string.h>
+
+#ifndef DEF_INCLUDE_HEADERS
+#define DEF_INCLUDE_HEADERS
+#endif /* !DEF_INCLUDE_HEADERS */
+
+#include "hob-htcp-int-01.h"
+#include "hob-htcp-hdr-01.h"
+
+static uint16_t m_calc_chksum(const char* achp_data, uint32_t ump_len,
+                            bool bop_odd, uint16_t usp_part)
+{
+    uint16_t usl_buf = 0; /* declare as uint16_t to ensure proper alignment */
+    uint8_t* const autl_buf = (uint8_t*)&usl_buf;
+    uint32_t uml_chksum;
+    uint32_t uml_i;
+
+    if (ump_len == 0)
+        return usp_part ? usp_part : 0xffff;
+
+    if ((size_t)achp_data & 1) { /* check achp_data alignment */
+        bop_odd = !bop_odd;
+
+        autl_buf[1] = *achp_data;
+        ++achp_data;
+        --ump_len;
+        if (ump_len & 1) {
+            --ump_len;
+            autl_buf[0] = achp_data[ump_len];
+        }
+    } else {
+        if (ump_len & 1) {
+            --ump_len;
+            autl_buf[0] = achp_data[ump_len];
+        }
+    }
+    ump_len /= 2;
+
+    uml_chksum = usl_buf;
+    if (bop_odd) {
+        autl_buf[0] = usp_part & 0xff;
+        autl_buf[1] = usp_part >> 8;
+    } else {
+        autl_buf[0] = usp_part >> 8;
+        autl_buf[1] = usp_part & 0xff;
+    }
+    uml_chksum += usl_buf;
+
+    /*
+     * we have already included partial checksum and edge bytes
+     * achp_data points to ump_len (which is even) 2-byte aligned bytes
+     */
+
+    for (; ump_len >= 0xffff; ump_len -= 0xffff) {
+        /*
+         *avoid overflow:
+         * 32 bits contain maximum 0xffff * 0x10001
+         * we must allow for 0x1fffe as current checksum
+         * we cannot do more than for 0xffff additions
+         */
+
+        for (uml_i = 0; uml_i < 0xffff; ++uml_i) {
+            uml_chksum += *(const uint16_t*)achp_data;
+            achp_data += 2;
+        }
+        uml_chksum = (uml_chksum & 0xffff) + (uml_chksum >> 16);
+    }
+
+    for (; ump_len > 0; --ump_len) {
+        uml_chksum += *(const uint16_t*)achp_data;
+        achp_data += 2;
+    }
+
+    uml_chksum = (uml_chksum & 0xffff) + (uml_chksum >> 16);
+    uml_chksum += uml_chksum >> 16;
+
+    usl_buf = uml_chksum;
+
+    if (bop_odd) {
+        uml_chksum = autl_buf[1] << 8 | autl_buf[0];
+    } else {
+        uml_chksum = autl_buf[0] << 8 | autl_buf[1];
+    }
+
+    return uml_chksum ? uml_chksum : 0xffff;
+}
+
+uint16_t m_calc_ip_chksum(const char* achp_ip_header)
+{
+    uint16_t usl_part;
+    uint32_t uml_len;
+
+    uml_len = m_get_calc_ip_hlen(achp_ip_header);
+    if (uml_len < 20)
+        uml_len = 20;
+    usl_part = m_calc_chksum(achp_ip_header, 10, false, 0);
+    usl_part = m_calc_chksum(achp_ip_header + 12, uml_len - 12,
+                             false, usl_part);
+
+    return usl_part == 0xffff ? 0xffff : ~usl_part;
+}
+
+uint16_t m_calc_ip_tcp_pseudo_chksum(const char* achp_ip_header)
+{
+    return m_calc_chksum(achp_ip_header + 12, 8, false, 6);
+}
+
+uint16_t m_calc_ip6_tcp_pseudo_chksum(const char* achp_ip6_header)
+{
+    return m_calc_chksum(achp_ip6_header + 8, 32, false, 6);
+}
+
+uint16_t m_calc_tcp_data_chksum(const char* achp_data, uint32_t ump_len,
+                                uint16_t usp_part)
+{
+    return m_calc_chksum(achp_data, ump_len, false, usp_part);
+}
+
+uint16_t m_calc_tcp_odd_data_chksum(const char* achp_data, uint32_t ump_len,
+                                  uint16_t usp_part)
+{
+    return m_calc_chksum(achp_data, ump_len, true, usp_part);
+}
+
+uint16_t m_calc_tcp_chksum(const char* achp_tcp_header, uint32_t ump_data_len,
+                           uint16_t usp_part)
+{
+    uint32_t uml_chksum;
+    unsigned unl_hlen;
+
+    unl_hlen = m_get_calc_tcp_hlen(achp_tcp_header);
+    usp_part = m_calc_chksum(achp_tcp_header, 16, false, usp_part);
+    usp_part = m_calc_chksum(achp_tcp_header + 18, unl_hlen - 18, false,
+                             usp_part);
+
+    ump_data_len += unl_hlen;
+    uml_chksum = (ump_data_len & 0xffff) + (ump_data_len >> 16);
+    uml_chksum += usp_part;
+    usp_part = (uml_chksum & 0xffff) + (uml_chksum >> 16);
+
+    return usp_part == 0xffff ? 0xffff : ~usp_part;
+}
+
+uint16_t m_tcp_chksum_add(uint16_t usp_chksum,
+                          const char* achp_data, uint32_t ump_len)
+{
+    usp_chksum = m_calc_chksum(achp_data, ump_len, false, ~usp_chksum);
+    return usp_chksum == 0xffff ? 0xffff : ~usp_chksum;
+}
+
+uint16_t m_tcp_chksum_odd_add(uint16_t usp_chksum,
+                              const char* achp_data, uint32_t ump_len)
+{
+    usp_chksum = m_calc_chksum(achp_data, ump_len, true, ~usp_chksum);
+    return usp_chksum == 0xffff ? 0xffff : ~usp_chksum;
+}
+
+uint16_t m_tcp_chksum_sub(uint16_t usp_chksum,
+                          const char* achp_data, uint32_t ump_len)
+{
+    return m_calc_chksum(achp_data, ump_len, false, usp_chksum);
+}
+
+uint16_t m_tcp_chksum_odd_sub(uint16_t usp_chksum,
+                              const char* achp_data, uint32_t ump_len)
+{
+    return m_calc_chksum(achp_data, ump_len, true, usp_chksum);
+}
+
+uint16_t m_tcp_chksum_odd_to_even(uint16_t usp_chksum,
+                                  const char* achp_data, uint32_t ump_len)
+{
+    uint16_t usl_c;
+    uint32_t uml_chksum = usp_chksum;
+
+    usl_c = m_calc_chksum(achp_data, ump_len, true, 0);
+    uml_chksum += usl_c;
+
+    usl_c = ~usl_c;
+    uml_chksum += ((usl_c & 0xff) << 8) | (usl_c >> 8);
+
+    usl_c = (uml_chksum & 0xffff) + (uml_chksum >> 16);
+    return usl_c ? usl_c : 0xffff;
+}
+
+uint16_t m_tcp_chksum_even_to_odd(uint16_t usp_chksum,
+                                  const char* achp_data, uint32_t ump_len)
+{
+    uint16_t usl_c;
+    uint32_t uml_chksum = usp_chksum;
+
+    usl_c = m_calc_chksum(achp_data, ump_len, false, 0);
+    uml_chksum += usl_c;
+
+    usl_c = ~usl_c;
+    uml_chksum += ((usl_c & 0xff) << 8) | (usl_c >> 8);
+
+    usl_c = (uml_chksum & 0xffff) + (uml_chksum >> 16);
+    return usl_c ? usl_c : 0xffff;
+}
+
+uint16_t m_tcp_chksum_change_len(uint16_t usp_chksum, int32_t ump_add_len)
+{
+    char chrl_buf[4];
+
+    if (ump_add_len > 0) {
+        chrl_buf[0] = ump_add_len >> 24;
+        chrl_buf[1] = ump_add_len >> 16;
+        chrl_buf[2] = ump_add_len >> 8;
+        chrl_buf[3] = ump_add_len;
+        return m_tcp_chksum_add(usp_chksum, chrl_buf, 4);
+    } else if (ump_add_len < 0) {
+        ump_add_len = -ump_add_len;
+        chrl_buf[0] = ump_add_len >> 24;
+        chrl_buf[1] = ump_add_len >> 16;
+        chrl_buf[2] = ump_add_len >> 8;
+        chrl_buf[3] = ump_add_len;
+        return m_tcp_chksum_sub(usp_chksum, chrl_buf, 4);
+    } else {
+        return usp_chksum;
+    }
+}
+
+bool m_is_ip_size_ok(const char* achp_ip_header, uint32_t ump_hsize)
+{
+    uint32_t uml_hlen;
+    uint32_t uml_tlen;
+
+    if (ump_hsize < 20)
+        return false;
+
+    if (m_get_ip_version(achp_ip_header) != 4)
+        return false;
+
+    uml_hlen = m_get_calc_ip_hlen(achp_ip_header);
+    if (uml_hlen < 20)
+        return false;
+
+    uml_tlen = m_get_ip_tlen(achp_ip_header);
+    if (uml_tlen < uml_hlen)
+        return false;
+
+    uml_tlen += m_get_calc_ip_fofs(achp_ip_header);
+    if (uml_tlen > 0xffff)
+        return false;
+
+    return true;
+}
+
+bool m_is_ip6_size_ok(const char* achp_ip6_header, uint32_t ump_hsize)
+{
+    if (ump_hsize < 40)
+        return false;
+
+    if (m_get_ip6_version(achp_ip6_header) != 6)
+        return false;
+
+    return true;
+}
+
+bool m_is_tcp_size_ok(const char* achp_tcp_header, uint32_t ump_hsize,
+                      uint32_t ump_segsize)
+{
+    uint32_t uml_hlen;
+
+    if (ump_hsize < 20 || ump_segsize < 20)
+        return false;
+
+    uml_hlen = m_get_calc_tcp_hlen(achp_tcp_header);
+    if (uml_hlen < 20 || uml_hlen > ump_hsize || uml_hlen > ump_segsize)
+        return false;
+
+    return true;
+}
+
+const char* m_first_tcp_option(const char* achp_tcp_header,
+                               const char* achp_tcp_header_end)
+{
+    achp_tcp_header += 20;
+
+    while (achp_tcp_header + 1 < achp_tcp_header_end) {
+        switch (*achp_tcp_header) {
+        case 0:
+            return achp_tcp_header_end;
+
+        case 1:
+            ++achp_tcp_header;
+            break;
+
+        default:
+            if (achp_tcp_header[1] < 2 ||
+                achp_tcp_header + achp_tcp_header[1] > achp_tcp_header_end) {
+
+                return achp_tcp_header_end;
+            }
+            return achp_tcp_header;
+        }
+    }
+
+    return achp_tcp_header_end;
+}
+
+const char* m_next_tcp_option(const char* achp_tcp_option,
+                              const char* achp_tcp_header_end)
+{
+    if (achp_tcp_option + 1 >= achp_tcp_header_end || achp_tcp_option[1] < 2)
+        return achp_tcp_header_end;
+
+    achp_tcp_option += achp_tcp_option[1];
+
+    while (achp_tcp_option + 1 < achp_tcp_header_end) {
+        switch (*achp_tcp_option) {
+        case 0:
+            return achp_tcp_header_end;
+
+        case 1:
+            ++achp_tcp_option;
+            break;
+
+        default:
+            if (achp_tcp_option[1] < 2 ||
+                achp_tcp_option + achp_tcp_option[1] > achp_tcp_header_end) {
+
+                return achp_tcp_header_end;
+            }
+            return achp_tcp_option;
+        }
+    }
+
+    return achp_tcp_header_end;
+}
+
+uint32_t m_ip_tcp_answer_reset(char* achp_answer, uint32_t ump_alen,
+                               const char* achp_header, uint32_t ump_hlen,
+                               uint16_t usp_id)
+{
+    uint32_t uml_ip_hlen;
+    uint16_t usl_orig_dlen;
+    uint16_t usl_part_chksum;
+    uint16_t usl_hchksum;
+    const char* achl_tcp_header;
+
+    if (ump_alen < 40 || !m_is_ip_size_ok(achp_header, ump_hlen)) {
+        return 0;
+    }
+    uml_ip_hlen = m_get_calc_ip_hlen(achp_header);
+    usl_hchksum = m_get_ip_chksum(achp_header);
+    achl_tcp_header = achp_header + uml_ip_hlen;
+    if ((usl_hchksum != 0 && usl_hchksum != m_calc_ip_chksum(achp_header)) ||
+        m_get_ip_prot(achp_header) != 6 ||
+        ump_hlen < uml_ip_hlen + 20 ||
+        !m_is_tcp_size_ok(achl_tcp_header, ump_hlen - uml_ip_hlen,
+                          m_get_ip_tlen(achp_header) - uml_ip_hlen) ||
+        m_get_tcp_rst(achl_tcp_header)) {
+
+        return 0;
+    }
+
+    m_set_ip_version(achp_answer, 4);
+    m_set_calc_ip_hlen(achp_answer, 20);
+    m_set_ip_tos(achp_answer, 0);
+    m_set_ip_tlen(achp_answer, 40);
+    m_set_ip_id(achp_answer, usp_id);
+    m_set_ip_flags(achp_answer, 0);
+    m_set_ip_df(achp_answer, 1);
+    m_set_calc_ip_fofs(achp_answer, 0);
+    m_set_ip_ttl(achp_answer, 128);
+    m_set_ip_prot(achp_answer, m_get_ip_prot(achp_header));
+    m_set_ip_src_addr(achp_answer, m_get_ip_dst_addr(achp_header));
+    m_set_ip_dst_addr(achp_answer, m_get_ip_src_addr(achp_header));
+
+    m_set_ip_chksum(achp_answer, m_calc_ip_chksum(achp_answer));
+
+    m_set_tcp_src_port(achp_answer + 20, m_get_tcp_dst_port(achl_tcp_header));
+    m_set_tcp_dst_port(achp_answer + 20, m_get_tcp_src_port(achl_tcp_header));
+    m_set_calc_tcp_hlen(achp_answer + 20, 20);
+    m_set_tcp_resv(achp_answer + 20, 0);
+    m_set_tcp_flags(achp_answer + 20, 0);
+    m_set_tcp_rst(achp_answer + 20, 1);
+    m_set_tcp_window(achp_answer + 20, 0);
+    m_set_tcp_urgent(achp_answer + 20, 0);
+
+    if (m_get_tcp_ack(achl_tcp_header)) {
+        m_set_tcp_seqn(achp_answer + 20, m_get_tcp_ackn(achl_tcp_header));
+        m_set_tcp_ackn(achp_answer + 20, 0);
+    } else {
+        usl_orig_dlen = m_get_ip_tlen(achp_header) -
+            m_get_calc_ip_hlen(achp_header) -
+            m_get_calc_tcp_hlen(achl_tcp_header);
+	if (m_get_tcp_syn(achl_tcp_header))
+	  ++usl_orig_dlen;
+	if (m_get_tcp_fin(achl_tcp_header))
+	  ++usl_orig_dlen;
+
+        m_set_tcp_seqn(achp_answer + 20, 0);
+        m_set_tcp_ackn(achp_answer + 20,
+                       m_get_tcp_seqn(achl_tcp_header) + usl_orig_dlen);
+        m_set_tcp_ack(achp_answer + 20, 1);
+    }
+
+    usl_part_chksum = m_calc_ip_tcp_pseudo_chksum(achp_answer);
+    m_set_tcp_chksum(achp_answer + 20,
+                     m_calc_tcp_chksum(achp_answer + 20, 0, usl_part_chksum));
+
+    return 40;
+}
+
+uint32_t m_ip6_tcp_answer_reset(char* achp_answer, uint32_t ump_alen,
+                                const char* achp_header, uint32_t ump_hlen)
+{
+    uint16_t usl_orig_dlen;
+    uint16_t usl_part_chksum;
+
+    if (ump_alen < 60 || ump_hlen < 60 ||
+        !m_is_ip6_size_ok(achp_header, ump_hlen) ||
+        m_get_ip6_nh(achp_header) != 6 ||
+        !m_is_tcp_size_ok(achp_header + 40, ump_hlen - 40,
+                          m_get_ip6_plen(achp_header)) ||
+        m_get_tcp_rst(achp_header + 40)) {
+
+        return 0;
+    }
+
+    m_set_ip6_version(achp_answer, 6);
+    m_set_ip6_tcls(achp_answer, 0);
+    m_set_ip6_flow(achp_answer, 0);
+    m_set_ip6_plen(achp_answer, 20);
+    m_set_ip6_nh(achp_answer, 6);
+    m_set_ip6_hlim(achp_answer, 128);
+    m_set_ip6_src_addr(achp_answer, m_get_ip6_dst_addr(achp_header));
+    m_set_ip6_dst_addr(achp_answer, m_get_ip6_src_addr(achp_header));
+
+    m_set_tcp_src_port(achp_answer + 40, m_get_tcp_dst_port(achp_header + 40));
+    m_set_tcp_dst_port(achp_answer + 40, m_get_tcp_src_port(achp_header + 40));
+    m_set_calc_tcp_hlen(achp_answer + 40, 20);
+    m_set_tcp_resv(achp_answer + 40, 0);
+    m_set_tcp_flags(achp_answer + 40, 0);
+    m_set_tcp_rst(achp_answer + 40, 1);
+    m_set_tcp_window(achp_answer + 40, 0);
+    m_set_tcp_urgent(achp_answer + 40, 0);
+
+    if (m_get_tcp_ack(achp_header + 40)) {
+        m_set_tcp_seqn(achp_answer + 40, m_get_tcp_ackn(achp_header + 40));
+        m_set_tcp_ackn(achp_answer + 40, 0);
+    } else {
+        usl_orig_dlen = m_get_ip6_plen(achp_header) -
+            m_get_calc_tcp_hlen(achp_header + 40);
+	if (m_get_tcp_syn(achp_header + 40))
+	  ++usl_orig_dlen;
+	if (m_get_tcp_fin(achp_header + 40))
+	  ++usl_orig_dlen;
+
+        m_set_tcp_seqn(achp_answer + 40, 0);
+        m_set_tcp_ackn(achp_answer + 40,
+                       m_get_tcp_seqn(achp_header + 40) + usl_orig_dlen);
+        m_set_tcp_ack(achp_answer + 40, 1);
+    }
+
+    usl_part_chksum = m_calc_ip6_tcp_pseudo_chksum(achp_answer);
+    m_set_tcp_chksum(achp_answer + 40,
+                     m_calc_tcp_chksum(achp_answer + 40, 0, usl_part_chksum));
+
+    return 60;
+}
Index: xs-htcp-htun-01.cpp
===================================================================
--- xs-htcp-htun-01.cpp	(revision 0)
+++ xs-htcp-htun-01.cpp	(revision 6)
@@ -0,0 +1,1692 @@
+// #define TRY_130114
+
+/******************************************************************************
+ * File name: xs-htcp-htun-01.cpp
+ *
+ * Author: Kevin Spiteri
+ * Copyright: Copyright (c) HOB Software 2012
+ ******************************************************************************/
+
+#include <string.h>
+#include <stdlib.h>
+#include <stddef.h>
+#include <list>
+
+#include "hob-htcp-int-01.h"
+#include "hob-htcp-hdr-01.h"
+#include "hob-htcp-01.h"
+
+#if defined WIN32
+#include <winsock2.h>
+#include <ws2tcpip.h>
+#include <windows.h>
+#elif defined HL_UNIX
+#include "hob-unix01.h"
+#include <arpa/inet.h>
+#include <net/if.h>
+#else // !defined WIN32 && !defined HL_UNIX
+#error either WIN32 or HL_UNIX needed
+#endif // !defined WIN32 && !defined HL_UNIX
+
+#ifndef HOB_CONTR_TIMER
+#define HOB_CONTR_TIMER
+#endif
+
+typedef unsigned char byte;
+#include "hob-netw-01.h"
+#include "hob-avl03.h"
+#include "hob-xslcontr.h"
+#include "hob-tun01.h"
+#include "hob-sessutil01.h"
+#include "hob-session01.h"
+
+// for WSP tracing:
+#ifndef DEF_HL_INCL_DOM
+#define DEF_HL_INCL_DOM
+#endif
+#ifndef DOMNode
+#define DOMNode void
+#endif
+#include "hob-wsppriv.h"
+#include "hob-xsclib01.h"
+#include "hob-xbipgw08-1.h"
+#include "hob-xbipgw08-2.h"
+extern "C" int img_wsp_trace_core_flags1;
+
+#include "hob-htcp-htun-01.h"
+
+extern "C"
+int m_get_random_number(int inp_max);
+
+extern "C"
+void m_htun_critsect_enter(struct dsd_tun_contr_conn* adsp_tun_contr_conn);
+
+extern "C"
+void m_htun_critsect_leave(struct dsd_tun_contr_conn* adsp_tun_contr_conn);
+
+static const int ins_round_robin_max = 64;
+
+
+enum ied_htcp_htun_state {
+    ied_hhs_connecting,  // still connecting to server
+    ied_hhs_conn_abort,  // aborted while connecting to server
+    ied_hhs_connected,   // connection active
+    ied_hhs_close,       // received m_htun_sess_close() but connection active
+    ied_hhs_close_force, // after ied_hhs_close, have not yet received end
+    ied_hhs_time_wait,   // after ied_hhs_close, received FIN, TCP TIME_WAIT
+    ied_hhs_end,         // received FIN, called m_htun_session_end()
+    ied_hhs_closed       // HTCP called amc_closed(), safety timeout phase
+};
+
+struct dsd_htcp_htun {
+    struct dsd_htun_handle dsc_handle;
+
+    struct dsd_tun_contr_conn* adsc_tcc;
+    struct dsd_tun_contr_ineta* adsc_tci;
+
+    /* connection state */
+    enum ied_htcp_htun_state iec_hhs;
+
+    /* address information */
+    bool boc_ipv6;
+    char chrc_local_addr[16];
+    char chrc_remote_addr[16];
+    uint16_t usc_local_port;
+    uint16_t usc_remote_port;
+
+    /*
+     * HTCP will only be called on one thread.
+     * If a call is received, information may be stored and handled later.
+     */
+    bool boc_sync_running;
+    bool boc_sync_close;
+    uint32_t umc_sync_send;
+    bool boc_sync_can_recv;
+    struct dsd_htcp_packet* adsc_sync_packet;
+    bool boc_sync_timeout;
+
+    struct dsd_timer_ele dsc_te;
+    struct dsd_timer_ele dsc_te_closing;
+    bool boc_te_closing_free;
+
+    /* used while connecting */
+    struct dsd_target_ineta_1* adsc_target_ineta;
+    void* ac_free_ti1;
+    int inc_htcp_error;
+    int inc_target_cur;
+    int inc_target_random_remain;
+    uint64_t ulc_target_unused;
+
+    /* used throughout connection */
+    struct dsd_gather_i_1* adsc_sending;
+    struct dsd_gather_i_1* adsc_sending_tail;
+    char* achc_sending_tail_end;
+    bool boc_can_recv;
+
+    /* HTCP connection */
+    struct dsd_htcp_conn dsc_hc;
+};
+
+struct dsd_htcp_packet_control {
+    struct dsd_htcp_packet* adsc_next;
+    void* ac_handle;
+    char* achc_data;
+    uint32_t umc_len;
+};
+
+struct dsd_htcp_packet {
+    struct dsd_htcp_packet_control dsc_hpc;
+    struct dsd_htcp_in_info dsc_hii;
+};
+
+static void m_process_sync(struct dsd_htcp_htun* adsp_hh);
+
+static void m_try_next_address(struct dsd_htcp_htun* adsp_hh);
+
+static void m_recv_data(struct dsd_htcp_htun* adsp_hh);
+
+static void m_free_resources(struct dsd_htcp_htun* adsp_hh);
+
+
+static void m_hct_compl(struct dsd_timer_ele* adsp_te);
+static void m_hct_compl_closing(struct dsd_timer_ele* adsp_te);
+
+static bool m_hcb_out_get(struct dsd_htcp_conn* adsp_hc,
+                          uint32_t ump_offset,
+                          const char** aachp_buf, uint32_t* aump_len);
+static bool m_hcb_out_packets(struct dsd_htcp_conn* adsp_hc);
+static bool m_hcb_out_ack(struct dsd_htcp_conn* adsp_hc, uint32_t ump_len);
+
+static bool m_hcb_in_get(struct dsd_htcp_conn* adsp_hc,
+                         struct dsd_htcp_in_info* adsp_hii,
+                         uint32_t ump_offset,
+                         const char** aachp_buf, uint32_t* aump_len);
+static bool m_hcb_in_more_data(struct dsd_htcp_conn* adsp_hc);
+static bool m_hcb_in_rel(struct dsd_htcp_conn* adsp_hc,
+                         struct dsd_htcp_in_info* adsp_hii);
+
+static bool m_hcb_get_time(struct dsd_htcp_conn* adsp_hc, int64_t* ailp_time);
+static bool m_hcb_set_timer(struct dsd_htcp_conn* adsp_hc,
+                            uint32_t ump_delay_ms);
+static bool m_hcb_rel_timer(struct dsd_htcp_conn* adsp_hc);
+
+static bool m_hcb_lock(struct dsd_htcp_conn* adsp_hc);
+static bool m_hcb_unlock(struct dsd_htcp_conn* adsp_hc);
+
+static bool m_hcb_established(struct dsd_htcp_conn* adsp_hc);
+static void m_hcb_closed(struct dsd_htcp_conn* adsp_hc,
+                         enum ied_htcp_close iep_htcpc);
+
+
+static const struct dsd_htcp_callbacks dss_hcb = {
+    &m_hcb_out_get,
+    &m_hcb_out_packets,
+    &m_hcb_out_ack,
+    &m_hcb_in_get,
+    &m_hcb_in_more_data,
+    &m_hcb_in_rel,
+    &m_hcb_get_time,
+    &m_hcb_set_timer,
+    &m_hcb_rel_timer,
+    &m_hcb_lock,
+    &m_hcb_unlock,
+    &m_hcb_established,
+    &m_hcb_closed
+};
+
+// achp_str should point to a buffer where at least 42 bytes may be written
+static void m_print_addr(char* achp_str, const char* achp_addr, bool bop_ipv6)
+{
+    int inl_i;
+    int inrl_a[8];
+    int inl_first_zero;
+    int inl_zero_count;
+    int inl_cur_zero_count;
+
+    if (bop_ipv6) {
+        inl_first_zero = 8;
+        inl_zero_count = 1;
+        inl_cur_zero_count = 0;
+        for (inl_i = 0; inl_i < 8; ++inl_i) {
+            inrl_a[inl_i] = (unsigned char)*achp_addr++;
+            inrl_a[inl_i] <<= 8;
+            inrl_a[inl_i] += (unsigned char)*achp_addr++;
+            if (inrl_a[inl_i] == 0) {
+                ++inl_cur_zero_count;
+            } else {
+                if (inl_cur_zero_count > inl_zero_count) {
+                    inl_first_zero = inl_i - inl_cur_zero_count;
+                    inl_zero_count = inl_cur_zero_count;
+                }
+                inl_cur_zero_count = 0;
+            }
+        }
+        if (inl_cur_zero_count > inl_zero_count) {
+            inl_first_zero = inl_i - inl_cur_zero_count;
+            inl_zero_count = inl_cur_zero_count;
+        }
+
+        *achp_str++ = '[';
+        for (inl_i = 0; inl_i < 8; ++inl_i) {
+            if (inl_i == inl_first_zero) {
+                if (inl_i == 0)
+                    *achp_str++ = ':';
+                *achp_str++ = ':';
+                inl_i += inl_zero_count - 1;
+                if (inl_i == 7)
+                    ++achp_str;
+            } else {
+                achp_str += sprintf(achp_str, "%x:", inrl_a[inl_i]);
+            }
+        }
+        *(achp_str - 1) = ']';
+        *achp_str++ = '\0';
+    } else {
+        for (inl_i = 0; inl_i < 4; ++inl_i) {
+            inrl_a[inl_i] = (unsigned char)*achp_addr++;
+        }
+        achp_str += sprintf(achp_str, "%d.%d.%d.%d\0",
+                            inrl_a[0], inrl_a[1], inrl_a[2], inrl_a[3]);
+    }
+}
+
+void m_htun_new_sess_htcp(struct dsd_tun_start_htcp* adsp_tsh,
+                          struct dsd_tun_contr_conn* adsp_tcc,
+                          struct dsd_tun_contr_ineta* adsp_tci)
+{
+#ifdef TRY_130114
+    adsp_tcc->imc_trace_level = HL_WT_SESS_NETW | HL_WT_CORE_DATA2;
+#endif
+
+    struct dsd_htcp_htun* adsl_hh;
+
+    if ((adsp_tcc->imc_trace_level & HL_WT_SESS_NETW) != 0) {
+        m_do_wsp_trace("SNEHTCSN", 0,
+                       adsp_tcc->imc_sno,
+                       adsp_tcc->imc_trace_level,
+                       NULL, 0, 0,
+                       "HTCP new session.");
+    }
+
+    adsl_hh = (struct dsd_htcp_htun*)malloc(sizeof(struct dsd_htcp_htun));
+    if (adsl_hh == NULL) {
+        m_htun_warning(adsp_tcc, adsp_tci, HTCP_ERR_INTERNAL_ERROR,
+                       "Could not allocate memory for HTCP session.");
+        m_htun_htcp_connect_end(adsp_tcc, adsp_tsh->adsc_server_ineta,
+                                adsp_tsh->ac_free_ti1,
+                                NULL, 0, HTCP_ERR_INTERNAL_ERROR);
+        m_htun_session_end(adsp_tcc, HTCP_ERR_INTERNAL_ERROR);
+        m_htun_htcp_free_resources(adsp_tci);
+        return;
+    }
+
+    adsl_hh->dsc_handle.iec_tunc = ied_tunc_htcp;
+    adsl_hh->dsc_handle.vpc_contr = adsl_hh;
+
+    adsl_hh->adsc_tcc = adsp_tcc;
+    adsl_hh->adsc_tci = adsp_tci;
+
+    adsl_hh->iec_hhs = ied_hhs_connecting;
+
+    adsl_hh->usc_remote_port = adsp_tsh->imc_server_port;
+
+    adsl_hh->boc_sync_running = true;
+    adsl_hh->boc_sync_close = false;
+    adsl_hh->umc_sync_send = 0;
+    adsl_hh->boc_sync_can_recv = false;
+    adsl_hh->adsc_sync_packet = NULL;
+    adsl_hh->boc_sync_timeout = false;
+
+    memset(&adsl_hh->dsc_te, 0, sizeof(adsl_hh->dsc_te));
+    adsl_hh->dsc_te.amc_compl = m_hct_compl;
+    memset(&adsl_hh->dsc_te_closing, 0, sizeof(adsl_hh->dsc_te_closing));
+    adsl_hh->dsc_te_closing.amc_compl = m_hct_compl_closing;
+    adsl_hh->boc_te_closing_free = false;
+
+    adsl_hh->adsc_target_ineta = adsp_tsh->adsc_server_ineta;
+    adsl_hh->ac_free_ti1 = adsp_tsh->ac_free_ti1;
+    adsl_hh->inc_htcp_error = 0;
+    if (adsp_tsh->boc_connect_round_robin) {
+        adsl_hh->inc_target_random_remain =
+            adsp_tsh->adsc_server_ineta->imc_no_ineta;
+        if (adsl_hh->inc_target_random_remain > ins_round_robin_max)
+            adsl_hh->inc_target_random_remain = ins_round_robin_max;
+        // assume two's complement
+        adsl_hh->ulc_target_unused = 1;
+        adsl_hh->ulc_target_unused <<= adsl_hh->inc_target_random_remain;
+        --adsl_hh->ulc_target_unused;
+    } else { // !adsp_tsh->boc_connect_round_robin
+        adsl_hh->inc_target_random_remain = -1;
+        adsl_hh->inc_target_cur = -1;
+    }
+
+    adsl_hh->adsc_sending = NULL;
+    // If adsc_sending is NULL, adsc_sending_tail and achc_sending_tail_end
+    // will not be used.
+    adsl_hh->boc_can_recv = true;
+
+    *(adsp_tsh->adsc_htun_h) = &adsl_hh->dsc_handle;
+
+    m_try_next_address(adsl_hh);
+
+    m_process_sync(adsl_hh);
+}
+
+void m_htcp_sess_close(struct dsd_htcp_htun* adsp_hh)
+{
+    bool bol_running;
+
+    if ((adsp_hh->adsc_tcc->imc_trace_level & HL_WT_SESS_NETW) != 0) {
+        m_do_wsp_trace("SNEHTCSC", 0,
+                       adsp_hh->adsc_tcc->imc_sno,
+                       adsp_hh->adsc_tcc->imc_trace_level,
+                       NULL, 0, 0,
+                       "HTCP being closed by client.");
+    }
+
+    m_htun_critsect_enter(adsp_hh->adsc_tcc);
+    adsp_hh->boc_sync_close = true;
+    bol_running = adsp_hh->boc_sync_running;
+    adsp_hh->boc_sync_running = true;
+    m_htun_critsect_leave(adsp_hh->adsc_tcc);
+
+    if (!bol_running)
+        m_process_sync(adsp_hh);
+}
+
+void m_htcp_sess_send(struct dsd_htcp_htun* adsp_hh,
+                      struct dsd_gather_i_1* adsp_gai1)
+{
+    bool bol_running;
+    uint32_t uml_send;
+    const int inl_trace_size = 16;
+    struct dsd_gather_i_1 dsrl_trace_data[inl_trace_size];
+    struct dsd_gather_i_1* adsl_trace_data;
+    int inl_trace_i;
+
+    m_htun_critsect_enter(adsp_hh->adsc_tcc);
+
+    if ((adsp_hh->adsc_tcc->imc_trace_level & HL_WT_SESS_NETW) != 0) {
+        if (adsp_hh->adsc_sending == NULL) {
+            dsrl_trace_data[0].achc_ginp_cur = NULL;
+            dsrl_trace_data[0].achc_ginp_end = NULL;
+            dsrl_trace_data[0].adsc_next = &dsrl_trace_data[1];
+            adsl_trace_data = adsp_gai1;
+            inl_trace_i = 1;
+        } else {
+            dsrl_trace_data[0].achc_ginp_cur =
+                adsp_hh->achc_sending_tail_end;
+            dsrl_trace_data[0].achc_ginp_end =
+                adsp_hh->adsc_sending_tail->achc_ginp_end;
+            dsrl_trace_data[0].adsc_next = &dsrl_trace_data[1];
+            adsl_trace_data = adsp_hh->adsc_sending_tail->adsc_next;
+            inl_trace_i = 1;
+        }
+        while (inl_trace_i < inl_trace_size && adsl_trace_data != NULL) {
+            if (adsl_trace_data->achc_ginp_cur ==
+                adsl_trace_data->achc_ginp_end) {
+
+                adsl_trace_data = adsl_trace_data->adsc_next;
+                continue;
+            }
+            dsrl_trace_data[inl_trace_i].achc_ginp_cur =
+                adsl_trace_data->achc_ginp_cur;
+            dsrl_trace_data[inl_trace_i].achc_ginp_end =
+                adsl_trace_data->achc_ginp_end;
+            dsrl_trace_data[inl_trace_i].adsc_next =
+                &dsrl_trace_data[inl_trace_i + 1];
+            ++inl_trace_i;
+        }
+        if (inl_trace_i == 0) {
+            dsrl_trace_data[0].achc_ginp_cur = NULL;
+            dsrl_trace_data[0].achc_ginp_end = NULL;
+            dsrl_trace_data[0].adsc_next = NULL;
+        } else {
+            dsrl_trace_data[inl_trace_i - 1].adsc_next = NULL;
+        }
+    }
+
+    if (adsp_hh->adsc_sending == NULL) {
+        if (adsp_gai1 == NULL) {
+            m_htun_critsect_leave(adsp_hh->adsc_tcc);
+            return;
+        }
+
+        adsp_hh->adsc_sending = adsp_gai1;
+        adsp_hh->adsc_sending_tail = adsp_gai1;
+        uml_send = adsp_gai1->achc_ginp_end - adsp_gai1->achc_ginp_cur;
+    } else { // adsp_hh->adsc_sending != NULL
+        uml_send = adsp_hh->adsc_sending_tail->achc_ginp_end -
+            adsp_hh->achc_sending_tail_end;
+    }
+
+    adsp_gai1 = adsp_hh->adsc_sending_tail->adsc_next;
+    while (adsp_gai1 != NULL) {
+        uml_send += adsp_gai1->achc_ginp_end - adsp_gai1->achc_ginp_cur;
+        adsp_hh->adsc_sending_tail = adsp_gai1;
+        adsp_gai1 = adsp_gai1->adsc_next;
+    }
+
+    adsp_hh->achc_sending_tail_end = adsp_hh->adsc_sending_tail->achc_ginp_end;
+
+    if (uml_send > 0) {
+        if ((adsp_hh->adsc_tcc->imc_trace_level & HL_WT_SESS_NETW) != 0) {
+            m_htun_critsect_leave(adsp_hh->adsc_tcc);
+            m_do_wsp_trace("SNEHTCSS", 0,
+                           adsp_hh->adsc_tcc->imc_sno,
+                           adsp_hh->adsc_tcc->imc_trace_level,
+                           dsrl_trace_data, uml_send, 16,
+                           "HTCP sending %d bytes.",
+                           (int)uml_send);
+            m_htun_critsect_enter(adsp_hh->adsc_tcc);
+        }
+
+        adsp_hh->umc_sync_send += uml_send;
+        bol_running = adsp_hh->boc_sync_running;
+        adsp_hh->boc_sync_running = true;
+    }
+    m_htun_critsect_leave(adsp_hh->adsc_tcc);
+
+    if (uml_send > 0 && !bol_running)
+        m_process_sync(adsp_hh);
+}
+
+void m_htcp_sess_canrecv(struct dsd_htcp_htun* adsp_hh)
+{
+    bool bol_running;
+
+    if ((adsp_hh->adsc_tcc->imc_trace_level & HL_WT_SESS_NETW) != 0) {
+        m_do_wsp_trace("SNEHTCSR", 0,
+                       adsp_hh->adsc_tcc->imc_sno,
+                       adsp_hh->adsc_tcc->imc_trace_level,
+                       NULL, 0, 0,
+                       "HTCP can receive data again.");
+    }
+
+    m_htun_critsect_enter(adsp_hh->adsc_tcc);
+    adsp_hh->boc_sync_can_recv = true;
+    bol_running = adsp_hh->boc_sync_running;
+    adsp_hh->boc_sync_running = true;
+    m_htun_critsect_leave(adsp_hh->adsc_tcc);
+
+    if (!bol_running)
+        m_process_sync(adsp_hh);
+}
+
+void m_htcp_packet_from_network(struct dsd_htcp_htun* adsp_hh,
+                                void* ap_handle, unsigned unp_offset,
+                                char* achp_data, unsigned unp_dlen)
+{
+    bool bol_running;
+    struct dsd_htcp_packet* adsl_hp;
+    struct dsd_htcp_packet** aadsl_hp;
+
+    /*
+     * Check if we have enough space for control information.
+     * The struct dsd_htcp_packet contains two inner structures:
+     *   - struct dsd_htcp_packet_control used by xs-htcp-htun-01.cpp and
+     *   - struct dsd_htcp_in_info used by xs-htcp-01.cpp.
+     * The struct dsd_htcp_packet_control must fit completely inside the space
+     * unp_offset before the packet so that it can be filled in immediately.
+     * The struct dsd_htcp_in_info may overflow on the IP header and the first
+     * 20 bytes of the TCP header, xs-htcp-01.cpp makes sure it does not
+     * overwrite any data before the data is used.
+     */
+    if (offsetof(struct dsd_htcp_packet, dsc_hpc) +
+        sizeof(struct dsd_htcp_packet_control) > unp_offset ||
+        sizeof(struct dsd_htcp_packet) > unp_offset + 40) {
+
+        // we need more space
+        m_htun_warning(adsp_hh->adsc_tcc, adsp_hh->adsc_tci,
+                       HTCP_ERR_INTERNAL_ERROR,
+                       "Not enough offset before packet.");
+        m_htun_relrecvbuf(ap_handle);
+        return;
+    }
+
+    adsl_hp = (struct dsd_htcp_packet*)(achp_data - unp_offset);
+    adsl_hp->dsc_hpc.adsc_next = NULL;
+    adsl_hp->dsc_hpc.ac_handle = ap_handle;
+    adsl_hp->dsc_hpc.achc_data = achp_data;
+    adsl_hp->dsc_hpc.umc_len = unp_dlen;
+
+    m_htun_critsect_enter(adsp_hh->adsc_tcc);
+
+    aadsl_hp = &adsp_hh->adsc_sync_packet;
+    while ((*aadsl_hp) != NULL)
+        aadsl_hp = &(*aadsl_hp)->dsc_hpc.adsc_next;
+
+    *aadsl_hp = adsl_hp;
+
+    bol_running = adsp_hh->boc_sync_running;
+    adsp_hh->boc_sync_running = true;
+    m_htun_critsect_leave(adsp_hh->adsc_tcc);
+
+    if (!bol_running)
+        m_process_sync(adsp_hh);
+}
+
+static void m_process_sync(struct dsd_htcp_htun* adsp_hh)
+{
+    bool bol_s_close;
+    uint32_t uml_s_send;
+    bool bol_s_can_recv;
+    struct dsd_htcp_packet* adsl_s_packet;
+    bool bol_s_timeout;
+
+    struct dsd_htcp_packet* adsl_hp;
+    uint32_t uml_len;
+    struct dsd_gather_i_1 dsl_trace_data;
+
+    // boc_sync_running should be set to true before entering this function.
+
+    if ((adsp_hh->adsc_tcc->imc_trace_level & HL_WT_SESS_NETW) != 0) {
+        m_do_wsp_trace("SNEHTCPS", 0,
+                       adsp_hh->adsc_tcc->imc_sno,
+                       adsp_hh->adsc_tcc->imc_trace_level,
+                       NULL, 0, 0,
+                       "HTCP starting processing loop.");
+    }
+
+    for (; ; ) {
+        m_htun_critsect_enter(adsp_hh->adsc_tcc);
+
+        bol_s_close = adsp_hh->boc_sync_close;
+        adsp_hh->boc_sync_close = false;
+
+        uml_s_send = adsp_hh->umc_sync_send;
+        adsp_hh->umc_sync_send = 0;
+
+        bol_s_can_recv = adsp_hh->boc_sync_can_recv;
+        adsp_hh->boc_sync_can_recv = false;
+
+        adsl_s_packet = adsp_hh->adsc_sync_packet;
+        adsp_hh->adsc_sync_packet = NULL;
+
+        bol_s_timeout = adsp_hh->boc_sync_timeout;
+        adsp_hh->boc_sync_timeout = false;
+
+        if (!bol_s_close &&
+            uml_s_send == 0 &&
+            !bol_s_can_recv &&
+            adsl_s_packet == NULL &&
+            !bol_s_timeout) {
+
+            if ((adsp_hh->adsc_tcc->imc_trace_level & HL_WT_SESS_NETW) != 0) {
+                m_htun_critsect_leave(adsp_hh->adsc_tcc);
+                m_do_wsp_trace("SNEHTCPL", 0,
+                               adsp_hh->adsc_tcc->imc_sno,
+                               adsp_hh->adsc_tcc->imc_trace_level,
+                               NULL, 0, 0,
+                               "HTCP leaving processing loop.");
+                m_htun_critsect_enter(adsp_hh->adsc_tcc);
+            }
+
+            adsp_hh->boc_sync_running = false;
+            m_htun_critsect_leave(adsp_hh->adsc_tcc);
+            return;
+        }
+
+        m_htun_critsect_leave(adsp_hh->adsc_tcc);
+
+        if (uml_s_send > 0) {
+            if (adsp_hh->iec_hhs == ied_hhs_connected) {
+                m_htcp_out_send(&adsp_hh->dsc_hc, uml_s_send, true, false);
+            } else {
+                m_htun_warning(adsp_hh->adsc_tcc, adsp_hh->adsc_tci,
+                               HTCP_ERR_INTERNAL_ERROR,
+                               "Ignoring %d outbound bytes in state %d.",
+                               (int)uml_s_send, (int)adsp_hh->iec_hhs);
+            }
+        }
+
+        if (bol_s_can_recv) {
+            adsp_hh->boc_can_recv = true;
+            m_recv_data(adsp_hh);
+        }
+
+        while (adsl_s_packet != NULL) {
+            if (adsp_hh->iec_hhs == ied_hhs_conn_abort ||
+                adsp_hh->iec_hhs == ied_hhs_close_force ||
+                adsp_hh->iec_hhs == ied_hhs_closed) {
+
+                m_htun_warning(adsp_hh->adsc_tcc, adsp_hh->adsc_tci, 1,
+                               "Discarding extra packets in state %d.",
+                               (int)adsp_hh->iec_hhs);
+                do {
+                    adsl_hp = adsl_s_packet;
+                    adsl_s_packet = adsl_hp->dsc_hpc.adsc_next;
+                    m_htun_relrecvbuf(adsl_hp->dsc_hpc.ac_handle);
+                } while (adsl_s_packet != NULL);
+                break;
+            }
+
+            adsl_hp = adsl_s_packet;
+            adsl_s_packet = adsl_s_packet->dsc_hpc.adsc_next;
+
+            /*
+             * Note: we can assume that any packet that arrives here has an IP
+             * header, at least twenty more bytes and a TCP protocol field.
+             */
+
+            if (adsp_hh->boc_ipv6) {
+                uml_len = 40;
+                if (m_get_ip6_version(adsl_hp->dsc_hpc.achc_data) == 6 &&
+                    memcmp(m_get_ip6_src_addr(adsl_hp->dsc_hpc.achc_data),
+                           adsp_hh->chrc_remote_addr, 16) == 0 &&
+                    memcmp(m_get_ip6_dst_addr(adsl_hp->dsc_hpc.achc_data),
+                           adsp_hh->chrc_local_addr, 16) == 0) {
+
+                    adsl_hp->dsc_hpc.achc_data += uml_len;
+                    uml_len = adsl_hp->dsc_hpc.umc_len - uml_len;
+                    adsl_hp->dsc_hpc.umc_len = uml_len;
+                }else {
+                    uml_len = 0;
+                }
+            } else { // IPv4
+                uml_len = m_get_calc_ip_hlen(adsl_hp->dsc_hpc.achc_data);
+                if (m_get_ip_version(adsl_hp->dsc_hpc.achc_data) == 4 &&
+                    memcmp(m_get_ip_src_addr_buf(adsl_hp->dsc_hpc.achc_data),
+                           adsp_hh->chrc_remote_addr, 4) == 0 &&
+                    memcmp(m_get_ip_dst_addr_buf(adsl_hp->dsc_hpc.achc_data),
+                           adsp_hh->chrc_local_addr, 4) == 0) {
+
+                    adsl_hp->dsc_hpc.achc_data += uml_len;
+                    uml_len = adsl_hp->dsc_hpc.umc_len - uml_len;
+                    adsl_hp->dsc_hpc.umc_len = uml_len;
+                }else {
+                    uml_len = 0;
+                }
+            }
+
+            if (uml_len > 0) {
+                if ((adsp_hh->adsc_tcc->imc_trace_level & HL_WT_SESS_NETW)
+                    != 0) {
+
+                    dsl_trace_data.achc_ginp_cur = adsl_hp->dsc_hpc.achc_data;
+                    dsl_trace_data.achc_ginp_end =
+                        dsl_trace_data.achc_ginp_cur + adsl_hp->dsc_hpc.umc_len;
+                    dsl_trace_data.adsc_next = NULL;
+                    m_do_wsp_trace("SNEHTCNR", 0,
+                                   adsp_hh->adsc_tcc->imc_sno,
+                                   adsp_hh->adsc_tcc->imc_trace_level,
+                                   &dsl_trace_data, uml_len, 32,
+                                   "HTCP received %d-byte segment %p.",
+                                   (int)adsl_hp->dsc_hpc.umc_len,
+                                   &adsl_hp->dsc_hii);
+                }
+
+                m_htcp_in_packet(&adsp_hh->dsc_hc, &adsl_hp->dsc_hii, uml_len);
+            } else {
+                // discard incorrectly routed packet
+                m_htun_relrecvbuf(adsl_hp->dsc_hpc.ac_handle);
+            }
+        }
+
+        if (bol_s_timeout) {
+            m_htcp_timeout(&adsp_hh->dsc_hc);
+        }
+
+        if (bol_s_close) {
+            switch (adsp_hh->iec_hhs) {
+            case ied_hhs_connecting:
+                adsp_hh->iec_hhs = ied_hhs_conn_abort;
+
+                m_htun_htcp_connect_end(adsp_hh->adsc_tcc,
+                                        adsp_hh->adsc_target_ineta,
+                                        adsp_hh->ac_free_ti1,
+                                        NULL, 0, HTCP_ERR_CANCELLED);
+
+                // m_htun_session_end() and m_free_resources() will be called
+                // inside m_hcb_closed().
+
+                m_htcp_abort(&adsp_hh->dsc_hc, false);
+                break;
+
+            case ied_hhs_connected:
+                adsp_hh->iec_hhs = ied_hhs_close;
+                m_htcp_out_send(&adsp_hh->dsc_hc, 0, false, true);
+                // Give session one minute to close gracefully before resetting.
+                adsp_hh->dsc_te_closing.ilcwaitmsec = 60000;
+                m_time_set(&adsp_hh->dsc_te_closing, FALSE);
+                break;
+
+            case ied_hhs_close:
+                adsp_hh->iec_hhs = ied_hhs_close_force;
+                m_htun_warning(NULL, adsp_hh->adsc_tci, 1,
+                               "HTCP session not closed in time, aborting.");
+                m_htcp_abort(&adsp_hh->dsc_hc, true);
+                break;
+
+            case ied_hhs_end:
+                // Race condition, already should have called
+                // m_htun_session_end(). Ignore.
+                break;
+
+            case ied_hhs_closed:
+                // Race condition, received RST while timeout signalled us
+                // to stop graceful wait and abort. We already aborted, so
+                // do nothing here.
+                break;
+
+            default:
+                // Should not arrive here. Display error message and ignore.
+                m_htun_warning(adsp_hh->adsc_tcc, adsp_hh->adsc_tci,
+                               HTCP_ERR_INTERNAL_ERROR,
+                               "Internal HTCP error at "
+                               "xs-htcp-htun-01.cpp:%d - state=%d.",
+                               __LINE__, (int)adsp_hh->iec_hhs);
+            }
+        }
+    }
+}
+
+static void m_try_next_address(struct dsd_htcp_htun* adsp_hh)
+{
+    int inl_next;
+    int inl_index;
+    int inl_i;
+    uint64_t ull_cur_bit;
+    struct dsd_ineta_single_1* adsl_target;
+    char* achl_bound;
+    uint16_t usl_chksum;
+    struct sockaddr_in dsl_sai;
+    struct sockaddr_in6 dsl_sai6;
+    char chrl_trace_addr[42];
+
+    while (adsp_hh->inc_target_random_remain >= 0 ||
+           adsp_hh->inc_target_cur + 1 <
+           adsp_hh->adsc_target_ineta->imc_no_ineta) {
+
+        // First get next address form list.
+        if (adsp_hh->inc_target_random_remain == 0) {
+            if (ins_round_robin_max >= adsp_hh->adsc_target_ineta->imc_no_ineta)
+                break;
+            inl_index = ins_round_robin_max;
+            adsp_hh->inc_target_cur = inl_index;
+        } else if (adsp_hh->inc_target_random_remain > 0) {
+            inl_next = m_get_random_number(adsp_hh->inc_target_random_remain);
+            --adsp_hh->inc_target_random_remain;
+
+            ++inl_next;
+            inl_index = 0;
+            ull_cur_bit = 1;
+            do {
+                while ((adsp_hh->ulc_target_unused & ull_cur_bit) == 0) {
+                    ++inl_index;
+                    ull_cur_bit <<= 1;
+                }
+
+                if (inl_index >= ins_round_robin_max) {
+                    // internal error
+                    m_htun_warning(adsp_hh->adsc_tcc, adsp_hh->adsc_tci,
+                                   HTCP_ERR_INTERNAL_ERROR,
+                                   "Internal HTCP error at "
+                                   "xs-htcp-htun-01.cpp:%d.",
+                                   __LINE__);
+                    m_htun_htcp_connect_end(adsp_hh->adsc_tcc,
+                                            adsp_hh->adsc_target_ineta,
+                                            adsp_hh->ac_free_ti1,
+                                            NULL, 0, HTCP_ERR_INTERNAL_ERROR);
+                    m_htun_session_end(adsp_hh->adsc_tcc,
+                                       HTCP_ERR_INTERNAL_ERROR);
+                    m_free_resources(adsp_hh);
+                    return;
+                }
+
+                --inl_next;
+                ++inl_index;
+                ull_cur_bit <<= 1;
+            } while (inl_next > 0);
+            --inl_index;
+            adsp_hh->ulc_target_unused ^= ull_cur_bit >> 1;
+            /*
+             * Note that the above code would fail to clear bit 64, but this is
+             * not a problem since bit 64 should not be probed more than once.
+             */
+            adsp_hh->inc_target_cur = inl_index;
+        } else { // adsp_hh->inc_target_random_remain < 0
+            inl_index = adsp_hh->inc_target_cur + 1;
+            adsp_hh->inc_target_cur = inl_index;
+        }
+        // We now have the index of the next address form list.
+
+        /*
+         * Note: we can cache the current location, but it is not really
+         * necessary since it only saves a very small amount of time while
+         * setting up the connection. On the other hand, it would add memory
+         * overhead for each active connection.
+         */
+        achl_bound = (char*)adsp_hh->adsc_target_ineta +
+            adsp_hh->adsc_target_ineta->imc_len_mem;
+        adsl_target = (struct dsd_ineta_single_1*)
+            (adsp_hh->adsc_target_ineta + 1);
+        for (inl_i = 0; inl_i < inl_index; ++inl_i) {
+            if ((char*)(adsl_target + 1) > achl_bound)
+                break;
+            adsl_target = (dsd_ineta_single_1*)
+                ((char*)(adsl_target + 1) + adsl_target->usc_length);
+        }
+        if ((char*)(adsl_target + 1) > achl_bound ||
+            ((char*)(adsl_target + 1) + adsl_target->usc_length) > achl_bound) {
+
+            m_htun_warning(adsp_hh->adsc_tcc, adsp_hh->adsc_tci,
+                           HTCP_ERR_INTERNAL_ERROR,
+                           "Target address %d beyond "
+                           "ds_target_ineta.imc_len_mem.",
+                           inl_index);
+            m_htun_htcp_connect_failed(adsp_hh->adsc_tcc, NULL, 0, inl_index,
+                                       adsp_hh->adsc_target_ineta->imc_no_ineta,
+                                       HTCP_ERR_INTERNAL_ERROR);
+
+            // try next address
+            continue;
+        }
+
+        if (adsl_target->usc_family == AF_INET &&
+            adsl_target->usc_length == 4 &&
+            adsp_hh->adsc_tci->dsc_soa_local_ipv4.sin_family == AF_INET) {
+
+            adsp_hh->boc_ipv6 = false;
+
+            memcpy(adsp_hh->chrc_local_addr,
+                   &adsp_hh->adsc_tci->dsc_soa_local_ipv4.sin_addr.s_addr, 4);
+            memcpy(adsp_hh->chrc_remote_addr, adsl_target + 1, 4);
+            adsp_hh->usc_local_port =
+                ntohs(adsp_hh->adsc_tci->dsc_soa_local_ipv4.sin_port);
+
+            usl_chksum = m_calc_tcp_data_chksum(adsp_hh->chrc_local_addr, 4, 6);
+            usl_chksum = m_calc_tcp_data_chksum(adsp_hh->chrc_remote_addr, 4,
+                                                usl_chksum);
+
+        } else if (adsl_target->usc_family == AF_INET6 &&
+                   adsl_target->usc_length == 16 &&
+                   adsp_hh->adsc_tci->dsc_soa_local_ipv6.sin6_family ==
+                   AF_INET6) {
+
+            adsp_hh->boc_ipv6 = true;
+
+            memcpy(adsp_hh->chrc_local_addr,
+                   &adsp_hh->adsc_tci->dsc_soa_local_ipv6.sin6_addr.s6_addr,
+                   16);
+            memcpy(adsp_hh->chrc_remote_addr, adsl_target + 1, 16);
+            adsp_hh->usc_local_port =
+                ntohs(adsp_hh->adsc_tci->dsc_soa_local_ipv6.sin6_port);
+
+            usl_chksum = m_calc_tcp_data_chksum(adsp_hh->chrc_local_addr, 16,
+                                                6);
+            usl_chksum = m_calc_tcp_data_chksum(adsp_hh->chrc_remote_addr, 16,
+                                                usl_chksum);
+        } else {
+
+            if (adsl_target->usc_family == AF_INET &&
+                adsl_target->usc_length == 4) {
+
+                m_htun_warning(adsp_hh->adsc_tcc, adsp_hh->adsc_tci,
+                               HTCP_ERR_INTERNAL_ERROR,
+                               "Connection has no local IPv4 address.");
+
+                memset(&dsl_sai, 0, sizeof(dsl_sai));
+                dsl_sai.sin_family = AF_INET;
+                dsl_sai.sin_port = htons(adsp_hh->usc_remote_port);
+                memcpy(&dsl_sai.sin_addr.s_addr, adsl_target + 1, 4);
+
+                m_htun_htcp_connect_failed(adsp_hh->adsc_tcc,
+                                           (struct sockaddr*)&dsl_sai,
+                                           sizeof(dsl_sai),
+                                           inl_index, adsp_hh->
+                                           adsc_target_ineta->imc_no_ineta,
+                                           HTCP_ERR_INTERNAL_ERROR);
+            } else if (adsl_target->usc_family == AF_INET6 &&
+                       adsl_target->usc_length == 16) {
+
+                m_htun_warning(adsp_hh->adsc_tcc, adsp_hh->adsc_tci,
+                               HTCP_ERR_INTERNAL_ERROR,
+                               "Connection has no local IPv6 address.");
+
+                memset(&dsl_sai6, 0, sizeof(dsl_sai6));
+                dsl_sai6.sin6_family = AF_INET6;
+                dsl_sai6.sin6_port = htons(adsp_hh->usc_remote_port);
+                memcpy(&dsl_sai6.sin6_addr.s6_addr, adsl_target + 1, 16);
+
+                m_htun_htcp_connect_failed(adsp_hh->adsc_tcc,
+                                           (struct sockaddr*)&dsl_sai6,
+                                           sizeof(dsl_sai6),
+                                           inl_index, adsp_hh->
+                                           adsc_target_ineta->imc_no_ineta,
+                                           HTCP_ERR_INTERNAL_ERROR);
+            } else {
+                m_htun_warning(adsp_hh->adsc_tcc, adsp_hh->adsc_tci,
+                               HTCP_ERR_INTERNAL_ERROR,
+                               "Cannot recognize target address.");
+
+                m_htun_htcp_connect_failed(adsp_hh->adsc_tcc, NULL, 0,
+                                           inl_index, adsp_hh->
+                                           adsc_target_ineta->imc_no_ineta,
+                                           HTCP_ERR_INTERNAL_ERROR);
+            }
+
+            // try next address
+            continue;
+        }
+
+        // we have found a valid address - attempt to connect
+
+        if ((adsp_hh->adsc_tcc->imc_trace_level & HL_WT_SESS_NETW) != 0) {
+            m_print_addr(chrl_trace_addr,
+                         adsp_hh->chrc_remote_addr, adsp_hh->boc_ipv6);
+            m_do_wsp_trace("SNEHTCCA", 0,
+                           adsp_hh->adsc_tcc->imc_sno,
+                           adsp_hh->adsc_tcc->imc_trace_level,
+                           NULL, 0, 0,
+                           "HTCP attempting to connect to %s:%d.",
+                           chrl_trace_addr, (int)adsp_hh->usc_remote_port);
+        }
+
+        m_htcp_init(&adsp_hh->dsc_hc, NULL, &dss_hcb, usl_chksum,
+                    adsp_hh->usc_local_port, adsp_hh->usc_remote_port);
+        m_htcp_out_send(&adsp_hh->dsc_hc, 0, false, false);
+        return;
+    }
+
+    // no more addresses
+
+    if ((adsp_hh->adsc_tcc->imc_trace_level & HL_WT_SESS_NETW) != 0) {
+        m_do_wsp_trace("SNEHTCCF", 0,
+                       adsp_hh->adsc_tcc->imc_sno,
+                       adsp_hh->adsc_tcc->imc_trace_level,
+                       NULL, 0, 0,
+                       "HTCP found no server available.");
+    }
+
+    if (adsp_hh->inc_htcp_error == 0)
+        adsp_hh->inc_htcp_error = HTCP_ERR_CANCELLED;
+    m_htun_htcp_connect_end(adsp_hh->adsc_tcc,
+                            adsp_hh->adsc_target_ineta,
+                            adsp_hh->ac_free_ti1,
+                            NULL, 0, adsp_hh->inc_htcp_error);
+    m_htun_session_end(adsp_hh->adsc_tcc, adsp_hh->inc_htcp_error);
+    m_free_resources(adsp_hh);
+}
+
+static void m_recv_data(struct dsd_htcp_htun* adsp_hh)
+{
+    struct dsd_htcp_in_info* adsl_hii;
+    uint32_t uml_offset;
+    uint32_t uml_len;
+    bool bol_push;
+    bool bol_eof;
+    bool bol_more;
+    const int inl_bve_size = 8;
+    struct dsd_buf_vector_ele dsrl_bve[inl_bve_size];
+    int inl_bve_index;
+    struct dsd_htcp_packet* adsl_hp;
+    struct dsd_gather_i_1 dsl_trace_data;
+
+    inl_bve_index = 0;
+    do {
+        m_htcp_in_get_data(&adsp_hh->dsc_hc, &adsl_hii, &uml_offset, &uml_len,
+                           &bol_push, &bol_eof, &bol_more, false);
+
+        if (adsl_hii == NULL)
+            break;
+        adsl_hp = (struct dsd_htcp_packet*)
+            ((char*)adsl_hii - offsetof(struct dsd_htcp_packet, dsc_hii));
+
+        if ((adsp_hh->adsc_tcc->imc_trace_level & HL_WT_SESS_NETW) != 0) {
+            dsl_trace_data.achc_ginp_cur =
+                adsl_hp->dsc_hpc.achc_data + uml_offset;
+            dsl_trace_data.achc_ginp_end =
+                dsl_trace_data.achc_ginp_cur + uml_len;
+            dsl_trace_data.adsc_next = NULL;
+            m_do_wsp_trace("SNEHTCHD", 0,
+                           adsp_hh->adsc_tcc->imc_sno,
+                           adsp_hh->adsc_tcc->imc_trace_level,
+                           &dsl_trace_data, uml_len, 16,
+                           "HTCP obtained %d bytes from segment %p.",
+                           (int)uml_len, adsl_hii);
+        }
+
+        dsrl_bve[inl_bve_index].ac_handle = adsl_hp->dsc_hpc.ac_handle;
+        dsrl_bve[inl_bve_index].achc_data =
+            adsl_hp->dsc_hpc.achc_data + uml_offset;
+        dsrl_bve[inl_bve_index].imc_len_data = uml_len;
+        ++inl_bve_index;
+
+        if (inl_bve_index == inl_bve_size) {
+            if (adsp_hh->iec_hhs != ied_hhs_connected)
+                break;
+            inl_bve_index = 0;
+            if (!m_se_htun_recvbuf(adsp_hh->adsc_tcc, dsrl_bve, inl_bve_size)) {
+                if ((adsp_hh->adsc_tcc->imc_trace_level & HL_WT_SESS_NETW)
+                    != 0) {
+
+                    m_do_wsp_trace("SNEHTCSB", 0,
+                                   adsp_hh->adsc_tcc->imc_sno,
+                                   adsp_hh->adsc_tcc->imc_trace_level,
+                                   NULL, 0, 0,
+                                   "HTCP can no longer receive data.");
+                }
+
+                adsp_hh->boc_can_recv = false;
+                break;
+            }
+        }
+    } while (bol_more);
+
+    if (inl_bve_index > 0) {
+        if (adsp_hh->iec_hhs != ied_hhs_connected) {
+            // free all data and abort HTCP
+            while (inl_bve_index > 0) {
+                --inl_bve_index;
+                m_htun_relrecvbuf(dsrl_bve[inl_bve_index].ac_handle);
+            }
+
+            // there is no need to get any more data for freeing -
+            // HTCP will free the data itself
+
+            m_htun_warning(adsp_hh->adsc_tcc, adsp_hh->adsc_tci,
+                           HTCP_ERR_SESS_END_RST,
+                           "Received unwanted data.");
+            m_htcp_abort(&adsp_hh->dsc_hc, true);
+            return;
+        }
+
+        if (!m_se_htun_recvbuf(adsp_hh->adsc_tcc, dsrl_bve, inl_bve_index)) {
+            adsp_hh->boc_can_recv = false;
+        }
+    }
+
+    if (bol_eof) {
+        if ((adsp_hh->adsc_tcc->imc_trace_level & HL_WT_SESS_NETW) != 0) {
+            m_do_wsp_trace("SNEHTCHF", 0,
+                           adsp_hh->adsc_tcc->imc_sno,
+                           adsp_hh->adsc_tcc->imc_trace_level,
+                           &dsl_trace_data, uml_len, 16,
+                           "HTCP received end of connection indication.");
+        }
+
+        switch (adsp_hh->iec_hhs) {
+        case ied_hhs_connected:
+            adsp_hh->iec_hhs = ied_hhs_end;
+            m_htun_session_end(adsp_hh->adsc_tcc, 0);
+            m_htcp_out_send(&adsp_hh->dsc_hc, 0, false, true);
+            break;
+
+        case ied_hhs_close:
+            if (!m_time_rel(&adsp_hh->dsc_te_closing)) {
+                // Did not stop timer in time, so just ignore received FIN and
+                // allow timer to take us to ied_hhs_close_force.
+                break;
+            }
+            adsp_hh->iec_hhs = ied_hhs_time_wait;
+            break;
+
+        case ied_hhs_close_force:
+            // Too late now, already aborting.
+            break;
+
+        default:
+            // should not arrive here
+            m_htun_warning(adsp_hh->adsc_tcc, adsp_hh->adsc_tci,
+                           HTCP_ERR_INTERNAL_ERROR,
+                           "Received FIN in unexpected state - %d.",
+                           (int)adsp_hh->iec_hhs);
+        }
+    }
+}
+
+static void m_free_resources(struct dsd_htcp_htun* adsp_hh)
+{
+    struct dsd_gather_i_1* adsl_gai1;
+
+    // xs-htcp-01.cpp should have freed all packets in out-of-order queue
+
+    while (adsp_hh->adsc_sending != NULL) {
+        adsl_gai1 = adsp_hh->adsc_sending;
+        adsp_hh->adsc_sending = adsl_gai1->adsc_next;
+        adsl_gai1->achc_ginp_cur = adsl_gai1->achc_ginp_end;
+    }
+
+    adsp_hh->iec_hhs = ied_hhs_closed;
+    m_htun_htcp_free_resources(adsp_hh->adsc_tci);
+
+    // wait for a minute before freeing memory
+    adsp_hh->dsc_te_closing.ilcwaitmsec = 60000;
+    m_time_set(&adsp_hh->dsc_te_closing, FALSE);
+    adsp_hh->boc_te_closing_free = true;
+}
+
+static void m_hct_compl(struct dsd_timer_ele* adsp_te)
+{
+    struct dsd_htcp_htun* adsl_hh = (struct dsd_htcp_htun*)
+        ((char*)adsp_te - offsetof(struct dsd_htcp_htun, dsc_te));
+    bool bol_running;
+
+    if ((adsl_hh->adsc_tcc->imc_trace_level & HL_WT_SESS_NETW) != 0) {
+        m_do_wsp_trace("SNEHTCTO", 0,
+                       adsl_hh->adsc_tcc->imc_sno,
+                       adsl_hh->adsc_tcc->imc_trace_level,
+                       NULL, 0, 0,
+                       "HTCP timeout.");
+    }
+
+    m_htun_critsect_enter(adsl_hh->adsc_tcc);
+    adsl_hh->boc_sync_timeout = true;
+    bol_running = adsl_hh->boc_sync_running;
+    adsl_hh->boc_sync_running = true;
+    m_htun_critsect_leave(adsl_hh->adsc_tcc);
+
+    if (!bol_running)
+        m_process_sync(adsl_hh);
+}
+
+static void m_hct_compl_closing(struct dsd_timer_ele* adsp_te)
+{
+    struct dsd_htcp_htun* adsl_hh = (struct dsd_htcp_htun*)
+        ((char*)adsp_te - offsetof(struct dsd_htcp_htun, dsc_te_closing));
+    bool bol_running;
+
+    /*
+     * This timer only set in two places:
+     * 1. After receiving m_htun_sess_close(), to give the session enough time
+     *    for graceful closing before sending RST.
+     * 2. When a session is ended completely, so that adsl_hh is freed.
+     * Case 2. will have adsl_hh->boc_te_closing_free set to true.
+     */
+
+    if ((adsl_hh->adsc_tcc->imc_trace_level & HL_WT_SESS_NETW) != 0) {
+        m_do_wsp_trace("SNEHTCTC", 0,
+                       adsl_hh->adsc_tcc->imc_sno,
+                       adsl_hh->adsc_tcc->imc_trace_level,
+                       NULL, 0, 0,
+                       (adsl_hh->boc_te_closing_free ?
+                        "HTCP timeout - freeing." :
+                        "HTCP timeout - forcing close."));
+    }
+
+    if (adsl_hh->boc_te_closing_free) {
+        free(adsl_hh);
+    } else {
+        m_htun_critsect_enter(adsl_hh->adsc_tcc);
+        adsl_hh->boc_sync_close = true;
+        bol_running = adsl_hh->boc_sync_running;
+        adsl_hh->boc_sync_running = true;
+        m_htun_critsect_leave(adsl_hh->adsc_tcc);
+
+        if (!bol_running)
+            m_process_sync(adsl_hh);
+    }
+}
+
+static bool m_hcb_out_get(struct dsd_htcp_conn* adsp_hc,
+                          uint32_t ump_offset,
+                          const char** aachp_buf, uint32_t* aump_len)
+{
+    struct dsd_htcp_htun* adsl_hh = (struct dsd_htcp_htun*)
+        ((char*)adsp_hc - offsetof(struct dsd_htcp_htun, dsc_hc));
+    struct dsd_gather_i_1* adsl_gai1;
+
+    adsl_gai1 = adsl_hh->adsc_sending;
+
+    while (adsl_gai1 != NULL) {
+        if (adsl_gai1->achc_ginp_cur + ump_offset < adsl_gai1->achc_ginp_end) {
+            *aachp_buf = adsl_gai1->achc_ginp_cur + ump_offset;
+            *aump_len = adsl_gai1->achc_ginp_end - *aachp_buf;
+            return true;
+        }
+        ump_offset -= adsl_gai1->achc_ginp_end - adsl_gai1->achc_ginp_cur;
+        adsl_gai1 = adsl_gai1->adsc_next;
+    }
+
+    if (ump_offset == 0) {
+        *aachp_buf = NULL;
+        *aump_len = 0;
+        return true;
+    }
+
+    m_htun_warning(adsl_hh->adsc_tcc, adsl_hh->adsc_tci,
+                   HTCP_ERR_INTERNAL_ERROR,
+                   "Internal HTCP error at at xs-htcp-htun-01.cpp:%d.",
+                   __LINE__);
+    return false;
+}
+
+static bool m_hcb_out_packets(struct dsd_htcp_conn* adsp_hc)
+{
+    struct dsd_htcp_htun* adsl_hh = (struct dsd_htcp_htun*)
+        ((char*)adsp_hc - offsetof(struct dsd_htcp_htun, dsc_hc));
+    char chrl_header[100]; // 40 for IP, 60 for TCP
+    uint32_t uml_hlen;
+    uint32_t uml_offset;
+    uint32_t uml_len;
+    bool bol_more;
+    struct dsd_gather_i_1 dsl_g_header;
+    struct dsd_gather_i_1 dsl_g_data;
+    struct dsd_gather_i_1* adsl_gai1;
+    uint32_t uml_len_test;
+    struct dsd_gather_i_1* adsl_gai1_test;
+    int inl_trace_offset;
+    struct dsd_gather_i_1 dsl_trace_data;
+
+    do {
+        uml_hlen = 60;
+        m_htcp_out_get_packet(adsp_hc, chrl_header + 40, &uml_hlen,
+                              &uml_offset, &uml_len, &bol_more);
+        if (uml_hlen == 0)
+            break;
+
+        if (adsl_hh->boc_ipv6) {
+            m_set_ip6_version(chrl_header, 6);
+            m_set_ip6_tcls(chrl_header, 0);
+            m_set_ip6_flow(chrl_header, 0);
+            m_set_ip6_plen(chrl_header, uml_hlen + uml_len);
+            m_set_ip6_nh(chrl_header, 6);
+            m_set_ip6_hlim(chrl_header, 128);
+            m_set_ip6_src_addr(chrl_header, adsl_hh->chrc_local_addr);
+            m_set_ip6_dst_addr(chrl_header, adsl_hh->chrc_remote_addr);
+
+            uml_hlen += 40;
+            dsl_g_header.achc_ginp_cur = chrl_header;
+            dsl_g_header.achc_ginp_end = chrl_header + uml_hlen;
+        } else {
+            m_set_ip_version(chrl_header + 20, 4);
+            m_set_calc_ip_hlen(chrl_header + 20, 20);
+            m_set_ip_tos(chrl_header + 20, 0);
+            m_set_ip_tlen(chrl_header + 20, 20 + uml_hlen + uml_len);
+            m_set_ip_id(chrl_header + 20, 0);
+            m_set_ip_flags(chrl_header + 20, 0);
+            m_set_ip_df(chrl_header + 20, 1);
+            m_set_calc_ip_fofs(chrl_header + 20, 0);
+            m_set_ip_ttl(chrl_header + 20, 128);
+            m_set_ip_prot(chrl_header + 20, 6);
+            m_set_ip_src_addr_buf(chrl_header + 20, adsl_hh->chrc_local_addr);
+            m_set_ip_dst_addr_buf(chrl_header + 20, adsl_hh->chrc_remote_addr);
+            m_set_ip_chksum(chrl_header + 20,
+                            m_calc_ip_chksum(chrl_header + 20));
+
+            uml_hlen += 20;
+            dsl_g_header.achc_ginp_cur = chrl_header + 20;
+            dsl_g_header.achc_ginp_end = chrl_header + 20 + uml_hlen;
+        }
+
+        if (uml_len == 0) {
+            dsl_g_header.adsc_next = NULL;
+        } else {
+            dsl_g_header.adsc_next = &dsl_g_data;
+
+            adsl_gai1 = adsl_hh->adsc_sending;
+            while (adsl_gai1 != NULL) {
+                if (adsl_gai1->achc_ginp_cur + uml_offset <
+                    adsl_gai1->achc_ginp_end) {
+
+                    break;
+                }
+                uml_offset -= adsl_gai1->achc_ginp_end -
+                    adsl_gai1->achc_ginp_cur;
+                adsl_gai1 = adsl_gai1->adsc_next;
+            }
+
+            adsl_gai1_test = adsl_gai1;
+            uml_len_test = uml_offset + uml_len;
+            while (adsl_gai1_test != NULL) {
+                if (adsl_gai1_test->achc_ginp_cur + uml_len_test <
+                    adsl_gai1_test->achc_ginp_end) {
+
+                    break;
+                }
+                uml_len_test -= adsl_gai1_test->achc_ginp_end -
+                    adsl_gai1_test->achc_ginp_cur;
+                adsl_gai1_test = adsl_gai1_test->adsc_next;
+            }
+
+            if (adsl_gai1_test == NULL && uml_len_test > 0) {
+                m_htun_warning(adsl_hh->adsc_tcc, adsl_hh->adsc_tci,
+                               HTCP_ERR_INTERNAL_ERROR,
+                               "Internal HTCP error at xs-htcp-htun-01.cpp:%d.",
+                               __LINE__);
+                return false;
+            }
+
+            dsl_g_data.achc_ginp_cur = adsl_gai1->achc_ginp_cur + uml_offset;
+            dsl_g_data.achc_ginp_end = adsl_gai1->achc_ginp_end;
+            dsl_g_data.adsc_next = adsl_gai1->adsc_next;
+        }
+
+        if ((adsl_hh->adsc_tcc->imc_trace_level & HL_WT_SESS_NETW) != 0) {
+            if (adsl_hh->boc_ipv6)
+                inl_trace_offset = 40;
+            else
+                inl_trace_offset = 20;
+            dsl_trace_data.achc_ginp_cur =
+                dsl_g_header.achc_ginp_cur + inl_trace_offset;
+            dsl_trace_data.achc_ginp_end = dsl_g_header.achc_ginp_end;
+            dsl_trace_data.adsc_next = dsl_g_header.adsc_next;
+            m_do_wsp_trace("SNEHTCNS", 0,
+                           adsl_hh->adsc_tcc->imc_sno,
+                           adsl_hh->adsc_tcc->imc_trace_level,
+                           &dsl_trace_data,
+                           uml_hlen + uml_len - inl_trace_offset, 32,
+                           "HTCP sending %d-byte segment.",
+                           (int)(uml_hlen + uml_len - inl_trace_offset));
+        }
+
+        m_se_husip_send_gather(&dsl_g_header, uml_hlen + uml_len);
+
+    } while (bol_more);
+
+    return true;
+}
+
+static bool m_hcb_out_ack(struct dsd_htcp_conn* adsp_hc, uint32_t ump_len)
+{
+    struct dsd_htcp_htun* adsl_hh = (struct dsd_htcp_htun*)
+        ((char*)adsp_hc - offsetof(struct dsd_htcp_htun, dsc_hc));
+    struct dsd_gather_i_1* adsl_gai1;
+
+    if ((adsl_hh->adsc_tcc->imc_trace_level & HL_WT_SESS_NETW) != 0) {
+        m_do_wsp_trace("SNEHTCHA", 0,
+                       adsl_hh->adsc_tcc->imc_sno,
+                       adsl_hh->adsc_tcc->imc_trace_level,
+                       NULL, 0, 0,
+                       "HTCP releasing %d acknowledged bytes.",
+                       (int)(ump_len));
+    }
+
+    m_htun_critsect_enter(adsl_hh->adsc_tcc);
+
+    adsl_gai1 = adsl_hh->adsc_sending;
+    while (adsl_gai1 != NULL) {
+        if (adsl_gai1->achc_ginp_cur + ump_len < adsl_gai1->achc_ginp_end) {
+            adsl_gai1->achc_ginp_cur += ump_len;
+            m_htun_critsect_leave(adsl_hh->adsc_tcc);
+            m_htun_htcp_send_complete(adsl_hh->adsc_tcc);
+            return true;
+        }
+        adsl_hh->adsc_sending = adsl_gai1->adsc_next;
+        ump_len -= adsl_gai1->achc_ginp_end - adsl_gai1->achc_ginp_cur;
+        adsl_gai1->achc_ginp_cur = adsl_gai1->achc_ginp_end;
+        adsl_gai1 = adsl_hh->adsc_sending;
+    }
+
+    m_htun_critsect_leave(adsl_hh->adsc_tcc);
+
+    if (ump_len > 0) {
+        m_htun_warning(adsl_hh->adsc_tcc, adsl_hh->adsc_tci,
+                       HTCP_ERR_INTERNAL_ERROR,
+                       "Internal HTCP error at xs-htcp-htun-01.cpp:%d.",
+                       __LINE__);
+        return false;
+    }
+    return true;
+}
+
+static bool m_hcb_in_get(struct dsd_htcp_conn* adsp_hc,
+                         struct dsd_htcp_in_info* adsp_hii,
+                         uint32_t ump_offset,
+                         const char** aachp_buf, uint32_t* aump_len)
+{
+    struct dsd_htcp_htun* adsl_hh = (struct dsd_htcp_htun*)
+        ((char*)adsp_hc - offsetof(struct dsd_htcp_htun, dsc_hc));
+    struct dsd_htcp_packet* adsl_hp = (struct dsd_htcp_packet*)
+        ((char*)adsp_hii - offsetof(struct dsd_htcp_packet, dsc_hii));
+
+    if (ump_offset > adsl_hp->dsc_hpc.umc_len) {
+        m_htun_warning(adsl_hh->adsc_tcc, adsl_hh->adsc_tci,
+                       HTCP_ERR_INTERNAL_ERROR,
+                       "Internal HTCP error at xs-htcp-htun-01.cpp:%d.",
+                       __LINE__);
+        return false;
+    }
+
+    *aachp_buf = adsl_hp->dsc_hpc.achc_data + ump_offset;
+    *aump_len = adsl_hp->dsc_hpc.umc_len - ump_offset;
+    return true;
+}
+
+static bool m_hcb_in_more_data(struct dsd_htcp_conn* adsp_hc)
+{
+    struct dsd_htcp_htun* adsl_hh = (struct dsd_htcp_htun*)
+        ((char*)adsp_hc - offsetof(struct dsd_htcp_htun, dsc_hc));
+
+    if (adsl_hh->boc_can_recv)
+        m_recv_data(adsl_hh);
+
+    return true;
+}
+
+static bool m_hcb_in_rel(struct dsd_htcp_conn* adsp_hc,
+                         struct dsd_htcp_in_info* adsp_hii)
+{
+    struct dsd_htcp_htun* adsl_hh = (struct dsd_htcp_htun*)
+        ((char*)adsp_hc - offsetof(struct dsd_htcp_htun, dsc_hc));
+    struct dsd_htcp_packet* adsl_hp = (struct dsd_htcp_packet*)
+        ((char*)adsp_hii - offsetof(struct dsd_htcp_packet, dsc_hii));
+
+    if ((adsl_hh->adsc_tcc->imc_trace_level & HL_WT_SESS_NETW) != 0) {
+        m_do_wsp_trace("SNEHTCHL", 0,
+                       adsl_hh->adsc_tcc->imc_sno,
+                       adsl_hh->adsc_tcc->imc_trace_level,
+                       NULL, 0, 0,
+                       "HTCP done using segment %p.",
+                       adsp_hii);
+    }
+
+    m_htun_relrecvbuf(adsl_hp->dsc_hpc.ac_handle);
+    return true;
+}
+
+static bool m_hcb_get_time(struct dsd_htcp_conn* adsp_hc, int64_t* ailp_time)
+{
+    *ailp_time = m_get_epoch_ms();
+    return true;
+}
+
+static bool m_hcb_set_timer(struct dsd_htcp_conn* adsp_hc,
+                            uint32_t ump_delay_ms)
+{
+    struct dsd_htcp_htun* adsl_hh = (struct dsd_htcp_htun*)
+        ((char*)adsp_hc - offsetof(struct dsd_htcp_htun, dsc_hc));
+
+    if ((adsl_hh->adsc_tcc->imc_trace_level & HL_WT_SESS_NETW) != 0) {
+        m_do_wsp_trace("SNEHTCCT", 0,
+                       adsl_hh->adsc_tcc->imc_sno,
+                       adsl_hh->adsc_tcc->imc_trace_level,
+                       NULL, 0, 0,
+                       "HTCP setting timeout - %d ms delay.",
+                       (int)(ump_delay_ms));
+    }
+
+    m_time_rel(&adsl_hh->dsc_te);
+    adsl_hh->dsc_te.ilcwaitmsec = ump_delay_ms;
+    m_time_set(&adsl_hh->dsc_te, FALSE);
+    return true;
+}
+
+static bool m_hcb_rel_timer(struct dsd_htcp_conn* adsp_hc)
+{
+    struct dsd_htcp_htun* adsl_hh = (struct dsd_htcp_htun*)
+        ((char*)adsp_hc - offsetof(struct dsd_htcp_htun, dsc_hc));
+
+    if ((adsl_hh->adsc_tcc->imc_trace_level & HL_WT_SESS_NETW) != 0) {
+        m_do_wsp_trace("SNEHTCHR", 0,
+                       adsl_hh->adsc_tcc->imc_sno,
+                       adsl_hh->adsc_tcc->imc_trace_level,
+                       NULL, 0, 0,
+                       "HTCP releasing timer if active.");
+    }
+
+    m_time_rel(&adsl_hh->dsc_te);
+    return true;
+}
+
+static bool m_hcb_lock(struct dsd_htcp_conn* adsp_hc)
+{
+    // No need for locking since calls are synchronized.
+    return true;
+}
+
+static bool m_hcb_unlock(struct dsd_htcp_conn* adsp_hc)
+{
+    // No need for locking since calls are synchronized.
+    return true;
+}
+
+static bool m_hcb_established(struct dsd_htcp_conn* adsp_hc)
+{
+    struct dsd_htcp_htun* adsl_hh = (struct dsd_htcp_htun*)
+        ((char*)adsp_hc - offsetof(struct dsd_htcp_htun, dsc_hc));
+    struct sockaddr_in dsl_sai;
+    struct sockaddr_in6 dsl_sai6;
+    struct sockaddr* adsl_sa;
+    socklen_t ul_sl;
+    char chrl_trace_addr[42];
+
+    if ((adsl_hh->adsc_tcc->imc_trace_level & HL_WT_SESS_NETW) != 0) {
+        m_print_addr(chrl_trace_addr,
+                     adsl_hh->chrc_remote_addr, adsl_hh->boc_ipv6);
+        m_do_wsp_trace("SNEHTCHE", 0,
+                       adsl_hh->adsc_tcc->imc_sno,
+                       adsl_hh->adsc_tcc->imc_trace_level,
+                       NULL, 0, 0,
+                       "HTCP connection established with %s:%d.",
+                       chrl_trace_addr, (int)adsl_hh->usc_remote_port);
+    }
+
+    adsl_hh->iec_hhs = ied_hhs_connected;
+
+    if (adsl_hh->boc_ipv6) {
+        memset(&dsl_sai6, 0, sizeof(dsl_sai6));
+        dsl_sai6.sin6_family = AF_INET6;
+        dsl_sai6.sin6_port = htons(adsl_hh->usc_remote_port);
+        memcpy(&dsl_sai6.sin6_addr.s6_addr, adsl_hh->chrc_remote_addr, 16);
+        adsl_sa = (struct sockaddr*)&dsl_sai6;
+        ul_sl = sizeof(dsl_sai6);
+    } else { // IPv4
+        memset(&dsl_sai, 0, sizeof(dsl_sai));
+        dsl_sai.sin_family = AF_INET;
+        dsl_sai.sin_port = htons(adsl_hh->usc_remote_port);
+        memcpy(&dsl_sai.sin_addr.s_addr, adsl_hh->chrc_remote_addr, 4);
+        adsl_sa = (struct sockaddr*)&dsl_sai;
+        ul_sl = sizeof(dsl_sai);
+    }
+
+    m_htun_htcp_connect_end(adsl_hh->adsc_tcc, adsl_hh->adsc_target_ineta,
+                            adsl_hh->ac_free_ti1, adsl_sa, ul_sl, 0);
+
+    return true;
+}
+
+static void m_hcb_closed(struct dsd_htcp_conn* adsp_hc,
+                         enum ied_htcp_close iep_htcpc)
+{
+    struct dsd_htcp_htun* adsl_hh = (struct dsd_htcp_htun*)
+        ((char*)adsp_hc - offsetof(struct dsd_htcp_htun, dsc_hc));
+    char chrl_close_description[128];
+    uint32_t uml_dlen;
+    char chrl_close_debug_info[128];
+    uint32_t uml_dilen;
+    struct sockaddr_in dsl_sai;
+    struct sockaddr_in6 dsl_sai6;
+    struct sockaddr* adsl_sa;
+    socklen_t ul_sl;
+    int inl_error;
+
+    if ((adsl_hh->adsc_tcc->imc_trace_level & HL_WT_SESS_NETW) != 0) {
+        uml_dlen = sizeof(chrl_close_description);
+        uml_dilen = sizeof(chrl_close_description);
+        m_htcp_describe_close(&adsl_hh->dsc_hc,
+                              chrl_close_description, &uml_dlen,
+                              chrl_close_debug_info, &uml_dilen);
+        m_do_wsp_trace("SNEHTCHC", 0,
+                       adsl_hh->adsc_tcc->imc_sno,
+                       adsl_hh->adsc_tcc->imc_trace_level,
+                       NULL, 0, 0,
+                       "HTCP TCP connection closed from state %d - %s (%s).",
+                       (int)adsl_hh->iec_hhs,
+                       chrl_close_debug_info, chrl_close_debug_info);
+    }
+
+    switch (adsl_hh->iec_hhs) {
+    case ied_hhs_connecting:
+        // Connection failed to establish.
+        if (adsl_hh->boc_ipv6) {
+            memset(&dsl_sai6, 0, sizeof(dsl_sai6));
+            dsl_sai6.sin6_family = AF_INET6;
+            dsl_sai6.sin6_port = htons(adsl_hh->usc_remote_port);
+            memcpy(&dsl_sai6.sin6_addr.s6_addr, adsl_hh->chrc_remote_addr, 16);
+            adsl_sa = (struct sockaddr*)&dsl_sai6;
+            ul_sl = sizeof(dsl_sai6);
+        } else { // IPv4
+            memset(&dsl_sai, 0, sizeof(dsl_sai));
+            dsl_sai.sin_family = AF_INET;
+            dsl_sai.sin_port = htons(adsl_hh->usc_remote_port);
+            memcpy(&dsl_sai.sin_addr.s_addr, adsl_hh->chrc_remote_addr, 4);
+            adsl_sa = (struct sockaddr*)&dsl_sai;
+            ul_sl = sizeof(dsl_sai);
+        }
+        uml_dlen = sizeof(chrl_close_description);
+        m_htcp_describe_close(&adsl_hh->dsc_hc,
+                              chrl_close_description, &uml_dlen,
+                              NULL, NULL);
+
+        if (iep_htcpc == ied_htcpc_conn_refused) {
+            inl_error = HTCP_ERR_CONN_REFUSED;
+            if (adsl_hh->inc_htcp_error == HTCP_ERR_CONN_ALL_TIMEOUT)
+                adsl_hh->inc_htcp_error = HTCP_ERR_CONN_ALL_RF_TO;
+            else if (adsl_hh->inc_htcp_error != HTCP_ERR_CONN_ALL_RF_TO)
+                adsl_hh->inc_htcp_error = HTCP_ERR_CONN_ALL_REFUSED;
+        } else if (iep_htcpc == ied_htcpc_conn_timeout) {
+            inl_error = HTCP_ERR_CONN_TIMEOUT;
+            if (adsl_hh->inc_htcp_error == HTCP_ERR_CONN_ALL_REFUSED)
+                adsl_hh->inc_htcp_error = HTCP_ERR_CONN_ALL_RF_TO;
+            else if (adsl_hh->inc_htcp_error != HTCP_ERR_CONN_ALL_RF_TO)
+                adsl_hh->inc_htcp_error = HTCP_ERR_CONN_ALL_TIMEOUT;
+        } else {
+            inl_error = HTCP_ERR_CANCELLED;
+        }
+
+        m_htun_warning(adsl_hh->adsc_tcc, adsl_hh->adsc_tci, inl_error,
+                       "connecting failed - %s", chrl_close_description);
+        m_htun_htcp_connect_failed(adsl_hh->adsc_tcc, adsl_sa, ul_sl,
+                                   adsl_hh->inc_target_cur,
+                                   adsl_hh->adsc_target_ineta->imc_no_ineta,
+                                   inl_error);
+
+        m_try_next_address(adsl_hh);
+        // return not break - we do not want to close whole session
+        return;
+
+    case ied_hhs_conn_abort:
+        // Connection aborted while attempting to connect.
+        m_htun_session_end(adsl_hh->adsc_tcc, HTCP_ERR_CANCELLED);
+        break;
+
+    case ied_hhs_connected:
+        // Should be here if we received RST from remote endpoint or timeout.
+        if (iep_htcpc == ied_htcpc_conn_timeout)
+            inl_error = HTCP_ERR_SESS_END_TIMEOUT;
+        else
+            inl_error = HTCP_ERR_SESS_END_RST;
+        uml_dlen = sizeof(chrl_close_description);
+        m_htcp_describe_close(&adsl_hh->dsc_hc,
+                              chrl_close_description, &uml_dlen,
+                              NULL, NULL);
+        m_htun_warning(adsl_hh->adsc_tcc, adsl_hh->adsc_tci, inl_error,
+                       "connection closed - %s", chrl_close_description);
+        m_htun_session_end(adsl_hh->adsc_tcc, inl_error);
+        break;
+
+    case ied_hhs_close:
+        // Should be here if we received RST from remote endpoint or timeout
+        // after sending FIN.
+        adsl_hh->iec_hhs = ied_hhs_closed;
+        m_time_rel(&adsl_hh->dsc_te_closing);
+        // If we do not manage to stop timer, nothing bad happens. The state
+        // ied_hhs_closed would indicate that the connection is ended anyway.
+        if (iep_htcpc == ied_htcpc_conn_timeout)
+            inl_error = HTCP_ERR_SESS_END_TIMEOUT;
+        else
+            inl_error = HTCP_ERR_SESS_END_RST;
+        uml_dlen = sizeof(chrl_close_description);
+        m_htcp_describe_close(&adsl_hh->dsc_hc,
+                              chrl_close_description, &uml_dlen,
+                              NULL, NULL);
+        m_htun_warning(adsl_hh->adsc_tcc, adsl_hh->adsc_tci, inl_error,
+                       "connection closed - %s", chrl_close_description);
+        m_htun_session_end(adsl_hh->adsc_tcc, inl_error);
+        break;
+
+    case ied_hhs_close_force:
+        // Should be here after giving up waiting for connection to close
+        // gracefully.
+        m_htun_session_end(adsl_hh->adsc_tcc, HTCP_ERR_SESS_END_TIMEOUT);
+        break;
+
+    case ied_hhs_time_wait:
+        // connection closed gracefully after TIME_WAIT
+        m_htun_session_end(adsl_hh->adsc_tcc, 0);
+        break;
+
+    case ied_hhs_end:
+        // Connection closed after receiving FIN and sending FIN.
+        // Do not call m_htun_session_end() since it was already called when
+        // the state was set to ied_hhs_end.
+        break;
+
+    default:
+        // should not arrive here
+        m_time_rel(&adsl_hh->dsc_te_closing);
+        uml_dlen = sizeof(chrl_close_description);
+        m_htcp_describe_close(&adsl_hh->dsc_hc,
+                              chrl_close_description, &uml_dlen,
+                              NULL, NULL);
+        m_htun_warning(adsl_hh->adsc_tcc, adsl_hh->adsc_tci,
+                       HTCP_ERR_INTERNAL_ERROR,
+                       "Internal HTCP error at "
+                       "xs-htcp-htun-01.cpp:%d - state=%d - .",
+                       __LINE__, (int)adsl_hh->iec_hhs, chrl_close_description);
+    }
+
+    m_free_resources(adsl_hh);
+}
Index: nbipgw20.cpp
===================================================================
--- nbipgw20.cpp	(revision 2)
+++ nbipgw20.cpp	(revision 6)
@@ -5,16 +5,19 @@
        struct dsd_netw_post_1 dsc_netw_post_1;  /* structure to post from network callback */
 #endif
 #define TRY_120306_01                       /* flow-control send       */
-#define TRY_120513_01                       /* SO_REUSEADDR            */
-#define TRY_120513_02                       /* SO_REUSEADDR            */
-#define TRY_120513_03                       /* SO_REUSEADDR            */
-#define TRY_120522_01                       /* SO_REUSEADDR            */
-#define TRY_120522_02                       /* SO_REUSEADDR            */
-#define TRY_121023_01                       /* SO_REUSEADDR            */
+//#define TRY_120513_01                       /* SO_REUSEADDR            */
+//#define TRY_120513_02                       /* SO_REUSEADDR            */
+//#define TRY_120513_03                       /* SO_REUSEADDR            */
+//#define TRY_120522_01                       /* SO_REUSEADDR            */
+//#define TRY_120522_02                       /* SO_REUSEADDR            */
+//#define TRY_121023_01                       /* SO_REUSEADDR            */
+#define TRY_121128_01                       /* SO_REUSEADDR            */
+#define TRY_121211_01                       /* core dump               */
 #define DEBUG_120705_01 32                  /* loop SSL                */
-#define DEBUG_120710_01                     /* flow-control send       */
-#define DEBUG_120808_01                     /* debug start SDHs        */
-#define DEBUG_121023_01                     /* debug listen-gateway create socket */
+//#define DEBUG_120710_01                     /* flow-control send       */
+//#define DEBUG_120808_01                     /* debug start SDHs        */
+//#define DEBUG_121023_01                     /* debug listen-gateway create socket */
+//#define DEBUG_121116_01                     /* debug listen-gateway    */
 #define D_STOR_ONE_TIME
 #define WSP_TRACE_FILE_01 "WSP-trace-01.dat"
 #define WSP_TRACE_SLEEP 100
@@ -92,6 +95,9 @@
 #include <sys/uio.h>
 #include <netinet/tcp.h>
 /* end header-files for TCPCOMP                                        */
+#ifdef TRY_121211_01                        /* core dump               */
+#include <sys/prctl.h>
+#endif /* TRY_121211_01                        core dump               */
 #include <locale.h>
 #include <langinfo.h>
 #ifdef D_INCL_HOB_TUN
@@ -230,6 +236,7 @@
 #include <string>
 #include <map>
 #include <list>
+#ifdef B130123
 #ifdef D_INCL_HOB_TUN
 //#include <Iprtrmib.h>
 //#include <Iphlpapi.h>
@@ -237,6 +244,15 @@
 #endif
 #define D_INCL_TUN_CTRL
 #include "hob-tun01.h"
+#else
+#ifdef D_INCL_HOB_TUN
+//#include <Iprtrmib.h>
+//#include <Iphlpapi.h>
+//#include <Iptypes.h>
+#define D_INCL_TUN_CTRL
+#include "hob-tun01.h"
+#endif
+#endif
 #ifdef NOT_YET_110808
 #include "hob-htcp-int-types.h"
 #include "hob-htcp-misc.h"
@@ -322,12 +338,14 @@
 #endif
 #define D_LIGW_TIMEOUT         5            /* timeout in seconds      */
 #define D_WAIT_LIERR           15           /* wait after listen error in seconds */
+#define D_WAIT_OPEN_TUN        60           /* wait for listen-gateway open TUN adapter */
 #define DEF_SEND_IOVEC         32           /* for sendmsg()           */
 #define HL_AES_LEN             16
 #define D_MAX_LEN_NHASN        4            /* maximum length NHASN    */
 #ifdef D_INCL_HOB_TUN
 #define HL_ERROR_HTCP_CONN     (20000 + 1)  /* HOBLink Error Code      */
 #endif
+#define D_FN_IP_FORW   "/proc/sys/net/ipv4/ip_forward"

 /*+-------------------------------------------------------------------+*/
 /*| static used enum used if function calls.                          |*/
@@ -337,7 +355,10 @@
    ied_fmp_normal,                          /* normal processing       */
    ied_fmp_opli_sleep,                      /* open listen sleep       */
    ied_fmp_opli_ligw_wait,                  /* open listen listen gateway wait */
-   ied_fmp_opli_ligw_ret                    /* open listen listen gateway return */
+   ied_fmp_opli_ligw_ret,                   /* open listen listen gateway return */
+#ifdef D_INCL_HOB_TUN
+   ied_fmp_open_tun                         /* open TUN adapter        */
+#endif
 };

 enum ied_ret_main_poll {                    /* return from main poll   */
@@ -345,7 +366,7 @@
    ied_rmp_sig_end,                         /* message signal end      */
    ied_rmp_sig_reload,                      /* message signal reload configuration */
    ied_rmp_sig_check_shu,                   /* message signal check shutdown */
-   ied_rmp_ligw_success,                    /* listen gateway socket passed */
+   ied_rmp_ligw_success,                    /* listen gateway socket passed or TUN adapter opened */
    ied_rmp_ligw_failed,                     /* socket and bind failed  */
    ied_rmp_ligw_closed                      /* listen gateway is closed */
 };
@@ -367,10 +388,8 @@
 static int m_get_random_number( int );
 #endif
 static htfunc1_t m_conn_pttd_thread( void * );
-#ifdef NOT_YET
 static htfunc1_t m_serial_thread( void * );
 static htfunc1_t m_wsp_trace_thread( void * );
-#endif
 inline dsd_user_entry ** m_get_addr_user_entry( void * );
 inline dsd_user_group ** m_get_addr_user_group( void * );
 static ied_chid_ret m_auth_user( struct dsd_user_entry **, struct dsd_user_group **,
@@ -408,7 +427,6 @@
 static BOOL m_aux_secure_xor( struct dsd_aux_secure_xor_1 * );
 static BOOL m_aux_webso_conn( void *, struct dsd_aux_webso_conn_1 * );
 static void m_close_webso_conn( void * );
-static htfunc1_t m_wsp_trace_thread( void * );
 //static void m_end_proc( void );
 #ifdef NOT_YET
 static void m_wait_conn( void *, int );     /* wait till activated     */
@@ -429,14 +447,18 @@

 static void m_acc_errorcallback( class dsd_nblock_acc *, void *, char *, int, int );  // Error callback function.
 static void m_acc_acceptcallback( class dsd_nblock_acc *, void *, int, struct sockaddr *, int );
-#ifndef NOT_YET
 static void m_cb_tcpc_conn_err( class dsd_tcpcomp *, void *, struct sockaddr *, socklen_t, int, int, int );
+#ifdef B121121
 static void m_cb_tcpc_connect( class dsd_tcpcomp *, void *, struct sockaddr *, socklen_t, int );
+#else
+static void m_cb_tcpc_connect( dsd_tcpcomp *, void *, struct dsd_target_ineta_1 *, void *, struct sockaddr *, socklen_t, int );
+#endif
 static void m_cb_tcpc_send( class dsd_tcpcomp *, void * );  /* send callback function */
 static int m_cb_tcpc_getbuf( class dsd_tcpcomp *, void *, void **, char **, int ** );  // get receive buffer callback function
 static int m_cb_tcpc_recv( class dsd_tcpcomp *, void *, void * );  // receive callback function
 static void m_cb_tcpc_error( class dsd_tcpcomp *, void *, char *, int, int );  // error callback function
 static void m_cb_tcpc_cleanup( class dsd_tcpcomp *, void * );
+#ifdef B121121
 static void m_cb_tcpc_free_target_ineta( class dsd_tcpcomp *, void *, const struct dsd_target_ineta_1 * );
 #endif
 static void m_tc1_post_netw_post_1( struct dsd_tcp_ctrl_1 *adsp_tc1, int imp_mask );
@@ -452,7 +474,7 @@
 static void m_send_clse_tcp_1( struct dsd_conn1 *, struct dsd_tcp_ctrl_1 *, struct dsd_sdh_control_1 *, BOOL );
 static void m_ligw_open( void );            /* open the listen gateway */
 static void m_ligw_create_socket( void );
-static BOOL m_ligw_send( char *, int );
+static BOOL m_ligw_send( char *, int, struct msghdr * );
 static void m_ligw_recv( void );
 static void m_ligw_close( void );
 inline int m_tcp_sa_conn_server( struct dsd_aux_cf1 *, struct sockaddr * );
@@ -654,6 +676,8 @@
        struct dsd_tun_contr_conn dsc_tun_contr_conn;  /* HOB-TUN control area connection */
        struct dsd_sdh_control_1 *adsc_sdhc1_htun_sch;  /* chain of buffers to send over HOB-TUN */
        int    imc_send_window;              /* number of bytes to be sent */
+       int    imc_ppp_state;                /* PPP state               */
+       struct dsd_netw_post_1 *adsc_ppp_netw_post_1;  /* structure to post from network callback */
      };
 #endif
      struct {                               /* for L2TP                */
@@ -841,6 +865,10 @@
 static class dsd_hcla_critsect_1 dss_main_critsect;  /* for AVL-tree   */
 static class dsd_hcla_critsect_1 dss_util_critsect;  /* for utilities  */

+static char   chrs_msg_pre[ 5 ] = { 0, 0, 0, 0, 0 };
+
+#define LEN_MSG_PRE sizeof(chrs_msg_pre)
+
 static void * vprs_message_shutdown[ DEF_MSG_PIPE_LEN ] = {  /* message in pipe shutdown */
    (void *) ied_mepm_sig_check_shu,         /* message signal check shutdown */
    NULL
@@ -920,7 +948,7 @@
    (void *) &m_aux_conn,                    /* address routine m_aux_conn() */
 #endif
 #ifdef NOT_YET
-   (void *) &m_tcp_conn,                    /* address routine m_tcp_conn() - connect TCP */
+   (void *) &m_tcp_dynamic_conn,            /* address routine m_tcp_dynamic_conn() - connect TCP */
    &dsg_hco_main,                           /* work threads            */
    &dss_loconf_1,                           /* load configuration      */
    (void *) &m_set_wothr_blocking,
@@ -970,8 +998,7 @@
    &m_cb_tcpc_recv,
    &m_cb_tcpc_error,
    &m_cb_tcpc_cleanup,
-   &m_get_random_number,
-   &m_cb_tcpc_free_target_ineta
+   &m_get_random_number
 };

 static struct dsd_main_poll_sub {           /* structure main poll subroutine */
@@ -985,6 +1012,10 @@
    BOOL       boc_listen_start;             /* start listen at program start */
    BOOL       boc_listen_lbal;              /* start listen for load-balancing */
    BOOL       boc_rc_last_listen;           /* return code last listen */
+#ifdef D_INCL_HOB_TUN
+   BOOL       boc_ser_sent;                 /* serialize command sent  */
+   int        imc_open_tun_sent;             /* command open TUN sent   */
+#endif
    int        imc_sockfd;                   /* socket for connection   */
    int        imc_time_disconnect;          /* time of disconnect      */
 // int        imc_fd_pipe[2];               /* file descriptores pipe  */
@@ -1113,6 +1144,12 @@
      return -1;
    }

+#ifdef TRY_121211_01                        /* core dump               */
+   iml_rc = prctl( PR_SET_DUMPABLE, 1, 0, 0, 0 );
+   m_hlnew_printf( HLOG_XYZ1, "l%05d prctl() returned iml_rc=%d errno=%d.",
+                   __LINE__, iml_rc, errno );
+#endif /* TRY_121211_01                        core dump               */
+
    iml_rc = pipe( imrs_m_fd_pipe );         /* create pipe main        */
 #ifdef TRACEHL1
    m_hlnew_printf( HLOG_XYZ1, "l%05d pipe main completed / returned iml_rc=%d errno=%d.",
@@ -1166,6 +1203,9 @@
            case ied_chs_utf_8:              /* Unicode UTF-8           */
              achl2 = "UTF-8";
              break;
+           case ied_chs_iso8859_15:         /* ISO 8859-15             */
+             achl2 = "ISO-8859-15";
+             break;
            default:
              achl2 = "*invalid*";
              break;
@@ -1200,6 +1240,17 @@
      dsg_this_server.imc_len_server_name = 3;
    }
    dsg_this_server.imc_pid = getpid();      /* get process id          */
+// to-do 16.11.12 KB - move to other place, depending on configuration
+   if (TRUE) {
+     chrs_msg_pre[ 4 ] = ' ';               /* separator               */
+     iml1 = dsg_this_server.imc_pid;        /* get pid                 */
+     iml2 = 4;                              /* number of base64 characters */
+     do {                                   /* loop generate base64    */
+       iml2--;                              /* decrement index         */
+       chrs_msg_pre[ iml2 ] = ucrs_base64[ iml1 & 0X3F ];
+       iml1 >>= 6;                          /* remove 6 bits           */
+     } while (iml2 > 0);
+   }
 #ifdef XYZ1
 // to-do 06.08.11 KB
    dsg_this_server.boc_endian_big = FALSE;  /* Windows - CPU is not big endian */
@@ -1277,7 +1328,7 @@
                      achrpargv[1], errno );
      return -1;                             /* return with error       */
    }
-   iml_file1 = open( adss_path_param, O_RDONLY);
+   iml_file1 = open( adss_path_param, O_RDONLY );
    if (iml_file1 < 0) {                     /* error occured           */
      m_hlnew_printf( HLOG_XYZ1, "HWSPPCnnnE open input file %s returned error %d.",
                      adss_path_param, errno );
@@ -1875,6 +1926,10 @@
    if (bos_end_proc == FALSE) goto p_m_poll_00;  /* poll for events    */

    p_end_00:                                /* end of program          */
+#ifdef DEBUG_121116_01                      /* debug listen-gateway    */
+   m_hlnew_printf( HLOG_TRACE1, "nbipgw20-l%05d-T main() p_end_00",
+                   __LINE__ );
+#endif
    if (bos_pid_file) {                      /* PID file active         */
 //   bos_pid_file = FALSE;                  /* PID file no more active */
      iml_rc = unlink( dss_loconf_1.achc_pid_file );  /* delete PID file */
@@ -1923,6 +1978,9 @@
      }
    }
    iml1 = m_stop_all_listen( FALSE );
+#ifndef B121119
+   sleep( 5 );
+#endif

    p_shutdown_00:                           /* check shutdown of this process */
    if (ims_count_cma_sync != 0) {           /* count currently active CMA synchronize */
@@ -1957,6 +2015,19 @@
    int        iml_endtime_w2;               /* end time                */
    int        iml_timeout;                  /* timeout for poll()      */
    time_t     dsl_time_1;                   /* for time                */
+#ifdef D_INCL_HOB_TUN
+   char       *achl1;                       /* working variable        */
+   struct dsd_ser_thr_task *adsl_sth_w1;    /* working variable        */
+   struct msghdr dsl_msghdr;                /* message structure       */
+#ifdef MSGHDR_CONTROL_AVAILABLE
+   union {
+     struct cmsghdr dsc_msg;
+     char chrc_control[ CMSG_SPACE(sizeof(int)) ];
+   } dsl_control_un;
+   struct cmsghdr *adsl_cmd;
+#endif
+   char       chrl_send_buf[ 512 ];         /* send buffer             */
+#endif
    void *     vprl_message[ DEF_MSG_PIPE_LEN ];  /* message in pipe    */

    p_sub_poll_00:                           /* do poll now             */
@@ -1972,6 +2043,12 @@
      }
      return ied_rmp_ligw_failed;            /* socket and bind failed  */
    }
+#ifdef D_INCL_HOB_TUN
+   if (dss_ligw_g.imc_open_tun_sent == 2) {  /* command open TUN sent   */
+     dss_ligw_g.imc_open_tun_sent = 0;      /* command open TUN sent   */
+     return ied_rmp_ligw_success;           /* listen gateway socket passed */
+   }
+#endif
    iml_endtime_w1 = imp_endtime;            /* get end time            */
    time( &dsl_time_1 );                     /* get current time        */
    if (   (dss_loconf_1.boc_listen_gw)      /* do use listen gateway   */
@@ -2002,11 +2079,112 @@
        && (   (dss_ligw_g.adsc_gate_1_create_socket)  /* current gate to start */
            || (dss_ligw_g.boc_listen_start))  /* start listen at program start */
        && (dss_ligw_g.adsc_gate_listen_1_cur == NULL)) {  /* listen part of gateway currently processed */
+// to-do 29.12.12 KB - multiple commands give problems? check dss_ligw_g.boc_ser_sent
      m_ligw_create_socket();                /* send command create socket */
      if (dss_ligw_g.boc_connected == FALSE) {  /* not connected to Listen Gateway */
        goto p_sub_poll_00;                  /* do poll now             */
      }
    }
+#ifdef D_INCL_HOB_TUN
+   if (   (dss_ligw_g.boc_connected)        /* connected to Listen Gateway */
+       && (iep_fmp == ied_fmp_open_tun)     /* open TUN adapter        */
+       && (dss_ligw_g.imc_open_tun_sent == 0)) {  /* command open TUN sent */
+#define ADSL_LIGW_Q_OPEN_TUN_G ((struct dsd_ligw_q_open_tun *) (chrl_send_buf + 1))
+#ifdef B130109
+     ADSL_LIGW_Q_OPEN_TUN_G->ucc_use_ipv4 = 1;  /* use IPV4            */
+     ADSL_LIGW_Q_OPEN_TUN_G->ucc_use_ipv6 = 0;  /* use IPV6            */
+     ADSL_LIGW_Q_OPEN_TUN_G->ucc_no_ineta_ipv4 = 1;  /* number of INETAs IPV4 */
+     ADSL_LIGW_Q_OPEN_TUN_G->ucc_no_ineta_ipv6 = 0;  /* number of INETAs IPV6 */
+     memcpy( ADSL_LIGW_Q_OPEN_TUN_G + 1, &dss_loconf_1.adsc_raw_packet_if_conf->umc_ta_ineta_local, sizeof(UNSIG_MED) );   /* <TUN-adapter-ineta> */
+#endif
+     ADSL_LIGW_Q_OPEN_TUN_G->ucc_use_ipv4 = 0;  /* use IPV4            */
+     ADSL_LIGW_Q_OPEN_TUN_G->ucc_use_ipv6 = 0;  /* use IPV6            */
+     ADSL_LIGW_Q_OPEN_TUN_G->ucc_no_ineta_ipv4 = (unsigned char) dss_loconf_1.adsc_raw_packet_if_conf->imc_no_ta_ineta_ipv4;  /* number of INETAs IPV4 */
+     ADSL_LIGW_Q_OPEN_TUN_G->ucc_no_ineta_ipv6 = (unsigned char) dss_loconf_1.adsc_raw_packet_if_conf->imc_no_ta_ineta_ipv6;  /* number of INETAs IPV6 */
+     achl1 = (char *) (ADSL_LIGW_Q_OPEN_TUN_G + 1);
+     if (dss_loconf_1.adsc_raw_packet_if_conf->imc_no_ta_ineta_ipv4 > 0) {  /* number of INETAs IPV4 */
+       memcpy( achl1,
+               dss_loconf_1.adsc_raw_packet_if_conf->achc_ar_ta_ineta_ipv4,
+               dss_loconf_1.adsc_raw_packet_if_conf->imc_no_ta_ineta_ipv4 * 4 );  /* number of INETAs IPV4 */
+       achl1 += dss_loconf_1.adsc_raw_packet_if_conf->imc_no_ta_ineta_ipv4 * 4;  /* number of INETAs IPV4 */
+       ADSL_LIGW_Q_OPEN_TUN_G->ucc_use_ipv4 = 1;  /* use IPV4          */
+     }
+     if (dss_loconf_1.adsc_raw_packet_if_conf->imc_no_ta_ineta_ipv6 > 0) {  /* number of INETAs IPV6 */
+       memcpy( achl1,
+               dss_loconf_1.adsc_raw_packet_if_conf->achc_ar_ta_ineta_ipv6,
+               dss_loconf_1.adsc_raw_packet_if_conf->imc_no_ta_ineta_ipv6 * 16 );  /* number of INETAs IPV6 */
+       achl1 += dss_loconf_1.adsc_raw_packet_if_conf->imc_no_ta_ineta_ipv6 * 16;  /* number of INETAs IPV6 */
+       ADSL_LIGW_Q_OPEN_TUN_G->ucc_use_ipv6 = 1;  /* use IPV6          */
+     }
+     chrl_send_buf[ 0 ] = (unsigned char) ied_ligwq_open_tun;  /* open TUN adapter */
+     memset( &dsl_msghdr, 0, sizeof(struct msghdr) );
+
+#ifdef MSGHDR_CONTROL_AVAILABLE
+     dsl_msghdr.msg_control = dsl_control_un.chrc_control;
+     dsl_msghdr.msg_controllen = sizeof(dsl_control_un.chrc_control);
+
+     adsl_cmd = CMSG_FIRSTHDR( &dsl_msghdr );
+     adsl_cmd->cmsg_len = CMSG_LEN( sizeof(int) );
+     adsl_cmd->cmsg_level = SOL_SOCKET;
+     adsl_cmd->cmsg_type = SCM_RIGHTS;
+     *((int *) CMSG_DATA( adsl_cmd )) = dss_tun_ctrl.imc_fd_tun;
+#else
+     dsl_msghdr.msg_accrights = (caddr_t) &dss_tun_ctrl.imc_fd_tun;
+     dsl_msghdr.msg_accrightslen = sizeof(int);
+#endif
+
+#ifdef B130109
+     m_ligw_send( chrl_send_buf, 1 + sizeof(struct dsd_ligw_q_open_tun) + sizeof(UNSIG_MED), &dsl_msghdr );
+#endif
+     m_ligw_send( chrl_send_buf, achl1 - chrl_send_buf, &dsl_msghdr );
+
+#undef ADSL_LIGW_Q_OPEN_TUN_G
+
+     if (dss_ligw_g.boc_connected == FALSE) {  /* not connected to Listen Gateway */
+       goto p_sub_poll_00;                  /* do poll now             */
+     }
+     dss_ligw_g.imc_open_tun_sent = 1;      /* command open TUN sent   */
+   }
+   while (   (dss_ligw_g.boc_connected)     /* connected to Listen Gateway */
+          && (dss_ser_thr_ctrl.adsc_sth_work)  /* work as task for serial thread */
+          && (dss_ligw_g.boc_ser_sent == FALSE)) {  /* serialize command sent */
+// to-do 29.12.12 KB - multiple commands give problems? check dss_ligw_g.adsc_gate_listen_1_cur
+     if (dss_ser_thr_ctrl.adsc_sth_work->iec_sth  /* serial thread task type */
+             == ied_sth_route_ipv4_add) {   /* add a route IPV4        */
+#define ADSL_QUERY_AR_ADD_IPV4_G ((struct dsd_ligw_q_ar_add_ipv4 *) (chrl_send_buf + 1))  /* add ARP and route IPV4 */
+       memcpy( ADSL_QUERY_AR_ADD_IPV4_G->chrc_tiface, dss_tun_ctrl.chrc_tiface, IFNAMSIZ );
+       memcpy( ADSL_QUERY_AR_ADD_IPV4_G->chrc_riface, dss_tun_ctrl.chrc_riface, IFNAMSIZ );
+       memcpy( &ADSL_QUERY_AR_ADD_IPV4_G->dsc_rhwaddr, &dss_tun_ctrl.dsc_rhwaddr, sizeof(struct sockaddr) );
+       memcpy( ADSL_QUERY_AR_ADD_IPV4_G->chrc_ineta, dss_ser_thr_ctrl.adsc_sth_work->chrc_ineta, sizeof(UNSIG_MED) );
+#undef ADSL_QUERY_AR_ADD_IPV4_G
+       chrl_send_buf[ 0 ] = (unsigned char) ied_ligwq_arproute_add_ipv4;  /* add ARP and route IPV4 */
+       m_ligw_send( chrl_send_buf, 1 + sizeof(struct dsd_ligw_q_ar_add_ipv4), NULL );
+       dss_ligw_g.boc_ser_sent = TRUE;      /* serialize command sent  */
+     } else if (dss_ser_thr_ctrl.adsc_sth_work->iec_sth  /* serial thread task type */
+             == ied_sth_route_ipv4_del) {   /* delete a route IPV4     */
+       dss_ligw_g.boc_ser_sent = TRUE;      /* serialize command sent  */
+#define ADSL_QUERY_AR_DEL_IPV4_G ((struct dsd_ligw_q_ar_add_ipv4 *) (chrl_send_buf + 1))  /* del ARP and route IPV4 */
+       memcpy( ADSL_QUERY_AR_DEL_IPV4_G->chrc_tiface, dss_tun_ctrl.chrc_tiface, IFNAMSIZ );
+       memcpy( ADSL_QUERY_AR_DEL_IPV4_G->chrc_riface, dss_tun_ctrl.chrc_riface, IFNAMSIZ );
+       memcpy( &ADSL_QUERY_AR_DEL_IPV4_G->dsc_rhwaddr, &dss_tun_ctrl.dsc_rhwaddr, sizeof(struct sockaddr) );
+       memcpy( ADSL_QUERY_AR_DEL_IPV4_G->chrc_ineta, dss_ser_thr_ctrl.adsc_sth_work->chrc_ineta, sizeof(UNSIG_MED) );
+#undef ADSL_QUERY_AR_DEL_IPV4_G
+       chrl_send_buf[ 0 ] = (unsigned char) ied_ligwq_arproute_del_ipv4;  /* del ARP and route IPV4 */
+       m_ligw_send( chrl_send_buf, 1 + sizeof(struct dsd_ligw_q_ar_del_ipv4), NULL );
+       dss_ligw_g.boc_ser_sent = TRUE;      /* serialize command sent  */
+     } else {                               /* invalid command         */
+       m_hlnew_printf( HLOG_WARN1, "nbipgw20-l%05d-W m_main_poll() invalid serialize command iec_sth %d.",
+                       __LINE__, dss_ser_thr_ctrl.adsc_sth_work->iec_sth );
+       dsg_global_lock.m_enter();           /* enter critical section  */
+       adsl_sth_w1 = dss_ser_thr_ctrl.adsc_sth_work;  /* get work as task for serial thread */
+       dss_ser_thr_ctrl.adsc_sth_work = adsl_sth_w1->adsc_next;  /* remove from chain */
+       adsl_sth_w1->adsc_next = dss_ser_thr_ctrl.adsc_sth_free;  /* get old chain free */
+       dss_ser_thr_ctrl.adsc_sth_free = adsl_sth_w1;  /* set new chain free */
+       dsg_global_lock.m_leave();           /* leave critical section  */
+//     goto p_sub_poll_00;                  /* do poll now             */
+     }
+   }
+#endif
    iml_timeout = INFTIM;                    /* set infinite            */
    if (iml_endtime_w1 != 0) {               /* end time set            */
      iml_timeout = (iml_endtime_w1 - dsl_time_1) * 1000;
@@ -2085,6 +2263,10 @@
                        __LINE__ );
        dss_ligw_g.imc_time_disconnect = (int) time( NULL );  /* time of disconnect */
        dss_ligw_g.boc_connected = FALSE;    /* not connected to Listen Gateway */
+#ifdef D_INCL_HOB_TUN
+       dss_ligw_g.boc_ser_sent = FALSE;     /* serialize command sent  */
+       dss_ligw_g.imc_open_tun_sent = 0;    /* command open TUN sent   */
+#endif
        iml_rc = close( dss_ligw_g.imc_sockfd );
        if (iml_rc != 0) {                   /* error occured           */
          m_hlnew_printf( HLOG_XYZ1, "HWSPSnnnW nbipgw20 l%05d close socket listen-gateway returned %d %d.",
@@ -2343,6 +2525,10 @@

    p_stpr_60:                               /* end of PID file         */
    dss_ligw_g.boc_connected = FALSE;        /* not connected to Listen Gateway */
+#ifdef D_INCL_HOB_TUN
+   dss_ligw_g.boc_ser_sent = FALSE;         /* serialize command sent  */
+   dss_ligw_g.imc_open_tun_sent = 0;        /* command open TUN sent   */
+#endif
    if (dss_loconf_1.boc_listen_gw == FALSE) {  /* do not use listen gateway */
      goto p_ligw_80;                        /* listen gateway has been initialized */
    }
@@ -2727,182 +2913,6 @@
 #include "xiipgw08-trace.cpp"
 #include "xiipgw08-admin.cpp"

-#ifdef NOT_YET_110808
-/** thread for serializiation                                          */
-static htfunc1_t m_serial_thread( void * ) {
-   int        iml_rc;                       /* return code             */
-   int        iml_error;                    /* error code              */
-   DWORD      dwl_ret;                      /* return code             */
-   struct dsd_ser_thr_task *adsl_sth_w1;    /* working variable        */
-   struct dsd_ser_thr_task dsl_sth_work;    /* work as task for serial thread */
-   MIB_IPFORWARDROW dsl_ipforw_01;          /* to set routes           */
-#ifdef B100731
-#ifdef TRY_HSM_1007
-   unsigned long int uml_ai_buf_len;        /* length of buffer for adapter info */
-   DWORD      dwl_index_if;                 /* holds index of compatible IF */
-   PIP_ADAPTER_INFO adsl_adap_info_w1;      /* points to first adapter info */
-   PIP_ADAPTER_INFO adsl_adap_info_w2;      /* points to first adapter info */
-   IP_ADDR_STRING *adsl_ineta_cur;
-#endif
-#endif
-
-#ifdef B100731
-#ifdef TRY_HSM_1007
-   dwl_index_if = 0;                        /* holds index of compatible IF */
-   uml_ai_buf_len = 0;                      /* length of buffer for adapter info */
-   adsl_adap_info_w1 = NULL;                /* points to first adapter info */
-   dwl_ret = GetAdaptersInfo( adsl_adap_info_w1, &uml_ai_buf_len );
-   if (dwl_ret != ERROR_BUFFER_OVERFLOW) {
-     m_hlnew_printf( HLOG_XYZ1, "nbipgw20-l%05d-W GetAdaptersInfo() returned %d/0X%08X.",
-                     __LINE__, dwl_ret, dwl_ret );
-   }
-   adsl_adap_info_w1 = (PIP_ADAPTER_INFO) malloc( uml_ai_buf_len );
-   dwl_ret = GetAdaptersInfo( adsl_adap_info_w1, &uml_ai_buf_len );
-   if (dwl_ret != ERROR_SUCCESS) {
-     m_hlnew_printf( HLOG_XYZ1, "nbipgw20-l%05d-W GetAdaptersInfo() returned %d/0X%08X.",
-                     __LINE__, dwl_ret, dwl_ret );
-   }
-   adsl_adap_info_w2 = adsl_adap_info_w1;
-   while (adsl_adap_info_w2) {
-     adsl_ineta_cur = &(adsl_adap_info_w2->IpAddressList);
-     /* check all addresses                                            */
-     while (adsl_ineta_cur) {
-#ifndef TRACEHL1_XXX
-       m_hl1_printf( "nbipgw20-l%05d-T m_getindex_if() found INETA \"%s\" Index=%d 0X%08X.",
-                     __LINE__,
-                     adsl_ineta_cur->IpAddress.String,
-                     adsl_adap_info_w1->Index,
-                     inet_addr( adsl_ineta_cur->IpAddress.String ) );
-#endif
-       if (inet_addr( adsl_ineta_cur->IpAddress.String) == *((DWORD *) ucrs_adapter_ineta)) {
-         dwl_index_if = adsl_adap_info_w2->Index;
-         break;
-       }
-       adsl_ineta_cur = adsl_ineta_cur->Next;
-     }
-     if (adsl_ineta_cur) break;
-     /* move to next interface                                         */
-     adsl_adap_info_w2 = adsl_adap_info_w2->Next;
-   }
-   free( adsl_adap_info_w1 );
-#endif
-#endif
-   p_serial_00:                             /* serialisation start     */
-   if (dss_ser_thr_ctrl.adsc_sth_work) {    /* work as task for serial thread */
-     goto p_serial_20;                      /* found work to do        */
-   }
-   iml_rc = dss_ser_thr_ctrl.dsc_event_thr.m_wait( &iml_error );
-   if (iml_rc == 0) goto p_serial_00;       /* serialisation start     */
-// to-do 02.07.10 KB error message
-   m_hlnew_printf( HLOG_WARN1, "xxxxxxxx-%05d-W m_serial_thread thread m_wait Return Code %d Error %d.",
-                   __LINE__, iml_rc, iml_error );
-   Sleep( 2000 );                           /* wait some time          */
-   goto p_serial_00;                        /* serialisation start     */
-
-   p_serial_20:                             /* found work to do        */
-   dsg_global_lock.m_enter();               /* enter critical section  */
-   adsl_sth_w1 = dss_ser_thr_ctrl.adsc_sth_work;  /* get work as task for serial thread */
-   memcpy( &dsl_sth_work, adsl_sth_w1, sizeof(struct dsd_ser_thr_task) );
-   dss_ser_thr_ctrl.adsc_sth_work = adsl_sth_w1->adsc_next;  /* remove from chain */
-   adsl_sth_w1->adsc_next = dss_ser_thr_ctrl.adsc_sth_free;  /* get old chain free */
-   dss_ser_thr_ctrl.adsc_sth_free = adsl_sth_w1;  /* set new chain free */
-   dsg_global_lock.m_leave();               /* leave critical section  */
-   switch (dsl_sth_work.iec_sth) {          /* serial thread task type */
-     case ied_sth_route_ipv4_add:           /* add a route IPV4        */
-#ifdef B100731
-       dwl_ret = CreateProxyArpEntry( *((DWORD *) dsl_sth_work.chrc_ineta),
-                                      0XFFFFFFFF,  /* 255.255.255.255  */
-                                      dwl_index_if );
-#endif
-       dwl_ret = CreateProxyArpEntry( *((DWORD *) dsl_sth_work.chrc_ineta),
-                                      0XFFFFFFFF,  /* 255.255.255.255  */
-                                      *((DWORD *) &dsl_sth_work.umc_index_if_arp) );
-//#ifdef TRACEHL1
-       m_hlnew_printf( HLOG_XYZ1, "nbipgw20-l%05d-T CreateProxyArpEntry() returned %d/0X%08X.\n",
-                       __LINE__, dwl_ret, dwl_ret );
-//#endif
-       memset( &dsl_ipforw_01, 0, sizeof(MIB_IPFORWARDROW) );
-       dsl_ipforw_01.dwForwardProto = MIB_IPPROTO_NETMGMT;
-       dsl_ipforw_01.dwForwardIfIndex = *((DWORD *) &dsl_sth_work.umc_index_if_route);
-       dsl_ipforw_01.dwForwardMetric1 = 100;
-       dsl_ipforw_01.dwForwardMetric2 = -1;
-       dsl_ipforw_01.dwForwardMetric3 = -1;
-       dsl_ipforw_01.dwForwardMetric4 = -1;
-       dsl_ipforw_01.dwForwardMetric5 = -1;
-       dsl_ipforw_01.dwForwardDest = *((DWORD *) dsl_sth_work.chrc_ineta);
-//     dsl_ipforw_01.dwForwardMask = *((DWORD *) ucrs_route_mask);
-       dsl_ipforw_01.dwForwardMask = 0XFFFFFFFF,  /* 255.255.255.255   */
-#ifdef B100731
-       dsl_ipforw_01.dwForwardNextHop = *((DWORD *) ucrs_route_next_hop);
-#endif
-#ifdef B100802
-       dsl_ipforw_01.dwForwardNextHop = *((DWORD *) &dsl_sth_work.umc_taif_ineta);  /* <TUN-adapter-use-interface-ineta> = next hop */
-#endif
-       dsl_ipforw_01.dwForwardNextHop = *((DWORD *) &dsl_sth_work.umc_taif_ineta);  /* <TUN-adapter-use-interface-ineta> = next hop */
-#ifdef TRACEHL1
-       m_console_out( (char *) &dsl_ipforw_01, sizeof(MIB_IPFORWARDROW) );
-#endif
-       dwl_ret = CreateIpForwardEntry( &dsl_ipforw_01 );
-//#ifdef TRACEHL1
-       m_hlnew_printf( HLOG_XYZ1, "nbipgw20-l%05d-T CreateIpForwardEntry() returned %d/0X%08X.\n",
-                       __LINE__, dwl_ret, dwl_ret );
-//#endif
-       if (dwl_ret == NO_ERROR) break;
-// to-do 05.07.10 KB error message
-       break;
-     case ied_sth_route_ipv4_del:           /* delete a route IPV4     */
-       dwl_ret = DeleteProxyArpEntry( *((DWORD *) dsl_sth_work.chrc_ineta),
-                                      0XFFFFFFFF,  /* 255.255.255.255  */
-                                      *((DWORD *) &dsl_sth_work.umc_index_if_arp) );
-#ifdef TRACEHL1
-       m_hlnew_printf( HLOG_XYZ1, "nbipgw20-l%05d-T DeleteProxyArpEntry() returned %d/0X%08X.\n",
-                       __LINE__, dwl_ret, dwl_ret );
-#endif
-       memset( &dsl_ipforw_01, 0, sizeof(MIB_IPFORWARDROW) );
-       dsl_ipforw_01.dwForwardProto = MIB_IPPROTO_NETMGMT;
-       dsl_ipforw_01.dwForwardIfIndex = *((DWORD *) &dsl_sth_work.umc_index_if_route);
-       dsl_ipforw_01.dwForwardMetric1 = 100;
-       dsl_ipforw_01.dwForwardMetric2 = -1;
-       dsl_ipforw_01.dwForwardMetric3 = -1;
-       dsl_ipforw_01.dwForwardMetric4 = -1;
-       dsl_ipforw_01.dwForwardMetric5 = -1;
-       dsl_ipforw_01.dwForwardDest = *((DWORD *) dsl_sth_work.chrc_ineta);
-//     dsl_ipforw_01.dwForwardMask = *((DWORD *) ucrs_route_mask);
-       dsl_ipforw_01.dwForwardMask = 0XFFFFFFFF,  /* 255.255.255.255   */
-#ifdef B100731
-       dsl_ipforw_01.dwForwardNextHop = *((DWORD *) ucrs_route_next_hop);
-#endif
-#ifdef B100802
-       dsl_ipforw_01.dwForwardNextHop = *((DWORD *) &dsl_sth_work.umc_taif_ineta);  /* <TUN-adapter-use-interface-ineta> = next hop */
-#endif
-       dsl_ipforw_01.dwForwardNextHop = *((DWORD *) &dsl_sth_work.umc_taif_ineta);  /* <TUN-adapter-use-interface-ineta> = next hop */
-#ifdef TRACEHL1
-       m_console_out( (char *) &dsl_ipforw_01, sizeof(MIB_IPFORWARDROW) );
-#endif
-       dwl_ret = DeleteIpForwardEntry( &dsl_ipforw_01 );
-//#ifdef TRACEHL1
-       m_hlnew_printf( HLOG_XYZ1, "nbipgw20-l%05d-T DeleteIpForwardEntry() returned %d/0X%08X.\n",
-                       __LINE__, dwl_ret, dwl_ret );
-//#endif
-       if (dwl_ret == NO_ERROR) break;
-// to-do 08.08.10 KB error message
-       break;
-   }
-   if (dsl_sth_work.aboc_posted) {          /* with mark posted        */
-     *dsl_sth_work.aboc_posted = TRUE;      /* mark posted             */
-   }
-   if (dsl_sth_work.adsc_event_posted) {    /* event for posted        */
-     iml_rc = dsl_sth_work.adsc_event_posted->m_post( &iml_error );  /* event for posted */
-// to-do 02.07.10 KB error message
-     if (iml_rc < 0) {                     /* error occured           */
-       m_hl1_printf( "xxxxxxxr-%05d-W m_hco_shutdown thread m_post Return Code %d Error %d",
-                     __LINE__, iml_rc, iml_error );
-     }
-   }
-   goto p_serial_00;                        /* serialisation start     */
-} /* end m_serial_thread()                                             */
-#endif
-
 /** call DOM for subroutines                                           */
 extern "C" void * m_call_dom( DOMNode *adsp_domnode, ied_hlcldom_def iep_hlcldom_def ) {
 #ifdef TRACEHL1
@@ -3420,6 +3430,9 @@

 /** TCPCOMP connect callback function                                  */
 static void m_cb_tcpc_connect( struct dsd_tcpcomp *adsp_tcpco, void *vpp_userfld,
+#ifndef B121121
+                               struct dsd_target_ineta_1 *, void * ap_free_ti1,  /* INETA to free */
+#endif
                                struct sockaddr *adsp_soa, socklen_t imp_len_soa, int imp_error ) {
    int        iml_rc;                       /* return code             */
    char       *achl_msg_no;                 /* message number          */
@@ -3726,6 +3739,7 @@
 #undef ADSL_CONNECT_G
 } /* end m_cb_tcpc_cleanup()                                           */

+#ifdef B121121
 /** TCPCOMP free target INETA                                          */
 static void m_cb_tcpc_free_target_ineta( dsd_tcpcomp *adsp_tcpcomp, void *vpp_userfld,
                                          const struct dsd_target_ineta_1 *adsp_target_ineta_1 ) {
@@ -3749,6 +3763,7 @@
 #endif
    return;
 } /* end m_cb_tcpc_free_target_ineta()                                 */
+#endif

 /** post network resource for TCP connection                           */
 static void m_tc1_post_netw_post_1( struct dsd_tcp_ctrl_1 *adsp_tc1, int imp_select ) {
@@ -4947,7 +4962,9 @@
 static void m_start_rec_server( struct dsd_pd_work *adsp_pd_work ) {
    BOOL       bol1;                         /* working variable        */
    int        inl1;                         /* working variable        */
+#ifdef B121121
    BOOL       bol_next_conn;                /* try next connection     */
+#endif
    BOOL       bol_start_sdh;                /* start Server-Data-Hook  */
    char       *achl1, *achl2;               /* working variables       */
 #ifdef NOT_YET_110808
@@ -5045,6 +5062,7 @@
 #ifdef TRACEHL1
        m_hlnew_printf( HLOG_XYZ1, "nbipgw20.cpp l%05d clconn1::m_start_rec_server() do connect()", __LINE__ );
 #endif
+#ifdef B121121
        adsl_server_ineta_w1 = ADSL_CONN1_G->adsc_server_conf_1->adsc_server_ineta;  /* server INETA */
        iml_tcpcomp_state = 0;               /* value of TCPCOMP state  */
 #ifdef D_INCL_HOB_TUN
@@ -5107,6 +5125,9 @@
                   ADSL_CONN1_G,
                   &ADSL_CONN1_G->adsc_server_conf_1->dsc_bind_out,
                   adsl_server_ineta_w1,     /* server INETA            */
+#ifndef B121121
+                  NULL,
+#endif
                   ADSL_CONN1_G->adsc_server_conf_1->inc_server_port,  /* TCP/IP port connect */
                   ADSL_CONN1_G->adsc_server_conf_1->boc_connect_round_robin );  /* do connect round-robin */
        if (iml_rc == 0) return;             /* no error occured        */
@@ -5116,6 +5137,17 @@
                        ADSL_CONN1_G->adsc_gate1 + 1, ADSL_CONN1_G->dsc_co_sort.imc_sno, ADSL_CONN1_G->chrc_ineta, __LINE__, iml_rc );
 // to-do 13.08.10 KB what to do ???
        return;
+#endif
+#ifndef B121121
+       iml_rc = m_tcp_static_conn( ADSL_AUX_CF1, FALSE );
+       if (iml_rc == 0) return;             /* no error occured        */
+       ADSL_CONN1_G->dsc_tc1_server.boc_connected = FALSE;  /* TCP session is not connected */
+//     boc_tcpc_act = FALSE;                /* TCPCOMP not active      */
+       m_hlnew_printf( HLOG_XYZ1, "HWSPS175W GATE=%(ux)s SNO=%08d INETA=%s nbipgw20 l%05d m_tcp_static_conn() failed %d.",
+                       ADSL_CONN1_G->adsc_gate1 + 1, ADSL_CONN1_G->dsc_co_sort.imc_sno, ADSL_CONN1_G->chrc_ineta, __LINE__, iml_rc );
+// to-do 21.11.12 KB what to do ???
+       return;
+#endif
      } while (FALSE);
      if (ADSL_CONN1_G->adsc_wsp_auth_1) {   /* authentication active   */
        ADSL_CONN1_G->adsc_wsp_auth_1->boc_did_connect = TRUE;  /* did connect */
@@ -5315,6 +5347,7 @@
 #ifdef D_INCL_HOB_TUN
    goto p_strecs_40;                        /* continue start receive server */

+#ifdef B121121
    p_strecs_20:                             /* start HOB-TUN - entry HTCP */
    adsl_soa_w1 = (struct sockaddr *) &adsl_ineta_raws_1_w1->dsc_tun_contr_ineta.dsc_soa_local_ipv4;
    iml_local_namelen = sizeof(struct sockaddr_in);
@@ -5359,6 +5392,7 @@
    m_hlnew_printf( HLOG_XYZ1, "nbipgw20-l%05d-T clconn1::m_start_rec_server() m_htun_new_sess_htcp() handle %p &dsc_tun_contr_conn=%p.",
                    __LINE__, adsl_ineta_raws_1_w1->dsc_htun_h, &ADSL_CONN1_G->dsc_tun_contr_conn );
    return;                                  /* wait till connect complete */
+#endif

    p_strecs_24:                             /* start HOB-TUN - PPP     */
 #ifdef XYZ1
@@ -5439,6 +5473,8 @@
    ADSL_CONN1_G->iec_servcotype = ied_servcotype_htun;  /* HOB-TUN     */
    ADSL_CONN1_G->adsc_sdhc1_htun_sch = NULL;  /* no buffers to send    */
    ADSL_CONN1_G->imc_send_window = 0;       /* number of bytes to be sent */
+   ADSL_CONN1_G->imc_ppp_state;             /* PPP state               */
+   ADSL_CONN1_G->adsc_ppp_netw_post_1 = NULL;  /* structure to post from network callback */
    dsl_tun_start_ppp.adsc_htun_h = (void **) &ADSL_CONN1_G->dsc_htun_h;  /* where to put the handle created */
    m_htun_new_sess_ppp( &dsl_tun_start_ppp, &ADSL_CONN1_G->dsc_tun_contr_conn );
    ADSL_CONN1_G->iec_st_ses = ied_ses_start_server_1;  /* status server continue */
@@ -6562,10 +6598,10 @@
    imrl_send_li_gw[ 2 ] = D_LI_GW_VERSION;  /* version of listen gateway */
    imrl_send_li_gw[ 3 ] = getpid();         /* get our process ID      */
    *((unsigned char *) imrl_send_li_gw + sizeof(int) - 1) = ied_ligwq_start;  /* start of WSP */
-   bol1 = m_ligw_send( (char *) imrl_send_li_gw + sizeof(int) - 1, sizeof(imrl_send_li_gw) - (sizeof(int) - 1));
+   bol1 = m_ligw_send( (char *) imrl_send_li_gw + sizeof(int) - 1, sizeof(imrl_send_li_gw) - (sizeof(int) - 1), NULL );
    if (bol1 == FALSE) return;               /* connection listen-gateway not open */
    if (dss_ligw_g.aimrc_ligw_cluster) {     /* check cluster structure */
-     bol1 = m_ligw_send( (char *) dss_ligw_g.aimrc_ligw_cluster + 2 * sizeof(int) - 1, dss_ligw_g.aimrc_ligw_cluster[ 0 ] + 1);
+     bol1 = m_ligw_send( (char *) dss_ligw_g.aimrc_ligw_cluster + 2 * sizeof(int) - 1, dss_ligw_g.aimrc_ligw_cluster[ 0 ] + 1, NULL );
      if (bol1 == FALSE) return;             /* connection listen-gateway not open */
    }
    dss_ligw_g.adsc_gate_listen_1_cur = NULL;  /* listen part of gateway currently processed */
@@ -6612,11 +6648,22 @@
    if (dss_ligw_g.boc_listen_start == FALSE) {  /* not start listen at program start */
      dss_ligw_g.adsc_gate_listen_1_next = adsl_gate_listen_1_w1->adsc_next;
      if (dss_ligw_g.adsc_gate_listen_1_next == NULL) {
+#ifdef B121107
        dss_ligw_g.adsc_gate_1_create_socket = dss_ligw_g.adsc_gate_1_create_socket->adsc_next;
        while (   (dss_ligw_g.adsc_gate_1_create_socket)
               && (dss_ligw_g.adsc_gate_1_create_socket->boc_not_close_lbal)) {  /* no close listen by load-balancing */
          dss_ligw_g.adsc_gate_1_create_socket = dss_ligw_g.adsc_gate_1_create_socket->adsc_next;
        }
+#endif
+       adsl_gate_1_create_socket_w1 = dss_ligw_g.adsc_gate_1_create_socket;  /* get current gateway */
+       if (adsl_gate_1_create_socket_w1) {  /* more to do              */
+         adsl_gate_1_create_socket_w1 = adsl_gate_1_create_socket_w1->adsc_next;  /* get next in chain */
+         while (   (adsl_gate_1_create_socket_w1)
+                && (adsl_gate_1_create_socket_w1->boc_not_close_lbal)) {  /* no close listen by load-balancing */
+           adsl_gate_1_create_socket_w1 = adsl_gate_1_create_socket_w1->adsc_next;  /* get next in chain */
+         }
+       }
+       dss_ligw_g.adsc_gate_1_create_socket = adsl_gate_1_create_socket_w1;
      }
    }
    /* prepare packet to be sent to listen-gateway                      */
@@ -6646,17 +6693,18 @@
 #endif
    memcpy( ADSL_CREATE_SOCKET_LIGW + 1, achl1, iml1 );  /* copy INETA  */
    chrl_send_buf[ 0 ] = (unsigned char) ied_ligwq_socket;  /* create socket */
-   m_ligw_send( chrl_send_buf, 1 + sizeof(struct dsd_create_socket_ligw) + iml1 );
+   m_ligw_send( chrl_send_buf, 1 + sizeof(struct dsd_create_socket_ligw) + iml1, NULL );

 #undef ADSL_CREATE_SOCKET_LIGW

 } /* end m_ligw_create_socket()                                        */

 /** send a record encrypted to the listen-gateway                      */
-static BOOL m_ligw_send( char *achp_content, int imp_len_content ) {
+static BOOL m_ligw_send( char *achp_content, int imp_len_content, struct msghdr *adsp_msghdr ) {
    int        iml_rc;                       /* return code             */
    int        iml1, iml2;                   /* working variables       */
    char       *achl1, *achl2, *achl3;       /* working variables       */
+   struct iovec dsrl_iov[1];                /* vector containing send data */
    int        imrl_sha1[ SHA_ARRAY_SIZE ];  /* for hash                */
    char       chrl_sha1_out[ D_LIGW_RANDOM_L ];  /* output of SHA-1    */
    char       chrl_send_buf[ 512 ];         /* send buffer             */
@@ -6704,41 +6752,57 @@
    } while (achl1 < achl2);
    /* send data to the listen gateway                                  */
    iml1 = achl2 - chrl_send_buf;            /* length to send          */
-   iml_rc = write( dss_ligw_g.imc_sockfd, chrl_send_buf, iml1 );
+   if (adsp_msghdr == NULL) {
+     iml_rc = write( dss_ligw_g.imc_sockfd, chrl_send_buf, iml1 );
+   } else {
+     dsrl_iov[ 0 ].iov_base = chrl_send_buf;
+     dsrl_iov[ 0 ].iov_len = iml1;
+     adsp_msghdr->msg_iov = dsrl_iov;
+     adsp_msghdr->msg_iovlen = 1;
+     iml_rc = sendmsg( dss_ligw_g.imc_sockfd, adsp_msghdr, 0 );
+   }
 #ifdef TRACEHL1
    iml2 = errno;                            /* save errno              */
-   m_hlnew_printf( HLOG_XYZ1, "nbipgw20-l%05d-T write() to listen-gateway returned=%d %d.",
+   m_hlnew_printf( HLOG_XYZ1, "nbipgw20-l%05d-T write() / sendmsg() to listen-gateway returned=%d %d.",
                    __LINE__, iml_rc, iml2 );
    errno = iml2;                            /* restore errno           */
 #endif
 #ifdef DEBUG_121023_01                      /* debug listen-gateway create socket */
    iml2 = errno;                            /* save errno              */
-   m_hlnew_printf( HLOG_TRACE1, "nbipgw20-l%05d-T m_ligw_send() write() returned %d errno %d.",
+   m_hlnew_printf( HLOG_TRACE1, "nbipgw20-l%05d-T m_ligw_send() write() / sendmsg() returned %d errno %d.",
                    __LINE__, iml_rc, iml2 );
    errno = iml2;                            /* restore errno           */
 #endif
    if (iml_rc == iml1) return TRUE;         /* write succeeded         */
    if (   (iml_rc < 0)                      /* returned error          */
        && (errno == ENOTCONN)) {            /* 107 / Transport endpoint is not connected */
-     m_hlnew_printf( HLOG_XYZ1, "HWSPSxxxW l%05d listen-gateway write failed because not connected",
+     m_hlnew_printf( HLOG_WARN1, "HWSPM134W l%05d listen-gateway write() / sendmsg() failed because not connected",
                      __LINE__ );
      dss_ligw_g.imc_time_disconnect = (int) time( NULL );  /* time of disconnect */
      dss_ligw_g.boc_connected = FALSE;      /* not connected to Listen Gateway */
+#ifdef D_INCL_HOB_TUN
+     dss_ligw_g.boc_ser_sent = FALSE;       /* serialize command sent  */
+     dss_ligw_g.imc_open_tun_sent = 0;      /* command open TUN sent   */
+#endif
      iml_rc = close( dss_ligw_g.imc_sockfd );
      if (iml_rc != 0) {                     /* error occured           */
-       m_hlnew_printf( HLOG_XYZ1, "HWSPSnnnW nbipgw20 l%05d close socket listen-gateway returned %d %d.",
+       m_hlnew_printf( HLOG_WARN1, "HWSPM135W nbipgw20 l%05d close socket listen-gateway returned %d %d.",
                        __LINE__, iml_rc, errno );
      }
      return FALSE;                          /* all done                */
    }
    /* write returned error                                             */
-   m_hlnew_printf( HLOG_XYZ1, "HWSPSnnnW l%05d listen-gateway write returned %d %d.",
+   m_hlnew_printf( HLOG_WARN1, "HWSPM136W l%05d listen-gateway write() / sendmsg() returned %d %d.",
                    __LINE__, iml_rc, errno );
    dss_ligw_g.imc_time_disconnect = (int) time( NULL );  /* time of disconnect */
    dss_ligw_g.boc_connected = FALSE;        /* not connected to Listen Gateway */
+#ifdef D_INCL_HOB_TUN
+   dss_ligw_g.boc_ser_sent = FALSE;         /* serialize command sent  */
+   dss_ligw_g.imc_open_tun_sent = 0;        /* command open TUN sent   */
+#endif
    iml_rc = close( dss_ligw_g.imc_sockfd );
    if (iml_rc != 0) {                       /* error occured           */
-     m_hlnew_printf( HLOG_XYZ1, "HWSPSnnnW nbipgw20 l%05d close socket listen-gateway returned %d %d.",
+     m_hlnew_printf( HLOG_WARN1, "HWSPM137W nbipgw20 l%05d close socket listen-gateway returned %d %d.",
                      __LINE__, iml_rc, errno );
    }
    return FALSE;                            /* all done                */
@@ -6747,6 +6811,9 @@
 /** receive from the listen-gateway                                    */
 static void m_ligw_recv( void ) {
    int        iml_rc;                       /* return code             */
+#ifdef D_INCL_HOB_TUN
+   int        iml_error;                    /* error code              */
+#endif
    int        iml1, iml2, iml3;             /* working variables       */
    int        iml_socket;                   /* socket received         */
    enum ied_decode_ligw_recv_1 iel_dlr1;    /* decode received from listen-gateway */
@@ -6755,6 +6822,9 @@
    struct dsd_ligw_receive *adsl_rec1_w1;   /* area for receive        */
    struct dsd_gather_i_1 *adsl_gai1_w1;     /* gather input            */
    struct dsd_gather_i_1 *adsl_gai1_w2;     /* gather input            */
+#ifdef D_INCL_HOB_TUN
+   struct dsd_ser_thr_task *adsl_sth_w1;    /* working variable        */
+#endif
    struct msghdr dsl_msg;                   /* message structure       */
    struct iovec dsrl_iov[1];                /* vector containing send data */
 #ifdef MSGHDR_CONTROL_AVAILABLE
@@ -6764,11 +6834,16 @@
    } dsl_control_un;
    struct cmsghdr *adsl_cmd;
 #endif
+#ifdef D_INCL_HOB_TUN
+   struct dsd_ser_thr_task dsl_sth_work;    /* work as task for serial thread */
+#endif
    int        imrl_w1[ 3 ];                 /* array of int            */
    char       chrl_input[ 512 ];            /* input received          */

-   m_hlnew_printf( HLOG_XYZ1, "nbipgw20-l%05d-T m_ligw_recv() called",
+#ifdef DEBUG_121116_01                      /* debug listen-gateway    */
+   m_hlnew_printf( HLOG_TRACE1, "nbipgw20-l%05d-T m_ligw_recv() called",
                    __LINE__ );
+#endif
    adsl_receive_in1 = (struct dsd_ligw_receive *) m_proc_alloc();  /* receive buffer */
 #ifdef B110913
    iml_rc = recv( dss_ligw_g.imc_sockfd,
@@ -6802,10 +6877,10 @@
    dsl_msg.msg_iov = dsrl_iov;
    dsl_msg.msg_iovlen = 1;

-   iml_rc = recvmsg( dss_ligw_g.imc_sockfd, &dsl_msg, 0);
+   iml_rc = recvmsg( dss_ligw_g.imc_sockfd, &dsl_msg, 0 );
    if (iml_rc <= 0) {                       /* no data received        */
 // to-do 12.09.11 KB error message
-     m_hlnew_printf( HLOG_XYZ1, "nbipgw20-l%05d-T m_ligw_recv() called iml_rc=%d errno=%d - no data",
+     m_hlnew_printf( HLOG_XYZ1, "HWSPM160W nbipgw20 l%05d m_ligw_recv() called iml_rc=%d errno=%d - no data",
                      __LINE__, iml_rc, errno );
      m_proc_free( adsl_receive_in1 );       /* free storage            */
      m_ligw_close();                        /* close connection to listen-gateway */
@@ -6869,6 +6944,13 @@
 #endif
    iml1 = adsl_gai1_w1->achc_ginp_end - achl3;  /* length of input     */
    if (iml1 <= 0) goto p_recv_sc_60;        /* end of this gather      */
+#ifdef DEBUG_121116_01                      /* debug listen-gateway    */
+   m_hlnew_printf( HLOG_TRACE1, "nbipgw20-l%05d-T p_recv_sc_20: iel_dlr1=%d achl1=%p achl2=%p achl3=%p.",
+                   __LINE__, iel_dlr1, achl1, achl2, achl3 );
+   m_hlnew_printf( HLOG_TRACE1, "nbipgw20-l%05d-T p_recv_sc_20: length iml1=%d state iel_dlr1=%d.",
+                   __LINE__, iml1, iel_dlr1 );
+   m_console_out( achl3, iml1 );
+#endif
    switch (iel_dlr1) {                      /* decode received from listen-gateway */
      case ied_dlr1_header:                  /* header received         */
        iml2 = achl2 - achl1;                /* length remaining output */
@@ -6882,6 +6964,12 @@
          adsl_wsp_conn_w1->dsc_connect.dsc_tcpco1.m_end_session();  /* stop session */
          return FALSE;                      /* do not receive more     */
 #endif
+         m_hlnew_printf( HLOG_WARN1, "HWSPM161W nbipgw20 l%05d m_ligw_recv() input eye-catcher does not compare pos=%d.",
+                         __LINE__, achl1 - chrs_requestheader_query );
+#ifdef DEBUG_121116_01                      /* debug listen-gateway    */
+         m_hlnew_printf( HLOG_TRACE1, "nbipgw20-l%05d-T call m_ligw_close()",
+                         __LINE__ );
+#endif
          m_ligw_close();                    /* close connection to listen-gateway */
          return;
        }
@@ -6906,6 +6994,12 @@
            adsl_wsp_conn_w1->dsc_connect.dsc_tcpco1.m_end_session();  /* stop session */
            return FALSE;                    /* do not receive more     */
 #endif
+           m_hlnew_printf( HLOG_WARN1, "HWSPM162W nbipgw20 l%05d m_ligw_recv() input length NHASN contains too many digits",
+                           __LINE__ );
+#ifdef DEBUG_121116_01                      /* debug listen-gateway    */
+           m_hlnew_printf( HLOG_TRACE1, "nbipgw20-l%05d-T call m_ligw_close()",
+                           __LINE__ );
+#endif
            m_ligw_close();                  /* close connection to listen-gateway */
            return;
          }
@@ -6919,6 +7013,12 @@
          adsl_wsp_conn_w1->dsc_connect.dsc_tcpco1.m_end_session();  /* stop session */
          return FALSE;                      /* do not receive more     */
 #endif
+         m_hlnew_printf( HLOG_WARN1, "HWSPM163W nbipgw20 l%05d m_ligw_recv() input content length zero invalid",
+                         __LINE__ );
+#ifdef DEBUG_121116_01                      /* debug listen-gateway    */
+         m_hlnew_printf( HLOG_TRACE1, "nbipgw20-l%05d-T call m_ligw_close()",
+                         __LINE__ );
+#endif
          m_ligw_close();                    /* close connection to listen-gateway */
          return;
        }
@@ -6947,7 +7047,13 @@
        }
        achl3 -= iml1;                       /* input has not been consumed */
        if (iml3 > sizeof(chrl_input)) {
+         m_hlnew_printf( HLOG_WARN1, "HWSPM164W nbipgw20 l%05d m_ligw_recv() input content longer than prepared area",
+                         __LINE__ );
 // to-do 12.09.11 KB error message
+#ifdef DEBUG_121116_01                      /* debug listen-gateway    */
+         m_hlnew_printf( HLOG_TRACE1, "nbipgw20-l%05d-T call m_ligw_close()",
+                         __LINE__ );
+#endif
          m_ligw_close();                    /* close connection to listen-gateway */
          return;
        }
@@ -6979,6 +7085,9 @@
 #ifdef TRACEHL1
    m_console_out( achl1, iml1 );
 #endif
+#ifdef DEBUG_121116_01                      /* debug listen-gateway    */
+   m_console_out( achl1, iml1 );
+#endif
    adsl_gai1_w1->achc_ginp_cur = achl3;     /* processed till here     */
    switch ((enum ied_li_gw_response) *achl1) {
      case ied_ligwr_msg:                    /* message                 */
@@ -6989,6 +7098,16 @@
        achl1++;                             /* after tag               */
        iml1--;                              /* minus length tag        */
        do {                                 /* loop to open Unix domain socket connection */
+         if (iml1 < sizeof(int)) {
+           m_hlnew_printf( HLOG_WARN1, "HWSPM165W nbipgw20 l%05d m_ligw_recv() input ied_ligwr_wsps too short",
+                           __LINE__ );
+#ifdef DEBUG_121116_01                      /* debug listen-gateway    */
+           m_hlnew_printf( HLOG_TRACE1, "nbipgw20-l%05d-T call m_ligw_close()",
+                           __LINE__ );
+#endif
+           m_ligw_close();                  /* close connection to listen-gateway */
+           return;
+         }
          memcpy( &iml2, achl1, sizeof(int) );  /* for alignment        */
          m_cluster_ligw_conn( iml2 );       /* connect to WSP          */
          achl1 += sizeof(int);              /* after this              */
@@ -6998,6 +7117,8 @@
      case ied_ligwr_resp_socket_ok:         /* create socket succeeded */
        if (iml1 != 1) {                     /* check length sent      */
 // to-do 14.09.11 KB error message
+         m_hlnew_printf( HLOG_WARN1, "HWSPM166W nbipgw20 l%05d m_ligw_recv() input ied_ligwr_resp_socket_ok length %d invalid",
+                         __LINE__, iml1 );
          break;
        }
 #ifdef MSGHDR_CONTROL_AVAILABLE
@@ -7006,7 +7127,7 @@
            || (adsl_cmd->cmsg_len != CMSG_LEN(sizeof(int)))
            || (adsl_cmd->cmsg_level != SOL_SOCKET)
            || (adsl_cmd->cmsg_type != SCM_RIGHTS)) {
-         m_hlnew_printf( HLOG_XYZ1, "HWSPSxxxW l%05d listen-gateway recvmsg() no descriptor in message",
+         m_hlnew_printf( HLOG_WARN1, "HWSPM167W nbipgw20 l%05d listen-gateway recvmsg() no descriptor in message",
                          __LINE__ );
          dss_ligw_g.adsc_gate_listen_1_cur = NULL;  /* no listen currently processed */
          break;                             /* all done                */
@@ -7014,7 +7135,7 @@
        iml_socket = *((int *) CMSG_DATA( adsl_cmd ));
 #else
        if (dsl_msg.msg_accrightslen != sizeof(int)) {
-         m_hlnew_printf( HLOG_XYZ1, "HWSPSxxxW l%05d listen-gateway recvmsg() no descriptor in message",
+         m_hlnew_printf( HLOG_WARN1, "HWSPM167W nbipgw20 l%05d listen-gateway recvmsg() no descriptor in message",
                          __LINE__ );
          dss_ligw_g.adsc_gate_listen_1_cur = NULL;  /* no listen currently processed */
          break;                             /* all done                */
@@ -7055,7 +7176,7 @@
        iml_rc = listen( dss_ligw_g.adsc_gate_listen_1_cur->imc_socket,
                         dss_ligw_g.adsc_gate_listen_1_cur->adsc_gate_1->imc_backlog );
        if (iml_rc) {                        /* error occured           */
-         m_hlnew_printf( HLOG_XYZ1, "HWSPxxxxW l%05d Error listen() gate \"%(ux)s\" returned %d %d.",
+         m_hlnew_printf( HLOG_WARN1, "HWSPM168W nbipgw20 l%05d Error listen() gate \"%(ux)s\" returned %d %d.",
                          __LINE__, dss_ligw_g.adsc_gate_listen_1_cur->adsc_gate_1 + 1, iml_rc, D_TCP_ERROR );
          break;
        }
@@ -7078,23 +7199,27 @@
        dss_ligw_g.adsc_gate_listen_1_cur->boc_active = TRUE;  /* listen is active now */
        dss_ligw_g.adsc_gate_listen_1_cur = NULL;  /* no listen currently processed */
        if (dss_ligw_g.adsc_gate_1_create_socket) break;  /* current gate to start */
+#ifdef B121107
 // to-do 30.10.12 KB - superflous
        if (dss_ligw_g.adsc_gate_listen_1_next) break;  /* listen part of gateway next to process */
+#endif
        dsg_sys_state_1.boc_listen_active = TRUE;  /* listen is currently active */
 #ifdef DEBUG_121023_01                      /* debug listen-gateway create socket */
        m_hlnew_printf( HLOG_TRACE1, "nbipgw20-l%05d-T m_ligw_recv() dss_ligw_g.adsc_gate_1_create_socket=%p dss_ligw_g.adsc_gate_listen_1_cur=%p
dss_ligw_g.adsc_gate_listen_1_next=%p dsg_sys_state_1.boc_listen_active=%d.",
                        __LINE__, dss_ligw_g.adsc_gate_1_create_socket, dss_ligw_g.adsc_gate_listen_1_cur, dss_ligw_g.adsc_gate_listen_1_next, dsg_sys_state_1.boc_listen_active );
 #endif
-       m_status_cluster_lbal();             /* notify other cluster members */
+       m_status_cluster_lbal( TRUE );       /* notify other cluster members */
        break;                               /* all done                */
      case ied_ligwr_resp_socket_failed:     /* create socket failed    */
        if (iml1 != (1 + 3 * sizeof(int))) {  /* check length sent      */
 // to-do 14.09.11 KB error message
+         m_hlnew_printf( HLOG_WARN1, "HWSPM169W nbipgw20 l%05d m_ligw_recv() input ied_ligwr_resp_socket_failed length %d invalid",
+                         __LINE__, iml1 );
          break;
        }
 // to-do 14.09.11 KB error message
        memcpy( imrl_w1, achl1 + 1, 3 * sizeof(int) );  /* for alignment */
-       m_hlnew_printf( HLOG_INFO1, "HWSPMnnnW Listen-Gateway responded error to create socket %d %d %d.",
+       m_hlnew_printf( HLOG_WARN1, "HWSPM170W Listen-Gateway responded error to create socket %d %d %d.",
                        imrl_w1[ 0 ], imrl_w1[ 1 ], imrl_w1[ 2 ] );
        if (dss_ligw_g.adsc_gate_listen_1_cur == NULL) {  /* listen part of gateway currently processed */
 // to-do 14.09.11 KB error message
@@ -7111,19 +7236,131 @@
                        __LINE__, dss_ligw_g.adsc_gate_1_create_socket, dss_ligw_g.adsc_gate_listen_1_cur, dss_ligw_g.adsc_gate_listen_1_next, dsg_sys_state_1.boc_listen_active );
 #endif
        if (dss_ligw_g.adsc_gate_1_create_socket) break;  /* current gate to start */
+#ifdef B121107
 // to-do 30.10.12 KB - superflous
        if (dss_ligw_g.adsc_gate_listen_1_next) break;  /* listen part of gateway next to process */
+#endif
        dsg_sys_state_1.boc_listen_active = TRUE;  /* listen is currently active */
-       m_status_cluster_lbal();             /* notify other cluster members */
+       m_status_cluster_lbal( TRUE );       /* notify other cluster members */
 #ifdef DEBUG_121023_01                      /* debug listen-gateway create socket */
        m_hlnew_printf( HLOG_TRACE1, "nbipgw20-l%05d-T m_ligw_recv() dss_ligw_g.adsc_gate_1_create_socket=%p dss_ligw_g.adsc_gate_listen_1_cur=%p
dss_ligw_g.adsc_gate_listen_1_next=%p dsg_sys_state_1.boc_listen_active=%d.",
                        __LINE__, dss_ligw_g.adsc_gate_1_create_socket, dss_ligw_g.adsc_gate_listen_1_cur, dss_ligw_g.adsc_gate_listen_1_next, dsg_sys_state_1.boc_listen_active );
 #endif
        break;                               /* all done                */
+#ifdef D_INCL_HOB_TUN
+     case ied_ligwr_resp_open_tun:          /* open TUN adapter        */
+       if (iml1 != (1 + sizeof(struct dsd_ligw_r_open_tun))) {  /* check length sent */
+// to-do 14.09.11 KB error message
+         m_hlnew_printf( HLOG_WARN1, "HWSPMnnnW nbipgw20 l%05d m_ligw_recv() input ied_ligwr_resp_open_tun length %d invalid",
+                         __LINE__, iml1 );
+         break;
+       }
+       if (dss_ligw_g.imc_open_tun_sent != 1) {  /* command open TUN sent */
+         m_hlnew_printf( HLOG_WARN1, "HWSPMnnnW l%05d Listen-Gateway responded ied_ligwr_resp_open_tun but no command sent",
+                         __LINE__ );
+         break;
+       }
+#define ADSL_RESP_OPEN_TUN_G ((struct dsd_ligw_r_open_tun *) (achl1 + 1))  /* response open TUN adapter */
+       if (ADSL_RESP_OPEN_TUN_G->ucc_index_ineta_ipv4 == 0) {  /* index of INETA IPV4 + 1 */
+         m_hlnew_printf( HLOG_WARN1, "HWSPMnnnW nbipgw20 l%05d m_ligw_recv() input ied_ligwr_resp_open_tun no free <TUN-adapter-ineta> IPV4 found",
+                         __LINE__ );
+       } else {                             /* assigned INETA to adapter */
+         dss_tun_ctrl.achc_ta_ineta_ipv4    /* entry <TUN-adapter-ineta> IPV4 */
+           = &dss_loconf_1.adsc_raw_packet_if_conf->achc_ar_ta_ineta_ipv4[ (ADSL_RESP_OPEN_TUN_G->ucc_index_ineta_ipv4 - 1) * 4 ];  /* entry array <TUN-adapter-ineta> IPV4 */
+       }
+       memcpy( dss_tun_ctrl.chrc_tiface, ADSL_RESP_OPEN_TUN_G->chrc_tiface, IFNAMSIZ );
+#undef ADSL_RESP_OPEN_TUN_G
+       dss_ligw_g.imc_open_tun_sent = 2;    /* command open TUN sent   */
+       break;                               /* all done                */
+     case ied_ligwr_resp_arproute_add_ipv4:  /* add ARP and route IPV4 */
+       if (iml1 != 1) {                     /* check length sent       */
+// to-do 14.09.11 KB error message
+         m_hlnew_printf( HLOG_WARN1, "HWSPMnnnW nbipgw20 l%05d m_ligw_recv() input ied_ligwr_resp_arproute_add_ipv4 length %d invalid",
+                         __LINE__, iml1 );
+         break;
+       }
+       if (   (dss_ser_thr_ctrl.adsc_sth_work == NULL)  /* work as task for serial thread */
+           || (dss_ligw_g.boc_ser_sent == FALSE)) {  /* serialize command sent */
+         m_hlnew_printf( HLOG_WARN1, "HWSPMnnnW l%05d Listen-Gateway responded ied_ligwr_resp_arproute_add_ipv4 but no command sent",
+                         __LINE__ );
+         break;
+       }
+       if (dss_ser_thr_ctrl.adsc_sth_work->iec_sth  /* serial thread task type */
+             != ied_sth_route_ipv4_add) {   /* add a route IPV4        */
+         m_hlnew_printf( HLOG_WARN1, "HWSPMnnnW l%05d Listen-Gateway responded ied_ligwr_resp_arproute_add_ipv4 but not command ied_sth_route_ipv4_add sent",
+                         __LINE__ );
+         break;
+       }
+       dsg_global_lock.m_enter();           /* enter critical section  */
+       adsl_sth_w1 = dss_ser_thr_ctrl.adsc_sth_work;  /* get work as task for serial thread */
+       memcpy( &dsl_sth_work, adsl_sth_w1, sizeof(struct dsd_ser_thr_task) );
+       dss_ser_thr_ctrl.adsc_sth_work = adsl_sth_w1->adsc_next;  /* remove from chain */
+       adsl_sth_w1->adsc_next = dss_ser_thr_ctrl.adsc_sth_free;  /* get old chain free */
+       dss_ser_thr_ctrl.adsc_sth_free = adsl_sth_w1;  /* set new chain free */
+       dsg_global_lock.m_leave();           /* leave critical section  */
+       if (dsl_sth_work.aboc_posted) {      /* with mark posted        */
+         *dsl_sth_work.aboc_posted = TRUE;  /* mark posted             */
+       }
+       if (dsl_sth_work.adsc_event_posted) {  /* event for posted      */
+         iml_rc = dsl_sth_work.adsc_event_posted->m_post( &iml_error );  /* event for posted */
+// to-do 02.07.10 KB error message
+         if (iml_rc < 0) {                     /* error occured           */
+           m_hl1_printf( "xxxxxxxr-%05d-W m_ligw_recv() thread m_post Return Code %d Error %d",
+                         __LINE__, iml_rc, iml_error );
+         }
+       }
+       dss_ligw_g.boc_ser_sent = FALSE;     /* serialize command sent  */
+       break;                               /* all done                */
+     case ied_ligwr_resp_arproute_del_ipv4:  /* del ARP and route IPV4 */
+       if (iml1 != 1) {                     /* check length sent       */
+// to-do 14.09.11 KB error message
+         m_hlnew_printf( HLOG_WARN1, "HWSPMnnnW nbipgw20 l%05d m_ligw_recv() input ied_ligwr_resp_arproute_del_ipv4 length %d invalid",
+                         __LINE__, iml1 );
+         break;
+       }
+       if (   (dss_ser_thr_ctrl.adsc_sth_work == NULL)  /* work as task for serial thread */
+           || (dss_ligw_g.boc_ser_sent == FALSE)) {  /* serialize command sent */
+         m_hlnew_printf( HLOG_WARN1, "HWSPMnnnW l%05d Listen-Gateway responded ied_ligwr_resp_arproute_del_ipv4 but no command sent",
+                         __LINE__ );
+         break;
+       }
+       if (dss_ser_thr_ctrl.adsc_sth_work->iec_sth  /* serial thread task type */
+             != ied_sth_route_ipv4_del) {   /* del a route IPV4        */
+         m_hlnew_printf( HLOG_WARN1, "HWSPMnnnW l%05d Listen-Gateway responded ied_ligwr_resp_arproute_del_ipv4 but not command ied_sth_route_ipv4_del sent",
+                         __LINE__ );
+         break;
+       }
+       dsg_global_lock.m_enter();           /* enter critical section  */
+       adsl_sth_w1 = dss_ser_thr_ctrl.adsc_sth_work;  /* get work as task for serial thread */
+       memcpy( &dsl_sth_work, adsl_sth_w1, sizeof(struct dsd_ser_thr_task) );
+       dss_ser_thr_ctrl.adsc_sth_work = adsl_sth_w1->adsc_next;  /* remove from chain */
+       adsl_sth_w1->adsc_next = dss_ser_thr_ctrl.adsc_sth_free;  /* get old chain free */
+       dss_ser_thr_ctrl.adsc_sth_free = adsl_sth_w1;  /* set new chain free */
+       dsg_global_lock.m_leave();           /* leave critical section  */
+       if (dsl_sth_work.aboc_posted) {      /* with mark posted        */
+         *dsl_sth_work.aboc_posted = TRUE;  /* mark posted             */
+       }
+       if (dsl_sth_work.adsc_event_posted) {  /* event for posted      */
+         iml_rc = dsl_sth_work.adsc_event_posted->m_post( &iml_error );  /* event for posted */
+// to-do 02.07.10 KB error message
+         if (iml_rc < 0) {                     /* error occured           */
+           m_hl1_printf( "xxxxxxxr-%05d-W m_ligw_recv() thread m_post Return Code %d Error %d",
+                         __LINE__, iml_rc, iml_error );
+         }
+       }
+       dss_ligw_g.boc_ser_sent = FALSE;     /* serialize command sent  */
+       break;                               /* all done                */
+#endif
      default:
 // to-do 12.09.11 KB error message
-         m_ligw_close();                    /* close connection to listen-gateway */
-         return;
+       m_hlnew_printf( HLOG_WARN1, "HWSPM171W nbipgw20 l%05d m_ligw_recv() input invalid response tag %d.",
+                       __LINE__, (enum ied_li_gw_response) *achl1 );
+#ifdef DEBUG_121116_01                      /* debug listen-gateway    */
+       m_hlnew_printf( HLOG_TRACE1, "nbipgw20-l%05d-T call m_ligw_close()",
+                       __LINE__ );
+#endif
+       m_ligw_close();                      /* close connection to listen-gateway */
+       return;
    }

    p_record_80:                             /* the record has been processed */
@@ -7151,7 +7388,7 @@
 #endif
    dss_ligw_g.aimrc_ligw_cluster = aimrp_ligw_cluster;  /* set cluster structure */
    if (dss_ligw_g.boc_connected == FALSE) return;  /* not connected to Listen Gateway */
-   m_ligw_send( (char *) dss_ligw_g.aimrc_ligw_cluster + 2 * sizeof(int) - 1, dss_ligw_g.aimrc_ligw_cluster[ 0 ] + 1 );
+   m_ligw_send( (char *) dss_ligw_g.aimrc_ligw_cluster + 2 * sizeof(int) - 1, dss_ligw_g.aimrc_ligw_cluster[ 0 ] + 1, NULL );
 } /* end m_ligw_cluster_struct()                                       */

 /** close the connection to the listen-gateway                         */
@@ -7159,8 +7396,10 @@
    int        iml_rc;                       /* return code             */
    struct dsd_ligw_receive *adsl_rec1_w1;   /* area for receive        */

-   m_hlnew_printf( HLOG_XYZ1, "nbipgw20-l%05d-T m_ligw_close() called",
+#ifdef DEBUG_121116_01                      /* debug listen-gateway    */
+   m_hlnew_printf( HLOG_TRACE1, "nbipgw20-l%05d-T m_ligw_close() called",
                    __LINE__ );
+#endif
    iml_rc = close( dss_ligw_g.imc_sockfd );
    if (iml_rc != 0) {                       /* error occured           */
 // to-do 12.09.11 KB error message
@@ -7172,6 +7411,10 @@
      m_proc_free( adsl_rec1_w1 );           /* free receive block      */
    }
    dss_ligw_g.boc_connected = FALSE;        /* not connected to Listen Gateway */
+#ifdef D_INCL_HOB_TUN
+   dss_ligw_g.boc_ser_sent = FALSE;         /* serialize command sent  */
+   dss_ligw_g.imc_open_tun_sent = 0;        /* command open TUN sent   */
+#endif
 } /* end m_ligw_close()                                                */

 /** subroutine to close a session on work-thread                       */
@@ -7192,6 +7435,11 @@
    struct dsd_bgt_contr_1 *adsl_bgt_contr_1;  /* definition background-task control */
    struct dsd_bgt_function_1 *adsl_bgt_function_1;  /* chain background-task functions */
    struct dsd_wsp_trace_1 *adsl_wt1_w1;     /* WSP trace control record */
+#ifdef HL_UNIX
+   struct dsd_ineta_raws_1 *adsl_ineta_raws_1_w1;  /* used INETA       */
+   int        *aiml_state_a;                /* address state of HTUN / HTCP session */
+   void       **avpl_netw_post_1;           /* address clear structure to post */
+#endif
    char       *achl_avl_error;              /* error code AVL tree     */
    struct dsd_htree1_avl_work dsl_htree1_work;  /* work-area for AVL-Tree */
 #ifdef B120214
@@ -7385,6 +7633,38 @@
          ADSL_NETW_POST_1->boc_posted = TRUE;  /* as if event has been posted */
        }
 #endif
+#ifndef B130109
+       aiml_state_a = NULL;                 /* address state of HTUN / HTCP session */
+       avpl_netw_post_1 = NULL;             /* address clear structure to post */
+       adsl_ineta_raws_1_w1 = ADSL_CONN1_G->adsc_ineta_raws_1;
+       if (   (ADSL_CONN1_G->adsc_server_conf_1)
+           && (   (ADSL_CONN1_G->adsc_server_conf_1->inc_function == DEF_FUNC_HPPPT1)   /* PPP type session  */
+               || (ADSL_CONN1_G->adsc_server_conf_1->inc_function == DEF_FUNC_SSTP))) {  /* SSTP session type */
+         aiml_state_a                       /* address state of HTUN / HTCP session */
+           = &ADSL_CONN1_G->imc_ppp_state;          /* PPP state               */
+         avpl_netw_post_1                   /* address clear structure to post */
+           = (void **) &ADSL_CONN1_G->adsc_ppp_netw_post_1;   /* address structure to post from network callback */
+         adsl_ineta_raws_1_w1 = NULL;
+       }
+       if (adsl_ineta_raws_1_w1) {
+         aiml_state_a                       /* address state of HTUN / HTCP session */
+           = &adsl_ineta_raws_1_w1->imc_state;  /* HTCP state          */
+         avpl_netw_post_1                   /* address clear structure to post */
+           = (void **) &adsl_ineta_raws_1_w1->adsc_netw_post_1;  /* address structure to post from network callback */
+       }
+       if (avpl_netw_post_1) {              /* address clear structure to post */
+         *avpl_netw_post_1                  /* address clear structure to post */
+           = ADSL_NETW_POST_1;
+       }
+       if (aiml_state_a == NULL) {          /* no state found          */
+         ADSL_NETW_POST_1->boc_posted = TRUE;  /* as if event has been posted */
+       } else {
+         if (*aiml_state_a
+               & (DEF_STATE_HTUN_SESS_END     /* done HOB-TUN HTCP session end */
+                    | DEF_STATE_HTUN_ERR_SESS_END))  /* done HOB-TUN HTCP session end was with error */
+         ADSL_NETW_POST_1->boc_posted = TRUE;  /* as if event has been posted */
+       }
+#endif
        m_htun_sess_close( ADSL_CONN1_G->dsc_htun_h );
        while (ADSL_NETW_POST_1->boc_posted == FALSE) {  /* event has not been posted */
          m_hco_wothr_wait( ADSL_AUX_CF1->adsc_hco_wothr );  /* wait for an event */
@@ -8460,6 +8740,7 @@

 //#ifdef NOT_YET /* in xi...tun */
 extern "C" struct dsd_wsptun_conf_1 * m_get_wsptun_conf_1() {
+#ifdef D_INCL_HOB_TUN
    struct dsd_raw_packet_if_conf *adsl_raw_packet_if_conf;  /* configuration raw-packet-interface */

 #ifdef B100702
@@ -8468,14 +8749,24 @@
    adsl_raw_packet_if_conf = dss_loconf_1.adsc_raw_packet_if_conf;  /* get configuration raw-packet-interface */
    if (adsl_raw_packet_if_conf == NULL) return NULL;  /* did not find the configuration */
    return &adsl_raw_packet_if_conf->dsc_wsptun_conf_1;  /* TUN PPP INETAs */
+#else
+   return NULL;
+#endif
 } /* end m_get_wsptun_conf_1()                                         */

 extern "C" char * m_get_wsptun_ineta_ipv4_adapter() {
+#ifdef D_INCL_HOB_TUN
+#ifdef B130109
    struct dsd_raw_packet_if_conf *adsl_raw_packet_if_conf;  /* configuration raw-packet-interface */

    adsl_raw_packet_if_conf = dss_loconf_1.adsc_raw_packet_if_conf;  /* get configuration raw-packet-interface */
    if (adsl_raw_packet_if_conf == NULL) return NULL;  /* did not find the configuration */
    return (char *) &adsl_raw_packet_if_conf->umc_ta_ineta_local;  /* <TUN-adapter-ineta> */
+#endif
+   return dss_tun_ctrl.achc_ta_ineta_ipv4;  /* entry <TUN-adapter-ineta> IPV4 */
+#else
+   return NULL;
+#endif
 } /* end m_get_wsptun_ineta_ipv4_adapter()                             */
 //#endif

@@ -8778,6 +9069,13 @@
    }
 #endif
 #endif
+#ifdef TRY_121128_01                        /* SO_REUSEADDR            */
+   iml_rc = setsockopt( adsp_gate_listen_1->imc_socket, SOL_SOCKET, SO_REUSEADDR, (const char *) &ims_true, sizeof(int) );
+   if (iml_rc != 0) {                       /* error occured           */
+     m_hlnew_printf( HLOG_WARN1, "HWSPxxxxW l%05d Error setsockopt() returned %d %d.",
+                     __LINE__, iml_rc, D_TCP_ERROR );
+   }
+#endif
    p_opli_bind_40:                          /* open listen bind        */
    iml_rc = bind( adsp_gate_listen_1->imc_socket,
                   (struct sockaddr *) &adsp_gate_listen_1->dsc_soa,
@@ -8896,6 +9194,7 @@
                            __LINE__, adsp_gate_1 + 1, iml_rc, D_TCP_ERROR, imh_w1, imh_w2 );
          }
 #endif
+#ifdef TRY_121128_01                        /* SO_REUSEADDR            */
          if (dss_loconf_1.boc_reload_conf) {  /* allow reload configuration */
            iml_rc = setsockopt( adsl_gate_listen_1_w1->imc_socket, SOL_SOCKET, SO_REUSEADDR, (const char *) &ims_true, sizeof(int) );
            if (iml_rc != 0) {               /* error occured           */
@@ -8907,6 +9206,13 @@
                            __LINE__, iml_rc );
 #endif
          }
+#else /* TRY_121128_01                         SO_REUSEADDR            */
+         iml_rc = setsockopt( adsl_gate_listen_1_w1->imc_socket, SOL_SOCKET, SO_REUSEADDR, (const char *) &ims_true, sizeof(int) );
+         if (iml_rc != 0) {                 /* error occured           */
+           m_hlnew_printf( HLOG_WARN1, "HWSPxxxxW l%05d Error setsockopt() gate \"%(ux)s\" returned %d %d.",
+                           __LINE__, adsp_gate_1 + 1, iml_rc, D_TCP_ERROR );
+         }
+#endif
 #ifdef TRY_120522_01                        /* SO_REUSEADDR            */
          {
            int      imh_w1;
@@ -9051,8 +9357,12 @@
    if (dss_loconf_1.boc_listen_gw) {        /* do use listen gateway   */
      dss_ligw_g.boc_stop_listen_lbal = FALSE;  /* stop listen load-balancing in progress */
      dss_ligw_g.boc_listen_lbal = bop_lbal;  /* start listen for load-balancing */
+#ifdef B121107
      if (dss_ligw_g.adsc_gate_listen_1_cur != NULL) return 0;  /* listen part of gateway currently processed */
      if (dss_ligw_g.adsc_gate_1_create_socket != NULL) return 0;  /* starting still active */
+#endif
+     if (dss_ligw_g.adsc_gate_listen_1_cur != NULL) return -1;  /* listen part of gateway currently processed */
+     if (dss_ligw_g.adsc_gate_1_create_socket != NULL) return -1;  /* starting still active */
      dss_ligw_g.adsc_gate_1_create_socket = adsl_gate_1_w1;  /* current gate to start */
      dss_ligw_g.adsc_gate_listen_1_next = NULL;  /* listen part of gateway next to process */
    }
@@ -9415,7 +9725,7 @@
    struct dsd_wsp_trace_1 *adsl_wt1_w2;     /* WSP trace control record */
    struct dsd_wsp_trace_1 *adsl_wt1_w3;     /* WSP trace control record */
    struct dsd_wsp_trace_record *adsl_wtr_w1;  /* WSP trace record      */
-   char       chrl_out1[ 512 ];             /* buffer                  */
+   char       chrl_out1[ LEN_MSG_PRE + 512 ];  /* buffer               */
 #ifndef B120714
    char       chrl_out_memlog[ 512 ];       /* buffer for memlog       */
 #endif
@@ -9426,16 +9736,16 @@
 // to-do 12.07.12 KB use ieg_charset_system instead of ied_chs_ascii_850
    iml1 = m_hlvsnprintf( chrl_out1, sizeof(chrl_out1) - 2, ied_chs_ascii_850, achptext, dsl_argptr );
 #else
-   iml_len_msg = m_hlvsnprintf( chrl_out1, sizeof(chrl_out1) - 2, ieg_charset_system, achptext, dsl_argptr );
+   iml_len_msg = m_hlvsnprintf( chrl_out1 + LEN_MSG_PRE, sizeof(chrl_out1) - LEN_MSG_PRE - 2, ieg_charset_system, achptext, dsl_argptr );
    iml1 = 0;
    if (iml_len_msg > 0) iml1 = iml_len_msg;
 #endif
    va_end( dsl_argptr );
    if (iml1 > 0) {
-     *((char *) chrl_out1 + iml1 + 0) = '\n';
-     *((char *) chrl_out1 + iml1 + 1) = 0;
+     *((char *) chrl_out1 + LEN_MSG_PRE + iml1 + 0) = '\n';
+     *((char *) chrl_out1 + LEN_MSG_PRE + iml1 + 1) = 0;
    }
-   printf( "%.*s", iml1 + 1, chrl_out1 );
+   printf( "%.*s", iml1 + 1, chrl_out1 + LEN_MSG_PRE );
    if (   (img_wsp_trace_core_flags1 & HL_WT_CORE_CONSOLE)  /* messages written to the console */
        && (dss_wsp_trace_thr_ctrl.iec_wtt != ied_wtt_console)) {  /* not print on console */
      adsl_wt1_w1 = (struct dsd_wsp_trace_1 *) m_proc_alloc();  /* WSP trace record */
@@ -9456,7 +9766,7 @@
        achl_w1 = (char *) (((long long int) ((char *) (ADSL_WTR_G1 + 1) + iml2 + sizeof(void *) - 1)) & (0 - sizeof(void *)));
 #define ADSL_WTR_G2 ((struct dsd_wsp_trace_record *) achl_w1)
        iml2 = iml1;                         /* length of data displayed */
-       achl_w3 = (char *) chrl_out1;        /* start of data           */
+       achl_w3 = (char *) chrl_out1 + LEN_MSG_PRE;  /* start of data   */
        adsl_wt1_w2 = adsl_wt1_w1;           /* in this piece of memory */
        adsl_wtr_w1 = ADSL_WTR_G1;           /* set last in chain       */
        bol1 = FALSE;                        /* reset more flag         */
@@ -9507,7 +9817,7 @@
      m_write_log( imp_type, (char *) chrl_out1, iml2 );
 #else
      iml2 = iml_len_msg;                    /* get length message      */
-     achl_w1 = chrl_out1;                   /* get address message     */
+     achl_w1 = chrl_out1 + LEN_MSG_PRE;     /* get address message     */
      if (ieg_charset_system != ied_chs_utf_8) {  /* need other character set */
        iml2 = m_hlvsnprintf( chrl_out_memlog, sizeof(chrl_out_memlog), ied_chs_utf_8,
                              achptext, dsl_argptr );
@@ -9524,9 +9834,15 @@
      }
    } else if (bog_log == FALSE) return iml1;
 #ifndef B120714
-   if (iml_len_msg > 0) *(chrl_out1 + iml_len_msg) = 0;  /* make zero-terminated again */
+   if (iml_len_msg > 0) *(chrl_out1 + LEN_MSG_PRE + iml_len_msg) = 0;  /* make zero-terminated again */
 #endif
-   syslog( DEF_IPLEVEL, "%.*s\n", iml_len_msg, chrl_out1 );
+   achl_w1 = chrl_out1 + LEN_MSG_PRE;       /* get address message     */
+   if (chrs_msg_pre[ 0 ]) {                 /* with pid                */
+     memcpy( chrl_out1, chrs_msg_pre, LEN_MSG_PRE );
+     achl_w1 = chrl_out1;                   /* get address message     */
+     iml_len_msg += LEN_MSG_PRE;
+   }
+   syslog( DEF_IPLEVEL, "%.*s\n", iml_len_msg, achl_w1 );
    return iml1;
 #else
    iml1 = printf( "%s\n", achptext );
@@ -9550,7 +9866,7 @@
    struct dsd_wsp_trace_1 *adsl_wt1_w3;     /* WSP trace control record */
    struct dsd_wsp_trace_record *adsl_wtr_w1;  /* WSP trace record      */
 // HL_WCHAR   chrl_out1[ 512 * sizeof(HL_WCHAR) ];  /* buffer          */
-   char       chrl_out1[ 512 ];             /* buffer                  */
+   char       chrl_out1[ LEN_MSG_PRE + 512 ];  /* buffer               */
 #ifndef B120714
    char       chrl_out_memlog[ 512 ];       /* buffer for memlog       */
 #endif
@@ -9560,16 +9876,16 @@
 // to-do 12.07.12 KB use ieg_charset_system instead of ied_chs_ascii_850
    iml1 = m_hlvsnprintf( chrl_out1, sizeof(chrl_out1) - 2, ied_chs_ascii_850, aptext, dsl_argptr );
 #else
-   iml_len_msg = m_hlvsnprintf( chrl_out1, sizeof(chrl_out1) - 2, ieg_charset_system, aptext, dsl_argptr );
+   iml_len_msg = m_hlvsnprintf( chrl_out1 + LEN_MSG_PRE, sizeof(chrl_out1) - LEN_MSG_PRE - 2, ieg_charset_system, aptext, dsl_argptr );
    iml1 = 0;
    if (iml_len_msg > 0) iml1 = iml_len_msg;
 #endif
    va_end( dsl_argptr );
    if (iml1 > 0) {
-     *((char *) chrl_out1 + iml1 + 0) = '\n';
-     *((char *) chrl_out1 + iml1 + 1) = 0;
+     *((char *) chrl_out1 + LEN_MSG_PRE + iml1 + 0) = '\n';
+     *((char *) chrl_out1 + LEN_MSG_PRE + iml1 + 1) = 0;
    }
-   printf( "%.*s", iml1 + 1, chrl_out1 );
+   printf( "%.*s", iml1 + 1, chrl_out1 + LEN_MSG_PRE );
    if (   (img_wsp_trace_core_flags1 & HL_WT_CORE_CONSOLE)  /* messages written to the console */
        && (dss_wsp_trace_thr_ctrl.iec_wtt != ied_wtt_console)) {  /* not print on console */
      adsl_wt1_w1 = (struct dsd_wsp_trace_1 *) m_proc_alloc();  /* WSP trace record */
@@ -9590,7 +9906,7 @@
        achl_w1 = (char *) (((long long int) ((char *) (ADSL_WTR_G1 + 1) + iml2 + sizeof(void *) - 1)) & (0 - sizeof(void *)));
 #define ADSL_WTR_G2 ((struct dsd_wsp_trace_record *) achl_w1)
        iml2 = iml1;                         /* length of data displayed */
-       achl_w3 = (char *) chrl_out1;        /* start of data           */
+       achl_w3 = (char *) chrl_out1 + LEN_MSG_PRE;  /* start of data   */
        adsl_wt1_w2 = adsl_wt1_w1;           /* in this piece of memory */
        adsl_wtr_w1 = ADSL_WTR_G1;           /* set last in chain       */
        bol1 = FALSE;                        /* reset more flag         */
@@ -9641,7 +9957,7 @@
      m_write_log( HLOG_WARN1, (char *) chrl_out1, iml2 );
 #else
      iml2 = iml_len_msg;                    /* get length message      */
-     achl_w1 = chrl_out1;                   /* get address message     */
+     achl_w1 = chrl_out1 + LEN_MSG_PRE;     /* get address message     */
      if (ieg_charset_system != ied_chs_utf_8) {  /* need other character set */
        iml2 = m_hlvsnprintf( chrl_out_memlog, sizeof(chrl_out_memlog), ied_chs_utf_8,
                              aptext, dsl_argptr );
@@ -9656,9 +9972,15 @@
    if (bog_log == FALSE) return iml1;
 // to-do 12.05.12 KB - charset of system
 #ifndef B120714
-   if (iml_len_msg > 0) *(chrl_out1 + iml_len_msg) = 0;  /* make zero-terminated again */
+   if (iml_len_msg > 0) *(chrl_out1 + LEN_MSG_PRE + iml_len_msg) = 0;  /* make zero-terminated again */
 #endif
-   syslog( DEF_IPLEVEL, "%s", chrl_out1 );
+   achl_w1 = chrl_out1 + LEN_MSG_PRE;       /* get address message     */
+   if (chrs_msg_pre[ 0 ]) {                 /* with pid                */
+     memcpy( chrl_out1, chrs_msg_pre, LEN_MSG_PRE );
+     achl_w1 = chrl_out1;                   /* get address message     */
+     iml_len_msg += LEN_MSG_PRE;
+   }
+   syslog( DEF_IPLEVEL, "%.*s\n", iml_len_msg, achl_w1 );
    return iml1;
 } /* end m_hl1_printf()                                                */

@@ -9852,7 +10174,7 @@
 /** edit a long integer number for decimal display                     */
 static char * m_edit_dec_long( char *achp_target, HL_LONGLONG ilp1 ) {
    int        iml1;                         /* working variable        */
-   char       *achl1;
+   char       *achl1;                       /* working variable        */

    achl1 = achp_target + 31;
    *achl1 = 0;                              /* make zero-terminated    */
Index: hob-htcp-htun-01.h
===================================================================
--- hob-htcp-htun-01.h	(revision 0)
+++ hob-htcp-htun-01.h	(revision 6)
@@ -0,0 +1,23 @@
+/******************************************************************************
+ * File name: hob-htcp-htun-01.h
+ *
+ * Author: Kevin Spiteri
+ * Copyright: Copyright (c) HOB Software 2012
+ ******************************************************************************/
+
+#ifndef HOB_HTCP_HTUN_01_H
+#define HOB_HTCP_HTUN_01_H
+
+void m_htcp_sess_close(struct dsd_htcp_htun* adsp_hh);
+
+void m_htcp_sess_send(struct dsd_htcp_htun* adsp_hh,
+                      struct dsd_gather_i_1* adsp_gai1);
+
+void m_htcp_sess_canrecv(struct dsd_htcp_htun* adsp_hh);
+
+
+void m_htcp_packet_from_network(struct dsd_htcp_htun* adsp_hh,
+                                void* ap_handle, unsigned unp_offset,
+                                char* achp_data, unsigned unp_dlen);
+
+#endif /* !HOB_HTCP_HTUN_01_H */
Index: xiipgw08-tcp.cpp
===================================================================
--- xiipgw08-tcp.cpp	(revision 2)
+++ xiipgw08-tcp.cpp	(revision 6)
@@ -180,6 +180,7 @@
 #else
    memset( &dsl_tun_start_htcp, 0, sizeof(struct dsd_tun_start_htcp) );  /* HOB-TUN start interface HTCP */
    dsl_tun_start_htcp.adsc_server_ineta = adsl_server_ineta_w1;  /* server INETA */
+// dsl_tun_start_htcp.ac_free_ti1 = al_free_ti1;  /* INETA to free     */
    dsl_tun_start_htcp.imc_server_port = ntohs( ((struct sockaddr_in *) adsp_soa)->sin_port );  /* TCP/IP port connect */
    dsl_tun_start_htcp.boc_connect_round_robin = FALSE;  /* do not connect round-robin */
    dsl_tun_start_htcp.imc_tcpc_to_msec = adsl_raw_packet_if_conf->imc_tcpc_to_msec;  /* TCP connect timeout milliseconds */
@@ -387,10 +388,11 @@
 } /* end clconn1::mc_conn_server()                                        */

 /**
-   do connect for Server-Data-Hooks (SDHs)
+   do dynamic connect for Server-Data-Hooks (SDHs)
 */
-extern "C" BOOL m_tcp_conn( void * vpp_userfld, struct dsd_aux_tcp_conn_1 *adsp_tcp_conn,
-                            struct dsd_target_ineta_1 *adsp_target_ineta_1, BOOL bop_extended ) {
+extern "C" BOOL m_tcp_dynamic_conn( void * vpp_userfld, struct dsd_aux_tcp_conn_1 *adsp_tcp_conn,
+                                    struct dsd_target_ineta_1 *adsp_target_ineta_1, void * ap_free_ti1,
+                                    BOOL bop_extended ) {
    int        iml1;                         /* working variable        */
    int        dwl1;                         /* working variable        */
    BOOL       bol_csssl;                    /* with client-side SSL    */
@@ -407,6 +409,9 @@
    long long int ill_entropy;               /* time now                */
 #endif
    struct dsd_target_ineta_1 *adsl_target_ineta_1;  /* INETAs of target */
+#ifndef B121120
+   void *     al_free_ti1;                  /* INETA to free           */
+#endif
 #ifdef D_INCL_HOB_TUN
    struct dsd_ineta_raws_1 *adsl_ineta_raws_1_old;  /* auxiliary extension field HTUN */
    struct dsd_ineta_raws_1 *adsl_ineta_raws_1_new;  /* auxiliary extension field HTUN */
@@ -425,7 +430,7 @@
    struct dsd_targfi_1 *adsl_targfi_w1;     /* working variable        */

 #ifdef TRACEHL1
-   m_hlnew_printf( HLOG_XYZ1, "m_tcp_conn() started - TCP connect" );
+   m_hlnew_printf( HLOG_XYZ1, "m_tcp_dynamic_conn() started - TCP connect" );
 #endif
 #define ADSL_AUX_CF1 ((struct dsd_aux_cf1 *) vpp_userfld)  /* auxiliary control structure */
 #define ADSL_CONN1_G (ADSL_AUX_CF1->adsc_conn)  /* pointer on connection */
@@ -461,6 +466,9 @@
      m_hlnew_printf( HLOG_XYZ1, "HWSPS050W GATE=%(ux)s SNO=%08d INETA=%s TCP connect - server invalid or already connected",
                      (WCHAR *) (ADSL_CONN1_G->adsc_gate1 + 1), ADSL_CONN1_G->dsc_co_sort.imc_sno,
                      ADSL_CONN1_G->chrc_ineta );
+#ifndef B121120
+     if (ap_free_ti1) free( ap_free_ti1 );  /* INETA to free           */
+#endif
      adsp_tcp_conn->iec_tcpconn_ret = ied_tcr_invalid;  /* parameter is invalid */
      return TRUE;
    }
@@ -469,6 +477,9 @@
      m_hlnew_printf( HLOG_XYZ1, "HWSPSnnnW GATE=%(ux)s SNO=%08d INETA=%s TCP connect - option-connect-other-server not configured, connect not allowed",
                      (WCHAR *) (ADSL_CONN1_G->adsc_gate1 + 1), ADSL_CONN1_G->dsc_co_sort.imc_sno,
                      ADSL_CONN1_G->chrc_ineta );
+#ifndef B121120
+     if (ap_free_ti1) free( ap_free_ti1 );  /* INETA to free           */
+#endif
      adsp_tcp_conn->iec_tcpconn_ret = ied_tcr_no_ocos;  /* option-connect-other-server not configured */
      return TRUE;
    }
@@ -490,6 +501,9 @@
    if (bol_csssl) {                         /* use client-side SSL     */
      if (adsg_loconf_1_inuse->boc_csssl_conf == FALSE) {  /* Client Side SSL not configured */
        adsp_tcp_conn->iec_tcpconn_ret = ied_tcr_no_cs_ssl;  /* no Client-Side SSL configured */
+#ifndef B121120
+       if (ap_free_ti1) free( ap_free_ti1 );  /* INETA to free           */
+#endif
        return TRUE;
      }
 #ifndef HL_UNIX
@@ -505,6 +519,9 @@
    m_hco_wothr_blocking( ADSL_AUX_CF1->adsc_hco_wothr );  /* mark thread blocking */
    if (adsp_target_ineta_1) {               /* INETA passed as parameter */
      adsl_target_ineta_1 = adsp_target_ineta_1;  /* use INETA passed as parameter */
+#ifndef B121120
+     al_free_ti1 = ap_free_ti1;             /* INETA to free           */
+#endif
      goto p_ineta_20;                       /* target INETA is valid   */
    }
    adsl_target_ineta_1 = m_get_target_ineta( adsp_tcp_conn->dsc_target_ineta.ac_str,
@@ -522,10 +539,17 @@
      adsp_tcp_conn->iec_tcpconn_ret = ied_tcr_hostname;  /* host-name not in DNS */
      return TRUE;
    }
+#ifndef B121120
+   al_free_ti1 = ap_free_ti1;               /* INETA to free           */
+#endif
+#ifndef B121120
+
+   p_ineta_20:                              /* target INETA is valid   */
+#endif
    if (adsl_targfi_w1) {                    /* with target-filter      */
      if (adsg_loconf_1_inuse->inc_network_stat >= 4) {
 #ifdef B110104
-       m_hlnew_printf( HLOG_XYZ1, "HWSPS0xxI GATE=%(ux)s SNO=%08d INETA=%s m_tcp_conn apply target-filter INETA %(ux)s from %s to %(ucs)s.",
+       m_hlnew_printf( HLOG_XYZ1, "HWSPS0xxI GATE=%(ux)s SNO=%08d INETA=%s m_tcp_dynamic_conn apply target-filter INETA %(ux)s from %s to %(ucs)s.",
                        ADSL_CONN1_G->adsc_gate1 + 1,
                        ADSL_CONN1_G->dsc_co_sort.imc_sno,
                        ADSL_CONN1_G->chrc_ineta,
@@ -533,7 +557,7 @@
                        achl_stf,
                        &adsp_tcp_conn->dsc_target_ineta );
 #endif
-       m_hlnew_printf( HLOG_XYZ1, "HWSPS0xxI GATE=%(ux)s SNO=%08d INETA=%s m_tcp_conn apply target-filter %(u8)s from %s to %(ucs)s.",
+       m_hlnew_printf( HLOG_XYZ1, "HWSPS0xxI GATE=%(ux)s SNO=%08d INETA=%s m_tcp_dynamic_conn apply target-filter %(u8)s from %s to %(ucs)s.",
                        ADSL_CONN1_G->adsc_gate1 + 1,
                        ADSL_CONN1_G->dsc_co_sort.imc_sno,
                        ADSL_CONN1_G->chrc_ineta,
@@ -548,7 +572,7 @@
                                       adsp_tcp_conn->imc_server_port );
      if (bol1 == FALSE) {                   /* target-filter blocks access */
 #ifdef B110104
-       m_hlnew_printf( HLOG_XYZ1, "HWSPS0xxW GATE=%(ux)s SNO=%08d INETA=%s m_tcp_conn target-filter INETA %(ux)s from %s blocks access to %(ucs)s.",
+       m_hlnew_printf( HLOG_XYZ1, "HWSPS0xxW GATE=%(ux)s SNO=%08d INETA=%s m_tcp_dynamic_conn target-filter INETA %(ux)s from %s blocks access to %(ucs)s.",
                        ADSL_CONN1_G->adsc_gate1 + 1,
                        ADSL_CONN1_G->dsc_co_sort.imc_sno,
                        ADSL_CONN1_G->chrc_ineta,
@@ -556,7 +580,7 @@
                        achl_stf,
                        &adsp_tcp_conn->dsc_target_ineta );
 #endif
-       m_hlnew_printf( HLOG_XYZ1, "HWSPS0xxW GATE=%(ux)s SNO=%08d INETA=%s m_tcp_conn target-filter %(u8)s from %s blocks access to %(ucs)s.",
+       m_hlnew_printf( HLOG_XYZ1, "HWSPS0xxW GATE=%(ux)s SNO=%08d INETA=%s m_tcp_dynamic_conn target-filter %(u8)s from %s blocks access to %(ucs)s.",
                        ADSL_CONN1_G->adsc_gate1 + 1,
                        ADSL_CONN1_G->dsc_co_sort.imc_sno,
                        ADSL_CONN1_G->chrc_ineta,
@@ -564,12 +588,17 @@
                        achl_stf,
                        &adsp_tcp_conn->dsc_target_ineta );
        m_hco_wothr_active( ADSL_AUX_CF1->adsc_hco_wothr );  /* mark thread active */
+#ifndef B121120
+       if (al_free_ti1) free( al_free_ti1 );  /* INETA to free         */
+#endif
        adsp_tcp_conn->iec_tcpconn_ret = ied_tcr_denied_tf;  /* access denied because of target-filter */
        return TRUE;
      }
    }

+#ifdef B121120
    p_ineta_20:                              /* target INETA is valid   */
+#endif
 #ifdef D_INCL_HOB_TUN
    adsl_ineta_raws_1_old = ADSL_CONN1_G->adsc_ineta_raws_1;  /* get old auxiliary field for HOB-TUN */
    adsl_ineta_raws_1_new = NULL;             /* auxiliary extension field HTUN */
@@ -670,6 +699,7 @@
    ADSL_CONN1_G->dsc_tun_contr_conn.iec_tunc = ied_tunc_htcp;  /* HOB-TUN interface type */
    memset( &dsl_tun_start_htcp, 0, sizeof(struct dsd_tun_start_htcp) );  /* HOB-TUN start interface HTCP */
    dsl_tun_start_htcp.adsc_server_ineta = adsl_target_ineta_1;  /* server INETA */
+   dsl_tun_start_htcp.ac_free_ti1 = al_free_ti1;  /* INETA to free     */
    dsl_tun_start_htcp.imc_server_port = adsp_tcp_conn->imc_server_port;  /* TCP/IP port connect */
    dsl_tun_start_htcp.boc_connect_round_robin = ADSL_CONN1_G->adsc_server_conf_1->boc_connect_round_robin;  /* do connect round-robin */
    dsl_tun_start_htcp.imc_tcpc_to_msec = adsl_raw_packet_if_conf->imc_tcpc_to_msec;  /* TCP connect timeout milliseconds */
@@ -692,14 +722,19 @@
 #else
 // dsl_tun_start_htcp.adsc_htun_h = (dsd_htun_h *) &ADSL_CONN1_G->dsc_htun_h;  /* where to put the handle created */
    dsl_tun_start_htcp.adsc_htun_h = (dsd_htun_h *) &adsl_ineta_raws_1_new->dsc_htun_h;  /* where to put the handle created */
+#ifndef B130116
+   ADSL_CONN1_G->iec_servcotype = ied_servcotype_htun;  /* HOB-TUN       */
+#endif
    m_hl_lock_inc_1( &ADSL_CONN1_G->imc_references );  /* references to this session */
    m_htun_new_sess_htcp( &dsl_tun_start_htcp,
                          &ADSL_CONN1_G->dsc_tun_contr_conn,  /* HOB-TUN control area connection */
                          &adsl_ineta_raws_1_new->dsc_tun_contr_ineta );  /* HOB-TUN control interface for INETA */
    ADSL_CONN1_G->dsc_htun_h = adsl_ineta_raws_1_new->dsc_htun_h;  /* handle created */
 // ADSL_CONN1_G->iec_st_ses = ied_ses_wait_conn_s_static;  /* wait for static connect to server */
+#ifdef B130116
    ADSL_CONN1_G->iec_servcotype = ied_servcotype_htun;  /* HOB-TUN       */
 #endif
+#endif
 #define ADSL_NETW_POST_1 ((struct dsd_netw_post_1 *) ADSL_AUX_CF1->adsc_hco_wothr->vprc_aux_area)
    memset( ADSL_NETW_POST_1, 0, sizeof(struct dsd_netw_post_1) );  /* structure to post from network callback */
    ADSL_NETW_POST_1->adsc_event = &ADSL_AUX_CF1->adsc_hco_wothr->dsc_event;  /* event to be posted */
@@ -719,10 +754,10 @@
 #ifdef TRACEHL1
 #ifndef HL_UNIX
 #ifndef NEW_HOB_TUN_1103
-   m_hlnew_printf( HLOG_XYZ1, "IBIPGW08-l%05d-T m_tcp_conn() m_htun_new_sess() returned %p &dsc_tun_contr1=%p.",
+   m_hlnew_printf( HLOG_XYZ1, "IBIPGW08-l%05d-T m_tcp_dynamic_conn() m_htun_new_sess() returned %p &dsc_tun_contr1=%p.",
                    __LINE__, adsl_ineta_raws_1_new->dsc_htun_h, &adsl_ineta_raws_1_new->dsc_tun_contr1 );
 #else
-   m_hlnew_printf( HLOG_XYZ1, "IBIPGW08-l%05d-T m_tcp_conn() m_htun_new_sess() returned %p &dsc_tun_contr1=%p.",
+   m_hlnew_printf( HLOG_XYZ1, "IBIPGW08-l%05d-T m_tcp_dynamic_conn() m_htun_new_sess() returned %p &dsc_tun_contr1=%p.",
                    __LINE__, ADSL_CONN1_G->dsc_htun_h, &ADSL_CONN1_G->dsc_tun_contr1 );
 #endif
 #endif
@@ -766,6 +801,7 @@
    bol1 = ADSL_CONN1_G->dcl_tcp_r_s.m_connect_1( ADSL_CONN1_G,
                                                  &ADSL_CONN1_G->adsc_server_conf_1->dsc_bind_out,  /* IP address multihomed */
                                                  adsl_target_ineta_1,
+                                                 al_free_ti1,
                                                  adsp_tcp_conn->imc_server_port,
                                                  ADSL_CONN1_G->adsc_server_conf_1->boc_connect_round_robin,  /* do connect round-robin */
                                                  ADSL_NETW_POST_1 );  /* structure to post from network callback */
@@ -784,6 +820,7 @@
                   ADSL_CONN1_G,
                   &ADSL_CONN1_G->adsc_server_conf_1->dsc_bind_out,  /* IP address multihomed */
                   adsl_target_ineta_1,
+                  al_free_ti1,
                   adsp_tcp_conn->imc_server_port,
                   ADSL_CONN1_G->adsc_server_conf_1->boc_connect_round_robin );  /* do connect round-robin */
    if (iml_rc != 0) {                       /* error occured           */
@@ -828,7 +865,7 @@

    p_conn_20:                               /* after connect           */
 #ifdef TRACEHL1
-   m_hlnew_printf( HLOG_XYZ1, "m_tcp_conn() l%05d - TCP connect successfull", __LINE__ );
+   m_hlnew_printf( HLOG_XYZ1, "m_tcp_dynamic_conn() l%05d - TCP connect successfull", __LINE__ );
 #endif
 #ifdef D_INCL_HOB_TUN
 #ifndef HL_UNIX
@@ -884,9 +921,9 @@
        char chrh_work_1[128];
        int inh1, inh2;

-       m_hlnew_printf( HLOG_XYZ1, "m_tcp_conn() l%05d - ADSL_CONN1_G->adsc_server_conf_1=%p",
+       m_hlnew_printf( HLOG_XYZ1, "m_tcp_dynamic_conn() l%05d - ADSL_CONN1_G->adsc_server_conf_1=%p",
                        __LINE__, ADSL_CONN1_G->adsc_server_conf_1 );
-       m_hlnew_printf( HLOG_XYZ1, "m_tcp_conn() copy to=%p from=%p len=%d",
+       m_hlnew_printf( HLOG_XYZ1, "m_tcp_dynamic_conn() copy to=%p from=%p len=%d",
                        ADSL_CONN1_G->adsc_server_conf_1 + 1,
                        adsl_server_conf_1_w1 + 1,
                        adsl_server_conf_1_w1->inc_no_sdh * sizeof(struct dsd_sdh_work_1) );
@@ -998,7 +1035,7 @@
    m_hlcl01( &ADSL_CONN1_G->adsc_csssl_oper_1->dsc_hlcl01s );
 #endif
 #ifdef TRACEHL1
-   m_hlnew_printf( HLOG_XYZ1, "l%05d m_tcp_conn() - m_hlcl01( %p ) returned inc_return=%d",
+   m_hlnew_printf( HLOG_XYZ1, "l%05d m_tcp_dynamic_conn() - m_hlcl01( %p ) returned inc_return=%d",
                    __LINE__,
                    &ADSL_CONN1_G->adsc_csssl_oper_1->dsc_hlcl01s,
                    ADSL_CONN1_G->adsc_csssl_oper_1->dsc_hlcl01s.inc_return );
@@ -1008,9 +1045,263 @@
    return TRUE;                             /* all done                */
 #undef ADSL_CONN1_G
 #undef ADSL_AUX_CF1
-} /* end m_tcp_conn()                                                  */
+} /* end m_tcp_dynamic_conn()                                          */

 /**
+   do static connect to configured server
+*/
+extern "C" int m_tcp_static_conn( void * vpp_userfld, BOOL bop_wait_compl ) {
+   int        iml_rc;                       /* return code             */
+#ifndef HL_UNIX
+   BOOL       bol1;                         /* working variable        */
+#endif
+   struct dsd_target_ineta_1 *adsl_server_ineta_w1;  /* server INETA   */
+   void *     al_free_ti1;                  /* INETA to be freed       */
+#ifdef HL_UNIX
+#ifdef D_INCL_HOB_TUN
+   socklen_t  iml_local_namelen;            /* length of name local    */
+   enum ied_ineta_raws_def iel_irs_def;     /* type of INETA raw socket */
+   struct sockaddr *adsl_soa_w1;            /* sockaddr temporary value */
+   struct dsd_ineta_raws_1 *adsl_ineta_raws_1_w1;  /* extension field HOB-TUN */
+   struct dsd_raw_packet_if_conf *adsl_raw_packet_if_conf;  /* configuration raw-packet-interface */
+   struct dsd_tun_start_htcp dsl_tun_start_htcp;  /* HOB-TUN start interface HTCP */
+   char       chrl_ineta_local[ LEN_DISP_INETA ];  /* for INETA local  */
+#endif
+#endif
+
+#ifdef TRACEHL1
+   m_hlnew_printf( HLOG_XYZ1, "m_tcp_static_conn() started - TCP connect" );
+#endif
+#define ADSL_AUX_CF1 ((struct dsd_aux_cf1 *) vpp_userfld)  /* auxiliary control structure */
+#define ADSL_CONN1_G (ADSL_AUX_CF1->adsc_conn)  /* pointer on connection */
+   adsl_server_ineta_w1 = ADSL_CONN1_G->adsc_server_conf_1->adsc_server_ineta;  /* server INETA */
+   al_free_ti1 = NULL;                      /* INETA to be freed       */
+   if (ADSL_CONN1_G->adsc_server_conf_1->boc_dns_lookup_before_connect) {  /* needs to solve INETA before connect */
+     adsl_server_ineta_w1 = m_get_target_ineta( ADSL_CONN1_G->adsc_server_conf_1->achc_dns_name,  /* address of DNS name */
+                                                ADSL_CONN1_G->adsc_server_conf_1->imc_len_dns_name,  /* length of DNS name */
+                                                ied_chs_ansi_819,
+                                                &ADSL_CONN1_G->adsc_server_conf_1->dsc_bind_out );
+     if (adsl_server_ineta_w1 == NULL) {    /* could not resolve INETA */
+       m_hlnew_printf( HLOG_WARN1, "HWSPS170W GATE=%(ux)s SNO=%08d INETA=%s configured INETA %.*s could not by resolved by DNS",
+                       ADSL_CONN1_G->adsc_gate1 + 1, ADSL_CONN1_G->dsc_co_sort.imc_sno, ADSL_CONN1_G->chrc_ineta,
+                       ADSL_CONN1_G->adsc_server_conf_1->imc_len_dns_name,  /* length of DNS name */
+                       ADSL_CONN1_G->adsc_server_conf_1->achc_dns_name );  /* address of DNS name */
+#define DEF_ERR_NO_DNS 124
+       if (bop_wait_compl) return DEF_ERR_NO_DNS;
+       if (ADSL_CONN1_G->adsc_wsp_auth_1) {  /* authentication active */
+         ADSL_CONN1_G->adsc_wsp_auth_1->imc_connect_error = DEF_ERR_NO_DNS;
+         ADSL_CONN1_G->adsc_wsp_auth_1->boc_did_connect = TRUE;  /* did connect */
+         ADSL_CONN1_G->adsc_wsp_auth_1->boc_notify = TRUE;  /* notify authentication routine */
+         return DEF_ERR_NO_DNS;
+       }
+// to-do 03.07.10 KB we return now, we do not need to start the SDHs
+#ifndef HL_UNIX
+       ADSL_CONN1_G->iec_st_ses = clconn1::ied_ses_error_conn;  /* status server error */
+#else
+       ADSL_CONN1_G->iec_st_ses = ied_ses_error_conn;  /* status server error */
+#endif
+       if (ADSL_CONN1_G->adsc_server_conf_1->boc_dynamic == FALSE) return DEF_ERR_NO_DNS;  /* not dynamicly allocated */
+#ifndef HL_UNIX
+       ADSL_CONN1_G->iec_st_ses = clconn1::ied_ses_error_co_dyn;  /* status server error */
+#else
+       ADSL_CONN1_G->iec_st_ses = ied_ses_error_co_dyn;  /* status server error */
+#endif
+       return DEF_ERR_NO_DNS;
+     }
+     al_free_ti1 = adsl_server_ineta_w1;    /* INETA to be freed       */
+   }
+#ifdef HL_UNIX
+   ADSL_CONN1_G->imc_connect_error = 0;     /* save connect error      */
+#endif
+#ifdef HL_UNIX
+#ifdef D_INCL_HOB_TUN
+   adsl_raw_packet_if_conf = adsg_loconf_1_inuse->adsc_raw_packet_if_conf;  /* configuration raw-packet-interface */
+   if (   (ADSL_CONN1_G->adsc_server_conf_1->boc_use_ineta_appl)  /* use HTCP */
+       && (adsl_raw_packet_if_conf)) {
+     iel_irs_def = ied_ineta_raws_user_ipv4;  /* INETA user IPV4       */
+     adsl_ineta_raws_1_w1 = m_prepare_htun_ineta_htcp( ADSL_CONN1_G,
+                                                       ADSL_AUX_CF1->adsc_hco_wothr,
+                                                       iel_irs_def );
+     if (adsl_ineta_raws_1_w1) {            /* INETA found             */
+       goto p_start_tun_00;                 /* start HOB-TUN           */
+     }
+     m_hlnew_printf( HLOG_WARN1, "HWSPS173W GATE=%(ux)s SNO=%08d INETA=%s configured use-ineta-appl but no ineta-appl available - use normal TCP",
+                     ADSL_CONN1_G->adsc_gate1 + 1, ADSL_CONN1_G->dsc_co_sort.imc_sno, ADSL_CONN1_G->chrc_ineta );
+   }
+#endif
+#endif
+#define ADSL_NETW_POST_1 ((struct dsd_netw_post_1 *) ADSL_AUX_CF1->adsc_hco_wothr->vprc_aux_area)
+   if (bop_wait_compl) {
+     memset( ADSL_NETW_POST_1, 0, sizeof(struct dsd_netw_post_1) );  /* structure to post from network callback */
+     ADSL_NETW_POST_1->adsc_event = &ADSL_AUX_CF1->adsc_hco_wothr->dsc_event;  /* event to be posted */
+     ADSL_NETW_POST_1->imc_select = DEF_NETW_POST_1_TCPCOMP_CONN_OK | DEF_NETW_POST_1_TCPCOMP_CLEANUP;  /* select the events */
+   }
+#ifndef HL_UNIX
+   ADSL_CONN1_G->iec_servcotype = ied_servcotype_normal_tcp;  /* normal TCP */
+#ifdef B121122
+   ADSL_CONN1_G->iec_st_ses = clconn1::ied_ses_wait_conn_s_dynamic;  /* wait for dynamic connect to server */
+#else
+   ADSL_CONN1_G->iec_st_ses = clconn1::ied_ses_wait_conn_s_static;  /* wait for static connect to server */
+#endif
+   bol1 = ADSL_CONN1_G->dcl_tcp_r_s.m_connect_1( ADSL_CONN1_G,
+                                                 &ADSL_CONN1_G->adsc_server_conf_1->dsc_bind_out,  /* IP address multihomed */
+                                                 adsl_server_ineta_w1,
+#ifndef B121120
+                                                 al_free_ti1,  /* INETA to free */
+#endif
+                                                 ADSL_CONN1_G->adsc_server_conf_1->inc_server_port,  /* TCP/IP port connect */
+                                                 ADSL_CONN1_G->adsc_server_conf_1->boc_connect_round_robin,  /* do connect round-robin */
+                                                 ADSL_NETW_POST_1 );  /* structure to post from network callback */
+   if (bol1 == FALSE) {                     /* error occured           */
+// to-do 14.12.10 KB
+   }
+#else
+   memset( &ADSL_CONN1_G->dsc_tc1_server, 0, sizeof(struct dsd_tcp_ctrl_1) );  /* TCP control structure server */
+   ADSL_CONN1_G->iec_servcotype = ied_servcotype_normal_tcp;  /* normal TCP */
+#ifdef TRY100514X01
+#include "xiipgw08-test-ineta-1.cpp"
+#endif
+// iec_st_ses = ied_ses_wait_conn_s_pttd;  /* wait for connect to server, pass-thru-to-desktop */
+// if (bop_wait_compl == FALSE) {
+     ADSL_CONN1_G->iec_st_ses = ied_ses_wait_conn_s_static;  /* wait for static connect to server */
+// }
+   ADSL_CONN1_G->dsc_tc1_server.boc_connected = TRUE;  /* TCP session is connected */
+   iml_rc = ADSL_CONN1_G->dsc_tc1_server.dsc_tcpco1_1.m_startco_mh(
+              &dss_tcpcomp_cb1,
+              ADSL_CONN1_G,
+              &ADSL_CONN1_G->adsc_server_conf_1->dsc_bind_out,
+              adsl_server_ineta_w1,         /* server INETA            */
+#ifndef B121121
+              al_free_ti1,                  /* INETA to free           */
+#endif
+              ADSL_CONN1_G->adsc_server_conf_1->inc_server_port,  /* TCP/IP port connect */
+              ADSL_CONN1_G->adsc_server_conf_1->boc_connect_round_robin );  /* do connect round-robin */
+   if (iml_rc) {                            /* error occured          */
+     ADSL_CONN1_G->dsc_tc1_server.boc_connected = FALSE;  /* TCP session is not connected */
+// boc_tcpc_act = FALSE;                /* TCPCOMP not active      */
+     m_hlnew_printf( HLOG_XYZ1, "HWSPS175W GATE=%(ux)s SNO=%08d INETA=%s nbipgw20 l%05d m_startco_mh() failed %d.",
+                     ADSL_CONN1_G->adsc_gate1 + 1, ADSL_CONN1_G->dsc_co_sort.imc_sno, ADSL_CONN1_G->chrc_ineta, __LINE__, iml_rc );
+// to-do 13.08.10 KB what to do ???
+// to-do 17.11.12 KB set ADSL_CONN1_G->iec_st_ses
+     if (al_free_ti1) free( al_free_ti1 );  /* INETA to be freed       */
+     return iml_rc;
+   }
+#endif
+   if (bop_wait_compl == FALSE) return 0;   /* connect active          */
+   while (ADSL_NETW_POST_1->boc_posted == FALSE) {  /* event has not been posted */
+     m_hco_wothr_wait( ADSL_AUX_CF1->adsc_hco_wothr );  /* wait for an event */
+   }
+   if (ADSL_CONN1_G->iec_servcotype == ied_servcotype_normal_tcp) {  /* normal TCP */
+#ifndef HL_UNIX
+     ADSL_CONN1_G->dcl_tcp_r_s.start3();    /* receive data now        */
+#else
+     ADSL_CONN1_G->dsc_tc1_server.dsc_tcpco1_1.m_recv();  /* receive data now */
+#endif
+   }
+#ifndef HL_UNIX
+   ADSL_CONN1_G->iec_st_ses = clconn1::ied_ses_conn;  /* server is connected */
+   return ADSL_CONN1_G->dcl_tcp_r_s.m_get_conn_error();
+#else
+   ADSL_CONN1_G->iec_st_ses = ied_ses_conn;  /* server is connected    */
+   return ADSL_CONN1_G->imc_connect_error;
+#endif
+#undef ADSL_NETW_POST_1
+#ifdef HL_UNIX
+#ifdef D_INCL_HOB_TUN
+   p_start_tun_00:                          /* start HOB-TUN           */
+   adsl_soa_w1 = (struct sockaddr *) &adsl_ineta_raws_1_w1->dsc_tun_contr_ineta.dsc_soa_local_ipv4;
+   iml_local_namelen = sizeof(struct sockaddr_in);
+   iml_rc = getnameinfo( adsl_soa_w1, iml_local_namelen,
+                         chrl_ineta_local, sizeof(chrl_ineta_local),
+                         0, 0, NI_NUMERICHOST );
+   if (iml_rc < 0) {                  /* error occured           */
+#ifndef HL_UNIX
+     if (cl_tcp_r::hws2mod != NULL) {  /* functions loaded       */
+       iml_rc = cl_tcp_r::afunc_wsaglerr();  /* get error code   */
+     }
+     m_hlnew_printf( HLOG_XYZ1, "HWSPSnnnW GATE=%(ux)s SNO=%08d INETA=%s getnameinfo local failed with code %d.",
+                     ADSL_CONN1_G->adsc_gate1 + 1,
+                     ADSL_CONN1_G->dsc_co_sort.imc_sno,
+                     ADSL_CONN1_G->chrc_ineta,
+                     iml_rc );
+#else
+     m_hlnew_printf( HLOG_XYZ1, "HWSPSnnnW GATE=%(ux)s SNO=%08d INETA=%s getnameinfo local failed with code %d.",
+                     ADSL_CONN1_G->adsc_gate1 + 1,
+                     ADSL_CONN1_G->dsc_co_sort.imc_sno,
+                     ADSL_CONN1_G->chrc_ineta,
+                     errno );
+#endif
+   } else {
+     m_hlnew_printf( HLOG_XYZ1, "HWSPSnnnW GATE=%(ux)s SNO=%08d INETA=%s use ineta-appl %s TCP source port %d.",
+                     ADSL_CONN1_G->adsc_gate1 + 1, ADSL_CONN1_G->dsc_co_sort.imc_sno, ADSL_CONN1_G->chrc_ineta,
+                     chrl_ineta_local, adsl_ineta_raws_1_w1->usc_appl_port );
+   }
+   ADSL_CONN1_G->iec_servcotype = ied_servcotype_htun;  /* HOB-TUN     */
+   ADSL_CONN1_G->adsc_sdhc1_htun_sch = NULL;  /* chain of buffers to send over HOB-TUN */
+   ADSL_CONN1_G->imc_send_window = 0;       /* number of bytes to be sent */
+   memset( &ADSL_CONN1_G->dsc_tun_contr_conn, 0, sizeof(struct dsd_tun_contr_conn) );
+   ADSL_CONN1_G->dsc_tun_contr_conn.iec_tunc = ied_tunc_htcp;  /* HOB-TUN interface type */
+   memset( &dsl_tun_start_htcp, 0, sizeof(struct dsd_tun_start_htcp) );  /* HOB-TUN start interface HTCP */
+   dsl_tun_start_htcp.adsc_server_ineta = adsl_server_ineta_w1;  /* server INETA */
+   dsl_tun_start_htcp.ac_free_ti1 = al_free_ti1;  /* INETA to free     */
+   dsl_tun_start_htcp.imc_server_port = ADSL_CONN1_G->adsc_server_conf_1->inc_server_port;  /* TCP/IP port connect */
+   dsl_tun_start_htcp.boc_connect_round_robin = ADSL_CONN1_G->adsc_server_conf_1->boc_connect_round_robin;  /* do connect round-robin */
+   dsl_tun_start_htcp.imc_tcpc_to_msec = adsl_raw_packet_if_conf->imc_tcpc_to_msec;  /* TCP connect timeout milliseconds */
+   if (dsl_tun_start_htcp.imc_tcpc_to_msec == 0) {  /* no value configured */
+     dsl_tun_start_htcp.imc_tcpc_to_msec = DEF_HTCP_TCPC_TO_MSEC;  /* TCP connect timeout milliseconds */
+   }
+   dsl_tun_start_htcp.imc_tcpc_try_no = adsl_raw_packet_if_conf->imc_tcpc_try_no;  /* TCP connect number of try */
+   if (dsl_tun_start_htcp.imc_tcpc_try_no == 0) {  /* no value configured */
+     dsl_tun_start_htcp.imc_tcpc_try_no = DEF_HTCP_TCPC_TRY_NO;  /* TCP connect number of try */
+   }
+   dsl_tun_start_htcp.boc_tcp_keepalive = adsg_loconf_1_inuse->boc_tcp_keepalive;  /* TCP KEEPALIVE */
+   adsl_ineta_raws_1_w1->ac_conn1 = ADSL_CONN1_G;  /* set connection   */
+// dsl_tun_start_htcp.adsc_htun_h = (dsd_htun_h *) &ADSL_CONN1_G->dsc_htun_h;  /* where to put the handle created */
+   dsl_tun_start_htcp.adsc_htun_h = (dsd_htun_h *) &adsl_ineta_raws_1_w1->dsc_htun_h;  /* where to put the handle created */
+#ifndef B130116
+   ADSL_CONN1_G->iec_st_ses = ied_ses_wait_conn_s_static;  /* wait for static connect to server */
+   ADSL_CONN1_G->adsc_ineta_raws_1 = adsl_ineta_raws_1_w1;
+   ADSL_CONN1_G->iec_servcotype = ied_servcotype_htun;  /* HOB-TUN     */
+#endif
+   m_hl_lock_inc_1( &ADSL_CONN1_G->imc_references );  /* references to this session */
+   m_htun_new_sess_htcp( &dsl_tun_start_htcp,
+                         &ADSL_CONN1_G->dsc_tun_contr_conn,  /* HOB-TUN control area connection */
+                         &adsl_ineta_raws_1_w1->dsc_tun_contr_ineta );  /* HOB-TUN control interface for INETA */
+   ADSL_CONN1_G->dsc_htun_h = adsl_ineta_raws_1_w1->dsc_htun_h;  /* handle created */
+#ifdef B130116
+#ifdef B121211
+// ADSL_CONN1_G->iec_st_ses = ied_ses_wait_conn_s_static;  /* wait for static connect to server */
+#else
+   ADSL_CONN1_G->iec_st_ses = ied_ses_wait_conn_s_static;  /* wait for static connect to server */
+#endif
+#ifndef B121211
+   ADSL_CONN1_G->adsc_ineta_raws_1 = adsl_ineta_raws_1_w1;
+#endif
+   ADSL_CONN1_G->iec_servcotype = ied_servcotype_htun;  /* HOB-TUN     */
+#endif
+   if (bop_wait_compl == FALSE) return 0;   /* connect active          */
+#define ADSL_NETW_POST_1 ((struct dsd_netw_post_1 *) ADSL_AUX_CF1->adsc_hco_wothr->vprc_aux_area)
+   memset( ADSL_NETW_POST_1, 0, sizeof(struct dsd_netw_post_1) );  /* structure to post from network callback */
+   ADSL_NETW_POST_1->adsc_event = &ADSL_AUX_CF1->adsc_hco_wothr->dsc_event;  /* event to be posted */
+   ADSL_NETW_POST_1->imc_select
+     = DEF_NETW_POST_1_HTUN_CONN_OK | DEF_NETW_POST_1_HTUN_FREE_R;  /* select the events */
+   adsl_ineta_raws_1_w1->adsc_netw_post_1 = ADSL_NETW_POST_1;  /* structure to post from network callback */
+   while (ADSL_NETW_POST_1->boc_posted == FALSE) {  /* event has not been posted */
+     m_hco_wothr_wait( ADSL_AUX_CF1->adsc_hco_wothr );  /* wait for an event */
+   }
+#ifndef B121211
+   ADSL_CONN1_G->iec_st_ses = ied_ses_conn;  /* server is connected    */
+#endif
+// to-do 21.11.12 KB - connect error
+   return 0;
+#undef ADSL_NETW_POST_1
+#endif
+#endif
+#undef ADSL_CONN1_G
+#undef ADSL_AUX_CF1
+} /* end m_tcp_static_conn()                                           */
+
+/**
    close connection to server for Server-Data-Hooks (SDHs)
 */
 extern "C" BOOL m_tcp_close( void * vpp_userfld ) {
@@ -1195,6 +1486,11 @@
    memset( ADSL_NETW_POST_1, 0, sizeof(struct dsd_netw_post_1) );  /* structure to post from network callback */
    ADSL_NETW_POST_1->adsc_event = &ADSL_AUX_CF1->adsc_hco_wothr->dsc_event;  /* event to be posted */
 #ifndef TRY_120126_01
+#ifdef HL_UNIX
+#ifndef B130114
+#define NEW_CLOSE_HTCP
+#endif
+#endif
    ADSL_NETW_POST_1->imc_select = DEF_NETW_POST_1_HTUN_SESS_END;  /* posted for HTUN HTCP session end */
    ADSL_CONN1_G->adsc_ineta_raws_1->adsc_netw_post_1 = ADSL_NETW_POST_1;  /* structure to post from network callback */
    if (ADSL_CONN1_G->adsc_ineta_raws_1->imc_state
Index: xs-htcp-01.cpp
===================================================================
--- xs-htcp-01.cpp	(revision 0)
+++ xs-htcp-01.cpp	(revision 6)
@@ -0,0 +1,3910 @@
+/******************************************************************************
+ * File name: xs-htcp-01.cpp
+ *
+ * Implementation for HTCP
+ *
+ * Author: Kevin Spiteri
+ * Copyright: Copyright (c) HOB Software 2011
+ ******************************************************************************/
+
+
+#include <stdio.h>
+
+#ifdef _MSC_VER
+#pragma warning(disable: 4996)
+#include <stdarg.h>
+
+static int snprintf(char* achp_str, size_t upp_size,
+                    const char* achp_format, ...)
+{
+    va_list ap;
+    int inl_ret;
+
+    if (achp_str != NULL && upp_size > 0) {
+        va_start(ap, achp_format);
+        inl_ret = _vsnprintf(achp_str, upp_size, achp_format, ap);
+        va_end(ap);
+
+        if (inl_ret != -1 && inl_ret != (int)upp_size)
+            return inl_ret;
+
+        achp_str[upp_size - 1] = '\0';
+    }
+
+    va_start(ap, achp_format);
+    inl_ret = _vscprintf(achp_format, ap);
+    va_end(ap);
+
+    return inl_ret;
+}
+#endif /* _MSC_VER */
+
+#ifndef DEF_INCLUDE_HEADERS
+#define DEF_INCLUDE_HEADERS
+#endif /* !DEF_INCLUDE_HEADERS */
+
+#include "hob-htcp-int-01.h"
+#include "hob-htcp-hdr-01.h"
+#include "hob-htcp-01.h"
+
+
+// Internal functions return bool. If an error occured and the connection was
+// terminated, the function returns false. Otherwise the function returns true.
+//
+// Some functions are called from inside a critical section. In such cases, the
+// function name starts with "m_locked_". If an error occurs, the function
+// leaves the critical section before returning false. The "m_locked_" functions
+// do not leave the critical section unless an error that causes connection
+// termination occurs.
+//
+// The function m_unlock_do_sendavail_or_remove() is called from inside a
+// critical section. The function may leave the critical section to do some
+// callbacks and reacquire the critical section. The function finally leaves
+// the critical section before returning.
+
+
+#ifdef HTCP_NCHECK_LOCK
+
+#define HTCP_LOCK      (adsp_hc->adsc_cb->amc_lock(adsp_hc))
+#define HTCP_LOCK_F    HTCP_LOCK
+#define HTCP_UNLOCK    (adsp_hc->adsc_cb->amc_unlock(adsp_hc))
+#define HTCP_UNLOCK_F  HTCP_UNLOCK
+
+#else // !HTCP_NCHECK_LOCK
+
+#define HTCP_LOCK                                               \
+    do {                                                        \
+        if (!adsp_hc->adsc_cb->amc_lock(adsp_hc)) {             \
+            m_do_abort(adsp_hc, ied_htcpc_application_error,    \
+                       __LINE__, "amc_lock() failed");          \
+            return;                                             \
+        }                                                       \
+    } while (0)
+
+#define HTCP_LOCK_F                                             \
+    do {                                                        \
+        if (!adsp_hc->adsc_cb->amc_lock(adsp_hc)) {             \
+            m_do_abort(adsp_hc, ied_htcpc_application_error,    \
+                       __LINE__, "amc_lock() failed");          \
+            return false;                                       \
+        }                                                       \
+    } while (0)
+
+#define HTCP_UNLOCK                                             \
+    do {                                                        \
+        if (!adsp_hc->adsc_cb->amc_unlock(adsp_hc)) {           \
+            m_do_abort(adsp_hc, ied_htcpc_application_error,    \
+                       __LINE__, "amc_unlock() failed");        \
+            return;                                             \
+        }                                                       \
+    } while (0)
+
+#define HTCP_UNLOCK_F                                           \
+    do {                                                        \
+        if (!adsp_hc->adsc_cb->amc_unlock(adsp_hc)) {           \
+            m_do_abort(adsp_hc, ied_htcpc_application_error,    \
+                       __LINE__, "amc_unlock() failed");        \
+            return false;                                       \
+        }                                                       \
+    } while (0)
+
+#endif // !HTCP_NCHECK_LOCK
+
+
+#define HTCP_ERROR(t)                                           \
+    do {                                                        \
+        m_do_abort(adsp_hc, ied_htcpc_error, __LINE__, (t));    \
+        return;                                                 \
+    } while (0)
+
+#define HTCP_ERROR_F(t)                                         \
+    do {                                                        \
+        m_do_abort(adsp_hc, ied_htcpc_error, __LINE__, (t));    \
+        return false;                                           \
+    } while (0)
+
+#define HTCP_LOCKED_ERROR(t)                                    \
+    do {                                                        \
+        adsp_hc->adsc_cb->amc_unlock(adsp_hc);                  \
+        m_do_abort(adsp_hc, ied_htcpc_error, __LINE__, (t));    \
+        return;                                                 \
+    } while (0)
+
+#define HTCP_LOCKED_ERROR_F(t)                                  \
+    do {                                                        \
+        adsp_hc->adsc_cb->amc_unlock(adsp_hc);                  \
+        m_do_abort(adsp_hc, ied_htcpc_error, __LINE__, (t));    \
+        return false;                                           \
+    } while (0)
+
+
+#ifdef NDEBUG
+
+#define HTCP_ASSERT(a)                 do {} while (0)
+#define HTCP_ASSERT_F(a)               do {} while (0)
+#define HTCP_LOCKED_ASSERT(a)          do {} while (0)
+#define HTCP_LOCKED_ASSERT_F(a)        do {} while (0)
+
+#else // !NDEBUG
+
+#define HTCP_ASSERT(a)                                          \
+    do {                                                        \
+        if (!(a)) {                                             \
+            m_do_abort(adsp_hc, ied_htcpc_error, __LINE__,      \
+                       "assertion (" #a ") failed");            \
+            return;                                             \
+        }                                                       \
+    } while (0)
+
+#define HTCP_ASSERT_F(a)                                        \
+    do {                                                        \
+        if (!(a)) {                                             \
+            m_do_abort(adsp_hc, ied_htcpc_error, __LINE__,      \
+                       "assertion (" #a ") failed");            \
+            return false;                                       \
+        }                                                       \
+    } while (0)
+
+#define HTCP_LOCKED_ASSERT(a)                                   \
+    do {                                                        \
+        if (!(a)) {                                             \
+            adsp_hc->adsc_cb->amc_unlock(adsp_hc);              \
+            m_do_abort(adsp_hc, ied_htcpc_error, __LINE__,      \
+                       "assertion (" #a ") failed");            \
+            return;                                             \
+        }                                                       \
+    } while (0)
+
+#define HTCP_LOCKED_ASSERT_F(a)                                 \
+    do {                                                        \
+        if (!(a)) {                                             \
+            adsp_hc->adsc_cb->amc_unlock(adsp_hc);              \
+            m_do_abort(adsp_hc, ied_htcpc_error, __LINE__,      \
+                       "assertion (" #a ") failed");            \
+            return false;                                       \
+        }                                                       \
+    } while (0)
+
+#endif // !NDEBUG
+
+
+#define HTCP_TEST(a, t)                                         \
+    do {                                                        \
+        if (!(a)) {                                             \
+            m_do_abort(adsp_hc, ied_htcpc_conn_error, __LINE__, \
+                       t);                                      \
+            return;                                             \
+        }                                                       \
+    } while (0)
+
+#define HTCP_TEST_F(a, t)                                       \
+    do {                                                        \
+        if (!(a)) {                                             \
+            m_do_abort(adsp_hc, ied_htcpc_conn_error, __LINE__, \
+                       t);                                      \
+            return false;                                       \
+        }                                                       \
+    } while (0)
+
+#define HTCP_LOCKED_TEST(a, t)                                  \
+    do {                                                        \
+        if (!(a)) {                                             \
+            adsp_hc->adsc_cb->amc_unlock(adsp_hc);              \
+            m_do_abort(adsp_hc, ied_htcpc_conn_error, __LINE__, \
+                       t);                                      \
+            return;                                             \
+        }                                                       \
+    } while (0)
+
+#define HTCP_LOCKED_TEST_F(a, t)                                \
+    do {                                                        \
+        if (!(a)) {                                             \
+            adsp_hc->adsc_cb->amc_unlock(adsp_hc);              \
+            m_do_abort(adsp_hc, ied_htcpc_conn_error, __LINE__, \
+                       t);                                      \
+            return false;                                       \
+        }                                                       \
+    } while (0)
+
+
+#define HTCP_CHECK_CB_RET(t)                                    \
+    do {                                                        \
+        if (!bol_ret) {                                         \
+            m_do_abort(adsp_hc, ied_htcpc_application_error,    \
+                       __LINE__, #t "() failed");               \
+            return;                                             \
+        }                                                       \
+    } while (0)
+
+#define HTCP_CHECK_CB_RET_F(t)                                  \
+    do {                                                        \
+        if (!bol_ret) {                                         \
+            m_do_abort(adsp_hc, ied_htcpc_application_error,    \
+                       __LINE__, #t "() failed");               \
+            return false;                                       \
+        }                                                       \
+    } while (0)
+
+#define HTCP_LOCKED_CHECK_CB_RET(t)                             \
+    do {                                                        \
+        if (!bol_ret) {                                         \
+            adsp_hc->adsc_cb->amc_unlock(adsp_hc);              \
+            m_do_abort(adsp_hc, ied_htcpc_application_error,    \
+                       __LINE__, #t "() failed");               \
+            return;                                             \
+        }                                                       \
+    } while (0)
+
+#define HTCP_LOCKED_CHECK_CB_RET_F(t)                           \
+    do {                                                        \
+        if (!bol_ret) {                                         \
+            adsp_hc->adsc_cb->amc_unlock(adsp_hc);              \
+            m_do_abort(adsp_hc, ied_htcpc_application_error,    \
+                       __LINE__, #t "() failed");               \
+            return false;                                       \
+        }                                                       \
+    } while (0)
+
+
+static void m_cc_newreno(enum ied_htcp_cc_event iep_cce_e,
+                         int64_t ilp_time, uint32_t ump_rtt_ms,
+                         uint32_t ump_snd_smss, uint32_t ump_flight,
+                         struct dsd_htcp_cc* adsp_cc);
+
+static void m_cc_cubic(enum ied_htcp_cc_event iep_cce_e,
+                       int64_t ilp_time, uint32_t ump_rtt_ms,
+                       uint32_t ump_snd_smss, uint32_t ump_flight,
+                       struct dsd_htcp_cc* adsp_cc);
+
+/*
+ * m_do_close() should be called exactly once
+ * m_do_abort() may be called once, more than once, or not at all
+ * IMPORTANT:
+ * achp_why MUST remain valid until any m_htcp_describe_close() call is done.
+ * achp_why MAY be NULL.
+ * achp_why MAY point to a string literal.
+ * achp_why SHOULD NOT be on the stack.
+ */
+static void m_do_close(struct dsd_htcp_conn* adsp_hc,
+                       enum ied_htcp_close iep_htcpc,
+                       int inp_line, const char* achp_why);
+static void m_do_abort(struct dsd_htcp_conn* adsp_hc,
+                       enum ied_htcp_close iep_htcpc,
+                       int inp_line, const char* achp_why);
+
+static void m_rto_init(struct dsd_htcp_conn* adsp_hc);
+static bool m_locked_rto_sending(struct dsd_htcp_conn* adsp_hc,
+                                 int64_t ilp_now_ms,
+                                 uint32_t ump_seq, uint32_t ump_len);
+static bool m_locked_rto_received(struct dsd_htcp_conn* adsp_hc,
+                                  int64_t ilp_now_ms);
+static bool m_locked_rto_timestamp_update(struct dsd_htcp_conn* adsp_hc,
+                                          int64_t ilp_now_ms,
+                                          uint32_t ump_seg_tsecr);
+
+static bool m_locked_process_syn_options(struct dsd_htcp_conn* adsp_hc,
+                                         const char* achp_tcp_header,
+                                         uint32_t ump_hlen);
+
+static bool m_locked_create_timestamp_option(struct dsd_htcp_conn* adsp_hc,
+                                             char* achp_o,
+                                             int64_t ilp_now_ms);
+
+static bool m_update_timer(struct dsd_htcp_conn* adsp_hc,
+                           int64_t ilp_now_ms, int64_t ilp_timer);
+
+static bool m_locked_stop_timer(struct dsd_htcp_conn* adsp_hc,
+                                bool* abop_update, int64_t* ailp_update_timer,
+                                int64_t* ailp_timer, int64_t ilp_other);
+
+static bool m_locked_start_timer(struct dsd_htcp_conn* adsp_hc,
+                                 bool* abop_update, int64_t* ailp_update_timer,
+                                 int64_t* ailp_timer, int64_t ilp_new_time,
+                                 int64_t ilp_other);
+
+static bool m_locked_restart_rexmt_timer(struct dsd_htcp_conn* adsp_hc,
+                                         bool* abop_update,
+                                         int64_t* ailp_update_timer,
+                                         int64_t ilp_now_ms);
+static bool m_locked_restart_time_wait_timer(struct dsd_htcp_conn* adsp_hc,
+                                             bool* abop_update,
+                                             int64_t* ailp_update_timer,
+                                             int64_t ilp_now_ms);
+
+
+static bool m_locked_start_da_timer(struct dsd_htcp_conn* adsp_hc,
+                                    bool* abop_update,
+                                    int64_t* ailp_update_timer,
+                                    int64_t ilp_now_ms);
+
+static bool m_locked_stop_da_timer(struct dsd_htcp_conn* adsp_hc,
+                                   bool* abop_update,
+                                   int64_t* ailp_update_timer);
+
+static bool m_locked_update_rcv_sack(struct dsd_htcp_conn* adsp_hc,
+                                     uint32_t ump_ack,
+                                     const char* achp_option_data,
+                                     int32_t imp_option_count);
+
+
+static bool m_locked_update_sack_pipe(struct dsd_htcp_conn* adsp_hc);
+
+static bool m_locked_sack_nextseg(struct dsd_htcp_conn* adsp_hc,
+                                  bool* abop_segment, uint32_t* aump_seq);
+
+static bool m_locked_create_sack_option(struct dsd_htcp_conn* adsp_hc,
+                                        char* achp_o, uint32_t* aump_len);
+
+static bool m_locked_start_header(struct dsd_htcp_conn* adsp_hc,
+                                  char* achp_header, uint32_t* aump_hlen,
+                                  uint8_t utp_flags, uint16_t usp_urg,
+                                  int64_t ilp_now_ms);
+
+static bool m_locked_prepare_syn(struct dsd_htcp_conn* adsp_hc,
+                                 char* achp_header, uint32_t* aump_hlen,
+                                 bool bop_ack, int64_t ilp_now_ms);
+
+static bool m_locked_packets_available(struct dsd_htcp_conn* adsp_hc,
+                                       bool* abop_available);
+
+static bool m_send_rst(struct dsd_htcp_conn* adsp_hc,
+                       uint32_t ump_seq_or_ack, bool bop_ack);
+
+static inline bool m_wlt(uint32_t ump_x, uint32_t ump_y)
+{
+    return (ump_x - ump_y) >= 0x80000000U;
+}
+
+static inline bool m_wle(uint32_t ump_x, uint32_t ump_y)
+{
+    return !m_wlt(ump_y, ump_x);
+}
+
+static inline bool m_wgt(uint32_t ump_x, uint32_t ump_y)
+{
+    return m_wlt(ump_y, ump_x);
+}
+
+static inline bool m_wge(uint32_t ump_x, uint32_t ump_y)
+{
+    return !m_wlt(ump_x, ump_y);
+}
+
+// check if low <= x < hi ignoring wraparound
+static inline
+bool m_within(uint32_t ump_low_inc, uint32_t ump_hi_exc, uint32_t ump_x)
+{
+    return ump_x - ump_low_inc < ump_hi_exc - ump_low_inc;
+}
+
+static inline uint16_t m_get_16_bit(const char* achp_p)
+{
+    return ((uint8_t)achp_p[0] << 8) |
+      (uint8_t)achp_p[1];
+}
+
+static inline uint32_t m_get_32_bit(const char* achp_p)
+{
+    return ((uint8_t)achp_p[0] << 24) | ((uint8_t)achp_p[1] << 16) |
+      ((uint8_t)achp_p[2] << 8) | (uint8_t)achp_p[3];
+}
+
+static inline void m_put_16_bit(char* achp_p, uint16_t usp_x)
+{
+    achp_p[0] = usp_x >> 8;
+    achp_p[1] = usp_x;
+}
+
+static inline void m_put_32_bit(char* achp_p, uint32_t ump_x)
+{
+    achp_p[0] = ump_x >> 24;
+    achp_p[1] = ump_x >> 16;
+    achp_p[2] = ump_x >> 8;
+    achp_p[3] = ump_x;
+}
+
+const struct dsd_htcp_config dsg_htcp_default_config = {
+    131070, // umc_in_bufsize
+    1360, // umc_in_mss
+    1360, // umc_out_mss_cap
+    30, // umc_msl_s
+    100, // umc_delay_ack_ms
+    true, // boc_sack
+    true, // boc_window_scaling
+    true, // boc_timestamp
+    ied_htcp_cca_cubic // iec_cc_algorithm
+};
+
+
+
+void m_htcp_init(struct dsd_htcp_conn* adsp_hc,
+                 const struct dsd_htcp_config* adsp_hconf,
+                 const struct dsd_htcp_callbacks* adsp_hcb,
+                 uint16_t usp_pseudo_header_chksum,
+                 uint16_t usp_local_port, uint16_t usp_remote_port)
+{
+    int64_t ilc_time;
+    uint8_t utl_hash;
+    bool bol_ret;
+    uint32_t uml_maxwin;
+
+    adsp_hc->adsc_cb = adsp_hcb;
+
+    bol_ret = adsp_hc->adsc_cb->amc_get_time(adsp_hc, &ilc_time);
+    HTCP_CHECK_CB_RET(amc_get_time);
+
+    if (adsp_hconf == NULL)
+        adsp_hconf = &dsg_htcp_default_config;
+
+    adsp_hc->usc_local_port = usp_local_port;
+    adsp_hc->usc_remote_port = usp_remote_port;
+    adsp_hc->usc_pseudo_header_chksum = usp_pseudo_header_chksum;
+
+    adsp_hc->iec_state = ied_htcp_listen;
+
+    adsp_hc->adsc_in_list = NULL;
+    adsp_hc->adsc_oo_list = NULL;
+    adsp_hc->adsc_sack_first = NULL;
+    adsp_hc->boc_oo_fin_received = false;
+
+    // hash does not really help - stale connections that might be detected
+    // by different iss would have same hash
+    utl_hash = usp_pseudo_header_chksum;
+    utl_hash ^= usp_pseudo_header_chksum >> 8;
+    utl_hash ^= usp_local_port;
+    utl_hash ^= usp_local_port >> 8;
+    utl_hash ^= usp_remote_port;
+    utl_hash ^= usp_remote_port >> 8;
+    adsp_hc->umc_snd_iss = (ilc_time << 8) | utl_hash;
+
+    adsp_hc->umc_snd_una = adsp_hc->umc_snd_iss;
+    adsp_hc->umc_snd_nxt = adsp_hc->umc_snd_iss + 1;
+    adsp_hc->umc_snd_nxt_cur = adsp_hc->umc_snd_nxt;
+    adsp_hc->umc_snd_wnd = 0;
+    adsp_hc->umc_snd_smss = adsp_hconf->umc_out_mss_cap;
+    if (adsp_hc->umc_snd_smss < 536)
+        adsp_hc->umc_snd_smss = 536;
+    if (adsp_hc->umc_snd_smss > 65495)
+        adsp_hc->umc_snd_smss = 65495;
+
+    adsp_hc->umc_rcv_rmss = adsp_hconf->umc_in_mss;
+    if (adsp_hc->umc_rcv_rmss < 536)
+        adsp_hc->umc_rcv_rmss = 536;
+    if (adsp_hc->umc_rcv_rmss > 65495)
+        adsp_hc->umc_rcv_rmss = 65495;
+
+    adsp_hc->umc_rcv_wnd = adsp_hconf->umc_in_bufsize;
+    adsp_hc->umc_rcv_wnd_throttled = 0;
+
+    adsp_hc->umc_msl_s = adsp_hconf->umc_msl_s;
+    adsp_hc->umc_delay_ack_ms = adsp_hconf->umc_delay_ack_ms;
+
+    adsp_hc->boc_use_sack = adsp_hconf->boc_sack;
+    adsp_hc->boc_use_winscale = adsp_hconf->boc_window_scaling;
+    adsp_hc->boc_use_timestamp = false; // SYN packet starts timing
+    adsp_hc->boc_use_timestamp = adsp_hconf->boc_timestamp;
+
+    adsp_hc->umc_ts_recent = 0;
+
+    if (adsp_hc->boc_use_winscale) {
+        uml_maxwin = 0xffff;
+        for (adsp_hc->umc_rcv_winscale = 0;
+             adsp_hc->umc_rcv_winscale < 14;
+             ++adsp_hc->umc_rcv_winscale) {
+
+            if (uml_maxwin >= adsp_hconf->umc_in_bufsize)
+                break;
+            uml_maxwin <<= 1;
+        }
+    }
+    adsp_hc->umc_snd_winscale = 0;
+
+    m_rto_init(adsp_hc);
+
+    switch (adsp_hconf->iec_cc_algorithm) {
+    case ied_htcp_cca_newreno:
+        adsp_hc->amc_cc_func = m_cc_newreno;
+        break;
+
+    case ied_htcp_cca_cubic:
+        adsp_hc->amc_cc_func = m_cc_cubic;
+        break;
+
+        // TODO: add more congestion control functions
+
+    default:
+        adsp_hc->amc_cc_func = m_cc_newreno;
+    }
+    // amc_cc_func(ied_htcp_cce_init, ...) is called after
+    // receiving SYN because of MSS
+
+    adsp_hc->umc_out_sack_count = 0;
+
+    adsp_hc->umc_dack = 0;
+    adsp_hc->boc_recovering = false;
+    adsp_hc->umc_sack_data_size = 0;
+    adsp_hc->umc_recover = adsp_hc->umc_snd_iss;
+    adsp_hc->umc_high_rxt = adsp_hc->umc_snd_iss; // TODO: check
+    adsp_hc->umc_exp_backoff = 1;
+
+    adsp_hc->ilc_timer = 0;
+    adsp_hc->ilc_da_timer = 0;
+
+    adsp_hc->iec_htcpc = ied_htcpc_open;
+    adsp_hc->achc_close_reason = NULL;
+    adsp_hc->inc_close_line = 0;
+
+    adsp_hc->umc_send_pending = 0;
+    adsp_hc->boc_out_send_recover = false;
+
+    adsp_hc->boc_out_packet_promised = false;
+    adsp_hc->boc_zwnd_probe = false;
+    adsp_hc->boc_recover_packet = false;
+    adsp_hc->utc_packet_flags = 0;
+    adsp_hc->umc_limited_transmit = 0;
+    adsp_hc->umc_tosend_dack = 0;
+    adsp_hc->umc_pending_dacks = 0;
+}
+
+void m_htcp_out_send(struct dsd_htcp_conn* adsp_hc,
+                     uint32_t ump_len, bool bop_push, bool bop_eof)
+{
+    bool bol_send_notify = false;
+    bool bol_incorrect_state = false;
+    int64_t ill_now_ms;
+    bool bol_ret;
+
+    // TODO: use bop_push
+    // currently it is always treated as true
+    // if we can treat it as false, we must timeout to send data anyway
+
+    bol_ret = adsp_hc->adsc_cb->amc_get_time(adsp_hc, &ill_now_ms);
+    HTCP_CHECK_CB_RET(amc_get_time);
+
+    HTCP_LOCK;
+
+    switch (adsp_hc->iec_state) {
+    case ied_htcp_closed:
+        break;
+
+    case ied_htcp_listen:
+        HTCP_LOCKED_ASSERT(m_get_tcp_flags_rst(adsp_hc->utc_packet_flags) == 0);
+        adsp_hc->utc_packet_flags = utd_tcp_syn;
+        adsp_hc->umc_send_pending += ump_len;
+        if (bop_eof)
+            adsp_hc->iec_state = ied_htcp_syn_sent_eof;
+        else
+            adsp_hc->iec_state = ied_htcp_syn_sent;
+        break;
+
+    case ied_htcp_syn_sent:
+        adsp_hc->umc_send_pending += ump_len;
+        if (bop_eof)
+            adsp_hc->iec_state = ied_htcp_syn_sent_eof;
+        break;
+
+    case ied_htcp_syn_rcvd:
+        adsp_hc->umc_send_pending += ump_len;
+        if (bop_eof)
+            adsp_hc->iec_state = ied_htcp_syn_rcvd_eof;
+        break;
+
+    case ied_htcp_established:
+        adsp_hc->umc_send_pending += ump_len;
+        if (bop_eof)
+            adsp_hc->iec_state = ied_htcp_fin_wait_1;
+        break;
+
+    case ied_htcp_close_wait:
+        adsp_hc->umc_send_pending += ump_len;
+        if (bop_eof)
+            adsp_hc->iec_state = ied_htcp_last_ack;
+        break;
+
+    default:
+        // eof already received or connection closed, should not receive data
+        if (ump_len > 0) {
+            adsp_hc->iec_state = ied_htcp_closed;
+            bol_incorrect_state = true;
+        }
+    }
+
+    bol_send_notify = false;
+    if (!adsp_hc->boc_out_packet_promised) {
+        bol_ret = m_locked_packets_available(adsp_hc, &bol_send_notify);
+        if (!bol_ret)
+            return;
+        adsp_hc->boc_out_packet_promised = bol_send_notify;
+    }
+
+    HTCP_UNLOCK;
+
+    if (bol_send_notify) {
+        bol_ret = adsp_hc->adsc_cb->amc_out_packets(adsp_hc);
+        HTCP_CHECK_CB_RET(amc_out_packets);
+    }
+
+    if (bol_incorrect_state) {
+        m_do_close(adsp_hc, ied_htcpc_interface_error, __LINE__,
+                   "m_htcp_out_send() call not expected");
+        return;
+    }
+}
+
+static bool m_check_packet(struct dsd_htcp_conn* adsp_hc,
+                           struct dsd_htcp_in_info* adsp_hii,
+                           uint32_t ump_tcp_len,
+                           bool* abop_packet_ok,
+                           uint32_t* aump_hlen,
+                           char* achp_header,
+                           const char** aachp_header)
+{
+    bool bol_ret;
+    const char* achl_part_buf;
+    uint32_t uml_part_len;
+    uint32_t uml_hofs;
+    uint16_t usl_chksum;
+    uint32_t uml_len;
+
+    // check if segment too short
+    if (ump_tcp_len < 20) {
+        bol_ret = adsp_hc->adsc_cb->amc_in_rel(adsp_hc, adsp_hii);
+        HTCP_CHECK_CB_RET_F(amc_in_rel);
+        *abop_packet_ok = false;
+        return true;
+    }
+
+    // get header (or first part of it)
+    bol_ret = adsp_hc->adsc_cb->
+        amc_in_get(adsp_hc, adsp_hii, 0, &achl_part_buf, &uml_part_len);
+    HTCP_CHECK_CB_RET_F(amc_in_get);
+
+    // calculate header length if header available
+    if (uml_part_len < 20) {
+        *aump_hlen = 20;
+    } else {
+        *aump_hlen = m_get_calc_tcp_hlen(achl_part_buf);
+        // check if segment shorter than header or invalid header length
+        if (ump_tcp_len < *aump_hlen || *aump_hlen < 20) {
+            bol_ret = adsp_hc->adsc_cb->amc_in_rel(adsp_hc, adsp_hii);
+            HTCP_CHECK_CB_RET_F(amc_in_rel);
+            *abop_packet_ok = false;
+            return true;
+        }
+    }
+
+    if (uml_part_len < *aump_hlen) {
+        // copy fragmented header
+
+        memcpy(achp_header, achl_part_buf, uml_part_len);
+        uml_hofs = uml_part_len;
+        do {
+            // get next part of header
+            bol_ret = adsp_hc->adsc_cb->
+                amc_in_get(adsp_hc, adsp_hii, uml_hofs,
+                           &achl_part_buf, &uml_part_len);
+            HTCP_CHECK_CB_RET_F(amc_in_get);
+
+            // can we calculate header length?
+            if (uml_hofs < 20 && uml_hofs + uml_part_len >= 20) {
+                // update *aump_hlen
+                memcpy(achp_header + uml_hofs, achl_part_buf, 20 - uml_hofs);
+                achl_part_buf += 20 - uml_hofs;
+                uml_part_len -= 20 - uml_hofs;
+                uml_hofs = 20;
+                *aump_hlen = m_get_calc_tcp_hlen(achl_part_buf);
+                // check if segment shorter than header or invalid header length
+                if (ump_tcp_len < *aump_hlen || *aump_hlen < 20) {
+                    bol_ret = adsp_hc->adsc_cb->amc_in_rel(adsp_hc, adsp_hii);
+                    HTCP_CHECK_CB_RET_F(amc_in_rel);
+                    *abop_packet_ok = false;
+                    return true;
+                }
+            }
+
+            if (uml_hofs + uml_part_len > *aump_hlen)
+                uml_len = *aump_hlen - uml_hofs;
+            else
+                uml_len = uml_part_len;
+            memcpy(achp_header + uml_hofs, achl_part_buf, uml_len);
+            uml_hofs += uml_len;
+        } while (uml_hofs < *aump_hlen);
+
+        *aachp_header = achp_header;
+        achl_part_buf += uml_len;
+        uml_part_len -= uml_len;
+    } else {
+        *aachp_header = achl_part_buf;
+        achl_part_buf += *aump_hlen;
+        uml_part_len -= *aump_hlen;
+    }
+
+    // check ports
+    if (m_get_tcp_src_port(*aachp_header) != adsp_hc->usc_remote_port ||
+        m_get_tcp_dst_port(*aachp_header) != adsp_hc->usc_local_port) {
+
+        bol_ret = adsp_hc->adsc_cb->amc_in_rel(adsp_hc, adsp_hii);
+        HTCP_CHECK_CB_RET_F(amc_in_rel);
+        *abop_packet_ok = false;
+        return true;
+    }
+
+    // check checksum
+    usl_chksum = adsp_hc->usc_pseudo_header_chksum;
+    uml_len = *aump_hlen;
+    while (uml_len < ump_tcp_len) {
+        if (uml_len != *aump_hlen || uml_part_len == 0) {
+            bol_ret = adsp_hc->adsc_cb->
+                amc_in_get(adsp_hc, adsp_hii, uml_len,
+                           &achl_part_buf, &uml_part_len);
+            HTCP_CHECK_CB_RET_F(amc_in_get);
+        }
+
+        if (uml_len + uml_part_len > ump_tcp_len)
+            uml_part_len = ump_tcp_len - uml_len;
+
+        if (uml_len % 2 == 0) {
+            usl_chksum = m_calc_tcp_data_chksum(achl_part_buf,
+                                                uml_part_len,
+                                                usl_chksum);
+        } else {
+            usl_chksum = m_calc_tcp_odd_data_chksum(achl_part_buf,
+                                                    uml_part_len,
+                                                    usl_chksum);
+        }
+
+        uml_len += uml_part_len;
+    }
+
+    if (m_calc_tcp_chksum(*aachp_header, ump_tcp_len - *aump_hlen, usl_chksum)
+        != m_get_tcp_chksum(*aachp_header)) {
+
+        bol_ret = adsp_hc->adsc_cb->amc_in_rel(adsp_hc, adsp_hii);
+        HTCP_CHECK_CB_RET_F(amc_in_rel);
+        *abop_packet_ok = false;
+        return true;
+    }
+
+    *abop_packet_ok = true;
+    return true;
+}
+
+static void m_do_htcp_in_packet(struct dsd_htcp_conn* adsp_hc,
+                                struct dsd_htcp_in_info* adsp_hii,
+                                uint32_t ump_tcp_len,
+                                struct dsd_htcp_in_info** aadsp_to_del);
+
+void m_htcp_in_packet(struct dsd_htcp_conn* adsp_hc,
+                      struct dsd_htcp_in_info* adsp_hii,
+                      uint32_t ump_tcp_len)
+{
+    struct dsd_htcp_in_info* adsl_to_del = NULL;
+    struct dsd_htcp_in_info* adsl_hii;
+
+    m_do_htcp_in_packet(adsp_hc, adsp_hii, ump_tcp_len, &adsl_to_del);
+
+    while (adsl_to_del != NULL) {
+        adsl_hii = adsl_to_del;
+        adsl_to_del = adsl_to_del->adsc_next;
+        /*
+         * Do not check for errors when realeasing:
+         * if freeing here, the connection was terminated anyway.
+         */
+        adsp_hc->adsc_cb->amc_in_rel(adsp_hc, adsl_hii);
+    }
+}
+
+static void m_do_htcp_in_packet(struct dsd_htcp_conn* adsp_hc,
+                                struct dsd_htcp_in_info* adsp_hii,
+                                uint32_t ump_tcp_len,
+                                struct dsd_htcp_in_info** aadsp_to_del)
+{
+    bool bol_packet_ok;
+
+    uint32_t uml_seq;
+    uint32_t uml_ack;
+    uint32_t uml_win;
+    uint32_t uml_dlen;
+    uint8_t utl_flags;
+    char chrl_header[60];
+    uint32_t uml_hlen;
+    const char* achl_header;
+    uint32_t uml_len;
+    int64_t ill_now_ms;
+
+    bool bol_invalid;
+    bool bol_fin;
+    bool bol_just_ack;
+    bool bol_ret;
+    const char* achl_option;
+    const char* achl_ts_option;
+    const char* achl_sack_option;
+    uint32_t uml_sack_option_count;
+    uint32_t uml_seg_tsval;
+    uint32_t uml_seg_tsecr;
+    uint32_t uml_acked_len;
+    struct dsd_htcp_in_info* adsl_hii;
+    struct dsd_htcp_in_info** aadsl_hii;
+    uint32_t uml_buf_b;
+    uint32_t uml_buf_e;
+    uint32_t uml_block_b;
+    uint32_t uml_block_e;
+    uint32_t uml_remove = 0;
+
+    bool bol_invalid_init = false;
+    bool bol_send_notify = false;
+    bool bol_update_timer = false;
+    int64_t ill_update_timer;
+    bool bol_reply_reset = false;
+    bool bol_conn_established = false;
+    bool bol_reset_by_peer = false;
+    bool bol_conn_refused = false;
+    bool bol_conn_closed = false;
+    bool bol_new_data = false;
+
+    /* if check fails, packet is freed inside m_check_packet() */
+    bol_ret = m_check_packet(adsp_hc, adsp_hii, ump_tcp_len, &bol_packet_ok,
+                             &uml_hlen, chrl_header, &achl_header);
+    if (!bol_ret)
+        return;
+    if (!bol_packet_ok) {
+        HTCP_LOCK;
+        if (adsp_hc->iec_state == ied_htcp_listen) {
+            bol_invalid_init = true;
+            adsp_hc->iec_state = ied_htcp_closed;
+        }
+        HTCP_UNLOCK;
+
+        if (bol_invalid_init)
+            m_do_abort(adsp_hc, ied_htcpc_conn_error, __LINE__,
+                       "received invalid initial packet");
+
+        return;
+    }
+
+    bol_ret = adsp_hc->adsc_cb->amc_get_time(adsp_hc, &ill_now_ms);
+    HTCP_CHECK_CB_RET(amc_get_time);
+
+    // start packet processing
+
+    bol_update_timer = false;
+
+    // copy fields - may be overwritten when writing to adsp_hii or chrl_header
+    uml_seq = m_get_tcp_seqn(achl_header);
+    uml_ack = m_get_tcp_ackn(achl_header);
+    uml_win = m_get_tcp_window(achl_header); // soon scaled
+    uml_dlen = ump_tcp_len - uml_hlen;
+    utl_flags = m_get_tcp_flags(achl_header);
+
+    adsp_hii->umc_offset = uml_hlen;
+
+    adsp_hii->adsc_next = *aadsp_to_del;
+    *aadsp_to_del = adsp_hii;
+
+    HTCP_LOCK;
+
+    if (!m_get_tcp_flags_syn(utl_flags))
+        uml_win <<= adsp_hc->umc_snd_winscale;
+
+    switch (adsp_hc->iec_state) {
+
+    case ied_htcp_closed:
+        if (m_get_tcp_flags_rst(utl_flags))
+            break;
+        bol_reply_reset = true;
+        break;
+
+    case ied_htcp_listen:
+        if (m_get_tcp_flags_rst(utl_flags)) {
+            bol_invalid_init = true;
+            break;
+        }
+
+        if (m_get_tcp_flags_ack(utl_flags)) {
+            bol_reply_reset = true;
+            bol_invalid_init = true;
+            break;
+        }
+
+        if (!m_get_tcp_flags_syn(utl_flags)) {
+            bol_invalid_init = true;
+            break;
+        }
+
+        bol_ret = m_locked_process_syn_options(adsp_hc, achl_header, uml_hlen);
+        if (!bol_ret)
+            return;
+
+        adsp_hc->umc_rcv_irs = uml_seq;
+        adsp_hc->umc_rcv_nxt = uml_seq + 1;
+        adsp_hc->umc_last_ack_sent = uml_seq + 1;
+
+        adsp_hc->amc_cc_func(ied_htcp_cce_init,
+                             ill_now_ms, adsp_hc->umc_srtt_ms,
+                             adsp_hc->umc_snd_smss, 0,
+                             &adsp_hc->dsc_cc);
+
+        if (uml_dlen > adsp_hc->umc_snd_wnd) {
+            uml_dlen = adsp_hc->umc_snd_wnd;
+        }
+
+        if (uml_dlen > 0) {
+            uml_dlen = 0;// TODO: accept data?
+        }
+
+        HTCP_LOCKED_ASSERT(m_get_tcp_flags_rst(adsp_hc->utc_packet_flags) == 0);
+        adsp_hc->utc_packet_flags = utd_tcp_syn_ack;
+
+        adsp_hc->iec_state = ied_htcp_syn_rcvd;
+        break;
+
+    case ied_htcp_syn_sent:
+    case ied_htcp_syn_sent_eof:
+        if (m_get_tcp_flags_ack(utl_flags)) {
+            if (!m_within(adsp_hc->umc_snd_iss + 1, adsp_hc->umc_snd_nxt + 1,
+                          uml_ack) ||
+                !m_within(adsp_hc->umc_snd_una, adsp_hc->umc_snd_nxt + 1,
+                          uml_ack)) {
+
+                if (m_get_tcp_flags_rst(utl_flags))
+                    break;
+                bol_reply_reset = true;
+                break;
+            }
+        };
+
+        if (m_get_tcp_flags_rst(utl_flags)) {
+            if (!m_get_tcp_flags_ack(utl_flags))
+                break;
+            bol_conn_refused = true;
+            adsp_hc->iec_state = ied_htcp_closed;
+            break;
+        }
+
+        if (!m_get_tcp_flags_syn(utl_flags))
+            break;
+
+        bol_ret = m_locked_process_syn_options(adsp_hc, achl_header, uml_hlen);
+        if (!bol_ret)
+            return;
+
+        adsp_hc->umc_rcv_irs = uml_seq;
+        adsp_hc->umc_rcv_nxt = uml_seq + 1;
+        adsp_hc->umc_last_ack_sent = uml_seq + 1;
+
+        adsp_hc->amc_cc_func(ied_htcp_cce_init,
+                             ill_now_ms, adsp_hc->umc_srtt_ms,
+                             adsp_hc->umc_snd_smss, 0,
+                             &adsp_hc->dsc_cc);
+
+        if (uml_dlen > adsp_hc->umc_snd_wnd) {
+            // initial umc_snd_wnd == 0, so this currently ensures uml_dlen == 0
+            uml_dlen = adsp_hc->umc_snd_wnd;
+        }
+
+        if (uml_dlen > 0) {
+            uml_dlen = 0; // TODO: accept data on SYN and SYNACK? RFC says yes
+        }
+
+        if (m_get_tcp_flags_ack(utl_flags)) {
+            adsp_hc->umc_snd_una = uml_ack;
+            adsp_hc->umc_snd_wnd = uml_win;
+
+            HTCP_LOCKED_ASSERT(m_get_tcp_flags_rst(adsp_hc->utc_packet_flags)
+                               == 0);
+            adsp_hc->utc_packet_flags = utd_tcp_ack;
+            bol_conn_established = true;
+            if (adsp_hc->iec_state == ied_htcp_syn_sent_eof)
+                adsp_hc->iec_state = ied_htcp_fin_wait_1;
+            else
+                adsp_hc->iec_state = ied_htcp_established;
+        } else {
+            HTCP_LOCKED_ASSERT(m_get_tcp_flags_rst(adsp_hc->utc_packet_flags)
+                               == 0);
+            adsp_hc->utc_packet_flags = utd_tcp_syn_ack;
+
+            adsp_hc->iec_state = ied_htcp_syn_rcvd;
+        }
+        break;
+
+    case ied_htcp_syn_rcvd:
+    case ied_htcp_syn_rcvd_eof:
+    case ied_htcp_established:
+    case ied_htcp_fin_wait_1:
+    case ied_htcp_fin_wait_2:
+    case ied_htcp_close_wait:
+    case ied_htcp_closing:
+    case ied_htcp_last_ack:
+    case ied_htcp_time_wait:
+
+        bol_fin = m_get_tcp_flags_fin(utl_flags) != 0;
+        bol_just_ack = m_get_tcp_flags_ack(utl_flags) &&
+            !bol_fin &&
+            uml_dlen == 0;
+
+        achl_ts_option = NULL;
+        achl_sack_option = NULL;
+        uml_sack_option_count = 0;
+
+        if (adsp_hc->boc_use_timestamp || adsp_hc->boc_use_sack) {
+            // traverse options to find relevant options
+            achl_option = m_first_tcp_option(achl_header,
+                                             achl_header + uml_hlen);
+            while (achl_option < achl_header + uml_hlen) {
+                if (adsp_hc->boc_use_timestamp &&
+                    achl_ts_option == NULL &&
+                    achl_option[0] == 8 &&
+                    achl_option[1] == 10) {
+                    achl_ts_option = achl_option + 2;
+                    if (!adsp_hc->boc_use_sack || achl_sack_option != NULL)
+                        break;
+                }
+
+                if (adsp_hc->boc_use_sack &&
+                    achl_sack_option == NULL &&
+                    achl_option[0] == 5 &&
+                    achl_option[1] >= 10 &&
+                    achl_option[1] % 8 == 2) {
+                    achl_sack_option = achl_option + 2;
+                    uml_sack_option_count = achl_option[1] / 8;
+                    if (!adsp_hc->boc_use_timestamp || achl_ts_option != NULL)
+                        break;
+                }
+
+                achl_option = m_next_tcp_option(achl_option,
+                                                achl_header + uml_hlen);
+            }
+        }
+
+        // PAWS, check the sequence number
+        bol_invalid = false;
+        if (!bol_invalid) {
+            if (adsp_hc->boc_use_timestamp) {
+                if (achl_ts_option != NULL) {
+                    uml_seg_tsval = m_get_32_bit(achl_ts_option);
+                    uml_seg_tsecr = m_get_32_bit(achl_ts_option + 4);
+                    bol_invalid =
+                        m_wlt(uml_seg_tsval, adsp_hc->umc_ts_recent) &&
+                        ill_now_ms / 1000 - adsp_hc->imc_recent_age_s >= 0 &&
+                        !m_get_tcp_flags_rst(utl_flags);
+                } else {
+                    bol_invalid = !m_get_tcp_flags_rst(utl_flags);
+                }
+            }
+        }
+        if (!bol_invalid) {
+            if (adsp_hc->umc_rcv_wnd == 0) {
+                bol_invalid = uml_dlen != 0 || uml_seq != adsp_hc->umc_rcv_nxt;
+            } else {
+                bol_invalid =
+                    !m_within(adsp_hc->umc_rcv_nxt,
+                              adsp_hc->umc_rcv_nxt + adsp_hc->umc_rcv_wnd,
+                              uml_seq) &&
+                    (uml_dlen == 0 ||
+                     !m_within(adsp_hc->umc_rcv_nxt,
+                               adsp_hc->umc_rcv_nxt + adsp_hc->umc_rcv_wnd,
+                               uml_seq + uml_dlen - 1));
+            }
+        }
+        if (!bol_invalid && m_get_tcp_flags_ack(utl_flags)) {
+            bol_invalid = !m_within(adsp_hc->umc_snd_una,
+                                    adsp_hc->umc_snd_nxt + 1,
+                                    uml_ack);
+        }
+        if (bol_invalid) {
+            if (!m_get_tcp_flags_rst(utl_flags)) {
+                adsp_hc->utc_packet_flags |= utd_tcp_ack;
+            }
+            break;
+        }
+
+        // check if packet goes beyond a previously received FIN
+        if (adsp_hc->boc_oo_fin_received) {
+            HTCP_LOCKED_TEST(m_wle(uml_seq + uml_dlen, adsp_hc->umc_oo_fin_seq),
+                             "received data beyond previously received FIN");
+        }
+
+        // chop off packets that go beyond receive window
+        if (m_within(uml_seq, uml_seq + uml_dlen,
+                     adsp_hc->umc_rcv_nxt + adsp_hc->umc_rcv_wnd)) {
+
+            bol_fin = false;
+            uml_dlen = adsp_hc->umc_rcv_nxt + adsp_hc->umc_rcv_wnd - uml_seq;
+        }
+
+        // chop off duplicate data at beginning
+        if (uml_dlen > 0 &&
+            m_within(uml_seq + 1, uml_seq + uml_dlen, adsp_hc->umc_rcv_nxt)) {
+
+            uml_dlen -= adsp_hc->umc_rcv_nxt - uml_seq;
+            adsp_hii->umc_offset += adsp_hc->umc_rcv_nxt - uml_seq;
+            uml_seq = adsp_hc->umc_rcv_nxt;
+        }
+
+        // check the RST bit
+        if (m_get_tcp_flags_rst(utl_flags)) {
+            bol_reset_by_peer = true;
+            adsp_hc->iec_state = ied_htcp_closed;
+            break;
+        }
+
+        // check the SYN bit
+        if (m_get_tcp_flags_syn(utl_flags)) {
+            bol_reply_reset = true;
+            bol_reset_by_peer = true;
+            adsp_hc->iec_state = ied_htcp_closed;
+            break;
+        }
+
+        // check the ACK field
+        if (!m_get_tcp_flags_ack(utl_flags))
+            break;
+
+        if (adsp_hc->iec_state == ied_htcp_syn_rcvd ||
+            adsp_hc->iec_state == ied_htcp_syn_rcvd_eof) {
+
+            // RFC 793 indicates
+            // adsp_hc->umc_snd_una, adsp_hc->umc_snd_nxt + 1,
+            // but this allows an ack which does not acknowledge syn
+            // to change our state to ied_htcp_established
+            if (!m_within(adsp_hc->umc_snd_una + 1, adsp_hc->umc_snd_nxt + 1,
+                          uml_ack)) {
+
+                if (uml_ack != adsp_hc->umc_snd_una)
+                    bol_reply_reset = true;
+                // instead of following RFC, drop the segment
+                break;
+            }
+
+            adsp_hc->umc_snd_una = uml_ack;
+            adsp_hc->umc_snd_wnd = uml_win;
+            // TODO: check window update
+            bol_conn_established = true;
+            if (adsp_hc->iec_state == ied_htcp_syn_rcvd_eof)
+                adsp_hc->iec_state = ied_htcp_fin_wait_1;
+            else
+                adsp_hc->iec_state = ied_htcp_established;
+            bol_ret = m_locked_rto_received(adsp_hc, ill_now_ms);
+            if (!bol_ret)
+                return;
+        }
+
+        if (adsp_hc->boc_use_timestamp) {
+            if (m_wle(uml_seq, adsp_hc->umc_last_ack_sent)) {
+                adsp_hc->umc_ts_recent = uml_seg_tsval;
+                adsp_hc->imc_recent_age_s = ill_now_ms / 1000;
+            }
+        }
+
+        if (adsp_hc->boc_use_sack) {
+            bol_ret = m_locked_update_rcv_sack(adsp_hc, uml_ack,
+                                               achl_sack_option,
+                                               uml_sack_option_count);
+            if (!bol_ret)
+                return;
+        }
+
+        if (m_within(adsp_hc->umc_snd_una + 1, adsp_hc->umc_snd_nxt + 1,
+                     uml_ack)) {
+            // new ack
+
+            if (m_wlt(adsp_hc->umc_snd_nxt_cur, uml_ack))
+                adsp_hc->umc_snd_nxt_cur = uml_ack;
+
+            bol_ret = m_locked_restart_rexmt_timer(adsp_hc, &bol_update_timer,
+                                                   &ill_update_timer,
+                                                   ill_now_ms);
+            if (!bol_ret)
+                return;
+
+            if (adsp_hc->boc_use_timestamp) {
+                HTCP_LOCKED_ASSERT(achl_ts_option != NULL);
+                bol_ret =
+                    m_locked_rto_timestamp_update(adsp_hc, ill_now_ms,
+                                                  m_get_32_bit(achl_ts_option +
+                                                               4));
+                if (!bol_ret)
+                    return;
+            }
+
+            HTCP_LOCKED_ASSERT(adsp_hc->iec_state == ied_htcp_established ||
+                               adsp_hc->iec_state == ied_htcp_fin_wait_1 ||
+                               adsp_hc->iec_state == ied_htcp_closing ||
+                               adsp_hc->iec_state == ied_htcp_close_wait ||
+                               adsp_hc->iec_state == ied_htcp_last_ack);
+
+            uml_acked_len = uml_ack - adsp_hc->umc_snd_una;
+
+            // check if sent FIN bit acknowledged
+            if (uml_acked_len == adsp_hc->umc_send_pending + 1) {
+
+                HTCP_LOCKED_ASSERT(adsp_hc->iec_state == ied_htcp_fin_wait_1 ||
+                                   adsp_hc->iec_state == ied_htcp_closing ||
+                                   adsp_hc->iec_state == ied_htcp_last_ack);
+
+                --uml_acked_len;
+
+                switch (adsp_hc->iec_state) {
+                case ied_htcp_fin_wait_1:
+                    adsp_hc->iec_state = ied_htcp_fin_wait_2;
+                    break;
+
+                case ied_htcp_closing:
+                    bol_ret =
+                        m_locked_restart_time_wait_timer(adsp_hc,
+                                                         &bol_update_timer,
+                                                         &ill_update_timer,
+                                                         ill_now_ms);
+                    if (!bol_ret)
+                        return;
+                    adsp_hc->iec_state = ied_htcp_time_wait;
+                    break;
+
+                case ied_htcp_last_ack:
+                    bol_conn_closed = true;
+                    adsp_hc->iec_state = ied_htcp_closed;
+                    break;
+
+                default:
+                    // should not arrive here
+                    HTCP_LOCKED_ERROR("processing invalid ACK number");
+                }
+            }
+
+            adsp_hc->umc_snd_una = uml_ack;
+            // TODO: fix window update
+            adsp_hc->umc_snd_wnd = uml_win;
+            // leave exponential backoff for zero window probe
+            if (uml_win != 0)
+            adsp_hc->umc_exp_backoff = 1;
+            // TODO: release/reset rexmt timer
+
+            // to empty relevent section from out queue
+            uml_remove += uml_acked_len;
+
+            // update congestion window, recovery mechanisms
+            if (adsp_hc->boc_recovering) {
+                if (m_wge(adsp_hc->umc_snd_una, adsp_hc->umc_recover)) {
+                    // full ack - same with and without sack
+
+                    // note: since recovering (not timeout recovery),
+                    //       umc_snd_nxt == umc_snd_nxt_cur
+                    HTCP_LOCKED_ASSERT(adsp_hc->umc_snd_nxt_cur ==
+                                       adsp_hc->umc_snd_nxt); // recovering
+
+                    adsp_hc->amc_cc_func(ied_htcp_cce_recover_ack,
+                                         ill_now_ms,
+                                         adsp_hc->umc_srtt_ms,
+                                         adsp_hc->umc_snd_smss,
+                                         adsp_hc->umc_snd_nxt -
+                                         adsp_hc->umc_snd_una,
+                                         &adsp_hc->dsc_cc);
+                    adsp_hc->boc_recovering = false;
+                } else {
+                    // partial ack
+                    if (!adsp_hc->boc_use_sack) {
+                        adsp_hc->dsc_cc.umc_cwnd -= uml_acked_len;
+                        if (uml_acked_len >= adsp_hc->umc_snd_smss)
+                            adsp_hc->dsc_cc.umc_cwnd += adsp_hc->umc_snd_smss;
+                        if (!adsp_hc->boc_out_send_recover) {
+                            // if there is an recovery packet pending,
+                            // we cannot handle sending additional packet
+
+                            if (adsp_hc->umc_send_pending > 0) {
+                                adsp_hc->boc_out_send_recover = true;
+                                adsp_hc->umc_out_send_recover_seq =
+                                    adsp_hc->umc_snd_una;
+                                if (adsp_hc->boc_pack_time) {
+                                    bol_ret = m_locked_restart_rexmt_timer
+                                        (adsp_hc,
+                                         &bol_update_timer, &ill_update_timer,
+                                         ill_now_ms);
+                                    if (!bol_ret)
+                                        return;
+                                    adsp_hc->boc_pack_time = false;
+                                }
+                            }
+                        }
+                    }
+                }
+            } else { // !adsp_hc->boc_recovering
+                adsp_hc->dsc_cc.umc_bytes_acked += uml_acked_len;
+                adsp_hc->amc_cc_func(ied_htcp_cce_newack,
+                                     ill_now_ms,
+                                     adsp_hc->umc_srtt_ms,
+                                     adsp_hc->umc_snd_smss,
+                                     adsp_hc->umc_snd_nxt_cur -
+                                     adsp_hc->umc_snd_una,
+                                     &adsp_hc->dsc_cc);
+                if (m_wlt(adsp_hc->umc_recover, adsp_hc->umc_snd_una))
+                    adsp_hc->umc_recover = adsp_hc->umc_snd_una;
+            }
+            adsp_hc->umc_dack = 0;
+
+            bol_ret = m_locked_rto_received(adsp_hc, ill_now_ms);
+            if (!bol_ret)
+                return;
+        } else if (uml_ack == adsp_hc->umc_snd_nxt) {
+            // dup ack, but no unacked data
+
+            // update window size
+            // TODO: fix window update
+            if (adsp_hc->umc_snd_wnd < uml_win)
+                adsp_hc->umc_snd_wnd = uml_win;
+        } else if (uml_ack == adsp_hc->umc_snd_una && bol_just_ack) {
+            // duplicate ack
+
+            ++adsp_hc->umc_dack;
+            if ((int)adsp_hc->umc_dack == ins_dup_thresh &&
+                !adsp_hc->boc_recovering &&
+                m_wge(adsp_hc->umc_snd_una, adsp_hc->umc_recover)) {
+
+                // do fast retransmission, start fast recovery
+
+                // note: since recovering (not timeout recovery),
+                //       umc_snd_nxt == umc_snd_nxt_cur.
+                //       Otherwise, umc_snd_una >= umc_recover not satisfied.
+                HTCP_LOCKED_ASSERT(adsp_hc->umc_snd_nxt_cur ==
+                                   adsp_hc->umc_snd_nxt); // recovering
+
+                adsp_hc->boc_recovering = true;
+                adsp_hc->boc_pack_time = true;
+                adsp_hc->umc_recover = adsp_hc->umc_snd_nxt;
+                if (adsp_hc->boc_use_sack) {
+                    adsp_hc->amc_cc_func(ied_htcp_cce_three_dup_sack,
+                                         ill_now_ms,
+                                         adsp_hc->umc_srtt_ms,
+                                         adsp_hc->umc_snd_smss,
+                                         adsp_hc->umc_snd_nxt -
+                                         adsp_hc->umc_snd_una,
+                                         &adsp_hc->dsc_cc);
+
+                    bol_ret = m_locked_update_sack_pipe(adsp_hc);
+                    if (!bol_ret)
+                        return;
+                } else {
+                    adsp_hc->amc_cc_func(ied_htcp_cce_three_dup,
+                                         ill_now_ms,
+                                         adsp_hc->umc_srtt_ms,
+                                         adsp_hc->umc_snd_smss,
+                                         adsp_hc->umc_snd_nxt -
+                                         adsp_hc->umc_snd_una,
+                                         &adsp_hc->dsc_cc);
+                }
+
+                if (adsp_hc->umc_snd_nxt != adsp_hc->umc_snd_una &&
+                    !adsp_hc->boc_out_send_recover) {
+
+                    adsp_hc->boc_out_send_recover = true;
+                    adsp_hc->umc_out_send_recover_seq = adsp_hc->umc_snd_una;
+                }
+            } else if (adsp_hc->boc_recovering) {
+                // fast recovery
+                if (adsp_hc->boc_use_sack) {
+                    bol_ret = m_locked_update_sack_pipe(adsp_hc);
+                    if (!bol_ret)
+                        return;
+                } else {
+                    HTCP_LOCKED_ASSERT(adsp_hc->umc_snd_nxt_cur ==
+                                       adsp_hc->umc_snd_nxt); // recovering
+
+                    adsp_hc->amc_cc_func(ied_htcp_cce_more_dup,
+                                         ill_now_ms,
+                                         adsp_hc->umc_srtt_ms,
+                                         adsp_hc->umc_snd_smss,
+                                         adsp_hc->umc_snd_nxt -
+                                         adsp_hc->umc_snd_una,
+                                         &adsp_hc->dsc_cc);
+                    ++adsp_hc->umc_pending_dacks;
+                }
+            } else if (adsp_hc->umc_dack < (uint32_t)ins_dup_thresh &&
+                       !adsp_hc->boc_out_send_recover &&
+                       adsp_hc->umc_snd_nxt_cur == adsp_hc->umc_snd_nxt) {
+
+                // limited transmit
+                uml_len = adsp_hc->umc_send_pending;
+                if (uml_len > adsp_hc->umc_snd_wnd)
+                    uml_len = adsp_hc->umc_snd_wnd;
+                if (uml_len > adsp_hc->umc_snd_nxt - adsp_hc->umc_snd_una) {
+
+                    adsp_hc->boc_out_send_recover = true;
+                    adsp_hc->umc_out_send_recover_seq = adsp_hc->umc_snd_nxt;
+                }
+            }
+        }
+
+        if (uml_dlen > 0) {
+            HTCP_LOCKED_TEST(*aadsp_to_del == adsp_hii,
+                             "incorrect internal state");
+            *aadsp_to_del = (*aadsp_to_del)->adsc_next;
+            HTCP_LOCKED_ASSERT(*aadsp_to_del == NULL);
+        }
+
+        // process segment text
+        if (uml_dlen > 0 &&
+            m_within(uml_seq, uml_seq + uml_dlen, adsp_hc->umc_rcv_nxt)) {
+            // append data to input buffer
+
+            bol_new_data = true;
+            aadsl_hii = &adsp_hc->adsc_in_list;
+            while (*aadsl_hii != NULL)
+                aadsl_hii = &(*aadsl_hii)->adsc_next;
+            *aadsl_hii = adsp_hii;
+            adsp_hii->adsc_next = NULL;
+            aadsl_hii = &adsp_hii->adsc_next;
+
+            adsp_hii->umc_seq = adsp_hc->umc_rcv_nxt;
+            adsp_hii->umc_len = uml_dlen;
+            adsp_hii->boc_push = m_get_tcp_flags_psh(utl_flags) == 1;
+
+            adsp_hc->umc_rcv_nxt = uml_seq + uml_dlen;
+
+            if (bol_fin) {
+                HTCP_LOCKED_TEST(!adsp_hc->boc_oo_fin_received ||
+                                 adsp_hc->umc_oo_fin_seq == uml_seq + uml_dlen,
+                                 "conflicting FINs received");
+                adsp_hc->boc_oo_fin_received = false;
+
+                // we will not need out-of-order segments, mark for release
+                adsp_hc->adsc_sack_first = NULL;
+                while (adsp_hc->adsc_oo_list != NULL) {
+                    adsl_hii = adsp_hc->adsc_oo_list;
+                    adsp_hc->adsc_oo_list = adsp_hc->adsc_oo_list->adsc_next;
+                    adsl_hii->adsc_next = *aadsp_to_del;
+                    *aadsp_to_del = adsl_hii;
+                }
+
+                // TODO: test out of order segments not beyond FIN
+            } else {
+                // Check out of order segments available.
+                while ((adsl_hii = adsp_hc->adsc_oo_list) != NULL) {
+                    if (m_wge(uml_seq + uml_dlen,
+                              adsl_hii->umc_seq + adsl_hii->umc_len)) {
+
+                        // out of order segment redundant
+                        adsp_hc->adsc_oo_list = adsl_hii->adsc_next;
+                        adsl_hii->adsc_next = *aadsp_to_del;
+                        *aadsp_to_del = adsl_hii;
+                    } else if (m_wge(uml_seq + uml_dlen, adsl_hii->umc_seq)) {
+                        // use out of order segment
+
+                        // append data to input buffer
+
+                        adsp_hc->adsc_oo_list = adsl_hii->adsc_next;
+                        *aadsl_hii = adsl_hii;
+                        adsl_hii->adsc_next = NULL;
+                        aadsl_hii = &adsl_hii->adsc_next;
+
+                        if (adsl_hii->umc_seq != uml_seq + uml_dlen) {
+                            adsl_hii->umc_offset += uml_seq + uml_dlen -
+                                adsl_hii->umc_seq;
+                            adsl_hii->umc_len -= uml_seq + uml_dlen -
+                                adsl_hii->umc_seq;
+                            adsl_hii->umc_seq = uml_seq + uml_dlen;
+                        }
+
+                        uml_dlen += adsl_hii->umc_len;
+                    } else {
+                        // out of order segments still not usable
+                        break;
+                    }
+
+                    // here if oo segment removed from queue
+                    if (adsp_hc->adsc_sack_first == adsl_hii)
+                        adsp_hc->adsc_sack_first = adsp_hc->adsc_oo_list;
+                }
+
+                adsp_hc->umc_rcv_nxt = uml_seq + uml_dlen;
+
+                // check out of order FIN
+                if (adsp_hc->boc_oo_fin_received &&
+                    adsp_hc->umc_oo_fin_seq == adsp_hc->umc_rcv_nxt) {
+                    bol_fin = true;
+                    adsp_hc->boc_oo_fin_received = false;
+                }
+            } // !bol_fin
+
+            adsp_hc->umc_rcv_wnd -= uml_dlen;
+
+            // notify application
+            if (adsp_hc->ilc_da_timer == 0) {
+                bol_ret = m_locked_start_da_timer(adsp_hc, &bol_update_timer,
+                                                  &ill_update_timer,
+                                                  ill_now_ms);
+                if (!bol_ret)
+                    return;
+            } else {
+                bol_ret = m_locked_stop_da_timer(adsp_hc, &bol_update_timer,
+                                                 &ill_update_timer);
+                if (!bol_ret)
+                    return;
+                if (adsp_hc->utc_packet_flags == 0)
+                    adsp_hc->utc_packet_flags = utd_tcp_ack;
+            }
+
+        } else if (uml_dlen > 0) {
+            // add to out of order buffer
+
+            // do not prepare ACK segment here - do it later (end of this scope)
+            // since it might contain SACK fields which require
+            // adsp_hc->adsc_oo_list to be up to date
+
+            HTCP_LOCKED_TEST(!adsp_hc->boc_oo_fin_received ||
+                             m_wle(uml_seq + uml_dlen, adsp_hc->umc_oo_fin_seq),
+                             "received data beyond received FIN");
+
+            // first, find oo segment just before this segment
+            aadsl_hii = &adsp_hc->adsc_oo_list;
+            while (*aadsl_hii != NULL &&
+                   m_wge(uml_seq,
+                         (*aadsl_hii)->umc_seq + (*aadsl_hii)->umc_len)) {
+
+                aadsl_hii = &(*aadsl_hii)->adsc_next;
+            }
+
+            // We are now sure that there is no overlap before iterator.
+            // The above statement will always hold.
+
+            while (uml_dlen > 0 && *aadsl_hii != NULL) {
+                // buffer we are inserting:
+                uml_buf_b = uml_seq;
+                uml_buf_e = uml_buf_b + uml_dlen;
+                // current block in adsc_oo_list:
+                uml_block_b = (*aadsl_hii)->umc_seq;
+                uml_block_e = uml_block_b + (*aadsl_hii)->umc_len;
+
+                // first handle the common cases of no conflict
+
+                // block does not interfere, so skip
+                if (m_wle(uml_block_e, uml_buf_b)) {
+                    aadsl_hii = &(*aadsl_hii)->adsc_next;
+                    continue;
+                }
+
+                // buf is before block, so just insert
+                if (m_wle(uml_buf_e, uml_block_b)) {
+                    adsp_hii->umc_seq = uml_seq;
+                    adsp_hii->umc_len = uml_dlen;
+                    adsp_hii->boc_push = m_get_tcp_flags_psh(utl_flags) == 1;
+
+                    adsp_hii->adsc_next = *aadsl_hii;
+                    *aadsl_hii = adsp_hii;
+
+                    uml_seq += uml_dlen;
+                    uml_dlen = 0;
+                    break;
+                }
+
+                // now the not-so-common cases of conflicts
+
+                // buf is contained in block, so erase buf
+                if (m_wge(uml_buf_b, uml_block_b) &&
+                    m_wle(uml_buf_e, uml_block_e)) {
+                    adsp_hii->adsc_next = *aadsp_to_del;
+                    *aadsp_to_del = adsp_hii;
+                    uml_seq += uml_dlen;
+                    uml_dlen = 0;
+                    break;
+                }
+
+                // block is contained in buf, so erase block
+                if (m_wge(uml_block_b, uml_buf_b) &&
+                    m_wle(uml_block_e, uml_buf_e)) {
+                    (*aadsl_hii)->adsc_next = *aadsp_to_del;
+                    *aadsp_to_del = *aadsl_hii;
+                    // TODO: FIXME: something wrong with (*aadsl_hii)->adsc_next
+                    *aadsl_hii = (*aadsl_hii)->adsc_next;
+                    continue;
+                }
+
+                // crop last part of buf and insert
+                if (m_wlt(uml_buf_b, uml_block_b)) {
+                    HTCP_LOCKED_ASSERT(m_wgt(uml_buf_e, uml_block_b));
+                    HTCP_LOCKED_ASSERT(m_wlt(uml_buf_e, uml_block_e));
+
+                    adsp_hii->umc_seq = uml_seq;
+                    adsp_hii->umc_len = uml_block_b - uml_buf_b;;
+                    adsp_hii->boc_push = m_get_tcp_flags_psh(utl_flags) == 1;
+
+                    adsp_hii->adsc_next = *aadsl_hii;
+                    *aadsl_hii = adsp_hii;
+
+                    uml_seq += uml_dlen;
+                    uml_dlen = 0;
+                    break;
+                }
+
+                // crop first part of buf, update aadsl_hii, loop
+                HTCP_LOCKED_ASSERT(m_wgt(uml_buf_b, uml_block_b));
+                HTCP_LOCKED_ASSERT(m_wlt(uml_buf_b, uml_block_e));
+                HTCP_LOCKED_ASSERT(m_wgt(uml_buf_e, uml_block_e));
+
+                adsp_hii->umc_offset += uml_block_e - uml_buf_b;
+                uml_dlen -= uml_block_e - uml_buf_b;
+                uml_seq = uml_block_e;
+                aadsl_hii = &(*aadsl_hii)->adsc_next;
+            }
+
+            // now append final parts
+            if (uml_dlen > 0) {
+                HTCP_LOCKED_ASSERT(*aadsl_hii == NULL);
+
+                adsp_hii->umc_seq = uml_seq;
+                adsp_hii->umc_len = uml_dlen;
+                adsp_hii->boc_push = m_get_tcp_flags_psh(utl_flags) == 1;
+
+                adsp_hii->adsc_next = NULL;
+                *aadsl_hii = adsp_hii;
+            }
+
+            // now store out-of-order FIN
+            if (bol_fin) {
+                HTCP_LOCKED_TEST(adsp_hii->adsc_next == NULL,
+                                 "received data beyond received FIN");
+
+                adsp_hc->boc_oo_fin_received = true;
+                adsp_hc->umc_oo_fin_seq = uml_seq + uml_dlen;
+                bol_fin = false;
+            }
+
+            // now update adsp_hc->adsc_sack_first
+            if (adsp_hc->boc_use_sack) {
+                adsl_hii = adsp_hc->adsc_oo_list;
+                adsp_hc->adsc_sack_first = adsl_hii;
+                while (!m_within(adsl_hii->umc_seq,
+                                 adsl_hii->umc_seq + adsl_hii->umc_len + 1,
+                                 uml_seq)) {
+
+                    if (adsl_hii->adsc_next == NULL)
+                    HTCP_LOCKED_ASSERT(adsl_hii->adsc_next != NULL);
+
+                    HTCP_LOCKED_ASSERT(m_wge(adsl_hii->adsc_next->umc_seq,
+                                             adsl_hii->umc_seq +
+                                             adsl_hii->umc_len));
+                    if (adsl_hii->adsc_next->umc_seq !=
+                        adsl_hii->umc_seq + adsl_hii->umc_len) {
+
+                        adsp_hc->adsc_sack_first = adsl_hii->adsc_next;
+                    }
+
+                    adsl_hii = adsl_hii->adsc_next;
+                }
+            }
+
+            // ACK out-of-order segment
+            ++adsp_hc->umc_tosend_dack;
+        } else if (bol_fin && uml_seq != adsp_hc->umc_rcv_nxt) {
+            adsp_hc->boc_oo_fin_received = true;
+            adsp_hc->umc_oo_fin_seq = uml_seq;
+            bol_fin = false;
+        }
+        // done processing segment text
+
+        // check the FIN bit
+        if (bol_fin) {
+            if (adsp_hc->utc_packet_flags == 0)
+                adsp_hc->utc_packet_flags = utd_tcp_ack;
+
+            ++adsp_hc->umc_rcv_nxt;
+
+            switch (adsp_hc->iec_state) {
+            case ied_htcp_established:
+                adsp_hc->iec_state = ied_htcp_close_wait;
+                bol_new_data = true;
+                break;
+            case ied_htcp_fin_wait_1:
+                adsp_hc->iec_state = ied_htcp_closing;
+                bol_new_data = true;
+                break;
+            case ied_htcp_fin_wait_2:
+                adsp_hc->iec_state = ied_htcp_time_wait;
+                bol_new_data = true;
+                bol_ret = m_locked_restart_time_wait_timer(adsp_hc,
+                                                           &bol_update_timer,
+                                                           &ill_update_timer,
+                                                           ill_now_ms);
+                if (!bol_ret)
+                    return;
+                break;
+            default:
+                // repeated FIN - send ACK
+                adsp_hc->utc_packet_flags |= utd_tcp_ack;
+            }
+        }
+
+        break;
+
+    default:
+        // should not arrive here
+        HTCP_LOCKED_ERROR("invalid state inside m_htcp_in_packet()");
+    }
+
+    adsp_hc->umc_send_pending -= uml_remove;
+
+    bol_send_notify = false;
+    if (!adsp_hc->boc_out_packet_promised) {
+        bol_ret = m_locked_packets_available(adsp_hc, &bol_send_notify);
+        adsp_hc->boc_out_packet_promised = bol_send_notify;
+    }
+
+    HTCP_UNLOCK;
+
+    if (uml_remove > 0) {
+        bol_ret = adsp_hc->adsc_cb->amc_out_ack(adsp_hc, uml_remove);
+        HTCP_CHECK_CB_RET(amc_out_ack);
+    }
+
+    if (bol_send_notify) {
+        bol_ret = adsp_hc->adsc_cb->amc_out_packets(adsp_hc);
+        HTCP_CHECK_CB_RET(amc_out_packets);
+    }
+
+    while (*aadsp_to_del != NULL) {
+        adsl_hii = *aadsp_to_del;
+        *aadsp_to_del = adsl_hii->adsc_next;
+        bol_ret = adsp_hc->adsc_cb->amc_in_rel(adsp_hc, adsl_hii);
+        HTCP_CHECK_CB_RET(amc_in_rel);
+    }
+
+    if (bol_update_timer) {
+        bol_ret = m_update_timer(adsp_hc, ill_now_ms, ill_update_timer);
+        if (!bol_ret)
+            return;
+    }
+
+    if (bol_reply_reset) {
+        if (m_get_tcp_flags_ack(utl_flags)) {
+            bol_ret = m_send_rst(adsp_hc, uml_ack, false);
+            if (!bol_ret)
+                return;
+        } else {
+            bol_ret = m_send_rst(adsp_hc, uml_seq, true);
+            if (!bol_ret)
+                return;
+        }
+    }
+
+    if (bol_invalid_init) {
+        m_do_abort(adsp_hc, ied_htcpc_conn_error, __LINE__,
+                   "received invalid initial packet");
+    }
+
+    if (bol_conn_established) {
+        bol_ret = adsp_hc->adsc_cb->amc_established(adsp_hc);
+        HTCP_CHECK_CB_RET(amc_established);
+    }
+
+    if (bol_new_data) {
+        bol_ret = adsp_hc->adsc_cb->amc_in_more_data(adsp_hc);
+        HTCP_CHECK_CB_RET(amc_in_more_data);
+    }
+
+    if (bol_reset_by_peer) {
+        m_do_close(adsp_hc, ied_htcpc_remote_reset, __LINE__,
+                   "connection reset by peer");
+        return;
+    }
+
+    if (bol_conn_refused) {
+        m_do_close(adsp_hc, ied_htcpc_conn_refused, __LINE__,
+                   "connection refused");
+        return;
+    }
+
+    if (bol_conn_closed) {
+        m_do_close(adsp_hc, ied_htcpc_normal, __LINE__,
+                   "connection closed normally");
+        return;
+    }
+}
+
+void m_htcp_in_get_data(struct dsd_htcp_conn* adsp_hc,
+                        struct dsd_htcp_in_info** aadsp_hii,
+                        uint32_t* aump_offset, uint32_t* aump_len,
+                        bool* abop_push,
+                        bool* abop_eof, bool* abop_more,
+                        bool bop_throttle)
+{
+    bool bol_win_update = false;
+    bool bol_ret;
+
+    // if throttle, do not reopen receive window for any data retrieved
+
+    HTCP_LOCK;
+    if (aadsp_hii != NULL) {
+        if (adsp_hc->adsc_in_list != NULL) {
+            *aadsp_hii = adsp_hc->adsc_in_list;
+            *aump_offset = adsp_hc->adsc_in_list->umc_offset;
+            *aump_len = adsp_hc->adsc_in_list->umc_len;
+            *abop_push = adsp_hc->adsc_in_list->boc_push;
+
+            adsp_hc->adsc_in_list = adsp_hc->adsc_in_list->adsc_next;
+            adsp_hc->umc_rcv_wnd_throttled += *aump_len;
+        } else {
+            *aadsp_hii = NULL;
+            *aump_offset = 0;
+            *aump_len = 0;
+            *abop_push = false;
+        }
+    }
+
+    if (adsp_hc->adsc_in_list == NULL) {
+        *abop_more = false;
+        switch (adsp_hc->iec_state) {
+        case ied_htcp_close_wait:
+        case ied_htcp_last_ack:
+        case ied_htcp_closing:
+        case ied_htcp_time_wait:
+        case ied_htcp_closed:
+            *abop_eof = true;
+            break;
+
+        default:
+            *abop_eof = false;
+        }
+    } else {
+        *abop_more = true;
+        *abop_eof = false;
+    }
+
+    if (!bop_throttle) {
+        bol_win_update = adsp_hc->umc_rcv_wnd < adsp_hc->umc_rcv_rmss;
+        adsp_hc->umc_rcv_wnd += adsp_hc->umc_rcv_wnd_throttled;
+        adsp_hc->umc_rcv_wnd_throttled = 0;
+        bol_win_update = bol_win_update &&
+            adsp_hc->umc_rcv_wnd >= adsp_hc->umc_rcv_rmss;
+    }
+
+    HTCP_UNLOCK;
+
+    if (bol_win_update) {
+        HTCP_LOCK;
+        adsp_hc->utc_packet_flags |= utd_tcp_ack;
+        HTCP_UNLOCK;
+        bol_ret = adsp_hc->adsc_cb->amc_out_packets(adsp_hc);
+        HTCP_CHECK_CB_RET(amc_out_packets);
+     }
+}
+
+void m_htcp_timeout(struct dsd_htcp_conn* adsp_hc)
+{
+    bool bol_ret;
+    int64_t ill_now_ms;
+
+    bool bol_update_timer = false;
+    int64_t ill_update_timer = 0;
+
+    bool bol_transmitting = false;
+    bool bol_restart_rxt = false;
+
+    bol_ret = adsp_hc->adsc_cb->amc_get_time(adsp_hc, &ill_now_ms);
+    HTCP_CHECK_CB_RET(amc_get_time);
+
+    HTCP_LOCK;
+
+    bol_transmitting = adsp_hc->boc_out_packet_promised;
+
+    if (adsp_hc->ilc_timer != 0 && adsp_hc->ilc_timer <= ill_now_ms) {
+        adsp_hc->ilc_timer = 0;
+
+        // service retransmit/time_wait timer/zero window probe
+
+        if (adsp_hc->umc_exp_backoff == 128) {
+            // give up
+            adsp_hc->iec_state = ied_htcp_closed;
+
+            HTCP_UNLOCK;
+            m_do_close(adsp_hc, ied_htcpc_conn_timeout, __LINE__,
+                       "connection timed out");
+            return;
+        }
+
+        adsp_hc->umc_recover = adsp_hc->umc_snd_nxt;
+
+        switch (adsp_hc->iec_state) {
+        case ied_htcp_closed:
+            break;
+
+        case ied_htcp_syn_sent:
+            HTCP_LOCKED_ASSERT(m_get_tcp_flags_rst(adsp_hc->utc_packet_flags)
+                               == 0);
+            bol_restart_rxt = true;
+            bol_transmitting = true;
+            adsp_hc->umc_exp_backoff *= 2;
+            adsp_hc->utc_packet_flags = utd_tcp_syn;
+            break;
+
+        case ied_htcp_syn_rcvd:
+            HTCP_LOCKED_ASSERT(m_get_tcp_flags_rst(adsp_hc->utc_packet_flags)
+                               == 0);
+            bol_restart_rxt = true;
+            bol_transmitting = true;
+            adsp_hc->umc_exp_backoff *= 2;
+            adsp_hc->utc_packet_flags = utd_tcp_syn_ack;
+            break;
+
+        case ied_htcp_established:
+        case ied_htcp_close_wait:
+        case ied_htcp_last_ack:
+        case ied_htcp_fin_wait_1:
+        case ied_htcp_closing:
+
+            if (adsp_hc->umc_snd_nxt == adsp_hc->umc_snd_una) {
+                // nothing to retransmit
+
+                // check if we need to send zero window probe
+                if (adsp_hc->utc_packet_flags == 0 &&
+                    !adsp_hc->boc_out_packet_promised &&
+                    m_wlt(adsp_hc->umc_snd_nxt_cur,
+                    adsp_hc->umc_snd_una + adsp_hc->umc_send_pending)) {
+
+                    bol_transmitting = true;
+                    bol_restart_rxt = true;
+                    adsp_hc->boc_zwnd_probe = true;
+                    adsp_hc->umc_exp_backoff *= 2;
+                }
+                // TODO: reset round-trip-time estimate?
+                break;
+            }
+
+            adsp_hc->umc_exp_backoff *= 2;
+            adsp_hc->amc_cc_func(ied_htcp_cce_timeout,
+                                 ill_now_ms,
+                                 adsp_hc->umc_srtt_ms,
+                                 adsp_hc->umc_snd_smss,
+                                 adsp_hc->umc_snd_nxt_cur -
+                                 adsp_hc->umc_snd_una,
+                                 &adsp_hc->dsc_cc);
+
+            if (adsp_hc->boc_recovering) {
+                adsp_hc->boc_out_send_recover = false;
+                adsp_hc->boc_recovering = false;
+                adsp_hc->umc_out_sack_count = 0;
+                adsp_hc->umc_sack_data_size = 0;
+            }
+            //adsp_hc->umc_recover = adsp_hc->umc_snd_nxt;
+
+            // start retransmitting from last acked place
+            adsp_hc->umc_snd_nxt_cur = adsp_hc->umc_snd_una;
+
+            bol_transmitting = true;
+            bol_restart_rxt = true;
+
+            break;
+
+        case ied_htcp_fin_wait_2:
+            // should not really arrive here:
+            // nothing to retransmit, timer should have been released
+            break;
+
+        case ied_htcp_time_wait:
+            adsp_hc->iec_state = ied_htcp_closed;
+            HTCP_UNLOCK;
+            m_do_close(adsp_hc, ied_htcpc_normal, __LINE__,
+                       "connection ended normally");
+            return;
+
+        default:
+            // should not arrive here
+            HTCP_LOCKED_ERROR("invalid state inside m_htcp_timeout()");
+        }
+
+        // if too much timeouts, reset rtt estimate (RFC 2988 5)
+        if (adsp_hc->umc_exp_backoff >= 8)
+            adsp_hc->umc_srtt_ms = 0;
+    }
+
+    // if transmitting something, ACK will be sent, so clear delayed ACK timer
+    if (bol_transmitting)
+        adsp_hc->ilc_da_timer = 0;
+
+    if (adsp_hc->ilc_da_timer != 0) {
+        if (adsp_hc->ilc_da_timer <= ill_now_ms) {
+            adsp_hc->ilc_da_timer = 0;
+
+            // service delayed ACK timer
+
+            HTCP_LOCKED_ASSERT(adsp_hc->utc_packet_flags == 0);
+            adsp_hc->utc_packet_flags = utd_tcp_ack;
+        }
+    }
+
+    if (bol_restart_rxt) {
+        bol_ret = m_locked_restart_rexmt_timer(adsp_hc,
+                                               &bol_update_timer,
+                                               &ill_update_timer,
+                                               ill_now_ms);
+        if (!bol_ret)
+            return;
+    }
+
+    if (adsp_hc->ilc_timer != 0) {
+        bol_update_timer = true;
+        if (adsp_hc->ilc_da_timer != 0 &&
+            adsp_hc->ilc_da_timer < adsp_hc->ilc_timer) {
+
+            ill_update_timer = adsp_hc->ilc_da_timer;
+        } else {
+            ill_update_timer = adsp_hc->ilc_timer;
+        }
+    } else if (adsp_hc->ilc_da_timer != 0) {
+        bol_update_timer = true;
+        ill_update_timer = adsp_hc->ilc_da_timer;
+    } else {
+        bol_update_timer = false;
+    }
+
+    bol_transmitting = false;
+    if (!adsp_hc->boc_out_packet_promised) {
+        bol_ret = m_locked_packets_available(adsp_hc, &bol_transmitting);
+        if (!bol_ret)
+            return;
+        adsp_hc->boc_out_packet_promised = bol_transmitting;
+    }
+
+    HTCP_UNLOCK;
+
+    if (bol_transmitting) {
+        bol_ret = adsp_hc->adsc_cb->amc_out_packets(adsp_hc);
+        HTCP_CHECK_CB_RET(amc_out_packets);
+    }
+
+    if (bol_update_timer) {
+        bol_ret = adsp_hc->adsc_cb->amc_set_timer(adsp_hc,
+                                                  ill_update_timer -
+                                                  ill_now_ms);
+        HTCP_CHECK_CB_RET(amc_set_timer);
+    }
+}
+
+void m_htcp_out_get_packet(struct dsd_htcp_conn* adsp_hc,
+                           char* achp_header, uint32_t* aump_hlen,
+                           uint32_t* aump_offset, uint32_t* aump_dlen,
+                           bool* abop_more)
+{
+    int64_t ill_now_ms;
+    int64_t ill_update_timer = 0;
+    bool bol_update_timer = false;
+    uint32_t uml_pending;
+    uint32_t uml_cwnd;
+    uint8_t utl_flags;
+    uint16_t usl_chksum;
+    uint32_t uml_seq;
+    uint32_t uml_offset;
+    uint32_t uml_to_send;
+    uint32_t uml_smss;
+    uint32_t uml_nxt_offset;
+    const char* achl_part_buf;
+    uint32_t uml_part_data_len;
+    uint32_t uml_cur_data_len;
+    bool bol_send_fin;
+    bool bol_have_packet;
+    bool bol_packet;
+    bool bol_ret;
+
+    bol_ret = adsp_hc->adsc_cb->amc_get_time(adsp_hc, &ill_now_ms);
+    HTCP_CHECK_CB_RET(amc_get_time);
+
+    HTCP_LOCK;
+
+    bol_have_packet = adsp_hc->boc_out_packet_promised;
+    adsp_hc->boc_out_packet_promised = false;
+    if (!bol_have_packet) {
+        bol_ret = m_locked_packets_available(adsp_hc, &bol_have_packet);
+        if (!bol_ret) {
+            // TODO: maybe better error reporting
+            *aump_hlen = 0;
+            *aump_offset = 0;
+            *aump_dlen = 0;
+            *abop_more = false;
+            return;
+        }
+    }
+
+    if (!bol_have_packet) {
+        HTCP_UNLOCK;
+        *aump_hlen = 0;
+        *aump_offset = 0;
+        *aump_dlen = 0;
+        *abop_more = false;
+        return;
+    }
+
+    // there is no need to keep delayed ACK timer
+    if (adsp_hc->ilc_da_timer != 0) {
+        bol_ret = m_locked_stop_da_timer(adsp_hc, &bol_update_timer,
+                                         &ill_update_timer);
+        if (!bol_ret) {
+            // TODO: maybe better error reporting
+            *aump_hlen = 0;
+            *aump_offset = 0;
+            *aump_dlen = 0;
+            *abop_more = false;
+            return;
+        }
+    }
+
+    usl_chksum = adsp_hc->usc_pseudo_header_chksum;
+
+    utl_flags = adsp_hc->utc_packet_flags;
+    adsp_hc->utc_packet_flags = 0;
+
+    if (m_get_tcp_flags_rst(utl_flags)) {
+        // RST
+        m_set_tcp_seqn(achp_header, adsp_hc->umc_packet_seq);
+        m_set_tcp_ackn(achp_header, adsp_hc->umc_packet_ack);
+        HTCP_UNLOCK;
+        m_set_tcp_src_port(achp_header, adsp_hc->usc_local_port);
+        m_set_tcp_dst_port(achp_header, adsp_hc->usc_remote_port);
+        m_set_calc_tcp_hlen(achp_header, 20);
+        m_set_tcp_resv(achp_header, 0);
+        m_set_tcp_flags(achp_header, utl_flags);
+        m_set_tcp_window(achp_header, 0);
+        m_set_tcp_urgent(achp_header, 0);
+
+        usl_chksum = m_calc_tcp_chksum(achp_header, 0, usl_chksum);
+        m_set_tcp_chksum(achp_header, usl_chksum);
+
+        *aump_hlen = 20;
+        *aump_offset = 0;
+        *aump_dlen = 0;
+        *abop_more = false;
+        return; // RST
+    }
+
+    if (m_get_tcp_flags_syn(utl_flags)) {
+        // SYN
+        uml_seq = adsp_hc->umc_snd_iss;
+
+        bol_ret = m_locked_prepare_syn(adsp_hc, achp_header, aump_hlen,
+                                       m_get_tcp_flags_ack(utl_flags),
+                                       ill_now_ms);
+
+        if (bol_ret) {
+            bol_ret = m_locked_restart_rexmt_timer(adsp_hc,
+                                                   &bol_update_timer,
+                                                   &ill_update_timer,
+                                                   ill_now_ms);
+        }
+
+        if (bol_ret) {
+            bol_ret = m_locked_rto_sending(adsp_hc, ill_now_ms,
+                                           uml_seq, 1);
+        }
+
+        if (!bol_ret) {
+            // TODO: maybe better error reporting
+            *aump_hlen = 0;
+            *aump_offset = 0;
+            *aump_dlen = 0;
+            *abop_more = false;
+            return;
+        }
+
+        HTCP_UNLOCK;
+
+        usl_chksum = m_calc_tcp_chksum(achp_header, 0, usl_chksum);
+        m_set_tcp_chksum(achp_header, usl_chksum);
+
+        *aump_offset = 0;
+        *aump_dlen = 0;
+        *abop_more = false;
+
+        if (bol_update_timer) {
+            bol_ret = m_update_timer(adsp_hc, ill_now_ms, ill_update_timer);
+            if (!bol_ret)
+                return;
+        }
+
+        return; // SYN
+    }
+
+    // When sending RST or SYN, no more packets would be available. From now
+    // on, we must check if more packets are available before returning.
+
+    utl_flags = utd_tcp_ack;
+    HTCP_LOCKED_ASSERT(m_wge(adsp_hc->umc_snd_nxt_cur, adsp_hc->umc_snd_una));
+    uml_nxt_offset = adsp_hc->umc_snd_nxt_cur - adsp_hc->umc_snd_una;
+    uml_pending = adsp_hc->umc_send_pending;
+    HTCP_LOCKED_ASSERT(uml_pending >= uml_nxt_offset);
+    uml_cwnd = adsp_hc->dsc_cc.umc_cwnd;
+
+    bol_ret = m_locked_start_header(adsp_hc, achp_header, aump_hlen,
+                                    utl_flags, 0, ill_now_ms);
+    if (!bol_ret) {
+        // TODO: maybe better error reporting
+        *aump_hlen = 0;
+        *aump_offset = 0;
+        *aump_dlen = 0;
+        *abop_more = false;
+        return;
+    }
+
+    if (adsp_hc->boc_zwnd_probe) {
+        adsp_hc->boc_zwnd_probe = false;
+
+        if (uml_pending > uml_nxt_offset) { // useless without pending data
+            bol_ret = m_locked_packets_available(adsp_hc, abop_more);
+            if (!bol_ret) {
+                // TODO: maybe better error reporting
+                *aump_hlen = 0;
+                *aump_offset = 0;
+                *aump_dlen = 0;
+                *abop_more = false;
+                return;
+            }
+            adsp_hc->boc_out_packet_promised = *abop_more;
+
+            adsp_hc->umc_last_ack_sent = adsp_hc->umc_rcv_nxt;
+
+            if (m_wle(adsp_hc->umc_snd_nxt, adsp_hc->umc_snd_nxt_cur)) {
+                adsp_hc->umc_snd_nxt = adsp_hc->umc_snd_nxt_cur + 1;
+            }
+
+            HTCP_UNLOCK;
+
+            bol_ret = adsp_hc->adsc_cb->
+                amc_out_get(adsp_hc, uml_nxt_offset,
+                            &achl_part_buf, &uml_part_data_len);
+            HTCP_CHECK_CB_RET(amc_out_get);
+            HTCP_ASSERT(uml_part_data_len > 0);
+            usl_chksum = m_calc_tcp_data_chksum(achl_part_buf, 1, usl_chksum);
+            usl_chksum = m_calc_tcp_chksum(achp_header, 1, usl_chksum);
+            m_set_tcp_chksum(achp_header, usl_chksum);
+
+            *aump_offset = uml_nxt_offset;
+            *aump_dlen = 1;
+
+            return; // zero window probe
+        }
+    }
+
+    // The special cases RST, SYN and zero window probe are handled by now.
+    // From now on, some work is shared at a later stage.
+
+    bol_send_fin = (adsp_hc->iec_state == ied_htcp_syn_rcvd_eof ||
+                    adsp_hc->iec_state == ied_htcp_fin_wait_1 ||
+                    adsp_hc->iec_state == ied_htcp_closing ||
+                    adsp_hc->iec_state == ied_htcp_last_ack);
+
+    if (uml_pending > adsp_hc->umc_snd_wnd) {
+        uml_pending = adsp_hc->umc_snd_wnd;
+        bol_send_fin = false;
+    }
+
+    bol_packet = false;
+
+    if (adsp_hc->boc_recovering) {
+
+        if (adsp_hc->boc_recover_packet) {
+            uml_seq = adsp_hc->umc_packet_seq;
+            HTCP_LOCKED_ASSERT(m_wge(uml_seq, adsp_hc->umc_snd_una));
+            bol_packet = true;
+        } else if (adsp_hc->boc_use_sack) {
+            bol_ret = m_locked_sack_nextseg(adsp_hc, &bol_packet, &uml_seq);
+            if (!bol_ret) {
+                // TODO: maybe better error reporting
+                *aump_hlen = 0;
+                *aump_offset = 0;
+                *aump_dlen = 0;
+                *abop_more = false;
+                return;
+            }
+        }
+    }
+
+    // limited transmit
+    if (!bol_packet && adsp_hc->umc_limited_transmit > 0) {
+        --adsp_hc->umc_limited_transmit;
+        if (uml_pending > uml_nxt_offset &&
+            uml_cwnd + 2 * adsp_hc->umc_snd_smss > uml_nxt_offset) {
+
+            bol_packet = true;
+            uml_seq = adsp_hc->umc_snd_nxt_cur;
+        } else {
+            adsp_hc->umc_limited_transmit = 0;
+        }
+    }
+
+    if (!bol_packet &&
+        adsp_hc->boc_recovering && adsp_hc->umc_pending_dacks > 0) {
+
+        --adsp_hc->umc_pending_dacks;
+        if (uml_pending > uml_nxt_offset &&
+            uml_cwnd > uml_nxt_offset) {
+
+            bol_packet = true;
+            uml_seq = adsp_hc->umc_snd_nxt_cur;
+        } else {
+            adsp_hc->umc_pending_dacks = 0;
+        }
+    }
+
+    if (!bol_packet &&
+        ((uml_pending > uml_nxt_offset && uml_cwnd > uml_nxt_offset) ||
+         (uml_pending == uml_nxt_offset && bol_send_fin))) {
+
+        bol_packet = true;
+        uml_seq = adsp_hc->umc_snd_nxt_cur;
+    }
+
+    // now the work to construct the packet
+
+    if (bol_packet) {
+        HTCP_LOCKED_ASSERT(m_within(adsp_hc->umc_snd_una,
+            adsp_hc->umc_snd_una + adsp_hc->umc_send_pending + 1,
+            uml_seq));
+        uml_offset = uml_seq - adsp_hc->umc_snd_una;
+        if (uml_pending > uml_offset) {
+            uml_to_send = uml_pending - uml_offset;
+        } else {
+            // latest assertion above implies uml_pending == uml_offset
+            uml_to_send = 0;
+        }
+
+        uml_smss = adsp_hc->umc_snd_smss;
+        if (adsp_hc->boc_use_timestamp) {
+            HTCP_LOCKED_ASSERT(*aump_hlen >= 32);
+            HTCP_LOCKED_ASSERT(uml_smss > (*aump_hlen - 32));
+            uml_smss -= (*aump_hlen - 32);
+        } else {
+            HTCP_LOCKED_ASSERT(*aump_hlen >= 20);
+            HTCP_LOCKED_ASSERT(uml_smss > (*aump_hlen - 20));
+            uml_smss -= (*aump_hlen - 20);
+        }
+
+        if (uml_to_send > uml_smss) {
+            uml_to_send = uml_smss;
+            bol_send_fin = false;
+        }
+
+        if (adsp_hc->boc_recovering) {
+            HTCP_LOCKED_ASSERT(adsp_hc->umc_snd_nxt ==
+                               adsp_hc->umc_snd_nxt_cur);
+            if (m_wlt(uml_seq, adsp_hc->umc_snd_nxt)) {
+                adsp_hc->umc_high_rxt = uml_seq + uml_to_send;
+                if (m_wgt(adsp_hc->umc_high_rxt, adsp_hc->umc_snd_nxt))
+                    adsp_hc->umc_high_rxt = adsp_hc->umc_snd_nxt;
+            }
+            if (adsp_hc->boc_use_sack)
+                adsp_hc->umc_sack_pipe += uml_to_send;
+        }
+
+        if (bol_send_fin) {
+            adsp_hc->umc_snd_nxt_cur = uml_seq + uml_to_send + 1;
+            adsp_hc->umc_snd_nxt = adsp_hc->umc_snd_nxt_cur;
+        } else {
+            if (m_wlt(adsp_hc->umc_snd_nxt_cur, uml_seq + uml_to_send)) {
+                adsp_hc->umc_snd_nxt_cur = uml_seq + uml_to_send;
+            }
+            if (m_wlt(adsp_hc->umc_snd_nxt, uml_seq + uml_to_send)) {
+                adsp_hc->umc_snd_nxt = uml_seq + uml_to_send;
+            }
+        }
+    } else {
+        uml_seq = adsp_hc->umc_snd_nxt_cur;
+        bol_send_fin = false;
+        uml_offset = 0;
+        uml_to_send = 0;
+    }
+
+    *aump_offset = uml_offset;
+    *aump_dlen = uml_to_send;
+
+    if (uml_to_send == 0 && adsp_hc->umc_tosend_dack > 0)
+        --adsp_hc->umc_tosend_dack;
+
+    if (!adsp_hc->boc_use_timestamp) {
+        bol_ret = m_locked_rto_sending(adsp_hc, ill_now_ms,
+                                       uml_seq, uml_to_send);
+	    if (!bol_ret) {
+            // TODO: maybe better error reporting
+            *aump_hlen = 0;
+            *aump_offset = 0;
+            *aump_dlen = 0;
+            *abop_more = false;
+            return;
+	    }
+    }
+
+    if ((uml_to_send > 0 || bol_send_fin) && adsp_hc->ilc_timer == 0) {
+        bol_ret = m_locked_restart_rexmt_timer(adsp_hc, &bol_update_timer,
+                                               &ill_update_timer, ill_now_ms);
+        if (!bol_ret) {
+            // TODO: maybe better error reporting
+            *aump_hlen = 0;
+            *aump_offset = 0;
+            *aump_dlen = 0;
+            *abop_more = false;
+            return;
+        }
+    }
+
+    bol_ret = m_locked_packets_available(adsp_hc, abop_more);
+    if (!bol_ret) {
+        // TODO: maybe better error reporting
+        *aump_hlen = 0;
+        *aump_offset = 0;
+        *aump_dlen = 0;
+        *abop_more = false;
+        return;
+    }
+    adsp_hc->boc_out_packet_promised = *abop_more;
+
+    adsp_hc->umc_last_ack_sent = adsp_hc->umc_rcv_nxt;
+
+    HTCP_UNLOCK;
+
+    // complete header
+
+    m_set_tcp_seqn(achp_header, uml_seq);
+    if (bol_send_fin)
+        m_set_tcp_fin(achp_header, 1);
+    else if (bol_packet && !*abop_more)
+        m_set_tcp_psh(achp_header, 1);
+
+    // calculate checksum
+
+    uml_cur_data_len = 0;
+    while (uml_cur_data_len < uml_to_send) {
+        bol_ret = adsp_hc->adsc_cb->
+            amc_out_get(adsp_hc, uml_offset + uml_cur_data_len,
+                        &achl_part_buf, &uml_part_data_len);
+        HTCP_CHECK_CB_RET(amc_out_get);
+
+        HTCP_ASSERT(uml_part_data_len > 0);
+
+        if (uml_cur_data_len + uml_part_data_len > uml_to_send) {
+            HTCP_ASSERT(uml_to_send > uml_cur_data_len);
+            uml_part_data_len = uml_to_send - uml_cur_data_len;
+        }
+
+        if (uml_cur_data_len % 2 == 0) {
+            usl_chksum = m_calc_tcp_data_chksum(achl_part_buf,
+                                                uml_part_data_len,
+                                                usl_chksum);
+        } else {
+            usl_chksum = m_calc_tcp_odd_data_chksum(achl_part_buf,
+                                                    uml_part_data_len,
+                                                    usl_chksum);
+        }
+
+        uml_cur_data_len += uml_part_data_len;
+    }
+
+    HTCP_ASSERT(m_get_calc_tcp_hlen(achp_header) == *aump_hlen);
+    usl_chksum = m_calc_tcp_chksum(achp_header, uml_to_send, usl_chksum);
+    m_set_tcp_chksum(achp_header, usl_chksum);
+
+    // checksum calculation done
+
+    if (bol_update_timer) {
+        bol_ret = m_update_timer(adsp_hc, ill_now_ms, ill_update_timer);
+        if (!bol_ret)
+            return;
+    }
+}
+
+void m_htcp_abort(struct dsd_htcp_conn* adsp_hc, bool bop_reset)
+{
+    bool bol_close;
+    uint32_t uml_seq;
+
+    HTCP_LOCK;
+    bol_close = adsp_hc->iec_state != ied_htcp_closed;
+    adsp_hc->iec_state = ied_htcp_closed;
+    uml_seq = adsp_hc->umc_snd_nxt;
+    HTCP_UNLOCK;
+
+    if (bol_close) {
+        if (bop_reset)
+            m_send_rst(adsp_hc, uml_seq, false);
+
+        m_do_close(adsp_hc, ied_htcpc_local_reset, __LINE__,
+                   "connection reset by application");
+    }
+}
+
+void m_htcp_status(struct dsd_htcp_conn* adsp_hc,
+                   struct dsd_htcp_status* adsp_hs)
+{
+    HTCP_LOCK;
+    adsp_hs->umc_out_queue_len = adsp_hc->umc_send_pending;
+    adsp_hs->umc_out_in_flight = adsp_hc->umc_snd_nxt - adsp_hc->umc_snd_una;
+
+    if (adsp_hc->iec_state == ied_htcp_syn_sent ||
+        adsp_hc->iec_state == ied_htcp_syn_rcvd ||
+        adsp_hc->iec_state == ied_htcp_syn_sent_eof ||
+        adsp_hc->iec_state == ied_htcp_syn_rcvd_eof) {
+
+        --adsp_hs->umc_out_in_flight;
+    }
+
+    if (adsp_hc->iec_state == ied_htcp_syn_rcvd_eof ||
+        adsp_hc->iec_state == ied_htcp_fin_wait_1 ||
+        adsp_hc->iec_state == ied_htcp_closing ||
+        adsp_hc->iec_state == ied_htcp_last_ack) {
+
+        --adsp_hs->umc_out_in_flight;
+    }
+
+    HTCP_UNLOCK;
+}
+
+void m_htcp_describe_close(struct dsd_htcp_conn* adsp_hc,
+                           char* achp_description, uint32_t* aump_dlen,
+                           char* achp_debug_info, uint32_t* aump_dilen)
+{
+    int inl_ret;
+
+    if (adsp_hc->iec_htcpc == ied_htcpc_open) {
+        *aump_dlen = 0;
+        *aump_dilen = 0;
+        return;
+    }
+
+    if (achp_description != NULL && aump_dlen != NULL && *aump_dlen > 0) {
+        switch (adsp_hc->iec_htcpc) {
+        case ied_htcpc_normal:
+            inl_ret = snprintf(achp_description, *aump_dlen, "%s",
+                               "connection closed normally");
+            break;
+
+        case ied_htcpc_conn_refused:
+            inl_ret = snprintf(achp_description, *aump_dlen, "%s",
+                               "connection refused");
+            break;
+
+        case ied_htcpc_conn_timeout:
+            inl_ret = snprintf(achp_description, *aump_dlen, "%s",
+                               "connection timed out");
+            break;
+
+        case ied_htcpc_conn_error:
+            inl_ret = snprintf(achp_description, *aump_dlen, "%s",
+                               "connection error");
+            break;
+
+        case ied_htcpc_remote_reset:
+            inl_ret = snprintf(achp_description, *aump_dlen, "%s",
+                               "connection reset by peer");
+            break;
+
+        case ied_htcpc_local_reset:
+            inl_ret = snprintf(achp_description, *aump_dlen, "%s",
+                               "connection reset by application");
+            break;
+
+        case ied_htcpc_error:
+            inl_ret = snprintf(achp_description, *aump_dlen, "%s",
+                               "connection internal error");
+            break;
+
+        case ied_htcpc_interface_error:
+            inl_ret = snprintf(achp_description, *aump_dlen, "%s",
+                               "connection interface error");
+            break;
+
+        case ied_htcpc_application_error:
+            inl_ret = snprintf(achp_description, *aump_dlen, "%s",
+                               "connection application error");
+            break;
+
+        default:
+            inl_ret = snprintf(achp_description, *aump_dlen, "%s",
+                               "connection closed");
+        }
+        if (inl_ret < 0)
+            *aump_dlen = 0;
+        else
+            *aump_dlen = inl_ret;
+    }
+
+    if (achp_debug_info != NULL && aump_dilen != NULL && *aump_dilen > 0) {
+        inl_ret = snprintf(achp_debug_info, *aump_dilen, "%s%04d%s%s",
+                           "xs-htcp-01.cpp:", adsp_hc->inc_close_line,
+                           " - ", adsp_hc->achc_close_reason);
+        if (inl_ret < 0)
+            *aump_dilen = 0;
+        else
+            *aump_dilen = inl_ret;
+    }
+}
+
+
+static void m_do_close(struct dsd_htcp_conn* adsp_hc,
+                       enum ied_htcp_close iep_htcpc,
+                       int inp_line, const char* achp_why)
+{
+    struct dsd_htcp_in_info* adsl_hii;
+
+    while (adsp_hc->adsc_in_list != NULL) {
+        adsl_hii = adsp_hc->adsc_in_list;
+        adsp_hc->adsc_in_list = adsl_hii->adsc_next;
+        adsp_hc->adsc_cb->amc_in_rel(adsp_hc, adsl_hii);
+    }
+
+    while (adsp_hc->adsc_oo_list != NULL) {
+        adsl_hii = adsp_hc->adsc_oo_list;
+        adsp_hc->adsc_oo_list = adsl_hii->adsc_next;
+        adsp_hc->adsc_cb->amc_in_rel(adsp_hc, adsl_hii);
+    }
+
+    adsp_hc->adsc_cb->amc_rel_timer(adsp_hc);
+
+    //adsp_hc->iec_state = ied_htcp_closed;
+    adsp_hc->iec_htcpc = iep_htcpc;
+    adsp_hc->achc_close_reason = achp_why;
+    adsp_hc->inc_close_line = inp_line;
+    adsp_hc->adsc_cb->amc_closed(adsp_hc, iep_htcpc);
+}
+
+static void m_do_abort(struct dsd_htcp_conn* adsp_hc,
+                       enum ied_htcp_close iep_htcpc,
+                       int inp_line, const char* achp_why)
+{
+    bool bol_close;
+
+    adsp_hc->adsc_cb->amc_lock(adsp_hc);
+    bol_close = adsp_hc->iec_state != ied_htcp_closed;
+    adsp_hc->iec_state = ied_htcp_closed;
+    adsp_hc->adsc_cb->amc_unlock(adsp_hc);
+
+    if (bol_close) {
+        m_do_close(adsp_hc, iep_htcpc, inp_line, achp_why);
+    }
+}
+
+static bool m_locked_process_syn_options(struct dsd_htcp_conn* adsp_hc,
+                                         const char* achp_tcp_header,
+                                         uint32_t ump_hlen)
+{
+    const char* achl_option;
+    bool bol_search_mss = true;
+    bool bol_search_winscale = adsp_hc->boc_use_winscale;
+    bool bol_search_sack = adsp_hc->boc_use_sack;
+    bool bol_search_timestamp = adsp_hc->boc_use_timestamp;
+    uint16_t usl_mss;
+
+    // adsp_hc->umc_snd_smss is already set to default
+
+    achl_option = m_first_tcp_option(achp_tcp_header,
+                                     achp_tcp_header + ump_hlen);
+    while (achl_option < achp_tcp_header + ump_hlen) {
+        switch (achl_option[0]) {
+        case 2: // mss
+            if (!bol_search_mss || achl_option[1] != 4)
+                break;
+            usl_mss = m_get_16_bit(achl_option + 2);
+            if (usl_mss < adsp_hc->umc_snd_smss) {
+                if (usl_mss < 536)
+                    adsp_hc->umc_snd_smss = 536;
+                else
+                    adsp_hc->umc_snd_smss = usl_mss;
+            }
+            bol_search_mss = false;
+            break;
+
+        case 3: // window scaling
+            if (!bol_search_winscale || achl_option[1] != 3)
+                break;
+            adsp_hc->umc_snd_winscale = *(const uint8_t*)(achl_option + 2);
+            if (adsp_hc->umc_snd_winscale > 14)
+                adsp_hc->umc_snd_winscale = 14;
+            bol_search_winscale = false;
+            break;
+
+        case 4: // allow SACK
+            if (!bol_search_sack || achl_option[1] != 2)
+                break;
+            bol_search_sack = false;
+            break;
+
+        case 8: // timestamps
+            if (!bol_search_timestamp || achl_option[1] != 10)
+                break;
+            adsp_hc->umc_ts_recent = m_get_32_bit(achl_option + 2);
+            bol_search_timestamp = false;
+            break;
+        }
+
+        achl_option = m_next_tcp_option(achl_option,
+                                        achp_tcp_header + ump_hlen);
+    }
+
+    if (bol_search_mss) {
+        adsp_hc->umc_snd_smss = 536;
+    }
+
+    if (bol_search_winscale) {
+        adsp_hc->boc_use_winscale = false;
+        adsp_hc->umc_rcv_winscale = 0;
+    }
+
+    if (bol_search_sack) {
+        adsp_hc->boc_use_sack = false;
+    }
+
+    if (bol_search_timestamp) {
+        adsp_hc->boc_use_timestamp = false;
+    } else if (adsp_hc->boc_use_timestamp) {
+        adsp_hc->umc_snd_smss -= 12;
+    }
+
+    // TODO: if this is SYNACK with timestamp, update rtt estimate
+
+    return true;
+}
+
+// um_flight = um_snd_nxt - um_snd_una
+static void m_cc_newreno(enum ied_htcp_cc_event iep_cce_e,
+                         int64_t ilp_time, uint32_t ump_rtt_ms,
+                         uint32_t ump_snd_smss, uint32_t ump_flight,
+                         struct dsd_htcp_cc* adsp_cc)
+{
+    struct dsd_htcp_cc_newreno* adsl_newreno = &adsp_cc->dsc_ucc.dsc_cc_newreno;
+
+    switch (iep_cce_e) {
+    case ied_htcp_cce_init:
+        // adsp_cc->umc_cwnd = ump_snd_smss; // may be up to 2 * ump_snd_smss
+        /*
+        adsp_cc->umc_cwnd = 4380;
+        if (adsp_cc->umc_cwnd < 2 * ump_snd_smss)
+            adsp_cc->umc_cwnd = 2 * ump_snd_smss;
+        if (adsp_cc->umc_cwnd > 4 * ump_snd_smss)
+            adsp_cc->umc_cwnd = 4 * ump_snd_smss;
+        */
+        // draft-ietf-tcpm-initcwnd-03
+        adsp_cc->umc_cwnd = 14600;
+        if (adsp_cc->umc_cwnd < 2 * ump_snd_smss)
+            adsp_cc->umc_cwnd = 2 * ump_snd_smss;
+        if (adsp_cc->umc_cwnd > 10 * ump_snd_smss)
+            adsp_cc->umc_cwnd = 10 * ump_snd_smss;
+        // draft-ietf-tcpm-initcwnd-03
+        adsl_newreno->umc_ssthresh = 65535; // arbitrary
+        adsp_cc->umc_bytes_acked = 0;
+        break;
+
+    case ied_htcp_cce_newack:
+        if (adsp_cc->umc_cwnd <= adsl_newreno->umc_ssthresh) {
+            // slow start
+            //adsp_cc->umc_cwnd += ump_snd_smss;
+            // appropriate byte counting
+            if (adsp_cc->umc_bytes_acked >= ump_snd_smss) {
+                adsp_cc->umc_bytes_acked -= ump_snd_smss;
+                adsp_cc->umc_cwnd += ump_snd_smss;
+                if (adsp_cc->umc_bytes_acked > ump_snd_smss)
+                    adsp_cc->umc_bytes_acked = ump_snd_smss;
+            }
+        } else {
+            // congestion avoidance
+            // adsp_cc->umc_cwnd += (std::max)(uint32(1),
+            //               ump_snd_smss * ump_snd_smss / adsp_cc->umc_cwnd);
+            // appropriate byte counting
+            if (adsp_cc->umc_bytes_acked >= adsp_cc->umc_cwnd) {
+                adsp_cc->umc_bytes_acked -= adsp_cc->umc_cwnd;
+                adsp_cc->umc_cwnd += ump_snd_smss;
+            }
+        }
+        break;
+
+    case ied_htcp_cce_timeout:
+        if (true || adsl_newreno->umc_ssthresh > ump_flight / 2)
+            adsl_newreno->umc_ssthresh = ump_flight / 2;
+        if (adsl_newreno->umc_ssthresh < 2 * ump_snd_smss)
+            adsl_newreno->umc_ssthresh = 2 * ump_snd_smss;
+        adsp_cc->umc_cwnd = ump_snd_smss;
+        adsp_cc->umc_bytes_acked = 0;
+        break;
+
+    case ied_htcp_cce_three_dup:
+        if (true || adsl_newreno->umc_ssthresh > ump_flight / 2)
+            adsl_newreno->umc_ssthresh = ump_flight / 2;
+        if (adsl_newreno->umc_ssthresh < 2 + ump_snd_smss)
+            adsl_newreno->umc_ssthresh = 2 + ump_snd_smss;
+        adsp_cc->umc_cwnd = adsl_newreno->umc_ssthresh + 3 * ump_snd_smss;
+        break;
+
+    case ied_htcp_cce_three_dup_sack:
+        if (true || adsl_newreno->umc_ssthresh > ump_flight / 2)
+            adsl_newreno->umc_ssthresh = ump_flight / 2;
+        if (adsl_newreno->umc_ssthresh < 2 + ump_snd_smss)
+            adsl_newreno->umc_ssthresh = 2 + ump_snd_smss;
+        adsp_cc->umc_cwnd = adsl_newreno->umc_ssthresh;
+        break;
+
+    case ied_htcp_cce_more_dup:
+        adsp_cc->umc_cwnd += ump_snd_smss;
+        break;
+
+    case ied_htcp_cce_recover_ack:
+        adsp_cc->umc_cwnd = adsl_newreno->umc_ssthresh;
+        // New Reno improvement:
+        if (adsp_cc->umc_cwnd > ump_flight + ump_snd_smss)
+            adsp_cc->umc_cwnd = ump_flight + ump_snd_smss;
+        break;
+    }
+}
+
+static uint32_t m_cbrt(uint32_t ump_x)
+{
+    int inl_i;
+    uint32_t uml_y, uml_b, uml_y2;
+
+    uml_y2 = 0;
+    uml_y = 0;
+    for (inl_i = 30; inl_i >= 0; inl_i -= 3) {
+        uml_y2 <<= 2;
+        uml_y <<= 1;
+        uml_b = (3 * (uml_y2 + uml_y) + 1) << inl_i;
+        if (ump_x >= uml_b) {
+            ump_x -= uml_b;
+            uml_y2 += uml_y + uml_y + 1;
+            ++uml_y;
+        }
+    }
+    return uml_y;
+}
+
+// um_flight = um_snd_nxt - um_snd_una
+static void m_cc_cubic(enum ied_htcp_cc_event iep_cce_e,
+                       int64_t ilp_time, uint32_t ump_rtt_ms,
+                       uint32_t ump_snd_smss, uint32_t ump_flight,
+                       struct dsd_htcp_cc* adsp_cc)
+{
+    int64_t ill_t;
+    uint32_t uml_target;
+
+    if (ilp_time == 0)
+        ilp_time = 1;
+
+    struct dsd_htcp_cc_cubic* adsl_cubic = &adsp_cc->dsc_ucc.dsc_cc_cubic;
+
+    switch (iep_cce_e) {
+    case ied_htcp_cce_init:
+        adsp_cc->umc_cwnd = 14600;
+        if (adsp_cc->umc_cwnd < 2 * ump_snd_smss)
+            adsp_cc->umc_cwnd = 2 * ump_snd_smss;
+        if (adsp_cc->umc_cwnd > 10 * ump_snd_smss)
+            adsp_cc->umc_cwnd = 10 * ump_snd_smss;
+        adsl_cubic->umc_ssthresh = 65535; // arbitrary
+        adsp_cc->umc_bytes_acked = 0;
+
+        adsl_cubic->umc_w_lastmax = 0;
+        adsl_cubic->ilc_epoch_start = 0;
+        adsl_cubic->umc_origin_point = 0;
+        adsl_cubic->umc_dmin = 0;
+        adsl_cubic->umc_wtcp = 0;
+        adsl_cubic->umc_k = 0;
+        adsl_cubic->umc_ack_cnt = 0;
+        break;
+
+    case ied_htcp_cce_newack:
+    case ied_htcp_cce_recover_ack:
+        if (adsl_cubic->umc_dmin == 0 || adsl_cubic->umc_dmin > ump_rtt_ms)
+            adsl_cubic->umc_dmin = ump_rtt_ms;
+        if (adsp_cc->umc_cwnd <= adsl_cubic->umc_ssthresh) {
+            // slow start
+            if (adsp_cc->umc_bytes_acked >= ump_snd_smss) {
+                adsp_cc->umc_bytes_acked -= ump_snd_smss;
+                adsp_cc->umc_cwnd += ump_snd_smss;
+                if (adsp_cc->umc_bytes_acked > ump_snd_smss)
+                    adsp_cc->umc_bytes_acked = ump_snd_smss;
+            }
+        } else {
+            // congestion avoidance
+
+            if (adsl_cubic->ilc_epoch_start == 0) {
+                adsl_cubic->ilc_epoch_start = ilp_time;
+                if (adsp_cc->umc_cwnd < adsl_cubic->umc_w_lastmax) {
+                    adsl_cubic->umc_k =
+                        m_cbrt((adsl_cubic->umc_w_lastmax - adsp_cc->umc_cwnd)
+                               * 5 / 2);
+                    adsl_cubic->umc_origin_point = adsl_cubic->umc_w_lastmax;
+                } else {
+                    adsl_cubic->umc_k = 0;
+                    adsl_cubic->umc_origin_point = adsp_cc->umc_cwnd;
+                }
+                adsl_cubic->umc_wtcp = adsp_cc->umc_cwnd;
+            }
+
+            ill_t =
+                ilp_time + adsl_cubic->umc_dmin - adsl_cubic->ilc_epoch_start;
+            uml_target = ill_t - adsl_cubic->umc_k;
+            uml_target *= uml_target * uml_target;
+            uml_target = uml_target * 2 / 5 + adsl_cubic->umc_origin_point;
+
+            if (adsl_cubic->umc_ack_cnt < adsp_cc->umc_bytes_acked) {
+                adsl_cubic->umc_wtcp +=
+                    (adsp_cc->umc_bytes_acked - adsl_cubic->umc_ack_cnt) *
+                    ump_snd_smss / (adsp_cc->umc_cwnd * 3);
+                adsl_cubic->umc_ack_cnt = adsp_cc->umc_bytes_acked;
+            }
+
+            if (uml_target < adsl_cubic->umc_wtcp)
+                uml_target = adsl_cubic->umc_wtcp;
+            if (uml_target > adsp_cc->umc_cwnd) {
+                if (adsp_cc->umc_bytes_acked >
+                    adsp_cc->umc_cwnd * ump_snd_smss /
+                    (uml_target - adsp_cc->umc_cwnd)) {
+
+                    adsp_cc->umc_bytes_acked = 0;
+                    adsl_cubic->umc_ack_cnt = 0;
+                    adsp_cc->umc_cwnd += ump_snd_smss;
+                }
+            }
+        }
+        break;
+
+    case ied_htcp_cce_timeout:
+        adsl_cubic->umc_ssthresh = ump_flight / 2;
+        if (adsl_cubic->umc_ssthresh < 2 * ump_snd_smss)
+            adsl_cubic->umc_ssthresh = 2 * ump_snd_smss;
+        adsp_cc->umc_cwnd = ump_snd_smss;
+
+        adsp_cc->umc_bytes_acked = 0;
+
+        adsl_cubic->umc_w_lastmax = 0;
+        adsl_cubic->ilc_epoch_start = 0;
+        adsl_cubic->umc_origin_point = 0;
+        adsl_cubic->umc_dmin = 0;
+        adsl_cubic->umc_wtcp = 0;
+        adsl_cubic->umc_k = 0;
+        adsl_cubic->umc_ack_cnt = 0;
+        break;
+
+    case ied_htcp_cce_three_dup:
+    case ied_htcp_cce_three_dup_sack:
+        adsl_cubic->ilc_epoch_start = 0;
+        adsl_cubic->umc_w_lastmax = adsp_cc->umc_cwnd;
+        if (adsp_cc->umc_cwnd < adsl_cubic->umc_w_lastmax) {
+            adsl_cubic->umc_w_lastmax -= adsp_cc->umc_cwnd / 10;
+        }
+        adsp_cc->umc_cwnd -= adsp_cc->umc_cwnd / 5;
+        adsl_cubic->umc_ssthresh = adsp_cc->umc_cwnd;
+        break;
+
+    case ied_htcp_cce_more_dup:
+        adsp_cc->umc_cwnd += ump_snd_smss;
+        break;
+    }
+}
+
+static void m_rto_init(struct dsd_htcp_conn* adsp_hc)
+{
+    adsp_hc->umc_srtt_ms = 0;
+    adsp_hc->umc_rttvar_ms = 0;
+    adsp_hc->umc_rto_ms = 1000; // as in RFC 6298, not 3000 as in RFC 793
+
+    adsp_hc->boc_rtt_calc_valid = false;
+}
+
+static bool m_locked_rto_sending(struct dsd_htcp_conn* adsp_hc,
+                                 int64_t ilp_now_ms,
+                                 uint32_t ump_seq, uint32_t ump_len)
+{
+    // if already timing and this send is no duplicate (Karn), return
+    if (adsp_hc->boc_rtt_calc_valid &&
+        !m_within(ump_seq, ump_seq + ump_len, adsp_hc->umc_rtt_calc_seq_sent)) {
+
+        return true;
+    }
+
+    adsp_hc->boc_rtt_calc_valid = false;
+
+    if (adsp_hc->umc_snd_nxt == adsp_hc->umc_snd_una &&
+        m_within(ump_seq, ump_seq + ump_len, adsp_hc->umc_snd_nxt)) {
+        // a usable unsent byte exists
+        adsp_hc->ilc_rtt_calc_time_sent_ms = ilp_now_ms;
+        adsp_hc->umc_rtt_calc_seq_sent = adsp_hc->umc_snd_nxt;
+        adsp_hc->boc_rtt_calc_valid = true;
+    }
+
+    return true;
+}
+
+static bool m_locked_rto_received(struct dsd_htcp_conn* adsp_hc,
+                                  int64_t ilp_now_ms)
+{
+    int64_t ill_this_rtt;
+    int64_t ill_diff;
+
+    if (adsp_hc->boc_use_timestamp)
+        return true;
+
+    if (!adsp_hc->boc_rtt_calc_valid) {
+        return true;
+    }
+
+    if (!m_within(adsp_hc->umc_rtt_calc_seq_sent + 1, adsp_hc->umc_snd_nxt + 1,
+                  adsp_hc->umc_snd_una)) {
+
+        return true;
+    }
+
+    // relevant byte acknowledged - do update
+
+    ill_this_rtt = ilp_now_ms - adsp_hc->ilc_rtt_calc_time_sent_ms;
+
+    if (adsp_hc->umc_srtt_ms == 0) {
+        // first measurement
+        adsp_hc->umc_srtt_ms = ill_this_rtt;
+        adsp_hc->umc_rttvar_ms = ill_this_rtt / 2;
+    } else {
+        ill_diff = ill_this_rtt;
+        ill_diff -= adsp_hc->umc_srtt_ms;
+        adsp_hc->umc_srtt_ms += ill_diff / 8;
+        if (ill_diff < 0)
+            ill_diff = -ill_diff;
+        adsp_hc->umc_rttvar_ms += (ill_diff - adsp_hc->umc_rttvar_ms) / 4;
+    }
+
+    adsp_hc->umc_rto_ms = adsp_hc->umc_srtt_ms + 4 * adsp_hc->umc_rttvar_ms;
+    if (adsp_hc->umc_rto_ms < 500) // SHOULD hava a minimum of 1s (using 0.5s)
+        adsp_hc->umc_rto_ms = 500;
+    else if (adsp_hc->umc_rto_ms > 60000) // MAY have a maximum of at least 60s
+        adsp_hc->umc_rto_ms = 60000;
+
+    adsp_hc->boc_rtt_calc_valid = false;
+
+    return true;
+}
+
+static bool m_locked_rto_timestamp_update(struct dsd_htcp_conn* adsp_hc,
+                                          int64_t ilp_now_ms,
+                                          uint32_t ump_seg_tsecr)
+{
+    uint32_t uml_this_rtt = ilp_now_ms - ump_seg_tsecr;
+    int64_t ill_diff;
+    int32_t iml_w_num;
+    int32_t iml_w_den;
+
+    if (adsp_hc->umc_srtt_ms == 0) {
+        // first measurement
+        adsp_hc->umc_srtt_ms = uml_this_rtt;
+        adsp_hc->umc_rttvar_ms = uml_this_rtt / 2;
+        adsp_hc->umc_last_tsecr = ump_seg_tsecr;
+    } else if (ump_seg_tsecr != adsp_hc->umc_last_tsecr) {
+        ill_diff = uml_this_rtt;
+        ill_diff -= adsp_hc->umc_srtt_ms;
+        // TODO: check overflow when multiplying?
+        iml_w_num = ilp_now_ms - adsp_hc->umc_last_update_ts;
+        iml_w_den = adsp_hc->umc_srtt_ms;
+        if (iml_w_num >= iml_w_den || true) { // TODO: clean
+            adsp_hc->umc_srtt_ms += ill_diff / 8;
+            if (ill_diff < 0)
+                ill_diff = -ill_diff;
+            adsp_hc->umc_rttvar_ms += (ill_diff - adsp_hc->umc_rttvar_ms) / 4;
+        } else {
+            adsp_hc->umc_srtt_ms +=
+                (ill_diff / 8 * iml_w_num + iml_w_den - 1) / iml_w_den;
+            if (ill_diff < 0)
+                ill_diff = -ill_diff;
+            adsp_hc->umc_rttvar_ms += ((ill_diff - adsp_hc->umc_rttvar_ms) / 4
+                                       * iml_w_num + iml_w_den - 1) / iml_w_den;
+        }
+    }
+    adsp_hc->umc_last_update_ts = ilp_now_ms;
+    adsp_hc->umc_last_tsecr = ump_seg_tsecr;
+
+    adsp_hc->umc_rto_ms = adsp_hc->umc_srtt_ms + 4 * adsp_hc->umc_rttvar_ms;
+    // SHOULD hava a minimum of 1s (using 0.5s)
+    // MAY have a maximum of at least 60s
+    if (adsp_hc->umc_rto_ms < 500) {
+        adsp_hc->umc_rto_ms = 500;
+    } else if (adsp_hc->umc_rto_ms > 60000) {
+        adsp_hc->umc_rto_ms = 60000;
+    }
+
+    return true;
+}
+
+static bool m_locked_create_timestamp_option(struct dsd_htcp_conn* adsp_hc,
+                                             char* achp_o,
+                                             int64_t ilp_now_ms)
+{
+    achp_o[0] = 8;
+    achp_o[1] = 10;
+    m_put_32_bit(achp_o + 2, ilp_now_ms);
+    m_put_32_bit(achp_o + 6, adsp_hc->umc_ts_recent);
+
+    return true;
+}
+
+static bool m_update_timer(struct dsd_htcp_conn* adsp_hc,
+                           int64_t ilp_now_ms, int64_t ilp_timer)
+{
+    bool bol_ret;
+    int inl_delay;
+    int64_t ill_first;
+    bool bol_repeat;
+
+    do {
+        bol_repeat = false;
+
+        if (ilp_timer == 0) {
+            bol_ret = adsp_hc->adsc_cb->amc_rel_timer(adsp_hc);
+            HTCP_CHECK_CB_RET_F(amc_rel_timer);
+        } else {
+            inl_delay = ilp_timer - ilp_now_ms;
+            if (inl_delay <= 0)
+                inl_delay = 1;
+            bol_ret = adsp_hc->adsc_cb->amc_set_timer(adsp_hc, inl_delay);
+            HTCP_CHECK_CB_RET_F(amc_set_timer);
+        }
+
+        ill_first = 0;
+        HTCP_LOCK_F;
+        if (ill_first == 0 ||
+            (adsp_hc->ilc_timer != 0 && adsp_hc->ilc_timer < ill_first)) {
+
+            ill_first = adsp_hc->ilc_timer;
+        }
+        if (ill_first == 0 ||
+            (adsp_hc->ilc_da_timer != 0 && adsp_hc->ilc_da_timer < ill_first)) {
+
+            ill_first = adsp_hc->ilc_da_timer;
+        }
+        if (ilp_timer != ill_first) {
+            ilp_timer = ill_first;
+            bol_repeat = true;
+        }
+        HTCP_UNLOCK_F;
+
+    } while (bol_repeat);
+
+    return true;
+}
+
+static bool m_locked_stop_timer(struct dsd_htcp_conn* adsp_hc,
+                                bool* abop_update, int64_t* ailp_update_timer,
+                                int64_t* ailp_timer, int64_t ilp_other)
+{
+    if (*ailp_timer == 0) {
+        return true;
+    }
+
+    if (ilp_other != 0) {
+        if (ilp_other >= *ailp_timer) {
+            *abop_update = true;
+            *ailp_update_timer = ilp_other;
+        }
+    } else {
+        *abop_update = true;
+        *ailp_update_timer = 0;
+    }
+
+    *ailp_timer = 0;
+
+    return true;
+}
+
+static bool m_locked_start_timer(struct dsd_htcp_conn* adsp_hc,
+                                 bool* abop_update, int64_t* ailp_update_timer,
+                                 int64_t* ailp_timer, int64_t ilp_new_time,
+                                 int64_t ilp_other)
+{
+    if (ilp_new_time == 0)
+        ilp_new_time = 1;
+
+    if (*ailp_timer == ilp_new_time) {
+        return true;
+    }
+
+    if (ilp_other == 0 || ilp_other >= ilp_new_time) {
+        *abop_update = true;
+        *ailp_update_timer = ilp_new_time;
+    } else if (ilp_other > *ailp_timer) {
+        *abop_update = true;
+        *ailp_update_timer = ilp_other;
+    }
+
+    *ailp_timer = ilp_new_time;
+
+    return true;
+}
+
+static bool m_locked_restart_rexmt_timer(struct dsd_htcp_conn* adsp_hc,
+                                         bool* abop_update,
+                                         int64_t* ailp_update_timer,
+                                         int64_t ilp_now_ms)
+{
+    uint32_t uml_delay_ms;
+
+    if (adsp_hc->umc_exp_backoff > 64)
+        uml_delay_ms = 2 * adsp_hc->umc_msl_s * 1000; // one last time with 2MSL
+    else
+        uml_delay_ms = adsp_hc->umc_rto_ms * adsp_hc->umc_exp_backoff;
+
+    return m_locked_start_timer(adsp_hc, abop_update, ailp_update_timer,
+                                &adsp_hc->ilc_timer,
+                                ilp_now_ms + uml_delay_ms,
+                                adsp_hc->ilc_da_timer);
+}
+
+static bool m_locked_restart_time_wait_timer(struct dsd_htcp_conn* adsp_hc,
+                                             bool* abop_update,
+                                             int64_t* ailp_update_timer,
+                                             int64_t ilp_now_ms)
+{
+    uint32_t uml_delay_ms = 2 * adsp_hc->umc_msl_s * 1000;
+
+    return m_locked_start_timer(adsp_hc, abop_update, ailp_update_timer,
+                                &adsp_hc->ilc_timer,
+                                ilp_now_ms + uml_delay_ms,
+                                adsp_hc->ilc_da_timer);
+}
+
+
+static bool m_locked_start_da_timer(struct dsd_htcp_conn* adsp_hc,
+                                    bool* abop_update,
+                                    int64_t* ailp_update_timer,
+                                    int64_t ilp_now_ms)
+{
+    return m_locked_start_timer(adsp_hc, abop_update, ailp_update_timer,
+                                &adsp_hc->ilc_da_timer,
+                                ilp_now_ms + adsp_hc->umc_delay_ack_ms,
+                                adsp_hc->ilc_timer);
+}
+
+static bool m_locked_stop_da_timer(struct dsd_htcp_conn* adsp_hc,
+                                   bool* abop_update,
+                                   int64_t* ailp_update_timer)
+{
+    return m_locked_stop_timer(adsp_hc, abop_update, ailp_update_timer,
+                               &adsp_hc->ilc_da_timer, adsp_hc->ilc_timer);
+}
+
+static bool m_locked_update_rcv_sack(struct dsd_htcp_conn* adsp_hc,
+                                     uint32_t ump_ack,
+                                     const char* achp_option_data,
+                                     int32_t imp_option_count)
+{
+    uint32_t umrl_left[4];
+    uint32_t umrl_right[4];
+    uint32_t uml_left;
+    uint32_t uml_right;
+    bool bol_drop;
+    uint32_t umrl_buf_left[ins_htcp_out_sack_count];
+    uint32_t umrl_buf_right[ins_htcp_out_sack_count];
+    int32_t iml_buf_count;
+    int32_t iml_i;
+    int32_t iml_j;
+    int32_t iml_k;
+
+    // update the SACK options we receive - concerning output packets
+
+    // Since we arrived here, we know that ump_ack is not before umc_snd_una
+
+    HTCP_LOCKED_ASSERT_F(imp_option_count <= 4);
+
+    // we can sort incoming SACK information - we do not use order yet
+    for (iml_i = 0; iml_i < imp_option_count; ++iml_i) {
+        uml_left = m_get_32_bit(achp_option_data);
+        achp_option_data += 4;
+        uml_right = m_get_32_bit(achp_option_data);
+        achp_option_data += 4;
+
+        if (m_wge(uml_left, uml_right) ||
+            m_wle(uml_left, ump_ack) ||
+            m_wgt(uml_right, adsp_hc->umc_snd_nxt)) {
+            --imp_option_count;
+            --iml_i;
+            continue;
+        }
+
+        bol_drop = false;
+        for (iml_j = 0; iml_j < iml_i; ++iml_j) {
+            if (m_wlt(uml_right, umrl_left[iml_j])) {
+                // current block precedes block j
+                for (iml_k = iml_i; iml_k > iml_j; --iml_k) {
+                    umrl_left[iml_k] = umrl_left[iml_k - 1];
+                    umrl_right[iml_k] = umrl_right[iml_k - 1];
+                }
+                break;
+            }
+            if (m_wle(uml_left, umrl_right[iml_j])) {
+                // current block collides with block j - drop it
+                bol_drop = true;
+                break;
+            }
+        }
+        if (bol_drop) {
+            --imp_option_count;
+            --iml_i;
+            continue;
+        }
+        umrl_left[iml_j] = uml_left;
+        umrl_right[iml_j] = uml_right;
+    }
+
+    // update umc_sack_data_size
+    for (iml_i = 0; iml_i < imp_option_count; ++iml_i)
+        adsp_hc->umc_sack_data_size += umrl_right[iml_i] - umrl_left[iml_i];
+
+    // now check any table SACK info colliding with ack or options - and discard
+    // also copy table to temporary buffer to merge later into place
+
+    iml_i = 0; // SACK entries in header
+    iml_buf_count = 0;
+    for (iml_j = 0; iml_j < (int32_t)adsp_hc->umc_out_sack_count; ++iml_j) {
+        if (iml_buf_count == ins_htcp_out_sack_count - imp_option_count ||
+            m_wle(adsp_hc->umrc_out_sack_left[iml_j], ump_ack)) {
+
+            adsp_hc->umc_sack_data_size -=
+                adsp_hc->umrc_out_sack_right[iml_j] -
+                adsp_hc->umrc_out_sack_left[iml_j];
+            continue;
+        }
+
+        while (iml_i < imp_option_count &&
+               m_wlt(umrl_right[iml_i],
+                     adsp_hc->umrc_out_sack_left[iml_j])) {
+
+            ++iml_i;
+        }
+        // iml_i range is not before iml_j range
+        if (iml_i < imp_option_count &&
+            m_wle(umrl_left[iml_i],
+                  adsp_hc->umrc_out_sack_right[iml_j])) {
+
+            adsp_hc->umc_sack_data_size -=
+                adsp_hc->umrc_out_sack_right[iml_j] -
+                adsp_hc->umrc_out_sack_left[iml_j];
+            continue;
+        }
+
+        umrl_buf_left[iml_buf_count] = adsp_hc->umrc_out_sack_left[iml_j];
+        umrl_buf_right[iml_buf_count] = adsp_hc->umrc_out_sack_right[iml_j];
+        ++iml_buf_count;
+    }
+
+    // now merge received sack information in sack table
+    if (imp_option_count > 0 || iml_buf_count > 0) {
+        iml_i = 0;
+        iml_j = 0;
+        iml_k = 0;
+        while (iml_i < imp_option_count && iml_j < iml_buf_count) {
+            if (m_wlt(umrl_left[iml_i], umrl_buf_left[iml_j])) {
+                adsp_hc->umrc_out_sack_left[iml_k] = umrl_left[iml_i];
+                adsp_hc->umrc_out_sack_right[iml_k] = umrl_right[iml_i];
+                ++iml_i;
+            } else {
+                adsp_hc->umrc_out_sack_left[iml_k] = umrl_buf_left[iml_j];
+                adsp_hc->umrc_out_sack_right[iml_k] = umrl_buf_right[iml_j];
+                ++iml_j;
+            }
+            ++iml_k;
+        }
+        if (iml_i < imp_option_count) {
+            HTCP_LOCKED_ASSERT_F(iml_j == iml_buf_count);
+            while (iml_i < imp_option_count) {
+                adsp_hc->umrc_out_sack_left[iml_k] = umrl_left[iml_i];
+                adsp_hc->umrc_out_sack_right[iml_k] = umrl_right[iml_i];
+                ++iml_i;
+                ++iml_k;
+            }
+        } else {
+            HTCP_LOCKED_ASSERT_F(iml_j < iml_buf_count);
+            while (iml_j < iml_buf_count) {
+                adsp_hc->umrc_out_sack_left[iml_k] = umrl_buf_left[iml_j];
+                adsp_hc->umrc_out_sack_right[iml_k] = umrl_buf_right[iml_j];
+                ++iml_j;
+                ++iml_k;
+            }
+        }
+        adsp_hc->umc_out_sack_count = iml_k;
+    } else {
+        HTCP_LOCKED_ASSERT_F(adsp_hc->umc_sack_data_size == 0);
+        adsp_hc->umc_out_sack_count = 0;
+    }
+
+    return true;
+}
+
+static bool m_locked_update_sack_pipe(struct dsd_htcp_conn* adsp_hc)
+{
+    int32_t iml_higher_sack_count;
+    int32_t iml_higher_sack_data;
+    uint32_t uml_last_edge;
+    uint32_t uml_cur_hole;
+    uint32_t uml_i;
+
+    iml_higher_sack_count = adsp_hc->umc_out_sack_count;
+    iml_higher_sack_data = adsp_hc->umc_sack_data_size;
+
+    adsp_hc->umc_sack_pipe = 0;
+
+    uml_last_edge = adsp_hc->umc_snd_una;
+
+    for (uml_i = 0; uml_i < adsp_hc->umc_out_sack_count; ++uml_i) {
+        uml_cur_hole = adsp_hc->umrc_out_sack_left[uml_i] - uml_last_edge;
+
+        if (iml_higher_sack_count < ins_dup_thresh &&
+            iml_higher_sack_data <
+            ins_dup_thresh * ((int)adsp_hc->umc_snd_smss - 36)) {
+            // Reducing 36 from smss ensures we do not miss a detection of a
+            // lost segment because we send some SACK data ourselves.
+            // On the other hand, if the reduction is not necessary,
+            // it is very unlikely to have any effect.
+
+            // current hole is not considered lost, so is in transit (in pipe)
+            adsp_hc->umc_sack_pipe += uml_cur_hole;
+        }
+
+        if (m_wle(adsp_hc->umrc_out_sack_left[uml_i], adsp_hc->umc_high_rxt)) {
+            // current hole is retransmitted, so is in transit (in pipe)
+            adsp_hc->umc_sack_pipe += uml_cur_hole;
+        } else if (m_wlt(uml_last_edge, adsp_hc->umc_high_rxt)) {
+            // part of current hole is retransmitted, so is in transit (in pipe)
+            adsp_hc->umc_sack_pipe += adsp_hc->umc_high_rxt - uml_last_edge;
+        }
+
+        --iml_higher_sack_count;
+        iml_higher_sack_data -= (int32_t)(adsp_hc->umrc_out_sack_right[uml_i] -
+                                          adsp_hc->umrc_out_sack_left[uml_i]);
+        uml_last_edge = adsp_hc->umrc_out_sack_right[uml_i];
+    }
+
+    // now add data beyond highest sack block
+    adsp_hc->umc_sack_pipe += adsp_hc->umc_snd_nxt - uml_last_edge;
+    if (m_wlt(uml_last_edge, adsp_hc->umc_high_rxt))
+        adsp_hc->umc_sack_pipe += adsp_hc->umc_high_rxt - uml_last_edge;
+
+    return true;
+}
+
+static bool m_locked_sack_nextseg(struct dsd_htcp_conn* adsp_hc,
+                                  bool* abop_segment, uint32_t* aump_seq)
+{
+    int32_t iml_higher_sack_count;
+    int32_t iml_higher_sack_data;
+    bool bol_last_resort;
+    uint32_t uml_last_edge;
+    uint32_t uml_flight;
+    uint32_t uml_i;
+
+    if (adsp_hc->dsc_cc.umc_cwnd <
+        adsp_hc->umc_sack_pipe + adsp_hc->umc_snd_smss) {
+
+        *abop_segment = false;
+        return true;
+    }
+
+    iml_higher_sack_count = adsp_hc->umc_out_sack_count;
+    iml_higher_sack_data = adsp_hc->umc_sack_data_size;
+
+    bol_last_resort = false;
+
+    uml_last_edge = adsp_hc->umc_snd_una;
+
+    for (uml_i = 0; uml_i < adsp_hc->umc_out_sack_count; ++uml_i) {
+        if (m_wgt(adsp_hc->umrc_out_sack_left[uml_i], adsp_hc->umc_high_rxt)) {
+            if (m_wlt(uml_last_edge, adsp_hc->umc_high_rxt))
+                uml_last_edge = adsp_hc->umc_high_rxt;
+
+            if (iml_higher_sack_count >= ins_dup_thresh ||
+                iml_higher_sack_data >=
+                ins_dup_thresh * ((int)adsp_hc->umc_snd_smss) - 36) {
+                // Reducing 36 from smss ensures we do not miss a detection of a
+                // lost segment because we send some SACK data ourselves.
+                // On the other hand, if the reduction is not necessary,
+                // it is very unlikely to have any effect.
+
+                *aump_seq = uml_last_edge;
+                *abop_segment = true;
+                return true;
+            } else {
+                *aump_seq = uml_last_edge;
+                bol_last_resort = true;
+            }
+
+            break;
+        }
+
+        --iml_higher_sack_count;
+        iml_higher_sack_data -= (int32_t)(adsp_hc->umrc_out_sack_right[uml_i] -
+                                          adsp_hc->umrc_out_sack_left[uml_i]);
+        uml_last_edge = adsp_hc->umrc_out_sack_right[uml_i];
+    }
+
+    uml_flight = adsp_hc->umc_snd_nxt - adsp_hc->umc_snd_una;
+    if (adsp_hc->umc_send_pending >= adsp_hc->umc_snd_wnd) {
+        if (adsp_hc->umc_snd_wnd > uml_flight) {
+            *aump_seq = adsp_hc->umc_snd_nxt;
+            *abop_segment = true;
+            return true;
+        }
+    } else { // adsp_hc->umc_send_pending < adsp_hc->umc_snd_wnd
+        if (adsp_hc->umc_send_pending > uml_flight) {
+            *aump_seq = adsp_hc->umc_snd_nxt;
+            *abop_segment = true;
+            return true;
+        }
+    }
+
+    *abop_segment = bol_last_resort;
+    return true;
+}
+
+static bool m_locked_create_sack_option(struct dsd_htcp_conn* adsp_hc,
+                                        char* achp_o, uint32_t* aump_len)
+{
+    uint32_t uml_count;
+    struct dsd_htcp_in_info* adsl_hii;
+    uint32_t uml_seq;
+    bool bol_first;
+    bool bol_first_found_assertion = false;
+
+    HTCP_LOCKED_ASSERT_F(*aump_len <= 40);
+
+    if (adsp_hc->adsc_sack_first == NULL || *aump_len < 10) {
+        *aump_len = 0;
+        return true;
+    }
+
+    HTCP_LOCKED_ASSERT_F(adsp_hc->adsc_oo_list != NULL);
+
+    adsl_hii = adsp_hc->adsc_sack_first;
+    uml_seq = adsl_hii->umc_seq;
+    m_put_32_bit(achp_o + 2, uml_seq);
+    do {
+        uml_seq += adsl_hii->umc_len;
+        if (adsl_hii->adsc_next == NULL)
+            break;
+        adsl_hii = adsl_hii->adsc_next;
+    } while (adsl_hii->umc_seq == uml_seq);
+    HTCP_LOCKED_ASSERT_F(adsl_hii == NULL ||
+                         !m_within(adsl_hii->umc_seq,
+                                   adsl_hii->umc_seq + adsl_hii->umc_len,
+                                   uml_seq));
+    m_put_32_bit(achp_o + 6, uml_seq);
+
+
+    achp_o[0] = 5;
+    uml_count = 10;
+    adsl_hii = adsp_hc->adsc_oo_list;
+    while (uml_count + 8 <= *aump_len) {
+        bol_first = adsl_hii == adsp_hc->adsc_sack_first;
+
+        if (bol_first) {
+            HTCP_LOCKED_ASSERT_F(!bol_first_found_assertion);
+            bol_first_found_assertion = true;
+        }
+
+        uml_seq = adsl_hii->umc_seq;
+
+        if (!bol_first) {
+            m_put_32_bit(achp_o + uml_count, uml_seq);
+            uml_count += 4;
+        }
+
+        do {
+            uml_seq += adsl_hii->umc_len;
+            adsl_hii = adsl_hii->adsc_next;
+        } while (adsl_hii != NULL && adsl_hii->umc_seq == uml_seq);
+        HTCP_LOCKED_ASSERT_F(adsl_hii == NULL ||
+                             !m_within(adsl_hii->umc_seq,
+                                       adsl_hii->umc_seq + adsl_hii->umc_len,
+                                       uml_seq));
+
+        if (!bol_first) {
+            m_put_32_bit(achp_o + uml_count, uml_seq);
+            uml_count += 4;
+        }
+
+        if (adsl_hii == NULL)
+            break;
+    }
+
+    HTCP_LOCKED_ASSERT_F(bol_first_found_assertion ||
+                         uml_count + 8 > *aump_len);
+
+    achp_o[1] = uml_count;
+    *aump_len = uml_count;
+    return true;
+}
+
+static bool m_locked_start_header(struct dsd_htcp_conn* adsp_hc,
+                                  char* achp_header, uint32_t* aump_hlen,
+                                  uint8_t utp_flags, uint16_t usp_urg,
+                                  int64_t ilp_now_ms)
+{
+    uint32_t uml_len;
+    uint32_t uml_olen;
+    uint32_t uml_win;
+    bool bol_ret;
+
+    uml_olen = 0;
+    if (adsp_hc->boc_use_timestamp) {
+        if (adsp_hc->adsc_sack_first == NULL) {
+            achp_header[20 + uml_olen++] = 1; // noop padding
+            achp_header[20 + uml_olen++] = 1; // noop padding
+        }
+        bol_ret = m_locked_create_timestamp_option(adsp_hc,
+                                                   achp_header +
+                                                   20 + uml_olen,
+                                                   ilp_now_ms);
+        if (!bol_ret)
+            return false;
+        uml_olen += 10;
+    }
+
+    if (adsp_hc->adsc_sack_first != NULL) {
+        if (!adsp_hc->boc_use_timestamp) {
+            achp_header[20 + uml_olen++] = 1; // noop padding
+            achp_header[20 + uml_olen++] = 1; // noop padding
+        }
+        uml_len = 40 - uml_olen;
+        bol_ret = m_locked_create_sack_option(adsp_hc,
+                                              achp_header + 20 + uml_olen,
+                                              &uml_len);
+        if (!bol_ret)
+            return false;
+        uml_olen += uml_len;
+    }
+
+    HTCP_LOCKED_ASSERT_F(uml_olen <= 40 && uml_olen % 4 == 0);
+    *aump_hlen = 20 + uml_olen;
+
+    HTCP_LOCKED_ASSERT_F(m_get_tcp_flags_ack(utp_flags));
+
+    m_set_tcp_src_port(achp_header, adsp_hc->usc_local_port);
+    m_set_tcp_dst_port(achp_header, adsp_hc->usc_remote_port);
+    m_set_tcp_seqn(achp_header, adsp_hc->umc_snd_nxt_cur);
+    m_set_tcp_ackn(achp_header, adsp_hc->umc_rcv_nxt);
+    m_set_calc_tcp_hlen(achp_header, *aump_hlen);
+    m_set_tcp_resv(achp_header, 0);
+    m_set_tcp_flags(achp_header, utp_flags);
+    m_set_tcp_urgent(achp_header, usp_urg);
+
+    uml_win = adsp_hc->umc_rcv_wnd >> adsp_hc->umc_rcv_winscale;
+    if (uml_win > 65535)
+        uml_win = 65535;
+    m_set_tcp_window(achp_header, uml_win);
+
+    return true;
+}
+
+static bool m_locked_prepare_syn(struct dsd_htcp_conn* adsp_hc,
+                                 char* achp_header, uint32_t* aump_hlen,
+                                 bool bop_ack, int64_t ilp_now_ms)
+{
+    uint32_t uml_hlen;
+    uint8_t utl_flags;
+    bool bol_use_timestamp;
+    bool bol_ret;
+
+    // TODO: bol_use_timestamp variable is redundant
+    bol_use_timestamp = adsp_hc->boc_use_timestamp;
+
+    uml_hlen = 20;
+
+    // mss
+    achp_header[uml_hlen++] = 2;
+    achp_header[uml_hlen++] = 4;
+    m_put_16_bit(achp_header + uml_hlen, adsp_hc->umc_rcv_rmss);
+    uml_hlen += 2;
+
+    // window size shift
+    if (adsp_hc->boc_use_winscale) {
+        achp_header[uml_hlen++] = 3;
+        achp_header[uml_hlen++] = 3;
+        achp_header[uml_hlen++] = adsp_hc->umc_rcv_winscale;
+        if (adsp_hc->boc_use_sack || bol_use_timestamp)
+            achp_header[uml_hlen++] = 1; // noop padding
+        else
+            achp_header[uml_hlen++] = 0; // end padding
+    }
+
+    // accept SACK
+    if (adsp_hc->boc_use_sack) {
+        achp_header[uml_hlen++] = 4;
+        achp_header[uml_hlen++] = 2;
+        if (!bol_use_timestamp) {
+            achp_header[uml_hlen++] = 0; // end padding
+            achp_header[uml_hlen++] = 0; // end padding
+        }
+    }
+
+    // timestamp
+    if (bol_use_timestamp) {
+        if (!adsp_hc->boc_use_sack) {
+            achp_header[uml_hlen++] = 1; // noop padding
+            achp_header[uml_hlen++] = 1; // noop padding
+        }
+        bol_ret = m_locked_create_timestamp_option(adsp_hc,
+                                                   achp_header + uml_hlen,
+                                                   ilp_now_ms);
+        if (!bol_ret)
+            return false;
+        uml_hlen += 10;
+    }
+
+    HTCP_LOCKED_ASSERT_F(uml_hlen % 4 == 0);
+
+    utl_flags = bop_ack ? utd_tcp_syn_ack : utd_tcp_syn;
+
+    m_set_tcp_src_port(achp_header, adsp_hc->usc_local_port);
+    m_set_tcp_dst_port(achp_header, adsp_hc->usc_remote_port);
+    m_set_tcp_seqn(achp_header, adsp_hc->umc_snd_iss);
+    m_set_tcp_ackn(achp_header, bop_ack ? adsp_hc->umc_rcv_nxt : 0);
+    m_set_calc_tcp_hlen(achp_header, uml_hlen);
+    m_set_tcp_resv(achp_header, 0);
+    m_set_tcp_flags(achp_header, utl_flags);
+    m_set_tcp_window(achp_header, adsp_hc->umc_rcv_wnd > 65535 ?
+                     65535 : adsp_hc->umc_rcv_wnd);
+    m_set_tcp_urgent(achp_header, 0);
+
+    *aump_hlen = uml_hlen;
+
+    return true;
+}
+
+static bool m_locked_packets_available(struct dsd_htcp_conn* adsp_hc,
+                                       bool* abop_available)
+{
+    uint32_t uml_pending;
+    uint32_t uml_nxt_offset;
+    uint32_t uml_cwnd;
+    uint32_t uml_dummy;
+    bool bol_syn_unacked;
+    bool bol_send_fin;
+
+    // check adsp_hc->utc_packet_flags for SYN or RST or ACK,
+    // and for zero window probe,
+    // and for output dup ACKs
+    if (adsp_hc->utc_packet_flags != 0 ||
+        adsp_hc->boc_zwnd_probe ||
+        adsp_hc->umc_tosend_dack > 0) {
+        *abop_available = true;
+        return true;
+    }
+
+    if (adsp_hc->iec_state == ied_htcp_closed) {
+        *abop_available = false;
+        return true;
+    }
+
+    bol_syn_unacked = (adsp_hc->iec_state == ied_htcp_syn_sent ||
+                       adsp_hc->iec_state == ied_htcp_syn_rcvd ||
+                       adsp_hc->iec_state == ied_htcp_syn_sent_eof ||
+                       adsp_hc->iec_state == ied_htcp_syn_rcvd_eof);
+
+    bol_send_fin = (adsp_hc->iec_state == ied_htcp_syn_rcvd_eof ||
+                    adsp_hc->iec_state == ied_htcp_fin_wait_1 ||
+                    adsp_hc->iec_state == ied_htcp_closing ||
+                    adsp_hc->iec_state == ied_htcp_last_ack);
+
+    HTCP_LOCKED_ASSERT_F(m_wge(adsp_hc->umc_snd_nxt_cur, adsp_hc->umc_snd_una));
+    uml_nxt_offset = adsp_hc->umc_snd_nxt_cur - adsp_hc->umc_snd_una;
+    uml_pending = adsp_hc->umc_send_pending;
+    HTCP_LOCKED_ASSERT_F(uml_pending +
+                         (bol_syn_unacked ? 1 : 0) + (bol_send_fin ? 1 : 0)
+                         >= uml_nxt_offset);
+    uml_cwnd = adsp_hc->dsc_cc.umc_cwnd;
+
+    if (uml_pending > adsp_hc->umc_snd_wnd) {
+        uml_pending = adsp_hc->umc_snd_wnd;
+        bol_send_fin = false;
+    }
+
+    if (adsp_hc->boc_recovering) {
+
+        if (adsp_hc->boc_recover_packet) {
+            *abop_available = true;
+            return true;
+        }
+
+        if (adsp_hc->boc_use_sack) {
+            if (!m_locked_sack_nextseg(adsp_hc, abop_available, &uml_dummy))
+                return false;
+            return true;
+        } else { // !adsp_hc->boc_use_sack
+            if (adsp_hc->umc_pending_dacks == 0) {
+                *abop_available = false;
+                return true;
+            }
+
+            // If we have limited transmit segments, send those first.
+            // Otherwise, go on to check if a packet is available within cwin.
+            // Note that this is the only case where we remain in this
+            // function if adsp_hc->boc_recovering is true.
+        }
+    }
+
+    // limited transmit
+    if (adsp_hc->umc_limited_transmit > 0) {
+        if (uml_pending > uml_nxt_offset &&
+            uml_cwnd + 2 * adsp_hc->umc_snd_smss > uml_nxt_offset) {
+
+            *abop_available = true;
+            return true;
+        }
+        adsp_hc->umc_limited_transmit = 0;
+
+        /*
+        // optimization to avoid going through next steps:
+        adsp_hc->umc_pending_dacks = 0;
+        *abop_available = false;
+        return true;
+        // end of optimization
+        */
+    }
+
+    if (adsp_hc->boc_recovering) {
+        // We only arrive here if handling adsp_hc->umc_pending_dacks
+        if (uml_pending > uml_nxt_offset &&
+            uml_cwnd > uml_nxt_offset) {
+
+            *abop_available = true;
+            return true;
+        }
+        adsp_hc->umc_pending_dacks = 0;
+
+        /*
+        // optimization to avoid going through next step:
+        *abop_available = false;
+        return true;
+        // end of optimization
+        */
+    }
+
+    if (uml_pending > uml_nxt_offset &&
+        uml_cwnd > uml_nxt_offset) {
+
+        *abop_available = true;
+        return true;
+    }
+
+    if (uml_pending == uml_nxt_offset && bol_send_fin) {
+        *abop_available = true;
+        return true;
+    }
+
+    *abop_available = false;
+    return true;
+}
+
+static bool m_send_rst(struct dsd_htcp_conn* adsp_hc,
+                       uint32_t ump_seq_or_ack, bool bop_ack)
+{
+    // TODO: syncronize
+
+    bool bol_ret;
+
+    if (bop_ack) {
+        adsp_hc->utc_packet_flags = utd_tcp_rst_ack;
+        adsp_hc->umc_packet_seq = 0;
+        adsp_hc->umc_packet_ack = ump_seq_or_ack;
+    } else {
+        adsp_hc->utc_packet_flags = utd_tcp_rst;
+        adsp_hc->umc_packet_seq = ump_seq_or_ack;
+        adsp_hc->umc_packet_ack = 0;
+    }
+
+    bol_ret = adsp_hc->adsc_cb->amc_out_packets(adsp_hc);
+    HTCP_CHECK_CB_RET_F(amc_out_packets);
+
+    return true;
+}
Index: SOFTWARE.HLSEC.HPPPT1P2.act.txt
===================================================================
--- SOFTWARE.HLSEC.HPPPT1P2.act.txt	(revision 0)
+++ SOFTWARE.HLSEC.HPPPT1P2.act.txt	(revision 6)
@@ -0,0 +1,107 @@
+
+
+
+
+
+
+         Protocol HOB-PPP-T1
+
+         current version: 2.1
+
+         1. General Architecture
+
+         The client sends the first packet which is terminated by
+         carriage-return line-feed.
+
+         Content in ASCII:
+         HOB PPP TUNNEL V01<CR><LF>
+
+         The protocol is designed in a way so that for IP packets, IPV4
+         and IPV6, no extra overhead is needed.
+         Mostly IP packets are exchanged over HOB-PPP-T1, so this
+         protocol is very efficiant.
+
+         After the first packet, alle packets exchanged are encoded as
+         TLV, Tag, Length, Value.
+
+         The length is encoded as NHASN if not part of an IP header.
+
+         IPV4 packets start with 0X4x, and the length of the IP packet is
+         encoded as two bytes network-byte-order (big endian) in the
+         field Total Length at displacement 2.
+
+         IPV6 packets start with 0X6x, and the length of the IP packet
+         can be calculated from the field Payload Length and the length
+         of the IPV6 header which is always 40 bytes long.
+         Payload Length is encoded as as two bytes network-byte-order
+         (big endian) at displacement 4.
+
+         For IPV4 and IPV6 packets, no extra information is provided.
+
+         Besides 0X4x and 0X6x for IPV4 and IPV6, the following tags are
+         used:
+         - Tag 0X30 - ASCII '0' for control packets
+         - Tag 0X31 - ASCII '1' for PPP packets
+
+         Both, control packets, and PPP packets, are constructed as Tag,
+         Length in NHASN for the following payload data.
+
+         2. Control Packets
+
+         Control character '0' means control packets.
+
+         2.1. The client may send the following control messages:
+
+         2.1.1. START HOSTNAME=HOB-PPP-T1-07 LOCAL-INETA=172.22.60.158
+         EPOCH=1276845953
+         ... UUU TCP special + TSS
+
+         2.2.2. RECONNECT TUNNEL-ID=261A0005 LOCAL-INETA=172.22.60.158
+         EPOCH=1276846037 DROPPED-PACKETS=27+
+
+
+
+
+
+         2.1.3. NOP
+
+         2.1.4. END DROPPED-PACKETS=nnn
+
+         2.1.5. QUERY-SIGNATURE=...
+
+         2.2. The server may send the following control messages:
+
+         2.2.1. RESPONSE-START TUNNEL-ID=261A0005
+         SERVER-NETWORK-INETA=172.22.0.0 SERVER-NETWORK-MASK=255.255.0.0
+         ... UUU TCP special + TSS
+
+         2.2.2. STOP
+
+         2.2.3. RESPONSE-SIGNATURE=...
+
+         2.2.4. Signature for HOB Anti Split Tunneling
+
+         The client may request a signature of the WSP / server by
+         sending a Nonce of any length, encoded as Mime / Base64 without
+         trailing equals (=).
+         This request is sent as the query 2.1.5. QUERY-SIGNATURE=....
+
+         The server will compute the response by RSA and respond with
+         RESPONSE-SIGNATURE=..., also encoded as Mime / Base64 without
+         trailing equals (=).
+
+         3. Flow of Packets
+
+         3.2. when the server has received 'RECONNECT TUNNEL-ID=...' it
+         sends 'NOP'.
+         This is needed so that the client knows that the TCP connection
+         really is estiblished.
+         Only when the client receives a TCP packet it can be shure that
+         the TCP session is really established.
+
+         4. Reference:
+         HOBC02K E:\TRACES\HOB-PPP-T1\hpppt1-reconnect-02.LST
+
+         31.12.12  KB+
\ No newline at end of file
Index: hob-li-gw-01.h
===================================================================
--- hob-li-gw-01.h	(revision 2)
+++ hob-li-gw-01.h	(revision 6)
@@ -12,6 +12,7 @@
 /*| ----------                                                        |*/
 /*|  Copyright (C) HOB Germany 2011                                   |*/
 /*|  Copyright (C) HOB Germany 2012                                   |*/
+/*|  Copyright (C) HOB Germany 2013                                   |*/
 /*|                                                                   |*/
 /*| REQUIRED PROGRAMS:                                                |*/
 /*| ------------------                                                |*/
@@ -33,6 +34,7 @@
 #define D_LI_GW_TOKEN          0X10092011   /* token for start packet  */
 #define D_LI_GW_VERSION        0            /* version of listen gateway */
 #define D_LIGW_RANDOM_L        20           /* length random listen-gateway - length SHA-1 */
+#define D_LIGW_MAX_TIME_RANDOM 5            /* maximum time in seconds that the listen-gateway decrypts the message after sent */
 #define D_LIGW_MAX_WSP         16           /* maximum number of WSPs connected */
 #define D_LIGW_UDS_WSP_BACKLOG 8            /* backlog Unix domain socket listen */
 #define D_LIGW_CLUSTER_BACKLOG 8            /* backlog TCP cluster listen */
@@ -49,14 +51,24 @@
 enum ied_li_gw_query {
    ied_ligwq_start = 0,                     /* start of WSP            */
    ied_ligwq_socket,                        /* create socket           */
-   ied_ligwq_cluster                        /* cluster message         */
+   ied_ligwq_cluster,                       /* cluster message         */
+#ifdef D_INCL_HOB_TUN
+   ied_ligwq_open_tun,                      /* open TUN adapter        */
+   ied_ligwq_arproute_add_ipv4,             /* add ARP and route IPV4  */
+   ied_ligwq_arproute_del_ipv4              /* del ARP and route IPV4  */
+#endif
 };

 enum ied_li_gw_response {
    ied_ligwr_msg = 0,                       /* message                 */
    ied_ligwr_wsps,                          /* other WSPs              */
    ied_ligwr_resp_socket_ok,                /* create socket succeeded */
-   ied_ligwr_resp_socket_failed             /* create socket failed    */
+   ied_ligwr_resp_socket_failed,            /* create socket failed    */
+#ifdef D_INCL_HOB_TUN
+   ied_ligwr_resp_open_tun,                 /* open TUN adapter        */
+   ied_ligwr_resp_arproute_add_ipv4,        /* add ARP and route IPV4  */
+   ied_ligwr_resp_arproute_del_ipv4         /* del ARP and route IPV4  */
+#endif
 };

 enum ied_li_gw_error_command {              /* command which failed    */
@@ -64,11 +76,13 @@
    ied_ligwec_bind                          /* bind failed             */
 };

+#ifdef XYZ1
 struct dsd_ineta_port_ligw {                /* INETA and port          */
    unsigned char ucc_family;                /* address family          */
    unsigned char ucc_len_ineta;             /* length INETA            */
    unsigned char ucrc_port[ 2 ];            /* port                    */
 };
+#endif

 struct dsd_create_socket_ligw {             /* create a socket         */
    unsigned char ucc_family;                /* address family          */
@@ -76,3 +90,32 @@
    unsigned char ucc_protocol;              /* protocol used           */
    unsigned char ucrc_port[ 2 ];            /* port                    */
 };
+
+#ifdef D_INCL_HOB_TUN
+struct dsd_ligw_q_open_tun {                /* query open TUN adapter  */
+   unsigned char ucc_use_ipv4;              /* use IPV4                */
+   unsigned char ucc_use_ipv6;              /* use IPV6                */
+   unsigned char ucc_no_ineta_ipv4;         /* number of INETAs IPV4   */
+   unsigned char ucc_no_ineta_ipv6;         /* number of INETAs IPV6   */
+};
+
+struct dsd_ligw_r_open_tun {                /* response open TUN adapter */
+   unsigned char ucc_index_ineta_ipv4;      /* index of INETA IPV4 + 1 */
+   unsigned char ucc_index_ineta_ipv6;      /* index of INETA IPV6 + 1 */
+   char       chrc_tiface[ IFNAMSIZ ];      /* name of tun interface   */
+};
+
+struct dsd_ligw_q_ar_add_ipv4 {             /* add ARP and route IPV4  */
+   char       chrc_tiface[ IFNAMSIZ ];      /* name of tun interface   */
+   char       chrc_riface[ IFNAMSIZ ];      /* name of real interface  */
+   struct sockaddr dsc_rhwaddr;             /* real interface mac addr */
+   char       chrc_ineta[4];                /* INETA IPV4              */
+};
+
+struct dsd_ligw_q_ar_del_ipv4 {             /* del ARP and route IPV4  */
+   char       chrc_tiface[ IFNAMSIZ ];      /* name of tun interface   */
+   char       chrc_riface[ IFNAMSIZ ];      /* name of real interface  */
+   struct sockaddr dsc_rhwaddr;             /* real interface mac addr */
+   char       chrc_ineta[4];                /* INETA IPV4              */
+};
+#endif
Index: xiipgw08-aux.cpp
===================================================================
--- xiipgw08-aux.cpp	(revision 2)
+++ xiipgw08-aux.cpp	(revision 6)
@@ -307,6 +307,18 @@
      case DEF_AUX_SECURE_RANDOM:            /* get secure random       */
        achl_func = "DEF_AUX_SECURE_RANDOM";  /* text of function       */
        break;
+     case DEF_AUX_GET_WSP_FINGERPRINT:      /* get WSP fingerprint     */
+       achl_func = "DEF_AUX_GET_WSP_FINGERPRINT";  /* text of function */
+       break;
+     case DEF_AUX_PIPE:                     /* aux-pipe                */
+       achl_func = "DEF_AUX_PIPE";          /* text of function        */
+       break;
+     case DEF_AUX_UTILITY_THREAD:           /* create unitliy thread   */
+       achl_func = "DEF_AUX_UTILITY_THREAD";  /* text of function      */
+       break;
+     case DEF_AUX_SWAP_STOR:                /* manage swap storage     */
+       achl_func = "DEF_AUX_SWAP_STOR";     /* text of function        */
+       break;
    }
 #undef HL_MAX_AUX_TEXT
    bol1 = m_secondary_aux( vpp_userfld, imp_func, apparam, imp_length );
@@ -904,10 +916,10 @@
        return m_tcp_conn( ADSL_AUX_CF1, (struct dsd_aux_tcp_conn_1 *) apparam );
 #endif
 #ifdef TRY_D_INCL_HTUN
-       return m_tcp_conn( ADSL_AUX_CF1, (struct dsd_aux_tcp_conn_1 *) apparam, NULL, TRUE );
+       return m_tcp_dynamic_conn( ADSL_AUX_CF1, (struct dsd_aux_tcp_conn_1 *) apparam, NULL, NULL, TRUE );
 #endif
 #else
-       return m_tcp_conn( ADSL_AUX_CF1, (struct dsd_aux_tcp_conn_1 *) apparam, NULL, TRUE );
+       return m_tcp_dynamic_conn( ADSL_AUX_CF1, (struct dsd_aux_tcp_conn_1 *) apparam, NULL, NULL, TRUE );
 #endif
      case DEF_AUX_TCP_CLOSE:                /* close TCP to Server     */
        if (ADSL_CONN1_G->adsc_server_conf_1->boc_dynamic == FALSE) {
@@ -1830,6 +1842,16 @@
        iml1 = m_secdrbg_randbytes( (char *) apparam, imp_length );
        if (iml1 == imp_length) return TRUE;
        return FALSE;
+     case DEF_AUX_GET_WSP_FINGERPRINT:      /* get WSP fingerprint     */
+       if (imp_length != DEF_LEN_FINGERPRINT) return FALSE;  /* invalid size  */
+       memcpy( apparam, dsg_this_server.chrc_fingerprint, DEF_LEN_FINGERPRINT );
+       return TRUE;
+     case DEF_AUX_PIPE:                     /* aux-pipe                */
+       return FALSE;
+     case DEF_AUX_UTILITY_THREAD:           /* create unitliy thread   */
+       return FALSE;
+     case DEF_AUX_SWAP_STOR:                /* manage swap storage     */
+       return FALSE;
    }
    /* not new element                                                  */
    adsl_auxf_1_w1 = ADSL_CONN1_G->adsc_auxf_1;
@@ -4595,10 +4617,32 @@
    return;                                  /* structure has been filled */
 } /* end m_aux_get_duia_1()                                            */

+/**
+  for secure XOR, there is an entry in the WSP-XML-configuration-file,
+  <general>
+    <security-token-plain>
+      or
+    <security-token-encrypted>
+  a hash is taken from this UTF-8 string.
+  When the function aux() DEF_AUX_SECURE_XOR is processed,
+  the optionally passed post-key is also feed into this hash.
+  AES encryption is done as described in RFC 3711 - Secure RTP (SRTP).
+  The follwing input variables are needed for the AES encryption:
+  - RSA key, 256 bit = 32 bytes
+  - IV, 128 bit = 16 bytes
+  - first block for AES CBC encryption, 16 bytes
+    ??? 23.11.12 KB
+  the output string is built by XOR of the input string
+  with the result of the AES encryption.
+*/
 /** process secure XOR                                                 */
 static BOOL m_aux_secure_xor( struct dsd_aux_secure_xor_1 *adsp_asx1 ) {
    char       *achl1, *achl2, *achl3, *achl4, *achl5;  /* working variables */
    int        imrl_sha1[ SHA_ARRAY_SIZE ];  /* for hash                */
+#ifdef TRY_121123_01                        /* secure-XOR SHA-384      */
+   HL_LONGLONG ilrl_sha384_temp[ SHA384_ARRAY_SIZE ];  /* for hash security-token */
+   char       chrl_hash_both[ SHA384_DIGEST_LEN ];  /* output of hash  */
+#endif
    char       chrl_hash1[ 20 ];             /* output of hash          */
    char       chrl_encry1[ 16 ];            /* for encryption          */
    struct ds_aes_key_t dsl_enckeybyte;      /* for AES encryption      */
@@ -4612,17 +4656,39 @@
      SHA1_Update( imrl_sha1, adsp_asx1->achc_post_key, 0, adsp_asx1->imc_len_post_key );
    }
    SHA1_Final( imrl_sha1, chrl_hash1, 0 );
+#ifdef TRY_121123_01                        /* secure-XOR SHA-384      */
+   memcpy( ilrl_sha384_temp, ilrs_sha384_security_token, sizeof(ilrs_sha384_security_token) );  /* for hash security-token */
+   if (adsp_asx1->imc_len_post_key > 0) {   /* length of post key string */
+     SHA384_512_Update( ilrl_sha384_temp, adsp_asx1->achc_post_key, 0, adsp_asx1->imc_len_post_key );
+   }
+   SHA384_Final( ilrl_sha384_temp, chrl_hash_both, 0 );
+#endif
+#ifndef TRY_121123_01                       /* secure-XOR SHA-384      */
 // to-do 18.10.12 KB - first 16 bytes of chrl_hash1 not used
    memcpy( chrl_encry1 + 0, chrl_hash1 + 16, sizeof(chrl_hash1) - 16 );
    memset( chrl_encry1 + sizeof(chrl_hash1) - 16, 0, sizeof(chrl_encry1) - (sizeof(chrl_hash1) - 16) );
    m_aes_set_encrypt_key( (unsigned char *) chrl_encry1, 4, &dsl_enckeybyte );
 // to-do 12.09.11 KB - is memset() necessary ???
    memset( ucrl_ivector, 0, sizeof(ucrl_ivector) );
+#endif
+#ifdef TRY_121123_01                       /* secure-XOR SHA-384      */
+#ifdef B121130
+//  ??? 23.11.12 KB
+   memset( chrl_encry1, 0, sizeof(chrl_encry1) );
+#endif
+   m_aes_set_encrypt_key( (unsigned char *) chrl_hash_both, 8, &dsl_enckeybyte );
+   memcpy( ucrl_ivector, (unsigned char *) chrl_hash_both + 32, sizeof(ucrl_ivector) );
+#endif
    achl1 = adsp_asx1->achc_source;          /* address of source       */
    achl2 = achl1 + adsp_asx1->imc_len_xor;  /* add length of string, end */
    achl3 = adsp_asx1->achc_destination;     /* address of destination  */
    do {                                     /* loop to XOR data        */
+#ifndef TRY_121123_01                       /* secure-XOR SHA-384      */
      m_aes_cbc_encrypt( (unsigned char *) achl1, (unsigned char *) chrl_encry1, &dsl_enckeybyte, 1, ucrl_ivector, 4 + 6 );
+#endif
+#ifdef TRY_121123_01                       /* secure-XOR SHA-384      */
+     m_aes_cbc_encrypt( (unsigned char *) achl1, (unsigned char *) chrl_encry1, &dsl_enckeybyte, 1, ucrl_ivector, 8 + 6 );
+#endif
      achl4 = achl1 + sizeof(chrl_encry1);
      if (achl4 > achl2) achl4 = achl2;      /* end of input            */
      achl5 = chrl_encry1;                   /* here is content for XOR */
Index: SOFTWARE.HLSEC.NBIPGW19.act.txt
===================================================================
--- SOFTWARE.HLSEC.NBIPGW19.act.txt	(revision 0)
+++ SOFTWARE.HLSEC.NBIPGW19.act.txt	(revision 6)
@@ -0,0 +1,291 @@
+
+
+
+
+
+
+         nbipgw19 - Description
+
+         1. Overview - the Need
+
+         All Unix (and Linux) systems prevent programs from listening to
+         well-known ports (<1024) if they don't run under a superuser
+         (administrator) account.
+         The so-called listen-gateway nbipgw19 is meant to allow HOB
+         programs, which, for security reasons do not run under such a
+         privileged account, to listen to the above ports as well.
+         This is done by having the non-privileged program call nbipgw19,
+         which runs under a privileged account. nbipgw19 then does create
+         the sockets and bind() for that program and hands the resulting
+         socket back over to the program which can then start doing
+         listen() and resulting from accept(), communications with it.
+
+         When HOB-TUN is included by the HOB WebSecureProxy (WSP), using
+         a TUN-adapter, ARP entries (Address Resolution Protocol) need to
+         be created and deleted, and also routes need to be added and
+         deleted. All this can only be done under a superuser
+         (administrator) account.
+         So nbipgw19 also includes support for ARP entries and routes to
+         be managed in request from the calling program (nbipgw20).
+
+         For the HOB WebSecureProxy (WSP, nbipgw20 in Unix), some type of
+         coordination needs to be done when more than one WSP runs on the
+         same machine.
+         The concept of the WSP includes that the configuration may be
+         changed and applied without disrupting the service given to the
+         users / clients.
+         In Unix this means, when the configuration has been changed, a
+         second nbipgw20 is started. This notifies the first running
+         nbipgw20 by a signal that this needs to close its listen
+         sockets, and then the second nbipgw20 can open the listen ports.
+         New connections are handled by the second nbipgw20, since this
+         is now listening. The first nbipgw20 stops processing as soon as
+         all active sessions have ended.
+
+         In this szenario, coordination is needed for the cluster
+         functionality. Other WSPs on other servers need to be connected
+         to the first nbipgw20 and the second nbipgw20 at the same time.
+
+         This behaviour is reached thru coordination for the cluster thru
+         the listen-gateway nbipgw19.
+
+         All messages from a client to the listen-gateway nbipgw19 are
+         encrypted in a special way, using a shared secret.
+
+         So when another application does not know the shared secret, it
+         cannot encrypt the messages in the way needed, and so another
+         application cannot get the listen-gateway nbipgw19 do things for
+         which superuser rights are needed.
+
+         The listen-gateway nbipgw19 uses Unix sockets for the
+         communication with its clients; communication over Unix sockets
+         is only possible between processes running on the same Unix
+         system. Communication over Unix sockets cannot be done over the
+         network.+
+
+
+
+
+
+         The listen-gateway nbipgw19 does not need any configuration, but
+         certain parameters may optionally be passed in the command line
+         when nbipgw19 is started.
+
+         The listen-gateway nbipgw19 gets all necessary information from
+         its clients (WSPs), these may pass their configuration to the
+         listen-gateway.
+
+         2. Protocol
+
+         2.1. General Design of the Protocol
+
+         Communication between the listen-gateway nbipgw19 and its
+         clients is handled over Unix sockets. A running nbipgw19 can
+         simulantiously be connected by any number of clients.
+         nbipgw19 listens on a Unix socket for incomming connections from
+         its clients.
+
+         For communication between the listen-gateway nbipgw19 and its
+         clients, the structures are defined in hob-li-gw-01.h.
+
+         The communication between the listen-gateway nbipgw19 and its
+         clients is done using the following protocol:
+
+         All numbers except length values are sent in the endianness of
+         the underlying hardware. Length values are NHASN coded. The
+         header containing the overall length value (not containing
+         header and length field) is sent "as is". The remaining part of
+         a request message, the commands, is encrypted. The responses
+         sent from nbipgw19 to the clients are never encrypted.
+         The commands are sent in sequence and structured as follows:
+
+         Commands = queries from the client (nbipgw20) to nbipgw19 first
+         contain a header with the constant:
+           0X48, 0X4F, 0X42, 0X20, 0X4C, 0X49, 0X00, 0X51, 0X00
+             /* HOB LI - Q */
+         After this, there is a random for encryption, the current time,
+         and then there is the payload encrypted.
+
+         Responses from nbipgw19 to the client (nbipgw20) first contain a
+         header with the constant:
+           0X48, 0X4F, 0X42, 0X20, 0X4C, 0X49, 0X00, 0X52, 0X00
+             /* HOB LI - R */
+
+         After the header, the payload is sent starting with:
+
+         Length (NHASN)
+         Command = Tag (1 byte)
+         Command data (Command data length + 1 for Command = Tag)
+
+         2.2. Command Start to Start Communication by the Client
+
+         The client, after starting the Unix socket connection, sends a
+         message ied_ligwq_start containing three int (4 bytes each)
+         values D_LI_GW_TOKEN, D_LI_GW_VERSION and the PID (process
+         identifier) of the client.+
+
+
+
+
+
+         When already other clients (WSPs) are conntected to the
+         listen-gateway nbipgw19, the listen-gateway sends as response
+         the list of PIDs (process identifier) of the other clients
+         (WSPs) that are already connected to this listen-gateway. This
+         response contains the tag ied_ligwr_wsps, followed by int values
+         containing the PID.
+
+         When no other clients (WSPs) are conntected to the
+         listen-gateway nbipgw19, the listen-gateway does not send a
+         response.
+
+         2.3. Messages from the Listen-Gateway nbipgw19 to the client to
+         be display on the console by the client and optionally written
+         to a configured log by the client
+
+         The listen-gateway nbipgw19 may, at any time, send ASCII
+         messages (or UTF-8 or the system-used character-set) to the
+         client (WSP) to be displayed at the console of the client and,
+         if a log is configured at the client, to be written to the
+         corresponding log.
+
+         This message contains the tag ied_ligwr_msg.
+
+         2.4. Command Create Socket
+
+         A client (nbipgw20) can send a command = query to nbipgw19 to
+         create socket by setting
+           ied_ligwq_socket   /* create socket */
+         after the header and the length of the command.
+         After this,
+           struct dsd_create_socket_ligw   /* create a socket */
+         are passed and appended there is the INETA for bind().
+
+         Any network protocol (AF_INET or AF_INET6) and any socket-type
+         (SOCK_STREAM or SOCK_DGRAM) can be passed.
+
+         When nbipgw19 has successfully created the requested socket and
+         did the bind(), it sends the reply by the API
+           sendmsg()
+         which sends data and associated with it a socket or file
+         descriptor. The tag of this message is ied_ligwr_resp_socket_ok.
+
+         The client needs to receive this message by the API
+           recvmsg()
+         so it can retrieve the passed socket or file descriptor.
+
+         When creating the socket or the bind() fail, the listen-gateway
+         responds with message ied_ligwr_resp_socket_failed including
+         three int (4 bytes) values of
+         - enum ied_li_gw_error_command
+           (either ied_ligwec_socket or ied_ligwec_bind)
+         - return-code of the API
+         - errno+
+
+
+
+
+
+         2.5. Cluster Commands
+
+         As described in the document about clusters, the clients (WSPs)
+         can send commands ied_ligwq_cluster which contain:
+         - original port, 2 bytes big endian
+         - port client (WSP) is really listening, 2 bytes big endian
+         - INETA (multihomed) when the client (WSP) is listening,
+           4 bytes for IPV4 or 16 bytes for IPV6
+
+         2.6. Encryption of the Data send from the Client to the
+         Listen-Gateway
+
+         The client builds the record after the constant header as
+         follows:
+         - 16 bytes random
+         - 4 bytes current time (Epoch) in seconds, big endian
+
+         The message, in chunks of 20 bytes each, is XORed with the SHA-1
+         Hash calculated as follows:
+         - feed hash with shared secret in single-byte character set
+         - feed hash with 20 bytes of last part of message, first random
+           and time, later last chunk XORed
+         - finalize the hash giving 20 bytes
+         - XOR current payload with result of hash (20 bytes)
+         - increase pointer to payload and last chunk
+         This algorithm is repeated for the entire payload.
+         No padding is needed.
+
+         The time is included to prevent replay of recorded messages.
+
+         3. Cluster
+
+         The listen-gateway nbipgw19 has special functionality
+         implemented to support WSPs running in a cluster.
+
+         From the clients (WSPs) the listen-gateway gets commands
+         (messages) about the cluster configuration and usage.
+         The listen-gateway opens TCP ports for listening to other
+         cluster members on the TCP ports configured in the clients
+         (WSPs).
+         When another WSP creates a TCP connection to the listen-gateway,
+         and sends the first message 0 Control Path, the listen-gateway
+         responds sending a message containing 2 Redirect, and
+         information about one or multiple WSPs and where they are
+         listening on randomly selected TCP ports.
+
+         4. Command Line Options when Starting nbipgw19
+
+         The listen-gateway nbipgw19 may be started without any
+         parameters, or it can be started with certain parameters passed
+         in the command line. When the listen-gateway is started and
+         parameters are passed, these paramters consist of a keyword and
+         optionally followed by the equal sign and the value.+
+
+
+
+
+
+         The following keywords may be used:
+         - domain-socket=   name for the used Unix socket
+         - shared-secret=   shared secret for encryption
+         - log              nbipgw19 writes all messages to the system
+                            log (syslog)
+         - trace=           numeric trace-level for problem analysis
+
+         Example:
+           nbipgw19 domain-socket=test-unix-socket-name log
+           nbipgw19 domain-socket=tusn "shared-secret=a b c"
+           nbipgw19 trace=9 log
+
+         When no domain-socket= or no shared-secret= are given,
+         internally defined default values are used.
+
+         5. Running the Listen-Gateway nbipgw19
+
+         Normally, the listen-gateway nbipg19 should be started before
+         clients (WSP, nbipgw20) are started. But as the clients should
+         periodically try to reconnect to the listen-gateway, the
+         listen-gateway can also be started after the clients are
+         started.
+
+         It is also possible to terminate the listen-gateway nbipg19 in
+         production environment and later restart the listen-gateway
+         nbipg19. The clients will periodically try to reconnect. Of
+         course, the clients cannot call any superuser APIs while
+         disconnected from the the listen-gateway nbipg19.
+
+         Multiple nbipgw19 may run on the same server as long as they use
+         different Unix socket (Unix domain socket) names. The clients
+         (WSPs) need to be configured accordingly in this szenario.
+
+         6. References
+
+         HOBTEXT SOFTWARE.HLSEC.CLUSTER1
+
+         12.11.12  KB
+         16.11.12  KB
+         17.11.12  KB+
\ No newline at end of file

</review-scope>
