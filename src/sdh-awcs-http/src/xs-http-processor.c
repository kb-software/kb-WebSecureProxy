/*+---------------------------------------------------------------------+*/
/*|                                                                     |*/
/*| PROGRAM-NAME                                                        |*/
/*| ============                                                        |*/
/*|   xs-http-parser                                                    |*/
/*|   http parser                                                       |*/
/*|                                                                     |*/
/*| COPYRIGHT                                                           |*/
/*| =========                                                           |*/
/*|   Copyright (C) HOB Germany 2011                                    |*/
/*|                                                                     |*/
/*| AUTHOR                                                              |*/
/*| ======                                                              |*/
/*|   Michael Jakobs                                                    |*/
/*|   Tobias Hofmann, October 2011                                      |*/
/*|                                                                     |*/
/*| DATE                                                                |*/
/*| ====                                                                |*/
/*|   01/19/2011                                                        |*/
/*|                                                                     |*/
/*+---------------------------------------------------------------------+*/

/*+---------------------------------------------------------------------+*/
/*| global includes:                                                    |*/
/*+---------------------------------------------------------------------+*/
#ifdef HL_UNIX
#else // windows
    #include <windows.h>
	#pragma warning(disable:4996)       /* windows warning for vnsprintf */
#endif //HL_UNIX
#include <string.h>
#include <stdio.h>
#include <stdarg.h>


#ifndef HOB_XSLUNIC1_H
    #define HOB_XSLUNIC1_H
    #include <hob-xslunic1.h>
#endif // HOB_XSLUNIC1_H

#ifndef _HOB_XSCLIB01_H
    #define _HOB_XSCLIB01_H
    #include <hob-xsclib01.h>
#endif //_HOB_XSCLIB01_H

/*+---------------------------------------------------------------------+*/
/*| local includes:                                                     |*/
/*+---------------------------------------------------------------------+*/
#include "hob-http-processor.h"

/*+---------------------------------------------------------------------+*/
/*| defines:                                                            |*/
/*+---------------------------------------------------------------------+*/
#ifdef _TEST
    #define PRIVATE extern
#else
    #define PRIVATE static
#endif

/*+---------------------------------------------------------------------+*/
/*| declarations and constants:                                         |*/
/*+---------------------------------------------------------------------+*/
typedef struct dsd_const_01 {
    char*     achc_string;
    int       inc_length;
} dsd_const_01;

/* http methods                         compare to enum ied_http_methods */
static const struct dsd_const_01 dss_http_methods[] = {
    { "GET",            3 }, { "HEAD",           4 },
    { "POST",           4 }, { "PUT",            3 },
    { "OPTIONS",        7 }, { "DELETE",         6 },
    { "TRACE",          5 }, { "CONNECT",        7 },

    /* WEBDAV methods */
    { "bdelete",        7 }, { "bmove",          5 },
    { "bproppatch",    10 }, { "copy",           4 },
    { "lock",           4 }, { "mkcol",          5 },
    { "move",           4 }, { "poll",           4 },
    { "propfind",       8 }, { "proppatch",      9 },
    { "subscribe",      9 }, { "search",         6 },
    { "bcopy",          5 }, { "bpropfind",      9 },
    { "notify",         6 }, { "unlock",         6 },
    { "unsubscribe",   11 }, { "x-ms-enumatts", 13 },
    { 0,                0 }
};

/* http header lines                  compare to enum ied_http_hdr_lines */
/*  please watch http://en.wikipedia.org/wiki/List_of_HTTP_headers       */
static const struct dsd_const_01 dss_http_hdr_lines[] = {
    { "Accept",                  6 }, { "Accept-Charset",         14 },
    { "Accept-Encoding",        15 }, { "Accept-Language",        15 },
    { "Accept-Ranges",          13 }, { "Age",                     3 },
    { "Allow",                   5 }, { "Authorization",          13 },
    { "Cache-Control",          13 }, { "Connection",             10 },
    { "Content-Disposition",    19 }, { "Content-Encoding",       16 },
    { "Content-Language",       16 }, { "Content-Length",         14 },
    { "Content-Location",       16 }, { "Content-MD5",            11 },
    { "Content-Range",          13 }, { "Content-Type",           12 },
    { "Cookie",                  6 }, { "Date",                    4 },
    { "ETag",                    4 }, { "Expect",                  6 },
    { "Expires",                 7 }, { "Host",                    4 },
    { "If-Match",                8 }, { "If-Modified-Since",      17 },
    { "If-None-Match",          13 }, { "If-Range",                8 },
    { "If-Unmodified-Since",    19 }, { "Last-Modified",          13 },
    { "Location",                8 }, { "Max-Forwards",           12 },
    { "Pragma",                  6 }, { "Proxy-Authenticate",     18 },
    { "Proxy-Authorization",    19 }, { "Range",                   5 },
    { "Referer",                 7 }, { "Retry-After",            11 },
    { "Server",                  6 }, { "Set-Cookie",             10 },
    { "TE",                      2 }, { "Trailer",                 7 },
    { "Transfer-Encoding",      17 }, { "Upgrade",                 7 },
    { "User-Agent",             10 }, { "Vary",                    4 },
    { "Via",                     3 }, { "Warn",                    4 },
    { "WWW-Authenticate",       16 },
    /* websocket header lines */
    { "Sec-WebSocket-Key1",     18 }, { "Sec-WebSocket-Key2",     18 },
    { "Sec-WebSocket-Key",      17 }, { "Sec-WebSocket-Origin",   20 },
    { "Sec-WebSocket-Protocol", 22 }, { "Sec-WebSocket-Version",  21 },
    { "Sec-WebSocket-Accept",   20 }, { "Sec-WebSocket-Nonce",    19 },
    { "Sec-WebSocket-Location", 22 }, { 0,                         0 }
};

/* http versions                       compare to enum ied_http_versions */
static const struct dsd_const_01 dss_http_versions[] = {
    { 0,          0 }, { 0,          0 }, { 0,          0 }, /* 0.0 - 0.2 */
    { 0,          0 }, { 0,          0 }, { 0,          0 }, /* 0.3 - 0.5 */   
    { 0,          0 }, { 0,          0 }, { 0,          0 }, /* 0.6 - 0.8 */
    { "HTTP/0.9", 8 }, { "HTTP/1.0", 8 }, { "HTTP/1.1", 8 }  /* 0.9 - 1.1 */
};

/* http status codes                     compare to enum ied_http_status */
/*  please watch http://en.wikipedia.org/wiki/List_of_HTTP_status_codes  */
static const char *achs_http_status[] = {
    ""                                  , ""                                , /*   0 -   1 */
    ""                                  , ""                                , /*   2 -   3 */
    ""                                  , ""                                , /*   4 -   5 */
    ""                                  , ""                                , /*   6 -   7 */
    ""                                  , ""                                , /*   8 -   9 */
    ""                                  , ""                                , /*  10 -  11 */
    ""                                  , ""                                , /*  12 -  13 */
    ""                                  , ""                                , /*  14 -  15 */
    ""                                  , ""                                , /*  16 -  17 */
    ""                                  , ""                                , /*  18 -  19 */
    ""                                  , ""                                , /*  20 -  21 */
    ""                                  , ""                                , /*  22 -  23 */
    ""                                  , ""                                , /*  24 -  25 */
    ""                                  , ""                                , /*  26 -  27 */
    ""                                  , ""                                , /*  28 -  29 */
    ""                                  , ""                                , /*  30 -  31 */
    ""                                  , ""                                , /*  32 -  33 */
    ""                                  , ""                                , /*  34 -  35 */
    ""                                  , ""                                , /*  36 -  37 */
    ""                                  , ""                                , /*  38 -  39 */
    ""                                  , ""                                , /*  40 -  41 */
    ""                                  , ""                                , /*  42 -  43 */
    ""                                  , ""                                , /*  44 -  45 */
    ""                                  , ""                                , /*  46 -  47 */
    ""                                  , ""                                , /*  48 -  49 */
    ""                                  , ""                                , /*  50 -  51 */
    ""                                  , ""                                , /*  52 -  53 */
    ""                                  , ""                                , /*  54 -  55 */
    ""                                  , ""                                , /*  56 -  57 */
    ""                                  , ""                                , /*  58 -  59 */
    ""                                  , ""                                , /*  60 -  61 */
    ""                                  , ""                                , /*  62 -  63 */
    ""                                  , ""                                , /*  64 -  65 */
    ""                                  , ""                                , /*  66 -  67 */
    ""                                  , ""                                , /*  68 -  69 */
    ""                                  , ""                                , /*  70 -  71 */
    ""                                  , ""                                , /*  72 -  73 */
    ""                                  , ""                                , /*  74 -  75 */
    ""                                  , ""                                , /*  76 -  77 */
    ""                                  , ""                                , /*  78 -  79 */
    ""                                  , ""                                , /*  80 -  81 */
    ""                                  , ""                                , /*  82 -  83 */
    ""                                  , ""                                , /*  84 -  85 */
    ""                                  , ""                                , /*  86 -  87 */
    ""                                  , ""                                , /*  88 -  89 */
    ""                                  , ""                                , /*  90 -  91 */
    ""                                  , ""                                , /*  92 -  93 */
    ""                                  , ""                                , /*  94 -  95 */
    ""                                  , ""                                , /*  96 -  97 */
    ""                                  , ""                                , /*  98 -  99 */
    /*
        1xx Informational
    */
    "Continue"                          , "Switching Protocols"             , /* 100 - 101 */
    "Processing"                        , ""                                , /* 102 - 103 */
    ""                                  , ""                                , /* 104 - 105 */
    ""                                  , ""                                , /* 106 - 107 */
    ""                                  , ""                                , /* 108 - 109 */
    ""                                  , ""                                , /* 110 - 111 */
    ""                                  , ""                                , /* 112 - 113 */
    ""                                  , ""                                , /* 114 - 115 */
    ""                                  , ""                                , /* 116 - 117 */
    ""                                  , ""                                , /* 118 - 119 */
    ""                                  , ""                                , /* 120 - 121 */
    "Request-URI too long"              , ""                                , /* 122 - 123 */
    ""                                  , ""                                , /* 124 - 125 */
    ""                                  , ""                                , /* 126 - 127 */
    ""                                  , ""                                , /* 128 - 129 */
    ""                                  , ""                                , /* 130 - 131 */
    ""                                  , ""                                , /* 132 - 133 */
    ""                                  , ""                                , /* 134 - 135 */
    ""                                  , ""                                , /* 136 - 137 */
    ""                                  , ""                                , /* 138 - 139 */
    ""                                  , ""                                , /* 140 - 141 */
    ""                                  , ""                                , /* 142 - 143 */
    ""                                  , ""                                , /* 144 - 145 */
    ""                                  , ""                                , /* 146 - 147 */
    ""                                  , ""                                , /* 148 - 149 */
    ""                                  , ""                                , /* 150 - 151 */
    ""                                  , ""                                , /* 152 - 153 */
    ""                                  , ""                                , /* 154 - 155 */
    ""                                  , ""                                , /* 156 - 157 */
    ""                                  , ""                                , /* 158 - 159 */
    ""                                  , ""                                , /* 160 - 161 */
    ""                                  , ""                                , /* 162 - 163 */
    ""                                  , ""                                , /* 164 - 165 */
    ""                                  , ""                                , /* 166 - 167 */
    ""                                  , ""                                , /* 168 - 169 */
    ""                                  , ""                                , /* 170 - 171 */
    ""                                  , ""                                , /* 172 - 173 */
    ""                                  , ""                                , /* 174 - 175 */
    ""                                  , ""                                , /* 176 - 177 */
    ""                                  , ""                                , /* 178 - 179 */
    ""                                  , ""                                , /* 180 - 181 */
    ""                                  , ""                                , /* 182 - 183 */
    ""                                  , ""                                , /* 184 - 185 */
    ""                                  , ""                                , /* 186 - 187 */
    ""                                  , ""                                , /* 188 - 189 */
    ""                                  , ""                                , /* 190 - 191 */
    ""                                  , ""                                , /* 192 - 193 */
    ""                                  , ""                                , /* 194 - 195 */
    ""                                  , ""                                , /* 196 - 197 */
    ""                                  , ""                                , /* 198 - 199 */
    /*
        2xx Success
    */
    "OK"                                , "Created"                         , /* 200 - 201 */
    "Accepted"                          , "Non-Authoritative Information"   , /* 202 - 203 */
    "No Content"                        ,"Reset Content"                    , /* 204 - 205 */
    "Partial Content"                   , "Multi-Status"                    , /* 206 - 207 */
    ""                                  , ""                                , /* 208 - 209 */
    ""                                  , ""                                , /* 210 - 211 */
    ""                                  , ""                                , /* 212 - 213 */
    ""                                  , ""                                , /* 214 - 215 */
    ""                                  , ""                                , /* 216 - 217 */
    ""                                  , ""                                , /* 218 - 219 */
    ""                                  , ""                                , /* 220 - 221 */
    ""                                  , ""                                , /* 222 - 223 */
    ""                                  , ""                                , /* 224 - 225 */
    ""                                  , ""                                , /* 226 - 227 */
    ""                                  , ""                                , /* 228 - 229 */
    ""                                  , ""                                , /* 230 - 231 */
    ""                                  , ""                                , /* 232 - 233 */
    ""                                  , ""                                , /* 234 - 235 */
    ""                                  , ""                                , /* 236 - 237 */
    ""                                  , ""                                , /* 238 - 239 */
    ""                                  , ""                                , /* 240 - 241 */
    ""                                  , ""                                , /* 242 - 243 */
    ""                                  , ""                                , /* 244 - 245 */
    ""                                  , ""                                , /* 246 - 247 */
    ""                                  , ""                                , /* 248 - 249 */
    ""                                  , ""                                , /* 250 - 251 */
    ""                                  , ""                                , /* 252 - 253 */
    ""                                  , ""                                , /* 254 - 255 */
    ""                                  , ""                                , /* 256 - 257 */
    ""                                  , ""                                , /* 258 - 259 */
    ""                                  , ""                                , /* 260 - 261 */
    ""                                  , ""                                , /* 262 - 263 */
    ""                                  , ""                                , /* 264 - 265 */
    ""                                  , ""                                , /* 266 - 267 */
    ""                                  , ""                                , /* 268 - 269 */
    ""                                  , ""                                , /* 270 - 271 */
    ""                                  , ""                                , /* 272 - 273 */
    ""                                  , ""                                , /* 274 - 275 */
    ""                                  , ""                                , /* 276 - 277 */
    ""                                  , ""                                , /* 278 - 279 */
    ""                                  , ""                                , /* 280 - 281 */
    ""                                  , ""                                , /* 282 - 283 */
    ""                                  , ""                                , /* 284 - 285 */
    ""                                  , ""                                , /* 286 - 287 */
    ""                                  , ""                                , /* 288 - 289 */
    ""                                  , ""                                , /* 290 - 291 */
    ""                                  , ""                                , /* 292 - 293 */
    ""                                  , ""                                , /* 294 - 295 */
    ""                                  , ""                                , /* 296 - 297 */
    ""                                  , ""                                , /* 298 - 299 */
    /*
        3xx Redirection
    */
    "Multiple Choices"                  , "Moved Permanently"               , /* 300 - 301 */
    "Found"                             , "See Other"                       , /* 302 - 303 */
    "Not Modified"                      , "Use Proxy"                       , /* 304 - 305 */
    "Switch Proxy"                      , "Temporary Redirect"              , /* 306 - 307 */
    ""                                  , ""                                , /* 308 - 309 */
    ""                                  , ""                                , /* 310 - 311 */
    ""                                  , ""                                , /* 312 - 313 */
    ""                                  , ""                                , /* 314 - 315 */
    ""                                  , ""                                , /* 316 - 317 */
    ""                                  , ""                                , /* 318 - 319 */
    ""                                  , ""                                , /* 320 - 321 */
    ""                                  , ""                                , /* 322 - 323 */
    ""                                  , ""                                , /* 324 - 325 */
    ""                                  , ""                                , /* 326 - 327 */
    ""                                  , ""                                , /* 328 - 329 */
    ""                                  , ""                                , /* 330 - 331 */
    ""                                  , ""                                , /* 332 - 333 */
    ""                                  , ""                                , /* 334 - 335 */
    ""                                  , ""                                , /* 336 - 337 */
    ""                                  , ""                                , /* 338 - 339 */
    ""                                  , ""                                , /* 340 - 341 */
    ""                                  , ""                                , /* 342 - 343 */
    ""                                  , ""                                , /* 344 - 345 */
    ""                                  , ""                                , /* 346 - 347 */
    ""                                  , ""                                , /* 348 - 349 */
    ""                                  , ""                                , /* 350 - 351 */
    ""                                  , ""                                , /* 352 - 353 */
    ""                                  , ""                                , /* 354 - 355 */
    ""                                  , ""                                , /* 356 - 357 */
    ""                                  , ""                                , /* 358 - 359 */
    ""                                  , ""                                , /* 360 - 361 */
    ""                                  , ""                                , /* 362 - 363 */
    ""                                  , ""                                , /* 364 - 365 */
    ""                                  , ""                                , /* 366 - 367 */
    ""                                  , ""                                , /* 368 - 369 */
    ""                                  , ""                                , /* 370 - 371 */
    ""                                  , ""                                , /* 372 - 373 */
    ""                                  , ""                                , /* 374 - 375 */
    ""                                  , ""                                , /* 376 - 377 */
    ""                                  , ""                                , /* 378 - 379 */
    ""                                  , ""                                , /* 380 - 381 */
    ""                                  , ""                                , /* 382 - 383 */
    ""                                  , ""                                , /* 384 - 385 */
    ""                                  , ""                                , /* 386 - 387 */
    ""                                  , ""                                , /* 388 - 389 */
    ""                                  , ""                                , /* 390 - 391 */
    ""                                  , ""                                , /* 392 - 393 */
    ""                                  , ""                                , /* 394 - 395 */
    ""                                  , ""                                , /* 396 - 397 */
    ""                                  , ""                                , /* 398 - 399 */
    /*
        4xx Client Error
    */
    "Bad Request"                       , "Unauthorized"                    , /* 400 - 401 */
    "Payment Required"                  , "Forbidden"                       , /* 402 - 403 */
    "Not Found"                         , "Method Not Allowed"              , /* 404 - 405 */
    "Not Acceptable"                    , "Proxy Authentication Required"   , /* 406 - 407 */
    "Request Timeout"                   , "Conflict"                        , /* 408 - 409 */
    "Gone"                              , "Length Required"                 , /* 410 - 411 */
    "Precondition Failed"               , "Request Entity Too Large"        , /* 412 - 413 */
    "Request-URI Too Long"              , "Unsupported Media Type"          , /* 414 - 415 */
    "Requested Range Not Satisfiable"   , "Expectation Failed"              , /* 416 - 417 */
    "I'm a teapot"                      , ""                                , /* 418 - 419 */
    ""                                  , ""                                , /* 420 - 421 */
    "Unprocessable Entity"              , "Locked"                          , /* 422 - 423 */
    "Failed Dependency"                 , "Unordered Collection"            , /* 424 - 425 */
    "Upgrade Required"                  , ""                                , /* 426 - 427 */
    ""                                  , ""                                , /* 428 - 429 */
    ""                                  , ""                                , /* 430 - 431 */
    ""                                  , ""                                , /* 432 - 433 */
    ""                                  , ""                                , /* 434 - 435 */
    ""                                  , ""                                , /* 436 - 437 */
    ""                                  , ""                                , /* 438 - 439 */
    ""                                  , ""                                , /* 440 - 441 */
    ""                                  , ""                                , /* 442 - 443 */
    ""                                  , ""                                , /* 444 - 445 */
    ""                                  , ""                                , /* 446 - 447 */
    ""                                  , "Retry With"                      , /* 448 - 449 */
    "Blocked"                           , ""                                , /* 450 - 451 */
    ""                                  , ""                                , /* 452 - 453 */
    ""                                  , ""                                , /* 454 - 455 */
    ""                                  , ""                                , /* 456 - 457 */
    ""                                  , ""                                , /* 458 - 459 */
    ""                                  , ""                                , /* 460 - 461 */
    ""                                  , ""                                , /* 462 - 463 */
    ""                                  , ""                                , /* 464 - 465 */
    ""                                  , ""                                , /* 466 - 467 */
    ""                                  , ""                                , /* 468 - 469 */
    ""                                  , ""                                , /* 470 - 471 */
    ""                                  , ""                                , /* 472 - 473 */
    ""                                  , ""                                , /* 474 - 475 */
    ""                                  , ""                                , /* 476 - 477 */
    ""                                  , ""                                , /* 478 - 479 */
    ""                                  , ""                                , /* 480 - 481 */
    ""                                  , ""                                , /* 482 - 483 */
    ""                                  , ""                                , /* 484 - 485 */
    ""                                  , ""                                , /* 486 - 487 */
    ""                                  , ""                                , /* 488 - 489 */
    ""                                  , ""                                , /* 490 - 491 */
    ""                                  , ""                                , /* 492 - 493 */
    ""                                  , ""                                , /* 493 - 495 */
    ""                                  , ""                                , /* 496 - 497 */
    ""                                  , ""                                , /* 498 - 499 */
    /*
        5xx Server Error
    */
    "Internal Server Error"             , "Not Implemented"                 , /* 500 - 501 */
    "Bad Gateway"                       , "Service Unavailable"             , /* 502 - 503 */
    "Gateway Timeout"                   , "HTTP Version Not Supported"      , /* 504 - 505 */
    "Variant Also Negotiates"           , "Insufficient Storage"            , /* 506 - 507 */
    ""                                  , "Bandwidth Limit Exceeded"        , /* 508 - 509 */
    "Not Extended"                      , ""                                , /* 510 - 511 */
    ""                                  , ""                                , /* 512 - 513 */
    ""                                  , ""                                , /* 514 - 515 */
    ""                                  , ""                                , /* 516 - 517 */
    ""                                  , ""                                , /* 518 - 519 */
    ""                                  , ""                                , /* 520 - 521 */
    ""                                  , ""                                , /* 522 - 523 */
    ""                                  , ""                                , /* 524 - 525 */
    ""                                  , ""                                , /* 526 - 527 */
    ""                                  , ""                                , /* 528 - 529 */
    ""                                  , ""                                , /* 530 - 531 */
    ""                                  , ""                                , /* 532 - 533 */
    ""                                  , ""                                , /* 534 - 535 */
    ""                                  , ""                                , /* 536 - 537 */
    ""                                  , ""                                , /* 538 - 539 */
    ""                                  , ""                                , /* 540 - 541 */
    ""                                  , ""                                , /* 542 - 543 */
    ""                                  , ""                                , /* 544 - 545 */
    ""                                  , ""                                , /* 546 - 547 */
    ""                                  , ""                                , /* 548 - 549 */
    ""                                  , ""                                , /* 550 - 551 */
    ""                                  , ""                                , /* 552 - 553 */
    ""                                  , ""                                , /* 554 - 555 */
    ""                                  , ""                                , /* 556 - 557 */
    ""                                  , ""                                , /* 558 - 559 */
    ""                                  , ""                                , /* 560 - 561 */
    ""                                  , ""                                , /* 562 - 563 */
    ""                                  , ""                                , /* 564 - 565 */
    ""                                  , ""                                , /* 566 - 567 */
    ""                                  , ""                                , /* 568 - 569 */
    ""                                  , ""                                , /* 570 - 571 */
    ""                                  , ""                                , /* 572 - 573 */
    ""                                  , ""                                , /* 574 - 575 */
    ""                                  , ""                                , /* 576 - 577 */
    ""                                  , ""                                , /* 578 - 579 */
    ""                                  , ""                                , /* 580 - 581 */
    ""                                  , ""                                , /* 582 - 583 */
    ""                                  , ""                                , /* 584 - 585 */
    ""                                  , ""                                , /* 586 - 587 */
    ""                                  , ""                                , /* 588 - 589 */
    ""                                  , ""                                , /* 590 - 591 */
    ""                                  , ""                                , /* 592 - 593 */
    ""                                  , ""                                , /* 594 - 595 */
    ""                                  , ""                                , /* 596 - 597 */
    ""                                  , ""                                , /* 598 - 599 */
    ""                                  , ""                                , /* 600 - 601 */
    0
};

/*+---------------------------------------------------------------------+*/
/*| delimiter tables:                                                   |*/
/*+---------------------------------------------------------------------+*/
static const char chrs_delimiter[256] = {
    0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0,    /*   0 -  15 */
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,    /*  16 -  31 */
    1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,    /*  32 -  47 */
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0,    /*  48 -  63 */
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,    /*  64 -  79 */
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,    /*  80 -  95 */
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,    /*  96 - 111 */
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,    /* 112 - 127 */
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,    /* 128 - 143 */
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,    /* 144 - 159 */
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,    /* 160 - 175 */
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,    /* 176 - 191 */
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,    /* 192 - 207 */
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,    /* 208 - 223 */
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,    /* 224 - 239 */
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,    /* 240 - 255 */
};

static const char chrs_whitespace[256] = {
    0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0,    /*   0 -  15 */
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,    /*  16 -  31 */
    1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,    /*  32 -  47 */
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,    /*  48 -  63 */
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,    /*  64 -  79 */
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,    /*  80 -  95 */
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,    /*  96 - 111 */
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,    /* 112 - 127 */
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,    /* 128 - 143 */
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,    /* 144 - 159 */
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,    /* 160 - 175 */
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,    /* 176 - 191 */
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,    /* 192 - 207 */
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,    /* 208 - 223 */
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,    /* 224 - 239 */
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,    /* 240 - 255 */
};

/*+---------------------------------------------------------------------+*/
/*| length information:                                                 |*/
/*+---------------------------------------------------------------------+*/
#define DEF_KW_CHUNKED "chunked"
#define DEF_KW_CLOSE   "close"

enum ied_length_info {
    ied_not_set     = 0,                /* not set length info           */
    ied_content_len,                    /* content length                */
    ied_chunked,                        /* chunked                       */
    ied_until_close                     /* data until close connection   */
};

/*+---------------------------------------------------------------------+*/
/*| websocket stuff:                                                    |*/
/*+---------------------------------------------------------------------+*/
#define DEF_KW_WEBSOCKET "websocket"
#define DEF_KW_UPGRADE   "upgrade"

/*+---------------------------------------------------------------------+*/
/*| url stuff:                                                          |*/
/*+---------------------------------------------------------------------+*/
static const struct dsd_const_01 dss_url_protos[] = {
    { "http://",  7 }, { "https://", 8 },
    { "ws://",    5 }, { "wss://",   6 },
    { 0,          0 }
};

/*+---------------------------------------------------------------------+*/
/*| main structures:                                                    |*/
/*+---------------------------------------------------------------------+*/
typedef struct dsd_http_parser {
    BOOL (*amc_parser) ( struct dsd_http_parser*, struct dsd_gather_i_1* );
    struct dsd_http_header     dsc_header;      // header structure
    struct dsd_http_trailer    dsc_trailer;     // http trailer
    struct dsd_http_parser_cbs *adsc_cbs;       // callback functions
    char                       *achc_header;    // header data
    size_t                     uinc_hdr_len;    // length of header
    size_t                     uinc_hdr_pos;    // current position in header
    size_t                     uinc_max_lines;  // max number of header lines
    char                       *achc_inc_line;  // marker for incomplete line
    BOOL                       boc_check_folded;// check for folded lines
    enum ied_length_info       ienc_len_info;   // length information type
    unsigned long long         uilc_length;     // current working length
    char                       chc_chunked[20]; // buffer for building chunked length
    size_t                     uinc_chk_off;    // offset in chc_chunked
    char                       *achc_url;       // url memory
    size_t                     uinc_max_url;    // max length url
    BOOL                       boc_websocket;   // websocket
} dsd_http_parser;

typedef struct dsd_http_creator {
    struct dsd_http_creator_cbs *adsc_cbs;      // callback functions
    char                        *achc_line;     // line buffer
    enum ied_length_info        ienc_len_info;  // length information type
    unsigned long long          uilc_length;    // current working length
    size_t                      uinc_line_max;  // total length of line buffer
} dsd_http_creator;

/*+---------------------------------------------------------------------+*/
/*| function declarations:                                              |*/
/*+---------------------------------------------------------------------+*/
PRIVATE BOOL m_ignore_eol      ( struct dsd_http_parser *adsp_http,
                                 struct dsd_gather_i_1  *adsp_data );
PRIVATE BOOL m_parse_first_line( struct dsd_http_parser *adsp_http,
                                 struct dsd_gather_i_1  *adsp_data );
PRIVATE BOOL m_parse_line      ( struct dsd_http_parser *adsp_http,
                                 struct dsd_gather_i_1  *adsp_data );
PRIVATE BOOL m_parse_trailer   ( struct dsd_http_parser *adsp_http,
                                 struct dsd_gather_i_1  *adsp_data );
PRIVATE BOOL m_pass_length     ( struct dsd_http_parser *adsp_http,
                                 struct dsd_gather_i_1  *adsp_data );
PRIVATE BOOL m_pass_chunked    ( struct dsd_http_parser *adsp_http,
                                 struct dsd_gather_i_1  *adsp_data );
PRIVATE BOOL m_pass_all        ( struct dsd_http_parser *adsp_http,
                                 struct dsd_gather_i_1  *adsp_data );
PRIVATE BOOL m_ws_handshake    ( struct dsd_http_parser *adsp_http,
                                 struct dsd_gather_i_1  *adsp_data );

PRIVATE void m_init_parser( struct dsd_http_parser     *adsp_http,
                            struct dsd_http_parser_cbs *adsp_cbs,
                            size_t uinp_max_hdr_len,
                            size_t uinp_max_hdr_lines,
                            size_t uinp_max_len_url );
PRIVATE void m_init_creator( struct dsd_http_creator     *adsp_http,
                             struct dsd_http_creator_cbs *adsp_cbs,
                             size_t uinp_max_line_len );

PRIVATE long long m_atoll( const char *achp_ptr, int inp_length,
                            char **aachp_endptr,  int inp_base   );
PRIVATE int m_fbuffer    ( char *achp_buffer, size_t uinp_length,
                           const char *achp_format, ...           );
/*+---------------------------------------------------------------------+*/
/*| public functions:                                                   |*/
/*+---------------------------------------------------------------------+*/

/**
 * public function m_new_http_parser
 *   create a new http parse instance
 *
 * @param[in]   dsd_http_parser_cbs *adsp_cbs           parser callbacks
 * @param[in]   size_t              uinp_max_hdr_len    max header length
 * @param[in]   size_t              uinp_max_lines      max number of header lines
 * @param[in]   size_t              uinp_max_url_len    max length of req url
 * @return      void*                                   parser handle
 *                                                      NULL in error cases
*/
extern void* m_new_http_parser( struct dsd_http_parser_cbs *adsp_cbs,
                                size_t uinp_max_hdr_len,
                                size_t uinp_max_lines,
                                size_t uinp_max_url_len               )
{
    // initialize some variables:
    dsd_http_parser *adsl_parser;

    // allocate memory:
    if (    adsp_cbs
         && adsp_cbs->amc_alloc ) {
        adsl_parser = (dsd_http_parser*)adsp_cbs->amc_alloc(
                                                adsp_cbs->avc_usrfld,
                                                sizeof(dsd_http_parser)
                                                +   uinp_max_lines
                                                  * sizeof(dsd_http_hdr_line)
                                                + uinp_max_hdr_len
                                                + uinp_max_url_len      );
    } else {
        adsl_parser = (dsd_http_parser*)malloc(   sizeof(dsd_http_parser)
                                                +   uinp_max_lines
                                                  * sizeof(dsd_http_hdr_line)
                                                + uinp_max_hdr_len
                                                + uinp_max_url_len        );
    }
    if ( adsl_parser == NULL ) {
        return NULL;
    }

    m_init_parser( adsl_parser, adsp_cbs, uinp_max_hdr_len,
                   uinp_max_lines, uinp_max_url_len );
    return (void*)adsl_parser;
} // end of m_new_http_parser


/**
 * public function m_parse_http
 *   process given data through http parser
 *
 * @param[in]   void            *avp_parser     parser handle
 * @param[in]   dsd_gather_i_1  *adsp_data      data to be parsed
 * @return      BOOL
*/
extern BOOL m_parse_http( void *avp_parser, 
                          struct dsd_gather_i_1 *adsp_data )
{
    dsd_http_parser* adsl_parser;

    // check input data:
    if ( avp_parser == NULL ) {
        return FALSE;
    }
    adsl_parser = (dsd_http_parser*)avp_parser;

    while (    adsp_data                != NULL
            && adsp_data->achc_ginp_cur >= adsp_data->achc_ginp_end ) {
        adsp_data = adsp_data->adsc_next;
    }
    if ( adsp_data == NULL ) {
        if ( adsl_parser->amc_parser == &m_pass_all ) {
            /*
                calling with NULL pointer means end of connection
                  -> call data block function empty to signal end
                     of data
            */
            if (    adsl_parser->adsc_cbs
                 && adsl_parser->adsc_cbs->amc_data_block ) {
                return adsl_parser->adsc_cbs->amc_data_block( 
                                    adsl_parser->adsc_cbs->avc_usrfld,
                                    &adsl_parser->dsc_header, NULL );
            }
        }
        return FALSE;
    }

    return adsl_parser->amc_parser( adsl_parser, adsp_data );
} // end of BOOL m_parse_http


/**
 * public function m_del_http_parser
 *   delete http parser
 *
 * @param[in]   void            *avp_parser     parser handle
*/
extern void m_del_http_parser( void **aavp_parser )
{
    dsd_http_parser* adsl_parser;

    // check input data:
    if ( *aavp_parser == NULL ) {
        return;
    }
    adsl_parser = (dsd_http_parser*)(*aavp_parser);

    if (    adsl_parser->adsc_cbs
         && adsl_parser->adsc_cbs->amc_free ) {
        adsl_parser->adsc_cbs->amc_free( adsl_parser->adsc_cbs->avc_usrfld,
                                         *aavp_parser );
    } else {
        free( *aavp_parser );
    }
    *aavp_parser = NULL;
} // end of m_del_http_parser


/**
 * public function m_search_hdr_line
 *   search for header line with given key
 *
 * @param[in]       dsd_http_header     *adsp_header    http header structure
 * @param[in]       ied_http_hdr_lines  ienp_line       line type
 * @param[in/out]   size_t              *auin_offset    in:  start at line number
 *                                                      out: found at line number
 * @return          dsd_http_hdr_line*                  found header line
 *                                                      or NULL if not found
*/
extern struct dsd_http_hdr_line* m_search_hdr_line( struct dsd_http_header *adsp_header,
                                                    enum ied_http_hdr_lines ienp_line,
                                                    size_t *auin_offset )
{
    // initialize some variables:
    struct dsd_http_hdr_line *adsl_line;    // current line
    size_t                   uinl_line;     // current line number

    uinl_line = auin_offset?(*auin_offset):0;
    for ( ; uinl_line < adsp_header->uinc_lines; uinl_line++ ) {
        adsl_line = &adsp_header->adsc_lines[uinl_line];
        if ( adsl_line->ienc_type == ienp_line ) {
            if ( auin_offset ) {
                *auin_offset = uinl_line;
            }
            return adsl_line;
        }
    }
    return NULL;
} // end of m_search_hdr_line


/**
 * public function m_new_http_creator
 *   create a new http creator instance
 *
 * @param[in]   dsd_http_creator_cbs *adsp_cbs          creator callbacks
 * @param[in]   size_t               uinp_max_line_len  max header line length
 * @return      void*                                   creator handle
 *                                                      NULL in error cases
*/
extern void* m_new_http_creator( struct dsd_http_creator_cbs *adsp_cbs,
                                 size_t uinp_max_line_len )
{
    // initialize some variables:
    struct dsd_http_creator *adsl_creator;

    // allocate memory:
    if (    adsp_cbs
         && adsp_cbs->amc_alloc ) {
        adsl_creator = (dsd_http_creator*)adsp_cbs->amc_alloc(
                                                  adsp_cbs->avc_usrfld,
                                                     sizeof(dsd_http_creator)
                                                  + uinp_max_line_len );
    } else {
        adsl_creator = (dsd_http_creator*)malloc(   sizeof(dsd_http_creator)
                                                  + uinp_max_line_len );
    }
    if ( adsl_creator == NULL ) {
        return NULL;
    }

    m_init_creator( adsl_creator, adsp_cbs, uinp_max_line_len );
    return (void*)adsl_creator;
} // end of m_new_http_creator


/**
 * public function m_create_request
 *   create new request header
 *
 * @param[in]   void                *avp_creator    creator handle
 * @param[in]   ied_http_methods    ienp_method     request method
 * @param[in]   const char          *achp_url       requested url
 * @param[in]   int                 inp_url_len     length of url
 * @param[in]   ied_http_versions   ienp_version    HTTP version
 * return       BOOL
*/
extern BOOL m_create_request( void *avp_creator,
                              enum ied_http_methods  ienp_method,
                              const char             *achp_url,
                              int                    inp_url_len,
                              enum ied_http_versions ienp_version )
{
    // initialize some variables:
    struct dsd_http_creator *adsl_http;
    int                     inl_ret;

    if (    avp_creator == NULL
         || ienp_method  < 1
         || achp_url    == NULL
         || inp_url_len  < 1
         || ienp_version < 9 ) {
        return FALSE;
    }
    adsl_http = (struct dsd_http_creator*)avp_creator;

    inl_ret = m_fbuffer( adsl_http->achc_line, adsl_http->uinc_line_max,
                         "%s %.*s %s\r\n",
                         dss_http_methods[ienp_method].achc_string,
                         inp_url_len, achp_url,
                         dss_http_versions[ienp_version].achc_string );
    if ( inl_ret == -1 ) {
        return FALSE;
    }
    if (    adsl_http->adsc_cbs
         && adsl_http->adsc_cbs->amc_out ) {
        return adsl_http->adsc_cbs->amc_out( adsl_http->adsc_cbs->avc_usrfld,
                                             adsl_http->achc_line, (size_t) inl_ret );
    }
    return FALSE;
} // end of m_create_request


/**
 * public function m_create_response
 *   create new response header
 *
 * @param[in]   void                *avp_creator    creator handle
 * @param[in]   ied_http_versions   ienp_version    HTTP version
 * @param[in]   ied_http_status     ienp_status     status code
 * @return      BOOL
*/
extern BOOL m_create_response( void *avp_creator,
                               enum ied_http_versions ienp_version,
                               enum ied_http_status   ienp_status   )
{
    // initialize some variables:
    struct dsd_http_creator *adsl_http;
    int                     inl_ret;

    if (    avp_creator  == NULL
         || ienp_version  < 9    ) {
        return FALSE;
    }
    adsl_http = (struct dsd_http_creator*)avp_creator;

    inl_ret = m_fbuffer( adsl_http->achc_line, adsl_http->uinc_line_max,
                         "%s %d %s\r\n",
                         dss_http_versions[ienp_version].achc_string,
                         ienp_status, achs_http_status[ienp_status] );
    if ( inl_ret == -1 ) {
        return FALSE;
    }
    if (    adsl_http->adsc_cbs
         && adsl_http->adsc_cbs->amc_out ) {
        return adsl_http->adsc_cbs->amc_out( adsl_http->adsc_cbs->avc_usrfld,
                                             adsl_http->achc_line, (size_t) inl_ret );
    }
    return FALSE;
} // end of m_create_response


/**
 * public function m_create_line_f
 *   create string header line and add it to output
 *
 * @param[in]   void                *avp_creator    creator handle
 * @param[in]   ied_http_hdr_lines  ienp_line       line type
 * @param[in]   const char          *achp_format    format
 * @param[in]   ...
 * @return      BOOL
*/
extern BOOL m_create_line_f( void *avp_creator,
                             enum ied_http_hdr_lines ienp_line,
                             const char *achp_format, ... )
{
    struct dsd_http_creator *adsl_http;
    int                     inl_out1;
    int                     inl_out2;
    int                     inl_out3;
    va_list                 dsl_args;

    if (    avp_creator == NULL
         || ienp_line    < 1    ) {
        return FALSE;
    }
    adsl_http = (struct dsd_http_creator*)avp_creator;

    inl_out1 = m_fbuffer( adsl_http->achc_line, adsl_http->uinc_line_max,
                          "%s: ", 
                          dss_http_hdr_lines[ienp_line].achc_string );
    if ( inl_out1 < 0 ) {
        return FALSE;
    }

    va_start( dsl_args, achp_format );
    inl_out2 = vsnprintf( &adsl_http->achc_line[inl_out1],
                          adsl_http->uinc_line_max - inl_out1,
                          achp_format, dsl_args );
    va_end( dsl_args );
    if (    inl_out2 < 0
         || inl_out2 > adsl_http->uinc_line_max - inl_out1 ) {
        return FALSE;
    }

    inl_out3 = m_fbuffer( &adsl_http->achc_line[inl_out1 + inl_out2],
                          adsl_http->uinc_line_max - inl_out1 - inl_out2,
                          "\r\n" );
    if ( inl_out3 == -1 ) {
        return FALSE;
    }

    if (    adsl_http->adsc_cbs
         && adsl_http->adsc_cbs->amc_out ) {
        return adsl_http->adsc_cbs->amc_out( adsl_http->adsc_cbs->avc_usrfld,
                                             adsl_http->achc_line,
                                             (size_t)(   inl_out1
                                                       + inl_out2
                                                       + inl_out3 ) );
    }
    return FALSE;
} /* end of m_create_line_f */


/**
 * public function m_create_line_s
 *   create string header line and add it to output
 *
 * @param[in]   void                *avp_creator    creator handle
 * @param[in]   ied_http_hdr_lines  ienp_line       line type
 * @param[in]   const char          *achp_value     line value
 * @param[in]   int                 inp_length      length of value
 * @return      BOOL
*/
extern BOOL m_create_line_s( void *avp_creator,
                             enum ied_http_hdr_lines ienp_line,
                             const char *achp_value, int inp_length )
{
    // initialize some variables:
    struct dsd_http_creator *adsl_http;
    int                     inl_ret;

    if (    avp_creator == NULL
         || ienp_line    < 1    ) {
        return FALSE;
    }
    adsl_http = (struct dsd_http_creator*)avp_creator;

    inl_ret = m_fbuffer( adsl_http->achc_line, adsl_http->uinc_line_max,
                         "%s: %.*s\r\n",
                         dss_http_hdr_lines[ienp_line].achc_string,
                         inp_length, achp_value );
    if ( inl_ret == -1 ) {
        return FALSE;
    }
    if (    adsl_http->adsc_cbs
         && adsl_http->adsc_cbs->amc_out ) {
        return adsl_http->adsc_cbs->amc_out( adsl_http->adsc_cbs->avc_usrfld,
                                             adsl_http->achc_line, (size_t) inl_ret );
    }
    return FALSE;
} // end of m_create_line_s


/**
 * public function m_create_line_szt
 *   create string header line and add it to output
 *
 * @param[in]   void                *avp_creator    creator handle
 * @param[in]   ied_http_hdr_lines  ienp_line       line type
 * @param[in]   const char          *achp_value     line value zero terminated
 * @return      BOOL
*/
extern BOOL m_create_line_szt( void *avp_creator,
                               enum ied_http_hdr_lines ienp_line,
                               const char *achp_value             )
{
    // initialize some variables:
    struct dsd_http_creator *adsl_http;
    int                     inl_ret;

    if (    avp_creator == NULL
         || ienp_line    < 1    ) {
        return FALSE;
    }
    adsl_http = (struct dsd_http_creator*)avp_creator;

    inl_ret = m_fbuffer( adsl_http->achc_line, adsl_http->uinc_line_max,
                         "%s: %s\r\n",
                         dss_http_hdr_lines[ienp_line].achc_string,
                         achp_value );
    if ( inl_ret == -1 ) {
        return FALSE;
    }
    if (    adsl_http->adsc_cbs
         && adsl_http->adsc_cbs->amc_out ) {
        return adsl_http->adsc_cbs->amc_out( adsl_http->adsc_cbs->avc_usrfld,
                                             adsl_http->achc_line, (size_t) inl_ret );
    }
    return FALSE;
} // end of m_create_line_s


/**
 * public function m_create_line_n
 *   create numeric header line and add it to output
 *
 * @param[in]   void                *avp_creator    creator handle
 * @param[in]   ied_http_hdr_lines  ienp_line       line type
 * @param[in]   int                 inp_value       line value
 * @return      BOOL
*/
extern BOOL m_create_line_n( void *avp_creator,
                             enum ied_http_hdr_lines ienp_line,
                             int inp_value )
{
    // initialize some variables:
    struct dsd_http_creator *adsl_http;
    int                     inl_ret;

    if (    avp_creator == NULL
         || ienp_line    < 1    ) {
        return FALSE;
    }
    adsl_http = (struct dsd_http_creator*)avp_creator;

    inl_ret = m_fbuffer( adsl_http->achc_line, adsl_http->uinc_line_max,
                         "%s: %d\r\n",
                         dss_http_hdr_lines[ienp_line].achc_string,
                         inp_value );
    if ( inl_ret == -1 ) {
        return FALSE;
    }
    if (    adsl_http->adsc_cbs
         && adsl_http->adsc_cbs->amc_out ) {
        return adsl_http->adsc_cbs->amc_out( adsl_http->adsc_cbs->avc_usrfld,
                                             adsl_http->achc_line, (size_t) inl_ret );
    }
    return FALSE;
} // end of m_create_line_n


/**
 * public function m_finish_header
 *   end http header
 *
 * @param[in]   void                *avp_creator    creator handle
 * @return      BOOL
*/
extern BOOL m_finish_header( void *avp_creator )
{
    // initialize some variables:
    struct dsd_http_creator *adsl_http;
    int                     inl_ret;

    if ( avp_creator == NULL ) {
        return FALSE;
    }
    adsl_http = (struct dsd_http_creator*)avp_creator;

    inl_ret = m_fbuffer( adsl_http->achc_line, adsl_http->uinc_line_max, "\r\n" );
    if ( inl_ret == -1 ) {
        return FALSE;
    }
    if (    adsl_http->adsc_cbs
         && adsl_http->adsc_cbs->amc_out ) {
        return adsl_http->adsc_cbs->amc_out( adsl_http->adsc_cbs->avc_usrfld,
                                             adsl_http->achc_line, (size_t) inl_ret );
    }
    return FALSE;
} // end of m_finish_header


/**
 * public function m_del_http_creator
 *   delete http creator
 *
 * @param[in]   void            **aavp_creator    creator handle
*/
extern void m_del_http_creator( void **aavp_creator )
{
    struct dsd_http_creator *adsl_creator;

    // check input data:
    if ( *aavp_creator == NULL ) {
        return;
    }
    adsl_creator = (dsd_http_creator*)(*aavp_creator);

    if (    adsl_creator->adsc_cbs
         && adsl_creator->adsc_cbs->amc_free ) {
        adsl_creator->adsc_cbs->amc_free( adsl_creator->adsc_cbs->avc_usrfld,
                                          *aavp_creator );
    } else {
        free( *aavp_creator );
    }
    *aavp_creator = NULL;
} // end of m_del_http_creator

/*+---------------------------------------------------------------------+*/
/*| private functions:                                                  |*/
/*+---------------------------------------------------------------------+*/

/**
 * private function m_get_protocol
 *   get protocol from given url
 *
 * @param[in]   const char      *achp_url   pointer to url
 * @param[in]   int             inp_len     length of given url
 * @return      ied_url_protos              protocol type
*/
PRIVATE enum ied_url_protos m_get_protocol( const char* achp_url, int inp_len )
{
    // initialize some variables:
    BOOL bol_ret;
    int  inl_result;
    int  inl_proto = 0;

#define INL_LENGTH dss_url_protos[inl_proto].inc_length
    while ( dss_url_protos[inl_proto].achc_string != NULL ) {
        if ( inp_len > INL_LENGTH ) {
            bol_ret = m_cmpi_vx_vx( &inl_result,
                                    (void*)achp_url, INL_LENGTH, ied_chs_utf_8,
                                    (void*)dss_url_protos[inl_proto].achc_string,
                                    INL_LENGTH, ied_chs_utf_8 );
            if (    bol_ret    == TRUE
                 && inl_result == 0    ) {
                return (enum ied_url_protos)inl_proto;
            }
        }
        inl_proto++;
    }
#undef INL_LENGTH

    return ied_proto_not_supported;
} // end of m_get_protocol


/**
 * private function m_get_realpath
 *   remove "../" stuff out of the path
 *
 * @param[in]   const char  *achp_in        pointer to input path
 * @param[in]   int         inp_in          length of input path
 * @param[out]  char        *achp_out       pointer to output
 * @param[in]   int         inp_out         max length output
 * @return      int                         output length
 *                                          -1 in error cases
 *                                           0 output buffer to small
*/
PRIVATE int m_get_realpath( const char *achp_in,  int inp_in,
                            char       *achp_out, int inp_out )
{
    // initialize some variables:
    char *achl_cur;                         // current working pointer
    char *achl_end;                         // end of data
    char *achl_folder;                      // folder in path
    int  inl_flength;                       // length folder
    int  inl_olength;                       // output length
    int  inl_needed;                        // needed length in output


    achl_cur    = (char*)achp_in;
    achl_end    = (char*)&achp_in[inp_in];
    inl_olength = 0;


    while ( achl_cur < achl_end ) {
        /*
            search for a folder
              -> ends with "/"
        */
        achl_folder = achl_cur;
        inl_flength = 0;
        while (    achl_cur < achl_end
#if defined WIN32 || defined WIN64
                && *achl_cur != '\\'
#endif
                && *achl_cur != '/'  ) {
            achl_cur++;
            inl_flength++;
        }

        /*
            now we have a folder found
        */
        if (    inl_flength  == 1
             && *achl_folder == '.' ) {
            /*
                just a "." folder
                  -> nothing todo
            */
        } else if (    inl_flength    == 2
                    && achl_folder[0] == '.'
                    && achl_folder[1] == '.' ) {
            /*
                "../" folder
                   -> if possible go one folder up
                   -> if not stop - error
            */
            if ( inl_olength < 2 ) {
                return -1;
            }
            inl_olength--;
            while (    inl_olength > 1
                    && achp_out[inl_olength - 1] != '/' ) {
                inl_olength--;
            }
            if (    inl_olength == 1
                 && achp_out[0] != '/' ) {
                inl_olength--;
            }
        } else {
            /*
                normal folder
                   -> add it to output buffer
                   -> add '/' sign
            */
            if ( inl_flength > 0 ) {
                inl_needed = m_cpy_vx_vx( &achp_out[inl_olength],
                                          inp_out - inl_olength, ied_chs_utf_8,
                                          achl_folder, inl_flength, ied_chs_uri_1 );
                if ( inl_needed < 0 ) {
                    return 0;
                }
                inl_olength += inl_needed;
            }
#if defined WIN32 || defined WIN64
            if (    *achl_cur == '/'
                 || *achl_cur == '\\' ) {
#else
            if ( *achl_cur == '/' ) {
#endif
                if ( inp_out - inl_olength < 1 ) {
                    return 0;
                }
                achp_out[inl_olength] = '/';
                inl_olength++;
            }
        }

        if ( achl_cur < achl_end ) {
            achl_cur++;
        }
    }
    return inl_olength;
} // end of m_get_realpath


/**
 * private function m_init_parser
 *   initialize our http parser
 *
 * @param[in]   dsd_http_parser *adsp_http              http parser handle
 * @param[in]   dsd_http_parser_cbs *adsp_cbs           parser callbacks
 * @param[in]   size_t          uinp_max_hdr_len        max length of header
 * @param[in]   size_t          uinp_max_hdr_lines      max number of hdr lines
 * @param[in]   size_t          uinp_max_len_url        max length 
*/
PRIVATE void m_init_parser( struct dsd_http_parser     *adsp_http,
                            struct dsd_http_parser_cbs *adsp_cbs,
                            size_t uinp_max_hdr_len,
                            size_t uinp_max_hdr_lines,
                            size_t uinp_max_len_url                )
{
    memset( adsp_http, 0, sizeof(dsd_http_parser) );
    adsp_http->amc_parser            = &m_ignore_eol;
    adsp_http->adsc_cbs              = adsp_cbs;
    adsp_http->uinc_max_lines        = uinp_max_hdr_lines;
    adsp_http->dsc_header.adsc_lines = (dsd_http_hdr_line*)(adsp_http + 1);
    adsp_http->achc_header           = (char*)(   adsp_http->dsc_header.adsc_lines
                                                + uinp_max_hdr_lines               );
    adsp_http->uinc_hdr_len          = uinp_max_hdr_len;
    adsp_http->achc_url              = (char*)(   adsp_http->achc_header
                                                + uinp_max_hdr_len       );
    adsp_http->uinc_max_url          = uinp_max_len_url;
} // end of m_init_parser


/**
 * private function m_init_creator
 *   initialize our http creator
 *
 * @param[in]   dsd_http_creator     *adsp_http         http creator handle
 * @param[in]   dsd_http_creator_cbs *adsp_cbs          creator callbacks
 * @param[in]   size_t               uinp_max_line_len  max length of header line
*/
PRIVATE void m_init_creator( struct dsd_http_creator     *adsp_http,
                             struct dsd_http_creator_cbs *adsp_cbs,
                             size_t uinp_max_line_len )
{
    memset( adsp_http, 0, sizeof(dsd_http_creator) );
    adsp_http->adsc_cbs      = adsp_cbs;
    adsp_http->achc_line     = (char*)(adsp_http + 1);
    adsp_http->uinc_line_max = uinp_max_line_len;
} // end of m_init_creator


/**
 * private function m_move_gather
 *    move current gather pointer for one byte
 *
 * @param[in/out]   dsd_gather_i_1  **aadsp_data    gather
*/
PRIVATE void m_move_gather( struct dsd_gather_i_1 **aadsp_data )
{
    // read next sign:
    (*aadsp_data)->achc_ginp_cur++;

    // still in current gather:
    while (    (*aadsp_data)                != NULL
            && (*aadsp_data)->achc_ginp_cur >= (*aadsp_data)->achc_ginp_end ) {
        *aadsp_data = (*aadsp_data)->adsc_next;
    }
} // end of m_move_gather


/**
 * private function m_get_hdr_line
 *   search for a header line in gather and copy it to our
 *   header line memory
 *   incoming gathers will be already marked!
 *
 * @param[in]       dsd_http_parser *adsp_http      parser handle
 * @param[in/out]   dsd_gather_i_1  **aadsp_data    data to be parsed
 * @param[out]      char            **aachp_line    pointer to found line
 * @param[out]      int             *ainp_len       length of found line
 * @return          BOOL                            FALSE = header is too long
*/
PRIVATE BOOL m_get_hdr_line( struct dsd_http_parser *adsp_http,
                             struct dsd_gather_i_1 **aadsp_data,
                             char **aachp_line, int *ainp_len    )
{
    // set output:
    if ( adsp_http->achc_inc_line == NULL ) {
        *aachp_line = &adsp_http->achc_header[adsp_http->uinc_hdr_pos];
    } else {
        *aachp_line = adsp_http->achc_inc_line;
    }
    *ainp_len = -1;

    // check for a folded uncomplete older line 
    if ( adsp_http->boc_check_folded == TRUE ) {
        adsp_http->boc_check_folded = FALSE;
        if (    *((*aadsp_data)->achc_ginp_cur) != 0x20
             && *((*aadsp_data)->achc_ginp_cur) != 0x09 ) {
            // set output length:
            *ainp_len = (int)(&adsp_http->achc_header[adsp_http->uinc_hdr_pos] - *aachp_line);

            // reset incomplete line marker:
            adsp_http->achc_inc_line = NULL;

            return (adsp_http->uinc_hdr_pos < adsp_http->uinc_hdr_len)?TRUE:FALSE;
        }
    }

    for ( ; ; ) {
        // copy line to linear buffer:
        while (    (*aadsp_data)                   != NULL                    /* valid gather    */
                && *((*aadsp_data)->achc_ginp_cur) != 0x0A                    /* eol '\n'        */
                && adsp_http->uinc_hdr_pos          < adsp_http->uinc_hdr_len /* space in buffer */ ) {
            // don't save unneeded new lines:
            if ( *((*aadsp_data)->achc_ginp_cur) != 0x0D ) {
                /*
                    For websocket keys number of whitespaces are important!
                    -> don't replace multiple whitespace by one whitespace
                */
#if 0
                /*
                   RFC 2616, Sec 2.2:
                   ------------------
                     All linear white space, including folding, has the same
                     semantics as SP. A recipient MAY replace any linear white
                     space with a single SP before interpreting the field
                     value or forwarding the message downstream.
                */
                if ( chrs_whitespace[*((*aadsp_data)->achc_ginp_cur)] == 1 ) {
                    if (    *aachp_line == &adsp_http->achc_header[adsp_http->uinc_hdr_pos] /* first sign */
                         || adsp_http->uinc_hdr_pos == 0
                         || adsp_http->achc_header[adsp_http->uinc_hdr_pos - 1] != 0x20 ) {
                        adsp_http->achc_header[adsp_http->uinc_hdr_pos] = 0x20;
                        adsp_http->uinc_hdr_pos++;
                    }
                } else {
                    adsp_http->achc_header[adsp_http->uinc_hdr_pos] = *((*aadsp_data)->achc_ginp_cur);
                    adsp_http->uinc_hdr_pos++;
                }
#endif
                adsp_http->achc_header[adsp_http->uinc_hdr_pos] = *((*aadsp_data)->achc_ginp_cur);
                adsp_http->uinc_hdr_pos++;
            }

            // read next sign:
            m_move_gather( aadsp_data );
        }

        // is this line complete ?
        if (    (*aadsp_data)                   != NULL
             && *((*aadsp_data)->achc_ginp_cur) == 0x0A ) {
            // move over 0x0A:
            m_move_gather( aadsp_data );

            // check for last line:
            if ( *aachp_line == &adsp_http->achc_header[adsp_http->uinc_hdr_pos] ) {
                *ainp_len = 0;
                adsp_http->achc_inc_line = NULL;
                break;
            }

            /*
               RFC 2616, Sec 2.2:
               ------------------
                 HTTP/1.1 header field values can be folded onto multiple lines
                 if the continuation line begins with a space or horizontal tab
            */
            if ( (*aadsp_data) == NULL ) {
                /*
                    we cannot control next byte 
                    see if header line is complete
                      -> wait for another call
                */
                adsp_http->boc_check_folded = TRUE;
                if ( adsp_http->achc_inc_line == NULL ) {
                    adsp_http->achc_inc_line = *aachp_line;
                }
                break;
            }
            if (    *((*aadsp_data)->achc_ginp_cur) == 0x20
                 || *((*aadsp_data)->achc_ginp_cur) == 0x09 ) {
                continue;
            }

            // set output length:
            *ainp_len = (int)(&adsp_http->achc_header[adsp_http->uinc_hdr_pos] - *aachp_line);

            // reset incomplete line marker:
            adsp_http->achc_inc_line = NULL;
        } else if ( adsp_http->achc_inc_line == NULL ) {
            // set incomplete line marker:
            adsp_http->achc_inc_line = *aachp_line;
        }
        break;
    }

    return (adsp_http->uinc_hdr_pos < adsp_http->uinc_hdr_len)?TRUE:FALSE;
} // end of m_get_hdr_line


/**
 * private function m_get_chunked_line
 *   search for a header line in gather and copy it to our
 *   header line memory
 *   incoming gathers will be already marked!
 *
 * @param[in]       dsd_http_parser *adsp_http      parser handle
 * @param[in/out]   dsd_gather_i_1  **aadsp_data    data to be parsed
 * @param[out]      char            **aachp_line    pointer to found line
 * @param[out]      int             *ainp_len       length of found line
 * @return          BOOL                            FALSE = header is too long
*/
PRIVATE BOOL m_get_chunked_line( struct dsd_http_parser *adsp_http,
                                 struct dsd_gather_i_1 **aadsp_data,
                                 char **aachp_line, int *ainp_len    )
{
    // set output:
    *aachp_line = &adsp_http->chc_chunked[0];
    *ainp_len   = -1;

    // copy line to linear buffer:
    while (    (*aadsp_data)                   != NULL                           /* valid gather    */
            && *((*aadsp_data)->achc_ginp_cur) != 0x0A                           /* eol '\n'        */
            && adsp_http->uinc_chk_off          < sizeof(adsp_http->chc_chunked) /* space in buffer */ ) {
        // don't save unneeded new lines:
        if ( *((*aadsp_data)->achc_ginp_cur) != 0x0D ) {
            adsp_http->chc_chunked[adsp_http->uinc_chk_off] = *((*aadsp_data)->achc_ginp_cur);
            adsp_http->uinc_chk_off++;
        }

        // read next sign:
        m_move_gather( aadsp_data );
    }

    // is this line complete ?
    if (    (*aadsp_data)                   != NULL
         && *((*aadsp_data)->achc_ginp_cur) == 0x0A ) {
        // move over 0x0A:
        m_move_gather( aadsp_data );

        // set output length:
        *ainp_len = (int)adsp_http->uinc_chk_off;
        adsp_http->uinc_chk_off = 0;
    }

    return (adsp_http->uinc_chk_off < sizeof(adsp_http->chc_chunked))?TRUE:FALSE;
} // end of m_get_chunked_line


/**
 * private function m_get_method
 *   get request method type
 *
 * @param[in]   const char          *achp_line  pointer to first header line
 * @param[in]   int                 inp_len     length of method
 * @return      ied_http_methods                method type
*/
PRIVATE enum ied_http_methods m_get_method( const char *achp_line, int inp_len )
{
    // initialize some variables:
    BOOL bol_ret;
    int  inl_result;
    int  inl_method = 0;

#define INL_LENGTH dss_http_methods[inl_method].inc_length
    while ( dss_http_methods[inl_method].achc_string != NULL ) {
        if (    inp_len > INL_LENGTH
             && achp_line[INL_LENGTH] == ' ' ) {
            bol_ret = m_cmpi_vx_vx( &inl_result,
                                    (void*)achp_line, INL_LENGTH, ied_chs_utf_8,
                                    (void*)dss_http_methods[inl_method].achc_string,
                                    INL_LENGTH, ied_chs_utf_8 );
            if (     bol_ret   == TRUE
                 && inl_result == 0    ) {
                return (enum ied_http_methods)inl_method;
            }
        }
        inl_method++;
    }
#undef INL_LENGTH

    return ied_mt_http_unknown;
} // end of m_get_method


/**
 * private function m_split_line
 *   get type and value of given line
 *
 * @param[in]   const char          *achp_line  pointer to header line
 * @param[in]   int                 inp_len     length of header line
 * @param[out]  char                **aachp_val pointer to value
 * @param[out]  int                 *ainp_val   length of value
 * @return      ied_http_hdr_lines              line type
*/
PRIVATE enum ied_http_hdr_lines m_split_line( const char *achp_line, int inp_len,
                                              char **aachp_val, int *ainp_val     )
{
    // initialize some variables:
    BOOL bol_ret;
    int  inl_result;
    int  inl_line = 0;

#define INL_LENGTH dss_http_hdr_lines[inl_line].inc_length
    while ( dss_http_hdr_lines[inl_line].achc_string != NULL ) {
        if (    inp_len > INL_LENGTH
             && chrs_delimiter[achp_line[INL_LENGTH]] == 1 ) {
            bol_ret = m_cmpi_vx_vx( &inl_result,
                                    (void*)achp_line, INL_LENGTH, ied_chs_utf_8,
                                    (void*)dss_http_hdr_lines[inl_line].achc_string,
                                    INL_LENGTH, ied_chs_utf_8 );
            if (    bol_ret    == TRUE
                 && inl_result == 0 ) {
                // get value of found line:
                *aachp_val = (char*)&achp_line[INL_LENGTH];
                while (    (*aachp_val) < &achp_line[inp_len]
                        && chrs_delimiter[**aachp_val] == 1    ) {
                    (*aachp_val)++;
                }
                *ainp_val = inp_len - (int)(*aachp_val - achp_line);

                return (enum ied_http_hdr_lines)inl_line;
            }
        }
        inl_line++;
    }
#undef INL_LENGTH

    return ied_hdr_ln_http_unknown;
} // end of m_split_line


/**
 * private function m_get_resp_version
 *   get HTTP version from given RESPONSE header line
 *
 * @param[in]   const char          *achp_line  pointer to header line
 * @param[in]   int                 inp_len     length of header line
 * @return      ied_http_versions               version
*/
PRIVATE enum ied_http_versions m_get_resp_version( const char *achp_line, int inp_len )
{
    // initialize some variables:
    BOOL bol_ret;
    int  inl_result;
    /*
        we are going backward, cause we think newer version
        are more common than older version!
    */
    int inl_version = (int)(sizeof(dss_http_versions)/sizeof(dsd_const_01)) - 1;

#define INL_LENGTH dss_http_versions[inl_version].inc_length
    while ( dss_http_versions[inl_version].achc_string != NULL ) {
        if (    inp_len > INL_LENGTH
             && achp_line[INL_LENGTH] == 0x20 ) {
            /*
                in HTTP response, HTTP version is first in first line
            */
            bol_ret = m_cmp_vx_vx( &inl_result,
                                   (void*)achp_line, INL_LENGTH, ied_chs_utf_8,
                                   (void*)dss_http_versions[inl_version].achc_string,
                                   INL_LENGTH, ied_chs_utf_8 );
            if (    bol_ret    == TRUE
                 && inl_result == 0    ) {
                return (enum ied_http_versions)inl_version;
            }
        }
        inl_version--;
    }
#undef INL_LENGTH

    return ied_vs_http_unknown;
} // end of m_get_resp_version


/**
 * private function m_get_resp_status
 *   get response status code
 *
 * @param[in]       const char          *achp_line      pointer to header line
 * @param[in]       int                 inp_len         length of header line
 * @param[in/out]   dsd_http_response   *adsp_rsp       response struture 
*/
PRIVATE void m_get_resp_status( const char *achp_line, int inp_len,
                                struct dsd_http_response *adsp_rsp )
{
    // initialize some variables:
    long long ill_status;
    char      *achl_end;

#define INL_LENGTH (dss_http_versions[adsp_rsp->ienc_version].inc_length + 1)
    ill_status = m_atoll( &achp_line[INL_LENGTH], inp_len - INL_LENGTH,
                          &achl_end, 10 );
    if (    achl_end   == &achp_line[INL_LENGTH] + 3
         && ill_status  > 0
         && ill_status  < 1000                       ) {
        adsp_rsp->ienc_status = (enum ied_http_status)ill_status;
        return;
    } else {
        adsp_rsp->ienc_status = ied_st_http_unknown;
    }
#undef INL_LENGTH
} // end of m_get_resp_status


/**
 * private function m_get_resp_key
 *   get response status keyword
 *
 * @param[in]       const char          *achp_line      pointer to header line
 * @param[in]       int                 inp_len         length of header line
 * @param[in/out]   dsd_http_response   *adsp_rsp       response struture 
*/
PRIVATE void m_get_resp_key( const char *achp_line, int inp_len,
                             struct dsd_http_response *adsp_rsp )
{    
#define INL_LENGTH (dss_http_versions[adsp_rsp->ienc_version].inc_length + 1 + 3 + 1)
    if ( inp_len - INL_LENGTH > 0 ) {
        adsp_rsp->achc_key    = (char*)&achp_line[INL_LENGTH];
        adsp_rsp->inc_len_key = inp_len - INL_LENGTH;
    }
#undef INL_LENGTH
} // end of m_get_resp_key


/**
 * private function m_get_req_version
 *   get HTTP version from given REQUEST header line
 *
 * @param[in]   const char          *achp_line  pointer to header line
 * @param[in]   int                 inp_len     length of header line
 * @return      ied_http_versions               version
*/
PRIVATE enum ied_http_versions m_get_req_version( const char *achp_line, int inp_len )
{
    // initialize some variables:
    BOOL bol_ret;
    int  inl_result;
    /*
        we are going backward, cause we think newer version
        are more common than older version!
    */
    int inl_version = (int)(sizeof(dss_http_versions)/sizeof(dsd_const_01)) - 1;

#define INL_LENGTH dss_http_versions[inl_version].inc_length
    while ( dss_http_versions[inl_version].achc_string != NULL ) {
        if ( inp_len > INL_LENGTH ) {
            /*
                in HTTP requests, HTTP version is last in first u.
                so we comparing the end of the given u.
            */
            bol_ret = m_cmp_vx_vx( &inl_result,
                                   (void*)&achp_line[inp_len - INL_LENGTH],
                                   INL_LENGTH, ied_chs_utf_8,
                                   (void*)dss_http_versions[inl_version].achc_string,
                                   INL_LENGTH, ied_chs_utf_8 );
            if (    bol_ret    == TRUE
                 && inl_result == 0    ) {
                return (enum ied_http_versions)inl_version;
            }
        }
        inl_version--;
    }
#undef INL_LENGTH

    return ied_vs_http_unknown;
} // end of m_get_req_version


/**
 * private function m_get_req_url
 *   get request url
 *
 * @param[in]       const char          *achp_line      pointer to header line
 * @param[in]       int                 inp_len         length of header line
 * @param[in/out]   dsd_http_parser     *adsp_http      parser structure 
*/
PRIVATE void m_get_req_url( const char *achp_line, int inp_len,
                            struct dsd_http_parser *adsp_http )
{
    // initialize some variables:
    char                *achl_surl;             // start of url
    char                *achl_eurl;             // end of url
    char                *achl_shost;            // start of host
    char                *achl_ehost;            // end of host
    char                *achl_spath;            // start of path
    char                *achl_epath;            // end of path
    char                *achl_query;            // query
    int                 inl_length;             // length
    enum ied_url_protos ienl_proto;

#define DSL_REQUEST (adsp_http->dsc_header.u.dsc_request)
    /*
        get url from request line:
           -> find start of url
           -> find end of url
    */
    achl_surl = (char*)&achp_line[ dss_http_methods[DSL_REQUEST.ienc_method].inc_length ];
    while (    achl_surl < &achp_line[inp_len]
            && chrs_whitespace[*achl_surl] == 1 ) {
        achl_surl++;
    }

    achl_eurl = achl_surl;
    while (    achl_eurl < &achp_line[inp_len]
            && chrs_whitespace[*achl_eurl] == 0  ) {
        achl_eurl++;
    }
    if ( achl_eurl == achl_surl ) {
        return;
    }

    /*
        split url into host - path - query
    */
    achl_spath = achl_surl;
    achl_epath = achl_eurl;
    switch ( *achl_surl ) {
        default:
            /*
                unknown sign:
                   -> check if this is a supported protocol
                   -> search end of host
                   -> encode as utf8
            */
            ienl_proto = m_get_protocol( achl_surl, (int)(achl_eurl - achl_surl) );
            if ( ienl_proto == ied_proto_not_supported ) {
                return;
            }

            achl_shost = &achl_surl[dss_url_protos[ienl_proto].inc_length];
            achl_ehost = &achl_surl[dss_url_protos[ienl_proto].inc_length];
            while (    achl_ehost   < achl_eurl
                    && *achl_ehost != '/'       ) {
                achl_ehost++;
            }

#ifdef DEF_CHS_IDNA_1 // ied_chs_idna_1 encoding not implemented yet in xslunic1.cpp
            inl_length = m_cpy_vx_vx( adsp_http->achc_url,
                                      (int)adsp_http->uinc_max_url,
                                      ied_chs_utf_8,
                                      achl_shost,
                                      (int)(achl_ehost - achl_shost),
                                      ied_chs_idna_1 );
#else
            inl_length = m_cpy_vx_vx( adsp_http->achc_url,
                                      (int)adsp_http->uinc_max_url,
                                      ied_chs_utf_8,
                                      achl_shost,
                                      (int)(achl_ehost - achl_shost),
                                      ied_chs_uri_1 );
#endif
            if ( inl_length < 1 ) {
                return;
            }
            DSL_REQUEST.ienc_proto   = ienl_proto;
            DSL_REQUEST.achc_host    = adsp_http->achc_url;
            DSL_REQUEST.inc_host_len = inl_length;

            achl_spath = achl_ehost;
            /* break is missing on purpose */

        case '/':
            /*
                absolute url:
                    -> get realpath (means remove "../" and format to utf8 encoding
                    -> search for query starting with '?' or '&'
            */
            inl_length = m_get_realpath( achl_spath, (int)(achl_epath - achl_spath),
                                         &adsp_http->achc_url[DSL_REQUEST.inc_host_len],
                                         (int)adsp_http->uinc_max_url - DSL_REQUEST.inc_host_len );
            if ( inl_length < 1 ) {
                return;
            }
            achl_spath = &adsp_http->achc_url[DSL_REQUEST.inc_host_len];
            achl_epath = &adsp_http->achc_url[DSL_REQUEST.inc_host_len + inl_length];

            achl_query = achl_spath;
            while (    achl_query   < achl_epath
                    && *achl_query != '?'
                    && *achl_query != '&'         ) {
                achl_query++;
            }

            if ( achl_query == achl_epath ) {
                DSL_REQUEST.achc_path    = achl_spath;
                DSL_REQUEST.inc_path_len = (int)(achl_epath - achl_spath);
            } else {
                DSL_REQUEST.achc_path     = achl_spath;
                DSL_REQUEST.inc_path_len  = (int)(achl_query - achl_spath);
                DSL_REQUEST.achc_query    = achl_query;
                DSL_REQUEST.inc_query_len = (int)(achl_epath - achl_query);
            }
            break;
    }

#undef DSL_REQUEST
} // end of m_get_req_url


/**
 * private function m_get_cvalue
 *    get char value
 *
 * @param[in]   char    chp_sign
 * @param[in]   int     inp_base
*/
PRIVATE int m_get_cvalue( char chp_sign, int inp_base )
{
    // initialize some variables:
    int inl_value;

    if ( chp_sign < '0' ) {
        return -1;
    }

    if ( '0' <= chp_sign && chp_sign <= '9' ) {
        inl_value = (int)(chp_sign - '0');
    } else if ( 'a' <= chp_sign && chp_sign <= 'z' ) {
        inl_value = (int)(chp_sign - 'a' + 10);
    } else if ( 'A' <= chp_sign && chp_sign <= 'Z' ) {
        inl_value = (int)(chp_sign - 'A' + 10);
    } else {
        return -1;
    }

    if ( inl_value >= inp_base ) {
        inl_value = -1;
    }
    return inl_value;
} // end of m_get_cvalue


/**
 * private function m_atoll
 *    transform given string to number
 *
 * @param[in]   const char  *achp_ptr           pointer to data
 * @param[in]   int         inp_length          length of data
 * @param[out]  char        **aachp_endptr      if given, point to end of number
 * @param[in]   int         inp_base            base
 * @return      long long
*/
PRIVATE long long m_atoll( const char *achp_ptr, int inp_length,
                           char **aachp_endptr,  int inp_base    )
{
    // initialize some variables:
    long long illl_result = 0;
    int       inl_off     = 0;
    BOOL      bol_negative;
    int       inl_value;

    // check incoming data:
    if (    inp_base      != 0 
         && (    inp_base  < 2
              || inp_base  > 36 ) ) {
        if ( aachp_endptr != NULL ) {
            *aachp_endptr = (char*)achp_ptr;
        }
        return 0;
    }

    // check if positiv or negativ:
    switch ( achp_ptr[inl_off] ) {
        case '-':
            bol_negative = TRUE;
            inl_off++;
            break;
        case '+':
            bol_negative = FALSE;
            inl_off++;
            break;
        default:
            bol_negative = FALSE;
            break;
    }
    if ( inl_off >= inp_length ) {
        if ( aachp_endptr != NULL ) {
            *aachp_endptr = (char*)achp_ptr;
        }
        return 0;
    }

    /*
        get base:
            -> If base is 0, determine the real base based on the beginning on
                the number; octal numbers begin with "0", hexadecimal with "0x",
                and the others are considered octal.
    */
    if ( achp_ptr[inl_off] == '0' ) {
        if (    ( inp_base == 0 || inp_base == 16 )
             && inl_off + 2 < inp_length
             && ( achp_ptr[inl_off + 1] == 'x' || achp_ptr[inl_off + 1] == 'X' ) ) {
            /* hexadecimal */
            inp_base = 16;
            inl_off += 2;
        } else if ( inp_base == 0 ) {
            /* octal */
            inp_base = 8;
        }
    } else if ( inp_base == 0 ) {
        inp_base = 10;
    }

    if ( bol_negative == FALSE ) {
        // read positive number:
        for ( ; inl_off < inp_length; inl_off++ ) {
            inl_value = m_get_cvalue( achp_ptr[inl_off], inp_base );
            if ( inl_value == -1 ) {
                break;
            }
            illl_result = inp_base * illl_result + inl_value;
        }
    } else {
        // read negative number:
        for ( ; inl_off < inp_length; inl_off++ ) {
            inl_value = m_get_cvalue( achp_ptr[inl_off], inp_base );
            if ( inl_value == -1 ) {
                break;
            }
            illl_result = inp_base * illl_result - inl_value;
        }
    }

    if ( aachp_endptr != NULL ) {
        *aachp_endptr = (char*)&achp_ptr[inl_off];
    }
    return illl_result;
} // end of m_atoll


/**
 * private function m_fbuffer
 *    fill buffer in printf style
 *
 * @param[in]   char        *achp_buffer
 * @param[in]   size_t      uinp_length
 * @param[in]   const char  *achp_format
 * @return      int                      
*/
PRIVATE int m_fbuffer( char *achp_buffer, size_t uinp_length,
                       const char *achp_format, ...           )
{
    // initialize some variables:
    int     inl_size;               // used buffer size
    va_list dsl_args;               // argument list

    // print in buffer:
    va_start( dsl_args, achp_format );
    inl_size = vsnprintf( achp_buffer, uinp_length, achp_format, dsl_args );
    va_end( dsl_args );

    // zero termination:
    if (    inl_size < 0
         || inl_size > (int)uinp_length ) {
        inl_size = -1;
    }
    return inl_size;
} // end of ds_wsp_helper::m_fbuffer


/**
 * private function m_equals_i
 *    compare two strings (first is zeroterminated)
 *    this function will ignore case!
 *
 * @param[in]   const char  *achp_str1          zero terminated string
 * @param[in]   const char  *achp_str2          string with length
 * @param[in]   int         inp_len2            length of second string
 * @return      BOOL
*/
PRIVATE BOOL m_equals_i( const char* achp_str1,
                         const char* achp_str2, int inp_len2 )
{
    BOOL bol_ret;
    int  inl_result;

    bol_ret = m_cmpi_vx_vx( &inl_result, 
                            (void*)achp_str1,       -1, ied_chs_utf_8,
                            (void*)achp_str2, inp_len2, ied_chs_utf_8 );

    return (bol_ret == TRUE && inl_result == 0)?TRUE:FALSE;
} // end of m_equals_i


/**
 * private function m_add_hdr_line
 *   add given line to our header structure
 *   read length information field
 *
 * @param[in]   dsd_http_parser *adsp_http      parser handle
 * @param[in]   const char      *achp_line      pointer to header line
 * @param[in]   int             inp_length      length of header line
 * @return      BOOL                            TRUE = success
*/
PRIVATE BOOL m_add_hdr_line( struct dsd_http_parser *adsp_http,
                             const char* achp_line, int inp_length )
{
    // initialize some variables:
    BOOL                     bol_ret;           // return for compare
    char                     *achl_value;       // pointer to line value
    int                      inl_length;        // length of line value
    struct dsd_http_hdr_line *adsl_line;        // line to be filled
    long long                ill_result;        // length result
    char                     *achl_end;         // end pointer

    if ( adsp_http->dsc_header.uinc_lines < adsp_http->uinc_max_lines ) {
        adsl_line = &adsp_http->dsc_header.adsc_lines[adsp_http->dsc_header.uinc_lines];
        adsl_line->ienc_type = m_split_line( achp_line, inp_length,
                                             &achl_value, &inl_length );
        if ( adsl_line->ienc_type == ied_hdr_ln_http_unknown ) {
            /*
                unknown header line
                  -> save it as complete line
            */
            adsl_line->u.dsc_unkown.achc_line  = (char*)achp_line;
            adsl_line->u.dsc_unkown.inc_length = inp_length;
        } else {
            /*
                known header line
                  -> save it with key/value
                  -> have a look for length information
                  -> have a look for host information
            */
            adsl_line->u.dsc_known.achc_value = achl_value;
            adsl_line->u.dsc_known.inc_length = inl_length;

            if ( adsp_http->ienc_len_info == ied_not_set ) {
                switch ( adsl_line->ienc_type ) {
                    case ied_hdr_ln_http_content_length:
                        // get length:
                        ill_result = m_atoll( achl_value, inl_length, &achl_end, 10 );
                        if (    achl_end   == achl_value /* no valid number */
                             || ill_result  < 0          /* negativ length  */ ) {
                            break;
                        }
                        adsp_http->ienc_len_info = ied_content_len;
                        adsp_http->uilc_length   = (unsigned long long)ill_result;
                        break;
                    case ied_hdr_ln_http_connection:
                        bol_ret = m_equals_i( DEF_KW_CLOSE, achl_value, inl_length );
                        if ( bol_ret == TRUE ) {
                            adsp_http->ienc_len_info = ied_until_close;
                        }
                        break;
                    case ied_hdr_ln_http_transfer_encoding:
                        bol_ret = m_equals_i( DEF_KW_CHUNKED, achl_value, inl_length );
                        if ( bol_ret == TRUE ) {
                            adsp_http->ienc_len_info = ied_chunked;
                        }
                        break;
                    default:
                        break;
                }
            }

            if (    adsp_http->dsc_header.inc_type == DEF_HTTP_REQUEST
                 && adsp_http->dsc_header.u.dsc_request.inc_host_len < 1
                 && adsl_line->ienc_type == ied_hdr_ln_http_host       ) {
#ifdef DEF_CHS_IDNA_1 // ied_chs_idna_1 encoding not implemented yet in xslunic1.cpp
                inl_length = m_cpy_vx_vx( adsp_http->achc_url,
                                         (int)adsp_http->uinc_max_url,
                                         ied_chs_utf_8,
                                         achl_shost,
                                         (int)(achl_ehost - achl_shost),
                                         ied_chs_idna_1 );
#else
                inl_length = m_cpy_vx_vx( &adsp_http->achc_url[   adsp_http->dsc_header.u.dsc_request.inc_path_len
                                                                + adsp_http->dsc_header.u.dsc_request.inc_query_len ],
                                             (int)adsp_http->uinc_max_url
                                           - adsp_http->dsc_header.u.dsc_request.inc_path_len
                                           - adsp_http->dsc_header.u.dsc_request.inc_query_len,
                                          ied_chs_utf_8,
                                          achl_value, inl_length, ied_chs_uri_1 );
#endif
                if ( inl_length > 1 ) {
                    adsp_http->dsc_header.u.dsc_request.achc_host = &adsp_http->achc_url[   adsp_http->dsc_header.u.dsc_request.inc_path_len
                                                                                          + adsp_http->dsc_header.u.dsc_request.inc_query_len ];
                    adsp_http->dsc_header.u.dsc_request.inc_host_len = inl_length;
                }
            }
        }
        adsp_http->dsc_header.uinc_lines++;
        return TRUE;
    }
    return FALSE;
} // end of m_add_hdr_line


/**
 * private function m_add_trl_line
 *   add given line to our trailer structure
 *
 * @param[in]   dsd_http_parser *adsp_http      parser handle
 * @param[in]   const char      *achp_line      pointer to header line
 * @param[in]   int             inp_length      length of header line
 * @return      BOOL                            TRUE = success
*/
PRIVATE BOOL m_add_trl_line( struct dsd_http_parser *adsp_http,
                             const char* achp_line, int inp_length )
{
    // initialize some variables:
    char                     *achl_value;       // pointer to line value
    int                      inl_length;        // length of line value
    struct dsd_http_hdr_line *adsl_line;        // line to be filled

    if ( adsp_http->dsc_trailer.adsc_lines == NULL ) {
        adsp_http->dsc_trailer.adsc_lines = &adsp_http->dsc_header.adsc_lines[adsp_http->dsc_header.uinc_lines];
    }

    if (   adsp_http->dsc_header.uinc_lines
         + adsp_http->dsc_trailer.uinc_lines < adsp_http->uinc_max_lines ) {
        adsl_line = &adsp_http->dsc_trailer.adsc_lines[adsp_http->dsc_trailer.uinc_lines];
        adsl_line->ienc_type = m_split_line( achp_line, inp_length,
                                             &achl_value, &inl_length );
        if ( adsl_line->ienc_type == ied_hdr_ln_http_unknown ) {
            /*
                unknown header line
                  -> save it as complete line
            */
            adsl_line->u.dsc_unkown.achc_line  = (char*)achp_line;
            adsl_line->u.dsc_unkown.inc_length = inp_length;
        } else {
            /*
                known header line
                  -> save it with key/value
                  -> have a look for length information
            */
            adsl_line->u.dsc_known.achc_value = achl_value;
            adsl_line->u.dsc_known.inc_length = inl_length;
        }
        adsp_http->dsc_trailer.uinc_lines++;
        return TRUE;
    }
    return FALSE;
} // end of m_add_trl_line


/**
 * private function m_is_websocket 
 *   check if given go over end of line sines (\r\n) at the beginning of data
 *
 * @param[in]   dsd_http_header *adsp_header    header
 * @return      BOOL                            TRUE = is websocket
*/
PRIVATE BOOL m_is_websocket( struct dsd_http_header *adsp_header )
{
    // initialize some variables:
    struct dsd_http_hdr_line *adsl_line;
    size_t                   uinl_line;
    BOOL                     bol_ret;

    /*
        to indicate a request or response as a websocket handshake we use:

        1.) version must be HTTP/1.1
        2.) request  -> method must be GET
            response -> status must be 101 (Switching Protocols)
        3.) header line "Upgrade: websocket" must be present
        4.) header line "Connection: upgrade" must be present
    */

    switch ( adsp_header->inc_type ) {
        case DEF_HTTP_REQUEST:
            if (    adsp_header->u.dsc_request.ienc_version != ied_vs_http_1_1
                 || adsp_header->u.dsc_request.ienc_method  != ied_mt_http_get ) {
                return FALSE;
            }
            break;
        case DEF_HTTP_RESPONSE:
            if (    adsp_header->u.dsc_response.ienc_version != ied_vs_http_1_1
                 || adsp_header->u.dsc_response.ienc_status  != ied_st_http_switching_protocols ) {
                return FALSE;
            }
            break;
    }

    /*
        3.) check for "Upgrade: websocket" line:
    */
    uinl_line = 0;
    bol_ret   = FALSE;
    for ( uinl_line = 0; uinl_line < adsp_header->uinc_lines; uinl_line++ ) {
        adsl_line = m_search_hdr_line( adsp_header,
                                       ied_hdr_ln_http_upgrade, &uinl_line );
        if ( adsl_line == NULL ) {
            return FALSE;
        }
        bol_ret = m_equals_i( DEF_KW_WEBSOCKET,
                              adsl_line->u.dsc_known.achc_value,
                              adsl_line->u.dsc_known.inc_length );
        if ( bol_ret == TRUE ) {
            break;
        }        
    }
    if ( bol_ret == FALSE ) {
        return FALSE;
    }

    /*
        4.) check for "Connection: upgrade" line:
    */
    uinl_line = 0;
    bol_ret   = FALSE;
    for ( uinl_line = 0; uinl_line < adsp_header->uinc_lines; uinl_line++ ) {
        adsl_line = m_search_hdr_line( adsp_header,
                                       ied_hdr_ln_http_connection, &uinl_line );
        if ( adsl_line == NULL ) {
            return FALSE;
        }
        bol_ret = m_equals_i( DEF_KW_UPGRADE,
                              adsl_line->u.dsc_known.achc_value,
                              adsl_line->u.dsc_known.inc_length );
        if ( bol_ret == TRUE ) {
            break;
        }        
    }
    return bol_ret;
} // end of m_is_websocket


/**
 * private function m_ignore_eol 
 *   go over end of line sines (\r\n) at the beginning of data
 *
 * @param[in]   dsd_http_parser *adsp_http      parser handle
 * @param[in]   dsd_gather_i_1  *adsp_data      data to be parsed
 * @return      BOOL                            TRUE = success
*/
PRIVATE BOOL m_ignore_eol( struct dsd_http_parser *adsp_http,
                           struct dsd_gather_i_1  *adsp_data )
{
    /*
          http://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html
          In the interest of robustness, servers SHOULD ignore any
          empty line(s) received where a Request-Line is expected.
          In other words, if the server is reading the protocol stream
          at the beginning of a message and receives a CRLF first, it
          should ignore the CRLF. 
    */

    while (    adsp_data                        != NULL
            && (    *(adsp_data->achc_ginp_cur) == 0x0D
                 || *(adsp_data->achc_ginp_cur) == 0x0A ) ) {
        m_move_gather( &adsp_data );
    }

    if ( adsp_data != NULL ) {
        // set next parsing function
        adsp_http->amc_parser = &m_parse_first_line;
        return m_parse_first_line( adsp_http, adsp_data );
    }
    return TRUE;
} // end of m_ignore_eol


/**
 * private function m_parse_first_line
 *   parse first line of incoming data
 *   decide whether  - this has valid HTTP format
 *                   - this is a request or a response
 *
 * @param[in]   dsd_http_parser *adsp_http      parser handle
 * @param[in]   dsd_gather_i_1  *adsp_data      data to be parsed
 * @return      BOOL                            TRUE = success
*/
PRIVATE BOOL m_parse_first_line( struct dsd_http_parser *adsp_http,
                                 struct dsd_gather_i_1  *adsp_data )
{
    // initialize some variables:
    BOOL                   bol_ret;             // return for several functions
    char                   *achl_line;          // pointer to found line
    int                    inl_length;          // length of found line
    enum ied_http_methods  ienl_method;         // request method
    struct dsd_http_header *adsl_hdr;           // header

    //-------------------------------------------
    // get first line from data block:
    //-------------------------------------------
    bol_ret = m_get_hdr_line( adsp_http, &adsp_data, &achl_line, &inl_length );
    if (    bol_ret    == FALSE     /* header to long      */
         || inl_length == 0         /* first line is empty */ ) {
        m_init_parser( adsp_http, adsp_http->adsc_cbs,
                       adsp_http->uinc_hdr_len,
                       adsp_http->uinc_max_lines,
                       adsp_http->uinc_max_url );
        return FALSE;
    }
    if ( inl_length < 0 ) {
        // no line found yet -> return and wait for more data
        return TRUE;
    }

    //-------------------------------------------
    // is this request or response?
    //-------------------------------------------
    adsl_hdr    = &adsp_http->dsc_header;
    ienl_method = m_get_method( achl_line, inl_length );
    if ( ienl_method == ied_mt_http_unknown ) {
        /*
            response
        */
        adsl_hdr->inc_type = DEF_HTTP_RESPONSE;
        adsl_hdr->u.dsc_response.ienc_version = m_get_resp_version( achl_line,
                                                                    inl_length );
        if ( adsl_hdr->u.dsc_response.ienc_version == ied_vs_http_unknown ) {
            // not a valid response
            m_init_parser( adsp_http, adsp_http->adsc_cbs,
                           adsp_http->uinc_hdr_len,
                           adsp_http->uinc_max_lines,
                           adsp_http->uinc_max_url );
            return FALSE;
        }

        // get response status:
        m_get_resp_status( achl_line, inl_length, &adsl_hdr->u.dsc_response );
        if ( adsl_hdr->u.dsc_response.ienc_status == ied_st_http_unknown ) {
            // not a valid response
            m_init_parser( adsp_http, adsp_http->adsc_cbs,
                           adsp_http->uinc_hdr_len,
                           adsp_http->uinc_max_lines,
                           adsp_http->uinc_max_url );
            return FALSE;
        }

        // get response key word:
        m_get_resp_key( achl_line, inl_length, &adsl_hdr->u.dsc_response );
    } else {
        /*
            request
        */
        adsl_hdr->inc_type                  = DEF_HTTP_REQUEST;
        adsl_hdr->u.dsc_request.ienc_method = ienl_method;

        // check for a valid version:
        adsl_hdr->u.dsc_request.ienc_version = m_get_req_version( achl_line,
                                                                  inl_length );
        if ( adsl_hdr->u.dsc_request.ienc_version == ied_vs_http_unknown ) {
            // not a valid request!
            m_init_parser( adsp_http, adsp_http->adsc_cbs,
                           adsp_http->uinc_hdr_len,
                           adsp_http->uinc_max_lines,
                           adsp_http->uinc_max_url );
            return FALSE;
        }

        // get requested url:
        m_get_req_url( achl_line, inl_length, adsp_http );
        if ( adsl_hdr->u.dsc_request.inc_path_len < 1 ) {
            // not a valid request!
            m_init_parser( adsp_http, adsp_http->adsc_cbs,
                           adsp_http->uinc_hdr_len,
                           adsp_http->uinc_max_lines,
                           adsp_http->uinc_max_url );
            return FALSE;
        }
    }

    // set next parsing function
    adsp_http->amc_parser = &m_parse_line;
    if ( adsp_data != NULL ) {
        return m_parse_line( adsp_http, adsp_data );
    }
    return TRUE;
} // end of m_parse_first_line


/**
 * private function m_parse_line
 *   parse all (except first) lines of incoming data
 *
 * @param[in]   dsd_http_parser *adsp_http      parser handle
 * @param[in]   dsd_gather_i_1  *adsp_data      data to be parsed
 * @return      BOOL                            TRUE = success
*/
PRIVATE BOOL m_parse_line( struct dsd_http_parser *adsp_http,
                           struct dsd_gather_i_1  *adsp_data )
{
    // initialize some variables:
    BOOL bol_ret;                       // return for several functions
    char *achl_line;                    // pointer to found line
    int  inl_length;                    // length of found line

    for ( ; ; ) {
        // get next line from data block:
        bol_ret = m_get_hdr_line( adsp_http, &adsp_data, &achl_line, &inl_length );
        if ( bol_ret == FALSE ) {
            // header to long!
            m_init_parser( adsp_http, adsp_http->adsc_cbs,
                           adsp_http->uinc_hdr_len,
                           adsp_http->uinc_max_lines,
                           adsp_http->uinc_max_url );
            return FALSE;
        }
        switch ( inl_length ) {
            case -1:
                /*
                    no line found yet
                       -> return and wait for another call
                */
                return TRUE;

            case 0:
                /*
                    terminating header line
                       -> check if this is a websocket request
                       -> call header complete function
                       -> check if body will follow
                       -> call next parser
                */

                /*
                    check for websocket handshake request
                */
                bol_ret = m_is_websocket( &adsp_http->dsc_header );
                if ( bol_ret == TRUE ) {
                    if (    adsp_http->adsc_cbs
                         && adsp_http->adsc_cbs->amc_ws_handshake ) {
                        /* websocket support is enabled */
                        adsp_http->boc_websocket = TRUE;
                        adsp_http->amc_parser = &m_ws_handshake;
                        return adsp_http->amc_parser( adsp_http, adsp_data );         
                    } else {
                        /* websocket should not be supported */
                        m_init_parser( adsp_http, adsp_http->adsc_cbs,
                                       adsp_http->uinc_hdr_len,
                                       adsp_http->uinc_max_lines,
                                       adsp_http->uinc_max_url );
                        return FALSE; // quit
                    }
                } else if (    adsp_http->adsc_cbs
                            && adsp_http->adsc_cbs->amc_header_compl ) {
                    bol_ret = adsp_http->adsc_cbs->amc_header_compl(
                                            adsp_http->adsc_cbs->avc_usrfld,
                                            &adsp_http->dsc_header );
                    if ( bol_ret == FALSE ) {
                        // header function returned FALSE!
                        m_init_parser( adsp_http, adsp_http->adsc_cbs,
                                       adsp_http->uinc_hdr_len,
                                       adsp_http->uinc_max_lines,
                                       adsp_http->uinc_max_url );
                        return FALSE; // quit
                    }
                }

                // in HTTP/1.0, a response with no length info
                if (    adsp_http->dsc_header.inc_type                    == DEF_HTTP_RESPONSE
                     && adsp_http->dsc_header.u.dsc_response.ienc_version == ied_vs_http_1_0
                     && adsp_http->ienc_len_info                          == ied_not_set       ) {
                    adsp_http->ienc_len_info = ied_until_close;
                }

                // set next parser function:
                switch( adsp_http->ienc_len_info ) {
                    case ied_not_set:
                        /*
                            no body following
                              -> call body complete function (empty)
                              -> parser back to start
                        */
                        if (    adsp_http->adsc_cbs
                             && adsp_http->adsc_cbs->amc_data_block ) {
                            bol_ret = adsp_http->adsc_cbs->amc_data_block(
                                            adsp_http->adsc_cbs->avc_usrfld,
                                            &adsp_http->dsc_header, NULL );
                            if ( bol_ret == FALSE ) {
                                // header function returned FALSE!
                                m_init_parser( adsp_http, adsp_http->adsc_cbs,
                                               adsp_http->uinc_hdr_len,
                                               adsp_http->uinc_max_lines,
                                               adsp_http->uinc_max_url );
                                return FALSE; // quit
                            }
                        }
                        // reset parser:
                        m_init_parser( adsp_http, adsp_http->adsc_cbs,
                                       adsp_http->uinc_hdr_len,
                                       adsp_http->uinc_max_lines,
                                       adsp_http->uinc_max_url );
                        break;

                    case ied_content_len:
                        /*
                            body with content-length
                        */
                        adsp_http->amc_parser = &m_pass_length;
                        break;

                    case ied_chunked:
                        /*
                            body with chunked length:
                        */
                        adsp_http->amc_parser = &m_pass_chunked;
                        break;

                    case ied_until_close:
                        /*
                            data until connection close:
                        */
                        adsp_http->amc_parser = &m_pass_all;
                        break;
                }

                // call next parser function:
                if ( adsp_data != NULL ) {
                    return adsp_http->amc_parser( adsp_http, adsp_data );
                }
                return TRUE;

            default:
                /*
                    add line to our header structure:
                */
                bol_ret = m_add_hdr_line( adsp_http, achl_line, inl_length );
                if ( bol_ret == FALSE ) {
                    m_init_parser( adsp_http, adsp_http->adsc_cbs,
                                   adsp_http->uinc_hdr_len,
                                   adsp_http->uinc_max_lines,
                                   adsp_http->uinc_max_url );
                    return FALSE;
                }
                break;
        }
    }
} // end of m_parse_line



/**
 * private function m_parse_trailer
 *   parse trailing lines of incoming data
 *
 * @param[in]   dsd_http_parser *adsp_http      parser handle
 * @param[in]   dsd_gather_i_1  *adsp_data      data to be parsed
 * @return      BOOL                            TRUE = success
*/
PRIVATE BOOL m_parse_trailer( struct dsd_http_parser *adsp_http,
                              struct dsd_gather_i_1  *adsp_data )
{
    // initialize some variables:
    BOOL bol_ret;                       // return for several functions
    char *achl_line;                    // pointer to found line
    int  inl_length;                    // length of found line

    for ( ; ; ) {
        // get next line from data block:
        bol_ret = m_get_hdr_line( adsp_http, &adsp_data, &achl_line, &inl_length );
        if ( bol_ret == FALSE ) {
            // header to long!
            m_init_parser( adsp_http, adsp_http->adsc_cbs,
                           adsp_http->uinc_hdr_len,
                           adsp_http->uinc_max_lines,
                           adsp_http->uinc_max_url );
            return FALSE;
        }
        switch ( inl_length ) {
            case -1:
                /*
                    no line found yet
                       -> return and wait for another call
                */
                return TRUE;

            case 0:
                /*
                    terminating trailer line
                       -> call trailer complete function
                       -> reset parser and quit
                */
                if (    adsp_http->adsc_cbs
                     && adsp_http->adsc_cbs->amc_trailer_compl ) {
                    bol_ret = adsp_http->adsc_cbs->amc_trailer_compl(
                                        adsp_http->adsc_cbs->avc_usrfld,
                                        &adsp_http->dsc_header,
                                        &adsp_http->dsc_trailer );
                }
                m_init_parser( adsp_http, adsp_http->adsc_cbs,
                               adsp_http->uinc_hdr_len,
                               adsp_http->uinc_max_lines,
                               adsp_http->uinc_max_url );
                return bol_ret;

            default:
                /*
                    add line to our trailer structure:
                */
                bol_ret = m_add_trl_line( adsp_http, achl_line, inl_length );
                if ( bol_ret == FALSE ) {
                    m_init_parser( adsp_http, adsp_http->adsc_cbs,
                                   adsp_http->uinc_hdr_len,
                                   adsp_http->uinc_max_lines,
                                   adsp_http->uinc_max_url );
                    return FALSE;
                }
                break;
        }
    }
} // end of m_parse_trailer


/**
 * private function m_pass_to_worker
 *    pass available data to worker function
 *    calculate remaining length
 *
 * @param[in]   dsd_http_parser *adsp_http      parser handle
 * @param[in]   dsd_gather_i_1  **aadsp_data    data to be parsed
 * @return      BOOL                            TRUE = success
*/
PRIVATE BOOL m_pass_to_worker( struct dsd_http_parser *adsp_http,
                               struct dsd_gather_i_1  **aadsp_data )
{
    // initialize some variables:
    struct dsd_gather_i_1 *adsl_gather;
    struct dsd_gather_i_1 *adsl_next   = NULL;
    char                  *achl_end    = NULL;
    BOOL                  bol_ret;

    /*
        there is somebody who wants to work with this data
           -> calculate available data
           -> call worker function
           -> calculate processed data
    */

    // calculate available data:
    adsl_gather = *aadsp_data;
    while (    adsl_gather            != NULL
            && adsp_http->uilc_length  > 0
            && (unsigned long long)
               (   adsl_gather->achc_ginp_end
                 - adsl_gather->achc_ginp_cur ) <= adsp_http->uilc_length ) {
        adsp_http->uilc_length -= (unsigned long long)
                                  (   adsl_gather->achc_ginp_end
                                    - adsl_gather->achc_ginp_cur );
        adsl_gather = adsl_gather->adsc_next;
    }

    if ( adsl_gather != NULL ) {
        /*
            there is more data available than our required length
               -> save orginal end pointer
               -> set new to end of data block
               -> save original next pointer
        */
        achl_end = adsl_gather->achc_ginp_end;
        adsl_gather->achc_ginp_end =   adsl_gather->achc_ginp_cur
                                     + adsp_http->uilc_length;

        adsl_next = adsl_gather->adsc_next;
        adsl_gather->adsc_next = NULL;
    }

    /*
        call body data function
    */
    bol_ret = adsp_http->adsc_cbs->amc_data_block( 
                                adsp_http->adsc_cbs->avc_usrfld,
                                &adsp_http->dsc_header, *aadsp_data );
    if ( bol_ret == FALSE ) {
        // header function returned FALSE!
        return FALSE; // quit
    }
    
    /*
        calculate processed data:
    */
    while ( *aadsp_data != adsl_gather ) {
        if ( ((*aadsp_data)->achc_ginp_end - (*aadsp_data)->achc_ginp_cur) > 0 ) {
            adsp_http->uilc_length += (   (*aadsp_data)->achc_ginp_end
                                        - (*aadsp_data)->achc_ginp_cur );
        }
        (*aadsp_data) = (*aadsp_data)->adsc_next;
    }
    if ( adsl_gather != NULL ) {
        adsp_http->uilc_length += (   adsl_gather->achc_ginp_end
                                    - adsl_gather->achc_ginp_cur );
        /*
            reset original pointer:
        */
        adsl_gather->achc_ginp_end = achl_end;
        adsl_gather->adsc_next     = adsl_next;
    }
    return TRUE;
} // end of m_pass_to_worker


/**
 * private function m_mark_data
 *    mark available data as processed
 *    calculate remaining length
 *
 * @param[in]   dsd_http_parser *adsp_http      parser handle
 * @param[in]   dsd_gather_i_1  **aadsp_data    data to be parsed
*/
PRIVATE void m_mark_data( struct dsd_http_parser *adsp_http,
                          struct dsd_gather_i_1  **aadsp_data )
{
    /*
        there is nobody who wants to work with this data
           -> just mark as processed
    */
    while (    (*aadsp_data)          != NULL
            && adsp_http->uilc_length  > 0   ) {
        if ( adsp_http->uilc_length >= (unsigned long long)
                                       (   (*aadsp_data)->achc_ginp_end
                                         - (*aadsp_data)->achc_ginp_cur ) ) {
            /*
                whole gather are body data
                   -> increment length
                   -> mark gather as processed
                   -> get next gather
            */
            adsp_http->uilc_length -= (   (*aadsp_data)->achc_ginp_end
                                        - (*aadsp_data)->achc_ginp_cur );
            (*aadsp_data)->achc_ginp_cur = (*aadsp_data)->achc_ginp_end;
            (*aadsp_data) = (*aadsp_data)->adsc_next;
        } else {
            /*
                just a rest of gather is body data
                   -> mark body data as processed
                   -> length to zero
            */
            (*aadsp_data)->achc_ginp_cur += adsp_http->uilc_length;
            adsp_http->uilc_length = 0;
        }
    }
} // end of m_mark_data


/**
 * private function m_ws_handshake
 *  handle websocket handshake
 *
 * @param[in]   dsd_http_parser *adsp_http      parser handle
 * @param[in]   dsd_gather_i_1  *adsp_data      data to be parsed
 * @return      BOOL                            TRUE = success
*/
PRIVATE BOOL m_ws_handshake( struct dsd_http_parser *adsp_http,
                             struct dsd_gather_i_1  *adsp_data )
{
    BOOL                   bol_ret;
        
    /* call handshake callback function */
    bol_ret = adsp_http->adsc_cbs->amc_ws_handshake(
                                            adsp_http->adsc_cbs->avc_usrfld,
                                            &adsp_http->dsc_header,
                                            adsp_data );
    if ( bol_ret == FALSE ) {
        /* handshake function returned FALSE */
        m_init_parser( adsp_http, adsp_http->adsc_cbs,
                       adsp_http->uinc_hdr_len,
                       adsp_http->uinc_max_lines,
                       adsp_http->uinc_max_url );
        return FALSE; // quit
    }

    while (    adsp_data                != NULL
            && adsp_data->achc_ginp_cur >= adsp_data->achc_ginp_end ) {
        adsp_data = adsp_data->adsc_next;
    }

    /* pass all data to caller */
    adsp_http->amc_parser = &m_pass_all;
    if ( adsp_data != NULL ) {
        return adsp_http->amc_parser( adsp_http, adsp_data );
    }
    return TRUE;
} // end of m_ws_handshake


/**
 * private function m_pass_length
 *   pass body with content length
 *
 * @param[in]   dsd_http_parser *adsp_http      parser handle
 * @param[in]   dsd_gather_i_1  *adsp_data      data to be parsed
 * @return      BOOL                            TRUE = success
*/
PRIVATE BOOL m_pass_length( struct dsd_http_parser *adsp_http,
                            struct dsd_gather_i_1  *adsp_data )
{
    // initialize some variables:
    BOOL bol_ret;

    if (    adsp_http->adsc_cbs
         && adsp_http->adsc_cbs->amc_data_block ) {
        /*
            there is somebody who wants to work with this data
        */
        bol_ret = m_pass_to_worker( adsp_http, &adsp_data );
        if ( bol_ret == FALSE ) {
            m_init_parser( adsp_http, adsp_http->adsc_cbs,
                           adsp_http->uinc_hdr_len,
                           adsp_http->uinc_max_lines,
                           adsp_http->uinc_max_url );
            return FALSE;
        }
    } else {
        /*
            there is nobody who wants to work with this data
        */
        m_mark_data( adsp_http, &adsp_data );
    }

    if ( adsp_http->uilc_length > 0 ) {
        // wait for more data
        return TRUE; 
    }
    
    /*
        data is complete
           -> call data block handle with empty data
              to signal end of data
    */
    if (    adsp_http->adsc_cbs
         && adsp_http->adsc_cbs->amc_data_block ) {
        bol_ret = adsp_http->adsc_cbs->amc_data_block( 
                                    adsp_http->adsc_cbs->avc_usrfld,
                                    &adsp_http->dsc_header, NULL );
        if ( bol_ret == FALSE ) {
            // header function returned FALSE!
            m_init_parser( adsp_http, adsp_http->adsc_cbs,
                           adsp_http->uinc_hdr_len,
                           adsp_http->uinc_max_lines,
                           adsp_http->uinc_max_url );
            return FALSE; // quit
        }
    }

    // reset parser:
    m_init_parser( adsp_http, adsp_http->adsc_cbs,
                   adsp_http->uinc_hdr_len,
                   adsp_http->uinc_max_lines,
                   adsp_http->uinc_max_url );
    if ( adsp_data != NULL ) {
        return adsp_http->amc_parser( adsp_http, adsp_data );
    }
    return TRUE;
} // end of m_pass_length


/**
 * private function m_pass_chunked
 *   pass body with chunked length information
 *
 * @param[in]   dsd_http_parser *adsp_http      parser handle
 * @param[in]   dsd_gather_i_1  *adsp_data      data to be parsed
 * @return      BOOL                            TRUE = success
*/
PRIVATE BOOL m_pass_chunked( struct dsd_http_parser *adsp_http,
                             struct dsd_gather_i_1  *adsp_data )
{
    // initialize some variables:
    BOOL      bol_ret;                          // return for several functions
    char      *achl_line;                       // pointer to found line
    int       inl_line;                         // length of line
    long long ill_length;                       // length of datablock
    char      *achl_end;                        // end pointer


    do {
        /*
            read length of next data block:
        */
        if ( adsp_http->uilc_length == 0 ) {
            // get length line:
            bol_ret = m_get_chunked_line( adsp_http, &adsp_data,
                                          &achl_line, &inl_line );
            if ( bol_ret == FALSE ) {
                return FALSE;
            }
            switch ( inl_line ) {
                case 0:
                    /*
                        empty line
                          -> means end of chunked block
                          -> new length if following
                    */
                    continue;

                case -1:
                    /*
                        line not complete
                          -> wait for more data
                    */
                    return TRUE;

                default:
                    /*
                       read the length
                    */
                    ill_length = m_atoll( achl_line, inl_line, &achl_end, 16 );
                    if (    ill_length < 0
                         || achl_end == achl_line ) {
                        // invalid length or other signs following
                        m_init_parser( adsp_http, adsp_http->adsc_cbs,
                                       adsp_http->uinc_hdr_len,
                                       adsp_http->uinc_max_lines,
                                       adsp_http->uinc_max_url );
                        return FALSE;
                    }
                    adsp_http->uilc_length = (unsigned long long)ill_length;

                    /*
                        length 0 is last chunked block
                    */
                    if ( adsp_http->uilc_length == 0 ) {
                        /*
                            call data block handle with empty data
                            to signal end of data
                        */
                        if (    adsp_http->adsc_cbs
                             && adsp_http->adsc_cbs->amc_data_block ) {
                            bol_ret = adsp_http->adsc_cbs->amc_data_block(
                                            adsp_http->adsc_cbs->avc_usrfld,
                                            &adsp_http->dsc_header, NULL );
                            if ( bol_ret == FALSE ) {
                                // header function returned FALSE!
                                m_init_parser( adsp_http, adsp_http->adsc_cbs,
                                               adsp_http->uinc_hdr_len,
                                               adsp_http->uinc_max_lines,
                                               adsp_http->uinc_max_url );
                                return FALSE; // quit
                            }
                        }

                        /*
                            trailer might follow
                        */
                        adsp_http->amc_parser = &m_parse_trailer;
                        if ( adsp_data != NULL ) {
                            return m_parse_trailer( adsp_http, adsp_data );
                        }
                        return TRUE;
                    }
                    break;
            }
        } // end of if


        /*
            handle this data data:
        */
        if ( adsp_data != NULL ) {
            if (    adsp_http->adsc_cbs
                 && adsp_http->adsc_cbs->amc_data_block ) {
                /*
                    there is somebody who wants to work with this data
                */
                bol_ret = m_pass_to_worker( adsp_http, &adsp_data );
                if ( bol_ret == FALSE ) {
                    m_init_parser( adsp_http, adsp_http->adsc_cbs,
                                   adsp_http->uinc_hdr_len,
                                   adsp_http->uinc_max_lines,
                                   adsp_http->uinc_max_url );
                    return FALSE;
                }
            } else {
                /*
                    there is nobody who wants to work with this data
                */
                m_mark_data( adsp_http, &adsp_data );
            }
        }
    } while (    adsp_data              != NULL
              && adsp_http->uilc_length == 0    );

    /*
        if we reach this state, some data is
        missing (adsp_http->uilc_length > 0)
    */
    return TRUE;
} // end of m_pass_chunked


/**
 * private function m_pass_all
 *   pass all following data as body
 *
 * @param[in]   dsd_http_parser *adsp_http      parser handle
 * @param[in]   dsd_gather_i_1  *adsp_data      data to be parsed
 * @return      BOOL                            TRUE = success
*/
PRIVATE BOOL m_pass_all( struct dsd_http_parser *adsp_http,
                         struct dsd_gather_i_1  *adsp_data )
{
    // initialize some variables:
    BOOL bol_ret;

    if (    adsp_http->adsc_cbs
         && adsp_http->adsc_cbs->amc_data_block ) {
        /*
            call body data function
        */
        bol_ret = adsp_http->adsc_cbs->amc_data_block( 
                                    adsp_http->adsc_cbs->avc_usrfld,
                                    &adsp_http->dsc_header,
									adsp_data);
        if ( bol_ret == FALSE ) {
            // header function returned FALSE!
            m_init_parser( adsp_http, adsp_http->adsc_cbs,
                           adsp_http->uinc_hdr_len,
                           adsp_http->uinc_max_lines,
                           adsp_http->uinc_max_url );
            return FALSE; // quit
        }
    } else {
        /*
            there is nobody who wants to work with this data
               -> just mark as processed
        */
        while ( adsp_data != NULL ) {
            adsp_data->achc_ginp_cur = adsp_data->achc_ginp_end;
            adsp_data = adsp_data->adsc_next;
        }
    }
    return TRUE;
} // end of m_pass_all
